{"path": "Mathlib/ModelTheory/Quotients.lean", "imports": ["Mathlib/Data/Fintype/Quotient.lean", "Mathlib/ModelTheory/Semantics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.Prestructure", "code": "class Prestructure (s : Setoid M) where\n  toStructure : L.Structure M\n  fun_equiv : \u2200 {n} {f : L.Functions n} (x y : Fin n \u2192 M), x \u2248 y \u2192 funMap f x \u2248 funMap f y\n  rel_equiv : \u2200 {n} {r : L.Relations n} (x y : Fin n \u2192 M) (_ : x \u2248 y), RelMap r x = RelMap r y", "start": [34, 1], "end": [39, 95], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.quotientStructure", "code": "instance quotientStructure : L.Structure (Quotient s) where\n  funMap {n} f x :=\n    Quotient.map (@funMap L M ps.toStructure n f) Prestructure.fun_equiv (Quotient.finChoice x)\n  RelMap {n} r x :=\n    Quotient.lift (@RelMap L M ps.toStructure n r) Prestructure.rel_equiv (Quotient.finChoice x)", "start": [48, 1], "end": [52, 97], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.funMap_quotient_mk'", "code": "theorem funMap_quotient_mk' {n : \u2115} (f : L.Functions n) (x : Fin n \u2192 M) :\n    (funMap f fun i => (\u27e6x i\u27e7 : Quotient s)) = \u27e6@funMap _ _ ps.toStructure _ f x\u27e7", "start": [57, 1], "end": [62, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.relMap_quotient_mk'", "code": "theorem relMap_quotient_mk' {n : \u2115} (r : L.Relations n) (x : Fin n \u2192 M) :\n    (RelMap r fun i => (\u27e6x i\u27e7 : Quotient s)) \u2194 @RelMap _ _ ps.toStructure _ r x", "start": [65, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Term.realize_quotient_mk'", "code": "theorem Term.realize_quotient_mk' {\u03b2 : Type*} (t : L.Term \u03b2) (x : \u03b2 \u2192 M) :\n    (t.realize fun i => (\u27e6x i\u27e7 : Quotient s)) = \u27e6@Term.realize _ _ ps.toStructure _ x t\u27e7", "start": [73, 1], "end": [77, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/ElementaryMaps.lean", "imports": ["Mathlib/ModelTheory/Substructures.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.ElementaryEmbedding", "code": "structure ElementaryEmbedding where\n  toFun : M \u2192 N\n  map_formula' :\n    \u2200 \u2983n\u2984 (\u03c6 : L.Formula (Fin n)) (x : Fin n \u2192 M), \u03c6.Realize (toFun \u2218 x) \u2194 \u03c6.Realize x := by\n    intros; trivial", "start": [45, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.funLike", "code": "instance funLike : FunLike (M \u21aa\u2091[L] N) M fun _ => N where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    simp only [ElementaryEmbedding.mk.injEq]\n    ext x\n    exact Function.funext_iff.1 h x", "start": [71, 1], "end": [78, 36], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_boundedFormula", "code": "@[simp]\ntheorem map_boundedFormula (f : M \u21aa\u2091[L] N) {\u03b1 : Type*} {n : \u2115} (\u03c6 : L.BoundedFormula \u03b1 n)\n    (v : \u03b1 \u2192 M) (xs : Fin n \u2192 M) : \u03c6.Realize (f \u2218 v) (f \u2218 xs) \u2194 \u03c6.Realize v xs", "start": [84, 1], "end": [101, 61], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_formula", "code": "@[simp]\ntheorem map_formula (f : M \u21aa\u2091[L] N) {\u03b1 : Type*} (\u03c6 : L.Formula \u03b1) (x : \u03b1 \u2192 M) :\n    \u03c6.Realize (f \u2218 x) \u2194 \u03c6.Realize x", "start": [104, 1], "end": [107, 97], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_sentence", "code": "theorem map_sentence (f : M \u21aa\u2091[L] N) (\u03c6 : L.Sentence) : M \u22a8 \u03c6 \u2194 N \u22a8 \u03c6", "start": [110, 1], "end": [111, 92], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.theory_model_iff", "code": "theorem theory_model_iff (f : M \u21aa\u2091[L] N) (T : L.Theory) : M \u22a8 T \u2194 N \u22a8 T", "start": [114, 1], "end": [115, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.elementarilyEquivalent", "code": "theorem elementarilyEquivalent (f : M \u21aa\u2091[L] N) : M \u2245[L] N", "start": [119, 1], "end": [120, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.injective", "code": "@[simp]\ntheorem injective (\u03c6 : M \u21aa\u2091[L] N) : Function.Injective \u03c6", "start": [123, 1], "end": [131, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.embeddingLike", "code": "instance embeddingLike : EmbeddingLike (M \u21aa\u2091[L] N) M N :=\n  { show FunLike (M \u21aa\u2091[L] N) M fun _ => N from inferInstance with injective' := injective }", "start": [134, 1], "end": [135, 92], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_fun", "code": "@[simp]\ntheorem map_fun (\u03c6 : M \u21aa\u2091[L] N) {n : \u2115} (f : L.Functions n) (x : Fin n \u2192 M) :\n    \u03c6 (funMap f x) = funMap f (\u03c6 \u2218 x)", "start": [138, 1], "end": [143, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_rel", "code": "@[simp]\ntheorem map_rel (\u03c6 : M \u21aa\u2091[L] N) {n : \u2115} (r : L.Relations n) (x : Fin n \u2192 M) :\n    RelMap r (\u03c6 \u2218 x) \u2194 RelMap r x", "start": [146, 1], "end": [150, 4], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.strongHomClass", "code": "instance strongHomClass : StrongHomClass L (M \u21aa\u2091[L] N) M N where\n  map_fun := map_fun\n  map_rel := map_rel", "start": [153, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.map_constants", "code": "@[simp]\ntheorem map_constants (\u03c6 : M \u21aa\u2091[L] N) (c : L.Constants) : \u03c6 c = c", "start": [158, 1], "end": [160, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.toEmbedding", "code": "def toEmbedding (f : M \u21aa\u2091[L] N) : M \u21aa[L] N where\n  toFun := f\n  inj' := f.injective\n  map_fun' {_} f x := by aesop\n  map_rel' {_} R x := by aesop", "start": [163, 1], "end": [168, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.toHom", "code": "def toHom (f : M \u21aa\u2091[L] N) : M \u2192[L] N where\n  toFun := f\n  map_fun' {_} f x := by aesop\n  map_rel' {_} R x := by aesop", "start": [171, 1], "end": [175, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.toEmbedding_toHom", "code": "@[simp]\ntheorem toEmbedding_toHom (f : M \u21aa\u2091[L] N) : f.toEmbedding.toHom = f.toHom", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.coe_toHom", "code": "@[simp]\ntheorem coe_toHom {f : M \u21aa\u2091[L] N} : (f.toHom : M \u2192 N) = (f : M \u2192 N)", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.coe_toEmbedding", "code": "@[simp]\ntheorem coe_toEmbedding (f : M \u21aa\u2091[L] N) : (f.toEmbedding : M \u2192 N) = (f : M \u2192 N)", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.coe_injective", "code": "theorem coe_injective : @Function.Injective (M \u21aa\u2091[L] N) (M \u2192 N) (\u2191)", "start": [193, 1], "end": [194, 24], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.ext", "code": "@[ext]\ntheorem ext \u2983f g : M \u21aa\u2091[L] N\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [197, 1], "end": [199, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.ext_iff", "code": "theorem ext_iff {f g : M \u21aa\u2091[L] N} : f = g \u2194 \u2200 x, f x = g x", "start": [202, 1], "end": [203, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.refl", "code": "@[refl]\ndef refl : M \u21aa\u2091[L] M where toFun := id", "start": [208, 1], "end": [210, 39], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : M) : refl L M x = x", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.comp", "code": "@[trans]\ndef comp (hnp : N \u21aa\u2091[L] P) (hmn : M \u21aa\u2091[L] N) : M \u21aa\u2091[L] P where\n  toFun := hnp \u2218 hmn\n  map_formula' n \u03c6 x := by\n    cases' hnp with _ hhnp\n    cases' hmn with _ hhmn\n    erw [hhnp, hhmn]", "start": [223, 1], "end": [230, 21], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : N \u21aa\u2091[L] P) (f : M \u21aa\u2091[L] N) (x : M) : g.comp f x = g (f x)", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.comp_assoc", "code": "theorem comp_assoc (f : M \u21aa\u2091[L] N) (g : N \u21aa\u2091[L] P) (h : P \u21aa\u2091[L] Q) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [238, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.elementaryDiagram", "code": "abbrev elementaryDiagram : L[[M]].Theory :=\n  L[[M]].completeTheory M", "start": [248, 1], "end": [251, 26], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementaryEmbedding.ofModelsElementaryDiagram", "code": "@[simps]\ndef ElementaryEmbedding.ofModelsElementaryDiagram (N : Type*) [L.Structure N] [L[[M]].Structure N]\n    [(lhomWithConstants L M).IsExpansionOn N] [N \u22a8 L.elementaryDiagram M] : M \u21aa\u2091[L] N :=\n  \u27e8((\u2191) : L[[M]].Constants \u2192 N) \u2218 Sum.inr, fun n \u03c6 x => by\n    refine'\n      _root_.trans _\n        ((realize_iff_of_model_completeTheory M N\n              (((L.lhomWithConstants M).onBoundedFormula \u03c6).subst\n                  (Constants.term \u2218 Sum.inr \u2218 x)).alls).trans\n          _)\n    \u00b7 simp_rw [Sentence.Realize, BoundedFormula.realize_alls, BoundedFormula.realize_subst,\n        LHom.realize_onBoundedFormula, Formula.Realize, Unique.forall_iff, Function.comp,\n        Term.realize_constants]\n    \u00b7 simp_rw [Sentence.Realize, BoundedFormula.realize_alls, BoundedFormula.realize_subst,\n        LHom.realize_onBoundedFormula, Formula.Realize, Unique.forall_iff]\n      rfl\u27e9", "start": [254, 1], "end": [271, 11], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Embedding.isElementary_of_exists", "code": "theorem isElementary_of_exists (f : M \u21aa[L] N)\n    (htv :\n      \u2200 (n : \u2115) (\u03c6 : L.BoundedFormula Empty (n + 1)) (x : Fin n \u2192 M) (a : N),\n        \u03c6.Realize default (Fin.snoc (f \u2218 x) a : _ \u2192 N) \u2192\n          \u2203 b : M, \u03c6.Realize default (Fin.snoc (f \u2218 x) (f b) : _ \u2192 N)) :\n    \u2200 {n} (\u03c6 : L.Formula (Fin n)) (x : Fin n \u2192 M), \u03c6.Realize (f \u2218 x) \u2194 \u03c6.Realize x", "start": [278, 1], "end": [310, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Embedding.toElementaryEmbedding", "code": "@[simps]\ndef toElementaryEmbedding (f : M \u21aa[L] N)\n    (htv :\n      \u2200 (n : \u2115) (\u03c6 : L.BoundedFormula Empty (n + 1)) (x : Fin n \u2192 M) (a : N),\n        \u03c6.Realize default (Fin.snoc (f \u2218 x) a : _ \u2192 N) \u2192\n          \u2203 b : M, \u03c6.Realize default (Fin.snoc (f \u2218 x) (f b) : _ \u2192 N)) :\n    M \u21aa\u2091[L] N :=\n  \u27e8f, fun _ => f.isElementary_of_exists htv\u27e9", "start": [313, 1], "end": [321, 45], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.toElementaryEmbedding", "code": "def toElementaryEmbedding (f : M \u2243[L] N) : M \u21aa\u2091[L] N where\n  toFun := f\n  map_formula' n \u03c6 x := by aesop", "start": [328, 1], "end": [331, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.toElementaryEmbedding_toEmbedding", "code": "@[simp]\ntheorem toElementaryEmbedding_toEmbedding (f : M \u2243[L] N) :\n    f.toElementaryEmbedding.toEmbedding = f.toEmbedding", "start": [334, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.coe_toElementaryEmbedding", "code": "@[simp]\ntheorem coe_toElementaryEmbedding (f : M \u2243[L] N) :\n    (f.toElementaryEmbedding : M \u2192 N) = (f : M \u2192 N)", "start": [340, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.realize_term_substructure", "code": "@[simp]\ntheorem realize_term_substructure {\u03b1 : Type*} {S : L.Substructure M} (v : \u03b1 \u2192 S) (t : L.Term \u03b1) :\n    t.realize ((\u2191) \u2218 v) = (\u2191(t.realize v) : M)", "start": [348, 1], "end": [351, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.realize_boundedFormula_top", "code": "@[simp]\ntheorem realize_boundedFormula_top {\u03b1 : Type*} {n : \u2115} {\u03c6 : L.BoundedFormula \u03b1 n}\n    {v : \u03b1 \u2192 (\u22a4 : L.Substructure M)} {xs : Fin n \u2192 (\u22a4 : L.Substructure M)} :\n    \u03c6.Realize v xs \u2194 \u03c6.Realize (((\u2191) : _ \u2192 M) \u2218 v) ((\u2191) \u2218 xs)", "start": [356, 1], "end": [361, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.realize_formula_top", "code": "@[simp]\ntheorem realize_formula_top {\u03b1 : Type*} {\u03c6 : L.Formula \u03b1} {v : \u03b1 \u2192 (\u22a4 : L.Substructure M)} :\n    \u03c6.Realize v \u2194 \u03c6.Realize (((\u2191) : (\u22a4 : L.Substructure M) \u2192 M) \u2218 v)", "start": [364, 1], "end": [368, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.IsElementary", "code": "def IsElementary (S : L.Substructure M) : Prop :=\n  \u2200 \u2983n\u2984 (\u03c6 : L.Formula (Fin n)) (x : Fin n \u2192 S), \u03c6.Realize (((\u2191) : _ \u2192 M) \u2218 x) \u2194 \u03c6.Realize x", "start": [371, 1], "end": [374, 93], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure", "code": "structure ElementarySubstructure where\n  toSubstructure : L.Substructure M\n  isElementary' : toSubstructure.IsElementary", "start": [381, 1], "end": [385, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.instCoe", "code": "instance instCoe : Coe (L.ElementarySubstructure M) (L.Substructure M) :=\n  \u27e8ElementarySubstructure.toSubstructure\u27e9", "start": [396, 1], "end": [397, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.instSetLike", "code": "instance instSetLike : SetLike (L.ElementarySubstructure M) M :=\n  \u27e8fun x => x.toSubstructure.carrier, fun \u27e8\u27e8s, hs1\u27e9, hs2\u27e9 \u27e8\u27e8t, ht1\u27e9, _\u27e9 _ => by\n    congr\u27e9", "start": [400, 1], "end": [402, 11], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.inducedStructure", "code": "instance inducedStructure (S : L.ElementarySubstructure M) : L.Structure S :=\n  Substructure.inducedStructure", "start": [405, 1], "end": [406, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.isElementary", "code": "@[simp]\ntheorem isElementary (S : L.ElementarySubstructure M) : (S : L.Substructure M).IsElementary", "start": [410, 1], "end": [412, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.subtype", "code": "def subtype (S : L.ElementarySubstructure M) : S \u21aa\u2091[L] M where\n  toFun := (\u2191)\n  map_formula' := S.isElementary", "start": [415, 1], "end": [418, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.coeSubtype", "code": "@[simp]\ntheorem coeSubtype {S : L.ElementarySubstructure M} : \u21d1S.subtype = ((\u2191) : S \u2192 M)", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.instTop", "code": "instance instTop : Top (L.ElementarySubstructure M) :=\n  \u27e8\u27e8\u22a4, fun _ _ _ => Substructure.realize_formula_top.symm\u27e9\u27e9", "start": [426, 1], "end": [428, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.instInhabited", "code": "instance instInhabited : Inhabited (L.ElementarySubstructure M) :=\n  \u27e8\u22a4\u27e9", "start": [431, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.mem_top", "code": "@[simp]\ntheorem mem_top (x : M) : x \u2208 (\u22a4 : L.ElementarySubstructure M)", "start": [435, 1], "end": [437, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : L.ElementarySubstructure M) : Set M) = Set.univ", "start": [440, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.realize_sentence", "code": "@[simp]\ntheorem realize_sentence (S : L.ElementarySubstructure M) (\u03c6 : L.Sentence) : S \u22a8 \u03c6 \u2194 M \u22a8 \u03c6", "start": [445, 1], "end": [447, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.theory_model_iff", "code": "@[simp]\ntheorem theory_model_iff (S : L.ElementarySubstructure M) (T : L.Theory) : S \u22a8 T \u2194 M \u22a8 T", "start": [450, 1], "end": [452, 49], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.theory_model", "code": "instance theory_model {T : L.Theory} [h : M \u22a8 T] {S : L.ElementarySubstructure M} : S \u22a8 T :=\n  (theory_model_iff S T).2 h", "start": [456, 1], "end": [457, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.instNonempty", "code": "instance instNonempty [Nonempty M] {S : L.ElementarySubstructure M} : Nonempty S :=\n  (model_nonemptyTheory_iff L).1 inferInstance", "start": [461, 1], "end": [462, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.elementarilyEquivalent", "code": "theorem elementarilyEquivalent (S : L.ElementarySubstructure M) : S \u2245[L] M", "start": [465, 1], "end": [466, 35], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.isElementary_of_exists", "code": "theorem isElementary_of_exists (S : L.Substructure M)\n    (htv :\n      \u2200 (n : \u2115) (\u03c6 : L.BoundedFormula Empty (n + 1)) (x : Fin n \u2192 S) (a : M),\n        \u03c6.Realize default (Fin.snoc ((\u2191) \u2218 x) a : _ \u2192 M) \u2192\n          \u2203 b : S, \u03c6.Realize default (Fin.snoc ((\u2191) \u2218 x) b : _ \u2192 M)) :\n    S.IsElementary", "start": [473, 1], "end": [479, 68], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.toElementarySubstructure", "code": "@[simps]\ndef toElementarySubstructure (S : L.Substructure M)\n    (htv :\n      \u2200 (n : \u2115) (\u03c6 : L.BoundedFormula Empty (n + 1)) (x : Fin n \u2192 S) (a : M),\n        \u03c6.Realize default (Fin.snoc ((\u2191) \u2218 x) a : _ \u2192 M) \u2192\n          \u2203 b : S, \u03c6.Realize default (Fin.snoc ((\u2191) \u2218 x) b : _ \u2192 M)) :\n    L.ElementarySubstructure M :=\n  \u27e8S, S.isElementary_of_exists htv\u27e9", "start": [482, 1], "end": [490, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Stonean/Basic.lean", "imports": ["Mathlib/CategoryTheory/Sites/Coherent.lean", "Mathlib/Topology/Category/CompHaus/Projective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/Topology/ExtremallyDisconnected.lean"], "premises": [{"full_name": "Stonean", "code": "structure Stonean where\n  \n  compHaus : CompHaus.{u}\n  \n  [extrDisc : ExtremallyDisconnected compHaus]", "start": [40, 1], "end": [45, 47], "kind": "commanddeclaration"}, {"full_name": "CompHaus.toStonean", "code": "@[simps!]\ndef toStonean (X : CompHaus.{u}) [Projective X] :\n    Stonean where\n  compHaus := X", "start": [70, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "Stonean.toCompHaus", "code": "@[simps!]\ndef toCompHaus : Stonean.{u} \u2964 CompHaus.{u} :=\n  inducedFunctor _", "start": [84, 1], "end": [87, 19], "kind": "commanddeclaration"}, {"full_name": "Stonean.of", "code": "def of (X : Type*) [TopologicalSpace X] [CompactSpace X] [T2Space X]\n    [ExtremallyDisconnected X] : Stonean :=\n  \u27e8\u27e8\u27e8X, inferInstance\u27e9\u27e9\u27e9", "start": [89, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "Stonean.instTopologicalSpace", "code": "instance instTopologicalSpace (X : Stonean.{u}) : TopologicalSpace X :=\n  show TopologicalSpace X.compHaus from inferInstance", "start": [110, 1], "end": [112, 54], "kind": "commanddeclaration"}, {"full_name": "Stonean.toProfinite", "code": "@[simps]\ndef toProfinite : Stonean.{u} \u2964 Profinite.{u} where\n  obj X :=\n    { toCompHaus := X.compHaus,\n      IsTotallyDisconnected := show TotallyDisconnectedSpace X from inferInstance }\n  map f := f", "start": [125, 1], "end": [131, 13], "kind": "commanddeclaration"}, {"full_name": "Stonean.isoOfHomeo", "code": "@[simps! hom inv]\nnoncomputable\ndef isoOfHomeo {X Y : Stonean} (f : X \u2243\u209c Y) : X \u2245 Y :=\n  @asIso _ _ _ _ \u27e8f, f.continuous\u27e9\n  (@isIso_of_reflects_iso _ _ _ _ _ _ _ toCompHaus (IsIso.of_iso (CompHaus.isoOfHomeo f)) _)", "start": [145, 1], "end": [150, 93], "kind": "commanddeclaration"}, {"full_name": "Stonean.homeoOfIso", "code": "@[simps!]\ndef homeoOfIso {X Y : Stonean} (f : X \u2245 Y) : X \u2243\u209c Y := CompHaus.homeoOfIso (toCompHaus.mapIso f)", "start": [152, 1], "end": [154, 97], "kind": "commanddeclaration"}, {"full_name": "Stonean.isoEquivHomeo", "code": "@[simps!]\nnoncomputable\ndef isoEquivHomeo {X Y : Stonean} : (X \u2245 Y) \u2243 (X \u2243\u209c Y) where\n  toFun := homeoOfIso\n  invFun := isoOfHomeo\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl", "start": [156, 1], "end": [164, 29], "kind": "commanddeclaration"}, {"full_name": "Stonean.mkFinite", "code": "def mkFinite (X : Type*) [Finite X] [TopologicalSpace X] [DiscreteTopology X] : Stonean where\n  compHaus := CompHaus.of X\n  extrDisc := by\n    dsimp\n    constructor\n    intro U _\n    apply isOpen_discrete (closure U)", "start": [166, 1], "end": [175, 38], "kind": "commanddeclaration"}, {"full_name": "Stonean.epi_iff_surjective", "code": "lemma epi_iff_surjective {X Y : Stonean} (f : X \u27f6 Y) :\n    Epi f \u2194 Function.Surjective f := by\n  refine \u27e8?_, ConcreteCategory.epi_of_surjective _\u27e9\n  dsimp [Function.Surjective]\n  intro h y\n  by_contra' hy\n  let C := Set.range f\n  have hC : IsClosed C := (isCompact_range f.continuous).isClosed\n  let U := C\u1d9c\n  have hUy : U \u2208 nhds y := by\n    simp only [Set.mem_range, hy, exists_false, not_false_eq_true, hC.compl_mem_nhds]\n  obtain \u27e8V, hV, hyV, hVU\u27e9 := isTopologicalBasis_clopen.mem_nhds_iff.mp hUy\n  classical\n  let g : Y \u27f6 mkFinite (ULift (Fin 2)) :=\n    \u27e8(LocallyConstant.ofClopen hV).map ULift.up, LocallyConstant.continuous _\u27e9\n  let h : Y \u27f6 mkFinite (ULift (Fin 2)) := \u27e8fun _ => \u27e81\u27e9, continuous_const\u27e9\n  have H : h = g := by\n    rw [\u2190 cancel_epi f]\n    ext x\n    apply ULift.ext change 1 = ite _ _ _ rw [if_neg]\n    refine mt (hVU \u00b7) ?_ simpa only [Set.mem_compl_iff, Set.mem_range, not_exists, not_forall, not_not]\n      using exists_apply_eq_apply f x\n  apply_fun fun e => (e y).down at H\n  change 1 = ite _ _ _ at H rw [if_pos hyV] at H\n  exact one_ne_zero H", "start": [177, 1], "end": [211, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.presentation", "code": "noncomputable\ndef presentation (X : CompHaus) : Stonean where\n  compHaus := (projectivePresentation X).p\n  extrDisc := by\n    refine' CompactT2.Projective.extremallyDisconnected\n      (@fun Y Z _ _ _ _ _ _ f g hfcont hgcont hgsurj => _)\n    let g\u2081 : (CompHaus.of Y) \u27f6 (CompHaus.of Z) := \u27e8g, hgcont\u27e9\n    let f\u2081 : (projectivePresentation X).p \u27f6 (CompHaus.of Z) := \u27e8f, hfcont\u27e9\n    have hg\u2081 : Epi g\u2081 := (epi_iff_surjective _).2 hgsurj\n    refine' \u27e8Projective.factorThru f\u2081 g\u2081, (Projective.factorThru f\u2081 g\u2081).2, funext (fun _ => _)\u27e9\n    change (Projective.factorThru f\u2081 g\u2081 \u226b g\u2081) _ = f _\n    rw [Projective.factorThru_comp]\n    rfl", "start": [247, 1], "end": [262, 8], "kind": "commanddeclaration"}, {"full_name": "CompHaus.presentation.\u03c0", "code": "noncomputable\ndef presentation.\u03c0 (X : CompHaus) : X.presentation.compHaus \u27f6 X :=\n  (projectivePresentation X).f", "start": [264, 1], "end": [267, 31], "kind": "commanddeclaration"}, {"full_name": "CompHaus.presentation.epi_\u03c0", "code": "noncomputable\ninstance presentation.epi_\u03c0 (X : CompHaus) : Epi (\u03c0 X) :=\n  (projectivePresentation X).epi", "start": [269, 1], "end": [272, 33], "kind": "commanddeclaration"}, {"full_name": "CompHaus.lift", "code": "noncomputable\ndef lift {X Y : CompHaus} {Z : Stonean} (e : Z.compHaus \u27f6 Y) (f : X \u27f6 Y) [Epi f] :\n    Z.compHaus \u27f6 X :=\n  Projective.factorThru e f", "start": [274, 1], "end": [290, 28], "kind": "commanddeclaration"}, {"full_name": "CompHaus.lift_lifts", "code": "@[simp, reassoc]\nlemma lift_lifts {X Y : CompHaus} {Z : Stonean} (e : Z.compHaus \u27f6 Y) (f : X \u27f6 Y) [Epi f] :\n    lift e f \u226b f = e := by simp [lift]", "start": [292, 1], "end": [294, 39], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.Gleason", "code": "lemma Gleason (X : CompHaus.{u}) :\n    Projective X \u2194 ExtremallyDisconnected X := by\n  constructor\n  \u00b7 intro h\n    show ExtremallyDisconnected X.toStonean\n    infer_instance\n  \u00b7 intro h\n    let X' : Stonean := \u27e8X\u27e9\n    show Projective X'.compHaus\n    apply Stonean.instProjectiveCompHausCategoryCompHaus", "start": [296, 1], "end": [305, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.presentation", "code": "noncomputable\ndef presentation (X : Profinite) : Stonean where\n  compHaus := X.toCompHaus.projectivePresentation.p\n  extrDisc := X.toCompHaus.presentation.extrDisc", "start": [311, 1], "end": [316, 49], "kind": "commanddeclaration"}, {"full_name": "Profinite.presentation.\u03c0", "code": "noncomputable\ndef presentation.\u03c0 (X : Profinite) : Stonean.toProfinite.obj X.presentation \u27f6 X :=\n  X.toCompHaus.projectivePresentation.f", "start": [318, 1], "end": [321, 40], "kind": "commanddeclaration"}, {"full_name": "Profinite.presentation.epi_\u03c0", "code": "noncomputable\ninstance presentation.epi_\u03c0 (X : Profinite) : Epi (\u03c0 X) := by\n  have := X.toCompHaus.projectivePresentation.epi\n  rw [CompHaus.epi_iff_surjective] at this\n  rw [epi_iff_surjective]\n  exact this", "start": [323, 1], "end": [329, 13], "kind": "commanddeclaration"}, {"full_name": "Profinite.lift", "code": "noncomputable\ndef lift {X Y : Profinite} {Z : Stonean} (e : Stonean.toProfinite.obj Z \u27f6 Y) (f : X \u27f6 Y) [Epi f] :\n    Stonean.toProfinite.obj Z \u27f6 X := CompHaus.lift e f", "start": [331, 1], "end": [346, 55], "kind": "commanddeclaration"}, {"full_name": "Profinite.lift_lifts", "code": "@[simp, reassoc]\nlemma lift_lifts {X Y : Profinite} {Z : Stonean} (e : Stonean.toProfinite.obj Z \u27f6 Y) (f : X \u27f6 Y)\n    [Epi f] : lift e f \u226b f = e := CompHaus.lift_lifts _ _", "start": [348, 1], "end": [350, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.projective_of_extrDisc", "code": "lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :\n    Projective X := by\n  show Projective (Stonean.toProfinite.obj \u27e8X.toCompHaus\u27e9)\n  exact inferInstance", "start": [352, 1], "end": [355, 22], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/DFinsupp/NeLocus.lean", "imports": ["Mathlib/Data/DFinsupp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFinsupp.neLocus", "code": "def neLocus (f g : \u03a0\u2080 a, N a) : Finset \u03b1 :=\n  (f.support \u222a g.support).filter fun x \u21a6 f x \u2260 g x", "start": [34, 1], "end": [37, 51], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_neLocus", "code": "@[simp]\ntheorem mem_neLocus {f g : \u03a0\u2080 a, N a} {a : \u03b1} : a \u2208 f.neLocus g \u2194 f a \u2260 g a", "start": [40, 1], "end": [43, 47], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.not_mem_neLocus", "code": "theorem not_mem_neLocus {f g : \u03a0\u2080 a, N a} {a : \u03b1} : a \u2209 f.neLocus g \u2194 f a = g a", "start": [46, 1], "end": [47, 35], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_neLocus", "code": "@[simp]\ntheorem coe_neLocus : \u2191(f.neLocus g) = { x | f x \u2260 g x }", "start": [50, 1], "end": [52, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_eq_empty", "code": "@[simp]\ntheorem neLocus_eq_empty {f g : \u03a0\u2080 a, N a} : f.neLocus g = \u2205 \u2194 f = g", "start": [55, 1], "end": [59, 97], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.nonempty_neLocus_iff", "code": "@[simp]\ntheorem nonempty_neLocus_iff {f g : \u03a0\u2080 a, N a} : (f.neLocus g).Nonempty \u2194 f \u2260 g", "start": [62, 1], "end": [64, 58], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_comm", "code": "theorem neLocus_comm : f.neLocus g = g.neLocus f", "start": [67, 1], "end": [68, 48], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_zero_right", "code": "@[simp]\ntheorem neLocus_zero_right : f.neLocus 0 = f.support", "start": [71, 1], "end": [74, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_zero_left", "code": "@[simp]\ntheorem neLocus_zero_left : (0 : \u03a0\u2080 a, N a).neLocus f = f.support", "start": [77, 1], "end": [79, 50], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subset_mapRange_neLocus", "code": "theorem subset_mapRange_neLocus [\u2200 a, DecidableEq (N a)] [\u2200 a, DecidableEq (M a)] (f g : \u03a0\u2080 a, N a)\n    {F : \u2200 a, N a \u2192 M a} (F0 : \u2200 a, F a 0 = 0) :\n    (f.mapRange F F0).neLocus (g.mapRange F F0) \u2286 f.neLocus g", "start": [88, 1], "end": [91, 78], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zipWith_neLocus_eq_left", "code": "theorem zipWith_neLocus_eq_left [\u2200 a, DecidableEq (N a)] [\u2200 a, DecidableEq (P a)]\n    {F : \u2200 a, M a \u2192 N a \u2192 P a} (F0 : \u2200 a, F a 0 0 = 0) (f : \u03a0\u2080 a, M a) (g\u2081 g\u2082 : \u03a0\u2080 a, N a)\n    (hF : \u2200 a f, Function.Injective fun g \u21a6 F a f g) :\n    (zipWith F F0 f g\u2081).neLocus (zipWith F F0 f g\u2082) = g\u2081.neLocus g\u2082", "start": [94, 1], "end": [99, 49], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zipWith_neLocus_eq_right", "code": "theorem zipWith_neLocus_eq_right [\u2200 a, DecidableEq (M a)] [\u2200 a, DecidableEq (P a)]\n    {F : \u2200 a, M a \u2192 N a \u2192 P a} (F0 : \u2200 a, F a 0 0 = 0) (f\u2081 f\u2082 : \u03a0\u2080 a, M a) (g : \u03a0\u2080 a, N a)\n    (hF : \u2200 a g, Function.Injective fun f \u21a6 F a f g) :\n    (zipWith F F0 f\u2081 g).neLocus (zipWith F F0 f\u2082 g) = f\u2081.neLocus f\u2082", "start": [102, 1], "end": [107, 49], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_neLocus_eq", "code": "theorem mapRange_neLocus_eq [\u2200 a, DecidableEq (N a)] [\u2200 a, DecidableEq (M a)] (f g : \u03a0\u2080 a, N a)\n    {F : \u2200 a, N a \u2192 M a} (F0 : \u2200 a, F a 0 = 0) (hF : \u2200 a, Function.Injective (F a)) :\n    (f.mapRange F F0).neLocus (g.mapRange F F0) = f.neLocus g", "start": [110, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_add_left", "code": "@[simp]\ntheorem neLocus_add_left [\u2200 a, AddLeftCancelMonoid (N a)] (f g h : \u03a0\u2080 a, N a) :\n    (f + g).neLocus (f + h) = g.neLocus h", "start": [121, 1], "end": [124, 63], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_add_right", "code": "@[simp]\ntheorem neLocus_add_right [\u2200 a, AddRightCancelMonoid (N a)] (f g h : \u03a0\u2080 a, N a) :\n    (f + h).neLocus (g + h) = f.neLocus g", "start": [127, 1], "end": [130, 63], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_neg_neg", "code": "@[simp]\ntheorem neLocus_neg_neg : neLocus (-f) (-g) = f.neLocus g", "start": [137, 1], "end": [139, 69], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_neg", "code": "theorem neLocus_neg : neLocus (-f) g = f.neLocus (-g)", "start": [142, 1], "end": [142, 92], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_eq_support_sub", "code": "theorem neLocus_eq_support_sub : f.neLocus g = (f - g).support", "start": [145, 1], "end": [146, 98], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_sub_left", "code": "@[simp]\ntheorem neLocus_sub_left : neLocus (f - g\u2081) (f - g\u2082) = neLocus g\u2081 g\u2082", "start": [149, 1], "end": [151, 75], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_sub_right", "code": "@[simp]\ntheorem neLocus_sub_right : neLocus (f\u2081 - g) (f\u2082 - g) = neLocus f\u2081 f\u2082", "start": [154, 1], "end": [156, 71], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_self_add_right", "code": "@[simp]\ntheorem neLocus_self_add_right : neLocus f (f + g) = g.support", "start": [159, 1], "end": [161, 74], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_self_add_left", "code": "@[simp]\ntheorem neLocus_self_add_left : neLocus (f + g) f = g.support", "start": [164, 1], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_self_sub_right", "code": "@[simp]\ntheorem neLocus_self_sub_right : neLocus f (f - g) = g.support", "start": [169, 1], "end": [171, 59], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neLocus_self_sub_left", "code": "@[simp]\ntheorem neLocus_self_sub_left : neLocus (f - g) f = g.support", "start": [174, 1], "end": [176, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/Order.lean", "imports": ["Mathlib/Data/DFinsupp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFinsupp.le_def", "code": "theorem le_def {f g : \u03a0\u2080 i, \u03b1 i} : f \u2264 g \u2194 \u2200 i, f i \u2264 g i", "start": [43, 1], "end": [44, 10], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.orderEmbeddingToFun", "code": "def orderEmbeddingToFun : (\u03a0\u2080 i, \u03b1 i) \u21aao \u2200 i, \u03b1 i where\n  toFun := FunLike.coe\n  inj' := FunLike.coe_injective\n  map_rel_iff' := by rfl", "start": [47, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.orderEmbeddingToFun_apply", "code": "@[simp]\ntheorem orderEmbeddingToFun_apply {f : \u03a0\u2080 i, \u03b1 i} {i : \u03b9} :\n    (@orderEmbeddingToFun \u03b9 \u03b1 _ _ f) i = f i", "start": [55, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coeFn_mono", "code": "theorem coeFn_mono : Monotone (FunLike.coe : (\u03a0\u2080 i, \u03b1 i) \u2192 \u2200 i, \u03b1 i)", "start": [72, 1], "end": [72, 91], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.inf_apply", "code": "@[simp]\ntheorem inf_apply [\u2200 i, SemilatticeInf (\u03b1 i)] (f g : \u03a0\u2080 i, \u03b1 i) (i : \u03b9) : (f \u2293 g) i = f i \u2293 g i", "start": [88, 1], "end": [90, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sup_apply", "code": "@[simp]\ntheorem sup_apply [\u2200 i, SemilatticeSup (\u03b1 i)] (f g : \u03a0\u2080 i, \u03b1 i) (i : \u03b9) : (f \u2294 g) i = f i \u2294 g i", "start": [100, 1], "end": [102, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lattice", "code": "instance lattice : Lattice (\u03a0\u2080 i, \u03b1 i) :=\n  { (inferInstance : SemilatticeInf (DFinsupp \u03b1)),\n    (inferInstance : SemilatticeSup (DFinsupp \u03b1)) with }", "start": [108, 1], "end": [110, 57], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_inf_union_support_sup", "code": "theorem support_inf_union_support_sup : (f \u2293 g).support \u222a (f \u2294 g).support = f.support \u222a g.support", "start": [115, 1], "end": [116, 73], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_sup_union_support_inf", "code": "theorem support_sup_union_support_inf : (f \u2294 g).support \u222a (f \u2293 g).support = f.support \u222a g.support", "start": [119, 1], "end": [120, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.bot_eq_zero", "code": "protected theorem bot_eq_zero : (\u22a5 : \u03a0\u2080 i, \u03b1 i) = 0", "start": [155, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.add_eq_zero_iff", "code": "@[simp]\ntheorem add_eq_zero_iff (f g : \u03a0\u2080 i, \u03b1 i) : f + g = 0 \u2194 f = 0 \u2227 g = 0", "start": [159, 1], "end": [161, 37], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.le_iff'", "code": "theorem le_iff' (hf : f.support \u2286 s) : f \u2264 g \u2194 \u2200 i \u2208 s, f i \u2264 g i", "start": [168, 1], "end": [170, 94], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.le_iff", "code": "theorem le_iff : f \u2264 g \u2194 \u2200 i \u2208 f.support, f i \u2264 g i", "start": [173, 1], "end": [174, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_monotone", "code": "lemma support_monotone : Monotone (support (\u03b9 := \u03b9) (\u03b2 := \u03b1)) :=\n  fun f g h a ha \u21a6 by rw [mem_support_iff, \u2190pos_iff_ne_zero] at ha \u22a2; exact ha.trans_le (h _)", "start": [177, 1], "end": [178, 94], "kind": "mathlibtacticlemma"}, {"full_name": "DFinsupp.support_mono", "code": "lemma support_mono (hfg : f \u2264 g) : f.support \u2286 g.support := support_monotone hfg", "start": [180, 1], "end": [180, 81], "kind": "mathlibtacticlemma"}, {"full_name": "DFinsupp.decidableLE", "code": "instance decidableLE [\u2200 i, DecidableRel (@LE.le (\u03b1 i) _)] : DecidableRel (@LE.le (\u03a0\u2080 i, \u03b1 i) _) :=\n  fun _ _ \u21a6 decidable_of_iff _ le_iff.symm", "start": [184, 1], "end": [185, 43], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_le_iff", "code": "@[simp]\ntheorem single_le_iff {i : \u03b9} {a : \u03b1 i} : single i a \u2264 f \u2194 a \u2264 f i", "start": [190, 1], "end": [192, 51], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.tsub", "code": "instance tsub : Sub (\u03a0\u2080 i, \u03b1 i) :=\n  \u27e8zipWith (fun _ m n \u21a6 m - n) fun _ \u21a6 tsub_self 0\u27e9", "start": [201, 1], "end": [204, 52], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.tsub_apply", "code": "theorem tsub_apply (f g : \u03a0\u2080 i, \u03b1 i) (i : \u03b9) : (f - g) i = f i - g i", "start": [209, 1], "end": [210, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_tsub", "code": "@[simp]\ntheorem coe_tsub (f g : \u03a0\u2080 i, \u03b1 i) : \u21d1(f - g) = f - g", "start": [213, 1], "end": [216, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_tsub", "code": "@[simp]\ntheorem single_tsub : single i (a - b) = single i a - single i b", "start": [236, 1], "end": [241, 88], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_tsub", "code": "theorem support_tsub : (f - g).support \u2286 f.support", "start": [246, 1], "end": [248, 72], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subset_support_tsub", "code": "theorem subset_support_tsub : f.support \\ g.support \u2286 (f - g).support", "start": [251, 1], "end": [252, 55], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_inf", "code": "@[simp]\ntheorem support_inf : (f \u2293 g).support = f.support \u2229 g.support", "start": [261, 1], "end": [265, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_sup", "code": "@[simp]\ntheorem support_sup : (f \u2294 g).support = f.support \u222a g.support", "start": [268, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.disjoint_iff", "code": "nonrec theorem disjoint_iff : Disjoint f g \u2194 Disjoint f.support g.support", "start": [275, 1], "end": [278, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Projective.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Module.Projective", "code": "class Module.Projective (R : Type*) [Semiring R] (P : Type*) [AddCommMonoid P] [Module R P] :\n    Prop where\n  out : \u2203 s : P \u2192\u2097[R] P \u2192\u2080 R, Function.LeftInverse (Finsupp.total P P R id) s", "start": [71, 1], "end": [76, 78], "kind": "commanddeclaration"}, {"full_name": "Module.projective_def", "code": "theorem projective_def :\n    Projective R P \u2194 \u2203 s : P \u2192\u2097[R] P \u2192\u2080 R, Function.LeftInverse (Finsupp.total P P R id) s", "start": [86, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "Module.projective_def'", "code": "theorem projective_def' :\n    Projective R P \u2194 \u2203 s : P \u2192\u2097[R] P \u2192\u2080 R, Finsupp.total P P R id \u2218\u2097 s = .id", "start": [91, 1], "end": [93, 91], "kind": "commanddeclaration"}, {"full_name": "Module.projective_lifting_property", "code": "theorem projective_lifting_property [h : Projective R P] (f : M \u2192\u2097[R] N) (g : P \u2192\u2097[R] N)\n    (hf : Function.Surjective f) : \u2203 h : P \u2192\u2097[R] M, f.comp h = g", "start": [96, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "Module.Projective.of_lifting_property''", "code": "theorem Projective.of_lifting_property'' {R : Type u} [Semiring R] {P : Type v} [AddCommMonoid P]\n    [Module R P] (huniv : \u2200 (f : (P \u2192\u2080 R) \u2192\u2097[R] P), Function.Surjective f \u2192\n      \u2203 h : P \u2192\u2097[R] (P \u2192\u2080 R), f.comp h = .id) :\n    Projective R P", "start": [118, 1], "end": [126, 48], "kind": "commanddeclaration"}, {"full_name": "Module.Projective.of_basis", "code": "theorem Projective.of_basis {\u03b9 : Type*} (b : Basis \u03b9 R P) : Projective R P", "start": [154, 1], "end": [162, 23], "kind": "commanddeclaration"}, {"full_name": "Module.Projective.of_free", "code": "instance (priority := 100) Projective.of_free [Module.Free R P] : Module.Projective R P :=\n  .of_basis <| Module.Free.chooseBasis R P", "start": [165, 1], "end": [166, 43], "kind": "commanddeclaration"}, {"full_name": "Module.Projective.of_lifting_property'", "code": "theorem Projective.of_lifting_property' {R : Type u} [Semiring R] {P : Type max u v}\n    [AddCommMonoid P] [Module R P]\n    (huniv : \u2200 {M : Type max v u} {N : Type max u v} [AddCommMonoid M] [AddCommMonoid N]\n      [Module R M] [Module R N] (f : M \u2192\u2097[R] N) (g : P \u2192\u2097[R] N),\n        Function.Surjective f \u2192 \u2203 h : P \u2192\u2097[R] M, f.comp h = g) :\n    Projective R P", "start": [175, 1], "end": [185, 37], "kind": "commanddeclaration"}, {"full_name": "Module.Projective.of_lifting_property", "code": "theorem Projective.of_lifting_property {R : Type u} [Ring R] {P : Type max u v} [AddCommGroup P]\n    [Module R P]\n    (huniv : \u2200 {M : Type max v u} {N : Type max u v} [AddCommGroup M] [AddCommGroup N]\n      [Module R M] [Module R N] (f : M \u2192\u2097[R] N) (g : P \u2192\u2097[R] N),\n        Function.Surjective f \u2192 \u2203 h : P \u2192\u2097[R] M, f.comp h = g) :\n    Projective R P", "start": [189, 1], "end": [199, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/CechNerve.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/WidePullbacks.lean", "Mathlib/AlgebraicTopology/SimplicialObject.lean", "Mathlib/CategoryTheory/Arrow.lean"], "premises": [{"full_name": "CategoryTheory.Arrow.cechNerve", "code": "@[simps]\ndef cechNerve : SimplicialObject C where\n  obj n := widePullback.{0} f.right (fun _ : Fin (n.unop.len + 1) => f.left) fun _ => f.hom\n  map g := WidePullback.lift (WidePullback.base _)\n    (fun i => WidePullback.\u03c0 _ (g.unop.toOrderHom i)) (by aesop_cat)", "start": [51, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mapCechNerve", "code": "@[simps]\ndef mapCechNerve {f g : Arrow C}\n    [\u2200 n : \u2115, HasWidePullback f.right (fun _ : Fin (n + 1) => f.left) fun _ => f.hom]\n    [\u2200 n : \u2115, HasWidePullback g.right (fun _ : Fin (n + 1) => g.left) fun _ => g.hom] (F : f \u27f6 g) :\n    f.cechNerve \u27f6 g.cechNerve where\n  app n :=\n    WidePullback.lift (WidePullback.base _ \u226b F.right) (fun i => WidePullback.\u03c0 _ i \u226b F.left)\n      fun j => by simp", "start": [59, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.augmentedCechNerve", "code": "@[simps]\ndef augmentedCechNerve : SimplicialObject.Augmented C where\n  left := f.cechNerve\n  right := f.right\n  hom := { app := fun i => WidePullback.base _ }", "start": [70, 1], "end": [75, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mapAugmentedCechNerve", "code": "@[simps]\ndef mapAugmentedCechNerve {f g : Arrow C}\n    [\u2200 n : \u2115, HasWidePullback f.right (fun _ : Fin (n + 1) => f.left) fun _ => f.hom]\n    [\u2200 n : \u2115, HasWidePullback g.right (fun _ : Fin (n + 1) => g.left) fun _ => g.hom] (F : f \u27f6 g) :\n    f.augmentedCechNerve \u27f6 g.augmentedCechNerve where\n  left := mapCechNerve F\n  right := F.right", "start": [78, 1], "end": [85, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.cechNerve", "code": "@[simps]\ndef cechNerve : Arrow C \u2964 SimplicialObject C where\n  obj f := f.cechNerve\n  map F := Arrow.mapCechNerve F", "start": [97, 1], "end": [101, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.augmentedCechNerve", "code": "@[simps!]\ndef augmentedCechNerve : Arrow C \u2964 SimplicialObject.Augmented C where\n  obj f := f.augmentedCechNerve\n  map F := Arrow.mapAugmentedCechNerve F", "start": [104, 1], "end": [108, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.equivalenceRightToLeft", "code": "@[simps]\ndef equivalenceRightToLeft (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : X \u27f6 F.augmentedCechNerve) : Augmented.toArrow.obj X \u27f6 F where\n  left := G.left.app _ \u226b WidePullback.\u03c0 _ 0\n  right := G.right\n  w := by\n    have := G.w\n    apply_fun fun e => e.app (Opposite.op <| SimplexCategory.mk 0) at this\n    simpa using this", "start": [111, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.equivalenceLeftToRight", "code": "@[simps]\ndef equivalenceLeftToRight (X : SimplicialObject.Augmented C) (F : Arrow C)\n    (G : Augmented.toArrow.obj X \u27f6 F) : X \u27f6 F.augmentedCechNerve where\n  left :=\n    { app := fun x =>\n        Limits.WidePullback.lift (X.hom.app _ \u226b G.right)\n          (fun i => X.left.map (SimplexCategory.const x.unop i).op \u226b G.left) fun i => by\n          dsimp\n          erw [Category.assoc, Arrow.w, Augmented.toArrow_obj_hom, NatTrans.naturality_assoc,\n            Functor.const_obj_map, Category.id_comp]\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        \u00b7 dsimp\n          simp only [WidePullback.lift_\u03c0, Category.assoc, \u2190 X.left.map_comp_assoc]\n          rfl\n        \u00b7 dsimp\n          simp }\n  right := G.right", "start": [123, 1], "end": [143, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.cechNerveEquiv", "code": "@[simps]\ndef cechNerveEquiv (X : SimplicialObject.Augmented C) (F : Arrow C) :\n    (Augmented.toArrow.obj X \u27f6 F) \u2243 (X \u27f6 F.augmentedCechNerve) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext\n    \u00b7 dsimp\n      erw [WidePullback.lift_\u03c0]\n      nth_rw 2 [\u2190 Category.id_comp A.left]\n      congr 1\n      convert X.left.map_id _\n      rw [\u2190 op_id]\n      congr 1\n      ext \u27e8a, ha\u27e9\n      change a < 1 at ha\n      change 0 = a\n      linarith\n    \u00b7 rfl\n  right_inv := by\n    intro A\n    ext x : 2\n    \u00b7 refine' WidePullback.hom_ext _ _ _ (fun j => _) _\n      \u00b7 dsimp\n        simp\n        rfl\n      \u00b7 simpa using congr_app A.w.symm x\n    \u00b7 rfl", "start": [146, 1], "end": [175, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SimplicialObject.cechNerveAdjunction", "code": "abbrev cechNerveAdjunction : (Augmented.toArrow : _ \u2964 Arrow C) \u22a3 augmentedCechNerve :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := cechNerveEquiv\n      homEquiv_naturality_left_symm := by dsimp [cechNerveEquiv]; aesop_cat\n      homEquiv_naturality_right := by\n        dsimp [cechNerveEquiv]\n        intro X Y Y' f g\n        change equivalenceLeftToRight X Y' (f \u226b g) =\n          equivalenceLeftToRight X Y f \u226b augmentedCechNerve.map g\n        aesop_cat\n    }", "start": [178, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.cechConerve", "code": "@[simps]\ndef cechConerve : CosimplicialObject C where\n  obj n := widePushout f.left (fun _ : Fin (n.len + 1) => f.right) fun _ => f.hom\n  map {x y} g := by\n    refine' WidePushout.desc (WidePushout.head _)\n      (fun i => (@WidePushout.\u03b9 _ _ _ _ _ (fun _ => f.hom) ?_ (g.toOrderHom i))) (fun j => _)\n    erw [\u2190 WidePushout.arrow_\u03b9]", "start": [203, 1], "end": [210, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mapCechConerve", "code": "@[simps]\ndef mapCechConerve {f g : Arrow C}\n    [\u2200 n : \u2115, HasWidePushout f.left (fun _ : Fin (n + 1) => f.right) fun _ => f.hom]\n    [\u2200 n : \u2115, HasWidePushout g.left (fun _ : Fin (n + 1) => g.right) fun _ => g.hom] (F : f \u27f6 g) :\n    f.cechConerve \u27f6 g.cechConerve where\n  app n := WidePushout.desc (F.left \u226b WidePushout.head _)\n    (fun i => F.right \u226b (by apply WidePushout.\u03b9 _ i))\n    (fun i => (by rw [\u2190 Arrow.w_assoc F, \u2190 WidePushout.arrow_\u03b9]))", "start": [213, 1], "end": [221, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.augmentedCechConerve", "code": "@[simps]\ndef augmentedCechConerve : CosimplicialObject.Augmented C where\n  left := f.left\n  right := f.cechConerve\n  hom :=\n    { app := fun i => (WidePushout.head _ : f.left \u27f6 _) }", "start": [224, 1], "end": [230, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.mapAugmentedCechConerve", "code": "@[simps]\ndef mapAugmentedCechConerve {f g : Arrow C}\n    [\u2200 n : \u2115, HasWidePushout f.left (fun _ : Fin (n + 1) => f.right) fun _ => f.hom]\n    [\u2200 n : \u2115, HasWidePushout g.left (fun _ : Fin (n + 1) => g.right) fun _ => g.hom] (F : f \u27f6 g) :\n    f.augmentedCechConerve \u27f6 g.augmentedCechConerve where\n  left := F.left\n  right := mapCechConerve F", "start": [233, 1], "end": [240, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.cechConerve", "code": "@[simps]\ndef cechConerve : Arrow C \u2964 CosimplicialObject C where\n  obj f := f.cechConerve\n  map F := Arrow.mapCechConerve F", "start": [252, 1], "end": [256, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.augmentedCechConerve", "code": "@[simps]\ndef augmentedCechConerve : Arrow C \u2964 CosimplicialObject.Augmented C where\n  obj f := f.augmentedCechConerve\n  map F := Arrow.mapAugmentedCechConerve F", "start": [259, 1], "end": [263, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.equivalenceLeftToRight", "code": "@[simps]\ndef equivalenceLeftToRight (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F.augmentedCechConerve \u27f6 X) : F \u27f6 Augmented.toArrow.obj X where\n  left := G.left\n  right := (WidePushout.\u03b9 _ 0 \u226b G.right.app (SimplexCategory.mk 0) : _)\n  w := by\n    dsimp\n    rw [@WidePushout.arrow_\u03b9_assoc _ _ _ _ _ (fun (_ : Fin 1) => F.hom)\n      (by dsimp; infer_instance)]\n    exact congr_app G.w (SimplexCategory.mk 0)", "start": [266, 1], "end": [276, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.equivalenceRightToLeft", "code": "@[simps!]\ndef equivalenceRightToLeft (F : Arrow C) (X : CosimplicialObject.Augmented C)\n    (G : F \u27f6 Augmented.toArrow.obj X) : F.augmentedCechConerve \u27f6 X where\n  left := G.left\n  right :=\n    { app := fun x =>\n        Limits.WidePushout.desc (G.left \u226b X.hom.app _)\n          (fun i => G.right \u226b X.right.map (SimplexCategory.const x i))\n          (by\n            rintro j\n            rw [\u2190 Arrow.w_assoc G]\n            have t := X.hom.naturality (x.const j)\n            dsimp at t \u22a2\n            simp only [Category.id_comp] at t\n            rw [\u2190 t])\n      naturality := by\n        intro x y f\n        dsimp\n        ext\n        \u00b7 dsimp\n          simp only [WidePushout.\u03b9_desc_assoc, WidePushout.\u03b9_desc]\n          rw [Category.assoc, \u2190 X.right.map_comp]\n          rfl\n        \u00b7 dsimp\n          simp only [Functor.const_obj_map, \u2190 NatTrans.naturality, WidePushout.head_desc_assoc,\n            WidePushout.head_desc, Category.assoc]\n          erw [Category.id_comp] }", "start": [279, 1], "end": [306, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.cechConerveEquiv", "code": "@[simps]\ndef cechConerveEquiv (F : Arrow C) (X : CosimplicialObject.Augmented C) :\n    (F.augmentedCechConerve \u27f6 X) \u2243 (F \u27f6 Augmented.toArrow.obj X) where\n  toFun := equivalenceLeftToRight _ _\n  invFun := equivalenceRightToLeft _ _\n  left_inv := by\n    intro A\n    ext x : 2\n    \u00b7 rfl\n    \u00b7 refine' WidePushout.hom_ext _ _ _ (fun j => _) _\n      \u00b7 dsimp\n        simp only [Category.assoc, \u2190 NatTrans.naturality A.right, Arrow.augmentedCechConerve_right,\n          SimplexCategory.len_mk, Arrow.cechConerve_map, colimit.\u03b9_desc,\n          WidePushoutShape.mkCocone_\u03b9_app, colimit.\u03b9_desc_assoc]\n        rfl\n      \u00b7 dsimp\n        rw [colimit.\u03b9_desc]\n        exact congr_app A.w x\n  right_inv := by\n    intro A\n    ext\n    \u00b7 rfl\n    \u00b7 dsimp\n      erw [WidePushout.\u03b9_desc]\n      nth_rw 2 [\u2190 Category.comp_id A.right]\n      congr 1\n      convert X.right.map_id _\n      ext \u27e8a, ha\u27e9\n      change a < 1 at ha\n      change 0 = a\n      linarith", "start": [309, 1], "end": [340, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CosimplicialObject.cechConerveAdjunction", "code": "abbrev cechConerveAdjunction : augmentedCechConerve \u22a3 (Augmented.toArrow : _ \u2964 Arrow C) :=\n  Adjunction.mkOfHomEquiv { homEquiv := cechConerveEquiv }", "start": [343, 1], "end": [345, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cechNerveTerminalFrom", "code": "def cechNerveTerminalFrom {C : Type u} [Category.{v} C] [HasFiniteProducts C] (X : C) :\n    SimplicialObject C where\n  obj n := \u220f fun _ : Fin (n.unop.len + 1) => X\n  map f := Limits.Pi.lift fun i => Limits.Pi.\u03c0 _ (f.unop.toOrderHom i)", "start": [350, 1], "end": [354, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.wideCospan", "code": "def wideCospan (X : C) : WidePullbackShape \u03b9 \u2964 C :=\n  WidePullbackShape.wideCospan (terminal C) (fun _ : \u03b9 => X) fun _ => terminal.from X", "start": [361, 1], "end": [363, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.uniqueToWideCospanNone", "code": "instance uniqueToWideCospanNone (X Y : C) : Unique (Y \u27f6 (wideCospan \u03b9 X).obj none) := by\n  dsimp [wideCospan]\n  infer_instance", "start": [366, 1], "end": [368, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.wideCospan.limitCone", "code": "def wideCospan.limitCone [Finite \u03b9] (X : C) : LimitCone (wideCospan \u03b9 X) where\n  cone :=\n    { pt := \u220f fun _ : \u03b9 => X\n      \u03c0 :=\n        { app := fun X => Option.casesOn X (terminal.from _) fun i => limit.\u03c0 _ \u27e8i\u27e9\n          naturality := fun i j f => by\n            cases f\n            \u00b7 cases i\n              all_goals dsimp; simp\n            \u00b7 dsimp\n              simp only [terminal.comp_from]\n              exact Subsingleton.elim _ _ } }\n  isLimit :=\n    { lift := fun s => Limits.Pi.lift fun j => s.\u03c0.app (some j)\n      fac := fun s j => Option.casesOn j (Subsingleton.elim _ _) fun j => limit.lift_\u03c0 _ _\n      uniq := fun s f h => by\n        dsimp\n        ext j\n        dsimp only [Limits.Pi.lift]\n        rw [limit.lift_\u03c0]\n        dsimp\n        rw [\u2190 h (some j)] }", "start": [373, 1], "end": [395, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.hasWidePullback", "code": "instance hasWidePullback [Finite \u03b9] (X : C) :\n    HasWidePullback (Arrow.mk (terminal.from X)).right\n      (fun _ : \u03b9 => (Arrow.mk (terminal.from X)).left)\n      (fun _ => (Arrow.mk (terminal.from X)).hom) := by\n  cases nonempty_fintype \u03b9\n  exact \u27e8\u27e8wideCospan.limitCone \u03b9 X\u27e9\u27e9", "start": [398, 1], "end": [403, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.hasWidePullback'", "code": "instance hasWidePullback' [Finite \u03b9] (X : C) :\n    HasWidePullback (\u22a4_ C)\n      (fun _ : \u03b9 => X)\n      (fun _ => terminal.from X) :=\n  hasWidePullback _ _", "start": [407, 1], "end": [411, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.hasLimit_wideCospan", "code": "instance hasLimit_wideCospan [Finite \u03b9] (X : C) : HasLimit (wideCospan \u03b9 X) := hasWidePullback _ _", "start": [414, 1], "end": [414, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi", "code": "def wideCospan.limitIsoPi [Finite \u03b9] (X : C) :\n    limit (wideCospan \u03b9 X) \u2245 \u220f fun _ : \u03b9 => X :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit _)\n    (wideCospan.limitCone \u03b9 X).2)", "start": [417, 1], "end": [421, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_inv_comp_pi", "code": "@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_inv_comp_pi [Finite \u03b9] (X : C) (j : \u03b9) :\n    (wideCospan.limitIsoPi \u03b9 X).inv \u226b WidePullback.\u03c0 _ j = Pi.\u03c0 _ j :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ _", "start": [424, 1], "end": [427, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.wideCospan.limitIsoPi_hom_comp_pi", "code": "@[reassoc (attr := simp)]\nlemma wideCospan.limitIsoPi_hom_comp_pi [Finite \u03b9] (X : C) (j : \u03b9) :\n    (wideCospan.limitIsoPi \u03b9 X).hom \u226b Pi.\u03c0 _ j = WidePullback.\u03c0 _ j := by\n  rw [\u2190 wideCospan.limitIsoPi_inv_comp_pi, Iso.hom_inv_id_assoc]", "start": [429, 1], "end": [432, 65], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CechNerveTerminalFrom.iso", "code": "def iso (X : C) : (Arrow.mk (terminal.from X)).cechNerve \u2245 cechNerveTerminalFrom X :=\n  NatIso.ofComponents (fun m => wideCospan.limitIsoPi _ _) (fun {m n} f => by\n    dsimp only [cechNerveTerminalFrom, Arrow.cechNerve]\n    ext \u27e8j\u27e9\n    simp only [Category.assoc, limit.lift_\u03c0, Fan.mk_\u03c0_app]\n    erw [wideCospan.limitIsoPi_hom_comp_pi,\n      wideCospan.limitIsoPi_hom_comp_pi, limit.lift_\u03c0]\n    rfl)", "start": [434, 1], "end": [444, 9], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/SimplicialSet.lean", "imports": ["Mathlib/CategoryTheory/Yoneda.lean", "Mathlib/CategoryTheory/Limits/Presheaf.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Category/TopCat/Limits/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Types.lean", "Mathlib/AlgebraicTopology/TopologicalSimplex.lean", "Mathlib/AlgebraicTopology/SimplicialObject.lean"], "premises": [{"full_name": "SSet", "code": "def SSet : Type (u + 1) :=\n  SimplicialObject (Type u)", "start": [44, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "SSet.largeCategory", "code": "instance largeCategory : LargeCategory SSet := by\n  dsimp only [SSet]\n  infer_instance", "start": [54, 1], "end": [56, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.hasLimits", "code": "instance hasLimits : HasLimits SSet := by\n  dsimp only [SSet]\n  infer_instance", "start": [58, 1], "end": [60, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.hasColimits", "code": "instance hasColimits : HasColimits SSet := by\n  dsimp only [SSet]\n  infer_instance", "start": [62, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.hom_ext", "code": "@[ext]\nlemma hom_ext {X Y : SSet} {f g : X \u27f6 Y} (w : \u2200 n, f.app n = g.app n) : f = g :=\n  SimplicialObject.hom_ext _ _ w", "start": [68, 1], "end": [70, 33], "kind": "mathlibtacticlemma"}, {"full_name": "SSet.standardSimplex", "code": "def standardSimplex : SimplexCategory \u2964 SSet :=\n  yoneda", "start": [72, 1], "end": [75, 9], "kind": "commanddeclaration"}, {"full_name": "SSet.asOrderHom", "code": "def asOrderHom {n} {m} (\u03b1 : \u0394[n].obj m) : OrderHom (Fin (m.unop.len + 1)) (Fin (n + 1)) :=\n  \u03b1.toOrderHom", "start": [87, 1], "end": [90, 15], "kind": "commanddeclaration"}, {"full_name": "SSet.boundary", "code": "def boundary (n : \u2115) : SSet where\n  obj m := { \u03b1 : \u0394[n].obj m // \u00acFunction.Surjective (asOrderHom \u03b1) }\n  map {m\u2081 m\u2082} f \u03b1 :=\n    \u27e8f.unop \u226b (\u03b1 : \u0394[n].obj m\u2081), by\n      intro h\n      apply \u03b1.property\n      exact Function.Surjective.of_comp h\u27e9", "start": [96, 1], "end": [105, 43], "kind": "commanddeclaration"}, {"full_name": "SSet.boundaryInclusion", "code": "def boundaryInclusion (n : \u2115) : \u2202\u0394[n] \u27f6 \u0394[n] where app m (\u03b1 : { \u03b1 : \u0394[n].obj m // _ }) := \u03b1", "start": [112, 1], "end": [113, 92], "kind": "commanddeclaration"}, {"full_name": "SSet.horn", "code": "def horn (n : \u2115) (i : Fin (n + 1)) : SSet where\n  obj m := { \u03b1 : \u0394[n].obj m // Set.range (asOrderHom \u03b1) \u222a {i} \u2260 Set.univ }\n  map {m\u2081 m\u2082} f \u03b1 :=\n    \u27e8f.unop \u226b (\u03b1 : \u0394[n].obj m\u2081), by\n      intro h; apply \u03b1.property\n      rw [Set.eq_univ_iff_forall] at h \u22a2; intro j\n      apply Or.imp _ id (h j)\n      intro hj\n      exact Set.range_comp_subset_range _ _ hj\u27e9", "start": [117, 1], "end": [129, 48], "kind": "commanddeclaration"}, {"full_name": "SSet.hornInclusion", "code": "def hornInclusion (n : \u2115) (i : Fin (n + 1)) : \u039b[n, i] \u27f6 \u0394[n] where\n  app m (\u03b1 : { \u03b1 : \u0394[n].obj m // _ }) := \u03b1", "start": [136, 1], "end": [138, 43], "kind": "commanddeclaration"}, {"full_name": "SSet.S1", "code": "noncomputable def S1 : SSet :=\n  Limits.colimit <|\n    Limits.parallelPair (standardSimplex.map <| SimplexCategory.\u03b4 0 : \u0394[0] \u27f6 \u0394[1])\n      (standardSimplex.map <| SimplexCategory.\u03b4 1)", "start": [146, 1], "end": [150, 51], "kind": "commanddeclaration"}, {"full_name": "SSet.Truncated", "code": "def Truncated (n : \u2115) :=\n  SimplicialObject.Truncated (Type u) n", "start": [156, 1], "end": [158, 40], "kind": "commanddeclaration"}, {"full_name": "SSet.Truncated.largeCategory", "code": "instance Truncated.largeCategory (n : \u2115) : LargeCategory (Truncated n) := by\n  dsimp only [Truncated]\n  infer_instance", "start": [162, 1], "end": [164, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.Truncated.hasLimits", "code": "instance Truncated.hasLimits : HasLimits (Truncated n) := by\n  dsimp only [Truncated]\n  infer_instance", "start": [166, 1], "end": [168, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.Truncated.hasColimits", "code": "instance Truncated.hasColimits : HasColimits (Truncated n) := by\n  dsimp only [Truncated]\n  infer_instance", "start": [170, 1], "end": [172, 17], "kind": "commanddeclaration"}, {"full_name": "SSet.Truncated.hom_ext", "code": "@[ext]\nlemma Truncated.hom_ext {X Y : Truncated n} {f g : X \u27f6 Y} (w : \u2200 n, f.app n = g.app n) : f = g :=\n  NatTrans.ext _ _ (funext w)", "start": [176, 1], "end": [178, 30], "kind": "mathlibtacticlemma"}, {"full_name": "SSet.sk", "code": "def sk (n : \u2115) : SSet \u2964 SSet.Truncated n :=\n  SimplicialObject.sk n", "start": [180, 1], "end": [182, 24], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented", "code": "abbrev Augmented :=\n  SimplicialObject.Augmented (Type u)", "start": [189, 1], "end": [192, 38], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.standardSimplex", "code": "@[simps]\nnoncomputable def standardSimplex : SimplexCategory \u2964 SSet.Augmented where\n  obj \u0394 :=\n    { left := SSet.standardSimplex.obj \u0394\n      right := terminal _\n      hom := { app := fun \u0394' => terminal.from _ } }\n  map \u03b8 :=\n    { left := SSet.standardSimplex.map \u03b8\n      right := terminal.from _ }", "start": [204, 1], "end": [214, 33], "kind": "commanddeclaration"}, {"full_name": "TopCat.toSSet", "code": "noncomputable def TopCat.toSSet : TopCat \u2964 SSet :=\n  ColimitAdj.restrictedYoneda SimplexCategory.toTop", "start": [222, 1], "end": [224, 52], "kind": "commanddeclaration"}, {"full_name": "SSet.toTop", "code": "noncomputable def SSet.toTop : SSet \u2964 TopCat :=\n  ColimitAdj.extendAlongYoneda SimplexCategory.toTop", "start": [228, 1], "end": [230, 53], "kind": "commanddeclaration"}, {"full_name": "sSetTopAdj", "code": "noncomputable def sSetTopAdj : SSet.toTop \u22a3 TopCat.toSSet :=\n  ColimitAdj.yonedaAdjunction _", "start": [234, 1], "end": [236, 32], "kind": "commanddeclaration"}, {"full_name": "SSet.toTopSimplex", "code": "noncomputable def SSet.toTopSimplex :\n    (yoneda : SimplexCategory \u2964 _) \u22d9 SSet.toTop \u2245 SimplexCategory.toTop :=\n  ColimitAdj.isExtensionAlongYoneda _", "start": [240, 1], "end": [244, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/Projective.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Yoneda/Projective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Preadditive/Yoneda/Limits.lean", "Mathlib/CategoryTheory/Preadditive/ProjectiveResolution.lean", "Mathlib/Algebra/Homology/QuasiIso.lean"], "premises": [{"full_name": "CategoryTheory.exact_d_f", "code": "theorem exact_d_f [EnoughProjectives C] {X Y : C} (f : X \u27f6 Y) : Exact (d f) f", "start": [34, 1], "end": [37, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective", "code": "def preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective (P : C) [hP : Projective P] :\n    PreservesFiniteColimits (preadditiveCoyonedaObj (op P)) := by\n  haveI := (projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' P).mp hP\n  haveI := @Functor.preservesEpimorphisms_of_preserves_of_reflects _ _ _ _ _ _ _ _ this _\n  apply Functor.preservesFiniteColimitsOfPreservesEpisAndKernels", "start": [40, 1], "end": [46, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.projective_of_preservesFiniteColimits_preadditiveCoyonedaObj", "code": "theorem projective_of_preservesFiniteColimits_preadditiveCoyonedaObj (P : C)\n    [hP : PreservesFiniteColimits (preadditiveCoyonedaObj (op P))] : Projective P", "start": [49, 1], "end": [55, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProjectiveResolution.ofComplex", "code": "@[simps!]\ndef ofComplex (Z : C) : ChainComplex C \u2115 :=\n  ChainComplex.mk' (Projective.over Z) (Projective.syzygies (Projective.\u03c0 Z))\n    (Projective.d (Projective.\u03c0 Z)) fun \u27e8_, _, f\u27e9 =>\n    \u27e8Projective.syzygies f, Projective.d f, (exact_d_f f).w\u27e9", "start": [74, 1], "end": [79, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProjectiveResolution.ofComplex_sq_10_comm", "code": "theorem ofComplex_sq_10_comm (Z : C) :\n    0 \u226b HomologicalComplex.d ((ChainComplex.single\u2080 C).obj Z) 1 0 =\n    HomologicalComplex.d (ofComplex Z) 1 0 \u226b Projective.\u03c0 Z", "start": [112, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProjectiveResolution.exact_ofComplex", "code": "theorem exact_ofComplex (Z : C) (n : \u2115) :\n    Exact (HomologicalComplex.d (ofComplex Z) (n + 2) (n + 1))\n    (HomologicalComplex.d (ofComplex Z) (n + 1) n)", "start": [122, 1], "end": [134, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ProjectiveResolution.of", "code": "irreducible_def of (Z : C) : ProjectiveResolution Z :=\n  { complex := ofComplex Z\n    \u03c0 := ChainComplex.mkHom (ofComplex Z) ((ChainComplex.single\u2080 C).obj Z) (Projective.\u03c0 Z) 0\n           (ofComplex_sq_10_comm Z) (fun n _ \u21a6 \u27e80, by\n           apply HasZeroObject.to_zero_ext \u27e9)\n    projective := by rintro (_ | _ | _ | n) <;> apply Projective.projective_over\n    exact\u2080 := by simpa using exact_d_f (Projective.\u03c0 Z)\n    exact := exact_ofComplex Z\n    epi := Projective.\u03c0_epi Z }", "start": [136, 1], "end": [148, 32], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "HomologicalComplex.Hom.toSingle\u2080ProjectiveResolution", "code": "def toSingle\u2080ProjectiveResolution {X : ChainComplex C \u2115} {Y : C}\n    (f : X \u27f6 (ChainComplex.single\u2080 C).obj Y) [QuasiIso f] (H : \u2200 n, Projective (X.X n)) :\n    ProjectiveResolution Y where\n  complex := X\n  \u03c0 := f\n  projective := H\n  exact\u2080 := HomologicalComplex.Hom.to_single\u2080_exact_d_f_at_zero f\n  exact := HomologicalComplex.Hom.to_single\u2080_exact_at_succ f\n  epi := HomologicalComplex.Hom.to_single\u2080_epi_at_zero f", "start": [164, 1], "end": [176, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/LeftDerived.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/ProjectiveResolution.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.leftDerived", "code": "def Functor.leftDerived (F : C \u2964 D) [F.Additive] (n : \u2115) : C \u2964 D :=\n  projectiveResolutions C \u22d9 F.mapHomotopyCategory _ \u22d9 HomotopyCategory.homologyFunctor D _ n", "start": [61, 1], "end": [63, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftDerivedObjIso", "code": "@[simps!]\ndef Functor.leftDerivedObjIso (F : C \u2964 D) [F.Additive] (n : \u2115) {X : C}\n    (P : ProjectiveResolution X) :\n    (F.leftDerived n).obj X \u2245\n      (homologyFunctor D _ n).obj ((F.mapHomologicalComplex _).obj P.complex) :=\n  (HomotopyCategory.homologyFunctor D _ n).mapIso\n      (HomotopyCategory.isoOfHomotopyEquiv\n        (F.mapHomotopyEquiv (ProjectiveResolution.homotopyEquiv _ P))) \u226a\u226b\n    (HomotopyCategory.homologyFactors D _ n).app _", "start": [67, 1], "end": [76, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftDerivedObjProjectiveZero", "code": "@[simps!]\ndef Functor.leftDerivedObjProjectiveZero (F : C \u2964 D) [F.Additive] (X : C) [Projective X] :\n    (F.leftDerived 0).obj X \u2245 F.obj X :=\n  F.leftDerivedObjIso 0 (ProjectiveResolution.self X) \u226a\u226b\n    (homologyFunctor _ _ _).mapIso ((ChainComplex.single\u2080MapHomologicalComplex F).app X) \u226a\u226b\n      (ChainComplex.homologyFunctor0Single\u2080 D).app (F.obj X)", "start": [83, 1], "end": [89, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftDerivedObjProjectiveSucc", "code": "@[simps! inv]\ndef Functor.leftDerivedObjProjectiveSucc (F : C \u2964 D) [F.Additive] (n : \u2115) (X : C) [Projective X] :\n    (F.leftDerived (n + 1)).obj X \u2245 0 :=\n  F.leftDerivedObjIso (n + 1) (ProjectiveResolution.self X) \u226a\u226b\n    (homologyFunctor _ _ _).mapIso ((ChainComplex.single\u2080MapHomologicalComplex F).app X) \u226a\u226b\n      (ChainComplex.homologyFunctorSuccSingle\u2080 D n).app (F.obj X) \u226a\u226b (Functor.zero_obj _).isoZero", "start": [94, 1], "end": [100, 98], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftDerived_map_eq", "code": "theorem Functor.leftDerived_map_eq (F : C \u2964 D) [F.Additive] (n : \u2115) {X Y : C} (f : X \u27f6 Y)\n    {P : ProjectiveResolution X} {Q : ProjectiveResolution Y} (g : P.complex \u27f6 Q.complex)\n    (w : g \u226b Q.\u03c0 = P.\u03c0 \u226b (ChainComplex.single\u2080 C).map f) :\n    (F.leftDerived n).map f =\n      (F.leftDerivedObjIso n P).hom \u226b\n        (homologyFunctor D _ n).map ((F.mapHomologicalComplex _).map g) \u226b\n          (F.leftDerivedObjIso n Q).inv", "start": [105, 1], "end": [124, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftDerived", "code": "@[simps!]\ndef NatTrans.leftDerived {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) :\n    F.leftDerived n \u27f6 G.leftDerived n :=\n  whiskerLeft (projectiveResolutions C)\n    (whiskerRight (NatTrans.mapHomotopyCategory \u03b1 _) (HomotopyCategory.homologyFunctor D _ n))", "start": [127, 1], "end": [132, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftDerived_id", "code": "@[simp]\ntheorem NatTrans.leftDerived_id (F : C \u2964 D) [F.Additive] (n : \u2115) :\n    NatTrans.leftDerived (\ud835\udfd9 F) n = \ud835\udfd9 (F.leftDerived n)", "start": [135, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftDerived_comp", "code": "@[simp]\ntheorem NatTrans.leftDerived_comp {F G H : C \u2964 D} [F.Additive] [G.Additive] [H.Additive] (\u03b1 : F \u27f6 G)\n    (\u03b2 : G \u27f6 H) (n : \u2115) :\n    NatTrans.leftDerived (\u03b1 \u226b \u03b2) n = NatTrans.leftDerived \u03b1 n \u226b NatTrans.leftDerived \u03b2 n", "start": [143, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftDerived_eq", "code": "theorem NatTrans.leftDerived_eq {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) {X : C}\n    (P : ProjectiveResolution X) :\n    (NatTrans.leftDerived \u03b1 n).app X =\n      (F.leftDerivedObjIso n P).hom \u226b\n        (homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex \u03b1 _).app P.complex) \u226b\n          (G.leftDerivedObjIso n P).inv", "start": [150, 1], "end": [170, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/FGModuleCat/Limits.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Products.lean", "Mathlib/CategoryTheory/Limits/Creates.lean", "Mathlib/CategoryTheory/Limits/Shapes/FiniteLimits.lean", "Mathlib/Algebra/Category/FGModuleCat/Basic.lean", "Mathlib/CategoryTheory/Limits/Constructions/LimitsOfProductsAndEqualizers.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Limits.lean", "Mathlib/Algebra/Category/ModuleCat/EpiMono.lean"], "premises": [{"full_name": "FGModuleCat.forget\u2082CreatesLimit", "code": "def forget\u2082CreatesLimit (F : J \u2964 FGModuleCat k) :\n    CreatesLimit F (forget\u2082 (FGModuleCat k) (ModuleCat.{v} k)) :=\n  createsLimitOfFullyFaithfulOfIso\n    \u27e8(limit (F \u22d9 forget\u2082 (FGModuleCat k) (ModuleCat.{v} k)) : ModuleCat.{v} k), inferInstance\u27e9\n    (Iso.refl _)", "start": [59, 1], "end": [64, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/Rep.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Colimits.lean", "Mathlib/RepresentationTheory/Action.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Adjunctions.lean", "Mathlib/RepresentationTheory/Basic.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Closed.lean"], "premises": [{"full_name": "Rep", "code": "abbrev Rep (k G : Type u) [Ring k] [Monoid G] :=\n  Action (ModuleCat.{u} k) (MonCat.of G)", "start": [37, 1], "end": [39, 41], "kind": "commanddeclaration"}, {"full_name": "Rep.\u03c1", "code": "def \u03c1 (V : Rep k G) : Representation k G V :=\nAction.\u03c1 V", "start": [63, 1], "end": [67, 13], "kind": "commanddeclaration"}, {"full_name": "Rep.of", "code": "def of {V : Type u} [AddCommGroup V] [Module k V] (\u03c1 : G \u2192* V \u2192\u2097[k] V) : Rep k G :=\n  \u27e8ModuleCat.of k V, \u03c1\u27e9", "start": [71, 1], "end": [73, 24], "kind": "commanddeclaration"}, {"full_name": "Rep.coe_of", "code": "@[simp]\ntheorem coe_of {V : Type u} [AddCommGroup V] [Module k V] (\u03c1 : G \u2192* V \u2192\u2097[k] V) :\n    (of \u03c1 : Type u) = V", "start": [77, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.of_\u03c1", "code": "@[simp]\ntheorem of_\u03c1 {V : Type u} [AddCommGroup V] [Module k V] (\u03c1 : G \u2192* V \u2192\u2097[k] V) : (of \u03c1).\u03c1 = \u03c1", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.Action_\u03c1_eq_\u03c1", "code": "theorem Action_\u03c1_eq_\u03c1 {A : Rep k G} : Action.\u03c1 A = A.\u03c1", "start": [90, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.of_\u03c1_apply", "code": "theorem of_\u03c1_apply {V : Type u} [AddCommGroup V] [Module k V] (\u03c1 : Representation k G V)\n    (g : MonCat.of G) : (Rep.of \u03c1).\u03c1 g = \u03c1 (g : G)", "start": [95, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.\u03c1_inv_self_apply", "code": "@[simp]\ntheorem \u03c1_inv_self_apply {G : Type u} [Group G] (A : Rep k G) (g : G) (x : A) :\n    A.\u03c1 g\u207b\u00b9 (A.\u03c1 g x) = x", "start": [103, 1], "end": [106, 93], "kind": "commanddeclaration"}, {"full_name": "Rep.\u03c1_self_inv_apply", "code": "@[simp]\ntheorem \u03c1_self_inv_apply {G : Type u} [Group G] {A : Rep k G} (g : G) (x : A) :\n    A.\u03c1 g (A.\u03c1 g\u207b\u00b9 x) = x", "start": [110, 1], "end": [113, 93], "kind": "commanddeclaration"}, {"full_name": "Rep.hom_comm_apply", "code": "theorem hom_comm_apply {A B : Rep k G} (f : A \u27f6 B) (g : G) (x : A) :\n    f.hom (A.\u03c1 g x) = B.\u03c1 g (f.hom x)", "start": [117, 1], "end": [119, 35], "kind": "commanddeclaration"}, {"full_name": "Rep.trivial", "code": "def trivial (V : Type u) [AddCommGroup V] [Module k V] : Rep k G :=\n  Rep.of (@Representation.trivial k G V _ _ _ _)", "start": [125, 1], "end": [127, 49], "kind": "commanddeclaration"}, {"full_name": "Rep.trivial_def", "code": "theorem trivial_def {V : Type u} [AddCommGroup V] [Module k V] (g : G) (v : V) :\n    (trivial k G V).\u03c1 g v = v", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalCategory.braiding_hom_apply", "code": "theorem MonoidalCategory.braiding_hom_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.Hom.hom (\u03b2_ A B).hom (TensorProduct.tmul k x y) = TensorProduct.tmul k y x", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalCategory.braiding_inv_apply", "code": "theorem MonoidalCategory.braiding_inv_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.Hom.hom (\u03b2_ A B).inv (TensorProduct.tmul k y x) = TensorProduct.tmul k x y", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization", "code": "noncomputable def linearization : MonoidalFunctor (Action (Type u) (MonCat.of G)) (Rep k G) :=\n  (ModuleCat.monoidalFree k).mapAction (MonCat.of G)", "start": [166, 1], "end": [169, 53], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_obj_\u03c1", "code": "@[simp]\ntheorem linearization_obj_\u03c1 (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V \u2192\u2080 k) :\n    ((linearization k G).obj X).\u03c1 g x = Finsupp.lmapDomain k k (X.\u03c1 g) x", "start": [175, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_of", "code": "theorem linearization_of (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V) :\n    ((linearization k G).obj X).\u03c1 g (Finsupp.single x (1 : k))\n      = Finsupp.single (X.\u03c1 g x) (1 : k)", "start": [182, 1], "end": [185, 79], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_single", "code": "theorem linearization_single (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V) (r : k) :\n    ((linearization k G).obj X).\u03c1 g (Finsupp.single x r) = Finsupp.single (X.\u03c1 g x) r", "start": [190, 1], "end": [192, 82], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_map_hom", "code": "@[simp]\ntheorem linearization_map_hom : ((linearization k G).map f).hom = Finsupp.lmapDomain k k f.hom", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_map_hom_single", "code": "theorem linearization_map_hom_single (x : X.V) (r : k) :\n    ((linearization k G).map f).hom (Finsupp.single x r) = Finsupp.single (f.hom x) r", "start": [202, 1], "end": [204, 27], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_\u03bc_hom", "code": "@[simp]\ntheorem linearization_\u03bc_hom (X Y : Action (Type u) (MonCat.of G)) :\n    ((linearization k G).\u03bc X Y).hom = (finsuppTensorFinsupp' k X.V Y.V).toLinearMap", "start": [208, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_\u03bc_inv_hom", "code": "@[simp]\ntheorem linearization_\u03bc_inv_hom (X Y : Action (Type u) (MonCat.of G)) :\n    (inv ((linearization k G).\u03bc X Y)).hom = (finsuppTensorFinsupp' k X.V Y.V).symm.toLinearMap", "start": [215, 1], "end": [224, 96], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_\u03b5_hom", "code": "@[simp]\ntheorem linearization_\u03b5_hom : (linearization k G).\u03b5.hom = Finsupp.lsingle PUnit.unit", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.linearization_\u03b5_inv_hom_apply", "code": "@[simp, nolint simpNF]\ntheorem linearization_\u03b5_inv_hom_apply (r : k) :\n    (inv (linearization k G).\u03b5).hom (Finsupp.single PUnit.unit r) = r", "start": [235, 1], "end": [238, 49], "kind": "commanddeclaration"}, {"full_name": "Rep.linearizationTrivialIso", "code": "@[simps!]\nnoncomputable def linearizationTrivialIso (X : Type u) :\n    (linearization k G).obj (Action.mk X 1) \u2245 trivial k G (X \u2192\u2080 k) :=\n  Action.mkIso (Iso.refl _) fun _ => Finsupp.lhom_ext' fun _ => LinearMap.ext\n    fun _ => linearization_single ..", "start": [244, 1], "end": [250, 37], "kind": "commanddeclaration"}, {"full_name": "Rep.ofMulAction", "code": "noncomputable abbrev ofMulAction (H : Type u) [MulAction G H] : Rep k G :=\n  of <| Representation.ofMulAction k G H", "start": [254, 1], "end": [257, 41], "kind": "commanddeclaration"}, {"full_name": "Rep.leftRegular", "code": "noncomputable def leftRegular : Rep k G :=\n  ofMulAction k G G", "start": [261, 1], "end": [263, 20], "kind": "commanddeclaration"}, {"full_name": "Rep.diagonal", "code": "noncomputable def diagonal (n : \u2115) : Rep k G :=\n  ofMulAction k G (Fin n \u2192 G)", "start": [267, 1], "end": [269, 30], "kind": "commanddeclaration"}, {"full_name": "Rep.linearizationOfMulActionIso", "code": "noncomputable def linearizationOfMulActionIso (H : Type u) [MulAction G H] :\n    (linearization k G).obj (Action.ofMulAction G H) \u2245 ofMulAction k G H :=\n  Iso.refl _", "start": [273, 1], "end": [277, 13], "kind": "commanddeclaration"}, {"full_name": "Rep.leftRegularHom", "code": "@[simps]\nnoncomputable def leftRegularHom (A : Rep k G) (x : A) : Rep.ofMulAction k G G \u27f6 A where\n  hom := Finsupp.lift _ _ _ fun g => A.\u03c1 g x\n  comm g := by\n    refine' Finsupp.lhom_ext' fun y => LinearMap.ext_ring _\n\n    simp only [LinearMap.comp_apply, ModuleCat.comp_def, Finsupp.lsingle_apply]\n    erw [Finsupp.lift_apply, Finsupp.lift_apply, Representation.ofMulAction_single (G := G)]\n    simp only [Finsupp.sum_single_index, zero_smul, one_smul, smul_eq_mul, A.\u03c1.map_mul, of_\u03c1]\n    rfl", "start": [283, 1], "end": [297, 8], "kind": "commanddeclaration"}, {"full_name": "Rep.leftRegularHom_apply", "code": "theorem leftRegularHom_apply {A : Rep k G} (x : A) :\n    (leftRegularHom A x).hom (Finsupp.single 1 1) = x", "start": [301, 1], "end": [306, 19], "kind": "commanddeclaration"}, {"full_name": "Rep.leftRegularHomEquiv", "code": "@[simps]\nnoncomputable def leftRegularHomEquiv (A : Rep k G) : (Rep.ofMulAction k G G \u27f6 A) \u2243\u2097[k] A where\n  toFun f := f.hom (Finsupp.single 1 1)\n  map_add' x y := rfl\n  map_smul' r x := rfl\n  invFun x := leftRegularHom A x\n  left_inv f := by\n    refine' Action.Hom.ext _ _ (Finsupp.lhom_ext' fun x : G => LinearMap.ext_ring _)\n    have :\n      f.hom ((ofMulAction k G G).\u03c1 x (Finsupp.single (1 : G) (1 : k))) =\n        A.\u03c1 x (f.hom (Finsupp.single (1 : G) (1 : k))) :=\n      LinearMap.ext_iff.1 (f.comm x) (Finsupp.single 1 1)\n\n    simp only [LinearMap.comp_apply, Finsupp.lsingle_apply, leftRegularHom_hom]\n    erw [Finsupp.lift_apply]\n    rw [Finsupp.sum_single_index, \u2190this, of_\u03c1_apply]\n    erw [Representation.ofMulAction_single x (1 : G) (1 : k)]\n    simp only [one_smul, smul_eq_mul, mul_one]\n    \u00b7 rfl\n    \u00b7 rw [zero_smul]\n  right_inv x := leftRegularHom_apply x", "start": [310, 1], "end": [336, 40], "kind": "commanddeclaration"}, {"full_name": "Rep.leftRegularHomEquiv_symm_single", "code": "theorem leftRegularHomEquiv_symm_single {A : Rep k G} (x : A) (g : G) :\n    ((leftRegularHomEquiv A).symm x).hom (Finsupp.single g 1) = A.\u03c1 g x", "start": [340, 1], "end": [345, 19], "kind": "commanddeclaration"}, {"full_name": "Rep.ihom", "code": "@[simps]\nprotected def ihom (A : Rep k G) : Rep k G \u2964 Rep k G where\n  obj B := Rep.of (Representation.linHom A.\u03c1 B.\u03c1)\n  map := fun {X} {Y} f =>\n    { hom := ModuleCat.ofHom (LinearMap.llcomp k _ _ _ f.hom)\n      comm := fun g => LinearMap.ext fun x => LinearMap.ext fun y => by\n        show f.hom (X.\u03c1 g _) = _\n        simp only [hom_comm_apply]; rfl }\n  map_id := fun _ => by ext; rfl\n  map_comp := fun _ _ => by ext; rfl", "start": [358, 1], "end": [370, 37], "kind": "commanddeclaration"}, {"full_name": "Rep.ihom_obj_\u03c1_apply", "code": "@[simp] theorem ihom_obj_\u03c1_apply {A B : Rep k G} (g : G) (x : A \u2192\u2097[k] B) :\n    ((Rep.ihom A).obj B).\u03c1 g x = B.\u03c1 g \u2218\u2097 x \u2218\u2097 A.\u03c1 g\u207b\u00b9", "start": [374, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.homEquiv", "code": "def homEquiv (A B C : Rep k G) : (A \u2297 B \u27f6 C) \u2243 (B \u27f6 (Rep.ihom A).obj C) where\n  toFun f :=\n    { hom := (TensorProduct.curry f.hom).flip\n      comm := fun g => by\n        refine' LinearMap.ext fun x => LinearMap.ext fun y => _\n        change f.hom (_ \u2297\u209c[k] _) = C.\u03c1 g (f.hom (_ \u2297\u209c[k] _))\n        rw [\u2190hom_comm_apply]\n        change _ = f.hom ((A.\u03c1 g * A.\u03c1 g\u207b\u00b9) y \u2297\u209c[k] _)\n        simp only [\u2190map_mul, mul_inv_self, map_one]\n        rfl }\n  invFun f :=\n    { hom := TensorProduct.uncurry k _ _ _ f.hom.flip\n      comm := fun g => TensorProduct.ext' fun x y => by\n\n        change TensorProduct.uncurry k _ _ _ f.hom.flip (A.\u03c1 g x \u2297\u209c[k] B.\u03c1 g y) =\n          C.\u03c1 g (TensorProduct.uncurry k _ _ _ f.hom.flip (x \u2297\u209c[k] y))\n        erw [TensorProduct.uncurry_apply, LinearMap.flip_apply, hom_comm_apply,\n          Rep.ihom_obj_\u03c1_apply,\n          LinearMap.comp_apply, LinearMap.comp_apply] dsimp\n        erw [\u03c1_inv_self_apply]\n        rfl}\n  left_inv f := Action.Hom.ext _ _ (TensorProduct.ext' fun _ _ => rfl)\n  right_inv f := by ext; rfl", "start": [380, 1], "end": [411, 29], "kind": "commanddeclaration"}, {"full_name": "Rep.homEquiv_apply_hom", "code": "theorem homEquiv_apply_hom (f : A \u2297 B \u27f6 C) :\n    (homEquiv A B C f).hom = (TensorProduct.curry f.hom).flip", "start": [417, 1], "end": [420, 69], "kind": "commanddeclaration"}, {"full_name": "Rep.homEquiv_symm_apply_hom", "code": "theorem homEquiv_symm_apply_hom (f : B \u27f6 (Rep.ihom A).obj C) :\n    ((homEquiv A B C).symm f).hom = TensorProduct.uncurry k A B C f.hom.flip", "start": [424, 1], "end": [427, 84], "kind": "commanddeclaration"}, {"full_name": "Rep.ihom_obj_\u03c1_def", "code": "@[simp]\ntheorem ihom_obj_\u03c1_def (A B : Rep k G) : ((ihom A).obj B).\u03c1 = ((Rep.ihom A).obj B).\u03c1", "start": [442, 1], "end": [444, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.homEquiv_def", "code": "@[simp]\ntheorem homEquiv_def (A B C : Rep k G) : (ihom.adjunction A).homEquiv B C = Rep.homEquiv A B C", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.ihom_ev_app_hom", "code": "@[simp]\ntheorem ihom_ev_app_hom (A B : Rep k G) :\n    Action.Hom.hom ((ihom.ev A).app B)\n      = TensorProduct.uncurry k A (A \u2192\u2097[k] B) B LinearMap.id.flip", "start": [454, 1], "end": [458, 11], "kind": "commanddeclaration"}, {"full_name": "Rep.ihom_coev_app_hom", "code": "@[simp] theorem ihom_coev_app_hom (A B : Rep k G) :\n    Action.Hom.hom ((ihom.coev A).app B) = (TensorProduct.mk k _ _).flip", "start": [462, 1], "end": [464, 52], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquiv", "code": "def MonoidalClosed.linearHomEquiv : (A \u2297 B \u27f6 C) \u2243\u2097[k] B \u27f6 A \u27f6[Rep k G] C :=\n  { (ihom.adjunction A).homEquiv _ _ with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [470, 1], "end": [475, 34], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquivComm", "code": "def MonoidalClosed.linearHomEquivComm : (A \u2297 B \u27f6 C) \u2243\u2097[k] A \u27f6 B \u27f6[Rep k G] C :=\n  Linear.homCongr k (\u03b2_ A B) (Iso.refl _) \u226a\u226b\u2097 MonoidalClosed.linearHomEquiv _ _ _", "start": [479, 1], "end": [482, 82], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquiv_hom", "code": "@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquiv_hom (f : A \u2297 B \u27f6 C) :\n    (MonoidalClosed.linearHomEquiv A B C f).hom = (TensorProduct.curry f.hom).flip", "start": [489, 1], "end": [492, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquivComm_hom", "code": "@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquivComm_hom (f : A \u2297 B \u27f6 C) :\n    (MonoidalClosed.linearHomEquivComm A B C f).hom = TensorProduct.curry f.hom", "start": [497, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquiv_symm_hom", "code": "@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquiv_symm_hom (f : B \u27f6 A \u27f6[Rep k G] C) :\n    ((MonoidalClosed.linearHomEquiv A B C).symm f).hom = TensorProduct.uncurry k A B C f.hom.flip", "start": [505, 1], "end": [508, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.MonoidalClosed.linearHomEquivComm_symm_hom", "code": "@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquivComm_symm_hom (f : A \u27f6 B \u27f6[Rep k G] C) :\n    ((MonoidalClosed.linearHomEquivComm A B C).symm f).hom\n      = TensorProduct.uncurry k A B C f.hom", "start": [513, 1], "end": [517, 36], "kind": "commanddeclaration"}, {"full_name": "Representation.repOfTprodIso", "code": "def repOfTprodIso : Rep.of (\u03c1.tprod \u03c4) \u2245 Rep.of \u03c1 \u2297 Rep.of \u03c4 :=\n  Iso.refl _", "start": [530, 1], "end": [532, 13], "kind": "commanddeclaration"}, {"full_name": "Representation.repOfTprodIso_apply", "code": "theorem repOfTprodIso_apply (x : TensorProduct k V W) : (repOfTprodIso \u03c1 \u03c4).hom.hom x = x", "start": [536, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "Representation.repOfTprodIso_inv_apply", "code": "theorem repOfTprodIso_inv_apply (x : TensorProduct k V W) : (repOfTprodIso \u03c1 \u03c4).inv.hom x = x", "start": [541, 1], "end": [542, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.to_Module_monoidAlgebra_map_aux", "code": "theorem to_Module_monoidAlgebra_map_aux {k G : Type*} [CommRing k] [Monoid G] (V W : Type*)\n    [AddCommGroup V] [AddCommGroup W] [Module k V] [Module k W] (\u03c1 : G \u2192* V \u2192\u2097[k] V)\n    (\u03c3 : G \u2192* W \u2192\u2097[k] W) (f : V \u2192\u2097[k] W) (w : \u2200 g : G, f.comp (\u03c1 g) = (\u03c3 g).comp f)\n    (r : MonoidAlgebra k G) (x : V) :\n    f ((((MonoidAlgebra.lift k G (V \u2192\u2097[k] V)) \u03c1) r) x) =\n      (((MonoidAlgebra.lift k G (W \u2192\u2097[k] W)) \u03c3) r) (f x)", "start": [566, 1], "end": [579, 97], "kind": "commanddeclaration"}, {"full_name": "Rep.toModuleMonoidAlgebraMap", "code": "def toModuleMonoidAlgebraMap {V W : Rep k G} (f : V \u27f6 W) :\n    ModuleCat.of (MonoidAlgebra k G) V.\u03c1.asModule \u27f6 ModuleCat.of (MonoidAlgebra k G) W.\u03c1.asModule :=\n  { f.hom with\n    map_smul' := fun r x => to_Module_monoidAlgebra_map_aux V.V W.V V.\u03c1 W.\u03c1 f.hom f.comm r x }", "start": [583, 1], "end": [587, 95], "kind": "commanddeclaration"}, {"full_name": "Rep.toModuleMonoidAlgebra", "code": "def toModuleMonoidAlgebra : Rep k G \u2964 ModuleCat.{u} (MonoidAlgebra k G) where\n  obj V := ModuleCat.of _ V.\u03c1.asModule\n  map f := toModuleMonoidAlgebraMap f", "start": [591, 1], "end": [594, 38], "kind": "commanddeclaration"}, {"full_name": "Rep.ofModuleMonoidAlgebra", "code": "def ofModuleMonoidAlgebra : ModuleCat.{u} (MonoidAlgebra k G) \u2964 Rep k G where\n  obj M := Rep.of (Representation.ofModule M)\n  map f :=\n    { hom := { f with map_smul' := fun r x => f.map_smul (algebraMap k _ r) x }\n      comm := fun g => by ext; apply f.map_smul }", "start": [598, 1], "end": [603, 50], "kind": "commanddeclaration"}, {"full_name": "Rep.ofModuleMonoidAlgebra_obj_coe", "code": "theorem ofModuleMonoidAlgebra_obj_coe (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (ofModuleMonoidAlgebra.obj M : Type u) = RestrictScalars k (MonoidAlgebra k G) M", "start": [607, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.ofModuleMonoidAlgebra_obj_\u03c1", "code": "theorem ofModuleMonoidAlgebra_obj_\u03c1 (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (ofModuleMonoidAlgebra.obj M).\u03c1 = Representation.ofModule M", "start": [613, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.counitIsoAddEquiv", "code": "def counitIsoAddEquiv {M : ModuleCat.{u} (MonoidAlgebra k G)} :\n    (ofModuleMonoidAlgebra \u22d9 toModuleMonoidAlgebra).obj M \u2243+ M := by\n  dsimp [ofModuleMonoidAlgebra, toModuleMonoidAlgebra]\n  refine' (Representation.ofModule M).asModuleEquiv.trans\n    (RestrictScalars.addEquiv k (MonoidAlgebra k G) _)", "start": [619, 1], "end": [624, 55], "kind": "commanddeclaration"}, {"full_name": "Rep.unitIsoAddEquiv", "code": "def unitIsoAddEquiv {V : Rep k G} : V \u2243+ (toModuleMonoidAlgebra \u22d9 ofModuleMonoidAlgebra).obj V := by\n  dsimp [ofModuleMonoidAlgebra, toModuleMonoidAlgebra]\n  refine' V.\u03c1.asModuleEquiv.symm.trans _\n  exact (RestrictScalars.addEquiv _ _ _).symm", "start": [628, 1], "end": [632, 46], "kind": "commanddeclaration"}, {"full_name": "Rep.counitIso", "code": "def counitIso (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (ofModuleMonoidAlgebra \u22d9 toModuleMonoidAlgebra).obj M \u2245 M :=\n  LinearEquiv.toModuleIso'\n    { counitIsoAddEquiv with\n      map_smul' := fun r x => by\n        dsimp [counitIsoAddEquiv]\n\n        rw [AddEquiv.coe_toEquiv, AddEquiv.trans_apply]\n        rw [AddEquiv.trans_apply]\n        erw [@Representation.ofModule_asAlgebraHom_apply_apply k G _ _ _ _ (_)]\n        exact AddEquiv.symm_apply_apply _ _}", "start": [636, 1], "end": [647, 45], "kind": "commanddeclaration"}, {"full_name": "Rep.unit_iso_comm", "code": "theorem unit_iso_comm (V : Rep k G) (g : G) (x : V) :\n    unitIsoAddEquiv ((V.\u03c1 g).toFun x) = ((ofModuleMonoidAlgebra.obj\n      (toModuleMonoidAlgebra.obj V)).\u03c1 g).toFun (unitIsoAddEquiv x)", "start": [651, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "Rep.unitIso", "code": "def unitIso (V : Rep k G) : V \u2245 (toModuleMonoidAlgebra \u22d9 ofModuleMonoidAlgebra).obj V :=\n  Action.mkIso\n    (LinearEquiv.toModuleIso'\n      { unitIsoAddEquiv with\n        map_smul' := fun r x => by\n          dsimp [unitIsoAddEquiv]\n\n                    erw [AddEquiv.coe_toEquiv, AddEquiv.trans_apply,\n            Representation.asModuleEquiv_symm_map_smul]\n          rfl })\n    fun g => by ext; apply unit_iso_comm", "start": [663, 1], "end": [677, 41], "kind": "commanddeclaration"}, {"full_name": "Rep.equivalenceModuleMonoidAlgebra", "code": "def equivalenceModuleMonoidAlgebra : Rep k G \u224c ModuleCat.{u} (MonoidAlgebra k G) where\n  functor := toModuleMonoidAlgebra\n  inverse := ofModuleMonoidAlgebra\n  unitIso := NatIso.ofComponents (fun V => unitIso V) (by aesop_cat)\n  counitIso := NatIso.ofComponents (fun M => counitIso M) (by aesop_cat)", "start": [681, 1], "end": [686, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Schur.lean", "imports": ["Mathlib/CategoryTheory/Simple.lean", "Mathlib/CategoryTheory/Endomorphism.lean", "Mathlib/Algebra/Group/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean", "Mathlib/CategoryTheory/Linear/Basic.lean"], "premises": [{"full_name": "CategoryTheory.mono_of_nonzero_from_simple", "code": "theorem mono_of_nonzero_from_simple [HasKernels C] {X Y : C} [Simple X] {f : X \u27f6 Y} (w : f \u2260 0) :\n    Mono f", "start": [36, 1], "end": [38, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_hom_simple", "code": "theorem isIso_of_hom_simple\n    [HasKernels C] {X Y : C} [Simple X] [Simple Y] {f : X \u27f6 Y} (w : f \u2260 0) : IsIso f", "start": [41, 1], "end": [47, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_iff_nonzero", "code": "theorem isIso_iff_nonzero [HasKernels C] {X Y : C} [Simple X] [Simple Y] (f : X \u27f6 Y) :\n    IsIso f \u2194 f \u2260 0", "start": [50, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_hom_simple_simple_eq_zero_of_not_iso", "code": "theorem finrank_hom_simple_simple_eq_zero_of_not_iso [HasKernels C] [Linear \ud835\udd5c C] {X Y : C}\n    [Simple X] [Simple Y] (h : (X \u2245 Y) \u2192 False) : finrank \ud835\udd5c (X \u27f6 Y) = 0", "start": [87, 1], "end": [97, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_endomorphism_eq_one", "code": "theorem finrank_endomorphism_eq_one {X : C} (isIso_iff_nonzero : \u2200 f : X \u27f6 X, IsIso f \u2194 f \u2260 0)\n    [I : FiniteDimensional \ud835\udd5c (X \u27f6 X)] : finrank \ud835\udd5c (X \u27f6 X) = 1", "start": [115, 1], "end": [131, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_endomorphism_simple_eq_one", "code": "theorem finrank_endomorphism_simple_eq_one (X : C) [Simple X] [FiniteDimensional \ud835\udd5c (X \u27f6 X)] :\n    finrank \ud835\udd5c (X \u27f6 X) = 1", "start": [136, 1], "end": [140, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.endomorphism_simple_eq_smul_id", "code": "theorem endomorphism_simple_eq_smul_id {X : C} [Simple X] [FiniteDimensional \ud835\udd5c (X \u27f6 X)]\n    (f : X \u27f6 X) : \u2203 c : \ud835\udd5c, c \u2022 \ud835\udfd9 X = f", "start": [143, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fieldEndOfFiniteDimensional", "code": "noncomputable def fieldEndOfFiniteDimensional (X : C) [Simple X] [I : FiniteDimensional \ud835\udd5c (X \u27f6 X)] :\n    Field (End X) := by\n  classical exact\n    { (inferInstance : DivisionRing (End X)) with\n      mul_comm := fun f g => by\n        obtain \u27e8c, rfl\u27e9 := endomorphism_simple_eq_smul_id \ud835\udd5c f\n        obtain \u27e8d, rfl\u27e9 := endomorphism_simple_eq_smul_id \ud835\udd5c g\n        simp [\u2190 mul_smul, mul_comm c d] }", "start": [149, 1], "end": [159, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_hom_simple_simple_le_one", "code": "theorem finrank_hom_simple_simple_le_one (X Y : C) [FiniteDimensional \ud835\udd5c (X \u27f6 X)] [Simple X]\n    [Simple Y] : finrank \ud835\udd5c (X \u27f6 Y) \u2264 1", "start": [164, 1], "end": [180, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_hom_simple_simple_eq_one_iff", "code": "theorem finrank_hom_simple_simple_eq_one_iff (X Y : C) [FiniteDimensional \ud835\udd5c (X \u27f6 X)]\n    [FiniteDimensional \ud835\udd5c (X \u27f6 Y)] [Simple X] [Simple Y] :\n    finrank \ud835\udd5c (X \u27f6 Y) = 1 \u2194 Nonempty (X \u2245 Y)", "start": [183, 1], "end": [196, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_hom_simple_simple_eq_zero_iff", "code": "theorem finrank_hom_simple_simple_eq_zero_iff (X Y : C) [FiniteDimensional \ud835\udd5c (X \u27f6 X)]\n    [FiniteDimensional \ud835\udd5c (X \u27f6 Y)] [Simple X] [Simple Y] :\n    finrank \ud835\udd5c (X \u27f6 Y) = 0 \u2194 IsEmpty (X \u2245 Y)", "start": [199, 1], "end": [207, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.finrank_hom_simple_simple", "code": "theorem finrank_hom_simple_simple (X Y : C) [\u2200 X Y : C, FiniteDimensional \ud835\udd5c (X \u27f6 Y)] [Simple X]\n    [Simple Y] : finrank \ud835\udd5c (X \u27f6 Y) = if Nonempty (X \u2245 Y) then 1 else 0", "start": [212, 1], "end": [216, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Deprecated/Submonoid.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "Mathlib/Deprecated/Group.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsAddSubmonoid", "code": "structure IsAddSubmonoid (s : Set A) : Prop where\n  \n  zero_mem : (0 : A) \u2208 s\n  \n  add_mem {a b} : a \u2208 s \u2192 b \u2208 s \u2192 a + b \u2208 s", "start": [40, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid", "code": "@[to_additive]\nstructure IsSubmonoid (s : Set M) : Prop where\n  \n  one_mem : (1 : M) \u2208 s\n  \n  mul_mem {a b} : a \u2208 s \u2192 b \u2208 s \u2192 a * b \u2208 s", "start": [50, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "Additive.isAddSubmonoid", "code": "theorem Additive.isAddSubmonoid {s : Set M} :\n    \u2200 _ : IsSubmonoid s, @IsAddSubmonoid (Additive M) _ s", "start": [61, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "Additive.isAddSubmonoid_iff", "code": "theorem Additive.isAddSubmonoid_iff {s : Set M} :\n    @IsAddSubmonoid (Additive M) _ s \u2194 IsSubmonoid s", "start": [66, 1], "end": [68, 55], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isSubmonoid", "code": "theorem Multiplicative.isSubmonoid {s : Set A} :\n    \u2200 _ : IsAddSubmonoid s, @IsSubmonoid (Multiplicative A) _ s", "start": [71, 1], "end": [73, 26], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isSubmonoid_iff", "code": "theorem Multiplicative.isSubmonoid_iff {s : Set A} :\n    @IsSubmonoid (Multiplicative A) _ s \u2194 IsAddSubmonoid s", "start": [76, 1], "end": [78, 58], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.inter", "code": "@[to_additive\n      \"The intersection of two `AddSubmonoid`s of an `AddMonoid` `M` is an `AddSubmonoid` of M.\"]\ntheorem IsSubmonoid.inter {s\u2081 s\u2082 : Set M} (is\u2081 : IsSubmonoid s\u2081) (is\u2082 : IsSubmonoid s\u2082) :\n    IsSubmonoid (s\u2081 \u2229 s\u2082)", "start": [81, 1], "end": [87, 82], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.iInter", "code": "@[to_additive\n      \"The intersection of an indexed set of `AddSubmonoid`s of an `AddMonoid` `M` is\n      an `AddSubmonoid` of `M`.\"]\ntheorem IsSubmonoid.iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set M} (h : \u2200 y : \u03b9, IsSubmonoid (s y)) :\n    IsSubmonoid (Set.iInter s)", "start": [91, 1], "end": [99, 96], "kind": "commanddeclaration"}, {"full_name": "isSubmonoid_iUnion_of_directed", "code": "@[to_additive\n      \"The union of an indexed, directed, nonempty set of `AddSubmonoid`s of an `AddMonoid` `M`\n      is an `AddSubmonoid` of `M`. \"]\ntheorem isSubmonoid_iUnion_of_directed {\u03b9 : Type*} [h\u03b9 : Nonempty \u03b9] {s : \u03b9 \u2192 Set M}\n    (hs : \u2200 i, IsSubmonoid (s i)) (Directed : \u2200 i j, \u2203 k, s i \u2286 s k \u2227 s j \u2286 s k) :\n    IsSubmonoid (\u22c3 i, s i)", "start": [103, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "powers", "code": "@[to_additive multiples\n      \"The set of natural number multiples `0, x, 2x, ...` of an element `x` of an `AddMonoid`.\"]\ndef powers (x : M) : Set M :=\n  { y | \u2203 n : \u2115, x ^ n = y }", "start": [124, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "powers.one_mem", "code": "@[to_additive \"0 is in the set of natural number multiples of an element of an `AddMonoid`.\"]\ntheorem powers.one_mem {x : M} : (1 : M) \u2208 powers x", "start": [132, 1], "end": [135, 18], "kind": "commanddeclaration"}, {"full_name": "powers.self_mem", "code": "@[to_additive\n      \"An element of an `AddMonoid` is in the set of that element's natural number multiples.\"]\ntheorem powers.self_mem {x : M} : x \u2208 powers x", "start": [139, 1], "end": [143, 17], "kind": "commanddeclaration"}, {"full_name": "powers.mul_mem", "code": "@[to_additive\n      \"The set of natural number multiples of an element of an `AddMonoid` is closed under\n      addition.\"]\ntheorem powers.mul_mem {x y z : M} : y \u2208 powers x \u2192 z \u2208 powers x \u2192 y * z \u2208 powers x", "start": [147, 1], "end": [152, 64], "kind": "commanddeclaration"}, {"full_name": "powers.isSubmonoid", "code": "@[to_additive\n      \"The set of natural number multiples of an element of an `AddMonoid` `M` is\n      an `AddSubmonoid` of `M`.\"]\ntheorem powers.isSubmonoid (x : M) : IsSubmonoid (powers x)", "start": [156, 1], "end": [162, 32], "kind": "commanddeclaration"}, {"full_name": "Univ.isSubmonoid", "code": "@[to_additive \"An `AddMonoid` is an `AddSubmonoid` of itself.\"]\ntheorem Univ.isSubmonoid : IsSubmonoid (@Set.univ M)", "start": [166, 1], "end": [168, 80], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.preimage", "code": "@[to_additive\n      \"The preimage of an `AddSubmonoid` under an `AddMonoid` hom is\n      an `AddSubmonoid` of the domain.\"]\ntheorem IsSubmonoid.preimage {N : Type*} [Monoid N] {f : M \u2192 N} (hf : IsMonoidHom f) {s : Set N}\n    (hs : IsSubmonoid s) : IsSubmonoid (f \u207b\u00b9' s)", "start": [172, 1], "end": [180, 85], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.image", "code": "@[to_additive\n      \"The image of an `AddSubmonoid` under an `AddMonoid` hom is an `AddSubmonoid` of the\n      codomain.\"]\ntheorem IsSubmonoid.image {\u03b3 : Type*} [Monoid \u03b3] {f : M \u2192 \u03b3} (hf : IsMonoidHom f) {s : Set M}\n    (hs : IsSubmonoid s) : IsSubmonoid (f '' s)", "start": [184, 1], "end": [192, 70], "kind": "commanddeclaration"}, {"full_name": "Range.isSubmonoid", "code": "@[to_additive \"The image of an `AddMonoid` hom is an `AddSubmonoid` of the codomain.\"]\ntheorem Range.isSubmonoid {\u03b3 : Type*} [Monoid \u03b3] {f : M \u2192 \u03b3} (hf : IsMonoidHom f) :\n    IsSubmonoid (Set.range f)", "start": [196, 1], "end": [201, 34], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.pow_mem", "code": "@[to_additive\n      \"An `AddSubmonoid` is closed under multiplication by naturals.\"]\ntheorem IsSubmonoid.pow_mem {a : M} (hs : IsSubmonoid s) (h : a \u2208 s) : \u2200 {n : \u2115}, a ^ n \u2208 s", "start": [205, 1], "end": [214, 50], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.power_subset", "code": "@[to_additive IsAddSubmonoid.multiples_subset\n      \"The set of natural number multiples of an element of an `AddSubmonoid` is a subset of\n      the `AddSubmonoid`.\"]\ntheorem IsSubmonoid.power_subset {a : M} (hs : IsSubmonoid s) (h : a \u2208 s) : powers a \u2286 s", "start": [217, 1], "end": [222, 37], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.list_prod_mem", "code": "@[to_additive\n      \"The sum of a list of elements of an `AddSubmonoid` is an element of the `AddSubmonoid`.\"]\ntheorem list_prod_mem (hs : IsSubmonoid s) : \u2200 {l : List M}, (\u2200 x \u2208 l, x \u2208 s) \u2192 l.prod \u2208 s", "start": [230, 1], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.multiset_prod_mem", "code": "@[to_additive\n      \"The sum of a multiset of elements of an `AddSubmonoid` of an `AddCommMonoid`\n      is an element of the `AddSubmonoid`. \"]\ntheorem multiset_prod_mem {M} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (m : Multiset M) :\n    (\u2200 a \u2208 m, a \u2208 s) \u2192 m.prod \u2208 s", "start": [242, 1], "end": [251, 28], "kind": "commanddeclaration"}, {"full_name": "IsSubmonoid.finset_prod_mem", "code": "@[to_additive\n      \"The sum of elements of an `AddSubmonoid` of an `AddCommMonoid` indexed by\n      a `Finset` is an element of the `AddSubmonoid`.\"]\ntheorem finset_prod_mem {M A} [CommMonoid M] {s : Set M} (hs : IsSubmonoid s) (f : A \u2192 M) :\n    \u2200 t : Finset A, (\u2200 b \u2208 t, f b \u2208 s) \u2192 (\u220f b in t, f b) \u2208 s", "start": [255, 1], "end": [262, 52], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.InClosure", "code": "inductive InClosure (s : Set A) : A \u2192 Prop\n  | basic {a : A} : a \u2208 s \u2192 InClosure _ a\n  | zero : InClosure _ 0\n  | add {a b : A} : InClosure _ a \u2192 InClosure _ b \u2192 InClosure _ (a + b)", "start": [270, 1], "end": [275, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.InClosure", "code": "@[to_additive]\ninductive InClosure (s : Set M) : M \u2192 Prop\n  | basic {a : M} : a \u2208 s \u2192 InClosure _ a\n  | one : InClosure _ 1\n  | mul {a b : M} : InClosure _ a \u2192 InClosure _ b \u2192 InClosure _ (a * b)", "start": [282, 1], "end": [288, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.Closure", "code": "@[to_additive\n      \"The inductively defined `AddSubmonoid` generated by a subset of an `AddMonoid`.\"]\ndef Closure (s : Set M) : Set M :=\n  { a | InClosure s a }", "start": [291, 1], "end": [295, 24], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure.isSubmonoid", "code": "@[to_additive]\ntheorem closure.isSubmonoid (s : Set M) : IsSubmonoid (Closure s)", "start": [299, 1], "end": [302, 31], "kind": "commanddeclaration"}, {"full_name": "Monoid.subset_closure", "code": "@[to_additive\n    \"A subset of an `AddMonoid` is contained in the `AddSubmonoid` it generates.\"]\ntheorem subset_closure {s : Set M} : s \u2286 Closure s", "start": [306, 1], "end": [309, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure_subset", "code": "@[to_additive\n      \"The `AddSubmonoid` generated by a set is contained in any `AddSubmonoid` that\n      contains the set.\"]\ntheorem closure_subset {s t : Set M} (ht : IsSubmonoid t) (h : s \u2286 t) : Closure s \u2286 t", "start": [313, 1], "end": [318, 78], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure_mono", "code": "@[to_additive\n      \"Given subsets `t` and `s` of an `AddMonoid M`, if `s \u2286 t`, the `AddSubmonoid`\n      of `M` generated by `s` is contained in the `AddSubmonoid` generated by `t`.\"]\ntheorem closure_mono {s t : Set M} (h : s \u2286 t) : Closure s \u2286 Closure t", "start": [322, 1], "end": [328, 78], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure_singleton", "code": "@[to_additive\n      \"The `AddSubmonoid` generated by an element of an `AddMonoid` equals the set of\n      natural number multiples of the element.\"]\ntheorem closure_singleton {x : M} : Closure ({x} : Set M) = powers x", "start": [332, 1], "end": [341, 51], "kind": "commanddeclaration"}, {"full_name": "Monoid.image_closure", "code": "@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\n      the `AddSubmonoid` generated by the image of the set under the `AddMonoid` hom.\"]\ntheorem image_closure {A : Type*} [Monoid A] {f : M \u2192 A} (hf : IsMonoidHom f) (s : Set M) :\n    f '' Closure s = Closure (f '' s)", "start": [345, 1], "end": [362, 41], "kind": "commanddeclaration"}, {"full_name": "Monoid.exists_list_of_mem_closure", "code": "@[to_additive\n      \"Given an element `a` of the `AddSubmonoid` of an `AddMonoid M` generated by\n      a set `s`, there exists a list of elements of `s` whose sum is `a`.\"]\ntheorem exists_list_of_mem_closure {s : Set M} {a : M} (h : a \u2208 Closure s) :\n    \u2203 l : List M, (\u2200 x \u2208 l, x \u2208 s) \u2227 l.prod = a", "start": [366, 1], "end": [381, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.mem_closure_union_iff", "code": "@[to_additive\n      \"Given sets `s, t` of a commutative `AddMonoid M`, `x \u2208 M` is in the `AddSubmonoid`\n      of `M` generated by `s \u222a t` iff there exists an element of the `AddSubmonoid` generated by `s`\n      and an element of the `AddSubmonoid` generated by `t` whose sum is `x`.\"]\ntheorem mem_closure_union_iff {M : Type*} [CommMonoid M] {s t : Set M} {x : M} :\n    x \u2208 Closure (s \u222a t) \u2194 \u2203 y \u2208 Closure s, \u2203 z \u2208 Closure t, y * z = x", "start": [385, 1], "end": [413, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.of", "code": "@[to_additive \"Create a bundled additive submonoid from a set `s` and `[IsAddSubmonoid s]`.\"]\ndef Submonoid.of {s : Set M} (h : IsSubmonoid s) : Submonoid M :=\n  \u27e8\u27e8s, @fun _ _ => h.2\u27e9, h.1\u27e9", "start": [419, 1], "end": [422, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.isSubmonoid", "code": "@[to_additive]\ntheorem Submonoid.isSubmonoid (S : Submonoid M) : IsSubmonoid (S : Set M)", "start": [426, 1], "end": [428, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Heyting/Hom.lean", "imports": ["Mathlib/Order/Hom/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HeytingHom", "code": "structure HeytingHom (\u03b1 \u03b2 : Type*) [HeytingAlgebra \u03b1] [HeytingAlgebra \u03b2] extends\n  LatticeHom \u03b1 \u03b2 where\n  \n  protected map_bot' : toFun \u22a5 = \u22a5\n  \n  protected map_himp' : \u2200 a b, toFun (a \u21e8 b) = toFun a \u21e8 toFun b", "start": [37, 1], "end": [44, 65], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom", "code": "structure CoheytingHom (\u03b1 \u03b2 : Type*) [CoheytingAlgebra \u03b1] [CoheytingAlgebra \u03b2] extends\n  LatticeHom \u03b1 \u03b2 where\n  \n  protected map_top' : toFun \u22a4 = \u22a4\n  \n  protected map_sdiff' : \u2200 a b, toFun (a \\ b) = toFun a \\ toFun b", "start": [47, 1], "end": [54, 66], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom", "code": "structure BiheytingHom (\u03b1 \u03b2 : Type*) [BiheytingAlgebra \u03b1] [BiheytingAlgebra \u03b2] extends\n  LatticeHom \u03b1 \u03b2 where\n  \n  protected map_himp' : \u2200 a b, toFun (a \u21e8 b) = toFun a \u21e8 toFun b\n  \n  protected map_sdiff' : \u2200 a b, toFun (a \\ b) = toFun a \\ toFun b", "start": [57, 1], "end": [64, 66], "kind": "commanddeclaration"}, {"full_name": "HeytingHomClass", "code": "class HeytingHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [HeytingAlgebra \u03b1]\n  [HeytingAlgebra \u03b2] extends LatticeHomClass F \u03b1 \u03b2 where\n  \n  map_bot (f : F) : f \u22a5 = \u22a5\n  \n  map_himp (f : F) : \u2200 a b, f (a \u21e8 b) = f a \u21e8 f b", "start": [67, 1], "end": [75, 50], "kind": "commanddeclaration"}, {"full_name": "CoheytingHomClass", "code": "class CoheytingHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [CoheytingAlgebra \u03b1]\n  [CoheytingAlgebra \u03b2] extends LatticeHomClass F \u03b1 \u03b2 where\n  \n  map_top (f : F) : f \u22a4 = \u22a4\n  \n  map_sdiff (f : F) : \u2200 a b, f (a \\ b) = f a \\ f b", "start": [78, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "BiheytingHomClass", "code": "class BiheytingHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [BiheytingAlgebra \u03b1]\n  [BiheytingAlgebra \u03b2] extends LatticeHomClass F \u03b1 \u03b2 where\n  \n  map_himp (f : F) : \u2200 a b, f (a \u21e8 b) = f a \u21e8 f b\n  \n  map_sdiff (f : F) : \u2200 a b, f (a \\ b) = f a \\ f b", "start": [89, 1], "end": [97, 51], "kind": "commanddeclaration"}, {"full_name": "HeytingHomClass.toBoundedLatticeHomClass", "code": "instance (priority := 100) HeytingHomClass.toBoundedLatticeHomClass [HeytingAlgebra \u03b1]\n    { _ : HeytingAlgebra \u03b2} [HeytingHomClass F \u03b1 \u03b2] : BoundedLatticeHomClass F \u03b1 \u03b2 :=\n  { \u2039HeytingHomClass F \u03b1 \u03b2\u203a with\n    map_top := fun f => by rw [\u2190 @himp_self \u03b1 _ \u22a5, \u2190 himp_self, map_himp] }", "start": [109, 1], "end": [112, 76], "kind": "commanddeclaration"}, {"full_name": "CoheytingHomClass.toBoundedLatticeHomClass", "code": "instance (priority := 100) CoheytingHomClass.toBoundedLatticeHomClass [CoheytingAlgebra \u03b1]\n    { _ : CoheytingAlgebra \u03b2} [CoheytingHomClass F \u03b1 \u03b2] : BoundedLatticeHomClass F \u03b1 \u03b2 :=\n  { \u2039CoheytingHomClass F \u03b1 \u03b2\u203a with\n    map_bot := fun f => by rw [\u2190 @sdiff_self \u03b1 _ \u22a4, \u2190 sdiff_self, map_sdiff] }", "start": [116, 1], "end": [119, 79], "kind": "commanddeclaration"}, {"full_name": "BiheytingHomClass.toHeytingHomClass", "code": "instance (priority := 100) BiheytingHomClass.toHeytingHomClass [BiheytingAlgebra \u03b1]\n    { _ : BiheytingAlgebra \u03b2} [BiheytingHomClass F \u03b1 \u03b2] : HeytingHomClass F \u03b1 \u03b2 :=\n  { \u2039BiheytingHomClass F \u03b1 \u03b2\u203a with\n    map_bot := fun f => by rw [\u2190 @sdiff_self \u03b1 _ \u22a4, \u2190 sdiff_self, BiheytingHomClass.map_sdiff] }", "start": [123, 1], "end": [126, 97], "kind": "commanddeclaration"}, {"full_name": "BiheytingHomClass.toCoheytingHomClass", "code": "instance (priority := 100) BiheytingHomClass.toCoheytingHomClass [BiheytingAlgebra \u03b1]\n    { _ : BiheytingAlgebra \u03b2} [BiheytingHomClass F \u03b1 \u03b2] : CoheytingHomClass F \u03b1 \u03b2 :=\n  { \u2039BiheytingHomClass F \u03b1 \u03b2\u203a with\n    map_top := fun f => by rw [\u2190 @himp_self \u03b1 _ \u22a5, \u2190 himp_self, map_himp] }", "start": [130, 1], "end": [133, 76], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toHeytingHomClass", "code": "instance (priority := 100) OrderIsoClass.toHeytingHomClass [HeytingAlgebra \u03b1]\n    { _ : HeytingAlgebra \u03b2} [OrderIsoClass F \u03b1 \u03b2] : HeytingHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toBoundedLatticeHomClass with\n    map_himp := fun f a b =>\n      eq_of_forall_le_iff fun c => by\n        simp only [\u2190 map_inv_le_iff, le_himp_iff]\n        rw [\u2190 OrderIsoClass.map_le_map_iff f]\n        simp }", "start": [137, 1], "end": [144, 15], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toCoheytingHomClass", "code": "instance (priority := 100) OrderIsoClass.toCoheytingHomClass [CoheytingAlgebra \u03b1]\n    { _ : CoheytingAlgebra \u03b2} [OrderIsoClass F \u03b1 \u03b2] : CoheytingHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toBoundedLatticeHomClass with\n    map_sdiff := fun f a b =>\n      eq_of_forall_ge_iff fun c => by\n        simp only [\u2190 le_map_inv_iff, sdiff_le_iff]\n        rw [\u2190 OrderIsoClass.map_le_map_iff f]\n        simp }", "start": [148, 1], "end": [155, 15], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toBiheytingHomClass", "code": "instance (priority := 100) OrderIsoClass.toBiheytingHomClass [BiheytingAlgebra \u03b1]\n    { _ : BiheytingAlgebra \u03b2} [OrderIsoClass F \u03b1 \u03b2] : BiheytingHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toLatticeHomClass with\n    map_himp := fun f a b =>\n      eq_of_forall_le_iff fun c => by\n        simp only [\u2190 map_inv_le_iff, le_himp_iff]\n        rw [\u2190 OrderIsoClass.map_le_map_iff f]\n        simp\n    map_sdiff := fun f a b =>\n      eq_of_forall_ge_iff fun c => by\n        simp only [\u2190 le_map_inv_iff, sdiff_le_iff]\n        rw [\u2190 OrderIsoClass.map_le_map_iff f]\n        simp }", "start": [159, 1], "end": [171, 15], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHomClass.toBiheytingHomClass", "code": "@[reducible]\ndef BoundedLatticeHomClass.toBiheytingHomClass [BooleanAlgebra \u03b1] [BooleanAlgebra \u03b2]\n    [BoundedLatticeHomClass F \u03b1 \u03b2] : BiheytingHomClass F \u03b1 \u03b2 :=\n  { \u2039BoundedLatticeHomClass F \u03b1 \u03b2\u203a with\n    map_himp := fun f a b => by rw [himp_eq, himp_eq, map_sup, (isCompl_compl.map _).compl_eq]\n    map_sdiff := fun f a b => by rw [sdiff_eq, sdiff_eq, map_inf, (isCompl_compl.map _).compl_eq] }", "start": [176, 1], "end": [182, 100], "kind": "commanddeclaration"}, {"full_name": "map_compl", "code": "@[simp]\ntheorem map_compl (a : \u03b1) : f a\u1d9c = (f a)\u1d9c", "start": [189, 1], "end": [190, 95], "kind": "commanddeclaration"}, {"full_name": "map_bihimp", "code": "@[simp]\ntheorem map_bihimp (a b : \u03b1) : f (a \u21d4 b) = f a \u21d4 f b", "start": [193, 1], "end": [194, 95], "kind": "commanddeclaration"}, {"full_name": "map_hnot", "code": "@[simp]\ntheorem map_hnot (a : \u03b1) : f (\uffe2a) = \uffe2f a", "start": [204, 1], "end": [205, 99], "kind": "commanddeclaration"}, {"full_name": "map_symmDiff", "code": "@[simp]\ntheorem map_symmDiff (a b : \u03b1) : f (a \u2206 b) = f a \u2206 f b", "start": [208, 1], "end": [209, 100], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.instHeytingHomClass", "code": "instance instHeytingHomClass : HeytingHomClass (HeytingHom \u03b1 \u03b2) \u03b1 \u03b2 where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9 := f; obtain \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9 := g; congr\n  map_sup f := f.map_sup'\n  map_inf f := f.map_inf'\n  map_bot f := f.map_bot'\n  map_himp := HeytingHom.map_himp'", "start": [244, 1], "end": [250, 35], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : HeytingHom \u03b1 \u03b2} : f.toFun = \u21d1f", "start": [260, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.toFun_eq_coe_aux", "code": "@[simp]\ntheorem toFun_eq_coe_aux {f : HeytingHom \u03b1 \u03b2} : (\u2191f.toLatticeHom) = \u21d1f", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.ext", "code": "@[ext]\ntheorem ext {f g : HeytingHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [268, 1], "end": [270, 20], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.copy", "code": "protected def copy (f : HeytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : HeytingHom \u03b1 \u03b2 where\n  toFun := f'\n  map_sup' := by simpa only [h] using map_sup f\n  map_inf' := by simpa only [h] using map_inf f\n  map_bot' := by simpa only [h] using map_bot f\n  map_himp' := by simpa only [h] using map_himp f", "start": [273, 1], "end": [280, 50], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : HeytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.copy_eq", "code": "theorem copy_eq (f : HeytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [288, 1], "end": [289, 17], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.id", "code": "protected def id : HeytingHom \u03b1 \u03b1 :=\n  { BotHom.id _ with\n    toLatticeHom := LatticeHom.id _\n    map_himp' := fun _ _ => rfl }", "start": [294, 1], "end": [298, 34], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(HeytingHom.id \u03b1) = id", "start": [301, 1], "end": [303, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : HeytingHom.id \u03b1 a = a", "start": [308, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.comp", "code": "def comp (f : HeytingHom \u03b2 \u03b3) (g : HeytingHom \u03b1 \u03b2) : HeytingHom \u03b1 \u03b3 :=\n  { f.toLatticeHom.comp g.toLatticeHom with\n    toFun := f \u2218 g\n    map_bot' := by simp\n    map_himp' := fun a b => by simp }", "start": [319, 1], "end": [324, 38], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : HeytingHom \u03b2 \u03b3) (g : HeytingHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [329, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : HeytingHom \u03b2 \u03b3) (g : HeytingHom \u03b1 \u03b2) (a : \u03b1) : f.comp g a = f (g a)", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : HeytingHom \u03b3 \u03b4) (g : HeytingHom \u03b2 \u03b3) (h : HeytingHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [339, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : HeytingHom \u03b1 \u03b2) : f.comp (HeytingHom.id \u03b1) = f", "start": [345, 1], "end": [347, 19], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : HeytingHom \u03b1 \u03b2) : (HeytingHom.id \u03b2).comp f = f", "start": [350, 1], "end": [352, 19], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [355, 1], "end": [357, 85], "kind": "commanddeclaration"}, {"full_name": "HeytingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left (hg : Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [360, 1], "end": [362, 92], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : CoheytingHom \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [387, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.toFun_eq_coe_aux", "code": "@[simp]\ntheorem toFun_eq_coe_aux {f : CoheytingHom \u03b1 \u03b2} : (\u2191f.toLatticeHom) = \u21d1f", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.ext", "code": "@[ext]\ntheorem ext {f g : CoheytingHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [395, 1], "end": [397, 20], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.copy", "code": "protected def copy (f : CoheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : CoheytingHom \u03b1 \u03b2 where\n  toFun := f'\n  map_sup' := by simpa only [h] using map_sup f\n  map_inf' := by simpa only [h] using map_inf f\n  map_top' := by simpa only [h] using map_top f\n  map_sdiff' := by simpa only [h] using map_sdiff f", "start": [400, 1], "end": [407, 52], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : CoheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [410, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.copy_eq", "code": "theorem copy_eq (f : CoheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [415, 1], "end": [416, 17], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.id", "code": "protected def id : CoheytingHom \u03b1 \u03b1 :=\n  { TopHom.id _ with\n    toLatticeHom := LatticeHom.id _\n    map_sdiff' := fun _ _ => rfl }", "start": [421, 1], "end": [425, 35], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(CoheytingHom.id \u03b1) = id", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : CoheytingHom.id \u03b1 a = a", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.comp", "code": "def comp (f : CoheytingHom \u03b2 \u03b3) (g : CoheytingHom \u03b1 \u03b2) : CoheytingHom \u03b1 \u03b3 :=\n  { f.toLatticeHom.comp g.toLatticeHom with\n    toFun := f \u2218 g\n    map_top' := by simp\n    map_sdiff' := fun a b => by simp }", "start": [446, 1], "end": [451, 39], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : CoheytingHom \u03b2 \u03b3) (g : CoheytingHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [456, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : CoheytingHom \u03b2 \u03b3) (g : CoheytingHom \u03b1 \u03b2) (a : \u03b1) : f.comp g a = f (g a)", "start": [461, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : CoheytingHom \u03b3 \u03b4) (g : CoheytingHom \u03b2 \u03b3) (h : CoheytingHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [466, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : CoheytingHom \u03b1 \u03b2) : f.comp (CoheytingHom.id \u03b1) = f", "start": [472, 1], "end": [474, 19], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : CoheytingHom \u03b1 \u03b2) : (CoheytingHom.id \u03b2).comp f = f", "start": [477, 1], "end": [479, 19], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [482, 1], "end": [484, 85], "kind": "commanddeclaration"}, {"full_name": "CoheytingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left (hg : Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [487, 1], "end": [489, 94], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : BiheytingHom \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [513, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.toFun_eq_coe_aux", "code": "@[simp]\ntheorem toFun_eq_coe_aux {f : BiheytingHom \u03b1 \u03b2} : (\u2191f.toLatticeHom) = \u21d1f", "start": [517, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.ext", "code": "@[ext]\ntheorem ext {f g : BiheytingHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [521, 1], "end": [523, 20], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.copy", "code": "protected def copy (f : BiheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : BiheytingHom \u03b1 \u03b2 where\n  toFun := f'\n  map_sup' := by simpa only [h] using map_sup f\n  map_inf' := by simpa only [h] using map_inf f\n  map_himp' := by simpa only [h] using map_himp f\n  map_sdiff' := by simpa only [h] using map_sdiff f", "start": [526, 1], "end": [533, 52], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : BiheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [536, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.copy_eq", "code": "theorem copy_eq (f : BiheytingHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [541, 1], "end": [542, 17], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.id", "code": "protected def id : BiheytingHom \u03b1 \u03b1 :=\n  { HeytingHom.id _, CoheytingHom.id _ with toLatticeHom := LatticeHom.id _ }", "start": [547, 1], "end": [549, 78], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(BiheytingHom.id \u03b1) = id", "start": [552, 1], "end": [554, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : BiheytingHom.id \u03b1 a = a", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.comp", "code": "def comp (f : BiheytingHom \u03b2 \u03b3) (g : BiheytingHom \u03b1 \u03b2) : BiheytingHom \u03b1 \u03b3 :=\n  { f.toLatticeHom.comp g.toLatticeHom with\n    toFun := f \u2218 g\n    map_himp' := fun a b => by simp\n    map_sdiff' := fun a b => by simp }", "start": [570, 1], "end": [575, 39], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : BiheytingHom \u03b2 \u03b3) (g : BiheytingHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [580, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : BiheytingHom \u03b2 \u03b3) (g : BiheytingHom \u03b1 \u03b2) (a : \u03b1) : f.comp g a = f (g a)", "start": [585, 1], "end": [587, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : BiheytingHom \u03b3 \u03b4) (g : BiheytingHom \u03b2 \u03b3) (h : BiheytingHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [590, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : BiheytingHom \u03b1 \u03b2) : f.comp (BiheytingHom.id \u03b1) = f", "start": [596, 1], "end": [598, 19], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : BiheytingHom \u03b1 \u03b2) : (BiheytingHom.id \u03b2).comp f = f", "start": [601, 1], "end": [603, 19], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [606, 1], "end": [608, 85], "kind": "commanddeclaration"}, {"full_name": "BiheytingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left (hg : Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [611, 1], "end": [613, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/BddDistLat.lean", "imports": ["Mathlib/Order/Category/DistLat.lean", "Mathlib/Order/Category/BddLat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BddDistLat", "code": "structure BddDistLat where\n  toDistLat : DistLat\n  [isBoundedOrder : BoundedOrder toDistLat]", "start": [26, 1], "end": [29, 44], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.of", "code": "def of (\u03b1 : Type*) [DistribLattice \u03b1] [BoundedOrder \u03b1] : BddDistLat :=\n  \u27e8{\u03b1 := \u03b1}\u27e9", "start": [42, 1], "end": [46, 13], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [DistribLattice \u03b1] [BoundedOrder \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.toBddLat", "code": "def toBddLat (X : BddDistLat) : BddLat :=\n  BddLat.of X", "start": [57, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.coe_toBddLat", "code": "@[simp]\ntheorem coe_toBddLat (X : BddDistLat) : \u21a5X.toBddLat = \u21a5X", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.hasForgetToDistLat", "code": "instance hasForgetToDistLat : HasForget\u2082 BddDistLat DistLat where\n  forget\u2082 :=\n    { obj := fun X => { \u03b1 := X }\n      map := fun {X Y} => BoundedLatticeHom.toLatticeHom }", "start": [73, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.hasForgetToBddLat", "code": "instance hasForgetToBddLat : HasForget\u2082 BddDistLat BddLat :=\n  InducedCategory.hasForget\u2082 toBddLat", "start": [81, 1], "end": [82, 38], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.forget_bddLat_lat_eq_forget_distLat_lat", "code": "theorem forget_bddLat_lat_eq_forget_distLat_lat :\n    forget\u2082 BddDistLat BddLat \u22d9 forget\u2082 BddLat Lat =\n      forget\u2082 BddDistLat DistLat \u22d9 forget\u2082 DistLat Lat", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : BddDistLat.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : BoundedLatticeHom \u03b1 \u03b2)\n  inv := (e.symm : BoundedLatticeHom \u03b2 \u03b1)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [91, 1], "end": [98, 51], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.dual", "code": "@[simps]\ndef dual : BddDistLat \u2964 BddDistLat where\n  obj X := of X\u1d52\u1d48\n  map {X Y} := BoundedLatticeHom.dual", "start": [101, 1], "end": [105, 38], "kind": "commanddeclaration"}, {"full_name": "BddDistLat.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : BddDistLat \u224c BddDistLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [108, 1], "end": [114, 74], "kind": "commanddeclaration"}, {"full_name": "bddDistLat_dual_comp_forget_to_distLat", "code": "theorem bddDistLat_dual_comp_forget_to_distLat :\n    BddDistLat.dual \u22d9 forget\u2082 BddDistLat DistLat =\n      forget\u2082 BddDistLat DistLat \u22d9 DistLat.dual", "start": [119, 1], "end": [122, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortExact/Abelian.lean", "imports": ["Mathlib/CategoryTheory/Abelian/DiagramLemmas/Four.lean", "Mathlib/Algebra/Homology/ShortExact/Preadditive.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.isIso_of_shortExact_of_isIso_of_isIso", "code": "theorem isIso_of_shortExact_of_isIso_of_isIso (h : ShortExact f g) (h' : ShortExact f' g')\n    (i\u2081 : A \u27f6 A') (i\u2082 : B \u27f6 B') (i\u2083 : C \u27f6 C')\n    (comm\u2081 : i\u2081 \u226b f' = f \u226b i\u2082 := by aesop_cat)\n    (comm\u2082 : i\u2082 \u226b g' = g \u226b i\u2083 := by aesop_cat) [IsIso i\u2081] [IsIso i\u2083] : IsIso i\u2082", "start": [32, 1], "end": [43, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Splitting.mk'", "code": "def Splitting.mk' (h : ShortExact f g) (i : B \u27f6 A \u229e C) (h1 : f \u226b i = biprod.inl)\n    (h2 : i \u226b biprod.snd = g) : Splitting f g :=\n  have : IsIso i := isIso_of_shortExact_of_isIso_of_isIso h \u27e8exact_inl_snd A C\u27e9 (\ud835\udfd9 _) i (\ud835\udfd9 _)\n  { iso := asIso i\n    comp_iso_eq_inl := h1\n    iso_comp_snd_eq := h2 }", "start": [46, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Splitting.mk''", "code": "def Splitting.mk'' (h : ShortExact f g) (i : A \u229e C \u27f6 B) (h1 : biprod.inl \u226b i = f)\n    (h2 : i \u226b g = biprod.snd) : Splitting f g :=\n  have : IsIso i := isIso_of_shortExact_of_isIso_of_isIso \u27e8exact_inl_snd A C\u27e9 h (\ud835\udfd9 _) i (\ud835\udfd9 _)\n  { iso := (asIso i).symm\n    comp_iso_eq_inl := by rw [Iso.symm_hom, asIso_inv, IsIso.comp_inv_eq, h1]\n    iso_comp_snd_eq := by rw [Iso.symm_hom, asIso_inv, IsIso.inv_comp_eq, h2] }", "start": [60, 1], "end": [71, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LeftSplit.splitting", "code": "def LeftSplit.splitting {f : A \u27f6 B} {g : B \u27f6 C} (h : LeftSplit f g) : Splitting f g :=\n  Splitting.mk' h.shortExact (biprod.lift h.left_split.choose g)\n    (by\n      ext\n      \u00b7 simpa only [biprod.inl_fst, biprod.lift_fst, Category.assoc] using h.left_split.choose_spec\n      \u00b7 simp only [biprod.inl_snd, biprod.lift_snd, Category.assoc, h.exact.w])\n    (by simp only [biprod.lift_snd])", "start": [74, 1], "end": [81, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.RightSplit.splitting", "code": "def RightSplit.splitting {f : A \u27f6 B} {g : B \u27f6 C} (h : RightSplit f g) : Splitting f g :=\n  Splitting.mk'' h.shortExact (biprod.desc f h.right_split.choose) (biprod.inl_desc _ _)\n    (by\n      ext\n      \u00b7 rw [biprod.inl_snd, \u2190 Category.assoc, biprod.inl_desc, h.exact.w]\n      \u00b7 rw [biprod.inr_snd, \u2190 Category.assoc, biprod.inr_desc, h.right_split.choose_spec])", "start": [84, 1], "end": [90, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Integration.lean", "imports": ["Mathlib/MeasureTheory/Integral/SetIntegral.lean", "Mathlib/Probability/Independence/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator", "code": "theorem lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator {Mf m\u03a9 : MeasurableSpace \u03a9}\n    {\u03bc : Measure \u03a9} (hMf : Mf \u2264 m\u03a9) (c : \u211d\u22650\u221e) {T : Set \u03a9} (h_meas_T : MeasurableSet T)\n    (h_ind : IndepSets {s | MeasurableSet[Mf] s} {T} \u03bc) (h_meas_f : Measurable[Mf] f) :\n    (\u222b\u207b \u03c9, f \u03c9 * T.indicator (fun _ => c) \u03c9 \u2202\u03bc) =\n      (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc) * \u222b\u207b \u03c9, T.indicator (fun _ => c) \u03c9 \u2202\u03bc", "start": [42, 1], "end": [73, 68], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace", "code": "theorem lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace\n    {Mf Mg m\u03a9 : MeasurableSpace \u03a9} {\u03bc : Measure \u03a9} (hMf : Mf \u2264 m\u03a9) (hMg : Mg \u2264 m\u03a9)\n    (h_ind : Indep Mf Mg \u03bc) (h_meas_f : Measurable[Mf] f) (h_meas_g : Measurable[Mg] g) :\n    \u222b\u207b \u03c9, f \u03c9 * g \u03c9 \u2202\u03bc = (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc) * \u222b\u207b \u03c9, g \u03c9 \u2202\u03bc", "start": [76, 1], "end": [104, 78], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun", "code": "theorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun (h_meas_f : Measurable f)\n    (h_meas_g : Measurable g) (h_indep_fun : IndepFun f g \u03bc) :\n    (\u222b\u207b \u03c9, (f * g) \u03c9 \u2202\u03bc) = (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc) * \u222b\u207b \u03c9, g \u03c9 \u2202\u03bc", "start": [107, 1], "end": [114, 68], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'", "code": "theorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun' (h_meas_f : AEMeasurable f \u03bc)\n    (h_meas_g : AEMeasurable g \u03bc) (h_indep_fun : IndepFun f g \u03bc) :\n    (\u222b\u207b \u03c9, (f * g) \u03c9 \u2202\u03bc) = (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc) * \u222b\u207b \u03c9, g \u03c9 \u2202\u03bc", "start": [117, 1], "end": [128, 62], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun''", "code": "theorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'' (h_meas_f : AEMeasurable f \u03bc)\n    (h_meas_g : AEMeasurable g \u03bc) (h_indep_fun : IndepFun f g \u03bc) :\n    \u222b\u207b \u03c9, f \u03c9 * g \u03c9 \u2202\u03bc = (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc) * \u222b\u207b \u03c9, g \u03c9 \u2202\u03bc", "start": [131, 1], "end": [134, 86], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integrable_mul", "code": "theorem IndepFun.integrable_mul {\u03b2 : Type*} [MeasurableSpace \u03b2] {X Y : \u03a9 \u2192 \u03b2}\n    [NormedDivisionRing \u03b2] [BorelSpace \u03b2] (hXY : IndepFun X Y \u03bc) (hX : Integrable X \u03bc)\n    (hY : Integrable Y \u03bc) : Integrable (X * Y) \u03bc", "start": [137, 1], "end": [153, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integrable_left_of_integrable_mul", "code": "theorem IndepFun.integrable_left_of_integrable_mul {\u03b2 : Type*} [MeasurableSpace \u03b2] {X Y : \u03a9 \u2192 \u03b2}\n    [NormedDivisionRing \u03b2] [BorelSpace \u03b2] (hXY : IndepFun X Y \u03bc) (h'XY : Integrable (X * Y) \u03bc)\n    (hX : AEStronglyMeasurable X \u03bc) (hY : AEStronglyMeasurable Y \u03bc) (h'Y : \u00acY =\u1d50[\u03bc] 0) :\n    Integrable X \u03bc", "start": [156, 1], "end": [175, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integrable_right_of_integrable_mul", "code": "theorem IndepFun.integrable_right_of_integrable_mul {\u03b2 : Type*} [MeasurableSpace \u03b2] {X Y : \u03a9 \u2192 \u03b2}\n    [NormedDivisionRing \u03b2] [BorelSpace \u03b2] (hXY : IndepFun X Y \u03bc) (h'XY : Integrable (X * Y) \u03bc)\n    (hX : AEStronglyMeasurable X \u03bc) (hY : AEStronglyMeasurable Y \u03bc) (h'X : \u00acX =\u1d50[\u03bc] 0) :\n    Integrable Y \u03bc", "start": [178, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integral_mul_of_nonneg", "code": "theorem IndepFun.integral_mul_of_nonneg (hXY : IndepFun X Y \u03bc) (hXp : 0 \u2264 X) (hYp : 0 \u2264 Y)\n    (hXm : AEMeasurable X \u03bc) (hYm : AEMeasurable Y \u03bc) :\n    integral \u03bc (X * Y) = integral \u03bc X * integral \u03bc Y", "start": [200, 1], "end": [218, 69], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integral_mul_of_integrable", "code": "theorem IndepFun.integral_mul_of_integrable (hXY : IndepFun X Y \u03bc) (hX : Integrable X \u03bc)\n    (hY : Integrable Y \u03bc) : integral \u03bc (X * Y) = integral \u03bc X * integral \u03bc Y", "start": [221, 1], "end": [265, 7], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integral_mul", "code": "theorem IndepFun.integral_mul (hXY : IndepFun X Y \u03bc) (hX : AEStronglyMeasurable X \u03bc)\n    (hY : AEStronglyMeasurable Y \u03bc) : integral \u03bc (X * Y) = integral \u03bc X * integral \u03bc Y", "start": [268, 1], "end": [293, 50], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.integral_mul'", "code": "theorem IndepFun.integral_mul' (hXY : IndepFun X Y \u03bc) (hX : AEStronglyMeasurable X \u03bc)\n    (hY : AEStronglyMeasurable Y \u03bc) :\n    (integral \u03bc fun \u03c9 => X \u03c9 * Y \u03c9) = integral \u03bc X * integral \u03bc Y", "start": [296, 1], "end": [299, 25], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.indepFun_iff_integral_comp_mul", "code": "theorem indepFun_iff_integral_comp_mul [IsFiniteMeasure \u03bc] {\u03b2 \u03b2' : Type*} {m\u03b2 : MeasurableSpace \u03b2}\n    {m\u03b2' : MeasurableSpace \u03b2'} {f : \u03a9 \u2192 \u03b2} {g : \u03a9 \u2192 \u03b2'} {hfm : Measurable f} {hgm : Measurable g} :\n    IndepFun f g \u03bc \u2194 \u2200 {\u03c6 : \u03b2 \u2192 \u211d} {\u03c8 : \u03b2' \u2192 \u211d}, Measurable \u03c6 \u2192 Measurable \u03c8 \u2192\n      Integrable (\u03c6 \u2218 f) \u03bc \u2192 Integrable (\u03c8 \u2218 g) \u03bc \u2192\n        integral \u03bc (\u03c6 \u2218 f * \u03c8 \u2218 g) = integral \u03bc (\u03c6 \u2218 f) * integral \u03bc (\u03c8 \u2218 g)", "start": [302, 1], "end": [320, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/MulCoeff.lean", "imports": ["Mathlib/Data/MvPolynomial/Supported.lean", "Mathlib/RingTheory/WittVector/Truncated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WittVector.wittPolyProd", "code": "def wittPolyProd (n : \u2115) : \ud835\udd44 :=\n  rename (Prod.mk (0 : Fin 2)) (wittPolynomial p \u2124 n) *\n    rename (Prod.mk (1 : Fin 2)) (wittPolynomial p \u2124 n)", "start": [50, 1], "end": [58, 56], "kind": "commanddeclaration"}, {"full_name": "WittVector.wittPolyProd_vars", "code": "theorem wittPolyProd_vars (n : \u2115) : (wittPolyProd p n).vars \u2286 univ \u00d7\u02e2 range (n + 1)", "start": [61, 1], "end": [66, 49], "kind": "commanddeclaration"}, {"full_name": "WittVector.wittPolyProdRemainder", "code": "def wittPolyProdRemainder (n : \u2115) : \ud835\udd44 :=\n  \u2211 i in range n, (p : \ud835\udd44) ^ i * wittMul p i ^ p ^ (n - i)", "start": [69, 1], "end": [71, 58], "kind": "commanddeclaration"}, {"full_name": "WittVector.wittPolyProdRemainder_vars", "code": "theorem wittPolyProdRemainder_vars (n : \u2115) :\n    (wittPolyProdRemainder p n).vars \u2286 univ \u00d7\u02e2 range n", "start": [74, 1], "end": [90, 13], "kind": "commanddeclaration"}, {"full_name": "WittVector.remainder", "code": "def remainder (n : \u2115) : \ud835\udd44 :=\n  (\u2211 x : \u2115 in range (n + 1),\n    (rename (Prod.mk 0)) ((monomial (Finsupp.single x (p ^ (n + 1 - x)))) ((p : \u2124) ^ x))) *\n   \u2211 x : \u2115 in range (n + 1),\n    (rename (Prod.mk 1)) ((monomial (Finsupp.single x (p ^ (n + 1 - x)))) ((p : \u2124) ^ x))", "start": [93, 1], "end": [101, 89], "kind": "commanddeclaration"}, {"full_name": "WittVector.remainder_vars", "code": "theorem remainder_vars (n : \u2115) : (remainder p n).vars \u2286 univ \u00d7\u02e2 range (n + 1)", "start": [104, 1], "end": [115, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.polyOfInterest", "code": "def polyOfInterest (n : \u2115) : \ud835\udd44 :=\n  wittMul p (n + 1) + (p : \ud835\udd44) ^ (n + 1) * X (0, n + 1) * X (1, n + 1) -\n    X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) -\n    X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p \u2124 (n + 1))", "start": [118, 1], "end": [122, 77], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_aux1", "code": "theorem mul_polyOfInterest_aux1 (n : \u2115) :\n    \u2211 i in range (n + 1), (p : \ud835\udd44) ^ i * wittMul p i ^ p ^ (n - i) = wittPolyProd p n", "start": [125, 1], "end": [140, 39], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_aux2", "code": "theorem mul_polyOfInterest_aux2 (n : \u2115) :\n    (p : \ud835\udd44) ^ n * wittMul p n + wittPolyProdRemainder p n = wittPolyProd p n", "start": [143, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_aux3", "code": "theorem mul_polyOfInterest_aux3 (n : \u2115) : wittPolyProd p (n + 1) =\n    -((p : \ud835\udd44) ^ (n + 1) * X (0, n + 1)) * ((p : \ud835\udd44) ^ (n + 1) * X (1, n + 1)) +\n    (p : \ud835\udd44) ^ (n + 1) * X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) +\n    (p : \ud835\udd44) ^ (n + 1) * X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) +\n    remainder p n", "start": [150, 1], "end": [181, 7], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_aux4", "code": "theorem mul_polyOfInterest_aux4 (n : \u2115) :\n    (p : \ud835\udd44) ^ (n + 1) * wittMul p (n + 1) =\n    -((p : \ud835\udd44) ^ (n + 1) * X (0, n + 1)) * ((p : \ud835\udd44) ^ (n + 1) * X (1, n + 1)) +\n    (p : \ud835\udd44) ^ (n + 1) * X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) +\n    (p : \ud835\udd44) ^ (n + 1) * X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) +\n    (remainder p n - wittPolyProdRemainder p (n + 1))", "start": [184, 1], "end": [191, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_aux5", "code": "theorem mul_polyOfInterest_aux5 (n : \u2115) :\n    (p : \ud835\udd44) ^ (n + 1) * polyOfInterest p n = remainder p n - wittPolyProdRemainder p (n + 1)", "start": [194, 1], "end": [198, 7], "kind": "commanddeclaration"}, {"full_name": "WittVector.mul_polyOfInterest_vars", "code": "theorem mul_polyOfInterest_vars (n : \u2115) :\n    ((p : \ud835\udd44) ^ (n + 1) * polyOfInterest p n).vars \u2286 univ \u00d7\u02e2 range (n + 1)", "start": [201, 1], "end": [207, 37], "kind": "commanddeclaration"}, {"full_name": "WittVector.polyOfInterest_vars_eq", "code": "theorem polyOfInterest_vars_eq (n : \u2115) : (polyOfInterest p n).vars =\n    ((p : \ud835\udd44) ^ (n + 1) * (wittMul p (n + 1) + (p : \ud835\udd44) ^ (n + 1) * X (0, n + 1) * X (1, n + 1) -\n      X (0, n + 1) * rename (Prod.mk (1 : Fin 2)) (wittPolynomial p \u2124 (n + 1)) -\n      X (1, n + 1) * rename (Prod.mk (0 : Fin 2)) (wittPolynomial p \u2124 (n + 1)))).vars", "start": [210, 1], "end": [217, 32], "kind": "commanddeclaration"}, {"full_name": "WittVector.polyOfInterest_vars", "code": "theorem polyOfInterest_vars (n : \u2115) : (polyOfInterest p n).vars \u2286 univ \u00d7\u02e2 range (n + 1)", "start": [220, 1], "end": [221, 61], "kind": "commanddeclaration"}, {"full_name": "WittVector.peval_polyOfInterest", "code": "theorem peval_polyOfInterest (n : \u2115) (x y : \ud835\udd4e k) :\n    peval (polyOfInterest p n) ![fun i => x.coeff i, fun i => y.coeff i] =\n    (x * y).coeff (n + 1) + p ^ (n + 1) * x.coeff (n + 1) * y.coeff (n + 1) -\n      y.coeff (n + 1) * \u2211 i in range (n + 1 + 1), p ^ i * x.coeff i ^ p ^ (n + 1 - i) -\n      x.coeff (n + 1) * \u2211 i in range (n + 1 + 1), p ^ i * y.coeff i ^ p ^ (n + 1 - i)", "start": [224, 1], "end": [234, 31], "kind": "commanddeclaration"}, {"full_name": "WittVector.peval_polyOfInterest'", "code": "theorem peval_polyOfInterest' (n : \u2115) (x y : \ud835\udd4e k) :\n    peval (polyOfInterest p n) ![fun i => x.coeff i, fun i => y.coeff i] =\n      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -\n        x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)", "start": [239, 1], "end": [255, 41], "kind": "commanddeclaration"}, {"full_name": "WittVector.nth_mul_coeff'", "code": "theorem nth_mul_coeff' (n : \u2115) :\n    \u2203 f : TruncatedWittVector p (n + 1) k \u2192 TruncatedWittVector p (n + 1) k \u2192 k,\n    \u2200 x y : \ud835\udd4e k, f (truncateFun (n + 1) x) (truncateFun (n + 1) y) =\n      (x * y).coeff (n + 1) - y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) -\n        x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1)", "start": [260, 1], "end": [285, 22], "kind": "commanddeclaration"}, {"full_name": "WittVector.nth_mul_coeff", "code": "theorem nth_mul_coeff (n : \u2115) :\n    \u2203 f : TruncatedWittVector p (n + 1) k \u2192 TruncatedWittVector p (n + 1) k \u2192 k,\n    \u2200 x y : \ud835\udd4e k, (x * y).coeff (n + 1) =\n      x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n      f (truncateFun (n + 1) x) (truncateFun (n + 1) y)", "start": [288, 1], "end": [297, 7], "kind": "commanddeclaration"}, {"full_name": "WittVector.nthRemainder", "code": "def nthRemainder (n : \u2115) : (Fin (n + 1) \u2192 k) \u2192 (Fin (n + 1) \u2192 k) \u2192 k :=\n  Classical.choose (nth_mul_coeff p k n)", "start": [302, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "WittVector.nthRemainder_spec", "code": "theorem nthRemainder_spec (n : \u2115) (x y : \ud835\udd4e k) : (x * y).coeff (n + 1) =\n    x.coeff (n + 1) * y.coeff 0 ^ p ^ (n + 1) + y.coeff (n + 1) * x.coeff 0 ^ p ^ (n + 1) +\n    nthRemainder p n (truncateFun (n + 1) x) (truncateFun (n + 1) y)", "start": [309, 1], "end": [312, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/Domain.lean", "imports": ["Mathlib/RingTheory/WittVector/Identities.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WittVector.shift", "code": "def shift (x : \ud835\udd4e R) (n : \u2115) : \ud835\udd4e R :=\n  @mk' p R fun i => x.coeff (n + i)", "start": [54, 1], "end": [60, 36], "kind": "commanddeclaration"}, {"full_name": "WittVector.shift_coeff", "code": "theorem shift_coeff (x : \ud835\udd4e R) (n k : \u2115) : (x.shift n).coeff k = x.coeff (n + k)", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "WittVector.verschiebung_shift", "code": "theorem verschiebung_shift (x : \ud835\udd4e R) (k : \u2115) (h : \u2200 i < k + 1, x.coeff i = 0) :\n    verschiebung (x.shift k.succ) = x.shift k", "start": [69, 1], "end": [76, 56], "kind": "commanddeclaration"}, {"full_name": "WittVector.eq_iterate_verschiebung", "code": "theorem eq_iterate_verschiebung {x : \ud835\udd4e R} {n : \u2115} (h : \u2200 i < n, x.coeff i = 0) :\n    x = verschiebung^[n] (x.shift n)", "start": [79, 1], "end": [85, 14], "kind": "commanddeclaration"}, {"full_name": "WittVector.verschiebung_nonzero", "code": "theorem verschiebung_nonzero {x : \ud835\udd4e R} (hx : x \u2260 0) :\n    \u2203 n : \u2115, \u2203 x' : \ud835\udd4e R, x'.coeff 0 \u2260 0 \u2227 x = verschiebung^[n] x'", "start": [88, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "WittVector.instIsDomain", "code": "instance instIsDomain [CharP R p] [IsDomain R] : IsDomain (\ud835\udd4e R) :=\n  NoZeroDivisors.to_isDomain _", "start": [121, 1], "end": [122, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Triangulated/TriangleShift.lean", "imports": ["Mathlib/Algebra/GroupPower/NegOnePow.lean", "Mathlib/CategoryTheory/Triangulated/Rotate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Pretriangulated.Triangle.shiftFunctor", "code": "@[simps]\nnoncomputable def Triangle.shiftFunctor (n : \u2124) : Triangle C \u2964 Triangle C where\n  obj T := Triangle.mk (n.negOnePow \u2022 T.mor\u2081\u27e6n\u27e7') (n.negOnePow \u2022 T.mor\u2082\u27e6n\u27e7')\n    (n.negOnePow \u2022 T.mor\u2083\u27e6n\u27e7' \u226b (shiftFunctorComm C 1 n).hom.app T.obj\u2081)\n  map f :=\n    { hom\u2081 := f.hom\u2081\u27e6n\u27e7'\n      hom\u2082 := f.hom\u2082\u27e6n\u27e7'\n      hom\u2083 := f.hom\u2083\u27e6n\u27e7'\n      comm\u2081 := by\n        dsimp\n        simp only [zsmul_comp, comp_zsmul, \u2190 Functor.map_comp, f.comm\u2081]\n      comm\u2082 := by\n        dsimp\n        simp only [zsmul_comp, comp_zsmul, \u2190 Functor.map_comp, f.comm\u2082]\n      comm\u2083 := by\n        dsimp\n        rw [zsmul_comp, comp_zsmul, \u2190 Functor.map_comp_assoc, \u2190 f.comm\u2083,\n          Functor.map_comp, assoc, assoc]\n        erw [(shiftFunctorComm C 1 n).hom.naturality]\n        rfl }", "start": [37, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.shiftFunctorZero", "code": "@[simps!]\nnoncomputable def Triangle.shiftFunctorZero : Triangle.shiftFunctor C 0 \u2245 \ud835\udfed _ :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ ((CategoryTheory.shiftFunctorZero C \u2124).app _)\n      ((CategoryTheory.shiftFunctorZero C \u2124).app _) ((CategoryTheory.shiftFunctorZero C \u2124).app _)\n      (by aesop_cat) (by aesop_cat) (by\n        dsimp\n        simp only [one_zsmul, assoc, shiftFunctorComm_zero_hom_app,\n          \u2190 Functor.map_comp, Iso.inv_hom_id_app, Functor.id_obj, Functor.map_id,\n          comp_id, NatTrans.naturality, Functor.id_map]))\n    (by aesop_cat)", "start": [61, 1], "end": [72, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.shiftFunctorAdd'", "code": "@[simps!]\nnoncomputable def Triangle.shiftFunctorAdd' (a b n : \u2124) (h : a + b = n) :\n    Triangle.shiftFunctor C n \u2245 Triangle.shiftFunctor C a \u22d9 Triangle.shiftFunctor C b :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _\n      ((CategoryTheory.shiftFunctorAdd' C a b n h).app _)\n      ((CategoryTheory.shiftFunctorAdd' C a b n h).app _)\n      ((CategoryTheory.shiftFunctorAdd' C a b n h).app _)\n      (by\n        subst h\n        dsimp\n        rw [zsmul_comp, NatTrans.naturality, comp_zsmul, Functor.comp_map, Functor.map_zsmul,\n          comp_zsmul, smul_smul, Int.negOnePow_add, mul_comm])\n      (by\n        subst h\n        dsimp\n        rw [zsmul_comp, NatTrans.naturality, comp_zsmul, Functor.comp_map, Functor.map_zsmul,\n          comp_zsmul, smul_smul, Int.negOnePow_add, mul_comm])\n      (by\n        subst h\n        dsimp\n        rw [zsmul_comp, comp_zsmul, Functor.map_zsmul, zsmul_comp, comp_zsmul, smul_smul,\n          assoc, Functor.map_comp, assoc]\n        erw [\u2190 NatTrans.naturality_assoc]\n        simp only [shiftFunctorAdd'_eq_shiftFunctorAdd, Int.negOnePow_add,\n          shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app, add_comm a]))\n    (by aesop_cat)", "start": [74, 1], "end": [103, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.rotateRotateRotateIso", "code": "noncomputable def rotateRotateRotateIso :\n    rotate C \u22d9 rotate C \u22d9 rotate C \u2245 Triangle.shiftFunctor C 1 :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n      (by aesop_cat) (by aesop_cat) (by aesop_cat))\n    (by aesop_cat)", "start": [105, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.invRotateInvRotateInvRotateIso", "code": "noncomputable def invRotateInvRotateInvRotateIso :\n    invRotate C \u22d9 invRotate C \u22d9 invRotate C \u2245 Triangle.shiftFunctor C (-1) :=\n  NatIso.ofComponents\n    (fun T => Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n      (by aesop_cat)\n      (by aesop_cat)\n      (by\n        dsimp [shiftFunctorCompIsoId]\n        simp [shiftFunctorComm_eq C _ _ _ (add_neg_self (1 : \u2124))]))\n    (by aesop_cat)", "start": [113, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.invRotateIsoRotateRotateShiftFunctorNegOne", "code": "noncomputable def invRotateIsoRotateRotateShiftFunctorNegOne :\n    invRotate C \u2245 rotate C \u22d9 rotate C \u22d9 Triangle.shiftFunctor C (-1) :=\n  calc\n    invRotate C \u2245 invRotate C \u22d9 \ud835\udfed _ := (Functor.rightUnitor _).symm\n    _ \u2245 invRotate C \u22d9 Triangle.shiftFunctor C 0 :=\n          isoWhiskerLeft _ (Triangle.shiftFunctorZero C).symm\n    _ \u2245 invRotate C \u22d9 Triangle.shiftFunctor C 1 \u22d9 Triangle.shiftFunctor C (-1) :=\n          isoWhiskerLeft _ (Triangle.shiftFunctorAdd' C 1 (-1) 0 (add_neg_self 1))\n    _ \u2245 invRotate C \u22d9 (rotate C \u22d9 rotate C \u22d9 rotate C) \u22d9 Triangle.shiftFunctor C (-1) :=\n          isoWhiskerLeft _ (isoWhiskerRight (rotateRotateRotateIso C).symm _)\n    _ \u2245 (invRotate C \u22d9 rotate C) \u22d9 rotate C \u22d9 rotate C \u22d9 Triangle.shiftFunctor C (-1) :=\n          isoWhiskerLeft _ (Functor.associator _ _ _ \u226a\u226b\n            isoWhiskerLeft _ (Functor.associator _ _ _)) \u226a\u226b (Functor.associator _ _ _).symm\n    _ \u2245 \ud835\udfed _ \u22d9 rotate C \u22d9 rotate C \u22d9 Triangle.shiftFunctor C (-1) :=\n          isoWhiskerRight (triangleRotation C).counitIso _\n    _ \u2245 _ := Functor.leftUnitor _", "start": [125, 1], "end": [142, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/Upcrossing.lean", "imports": ["Mathlib/Probability/Martingale/Basic.lean", "Mathlib/Data/Set/Intervals/Monotone.lean", "Mathlib/Probability/Process/HittingTime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.lowerCrossingTimeAux", "code": "noncomputable def lowerCrossingTimeAux [Preorder \u03b9] [InfSet \u03b9] (a : \u211d) (f : \u03b9 \u2192 \u03a9 \u2192 \u211d) (c N : \u03b9) :\n    \u03a9 \u2192 \u03b9 :=\n  hitting f (Set.Iic a) c N", "start": [130, 1], "end": [134, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime", "code": "noncomputable def upperCrossingTime [Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9] (a b : \u211d) (f : \u03b9 \u2192 \u03a9 \u2192 \u211d)\n    (N : \u03b9) : \u2115 \u2192 \u03a9 \u2192 \u03b9\n  | 0 => \u22a5\n  | n + 1 => fun \u03c9 =>\n    hitting f (Set.Ici b) (lowerCrossingTimeAux a f (upperCrossingTime a b f N n \u03c9) N \u03c9) N \u03c9", "start": [137, 1], "end": [143, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime", "code": "noncomputable def lowerCrossingTime [Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9] (a b : \u211d) (f : \u03b9 \u2192 \u03a9 \u2192 \u211d)\n    (N : \u03b9) (n : \u2115) : \u03a9 \u2192 \u03b9 := fun \u03c9 => hitting f (Set.Iic a) (upperCrossingTime a b f N n \u03c9) N \u03c9", "start": [146, 1], "end": [149, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_zero", "code": "@[simp]\ntheorem upperCrossingTime_zero : upperCrossingTime a b f N 0 = \u22a5", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_zero", "code": "@[simp]\ntheorem lowerCrossingTime_zero : lowerCrossingTime a b f N 0 = hitting f (Set.Iic a) \u22a5 N", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_succ", "code": "theorem upperCrossingTime_succ : upperCrossingTime a b f N (n + 1) \u03c9 =\n    hitting f (Set.Ici b) (lowerCrossingTimeAux a f (upperCrossingTime a b f N n \u03c9) N \u03c9) N \u03c9", "start": [168, 1], "end": [170, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_succ_eq", "code": "theorem upperCrossingTime_succ_eq (\u03c9 : \u03a9) : upperCrossingTime a b f N (n + 1) \u03c9 =\n    hitting f (Set.Ici b) (lowerCrossingTime a b f N n \u03c9) N \u03c9", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_le", "code": "theorem upperCrossingTime_le : upperCrossingTime a b f N n \u03c9 \u2264 N", "start": [187, 1], "end": [190, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_zero'", "code": "@[simp]\ntheorem upperCrossingTime_zero' : upperCrossingTime a b f \u22a5 n \u03c9 = \u22a5", "start": [193, 1], "end": [195, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_le", "code": "theorem lowerCrossingTime_le : lowerCrossingTime a b f N n \u03c9 \u2264 N", "start": [198, 1], "end": [199, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_le_lowerCrossingTime", "code": "theorem upperCrossingTime_le_lowerCrossingTime :\n    upperCrossingTime a b f N n \u03c9 \u2264 lowerCrossingTime a b f N n \u03c9", "start": [202, 1], "end": [204, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_le_upperCrossingTime_succ", "code": "theorem lowerCrossingTime_le_upperCrossingTime_succ :\n    lowerCrossingTime a b f N n \u03c9 \u2264 upperCrossingTime a b f N (n + 1) \u03c9", "start": [207, 1], "end": [210, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_mono", "code": "theorem lowerCrossingTime_mono (hnm : n \u2264 m) :\n    lowerCrossingTime a b f N n \u03c9 \u2264 lowerCrossingTime a b f N m \u03c9", "start": [213, 1], "end": [217, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_mono", "code": "theorem upperCrossingTime_mono (hnm : n \u2264 m) :\n    upperCrossingTime a b f N n \u03c9 \u2264 upperCrossingTime a b f N m \u03c9", "start": [220, 1], "end": [224, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stoppedValue_lowerCrossingTime", "code": "theorem stoppedValue_lowerCrossingTime (h : lowerCrossingTime a b f N n \u03c9 \u2260 N) :\n    stoppedValue f (lowerCrossingTime a b f N n) \u03c9 \u2264 a", "start": [231, 1], "end": [234, 88], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.stoppedValue_upperCrossingTime", "code": "theorem stoppedValue_upperCrossingTime (h : upperCrossingTime a b f N (n + 1) \u03c9 \u2260 N) :\n    b \u2264 stoppedValue f (upperCrossingTime a b f N (n + 1)) \u03c9", "start": [237, 1], "end": [240, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_lt_lowerCrossingTime", "code": "theorem upperCrossingTime_lt_lowerCrossingTime (hab : a < b)\n    (hn : lowerCrossingTime a b f N (n + 1) \u03c9 \u2260 N) :\n    upperCrossingTime a b f N (n + 1) \u03c9 < lowerCrossingTime a b f N (n + 1) \u03c9", "start": [243, 1], "end": [250, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_lt_upperCrossingTime", "code": "theorem lowerCrossingTime_lt_upperCrossingTime (hab : a < b)\n    (hn : upperCrossingTime a b f N (n + 1) \u03c9 \u2260 N) :\n    lowerCrossingTime a b f N n \u03c9 < upperCrossingTime a b f N (n + 1) \u03c9", "start": [253, 1], "end": [260, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_lt_succ", "code": "theorem upperCrossingTime_lt_succ (hab : a < b) (hn : upperCrossingTime a b f N (n + 1) \u03c9 \u2260 N) :\n    upperCrossingTime a b f N n \u03c9 < upperCrossingTime a b f N (n + 1) \u03c9", "start": [263, 1], "end": [266, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_stabilize", "code": "theorem lowerCrossingTime_stabilize (hnm : n \u2264 m) (hn : lowerCrossingTime a b f N n \u03c9 = N) :\n    lowerCrossingTime a b f N m \u03c9 = N", "start": [269, 1], "end": [271, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_stabilize", "code": "theorem upperCrossingTime_stabilize (hnm : n \u2264 m) (hn : upperCrossingTime a b f N n \u03c9 = N) :\n    upperCrossingTime a b f N m \u03c9 = N", "start": [274, 1], "end": [276, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_stabilize'", "code": "theorem lowerCrossingTime_stabilize' (hnm : n \u2264 m) (hn : N \u2264 lowerCrossingTime a b f N n \u03c9) :\n    lowerCrossingTime a b f N m \u03c9 = N", "start": [279, 1], "end": [281, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_stabilize'", "code": "theorem upperCrossingTime_stabilize' (hnm : n \u2264 m) (hn : N \u2264 upperCrossingTime a b f N n \u03c9) :\n    upperCrossingTime a b f N m \u03c9 = N", "start": [284, 1], "end": [286, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_upperCrossingTime_eq", "code": "theorem exists_upperCrossingTime_eq (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (N : \u2115) (\u03c9 : \u03a9) (hab : a < b) :\n    \u2203 n, upperCrossingTime a b f N n \u03c9 = N", "start": [290, 1], "end": [299, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_lt_bddAbove", "code": "theorem upperCrossingTime_lt_bddAbove (hab : a < b) :\n    BddAbove {n | upperCrossingTime a b f N n \u03c9 < N}", "start": [302, 1], "end": [307, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_lt_nonempty", "code": "theorem upperCrossingTime_lt_nonempty (hN : 0 < N) :\n    {n | upperCrossingTime a b f N n \u03c9 < N}.Nonempty", "start": [310, 1], "end": [312, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_bound_eq", "code": "theorem upperCrossingTime_bound_eq (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (N : \u2115) (\u03c9 : \u03a9) (hab : a < b) :\n    upperCrossingTime a b f N N \u03c9 = N", "start": [315, 1], "end": [326, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_eq_of_bound_le", "code": "theorem upperCrossingTime_eq_of_bound_le (hab : a < b) (hn : N \u2264 n) :\n    upperCrossingTime a b f N n \u03c9 = N", "start": [329, 1], "end": [332, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.isStoppingTime_crossing", "code": "theorem Adapted.isStoppingTime_crossing (hf : Adapted \u2131 f) :\n    IsStoppingTime \u2131 (upperCrossingTime a b f N n) \u2227\n      IsStoppingTime \u2131 (lowerCrossingTime a b f N n)", "start": [337, 1], "end": [352, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.isStoppingTime_upperCrossingTime", "code": "theorem Adapted.isStoppingTime_upperCrossingTime (hf : Adapted \u2131 f) :\n    IsStoppingTime \u2131 (upperCrossingTime a b f N n)", "start": [355, 1], "end": [357, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.isStoppingTime_lowerCrossingTime", "code": "theorem Adapted.isStoppingTime_lowerCrossingTime (hf : Adapted \u2131 f) :\n    IsStoppingTime \u2131 (lowerCrossingTime a b f N n)", "start": [360, 1], "end": [362, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingStrat", "code": "noncomputable def upcrossingStrat (a b : \u211d) (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (N n : \u2115) (\u03c9 : \u03a9) : \u211d :=\n  \u2211 k in Finset.range N,\n    (Set.Ico (lowerCrossingTime a b f N k \u03c9) (upperCrossingTime a b f N (k + 1) \u03c9)).indicator 1 n", "start": [365, 1], "end": [370, 98], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingStrat_nonneg", "code": "theorem upcrossingStrat_nonneg : 0 \u2264 upcrossingStrat a b f N n \u03c9", "start": [373, 1], "end": [374, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingStrat_le_one", "code": "theorem upcrossingStrat_le_one : upcrossingStrat a b f N n \u03c9 \u2264 1", "start": [377, 1], "end": [395, 58], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.upcrossingStrat_adapted", "code": "theorem Adapted.upcrossingStrat_adapted (hf : Adapted \u2131 f) :\n    Adapted \u2131 (upcrossingStrat a b f N)", "start": [398, 1], "end": [407, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.sum_upcrossingStrat_mul", "code": "theorem Submartingale.sum_upcrossingStrat_mul [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (a b : \u211d) (N : \u2115) : Submartingale (fun n : \u2115 =>\n      \u2211 k in Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)) \u2131 \u03bc", "start": [410, 1], "end": [414, 27], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.sum_sub_upcrossingStrat_mul", "code": "theorem Submartingale.sum_sub_upcrossingStrat_mul [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (a b : \u211d) (N : \u2115) : Submartingale (fun n : \u2115 =>\n      \u2211 k in Finset.range n, (1 - upcrossingStrat a b f N k) * (f (k + 1) - f k)) \u2131 \u03bc", "start": [417, 1], "end": [424, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.sum_mul_upcrossingStrat_le", "code": "theorem Submartingale.sum_mul_upcrossingStrat_le [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc) :\n    \u03bc[\u2211 k in Finset.range n, upcrossingStrat a b f N k * (f (k + 1) - f k)] \u2264 \u03bc[f n] - \u03bc[f 0]", "start": [427, 1], "end": [446, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore", "code": "noncomputable def upcrossingsBefore [Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9] (a b : \u211d) (f : \u03b9 \u2192 \u03a9 \u2192 \u211d)\n    (N : \u03b9) (\u03c9 : \u03a9) : \u2115 :=\n  sSup {n | upperCrossingTime a b f N n \u03c9 < N}", "start": [449, 1], "end": [452, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_bot", "code": "@[simp]\ntheorem upcrossingsBefore_bot [Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9] {a b : \u211d} {f : \u03b9 \u2192 \u03a9 \u2192 \u211d}\n    {\u03c9 : \u03a9} : upcrossingsBefore a b f \u22a5 \u03c9 = \u22a5", "start": [455, 1], "end": [457, 77], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_zero", "code": "theorem upcrossingsBefore_zero : upcrossingsBefore a b f 0 \u03c9 = 0", "start": [460, 1], "end": [460, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_zero'", "code": "@[simp]\ntheorem upcrossingsBefore_zero' : upcrossingsBefore a b f 0 = 0", "start": [463, 1], "end": [465, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_lt_of_le_upcrossingsBefore", "code": "theorem upperCrossingTime_lt_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n \u2264 upcrossingsBefore a b f N \u03c9) : upperCrossingTime a b f N n \u03c9 < N", "start": [468, 1], "end": [473, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_eq_of_upcrossingsBefore_lt", "code": "theorem upperCrossingTime_eq_of_upcrossingsBefore_lt (hab : a < b)\n    (hn : upcrossingsBefore a b f N \u03c9 < n) : upperCrossingTime a b f N n \u03c9 = N", "start": [476, 1], "end": [479, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_le", "code": "theorem upcrossingsBefore_le (f : \u2115 \u2192 \u03a9 \u2192 \u211d) (\u03c9 : \u03a9) (hab : a < b) :\n    upcrossingsBefore a b f N \u03c9 \u2264 N", "start": [482, 1], "end": [489, 73], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.crossing_eq_crossing_of_lowerCrossingTime_lt", "code": "theorem crossing_eq_crossing_of_lowerCrossingTime_lt {M : \u2115} (hNM : N \u2264 M)\n    (h : lowerCrossingTime a b f N n \u03c9 < N) :\n    upperCrossingTime a b f M n \u03c9 = upperCrossingTime a b f N n \u03c9 \u2227\n      lowerCrossingTime a b f M n \u03c9 = lowerCrossingTime a b f N n \u03c9", "start": [492, 1], "end": [518, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.crossing_eq_crossing_of_upperCrossingTime_lt", "code": "theorem crossing_eq_crossing_of_upperCrossingTime_lt {M : \u2115} (hNM : N \u2264 M)\n    (h : upperCrossingTime a b f N (n + 1) \u03c9 < N) :\n    upperCrossingTime a b f M (n + 1) \u03c9 = upperCrossingTime a b f N (n + 1) \u03c9 \u2227\n      lowerCrossingTime a b f M n \u03c9 = lowerCrossingTime a b f N n \u03c9", "start": [521, 1], "end": [532, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upperCrossingTime_eq_upperCrossingTime_of_lt", "code": "theorem upperCrossingTime_eq_upperCrossingTime_of_lt {M : \u2115} (hNM : N \u2264 M)\n    (h : upperCrossingTime a b f N n \u03c9 < N) :\n    upperCrossingTime a b f M n \u03c9 = upperCrossingTime a b f N n \u03c9", "start": [535, 1], "end": [540, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_mono", "code": "theorem upcrossingsBefore_mono (hab : a < b) : Monotone fun N \u03c9 => upcrossingsBefore a b f N \u03c9", "start": [543, 1], "end": [551, 53], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_lt_of_exists_upcrossing", "code": "theorem upcrossingsBefore_lt_of_exists_upcrossing (hab : a < b) {N\u2081 N\u2082 : \u2115} (hN\u2081 : N \u2264 N\u2081)\n    (hN\u2081' : f N\u2081 \u03c9 < a) (hN\u2082 : N\u2081 \u2264 N\u2082) (hN\u2082' : b < f N\u2082 \u03c9) :\n    upcrossingsBefore a b f N \u03c9 < upcrossingsBefore a b f (N\u2082 + 1) \u03c9", "start": [554, 1], "end": [570, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.lowerCrossingTime_lt_of_lt_upcrossingsBefore", "code": "theorem lowerCrossingTime_lt_of_lt_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N \u03c9) : lowerCrossingTime a b f N n \u03c9 < N", "start": [573, 1], "end": [576, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.le_sub_of_le_upcrossingsBefore", "code": "theorem le_sub_of_le_upcrossingsBefore (hN : 0 < N) (hab : a < b)\n    (hn : n < upcrossingsBefore a b f N \u03c9) :\n    b - a \u2264 stoppedValue f (upperCrossingTime a b f N (n + 1)) \u03c9 -\n      stoppedValue f (lowerCrossingTime a b f N n) \u03c9", "start": [579, 1], "end": [585, 97], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.sub_eq_zero_of_upcrossingsBefore_lt", "code": "theorem sub_eq_zero_of_upcrossingsBefore_lt (hab : a < b) (hn : upcrossingsBefore a b f N \u03c9 < n) :\n    stoppedValue f (upperCrossingTime a b f N (n + 1)) \u03c9 -\n      stoppedValue f (lowerCrossingTime a b f N n) \u03c9 = 0", "start": [588, 1], "end": [596, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_upcrossingsBefore_le", "code": "theorem mul_upcrossingsBefore_le (hf : a \u2264 f N \u03c9) (hab : a < b) :\n    (b - a) * upcrossingsBefore a b f N \u03c9 \u2264\n    \u2211 k in Finset.range N, upcrossingStrat a b f N k \u03c9 * (f (k + 1) - f k) \u03c9", "start": [599, 1], "end": [652, 67], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integral_mul_upcrossingsBefore_le_integral", "code": "theorem integral_mul_upcrossingsBefore_le_integral [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hfN : \u2200 \u03c9, a \u2264 f N \u03c9) (hfzero : 0 \u2264 f 0) (hab : a < b) :\n    (b - a) * \u03bc[upcrossingsBefore a b f N] \u2264 \u03bc[f N]", "start": [655, 1], "end": [667, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.crossing_pos_eq", "code": "theorem crossing_pos_eq (hab : a < b) :\n    upperCrossingTime 0 (b - a) (fun n \u03c9 => (f n \u03c9 - a)\u207a) N n = upperCrossingTime a b f N n \u2227\n      lowerCrossingTime 0 (b - a) (fun n \u03c9 => (f n \u03c9 - a)\u207a) N n = lowerCrossingTime a b f N n", "start": [670, 1], "end": [715, 10], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_pos_eq", "code": "theorem upcrossingsBefore_pos_eq (hab : a < b) :\n    upcrossingsBefore 0 (b - a) (fun n \u03c9 => (f n \u03c9 - a)\u207a) N \u03c9 = upcrossingsBefore a b f N \u03c9", "start": [718, 1], "end": [720, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.mul_integral_upcrossingsBefore_le_integral_pos_part_aux", "code": "theorem mul_integral_upcrossingsBefore_le_integral_pos_part_aux [IsFiniteMeasure \u03bc]\n    (hf : Submartingale f \u2131 \u03bc) (hab : a < b) :\n    (b - a) * \u03bc[upcrossingsBefore a b f N] \u2264 \u03bc[fun \u03c9 => (f N \u03c9 - a)\u207a]", "start": [723, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part", "code": "theorem Submartingale.mul_integral_upcrossingsBefore_le_integral_pos_part [IsFiniteMeasure \u03bc]\n    (a b : \u211d) (hf : Submartingale f \u2131 \u03bc) (N : \u2115) :\n    (b - a) * \u03bc[upcrossingsBefore a b f N] \u2264 \u03bc[fun \u03c9 => (f N \u03c9 - a)\u207a]", "start": [734, 1], "end": [745, 66], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossingsBefore_eq_sum", "code": "theorem upcrossingsBefore_eq_sum (hab : a < b) : upcrossingsBefore a b f N \u03c9 =\n    \u2211 i in Finset.Ico 1 (N + 1), {n | upperCrossingTime a b f N n \u03c9 < N}.indicator 1 i", "start": [774, 1], "end": [797, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.measurable_upcrossingsBefore", "code": "theorem Adapted.measurable_upcrossingsBefore (hf : Adapted \u2131 f) (hab : a < b) :\n    Measurable (upcrossingsBefore a b f N)", "start": [800, 1], "end": [808, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.integrable_upcrossingsBefore", "code": "theorem Adapted.integrable_upcrossingsBefore [IsFiniteMeasure \u03bc] (hf : Adapted \u2131 f) (hab : a < b) :\n    Integrable (fun \u03c9 => (upcrossingsBefore a b f N \u03c9 : \u211d)) \u03bc", "start": [811, 1], "end": [818, 39], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossings", "code": "noncomputable def upcrossings [Preorder \u03b9] [OrderBot \u03b9] [InfSet \u03b9] (a b : \u211d) (f : \u03b9 \u2192 \u03a9 \u2192 \u211d)\n    (\u03c9 : \u03a9) : \u211d\u22650\u221e :=\n  \u2a06 N, (upcrossingsBefore a b f N \u03c9 : \u211d\u22650\u221e)", "start": [821, 1], "end": [825, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Adapted.measurable_upcrossings", "code": "theorem Adapted.measurable_upcrossings (hf : Adapted \u2131 f) (hab : a < b) :\n    Measurable (upcrossings a b f)", "start": [828, 1], "end": [830, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossings_lt_top_iff", "code": "theorem upcrossings_lt_top_iff :\n    upcrossings a b f \u03c9 < \u221e \u2194 \u2203 k, \u2200 N, upcrossingsBefore a b f N \u03c9 \u2264 k", "start": [833, 1], "end": [848, 51], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part", "code": "theorem Submartingale.mul_lintegral_upcrossings_le_lintegral_pos_part [IsFiniteMeasure \u03bc] (a b : \u211d)\n    (hf : Submartingale f \u2131 \u03bc) : ENNReal.ofReal (b - a) * \u222b\u207b \u03c9, upcrossings a b f \u03c9 \u2202\u03bc \u2264\n      \u2a06 N, \u222b\u207b \u03c9, ENNReal.ofReal ((f N \u03c9 - a)\u207a) \u2202\u03bc", "start": [851, 1], "end": [880, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Multilinear/TensorProduct.lean", "imports": ["Mathlib/LinearAlgebra/TensorProduct.lean", "Mathlib/LinearAlgebra/Multilinear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MultilinearMap.domCoprod", "code": "@[simps apply]\ndef domCoprod (a : MultilinearMap R (fun _ : \u03b9\u2081 => N) N\u2081)\n    (b : MultilinearMap R (fun _ : \u03b9\u2082 => N) N\u2082) :\n    MultilinearMap R (fun _ : Sum \u03b9\u2081 \u03b9\u2082 => N) (N\u2081 \u2297[R] N\u2082) where\n  toFun v := (a fun i => v (Sum.inl i)) \u2297\u209c b fun i => v (Sum.inr i)\n  map_add' _ i p q := by\n    letI := (@Sum.inl_injective \u03b9\u2081 \u03b9\u2082).decidableEq\n    letI := (@Sum.inr_injective \u03b9\u2081 \u03b9\u2082).decidableEq\n    cases i <;> simp [TensorProduct.add_tmul, TensorProduct.tmul_add]\n  map_smul' _ i c p := by\n    letI := (@Sum.inl_injective \u03b9\u2081 \u03b9\u2082).decidableEq\n    letI := (@Sum.inr_injective \u03b9\u2081 \u03b9\u2082).decidableEq\n    cases i <;> simp [TensorProduct.smul_tmul', TensorProduct.tmul_smul]", "start": [33, 1], "end": [58, 73], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod'", "code": "def domCoprod' :\n    MultilinearMap R (fun _ : \u03b9\u2081 => N) N\u2081 \u2297[R] MultilinearMap R (fun _ : \u03b9\u2082 => N) N\u2082 \u2192\u2097[R]\n      MultilinearMap R (fun _ : Sum \u03b9\u2081 \u03b9\u2082 => N) (N\u2081 \u2297[R] N\u2082) :=\n  TensorProduct.lift <|\n    LinearMap.mk\u2082 R domCoprod\n      (fun m\u2081 m\u2082 n => by\n        ext\n        simp only [domCoprod_apply, TensorProduct.add_tmul, add_apply])\n      (fun c m n => by\n        ext\n        simp only [domCoprod_apply, TensorProduct.smul_tmul', smul_apply])\n      (fun m n\u2081 n\u2082 => by\n        ext\n        simp only [domCoprod_apply, TensorProduct.tmul_add, add_apply])\n      fun c m n => by\n      ext\n      simp only [domCoprod_apply, TensorProduct.tmul_smul, smul_apply]", "start": [61, 1], "end": [79, 71], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod'_apply", "code": "@[simp]\ntheorem domCoprod'_apply (a : MultilinearMap R (fun _ : \u03b9\u2081 => N) N\u2081)\n    (b : MultilinearMap R (fun _ : \u03b9\u2082 => N) N\u2082) : domCoprod' (a \u2297\u209c[R] b) = domCoprod a b", "start": [82, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "MultilinearMap.domCoprod_domDomCongr_sumCongr", "code": "theorem domCoprod_domDomCongr_sumCongr (a : MultilinearMap R (fun _ : \u03b9\u2081 => N) N\u2081)\n    (b : MultilinearMap R (fun _ : \u03b9\u2082 => N) N\u2082) (\u03c3a : \u03b9\u2081 \u2243 \u03b9\u2083) (\u03c3b : \u03b9\u2082 \u2243 \u03b9\u2084) :\n    (a.domCoprod b).domDomCongr (\u03c3a.sumCongr \u03c3b) =\n      (a.domDomCongr \u03c3a).domCoprod (b.domDomCongr \u03c3b)", "start": [88, 1], "end": [94, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/Subquiver.lean", "imports": ["Mathlib/Combinatorics/Quiver/Basic.lean", "Mathlib/Order/BoundedOrder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WideSubquiver", "code": "def WideSubquiver (V) [Quiver.{v + 1} V] :=\n  \u2200 a b : V, Set (a \u27f6 b)", "start": [21, 1], "end": [26, 25], "kind": "commanddeclaration"}, {"full_name": "WideSubquiver.toType", "code": "@[nolint unusedArguments]\ndef WideSubquiver.toType (V) [Quiver V] (_ : WideSubquiver V) : Type u :=\n  V", "start": [29, 1], "end": [34, 4], "kind": "commanddeclaration"}, {"full_name": "wideSubquiverHasCoeToSort", "code": "instance wideSubquiverHasCoeToSort {V} [Quiver V] :\n    CoeSort (WideSubquiver V) (Type u) where coe H := WideSubquiver.toType V H", "start": [37, 1], "end": [38, 79], "kind": "commanddeclaration"}, {"full_name": "WideSubquiver.quiver", "code": "instance WideSubquiver.quiver {V} [Quiver V] (H : WideSubquiver V) : Quiver H :=\n  \u27e8fun a b \u21a6 { f // f \u2208 H a b }\u27e9", "start": [40, 1], "end": [42, 33], "kind": "commanddeclaration"}, {"full_name": "Quiver.Total", "code": "@[ext]\nstructure Total (V : Type u) [Quiver.{v} V] : Sort max (u + 1) v where\n  \n  left : V\n  \n  right : V\n  \n  hom : left \u27f6 right", "start": [56, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Quiver.wideSubquiverEquivSetTotal", "code": "def wideSubquiverEquivSetTotal {V} [Quiver V] :\n    WideSubquiver V \u2243\n      Set (Total V) where\n  toFun H := { e | e.hom \u2208 H e.left e.right }\n  invFun S a b := { e | Total.mk a b e \u2208 S }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [70, 1], "end": [77, 21], "kind": "commanddeclaration"}, {"full_name": "Quiver.Labelling", "code": "def Labelling (V : Type u) [Quiver V] (L : Sort*) :=\n  \u2200 \u2983a b : V\u2984, (a \u27f6 b) \u2192 L", "start": [80, 1], "end": [82, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Pullbacks.lean", "imports": ["Mathlib/AlgebraicGeometry/AffineScheme.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/AlgebraicGeometry/Gluing.lean", "Mathlib/CategoryTheory/Limits/Opposites.lean", "Mathlib/CategoryTheory/Limits/Shapes/Diagonal.lean"], "premises": [{"full_name": "AlgebraicGeometry.Scheme.Pullback.v", "code": "def v (i j : \ud835\udcb0.J) : Scheme :=\n  pullback ((pullback.fst : pullback (\ud835\udcb0.map i \u226b f) g \u27f6 _) \u226b \ud835\udcb0.map i) (\ud835\udcb0.map j)", "start": [46, 1], "end": [48, 79], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t", "code": "def t (i j : \ud835\udcb0.J) : v \ud835\udcb0 f g i j \u27f6 v \ud835\udcb0 f g j i := by\n  haveI : HasPullback (pullback.snd \u226b \ud835\udcb0.map i \u226b f) g :=\n    hasPullback_assoc_symm (\ud835\udcb0.map j) (\ud835\udcb0.map i) (\ud835\udcb0.map i \u226b f) g\n  haveI : HasPullback (pullback.snd \u226b \ud835\udcb0.map j \u226b f) g :=\n    hasPullback_assoc_symm (\ud835\udcb0.map i) (\ud835\udcb0.map j) (\ud835\udcb0.map j \u226b f) g\n  refine' (pullbackSymmetry _ _).hom \u226b _\n  refine' (pullbackAssoc _ _ _ _).inv \u226b _\n  change pullback _ _ \u27f6 pullback _ _\n  refine' _ \u226b (pullbackSymmetry _ _).hom\n  refine' _ \u226b (pullbackAssoc _ _ _ _).hom\n  refine' pullback.map _ _ _ _ (pullbackSymmetry _ _).hom (\ud835\udfd9 _) (\ud835\udfd9 _) _ _\n  rw [pullbackSymmetry_hom_comp_snd_assoc, pullback.condition_assoc, Category.comp_id]\n  rw [Category.comp_id, Category.id_comp]", "start": [51, 1], "end": [65, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t_fst_fst", "code": "@[simp, reassoc]\ntheorem t_fst_fst (i j : \ud835\udcb0.J) : t \ud835\udcb0 f g i j \u226b pullback.fst \u226b pullback.fst = pullback.snd", "start": [68, 1], "end": [78, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t_fst_snd", "code": "@[simp, reassoc]\ntheorem t_fst_snd (i j : \ud835\udcb0.J) :\n    t \ud835\udcb0 f g i j \u226b pullback.fst \u226b pullback.snd = pullback.fst \u226b pullback.snd", "start": [81, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t_snd", "code": "@[simp, reassoc]\ntheorem t_snd (i j : \ud835\udcb0.J) : t \ud835\udcb0 f g i j \u226b pullback.snd = pullback.fst \u226b pullback.fst", "start": [95, 1], "end": [105, 62], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t_id", "code": "theorem t_id (i : \ud835\udcb0.J) : t \ud835\udcb0 f g i i = \ud835\udfd9 _", "start": [108, 1], "end": [113, 88], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.fV", "code": "abbrev fV (i j : \ud835\udcb0.J) : v \ud835\udcb0 f g i j \u27f6 pullback (\ud835\udcb0.map i \u226b f) g :=\n  pullback.fst", "start": [116, 1], "end": [118, 15], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'", "code": "def t' (i j k : \ud835\udcb0.J) :\n    pullback (fV \ud835\udcb0 f g i j) (fV \ud835\udcb0 f g i k) \u27f6 pullback (fV \ud835\udcb0 f g j k) (fV \ud835\udcb0 f g j i) := by\n  refine' (pullbackRightPullbackFstIso _ _ _).hom \u226b _\n  refine' _ \u226b (pullbackSymmetry _ _).hom\n  refine' _ \u226b (pullbackRightPullbackFstIso _ _ _).inv\n  refine' pullback.map _ _ _ _ (t \ud835\udcb0 f g i j) (\ud835\udfd9 _) (\ud835\udfd9 _) _ _\n  \u00b7 simp only [\u2190 pullback.condition, Category.comp_id, t_fst_fst_assoc]\n  \u00b7 simp only [Category.comp_id, Category.id_comp]", "start": [121, 1], "end": [130, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_fst", "code": "@[simp, reassoc]\ntheorem t'_fst_fst_fst (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.fst \u226b pullback.fst \u226b pullback.fst = pullback.fst \u226b pullback.snd", "start": [133, 1], "end": [139, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_fst_fst_snd", "code": "@[simp, reassoc]\ntheorem t'_fst_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.fst \u226b pullback.fst \u226b pullback.snd =\n      pullback.fst \u226b pullback.fst \u226b pullback.snd", "start": [142, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_fst_snd", "code": "@[simp, reassoc]\ntheorem t'_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.fst \u226b pullback.snd = pullback.snd \u226b pullback.snd", "start": [152, 1], "end": [158, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_fst", "code": "@[simp, reassoc]\ntheorem t'_snd_fst_fst (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.snd \u226b pullback.fst \u226b pullback.fst = pullback.fst \u226b pullback.snd", "start": [161, 1], "end": [167, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_snd_fst_snd", "code": "@[simp, reassoc]\ntheorem t'_snd_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.snd \u226b pullback.fst \u226b pullback.snd =\n      pullback.fst \u226b pullback.fst \u226b pullback.snd", "start": [170, 1], "end": [177, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.t'_snd_snd", "code": "@[simp, reassoc]\ntheorem t'_snd_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b pullback.snd \u226b pullback.snd = pullback.fst \u226b pullback.fst \u226b pullback.fst", "start": [180, 1], "end": [186, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_fst", "code": "theorem cocycle_fst_fst_fst (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.fst \u226b pullback.fst \u226b pullback.fst =\n      pullback.fst \u226b pullback.fst \u226b pullback.fst", "start": [189, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_fst_fst_snd", "code": "theorem cocycle_fst_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.fst \u226b pullback.fst \u226b pullback.snd =\n      pullback.fst \u226b pullback.fst \u226b pullback.snd", "start": [195, 1], "end": [198, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_fst_snd", "code": "theorem cocycle_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.fst \u226b pullback.snd =\n      pullback.fst \u226b pullback.snd", "start": [201, 1], "end": [204, 56], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_fst", "code": "theorem cocycle_snd_fst_fst (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.snd \u226b pullback.fst \u226b pullback.fst =\n      pullback.snd \u226b pullback.fst \u226b pullback.fst", "start": [207, 1], "end": [211, 79], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_snd_fst_snd", "code": "theorem cocycle_snd_fst_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.snd \u226b pullback.fst \u226b pullback.snd =\n      pullback.snd \u226b pullback.fst \u226b pullback.snd", "start": [214, 1], "end": [217, 58], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle_snd_snd", "code": "theorem cocycle_snd_snd (i j k : \ud835\udcb0.J) :\n    t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j \u226b pullback.snd \u226b pullback.snd =\n      pullback.snd \u226b pullback.snd", "start": [220, 1], "end": [223, 56], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.cocycle", "code": "theorem cocycle (i j k : \ud835\udcb0.J) : t' \ud835\udcb0 f g i j k \u226b t' \ud835\udcb0 f g j k i \u226b t' \ud835\udcb0 f g k i j = \ud835\udfd9 _", "start": [227, 1], "end": [244, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluing", "code": "@[simps]\ndef gluing : Scheme.GlueData.{u} where\n  J := \ud835\udcb0.J\n  U i := pullback (\ud835\udcb0.map i \u226b f) g\n  V := fun \u27e8i, j\u27e9 => v \ud835\udcb0 f g i j\n  f i j := pullback.fst\n  f_id i := inferInstance\n  f_open := inferInstance\n  t i j := t \ud835\udcb0 f g i j\n  t_id i := t_id \ud835\udcb0 f g i\n  t' i j k := t' \ud835\udcb0 f g i j k\n  t_fac i j k := by\n    apply pullback.hom_ext\n    apply pullback.hom_ext\n    all_goals\n      simp only [t'_snd_fst_fst, t'_snd_fst_snd, t'_snd_snd, t_fst_fst, t_fst_snd, t_snd,\n        Category.assoc]\n  cocycle i j k := cocycle \ud835\udcb0 f g i j k", "start": [247, 1], "end": [266, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.p1", "code": "def p1 : (gluing \ud835\udcb0 f g).glued \u27f6 X := by\n  fapply Multicoequalizer.desc\n  exact fun i => pullback.fst \u226b \ud835\udcb0.map i\n  rintro \u27e8i, j\u27e9\n  change pullback.fst \u226b _ \u226b \ud835\udcb0.map i = (_ \u226b _) \u226b _ \u226b \ud835\udcb0.map j\n  erw [pullback.condition]\n  rw [\u2190 Category.assoc]\n  congr 1\n  rw [Category.assoc]\n  exact (t_fst_fst _ _ _ _ _).symm", "start": [269, 1], "end": [280, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.p2", "code": "def p2 : (gluing \ud835\udcb0 f g).glued \u27f6 Y := by\n  fapply Multicoequalizer.desc\n  exact fun i => pullback.snd\n  rintro \u27e8i, j\u27e9\n  change pullback.fst \u226b _ = (_ \u226b _) \u226b _\n  rw [Category.assoc]\n  exact (t_fst_snd _ _ _ _ _).symm", "start": [283, 1], "end": [290, 35], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.p_comm", "code": "theorem p_comm : p1 \ud835\udcb0 f g \u226b f = p2 \ud835\udcb0 f g \u226b g", "start": [293, 1], "end": [297, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap", "code": "def gluedLiftPullbackMap (i j : \ud835\udcb0.J) :\n    pullback ((\ud835\udcb0.pullbackCover s.fst).map i) ((\ud835\udcb0.pullbackCover s.fst).map j) \u27f6\n      (gluing \ud835\udcb0 f g).V \u27e8i, j\u27e9 := by\n  change pullback pullback.fst pullback.fst \u27f6 pullback _ _\n  refine' (pullbackRightPullbackFstIso _ _ _).hom \u226b _\n  refine' pullback.map _ _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) _ _\n  \u00b7 exact (pullbackSymmetry _ _).hom \u226b\n      pullback.map _ _ _ _ (\ud835\udfd9 _) s.snd f (Category.id_comp _).symm s.condition\n  \u00b7 simpa using pullback.condition\n  \u00b7 simp only [Category.comp_id, Category.id_comp]", "start": [302, 1], "end": [315, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_fst", "code": "@[reassoc]\ntheorem gluedLiftPullbackMap_fst (i j : \ud835\udcb0.J) :\n    gluedLiftPullbackMap \ud835\udcb0 f g s i j \u226b pullback.fst =\n      pullback.fst \u226b\n        (pullbackSymmetry _ _).hom \u226b\n          pullback.map _ _ _ _ (\ud835\udfd9 _) s.snd f (Category.id_comp _).symm s.condition", "start": [318, 1], "end": [327, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLiftPullbackMap_snd", "code": "@[reassoc]\ntheorem gluedLiftPullbackMap_snd (i j : \ud835\udcb0.J) :\n    gluedLiftPullbackMap \ud835\udcb0 f g s i j \u226b pullback.snd = pullback.snd \u226b pullback.snd", "start": [330, 1], "end": [336, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLift", "code": "def gluedLift : s.pt \u27f6 (gluing \ud835\udcb0 f g).glued := by\n  fapply (\ud835\udcb0.pullbackCover s.fst).glueMorphisms\n  \u00b7 exact fun i => (pullbackSymmetry _ _).hom \u226b\n      pullback.map _ _ _ _ (\ud835\udfd9 _) s.snd f (Category.id_comp _).symm s.condition \u226b\n        (gluing \ud835\udcb0 f g).\u03b9 i\n  intro i j\n  rw [\u2190 gluedLiftPullbackMap_fst_assoc]\n  have : _ = pullback.fst \u226b _ := (gluing \ud835\udcb0 f g).glue_condition i j\n  rw [\u2190 this, gluing_t, gluing_f]\n  simp_rw [\u2190 Category.assoc]\n  congr 1\n  apply pullback.hom_ext <;> simp_rw [Category.assoc]\n  \u00b7 rw [t_fst_fst, gluedLiftPullbackMap_snd]\n    congr 1\n    rw [\u2190 Iso.inv_comp_eq, pullbackSymmetry_inv_comp_snd]\n    erw [pullback.lift_fst]\n    rw [Category.comp_id]\n  \u00b7 rw [t_fst_snd, gluedLiftPullbackMap_fst_assoc]\n    erw [pullback.lift_snd, pullback.lift_snd]\n    rw [pullbackSymmetry_hom_comp_snd_assoc, pullbackSymmetry_hom_comp_snd_assoc]\n    exact pullback.condition_assoc _", "start": [339, 1], "end": [369, 37], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLift_p1", "code": "theorem gluedLift_p1 : gluedLift \ud835\udcb0 f g s \u226b p1 \ud835\udcb0 f g = s.fst", "start": [372, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedLift_p2", "code": "theorem gluedLift_p2 : gluedLift \ud835\udcb0 f g s \u226b p2 \ud835\udcb0 f g = s.snd", "start": [387, 1], "end": [398, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackFst\u03b9ToV", "code": "def pullbackFst\u03b9ToV (i j : \ud835\udcb0.J) :\n    pullback (pullback.fst : pullback (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) \u27f6 _) ((gluing \ud835\udcb0 f g).\u03b9 j) \u27f6\n      v \ud835\udcb0 f g j i :=\n  (pullbackSymmetry _ _ \u226a\u226b pullbackRightPullbackFstIso (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) _).hom \u226b\n    (pullback.congrHom (Multicoequalizer.\u03c0_desc _ _ _ _ _) rfl).hom", "start": [401, 1], "end": [410, 68], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackFst\u03b9ToV_fst", "code": "@[simp, reassoc]\ntheorem pullbackFst\u03b9ToV_fst (i j : \ud835\udcb0.J) :\n    pullbackFst\u03b9ToV \ud835\udcb0 f g i j \u226b pullback.fst = pullback.snd", "start": [413, 1], "end": [422, 37], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackFst\u03b9ToV_snd", "code": "@[simp, reassoc]\ntheorem pullbackFst\u03b9ToV_snd (i j : \ud835\udcb0.J) :\n    pullbackFst\u03b9ToV \ud835\udcb0 f g i j \u226b pullback.snd = pullback.fst \u226b pullback.snd", "start": [425, 1], "end": [434, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.lift_comp_\u03b9", "code": "theorem lift_comp_\u03b9 (i : \ud835\udcb0.J) :\n    pullback.lift pullback.snd (pullback.fst \u226b p2 \ud835\udcb0 f g)\n          (by rw [\u2190 pullback.condition_assoc, Category.assoc, p_comm]) \u226b\n        (gluing \ud835\udcb0 f g).\u03b9 i =\n      (pullback.fst : pullback (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) \u27f6 _)", "start": [437, 1], "end": [466, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso", "code": "def pullbackP1Iso (i : \ud835\udcb0.J) : pullback (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) \u2245 pullback (\ud835\udcb0.map i \u226b f) g := by\n  fconstructor\n  exact\n    pullback.lift pullback.snd (pullback.fst \u226b p2 \ud835\udcb0 f g)\n      (by rw [\u2190 pullback.condition_assoc, Category.assoc, p_comm])\n  refine' pullback.lift ((gluing \ud835\udcb0 f g).\u03b9 i) pullback.fst (by erw [Multicoequalizer.\u03c0_desc])\n  \u00b7 apply pullback.hom_ext\n    \u00b7 simpa using lift_comp_\u03b9 \ud835\udcb0 f g i\n    \u00b7 simp only [Category.assoc, pullback.lift_snd, pullback.lift_fst, Category.id_comp]\n  \u00b7 apply pullback.hom_ext\n    \u00b7 simp only [Category.assoc, pullback.lift_fst, pullback.lift_snd, Category.id_comp]\n    \u00b7 simp only [Category.assoc, pullback.lift_snd, pullback.lift_fst_assoc, Category.id_comp]\n      erw [Multicoequalizer.\u03c0_desc]", "start": [469, 1], "end": [483, 36], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_fst", "code": "@[simp, reassoc]\ntheorem pullbackP1Iso_hom_fst (i : \ud835\udcb0.J) :\n    (pullbackP1Iso \ud835\udcb0 f g i).hom \u226b pullback.fst = pullback.snd", "start": [486, 1], "end": [490, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_snd", "code": "@[simp, reassoc]\ntheorem pullbackP1Iso_hom_snd (i : \ud835\udcb0.J) :\n    (pullbackP1Iso \ud835\udcb0 f g i).hom \u226b pullback.snd = pullback.fst \u226b p2 \ud835\udcb0 f g", "start": [493, 1], "end": [496, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_fst", "code": "@[simp, reassoc]\ntheorem pullbackP1Iso_inv_fst (i : \ud835\udcb0.J) :\n    (pullbackP1Iso \ud835\udcb0 f g i).inv \u226b pullback.fst = (gluing \ud835\udcb0 f g).\u03b9 i", "start": [499, 1], "end": [502, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_inv_snd", "code": "@[simp, reassoc]\ntheorem pullbackP1Iso_inv_snd (i : \ud835\udcb0.J) :\n    (pullbackP1Iso \ud835\udcb0 f g i).inv \u226b pullback.snd = pullback.fst", "start": [505, 1], "end": [508, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.pullbackP1Iso_hom_\u03b9", "code": "@[simp, reassoc]\ntheorem pullbackP1Iso_hom_\u03b9 (i : \ud835\udcb0.J) :\n    (pullbackP1Iso \ud835\udcb0 f g i).hom \u226b (gluing \ud835\udcb0 f g).\u03b9 i = pullback.fst", "start": [511, 1], "end": [514, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.gluedIsLimit", "code": "def gluedIsLimit : IsLimit (PullbackCone.mk _ _ (p_comm \ud835\udcb0 f g)) := by\n  apply PullbackCone.isLimitAux'\n  intro s\n  refine' \u27e8gluedLift \ud835\udcb0 f g s, gluedLift_p1 \ud835\udcb0 f g s, gluedLift_p2 \ud835\udcb0 f g s, _\u27e9\n  intro m h\u2081 h\u2082\n  change m \u226b p1 \ud835\udcb0 f g = _ at h\u2081\n  change m \u226b p2 \ud835\udcb0 f g = _ at h\u2082\n  apply (\ud835\udcb0.pullbackCover s.fst).hom_ext\n  intro i\n  rw [OpenCover.pullbackCover_map]\n  have := pullbackRightPullbackFstIso (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) m \u226a\u226b pullback.congrHom h\u2081 rfl\n  erw [(\ud835\udcb0.pullbackCover s.fst).\u03b9_glueMorphisms]\n  rw [\u2190\n    cancel_epi\n      (pullbackRightPullbackFstIso (p1 \ud835\udcb0 f g) (\ud835\udcb0.map i) m \u226a\u226b pullback.congrHom h\u2081 rfl).hom,\n    Iso.trans_hom, Category.assoc, pullback.congrHom_hom, pullback.lift_fst_assoc,\n    Category.comp_id, pullbackRightPullbackFstIso_hom_fst_assoc, pullback.condition]\n  trans pullback.snd \u226b (pullbackP1Iso \ud835\udcb0 f g _).hom \u226b (gluing \ud835\udcb0 f g).\u03b9 _\n  \u00b7 congr 1; rw [\u2190 pullbackP1Iso_hom_\u03b9]\n  simp_rw [\u2190 Category.assoc]\n  congr 1\n  apply pullback.hom_ext\n  \u00b7 simp only [Category.comp_id, pullbackRightPullbackFstIso_hom_snd, Category.assoc,\n      pullbackP1Iso_hom_fst, pullback.lift_snd, pullback.lift_fst, pullbackSymmetry_hom_comp_fst]\n  \u00b7 simp only [Category.comp_id, pullbackRightPullbackFstIso_hom_fst_assoc,\n      pullbackP1Iso_hom_snd, Category.assoc, pullback.lift_fst_assoc,\n      pullbackSymmetry_hom_comp_snd_assoc, pullback.lift_snd]\n    rw [\u2190 pullback.condition_assoc, h\u2082]", "start": [517, 1], "end": [545, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.hasPullback_of_cover", "code": "theorem hasPullback_of_cover : HasPullback f g", "start": [548, 1], "end": [549, 30], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.affine_hasPullback", "code": "instance affine_hasPullback {A B C : CommRingCat}\n    (f : Spec.obj (Opposite.op A) \u27f6 Spec.obj (Opposite.op C))\n    (g : Spec.obj (Opposite.op B) \u27f6 Spec.obj (Opposite.op C)) : HasPullback f g := by\n  rw [\u2190 Spec.image_preimage f, \u2190 Spec.image_preimage g]\n  exact\n    \u27e8\u27e8\u27e8_, isLimitOfHasPullbackOfPreservesLimit Spec (Spec.preimage f) (Spec.preimage g)\u27e9\u27e9\u27e9", "start": [552, 1], "end": [557, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.affine_affine_hasPullback", "code": "theorem affine_affine_hasPullback {B C : CommRingCat} {X : Scheme}\n    (f : X \u27f6 Spec.obj (Opposite.op C)) (g : Spec.obj (Opposite.op B) \u27f6 Spec.obj (Opposite.op C)) :\n    HasPullback f g", "start": [560, 1], "end": [563, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.base_affine_hasPullback", "code": "instance base_affine_hasPullback {C : CommRingCat} {X Y : Scheme} (f : X \u27f6 Spec.obj (Opposite.op C))\n    (g : Y \u27f6 Spec.obj (Opposite.op C)) : HasPullback f g :=\n  @hasPullback_symmetry _ _ _ _ _ _ _\n    (@hasPullback_of_cover _ _ _ Y.affineCover g f fun _ =>\n      @hasPullback_symmetry _ _ _ _ _ _ _ <| affine_affine_hasPullback _ _)", "start": [566, 1], "end": [570, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.left_affine_comp_pullback_hasPullback", "code": "instance left_affine_comp_pullback_hasPullback {X Y Z : Scheme} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    (i : Z.affineCover.J) : HasPullback ((Z.affineCover.pullbackCover f).map i \u226b f) g := by\n  let X\u1d62 := pullback f (Z.affineCover.map i)\n  let Y\u1d62 := pullback g (Z.affineCover.map i)\n  let W := pullback (pullback.snd : Y\u1d62 \u27f6 _) (pullback.snd : X\u1d62 \u27f6 _)\n  have :=\n    bigSquareIsPullback (pullback.fst : W \u27f6 _) (pullback.fst : Y\u1d62 \u27f6 _) (pullback.snd : X\u1d62 \u27f6 _)\n      (Z.affineCover.map i) pullback.snd pullback.snd g pullback.condition.symm\n      pullback.condition.symm (PullbackCone.flipIsLimit <| pullbackIsPullback _ _)\n      (PullbackCone.flipIsLimit <| pullbackIsPullback _ _)\n  have : HasPullback (pullback.snd \u226b Z.affineCover.map i : X\u1d62 \u27f6 _) g := \u27e8\u27e8\u27e8_, this\u27e9\u27e9\u27e9\n  rw [\u2190 pullback.condition] at this\n  exact this", "start": [573, 1], "end": [585, 13], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.isAffine_of_isAffine_isAffine_isAffine", "code": "instance isAffine_of_isAffine_isAffine_isAffine {X Y Z : Scheme}\n    (f : X \u27f6 Z) (g : Y \u27f6 Z) [IsAffine X] [IsAffine Y] [IsAffine Z] :\n    IsAffine (pullback f g) :=\n  isAffineOfIso\n    (pullback.map f g (Spec.map (\u0393.map f.op).op) (Spec.map (\u0393.map g.op).op)\n        (\u0393Spec.adjunction.unit.app X) (\u0393Spec.adjunction.unit.app Y) (\u0393Spec.adjunction.unit.app Z)\n        (\u0393Spec.adjunction.unit.naturality f) (\u0393Spec.adjunction.unit.naturality g) \u226b\n      (PreservesPullback.iso Spec _ _).inv)", "start": [594, 1], "end": [601, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfLeft", "code": "@[simps! J obj map]\ndef openCoverOfLeft (\ud835\udcb0 : OpenCover X) (f : X \u27f6 Z) (g : Y \u27f6 Z) : OpenCover (pullback f g) := by\n  fapply\n    ((gluing \ud835\udcb0 f g).openCover.pushforwardIso\n          (limit.isoLimitCone \u27e8_, gluedIsLimit \ud835\udcb0 f g\u27e9).inv).copy\n      \ud835\udcb0.J (fun i => pullback (\ud835\udcb0.map i \u226b f) g)\n      (fun i => pullback.map _ _ _ _ (\ud835\udcb0.map i) (\ud835\udfd9 _) (\ud835\udfd9 _) (Category.comp_id _) (by simp))\n      (Equiv.refl \ud835\udcb0.J) fun _ => Iso.refl _\n  rintro (i : \ud835\udcb0.J)\n  change pullback.map _ _ _ _ _ _ _ _ _ = \ud835\udfd9 _ \u226b (gluing \ud835\udcb0 f g).\u03b9 i \u226b _\n  refine' Eq.trans _ (Category.id_comp _).symm\n  apply pullback.hom_ext\n  all_goals\n    dsimp\n    simp only [limit.isoLimitCone_inv_\u03c0, PullbackCone.mk_\u03c0_app_left, Category.comp_id,\n      PullbackCone.mk_\u03c0_app_right, Category.assoc, pullback.lift_fst, pullback.lift_snd]\n    symm\n    exact Multicoequalizer.\u03c0_desc _ _ _ _ _", "start": [603, 1], "end": [621, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfRight", "code": "@[simps! J obj map]\ndef openCoverOfRight (\ud835\udcb0 : OpenCover Y) (f : X \u27f6 Z) (g : Y \u27f6 Z) : OpenCover (pullback f g) := by\n  fapply\n    ((openCoverOfLeft \ud835\udcb0 g f).pushforwardIso (pullbackSymmetry _ _).hom).copy \ud835\udcb0.J\n      (fun i => pullback f (\ud835\udcb0.map i \u226b g))\n      (fun i => pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udcb0.map i) (\ud835\udfd9 _) (by simp) (Category.comp_id _))\n      (Equiv.refl _) fun i => pullbackSymmetry _ _\n  intro i\n  dsimp [OpenCover.bind]\n  apply pullback.hom_ext <;> simp", "start": [624, 1], "end": [634, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfLeftRight", "code": "@[simps! J obj map]\ndef openCoverOfLeftRight (\ud835\udcb0X : X.OpenCover) (\ud835\udcb0Y : Y.OpenCover) (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (pullback f g).OpenCover := by\n  fapply\n    ((openCoverOfLeft \ud835\udcb0X f g).bind fun x => openCoverOfRight \ud835\udcb0Y (\ud835\udcb0X.map x \u226b f) g).copy\n      (\ud835\udcb0X.J \u00d7 \ud835\udcb0Y.J) (fun ij => pullback (\ud835\udcb0X.map ij.1 \u226b f) (\ud835\udcb0Y.map ij.2 \u226b g))\n      (fun ij =>\n        pullback.map _ _ _ _ (\ud835\udcb0X.map ij.1) (\ud835\udcb0Y.map ij.2) (\ud835\udfd9 _) (Category.comp_id _)\n          (Category.comp_id _))\n      (Equiv.sigmaEquivProd _ _).symm fun _ => Iso.refl _\n  rintro \u27e8i, j\u27e9\n  apply pullback.hom_ext <;> simp", "start": [637, 1], "end": [650, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfBase'", "code": "@[simps! map]\ndef openCoverOfBase' (\ud835\udcb0 : OpenCover Z) (f : X \u27f6 Z) (g : Y \u27f6 Z) : OpenCover (pullback f g) := by\n  apply (openCoverOfLeft (\ud835\udcb0.pullbackCover f) f g).bind\n  intro i\n  let X\u1d62 := pullback f (\ud835\udcb0.map i)\n  let Y\u1d62 := pullback g (\ud835\udcb0.map i)\n  let W := pullback (pullback.snd : Y\u1d62 \u27f6 _) (pullback.snd : X\u1d62 \u27f6 _)\n  have :=\n    bigSquareIsPullback (pullback.fst : W \u27f6 _) (pullback.fst : Y\u1d62 \u27f6 _) (pullback.snd : X\u1d62 \u27f6 _)\n      (\ud835\udcb0.map i) pullback.snd pullback.snd g pullback.condition.symm pullback.condition.symm\n      (PullbackCone.flipIsLimit <| pullbackIsPullback _ _)\n      (PullbackCone.flipIsLimit <| pullbackIsPullback _ _)\n  refine'\n    @openCoverOfIsIso\n      (f := (pullbackSymmetry _ _).hom \u226b\n        (limit.isoLimitCone \u27e8_, this\u27e9).inv \u226b pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) _ _) ?_\n  \u00b7 simp only [Category.comp_id, Category.id_comp, \u2190 pullback.condition]\n    rfl\n  \u00b7 simp only [Category.comp_id, Category.id_comp]\n  \u00b7 apply IsIso.comp_isIso", "start": [653, 1], "end": [675, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.Pullback.openCoverOfBase", "code": "@[simps! J obj map]\ndef openCoverOfBase (\ud835\udcb0 : OpenCover Z) (f : X \u27f6 Z) (g : Y \u27f6 Z) : OpenCover (pullback f g) := by\n  apply\n    (openCoverOfBase'.{u, u} \ud835\udcb0 f g).copy \ud835\udcb0.J\n      (fun i =>\n        pullback (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)\n          (pullback.snd : pullback g (\ud835\udcb0.map i) \u27f6 _))\n      (fun i =>\n        pullback.map _ _ _ _ pullback.fst pullback.fst (\ud835\udcb0.map i) pullback.condition.symm\n          pullback.condition.symm)\n      ((Equiv.prodPUnit \ud835\udcb0.J).symm.trans (Equiv.sigmaEquivProd \ud835\udcb0.J PUnit).symm) fun _ => Iso.refl _\n  intro i\n  rw [Iso.refl_hom, Category.id_comp, openCoverOfBase'_map]\n  apply pullback.hom_ext <;> dsimp <;>\n  \u00b7 simp only [limit.lift_\u03c0, PullbackCone.mk_pt, PullbackCone.mk_\u03c0_app, Category.assoc,\n      limit.lift_\u03c0_assoc, cospan_left, Category.comp_id, limit.isoLimitCone_inv_\u03c0,\n      limit.isoLimitCone_inv_\u03c0_assoc, pullbackSymmetry_hom_comp_fst_assoc,\n      pullbackSymmetry_hom_comp_snd_assoc]\n    rfl", "start": [678, 1], "end": [699, 8], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.pullback_map_isOpenImmersion", "code": "instance Scheme.pullback_map_isOpenImmersion {X Y S X' Y' S' : Scheme}\n    (f : X \u27f6 S) (g : Y \u27f6 S) (f' : X' \u27f6 S') (g' : Y' \u27f6 S')\n    (i\u2081 : X \u27f6 X') (i\u2082 : Y \u27f6 Y') (i\u2083 : S \u27f6 S') (e\u2081 : f \u226b i\u2083 = i\u2081 \u226b f') (e\u2082 : g \u226b i\u2083 = i\u2082 \u226b g')\n    [IsOpenImmersion i\u2081] [IsOpenImmersion i\u2082] [Mono i\u2083] :\n    IsOpenImmersion (pullback.map f g f' g' i\u2081 i\u2082 i\u2083 e\u2081 e\u2082) := by\n  rw [pullback_map_eq_pullbackFstFstIso_inv]\n  exact PresheafedSpace.IsOpenImmersion.comp _ (hg := PresheafedSpace.IsOpenImmersion.comp _ _)", "start": [708, 1], "end": [715, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/VectorBundle/Tangent.lean", "imports": ["Mathlib/Geometry/Manifold/VectorBundle/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "contDiffOn_fderiv_coord_change", "code": "theorem contDiffOn_fderiv_coord_change (i j : atlas H M) :\n    ContDiffOn \ud835\udd5c \u221e (fderivWithin \ud835\udd5c (j.1.extend I \u2218 (i.1.extend I).symm) (range I))\n      ((i.1.extend I).symm \u226b j.1.extend I).source", "start": [51, 1], "end": [62, 63], "kind": "commanddeclaration"}, {"full_name": "tangentBundleCore", "code": "@[simps indexAt coordChange]\ndef tangentBundleCore : VectorBundleCore \ud835\udd5c M E (atlas H M) where\n  baseSet i := i.1.source\n  isOpen_baseSet i := i.1.open_source\n  indexAt := achart H\n  mem_baseSet_at := mem_chart_source H\n  coordChange i j x :=\n    fderivWithin \ud835\udd5c (j.1.extend I \u2218 (i.1.extend I).symm) (range I) (i.1.extend I x)\n  coordChange_self i x hx v := by\n    simp only\n    rw [Filter.EventuallyEq.fderivWithin_eq, fderivWithin_id', ContinuousLinearMap.id_apply]\n    \u00b7 exact I.unique_diff_at_image\n    \u00b7 filter_upwards [i.1.extend_target_mem_nhdsWithin I hx] with y hy\n      exact (i.1.extend I).right_inv hy\n    \u00b7 simp_rw [Function.comp_apply, i.1.extend_left_inv I hx]\n  continuousOn_coordChange i j := by\n    refine' (contDiffOn_fderiv_coord_change I i j).continuousOn.comp\n      ((i.1.continuousOn_extend I).mono _) _\n    \u00b7 rw [i.1.extend_source]; exact inter_subset_left _ _\n    simp_rw [\u2190 i.1.extend_image_source_inter, mapsTo_image]\n  coordChange_comp := by\n    rintro i j k x \u27e8\u27e8hxi, hxj\u27e9, hxk\u27e9 v\n    rw [fderivWithin_fderivWithin, Filter.EventuallyEq.fderivWithin_eq]\n    \u00b7 have := i.1.extend_preimage_mem_nhds I hxi (j.1.extend_source_mem_nhds I hxj)\n      filter_upwards [nhdsWithin_le_nhds this] with y hy\n      simp_rw [Function.comp_apply, (j.1.extend I).left_inv hy]\n    \u00b7 simp_rw [Function.comp_apply, i.1.extend_left_inv I hxi, j.1.extend_left_inv I hxj]\n    \u00b7 exact (contDiffWithinAt_extend_coord_change' I (subset_maximalAtlas I k.2)\n        (subset_maximalAtlas I j.2) hxk hxj).differentiableWithinAt le_top\n    \u00b7 exact (contDiffWithinAt_extend_coord_change' I (subset_maximalAtlas I j.2)\n        (subset_maximalAtlas I i.2) hxj hxi).differentiableWithinAt le_top\n    \u00b7 intro x _; exact mem_range_self _\n    \u00b7 exact I.unique_diff_at_image\n    \u00b7 rw [Function.comp_apply, i.1.extend_left_inv I hxi]", "start": [69, 1], "end": [111, 58], "kind": "commanddeclaration"}, {"full_name": "tangentBundleCore_baseSet", "code": "@[simp high]\ntheorem tangentBundleCore_baseSet (i) : (tangentBundleCore I M).baseSet i = i.1.source", "start": [115, 1], "end": [116, 94], "kind": "commanddeclaration"}, {"full_name": "tangentBundleCore_coordChange_achart", "code": "theorem tangentBundleCore_coordChange_achart (x x' z : M) :\n    (tangentBundleCore I M).coordChange (achart H x) (achart H x') z =\n      fderivWithin \ud835\udd5c (extChartAt I x' \u2218 (extChartAt I x).symm) (range I) (extChartAt I x z)", "start": [120, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "TangentSpace", "code": "@[nolint unusedArguments]\ndef TangentSpace {\ud835\udd5c} [NontriviallyNormedField \ud835\udd5c] {E} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]\n    {H} [TopologicalSpace H] (I : ModelWithCorners \ud835\udd5c E H) {M} [TopologicalSpace M]\n    [ChartedSpace H M] [SmoothManifoldWithCorners I M] (_x : M) : Type* := E", "start": [126, 1], "end": [133, 77], "kind": "commanddeclaration"}, {"full_name": "TangentBundle", "code": "@[reducible] def TangentBundle :=\n  Bundle.TotalSpace E (TangentSpace I : M \u2192 Type _)", "start": [144, 1], "end": [148, 52], "kind": "commanddeclaration"}, {"full_name": "TangentSpace.fiberBundle", "code": "instance TangentSpace.fiberBundle : FiberBundle E (TangentSpace I : M \u2192 Type _) :=\n  (tangentBundleCore I M).fiberBundle", "start": [173, 1], "end": [174, 38], "kind": "commanddeclaration"}, {"full_name": "TangentSpace.vectorBundle", "code": "instance TangentSpace.vectorBundle : VectorBundle \ud835\udd5c E (TangentSpace I : M \u2192 Type _) :=\n  (tangentBundleCore I M).vectorBundle", "start": [176, 1], "end": [177, 39], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.chartAt", "code": "protected theorem chartAt (p : TM) :\n    chartAt (ModelProd H E) p =\n      ((tangentBundleCore I M).toFiberBundleCore.localTriv (achart H p.1)).toLocalHomeomorph \u226b\u2095\n        (chartAt H p.1).prod (LocalHomeomorph.refl E)", "start": [181, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.chartAt_toLocalEquiv", "code": "theorem chartAt_toLocalEquiv (p : TM) :\n    (chartAt (ModelProd H E) p).toLocalEquiv =\n      (tangentBundleCore I M).toFiberBundleCore.localTrivAsLocalEquiv (achart H p.1) \u226b\n        (chartAt H p.1).toLocalEquiv.prod (LocalEquiv.refl E)", "start": [188, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_eq_localTriv", "code": "theorem trivializationAt_eq_localTriv (x : M) :\n    trivializationAt E (TangentSpace I) x =\n      (tangentBundleCore I M).toFiberBundleCore.localTriv (achart H x)", "start": [195, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_source", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_source (x : M) :\n    (trivializationAt E (TangentSpace I) x).source =\n      \u03c0 E (TangentSpace I) \u207b\u00b9' (chartAt H x).source", "start": [201, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_target", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_target (x : M) :\n    (trivializationAt E (TangentSpace I) x).target = (chartAt H x).source \u00d7\u02e2 univ", "start": [208, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_baseSet", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_baseSet (x : M) :\n    (trivializationAt E (TangentSpace I) x).baseSet = (chartAt H x).source", "start": [214, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_apply", "code": "theorem trivializationAt_apply (x : M) (z : TM) :\n    trivializationAt E (TangentSpace I) x z =\n      (z.1, fderivWithin \ud835\udd5c ((chartAt H x).extend I \u2218 ((chartAt H z.1).extend I).symm) (range I)\n        ((chartAt H z.1).extend I z.1) z.2)", "start": [220, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_fst", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_fst (x : M) (z : TM) : (trivializationAt E (TangentSpace I) x z).1 = z.1", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.mem_chart_source_iff", "code": "@[simp, mfld_simps]\ntheorem mem_chart_source_iff (p q : TM) :\n    p \u2208 (chartAt (ModelProd H E) q).source \u2194 p.1 \u2208 (chartAt H q.1).source", "start": [232, 1], "end": [235, 59], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.mem_chart_target_iff", "code": "@[simp, mfld_simps]\ntheorem mem_chart_target_iff (p : H \u00d7 E) (q : TM) :\n    p \u2208 (chartAt (ModelProd H E) q).target \u2194 p.1 \u2208 (chartAt H q.1).target", "start": [238, 1], "end": [247, 82], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.coe_chartAt_fst", "code": "@[simp, mfld_simps]\ntheorem coe_chartAt_fst (p q : TM) : ((chartAt (ModelProd H E) q) p).1 = chartAt H q.1 p.1", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.coe_chartAt_symm_fst", "code": "@[simp, mfld_simps]\ntheorem coe_chartAt_symm_fst (p : H \u00d7 E) (q : TM) :\n    ((chartAt (ModelProd H E) q).symm p).1 = ((chartAt H q.1).symm : H \u2192 M) p.1", "start": [255, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_continuousLinearMapAt", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_continuousLinearMapAt {b\u2080 b : M}\n    (hb : b \u2208 (trivializationAt E (TangentSpace I) b\u2080).baseSet) :\n    (trivializationAt E (TangentSpace I) b\u2080).continuousLinearMapAt \ud835\udd5c b =\n      (tangentBundleCore I M).coordChange (achart H b) (achart H b\u2080) b", "start": [261, 1], "end": [266, 61], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.trivializationAt_symmL", "code": "@[simp, mfld_simps]\ntheorem trivializationAt_symmL {b\u2080 b : M}\n    (hb : b \u2208 (trivializationAt E (TangentSpace I) b\u2080).baseSet) :\n    (trivializationAt E (TangentSpace I) b\u2080).symmL \ud835\udd5c b =\n      (tangentBundleCore I M).coordChange (achart H b\u2080) (achart H b) b", "start": [269, 1], "end": [274, 45], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.coordChange_model_space", "code": "@[simp high, mfld_simps]\ntheorem coordChange_model_space (b b' x : F) :\n    (tangentBundleCore \ud835\udcd8(\ud835\udd5c, F) F).coordChange (achart F b) (achart F b') x = 1", "start": [279, 1], "end": [283, 44], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.symmL_model_space", "code": "@[simp high, mfld_simps]\ntheorem symmL_model_space (b b' : F) :\n    (trivializationAt F (TangentSpace \ud835\udcd8(\ud835\udd5c, F)) b).symmL \ud835\udd5c b' = (1 : F \u2192L[\ud835\udd5c] F)", "start": [287, 1], "end": [291, 17], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.continuousLinearMapAt_model_space", "code": "@[simp high, mfld_simps]\ntheorem continuousLinearMapAt_model_space (b b' : F) :\n    (trivializationAt F (TangentSpace \ud835\udcd8(\ud835\udd5c, F)) b).continuousLinearMapAt \ud835\udd5c b' = (1 : F \u2192L[\ud835\udd5c] F)", "start": [296, 1], "end": [300, 17], "kind": "commanddeclaration"}, {"full_name": "tangentBundleCore.isSmooth", "code": "instance tangentBundleCore.isSmooth : (tangentBundleCore I M).IsSmooth I := by\n  refine' \u27e8fun i j => _\u27e9\n  rw [SmoothOn, contMDiffOn_iff_source_of_mem_maximalAtlas (subset_maximalAtlas I i.2),\n    contMDiffOn_iff_contDiffOn]\n  refine' ((contDiffOn_fderiv_coord_change I i j).congr fun x hx => _).mono _\n  \u00b7 rw [LocalEquiv.trans_source'] at hx\n    simp_rw [Function.comp_apply, tangentBundleCore_coordChange, (i.1.extend I).right_inv hx.1]\n  \u00b7 exact (i.1.extend_image_source_inter j.1 I).subset\n  \u00b7 apply inter_subset_left", "start": [305, 1], "end": [313, 28], "kind": "commanddeclaration"}, {"full_name": "TangentBundle.smoothVectorBundle", "code": "instance TangentBundle.smoothVectorBundle : SmoothVectorBundle E (TangentSpace I : M \u2192 Type _) I :=\n  (tangentBundleCore I M).smoothVectorBundle _", "start": [316, 1], "end": [317, 47], "kind": "commanddeclaration"}, {"full_name": "tangentBundle_model_space_chartAt", "code": "@[simp, mfld_simps]\ntheorem tangentBundle_model_space_chartAt (p : TangentBundle I H) :\n    (chartAt (ModelProd H E) p).toLocalEquiv = (TotalSpace.toProd H E).toLocalEquiv", "start": [325, 1], "end": [338, 25], "kind": "commanddeclaration"}, {"full_name": "tangentBundle_model_space_coe_chartAt", "code": "@[simp, mfld_simps]\ntheorem tangentBundle_model_space_coe_chartAt (p : TangentBundle I H) :\n    \u21d1(chartAt (ModelProd H E) p) = TotalSpace.toProd H E", "start": [341, 1], "end": [344, 73], "kind": "commanddeclaration"}, {"full_name": "tangentBundle_model_space_coe_chartAt_symm", "code": "@[simp, mfld_simps]\ntheorem tangentBundle_model_space_coe_chartAt_symm (p : TangentBundle I H) :\n    ((chartAt (ModelProd H E) p).symm : ModelProd H E \u2192 TangentBundle I H) =\n      (TotalSpace.toProd H E).symm", "start": [347, 1], "end": [352, 44], "kind": "commanddeclaration"}, {"full_name": "tangentBundleCore_coordChange_model_space", "code": "theorem tangentBundleCore_coordChange_model_space (x x' z : H) :\n    (tangentBundleCore I H).coordChange (achart H x) (achart H x') z = ContinuousLinearMap.id \ud835\udd5c E", "start": [355, 1], "end": [357, 89], "kind": "commanddeclaration"}, {"full_name": "tangentBundleModelSpaceHomeomorph", "code": "def tangentBundleModelSpaceHomeomorph : TangentBundle I H \u2243\u209c ModelProd H E :=\n  { TotalSpace.toProd H E with\n    continuous_toFun := by\n      let p : TangentBundle I H := \u27e8I.symm (0 : E), (0 : E)\u27e9\n      have : Continuous (chartAt (ModelProd H E) p) := by\n        rw [continuous_iff_continuousOn_univ]\n        convert (chartAt (ModelProd H E) p).continuousOn\n        simp only [TangentSpace.fiberBundle, mfld_simps]\n      simpa only [mfld_simps] using this\n    continuous_invFun := by\n      let p : TangentBundle I H := \u27e8I.symm (0 : E), (0 : E)\u27e9\n      have : Continuous (chartAt (ModelProd H E) p).symm := by\n        rw [continuous_iff_continuousOn_univ]\n        convert (chartAt (ModelProd H E) p).symm.continuousOn\n        simp only [mfld_simps]\n      simpa only [mfld_simps] using this }", "start": [362, 1], "end": [379, 43], "kind": "commanddeclaration"}, {"full_name": "tangentBundleModelSpaceHomeomorph_coe", "code": "@[simp, mfld_simps]\ntheorem tangentBundleModelSpaceHomeomorph_coe :\n    (tangentBundleModelSpaceHomeomorph H I : TangentBundle I H \u2192 ModelProd H E) =\n      TotalSpace.toProd H E", "start": [382, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "tangentBundleModelSpaceHomeomorph_coe_symm", "code": "@[simp, mfld_simps]\ntheorem tangentBundleModelSpaceHomeomorph_coe_symm :\n    ((tangentBundleModelSpaceHomeomorph H I).symm : ModelProd H E \u2192 TangentBundle I H) =\n      (TotalSpace.toProd H E).symm", "start": [389, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "inCoordinates_tangent_bundle_core_model_space", "code": "theorem inCoordinates_tangent_bundle_core_model_space (x\u2080 x : H) (y\u2080 y : H') (\u03d5 : E \u2192L[\ud835\udd5c] E') :\n    inCoordinates E (TangentSpace I) E' (TangentSpace I') x\u2080 x y\u2080 y \u03d5 = \u03d5", "start": [400, 1], "end": [405, 62], "kind": "commanddeclaration"}, {"full_name": "inTangentCoordinates", "code": "def inTangentCoordinates (f : N \u2192 M) (g : N \u2192 M') (\u03d5 : N \u2192 E \u2192L[\ud835\udd5c] E') : N \u2192 N \u2192 E \u2192L[\ud835\udd5c] E' :=\n  fun x\u2080 x => inCoordinates E (TangentSpace I) E' (TangentSpace I') (f x\u2080) (f x) (g x\u2080) (g x) (\u03d5 x)", "start": [408, 1], "end": [420, 100], "kind": "commanddeclaration"}, {"full_name": "inTangentCoordinates_model_space", "code": "theorem inTangentCoordinates_model_space (f : N \u2192 H) (g : N \u2192 H') (\u03d5 : N \u2192 E \u2192L[\ud835\udd5c] E') (x\u2080 : N) :\n    inTangentCoordinates I I' f g \u03d5 x\u2080 = \u03d5", "start": [423, 1], "end": [425, 80], "kind": "commanddeclaration"}, {"full_name": "inTangentCoordinates_eq", "code": "theorem inTangentCoordinates_eq (f : N \u2192 M) (g : N \u2192 M') (\u03d5 : N \u2192 E \u2192L[\ud835\udd5c] E') {x\u2080 x : N}\n    (hx : f x \u2208 (chartAt H (f x\u2080)).source) (hy : g x \u2208 (chartAt H' (g x\u2080)).source) :\n    inTangentCoordinates I I' f g \u03d5 x\u2080 x =\n      (tangentBundleCore I' M').coordChange (achart H' (g x)) (achart H' (g x\u2080)) (g x) \u2218L\n        \u03d5 x \u2218L (tangentBundleCore I M).coordChange (achart H (f x\u2080)) (achart H (f x)) (f x)", "start": [428, 1], "end": [433, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Exponential.lean", "imports": ["Mathlib/Analysis/NormedSpace/Exponential.lean", "Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "Mathlib/Topology/MetricSpace/CauSeqFilter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hasStrictFDerivAt_exp_zero_of_radius_pos", "code": "theorem hasStrictFDerivAt_exp_zero_of_radius_pos (h : 0 < (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictFDerivAt (exp \ud835\udd42) (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38) 0", "start": [65, 1], "end": [72, 43], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_zero_of_radius_pos", "code": "theorem hasFDerivAt_exp_zero_of_radius_pos (h : 0 < (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasFDerivAt (exp \ud835\udd42) (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38) 0", "start": [75, 1], "end": [79, 59], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_of_mem_ball", "code": "theorem hasFDerivAt_exp_of_mem_ball [CharZero \ud835\udd42] {x : \ud835\udd38}\n    (hx : x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasFDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x \u2022 (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38)) x", "start": [89, 1], "end": [107, 7], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_of_mem_ball", "code": "theorem hasStrictFDerivAt_exp_of_mem_ball [CharZero \ud835\udd42] {x : \ud835\udd38}\n    (hx : x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictFDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x \u2022 (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38)) x", "start": [110, 1], "end": [117, 80], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_of_mem_ball", "code": "theorem hasStrictDerivAt_exp_of_mem_ball [CharZero \ud835\udd42] {x : \ud835\udd42}\n    (hx : x \u2208 EMetric.ball (0 : \ud835\udd42) (expSeries \ud835\udd42 \ud835\udd42).radius) : HasStrictDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x", "start": [126, 1], "end": [130, 73], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_of_mem_ball", "code": "theorem hasDerivAt_exp_of_mem_ball [CharZero \ud835\udd42] {x : \ud835\udd42}\n    (hx : x \u2208 EMetric.ball (0 : \ud835\udd42) (expSeries \ud835\udd42 \ud835\udd42).radius) : HasDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x", "start": [133, 1], "end": [137, 51], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_zero_of_radius_pos", "code": "theorem hasStrictDerivAt_exp_zero_of_radius_pos (h : 0 < (expSeries \ud835\udd42 \ud835\udd42).radius) :\n    HasStrictDerivAt (exp \ud835\udd42) (1 : \ud835\udd42) 0", "start": [140, 1], "end": [144, 64], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_zero_of_radius_pos", "code": "theorem hasDerivAt_exp_zero_of_radius_pos (h : 0 < (expSeries \ud835\udd42 \ud835\udd42).radius) :\n    HasDerivAt (exp \ud835\udd42) (1 : \ud835\udd42) 0", "start": [147, 1], "end": [151, 57], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_zero", "code": "theorem hasStrictFDerivAt_exp_zero : HasStrictFDerivAt (exp \ud835\udd42) (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38) 0", "start": [160, 1], "end": [163, 70], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_zero", "code": "theorem hasFDerivAt_exp_zero : HasFDerivAt (exp \ud835\udd42) (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38) 0", "start": [166, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp", "code": "theorem hasStrictFDerivAt_exp {x : \ud835\udd38} : HasStrictFDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x \u2022 (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38)) x", "start": [178, 1], "end": [181, 92], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp", "code": "theorem hasFDerivAt_exp {x : \ud835\udd38} : HasFDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x \u2022 (1 : \ud835\udd38 \u2192L[\ud835\udd42] \ud835\udd38)) x", "start": [184, 1], "end": [187, 36], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp", "code": "theorem hasStrictDerivAt_exp {x : \ud835\udd42} : HasStrictDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x", "start": [196, 1], "end": [199, 91], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp", "code": "theorem hasDerivAt_exp {x : \ud835\udd42} : HasDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x", "start": [202, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_zero", "code": "theorem hasStrictDerivAt_exp_zero : HasStrictDerivAt (exp \ud835\udd42) (1 : \ud835\udd42) 0", "start": [207, 1], "end": [209, 69], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_zero", "code": "theorem hasDerivAt_exp_zero : HasDerivAt (exp \ud835\udd42) (1 : \ud835\udd42) 0", "start": [212, 1], "end": [214, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.exp_eq_exp_\u2102", "code": "theorem Complex.exp_eq_exp_\u2102 : Complex.exp = _root_.exp \u2102", "start": [219, 1], "end": [223, 101], "kind": "commanddeclaration"}, {"full_name": "Real.exp_eq_exp_\u211d", "code": "theorem Real.exp_eq_exp_\u211d : Real.exp = _root_.exp \u211d", "start": [226, 1], "end": [227, 57], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_smul_const_of_mem_ball", "code": "theorem hasFDerivAt_exp_smul_const_of_mem_ball (x : \ud835\udd38) (t : \ud835\udd4a)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) \u2022 (1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x) t", "start": [274, 1], "end": [302, 101], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_smul_const_of_mem_ball'", "code": "theorem hasFDerivAt_exp_smul_const_of_mem_ball' (x : \ud835\udd38) (t : \ud835\udd4a)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (((1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x).smulRight (exp \ud835\udd42 (t \u2022 x))) t", "start": [305, 1], "end": [312, 67], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_smul_const_of_mem_ball", "code": "theorem hasStrictFDerivAt_exp_smul_const_of_mem_ball (x : \ud835\udd38) (t : \ud835\udd4a)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (exp \ud835\udd42 (t \u2022 x) \u2022 (1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x) t", "start": [315, 1], "end": [324, 44], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_smul_const_of_mem_ball'", "code": "theorem hasStrictFDerivAt_exp_smul_const_of_mem_ball' (x : \ud835\udd38) (t : \ud835\udd4a)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (((1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x).smulRight (exp \ud835\udd42 (t \u2022 x))) t", "start": [327, 1], "end": [335, 67], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_smul_const_of_mem_ball", "code": "theorem hasStrictDerivAt_exp_smul_const_of_mem_ball (x : \ud835\udd38) (t : \ud835\udd42)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) * x) t", "start": [340, 1], "end": [343, 88], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_smul_const_of_mem_ball'", "code": "theorem hasStrictDerivAt_exp_smul_const_of_mem_ball' (x : \ud835\udd38) (t : \ud835\udd42)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasStrictDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (x * exp \ud835\udd42 (t \u2022 x)) t", "start": [346, 1], "end": [349, 89], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_smul_const_of_mem_ball", "code": "theorem hasDerivAt_exp_smul_const_of_mem_ball (x : \ud835\udd38) (t : \ud835\udd42)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) * x) t", "start": [352, 1], "end": [355, 67], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_smul_const_of_mem_ball'", "code": "theorem hasDerivAt_exp_smul_const_of_mem_ball' (x : \ud835\udd38) (t : \ud835\udd42)\n    (htx : t \u2022 x \u2208 EMetric.ball (0 : \ud835\udd38) (expSeries \ud835\udd42 \ud835\udd38).radius) :\n    HasDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (x * exp \ud835\udd42 (t \u2022 x)) t", "start": [358, 1], "end": [361, 68], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_smul_const", "code": "theorem hasFDerivAt_exp_smul_const (x : \ud835\udd38) (t : \ud835\udd4a) :\n    HasFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) \u2022 (1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x) t", "start": [378, 1], "end": [381, 58], "kind": "commanddeclaration"}, {"full_name": "hasFDerivAt_exp_smul_const'", "code": "theorem hasFDerivAt_exp_smul_const' (x : \ud835\udd38) (t : \ud835\udd4a) :\n    HasFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (((1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x).smulRight (exp \ud835\udd42 (t \u2022 x))) t", "start": [384, 1], "end": [388, 58], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_smul_const", "code": "theorem hasStrictFDerivAt_exp_smul_const (x : \ud835\udd38) (t : \ud835\udd4a) :\n    HasStrictFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (exp \ud835\udd42 (t \u2022 x) \u2022 (1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x) t", "start": [391, 1], "end": [395, 58], "kind": "commanddeclaration"}, {"full_name": "hasStrictFDerivAt_exp_smul_const'", "code": "theorem hasStrictFDerivAt_exp_smul_const' (x : \ud835\udd38) (t : \ud835\udd4a) :\n    HasStrictFDerivAt (fun u : \ud835\udd4a => exp \ud835\udd42 (u \u2022 x))\n      (((1 : \ud835\udd4a \u2192L[\ud835\udd42] \ud835\udd4a).smulRight x).smulRight (exp \ud835\udd42 (t \u2022 x))) t", "start": [398, 1], "end": [402, 58], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_smul_const", "code": "theorem hasStrictDerivAt_exp_smul_const (x : \ud835\udd38) (t : \ud835\udd42) :\n    HasStrictDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) * x) t", "start": [407, 1], "end": [410, 58], "kind": "commanddeclaration"}, {"full_name": "hasStrictDerivAt_exp_smul_const'", "code": "theorem hasStrictDerivAt_exp_smul_const' (x : \ud835\udd38) (t : \ud835\udd42) :\n    HasStrictDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (x * exp \ud835\udd42 (t \u2022 x)) t", "start": [413, 1], "end": [416, 58], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_smul_const", "code": "theorem hasDerivAt_exp_smul_const (x : \ud835\udd38) (t : \ud835\udd42) :\n    HasDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (exp \ud835\udd42 (t \u2022 x) * x) t", "start": [419, 1], "end": [421, 101], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_exp_smul_const'", "code": "theorem hasDerivAt_exp_smul_const' (x : \ud835\udd38) (t : \ud835\udd42) :\n    HasDerivAt (fun u : \ud835\udd42 => exp \ud835\udd42 (u \u2022 x)) (x * exp \ud835\udd42 (t \u2022 x)) t", "start": [424, 1], "end": [427, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Spectrum.lean", "imports": ["Mathlib/Analysis/Complex/Polynomial.lean", "Mathlib/Analysis/NormedSpace/Exponential.lean", "Mathlib/Topology/Algebra/Module/CharacterSpace.lean", "Mathlib/Analysis/Complex/Liouville.lean", "Mathlib/Analysis/Analytic/RadiusLiminf.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/FieldTheory/IsAlgClosed/Spectrum.lean"], "premises": [{"full_name": "spectralRadius", "code": "noncomputable def spectralRadius (\ud835\udd5c : Type*) {A : Type*} [NormedField \ud835\udd5c] [Ring A] [Algebra \ud835\udd5c A]\n    (a : A) : \u211d\u22650\u221e :=\n  \u2a06 k \u2208 spectrum \ud835\udd5c a, \u2016k\u2016\u208a", "start": [50, 1], "end": [57, 27], "kind": "commanddeclaration"}, {"full_name": "spectrum.SpectralRadius.of_subsingleton", "code": "@[simp]\ntheorem SpectralRadius.of_subsingleton [Subsingleton A] (a : A) : spectralRadius \ud835\udd5c a = 0", "start": [74, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_zero", "code": "@[simp]\ntheorem spectralRadius_zero : spectralRadius \ud835\udd5c (0 : A) = 0", "start": [79, 1], "end": [82, 24], "kind": "commanddeclaration"}, {"full_name": "spectrum.mem_resolventSet_of_spectralRadius_lt", "code": "theorem mem_resolventSet_of_spectralRadius_lt {a : A} {k : \ud835\udd5c} (h : spectralRadius \ud835\udd5c a < \u2016k\u2016\u208a) :\n    k \u2208 \u03c1 a", "start": [85, 1], "end": [87, 71], "kind": "commanddeclaration"}, {"full_name": "spectrum.isOpen_resolventSet", "code": "theorem isOpen_resolventSet (a : A) : IsOpen (\u03c1 a)", "start": [92, 1], "end": [93, 75], "kind": "commanddeclaration"}, {"full_name": "spectrum.isClosed", "code": "protected theorem isClosed (a : A) : IsClosed (\u03c3 a)", "start": [96, 1], "end": [97, 41], "kind": "commanddeclaration"}, {"full_name": "spectrum.mem_resolventSet_of_norm_lt_mul", "code": "theorem mem_resolventSet_of_norm_lt_mul {a : A} {k : \ud835\udd5c} (h : \u2016a\u2016 * \u2016(1 : A)\u2016 < \u2016k\u2016) : k \u2208 \u03c1 a", "start": [100, 1], "end": [109, 88], "kind": "commanddeclaration"}, {"full_name": "spectrum.mem_resolventSet_of_norm_lt", "code": "theorem mem_resolventSet_of_norm_lt [NormOneClass A] {a : A} {k : \ud835\udd5c} (h : \u2016a\u2016 < \u2016k\u2016) : k \u2208 \u03c1 a", "start": [112, 1], "end": [113, 63], "kind": "commanddeclaration"}, {"full_name": "spectrum.norm_le_norm_mul_of_mem", "code": "theorem norm_le_norm_mul_of_mem {a : A} {k : \ud835\udd5c} (hk : k \u2208 \u03c3 a) : \u2016k\u2016 \u2264 \u2016a\u2016 * \u2016(1 : A)\u2016", "start": [116, 1], "end": [117, 56], "kind": "commanddeclaration"}, {"full_name": "spectrum.norm_le_norm_of_mem", "code": "theorem norm_le_norm_of_mem [NormOneClass A] {a : A} {k : \ud835\udd5c} (hk : k \u2208 \u03c3 a) : \u2016k\u2016 \u2264 \u2016a\u2016", "start": [120, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "spectrum.subset_closedBall_norm_mul", "code": "theorem subset_closedBall_norm_mul (a : A) : \u03c3 a \u2286 Metric.closedBall (0 : \ud835\udd5c) (\u2016a\u2016 * \u2016(1 : A)\u2016)", "start": [124, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "spectrum.subset_closedBall_norm", "code": "theorem subset_closedBall_norm [NormOneClass A] (a : A) : \u03c3 a \u2286 Metric.closedBall (0 : \ud835\udd5c) \u2016a\u2016", "start": [128, 1], "end": [129, 47], "kind": "commanddeclaration"}, {"full_name": "spectrum.isBounded", "code": "theorem isBounded (a : A) : Bornology.IsBounded (\u03c3 a)", "start": [132, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "spectrum.isCompact", "code": "protected theorem isCompact [ProperSpace \ud835\udd5c] (a : A) : IsCompact (\u03c3 a)", "start": [136, 1], "end": [137, 77], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_le_nnnorm", "code": "theorem spectralRadius_le_nnnorm [NormOneClass A] (a : A) : spectralRadius \ud835\udd5c a \u2264 \u2016a\u2016\u208a", "start": [140, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "spectrum.exists_nnnorm_eq_spectralRadius_of_nonempty", "code": "theorem exists_nnnorm_eq_spectralRadius_of_nonempty [ProperSpace \ud835\udd5c] {a : A} (ha : (\u03c3 a).Nonempty) :\n    \u2203 k \u2208 \u03c3 a, (\u2016k\u2016\u208a : \u211d\u22650\u221e) = spectralRadius \ud835\udd5c a", "start": [145, 1], "end": [148, 91], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_lt_of_forall_lt_of_nonempty", "code": "theorem spectralRadius_lt_of_forall_lt_of_nonempty [ProperSpace \ud835\udd5c] {a : A} (ha : (\u03c3 a).Nonempty)\n    {r : \u211d\u22650} (hr : \u2200 k \u2208 \u03c3 a, \u2016k\u2016\u208a < r) : spectralRadius \ud835\udd5c a < r", "start": [151, 1], "end": [156, 51], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_le_pow_nnnorm_pow_one_div", "code": "theorem spectralRadius_le_pow_nnnorm_pow_one_div (a : A) (n : \u2115) :\n    spectralRadius \ud835\udd5c a \u2264 (\u2016a ^ (n + 1)\u2016\u208a : \u211d\u22650\u221e) ^ (1 / (n + 1) : \u211d) *\n      (\u2016(1 : A)\u2016\u208a : \u211d\u22650\u221e) ^ (1 / (n + 1) : \u211d)", "start": [163, 1], "end": [180, 43], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_le_liminf_pow_nnnorm_pow_one_div", "code": "theorem spectralRadius_le_liminf_pow_nnnorm_pow_one_div (a : A) :\n    spectralRadius \ud835\udd5c a \u2264 atTop.liminf fun n : \u2115 => (\u2016a ^ n\u2016\u208a : \u211d\u22650\u221e) ^ (1 / n : \u211d)", "start": [183, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "spectrum.hasDerivAt_resolvent", "code": "theorem hasDerivAt_resolvent {a : A} {k : \ud835\udd5c} (hk : k \u2208 \u03c1 a) :\n    HasDerivAt (resolvent a) (-resolvent a k ^ 2) k", "start": [215, 1], "end": [220, 97], "kind": "commanddeclaration"}, {"full_name": "spectrum.norm_resolvent_le_forall", "code": "theorem norm_resolvent_le_forall (a : A) :\n    \u2200 \u03b5 > 0, \u2203 R > 0, \u2200 z : \ud835\udd5c, R \u2264 \u2016z\u2016 \u2192 \u2016resolvent a z\u2016 \u2264 \u03b5", "start": [226, 1], "end": [256, 51], "kind": "commanddeclaration"}, {"full_name": "spectrum.hasFPowerSeriesOnBall_inverse_one_sub_smul", "code": "theorem hasFPowerSeriesOnBall_inverse_one_sub_smul [CompleteSpace A] (a : A) :\n    HasFPowerSeriesOnBall (fun z : \ud835\udd5c => Ring.inverse (1 - z \u2022 a))\n      (fun n => ContinuousMultilinearMap.mkPiField \ud835\udd5c (Fin n) (a ^ n)) 0 \u2016a\u2016\u208a\u207b\u00b9", "start": [271, 1], "end": [300, 54], "kind": "commanddeclaration"}, {"full_name": "spectrum.isUnit_one_sub_smul_of_lt_inv_radius", "code": "theorem isUnit_one_sub_smul_of_lt_inv_radius {a : A} {z : \ud835\udd5c} (h : \u2191\u2016z\u2016\u208a < (spectralRadius \ud835\udd5c a)\u207b\u00b9) :\n    IsUnit (1 - z \u2022 a)", "start": [305, 1], "end": [315, 99], "kind": "commanddeclaration"}, {"full_name": "spectrum.differentiableOn_inverse_one_sub_smul", "code": "theorem differentiableOn_inverse_one_sub_smul [CompleteSpace A] {a : A} {r : \u211d\u22650}\n    (hr : (r : \u211d\u22650\u221e) < (spectralRadius \ud835\udd5c a)\u207b\u00b9) :\n    DifferentiableOn \ud835\udd5c (fun z : \ud835\udd5c => Ring.inverse (1 - z \u2022 a)) (Metric.closedBall 0 r)", "start": [318, 1], "end": [330, 82], "kind": "commanddeclaration"}, {"full_name": "spectrum.limsup_pow_nnnorm_pow_one_div_le_spectralRadius", "code": "theorem limsup_pow_nnnorm_pow_one_div_le_spectralRadius (a : A) :\n    limsup (fun n : \u2115 => (\u2016a ^ n\u2016\u208a : \u211d\u22650\u221e) ^ (1 / n : \u211d)) atTop \u2264 spectralRadius \u2102 a", "start": [343, 1], "end": [359, 85], "kind": "commanddeclaration"}, {"full_name": "spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius", "code": "theorem pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : \u2115 => (\u2016a ^ n\u2016\u208a : \u211d\u22650\u221e) ^ (1 / n : \u211d)) atTop (\ud835\udcdd (spectralRadius \u2102 a))", "start": [362, 1], "end": [367, 56], "kind": "commanddeclaration"}, {"full_name": "spectrum.pow_norm_pow_one_div_tendsto_nhds_spectralRadius", "code": "theorem pow_norm_pow_one_div_tendsto_nhds_spectralRadius (a : A) :\n    Tendsto (fun n : \u2115 => ENNReal.ofReal (\u2016a ^ n\u2016 ^ (1 / n : \u211d))) atTop\n      (\ud835\udcdd (spectralRadius \u2102 a))", "start": [372, 1], "end": [380, 57], "kind": "commanddeclaration"}, {"full_name": "spectrum.nonempty", "code": "protected theorem nonempty : (spectrum \u2102 a).Nonempty", "start": [389, 1], "end": [420, 90], "kind": "commanddeclaration"}, {"full_name": "spectrum.exists_nnnorm_eq_spectralRadius", "code": "theorem exists_nnnorm_eq_spectralRadius : \u2203 z \u2208 spectrum \u2102 a, (\u2016z\u2016\u208a : \u211d\u22650\u221e) = spectralRadius \u2102 a", "start": [423, 1], "end": [426, 68], "kind": "commanddeclaration"}, {"full_name": "spectrum.spectralRadius_lt_of_forall_lt", "code": "theorem spectralRadius_lt_of_forall_lt {r : \u211d\u22650} (hr : \u2200 z \u2208 spectrum \u2102 a, \u2016z\u2016\u208a < r) :\n    spectralRadius \u2102 a < r", "start": [429, 1], "end": [433, 70], "kind": "commanddeclaration"}, {"full_name": "spectrum.map_polynomial_aeval", "code": "theorem map_polynomial_aeval (p : \u2102[X]) :\n    spectrum \u2102 (aeval a p) = (fun k => eval k p) '' spectrum \u2102 a", "start": [440, 1], "end": [443, 61], "kind": "commanddeclaration"}, {"full_name": "spectrum.map_pow", "code": "protected theorem map_pow (n : \u2115) :\n    spectrum \u2102 (a ^ n) = (fun x : \u2102 => HPow.hPow x n) '' spectrum \u2102 a", "start": [447, 1], "end": [451, 82], "kind": "commanddeclaration"}, {"full_name": "spectrum.algebraMap_eq_of_mem", "code": "theorem algebraMap_eq_of_mem {a : A} {z : \u2102} (h : z \u2208 \u03c3 a) : algebraMap \u2102 A z = a", "start": [462, 1], "end": [463, 57], "kind": "commanddeclaration"}, {"full_name": "NormedRing.algEquivComplexOfComplete", "code": "@[simps]\nnoncomputable def _root_.NormedRing.algEquivComplexOfComplete [CompleteSpace A] : \u2102 \u2243\u2090[\u2102] A :=\n  let nt : Nontrivial A := \u27e8\u27e81, 0, hA.mp \u27e8\u27e81, 1, mul_one _, mul_one _\u27e9, rfl\u27e9\u27e9\u27e9\n  { Algebra.ofId \u2102 A with\n    toFun := algebraMap \u2102 A\n    invFun := fun a => (@spectrum.nonempty _ _ _ _ nt a).some\n    left_inv := fun z => by\n      simpa only [@scalar_eq _ _ _ _ _ nt _] using\n        (@spectrum.nonempty _ _ _ _ nt <| algebraMap \u2102 A z).some_mem\n    right_inv := fun a => algebraMap_eq_of_mem (@hA) (@spectrum.nonempty _ _ _ _ nt a).some_mem }", "start": [466, 1], "end": [484, 98], "kind": "commanddeclaration"}, {"full_name": "spectrum.exp_mem_exp", "code": "theorem exp_mem_exp [IsROrC \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A] (a : A) {z : \ud835\udd5c}\n    (hz : z \u2208 spectrum \ud835\udd5c a) : exp \ud835\udd5c z \u2208 spectrum \ud835\udd5c (exp \ud835\udd5c a)", "start": [493, 1], "end": [518, 95], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toContinuousLinearMap", "code": "def toContinuousLinearMap (\u03c6 : A \u2192\u2090[\ud835\udd5c] \ud835\udd5c) : A \u2192L[\ud835\udd5c] \ud835\udd5c :=\n  { \u03c6.toLinearMap with cont := map_continuous \u03c6 }", "start": [541, 1], "end": [544, 50], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_toContinuousLinearMap", "code": "@[simp]\ntheorem coe_toContinuousLinearMap (\u03c6 : A \u2192\u2090[\ud835\udd5c] \ud835\udd5c) : \u21d1\u03c6.toContinuousLinearMap = \u03c6", "start": [547, 1], "end": [549, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.norm_apply_le_self_mul_norm_one", "code": "theorem norm_apply_le_self_mul_norm_one [AlgHomClass F \ud835\udd5c A \ud835\udd5c] (f : F) (a : A) :\n    \u2016f a\u2016 \u2264 \u2016a\u2016 * \u2016(1 : A)\u2016", "start": [552, 1], "end": [554, 60], "kind": "commanddeclaration"}, {"full_name": "AlgHom.norm_apply_le_self", "code": "theorem norm_apply_le_self [NormOneClass A] [AlgHomClass F \ud835\udd5c A \ud835\udd5c] (f : F) (a : A) : \u2016f a\u2016 \u2264 \u2016a\u2016", "start": [557, 1], "end": [558, 56], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toContinuousLinearMap_norm", "code": "@[simp]\ntheorem toContinuousLinearMap_norm [NormOneClass A] (\u03c6 : A \u2192\u2090[\ud835\udd5c] \ud835\udd5c) :\n    \u2016\u03c6.toContinuousLinearMap\u2016 = 1", "start": [569, 1], "end": [574, 97], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.equivAlgHom", "code": "def equivAlgHom : characterSpace \ud835\udd5c A \u2243 (A \u2192\u2090[\ud835\udd5c] \ud835\udd5c) where\n  toFun := toAlgHom\n  invFun f :=\n    { val := f.toContinuousLinearMap\n      property := by rw [eq_set_map_one_map_mul]; exact \u27e8map_one f, map_mul f\u27e9 }\n  left_inv f := Subtype.ext <| ContinuousLinearMap.ext fun x => rfl\n  right_inv f := AlgHom.ext fun x => rfl", "start": [589, 1], "end": [596, 41], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.equivAlgHom_coe", "code": "@[simp]\ntheorem equivAlgHom_coe (f : characterSpace \ud835\udd5c A) : \u21d1(equivAlgHom f) = f", "start": [599, 1], "end": [601, 6], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.equivAlgHom_symm_coe", "code": "@[simp]\ntheorem equivAlgHom_symm_coe (f : A \u2192\u2090[\ud835\udd5c] \ud835\udd5c) : \u21d1(equivAlgHom.symm f) = f", "start": [604, 1], "end": [606, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/WeakDual.lean", "imports": ["Mathlib/Analysis/NormedSpace/Dual.lean", "Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Topology/Algebra/Module/WeakDual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NormedSpace.Dual.toWeakDual", "code": "def toWeakDual : Dual \ud835\udd5c E \u2243\u2097[\ud835\udd5c] WeakDual \ud835\udd5c E :=\n  LinearEquiv.refl \ud835\udd5c (E \u2192L[\ud835\udd5c] \ud835\udd5c)", "start": [115, 1], "end": [118, 33], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.coe_toWeakDual", "code": "@[simp]\ntheorem coe_toWeakDual (x' : Dual \ud835\udd5c E) : toWeakDual x' = x'", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.toWeakDual_eq_iff", "code": "@[simp]\ntheorem toWeakDual_eq_iff (x' y' : Dual \ud835\udd5c E) : toWeakDual x' = toWeakDual y' \u2194 x' = y'", "start": [126, 1], "end": [128, 64], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.toWeakDual_continuous", "code": "theorem toWeakDual_continuous : Continuous fun x' : Dual \ud835\udd5c E => toWeakDual x'", "start": [131, 1], "end": [132, 94], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.continuousLinearMapToWeakDual", "code": "def continuousLinearMapToWeakDual : Dual \ud835\udd5c E \u2192L[\ud835\udd5c] WeakDual \ud835\udd5c E :=\n  { toWeakDual with cont := toWeakDual_continuous }", "start": [135, 1], "end": [139, 52], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.dual_norm_topology_le_weak_dual_topology", "code": "theorem dual_norm_topology_le_weak_dual_topology :\n    (UniformSpace.toTopologicalSpace : TopologicalSpace (Dual \ud835\udd5c E)) \u2264\n      (WeakDual.instTopologicalSpace : TopologicalSpace (WeakDual \ud835\udd5c E))", "start": [142, 1], "end": [147, 24], "kind": "commanddeclaration"}, {"full_name": "WeakDual.toNormedDual", "code": "def toNormedDual : WeakDual \ud835\udd5c E \u2243\u2097[\ud835\udd5c] Dual \ud835\udd5c E :=\n  NormedSpace.Dual.toWeakDual.symm", "start": [158, 1], "end": [162, 35], "kind": "commanddeclaration"}, {"full_name": "WeakDual.toNormedDual_apply", "code": "theorem toNormedDual_apply (x : WeakDual \ud835\udd5c E) (y : E) : (toNormedDual x) y = x y", "start": [165, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "WeakDual.coe_toNormedDual", "code": "@[simp]\ntheorem coe_toNormedDual (x' : WeakDual \ud835\udd5c E) : toNormedDual x' = x'", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "WeakDual.toNormedDual_eq_iff", "code": "@[simp]\ntheorem toNormedDual_eq_iff (x' y' : WeakDual \ud835\udd5c E) : toNormedDual x' = toNormedDual y' \u2194 x' = y'", "start": [174, 1], "end": [176, 66], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isClosed_closedBall", "code": "theorem isClosed_closedBall (x' : Dual \ud835\udd5c E) (r : \u211d) : IsClosed (toNormedDual \u207b\u00b9' closedBall x' r)", "start": [179, 1], "end": [180, 79], "kind": "commanddeclaration"}, {"full_name": "WeakDual.polar", "code": "def polar (s : Set E) : Set (WeakDual \ud835\udd5c E) :=\n  toNormedDual \u207b\u00b9' (NormedSpace.polar \ud835\udd5c) s", "start": [190, 1], "end": [193, 43], "kind": "commanddeclaration"}, {"full_name": "WeakDual.polar_def", "code": "theorem polar_def (s : Set E) : polar \ud835\udd5c s = { f : WeakDual \ud835\udd5c E | \u2200 x \u2208 s, \u2016f x\u2016 \u2264 1 }", "start": [196, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isClosed_polar", "code": "theorem isClosed_polar (s : Set E) : IsClosed (polar \ud835\udd5c s)", "start": [200, 1], "end": [204, 96], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isClosed_image_coe_of_bounded_of_closed", "code": "theorem isClosed_image_coe_of_bounded_of_closed {s : Set (WeakDual \ud835\udd5c E)}\n    (hb : IsBounded (Dual.toWeakDual \u207b\u00b9' s)) (hc : IsClosed s) :\n    IsClosed (((\u2191) : WeakDual \ud835\udd5c E \u2192 E \u2192 \ud835\udd5c) '' s)", "start": [209, 1], "end": [214, 99], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isCompact_of_bounded_of_closed", "code": "theorem isCompact_of_bounded_of_closed [ProperSpace \ud835\udd5c] {s : Set (WeakDual \ud835\udd5c E)}\n    (hb : IsBounded (Dual.toWeakDual \u207b\u00b9' s)) (hc : IsClosed s) : IsCompact s", "start": [217, 1], "end": [221, 52], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isClosed_image_polar_of_mem_nhds", "code": "theorem isClosed_image_polar_of_mem_nhds {s : Set E} (s_nhd : s \u2208 \ud835\udcdd (0 : E)) :\n    IsClosed (((\u2191) : WeakDual \ud835\udd5c E \u2192 E \u2192 \ud835\udd5c) '' polar \ud835\udd5c s)", "start": [226, 1], "end": [231, 25], "kind": "commanddeclaration"}, {"full_name": "NormedSpace.Dual.isClosed_image_polar_of_mem_nhds", "code": "theorem _root_.NormedSpace.Dual.isClosed_image_polar_of_mem_nhds {s : Set E}\n    (s_nhd : s \u2208 \ud835\udcdd (0 : E)) :\n    IsClosed (((\u2191) : Dual \ud835\udd5c E \u2192 E \u2192 \ud835\udd5c) '' NormedSpace.polar \ud835\udd5c s)", "start": [234, 1], "end": [239, 52], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isCompact_polar", "code": "theorem isCompact_polar [ProperSpace \ud835\udd5c] {s : Set E} (s_nhd : s \u2208 \ud835\udcdd (0 : E)) :\n    IsCompact (polar \ud835\udd5c s)", "start": [242, 1], "end": [246, 97], "kind": "commanddeclaration"}, {"full_name": "WeakDual.isCompact_closedBall", "code": "theorem isCompact_closedBall [ProperSpace \ud835\udd5c] (x' : Dual \ud835\udd5c E) (r : \u211d) :\n    IsCompact (toNormedDual \u207b\u00b9' closedBall x' r)", "start": [249, 1], "end": [253, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Shift/CommShift.lean", "imports": ["Mathlib/CategoryTheory/Shift/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.CommShift.isoZero", "code": "@[simps!]\nnoncomputable def isoZero : shiftFunctor C (0 : A) \u22d9 F \u2245 F \u22d9 shiftFunctor D (0 : A) :=\n  isoWhiskerRight (shiftFunctorZero C A) F \u226a\u226b F.leftUnitor \u226a\u226b\n     F.rightUnitor.symm \u226a\u226b isoWhiskerLeft F (shiftFunctorZero D A).symm", "start": [41, 1], "end": [47, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.CommShift.isoAdd'", "code": "@[simps!]\nnoncomputable def isoAdd' {a b c : A} (h : a + b = c)\n    (e\u2081 : shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a)\n    (e\u2082 : shiftFunctor C b \u22d9 F \u2245 F \u22d9 shiftFunctor D b) :\n    shiftFunctor C c \u22d9 F \u2245 F \u22d9 shiftFunctor D c :=\n  isoWhiskerRight (shiftFunctorAdd' C _ _ _ h) F \u226a\u226b Functor.associator _ _ _ \u226a\u226b\n    isoWhiskerLeft _ e\u2082 \u226a\u226b (Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight e\u2081 _ \u226a\u226b\n      Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft _ (shiftFunctorAdd' D _ _ _ h).symm", "start": [51, 1], "end": [61, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.CommShift.isoAdd", "code": "noncomputable def isoAdd {a b : A}\n    (e\u2081 : shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a)\n    (e\u2082 : shiftFunctor C b \u22d9 F \u2245 F \u22d9 shiftFunctor D b) :\n    shiftFunctor C (a + b) \u22d9 F \u2245 F \u22d9 shiftFunctor D (a + b) :=\n  CommShift.isoAdd' rfl e\u2081 e\u2082", "start": [63, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.CommShift.isoAdd_hom_app", "code": "@[simp]\nlemma isoAdd_hom_app {a b : A}\n    (e\u2081 : shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a)\n    (e\u2082 : shiftFunctor C b \u22d9 F \u2245 F \u22d9 shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd e\u2081 e\u2082).hom.app X =\n        F.map ((shiftFunctorAdd C a b).hom.app X) \u226b e\u2082.hom.app ((shiftFunctor C a).obj X) \u226b\n          (shiftFunctor D b).map (e\u2081.hom.app X) \u226b (shiftFunctorAdd D a b).inv.app (F.obj X) := by\n  simp only [isoAdd, isoAdd'_hom_app, shiftFunctorAdd'_eq_shiftFunctorAdd]", "start": [71, 1], "end": [78, 75], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.CommShift.isoAdd_inv_app", "code": "@[simp]\nlemma isoAdd_inv_app {a b : A}\n    (e\u2081 : shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a)\n    (e\u2082 : shiftFunctor C b \u22d9 F \u2245 F \u22d9 shiftFunctor D b) (X : C) :\n      (CommShift.isoAdd e\u2081 e\u2082).inv.app X = (shiftFunctorAdd D a b).hom.app (F.obj X) \u226b\n        (shiftFunctor D b).map (e\u2081.inv.app X) \u226b e\u2082.inv.app ((shiftFunctor C a).obj X) \u226b\n        F.map ((shiftFunctorAdd C a b).inv.app X) := by\n  simp only [isoAdd, isoAdd'_inv_app, shiftFunctorAdd'_eq_shiftFunctorAdd]", "start": [80, 1], "end": [87, 75], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.CommShift", "code": "class CommShift where\n  iso (a : A) : shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a\n  zero : iso 0 = CommShift.isoZero F A := by aesop_cat\n  add (a b : A) : iso (a + b) = CommShift.isoAdd (iso a) (iso b) := by aesop_cat", "start": [91, 1], "end": [97, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.commShiftIso", "code": "def commShiftIso (a : A) :\n    shiftFunctor C a \u22d9 F \u2245 F \u22d9 shiftFunctor D a :=\n  CommShift.iso a", "start": [105, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.commShiftIso_hom_naturality", "code": "@[reassoc (attr := simp)]\nlemma commShiftIso_hom_naturality {X Y : C} (f : X \u27f6 Y) (a : A) :\n    F.map (f\u27e6a\u27e7') \u226b (F.commShiftIso a).hom.app Y =\n      (F.commShiftIso a).hom.app X \u226b (F.map f)\u27e6a\u27e7' :=\n  (F.commShiftIso a).hom.naturality f", "start": [116, 1], "end": [120, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.commShiftIso_inv_naturality", "code": "@[reassoc (attr := simp)]\nlemma commShiftIso_inv_naturality {X Y : C} (f : X \u27f6 Y) (a : A) :\n    (F.map f)\u27e6a\u27e7' \u226b (F.commShiftIso a).inv.app Y =\n      (F.commShiftIso a).inv.app X \u226b F.map (f\u27e6a\u27e7') :=\n  (F.commShiftIso a).inv.naturality f", "start": [122, 1], "end": [126, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.commShiftIso_zero", "code": "lemma commShiftIso_zero :\n    F.commShiftIso (0 : A) = CommShift.isoZero F A :=\n  CommShift.zero", "start": [130, 1], "end": [132, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.commShiftIso_add", "code": "lemma commShiftIso_add (a b : A) :\n    F.commShiftIso (a + b) = CommShift.isoAdd (F.commShiftIso a) (F.commShiftIso b) :=\n  CommShift.add a b", "start": [136, 1], "end": [138, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.commShiftIso_add'", "code": "lemma commShiftIso_add' {a b c : A} (h : a + b = c) :\n    F.commShiftIso c = CommShift.isoAdd' h (F.commShiftIso a) (F.commShiftIso b) := by\n  subst h\n  simp only [commShiftIso_add, CommShift.isoAdd]", "start": [140, 1], "end": [143, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.CommShift.id", "code": "instance id : CommShift (\ud835\udfed C) A where\n  iso := fun a => rightUnitor _ \u226a\u226b (leftUnitor _).symm", "start": [151, 1], "end": [152, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean", "Mathlib/AlgebraicTopology/DoldKan/NReflectsIso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicTopology.DoldKan.PInfty_comp_map_mono_eq_zero", "code": "theorem PInfty_comp_map_mono_eq_zero (X : SimplicialObject C) {n : \u2115} {\u0394' : SimplexCategory}\n    (i : \u0394' \u27f6 [n]) [hi : Mono i] (h\u2081 : \u0394'.len \u2260 n) (h\u2082 : \u00acIs\u03b4\u2080 i) :\n    PInfty.f n \u226b X.map i.op = 0", "start": [38, 1], "end": [78, 69], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2080_obj_termwise_mapMono_comp_PInfty", "code": "@[reassoc]\ntheorem \u0393\u2080_obj_termwise_mapMono_comp_PInfty (X : SimplicialObject C) {\u0394 \u0394' : SimplexCategory}\n    (i : \u0394 \u27f6 \u0394') [Mono i] :\n    \u0393\u2080.Obj.Termwise.mapMono (AlternatingFaceMapComplex.obj X) i \u226b PInfty.f \u0394.len =\n      PInfty.f \u0394'.len \u226b X.map i.op", "start": [82, 1], "end": [124, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2082N\u2081.natTrans", "code": "@[simps]\ndef natTrans : (N\u2081 : SimplicialObject C \u2964 _) \u22d9 \u0393\u2082 \u27f6 toKaroubi _ where\n  app X :=\n    { f :=\n        { app := fun \u0394 => (\u0393\u2080.splitting K[X]).desc \u0394 fun A => PInfty.f A.1.unop.len \u226b X.map A.e.op\n          naturality := fun \u0394 \u0394' \u03b8 => by\n            apply (\u0393\u2080.splitting K[X]).hom_ext'\n            intro A\n            change _ \u226b (\u0393\u2080.obj K[X]).map \u03b8 \u226b _ = _\n            simp only [Splitting.\u03b9_desc_assoc, assoc, \u0393\u2080.Obj.map_on_summand'_assoc,\n              Splitting.\u03b9_desc]\n            erw [\u0393\u2080_obj_termwise_mapMono_comp_PInfty_assoc X (image.\u03b9 (\u03b8.unop \u226b A.e))]\n            dsimp only [toKaroubi]\n            simp only [\u2190 X.map_comp]\n            congr 2\n            simp only [eqToHom_refl, id_comp, comp_id, \u2190 op_comp]\n            exact Quiver.Hom.unop_inj (A.fac_pull \u03b8) }\n      comm := by\n        apply (\u0393\u2080.splitting K[X]).hom_ext\n        intro n\n        dsimp [N\u2081]\n        simp only [\u2190 Splitting.\u03b9Summand_id, Splitting.\u03b9_desc, comp_id, Splitting.\u03b9_desc_assoc,\n          assoc, PInfty_f_idem_assoc] }\n  naturality {X Y} f := by\n    ext1\n    apply (\u0393\u2080.splitting K[X]).hom_ext\n    intro n\n    dsimp [N\u2081, toKaroubi]\n    simp only [\u2190 Splitting.\u03b9Summand_id, Splitting.\u03b9_desc, Splitting.\u03b9_desc_assoc, assoc,\n      PInfty_f_idem_assoc, Karoubi.comp_f, NatTrans.comp_app, \u0393\u2082_map_f_app,\n      HomologicalComplex.comp_f, AlternatingFaceMapComplex.map_f, PInfty_f_naturality_assoc,\n      NatTrans.naturality, Splitting.IndexSet.id_fst, unop_op, len_mk]", "start": [132, 1], "end": [164, 71], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082", "code": "def compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082 : toKaroubi (SimplicialObject C) \u22d9 N\u2082 \u22d9 \u0393\u2082 \u2245 N\u2081 \u22d9 \u0393\u2082 :=\n  eqToIso (by rw [\u2190 Functor.assoc, compatibility_N\u2081_N\u2082])", "start": [174, 1], "end": [176, 57], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_hom_app", "code": "lemma compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_hom_app (X : SimplicialObject C) :\n    compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.hom.app X =\n      eqToHom (by rw [\u2190 Functor.assoc, compatibility_N\u2081_N\u2082]) := by\n  dsimp only [compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082, CategoryTheory.eqToIso]\n  apply eqToHom_app", "start": [181, 1], "end": [185, 20], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraicTopology.DoldKan.compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_inv_app", "code": "lemma compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_inv_app (X : SimplicialObject C) :\n    compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.inv.app X =\n      eqToHom (by rw [\u2190 Functor.assoc, compatibility_N\u2081_N\u2082]) := by\n  rw [\u2190 cancel_mono (compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.hom.app X), Iso.inv_hom_id_app,\n    compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_hom_app, eqToHom_trans, eqToHom_refl]", "start": [190, 1], "end": [194, 66], "kind": "mathlibtacticlemma"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2082N\u2082.natTrans", "code": "def natTrans : (N\u2082 : Karoubi (SimplicialObject C) \u2964 _) \u22d9 \u0393\u2082 \u27f6 \ud835\udfed _ :=\n  ((whiskeringLeft _ _ _).obj (toKaroubi (SimplicialObject C))).preimage\n    (by exact compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.hom \u226b \u0393\u2082N\u2081.natTrans)", "start": [198, 1], "end": [201, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2082N\u2082.natTrans_app_f_app", "code": "theorem natTrans_app_f_app (P : Karoubi (SimplicialObject C)) :\n    \u0393\u2082N\u2082.natTrans.app P = by\n      exact (N\u2082 \u22d9 \u0393\u2082).map P.decompId_i \u226b\n        (compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.hom \u226b \u0393\u2082N\u2081.natTrans).app P.X \u226b P.decompId_p", "start": [205, 1], "end": [211, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_natTrans", "code": "theorem compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082_natTrans (X : SimplicialObject C) :\n    \u0393\u2082N\u2081.natTrans.app X =\n      (compatibility_\u0393\u2082N\u2081_\u0393\u2082N\u2082.app X).inv \u226b\n        \u0393\u2082N\u2082.natTrans.app ((toKaroubi (SimplicialObject C)).obj X)", "start": [220, 1], "end": [230, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.identity_N\u2082_objectwise", "code": "theorem identity_N\u2082_objectwise (P : Karoubi (SimplicialObject C)) :\n    (N\u2082\u0393\u2082.inv.app (N\u2082.obj P) : N\u2082.obj P \u27f6 N\u2082.obj (\u0393\u2082.obj (N\u2082.obj P))) \u226b\n    N\u2082.map (\u0393\u2082N\u2082.natTrans.app P) = \ud835\udfd9 (N\u2082.obj P)", "start": [232, 1], "end": [251, 72], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.identity_N\u2082", "code": "theorem identity_N\u2082 :\n    (\ud835\udfd9 (N\u2082 : Karoubi (SimplicialObject C) \u2964 _) \u25eb N\u2082\u0393\u2082.inv) \u226b\n    (Functor.associator _ _ _).inv \u226b \u0393\u2082N\u2082.natTrans \u25eb \ud835\udfd9 (@N\u2082 C _ _) = \ud835\udfd9 N\u2082", "start": [256, 1], "end": [262, 81], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2082N\u2082", "code": "@[simps! inv]\ndef \u0393\u2082N\u2082 : \ud835\udfed _ \u2245 (N\u2082 : Karoubi (SimplicialObject C) \u2964 _) \u22d9 \u0393\u2082 :=\n  (asIso \u0393\u2082N\u2082.natTrans).symm", "start": [284, 1], "end": [287, 29], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.\u0393\u2082N\u2081", "code": "@[simps! inv]\ndef \u0393\u2082N\u2081 : toKaroubi _ \u2245 (N\u2081 : SimplicialObject C \u2964 _) \u22d9 \u0393\u2082 :=\n  (asIso \u0393\u2082N\u2081.natTrans).symm", "start": [291, 1], "end": [294, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "imports": ["Mathlib/Algebra/Module/Opposites.lean", "Mathlib/LinearAlgebra/CliffordAlgebra/Grading.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CliffordAlgebra.involute", "code": "def involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q :=\n  CliffordAlgebra.lift Q \u27e8-\u03b9 Q, fun m => by simp\u27e9", "start": [46, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_\u03b9", "code": "@[simp]\ntheorem involute_\u03b9 (m : M) : involute (\u03b9 Q m) = -\u03b9 Q m", "start": [51, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_comp_involute", "code": "@[simp]\ntheorem involute_comp_involute : involute.comp involute = AlgHom.id R (CliffordAlgebra Q)", "start": [56, 1], "end": [58, 12], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_involutive", "code": "theorem involute_involutive : Function.Involutive (involute : _ \u2192 CliffordAlgebra Q)", "start": [61, 1], "end": [62, 42], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_involute", "code": "@[simp]\ntheorem involute_involute : \u2200 a : CliffordAlgebra Q, involute (involute a) = a", "start": [65, 1], "end": [67, 22], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involuteEquiv", "code": "@[simps!]\ndef involuteEquiv : CliffordAlgebra Q \u2243\u2090[R] CliffordAlgebra Q :=\n  AlgEquiv.ofAlgHom involute involute (AlgHom.ext <| involute_involute)\n    (AlgHom.ext <| involute_involute)", "start": [70, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverseOp", "code": "def reverseOp : CliffordAlgebra Q \u2192\u2090[R] (CliffordAlgebra Q)\u1d50\u1d52\u1d56 :=\n  CliffordAlgebra.lift Q\n    \u27e8(MulOpposite.opLinearEquiv R).toLinearMap \u2218\u2097 \u03b9 Q, fun m => unop_injective <| by simp\u27e9", "start": [83, 1], "end": [86, 91], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverseOp_\u03b9", "code": "@[simp]\ntheorem reverseOp_\u03b9 (m : M) : reverseOp (\u03b9 Q m) = op (\u03b9 Q m)", "start": [88, 1], "end": [89, 83], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverseOpEquiv", "code": "@[simps! apply]\ndef reverseOpEquiv : CliffordAlgebra Q \u2243\u2090[R] (CliffordAlgebra Q)\u1d50\u1d52\u1d56 :=\n  AlgEquiv.ofAlgHom reverseOp (AlgHom.opComm reverseOp)\n    (AlgHom.unop.injective <| hom_ext <| LinearMap.ext <| fun _ => by simp)\n    (hom_ext <| LinearMap.ext <| fun _ => by simp)", "start": [91, 1], "end": [96, 51], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverseOpEquiv_opComm", "code": "@[simp]\ntheorem reverseOpEquiv_opComm :\n    AlgEquiv.opComm (reverseOpEquiv (Q := Q)) = reverseOpEquiv.symm", "start": [98, 1], "end": [100, 75], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse", "code": "def reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q :=\n  (opLinearEquiv R).symm.toLinearMap.comp reverseOp.toLinearMap", "start": [102, 1], "end": [105, 64], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.unop_reverseOp", "code": "@[simp] theorem unop_reverseOp (x : CliffordAlgebra Q) : (reverseOp x).unop = reverse x", "start": [108, 1], "end": [108, 95], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.op_reverse", "code": "@[simp] theorem op_reverse (x : CliffordAlgebra Q) : op (reverse x) = reverseOp x", "start": [110, 1], "end": [110, 89], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_\u03b9", "code": "@[simp]\ntheorem reverse_\u03b9 (m : M) : reverse (\u03b9 Q m) = \u03b9 Q m", "start": [112, 1], "end": [113, 73], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse.commutes", "code": "@[simp]\ntheorem reverse.commutes (r : R) :\n    reverse (algebraMap R (CliffordAlgebra Q) r) = algebraMap R _ r", "start": [116, 1], "end": [119, 39], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse.map_one", "code": "@[simp]\ntheorem reverse.map_one : reverse (1 : CliffordAlgebra Q) = 1", "start": [122, 1], "end": [124, 33], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse.map_mul", "code": "@[simp]\ntheorem reverse.map_mul (a b : CliffordAlgebra Q) :\n    reverse (a * b) = reverse b * reverse a", "start": [127, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_involutive", "code": "@[simp]\ntheorem reverse_involutive : Function.Involutive (reverse (Q := Q))", "start": [133, 1], "end": [135, 44], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_comp_reverse", "code": "@[simp]\ntheorem reverse_comp_reverse :\n    reverse.comp reverse = (LinearMap.id : _ \u2192\u2097[R] CliffordAlgebra Q)", "start": [138, 1], "end": [141, 35], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_reverse", "code": "@[simp]\ntheorem reverse_reverse : \u2200 a : CliffordAlgebra Q, reverse (reverse a) = a", "start": [143, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverseEquiv", "code": "@[simps!]\ndef reverseEquiv : CliffordAlgebra Q \u2243\u2097[R] CliffordAlgebra Q :=\n  LinearEquiv.ofInvolutive reverse reverse_involutive", "start": [148, 1], "end": [151, 54], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_comp_involute", "code": "theorem reverse_comp_involute :\n    reverse.comp involute.toLinearMap =\n      (involute.toLinearMap.comp reverse : _ \u2192\u2097[R] CliffordAlgebra Q)", "start": [154, 1], "end": [163, 78], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_involute_commute", "code": "theorem reverse_involute_commute : Function.Commute (reverse (Q := Q)) involute", "start": [166, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_involute", "code": "theorem reverse_involute :\n    \u2200 a : CliffordAlgebra Q, reverse (involute a) = involute (reverse a)", "start": [172, 1], "end": [174, 27], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_prod_map_\u03b9", "code": "theorem reverse_prod_map_\u03b9 :\n    \u2200 l : List M, reverse (l.map <| \u03b9 Q).prod = (l.map <| \u03b9 Q).reverse.prod", "start": [186, 1], "end": [191, 45], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_prod_map_\u03b9", "code": "theorem involute_prod_map_\u03b9 :\n    \u2200 l : List M, involute (l.map <| \u03b9 Q).prod = (-1 : R) ^ l.length \u2022 (l.map <| \u03b9 Q).prod", "start": [194, 1], "end": [199, 56], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_map_involute_eq_comap", "code": "theorem submodule_map_involute_eq_comap (p : Submodule R (CliffordAlgebra Q)) :\n    p.map (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap =\n      p.comap (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap", "start": [215, 1], "end": [218, 66], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.\u03b9_range_map_involute", "code": "@[simp]\ntheorem \u03b9_range_map_involute :\n    (\u03b9 Q).range.map (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap =\n      LinearMap.range (\u03b9 Q)", "start": [221, 1], "end": [225, 55], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.\u03b9_range_comap_involute", "code": "@[simp]\ntheorem \u03b9_range_comap_involute :\n    (\u03b9 Q).range.comap (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap =\n      LinearMap.range (\u03b9 Q)", "start": [228, 1], "end": [232, 66], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenOdd_map_involute", "code": "@[simp]\ntheorem evenOdd_map_involute (n : ZMod 2) :\n    (evenOdd Q n).map (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap =\n      evenOdd Q n", "start": [235, 1], "end": [239, 84], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenOdd_comap_involute", "code": "@[simp]\ntheorem evenOdd_comap_involute (n : ZMod 2) :\n    (evenOdd Q n).comap (involute : CliffordAlgebra Q \u2192\u2090[R] CliffordAlgebra Q).toLinearMap =\n      evenOdd Q n", "start": [242, 1], "end": [246, 66], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_map_reverse_eq_comap", "code": "theorem submodule_map_reverse_eq_comap (p : Submodule R (CliffordAlgebra Q)) :\n    p.map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) =\n      p.comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q)", "start": [253, 1], "end": [256, 65], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.\u03b9_range_map_reverse", "code": "@[simp]\ntheorem \u03b9_range_map_reverse :\n    (\u03b9 Q).range.map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q)\n      = LinearMap.range (\u03b9 Q)", "start": [259, 1], "end": [265, 27], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.\u03b9_range_comap_reverse", "code": "@[simp]\ntheorem \u03b9_range_comap_reverse :\n    (\u03b9 Q).range.comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q)\n      = LinearMap.range (\u03b9 Q)", "start": [268, 1], "end": [272, 61], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_map_mul_reverse", "code": "theorem submodule_map_mul_reverse (p q : Submodule R (CliffordAlgebra Q)) :\n    (p * q).map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) =\n      q.map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) *\n        p.map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q)", "start": [275, 1], "end": [280, 83], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_comap_mul_reverse", "code": "theorem submodule_comap_mul_reverse (p q : Submodule R (CliffordAlgebra Q)) :\n    (p * q).comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) =\n      q.comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) *\n        p.comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q)", "start": [283, 1], "end": [287, 75], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_map_pow_reverse", "code": "theorem submodule_map_pow_reverse (p : Submodule R (CliffordAlgebra Q)) (n : \u2115) :\n    (p ^ n).map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) =\n      p.map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) ^ n", "start": [290, 1], "end": [294, 83], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.submodule_comap_pow_reverse", "code": "theorem submodule_comap_pow_reverse (p : Submodule R (CliffordAlgebra Q)) (n : \u2115) :\n    (p ^ n).comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) =\n      p.comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) ^ n", "start": [297, 1], "end": [300, 75], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenOdd_map_reverse", "code": "@[simp]\ntheorem evenOdd_map_reverse (n : ZMod 2) :\n    (evenOdd Q n).map (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) = evenOdd Q n", "start": [303, 1], "end": [306, 88], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.evenOdd_comap_reverse", "code": "@[simp]\ntheorem evenOdd_comap_reverse (n : ZMod 2) :\n    (evenOdd Q n).comap (reverse : CliffordAlgebra Q \u2192\u2097[R] CliffordAlgebra Q) = evenOdd Q n", "start": [309, 1], "end": [312, 61], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_mem_evenOdd_iff", "code": "@[simp]\ntheorem involute_mem_evenOdd_iff {x : CliffordAlgebra Q} {n : ZMod 2} :\n    involute x \u2208 evenOdd Q n \u2194 x \u2208 evenOdd Q n", "start": [317, 1], "end": [320, 52], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.reverse_mem_evenOdd_iff", "code": "@[simp]\ntheorem reverse_mem_evenOdd_iff {x : CliffordAlgebra Q} {n : ZMod 2} :\n    reverse x \u2208 evenOdd Q n \u2194 x \u2208 evenOdd Q n", "start": [323, 1], "end": [326, 51], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_eq_of_mem_even", "code": "theorem involute_eq_of_mem_even {x : CliffordAlgebra Q} (h : x \u2208 evenOdd Q 0) : involute x = x", "start": [338, 1], "end": [343, 68], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.involute_eq_of_mem_odd", "code": "theorem involute_eq_of_mem_odd {x : CliffordAlgebra Q} (h : x \u2208 evenOdd Q 1) : involute x = -x", "start": [346, 1], "end": [351, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/RingTheory/NonUnitalSubsemiring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonUnitalSubringClass", "code": "class NonUnitalSubringClass (S : Type*) (R : Type u) [NonUnitalNonAssocRing R]\n    [SetLike S R] extends NonUnitalSubsemiringClass S R, NegMemClass S R : Prop where", "start": [79, 1], "end": [82, 86], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.addSubgroupClass", "code": "instance (priority := 100) NonUnitalSubringClass.addSubgroupClass (S : Type*) (R : Type u)\n    [SetLike S R] [NonUnitalNonAssocRing R] [h : NonUnitalSubringClass S R] :\n    AddSubgroupClass S R :=\n  { h with }", "start": [85, 1], "end": [88, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.toNonUnitalNonAssocRing", "code": "instance (priority := 75) toNonUnitalNonAssocRing : NonUnitalNonAssocRing s :=\n  Subtype.val_injective.nonUnitalNonAssocRing _ rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [95, 1], "end": [98, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.toNonUnitalRing", "code": "instance (priority := 75) toNonUnitalRing {R : Type*} [NonUnitalRing R] [SetLike S R]\n    [NonUnitalSubringClass S R] (s : S) : NonUnitalRing s :=\n  Subtype.val_injective.nonUnitalRing _ rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [101, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.toNonUnitalCommRing", "code": "instance (priority := 75) toNonUnitalCommRing {R} [NonUnitalCommRing R] [SetLike S R]\n    [NonUnitalSubringClass S R] : NonUnitalCommRing s :=\n  Subtype.val_injective.nonUnitalCommRing _ rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [108, 1], "end": [112, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.subtype", "code": "def subtype (s : S) : s \u2192\u2099+* R :=\n  { NonUnitalSubsemiringClass.subtype s,\n    AddSubgroupClass.subtype s with\n    toFun := Subtype.val }", "start": [114, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubringClass.coe_subtype", "code": "@[simp]\ntheorem coe_subtype : (subtype s : s \u2192 R) = Subtype.val", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring", "code": "structure NonUnitalSubring (R : Type u) [NonUnitalNonAssocRing R] extends\n  NonUnitalSubsemiring R, AddSubgroup R", "start": [130, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubsemigroup", "code": "def toSubsemigroup (s : NonUnitalSubring R) : Subsemigroup R :=\n  { s.toNonUnitalSubsemiring.toSubsemigroup with carrier := s.carrier }", "start": [144, 1], "end": [146, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_carrier", "code": "theorem mem_carrier {s : NonUnitalSubring R} {x : R} : x \u2208 s.toNonUnitalSubsemiring \u2194 x \u2208 s", "start": [160, 1], "end": [161, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_mk", "code": "@[simp]\ntheorem mem_mk {S : NonUnitalSubsemiring R} {x : R} (h) :\n    x \u2208 (\u27e8S, h\u27e9 : NonUnitalSubring R) \u2194 x \u2208 S", "start": [163, 1], "end": [166, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_set_mk", "code": "@[simp]\ntheorem coe_set_mk (S : NonUnitalSubsemiring R) (h) :\n    ((\u27e8S, h\u27e9 : NonUnitalSubring R) : Set R) = S", "start": [168, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk {S S' : NonUnitalSubsemiring R} (h h') :\n    (\u27e8S, h\u27e9 : NonUnitalSubring R) \u2264 (\u27e8S', h'\u27e9 : NonUnitalSubring R) \u2194 S \u2264 S'", "start": [173, 1], "end": [176, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.ext", "code": "@[ext]\ntheorem ext {S T : NonUnitalSubring R} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [178, 1], "end": [181, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.copy", "code": "protected def copy (S : NonUnitalSubring R) (s : Set R) (hs : s = \u2191S) : NonUnitalSubring R :=\n  { S.toNonUnitalSubsemiring.copy s hs with\n    carrier := s\n    neg_mem' := hs.symm \u25b8 S.neg_mem' }", "start": [183, 1], "end": [188, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : NonUnitalSubring R) (s : Set R) (hs : s = \u2191S) : (S.copy s hs : Set R) = s", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.copy_eq", "code": "theorem copy_eq (S : NonUnitalSubring R) (s : Set R) (hs : s = \u2191S) : S.copy s hs = S", "start": [194, 1], "end": [195, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toNonUnitalSubsemiring_injective", "code": "theorem toNonUnitalSubsemiring_injective :\n    Function.Injective (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R)", "start": [197, 1], "end": [199, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toNonUnitalSubsemiring_strictMono", "code": "@[mono]\ntheorem toNonUnitalSubsemiring_strictMono :\n    StrictMono (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R)", "start": [201, 1], "end": [204, 5], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toNonUnitalSubsemiring_mono", "code": "@[mono]\ntheorem toNonUnitalSubsemiring_mono :\n    Monotone (toNonUnitalSubsemiring : NonUnitalSubring R \u2192 NonUnitalSubsemiring R)", "start": [206, 1], "end": [209, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toAddSubgroup_injective", "code": "theorem toAddSubgroup_injective :\n    Function.Injective (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R)", "start": [211, 1], "end": [213, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toAddSubgroup_strictMono", "code": "@[mono]\ntheorem toAddSubgroup_strictMono :\n    StrictMono (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R)", "start": [215, 1], "end": [217, 85], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toAddSubgroup_mono", "code": "@[mono]\ntheorem toAddSubgroup_mono : Monotone (toAddSubgroup : NonUnitalSubring R \u2192 AddSubgroup R)", "start": [219, 1], "end": [221, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubsemigroup_injective", "code": "theorem toSubsemigroup_injective :\n    Function.Injective (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R)", "start": [223, 1], "end": [225, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubsemigroup_strictMono", "code": "@[mono]\ntheorem toSubsemigroup_strictMono :\n    StrictMono (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R)", "start": [227, 1], "end": [229, 87], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toSubsemigroup_mono", "code": "@[mono]\ntheorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubring R \u2192 Subsemigroup R)", "start": [231, 1], "end": [233, 37], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mk'", "code": "protected def mk' (s : Set R) (sm : Subsemigroup R) (sa : AddSubgroup R) (hm : \u2191sm = s)\n    (ha : \u2191sa = s) : NonUnitalSubring R :=\n  { sm.copy s hm.symm, sa.copy s ha.symm with }", "start": [235, 1], "end": [239, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_mk'", "code": "@[simp]\ntheorem coe_mk' {s : Set R} {sm : Subsemigroup R} (hm : \u2191sm = s) {sa : AddSubgroup R}\n    (ha : \u2191sa = s) : (NonUnitalSubring.mk' s sm sa hm ha : Set R) = s", "start": [241, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_mk'", "code": "@[simp]\ntheorem mem_mk' {s : Set R} {sm : Subsemigroup R} (hm : \u2191sm = s) {sa : AddSubgroup R} (ha : \u2191sa = s)\n    {x : R} : x \u2208 NonUnitalSubring.mk' s sm sa hm ha \u2194 x \u2208 s", "start": [246, 1], "end": [249, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mk'_toSubsemigroup", "code": "@[simp]\ntheorem mk'_toSubsemigroup {s : Set R} {sm : Subsemigroup R} (hm : \u2191sm = s) {sa : AddSubgroup R}\n    (ha : \u2191sa = s) : (NonUnitalSubring.mk' s sm sa hm ha).toSubsemigroup = sm", "start": [251, 1], "end": [254, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mk'_toAddSubgroup", "code": "@[simp]\ntheorem mk'_toAddSubgroup {s : Set R} {sm : Subsemigroup R} (hm : \u2191sm = s) {sa : AddSubgroup R}\n    (ha : \u2191sa = s) : (NonUnitalSubring.mk' s sm sa hm ha).toAddSubgroup = sa", "start": [256, 1], "end": [259, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.zero_mem", "code": "protected theorem zero_mem : (0 : R) \u2208 s", "start": [267, 1], "end": [269, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mul_mem", "code": "protected theorem mul_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x * y \u2208 s", "start": [271, 1], "end": [273, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.add_mem", "code": "protected theorem add_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x + y \u2208 s", "start": [275, 1], "end": [277, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.neg_mem", "code": "protected theorem neg_mem {x : R} : x \u2208 s \u2192 -x \u2208 s", "start": [279, 1], "end": [281, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.sub_mem", "code": "protected theorem sub_mem {x y : R} (hx : x \u2208 s) (hy : y \u2208 s) : x - y \u2208 s", "start": [283, 1], "end": [285, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.list_sum_mem", "code": "protected theorem list_sum_mem {l : List R} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s", "start": [287, 1], "end": [289, 15], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.multiset_sum_mem", "code": "protected theorem multiset_sum_mem {R} [NonUnitalNonAssocRing R] (s : NonUnitalSubring R)\n    (m : Multiset R) : (\u2200 a \u2208 m, a \u2208 s) \u2192 m.sum \u2208 s", "start": [291, 1], "end": [295, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.sum_mem", "code": "protected theorem sum_mem {R : Type*} [NonUnitalNonAssocRing R] (s : NonUnitalSubring R)\n    {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 R} (h : \u2200 c \u2208 t, f c \u2208 s) : (\u2211 i in t, f i) \u2208 s", "start": [297, 1], "end": [301, 12], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toNonUnitalRing", "code": "instance toNonUnitalRing {R : Type*} [NonUnitalRing R] (s : NonUnitalSubring R) :\n    NonUnitalRing s :=\n  Subtype.coe_injective.nonUnitalRing _ rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [303, 1], "end": [307, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.zsmul_mem", "code": "protected theorem zsmul_mem {x : R} (hx : x \u2208 s) (n : \u2124) : n \u2022 x \u2208 s", "start": [309, 1], "end": [310, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.val_add", "code": "@[simp, norm_cast]\ntheorem val_add (x y : s) : (\u2191(x + y) : R) = \u2191x + \u2191y", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.val_neg", "code": "@[simp, norm_cast]\ntheorem val_neg (x : s) : (\u2191(-x) : R) = -\u2191x", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.val_mul", "code": "@[simp, norm_cast]\ntheorem val_mul (x y : s) : (\u2191(x * y) : R) = \u2191x * \u2191y", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.val_zero", "code": "@[simp, norm_cast]\ntheorem val_zero : ((0 : s) : R) = 0", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_eq_zero_iff", "code": "theorem coe_eq_zero_iff {x : s} : (x : R) = 0 \u2194 x = 0", "start": [328, 1], "end": [329, 7], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.toNonUnitalCommRing", "code": "instance toNonUnitalCommRing {R} [NonUnitalCommRing R] (s : NonUnitalSubring R) :\n    NonUnitalCommRing s :=\n  Subtype.coe_injective.nonUnitalCommRing _ rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [331, 1], "end": [335, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_toSubsemigroup", "code": "@[simp]\ntheorem mem_toSubsemigroup {s : NonUnitalSubring R} {x : R} : x \u2208 s.toSubsemigroup \u2194 x \u2208 s", "start": [340, 1], "end": [342, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_toSubsemigroup", "code": "@[simp]\ntheorem coe_toSubsemigroup (s : NonUnitalSubring R) : (s.toSubsemigroup : Set R) = s", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_toAddSubgroup", "code": "@[simp]\ntheorem mem_toAddSubgroup {s : NonUnitalSubring R} {x : R} : x \u2208 s.toAddSubgroup \u2194 x \u2208 s", "start": [348, 1], "end": [350, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_toAddSubgroup", "code": "@[simp]\ntheorem coe_toAddSubgroup (s : NonUnitalSubring R) : (s.toAddSubgroup : Set R) = s", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem mem_toNonUnitalSubsemiring {s : NonUnitalSubring R} {x : R} :\n    x \u2208 s.toNonUnitalSubsemiring \u2194 x \u2208 s", "start": [356, 1], "end": [359, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem coe_toNonUnitalSubsemiring (s : NonUnitalSubring R) :\n    (s.toNonUnitalSubsemiring : Set R) = s", "start": [361, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_top", "code": "@[simp]\ntheorem mem_top (x : R) : x \u2208 (\u22a4 : NonUnitalSubring R)", "start": [373, 1], "end": [375, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : NonUnitalSubring R) : Set R) = Set.univ", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.topEquiv", "code": "@[simps!]\ndef topEquiv : (\u22a4 : NonUnitalSubring R) \u2243+* R := NonUnitalSubsemiring.topEquiv", "start": [381, 1], "end": [383, 79], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap", "code": "def comap {F : Type w} {R : Type u} {S : Type v} [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S]\n    [NonUnitalRingHomClass F R S] (f : F) (s : NonUnitalSubring S) : NonUnitalSubring R :=\n  { s.toSubsemigroup.comap (f : R \u2192\u2099* S), s.toAddSubgroup.comap (f : R \u2192+ S) with\n    carrier := f \u207b\u00b9' s.carrier }", "start": [400, 1], "end": [404, 33], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_comap", "code": "@[simp]\ntheorem coe_comap (s : NonUnitalSubring S) (f : F) : (s.comap f : Set R) = f \u207b\u00b9' s", "start": [406, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_comap", "code": "@[simp]\ntheorem mem_comap {s : NonUnitalSubring S} {f : F} {x : R} : x \u2208 s.comap f \u2194 f x \u2208 s", "start": [410, 1], "end": [412, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap_comap", "code": "theorem comap_comap (s : NonUnitalSubring T) (g : S \u2192\u2099+* T) (f : R \u2192\u2099+* S) :\n    (s.comap g).comap f = s.comap (g.comp f)", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map", "code": "def map {F : Type w} {R : Type u} {S : Type v} [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S]\n    [NonUnitalRingHomClass F R S] (f : F) (s : NonUnitalSubring R) : NonUnitalSubring S :=\n  { s.toSubsemigroup.map (f : R \u2192\u2099* S), s.toAddSubgroup.map (f : R \u2192+ S) with\n    carrier := f '' s.carrier }", "start": [420, 1], "end": [424, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_map", "code": "@[simp]\ntheorem coe_map (f : F) (s : NonUnitalSubring R) : (s.map f : Set S) = f '' s", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_map", "code": "@[simp]\ntheorem mem_map {f : F} {s : NonUnitalSubring R} {y : S} : y \u2208 s.map f \u2194 \u2203 x \u2208 s, f x = y", "start": [430, 1], "end": [432, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_id", "code": "@[simp]\ntheorem map_id : s.map (NonUnitalRingHom.id R) = s", "start": [434, 1], "end": [436, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_map", "code": "theorem map_map (g : S \u2192\u2099+* T) (f : R \u2192\u2099+* S) : (s.map f).map g = s.map (g.comp f)", "start": [438, 1], "end": [439, 49], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : F} {s : NonUnitalSubring R} {t : NonUnitalSubring S} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f", "start": [441, 1], "end": [443, 23], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.gc_map_comap", "code": "theorem gc_map_comap (f : F) :\n    GaloisConnection (map f : NonUnitalSubring R \u2192 NonUnitalSubring S) (comap f)", "start": [445, 1], "end": [447, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.equivMapOfInjective", "code": "noncomputable def equivMapOfInjective (f : F) (hf : Function.Injective (f : R \u2192 S)) :\n    s \u2243+* s.map f :=\n  {\n    Equiv.Set.image f s\n      hf with\n    map_mul' := fun _ _ => Subtype.ext (map_mul f _ _)\n    map_add' := fun _ _ => Subtype.ext (map_add f _ _) }", "start": [449, 1], "end": [456, 57], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_equivMapOfInjective_apply", "code": "@[simp]\ntheorem coe_equivMapOfInjective_apply (f : F) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x", "start": [458, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.range", "code": "def range {R : Type u} {S : Type v} [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S]\n    (f : R \u2192\u2099+* S) : NonUnitalSubring S :=\n  ((\u22a4 : NonUnitalSubring R).map f).copy (Set.range f) Set.image_univ.symm", "start": [473, 1], "end": [477, 74], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_range", "code": "@[simp]\ntheorem coe_range : (f.range : Set S) = Set.range f", "start": [479, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.mem_range", "code": "@[simp]\ntheorem mem_range {f : R \u2192\u2099+* S} {y : S} : y \u2208 f.range \u2194 \u2203 x, f x = y", "start": [483, 1], "end": [485, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.range_eq_map", "code": "theorem range_eq_map (f : R \u2192\u2099+* S) : f.range = NonUnitalSubring.map f \u22a4", "start": [487, 1], "end": [487, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.mem_range_self", "code": "theorem mem_range_self (f : R \u2192\u2099+* S) (x : R) : f x \u2208 f.range", "start": [489, 1], "end": [490, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.map_range", "code": "theorem map_range : f.range.map g = (g.comp f).range", "start": [492, 1], "end": [493, 71], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.fintypeRange", "code": "instance fintypeRange [Fintype R] [DecidableEq S] (f : R \u2192\u2099+* S) : Fintype (range f) :=\n  Set.fintypeRange f", "start": [495, 1], "end": [499, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_bot", "code": "theorem coe_bot : ((\u22a5 : NonUnitalSubring R) : Set R) = {0}", "start": [521, 1], "end": [522, 79], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_bot", "code": "theorem mem_bot {x : R} : x \u2208 (\u22a5 : NonUnitalSubring R) \u2194 x = 0", "start": [524, 1], "end": [525, 93], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_inf", "code": "@[simp]\ntheorem coe_inf (p p' : NonUnitalSubring R) :\n    ((p \u2293 p' : NonUnitalSubring R) : Set R) = (p : Set R) \u2229 p'", "start": [535, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_inf", "code": "@[simp]\ntheorem mem_inf {p p' : NonUnitalSubring R} {x : R} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [540, 1], "end": [542, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (NonUnitalSubring R)) :\n    ((sInf S : NonUnitalSubring R) : Set R) = \u22c2 s \u2208 S, \u2191s", "start": [549, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_sInf", "code": "theorem mem_sInf {S : Set (NonUnitalSubring R)} {x : R} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [554, 1], "end": [555, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubring R} : (\u2191(\u2a05 i, S i) : Set R) = \u22c2 i, S i", "start": [557, 1], "end": [559, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubring R} {x : R} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [561, 1], "end": [562, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.sInf_toSubsemigroup", "code": "@[simp]\ntheorem sInf_toSubsemigroup (s : Set (NonUnitalSubring R)) :\n    (sInf s).toSubsemigroup = \u2a05 t \u2208 s, NonUnitalSubring.toSubsemigroup t", "start": [564, 1], "end": [567, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.sInf_toAddSubgroup", "code": "@[simp]\ntheorem sInf_toAddSubgroup (s : Set (NonUnitalSubring R)) :\n    (sInf s).toAddSubgroup = \u2a05 t \u2208 s, NonUnitalSubring.toAddSubgroup t", "start": [569, 1], "end": [572, 24], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.eq_top_iff'", "code": "theorem eq_top_iff' (A : NonUnitalSubring R) : A = \u22a4 \u2194 \u2200 x : R, x \u2208 A", "start": [588, 1], "end": [589, 65], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.center", "code": "def center : NonUnitalSubring R :=\n  { NonUnitalSubsemiring.center R with\n    carrier := Set.center R\n    neg_mem' := Set.neg_mem_center }", "start": [601, 1], "end": [605, 37], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_center", "code": "theorem coe_center : \u2191(center R) = Set.center R", "start": [607, 1], "end": [608, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.center_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem center_toNonUnitalSubsemiring :\n    (center R).toNonUnitalSubsemiring = NonUnitalSubsemiring.center R", "start": [610, 1], "end": [613, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_center_iff", "code": "theorem mem_center_iff {z : R} : z \u2208 center R \u2194 \u2200 g, g * z = z * g", "start": [617, 1], "end": [618, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.decidableMemCenter", "code": "instance decidableMemCenter [DecidableEq R] [Fintype R] : DecidablePred (\u00b7 \u2208 center R) := fun _ =>\n  decidable_of_iff' _ mem_center_iff", "start": [620, 1], "end": [621, 37], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (R) [NonUnitalCommRing R] : center R = \u22a4", "start": [623, 1], "end": [625, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.center.instNonUnitalCommRing", "code": "instance center.instNonUnitalCommRing : NonUnitalCommRing (center R) :=\n  { NonUnitalSubsemiring.center.instNonUnitalCommSemiring,\n    (center R).toNonUnitalRing with }", "start": [627, 1], "end": [630, 38], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure", "code": "def closure (s : Set R) : NonUnitalSubring R :=\n  sInf {S | s \u2286 S}", "start": [641, 1], "end": [643, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_closure", "code": "theorem mem_closure {x : R} {s : Set R} : x \u2208 closure s \u2194 \u2200 S : NonUnitalSubring R, s \u2286 S \u2192 x \u2208 S", "start": [645, 1], "end": [646, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.subset_closure", "code": "@[simp, aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_closure {s : Set R} : s \u2286 closure s", "start": [648, 1], "end": [650, 100], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P \u2209 closure s) : P \u2209 s", "start": [652, 1], "end": [653, 24], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_le", "code": "@[simp]\ntheorem closure_le {s : Set R} {t : NonUnitalSubring R} : closure s \u2264 t \u2194 s \u2286 t", "start": [655, 1], "end": [658, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_mono", "code": "theorem closure_mono \u2983s t : Set R\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [660, 1], "end": [663, 52], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_eq_of_le", "code": "theorem closure_eq_of_le {s : Set R} {t : NonUnitalSubring R} (h\u2081 : s \u2286 t) (h\u2082 : t \u2264 closure s) :\n    closure s = t", "start": [665, 1], "end": [667, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_induction", "code": "@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x)\n    (H0 : p 0) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (Hneg : \u2200 x : R, p x \u2192 p (-x))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [669, 1], "end": [676, 71], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_induction'", "code": "@[elab_as_elim]\ntheorem closure_induction' {s : Set R} {p : closure s \u2192 Prop} (a : closure s)\n    (Hs : \u2200 (x) (hx : x \u2208 s), p \u27e8x, subset_closure hx\u27e9) (H0 : p 0)\n    (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (Hneg : \u2200 x, p x \u2192 p (-x))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p a", "start": [678, 1], "end": [695, 46], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_induction\u2082", "code": "@[elab_as_elim]\ntheorem closure_induction\u2082 {s : Set R} {p : R \u2192 R \u2192 Prop} {a b : R} (ha : a \u2208 closure s)\n    (hb : b \u2208 closure s) (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (H0_left : \u2200 x, p 0 x)\n    (H0_right : \u2200 x, p x 0) (Hneg_left : \u2200 x y, p x y \u2192 p (-x) y)\n    (Hneg_right : \u2200 x y, p x y \u2192 p x (-y)) (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)) : p a b", "start": [697, 1], "end": [710, 68], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_closure_iff", "code": "theorem mem_closure_iff {s : Set R} {x} :\n    x \u2208 closure s \u2194 x \u2208 AddSubgroup.closure (Subsemigroup.closure s : Set R)", "start": [712, 1], "end": [737, 76], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closureNonUnitalCommRingOfComm", "code": "def closureNonUnitalCommRingOfComm {R : Type u} [NonUnitalRing R] {s : Set R}\n    (hcomm : \u2200 a \u2208 s, \u2200 b \u2208 s, a * b = b * a) : NonUnitalCommRing (closure s) :=\n  { (closure s).toNonUnitalRing with\n    mul_comm := fun x y => by\n      ext\n      simp only [NonUnitalSubring.val_mul]\n      refine'\n        closure_induction\u2082 x.prop y.prop hcomm\n          (fun x => by simp only [mul_zero, zero_mul])\n          (fun x => by simp only [mul_zero, zero_mul])\n          (fun x y hxy => by simp only [mul_neg, neg_mul, hxy])\n          (fun x y hxy => by simp only [mul_neg, neg_mul, hxy])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by rw [\u2190 mul_assoc, \u2190 h\u2081, mul_assoc x\u2081 y x\u2082, \u2190 h\u2082, mul_assoc])\n          fun x\u2081 x\u2082 y h\u2081 h\u2082 => by rw [\u2190 mul_assoc, h\u2081, mul_assoc, h\u2082, \u2190 mul_assoc] }", "start": [739, 1], "end": [755, 85], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.gi", "code": "protected def gi : GaloisInsertion (@closure R _) SetLike.coe\n    where\n  choice s _ := closure s\n  gc _s _t := closure_le\n  le_l_u _s := subset_closure\n  choice_eq _s _h := rfl", "start": [759, 1], "end": [765, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_eq", "code": "theorem closure_eq (s : NonUnitalSubring R) : closure (s : Set R) = s", "start": [769, 1], "end": [771, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_empty", "code": "@[simp]\ntheorem closure_empty : closure (\u2205 : Set R) = \u22a5", "start": [773, 1], "end": [775, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_univ", "code": "@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = \u22a4", "start": [777, 1], "end": [779, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_union", "code": "theorem closure_union (s t : Set R) : closure (s \u222a t) = closure s \u2294 closure t", "start": [781, 1], "end": [782, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_iUnion", "code": "theorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set R) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [784, 1], "end": [785, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_sUnion", "code": "theorem closure_sUnion (s : Set (Set R)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t", "start": [787, 1], "end": [788, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_sup", "code": "theorem map_sup (s t : NonUnitalSubring R) (f : F) : (s \u2294 t).map f = s.map f \u2294 t.map f", "start": [790, 1], "end": [791, 38], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_iSup", "code": "theorem map_iSup {\u03b9 : Sort*} (f : F) (s : \u03b9 \u2192 NonUnitalSubring R) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [793, 1], "end": [795, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap_inf", "code": "theorem comap_inf (s t : NonUnitalSubring S) (f : F) : (s \u2293 t).comap f = s.comap f \u2293 t.comap f", "start": [797, 1], "end": [798, 38], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap_iInf", "code": "theorem comap_iInf {\u03b9 : Sort*} (f : F) (s : \u03b9 \u2192 NonUnitalSubring S) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [800, 1], "end": [802, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_bot", "code": "@[simp]\ntheorem map_bot (f : R \u2192\u2099+* S) : (\u22a5 : NonUnitalSubring R).map f = \u22a5", "start": [804, 1], "end": [806, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap_top", "code": "@[simp]\ntheorem comap_top (f : R \u2192\u2099+* S) : (\u22a4 : NonUnitalSubring S).comap f = \u22a4", "start": [808, 1], "end": [810, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prod", "code": "def prod (s : NonUnitalSubring R) (t : NonUnitalSubring S) : NonUnitalSubring (R \u00d7 S) :=\n  { s.toSubsemigroup.prod t.toSubsemigroup, s.toAddSubgroup.prod t.toAddSubgroup with\n    carrier := s \u00d7\u02e2 t }", "start": [812, 1], "end": [816, 24], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod (s : NonUnitalSubring R) (t : NonUnitalSubring S) :\n    (s.prod t : Set (R \u00d7 S)) = (s : Set R) \u00d7\u02e2 t", "start": [818, 1], "end": [821, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_prod", "code": "theorem mem_prod {s : NonUnitalSubring R} {t : NonUnitalSubring S} {p : R \u00d7 S} :\n    p \u2208 s.prod t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [823, 1], "end": [825, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prod_mono", "code": "@[mono]\ntheorem prod_mono \u2983s\u2081 s\u2082 : NonUnitalSubring R\u2984 (hs : s\u2081 \u2264 s\u2082) \u2983t\u2081 t\u2082 : NonUnitalSubring S\u2984\n    (ht : t\u2081 \u2264 t\u2082) : s\u2081.prod t\u2081 \u2264 s\u2082.prod t\u2082", "start": [827, 1], "end": [830, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prod_mono_right", "code": "theorem prod_mono_right (s : NonUnitalSubring R) :\n    Monotone fun t : NonUnitalSubring S => s.prod t", "start": [832, 1], "end": [834, 24], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prod_mono_left", "code": "theorem prod_mono_left (t : NonUnitalSubring S) : Monotone fun s : NonUnitalSubring R => s.prod t", "start": [836, 1], "end": [837, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prod_top", "code": "theorem prod_top (s : NonUnitalSubring R) :\n    s.prod (\u22a4 : NonUnitalSubring S) = s.comap (NonUnitalRingHom.fst R S)", "start": [839, 1], "end": [841, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.top_prod", "code": "theorem top_prod (s : NonUnitalSubring S) :\n    (\u22a4 : NonUnitalSubring R).prod s = s.comap (NonUnitalRingHom.snd R S)", "start": [843, 1], "end": [845, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.top_prod_top", "code": "@[simp]\ntheorem top_prod_top : (\u22a4 : NonUnitalSubring R).prod (\u22a4 : NonUnitalSubring S) = \u22a4", "start": [847, 1], "end": [849, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.prodEquiv", "code": "def prodEquiv (s : NonUnitalSubring R) (t : NonUnitalSubring S) : s.prod t \u2243+* s \u00d7 t :=\n  { Equiv.Set.prod (s : Set R) (t : Set S) with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [851, 1], "end": [855, 33], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_iSup_of_directed", "code": "theorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 NonUnitalSubring R}\n    (hS : Directed (\u00b7 \u2264 \u00b7) S) {x : R} : (x \u2208 \u2a06 i, S i) \u2194 \u2203 i, x \u2208 S i", "start": [857, 1], "end": [868, 55], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 NonUnitalSubring R}\n    (hS : Directed (\u00b7 \u2264 \u00b7) S) : ((\u2a06 i, S i : NonUnitalSubring R) : Set R) = \u22c3 i, \u2191(S i)", "start": [870, 1], "end": [872, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_sSup_of_directedOn", "code": "theorem mem_sSup_of_directedOn {S : Set (NonUnitalSubring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) {x : R} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "start": [874, 1], "end": [878, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.coe_sSup_of_directedOn", "code": "theorem coe_sSup_of_directedOn {S : Set (NonUnitalSubring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) : (\u2191(sSup S) : Set R) = \u22c3 s \u2208 S, \u2191s", "start": [880, 1], "end": [882, 59], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.mem_map_equiv", "code": "theorem mem_map_equiv {f : R \u2243+* S} {K : NonUnitalSubring R} {x : S} :\n    x \u2208 K.map (f : R \u2192\u2099+* S) \u2194 f.symm x \u2208 K", "start": [884, 1], "end": [886, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.map_equiv_eq_comap_symm", "code": "theorem map_equiv_eq_comap_symm (f : R \u2243+* S) (K : NonUnitalSubring R) :\n    K.map (f : R \u2192\u2099+* S) = K.comap f.symm", "start": [888, 1], "end": [890, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.comap_equiv_eq_map_symm", "code": "theorem comap_equiv_eq_map_symm (f : R \u2243+* S) (K : NonUnitalSubring S) :\n    K.comap (f : R \u2192\u2099+* S) = K.map f.symm", "start": [892, 1], "end": [894, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.rangeRestrict", "code": "def rangeRestrict (f : R \u2192\u2099+* S) : R \u2192\u2099+* f.range :=\n  NonUnitalRingHom.codRestrict f f.range fun x => \u27e8x, rfl\u27e9", "start": [908, 1], "end": [912, 59], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_rangeRestrict", "code": "@[simp]\ntheorem coe_rangeRestrict (f : R \u2192\u2099+* S) (x : R) : (f.rangeRestrict x : S) = f x", "start": [914, 1], "end": [916, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.rangeRestrict_surjective", "code": "theorem rangeRestrict_surjective (f : R \u2192\u2099+* S) : Function.Surjective f.rangeRestrict", "start": [918, 1], "end": [921, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.range_top_iff_surjective", "code": "theorem range_top_iff_surjective {f : R \u2192\u2099+* S} :\n    f.range = (\u22a4 : NonUnitalSubring S) \u2194 Function.Surjective f", "start": [923, 1], "end": [925, 92], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.range_top_of_surjective", "code": "@[simp]\ntheorem range_top_of_surjective (f : R \u2192\u2099+* S) (hf : Function.Surjective f) :\n    f.range = (\u22a4 : NonUnitalSubring S)", "start": [927, 1], "end": [931, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.eqLocus", "code": "def eqLocus (f g : R \u2192\u2099+* S) : NonUnitalSubring R :=\n  { (f : R \u2192\u2099* S).eqLocus g, (f : R \u2192+ S).eqLocus g with carrier := {x | f x = g x} }", "start": [933, 1], "end": [936, 86], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.eqLocus_same", "code": "@[simp]\ntheorem eqLocus_same (f : R \u2192\u2099+* S) : f.eqLocus f = \u22a4", "start": [938, 1], "end": [940, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.eqOn_set_closure", "code": "theorem eqOn_set_closure {f g : R \u2192\u2099+* S} {s : Set R} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s)", "start": [942, 1], "end": [946, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.eq_of_eqOn_set_top", "code": "theorem eq_of_eqOn_set_top {f g : R \u2192\u2099+* S} (h : Set.EqOn f g (\u22a4 : NonUnitalSubring R)) : f = g", "start": [948, 1], "end": [949, 26], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.eq_of_eqOn_set_dense", "code": "theorem eq_of_eqOn_set_dense {s : Set R} (hs : closure s = \u22a4) {f g : R \u2192\u2099+* S} (h : s.EqOn f g) :\n    f = g", "start": [951, 1], "end": [953, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.closure_preimage_le", "code": "theorem closure_preimage_le (f : R \u2192\u2099+* S) (s : Set S) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [955, 1], "end": [956, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.map_closure", "code": "theorem map_closure (f : R \u2192\u2099+* S) (s : Set R) : (closure s).map f = closure (f '' s)", "start": [958, 1], "end": [964, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.inclusion", "code": "def inclusion {S T : NonUnitalSubring R} (h : S \u2264 T) : S \u2192\u2099+* T :=\n  NonUnitalRingHom.codRestrict (NonUnitalSubringClass.subtype S) _ fun x => h x.2", "start": [978, 1], "end": [980, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.range_subtype", "code": "@[simp]\ntheorem range_subtype (s : NonUnitalSubring R) : (NonUnitalSubringClass.subtype s).range = s", "start": [982, 1], "end": [984, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.range_fst", "code": "theorem range_fst : NonUnitalRingHom.srange (fst R S) = \u22a4", "start": [986, 1], "end": [987, 33], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.range_snd", "code": "theorem range_snd : NonUnitalRingHom.srange (snd R S) = \u22a4", "start": [989, 1], "end": [990, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.nonUnitalSubringCongr", "code": "def nonUnitalSubringCongr (h : s = t) : s \u2243+* t :=\n  {\n    Equiv.setCongr <| congr_arg _ h with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [1002, 1], "end": [1008, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse'", "code": "def ofLeftInverse' {g : S \u2192 R} {f : R \u2192\u2099+* S} (h : Function.LeftInverse g f) : R \u2243+* f.range :=\n  { f.rangeRestrict with\n    toFun := fun x => f.rangeRestrict x\n    invFun := fun x => (g \u2218 NonUnitalSubringClass.subtype f.range) x\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := NonUnitalRingHom.mem_range.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [1010, 1], "end": [1020, 47], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse'_apply", "code": "@[simp]\ntheorem ofLeftInverse'_apply {g : S \u2192 R} {f : R \u2192\u2099+* S} (h : Function.LeftInverse g f) (x : R) :\n    \u2191(ofLeftInverse' h x) = f x", "start": [1022, 1], "end": [1025, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse'_symm_apply", "code": "@[simp]\ntheorem ofLeftInverse'_symm_apply {g : S \u2192 R} {f : R \u2192\u2099+* S} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse' h).symm x = g x", "start": [1027, 1], "end": [1030, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubring.closure_preimage_le", "code": "theorem closure_preimage_le (f : F) (s : Set S) :\n    closure ((f : R \u2192 S) \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [1040, 1], "end": [1042, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/Partrec.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/Computability/Primrec.lean", "Mathlib/Data/Nat/PSub.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.lbp", "code": "private def lbp (m n : \u2115) : Prop :=\n  m = n + 1 \u2227 \u2200 k \u2264 n, false \u2208 p k", "start": [36, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.wf_lbp", "code": "private def wf_lbp : WellFounded (lbp p) :=\n  \u27e8by\n    let \u27e8n, pn\u27e9 := H\n    suffices \u2200 m k, n \u2264 k + m \u2192 Acc (lbp p) k by exact fun a => this _ _ (Nat.le_add_left _ _)\n    intro m k kn\n    induction' m with m IH generalizing k <;> refine' \u27e8_, fun y r => _\u27e9 <;> rcases r with \u27e8rfl, a\u27e9\n    \u00b7 injection mem_unique pn.1 (a _ kn)\n    \u00b7 exact IH _ (by rw [Nat.add_right_comm]; exact kn)\u27e9", "start": [41, 1], "end": [48, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.rfindX", "code": "def rfindX : { n // true \u2208 p n \u2227 \u2200 m < n, false \u2208 p m } :=\n  suffices \u2200 k, (\u2200 n < k, false \u2208 p n) \u2192 { n // true \u2208 p n \u2227 \u2200 m < n, false \u2208 p m } from\n    this 0 fun n => (Nat.not_lt_zero _).elim\n  @WellFounded.fix _ _ (lbp p) (wf_lbp p H)\n    (by\n      intro m IH al\n      have pm : (p m).Dom := by\n        rcases H with \u27e8n, h\u2081, h\u2082\u27e9\n        rcases lt_trichotomy m n with (h\u2083 | h\u2083 | h\u2083)\n        \u00b7 exact h\u2082 _ h\u2083\n        \u00b7 rw [h\u2083]\n          exact h\u2081.fst\n        \u00b7 injection mem_unique h\u2081 (al _ h\u2083)\n      cases e : (p m).get pm\n      \u00b7 suffices \u2200\u1d49 k \u2264 m, false \u2208 p k from IH _ \u27e8rfl, this\u27e9 fun n h => this _ (le_of_lt_succ h)\n        intro n h\n        cases' h.lt_or_eq_dec with h h\n        \u00b7 exact al _ h\n        \u00b7 rw [h]\n          exact \u27e8_, e\u27e9\n      \u00b7 exact \u27e8m, \u27e8_, e\u27e9, al\u27e9)", "start": [50, 1], "end": [70, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind", "code": "def rfind (p : \u2115 \u2192. Bool) : Part \u2115 :=\n  \u27e8_, fun h => (rfindX p h).1\u27e9", "start": [75, 1], "end": [76, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_spec", "code": "theorem rfind_spec {p : \u2115 \u2192. Bool} {n : \u2115} (h : n \u2208 rfind p) : true \u2208 p n", "start": [79, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_min", "code": "theorem rfind_min {p : \u2115 \u2192. Bool} {n : \u2115} (h : n \u2208 rfind p) : \u2200 {m : \u2115}, m < n \u2192 false \u2208 p m", "start": [83, 1], "end": [84, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_dom", "code": "@[simp]\ntheorem rfind_dom {p : \u2115 \u2192. Bool} :\n    (rfind p).Dom \u2194 \u2203 n, true \u2208 p n \u2227 \u2200 {m : \u2115}, m < n \u2192 (p m).Dom", "start": [87, 1], "end": [90, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_dom'", "code": "theorem rfind_dom' {p : \u2115 \u2192. Bool} :\n    (rfind p).Dom \u2194 \u2203 n, true \u2208 p n \u2227 \u2200 {m : \u2115}, m \u2264 n \u2192 (p m).Dom", "start": [93, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_rfind", "code": "@[simp]\ntheorem mem_rfind {p : \u2115 \u2192. Bool} {n : \u2115} :\n    n \u2208 rfind p \u2194 true \u2208 p n \u2227 \u2200 {m : \u2115}, m < n \u2192 false \u2208 p m", "start": [101, 1], "end": [109, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_min'", "code": "theorem rfind_min' {p : \u2115 \u2192 Bool} {m : \u2115} (pm : p m) : \u2203 n \u2208 rfind p, n \u2264 m", "start": [112, 1], "end": [115, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.rfind_zero_none", "code": "theorem rfind_zero_none (p : \u2115 \u2192. Bool) (p0 : p 0 = Part.none) : rfind p = Part.none", "start": [118, 1], "end": [121, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.rfindOpt", "code": "def rfindOpt {\u03b1} (f : \u2115 \u2192 Option \u03b1) : Part \u03b1 :=\n  (rfind fun n => (f n).isSome).bind fun n => f n", "start": [124, 1], "end": [125, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.rfindOpt_spec", "code": "theorem rfindOpt_spec {\u03b1} {f : \u2115 \u2192 Option \u03b1} {a} (h : a \u2208 rfindOpt f) : \u2203 n, a \u2208 f n", "start": [128, 1], "end": [130, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.rfindOpt_dom", "code": "theorem rfindOpt_dom {\u03b1} {f : \u2115 \u2192 Option \u03b1} : (rfindOpt f).Dom \u2194 \u2203 n a, a \u2208 f n", "start": [133, 1], "end": [143, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.rfindOpt_mono", "code": "theorem rfindOpt_mono {\u03b1} {f : \u2115 \u2192 Option \u03b1} (H : \u2200 {a m n}, m \u2264 n \u2192 a \u2208 f m \u2192 a \u2208 f n) {a} :\n    a \u2208 rfindOpt f \u2194 \u2203 n, a \u2208 f n", "start": [146, 1], "end": [152, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec", "code": "inductive Partrec : (\u2115 \u2192. \u2115) \u2192 Prop\n  | zero : Partrec (pure 0)\n  | succ : Partrec succ\n  | left : Partrec \u2191fun n : \u2115 => n.unpair.1\n  | right : Partrec \u2191fun n : \u2115 => n.unpair.2\n  | pair {f g} : Partrec f \u2192 Partrec g \u2192 Partrec fun n => pair <$> f n <*> g n\n  | comp {f g} : Partrec f \u2192 Partrec g \u2192 Partrec fun n => g n >>= f\n  | prec {f g} : Partrec f \u2192 Partrec g \u2192 Partrec (unpaired fun a n =>\n      n.rec (f a) fun y IH => do let i \u2190 IH; g (pair a (pair y i)))\n  | rfind {f} : Partrec f \u2192 Partrec fun a => rfind fun n => (fun m => m = 0) <$> f (pair a n)", "start": [155, 1], "end": [164, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.of_eq", "code": "theorem of_eq {f g : \u2115 \u2192. \u2115} (hf : Partrec f) (H : \u2200 n, f n = g n) : Partrec g", "start": [169, 1], "end": [170, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.of_eq_tot", "code": "theorem of_eq_tot {f : \u2115 \u2192. \u2115} {g : \u2115 \u2192 \u2115} (hf : Partrec f) (H : \u2200 n, g n \u2208 f n) : Partrec g", "start": [173, 1], "end": [174, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.of_primrec", "code": "theorem of_primrec {f : \u2115 \u2192 \u2115} (hf : Nat.Primrec f) : Partrec f", "start": [177, 1], "end": [196, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.some", "code": "protected theorem some : Partrec some", "start": [199, 1], "end": [200, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.none", "code": "theorem none : Partrec fun _ => none", "start": [203, 1], "end": [205, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.prec'", "code": "theorem prec' {f g h} (hf : Partrec f) (hg : Partrec g) (hh : Partrec h) :\n    Partrec fun a => (f a).bind fun n => n.rec (g a)\n      fun y IH => do {let i \u2190 IH; h (Nat.pair a (Nat.pair y i))}", "start": [208, 1], "end": [212, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.ppred", "code": "theorem ppred : Partrec fun n => ppred n", "start": [215, 1], "end": [230, 24], "kind": "commanddeclaration"}, {"full_name": "Partrec", "code": "def Partrec {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] (f : \u03b1 \u2192. \u03c3) :=\n  Nat.Partrec fun n => Part.bind (decode (\u03b1 := \u03b1) n) fun a => (f a).map encode", "start": [237, 1], "end": [238, 79], "kind": "commanddeclaration"}, {"full_name": "Partrec\u2082", "code": "def Partrec\u2082 {\u03b1 \u03b2 \u03c3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3] (f : \u03b1 \u2192 \u03b2 \u2192. \u03c3) :=\n  Partrec fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [241, 1], "end": [242, 37], "kind": "commanddeclaration"}, {"full_name": "Computable", "code": "def Computable {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] (f : \u03b1 \u2192 \u03c3) :=\n  Partrec (f : \u03b1 \u2192. \u03c3)", "start": [245, 1], "end": [246, 23], "kind": "commanddeclaration"}, {"full_name": "Computable\u2082", "code": "def Computable\u2082 {\u03b1 \u03b2 \u03c3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3) :=\n  Computable fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [249, 1], "end": [250, 40], "kind": "commanddeclaration"}, {"full_name": "Primrec.to_comp", "code": "theorem Primrec.to_comp {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {f : \u03b1 \u2192 \u03c3} (hf : Primrec f) :\n    Computable f", "start": [253, 1], "end": [256, 43], "kind": "commanddeclaration"}, {"full_name": "Primrec\u2082.to_comp", "code": "nonrec theorem Primrec\u2082.to_comp {\u03b1 \u03b2 \u03c3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]\n    {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Primrec\u2082 f) : Computable\u2082 f", "start": [259, 1], "end": [261, 13], "kind": "commanddeclaration"}, {"full_name": "Computable.partrec", "code": "protected theorem Computable.partrec {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {f : \u03b1 \u2192 \u03c3}\n    (hf : Computable f) : Partrec (f : \u03b1 \u2192. \u03c3)", "start": [264, 1], "end": [266, 5], "kind": "commanddeclaration"}, {"full_name": "Computable\u2082.partrec\u2082", "code": "protected theorem Computable\u2082.partrec\u2082 {\u03b1 \u03b2 \u03c3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03c3]\n    {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Computable\u2082 f) : Partrec\u2082 fun a => (f a : \u03b2 \u2192. \u03c3)", "start": [269, 1], "end": [271, 5], "kind": "commanddeclaration"}, {"full_name": "Computable.of_eq", "code": "theorem of_eq {f g : \u03b1 \u2192 \u03c3} (hf : Computable f) (H : \u2200 n, f n = g n) : Computable g", "start": [280, 1], "end": [281, 26], "kind": "commanddeclaration"}, {"full_name": "Computable.const", "code": "theorem const (s : \u03c3) : Computable fun _ : \u03b1 => s", "start": [284, 1], "end": [285, 28], "kind": "commanddeclaration"}, {"full_name": "Computable.ofOption", "code": "theorem ofOption {f : \u03b1 \u2192 Option \u03b2} (hf : Computable f) : Partrec fun a => (f a : Part \u03b2)", "start": [288, 1], "end": [291, 31], "kind": "commanddeclaration"}, {"full_name": "Computable.to\u2082", "code": "theorem to\u2082 {f : \u03b1 \u00d7 \u03b2 \u2192 \u03c3} (hf : Computable f) : Computable\u2082 fun a b => f (a, b)", "start": [294, 1], "end": [295, 29], "kind": "commanddeclaration"}, {"full_name": "Computable.id", "code": "protected theorem id : Computable (@id \u03b1)", "start": [298, 1], "end": [299, 21], "kind": "commanddeclaration"}, {"full_name": "Computable.fst", "code": "theorem fst : Computable (@Prod.fst \u03b1 \u03b2)", "start": [302, 1], "end": [303, 22], "kind": "commanddeclaration"}, {"full_name": "Computable.snd", "code": "theorem snd : Computable (@Prod.snd \u03b1 \u03b2)", "start": [306, 1], "end": [307, 22], "kind": "commanddeclaration"}, {"full_name": "Computable.pair", "code": "nonrec theorem pair {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => (f a, g a)", "start": [310, 1], "end": [312, 76], "kind": "commanddeclaration"}, {"full_name": "Computable.unpair", "code": "theorem unpair : Computable Nat.unpair", "start": [315, 1], "end": [316, 25], "kind": "commanddeclaration"}, {"full_name": "Computable.succ", "code": "theorem succ : Computable Nat.succ", "start": [319, 1], "end": [320, 23], "kind": "commanddeclaration"}, {"full_name": "Computable.pred", "code": "theorem pred : Computable Nat.pred", "start": [323, 1], "end": [324, 23], "kind": "commanddeclaration"}, {"full_name": "Computable.nat_bodd", "code": "theorem nat_bodd : Computable Nat.bodd", "start": [327, 1], "end": [328, 27], "kind": "commanddeclaration"}, {"full_name": "Computable.nat_div2", "code": "theorem nat_div2 : Computable Nat.div2", "start": [331, 1], "end": [332, 27], "kind": "commanddeclaration"}, {"full_name": "Computable.sum_inl", "code": "theorem sum_inl : Computable (@Sum.inl \u03b1 \u03b2)", "start": [335, 1], "end": [336, 26], "kind": "commanddeclaration"}, {"full_name": "Computable.sum_inr", "code": "theorem sum_inr : Computable (@Sum.inr \u03b1 \u03b2)", "start": [339, 1], "end": [340, 26], "kind": "commanddeclaration"}, {"full_name": "Computable.list_cons", "code": "theorem list_cons : Computable\u2082 (@List.cons \u03b1)", "start": [343, 1], "end": [344, 28], "kind": "commanddeclaration"}, {"full_name": "Computable.list_reverse", "code": "theorem list_reverse : Computable (@List.reverse \u03b1)", "start": [347, 1], "end": [348, 31], "kind": "commanddeclaration"}, {"full_name": "Computable.list_get?", "code": "theorem list_get? : Computable\u2082 (@List.get? \u03b1)", "start": [351, 1], "end": [352, 28], "kind": "commanddeclaration"}, {"full_name": "Computable.list_append", "code": "theorem list_append : Computable\u2082 ((\u00b7 ++ \u00b7) : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1)", "start": [355, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.list_concat", "code": "theorem list_concat : Computable\u2082 fun l (a : \u03b1) => l ++ [a]", "start": [359, 1], "end": [360, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.list_length", "code": "theorem list_length : Computable (@List.length \u03b1)", "start": [363, 1], "end": [364, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_cons", "code": "theorem vector_cons {n} : Computable\u2082 (@Vector.cons \u03b1 n)", "start": [367, 1], "end": [368, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_toList", "code": "theorem vector_toList {n} : Computable (@Vector.toList \u03b1 n)", "start": [371, 1], "end": [372, 32], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_length", "code": "theorem vector_length {n} : Computable (@Vector.length \u03b1 n)", "start": [375, 1], "end": [376, 32], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_head", "code": "theorem vector_head {n} : Computable (@Vector.head \u03b1 n)", "start": [379, 1], "end": [380, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_tail", "code": "theorem vector_tail {n} : Computable (@Vector.tail \u03b1 n)", "start": [383, 1], "end": [384, 30], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_get", "code": "theorem vector_get {n} : Computable\u2082 (@Vector.get \u03b1 n)", "start": [387, 1], "end": [388, 29], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_ofFn'", "code": "theorem vector_ofFn' {n} : Computable (@Vector.ofFn \u03b1 n)", "start": [392, 1], "end": [393, 31], "kind": "commanddeclaration"}, {"full_name": "Computable.fin_app", "code": "theorem fin_app {n} : Computable\u2082 (@id (Fin n \u2192 \u03c3))", "start": [396, 1], "end": [397, 26], "kind": "commanddeclaration"}, {"full_name": "Computable.encode", "code": "protected theorem encode : Computable (@encode \u03b1 _)", "start": [400, 1], "end": [401, 25], "kind": "commanddeclaration"}, {"full_name": "Computable.decode", "code": "protected theorem decode : Computable (decode (\u03b1 := \u03b1))", "start": [404, 1], "end": [405, 25], "kind": "commanddeclaration"}, {"full_name": "Computable.ofNat", "code": "protected theorem ofNat (\u03b1) [Denumerable \u03b1] : Computable (ofNat \u03b1)", "start": [408, 1], "end": [409, 28], "kind": "commanddeclaration"}, {"full_name": "Computable.encode_iff", "code": "theorem encode_iff {f : \u03b1 \u2192 \u03c3} : (Computable fun a => encode (f a)) \u2194 Computable f", "start": [412, 1], "end": [413, 10], "kind": "commanddeclaration"}, {"full_name": "Computable.option_some", "code": "theorem option_some : Computable (@Option.some \u03b1)", "start": [416, 1], "end": [417, 30], "kind": "commanddeclaration"}, {"full_name": "Partrec.of_eq", "code": "theorem of_eq {f g : \u03b1 \u2192. \u03c3} (hf : Partrec f) (H : \u2200 n, f n = g n) : Partrec g", "start": [430, 1], "end": [431, 26], "kind": "commanddeclaration"}, {"full_name": "Partrec.of_eq_tot", "code": "theorem of_eq_tot {f : \u03b1 \u2192. \u03c3} {g : \u03b1 \u2192 \u03c3} (hf : Partrec f) (H : \u2200 n, g n \u2208 f n) : Computable g", "start": [434, 1], "end": [435, 40], "kind": "commanddeclaration"}, {"full_name": "Partrec.none", "code": "theorem none : Partrec fun _ : \u03b1 => @Part.none \u03c3", "start": [438, 1], "end": [439, 70], "kind": "commanddeclaration"}, {"full_name": "Partrec.some", "code": "protected theorem some : Partrec (@Part.some \u03b1)", "start": [442, 1], "end": [443, 16], "kind": "commanddeclaration"}, {"full_name": "Decidable.Partrec.const'", "code": "theorem _root_.Decidable.Partrec.const' (s : Part \u03c3) [Decidable s.Dom] : Partrec fun _ : \u03b1 => s", "start": [446, 1], "end": [447, 74], "kind": "commanddeclaration"}, {"full_name": "Partrec.const'", "code": "theorem const' (s : Part \u03c3) : Partrec fun _ : \u03b1 => s", "start": [450, 1], "end": [452, 29], "kind": "commanddeclaration"}, {"full_name": "Partrec.bind", "code": "protected theorem bind {f : \u03b1 \u2192. \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} (hf : Partrec f) (hg : Partrec\u2082 g) :\n    Partrec fun a => (f a).bind (g a)", "start": [455, 1], "end": [458, 78], "kind": "commanddeclaration"}, {"full_name": "Partrec.map", "code": "theorem map {f : \u03b1 \u2192. \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Partrec f) (hg : Computable\u2082 g) :\n    Partrec fun a => (f a).map (g a)", "start": [461, 1], "end": [463, 96], "kind": "commanddeclaration"}, {"full_name": "Partrec.to\u2082", "code": "theorem to\u2082 {f : \u03b1 \u00d7 \u03b2 \u2192. \u03c3} (hf : Partrec f) : Partrec\u2082 fun a b => f (a, b)", "start": [466, 1], "end": [467, 29], "kind": "commanddeclaration"}, {"full_name": "Partrec.nat_rec", "code": "theorem nat_rec {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192. \u03c3} {h : \u03b1 \u2192 \u2115 \u00d7 \u03c3 \u2192. \u03c3} (hf : Computable f) (hg : Partrec g)\n    (hh : Partrec\u2082 h) : Partrec fun a => (f a).rec (g a) fun y IH => IH.bind fun i => h a (y, i)", "start": [470, 1], "end": [477, 19], "kind": "commanddeclaration"}, {"full_name": "Partrec.comp", "code": "nonrec theorem comp {f : \u03b2 \u2192. \u03c3} {g : \u03b1 \u2192 \u03b2} (hf : Partrec f) (hg : Computable g) :\n    Partrec fun a => f (g a)", "start": [480, 1], "end": [482, 97], "kind": "commanddeclaration"}, {"full_name": "Partrec.nat_iff", "code": "theorem nat_iff {f : \u2115 \u2192. \u2115} : Partrec f \u2194 Nat.Partrec f", "start": [485, 1], "end": [485, 87], "kind": "commanddeclaration"}, {"full_name": "Partrec.map_encode_iff", "code": "theorem map_encode_iff {f : \u03b1 \u2192. \u03c3} : (Partrec fun a => (f a).map encode) \u2194 Partrec f", "start": [488, 1], "end": [489, 10], "kind": "commanddeclaration"}, {"full_name": "Partrec\u2082.unpaired", "code": "theorem unpaired {f : \u2115 \u2192 \u2115 \u2192. \u03b1} : Partrec (Nat.unpaired f) \u2194 Partrec\u2082 f", "start": [500, 1], "end": [502, 44], "kind": "commanddeclaration"}, {"full_name": "Partrec\u2082.unpaired'", "code": "theorem unpaired' {f : \u2115 \u2192 \u2115 \u2192. \u2115} : Nat.Partrec (Nat.unpaired f) \u2194 Partrec\u2082 f", "start": [505, 1], "end": [506, 38], "kind": "commanddeclaration"}, {"full_name": "Partrec\u2082.comp", "code": "nonrec theorem comp {f : \u03b2 \u2192 \u03b3 \u2192. \u03c3} {g : \u03b1 \u2192 \u03b2} {h : \u03b1 \u2192 \u03b3} (hf : Partrec\u2082 f) (hg : Computable g)\n    (hh : Computable h) : Partrec fun a => f (g a) (h a)", "start": [509, 1], "end": [511, 23], "kind": "commanddeclaration"}, {"full_name": "Partrec\u2082.comp\u2082", "code": "theorem comp\u2082 {f : \u03b3 \u2192 \u03b4 \u2192. \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b4} (hf : Partrec\u2082 f)\n    (hg : Computable\u2082 g) (hh : Computable\u2082 h) : Partrec\u2082 fun a b => f (g a b) (h a b)", "start": [514, 1], "end": [516, 16], "kind": "commanddeclaration"}, {"full_name": "Computable.comp", "code": "nonrec theorem comp {f : \u03b2 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => f (g a)", "start": [527, 1], "end": [529, 13], "kind": "commanddeclaration"}, {"full_name": "Computable.comp\u2082", "code": "theorem comp\u2082 {f : \u03b3 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : Computable f) (hg : Computable\u2082 g) :\n    Computable\u2082 fun a b => f (g a b)", "start": [532, 1], "end": [534, 13], "kind": "commanddeclaration"}, {"full_name": "Computable\u2082.comp", "code": "nonrec theorem comp {f : \u03b2 \u2192 \u03b3 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2} {h : \u03b1 \u2192 \u03b3} (hf : Computable\u2082 f)\n    (hg : Computable g) (hh : Computable h) : Computable fun a => f (g a) (h a)", "start": [545, 1], "end": [547, 23], "kind": "commanddeclaration"}, {"full_name": "Computable\u2082.comp\u2082", "code": "theorem comp\u2082 {f : \u03b3 \u2192 \u03b4 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b4} (hf : Computable\u2082 f)\n    (hg : Computable\u2082 g) (hh : Computable\u2082 h) : Computable\u2082 fun a b => f (g a b) (h a b)", "start": [550, 1], "end": [552, 16], "kind": "commanddeclaration"}, {"full_name": "Partrec.rfind", "code": "theorem rfind {p : \u03b1 \u2192 \u2115 \u2192. Bool} (hp : Partrec\u2082 p) : Partrec fun a => Nat.rfind (p a)", "start": [565, 1], "end": [573, 20], "kind": "commanddeclaration"}, {"full_name": "Partrec.rfindOpt", "code": "theorem rfindOpt {f : \u03b1 \u2192 \u2115 \u2192 Option \u03c3} (hf : Computable\u2082 f) :\n    Partrec fun a => Nat.rfindOpt (f a)", "start": [576, 1], "end": [578, 81], "kind": "commanddeclaration"}, {"full_name": "Partrec.nat_casesOn_right", "code": "theorem nat_casesOn_right {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u2115 \u2192. \u03c3} (hf : Computable f)\n    (hg : Computable g) (hh : Partrec\u2082 h) : Partrec fun a => (f a).casesOn (some (g a)) (h a)", "start": [581, 1], "end": [592, 37], "kind": "commanddeclaration"}, {"full_name": "Partrec.bind_decode\u2082_iff", "code": "theorem bind_decode\u2082_iff {f : \u03b1 \u2192. \u03c3} :\n    Partrec f \u2194 Nat.Partrec fun n => Part.bind (decode\u2082 \u03b1 n) fun a => (f a).map encode", "start": [595, 1], "end": [602, 95], "kind": "commanddeclaration"}, {"full_name": "Partrec.vector_mOfFn", "code": "theorem vector_mOfFn :\n    \u2200 {n} {f : Fin n \u2192 \u03b1 \u2192. \u03c3},\n      (\u2200 i, Partrec (f i)) \u2192 Partrec fun a : \u03b1 => Vector.mOfFn fun i => f i a", "start": [605, 1], "end": [614, 65], "kind": "commanddeclaration"}, {"full_name": "Vector.mOfFn_part_some", "code": "@[simp]\ntheorem Vector.mOfFn_part_some {\u03b1 n} :\n    \u2200 f : Fin n \u2192 \u03b1, (Vector.mOfFn fun i => Part.some (f i)) = Part.some (Vector.ofFn f)", "start": [619, 1], "end": [622, 20], "kind": "commanddeclaration"}, {"full_name": "Computable.option_some_iff", "code": "theorem option_some_iff {f : \u03b1 \u2192 \u03c3} : (Computable fun a => Option.some (f a)) \u2194 Computable f", "start": [631, 1], "end": [632, 91], "kind": "commanddeclaration"}, {"full_name": "Computable.bind_decode_iff", "code": "theorem bind_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 Option \u03c3} :\n    (Computable\u2082 fun a n => (decode (\u03b1 := \u03b2) n).bind (f a)) \u2194 Computable\u2082 f", "start": [635, 1], "end": [656, 56], "kind": "commanddeclaration"}, {"full_name": "Computable.map_decode_iff", "code": "theorem map_decode_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} :\n    (Computable\u2082 fun a n => (decode (\u03b1 := \u03b2) n).map (f a)) \u2194 Computable\u2082 f", "start": [659, 1], "end": [662, 27], "kind": "commanddeclaration"}, {"full_name": "Computable.nat_rec", "code": "theorem nat_rec {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u2115 \u00d7 \u03c3 \u2192 \u03c3} (hf : Computable f) (hg : Computable g)\n    (hh : Computable\u2082 h) :\n    Computable fun a => Nat.rec (motive := fun _ => \u03c3) (g a) (fun y IH => h a (y, IH)) (f a)", "start": [665, 1], "end": [668, 89], "kind": "commanddeclaration"}, {"full_name": "Computable.nat_casesOn", "code": "theorem nat_casesOn {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u2115 \u2192 \u03c3} (hf : Computable f) (hg : Computable g)\n    (hh : Computable\u2082 h) :\n    Computable fun a => Nat.casesOn (motive := fun _ => \u03c3) (f a) (g a) (h a)", "start": [671, 1], "end": [674, 50], "kind": "commanddeclaration"}, {"full_name": "Computable.cond", "code": "theorem cond {c : \u03b1 \u2192 Bool} {f : \u03b1 \u2192 \u03c3} {g : \u03b1 \u2192 \u03c3} (hc : Computable c) (hf : Computable f)\n    (hg : Computable g) : Computable fun a => cond (c a) (f a) (g a)", "start": [677, 1], "end": [679, 91], "kind": "commanddeclaration"}, {"full_name": "Computable.option_casesOn", "code": "theorem option_casesOn {o : \u03b1 \u2192 Option \u03b2} {f : \u03b1 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (ho : Computable o)\n    (hf : Computable f) (hg : Computable\u2082 g) :\n    @Computable _ \u03c3 _ _ fun a => Option.casesOn (o a) (f a) (g a)", "start": [682, 1], "end": [687, 35], "kind": "commanddeclaration"}, {"full_name": "Computable.option_bind", "code": "theorem option_bind {f : \u03b1 \u2192 Option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 Option \u03c3} (hf : Computable f)\n    (hg : Computable\u2082 g) : Computable fun a => (f a).bind (g a)", "start": [690, 1], "end": [692, 81], "kind": "commanddeclaration"}, {"full_name": "Computable.option_map", "code": "theorem option_map {f : \u03b1 \u2192 Option \u03b2} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} (hf : Computable f) (hg : Computable\u2082 g) :\n    Computable fun a => (f a).map (g a)", "start": [695, 1], "end": [698, 27], "kind": "commanddeclaration"}, {"full_name": "Computable.option_getD", "code": "theorem option_getD {f : \u03b1 \u2192 Option \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : Computable f) (hg : Computable g) :\n    Computable fun a => (f a).getD (g a)", "start": [701, 1], "end": [704, 34], "kind": "commanddeclaration"}, {"full_name": "Computable.subtype_mk", "code": "theorem subtype_mk {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} [DecidablePred p] {h : \u2200 a, p (f a)}\n    (hp : PrimrecPred p) (hf : Computable f) :\n    @Computable _ _ _ (Primcodable.subtype hp) fun a => (\u27e8f a, h a\u27e9 : Subtype p)", "start": [707, 1], "end": [710, 5], "kind": "commanddeclaration"}, {"full_name": "Computable.sum_casesOn", "code": "theorem sum_casesOn {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192 \u03c3} (hf : Computable f)\n    (hg : Computable\u2082 g) (hh : Computable\u2082 h) :\n    @Computable _ \u03c3 _ _ fun a => Sum.casesOn (f a) (g a) (h a)", "start": [713, 1], "end": [721, 52], "kind": "commanddeclaration"}, {"full_name": "Computable.nat_strong_rec", "code": "theorem nat_strong_rec (f : \u03b1 \u2192 \u2115 \u2192 \u03c3) {g : \u03b1 \u2192 List \u03c3 \u2192 Option \u03c3} (hg : Computable\u2082 g)\n    (H : \u2200 a n, g a ((List.range n).map (f a)) = Option.some (f a n)) : Computable\u2082 f", "start": [724, 1], "end": [739, 36], "kind": "commanddeclaration"}, {"full_name": "Computable.list_ofFn", "code": "theorem list_ofFn :\n    \u2200 {n} {f : Fin n \u2192 \u03b1 \u2192 \u03c3},\n      (\u2200 i, Computable (f i)) \u2192 Computable fun a => List.ofFn fun i => f i a", "start": [742, 1], "end": [748, 63], "kind": "commanddeclaration"}, {"full_name": "Computable.vector_ofFn", "code": "theorem vector_ofFn {n} {f : Fin n \u2192 \u03b1 \u2192 \u03c3} (hf : \u2200 i, Computable (f i)) :\n    Computable fun a => Vector.ofFn fun i => f i a", "start": [751, 1], "end": [753, 51], "kind": "commanddeclaration"}, {"full_name": "Partrec.option_some_iff", "code": "theorem option_some_iff {f : \u03b1 \u2192. \u03c3} : (Partrec fun a => (f a).map Option.some) \u2194 Partrec f", "start": [766, 1], "end": [772, 49], "kind": "commanddeclaration"}, {"full_name": "Partrec.option_casesOn_right", "code": "theorem option_casesOn_right {o : \u03b1 \u2192 Option \u03b2} {f : \u03b1 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} (ho : Computable o)\n    (hf : Computable f) (hg : Partrec\u2082 g) :\n    @Partrec _ \u03c3 _ _ fun a => Option.casesOn (o a) (Part.some (f a)) (g a)", "start": [775, 1], "end": [784, 62], "kind": "commanddeclaration"}, {"full_name": "Partrec.sum_casesOn_right", "code": "theorem sum_casesOn_right {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192. \u03c3} (hf : Computable f)\n    (hg : Computable\u2082 g) (hh : Partrec\u2082 h) :\n    @Partrec _ \u03c3 _ _ fun a => Sum.casesOn (f a) (fun b => Part.some (g a b)) (h a)", "start": [787, 1], "end": [801, 65], "kind": "commanddeclaration"}, {"full_name": "Partrec.sum_casesOn_left", "code": "theorem sum_casesOn_left {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192 \u03c3} (hf : Computable f)\n    (hg : Partrec\u2082 g) (hh : Computable\u2082 h) :\n    @Partrec _ \u03c3 _ _ fun a => Sum.casesOn (f a) (g a) fun c => Part.some (h a c)", "start": [804, 1], "end": [808, 35], "kind": "commanddeclaration"}, {"full_name": "Partrec.fix_aux", "code": "theorem fix_aux {\u03b1 \u03c3} (f : \u03b1 \u2192. Sum \u03c3 \u03b1) (a : \u03b1) (b : \u03c3) :\n    let F : \u03b1 \u2192 \u2115 \u2192. Sum \u03c3 \u03b1 := fun a n =>\n      n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f\n    (\u2203 n : \u2115,\n        ((\u2203 b' : \u03c3, Sum.inl b' \u2208 F a n) \u2227 \u2200 {m : \u2115}, m < n \u2192 \u2203 b : \u03b1, Sum.inr b \u2208 F a m) \u2227\n          Sum.inl b \u2208 F a n) \u2194\n      b \u2208 PFun.fix f a", "start": [811, 1], "end": [848, 29], "kind": "commanddeclaration"}, {"full_name": "Partrec.fix", "code": "theorem fix {f : \u03b1 \u2192. Sum \u03c3 \u03b1} (hf : Partrec f) : Partrec (PFun.fix f)", "start": [851, 1], "end": [861, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Basic.lean", "Mathlib/MeasureTheory/Integral/Bochner.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoundedContinuousFunction.measurable_coe_ennreal_comp", "code": "theorem measurable_coe_ennreal_comp (f : X \u2192\u1d47 \u211d\u22650) :\n    Measurable fun x \u21a6 (f x : \u211d\u22650\u221e)", "start": [27, 1], "end": [29, 61], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lintegral_lt_top_of_nnreal", "code": "theorem lintegral_lt_top_of_nnreal (f : X \u2192\u1d47 \u211d\u22650) :\n    (\u222b\u207b x, f x \u2202\u03bc) < \u221e", "start": [34, 1], "end": [39, 27], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.integrable_of_nnreal", "code": "theorem integrable_of_nnreal (f : X \u2192\u1d47 \u211d\u22650) :\n    Integrable (((\u2191) : \u211d\u22650 \u2192 \u211d) \u2218 \u21d1f) \u03bc", "start": [42, 1], "end": [46, 39], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.integral_eq_integral_nnrealPart_sub", "code": "theorem integral_eq_integral_nnrealPart_sub (f : X \u2192\u1d47 \u211d) :\n    \u222b x, f x \u2202\u03bc = (\u222b x, (f.nnrealPart x : \u211d) \u2202\u03bc) - \u222b x, ((-f).nnrealPart x : \u211d) \u2202\u03bc", "start": [49, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lintegral_of_real_lt_top", "code": "theorem lintegral_of_real_lt_top (f : X \u2192\u1d47 \u211d) :\n    (\u222b\u207b x, ENNReal.ofReal (f x) \u2202\u03bc) < \u221e", "start": [56, 1], "end": [57, 85], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.toReal_lintegral_coe_eq_integral", "code": "theorem toReal_lintegral_coe_eq_integral (f : X \u2192\u1d47 \u211d\u22650) (\u03bc : Measure X) :\n    (\u222b\u207b x, (f x : \u211d\u22650\u221e) \u2202\u03bc).toReal = \u222b x, (f x : \u211d) \u2202\u03bc", "start": [60, 1], "end": [65, 96], "kind": "commanddeclaration"}, {"full_name": "BoundedContinuousFunction.lintegral_nnnorm_le", "code": "lemma lintegral_nnnorm_le (f : X \u2192\u1d47 E) :\n    \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc \u2264 \u2016f\u2016\u208a * (\u03bc Set.univ) := by\n  calc  \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc\n    _ \u2264 \u222b\u207b _, \u2016f\u2016\u208a \u2202\u03bc         := ?_\n    _ = \u2016f\u2016\u208a * (\u03bc Set.univ)   := by rw [lintegral_const]\n  \u00b7 apply lintegral_mono exact fun x \u21a6 ENNReal.coe_le_coe.mpr (nnnorm_coe_le_nnnorm f x)", "start": [77, 1], "end": [83, 68], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.integrable", "code": "lemma integrable [IsFiniteMeasure \u03bc] (f : X \u2192\u1d47 E) :\n    Integrable f \u03bc := by\n  refine \u27e8f.continuous.measurable.aestronglyMeasurable, (hasFiniteIntegral_def _ _).mp ?_\u27e9\n  calc  \u222b\u207b x, \u2016f x\u2016\u208a \u2202\u03bc\n    _ \u2264 \u2016f\u2016\u208a * (\u03bc Set.univ)   := f.lintegral_nnnorm_le \u03bc\n    _ < \u221e                     := ENNReal.mul_lt_top ENNReal.coe_ne_top (measure_ne_top \u03bc Set.univ)", "start": [85, 1], "end": [90, 99], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.norm_integral_le_mul_norm", "code": "lemma norm_integral_le_mul_norm [IsFiniteMeasure \u03bc] (f : X \u2192\u1d47 E) :\n    \u2016\u222b x, (f x) \u2202\u03bc\u2016 \u2264 ENNReal.toReal (\u03bc Set.univ) * \u2016f\u2016 := by\n  calc  \u2016\u222b x, (f x) \u2202\u03bc\u2016\n    _ \u2264 \u222b x, \u2016f x\u2016 \u2202\u03bc                       := by exact norm_integral_le_integral_norm _\n    _ \u2264 \u222b _, \u2016f\u2016 \u2202\u03bc                         := ?_\n    _ = ENNReal.toReal (\u03bc Set.univ) \u2022 \u2016f\u2016   := by rw [integral_const]\n  \u00b7 apply integral_mono _ (integrable_const \u2016f\u2016) (fun x \u21a6 f.norm_coe_le_norm x) exact (integrable_norm_iff f.continuous.measurable.aestronglyMeasurable).mpr (f.integrable \u03bc)", "start": [95, 1], "end": [102, 98], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.norm_integral_le_norm", "code": "lemma norm_integral_le_norm [IsProbabilityMeasure \u03bc] (f : X \u2192\u1d47 E) :\n    \u2016\u222b x, (f x) \u2202\u03bc\u2016 \u2264 \u2016f\u2016 := by\n  convert f.norm_integral_le_mul_norm \u03bc\n  simp only [measure_univ, ENNReal.one_toReal, one_mul]", "start": [104, 1], "end": [107, 56], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.isBounded_range_integral", "code": "lemma isBounded_range_integral\n    {\u03b9 : Type*} (\u03bcs : \u03b9 \u2192 Measure X) [\u2200 i, IsProbabilityMeasure (\u03bcs i)] (f : X \u2192\u1d47 E) :\n    Bornology.IsBounded (Set.range (fun i \u21a6 \u222b x, (f x) \u2202 (\u03bcs i))) := by\n  apply isBounded_iff_forall_norm_le.mpr \u27e8\u2016f\u2016, fun v hv \u21a6 ?_\u27e9\n  obtain \u27e8i, hi\u27e9 := hv\n  rw [\u2190 hi]\n  apply f.norm_integral_le_norm (\u03bcs i)", "start": [109, 1], "end": [115, 39], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.integral_add_const", "code": "lemma integral_add_const (f : X \u2192\u1d47 \u211d) (c : \u211d) :\n    \u222b x, (f + const X c) x \u2202\u03bc = \u222b x, f x \u2202\u03bc + ENNReal.toReal (\u03bc (Set.univ)) \u2022 c := by\n  simp [integral_add (f.integrable _) (integrable_const c)]", "start": [124, 1], "end": [126, 60], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedContinuousFunction.integral_const_sub", "code": "lemma integral_const_sub (f : X \u2192\u1d47 \u211d) (c : \u211d) :\n    \u222b x, (const X c - f) x \u2202\u03bc = ENNReal.toReal (\u03bc (Set.univ)) \u2022 c - \u222b x, f x \u2202\u03bc := by\n  simp [integral_sub (integrable_const c) (f.integrable _)]", "start": [128, 1], "end": [130, 60], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Combinatorics/Pigeonhole.lean", "imports": ["Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/Module/BigOperators.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/Data/Nat/ModEq.lean"], "premises": [{"full_name": "Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum", "code": "theorem exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (hb : t.card \u2022 b < \u2211 x in s, w x) : \u2203 y \u2208 t, b < \u2211 x in s.filter fun x => f x = y, w x", "start": [113, 1], "end": [119, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul", "code": "theorem exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (hb : \u2211 x in s, w x < t.card \u2022 b) : \u2203 y \u2208 t, \u2211 x in s.filter fun x => f x = y, w x < b", "start": [122, 1], "end": [128, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum", "code": "theorem exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum\n    (ht : \u2200 (y) (_ : y \u2209 t), \u2211 x in s.filter fun x => f x = y, w x \u2264 0)\n    (hb : t.card \u2022 b < \u2211 x in s, w x) : \u2203 y \u2208 t, b < \u2211 x in s.filter fun x => f x = y, w x", "start": [131, 1], "end": [143, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul", "code": "theorem exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul\n    (ht : \u2200 (y) (_ : y \u2209 t), (0 : M) \u2264 \u2211 x in s.filter fun x => f x = y, w x)\n    (hb : \u2211 x in s, w x < t.card \u2022 b) : \u2203 y \u2208 t, \u2211 x in s.filter fun x => f x = y, w x < b", "start": [146, 1], "end": [154, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum", "code": "theorem exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Nonempty)\n    (hb : t.card \u2022 b \u2264 \u2211 x in s, w x) : \u2203 y \u2208 t, b \u2264 \u2211 x in s.filter fun x => f x = y, w x", "start": [162, 1], "end": [168, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul", "code": "theorem exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Nonempty)\n    (hb : \u2211 x in s, w x \u2264 t.card \u2022 b) : \u2203 y \u2208 t, \u2211 x in s.filter fun x => f x = y, w x \u2264 b", "start": [171, 1], "end": [177, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum", "code": "theorem exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum\n    (hf : \u2200 (y) (_ : y \u2209 t), \u2211 x in s.filter fun x => f x = y, w x \u2264 0) (ht : t.Nonempty)\n    (hb : t.card \u2022 b \u2264 \u2211 x in s, w x) : \u2203 y \u2208 t, b \u2264 \u2211 x in s.filter fun x => f x = y, w x", "start": [180, 1], "end": [192, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul", "code": "theorem exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul\n    (hf : \u2200 (y) (_ : y \u2209 t), (0 : M) \u2264 \u2211 x in s.filter fun x => f x = y, w x) (ht : t.Nonempty)\n    (hb : \u2211 x in s, w x \u2264 t.card \u2022 b) : \u2203 y \u2208 t, \u2211 x in s.filter fun x => f x = y, w x \u2264 b", "start": [195, 1], "end": [203, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to", "code": "theorem exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (ht : t.card \u2022 b < s.card) : \u2203 y \u2208 t, b < (s.filter fun x => f x = y).card", "start": [228, 1], "end": [233, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to", "code": "theorem exists_lt_card_fiber_of_mul_lt_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (hn : t.card * n < s.card) : \u2203 y \u2208 t, n < (s.filter fun x => f x = y).card", "start": [236, 1], "end": [245, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_card_fiber_lt_of_card_lt_nsmul", "code": "theorem exists_card_fiber_lt_of_card_lt_nsmul (ht : \u2191s.card < t.card \u2022 b) :\n    \u2203 y \u2208 t, \u2191(s.filter fun x => f x = y).card < b", "start": [248, 1], "end": [255, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_card_fiber_lt_of_card_lt_mul", "code": "theorem exists_card_fiber_lt_of_card_lt_mul (hn : s.card < t.card * n) :\n    \u2203 y \u2208 t, (s.filter fun x => f x = y).card < n", "start": [258, 1], "end": [267, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to", "code": "theorem exists_le_card_fiber_of_nsmul_le_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Nonempty)\n    (hb : t.card \u2022 b \u2264 s.card) : \u2203 y \u2208 t, b \u2264 (s.filter fun x => f x = y).card", "start": [270, 1], "end": [277, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to", "code": "theorem exists_le_card_fiber_of_mul_le_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Nonempty)\n    (hn : t.card * n \u2264 s.card) : \u2203 y \u2208 t, n \u2264 (s.filter fun x => f x = y).card", "start": [280, 1], "end": [286, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_card_fiber_le_of_card_le_nsmul", "code": "theorem exists_card_fiber_le_of_card_le_nsmul (ht : t.Nonempty) (hb : \u2191s.card \u2264 t.card \u2022 b) :\n    \u2203 y \u2208 t, \u2191(s.filter fun x => f x = y).card \u2264 b", "start": [289, 1], "end": [298, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_card_fiber_le_of_card_le_mul", "code": "theorem exists_card_fiber_le_of_card_le_mul (ht : t.Nonempty) (hn : s.card \u2264 t.card * n) :\n    \u2203 y \u2208 t, (s.filter fun x => f x = y).card \u2264 n", "start": [301, 1], "end": [307, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum", "code": "theorem exists_lt_sum_fiber_of_nsmul_lt_sum (hb : card \u03b2 \u2022 b < \u2211 x, w x) :\n    \u2203 y, b < \u2211 x in univ.filter fun x => f x = y, w x", "start": [330, 1], "end": [336, 10], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_le_sum_fiber_of_nsmul_le_sum", "code": "theorem exists_le_sum_fiber_of_nsmul_le_sum [Nonempty \u03b2] (hb : card \u03b2 \u2022 b \u2264 \u2211 x, w x) :\n    \u2203 y, b \u2264 \u2211 x in univ.filter fun x => f x = y, w x", "start": [339, 1], "end": [347, 10], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul", "code": "theorem exists_sum_fiber_lt_of_sum_lt_nsmul (hb : \u2211 x, w x < card \u03b2 \u2022 b) :\n    \u2203 y, \u2211 x in univ.filter fun x => f x = y, w x < b", "start": [350, 1], "end": [355, 64], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_sum_fiber_le_of_sum_le_nsmul", "code": "theorem exists_sum_fiber_le_of_sum_le_nsmul [Nonempty \u03b2] (hb : \u2211 x, w x \u2264 card \u03b2 \u2022 b) :\n    \u2203 y, \u2211 x in univ.filter fun x => f x = y, w x \u2264 b", "start": [358, 1], "end": [364, 66], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_lt_card_fiber_of_nsmul_lt_card", "code": "theorem exists_lt_card_fiber_of_nsmul_lt_card (hb : card \u03b2 \u2022 b < card \u03b1) :\n    \u2203 y : \u03b2, b < (univ.filter fun x => f x = y).card", "start": [371, 1], "end": [377, 9], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_lt_card_fiber_of_mul_lt_card", "code": "theorem exists_lt_card_fiber_of_mul_lt_card (hn : card \u03b2 * n < card \u03b1) :\n    \u2203 y : \u03b2, n < (univ.filter fun x => f x = y).card", "start": [380, 1], "end": [390, 45], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_card_fiber_lt_of_card_lt_nsmul", "code": "theorem exists_card_fiber_lt_of_card_lt_nsmul (hb : \u2191(card \u03b1) < card \u03b2 \u2022 b) :\n    \u2203 y : \u03b2, \u2191(univ.filter fun x => f x = y).card < b", "start": [393, 1], "end": [399, 9], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_card_fiber_lt_of_card_lt_mul", "code": "theorem exists_card_fiber_lt_of_card_lt_mul (hn : card \u03b1 < card \u03b2 * n) :\n    \u2203 y : \u03b2, (univ.filter fun x => f x = y).card < n", "start": [402, 1], "end": [412, 45], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_le_card_fiber_of_nsmul_le_card", "code": "theorem exists_le_card_fiber_of_nsmul_le_card [Nonempty \u03b2] (hb : card \u03b2 \u2022 b \u2264 card \u03b1) :\n    \u2203 y : \u03b2, b \u2264 (univ.filter fun x => f x = y).card", "start": [415, 1], "end": [423, 9], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_le_card_fiber_of_mul_le_card", "code": "theorem exists_le_card_fiber_of_mul_le_card [Nonempty \u03b2] (hn : card \u03b2 * n \u2264 card \u03b1) :\n    \u2203 y : \u03b2, n \u2264 (univ.filter fun x => f x = y).card", "start": [426, 1], "end": [432, 45], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_card_fiber_le_of_card_le_nsmul", "code": "theorem exists_card_fiber_le_of_card_le_nsmul [Nonempty \u03b2] (hb : \u2191(card \u03b1) \u2264 card \u03b2 \u2022 b) :\n    \u2203 y : \u03b2, \u2191(univ.filter fun x => f x = y).card \u2264 b", "start": [435, 1], "end": [442, 9], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_card_fiber_le_of_card_le_mul", "code": "theorem exists_card_fiber_le_of_card_le_mul [Nonempty \u03b2] (hn : card \u03b1 \u2264 card \u03b2 * n) :\n    \u2203 y : \u03b2, (univ.filter fun x => f x = y).card \u2264 n", "start": [445, 1], "end": [451, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_lt_modEq_of_infinite", "code": "theorem exists_lt_modEq_of_infinite {s : Set \u2115} (hs : s.Infinite) {k : \u2115} (hk : 0 < k) :\n    \u2203 m \u2208 s, \u2203 n \u2208 s, m < n \u2227 m \u2261 n [MOD k]", "start": [460, 1], "end": [465, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/EuclideanAbsoluteValue.lean", "imports": ["Mathlib/Algebra/EuclideanDomain/Instances.lean", "Mathlib/Algebra/Order/AbsoluteValue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AbsoluteValue.IsEuclidean", "code": "structure IsEuclidean : Prop where\n  \n  map_lt_map_iff' : \u2200 {x y}, abv x < abv y \u2194 x \u227a y", "start": [37, 1], "end": [43, 51], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.IsEuclidean.map_lt_map_iff", "code": "theorem map_lt_map_iff {x y : R} (h : abv.IsEuclidean) : abv x < abv y \u2194 x \u227a y", "start": [51, 1], "end": [52, 20], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.IsEuclidean.sub_mod_lt", "code": "theorem sub_mod_lt (h : abv.IsEuclidean) (a : R) {b : R} (hb : b \u2260 0) : abv (a % b) < abv b", "start": [57, 1], "end": [58, 53], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.abs_isEuclidean", "code": "protected theorem abs_isEuclidean : IsEuclidean (AbsoluteValue.abs : AbsoluteValue \u2124 \u2124)", "start": [70, 1], "end": [73, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/AbsoluteValue.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/AbsoluteValue.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/GroupTheory/GroupAction/Units.lean", "Mathlib/Data/Int/Units.lean"], "premises": [{"full_name": "AbsoluteValue.map_units_int", "code": "@[simp]\ntheorem AbsoluteValue.map_units_int (abv : AbsoluteValue \u2124 S) (x : \u2124\u02e3) : abv x = 1", "start": [28, 1], "end": [30, 57], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_units_int_cast", "code": "@[simp]\ntheorem AbsoluteValue.map_units_int_cast [Nontrivial R] (abv : AbsoluteValue R S) (x : \u2124\u02e3) :\n    abv ((x : \u2124) : R) = 1", "start": [33, 1], "end": [35, 87], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_units_int_smul", "code": "@[simp]\ntheorem AbsoluteValue.map_units_int_smul (abv : AbsoluteValue R S) (x : \u2124\u02e3) (y : R) :\n    abv (x \u2022 y) = abv y", "start": [38, 1], "end": [40, 85], "kind": "commanddeclaration"}, {"full_name": "Int.natAbsHom", "code": "@[simps]\ndef Int.natAbsHom : \u2124 \u2192*\u2080 \u2115 where\n  toFun := Int.natAbs\n  map_mul' := Int.natAbs_mul\n  map_one' := Int.natAbs_one\n  map_zero' := Int.natAbs_zero", "start": [43, 1], "end": [49, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/CategoryTheory/Category/Grpd.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Homotopy/Path.lean"], "premises": [{"full_name": "Path.Homotopy.reflTransSymmAux", "code": "def reflTransSymmAux (x : I \u00d7 I) : \u211d :=\n  if (x.2 : \u211d) \u2264 1 / 2 then x.1 * 2 * x.2 else x.1 * (2 - 2 * x.2)", "start": [40, 1], "end": [42, 67], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.continuous_reflTransSymmAux", "code": "@[continuity]\ntheorem continuous_reflTransSymmAux : Continuous reflTransSymmAux", "start": [45, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.reflTransSymmAux_mem_I", "code": "theorem reflTransSymmAux_mem_I (x : I \u00d7 I) : reflTransSymmAux x \u2208 I", "start": [56, 1], "end": [79, 68], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.reflTransSymm", "code": "def reflTransSymm (p : Path x\u2080 x\u2081) : Homotopy (Path.refl x\u2080) (p.trans p.symm) where\n  toFun x := p \u27e8reflTransSymmAux x, reflTransSymmAux_mem_I x\u27e9\n  continuous_toFun := by continuity\n  map_zero_left := by simp [reflTransSymmAux]\n  map_one_left x := by\n    dsimp only [reflTransSymmAux, Path.coe_toContinuousMap, Path.trans]\n    change _ = ite _ _ _\n    split_ifs with h\n    \u00b7 rw [Path.extend, Set.IccExtend_of_mem]\n      \u00b7 norm_num\n      \u00b7 rw [unitInterval.mul_pos_mem_iff zero_lt_two]\n        exact \u27e8unitInterval.nonneg x, h\u27e9\n    \u00b7 rw [Path.symm, Path.extend, Set.IccExtend_of_mem]\n      \u00b7 simp only [Set.Icc.coe_one, one_mul, coe_mk_mk, Function.comp_apply]\n        congr 1\n        ext\n        norm_num [sub_sub_eq_add_sub]\n      \u00b7 rw [unitInterval.two_mul_sub_one_mem_iff]\n        exact \u27e8(not_le.1 h).le, unitInterval.le_one x\u27e9\n  prop' t x hx := by\n    simp only [Set.mem_singleton_iff, Set.mem_insert_iff] at hx\n    simp only [ContinuousMap.coe_mk, coe_toContinuousMap, Path.refl_apply]\n    cases hx with\n    | inl hx\n    | inr hx =>\n      rw [hx]\n      norm_num [reflTransSymmAux]", "start": [83, 1], "end": [111, 34], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.reflSymmTrans", "code": "def reflSymmTrans (p : Path x\u2080 x\u2081) : Homotopy (Path.refl x\u2081) (p.symm.trans p) :=\n  (reflTransSymm p.symm).cast rfl <| congr_arg _ Path.symm_symm", "start": [114, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transReflReparamAux", "code": "def transReflReparamAux (t : I) : \u211d :=\n  if (t : \u211d) \u2264 1 / 2 then 2 * t else 1", "start": [124, 1], "end": [126, 39], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.continuous_transReflReparamAux", "code": "@[continuity]\ntheorem continuous_transReflReparamAux : Continuous transReflReparamAux", "start": [129, 1], "end": [134, 12], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transReflReparamAux_mem_I", "code": "theorem transReflReparamAux_mem_I (t : I) : transReflReparamAux t \u2208 I", "start": [137, 1], "end": [139, 88], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transReflReparamAux_zero", "code": "theorem transReflReparamAux_zero : transReflReparamAux 0 = 0", "start": [143, 1], "end": [144, 33], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transReflReparamAux_one", "code": "theorem transReflReparamAux_one : transReflReparamAux 1 = 1", "start": [147, 1], "end": [148, 33], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.trans_refl_reparam", "code": "theorem trans_refl_reparam (p : Path x\u2080 x\u2081) :\n    p.trans (Path.refl x\u2081) =\n      p.reparam (fun t => \u27e8transReflReparamAux t, transReflReparamAux_mem_I t\u27e9) (by continuity)\n        (Subtype.ext transReflReparamAux_zero) (Subtype.ext transReflReparamAux_one)", "start": [151, 1], "end": [162, 9], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transRefl", "code": "def transRefl (p : Path x\u2080 x\u2081) : Homotopy (p.trans (Path.refl x\u2081)) p :=\n  ((Homotopy.reparam p (fun t => \u27e8transReflReparamAux t, transReflReparamAux_mem_I t\u27e9)\n          (by continuity) (Subtype.ext transReflReparamAux_zero)\n          (Subtype.ext transReflReparamAux_one)).cast\n      rfl (trans_refl_reparam p).symm).symm", "start": [165, 1], "end": [170, 44], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.reflTrans", "code": "def reflTrans (p : Path x\u2080 x\u2081) : Homotopy ((Path.refl x\u2080).trans p) p :=\n  (transRefl p.symm).symm\u2082.cast (by simp) (by simp)", "start": [173, 1], "end": [175, 52], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transAssocReparamAux", "code": "def transAssocReparamAux (t : I) : \u211d :=\n  if (t : \u211d) \u2264 1 / 4 then 2 * t else if (t : \u211d) \u2264 1 / 2 then t + 1 / 4 else 1 / 2 * (t + 1)", "start": [182, 1], "end": [184, 92], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.continuous_transAssocReparamAux", "code": "@[continuity]\ntheorem continuous_transAssocReparamAux : Continuous transAssocReparamAux", "start": [187, 1], "end": [195, 20], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transAssocReparamAux_mem_I", "code": "theorem transAssocReparamAux_mem_I (t : I) : transAssocReparamAux t \u2208 I", "start": [198, 1], "end": [200, 88], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transAssocReparamAux_zero", "code": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0", "start": [204, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transAssocReparamAux_one", "code": "theorem transAssocReparamAux_one : transAssocReparamAux 1 = 1", "start": [208, 1], "end": [209, 34], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.trans_assoc_reparam", "code": "theorem trans_assoc_reparam {x\u2080 x\u2081 x\u2082 x\u2083 : X} (p : Path x\u2080 x\u2081) (q : Path x\u2081 x\u2082) (r : Path x\u2082 x\u2083) :\n    (p.trans q).trans r =\n      (p.trans (q.trans r)).reparam\n        (fun t => \u27e8transAssocReparamAux t, transAssocReparamAux_mem_I t\u27e9) (by continuity)\n        (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one)", "start": [212, 1], "end": [251, 9], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopy.transAssoc", "code": "def transAssoc {x\u2080 x\u2081 x\u2082 x\u2083 : X} (p : Path x\u2080 x\u2081) (q : Path x\u2081 x\u2082) (r : Path x\u2082 x\u2083) :\n    Homotopy ((p.trans q).trans r) (p.trans (q.trans r)) :=\n  ((Homotopy.reparam (p.trans (q.trans r))\n          (fun t => \u27e8transAssocReparamAux t, transAssocReparamAux_mem_I t\u27e9) (by continuity)\n          (Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one)).cast\n      rfl (trans_assoc_reparam p q r).symm).symm", "start": [254, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid", "code": "def FundamentalGroupoid (X : Type u) := X", "start": [269, 1], "end": [271, 42], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.comp_eq", "code": "theorem comp_eq (x y z : FundamentalGroupoid X) (p : x \u27f6 y) (q : y \u27f6 z) : p \u226b q = p.comp q", "start": [313, 1], "end": [313, 98], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.id_eq_path_refl", "code": "theorem id_eq_path_refl (x : FundamentalGroupoid X) : \ud835\udfd9 x = \u27e6Path.refl x\u27e7", "start": [316, 1], "end": [316, 81], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.fundamentalGroupoidFunctor", "code": "def fundamentalGroupoidFunctor : TopCat \u2964 CategoryTheory.Grpd where\n  obj X := { \u03b1 := FundamentalGroupoid X }\n  map f :=\n    { obj := f\n      map := fun {X Y} p => by exact Path.Homotopic.Quotient.mapFn p f\n      map_id := fun X => rfl\n      map_comp := fun {x y z} p q => by\n        refine Quotient.inductionOn\u2082 p q fun a b => ?_\n        simp only [comp_eq, \u2190 Path.Homotopic.map_lift, \u2190 Path.Homotopic.comp_lift, Path.map_trans]\n        erw [ \u2190 Path.Homotopic.comp_lift]; rfl}\n  map_id X := by\n    simp only\n    change _ = (\u27e8_, _, _\u27e9 : FundamentalGroupoid X \u2964 FundamentalGroupoid X)\n    congr\n    ext x y p\n    refine' Quotient.inductionOn p fun q => _\n    rw [\u2190 Path.Homotopic.map_lift]\n    conv_rhs => rw [\u2190 q.map_id]\n  map_comp f g := by\n    simp only\n    congr\n    ext x y p\n    refine' Quotient.inductionOn p fun q => _\n    simp only [Quotient.map_mk, Path.map_map, Quotient.eq']\n    rfl", "start": [319, 1], "end": [345, 8], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.map_eq", "code": "theorem map_eq {X Y : TopCat} {x\u2080 x\u2081 : X} (f : C(X, Y)) (p : Path.Homotopic.Quotient x\u2080 x\u2081) :\n    (\u03c0\u2098 f).map p = p.mapFn f", "start": [352, 1], "end": [353, 36], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.toTop", "code": "@[reducible]\ndef toTop {X : TopCat} (x : \u03c0\u2093 X) : X := x", "start": [356, 1], "end": [359, 43], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.fromTop", "code": "@[reducible]\ndef fromTop {X : TopCat} (x : X) : \u03c0\u2093 X := x", "start": [362, 1], "end": [365, 45], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.toPath", "code": "@[reducible]\ndef toPath {X : TopCat} {x\u2080 x\u2081 : \u03c0\u2093 X} (p : x\u2080 \u27f6 x\u2081) : Path.Homotopic.Quotient (X := X) x\u2080 x\u2081 := p", "start": [368, 1], "end": [372, 99], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoid.fromPath", "code": "@[reducible]\ndef fromPath {X : TopCat} {x\u2080 x\u2081 : X} (p : Path.Homotopic.Quotient x\u2080 x\u2081) : x\u2080 \u27f6 x\u2081 := p", "start": [375, 1], "end": [378, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Homotopy/Product.lean", "imports": ["Mathlib/Topology/Homotopy/Path.lean", "Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.HomotopyRel.pi", "code": "@[simps!]\ndef HomotopyRel.pi (homotopies : \u2200 i : I, HomotopyRel (f i) (g i) S) :\n    HomotopyRel (pi f) (pi g) S :=\n  { Homotopy.pi fun i => (homotopies i).toHomotopy with\n    prop' := by\n      intro t x hx\n      dsimp only [coe_mk, pi_eval, toFun_eq_coe, HomotopyWith.coe_toContinuousMap]\n      simp only [Function.funext_iff, \u2190 forall_and]\n      intro i\n      exact (homotopies i).prop' t x hx }", "start": [71, 1], "end": [81, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Homotopy.prod", "code": "@[simps]\ndef Homotopy.prod (F : Homotopy f\u2080 f\u2081) (G : Homotopy g\u2080 g\u2081) :\n    Homotopy (ContinuousMap.prodMk f\u2080 g\u2080) (ContinuousMap.prodMk f\u2081 g\u2081) where\n  toFun t := (F t, G t)\n  map_zero_left x := by simp only [prod_eval, Homotopy.apply_zero]\n  map_one_left x := by simp only [prod_eval, Homotopy.apply_one]", "start": [91, 1], "end": [98, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.HomotopyRel.prod", "code": "@[simps!]\ndef HomotopyRel.prod (F : HomotopyRel f\u2080 f\u2081 S) (G : HomotopyRel g\u2080 g\u2081 S) :\n    HomotopyRel (prodMk f\u2080 g\u2080) (prodMk f\u2081 g\u2081) S :=\n  { Homotopy.prod F.toHomotopy G.toHomotopy with\n    prop' := by\n      intro t x hx\n      have hF := F.prop' t x hx\n      have hG := G.prop' t x hx\n      simp only [coe_mk, prod_eval, Prod.mk.inj_iff, Homotopy.prod] at hF hG\u22a2\n      exact \u27e8\u27e8hF.1, hG.1\u27e9, \u27e8hF.2, hG.2\u27e9\u27e9 }", "start": [101, 1], "end": [112, 43], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.piHomotopy", "code": "def piHomotopy (\u03b3\u2080 \u03b3\u2081 : \u2200 i, Path (as i) (bs i)) (H : \u2200 i, Path.Homotopy (\u03b3\u2080 i) (\u03b3\u2081 i)) :\n    Path.Homotopy (Path.pi \u03b3\u2080) (Path.pi \u03b3\u2081) :=\n  ContinuousMap.HomotopyRel.pi H", "start": [129, 1], "end": [132, 33], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.pi", "code": "def pi (\u03b3 : \u2200 i, Path.Homotopic.Quotient (as i) (bs i)) : Path.Homotopic.Quotient as bs :=\n  (Quotient.map Path.pi fun x y hxy =>\n    Nonempty.map (piHomotopy x y) (Classical.nonempty_pi.mpr hxy)) (Quotient.choice \u03b3)", "start": [135, 1], "end": [138, 87], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.pi_lift", "code": "theorem pi_lift (\u03b3 : \u2200 i, Path (as i) (bs i)) :\n    (Path.Homotopic.pi fun i => \u27e6\u03b3 i\u27e7) = \u27e6Path.pi \u03b3\u27e7", "start": [141, 1], "end": [142, 75], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.comp_pi_eq_pi_comp", "code": "theorem comp_pi_eq_pi_comp (\u03b3\u2080 : \u2200 i, Path.Homotopic.Quotient (as i) (bs i))\n    (\u03b3\u2081 : \u2200 i, Path.Homotopic.Quotient (bs i) (cs i)): pi \u03b3\u2080 \u2b1d pi \u03b3\u2081 = pi fun i => \u03b3\u2080 i \u2b1d \u03b3\u2081 i", "start": [145, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.proj", "code": "@[reducible]\ndef proj (i : \u03b9) (p : Path.Homotopic.Quotient as bs) : Path.Homotopic.Quotient (as i) (bs i) :=\n  p.mapFn \u27e8_, continuous_apply i\u27e9", "start": [158, 1], "end": [161, 34], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.proj_pi", "code": "@[simp]\ntheorem proj_pi (i : \u03b9) (paths : \u2200 i, Path.Homotopic.Quotient (as i) (bs i)) :\n    proj i (pi paths) = paths i", "start": [164, 1], "end": [171, 8], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.pi_proj", "code": "@[simp]\ntheorem pi_proj (p : Path.Homotopic.Quotient as bs) : (pi fun i => proj i p) = p", "start": [174, 1], "end": [180, 8], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.prodHomotopy", "code": "def prodHomotopy (h\u2081 : Path.Homotopy p\u2081 p\u2081') (h\u2082 : Path.Homotopy p\u2082 p\u2082') :\n    Path.Homotopy (p\u2081.prod p\u2082) (p\u2081'.prod p\u2082') :=\n  ContinuousMap.HomotopyRel.prod h\u2081 h\u2082", "start": [191, 1], "end": [195, 39], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.prod", "code": "def prod (q\u2081 : Path.Homotopic.Quotient a\u2081 a\u2082) (q\u2082 : Path.Homotopic.Quotient b\u2081 b\u2082) :\n    Path.Homotopic.Quotient (a\u2081, b\u2081) (a\u2082, b\u2082) :=\n  Quotient.map\u2082 Path.prod (fun _ _ h\u2081 _ _ h\u2082 => Nonempty.map2 prodHomotopy h\u2081 h\u2082) q\u2081 q\u2082", "start": [198, 1], "end": [201, 88], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.prod_lift", "code": "theorem prod_lift : prod \u27e6p\u2081\u27e7 \u27e6p\u2082\u27e7 = \u27e6p\u2081.prod p\u2082\u27e7", "start": [206, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.comp_prod_eq_prod_comp", "code": "theorem comp_prod_eq_prod_comp : prod q\u2081 q\u2082 \u2b1d prod r\u2081 r\u2082 = prod (q\u2081 \u2b1d r\u2081) (q\u2082 \u2b1d r\u2082)", "start": [212, 1], "end": [219, 83], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.projLeft", "code": "@[reducible]\ndef projLeft (p : Path.Homotopic.Quotient c\u2081 c\u2082) : Path.Homotopic.Quotient c\u2081.1 c\u2082.1 :=\n  p.mapFn \u27e8_, continuous_fst\u27e9", "start": [224, 1], "end": [227, 30], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.projRight", "code": "@[reducible]\ndef projRight (p : Path.Homotopic.Quotient c\u2081 c\u2082) : Path.Homotopic.Quotient c\u2081.2 c\u2082.2 :=\n  p.mapFn \u27e8_, continuous_snd\u27e9", "start": [230, 1], "end": [233, 30], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.projLeft_prod", "code": "@[simp]\ntheorem projLeft_prod : projLeft (prod q\u2081 q\u2082) = q\u2081", "start": [236, 1], "end": [243, 8], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.projRight_prod", "code": "@[simp]\ntheorem projRight_prod : projRight (prod q\u2081 q\u2082) = q\u2082", "start": [246, 1], "end": [252, 8], "kind": "commanddeclaration"}, {"full_name": "Path.Homotopic.prod_projLeft_projRight", "code": "@[simp]\ntheorem prod_projLeft_projRight (p : Path.Homotopic.Quotient (a\u2081, b\u2081) (a\u2082, b\u2082)) :\n    prod (projLeft p) (projRight p) = p", "start": [255, 1], "end": [262, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/InnerProductSpace/Spectrum.lean", "imports": ["Mathlib/Algebra/DirectSum/Decomposition.lean", "Mathlib/Analysis/InnerProductSpace/Rayleigh.lean", "Mathlib/LinearAlgebra/Eigenspace/Minpoly.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean"], "premises": [{"full_name": "LinearMap.IsSymmetric.invariant_orthogonalComplement_eigenspace", "code": "theorem invariant_orthogonalComplement_eigenspace (\u03bc : \ud835\udd5c) (v : E) (hv : v \u2208 (eigenspace T \u03bc)\u15ee) :\n    T v \u2208 (eigenspace T \u03bc)\u15ee", "start": [68, 1], "end": [73, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.conj_eigenvalue_eq_self", "code": "theorem conj_eigenvalue_eq_self {\u03bc : \ud835\udd5c} (h\u03bc : HasEigenvalue T \u03bc) : conj \u03bc = \u03bc", "start": [76, 1], "end": [80, 67], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalFamily_eigenspaces", "code": "theorem orthogonalFamily_eigenspaces :\n    OrthogonalFamily \ud835\udd5c (fun \u03bc => eigenspace T \u03bc) fun \u03bc => (eigenspace T \u03bc).subtype\u2097\u1d62", "start": [83, 1], "end": [92, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalFamily_eigenspaces'", "code": "theorem orthogonalFamily_eigenspaces' :\n    OrthogonalFamily \ud835\udd5c (fun \u03bc : Eigenvalues T => eigenspace T \u03bc) fun \u03bc =>\n      (eigenspace T \u03bc).subtype\u2097\u1d62", "start": [95, 1], "end": [98, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_invariant", "code": "theorem orthogonalComplement_iSup_eigenspaces_invariant \u2983v : E\u2984 (hv : v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee) :\n    T v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee", "start": [101, 1], "end": [106, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces", "code": "theorem orthogonalComplement_iSup_eigenspaces (\u03bc : \ud835\udd5c) :\n    eigenspace (T.restrict hT.orthogonalComplement_iSup_eigenspaces_invariant) \u03bc = \u22a5", "start": [109, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot", "code": "theorem orthogonalComplement_iSup_eigenspaces_eq_bot : (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee = \u22a5", "start": [124, 1], "end": [132, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot'", "code": "theorem orthogonalComplement_iSup_eigenspaces_eq_bot' :\n    (\u2a06 \u03bc : Eigenvalues T, eigenspace T \u03bc)\u15ee = \u22a5", "start": [135, 1], "end": [138, 78], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.directSumDecomposition", "code": "noncomputable instance directSumDecomposition [hT : Fact T.IsSymmetric] :\n    DirectSum.Decomposition fun \u03bc : Eigenvalues T => eigenspace T \u03bc :=\n  haveI h : \u2200 \u03bc : Eigenvalues T, CompleteSpace (eigenspace T \u03bc) := fun \u03bc => by infer_instance\n  hT.out.orthogonalFamily_eigenspaces'.decomposition\n    (Submodule.orthogonal_eq_bot_iff.mp hT.out.orthogonalComplement_iSup_eigenspaces_eq_bot')", "start": [141, 1], "end": [149, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.directSum_decompose_apply", "code": "theorem directSum_decompose_apply [_hT : Fact T.IsSymmetric] (x : E) (\u03bc : Eigenvalues T) :\n    DirectSum.decompose (fun \u03bc : Eigenvalues T => eigenspace T \u03bc) x \u03bc =\n      orthogonalProjection (eigenspace T \u03bc) x", "start": [152, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.direct_sum_isInternal", "code": "theorem direct_sum_isInternal : DirectSum.IsInternal fun \u03bc : Eigenvalues T => eigenspace T \u03bc", "start": [158, 1], "end": [162, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.diagonalization", "code": "noncomputable def diagonalization : E \u2243\u2097\u1d62[\ud835\udd5c] PiLp 2 fun \u03bc : Eigenvalues T => eigenspace T \u03bc :=\n  hT.direct_sum_isInternal.isometryL2OfOrthogonalFamily hT.orthogonalFamily_eigenspaces'", "start": [167, 1], "end": [170, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.diagonalization_symm_apply", "code": "@[simp]\ntheorem diagonalization_symm_apply (w : PiLp 2 fun \u03bc : Eigenvalues T => eigenspace T \u03bc) :\n    hT.diagonalization.symm w = \u2211 \u03bc, w \u03bc", "start": [173, 1], "end": [177, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.diagonalization_apply_self_apply", "code": "theorem diagonalization_apply_self_apply (v : E) (\u03bc : Eigenvalues T) :\n    hT.diagonalization (T v) \u03bc = (\u03bc : \ud835\udd5c) \u2022 hT.diagonalization v \u03bc", "start": [180, 1], "end": [192, 84], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.eigenvectorBasis", "code": "noncomputable irreducible_def eigenvectorBasis : OrthonormalBasis (Fin n) \ud835\udd5c E :=\n  hT.direct_sum_isInternal.subordinateOrthonormalBasis hn hT.orthogonalFamily_eigenspaces'", "start": [201, 1], "end": [207, 91], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "LinearMap.IsSymmetric.eigenvalues", "code": "noncomputable irreducible_def eigenvalues (i : Fin n) : \u211d :=\n  @IsROrC.re \ud835\udd5c _ <| (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i\n    hT.orthogonalFamily_eigenspaces').val", "start": [210, 1], "end": [216, 42], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis", "code": "theorem hasEigenvector_eigenvectorBasis (i : Fin n) :\n    HasEigenvector T (hT.eigenvalues hn i) (hT.eigenvectorBasis hn i)", "start": [219, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.hasEigenvalue_eigenvalues", "code": "theorem hasEigenvalue_eigenvalues (i : Fin n) : HasEigenvalue T (hT.eigenvalues hn i)", "start": [241, 1], "end": [242, 87], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.apply_eigenvectorBasis", "code": "@[simp]\ntheorem apply_eigenvectorBasis (i : Fin n) :\n    T (hT.eigenvectorBasis hn i) = (hT.eigenvalues hn i : \ud835\udd5c) \u2022 hT.eigenvectorBasis hn i", "start": [245, 1], "end": [248, 68], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply", "code": "theorem eigenvectorBasis_apply_self_apply (v : E) (i : Fin n) :\n    (hT.eigenvectorBasis hn).repr (T v) i =\n      hT.eigenvalues hn i * (hT.eigenvectorBasis hn).repr v i", "start": [251, 1], "end": [268, 27], "kind": "commanddeclaration"}, {"full_name": "inner_product_apply_eigenvector", "code": "@[simp]\ntheorem inner_product_apply_eigenvector {\u03bc : \ud835\udd5c} {v : E} {T : E \u2192\u2097[\ud835\udd5c] E}\n    (h : v \u2208 Module.End.eigenspace T \u03bc) : \u27eav, T v\u27eb = \u03bc * (\u2016v\u2016 : \ud835\udd5c) ^ 2", "start": [281, 1], "end": [284, 84], "kind": "commanddeclaration"}, {"full_name": "eigenvalue_nonneg_of_nonneg", "code": "theorem eigenvalue_nonneg_of_nonneg {\u03bc : \u211d} {T : E \u2192\u2097[\ud835\udd5c] E} (h\u03bc : HasEigenvalue T \u03bc)\n    (hnn : \u2200 x : E, 0 \u2264 IsROrC.re \u27eax, T x\u27eb) : 0 \u2264 \u03bc", "start": [287, 1], "end": [296, 51], "kind": "commanddeclaration"}, {"full_name": "eigenvalue_pos_of_pos", "code": "theorem eigenvalue_pos_of_pos {\u03bc : \u211d} {T : E \u2192\u2097[\ud835\udd5c] E} (h\u03bc : HasEigenvalue T \u03bc)\n    (hnn : \u2200 x : E, 0 < IsROrC.re \u27eax, T x\u27eb) : 0 < \u03bc", "start": [299, 1], "end": [308, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Hermitian.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/PiL2.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.IsHermitian", "code": "def IsHermitian (A : Matrix n n \u03b1) : Prop := A\u1d34 = A", "start": [40, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eq", "code": "theorem IsHermitian.eq {A : Matrix n n \u03b1} (h : A.IsHermitian) : A\u1d34 = A", "start": [45, 1], "end": [45, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.isSelfAdjoint", "code": "protected theorem IsHermitian.isSelfAdjoint {A : Matrix n n \u03b1} (h : A.IsHermitian) :\n    IsSelfAdjoint A", "start": [48, 1], "end": [49, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.ext", "code": "theorem IsHermitian.ext {A : Matrix n n \u03b1} : (\u2200 i j, star (A j i) = A i j) \u2192 A.IsHermitian", "start": [53, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.apply", "code": "theorem IsHermitian.apply {A : Matrix n n \u03b1} (h : A.IsHermitian) (i j : n) : star (A j i) = A i j", "start": [57, 1], "end": [58, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.ext_iff", "code": "theorem IsHermitian.ext_iff {A : Matrix n n \u03b1} : A.IsHermitian \u2194 \u2200 i j, star (A j i) = A i j", "start": [61, 1], "end": [62, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.map", "code": "@[simp]\ntheorem IsHermitian.map {A : Matrix n n \u03b1} (h : A.IsHermitian) (f : \u03b1 \u2192 \u03b2)\n    (hf : Function.Semiconj f star star) : (A.map f).IsHermitian", "start": [65, 1], "end": [68, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.transpose", "code": "theorem IsHermitian.transpose {A : Matrix n n \u03b1} (h : A.IsHermitian) : A\u1d40.IsHermitian", "start": [71, 1], "end": [73, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_transpose_iff", "code": "@[simp]\ntheorem isHermitian_transpose_iff (A : Matrix n n \u03b1) : A\u1d40.IsHermitian \u2194 A.IsHermitian", "start": [76, 1], "end": [78, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.conjTranspose", "code": "theorem IsHermitian.conjTranspose {A : Matrix n n \u03b1} (h : A.IsHermitian) : A\u1d34.IsHermitian", "start": [81, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.submatrix", "code": "@[simp]\ntheorem IsHermitian.submatrix {A : Matrix n n \u03b1} (h : A.IsHermitian) (f : m \u2192 n) :\n    (A.submatrix f f).IsHermitian", "start": [85, 1], "end": [87, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_submatrix_equiv", "code": "@[simp]\ntheorem isHermitian_submatrix_equiv {A : Matrix n n \u03b1} (e : m \u2243 n) :\n    (A.submatrix e e).IsHermitian \u2194 A.IsHermitian", "start": [90, 1], "end": [93, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_conjTranspose_iff", "code": "@[simp]\ntheorem isHermitian_conjTranspose_iff (A : Matrix n n \u03b1) : A\u1d34.IsHermitian \u2194 A.IsHermitian", "start": [102, 1], "end": [104, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.fromBlocks", "code": "theorem IsHermitian.fromBlocks {A : Matrix m m \u03b1} {B : Matrix m n \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} (hA : A.IsHermitian) (hBC : B\u1d34 = C) (hD : D.IsHermitian) :\n    (A.fromBlocks B C D).IsHermitian", "start": [107, 1], "end": [114, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_fromBlocks_iff", "code": "theorem isHermitian_fromBlocks_iff {A : Matrix m m \u03b1} {B : Matrix m n \u03b1} {C : Matrix n m \u03b1}\n    {D : Matrix n n \u03b1} :\n    (A.fromBlocks B C D).IsHermitian \u2194 A.IsHermitian \u2227 B\u1d34 = C \u2227 C\u1d34 = B \u2227 D.IsHermitian", "start": [117, 1], "end": [124, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_diagonal_of_self_adjoint", "code": "theorem isHermitian_diagonal_of_self_adjoint [DecidableEq n] (v : n \u2192 \u03b1) (h : IsSelfAdjoint v) :\n    (diagonal v).IsHermitian", "start": [133, 1], "end": [137, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_diagonal", "code": "@[simp]\ntheorem isHermitian_diagonal [TrivialStar \u03b1] [DecidableEq n] (v : n \u2192 \u03b1) :\n    (diagonal v).IsHermitian", "start": [140, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_zero", "code": "@[simp]\ntheorem isHermitian_zero : (0 : Matrix n n \u03b1).IsHermitian", "start": [148, 1], "end": [150, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.add", "code": "@[simp]\ntheorem IsHermitian.add {A B : Matrix n n \u03b1} (hA : A.IsHermitian) (hB : B.IsHermitian) :\n    (A + B).IsHermitian", "start": [153, 1], "end": [156, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_add_transpose_self", "code": "theorem isHermitian_add_transpose_self (A : Matrix n n \u03b1) : (A + A\u1d34).IsHermitian", "start": [165, 1], "end": [166, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_transpose_add_self", "code": "theorem isHermitian_transpose_add_self (A : Matrix n n \u03b1) : (A\u1d34 + A).IsHermitian", "start": [169, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.neg", "code": "@[simp]\ntheorem IsHermitian.neg {A : Matrix n n \u03b1} (h : A.IsHermitian) : (-A).IsHermitian", "start": [179, 1], "end": [181, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.sub", "code": "@[simp]\ntheorem IsHermitian.sub {A B : Matrix n n \u03b1} (hA : A.IsHermitian) (hB : B.IsHermitian) :\n    (A - B).IsHermitian", "start": [184, 1], "end": [187, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_mul_conjTranspose_self", "code": "theorem isHermitian_mul_conjTranspose_self [Fintype n] (A : Matrix m n \u03b1) : (A * A\u1d34).IsHermitian", "start": [196, 1], "end": [198, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_transpose_mul_self", "code": "theorem isHermitian_transpose_mul_self [Fintype m] (A : Matrix m n \u03b1) : (A\u1d34 * A).IsHermitian", "start": [201, 1], "end": [203, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_conjTranspose_mul_mul", "code": "theorem isHermitian_conjTranspose_mul_mul [Fintype m] {A : Matrix m m \u03b1} (B : Matrix m n \u03b1)\n    (hA : A.IsHermitian) : (B\u1d34 * A * B).IsHermitian", "start": [206, 1], "end": [209, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_mul_mul_conjTranspose", "code": "theorem isHermitian_mul_mul_conjTranspose [Fintype m] {A : Matrix m m \u03b1} (B : Matrix n m \u03b1)\n    (hA : A.IsHermitian) : (B * A * B\u1d34).IsHermitian", "start": [212, 1], "end": [215, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_one", "code": "@[simp]\ntheorem isHermitian_one [DecidableEq n] : (1 : Matrix n n \u03b1).IsHermitian", "start": [224, 1], "end": [228, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.inv", "code": "theorem IsHermitian.inv [Fintype m] [DecidableEq m] {A : Matrix m m \u03b1} (hA : A.IsHermitian) :\n    A\u207b\u00b9.IsHermitian", "start": [237, 1], "end": [238, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_inv", "code": "@[simp]\ntheorem isHermitian_inv [Fintype m] [DecidableEq m] (A : Matrix m m \u03b1) [Invertible A] :\n    A\u207b\u00b9.IsHermitian \u2194 A.IsHermitian", "start": [241, 1], "end": [244, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.adjugate", "code": "theorem IsHermitian.adjugate [Fintype m] [DecidableEq m] {A : Matrix m m \u03b1} (hA : A.IsHermitian) :\n    A.adjugate.IsHermitian", "start": [247, 1], "end": [248, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.coe_re_apply_self", "code": "theorem IsHermitian.coe_re_apply_self {A : Matrix n n \u03b1} (h : A.IsHermitian) (i : n) :\n    (re (A i i) : \u03b1) = A i i", "start": [259, 1], "end": [261, 98], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.coe_re_diag", "code": "theorem IsHermitian.coe_re_diag {A : Matrix n n \u03b1} (h : A.IsHermitian) :\n    (fun i => (re (A.diag i) : \u03b1)) = A.diag", "start": [264, 1], "end": [267, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.isHermitian_iff_isSymmetric", "code": "theorem isHermitian_iff_isSymmetric [Fintype n] [DecidableEq n] {A : Matrix n n \u03b1} :\n    IsHermitian A \u2194 A.toEuclideanLin.IsSymmetric", "start": [270, 1], "end": [282, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Rank.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/LinearAlgebra/FiniteDimensional.lean", "Mathlib/LinearAlgebra/Determinant.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/LinearAlgebra/Matrix/Diagonal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/DotProduct.lean", "Mathlib/Data/Complex/Module.lean"], "premises": [{"full_name": "Matrix.rank", "code": "noncomputable def rank (A : Matrix m n R) : \u2115 :=\n  finrank R <| LinearMap.range A.mulVecLin", "start": [47, 1], "end": [49, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_one", "code": "@[simp]\ntheorem rank_one [StrongRankCondition R] [DecidableEq n] :\n    rank (1 : Matrix n n R) = Fintype.card n", "start": [52, 1], "end": [55, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_zero", "code": "@[simp]\ntheorem rank_zero [Nontrivial R] : rank (0 : Matrix m n R) = 0", "start": [58, 1], "end": [60, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_le_card_width", "code": "theorem rank_le_card_width [StrongRankCondition R] (A : Matrix m n R) :\n    A.rank \u2264 Fintype.card n", "start": [63, 1], "end": [67, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_le_width", "code": "theorem rank_le_width [StrongRankCondition R] {m n : \u2115} (A : Matrix (Fin m) (Fin n) R) :\n    A.rank \u2264 n", "start": [70, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_mul_le_left", "code": "theorem rank_mul_le_left [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (A * B).rank \u2264 A.rank", "start": [75, 1], "end": [78, 100], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_mul_le_right", "code": "theorem rank_mul_le_right [StrongRankCondition R] (A : Matrix l m R) (B : Matrix m n R) :\n    (A * B).rank \u2264 B.rank", "start": [81, 1], "end": [85, 100], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_mul_le", "code": "theorem rank_mul_le [StrongRankCondition R] (A : Matrix m n R) (B : Matrix n o R) :\n    (A * B).rank \u2264 min A.rank B.rank", "start": [88, 1], "end": [90, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_unit", "code": "theorem rank_unit [StrongRankCondition R] [DecidableEq n] (A : (Matrix n n R)\u02e3) :\n    (A : Matrix n n R).rank = Fintype.card n", "start": [93, 1], "end": [97, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_of_isUnit", "code": "theorem rank_of_isUnit [StrongRankCondition R] [DecidableEq n] (A : Matrix n n R) (h : IsUnit A) :\n    A.rank = Fintype.card n", "start": [100, 1], "end": [103, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_mul_eq_left_of_isUnit_det", "code": "lemma rank_mul_eq_left_of_isUnit_det [DecidableEq n]\n    (A : Matrix n n R) (B : Matrix m n R) (hA : IsUnit A.det) :\n    (B * A).rank = B.rank := by\n  suffices : Function.Surjective A.mulVecLin\n  \u00b7 rw [rank, mulVecLin_mul, LinearMap.range_comp_of_range_eq_top _\n    (LinearMap.range_eq_top.mpr this), \u2190 rank]\n  intro v\n  exact \u27e8(A\u207b\u00b9).mulVecLin v, by simp [mul_nonsing_inv _ hA]\u27e9", "start": [106, 1], "end": [114, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.rank_mul_eq_right_of_isUnit_det", "code": "lemma rank_mul_eq_right_of_isUnit_det [DecidableEq m]\n    (A : Matrix m m R) (B : Matrix m n R) (hA : IsUnit A.det) :\n    (A * B).rank = B.rank := by\n  let b : Basis m R (m \u2192 R) := Pi.basisFun R m\n  replace hA : IsUnit (LinearMap.toMatrix b b A.mulVecLin).det := by\n    convert hA; rw [\u2190 LinearEquiv.eq_symm_apply]; rfl\n  have hAB : mulVecLin (A * B) = (LinearEquiv.ofIsUnitDet hA).comp (mulVecLin B) := by ext; simp\n  rw [rank, rank, hAB, LinearMap.range_comp, LinearEquiv.finrank_map_eq]", "start": [116, 1], "end": [124, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.rank_submatrix_le", "code": "theorem rank_submatrix_le [StrongRankCondition R] [Fintype m] (f : n \u2192 m) (e : n \u2243 m)\n    (A : Matrix m m R) : rank (A.submatrix f e) \u2264 rank A", "start": [126, 1], "end": [132, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_reindex", "code": "theorem rank_reindex [Fintype m] (e\u2081 e\u2082 : m \u2243 n) (A : Matrix m m R) :\n    rank (reindex e\u2081 e\u2082 A) = rank A", "start": [135, 1], "end": [138, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_submatrix", "code": "@[simp]\ntheorem rank_submatrix [Fintype m] (A : Matrix m m R) (e\u2081 e\u2082 : n \u2243 m) :\n    rank (A.submatrix e\u2081 e\u2082) = rank A", "start": [141, 1], "end": [144, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_eq_finrank_range_toLin", "code": "theorem rank_eq_finrank_range_toLin [DecidableEq n] {M\u2081 M\u2082 : Type*} [AddCommGroup M\u2081]\n    [AddCommGroup M\u2082] [Module R M\u2081] [Module R M\u2082] (A : Matrix m n R) (v\u2081 : Basis m R M\u2081)\n    (v\u2082 : Basis n R M\u2082) : A.rank = finrank R (LinearMap.range (toLin v\u2082 v\u2081 A))", "start": [147, 1], "end": [166, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_le_card_height", "code": "theorem rank_le_card_height [StrongRankCondition R] (A : Matrix m n R) :\n    A.rank \u2264 Fintype.card m", "start": [169, 1], "end": [173, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_le_height", "code": "theorem rank_le_height [StrongRankCondition R] {m n : \u2115} (A : Matrix (Fin m) (Fin n) R) :\n    A.rank \u2264 m", "start": [176, 1], "end": [178, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_eq_finrank_span_cols", "code": "theorem rank_eq_finrank_span_cols (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range A\u1d40))", "start": [181, 1], "end": [183, 97], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_diagonal", "code": "theorem rank_diagonal [DecidableEq m] [DecidableEq R] (w : m \u2192 R) :\n    (diagonal w).rank = Fintype.card {i // (w i) \u2260 0}", "start": [192, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.ker_mulVecLin_conjTranspose_mul_self", "code": "theorem ker_mulVecLin_conjTranspose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (A\u1d34 * A).mulVecLin = LinearMap.ker (mulVecLin A)", "start": [218, 1], "end": [221, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_conjTranspose_mul_self", "code": "theorem rank_conjTranspose_mul_self (A : Matrix m n R) : (A\u1d34 * A).rank = A.rank", "start": [224, 1], "end": [231, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_conjTranspose", "code": "@[simp]\ntheorem rank_conjTranspose (A : Matrix m n R) : A\u1d34.rank = A.rank", "start": [235, 1], "end": [241, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_self_mul_conjTranspose", "code": "@[simp]\ntheorem rank_self_mul_conjTranspose (A : Matrix m n R) : (A * A\u1d34).rank = A.rank", "start": [244, 1], "end": [247, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.ker_mulVecLin_transpose_mul_self", "code": "theorem ker_mulVecLin_transpose_mul_self (A : Matrix m n R) :\n    LinearMap.ker (A\u1d40 * A).mulVecLin = LinearMap.ker (mulVecLin A)", "start": [256, 1], "end": [265, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_transpose_mul_self", "code": "theorem rank_transpose_mul_self (A : Matrix m n R) : (A\u1d40 * A).rank = A.rank", "start": [268, 1], "end": [275, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_transpose", "code": "@[simp]\ntheorem rank_transpose (A : Matrix m n R) : A\u1d40.rank = A.rank", "start": [278, 1], "end": [282, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_self_mul_transpose", "code": "@[simp]\ntheorem rank_self_mul_transpose (A : Matrix m n R) : (A * A\u1d40).rank = A.rank", "start": [285, 1], "end": [287, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.rank_eq_finrank_span_row", "code": "theorem rank_eq_finrank_span_row [LinearOrderedField R] [Finite m] (A : Matrix m n R) :\n    A.rank = finrank R (Submodule.span R (Set.range A))", "start": [292, 1], "end": [298, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/CondCdf.lean", "imports": ["Mathlib/MeasureTheory/Measure/Stieltjes.lean", "Mathlib/MeasureTheory/Decomposition/RadonNikodym.lean", "Mathlib/Probability/Kernel/Composition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Directed.sequence_anti", "code": "theorem sequence_anti : Antitone (f \u2218 hf.sequence f)", "start": [59, 1], "end": [60, 50], "kind": "commanddeclaration"}, {"full_name": "Directed.sequence_le", "code": "theorem sequence_le (a : \u03b1) : f (hf.sequence f (Encodable.encode a + 1)) \u2264 f a", "start": [63, 1], "end": [64, 20], "kind": "commanddeclaration"}, {"full_name": "prod_iInter", "code": "theorem prod_iInter {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} [h\u03b9 : Nonempty \u03b9] :\n    (s \u00d7\u02e2 \u22c2 i, t i) = \u22c2 i, s \u00d7\u02e2 t i", "start": [70, 1], "end": [74, 78], "kind": "commanddeclaration"}, {"full_name": "Real.iUnion_Iic_rat", "code": "theorem Real.iUnion_Iic_rat : \u22c3 r : \u211a, Iic (r : \u211d) = univ", "start": [77, 1], "end": [81, 19], "kind": "commanddeclaration"}, {"full_name": "Real.iInter_Iic_rat", "code": "theorem Real.iInter_Iic_rat : \u22c2 r : \u211a, Iic (r : \u211d) = \u2205", "start": [84, 1], "end": [87, 24], "kind": "commanddeclaration"}, {"full_name": "atBot_le_nhds_bot", "code": "theorem atBot_le_nhds_bot {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderBot \u03b1]\n    [OrderTopology \u03b1] : (atBot : Filter \u03b1) \u2264 \ud835\udcdd \u22a5", "start": [91, 1], "end": [102, 54], "kind": "commanddeclaration"}, {"full_name": "atTop_le_nhds_top", "code": "theorem atTop_le_nhds_top {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTop \u03b1]\n    [OrderTopology \u03b1] : (atTop : Filter \u03b1) \u2264 \ud835\udcdd \u22a4", "start": [106, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_antitone", "code": "theorem tendsto_of_antitone {\u03b9 \u03b1 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]\n    [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (h_mono : Antitone f) :\n    Tendsto f atTop atBot \u2228 \u2203 l, Tendsto f atTop (\ud835\udcdd l)", "start": [112, 1], "end": [115, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_cinfi", "code": "theorem ENNReal.ofReal_cinfi (f : \u03b1 \u2192 \u211d) [Nonempty \u03b1] :\n    ENNReal.ofReal (\u2a05 i, f i) = \u2a05 i, ENNReal.ofReal (f i)", "start": [119, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "lintegral_iInf_directed_of_measurable", "code": "theorem lintegral_iInf_directed_of_measurable {m\u03b1 : MeasurableSpace \u03b1} [Countable \u03b2]\n    {f : \u03b2 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1} (h\u03bc : \u03bc \u2260 0) (hf : \u2200 b, Measurable (f b))\n    (hf_int : \u2200 b, \u222b\u207b a, f b a \u2202\u03bc \u2260 \u221e) (h_directed : Directed (\u00b7 \u2265 \u00b7) f) :\n    \u222b\u207b a, \u2a05 b, f b a \u2202\u03bc = \u2a05 b, \u222b\u207b a, f b a \u2202\u03bc", "start": [134, 1], "end": [169, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd", "code": "noncomputable def IicSnd (r : \u211d) : Measure \u03b1 :=\n  (\u03c1.restrict (univ \u00d7\u02e2 Iic r)).fst", "start": [178, 1], "end": [180, 35], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd_apply", "code": "theorem IicSnd_apply (r : \u211d) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u03c1.IicSnd r s = \u03c1 (s \u00d7\u02e2 Iic r)", "start": [183, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd_univ", "code": "theorem IicSnd_univ (r : \u211d) : \u03c1.IicSnd r univ = \u03c1 (univ \u00d7\u02e2 Iic r)", "start": [190, 1], "end": [191, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd_mono", "code": "theorem IicSnd_mono {r r' : \u211d} (h_le : r \u2264 r') : \u03c1.IicSnd r \u2264 \u03c1.IicSnd r'", "start": [194, 1], "end": [198, 22], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd_le_fst", "code": "theorem IicSnd_le_fst (r : \u211d) : \u03c1.IicSnd r \u2264 \u03c1.fst", "start": [201, 1], "end": [204, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IicSnd_ac_fst", "code": "theorem IicSnd_ac_fst (r : \u211d) : \u03c1.IicSnd r \u226a \u03c1.fst", "start": [207, 1], "end": [208, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.IsFiniteMeasure.IicSnd", "code": "theorem IsFiniteMeasure.IicSnd {\u03c1 : Measure (\u03b1 \u00d7 \u211d)} [IsFiniteMeasure \u03c1] (r : \u211d) :\n    IsFiniteMeasure (\u03c1.IicSnd r)", "start": [211, 1], "end": [213, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.iInf_IicSnd_gt", "code": "theorem iInf_IicSnd_gt (t : \u211a) {s : Set \u03b1} (hs : MeasurableSet s) [IsFiniteMeasure \u03c1] :\n    \u2a05 r : { r' : \u211a // t < r' }, \u03c1.IicSnd r s = \u03c1.IicSnd t s", "start": [216, 1], "end": [231, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.tendsto_IicSnd_atTop", "code": "theorem tendsto_IicSnd_atTop {s : Set \u03b1} (hs : MeasurableSet s) :\n    Tendsto (fun r : \u211a => \u03c1.IicSnd r s) atTop (\ud835\udcdd (\u03c1.fst s))", "start": [234, 1], "end": [241, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.tendsto_IicSnd_atBot", "code": "theorem tendsto_IicSnd_atBot [IsFiniteMeasure \u03c1] {s : Set \u03b1} (hs : MeasurableSet s) :\n    Tendsto (fun r : \u211a => \u03c1.IicSnd r s) atBot (\ud835\udcdd 0)", "start": [244, 1], "end": [266, 21], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.preCdf", "code": "noncomputable def preCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (r : \u211a) : \u03b1 \u2192 \u211d\u22650\u221e :=\n  Measure.rnDeriv (\u03c1.IicSnd r) \u03c1.fst", "start": [287, 1], "end": [295, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measurable_preCdf", "code": "theorem measurable_preCdf {\u03c1 : Measure (\u03b1 \u00d7 \u211d)} {r : \u211a} : Measurable (preCdf \u03c1 r)", "start": [298, 1], "end": [299, 33], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.withDensity_preCdf", "code": "theorem withDensity_preCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (r : \u211a) [IsFiniteMeasure \u03c1] :\n    \u03c1.fst.withDensity (preCdf \u03c1 r) = \u03c1.IicSnd r", "start": [302, 1], "end": [304, 89], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_preCdf_fst", "code": "theorem set_lintegral_preCdf_fst (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (r : \u211a) {s : Set \u03b1} (hs : MeasurableSet s)\n    [IsFiniteMeasure \u03c1] : \u222b\u207b x in s, preCdf \u03c1 r x \u2202\u03c1.fst = \u03c1.IicSnd r s", "start": [307, 1], "end": [315, 35], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.monotone_preCdf", "code": "theorem monotone_preCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, Monotone fun r => preCdf \u03c1 r a", "start": [318, 1], "end": [326, 22], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_iInf_gt_preCdf", "code": "theorem set_lintegral_iInf_gt_preCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (t : \u211a) {s : Set \u03b1}\n    (hs : MeasurableSet s) : \u222b\u207b x in s, \u2a05 r : Ioi t, preCdf \u03c1 r x \u2202\u03c1.fst = \u03c1.IicSnd t s", "start": [329, 1], "end": [346, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.preCdf_le_one", "code": "theorem preCdf_le_one (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, \u2200 r, preCdf \u03c1 r a \u2264 1", "start": [349, 1], "end": [357, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_lintegral_preCdf_atTop", "code": "theorem tendsto_lintegral_preCdf_atTop (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    Tendsto (fun r => \u222b\u207b a, preCdf \u03c1 r a \u2202\u03c1.fst) atTop (\ud835\udcdd (\u03c1 univ))", "start": [360, 1], "end": [364, 32], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_lintegral_preCdf_atBot", "code": "theorem tendsto_lintegral_preCdf_atBot (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    Tendsto (fun r => \u222b\u207b a, preCdf \u03c1 r a \u2202\u03c1.fst) atBot (\ud835\udcdd 0)", "start": [367, 1], "end": [370, 77], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_preCdf_atTop_one", "code": "theorem tendsto_preCdf_atTop_one (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, Tendsto (fun r => preCdf \u03c1 r a) atTop (\ud835\udcdd 1)", "start": [373, 1], "end": [440, 47], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_preCdf_atBot_zero", "code": "theorem tendsto_preCdf_atBot_zero (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, Tendsto (fun r => preCdf \u03c1 r a) atBot (\ud835\udcdd 0)", "start": [443, 1], "end": [508, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.inf_gt_preCdf", "code": "theorem inf_gt_preCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, \u2200 t : \u211a, \u2a05 r : Ioi t, preCdf \u03c1 r a = preCdf \u03c1 t a", "start": [511, 1], "end": [517, 76], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.HasCondCdf", "code": "structure HasCondCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) : Prop where\n  mono : Monotone fun r => preCdf \u03c1 r a\n  le_one : \u2200 r, preCdf \u03c1 r a \u2264 1\n  tendsto_atTop_one : Tendsto (fun r => preCdf \u03c1 r a) atTop (\ud835\udcdd 1)\n  tendsto_atBot_zero : Tendsto (fun r => preCdf \u03c1 r a) atBot (\ud835\udcdd 0)\n  iInf_rat_gt_eq : \u2200 t : \u211a, \u2a05 r : Ioi t, preCdf \u03c1 r a = preCdf \u03c1 t a", "start": [522, 1], "end": [530, 69], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.hasCondCdf_ae", "code": "theorem hasCondCdf_ae (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] : \u2200\u1d50 a \u2202\u03c1.fst, HasCondCdf \u03c1 a", "start": [533, 1], "end": [536, 29], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfSet", "code": "def condCdfSet (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) : Set \u03b1 :=\n  (toMeasurable \u03c1.fst {b | \u00acHasCondCdf \u03c1 b})\u1d9c", "start": [539, 1], "end": [542, 46], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measurableSet_condCdfSet", "code": "theorem measurableSet_condCdfSet (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) : MeasurableSet (condCdfSet \u03c1)", "start": [545, 1], "end": [546, 41], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.hasCondCdf_of_mem_condCdfSet", "code": "theorem hasCondCdf_of_mem_condCdfSet {\u03c1 : Measure (\u03b1 \u00d7 \u211d)} {a : \u03b1} (h : a \u2208 condCdfSet \u03c1) :\n    HasCondCdf \u03c1 a", "start": [549, 1], "end": [554, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.mem_condCdfSet_ae", "code": "theorem mem_condCdfSet_ae (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] :\n    \u2200\u1d50 a \u2202\u03c1.fst, a \u2208 condCdfSet \u03c1", "start": [557, 1], "end": [560, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat", "code": "noncomputable def condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) : \u03b1 \u2192 \u211a \u2192 \u211d := fun a =>\n  if a \u2208 condCdfSet \u03c1 then fun r => (preCdf \u03c1 r a).toReal else fun r => if r < 0 then 0 else 1", "start": [567, 1], "end": [571, 95], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat_of_not_mem", "code": "theorem condCdfRat_of_not_mem (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (h : a \u2209 condCdfSet \u03c1) {r : \u211a} :\n    condCdfRat \u03c1 a r = if r < 0 then 0 else 1", "start": [574, 1], "end": [575, 88], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat_of_mem", "code": "theorem condCdfRat_of_mem (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (h : a \u2208 condCdfSet \u03c1) (r : \u211a) :\n    condCdfRat \u03c1 a r = (preCdf \u03c1 r a).toReal", "start": [578, 1], "end": [579, 86], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.monotone_condCdfRat", "code": "theorem monotone_condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) : Monotone (condCdfRat \u03c1 a)", "start": [582, 1], "end": [595, 72], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measurable_condCdfRat", "code": "theorem measurable_condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (q : \u211a) :\n    Measurable fun a => condCdfRat \u03c1 a q", "start": [598, 1], "end": [603, 23], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat_nonneg", "code": "theorem condCdfRat_nonneg (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211a) : 0 \u2264 condCdfRat \u03c1 a r", "start": [606, 1], "end": [613, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat_le_one", "code": "theorem condCdfRat_le_one (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211a) : condCdfRat \u03c1 a r \u2264 1", "start": [616, 1], "end": [624, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_condCdfRat_atBot", "code": "theorem tendsto_condCdfRat_atBot (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) :\n    Tendsto (condCdfRat \u03c1 a) atBot (\ud835\udcdd 0)", "start": [627, 1], "end": [639, 13], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_condCdfRat_atTop", "code": "theorem tendsto_condCdfRat_atTop (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) :\n    Tendsto (condCdfRat \u03c1 a) atTop (\ud835\udcdd 1)", "start": [642, 1], "end": [653, 57], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdfRat_ae_eq", "code": "theorem condCdfRat_ae_eq (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (r : \u211a) :\n    (fun a => condCdfRat \u03c1 a r) =\u1d50[\u03c1.fst] fun a => (preCdf \u03c1 r a).toReal", "start": [656, 1], "end": [658, 82], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.ofReal_condCdfRat_ae_eq", "code": "theorem ofReal_condCdfRat_ae_eq (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (r : \u211a) :\n    (fun a => ENNReal.ofReal (condCdfRat \u03c1 a r)) =\u1d50[\u03c1.fst] preCdf \u03c1 r", "start": [661, 1], "end": [665, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.inf_gt_condCdfRat", "code": "theorem inf_gt_condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (t : \u211a) :\n    \u2a05 r : Ioi t, condCdfRat \u03c1 a r = condCdfRat \u03c1 a t", "start": [668, 1], "end": [702, 45], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf'", "code": "noncomputable irreducible_def condCdf' (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) : \u03b1 \u2192 \u211d \u2192 \u211d := fun a t =>\n  \u2a05 r : { r' : \u211a // t < r' }, condCdfRat \u03c1 a r", "start": [705, 1], "end": [708, 47], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "ProbabilityTheory.condCdf'_def'", "code": "theorem condCdf'_def' {\u03c1 : Measure (\u03b1 \u00d7 \u211d)} {a : \u03b1} {x : \u211d} :\n    condCdf' \u03c1 a x = \u2a05 r : { r : \u211a // x < r }, condCdfRat \u03c1 a r", "start": [711, 1], "end": [712, 84], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf'_eq_condCdfRat", "code": "theorem condCdf'_eq_condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211a) :\n    condCdf' \u03c1 a r = condCdfRat \u03c1 a r", "start": [715, 1], "end": [725, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf'_nonneg", "code": "theorem condCdf'_nonneg (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211d) : 0 \u2264 condCdf' \u03c1 a r", "start": [728, 1], "end": [733, 51], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.bddBelow_range_condCdfRat_gt", "code": "theorem bddBelow_range_condCdfRat_gt (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (x : \u211d) :\n    BddBelow (range fun r : { r' : \u211a // x < \u2191r' } => condCdfRat \u03c1 a r)", "start": [736, 1], "end": [738, 74], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.monotone_condCdf'", "code": "theorem monotone_condCdf' (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) : Monotone (condCdf' \u03c1 a)", "start": [741, 1], "end": [750, 8], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.continuousWithinAt_condCdf'_Ici", "code": "theorem continuousWithinAt_condCdf'_Ici (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (x : \u211d) :\n    ContinuousWithinAt (condCdf' \u03c1 a) (Ici x) x", "start": [753, 1], "end": [770, 22], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf", "code": "noncomputable def condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) : StieltjesFunction where\n  toFun := condCdf' \u03c1 a\n  mono' := monotone_condCdf' \u03c1 a\n  right_continuous' x := continuousWithinAt_condCdf'_Ici \u03c1 a x", "start": [776, 1], "end": [780, 63], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf_eq_condCdfRat", "code": "theorem condCdf_eq_condCdfRat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211a) :\n    condCdf \u03c1 a r = condCdfRat \u03c1 a r", "start": [783, 1], "end": [785, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf_nonneg", "code": "theorem condCdf_nonneg (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (r : \u211d) : 0 \u2264 condCdf \u03c1 a r", "start": [788, 1], "end": [790, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf_le_one", "code": "theorem condCdf_le_one (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (x : \u211d) : condCdf \u03c1 a x \u2264 1", "start": [793, 1], "end": [799, 17], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_condCdf_atBot", "code": "theorem tendsto_condCdf_atBot (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) :\n    Tendsto (condCdf \u03c1 a) atBot (\ud835\udcdd 0)", "start": [802, 1], "end": [818, 57], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.tendsto_condCdf_atTop", "code": "theorem tendsto_condCdf_atTop (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) :\n    Tendsto (condCdf \u03c1 a) atTop (\ud835\udcdd 1)", "start": [821, 1], "end": [837, 65], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condCdf_ae_eq", "code": "theorem condCdf_ae_eq (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (r : \u211a) :\n    (fun a => condCdf \u03c1 a r) =\u1d50[\u03c1.fst] fun a => (preCdf \u03c1 r a).toReal", "start": [840, 1], "end": [843, 69], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.ofReal_condCdf_ae_eq", "code": "theorem ofReal_condCdf_ae_eq (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (r : \u211a) :\n    (fun a => ENNReal.ofReal (condCdf \u03c1 a r)) =\u1d50[\u03c1.fst] preCdf \u03c1 r", "start": [846, 1], "end": [850, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measurable_condCdf", "code": "theorem measurable_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (x : \u211d) : Measurable fun a => condCdf \u03c1 a x", "start": [853, 1], "end": [861, 61], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condCdf_rat", "code": "theorem set_lintegral_condCdf_rat (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (r : \u211a) {s : Set \u03b1}\n    (hs : MeasurableSet s) :\n    \u222b\u207b a in s, ENNReal.ofReal (condCdf \u03c1 a r) \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 Iic (r : \u211d))", "start": [864, 1], "end": [871, 28], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condCdf", "code": "theorem set_lintegral_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d) {s : Set \u03b1}\n    (hs : MeasurableSet s) : \u222b\u207b a in s, ENNReal.ofReal (condCdf \u03c1 a x) \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 Iic x)", "start": [874, 1], "end": [917, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condCdf", "code": "theorem lintegral_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d) :\n    \u222b\u207b a, ENNReal.ofReal (condCdf \u03c1 a x) \u2202\u03c1.fst = \u03c1 (univ \u00d7\u02e2 Iic x)", "start": [920, 1], "end": [922, 74], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.stronglyMeasurable_condCdf", "code": "theorem stronglyMeasurable_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (x : \u211d) :\n    StronglyMeasurable fun a => condCdf \u03c1 a x", "start": [925, 1], "end": [928, 46], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_condCdf", "code": "theorem integrable_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d) :\n    Integrable (fun a => condCdf \u03c1 a x) \u03c1.fst", "start": [931, 1], "end": [945, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_condCdf", "code": "theorem set_integral_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d) {s : Set \u03b1}\n    (hs : MeasurableSet s) : \u222b a in s, condCdf \u03c1 a x \u2202\u03c1.fst = (\u03c1 (s \u00d7\u02e2 Iic x)).toReal", "start": [948, 1], "end": [955, 61], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_condCdf", "code": "theorem integral_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d) :\n    \u222b a, condCdf \u03c1 a x \u2202\u03c1.fst = (\u03c1 (univ \u00d7\u02e2 Iic x)).toReal", "start": [958, 1], "end": [960, 76], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_condCdf_Iic", "code": "theorem measure_condCdf_Iic (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (x : \u211d) :\n    (condCdf \u03c1 a).measure (Iic x) = ENNReal.ofReal (condCdf \u03c1 a x)", "start": [965, 1], "end": [968, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_condCdf_univ", "code": "theorem measure_condCdf_univ (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) : (condCdf \u03c1 a).measure univ = 1", "start": [971, 1], "end": [973, 97], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.instIsProbabilityMeasure", "code": "instance instIsProbabilityMeasure (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) :\n    IsProbabilityMeasure (condCdf \u03c1 a).measure :=\n  \u27e8measure_condCdf_univ \u03c1 a\u27e9", "start": [976, 1], "end": [978, 29], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measurable_measure_condCdf", "code": "theorem measurable_measure_condCdf (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) :\n    Measurable fun a => (condCdf \u03c1 a).measure", "start": [980, 1], "end": [1003, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/IntegralCompProd.lean", "imports": ["Mathlib/MeasureTheory/Integral/SetIntegral.lean", "Mathlib/Probability/Kernel/Composition.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.hasFiniteIntegral_prod_mk_left", "code": "theorem hasFiniteIntegral_prod_mk_left (a : \u03b1) {s : Set (\u03b2 \u00d7 \u03b3)} (h2s : (\u03ba \u2297\u2096 \u03b7) a s \u2260 \u221e) :\n    HasFiniteIntegral (fun b => (\u03b7 (a, b) (Prod.mk b \u207b\u00b9' s)).toReal) (\u03ba a)", "start": [48, 1], "end": [61, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_kernel_prod_mk_left", "code": "theorem integrable_kernel_prod_mk_left (a : \u03b1) {s : Set (\u03b2 \u00d7 \u03b3)} (hs : MeasurableSet s)\n    (h2s : (\u03ba \u2297\u2096 \u03b7) a s \u2260 \u221e) : Integrable (fun b => (\u03b7 (a, b) (Prod.mk b \u207b\u00b9' s)).toReal) (\u03ba a)", "start": [64, 1], "end": [68, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_kernel_compProd [NormedSpace \u211d E]\n    [CompleteSpace E] \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : AEStronglyMeasurable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    AEStronglyMeasurable (fun x => \u222b y, f (x, y) \u2202\u03b7 (a, x)) (\u03ba a)", "start": [71, 1], "end": [75, 92], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.compProd_mk_left", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.compProd_mk_left {\u03b4 : Type*} [TopologicalSpace \u03b4]\n    {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b4} (hf : AEStronglyMeasurable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u2200\u1d50 x \u2202\u03ba a, AEStronglyMeasurable (fun y => f (x, y)) (\u03b7 (a, x))", "start": [78, 1], "end": [82, 100], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.hasFiniteIntegral_compProd_iff", "code": "theorem hasFiniteIntegral_compProd_iff \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (h1f : StronglyMeasurable f) :\n    HasFiniteIntegral f ((\u03ba \u2297\u2096 \u03b7) a) \u2194\n      (\u2200\u1d50 x \u2202\u03ba a, HasFiniteIntegral (fun y => f (x, y)) (\u03b7 (a, x))) \u2227\n        HasFiniteIntegral (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03b7 (a, x)) (\u03ba a)", "start": [88, 1], "end": [104, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.hasFiniteIntegral_compProd_iff'", "code": "theorem hasFiniteIntegral_compProd_iff' \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984\n    (h1f : AEStronglyMeasurable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    HasFiniteIntegral f ((\u03ba \u2297\u2096 \u03b7) a) \u2194\n      (\u2200\u1d50 x \u2202\u03ba a, HasFiniteIntegral (fun y => f (x, y)) (\u03b7 (a, x))) \u2227\n        HasFiniteIntegral (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03b7 (a, x)) (\u03ba a)", "start": [107, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integrable_compProd_iff", "code": "theorem integrable_compProd_iff \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : AEStronglyMeasurable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    Integrable f ((\u03ba \u2297\u2096 \u03b7) a) \u2194\n      (\u2200\u1d50 x \u2202\u03ba a, Integrable (fun y => f (x, y)) (\u03b7 (a, x))) \u2227\n        Integrable (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03b7 (a, x)) (\u03ba a)", "start": [124, 1], "end": [129, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.compProd_mk_left_ae", "code": "theorem _root_.MeasureTheory.Integrable.compProd_mk_left_ae \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984\n    (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) : \u2200\u1d50 x \u2202\u03ba a, Integrable (fun y => f (x, y)) (\u03b7 (a, x))", "start": [132, 1], "end": [134, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_norm_compProd", "code": "theorem _root_.MeasureTheory.Integrable.integral_norm_compProd \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984\n    (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) : Integrable (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03b7 (a, x)) (\u03ba a)", "start": [137, 1], "end": [139, 62], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_compProd", "code": "theorem _root_.MeasureTheory.Integrable.integral_compProd [NormedSpace \u211d E] [CompleteSpace E]\n    \u2983f : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) :\n    Integrable (fun x => \u222b y, f (x, y) \u2202\u03b7 (a, x)) (\u03ba a)", "start": [142, 1], "end": [150, 79], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_fn_integral_add", "code": "theorem kernel.integral_fn_integral_add \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (F : E \u2192 E')\n    (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, F (\u222b y, f (x, y) + g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a =\n      \u222b x, F (\u222b y, f (x, y) \u2202\u03b7 (a, x) + \u222b y, g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a", "start": [159, 1], "end": [165, 30], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_fn_integral_sub", "code": "theorem kernel.integral_fn_integral_sub \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (F : E \u2192 E')\n    (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, F (\u222b y, f (x, y) - g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a =\n      \u222b x, F (\u222b y, f (x, y) \u2202\u03b7 (a, x) - \u222b y, g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a", "start": [168, 1], "end": [174, 30], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.lintegral_fn_integral_sub", "code": "theorem kernel.lintegral_fn_integral_sub \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (F : E \u2192 \u211d\u22650\u221e)\n    (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)) (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b\u207b x, F (\u222b y, f (x, y) - g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a =\n      \u222b\u207b x, F (\u222b y, f (x, y) \u2202\u03b7 (a, x) - \u222b y, g (x, y) \u2202\u03b7 (a, x)) \u2202\u03ba a", "start": [177, 1], "end": [183, 30], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_integral_add", "code": "theorem kernel.integral_integral_add \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a))\n    (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, \u222b y, f (x, y) + g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a =\n      \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a + \u222b x, \u222b y, g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [186, 1], "end": [191, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_integral_add'", "code": "theorem kernel.integral_integral_add' \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a))\n    (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, \u222b y, (f + g) (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a =\n      \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a + \u222b x, \u222b y, g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [194, 1], "end": [198, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_integral_sub", "code": "theorem kernel.integral_integral_sub \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a))\n    (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, \u222b y, f (x, y) - g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a =\n      \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a - \u222b x, \u222b y, g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [201, 1], "end": [206, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.integral_integral_sub'", "code": "theorem kernel.integral_integral_sub' \u2983f g : \u03b2 \u00d7 \u03b3 \u2192 E\u2984 (hf : Integrable f ((\u03ba \u2297\u2096 \u03b7) a))\n    (hg : Integrable g ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b x, \u222b y, (f - g) (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a =\n      \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a - \u222b x, \u222b y, g (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [209, 1], "end": [213, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.continuous_integral_integral", "code": "theorem kernel.continuous_integral_integral :\n    Continuous fun f : (MeasureTheory.Lp (\u03b1 := \u03b2 \u00d7 \u03b3) E 1 (((\u03ba \u2297\u2096 \u03b7) a) : Measure (\u03b2 \u00d7 \u03b3))) =>\n        \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [217, 1], "end": [242, 19], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_compProd", "code": "theorem integral_compProd :\n    \u2200 {f : \u03b2 \u00d7 \u03b3 \u2192 E} (_ : Integrable f ((\u03ba \u2297\u2096 \u03b7) a)),\n      \u222b z, f z \u2202(\u03ba \u2297\u2096 \u03b7) a = \u222b x, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [245, 1], "end": [268, 62], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_compProd", "code": "theorem set_integral_compProd {f : \u03b2 \u00d7 \u03b3 \u2192 E} {s : Set \u03b2} {t : Set \u03b3} (hs : MeasurableSet s)\n    (ht : MeasurableSet t) (hf : IntegrableOn f (s \u00d7\u02e2 t) ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b z in s \u00d7\u02e2 t, f z \u2202(\u03ba \u2297\u2096 \u03b7) a = \u222b x in s, \u222b y in t, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [271, 1], "end": [277, 60], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_compProd_univ_right", "code": "theorem set_integral_compProd_univ_right (f : \u03b2 \u00d7 \u03b3 \u2192 E) {s : Set \u03b2} (hs : MeasurableSet s)\n    (hf : IntegrableOn f (s \u00d7\u02e2 univ) ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b z in s \u00d7\u02e2 univ, f z \u2202(\u03ba \u2297\u2096 \u03b7) a = \u222b x in s, \u222b y, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [280, 1], "end": [283, 82], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_compProd_univ_left", "code": "theorem set_integral_compProd_univ_left (f : \u03b2 \u00d7 \u03b3 \u2192 E) {t : Set \u03b3} (ht : MeasurableSet t)\n    (hf : IntegrableOn f (univ \u00d7\u02e2 t) ((\u03ba \u2297\u2096 \u03b7) a)) :\n    \u222b z in univ \u00d7\u02e2 t, f z \u2202(\u03ba \u2297\u2096 \u03b7) a = \u222b x, \u222b y in t, f (x, y) \u2202\u03b7 (a, x) \u2202\u03ba a", "start": [286, 1], "end": [289, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/MinimalAxioms.lean", "imports": ["Mathlib/Algebra/Group/MinimalAxioms.lean", "Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ring.ofMinimalAxioms", "code": "@[reducible]\ndef Ring.ofMinimalAxioms {R : Type u}\n    [Add R] [Mul R] [Neg R] [Zero R] [One R]\n    (add_assoc : \u2200 a b c : R, a + b + c = a + (b + c))\n    (zero_add : \u2200 a : R, 0 + a = a)\n    (add_left_neg : \u2200 a : R, -a + a = 0)\n    (mul_assoc : \u2200 a b c : R, a * b * c = a * (b * c))\n    (one_mul : \u2200 a : R, 1 * a = a)\n    (mul_one : \u2200 a : R, a * 1 = a)\n    (left_distrib : \u2200 a b c : R, a * (b + c) = a * b + a * c)\n    (right_distrib : \u2200 a b c : R, (a + b) * c = a * c + b * c) : Ring R :=\n  letI := AddGroup.ofLeftAxioms add_assoc zero_add add_left_neg\n  haveI add_comm : \u2200 a b, a + b = b + a := by\n    intro a b\n    have h\u2081 : (1 + 1 : R) * (a + b) = a + (a + b) + b := by\n      rw [left_distrib]\n      simp only [right_distrib, one_mul, add_assoc]\n    have h\u2082 : (1 + 1 : R) * (a + b) = a + (b + a) + b := by\n      rw [right_distrib]\n      simp only [left_distrib, one_mul, add_assoc]\n    have := h\u2081.symm.trans h\u2082\n    rwa [add_left_inj, add_right_inj] at this\n  haveI zero_mul : \u2200 a, (0 : R) * a = 0 := fun a => by\n    have : 0 * a = 0 * a + 0 * a :=\n      calc 0 * a = (0 + 0) * a := by rw [zero_add]\n      _ = 0 * a + 0 * a := by rw [right_distrib]\n    rwa [self_eq_add_right] at this\n  haveI mul_zero : \u2200 a, a * (0 : R) = 0 := fun a => by\n    have : a * 0 = a * 0 + a * 0 :=\n      calc a * 0 = a * (0 + 0) := by rw [zero_add]\n      _ = a * 0 + a * 0 := by rw [left_distrib]\n    rwa [self_eq_add_right] at this\n  { add_comm := add_comm\n    left_distrib := left_distrib\n    right_distrib := right_distrib\n    zero_mul := zero_mul\n    mul_zero := mul_zero\n    mul_assoc := mul_assoc\n    one_mul := one_mul\n    mul_one := mul_one\n    add_left_neg := add_left_neg }", "start": [27, 1], "end": [70, 35], "kind": "commanddeclaration"}, {"full_name": "CommRing.ofMinimalAxioms", "code": "@[reducible]\ndef CommRing.ofMinimalAxioms {R : Type u}\n    [Add R] [Mul R] [Neg R] [Zero R] [One R]\n    (add_assoc : \u2200 a b c : R, a + b + c = a + (b + c))\n    (zero_add : \u2200 a : R, 0 + a = a)\n    (add_left_neg : \u2200 a : R, -a + a = 0)\n    (mul_assoc : \u2200 a b c : R, a * b * c = a * (b * c))\n    (mul_comm : \u2200 a b : R, a * b = b * a)\n    (one_mul : \u2200 a : R, 1 * a = a)\n    (left_distrib : \u2200 a b c : R, a * (b + c) = a * b + a * c) : CommRing R :=\n  haveI mul_one : \u2200 a : R, a * 1 = a := fun a => by\n    rw [mul_comm, one_mul]\n  haveI right_distrib : \u2200 a b c : R, (a + b) * c = a * c + b * c := fun a b c => by\n    rw [mul_comm, left_distrib, mul_comm, mul_comm b c]\n  letI := Ring.ofMinimalAxioms add_assoc zero_add add_left_neg mul_assoc\n    one_mul mul_one left_distrib right_distrib\n  { mul_comm := mul_comm }", "start": [72, 1], "end": [91, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Vandermonde.lean", "imports": ["Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Data/Polynomial/Coeff.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.add_choose_eq", "code": "theorem Nat.add_choose_eq (m n k : \u2115) :\n    (m + n).choose k = \u2211 ij : \u2115 \u00d7 \u2115 in antidiagonal k, m.choose ij.1 * n.choose ij.2", "start": [28, 1], "end": [36, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/TensorProduct.lean", "imports": ["Mathlib/Algebra/Lie/Abelian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.LieModule.hasBracketAux", "code": "def hasBracketAux (x : L) : Module.End R (M \u2297[R] N) :=\n  (toEndomorphism R L M x).rTensor N + (toEndomorphism R L N x).lTensor M", "start": [48, 1], "end": [52, 74], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.lieRingModule", "code": "instance lieRingModule : LieRingModule L (M \u2297[R] N) where\n  bracket x := hasBracketAux x\n  add_lie x y t := by\n    simp only [hasBracketAux, LinearMap.lTensor_add, LinearMap.rTensor_add, LieHom.map_add,\n      LinearMap.add_apply]\n    abel\n  lie_add x := LinearMap.map_add _\n  leibniz_lie x y t := by\n    suffices (hasBracketAux x).comp (hasBracketAux y) =\n        hasBracketAux \u2045x, y\u2046 + (hasBracketAux y).comp (hasBracketAux x) by\n      simp only [\u2190 LinearMap.add_apply]; rw [\u2190 LinearMap.comp_apply, this]; rfl\n    ext m n\n    simp only [hasBracketAux, LieRing.of_associative_ring_bracket, LinearMap.mul_apply, mk_apply,\n      LinearMap.lTensor_sub, LinearMap.compr\u2082_apply, Function.comp_apply, LinearMap.coe_comp,\n      LinearMap.rTensor_tmul, LieHom.map_lie, toEndomorphism_apply_apply, LinearMap.add_apply,\n      LinearMap.map_add, LinearMap.rTensor_sub, LinearMap.sub_apply, LinearMap.lTensor_tmul]\n    abel", "start": [55, 1], "end": [72, 9], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.lieModule", "code": "instance lieModule : LieModule R L (M \u2297[R] N) where\n  smul_lie c x t := by\n    change hasBracketAux (c \u2022 x) _ = c \u2022 hasBracketAux _ _\n    simp only [hasBracketAux, smul_add, LinearMap.rTensor_smul, LinearMap.smul_apply,\n      LinearMap.lTensor_smul, LieHom.map_smul, LinearMap.add_apply]\n  lie_smul c x := LinearMap.map_smul _ c", "start": [75, 1], "end": [81, 41], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.lie_tmul_right", "code": "@[simp]\ntheorem lie_tmul_right (x : L) (m : M) (n : N) : \u2045x, m \u2297\u209c[R] n\u2046 = \u2045x, m\u2046 \u2297\u209c n + m \u2297\u209c \u2045x, n\u2046", "start": [84, 1], "end": [88, 51], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.lift", "code": "def lift : (M \u2192\u2097[R] N \u2192\u2097[R] P) \u2243\u2097\u2045R,L\u2046 M \u2297[R] N \u2192\u2097[R] P :=\n  { TensorProduct.lift.equiv R M N P with\n    map_lie' := fun {x f} => by\n      ext m n\n      simp only [mk_apply, LinearMap.compr\u2082_apply, lie_tmul_right, LinearMap.sub_apply,\n        lift.equiv_apply, LinearEquiv.toFun_eq_coe, LieHom.lie_apply, LinearMap.map_add]\n      abel }", "start": [93, 1], "end": [101, 13], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.lift_apply", "code": "@[simp]\ntheorem lift_apply (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) (n : N) : lift R L M N P f (m \u2297\u209c n) = f m n", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.liftLie", "code": "def liftLie : (M \u2192\u2097\u2045R,L\u2046 N \u2192\u2097[R] P) \u2243\u2097[R] M \u2297[R] N \u2192\u2097\u2045R,L\u2046 P :=\n  maxTrivLinearMapEquivLieModuleHom.symm \u226a\u226b\u2097 \u2191(maxTrivEquiv (lift R L M N P)) \u226a\u226b\u2097\n    maxTrivLinearMapEquivLieModuleHom", "start": [109, 1], "end": [115, 38], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.coe_liftLie_eq_lift_coe", "code": "@[simp]\ntheorem coe_liftLie_eq_lift_coe (f : M \u2192\u2097\u2045R,L\u2046 N \u2192\u2097[R] P) :\n    \u21d1(liftLie R L M N P f) = lift R L M N P f", "start": [118, 1], "end": [126, 58], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.liftLie_apply", "code": "theorem liftLie_apply (f : M \u2192\u2097\u2045R,L\u2046 N \u2192\u2097[R] P) (m : M) (n : N) :\n    liftLie R L M N P f (m \u2297\u209c n) = f m n", "start": [129, 1], "end": [131, 80], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.map", "code": "nonrec def map (f : M \u2192\u2097\u2045R,L\u2046 P) (g : N \u2192\u2097\u2045R,L\u2046 Q) : M \u2297[R] N \u2192\u2097\u2045R,L\u2046 P \u2297[R] Q :=\n  { map (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) with\n    map_lie' := fun {x t} => by\n      simp only [LinearMap.toFun_eq_coe]\n      refine' t.induction_on _ _ _\n      \u00b7 simp only [LinearMap.map_zero, lie_zero]\n      \u00b7 intro m n\n        simp only [LieModuleHom.coe_toLinearMap, lie_tmul_right, LieModuleHom.map_lie, map_tmul,\n          LinearMap.map_add]\n      \u00b7 intro t\u2081 t\u2082 ht\u2081 ht\u2082; simp only [ht\u2081, ht\u2082, lie_add, LinearMap.map_add] }", "start": [136, 1], "end": [147, 80], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.coe_linearMap_map", "code": "@[simp]\ntheorem coe_linearMap_map (f : M \u2192\u2097\u2045R,L\u2046 P) (g : N \u2192\u2097\u2045R,L\u2046 Q) :\n    (map f g : M \u2297[R] N \u2192\u2097[R] P \u2297[R] Q) = TensorProduct.map (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q)", "start": [150, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.map_tmul", "code": "@[simp]\nnonrec theorem map_tmul (f : M \u2192\u2097\u2045R,L\u2046 P) (g : N \u2192\u2097\u2045R,L\u2046 Q) (m : M) (n : N) :\n    map f g (m \u2297\u209c n) = f m \u2297\u209c g n", "start": [156, 1], "end": [159, 19], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.mapIncl", "code": "def mapIncl (M' : LieSubmodule R L M) (N' : LieSubmodule R L N) : M' \u2297[R] N' \u2192\u2097\u2045R,L\u2046 M \u2297[R] N :=\n  map M'.incl N'.incl", "start": [162, 1], "end": [164, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.LieModule.mapIncl_def", "code": "@[simp]\ntheorem mapIncl_def (M' : LieSubmodule R L M) (N' : LieSubmodule R L N) :\n    mapIncl M' N' = map M'.incl N'.incl", "start": [167, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "LieModule.toModuleHom", "code": "def toModuleHom : L \u2297[R] M \u2192\u2097\u2045R,L\u2046 M :=\n  TensorProduct.LieModule.liftLie R L L M M\n    { (toEndomorphism R L M : L \u2192\u2097[R] M \u2192\u2097[R] M) with\n      map_lie' := fun {x m} => by ext n; simp [LieRing.of_associative_ring_bracket] }", "start": [187, 1], "end": [191, 86], "kind": "commanddeclaration"}, {"full_name": "LieModule.toModuleHom_apply", "code": "@[simp]\ntheorem toModuleHom_apply (x : L) (m : M) : toModuleHom R L M (x \u2297\u209c m) = \u2045x, m\u2046", "start": [194, 1], "end": [197, 98], "kind": "commanddeclaration"}, {"full_name": "LieSubmodule.lieIdeal_oper_eq_tensor_map_range", "code": "theorem lieIdeal_oper_eq_tensor_map_range :\n    \u2045I, N\u2046 = ((toModuleHom R L M).comp (mapIncl I N : (\u21a5I) \u2297[R] (\u21a5N) \u2192\u2097\u2045R,L\u2046 L \u2297[R] M)).range", "start": [215, 1], "end": [230, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Divisibility/Lemmas.lean", "imports": ["Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "dvd_smul_of_dvd", "code": "lemma dvd_smul_of_dvd {M : Type*} [SMul M R] [Semigroup R] [SMulCommClass M R R] {x y : R}\n    (m : M) (h : x \u2223 y) : x \u2223 m \u2022 y :=\n  let \u27e8k, hk\u27e9 := h; \u27e8m \u2022 k, by rw [mul_smul_comm, \u2190 hk]\u27e9", "start": [20, 1], "end": [22, 57], "kind": "mathlibtacticlemma"}, {"full_name": "dvd_nsmul_of_dvd", "code": "lemma dvd_nsmul_of_dvd [NonUnitalSemiring R] {x y : R} (n : \u2115) (h : x \u2223 y) : x \u2223 n \u2022 y :=\n  dvd_smul_of_dvd n h", "start": [24, 1], "end": [25, 22], "kind": "mathlibtacticlemma"}, {"full_name": "dvd_zsmul_of_dvd", "code": "lemma dvd_zsmul_of_dvd [NonUnitalRing R] {x y : R} (z : \u2124) (h : x \u2223 y) : x \u2223 z \u2022 y :=\n  dvd_smul_of_dvd z h", "start": [27, 1], "end": [28, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_add_pow_of_pow_eq_zero_right", "code": "lemma pow_dvd_add_pow_of_pow_eq_zero_right (hy : y ^ n = 0) :\n    x ^ m \u2223 (x + y) ^ p := by\n  rw [h_comm.add_pow']\n  refine Finset.dvd_sum fun \u27e8i, j\u27e9 hij \u21a6 ?_\n  replace hij : i + j = p := by simpa using hij\n  apply dvd_nsmul_of_dvd\n  rcases le_or_lt m i with (hi : m \u2264 i) | (hi : i + 1 \u2264 m)\n  \u00b7 exact dvd_mul_of_dvd_left (pow_dvd_pow x hi) _\n  \u00b7 simp [pow_eq_zero_of_le (by linarith : n \u2264 j) hy]", "start": [38, 1], "end": [46, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_add_pow_of_pow_eq_zero_left", "code": "lemma pow_dvd_add_pow_of_pow_eq_zero_left (hx : x ^ n = 0) :\n    y ^ m \u2223 (x + y) ^ p :=\n  add_comm x y \u25b8 h_comm.symm.pow_dvd_add_pow_of_pow_eq_zero_right hp hx", "start": [48, 1], "end": [50, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_pow_of_sub_pow_eq_zero", "code": "lemma pow_dvd_pow_of_sub_pow_eq_zero (h : (x - y) ^ n = 0) :\n    x ^ m \u2223 y ^ p := by\n  rw [\u2190 sub_add_cancel y x]\n  apply (h_comm.symm.sub_left rfl).pow_dvd_add_pow_of_pow_eq_zero_left hp _\n  rw [\u2190 neg_sub x y, neg_pow, h, mul_zero]", "start": [58, 1], "end": [62, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_pow_of_add_pow_eq_zero", "code": "lemma pow_dvd_pow_of_add_pow_eq_zero (h : (x + y) ^ n = 0) :\n    x ^ m \u2223 y ^ p := by\n  rw [\u2190 neg_neg y, neg_pow']\n  apply dvd_mul_of_dvd_left\n  apply h_comm.neg_right.pow_dvd_pow_of_sub_pow_eq_zero hp\n  simpa", "start": [64, 1], "end": [69, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_sub_pow_of_pow_eq_zero_right", "code": "lemma pow_dvd_sub_pow_of_pow_eq_zero_right (hy : y ^ n = 0) :\n    x ^ m \u2223 (x - y) ^ p :=\n  (sub_right rfl h_comm).pow_dvd_pow_of_sub_pow_eq_zero hp (by simpa)", "start": [71, 1], "end": [73, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.pow_dvd_sub_pow_of_pow_eq_zero_left", "code": "lemma pow_dvd_sub_pow_of_pow_eq_zero_left (hx : x ^ n = 0) :\n    y ^ m \u2223 (x - y) ^ p := by\n  rw [\u2190 neg_sub y x, neg_pow']\n  apply dvd_mul_of_dvd_left\n  exact h_comm.symm.pow_dvd_sub_pow_of_pow_eq_zero_right hp hx", "start": [75, 1], "end": [79, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.add_pow_dvd_pow_of_pow_eq_zero_right", "code": "lemma add_pow_dvd_pow_of_pow_eq_zero_right (hx : x ^ n = 0) :\n    (x + y) ^ m \u2223 y ^ p :=\n  (h_comm.add_left rfl).pow_dvd_pow_of_sub_pow_eq_zero hp (by simpa)", "start": [81, 1], "end": [83, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.add_pow_dvd_pow_of_pow_eq_zero_left", "code": "lemma add_pow_dvd_pow_of_pow_eq_zero_left (hy : y ^ n = 0) :\n    (x + y) ^ m \u2223 x ^ p :=\n  add_comm x y \u25b8 h_comm.symm.add_pow_dvd_pow_of_pow_eq_zero_right hp hy", "start": [85, 1], "end": [87, 72], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Lie/Engel.lean", "imports": ["Mathlib/Algebra/Lie/Nilpotent.lean", "Mathlib/Algebra/Lie/Normalizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieSubmodule.exists_smul_add_of_span_sup_eq_top", "code": "theorem exists_smul_add_of_span_sup_eq_top (y : L) : \u2203 t : R, \u2203 z \u2208 I, y = t \u2022 x + z", "start": [84, 1], "end": [88, 24], "kind": "commanddeclaration"}, {"full_name": "LieSubmodule.lie_top_eq_of_span_sup_eq_top", "code": "theorem lie_top_eq_of_span_sup_eq_top (N : LieSubmodule R L M) :\n    (\u2191\u2045(\u22a4 : LieIdeal R L), N\u2046 : Submodule R M) =\n      (N : Submodule R M).map (toEndomorphism R L M x) \u2294 (\u2191\u2045I, N\u2046 : Submodule R M)", "start": [91, 1], "end": [104, 46], "kind": "commanddeclaration"}, {"full_name": "LieSubmodule.lcs_le_lcs_of_is_nilpotent_span_sup_eq_top", "code": "theorem lcs_le_lcs_of_is_nilpotent_span_sup_eq_top {n i j : \u2115}\n    (hxn : toEndomorphism R L M x ^ n = 0) (hIM : lowerCentralSeries R L M i \u2264 I.lcs M j) :\n    lowerCentralSeries R L M (i + n) \u2264 I.lcs M (j + 1)", "start": [107, 1], "end": [127, 58], "kind": "commanddeclaration"}, {"full_name": "LieSubmodule.isNilpotentOfIsNilpotentSpanSupEqTop", "code": "theorem isNilpotentOfIsNilpotentSpanSupEqTop (hnp : IsNilpotent <| toEndomorphism R L M x)\n    (hIM : IsNilpotent R I M) : IsNilpotent R L M", "start": [130, 1], "end": [142, 85], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.IsEngelian", "code": "def LieAlgebra.IsEngelian : Prop :=\n  \u2200 (M : Type u\u2084) [AddCommGroup M],\n    \u2200 [Module R M] [LieRingModule L M],\n      \u2200 [LieModule R L M],\n        \u2200 _ : \u2200 x : L, _root_.IsNilpotent (toEndomorphism R L M x), LieModule.IsNilpotent R L M", "start": [155, 1], "end": [164, 96], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isEngelian_of_subsingleton", "code": "theorem LieAlgebra.isEngelian_of_subsingleton [Subsingleton L] : LieAlgebra.IsEngelian R L", "start": [169, 1], "end": [174, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.isEngelian", "code": "theorem Function.Surjective.isEngelian {f : L \u2192\u2097\u2045R\u2046 L\u2082} (hf : Function.Surjective f)\n    (h : LieAlgebra.IsEngelian.{u\u2081, u\u2082, u\u2084} R L) : LieAlgebra.IsEngelian.{u\u2081, u\u2083, u\u2084} R L\u2082", "start": [177, 1], "end": [187, 51], "kind": "commanddeclaration"}, {"full_name": "LieEquiv.isEngelian_iff", "code": "theorem LieEquiv.isEngelian_iff (e : L \u2243\u2097\u2045R\u2046 L\u2082) :\n    LieAlgebra.IsEngelian.{u\u2081, u\u2082, u\u2084} R L \u2194 LieAlgebra.IsEngelian.{u\u2081, u\u2083, u\u2084} R L\u2082", "start": [190, 1], "end": [192, 58], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer", "code": "theorem LieAlgebra.exists_engelian_lieSubalgebra_of_lt_normalizer {K : LieSubalgebra R L}\n    (hK\u2081 : LieAlgebra.IsEngelian.{u\u2081, u\u2082, u\u2084} R K) (hK\u2082 : K < K.normalizer) :\n    \u2203 (K' : LieSubalgebra R L), LieAlgebra.IsEngelian.{u\u2081, u\u2082, u\u2084} R K' \u2227 K < K'", "start": [196, 1], "end": [220, 89], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isEngelian_of_isNoetherian", "code": "theorem LieAlgebra.isEngelian_of_isNoetherian [IsNoetherian R L] : LieAlgebra.IsEngelian R L", "start": [225, 1], "end": [281, 18], "kind": "commanddeclaration"}, {"full_name": "LieModule.isNilpotent_iff_forall", "code": "theorem LieModule.isNilpotent_iff_forall [IsNoetherian R L] :\n    LieModule.IsNilpotent R L M \u2194 \u2200 x, _root_.IsNilpotent <| toEndomorphism R L M x", "start": [284, 1], "end": [290, 55], "kind": "commanddeclaration"}, {"full_name": "LieModule.isNilpotent_iff_forall'", "code": "theorem LieModule.isNilpotent_iff_forall' [IsNoetherian R M] :\n    LieModule.IsNilpotent R L M \u2194 \u2200 x, _root_.IsNilpotent <| toEndomorphism R L M x", "start": [293, 1], "end": [296, 86], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isNilpotent_iff_forall", "code": "theorem LieAlgebra.isNilpotent_iff_forall [IsNoetherian R L] :\n    LieAlgebra.IsNilpotent R L \u2194 \u2200 x, _root_.IsNilpotent <| LieAlgebra.ad R L x", "start": [298, 1], "end": [301, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/GradedAlgebra/Basic.lean", "Mathlib/RingTheory/Ideal/Operations.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "Ideal.IsHomogeneous", "code": "def Ideal.IsHomogeneous : Prop :=\n  \u2200 (i : \u03b9) \u2983r : A\u2984, r \u2208 I \u2192 (DirectSum.decompose \ud835\udc9c r i : A) \u2208 I", "start": [61, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal", "code": "structure HomogeneousIdeal extends Submodule A A where\n  is_homogeneous' : Ideal.IsHomogeneous \ud835\udc9c toSubmodule", "start": [67, 1], "end": [69, 54], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal", "code": "def HomogeneousIdeal.toIdeal (I : HomogeneousIdeal \ud835\udc9c) : Ideal A :=\n  I.toSubmodule", "start": [74, 1], "end": [76, 16], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.isHomogeneous", "code": "theorem HomogeneousIdeal.isHomogeneous (I : HomogeneousIdeal \ud835\udc9c) : I.toIdeal.IsHomogeneous \ud835\udc9c", "start": [79, 1], "end": [80, 20], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_injective", "code": "theorem HomogeneousIdeal.toIdeal_injective :\n    Function.Injective (HomogeneousIdeal.toIdeal : HomogeneousIdeal \ud835\udc9c \u2192 Ideal A)", "start": [83, 1], "end": [85, 56], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.setLike", "code": "instance HomogeneousIdeal.setLike : SetLike (HomogeneousIdeal \ud835\udc9c) A where\n  coe I := I.toIdeal\n  coe_injective' _ _ h := HomogeneousIdeal.toIdeal_injective <| SetLike.coe_injective h", "start": [88, 1], "end": [90, 88], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.ext", "code": "@[ext]\ntheorem HomogeneousIdeal.ext {I J : HomogeneousIdeal \ud835\udc9c} (h : I.toIdeal = J.toIdeal) : I = J", "start": [93, 1], "end": [95, 39], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.mem_iff", "code": "@[simp]\ntheorem HomogeneousIdeal.mem_iff {I : HomogeneousIdeal \ud835\udc9c} {x : A} : x \u2208 I.toIdeal \u2194 x \u2208 I", "start": [98, 1], "end": [100, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore'", "code": "def Ideal.homogeneousCore' (I : Ideal A) : Ideal A :=\n  Ideal.span ((\u2191) '' (((\u2191) : Subtype (Homogeneous \ud835\udc9c) \u2192 A) \u207b\u00b9' I))", "start": [113, 1], "end": [116, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore'_mono", "code": "theorem Ideal.homogeneousCore'_mono : Monotone (Ideal.homogeneousCore' \ud835\udc9c)", "start": [119, 1], "end": [120, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore'_le", "code": "theorem Ideal.homogeneousCore'_le : I.homogeneousCore' \ud835\udc9c \u2264 I", "start": [123, 1], "end": [124, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.isHomogeneous_iff_forall_subset", "code": "theorem Ideal.isHomogeneous_iff_forall_subset :\n    I.IsHomogeneous \ud835\udc9c \u2194 \u2200 i, (I : Set A) \u2286 GradedRing.proj \ud835\udc9c i \u207b\u00b9' I", "start": [139, 1], "end": [141, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.isHomogeneous_iff_subset_iInter", "code": "theorem Ideal.isHomogeneous_iff_subset_iInter :\n    I.IsHomogeneous \ud835\udc9c \u2194 (I : Set A) \u2286 \u22c2 i, GradedRing.proj \ud835\udc9c i \u207b\u00b9' \u2191I", "start": [144, 1], "end": [146, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_homogeneous_element_mem_of_mem", "code": "theorem Ideal.mul_homogeneous_element_mem_of_mem {I : Ideal A} (r x : A) (hx\u2081 : Homogeneous \ud835\udc9c x)\n    (hx\u2082 : x \u2208 I) (j : \u03b9) : GradedRing.proj \ud835\udc9c j (r * x) \u2208 I", "start": [149, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneous_span", "code": "theorem Ideal.homogeneous_span (s : Set A) (h : \u2200 x \u2208 s, Homogeneous \ud835\udc9c x) :\n    (Ideal.span s).IsHomogeneous \ud835\udc9c", "start": [164, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore", "code": "def Ideal.homogeneousCore : HomogeneousIdeal \ud835\udc9c :=\n  \u27e8Ideal.homogeneousCore' \ud835\udc9c I,\n    Ideal.homogeneous_span _ _ fun _ h => (Subtype.image_preimage_coe _ _ \u25b8 h).2\u27e9", "start": [181, 1], "end": [185, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore_mono", "code": "theorem Ideal.homogeneousCore_mono : Monotone (Ideal.homogeneousCore \ud835\udc9c)", "start": [188, 1], "end": [189, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.toIdeal_homogeneousCore_le", "code": "theorem Ideal.toIdeal_homogeneousCore_le : (I.homogeneousCore \ud835\udc9c).toIdeal \u2264 I", "start": [192, 1], "end": [193, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_homogeneousCore_of_homogeneous_of_mem", "code": "theorem Ideal.mem_homogeneousCore_of_homogeneous_of_mem {x : A} (h : SetLike.Homogeneous \ud835\udc9c x)\n    (hmem : x \u2208 I) : x \u2208 I.homogeneousCore \ud835\udc9c", "start": [198, 1], "end": [200, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self", "code": "theorem Ideal.IsHomogeneous.toIdeal_homogeneousCore_eq_self (h : I.IsHomogeneous \ud835\udc9c) :\n    (I.homogeneousCore \ud835\udc9c).toIdeal = I", "start": [203, 1], "end": [209, 91], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_homogeneousCore_eq_self", "code": "@[simp]\ntheorem HomogeneousIdeal.toIdeal_homogeneousCore_eq_self (I : HomogeneousIdeal \ud835\udc9c) :\n    I.toIdeal.homogeneousCore \ud835\udc9c = I", "start": [212, 1], "end": [216, 78], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iff_eq", "code": "theorem Ideal.IsHomogeneous.iff_eq : I.IsHomogeneous \ud835\udc9c \u2194 (I.homogeneousCore \ud835\udc9c).toIdeal = I", "start": [221, 1], "end": [222, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iff_exists", "code": "theorem Ideal.IsHomogeneous.iff_exists :\n    I.IsHomogeneous \ud835\udc9c \u2194 \u2203 S : Set (homogeneousSubmonoid \ud835\udc9c), I = Ideal.span ((\u2191) '' S)", "start": [225, 1], "end": [228, 80], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.bot", "code": "theorem bot : Ideal.IsHomogeneous \ud835\udc9c \u22a5", "start": [249, 1], "end": [252, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.top", "code": "theorem top : Ideal.IsHomogeneous \ud835\udc9c \u22a4", "start": [255, 1], "end": [255, 87], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.inf", "code": "theorem inf {I J : Ideal A} (HI : I.IsHomogeneous \ud835\udc9c) (HJ : J.IsHomogeneous \ud835\udc9c) :\n    (I \u2293 J).IsHomogeneous \ud835\udc9c", "start": [260, 1], "end": [262, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.sup", "code": "theorem sup {I J : Ideal A} (HI : I.IsHomogeneous \ud835\udc9c) (HJ : J.IsHomogeneous \ud835\udc9c) :\n    (I \u2294 J).IsHomogeneous \ud835\udc9c", "start": [265, 1], "end": [271, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iSup", "code": "protected theorem iSup {\u03ba : Sort*} {f : \u03ba \u2192 Ideal A} (h : \u2200 i, (f i).IsHomogeneous \ud835\udc9c) :\n    (\u2a06 i, f i).IsHomogeneous \ud835\udc9c", "start": [274, 1], "end": [281, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iInf", "code": "protected theorem iInf {\u03ba : Sort*} {f : \u03ba \u2192 Ideal A} (h : \u2200 i, (f i).IsHomogeneous \ud835\udc9c) :\n    (\u2a05 i, f i).IsHomogeneous \ud835\udc9c", "start": [284, 1], "end": [288, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iSup\u2082", "code": "theorem iSup\u2082 {\u03ba : Sort*} {\u03ba' : \u03ba \u2192 Sort*} {f : \u2200 i, \u03ba' i \u2192 Ideal A}\n    (h : \u2200 i j, (f i j).IsHomogeneous \ud835\udc9c) : (\u2a06 (i) (j), f i j).IsHomogeneous \ud835\udc9c", "start": [291, 1], "end": [293, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.iInf\u2082", "code": "theorem iInf\u2082 {\u03ba : Sort*} {\u03ba' : \u03ba \u2192 Sort*} {f : \u2200 i, \u03ba' i \u2192 Ideal A}\n    (h : \u2200 i j, (f i j).IsHomogeneous \ud835\udc9c) : (\u2a05 (i) (j), f i j).IsHomogeneous \ud835\udc9c", "start": [296, 1], "end": [298, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.sSup", "code": "theorem sSup {\u2110 : Set (Ideal A)} (h : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I) :\n    (sSup \u2110).IsHomogeneous \ud835\udc9c", "start": [301, 1], "end": [304, 16], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.sInf", "code": "theorem sInf {\u2110 : Set (Ideal A)} (h : \u2200 I \u2208 \u2110, Ideal.IsHomogeneous \ud835\udc9c I) :\n    (sInf \u2110).IsHomogeneous \ud835\udc9c", "start": [307, 1], "end": [310, 16], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : HomogeneousIdeal \ud835\udc9c) : Set A) = univ", "start": [340, 1], "end": [342, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.coe_bot", "code": "@[simp]\ntheorem coe_bot : ((\u22a5 : HomogeneousIdeal \ud835\udc9c) : Set A) = 0", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.coe_sup", "code": "@[simp]\ntheorem coe_sup (I J : HomogeneousIdeal \ud835\udc9c) : \u2191(I \u2294 J) = (I + J : Set A)", "start": [350, 1], "end": [352, 24], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.coe_inf", "code": "@[simp]\ntheorem coe_inf (I J : HomogeneousIdeal \ud835\udc9c) : (\u2191(I \u2293 J) : Set A) = \u2191I \u2229 \u2191J", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_top", "code": "@[simp]\ntheorem toIdeal_top : (\u22a4 : HomogeneousIdeal \ud835\udc9c).toIdeal = (\u22a4 : Ideal A)", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_bot", "code": "@[simp]\ntheorem toIdeal_bot : (\u22a5 : HomogeneousIdeal \ud835\udc9c).toIdeal = (\u22a5 : Ideal A)", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_sup", "code": "@[simp]\ntheorem toIdeal_sup (I J : HomogeneousIdeal \ud835\udc9c) : (I \u2294 J).toIdeal = I.toIdeal \u2294 J.toIdeal", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_inf", "code": "@[simp]\ntheorem toIdeal_inf (I J : HomogeneousIdeal \ud835\udc9c) : (I \u2293 J).toIdeal = I.toIdeal \u2293 J.toIdeal", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_sSup", "code": "@[simp]\ntheorem toIdeal_sSup (\u2110 : Set (HomogeneousIdeal \ud835\udc9c)) : (sSup \u2110).toIdeal = \u2a06 s \u2208 \u2110, toIdeal s", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_sInf", "code": "@[simp]\ntheorem toIdeal_sInf (\u2110 : Set (HomogeneousIdeal \ud835\udc9c)) : (sInf \u2110).toIdeal = \u2a05 s \u2208 \u2110, toIdeal s", "start": [385, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_iSup", "code": "@[simp]\ntheorem toIdeal_iSup {\u03ba : Sort*} (s : \u03ba \u2192 HomogeneousIdeal \ud835\udc9c) :\n    (\u2a06 i, s i).toIdeal = \u2a06 i, (s i).toIdeal", "start": [390, 1], "end": [393, 38], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_iInf", "code": "@[simp]\ntheorem toIdeal_iInf {\u03ba : Sort*} (s : \u03ba \u2192 HomogeneousIdeal \ud835\udc9c) :\n    (\u2a05 i, s i).toIdeal = \u2a05 i, (s i).toIdeal", "start": [396, 1], "end": [399, 38], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_iSup\u2082", "code": "theorem toIdeal_iSup\u2082 {\u03ba : Sort*} {\u03ba' : \u03ba \u2192 Sort*} (s : \u2200 i, \u03ba' i \u2192 HomogeneousIdeal \ud835\udc9c) :\n    (\u2a06 (i) (j), s i j).toIdeal = \u2a06 (i) (j), (s i j).toIdeal", "start": [403, 1], "end": [405, 25], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_iInf\u2082", "code": "theorem toIdeal_iInf\u2082 {\u03ba : Sort*} {\u03ba' : \u03ba \u2192 Sort*} (s : \u2200 i, \u03ba' i \u2192 HomogeneousIdeal \ud835\udc9c) :\n    (\u2a05 (i) (j), s i j).toIdeal = \u2a05 (i) (j), (s i j).toIdeal", "start": [409, 1], "end": [411, 25], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.eq_top_iff", "code": "@[simp]\ntheorem eq_top_iff (I : HomogeneousIdeal \ud835\udc9c) : I = \u22a4 \u2194 I.toIdeal = \u22a4", "start": [414, 1], "end": [416, 32], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.eq_bot_iff", "code": "@[simp]\ntheorem eq_bot_iff (I : HomogeneousIdeal \ud835\udc9c) : I = \u22a5 \u2194 I.toIdeal = \u22a5", "start": [419, 1], "end": [421, 32], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.completeLattice", "code": "instance completeLattice : CompleteLattice (HomogeneousIdeal \ud835\udc9c) :=\n  toIdeal_injective.completeLattice _ toIdeal_sup toIdeal_inf toIdeal_sSup toIdeal_sInf toIdeal_top\n    toIdeal_bot", "start": [424, 1], "end": [426, 16], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_add", "code": "@[simp]\ntheorem toIdeal_add (I J : HomogeneousIdeal \ud835\udc9c) : (I + J).toIdeal = I.toIdeal + J.toIdeal", "start": [431, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.mul", "code": "theorem Ideal.IsHomogeneous.mul {I J : Ideal A} (HI : I.IsHomogeneous \ud835\udc9c) (HJ : J.IsHomogeneous \ud835\udc9c) :\n    (I * J).IsHomogeneous \ud835\udc9c", "start": [452, 1], "end": [457, 88], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_mul", "code": "@[simp]\ntheorem HomogeneousIdeal.toIdeal_mul (I J : HomogeneousIdeal \ud835\udc9c) :\n    (I * J).toIdeal = I.toIdeal * J.toIdeal", "start": [463, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore.gc", "code": "theorem Ideal.homogeneousCore.gc : GaloisConnection toIdeal (Ideal.homogeneousCore \ud835\udc9c)", "start": [489, 1], "end": [491, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore.gi", "code": "def Ideal.homogeneousCore.gi : GaloisCoinsertion toIdeal (Ideal.homogeneousCore \ud835\udc9c) where\n  choice I HI :=\n    \u27e8I, le_antisymm (I.toIdeal_homogeneousCore_le \ud835\udc9c) HI \u25b8 HomogeneousIdeal.isHomogeneous _\u27e9\n  gc := Ideal.homogeneousCore.gc \ud835\udc9c\n  u_l_le _ := Ideal.homogeneousCore'_le _ _\n  choice_eq I H := le_antisymm H (I.toIdeal_homogeneousCore_le _)", "start": [494, 1], "end": [501, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore_eq_sSup", "code": "theorem Ideal.homogeneousCore_eq_sSup :\n    I.homogeneousCore \ud835\udc9c = sSup { J : HomogeneousIdeal \ud835\udc9c | J.toIdeal \u2264 I }", "start": [504, 1], "end": [506, 78], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousCore'_eq_sSup", "code": "theorem Ideal.homogeneousCore'_eq_sSup :\n    I.homogeneousCore' \ud835\udc9c = sSup { J : Ideal A | J.IsHomogeneous \ud835\udc9c \u2227 J \u2264 I }", "start": [509, 1], "end": [519, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull", "code": "def Ideal.homogeneousHull : HomogeneousIdeal \ud835\udc9c :=\n  \u27e8Ideal.span { r : A | \u2203 (i : \u03b9) (x : I), (DirectSum.decompose \ud835\udc9c (x : A) i : A) = r }, by\n    refine' Ideal.homogeneous_span _ _ fun x hx => _\n    obtain \u27e8i, x, rfl\u27e9 := hx\n    apply SetLike.homogeneous_coe\u27e9", "start": [537, 1], "end": [543, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_toIdeal_homogeneousHull", "code": "theorem Ideal.le_toIdeal_homogeneousHull : I \u2264 (Ideal.homogeneousHull \ud835\udc9c I).toIdeal", "start": [546, 1], "end": [554, 14], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull_mono", "code": "theorem Ideal.homogeneousHull_mono : Monotone (Ideal.homogeneousHull \ud835\udc9c)", "start": [557, 1], "end": [560, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self", "code": "theorem Ideal.IsHomogeneous.toIdeal_homogeneousHull_eq_self (h : I.IsHomogeneous \ud835\udc9c) :\n    (Ideal.homogeneousHull \ud835\udc9c I).toIdeal = I", "start": [565, 1], "end": [570, 19], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.homogeneousHull_toIdeal_eq_self", "code": "@[simp]\ntheorem HomogeneousIdeal.homogeneousHull_toIdeal_eq_self (I : HomogeneousIdeal \ud835\udc9c) :\n    I.toIdeal.homogeneousHull \ud835\udc9c = I", "start": [573, 1], "end": [576, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.toIdeal_homogeneousHull_eq_iSup", "code": "theorem Ideal.toIdeal_homogeneousHull_eq_iSup :\n    (I.homogeneousHull \ud835\udc9c).toIdeal = \u2a06 i, Ideal.span (GradedRing.proj \ud835\udc9c i '' I)", "start": [581, 1], "end": [587, 50], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull_eq_iSup", "code": "theorem Ideal.homogeneousHull_eq_iSup :\n    I.homogeneousHull \ud835\udc9c =\n      \u2a06 i, \u27e8Ideal.span (GradedRing.proj \ud835\udc9c i '' I), Ideal.homogeneous_span \ud835\udc9c _ (by\n        rintro _ \u27e8x, -, rfl\u27e9\n        apply SetLike.homogeneous_coe)\u27e9", "start": [590, 1], "end": [597, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull.gc", "code": "theorem Ideal.homogeneousHull.gc : GaloisConnection (Ideal.homogeneousHull \ud835\udc9c) toIdeal", "start": [610, 1], "end": [612, 81], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull.gi", "code": "def Ideal.homogeneousHull.gi : GaloisInsertion (Ideal.homogeneousHull \ud835\udc9c) toIdeal where\n  choice I H := \u27e8I, le_antisymm H (I.le_toIdeal_homogeneousHull \ud835\udc9c) \u25b8 isHomogeneous _\u27e9\n  gc := Ideal.homogeneousHull.gc \ud835\udc9c\n  le_l_u _ := Ideal.le_toIdeal_homogeneousHull _ _\n  choice_eq I H := le_antisymm (I.le_toIdeal_homogeneousHull \ud835\udc9c) H", "start": [615, 1], "end": [621, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.homogeneousHull_eq_sInf", "code": "theorem Ideal.homogeneousHull_eq_sInf (I : Ideal A) :\n    Ideal.homogeneousHull \ud835\udc9c I = sInf { J : HomogeneousIdeal \ud835\udc9c | I \u2264 J.toIdeal }", "start": [624, 1], "end": [626, 75], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.irrelevant", "code": "def HomogeneousIdeal.irrelevant : HomogeneousIdeal \ud835\udc9c :=\n  \u27e8RingHom.ker (GradedRing.projZeroRingHom \ud835\udc9c), fun i r (hr : (decompose \ud835\udc9c r 0 : A) = 0) => by\n    change (decompose \ud835\udc9c (decompose \ud835\udc9c r _ : A) 0 : A) = 0\n    by_cases h : i = 0\n    \u00b7 rw [h, hr, decompose_zero, zero_apply, ZeroMemClass.coe_zero]\n    \u00b7 rw [decompose_of_mem_ne \ud835\udc9c (SetLike.coe_mem _) h]\u27e9", "start": [643, 1], "end": [658, 56], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.mem_irrelevant_iff", "code": "@[simp]\ntheorem HomogeneousIdeal.mem_irrelevant_iff (a : A) :\n    a \u2208 HomogeneousIdeal.irrelevant \ud835\udc9c \u2194 proj \ud835\udc9c 0 a = 0", "start": [661, 1], "end": [664, 10], "kind": "commanddeclaration"}, {"full_name": "HomogeneousIdeal.toIdeal_irrelevant", "code": "@[simp]\ntheorem HomogeneousIdeal.toIdeal_irrelevant :\n    (HomogeneousIdeal.irrelevant \ud835\udc9c).toIdeal = RingHom.ker (GradedRing.projZeroRingHom \ud835\udc9c)", "start": [667, 1], "end": [670, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/Injective.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Projective.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Injective", "code": "class Injective (J : C) : Prop where\n  factors : \u2200 {X Y : C} (g : X \u27f6 J) (f : X \u27f6 Y) [Mono f], \u2203 h : Y \u27f6 J, f \u226b h = g", "start": [31, 1], "end": [35, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectivePresentation", "code": "structure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X \u27f6 J\n  mono : Mono f := by infer_instance", "start": [42, 1], "end": [49, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EnoughInjectives", "code": "class EnoughInjectives : Prop where\n  presentation : \u2200 X : C, Nonempty (InjectivePresentation X)", "start": [59, 1], "end": [62, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.factorThru", "code": "def factorThru {J X Y : C} [Injective J] (g : X \u27f6 J) (f : X \u27f6 Y) [Mono f] : Y \u27f6 J :=\n  (Injective.factors g f).choose", "start": [71, 1], "end": [75, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.comp_factorThru", "code": "@[simp]\ntheorem comp_factorThru {J X Y : C} [Injective J] (g : X \u27f6 J) (f : X \u27f6 Y) [Mono f] :\n    f \u226b factorThru g f = g", "start": [78, 1], "end": [81, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.zero_injective", "code": "instance zero_injective [HasZeroObject C] [HasZeroMorphisms C] : Injective (0 : C) where\n  factors g f := \u27e80, by ext\u27e9", "start": [88, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.of_iso", "code": "theorem of_iso {P Q : C} (i : P \u2245 Q) (hP : Injective P) : Injective Q", "start": [94, 1], "end": [99, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.iso_iff", "code": "theorem iso_iff {P Q : C} (i : P \u2245 Q) : Injective P \u2194 Injective Q", "start": [102, 1], "end": [103, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.Type.enoughInjectives", "code": "instance Type.enoughInjectives : EnoughInjectives (Type u\u2081) where\n  presentation X :=\n    Nonempty.intro\n      { J := WithBot X\n        injective := inferInstance\n        f := Option.some\n        mono := by\n          rw [mono_iff_injective]\n          exact Option.some_injective X }", "start": [121, 1], "end": [129, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.injective_iff_projective_op", "code": "theorem injective_iff_projective_op {J : C} : Injective J \u2194 Projective (op J)", "start": [181, 1], "end": [182, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.projective_iff_injective_op", "code": "theorem projective_iff_injective_op {P : C} : Projective P \u2194 Injective (op P)", "start": [185, 1], "end": [186, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.injective_iff_preservesEpimorphisms_yoneda_obj", "code": "theorem injective_iff_preservesEpimorphisms_yoneda_obj (J : C) :\n    Injective J \u2194 (yoneda.obj J).PreservesEpimorphisms", "start": [189, 1], "end": [192, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.injective_of_adjoint", "code": "theorem injective_of_adjoint (adj : L \u22a3 R) (J : D) [Injective J] : Injective <| R.obj J", "start": [203, 1], "end": [206, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.under", "code": "def under (X : C) : C :=\n  (EnoughInjectives.presentation X).some.J", "start": [215, 1], "end": [219, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.injective_under", "code": "instance injective_under (X : C) : Injective (under X) :=\n  (EnoughInjectives.presentation X).some.injective", "start": [222, 1], "end": [223, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.\u03b9", "code": "def \u03b9 (X : C) : X \u27f6 under X :=\n  (EnoughInjectives.presentation X).some.f", "start": [226, 1], "end": [230, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.\u03b9_mono", "code": "instance \u03b9_mono (X : C) : Mono (\u03b9 X) :=\n  (EnoughInjectives.presentation X).some.mono", "start": [233, 1], "end": [234, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.syzygies", "code": "def syzygies : C :=\n  under (cokernel f)", "start": [241, 1], "end": [245, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.d", "code": "abbrev d : Y \u27f6 syzygies f :=\n  cokernel.\u03c0 f \u226b \u03b9 (cokernel f)", "start": [250, 1], "end": [257, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.enoughProjectives_of_enoughInjectives_op", "code": "theorem enoughProjectives_of_enoughInjectives_op [EnoughInjectives C\u1d52\u1d56] : EnoughProjectives C", "start": [270, 1], "end": [271, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.enoughInjectives_of_enoughProjectives_op", "code": "theorem enoughInjectives_of_enoughProjectives_op [EnoughProjectives C\u1d52\u1d56] : EnoughInjectives C", "start": [274, 1], "end": [275, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.Exact.desc", "code": "def Exact.desc {J Q R S : C} [Injective J] (h : R \u27f6 J) (f : Q \u27f6 R) (g : R \u27f6 S)\n    (hgf : Exact g.op f.op) (w : f \u226b h = 0) : S \u27f6 J :=\n  (Exact.lift h.op g.op f.op hgf (congr_arg Quiver.Hom.op w)).unop", "start": [284, 1], "end": [297, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Injective.Exact.comp_desc", "code": "@[simp]\ntheorem Exact.comp_desc {J Q R S : C} [Injective J] (h : R \u27f6 J) (f : Q \u27f6 R) (g : R \u27f6 S)\n    (hgf : Exact g.op f.op) (w : f \u226b h = 0) : g \u226b Exact.desc h f g hgf w = h", "start": [300, 1], "end": [303, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.map_injective", "code": "theorem map_injective (adj : F \u22a3 G) [F.PreservesMonomorphisms] (I : D) (hI : Injective I) :\n    Injective (G.obj I)", "start": [314, 1], "end": [321, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.injective_of_map_injective", "code": "theorem injective_of_map_injective (adj : F \u22a3 G) [Full G] [Faithful G] (I : D)\n    (hI : Injective (G.obj I)) : Injective I", "start": [324, 1], "end": [332, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.mapInjectivePresentation", "code": "def mapInjectivePresentation (adj : F \u22a3 G) [F.PreservesMonomorphisms] (X : D)\n    (I : InjectivePresentation X) : InjectivePresentation (G.obj X) where\n  J := G.obj I.J\n  injective := adj.map_injective _ I.injective\n  f := G.map I.f\n  mono := by\n    haveI : PreservesLimitsOfSize.{0, 0} G := adj.rightAdjointPreservesLimits; infer_instance", "start": [335, 1], "end": [343, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.map_injective_iff", "code": "theorem map_injective_iff (P : C) : Injective (F.functor.obj P) \u2194 Injective P", "start": [352, 1], "end": [353, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.injectivePresentationOfMapInjectivePresentation", "code": "def injectivePresentationOfMapInjectivePresentation (X : C)\n    (I : InjectivePresentation (F.functor.obj X)) : InjectivePresentation X where\n  J := F.inverse.obj I.J\n  injective := Adjunction.map_injective F.toAdjunction I.J I.injective\n  f := F.unit.app _ \u226b F.inverse.map I.f\n  mono := mono_comp _ _", "start": [355, 1], "end": [362, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.enoughInjectives_iff", "code": "theorem enoughInjectives_iff (F : C \u224c D) : EnoughInjectives C \u2194 EnoughInjectives D", "start": [365, 1], "end": [373, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Opposite.lean", "imports": ["Mathlib/Data/Set/Image.lean", "Mathlib/Data/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.op", "code": "protected def op (s : Set \u03b1) : Set \u03b1\u1d52\u1d56 :=\n  unop \u207b\u00b9' s", "start": [23, 1], "end": [25, 13], "kind": "commanddeclaration"}, {"full_name": "Set.unop", "code": "protected def unop (s : Set \u03b1\u1d52\u1d56) : Set \u03b1 :=\n  op \u207b\u00b9' s", "start": [28, 1], "end": [30, 11], "kind": "commanddeclaration"}, {"full_name": "Set.mem_op", "code": "@[simp]\ntheorem mem_op {s : Set \u03b1} {a : \u03b1\u1d52\u1d56} : a \u2208 s.op \u2194 unop a \u2208 s", "start": [33, 1], "end": [35, 10], "kind": "commanddeclaration"}, {"full_name": "Set.op_mem_op", "code": "@[simp 1100]\ntheorem op_mem_op {s : Set \u03b1} {a : \u03b1} : op a \u2208 s.op \u2194 a \u2208 s", "start": [38, 1], "end": [39, 70], "kind": "commanddeclaration"}, {"full_name": "Set.mem_unop", "code": "@[simp]\ntheorem mem_unop {s : Set \u03b1\u1d52\u1d56} {a : \u03b1} : a \u2208 s.unop \u2194 op a \u2208 s", "start": [42, 1], "end": [44, 10], "kind": "commanddeclaration"}, {"full_name": "Set.unop_mem_unop", "code": "@[simp 1100]\ntheorem unop_mem_unop {s : Set \u03b1\u1d52\u1d56} {a : \u03b1\u1d52\u1d56} : unop a \u2208 s.unop \u2194 a \u2208 s", "start": [47, 1], "end": [48, 82], "kind": "commanddeclaration"}, {"full_name": "Set.op_unop", "code": "@[simp]\ntheorem op_unop (s : Set \u03b1) : s.op.unop = s", "start": [51, 1], "end": [52, 51], "kind": "commanddeclaration"}, {"full_name": "Set.unop_op", "code": "@[simp]\ntheorem unop_op (s : Set \u03b1\u1d52\u1d56) : s.unop.op = s", "start": [55, 1], "end": [56, 53], "kind": "commanddeclaration"}, {"full_name": "Set.opEquiv_self", "code": "@[simps]\ndef opEquiv_self (s : Set \u03b1) : s.op \u2243 s :=\n  \u27e8fun x \u21a6 \u27e8unop x, x.2\u27e9, fun x \u21a6 \u27e8op x, x.2\u27e9, fun _ \u21a6 rfl, fun _ \u21a6 rfl\u27e9", "start": [59, 1], "end": [62, 73], "kind": "commanddeclaration"}, {"full_name": "Set.opEquiv", "code": "@[simps]\ndef opEquiv : Set \u03b1 \u2243 Set \u03b1\u1d52\u1d56 :=\n  \u27e8Set.op, Set.unop, op_unop, unop_op\u27e9", "start": [67, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_op", "code": "@[simp]\ntheorem singleton_op (x : \u03b1) : ({x} : Set \u03b1).op = {op x}", "start": [75, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_unop", "code": "@[simp]\ntheorem singleton_unop (x : \u03b1\u1d52\u1d56) : ({x} : Set \u03b1\u1d52\u1d56).unop = {unop x}", "start": [83, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_op_unop", "code": "@[simp 1100]\ntheorem singleton_op_unop (x : \u03b1) : ({op x} : Set \u03b1\u1d52\u1d56).unop = {x}", "start": [91, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_unop_op", "code": "@[simp 1100]\ntheorem singleton_unop_op (x : \u03b1\u1d52\u1d56) : ({unop x} : Set \u03b1).op = {x}", "start": [99, 1], "end": [104, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/EssentiallySmall.lean", "imports": ["Mathlib/CategoryTheory/EssentiallySmall.lean", "Mathlib/CategoryTheory/Limits/Shapes/Products.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.hasLimitsOfShape_of_essentiallySmall", "code": "theorem hasLimitsOfShape_of_essentiallySmall [EssentiallySmall.{w\u2081} J]\n    [HasLimitsOfSize.{w\u2081, w\u2081} C] : HasLimitsOfShape J C", "start": [31, 1], "end": [33, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasColimitsOfShape_of_essentiallySmall", "code": "theorem hasColimitsOfShape_of_essentiallySmall [EssentiallySmall.{w\u2081} J]\n    [HasColimitsOfSize.{w\u2081, w\u2081} C] : HasColimitsOfShape J C", "start": [36, 1], "end": [38, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasProductsOfShape_of_small", "code": "theorem hasProductsOfShape_of_small (\u03b2 : Type w\u2082) [Small.{w\u2081} \u03b2] [HasProducts.{w\u2081} C] :\n    HasProductsOfShape \u03b2 C", "start": [41, 1], "end": [43, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoproductsOfShape_of_small", "code": "theorem hasCoproductsOfShape_of_small (\u03b2 : Type w\u2082) [Small.{w\u2081} \u03b2] [HasCoproducts.{w\u2081} C] :\n    HasCoproductsOfShape \u03b2 C", "start": [46, 1], "end": [48, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/Predicate.lean", "imports": ["Mathlib/CategoryTheory/Localization/Construction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.IsLocalization", "code": "class IsLocalization : Prop where\n  \n  inverts : W.IsInvertedBy L\n  \n  nonempty_isEquivalence : Nonempty (IsEquivalence (Localization.Construction.lift L inverts))", "start": [47, 1], "end": [54, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.q_isLocalization", "code": "instance q_isLocalization : W.Q.IsLocalization W\n    where\n  inverts := W.Q_inverts\n  nonempty_isEquivalence := by\n    suffices Localization.Construction.lift W.Q W.Q_inverts = \ud835\udfed _ by\n      apply Nonempty.intro\n      rw [this]\n      infer_instance\n    apply Localization.Construction.uniq\n    simp only [Localization.Construction.fac]\n    rfl", "start": [57, 1], "end": [67, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.StrictUniversalPropertyFixedTarget", "code": "structure StrictUniversalPropertyFixedTarget where\n  \n  inverts : W.IsInvertedBy L\n  \n  lift : \u2200 (F : C \u2964 E) (_ : W.IsInvertedBy F), D \u2964 E\n  \n  fac : \u2200 (F : C \u2964 E) (hF : W.IsInvertedBy F), L \u22d9 lift F hF = F\n  \n  uniq : \u2200 (F\u2081 F\u2082 : D \u2964 E) (_ : L \u22d9 F\u2081 = L \u22d9 F\u2082), F\u2081 = F\u2082", "start": [75, 1], "end": [86, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.strictUniversalPropertyFixedTargetQ", "code": "@[simps]\ndef strictUniversalPropertyFixedTargetQ : StrictUniversalPropertyFixedTarget W.Q W E\n    where\n  inverts := W.Q_inverts\n  lift := Construction.lift\n  fac := Construction.fac\n  uniq := Construction.uniq", "start": [89, 1], "end": [97, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.strictUniversalPropertyFixedTargetId", "code": "@[simps]\ndef strictUniversalPropertyFixedTargetId (hW : W \u2286 MorphismProperty.isomorphisms C) :\n    StrictUniversalPropertyFixedTarget (\ud835\udfed C) W E\n    where\n  inverts X Y f hf := hW f hf\n  lift F _ := F\n  fac F hF := by\n    cases F\n    rfl\n  uniq F\u2081 F\u2082 eq := by\n    cases F\u2081\n    cases F\u2082\n    exact eq", "start": [104, 1], "end": [118, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.mk'", "code": "theorem IsLocalization.mk' (h\u2081 : Localization.StrictUniversalPropertyFixedTarget L W D)\n    (h\u2082 : Localization.StrictUniversalPropertyFixedTarget L W W.Localization) :\n    IsLocalization L W", "start": [125, 1], "end": [147, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.for_id", "code": "theorem IsLocalization.for_id (hW : W \u2286 MorphismProperty.isomorphisms C) : (\ud835\udfed C).IsLocalization W", "start": [150, 1], "end": [152, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.inverts", "code": "theorem inverts : W.IsInvertedBy L", "start": [161, 1], "end": [162, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.isoOfHom", "code": "@[simps!]\ndef isoOfHom {X Y : C} (f : X \u27f6 Y) (hf : W f) : L.obj X \u2245 L.obj Y :=\n  haveI : IsIso (L.map f) := inverts L W f hf\n  asIso (L.map f)", "start": [165, 1], "end": [170, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.equivalenceFromModel", "code": "def equivalenceFromModel : W.Localization \u224c D :=\n  (Localization.Construction.lift L (inverts L W)).asEquivalence", "start": [176, 1], "end": [180, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.qCompEquivalenceFromModelFunctorIso", "code": "def qCompEquivalenceFromModelFunctorIso : W.Q \u22d9 (equivalenceFromModel L W).functor \u2245 L :=\n  eqToIso (Construction.fac _ _)", "start": [183, 1], "end": [186, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.compEquivalenceFromModelInverseIso", "code": "def compEquivalenceFromModelInverseIso : L \u22d9 (equivalenceFromModel L W).inverse \u2245 W.Q :=\n  calc\n    L \u22d9 (equivalenceFromModel L W).inverse \u2245 _ :=\n      isoWhiskerRight (qCompEquivalenceFromModelFunctorIso L W).symm _\n    _ \u2245 W.Q \u22d9 (equivalenceFromModel L W).functor \u22d9 (equivalenceFromModel L W).inverse :=\n      (Functor.associator _ _ _)\n    _ \u2245 W.Q \u22d9 \ud835\udfed _ := (isoWhiskerLeft _ (equivalenceFromModel L W).unitIso.symm)\n    _ \u2245 W.Q := Functor.rightUnitor _", "start": [190, 1], "end": [199, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.essSurj", "code": "theorem essSurj : EssSurj L", "start": [202, 1], "end": [207, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.whiskeringLeftFunctor", "code": "def whiskeringLeftFunctor : (D \u2964 E) \u2964 W.FunctorsInverting E :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ E).obj L)\n    (MorphismProperty.IsInvertedBy.of_comp W L (inverts L W))", "start": [210, 1], "end": [214, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.functorEquivalence", "code": "def functorEquivalence : D \u2964 E \u224c W.FunctorsInverting E :=\n  (whiskeringLeftFunctor L W E).asEquivalence", "start": [241, 1], "end": [245, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.whiskeringLeftFunctor'", "code": "@[nolint unusedArguments]\ndef whiskeringLeftFunctor' (_ : MorphismProperty C) (E : Type*) [Category E] :\n    (D \u2964 E) \u2964 C \u2964 E :=\n  (whiskeringLeft C D E).obj L", "start": [248, 1], "end": [253, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.whiskeringLeftFunctor'_eq", "code": "theorem whiskeringLeftFunctor'_eq :\n    whiskeringLeftFunctor' L W E = Localization.whiskeringLeftFunctor L W E \u22d9 inducedFunctor _", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.whiskeringLeftFunctor'_obj", "code": "@[simp]\ntheorem whiskeringLeftFunctor'_obj (F : D \u2964 E) : (whiskeringLeftFunctor' L W E).obj F = L \u22d9 F", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.natTrans_ext", "code": "theorem natTrans_ext {F\u2081 F\u2082 : D \u2964 E} (\u03c4 \u03c4' : F\u2081 \u27f6 F\u2082)\n    (h : \u2200 X : C, \u03c4.app (L.obj X) = \u03c4'.app (L.obj X)) : \u03c4 = \u03c4'", "start": [280, 1], "end": [284, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting", "code": "class Lifting (W : MorphismProperty C) (F : C \u2964 E) (F' : D \u2964 E) where\n  \n  iso' : L \u22d9 F' \u2245 F", "start": [289, 1], "end": [294, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting.iso", "code": "def Lifting.iso (F : C \u2964 E) (F' : D \u2964 E) [Lifting L W F F'] :\n    L \u22d9 F' \u2245 F :=\n  Lifting.iso' W", "start": [297, 1], "end": [300, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.lift", "code": "def lift (F : C \u2964 E) (hF : W.IsInvertedBy F) (L : C \u2964 D) [L.IsLocalization W] : D \u2964 E :=\n  (functorEquivalence L W E).inverse.obj \u27e8F, hF\u27e9", "start": [304, 1], "end": [308, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftingLift", "code": "instance liftingLift (F : C \u2964 E) (hF : W.IsInvertedBy F) (L : C \u2964 D) [L.IsLocalization W] :\n    Lifting L W F (lift F hF L) :=\n  \u27e8(inducedFunctor _).mapIso ((functorEquivalence L W E).counitIso.app \u27e8F, hF\u27e9)\u27e9", "start": [311, 1], "end": [313, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.fac", "code": "def fac (F : C \u2964 E) (hF : W.IsInvertedBy F) (L : C \u2964 D) [L.IsLocalization W] :\n    L \u22d9 lift F hF L \u2245 F :=\n  Lifting.iso L W F _", "start": [317, 1], "end": [321, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftingConstructionLift", "code": "instance liftingConstructionLift (F : C \u2964 D) (hF : W.IsInvertedBy F) :\n    Lifting W.Q W F (Construction.lift F hF) :=\n  \u27e8eqToIso (Construction.fac F hF)\u27e9", "start": [324, 1], "end": [326, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftNatTrans", "code": "def liftNatTrans (F\u2081 F\u2082 : C \u2964 E) (F\u2081' F\u2082' : D \u2964 E) [Lifting L W F\u2081 F\u2081'] [Lifting L W F\u2082 F\u2082']\n    (\u03c4 : F\u2081 \u27f6 F\u2082) : F\u2081' \u27f6 F\u2082' :=\n  (whiskeringLeftFunctor' L W E).preimage\n    ((Lifting.iso L W F\u2081 F\u2081').hom \u226b \u03c4 \u226b (Lifting.iso L W F\u2082 F\u2082').inv)", "start": [331, 1], "end": [337, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftNatTrans_app", "code": "@[simp]\ntheorem liftNatTrans_app (F\u2081 F\u2082 : C \u2964 E) (F\u2081' F\u2082' : D \u2964 E) [Lifting L W F\u2081 F\u2081'] [Lifting L W F\u2082 F\u2082']\n    (\u03c4 : F\u2081 \u27f6 F\u2082) (X : C) :\n    (liftNatTrans L W F\u2081 F\u2082 F\u2081' F\u2082' \u03c4).app (L.obj X) =\n      (Lifting.iso L W F\u2081 F\u2081').hom.app X \u226b \u03c4.app X \u226b (Lifting.iso L W F\u2082 F\u2082').inv.app X", "start": [340, 1], "end": [345, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.comp_liftNatTrans", "code": "@[reassoc (attr := simp)]\ntheorem comp_liftNatTrans (F\u2081 F\u2082 F\u2083 : C \u2964 E) (F\u2081' F\u2082' F\u2083' : D \u2964 E) [h\u2081 : Lifting L W F\u2081 F\u2081']\n    [h\u2082 : Lifting L W F\u2082 F\u2082'] [h\u2083 : Lifting L W F\u2083 F\u2083'] (\u03c4 : F\u2081 \u27f6 F\u2082) (\u03c4' : F\u2082 \u27f6 F\u2083) :\n    liftNatTrans L W F\u2081 F\u2082 F\u2081' F\u2082' \u03c4 \u226b liftNatTrans L W F\u2082 F\u2083 F\u2082' F\u2083' \u03c4' =\n      liftNatTrans L W F\u2081 F\u2083 F\u2081' F\u2083' (\u03c4 \u226b \u03c4')", "start": [348, 1], "end": [354, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftNatTrans_id", "code": "@[simp]\ntheorem liftNatTrans_id (F : C \u2964 E) (F' : D \u2964 E) [h : Lifting L W F F'] :\n    liftNatTrans L W F F F' F' (\ud835\udfd9 F) = \ud835\udfd9 F'", "start": [357, 1], "end": [362, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.liftNatIso", "code": "@[simps]\ndef liftNatIso (F\u2081 F\u2082 : C \u2964 E) (F\u2081' F\u2082' : D \u2964 E) [h\u2081 : Lifting L W F\u2081 F\u2081'] [h\u2082 : Lifting L W F\u2082 F\u2082']\n    (e : F\u2081 \u2245 F\u2082) : F\u2081' \u2245 F\u2082'\n    where\n  hom := liftNatTrans L W F\u2081 F\u2082 F\u2081' F\u2082' e.hom\n  inv := liftNatTrans L W F\u2082 F\u2081 F\u2082' F\u2081' e.inv", "start": [365, 1], "end": [373, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting.compRight", "code": "@[simps]\ninstance compRight {E' : Type*} [Category E'] (F : C \u2964 E) (F' : D \u2964 E) [Lifting L W F F']\n    (G : E \u2964 E') : Lifting L W (F \u22d9 G) (F' \u22d9 G) :=\n  \u27e8isoWhiskerRight (iso L W F F') G\u27e9", "start": [378, 1], "end": [381, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting.id", "code": "@[simps]\ninstance id : Lifting L W L (\ud835\udfed D) :=\n  \u27e8Functor.rightUnitor L\u27e9", "start": [384, 1], "end": [386, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting.compLeft", "code": "@[simps]\ninstance compLeft (F : D \u2964 E) : Localization.Lifting L W (L \u22d9 F) F := \u27e8Iso.refl _\u27e9", "start": [389, 1], "end": [390, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.Lifting.ofIsos", "code": "@[simps]\ndef ofIsos {F\u2081 F\u2082 : C \u2964 E} {F\u2081' F\u2082' : D \u2964 E} (e : F\u2081 \u2245 F\u2082) (e' : F\u2081' \u2245 F\u2082') [Lifting L W F\u2081 F\u2081'] :\n    Lifting L W F\u2082 F\u2082' :=\n  \u27e8isoWhiskerLeft L e'.symm \u226a\u226b iso L W F\u2081 F\u2081' \u226a\u226b e\u27e9", "start": [392, 1], "end": [398, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.of_iso", "code": "theorem of_iso {L\u2081 L\u2082 : C \u2964 D} (e : L\u2081 \u2245 L\u2082) [L\u2081.IsLocalization W] : L\u2082.IsLocalization W", "start": [411, 1], "end": [419, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.of_equivalence_target", "code": "theorem of_equivalence_target {E : Type*} [Category E] (L' : C \u2964 E) (eq : D \u224c E)\n    [L.IsLocalization W] (e : L \u22d9 eq.functor \u2245 L') : L'.IsLocalization W", "start": [422, 1], "end": [434, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.uniq", "code": "def uniq : D\u2081 \u224c D\u2082 :=\n  (equivalenceFromModel L\u2081 W').symm.trans (equivalenceFromModel L\u2082 W')", "start": [446, 1], "end": [449, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.uniq_symm", "code": "lemma uniq_symm : (uniq L\u2081 L\u2082 W').symm = uniq L\u2082 L\u2081 W' := rfl", "start": [451, 1], "end": [451, 62], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Localization.compUniqFunctor", "code": "def compUniqFunctor : L\u2081 \u22d9 (uniq L\u2081 L\u2082 W').functor \u2245 L\u2082 :=\n  calc\n    L\u2081 \u22d9 (uniq L\u2081 L\u2082 W').functor \u2245 (L\u2081 \u22d9 (equivalenceFromModel L\u2081 W').inverse) \u22d9\n      (equivalenceFromModel L\u2082 W').functor := (Functor.associator _ _ _).symm\n    _ \u2245 W'.Q \u22d9 (equivalenceFromModel L\u2082 W').functor :=\n      isoWhiskerRight (compEquivalenceFromModelInverseIso L\u2081 W') _\n    _ \u2245 L\u2082 := qCompEquivalenceFromModelFunctorIso L\u2082 W'", "start": [453, 1], "end": [461, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.compUniqInverse", "code": "def compUniqInverse : L\u2082 \u22d9 (uniq L\u2081 L\u2082 W').inverse \u2245 L\u2081 := compUniqFunctor L\u2082 L\u2081 W'", "start": [463, 1], "end": [465, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.isoUniqFunctor", "code": "def isoUniqFunctor (F : D\u2081 \u2964 D\u2082) (e : L\u2081 \u22d9 F \u2245 L\u2082) :\n    F \u2245 (uniq L\u2081 L\u2082 W').functor :=\n  letI : Lifting L\u2081 W' L\u2082 F := \u27e8e\u27e9\n  liftNatIso L\u2081 W' L\u2082 L\u2082 F (uniq L\u2081 L\u2082 W').functor (Iso.refl L\u2082)", "start": [470, 1], "end": [476, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/CatCommSq.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.CatCommSq", "code": "@[ext]\nclass CatCommSq where\n  \n  iso' : T \u22d9 R \u2245 L \u22d9 B", "start": [30, 1], "end": [36, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.iso", "code": "def iso [h : CatCommSq T L R B] : T \u22d9 R \u2245 L \u22d9 B := h.iso'", "start": [40, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.hComp", "code": "@[simps! iso'_hom_app iso'_inv_app]\ndef hComp (T\u2081 : C\u2081 \u2964 C\u2082) (T\u2082 : C\u2082 \u2964 C\u2083) (V\u2081 : C\u2081 \u2964 C\u2084) (V\u2082 : C\u2082 \u2964 C\u2085) (V\u2083 : C\u2083 \u2964 C\u2086)\n    (B\u2081 : C\u2084 \u2964 C\u2085) (B\u2082 : C\u2085 \u2964 C\u2086) [CatCommSq T\u2081 V\u2081 V\u2082 B\u2081] [CatCommSq T\u2082 V\u2082 V\u2083 B\u2082] :\n    CatCommSq (T\u2081 \u22d9 T\u2082) V\u2081 V\u2083 (B\u2081 \u22d9 B\u2082) where\n  iso' := Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft T\u2081 (iso T\u2082 V\u2082 V\u2083 B\u2082) \u226a\u226b\n    (Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight (iso T\u2081 V\u2081 V\u2082 B\u2081) B\u2082 \u226a\u226b\n    Functor.associator _ _ _", "start": [44, 1], "end": [51, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.vComp", "code": "@[simps! iso'_hom_app iso'_inv_app]\ndef vComp (L\u2081 : C\u2081 \u2964 C\u2082) (L\u2082 : C\u2082 \u2964 C\u2083) (H\u2081 : C\u2081 \u2964 C\u2084) (H\u2082 : C\u2082 \u2964 C\u2085) (H\u2083 : C\u2083 \u2964 C\u2086)\n    (R\u2081 : C\u2084 \u2964 C\u2085) (R\u2082 : C\u2085 \u2964 C\u2086) [CatCommSq H\u2081 L\u2081 R\u2081 H\u2082] [CatCommSq H\u2082 L\u2082 R\u2082 H\u2083] :\n    CatCommSq H\u2081 (L\u2081 \u22d9 L\u2082) (R\u2081 \u22d9 R\u2082) H\u2083 where\n  iso' := (Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight (iso H\u2081 L\u2081 R\u2081 H\u2082) R\u2082 \u226a\u226b\n      Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft L\u2081 (iso H\u2082 L\u2082 R\u2082 H\u2083) \u226a\u226b\n      (Functor.associator _ _ _).symm", "start": [53, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.hInv", "code": "@[simps! iso'_hom_app iso'_inv_app]\ndef hInv (_ : CatCommSq T.functor L R B.functor) : CatCommSq T.inverse R L B.inverse where\n  iso' := isoWhiskerLeft _ (L.rightUnitor.symm \u226a\u226b isoWhiskerLeft L B.unitIso \u226a\u226b\n      (Functor.associator _ _ _).symm \u226a\u226b\n      isoWhiskerRight (iso T.functor L R B.functor).symm B.inverse \u226a\u226b\n      Functor.associator _ _ _  ) \u226a\u226b (Functor.associator _ _ _).symm \u226a\u226b\n      isoWhiskerRight T.counitIso _ \u226a\u226b Functor.leftUnitor _", "start": [66, 1], "end": [73, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.hInv_hInv", "code": "lemma hInv_hInv (h : CatCommSq T.functor L R B.functor) :\n    hInv T.symm R L B.symm (hInv T L R B h) = h := by\n  ext X\n  erw [\u2190 cancel_mono (B.functor.map (L.map (T.unitIso.hom.app X))),\n    \u2190 h.iso'.hom.naturality (T.unitIso.hom.app X), hInv_iso'_hom_app, hInv_iso'_inv_app]\n  dsimp\n  simp only [Functor.comp_obj, assoc, \u2190 Functor.map_comp, Iso.inv_hom_id_app,\n    Equivalence.counitInv_app_functor, Functor.map_id]\n  simp only [Functor.map_comp, Equivalence.fun_inv_map, assoc,\n    Equivalence.counitInv_functor_comp, comp_id, Iso.inv_hom_id_app_assoc]\n  rfl", "start": [75, 1], "end": [85, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CatCommSq.hInvEquiv", "code": "def hInvEquiv : CatCommSq T.functor L R B.functor \u2243 CatCommSq T.inverse R L B.inverse where\n  toFun := hInv T L R B\n  invFun := hInv T.symm R L B.symm\n  left_inv := hInv_hInv T L R B\n  right_inv := hInv_hInv T.symm R L B.symm", "start": [87, 1], "end": [94, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CatCommSq.hInv'", "code": "instance hInv' [h : CatCommSq T L R B] [IsEquivalence T] [IsEquivalence B] :\n    CatCommSq T.inv R L B.inv :=\n  hInv T.asEquivalence L R B.asEquivalence h", "start": [98, 1], "end": [100, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean", "imports": ["Mathlib/NumberTheory/Zsqrtd/Basic.lean", "Mathlib/Data/Complex/Basic.lean", "Mathlib/RingTheory/PrincipalIdealDomain.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GaussianInt", "code": "@[reducible]\ndef GaussianInt : Type :=\n  Zsqrtd (-1)", "start": [46, 1], "end": [49, 14], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.instCommRing", "code": "instance instCommRing : CommRing \u2124[i] :=\n  Zsqrtd.commRing", "start": [59, 1], "end": [60, 18], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex", "code": "def toComplex : \u2124[i] \u2192+* \u2102 :=\n  Zsqrtd.lift \u27e8I, by simp\u27e9", "start": [67, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_def", "code": "theorem toComplex_def (x : \u2124[i]) : (x : \u2102) = x.re + x.im * I", "start": [77, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_def'", "code": "theorem toComplex_def' (x y : \u2124) : ((\u27e8x, y\u27e9 : \u2124[i]) : \u2102) = x + y * I", "start": [81, 1], "end": [81, 96], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_def\u2082", "code": "theorem toComplex_def\u2082 (x : \u2124[i]) : (x : \u2102) = \u27e8x.re, x.im\u27e9", "start": [84, 1], "end": [85, 45], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.to_real_re", "code": "@[simp]\ntheorem to_real_re (x : \u2124[i]) : ((x.re : \u2124) : \u211d) = (x : \u2102).re", "start": [88, 1], "end": [89, 89], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.to_real_im", "code": "@[simp]\ntheorem to_real_im (x : \u2124[i]) : ((x.im : \u2124) : \u211d) = (x : \u2102).im", "start": [92, 1], "end": [93, 89], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_re", "code": "@[simp]\ntheorem toComplex_re (x y : \u2124) : ((\u27e8x, y\u27e9 : \u2124[i]) : \u2102).re = x", "start": [96, 1], "end": [97, 89], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_im", "code": "@[simp]\ntheorem toComplex_im (x y : \u2124) : ((\u27e8x, y\u27e9 : \u2124[i]) : \u2102).im = y", "start": [100, 1], "end": [101, 89], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_add", "code": "theorem toComplex_add (x y : \u2124[i]) : ((x + y : \u2124[i]) : \u2102) = x + y", "start": [105, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_mul", "code": "theorem toComplex_mul (x y : \u2124[i]) : ((x * y : \u2124[i]) : \u2102) = x * y", "start": [110, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_one", "code": "theorem toComplex_one : ((1 : \u2124[i]) : \u2102) = 1", "start": [115, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_zero", "code": "theorem toComplex_zero : ((0 : \u2124[i]) : \u2102) = 0", "start": [120, 1], "end": [121, 21], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_neg", "code": "theorem toComplex_neg (x : \u2124[i]) : ((-x : \u2124[i]) : \u2102) = -x", "start": [125, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_sub", "code": "theorem toComplex_sub (x y : \u2124[i]) : ((x - y : \u2124[i]) : \u2102) = x - y", "start": [130, 1], "end": [131, 24], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_star", "code": "@[simp]\ntheorem toComplex_star (x : \u2124[i]) : ((star x : \u2124[i]) : \u2102) = conj (x : \u2102)", "start": [134, 1], "end": [137, 42], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_inj", "code": "@[simp]\ntheorem toComplex_inj {x y : \u2124[i]} : (x : \u2102) = y \u2194 x = y", "start": [140, 1], "end": [142, 42], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_eq_zero", "code": "@[simp]\ntheorem toComplex_eq_zero {x : \u2124[i]} : (x : \u2102) = 0 \u2194 x = 0", "start": [145, 1], "end": [147, 39], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.int_cast_real_norm", "code": "@[simp]\ntheorem int_cast_real_norm (x : \u2124[i]) : (x.norm : \u211d) = Complex.normSq (x : \u2102)", "start": [150, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.int_cast_complex_norm", "code": "@[simp]\ntheorem int_cast_complex_norm (x : \u2124[i]) : (x.norm : \u2102) = Complex.normSq (x : \u2102)", "start": [155, 1], "end": [157, 42], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.norm_nonneg", "code": "theorem norm_nonneg (x : \u2124[i]) : 0 \u2264 norm x", "start": [160, 1], "end": [161, 37], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.norm_eq_zero", "code": "@[simp]\ntheorem norm_eq_zero {x : \u2124[i]} : norm x = 0 \u2194 x = 0", "start": [164, 1], "end": [165, 94], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.norm_pos", "code": "theorem norm_pos {x : \u2124[i]} : 0 < norm x \u2194 x \u2260 0", "start": [168, 1], "end": [169, 75], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.abs_coe_nat_norm", "code": "theorem abs_coe_nat_norm (x : \u2124[i]) : (x.norm.natAbs : \u2124) = x.norm", "start": [172, 1], "end": [173, 39], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.nat_cast_natAbs_norm", "code": "@[simp]\ntheorem nat_cast_natAbs_norm {\u03b1 : Type*} [Ring \u03b1] (x : \u2124[i]) : (x.norm.natAbs : \u03b1) = x.norm", "start": [176, 1], "end": [178, 42], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.natAbs_norm_eq", "code": "theorem natAbs_norm_eq (x : \u2124[i]) :\n    x.norm.natAbs = x.re.natAbs * x.re.natAbs + x.im.natAbs * x.im.natAbs", "start": [181, 1], "end": [183, 47], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.div_def", "code": "theorem div_def (x y : \u2124[i]) :\n    x / y = \u27e8round ((x * star y).re / norm y : \u211a), round ((x * star y).im / norm y : \u211a)\u27e9", "start": [192, 1], "end": [194, 50], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_div_re", "code": "theorem toComplex_div_re (x y : \u2124[i]) : ((x / y : \u2124[i]) : \u2102).re = round (x / y : \u2102).re", "start": [197, 1], "end": [199, 70], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.toComplex_div_im", "code": "theorem toComplex_div_im (x y : \u2124[i]) : ((x / y : \u2124[i]) : \u2102).im = round (x / y : \u2102).im", "start": [202, 1], "end": [204, 70], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.normSq_le_normSq_of_re_le_of_im_le", "code": "theorem normSq_le_normSq_of_re_le_of_im_le {x y : \u2102} (hre : |x.re| \u2264 |y.re|)\n    (him : |x.im| \u2264 |y.im|) : Complex.normSq x \u2264 Complex.normSq y", "start": [207, 1], "end": [213, 101], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.normSq_div_sub_div_lt_one", "code": "theorem normSq_div_sub_div_lt_one (x y : \u2124[i]) :\n    Complex.normSq ((x / y : \u2102) - ((x / y : \u2124[i]) : \u2102)) < 1", "start": [216, 1], "end": [229, 40], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.mod_def", "code": "theorem mod_def (x y : \u2124[i]) : x % y = x - y * (x / y)", "start": [235, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.norm_mod_lt", "code": "theorem norm_mod_lt (x : \u2124[i]) {y : \u2124[i]} (hy : y \u2260 0) : (x % y).norm < y.norm", "start": [239, 1], "end": [248, 35], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.natAbs_norm_mod_lt", "code": "theorem natAbs_norm_mod_lt (x : \u2124[i]) {y : \u2124[i]} (hy : y \u2260 0) :\n    (x % y).norm.natAbs < y.norm.natAbs", "start": [251, 1], "end": [253, 61], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.norm_le_norm_mul_left", "code": "theorem norm_le_norm_mul_left (x : \u2124[i]) {y : \u2124[i]} (hy : y \u2260 0) :\n    (norm x).natAbs \u2264 (norm (x * y)).natAbs", "start": [256, 1], "end": [261, 49], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.instNontrivial", "code": "instance instNontrivial : Nontrivial \u2124[i] :=\n  \u27e8\u27e80, 1, by decide\u27e9\u27e9", "start": [264, 1], "end": [265, 22], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.sq_add_sq_of_nat_prime_of_not_irreducible", "code": "theorem sq_add_sq_of_nat_prime_of_not_irreducible (p : \u2115) [hp : Fact p.Prime]\n    (hpi : \u00acIrreducible (p : \u2124[i])) : \u2203 a b, a ^ 2 + b ^ 2 = p", "start": [282, 1], "end": [297, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/KernelPair.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsReflexivePair", "code": "class IsReflexivePair (f g : A \u27f6 B) : Prop where\n  common_section' : \u2203 s : B \u27f6 A, s \u226b f = \ud835\udfd9 B \u2227 s \u226b g = \ud835\udfd9 B", "start": [42, 1], "end": [45, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsReflexivePair.common_section", "code": "theorem IsReflexivePair.common_section (f g : A \u27f6 B) [IsReflexivePair f g] :\n    \u2203 s : B \u27f6 A, s \u226b f = \ud835\udfd9 B \u2227 s \u226b g = \ud835\udfd9 B", "start": [49, 1], "end": [50, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoreflexivePair", "code": "class IsCoreflexivePair (f g : A \u27f6 B) : Prop where\n  common_retraction' : \u2203 s : B \u27f6 A, f \u226b s = \ud835\udfd9 A \u2227 g \u226b s = \ud835\udfd9 A", "start": [52, 1], "end": [56, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoreflexivePair.common_retraction", "code": "theorem IsCoreflexivePair.common_retraction (f g : A \u27f6 B) [IsCoreflexivePair f g] :\n    \u2203 s : B \u27f6 A, f \u226b s = \ud835\udfd9 A \u2227 g \u226b s = \ud835\udfd9 A", "start": [60, 1], "end": [61, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsReflexivePair.mk'", "code": "theorem IsReflexivePair.mk' (s : B \u27f6 A) (sf : s \u226b f = \ud835\udfd9 B) (sg : s \u226b g = \ud835\udfd9 B) :\n    IsReflexivePair f g", "start": [63, 1], "end": [65, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoreflexivePair.mk'", "code": "theorem IsCoreflexivePair.mk' (s : B \u27f6 A) (fs : f \u226b s = \ud835\udfd9 A) (gs : g \u226b s = \ud835\udfd9 A) :\n    IsCoreflexivePair f g", "start": [68, 1], "end": [70, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.commonSection", "code": "noncomputable def commonSection (f g : A \u27f6 B) [IsReflexivePair f g] : B \u27f6 A :=\n  (IsReflexivePair.common_section f g).choose", "start": [73, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.section_comp_left", "code": "@[reassoc (attr := simp)]\ntheorem section_comp_left (f g : A \u27f6 B) [IsReflexivePair f g] : commonSection f g \u226b f = \ud835\udfd9 B", "start": [78, 1], "end": [80, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.section_comp_right", "code": "@[reassoc (attr := simp)]\ntheorem section_comp_right (f g : A \u27f6 B) [IsReflexivePair f g] : commonSection f g \u226b g = \ud835\udfd9 B", "start": [83, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.commonRetraction", "code": "noncomputable def commonRetraction (f g : A \u27f6 B) [IsCoreflexivePair f g] : B \u27f6 A :=\n  (IsCoreflexivePair.common_retraction f g).choose", "start": [88, 1], "end": [90, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.left_comp_retraction", "code": "@[reassoc (attr := simp)]\ntheorem left_comp_retraction (f g : A \u27f6 B) [IsCoreflexivePair f g] :\n    f \u226b commonRetraction f g = \ud835\udfd9 A", "start": [93, 1], "end": [96, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.right_comp_retraction", "code": "@[reassoc (attr := simp)]\ntheorem right_comp_retraction (f g : A \u27f6 B) [IsCoreflexivePair f g] :\n    g \u226b commonRetraction f g = \ud835\udfd9 A", "start": [99, 1], "end": [102, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsKernelPair.isReflexivePair", "code": "theorem IsKernelPair.isReflexivePair {R : C} {f g : R \u27f6 A} {q : A \u27f6 B} (h : IsKernelPair q f g) :\n    IsReflexivePair f g", "start": [105, 1], "end": [108, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsReflexivePair.swap", "code": "theorem IsReflexivePair.swap [IsReflexivePair f g] : IsReflexivePair g f", "start": [112, 1], "end": [114, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoreflexivePair.swap", "code": "theorem IsCoreflexivePair.swap [IsCoreflexivePair f g] : IsCoreflexivePair g f", "start": [118, 1], "end": [120, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasReflexiveCoequalizers", "code": "class HasReflexiveCoequalizers : Prop where\n  has_coeq : \u2200 \u2983A B : C\u2984 (f g : A \u27f6 B) [IsReflexivePair f g], HasCoequalizer f g", "start": [138, 1], "end": [140, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasCoreflexiveEqualizers", "code": "class HasCoreflexiveEqualizers : Prop where\n  has_eq : \u2200 \u2983A B : C\u2984 (f g : A \u27f6 B) [IsCoreflexivePair f g], HasEqualizer f g", "start": [143, 1], "end": [145, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizer_of_common_section", "code": "theorem hasCoequalizer_of_common_section [HasReflexiveCoequalizers C] {A B : C} {f g : A \u27f6 B}\n    (r : B \u27f6 A) (rf : r \u226b f = \ud835\udfd9 _) (rg : r \u226b g = \ud835\udfd9 _) : HasCoequalizer f g", "start": [152, 1], "end": [155, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasEqualizer_of_common_retraction", "code": "theorem hasEqualizer_of_common_retraction [HasCoreflexiveEqualizers C] {A B : C} {f g : A \u27f6 B}\n    (r : B \u27f6 A) (fr : f \u226b r = \ud835\udfd9 _) (gr : g \u226b r = \ud835\udfd9 _) : HasEqualizer f g", "start": [158, 1], "end": [161, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers", "code": "instance (priority := 100) hasReflexiveCoequalizers_of_hasCoequalizers [HasCoequalizers C] :\n    HasReflexiveCoequalizers C where has_coeq A B f g _ := by infer_instance", "start": [164, 1], "end": [166, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers", "code": "instance (priority := 100) hasCoreflexiveEqualizers_of_hasEqualizers [HasEqualizers C] :\n    HasCoreflexiveEqualizers C where has_eq A B f g _ := by infer_instance", "start": [169, 1], "end": [171, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Group/AddCircle.lean", "imports": ["Mathlib/Data/ZMod/Quotient.lean", "Mathlib/MeasureTheory/Integral/Periodic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCircle.closedBall_ae_eq_ball", "code": "theorem closedBall_ae_eq_ball {x : AddCircle T} {\u03b5 : \u211d} : closedBall x \u03b5 =\u1d50[volume] ball x \u03b5", "start": [34, 1], "end": [48, 53], "kind": "commanddeclaration"}, {"full_name": "AddCircle.isAddFundamentalDomain_of_ae_ball", "code": "theorem isAddFundamentalDomain_of_ae_ball (I : Set <| AddCircle T) (u x : AddCircle T)\n    (hu : IsOfFinAddOrder u) (hI : I =\u1d50[volume] ball x (T / (2 * addOrderOf u))) :\n    IsAddFundamentalDomain (AddSubgroup.zmultiples u) I", "start": [51, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "AddCircle.volume_of_add_preimage_eq", "code": "theorem volume_of_add_preimage_eq (s I : Set <| AddCircle T) (u x : AddCircle T)\n    (hu : IsOfFinAddOrder u) (hs : (u +\u1d65 s : Set <| AddCircle T) =\u1d50[volume] s)\n    (hI : I =\u1d50[volume] ball x (T / (2 * addOrderOf u))) :\n    volume s = addOrderOf u \u2022 volume (s \u2229 I)", "start": [95, 1], "end": [104, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Ergodic/Ergodic.lean", "imports": ["Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PreErgodic", "code": "structure PreErgodic (\u03bc : Measure \u03b1 := by volume_tac) : Prop where\n  ae_empty_or_univ : \u2200 \u2983s\u2984, MeasurableSet s \u2192 f \u207b\u00b9' s = s \u2192 s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [40, 1], "end": [43, 95], "kind": "commanddeclaration"}, {"full_name": "Ergodic", "code": "structure Ergodic (\u03bc : Measure \u03b1 := by volume_tac) extends\n  MeasurePreserving f \u03bc \u03bc, PreErgodic f \u03bc : Prop", "start": [46, 1], "end": [50, 49], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic", "code": "structure QuasiErgodic (\u03bc : Measure \u03b1 := by volume_tac) extends\n  QuasiMeasurePreserving f \u03bc \u03bc, PreErgodic f \u03bc : Prop", "start": [53, 1], "end": [57, 54], "kind": "commanddeclaration"}, {"full_name": "PreErgodic.measure_self_or_compl_eq_zero", "code": "theorem measure_self_or_compl_eq_zero (hf : PreErgodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f \u207b\u00b9' s = s) : \u03bc s = 0 \u2228 \u03bc s\u1d9c = 0", "start": [64, 1], "end": [66, 41], "kind": "commanddeclaration"}, {"full_name": "PreErgodic.ae_mem_or_ae_nmem", "code": "theorem ae_mem_or_ae_nmem (hf : PreErgodic f \u03bc) (hsm : MeasurableSet s) (hs : f \u207b\u00b9' s = s) :\n    (\u2200\u1d50 x \u2202\u03bc, x \u2208 s) \u2228 \u2200\u1d50 x \u2202\u03bc, x \u2209 s", "start": [69, 1], "end": [71, 81], "kind": "commanddeclaration"}, {"full_name": "PreErgodic.prob_eq_zero_or_one", "code": "theorem prob_eq_zero_or_one [IsProbabilityMeasure \u03bc] (hf : PreErgodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f \u207b\u00b9' s = s) : \u03bc s = 0 \u2228 \u03bc s = 1", "start": [73, 1], "end": [76, 59], "kind": "commanddeclaration"}, {"full_name": "PreErgodic.of_iterate", "code": "theorem of_iterate (n : \u2115) (hf : PreErgodic f^[n] \u03bc) : PreErgodic f \u03bc", "start": [79, 1], "end": [80, 79], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.preErgodic_of_preErgodic_conjugate", "code": "theorem preErgodic_of_preErgodic_conjugate (hg : MeasurePreserving g \u03bc \u03bc') (hf : PreErgodic f \u03bc)\n    {f' : \u03b2 \u2192 \u03b2} (h_comm : g \u2218 f = f' \u2218 g) : PreErgodic f' \u03bc'", "start": [89, 1], "end": [96, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.preErgodic_conjugate_iff", "code": "theorem preErgodic_conjugate_iff {e : \u03b1 \u2243\u1d50 \u03b2} (h : MeasurePreserving e \u03bc \u03bc') :\n    PreErgodic (e \u2218 f \u2218 e.symm) \u03bc' \u2194 PreErgodic f \u03bc", "start": [99, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.MeasurePreserving.ergodic_conjugate_iff", "code": "theorem ergodic_conjugate_iff {e : \u03b1 \u2243\u1d50 \u03b2} (h : MeasurePreserving e \u03bc \u03bc') :\n    Ergodic (e \u2218 f \u2218 e.symm) \u03bc' \u2194 Ergodic f \u03bc", "start": [109, 1], "end": [115, 79], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.ae_empty_or_univ'", "code": "theorem ae_empty_or_univ' (hf : QuasiErgodic f \u03bc) (hs : MeasurableSet s) (hs' : f \u207b\u00b9' s =\u1d50[\u03bc] s) :\n    s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [122, 1], "end": [127, 101], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.ae_empty_or_univ\u2080", "code": "theorem ae_empty_or_univ\u2080 (hf : QuasiErgodic f \u03bc) (hsm : NullMeasurableSet s \u03bc)\n    (hs : f \u207b\u00b9' s =\u1d50[\u03bc] s) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [130, 1], "end": [136, 58], "kind": "commanddeclaration"}, {"full_name": "QuasiErgodic.ae_mem_or_ae_nmem\u2080", "code": "theorem ae_mem_or_ae_nmem\u2080 (hf : QuasiErgodic f \u03bc) (hsm : NullMeasurableSet s \u03bc)\n    (hs : f \u207b\u00b9' s =\u1d50[\u03bc] s) :\n    (\u2200\u1d50 x \u2202\u03bc, x \u2208 s) \u2228 \u2200\u1d50 x \u2202\u03bc, x \u2209 s", "start": [138, 1], "end": [143, 83], "kind": "commanddeclaration"}, {"full_name": "Ergodic.quasiErgodic", "code": "theorem quasiErgodic (hf : Ergodic f \u03bc) : QuasiErgodic f \u03bc", "start": [149, 1], "end": [151, 74], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_preimage_ae_le'", "code": "theorem ae_empty_or_univ_of_preimage_ae_le' (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f \u207b\u00b9' s \u2264\u1d50[\u03bc] s) (h_fin : \u03bc s \u2260 \u221e) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [154, 1], "end": [159, 48], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_ae_le_preimage'", "code": "theorem ae_empty_or_univ_of_ae_le_preimage' (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : s \u2264\u1d50[\u03bc] f \u207b\u00b9' s) (h_fin : \u03bc s \u2260 \u221e) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [162, 1], "end": [167, 89], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_image_ae_le'", "code": "theorem ae_empty_or_univ_of_image_ae_le' (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f '' s \u2264\u1d50[\u03bc] s) (h_fin : \u03bc s \u2260 \u221e) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [170, 1], "end": [176, 60], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_preimage_ae_le", "code": "theorem ae_empty_or_univ_of_preimage_ae_le (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f \u207b\u00b9' s \u2264\u1d50[\u03bc] s) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [183, 1], "end": [185, 70], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_ae_le_preimage", "code": "theorem ae_empty_or_univ_of_ae_le_preimage (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : s \u2264\u1d50[\u03bc] f \u207b\u00b9' s) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [188, 1], "end": [190, 70], "kind": "commanddeclaration"}, {"full_name": "Ergodic.ae_empty_or_univ_of_image_ae_le", "code": "theorem ae_empty_or_univ_of_image_ae_le (hf : Ergodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f '' s \u2264\u1d50[\u03bc] s) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ", "start": [193, 1], "end": [195, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/Iterate.lean", "imports": ["Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Hom/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "smul_eq_self_of_preimage_zpow_eq_self", "code": "@[to_additive\n      \"Let `n : \u2124` and `s` a subset of an additive commutative group `G` that is invariant\n      under preimage for the map `x \u21a6 n \u2022 x`. Then `s` is invariant under the pointwise action of\n      the additive subgroup of elements `g : G` such that `(n^j) \u2022 g = 0` for some `j : \u2115`.\n      (This additive subgroup is called the Pr\u00fcfer subgroup when `G` is the `AddCircle` and `n` is\n      prime.)\"]\ntheorem smul_eq_self_of_preimage_zpow_eq_self {G : Type*} [CommGroup G] {n : \u2124} {s : Set G}\n    (hs : (fun x => x ^ n) \u207b\u00b9' s = s) {g : G} {j : \u2115} (hg : g ^ n ^ j = 1) : g \u2022 s = s", "start": [21, 1], "end": [44, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/UpperLowerSetTopology.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/AlexandrovDiscrete.lean", "Mathlib/Topology/Order/LowerUpperTopology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Topology.upperSet", "code": "def upperSet (\u03b1 :  Type*) [Preorder \u03b1] : TopologicalSpace \u03b1 where\n  IsOpen := IsUpperSet\n  isOpen_univ := isUpperSet_univ\n  isOpen_inter _ _ := IsUpperSet.inter\n  isOpen_sUnion _ := isUpperSet_sUnion", "start": [54, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "Topology.lowerSet", "code": "def lowerSet (\u03b1 :  Type*) [Preorder \u03b1] : TopologicalSpace \u03b1 where\n  IsOpen := IsLowerSet\n  isOpen_univ := isLowerSet_univ\n  isOpen_inter _ _ := IsLowerSet.inter\n  isOpen_sUnion _ := isLowerSet_sUnion", "start": [63, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet", "code": "def WithUpperSet (\u03b1 : Type*) := \u03b1", "start": [72, 1], "end": [73, 34], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.toUpperSet", "code": "@[match_pattern] def toUpperSet : \u03b1 \u2243 WithUpperSet \u03b1 := Equiv.refl _", "start": [77, 1], "end": [78, 69], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.ofUpperSet", "code": "@[match_pattern] def ofUpperSet : WithUpperSet \u03b1 \u2243 \u03b1 := Equiv.refl _", "start": [80, 1], "end": [81, 69], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.to_WithUpperSet_symm_eq", "code": "@[simp] lemma to_WithUpperSet_symm_eq : (@toUpperSet \u03b1).symm = ofUpperSet := rfl", "start": [83, 1], "end": [83, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.of_WithUpperSet_symm_eq", "code": "@[simp] lemma of_WithUpperSet_symm_eq : (@ofUpperSet \u03b1).symm = toUpperSet := rfl", "start": [84, 1], "end": [84, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.toUpperSet_ofUpperSet", "code": "@[simp] lemma toUpperSet_ofUpperSet (a : WithUpperSet \u03b1) : toUpperSet (ofUpperSet a) = a := rfl", "start": [85, 1], "end": [85, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.ofUpperSet_toUpperSet", "code": "@[simp] lemma ofUpperSet_toUpperSet (a : \u03b1) : ofUpperSet (toUpperSet a) = a := rfl", "start": [86, 1], "end": [86, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.toUpperSet_inj", "code": "lemma toUpperSet_inj {a b : \u03b1} : toUpperSet a = toUpperSet b \u2194 a = b := Iff.rfl", "start": [87, 1], "end": [87, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.ofUpperSet_inj", "code": "lemma ofUpperSet_inj {a b : WithUpperSet \u03b1} : ofUpperSet a = ofUpperSet b \u2194 a = b := Iff.rfl", "start": [88, 1], "end": [88, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.rec", "code": "protected def rec {\u03b2 : WithUpperSet \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toUpperSet a)) : \u2200 a, \u03b2 a :=\n  fun a => h (ofUpperSet a)", "start": [90, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.ofUpperSet_le_iff", "code": "lemma ofUpperSet_le_iff {a b : WithUpperSet \u03b1} : ofUpperSet a \u2264 ofUpperSet b \u2194 a \u2264 b := Iff.rfl", "start": [102, 1], "end": [102, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.toUpperSet_le_iff", "code": "lemma toUpperSet_le_iff {a b : \u03b1} : toUpperSet a \u2264 toUpperSet b \u2194 a \u2264 b := Iff.rfl", "start": [103, 1], "end": [103, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.ofUpperSetOrderIso", "code": "def ofUpperSetOrderIso : WithUpperSet \u03b1 \u2243o \u03b1 where\n  toEquiv := ofUpperSet\n  map_rel_iff' := ofUpperSet_le_iff", "start": [105, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.toUpperSetOrderIso", "code": "def toUpperSetOrderIso : \u03b1 \u2243o WithUpperSet \u03b1 where\n  toEquiv := toUpperSet\n  map_rel_iff' := toUpperSet_le_iff", "start": [110, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet", "code": "def WithLowerSet (\u03b1 : Type*) := \u03b1", "start": [117, 1], "end": [118, 34], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.toLowerSet", "code": "@[match_pattern] def toLowerSet : \u03b1 \u2243 WithLowerSet \u03b1 := Equiv.refl _", "start": [122, 1], "end": [123, 69], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.ofLowerSet", "code": "@[match_pattern] def ofLowerSet : WithLowerSet \u03b1 \u2243 \u03b1 := Equiv.refl _", "start": [125, 1], "end": [126, 69], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.to_WithLowerSet_symm_eq", "code": "@[simp] lemma to_WithLowerSet_symm_eq : (@toLowerSet \u03b1).symm = ofLowerSet := rfl", "start": [128, 1], "end": [128, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.of_WithLowerSet_symm_eq", "code": "@[simp] lemma of_WithLowerSet_symm_eq : (@ofLowerSet \u03b1).symm = toLowerSet := rfl", "start": [129, 1], "end": [129, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.toLowerSet_ofLowerSet", "code": "@[simp] lemma toLowerSet_ofLowerSet (a : WithLowerSet \u03b1) : toLowerSet (ofLowerSet a) = a := rfl", "start": [130, 1], "end": [130, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.ofLowerSet_toLowerSet", "code": "@[simp] lemma ofLowerSet_toLowerSet (a : \u03b1) : ofLowerSet (toLowerSet a) = a := rfl", "start": [131, 1], "end": [131, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.toLowerSet_inj", "code": "lemma toLowerSet_inj {a b : \u03b1} : toLowerSet a = toLowerSet b \u2194 a = b := Iff.rfl", "start": [132, 1], "end": [132, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.ofLowerSet_inj", "code": "lemma ofLowerSet_inj {a b : WithLowerSet \u03b1} : ofLowerSet a = ofLowerSet b \u2194 a = b := Iff.rfl", "start": [133, 1], "end": [133, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.rec", "code": "protected def rec {\u03b2 : WithLowerSet \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toLowerSet a)) : \u2200 a, \u03b2 a :=\n  fun a => h (ofLowerSet a)", "start": [135, 1], "end": [137, 28], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.ofLowerSet_le_iff", "code": "lemma ofLowerSet_le_iff {a b : WithLowerSet \u03b1} : ofLowerSet a \u2264 ofLowerSet b \u2194 a \u2264 b := Iff.rfl", "start": [147, 1], "end": [147, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.toLowerSet_le_iff", "code": "lemma toLowerSet_le_iff {a b : \u03b1} : toLowerSet a \u2264 toLowerSet b \u2194 a \u2264 b := Iff.rfl", "start": [148, 1], "end": [148, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.ofLowerSetOrderIso", "code": "def ofLowerSetOrderIso : WithLowerSet \u03b1 \u2243o \u03b1 where\n  toEquiv := ofLowerSet\n  map_rel_iff' := ofLowerSet_le_iff", "start": [150, 1], "end": [153, 36], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.toLowerSetOrderIso", "code": "def toLowerSetOrderIso : \u03b1 \u2243o WithLowerSet \u03b1 where\n  toEquiv := toLowerSet\n  map_rel_iff' := toLowerSet_le_iff", "start": [155, 1], "end": [158, 36], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.toDualHomeomorph", "code": "def WithUpperSet.toDualHomeomorph [Preorder \u03b1] : WithUpperSet \u03b1 \u2243\u209c WithLowerSet \u03b1\u1d52\u1d48 where\n  toFun := OrderDual.toDual\n  invFun := OrderDual.ofDual\n  left_inv := OrderDual.toDual_ofDual\n  right_inv := OrderDual.ofDual_toDual\n  continuous_toFun := continuous_coinduced_rng\n  continuous_invFun := continuous_coinduced_rng", "start": [162, 1], "end": [171, 48], "kind": "commanddeclaration"}, {"full_name": "Topology.IsUpperSet", "code": "protected class IsUpperSet (\u03b1 : Type*) [t : TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  topology_eq_upperSetTopology : t = upperSet \u03b1", "start": [173, 1], "end": [178, 48], "kind": "commanddeclaration"}, {"full_name": "Topology.IsLowerSet", "code": "protected class IsLowerSet (\u03b1 : Type*) [t : TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  topology_eq_lowerSetTopology : t = lowerSet \u03b1", "start": [188, 1], "end": [193, 48], "kind": "commanddeclaration"}, {"full_name": "Topology.IsUpperSet.topology_eq", "code": "lemma topology_eq : \u2039_\u203a = upperSet \u03b1 := topology_eq_upperSetTopology", "start": [210, 1], "end": [210, 69], "kind": "mathlibtacticlemma"}, {"full_name": "OrderDual.instIsLowerSet", "code": "instance _root_.OrderDual.instIsLowerSet [Preorder \u03b1] [TopologicalSpace \u03b1] [Topology.IsUpperSet \u03b1] :\n    Topology.IsLowerSet \u03b1\u1d52\u1d48 where\n  topology_eq_lowerSetTopology := by ext; rw [IsUpperSet.topology_eq \u03b1]", "start": [214, 1], "end": [216, 72], "kind": "commanddeclaration"}, {"full_name": "Topology.IsUpperSet.WithUpperSetHomeomorph", "code": "def WithUpperSetHomeomorph : WithUpperSet \u03b1 \u2243\u209c \u03b1 :=\n  WithUpperSet.ofUpperSet.toHomeomorphOfInducing \u27e8by erw [topology_eq \u03b1, induced_id]; rfl\u27e9", "start": [218, 1], "end": [221, 91], "kind": "commanddeclaration"}, {"full_name": "Topology.IsUpperSet.isOpen_iff_isUpperSet", "code": "lemma isOpen_iff_isUpperSet : IsOpen s \u2194 IsUpperSet s := by\n  rw [topology_eq \u03b1]\n  rfl", "start": [223, 1], "end": [225, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.toAlexandrovDiscrete", "code": "instance toAlexandrovDiscrete : AlexandrovDiscrete \u03b1 where\n  isOpen_sInter S := by simpa only [isOpen_iff_isUpperSet] using isUpperSet_sInter (\u03b1 := \u03b1)", "start": [227, 1], "end": [228, 92], "kind": "commanddeclaration"}, {"full_name": "Topology.IsUpperSet.isClosed_iff_isLower", "code": "lemma isClosed_iff_isLower : IsClosed s \u2194 IsLowerSet s := by\n  rw [\u2190 isOpen_compl_iff, isOpen_iff_isUpperSet,\n    isLowerSet_compl.symm, compl_compl]", "start": [231, 1], "end": [233, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.closure_eq_lowerClosure", "code": "lemma closure_eq_lowerClosure {s : Set \u03b1} : closure s = lowerClosure s := by\n  rw [subset_antisymm_iff]\n  refine \u27e8?_, lowerClosure_min subset_closure (isClosed_iff_isLower.1 isClosed_closure)\u27e9\n  \u00b7 apply closure_minimal subset_lowerClosure _\n    rw [isClosed_iff_isLower]\n    exact LowerSet.lower (lowerClosure s)", "start": [235, 1], "end": [240, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.closure_singleton", "code": "@[simp] lemma closure_singleton {a : \u03b1} : closure {a} = Iic a := by\n  rw [closure_eq_lowerClosure, lowerClosure_singleton]\n  rfl", "start": [242, 1], "end": [248, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.monotone_iff_continuous", "code": "protected lemma monotone_iff_continuous [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [Topology.IsUpperSet \u03b1] [Topology.IsUpperSet \u03b2] {f : \u03b1 \u2192 \u03b2} : Monotone f \u2194 Continuous f := by\n  constructor\n  \u00b7 intro hf\n    simp_rw [continuous_def, isOpen_iff_isUpperSet]\n    exact fun _ hs \u21a6 IsUpperSet.preimage hs hf\n  \u00b7 intro hf a b hab\n    rw [\u2190 mem_Iic, \u2190 closure_singleton] at hab \u22a2\n    apply (Continuous.closure_preimage_subset hf {f b})\n    apply mem_of_mem_of_subset hab\n    apply closure_mono\n    rw [singleton_subset_iff, mem_preimage, mem_singleton_iff]", "start": [258, 1], "end": [269, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.monotone_to_upperTopology_continuous", "code": "lemma monotone_to_upperTopology_continuous [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [Topology.IsUpperSet \u03b1] [IsUpper \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) : Continuous f := by\n  simp_rw [continuous_def, isOpen_iff_isUpperSet]\n  intro s hs\n  exact (IsUpper.isUpperSet_of_isOpen hs).preimage hf", "start": [271, 1], "end": [275, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsUpperSet.upperSet_le_upper", "code": "lemma upperSet_le_upper {t\u2081 t\u2082 : TopologicalSpace \u03b1} [@Topology.IsUpperSet \u03b1 t\u2081 _]\n    [@Topology.IsUpper \u03b1 t\u2082 _] : t\u2081 \u2264 t\u2082 := fun s hs => by\n  rw [@isOpen_iff_isUpperSet \u03b1 _ t\u2081]\n  exact IsUpper.isUpperSet_of_isOpen hs", "start": [277, 1], "end": [280, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.topology_eq", "code": "lemma topology_eq : \u2039_\u203a = lowerSet \u03b1 := topology_eq_lowerSetTopology", "start": [293, 1], "end": [293, 69], "kind": "mathlibtacticlemma"}, {"full_name": "OrderDual.instIsUpperSet", "code": "instance _root_.OrderDual.instIsUpperSet [Preorder \u03b1] [TopologicalSpace \u03b1] [Topology.IsLowerSet \u03b1] :\n    Topology.IsUpperSet \u03b1\u1d52\u1d48 where\n  topology_eq_upperSetTopology := by ext; rw [IsLowerSet.topology_eq \u03b1]", "start": [297, 1], "end": [299, 72], "kind": "commanddeclaration"}, {"full_name": "Topology.IsLowerSet.WithLowerSetHomeomorph", "code": "def WithLowerSetHomeomorph : WithLowerSet \u03b1 \u2243\u209c \u03b1 :=\n  WithLowerSet.ofLowerSet.toHomeomorphOfInducing \u27e8by erw [topology_eq \u03b1, induced_id]; rfl\u27e9", "start": [301, 1], "end": [303, 91], "kind": "commanddeclaration"}, {"full_name": "Topology.IsLowerSet.isOpen_iff_isLowerSet", "code": "lemma isOpen_iff_isLowerSet : IsOpen s \u2194 IsLowerSet s := by rw [topology_eq \u03b1]; rfl", "start": [305, 1], "end": [305, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.toAlexandrovDiscrete", "code": "instance toAlexandrovDiscrete : AlexandrovDiscrete \u03b1 := IsUpperSet.toAlexandrovDiscrete (\u03b1 := \u03b1\u1d52\u1d48)", "start": [307, 1], "end": [307, 99], "kind": "commanddeclaration"}, {"full_name": "Topology.IsLowerSet.isClosed_iff_isUpper", "code": "lemma isClosed_iff_isUpper : IsClosed s \u2194 IsUpperSet s := by\n  rw [\u2190 isOpen_compl_iff, isOpen_iff_isLowerSet, isUpperSet_compl.symm, compl_compl]", "start": [309, 1], "end": [310, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.closure_eq_upperClosure", "code": "lemma closure_eq_upperClosure {s : Set \u03b1} : closure s = upperClosure s :=\n  IsUpperSet.closure_eq_lowerClosure (\u03b1 := \u03b1\u1d52\u1d48)", "start": [312, 1], "end": [313, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.closure_singleton", "code": "@[simp] lemma closure_singleton {a : \u03b1} : closure {a} = Ici a := by\n  rw [closure_eq_upperClosure, upperClosure_singleton]\n  rfl", "start": [315, 1], "end": [321, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.monotone_iff_continuous", "code": "protected lemma monotone_iff_continuous [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [Topology.IsLowerSet \u03b1] [Topology.IsLowerSet \u03b2] {f : \u03b1 \u2192 \u03b2} : Monotone f \u2194 Continuous f := by\n  rw [\u2190 monotone_dual_iff]\n  exact IsUpperSet.monotone_iff_continuous (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48)\n    (f := (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48))", "start": [332, 1], "end": [336, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.monotone_to_lowerTopology_continuous", "code": "lemma monotone_to_lowerTopology_continuous [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [Topology.IsLowerSet \u03b1] [IsLower \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) : Continuous f :=\n  IsUpperSet.monotone_to_upperTopology_continuous (\u03b1 := \u03b1\u1d52\u1d48) (\u03b2 := \u03b2\u1d52\u1d48) hf.dual", "start": [338, 1], "end": [340, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.IsLowerSet.lowerSet_le_lower", "code": "lemma lowerSet_le_lower {t\u2081 t\u2082 : TopologicalSpace \u03b1} [@Topology.IsLowerSet \u03b1 t\u2081 _]\n    [@IsLower \u03b1 t\u2082 _] : t\u2081 \u2264 t\u2082 := fun s hs => by\n  rw [@isOpen_iff_isLowerSet \u03b1 _ t\u2081]\n  exact IsLower.isLowerSet_of_isOpen hs", "start": [342, 1], "end": [345, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.isUpperSet_orderDual", "code": "lemma isUpperSet_orderDual [Preorder \u03b1] [TopologicalSpace \u03b1] :\n    Topology.IsUpperSet \u03b1\u1d52\u1d48 \u2194 Topology.IsLowerSet \u03b1 := by\n  constructor\n  \u00b7 apply OrderDual.instIsLowerSet\n  \u00b7 apply OrderDual.instIsUpperSet", "start": [351, 1], "end": [355, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.isLowerSet_orderDual", "code": "lemma isLowerSet_orderDual [Preorder \u03b1] [TopologicalSpace \u03b1] :\n    Topology.IsLowerSet \u03b1\u1d52\u1d48 \u2194 Topology.IsUpperSet \u03b1 := isUpperSet_orderDual.symm", "start": [357, 1], "end": [358, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.map", "code": "def map (f : \u03b1 \u2192o \u03b2) : C(WithUpperSet \u03b1, WithUpperSet \u03b2) where\n  toFun := toUpperSet \u2218 f \u2218 ofUpperSet\n  continuous_toFun := continuous_def.2 \u03bb _s hs \u21a6 IsUpperSet.preimage hs f.monotone", "start": [363, 1], "end": [367, 83], "kind": "commanddeclaration"}, {"full_name": "Topology.WithUpperSet.map_id", "code": "@[simp] lemma map_id : map (OrderHom.id : \u03b1 \u2192o \u03b1) = ContinuousMap.id _ := rfl", "start": [369, 1], "end": [369, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.map_comp", "code": "@[simp] lemma map_comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2): map (g.comp f) = (map g).comp (map f) := rfl", "start": [370, 1], "end": [370, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.toUpperSet_specializes_toUpperSet", "code": "@[simp] lemma toUpperSet_specializes_toUpperSet {a b : \u03b1} :\n    toUpperSet a \u2933 toUpperSet b \u2194 b \u2264 a := by\n  simp_rw [specializes_iff_closure_subset, IsUpperSet.closure_singleton, Iic_subset_Iic,\n    toUpperSet_le_iff]", "start": [372, 1], "end": [375, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.ofUpperSet_le_ofUpperSet", "code": "@[simp] lemma ofUpperSet_le_ofUpperSet {a b : WithUpperSet \u03b1} :\n    ofUpperSet a \u2264 ofUpperSet b \u2194 b \u2933 a := toUpperSet_specializes_toUpperSet.symm", "start": [377, 1], "end": [378, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.isUpperSet_toUpperSet_preimage", "code": "@[simp] lemma isUpperSet_toUpperSet_preimage {s : Set (WithUpperSet \u03b1)} :\n    IsUpperSet (toUpperSet \u207b\u00b9' s) \u2194 IsOpen s := Iff.rfl", "start": [380, 1], "end": [381, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithUpperSet.isOpen_ofUpperSet_preimage", "code": "@[simp] lemma isOpen_ofUpperSet_preimage {s : Set \u03b1} :\n    IsOpen (ofUpperSet \u207b\u00b9' s) \u2194 IsUpperSet s := isUpperSet_toUpperSet_preimage.symm", "start": [383, 1], "end": [384, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.map", "code": "def map (f : \u03b1 \u2192o \u03b2) : C(WithLowerSet \u03b1, WithLowerSet \u03b2) where\n  toFun := toLowerSet \u2218 f \u2218 ofLowerSet\n  continuous_toFun := continuous_def.2 \u03bb _s hs \u21a6 IsLowerSet.preimage hs f.monotone", "start": [391, 1], "end": [395, 83], "kind": "commanddeclaration"}, {"full_name": "Topology.WithLowerSet.map_id", "code": "@[simp] lemma map_id : map (OrderHom.id : \u03b1 \u2192o \u03b1) = ContinuousMap.id _ := rfl", "start": [397, 1], "end": [397, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.map_comp", "code": "@[simp] lemma map_comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2): map (g.comp f) = (map g).comp (map f) := rfl", "start": [398, 1], "end": [398, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.toLowerSet_specializes_toLowerSet", "code": "@[simp] lemma toLowerSet_specializes_toLowerSet {a b : \u03b1} :\n  toLowerSet a \u2933 toLowerSet b \u2194 a \u2264 b := by\n  simp_rw [specializes_iff_closure_subset, IsLowerSet.closure_singleton, Ici_subset_Ici,\n    toLowerSet_le_iff]", "start": [400, 1], "end": [403, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.ofLowerSet_le_ofLowerSet", "code": "@[simp] lemma ofLowerSet_le_ofLowerSet {a b : WithLowerSet \u03b1} :\n    ofLowerSet a \u2264 ofLowerSet b \u2194 a \u2933 b := toLowerSet_specializes_toLowerSet.symm", "start": [405, 1], "end": [406, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.isLowerSet_toLowerSet_preimage", "code": "@[simp] lemma isLowerSet_toLowerSet_preimage {s : Set (WithLowerSet \u03b1)} :\n    IsLowerSet (toLowerSet \u207b\u00b9' s) \u2194 IsOpen s := Iff.rfl", "start": [408, 1], "end": [409, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Topology.WithLowerSet.isOpen_ofLowerSet_preimage", "code": "@[simp] lemma isOpen_ofLowerSet_preimage {s : Set \u03b1} :\n    IsOpen (ofLowerSet \u207b\u00b9' s) \u2194 IsLowerSet s := isLowerSet_toLowerSet_preimage.symm", "start": [411, 1], "end": [412, 84], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Dynamics/FixedPoints/Topology.lean", "imports": ["Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isFixedPt_of_tendsto_iterate", "code": "theorem isFixedPt_of_tendsto_iterate {x y : \u03b1} (hy : Tendsto (fun n => f^[n] x) atTop (\ud835\udcdd y))\n    (hf : ContinuousAt f y) : IsFixedPt f y", "start": [31, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "isClosed_fixedPoints", "code": "theorem isClosed_fixedPoints (hf : Continuous f) : IsClosed (fixedPoints f)", "start": [40, 1], "end": [42, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/ExtendToLocalization.lean", "imports": ["Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/RingTheory/Valuation/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Valuation.extendToLocalization", "code": "noncomputable def Valuation.extendToLocalization : Valuation B \u0393 :=\n  let f := IsLocalization.toLocalizationMap S B\n  let h : \u2200 s : S, IsUnit (v.1.toMonoidHom s) := fun s => isUnit_iff_ne_zero.2 (hS s.2)\n  { f.lift h with\n    map_zero' := by convert f.lift_eq (P := \u0393) _ 0 <;> simp\n    map_add_le_max' := fun x y => by\n      obtain \u27e8a, b, s, rfl, rfl\u27e9 : \u2203 (a b : A) (s : S), f.mk' a s = x \u2227 f.mk' b s = y := by\n        obtain \u27e8a, s, rfl\u27e9 := f.mk'_surjective x\n        obtain \u27e8b, t, rfl\u27e9 := f.mk'_surjective y\n        use a * t, b * s, s * t\n        constructor <;>\n          \u00b7 rw [f.mk'_eq_iff_eq, Submonoid.coe_mul]\n            ring_nf\n      convert_to f.lift h (f.mk' (a + b) s) \u2264 max (f.lift h _) (f.lift h _)\n      \u00b7 refine' congr_arg (f.lift h) (IsLocalization.eq_mk'_iff_mul_eq.2 _)\n        rw [add_mul, _root_.map_add]\n        iterate 2 erw [IsLocalization.mk'_spec]\n      iterate 3 rw [f.lift_mk']\n      rw [max_mul_mul_right]\n      apply mul_le_mul_right' (v.map_add a b) }", "start": [26, 1], "end": [47, 48], "kind": "commanddeclaration"}, {"full_name": "Valuation.extendToLocalization_apply_map_apply", "code": "@[simp]\ntheorem Valuation.extendToLocalization_apply_map_apply (a : A) :\n    v.extendToLocalization hS B (algebraMap A B a) = v a", "start": [50, 1], "end": [53, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/ValuationSubring.lean", "imports": ["Mathlib/RingTheory/Valuation/ValuationRing.lean", "Mathlib/AlgebraicGeometry/PrimeSpectrum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Subring/Pointwise.lean", "Mathlib/RingTheory/Localization/AsSubring.lean"], "premises": [{"full_name": "ValuationSubring", "code": "structure ValuationSubring extends Subring K where\n  mem_or_inv_mem' : \u2200 x : K, x \u2208 carrier \u2228 x\u207b\u00b9 \u2208 carrier", "start": [32, 1], "end": [35, 57], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_carrier", "code": "@[simp, nolint simpNF] theorem mem_carrier (x : K) : x \u2208 A.carrier \u2194 x \u2208 A", "start": [50, 1], "end": [51, 66], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_toSubring", "code": "@[simp]\ntheorem mem_toSubring (x : K) : x \u2208 A.toSubring \u2194 x \u2208 A", "start": [54, 1], "end": [55, 70], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ext", "code": "@[ext]\ntheorem ext (A B : ValuationSubring K) (h : \u2200 x, x \u2208 A \u2194 x \u2208 B) : A = B", "start": [58, 1], "end": [59, 89], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.zero_mem", "code": "theorem zero_mem : (0 : K) \u2208 A", "start": [62, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.one_mem", "code": "theorem one_mem : (1 : K) \u2208 A", "start": [65, 1], "end": [65, 53], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.add_mem", "code": "theorem add_mem (x y : K) : x \u2208 A \u2192 y \u2208 A \u2192 x + y \u2208 A", "start": [68, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mul_mem", "code": "theorem mul_mem (x y : K) : x \u2208 A \u2192 y \u2208 A \u2192 x * y \u2208 A", "start": [71, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.neg_mem", "code": "theorem neg_mem (x : K) : x \u2208 A \u2192 -x \u2208 A", "start": [74, 1], "end": [74, 64], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_or_inv_mem", "code": "theorem mem_or_inv_mem (x : K) : x \u2208 A \u2228 x\u207b\u00b9 \u2208 A", "start": [77, 1], "end": [77, 72], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.toSubring_injective", "code": "theorem toSubring_injective : Function.Injective (toSubring : ValuationSubring K \u2192 Subring K)", "start": [87, 1], "end": [88, 42], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_top", "code": "theorem mem_top (x : K) : x \u2208 (\u22a4 : ValuationSubring K)", "start": [100, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.le_top", "code": "theorem le_top : A \u2264 \u22a4", "start": [104, 1], "end": [104, 50], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.localRing", "code": "instance localRing : LocalRing A := ValuationRing.localRing A", "start": [142, 1], "end": [142, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (a : A) : algebraMap A K a = a", "start": [144, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ValueGroup", "code": "def ValueGroup :=\n  ValuationRing.ValueGroup A K", "start": [161, 1], "end": [163, 31], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation", "code": "def valuation : Valuation K A.ValueGroup :=\n  ValuationRing.valuation A K", "start": [172, 1], "end": [174, 30], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.inhabitedValueGroup", "code": "instance inhabitedValueGroup : Inhabited A.ValueGroup := \u27e8A.valuation 0\u27e9", "start": [177, 1], "end": [177, 73], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_le_one", "code": "theorem valuation_le_one (a : A) : A.valuation a \u2264 1", "start": [180, 1], "end": [181, 51], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_of_valuation_le_one", "code": "theorem mem_of_valuation_le_one (x : K) (h : A.valuation x \u2264 1) : x \u2208 A", "start": [184, 1], "end": [186, 11], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_le_one_iff", "code": "theorem valuation_le_one_iff (x : K) : A.valuation x \u2264 1 \u2194 x \u2208 A", "start": [189, 1], "end": [190, 70], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_eq_iff", "code": "theorem valuation_eq_iff (x y : K) : A.valuation x = A.valuation y \u2194 \u2203 a : A\u02e3, (a : K) * y = x", "start": [193, 1], "end": [194, 16], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_le_iff", "code": "theorem valuation_le_iff (x y : K) : A.valuation x \u2264 A.valuation y \u2194 \u2203 a : A, (a : K) * y = x", "start": [197, 1], "end": [198, 10], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_surjective", "code": "theorem valuation_surjective : Function.Surjective A.valuation", "start": [201, 1], "end": [201, 87], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_unit", "code": "theorem valuation_unit (a : A\u02e3) : A.valuation a = 1", "start": [204, 1], "end": [205, 60], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_eq_one_iff", "code": "theorem valuation_eq_one_iff (a : A) : IsUnit a \u2194 A.valuation a = 1", "start": [208, 1], "end": [215, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_lt_one_or_eq_one", "code": "theorem valuation_lt_one_or_eq_one (a : A) : A.valuation a < 1 \u2228 A.valuation a = 1", "start": [218, 1], "end": [219, 40], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuation_lt_one_iff", "code": "theorem valuation_lt_one_iff (a : A) : a \u2208 LocalRing.maximalIdeal A \u2194 A.valuation a < 1", "start": [222, 1], "end": [225, 46], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofSubring", "code": "def ofSubring (R : Subring K) (hR : \u2200 x : K, x \u2208 R \u2228 x\u207b\u00b9 \u2208 R) : ValuationSubring K :=\n  { R with mem_or_inv_mem' := hR }", "start": [228, 1], "end": [231, 35], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_ofSubring", "code": "@[simp]\ntheorem mem_ofSubring (R : Subring K) (hR : \u2200 x : K, x \u2208 R \u2228 x\u207b\u00b9 \u2208 R) (x : K) :\n    x \u2208 ofSubring R hR \u2194 x \u2208 R", "start": [234, 1], "end": [237, 13], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofLE", "code": "def ofLE (R : ValuationSubring K) (S : Subring K) (h : R.toSubring \u2264 S) : ValuationSubring K :=\n  { S with mem_or_inv_mem' := fun x => (R.mem_or_inv_mem x).imp (@h x) (@h _) }", "start": [240, 1], "end": [242, 80], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.inclusion", "code": "def inclusion (R S : ValuationSubring K) (h : R \u2264 S) : R \u2192+* S :=\n  Subring.inclusion h", "start": [254, 1], "end": [256, 22], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.subtype", "code": "def subtype (R : ValuationSubring K) : R \u2192+* K :=\n  Subring.subtype R.toSubring", "start": [259, 1], "end": [261, 30], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mapOfLE", "code": "def mapOfLE (R S : ValuationSubring K) (h : R \u2264 S) : R.ValueGroup \u2192*\u2080 S.ValueGroup where\n  toFun := Quotient.map' id fun x y \u27e8u, hu\u27e9 => \u27e8Units.map (R.inclusion S h).toMonoidHom u, hu\u27e9\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' := by rintro \u27e8\u27e9 \u27e8\u27e9; rfl", "start": [264, 1], "end": [269, 35], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.monotone_mapOfLE", "code": "@[mono]\ntheorem monotone_mapOfLE (R S : ValuationSubring K) (h : R \u2264 S) : Monotone (R.mapOfLE S h)", "start": [272, 1], "end": [274, 54], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mapOfLE_comp_valuation", "code": "@[simp]\ntheorem mapOfLE_comp_valuation (R S : ValuationSubring K) (h : R \u2264 S) :\n    R.mapOfLE S h \u2218 R.valuation = S.valuation", "start": [277, 1], "end": [279, 61], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mapOfLE_valuation_apply", "code": "@[simp]\ntheorem mapOfLE_valuation_apply (R S : ValuationSubring K) (h : R \u2264 S) (x : K) :\n    R.mapOfLE S h (R.valuation x) = S.valuation x", "start": [282, 1], "end": [284, 57], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.idealOfLE", "code": "def idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) : Ideal R :=\n  (LocalRing.maximalIdeal S).comap (R.inclusion S h)", "start": [287, 1], "end": [289, 53], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.prime_idealOfLE", "code": "instance prime_idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) : (idealOfLE R S h).IsPrime :=\n  (LocalRing.maximalIdeal S).comap_isPrime _", "start": [292, 1], "end": [293, 45], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime", "code": "def ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : ValuationSubring K :=\n  ofLE A (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors).toSubring\n    fun a ha => Subalgebra.mem_toSubring.mpr <|\n      Subalgebra.algebraMap_mem\n        (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors) (\u27e8a, ha\u27e9 : A)", "start": [296, 1], "end": [302, 92], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrimeAlgebra", "code": "instance ofPrimeAlgebra (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    Algebra A (A.ofPrime P) :=\n  Subalgebra.algebra (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)", "start": [305, 1], "end": [308, 91], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime_scalar_tower", "code": "instance ofPrime_scalar_tower (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    letI : SMul A (A.ofPrime P) := SMulZeroClass.toSMul\n    IsScalarTower A (A.ofPrime P) K :=\n  IsScalarTower.subalgebra' A K K\n    (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)", "start": [311, 1], "end": [317, 74], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime_localization", "code": "instance ofPrime_localization (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    IsLocalization.AtPrime (A.ofPrime P) P := by\n  apply\n    Localization.subalgebra.isLocalization_ofField K P.primeCompl\n      P.primeCompl_le_nonZeroDivisors", "start": [320, 1], "end": [324, 38], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.le_ofPrime", "code": "theorem le_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : A \u2264 ofPrime A P", "start": [327, 1], "end": [329, 88], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime_valuation_eq_one_iff_mem_primeCompl", "code": "theorem ofPrime_valuation_eq_one_iff_mem_primeCompl (A : ValuationSubring K) (P : Ideal A)\n    [P.IsPrime] (x : A) : (ofPrime A P).valuation x = 1 \u2194 x \u2208 P.primeCompl", "start": [332, 1], "end": [334, 95], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.idealOfLE_ofPrime", "code": "@[simp]\ntheorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :\n    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P", "start": [337, 1], "end": [342, 32], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime_idealOfLE", "code": "@[simp]\ntheorem ofPrime_idealOfLE (R S : ValuationSubring K) (h : R \u2264 S) :\n    ofPrime R (idealOfLE R S h) = S", "start": [345, 1], "end": [364, 24], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ofPrime_le_of_le", "code": "theorem ofPrime_le_of_le (P Q : Ideal A) [P.IsPrime] [Q.IsPrime] (h : P \u2264 Q) :\n    ofPrime A Q \u2264 ofPrime A P", "start": [367, 1], "end": [368, 88], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.idealOfLE_le_of_le", "code": "theorem idealOfLE_le_of_le (R S : ValuationSubring K) (hR : A \u2264 R) (hS : A \u2264 S) (h : R \u2264 S) :\n    idealOfLE A S hS \u2264 idealOfLE A R hR", "start": [371, 1], "end": [377, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.primeSpectrumEquiv", "code": "@[simps]\ndef primeSpectrumEquiv : PrimeSpectrum A \u2243 {S // A \u2264 S} where\n  toFun P := \u27e8ofPrime A P.asIdeal, le_ofPrime _ _\u27e9\n  invFun S := \u27e8idealOfLE _ S S.2, inferInstance\u27e9\n  left_inv P := by ext1; simp\n  right_inv S := by ext1; simp", "start": [380, 1], "end": [386, 31], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.primeSpectrumOrderEquiv", "code": "@[simps]\ndef primeSpectrumOrderEquiv : (PrimeSpectrum A)\u1d52\u1d48 \u2243o {S // A \u2264 S} :=\n  { primeSpectrumEquiv A with\n    map_rel_iff' :=\n      \u27e8fun h => by\n        dsimp at h\n        have := idealOfLE_le_of_le A _ _ ?_ ?_ h\n        iterate 2 erw [idealOfLE_ofPrime] at this\n        exact this\n        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),\n      fun h => by apply ofPrime_le_of_le; exact h\u27e9 }", "start": [389, 1], "end": [400, 53], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.linearOrderOverring", "code": "instance linearOrderOverring : LinearOrder {S // A \u2264 S} :=\n  { (inferInstance : PartialOrder _) with\n    le_total :=\n      let i : IsTotal (PrimeSpectrum A) (\u00b7 \u2264 \u00b7) := \u27e8fun \u27e8x, _\u27e9 \u27e8y, _\u27e9 => LE.isTotal.total x y\u27e9\n      (primeSpectrumOrderEquiv A).symm.toRelEmbedding.isTotal.total\n    decidableLE := inferInstance }", "start": [403, 1], "end": [408, 35], "kind": "commanddeclaration"}, {"full_name": "Valuation.valuationSubring", "code": "def valuationSubring : ValuationSubring K :=\n  { v.integer with\n    mem_or_inv_mem' := by\n      intro x\n      cases' le_or_lt (v x) 1 with h h\n      \u00b7 left; exact h\n      \u00b7 right; change v x\u207b\u00b9 \u2264 1\n        rw [map_inv\u2080 v, \u2190 inv_one, inv_le_inv\u2080]\n        \u00b7 exact le_of_lt h\n        \u00b7 intro c; simp [c] at h\n        \u00b7 exact one_ne_zero }", "start": [422, 1], "end": [433, 30], "kind": "commanddeclaration"}, {"full_name": "Valuation.mem_valuationSubring_iff", "code": "@[simp]\ntheorem mem_valuationSubring_iff (x : K) : x \u2208 v.valuationSubring \u2194 v x \u2264 1", "start": [436, 1], "end": [437, 90], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_iff_valuationSubring", "code": "theorem isEquiv_iff_valuationSubring :\n    v\u2081.IsEquiv v\u2082 \u2194 v\u2081.valuationSubring = v\u2082.valuationSubring", "start": [440, 1], "end": [447, 21], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_valuation_valuationSubring", "code": "theorem isEquiv_valuation_valuationSubring : v.IsEquiv v.valuationSubring.valuation", "start": [450, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.valuationSubring_valuation", "code": "@[simp]\ntheorem valuationSubring_valuation : A.valuation.valuationSubring = A", "start": [464, 1], "end": [466, 42], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroup", "code": "def unitGroup : Subgroup K\u02e3 :=\n  (A.valuation.toMonoidWithZeroHom.toMonoidHom.comp (Units.coeHom K)).ker", "start": [471, 1], "end": [473, 74], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_unitGroup_iff", "code": "@[simp]\ntheorem mem_unitGroup_iff (x : K\u02e3) : x \u2208 A.unitGroup \u2194 A.valuation x = 1", "start": [476, 1], "end": [477, 84], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroupMulEquiv", "code": "def unitGroupMulEquiv : A.unitGroup \u2243* A\u02e3 where\n  toFun x :=\n    { val := \u27e8(x : K\u02e3), mem_of_valuation_le_one A _ x.prop.le\u27e9\n      inv := \u27e8((x\u207b\u00b9 : A.unitGroup) : K\u02e3), mem_of_valuation_le_one _ _ x\u207b\u00b9.prop.le\u27e9\n      val_inv := Subtype.ext (by simp)\n      inv_val := Subtype.ext (by simp) }\n  invFun x := \u27e8Units.map A.subtype.toMonoidHom x, A.valuation_unit x\u27e9\n  left_inv a := by ext; rfl\n  right_inv a := by ext; rfl\n  map_mul' a b := by ext; rfl", "start": [480, 1], "end": [492, 30], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_unitGroupMulEquiv_apply", "code": "@[simp]\ntheorem coe_unitGroupMulEquiv_apply (a : A.unitGroup) :\n    ((A.unitGroupMulEquiv a : A) : K) = ((a : K\u02e3) : K)", "start": [495, 1], "end": [497, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_unitGroupMulEquiv_symm_apply", "code": "@[simp]\ntheorem coe_unitGroupMulEquiv_symm_apply (a : A\u02e3) : ((A.unitGroupMulEquiv.symm a : K\u02e3) : K) = a", "start": [500, 1], "end": [502, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroup_le_unitGroup", "code": "theorem unitGroup_le_unitGroup {A B : ValuationSubring K} : A.unitGroup \u2264 B.unitGroup \u2194 A \u2264 B", "start": [505, 1], "end": [521, 19], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroup_injective", "code": "theorem unitGroup_injective : Function.Injective (unitGroup : ValuationSubring K \u2192 Subgroup _)", "start": [524, 1], "end": [525, 79], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.eq_iff_unitGroup", "code": "theorem eq_iff_unitGroup {A B : ValuationSubring K} : A = B \u2194 A.unitGroup = B.unitGroup", "start": [528, 1], "end": [529, 34], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroupOrderEmbedding", "code": "def unitGroupOrderEmbedding : ValuationSubring K \u21aao Subgroup K\u02e3 where\n  toFun A := A.unitGroup\n  inj' := unitGroup_injective\n  map_rel_iff' {_A _B} := unitGroup_le_unitGroup", "start": [532, 1], "end": [536, 49], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroup_strictMono", "code": "theorem unitGroup_strictMono : StrictMono (unitGroup : ValuationSubring K \u2192 Subgroup _)", "start": [539, 1], "end": [540, 37], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits", "code": "def nonunits : Subsemigroup K where\n  carrier := {x | A.valuation x < 1}\n  mul_mem' ha hb := (mul_lt_mul\u2080 (Set.mem_setOf.mp ha) (Set.mem_setOf.mp hb)).trans_eq <| mul_one _", "start": [547, 1], "end": [551, 100], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_nonunits_iff", "code": "theorem mem_nonunits_iff {x : K} : x \u2208 A.nonunits \u2194 A.valuation x < 1", "start": [554, 1], "end": [555, 10], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits_le_nonunits", "code": "theorem nonunits_le_nonunits {A B : ValuationSubring K} : B.nonunits \u2264 A.nonunits \u2194 A \u2264 B", "start": [558, 1], "end": [565, 77], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits_injective", "code": "theorem nonunits_injective : Function.Injective (nonunits : ValuationSubring K \u2192 Subsemigroup _)", "start": [568, 1], "end": [569, 82], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits_inj", "code": "theorem nonunits_inj {A B : ValuationSubring K} : A.nonunits = B.nonunits \u2194 A = B", "start": [572, 1], "end": [573, 28], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunitsOrderEmbedding", "code": "def nonunitsOrderEmbedding : ValuationSubring K \u21aao (Subsemigroup K)\u1d52\u1d48 where\n  toFun A := A.nonunits\n  inj' := nonunits_injective\n  map_rel_iff' {_A _B} := nonunits_le_nonunits", "start": [576, 1], "end": [580, 47], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_mem_nonunits_iff", "code": "theorem coe_mem_nonunits_iff {a : A} : (a : K) \u2208 A.nonunits \u2194 a \u2208 LocalRing.maximalIdeal A", "start": [585, 1], "end": [591, 34], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits_le", "code": "theorem nonunits_le : A.nonunits \u2264 A.toSubring.toSubmonoid.toSubsemigroup", "start": [594, 1], "end": [595, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.nonunits_subset", "code": "theorem nonunits_subset : (A.nonunits : Set K) \u2286 A", "start": [598, 1], "end": [599, 14], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal", "code": "theorem mem_nonunits_iff_exists_mem_maximalIdeal {a : K} :\n    a \u2208 A.nonunits \u2194 \u2203 ha, (\u27e8a, ha\u27e9 : A) \u2208 LocalRing.maximalIdeal A", "start": [602, 1], "end": [610, 32], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.image_maximalIdeal", "code": "theorem image_maximalIdeal : ((\u2191) : A \u2192 K) '' LocalRing.maximalIdeal A = A.nonunits", "start": [613, 1], "end": [620, 7], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroup", "code": "def principalUnitGroup : Subgroup K\u02e3 where\n  carrier := {x | A.valuation (x - 1) < 1}\n  mul_mem' := by\n    intro a b ha hb\n    rw [Set.mem_setOf] at ha hb\n    refine' lt_of_le_of_lt _ (max_lt hb ha)\n    rw [\u2190 one_mul (A.valuation (b - 1)), \u2190 A.valuation.map_one_add_of_lt ha, add_sub_cancel'_right,\n      \u2190 Valuation.map_mul, mul_sub_one, \u2190 sub_add_sub_cancel (\u2191(a * b) : K) _ 1]\n    exact A.valuation.map_add _ _\n  one_mem' := by simp\n  inv_mem' := by\n    dsimp\n    intro a ha\n    conv =>\n      lhs\n      rw [\u2190 mul_one (A.valuation _), \u2190 A.valuation.map_one_add_of_lt ha]\n    rwa [add_sub_cancel'_right, \u2190 Valuation.map_mul, sub_mul, Units.inv_mul, \u2190 neg_sub, one_mul,\n      Valuation.map_neg]", "start": [627, 1], "end": [647, 25], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principal_units_le_units", "code": "theorem principal_units_le_units : A.principalUnitGroup \u2264 A.unitGroup", "start": [650, 1], "end": [651, 75], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_principalUnitGroup_iff", "code": "theorem mem_principalUnitGroup_iff (x : K\u02e3) :\n    x \u2208 A.principalUnitGroup \u2194 A.valuation ((x : K) - 1) < 1", "start": [654, 1], "end": [656, 10], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroup_le_principalUnitGroup", "code": "theorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :\n    B.principalUnitGroup \u2264 A.principalUnitGroup \u2194 A \u2264 B", "start": [659, 1], "end": [671, 77], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroup_injective", "code": "theorem principalUnitGroup_injective :\n    Function.Injective (principalUnitGroup : ValuationSubring K \u2192 Subgroup _)", "start": [674, 1], "end": [676, 81], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.eq_iff_principalUnitGroup", "code": "theorem eq_iff_principalUnitGroup {A B : ValuationSubring K} :\n    A = B \u2194 A.principalUnitGroup = B.principalUnitGroup", "start": [679, 1], "end": [681, 43], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroupOrderEmbedding", "code": "def principalUnitGroupOrderEmbedding : ValuationSubring K \u21aao (Subgroup K\u02e3)\u1d52\u1d48 where\n  toFun A := A.principalUnitGroup\n  inj' := principalUnitGroup_injective\n  map_rel_iff' {_A _B} := principalUnitGroup_le_principalUnitGroup", "start": [684, 1], "end": [688, 67], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_mem_principalUnitGroup_iff", "code": "theorem coe_mem_principalUnitGroup_iff {x : A.unitGroup} :\n    (x : K\u02e3) \u2208 A.principalUnitGroup \u2194\n      A.unitGroupMulEquiv x \u2208 (Units.map (LocalRing.residue A).toMonoidHom).ker", "start": [691, 1], "end": [697, 36], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroupEquiv", "code": "def principalUnitGroupEquiv :\n    A.principalUnitGroup \u2243* (Units.map (LocalRing.residue A).toMonoidHom).ker where\n  toFun x :=\n    \u27e8A.unitGroupMulEquiv \u27e8_, A.principal_units_le_units x.2\u27e9,\n      A.coe_mem_principalUnitGroup_iff.1 x.2\u27e9\n  invFun x :=\n    \u27e8A.unitGroupMulEquiv.symm x, by\n      rw [A.coe_mem_principalUnitGroup_iff]; simpa using SetLike.coe_mem x\u27e9\n  left_inv x := by simp\n  right_inv x := by simp\n  map_mul' x y := rfl", "start": [700, 1], "end": [712, 22], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroupEquiv_apply", "code": "@[simp, nolint simpNF]\ntheorem principalUnitGroupEquiv_apply (a : A.principalUnitGroup) :\n    (((principalUnitGroupEquiv A a : A\u02e3) : A) : K) = (a : K\u02e3)", "start": [716, 1], "end": [719, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.principalUnitGroup_symm_apply", "code": "@[simp, nolint simpNF]\ntheorem principalUnitGroup_symm_apply (a : (Units.map (LocalRing.residue A).toMonoidHom).ker) :\n    ((A.principalUnitGroupEquiv.symm a : K\u02e3) : K) = ((a : A\u02e3) : A)", "start": [723, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitGroupToResidueFieldUnits", "code": "def unitGroupToResidueFieldUnits : A.unitGroup \u2192* (LocalRing.ResidueField A)\u02e3 :=\n  MonoidHom.comp (Units.map <| (Ideal.Quotient.mk _).toMonoidHom) A.unitGroupMulEquiv.toMonoidHom", "start": [729, 1], "end": [731, 98], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_unitGroupToResidueFieldUnits_apply", "code": "@[simp]\ntheorem coe_unitGroupToResidueFieldUnits_apply (x : A.unitGroup) :\n    (A.unitGroupToResidueFieldUnits x : LocalRing.ResidueField A) =\n      Ideal.Quotient.mk _ (A.unitGroupMulEquiv x : A)", "start": [734, 1], "end": [738, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.ker_unitGroupToResidueFieldUnits", "code": "theorem ker_unitGroupToResidueFieldUnits :\n    A.unitGroupToResidueFieldUnits.ker = A.principalUnitGroup.comap A.unitGroup.subtype", "start": [741, 1], "end": [748, 6], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.surjective_unitGroupToResidueFieldUnits", "code": "theorem surjective_unitGroupToResidueFieldUnits :\n    Function.Surjective A.unitGroupToResidueFieldUnits", "start": [752, 1], "end": [756, 28], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits", "code": "def unitsModPrincipalUnitsEquivResidueFieldUnits :\n    A.unitGroup \u29f8 A.principalUnitGroup.comap A.unitGroup.subtype \u2243* (LocalRing.ResidueField A)\u02e3 :=\n  (QuotientGroup.quotientMulEquivOfEq A.ker_unitGroupToResidueFieldUnits.symm).trans\n    (QuotientGroup.quotientKerEquivOfSurjective _ A.surjective_unitGroupToResidueFieldUnits)", "start": [759, 1], "end": [764, 93], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk", "code": "theorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom.comp (QuotientGroup.mk' _) =\n      A.unitGroupToResidueFieldUnits", "start": [772, 1], "end": [774, 44], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply", "code": "@[simp, nolint simpNF]\ntheorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply\n    (x : A.unitGroup) :\n    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom (QuotientGroup.mk x) =\n      A.unitGroupToResidueFieldUnits x", "start": [778, 1], "end": [782, 46], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwiseHasSMul", "code": "def pointwiseHasSMul : SMul G (ValuationSubring K) where\n  smul g S :={ g \u2022 S.toSubring with\n      mem_or_inv_mem' := fun x =>\n        (mem_or_inv_mem S (g\u207b\u00b9 \u2022 x)).imp Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr fun h =>\n          Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr <| by rwa [smul_inv''] }", "start": [805, 1], "end": [813, 83], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (g : G) (S : ValuationSubring K) : \u2191(g \u2022 S) = g \u2022 (S : Set K)", "start": [820, 1], "end": [821, 96], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwise_smul_toSubring", "code": "@[simp]\ntheorem pointwise_smul_toSubring (g : G) (S : ValuationSubring K) :\n    (g \u2022 S).toSubring = g \u2022 S.toSubring", "start": [824, 1], "end": [826, 47], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwiseMulAction", "code": "def pointwiseMulAction : MulAction G (ValuationSubring K) :=\n  toSubring_injective.mulAction toSubring pointwise_smul_toSubring", "start": [829, 1], "end": [835, 67], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (g : G) (x : K) (S : ValuationSubring K) : x \u2208 S \u2192 g \u2022 x \u2208 g \u2022 S", "start": [842, 1], "end": [843, 52], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_smul_pointwise_iff_exists", "code": "theorem mem_smul_pointwise_iff_exists (g : G) (x : K) (S : ValuationSubring K) :\n    x \u2208 g \u2022 S \u2194 \u2203 s : K, s \u2208 S \u2227 g \u2022 s = x", "start": [846, 1], "end": [848, 47], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwise_central_scalar", "code": "instance pointwise_central_scalar [MulSemiringAction G\u1d50\u1d52\u1d56 K] [IsCentralScalar G K] :\n    IsCentralScalar G (ValuationSubring K) :=\n  \u27e8fun g S => toSubring_injective <| op_smul_eq_smul g S.toSubring\u27e9", "start": [851, 1], "end": [853, 68], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.smul_mem_pointwise_smul_iff", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    g \u2022 x \u2208 g \u2022 S \u2194 x \u2208 S", "start": [856, 1], "end": [858, 55], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_pointwise_smul_iff_inv_smul_mem", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem {g : G} {S : ValuationSubring K} {x : K} :\n    x \u2208 g \u2022 S \u2194 g\u207b\u00b9 \u2022 x \u2208 S", "start": [861, 1], "end": [862, 65], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_inv_pointwise_smul_iff", "code": "theorem mem_inv_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :\n    x \u2208 g\u207b\u00b9 \u2022 S \u2194 g \u2022 x \u2208 S", "start": [865, 1], "end": [866, 56], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwise_smul_le_pointwise_smul_iff", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {g : G} {S T : ValuationSubring K} :\n    g \u2022 S \u2264 g \u2022 T \u2194 S \u2264 T", "start": [869, 1], "end": [871, 62], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.pointwise_smul_subset_iff", "code": "theorem pointwise_smul_subset_iff {g : G} {S T : ValuationSubring K} : g \u2022 S \u2264 T \u2194 S \u2264 g\u207b\u00b9 \u2022 T", "start": [874, 1], "end": [875, 26], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.subset_pointwise_smul_iff", "code": "theorem subset_pointwise_smul_iff {g : G} {S T : ValuationSubring K} : S \u2264 g \u2022 T \u2194 g\u207b\u00b9 \u2022 S \u2264 T", "start": [878, 1], "end": [879, 26], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.comap", "code": "def comap (A : ValuationSubring L) (f : K \u2192+* L) : ValuationSubring K :=\n  { A.toSubring.comap f with mem_or_inv_mem' := fun k => by simp [ValuationSubring.mem_or_inv_mem] }", "start": [888, 1], "end": [890, 101], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.coe_comap", "code": "@[simp]\ntheorem coe_comap (A : ValuationSubring L) (f : K \u2192+* L) : (A.comap f : Set K) = f \u207b\u00b9' A", "start": [893, 1], "end": [894, 96], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.mem_comap", "code": "@[simp]\ntheorem mem_comap {A : ValuationSubring L} {f : K \u2192+* L} {x : K} : x \u2208 A.comap f \u2194 f x \u2208 A", "start": [897, 1], "end": [899, 10], "kind": "commanddeclaration"}, {"full_name": "ValuationSubring.comap_comap", "code": "theorem comap_comap (A : ValuationSubring J) (g : L \u2192+* J) (f : K \u2192+* L) :\n    (A.comap g).comap f = A.comap (g.comp f)", "start": [902, 1], "end": [903, 52], "kind": "commanddeclaration"}, {"full_name": "Valuation.mem_unitGroup_iff", "code": "theorem mem_unitGroup_iff : x \u2208 v.valuationSubring.unitGroup \u2194 v x = 1", "start": [915, 1], "end": [916, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/ValuedField.lean", "imports": ["Mathlib/Topology/Algebra/WithZeroTopology.lean", "Mathlib/Topology/Algebra/UniformField.lean", "Mathlib/Topology/Algebra/Valuation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Valuation.inversion_estimate", "code": "theorem Valuation.inversion_estimate {x y : K} {\u03b3 : \u0393\u2080\u02e3} (y_ne : y \u2260 0)\n    (h : v (x - y) < min (\u03b3 * (v y * v y)) (v y)) : v (x\u207b\u00b9 - y\u207b\u00b9) < \u03b3", "start": [51, 1], "end": [72, 19], "kind": "commanddeclaration"}, {"full_name": "Valued.topologicalDivisionRing", "code": "instance (priority := 100) Valued.topologicalDivisionRing [Valued K \u0393\u2080] :\n    TopologicalDivisionRing K :=\n  { (by infer_instance : TopologicalRing K) with\n    continuousAt_inv\u2080 := by\n      intro x x_ne s s_in\n      cases' Valued.mem_nhds.mp s_in with \u03b3 hs; clear s_in\n      rw [mem_map, Valued.mem_nhds]\n      change \u2203 \u03b3 : \u0393\u2080\u02e3, { y : K | (v (y - x) : \u0393\u2080) < \u03b3 } \u2286 { x : K | x\u207b\u00b9 \u2208 s }\n      have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n      let \u03b3' := Units.mk0 _ vx_ne\n      use min (\u03b3 * (\u03b3' * \u03b3')) \u03b3'\n      intro y y_in\n      apply hs\n      simp only [mem_setOf_eq] at y_in\n      rw [Units.min_val, Units.val_mul, Units.val_mul] at y_in\n      exact Valuation.inversion_estimate _ x_ne y_in }", "start": [79, 1], "end": [96, 55], "kind": "commanddeclaration"}, {"full_name": "ValuedRing.separated", "code": "instance (priority := 100) ValuedRing.separated [Valued K \u0393\u2080] : SeparatedSpace K := by\n  rw [separated_iff_t2]\n  apply TopologicalAddGroup.t2Space_of_zero_sep\n  intro x x_ne\n  refine' \u27e8{ k | v k < v x }, _, fun h => lt_irrefl _ h\u27e9\n  rw [Valued.mem_nhds]\n  have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne\n  let \u03b3' := Units.mk0 _ vx_ne\n  exact \u27e8\u03b3', fun y hy => by simpa using hy\u27e9", "start": [99, 1], "end": [108, 44], "kind": "commanddeclaration"}, {"full_name": "Valued.continuous_valuation", "code": "theorem Valued.continuous_valuation [Valued K \u0393\u2080] : Continuous (v : K \u2192 \u0393\u2080)", "start": [117, 1], "end": [127, 32], "kind": "commanddeclaration"}, {"full_name": "Valued.completable", "code": "instance (priority := 100) completable : CompletableTopField K :=\n  { ValuedRing.separated with\n    nice := by\n      rintro F hF h0\n      have : \u2203 \u03b3\u2080 : \u0393\u2080\u02e3, \u2203 M \u2208 F, \u2200 x \u2208 M, (\u03b3\u2080 : \u0393\u2080) \u2264 v x := by\n        rcases Filter.inf_eq_bot_iff.mp h0 with \u27e8U, U_in, M, M_in, H\u27e9\n        rcases Valued.mem_nhds_zero.mp U_in with \u27e8\u03b3\u2080, hU\u27e9\n        exists \u03b3\u2080, M, M_in\n        intro x xM\n        apply le_of_not_lt _\n        intro hyp\n        have : x \u2208 U \u2229 M := \u27e8hU hyp, xM\u27e9\n        rwa [H] at this\n      rcases this with \u27e8\u03b3\u2080, M\u2080, M\u2080_in, H\u2080\u27e9\n      rw [Valued.cauchy_iff] at hF \u22a2\n      refine' \u27e8hF.1.map _, _\u27e9\n      replace hF := hF.2\n      intro \u03b3\n      rcases hF (min (\u03b3 * \u03b3\u2080 * \u03b3\u2080) \u03b3\u2080) with \u27e8M\u2081, M\u2081_in, H\u2081\u27e9\n      clear hF\n      use (fun x : K => x\u207b\u00b9) '' (M\u2080 \u2229 M\u2081)\n      constructor\n      \u00b7 rw [mem_map]\n        apply mem_of_superset (Filter.inter_mem M\u2080_in M\u2081_in)\n        exact subset_preimage_image _ _\n      \u00b7 rintro _ \u27e8x, \u27e8x_in\u2080, x_in\u2081\u27e9, rfl\u27e9 _ \u27e8y, \u27e8y_in\u2080, y_in\u2081\u27e9, rfl\u27e9\n        simp only [mem_setOf_eq]\n        specialize H\u2081 x x_in\u2081 y y_in\u2081\n        replace x_in\u2080 := H\u2080 x x_in\u2080\n        replace := H\u2080 y y_in\u2080\n        clear H\u2080\n        apply Valuation.inversion_estimate\n        \u00b7 have : (v x : \u0393\u2080) \u2260 0 := by\n            intro h\n            rw [h] at x_in\u2080\n            simp at x_in\u2080\n          exact (Valuation.ne_zero_iff _).mp this\n        \u00b7 refine' lt_of_lt_of_le H\u2081 _\n          rw [Units.min_val]\n          apply min_le_min _ x_in\u2080\n          rw [mul_assoc]\n          have : ((\u03b3\u2080 * \u03b3\u2080 : \u0393\u2080\u02e3) : \u0393\u2080) \u2264 v x * v x :=\n            calc\n              \u2191\u03b3\u2080 * \u2191\u03b3\u2080 \u2264 \u2191\u03b3\u2080 * v x := mul_le_mul_left' x_in\u2080 \u2191\u03b3\u2080\n              _ \u2264 _ := mul_le_mul_right' x_in\u2080 (v x)\n          rw [Units.val_mul]\n          exact mul_le_mul_left' this \u03b3 }", "start": [144, 1], "end": [191, 42], "kind": "commanddeclaration"}, {"full_name": "Valued.extension", "code": "noncomputable def extension : hat K \u2192 \u0393\u2080 :=\n  Completion.denseInducing_coe.extend (v : K \u2192 \u0393\u2080)", "start": [196, 1], "end": [198, 51], "kind": "commanddeclaration"}, {"full_name": "Valued.continuous_extension", "code": "theorem continuous_extension : Continuous (Valued.extension : hat K \u2192 \u0393\u2080)", "start": [201, 1], "end": [273, 40], "kind": "commanddeclaration"}, {"full_name": "Valued.extension_extends", "code": "@[simp, norm_cast]\ntheorem extension_extends (x : K) : extension (x : hat K) = v x", "start": [276, 1], "end": [280, 49], "kind": "commanddeclaration"}, {"full_name": "Valued.extensionValuation", "code": "noncomputable def extensionValuation : Valuation (hat K) \u0393\u2080 where\n  toFun := Valued.extension\n  map_zero' := by\n    rw [\u2190 v.map_zero (R := K), \u2190 Valued.extension_extends (0 : K)]\n    rfl\n  map_one' := by\n    simp only\n    rw [\u2190 Completion.coe_one, Valued.extension_extends (1 : K)]\n    exact Valuation.map_one _\n  map_mul' x y := by\n    apply Completion.induction_on\u2082 x y\n      (p := fun x y => extension (x * y) = extension x * extension y)\n    \u00b7 have c1 : Continuous fun x : hat K \u00d7 hat K => Valued.extension (x.1 * x.2) :=\n        Valued.continuous_extension.comp (continuous_fst.mul continuous_snd)\n      have c2 : Continuous fun x : hat K \u00d7 hat K => Valued.extension x.1 * Valued.extension x.2 :=\n        (Valued.continuous_extension.comp continuous_fst).mul\n          (Valued.continuous_extension.comp continuous_snd)\n      exact isClosed_eq c1 c2\n    \u00b7 intro x y\n      norm_cast\n      exact Valuation.map_mul _ _ _\n  map_add_le_max' x y := by\n    rw [le_max_iff]\n    apply Completion.induction_on\u2082 x y\n      (p := fun x y => extension (x + y) \u2264 extension x \u2228 extension (x + y) \u2264 extension y)\n    \u00b7 have cont : Continuous (Valued.extension : hat K \u2192 \u0393\u2080) := Valued.continuous_extension\n      exact\n        (isClosed_le (cont.comp continuous_add) <| cont.comp continuous_fst).union\n          (isClosed_le (cont.comp continuous_add) <| cont.comp continuous_snd)\n    \u00b7 intro x y\n      norm_cast\n      rw [\u2190 le_max_iff]\n      exact v.map_add x y", "start": [283, 1], "end": [316, 26], "kind": "commanddeclaration"}, {"full_name": "Valued.closure_coe_completion_v_lt", "code": "theorem closure_coe_completion_v_lt {\u03b3 : \u0393\u2080\u02e3} :\n    closure ((\u2191) '' { x : K | v x < (\u03b3 : \u0393\u2080) }) =\n    { x : hat K | extensionValuation x < (\u03b3 : \u0393\u2080) }", "start": [320, 1], "end": [346, 35], "kind": "commanddeclaration"}, {"full_name": "Valued.valuedCompletion", "code": "noncomputable instance valuedCompletion : Valued (hat K) \u0393\u2080 where\n  v := extensionValuation\n  is_topological_valuation s := by\n    suffices\n      HasBasis (\ud835\udcdd (0 : hat K)) (fun _ => True) fun \u03b3 : \u0393\u2080\u02e3 => { x | extensionValuation x < \u03b3 } by\n      rw [this.mem_iff]\n      exact exists_congr fun \u03b3 => by simp\n    simp_rw [\u2190 closure_coe_completion_v_lt]\n    exact (hasBasis_nhds_zero K \u0393\u2080).hasBasis_of_denseInducing Completion.denseInducing_coe", "start": [349, 1], "end": [357, 91], "kind": "commanddeclaration"}, {"full_name": "Valued.valuedCompletion_apply", "code": "@[simp]\ntheorem valuedCompletion_apply (x : K) : Valued.v (x : hat K) = v x", "start": [362, 1], "end": [364, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Traversable/Equiv.lean", "imports": ["Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.map", "code": "protected def map {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (x : t' \u03b1) : t' \u03b2 :=\n  eqv \u03b2 <| map f ((eqv \u03b1).symm x)", "start": [41, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.functor", "code": "protected def functor : Functor t' where map := Equiv.map eqv", "start": [49, 1], "end": [51, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.id_map", "code": "protected theorem id_map {\u03b1 : Type u} (x : t' \u03b1) : Equiv.map eqv id x = x", "start": [57, 1], "end": [58, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_map", "code": "protected theorem comp_map {\u03b1 \u03b2 \u03b3 : Type u} (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 \u03b3) (x : t' \u03b1) :\n    Equiv.map eqv (h \u2218 g) x = Equiv.map eqv h (Equiv.map eqv g x)", "start": [61, 1], "end": [63, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.lawfulFunctor", "code": "protected theorem lawfulFunctor : @LawfulFunctor _ (Equiv.functor eqv)", "start": [66, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.lawfulFunctor'", "code": "protected theorem lawfulFunctor' [F : Functor t']\n    (h\u2080 : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2), Functor.map f = Equiv.map eqv f)\n    (h\u2081 : \u2200 {\u03b1 \u03b2} (f : \u03b2), Functor.mapConst f = (Equiv.map eqv \u2218 Function.const \u03b1) f) :\n    LawfulFunctor t'", "start": [74, 1], "end": [83, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.traverse", "code": "protected def traverse (f : \u03b1 \u2192 m \u03b2) (x : t' \u03b1) : m (t' \u03b2) :=\n  eqv \u03b2 <$> traverse f ((eqv \u03b1).symm x)", "start": [98, 1], "end": [102, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.traversable", "code": "protected def traversable : Traversable t' where\n  toFunctor := Equiv.functor eqv\n  traverse := Equiv.traverse eqv", "start": [105, 1], "end": [109, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.id_traverse", "code": "protected theorem id_traverse (x : t' \u03b1) : Equiv.traverse eqv (pure : \u03b1 \u2192 Id \u03b1) x = x", "start": [133, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.traverse_eq_map_id", "code": "protected theorem traverse_eq_map_id (f : \u03b1 \u2192 \u03b2) (x : t' \u03b1) :\n    Equiv.traverse eqv ((pure : \u03b2 \u2192 Id \u03b2) \u2218 f) x = pure (Equiv.map eqv f x)", "start": [138, 1], "end": [140, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_traverse", "code": "protected theorem comp_traverse (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : t' \u03b1) :\n    Equiv.traverse eqv (Comp.mk \u2218 Functor.map f \u2218 g) x =\n      Comp.mk (Equiv.traverse eqv f <$> Equiv.traverse eqv g x)", "start": [143, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.naturality", "code": "protected theorem naturality (f : \u03b1 \u2192 F \u03b2) (x : t' \u03b1) :\n    \u03b7 (Equiv.traverse eqv f x) = Equiv.traverse eqv (@\u03b7 _ \u2218 f) x", "start": [149, 1], "end": [151, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.isLawfulTraversable", "code": "protected theorem isLawfulTraversable : @LawfulTraversable t' (Equiv.traversable eqv)", "start": [154, 1], "end": [164, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.isLawfulTraversable'", "code": "protected theorem isLawfulTraversable' [Traversable t']\n    (h\u2080 : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2), map f = Equiv.map eqv f)\n    (h\u2081 : \u2200 {\u03b1 \u03b2} (f : \u03b2), mapConst f = (Equiv.map eqv \u2218 Function.const \u03b1) f)\n    (h\u2082 :\n      \u2200 {F : Type u \u2192 Type u} [Applicative F],\n        \u2200 [LawfulApplicative F] {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2), traverse f = Equiv.traverse eqv f) :\n    LawfulTraversable t'", "start": [167, 1], "end": [187, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Unitization.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Algebra/Algebra/Unitization.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Unitization.splitMul", "code": "def splitMul : Unitization \ud835\udd5c A \u2192\u2090[\ud835\udd5c] \ud835\udd5c \u00d7 (A \u2192L[\ud835\udd5c] A) :=\n  (lift 0).prod (lift <| NonUnitalAlgHom.Lmul \ud835\udd5c A)", "start": [67, 1], "end": [74, 51], "kind": "commanddeclaration"}, {"full_name": "Unitization.splitMul_apply", "code": "@[simp]\ntheorem splitMul_apply (x : Unitization \ud835\udd5c A) :\n    splitMul \ud835\udd5c A x = (x.fst, algebraMap \ud835\udd5c (A \u2192L[\ud835\udd5c] A) x.fst + mul \ud835\udd5c A x.snd)", "start": [78, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Unitization.splitMul_injective_of_clm_mul_injective", "code": "theorem splitMul_injective_of_clm_mul_injective\n    (h : Function.Injective (mul \ud835\udd5c A)) :\n    Function.Injective (splitMul \ud835\udd5c A)", "start": [83, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Unitization.splitMul_injective", "code": "theorem splitMul_injective : Function.Injective (splitMul \ud835\udd5c A)", "start": [105, 1], "end": [106, 71], "kind": "commanddeclaration"}, {"full_name": "Unitization.normedRingAux", "code": "@[reducible]\nnoncomputable def normedRingAux : NormedRing (Unitization \ud835\udd5c A) :=\n  @NormedRing.induced _ (Unitization \ud835\udd5c A) (\ud835\udd5c \u00d7 (A \u2192L[\ud835\udd5c] A)) Unitization.instRing\n    Prod.normedRing _ (splitMul \ud835\udd5c A) (splitMul_injective \ud835\udd5c A)", "start": [112, 1], "end": [119, 62], "kind": "commanddeclaration"}, {"full_name": "Unitization.normedAlgebraAux", "code": "@[reducible]\nnoncomputable def normedAlgebraAux : NormedAlgebra \ud835\udd5c (Unitization \ud835\udd5c A) :=\n  NormedAlgebra.induced \ud835\udd5c (Unitization \ud835\udd5c A) (\ud835\udd5c \u00d7 (A \u2192L[\ud835\udd5c] A)) (splitMul \ud835\udd5c A)", "start": [124, 1], "end": [129, 77], "kind": "commanddeclaration"}, {"full_name": "Unitization.norm_def", "code": "theorem norm_def (x : Unitization \ud835\udd5c A) : \u2016x\u2016 = \u2016splitMul \ud835\udd5c A x\u2016", "start": [133, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Unitization.nnnorm_def", "code": "theorem nnnorm_def (x : Unitization \ud835\udd5c A) : \u2016x\u2016\u208a = \u2016splitMul \ud835\udd5c A x\u2016\u208a", "start": [136, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Unitization.norm_eq_sup", "code": "theorem norm_eq_sup (x : Unitization \ud835\udd5c A) :\n    \u2016x\u2016 = \u2016x.fst\u2016 \u2294 \u2016algebraMap \ud835\udd5c (A \u2192L[\ud835\udd5c] A) x.fst + mul \ud835\udd5c A x.snd\u2016", "start": [139, 1], "end": [142, 59], "kind": "commanddeclaration"}, {"full_name": "Unitization.nnnorm_eq_sup", "code": "theorem nnnorm_eq_sup (x : Unitization \ud835\udd5c A) :\n    \u2016x\u2016\u208a = \u2016x.fst\u2016\u208a \u2294 \u2016algebraMap \ud835\udd5c (A \u2192L[\ud835\udd5c] A) x.fst + mul \ud835\udd5c A x.snd\u2016\u208a", "start": [144, 1], "end": [148, 29], "kind": "commanddeclaration"}, {"full_name": "Unitization.lipschitzWith_addEquiv", "code": "theorem lipschitzWith_addEquiv :\n    LipschitzWith 2 (Unitization.addEquiv \ud835\udd5c A)", "start": [151, 1], "end": [167, 51], "kind": "commanddeclaration"}, {"full_name": "Unitization.antilipschitzWith_addEquiv", "code": "theorem antilipschitzWith_addEquiv :\n    AntilipschitzWith 2 (addEquiv \ud835\udd5c A)", "start": [169, 1], "end": [182, 91], "kind": "commanddeclaration"}, {"full_name": "Unitization.uniformity_eq_aux", "code": "theorem uniformity_eq_aux :\n    \ud835\udce4[instUniformSpaceProd.comap <| addEquiv \ud835\udd5c A] = \ud835\udce4 (Unitization \ud835\udd5c A)", "start": [187, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Unitization.cobounded_eq_aux", "code": "theorem cobounded_eq_aux :\n    @cobounded _ (Bornology.induced <| addEquiv \ud835\udd5c A) = cobounded (Unitization \ud835\udd5c A)", "start": [194, 1], "end": [197, 58], "kind": "commanddeclaration"}, {"full_name": "Unitization.instUniformSpace", "code": "instance instUniformSpace : UniformSpace (Unitization \ud835\udd5c A) :=\n  instUniformSpaceProd.comap (addEquiv \ud835\udd5c A)", "start": [201, 1], "end": [203, 44], "kind": "commanddeclaration"}, {"full_name": "Unitization.instBornology", "code": "instance instBornology : Bornology (Unitization \ud835\udd5c A) :=\n  Bornology.induced <| addEquiv \ud835\udd5c A", "start": [205, 1], "end": [207, 36], "kind": "commanddeclaration"}, {"full_name": "Unitization.uniformEmbedding_addEquiv", "code": "theorem uniformEmbedding_addEquiv : UniformEmbedding (addEquiv \ud835\udd5c A) where", "start": [209, 1], "end": [211, 34], "kind": "commanddeclaration"}, {"full_name": "Unitization.instCompleteSpace", "code": "instance instCompleteSpace [CompleteSpace \ud835\udd5c] [CompleteSpace A] :\n    CompleteSpace (Unitization \ud835\udd5c A) :=\n  (completeSpace_congr uniformEmbedding_addEquiv).mpr CompleteSpace.prod", "start": [213, 1], "end": [216, 73], "kind": "commanddeclaration"}, {"full_name": "Unitization.instMetricSpace", "code": "noncomputable instance instMetricSpace : MetricSpace (Unitization \ud835\udd5c A) :=\n  (normedRingAux.toMetricSpace.replaceUniformity uniformity_eq_aux).replaceBornology\n    fun s => Filter.ext_iff.1 cobounded_eq_aux (s\u1d9c)", "start": [218, 1], "end": [223, 52], "kind": "commanddeclaration"}, {"full_name": "Unitization.instNormedRing", "code": "noncomputable instance instNormedRing : NormedRing (Unitization \ud835\udd5c A)\n    where\n  dist_eq := normedRingAux.dist_eq\n  norm_mul := normedRingAux.norm_mul\n  norm := normedRingAux.norm", "start": [225, 1], "end": [231, 29], "kind": "commanddeclaration"}, {"full_name": "Unitization.instNormedAlgebra", "code": "instance instNormedAlgebra : NormedAlgebra \ud835\udd5c (Unitization \ud835\udd5c A) where\n  norm_smul_le k x := by\n    rw [norm_def, map_smul, norm_smul, \u2190 norm_def]", "start": [233, 1], "end": [237, 51], "kind": "commanddeclaration"}, {"full_name": "Unitization.instNormOneClass", "code": "instance instNormOneClass : NormOneClass (Unitization \ud835\udd5c A) where\n  norm_one := by simpa only [norm_eq_sup, fst_one, norm_one, snd_one, map_one, map_zero,\n      add_zero, ge_iff_le, sup_eq_left] using op_norm_le_bound _ zero_le_one fun x => by simp", "start": [239, 1], "end": [241, 94], "kind": "commanddeclaration"}, {"full_name": "Unitization.norm_inr", "code": "lemma norm_inr (a : A) : \u2016(a : Unitization \ud835\udd5c A)\u2016 = \u2016a\u2016 := by\n  simp [norm_eq_sup]", "start": [243, 1], "end": [244, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Unitization.nnnorm_inr", "code": "lemma nnnorm_inr (a : A) : \u2016(a : Unitization \ud835\udd5c A)\u2016\u208a = \u2016a\u2016\u208a :=\n  NNReal.eq <| norm_inr a", "start": [246, 1], "end": [247, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Unitization.isometry_inr", "code": "lemma isometry_inr : Isometry ((\u2191) : A \u2192 Unitization \ud835\udd5c A) :=\n  AddMonoidHomClass.isometry_of_norm (inrNonUnitalAlgHom \ud835\udd5c A) norm_inr", "start": [249, 1], "end": [250, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Unitization.dist_inr", "code": "lemma dist_inr (a b : A) : dist (a : Unitization \ud835\udd5c A) (b : Unitization \ud835\udd5c A) = dist a b :=\n  isometry_inr.dist_eq a b", "start": [252, 1], "end": [253, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Unitization.nndist_inr", "code": "lemma nndist_inr (a b : A) : nndist (a : Unitization \ud835\udd5c A) (b : Unitization \ud835\udd5c A) = nndist a b :=\n  isometry_inr.nndist_eq a b", "start": [255, 1], "end": [256, 29], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Energy.lean", "imports": ["Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Combinatorics/SimpleGraph/Density.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Rat/BigOperators.lean"], "premises": [{"full_name": "Finpartition.energy", "code": "def energy : \u211a :=\n  ((\u2211 uv in P.parts.offDiag, G.edgeDensity uv.1 uv.2 ^ 2) : \u211a) / (P.parts.card : \u211a) ^ 2", "start": [39, 1], "end": [42, 88], "kind": "commanddeclaration"}, {"full_name": "Finpartition.energy_nonneg", "code": "theorem energy_nonneg : 0 \u2264 P.energy G", "start": [45, 1], "end": [46, 79], "kind": "commanddeclaration"}, {"full_name": "Finpartition.energy_le_one", "code": "theorem energy_le_one : P.energy G \u2264 1", "start": [49, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Finpartition.coe_energy", "code": "@[simp, norm_cast]\ntheorem coe_energy {\ud835\udd5c : Type*} [LinearOrderedField \ud835\udd5c] : (P.energy G : \ud835\udd5c) =\n    (\u2211 uv in P.parts.offDiag, (G.edgeDensity uv.1 uv.2 : \ud835\udd5c) ^ 2) / (P.parts.card : \ud835\udd5c) ^ 2", "start": [63, 1], "end": [66, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Chunk.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Regularity/Equitabilise.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Bound.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Uniform.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SzemerediRegularity.chunk", "code": "noncomputable def chunk : Finpartition U :=\n  if hUcard : U.card = m * 4 ^ P.parts.card + (card \u03b1 / P.parts.card - m * 4 ^ P.parts.card) then\n    (atomise U <| P.nonuniformWitnesses G \u03b5 U).equitabilise <| card_aux\u2081 hUcard\n  else (atomise U <| P.nonuniformWitnesses G \u03b5 U).equitabilise <| card_aux\u2082 hP hU hUcard", "start": [62, 1], "end": [66, 89], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.star", "code": "noncomputable def star (V : Finset \u03b1) : Finset (Finset \u03b1) :=\n  (chunk hP G \u03b5 hU).parts.filter (\u00b7 \u2286 G.nonuniformWitness \u03b5 U V)", "start": [71, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.biUnion_star_subset_nonuniformWitness", "code": "theorem biUnion_star_subset_nonuniformWitness :\n    (star hP G \u03b5 hU V).biUnion id \u2286 G.nonuniformWitness \u03b5 U V", "start": [84, 1], "end": [86, 69], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.star_subset_chunk", "code": "theorem star_subset_chunk : star hP G \u03b5 hU V \u2286 (chunk hP G \u03b5 hU).parts", "start": [91, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_nonuniformWitness_sdiff_biUnion_star", "code": "private theorem card_nonuniformWitness_sdiff_biUnion_star (hV : V \u2208 P.parts) (hUV : U \u2260 V)\n    (h\u2082 : \u00acG.IsUniform \u03b5 U V) :\n    (G.nonuniformWitness \u03b5 U V \\ (star hP G \u03b5 hU V).biUnion id).card \u2264\n    2 ^ (P.parts.card - 1) * m", "start": [95, 1], "end": [127, 69], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.one_sub_eps_mul_card_nonuniformWitness_le_card_star", "code": "private theorem one_sub_eps_mul_card_nonuniformWitness_le_card_star (hV : V \u2208 P.parts)\n    (hUV : U \u2260 V) (hunif : \u00acG.IsUniform \u03b5 U V) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) :\n    (1 - \u03b5 / 10) * (G.nonuniformWitness \u03b5 U V).card \u2264 ((star hP G \u03b5 hU V).biUnion id).card", "start": [129, 1], "end": [178, 76], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_chunk", "code": "theorem card_chunk (hm : m \u2260 0) : (chunk hP G \u03b5 hU).parts.card = 4 ^ P.parts.card", "start": [183, 1], "end": [188, 96], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_eq_of_mem_parts_chunk", "code": "theorem card_eq_of_mem_parts_chunk (hs : s \u2208 (chunk hP G \u03b5 hU).parts) :\n    s.card = m \u2228 s.card = m + 1", "start": [191, 1], "end": [194, 65], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.m_le_card_of_mem_chunk_parts", "code": "theorem m_le_card_of_mem_chunk_parts (hs : s \u2208 (chunk hP G \u03b5 hU).parts) : m \u2264 s.card", "start": [197, 1], "end": [198, 69], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_le_m_add_one_of_mem_chunk_parts", "code": "theorem card_le_m_add_one_of_mem_chunk_parts (hs : s \u2208 (chunk hP G \u03b5 hU).parts) : s.card \u2264 m + 1", "start": [201, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_biUnion_star_le_m_add_one_card_star_mul", "code": "theorem card_biUnion_star_le_m_add_one_card_star_mul :\n    (((star hP G \u03b5 hU V).biUnion id).card : \u211d) \u2264 (star hP G \u03b5 hU V).card * (m + 1)", "start": [205, 1], "end": [208, 65], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.le_sum_card_subset_chunk_parts", "code": "private theorem le_sum_card_subset_chunk_parts (h\ud835\udc9c : \ud835\udc9c \u2286 (chunk hP G \u03b5 hU).parts) (hs : s \u2208 \ud835\udc9c) :\n    (\ud835\udc9c.card : \u211d) * s.card * (m / (m + 1)) \u2264 (\ud835\udc9c.sup id).card", "start": [211, 1], "end": [217, 64], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.sum_card_subset_chunk_parts_le", "code": "private theorem sum_card_subset_chunk_parts_le (m_pos : (0 : \u211d) < m)\n    (h\ud835\udc9c : \ud835\udc9c \u2286 (chunk hP G \u03b5 hU).parts) (hs : s \u2208 \ud835\udc9c) :\n    ((\ud835\udc9c.sup id).card : \u211d) \u2264 \ud835\udc9c.card * s.card * ((m + 1) / m)", "start": [219, 1], "end": [227, 56], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.one_sub_le_m_div_m_add_one_sq", "code": "private theorem one_sub_le_m_div_m_add_one_sq [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5) :\n    \u21911 - \u03b5 ^ 5 / \u219150 \u2264 (m / (m + 1 : \u211d)) ^ 2", "start": [229, 1], "end": [241, 16], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.m_add_one_div_m_le_one_add", "code": "private theorem m_add_one_div_m_le_one_add [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) : ((m + 1 : \u211d) / m) ^ 2 \u2264 \u21911 + \u03b5 ^ 5 / 49", "start": [243, 1], "end": [257, 66], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.density_sub_eps_le_sum_density_div_card", "code": "private theorem density_sub_eps_le_sum_density_div_card [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    {hU : U \u2208 P.parts} {hV : V \u2208 P.parts} {A B : Finset (Finset \u03b1)}\n    (hA : A \u2286 (chunk hP G \u03b5 hU).parts) (hB : B \u2286 (chunk hP G \u03b5 hV).parts) :\n    (G.edgeDensity (A.biUnion id) (B.biUnion id)) - \u03b5 ^ 5 / 50 \u2264\n    (\u2211 ab in A.product B, (G.edgeDensity ab.1 ab.2 : \u211d)) / (A.card * B.card)", "start": [259, 1], "end": [295, 94], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.sum_density_div_card_le_density_add_eps", "code": "private theorem sum_density_div_card_le_density_add_eps [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) {hU : U \u2208 P.parts} {hV : V \u2208 P.parts} {A B : Finset (Finset \u03b1)}\n    (hA : A \u2286 (chunk hP G \u03b5 hU).parts) (hB : B \u2286 (chunk hP G \u03b5 hV).parts) :\n    (\u2211 ab in A.product B, G.edgeDensity ab.1 ab.2 : \u211d) / (A.card * B.card) \u2264\n    G.edgeDensity (A.biUnion id) (B.biUnion id) + \u03b5 ^ 5 / 49", "start": [297, 1], "end": [333, 94], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.average_density_near_total_density", "code": "private theorem average_density_near_total_density [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) {hU : U \u2208 P.parts} {hV : V \u2208 P.parts} {A B : Finset (Finset \u03b1)}\n    (hA : A \u2286 (chunk hP G \u03b5 hU).parts) (hB : B \u2286 (chunk hP G \u03b5 hV).parts) :\n    |(\u2211 ab in A.product B, G.edgeDensity ab.1 ab.2 : \u211d) / (A.card * B.card) -\n      G.edgeDensity (A.biUnion id) (B.biUnion id)| \u2264 \u03b5 ^ 5 / 49", "start": [335, 1], "end": [350, 62], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.edgeDensity_chunk_aux", "code": "private theorem edgeDensity_chunk_aux [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (hU : U \u2208 P.parts) (hV : V \u2208 P.parts) :\n    (G.edgeDensity U V : \u211d) ^ 2 - \u03b5 ^ 5 / \u219125 \u2264\n    ((\u2211 ab in (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts,\n      (G.edgeDensity ab.1 ab.2 : \u211d)) / \u219116 ^ P.parts.card) ^ 2", "start": [352, 1], "end": [378, 95], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.abs_density_star_sub_density_le_eps", "code": "private theorem abs_density_star_sub_density_le_eps (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) {hU : U \u2208 P.parts} {hV : V \u2208 P.parts} (hUV' : U \u2260 V) (hUV : \u00acG.IsUniform \u03b5 U V) :\n    |(G.edgeDensity ((star hP G \u03b5 hU V).biUnion id) ((star hP G \u03b5 hV U).biUnion id) : \u211d) -\n      G.edgeDensity (G.nonuniformWitness \u03b5 U V) (G.nonuniformWitness \u03b5 V U)| \u2264 \u03b5 / 5", "start": [380, 1], "end": [390, 11], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.eps_le_card_star_div", "code": "private theorem eps_le_card_star_div [Nonempty \u03b1] (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1)\n    (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5) (h\u03b5\u2081 : \u03b5 \u2264 1) (hU : U \u2208 P.parts) (hV : V \u2208 P.parts)\n    (hUV : U \u2260 V) (hunif : \u00acG.IsUniform \u03b5 U V) :\n    \u21914 / \u21915 * \u03b5 \u2264 (star hP G \u03b5 hU V).card / \u21914 ^ P.parts.card", "start": [392, 1], "end": [424, 15], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.edgeDensity_star_not_uniform", "code": "private theorem edgeDensity_star_not_uniform [Nonempty \u03b1]\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (h\u03b5\u2081 : \u03b5 \u2264 1) {hU : U \u2208 P.parts} {hV : V \u2208 P.parts} (hUVne : U \u2260 V) (hUV : \u00acG.IsUniform \u03b5 U V) :\n    \u21913 / \u21914 * \u03b5 \u2264\n    |(\u2211 ab in (star hP G \u03b5 hU V).product (star hP G \u03b5 hV U), (G.edgeDensity ab.1 ab.2 : \u211d)) /\n      ((star hP G \u03b5 hU V).card * (star hP G \u03b5 hV U).card) -\n        (\u2211 ab in (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts,\n          (G.edgeDensity ab.1 ab.2 : \u211d)) / (16 : \u211d) ^ P.parts.card|", "start": [433, 1], "end": [471, 18], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.edgeDensity_chunk_not_uniform", "code": "theorem edgeDensity_chunk_not_uniform [Nonempty \u03b1] (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1)\n    (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5) (h\u03b5\u2081 : \u03b5 \u2264 1) {hU : U \u2208 P.parts} {hV : V \u2208 P.parts}\n    (hUVne : U \u2260 V) (hUV : \u00acG.IsUniform \u03b5 U V) :\n    (G.edgeDensity U V : \u211d) ^ 2 - \u03b5 ^ 5 / \u219125 + \u03b5 ^ 4 / \u21913 \u2264\n    (\u2211 ab in (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts,\n      (G.edgeDensity ab.1 ab.2 : \u211d) ^ 2) / \u219116 ^ P.parts.card", "start": [473, 1], "end": [522, 22], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.edgeDensity_chunk_uniform", "code": "theorem edgeDensity_chunk_uniform [Nonempty \u03b1] (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1)\n    (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5) (hU : U \u2208 P.parts) (hV : V \u2208 P.parts) :\n    (G.edgeDensity U V : \u211d) ^ 2 - \u03b5 ^ 5 / \u219125 \u2264\n    (\u2211 ab in (chunk hP G \u03b5 hU).parts.product (chunk hP G \u03b5 hV).parts,\n      (G.edgeDensity ab.1 ab.2 : \u211d) ^ 2) / \u219116 ^ P.parts.card", "start": [525, 1], "end": [538, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Matrix.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Reindex.lean", "Mathlib/LinearAlgebra/Matrix/ToLinearEquiv.lean", "Mathlib/Algebra/Lie/OfAssociative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "lieEquivMatrix'", "code": "def lieEquivMatrix' : Module.End R (n \u2192 R) \u2243\u2097\u2045R\u2046 Matrix n n R :=\n  { LinearMap.toMatrix' with\n    map_lie' := fun {T S} => by\n      let f := @LinearMap.toMatrix' R _ n n _ _\n      change f (T.comp S - S.comp T) = f T * f S - f S * f T\n      have h : \u2200 T S : Module.End R _, f (T.comp S) = f T * f S := LinearMap.toMatrix'_comp\n      rw [LinearEquiv.map_sub, h, h] }", "start": [41, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "lieEquivMatrix'_apply", "code": "@[simp]\ntheorem lieEquivMatrix'_apply (f : Module.End R (n \u2192 R)) :\n    lieEquivMatrix' f = LinearMap.toMatrix' f", "start": [52, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "lieEquivMatrix'_symm_apply", "code": "@[simp]\ntheorem lieEquivMatrix'_symm_apply (A : Matrix n n R) :\n    (@lieEquivMatrix' R _ n _ _).symm A = Matrix.toLin' A", "start": [58, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.lieConj", "code": "def Matrix.lieConj (P : Matrix n n R) (h : Invertible P) : Matrix n n R \u2243\u2097\u2045R\u2046 Matrix n n R :=\n  ((@lieEquivMatrix' R _ n _ _).symm.trans (P.toLinearEquiv' h).lieConj).trans lieEquivMatrix'", "start": [64, 1], "end": [66, 95], "kind": "commanddeclaration"}, {"full_name": "Matrix.lieConj_apply", "code": "@[simp]\ntheorem Matrix.lieConj_apply (P A : Matrix n n R) (h : Invertible P) :\n    P.lieConj h A = P * A * P\u207b\u00b9", "start": [69, 1], "end": [73, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.lieConj_symm_apply", "code": "@[simp]\ntheorem Matrix.lieConj_symm_apply (P A : Matrix n n R) (h : Invertible P) :\n    (P.lieConj h).symm A = P\u207b\u00b9 * A * P", "start": [76, 1], "end": [80, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLieEquiv", "code": "def Matrix.reindexLieEquiv : Matrix n n R \u2243\u2097\u2045R\u2046 Matrix m m R :=\n  { Matrix.reindexLinearEquiv R R e e with\n    toFun := Matrix.reindex e e\n    map_lie' := fun {_ _} => by\n      simp only [LieRing.of_associative_ring_bracket, Matrix.reindex_apply,\n        Matrix.submatrix_mul_equiv, Matrix.submatrix_sub, Pi.sub_apply] }", "start": [85, 1], "end": [92, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLieEquiv_apply", "code": "@[simp]\ntheorem Matrix.reindexLieEquiv_apply (M : Matrix n n R) :\n    Matrix.reindexLieEquiv e M = Matrix.reindex e e M", "start": [95, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindexLieEquiv_symm", "code": "@[simp]\ntheorem Matrix.reindexLieEquiv_symm :\n    (Matrix.reindexLieEquiv e : _ \u2243\u2097\u2045R\u2046 _).symm = Matrix.reindexLieEquiv e.symm", "start": [101, 1], "end": [104, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/LocalProperties.lean", "imports": ["Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/RingTheory/RingHomProperties.lean", "Mathlib/RingTheory/Localization/Away/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Nilpotent.lean", "Mathlib/RingTheory/Localization/Submodule.lean", "Mathlib/RingTheory/FiniteType.lean", "Mathlib/RingTheory/Localization/Integer.lean"], "premises": [{"full_name": "LocalizationPreserves", "code": "def LocalizationPreserves : Prop :=\n  \u2200 {R : Type u} [hR : CommRing R] (M : Submonoid R) (S : Type u) [hS : CommRing S] [Algebra R S]\n    [IsLocalization M S], @P R hR \u2192 @P S hS", "start": [59, 1], "end": [63, 44], "kind": "commanddeclaration"}, {"full_name": "OfLocalizationMaximal", "code": "def OfLocalizationMaximal : Prop :=\n  \u2200 (R : Type u) [CommRing R],\n    (\u2200 (J : Ideal R) (_ : J.IsMaximal), P (Localization.AtPrime J)) \u2192 P R", "start": [66, 1], "end": [70, 74], "kind": "commanddeclaration"}, {"full_name": "RingHom.LocalizationPreserves", "code": "def RingHom.LocalizationPreserves :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S) (M : Submonoid R) (R' S' : Type u)\n    [CommRing R'] [CommRing S'] [Algebra R R'] [Algebra S S'] [IsLocalization M R']\n    [IsLocalization (M.map f) S'],\n    P f \u2192 P (IsLocalization.map S' f (Submonoid.le_comap_map M) : R' \u2192+* S')", "start": [79, 1], "end": [85, 77], "kind": "commanddeclaration"}, {"full_name": "RingHom.OfLocalizationFiniteSpan", "code": "def RingHom.OfLocalizationFiniteSpan :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S) (s : Finset R)\n    (_ : Ideal.span (s : Set R) = \u22a4) (_ : \u2200 r : s, P (Localization.awayMap f r)), P f", "start": [88, 1], "end": [96, 86], "kind": "commanddeclaration"}, {"full_name": "RingHom.OfLocalizationSpan", "code": "def RingHom.OfLocalizationSpan :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S) (s : Set R) (_ : Ideal.span s = \u22a4)\n    (_ : \u2200 r : s, P (Localization.awayMap f r)), P f", "start": [99, 1], "end": [107, 53], "kind": "commanddeclaration"}, {"full_name": "RingHom.HoldsForLocalizationAway", "code": "def RingHom.HoldsForLocalizationAway : Prop :=\n  \u2200 \u2983R : Type u\u2984 (S : Type u) [CommRing R] [CommRing S] [Algebra R S] (r : R)\n    [IsLocalization.Away r S], P (algebraMap R S)", "start": [110, 1], "end": [114, 50], "kind": "commanddeclaration"}, {"full_name": "RingHom.OfLocalizationFiniteSpanTarget", "code": "def RingHom.OfLocalizationFiniteSpanTarget : Prop :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S) (s : Finset S)\n    (_ : Ideal.span (s : Set S) = \u22a4)\n    (_ : \u2200 r : s, P ((algebraMap S (Localization.Away (r : S))).comp f)), P f", "start": [117, 1], "end": [126, 78], "kind": "commanddeclaration"}, {"full_name": "RingHom.OfLocalizationSpanTarget", "code": "def RingHom.OfLocalizationSpanTarget : Prop :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S) (s : Set S) (_ : Ideal.span s = \u22a4)\n    (_ : \u2200 r : s, P ((algebraMap S (Localization.Away (r : S))).comp f)), P f", "start": [129, 1], "end": [137, 78], "kind": "commanddeclaration"}, {"full_name": "RingHom.OfLocalizationPrime", "code": "def RingHom.OfLocalizationPrime : Prop :=\n  \u2200 \u2983R S : Type u\u2984 [CommRing R] [CommRing S] (f : R \u2192+* S),\n    (\u2200 (J : Ideal S) (_ : J.IsPrime), P (Localization.localRingHom _ J f rfl)) \u2192 P f", "start": [140, 1], "end": [144, 85], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal", "code": "structure RingHom.PropertyIsLocal : Prop where\n  LocalizationPreserves : RingHom.LocalizationPreserves @P\n  OfLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P\n  StableUnderComposition : RingHom.StableUnderComposition @P\n  HoldsForLocalizationAway : RingHom.HoldsForLocalizationAway @P", "start": [147, 1], "end": [153, 65], "kind": "commanddeclaration"}, {"full_name": "RingHom.ofLocalizationSpan_iff_finite", "code": "theorem RingHom.ofLocalizationSpan_iff_finite :\n    RingHom.OfLocalizationSpan @P \u2194 RingHom.OfLocalizationFiniteSpan @P", "start": [156, 1], "end": [166, 46], "kind": "commanddeclaration"}, {"full_name": "RingHom.ofLocalizationSpanTarget_iff_finite", "code": "theorem RingHom.ofLocalizationSpanTarget_iff_finite :\n    RingHom.OfLocalizationSpanTarget @P \u2194 RingHom.OfLocalizationFiniteSpanTarget @P", "start": [169, 1], "end": [179, 46], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.respectsIso", "code": "theorem RingHom.PropertyIsLocal.respectsIso (hP : RingHom.PropertyIsLocal @P) :\n    RingHom.RespectsIso @P", "start": [184, 1], "end": [192, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.LocalizationPreserves.away", "code": "theorem RingHom.LocalizationPreserves.away (H : RingHom.LocalizationPreserves @P) (r : R)\n    [IsLocalization.Away r R'] [IsLocalization.Away (f r) S'] (hf : P f) :\n    P (IsLocalization.Away.map R' S' f r)", "start": [196, 1], "end": [200, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.PropertyIsLocal.ofLocalizationSpan", "code": "theorem RingHom.PropertyIsLocal.ofLocalizationSpan (hP : RingHom.PropertyIsLocal @P) :\n    RingHom.OfLocalizationSpan @P", "start": [203, 1], "end": [212, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_of_localization_maximal", "code": "theorem Ideal.le_of_localization_maximal {I J : Ideal R}\n    (h : \u2200 (P : Ideal R) (hP : P.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I \u2264\n        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :\n    I \u2264 J", "start": [223, 1], "end": [244, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_of_localization_maximal", "code": "theorem Ideal.eq_of_localization_maximal {I J : Ideal R}\n    (h : \u2200 (P : Ideal R) (_ : P.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I =\n        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :\n    I = J", "start": [247, 1], "end": [255, 63], "kind": "commanddeclaration"}, {"full_name": "ideal_eq_bot_of_localization'", "code": "theorem ideal_eq_bot_of_localization' (I : Ideal R)\n    (h : \u2200 (J : Ideal R) (hJ : J.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime J)) I = \u22a5) :\n    I = \u22a5", "start": [258, 1], "end": [263, 69], "kind": "commanddeclaration"}, {"full_name": "ideal_eq_bot_of_localization", "code": "theorem ideal_eq_bot_of_localization (I : Ideal R)\n    (h : \u2200 (J : Ideal R) (hJ : J.IsMaximal),\n      IsLocalization.coeSubmodule (Localization.AtPrime J) I = \u22a5) :\n    I = \u22a5", "start": [268, 1], "end": [276, 25], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_localization", "code": "theorem eq_zero_of_localization (r : R)\n    (h : \u2200 (J : Ideal R) (hJ : J.IsMaximal), algebraMap R (Localization.AtPrime J) r = 0) :\n    r = 0", "start": [279, 1], "end": [289, 15], "kind": "commanddeclaration"}, {"full_name": "localization_isReduced", "code": "theorem localization_isReduced : LocalizationPreserves fun R hR => IsReduced R", "start": [296, 1], "end": [313, 38], "kind": "commanddeclaration"}, {"full_name": "isReduced_ofLocalizationMaximal", "code": "theorem isReduced_ofLocalizationMaximal : OfLocalizationMaximal fun R hR => IsReduced R", "start": [319, 1], "end": [326, 67], "kind": "commanddeclaration"}, {"full_name": "localizationPreserves_surjective", "code": "theorem localizationPreserves_surjective :\n    RingHom.LocalizationPreserves fun {R S} _ _ f => Function.Surjective f", "start": [333, 1], "end": [339, 30], "kind": "commanddeclaration"}, {"full_name": "surjective_ofLocalizationSpan", "code": "theorem surjective_ofLocalizationSpan :\n    RingHom.OfLocalizationSpan fun {R S} _ _ f => Function.Surjective f", "start": [342, 1], "end": [358, 30], "kind": "commanddeclaration"}, {"full_name": "localization_finite", "code": "theorem localization_finite : RingHom.LocalizationPreserves @RingHom.Finite", "start": [365, 1], "end": [398, 15], "kind": "commanddeclaration"}, {"full_name": "localization_away_map_finite", "code": "theorem localization_away_map_finite (r : R) [IsLocalization.Away r R']\n    [IsLocalization.Away (f r) S'] (hf : f.Finite) : (IsLocalization.Away.map R' S' f r).Finite", "start": [401, 1], "end": [403, 32], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.smul_mem_finsetIntegerMultiple_span", "code": "theorem IsLocalization.smul_mem_finsetIntegerMultiple_span [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x \u2208 Submodule.span R (s : Set S')) :\n    \u2203 m : M, m \u2022 x \u2208\n      Submodule.span R\n        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S)", "start": [406, 1], "end": [445, 31], "kind": "commanddeclaration"}, {"full_name": "multiple_mem_span_of_mem_localization_span", "code": "theorem multiple_mem_span_of_mem_localization_span [Algebra R' S] [Algebra R S]\n    [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S)\n    (hx : x \u2208 Submodule.span R' s) : \u2203 t : M, t \u2022 x \u2208 Submodule.span R s", "start": [448, 1], "end": [470, 6], "kind": "commanddeclaration"}, {"full_name": "multiple_mem_adjoin_of_mem_localization_adjoin", "code": "theorem multiple_mem_adjoin_of_mem_localization_adjoin [Algebra R' S] [Algebra R S]\n    [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S)\n    (hx : x \u2208 Algebra.adjoin R' s) : \u2203 t : M, t \u2022 x \u2208 Algebra.adjoin R s", "start": [473, 1], "end": [481, 63], "kind": "commanddeclaration"}, {"full_name": "finite_ofLocalizationSpan", "code": "theorem finite_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.Finite", "start": [484, 1], "end": [524, 69], "kind": "commanddeclaration"}, {"full_name": "localization_finiteType", "code": "theorem localization_finiteType : RingHom.LocalizationPreserves @RingHom.FiniteType", "start": [531, 1], "end": [558, 15], "kind": "commanddeclaration"}, {"full_name": "localization_away_map_finiteType", "code": "theorem localization_away_map_finiteType (r : R) [IsLocalization.Away r R']\n    [IsLocalization.Away (f r) S'] (hf : f.FiniteType) :\n    (IsLocalization.Away.map R' S' f r).FiniteType", "start": [561, 1], "end": [564, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.exists_smul_mem_of_mem_adjoin", "code": "theorem IsLocalization.exists_smul_mem_of_mem_adjoin [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] (M : Submonoid S) [IsLocalization M S'] (x : S) (s : Finset S')\n    (A : Subalgebra R S) (hA\u2081 : (IsLocalization.finsetIntegerMultiple M s : Set S) \u2286 A)\n    (hA\u2082 : M \u2264 A.toSubmonoid) (hx : algebraMap S S' x \u2208 Algebra.adjoin R (s : Set S')) :\n    \u2203 m : M, m \u2022 x \u2208 A", "start": [569, 1], "end": [592, 14], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.lift_mem_adjoin_finsetIntegerMultiple", "code": "theorem IsLocalization.lift_mem_adjoin_finsetIntegerMultiple [Algebra R S] [Algebra R S']\n    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')\n    (hx : algebraMap S S' x \u2208 Algebra.adjoin R (s : Set S')) :\n    \u2203 m : M, m \u2022 x \u2208\n      Algebra.adjoin R\n        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S)", "start": [595, 1], "end": [610, 59], "kind": "commanddeclaration"}, {"full_name": "finiteType_ofLocalizationSpan", "code": "theorem finiteType_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.FiniteType", "start": [613, 1], "end": [646, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/OfHasFiniteProducts.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.monoidalOfHasFiniteProducts", "code": "def monoidalOfHasFiniteProducts [HasTerminal C] [HasBinaryProducts C] : MonoidalCategory C :=\n  .ofTensorHom\n    (tensorUnit' := \u22a4_ C)\n    (tensorObj := fun X Y \u21a6 X \u2a2f Y)\n    (tensorHom := fun f g \u21a6 Limits.prod.map f g)\n    (associator := prod.associator)\n    (leftUnitor := fun P \u21a6 prod.leftUnitor P)\n    (rightUnitor := fun P \u21a6 prod.rightUnitor P)\n    (pentagon := prod.pentagon)\n    (triangle := prod.triangle)\n    (associator_naturality := @prod.associator_naturality _ _ _)", "start": [47, 1], "end": [58, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.tensorObj", "code": "@[simp]\ntheorem tensorObj (X Y : C) : X \u2297 Y = (X \u2a2f Y)", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.tensorHom", "code": "@[simp]\ntheorem tensorHom {W X Y Z : C} (f : W \u27f6 X) (g : Y \u27f6 Z) : f \u2297 g = Limits.prod.map f g", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.leftUnitor_hom", "code": "@[simp]\ntheorem leftUnitor_hom (X : C) : (\u03bb_ X).hom = Limits.prod.snd", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.leftUnitor_inv", "code": "@[simp]\ntheorem leftUnitor_inv (X : C) : (\u03bb_ X).inv = prod.lift (terminal.from X) (\ud835\udfd9 _)", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.rightUnitor_hom", "code": "@[simp]\ntheorem rightUnitor_hom (X : C) : (\u03c1_ X).hom = Limits.prod.fst", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.rightUnitor_inv", "code": "@[simp]\ntheorem rightUnitor_inv (X : C) : (\u03c1_ X).inv = prod.lift (\ud835\udfd9 _) (terminal.from X)", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.associator_hom", "code": "theorem associator_hom (X Y Z : C) :\n    (\u03b1_ X Y Z).hom =\n      prod.lift (Limits.prod.fst \u226b Limits.prod.fst)\n        (prod.lift (Limits.prod.fst \u226b Limits.prod.snd) Limits.prod.snd)", "start": [104, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteProducts.associator_inv", "code": "theorem associator_inv (X Y Z : C) :\n    (\u03b1_ X Y Z).inv =\n      prod.lift (prod.lift prod.fst (prod.snd \u226b prod.fst)) (prod.snd \u226b prod.snd)", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.symmetricOfHasFiniteProducts", "code": "@[simps]\ndef symmetricOfHasFiniteProducts [HasTerminal C] [HasBinaryProducts C] : SymmetricCategory C where\n  braiding X Y := Limits.prod.braiding X Y\n  braiding_naturality f g := by dsimp [tensorHom]; simp\n  hexagon_forward X Y Z := by dsimp [monoidalOfHasFiniteProducts.associator_hom]; simp\n  hexagon_reverse X Y Z := by dsimp [monoidalOfHasFiniteProducts.associator_inv]; simp\n  symmetry X Y := by dsimp; simp", "start": [124, 1], "end": [132, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts", "code": "def monoidalOfHasFiniteCoproducts [HasInitial C] [HasBinaryCoproducts C] : MonoidalCategory C :=\n  .ofTensorHom\n    (tensorUnit' := \u22a5_ C)\n    (tensorObj := fun X Y \u21a6 X \u2a3f Y)\n    (tensorHom := fun f g \u21a6 Limits.coprod.map f g)\n    (associator := coprod.associator)\n    (leftUnitor := coprod.leftUnitor)\n    (rightUnitor := coprod.rightUnitor)\n    (pentagon := coprod.pentagon)\n    (triangle := coprod.triangle)\n    (associator_naturality := @coprod.associator_naturality _ _ _)", "start": [139, 1], "end": [150, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.tensorObj", "code": "@[simp]\ntheorem tensorObj (X Y : C) : X \u2297 Y = (X \u2a3f Y)", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.tensorHom", "code": "@[simp]\ntheorem tensorHom {W X Y Z : C} (f : W \u27f6 X) (g : Y \u27f6 Z) : f \u2297 g = Limits.coprod.map f g", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.leftUnitor_hom", "code": "@[simp]\ntheorem leftUnitor_hom (X : C) : (\u03bb_ X).hom = coprod.desc (initial.to X) (\ud835\udfd9 _)", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.rightUnitor_hom", "code": "@[simp]\ntheorem rightUnitor_hom (X : C) : (\u03c1_ X).hom = coprod.desc (\ud835\udfd9 _) (initial.to X)", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.leftUnitor_inv", "code": "@[simp]\ntheorem leftUnitor_inv (X : C) : (\u03bb_ X).inv = Limits.coprod.inr", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.rightUnitor_inv", "code": "@[simp]\ntheorem rightUnitor_inv (X : C) : (\u03c1_ X).inv = Limits.coprod.inl", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.associator_hom", "code": "theorem associator_hom (X Y Z : C) :\n    (\u03b1_ X Y Z).hom =\n      coprod.desc (coprod.desc coprod.inl (coprod.inl \u226b coprod.inr)) (coprod.inr \u226b coprod.inr)", "start": [196, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoidalOfHasFiniteCoproducts.associator_inv", "code": "theorem associator_inv (X Y Z : C) :\n    (\u03b1_ X Y Z).inv =\n      coprod.desc (coprod.inl \u226b coprod.inl) (coprod.desc (coprod.inr \u226b coprod.inl) coprod.inr)", "start": [202, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.symmetricOfHasFiniteCoproducts", "code": "@[simps]\ndef symmetricOfHasFiniteCoproducts [HasInitial C] [HasBinaryCoproducts C] :\n    SymmetricCategory C where\n  braiding := Limits.coprod.braiding\n  braiding_naturality f g := by dsimp [tensorHom]; simp\n  hexagon_forward X Y Z := by dsimp [monoidalOfHasFiniteCoproducts.associator_hom]; simp\n  hexagon_reverse X Y Z := by dsimp [monoidalOfHasFiniteCoproducts.associator_inv]; simp\n  symmetry X Y := by dsimp; simp", "start": [215, 1], "end": [224, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Extr.lean", "imports": ["Mathlib/Topology/LocalExtr.lean", "Mathlib/Analysis/NormedSpace/Ray.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsMaxFilter.norm_add_sameRay", "code": "theorem IsMaxFilter.norm_add_sameRay (h : IsMaxFilter (norm \u2218 f) l c) (hy : SameRay \u211d (f c) y) :\n    IsMaxFilter (fun x => \u2016f x + y\u2016) l c", "start": [33, 1], "end": [42, 40], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.norm_add_self", "code": "theorem IsMaxFilter.norm_add_self (h : IsMaxFilter (norm \u2218 f) l c) :\n    IsMaxFilter (fun x => \u2016f x + f c\u2016) l c", "start": [45, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.norm_add_sameRay", "code": "theorem IsMaxOn.norm_add_sameRay (h : IsMaxOn (norm \u2218 f) s c) (hy : SameRay \u211d (f c) y) :\n    IsMaxOn (fun x => \u2016f x + y\u2016) s c", "start": [52, 1], "end": [57, 36], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.norm_add_self", "code": "theorem IsMaxOn.norm_add_self (h : IsMaxOn (norm \u2218 f) s c) : IsMaxOn (fun x => \u2016f x + f c\u2016) s c", "start": [60, 1], "end": [63, 30], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.norm_add_sameRay", "code": "theorem IsLocalMaxOn.norm_add_sameRay (h : IsLocalMaxOn (norm \u2218 f) s c) (hy : SameRay \u211d (f c) y) :\n    IsLocalMaxOn (fun x => \u2016f x + y\u2016) s c", "start": [70, 1], "end": [75, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.norm_add_self", "code": "theorem IsLocalMaxOn.norm_add_self (h : IsLocalMaxOn (norm \u2218 f) s c) :\n    IsLocalMaxOn (fun x => \u2016f x + f c\u2016) s c", "start": [78, 1], "end": [82, 30], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.norm_add_sameRay", "code": "theorem IsLocalMax.norm_add_sameRay (h : IsLocalMax (norm \u2218 f) c) (hy : SameRay \u211d (f c) y) :\n    IsLocalMax (fun x => \u2016f x + y\u2016) c", "start": [85, 1], "end": [90, 36], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.norm_add_self", "code": "theorem IsLocalMax.norm_add_self (h : IsLocalMax (norm \u2218 f) c) :\n    IsLocalMax (fun x => \u2016f x + f c\u2016) c", "start": [93, 1], "end": [97, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/ExtrClosure.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Topology/LocalExtr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsMaxOn.closure", "code": "protected theorem IsMaxOn.closure (h : IsMaxOn f s a) (hc : ContinuousOn f (closure s)) :\n    IsMaxOn f (closure s) a", "start": [27, 1], "end": [29, 94], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.closure", "code": "protected theorem IsMinOn.closure (h : IsMinOn f s a) (hc : ContinuousOn f (closure s)) :\n    IsMinOn f (closure s) a", "start": [32, 1], "end": [34, 20], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.closure", "code": "protected theorem IsExtrOn.closure (h : IsExtrOn f s a) (hc : ContinuousOn f (closure s)) :\n    IsExtrOn f (closure s) a", "start": [37, 1], "end": [39, 75], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.closure", "code": "protected theorem IsLocalMaxOn.closure (h : IsLocalMaxOn f s a) (hc : ContinuousOn f (closure s)) :\n    IsLocalMaxOn f (closure s) a", "start": [42, 1], "end": [51, 74], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.closure", "code": "protected theorem IsLocalMinOn.closure (h : IsLocalMinOn f s a) (hc : ContinuousOn f (closure s)) :\n    IsLocalMinOn f (closure s) a", "start": [54, 1], "end": [56, 33], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.closure", "code": "protected theorem IsLocalExtrOn.closure (h : IsLocalExtrOn f s a)\n    (hc : ContinuousOn f (closure s)) : IsLocalExtrOn f (closure s) a", "start": [59, 1], "end": [61, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticModuleCat", "code": "structure QuadraticModuleCat extends ModuleCat.{v} R where\n  \n  form : QuadraticForm R carrier", "start": [19, 1], "end": [22, 33], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.of", "code": "@[simps form]\ndef of {X : Type v} [AddCommGroup X] [Module R X] (Q : QuadraticForm R X) :\n    QuadraticModuleCat R where\n  form := Q", "start": [33, 1], "end": [37, 12], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.Hom", "code": "@[ext]\nstructure Hom (V W : QuadraticModuleCat.{v} R) :=\n  \n  toIsometry : V.form \u2192q\u1d62 W.form", "start": [39, 1], "end": [44, 33], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.Hom.toIsometry_injective", "code": "lemma Hom.toIsometry_injective (V W : QuadraticModuleCat.{v} R) :\n    Function.Injective (Hom.toIsometry : Hom V W \u2192 _) :=\n  fun \u27e8f\u27e9 \u27e8g\u27e9 _ => by congr", "start": [46, 1], "end": [48, 28], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticModuleCat.category", "code": "instance category : Category (QuadraticModuleCat.{v} R) where\n  Hom M N := Hom M N\n  id M := \u27e8Isometry.id M.form\u27e9\n  comp f g := \u27e8Isometry.comp g.toIsometry f.toIsometry\u27e9\n  id_comp g := Hom.ext _ _ <| Isometry.id_comp g.toIsometry\n  comp_id f := Hom.ext _ _ <| Isometry.comp_id f.toIsometry\n  assoc f g h := Hom.ext _ _ <| Isometry.comp_assoc h.toIsometry g.toIsometry f.toIsometry", "start": [50, 1], "end": [56, 91], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.hom_ext", "code": "@[ext]\nlemma hom_ext {M N : QuadraticModuleCat.{v} R} (f g : M \u27f6 N) (h : f.toIsometry = g.toIsometry) :\n    f = g :=\n  Hom.ext _ _ h", "start": [59, 1], "end": [62, 16], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticModuleCat.ofHom", "code": "abbrev ofHom {X : Type v} [AddCommGroup X] [Module R X]\n    {Q\u2081 : QuadraticForm R X} {Q\u2082 : QuadraticForm R X} (f : Q\u2081 \u2192q\u1d62 Q\u2082) :\n    of Q\u2081 \u27f6 of Q\u2082 :=\n  \u27e8f\u27e9", "start": [64, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.toIsometry_comp", "code": "@[simp] theorem toIsometry_comp {M N U : QuadraticModuleCat.{v} R} (f : M \u27f6 N) (g : N \u27f6 U) :\n    (f \u226b g).toIsometry = g.toIsometry.comp f.toIsometry", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.toIsometry_id", "code": "@[simp] theorem toIsometry_id {M : QuadraticModuleCat.{v} R}  :\n    Hom.toIsometry (\ud835\udfd9 M) = Isometry.id _", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.concreteCategory", "code": "instance concreteCategory : ConcreteCategory.{v} (QuadraticModuleCat.{v} R) where\n  forget :=\n    { obj := fun M => M\n      map := @fun M N f => f.toIsometry }\n  forget_faithful :=\n    { map_injective := @fun M N => FunLike.coe_injective.comp <| Hom.toIsometry_injective _ _ }", "start": [78, 1], "end": [83, 96], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.hasForgetToModule", "code": "instance hasForgetToModule : HasForget\u2082 (QuadraticModuleCat R) (ModuleCat R) where\n  forget\u2082 :=\n    { obj := fun M => ModuleCat.of R M\n      map := fun f => f.toIsometry.toLinearMap }", "start": [85, 1], "end": [88, 49], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.forget\u2082_obj", "code": "@[simp]\ntheorem forget\u2082_obj (X : QuadraticModuleCat R) :\n    (forget\u2082 (QuadraticModuleCat R) (ModuleCat R)).obj X = ModuleCat.of R X", "start": [90, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.forget\u2082_map", "code": "@[simp]\ntheorem forget\u2082_map (X Y : QuadraticModuleCat R) (f : X \u27f6 Y) :\n    (forget\u2082 (QuadraticModuleCat R) (ModuleCat R)).map f = f.toIsometry.toLinearMap", "start": [95, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.ofIso", "code": "@[simps]\ndef ofIso (e : Q\u2081.IsometryEquiv Q\u2082) : QuadraticModuleCat.of Q\u2081 \u2245 QuadraticModuleCat.of Q\u2082 where\n  hom := \u27e8e.toIsometry\u27e9\n  inv := \u27e8e.symm.toIsometry\u27e9\n  hom_inv_id := Hom.ext _ _ <| FunLike.ext _ _ e.left_inv\n  inv_hom_id := Hom.ext _ _ <| FunLike.ext _ _ e.right_inv", "start": [104, 1], "end": [111, 59], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.ofIso_refl", "code": "@[simp] theorem ofIso_refl : ofIso (IsometryEquiv.refl Q\u2081) = .refl _", "start": [113, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.ofIso_symm", "code": "@[simp] theorem ofIso_symm (e : Q\u2081.IsometryEquiv Q\u2082) : ofIso e.symm = (ofIso e).symm", "start": [116, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.ofIso_trans", "code": "@[simp] theorem ofIso_trans (e : Q\u2081.IsometryEquiv Q\u2082) (f : Q\u2082.IsometryEquiv Q\u2083) :\n    ofIso (e.trans f) = ofIso e \u226a\u226b ofIso f", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toIsometryEquiv", "code": "@[simps]\ndef toIsometryEquiv (i : X \u2245 Y) : X.form.IsometryEquiv Y.form where\n  toFun := i.hom.toIsometry\n  invFun := i.inv.toIsometry\n  left_inv x := by\n    change (i.hom \u226b i.inv).toIsometry x = x\n    simp\n  right_inv x := by\n    change (i.inv \u226b i.hom).toIsometry x = x\n    simp\n  map_add' := map_add _\n  map_smul' := map_smul _\n  map_app' := Isometry.map_app _", "start": [131, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toIsometryEquiv_refl", "code": "@[simp] theorem toIsometryEquiv_refl : toIsometryEquiv (.refl X) = .refl _", "start": [147, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toIsometryEquiv_symm", "code": "@[simp] theorem toIsometryEquiv_symm (e : X \u2245 Y) :\n    toIsometryEquiv e.symm = (toIsometryEquiv e).symm", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.toIsometryEquiv_trans", "code": "@[simp] theorem toIsometryEquiv_trans (e : X \u2245 Y) (f : Y \u2245 Z) :\n    toIsometryEquiv (e \u226a\u226b f) = e.toIsometryEquiv.trans f.toIsometryEquiv", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/TensorProduct/Isometries.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "Mathlib/LinearAlgebra/QuadraticForm/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticForm.tmul_comp_tensorMap", "code": "@[simp]\ntheorem tmul_comp_tensorMap\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2083 : QuadraticForm R M\u2083} {Q\u2084 : QuadraticForm R M\u2084}\n    (f : Q\u2081 \u2192q\u1d62 Q\u2082) (g : Q\u2083 \u2192q\u1d62 Q\u2084) :\n    (Q\u2082.tmul Q\u2084).comp (TensorProduct.map f.toLinearMap g.toLinearMap) = Q\u2081.tmul Q\u2083", "start": [36, 1], "end": [46, 52], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_tensorMap_apply", "code": "@[simp]\ntheorem tmul_tensorMap_apply\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2083 : QuadraticForm R M\u2083} {Q\u2084 : QuadraticForm R M\u2084}\n    (f : Q\u2081 \u2192q\u1d62 Q\u2082) (g : Q\u2083 \u2192q\u1d62 Q\u2084) (x : M\u2081 \u2297[R] M\u2083) :\n    Q\u2082.tmul Q\u2084 (TensorProduct.map f.toLinearMap g.toLinearMap x) = Q\u2081.tmul Q\u2083 x", "start": [48, 1], "end": [54, 48], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Isometry.tmul", "code": "def tmul\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2083 : QuadraticForm R M\u2083} {Q\u2084 : QuadraticForm R M\u2084}\n    (f : Q\u2081 \u2192q\u1d62 Q\u2082) (g : Q\u2083 \u2192q\u1d62 Q\u2084) : (Q\u2081.tmul Q\u2083) \u2192q\u1d62 (Q\u2082.tmul Q\u2084) where\n  toLinearMap := TensorProduct.map f.toLinearMap g.toLinearMap\n  map_app' := tmul_tensorMap_apply f g", "start": [58, 1], "end": [64, 39], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Isometry.tmul_apply", "code": "@[simp]\ntheorem tmul_apply\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2083 : QuadraticForm R M\u2083} {Q\u2084 : QuadraticForm R M\u2084}\n    (f : Q\u2081 \u2192q\u1d62 Q\u2082) (g : Q\u2083 \u2192q\u1d62 Q\u2084) (x : M\u2081 \u2297[R] M\u2083) :\n    f.tmul g x = TensorProduct.map f.toLinearMap g.toLinearMap x", "start": [66, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_comp_tensorComm", "code": "@[simp]\ntheorem tmul_comp_tensorComm (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    (Q\u2082.tmul Q\u2081).comp (TensorProduct.comm R M\u2081 M\u2082) = Q\u2081.tmul Q\u2082", "start": [78, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_tensorComm_apply", "code": "@[simp]\ntheorem tmul_tensorComm_apply\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (x : M\u2081 \u2297[R] M\u2082) :\n    Q\u2082.tmul Q\u2081 (TensorProduct.comm R M\u2081 M\u2082 x) = Q\u2081.tmul Q\u2082 x", "start": [88, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorComm", "code": "@[simps toLinearEquiv]\ndef tensorComm (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    (Q\u2081.tmul Q\u2082).IsometryEquiv (Q\u2082.tmul Q\u2081) where\n  toLinearEquiv := TensorProduct.comm R M\u2081 M\u2082\n  map_app' := tmul_tensorComm_apply Q\u2081 Q\u2082", "start": [94, 1], "end": [99, 42], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorComm_apply", "code": "@[simp] lemma tensorComm_apply (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082)\n    (x : M\u2081 \u2297[R] M\u2082) :\n    tensorComm Q\u2081 Q\u2082 x = TensorProduct.comm R M\u2081 M\u2082 x :=\n  rfl", "start": [101, 1], "end": [104, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.tensorComm_symm", "code": "@[simp] lemma tensorComm_symm (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    (tensorComm Q\u2081 Q\u2082).symm = tensorComm Q\u2082 Q\u2081 :=\n  rfl", "start": [106, 1], "end": [108, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.tmul_comp_tensorAssoc", "code": "@[simp]\ntheorem tmul_comp_tensorAssoc\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2083 : QuadraticForm R M\u2083) :\n    (Q\u2081.tmul (Q\u2082.tmul Q\u2083)).comp (TensorProduct.assoc R M\u2081 M\u2082 M\u2083) = (Q\u2081.tmul Q\u2082).tmul Q\u2083", "start": [114, 1], "end": [123, 24], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_tensorAssoc_apply", "code": "@[simp]\ntheorem tmul_tensorAssoc_apply\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2083 : QuadraticForm R M\u2083)\n    (x : (M\u2081 \u2297[R] M\u2082) \u2297[R] M\u2083):\n    Q\u2081.tmul (Q\u2082.tmul Q\u2083) (TensorProduct.assoc R M\u2081 M\u2082 M\u2083 x) = (Q\u2081.tmul Q\u2082).tmul Q\u2083 x", "start": [125, 1], "end": [130, 55], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorAssoc", "code": "@[simps toLinearEquiv]\ndef tensorAssoc (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2083 : QuadraticForm R M\u2083) :\n    ((Q\u2081.tmul Q\u2082).tmul Q\u2083).IsometryEquiv (Q\u2081.tmul (Q\u2082.tmul Q\u2083)) where\n  toLinearEquiv := TensorProduct.assoc R M\u2081 M\u2082 M\u2083\n  map_app' := tmul_tensorAssoc_apply Q\u2081 Q\u2082 Q\u2083", "start": [132, 1], "end": [137, 46], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorAssoc_apply", "code": "@[simp] lemma tensorAssoc_apply\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2083 : QuadraticForm R M\u2083)\n    (x : (M\u2081 \u2297[R] M\u2082) \u2297[R] M\u2083) :\n    tensorAssoc Q\u2081 Q\u2082 Q\u2083 x = TensorProduct.assoc R M\u2081 M\u2082 M\u2083 x :=\n  rfl", "start": [139, 1], "end": [143, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.tensorAssoc_symm_apply", "code": "@[simp] lemma tensorAssoc_symm_apply\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (Q\u2083 : QuadraticForm R M\u2083)\n    (x : M\u2081 \u2297[R] (M\u2082 \u2297[R] M\u2083)) :\n    (tensorAssoc Q\u2081 Q\u2082 Q\u2083).symm x = (TensorProduct.assoc R M\u2081 M\u2082 M\u2083).symm x :=\n  rfl", "start": [145, 1], "end": [149, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.comp_tensorRId_eq", "code": "theorem comp_tensorRId_eq (Q\u2081 : QuadraticForm R M\u2081) :\n    Q\u2081.comp (TensorProduct.rid R M\u2081) = Q\u2081.tmul (sq (R := R))", "start": [155, 1], "end": [162, 36], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_tensorRId_apply", "code": "@[simp]\ntheorem tmul_tensorRId_apply\n    (Q\u2081 : QuadraticForm R M\u2081) (x : M\u2081 \u2297[R] R) :\n    Q\u2081 (TensorProduct.rid R M\u2081 x) = Q\u2081.tmul (sq (R := R)) x", "start": [164, 1], "end": [168, 45], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorRId", "code": "@[simps toLinearEquiv]\ndef tensorRId (Q\u2081 : QuadraticForm R M\u2081):\n    (Q\u2081.tmul (sq (R := R))).IsometryEquiv Q\u2081 where\n  toLinearEquiv := TensorProduct.rid R M\u2081\n  map_app' := tmul_tensorRId_apply Q\u2081", "start": [170, 1], "end": [175, 38], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorRId_apply", "code": "@[simp] lemma tensorRId_apply (Q\u2081 : QuadraticForm R M\u2081) (x : M\u2081 \u2297[R] R) :\n    tensorRId Q\u2081 x = TensorProduct.rid R M\u2081 x :=\n  rfl", "start": [177, 1], "end": [179, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.tensorRId_symm_apply", "code": "@[simp] lemma tensorRId_symm_apply (Q\u2081 : QuadraticForm R M\u2081) (x : M\u2081) :\n    (tensorRId Q\u2081).symm x = (TensorProduct.rid R M\u2081).symm x :=\n  rfl", "start": [181, 1], "end": [183, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.comp_tensorLId_eq", "code": "theorem comp_tensorLId_eq (Q\u2082 : QuadraticForm R M\u2082) :\n    Q\u2082.comp (TensorProduct.lid R M\u2082) = (sq (R := R)).tmul Q\u2082", "start": [189, 1], "end": [196, 36], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tmul_tensorLId_apply", "code": "@[simp]\ntheorem tmul_tensorLId_apply\n    (Q\u2082 : QuadraticForm R M\u2082) (x : R \u2297[R] M\u2082) :\n    Q\u2082 (TensorProduct.lid R M\u2082 x) = (sq (R := R)).tmul Q\u2082 x", "start": [198, 1], "end": [202, 45], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorLId", "code": "@[simps toLinearEquiv]\ndef tensorLId (Q\u2082 : QuadraticForm R M\u2082):\n    ((sq (R := R)).tmul Q\u2082).IsometryEquiv Q\u2082 where\n  toLinearEquiv := TensorProduct.lid R M\u2082\n  map_app' := tmul_tensorLId_apply Q\u2082", "start": [204, 1], "end": [209, 38], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.tensorLId_apply", "code": "@[simp] lemma tensorLId_apply (Q\u2082 : QuadraticForm R M\u2082) (x : R \u2297[R] M\u2082) :\n    tensorLId Q\u2082 x = TensorProduct.lid R M\u2082 x :=\n  rfl", "start": [211, 1], "end": [213, 6], "kind": "mathlibtacticlemma"}, {"full_name": "QuadraticForm.tensorLId_symm_apply", "code": "@[simp] lemma tensorLId_symm_apply (Q\u2082 : QuadraticForm R M\u2082) (x : M\u2082) :\n    (tensorLId Q\u2082).symm x = (TensorProduct.lid R M\u2082).symm x :=\n  rfl", "start": [215, 1], "end": [217, 6], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.nonMemberSubfamily", "code": "def nonMemberSubfamily (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) : Finset (Finset \u03b1) :=\n  \ud835\udc9c.filter fun s => a \u2209 s", "start": [44, 1], "end": [46, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily", "code": "def memberSubfamily (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) : Finset (Finset \u03b1) :=\n  (\ud835\udc9c.filter fun s => a \u2208 s).image fun s => erase s a", "start": [49, 1], "end": [52, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_nonMemberSubfamily", "code": "@[simp]\ntheorem mem_nonMemberSubfamily : s \u2208 \ud835\udc9c.nonMemberSubfamily a \u2194 s \u2208 \ud835\udc9c \u2227 a \u2209 s", "start": [55, 1], "end": [57, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_memberSubfamily", "code": "@[simp]\ntheorem mem_memberSubfamily : s \u2208 \ud835\udc9c.memberSubfamily a \u2194 insert a s \u2208 \ud835\udc9c \u2227 a \u2209 s", "start": [60, 1], "end": [66, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.nonMemberSubfamily_inter", "code": "theorem nonMemberSubfamily_inter (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c \u2229 \u212c).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a \u2229 \u212c.nonMemberSubfamily a", "start": [69, 1], "end": [71, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_inter", "code": "theorem memberSubfamily_inter (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c \u2229 \u212c).memberSubfamily a = \ud835\udc9c.memberSubfamily a \u2229 \u212c.memberSubfamily a", "start": [74, 1], "end": [78, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.nonMemberSubfamily_union", "code": "theorem nonMemberSubfamily_union (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c \u222a \u212c).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a \u222a \u212c.nonMemberSubfamily a", "start": [81, 1], "end": [83, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_union", "code": "theorem memberSubfamily_union (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c \u222a \u212c).memberSubfamily a = \ud835\udc9c.memberSubfamily a \u222a \u212c.memberSubfamily a", "start": [86, 1], "end": [88, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_memberSubfamily_add_card_nonMemberSubfamily", "code": "theorem card_memberSubfamily_add_card_nonMemberSubfamily (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) :\n    (\ud835\udc9c.memberSubfamily a).card + (\ud835\udc9c.nonMemberSubfamily a).card = \ud835\udc9c.card", "start": [91, 1], "end": [96, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_union_nonMemberSubfamily", "code": "theorem memberSubfamily_union_nonMemberSubfamily (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) :\n    \ud835\udc9c.memberSubfamily a \u222a \ud835\udc9c.nonMemberSubfamily a = \ud835\udc9c.image fun s => s.erase a", "start": [99, 1], "end": [110, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_memberSubfamily", "code": "@[simp]\ntheorem memberSubfamily_memberSubfamily : (\ud835\udc9c.memberSubfamily a).memberSubfamily a = \u2205", "start": [113, 1], "end": [116, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_nonMemberSubfamily", "code": "@[simp]\ntheorem memberSubfamily_nonMemberSubfamily : (\ud835\udc9c.nonMemberSubfamily a).memberSubfamily a = \u2205", "start": [119, 1], "end": [122, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.nonMemberSubfamily_memberSubfamily", "code": "@[simp]\ntheorem nonMemberSubfamily_memberSubfamily :\n    (\ud835\udc9c.memberSubfamily a).nonMemberSubfamily a = \ud835\udc9c.memberSubfamily a", "start": [125, 1], "end": [129, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.nonMemberSubfamily_nonMemberSubfamily", "code": "@[simp]\ntheorem nonMemberSubfamily_nonMemberSubfamily :\n    (\ud835\udc9c.nonMemberSubfamily a).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a", "start": [132, 1], "end": [136, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.memberSubfamily_image_insert", "code": "lemma memberSubfamily_image_insert (h\ud835\udc9c : \u2200 s \u2208 \ud835\udc9c, a \u2209 s) :\n    (\ud835\udc9c.image <| insert a).memberSubfamily a = \ud835\udc9c := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image]\n  refine \u27e8?_, fun hs \u21a6 \u27e8\u27e8s, hs, rfl\u27e9, h\ud835\udc9c _ hs\u27e9\u27e9\n  rintro \u27e8\u27e8t, ht, hts\u27e9, hs\u27e9\n  rwa [\u2190insert_erase_invOn.2.injOn (h\ud835\udc9c _ ht) hs hts]", "start": [139, 1], "end": [145, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.nonMemberSubfamily_image_insert", "code": "@[simp] lemma nonMemberSubfamily_image_insert : (\ud835\udc9c.image <| insert a).nonMemberSubfamily a = \u2205 := by\n  simp [eq_empty_iff_forall_not_mem]", "start": [147, 1], "end": [148, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.memberSubfamily_image_erase", "code": "@[simp] lemma memberSubfamily_image_erase : (\ud835\udc9c.image (erase \u00b7 a)).memberSubfamily a = \u2205 := by\n  simp [eq_empty_iff_forall_not_mem,\n    (ne_of_mem_of_not_mem' (mem_insert_self _ _) (not_mem_erase _ _)).symm]", "start": [150, 1], "end": [152, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.image_insert_memberSubfamily", "code": "lemma image_insert_memberSubfamily (\ud835\udc9c : Finset (Finset \u03b1)) (a : \u03b1) :\n    (\ud835\udc9c.memberSubfamily a).image (insert a) = \ud835\udc9c.filter (a \u2208 \u00b7) := by\n  ext s\n  simp only [mem_memberSubfamily, mem_image, mem_filter]\n  refine \u27e8?_, fun \u27e8hs, ha\u27e9 \u21a6 \u27e8erase s a, \u27e8?_, not_mem_erase _ _\u27e9, insert_erase ha\u27e9\u27e9\n  \u00b7 rintro \u27e8s, \u27e8hs, -\u27e9, rfl\u27e9\n    exact \u27e8hs, mem_insert_self _ _\u27e9\n  \u00b7 rwa [insert_erase ha]", "start": [154, 1], "end": [161, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.memberFamily_induction_on", "code": "@[elab_as_elim]\nlemma memberFamily_induction_on {p : Finset (Finset \u03b1) \u2192 Prop}\n    (\ud835\udc9c : Finset (Finset \u03b1)) (empty : p \u2205) (singleton_empty : p {\u2205})\n    (subfamily : \u2200 (a : \u03b1) \u2983\ud835\udc9c : Finset (Finset \u03b1)\u2984,\n      p (\ud835\udc9c.nonMemberSubfamily a) \u2192 p (\ud835\udc9c.memberSubfamily a) \u2192 p \ud835\udc9c) : p \ud835\udc9c := by\n  set u := \ud835\udc9c.sup id\n  have hu : \u2200 s \u2208 \ud835\udc9c, s \u2286 u := fun s \u21a6 le_sup (f := id)\n  clear_value u\n  induction' u using Finset.induction with a u _ ih generalizing \ud835\udc9c\n  \u00b7 simp_rw [subset_empty] at hu\n    rw [\u2190subset_singleton_iff', subset_singleton_iff] at hu\n    obtain rfl | rfl := hu <;> assumption\n  refine subfamily a (ih _ ?_) (ih _ ?_)\n  \u00b7 simp only [mem_nonMemberSubfamily, and_imp]\n    exact fun s hs has \u21a6 (subset_insert_iff_of_not_mem has).1 <| hu _ hs\n  \u00b7 simp only [mem_memberSubfamily, and_imp]\n    exact fun s hs ha \u21a6 (insert_subset_insert_iff ha).1 <| hu _ hs", "start": [163, 1], "end": [191, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.family_induction_on", "code": "@[elab_as_elim]\nprotected lemma family_induction_on {p : Finset (Finset \u03b1) \u2192 Prop}\n    (\ud835\udc9c : Finset (Finset \u03b1)) (empty : p \u2205) (singleton_empty : p {\u2205})\n    (image_insert : \u2200 (a : \u03b1) \u2983\ud835\udc9c : Finset (Finset \u03b1)\u2984,\n      (\u2200 s \u2208 \ud835\udc9c, a \u2209 s) \u2192 p \ud835\udc9c \u2192 p (\ud835\udc9c.image <| insert a))\n    (subfamily : \u2200 (a : \u03b1) \u2983\ud835\udc9c : Finset (Finset \u03b1)\u2984,\n      p (\ud835\udc9c.filter (a \u2209 \u00b7)) \u2192 p (\ud835\udc9c.filter (a \u2208 \u00b7)) \u2192 p \ud835\udc9c) : p \ud835\udc9c := by\n  refine memberFamily_induction_on \ud835\udc9c empty singleton_empty fun a \ud835\udc9c h\ud835\udc9c\u2080 h\ud835\udc9c\u2081 \u21a6 subfamily a h\ud835\udc9c\u2080 ?_\n  rw [\u2190image_insert_memberSubfamily]\n  exact image_insert _ (by simp) h\ud835\udc9c\u2081", "start": [193, 1], "end": [215, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Down.compression", "code": "def compression (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) : Finset (Finset \u03b1) :=\n  (\ud835\udc9c.filter fun s => erase s a \u2208 \ud835\udc9c).disjUnion\n      ((\ud835\udc9c.image fun s => erase s a).filter fun s => s \u2209 \ud835\udc9c) <|\n    disjoint_left.2 fun s h\u2081 h\u2082 => by\n      have := (mem_filter.1 h\u2082).2\n      exact this (mem_filter.1 h\u2081).1", "start": [224, 1], "end": [231, 37], "kind": "commanddeclaration"}, {"full_name": "Down.mem_compression", "code": "theorem mem_compression : s \u2208 \ud835\udcd3 a \ud835\udc9c \u2194 s \u2208 \ud835\udc9c \u2227 s.erase a \u2208 \ud835\udc9c \u2228 s \u2209 \ud835\udc9c \u2227 insert a s \u2208 \ud835\udc9c", "start": [240, 1], "end": [249, 73], "kind": "commanddeclaration"}, {"full_name": "Down.erase_mem_compression", "code": "theorem erase_mem_compression (hs : s \u2208 \ud835\udc9c) : s.erase a \u2208 \ud835\udcd3 a \ud835\udc9c", "start": [252, 1], "end": [255, 72], "kind": "commanddeclaration"}, {"full_name": "Down.erase_mem_compression_of_mem_compression", "code": "theorem erase_mem_compression_of_mem_compression : s \u2208 \ud835\udcd3 a \ud835\udc9c \u2192 s.erase a \u2208 \ud835\udcd3 a \ud835\udc9c", "start": [259, 1], "end": [262, 79], "kind": "commanddeclaration"}, {"full_name": "Down.mem_compression_of_insert_mem_compression", "code": "theorem mem_compression_of_insert_mem_compression (h : insert a s \u2208 \ud835\udcd3 a \ud835\udc9c) : s \u2208 \ud835\udcd3 a \ud835\udc9c", "start": [265, 1], "end": [269, 53], "kind": "commanddeclaration"}, {"full_name": "Down.compression_idem", "code": "@[simp]\ntheorem compression_idem (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) : \ud835\udcd3 a (\ud835\udcd3 a \ud835\udc9c) = \ud835\udcd3 a \ud835\udc9c", "start": [272, 1], "end": [279, 62], "kind": "commanddeclaration"}, {"full_name": "Down.card_compression", "code": "@[simp]\ntheorem card_compression (a : \u03b1) (\ud835\udc9c : Finset (Finset \u03b1)) : (\ud835\udcd3 a \ud835\udc9c).card = \ud835\udc9c.card", "start": [282, 1], "end": [291, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/SMap.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Data/SMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SMap.foldM", "code": "def Lean.SMap.foldM {m : Type w \u2192 Type w} [Monad m] [BEq \u03b1] [Hashable \u03b1]\n    (f : \u03c3 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03c3) (init : \u03c3) (map : SMap \u03b1 \u03b2) : m \u03c3 := do\n  map.map\u2082.foldlM f (\u2190 map.map\u2081.foldM f init)", "start": [14, 1], "end": [17, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/SemidirectProduct.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Logic/Function/Basic.lean", "Mathlib/Algebra/Hom/Aut.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemidirectProduct", "code": "@[ext]\nstructure SemidirectProduct (\u03c6 : G \u2192* MulAut N) where\n  \n  left : N\n  \n  right : G\n  deriving DecidableEq", "start": [38, 1], "end": [47, 23], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.mul_def", "code": "lemma mul_def (a b : SemidirectProduct N G \u03c6) : a * b = \u27e8a.1 * \u03c6 a.2 b.1, a.2 * b.2\u27e9 := rfl", "start": [69, 1], "end": [69, 92], "kind": "mathlibtacticlemma"}, {"full_name": "SemidirectProduct.mul_left", "code": "@[simp]\ntheorem mul_left (a b : N \u22ca[\u03c6] G) : (a * b).left = a.left * \u03c6 a.right b.left", "start": [71, 1], "end": [72, 84], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.mul_right", "code": "@[simp]\ntheorem mul_right (a b : N \u22ca[\u03c6] G) : (a * b).right = a.right * b.right", "start": [75, 1], "end": [76, 78], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.one_left", "code": "@[simp]\ntheorem one_left : (1 : N \u22ca[\u03c6] G).left = 1", "start": [81, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.one_right", "code": "@[simp]\ntheorem one_right : (1 : N \u22ca[\u03c6] G).right = 1", "start": [85, 1], "end": [86, 52], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inv_left", "code": "@[simp]\ntheorem inv_left (a : N \u22ca[\u03c6] G) : a\u207b\u00b9.left = \u03c6 a.right\u207b\u00b9 a.left\u207b\u00b9", "start": [92, 1], "end": [93, 73], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inv_right", "code": "@[simp]\ntheorem inv_right (a : N \u22ca[\u03c6] G) : a\u207b\u00b9.right = a.right\u207b\u00b9", "start": [96, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl", "code": "def inl : N \u2192* N \u22ca[\u03c6] G where\n  toFun n := \u27e8n, 1\u27e9\n  map_one' := rfl\n  map_mul' := by intros; ext <;>\n    simp only [mul_left, map_one, MulAut.one_apply, mul_right, mul_one]", "start": [108, 1], "end": [113, 72], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.left_inl", "code": "@[simp]\ntheorem left_inl (n : N) : (inl n : N \u22ca[\u03c6] G).left = n", "start": [116, 1], "end": [117, 62], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.right_inl", "code": "@[simp]\ntheorem right_inl (n : N) : (inl n : N \u22ca[\u03c6] G).right = 1", "start": [120, 1], "end": [121, 64], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl_injective", "code": "theorem inl_injective : Function.Injective (inl : N \u2192 N \u22ca[\u03c6] G)", "start": [124, 1], "end": [125, 59], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl_inj", "code": "@[simp]\ntheorem inl_inj {n\u2081 n\u2082 : N} : (inl n\u2081 : N \u22ca[\u03c6] G) = inl n\u2082 \u2194 n\u2081 = n\u2082", "start": [128, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inr", "code": "def inr : G \u2192* N \u22ca[\u03c6] G where\n  toFun g := \u27e81, g\u27e9\n  map_one' := rfl\n  map_mul' := by intros; ext <;> simp", "start": [133, 1], "end": [137, 38], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.left_inr", "code": "@[simp]\ntheorem left_inr (g : G) : (inr g : N \u22ca[\u03c6] G).left = 1", "start": [140, 1], "end": [141, 62], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.right_inr", "code": "@[simp]\ntheorem right_inr (g : G) : (inr g : N \u22ca[\u03c6] G).right = g", "start": [144, 1], "end": [145, 64], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inr_injective", "code": "theorem inr_injective : Function.Injective (inr : G \u2192 N \u22ca[\u03c6] G)", "start": [148, 1], "end": [149, 61], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inr_inj", "code": "@[simp]\ntheorem inr_inj {g\u2081 g\u2082 : G} : (inr g\u2081 : N \u22ca[\u03c6] G) = inr g\u2082 \u2194 g\u2081 = g\u2082", "start": [152, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl_aut", "code": "theorem inl_aut (g : G) (n : N) : (inl (\u03c6 g n) : N \u22ca[\u03c6] G) = inr g * inl n * inr g\u207b\u00b9", "start": [157, 1], "end": [158, 15], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl_aut_inv", "code": "theorem inl_aut_inv (g : G) (n : N) : (inl ((\u03c6 g)\u207b\u00b9 n) : N \u22ca[\u03c6] G) = inr g\u207b\u00b9 * inl n * inr g", "start": [161, 1], "end": [162, 45], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.mk_eq_inl_mul_inr", "code": "@[simp]\ntheorem mk_eq_inl_mul_inr (g : G) (n : N) : (\u27e8n, g\u27e9 : N \u22ca[\u03c6] G) = inl n * inr g", "start": [165, 1], "end": [166, 99], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.inl_left_mul_inr_right", "code": "@[simp]\ntheorem inl_left_mul_inr_right (x : N \u22ca[\u03c6] G) : inl x.left * inr x.right = x", "start": [169, 1], "end": [170, 96], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom", "code": "def rightHom : N \u22ca[\u03c6] G \u2192* G where\n  toFun := SemidirectProduct.right\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [173, 1], "end": [177, 22], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_eq_right", "code": "@[simp]\ntheorem rightHom_eq_right : (rightHom : N \u22ca[\u03c6] G \u2192 G) = right", "start": [180, 1], "end": [181, 69], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_comp_inl", "code": "@[simp]\ntheorem rightHom_comp_inl : (rightHom : N \u22ca[\u03c6] G \u2192* G).comp inl = 1", "start": [184, 1], "end": [185, 95], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_comp_inr", "code": "@[simp]\ntheorem rightHom_comp_inr : (rightHom : N \u22ca[\u03c6] G \u2192* G).comp inr = MonoidHom.id _", "start": [188, 1], "end": [190, 23], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_inl", "code": "@[simp]\ntheorem rightHom_inl (n : N) : rightHom (inl n : N \u22ca[\u03c6] G) = 1", "start": [193, 1], "end": [194, 85], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_inr", "code": "@[simp]\ntheorem rightHom_inr (g : G) : rightHom (inr g : N \u22ca[\u03c6] G) = g", "start": [197, 1], "end": [198, 85], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_surjective", "code": "theorem rightHom_surjective : Function.Surjective (rightHom : N \u22ca[\u03c6] G \u2192 G)", "start": [201, 1], "end": [202, 64], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.range_inl_eq_ker_rightHom", "code": "theorem range_inl_eq_ker_rightHom : (inl : N \u2192* N \u22ca[\u03c6] G).range = rightHom.ker", "start": [205, 1], "end": [207, 65], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift", "code": "def lift (f\u2081 : N \u2192* H) (f\u2082 : G \u2192* H)\n    (h : \u2200 g, f\u2081.comp (\u03c6 g).toMonoidHom = (MulAut.conj (f\u2082 g)).toMonoidHom.comp f\u2081) : N \u22ca[\u03c6] G \u2192* H\n    where\n  toFun a := f\u2081 a.1 * f\u2082 a.2\n  map_one' := by simp\n  map_mul' a b := by\n    have := fun n g \u21a6 FunLike.ext_iff.1 (h n) g\n    simp only [MulAut.conj_apply, MonoidHom.comp_apply, MulEquiv.coe_toMonoidHom] at this\n    simp only [mul_left, mul_right, map_mul, this, mul_assoc, inv_mul_cancel_left]", "start": [215, 1], "end": [224, 83], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift_inl", "code": "@[simp]\ntheorem lift_inl (n : N) : lift f\u2081 f\u2082 h (inl n) = f\u2081 n", "start": [227, 1], "end": [228, 73], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift_comp_inl", "code": "@[simp]\ntheorem lift_comp_inl : (lift f\u2081 f\u2082 h).comp inl = f\u2081", "start": [231, 1], "end": [232, 69], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift_inr", "code": "@[simp]\ntheorem lift_inr (g : G) : lift f\u2081 f\u2082 h (inr g) = f\u2082 g", "start": [235, 1], "end": [236, 73], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift_comp_inr", "code": "@[simp]\ntheorem lift_comp_inr : (lift f\u2081 f\u2082 h).comp inr = f\u2082", "start": [239, 1], "end": [240, 69], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.lift_unique", "code": "theorem lift_unique (F : N \u22ca[\u03c6] G \u2192* H) :\n    F = lift (F.comp inl) (F.comp inr) fun _ \u21a6 by ext; simp [inl_aut]", "start": [243, 1], "end": [247, 42], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.hom_ext", "code": "theorem hom_ext {f g : N \u22ca[\u03c6] G \u2192* H} (hl : f.comp inl = g.comp inl)\n    (hr : f.comp inr = g.comp inr) : f = g", "start": [250, 1], "end": [255, 16], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map", "code": "def map (f\u2081 : N \u2192* N\u2081) (f\u2082 : G \u2192* G\u2081)\n    (h : \u2200 g : G, f\u2081.comp (\u03c6 g).toMonoidHom = (\u03c6\u2081 (f\u2082 g)).toMonoidHom.comp f\u2081) :\n    N \u22ca[\u03c6] G \u2192* N\u2081 \u22ca[\u03c6\u2081] G\u2081 where\n  toFun x := \u27e8f\u2081 x.1, f\u2082 x.2\u27e9\n  map_one' := by simp\n  map_mul' x y := by\n    replace h := FunLike.ext_iff.1 (h x.right) y.left\n    ext <;> simp_all", "start": [264, 1], "end": [273, 21], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_left", "code": "@[simp]\ntheorem map_left (g : N \u22ca[\u03c6] G) : (map f\u2081 f\u2082 h g).left = f\u2081 g.left", "start": [279, 1], "end": [280, 74], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_right", "code": "@[simp]\ntheorem map_right (g : N \u22ca[\u03c6] G) : (map f\u2081 f\u2082 h g).right = f\u2082 g.right", "start": [283, 1], "end": [284, 77], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.rightHom_comp_map", "code": "@[simp]\ntheorem rightHom_comp_map : rightHom.comp (map f\u2081 f\u2082 h) = f\u2082.comp rightHom", "start": [287, 1], "end": [288, 82], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_inl", "code": "@[simp]\ntheorem map_inl (n : N) : map f\u2081 f\u2082 h (inl n) = inl (f\u2081 n)", "start": [291, 1], "end": [292, 76], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_comp_inl", "code": "@[simp]\ntheorem map_comp_inl : (map f\u2081 f\u2082 h).comp inl = inl.comp f\u2081", "start": [295, 1], "end": [296, 79], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_inr", "code": "@[simp]\ntheorem map_inr (g : G) : map f\u2081 f\u2082 h (inr g) = inr (f\u2082 g)", "start": [299, 1], "end": [300, 76], "kind": "commanddeclaration"}, {"full_name": "SemidirectProduct.map_comp_inr", "code": "@[simp]\ntheorem map_comp_inr : (map f\u2081 f\u2082 h).comp inr = inr.comp f\u2082", "start": [303, 1], "end": [304, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PFunctor/Multivariate/Basic.lean", "imports": ["Mathlib/Control/Functor/Multivariate.lean", "Mathlib/Data/PFunctor/Univariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPFunctor", "code": "@[pp_with_univ]\nstructure MvPFunctor (n : \u2115) where\n  \n  A : Type u\n  \n  B : A \u2192 TypeVec.{u} n", "start": [25, 1], "end": [32, 24], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.Obj", "code": "@[coe]\ndef Obj (\u03b1 : TypeVec.{u} n) : Type u :=\n  \u03a3 a : P.A, P.B a \u27f9 \u03b1", "start": [41, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.map", "code": "def map {\u03b1 \u03b2 : TypeVec n} (f : \u03b1 \u27f9 \u03b2) : P \u03b1 \u2192 P \u03b2 := fun \u27e8a, g\u27e9 => \u27e8a, TypeVec.comp f g\u27e9", "start": [50, 1], "end": [51, 89], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.Obj.inhabited", "code": "instance Obj.inhabited {\u03b1 : TypeVec n} [Inhabited P.A] [\u2200 i, Inhabited (\u03b1 i)] :\n    Inhabited (P \u03b1) :=\n  \u27e8\u27e8default, fun _ _ => default\u27e9\u27e9", "start": [57, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.map_eq", "code": "theorem map_eq {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (a : P.A) (f : P.B a \u27f9 \u03b1) :\n    @MvFunctor.map _ P.Obj _ _ _ g \u27e8a, f\u27e9 = \u27e8a, g \u229a f\u27e9", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.id_map", "code": "theorem id_map {\u03b1 : TypeVec n} : \u2200 x : P \u03b1, TypeVec.id <$$> x = x", "start": [70, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp_map", "code": "theorem comp_map {\u03b1 \u03b2 \u03b3 : TypeVec n} (f : \u03b1 \u27f9 \u03b2) (g : \u03b2 \u27f9 \u03b3) :\n    \u2200 x : P \u03b1, (g \u229a f) <$$> x = g <$$> f <$$> x", "start": [74, 1], "end": [76, 18], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const", "code": "def const (n : \u2115) (A : Type u) : MvPFunctor n :=\n  { A\n    B := fun _ _ => PEmpty }", "start": [83, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const.mk", "code": "def const.mk (x : A) {\u03b1} : const n A \u03b1 :=\n  \u27e8x, fun _ a => PEmpty.elim a\u27e9", "start": [93, 1], "end": [95, 32], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const.get", "code": "def const.get (x : const n A \u03b1) : A :=\n  x.1", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const.get_map", "code": "@[simp]\ntheorem const.get_map (f : \u03b1 \u27f9 \u03b2) (x : const n A \u03b1) : const.get (f <$$> x) = const.get x", "start": [105, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const.get_mk", "code": "@[simp]\ntheorem const.get_mk (x : A) : const.get (const.mk n x : const n A \u03b1) = x", "start": [111, 1], "end": [112, 81], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.const.mk_get", "code": "@[simp]\ntheorem const.mk_get (x : const n A \u03b1) : const.mk n (const.get x) = x", "start": [115, 1], "end": [119, 19], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp", "code": "def comp (P : MvPFunctor.{u} n) (Q : Fin2 n \u2192 MvPFunctor.{u} m) : MvPFunctor m where\n  A := \u03a3 a\u2082 : P.1, \u2200 i, P.2 a\u2082 i \u2192 (Q i).1\n  B a i := \u03a3(j : _) (b : P.2 a.1 j), (Q j).2 (a.snd j b) i", "start": [124, 1], "end": [127, 59], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp.mk", "code": "def comp.mk (x : P (fun i => Q i \u03b1)) : comp P Q \u03b1 :=\n  \u27e8\u27e8x.1, fun _ a => (x.2 _ a).1\u27e9, fun i a => (x.snd a.fst a.snd.fst).snd i a.snd.snd\u27e9", "start": [132, 1], "end": [134, 86], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp.get", "code": "def comp.get (x : comp P Q \u03b1) : P (fun i => Q i \u03b1) :=\n  \u27e8x.1.1, fun i a => \u27e8x.fst.snd i a, fun (j : Fin2 m) (b : (Q i).B _ j) => x.snd j \u27e8i, \u27e8a, b\u27e9\u27e9\u27e9\u27e9", "start": [137, 1], "end": [139, 97], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp.get_map", "code": "theorem comp.get_map (f : \u03b1 \u27f9 \u03b2) (x : comp P Q \u03b1) :\n    comp.get (f <$$> x) = (fun i (x : Q i \u03b1) => f <$$> x) <$$> comp.get x", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp.get_mk", "code": "@[simp]\ntheorem comp.get_mk (x : P (fun i => Q i \u03b1)) : comp.get (comp.mk x) = x", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp.mk_get", "code": "@[simp]\ntheorem comp.mk_get (x : comp P Q \u03b1) : comp.mk (comp.get x) = x", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.liftP_iff", "code": "theorem liftP_iff {\u03b1 : TypeVec n} (p : \u2200 \u2983i\u2984, \u03b1 i \u2192 Prop) (x : P \u03b1) :\n    LiftP p x \u2194 \u2203 a f, x = \u27e8a, f\u27e9 \u2227 \u2200 i j, p (f i j)", "start": [160, 1], "end": [170, 16], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.liftP_iff'", "code": "theorem liftP_iff' {\u03b1 : TypeVec n} (p : \u2200 \u2983i\u2984, \u03b1 i \u2192 Prop) (a : P.A) (f : P.B a \u27f9 \u03b1) :\n    @LiftP.{u} _ P.Obj _ \u03b1 p \u27e8a, f\u27e9 \u2194 \u2200 i x, p (f i x)", "start": [173, 1], "end": [179, 42], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.liftR_iff", "code": "theorem liftR_iff {\u03b1 : TypeVec n} (r : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b1 i \u2192 Prop) (x y : P \u03b1) :\n    LiftR @r x y \u2194 \u2203 a f\u2080 f\u2081, x = \u27e8a, f\u2080\u27e9 \u2227 y = \u27e8a, f\u2081\u27e9 \u2227 \u2200 i j, r (f\u2080 i j) (f\u2081 i j)", "start": [182, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.supp_eq", "code": "theorem supp_eq {\u03b1 : TypeVec n} (a : P.A) (f : P.B a \u27f9 \u03b1) (i) :\n    @supp.{u} _ P.Obj _ \u03b1 (\u27e8a, f\u27e9 : P \u03b1) i = f i '' univ", "start": [206, 1], "end": [217, 10], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.drop", "code": "def drop : MvPFunctor n where\n  A := P.A\n  B a := (P.B a).drop", "start": [231, 1], "end": [235, 22], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.last", "code": "def last : PFunctor where\n  A := P.A\n  B a := (P.B a).last", "start": [238, 1], "end": [242, 22], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.appendContents", "code": "@[reducible]\ndef appendContents {\u03b1 : TypeVec n} {\u03b2 : Type*} {a : P.A} (f' : P.drop.B a \u27f9 \u03b1)\n    (f : P.last.B a \u2192 \u03b2) : P.B a \u27f9 (\u03b1 ::: \u03b2) :=\n  splitFun f' f", "start": [246, 1], "end": [250, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Analytic/IsolatedZeros.lean", "imports": ["Mathlib/Analysis/Analytic/Basic.lean", "Mathlib/Analysis/Calculus/FormalMultilinearSeries.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Calculus/Dslope.lean", "Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "Mathlib/Analysis/Analytic/Uniqueness.lean"], "premises": [{"full_name": "HasSum.hasSum_at_zero", "code": "theorem hasSum_at_zero (a : \u2115 \u2192 E) : HasSum (fun n => (0 : \ud835\udd5c) ^ n \u2022 a n) (a 0)", "start": [47, 1], "end": [51, 11], "kind": "commanddeclaration"}, {"full_name": "HasSum.exists_hasSum_smul_of_apply_eq_zero", "code": "theorem exists_hasSum_smul_of_apply_eq_zero (hs : HasSum (fun m => z ^ m \u2022 a m) s)\n    (ha : \u2200 k < n, a k = 0) : \u2203 t : E, z ^ n \u2022 t = s \u2227 HasSum (fun m => z ^ m \u2022 a (m + n)) t", "start": [54, 1], "end": [68, 26], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.has_fpower_series_dslope_fslope", "code": "theorem has_fpower_series_dslope_fslope (hp : HasFPowerSeriesAt f p z\u2080) :\n    HasFPowerSeriesAt (dslope f z\u2080) p.fslope z\u2080", "start": [75, 1], "end": [86, 72], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.has_fpower_series_iterate_dslope_fslope", "code": "theorem has_fpower_series_iterate_dslope_fslope (n : \u2115) (hp : HasFPowerSeriesAt f p z\u2080) :\n    HasFPowerSeriesAt ((swap dslope z\u2080)^[n] f) (fslope^[n] p) z\u2080", "start": [89, 1], "end": [93, 56], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.iterate_dslope_fslope_ne_zero", "code": "theorem iterate_dslope_fslope_ne_zero (hp : HasFPowerSeriesAt f p z\u2080) (h : p \u2260 0) :\n    (swap dslope z\u2080)^[p.order] f z\u2080 \u2260 0", "start": [96, 1], "end": [99, 52], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.eq_pow_order_mul_iterate_dslope", "code": "theorem eq_pow_order_mul_iterate_dslope (hp : HasFPowerSeriesAt f p z\u2080) :\n    \u2200\u1da0 z in \ud835\udcdd z\u2080, f z = (z - z\u2080) ^ p.order \u2022 (swap dslope z\u2080)^[p.order] f z", "start": [102, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.locally_ne_zero", "code": "theorem locally_ne_zero (hp : HasFPowerSeriesAt f p z\u2080) (h : p \u2260 0) : \u2200\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z \u2260 0", "start": [114, 1], "end": [119, 68], "kind": "commanddeclaration"}, {"full_name": "HasFPowerSeriesAt.locally_zero_iff", "code": "theorem locally_zero_iff (hp : HasFPowerSeriesAt f p z\u2080) : (\u2200\u1da0 z in \ud835\udcdd z\u2080, f z = 0) \u2194 p = 0", "start": [122, 1], "end": [123, 90], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.eventually_eq_zero_or_eventually_ne_zero", "code": "theorem eventually_eq_zero_or_eventually_ne_zero (hf : AnalyticAt \ud835\udd5c f z\u2080) :\n    (\u2200\u1da0 z in \ud835\udcdd z\u2080, f z = 0) \u2228 \u2200\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z \u2260 0", "start": [130, 1], "end": [138, 40], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.eventually_eq_or_eventually_ne", "code": "theorem eventually_eq_or_eventually_ne (hf : AnalyticAt \ud835\udd5c f z\u2080) (hg : AnalyticAt \ud835\udd5c g z\u2080) :\n    (\u2200\u1da0 z in \ud835\udcdd z\u2080, f z = g z) \u2228 \u2200\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z \u2260 g z", "start": [141, 1], "end": [143, 81], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.frequently_zero_iff_eventually_zero", "code": "theorem frequently_zero_iff_eventually_zero {f : \ud835\udd5c \u2192 E} {w : \ud835\udd5c} (hf : AnalyticAt \ud835\udd5c f w) :\n    (\u2203\u1da0 z in \ud835\udcdd[\u2260] w, f z = 0) \u2194 \u2200\u1da0 z in \ud835\udcdd w, f z = 0", "start": [146, 1], "end": [149, 51], "kind": "commanddeclaration"}, {"full_name": "AnalyticAt.frequently_eq_iff_eventually_eq", "code": "theorem frequently_eq_iff_eventually_eq (hf : AnalyticAt \ud835\udd5c f z\u2080) (hg : AnalyticAt \ud835\udd5c g z\u2080) :\n    (\u2203\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z = g z) \u2194 \u2200\u1da0 z in \ud835\udcdd z\u2080, f z = g z", "start": [152, 1], "end": [154, 76], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.eqOn_zero_of_preconnected_of_frequently_eq_zero", "code": "theorem eqOn_zero_of_preconnected_of_frequently_eq_zero (hf : AnalyticOn \ud835\udd5c f U)\n    (hU : IsPreconnected U) (h\u2080 : z\u2080 \u2208 U) (hfw : \u2203\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z = 0) : EqOn f 0 U", "start": [163, 1], "end": [171, 59], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.eqOn_zero_of_preconnected_of_mem_closure", "code": "theorem eqOn_zero_of_preconnected_of_mem_closure (hf : AnalyticOn \ud835\udd5c f U) (hU : IsPreconnected U)\n    (h\u2080 : z\u2080 \u2208 U) (hfz\u2080 : z\u2080 \u2208 closure ({z | f z = 0} \\ {z\u2080})) : EqOn f 0 U", "start": [174, 1], "end": [177, 51], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.eqOn_of_preconnected_of_frequently_eq", "code": "theorem eqOn_of_preconnected_of_frequently_eq (hf : AnalyticOn \ud835\udd5c f U) (hg : AnalyticOn \ud835\udd5c g U)\n    (hU : IsPreconnected U) (h\u2080 : z\u2080 \u2208 U) (hfg : \u2203\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z = g z) : EqOn f g U", "start": [180, 1], "end": [190, 78], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.eqOn_of_preconnected_of_mem_closure", "code": "theorem eqOn_of_preconnected_of_mem_closure (hf : AnalyticOn \ud835\udd5c f U) (hg : AnalyticOn \ud835\udd5c g U)\n    (hU : IsPreconnected U) (h\u2080 : z\u2080 \u2208 U) (hfg : z\u2080 \u2208 closure ({z | f z = g z} \\ {z\u2080})) :\n    EqOn f g U", "start": [193, 1], "end": [196, 98], "kind": "commanddeclaration"}, {"full_name": "AnalyticOn.eq_of_frequently_eq", "code": "theorem eq_of_frequently_eq [ConnectedSpace \ud835\udd5c] (hf : AnalyticOn \ud835\udd5c f univ) (hg : AnalyticOn \ud835\udd5c g univ)\n    (hfg : \u2203\u1da0 z in \ud835\udcdd[\u2260] z\u2080, f z = g z) : f = g", "start": [199, 1], "end": [207, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Gaussian.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConvexOn.congr", "code": "theorem ConvexOn.congr [SMul \ud835\udd5c \u03b2] (hf : ConvexOn \ud835\udd5c s f) (hfg : EqOn f g s) : ConvexOn \ud835\udd5c s g", "start": [55, 1], "end": [57, 94], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.congr", "code": "theorem ConcaveOn.congr [SMul \ud835\udd5c \u03b2] (hf : ConcaveOn \ud835\udd5c s f) (hfg : EqOn f g s) : ConcaveOn \ud835\udd5c s g", "start": [60, 1], "end": [62, 94], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.congr", "code": "theorem StrictConvexOn.congr [SMul \ud835\udd5c \u03b2] (hf : StrictConvexOn \ud835\udd5c s f) (hfg : EqOn f g s) :\n    StrictConvexOn \ud835\udd5c s g", "start": [65, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.congr", "code": "theorem StrictConcaveOn.congr [SMul \ud835\udd5c \u03b2] (hf : StrictConcaveOn \ud835\udd5c s f) (hfg : EqOn f g s) :\n    StrictConcaveOn \ud835\udd5c s g", "start": [72, 1], "end": [76, 32], "kind": "commanddeclaration"}, {"full_name": "ConvexOn.add_const", "code": "theorem ConvexOn.add_const [Module \ud835\udd5c \u03b2] (hf : ConvexOn \ud835\udd5c s f) (b : \u03b2) :\n    ConvexOn \ud835\udd5c s (f + fun _ => b)", "start": [79, 1], "end": [81, 33], "kind": "commanddeclaration"}, {"full_name": "ConcaveOn.add_const", "code": "theorem ConcaveOn.add_const [Module \ud835\udd5c \u03b2] (hf : ConcaveOn \ud835\udd5c s f) (b : \u03b2) :\n    ConcaveOn \ud835\udd5c s (f + fun _ => b)", "start": [84, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "StrictConvexOn.add_const", "code": "theorem StrictConvexOn.add_const {\u03b3 : Type*} {f : E \u2192 \u03b3} [OrderedCancelAddCommMonoid \u03b3]\n    [Module \ud835\udd5c \u03b3] (hf : StrictConvexOn \ud835\udd5c s f) (b : \u03b3) : StrictConvexOn \ud835\udd5c s (f + fun _ => b)", "start": [89, 1], "end": [91, 42], "kind": "commanddeclaration"}, {"full_name": "StrictConcaveOn.add_const", "code": "theorem StrictConcaveOn.add_const {\u03b3 : Type*} {f : E \u2192 \u03b3} [OrderedCancelAddCommMonoid \u03b3]\n    [Module \ud835\udd5c \u03b3] (hf : StrictConcaveOn \ud835\udd5c s f) (b : \u03b3) : StrictConcaveOn \ud835\udd5c s (f + fun _ => b)", "start": [94, 1], "end": [96, 44], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma", "code": "theorem Gamma_mul_add_mul_le_rpow_Gamma_mul_rpow_Gamma {s t a b : \u211d} (hs : 0 < s) (ht : 0 < t)\n    (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    Gamma (a * s + b * t) \u2264 Gamma s ^ a * Gamma t ^ b", "start": [105, 1], "end": [162, 97], "kind": "commanddeclaration"}, {"full_name": "Real.convexOn_log_Gamma", "code": "theorem convexOn_log_Gamma : ConvexOn \u211d (Ioi 0) (log \u2218 Gamma)", "start": [165, 1], "end": [175, 71], "kind": "commanddeclaration"}, {"full_name": "Real.convexOn_Gamma", "code": "theorem convexOn_Gamma : ConvexOn \u211d (Ioi 0) Gamma", "start": [178, 1], "end": [186, 100], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.logGammaSeq", "code": "def logGammaSeq (x : \u211d) (n : \u2115) : \u211d :=\n  x * log n + log n ! - \u2211 m : \u2115 in Finset.range (n + 1), log (x + m)", "start": [195, 1], "end": [198, 69], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.f_nat_eq", "code": "theorem f_nat_eq (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hn : n \u2260 0) :\n    f n = f 1 + log (n - 1)!", "start": [203, 1], "end": [212, 42], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.f_add_nat_eq", "code": "theorem f_add_nat_eq (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hx : 0 < x) (n : \u2115) :\n    f (x + n) = f x + \u2211 m : \u2115 in Finset.range n, log (x + m)", "start": [215, 1], "end": [223, 49], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.f_add_nat_le", "code": "theorem f_add_nat_le (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hn : n \u2260 0) (hx : 0 < x) (hx' : x \u2264 1) :\n    f (n + x) \u2264 f n + x * log n", "start": [226, 1], "end": [234, 96], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.f_add_nat_ge", "code": "theorem f_add_nat_ge (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hn : 2 \u2264 n) (hx : 0 < x) :\n    f n + x * log (n - 1) \u2264 f (n + x)", "start": [237, 1], "end": [251, 92], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.logGammaSeq_add_one", "code": "theorem logGammaSeq_add_one (x : \u211d) (n : \u2115) :\n    logGammaSeq (x + 1) n = logGammaSeq x (n + 1) + log x - (x + 1) * (log (n + 1) - log n)", "start": [254, 1], "end": [269, 7], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.le_logGammaSeq", "code": "theorem le_logGammaSeq (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x \u2264 1) (n : \u2115) :\n    f x \u2264 f 1 + x * log (n + 1) - x * log n + logGammaSeq x n", "start": [272, 1], "end": [278, 7], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.ge_logGammaSeq", "code": "theorem ge_logGammaSeq (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hx : 0 < x) (hn : n \u2260 0) :\n    f 1 + logGammaSeq x n \u2264 f x", "start": [281, 1], "end": [291, 37], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.tendsto_logGammaSeq_of_le_one", "code": "theorem tendsto_logGammaSeq_of_le_one (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hx : 0 < x) (hx' : x \u2264 1) :\n    Tendsto (logGammaSeq x) atTop (\ud835\udcdd <| f x - f 1)", "start": [294, 1], "end": [312, 87], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.tendsto_logGammaSeq", "code": "theorem tendsto_logGammaSeq (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (\ud835\udcdd <| f x - f 1)", "start": [315, 1], "end": [363, 11], "kind": "commanddeclaration"}, {"full_name": "Real.BohrMollerup.tendsto_log_gamma", "code": "theorem tendsto_log_gamma {x : \u211d} (hx : 0 < x) :\n    Tendsto (logGammaSeq x) atTop (\ud835\udcdd <| log (Gamma x))", "start": [366, 1], "end": [373, 25], "kind": "commanddeclaration"}, {"full_name": "Real.eq_Gamma_of_log_convex", "code": "theorem eq_Gamma_of_log_convex {f : \u211d \u2192 \u211d} (hf_conv : ConvexOn \u211d (Ioi 0) (log \u2218 f))\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = y * f y) (hf_pos : \u2200 {y : \u211d}, 0 < y \u2192 0 < f y)\n    (hf_one : f 1 = 1) : EqOn f Gamma (Ioi (0 : \u211d))", "start": [379, 1], "end": [392, 9], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_two", "code": "theorem Gamma_two : Gamma 2 = 1", "start": [400, 1], "end": [401, 75], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_three_div_two_lt_one", "code": "theorem Gamma_three_div_two_lt_one : Gamma (3 / 2) < 1", "start": [404, 1], "end": [424, 13], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_strictMonoOn_Ici", "code": "theorem Gamma_strictMonoOn_Ici : StrictMonoOn Gamma (Ici 2)", "start": [427, 1], "end": [433, 54], "kind": "commanddeclaration"}, {"full_name": "Real.doublingGamma", "code": "def doublingGamma (s : \u211d) : \u211d :=\n  Gamma (s / 2) * Gamma (s / 2 + 1 / 2) * 2 ^ (s - 1) / sqrt \u03c0", "start": [449, 1], "end": [451, 63], "kind": "commanddeclaration"}, {"full_name": "Real.doublingGamma_add_one", "code": "theorem doublingGamma_add_one (s : \u211d) (hs : s \u2260 0) :\n    doublingGamma (s + 1) = s * doublingGamma s", "start": [454, 1], "end": [458, 7], "kind": "commanddeclaration"}, {"full_name": "Real.doublingGamma_one", "code": "theorem doublingGamma_one : doublingGamma 1 = 1", "start": [461, 1], "end": [463, 61], "kind": "commanddeclaration"}, {"full_name": "Real.log_doublingGamma_eq", "code": "theorem log_doublingGamma_eq :\n    EqOn (log \u2218 doublingGamma)\n      (fun s => log (Gamma (s / 2)) + log (Gamma (s / 2 + 1 / 2)) + s * log 2 - log (2 * sqrt \u03c0))\n      (Ioi 0)", "start": [466, 1], "end": [478, 10], "kind": "commanddeclaration"}, {"full_name": "Real.doublingGamma_log_convex_Ioi", "code": "theorem doublingGamma_log_convex_Ioi : ConvexOn \u211d (Ioi (0 : \u211d)) (log \u2218 doublingGamma)", "start": [481, 1], "end": [504, 70], "kind": "commanddeclaration"}, {"full_name": "Real.doublingGamma_eq_Gamma", "code": "theorem doublingGamma_eq_Gamma {s : \u211d} (hs : 0 < s) : doublingGamma s = Gamma s", "start": [507, 1], "end": [512, 37], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_mul_Gamma_add_half_of_pos", "code": "theorem Gamma_mul_Gamma_add_half_of_pos {s : \u211d} (hs : 0 < s) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * 2 ^ (1 - 2 * s) * sqrt \u03c0", "start": [515, 1], "end": [524, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean", "imports": ["Mathlib/MeasureTheory/Integral/PeakFunction.lean", "Mathlib/Analysis/SpecialFunctions/Integrals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EulerSine.antideriv_cos_comp_const_mul", "code": "theorem antideriv_cos_comp_const_mul (hz : z \u2260 0) (x : \u211d) :\n    HasDerivAt (fun y : \u211d => Complex.sin (2 * z * y) / (2 * z)) (Complex.cos (2 * z * x)) x", "start": [42, 1], "end": [49, 10], "kind": "commanddeclaration"}, {"full_name": "EulerSine.antideriv_sin_comp_const_mul", "code": "theorem antideriv_sin_comp_const_mul (hz : z \u2260 0) (x : \u211d) :\n    HasDerivAt (fun y : \u211d => -Complex.cos (2 * z * y) / (2 * z)) (Complex.sin (2 * z * x)) x", "start": [52, 1], "end": [59, 10], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_cos_mul_cos_pow_aux", "code": "theorem integral_cos_mul_cos_pow_aux (hn : 2 \u2264 n) (hz : z \u2260 0) :\n    (\u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ n) =\n      n / (2 * z) *\n        \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.sin (2 * z * x) * sin x * (cos x : \u2102) ^ (n - 1)", "start": [62, 1], "end": [89, 87], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_sin_mul_sin_mul_cos_pow_eq", "code": "theorem integral_sin_mul_sin_mul_cos_pow_eq (hn : 2 \u2264 n) (hz : z \u2260 0) :\n    (\u222b x in (0 : \u211d)..\u03c0 / 2, Complex.sin (2 * z * x) * sin x * (cos x : \u2102) ^ (n - 1)) =\n      (n / (2 * z) * \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ n) -\n        (n - 1) / (2 * z) *\n          \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (n - 2)", "start": [92, 1], "end": [151, 87], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_cos_mul_cos_pow", "code": "theorem integral_cos_mul_cos_pow (hn : 2 \u2264 n) (hz : z \u2260 0) :\n    (((1 : \u2102) - (4 : \u2102) * z ^ 2 / (n : \u2102) ^ 2) *\n      \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ n) =\n      (n - 1 : \u2102) / n *\n        \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (n - 2)", "start": [154, 1], "end": [165, 97], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_cos_mul_cos_pow_even", "code": "theorem integral_cos_mul_cos_pow_even (n : \u2115) (hz : z \u2260 0) :\n    (((1 : \u2102) - z ^ 2 / ((n : \u2102) + 1) ^ 2) *\n        \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (2 * n + 2)) =\n      (2 * n + 1 : \u2102) / (2 * n + 2) *\n        \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (2 * n)", "start": [168, 1], "end": [180, 20], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_cos_pow_eq", "code": "theorem integral_cos_pow_eq (n : \u2115) :\n    (\u222b x in (0 : \u211d)..\u03c0 / 2, cos x ^ n) = 1 / 2 * \u222b x in (0 : \u211d)..\u03c0, sin x ^ n", "start": [183, 1], "end": [203, 28], "kind": "commanddeclaration"}, {"full_name": "EulerSine.integral_cos_pow_pos", "code": "theorem integral_cos_pow_pos (n : \u2115) : 0 < \u222b x in (0 : \u211d)..\u03c0 / 2, cos x ^ n", "start": [206, 1], "end": [207, 79], "kind": "commanddeclaration"}, {"full_name": "EulerSine.sin_pi_mul_eq", "code": "theorem sin_pi_mul_eq (z : \u2102) (n : \u2115) :\n    Complex.sin (\u03c0 * z) =\n      ((\u03c0 * z * \u220f j in Finset.range n, ((1 : \u2102) - z ^ 2 / ((j : \u2102) + 1) ^ 2)) *\n          \u222b x in (0 : \u211d)..\u03c0 / 2, Complex.cos (2 * z * x) * (cos x : \u2102) ^ (2 * n)) /\n        (\u222b x in (0 : \u211d)..\u03c0 / 2, cos x ^ (2 * n) : \u211d)", "start": [210, 1], "end": [268, 23], "kind": "commanddeclaration"}, {"full_name": "EulerSine.tendsto_integral_cos_pow_mul_div", "code": "theorem tendsto_integral_cos_pow_mul_div {f : \u211d \u2192 \u2102} (hf : ContinuousOn f (Icc 0 (\u03c0 / 2))) :\n    Tendsto\n      (fun n : \u2115 => (\u222b x in (0 : \u211d)..\u03c0 / 2, (cos x : \u2102) ^ n * f x) /\n        (\u222b x in (0 : \u211d)..\u03c0 / 2, cos x ^ n : \u211d))\n      atTop (\ud835\udcdd <| f 0)", "start": [282, 1], "end": [299, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.tendsto_euler_sin_prod", "code": "theorem _root_.Complex.tendsto_euler_sin_prod (z : \u2102) :\n    Tendsto (fun n : \u2115 => \u03c0 * z * \u220f j in Finset.range n, ((1 : \u2102) - z ^ 2 / ((j : \u2102) + 1) ^ 2))\n      atTop (\ud835\udcdd <| Complex.sin (\u03c0 * z))", "start": [302, 1], "end": [328, 57], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_euler_sin_prod", "code": "theorem _root_.Real.tendsto_euler_sin_prod (x : \u211d) :\n    Tendsto (fun n : \u2115 => \u03c0 * x * \u220f j in Finset.range n, ((1 : \u211d) - x ^ 2 / ((j : \u211d) + 1) ^ 2))\n      atTop (\ud835\udcdd <| sin (\u03c0 * x))", "start": [331, 1], "end": [345, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/BernoulliPolynomials.lean", "imports": ["Mathlib/NumberTheory/Bernoulli.lean", "Mathlib/Data/Nat/Choose/Cast.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Derivative.lean"], "premises": [{"full_name": "Polynomial.bernoulli", "code": "def bernoulli (n : \u2115) : \u211a[X] :=\n  \u2211 i in range (n + 1), Polynomial.monomial (n - i) (_root_.bernoulli i * choose n i)", "start": [54, 1], "end": [56, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_def", "code": "theorem bernoulli_def (n : \u2115) : bernoulli n =\n    \u2211 i in range (n + 1), Polynomial.monomial i (_root_.bernoulli (n - i) * choose n i)", "start": [59, 1], "end": [64, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_zero", "code": "@[simp]\ntheorem bernoulli_zero : bernoulli 0 = 1", "start": [72, 1], "end": [73, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_eval_zero", "code": "@[simp]\ntheorem bernoulli_eval_zero (n : \u2115) : (bernoulli n).eval 0 = _root_.bernoulli n", "start": [76, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_eval_one", "code": "@[simp]\ntheorem bernoulli_eval_one (n : \u2115) : (bernoulli n).eval 1 = bernoulli' n", "start": [87, 1], "end": [95, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_bernoulli_add_one", "code": "theorem derivative_bernoulli_add_one (k : \u2115) :\n    Polynomial.derivative (bernoulli (k + 1)) = (k + 1) * bernoulli k", "start": [100, 1], "end": [111, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.derivative_bernoulli", "code": "theorem derivative_bernoulli (k : \u2115) :\n    Polynomial.derivative (bernoulli k) = k * bernoulli (k - 1)", "start": [114, 1], "end": [118, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_bernoulli", "code": "@[simp]\nnonrec theorem sum_bernoulli (n : \u2115) :\n    (\u2211 k in range (n + 1), ((n + 1).choose k : \u211a) \u2022 bernoulli k) = monomial n (n + 1 : \u211a)", "start": [121, 1], "end": [155, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_eq_sub_sum", "code": "theorem bernoulli_eq_sub_sum (n : \u2115) :\n    (n.succ : \u211a) \u2022 bernoulli n =\n      monomial n (n.succ : \u211a) - \u2211 k in Finset.range n, ((n + 1).choose k : \u211a) \u2022 bernoulli k", "start": [158, 1], "end": [163, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_range_pow_eq_bernoulli_sub", "code": "theorem sum_range_pow_eq_bernoulli_sub (n p : \u2115) :\n    ((p + 1 : \u211a) * \u2211 k in range n, (k : \u211a) ^ p) = (bernoulli p.succ).eval (n : \u211a) -\n    _root_.bernoulli p.succ", "start": [166, 1], "end": [182, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_succ_eval", "code": "theorem bernoulli_succ_eval (n p : \u2115) : (bernoulli p.succ).eval (n : \u211a) =\n    _root_.bernoulli p.succ + (p + 1 : \u211a) * \u2211 k in range n, (k : \u211a) ^ p", "start": [185, 1], "end": [189, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_eval_one_add", "code": "theorem bernoulli_eval_one_add (n : \u2115) (x : \u211a) :\n    (bernoulli n).eval (1 + x) = (bernoulli n).eval x + n * x ^ (n - 1)", "start": [192, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_generating_function", "code": "theorem bernoulli_generating_function (t : A) :\n    (mk fun n => aeval t ((1 / n ! : \u211a) \u2022 bernoulli n)) * (exp A - 1) =\n      PowerSeries.X * rescale t (exp A)", "start": [224, 1], "end": [263, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "imports": ["Mathlib/Analysis/Convex/Normed.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Homotopy/Contractible.lean", "Mathlib/Analysis/Convex/Contractible.lean", "Mathlib/Analysis/Convex/Complex.lean", "Mathlib/Analysis/Complex/ReImTopology.lean"], "premises": [{"full_name": "UpperHalfPlane.openEmbedding_coe", "code": "theorem openEmbedding_coe : OpenEmbedding ((\u2191) : \u210d \u2192 \u2102)", "start": [34, 1], "end": [35, 87], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.embedding_coe", "code": "theorem embedding_coe : Embedding ((\u2191) : \u210d \u2192 \u2102)", "start": [38, 1], "end": [39, 24], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.continuous_coe", "code": "theorem continuous_coe : Continuous ((\u2191) : \u210d \u2192 \u2102)", "start": [42, 1], "end": [43, 27], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.continuous_re", "code": "theorem continuous_re : Continuous re", "start": [46, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.continuous_im", "code": "theorem continuous_im : Continuous im", "start": [50, 1], "end": [51, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/UpperHalfPlane/FunctionsBoundedAtInfty.lean", "imports": ["Mathlib/Algebra/Module/Submodule/Basic.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "Mathlib/Order/Filter/ZeroAndBoundedAtFilter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UpperHalfPlane.atImInfty", "code": "def atImInfty :=\n  Filter.atTop.comap UpperHalfPlane.im", "start": [28, 1], "end": [30, 39], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.atImInfty_basis", "code": "theorem atImInfty_basis : atImInfty.HasBasis (fun _ => True) fun i : \u211d => im \u207b\u00b9' Set.Ici i", "start": [33, 1], "end": [34, 61], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.atImInfty_mem", "code": "theorem atImInfty_mem (S : Set \u210d) : S \u2208 atImInfty \u2194 \u2203 A : \u211d, \u2200 z : \u210d, A \u2264 im z \u2192 z \u2208 S", "start": [37, 1], "end": [38, 53], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.IsBoundedAtImInfty", "code": "def IsBoundedAtImInfty {\u03b1 : Type*} [Norm \u03b1] (f : \u210d \u2192 \u03b1) : Prop :=\n  BoundedAtFilter atImInfty f", "start": [41, 1], "end": [43, 30], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.IsZeroAtImInfty", "code": "def IsZeroAtImInfty {\u03b1 : Type*} [Zero \u03b1] [TopologicalSpace \u03b1] (f : \u210d \u2192 \u03b1) : Prop :=\n  ZeroAtFilter atImInfty f", "start": [46, 1], "end": [48, 27], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.zero_form_isBoundedAtImInfty", "code": "theorem zero_form_isBoundedAtImInfty {\u03b1 : Type*} [NormedField \u03b1] :\n    IsBoundedAtImInfty (0 : \u210d \u2192 \u03b1)", "start": [51, 1], "end": [53, 42], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.zeroAtImInftySubmodule", "code": "def zeroAtImInftySubmodule (\u03b1 : Type*) [NormedField \u03b1] : Submodule \u03b1 (\u210d \u2192 \u03b1) :=\n  zeroAtFilterSubmodule atImInfty", "start": [56, 1], "end": [58, 34], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.boundedAtImInftySubalgebra", "code": "def boundedAtImInftySubalgebra (\u03b1 : Type*) [NormedField \u03b1] : Subalgebra \u03b1 (\u210d \u2192 \u03b1) :=\n  boundedFilterSubalgebra atImInfty", "start": [61, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.IsBoundedAtImInfty.mul", "code": "nonrec theorem IsBoundedAtImInfty.mul {f g : \u210d \u2192 \u2102} (hf : IsBoundedAtImInfty f)\n    (hg : IsBoundedAtImInfty g) : IsBoundedAtImInfty (f * g)", "start": [66, 1], "end": [68, 66], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.bounded_mem", "code": "theorem bounded_mem (f : \u210d \u2192 \u2102) :\n    IsBoundedAtImInfty f \u2194 \u2203 M A : \u211d, \u2200 z : \u210d, A \u2264 im z \u2192 abs (f z) \u2264 M", "start": [71, 1], "end": [74, 19], "kind": "commanddeclaration"}, {"full_name": "UpperHalfPlane.zero_at_im_infty", "code": "theorem zero_at_im_infty (f : \u210d \u2192 \u2102) :\n    IsZeroAtImInfty f \u2194 \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 A : \u211d, \u2200 z : \u210d, A \u2264 im z \u2192 abs (f z) \u2264 \u03b5", "start": [77, 1], "end": [80, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/LocallyUniformLimit.lean", "imports": ["Mathlib/Analysis/Complex/RemovableSingularity.lean", "Mathlib/Analysis/Calculus/Series.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.cderiv", "code": "noncomputable def cderiv (r : \u211d) (f : \u2102 \u2192 E) (z : \u2102) : E :=\n  (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e w in C(z, r), ((w - z) ^ 2)\u207b\u00b9 \u2022 f w", "start": [39, 1], "end": [43, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.cderiv_eq_deriv", "code": "theorem cderiv_eq_deriv (hU : IsOpen U) (hf : DifferentiableOn \u2102 f U) (hr : 0 < r)\n    (hzr : closedBall z r \u2286 U) : cderiv r f z = deriv f z", "start": [46, 1], "end": [48, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_cderiv_le", "code": "theorem norm_cderiv_le (hr : 0 < r) (hf : \u2200 w \u2208 sphere z r, \u2016f w\u2016 \u2264 M) :\n    \u2016cderiv r f z\u2016 \u2264 M / r", "start": [51, 1], "end": [65, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.cderiv_sub", "code": "theorem cderiv_sub (hr : 0 < r) (hf : ContinuousOn f (sphere z r))\n    (hg : ContinuousOn g (sphere z r)) : cderiv r (f - g) z = cderiv r f z - cderiv r g z", "start": [68, 1], "end": [77, 44], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_cderiv_lt", "code": "theorem norm_cderiv_lt (hr : 0 < r) (hfM : \u2200 w \u2208 sphere z r, \u2016f w\u2016 < M)\n    (hf : ContinuousOn f (sphere z r)) : \u2016cderiv r f z\u2016 < M / r", "start": [80, 1], "end": [87, 73], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_cderiv_sub_lt", "code": "theorem norm_cderiv_sub_lt (hr : 0 < r) (hfg : \u2200 w \u2208 sphere z r, \u2016f w - g w\u2016 < M)\n    (hf : ContinuousOn f (sphere z r)) (hg : ContinuousOn g (sphere z r)) :\n    \u2016cderiv r f z - cderiv r g z\u2016 < M / r", "start": [90, 1], "end": [93, 58], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.cderiv", "code": "theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f \u03c6 (cthickening \u03b4 K))\n    (h\u03b4 : 0 < \u03b4) (hFn : \u2200\u1da0 n in \u03c6, ContinuousOn (F n) (cthickening \u03b4 K)) :\n    TendstoUniformlyOn (cderiv \u03b4 \u2218 F) (cderiv \u03b4 f) \u03c6 K", "start": [96, 1], "end": [111, 90], "kind": "commanddeclaration"}, {"full_name": "Complex.tendstoUniformlyOn_deriv_of_cthickening_subset", "code": "theorem tendstoUniformlyOn_deriv_of_cthickening_subset (hf : TendstoLocallyUniformlyOn F f \u03c6 U)\n    (hF : \u2200\u1da0 n in \u03c6, DifferentiableOn \u2102 (F n) U) {\u03b4 : \u211d} (h\u03b4 : 0 < \u03b4) (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : cthickening \u03b4 K \u2286 U) :\n    TendstoUniformlyOn (deriv \u2218 F) (cderiv \u03b4 f) \u03c6 K", "start": [118, 1], "end": [129, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.exists_cthickening_tendstoUniformlyOn", "code": "theorem exists_cthickening_tendstoUniformlyOn (hf : TendstoLocallyUniformlyOn F f \u03c6 U)\n    (hF : \u2200\u1da0 n in \u03c6, DifferentiableOn \u2102 (F n) U) (hK : IsCompact K) (hU : IsOpen U) (hKU : K \u2286 U) :\n    \u2203 \u03b4 > 0, cthickening \u03b4 K \u2286 U \u2227 TendstoUniformlyOn (deriv \u2218 F) (cderiv \u03b4 f) \u03c6 K", "start": [132, 1], "end": [136, 88], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.differentiableOn", "code": "theorem _root_.TendstoLocallyUniformlyOn.differentiableOn [\u03c6.NeBot]\n    (hf : TendstoLocallyUniformlyOn F f \u03c6 U) (hF : \u2200\u1da0 n in \u03c6, DifferentiableOn \u2102 (F n) U)\n    (hU : IsOpen U) : DifferentiableOn \u2102 f U", "start": [139, 1], "end": [158, 81], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.deriv", "code": "theorem _root_.TendstoLocallyUniformlyOn.deriv (hf : TendstoLocallyUniformlyOn F f \u03c6 U)\n    (hF : \u2200\u1da0 n in \u03c6, DifferentiableOn \u2102 (F n) U) (hU : IsOpen U) :\n    TendstoLocallyUniformlyOn (deriv \u2218 F) (deriv f) \u03c6 U", "start": [161, 1], "end": [170, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.differentiableOn_tsum_of_summable_norm", "code": "theorem differentiableOn_tsum_of_summable_norm {u : \u03b9 \u2192 \u211d} (hu : Summable u)\n    (hf : \u2200 i : \u03b9, DifferentiableOn \u2102 (F i) U) (hU : IsOpen U)\n    (hF_le : \u2200 (i : \u03b9) (w : \u2102), w \u2208 U \u2192 \u2016F i w\u2016 \u2264 u i) :\n    DifferentiableOn \u2102 (fun w : \u2102 => \u2211' i : \u03b9, F i w) U", "start": [177, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_deriv_of_summable_norm", "code": "theorem hasSum_deriv_of_summable_norm {u : \u03b9 \u2192 \u211d} (hu : Summable u)\n    (hf : \u2200 i : \u03b9, DifferentiableOn \u2102 (F i) U) (hU : IsOpen U)\n    (hF_le : \u2200 (i : \u03b9) (w : \u2102), w \u2208 U \u2192 \u2016F i w\u2016 \u2264 u i) (hz : z \u2208 U) :\n    HasSum (fun i : \u03b9 => deriv (F i) z) (deriv (fun w : \u2102 => \u2211' i : \u03b9, F i w) z)", "start": [189, 1], "end": [201, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Quaternion.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/LinearAlgebra/FreeModule/Finite/Basic.lean", "Mathlib/SetTheory/Cardinal/Ordinal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Finrank.lean", "Mathlib/Algebra/Algebra/Equiv.lean"], "premises": [{"full_name": "QuaternionAlgebra", "code": "@[ext]\nstructure QuaternionAlgebra (R : Type*) (a b : R) where\n  \n  re : R\n  imI : R\n  imJ : R\n  imK : R", "start": [54, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.equivProd", "code": "@[simps]\ndef equivProd {R : Type*} (c\u2081 c\u2082 : R) : \u210d[R,c\u2081,c\u2082] \u2243 R \u00d7 R \u00d7 R \u00d7 R where\n  toFun a := \u27e8a.1, a.2, a.3, a.4\u27e9\n  invFun a := \u27e8a.1, a.2.1, a.2.2.1, a.2.2.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [75, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.equivTuple", "code": "@[simps symm_apply]\ndef equivTuple {R : Type*} (c\u2081 c\u2082 : R) : \u210d[R,c\u2081,c\u2082] \u2243 (Fin 4 \u2192 R) where\n  toFun a := ![a.1, a.2, a.3, a.4]\n  invFun a := \u27e8a 0, a 1, a 2, a 3\u27e9\n  left_inv _ := rfl\n  right_inv f := by ext \u27e8_, _ | _ | _ | _ | _ | \u27e8\u27e9\u27e9 <;> rfl", "start": [84, 1], "end": [90, 60], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.equivTuple_apply", "code": "@[simp]\ntheorem equivTuple_apply {R : Type*} (c\u2081 c\u2082 : R) (x : \u210d[R,c\u2081,c\u2082]) :\n    equivTuple c\u2081 c\u2082 x = ![x.re, x.imI, x.imJ, x.imK]", "start": [93, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mk.eta", "code": "@[simp]\ntheorem mk.eta {R : Type*} {c\u2081 c\u2082} (a : \u210d[R,c\u2081,c\u2082]) : mk a.1 a.2 a.3 a.4 = a", "start": [99, 1], "end": [100, 84], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im", "code": "def im (x : \u210d[R,c\u2081,c\u2082]) : \u210d[R,c\u2081,c\u2082] :=\n  \u27e80, x.imI, x.imJ, x.imK\u27e9", "start": [108, 1], "end": [110, 27], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_re", "code": "@[simp]\ntheorem im_re : a.im.re = 0", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_imI", "code": "@[simp]\ntheorem im_imI : a.im.imI = a.imI", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_imJ", "code": "@[simp]\ntheorem im_imJ : a.im.imJ = a.imJ", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_imK", "code": "@[simp]\ntheorem im_imK : a.im.imK = a.imK", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_idem", "code": "@[simp]\ntheorem im_idem : a.im.im = a.im", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe", "code": "@[coe] def coe (x : R) : \u210d[R,c\u2081,c\u2082] := \u27e8x, 0, 0, 0\u27e9", "start": [138, 1], "end": [139, 52], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_re", "code": "@[simp, norm_cast]\ntheorem coe_re : (x : \u210d[R,c\u2081,c\u2082]).re = x", "start": [143, 1], "end": [144, 48], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_imI", "code": "@[simp, norm_cast]\ntheorem coe_imI : (x : \u210d[R,c\u2081,c\u2082]).imI = 0", "start": [147, 1], "end": [148, 50], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_imJ", "code": "@[simp, norm_cast]\ntheorem coe_imJ : (x : \u210d[R,c\u2081,c\u2082]).imJ = 0", "start": [151, 1], "end": [152, 50], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_imK", "code": "@[simp, norm_cast]\ntheorem coe_imK : (x : \u210d[R,c\u2081,c\u2082]).imK = 0", "start": [155, 1], "end": [156, 50], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_injective", "code": "theorem coe_injective : Function.Injective (coe : R \u2192 \u210d[R,c\u2081,c\u2082])", "start": [159, 1], "end": [159, 97], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_inj", "code": "@[simp]\ntheorem coe_inj {x y : R} : (x : \u210d[R,c\u2081,c\u2082]) = y \u2194 x = y", "start": [162, 1], "end": [164, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.zero_re", "code": "@[simp] theorem zero_re : (0 : \u210d[R,c\u2081,c\u2082]).re = 0", "start": [170, 1], "end": [170, 57], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.zero_imI", "code": "@[simp] theorem zero_imI : (0 : \u210d[R,c\u2081,c\u2082]).imI = 0", "start": [173, 1], "end": [173, 59], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.zero_imJ", "code": "@[simp] theorem zero_imJ : (0 : \u210d[R,c\u2081,c\u2082]).imJ = 0", "start": [176, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.zero_imK", "code": "@[simp] theorem zero_imK : (0 : \u210d[R,c\u2081,c\u2082]).imK = 0", "start": [179, 1], "end": [179, 59], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.zero_im", "code": "@[simp] theorem zero_im : (0 : \u210d[R,c\u2081,c\u2082]).im = 0", "start": [182, 1], "end": [182, 57], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : R) : \u210d[R,c\u2081,c\u2082]) = 0", "start": [184, 1], "end": [185, 53], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.one_re", "code": "@[simp] theorem one_re : (1 : \u210d[R,c\u2081,c\u2082]).re = 1", "start": [193, 1], "end": [193, 56], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.one_imI", "code": "@[simp] theorem one_imI : (1 : \u210d[R,c\u2081,c\u2082]).imI = 0", "start": [196, 1], "end": [196, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.one_imJ", "code": "@[simp] theorem one_imJ : (1 : \u210d[R,c\u2081,c\u2082]).imJ = 0", "start": [199, 1], "end": [199, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.one_imK", "code": "@[simp] theorem one_imK : (1 : \u210d[R,c\u2081,c\u2082]).imK = 0", "start": [202, 1], "end": [202, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.one_im", "code": "@[simp] theorem one_im : (1 : \u210d[R,c\u2081,c\u2082]).im = 0", "start": [205, 1], "end": [205, 56], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : R) : \u210d[R,c\u2081,c\u2082]) = 1", "start": [207, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.add_re", "code": "@[simp] theorem add_re : (a + b).re = a.re + b.re", "start": [215, 1], "end": [215, 57], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.add_imI", "code": "@[simp] theorem add_imI : (a + b).imI = a.imI + b.imI", "start": [218, 1], "end": [218, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.add_imJ", "code": "@[simp] theorem add_imJ : (a + b).imJ = a.imJ + b.imJ", "start": [221, 1], "end": [221, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.add_imK", "code": "@[simp] theorem add_imK : (a + b).imK = a.imK + b.imK", "start": [224, 1], "end": [224, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.add_im", "code": "@[simp] theorem add_im : (a + b).im = a.im + b.im", "start": [227, 1], "end": [228, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mk_add_mk", "code": "@[simp]\ntheorem mk_add_mk (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R) :\n    (mk a\u2081 a\u2082 a\u2083 a\u2084 : \u210d[R,c\u2081,c\u2082]) + mk b\u2081 b\u2082 b\u2083 b\u2084 = mk (a\u2081 + b\u2081) (a\u2082 + b\u2082) (a\u2083 + b\u2083) (a\u2084 + b\u2084)", "start": [230, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add : ((x + y : R) : \u210d[R,c\u2081,c\u2082]) = x + y", "start": [236, 1], "end": [237, 72], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_re", "code": "@[simp] theorem neg_re : (-a).re = -a.re", "start": [243, 1], "end": [243, 48], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_imI", "code": "@[simp] theorem neg_imI : (-a).imI = -a.imI", "start": [246, 1], "end": [246, 51], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_imJ", "code": "@[simp] theorem neg_imJ : (-a).imJ = -a.imJ", "start": [249, 1], "end": [249, 51], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_imK", "code": "@[simp] theorem neg_imK : (-a).imK = -a.imK", "start": [252, 1], "end": [252, 51], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_im", "code": "@[simp] theorem neg_im : (-a).im = -a.im", "start": [255, 1], "end": [256, 54], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.neg_mk", "code": "@[simp]\ntheorem neg_mk (a\u2081 a\u2082 a\u2083 a\u2084 : R) : -(mk a\u2081 a\u2082 a\u2083 a\u2084 : \u210d[R,c\u2081,c\u2082]) = \u27e8-a\u2081, -a\u2082, -a\u2083, -a\u2084\u27e9", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg : ((-x : R) : \u210d[R,c\u2081,c\u2082]) = -x", "start": [263, 1], "end": [264, 66], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_re", "code": "@[simp] theorem sub_re : (a - b).re = a.re - b.re", "start": [270, 1], "end": [270, 57], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_imI", "code": "@[simp] theorem sub_imI : (a - b).imI = a.imI - b.imI", "start": [273, 1], "end": [273, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_imJ", "code": "@[simp] theorem sub_imJ : (a - b).imJ = a.imJ - b.imJ", "start": [276, 1], "end": [276, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_imK", "code": "@[simp] theorem sub_imK : (a - b).imK = a.imK - b.imK", "start": [279, 1], "end": [279, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_im", "code": "@[simp] theorem sub_im : (a - b).im = a.im - b.im", "start": [282, 1], "end": [283, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mk_sub_mk", "code": "@[simp]\ntheorem mk_sub_mk (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R) :\n    (mk a\u2081 a\u2082 a\u2083 a\u2084 : \u210d[R,c\u2081,c\u2082]) - mk b\u2081 b\u2082 b\u2083 b\u2084 = mk (a\u2081 - b\u2081) (a\u2082 - b\u2082) (a\u2083 - b\u2083) (a\u2084 - b\u2084)", "start": [285, 1], "end": [288, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_im", "code": "@[simp, norm_cast]\ntheorem coe_im : (x : \u210d[R,c\u2081,c\u2082]).im = 0", "start": [291, 1], "end": [293, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.re_add_im", "code": "@[simp]\ntheorem re_add_im : \u2191a.re + a.im = a", "start": [296, 1], "end": [298, 80], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_self_im", "code": "@[simp]\ntheorem sub_self_im : a - a.im = a.re", "start": [301, 1], "end": [303, 80], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.sub_self_re", "code": "@[simp]\ntheorem sub_self_re : a - a.re = a.im", "start": [306, 1], "end": [308, 80], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_re", "code": "@[simp]\ntheorem mul_re : (a * b).re = a.1 * b.1 + c\u2081 * a.2 * b.2 + c\u2082 * a.3 * b.3 - c\u2081 * c\u2082 * a.4 * b.4", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_imI", "code": "@[simp]\ntheorem mul_imI : (a * b).imI = a.1 * b.2 + a.2 * b.1 - c\u2082 * a.3 * b.4 + c\u2082 * a.4 * b.3", "start": [332, 1], "end": [333, 95], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_imJ", "code": "@[simp]\ntheorem mul_imJ : (a * b).imJ = a.1 * b.3 + c\u2081 * a.2 * b.4 + a.3 * b.1 - c\u2081 * a.4 * b.2", "start": [336, 1], "end": [337, 95], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_imK", "code": "@[simp] theorem mul_imK : (a * b).imK = a.1 * b.4 + a.2 * b.3 - a.3 * b.2 + a.4 * b.1", "start": [340, 1], "end": [340, 93], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mk_mul_mk", "code": "@[simp]\ntheorem mk_mul_mk (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R) :\n    (mk a\u2081 a\u2082 a\u2083 a\u2084 : \u210d[R,c\u2081,c\u2082]) * mk b\u2081 b\u2082 b\u2083 b\u2084 =\n      \u27e8a\u2081 * b\u2081 + c\u2081 * a\u2082 * b\u2082 + c\u2082 * a\u2083 * b\u2083 - c\u2081 * c\u2082 * a\u2084 * b\u2084,\n        a\u2081 * b\u2082 + a\u2082 * b\u2081 - c\u2082 * a\u2083 * b\u2084 + c\u2082 * a\u2084 * b\u2083,\n        a\u2081 * b\u2083 + c\u2081 * a\u2082 * b\u2084 + a\u2083 * b\u2081 - c\u2081 * a\u2084 * b\u2082, a\u2081 * b\u2084 + a\u2082 * b\u2083 - a\u2083 * b\u2082 + a\u2084 * b\u2081\u27e9", "start": [343, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_re", "code": "@[simp] theorem smul_re : (s \u2022 a).re = s \u2022 a.re", "start": [365, 1], "end": [365, 55], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_imI", "code": "@[simp] theorem smul_imI : (s \u2022 a).imI = s \u2022 a.imI", "start": [368, 1], "end": [368, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_imJ", "code": "@[simp] theorem smul_imJ : (s \u2022 a).imJ = s \u2022 a.imJ", "start": [371, 1], "end": [371, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_imK", "code": "@[simp] theorem smul_imK : (s \u2022 a).imK = s \u2022 a.imK", "start": [374, 1], "end": [374, 58], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_im", "code": "@[simp] theorem smul_im {S} [SMulZeroClass S R] (s : S) : (s \u2022 a).im = s \u2022 a.im", "start": [377, 1], "end": [378, 59], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_mk", "code": "@[simp]\ntheorem smul_mk (re im_i im_j im_k : R) :\n    s \u2022 (\u27e8re, im_i, im_j, im_k\u27e9 : \u210d[R,c\u2081,c\u2082]) = \u27e8s \u2022 re, s \u2022 im_i, s \u2022 im_j, s \u2022 im_k\u27e9", "start": [380, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul [SMulZeroClass S R] (s : S) (r : R) :\n    (\u2191(s \u2022 r) : \u210d[R,c\u2081,c\u2082]) = s \u2022 (r : \u210d[R,c\u2081,c\u2082])", "start": [388, 1], "end": [391, 89], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.nat_cast_re", "code": "@[simp, norm_cast]\ntheorem nat_cast_re (n : \u2115) : (n : \u210d[R,c\u2081,c\u2082]).re = n", "start": [408, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.nat_cast_imI", "code": "@[simp, norm_cast]\ntheorem nat_cast_imI (n : \u2115) : (n : \u210d[R,c\u2081,c\u2082]).imI = 0", "start": [413, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.nat_cast_imJ", "code": "@[simp, norm_cast]\ntheorem nat_cast_imJ (n : \u2115) : (n : \u210d[R,c\u2081,c\u2082]).imJ = 0", "start": [418, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.nat_cast_imK", "code": "@[simp, norm_cast]\ntheorem nat_cast_imK (n : \u2115) : (n : \u210d[R,c\u2081,c\u2082]).imK = 0", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.nat_cast_im", "code": "@[simp, norm_cast]\ntheorem nat_cast_im (n : \u2115) : (n : \u210d[R,c\u2081,c\u2082]).im = 0", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_nat_cast", "code": "@[norm_cast]\ntheorem coe_nat_cast (n : \u2115) : \u2191(n : R) = (n : \u210d[R,c\u2081,c\u2082])", "start": [433, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.int_cast_re", "code": "@[simp, norm_cast]\ntheorem int_cast_re (z : \u2124) : (z : \u210d[R,c\u2081,c\u2082]).re = z", "start": [438, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.int_cast_imI", "code": "@[simp, norm_cast]\ntheorem int_cast_imI (z : \u2124) : (z : \u210d[R,c\u2081,c\u2082]).imI = 0", "start": [443, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.int_cast_imJ", "code": "@[simp, norm_cast]\ntheorem int_cast_imJ (z : \u2124) : (z : \u210d[R,c\u2081,c\u2082]).imJ = 0", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.int_cast_imK", "code": "@[simp, norm_cast]\ntheorem int_cast_imK (z : \u2124) : (z : \u210d[R,c\u2081,c\u2082]).imK = 0", "start": [453, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.int_cast_im", "code": "@[simp, norm_cast]\ntheorem int_cast_im (z : \u2124) : (z : \u210d[R,c\u2081,c\u2082]).im = 0", "start": [458, 1], "end": [460, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_int_cast", "code": "@[norm_cast]\ntheorem coe_int_cast (z : \u2124) : \u2191(z : R) = (z : \u210d[R,c\u2081,c\u2082])", "start": [463, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.instRing", "code": "instance instRing : Ring \u210d[R,c\u2081,c\u2082] where\n  __ := inferInstanceAs (AddCommGroupWithOne \u210d[R,c\u2081,c\u2082])\n  left_distrib _ _ _ := by ext <;> simp <;> ring\n  right_distrib _ _ _ := by ext <;> simp <;> ring\n  zero_mul _ := by ext <;> simp\n  mul_zero _ := by ext <;> simp\n  mul_assoc _ _ _ := by ext <;> simp <;> ring\n  one_mul _ := by ext <;> simp\n  mul_one _ := by ext <;> simp", "start": [468, 1], "end": [476, 31], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_mul", "code": "@[norm_cast, simp]\ntheorem coe_mul : ((x * y : R) : \u210d[R,c\u2081,c\u2082]) = x * y", "start": [478, 1], "end": [479, 72], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.algebraMap_eq", "code": "theorem algebraMap_eq (r : R) : algebraMap R \u210d[R,c\u2081,c\u2082] r = \u27e8r, 0, 0, 0\u27e9", "start": [494, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.algebraMap_injective", "code": "theorem algebraMap_injective : (algebraMap R \u210d[R,c\u2081,c\u2082] : _ \u2192 _).Injective", "start": [498, 1], "end": [499, 36], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.re\u2097", "code": "@[simps]\ndef re\u2097 : \u210d[R,c\u2081,c\u2082] \u2192\u2097[R] R where\n  toFun := re\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [511, 1], "end": [516, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imI\u2097", "code": "@[simps]\ndef imI\u2097 : \u210d[R,c\u2081,c\u2082] \u2192\u2097[R] R where\n  toFun := imI\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [519, 1], "end": [524, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imJ\u2097", "code": "@[simps]\ndef imJ\u2097 : \u210d[R,c\u2081,c\u2082] \u2192\u2097[R] R where\n  toFun := imJ\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [527, 1], "end": [532, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imK\u2097", "code": "@[simps]\ndef imK\u2097 : \u210d[R,c\u2081,c\u2082] \u2192\u2097[R] R where\n  toFun := imK\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [535, 1], "end": [540, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.linearEquivTuple", "code": "def linearEquivTuple : \u210d[R,c\u2081,c\u2082] \u2243\u2097[R] Fin 4 \u2192 R :=\n  LinearEquiv.symm { (equivTuple c\u2081 c\u2082).symm with\n      toFun := (equivTuple c\u2081 c\u2082).symm\n      invFun := equivTuple c\u2081 c\u2082\n      map_add' := fun _ _ => rfl\n      map_smul' := fun _ _ => rfl }", "start": [543, 1], "end": [550, 36], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_linearEquivTuple", "code": "@[simp]\ntheorem coe_linearEquivTuple : \u21d1(linearEquivTuple c\u2081 c\u2082) = equivTuple c\u2081 c\u2082", "start": [553, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_linearEquivTuple_symm", "code": "@[simp]\ntheorem coe_linearEquivTuple_symm : \u21d1(linearEquivTuple c\u2081 c\u2082).symm = (equivTuple c\u2081 c\u2082).symm", "start": [558, 1], "end": [560, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.basisOneIJK", "code": "noncomputable def basisOneIJK : Basis (Fin 4) R \u210d[R,c\u2081,c\u2082] :=\n  .ofEquivFun <| linearEquivTuple c\u2081 c\u2082", "start": [563, 1], "end": [565, 40], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_basisOneIJK_repr", "code": "@[simp]\ntheorem coe_basisOneIJK_repr (q : \u210d[R,c\u2081,c\u2082]) :\n    \u21d1((basisOneIJK c\u2081 c\u2082).repr q) = ![q.re, q.imI, q.imJ, q.imK]", "start": [568, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.rank_eq_four", "code": "theorem rank_eq_four [StrongRankCondition R] : Module.rank R \u210d[R,c\u2081,c\u2082] = 4", "start": [578, 1], "end": [580, 11], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.finrank_eq_four", "code": "theorem finrank_eq_four [StrongRankCondition R] : FiniteDimensional.finrank R \u210d[R,c\u2081,c\u2082] = 4", "start": [583, 1], "end": [584, 69], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.swapEquiv", "code": "@[simps]\ndef swapEquiv : \u210d[R,c\u2081,c\u2082] \u2243\u2090[R] \u210d[R, c\u2082, c\u2081] where\n  toFun t := \u27e8t.1, t.3, t.2, -t.4\u27e9\n  invFun t := \u27e8t.1, t.3, t.2, -t.4\u27e9\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_mul' _ _ := by\n    ext\n      <;> simp only [mul_re, mul_imJ, mul_imI, add_left_inj, mul_imK, neg_mul, neg_add_rev,\n                     neg_sub, mk_mul_mk, mul_neg, neg_neg, sub_neg_eq_add]\n      <;> ring\n  map_add' _ _ := by ext <;> simp [add_comm]\n  commutes' _ := by simp [algebraMap_eq]", "start": [587, 1], "end": [600, 41], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_sub", "code": "@[norm_cast, simp]\ntheorem coe_sub : ((x - y : R) : \u210d[R,c\u2081,c\u2082]) = x - y", "start": [604, 1], "end": [606, 40], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_pow", "code": "@[norm_cast, simp]\ntheorem coe_pow (n : \u2115) : (\u2191(x ^ n) : \u210d[R,c\u2081,c\u2082]) = (x : \u210d[R,c\u2081,c\u2082]) ^ n", "start": [609, 1], "end": [611, 40], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_commutes", "code": "theorem coe_commutes : \u2191r * a = a * r", "start": [614, 1], "end": [615, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_commute", "code": "theorem coe_commute : Commute (\u2191r) a", "start": [618, 1], "end": [619, 19], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_mul_eq_smul", "code": "theorem coe_mul_eq_smul : \u2191r * a = r \u2022 a", "start": [622, 1], "end": [623, 30], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_coe_eq_smul", "code": "theorem mul_coe_eq_smul : a * r = r \u2022 a", "start": [626, 1], "end": [626, 83], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_algebraMap", "code": "@[norm_cast, simp]\ntheorem coe_algebraMap : \u21d1(algebraMap R \u210d[R,c\u2081,c\u2082]) = coe", "start": [629, 1], "end": [631, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.smul_coe", "code": "theorem smul_coe : x \u2022 (y : \u210d[R,c\u2081,c\u2082]) = \u2191(x * y)", "start": [634, 1], "end": [634, 87], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.instStarQuaternionAlgebra", "code": "instance instStarQuaternionAlgebra : Star \u210d[R,c\u2081,c\u2082] where star a := \u27e8a.1, -a.2, -a.3, -a.4\u27e9", "start": [637, 1], "end": [638, 93], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.re_star", "code": "@[simp] theorem re_star : (star a).re = a.re", "start": [640, 1], "end": [640, 52], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imI_star", "code": "@[simp]\ntheorem imI_star : (star a).imI = -a.imI", "start": [643, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imJ_star", "code": "@[simp]\ntheorem imJ_star : (star a).imJ = -a.imJ", "start": [648, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.imK_star", "code": "@[simp]\ntheorem imK_star : (star a).imK = -a.imK", "start": [653, 1], "end": [655, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.im_star", "code": "@[simp]\ntheorem im_star : (star a).im = -a.im", "start": [658, 1], "end": [660, 54], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_mk", "code": "@[simp]\ntheorem star_mk (a\u2081 a\u2082 a\u2083 a\u2084 : R) : star (mk a\u2081 a\u2082 a\u2083 a\u2084 : \u210d[R,c\u2081,c\u2082]) = \u27e8a\u2081, -a\u2082, -a\u2083, -a\u2084\u27e9", "start": [663, 1], "end": [665, 6], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.instStarRing", "code": "instance instStarRing : StarRing \u210d[R,c\u2081,c\u2082] where\n  star_involutive x := by simp [Star.star]\n  star_add a b := by ext <;> simp [add_comm]\n  star_mul a b := by ext <;> simp <;> ring", "start": [668, 1], "end": [671, 43], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.self_add_star'", "code": "theorem self_add_star' : a + star a = \u2191(2 * a.re)", "start": [673, 1], "end": [673, 79], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.self_add_star", "code": "theorem self_add_star : a + star a = 2 * a.re", "start": [676, 1], "end": [676, 97], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_add_self'", "code": "theorem star_add_self' : star a + a = \u2191(2 * a.re)", "start": [679, 1], "end": [679, 86], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_add_self", "code": "theorem star_add_self : star a + a = 2 * a.re", "start": [682, 1], "end": [682, 81], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_eq_two_re_sub", "code": "theorem star_eq_two_re_sub : star a = \u2191(2 * a.re) - a", "start": [685, 1], "end": [686, 39], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_coe", "code": "@[simp, norm_cast]\ntheorem star_coe : star (x : \u210d[R,c\u2081,c\u2082]) = x", "start": [694, 1], "end": [695, 64], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_im", "code": "@[simp] theorem star_im : star a.im = -a.im", "start": [698, 1], "end": [698, 57], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_smul", "code": "@[simp]\ntheorem star_smul [Monoid S] [DistribMulAction S R] (s : S) (a : \u210d[R,c\u2081,c\u2082]) :\n    star (s \u2022 a) = s \u2022 star a", "start": [701, 1], "end": [704, 92], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.eq_re_of_eq_coe", "code": "theorem eq_re_of_eq_coe {a : \u210d[R,c\u2081,c\u2082]} {x : R} (h : a = x) : a = a.re", "start": [707, 1], "end": [707, 93], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.eq_re_iff_mem_range_coe", "code": "theorem eq_re_iff_mem_range_coe {a : \u210d[R,c\u2081,c\u2082]} :\n    a = a.re \u2194 a \u2208 Set.range (coe : R \u2192 \u210d[R,c\u2081,c\u2082])", "start": [710, 1], "end": [712, 66], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_eq_self", "code": "@[simp]\ntheorem star_eq_self {c\u2081 c\u2082 : R} {a : \u210d[R,c\u2081,c\u2082]} : star a = a \u2194 a = a.re", "start": [719, 1], "end": [721, 77], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_eq_neg", "code": "theorem star_eq_neg {c\u2081 c\u2082 : R} {a : \u210d[R,c\u2081,c\u2082]} : star a = -a \u2194 a.re = 0", "start": [724, 1], "end": [725, 59], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.star_mul_eq_coe", "code": "theorem star_mul_eq_coe : star a * a = (star a * a).re", "start": [731, 1], "end": [731, 83], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.mul_star_eq_coe", "code": "theorem mul_star_eq_coe : a * star a = (a * star a).re", "start": [734, 1], "end": [736, 26], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.starAe", "code": "def starAe : \u210d[R,c\u2081,c\u2082] \u2243\u2090[R] \u210d[R,c\u2081,c\u2082]\u1d50\u1d52\u1d56 :=\n  { starAddEquiv.trans opAddEquiv with\n    toFun := op \u2218 star\n    invFun := star \u2218 unop\n    map_mul' := fun x y => by simp\n    commutes' := fun r => by simp }", "start": [741, 1], "end": [747, 36], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.coe_starAe", "code": "@[simp]\ntheorem coe_starAe : \u21d1(starAe : \u210d[R,c\u2081,c\u2082] \u2243\u2090[R] _) = op \u2218 star", "start": [750, 1], "end": [752, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion", "code": "def Quaternion (R : Type*) [One R] [Neg R] :=\n  QuaternionAlgebra R (-1) (-1)", "start": [757, 1], "end": [760, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.equivProd", "code": "@[simps!]\ndef Quaternion.equivProd (R : Type*) [One R] [Neg R] : \u210d[R] \u2243 R \u00d7 R \u00d7 R \u00d7 R :=\n  QuaternionAlgebra.equivProd _ _", "start": [766, 1], "end": [769, 34], "kind": "commanddeclaration"}, {"full_name": "Quaternion.equivTuple", "code": "@[simps! symm_apply]\ndef Quaternion.equivTuple (R : Type*) [One R] [Neg R] : \u210d[R] \u2243 (Fin 4 \u2192 R) :=\n  QuaternionAlgebra.equivTuple _ _", "start": [772, 1], "end": [775, 35], "kind": "commanddeclaration"}, {"full_name": "Quaternion.equivTuple_apply", "code": "@[simp]\ntheorem Quaternion.equivTuple_apply (R : Type*) [One R] [Neg R] (x : \u210d[R]) :\n    Quaternion.equivTuple R x = ![x.re, x.imI, x.imJ, x.imK]", "start": [778, 1], "end": [781, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe", "code": "@[coe] def coe : R \u2192 \u210d[R] := QuaternionAlgebra.coe", "start": [795, 1], "end": [796, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.instRing", "code": "instance instRing : Ring \u210d[R] := QuaternionAlgebra.instRing", "start": [800, 1], "end": [800, 60], "kind": "commanddeclaration"}, {"full_name": "Quaternion.algebra", "code": "protected instance algebra [CommSemiring S] [Algebra S R] : Algebra S \u210d[R] :=\n  inferInstanceAs <| Algebra S \u210d[R,-1,-1]", "start": [812, 1], "end": [813, 42], "kind": "commanddeclaration"}, {"full_name": "Quaternion.ext", "code": "@[ext]\ntheorem ext : a.re = b.re \u2192 a.imI = b.imI \u2192 a.imJ = b.imJ \u2192 a.imK = b.imK \u2192 a = b", "start": [820, 1], "end": [822, 28], "kind": "commanddeclaration"}, {"full_name": "Quaternion.ext_iff", "code": "theorem ext_iff {a b : \u210d[R]} :\n    a = b \u2194 a.re = b.re \u2227 a.imI = b.imI \u2227 a.imJ = b.imJ \u2227 a.imK = b.imK", "start": [825, 1], "end": [827, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im", "code": "nonrec def im (x : \u210d[R]) : \u210d[R] := x.im", "start": [830, 1], "end": [831, 40], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_re", "code": "@[simp] theorem im_re : a.im.re = 0", "start": [834, 1], "end": [834, 43], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_imI", "code": "@[simp] theorem im_imI : a.im.imI = a.imI", "start": [837, 1], "end": [837, 49], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_imJ", "code": "@[simp] theorem im_imJ : a.im.imJ = a.imJ", "start": [840, 1], "end": [840, 49], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_imK", "code": "@[simp] theorem im_imK : a.im.imK = a.imK", "start": [843, 1], "end": [843, 49], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_idem", "code": "@[simp] theorem im_idem : a.im.im = a.im", "start": [846, 1], "end": [846, 48], "kind": "commanddeclaration"}, {"full_name": "Quaternion.re_add_im", "code": "@[simp] nonrec theorem re_add_im : \u2191a.re + a.im = a", "start": [849, 1], "end": [849, 67], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_self_im", "code": "@[simp] nonrec theorem sub_self_im : a - a.im = a.re", "start": [852, 1], "end": [852, 70], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_self_re", "code": "@[simp] nonrec theorem sub_self_re : a - \u2191a.re = a.im", "start": [855, 1], "end": [855, 71], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_re", "code": "@[simp, norm_cast]\ntheorem coe_re : (x : \u210d[R]).re = x", "start": [858, 1], "end": [859, 42], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_imI", "code": "@[simp, norm_cast]\ntheorem coe_imI : (x : \u210d[R]).imI = 0", "start": [862, 1], "end": [863, 44], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_imJ", "code": "@[simp, norm_cast]\ntheorem coe_imJ : (x : \u210d[R]).imJ = 0", "start": [866, 1], "end": [867, 44], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_imK", "code": "@[simp, norm_cast]\ntheorem coe_imK : (x : \u210d[R]).imK = 0", "start": [870, 1], "end": [871, 44], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_im", "code": "@[simp, norm_cast]\ntheorem coe_im : (x : \u210d[R]).im = 0", "start": [874, 1], "end": [875, 42], "kind": "commanddeclaration"}, {"full_name": "Quaternion.zero_re", "code": "@[simp] theorem zero_re : (0 : \u210d[R]).re = 0", "start": [878, 1], "end": [878, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.zero_imI", "code": "@[simp] theorem zero_imI : (0 : \u210d[R]).imI = 0", "start": [881, 1], "end": [881, 53], "kind": "commanddeclaration"}, {"full_name": "Quaternion.zero_imJ", "code": "@[simp] theorem zero_imJ : (0 : \u210d[R]).imJ = 0", "start": [884, 1], "end": [884, 53], "kind": "commanddeclaration"}, {"full_name": "Quaternion.zero_imK", "code": "@[simp] theorem zero_imK : (0 : \u210d[R]).imK = 0", "start": [887, 1], "end": [887, 53], "kind": "commanddeclaration"}, {"full_name": "Quaternion.zero_im", "code": "@[simp] theorem zero_im : (0 : \u210d[R]).im = 0", "start": [890, 1], "end": [890, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : R) : \u210d[R]) = 0", "start": [893, 1], "end": [894, 47], "kind": "commanddeclaration"}, {"full_name": "Quaternion.one_re", "code": "@[simp] theorem one_re : (1 : \u210d[R]).re = 1", "start": [897, 1], "end": [897, 50], "kind": "commanddeclaration"}, {"full_name": "Quaternion.one_imI", "code": "@[simp] theorem one_imI : (1 : \u210d[R]).imI = 0", "start": [900, 1], "end": [900, 52], "kind": "commanddeclaration"}, {"full_name": "Quaternion.one_imJ", "code": "@[simp] theorem one_imJ : (1 : \u210d[R]).imJ = 0", "start": [903, 1], "end": [903, 52], "kind": "commanddeclaration"}, {"full_name": "Quaternion.one_imK", "code": "@[simp] theorem one_imK : (1 : \u210d[R]).imK = 0", "start": [906, 1], "end": [906, 52], "kind": "commanddeclaration"}, {"full_name": "Quaternion.one_im", "code": "@[simp] theorem one_im : (1 : \u210d[R]).im = 0", "start": [909, 1], "end": [909, 50], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : R) : \u210d[R]) = 1", "start": [912, 1], "end": [913, 46], "kind": "commanddeclaration"}, {"full_name": "Quaternion.add_re", "code": "@[simp] theorem add_re : (a + b).re = a.re + b.re", "start": [916, 1], "end": [916, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.add_imI", "code": "@[simp] theorem add_imI : (a + b).imI = a.imI + b.imI", "start": [919, 1], "end": [919, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.add_imJ", "code": "@[simp] theorem add_imJ : (a + b).imJ = a.imJ + b.imJ", "start": [922, 1], "end": [922, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.add_imK", "code": "@[simp] theorem add_imK : (a + b).imK = a.imK + b.imK", "start": [925, 1], "end": [925, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.add_im", "code": "@[simp] nonrec theorem add_im : (a + b).im = a.im + b.im", "start": [928, 1], "end": [928, 71], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add : ((x + y : R) : \u210d[R]) = x + y", "start": [931, 1], "end": [933, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.neg_re", "code": "@[simp] theorem neg_re : (-a).re = -a.re", "start": [936, 1], "end": [936, 48], "kind": "commanddeclaration"}, {"full_name": "Quaternion.neg_imI", "code": "@[simp] theorem neg_imI : (-a).imI = -a.imI", "start": [939, 1], "end": [939, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.neg_imJ", "code": "@[simp] theorem neg_imJ : (-a).imJ = -a.imJ", "start": [942, 1], "end": [942, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.neg_imK", "code": "@[simp] theorem neg_imK : (-a).imK = -a.imK", "start": [945, 1], "end": [945, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.neg_im", "code": "@[simp] nonrec theorem neg_im : (-a).im = -a.im", "start": [948, 1], "end": [948, 60], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg : ((-x : R) : \u210d[R]) = -x", "start": [951, 1], "end": [953, 30], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_re", "code": "@[simp] theorem sub_re : (a - b).re = a.re - b.re", "start": [956, 1], "end": [956, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_imI", "code": "@[simp] theorem sub_imI : (a - b).imI = a.imI - b.imI", "start": [959, 1], "end": [959, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_imJ", "code": "@[simp] theorem sub_imJ : (a - b).imJ = a.imJ - b.imJ", "start": [962, 1], "end": [962, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_imK", "code": "@[simp] theorem sub_imK : (a - b).imK = a.imK - b.imK", "start": [965, 1], "end": [965, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sub_im", "code": "@[simp] nonrec theorem sub_im : (a - b).im = a.im - b.im", "start": [968, 1], "end": [968, 71], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub : ((x - y : R) : \u210d[R]) = x - y", "start": [971, 1], "end": [973, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_re", "code": "@[simp]\ntheorem mul_re : (a * b).re = a.re * b.re - a.imI * b.imI - a.imJ * b.imJ - a.imK * b.imK", "start": [976, 1], "end": [978, 99], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_imI", "code": "@[simp]\ntheorem mul_imI : (a * b).imI = a.re * b.imI + a.imI * b.re + a.imJ * b.imK - a.imK * b.imJ", "start": [981, 1], "end": [983, 100], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_imJ", "code": "@[simp]\ntheorem mul_imJ : (a * b).imJ = a.re * b.imJ - a.imI * b.imK + a.imJ * b.re + a.imK * b.imI", "start": [986, 1], "end": [988, 100], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_imK", "code": "@[simp]\ntheorem mul_imK : (a * b).imK = a.re * b.imK + a.imI * b.imJ - a.imJ * b.imI + a.imK * b.re", "start": [991, 1], "end": [993, 100], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul : ((x * y : R) : \u210d[R]) = x * y", "start": [996, 1], "end": [997, 80], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_pow", "code": "@[norm_cast, simp]\ntheorem coe_pow (n : \u2115) : (\u2191(x ^ n) : \u210d[R]) = (x : \u210d[R]) ^ n", "start": [1000, 1], "end": [1002, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nat_cast_re", "code": "@[simp, norm_cast]\ntheorem nat_cast_re (n : \u2115) : (n : \u210d[R]).re = n", "start": [1005, 1], "end": [1006, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nat_cast_imI", "code": "@[simp, norm_cast]\ntheorem nat_cast_imI (n : \u2115) : (n : \u210d[R]).imI = 0", "start": [1009, 1], "end": [1010, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nat_cast_imJ", "code": "@[simp, norm_cast]\ntheorem nat_cast_imJ (n : \u2115) : (n : \u210d[R]).imJ = 0", "start": [1013, 1], "end": [1014, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nat_cast_imK", "code": "@[simp, norm_cast]\ntheorem nat_cast_imK (n : \u2115) : (n : \u210d[R]).imK = 0", "start": [1017, 1], "end": [1018, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nat_cast_im", "code": "@[simp, norm_cast]\ntheorem nat_cast_im (n : \u2115) : (n : \u210d[R]).im = 0", "start": [1021, 1], "end": [1022, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_nat_cast", "code": "@[norm_cast]\ntheorem coe_nat_cast (n : \u2115) : \u2191(n : R) = (n : \u210d[R])", "start": [1025, 1], "end": [1026, 60], "kind": "commanddeclaration"}, {"full_name": "Quaternion.int_cast_re", "code": "@[simp, norm_cast]\ntheorem int_cast_re (z : \u2124) : (z : \u210d[R]).re = z", "start": [1029, 1], "end": [1030, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.int_cast_imI", "code": "@[simp, norm_cast]\ntheorem int_cast_imI (z : \u2124) : (z : \u210d[R]).imI = 0", "start": [1033, 1], "end": [1034, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.int_cast_imJ", "code": "@[simp, norm_cast]\ntheorem int_cast_imJ (z : \u2124) : (z : \u210d[R]).imJ = 0", "start": [1037, 1], "end": [1038, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.int_cast_imK", "code": "@[simp, norm_cast]\ntheorem int_cast_imK (z : \u2124) : (z : \u210d[R]).imK = 0", "start": [1041, 1], "end": [1042, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.int_cast_im", "code": "@[simp, norm_cast]\ntheorem int_cast_im (z : \u2124) : (z : \u210d[R]).im = 0", "start": [1045, 1], "end": [1046, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_int_cast", "code": "@[norm_cast]\ntheorem coe_int_cast (z : \u2124) : \u2191(z : R) = (z : \u210d[R])", "start": [1049, 1], "end": [1050, 60], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_injective", "code": "theorem coe_injective : Function.Injective (coe : R \u2192 \u210d[R])", "start": [1053, 1], "end": [1054, 34], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_inj", "code": "@[simp]\ntheorem coe_inj {x y : R} : (x : \u210d[R]) = y \u2194 x = y", "start": [1057, 1], "end": [1059, 23], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_re", "code": "@[simp]\ntheorem smul_re [SMul S R] (s : S) : (s \u2022 a).re = s \u2022 a.re", "start": [1062, 1], "end": [1064, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_imI", "code": "@[simp] theorem smul_imI [SMul S R] (s : S) : (s \u2022 a).imI = s \u2022 a.imI", "start": [1067, 1], "end": [1067, 77], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_imJ", "code": "@[simp] theorem smul_imJ [SMul S R] (s : S) : (s \u2022 a).imJ = s \u2022 a.imJ", "start": [1070, 1], "end": [1070, 77], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_imK", "code": "@[simp] theorem smul_imK [SMul S R] (s : S) : (s \u2022 a).imK = s \u2022 a.imK", "start": [1073, 1], "end": [1073, 77], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_im", "code": "@[simp]\nnonrec theorem smul_im [SMulZeroClass S R] (s : S) : (s \u2022 a).im = s \u2022 a.im", "start": [1076, 1], "end": [1078, 14], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul [SMulZeroClass S R] (s : S) (r : R) : (\u2191(s \u2022 r) : \u210d[R]) = s \u2022 (r : \u210d[R])", "start": [1081, 1], "end": [1083, 33], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_commutes", "code": "theorem coe_commutes : \u2191r * a = a * r", "start": [1086, 1], "end": [1087, 37], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_commute", "code": "theorem coe_commute : Commute (\u2191r) a", "start": [1090, 1], "end": [1091, 36], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_mul_eq_smul", "code": "theorem coe_mul_eq_smul : \u2191r * a = r \u2022 a", "start": [1094, 1], "end": [1095, 40], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_coe_eq_smul", "code": "theorem mul_coe_eq_smul : a * r = r \u2022 a", "start": [1098, 1], "end": [1099, 40], "kind": "commanddeclaration"}, {"full_name": "Quaternion.algebraMap_def", "code": "@[simp]\ntheorem algebraMap_def : \u21d1(algebraMap R \u210d[R]) = coe", "start": [1102, 1], "end": [1104, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.algebraMap_injective", "code": "theorem algebraMap_injective : (algebraMap R \u210d[R] : _ \u2192 _).Injective", "start": [1107, 1], "end": [1108, 41], "kind": "commanddeclaration"}, {"full_name": "Quaternion.smul_coe", "code": "theorem smul_coe : x \u2022 (y : \u210d[R]) = \u2191(x * y)", "start": [1110, 1], "end": [1111, 33], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rank_eq_four", "code": "theorem rank_eq_four [StrongRankCondition R] : Module.rank R \u210d[R] = 4", "start": [1117, 1], "end": [1118, 37], "kind": "commanddeclaration"}, {"full_name": "Quaternion.finrank_eq_four", "code": "theorem finrank_eq_four [StrongRankCondition R] : FiniteDimensional.finrank R \u210d[R] = 4", "start": [1121, 1], "end": [1122, 40], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_re", "code": "@[simp] theorem star_re : (star a).re = a.re", "start": [1125, 1], "end": [1125, 52], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_imI", "code": "@[simp] theorem star_imI : (star a).imI = -a.imI", "start": [1128, 1], "end": [1128, 56], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_imJ", "code": "@[simp] theorem star_imJ : (star a).imJ = -a.imJ", "start": [1131, 1], "end": [1131, 56], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_imK", "code": "@[simp] theorem star_imK : (star a).imK = -a.imK", "start": [1134, 1], "end": [1134, 56], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_im", "code": "@[simp] theorem star_im : (star a).im = -a.im", "start": [1137, 1], "end": [1137, 59], "kind": "commanddeclaration"}, {"full_name": "Quaternion.self_add_star'", "code": "nonrec theorem self_add_star' : a + star a = \u2191(2 * a.re)", "start": [1140, 1], "end": [1141, 19], "kind": "commanddeclaration"}, {"full_name": "Quaternion.self_add_star", "code": "nonrec theorem self_add_star : a + star a = 2 * a.re", "start": [1144, 1], "end": [1145, 18], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_add_self'", "code": "nonrec theorem star_add_self' : star a + a = \u2191(2 * a.re)", "start": [1148, 1], "end": [1149, 19], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_add_self", "code": "nonrec theorem star_add_self : star a + a = 2 * a.re", "start": [1152, 1], "end": [1153, 18], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_eq_two_re_sub", "code": "nonrec theorem star_eq_two_re_sub : star a = \u2191(2 * a.re) - a", "start": [1156, 1], "end": [1157, 23], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_coe", "code": "@[simp, norm_cast]\ntheorem star_coe : star (x : \u210d[R]) = x", "start": [1160, 1], "end": [1162, 31], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_star", "code": "@[simp]\ntheorem im_star : star a.im = -a.im", "start": [1165, 1], "end": [1167, 30], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_smul", "code": "@[simp]\ntheorem star_smul [Monoid S] [DistribMulAction S R] (s : S) (a : \u210d[R]) :\n    star (s \u2022 a) = s \u2022 star a", "start": [1170, 1], "end": [1173, 34], "kind": "commanddeclaration"}, {"full_name": "Quaternion.eq_re_of_eq_coe", "code": "theorem eq_re_of_eq_coe {a : \u210d[R]} {x : R} (h : a = x) : a = a.re", "start": [1176, 1], "end": [1177, 38], "kind": "commanddeclaration"}, {"full_name": "Quaternion.eq_re_iff_mem_range_coe", "code": "theorem eq_re_iff_mem_range_coe {a : \u210d[R]} : a = a.re \u2194 a \u2208 Set.range (coe : R \u2192 \u210d[R])", "start": [1180, 1], "end": [1181, 44], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_eq_self", "code": "@[simp]\ntheorem star_eq_self {a : \u210d[R]} : star a = a \u2194 a = a.re", "start": [1188, 1], "end": [1190, 33], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_eq_neg", "code": "@[simp]\ntheorem star_eq_neg {a : \u210d[R]} : star a = -a \u2194 a.re = 0", "start": [1193, 1], "end": [1195, 32], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_mul_eq_coe", "code": "nonrec theorem star_mul_eq_coe : star a * a = (star a * a).re", "start": [1200, 1], "end": [1201, 20], "kind": "commanddeclaration"}, {"full_name": "Quaternion.mul_star_eq_coe", "code": "nonrec theorem mul_star_eq_coe : a * star a = (a * star a).re", "start": [1204, 1], "end": [1205, 20], "kind": "commanddeclaration"}, {"full_name": "Quaternion.starAe", "code": "def starAe : \u210d[R] \u2243\u2090[R] \u210d[R]\u1d50\u1d52\u1d56 :=\n  QuaternionAlgebra.starAe", "start": [1210, 1], "end": [1212, 27], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_starAe", "code": "@[simp]\ntheorem coe_starAe : \u21d1(starAe : \u210d[R] \u2243\u2090[R] \u210d[R]\u1d50\u1d52\u1d56) = op \u2218 star", "start": [1215, 1], "end": [1217, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq", "code": "def normSq : \u210d[R] \u2192*\u2080 R where\n  toFun a := (a * star a).re\n  map_zero' := by simp only [star_zero, zero_mul, zero_re]\n  map_one' := by simp only [star_one, one_mul, one_re]\n  map_mul' x y := coe_injective <| by\n    conv_lhs => rw [\u2190 mul_star_eq_coe, star_mul, mul_assoc, \u2190 mul_assoc y, y.mul_star_eq_coe,\n      coe_commutes, \u2190 mul_assoc, x.mul_star_eq_coe, \u2190 coe_mul]", "start": [1220, 1], "end": [1227, 63], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_def", "code": "theorem normSq_def : normSq a = (a * star a).re", "start": [1230, 1], "end": [1230, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_def'", "code": "theorem normSq_def' : normSq a = a.1 ^ 2 + a.2 ^ 2 + a.3 ^ 2 + a.4 ^ 2", "start": [1233, 1], "end": [1235, 14], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_coe", "code": "theorem normSq_coe : normSq (x : \u210d[R]) = x ^ 2", "start": [1238, 1], "end": [1239, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_star", "code": "@[simp]\ntheorem normSq_star : normSq (star a) = normSq a", "start": [1242, 1], "end": [1243, 74], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_nat_cast", "code": "@[norm_cast]\ntheorem normSq_nat_cast (n : \u2115) : normSq (n : \u210d[R]) = (n : R) ^ 2", "start": [1246, 1], "end": [1248, 34], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_int_cast", "code": "@[norm_cast]\ntheorem normSq_int_cast (z : \u2124) : normSq (z : \u210d[R]) = (z : R) ^ 2", "start": [1251, 1], "end": [1253, 34], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_neg", "code": "@[simp]\ntheorem normSq_neg : normSq (-a) = normSq a", "start": [1256, 1], "end": [1257, 96], "kind": "commanddeclaration"}, {"full_name": "Quaternion.self_mul_star", "code": "theorem self_mul_star : a * star a = normSq a", "start": [1260, 1], "end": [1260, 85], "kind": "commanddeclaration"}, {"full_name": "Quaternion.star_mul_self", "code": "theorem star_mul_self : star a * a = normSq a", "start": [1263, 1], "end": [1263, 87], "kind": "commanddeclaration"}, {"full_name": "Quaternion.im_sq", "code": "theorem im_sq : a.im ^ 2 = -normSq a.im", "start": [1266, 1], "end": [1267, 59], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_normSq_add", "code": "theorem coe_normSq_add : (normSq (a + b) : \u210d[R]) = normSq a + a * star b + b * star a + normSq b", "start": [1270, 1], "end": [1271, 87], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_smul", "code": "theorem normSq_smul (r : R) (q : \u210d[R]) : normSq (r \u2022 q) = r ^ 2 * normSq q", "start": [1274, 1], "end": [1275, 96], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_add", "code": "theorem normSq_add (a b : \u210d[R]) : normSq (a + b) = normSq a + normSq b + 2 * (a * star b).re", "start": [1278, 1], "end": [1284, 65], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_eq_zero", "code": "@[simp]\ntheorem normSq_eq_zero : normSq a = 0 \u2194 a = 0", "start": [1297, 1], "end": [1302, 48], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_ne_zero", "code": "theorem normSq_ne_zero : normSq a \u2260 0 \u2194 a \u2260 0", "start": [1305, 1], "end": [1305, 68], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_nonneg", "code": "@[simp]\ntheorem normSq_nonneg : 0 \u2264 normSq a", "start": [1308, 1], "end": [1311, 38], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_le_zero", "code": "@[simp]\ntheorem normSq_le_zero : normSq a \u2264 0 \u2194 a = 0", "start": [1314, 1], "end": [1316, 47], "kind": "commanddeclaration"}, {"full_name": "Quaternion.instNontrivial", "code": "instance instNontrivial : Nontrivial \u210d[R] where\n  exists_pair_ne := \u27e80, 1, mt (congr_arg re) zero_ne_one\u27e9", "start": [1319, 1], "end": [1320, 58], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sq_eq_normSq", "code": "theorem sq_eq_normSq : a ^ 2 = normSq a \u2194 a = a.re", "start": [1329, 1], "end": [1331, 58], "kind": "commanddeclaration"}, {"full_name": "Quaternion.sq_eq_neg_normSq", "code": "theorem sq_eq_neg_normSq : a ^ 2 = -normSq a \u2194 a.re = 0", "start": [1334, 1], "end": [1338, 96], "kind": "commanddeclaration"}, {"full_name": "Quaternion.instInv", "code": "@[simps (config := { isSimp := false })]\ninstance instInv : Inv \u210d[R] :=\n  \u27e8fun a => (normSq a)\u207b\u00b9 \u2022 star a\u27e9", "start": [1347, 1], "end": [1349, 35], "kind": "commanddeclaration"}, {"full_name": "Quaternion.instGroupWithZero", "code": "instance instGroupWithZero : GroupWithZero \u210d[R] :=\n  { Quaternion.instNontrivial,\n    (by infer_instance : MonoidWithZero \u210d[R]) with\n    inv := Inv.inv\n    inv_zero := by rw [instInv_inv, star_zero, smul_zero]\n    mul_inv_cancel := fun a ha => by\n      letI : Semiring \u210d[R] := inferInstanceAs (Semiring \u210d[R,-1,-1])\n      rw [instInv_inv, Algebra.mul_smul_comm (normSq a)\u207b\u00b9 a (star a), self_mul_star, smul_coe,\n        inv_mul_cancel (normSq_ne_zero.2 ha), coe_one] }", "start": [1351, 1], "end": [1360, 57], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_inv", "code": "@[norm_cast, simp]\ntheorem coe_inv (x : R) : ((x\u207b\u00b9 : R) : \u210d[R]) = (\u2191x)\u207b\u00b9", "start": [1362, 1], "end": [1364, 33], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_div", "code": "@[norm_cast, simp]\ntheorem coe_div (x y : R) : ((x / y : R) : \u210d[R]) = x / y", "start": [1367, 1], "end": [1369, 35], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_zpow", "code": "@[norm_cast, simp]\ntheorem coe_zpow (x : R) (z : \u2124) : ((x ^ z : R) : \u210d[R]) = (x : \u210d[R]) ^ z", "start": [1372, 1], "end": [1374, 36], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rat_cast_re", "code": "@[simp, norm_cast]\ntheorem rat_cast_re (q : \u211a) : (q : \u210d[R]).re = q", "start": [1381, 1], "end": [1383, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rat_cast_imI", "code": "@[simp, norm_cast]\ntheorem rat_cast_imI (q : \u211a) : (q : \u210d[R]).imI = 0", "start": [1386, 1], "end": [1388, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rat_cast_imJ", "code": "@[simp, norm_cast]\ntheorem rat_cast_imJ (q : \u211a) : (q : \u210d[R]).imJ = 0", "start": [1391, 1], "end": [1393, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rat_cast_imK", "code": "@[simp, norm_cast]\ntheorem rat_cast_imK (q : \u211a) : (q : \u210d[R]).imK = 0", "start": [1396, 1], "end": [1398, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.rat_cast_im", "code": "@[simp, norm_cast]\ntheorem rat_cast_im (q : \u211a) : (q : \u210d[R]).im = 0", "start": [1401, 1], "end": [1403, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_rat_cast", "code": "@[norm_cast]\ntheorem coe_rat_cast (q : \u211a) : \u2191(q : R) = (q : \u210d[R])", "start": [1406, 1], "end": [1408, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_inv", "code": "theorem normSq_inv : normSq a\u207b\u00b9 = (normSq a)\u207b\u00b9", "start": [1423, 1], "end": [1424, 20], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_div", "code": "theorem normSq_div : normSq (a / b) = normSq a / normSq b", "start": [1428, 1], "end": [1429, 22], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_zpow", "code": "theorem normSq_zpow (z : \u2124) : normSq (a ^ z) = normSq a ^ z", "start": [1433, 1], "end": [1434, 23], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_rat_cast", "code": "@[norm_cast]\ntheorem normSq_rat_cast (q : \u211a) : normSq (q : \u210d[R]) = (q : \u210d[R]) ^ 2", "start": [1437, 1], "end": [1439, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.pow_four", "code": "private theorem pow_four [Infinite R] : #R ^\u2115 4 = #R", "start": [1456, 1], "end": [1457, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quaternionAlgebra", "code": "theorem mk_quaternionAlgebra : #(\u210d[R,c\u2081,c\u2082]) = #R ^\u2115 4", "start": [1459, 1], "end": [1463, 7], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quaternionAlgebra_of_infinite", "code": "@[simp]\ntheorem mk_quaternionAlgebra_of_infinite [Infinite R] : #(\u210d[R,c\u2081,c\u2082]) = #R", "start": [1466, 1], "end": [1468, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ_quaternionAlgebra", "code": "theorem mk_univ_quaternionAlgebra : #(Set.univ : Set \u210d[R,c\u2081,c\u2082]) = #R ^\u2115 4", "start": [1471, 1], "end": [1473, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ_quaternionAlgebra_of_infinite", "code": "theorem mk_univ_quaternionAlgebra_of_infinite [Infinite R] :\n    #(Set.univ : Set \u210d[R,c\u2081,c\u2082]) = #R", "start": [1477, 1], "end": [1478, 85], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quaternion", "code": "@[simp]\ntheorem mk_quaternion : #(\u210d[R]) = #R ^\u2115 4", "start": [1487, 1], "end": [1490, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quaternion_of_infinite", "code": "theorem mk_quaternion_of_infinite [Infinite R] : #(\u210d[R]) = #R", "start": [1494, 1], "end": [1495, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ_quaternion", "code": "theorem mk_univ_quaternion : #(Set.univ : Set \u210d[R]) = #R ^\u2115 4", "start": [1498, 1], "end": [1501, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ_quaternion_of_infinite", "code": "theorem mk_univ_quaternion_of_infinite [Infinite R] : #(Set.univ : Set \u210d[R]) = #R", "start": [1505, 1], "end": [1506, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Combinatorics/SimpleGraph/Subgraph.lean", "Mathlib/Data/List/Rotate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.Walk", "code": "inductive Walk : V \u2192 V \u2192 Type u\n  | nil {u : V} : Walk u u\n  | cons {u v w : V} (h : G.Adj u v) (p : Walk v w) : Walk u w\n  deriving DecidableEq", "start": [83, 1], "end": [94, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.instInhabited", "code": "@[simps]\ninstance Walk.instInhabited (v : V) : Inhabited (G.Walk v v) := \u27e8Walk.nil\u27e9", "start": [99, 1], "end": [100, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Adj.toWalk", "code": "@[match_pattern, reducible]\ndef Adj.toWalk {G : SimpleGraph V} {u v : V} (h : G.Adj u v) : G.Walk u v :=\n  Walk.cons h Walk.nil", "start": [103, 1], "end": [106, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.nil'", "code": "@[match_pattern]\nabbrev nil' (u : V) : G.Walk u u := Walk.nil", "start": [113, 1], "end": [115, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons'", "code": "@[match_pattern]\nabbrev cons' (u v w : V) (h : G.Adj u v) (p : G.Walk v w) : G.Walk u w := Walk.cons h p", "start": [118, 1], "end": [120, 88], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.copy", "code": "protected def copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') : G.Walk u' v' :=\n  hu \u25b8 hv \u25b8 p", "start": [123, 1], "end": [130, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.copy_rfl_rfl", "code": "@[simp]\ntheorem copy_rfl_rfl {u v} (p : G.Walk u v) : p.copy rfl rfl = p", "start": [133, 1], "end": [134, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.copy_copy", "code": "@[simp]\ntheorem copy_copy {u v u' v' u'' v''} (p : G.Walk u v)\n    (hu : u = u') (hv : v = v') (hu' : u' = u'') (hv' : v' = v'') :\n    (p.copy hu hv).copy hu' hv' = p.copy (hu.trans hu') (hv.trans hv')", "start": [137, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.copy_nil", "code": "@[simp]\ntheorem copy_nil {u u'} (hu : u = u') : (Walk.nil : G.Walk u u).copy hu hu = Walk.nil", "start": [145, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.copy_cons", "code": "theorem copy_cons {u v w u' w'} (h : G.Adj u v) (p : G.Walk v w) (hu : u = u') (hw : w = w') :\n    (Walk.cons h p).copy hu hw = Walk.cons (hu \u25b8 h) (p.copy rfl hw)", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_copy", "code": "@[simp]\ntheorem cons_copy {u v w v' w'} (h : G.Adj u v) (p : G.Walk v' w') (hv : v' = v) (hw : w' = w) :\n    Walk.cons h (p.copy hv hw) = (Walk.cons (hv \u25b8 h) p).copy rfl hw", "start": [157, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.exists_eq_cons_of_ne", "code": "theorem exists_eq_cons_of_ne {u v : V} (hne : u \u2260 v) :\n    \u2200 (p : G.Walk u v), \u2203 (w : V) (h : G.Adj u w) (p' : G.Walk w v), p = cons h p'", "start": [164, 1], "end": [167, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length", "code": "def length {u v : V} : G.Walk u v \u2192 \u2115\n  | nil => 0\n  | cons _ q => q.length.succ", "start": [170, 1], "end": [173, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append", "code": "@[trans]\ndef append {u v w : V} : G.Walk u v \u2192 G.Walk v w \u2192 G.Walk u w\n  | nil, q => q\n  | cons h p, q => cons h (p.append q)", "start": [176, 1], "end": [180, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat", "code": "def concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) : G.Walk u w := p.append (cons h nil)", "start": [183, 1], "end": [185, 94], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_eq_append", "code": "theorem concat_eq_append {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    p.concat h = p.append (cons h nil)", "start": [188, 1], "end": [189, 46], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverseAux", "code": "protected def reverseAux {u v w : V} : G.Walk u v \u2192 G.Walk u w \u2192 G.Walk v w\n  | nil, q => q\n  | cons h p, q => Walk.reverseAux p (cons (G.symm h) q)", "start": [192, 1], "end": [195, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse", "code": "@[symm]\ndef reverse {u v : V} (w : G.Walk u v) : G.Walk v u := w.reverseAux nil", "start": [198, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.getVert", "code": "def getVert {u v : V} : G.Walk u v \u2192 \u2115 \u2192 V\n  | nil, _ => u\n  | cons _ _, 0 => u\n  | cons _ q, n + 1 => q.getVert n", "start": [203, 1], "end": [209, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.getVert_zero", "code": "@[simp]\ntheorem getVert_zero {u v} (w : G.Walk u v) : w.getVert 0 = u", "start": [212, 1], "end": [213, 84], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.getVert_of_length_le", "code": "theorem getVert_of_length_le {u v} (w : G.Walk u v) {i : \u2115} (hi : w.length \u2264 i) :\n    w.getVert i = v", "start": [216, 1], "end": [223, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.getVert_length", "code": "@[simp]\ntheorem getVert_length {u v} (w : G.Walk u v) : w.getVert w.length = v", "start": [226, 1], "end": [228, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.adj_getVert_succ", "code": "theorem adj_getVert_succ {u v} (w : G.Walk u v) {i : \u2115} (hi : i < w.length) :\n    G.Adj (w.getVert i) (w.getVert (i + 1))", "start": [231, 1], "end": [238, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_append", "code": "@[simp]\ntheorem cons_append {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (q : G.Walk w x) :\n    (cons h p).append q = cons h (p.append q)", "start": [241, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_nil_append", "code": "@[simp]\ntheorem cons_nil_append {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h nil).append p = cons h p", "start": [246, 1], "end": [248, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append_nil", "code": "@[simp]\ntheorem append_nil {u v : V} (p : G.Walk u v) : p.append nil = p", "start": [251, 1], "end": [255, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.nil_append", "code": "@[simp]\ntheorem nil_append {u v : V} (p : G.Walk u v) : nil.append p = p", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append_assoc", "code": "theorem append_assoc {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk w x) :\n    p.append (q.append r) = (p.append q).append r", "start": [263, 1], "end": [269, 12], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append_copy_copy", "code": "@[simp]\ntheorem append_copy_copy {u v w u' v' w'} (p : G.Walk u v) (q : G.Walk v w)\n    (hu : u = u') (hv : v = v') (hw : w = w') :\n    (p.copy hu hv).append (q.copy hv hw) = (p.append q).copy hu hw", "start": [272, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_nil", "code": "theorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil", "start": [280, 1], "end": [280, 80], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_cons", "code": "@[simp]\ntheorem concat_cons {u v w x : V} (h : G.Adj u v) (p : G.Walk v w) (h' : G.Adj w x) :\n    (cons h p).concat h' = cons h (p.concat h')", "start": [283, 1], "end": [285, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append_concat", "code": "theorem append_concat {u v w x : V} (p : G.Walk u v) (q : G.Walk v w) (h : G.Adj w x) :\n    p.append (q.concat h) = (p.append q).concat h", "start": [288, 1], "end": [289, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_append", "code": "theorem concat_append {u v w x : V} (p : G.Walk u v) (h : G.Adj v w) (q : G.Walk w x) :\n    (p.concat h).append q = p.append (cons h q)", "start": [292, 1], "end": [294, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.exists_cons_eq_concat", "code": "theorem exists_cons_eq_concat {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    \u2203 (x : V) (q : G.Walk u x) (h' : G.Adj x w), cons h p = q.concat h'", "start": [297, 1], "end": [305, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.exists_concat_eq_cons", "code": "theorem exists_concat_eq_cons {u v w : V} :\n    \u2200 (p : G.Walk u v) (h : G.Adj v w),\n      \u2203 (x : V) (h' : G.Adj u x) (q : G.Walk x w), p.concat h = cons h' q", "start": [308, 1], "end": [313, 64], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_nil", "code": "@[simp]\ntheorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil", "start": [316, 1], "end": [317, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_singleton", "code": "theorem reverse_singleton {u v : V} (h : G.Adj u v) : (cons h nil).reverse = cons (G.symm h) nil", "start": [320, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_reverseAux", "code": "@[simp]\ntheorem cons_reverseAux {u v w x : V} (p : G.Walk u v) (q : G.Walk w x) (h : G.Adj w u) :\n    (cons h p).reverseAux q = p.reverseAux (cons (G.symm h) q)", "start": [324, 1], "end": [326, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.append_reverseAux", "code": "@[simp]\nprotected theorem append_reverseAux {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk v w) (r : G.Walk u x) :\n    (p.append q).reverseAux r = q.reverseAux (p.reverseAux r)", "start": [329, 1], "end": [335, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverseAux_append", "code": "@[simp]\nprotected theorem reverseAux_append {u v w x : V}\n    (p : G.Walk u v) (q : G.Walk u w) (r : G.Walk w x) :\n    (p.reverseAux q).append r = p.reverseAux (q.append r)", "start": [338, 1], "end": [344, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverseAux_eq_reverse_append", "code": "protected theorem reverseAux_eq_reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    p.reverseAux q = p.reverse.append q", "start": [347, 1], "end": [348, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_cons", "code": "@[simp]\ntheorem reverse_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).reverse = p.reverse.append (cons (G.symm h) nil)", "start": [351, 1], "end": [353, 85], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_copy", "code": "@[simp]\ntheorem reverse_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).reverse = p.reverse.copy hv hu", "start": [356, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_append", "code": "@[simp]\ntheorem reverse_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).reverse = q.reverse.append p.reverse", "start": [363, 1], "end": [365, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_concat", "code": "@[simp]\ntheorem reverse_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).reverse = cons (G.symm h) p.reverse", "start": [368, 1], "end": [370, 83], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_reverse", "code": "@[simp]\ntheorem reverse_reverse {u v : V} (p : G.Walk u v) : p.reverse.reverse = p", "start": [373, 1], "end": [377, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_nil", "code": "@[simp]\ntheorem length_nil {u : V} : (nil : G.Walk u u).length = 0", "start": [380, 1], "end": [381, 66], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_cons", "code": "@[simp]\ntheorem length_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).length = p.length + 1", "start": [384, 1], "end": [386, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_copy", "code": "@[simp]\ntheorem length_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).length = p.length", "start": [389, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_append", "code": "@[simp]\ntheorem length_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).length = p.length + q.length", "start": [396, 1], "end": [401, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_concat", "code": "@[simp]\ntheorem length_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).length = p.length + 1", "start": [404, 1], "end": [406, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_reverseAux", "code": "@[simp]\nprotected theorem length_reverseAux {u v w : V} (p : G.Walk u v) (q : G.Walk u w) :\n    (p.reverseAux q).length = p.length + q.length", "start": [409, 1], "end": [414, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_reverse", "code": "@[simp]\ntheorem length_reverse {u v : V} (p : G.Walk u v) : p.reverse.length = p.length", "start": [417, 1], "end": [418, 101], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.eq_of_length_eq_zero", "code": "theorem eq_of_length_eq_zero {u v : V} : \u2200 {p : G.Walk u v}, p.length = 0 \u2192 u = v", "start": [421, 1], "end": [422, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.exists_length_eq_zero_iff", "code": "@[simp]\ntheorem exists_length_eq_zero_iff {u v : V} : (\u2203 p : G.Walk u v, p.length = 0) \u2194 u = v", "start": [425, 1], "end": [431, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_eq_zero_iff", "code": "@[simp]\ntheorem length_eq_zero_iff {u : V} {p : G.Walk u u} : p.length = 0 \u2194 p = nil", "start": [434, 1], "end": [435, 100], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concatRecAux", "code": "def concatRecAux {u v : V} : (p : G.Walk u v) \u2192 motive v u p.reverse\n  | nil => Hnil\n  | cons h p => reverse_cons h p \u25b8 Hconcat p.reverse h.symm (concatRecAux p)", "start": [443, 1], "end": [446, 77], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concatRec", "code": "@[elab_as_elim]\ndef concatRec {u v : V} (p : G.Walk u v) : motive u v p :=\n  reverse_reverse p \u25b8 concatRecAux @Hnil @Hconcat p.reverse", "start": [449, 1], "end": [455, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concatRec_nil", "code": "@[simp]\ntheorem concatRec_nil (u : V) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (nil : G.Walk u u) = Hnil", "start": [458, 1], "end": [460, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concatRec_concat", "code": "@[simp]\ntheorem concatRec_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    @concatRec _ _ motive @Hnil @Hconcat _ _ (p.concat h) =\n      Hconcat p h (concatRec @Hnil @Hconcat p)", "start": [463, 1], "end": [474, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_ne_nil", "code": "theorem concat_ne_nil {u v : V} (p : G.Walk u v) (h : G.Adj v u) : p.concat h \u2260 nil", "start": [479, 1], "end": [480, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.concat_inj", "code": "theorem concat_inj {u v v' w : V} {p : G.Walk u v} {h : G.Adj v w} {p' : G.Walk u v'}\n    {h' : G.Adj v' w} (he : p.concat h = p'.concat h') : \u2203 hv : v = v', p.copy rfl hv = p'", "start": [483, 1], "end": [506, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support", "code": "def support {u v : V} : G.Walk u v \u2192 List V\n  | nil => [u]\n  | cons _ p => u :: p.support", "start": [509, 1], "end": [512, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts", "code": "def darts {u v : V} : G.Walk u v \u2192 List G.Dart\n  | nil => []\n  | cons h p => \u27e8(u, _), h\u27e9 :: p.darts", "start": [515, 1], "end": [518, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges", "code": "def edges {u v : V} (p : G.Walk u v) : List (Sym2 V) := p.darts.map Dart.edge", "start": [521, 1], "end": [523, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_nil", "code": "@[simp]\ntheorem support_nil {u : V} : (nil : G.Walk u u).support = [u]", "start": [526, 1], "end": [527, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_cons", "code": "@[simp]\ntheorem support_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).support = u :: p.support", "start": [530, 1], "end": [532, 47], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_concat", "code": "@[simp]\ntheorem support_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).support = p.support.concat w", "start": [535, 1], "end": [538, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_copy", "code": "@[simp]\ntheorem support_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).support = p.support", "start": [541, 1], "end": [545, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_append", "code": "theorem support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support = p.support ++ p'.support.tail", "start": [548, 1], "end": [550, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_reverse", "code": "@[simp]\ntheorem support_reverse {u v : V} (p : G.Walk u v) : p.reverse.support = p.support.reverse", "start": [553, 1], "end": [555, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_ne_nil", "code": "@[simp]\ntheorem support_ne_nil {u v : V} (p : G.Walk u v) : p.support \u2260 []", "start": [558, 1], "end": [559, 90], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.tail_support_append", "code": "theorem tail_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').support.tail = p.support.tail ++ p'.support.tail", "start": [562, 1], "end": [564, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_eq_cons", "code": "theorem support_eq_cons {u v : V} (p : G.Walk u v) : p.support = u :: p.support.tail", "start": [567, 1], "end": [568, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.start_mem_support", "code": "@[simp]\ntheorem start_mem_support {u v : V} (p : G.Walk u v) : u \u2208 p.support", "start": [571, 1], "end": [572, 92], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.end_mem_support", "code": "@[simp]\ntheorem end_mem_support {u v : V} (p : G.Walk u v) : v \u2208 p.support", "start": [575, 1], "end": [576, 98], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_nonempty", "code": "@[simp]\ntheorem support_nonempty {u v : V} (p : G.Walk u v) : { w | w \u2208 p.support }.Nonempty", "start": [579, 1], "end": [581, 15], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_support_iff", "code": "theorem mem_support_iff {u v w : V} (p : G.Walk u v) : w \u2208 p.support \u2194 w = u \u2228 w \u2208 p.support.tail", "start": [584, 1], "end": [585, 22], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_support_nil_iff", "code": "theorem mem_support_nil_iff {u v : V} : u \u2208 (nil : G.Walk v v).support \u2194 u = v", "start": [588, 1], "end": [588, 90], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_tail_support_append_iff", "code": "@[simp]\ntheorem mem_tail_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t \u2208 (p.append p').support.tail \u2194 t \u2208 p.support.tail \u2228 t \u2208 p'.support.tail", "start": [591, 1], "end": [594, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.end_mem_tail_support_of_ne", "code": "@[simp]\ntheorem end_mem_tail_support_of_ne {u v : V} (h : u \u2260 v) (p : G.Walk u v) : v \u2208 p.support.tail", "start": [597, 1], "end": [600, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_support_append_iff", "code": "@[simp, nolint unusedHavesSuffices]\ntheorem mem_support_append_iff {t u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    t \u2208 (p.append p').support \u2194 t \u2208 p.support \u2228 t \u2208 p'.support", "start": [603, 1], "end": [609, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.subset_support_append_left", "code": "@[simp]\ntheorem subset_support_append_left {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : p.support \u2286 (p.append q).support", "start": [612, 1], "end": [615, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.subset_support_append_right", "code": "@[simp]\ntheorem subset_support_append_right {V : Type u} {G : SimpleGraph V} {u v w : V}\n    (p : G.Walk u v) (q : G.Walk v w) : q.support \u2286 (p.append q).support", "start": [618, 1], "end": [622, 99], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.coe_support", "code": "theorem coe_support {u v : V} (p : G.Walk u v) : (p.support : Multiset V) = {u} + p.support.tail", "start": [625, 1], "end": [626, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.coe_support_append", "code": "theorem coe_support_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = {u} + p.support.tail + p'.support.tail", "start": [629, 1], "end": [631, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.coe_support_append'", "code": "theorem coe_support_append' [DecidableEq V] {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    ((p.append p').support : Multiset V) = p.support + p'.support - {v}", "start": [634, 1], "end": [639, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.chain_adj_support", "code": "theorem chain_adj_support {u v w : V} (h : G.Adj u v) :\n    \u2200 (p : G.Walk v w), List.Chain G.Adj u p.support", "start": [642, 1], "end": [645, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.chain'_adj_support", "code": "theorem chain'_adj_support {u v : V} : \u2200 (p : G.Walk u v), List.Chain' G.Adj p.support", "start": [648, 1], "end": [650, 38], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.chain_dartAdj_darts", "code": "theorem chain_dartAdj_darts {d : G.Dart} {v w : V} (h : d.snd = v) (p : G.Walk v w) :\n    List.Chain G.DartAdj d p.darts", "start": [653, 1], "end": [658, 69], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.chain'_dartAdj_darts", "code": "theorem chain'_dartAdj_darts {u v : V} : \u2200 (p : G.Walk u v), List.Chain' G.DartAdj p.darts", "start": [661, 1], "end": [664, 47], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_subset_edgeSet", "code": "theorem edges_subset_edgeSet {u v : V} :\n    \u2200 (p : G.Walk u v) \u2983e : Sym2 V\u2984, e \u2208 p.edges \u2192 e \u2208 G.edgeSet", "start": [667, 1], "end": [674, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.adj_of_mem_edges", "code": "theorem adj_of_mem_edges {u v x y : V} (p : G.Walk u v) (h : \u27e6(x, y)\u27e7 \u2208 p.edges) : G.Adj x y", "start": [677, 1], "end": [678, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_nil", "code": "@[simp]\ntheorem darts_nil {u : V} : (nil : G.Walk u u).darts = []", "start": [681, 1], "end": [682, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_cons", "code": "@[simp]\ntheorem darts_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).darts = \u27e8(u, v), h\u27e9 :: p.darts", "start": [685, 1], "end": [687, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_concat", "code": "@[simp]\ntheorem darts_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).darts = p.darts.concat \u27e8(v, w), h\u27e9", "start": [690, 1], "end": [693, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_copy", "code": "@[simp]\ntheorem darts_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).darts = p.darts", "start": [696, 1], "end": [700, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_append", "code": "@[simp]\ntheorem darts_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').darts = p.darts ++ p'.darts", "start": [703, 1], "end": [706, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_reverse", "code": "@[simp]\ntheorem darts_reverse {u v : V} (p : G.Walk u v) :\n    p.reverse.darts = (p.darts.map Dart.symm).reverse", "start": [709, 1], "end": [712, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_darts_reverse", "code": "theorem mem_darts_reverse {u v : V} {d : G.Dart} {p : G.Walk u v} :\n    d \u2208 p.reverse.darts \u2194 d.symm \u2208 p.darts", "start": [715, 1], "end": [716, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_map_snd_darts", "code": "theorem cons_map_snd_darts {u v : V} (p : G.Walk u v) : (u :: p.darts.map (\u00b7.snd)) = p.support", "start": [719, 1], "end": [720, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_snd_darts", "code": "theorem map_snd_darts {u v : V} (p : G.Walk u v) : p.darts.map (\u00b7.snd) = p.support.tail", "start": [723, 1], "end": [724, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_fst_darts_append", "code": "theorem map_fst_darts_append {u v : V} (p : G.Walk u v) :\n    p.darts.map (\u00b7.fst) ++ [v] = p.support", "start": [727, 1], "end": [729, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_fst_darts", "code": "theorem map_fst_darts {u v : V} (p : G.Walk u v) : p.darts.map (\u00b7.fst) = p.support.dropLast", "start": [732, 1], "end": [733, 64], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_nil", "code": "@[simp]\ntheorem edges_nil {u : V} : (nil : G.Walk u u).edges = []", "start": [736, 1], "end": [737, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_cons", "code": "@[simp]\ntheorem edges_cons {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).edges = \u27e6(u, v)\u27e7 :: p.edges", "start": [740, 1], "end": [742, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_concat", "code": "@[simp]\ntheorem edges_concat {u v w : V} (p : G.Walk u v) (h : G.Adj v w) :\n    (p.concat h).edges = p.edges.concat \u27e6(v, w)\u27e7", "start": [745, 1], "end": [747, 68], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_copy", "code": "@[simp]\ntheorem edges_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).edges = p.edges", "start": [750, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_append", "code": "@[simp]\ntheorem edges_append {u v w : V} (p : G.Walk u v) (p' : G.Walk v w) :\n    (p.append p').edges = p.edges ++ p'.edges", "start": [757, 1], "end": [759, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_reverse", "code": "@[simp]\ntheorem edges_reverse {u v : V} (p : G.Walk u v) : p.reverse.edges = p.edges.reverse", "start": [762, 1], "end": [764, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_support", "code": "@[simp]\ntheorem length_support {u v : V} (p : G.Walk u v) : p.support.length = p.length + 1", "start": [767, 1], "end": [769, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_darts", "code": "@[simp]\ntheorem length_darts {u v : V} (p : G.Walk u v) : p.darts.length = p.length", "start": [772, 1], "end": [774, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_edges", "code": "@[simp]\ntheorem length_edges {u v : V} (p : G.Walk u v) : p.edges.length = p.length", "start": [777, 1], "end": [778, 95], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.dart_fst_mem_support_of_mem_darts", "code": "theorem dart_fst_mem_support_of_mem_darts {u v : V} :\n    \u2200 (p : G.Walk u v) {d : G.Dart}, d \u2208 p.darts \u2192 d.fst \u2208 p.support", "start": [781, 1], "end": [787, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.dart_snd_mem_support_of_mem_darts", "code": "theorem dart_snd_mem_support_of_mem_darts {u v : V} (p : G.Walk u v) {d : G.Dart}\n    (h : d \u2208 p.darts) : d.snd \u2208 p.support", "start": [790, 1], "end": [792, 99], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.fst_mem_support_of_mem_edges", "code": "theorem fst_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : \u27e6(t, u)\u27e7 \u2208 p.edges) :\n    t \u2208 p.support", "start": [795, 1], "end": [801, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.snd_mem_support_of_mem_edges", "code": "theorem snd_mem_support_of_mem_edges {t u v w : V} (p : G.Walk v w) (he : \u27e6(t, u)\u27e7 \u2208 p.edges) :\n    u \u2208 p.support", "start": [804, 1], "end": [807, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_nodup_of_support_nodup", "code": "theorem darts_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.darts.Nodup", "start": [810, 1], "end": [816, 76], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_nodup_of_support_nodup", "code": "theorem edges_nodup_of_support_nodup {u v : V} {p : G.Walk u v} (h : p.support.Nodup) :\n    p.edges.Nodup", "start": [819, 1], "end": [825, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.Nil", "code": "inductive Nil : {v w : V} \u2192 G.Walk v w \u2192 Prop\n  | nil {u : V} : Nil (nil : G.Walk u u)", "start": [828, 1], "end": [833, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.nil_nil", "code": "@[simp] lemma nil_nil : (nil : G.Walk u u).Nil := Nil.nil", "start": [835, 1], "end": [835, 58], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.not_nil_cons", "code": "@[simp] lemma not_nil_cons {h : G.Adj u v} {p : G.Walk v w} : \u00ac (cons h p).Nil := fun.", "start": [837, 1], "end": [837, 87], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.Nil.eq", "code": "protected lemma Nil.eq {p : G.Walk v w} : p.Nil \u2192 v = w | .nil => rfl", "start": [844, 1], "end": [844, 70], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.not_nil_of_ne", "code": "lemma not_nil_of_ne {p : G.Walk v w} : v \u2260 w \u2192 \u00ac p.Nil := mt Nil.eq", "start": [846, 1], "end": [846, 68], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.nil_iff_support_eq", "code": "lemma nil_iff_support_eq {p : G.Walk v w} : p.Nil \u2194 p.support = [v] := by\n  cases p <;> simp", "start": [848, 1], "end": [849, 19], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.nil_iff_length_eq", "code": "lemma nil_iff_length_eq {p : G.Walk v w} : p.Nil \u2194 p.length = 0 := by\n  cases p <;> simp", "start": [851, 1], "end": [852, 19], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.not_nil_iff", "code": "lemma not_nil_iff {p : G.Walk v w} :\n    \u00ac p.Nil \u2194 \u2203 (u : V) (h : G.Adj v u) (q : G.Walk u w), p = cons h q := by\n  cases p <;> simp [*]", "start": [854, 1], "end": [856, 23], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.notNilRec", "code": "@[elab_as_elim]\ndef notNilRec {motive : {u w : V} \u2192 (p : G.Walk u w) \u2192 (h : \u00ac p.Nil) \u2192 Sort*}\n    (cons : {u v w : V} \u2192 (h : G.Adj u v) \u2192 (q : G.Walk v w) \u2192 motive (cons h q) not_nil_cons)\n    (p : G.Walk u w) : (hp : \u00ac p.Nil) \u2192 motive p hp :=\n  match p with\n  | nil => fun hp => absurd .nil hp\n  | .cons h q => fun _ => cons h q", "start": [858, 1], "end": [864, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.sndOfNotNil", "code": "def sndOfNotNil (p : G.Walk v w) (hp : \u00ac p.Nil) : V :=\n  p.notNilRec (@fun _ u _ _ _ => u) hp", "start": [866, 1], "end": [868, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.adj_sndOfNotNil", "code": "@[simp] lemma adj_sndOfNotNil {p : G.Walk v w} (hp : \u00ac p.Nil) :\n    G.Adj v (p.sndOfNotNil hp) :=\n  p.notNilRec (fun h _ => h) hp", "start": [870, 1], "end": [872, 32], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.tail", "code": "def tail (p : G.Walk x y) (hp : \u00ac p.Nil) : G.Walk (p.sndOfNotNil hp) y :=\n  p.notNilRec (fun _ q => q) hp", "start": [874, 1], "end": [876, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.firstDart", "code": "@[simps]\ndef firstDart (p : G.Walk v w) (hp : \u00ac p.Nil) : G.Dart where\n  fst := v\n  snd := p.sndOfNotNil hp\n  is_adj := p.adj_sndOfNotNil hp", "start": [878, 1], "end": [883, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edge_firstDart", "code": "lemma edge_firstDart (p : G.Walk v w) (hp : \u00ac p.Nil) :\n    (p.firstDart hp).edge = \u27e6(v, p.sndOfNotNil hp)\u27e7 := rfl", "start": [885, 1], "end": [886, 59], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.cons_tail_eq", "code": "@[simp] lemma cons_tail_eq (p : G.Walk x y) (hp : \u00ac p.Nil) :\n    cons (p.adj_sndOfNotNil hp) (p.tail hp) = p :=\n  p.notNilRec (fun _ _ => rfl) hp", "start": [888, 1], "end": [890, 34], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.cons_support_tail", "code": "@[simp] lemma cons_support_tail (p : G.Walk x y) (hp : \u00ac p.Nil) :\n    x :: (p.tail hp).support = p.support := by\n  rw [\u2190 support_cons, cons_tail_eq]", "start": [892, 1], "end": [894, 36], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.length_tail_add_one", "code": "@[simp] lemma length_tail_add_one {p : G.Walk x y} (hp : \u00ac p.Nil) :\n    (p.tail hp).length + 1 = p.length := by\n  rw [\u2190 length_cons, cons_tail_eq]", "start": [896, 1], "end": [898, 35], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.nil_copy", "code": "@[simp] lemma nil_copy {p : G.Walk x y} (hx : x = x') (hy : y = y') :\n    (p.copy hx hy).Nil = p.Nil := by\n  subst_vars; rfl", "start": [900, 1], "end": [902, 18], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.IsTrail", "code": "@[mk_iff isTrail_def]\nstructure IsTrail {u v : V} (p : G.Walk u v) : Prop where\n  edges_nodup : p.edges.Nodup", "start": [906, 1], "end": [909, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath", "code": "structure IsPath {u v : V} (p : G.Walk u v) extends IsTrail p : Prop where\n  support_nodup : p.support.Nodup", "start": [913, 1], "end": [916, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.isTrail", "code": "protected lemma IsPath.isTrail (h : IsPath p) : IsTrail p := h.toIsTrail", "start": [920, 1], "end": [920, 73], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.IsCircuit", "code": "@[mk_iff isCircuit_def]\nstructure IsCircuit {u : V} (p : G.Walk u u) extends IsTrail p : Prop where\n  ne_nil : p \u2260 nil", "start": [923, 1], "end": [926, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCircuit.isTrail", "code": "protected lemma IsCircuit.isTrail (h : IsCircuit p) : IsTrail p := h.toIsTrail", "start": [931, 1], "end": [931, 79], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.IsCycle", "code": "structure IsCycle {u : V} (p : G.Walk u u) extends IsCircuit p : Prop where\n  support_nodup : p.support.tail.Nodup", "start": [934, 1], "end": [937, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.isCircuit", "code": "protected lemma IsCycle.isCircuit (h : IsCycle p) : IsCircuit p := h.toIsCircuit", "start": [941, 1], "end": [941, 81], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.isTrail_copy", "code": "@[simp]\ntheorem isTrail_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsTrail \u2194 p.IsTrail", "start": [944, 1], "end": [948, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.mk'", "code": "theorem IsPath.mk' {u v : V} {p : G.Walk u v} (h : p.support.Nodup) : p.IsPath", "start": [951, 1], "end": [952, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isPath_def", "code": "theorem isPath_def {u v : V} (p : G.Walk u v) : p.IsPath \u2194 p.support.Nodup", "start": [955, 1], "end": [956, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isPath_copy", "code": "@[simp]\ntheorem isPath_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).IsPath \u2194 p.IsPath", "start": [959, 1], "end": [963, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isCircuit_copy", "code": "@[simp]\ntheorem isCircuit_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCircuit \u2194 p.IsCircuit", "start": [966, 1], "end": [970, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isCycle_def", "code": "theorem isCycle_def {u : V} (p : G.Walk u u) :\n    p.IsCycle \u2194 p.IsTrail \u2227 p \u2260 nil \u2227 p.support.tail.Nodup", "start": [973, 1], "end": [975, 74], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isCycle_copy", "code": "@[simp]\ntheorem isCycle_copy {u u'} (p : G.Walk u u) (hu : u = u') :\n    (p.copy hu hu).IsCycle \u2194 p.IsCycle", "start": [978, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.nil", "code": "@[simp]\ntheorem IsTrail.nil {u : V} : (nil : G.Walk u u).IsTrail", "start": [985, 1], "end": [987, 20], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.of_cons", "code": "theorem IsTrail.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsTrail \u2192 p.IsTrail", "start": [990, 1], "end": [991, 60], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_isTrail_iff", "code": "@[simp]\ntheorem cons_isTrail_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsTrail \u2194 p.IsTrail \u2227 \u27e6(u, v)\u27e7 \u2209 p.edges", "start": [994, 1], "end": [996, 91], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.reverse", "code": "theorem IsTrail.reverse {u v : V} (p : G.Walk u v) (h : p.IsTrail) : p.reverse.IsTrail", "start": [999, 1], "end": [1000, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_isTrail_iff", "code": "@[simp]\ntheorem reverse_isTrail_iff {u v : V} (p : G.Walk u v) : p.reverse.IsTrail \u2194 p.IsTrail", "start": [1003, 1], "end": [1008, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.of_append_left", "code": "theorem IsTrail.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : p.IsTrail", "start": [1011, 1], "end": [1014, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.of_append_right", "code": "theorem IsTrail.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsTrail) : q.IsTrail", "start": [1017, 1], "end": [1020, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.count_edges_le_one", "code": "theorem IsTrail.count_edges_le_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    (e : Sym2 V) : p.edges.count e \u2264 1", "start": [1023, 1], "end": [1025, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.count_edges_eq_one", "code": "theorem IsTrail.count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Walk u v} (h : p.IsTrail)\n    {e : Sym2 V} (he : e \u2208 p.edges) : p.edges.count e = 1", "start": [1028, 1], "end": [1030, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.nil", "code": "theorem IsPath.nil {u : V} : (nil : G.Walk u u).IsPath", "start": [1033, 1], "end": [1033, 82], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.of_cons", "code": "theorem IsPath.of_cons {u v w : V} {h : G.Adj u v} {p : G.Walk v w} :\n    (cons h p).IsPath \u2192 p.IsPath", "start": [1036, 1], "end": [1037, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.cons_isPath_iff", "code": "@[simp]\ntheorem cons_isPath_iff {u v w : V} (h : G.Adj u v) (p : G.Walk v w) :\n    (cons h p).IsPath \u2194 p.IsPath \u2227 u \u2209 p.support", "start": [1040, 1], "end": [1043, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.cons", "code": "protected lemma IsPath.cons (hp : p.IsPath) (hu : u \u2209 p.support) {h : G.Adj u v} :\n    (cons h p).IsPath :=\n  (cons_isPath_iff _ _).2 \u27e8hp, hu\u27e9", "start": [1046, 1], "end": [1048, 35], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.isPath_iff_eq_nil", "code": "@[simp]\ntheorem isPath_iff_eq_nil {u : V} (p : G.Walk u u) : p.IsPath \u2194 p = nil", "start": [1050, 1], "end": [1052, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.reverse", "code": "theorem IsPath.reverse {u v : V} {p : G.Walk u v} (h : p.IsPath) : p.reverse.IsPath", "start": [1055, 1], "end": [1056, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.isPath_reverse_iff", "code": "@[simp]\ntheorem isPath_reverse_iff {u v : V} (p : G.Walk u v) : p.reverse.IsPath \u2194 p.IsPath", "start": [1059, 1], "end": [1061, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.of_append_left", "code": "theorem IsPath.of_append_left {u v w : V} {p : G.Walk u v} {q : G.Walk v w} :\n    (p.append q).IsPath \u2192 p.IsPath", "start": [1064, 1], "end": [1067, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.of_append_right", "code": "theorem IsPath.of_append_right {u v w : V} {p : G.Walk u v} {q : G.Walk v w}\n    (h : (p.append q).IsPath) : q.IsPath", "start": [1070, 1], "end": [1074, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.not_of_nil", "code": "@[simp]\ntheorem IsCycle.not_of_nil {u : V} : \u00ac(nil : G.Walk u u).IsCycle", "start": [1077, 1], "end": [1078, 90], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.ne_bot", "code": "lemma IsCycle.ne_bot : \u2200 {p : G.Walk u u}, p.IsCycle \u2192 G \u2260 \u22a5\n  | nil, hp => by cases hp.ne_nil rfl\n  | cons h _, hp => by rintro rfl; exact h", "start": [1081, 1], "end": [1083, 43], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.cons_isCycle_iff", "code": "theorem cons_isCycle_iff {u v : V} (p : G.Walk v u) (h : G.Adj u v) :\n    (Walk.cons h p).IsCycle \u2194 p.IsPath \u2227 \u00ac\u27e6(u, v)\u27e7 \u2208 p.edges", "start": [1085, 1], "end": [1090, 8], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.tail", "code": "lemma IsPath.tail {p : G.Walk u v} (hp : p.IsPath) (hp' : \u00ac p.Nil) : (p.tail hp').IsPath := by\n  rw [Walk.isPath_def] at hp \u22a2\n  rw [\u2190 cons_support_tail _ hp', List.nodup_cons] at hp\n  exact hp.2", "start": [1093, 1], "end": [1096, 13], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.IsPath.length_lt", "code": "theorem IsPath.length_lt [Fintype V] {u v : V} {p : G.Walk u v} (hp : p.IsPath) :\n    p.length < Fintype.card V", "start": [1104, 1], "end": [1107, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.takeUntil", "code": "def takeUntil {v w : V} : \u2200 (p : G.Walk v w) (u : V), u \u2208 p.support \u2192 G.Walk v u\n  | nil, u, h => by rw [mem_support_nil_iff.mp h]\n  | cons r p, u, h =>\n    if hx : v = u then\n      by subst u; exact Walk.nil\n    else\n      cons r (takeUntil p u <| by cases h; exact (hx rfl).elim; assumption)", "start": [1117, 1], "end": [1124, 76], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.dropUntil", "code": "def dropUntil {v w : V} : \u2200 (p : G.Walk v w) (u : V), u \u2208 p.support \u2192 G.Walk u w\n  | nil, u, h => by rw [mem_support_nil_iff.mp h]\n  | cons r p, u, h =>\n    if hx : v = u then by\n      subst u\n      exact cons r p\n    else dropUntil p u <| by cases h; exact (hx rfl).elim; assumption", "start": [1127, 1], "end": [1136, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.take_spec", "code": "@[simp]\ntheorem take_spec {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).append (p.dropUntil u h) = p", "start": [1139, 1], "end": [1151, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_support_iff_exists_append", "code": "theorem mem_support_iff_exists_append {V : Type u} {G : SimpleGraph V} {u v w : V}\n    {p : G.Walk u v} : w \u2208 p.support \u2194 \u2203 (q : G.Walk u w) (r : G.Walk w v), p = q.append r", "start": [1154, 1], "end": [1160, 88], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.count_support_takeUntil_eq_one", "code": "@[simp]\ntheorem count_support_takeUntil_eq_one {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).support.count u = 1", "start": [1163, 1], "end": [1173, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.count_edges_takeUntil_le_one", "code": "theorem count_edges_takeUntil_le_one {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) (x : V) :\n    (p.takeUntil u h).edges.count \u27e6(u, x)\u27e7 \u2264 1", "start": [1176, 1], "end": [1194, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.takeUntil_copy", "code": "@[simp]\ntheorem takeUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).takeUntil u h = (p.takeUntil u (by subst_vars; exact h)).copy hv rfl", "start": [1197, 1], "end": [1202, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.dropUntil_copy", "code": "@[simp]\ntheorem dropUntil_copy {u v w v' w'} (p : G.Walk v w) (hv : v = v') (hw : w = w')\n    (h : u \u2208 (p.copy hv hw).support) :\n    (p.copy hv hw).dropUntil u h = (p.dropUntil u (by subst_vars; exact h)).copy rfl hw", "start": [1205, 1], "end": [1210, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_takeUntil_subset", "code": "theorem support_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).support \u2286 p.support", "start": [1213, 1], "end": [1216, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_dropUntil_subset", "code": "theorem support_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).support \u2286 p.support", "start": [1219, 1], "end": [1222, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_takeUntil_subset", "code": "theorem darts_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).darts \u2286 p.darts", "start": [1225, 1], "end": [1228, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_dropUntil_subset", "code": "theorem darts_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).darts \u2286 p.darts", "start": [1231, 1], "end": [1234, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_takeUntil_subset", "code": "theorem edges_takeUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).edges \u2286 p.edges", "start": [1237, 1], "end": [1239, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_dropUntil_subset", "code": "theorem edges_dropUntil_subset {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).edges \u2286 p.edges", "start": [1242, 1], "end": [1244, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_takeUntil_le", "code": "theorem length_takeUntil_le {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.takeUntil u h).length \u2264 p.length", "start": [1247, 1], "end": [1251, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_dropUntil_le", "code": "theorem length_dropUntil_le {u v w : V} (p : G.Walk v w) (h : u \u2208 p.support) :\n    (p.dropUntil u h).length \u2264 p.length", "start": [1254, 1], "end": [1258, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.takeUntil", "code": "protected theorem IsTrail.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u \u2208 p.support) : (p.takeUntil u h).IsTrail", "start": [1261, 1], "end": [1263, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.dropUntil", "code": "protected theorem IsTrail.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsTrail)\n    (h : u \u2208 p.support) : (p.dropUntil u h).IsTrail", "start": [1266, 1], "end": [1268, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.takeUntil", "code": "protected theorem IsPath.takeUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u \u2208 p.support) : (p.takeUntil u h).IsPath", "start": [1271, 1], "end": [1273, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.dropUntil", "code": "protected theorem IsPath.dropUntil {u v w : V} {p : G.Walk v w} (hc : p.IsPath)\n    (h : u \u2208 p.support) : (p.dropUntil u h).IsPath", "start": [1277, 1], "end": [1279, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.rotate", "code": "def rotate {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) : G.Walk u u :=\n  (c.dropUntil u h).append (c.takeUntil u h)", "start": [1282, 1], "end": [1284, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_rotate", "code": "@[simp]\ntheorem support_rotate {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).support.tail ~r c.support.tail", "start": [1287, 1], "end": [1292, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.rotate_darts", "code": "theorem rotate_darts {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).darts ~r c.darts", "start": [1295, 1], "end": [1299, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.rotate_edges", "code": "theorem rotate_edges {u v : V} (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).edges ~r c.edges", "start": [1302, 1], "end": [1304, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.rotate", "code": "protected theorem IsTrail.rotate {u v : V} {c : G.Walk v v} (hc : c.IsTrail) (h : u \u2208 c.support) :\n    (c.rotate h).IsTrail", "start": [1307, 1], "end": [1310, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCircuit.rotate", "code": "protected theorem IsCircuit.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCircuit)\n    (h : u \u2208 c.support) : (c.rotate h).IsCircuit", "start": [1313, 1], "end": [1321, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.rotate", "code": "protected theorem IsCycle.rotate {u v : V} {c : G.Walk v v} (hc : c.IsCycle) (h : u \u2208 c.support) :\n    (c.rotate h).IsCycle", "start": [1324, 1], "end": [1328, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.exists_boundary_dart", "code": "theorem exists_boundary_dart {u v : V} (p : G.Walk u v) (S : Set V) (uS : u \u2208 S) (vS : v \u2209 S) :\n    \u2203 d : G.Dart, d \u2208 p.darts \u2227 d.fst \u2208 S \u2227 d.snd \u2209 S", "start": [1333, 1], "end": [1342, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path", "code": "abbrev Path (u v : V) := { p : G.Walk u v // p.IsPath }", "start": [1350, 1], "end": [1351, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.isPath", "code": "@[simp]\nprotected theorem isPath {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsPath", "start": [1358, 1], "end": [1359, 92], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.isTrail", "code": "@[simp]\nprotected theorem isTrail {u v : V} (p : G.Path u v) : (p : G.Walk u v).IsTrail", "start": [1362, 1], "end": [1364, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.nil", "code": "@[refl, simps]\nprotected def nil {u : V} : G.Path u u :=\n  \u27e8Walk.nil, Walk.IsPath.nil\u27e9", "start": [1367, 1], "end": [1370, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.singleton", "code": "@[simps]\ndef singleton {u v : V} (h : G.Adj u v) : G.Path u v :=\n  \u27e8Walk.cons h Walk.nil, by simp [h.ne]\u27e9", "start": [1373, 1], "end": [1376, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.mk'_mem_edges_singleton", "code": "theorem mk'_mem_edges_singleton {u v : V} (h : G.Adj u v) :\n    \u27e6(u, v)\u27e7 \u2208 (singleton h : G.Walk u v).edges", "start": [1379, 1], "end": [1380, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.reverse", "code": "@[symm, simps]\ndef reverse {u v : V} (p : G.Path u v) : G.Path v u :=\n  \u27e8Walk.reverse p, p.property.reverse\u27e9", "start": [1383, 1], "end": [1386, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.count_support_eq_one", "code": "theorem count_support_eq_one [DecidableEq V] {u v w : V} {p : G.Path u v}\n    (hw : w \u2208 (p : G.Walk u v).support) : (p : G.Walk u v).support.count w = 1", "start": [1389, 1], "end": [1391, 55], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.count_edges_eq_one", "code": "theorem count_edges_eq_one [DecidableEq V] {u v : V} {p : G.Path u v} (e : Sym2 V)\n    (hw : e \u2208 (p : G.Walk u v).edges) : (p : G.Walk u v).edges.count e = 1", "start": [1394, 1], "end": [1396, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.nodup_support", "code": "@[simp]\ntheorem nodup_support {u v : V} (p : G.Path u v) : (p : G.Walk u v).support.Nodup", "start": [1399, 1], "end": [1401, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.loop_eq", "code": "theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil", "start": [1404, 1], "end": [1407, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.not_mem_edges_of_loop", "code": "theorem not_mem_edges_of_loop {v : V} {e : Sym2 V} {p : G.Path v v} : \u00ace \u2208 (p : G.Walk v v).edges", "start": [1410, 1], "end": [1411, 22], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.cons_isCycle", "code": "theorem cons_isCycle {u v : V} (p : G.Path v u) (h : G.Adj u v)\n    (he : \u00ac\u27e6(u, v)\u27e7 \u2208 (p : G.Walk v u).edges) : (Walk.cons h \u2191p).IsCycle", "start": [1414, 1], "end": [1416, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.bypass", "code": "def bypass {u v : V} : G.Walk u v \u2192 G.Walk u v\n  | nil => nil\n  | cons ha p =>\n    let p' := p.bypass\n    if hs : u \u2208 p'.support then\n      p'.dropUntil u hs\n    else\n      cons ha p'", "start": [1428, 1], "end": [1438, 17], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.bypass_copy", "code": "@[simp]\ntheorem bypass_copy {u v u' v'} (p : G.Walk u v) (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).bypass = p.bypass.copy hu hv", "start": [1441, 1], "end": [1445, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.bypass_isPath", "code": "theorem bypass_isPath {u v : V} (p : G.Walk u v) : p.bypass.IsPath", "start": [1448, 1], "end": [1455, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_bypass_le", "code": "theorem length_bypass_le {u v : V} (p : G.Walk u v) : p.bypass.length \u2264 p.length", "start": [1458, 1], "end": [1469, 34], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toPath", "code": "def toPath {u v : V} (p : G.Walk u v) : G.Path u v :=\n  \u27e8p.bypass, p.bypass_isPath\u27e9", "start": [1472, 1], "end": [1474, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_bypass_subset", "code": "theorem support_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.support \u2286 p.support", "start": [1477, 1], "end": [1488, 17], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_toPath_subset", "code": "theorem support_toPath_subset {u v : V} (p : G.Walk u v) :\n    (p.toPath : G.Walk u v).support \u2286 p.support", "start": [1491, 1], "end": [1493, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_bypass_subset", "code": "theorem darts_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.darts \u2286 p.darts", "start": [1496, 1], "end": [1505, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_bypass_subset", "code": "theorem edges_bypass_subset {u v : V} (p : G.Walk u v) : p.bypass.edges \u2286 p.edges", "start": [1508, 1], "end": [1509, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_toPath_subset", "code": "theorem darts_toPath_subset {u v : V} (p : G.Walk u v) : (p.toPath : G.Walk u v).darts \u2286 p.darts", "start": [1512, 1], "end": [1513, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_toPath_subset", "code": "theorem edges_toPath_subset {u v : V} (p : G.Walk u v) : (p.toPath : G.Walk u v).edges \u2286 p.edges", "start": [1516, 1], "end": [1517, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map", "code": "protected def map (f : G \u2192g G') {u v : V} : G.Walk u v \u2192 G'.Walk (f u) (f v)\n  | nil => nil\n  | cons h p => cons (f.map_adj h) (p.map f)", "start": [1529, 1], "end": [1532, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_nil", "code": "@[simp]\ntheorem map_nil : (nil : G.Walk u u).map f = nil", "start": [1537, 1], "end": [1538, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_cons", "code": "@[simp]\ntheorem map_cons {w : V} (h : G.Adj w u) : (cons h p).map f = cons (f.map_adj h) (p.map f)", "start": [1541, 1], "end": [1542, 98], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_copy", "code": "@[simp]\ntheorem map_copy (hu : u = u') (hv : v = v') :\n    (p.copy hu hv).map f = (p.map f).copy (hu \u25b8 rfl) (hv \u25b8 rfl)", "start": [1545, 1], "end": [1549, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_id", "code": "@[simp]\ntheorem map_id (p : G.Walk u v) : p.map Hom.id = p", "start": [1552, 1], "end": [1556, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_map", "code": "@[simp]\ntheorem map_map : (p.map f).map f' = p.map (f'.comp f)", "start": [1559, 1], "end": [1563, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_eq_of_eq", "code": "theorem map_eq_of_eq {f : G \u2192g G'} (f' : G \u2192g G') (h : f = f') :\n    p.map f = (p.map f').copy (h \u25b8 rfl) (h \u25b8 rfl)", "start": [1566, 1], "end": [1571, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_eq_nil_iff", "code": "@[simp]\ntheorem map_eq_nil_iff {p : G.Walk u u} : p.map f = nil \u2194 p = nil", "start": [1574, 1], "end": [1575, 89], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_map", "code": "@[simp]\ntheorem length_map : (p.map f).length = p.length", "start": [1578, 1], "end": [1579, 80], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_append", "code": "theorem map_append {u v w : V} (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).map f = (p.map f).append (q.map f)", "start": [1582, 1], "end": [1583, 83], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_map", "code": "@[simp]\ntheorem reverse_map : (p.map f).reverse = p.reverse.map f", "start": [1586, 1], "end": [1587, 101], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_map", "code": "@[simp]\ntheorem support_map : (p.map f).support = p.support.map f", "start": [1590, 1], "end": [1591, 89], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.darts_map", "code": "@[simp]\ntheorem darts_map : (p.map f).darts = p.darts.map f.mapDart", "start": [1594, 1], "end": [1595, 91], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_map", "code": "@[simp]\ntheorem edges_map : (p.map f).edges = p.edges.map (Sym2.map f)", "start": [1598, 1], "end": [1604, 20], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_isPath_of_injective", "code": "theorem map_isPath_of_injective (hinj : Function.Injective f) (hp : p.IsPath) :\n    (p.map f).IsPath", "start": [1609, 1], "end": [1619, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.of_map", "code": "protected theorem IsPath.of_map {f : G \u2192g G'} (hp : (p.map f).IsPath) : p.IsPath", "start": [1622, 1], "end": [1631, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_isPath_iff_of_injective", "code": "theorem map_isPath_iff_of_injective (hinj : Function.Injective f) : (p.map f).IsPath \u2194 p.IsPath", "start": [1634, 1], "end": [1635, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_isTrail_iff_of_injective", "code": "theorem map_isTrail_iff_of_injective (hinj : Function.Injective f) :\n    (p.map f).IsTrail \u2194 p.IsTrail", "start": [1638, 1], "end": [1645, 94], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_isTrail_of_injective", "code": "alias \u27e8_, map_isTrail_of_injective\u27e9 := map_isTrail_iff_of_injective", "start": [1648, 1], "end": [1648, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.map_isCycle_iff_of_injective", "code": "theorem map_isCycle_iff_of_injective {p : G.Walk u u} (hinj : Function.Injective f) :\n    (p.map f).IsCycle \u2194 p.IsCycle", "start": [1651, 1], "end": [1654, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_isCycle_of_injective", "code": "alias \u27e8_, map_isCycle_of_injective\u27e9 := map_isCycle_iff_of_injective", "start": [1657, 1], "end": [1657, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.map_injective_of_injective", "code": "theorem map_injective_of_injective {f : G \u2192g G'} (hinj : Function.Injective f) (u v : V) :\n    Function.Injective (Walk.map f : G.Walk u v \u2192 G'.Walk (f u) (f v))", "start": [1662, 1], "end": [1678, 22], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mapLe", "code": "@[reducible]\ndef mapLe {G G' : SimpleGraph V} (h : G \u2264 G') {u v : V} (p : G.Walk u v) : G'.Walk u v :=\n  p.map (Hom.mapSpanningSubgraphs h)", "start": [1681, 1], "end": [1684, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mapLe_isTrail", "code": "@[simp]\ntheorem mapLe_isTrail {G G' : SimpleGraph V} (h : G \u2264 G') {u v : V} {p : G.Walk u v} :\n    (p.mapLe h).IsTrail \u2194 p.IsTrail", "start": [1687, 1], "end": [1690, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsTrail.of_mapLe", "code": "alias \u27e8IsTrail.of_mapLe, IsTrail.mapLe\u27e9 := mapLe_isTrail", "start": [1693, 1], "end": [1693, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.IsTrail.mapLe", "code": "alias \u27e8IsTrail.of_mapLe, IsTrail.mapLe\u27e9 := mapLe_isTrail", "start": [1693, 1], "end": [1693, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.mapLe_isPath", "code": "@[simp]\ntheorem mapLe_isPath {G G' : SimpleGraph V} (h : G \u2264 G') {u v : V} {p : G.Walk u v} :\n    (p.mapLe h).IsPath \u2194 p.IsPath", "start": [1697, 1], "end": [1700, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.of_mapLe", "code": "alias \u27e8IsPath.of_mapLe, IsPath.mapLe\u27e9 := mapLe_isPath", "start": [1703, 1], "end": [1703, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.IsPath.mapLe", "code": "alias \u27e8IsPath.of_mapLe, IsPath.mapLe\u27e9 := mapLe_isPath", "start": [1703, 1], "end": [1703, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.mapLe_isCycle", "code": "@[simp]\ntheorem mapLe_isCycle {G G' : SimpleGraph V} (h : G \u2264 G') {u : V} {p : G.Walk u u} :\n    (p.mapLe h).IsCycle \u2194 p.IsCycle", "start": [1707, 1], "end": [1710, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.of_mapLe", "code": "alias \u27e8IsCycle.of_mapLe, IsCycle.mapLe\u27e9 := mapLe_isCycle", "start": [1713, 1], "end": [1713, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Walk.IsCycle.mapLe", "code": "alias \u27e8IsCycle.of_mapLe, IsCycle.mapLe\u27e9 := mapLe_isCycle", "start": [1713, 1], "end": [1713, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.Path.map", "code": "@[simps]\nprotected def map (f : G \u2192g G') (hinj : Function.Injective f) {u v : V} (p : G.Path u v) :\n    G'.Path (f u) (f v) :=\n  \u27e8Walk.map f p, Walk.map_isPath_of_injective hinj p.2\u27e9", "start": [1723, 1], "end": [1727, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.map_injective", "code": "theorem map_injective {f : G \u2192g G'} (hinj : Function.Injective f) (u v : V) :\n    Function.Injective (Path.map f hinj : G.Path u v \u2192 G'.Path (f u) (f v))", "start": [1730, 1], "end": [1734, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.mapEmbedding", "code": "@[simps!]\nprotected def mapEmbedding (f : G \u21aag G') {u v : V} (p : G.Path u v) : G'.Path (f u) (f v) :=\n  Path.map f.toHom f.injective p", "start": [1737, 1], "end": [1740, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Path.mapEmbedding_injective", "code": "theorem mapEmbedding_injective (f : G \u21aag G') (u v : V) :\n    Function.Injective (Path.mapEmbedding f : G.Path u v \u2192 G'.Path (f u) (f v))", "start": [1743, 1], "end": [1745, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.transfer", "code": "@[simp]\nprotected def transfer {u v : V} (p : G.Walk u v)\n    (H : SimpleGraph V) (h : \u2200 e, e \u2208 p.edges \u2192 e \u2208 H.edgeSet) : H.Walk u v :=\n  match p with\n  | nil => nil\n  | cons' u v w a p =>\n    cons (h \u27e6(u, v)\u27e7 (by simp)) (p.transfer H fun e he => h e (by simp [he]))", "start": [1756, 1], "end": [1763, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.transfer_self", "code": "theorem transfer_self : p.transfer G p.edges_subset_edgeSet = p", "start": [1768, 1], "end": [1769, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.transfer_eq_map_of_le", "code": "theorem transfer_eq_map_of_le (hp) (GH : G \u2264 H) :\n    p.transfer H hp = p.map (SimpleGraph.Hom.mapSpanningSubgraphs GH)", "start": [1772, 1], "end": [1774, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edges_transfer", "code": "@[simp]\ntheorem edges_transfer (hp) : (p.transfer H hp).edges = p.edges", "start": [1777, 1], "end": [1779, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.support_transfer", "code": "@[simp]\ntheorem support_transfer (hp) : (p.transfer H hp).support = p.support", "start": [1782, 1], "end": [1784, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.length_transfer", "code": "@[simp]\ntheorem length_transfer (hp) : (p.transfer H hp).length = p.length", "start": [1787, 1], "end": [1789, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.transfer", "code": "protected theorem IsPath.transfer (hp) (pp : p.IsPath) :\n    (p.transfer H hp).IsPath", "start": [1794, 1], "end": [1800, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.transfer", "code": "protected theorem IsCycle.transfer {q : G.Walk u u} (qc : q.IsCycle) (hq) :\n    (q.transfer H hq).IsCycle", "start": [1803, 1], "end": [1810, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.transfer_transfer", "code": "@[simp]\ntheorem transfer_transfer (hp) {K : SimpleGraph V} (hp') :\n    (p.transfer H hp).transfer K hp' = p.transfer K (p.edges_transfer hp \u25b8 hp')", "start": [1818, 1], "end": [1825, 13], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.transfer_append", "code": "@[simp]\ntheorem transfer_append (q : G.Walk v w) (hpq) :\n    (p.append q).transfer H hpq =\n      (p.transfer H fun e he => hpq _ (by simp [he])).append\n        (q.transfer H fun e he => hpq _ (by simp [he]))", "start": [1828, 1], "end": [1835, 95], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reverse_transfer", "code": "@[simp]\ntheorem reverse_transfer (hp) :\n    (p.transfer H hp).reverse =\n      p.reverse.transfer H (by simp only [edges_reverse, List.mem_reverse]; exact hp)", "start": [1838, 1], "end": [1844, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toDeleteEdges", "code": "@[reducible]\ndef toDeleteEdges (s : Set (Sym2 V)) {v w : V} (p : G.Walk v w) (hp : \u2200 e, e \u2208 p.edges \u2192 \u00ace \u2208 s) :\n    (G.deleteEdges s).Walk v w :=\n  p.transfer _ <| by\n    simp only [edgeSet_deleteEdges, Set.mem_diff]\n    exact fun e ep => \u27e8edges_subset_edgeSet p ep, hp e ep\u27e9", "start": [1856, 1], "end": [1863, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toDeleteEdges_nil", "code": "@[simp]\ntheorem toDeleteEdges_nil (s : Set (Sym2 V)) {v : V} (hp) :\n    (Walk.nil : G.Walk v v).toDeleteEdges s hp = Walk.nil", "start": [1866, 1], "end": [1868, 65], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toDeleteEdges_cons", "code": "@[simp]\ntheorem toDeleteEdges_cons (s : Set (Sym2 V)) {u v w : V} (h : G.Adj u v) (p : G.Walk v w) (hp) :\n    (Walk.cons h p).toDeleteEdges s hp =\n      Walk.cons ((deleteEdges_adj _ _ _ _).mpr \u27e8h, hp _ (List.Mem.head _)\u27e9)\n        (p.toDeleteEdges s fun _ he => hp _ <| List.Mem.tail _ he)", "start": [1871, 1], "end": [1876, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toDeleteEdge", "code": "abbrev toDeleteEdge (e : Sym2 V) (p : G.Walk v w) (hp : e \u2209 p.edges) :\n    (G.deleteEdges {e}).Walk v w :=\n  p.toDeleteEdges {e} (fun e' => by contrapose!; simp (config := { contextual := true }) [hp])", "start": [1879, 1], "end": [1883, 95], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.map_toDeleteEdges_eq", "code": "@[simp]\ntheorem map_toDeleteEdges_eq (s : Set (Sym2 V)) {p : G.Walk v w} (hp) :\n    Walk.map (Hom.mapSpanningSubgraphs (G.deleteEdges_le s)) (p.toDeleteEdges s hp) = p", "start": [1886, 1], "end": [1892, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsPath.toDeleteEdges", "code": "protected theorem IsPath.toDeleteEdges (s : Set (Sym2 V))\n    {p : G.Walk v w} (h : p.IsPath) (hp) : (p.toDeleteEdges s hp).IsPath", "start": [1895, 1], "end": [1897, 15], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.IsCycle.toDeleteEdges", "code": "protected theorem IsCycle.toDeleteEdges (s : Set (Sym2 V))\n    {p : G.Walk v v} (h : p.IsCycle) (hp) : (p.toDeleteEdges s hp).IsCycle", "start": [1900, 1], "end": [1902, 15], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toDeleteEdges_copy", "code": "@[simp]\ntheorem toDeleteEdges_copy (s : Set (Sym2 V))\n    (p : G.Walk u v) (hu : u = u') (hv : v = v') (h) :\n    (p.copy hu hv).toDeleteEdges s h =\n      (p.toDeleteEdges s (by subst_vars; exact h)).copy hu hv", "start": [1905, 1], "end": [1911, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable", "code": "def Reachable (u v : V) : Prop := Nonempty (G.Walk u v)", "start": [1919, 1], "end": [1922, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_iff_nonempty_univ", "code": "theorem reachable_iff_nonempty_univ {u v : V} :\n    G.Reachable u v \u2194 (Set.univ : Set (G.Walk u v)).Nonempty", "start": [1927, 1], "end": [1929, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.elim", "code": "protected theorem Reachable.elim {p : Prop} {u v : V} (h : G.Reachable u v)\n    (hp : G.Walk u v \u2192 p) : p", "start": [1932, 1], "end": [1934, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.elim_path", "code": "protected theorem Reachable.elim_path {p : Prop} {u v : V} (h : G.Reachable u v)\n    (hp : G.Path u v \u2192 p) : p", "start": [1937, 1], "end": [1938, 80], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.reachable", "code": "protected theorem Walk.reachable {G : SimpleGraph V} {u v : V} (p : G.Walk u v) : G.Reachable u v", "start": [1941, 1], "end": [1942, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Adj.reachable", "code": "protected theorem Adj.reachable {u v : V} (h : G.Adj u v) : G.Reachable u v", "start": [1945, 1], "end": [1946, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.refl", "code": "@[refl]\nprotected theorem Reachable.refl (u : V) : G.Reachable u u", "start": [1949, 1], "end": [1950, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.rfl", "code": "protected theorem Reachable.rfl {u : V} : G.Reachable u u", "start": [1953, 1], "end": [1953, 78], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.symm", "code": "@[symm]\nprotected theorem Reachable.symm {u v : V} (huv : G.Reachable u v) : G.Reachable v u", "start": [1956, 1], "end": [1958, 32], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_comm", "code": "theorem reachable_comm {u v : V} : G.Reachable u v \u2194 G.Reachable v u", "start": [1961, 1], "end": [1962, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.trans", "code": "@[trans]\nprotected theorem Reachable.trans {u v w : V} (huv : G.Reachable u v) (hvw : G.Reachable v w) :\n    G.Reachable u w", "start": [1965, 1], "end": [1968, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_iff_reflTransGen", "code": "theorem reachable_iff_reflTransGen (u v : V) :\n    G.Reachable u v \u2194 Relation.ReflTransGen G.Adj u v", "start": [1971, 1], "end": [1981, 71], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.map", "code": "protected theorem Reachable.map {G : SimpleGraph V} {G' : SimpleGraph V'} (f : G \u2192g G')\n    (h : G.Reachable u v) : G'.Reachable (f u) (f v)", "start": [1984, 1], "end": [1986, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Reachable.mono", "code": "@[mono]\nprotected lemma Reachable.mono  {G G' : SimpleGraph V} (h : G \u2264 G') (Guv : G.Reachable u v) :\n    G'.Reachable u v := Guv.map (SimpleGraph.Hom.mapSpanningSubgraphs h)", "start": [1989, 1], "end": [1991, 73], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Iso.reachable_iff", "code": "theorem Iso.reachable_iff {G : SimpleGraph V} {G' : SimpleGraph V'} {\u03c6 : G \u2243g G'} {u v : V} :\n    G'.Reachable (\u03c6 u) (\u03c6 v) \u2194 G.Reachable u v", "start": [1993, 1], "end": [1995, 85], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Iso.symm_apply_reachable", "code": "theorem Iso.symm_apply_reachable {G : SimpleGraph V} {G' : SimpleGraph V'} {\u03c6 : G \u2243g G'} {u : V}\n    {v : V'} : G.Reachable (\u03c6.symm v) u \u2194 G'.Reachable v (\u03c6 u)", "start": [1998, 1], "end": [2000, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_is_equivalence", "code": "theorem reachable_is_equivalence : Equivalence G.Reachable", "start": [2005, 1], "end": [2006, 84], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachableSetoid", "code": "def reachableSetoid : Setoid V := Setoid.mk _ G.reachable_is_equivalence", "start": [2009, 1], "end": [2010, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected", "code": "def Preconnected : Prop := \u2200 u v : V, G.Reachable u v", "start": [2013, 1], "end": [2014, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.map", "code": "theorem Preconnected.map {G : SimpleGraph V} {H : SimpleGraph V'} (f : G \u2192g H) (hf : Surjective f)\n    (hG : G.Preconnected) : H.Preconnected", "start": [2017, 1], "end": [2019, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.mono", "code": "@[mono]\nprotected lemma Preconnected.mono  {G G' : SimpleGraph V} (h : G \u2264 G') (hG : G.Preconnected) :\n    G'.Preconnected := fun u v => (hG u v).mono h", "start": [2022, 1], "end": [2024, 50], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.top_preconnected", "code": "lemma top_preconnected : (\u22a4 : SimpleGraph V).Preconnected := fun x y => by\n  if h : x = y then rw [h] else exact Adj.reachable h", "start": [2026, 1], "end": [2027, 54], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Iso.preconnected_iff", "code": "theorem Iso.preconnected_iff {G : SimpleGraph V} {H : SimpleGraph V'} (e : G \u2243g H) :\n    G.Preconnected \u2194 H.Preconnected", "start": [2029, 1], "end": [2032, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected", "code": "@[mk_iff connected_iff]\nstructure Connected : Prop where\n  protected preconnected : G.Preconnected\n  protected [nonempty : Nonempty V]", "start": [2035, 1], "end": [2043, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.connected_iff_exists_forall_reachable", "code": "lemma connected_iff_exists_forall_reachable : G.Connected \u2194 \u2203 v, \u2200 w, G.Reachable v w := by\n  rw [connected_iff]\n  constructor\n  \u00b7 rintro \u27e8hp, \u27e8v\u27e9\u27e9\n    exact \u27e8v, fun w => hp v w\u27e9\n  \u00b7 rintro \u27e8v, h\u27e9\n    exact \u27e8fun u w => (h u).symm.trans (h w), \u27e8v\u27e9\u27e9", "start": [2046, 1], "end": [2052, 51], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Connected.map", "code": "theorem Connected.map {G : SimpleGraph V} {H : SimpleGraph V'} (f : G \u2192g H) (hf : Surjective f)\n    (hG : G.Connected) : H.Connected", "start": [2056, 1], "end": [2059, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.mono", "code": "@[mono]\nprotected lemma Connected.mono {G G' : SimpleGraph V} (h : G \u2264 G')\n    (hG : G.Connected) : G'.Connected where\n  preconnected := hG.preconnected.mono h\n  nonempty := hG.nonempty", "start": [2062, 1], "end": [2066, 26], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.top_connected", "code": "lemma top_connected [Nonempty V] : (\u22a4 : SimpleGraph V).Connected where\n  preconnected := top_preconnected", "start": [2068, 1], "end": [2069, 35], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Iso.connected_iff", "code": "theorem Iso.connected_iff {G : SimpleGraph V} {H : SimpleGraph V'} (e : G \u2243g H) :\n    G.Connected \u2194 H.Connected", "start": [2071, 1], "end": [2073, 101], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent", "code": "def ConnectedComponent := Quot G.Reachable", "start": [2076, 1], "end": [2078, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.connectedComponentMk", "code": "def connectedComponentMk (v : V) : G.ConnectedComponent := Quot.mk G.Reachable v", "start": [2081, 1], "end": [2082, 81], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.inhabited", "code": "@[simps]\ninstance inhabited [Inhabited V] : Inhabited G.ConnectedComponent :=\n  \u27e8G.connectedComponentMk default\u27e9", "start": [2089, 1], "end": [2091, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.ind", "code": "@[elab_as_elim]\nprotected theorem ind {\u03b2 : G.ConnectedComponent \u2192 Prop}\n    (h : \u2200 v : V, \u03b2 (G.connectedComponentMk v)) (c : G.ConnectedComponent) : \u03b2 c", "start": [2094, 1], "end": [2097, 15], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.ind\u2082", "code": "@[elab_as_elim]\nprotected theorem ind\u2082 {\u03b2 : G.ConnectedComponent \u2192 G.ConnectedComponent \u2192 Prop}\n    (h : \u2200 v w : V, \u03b2 (G.connectedComponentMk v) (G.connectedComponentMk w))\n    (c d : G.ConnectedComponent) : \u03b2 c d", "start": [2100, 1], "end": [2104, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.sound", "code": "protected theorem sound {v w : V} :\n    G.Reachable v w \u2192 G.connectedComponentMk v = G.connectedComponentMk w", "start": [2107, 1], "end": [2109, 13], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.exact", "code": "protected theorem exact {v w : V} :\n    G.connectedComponentMk v = G.connectedComponentMk w \u2192 G.Reachable v w", "start": [2112, 1], "end": [2114, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.eq", "code": "@[simp]\nprotected theorem eq {v w : V} :\n    G.connectedComponentMk v = G.connectedComponentMk w \u2194 G.Reachable v w", "start": [2117, 1], "end": [2120, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.connectedComponentMk_eq_of_adj", "code": "theorem connectedComponentMk_eq_of_adj {v w : V} (a : G.Adj v w) :\n    G.connectedComponentMk v = G.connectedComponentMk w", "start": [2123, 1], "end": [2125, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.lift", "code": "protected def lift {\u03b2 : Sort*} (f : V \u2192 \u03b2)\n    (h : \u2200 (v w : V) (p : G.Walk v w), p.IsPath \u2192 f v = f w) : G.ConnectedComponent \u2192 \u03b2 :=\n  Quot.lift f fun v w (h' : G.Reachable v w) => h'.elim_path fun hp => h v w hp hp.2", "start": [2128, 1], "end": [2132, 85], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.lift_mk", "code": "@[simp]\nprotected theorem lift_mk {\u03b2 : Sort*} {f : V \u2192 \u03b2}\n    {h : \u2200 (v w : V) (p : G.Walk v w), p.IsPath \u2192 f v = f w} {v : V} :\n    ConnectedComponent.lift f h (G.connectedComponentMk v) = f v", "start": [2135, 1], "end": [2139, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.exists", "code": "protected theorem \u00abexists\u00bb {p : G.ConnectedComponent \u2192 Prop} :\n    (\u2203 c : G.ConnectedComponent, p c) \u2194 \u2203 v, p (G.connectedComponentMk v)", "start": [2142, 1], "end": [2144, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.forall", "code": "protected theorem \u00abforall\u00bb {p : G.ConnectedComponent \u2192 Prop} :\n    (\u2200 c : G.ConnectedComponent, p c) \u2194 \u2200 v, p (G.connectedComponentMk v)", "start": [2147, 1], "end": [2149, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.subsingleton_connectedComponent", "code": "theorem _root_.SimpleGraph.Preconnected.subsingleton_connectedComponent (h : G.Preconnected) :\n    Subsingleton G.ConnectedComponent", "start": [2152, 1], "end": [2154, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.map", "code": "def map (\u03c6 : G \u2192g G') (C : G.ConnectedComponent) : G'.ConnectedComponent :=\n  C.lift (fun v => G'.connectedComponentMk (\u03c6 v)) fun _ _ p _ =>\n    ConnectedComponent.eq.mpr (p.map \u03c6).reachable", "start": [2157, 1], "end": [2160, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.map_mk", "code": "@[simp]\ntheorem map_mk (\u03c6 : G \u2192g G') (v : V) :\n    (G.connectedComponentMk v).map \u03c6 = G'.connectedComponentMk (\u03c6 v)", "start": [2163, 1], "end": [2166, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.map_id", "code": "@[simp]\ntheorem map_id (C : ConnectedComponent G) : C.map Hom.id = C", "start": [2169, 1], "end": [2172, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.map_comp", "code": "@[simp]\ntheorem map_comp (C : G.ConnectedComponent) (\u03c6 : G \u2192g G') (\u03c8 : G' \u2192g G'') :\n    (C.map \u03c6).map \u03c8 = C.map (\u03c8.comp \u03c6)", "start": [2175, 1], "end": [2179, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.iso_image_comp_eq_map_iff_eq_comp", "code": "@[simp]\ntheorem iso_image_comp_eq_map_iff_eq_comp {C : G.ConnectedComponent} :\n    G'.connectedComponentMk (\u03c6 v) = C.map \u2191(\u2191\u03c6 : G \u21aag G') \u2194 G.connectedComponentMk v = C", "start": [2184, 1], "end": [2189, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.iso_inv_image_comp_eq_iff_eq_map", "code": "@[simp]\ntheorem iso_inv_image_comp_eq_iff_eq_map {C : G.ConnectedComponent} :\n    G.connectedComponentMk (\u03c6.symm v') = C \u2194 G'.connectedComponentMk v' = C.map \u03c6", "start": [2192, 1], "end": [2197, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Iso.connectedComponentEquiv", "code": "@[simps]\ndef connectedComponentEquiv (\u03c6 : G \u2243g G') : G.ConnectedComponent \u2243 G'.ConnectedComponent where\n  toFun := ConnectedComponent.map \u03c6\n  invFun := ConnectedComponent.map \u03c6.symm\n  left_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G.connectedComponentMk (Equiv.left_inv \u03c6.toEquiv v)) C\n  right_inv C := ConnectedComponent.ind\n    (fun v => congr_arg G'.connectedComponentMk (Equiv.right_inv \u03c6.toEquiv v)) C", "start": [2204, 1], "end": [2212, 81], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Iso.connectedComponentEquiv_refl", "code": "@[simp]\ntheorem connectedComponentEquiv_refl :\n    (Iso.refl : G \u2243g G).connectedComponentEquiv = Equiv.refl _", "start": [2215, 1], "end": [2219, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Iso.connectedComponentEquiv_symm", "code": "@[simp]\ntheorem connectedComponentEquiv_symm (\u03c6 : G \u2243g G') :\n    \u03c6.symm.connectedComponentEquiv = \u03c6.connectedComponentEquiv.symm", "start": [2222, 1], "end": [2226, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Iso.connectedComponentEquiv_trans", "code": "@[simp]\ntheorem connectedComponentEquiv_trans (\u03c6 : G \u2243g G') (\u03c6' : G' \u2243g G'') :\n    connectedComponentEquiv (\u03c6.trans \u03c6') =\n    \u03c6.connectedComponentEquiv.trans \u03c6'.connectedComponentEquiv", "start": [2229, 1], "end": [2234, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.supp", "code": "def supp (C : G.ConnectedComponent) :=\n  { v | G.connectedComponentMk v = C }", "start": [2241, 1], "end": [2243, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.supp_injective", "code": "@[ext]\ntheorem supp_injective :\n    Function.Injective (ConnectedComponent.supp : G.ConnectedComponent \u2192 Set V)", "start": [2246, 1], "end": [2253, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.supp_inj", "code": "@[simp]\ntheorem supp_inj {C D : G.ConnectedComponent} : C.supp = D.supp \u2194 C = D", "start": [2256, 1], "end": [2258, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.mem_supp_iff", "code": "@[simp]\ntheorem mem_supp_iff (C : G.ConnectedComponent) (v : V) :\n    v \u2208 C.supp \u2194 G.connectedComponentMk v = C", "start": [2265, 1], "end": [2268, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.connectedComponentMk_mem", "code": "theorem connectedComponentMk_mem {v : V} : v \u2208 G.connectedComponentMk v", "start": [2271, 1], "end": [2272, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ConnectedComponent.isoEquivSupp", "code": "def isoEquivSupp (\u03c6 : G \u2243g G') (C : G.ConnectedComponent) :\n    C.supp \u2243 (\u03c6.connectedComponentEquiv C).supp where\n  toFun v := \u27e8\u03c6 v, ConnectedComponent.iso_image_comp_eq_map_iff_eq_comp.mpr v.prop\u27e9\n  invFun v' := \u27e8\u03c6.symm v', ConnectedComponent.iso_inv_image_comp_eq_iff_eq_map.mpr v'.prop\u27e9\n  left_inv v := Subtype.ext_val (\u03c6.toEquiv.left_inv \u2191v)\n  right_inv v := Subtype.ext_val (\u03c6.toEquiv.right_inv \u2191v)", "start": [2275, 1], "end": [2283, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Preconnected.set_univ_walk_nonempty", "code": "theorem Preconnected.set_univ_walk_nonempty (hconn : G.Preconnected) (u v : V) :\n    (Set.univ : Set (G.Walk u v)).Nonempty", "start": [2288, 1], "end": [2291, 18], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Connected.set_univ_walk_nonempty", "code": "theorem Connected.set_univ_walk_nonempty (hconn : G.Connected) (u v : V) :\n    (Set.univ : Set (G.Walk u v)).Nonempty", "start": [2294, 1], "end": [2296, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph", "code": "@[simp]\nprotected def toSubgraph {u v : V} : G.Walk u v \u2192 G.Subgraph\n  | nil => G.singletonSubgraph u\n  | cons h p => G.subgraphOfAdj h \u2294 p.toSubgraph", "start": [2306, 1], "end": [2310, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_cons_nil_eq_subgraphOfAdj", "code": "theorem toSubgraph_cons_nil_eq_subgraphOfAdj (h : G.Adj u v) :\n    (cons h nil).toSubgraph = G.subgraphOfAdj h", "start": [2313, 1], "end": [2314, 59], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_verts_toSubgraph", "code": "theorem mem_verts_toSubgraph (p : G.Walk u v) : w \u2208 p.toSubgraph.verts \u2194 w \u2208 p.support", "start": [2317, 1], "end": [2322, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.start_mem_verts_toSubgraph", "code": "lemma start_mem_verts_toSubgraph (p : G.Walk u v) : u \u2208 p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]", "start": [2325, 1], "end": [2326, 30], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.end_mem_verts_toSubgraph", "code": "lemma end_mem_verts_toSubgraph (p : G.Walk u v) : v \u2208 p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]", "start": [2328, 1], "end": [2329, 30], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.Walk.verts_toSubgraph", "code": "@[simp]\ntheorem verts_toSubgraph (p : G.Walk u v) : p.toSubgraph.verts = { w | w \u2208 p.support }", "start": [2331, 1], "end": [2333, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_edges_toSubgraph", "code": "theorem mem_edges_toSubgraph (p : G.Walk u v) {e : Sym2 V} :\n    e \u2208 p.toSubgraph.edgeSet \u2194 e \u2208 p.edges", "start": [2336, 1], "end": [2337, 74], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.edgeSet_toSubgraph", "code": "@[simp]\ntheorem edgeSet_toSubgraph (p : G.Walk u v) : p.toSubgraph.edgeSet = { e | e \u2208 p.edges }", "start": [2340, 1], "end": [2342, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_append", "code": "@[simp]\ntheorem toSubgraph_append (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).toSubgraph = p.toSubgraph \u2294 q.toSubgraph", "start": [2345, 1], "end": [2347, 100], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_reverse", "code": "@[simp]\ntheorem toSubgraph_reverse (p : G.Walk u v) : p.reverse.toSubgraph = p.toSubgraph", "start": [2350, 1], "end": [2358, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_rotate", "code": "@[simp]\ntheorem toSubgraph_rotate [DecidableEq V] (c : G.Walk v v) (h : u \u2208 c.support) :\n    (c.rotate h).toSubgraph = c.toSubgraph", "start": [2361, 1], "end": [2364, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_map", "code": "@[simp]\ntheorem toSubgraph_map (f : G \u2192g G') (p : G.Walk u v) : (p.map f).toSubgraph = p.toSubgraph.map f", "start": [2367, 1], "end": [2369, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.finite_neighborSet_toSubgraph", "code": "@[simp]\ntheorem finite_neighborSet_toSubgraph (p : G.Walk u v) : (p.toSubgraph.neighborSet w).Finite", "start": [2372, 1], "end": [2382, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.toSubgraph_le_induce_support", "code": "lemma toSubgraph_le_induce_support (p : G.Walk u v) :\n    p.toSubgraph \u2264 (\u22a4 : G.Subgraph).induce {v | v \u2208 p.support} := by\n  convert Subgraph.le_induce_top_verts\n  exact p.verts_toSubgraph.symm", "start": [2385, 1], "end": [2388, 32], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.set_walk_self_length_zero_eq", "code": "theorem set_walk_self_length_zero_eq (u : V) : {p : G.Walk u u | p.length = 0} = {Walk.nil}", "start": [2397, 1], "end": [2399, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.set_walk_length_zero_eq_of_ne", "code": "theorem set_walk_length_zero_eq_of_ne {u v : V} (h : u \u2260 v) :\n    {p : G.Walk u v | p.length = 0} = \u2205", "start": [2402, 1], "end": [2406, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.set_walk_length_succ_eq", "code": "theorem set_walk_length_succ_eq (u v : V) (n : \u2115) :\n    {p : G.Walk u v | p.length = n.succ} =\n      \u22c3 (w : V) (h : G.Adj u w), Walk.cons h '' {p' : G.Walk w v | p'.length = n}", "start": [2409, 1], "end": [2421, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.walkLengthTwoEquivCommonNeighbors", "code": "@[simps]\ndef walkLengthTwoEquivCommonNeighbors (u v : V) :\n    {p : G.Walk u v // p.length = 2} \u2243 G.commonNeighbors u v where\n  toFun p := \u27e8p.val.getVert 1, match p with\n    | \u27e8.cons _ (.cons _ .nil), hp\u27e9 => \u27e8\u2039G.Adj u _\u203a, \u2039G.Adj _ v\u203a.symm\u27e9\u27e9\n  invFun w := \u27e8w.prop.1.toWalk.concat w.prop.2.symm, rfl\u27e9\n  left_inv | \u27e8.cons _ (.cons _ .nil), hp\u27e9 => by rfl\n  right_inv _ := rfl", "start": [2426, 1], "end": [2435, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.finsetWalkLength", "code": "def finsetWalkLength (n : \u2115) (u v : V) : Finset (G.Walk u v) :=\n  match n with\n  | 0 =>\n    if h : u = v then by\n      subst u\n      exact {Walk.nil}\n    else \u2205\n  | n + 1 =>\n    Finset.univ.biUnion fun (w : G.neighborSet u) =>\n      (finsetWalkLength n w v).map \u27e8fun p => Walk.cons w.property p, fun _ _ => by simp\u27e9", "start": [2441, 1], "end": [2456, 89], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.coe_finsetWalkLength_eq", "code": "theorem coe_finsetWalkLength_eq (n : \u2115) (u v : V) :\n    (G.finsetWalkLength n u v : Set (G.Walk u v)) = {p : G.Walk u v | p.length = n}", "start": [2459, 1], "end": [2472, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.Walk.mem_finsetWalkLength_iff_length_eq", "code": "theorem Walk.mem_finsetWalkLength_iff_length_eq {n : \u2115} {u v : V} (p : G.Walk u v) :\n    p \u2208 G.finsetWalkLength n u v \u2194 p.length = n", "start": [2477, 1], "end": [2479, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.fintypeSetWalkLength", "code": "instance fintypeSetWalkLength (u v : V) (n : \u2115) : Fintype {p : G.Walk u v | p.length = n} :=\n  Fintype.ofFinset (G.finsetWalkLength n u v) fun p => by\n    rw [\u2190 Finset.mem_coe, coe_finsetWalkLength_eq]", "start": [2484, 1], "end": [2486, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.fintypeSubtypeWalkLength", "code": "instance fintypeSubtypeWalkLength (u v : V) (n : \u2115) : Fintype {p : G.Walk u v // p.length = n} :=\n  fintypeSetWalkLength G u v n", "start": [2489, 1], "end": [2490, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.set_walk_length_toFinset_eq", "code": "theorem set_walk_length_toFinset_eq (n : \u2115) (u v : V) :\n    {p : G.Walk u v | p.length = n}.toFinset = G.finsetWalkLength n u v", "start": [2492, 1], "end": [2495, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.card_set_walk_length_eq", "code": "theorem card_set_walk_length_eq (u v : V) (n : \u2115) :\n    Fintype.card {p : G.Walk u v | p.length = n} = (G.finsetWalkLength n u v).card", "start": [2500, 1], "end": [2503, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.fintypeSetPathLength", "code": "instance fintypeSetPathLength (u v : V) (n : \u2115) :\n    Fintype {p : G.Walk u v | p.IsPath \u2227 p.length = n} :=\n  Fintype.ofFinset ((G.finsetWalkLength n u v).filter Walk.IsPath) <| by\n    simp [Walk.mem_finsetWalkLength_iff_length_eq, and_comm]", "start": [2506, 1], "end": [2509, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_iff_exists_finsetWalkLength_nonempty", "code": "theorem reachable_iff_exists_finsetWalkLength_nonempty (u v : V) :\n    G.Reachable u v \u2194 \u2203 n : Fin (Fintype.card V), (G.finsetWalkLength n u v).Nonempty", "start": [2518, 1], "end": [2526, 14], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsBridge", "code": "def IsBridge (G : SimpleGraph V) (e : Sym2 V) : Prop :=\n  e \u2208 G.edgeSet \u2227\n    Sym2.lift \u27e8fun v w => \u00ac(G \\ fromEdgeSet {e}).Reachable v w, by simp [reachable_comm]\u27e9 e", "start": [2551, 1], "end": [2555, 92], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isBridge_iff", "code": "theorem isBridge_iff {u v : V} :\n    G.IsBridge \u27e6(u, v)\u27e7 \u2194 G.Adj u v \u2227 \u00ac(G \\ fromEdgeSet {\u27e6(u, v)\u27e7}).Reachable u v", "start": [2558, 1], "end": [2559, 93], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_delete_edges_iff_exists_walk", "code": "theorem reachable_delete_edges_iff_exists_walk {v w : V} :\n    (G \\ fromEdgeSet {\u27e6(v, w)\u27e7}).Reachable v w \u2194 \u2203 p : G.Walk v w, \u00ac\u27e6(v, w)\u27e7 \u2208 p.edges", "start": [2562, 1], "end": [2574, 61], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isBridge_iff_adj_and_forall_walk_mem_edges", "code": "theorem isBridge_iff_adj_and_forall_walk_mem_edges {v w : V} :\n    G.IsBridge \u27e6(v, w)\u27e7 \u2194 G.Adj v w \u2227 \u2200 p : G.Walk v w, \u27e6(v, w)\u27e7 \u2208 p.edges", "start": [2577, 1], "end": [2580, 62], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.reachable_deleteEdges_iff_exists_cycle.aux", "code": "theorem reachable_deleteEdges_iff_exists_cycle.aux [DecidableEq V] {u v w : V}\n    (hb : \u2200 p : G.Walk v w, \u27e6(v, w)\u27e7 \u2208 p.edges) (c : G.Walk u u) (hc : c.IsTrail)\n    (he : \u27e6(v, w)\u27e7 \u2208 c.edges)\n    (hw : w \u2208 (c.takeUntil v (c.fst_mem_support_of_mem_edges he)).support) : False", "start": [2583, 1], "end": [2607, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.adj_and_reachable_delete_edges_iff_exists_cycle", "code": "theorem adj_and_reachable_delete_edges_iff_exists_cycle {v w : V} :\n    G.Adj v w \u2227 (G \\ fromEdgeSet {\u27e6(v, w)\u27e7}).Reachable v w \u2194\n      \u2203 (u : V) (p : G.Walk u u), p.IsCycle \u2227 \u27e6(v, w)\u27e7 \u2208 p.edges", "start": [2611, 1], "end": [2633, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isBridge_iff_adj_and_forall_cycle_not_mem", "code": "theorem isBridge_iff_adj_and_forall_cycle_not_mem {v w : V} : G.IsBridge \u27e6(v, w)\u27e7 \u2194\n    G.Adj v w \u2227 \u2200 \u2983u : V\u2984 (p : G.Walk u u), p.IsCycle \u2192 \u27e6(v, w)\u27e7 \u2209 p.edges", "start": [2636, 1], "end": [2643, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isBridge_iff_mem_and_forall_cycle_not_mem", "code": "theorem isBridge_iff_mem_and_forall_cycle_not_mem {e : Sym2 V} :\n    G.IsBridge e \u2194 e \u2208 G.edgeSet \u2227 \u2200 \u2983u : V\u2984 (p : G.Walk u u), p.IsCycle \u2192 e \u2209 p.edges", "start": [2646, 1], "end": [2648, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/CompatibleSheafification.lean", "imports": ["Mathlib/CategoryTheory/Sites/Sheafification.lean", "Mathlib/CategoryTheory/Sites/CompatiblePlus.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.GrothendieckTopology.sheafifyCompIso", "code": "noncomputable def sheafifyCompIso : J.sheafify P \u22d9 F \u2245 J.sheafify (P \u22d9 F) :=\n  J.plusCompIso _ _ \u226a\u226b (J.plusFunctor _).mapIso (J.plusCompIso _ _)", "start": [54, 1], "end": [62, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerLeftIso", "code": "noncomputable def sheafificationWhiskerLeftIso (P : C\u1d52\u1d56 \u2964 D)\n    [\u2200 (F : D \u2964 E) (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 F]\n    [\u2200 (F : D \u2964 E) (X : C) (W : J.Cover X) (P : C\u1d52\u1d56 \u2964 D),\n        PreservesLimit (W.index P).multicospan F] :\n    (whiskeringLeft _ _ E).obj (J.sheafify P) \u2245\n    (whiskeringLeft _ _ _).obj P \u22d9 J.sheafification E := by\n  refine' J.plusFunctorWhiskerLeftIso _ \u226a\u226b _ \u226a\u226b Functor.associator _ _ _\n  refine' isoWhiskerRight _ _\n  refine' J.plusFunctorWhiskerLeftIso _", "start": [65, 1], "end": [75, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerLeftIso_hom_app", "code": "@[simp]\ntheorem sheafificationWhiskerLeftIso_hom_app (P : C\u1d52\u1d56 \u2964 D) (F : D \u2964 E)\n    [\u2200 (F : D \u2964 E) (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 F]\n    [\u2200 (F : D \u2964 E) (X : C) (W : J.Cover X) (P : C\u1d52\u1d56 \u2964 D),\n        PreservesLimit (W.index P).multicospan F] :\n    (sheafificationWhiskerLeftIso J P).hom.app F = (J.sheafifyCompIso F P).hom", "start": [78, 1], "end": [85, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerLeftIso_inv_app", "code": "@[simp]\ntheorem sheafificationWhiskerLeftIso_inv_app (P : C\u1d52\u1d56 \u2964 D) (F : D \u2964 E)\n    [\u2200 (F : D \u2964 E) (X : C), PreservesColimitsOfShape (J.Cover X)\u1d52\u1d56 F]\n    [\u2200 (F : D \u2964 E) (X : C) (W : J.Cover X) (P : C\u1d52\u1d56 \u2964 D),\n        PreservesLimit (W.index P).multicospan F] :\n    (sheafificationWhiskerLeftIso J P).inv.app F = (J.sheafifyCompIso F P).inv", "start": [88, 1], "end": [95, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerRightIso", "code": "noncomputable def sheafificationWhiskerRightIso :\n    J.sheafification D \u22d9 (whiskeringRight _ _ _).obj F \u2245\n      (whiskeringRight _ _ _).obj F \u22d9 J.sheafification E := by\n  refine' Functor.associator _ _ _ \u226a\u226b _\n  refine' isoWhiskerLeft (J.plusFunctor D) (J.plusFunctorWhiskerRightIso _) \u226a\u226b _\n  refine' _ \u226a\u226b Functor.associator _ _ _\n  refine' (Functor.associator _ _ _).symm \u226a\u226b _\n  exact isoWhiskerRight (J.plusFunctorWhiskerRightIso _) (J.plusFunctor E)", "start": [98, 1], "end": [107, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerRightIso_hom_app", "code": "@[simp]\ntheorem sheafificationWhiskerRightIso_hom_app :\n    (J.sheafificationWhiskerRightIso F).hom.app P = (J.sheafifyCompIso F P).hom", "start": [110, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafificationWhiskerRightIso_inv_app", "code": "@[simp]\ntheorem sheafificationWhiskerRightIso_inv_app :\n    (J.sheafificationWhiskerRightIso F).inv.app P = (J.sheafifyCompIso F P).inv", "start": [118, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.whiskerRight_toSheafify_sheafifyCompIso_hom", "code": "@[simp, reassoc]\ntheorem whiskerRight_toSheafify_sheafifyCompIso_hom :\n    whiskerRight (J.toSheafify _) _ \u226b (J.sheafifyCompIso F P).hom = J.toSheafify _", "start": [126, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toSheafify_comp_sheafifyCompIso_inv", "code": "@[simp, reassoc]\ntheorem toSheafify_comp_sheafifyCompIso_inv :\n    J.toSheafify _ \u226b (J.sheafifyCompIso F P).inv = whiskerRight (J.toSheafify _) _", "start": [137, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.sheafifyCompIso_inv_eq_sheafifyLift", "code": "@[simp]\ntheorem sheafifyCompIso_inv_eq_sheafifyLift :\n    (J.sheafifyCompIso F P).inv =\n      J.sheafifyLift (whiskerRight (J.toSheafify P) F) ((J.sheafify_isSheaf _).comp _)", "start": [149, 1], "end": [155, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Subsheaf.lean", "imports": ["Mathlib/CategoryTheory/Sites/Sheafification.lean", "Mathlib/CategoryTheory/Elementwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/CategoryTheory/Elementwise.lean", "Mathlib/CategoryTheory/Adjunction/Evaluation.lean"], "premises": [{"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf", "code": "@[ext]\nstructure Subpresheaf (F : C\u1d52\u1d56 \u2964 Type w) where\n  \n  obj : \u2200 U, Set (F.obj U)\n  \n  map : \u2200 {U V : C\u1d52\u1d56} (i : U \u27f6 V), obj U \u2286 F.map i \u207b\u00b9' obj V", "start": [44, 1], "end": [53, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.toPresheaf", "code": "@[simps!]\ndef Subpresheaf.toPresheaf : C\u1d52\u1d56 \u2964 Type w where\n  obj U := G.obj U\n  map := @fun U V i x => \u27e8F.map i x, G.map i x.prop\u27e9\n  map_id X := by\n    ext \u27e8x, _\u27e9\n    dsimp\n    simp only [FunctorToTypes.map_id_apply]\n  map_comp := @fun X Y Z i j => by\n    ext \u27e8x, _\u27e9\n    dsimp\n    simp only [FunctorToTypes.map_comp_apply]", "start": [67, 1], "end": [79, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.\u03b9", "code": "@[simps]\ndef Subpresheaf.\u03b9 : G.toPresheaf \u27f6 F where app U x := x", "start": [85, 1], "end": [87, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.homOfLe", "code": "@[simps]\ndef Subpresheaf.homOfLe {G G' : Subpresheaf F} (h : G \u2264 G') : G.toPresheaf \u27f6 G'.toPresheaf where\n  app U x := \u27e8x, h U x.prop\u27e9", "start": [95, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.homOfLe_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem Subpresheaf.homOfLe_\u03b9 {G G' : Subpresheaf F} (h : G \u2264 G') :\n    Subpresheaf.homOfLe h \u226b G'.\u03b9 = G.\u03b9", "start": [108, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.eq_top_iff_isIso", "code": "theorem Subpresheaf.eq_top_iff_isIso : G = \u22a4 \u2194 IsIso G.\u03b9", "start": [121, 1], "end": [129, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.lift", "code": "@[simps!]\ndef Subpresheaf.lift (f : F' \u27f6 F) (hf : \u2200 U x, f.app U x \u2208 G.obj U) : F' \u27f6 G.toPresheaf where\n  app U x := \u27e8f.app U x, hf U x\u27e9\n  naturality := by\n    have := elementwise_of% f.naturality\n    intros\n    refine funext fun x => Subtype.ext ?_\n    simp only [toPresheaf_obj, types_comp_apply]\n    exact this _ _", "start": [132, 1], "end": [141, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.lift_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem Subpresheaf.lift_\u03b9 (f : F' \u27f6 F) (hf : \u2200 U x, f.app U x \u2208 G.obj U) :\n    G.lift f hf \u226b G.\u03b9 = f", "start": [144, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sieveOfSection", "code": "@[simps]\ndef Subpresheaf.sieveOfSection {U : C\u1d52\u1d56} (s : F.obj U) : Sieve (unop U) where\n  arrows V f := F.map f.op s \u2208 G.obj (op V)\n  downward_closed := @fun V W i hi j => by\n    simp only [op_unop, op_comp, FunctorToTypes.map_comp_apply]\n    exact G.map _ hi", "start": [151, 1], "end": [158, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.familyOfElementsOfSection", "code": "def Subpresheaf.familyOfElementsOfSection {U : C\u1d52\u1d56} (s : F.obj U) :\n    (G.sieveOfSection s).1.FamilyOfElements G.toPresheaf := fun _ i hi => \u27e8F.map i.op s, hi\u27e9", "start": [161, 1], "end": [164, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.family_of_elements_compatible", "code": "theorem Subpresheaf.family_of_elements_compatible {U : C\u1d52\u1d56} (s : F.obj U) :\n    (G.familyOfElementsOfSection s).Compatible", "start": [167, 1], "end": [172, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.nat_trans_naturality", "code": "theorem Subpresheaf.nat_trans_naturality (f : F' \u27f6 G.toPresheaf) {U V : C\u1d52\u1d56} (i : U \u27f6 V)\n    (x : F'.obj U) : (f.app V (F'.map i x)).1 = F.map i (f.app U x).1", "start": [175, 1], "end": [177, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sheafify", "code": "def Subpresheaf.sheafify : Subpresheaf F where\n  obj U := { s | G.sieveOfSection s \u2208 J (unop U) }\n  map := by\n    rintro U V i s hs\n    refine' J.superset_covering _ (J.pullback_stable i.unop hs)\n    intro _ _ h\n    dsimp at h \u22a2\n    rwa [\u2190 FunctorToTypes.map_comp_apply]", "start": [180, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.le_sheafify", "code": "theorem Subpresheaf.le_sheafify : G \u2264 G.sheafify J", "start": [192, 1], "end": [198, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.eq_sheafify", "code": "theorem Subpresheaf.eq_sheafify (h : Presieve.IsSheaf J F) (hG : Presieve.IsSheaf J G.toPresheaf) :\n    G = G.sheafify J", "start": [203, 1], "end": [212, 100], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sheafify_isSheaf", "code": "theorem Subpresheaf.sheafify_isSheaf (hF : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J (G.sheafify J).toPresheaf", "start": [215, 1], "end": [254, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.eq_sheafify_iff", "code": "theorem Subpresheaf.eq_sheafify_iff (h : Presieve.IsSheaf J F) :\n    G = G.sheafify J \u2194 Presieve.IsSheaf J G.toPresheaf", "start": [257, 1], "end": [259, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.isSheaf_iff", "code": "theorem Subpresheaf.isSheaf_iff (h : Presieve.IsSheaf J F) :\n    Presieve.IsSheaf J G.toPresheaf \u2194\n      \u2200 (U) (s : F.obj U), G.sieveOfSection s \u2208 J (unop U) \u2192 s \u2208 G.obj U", "start": [262, 1], "end": [267, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sheafify_sheafify", "code": "theorem Subpresheaf.sheafify_sheafify (h : Presieve.IsSheaf J F) :\n    (G.sheafify J).sheafify J = G.sheafify J", "start": [270, 1], "end": [272, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sheafifyLift", "code": "noncomputable def Subpresheaf.sheafifyLift (f : G.toPresheaf \u27f6 F') (h : Presieve.IsSheaf J F') :\n    (G.sheafify J).toPresheaf \u27f6 F' where\n  app U s := (h (G.sieveOfSection s.1) s.prop).amalgamate\n    (_) ((G.family_of_elements_compatible s.1).compPresheafMap f)\n  naturality := by\n    intro U V i\n    ext s\n    apply (h _ ((Subpresheaf.sheafify J G).toPresheaf.map i s).prop).isSeparatedFor.ext\n    intro W j hj\n    refine' (Presieve.IsSheafFor.valid_glue (h _ ((G.sheafify J).toPresheaf.map i s).2)\n      ((G.family_of_elements_compatible _).compPresheafMap _) _ hj).trans _\n    dsimp\n    conv_rhs => rw [\u2190 FunctorToTypes.map_comp_apply]\n    change _ = F'.map (j \u226b i.unop).op _\n    refine' Eq.trans _ (Presieve.IsSheafFor.valid_glue (h _ s.2)\n      ((G.family_of_elements_compatible s.1).compPresheafMap f) (j \u226b i.unop) _).symm\n    swap \u00b7 dsimp [Presieve.FamilyOfElements.compPresheafMap] at hj \u22a2\n      rwa [FunctorToTypes.map_comp_apply]\n    \u00b7 dsimp [Presieve.FamilyOfElements.compPresheafMap]\n      exact congr_arg _ (Subtype.ext (FunctorToTypes.map_comp_apply _ _ _ _).symm)", "start": [275, 1], "end": [297, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.to_sheafifyLift", "code": "theorem Subpresheaf.to_sheafifyLift (f : G.toPresheaf \u27f6 F') (h : Presieve.IsSheaf J F') :\n    Subpresheaf.homOfLe (G.le_sheafify J) \u226b G.sheafifyLift f h = f", "start": [300, 1], "end": [308, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.to_sheafify_lift_unique", "code": "theorem Subpresheaf.to_sheafify_lift_unique (h : Presieve.IsSheaf J F')\n    (l\u2081 l\u2082 : (G.sheafify J).toPresheaf \u27f6 F')\n    (e : Subpresheaf.homOfLe (G.le_sheafify J) \u226b l\u2081 = Subpresheaf.homOfLe (G.le_sheafify J) \u226b l\u2082) :\n    l\u2081 = l\u2082", "start": [311, 1], "end": [320, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.Subpresheaf.sheafify_le", "code": "theorem Subpresheaf.sheafify_le (h : G \u2264 G') (hF : Presieve.IsSheaf J F)\n    (hG' : Presieve.IsSheaf J G'.toPresheaf) : G.sheafify J \u2264 G'", "start": [323, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imagePresheaf", "code": "@[simps]\ndef imagePresheaf (f : F' \u27f6 F) : Subpresheaf F where\n  obj U := Set.range (f.app U)\n  map := by\n    rintro U V i _ \u27e8x, rfl\u27e9\n    have := elementwise_of% f.naturality\n    exact \u27e8_, this i x\u27e9", "start": [339, 1], "end": [346, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.top_subpresheaf_obj", "code": "@[simp]\ntheorem top_subpresheaf_obj (U) : (\u22a4 : Subpresheaf F).obj U = \u22a4", "start": [349, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imagePresheaf_id", "code": "@[simp]\ntheorem imagePresheaf_id : imagePresheaf (\ud835\udfd9 F) = \u22a4", "start": [354, 1], "end": [357, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toImagePresheaf", "code": "@[simps!]\ndef toImagePresheaf (f : F' \u27f6 F) : F' \u27f6 (imagePresheaf f).toPresheaf :=\n  (imagePresheaf f).lift f fun _ _ => Set.mem_range_self _", "start": [360, 1], "end": [363, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toImagePresheafSheafify", "code": "@[simps!]\ndef toImagePresheafSheafify (f : F' \u27f6 F) : F' \u27f6 ((imagePresheaf f).sheafify J).toPresheaf :=\n  toImagePresheaf f \u226b Subpresheaf.homOfLe ((imagePresheaf f).le_sheafify J)", "start": [368, 1], "end": [371, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toImagePresheaf_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem toImagePresheaf_\u03b9 (f : F' \u27f6 F) : toImagePresheaf f \u226b (imagePresheaf f).\u03b9 = f", "start": [376, 1], "end": [378, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imagePresheaf_comp_le", "code": "theorem imagePresheaf_comp_le (f\u2081 : F \u27f6 F') (f\u2082 : F' \u27f6 F'') :\n    imagePresheaf (f\u2081 \u226b f\u2082) \u2264 imagePresheaf f\u2082", "start": [381, 1], "end": [382, 101], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.isIso_toImagePresheaf", "code": "instance isIso_toImagePresheaf {F F' : C\u1d52\u1d56 \u2964 TypeMax.{v, w}} (f : F \u27f6 F') [hf : Mono f] :\n  IsIso (toImagePresheaf f) := by\n  have : \u2200 (X : C\u1d52\u1d56), IsIso ((toImagePresheaf f).app X) := by\n    intro X\n    rw [isIso_iff_bijective]\n    constructor\n    \u00b7 intro x y e\n      have := (NatTrans.mono_iff_mono_app _ _).mp hf X\n      rw [mono_iff_injective] at this\n      exact this (congr_arg Subtype.val e : _)\n    \u00b7 rintro \u27e8_, \u27e8x, rfl\u27e9\u27e9\n      exact \u27e8x, rfl\u27e9\n  apply NatIso.isIso_of_isIso_app", "start": [385, 1], "end": [397, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imageSheaf", "code": "@[simps]\ndef imageSheaf {F F' : Sheaf J (Type w)} (f : F \u27f6 F') : Sheaf J (Type w) :=\n  \u27e8((imagePresheaf f.1).sheafify J).toPresheaf, by\n    rw [isSheaf_iff_isSheaf_of_type]\n    apply Subpresheaf.sheafify_isSheaf\n    rw [\u2190 isSheaf_iff_isSheaf_of_type]\n    exact F'.2\u27e9", "start": [399, 1], "end": [407, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toImageSheaf", "code": "@[simps]\ndef toImageSheaf {F F' : Sheaf J (Type w)} (f : F \u27f6 F') : F \u27f6 imageSheaf f :=\n  \u27e8toImagePresheafSheafify J f.1\u27e9", "start": [410, 1], "end": [413, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imageSheaf\u03b9", "code": "@[simps]\ndef imageSheaf\u03b9 {F F' : Sheaf J (Type w)} (f : F \u27f6 F') : imageSheaf f \u27f6 F' :=\n  \u27e8Subpresheaf.\u03b9 _\u27e9", "start": [416, 1], "end": [419, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.toImageSheaf_\u03b9", "code": "@[reassoc (attr := simp)]\ntheorem toImageSheaf_\u03b9 {F F' : Sheaf J (Type w)} (f : F \u27f6 F') :\n    toImageSheaf f \u226b imageSheaf\u03b9 f = f", "start": [422, 1], "end": [426, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imageMonoFactorization", "code": "def imageMonoFactorization {F F' : Sheaf J (Type w)} (f : F \u27f6 F') : Limits.MonoFactorisation f where\n  I := imageSheaf f\n  m := imageSheaf\u03b9 f\n  e := toImageSheaf f", "start": [448, 1], "end": [452, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.imageFactorization", "code": "noncomputable def imageFactorization {F F' : Sheaf J TypeMax.{v, u}} (f : F \u27f6 F') :\n    Limits.ImageFactorisation f where\n  F := imageMonoFactorization f\n  isImage :=\n    { lift := fun I => by\n        haveI M := (Sheaf.Hom.mono_iff_presheaf_mono J TypeMax.{v, u} _).mp I.m_mono\n        haveI := isIso_toImagePresheaf I.m.1\n        refine' \u27e8Subpresheaf.homOfLe _ \u226b inv (toImagePresheaf I.m.1)\u27e9\n        apply Subpresheaf.sheafify_le\n        \u00b7 conv_lhs => rw [\u2190 I.fac]\n          apply imagePresheaf_comp_le\n        \u00b7 rw [\u2190 isSheaf_iff_isSheaf_of_type]\n          exact F'.2\n        \u00b7 apply Presieve.isSheaf_iso J (asIso <| toImagePresheaf I.m.1)\n          rw [\u2190 isSheaf_iff_isSheaf_of_type]\n          exact I.I.2\n      lift_fac := fun I => by\n        ext1\n        dsimp [imageMonoFactorization]\n        generalize_proofs h\n        rw [\u2190 Subpresheaf.homOfLe_\u03b9 h, Category.assoc]\n        congr 1\n        rw [IsIso.inv_comp_eq, toImagePresheaf_\u03b9] }", "start": [455, 1], "end": [479, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Fintype.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.fintype", "code": "noncomputable instance Finsupp.fintype {\u03b9 \u03c0 : Sort _} [DecidableEq \u03b9] [Zero \u03c0] [Fintype \u03b9]\n    [Fintype \u03c0] : Fintype (\u03b9 \u2192\u2080 \u03c0) :=\n  Fintype.ofEquiv _ Finsupp.equivFunOnFinite.symm", "start": [20, 1], "end": [22, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.infinite_of_left", "code": "instance Finsupp.infinite_of_left {\u03b9 \u03c0 : Sort _} [Nontrivial \u03c0] [Zero \u03c0] [Infinite \u03b9] :\n    Infinite (\u03b9 \u2192\u2080 \u03c0) :=\n  let \u27e8_, hm\u27e9 := exists_ne (0 : \u03c0)\n  Infinite.of_injective _ <| Finsupp.single_left_injective hm", "start": [25, 1], "end": [28, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.infinite_of_right", "code": "instance Finsupp.infinite_of_right {\u03b9 \u03c0 : Sort _} [Infinite \u03c0] [Zero \u03c0] [Nonempty \u03b9] :\n    Infinite (\u03b9 \u2192\u2080 \u03c0) :=\n  Infinite.of_injective (fun i => Finsupp.single (Classical.arbitrary \u03b9) i)\n    (Finsupp.single_injective (Classical.arbitrary \u03b9))", "start": [31, 1], "end": [34, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DList/Defs.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/DList.lean", "Mathlib/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.DList.lazy_ofList", "code": "def lazy_ofList (l : Thunk (List \u03b1)) : DList \u03b1 :=\n  \u27e8fun xs => l.get ++ xs, fun t => by simp\u27e9", "start": [37, 1], "end": [39, 44], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_ofList", "code": "theorem toList_ofList (l : List \u03b1) : DList.toList (DList.ofList l) = l", "start": [58, 1], "end": [59, 90], "kind": "commanddeclaration"}, {"full_name": "Std.DList.ofList_toList", "code": "theorem ofList_toList (l : DList \u03b1) : DList.ofList (DList.toList l) = l", "start": [62, 1], "end": [66, 16], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_empty", "code": "theorem toList_empty : toList (@empty \u03b1) = []", "start": [69, 1], "end": [69, 57], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_singleton", "code": "theorem toList_singleton (x : \u03b1) : toList (singleton x) = [x]", "start": [72, 1], "end": [72, 73], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_append", "code": "theorem toList_append (l\u2081 l\u2082 : DList \u03b1) : toList (l\u2081 ++ l\u2082) = toList l\u2081 ++ toList l\u2082", "start": [75, 1], "end": [77, 70], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_cons", "code": "theorem toList_cons (x : \u03b1) (l : DList \u03b1) : toList (cons x l) = x :: toList l", "start": [80, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "Std.DList.toList_push", "code": "theorem toList_push (x : \u03b1) (l : DList \u03b1) : toList (push l x) = toList l ++ [x]", "start": [84, 1], "end": [85, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/ExprLens.lean", "lake-packages/std/Std/Data/Nat/Init/Lemmas.lean", "lake-packages/proofwidgets/ProofWidgets/Component/MakeEditLink.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/proofwidgets/ProofWidgets/Component/OfRpcMethod.lean", "Mathlib/Tactic/Widget/SelectInsertParamsClass.lean"], "premises": [{"full_name": "getGoalLocations", "code": "def getGoalLocations (locations : Array GoalsLocation) : Array SubExpr.Pos := Id.run do\n  let mut res := #[]\n  for location in locations do\n    if let .target pos := location.loc then\n      res := res.push pos\n  return res", "start": [26, 1], "end": [33, 13], "kind": "commanddeclaration"}, {"full_name": "insertMetaVar", "code": "def insertMetaVar (e : Expr) (pos : SubExpr.Pos) : MetaM Expr :=\nreplaceSubexpr (fun _ \u21a6  do mkFreshExprMVar none .synthetic) pos e", "start": [35, 1], "end": [37, 67], "kind": "commanddeclaration"}, {"full_name": "String.renameMetaVar", "code": "def String.renameMetaVar (s : String) : String :=\n  match s.splitOn \"?m.\" with\n  | [] => \"\"\n  | [s] => s\n  | head::tail => head ++ \"?_\" ++ \"?_\".intercalate (tail.map fun s \u21a6 s.dropWhile Char.isDigit)", "start": [39, 1], "end": [44, 95], "kind": "commanddeclaration"}, {"full_name": "SelectInsertParams", "code": "structure SelectInsertParams where\n  \n  pos : Lsp.Position\n  \n  goals : Array Widget.InteractiveGoal\n  \n  selectedLocations : Array SubExpr.GoalsLocation\n  \n  replaceRange : Lsp.Range\n  deriving SelectInsertParamsClass, RpcEncodable", "start": [48, 1], "end": [58, 49], "kind": "commanddeclaration"}, {"full_name": "mkSelectionPanelRPC", "code": "def mkSelectionPanelRPC {Params : Type} [SelectInsertParamsClass Params]\n    (mkCmdStr : (pos : Array GoalsLocation) \u2192 (goalType : Expr) \u2192 Params \u2192\n   MetaM (String \u00d7 String \u00d7 Option (String.Pos \u00d7 String.Pos)))\n  (helpMsg : String) (title : String) (onlyGoal := true) (onlyOne := false) :\n  (params : Params) \u2192 RequestM (RequestTask Html) :=\nfun params \u21a6 RequestM.asTask do\nlet doc \u2190 RequestM.readDoc\nif h : 0 < (goals params).size then\n  let mainGoal := (goals params)[0]\n  let mainGoalName := mainGoal.mvarId.name\n  let all := if onlyOne then \"The selected sub-expression\" else \"All selected sub-expressions\"\n  let be_where := if onlyGoal then \"in the main goal.\" else \"in the main goal or its context.\"\n  let errorMsg := s!\"{all} should be {be_where}\"\n  let inner : Html \u2190 (do\n    if onlyOne && (selectedLocations params).size > 1 then\n      return <span>{.text \"You should select only one sub-expression\"}</span>\n    for selectedLocation in selectedLocations params do\n      if selectedLocation.mvarId.name != mainGoalName then\n        return <span>{.text errorMsg}</span>\n      else if onlyGoal then\n        if !(selectedLocation.loc matches (.target _)) then\n          return <span>{.text errorMsg}</span>\n    if (selectedLocations params).isEmpty then\n      return <span>{.text helpMsg}</span>\n    mainGoal.ctx.val.runMetaM {} do\n      let md \u2190 mainGoal.mvarId.getDecl\n      let lctx := md.lctx |>.sanitizeNames.run' {options := (\u2190 getOptions)}\n      Meta.withLCtx lctx md.localInstances do\n        let (linkText, newCode, range?) \u2190 mkCmdStr (selectedLocations params) md.type.consumeMData\n          params\n        return .ofComponent\n          MakeEditLink\n          (.ofReplaceRange doc.meta (replaceRange params) newCode range?)\n          #[ .text linkText ])\n  return <details \u00abopen\u00bb={true}>\n      <summary className=\"mv2 pointer\">{.text title}</summary>\n      <div className=\"ml1\">{inner}</div>\n    </details>\nelse\n  return <span>{.text \"There is no goal to solve!\"}</span>", "start": [61, 1], "end": [118, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Testing/SlimCheck/Testable.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Testing/SlimCheck/Sampleable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SlimCheck.TestResult", "code": "inductive TestResult (p : Prop) where\n  | success : PSum Unit p \u2192 TestResult p\n  | gaveUp : Nat \u2192 TestResult p\n  | failure : \u00ac p \u2192 List String \u2192 Nat \u2192 TestResult p\n  deriving Inhabited", "start": [86, 1], "end": [109, 21], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Configuration", "code": "structure Configuration where\n  numInst : Nat := 100\n  maxSize : Nat := 100\n  numRetries : Nat := 10\n  traceDiscarded : Bool := false\n  traceSuccesses : Bool := false\n  traceShrink : Bool := false\n  traceShrinkCandidates : Bool := false\n  randomSeed : Option Nat := none\n  quiet : Bool := false\n  deriving Inhabited", "start": [111, 1], "end": [122, 21], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.PrintableProp", "code": "class PrintableProp (p : Prop) where\n  printProp : String", "start": [137, 1], "end": [143, 21], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable", "code": "class Testable (p : Prop) where\n  run (cfg : Configuration) (minimize : Bool) : Gen (TestResult p)", "start": [150, 1], "end": [152, 67], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.NamedBinder", "code": "@[nolint unusedArguments]\ndef NamedBinder (_n : String) (p : Prop) : Prop := p", "start": [154, 1], "end": [155, 53], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.toString", "code": "def toString : TestResult p \u2192 String\n  | success (PSum.inl _) => \"success (no proof)\"\n  | success (PSum.inr _) => \"success (proof)\"\n  | gaveUp n => s!\"gave {n} times\"\n  | failure _ counters _ => s!\"failed {counters}\"", "start": [159, 1], "end": [163, 50], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.combine", "code": "def combine {p q : Prop} : PSum Unit (p \u2192 q) \u2192 PSum Unit p \u2192 PSum Unit q\n  | PSum.inr f, PSum.inr proof => PSum.inr $ f proof\n  | _, _ => PSum.inl ()", "start": [167, 1], "end": [170, 24], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.and", "code": "def and : TestResult p \u2192 TestResult q \u2192 TestResult (p \u2227 q)\n  | failure h xs n, _ => failure (\u03bb h2 => h h2.left) xs n\n  | _, failure h xs n => failure (\u03bb h2 => h h2.right) xs n\n  | success h1, success h2 => success $ combine (combine (PSum.inr And.intro) h1) h2\n  | gaveUp n, gaveUp m => gaveUp $ n + m\n  | gaveUp n, _ => gaveUp n\n  | _, gaveUp n => gaveUp n", "start": [172, 1], "end": [179, 28], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.or", "code": "def or : TestResult p \u2192 TestResult q \u2192 TestResult (p \u2228 q)\n  | failure h1 xs n, failure h2 ys m =>\n    let h3 := \u03bb h =>\n      match h with\n      | Or.inl h3 => h1 h3\n      | Or.inr h3 => h2 h3\n    failure h3 (xs ++ ys) (n + m)\n  | success h, _ => success $ combine (PSum.inr Or.inl) h\n  | _, success h => success $ combine (PSum.inr Or.inr) h\n  | gaveUp n, gaveUp m => gaveUp $ n + m\n  | gaveUp n, _ => gaveUp n\n  | _, gaveUp n => gaveUp n", "start": [181, 1], "end": [193, 28], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.imp", "code": "def imp (h : q \u2192 p) (r : TestResult p)\n    (p : PSum Unit (p \u2192 q) := PSum.inl ()) : TestResult q :=\n  match r with\n  | failure h2 xs n => failure (mt h h2) xs n\n  | success h2 => success $ combine p h2\n  | gaveUp n => gaveUp n", "start": [195, 1], "end": [202, 25], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.iff", "code": "def iff (h : q \u2194 p) (r : TestResult p) : TestResult q :=\n  imp h.mp r (PSum.inr h.mpr)", "start": [204, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.addInfo", "code": "def addInfo (x : String) (h : q \u2192 p) (r : TestResult p)\n    (p : PSum Unit (p \u2192 q) := PSum.inl ()) : TestResult q :=\n  if let failure h2 xs n := r then\n    failure (mt h h2) (x :: xs) n\n  else\n    imp h r p", "start": [208, 1], "end": [216, 14], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.addVarInfo", "code": "def addVarInfo [Repr \u03b3] (var : String) (x : \u03b3) (h : q \u2192 p) (r : TestResult p)\n    (p : PSum Unit (p \u2192 q) := PSum.inl ()) : TestResult q :=\n  addInfo s!\"{var} := {repr x}\" h r p", "start": [218, 1], "end": [221, 38], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.TestResult.isFailure", "code": "def isFailure : TestResult p \u2192 Bool\n  | failure _ _ _ => true\n  | _ => false", "start": [223, 1], "end": [225, 15], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Configuration.verbose", "code": "def verbose : Configuration where\n  traceDiscarded := true\n  traceSuccesses := true\n  traceShrink := true\n  traceShrinkCandidates := true", "start": [231, 1], "end": [236, 32], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.runProp", "code": "def runProp (p : Prop) [Testable p] : Configuration \u2192 Bool \u2192 Gen (TestResult p) := Testable.run", "start": [244, 1], "end": [244, 96], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.slimTrace", "code": "def slimTrace [Pure m] (s : String) : m PUnit := dbgTrace s!\"[SlimCheck: {s}]\" (\u03bb _ => pure ())", "start": [246, 1], "end": [247, 96], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.andTestable", "code": "instance andTestable [Testable p] [Testable q] : Testable (p \u2227 q) where\n  run := \u03bb cfg min => do\n    let xp \u2190 runProp p cfg min\n    let xq \u2190 runProp q cfg min\n    pure $ and xp xq", "start": [249, 1], "end": [253, 21], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.orTestable", "code": "instance orTestable [Testable p] [Testable q] : Testable (p \u2228 q) where\n  run := \u03bb cfg min => do\n    let xp \u2190 runProp p cfg min\n    match xp with\n    | success (PSum.inl h) => pure $ success (PSum.inl h)\n    | success (PSum.inr h) => pure $ success (PSum.inr $ Or.inl h)\n    | _ =>\n      let xq \u2190 runProp q cfg min\n      pure $ or xp xq", "start": [255, 1], "end": [265, 22], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.iffTestable", "code": "instance iffTestable [Testable ((p \u2227 q) \u2228 (\u00ac p \u2227 \u00ac q))] : Testable (p \u2194 q) where\n  run := \u03bb cfg min => do\n    let h \u2190 runProp ((p \u2227 q) \u2228 (\u00ac p \u2227 \u00ac q)) cfg min\n    pure $ iff iff_iff_and_or_not_and_not h", "start": [267, 1], "end": [270, 44], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.decGuardTestable", "code": "instance decGuardTestable [PrintableProp p] [Decidable p] {\u03b2 : p \u2192 Prop} [\u2200 h, Testable (\u03b2 h)] :\n    Testable (NamedBinder var $ \u2200 h, \u03b2 h) where\n  run := \u03bb cfg min => do\n    if h : p then\n      let res := (runProp (\u03b2 h) cfg min)\n      let s := printProp p\n      (\u03bb r => addInfo s!\"guard: {s}\" (\u00b7 $ h) r (PSum.inr $ \u03bb q _ => q)) <$> res\n    else if cfg.traceDiscarded || cfg.traceSuccesses then\n      let res := (\u03bb _ => pure $ gaveUp 1)\n      let s := printProp p\n      slimTrace s!\"discard: Guard {s} does not hold\"; res\n    else\n      pure $ gaveUp 1", "start": [274, 1], "end": [286, 22], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.forallTypesTestable", "code": "instance forallTypesTestable {f : Type \u2192 Prop} [Testable (f Int)] :\n    Testable (NamedBinder var $ \u2200 x, f x) where\n  run := \u03bb cfg min => do\n    let r \u2190 runProp (f Int) cfg min\n    pure $ addVarInfo var \"\u2124\" (\u00b7 $ Int) r", "start": [288, 1], "end": [292, 42], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.formatFailure", "code": "def formatFailure (s : String) (xs : List String) (n : Nat) : String :=\n  let counter := String.intercalate \"\\n\" xs\n  let parts := [\n    \"\\n===================\",\n    s,\n    counter,\n    s!\"({n} shrinks)\",\n    \"  ]\n  String.intercalate \"\\n\" parts", "start": [294, 1], "end": [306, 32], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.addShrinks", "code": "def addShrinks (n : Nat) : TestResult p \u2192 TestResult p\n  | TestResult.failure p xs m => TestResult.failure p xs (m + n)\n  | p => p", "start": [308, 1], "end": [313, 11], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.minimizeAux", "code": "partial def minimizeAux [SampleableExt \u03b1] {\u03b2 : \u03b1 \u2192 Prop} [\u2200 x, Testable (\u03b2 x)] (cfg : Configuration)\n    (var : String) (x : SampleableExt.proxy \u03b1) (n : Nat) :\n    OptionT Gen (\u03a3 x, TestResult (\u03b2 (SampleableExt.interp x))) := do\n  let candidates := SampleableExt.shrink.shrink x\n  if cfg.traceShrinkCandidates then\n    slimTrace s!\"Candidates for {var} := {repr x}:\\n  {repr candidates}\"\n  for candidate in candidates do\n    if cfg.traceShrinkCandidates then\n      slimTrace s!\"Trying {var} := {repr candidate}\"\n    let res \u2190 OptionT.lift $ Testable.runProp (\u03b2 (SampleableExt.interp candidate)) cfg true\n    if res.isFailure then\n      if cfg.traceShrink then\n        slimTrace s!\"{var} shrunk to {repr candidate} from {repr x}\"\n      let currentStep := OptionT.lift $ pure $ Sigma.mk candidate (addShrinks (n + 1) res)\n      let nextStep := minimizeAux cfg var candidate (n + 1)\n      return \u2190(nextStep <|> currentStep)\n  if cfg.traceShrink then\n    slimTrace s!\"No shrinking possible for {var} := {repr x}\"\n  failure", "start": [317, 1], "end": [340, 10], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.minimize", "code": "def minimize [SampleableExt \u03b1] {\u03b2 : \u03b1 \u2192 Prop} [\u2200 x, Testable (\u03b2 x)] (cfg : Configuration)\n    (var : String) (x : SampleableExt.proxy \u03b1) (r : TestResult (\u03b2 $ SampleableExt.interp x)) :\n    Gen (\u03a3 x, TestResult (\u03b2 $ SampleableExt.interp x)) := do\n  if cfg.traceShrink then\n     slimTrace \"Shrink\"\n     slimTrace s!\"Attempting to shrink {var} := {repr x}\"\n  let res \u2190 OptionT.run $ minimizeAux cfg var x 0\n  pure $ res.getD \u27e8x, r\u27e9", "start": [342, 1], "end": [351, 25], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.varTestable", "code": "instance varTestable [SampleableExt \u03b1] {\u03b2 : \u03b1 \u2192 Prop} [\u2200 x, Testable (\u03b2 x)] :\n    Testable (NamedBinder var $ \u2200 x : \u03b1, \u03b2 x) where\n  run := \u03bb cfg min => do\n    let x \u2190 SampleableExt.sample\n    if cfg.traceSuccesses || cfg.traceDiscarded then\n      slimTrace s!\"{var} := {repr x}\"\n    let r \u2190 Testable.runProp (\u03b2 $ SampleableExt.interp x) cfg false\n    let \u27e8finalX, finalR\u27e9 \u2190\n      if isFailure r then\n        if cfg.traceSuccesses then\n          slimTrace s!\"{var} := {repr x} is a failure\"\n        if min then\n          minimize cfg var x r\n        else\n          pure $ \u27e8x, r\u27e9\n      else\n        pure $ \u27e8x, r\u27e9\n    pure $ addVarInfo var finalX (\u00b7 $ SampleableExt.interp finalX) finalR", "start": [353, 1], "end": [372, 74], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.propVarTestable", "code": "instance propVarTestable {\u03b2 : Prop \u2192 Prop} [\u2200 b : Bool, Testable (\u03b2 b)] :\n  Testable (NamedBinder var $ \u2200 p : Prop, \u03b2 p)\nwhere\n  run := \u03bb cfg min =>\n    imp (\u03bb h (b : Bool) => h b) <$> Testable.runProp (NamedBinder var $ \u2200 b : Bool, \u03b2 b) cfg min", "start": [374, 1], "end": [379, 97], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.unusedVarTestable", "code": "instance (priority := high) unusedVarTestable [Nonempty \u03b1] [Testable \u03b2] :\n  Testable (NamedBinder var $ \u2200 _x : \u03b1, \u03b2)\nwhere\n  run := \u03bb cfg min => do\n    if cfg.traceDiscarded || cfg.traceSuccesses then\n      slimTrace s!\"{var} is unused\"\n    let r \u2190 Testable.runProp \u03b2 cfg min\n    let finalR := addInfo s!\"{var} is irrelevant (unused)\" id r\n    pure $ imp (\u00b7 $ Classical.ofNonempty) finalR (PSum.inr $ \u03bb x _ => x)", "start": [381, 1], "end": [389, 73], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.decidableTestable", "code": "instance (priority := low) decidableTestable {p : Prop} [PrintableProp p] [Decidable p] :\n    Testable p where\n  run := \u03bb _ _ =>\n    if h : p then\n      pure $ success (PSum.inr h)\n    else\n      let s := printProp p\n      pure $ failure h [s!\"issue: {s} does not hold\"] 0", "start": [391, 1], "end": [398, 56], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Eq.printableProp", "code": "instance Eq.printableProp [Repr \u03b1] {x y : \u03b1} : PrintableProp (x = y) where\n  printProp := s!\"{repr x} = {repr y}\"", "start": [404, 1], "end": [405, 39], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Ne.printableProp", "code": "instance Ne.printableProp [Repr \u03b1] {x y : \u03b1} : PrintableProp (x \u2260 y) where\n  printProp := s!\"{repr x} \u2260 {repr y}\"", "start": [407, 1], "end": [408, 39], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.LE.printableProp", "code": "instance LE.printableProp [Repr \u03b1] [LE \u03b1] {x y : \u03b1} : PrintableProp (x \u2264 y) where\n  printProp := s!\"{repr x} \u2264 {repr y}\"", "start": [410, 1], "end": [411, 39], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.LT.printableProp", "code": "instance LT.printableProp [Repr \u03b1] [LT \u03b1] {x y : \u03b1} : PrintableProp (x < y) where\n  printProp := s!\"{repr x} < {repr y}\"", "start": [413, 1], "end": [414, 39], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.And.printableProp", "code": "instance And.printableProp [PrintableProp x] [PrintableProp y]  : PrintableProp (x \u2227 y) where\n  printProp := s!\"{printProp x} \u2227 {printProp y}\"", "start": [416, 1], "end": [417, 49], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Or.printableProp", "code": "instance Or.printableProp [PrintableProp x] [PrintableProp y]  : PrintableProp (x \u2228 y) where\n  printProp := s!\"{printProp x} \u2228 {printProp y}\"", "start": [419, 1], "end": [420, 49], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Iff.printableProp", "code": "instance Iff.printableProp [PrintableProp x] [PrintableProp y]  : PrintableProp (x \u2194 y) where\n  printProp := s!\"{printProp x} \u2194 {printProp y}\"", "start": [422, 1], "end": [423, 49], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Imp.printableProp", "code": "instance Imp.printableProp [PrintableProp x] [PrintableProp y]  : PrintableProp (x \u2192 y) where\n  printProp := s!\"{printProp x} \u2192 {printProp y}\"", "start": [425, 1], "end": [426, 49], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Not.printableProp", "code": "instance Not.printableProp [PrintableProp x] : PrintableProp (\u00acx) where\n  printProp := s!\"\u00ac{printProp x}\"", "start": [428, 1], "end": [429, 34], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.True.printableProp", "code": "instance True.printableProp : PrintableProp True where\n  printProp := \"True\"", "start": [431, 1], "end": [432, 22], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.False.printableProp", "code": "instance False.printableProp : PrintableProp False where\n  printProp := \"False\"", "start": [434, 1], "end": [435, 23], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Bool.printableProp", "code": "instance Bool.printableProp {b : Bool} : PrintableProp b where\n  printProp := if b then \"true\" else \"false\"", "start": [437, 1], "end": [438, 45], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.retry", "code": "def retry (cmd : Rand (TestResult p)) : Nat \u2192 Rand (TestResult p)\n  | 0 => pure $ TestResult.gaveUp 1\n  | n+1 => do\n    let r \u2190 cmd\n    match r with\n    | success hp => pure $ success hp\n    | TestResult.failure h xs n => pure $ failure h xs n\n    | gaveUp _ => retry cmd n", "start": [445, 1], "end": [453, 30], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.giveUp", "code": "def giveUp (x : Nat) : TestResult p \u2192 TestResult p\n  | success (PSum.inl ()) => gaveUp x\n  | success (PSum.inr p) => success $ (PSum.inr p)\n  | gaveUp n => gaveUp $ n + x\n  | TestResult.failure h xs n => failure h xs n", "start": [455, 1], "end": [460, 48], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.runSuiteAux", "code": "def Testable.runSuiteAux (p : Prop) [Testable p] (cfg : Configuration) :\n    TestResult p \u2192 Nat \u2192 Rand (TestResult p)\n| r, 0 => pure r\n| r, n+1 => do\n  let size := (cfg.numInst - n - 1) * cfg.maxSize / cfg.numInst\n  if cfg.traceSuccesses then\n    slimTrace s!\"New sample\"\n    slimTrace s!\"Retrying up to {cfg.numRetries} times until guards hold\"\n  let x \u2190 retry (ReaderT.run (Testable.runProp p cfg true) \u27e8size\u27e9) cfg.numRetries\n  match x with\n  | (success (PSum.inl ())) => runSuiteAux p cfg r n\n  | (gaveUp g) => runSuiteAux p cfg (giveUp g r) n\n  | _ => pure $ x", "start": [462, 1], "end": [475, 18], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.runSuite", "code": "def Testable.runSuite (p : Prop) [Testable p] (cfg : Configuration := {}) : Rand (TestResult p) :=\n  Testable.runSuiteAux p cfg (success $ PSum.inl ()) cfg.numInst", "start": [477, 1], "end": [479, 65], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.checkIO", "code": "def Testable.checkIO (p : Prop) [Testable p] (cfg : Configuration := {}) : BaseIO (TestResult p) :=\n  match cfg.randomSeed with\n  | none => IO.runRand (Testable.runSuite p cfg)\n  | some seed => IO.runRandWith seed (Testable.runSuite p cfg)", "start": [481, 1], "end": [485, 63], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Decorations.addDecorations", "code": "partial def addDecorations (e : Expr) : Expr :=\n  e.replace $ \u03bb expr =>\n    match expr with\n    | Expr.forallE name type body data =>\n      let n := name.toString\n      let newType := addDecorations type\n      let newBody := addDecorations body\n      let rest := Expr.forallE name newType newBody data\n      some $ mkApp2 (mkConst `SlimCheck.NamedBinder) (mkStrLit n) rest\n    | _ => none", "start": [493, 1], "end": [504, 16], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Decorations.DecorationsOf", "code": "@[nolint unusedArguments]\nabbrev DecorationsOf (_p : Prop) := Prop", "start": [506, 1], "end": [510, 41], "kind": "commanddeclaration"}, {"full_name": "SlimCheck.Testable.check", "code": "def Testable.check (p : Prop) (cfg : Configuration := {})\n    (p' : Decorations.DecorationsOf p := by mk_decorations) [Testable p'] : IO PUnit := do\n  match \u2190 Testable.checkIO p' cfg with\n  | TestResult.success _ => if !cfg.quiet then IO.println \"Success\"\n  | TestResult.gaveUp n => if !cfg.quiet then IO.println s!\"Gave up {n} times\"\n  | TestResult.failure _ xs n => throw (IO.userError $ formatFailure \"Found problems!\" xs n)", "start": [534, 1], "end": [540, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Explode/Pretty.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Explode/Datatypes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Explode.padRight", "code": "def padRight (mds : List MessageData) : MetaM (List MessageData) := do\n  let mut maxLength := 0\n  for md in mds do\n    maxLength := max maxLength (\u2190 md.toString).length\n\n  let pad (md : MessageData) : MetaM MessageData := do\n    let padWidth : Nat := maxLength - (\u2190 md.toString).length\n    return md ++ \"\".pushn ' ' padWidth\n\n  mds.mapM pad", "start": [18, 1], "end": [37, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Explode.rowToMessageData", "code": "def rowToMessageData :\n    List MessageData \u2192 List MessageData \u2192 List MessageData \u2192 List Entry \u2192 MetaM MessageData\n  | line :: lines, dep :: deps, thm :: thms, en :: es => do\n    let pipes := String.join (List.replicate en.depth \"\u2502 \")\n    let pipes := match en.status with\n      | Status.sintro => s!\"\u251c \"\n      | Status.intro  => s!\"\u2502 {pipes}\u250c \"\n      | Status.cintro => s!\"\u2502 {pipes}\u251c \"\n      | Status.lam    => s!\"\u2502 {pipes}\"\n      | Status.reg    => s!\"\u2502 {pipes}\"\n\n    let row := m!\"{line}\u2502{dep}\u2502 {thm} {pipes}{en.type}\\n\"\n    return (\u2190 rowToMessageData lines deps thms es).compose row\n  | _, _, _, _ => return MessageData.nil", "start": [39, 1], "end": [53, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Explode.entriesToMessageData", "code": "def entriesToMessageData (entries : Entries) : MetaM MessageData := do\n  let paddedLines \u2190 padRight <| entries.l.map fun entry => m!\"{entry.line!}\"\n  let paddedDeps  \u2190 padRight <| entries.l.map fun entry =>\n    String.intercalate \",\" <| entry.deps.map (fun dep => (dep.map toString).getD \"_\")\n  let paddedThms \u2190 padRight <| entries.l.map (\u00b7.thm)\n\n  rowToMessageData paddedLines paddedDeps paddedThms entries.l", "start": [55, 1], "end": [65, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "imports": ["Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "jacobiSym", "code": "def jacobiSym (a : \u2124) (b : \u2115) : \u2124 :=\n  (b.factors.pmap (fun p pp => @legendreSym p \u27e8pp\u27e9 a) fun _ pf => prime_of_mem_factors pf).prod", "start": [79, 1], "end": [81, 96], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.zero_right", "code": "@[simp]\ntheorem zero_right (a : \u2124) : J(a | 0) = 1", "start": [97, 1], "end": [100, 64], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.one_right", "code": "@[simp]\ntheorem one_right (a : \u2124) : J(a | 1) = 1", "start": [103, 1], "end": [106, 63], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.legendreSym.to_jacobiSym", "code": "theorem legendreSym.to_jacobiSym (p : \u2115) [fp : Fact p.Prime] (a : \u2124) : legendreSym p a = J(a | p)", "start": [109, 1], "end": [112, 98], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mul_right'", "code": "theorem mul_right' (a : \u2124) {b\u2081 b\u2082 : \u2115} (hb\u2081 : b\u2081 \u2260 0) (hb\u2082 : b\u2082 \u2260 0) :\n    J(a | b\u2081 * b\u2082) = J(a | b\u2081) * J(a | b\u2082)", "start": [115, 1], "end": [120, 16], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mul_right", "code": "theorem mul_right (a : \u2124) (b\u2081 b\u2082 : \u2115) [NeZero b\u2081] [NeZero b\u2082] :\n    J(a | b\u2081 * b\u2082) = J(a | b\u2081) * J(a | b\u2082)", "start": [123, 1], "end": [126, 45], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.trichotomy", "code": "theorem trichotomy (a : \u2124) (b : \u2115) : J(a | b) = 0 \u2228 J(a | b) = 1 \u2228 J(a | b) = -1", "start": [129, 1], "end": [138, 52], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.one_left", "code": "@[simp]\ntheorem one_left (b : \u2115) : J(1 | b) = 1", "start": [141, 1], "end": [149, 34], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mul_left", "code": "theorem mul_left (a\u2081 a\u2082 : \u2124) (b : \u2115) : J(a\u2081 * a\u2082 | b) = J(a\u2081 | b) * J(a\u2082 | b)", "start": [152, 1], "end": [157, 71], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.eq_zero_iff_not_coprime", "code": "theorem eq_zero_iff_not_coprime {a : \u2124} {b : \u2115} [NeZero b] : J(a | b) = 0 \u2194 a.gcd b \u2260 1", "start": [160, 1], "end": [169, 19], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.ne_zero", "code": "protected theorem ne_zero {a : \u2124} {b : \u2115} (h : a.gcd b = 1) : J(a | b) \u2260 0", "start": [172, 1], "end": [177, 53], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.eq_zero_iff", "code": "theorem eq_zero_iff {a : \u2124} {b : \u2115} : J(a | b) = 0 \u2194 b \u2260 0 \u2227 a.gcd b \u2260 1", "start": [180, 1], "end": [186, 64], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.zero_left", "code": "theorem zero_left {b : \u2115} (hb : 1 < b) : J(0 | b) = 0", "start": [189, 1], "end": [192, 59], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.eq_one_or_neg_one", "code": "theorem eq_one_or_neg_one {a : \u2124} {b : \u2115} (h : a.gcd b = 1) : J(a | b) = 1 \u2228 J(a | b) = -1", "start": [195, 1], "end": [197, 55], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.pow_left", "code": "theorem pow_left (a : \u2124) (e b : \u2115) : J(a ^ e | b) = J(a | b) ^ e", "start": [200, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.pow_right", "code": "theorem pow_right (a : \u2124) (b e : \u2115) : J(a | b ^ e) = J(a | b) ^ e", "start": [206, 1], "end": [212, 59], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.sq_one", "code": "theorem sq_one {a : \u2124} {b : \u2115} (h : a.gcd b = 1) : J(a | b) ^ 2 = 1", "start": [215, 1], "end": [217, 60], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.sq_one'", "code": "theorem sq_one' {a : \u2124} {b : \u2115} (h : a.gcd b = 1) : J(a ^ 2 | b) = 1", "start": [220, 1], "end": [221, 99], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mod_left", "code": "theorem mod_left (a : \u2124) (b : \u2115) : J(a | b) = J(a % b | b)", "start": [224, 1], "end": [236, 32], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mod_left'", "code": "theorem mod_left' {a\u2081 a\u2082 : \u2124} {b : \u2115} (h : a\u2081 % b = a\u2082 % b) : J(a\u2081 | b) = J(a\u2082 | b)", "start": [239, 1], "end": [241, 31], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.prime_dvd_of_eq_neg_one", "code": "theorem prime_dvd_of_eq_neg_one {p : \u2115} [Fact p.Prime] {a : \u2124} (h : J(a | p) = -1) {x y : \u2124}\n    (hxy : \u2191p \u2223 (x ^ 2 - a * y ^ 2 : \u2124)) : \u2191p \u2223 x \u2227 \u2191p \u2223 y", "start": [244, 1], "end": [249, 50], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.list_prod_left", "code": "theorem list_prod_left {l : List \u2124} {n : \u2115} : J(l.prod | n) = (l.map fun a => J(a | n)).prod", "start": [252, 1], "end": [256, 64], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.list_prod_right", "code": "theorem list_prod_right {a : \u2124} {l : List \u2115} (hl : \u2200 n \u2208 l, n \u2260 0) :\n    J(a | l.prod) = (l.map fun n => J(a | n)).prod", "start": [259, 1], "end": [270, 77], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.eq_neg_one_at_prime_divisor_of_eq_neg_one", "code": "theorem eq_neg_one_at_prime_divisor_of_eq_neg_one {a : \u2124} {n : \u2115} (h : J(a | n) = -1) :\n    \u2203 (p : \u2115) (_ : p.Prime), p \u2223 n \u2227 J(a | p) = -1", "start": [273, 1], "end": [283, 76], "kind": "commanddeclaration"}, {"full_name": "ZMod.nonsquare_of_jacobiSym_eq_neg_one", "code": "theorem nonsquare_of_jacobiSym_eq_neg_one {a : \u2124} {b : \u2115} (h : J(a | b) = -1) :\n    \u00acIsSquare (a : ZMod b)", "start": [292, 1], "end": [298, 18], "kind": "commanddeclaration"}, {"full_name": "ZMod.nonsquare_iff_jacobiSym_eq_neg_one", "code": "theorem nonsquare_iff_jacobiSym_eq_neg_one {a : \u2124} {p : \u2115} [Fact p.Prime] :\n    J(a | p) = -1 \u2194 \u00acIsSquare (a : ZMod p)", "start": [301, 1], "end": [305, 37], "kind": "commanddeclaration"}, {"full_name": "ZMod.isSquare_of_jacobiSym_eq_one", "code": "theorem isSquare_of_jacobiSym_eq_one {a : \u2124} {p : \u2115} [Fact p.Prime] (h : J(a | p) = 1) :\n    IsSquare (a : ZMod p)", "start": [308, 1], "end": [311, 82], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.value_at", "code": "theorem value_at (a : \u2124) {R : Type*} [CommSemiring R] (\u03c7 : R \u2192* \u2124)\n    (hp : \u2200 (p : \u2115) (pp : p.Prime) (_ : p \u2260 2), @legendreSym p \u27e8pp\u27e9 a = \u03c7 p) {b : \u2115} (hb : Odd b) :\n    J(a | b) = \u03c7 b", "start": [323, 1], "end": [331, 79], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.at_neg_one", "code": "theorem at_neg_one {b : \u2115} (hb : Odd b) : J(-1 | b) = \u03c7\u2084 b", "start": [334, 1], "end": [338, 79], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.neg", "code": "protected theorem neg (a : \u2124) {b : \u2115} (hb : Odd b) : J(-a | b) = \u03c7\u2084 b * J(a | b)", "start": [341, 1], "end": [343, 51], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.at_two", "code": "theorem at_two {b : \u2115} (hb : Odd b) : J(2 | b) = \u03c7\u2088 b", "start": [346, 1], "end": [348, 72], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.at_neg_two", "code": "theorem at_neg_two {b : \u2115} (hb : Odd b) : J(-2 | b) = \u03c7\u2088' b", "start": [351, 1], "end": [353, 80], "kind": "commanddeclaration"}, {"full_name": "qrSign", "code": "def qrSign (m n : \u2115) : \u2124 :=\n  J(\u03c7\u2084 m | n)", "start": [363, 1], "end": [365, 14], "kind": "commanddeclaration"}, {"full_name": "qrSign.neg_one_pow", "code": "theorem neg_one_pow {m n : \u2115} (hm : Odd m) (hn : Odd n) :\n    qrSign m n = (-1) ^ (m / 2 * (n / 2))", "start": [370, 1], "end": [376, 95], "kind": "commanddeclaration"}, {"full_name": "qrSign.sq_eq_one", "code": "theorem sq_eq_one {m n : \u2115} (hm : Odd m) (hn : Odd n) : qrSign m n ^ 2 = 1", "start": [379, 1], "end": [381, 76], "kind": "commanddeclaration"}, {"full_name": "qrSign.mul_left", "code": "theorem mul_left (m\u2081 m\u2082 n : \u2115) : qrSign (m\u2081 * m\u2082) n = qrSign m\u2081 n * qrSign m\u2082 n", "start": [384, 1], "end": [386, 62], "kind": "commanddeclaration"}, {"full_name": "qrSign.mul_right", "code": "theorem mul_right (m n\u2081 n\u2082 : \u2115) [NeZero n\u2081] [NeZero n\u2082] :\n    qrSign m (n\u2081 * n\u2082) = qrSign m n\u2081 * qrSign m n\u2082", "start": [389, 1], "end": [392, 35], "kind": "commanddeclaration"}, {"full_name": "qrSign.symm", "code": "protected theorem symm {m n : \u2115} (hm : Odd m) (hn : Odd n) : qrSign m n = qrSign n m", "start": [395, 1], "end": [397, 62], "kind": "commanddeclaration"}, {"full_name": "qrSign.eq_iff_eq", "code": "theorem eq_iff_eq {m n : \u2115} (hm : Odd m) (hn : Odd n) (x y : \u2124) :\n    qrSign m n * x = y \u2194 x = qrSign m n * y", "start": [400, 1], "end": [408, 61], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.quadratic_reciprocity'", "code": "theorem quadratic_reciprocity' {a b : \u2115} (ha : Odd a) (hb : Odd b) :\n    J(a | b) = qrSign b a * J(b | a)", "start": [415, 1], "end": [434, 89], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.quadratic_reciprocity", "code": "theorem quadratic_reciprocity {a b : \u2115} (ha : Odd a) (hb : Odd b) :\n    J(a | b) = (-1) ^ (a / 2 * (b / 2)) * J(b | a)", "start": [437, 1], "end": [440, 83], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.quadratic_reciprocity_one_mod_four", "code": "theorem quadratic_reciprocity_one_mod_four {a b : \u2115} (ha : a % 4 = 1) (hb : Odd b) :\n    J(a | b) = J(b | a)", "start": [443, 1], "end": [448, 62], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.quadratic_reciprocity_one_mod_four'", "code": "theorem quadratic_reciprocity_one_mod_four' {a b : \u2115} (ha : Odd a) (hb : b % 4 = 1) :\n    J(a | b) = J(b | a)", "start": [451, 1], "end": [455, 50], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.quadratic_reciprocity_three_mod_four", "code": "theorem quadratic_reciprocity_three_mod_four {a b : \u2115} (ha : a % 4 = 3) (hb : b % 4 = 3) :\n    J(a | b) = -J(b | a)", "start": [458, 1], "end": [464, 44], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mod_right'", "code": "theorem mod_right' (a : \u2115) {b : \u2115} (hb : Odd b) : J(a | b) = J(a | b % (4 * a))", "start": [467, 1], "end": [489, 49], "kind": "commanddeclaration"}, {"full_name": "jacobiSym.mod_right", "code": "theorem mod_right (a : \u2124) {b : \u2115} (hb : Odd b) : J(a | b) = J(a | b % (4 * a.natAbs))", "start": [492, 1], "end": [498, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/Panel/SelectionPanel.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Presentation/Expr.lean", "lake-packages/lean4/src/lean/Lean/Meta/ExprLens.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Panel/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.SubExpr.GoalsLocation.saveExprWithCtx", "code": "def Lean.SubExpr.GoalsLocation.saveExprWithCtx (loc : GoalsLocation) : MetaM ExprWithCtx :=\n  let mvarId := loc.mvarId\n  match loc.loc with\n  | .hyp fv =>\n    mvarId.withContext <|\n      ExprWithCtx.save (mkFVar fv)\n  | .hypType fv pos => mvarId.withContext do\n    let tp \u2190 Meta.inferType (mkFVar fv)\n    Meta.viewSubexpr (visit := fun _ => ExprWithCtx.save) pos tp\n  | .hypValue fv pos => mvarId.withContext do\n    let some val \u2190 fv.getValue?\n      | throwError \"fvar {mkFVar fv} is not a let-binding\"\n    Meta.viewSubexpr (visit := fun _ => ExprWithCtx.save) pos val\n  | .target pos => mvarId.withContext do\n    let tp \u2190 Meta.inferType (mkMVar mvarId)\n    Meta.viewSubexpr (visit := fun _ => ExprWithCtx.save) pos tp", "start": [6, 1], "end": [22, 65], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.GoalsLocationsToExprsParams", "code": "structure GoalsLocationsToExprsParams where\n  locations : Array (WithRpcRef Elab.ContextInfo \u00d7 SubExpr.GoalsLocation)", "start": [27, 1], "end": [28, 74], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.GoalsLocationsToExprsResponse", "code": "structure GoalsLocationsToExprsResponse where\n  exprs : Array (WithRpcRef ExprWithCtx)", "start": [32, 1], "end": [33, 41], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.goalsLocationsToExprs", "code": "@[server_rpc_method]\ndef goalsLocationsToExprs (args : GoalsLocationsToExprsParams) :\n    RequestM (RequestTask GoalsLocationsToExprsResponse) :=\n  RequestM.asTask do\n    let mut exprs := #[]\n    for \u27e8\u27e8ci\u27e9, loc\u27e9 in args.locations do\n      exprs := exprs.push \u27e8\u2190 ci.runMetaM {} loc.saveExprWithCtx\u27e9\n    return { exprs }", "start": [37, 1], "end": [45, 21], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.SelectionPanel", "code": "@[widget_module]\ndef SelectionPanel : Component PanelWidgetProps where\n  javascript := include_str \"..\" / \"..\" / \"..\" / \"build\" / \"js\" / \"presentSelection.js\"", "start": [47, 1], "end": [53, 88], "kind": "commanddeclaration"}]}
{"path": "lake-packages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Data/Html.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProofWidgets.PenroseDiagramProps", "code": "structure PenroseDiagramProps where\n  embeds : Array (String \u00d7 Html)\n  dsl    : String\n  sty    : String\n  sub    : String\n  deriving Inhabited", "start": [7, 1], "end": [12, 21], "kind": "commanddeclaration"}, {"full_name": "ProofWidgets.PenroseDiagram", "code": "@[widget_module]\ndef PenroseDiagram : Component PenroseDiagramProps where\n  javascript := include_str \"..\" / \"..\" / \"build\" / \"js\" / \"penroseDisplay.js\"", "start": [16, 1], "end": [38, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/BirkhoffSum/Average.lean", "imports": ["Mathlib/Dynamics/BirkhoffSum/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "birkhoffAverage", "code": "def birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (n : \u2115) (x : \u03b1) : M := (n : R)\u207b\u00b9 \u2022 birkhoffSum f g n x", "start": [33, 1], "end": [43, 99], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_zero", "code": "theorem birkhoffAverage_zero (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (x : \u03b1) :\n    birkhoffAverage R f g 0 x = 0", "start": [45, 1], "end": [46, 63], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_zero'", "code": "@[simp] theorem birkhoffAverage_zero' (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) : birkhoffAverage R f g 0 = 0", "start": [48, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_one", "code": "theorem birkhoffAverage_one (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (x : \u03b1) :\n    birkhoffAverage R f g 1 x = g x", "start": [51, 1], "end": [52, 65], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_one'", "code": "@[simp]\ntheorem birkhoffAverage_one' (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) : birkhoffAverage R f g 1 = g", "start": [54, 1], "end": [56, 38], "kind": "commanddeclaration"}, {"full_name": "map_birkhoffAverage", "code": "theorem map_birkhoffAverage (S : Type*) {F N : Type*}\n    [DivisionSemiring S] [AddCommMonoid N] [Module S N]\n    [AddMonoidHomClass F M N] (g' : F) (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (n : \u2115) (x : \u03b1) :\n    g' (birkhoffAverage R f g n x) = birkhoffAverage S f (g' \u2218 g) n x", "start": [58, 1], "end": [62, 77], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_congr_ring", "code": "theorem birkhoffAverage_congr_ring (S : Type*) [DivisionSemiring S] [Module S M]\n    (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (n : \u2115) (x : \u03b1) :\n    birkhoffAverage R f g n x = birkhoffAverage S f g n x", "start": [64, 1], "end": [67, 54], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_congr_ring'", "code": "theorem birkhoffAverage_congr_ring' (S : Type*) [DivisionSemiring S] [Module S M] :\n    birkhoffAverage (\u03b1 := \u03b1) (M := M) R = birkhoffAverage S", "start": [69, 1], "end": [71, 40], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.birkhoffAverage_eq", "code": "theorem Function.IsFixedPt.birkhoffAverage_eq [CharZero R] {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (h : IsFixedPt f x)\n    (g : \u03b1 \u2192 M) {n : \u2115} (hn : n \u2260 0) : birkhoffAverage R f g n x = g x", "start": [73, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "birkhoffAverage_apply_sub_birkhoffAverage", "code": "theorem birkhoffAverage_apply_sub_birkhoffAverage {\u03b1 M : Type*} (R : Type*) [DivisionRing R]\n    [AddCommGroup M] [Module R M] (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (n : \u2115) (x : \u03b1) :\n    birkhoffAverage R f g n (f x) - birkhoffAverage R f g n x =\n      (n : R)\u207b\u00b9 \u2022 (g (f^[n] x) - g x)", "start": [80, 1], "end": [87, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/CofilteredSystem.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "Mathlib/CategoryTheory/Filtered/Basic.lean", "Mathlib/Topology/Category/TopCat/Limits/Konig.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nonempty_sections_of_finite_cofiltered_system.init", "code": "theorem nonempty_sections_of_finite_cofiltered_system.init {J : Type u} [SmallCategory J]\n    [IsCofilteredOrEmpty J] (F : J \u2964 Type u) [hf : \u2200 j, Finite (F.obj j)]\n    [hne : \u2200 j, Nonempty (F.obj j)] : F.sections.Nonempty", "start": [63, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "nonempty_sections_of_finite_cofiltered_system", "code": "theorem nonempty_sections_of_finite_cofiltered_system {J : Type u} [Category.{w} J]\n    [IsCofilteredOrEmpty J] (F : J \u2964 Type v) [\u2200 j : J, Finite (F.obj j)]\n    [\u2200 j : J, Nonempty (F.obj j)] : F.sections.Nonempty", "start": [77, 1], "end": [99, 16], "kind": "commanddeclaration"}, {"full_name": "nonempty_sections_of_finite_inverse_system", "code": "theorem nonempty_sections_of_finite_inverse_system {J : Type u} [Preorder J] [IsDirected J (\u00b7 \u2264 \u00b7)]\n    (F : J\u1d52\u1d56 \u2964 Type v) [\u2200 j : J\u1d52\u1d56, Finite (F.obj j)] [\u2200 j : J\u1d52\u1d56, Nonempty (F.obj j)] :\n    F.sections.Nonempty", "start": [102, 1], "end": [118, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eventualRange", "code": "def eventualRange (j : J) :=\n  \u22c2 (i) (f : i \u27f6 j), range (F.map f)", "start": [129, 1], "end": [132, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mem_eventualRange_iff", "code": "theorem mem_eventualRange_iff {x : F.obj j} :\n    x \u2208 F.eventualRange j \u2194 \u2200 \u2983i\u2984 (f : i \u27f6 j), x \u2208 range (F.map f)", "start": [135, 1], "end": [137, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsMittagLeffler", "code": "def IsMittagLeffler : Prop :=\n  \u2200 j : J, \u2203 (i : _) (f : i \u27f6 j), \u2200 \u2983k\u2984 (g : k \u27f6 j), range (F.map f) \u2286 range (F.map g)", "start": [140, 1], "end": [146, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isMittagLeffler_iff_eventualRange", "code": "theorem isMittagLeffler_iff_eventualRange :\n    F.IsMittagLeffler \u2194 \u2200 j : J, \u2203 (i : _) (f : i \u27f6 j), F.eventualRange j = range (F.map f)", "start": [149, 1], "end": [153, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsMittagLeffler.subset_image_eventualRange", "code": "theorem IsMittagLeffler.subset_image_eventualRange (h : F.IsMittagLeffler) (f : j \u27f6 i) :\n    F.eventualRange i \u2286 F.map f '' F.eventualRange j", "start": [156, 1], "end": [161, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eventualRange_eq_range_precomp", "code": "theorem eventualRange_eq_range_precomp (f : i \u27f6 j) (g : j \u27f6 k)\n    (h : F.eventualRange k = range (F.map g)) : F.eventualRange k = range (F.map <| f \u226b g)", "start": [164, 1], "end": [169, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isMittagLeffler_of_surjective", "code": "theorem isMittagLeffler_of_surjective (h : \u2200 \u2983i j : J\u2984 (f : i \u27f6 j), (F.map f).Surjective) :\n    F.IsMittagLeffler", "start": [172, 1], "end": [174, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toPreimages", "code": "@[simps]\ndef toPreimages : J \u2964 Type v where\n  obj j := \u22c2 f : j \u27f6 i, F.map f \u207b\u00b9' s\n  map g := MapsTo.restrict (F.map g) _ _ fun x h => by\n    rw [mem_iInter] at h \u22a2\n    intro f\n    rw [\u2190 mem_preimage, preimage_preimage, mem_preimage]\n    convert h (g \u226b f); rw [F.map_comp]; rfl\n  map_id j := by\n    simp_rw [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp f g := by\n    simp_rw [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl", "start": [177, 1], "end": [192, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toPreimages_finite", "code": "instance toPreimages_finite [\u2200 j, Finite (F.obj j)] : \u2200 j, Finite ((F.toPreimages s).obj j) :=\n  fun _ => Subtype.finite", "start": [195, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eventualRange_mapsTo", "code": "theorem eventualRange_mapsTo (f : j \u27f6 i) :\n    (F.eventualRange j).MapsTo (F.map f) (F.eventualRange i)", "start": [201, 1], "end": [208, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsMittagLeffler.eq_image_eventualRange", "code": "theorem IsMittagLeffler.eq_image_eventualRange (h : F.IsMittagLeffler) (f : j \u27f6 i) :\n    F.eventualRange i = F.map f '' F.eventualRange j", "start": [211, 1], "end": [213, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eventualRange_eq_iff", "code": "theorem eventualRange_eq_iff {f : i \u27f6 j} :\n    F.eventualRange j = range (F.map f) \u2194\n      \u2200 \u2983k\u2984 (g : k \u27f6 i), range (F.map f) \u2286 range (F.map <| g \u226b f)", "start": [216, 1], "end": [224, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isMittagLeffler_iff_subset_range_comp", "code": "theorem isMittagLeffler_iff_subset_range_comp : F.IsMittagLeffler \u2194\n    \u2200 j : J, \u2203 (i : _) (f : i \u27f6 j), \u2200 \u2983k\u2984 (g : k \u27f6 i), range (F.map f) \u2286 range (F.map <| g \u226b f)", "start": [227, 1], "end": [229, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsMittagLeffler.toPreimages", "code": "theorem IsMittagLeffler.toPreimages (h : F.IsMittagLeffler) : (F.toPreimages s).IsMittagLeffler", "start": [232, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isMittagLeffler_of_exists_finite_range", "code": "theorem isMittagLeffler_of_exists_finite_range\n    (h : \u2200 j : J, \u2203 (i : _) (f : i \u27f6 j), (range <| F.map f).Finite) : F.IsMittagLeffler", "start": [253, 1], "end": [265, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEventualRanges", "code": "@[simps]\ndef toEventualRanges : J \u2964 Type v where\n  obj j := F.eventualRange j\n  map f := (F.eventualRange_mapsTo f).restrict _ _ _\n  map_id i := by\n    simp_rw [MapsTo.restrict, Subtype.map, F.map_id]\n    ext\n    rfl\n  map_comp _ _ := by\n    simp_rw [MapsTo.restrict, Subtype.map, F.map_comp]\n    rfl", "start": [268, 1], "end": [279, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEventualRanges_finite", "code": "instance toEventualRanges_finite [\u2200 j, Finite (F.obj j)] : \u2200 j, Finite (F.toEventualRanges.obj j) :=\n  fun _ => Subtype.finite", "start": [282, 1], "end": [283, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEventualRangesSectionsEquiv", "code": "def toEventualRangesSectionsEquiv : F.toEventualRanges.sections \u2243 F.sections where\n  toFun s := \u27e8_, fun f => Subtype.coe_inj.2 <| s.prop f\u27e9\n  invFun s :=\n    \u27e8fun j => \u27e8_, mem_iInter\u2082.2 fun i f => \u27e8_, s.prop f\u27e9\u27e9, fun f => Subtype.ext <| s.prop f\u27e9\n  left_inv _ := by\n    ext\n    rfl\n  right_inv _ := by\n    ext\n    rfl", "start": [286, 1], "end": [297, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.surjective_toEventualRanges", "code": "theorem surjective_toEventualRanges (h : F.IsMittagLeffler) \u2983i j\u2984 (f : i \u27f6 j) :\n    (F.toEventualRanges.map f).Surjective", "start": [300, 1], "end": [305, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEventualRanges_nonempty", "code": "theorem toEventualRanges_nonempty (h : F.IsMittagLeffler) [\u2200 j : J, Nonempty (F.obj j)] (j : J) :\n    Nonempty (F.toEventualRanges.obj j)", "start": [308, 1], "end": [313, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.thin_diagram_of_surjective", "code": "theorem thin_diagram_of_surjective (Fsur : \u2200 \u2983i j : J\u2984 (f : i \u27f6 j), (F.map f).Surjective) {i j}\n    (f g : i \u27f6 j) : F.map f = F.map g", "start": [316, 1], "end": [320, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toPreimages_nonempty_of_surjective", "code": "theorem toPreimages_nonempty_of_surjective [hFn : \u2200 j : J, Nonempty (F.obj j)]\n    (Fsur : \u2200 \u2983i j : J\u2984 (f : i \u27f6 j), (F.map f).Surjective) (hs : s.Nonempty) (j) :\n    Nonempty ((F.toPreimages s).obj j)", "start": [323, 1], "end": [331, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eval_section_injective_of_eventually_injective", "code": "theorem eval_section_injective_of_eventually_injective {j}\n    (Finj : \u2200 (i) (f : i \u27f6 j), (F.map f).Injective) (i) (f : i \u27f6 j) :\n    (fun s : F.sections => s.val j).Injective", "start": [334, 1], "end": [342, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eval_section_surjective_of_surjective", "code": "theorem eval_section_surjective_of_surjective (i : J) :\n    (fun s : F.sections => s.val i).Surjective", "start": [350, 1], "end": [359, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.eventually_injective", "code": "theorem eventually_injective [Nonempty J] [Finite F.sections] :\n    \u2203 j, \u2200 (i) (f : i \u27f6 j), (F.map f).Injective", "start": [362, 1], "end": [373, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/ZModuleEquivalence.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.forget\u2082AddCommGroupFull", "code": "instance forget\u2082AddCommGroupFull : Full (forget\u2082 (ModuleCat \u2124) AddCommGroupCat.{u}) where\n  preimage {A B}\n    f := @LinearMap.mk _ _ _ _ _ _ _ _ _ A.isModule B.isModule\n        { toFun := f,\n          map_add' := AddMonoidHom.map_add (show A.carrier \u2192+ B.carrier from f) }\n        (fun n x => by\n          convert AddMonoidHom.map_zsmul (show A.carrier \u2192+ B.carrier from f) x n <;>\n            ext <;> apply int_smul_eq_zsmul)", "start": [28, 1], "end": [39, 45], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.forget\u2082_addCommGroupCat_essSurj", "code": "instance forget\u2082_addCommGroupCat_essSurj : EssSurj (forget\u2082 (ModuleCat \u2124) AddCommGroupCat.{u}) where\n  mem_essImage A :=\n    \u27e8ModuleCat.of \u2124 A,\n      \u27e8{  hom := \ud835\udfd9 A\n          inv := \ud835\udfd9 A }\u27e9\u27e9", "start": [43, 1], "end": [48, 25], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.forget\u2082AddCommGroupIsEquivalence", "code": "noncomputable instance forget\u2082AddCommGroupIsEquivalence :\n    IsEquivalence (forget\u2082 (ModuleCat \u2124) AddCommGroupCat.{u}) :=\n  Equivalence.ofFullyFaithfullyEssSurj (forget\u2082 (ModuleCat \u2124) AddCommGroupCat)", "start": [52, 1], "end": [54, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Kernels.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Preadditive.lean", "Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean", "Mathlib/Algebra/Category/GroupCat/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCommGroupCat.kernelCone", "code": "def kernelCone : KernelFork f :=\n  KernelFork.of\u03b9 (Z := of f.ker) f.ker.subtype <| ext fun x => x.casesOn fun _ hx => hx", "start": [22, 1], "end": [24, 88], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.kernelIsLimit", "code": "def kernelIsLimit : IsLimit <| kernelCone f :=\n  Fork.IsLimit.mk _\n    (fun s => (by exact Fork.\u03b9 s : _ \u2192+ G).codRestrict _ <| fun c => f.mem_ker.mpr <|\n      by exact FunLike.congr_fun s.condition c)\n    (fun _ => by rfl)\n    (fun _ _ h => ext fun x => Subtype.ext_iff_val.mpr <| by exact FunLike.congr_fun h x)", "start": [26, 1], "end": [32, 90], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.cokernelCocone", "code": "def cokernelCocone : CokernelCofork f :=\n  CokernelCofork.of\u03c0 (Z := of <| H \u29f8 f.range) (mk' f.range) <| ext fun x =>\n    (eq_zero_iff _).mpr \u27e8x, rfl\u27e9", "start": [34, 1], "end": [37, 33], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.cokernelIsColimit", "code": "def cokernelIsColimit : IsColimit <| cokernelCocone f :=\n  Cofork.IsColimit.mk _\n    (fun s => lift _ _ <| (range_le_ker_iff _ _).mpr <| CokernelCofork.condition s)\n    (fun _ => rfl)\n    (fun _ _ h => have : Epi (cokernelCocone f).\u03c0 := (epi_iff_surjective _).mpr <| mk'_surjective _\n      (cancel_epi _).mp <| by simpa only [parallelPair_obj_one] using h)", "start": [39, 1], "end": [45, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean", "imports": ["Mathlib/CategoryTheory/Sites/Coherent.lean", "Mathlib/Topology/Category/CompHaus/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CompHaus.EffectiveEpiFamily.relation", "code": "def relation : Setoid (finiteCoproduct X) where\n  r a b := \u2203 (Z : CompHaus.{u}) (z : Z)\n    (fst : Z \u27f6 X a.fst) (snd : Z \u27f6 X b.fst),\n    fst \u226b \u03c0 _ = snd \u226b \u03c0 _ \u2227 fst z = a.snd \u2227 snd z = b.snd\n  iseqv := by\n    constructor\n    \u00b7 rintro \u27e8a,x\u27e9\n      refine \u27e8X a, x, \ud835\udfd9 _, \ud835\udfd9 _, by simp, rfl, rfl\u27e9\n    \u00b7 rintro \u27e8a,x\u27e9 \u27e8b,y\u27e9 \u27e8Z,z,fst,snd,w,h1,h2\u27e9\n      exact \u27e8Z,z,snd,fst,w.symm,h2,h1\u27e9\n    \u00b7 rintro \u27e8a,x\u27e9 \u27e8b,y\u27e9 \u27e8z,c\u27e9 \u27e8Z,z,fstZ,sndZ,hZ,hZ1,hZ2\u27e9 \u27e8W,w,fstW,sndW,hW,hW1,hW2\u27e9\n      refine \u27e8pullback sndZ fstW, \u27e8\u27e8z,w\u27e9, by dsimp; rw [hZ2, hW1]\u27e9,\n        pullback.fst _ _ \u226b fstZ, pullback.snd _ _ \u226b sndW, ?_, hZ1, hW2\u27e9\n      dsimp at *\n      simp only [Category.assoc, hZ, \u2190 hW]\n      apply ContinuousMap.ext\n      rintro \u27e8\u27e8u,v\u27e9,h\u27e9\n      change \u03c0 b (sndZ u) = \u03c0 b (fstW v)\n      rw [h]", "start": [44, 1], "end": [66, 13], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03b9Fun", "code": "def \u03b9Fun : Quotient (relation \u03c0) \u2192 B :=\n  Quotient.lift (fun \u27e8a,x\u27e9 => \u03c0 a x) <| by\n    rintro \u27e8a,x\u27e9 \u27e8b,y\u27e9 \u27e8Z,z,fst,snd,h,hx,hy\u27e9\n    dsimp at *\n    rw [\u2190 hx, \u2190 hy]\n    apply_fun (fun t => t z) at h\n    exact h", "start": [68, 1], "end": [78, 12], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03b9Fun_continuous", "code": "lemma \u03b9Fun_continuous : Continuous (\u03b9Fun \u03c0) := by\n  apply Continuous.quotient_lift\n  apply continuous_sigma\n  intro a\n  exact (\u03c0 a).continuous", "start": [80, 1], "end": [84, 25], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03b9Fun_injective", "code": "lemma \u03b9Fun_injective : (\u03b9Fun \u03c0).Injective := by\n  rintro \u27e8\u27e8a,x\u27e9\u27e9 \u27e8\u27e8b,y\u27e9\u27e9 (h : \u03c0 _ _ = \u03c0 _ _)\n  apply Quotient.sound'\n  refine \u27e8pullback (\u03c0 a) (\u03c0 b), \u27e8\u27e8x,y\u27e9,h\u27e9, pullback.fst _ _, pullback.snd _ _, ?_, rfl, rfl\u27e9\n  ext \u27e8_, h\u27e9; exact h", "start": [86, 1], "end": [90, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.EffectiveEpiFamily.QB", "code": "def QB : CompHaus.{u} :=\n  haveI : T2Space (Quotient <| relation \u03c0) :=\n    \u27e8fun _ _ h => separated_by_continuous (\u03b9Fun_continuous \u03c0) <| (\u03b9Fun_injective \u03c0).ne h \u27e9\n  CompHaus.of (Quotient <| relation \u03c0)", "start": [92, 1], "end": [98, 39], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03b9Hom", "code": "def \u03b9Hom : (QB \u03c0) \u27f6 B := \u27e8\u03b9Fun \u03c0, \u03b9Fun_continuous \u03c0\u27e9", "start": [100, 1], "end": [101, 53], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03b9", "code": "noncomputable\ndef \u03b9 : (QB \u03c0) \u2245 B :=\n  haveI : IsIso (\u03b9Hom \u03c0) := by\n    apply isIso_of_bijective\n    refine \u27e8\u03b9Fun_injective _, ?_\u27e9\n    intro b\n    obtain \u27e8a,x,h\u27e9 := surj b\n    refine \u27e8Quotient.mk _ \u27e8a,x\u27e9, h\u27e9\n  asIso (\u03b9Hom \u03c0)", "start": [103, 1], "end": [114, 17], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03c0'", "code": "def \u03c0' : (a : \u03b1) \u2192 (X a \u27f6 QB \u03c0) := fun a =>\n  { toFun := fun x => Quotient.mk _ \u27e8a, x\u27e9\n    continuous_toFun := by\n      apply Continuous.comp\n      apply continuous_quot_mk\n      apply continuous_sigmaMk (\u03c3 := fun a => X a) }", "start": [116, 1], "end": [124, 53], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.structAux", "code": "def structAux : EffectiveEpiFamilyStruct X (\u03c0' \u03c0) where\n  desc := fun {W} e h => {\n    toFun := Quotient.lift (fun \u27e8a,x\u27e9 => e a x) <| by\n      rintro \u27e8a,x\u27e9 \u27e8b,y\u27e9 \u27e8Z,z,fst,snd,hh,hx,hy\u27e9; dsimp at *\n      rw [\u2190 hx, \u2190 hy]\n      specialize h _ _ fst snd ?_\n      \u00b7 ext z\n        apply \u03b9Fun_injective\n        apply_fun (fun q => q z) at hh\n        exact hh\n      apply_fun (fun q => q z) at h\n      exact h\n    continuous_toFun := by\n      apply Continuous.quotient_lift\n      apply continuous_sigma\n      intro a\n      exact (e a).continuous }\n  fac := by intro Z e h a; ext; rfl\n  uniq := by\n    intro Z e h m hm\n    ext \u27e8\u27e8a,x\u27e9\u27e9\n    specialize hm a\n    apply_fun (fun q => q x) at hm\n    exact hm", "start": [126, 1], "end": [152, 13], "kind": "commanddeclaration"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03c0'_comp_\u03b9_hom", "code": "@[reassoc]\nlemma \u03c0'_comp_\u03b9_hom (a : \u03b1) : \u03c0' \u03c0 a \u226b (\u03b9 _ surj).hom = \u03c0 a := by ext; rfl", "start": [154, 1], "end": [155, 75], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.EffectiveEpiFamily.\u03c0_comp_\u03b9_inv", "code": "@[reassoc]\nlemma \u03c0_comp_\u03b9_inv (a : \u03b1) : \u03c0 a \u226b (\u03b9 _ surj).inv = \u03c0' \u03c0 a := by\n  rw [Iso.comp_inv_eq]\n  exact \u03c0'_comp_\u03b9_hom _ surj _", "start": [157, 1], "end": [160, 31], "kind": "mathlibtacticlemma"}, {"full_name": "CompHaus.EffectiveEpiFamily.struct", "code": "noncomputable\ndef struct : EffectiveEpiFamilyStruct X \u03c0 where\n  desc := fun {W} e h => (\u03b9 \u03c0 surj).inv \u226b (structAux \u03c0).desc e (fun {Z} a\u2081 a\u2082 g\u2081 g\u2082 hh => by\n      apply h\n      rw [\u2190 cancel_mono (\u03b9 _ surj).inv]\n      simpa only [Category.assoc, \u03c0_comp_\u03b9_inv])\n  fac := by\n    intro W e h a\n    simp only [Eq.ndrec, id_eq, eq_mpr_eq_cast, \u03c0_comp_\u03b9_inv_assoc, (structAux \u03c0).fac]\n  uniq := by\n    intro W e h m hm\n    dsimp\n    rw [Iso.eq_inv_comp]\n    apply (structAux \u03c0).uniq\n    intro a\n    simpa using hm a", "start": [163, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "CompHaus.effectiveEpiFamily_of_jointly_surjective", "code": "theorem effectiveEpiFamily_of_jointly_surjective\n    {\u03b1 : Type} [Fintype \u03b1] {B : CompHaus.{u}}\n    (X : \u03b1 \u2192 CompHaus.{u}) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B))\n    (surj : \u2200 b : B, \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b) :\n    EffectiveEpiFamily X \u03c0", "start": [186, 1], "end": [191, 48], "kind": "commanddeclaration"}, {"full_name": "CompHaus.effectiveEpiFamily_tfae", "code": "theorem effectiveEpiFamily_tfae\n    {\u03b1 : Type} [Fintype \u03b1] {B : CompHaus.{u}}\n    (X : \u03b1 \u2192 CompHaus.{u}) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    TFAE\n    [ EffectiveEpiFamily X \u03c0\n    , Epi (Sigma.desc \u03c0)\n    , \u2200 b : B, \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b\n    ]", "start": [196, 1], "end": [227, 14], "kind": "commanddeclaration"}, {"full_name": "CompHaus.precoherent", "code": "instance precoherent : Precoherent CompHaus.{u} := by\n  constructor\n  intro B\u2081 B\u2082 f \u03b1 _ X\u2081 \u03c0\u2081 h\u2081\n  refine \u27e8\u03b1, inferInstance, fun a => pullback f (\u03c0\u2081 a), fun a => pullback.fst _ _, ?_,\n    id, fun a => pullback.snd _ _, ?_\u27e9\n  \u00b7 have := (effectiveEpiFamily_tfae _ \u03c0\u2081).out 0 2; rw [this] at h\u2081; clear this\n    have := (effectiveEpiFamily_tfae _ (fun a => pullback.fst f (\u03c0\u2081 a))).out 0 2\n    rw [this]; clear this\n    intro b\u2082\n    obtain \u27e8a, x, h\u27e9 := h\u2081 (f b\u2082)\n    refine \u27e8a, \u27e8\u27e8b\u2082, x\u27e9, h.symm\u27e9, rfl\u27e9\n  \u00b7 intro a\n    dsimp\n    ext \u27e8\u27e8_, _\u27e9, h\u27e9\n    exact h.symm", "start": [229, 1], "end": [243, 17], "kind": "commanddeclaration"}, {"full_name": "CompHaus.effectiveEpi_iff_surjective", "code": "lemma effectiveEpi_iff_surjective {X Y : CompHaus} (f : X \u27f6 Y) :\n    EffectiveEpi f \u2194 Function.Surjective f := by\n  rw [\u2190 epi_iff_surjective]\n  exact effectiveEpi_iff_epi (fun _ _ \u21a6 (effectiveEpiFamily_tfae _ _).out 0 1) f", "start": [245, 1], "end": [248, 81], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/NumberField/Embeddings.lean", "imports": ["Mathlib/Analysis/Complex/Polynomial.lean", "Mathlib/Topology/Instances/Complex.lean", "Mathlib/RingTheory/Norm.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/NumberTheory/NumberField/Basic.lean", "Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean"], "premises": [{"full_name": "NumberField.Embeddings.card", "code": "theorem card : Fintype.card (K \u2192+* A) = finrank \u211a K", "start": [55, 1], "end": [57, 69], "kind": "commanddeclaration"}, {"full_name": "NumberField.Embeddings.range_eval_eq_rootSet_minpoly", "code": "theorem range_eval_eq_rootSet_minpoly :\n    (range fun \u03c6 : K \u2192+* A => \u03c6 x) = (minpoly \u211a x).rootSet A", "start": [72, 1], "end": [79, 79], "kind": "commanddeclaration"}, {"full_name": "NumberField.Embeddings.coeff_bdd_of_norm_le", "code": "theorem coeff_bdd_of_norm_le {B : \u211d} {x : K} (h : \u2200 \u03c6 : K \u2192+* A, \u2016\u03c6 x\u2016 \u2264 B) (i : \u2115) :\n    \u2016(minpoly \u211a x).coeff i\u2016 \u2264 max B 1 ^ finrank \u211a K * (finrank \u211a K).choose (finrank \u211a K / 2)", "start": [92, 1], "end": [101, 12], "kind": "commanddeclaration"}, {"full_name": "NumberField.Embeddings.finite_of_norm_le", "code": "theorem finite_of_norm_le (B : \u211d) : {x : K | IsIntegral \u2124 x \u2227 \u2200 \u03c6 : K \u2192+* A, \u2016\u03c6 x\u2016 \u2264 B}.Finite", "start": [106, 1], "end": [118, 96], "kind": "commanddeclaration"}, {"full_name": "NumberField.Embeddings.pow_eq_one_of_norm_eq_one", "code": "theorem pow_eq_one_of_norm_eq_one {x : K} (hxi : IsIntegral \u2124 x) (hx : \u2200 \u03c6 : K \u2192+* A, \u2016\u03c6 x\u2016 = 1) :\n    \u2203 (n : \u2115) (_ : 0 < n), x ^ n = 1", "start": [121, 1], "end": [134, 67], "kind": "commanddeclaration"}, {"full_name": "NumberField.place", "code": "def NumberField.place : AbsoluteValue K \u211d :=\n  (IsAbsoluteValue.toAbsoluteValue (norm : A \u2192 \u211d)).comp \u03c6.injective", "start": [145, 1], "end": [147, 68], "kind": "commanddeclaration"}, {"full_name": "NumberField.place_apply", "code": "@[simp]\ntheorem NumberField.place_apply (x : K) : (NumberField.place \u03c6) x = norm (\u03c6 x)", "start": [150, 1], "end": [151, 86], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.conjugate", "code": "@[reducible]\ndef conjugate (\u03c6 : K \u2192+* \u2102) : K \u2192+* \u2102 := star \u03c6", "start": [164, 1], "end": [166, 48], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.conjugate_coe_eq", "code": "@[simp]\ntheorem conjugate_coe_eq (\u03c6 : K \u2192+* \u2102) (x : K) : (conjugate \u03c6) x = conj (\u03c6 x)", "start": [169, 1], "end": [170, 85], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.place_conjugate", "code": "theorem place_conjugate (\u03c6 : K \u2192+* \u2102) : place (conjugate \u03c6) = place \u03c6", "start": [173, 1], "end": [174, 72], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.IsReal", "code": "@[reducible]\ndef IsReal (\u03c6 : K \u2192+* \u2102) : Prop := IsSelfAdjoint \u03c6", "start": [177, 1], "end": [179, 51], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.isReal_iff", "code": "theorem isReal_iff {\u03c6 : K \u2192+* \u2102} : IsReal \u03c6 \u2194 conjugate \u03c6 = \u03c6", "start": [182, 1], "end": [182, 83], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.isReal_conjugate_iff", "code": "theorem isReal_conjugate_iff {\u03c6 : K \u2192+* \u2102} : IsReal (conjugate \u03c6) \u2194 IsReal \u03c6", "start": [185, 1], "end": [186, 25], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.IsReal.embedding", "code": "def IsReal.embedding {\u03c6 : K \u2192+* \u2102} (h\u03c6 : IsReal \u03c6) : K \u2192+* \u211d where\n  toFun x := (\u03c6 x).re\n  map_one' := by simp only [map_one, one_re]\n  map_mul' := by\n    simp only [Complex.conj_eq_iff_im.mp (RingHom.congr_fun h\u03c6 _), map_mul, mul_re,\n      mul_zero, tsub_zero, eq_self_iff_true, forall_const]\n  map_zero' := by simp only [map_zero, zero_re]\n  map_add' := by simp only [map_add, add_re, eq_self_iff_true, forall_const]", "start": [189, 1], "end": [197, 77], "kind": "commanddeclaration"}, {"full_name": "NumberField.ComplexEmbedding.IsReal.coe_embedding_apply", "code": "@[simp]\ntheorem IsReal.coe_embedding_apply {\u03c6 : K \u2192+* \u2102} (h\u03c6 : IsReal \u03c6) (x : K) :\n    (h\u03c6.embedding x : \u2102) = \u03c6 x", "start": [200, 1], "end": [206, 33], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace", "code": "def NumberField.InfinitePlace := { w : AbsoluteValue K \u211d // \u2203 \u03c6 : K \u2192+* \u2102, place \u03c6 = w }", "start": [217, 1], "end": [218, 89], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mk", "code": "noncomputable def NumberField.InfinitePlace.mk (\u03c6 : K \u2192+* \u2102) : NumberField.InfinitePlace K :=\n  \u27e8place \u03c6, \u27e8\u03c6, rfl\u27e9\u27e9", "start": [225, 1], "end": [227, 22], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.apply", "code": "@[simp]\ntheorem apply (\u03c6 : K \u2192+* \u2102) (x : K) : (mk \u03c6) x = Complex.abs (\u03c6 x)", "start": [250, 1], "end": [251, 74], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.embedding", "code": "noncomputable def embedding (w : InfinitePlace K) : K \u2192+* \u2102 := w.2.choose", "start": [254, 1], "end": [255, 74], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mk_embedding", "code": "@[simp]\ntheorem mk_embedding (w : InfinitePlace K) : mk (embedding w) = w", "start": [258, 1], "end": [259, 97], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mk_conjugate_eq", "code": "@[simp]\ntheorem mk_conjugate_eq (\u03c6 : K \u2192+* \u2102) : mk (ComplexEmbedding.conjugate \u03c6) = mk \u03c6", "start": [262, 1], "end": [265, 73], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.norm_embedding_eq", "code": "theorem norm_embedding_eq (w : InfinitePlace K) (x : K) :\n    \u2016(embedding w) x\u2016 = w x", "start": [268, 1], "end": [271, 6], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.eq_iff_eq", "code": "theorem eq_iff_eq (x : K) (r : \u211d) : (\u2200 w : InfinitePlace K, w x = r) \u2194 \u2200 \u03c6 : K \u2192+* \u2102, \u2016\u03c6 x\u2016 = r", "start": [273, 1], "end": [274, 66], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.le_iff_le", "code": "theorem le_iff_le (x : K) (r : \u211d) : (\u2200 w : InfinitePlace K, w x \u2264 r) \u2194 \u2200 \u03c6 : K \u2192+* \u2102, \u2016\u03c6 x\u2016 \u2264 r", "start": [277, 1], "end": [278, 66], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.pos_iff", "code": "theorem pos_iff {w : InfinitePlace K} {x : K} : 0 < w x \u2194 x \u2260 0", "start": [281, 1], "end": [281, 93], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mk_eq_iff", "code": "@[simp]\ntheorem mk_eq_iff {\u03c6 \u03c8 : K \u2192+* \u2102} : mk \u03c6 = mk \u03c8 \u2194 \u03c6 = \u03c8 \u2228 ComplexEmbedding.conjugate \u03c6 = \u03c8", "start": [284, 1], "end": [316, 27], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.IsReal", "code": "def IsReal (w : InfinitePlace K) : Prop := \u2203 \u03c6 : K \u2192+* \u2102, ComplexEmbedding.IsReal \u03c6 \u2227 mk \u03c6 = w", "start": [319, 1], "end": [320, 95], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.IsComplex", "code": "def IsComplex (w : InfinitePlace K) : Prop := \u2203 \u03c6 : K \u2192+* \u2102, \u00acComplexEmbedding.IsReal \u03c6 \u2227 mk \u03c6 = w", "start": [323, 1], "end": [324, 99], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.embedding_mk_eq", "code": "theorem embedding_mk_eq (\u03c6 : K \u2192+* \u2102) :\n    embedding (mk \u03c6) = \u03c6 \u2228 embedding (mk \u03c6) = ComplexEmbedding.conjugate \u03c6", "start": [327, 1], "end": [329, 94], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.embedding_mk_eq_of_isReal", "code": "@[simp]\ntheorem embedding_mk_eq_of_isReal {\u03c6 : K \u2192+* \u2102} (h : ComplexEmbedding.IsReal \u03c6) :\n    embedding (mk \u03c6) = \u03c6", "start": [331, 1], "end": [335, 58], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.isReal_iff", "code": "theorem isReal_iff {w : InfinitePlace K} :\n    IsReal w \u2194 ComplexEmbedding.IsReal (embedding w)", "start": [338, 1], "end": [342, 37], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.isComplex_iff", "code": "theorem isComplex_iff {w : InfinitePlace K} :\n    IsComplex w \u2194 \u00acComplexEmbedding.IsReal (embedding w)", "start": [345, 1], "end": [352, 68], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.not_isReal_iff_isComplex", "code": "@[simp]\ntheorem not_isReal_iff_isComplex {w : InfinitePlace K} : \u00acIsReal w \u2194 IsComplex w", "start": [355, 1], "end": [357, 33], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.isReal_or_isComplex", "code": "theorem isReal_or_isComplex (w : InfinitePlace K) : IsReal w \u2228 IsComplex w", "start": [360, 1], "end": [361, 46], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.embedding_of_isReal", "code": "noncomputable def embedding_of_isReal {w : InfinitePlace K} (hw : IsReal w) : K \u2192+* \u211d :=\n  ComplexEmbedding.IsReal.embedding (isReal_iff.mp hw)", "start": [364, 1], "end": [366, 55], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.embedding_of_isReal_apply", "code": "@[simp]\ntheorem embedding_of_isReal_apply {w : InfinitePlace K} (hw : IsReal w) (x : K) :\n    ((embedding_of_isReal hw) x : \u2102) = (embedding w) x", "start": [369, 1], "end": [372, 67], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.isReal_of_mk_isReal", "code": "@[simp]\ntheorem isReal_of_mk_isReal {\u03c6 : K \u2192+* \u2102} (h : IsReal (mk \u03c6)) :\n    ComplexEmbedding.IsReal \u03c6", "start": [374, 1], "end": [379, 20], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.not_isReal_of_mk_isComplex", "code": "@[simp]\ntheorem not_isReal_of_mk_isComplex {\u03c6 : K \u2192+* \u2102} (h : IsComplex (mk \u03c6)) :\n    \u00ac ComplexEmbedding.IsReal \u03c6", "start": [381, 1], "end": [386, 20], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mult", "code": "noncomputable def mult (w : InfinitePlace K) : \u2115 := if (IsReal w) then 1 else 2", "start": [388, 1], "end": [390, 80], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.card_filter_mk_eq", "code": "theorem card_filter_mk_eq [NumberField K] (w : InfinitePlace K) :\n    (Finset.univ.filter fun \u03c6 => mk \u03c6 = w).card = mult w", "start": [392, 1], "end": [404, 71], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mkReal", "code": "noncomputable def mkReal :\n    { \u03c6 : K \u2192+* \u2102 // ComplexEmbedding.IsReal \u03c6 } \u2243 { w : InfinitePlace K // IsReal w } := by\n  refine (Equiv.ofBijective (fun \u03c6 => \u27e8mk \u03c6, ?_\u27e9) \u27e8fun \u03c6 \u03c8 h => ?_, fun w => ?_\u27e9)\n  \u00b7 exact \u27e8\u03c6, \u03c6.prop, rfl\u27e9\n  \u00b7 rwa [Subtype.mk.injEq, mk_eq_iff, ComplexEmbedding.isReal_iff.mp \u03c6.prop, or_self,\n      \u2190 Subtype.ext_iff] at h\n  \u00b7 exact \u27e8\u27e8embedding w, isReal_iff.mp w.prop\u27e9, by simp\u27e9", "start": [406, 1], "end": [413, 57], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mkComplex", "code": "noncomputable def mkComplex :\n    { \u03c6 : K \u2192+* \u2102 // \u00acComplexEmbedding.IsReal \u03c6 } \u2192 { w : InfinitePlace K // IsComplex w } :=\n  Subtype.map mk fun \u03c6 h\u03c6 => \u27e8\u03c6, h\u03c6, rfl\u27e9", "start": [415, 1], "end": [418, 42], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mkReal_coe", "code": "@[simp]\ntheorem mkReal_coe (\u03c6 : { \u03c6 : K \u2192+* \u2102 // ComplexEmbedding.IsReal \u03c6 }) :\n    (mkReal \u03c6 : InfinitePlace K) = mk (\u03c6 : K \u2192+* \u2102)", "start": [421, 1], "end": [423, 59], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.mkComplex_coe", "code": "@[simp]\ntheorem mkComplex_coe (\u03c6 : { \u03c6 : K \u2192+* \u2102 // \u00acComplexEmbedding.IsReal \u03c6 }) :\n    (mkComplex \u03c6 : InfinitePlace K) = mk (\u03c6 : K \u2192+* \u2102)", "start": [426, 1], "end": [428, 62], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.NumberField.InfinitePlace.fintype", "code": "noncomputable instance NumberField.InfinitePlace.fintype : Fintype (InfinitePlace K) :=\n  Set.fintypeRange _", "start": [433, 1], "end": [434, 21], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.prod_eq_abs_norm", "code": "theorem prod_eq_abs_norm (x : K) :\n    \u220f w : InfinitePlace K, w x ^ mult w = abs (Algebra.norm \u211a x)", "start": [439, 1], "end": [453, 81], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.card_real_embeddings", "code": "theorem card_real_embeddings :\n    card { \u03c6 : K \u2192+* \u2102 // ComplexEmbedding.IsReal \u03c6 }\n      = card { w : InfinitePlace K // IsReal w }", "start": [458, 1], "end": [460, 78], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.card_complex_embeddings", "code": "theorem card_complex_embeddings :\n    card { \u03c6 : K \u2192+* \u2102 // \u00acComplexEmbedding.IsReal \u03c6 } =\n      2 * card { w : InfinitePlace K // IsComplex w }", "start": [463, 1], "end": [479, 52], "kind": "commanddeclaration"}, {"full_name": "NumberField.InfinitePlace.card_add_two_mul_card_eq_rank", "code": "theorem card_add_two_mul_card_eq_rank :\n    card { w : InfinitePlace K // IsReal w } + 2 * card { w : InfinitePlace K // IsComplex w } =\n      finrank \u211a K", "start": [482, 1], "end": [487, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Zlattice.lean", "imports": ["Mathlib/MeasureTheory/Group/Measure.lean", "Mathlib/RingTheory/Localization/Module.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/MeasureTheory/Group/FundamentalDomain.lean"], "premises": [{"full_name": "Zspan.fundamentalDomain", "code": "def fundamentalDomain : Set E := {m | \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1}", "start": [59, 1], "end": [61, 75], "kind": "commanddeclaration"}, {"full_name": "Zspan.mem_fundamentalDomain", "code": "@[simp]\ntheorem mem_fundamentalDomain {m : E} :\n    m \u2208 fundamentalDomain b \u2194 \u2200 i, b.repr m i \u2208 Set.Ico (0 : K) 1", "start": [64, 1], "end": [66, 77], "kind": "commanddeclaration"}, {"full_name": "Zspan.map_fundamentalDomain", "code": "theorem map_fundamentalDomain {F : Type*} [NormedAddCommGroup F] [NormedSpace K F] (f : E \u2243\u2097[K] F) :\n    f '' (fundamentalDomain b) = fundamentalDomain (b.map f)", "start": [69, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Zspan.fundamentalDomain_reindex", "code": "@[simp]\ntheorem fundamentalDomain_reindex {\u03b9' : Type*} (e : \u03b9 \u2243 \u03b9') :\n    fundamentalDomain (b.reindex e) = fundamentalDomain b", "start": [76, 1], "end": [82, 25], "kind": "commanddeclaration"}, {"full_name": "Zspan.fundamentalDomain_pi_basisFun", "code": "lemma fundamentalDomain_pi_basisFun [Fintype \u03b9] :\n    fundamentalDomain (Pi.basisFun \u211d \u03b9) = Set.pi Set.univ fun _ : \u03b9 \u21a6 Set.Ico (0 : \u211d) 1 := by\n  ext; simp", "start": [84, 1], "end": [86, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Zspan.floor", "code": "def floor (m : E) : span \u2124 (Set.range b) := \u2211 i, \u230ab.repr m i\u230b \u2022 b.restrictScalars \u2124 i", "start": [94, 1], "end": [96, 86], "kind": "commanddeclaration"}, {"full_name": "Zspan.ceil", "code": "def ceil (m : E) : span \u2124 (Set.range b) := \u2211 i, \u2308b.repr m i\u2309 \u2022 b.restrictScalars \u2124 i", "start": [99, 1], "end": [101, 85], "kind": "commanddeclaration"}, {"full_name": "Zspan.repr_floor_apply", "code": "@[simp]\ntheorem repr_floor_apply (m : E) (i : \u03b9) : b.repr (floor b m) i = \u230ab.repr m i\u230b", "start": [104, 1], "end": [108, 87], "kind": "commanddeclaration"}, {"full_name": "Zspan.repr_ceil_apply", "code": "@[simp]\ntheorem repr_ceil_apply (m : E) (i : \u03b9) : b.repr (ceil b m) i = \u2308b.repr m i\u2309", "start": [111, 1], "end": [115, 87], "kind": "commanddeclaration"}, {"full_name": "Zspan.floor_eq_self_of_mem", "code": "@[simp]\ntheorem floor_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (floor b m : E) = m", "start": [118, 1], "end": [125, 59], "kind": "commanddeclaration"}, {"full_name": "Zspan.ceil_eq_self_of_mem", "code": "@[simp]\ntheorem ceil_eq_self_of_mem (m : E) (h : m \u2208 span \u2124 (Set.range b)) : (ceil b m : E) = m", "start": [128, 1], "end": [135, 58], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract", "code": "def fract (m : E) : E := m - floor b m", "start": [138, 1], "end": [141, 39], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_apply", "code": "theorem fract_apply (m : E) : fract b m = m - floor b m", "start": [144, 1], "end": [144, 63], "kind": "commanddeclaration"}, {"full_name": "Zspan.repr_fract_apply", "code": "@[simp]\ntheorem repr_fract_apply (m : E) (i : \u03b9) : b.repr (fract b m) i = Int.fract (b.repr m i)", "start": [147, 1], "end": [149, 94], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_fract", "code": "@[simp]\ntheorem fract_fract (m : E) : fract b (fract b m) = fract b m", "start": [152, 1], "end": [154, 87], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_zspan_add", "code": "@[simp]\ntheorem fract_zspan_add (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (v + m) = fract b m", "start": [157, 1], "end": [165, 79], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_add_zspan", "code": "@[simp]\ntheorem fract_add_zspan (m : E) {v : E} (h : v \u2208 span \u2124 (Set.range b)) :\n    fract b (m + v) = fract b m", "start": [168, 1], "end": [170, 75], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_eq_self", "code": "theorem fract_eq_self {x : E} : fract b x = x \u2194 x \u2208 fundamentalDomain b", "start": [175, 1], "end": [177, 40], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_mem_fundamentalDomain", "code": "theorem fract_mem_fundamentalDomain (x : E) : fract b x \u2208 fundamentalDomain b", "start": [182, 1], "end": [183, 37], "kind": "commanddeclaration"}, {"full_name": "Zspan.fractRestrict", "code": "def fractRestrict (x : E) : fundamentalDomain b := \u27e8fract b x, fract_mem_fundamentalDomain b x\u27e9", "start": [186, 1], "end": [187, 96], "kind": "commanddeclaration"}, {"full_name": "Zspan.fractRestrict_surjective", "code": "theorem fractRestrict_surjective : Function.Surjective (fractRestrict b)", "start": [189, 1], "end": [190, 64], "kind": "commanddeclaration"}, {"full_name": "Zspan.fractRestrict_apply", "code": "@[simp]\ntheorem fractRestrict_apply (x : E) : (fractRestrict b x : E) = fract b x", "start": [192, 1], "end": [193, 81], "kind": "commanddeclaration"}, {"full_name": "Zspan.fract_eq_fract", "code": "theorem fract_eq_fract (m n : E) : fract b m = fract b n \u2194 -m + n \u2208 span \u2124 (Set.range b)", "start": [195, 1], "end": [200, 66], "kind": "commanddeclaration"}, {"full_name": "Zspan.norm_fract_le", "code": "theorem norm_fract_le [HasSolidNorm K] (m : E) : \u2016fract b m\u2016 \u2264 \u2211 i, \u2016b i\u2016", "start": [203, 1], "end": [217, 38], "kind": "commanddeclaration"}, {"full_name": "Zspan.coe_floor_self", "code": "@[simp]\ntheorem coe_floor_self (k : K) : (floor (Basis.singleton \u03b9 K) k : K) = \u230ak\u230b", "start": [224, 1], "end": [226, 97], "kind": "commanddeclaration"}, {"full_name": "Zspan.coe_fract_self", "code": "@[simp]\ntheorem coe_fract_self (k : K) : (fract (Basis.singleton \u03b9 K) k : K) = Int.fract k", "start": [229, 1], "end": [231, 97], "kind": "commanddeclaration"}, {"full_name": "Zspan.fundamentalDomain_isBounded", "code": "theorem fundamentalDomain_isBounded [Finite \u03b9] [HasSolidNorm K] :\n    IsBounded (fundamentalDomain b)", "start": [238, 1], "end": [243, 22], "kind": "commanddeclaration"}, {"full_name": "Zspan.vadd_mem_fundamentalDomain", "code": "theorem vadd_mem_fundamentalDomain [Fintype \u03b9] (y : span \u2124 (Set.range b)) (x : E) :\n    y +\u1d65 x \u2208 fundamentalDomain b \u2194 y = -floor b x", "start": [246, 1], "end": [250, 19], "kind": "commanddeclaration"}, {"full_name": "Zspan.exist_unique_vadd_mem_fundamentalDomain", "code": "theorem exist_unique_vadd_mem_fundamentalDomain [Finite \u03b9] (x : E) :\n    \u2203! v : span \u2124 (Set.range b), v +\u1d65 x \u2208 fundamentalDomain b", "start": [253, 1], "end": [258, 50], "kind": "commanddeclaration"}, {"full_name": "Zspan.quotientEquiv", "code": "def quotientEquiv [Fintype \u03b9] :\n    E \u29f8 span \u2124 (Set.range b) \u2243 (fundamentalDomain b) := by\n  refine Equiv.ofBijective ?_ \u27e8fun x y => ?_, fun x => ?_\u27e9\n  \u00b7 refine fun q => Quotient.liftOn q (fractRestrict b) (fun _ _ h => ?_)\n    rw [Subtype.mk.injEq, fractRestrict_apply, fractRestrict_apply, fract_eq_fract]\n    exact QuotientAddGroup.leftRel_apply.mp h\n  \u00b7 refine Quotient.inductionOn\u2082 x y (fun _ _ hxy => ?_)\n    rw [Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))), fractRestrict,\n      Quotient.liftOn_mk (s := quotientRel (span \u2124 (Set.range b))),  fractRestrict,\n      Subtype.mk.injEq] at hxy\n    apply Quotient.sound'\n    rwa [QuotientAddGroup.leftRel_apply, mem_toAddSubgroup, \u2190 fract_eq_fract]\n  \u00b7 obtain \u27e8a, rfl\u27e9 := fractRestrict_surjective b x\n    exact \u27e8Quotient.mk'' a, rfl\u27e9", "start": [261, 1], "end": [276, 33], "kind": "commanddeclaration"}, {"full_name": "Zspan.quotientEquiv_apply_mk", "code": "@[simp]\ntheorem quotientEquiv_apply_mk [Fintype \u03b9] (x : E) :\n    quotientEquiv b (Submodule.Quotient.mk x) = fractRestrict b x", "start": [278, 1], "end": [280, 73], "kind": "commanddeclaration"}, {"full_name": "Zspan.quotientEquiv.symm_apply", "code": "@[simp]\ntheorem quotientEquiv.symm_apply [Fintype \u03b9] (x : fundamentalDomain b) :\n    (quotientEquiv b).symm x = Submodule.Quotient.mk \u2191x", "start": [282, 1], "end": [286, 40], "kind": "commanddeclaration"}, {"full_name": "Zspan.fundamentalDomain_measurableSet", "code": "@[measurability]\ntheorem fundamentalDomain_measurableSet [MeasurableSpace E] [OpensMeasurableSpace E] [Finite \u03b9] :\n    MeasurableSet (fundamentalDomain b)", "start": [296, 1], "end": [307, 90], "kind": "commanddeclaration"}, {"full_name": "Zspan.isAddFundamentalDomain", "code": "protected theorem isAddFundamentalDomain [Finite \u03b9] [MeasurableSpace E] [OpensMeasurableSpace E]\n    (\u03bc : Measure E) :\n    IsAddFundamentalDomain (span \u2124 (Set.range b)).toAddSubgroup (fundamentalDomain b) \u03bc", "start": [310, 1], "end": [317, 57], "kind": "commanddeclaration"}, {"full_name": "Zspan.measure_fundamentalDomain", "code": "theorem measure_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] (b\u2080 : Basis \u03b9 \u211d E) :\n    \u03bc (fundamentalDomain b) = ENNReal.ofReal |(b\u2080.toMatrix b).det| * \u03bc (fundamentalDomain b\u2080)", "start": [320, 1], "end": [330, 98], "kind": "commanddeclaration"}, {"full_name": "Zspan.volume_fundamentalDomain", "code": "@[simp]\ntheorem volume_fundamentalDomain [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u211d (\u03b9 \u2192 \u211d)) :\n    volume (fundamentalDomain b) = ENNReal.ofReal |(Matrix.of b).det|", "start": [332, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "Zlattice.FG", "code": "theorem Zlattice.FG : AddSubgroup.FG L", "start": [353, 1], "end": [386, 52], "kind": "commanddeclaration"}, {"full_name": "Zlattice.module_finite", "code": "theorem Zlattice.module_finite : Module.Finite \u2124 L", "start": [388, 1], "end": [389, 87], "kind": "commanddeclaration"}, {"full_name": "Zlattice.module_free", "code": "theorem Zlattice.module_free : Module.Free \u2124 L", "start": [391, 1], "end": [398, 49], "kind": "commanddeclaration"}, {"full_name": "Zlattice.rank", "code": "theorem Zlattice.rank : finrank \u2124 L = finrank K E", "start": [402, 1], "end": [480, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean", "imports": ["Mathlib/MeasureTheory/Measure/Lebesgue/EqHaar.lean", "Mathlib/Analysis/Convex/Measure.lean", "Mathlib/MeasureTheory/Group/FundamentalDomain.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.exists_pair_mem_lattice_not_disjoint_vadd", "code": "theorem exists_pair_mem_lattice_not_disjoint_vadd [AddCommGroup L] [Countable L] [AddAction L E]\n    [MeasurableSpace L] [MeasurableVAdd L E] [VAddInvariantMeasure L E \u03bc]\n    (fund : IsAddFundamentalDomain L F \u03bc) (hS : NullMeasurableSet s \u03bc) (h : \u03bc F < \u03bc s) :\n    \u2203 x y : L, x \u2260 y \u2227 \u00acDisjoint (x +\u1d65 s) (y +\u1d65 s)", "start": [47, 1], "end": [58, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure", "code": "theorem exists_ne_zero_mem_lattice_of_measure_mul_two_pow_lt_measure [NormedAddCommGroup E]\n    [NormedSpace \u211d E] [BorelSpace E] [FiniteDimensional \u211d E] [IsAddHaarMeasure \u03bc]\n    {L : AddSubgroup E} [Countable L] (fund : IsAddFundamentalDomain L F \u03bc)\n    (h : \u03bc F * 2 ^ finrank \u211d E < \u03bc s) (h_symm : \u2200 x \u2208 s, -x \u2208 s) (h_conv : Convex \u211d s) :\n    \u2203 (x : _) (_ : x \u2260 0), ((x : L) : E) \u2208 s", "start": [61, 1], "end": [83, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/IdealQuotient.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Finite/Rank.lean", "Mathlib/Data/ZMod/Quotient.lean", "Mathlib/LinearAlgebra/FreeModule/StrongRankCondition.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "Mathlib/LinearAlgebra/QuotientPi.lean"], "premises": [{"full_name": "Ideal.quotientEquivPiSpan", "code": "noncomputable def quotientEquivPiSpan (I : Ideal S) (b : Basis \u03b9 R S) (hI : I \u2260 \u22a5) :\n    (S \u29f8 I) \u2243\u2097[R] \u2200 i, R \u29f8 span ({I.smithCoeffs b hI i} : Set R) := by\n  haveI := Fintype.ofFinite \u03b9\n  let a := I.smithCoeffs b hI\n  let b' := I.ringBasis b hI\n  let ab := I.selfBasis b hI\n  have ab_eq := I.selfBasis_def b hI\n  have mem_I_iff : \u2200 x, x \u2208 I \u2194 \u2200 i, a i \u2223 b'.repr x i := by\n    intro x\n    rw [ab.mem_ideal_iff']\n    simp_rw [ab_eq]\n    have : \u2200 (c : \u03b9 \u2192 R) (i), b'.repr (\u2211 j : \u03b9, c j \u2022 a j \u2022 b' j) i = a i * c i := by\n      intro c i\n      simp only [\u2190 MulAction.mul_smul, b'.repr_sum_self, mul_comm]\n    constructor\n    \u00b7 rintro \u27e8c, rfl\u27e9 i\n      exact \u27e8c i, this c i\u27e9\n    \u00b7 rintro ha\n      choose c hc using ha\n      exact \u27e8c, b'.ext_elem fun i => Eq.trans (hc i) (this c i).symm\u27e9\n  let I' : Submodule R (\u03b9 \u2192 R) := Submodule.pi Set.univ fun i => span ({a i} : Set R)\n  have : Submodule.map (b'.equivFun : S \u2192\u2097[R] \u03b9 \u2192 R) (I.restrictScalars R) = I' := by\n    ext x\n    simp only [Submodule.mem_map, Submodule.mem_pi, mem_span_singleton, Set.mem_univ,\n      Submodule.restrictScalars_mem, mem_I_iff, smul_eq_mul, forall_true_left, LinearEquiv.coe_coe,\n      Basis.equivFun_apply]\n    constructor\n    \u00b7 rintro \u27e8y, hy, rfl\u27e9 i\n      exact hy i\n    \u00b7 rintro hdvd\n      refine' \u27e8\u2211 i, x i \u2022 b' i, fun i => _, _\u27e9 <;> rw [b'.repr_sum_self]\n      \u00b7 exact hdvd i\n  refine' ((Submodule.Quotient.restrictScalarsEquiv R I).restrictScalars R).symm.trans\n    (\u03c3\u2081\u2082 := RingHom.id R) (\u03c3\u2083\u2082 := RingHom.id R) _\n  \u00b7 infer_instance\n  \u00b7 infer_instance\n  refine' (Submodule.Quotient.equiv (I.restrictScalars R) I' b'.equivFun this).trans\n    (\u03c3\u2081\u2082 := RingHom.id R) (\u03c3\u2083\u2082 := RingHom.id R) _\n  \u00b7 infer_instance\n  \u00b7 infer_instance\n  classical\n    let this :=\n      Submodule.quotientPi (show \u2200 _, Submodule R R from fun i => span ({a i} : Set R))\n    exact this", "start": [31, 1], "end": [82, 15], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivPiZMod", "code": "noncomputable def quotientEquivPiZMod (I : Ideal S) (b : Basis \u03b9 \u2124 S) (hI : I \u2260 \u22a5) :\n    S \u29f8 I \u2243+ \u2200 i, ZMod (I.smithCoeffs b hI i).natAbs :=\n  let a := I.smithCoeffs b hI\n  let e := I.quotientEquivPiSpan b hI\n  let e' : (\u2200 i : \u03b9, \u2124 \u29f8 span ({a i} : Set \u2124)) \u2243+ \u2200 i : \u03b9, ZMod (a i).natAbs :=\n    AddEquiv.piCongrRight fun i => \u2191(Int.quotientSpanEquivZMod (a i))\n  (\u2191(e : (S \u29f8 I) \u2243\u2097[\u2124] _) : S \u29f8 I \u2243+ _).trans e'", "start": [85, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "Ideal.fintypeQuotientOfFreeOfNeBot", "code": "noncomputable def fintypeQuotientOfFreeOfNeBot [Module.Free \u2124 S] [Module.Finite \u2124 S]\n    (I : Ideal S) (hI : I \u2260 \u22a5) : Fintype (S \u29f8 I) := by\n  let b := Module.Free.chooseBasis \u2124 S\n  let a := I.smithCoeffs b hI\n  let e := I.quotientEquivPiZMod b hI\n  haveI : \u2200 i, NeZero (a i).natAbs := fun i =>\n    \u27e8Int.natAbs_ne_zero.mpr (smithCoeffs_ne_zero b I hI i)\u27e9\n  classical exact Fintype.ofEquiv (\u2200 i, ZMod (a i).natAbs) e.symm", "start": [96, 1], "end": [108, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotientEquivDirectSum", "code": "noncomputable def quotientEquivDirectSum :\n    (S \u29f8 I) \u2243\u2097[F] \u2a01 i, R \u29f8 span ({I.smithCoeffs b hI i} : Set R) := by\n  haveI := Fintype.ofFinite \u03b9\n  exact ((I.quotientEquivPiSpan b _).restrictScalars F).trans\n    (DirectSum.linearEquivFunOnFintype _ _ _).symm", "start": [114, 1], "end": [121, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.finrank_quotient_eq_sum", "code": "theorem finrank_quotient_eq_sum {\u03b9} [Fintype \u03b9] (b : Basis \u03b9 R S) [Nontrivial F]\n    [\u2200 i, Module.Free F (R \u29f8 span ({I.smithCoeffs b hI i} : Set R))]\n    [\u2200 i, Module.Finite F (R \u29f8 span ({I.smithCoeffs b hI i} : Set R))] :\n    FiniteDimensional.finrank F (S \u29f8 I) =\n      \u2211 i, FiniteDimensional.finrank F (R \u29f8 span ({I.smithCoeffs b hI i} : Set R))", "start": [124, 1], "end": [130, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Quotient.lean", "imports": ["Mathlib/RingTheory/Ideal/Quotient.lean", "Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CharP.quotient", "code": "theorem quotient (R : Type u) [CommRing R] (p : \u2115) [hp1 : Fact p.Prime] (hp2 : \u2191p \u2208 nonunits R) :\n    CharP (R \u29f8 (Ideal.span ({(p : R)} : Set R) : Ideal R)) p", "start": [20, 1], "end": [31, 87], "kind": "commanddeclaration"}, {"full_name": "CharP.quotient'", "code": "theorem quotient' {R : Type*} [CommRing R] (p : \u2115) [CharP R p] (I : Ideal R)\n    (h : \u2200 x : \u2115, (x : R) \u2208 I \u2192 (x : R) = 0) : CharP (R \u29f8 I) p", "start": [34, 1], "end": [42, 49], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.index_eq_zero", "code": "theorem Ideal.Quotient.index_eq_zero {R : Type*} [CommRing R] (I : Ideal R) :\n    (\u2191I.toAddSubgroup.index : R \u29f8 I) = 0", "start": [47, 1], "end": [55, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Associated.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Algebra/Associated.lean", "Mathlib/Data/Int/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.natAbs_eq_iff_associated", "code": "theorem Int.natAbs_eq_iff_associated {a b : \u2124} : a.natAbs = b.natAbs \u2194 Associated a b", "start": [22, 1], "end": [31, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeModule/Determinant.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Finite/Basic.lean", "Mathlib/LinearAlgebra/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.det_zero''", "code": "@[simp]\ntheorem LinearMap.det_zero'' {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M]\n    [Module.Free R M] [Module.Finite R M] [Nontrivial M] : LinearMap.det (0 : M \u2192\u2097[R] M) = 0", "start": [24, 1], "end": [29, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/NormTrace.lean", "imports": ["Mathlib/RingTheory/Localization/Module.lean", "Mathlib/RingTheory/Norm.lean", "Mathlib/RingTheory/Discriminant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.map_leftMulMatrix_localization", "code": "theorem Algebra.map_leftMulMatrix_localization {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9]\n    (b : Basis \u03b9 R S) (a : S) :\n    (algebraMap R R\u2098).mapMatrix (leftMulMatrix b a) =\n    leftMulMatrix (b.localizationLocalization R\u2098 M S\u2098) (algebraMap S S\u2098 a)", "start": [54, 1], "end": [60, 90], "kind": "commanddeclaration"}, {"full_name": "Algebra.norm_localization", "code": "theorem Algebra.norm_localization [Module.Free R S] [Module.Finite R S] (a : S) :\n    Algebra.norm R\u2098 (algebraMap S S\u2098 a) = algebraMap R R\u2098 (Algebra.norm R a)", "start": [62, 1], "end": [73, 93], "kind": "commanddeclaration"}, {"full_name": "Algebra.trace_localization", "code": "theorem Algebra.trace_localization [Module.Free R S] [Module.Finite R S] (a : S) :\n    Algebra.trace R\u2098 S\u2098 (algebraMap S S\u2098 a) = algebraMap R R\u2098 (Algebra.trace R S a)", "start": [76, 1], "end": [88, 73], "kind": "commanddeclaration"}, {"full_name": "Algebra.traceMatrix_localizationLocalization", "code": "theorem Algebra.traceMatrix_localizationLocalization (b : Basis \u03b9 R S) :\n    Algebra.traceMatrix R\u2098 (b.localizationLocalization R\u2098 M S\u2098) =\n      (algebraMap R R\u2098).mapMatrix (Algebra.traceMatrix R b)", "start": [100, 1], "end": [108, 41], "kind": "commanddeclaration"}, {"full_name": "Algebra.discr_localizationLocalization", "code": "theorem Algebra.discr_localizationLocalization (b : Basis \u03b9 R S) :\n    Algebra.discr R\u2098 (b.localizationLocalization R\u2098 M S\u2098) =\n    algebraMap R R\u2098 (Algebra.discr R b)", "start": [110, 1], "end": [118, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/DedekindDomain/PID.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/RingTheory/DedekindDomain/Dvr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne", "code": "theorem Ideal.eq_span_singleton_of_mem_of_not_mem_sq_of_not_mem_prime_ne {P : Ideal R}\n    (hP : P.IsPrime) [IsDomain R] [IsDedekindDomain R] {x : R} (x_mem : x \u2208 P) (hxP2 : x \u2209 P ^ 2)\n    (hxQ : \u2200 Q : Ideal R, IsPrime Q \u2192 Q \u2260 P \u2192 x \u2209 Q) : P = Ideal.span {x}", "start": [38, 1], "end": [77, 87], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top", "code": "theorem FractionalIdeal.isPrincipal_of_unit_of_comap_mul_span_singleton_eq_top {R A : Type*}\n    [CommRing R] [CommRing A] [Algebra R A] {S : Submonoid R} [IsLocalization S A]\n    (I : (FractionalIdeal S A)\u02e3) {v : A} (hv : v \u2208 (\u2191I\u207b\u00b9 : FractionalIdeal S A))\n    (h : Submodule.comap (Algebra.linearMap R A) ((I : Submodule R A) * Submodule.span R {v}) = \u22a4) :\n    Submodule.IsPrincipal (I : Submodule R A)", "start": [81, 1], "end": [105, 86], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.isPrincipal.of_finite_maximals_of_inv", "code": "theorem FractionalIdeal.isPrincipal.of_finite_maximals_of_inv {A : Type*} [CommRing A]\n    [Algebra R A] {S : Submonoid R} [IsLocalization S A] (hS : S \u2264 R\u2070)\n    (hf : {I : Ideal R | I.IsMaximal}.Finite) (I I' : FractionalIdeal S A) (hinv : I * I' = 1) :\n    Submodule.IsPrincipal (I : Submodule R A)", "start": [108, 1], "end": [169, 80], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrincipal.of_finite_maximals_of_isUnit", "code": "theorem Ideal.IsPrincipal.of_finite_maximals_of_isUnit (hf : {I : Ideal R | I.IsMaximal}.Finite)\n    {I : Ideal R} (hI : IsUnit (I : FractionalIdeal R\u2070 (FractionRing R))) : I.IsPrincipal", "start": [172, 1], "end": [179, 74], "kind": "commanddeclaration"}, {"full_name": "IsPrincipalIdealRing.of_finite_primes", "code": "theorem IsPrincipalIdealRing.of_finite_primes [IsDomain R] [IsDedekindDomain R]\n    (h : {I : Ideal R | I.IsPrime}.Finite) : IsPrincipalIdealRing R", "start": [182, 1], "end": [190, 79], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime", "code": "theorem IsLocalization.OverPrime.mem_normalizedFactors_of_isPrime [DecidableEq (Ideal S\u209a)]\n    {P : Ideal S\u209a} (hP : IsPrime P) (hP0 : P \u2260 \u22a5) :\n    P \u2208 normalizedFactors (Ideal.map (algebraMap R S\u209a) p)", "start": [211, 1], "end": [251, 100], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.isPrincipalIdealRing_localization_over_prime", "code": "theorem IsDedekindDomain.isPrincipalIdealRing_localization_over_prime :\n    IsPrincipalIdealRing S\u209a", "start": [254, 1], "end": [270, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/Reflection.lean", "imports": ["Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Fin/VecNotation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FinVec.seq", "code": "def seq : \u2200 {m}, (Fin m \u2192 \u03b1 \u2192 \u03b2) \u2192 (Fin m \u2192 \u03b1) \u2192 Fin m \u2192 \u03b2\n  | 0, _, _ => ![]\n  | _ + 1, f, v => Matrix.vecCons (f 0 (v 0)) (seq (Matrix.vecTail f) (Matrix.vecTail v))", "start": [37, 1], "end": [40, 90], "kind": "commanddeclaration"}, {"full_name": "FinVec.seq_eq", "code": "@[simp]\ntheorem seq_eq : \u2200 {m} (f : Fin m \u2192 \u03b1 \u2192 \u03b2) (v : Fin m \u2192 \u03b1), seq f v = fun i => f i (v i)", "start": [43, 1], "end": [52, 12], "kind": "commanddeclaration"}, {"full_name": "FinVec.map", "code": "def map (f : \u03b1 \u2192 \u03b2) {m} : (Fin m \u2192 \u03b1) \u2192 Fin m \u2192 \u03b2 :=\n  seq fun _ => f", "start": [57, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "FinVec.map_eq", "code": "@[simp]\ntheorem map_eq (f : \u03b1 \u2192 \u03b2) {m} (v : Fin m \u2192 \u03b1) : map f v = f \u2218 v", "start": [62, 1], "end": [70, 13], "kind": "commanddeclaration"}, {"full_name": "FinVec.etaExpand", "code": "def etaExpand {m} (v : Fin m \u2192 \u03b1) : Fin m \u2192 \u03b1 :=\n  map id v", "start": [76, 1], "end": [78, 11], "kind": "commanddeclaration"}, {"full_name": "FinVec.etaExpand_eq", "code": "@[simp]\ntheorem etaExpand_eq {m} (v : Fin m \u2192 \u03b1) : etaExpand v = v", "start": [81, 1], "end": [89, 14], "kind": "commanddeclaration"}, {"full_name": "FinVec.Forall", "code": "def Forall : \u2200 {m} (_ : (Fin m \u2192 \u03b1) \u2192 Prop), Prop\n  | 0, P => P ![]\n  | _ + 1, P => \u2200 x : \u03b1, Forall fun v => P (Matrix.vecCons x v)", "start": [95, 1], "end": [98, 64], "kind": "commanddeclaration"}, {"full_name": "FinVec.forall_iff", "code": "@[simp]\ntheorem forall_iff : \u2200 {m} (P : (Fin m \u2192 \u03b1) \u2192 Prop), Forall P \u2194 \u2200 x, P x", "start": [101, 1], "end": [112, 92], "kind": "commanddeclaration"}, {"full_name": "FinVec.Exists", "code": "def Exists : \u2200 {m} (_ : (Fin m \u2192 \u03b1) \u2192 Prop), Prop\n  | 0, P => P ![]\n  | _ + 1, P => \u2203 x : \u03b1, Exists fun v => P (Matrix.vecCons x v)", "start": [118, 1], "end": [121, 64], "kind": "commanddeclaration"}, {"full_name": "FinVec.exists_iff", "code": "theorem exists_iff : \u2200 {m} (P : (Fin m \u2192 \u03b1) \u2192 Prop), Exists P \u2194 \u2203 x, P x", "start": [124, 1], "end": [134, 92], "kind": "commanddeclaration"}, {"full_name": "FinVec.sum", "code": "def sum [Add \u03b1] [Zero \u03b1] : \u2200 {m} (_ : Fin m \u2192 \u03b1), \u03b1\n  | 0, _ => 0\n  | 1, v => v 0\n  | _ + 2, v => sum (fun i => v (Fin.castSucc i)) + v (Fin.last _)", "start": [140, 1], "end": [145, 67], "kind": "commanddeclaration"}, {"full_name": "FinVec.sum_eq", "code": "@[simp]\ntheorem sum_eq [AddCommMonoid \u03b1] : \u2200 {m} (a : Fin m \u2192 \u03b1), sum a = \u2211 i, a i", "start": [150, 1], "end": [160, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "imports": ["Mathlib/Analysis/Convex/StrictConvexBetween.lean", "Mathlib/Geometry/Euclidean/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.Sphere", "code": "@[ext]\nstructure Sphere [MetricSpace P] where\n  center : P\n  radius : \u211d", "start": [40, 1], "end": [45, 13], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.mk_center", "code": "theorem Sphere.mk_center (c : P) (r : \u211d) : (\u27e8c, r\u27e9 : Sphere P).center = c", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.mk_radius", "code": "theorem Sphere.mk_radius (c : P) (r : \u211d) : (\u27e8c, r\u27e9 : Sphere P).radius = r", "start": [67, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.mk_center_radius", "code": "@[simp]\ntheorem Sphere.mk_center_radius (s : Sphere P) : (\u27e8s.center, s.radius\u27e9 : Sphere P) = s", "start": [71, 1], "end": [73, 14], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.coe_mk", "code": "@[simp]\ntheorem Sphere.coe_mk (c : P) (r : \u211d) : \u2191(\u27e8c, r\u27e9 : Sphere P) = Metric.sphere c r", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.mem_coe", "code": "theorem Sphere.mem_coe {p : P} {s : Sphere P} : p \u2208 (s : Set P) \u2194 p \u2208 s", "start": [87, 1], "end": [88, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.mem_coe'", "code": "@[simp]\ntheorem Sphere.mem_coe' {p : P} {s : Sphere P} : dist p s.center = s.radius \u2194 p \u2208 s", "start": [91, 1], "end": [93, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mem_sphere", "code": "theorem mem_sphere {p : P} {s : Sphere P} : p \u2208 s \u2194 dist p s.center = s.radius", "start": [95, 1], "end": [96, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mem_sphere'", "code": "theorem mem_sphere' {p : P} {s : Sphere P} : p \u2208 s \u2194 dist s.center p = s.radius", "start": [99, 1], "end": [100, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.subset_sphere", "code": "theorem subset_sphere {ps : Set P} {s : Sphere P} : ps \u2286 s \u2194 \u2200 p \u2208 ps, p \u2208 s", "start": [103, 1], "end": [104, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_of_mem_subset_sphere", "code": "theorem dist_of_mem_subset_sphere {p : P} {ps : Set P} {s : Sphere P} (hp : p \u2208 ps)\n    (hps : ps \u2286 (s : Set P)) : dist p s.center = s.radius", "start": [107, 1], "end": [109, 68], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_of_mem_subset_mk_sphere", "code": "theorem dist_of_mem_subset_mk_sphere {p c : P} {ps : Set P} {r : \u211d} (hp : p \u2208 ps)\n    (hps : ps \u2286 \u2191(\u27e8c, r\u27e9 : Sphere P)) : dist p c = r", "start": [112, 1], "end": [114, 35], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.ne_iff", "code": "theorem Sphere.ne_iff {s\u2081 s\u2082 : Sphere P} :\n    s\u2081 \u2260 s\u2082 \u2194 s\u2081.center \u2260 s\u2082.center \u2228 s\u2081.radius \u2260 s\u2082.radius", "start": [117, 1], "end": [119, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.center_eq_iff_eq_of_mem", "code": "theorem Sphere.center_eq_iff_eq_of_mem {s\u2081 s\u2082 : Sphere P} {p : P} (hs\u2081 : p \u2208 s\u2081) (hs\u2082 : p \u2208 s\u2082) :\n    s\u2081.center = s\u2082.center \u2194 s\u2081 = s\u2082", "start": [122, 1], "end": [126, 23], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.center_ne_iff_ne_of_mem", "code": "theorem Sphere.center_ne_iff_ne_of_mem {s\u2081 s\u2082 : Sphere P} {p : P} (hs\u2081 : p \u2208 s\u2081) (hs\u2082 : p \u2208 s\u2082) :\n    s\u2081.center \u2260 s\u2082.center \u2194 s\u2081 \u2260 s\u2082", "start": [129, 1], "end": [131, 47], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_center_eq_dist_center_of_mem_sphere", "code": "theorem dist_center_eq_dist_center_of_mem_sphere {p\u2081 p\u2082 : P} {s : Sphere P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) : dist p\u2081 s.center = dist p\u2082 s.center", "start": [134, 1], "end": [136, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_center_eq_dist_center_of_mem_sphere'", "code": "theorem dist_center_eq_dist_center_of_mem_sphere' {p\u2081 p\u2082 : P} {s : Sphere P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : p\u2082 \u2208 s) : dist s.center p\u2081 = dist s.center p\u2082", "start": [139, 1], "end": [141, 44], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical", "code": "def Cospherical (ps : Set P) : Prop :=\n  \u2203 (center : P) (radius : \u211d), \u2200 p \u2208 ps, dist p center = radius", "start": [144, 1], "end": [148, 64], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_def", "code": "theorem cospherical_def (ps : Set P) :\n    Cospherical ps \u2194 \u2203 (center : P) (radius : \u211d), \u2200 p \u2208 ps, dist p center = radius", "start": [151, 1], "end": [154, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_iff_exists_sphere", "code": "theorem cospherical_iff_exists_sphere {ps : Set P} :\n    Cospherical ps \u2194 \u2203 s : Sphere P, ps \u2286 (s : Set P)", "start": [157, 1], "end": [164, 34], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Sphere.cospherical", "code": "theorem Sphere.cospherical (s : Sphere P) : Cospherical (s : Set P)", "start": [167, 1], "end": [169, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical.subset", "code": "theorem Cospherical.subset {ps\u2081 ps\u2082 : Set P} (hs : ps\u2081 \u2286 ps\u2082) (hc : Cospherical ps\u2082) :\n    Cospherical ps\u2081", "start": [172, 1], "end": [176, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_empty", "code": "theorem cospherical_empty [Nonempty P] : Cospherical (\u2205 : Set P)", "start": [179, 1], "end": [182, 30], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_singleton", "code": "theorem cospherical_singleton (p : P) : Cospherical ({p} : Set P)", "start": [185, 1], "end": [188, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_pair", "code": "theorem cospherical_pair (p\u2081 p\u2082 : P) : Cospherical ({p\u2081, p\u2082} : Set P)", "start": [197, 1], "end": [202, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Concyclic", "code": "structure Concyclic (ps : Set P) : Prop where\n  Cospherical : Cospherical ps\n  Coplanar : Coplanar \u211d ps", "start": [205, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Concyclic.subset", "code": "theorem Concyclic.subset {ps\u2081 ps\u2082 : Set P} (hs : ps\u2081 \u2286 ps\u2082) (h : Concyclic ps\u2082) : Concyclic ps\u2081", "start": [212, 1], "end": [214, 33], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.concyclic_empty", "code": "theorem concyclic_empty : Concyclic (\u2205 : Set P)", "start": [217, 1], "end": [219, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.concyclic_singleton", "code": "theorem concyclic_singleton (p : P) : Concyclic ({p} : Set P)", "start": [222, 1], "end": [224, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.concyclic_pair", "code": "theorem concyclic_pair (p\u2081 p\u2082 : P) : Concyclic ({p\u2081, p\u2082} : Set P)", "start": [227, 1], "end": [229, 50], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical.affineIndependent", "code": "theorem Cospherical.affineIndependent {s : Set P} (hs : Cospherical s) {p : Fin 3 \u2192 P}\n    (hps : Set.range p \u2286 s) (hpi : Function.Injective p) : AffineIndependent \u211d p", "start": [238, 1], "end": [273, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical.affineIndependent_of_mem_of_ne", "code": "theorem Cospherical.affineIndependent_of_mem_of_ne {s : Set P} (hs : Cospherical s) {p\u2081 p\u2082 p\u2083 : P}\n    (h\u2081 : p\u2081 \u2208 s) (h\u2082 : p\u2082 \u2208 s) (h\u2083 : p\u2083 \u2208 s) (h\u2081\u2082 : p\u2081 \u2260 p\u2082) (h\u2081\u2083 : p\u2081 \u2260 p\u2083) (h\u2082\u2083 : p\u2082 \u2260 p\u2083) :\n    AffineIndependent \u211d ![p\u2081, p\u2082, p\u2083]", "start": [276, 1], "end": [283, 45], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.Cospherical.affineIndependent_of_ne", "code": "theorem Cospherical.affineIndependent_of_ne {p\u2081 p\u2082 p\u2083 : P} (hs : Cospherical ({p\u2081, p\u2082, p\u2083} : Set P))\n    (h\u2081\u2082 : p\u2081 \u2260 p\u2082) (h\u2081\u2083 : p\u2081 \u2260 p\u2083) (h\u2082\u2083 : p\u2082 \u2260 p\u2083) : AffineIndependent \u211d ![p\u2081, p\u2082, p\u2083]", "start": [286, 1], "end": [291, 90], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inner_vsub_vsub_of_mem_sphere_of_mem_sphere", "code": "theorem inner_vsub_vsub_of_mem_sphere_of_mem_sphere {p\u2081 p\u2082 : P} {s\u2081 s\u2082 : Sphere P} (hp\u2081s\u2081 : p\u2081 \u2208 s\u2081)\n    (hp\u2082s\u2081 : p\u2082 \u2208 s\u2081) (hp\u2081s\u2082 : p\u2081 \u2208 s\u2082) (hp\u2082s\u2082 : p\u2082 \u2208 s\u2082) :\n    \u27eas\u2082.center -\u1d65 s\u2081.center, p\u2082 -\u1d65 p\u2081\u27eb = 0", "start": [294, 1], "end": [302, 59], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two", "code": "theorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace \u211d P}\n    [FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = 2) {s\u2081 s\u2082 : Sphere P}\n    {p\u2081 p\u2082 p : P} (hs\u2081 : s\u2081.center \u2208 s) (hs\u2082 : s\u2082.center \u2208 s) (hp\u2081s : p\u2081 \u2208 s) (hp\u2082s : p\u2082 \u2208 s)\n    (hps : p \u2208 s) (hs : s\u2081 \u2260 s\u2082) (hp : p\u2081 \u2260 p\u2082) (hp\u2081s\u2081 : p\u2081 \u2208 s\u2081) (hp\u2082s\u2081 : p\u2082 \u2208 s\u2081) (hps\u2081 : p \u2208 s\u2081)\n    (hp\u2081s\u2082 : p\u2081 \u2208 s\u2082) (hp\u2082s\u2082 : p\u2082 \u2208 s\u2082) (hps\u2082 : p \u2208 s\u2082) : p = p\u2081 \u2228 p = p\u2082", "start": [305, 1], "end": [314, 91], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two", "code": "theorem eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = 2) {s\u2081 s\u2082 : Sphere P} {p\u2081 p\u2082 p : P} (hs : s\u2081 \u2260 s\u2082) (hp : p\u2081 \u2260 p\u2082)\n    (hp\u2081s\u2081 : p\u2081 \u2208 s\u2081) (hp\u2082s\u2081 : p\u2082 \u2208 s\u2081) (hps\u2081 : p \u2208 s\u2081) (hp\u2081s\u2082 : p\u2081 \u2208 s\u2082) (hp\u2082s\u2082 : p\u2082 \u2208 s\u2082)\n    (hps\u2082 : p \u2208 s\u2082) : p = p\u2081 \u2228 p = p\u2082", "start": [317, 1], "end": [324, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inner_pos_or_eq_of_dist_le_radius", "code": "theorem inner_pos_or_eq_of_dist_le_radius {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : dist p\u2082 s.center \u2264 s.radius) : 0 < \u27eap\u2081 -\u1d65 p\u2082, p\u2081 -\u1d65 s.center\u27eb \u2228 p\u2081 = p\u2082", "start": [327, 1], "end": [354, 23], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inner_nonneg_of_dist_le_radius", "code": "theorem inner_nonneg_of_dist_le_radius {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : dist p\u2082 s.center \u2264 s.radius) : 0 \u2264 \u27eap\u2081 -\u1d65 p\u2082, p\u2081 -\u1d65 s.center\u27eb", "start": [357, 1], "end": [363, 9], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inner_pos_of_dist_lt_radius", "code": "theorem inner_pos_of_dist_lt_radius {s : Sphere P} {p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2208 s)\n    (hp\u2082 : dist p\u2082 s.center < s.radius) : 0 < \u27eap\u2081 -\u1d65 p\u2082, p\u2081 -\u1d65 s.center\u27eb", "start": [366, 1], "end": [373, 71], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.wbtw_of_collinear_of_dist_center_le_radius", "code": "theorem wbtw_of_collinear_of_dist_center_le_radius {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)) (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : dist p\u2082 s.center \u2264 s.radius)\n    (hp\u2083 : p\u2083 \u2208 s) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : Wbtw \u211d p\u2081 p\u2082 p\u2083", "start": [376, 1], "end": [381, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius", "code": "theorem sbtw_of_collinear_of_dist_center_lt_radius {s : Sphere P} {p\u2081 p\u2082 p\u2083 : P}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)) (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : dist p\u2082 s.center < s.radius)\n    (hp\u2083 : p\u2083 \u2208 s) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : Sbtw \u211d p\u2081 p\u2082 p\u2083", "start": [384, 1], "end": [389, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "imports": ["Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "Mathlib/Analysis/Convex/Side.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.o", "code": "abbrev o := @Module.Oriented.positiveOrientation", "start": [36, 1], "end": [36, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle", "code": "def oangle (p\u2081 p\u2082 p\u2083 : P) : Real.Angle :=\n  o.oangle (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2082)", "start": [38, 1], "end": [42, 33], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.continuousAt_oangle", "code": "theorem continuousAt_oangle {x : P \u00d7 P \u00d7 P} (hx12 : x.1 \u2260 x.2.1) (hx32 : x.2.2 \u2260 x.2.1) :\n    ContinuousAt (fun y : P \u00d7 P \u00d7 P => \u2221 y.1 y.2.1 y.2.2) x", "start": [47, 1], "end": [54, 63], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_self_left", "code": "@[simp]\ntheorem oangle_self_left (p\u2081 p\u2082 : P) : \u2221 p\u2081 p\u2081 p\u2082 = 0", "start": [57, 1], "end": [59, 74], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_self_right", "code": "@[simp]\ntheorem oangle_self_right (p\u2081 p\u2082 : P) : \u2221 p\u2081 p\u2082 p\u2082 = 0", "start": [62, 1], "end": [64, 75], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_self_left_right", "code": "@[simp]\ntheorem oangle_self_left_right (p\u2081 p\u2082 : P) : \u2221 p\u2081 p\u2082 p\u2081 = 0", "start": [67, 1], "end": [70, 18], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_ne_zero", "code": "theorem left_ne_of_oangle_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 \u2260 0) : p\u2081 \u2260 p\u2082", "start": [73, 1], "end": [75, 67], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_ne_zero", "code": "theorem right_ne_of_oangle_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 \u2260 0) : p\u2083 \u2260 p\u2082", "start": [78, 1], "end": [80, 68], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_ne_zero", "code": "theorem left_ne_right_of_oangle_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 \u2260 0) : p\u2081 \u2260 p\u2083", "start": [83, 1], "end": [85, 73], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_eq_pi", "code": "theorem left_ne_of_oangle_eq_pi {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0) : p\u2081 \u2260 p\u2082", "start": [88, 1], "end": [90, 78], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_eq_pi", "code": "theorem right_ne_of_oangle_eq_pi {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0) : p\u2083 \u2260 p\u2082", "start": [93, 1], "end": [95, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_eq_pi", "code": "theorem left_ne_right_of_oangle_eq_pi {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0) : p\u2081 \u2260 p\u2083", "start": [98, 1], "end": [100, 84], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_eq_pi_div_two", "code": "theorem left_ne_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (\u03c0 / 2 : \u211d)) : p\u2081 \u2260 p\u2082", "start": [103, 1], "end": [105, 86], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_eq_pi_div_two", "code": "theorem right_ne_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (\u03c0 / 2 : \u211d)) : p\u2083 \u2260 p\u2082", "start": [108, 1], "end": [110, 87], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_eq_pi_div_two", "code": "theorem left_ne_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (\u03c0 / 2 : \u211d)) :\n    p\u2081 \u2260 p\u2083", "start": [113, 1], "end": [116, 92], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_eq_neg_pi_div_two", "code": "theorem left_ne_of_oangle_eq_neg_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (-\u03c0 / 2 : \u211d)) :\n    p\u2081 \u2260 p\u2082", "start": [119, 1], "end": [122, 90], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_eq_neg_pi_div_two", "code": "theorem right_ne_of_oangle_eq_neg_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (-\u03c0 / 2 : \u211d)) :\n    p\u2083 \u2260 p\u2082", "start": [125, 1], "end": [128, 91], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_eq_neg_pi_div_two", "code": "theorem left_ne_right_of_oangle_eq_neg_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = (-\u03c0 / 2 : \u211d)) :\n    p\u2081 \u2260 p\u2083", "start": [131, 1], "end": [134, 96], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_sign_ne_zero", "code": "theorem left_ne_of_oangle_sign_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign \u2260 0) : p\u2081 \u2260 p\u2082", "start": [137, 1], "end": [140, 64], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_sign_ne_zero", "code": "theorem right_ne_of_oangle_sign_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign \u2260 0) : p\u2083 \u2260 p\u2082", "start": [143, 1], "end": [146, 65], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_sign_ne_zero", "code": "theorem left_ne_right_of_oangle_sign_ne_zero {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign \u2260 0) : p\u2081 \u2260 p\u2083", "start": [149, 1], "end": [152, 70], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_sign_eq_one", "code": "theorem left_ne_of_oangle_sign_eq_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = 1) : p\u2081 \u2260 p\u2082", "start": [155, 1], "end": [158, 78], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_sign_eq_one", "code": "theorem right_ne_of_oangle_sign_eq_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = 1) : p\u2083 \u2260 p\u2082", "start": [161, 1], "end": [164, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_sign_eq_one", "code": "theorem left_ne_right_of_oangle_sign_eq_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = 1) : p\u2081 \u2260 p\u2083", "start": [167, 1], "end": [170, 84], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_of_oangle_sign_eq_neg_one", "code": "theorem left_ne_of_oangle_sign_eq_neg_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = -1) : p\u2081 \u2260 p\u2082", "start": [173, 1], "end": [176, 78], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.right_ne_of_oangle_sign_eq_neg_one", "code": "theorem right_ne_of_oangle_sign_eq_neg_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = -1) : p\u2083 \u2260 p\u2082", "start": [179, 1], "end": [182, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.left_ne_right_of_oangle_sign_eq_neg_one", "code": "theorem left_ne_right_of_oangle_sign_eq_neg_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = -1) :\n    p\u2081 \u2260 p\u2083", "start": [185, 1], "end": [189, 84], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_rev", "code": "theorem oangle_rev (p\u2081 p\u2082 p\u2083 : P) : \u2221 p\u2083 p\u2082 p\u2081 = -\u2221 p\u2081 p\u2082 p\u2083", "start": [192, 1], "end": [194, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_add_oangle_rev", "code": "@[simp]\ntheorem oangle_add_oangle_rev (p\u2081 p\u2082 p\u2083 : P) : \u2221 p\u2081 p\u2082 p\u2083 + \u2221 p\u2083 p\u2082 p\u2081 = 0", "start": [197, 1], "end": [200, 30], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_zero_iff_oangle_rev_eq_zero", "code": "theorem oangle_eq_zero_iff_oangle_rev_eq_zero {p\u2081 p\u2082 p\u2083 : P} : \u2221 p\u2081 p\u2082 p\u2083 = 0 \u2194 \u2221 p\u2083 p\u2082 p\u2081 = 0", "start": [203, 1], "end": [206, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_pi_iff_oangle_rev_eq_pi", "code": "theorem oangle_eq_pi_iff_oangle_rev_eq_pi {p\u2081 p\u2082 p\u2083 : P} : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0 \u2194 \u2221 p\u2083 p\u2082 p\u2081 = \u03c0", "start": [209, 1], "end": [212, 38], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_ne_zero_and_ne_pi_iff_affineIndependent", "code": "theorem oangle_ne_zero_and_ne_pi_iff_affineIndependent {p\u2081 p\u2082 p\u2083 : P} :\n    \u2221 p\u2081 p\u2082 p\u2083 \u2260 0 \u2227 \u2221 p\u2081 p\u2082 p\u2083 \u2260 \u03c0 \u2194 AffineIndependent \u211d ![p\u2081, p\u2082, p\u2083]", "start": [215, 1], "end": [224, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_zero_or_eq_pi_iff_collinear", "code": "theorem oangle_eq_zero_or_eq_pi_iff_collinear {p\u2081 p\u2082 p\u2083 : P} :\n    \u2221 p\u2081 p\u2082 p\u2083 = 0 \u2228 \u2221 p\u2081 p\u2082 p\u2083 = \u03c0 \u2194 Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)", "start": [227, 1], "end": [231, 45], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.affineIndependent_iff_of_two_zsmul_oangle_eq", "code": "theorem affineIndependent_iff_of_two_zsmul_oangle_eq {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2084 p\u2085 p\u2086) :\n    AffineIndependent \u211d ![p\u2081, p\u2082, p\u2083] \u2194 AffineIndependent \u211d ![p\u2084, p\u2085, p\u2086]", "start": [234, 1], "end": [239, 100], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.collinear_iff_of_two_zsmul_oangle_eq", "code": "theorem collinear_iff_of_two_zsmul_oangle_eq {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P}\n    (h : (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2084 p\u2085 p\u2086) :\n    Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P) \u2194 Collinear \u211d ({p\u2084, p\u2085, p\u2086} : Set P)", "start": [242, 1], "end": [247, 91], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.two_zsmul_oangle_of_vectorSpan_eq", "code": "theorem two_zsmul_oangle_of_vectorSpan_eq {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P}\n    (h\u2081\u2082\u2084\u2085 : vectorSpan \u211d ({p\u2081, p\u2082} : Set P) = vectorSpan \u211d ({p\u2084, p\u2085} : Set P))\n    (h\u2083\u2082\u2086\u2085 : vectorSpan \u211d ({p\u2083, p\u2082} : Set P) = vectorSpan \u211d ({p\u2086, p\u2085} : Set P)) :\n    (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2084 p\u2085 p\u2086", "start": [250, 1], "end": [257, 61], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.two_zsmul_oangle_of_parallel", "code": "theorem two_zsmul_oangle_of_parallel {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P}\n    (h\u2081\u2082\u2084\u2085 : line[\u211d, p\u2081, p\u2082] \u2225 line[\u211d, p\u2084, p\u2085]) (h\u2083\u2082\u2086\u2085 : line[\u211d, p\u2083, p\u2082] \u2225 line[\u211d, p\u2086, p\u2085]) :\n    (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2084 p\u2085 p\u2086", "start": [260, 1], "end": [266, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_add", "code": "@[simp]\ntheorem oangle_add {p p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) (hp\u2083 : p\u2083 \u2260 p) :\n    \u2221 p\u2081 p p\u2082 + \u2221 p\u2082 p p\u2083 = \u2221 p\u2081 p p\u2083", "start": [269, 1], "end": [274, 78], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_add_swap", "code": "@[simp]\ntheorem oangle_add_swap {p p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) (hp\u2083 : p\u2083 \u2260 p) :\n    \u2221 p\u2082 p p\u2083 + \u2221 p\u2081 p p\u2082 = \u2221 p\u2081 p p\u2083", "start": [277, 1], "end": [282, 83], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_sub_left", "code": "@[simp]\ntheorem oangle_sub_left {p p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) (hp\u2083 : p\u2083 \u2260 p) :\n    \u2221 p\u2081 p p\u2083 - \u2221 p\u2081 p p\u2082 = \u2221 p\u2082 p p\u2083", "start": [285, 1], "end": [290, 83], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_sub_right", "code": "@[simp]\ntheorem oangle_sub_right {p p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) (hp\u2083 : p\u2083 \u2260 p) :\n    \u2221 p\u2081 p p\u2083 - \u2221 p\u2082 p p\u2083 = \u2221 p\u2081 p p\u2082", "start": [293, 1], "end": [298, 84], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_add_cyc3", "code": "@[simp]\ntheorem oangle_add_cyc3 {p p\u2081 p\u2082 p\u2083 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) (hp\u2083 : p\u2083 \u2260 p) :\n    \u2221 p\u2081 p p\u2082 + \u2221 p\u2082 p p\u2083 + \u2221 p\u2083 p p\u2081 = 0", "start": [301, 1], "end": [306, 83], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_oangle_of_dist_eq", "code": "theorem oangle_eq_oangle_of_dist_eq {p\u2081 p\u2082 p\u2083 : P} (h : dist p\u2081 p\u2082 = dist p\u2081 p\u2083) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2082 p\u2083 p\u2081", "start": [309, 1], "end": [314, 49], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_pi_sub_two_zsmul_oangle_of_dist_eq", "code": "theorem oangle_eq_pi_sub_two_zsmul_oangle_of_dist_eq {p\u2081 p\u2082 p\u2083 : P} (hn : p\u2082 \u2260 p\u2083)\n    (h : dist p\u2081 p\u2082 = dist p\u2081 p\u2083) : \u2221 p\u2083 p\u2081 p\u2082 = \u03c0 - (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083", "start": [317, 1], "end": [326, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.abs_oangle_right_toReal_lt_pi_div_two_of_dist_eq", "code": "theorem abs_oangle_right_toReal_lt_pi_div_two_of_dist_eq {p\u2081 p\u2082 p\u2083 : P}\n    (h : dist p\u2081 p\u2082 = dist p\u2081 p\u2083) : |(\u2221 p\u2081 p\u2082 p\u2083).toReal| < \u03c0 / 2", "start": [329, 1], "end": [334, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.abs_oangle_left_toReal_lt_pi_div_two_of_dist_eq", "code": "theorem abs_oangle_left_toReal_lt_pi_div_two_of_dist_eq {p\u2081 p\u2082 p\u2083 : P}\n    (h : dist p\u2081 p\u2082 = dist p\u2081 p\u2083) : |(\u2221 p\u2082 p\u2083 p\u2081).toReal| < \u03c0 / 2", "start": [337, 1], "end": [340, 85], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_oangle_eq_cos_angle", "code": "theorem cos_oangle_eq_cos_angle {p p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) :\n    Real.Angle.cos (\u2221 p\u2081 p p\u2082) = Real.cos (\u2220 p\u2081 p p\u2082)", "start": [343, 1], "end": [347, 70], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_angle_or_eq_neg_angle", "code": "theorem oangle_eq_angle_or_eq_neg_angle {p p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) :\n    \u2221 p\u2081 p p\u2082 = \u2220 p\u2081 p p\u2082 \u2228 \u2221 p\u2081 p p\u2082 = -\u2220 p\u2081 p p\u2082", "start": [350, 1], "end": [354, 78], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_abs_oangle_toReal", "code": "theorem angle_eq_abs_oangle_toReal {p p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) :\n    \u2220 p\u2081 p p\u2082 = |(\u2221 p\u2081 p p\u2082).toReal|", "start": [357, 1], "end": [361, 73], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero", "code": "theorem eq_zero_or_angle_eq_zero_or_pi_of_sign_oangle_eq_zero {p p\u2081 p\u2082 : P}\n    (h : (\u2221 p\u2081 p p\u2082).sign = 0) : p\u2081 = p \u2228 p\u2082 = p \u2228 \u2220 p\u2081 p p\u2082 = 0 \u2228 \u2220 p\u2081 p p\u2082 = \u03c0", "start": [364, 1], "end": [368, 77], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_of_angle_eq_of_sign_eq", "code": "theorem oangle_eq_of_angle_eq_of_sign_eq {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u2220 p\u2084 p\u2085 p\u2086)\n    (hs : (\u2221 p\u2081 p\u2082 p\u2083).sign = (\u2221 p\u2084 p\u2085 p\u2086).sign) : \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2084 p\u2085 p\u2086", "start": [371, 1], "end": [375, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_iff_oangle_eq_of_sign_eq", "code": "theorem angle_eq_iff_oangle_eq_of_sign_eq {p\u2081 p\u2082 p\u2083 p\u2084 p\u2085 p\u2086 : P} (hp\u2081 : p\u2081 \u2260 p\u2082) (hp\u2083 : p\u2083 \u2260 p\u2082)\n    (hp\u2084 : p\u2084 \u2260 p\u2085) (hp\u2086 : p\u2086 \u2260 p\u2085) (hs : (\u2221 p\u2081 p\u2082 p\u2083).sign = (\u2221 p\u2084 p\u2085 p\u2086).sign) :\n    \u2220 p\u2081 p\u2082 p\u2083 = \u2220 p\u2084 p\u2085 p\u2086 \u2194 \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2084 p\u2085 p\u2086", "start": [378, 1], "end": [384, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_angle_of_sign_eq_one", "code": "theorem oangle_eq_angle_of_sign_eq_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = 1) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2220 p\u2081 p\u2082 p\u2083", "start": [387, 1], "end": [391, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_neg_angle_of_sign_eq_neg_one", "code": "theorem oangle_eq_neg_angle_of_sign_eq_neg_one {p\u2081 p\u2082 p\u2083 : P} (h : (\u2221 p\u2081 p\u2082 p\u2083).sign = -1) :\n    \u2221 p\u2081 p\u2082 p\u2083 = -\u2220 p\u2081 p\u2082 p\u2083", "start": [394, 1], "end": [398, 45], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_zero_iff_angle_eq_zero", "code": "theorem oangle_eq_zero_iff_angle_eq_zero {p p\u2081 p\u2082 : P} (hp\u2081 : p\u2081 \u2260 p) (hp\u2082 : p\u2082 \u2260 p) :\n    \u2221 p\u2081 p p\u2082 = 0 \u2194 \u2220 p\u2081 p p\u2082 = 0", "start": [401, 1], "end": [405, 79], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_pi_iff_angle_eq_pi", "code": "theorem oangle_eq_pi_iff_angle_eq_pi {p\u2081 p\u2082 p\u2083 : P} : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0 \u2194 \u2220 p\u2081 p\u2082 p\u2083 = \u03c0", "start": [408, 1], "end": [410, 33], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_pi_div_two_of_oangle_eq_pi_div_two", "code": "theorem angle_eq_pi_div_two_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2", "start": [413, 1], "end": [417, 50], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_rev_eq_pi_div_two_of_oangle_eq_pi_div_two", "code": "theorem angle_rev_eq_pi_div_two_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2220 p\u2083 p\u2082 p\u2081 = \u03c0 / 2", "start": [420, 1], "end": [425, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two", "code": "theorem angle_eq_pi_div_two_of_oangle_eq_neg_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(-\u03c0 / 2)) : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2", "start": [428, 1], "end": [432, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_rev_eq_pi_div_two_of_oangle_eq_neg_pi_div_two", "code": "theorem angle_rev_eq_pi_div_two_of_oangle_eq_neg_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(-\u03c0 / 2)) : \u2220 p\u2083 p\u2082 p\u2081 = \u03c0 / 2", "start": [435, 1], "end": [440, 58], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_swap\u2081\u2082_sign", "code": "theorem oangle_swap\u2081\u2082_sign (p\u2081 p\u2082 p\u2083 : P) : -(\u2221 p\u2081 p\u2082 p\u2083).sign = (\u2221 p\u2082 p\u2081 p\u2083).sign", "start": [443, 1], "end": [450, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_swap\u2081\u2083_sign", "code": "theorem oangle_swap\u2081\u2083_sign (p\u2081 p\u2082 p\u2083 : P) : -(\u2221 p\u2081 p\u2082 p\u2083).sign = (\u2221 p\u2083 p\u2082 p\u2081).sign", "start": [453, 1], "end": [455, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_swap\u2082\u2083_sign", "code": "theorem oangle_swap\u2082\u2083_sign (p\u2081 p\u2082 p\u2083 : P) : -(\u2221 p\u2081 p\u2082 p\u2083).sign = (\u2221 p\u2081 p\u2083 p\u2082).sign", "start": [458, 1], "end": [460, 68], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_rotate_sign", "code": "theorem oangle_rotate_sign (p\u2081 p\u2082 p\u2083 : P) : (\u2221 p\u2082 p\u2083 p\u2081).sign = (\u2221 p\u2081 p\u2082 p\u2083).sign", "start": [463, 1], "end": [465, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_pi_iff_sbtw", "code": "theorem oangle_eq_pi_iff_sbtw {p\u2081 p\u2082 p\u2083 : P} : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0 \u2194 Sbtw \u211d p\u2081 p\u2082 p\u2083", "start": [468, 1], "end": [471, 58], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2081\u2082\u2083_eq_pi", "code": "theorem _root_.Sbtw.oangle\u2081\u2082\u2083_eq_pi {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2081 p\u2082 p\u2083 = \u03c0", "start": [474, 1], "end": [477, 28], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2083\u2082\u2081_eq_pi", "code": "theorem _root_.Sbtw.oangle\u2083\u2082\u2081_eq_pi {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2083 p\u2082 p\u2081 = \u03c0", "start": [480, 1], "end": [483, 62], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle\u2082\u2081\u2083_eq_zero", "code": "theorem _root_.Wbtw.oangle\u2082\u2081\u2083_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2082 p\u2081 p\u2083 = 0", "start": [486, 1], "end": [492, 39], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2082\u2081\u2083_eq_zero", "code": "theorem _root_.Sbtw.oangle\u2082\u2081\u2083_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2082 p\u2081 p\u2083 = 0", "start": [495, 1], "end": [498, 27], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle\u2083\u2081\u2082_eq_zero", "code": "theorem _root_.Wbtw.oangle\u2083\u2081\u2082_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2083 p\u2081 p\u2082 = 0", "start": [501, 1], "end": [504, 66], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2083\u2081\u2082_eq_zero", "code": "theorem _root_.Sbtw.oangle\u2083\u2081\u2082_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2083 p\u2081 p\u2082 = 0", "start": [507, 1], "end": [510, 27], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle\u2082\u2083\u2081_eq_zero", "code": "theorem _root_.Wbtw.oangle\u2082\u2083\u2081_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2082 p\u2083 p\u2081 = 0", "start": [513, 1], "end": [516, 27], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2082\u2083\u2081_eq_zero", "code": "theorem _root_.Sbtw.oangle\u2082\u2083\u2081_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2082 p\u2083 p\u2081 = 0", "start": [519, 1], "end": [522, 27], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle\u2081\u2083\u2082_eq_zero", "code": "theorem _root_.Wbtw.oangle\u2081\u2083\u2082_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2081 p\u2083 p\u2082 = 0", "start": [525, 1], "end": [528, 27], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle\u2081\u2083\u2082_eq_zero", "code": "theorem _root_.Sbtw.oangle\u2081\u2083\u2082_eq_zero {p\u2081 p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) : \u2221 p\u2081 p\u2083 p\u2082 = 0", "start": [531, 1], "end": [534, 27], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_eq_zero_iff_wbtw", "code": "theorem oangle_eq_zero_iff_wbtw {p\u2081 p\u2082 p\u2083 : P} :\n    \u2221 p\u2081 p\u2082 p\u2083 = 0 \u2194 Wbtw \u211d p\u2082 p\u2081 p\u2083 \u2228 Wbtw \u211d p\u2082 p\u2083 p\u2081", "start": [537, 1], "end": [544, 22], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle_eq_left", "code": "theorem _root_.Wbtw.oangle_eq_left {p\u2081 p\u2081' p\u2082 p\u2083 : P} (h : Wbtw \u211d p\u2082 p\u2081 p\u2081') (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081' p\u2082 p\u2083", "start": [547, 1], "end": [553, 70], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_eq_left", "code": "theorem _root_.Sbtw.oangle_eq_left {p\u2081 p\u2081' p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2082 p\u2081 p\u2081') :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081' p\u2082 p\u2083", "start": [556, 1], "end": [560, 34], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle_eq_right", "code": "theorem _root_.Wbtw.oangle_eq_right {p\u2081 p\u2082 p\u2083 p\u2083' : P} (h : Wbtw \u211d p\u2082 p\u2083 p\u2083') (hp\u2083p\u2082 : p\u2083 \u2260 p\u2082) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081 p\u2082 p\u2083'", "start": [563, 1], "end": [566, 89], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_eq_right", "code": "theorem _root_.Sbtw.oangle_eq_right {p\u2081 p\u2082 p\u2083 p\u2083' : P} (h : Sbtw \u211d p\u2082 p\u2083 p\u2083') :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081 p\u2082 p\u2083'", "start": [569, 1], "end": [573, 35], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_midpoint_left", "code": "@[simp]\ntheorem oangle_midpoint_left (p\u2081 p\u2082 p\u2083 : P) : \u2221 (midpoint \u211d p\u2081 p\u2082) p\u2082 p\u2083 = \u2221 p\u2081 p\u2082 p\u2083", "start": [576, 1], "end": [581, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_midpoint_rev_left", "code": "@[simp]\ntheorem oangle_midpoint_rev_left (p\u2081 p\u2082 p\u2083 : P) : \u2221 (midpoint \u211d p\u2082 p\u2081) p\u2082 p\u2083 = \u2221 p\u2081 p\u2082 p\u2083", "start": [584, 1], "end": [588, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_midpoint_right", "code": "@[simp]\ntheorem oangle_midpoint_right (p\u2081 p\u2082 p\u2083 : P) : \u2221 p\u2081 p\u2082 (midpoint \u211d p\u2083 p\u2082) = \u2221 p\u2081 p\u2082 p\u2083", "start": [591, 1], "end": [596, 55], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_midpoint_rev_right", "code": "@[simp]\ntheorem oangle_midpoint_rev_right (p\u2081 p\u2082 p\u2083 : P) : \u2221 p\u2081 p\u2082 (midpoint \u211d p\u2082 p\u2083) = \u2221 p\u2081 p\u2082 p\u2083", "start": [599, 1], "end": [603, 44], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_eq_add_pi_left", "code": "theorem _root_.Sbtw.oangle_eq_add_pi_left\n    {p\u2081 p\u2081' p\u2082 p\u2083 : P} (h : Sbtw \u211d p\u2081 p\u2082 p\u2081') (hp\u2083p\u2082 : p\u2083 \u2260 p\u2082) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081' p\u2082 p\u2083 + \u03c0", "start": [606, 1], "end": [611, 71], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_eq_add_pi_right", "code": "theorem _root_.Sbtw.oangle_eq_add_pi_right\n    {p\u2081 p\u2082 p\u2083 p\u2083' : P} (h : Sbtw \u211d p\u2083 p\u2082 p\u2083') (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) :\n    \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081 p\u2082 p\u2083' + \u03c0", "start": [614, 1], "end": [619, 66], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_eq_left_right", "code": "theorem _root_.Sbtw.oangle_eq_left_right {p\u2081 p\u2081' p\u2082 p\u2083 p\u2083' : P} (h\u2081 : Sbtw \u211d p\u2081 p\u2082 p\u2081')\n    (h\u2083 : Sbtw \u211d p\u2083 p\u2082 p\u2083') : \u2221 p\u2081 p\u2082 p\u2083 = \u2221 p\u2081' p\u2082 p\u2083'", "start": [622, 1], "end": [627, 44], "kind": "commanddeclaration"}, {"full_name": "Collinear.two_zsmul_oangle_eq_left", "code": "theorem _root_.Collinear.two_zsmul_oangle_eq_left {p\u2081 p\u2081' p\u2082 p\u2083 : P}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2081'} : Set P)) (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082) (hp\u2081'p\u2082 : p\u2081' \u2260 p\u2082) :\n    (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2081' p\u2082 p\u2083", "start": [630, 1], "end": [639, 38], "kind": "commanddeclaration"}, {"full_name": "Collinear.two_zsmul_oangle_eq_right", "code": "theorem _root_.Collinear.two_zsmul_oangle_eq_right {p\u2081 p\u2082 p\u2083 p\u2083' : P}\n    (h : Collinear \u211d ({p\u2083, p\u2082, p\u2083'} : Set P)) (hp\u2083p\u2082 : p\u2083 \u2260 p\u2082) (hp\u2083'p\u2082 : p\u2083' \u2260 p\u2082) :\n    (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083 = (2 : \u2124) \u2022 \u2221 p\u2081 p\u2082 p\u2083'", "start": [642, 1], "end": [646, 95], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint", "code": "theorem dist_eq_iff_eq_smul_rotation_pi_div_two_vadd_midpoint {p\u2081 p\u2082 p : P} (h : p\u2081 \u2260 p\u2082) :\n    dist p\u2081 p = dist p\u2082 p \u2194\n      \u2203 r : \u211d, r \u2022 o.rotation (\u03c0 / 2 : \u211d) (p\u2082 -\u1d65 p\u2081) +\u1d65 midpoint \u211d p\u2081 p\u2082 = p", "start": [649, 1], "end": [672, 33], "kind": "commanddeclaration"}, {"full_name": "Collinear.oangle_sign_of_sameRay_vsub", "code": "theorem _root_.Collinear.oangle_sign_of_sameRay_vsub {p\u2081 p\u2082 p\u2083 p\u2084 : P} (p\u2085 : P) (hp\u2081p\u2082 : p\u2081 \u2260 p\u2082)\n    (hp\u2083p\u2084 : p\u2083 \u2260 p\u2084) (hc : Collinear \u211d ({p\u2081, p\u2082, p\u2083, p\u2084} : Set P))\n    (hr : SameRay \u211d (p\u2082 -\u1d65 p\u2081) (p\u2084 -\u1d65 p\u2083)) : (\u2221 p\u2081 p\u2085 p\u2082).sign = (\u2221 p\u2083 p\u2085 p\u2084).sign", "start": [677, 1], "end": [755, 72], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_sign_eq", "code": "theorem _root_.Sbtw.oangle_sign_eq {p\u2081 p\u2082 p\u2083 : P} (p\u2084 : P) (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) :\n    (\u2221 p\u2081 p\u2084 p\u2082).sign = (\u2221 p\u2082 p\u2084 p\u2083).sign", "start": [758, 1], "end": [763, 76], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle_sign_eq_of_ne_left", "code": "theorem _root_.Wbtw.oangle_sign_eq_of_ne_left {p\u2081 p\u2082 p\u2083 : P} (p\u2084 : P) (h : Wbtw \u211d p\u2081 p\u2082 p\u2083)\n    (hne : p\u2081 \u2260 p\u2082) : (\u2221 p\u2081 p\u2084 p\u2082).sign = (\u2221 p\u2081 p\u2084 p\u2083).sign", "start": [766, 1], "end": [773, 97], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_sign_eq_left", "code": "theorem _root_.Sbtw.oangle_sign_eq_left {p\u2081 p\u2082 p\u2083 : P} (p\u2084 : P) (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) :\n    (\u2221 p\u2081 p\u2084 p\u2082).sign = (\u2221 p\u2081 p\u2084 p\u2083).sign", "start": [776, 1], "end": [780, 47], "kind": "commanddeclaration"}, {"full_name": "Wbtw.oangle_sign_eq_of_ne_right", "code": "theorem _root_.Wbtw.oangle_sign_eq_of_ne_right {p\u2081 p\u2082 p\u2083 : P} (p\u2084 : P) (h : Wbtw \u211d p\u2081 p\u2082 p\u2083)\n    (hne : p\u2082 \u2260 p\u2083) : (\u2221 p\u2082 p\u2084 p\u2083).sign = (\u2221 p\u2081 p\u2084 p\u2083).sign", "start": [783, 1], "end": [788, 92], "kind": "commanddeclaration"}, {"full_name": "Sbtw.oangle_sign_eq_right", "code": "theorem _root_.Sbtw.oangle_sign_eq_right {p\u2081 p\u2082 p\u2083 : P} (p\u2084 : P) (h : Sbtw \u211d p\u2081 p\u2082 p\u2083) :\n    (\u2221 p\u2082 p\u2084 p\u2083).sign = (\u2221 p\u2081 p\u2084 p\u2083).sign", "start": [791, 1], "end": [795, 49], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.SSameSide.oangle_sign_eq", "code": "theorem _root_.AffineSubspace.SSameSide.oangle_sign_eq {s : AffineSubspace \u211d P} {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083p\u2084 : s.SSameSide p\u2083 p\u2084) :\n    (\u2221 p\u2081 p\u2084 p\u2082).sign = (\u2221 p\u2081 p\u2083 p\u2082).sign", "start": [798, 1], "end": [826, 63], "kind": "commanddeclaration"}, {"full_name": "AffineSubspace.SOppSide.oangle_sign_eq_neg", "code": "theorem _root_.AffineSubspace.SOppSide.oangle_sign_eq_neg {s : AffineSubspace \u211d P} {p\u2081 p\u2082 p\u2083 p\u2084 : P}\n    (hp\u2081 : p\u2081 \u2208 s) (hp\u2082 : p\u2082 \u2208 s) (hp\u2083p\u2084 : s.SOppSide p\u2083 p\u2084) :\n    (\u2221 p\u2081 p\u2084 p\u2082).sign = -(\u2221 p\u2081 p\u2083 p\u2082).sign", "start": [829, 1], "end": [837, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/CommMon_.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Mon_.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CommMon_", "code": "structure CommMon_ extends Mon_ C where\n  mul_comm : (\u03b2_ _ _).hom \u226b mul = mul := by aesop_cat", "start": [22, 1], "end": [25, 54], "kind": "commanddeclaration"}, {"full_name": "CommMon_.trivial", "code": "@[simps!]\ndef trivial : CommMon_ C :=\n  { Mon_.trivial C with mul_comm := by dsimp; rw [braiding_leftUnitor, unitors_equal] }", "start": [33, 1], "end": [37, 88], "kind": "commanddeclaration"}, {"full_name": "CommMon_.id_hom", "code": "@[simp]\ntheorem id_hom (A : CommMon_ C) : Mon_.Hom.hom (\ud835\udfd9 A) = \ud835\udfd9 A.X", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "CommMon_.comp_hom", "code": "@[simp]\ntheorem comp_hom {R S T : CommMon_ C} (f : R \u27f6 S) (g : S \u27f6 T) :\n    Mon_.Hom.hom (f \u226b g) = f.hom \u226b g.hom", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "CommMon_.hom_ext", "code": "@[ext]\nlemma hom_ext {A B : CommMon_ C} (f g : A \u27f6 B) (h : f.hom = g.hom) : f = g :=\n  Mon_.Hom.ext _ _ h", "start": [66, 1], "end": [68, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CommMon_.id'", "code": "@[simp]\nlemma id' (A : CommMon_ C) : (\ud835\udfd9 A : A.toMon_ \u27f6 A.toMon_) = \ud835\udfd9 (A.toMon_) := rfl", "start": [71, 1], "end": [72, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CommMon_.comp'", "code": "@[simp]\nlemma comp' {A\u2081 A\u2082 A\u2083 : CommMon_ C} (f : A\u2081 \u27f6 A\u2082) (g : A\u2082 \u27f6 A\u2083) :\n    ((f \u226b g : A\u2081 \u27f6 A\u2083) : A\u2081.toMon_ \u27f6 A\u2083.toMon_) = @CategoryStruct.comp (Mon_ C) _ _ _ _ f g := rfl", "start": [74, 1], "end": [76, 99], "kind": "mathlibtacticlemma"}, {"full_name": "CommMon_.forget\u2082Mon_", "code": "def forget\u2082Mon_ : CommMon_ C \u2964 Mon_ C :=\n  inducedFunctor CommMon_.toMon_", "start": [82, 1], "end": [84, 33], "kind": "commanddeclaration"}, {"full_name": "CommMon_.forget\u2082_Mon_obj_one", "code": "@[simp]\ntheorem forget\u2082_Mon_obj_one (A : CommMon_ C) : ((forget\u2082Mon_ C).obj A).one = A.one", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CommMon_.forget\u2082_Mon_obj_mul", "code": "@[simp]\ntheorem forget\u2082_Mon_obj_mul (A : CommMon_ C) : ((forget\u2082Mon_ C).obj A).mul = A.mul", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "CommMon_.forget\u2082_Mon_map_hom", "code": "@[simp]\ntheorem forget\u2082_Mon_map_hom {A B : CommMon_ C} (f : A \u27f6 B) : ((forget\u2082Mon_ C).map f).hom = f.hom", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "CommMon_.uniqueHomFromTrivial", "code": "instance uniqueHomFromTrivial (A : CommMon_ C) : Unique (trivial C \u27f6 A) :=\n  Mon_.uniqueHomFromTrivial A.toMon_", "start": [112, 1], "end": [113, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxBraidedFunctor.mapCommMon", "code": "@[simps!]\ndef mapCommMon (F : LaxBraidedFunctor C D) : CommMon_ C \u2964 CommMon_ D where\n  obj A :=\n    { F.toLaxMonoidalFunctor.mapMon.obj A.toMon_ with\n      mul_comm := by\n        dsimp\n        have := F.braided\n        slice_lhs 1 2 => rw [\u2190 this]\n        slice_lhs 2 3 => rw [\u2190 CategoryTheory.Functor.map_comp, A.mul_comm] }\n  map f := F.toLaxMonoidalFunctor.mapMon.map f", "start": [128, 1], "end": [141, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LaxBraidedFunctor.mapCommMonFunctor", "code": "@[simps]\ndef mapCommMonFunctor : LaxBraidedFunctor C D \u2964 CommMon_ C \u2964 CommMon_ D where\n  obj := mapCommMon\n  map \u03b1 :=\n    { app := fun A => { hom := \u03b1.app A.X }\n      naturality := by intros; ext; simp }", "start": [148, 1], "end": [154, 43], "kind": "commanddeclaration"}, {"full_name": "CommMon_.EquivLaxBraidedFunctorPunit.laxBraidedToCommMon", "code": "@[simps]\ndef laxBraidedToCommMon : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C \u2964 CommMon_ C where\n  obj F := (F.mapCommMon : CommMon_ _ \u2964 CommMon_ C).obj (trivial (Discrete PUnit.{u+1}))\n  map \u03b1 := ((mapCommMonFunctor (Discrete PUnit.{u+1}) C).map \u03b1).app _", "start": [166, 1], "end": [170, 70], "kind": "commanddeclaration"}, {"full_name": "CommMon_.EquivLaxBraidedFunctorPunit.commMonToLaxBraided", "code": "@[simps]\ndef commMonToLaxBraided : CommMon_ C \u2964 LaxBraidedFunctor (Discrete PUnit.{u + 1}) C where\n  obj A :=\n    { obj := fun _ => A.X\n      map := fun _ => \ud835\udfd9 _\n      \u03b5 := A.one\n      \u03bc := fun _ _ => A.mul\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => (Category.id_comp (\ud835\udfd9 A.X)).symm }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ _ => by dsimp; rw [Category.id_comp, Category.comp_id]\n      unit := Mon_.Hom.one_hom f\n      tensor := fun _ _ => Mon_.Hom.mul_hom f }", "start": [174, 1], "end": [188, 48], "kind": "commanddeclaration"}, {"full_name": "CommMon_.EquivLaxBraidedFunctorPunit.unitIso", "code": "@[simps!]\ndef unitIso :\n    \ud835\udfed (LaxBraidedFunctor (Discrete PUnit.{u + 1}) C) \u2245\n      laxBraidedToCommMon C \u22d9 commMonToLaxBraided C :=\n  NatIso.ofComponents\n    (fun F =>\n      LaxBraidedFunctor.mkIso\n        (MonoidalNatIso.ofComponents\n          (fun _ => F.toLaxMonoidalFunctor.toFunctor.mapIso (eqToIso (by ext)))\n          (by rintro \u27e8\u27e9 \u27e8\u27e9 f; aesop_cat) (by aesop_cat) (by aesop_cat)))", "start": [192, 1], "end": [202, 73], "kind": "commanddeclaration"}, {"full_name": "CommMon_.EquivLaxBraidedFunctorPunit.counitIso", "code": "@[simps!]\ndef counitIso : commMonToLaxBraided C \u22d9 laxBraidedToCommMon C \u2245 \ud835\udfed (CommMon_ C) :=\n  NatIso.ofComponents\n    (fun F =>\n      { hom := { hom := \ud835\udfd9 _ }\n        inv := { hom := \ud835\udfd9 _ } })", "start": [206, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "CommMon_.equivLaxBraidedFunctorPunit", "code": "@[simps]\ndef equivLaxBraidedFunctorPunit : LaxBraidedFunctor (Discrete PUnit.{u + 1}) C \u224c CommMon_ C where\n  functor := laxBraidedToCommMon C\n  inverse := commMonToLaxBraided C\n  unitIso := unitIso C\n  counitIso := counitIso C", "start": [220, 1], "end": [228, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Extreme.lean", "imports": ["Mathlib/Analysis/Convex/Hull.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsExtreme", "code": "def IsExtreme (A B : Set E) : Prop :=\n  B \u2286 A \u2227 \u2200 \u2983x\u2081\u2984, x\u2081 \u2208 A \u2192 \u2200 \u2983x\u2082\u2984, x\u2082 \u2208 A \u2192 \u2200 \u2983x\u2984, x \u2208 B \u2192 x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 \u2208 B \u2227 x\u2082 \u2208 B", "start": [56, 1], "end": [59, 101], "kind": "commanddeclaration"}, {"full_name": "Set.extremePoints", "code": "def Set.extremePoints (A : Set E) : Set E :=\n  { x \u2208 A | \u2200 \u2983x\u2081\u2984, x\u2081 \u2208 A \u2192 \u2200 \u2983x\u2082\u2984, x\u2082 \u2208 A \u2192 x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x \u2227 x\u2082 = x }", "start": [62, 1], "end": [65, 90], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.refl", "code": "@[refl]\nprotected theorem IsExtreme.refl (A : Set E) : IsExtreme \ud835\udd5c A A", "start": [68, 1], "end": [70, 55], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.rfl", "code": "protected theorem IsExtreme.rfl : IsExtreme \ud835\udd5c A A", "start": [75, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.trans", "code": "@[trans]\nprotected theorem IsExtreme.trans (hAB : IsExtreme \ud835\udd5c A B) (hBC : IsExtreme \ud835\udd5c B C) :\n    IsExtreme \ud835\udd5c A C", "start": [79, 1], "end": [84, 31], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.antisymm", "code": "protected theorem IsExtreme.antisymm : AntiSymmetric (IsExtreme \ud835\udd5c : Set E \u2192 Set E \u2192 Prop)", "start": [87, 1], "end": [88, 48], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.inter", "code": "theorem IsExtreme.inter (hAB : IsExtreme \ud835\udd5c A B) (hAC : IsExtreme \ud835\udd5c A C) :\n    IsExtreme \ud835\udd5c A (B \u2229 C)", "start": [96, 1], "end": [102, 35], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.mono", "code": "protected theorem IsExtreme.mono (hAC : IsExtreme \ud835\udd5c A C) (hBA : B \u2286 A) (hCB : C \u2286 B) :\n    IsExtreme \ud835\udd5c B C", "start": [105, 1], "end": [107, 73], "kind": "commanddeclaration"}, {"full_name": "isExtreme_iInter", "code": "theorem isExtreme_iInter {\u03b9 : Sort*} [Nonempty \u03b9] {F : \u03b9 \u2192 Set E}\n    (hAF : \u2200 i : \u03b9, IsExtreme \ud835\udd5c A (F i)) : IsExtreme \ud835\udd5c A (\u22c2 i : \u03b9, F i)", "start": [110, 1], "end": [116, 43], "kind": "commanddeclaration"}, {"full_name": "isExtreme_biInter", "code": "theorem isExtreme_biInter {F : Set (Set E)} (hF : F.Nonempty) (hA : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B) :\n    IsExtreme \ud835\udd5c A (\u22c2 B \u2208 F, B)", "start": [119, 1], "end": [122, 74], "kind": "commanddeclaration"}, {"full_name": "isExtreme_sInter", "code": "theorem isExtreme_sInter {F : Set (Set E)} (hF : F.Nonempty) (hAF : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B) :\n    IsExtreme \ud835\udd5c A (\u22c2\u2080 F)", "start": [125, 1], "end": [131, 55], "kind": "commanddeclaration"}, {"full_name": "mem_extremePoints", "code": "theorem mem_extremePoints : x \u2208 A.extremePoints \ud835\udd5c \u2194\n    x \u2208 A \u2227 \u2200 (x\u2081) (_ : x\u2081 \u2208 A) (x\u2082) (_ : x\u2082 \u2208 A), x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x \u2227 x\u2082 = x", "start": [134, 1], "end": [136, 10], "kind": "commanddeclaration"}, {"full_name": "mem_extremePoints_iff_extreme_singleton", "code": "theorem mem_extremePoints_iff_extreme_singleton : x \u2208 A.extremePoints \ud835\udd5c \u2194 IsExtreme \ud835\udd5c A {x}", "start": [139, 1], "end": [145, 22], "kind": "commanddeclaration"}, {"full_name": "extremePoints_subset", "code": "theorem extremePoints_subset : A.extremePoints \ud835\udd5c \u2286 A", "start": [148, 1], "end": [149, 18], "kind": "commanddeclaration"}, {"full_name": "extremePoints_empty", "code": "@[simp]\ntheorem extremePoints_empty : (\u2205 : Set E).extremePoints \ud835\udd5c = \u2205", "start": [152, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "extremePoints_singleton", "code": "@[simp]\ntheorem extremePoints_singleton : ({x} : Set E).extremePoints \ud835\udd5c = {x}", "start": [157, 1], "end": [160, 77], "kind": "commanddeclaration"}, {"full_name": "inter_extremePoints_subset_extremePoints_of_subset", "code": "theorem inter_extremePoints_subset_extremePoints_of_subset (hBA : B \u2286 A) :\n    B \u2229 A.extremePoints \ud835\udd5c \u2286 B.extremePoints \ud835\udd5c", "start": [163, 1], "end": [165, 78], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.extremePoints_subset_extremePoints", "code": "theorem IsExtreme.extremePoints_subset_extremePoints (hAB : IsExtreme \ud835\udd5c A B) :\n    B.extremePoints \ud835\udd5c \u2286 A.extremePoints \ud835\udd5c", "start": [168, 1], "end": [171, 63], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.extremePoints_eq", "code": "theorem IsExtreme.extremePoints_eq (hAB : IsExtreme \ud835\udd5c A B) :\n    B.extremePoints \ud835\udd5c = B \u2229 A.extremePoints \ud835\udd5c", "start": [174, 1], "end": [177, 63], "kind": "commanddeclaration"}, {"full_name": "IsExtreme.convex_diff", "code": "theorem IsExtreme.convex_diff (hA : Convex \ud835\udd5c A) (hAB : IsExtreme \ud835\udd5c A B) : Convex \ud835\udd5c (A \\ B)", "start": [187, 1], "end": [189, 84], "kind": "commanddeclaration"}, {"full_name": "extremePoints_prod", "code": "@[simp]\ntheorem extremePoints_prod (s : Set E) (t : Set F) :\n    (s \u00d7\u02e2 t).extremePoints \ud835\udd5c = s.extremePoints \ud835\udd5c \u00d7\u02e2 t.extremePoints \ud835\udd5c", "start": [192, 1], "end": [212, 71], "kind": "commanddeclaration"}, {"full_name": "extremePoints_pi", "code": "@[simp]\ntheorem extremePoints_pi (s : \u2200 i, Set (\u03c0 i)) :\n    (univ.pi s).extremePoints \ud835\udd5c = univ.pi fun i \u21a6 (s i).extremePoints \ud835\udd5c", "start": [215, 1], "end": [234, 79], "kind": "commanddeclaration"}, {"full_name": "mem_extremePoints_iff_forall_segment", "code": "theorem mem_extremePoints_iff_forall_segment : x \u2208 A.extremePoints \ud835\udd5c \u2194\n    x \u2208 A \u2227 \u2200 (x\u2081) (_ : x\u2081 \u2208 A) (x\u2082) (_ : x\u2082 \u2208 A), x \u2208 segment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x \u2228 x\u2082 = x", "start": [245, 1], "end": [256, 96], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_extremePoints_iff_convex_diff", "code": "theorem Convex.mem_extremePoints_iff_convex_diff (hA : Convex \ud835\udd5c A) :\n    x \u2208 A.extremePoints \ud835\udd5c \u2194 x \u2208 A \u2227 Convex \ud835\udd5c (A \\ {x})", "start": [259, 1], "end": [267, 63], "kind": "commanddeclaration"}, {"full_name": "Convex.mem_extremePoints_iff_mem_diff_convexHull_diff", "code": "theorem Convex.mem_extremePoints_iff_mem_diff_convexHull_diff (hA : Convex \ud835\udd5c A) :\n    x \u2208 A.extremePoints \ud835\udd5c \u2194 x \u2208 A \\ convexHull \ud835\udd5c (A \\ {x})", "start": [270, 1], "end": [273, 14], "kind": "commanddeclaration"}, {"full_name": "extremePoints_convexHull_subset", "code": "theorem extremePoints_convexHull_subset : (convexHull \ud835\udd5c A).extremePoints \ud835\udd5c \u2286 A", "start": [276, 1], "end": [281, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Gauge.lean", "imports": ["Mathlib/Analysis/LocallyConvex/Bounded.lean", "Mathlib/Data/IsROrC/Basic.lean", "Mathlib/Analysis/NormedSpace/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Seminorm.lean", "Mathlib/Analysis/Convex/Topology.lean"], "premises": [{"full_name": "gauge", "code": "def gauge (s : Set E) (x : E) : \u211d :=\n  sInf { r : \u211d | 0 < r \u2227 x \u2208 r \u2022 s }", "start": [55, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "gauge_def", "code": "theorem gauge_def : gauge s x = sInf ({ r \u2208 Set.Ioi (0 : \u211d) | x \u2208 r \u2022 s })", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "gauge_def'", "code": "theorem gauge_def' : gauge s x = sInf {r \u2208 Set.Ioi (0 : \u211d) | r\u207b\u00b9 \u2022 x \u2208 s}", "start": [67, 1], "end": [71, 76], "kind": "commanddeclaration"}, {"full_name": "gauge_set_bddBelow", "code": "private theorem gauge_set_bddBelow : BddBelow { r : \u211d | 0 < r \u2227 x \u2208 r \u2022 s }", "start": [74, 1], "end": [75, 27], "kind": "commanddeclaration"}, {"full_name": "Absorbent.gauge_set_nonempty", "code": "theorem Absorbent.gauge_set_nonempty (absorbs : Absorbent \u211d s) :\n    { r : \u211d | 0 < r \u2227 x \u2208 r \u2022 s }.Nonempty", "start": [77, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "gauge_mono", "code": "theorem gauge_mono (hs : Absorbent \u211d s) (h : s \u2286 t) : gauge t \u2264 gauge s", "start": [85, 1], "end": [86, 99], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_gauge_lt", "code": "theorem exists_lt_of_gauge_lt (absorbs : Absorbent \u211d s) (h : gauge s x < a) :\n    \u2203 b, 0 < b \u2227 b < a \u2227 x \u2208 b \u2022 s", "start": [89, 1], "end": [92, 25], "kind": "commanddeclaration"}, {"full_name": "gauge_zero", "code": "@[simp]\ntheorem gauge_zero : gauge s 0 = 0", "start": [95, 1], "end": [102, 57], "kind": "commanddeclaration"}, {"full_name": "gauge_zero'", "code": "@[simp]\ntheorem gauge_zero' : gauge (0 : Set E) = 0", "start": [105, 1], "end": [113, 81], "kind": "commanddeclaration"}, {"full_name": "gauge_empty", "code": "@[simp]\ntheorem gauge_empty : gauge (\u2205 : Set E) = 0", "start": [116, 1], "end": [119, 89], "kind": "commanddeclaration"}, {"full_name": "gauge_of_subset_zero", "code": "theorem gauge_of_subset_zero (h : s \u2286 0) : gauge s = 0", "start": [122, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "gauge_nonneg", "code": "theorem gauge_nonneg (x : E) : 0 \u2264 gauge s x", "start": [127, 1], "end": [129, 41], "kind": "commanddeclaration"}, {"full_name": "gauge_neg", "code": "theorem gauge_neg (symmetric : \u2200 x \u2208 s, -x \u2208 s) (x : E) : gauge s (-x) = gauge s x", "start": [132, 1], "end": [134, 39], "kind": "commanddeclaration"}, {"full_name": "gauge_neg_set_neg", "code": "theorem gauge_neg_set_neg (x : E) : gauge (-s) (-x) = gauge s x", "start": [137, 1], "end": [138, 46], "kind": "commanddeclaration"}, {"full_name": "gauge_neg_set_eq_gauge_neg", "code": "theorem gauge_neg_set_eq_gauge_neg (x : E) : gauge (-s) x = gauge s (-x)", "start": [141, 1], "end": [142, 36], "kind": "commanddeclaration"}, {"full_name": "gauge_le_of_mem", "code": "theorem gauge_le_of_mem (ha : 0 \u2264 a) (hx : x \u2208 a \u2022 s) : gauge s x \u2264 a", "start": [145, 1], "end": [148, 48], "kind": "commanddeclaration"}, {"full_name": "gauge_le_eq", "code": "theorem gauge_le_eq (hs\u2081 : Convex \u211d s) (hs\u2080 : (0 : E) \u2208 s) (hs\u2082 : Absorbent \u211d s) (ha : 0 \u2264 a) :\n    { x | gauge s x \u2264 a } = \u22c2 (r : \u211d) (_ : a < r), r \u2022 s", "start": [151, 1], "end": [166, 100], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_eq'", "code": "theorem gauge_lt_eq' (absorbs : Absorbent \u211d s) (a : \u211d) :\n    { x | gauge s x < a } = \u22c3 (r : \u211d) (_ : 0 < r) (_ : r < a), r \u2022 s", "start": [169, 1], "end": [175, 48], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_eq", "code": "theorem gauge_lt_eq (absorbs : Absorbent \u211d s) (a : \u211d) :\n    { x | gauge s x < a } = \u22c3 r \u2208 Set.Ioo 0 (a : \u211d), r \u2022 s", "start": [178, 1], "end": [184, 48], "kind": "commanddeclaration"}, {"full_name": "mem_openSegment_of_gauge_lt_one", "code": "theorem mem_openSegment_of_gauge_lt_one (absorbs : Absorbent \u211d s) (hgauge : gauge s x < 1) :\n    \u2203 y \u2208 s, x \u2208 openSegment \u211d 0 y", "start": [187, 1], "end": [191, 11], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_one_subset_self", "code": "theorem gauge_lt_one_subset_self (hs : Convex \u211d s) (h\u2080 : (0 : E) \u2208 s) (absorbs : Absorbent \u211d s) :\n    { x | gauge s x < 1 } \u2286 s", "start": [193, 1], "end": [196, 34], "kind": "commanddeclaration"}, {"full_name": "gauge_le_one_of_mem", "code": "theorem gauge_le_one_of_mem {x : E} (hx : x \u2208 s) : gauge s x \u2264 1", "start": [199, 1], "end": [200, 51], "kind": "commanddeclaration"}, {"full_name": "gauge_add_le", "code": "theorem gauge_add_le (hs : Convex \u211d s) (absorbs : Absorbent \u211d s) (x y : E) :\n    gauge s (x + y) \u2264 gauge s x + gauge s y", "start": [203, 1], "end": [215, 61], "kind": "commanddeclaration"}, {"full_name": "self_subset_gauge_le_one", "code": "theorem self_subset_gauge_le_one : s \u2286 { x | gauge s x \u2264 1 }", "start": [218, 1], "end": [218, 93], "kind": "commanddeclaration"}, {"full_name": "Convex.gauge_le", "code": "theorem Convex.gauge_le (hs : Convex \u211d s) (h\u2080 : (0 : E) \u2208 s) (absorbs : Absorbent \u211d s) (a : \u211d) :\n    Convex \u211d { x | gauge s x \u2264 a }", "start": [221, 1], "end": [228, 84], "kind": "commanddeclaration"}, {"full_name": "Balanced.starConvex", "code": "theorem Balanced.starConvex (hs : Balanced \u211d s) : StarConvex \u211d 0 s", "start": [231, 1], "end": [233, 67], "kind": "commanddeclaration"}, {"full_name": "le_gauge_of_not_mem", "code": "theorem le_gauge_of_not_mem (hs\u2080 : StarConvex \u211d 0 s) (hs\u2082 : Absorbs \u211d s {x}) (hx : x \u2209 a \u2022 s) :\n    a \u2264 gauge s x", "start": [236, 1], "end": [248, 49], "kind": "commanddeclaration"}, {"full_name": "one_le_gauge_of_not_mem", "code": "theorem one_le_gauge_of_not_mem (hs\u2081 : StarConvex \u211d 0 s) (hs\u2082 : Absorbs \u211d s {x}) (hx : x \u2209 s) :\n    1 \u2264 gauge s x", "start": [251, 1], "end": [253, 51], "kind": "commanddeclaration"}, {"full_name": "gauge_smul_of_nonneg", "code": "theorem gauge_smul_of_nonneg [MulActionWithZero \u03b1 E] [IsScalarTower \u03b1 \u211d (Set E)] {s : Set E} {a : \u03b1}\n    (ha : 0 \u2264 a) (x : E) : gauge s (a \u2022 x) = a \u2022 gauge s x", "start": [260, 1], "end": [282, 31], "kind": "commanddeclaration"}, {"full_name": "gauge_smul_left_of_nonneg", "code": "theorem gauge_smul_left_of_nonneg [MulActionWithZero \u03b1 E] [SMulCommClass \u03b1 \u211d \u211d]\n    [IsScalarTower \u03b1 \u211d \u211d] [IsScalarTower \u03b1 \u211d E] {s : Set E} {a : \u03b1} (ha : 0 \u2264 a) :\n    gauge (a \u2022 s) = a\u207b\u00b9 \u2022 gauge s", "start": [285, 1], "end": [303, 40], "kind": "commanddeclaration"}, {"full_name": "gauge_smul_left", "code": "theorem gauge_smul_left [Module \u03b1 E] [SMulCommClass \u03b1 \u211d \u211d] [IsScalarTower \u03b1 \u211d \u211d]\n    [IsScalarTower \u03b1 \u211d E] {s : Set E} (symmetric : \u2200 x \u2208 s, -x \u2208 s) (a : \u03b1) :\n    gauge (a \u2022 s) = |a|\u207b\u00b9 \u2022 gauge s", "start": [306, 1], "end": [319, 25], "kind": "commanddeclaration"}, {"full_name": "gauge_norm_smul", "code": "theorem gauge_norm_smul (hs : Balanced \ud835\udd5c s) (r : \ud835\udd5c) (x : E) :\n    gauge s (\u2016r\u2016 \u2022 x) = gauge s (r \u2022 x)", "start": [328, 1], "end": [334, 36], "kind": "commanddeclaration"}, {"full_name": "gauge_smul", "code": "theorem gauge_smul (hs : Balanced \ud835\udd5c s) (r : \ud835\udd5c) (x : E) : gauge s (r \u2022 x) = \u2016r\u2016 * gauge s x", "start": [337, 1], "end": [339, 81], "kind": "commanddeclaration"}, {"full_name": "interior_subset_gauge_lt_one", "code": "theorem interior_subset_gauge_lt_one (s : Set E) : interior s \u2286 { x | gauge s x < 1 }", "start": [349, 1], "end": [359, 50], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_one_eq_self_of_open", "code": "theorem gauge_lt_one_eq_self_of_open (hs\u2081 : Convex \u211d s) (hs\u2080 : (0 : E) \u2208 s) (hs\u2082 : IsOpen s) :\n    { x | gauge s x < 1 } = s", "start": [362, 1], "end": [366, 29], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_one_of_mem_of_open", "code": "theorem gauge_lt_one_of_mem_of_open (hs\u2082 : IsOpen s) {x : E} (hx : x \u2208 s) :\n    gauge s x < 1", "start": [370, 1], "end": [372, 61], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_of_mem_smul", "code": "theorem gauge_lt_of_mem_smul (x : E) (\u03b5 : \u211d) (h\u03b5 : 0 < \u03b5) (hs\u2082 : IsOpen s) (hx : x \u2208 \u03b5 \u2022 s) :\n    gauge s x < \u03b5", "start": [376, 1], "end": [381, 18], "kind": "commanddeclaration"}, {"full_name": "mem_closure_of_gauge_le_one", "code": "theorem mem_closure_of_gauge_le_one (hc : Convex \u211d s) (hs\u2080 : 0 \u2208 s) (ha : Absorbent \u211d s)\n    (h : gauge s x \u2264 1) : x \u2208 closure s", "start": [384, 1], "end": [393, 16], "kind": "commanddeclaration"}, {"full_name": "mem_frontier_of_gauge_eq_one", "code": "theorem mem_frontier_of_gauge_eq_one (hc : Convex \u211d s) (hs\u2080 : 0 \u2208 s) (ha : Absorbent \u211d s)\n    (h : gauge s x = 1) : x \u2208 frontier s", "start": [395, 1], "end": [398, 50], "kind": "commanddeclaration"}, {"full_name": "continuous_gauge", "code": "theorem continuous_gauge (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) : Continuous (gauge s)", "start": [408, 1], "end": [428, 75], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_one_eq_interior", "code": "theorem gauge_lt_one_eq_interior (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) :\n    { x | gauge s x < 1 } = interior s", "start": [430, 1], "end": [434, 95], "kind": "commanddeclaration"}, {"full_name": "gauge_lt_one_iff_mem_interior", "code": "theorem gauge_lt_one_iff_mem_interior (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) :\n    gauge s x < 1 \u2194 x \u2208 interior s", "start": [436, 1], "end": [438, 52], "kind": "commanddeclaration"}, {"full_name": "gauge_le_one_iff_mem_closure", "code": "theorem gauge_le_one_iff_mem_closure (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) :\n    gauge s x \u2264 1 \u2194 x \u2208 closure s", "start": [440, 1], "end": [444, 28], "kind": "commanddeclaration"}, {"full_name": "gauge_eq_one_iff_mem_frontier", "code": "theorem gauge_eq_one_iff_mem_frontier (hc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) :\n    gauge s x = 1 \u2194 x \u2208 frontier s", "start": [446, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "gauge_eq_zero", "code": "theorem gauge_eq_zero [T1Space E] (hs : Absorbent \u211d s) (hb : Bornology.IsVonNBounded \u211d s) :\n    gauge s x = 0 \u2194 x = 0", "start": [451, 1], "end": [462, 25], "kind": "commanddeclaration"}, {"full_name": "gauge_pos", "code": "theorem gauge_pos [T1Space E] (hs : Absorbent \u211d s) (hb : Bornology.IsVonNBounded \u211d s) :\n    0 < gauge s x \u2194 x \u2260 0", "start": [464, 1], "end": [466, 70], "kind": "commanddeclaration"}, {"full_name": "gaugeSeminorm", "code": "@[simps!]\ndef gaugeSeminorm (hs\u2080 : Balanced \ud835\udd5c s) (hs\u2081 : Convex \u211d s) (hs\u2082 : Absorbent \u211d s) : Seminorm \ud835\udd5c E :=\n  Seminorm.of (gauge s) (gauge_add_le hs\u2081 hs\u2082) (gauge_smul hs\u2080)", "start": [474, 1], "end": [477, 64], "kind": "commanddeclaration"}, {"full_name": "gaugeSeminorm_lt_one_of_open", "code": "theorem gaugeSeminorm_lt_one_of_open (hs : IsOpen s) {x : E} (hx : x \u2208 s) :\n    gaugeSeminorm hs\u2080 hs\u2081 hs\u2082 x < 1", "start": [483, 1], "end": [485, 36], "kind": "commanddeclaration"}, {"full_name": "gaugeSeminorm_ball_one", "code": "theorem gaugeSeminorm_ball_one (hs : IsOpen s) : (gaugeSeminorm hs\u2080 hs\u2081 hs\u2082).ball 0 1 = s", "start": [488, 1], "end": [490, 57], "kind": "commanddeclaration"}, {"full_name": "Seminorm.gauge_ball", "code": "@[simp]\nprotected theorem Seminorm.gauge_ball (p : Seminorm \u211d E) : gauge (p.ball 0 1) = p", "start": [495, 1], "end": [519, 35], "kind": "commanddeclaration"}, {"full_name": "Seminorm.gaugeSeminorm_ball", "code": "theorem Seminorm.gaugeSeminorm_ball (p : Seminorm \u211d E) :\n    gaugeSeminorm (p.balanced_ball_zero 1) (p.convex_ball 0 1) (p.absorbent_ball_zero zero_lt_one) =\n      p", "start": [522, 1], "end": [525, 37], "kind": "commanddeclaration"}, {"full_name": "gauge_unit_ball", "code": "theorem gauge_unit_ball (x : E) : gauge (ball (0 : E) 1) x = \u2016x\u2016", "start": [535, 1], "end": [536, 68], "kind": "commanddeclaration"}, {"full_name": "gauge_ball", "code": "theorem gauge_ball (hr : 0 \u2264 r) (x : E) : gauge (ball (0 : E) r) x = \u2016x\u2016 / r", "start": [539, 1], "end": [545, 22], "kind": "commanddeclaration"}, {"full_name": "gauge_ball'", "code": "@[deprecated gauge_ball]\ntheorem gauge_ball' (hr : 0 < r) (x : E) : gauge (ball (0 : E) r) x = \u2016x\u2016 / r", "start": [547, 1], "end": [549, 21], "kind": "commanddeclaration"}, {"full_name": "gauge_closure_zero", "code": "@[simp]\ntheorem gauge_closure_zero : gauge (closure (0 : Set E)) = 0", "start": [552, 1], "end": [560, 93], "kind": "commanddeclaration"}, {"full_name": "gauge_closedBall", "code": "@[simp]\ntheorem gauge_closedBall (hr : 0 \u2264 r) (x : E) : gauge (closedBall (0 : E) r) x = \u2016x\u2016 / r", "start": [562, 1], "end": [575, 68], "kind": "commanddeclaration"}, {"full_name": "mul_gauge_le_norm", "code": "theorem mul_gauge_le_norm (hs : Metric.ball (0 : E) r \u2286 s) : r * gauge s x \u2264 \u2016x\u2016", "start": [577, 1], "end": [581, 49], "kind": "commanddeclaration"}, {"full_name": "Convex.lipschitzWith_gauge", "code": "theorem Convex.lipschitzWith_gauge {r : \u211d\u22650} (hc : Convex \u211d s) (hr : 0 < r)\n    (hs : Metric.ball (0 : E) r \u2286 s) : LipschitzWith r\u207b\u00b9 (gauge s)", "start": [584, 1], "end": [593, 93], "kind": "commanddeclaration"}, {"full_name": "Convex.lipschitz_gauge", "code": "theorem Convex.lipschitz_gauge (hc : Convex \u211d s) (h\u2080 : s \u2208 \ud835\udcdd (0 : E)) :\n    \u2203 K, LipschitzWith K (gauge s)", "start": [596, 1], "end": [599, 57], "kind": "commanddeclaration"}, {"full_name": "Convex.uniformContinuous_gauge", "code": "theorem Convex.uniformContinuous_gauge (hc : Convex \u211d s) (h\u2080 : s \u2208 \ud835\udcdd (0 : E)) :\n    UniformContinuous (gauge s)", "start": [601, 1], "end": [603, 62], "kind": "commanddeclaration"}, {"full_name": "le_gauge_of_subset_closedBall", "code": "theorem le_gauge_of_subset_closedBall (hs : Absorbent \u211d s) (hr : 0 \u2264 r) (hsr : s \u2286 closedBall 0 r) :\n    \u2016x\u2016 / r \u2264 gauge s x", "start": [613, 1], "end": [616, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Derangements/Basic.lean", "imports": ["Mathlib/Logic/Equiv/Option.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/GroupTheory/Perm/Option.lean"], "premises": [{"full_name": "derangements", "code": "def derangements (\u03b1 : Type*) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | \u2200 x : \u03b1, f x \u2260 x }", "start": [32, 1], "end": [34, 36], "kind": "commanddeclaration"}, {"full_name": "mem_derangements_iff_fixedPoints_eq_empty", "code": "theorem mem_derangements_iff_fixedPoints_eq_empty {f : Perm \u03b1} :\n    f \u2208 derangements \u03b1 \u2194 fixedPoints f = \u2205", "start": [39, 1], "end": [41, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.derangementsCongr", "code": "def Equiv.derangementsCongr (e : \u03b1 \u2243 \u03b2) : derangements \u03b1 \u2243 derangements \u03b2 :=\n  e.permCongr.subtypeEquiv fun {f} => e.forall_congr <| by\n   intro b; simp only [ne_eq, permCongr_apply, symm_apply_apply, EmbeddingLike.apply_eq_iff_eq]", "start": [44, 1], "end": [47, 96], "kind": "commanddeclaration"}, {"full_name": "derangements.subtypeEquiv", "code": "protected def subtypeEquiv (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    derangements (Subtype p) \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n  calc\n    derangements (Subtype p) \u2243 { f : { f : Perm \u03b1 // \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f } //\n        \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } := by\n      refine' (Perm.subtypeEquivSubtypePerm p).subtypeEquiv fun f => \u27e8fun hf a hfa ha => _, _\u27e9\n      \u00b7 refine' hf \u27e8a, ha\u27e9 (Subtype.ext _)\n        simp_rw [mem_fixedPoints, IsFixedPt, Perm.subtypeEquivSubtypePerm,\n        Equiv.coe_fn_mk, Perm.ofSubtype_apply_of_mem _ ha] at hfa\n        assumption\n      rintro hf \u27e8a, ha\u27e9 hfa\n      refine' hf _ _ ha\n      simp only [Perm.subtypeEquivSubtypePerm_apply_coe, mem_fixedPoints]\n      dsimp [IsFixedPt]\n      simp_rw [Perm.ofSubtype_apply_of_mem _ ha, hfa]\n    _ \u2243 { f : Perm \u03b1 // \u2203 _h : \u2200 a, \u00acp a \u2192 a \u2208 fixedPoints f, \u2200 a, a \u2208 fixedPoints f \u2192 \u00acp a } :=\n      subtypeSubtypeEquivSubtypeExists _ _\n    _ \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2194 a \u2208 fixedPoints f } :=\n      subtypeEquivRight fun f => by\n        simp_rw [exists_prop, \u2190 forall_and, \u2190 iff_iff_implies_and_implies]", "start": [52, 1], "end": [73, 75], "kind": "commanddeclaration"}, {"full_name": "derangements.atMostOneFixedPointEquivSum_derangements", "code": "def atMostOneFixedPointEquivSum_derangements [DecidableEq \u03b1] (a : \u03b1) :\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) :=\n  calc\n    { f : Perm \u03b1 // fixedPoints f \u2286 {a} } \u2243\n        Sum { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2208 fixedPoints f }\n          { f : { f : Perm \u03b1 // fixedPoints f \u2286 {a} } // a \u2209 fixedPoints f } :=\n      (Equiv.sumCompl _).symm\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2208 fixedPoints f }\n          { f : Perm \u03b1 // fixedPoints f \u2286 {a} \u2227 a \u2209 fixedPoints f } := by\n      refine' Equiv.sumCongr _ _\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (a \u2208 fixedPoints \u00b7)\n      \u00b7 exact subtypeSubtypeEquivSubtypeInter\n          (fun x : Perm \u03b1 => fixedPoints x \u2286 {a})\n          (\u00aca \u2208 fixedPoints \u00b7)\n    _ \u2243 Sum { f : Perm \u03b1 // fixedPoints f = {a} } { f : Perm \u03b1 // fixedPoints f = \u2205 } := by\n      refine' Equiv.sumCongr (subtypeEquivRight fun f => _) (subtypeEquivRight fun f => _)\n      \u00b7 rw [Set.eq_singleton_iff_unique_mem, and_comm]\n        rfl\n      \u00b7 rw [Set.eq_empty_iff_forall_not_mem]\n        refine' \u27e8fun h x hx => h.2 (h.1 hx \u25b8 hx), fun h => \u27e8fun x hx => (h _ hx).elim, h _\u27e9\u27e9\n    _ \u2243 Sum (derangements ({a}\u1d9c : Set \u03b1)) (derangements \u03b1) := by\n      refine'\n        Equiv.sumCongr ((derangements.subtypeEquiv (\u00b7 \u2208 ({a}\u1d9c : Set \u03b1))).trans <|\n            subtypeEquivRight fun x => _).symm\n          (subtypeEquivRight fun f => mem_derangements_iff_fixedPoints_eq_empty.symm)\n      rw [eq_comm, Set.ext_iff]\n      simp_rw [Set.mem_compl_iff, Classical.not_not]", "start": [77, 1], "end": [110, 53], "kind": "commanddeclaration"}, {"full_name": "derangements.Equiv.RemoveNone.fiber", "code": "def RemoveNone.fiber (a : Option \u03b1) : Set (Perm \u03b1) :=\n  { f : Perm \u03b1 | (a, f) \u2208 Equiv.Perm.decomposeOption '' derangements (Option \u03b1) }", "start": [117, 1], "end": [120, 82], "kind": "commanddeclaration"}, {"full_name": "derangements.Equiv.RemoveNone.mem_fiber", "code": "theorem RemoveNone.mem_fiber (a : Option \u03b1) (f : Perm \u03b1) :\n    f \u2208 RemoveNone.fiber a \u2194\n      \u2203 F : Perm (Option \u03b1), F \u2208 derangements (Option \u03b1) \u2227 F none = a \u2227 removeNone F = f", "start": [123, 1], "end": [126, 43], "kind": "commanddeclaration"}, {"full_name": "derangements.Equiv.RemoveNone.fiber_none", "code": "theorem RemoveNone.fiber_none : RemoveNone.fiber (@none \u03b1) = \u2205", "start": [129, 1], "end": [134, 34], "kind": "commanddeclaration"}, {"full_name": "derangements.Equiv.RemoveNone.fiber_some", "code": "theorem RemoveNone.fiber_some (a : \u03b1) :\n    RemoveNone.fiber (some a) = { f : Perm \u03b1 | fixedPoints f \u2286 {a} }", "start": [137, 1], "end": [169, 28], "kind": "commanddeclaration"}, {"full_name": "derangements.derangementsOptionEquivSigmaAtMostOneFixedPoint", "code": "def derangementsOptionEquivSigmaAtMostOneFixedPoint :\n    derangements (Option \u03b1) \u2243 \u03a3a : \u03b1, { f : Perm \u03b1 | fixedPoints f \u2286 {a} } := by\n  have fiber_none_is_false : Equiv.RemoveNone.fiber (@none \u03b1) \u2192 False := by\n    rw [Equiv.RemoveNone.fiber_none]\n    exact IsEmpty.false\n  calc\n    derangements (Option \u03b1) \u2243 Equiv.Perm.decomposeOption '' derangements (Option \u03b1) :=\n      Equiv.image _ _\n    _ \u2243 \u03a3a : Option \u03b1, \u21a5(Equiv.RemoveNone.fiber a) := setProdEquivSigma _\n    _ \u2243 \u03a3a : \u03b1, \u21a5(Equiv.RemoveNone.fiber (some a)) :=\n      sigmaOptionEquivOfSome _ fiber_none_is_false\n    _ \u2243 \u03a3a : \u03b1, { f : Perm \u03b1 | fixedPoints f \u2286 {a} } := by\n      simp_rw [Equiv.RemoveNone.fiber_some]\n      rfl", "start": [178, 1], "end": [193, 10], "kind": "commanddeclaration"}, {"full_name": "derangements.derangementsRecursionEquiv", "code": "def derangementsRecursionEquiv :\n    derangements (Option \u03b1) \u2243\n      \u03a3a : \u03b1, Sum (derangements (({a}\u1d9c : Set \u03b1) : Type _)) (derangements \u03b1) :=\n  derangementsOptionEquivSigmaAtMostOneFixedPoint.trans\n    (sigmaCongrRight atMostOneFixedPointEquivSum_derangements)", "start": [196, 1], "end": [202, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Irrational.lean", "imports": ["Mathlib/Data/Real/Irrational.lean", "Mathlib/Topology/MetricSpace/Baire.lean", "Mathlib/Data/Rat/Encodable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isG\u03b4_irrational", "code": "theorem isG\u03b4_irrational : IsG\u03b4 { x | Irrational x }", "start": [38, 1], "end": [39, 33], "kind": "commanddeclaration"}, {"full_name": "dense_irrational", "code": "theorem dense_irrational : Dense { x : \u211d | Irrational x }", "start": [43, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "eventually_residual_irrational", "code": "theorem eventually_residual_irrational : \u2200\u1da0 x in residual \u211d, Irrational x", "start": [52, 1], "end": [53, 76], "kind": "commanddeclaration"}, {"full_name": "Irrational.eventually_forall_le_dist_cast_div", "code": "theorem eventually_forall_le_dist_cast_div (hx : Irrational x) (n : \u2115) :\n    \u2200\u1da0 \u03b5 : \u211d in \ud835\udcdd 0, \u2200 m : \u2124, \u03b5 \u2264 dist x (m / n)", "start": [76, 1], "end": [87, 24], "kind": "commanddeclaration"}, {"full_name": "Irrational.eventually_forall_le_dist_cast_div_of_denom_le", "code": "theorem eventually_forall_le_dist_cast_div_of_denom_le (hx : Irrational x) (n : \u2115) :\n    \u2200\u1da0 \u03b5 : \u211d in \ud835\udcdd 0, \u2200 k \u2264 n, \u2200 (m : \u2124), \u03b5 \u2264 dist x (m / k)", "start": [90, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "Irrational.eventually_forall_le_dist_cast_rat_of_den_le", "code": "theorem eventually_forall_le_dist_cast_rat_of_den_le (hx : Irrational x) (n : \u2115) :\n    \u2200\u1da0 \u03b5 : \u211d in \ud835\udcdd 0, \u2200 r : \u211a, r.den \u2264 n \u2192 \u03b5 \u2264 dist x r", "start": [95, 1], "end": [98, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Liouville/Basic.lean", "imports": ["Mathlib/Data/Real/Irrational.lean", "Mathlib/Data/Polynomial/DenomsClearable.lean", "Mathlib/Analysis/Calculus/Deriv/Polynomial.lean", "Mathlib/Analysis/Calculus/MeanValue.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Polynomial.lean"], "premises": [{"full_name": "Liouville", "code": "def Liouville (x : \u211d) :=\n  \u2200 n : \u2115, \u2203 a b : \u2124, 1 < b \u2227 x \u2260 a / b \u2227 |x - a / b| < 1 / (b : \u211d) ^ n", "start": [29, 1], "end": [34, 72], "kind": "commanddeclaration"}, {"full_name": "Liouville.irrational", "code": "protected theorem irrational {x : \u211d} (h : Liouville x) : Irrational x", "start": [39, 1], "end": [71, 96], "kind": "commanddeclaration"}, {"full_name": "Liouville.exists_one_le_pow_mul_dist", "code": "theorem exists_one_le_pow_mul_dist {Z N R : Type*} [PseudoMetricSpace R] {d : N \u2192 \u211d}\n    {j : Z \u2192 N \u2192 R} {f : R \u2192 R} {\u03b1 : R} {\u03b5 M : \u211d}\n    (d0 : \u2200 a : N, 1 \u2264 d a)\n    (e0 : 0 < \u03b5)\n    (B : \u2200 \u2983y : R\u2984, y \u2208 closedBall \u03b1 \u03b5 \u2192 dist (f \u03b1) (f y) \u2264 dist \u03b1 y * M)\n    (L : \u2200 \u2983z : Z\u2984, \u2200 \u2983a : N\u2984, j z a \u2208 closedBall \u03b1 \u03b5 \u2192 1 \u2264 d a * dist (f \u03b1) (f (j z a))) :\n    \u2203 A : \u211d, 0 < A \u2227 \u2200 z : Z, \u2200 a : N, 1 \u2264 d a * (dist \u03b1 (j z a) * A)", "start": [78, 1], "end": [120, 67], "kind": "commanddeclaration"}, {"full_name": "Liouville.exists_pos_real_of_irrational_root", "code": "theorem exists_pos_real_of_irrational_root {\u03b1 : \u211d} (ha : Irrational \u03b1) {f : \u2124[X]} (f0 : f \u2260 0)\n    (fa : eval \u03b1 (map (algebraMap \u2124 \u211d) f) = 0) :\n    \u2203 A : \u211d, 0 < A \u2227 \u2200 a : \u2124, \u2200 b : \u2115,\n      (1 : \u211d) \u2264 ((b : \u211d) + 1) ^ f.natDegree * (|\u03b1 - a / (b + 1)| * A)", "start": [123, 1], "end": [173, 50], "kind": "commanddeclaration"}, {"full_name": "Liouville.transcendental", "code": "protected theorem transcendental {x : \u211d} (lx : Liouville x) : Transcendental \u2124 x", "start": [176, 1], "end": [217, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Thunk.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Tactic/Ext.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Thunk.ext", "code": "@[ext]\ntheorem ext {\u03b1 : Type u} {a b : Thunk \u03b1} (eq : a.get = b.get) : a = b", "start": [20, 1], "end": [25, 26], "kind": "commanddeclaration"}, {"full_name": "Thunk.prod", "code": "def prod (a : Thunk \u03b1) (b : Thunk \u03b2) : Thunk (\u03b1 \u00d7 \u03b2) := Thunk.mk fun _ => (a.get, b.get)", "start": [33, 1], "end": [34, 89], "kind": "commanddeclaration"}, {"full_name": "Thunk.prod_get_fst", "code": "@[simp] theorem prod_get_fst : (prod a b).get.1 = a.get", "start": [36, 1], "end": [36, 63], "kind": "commanddeclaration"}, {"full_name": "Thunk.prod_get_snd", "code": "@[simp] theorem prod_get_snd : (prod a b).get.2 = b.get", "start": [37, 1], "end": [37, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/EditDistance/Defs.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Levenshtein.Cost", "code": "structure Cost (\u03b1 \u03b2 \u03b4 : Type*) where\n  \n  delete : \u03b1 \u2192 \u03b4\n  \n  insert : \u03b2 \u2192 \u03b4\n  \n  substitute : \u03b1 \u2192 \u03b2 \u2192 \u03b4", "start": [44, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "Levenshtein.defaultCost", "code": "@[simps]\ndef defaultCost [DecidableEq \u03b1] : Cost \u03b1 \u03b1 \u2115 where\n  delete _ := 1\n  insert _ := 1\n  substitute a b := if a = b then 0 else 1", "start": [53, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "Levenshtein.impl", "code": "def impl\n    (xs : List \u03b1) (y : \u03b2) (d : {r : List \u03b4 // 0 < r.length}) : {r : List \u03b4 // 0 < r.length} :=\n  let \u27e8ds, w\u27e9 := d\n  xs.zip (ds.zip ds.tail) |>.foldr\n    (init := \u27e8[C.insert y + ds.getLast (List.length_pos.mp w)], by simp\u27e9)\n    (fun \u27e8x, d\u2080, d\u2081\u27e9 \u27e8r, w\u27e9 =>\n      \u27e8min (C.delete x + r[0]) (min (C.insert y + d\u2080) (C.substitute x y + d\u2081)) :: r, by simp\u27e9)", "start": [64, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "Levenshtein.impl_cons", "code": "theorem impl_cons (w' : 0 < List.length ds) :\n    impl C (x :: xs) y \u27e8d :: ds, w\u27e9 =\n      let \u27e8r, w\u27e9 := impl C xs y \u27e8ds, w'\u27e9\n      \u27e8min (C.delete x + r[0]) (min (C.insert y + d) (C.substitute x y + ds[0])) :: r, by simp\u27e9", "start": [89, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "Levenshtein.impl_cons_fst_zero", "code": "theorem impl_cons_fst_zero (h) (w' : 0 < List.length ds) :\n    (impl C (x :: xs) y \u27e8d :: ds, w\u27e9).1[0] =\n      let \u27e8r, w\u27e9 := impl C xs y \u27e8ds, w'\u27e9\n      min (C.delete x + r[0]) (min (C.insert y + d) (C.substitute x y + ds[0]))", "start": [97, 1], "end": [101, 39], "kind": "commanddeclaration"}, {"full_name": "Levenshtein.impl_length", "code": "theorem impl_length (d : {r : List \u03b4 // 0 < r.length}) (w : d.1.length = xs.length + 1) :\n    (impl C xs y d).1.length = xs.length + 1", "start": [103, 1], "end": [114, 57], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein", "code": "def suffixLevenshtein (xs : List \u03b1) (ys : List \u03b2) : {r : List \u03b4 // 0 < r.length} :=\n  ys.foldr\n    (impl C xs)\n    (xs.foldr (init := \u27e8[0], by simp\u27e9) (fun a \u27e8r, w\u27e9 => \u27e8(C.delete a + r[0]) :: r, by simp\u27e9))", "start": [122, 1], "end": [139, 94], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_length", "code": "theorem suffixLevenshtein_length (xs : List \u03b1) (ys : List \u03b2) :\n    (suffixLevenshtein C xs ys).1.length = xs.length + 1", "start": [143, 1], "end": [155, 13], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_eq", "code": "theorem suffixLevenshtein_eq (xs : List \u03b1) (y ys) :\n    impl C xs y (suffixLevenshtein C xs ys) = suffixLevenshtein C xs (y :: ys)", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "levenshtein", "code": "def levenshtein (xs : List \u03b1) (ys : List \u03b2) : \u03b4 :=\n  let \u27e8r, w\u27e9 := suffixLevenshtein C xs ys\n  r[0]", "start": [164, 1], "end": [178, 7], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_nil_nil", "code": "theorem suffixLevenshtein_nil_nil : (suffixLevenshtein C [] []).1 = [0]", "start": [182, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_length_one", "code": "theorem List.eq_of_length_one (x : List \u03b1) (w : x.length = 1) :\n    have : 0 < x.length := (lt_of_lt_of_eq Nat.zero_lt_one w.symm)\n    x = [x[0]]", "start": [186, 1], "end": [190, 18], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_nil'", "code": "theorem suffixLevenshtein_nil' (ys : List \u03b2) :\n    (suffixLevenshtein C [] ys).1 = [levenshtein C [] ys]", "start": [192, 1], "end": [194, 58], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_cons\u2082", "code": "theorem suffixLevenshtein_cons\u2082 (xs : List \u03b1) (y ys) :\n    suffixLevenshtein C xs (y :: ys) = (impl C xs) y (suffixLevenshtein C xs ys)", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_cons\u2081_aux", "code": "theorem suffixLevenshtein_cons\u2081_aux {x y : {r : List \u03b4 // 0 < r.length}}\n    (w\u2080 : x.1[0]'x.2 = y.1[0]'y.2) (w : x.1.tail = y.1.tail) : x = y", "start": [200, 1], "end": [203, 45], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_cons\u2081", "code": "theorem suffixLevenshtein_cons\u2081\n    (x : \u03b1) (xs ys) :\n    suffixLevenshtein C (x :: xs) ys =\n      \u27e8levenshtein C (x :: xs) ys ::\n        (suffixLevenshtein C xs ys).1, by simp\u27e9", "start": [205, 1], "end": [218, 40], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_cons\u2081_fst", "code": "theorem suffixLevenshtein_cons\u2081_fst (x : \u03b1) (xs ys) :\n    (suffixLevenshtein C (x :: xs) ys).1 =\n      levenshtein C (x :: xs) ys ::\n        (suffixLevenshtein C xs ys).1", "start": [220, 1], "end": [224, 33], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_cons_cons_fst_get_zero", "code": "theorem suffixLevenshtein_cons_cons_fst_get_zero\n    (x : \u03b1) (xs y ys) (w) :\n    (suffixLevenshtein C (x :: xs) (y :: ys)).1[0] =\n      let \u27e8dx, _\u27e9 := suffixLevenshtein C xs (y :: ys)\n      let \u27e8dy, _\u27e9 := suffixLevenshtein C (x :: xs) ys\n      let \u27e8dxy, _\u27e9 := suffixLevenshtein C xs ys\n      min\n        (C.delete x + dx[0])\n        (min\n          (C.insert y + dy[0])\n          (C.substitute x y + dxy[0]))", "start": [226, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_eq_tails_map", "code": "theorem suffixLevenshtein_eq_tails_map (xs ys) :\n    (suffixLevenshtein C xs ys).1 = xs.tails.map fun xs' => levenshtein C xs' ys", "start": [244, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "levenshtein_nil_nil", "code": "@[simp]\ntheorem levenshtein_nil_nil : levenshtein C [] [] = 0", "start": [252, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "levenshtein_nil_cons", "code": "@[simp]\ntheorem levenshtein_nil_cons (y) (ys) :\n    levenshtein C [] (y :: ys) = C.insert y + levenshtein C [] ys", "start": [256, 1], "end": [264, 24], "kind": "commanddeclaration"}, {"full_name": "levenshtein_cons_nil", "code": "@[simp]\ntheorem levenshtein_cons_nil (x : \u03b1) (xs : List \u03b1) :\n    levenshtein C (x :: xs) [] = C.delete x + levenshtein C xs []", "start": [266, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "levenshtein_cons_cons", "code": "@[simp]\ntheorem levenshtein_cons_cons\n    (x : \u03b1) (xs : List \u03b1) (y : \u03b2) (ys : List \u03b2) :\n    levenshtein C (x :: xs) (y :: ys) =\n      min (C.delete x + levenshtein C xs (y :: ys))\n        (min (C.insert y + levenshtein C (x :: xs) ys)\n          (C.substitute x y + levenshtein C xs ys))", "start": [271, 1], "end": [278, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Hom/Monoid.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Algebra/Hom/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Algebra/Order/Group/Instances.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean"], "premises": [{"full_name": "OrderAddMonoidHom", "code": "structure OrderAddMonoidHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] [AddZeroClass \u03b1]\n  [AddZeroClass \u03b2] extends \u03b1 \u2192+ \u03b2 where\n  \n  monotone' : Monotone toFun", "start": [63, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "OrderAddMonoidHomClass", "code": "class OrderAddMonoidHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Preorder \u03b1] [Preorder \u03b2]\n  [AddZeroClass \u03b1] [AddZeroClass \u03b2] extends AddMonoidHomClass F \u03b1 \u03b2 where\n  \n  monotone (f : F) : Monotone f", "start": [83, 1], "end": [89, 32], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom", "code": "@[to_additive]\nstructure OrderMonoidHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] [MulOneClass \u03b1]\n  [MulOneClass \u03b2] extends \u03b1 \u2192* \u03b2 where\n  \n  monotone' : Monotone toFun", "start": [99, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHomClass", "code": "@[to_additive]\nclass OrderMonoidHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Preorder \u03b1] [Preorder \u03b2]\n  [MulOneClass \u03b1] [MulOneClass \u03b2] extends MonoidHomClass F \u03b1 \u03b2 where\n  \n  monotone (f : F) : Monotone f", "start": [119, 1], "end": [126, 32], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHomClass.toOrderMonoidHom", "code": "@[to_additive (attr := coe)\n  \"Turn an element of a type `F` satisfying `OrderAddMonoidHomClass F \u03b1 \u03b2` into an actual\n  `OrderAddMonoidHom`. This is declared as the default coercion from `F` to `\u03b1 \u2192+o \u03b2`.\"]\ndef OrderMonoidHomClass.toOrderMonoidHom [OrderMonoidHomClass F \u03b1 \u03b2] (f : F) : \u03b1 \u2192*o \u03b2 :=\n  { (f : \u03b1 \u2192* \u03b2) with monotone' := monotone f }", "start": [133, 1], "end": [139, 48], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHomClass.toOrderHomClass", "code": "@[to_additive]\ninstance (priority := 100) OrderMonoidHomClass.toOrderHomClass [OrderMonoidHomClass F \u03b1 \u03b2] :\n    OrderHomClass F \u03b1 \u03b2 :=\n  { \u2039OrderMonoidHomClass F \u03b1 \u03b2\u203a with map_rel := OrderMonoidHomClass.monotone }", "start": [142, 1], "end": [145, 79], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom", "code": "structure OrderMonoidWithZeroHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] [MulZeroOneClass \u03b1]\n  [MulZeroOneClass \u03b2] extends \u03b1 \u2192*\u2080 \u03b2 where\n  \n  monotone' : Monotone toFun", "start": [162, 1], "end": [174, 29], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHomClass", "code": "class OrderMonoidWithZeroHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Preorder \u03b1] [Preorder \u03b2]\n  [MulZeroOneClass \u03b1] [MulZeroOneClass \u03b2] extends MonoidWithZeroHomClass F \u03b1 \u03b2 where\n  \n  monotone (f : F) : Monotone f", "start": [182, 1], "end": [189, 32], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom", "code": "@[coe]\ndef OrderMonoidWithZeroHomClass.toOrderMonoidWithZeroHom [OrderMonoidWithZeroHomClass F \u03b1 \u03b2]\n    (f : F) : \u03b1 \u2192*\u2080o \u03b2 :=\n{ (f : \u03b1 \u2192*\u2080 \u03b2) with monotone' := monotone f }", "start": [192, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHomClass.toOrderMonoidHomClass", "code": "instance (priority := 100) OrderMonoidWithZeroHomClass.toOrderMonoidHomClass\n    {_ : Preorder \u03b1} {_ : Preorder \u03b2} {_ : MulZeroOneClass \u03b1} {_ : MulZeroOneClass \u03b2}\n    [OrderMonoidWithZeroHomClass F \u03b1 \u03b2] : OrderMonoidHomClass F \u03b1 \u03b2 :=\n  { \u2039OrderMonoidWithZeroHomClass F \u03b1 \u03b2\u203a with }", "start": [202, 1], "end": [205, 47], "kind": "commanddeclaration"}, {"full_name": "map_nonneg", "code": "theorem map_nonneg (ha : 0 \u2264 a) : 0 \u2264 f a", "start": [218, 1], "end": [220, 32], "kind": "commanddeclaration"}, {"full_name": "map_nonpos", "code": "theorem map_nonpos (ha : a \u2264 0) : f a \u2264 0", "start": [223, 1], "end": [225, 32], "kind": "commanddeclaration"}, {"full_name": "monotone_iff_map_nonneg", "code": "theorem monotone_iff_map_nonneg : Monotone (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a, 0 \u2264 a \u2192 0 \u2264 f a", "start": [234, 1], "end": [239, 58], "kind": "commanddeclaration"}, {"full_name": "antitone_iff_map_nonpos", "code": "theorem antitone_iff_map_nonpos : Antitone (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a, 0 \u2264 a \u2192 f a \u2264 0", "start": [242, 1], "end": [243, 67], "kind": "commanddeclaration"}, {"full_name": "monotone_iff_map_nonpos", "code": "theorem monotone_iff_map_nonpos : Monotone (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a \u2264 0, f a \u2264 0", "start": [246, 1], "end": [247, 67], "kind": "commanddeclaration"}, {"full_name": "antitone_iff_map_nonneg", "code": "theorem antitone_iff_map_nonneg : Antitone (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a \u2264 0, 0 \u2264 f a", "start": [250, 1], "end": [251, 67], "kind": "commanddeclaration"}, {"full_name": "strictMono_iff_map_pos", "code": "theorem strictMono_iff_map_pos : StrictMono (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a, 0 < a \u2192 0 < f a", "start": [256, 1], "end": [261, 53], "kind": "commanddeclaration"}, {"full_name": "strictAnti_iff_map_neg", "code": "theorem strictAnti_iff_map_neg : StrictAnti (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a, 0 < a \u2192 f a < 0", "start": [264, 1], "end": [265, 68], "kind": "commanddeclaration"}, {"full_name": "strictMono_iff_map_neg", "code": "theorem strictMono_iff_map_neg : StrictMono (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a < 0, f a < 0", "start": [268, 1], "end": [269, 68], "kind": "commanddeclaration"}, {"full_name": "strictAnti_iff_map_pos", "code": "theorem strictAnti_iff_map_pos : StrictAnti (f : \u03b1 \u2192 \u03b2) \u2194 \u2200 a < 0, 0 < f a", "start": [272, 1], "end": [273, 68], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext (h : \u2200 a, f a = g a) : f = g", "start": [306, 1], "end": [308, 20], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toFun_eq_coe", "code": "@[to_additive]\ntheorem toFun_eq_coe (f : \u03b1 \u2192*o \u03b2) : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_mk (f : \u03b1 \u2192* \u03b2) (h) : (OrderMonoidHom.mk f h : \u03b1 \u2192 \u03b2) = f", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem mk_coe (f : \u03b1 \u2192*o \u03b2) (h) : OrderMonoidHom.mk (f : \u03b1 \u2192* \u03b2) h = f", "start": [324, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toOrderHom", "code": "@[to_additive \"Reinterpret an ordered additive monoid homomorphism as an order homomorphism.\"]\ndef toOrderHom (f : \u03b1 \u2192*o \u03b2) : \u03b1 \u2192o \u03b2 :=\n  { f with }", "start": [331, 1], "end": [334, 13], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_monoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_monoidHom (f : \u03b1 \u2192*o \u03b2) : ((f : \u03b1 \u2192* \u03b2) : \u03b1 \u2192 \u03b2) = f", "start": [338, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_orderHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_orderHom (f : \u03b1 \u2192*o \u03b2) : ((f : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = f", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toMonoidHom_injective", "code": "@[to_additive]\ntheorem toMonoidHom_injective : Injective (toMonoidHom : _ \u2192 \u03b1 \u2192* \u03b2)", "start": [350, 1], "end": [352, 48], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toOrderHom_injective", "code": "@[to_additive]\ntheorem toOrderHom_injective : Injective (toOrderHom : _ \u2192 \u03b1 \u2192o \u03b2)", "start": [356, 1], "end": [358, 48], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.copy", "code": "@[to_additive \"Copy of an `OrderAddMonoidHom` with a new `toFun` equal to the old one. Useful to fix\ndefinitional equalities.\"]\nprotected def copy (f : \u03b1 \u2192*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192*o \u03b2 :=\n  { f.toMonoidHom.copy f' h with toFun := f', monotone' := h.symm.subst f.monotone' }", "start": [362, 1], "end": [367, 86], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem coe_copy (f : \u03b1 \u2192*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [371, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.copy_eq", "code": "@[to_additive]\ntheorem copy_eq (f : \u03b1 \u2192*o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [377, 1], "end": [379, 17], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.id", "code": "@[to_additive \"The identity map as an ordered additive monoid homomorphism.\"]\nprotected def id : \u03b1 \u2192*o \u03b1 :=\n  { MonoidHom.id \u03b1, OrderHom.id with }", "start": [385, 1], "end": [388, 39], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_id", "code": "@[to_additive (attr := simp)]\ntheorem coe_id : \u21d1(OrderMonoidHom.id \u03b1) = id", "start": [392, 1], "end": [394, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp", "code": "@[to_additive \"Composition of `OrderAddMonoidHom`s as an `OrderAddMonoidHom`\"]\ndef comp (f : \u03b2 \u2192*o \u03b3) (g : \u03b1 \u2192*o \u03b2) : \u03b1 \u2192*o \u03b3 :=\n  { f.toMonoidHom.comp (g : \u03b1 \u2192* \u03b2), f.toOrderHom.comp (g : \u03b1 \u2192o \u03b2) with }", "start": [404, 1], "end": [407, 75], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem coe_comp (f : \u03b2 \u2192*o \u03b3) (g : \u03b1 \u2192*o \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [411, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp_apply", "code": "@[to_additive (attr := simp)]\ntheorem comp_apply (f : \u03b2 \u2192*o \u03b3) (g : \u03b1 \u2192*o \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [417, 1], "end": [419, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_comp_monoidHom", "code": "@[to_additive]\ntheorem coe_comp_monoidHom (f : \u03b2 \u2192*o \u03b3) (g : \u03b1 \u2192*o \u03b2) :\n    (f.comp g : \u03b1 \u2192* \u03b3) = (f : \u03b2 \u2192* \u03b3).comp g", "start": [423, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_comp_orderHom", "code": "@[to_additive]\ntheorem coe_comp_orderHom (f : \u03b2 \u2192*o \u03b3) (g : \u03b1 \u2192*o \u03b2) :\n    (f.comp g : \u03b1 \u2192o \u03b3) = (f : \u03b2 \u2192o \u03b3).comp g", "start": [430, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp_assoc", "code": "@[to_additive (attr := simp)]\ntheorem comp_assoc (f : \u03b3 \u2192*o \u03b4) (g : \u03b2 \u2192*o \u03b3) (h : \u03b1 \u2192*o \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [437, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem comp_id (f : \u03b1 \u2192*o \u03b2) : f.comp (OrderMonoidHom.id \u03b1) = f", "start": [444, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.id_comp", "code": "@[to_additive (attr := simp)]\ntheorem id_comp (f : \u03b1 \u2192*o \u03b2) : (OrderMonoidHom.id \u03b2).comp f = f", "start": [450, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192*o \u03b3} {f : \u03b1 \u2192*o \u03b2} (hf : Function.Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [456, 1], "end": [459, 74], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem cancel_left {g : \u03b2 \u2192*o \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192*o \u03b2} (hg : Function.Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [463, 1], "end": [466, 81], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one : \u21d1(1 : \u03b1 \u2192*o \u03b2) = 1", "start": [475, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem one_apply (a : \u03b1) : (1 : \u03b1 \u2192*o \u03b2) a = 1", "start": [481, 1], "end": [483, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem one_comp (f : \u03b1 \u2192*o \u03b2) : (1 : \u03b2 \u2192*o \u03b3).comp f = 1", "start": [487, 1], "end": [489, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp_one", "code": "@[to_additive (attr := simp)]\ntheorem comp_one (f : \u03b2 \u2192*o \u03b3) : f.comp (1 : \u03b1 \u2192*o \u03b2) = 1", "start": [493, 1], "end": [495, 25], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.coe_mul", "code": "@[to_additive (attr := simp)]\ntheorem coe_mul (f g : \u03b1 \u2192*o \u03b2) : \u21d1(f * g) = f * g", "start": [512, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply (f g : \u03b1 \u2192*o \u03b2) (a : \u03b1) : (f * g) a = f a * g a", "start": [518, 1], "end": [520, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.mul_comp", "code": "@[to_additive]\ntheorem mul_comp (g\u2081 g\u2082 : \u03b2 \u2192*o \u03b3) (f : \u03b1 \u2192*o \u03b2) : (g\u2081 * g\u2082).comp f = g\u2081.comp f * g\u2082.comp f", "start": [524, 1], "end": [526, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.comp_mul", "code": "@[to_additive]\ntheorem comp_mul (g : \u03b2 \u2192*o \u03b3) (f\u2081 f\u2082 : \u03b1 \u2192*o \u03b2) : g.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082", "start": [530, 1], "end": [532, 29], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toMonoidHom_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toMonoidHom_eq_coe (f : \u03b1 \u2192*o \u03b2) : f.toMonoidHom = f", "start": [542, 1], "end": [544, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.toOrderHom_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toOrderHom_eq_coe (f : \u03b1 \u2192*o \u03b2) : f.toOrderHom = f", "start": [548, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidHom.mk'", "code": "@[to_additive\n      \"Makes an ordered additive group homomorphism from a proof that the map preserves\n      addition.\"]\ndef mk' (f : \u03b1 \u2192 \u03b2) (hf : Monotone f) (map_mul : \u2200 a b : \u03b1, f (a * b) = f a * f b) : \u03b1 \u2192*o \u03b2 :=\n  { MonoidHom.mk' f map_mul with monotone' := hf }", "start": [560, 1], "end": [565, 51], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.ext", "code": "@[ext]\ntheorem ext (h : \u2200 a, f a = g a) : f = g", "start": [599, 1], "end": [601, 20], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toFun_eq_coe", "code": "theorem toFun_eq_coe (f : \u03b1 \u2192*\u2080o \u03b2) : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [604, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u03b1 \u2192*\u2080 \u03b2) (h) : (OrderMonoidWithZeroHom.mk f h : \u03b1 \u2192 \u03b2) = f", "start": [608, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : \u03b1 \u2192*\u2080o \u03b2) (h) : OrderMonoidWithZeroHom.mk (f : \u03b1 \u2192*\u2080 \u03b2) h = f", "start": [613, 1], "end": [614, 89], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toOrderMonoidHom", "code": "def toOrderMonoidHom (f : \u03b1 \u2192*\u2080o \u03b2) : \u03b1 \u2192*o \u03b2 :=\n  { f with }", "start": [617, 1], "end": [619, 13], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_monoidWithZeroHom", "code": "@[simp]\ntheorem coe_monoidWithZeroHom (f : \u03b1 \u2192*\u2080o \u03b2) : \u21d1(f : \u03b1 \u2192*\u2080 \u03b2) = f", "start": [622, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_orderMonoidHom", "code": "@[simp]\ntheorem coe_orderMonoidHom (f : \u03b1 \u2192*\u2080o \u03b2) : \u21d1(f : \u03b1 \u2192*o \u03b2) = f", "start": [627, 1], "end": [629, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toOrderMonoidHom_injective", "code": "theorem toOrderMonoidHom_injective : Injective (toOrderMonoidHom : _ \u2192 \u03b1 \u2192*o \u03b2)", "start": [632, 1], "end": [633, 48], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toMonoidWithZeroHom_injective", "code": "theorem toMonoidWithZeroHom_injective : Injective (toMonoidWithZeroHom : _ \u2192 \u03b1 \u2192*\u2080 \u03b2)", "start": [636, 1], "end": [637, 61], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.copy", "code": "protected def copy (f : \u03b1 \u2192*\u2080o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192*o \u03b2 :=\n  { f.toOrderMonoidHom.copy f' h, f.toMonoidWithZeroHom.copy f' h with toFun := f' }", "start": [640, 1], "end": [643, 85], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192*\u2080o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [646, 1], "end": [648, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192*\u2080o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [651, 1], "end": [652, 17], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.id", "code": "protected def id : \u03b1 \u2192*\u2080o \u03b1 :=\n  { MonoidWithZeroHom.id \u03b1, OrderHom.id with }", "start": [657, 1], "end": [659, 47], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(OrderMonoidWithZeroHom.id \u03b1) = id", "start": [662, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.comp", "code": "def comp (f : \u03b2 \u2192*\u2080o \u03b3) (g : \u03b1 \u2192*\u2080o \u03b2) : \u03b1 \u2192*\u2080o \u03b3 :=\n  { f.toMonoidWithZeroHom.comp (g : \u03b1 \u2192*\u2080 \u03b2), f.toOrderMonoidHom.comp (g : \u03b1 \u2192*o \u03b2) with }", "start": [672, 1], "end": [674, 91], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : \u03b2 \u2192*\u2080o \u03b3) (g : \u03b1 \u2192*\u2080o \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [677, 1], "end": [679, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : \u03b2 \u2192*\u2080o \u03b3) (g : \u03b1 \u2192*\u2080o \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [682, 1], "end": [684, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_comp_monoidWithZeroHom", "code": "theorem coe_comp_monoidWithZeroHom (f : \u03b2 \u2192*\u2080o \u03b3) (g : \u03b1 \u2192*\u2080o \u03b2) :\n    (f.comp g : \u03b1 \u2192*\u2080 \u03b3) = (f : \u03b2 \u2192*\u2080 \u03b3).comp g", "start": [687, 1], "end": [689, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_comp_orderMonoidHom", "code": "theorem coe_comp_orderMonoidHom (f : \u03b2 \u2192*\u2080o \u03b3) (g : \u03b1 \u2192*\u2080o \u03b2) :\n    (f.comp g : \u03b1 \u2192*o \u03b3) = (f : \u03b2 \u2192*o \u03b3).comp g", "start": [692, 1], "end": [694, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : \u03b3 \u2192*\u2080o \u03b4) (g : \u03b2 \u2192*\u2080o \u03b3) (h : \u03b1 \u2192*\u2080o \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [697, 1], "end": [700, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192*\u2080o \u03b2) : f.comp (OrderMonoidWithZeroHom.id \u03b1) = f", "start": [703, 1], "end": [704, 81], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192*\u2080o \u03b2) : (OrderMonoidWithZeroHom.id \u03b2).comp f = f", "start": [707, 1], "end": [708, 81], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192*\u2080o \u03b3} {f : \u03b1 \u2192*\u2080o \u03b2} (hf : Function.Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [711, 1], "end": [714, 74], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192*\u2080o \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192*\u2080o \u03b2} (hg : Function.Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [717, 1], "end": [720, 81], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : \u03b1 \u2192*\u2080o \u03b2) : \u21d1(f * g) = f * g", "start": [735, 1], "end": [737, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.mul_apply", "code": "@[simp]\ntheorem mul_apply (f g : \u03b1 \u2192*\u2080o \u03b2) (a : \u03b1) : (f * g) a = f a * g a", "start": [740, 1], "end": [742, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.mul_comp", "code": "theorem mul_comp (g\u2081 g\u2082 : \u03b2 \u2192*\u2080o \u03b3) (f : \u03b1 \u2192*\u2080o \u03b2) : (g\u2081 * g\u2082).comp f = g\u2081.comp f * g\u2082.comp f", "start": [745, 1], "end": [746, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.comp_mul", "code": "theorem comp_mul (g : \u03b2 \u2192*\u2080o \u03b3) (f\u2081 f\u2082 : \u03b1 \u2192*\u2080o \u03b2) : g.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082", "start": [749, 1], "end": [750, 29], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toMonoidWithZeroHom_eq_coe", "code": "@[simp]\ntheorem toMonoidWithZeroHom_eq_coe (f : \u03b1 \u2192*\u2080o \u03b2) : f.toMonoidWithZeroHom = f", "start": [759, 1], "end": [761, 6], "kind": "commanddeclaration"}, {"full_name": "OrderMonoidWithZeroHom.toOrderMonoidHom_eq_coe", "code": "@[simp]\ntheorem toOrderMonoidHom_eq_coe (f : \u03b1 \u2192*\u2080o \u03b2) : f.toOrderMonoidHom = f", "start": [764, 1], "end": [766, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Padics/PadicIntegers.lean", "imports": ["Mathlib/NumberTheory/Padics/PadicNumbers.lean", "Mathlib/RingTheory/DiscreteValuationRing/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PadicInt", "code": "def PadicInt (p : \u2115) [Fact p.Prime] :=\n  { x : \u211a_[p] // \u2016x\u2016 \u2264 1 }", "start": [57, 1], "end": [59, 27], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ext", "code": "theorem ext {x y : \u2124_[p]} : (x : \u211a_[p]) = y \u2192 x = y", "start": [75, 1], "end": [76, 14], "kind": "commanddeclaration"}, {"full_name": "PadicInt.subring", "code": "def subring : Subring \u211a_[p] where\n  carrier := { x : \u211a_[p] | \u2016x\u2016 \u2264 1 }\n  zero_mem' := by norm_num\n  one_mem' := by norm_num\n  add_mem' hx hy := (padicNormE.nonarchimedean _ _).trans <| max_le_iff.2 \u27e8hx, hy\u27e9\n  mul_mem' hx hy := (padicNormE.mul _ _).trans_le <| mul_le_one hx (norm_nonneg _) hy\n  neg_mem' hx := (norm_neg _).trans_le hx", "start": [81, 1], "end": [88, 42], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mem_subring_iff", "code": "@[simp]\ntheorem mem_subring_iff {x : \u211a_[p]} : x \u2208 subring p \u2194 \u2016x\u2016 \u2264 1", "start": [91, 1], "end": [92, 73], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mk_zero", "code": "@[simp]\ntheorem mk_zero {h} : (\u27e80, h\u27e9 : \u2124_[p]) = (0 : \u2124_[p])", "start": [117, 1], "end": [118, 60], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (z1 z2 : \u2124_[p]) : ((z1 + z2 : \u2124_[p]) : \u211a_[p]) = z1 + z2", "start": [121, 1], "end": [122, 79], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (z1 z2 : \u2124_[p]) : ((z1 * z2 : \u2124_[p]) : \u211a_[p]) = z1 * z2", "start": [125, 1], "end": [126, 79], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (z1 : \u2124_[p]) : ((-z1 : \u2124_[p]) : \u211a_[p]) = -z1", "start": [129, 1], "end": [130, 68], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (z1 z2 : \u2124_[p]) : ((z1 - z2 : \u2124_[p]) : \u211a_[p]) = z1 - z2", "start": [133, 1], "end": [134, 79], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : \u2124_[p]) : \u211a_[p]) = 1", "start": [137, 1], "end": [138, 51], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : \u2124_[p]) : \u211a_[p]) = 0", "start": [141, 1], "end": [142, 52], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_eq_zero", "code": "theorem coe_eq_zero (z : \u2124_[p]) : (z : \u211a_[p]) = 0 \u2194 z = 0", "start": [145, 1], "end": [145, 97], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_ne_zero", "code": "theorem coe_ne_zero (z : \u2124_[p]) : (z : \u211a_[p]) \u2260 0 \u2194 z \u2260 0", "start": [148, 1], "end": [148, 79], "kind": "commanddeclaration"}, {"full_name": "PadicInt.instCommRing", "code": "instance instCommRing : CommRing \u2124_[p] := (by infer_instance : CommRing (subring p))", "start": [153, 1], "end": [153, 85], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_nat_cast", "code": "@[simp, norm_cast]\ntheorem coe_nat_cast (n : \u2115) : ((n : \u2124_[p]) : \u211a_[p]) = n", "start": [155, 1], "end": [156, 64], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_int_cast", "code": "@[simp, norm_cast]\ntheorem coe_int_cast (z : \u2124) : ((z : \u2124_[p]) : \u211a_[p]) = z", "start": [159, 1], "end": [160, 64], "kind": "commanddeclaration"}, {"full_name": "PadicInt.Coe.ringHom", "code": "def Coe.ringHom : \u2124_[p] \u2192+* \u211a_[p] := (subring p).subtype", "start": [163, 1], "end": [164, 57], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : \u2124_[p]) (n : \u2115) : (\u2191(x ^ n) : \u211a_[p]) = (\u2191x : \u211a_[p]) ^ n", "start": [167, 1], "end": [168, 83], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mk_coe", "code": "theorem mk_coe (k : \u2124_[p]) : (\u27e8k, k.2\u27e9 : \u2124_[p]) = k", "start": [172, 1], "end": [172, 75], "kind": "commanddeclaration"}, {"full_name": "PadicInt.inv", "code": "def inv : \u2124_[p] \u2192 \u2124_[p]\n  | \u27e8k, _\u27e9 => if h : \u2016k\u2016 = 1 then \u27e8k\u207b\u00b9, by simp [h]\u27e9 else 0", "start": [175, 1], "end": [178, 60], "kind": "commanddeclaration"}, {"full_name": "PadicInt.coe_int_eq", "code": "@[norm_cast] theorem coe_int_eq (z1 z2 : \u2124) : (z1 : \u2124_[p]) = z2 \u2194 z1 = z2", "start": [184, 1], "end": [187, 12], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ofIntSeq", "code": "def ofIntSeq (seq : \u2115 \u2192 \u2124) (h : IsCauSeq (padicNorm p) fun n => seq n) : \u2124_[p] :=\n  \u27e8\u27e6\u27e8_, h\u27e9\u27e7,\n    show \u2191(PadicSeq.norm _) \u2264 (1 : \u211d) by\n      rw [PadicSeq.norm]\n      split_ifs with hne <;> norm_cast\n      apply padicNorm.of_int\u27e9", "start": [190, 1], "end": [197, 30], "kind": "commanddeclaration"}, {"full_name": "PadicInt.completeSpace", "code": "instance completeSpace : CompleteSpace \u2124_[p] :=\n  have : IsClosed { x : \u211a_[p] | \u2016x\u2016 \u2264 1 } := isClosed_le continuous_norm continuous_const\n  this.completeSpace_coe", "start": [217, 1], "end": [219, 25], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_def", "code": "theorem norm_def {z : \u2124_[p]} : \u2016z\u2016 = \u2016(z : \u211a_[p])\u2016", "start": [226, 1], "end": [226, 58], "kind": "commanddeclaration"}, {"full_name": "PadicInt.isAbsoluteValue", "code": "instance isAbsoluteValue : IsAbsoluteValue fun z : \u2124_[p] => \u2016z\u2016 where\n  abv_nonneg' := norm_nonneg\n  abv_eq_zero' := by simp [norm_eq_zero]\n  abv_add' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => norm_add_le _ _\n  abv_mul' _ _ := by simp only [norm_def, padicNormE.mul, PadicInt.coe_mul]", "start": [240, 1], "end": [244, 76], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_le_one", "code": "theorem norm_le_one (z : \u2124_[p]) : \u2016z\u2016 \u2264 1", "start": [260, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_mul", "code": "@[simp]\ntheorem norm_mul (z1 z2 : \u2124_[p]) : \u2016z1 * z2\u2016 = \u2016z1\u2016 * \u2016z2\u2016", "start": [263, 1], "end": [264, 81], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_pow", "code": "@[simp]\ntheorem norm_pow (z : \u2124_[p]) : \u2200 n : \u2115, \u2016z ^ n\u2016 = \u2016z\u2016 ^ n", "start": [267, 1], "end": [273, 19], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nonarchimedean", "code": "theorem nonarchimedean (q r : \u2124_[p]) : \u2016q + r\u2016 \u2264 max \u2016q\u2016 \u2016r\u2016", "start": [276, 1], "end": [276, 94], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_add_eq_max_of_ne", "code": "theorem norm_add_eq_max_of_ne {q r : \u2124_[p]} : \u2016q\u2016 \u2260 \u2016r\u2016 \u2192 \u2016q + r\u2016 = max \u2016q\u2016 \u2016r\u2016", "start": [279, 1], "end": [280, 30], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_eq_of_norm_add_lt_right", "code": "theorem norm_eq_of_norm_add_lt_right {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z2\u2016) : \u2016z1\u2016 = \u2016z2\u2016", "start": [283, 1], "end": [285, 75], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_eq_of_norm_add_lt_left", "code": "theorem norm_eq_of_norm_add_lt_left {z1 z2 : \u2124_[p]} (h : \u2016z1 + z2\u2016 < \u2016z1\u2016) : \u2016z1\u2016 = \u2016z2\u2016", "start": [288, 1], "end": [290, 74], "kind": "commanddeclaration"}, {"full_name": "PadicInt.padic_norm_e_of_padicInt", "code": "@[simp]\ntheorem padic_norm_e_of_padicInt (z : \u2124_[p]) : \u2016(z : \u211a_[p])\u2016 = \u2016z\u2016", "start": [293, 1], "end": [294, 89], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_int_cast_eq_padic_norm", "code": "theorem norm_int_cast_eq_padic_norm (z : \u2124) : \u2016(z : \u2124_[p])\u2016 = \u2016(z : \u211a_[p])\u2016", "start": [297, 1], "end": [297, 98], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_eq_padic_norm", "code": "@[simp]\ntheorem norm_eq_padic_norm {q : \u211a_[p]} (hq : \u2016q\u2016 \u2264 1) : @norm \u2124_[p] _ \u27e8q, hq\u27e9 = \u2016q\u2016", "start": [300, 1], "end": [301, 91], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_p", "code": "@[simp]\ntheorem norm_p : \u2016(p : \u2124_[p])\u2016 = (p : \u211d)\u207b\u00b9", "start": [304, 1], "end": [305, 64], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_p_pow", "code": "theorem norm_p_pow (n : \u2115) : \u2016(p : \u2124_[p]) ^ n\u2016 = (p : \u211d) ^ (-n : \u2124)", "start": [309, 1], "end": [309, 95], "kind": "commanddeclaration"}, {"full_name": "PadicInt.cauSeq_to_rat_cauSeq", "code": "private def cauSeq_to_rat_cauSeq (f : CauSeq \u2124_[p] norm) : CauSeq \u211a_[p] fun a => \u2016a\u2016 :=\n  \u27e8fun n => f n, fun _ h\u03b5 => by simpa [norm, norm_def] using f.cauchy h\u03b5\u27e9", "start": [312, 1], "end": [313, 74], "kind": "commanddeclaration"}, {"full_name": "PadicInt.complete", "code": "instance complete : CauSeq.IsComplete \u2124_[p] norm :=\n  \u27e8fun f =>\n    have hqn : \u2016CauSeq.lim (cauSeq_to_rat_cauSeq f)\u2016 \u2264 1 :=\n      padicNormE_lim_le zero_lt_one fun _ => norm_le_one _\n    \u27e8\u27e8_, hqn\u27e9, fun \u03b5 => by\n      simpa [norm, norm_def] using CauSeq.equiv_lim (cauSeq_to_rat_cauSeq f) \u03b5\u27e9\u27e9", "start": [317, 1], "end": [322, 81], "kind": "commanddeclaration"}, {"full_name": "PadicInt.exists_pow_neg_lt", "code": "theorem exists_pow_neg_lt {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211d) ^ (-(k : \u2124)) < \u03b5", "start": [331, 1], "end": [341, 28], "kind": "commanddeclaration"}, {"full_name": "PadicInt.exists_pow_neg_lt_rat", "code": "theorem exists_pow_neg_lt_rat {\u03b5 : \u211a} (h\u03b5 : 0 < \u03b5) : \u2203 k : \u2115, (p : \u211a) ^ (-(k : \u2124)) < \u03b5", "start": [344, 1], "end": [348, 20], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_int_lt_one_iff_dvd", "code": "theorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u2124_[p])\u2016 < 1 \u2194 (p : \u2124) \u2223 k", "start": [353, 1], "end": [355, 39], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_int_le_pow_iff_dvd", "code": "theorem norm_int_le_pow_iff_dvd {k : \u2124} {n : \u2115} :\n    \u2016(k : \u2124_[p])\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 (p ^ n : \u2124) \u2223 k", "start": [358, 1], "end": [361, 41], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation", "code": "def valuation (x : \u2124_[p]) :=\n  Padic.valuation (x : \u211a_[p])", "start": [367, 1], "end": [369, 30], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_eq_pow_val", "code": "theorem norm_eq_pow_val {x : \u2124_[p]} (hx : x \u2260 0) : \u2016x\u2016 = (p : \u211d) ^ (-x.valuation)", "start": [372, 1], "end": [375, 33], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation_zero", "code": "@[simp]\ntheorem valuation_zero : valuation (0 : \u2124_[p]) = 0", "start": [378, 1], "end": [379, 75], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation_one", "code": "@[simp]\ntheorem valuation_one : valuation (1 : \u2124_[p]) = 0", "start": [382, 1], "end": [383, 73], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation_p", "code": "@[simp]\ntheorem valuation_p : valuation (p : \u2124_[p]) = 1", "start": [386, 1], "end": [387, 71], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation_nonneg", "code": "theorem valuation_nonneg (x : \u2124_[p]) : 0 \u2264 x.valuation", "start": [390, 1], "end": [397, 25], "kind": "commanddeclaration"}, {"full_name": "PadicInt.valuation_p_pow_mul", "code": "@[simp]\ntheorem valuation_p_pow_mul (n : \u2115) (c : \u2124_[p]) (hc : c \u2260 0) :\n    ((p : \u2124_[p]) ^ n * c).valuation = n + c.valuation", "start": [400, 1], "end": [415, 32], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mul_inv", "code": "theorem mul_inv : \u2200 {z : \u2124_[p]}, \u2016z\u2016 = 1 \u2192 z * z.inv = 1", "start": [425, 1], "end": [433, 29], "kind": "commanddeclaration"}, {"full_name": "PadicInt.inv_mul", "code": "theorem inv_mul {z : \u2124_[p]} (hz : \u2016z\u2016 = 1) : z.inv * z = 1", "start": [436, 1], "end": [436, 91], "kind": "commanddeclaration"}, {"full_name": "PadicInt.isUnit_iff", "code": "theorem isUnit_iff {z : \u2124_[p]} : IsUnit z \u2194 \u2016z\u2016 = 1", "start": [439, 1], "end": [445, 45], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_lt_one_add", "code": "theorem norm_lt_one_add {z1 z2 : \u2124_[p]} (hz1 : \u2016z1\u2016 < 1) (hz2 : \u2016z2\u2016 < 1) : \u2016z1 + z2\u2016 < 1", "start": [448, 1], "end": [449, 55], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_lt_one_mul", "code": "theorem norm_lt_one_mul {z1 z2 : \u2124_[p]} (hz2 : \u2016z2\u2016 < 1) : \u2016z1 * z2\u2016 < 1", "start": [452, 1], "end": [455, 86], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mem_nonunits", "code": "theorem mem_nonunits {z : \u2124_[p]} : z \u2208 nonunits \u2124_[p] \u2194 \u2016z\u2016 < 1", "start": [460, 1], "end": [461, 68], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mkUnits", "code": "def mkUnits {u : \u211a_[p]} (h : \u2016u\u2016 = 1) : \u2124_[p]\u02e3 :=\n  let z : \u2124_[p] := \u27e8u, le_of_eq h\u27e9\n  \u27e8z, z.inv, mul_inv h, inv_mul h\u27e9", "start": [464, 1], "end": [467, 35], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mkUnits_eq", "code": "@[simp]\ntheorem mkUnits_eq {u : \u211a_[p]} (h : \u2016u\u2016 = 1) : ((mkUnits h : \u2124_[p]) : \u211a_[p]) = u", "start": [470, 1], "end": [471, 88], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_units", "code": "@[simp]\ntheorem norm_units (u : \u2124_[p]\u02e3) : \u2016(u : \u2124_[p])\u2016 = 1", "start": [474, 1], "end": [475, 80], "kind": "commanddeclaration"}, {"full_name": "PadicInt.unitCoeff", "code": "def unitCoeff {x : \u2124_[p]} (hx : x \u2260 0) : \u2124_[p]\u02e3 :=\n  let u : \u211a_[p] := x * (p : \u211a_[p]) ^ (-x.valuation)\n  have hu : \u2016u\u2016 = 1 := by\n    simp [hx, Nat.zpow_ne_zero_of_pos (by exact_mod_cast hp.1.pos) x.valuation, norm_eq_pow_val,\n      zpow_neg, inv_mul_cancel]\n  mkUnits hu", "start": [478, 1], "end": [485, 13], "kind": "commanddeclaration"}, {"full_name": "PadicInt.unitCoeff_coe", "code": "@[simp]\ntheorem unitCoeff_coe {x : \u2124_[p]} (hx : x \u2260 0) :\n    (unitCoeff hx : \u211a_[p]) = x * (p : \u211a_[p]) ^ (-x.valuation)", "start": [488, 1], "end": [490, 69], "kind": "commanddeclaration"}, {"full_name": "PadicInt.unitCoeff_spec", "code": "theorem unitCoeff_spec {x : \u2124_[p]} (hx : x \u2260 0) :\n    x = (unitCoeff hx : \u2124_[p]) * (p : \u2124_[p]) ^ Int.natAbs (valuation x)", "start": [493, 1], "end": [502, 63], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_le_pow_iff_le_valuation", "code": "theorem norm_le_pow_iff_le_valuation (x : \u2124_[p]) (hx : x \u2260 0) (n : \u2115) :\n    \u2016x\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 \u2191n \u2264 x.valuation", "start": [512, 1], "end": [524, 12], "kind": "commanddeclaration"}, {"full_name": "PadicInt.mem_span_pow_iff_le_valuation", "code": "theorem mem_span_pow_iff_le_valuation (x : \u2124_[p]) (hx : x \u2260 0) (n : \u2115) :\n    x \u2208 (Ideal.span {(p : \u2124_[p]) ^ n} : Ideal \u2124_[p]) \u2194 \u2191n \u2264 x.valuation", "start": [527, 1], "end": [542, 39], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_le_pow_iff_mem_span_pow", "code": "theorem norm_le_pow_iff_mem_span_pow (x : \u2124_[p]) (n : \u2115) :\n    \u2016x\u2016 \u2264 (p : \u211d) ^ (-n : \u2124) \u2194 x \u2208 (Ideal.span {(p : \u2124_[p]) ^ n} : Ideal \u2124_[p])", "start": [545, 1], "end": [551, 77], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_le_pow_iff_norm_lt_pow_add_one", "code": "theorem norm_le_pow_iff_norm_lt_pow_add_one (x : \u2124_[p]) (n : \u2124) :\n    \u2016x\u2016 \u2264 (p : \u211d) ^ n \u2194 \u2016x\u2016 < (p : \u211d) ^ (n + 1)", "start": [554, 1], "end": [556, 69], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_lt_pow_iff_norm_le_pow_sub_one", "code": "theorem norm_lt_pow_iff_norm_le_pow_sub_one (x : \u2124_[p]) (n : \u2124) :\n    \u2016x\u2016 < (p : \u211d) ^ n \u2194 \u2016x\u2016 \u2264 (p : \u211d) ^ (n - 1)", "start": [559, 1], "end": [561, 59], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_lt_one_iff_dvd", "code": "theorem norm_lt_one_iff_dvd (x : \u2124_[p]) : \u2016x\u2016 < 1 \u2194 \u2191p \u2223 x", "start": [564, 1], "end": [568, 80], "kind": "commanddeclaration"}, {"full_name": "PadicInt.pow_p_dvd_int_iff", "code": "@[simp]\ntheorem pow_p_dvd_int_iff (n : \u2115) (a : \u2124) : (p : \u2124_[p]) ^ n \u2223 a \u2194 (p ^ n : \u2124) \u2223 a", "start": [571, 1], "end": [574, 44], "kind": "commanddeclaration"}, {"full_name": "PadicInt.p_nonnunit", "code": "theorem p_nonnunit : (p : \u2124_[p]) \u2208 nonunits \u2124_[p]", "start": [587, 1], "end": [589, 41], "kind": "commanddeclaration"}, {"full_name": "PadicInt.maximalIdeal_eq_span_p", "code": "theorem maximalIdeal_eq_span_p : maximalIdeal \u2124_[p] = Ideal.span {(p : \u2124_[p])}", "start": [592, 1], "end": [598, 21], "kind": "commanddeclaration"}, {"full_name": "PadicInt.prime_p", "code": "theorem prime_p : Prime (p : \u2124_[p])", "start": [601, 1], "end": [604, 32], "kind": "commanddeclaration"}, {"full_name": "PadicInt.irreducible_p", "code": "theorem irreducible_p : Irreducible (p : \u2124_[p])", "start": [607, 1], "end": [607, 77], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ideal_eq_span_pow_p", "code": "theorem ideal_eq_span_pow_p {s : Ideal \u2124_[p]} (hs : s \u2260 \u22a5) :\n    \u2203 n : \u2115, s = Ideal.span {(p : \u2124_[p]) ^ n}", "start": [615, 1], "end": [617, 71], "kind": "commanddeclaration"}, {"full_name": "PadicInt.algebra", "code": "instance algebra : Algebra \u2124_[p] \u211a_[p] :=\n  Algebra.ofSubring (subring p)", "start": [650, 1], "end": [651, 32], "kind": "commanddeclaration"}, {"full_name": "PadicInt.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (x : \u2124_[p]) : algebraMap \u2124_[p] \u211a_[p] x = x", "start": [654, 1], "end": [656, 6], "kind": "commanddeclaration"}, {"full_name": "PadicInt.isFractionRing", "code": "instance isFractionRing : IsFractionRing \u2124_[p] \u211a_[p] where\n  map_units' := fun \u27e8x, hx\u27e9 => by\n    rwa [algebraMap_apply, isUnit_iff_ne_zero, PadicInt.coe_ne_zero, \u2190\n      mem_nonZeroDivisors_iff_ne_zero]\n  surj' x := by\n    by_cases hx : \u2016x\u2016 \u2264 1\n    \u00b7 use (\u27e8x, hx\u27e9, 1)\n      rw [Submonoid.coe_one, map_one, mul_one, PadicInt.algebraMap_apply, Subtype.coe_mk]\n    \u00b7 set n := Int.toNat (-x.valuation) with hn\n      have hn_coe : (n : \u2124) = -x.valuation := by\n        rw [hn, Int.toNat_of_nonneg]\n        rw [Right.nonneg_neg_iff]\n        rw [Padic.norm_le_one_iff_val_nonneg, not_le] at hx\n        exact hx.le\n      set a := x * (p : \u211a_[p]) ^ n with ha\n      have ha_norm : \u2016a\u2016 = 1 := by\n        have hx : x \u2260 0 := by\n          intro h0\n          rw [h0, norm_zero] at hx\n          exact hx zero_le_one\n        rw [ha, padicNormE.mul, padicNormE.norm_p_pow, Padic.norm_eq_pow_val hx, \u2190 zpow_add',\n          hn_coe, neg_neg, add_left_neg, zpow_zero]\n        exact Or.inl (Nat.cast_ne_zero.mpr (NeZero.ne p))\n      use\n        (\u27e8a, le_of_eq ha_norm\u27e9,\n          \u27e8(p ^ n : \u2124_[p]), mem_nonZeroDivisors_iff_ne_zero.mpr (NeZero.ne _)\u27e9)\n      simp only [map_pow, map_natCast, algebraMap_apply, PadicInt.coe_pow, PadicInt.coe_nat_cast,\n        Subtype.coe_mk, Nat.cast_pow]\n  eq_iff_exists' := by\n    simp_rw [algebraMap_apply, Subtype.coe_inj]\n    refine \u27e8fun h => \u27e81, by rw [h]\u27e9, ?_\u27e9\n    rintro \u27e8\u27e8c, hc\u27e9, h\u27e9\n    exact (mul_eq_mul_left_iff.mp h).resolve_right (mem_nonZeroDivisors_iff_ne_zero.mp hc)", "start": [659, 1], "end": [691, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Metrizable.lean", "imports": ["Mathlib/Topology/Compactness/Paracompact.lean", "Mathlib/Topology/MetricSpace/Metrizable.lean", "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ManifoldWithCorners.metrizableSpace", "code": "theorem ManifoldWithCorners.metrizableSpace {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {H : Type*} [TopologicalSpace H] (I : ModelWithCorners \u211d E H)\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H M] [SigmaCompactSpace M] [T2Space M] :\n    MetrizableSpace M", "start": [22, 1], "end": [31, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/PartitionOfUnity.lean", "imports": ["Mathlib/Geometry/Manifold/Algebra/Structures.lean", "Mathlib/Geometry/Manifold/BumpFunction.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/MetricSpace/PartitionOfUnity.lean", "Mathlib/Topology/ShrinkingLemma.lean"], "premises": [{"full_name": "SmoothBumpCovering", "code": "structure SmoothBumpCovering (s : Set M := univ) where\n  \n  c : \u03b9 \u2192 M\n  \n  toFun : \u2200 i, SmoothBumpFunction I (c i)\n  \n  c_mem' : \u2200 i, c i \u2208 s\n  \n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  \n  eventuallyEq_one' : \u2200 x \u2208 s, \u2203 i, toFun i =\u1da0[\ud835\udcdd x] 1", "start": [93, 1], "end": [117, 54], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity", "code": "structure SmoothPartitionOfUnity (s : Set M := univ) where\n  \n  toFun : \u03b9 \u2192 C^\u221e\u27eeI, M; \ud835\udcd8(\u211d), \u211d\u27ef\n  \n  locallyFinite' : LocallyFinite fun i => support (toFun i)\n  \n  nonneg' : \u2200 i x, 0 \u2264 toFun i x\n  \n  sum_eq_one' : \u2200 x \u2208 s, \u2211\u1da0 i, toFun i x = 1\n  \n  sum_le_one' : \u2200 x, \u2211\u1da0 i, toFun i x \u2264 1", "start": [120, 1], "end": [136, 41], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.locallyFinite", "code": "protected theorem locallyFinite : LocallyFinite fun i => support (f i)", "start": [149, 1], "end": [150, 19], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.nonneg", "code": "theorem nonneg (i : \u03b9) (x : M) : 0 \u2264 f i x", "start": [153, 1], "end": [154, 16], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.sum_eq_one", "code": "theorem sum_eq_one {x} (hx : x \u2208 s) : \u2211\u1da0 i, f i x = 1", "start": [157, 1], "end": [158, 21], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.exists_pos_of_mem", "code": "theorem exists_pos_of_mem {x} (hx : x \u2208 s) : \u2203 i, 0 < f i x", "start": [161, 1], "end": [167, 8], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.sum_le_one", "code": "theorem sum_le_one (x : M) : \u2211\u1da0 i, f i x \u2264 1", "start": [169, 1], "end": [170, 18], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.toPartitionOfUnity", "code": "def toPartitionOfUnity : PartitionOfUnity \u03b9 M s :=\n  { f with toFun := fun i => f i }", "start": [173, 1], "end": [175, 35], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.smooth_sum", "code": "theorem smooth_sum : Smooth I \ud835\udcd8(\u211d) fun x => \u2211\u1da0 i, f i x", "start": [178, 1], "end": [179, 56], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.le_one", "code": "theorem le_one (i : \u03b9) (x : M) : f i x \u2264 1", "start": [182, 1], "end": [183, 34], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.sum_nonneg", "code": "theorem sum_nonneg (x : M) : 0 \u2264 \u2211\u1da0 i, f i x", "start": [186, 1], "end": [187, 36], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.contMDiff_smul", "code": "theorem contMDiff_smul {g : M \u2192 F} {i} (hg : \u2200 x \u2208 tsupport (f i), ContMDiffAt I \ud835\udcd8(\u211d, F) n g x) :\n    ContMDiff I \ud835\udcd8(\u211d, F) n fun x => f i x \u2022 g x", "start": [190, 1], "end": [193, 96], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.smooth_smul", "code": "theorem smooth_smul {g : M \u2192 F} {i} (hg : \u2200 x \u2208 tsupport (f i), SmoothAt I \ud835\udcd8(\u211d, F) g x) :\n    Smooth I \ud835\udcd8(\u211d, F) fun x => f i x \u2022 g x", "start": [196, 1], "end": [198, 22], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.contMDiff_finsum_smul", "code": "theorem contMDiff_finsum_smul {g : \u03b9 \u2192 M \u2192 F}\n    (hg : \u2200 (i), \u2200 x \u2208 tsupport (f i), ContMDiffAt I \ud835\udcd8(\u211d, F) n (g i) x) :\n    ContMDiff I \ud835\udcd8(\u211d, F) n fun x => \u2211\u1da0 i, f i x \u2022 g i x", "start": [201, 1], "end": [208, 65], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.smooth_finsum_smul", "code": "theorem smooth_finsum_smul {g : \u03b9 \u2192 M \u2192 F}\n    (hg : \u2200 (i), \u2200 x \u2208 tsupport (f i), SmoothAt I \ud835\udcd8(\u211d, F) (g i) x) :\n    Smooth I \ud835\udcd8(\u211d, F) fun x => \u2211\u1da0 i, f i x \u2022 g i x", "start": [211, 1], "end": [217, 29], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.finsum_smul_mem_convex", "code": "theorem finsum_smul_mem_convex {g : \u03b9 \u2192 M \u2192 F} {t : Set F} {x : M} (hx : x \u2208 s)\n    (hg : \u2200 i, f i x \u2260 0 \u2192 g i x \u2208 t) (ht : Convex \u211d t) : \u2211\u1da0 i, f i x \u2022 g i x \u2208 t", "start": [220, 1], "end": [222, 61], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.IsSubordinate", "code": "def IsSubordinate (f : SmoothPartitionOfUnity \u03b9 I M s) (U : \u03b9 \u2192 Set M) :=\n  \u2200 i, tsupport (f i) \u2286 U i", "start": [225, 1], "end": [228, 28], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.isSubordinate_toPartitionOfUnity", "code": "@[simp]\ntheorem isSubordinate_toPartitionOfUnity :\n    f.toPartitionOfUnity.IsSubordinate U \u2194 f.IsSubordinate U", "start": [233, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.IsSubordinate.toPartitionOfUnity", "code": "alias \u27e8_, IsSubordinate.toPartitionOfUnity\u27e9 := isSubordinate_toPartitionOfUnity", "start": [239, 1], "end": [239, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SmoothPartitionOfUnity.IsSubordinate.contMDiff_finsum_smul", "code": "theorem IsSubordinate.contMDiff_finsum_smul {g : \u03b9 \u2192 M \u2192 F} (hf : f.IsSubordinate U)\n    (ho : \u2200 i, IsOpen (U i)) (hg : \u2200 i, ContMDiffOn I \ud835\udcd8(\u211d, F) n (g i) (U i)) :\n    ContMDiff I \ud835\udcd8(\u211d, F) n fun x => \u2211\u1da0 i, f i x \u2022 g i x", "start": [242, 1], "end": [248, 88], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.IsSubordinate.smooth_finsum_smul", "code": "theorem IsSubordinate.smooth_finsum_smul {g : \u03b9 \u2192 M \u2192 F} (hf : f.IsSubordinate U)\n    (ho : \u2200 i, IsOpen (U i)) (hg : \u2200 i, SmoothOn I \ud835\udcd8(\u211d, F) (g i) (U i)) :\n    Smooth I \ud835\udcd8(\u211d, F) fun x => \u2211\u1da0 i, f i x \u2022 g i x", "start": [251, 1], "end": [257, 33], "kind": "commanddeclaration"}, {"full_name": "BumpCovering.smooth_toPartitionOfUnity", "code": "theorem smooth_toPartitionOfUnity {E : Type uE} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    {H : Type uH} [TopologicalSpace H] {I : ModelWithCorners \u211d E H} {M : Type uM}\n    [TopologicalSpace M] [ChartedSpace H M] {s : Set M} (f : BumpCovering \u03b9 M s)\n    (hf : \u2200 i, Smooth I \ud835\udcd8(\u211d) (f i)) (i : \u03b9) : Smooth I \ud835\udcd8(\u211d) (f.toPartitionOfUnity i)", "start": [265, 1], "end": [271, 26], "kind": "commanddeclaration"}, {"full_name": "BumpCovering.toSmoothPartitionOfUnity", "code": "def toSmoothPartitionOfUnity (f : BumpCovering \u03b9 M s) (hf : \u2200 i, Smooth I \ud835\udcd8(\u211d) (f i)) :\n    SmoothPartitionOfUnity \u03b9 I M s :=\n  { f.toPartitionOfUnity with\n    toFun := fun i => \u27e8f.toPartitionOfUnity i, f.smooth_toPartitionOfUnity hf i\u27e9 }", "start": [276, 1], "end": [286, 83], "kind": "commanddeclaration"}, {"full_name": "BumpCovering.toSmoothPartitionOfUnity_toPartitionOfUnity", "code": "@[simp]\ntheorem toSmoothPartitionOfUnity_toPartitionOfUnity (f : BumpCovering \u03b9 M s)\n    (hf : \u2200 i, Smooth I \ud835\udcd8(\u211d) (f i)) :\n    (f.toSmoothPartitionOfUnity hf).toPartitionOfUnity = f.toPartitionOfUnity", "start": [289, 1], "end": [293, 6], "kind": "commanddeclaration"}, {"full_name": "BumpCovering.coe_toSmoothPartitionOfUnity", "code": "@[simp]\ntheorem coe_toSmoothPartitionOfUnity (f : BumpCovering \u03b9 M s) (hf : \u2200 i, Smooth I \ud835\udcd8(\u211d) (f i))\n    (i : \u03b9) : \u21d1(f.toSmoothPartitionOfUnity hf i) = f.toPartitionOfUnity i", "start": [296, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "BumpCovering.IsSubordinate.toSmoothPartitionOfUnity", "code": "theorem IsSubordinate.toSmoothPartitionOfUnity {f : BumpCovering \u03b9 M s} {U : \u03b9 \u2192 Set M}\n    (h : f.IsSubordinate U) (hf : \u2200 i, Smooth I \ud835\udcd8(\u211d) (f i)) :\n    (f.toSmoothPartitionOfUnity hf).IsSubordinate U", "start": [302, 1], "end": [305, 23], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.IsSubordinate", "code": "def IsSubordinate {s : Set M} (f : SmoothBumpCovering \u03b9 I M s) (U : M \u2192 Set M) :=\n  \u2200 i, tsupport (f i) \u2286 U (f.c i)", "start": [319, 1], "end": [326, 34], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.IsSubordinate.support_subset", "code": "theorem IsSubordinate.support_subset {fs : SmoothBumpCovering \u03b9 I M s} {U : M \u2192 Set M}\n    (h : fs.IsSubordinate U) (i : \u03b9) : support (fs i) \u2286 U (fs.c i)", "start": [329, 1], "end": [331, 36], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.exists_isSubordinate", "code": "theorem exists_isSubordinate [T2Space M] [SigmaCompactSpace M] (hs : IsClosed s)\n    (hU : \u2200 x \u2208 s, U x \u2208 \ud835\udcdd x) :\n    \u2203 (\u03b9 : Type uM) (f : SmoothBumpCovering \u03b9 I M s), f.IsSubordinate U", "start": [336, 1], "end": [360, 76], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.locallyFinite", "code": "protected theorem locallyFinite : LocallyFinite fun i => support (fs i)", "start": [365, 1], "end": [366, 20], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.point_finite", "code": "protected theorem point_finite (x : M) : {i | fs i x \u2260 0}.Finite", "start": [369, 1], "end": [370, 34], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.mem_chartAt_source_of_eq_one", "code": "theorem mem_chartAt_source_of_eq_one {i : \u03b9} {x : M} (h : fs i x = 1) :\n    x \u2208 (chartAt H (fs.c i)).source", "start": [373, 1], "end": [375, 46], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.mem_extChartAt_source_of_eq_one", "code": "theorem mem_extChartAt_source_of_eq_one {i : \u03b9} {x : M} (h : fs i x = 1) :\n    x \u2208 (extChartAt I (fs.c i)).source", "start": [378, 1], "end": [380, 66], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.ind", "code": "def ind (x : M) (hx : x \u2208 s) : \u03b9 :=\n  (fs.eventuallyEq_one' x hx).choose", "start": [383, 1], "end": [385, 37], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.eventuallyEq_one", "code": "theorem eventuallyEq_one (x : M) (hx : x \u2208 s) : fs (fs.ind x hx) =\u1da0[\ud835\udcdd x] 1", "start": [388, 1], "end": [389, 42], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.apply_ind", "code": "theorem apply_ind (x : M) (hx : x \u2208 s) : fs (fs.ind x hx) x = 1", "start": [392, 1], "end": [393, 40], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.mem_support_ind", "code": "theorem mem_support_ind (x : M) (hx : x \u2208 s) : x \u2208 support (fs <| fs.ind x hx)", "start": [396, 1], "end": [397, 27], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.mem_chartAt_ind_source", "code": "theorem mem_chartAt_ind_source (x : M) (hx : x \u2208 s) : x \u2208 (chartAt H (fs.c (fs.ind x hx))).source", "start": [400, 1], "end": [401, 54], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.mem_extChartAt_ind_source", "code": "theorem mem_extChartAt_ind_source (x : M) (hx : x \u2208 s) :\n    x \u2208 (extChartAt I (fs.c (fs.ind x hx))).source", "start": [404, 1], "end": [406, 57], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.fintype", "code": "protected def fintype [CompactSpace M] : Fintype \u03b9 :=\n  fs.locallyFinite.fintypeOfCompact fun i => (fs i).nonempty_support", "start": [409, 1], "end": [411, 69], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.toBumpCovering", "code": "def toBumpCovering : BumpCovering \u03b9 M s where\n  toFun i := \u27e8fs i, (fs i).continuous\u27e9\n  locallyFinite' := fs.locallyFinite\n  nonneg' i _ := (fs i).nonneg\n  le_one' i _ := (fs i).le_one\n  eventuallyEq_one' := fs.eventuallyEq_one'", "start": [416, 1], "end": [423, 44], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.isSubordinate_toBumpCovering", "code": "@[simp, nolint simpNF]\ntheorem isSubordinate_toBumpCovering {f : SmoothBumpCovering \u03b9 I M s} {U : M \u2192 Set M} :\n    (f.toBumpCovering.IsSubordinate fun i => U (f.c i)) \u2194 f.IsSubordinate U", "start": [427, 1], "end": [430, 10], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.IsSubordinate.toBumpCovering", "code": "alias \u27e8_, IsSubordinate.toBumpCovering\u27e9 := isSubordinate_toBumpCovering", "start": [433, 1], "end": [433, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SmoothBumpCovering.toSmoothPartitionOfUnity", "code": "def toSmoothPartitionOfUnity : SmoothPartitionOfUnity \u03b9 I M s :=\n  fs.toBumpCovering.toSmoothPartitionOfUnity fun i => (fs i).smooth", "start": [436, 1], "end": [438, 68], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.toSmoothPartitionOfUnity_apply", "code": "theorem toSmoothPartitionOfUnity_apply (i : \u03b9) (x : M) :\n    fs.toSmoothPartitionOfUnity i x = fs i x * \u220f\u1da0 (j) (_ : WellOrderingRel j i), (1 - fs j x)", "start": [441, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.toSmoothPartitionOfUnity_eq_mul_prod", "code": "theorem toSmoothPartitionOfUnity_eq_mul_prod (i : \u03b9) (x : M) (t : Finset \u03b9)\n    (ht : \u2200 j, WellOrderingRel j i \u2192 fs j x \u2260 0 \u2192 j \u2208 t) :\n    fs.toSmoothPartitionOfUnity i x =\n      fs i x * \u220f j in t.filter fun j => WellOrderingRel j i, (1 - fs j x)", "start": [446, 1], "end": [450, 60], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.exists_finset_toSmoothPartitionOfUnity_eventuallyEq", "code": "theorem exists_finset_toSmoothPartitionOfUnity_eventuallyEq (i : \u03b9) (x : M) :\n    \u2203 t : Finset \u03b9,\n      fs.toSmoothPartitionOfUnity i =\u1da0[\ud835\udcdd x]\n        fs i * \u220f j in t.filter fun j => WellOrderingRel j i, ((1 : M \u2192 \u211d) - fs j)", "start": [453, 1], "end": [458, 82], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.toSmoothPartitionOfUnity_zero_of_zero", "code": "theorem toSmoothPartitionOfUnity_zero_of_zero {i : \u03b9} {x : M} (h : fs i x = 0) :\n    fs.toSmoothPartitionOfUnity i x = 0", "start": [461, 1], "end": [463, 54], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.support_toSmoothPartitionOfUnity_subset", "code": "theorem support_toSmoothPartitionOfUnity_subset (i : \u03b9) :\n    support (fs.toSmoothPartitionOfUnity i) \u2286 support (fs i)", "start": [466, 1], "end": [468, 56], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.IsSubordinate.toSmoothPartitionOfUnity", "code": "theorem IsSubordinate.toSmoothPartitionOfUnity {f : SmoothBumpCovering \u03b9 I M s} {U : M \u2192 Set M}\n    (h : f.IsSubordinate U) : f.toSmoothPartitionOfUnity.IsSubordinate fun i => U (f.c i)", "start": [471, 1], "end": [473, 38], "kind": "commanddeclaration"}, {"full_name": "SmoothBumpCovering.sum_toSmoothPartitionOfUnity_eq", "code": "theorem sum_toSmoothPartitionOfUnity_eq (x : M) :\n    \u2211\u1da0 i, fs.toSmoothPartitionOfUnity i x = 1 - \u220f\u1da0 i, (1 - fs i x)", "start": [476, 1], "end": [478, 48], "kind": "commanddeclaration"}, {"full_name": "exists_smooth_zero_one_of_closed", "code": "theorem exists_smooth_zero_one_of_closed [T2Space M] [SigmaCompactSpace M] {s t : Set M}\n    (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    \u2203 f : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d), \u211d\u27ef, EqOn f 0 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1", "start": [485, 1], "end": [500, 70], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.single", "code": "def single (i : \u03b9) (s : Set M) : SmoothPartitionOfUnity \u03b9 I M s :=\n  (BumpCovering.single i s).toSmoothPartitionOfUnity fun j => by\n    rcases eq_or_ne j i with (rfl | h)\n    \u00b7 simp only [smooth_one, ContinuousMap.coe_one, BumpCovering.coe_single, Pi.single_eq_same]\n    \u00b7 simp only [smooth_zero, BumpCovering.coe_single, Pi.single_eq_of_ne h, ContinuousMap.coe_zero]", "start": [505, 1], "end": [511, 101], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.exists_isSubordinate", "code": "theorem exists_isSubordinate {s : Set M} (hs : IsClosed s) (U : \u03b9 \u2192 Set M) (ho : \u2200 i, IsOpen (U i))\n    (hU : s \u2286 \u22c3 i, U i) : \u2203 f : SmoothPartitionOfUnity \u03b9 I M s, f.IsSubordinate U", "start": [519, 1], "end": [532, 28], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.exists_isSubordinate_chartAt_source_of_isClosed", "code": "theorem exists_isSubordinate_chartAt_source_of_isClosed {s : Set M} (hs : IsClosed s) :\n    \u2203 f : SmoothPartitionOfUnity s I M s,\n      f.IsSubordinate (fun x \u21a6 (chartAt H (x : M)).source)", "start": [535, 1], "end": [539, 57], "kind": "commanddeclaration"}, {"full_name": "SmoothPartitionOfUnity.exists_isSubordinate_chartAt_source", "code": "theorem exists_isSubordinate_chartAt_source :\n    \u2203 f : SmoothPartitionOfUnity M I M univ, f.IsSubordinate (fun x \u21a6 (chartAt H x).source)", "start": [542, 1], "end": [545, 51], "kind": "commanddeclaration"}, {"full_name": "exists_contMDiffOn_forall_mem_convex_of_local", "code": "theorem exists_contMDiffOn_forall_mem_convex_of_local (ht : \u2200 x, Convex \u211d (t x))\n    (Hloc : \u2200 x : M, \u2203 U \u2208 \ud835\udcdd x, \u2203 g : M \u2192 F, ContMDiffOn I \ud835\udcd8(\u211d, F) n g U \u2227 \u2200 y \u2208 U, g y \u2208 t y) :\n    \u2203 g : C^n\u27eeI, M; \ud835\udcd8(\u211d, F), F\u27ef, \u2200 x, g x \u2208 t x", "start": [551, 1], "end": [567, 52], "kind": "commanddeclaration"}, {"full_name": "exists_smooth_forall_mem_convex_of_local", "code": "theorem exists_smooth_forall_mem_convex_of_local (ht : \u2200 x, Convex \u211d (t x))\n    (Hloc : \u2200 x : M, \u2203 U \u2208 \ud835\udcdd x, \u2203 g : M \u2192 F, SmoothOn I \ud835\udcd8(\u211d, F) g U \u2227 \u2200 y \u2208 U, g y \u2208 t y) :\n    \u2203 g : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, F), F\u27ef, \u2200 x, g x \u2208 t x", "start": [570, 1], "end": [579, 58], "kind": "commanddeclaration"}, {"full_name": "exists_smooth_forall_mem_convex_of_local_const", "code": "theorem exists_smooth_forall_mem_convex_of_local_const (ht : \u2200 x, Convex \u211d (t x))\n    (Hloc : \u2200 x : M, \u2203 c : F, \u2200\u1da0 y in \ud835\udcdd x, c \u2208 t y) : \u2203 g : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, F), F\u27ef, \u2200 x, g x \u2208 t x", "start": [582, 1], "end": [591, 53], "kind": "commanddeclaration"}, {"full_name": "Emetric.exists_smooth_forall_closedBall_subset", "code": "theorem Emetric.exists_smooth_forall_closedBall_subset {M} [EMetricSpace M] [ChartedSpace H M]\n    [SmoothManifoldWithCorners I M] [SigmaCompactSpace M] {K : \u03b9 \u2192 Set M} {U : \u03b9 \u2192 Set M}\n    (hK : \u2200 i, IsClosed (K i)) (hU : \u2200 i, IsOpen (U i)) (hKU : \u2200 i, K i \u2286 U i)\n    (hfin : LocallyFinite K) :\n    \u2203 \u03b4 : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef,\n      (\u2200 x, 0 < \u03b4 x) \u2227 \u2200 (i), \u2200 x \u2208 K i, EMetric.closedBall x (ENNReal.ofReal (\u03b4 x)) \u2286 U i", "start": [594, 1], "end": [607, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_smooth_forall_closedBall_subset", "code": "theorem Metric.exists_smooth_forall_closedBall_subset {M} [MetricSpace M] [ChartedSpace H M]\n    [SmoothManifoldWithCorners I M] [SigmaCompactSpace M] {K : \u03b9 \u2192 Set M} {U : \u03b9 \u2192 Set M}\n    (hK : \u2200 i, IsClosed (K i)) (hU : \u2200 i, IsOpen (U i)) (hKU : \u2200 i, K i \u2286 U i)\n    (hfin : LocallyFinite K) :\n    \u2203 \u03b4 : C^\u221e\u27eeI, M; \ud835\udcd8(\u211d, \u211d), \u211d\u27ef,\n      (\u2200 x, 0 < \u03b4 x) \u2227 \u2200 (i), \u2200 x \u2208 K i, Metric.closedBall x (\u03b4 x) \u2286 U i", "start": [610, 1], "end": [623, 18], "kind": "commanddeclaration"}, {"full_name": "IsOpen.exists_msmooth_support_eq_aux", "code": "lemma IsOpen.exists_msmooth_support_eq_aux {s : Set H} (hs : IsOpen s) :\n    \u2203 f : H \u2192 \u211d, f.support = s \u2227 Smooth I \ud835\udcd8(\u211d) f \u2227 Set.range f \u2286 Set.Icc 0 1 := by\n  have h's : IsOpen (I.symm \u207b\u00b9' s) := I.continuous_symm.isOpen_preimage _ hs\n  rcases h's.exists_smooth_support_eq with \u27e8f, f_supp, f_diff, f_range\u27e9\n  refine \u27e8f \u2218 I, ?_, ?_, ?_\u27e9\n  \u00b7 rw [support_comp_eq_preimage, f_supp, \u2190 preimage_comp]\n    simp only [ModelWithCorners.symm_comp_self, preimage_id_eq, id_eq]\n  \u00b7 exact f_diff.comp_contMDiff contMDiff_model\n  \u00b7 exact Subset.trans (range_comp_subset_range _ _) f_range", "start": [626, 1], "end": [634, 61], "kind": "mathlibtacticlemma"}, {"full_name": "IsOpen.exists_msmooth_support_eq", "code": "theorem IsOpen.exists_msmooth_support_eq (hs : IsOpen s) :\n    \u2203 f : M \u2192 \u211d, f.support = s \u2227 Smooth I \ud835\udcd8(\u211d) f \u2227 \u2200 x, 0 \u2264 f x", "start": [636, 1], "end": [683, 43], "kind": "commanddeclaration"}, {"full_name": "exists_msmooth_support_eq_eq_one_iff", "code": "theorem exists_msmooth_support_eq_eq_one_iff\n    {s t : Set M} (hs : IsOpen s) (ht : IsClosed t) (h : t \u2286 s) :\n    \u2203 f : M \u2192 \u211d, Smooth I \ud835\udcd8(\u211d) f \u2227 range f \u2286 Icc 0 1 \u2227 support f = s\n      \u2227 (\u2200 x, x \u2208 t \u2194 f x = 1)", "start": [685, 1], "end": [720, 82], "kind": "commanddeclaration"}, {"full_name": "exists_msmooth_zero_iff_one_iff_of_closed", "code": "theorem exists_msmooth_zero_iff_one_iff_of_closed {s t : Set M}\n    (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    \u2203 f : M \u2192 \u211d, Smooth I \ud835\udcd8(\u211d) f \u2227 range f \u2286 Icc 0 1 \u2227 (\u2200 x, x \u2208 s \u2194 f x = 0)\n      \u2227 (\u2200 x, x \u2208 t \u2194 f x = 1)", "start": [722, 1], "end": [732, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "imports": ["Mathlib/Analysis/Calculus/Deriv/Slope.lean", "Mathlib/Analysis/Calculus/Deriv/Comp.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Calculus/Deriv/Mul.lean"], "premises": [{"full_name": "HasLineDerivWithinAt", "code": "def HasLineDerivWithinAt (f : E \u2192 F) (f' : F) (s : Set E) (x : E) (v : E) :=\n  HasDerivWithinAt (fun t \u21a6 f (x + t \u2022 v)) f' ((fun t \u21a6 x + t \u2022 v) \u207b\u00b9' s) (0 : \ud835\udd5c)", "start": [65, 1], "end": [70, 82], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt", "code": "def HasLineDerivAt (f : E \u2192 F) (f' : F) (x : E) (v : E) :=\n  HasDerivAt (fun t \u21a6 f (x + t \u2022 v)) f' (0 : \ud835\udd5c)", "start": [72, 1], "end": [77, 48], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt", "code": "def LineDifferentiableWithinAt (f : E \u2192 F) (s : Set E) (x : E) (v : E) : Prop :=\n  DifferentiableWithinAt \ud835\udd5c (fun t \u21a6 f (x + t \u2022 v)) ((fun t \u21a6 x + t \u2022 v) \u207b\u00b9' s) (0 : \ud835\udd5c)", "start": [79, 1], "end": [83, 87], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt", "code": "def LineDifferentiableAt (f : E \u2192 F) (x : E) (v : E) : Prop :=\n  DifferentiableAt \ud835\udd5c (fun t \u21a6 f (x + t \u2022 v)) (0 : \ud835\udd5c)", "start": [85, 1], "end": [88, 53], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin", "code": "def lineDerivWithin (f : E \u2192 F) (s : Set E) (x : E) (v : E) : F :=\n  derivWithin (fun t \u21a6 f (x + t \u2022 v)) ((fun t \u21a6 x + t \u2022 v) \u207b\u00b9' s) (0 : \ud835\udd5c)", "start": [90, 1], "end": [97, 74], "kind": "commanddeclaration"}, {"full_name": "lineDeriv", "code": "def lineDeriv (f : E \u2192 F) (x : E) (v : E) : F :=\n  deriv (fun t \u21a6 f (x + t \u2022 v)) (0 : \ud835\udd5c)", "start": [99, 1], "end": [105, 40], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.mono", "code": "lemma HasLineDerivWithinAt.mono (hf : HasLineDerivWithinAt \ud835\udd5c f f' s x v) (hst : t \u2286 s) :\n    HasLineDerivWithinAt \ud835\udd5c f f' t x v :=\n  HasDerivWithinAt.mono hf (preimage_mono hst)", "start": [110, 1], "end": [112, 47], "kind": "mathlibtacticlemma"}, {"full_name": "HasLineDerivAt.hasLineDerivWithinAt", "code": "lemma HasLineDerivAt.hasLineDerivWithinAt (hf : HasLineDerivAt \ud835\udd5c f f' x v) (s : Set E) :\n    HasLineDerivWithinAt \ud835\udd5c f f' s x v :=\n  HasDerivAt.hasDerivWithinAt hf", "start": [114, 1], "end": [116, 33], "kind": "mathlibtacticlemma"}, {"full_name": "HasLineDerivWithinAt.lineDifferentiableWithinAt", "code": "lemma HasLineDerivWithinAt.lineDifferentiableWithinAt (hf : HasLineDerivWithinAt \ud835\udd5c f f' s x v) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x v :=\n  HasDerivWithinAt.differentiableWithinAt hf", "start": [118, 1], "end": [120, 45], "kind": "mathlibtacticlemma"}, {"full_name": "HasLineDerivAt.lineDifferentiableAt", "code": "theorem HasLineDerivAt.lineDifferentiableAt (hf : HasLineDerivAt \ud835\udd5c f f' x v) :\n    LineDifferentiableAt \ud835\udd5c f x v", "start": [122, 1], "end": [124, 33], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.hasLineDerivWithinAt", "code": "theorem LineDifferentiableWithinAt.hasLineDerivWithinAt (h : LineDifferentiableWithinAt \ud835\udd5c f s x v) :\n    HasLineDerivWithinAt \ud835\udd5c f (lineDerivWithin \ud835\udd5c f s x v) s x v", "start": [126, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt.hasLineDerivAt", "code": "theorem LineDifferentiableAt.hasLineDerivAt (h : LineDifferentiableAt \ud835\udd5c f x v) :\n    HasLineDerivAt \ud835\udd5c f (lineDeriv \ud835\udd5c f x v) x v", "start": [130, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivWithinAt_univ", "code": "@[simp] lemma hasLineDerivWithinAt_univ :\n    HasLineDerivWithinAt \ud835\udd5c f f' univ x v \u2194 HasLineDerivAt \ud835\udd5c f f' x v := by\n  simp only [HasLineDerivWithinAt, HasLineDerivAt, preimage_univ, hasDerivWithinAt_univ]", "start": [134, 1], "end": [136, 89], "kind": "mathlibtacticlemma"}, {"full_name": "lineDerivWithin_zero_of_not_lineDifferentiableWithinAt", "code": "theorem lineDerivWithin_zero_of_not_lineDifferentiableWithinAt\n    (h : \u00acLineDifferentiableWithinAt \ud835\udd5c f s x v) :\n    lineDerivWithin \ud835\udd5c f s x v = 0", "start": [138, 1], "end": [141, 51], "kind": "commanddeclaration"}, {"full_name": "lineDeriv_zero_of_not_lineDifferentiableAt", "code": "theorem lineDeriv_zero_of_not_lineDifferentiableAt (h : \u00acLineDifferentiableAt \ud835\udd5c f x v) :\n    lineDeriv \ud835\udd5c f x v = 0", "start": [143, 1], "end": [145, 39], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivAt_iff_isLittleO_nhds_zero", "code": "theorem hasLineDerivAt_iff_isLittleO_nhds_zero :\n    HasLineDerivAt \ud835\udd5c f f' x v \u2194\n      (fun t : \ud835\udd5c => f (x + t \u2022 v) - f x - t \u2022 f') =o[\ud835\udcdd 0] fun t => t", "start": [147, 1], "end": [150, 96], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.unique", "code": "theorem HasLineDerivAt.unique (h\u2080 : HasLineDerivAt \ud835\udd5c f f\u2080' x v) (h\u2081 : HasLineDerivAt \ud835\udd5c f f\u2081' x v) :\n    f\u2080' = f\u2081'", "start": [152, 1], "end": [154, 26], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.lineDeriv", "code": "protected theorem HasLineDerivAt.lineDeriv (h : HasLineDerivAt \ud835\udd5c f f' x v) :\n    lineDeriv \ud835\udd5c f x v = f'", "start": [156, 1], "end": [158, 54], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableWithinAt_univ", "code": "theorem lineDifferentiableWithinAt_univ :\n    LineDifferentiableWithinAt \ud835\udd5c f univ x v \u2194 LineDifferentiableAt \ud835\udd5c f x v", "start": [160, 1], "end": [163, 33], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt.lineDifferentiableWithinAt", "code": "theorem LineDifferentiableAt.lineDifferentiableWithinAt (h : LineDifferentiableAt \ud835\udd5c f x v) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x v", "start": [165, 1], "end": [167, 57], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_univ", "code": "@[simp]\ntheorem lineDerivWithin_univ : lineDerivWithin \ud835\udd5c f univ x v = lineDeriv \ud835\udd5c f x v", "start": [169, 1], "end": [171, 36], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.mono", "code": "theorem LineDifferentiableWithinAt.mono (h : LineDifferentiableWithinAt \ud835\udd5c f t x v) (st : s \u2286 t) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x v", "start": [173, 1], "end": [175, 62], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.congr_mono", "code": "theorem HasLineDerivWithinAt.congr_mono (h : HasLineDerivWithinAt \ud835\udd5c f f' s x v) (ht : EqOn f\u2081 f t)\n    (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) : HasLineDerivWithinAt \ud835\udd5c f\u2081 f' t x v", "start": [177, 1], "end": [179, 90], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.congr", "code": "theorem HasLineDerivWithinAt.congr (h : HasLineDerivWithinAt \ud835\udd5c f f' s x v) (hs : EqOn f\u2081 f s)\n    (hx : f\u2081 x = f x) : HasLineDerivWithinAt \ud835\udd5c f\u2081 f' s x v", "start": [181, 1], "end": [183, 37], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.congr'", "code": "theorem HasLineDerivWithinAt.congr' (h : HasLineDerivWithinAt \ud835\udd5c f f' s x v)\n    (hs : EqOn f\u2081 f s) (hx : x \u2208 s) :\n    HasLineDerivWithinAt \ud835\udd5c f\u2081 f' s x v", "start": [185, 1], "end": [188, 21], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.congr_mono", "code": "theorem LineDifferentiableWithinAt.congr_mono (h : LineDifferentiableWithinAt \ud835\udd5c f s x v)\n    (ht : EqOn f\u2081 f t) (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) :\n    LineDifferentiableWithinAt \ud835\udd5c f\u2081 t x v", "start": [190, 1], "end": [193, 91], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.congr", "code": "theorem LineDifferentiableWithinAt.congr (h : LineDifferentiableWithinAt \ud835\udd5c f s x v)\n    (ht : \u2200 x \u2208 s, f\u2081 x = f x) (hx : f\u2081 x = f x) :\n    LineDifferentiableWithinAt \ud835\udd5c f\u2081 s x v", "start": [195, 1], "end": [198, 64], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_congr", "code": "theorem lineDerivWithin_congr (hs : EqOn f\u2081 f s) (hx : f\u2081 x = f x) :\n    lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v", "start": [200, 1], "end": [202, 59], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_congr'", "code": "theorem lineDerivWithin_congr' (hs : EqOn f\u2081 f s) (hx : x \u2208 s) :\n    lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v", "start": [204, 1], "end": [206, 35], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivAt_iff_tendsto_slope_zero", "code": "theorem hasLineDerivAt_iff_tendsto_slope_zero :\n    HasLineDerivAt \ud835\udd5c f f' x v \u2194\n      Tendsto (fun (t : \ud835\udd5c) \u21a6 t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd f')", "start": [208, 1], "end": [212, 25], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.tendsto_slope_zero", "code": "alias \u27e8HasLineDerivAt.tendsto_slope_zero, _\u27e9 := hasLineDerivAt_iff_tendsto_slope_zero", "start": [214, 1], "end": [214, 86], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasLineDerivAt.tendsto_slope_zero_right", "code": "theorem HasLineDerivAt.tendsto_slope_zero_right [PartialOrder \ud835\udd5c] (h : HasLineDerivAt \ud835\udd5c f f' x v) :\n    Tendsto (fun (t : \ud835\udd5c) \u21a6 t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) (\ud835\udcdd[>] 0) (\ud835\udcdd f')", "start": [216, 1], "end": [218, 60], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.tendsto_slope_zero_left", "code": "theorem HasLineDerivAt.tendsto_slope_zero_left [PartialOrder \ud835\udd5c] (h : HasLineDerivAt \ud835\udd5c f f' x v) :\n    Tendsto (fun (t : \ud835\udd5c) \u21a6 t\u207b\u00b9 \u2022 (f (x + t \u2022 v) - f x)) (\ud835\udcdd[<] 0) (\ud835\udcdd f')", "start": [220, 1], "end": [222, 59], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.mono_of_mem", "code": "theorem HasLineDerivWithinAt.mono_of_mem\n    (h : HasLineDerivWithinAt \ud835\udd5c f f' t x v) (hst : t \u2208 \ud835\udcdd[s] x) :\n    HasLineDerivWithinAt \ud835\udd5c f f' s x v", "start": [235, 1], "end": [240, 50], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.hasLineDerivAt", "code": "theorem HasLineDerivWithinAt.hasLineDerivAt\n    (h : HasLineDerivWithinAt \ud835\udd5c f f' s x v) (hs : s \u2208 \ud835\udcdd x) :\n    HasLineDerivAt \ud835\udd5c f f' x v", "start": [242, 1], "end": [247, 25], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.lineDifferentiableAt", "code": "theorem LineDifferentiableWithinAt.lineDifferentiableAt (h : LineDifferentiableWithinAt \ud835\udd5c f s x v)\n    (hs : s \u2208 \ud835\udcdd x) : LineDifferentiableAt \ud835\udd5c f x v", "start": [249, 1], "end": [251, 66], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.hasLineDerivWithinAt", "code": "lemma HasFDerivWithinAt.hasLineDerivWithinAt (hf : HasFDerivWithinAt f L s x) (v : E) :\n    HasLineDerivWithinAt \ud835\udd5c f (L v) s x v := by\n  let F := fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v\n  rw [show x = F (0 : \ud835\udd5c) by simp] at hf\n  have A : HasDerivWithinAt F (0 + (1 : \ud835\udd5c) \u2022 v) (F \u207b\u00b9' s) 0 :=\n    ((hasDerivAt_const (0 : \ud835\udd5c) x).add ((hasDerivAt_id' (0 : \ud835\udd5c)).smul_const v)).hasDerivWithinAt\n  simp only [one_smul, zero_add] at A\n  exact hf.comp_hasDerivWithinAt (x := (0 : \ud835\udd5c)) A (mapsTo_preimage F s)", "start": [253, 1], "end": [260, 72], "kind": "mathlibtacticlemma"}, {"full_name": "HasFDerivAt.hasLineDerivAt", "code": "lemma HasFDerivAt.hasLineDerivAt (hf : HasFDerivAt f L x) (v : E) :\n    HasLineDerivAt \ud835\udd5c f (L v) x v := by\n  rw [\u2190 hasLineDerivWithinAt_univ]\n  exact hf.hasFDerivWithinAt.hasLineDerivWithinAt v", "start": [262, 1], "end": [265, 52], "kind": "mathlibtacticlemma"}, {"full_name": "DifferentiableAt.lineDeriv_eq_fderiv", "code": "lemma DifferentiableAt.lineDeriv_eq_fderiv (hf : DifferentiableAt \ud835\udd5c f x) :\n    lineDeriv \ud835\udd5c f x v = fderiv \ud835\udd5c f x v :=\n  (hf.hasFDerivAt.hasLineDerivAt v).lineDeriv", "start": [267, 1], "end": [269, 46], "kind": "mathlibtacticlemma"}, {"full_name": "LineDifferentiableWithinAt.mono_of_mem", "code": "theorem LineDifferentiableWithinAt.mono_of_mem (h : LineDifferentiableWithinAt \ud835\udd5c f s x v)\n    (hst : s \u2208 \ud835\udcdd[t] x) : LineDifferentiableWithinAt \ud835\udd5c f t x v", "start": [271, 1], "end": [273, 70], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_of_mem_nhds", "code": "theorem lineDerivWithin_of_mem_nhds (h : s \u2208 \ud835\udcdd x) :\n    lineDerivWithin \ud835\udd5c f s x v = lineDeriv \ud835\udd5c f x v", "start": [275, 1], "end": [279, 13], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_of_open", "code": "theorem lineDerivWithin_of_open (hs : IsOpen s) (hx : x \u2208 s) :\n    lineDerivWithin \ud835\udd5c f s x v = lineDeriv \ud835\udd5c f x v", "start": [281, 1], "end": [283, 47], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivWithinAt_congr_set", "code": "theorem hasLineDerivWithinAt_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    HasLineDerivWithinAt \ud835\udd5c f f' s x v \u2194 HasLineDerivWithinAt \ud835\udd5c f f' t x v", "start": [285, 1], "end": [291, 33], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableWithinAt_congr_set", "code": "theorem lineDifferentiableWithinAt_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x v \u2194 LineDifferentiableWithinAt \ud835\udd5c f t x v", "start": [293, 1], "end": [298, 57], "kind": "commanddeclaration"}, {"full_name": "lineDerivWithin_congr_set", "code": "theorem lineDerivWithin_congr_set (h : s =\u1da0[\ud835\udcdd x] t) :\n    lineDerivWithin \ud835\udd5c f s x v = lineDerivWithin \ud835\udd5c f t x v", "start": [300, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasLineDerivAt_iff", "code": "theorem Filter.EventuallyEq.hasLineDerivAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081) :\n    HasLineDerivAt \ud835\udd5c f\u2080 f' x v \u2194 HasLineDerivAt \ud835\udd5c f\u2081 f' x v", "start": [308, 1], "end": [314, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDifferentiableAt_iff", "code": "theorem Filter.EventuallyEq.lineDifferentiableAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd x] f\u2081) :\n    LineDifferentiableAt \ud835\udd5c f\u2080 x v \u2194 LineDifferentiableAt \ud835\udd5c f\u2081 x v", "start": [316, 1], "end": [319, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasLineDerivWithinAt_iff", "code": "theorem Filter.EventuallyEq.hasLineDerivWithinAt_iff (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : f\u2080 x = f\u2081 x) :\n    HasLineDerivWithinAt \ud835\udd5c f\u2080 f' s x v \u2194 HasLineDerivWithinAt \ud835\udd5c f\u2081 f' s x v", "start": [321, 1], "end": [326, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.hasLineDerivWithinAt_iff_of_mem", "code": "theorem Filter.EventuallyEq.hasLineDerivWithinAt_iff_of_mem (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : x \u2208 s) :\n    HasLineDerivWithinAt \ud835\udd5c f\u2080 f' s x v \u2194 HasLineDerivWithinAt \ud835\udd5c f\u2081 f' s x v", "start": [328, 1], "end": [330, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDifferentiableWithinAt_iff", "code": "theorem Filter.EventuallyEq.lineDifferentiableWithinAt_iff\n    (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : f\u2080 x = f\u2081 x) :\n    LineDifferentiableWithinAt \ud835\udd5c f\u2080 s x v \u2194 LineDifferentiableWithinAt \ud835\udd5c f\u2081 s x v", "start": [332, 1], "end": [336, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDifferentiableWithinAt_iff_of_mem", "code": "theorem Filter.EventuallyEq.lineDifferentiableWithinAt_iff_of_mem\n    (h : f\u2080 =\u1da0[\ud835\udcdd[s] x] f\u2081) (hx : x \u2208 s) :\n    LineDifferentiableWithinAt \ud835\udd5c f\u2080 s x v \u2194 LineDifferentiableWithinAt \ud835\udd5c f\u2081 s x v", "start": [338, 1], "end": [341, 59], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.congr_of_eventuallyEq", "code": "lemma HasLineDerivWithinAt.congr_of_eventuallyEq (hf : HasLineDerivWithinAt \ud835\udd5c f f' s x v)\n    (h'f : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : HasLineDerivWithinAt \ud835\udd5c f\u2081 f' s x v := by\n  apply HasDerivWithinAt.congr_of_eventuallyEq hf _ (by simp [hx])\n  have A : Continuous (fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v) := by continuity\n  exact A.continuousWithinAt.preimage_mem_nhdsWithin'' h'f (by simp)", "start": [343, 1], "end": [347, 69], "kind": "mathlibtacticlemma"}, {"full_name": "HasLineDerivAt.congr_of_eventuallyEq", "code": "theorem HasLineDerivAt.congr_of_eventuallyEq (h : HasLineDerivAt \ud835\udd5c f f' x v) (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    HasLineDerivAt \ud835\udd5c f\u2081 f' x v", "start": [349, 1], "end": [354, 71], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.congr_of_eventuallyEq", "code": "theorem LineDifferentiableWithinAt.congr_of_eventuallyEq (h : LineDifferentiableWithinAt \ud835\udd5c f s x v)\n    (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : LineDifferentiableWithinAt \ud835\udd5c f\u2081 s x v", "start": [356, 1], "end": [358, 78], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt.congr_of_eventuallyEq", "code": "theorem LineDifferentiableAt.congr_of_eventuallyEq\n    (h : LineDifferentiableAt \ud835\udd5c f x v) (hL : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    LineDifferentiableAt \ud835\udd5c f\u2081 x v", "start": [360, 1], "end": [366, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDerivWithin_eq", "code": "theorem Filter.EventuallyEq.lineDerivWithin_eq (hs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) :\n    lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v", "start": [368, 1], "end": [372, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDerivWithin_eq_nhds", "code": "theorem Filter.EventuallyEq.lineDerivWithin_eq_nhds (h : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v", "start": [374, 1], "end": [376, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.lineDeriv_eq", "code": "theorem Filter.EventuallyEq.lineDeriv_eq (h : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    lineDeriv \ud835\udd5c f\u2081 x v = lineDeriv \ud835\udd5c f x v", "start": [378, 1], "end": [380, 81], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.le_of_lip'", "code": "theorem HasLineDerivAt.le_of_lip' {f : E \u2192 F} {f' : F} {x\u2080 : E} (hf : HasLineDerivAt \ud835\udd5c f f' x\u2080 v)\n    {C : \u211d} (hC\u2080 : 0 \u2264 C) (hlip : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016) :\n    \u2016f'\u2016 \u2264 C * \u2016v\u2016", "start": [382, 1], "end": [394, 29], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.le_of_lipschitzOn", "code": "theorem HasLineDerivAt.le_of_lipschitzOn\n    {f : E \u2192 F} {f' : F} {x\u2080 : E} (hf : HasLineDerivAt \ud835\udd5c f f' x\u2080 v)\n    {s : Set E} (hs : s \u2208 \ud835\udcdd x\u2080) {C : \u211d\u22650} (hlip : LipschitzOnWith C f s) :\n    \u2016f'\u2016 \u2264 C * \u2016v\u2016", "start": [396, 1], "end": [405, 79], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.le_of_lipschitz", "code": "theorem HasLineDerivAt.le_of_lipschitz\n    {f : E \u2192 F} {f' : F} {x\u2080 : E} (hf : HasLineDerivAt \ud835\udd5c f f' x\u2080 v)\n    {C : \u211d\u22650} (hlip : LipschitzWith C f) : \u2016f'\u2016 \u2264 C * \u2016v\u2016", "start": [407, 1], "end": [412, 58], "kind": "commanddeclaration"}, {"full_name": "norm_lineDeriv_le_of_lip'", "code": "theorem norm_lineDeriv_le_of_lip' {f : E \u2192 F} {x\u2080 : E}\n    {C : \u211d} (hC\u2080 : 0 \u2264 C) (hlip : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016) :\n    \u2016lineDeriv \ud835\udd5c f x\u2080 v\u2016 \u2264 C * \u2016v\u2016", "start": [416, 1], "end": [429, 29], "kind": "commanddeclaration"}, {"full_name": "norm_lineDeriv_le_of_lipschitzOn", "code": "theorem norm_lineDeriv_le_of_lipschitzOn {f : E \u2192 F} {x\u2080 : E} {s : Set E} (hs : s \u2208 \ud835\udcdd x\u2080)\n    {C : \u211d\u22650} (hlip : LipschitzOnWith C f s) : \u2016lineDeriv \ud835\udd5c f x\u2080 v\u2016 \u2264 C * \u2016v\u2016", "start": [431, 1], "end": [437, 79], "kind": "commanddeclaration"}, {"full_name": "norm_lineDeriv_le_of_lipschitz", "code": "theorem norm_lineDeriv_le_of_lipschitz {f : E \u2192 F} {x\u2080 : E}\n    {C : \u211d\u22650} (hlip : LipschitzWith C f) : \u2016lineDeriv \ud835\udd5c f x\u2080 v\u2016 \u2264 C * \u2016v\u2016", "start": [439, 1], "end": [444, 72], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivWithinAt_zero", "code": "theorem hasLineDerivWithinAt_zero : HasLineDerivWithinAt \ud835\udd5c f 0 s x 0", "start": [454, 1], "end": [455, 54], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivAt_zero", "code": "theorem hasLineDerivAt_zero : HasLineDerivAt \ud835\udd5c f 0 x 0", "start": [457, 1], "end": [458, 42], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableWithinAt_zero", "code": "theorem lineDifferentiableWithinAt_zero : LineDifferentiableWithinAt \ud835\udd5c f s x 0", "start": [460, 1], "end": [461, 55], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableAt_zero", "code": "theorem lineDifferentiableAt_zero : LineDifferentiableAt \ud835\udd5c f x 0", "start": [463, 1], "end": [464, 43], "kind": "commanddeclaration"}, {"full_name": "lineDeriv_zero", "code": "theorem lineDeriv_zero : lineDeriv \ud835\udd5c f x 0 = 0", "start": [466, 1], "end": [467, 32], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.of_comp", "code": "theorem HasLineDerivAt.of_comp {v : E'} (hf : HasLineDerivAt \ud835\udd5c (f \u2218 L) f' x v) :\n    HasLineDerivAt \ud835\udd5c f f' (L x) (L v)", "start": [477, 1], "end": [479, 34], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt.of_comp", "code": "theorem LineDifferentiableAt.of_comp {v : E'} (hf : LineDifferentiableAt \ud835\udd5c (f \u2218 L) x v) :\n    LineDifferentiableAt \ud835\udd5c f (L x) (L v)", "start": [481, 1], "end": [483, 49], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivWithinAt.smul", "code": "theorem HasLineDerivWithinAt.smul (h : HasLineDerivWithinAt \ud835\udd5c f f' s x v) (c : \ud835\udd5c) :\n    HasLineDerivWithinAt \ud835\udd5c f (c \u2022 f') s x (c \u2022 v)", "start": [491, 1], "end": [502, 21], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivWithinAt_smul_iff", "code": "theorem hasLineDerivWithinAt_smul_iff {c : \ud835\udd5c} (hc : c \u2260 0) :\n    HasLineDerivWithinAt \ud835\udd5c f (c \u2022 f') s x (c \u2022 v) \u2194 HasLineDerivWithinAt \ud835\udd5c f f' s x v", "start": [504, 1], "end": [506, 90], "kind": "commanddeclaration"}, {"full_name": "HasLineDerivAt.smul", "code": "theorem HasLineDerivAt.smul (h : HasLineDerivAt \ud835\udd5c f f' x v) (c : \ud835\udd5c) :\n    HasLineDerivAt \ud835\udd5c f (c \u2022 f') x (c \u2022 v)", "start": [508, 1], "end": [511, 38], "kind": "commanddeclaration"}, {"full_name": "hasLineDerivAt_smul_iff", "code": "theorem hasLineDerivAt_smul_iff {c : \ud835\udd5c} (hc : c \u2260 0) :\n    HasLineDerivAt \ud835\udd5c f (c \u2022 f') x (c \u2022 v) \u2194 HasLineDerivAt \ud835\udd5c f f' x v", "start": [513, 1], "end": [515, 90], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableWithinAt.smul", "code": "theorem LineDifferentiableWithinAt.smul (h : LineDifferentiableWithinAt \ud835\udd5c f s x v) (c : \ud835\udd5c) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x (c \u2022 v)", "start": [517, 1], "end": [519, 61], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableWithinAt_smul_iff", "code": "theorem lineDifferentiableWithinAt_smul_iff {c : \ud835\udd5c} (hc : c \u2260 0) :\n    LineDifferentiableWithinAt \ud835\udd5c f s x (c \u2022 v) \u2194 LineDifferentiableWithinAt \ud835\udd5c f s x v", "start": [521, 1], "end": [523, 90], "kind": "commanddeclaration"}, {"full_name": "LineDifferentiableAt.smul", "code": "theorem LineDifferentiableAt.smul (h : LineDifferentiableAt \ud835\udd5c f x v) (c : \ud835\udd5c) :\n    LineDifferentiableAt \ud835\udd5c f x (c \u2022 v)", "start": [525, 1], "end": [527, 49], "kind": "commanddeclaration"}, {"full_name": "lineDifferentiableAt_smul_iff", "code": "theorem lineDifferentiableAt_smul_iff {c : \ud835\udd5c} (hc : c \u2260 0) :\n    LineDifferentiableAt \ud835\udd5c f x (c \u2022 v) \u2194 LineDifferentiableAt \ud835\udd5c f x v", "start": [529, 1], "end": [531, 90], "kind": "commanddeclaration"}, {"full_name": "lineDeriv_smul", "code": "theorem lineDeriv_smul {c : \ud835\udd5c} : lineDeriv \ud835\udd5c f x (c \u2022 v) = c \u2022 lineDeriv \ud835\udd5c f x v", "start": [533, 1], "end": [540, 61], "kind": "commanddeclaration"}, {"full_name": "lineDeriv_neg", "code": "theorem lineDeriv_neg : lineDeriv \ud835\udd5c f x (-v) = - lineDeriv \ud835\udd5c f x v", "start": [542, 1], "end": [543, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/Monotone.lean", "imports": ["Mathlib/MeasureTheory/Covering/OneDim.lean", "Mathlib/Order/Monotone/Extension.lean", "Mathlib/Analysis/Calculus/Deriv/Slope.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tendsto_apply_add_mul_sq_div_sub", "code": "theorem tendsto_apply_add_mul_sq_div_sub {f : \u211d \u2192 \u211d} {x a c d : \u211d} {l : Filter \u211d} (hl : l \u2264 \ud835\udcdd[\u2260] x)\n    (hf : Tendsto (fun y => (f y - d) / (y - x)) l (\ud835\udcdd a))\n    (h' : Tendsto (fun y => y + c * (y - x) ^ 2) l l) :\n    Tendsto (fun y => (f (y + c * (y - x) ^ 2) - d) / (y - x)) l (\ud835\udcdd a)", "start": [41, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "StieltjesFunction.ae_hasDerivAt", "code": "theorem StieltjesFunction.ae_hasDerivAt (f : StieltjesFunction) :\n    \u2200\u1d50 x, HasDerivAt f (rnDeriv f.measure volume x).toReal x", "start": [67, 1], "end": [133, 17], "kind": "commanddeclaration"}, {"full_name": "Monotone.ae_hasDerivAt", "code": "theorem Monotone.ae_hasDerivAt {f : \u211d \u2192 \u211d} (hf : Monotone f) :\n    \u2200\u1d50 x, HasDerivAt f (rnDeriv hf.stieltjesFunction.measure volume x).toReal x", "start": [136, 1], "end": [214, 17], "kind": "commanddeclaration"}, {"full_name": "Monotone.ae_differentiableAt", "code": "theorem Monotone.ae_differentiableAt {f : \u211d \u2192 \u211d} (hf : Monotone f) :\n    \u2200\u1d50 x, DifferentiableAt \u211d f x", "start": [217, 1], "end": [220, 72], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.ae_differentiableWithinAt_of_mem", "code": "theorem MonotoneOn.ae_differentiableWithinAt_of_mem {f : \u211d \u2192 \u211d} {s : Set \u211d} (hf : MonotoneOn f s) :\n    \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [223, 1], "end": [243, 36], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.ae_differentiableWithinAt", "code": "theorem MonotoneOn.ae_differentiableWithinAt {f : \u211d \u2192 \u211d} {s : Set \u211d} (hf : MonotoneOn f s)\n    (hs : MeasurableSet s) : \u2200\u1d50 x \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x", "start": [246, 1], "end": [253, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/NatPrime.lean", "imports": ["Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.not_prime_of_int_mul", "code": "theorem not_prime_of_int_mul {a b : \u2124} {c : \u2115} (ha : 1 < a.natAbs) (hb : 1 < b.natAbs)\n    (hc : a * b = (c : \u2124)) : \u00acNat.Prime c", "start": [19, 1], "end": [21, 49], "kind": "commanddeclaration"}, {"full_name": "Int.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul", "code": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul {p : \u2115} (p_prime : Nat.Prime p) {m n : \u2124}\n    {k l : \u2115} (hpm : \u2191(p ^ k) \u2223 m) (hpn : \u2191(p ^ l) \u2223 n) (hpmn : \u2191(p ^ (k + l + 1)) \u2223 m * n) :\n    \u2191(p ^ (k + 1)) \u2223 m \u2228 \u2191(p ^ (l + 1)) \u2223 n", "start": [24, 1], "end": [33, 81], "kind": "commanddeclaration"}, {"full_name": "Int.Prime.dvd_natAbs_of_coe_dvd_sq", "code": "theorem Prime.dvd_natAbs_of_coe_dvd_sq {p : \u2115} (hp : p.Prime) (k : \u2124) (h : (p : \u2124) \u2223 k ^ 2) :\n    p \u2223 k.natAbs", "start": [36, 1], "end": [39, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean", "imports": ["Mathlib/Geometry/Manifold/Algebra/Structures.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SmoothMap.instMul", "code": "@[to_additive]\nprotected instance instMul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] : Mul C^\u221e\u27eeI, N; I', G\u27ef :=\n  \u27e8fun f g => \u27e8f * g, f.smooth.mul g.smooth\u27e9\u27e9", "start": [32, 1], "end": [35, 46], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_mul", "code": "@[to_additive (attr := simp)]\ntheorem coe_mul {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]\n    (f g : C^\u221e\u27eeI, N; I', G\u27ef) : \u21d1(f * g) = f * g", "start": [39, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.mul_comp", "code": "@[to_additive (attr := simp)]\ntheorem mul_comp {G : Type*} [Mul G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]\n    (f g : C^\u221e\u27eeI'', N'; I', G\u27ef) (h : C^\u221e\u27eeI, N; I'', N'\u27ef) : (f * g).comp h = f.comp h * g.comp h", "start": [46, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.instOne", "code": "@[to_additive]\nprotected instance instOne {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :\n    One C^\u221e\u27eeI, N; I', G\u27ef :=\n  \u27e8ContMDiffMap.const (1 : G)\u27e9", "start": [53, 1], "end": [56, 31], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_one {G : Type*} [One G] [TopologicalSpace G] [ChartedSpace H' G] :\n    \u21d1(1 : C^\u221e\u27eeI, N; I', G\u27ef) = 1", "start": [60, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.instNSMul", "code": "instance instNSMul {G : Type*} [AddMonoid G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothAdd I' G] : SMul \u2115 C^\u221e\u27eeI, N; I', G\u27ef where\n  smul n f := \u27e8n \u2022 (f : N \u2192 G), (smooth_nsmul n).comp f.smooth\u27e9", "start": [67, 1], "end": [69, 64], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.instPow", "code": "@[to_additive existing]\ninstance instPow {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G] :\n    Pow C^\u221e\u27eeI, N; I', G\u27ef \u2115 where\n  pow f n := \u27e8(f : N \u2192 G) ^ n, (smooth_pow n).comp f.smooth\u27e9", "start": [71, 1], "end": [74, 61], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_pow", "code": "@[to_additive (attr := simp)]\ntheorem coe_pow {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G] [SmoothMul I' G]\n    (f : C^\u221e\u27eeI, N; I', G\u27ef) (n : \u2115) :\n    \u21d1(f ^ n) = (f : N \u2192 G) ^ n", "start": [76, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.semigroup", "code": "@[to_additive]\ninstance semigroup {G : Type*} [Semigroup G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] : Semigroup C^\u221e\u27eeI, N; I', G\u27ef :=\n  FunLike.coe_injective.semigroup _ coe_mul", "start": [91, 1], "end": [94, 44], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.monoid", "code": "@[to_additive]\ninstance monoid {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] : Monoid C^\u221e\u27eeI, N; I', G\u27ef :=\n  FunLike.coe_injective.monoid _ coe_one coe_mul coe_pow", "start": [98, 1], "end": [101, 57], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coeFnMonoidHom", "code": "@[to_additive (attr := simps) \"Coercion to a function as an `AddMonoidHom`.\n  Similar to `AddMonoidHom.coeFn`.\"]\ndef coeFnMonoidHom {G : Type*} [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] : C^\u221e\u27eeI, N; I', G\u27ef \u2192* N \u2192 G where\n  toFun := FunLike.coe\n  map_one' := coe_one\n  map_mul' := coe_mul", "start": [105, 1], "end": [112, 22], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.compLeftMonoidHom", "code": "@[to_additive \"For a manifold `N` and a smooth homomorphism `\u03c6` between additive Lie groups `G'`,\n`G''`, the 'left-composition-by-`\u03c6`' group homomorphism from `C^\u221e\u27eeI, N; I', G'\u27ef` to\n`C^\u221e\u27eeI, N; I'', G''\u27ef`.\"]\ndef compLeftMonoidHom {G' : Type*} [Monoid G'] [TopologicalSpace G'] [ChartedSpace H' G']\n    [SmoothMul I' G'] {G'' : Type*} [Monoid G''] [TopologicalSpace G''] [ChartedSpace H'' G'']\n    [SmoothMul I'' G''] (\u03c6 : G' \u2192* G'') (h\u03c6 : Smooth I' I'' \u03c6) :\n    C^\u221e\u27eeI, N; I', G'\u27ef \u2192* C^\u221e\u27eeI, N; I'', G''\u27ef where\n  toFun f := \u27e8\u03c6 \u2218 f, fun x => (h\u03c6.smooth _).comp x (f.contMDiff x)\u27e9\n  map_one' := by ext; show \u03c6 1 = 1; simp\n  map_mul' f g := by ext x; show \u03c6 (f x * g x) = \u03c6 (f x) * \u03c6 (g x); simp", "start": [118, 1], "end": [129, 73], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.restrictMonoidHom", "code": "@[to_additive \"For an additive Lie group `G` and open sets `U \u2286 V` in `N`, the 'restriction' group\nhomomorphism from `C^\u221e\u27eeI, V; I', G\u27ef` to `C^\u221e\u27eeI, U; I', G\u27ef`.\"]\ndef restrictMonoidHom (G : Type*) [Monoid G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] {U V : Opens N} (h : U \u2264 V) : C^\u221e\u27eeI, V; I', G\u27ef \u2192* C^\u221e\u27eeI, U; I', G\u27ef where\n  toFun f := \u27e8f \u2218 Set.inclusion h, f.smooth.comp (smooth_inclusion h)\u27e9\n  map_one' := rfl\n  map_mul' _ _:= rfl", "start": [136, 1], "end": [144, 21], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.commMonoid", "code": "@[to_additive]\ninstance commMonoid {G : Type*} [CommMonoid G] [TopologicalSpace G] [ChartedSpace H' G]\n    [SmoothMul I' G] : CommMonoid C^\u221e\u27eeI, N; I', G\u27ef :=\n  FunLike.coe_injective.commMonoid _ coe_one coe_mul coe_pow", "start": [150, 1], "end": [153, 61], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.group", "code": "@[to_additive]\ninstance group {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G] :\n    Group C^\u221e\u27eeI, N; I', G\u27ef :=\n  { SmoothMap.monoid with\n    inv := fun f => \u27e8fun x => (f x)\u207b\u00b9, f.smooth.inv\u27e9\n    mul_left_inv := fun a => by ext; exact mul_left_inv _\n    div := fun f g => \u27e8f / g, f.smooth.div g.smooth\u27e9\n    div_eq_mul_inv := fun f g => by ext; exact div_eq_mul_inv _ _ }", "start": [157, 1], "end": [164, 68], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_inv {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]\n    (f : C^\u221e\u27eeI, N; I', G\u27ef) : \u21d1f\u207b\u00b9 = (\u21d1f)\u207b\u00b9", "start": [168, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_div", "code": "@[to_additive (attr := simp)]\ntheorem coe_div {G : Type*} [Group G] [TopologicalSpace G] [ChartedSpace H' G] [LieGroup I' G]\n    (f g : C^\u221e\u27eeI, N; I', G\u27ef) : \u21d1(f / g) = f / g", "start": [175, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.commGroup", "code": "@[to_additive]\ninstance commGroup {G : Type*} [CommGroup G] [TopologicalSpace G] [ChartedSpace H' G]\n    [LieGroup I' G] : CommGroup C^\u221e\u27eeI, N; I', G\u27ef :=\n  { SmoothMap.group, SmoothMap.commMonoid with }", "start": [182, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.semiring", "code": "instance semiring {R : Type*} [Semiring R] [TopologicalSpace R] [ChartedSpace H' R]\n    [SmoothRing I' R] : Semiring C^\u221e\u27eeI, N; I', R\u27ef :=\n  { SmoothMap.addCommMonoid,\n    SmoothMap.monoid with\n    left_distrib := fun a b c => by ext; exact left_distrib _ _ _\n    right_distrib := fun a b c => by ext; exact right_distrib _ _ _\n    zero_mul := fun a => by ext; exact zero_mul _\n    mul_zero := fun a => by ext; exact mul_zero _ }", "start": [201, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.ring", "code": "instance ring {R : Type*} [Ring R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R] :\n    Ring C^\u221e\u27eeI, N; I', R\u27ef :=\n  { SmoothMap.semiring, SmoothMap.addCommGroup with }", "start": [211, 1], "end": [213, 54], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.commRing", "code": "instance commRing {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]\n    [SmoothRing I' R] : CommRing C^\u221e\u27eeI, N; I', R\u27ef :=\n  { SmoothMap.semiring, SmoothMap.addCommGroup, SmoothMap.commMonoid with }", "start": [216, 1], "end": [218, 76], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.compLeftRingHom", "code": "def compLeftRingHom {R' : Type*} [Ring R'] [TopologicalSpace R'] [ChartedSpace H' R']\n    [SmoothRing I' R'] {R'' : Type*} [Ring R''] [TopologicalSpace R''] [ChartedSpace H'' R'']\n    [SmoothRing I'' R''] (\u03c6 : R' \u2192+* R'') (h\u03c6 : Smooth I' I'' \u03c6) :\n    C^\u221e\u27eeI, N; I', R'\u27ef \u2192+* C^\u221e\u27eeI, N; I'', R''\u27ef :=\n  { SmoothMap.compLeftMonoidHom I N \u03c6.toMonoidHom h\u03c6,\n    SmoothMap.compLeftAddMonoidHom I N \u03c6.toAddMonoidHom h\u03c6 with\n    toFun := fun f => \u27e8\u03c6 \u2218 f, fun x => (h\u03c6.smooth _).comp x (f.contMDiff x)\u27e9 }", "start": [223, 1], "end": [231, 79], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.restrictRingHom", "code": "def restrictRingHom (R : Type*) [Ring R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R]\n    {U V : Opens N} (h : U \u2264 V) : C^\u221e\u27eeI, V; I', R\u27ef \u2192+* C^\u221e\u27eeI, U; I', R\u27ef :=\n  { SmoothMap.restrictMonoidHom I I' R h, SmoothMap.restrictAddMonoidHom I I' R h with\n    toFun := fun f => \u27e8f \u2218 Set.inclusion h, f.smooth.comp (smooth_inclusion h)\u27e9 }", "start": [236, 1], "end": [241, 82], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coeFnRingHom", "code": "@[simps]\ndef coeFnRingHom {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R]\n    [SmoothRing I' R] : C^\u221e\u27eeI, N; I', R\u27ef \u2192+* N \u2192 R :=\n  { (coeFnMonoidHom : C^\u221e\u27eeI, N; I', R\u27ef \u2192* _), (coeFnAddMonoidHom : C^\u221e\u27eeI, N; I', R\u27ef \u2192+ _) with\n    toFun := (\u2191) }", "start": [246, 1], "end": [251, 19], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.evalRingHom", "code": "def evalRingHom {R : Type*} [CommRing R] [TopologicalSpace R] [ChartedSpace H' R] [SmoothRing I' R]\n    (n : N) : C^\u221e\u27eeI, N; I', R\u27ef \u2192+* R :=\n  (Pi.evalRingHom _ n : (N \u2192 R) \u2192+* R).comp SmoothMap.coeFnRingHom", "start": [254, 1], "end": [257, 67], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.instSMul", "code": "instance instSMul {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] :\n    SMul \ud835\udd5c C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef :=\n  \u27e8fun r f => \u27e8r \u2022 \u21d1f, smooth_const.smul f.smooth\u27e9\u27e9", "start": [272, 1], "end": [274, 52], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coe_smul", "code": "@[simp]\ntheorem coe_smul {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] (r : \ud835\udd5c)\n    (f : C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [277, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.smul_comp", "code": "@[simp]\ntheorem smul_comp {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] (r : \ud835\udd5c)\n    (g : C^\u221e\u27eeI'', N'; \ud835\udcd8(\ud835\udd5c, V), V\u27ef) (h : C^\u221e\u27eeI, N; I'', N'\u27ef) : (r \u2022 g).comp h = r \u2022 g.comp h", "start": [283, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.module", "code": "instance module {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] :\n    Module \ud835\udd5c C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef :=\n  Function.Injective.module \ud835\udd5c coeFnAddMonoidHom ContMDiffMap.coe_injective coe_smul", "start": [289, 1], "end": [291, 84], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coeFnLinearMap", "code": "@[simps]\ndef coeFnLinearMap {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] :\n    C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef \u2192\u2097[\ud835\udd5c] N \u2192 V :=\n  { (coeFnAddMonoidHom : C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef \u2192+ _) with\n    toFun := (\u2191)\n    map_smul' := coe_smul }", "start": [294, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.C", "code": "def C : \ud835\udd5c \u2192+* C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, A), A\u27ef where\n  toFun := fun c : \ud835\udd5c => \u27e8fun _ => (algebraMap \ud835\udd5c A) c, smooth_const\u27e9\n  map_one' := by ext; exact (algebraMap \ud835\udd5c A).map_one\n  map_mul' c\u2081 c\u2082 := by ext; exact (algebraMap \ud835\udd5c A).map_mul _ _\n  map_zero' := by ext; exact (algebraMap \ud835\udd5c A).map_zero\n  map_add' c\u2081 c\u2082 := by ext; exact (algebraMap \ud835\udd5c A).map_add _ _", "start": [317, 1], "end": [323, 63], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.algebra", "code": "instance algebra : Algebra \ud835\udd5c C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, A), A\u27ef :=\n  { smul := fun r f => \u27e8r \u2022 f, smooth_const.smul f.smooth\u27e9\n    toRingHom := SmoothMap.C\n    commutes' := fun c f => by ext x; exact Algebra.commutes' _ _\n    smul_def' := fun c f => by ext x; exact Algebra.smul_def' _ _ }", "start": [327, 1], "end": [332, 68], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.coeFnAlgHom", "code": "@[simps]\ndef coeFnAlgHom : C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, A), A\u27ef \u2192\u2090[\ud835\udd5c] N \u2192 A where\n  toFun := (\u2191)\n  commutes' _ := rfl\n  map_zero' := SmoothMap.coe_zero\n  map_one' := SmoothMap.coe_one\n  map_add' := SmoothMap.coe_add\n  map_mul' := SmoothMap.coe_mul", "start": [335, 1], "end": [344, 32], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.instSMul'", "code": "instance instSMul' {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] :\n    SMul C^\u221e\u27eeI, N; \ud835\udd5c\u27ef C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef :=\n  \u27e8fun f g => \u27e8fun x => f x \u2022 g x, Smooth.smul f.2 g.2\u27e9\u27e9", "start": [358, 1], "end": [360, 57], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.smul_comp'", "code": "@[simp]\ntheorem smul_comp' {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] (f : C^\u221e\u27eeI'', N'; \ud835\udd5c\u27ef)\n    (g : C^\u221e\u27eeI'', N'; \ud835\udcd8(\ud835\udd5c, V), V\u27ef) (h : C^\u221e\u27eeI, N; I'', N'\u27ef) :\n    (f \u2022 g).comp h = f.comp h \u2022 g.comp h", "start": [363, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "SmoothMap.module'", "code": "instance module' {V : Type*} [NormedAddCommGroup V] [NormedSpace \ud835\udd5c V] :\n    Module C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c), \ud835\udd5c\u27ef C^\u221e\u27eeI, N; \ud835\udcd8(\ud835\udd5c, V), V\u27ef where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_add c f g := by ext x; exact smul_add (c x) (f x) (g x)\n  add_smul c\u2081 c\u2082 f := by ext x; exact add_smul (c\u2081 x) (c\u2082 x) (f x)\n  mul_smul c\u2081 c\u2082 f := by ext x; exact mul_smul (c\u2081 x) (c\u2082 x) (f x)\n  one_smul f := by ext x; exact one_smul \ud835\udd5c (f x)\n  zero_smul f := by ext x; exact zero_smul _ _\n  smul_zero r := by ext x; exact smul_zero _", "start": [370, 1], "end": [378, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "imports": ["Mathlib/Algebra/Homology/ShortComplex/RightHomology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.HomologyData", "code": "structure HomologyData where\n  \n  left : S.LeftHomologyData\n  \n  right : S.RightHomologyData\n  \n  iso : left.H \u2245 right.H\n  \n  comm : left.\u03c0 \u226b iso.hom \u226b right.\u03b9 = left.i \u226b right.p := by aesop_cat", "start": [45, 1], "end": [57, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData", "code": "structure HomologyMapData where\n  \n  left : LeftHomologyMapData \u03c6 h\u2081.left h\u2082.left\n  \n  right : RightHomologyMapData \u03c6 h\u2081.right h\u2082.right", "start": [63, 1], "end": [69, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.comm", "code": "@[reassoc]\nlemma comm (h : HomologyMapData \u03c6 h\u2081 h\u2082) :\n    h.left.\u03c6H \u226b h\u2082.iso.hom = h\u2081.iso.hom \u226b h.right.\u03c6H := by\n  simp only [\u2190 cancel_epi h\u2081.left.\u03c0, \u2190 cancel_mono h\u2082.right.\u03b9, assoc,\n    LeftHomologyMapData.comm\u03c0_assoc, HomologyData.comm, LeftHomologyMapData.commi_assoc,\n    RightHomologyMapData.comm\u03b9, HomologyData.comm_assoc, RightHomologyMapData.commp]", "start": [77, 1], "end": [82, 85], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.homologyMapData", "code": "def homologyMapData : HomologyMapData \u03c6 h\u2081 h\u2082 := default", "start": [95, 1], "end": [98, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.congr_left_\u03c6H", "code": "lemma congr_left_\u03c6H {\u03b3\u2081 \u03b3\u2082 : HomologyMapData \u03c6 h\u2081 h\u2082} (eq : \u03b3\u2081 = \u03b3\u2082) :\n    \u03b3\u2081.left.\u03c6H = \u03b3\u2082.left.\u03c6H := by rw [eq]", "start": [102, 1], "end": [103, 42], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork", "code": "@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsLimitKernelFork S hf c hc\n  right := RightHomologyData.ofIsLimitKernelFork S hf c hc\n  iso := Iso.refl _", "start": [109, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofHasKernel", "code": "@[simps]\nnoncomputable def ofHasKernel (hf : S.f = 0) [HasKernel S.g] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasKernel S hf\n  right := RightHomologyData.ofHasKernel S hf\n  iso := Iso.refl _", "start": [118, 1], "end": [125, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork", "code": "@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsColimitCokernelCofork S hg c hc\n  right := RightHomologyData.ofIsColimitCokernelCofork S hg c hc\n  iso := Iso.refl _", "start": [127, 1], "end": [134, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofHasCokernel", "code": "@[simps]\nnoncomputable def ofHasCokernel (hg : S.g = 0) [HasCokernel S.f] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasCokernel S hg\n  right := RightHomologyData.ofHasCokernel S hg\n  iso := Iso.refl _", "start": [136, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofZeros", "code": "@[simps]\nnoncomputable def ofZeros (hf : S.f = 0) (hg : S.g = 0) :\n    S.HomologyData where\n  left := LeftHomologyData.ofZeros S hf hg\n  right := RightHomologyData.ofZeros S hf hg\n  iso := Iso.refl _", "start": [145, 1], "end": [151, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono", "code": "@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (\u03c6 : S\u2081 \u27f6 S\u2082) (h : HomologyData S\u2081)\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] : HomologyData S\u2082 where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono \u03c6 h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono \u03c6 h.right\n  iso := h.iso", "start": [153, 1], "end": [161, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono'", "code": "@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (\u03c6 : S\u2081 \u27f6 S\u2082) (h : HomologyData S\u2082)\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] : HomologyData S\u2081 where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono' \u03c6 h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono' \u03c6 h.right\n  iso := h.iso", "start": [163, 1], "end": [171, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofIso", "code": "@[simps!]\nnoncomputable def ofIso (e : S\u2081 \u2245 S\u2082) (h : HomologyData S\u2081) :=\n  h.ofEpiOfIsIsoOfMono e.hom", "start": [173, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.op", "code": "@[simps]\ndef op (h : S.HomologyData) : S.op.HomologyData where\n  left := h.right.op\n  right := h.left.op\n  iso := h.iso.op\n  comm := Quiver.Hom.unop_inj (by simp)", "start": [181, 1], "end": [187, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.unop", "code": "@[simps]\ndef unop {S : ShortComplex C\u1d52\u1d56} (h : S.HomologyData) : S.unop.HomologyData where\n  left := h.right.unop\n  right := h.left.unop\n  iso := h.iso.unop\n  comm := Quiver.Hom.op_inj (by simp)", "start": [189, 1], "end": [196, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HasHomology", "code": "class HasHomology : Prop where\n  \n  condition : Nonempty S.HomologyData", "start": [200, 1], "end": [203, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyData", "code": "noncomputable def homologyData [HasHomology S] :\n  S.HomologyData := HasHomology.condition.some", "start": [205, 1], "end": [207, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HasHomology.mk'", "code": "lemma HasHomology.mk' (h : S.HomologyData) : HasHomology S :=\n  \u27e8Nonempty.intro h\u27e9", "start": [211, 1], "end": [212, 21], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.hasLeftHomology_of_hasHomology", "code": "instance hasLeftHomology_of_hasHomology [S.HasHomology] : S.HasLeftHomology :=\n  HasLeftHomology.mk' S.homologyData.left", "start": [217, 1], "end": [218, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasRightHomology_of_hasHomology", "code": "instance hasRightHomology_of_hasHomology [S.HasHomology] : S.HasRightHomology :=\n  HasRightHomology.mk' S.homologyData.right", "start": [220, 1], "end": [221, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_hasCokernel", "code": "instance hasHomology_of_hasCokernel {X Y : C} (f : X \u27f6 Y) (Z : C) [HasCokernel f] :\n    (ShortComplex.mk f (0 : Y \u27f6 Z) comp_zero).HasHomology :=\n  HasHomology.mk' (HomologyData.ofHasCokernel _ rfl)", "start": [223, 1], "end": [225, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_hasKernel", "code": "instance hasHomology_of_hasKernel {Y Z : C} (g : Y \u27f6 Z) (X : C) [HasKernel g] :\n    (ShortComplex.mk (0 : X \u27f6 Y) g zero_comp).HasHomology :=\n  HasHomology.mk' (HomologyData.ofHasKernel _ rfl)", "start": [227, 1], "end": [229, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_zeros", "code": "instance hasHomology_of_zeros (X Y Z : C) :\n    (ShortComplex.mk (0 : X \u27f6 Y) (0 : Y \u27f6 Z) zero_comp).HasHomology :=\n  HasHomology.mk' (HomologyData.ofZeros _ rfl rfl)", "start": [231, 1], "end": [233, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_epi_of_isIso_of_mono", "code": "lemma hasHomology_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082) [HasHomology S\u2081]\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] : HasHomology S\u2082 :=\n  HasHomology.mk' (HomologyData.ofEpiOfIsIsoOfMono \u03c6 S\u2081.homologyData)", "start": [235, 1], "end": [237, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_epi_of_isIso_of_mono'", "code": "lemma hasHomology_of_epi_of_isIso_of_mono' (\u03c6 : S\u2081 \u27f6 S\u2082) [HasHomology S\u2082]\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] : HasHomology S\u2081 :=\n  HasHomology.mk' (HomologyData.ofEpiOfIsIsoOfMono' \u03c6 S\u2082.homologyData)", "start": [239, 1], "end": [241, 71], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_iso", "code": "lemma hasHomology_of_iso (e : S\u2081 \u2245 S\u2082) [HasHomology S\u2081] : HasHomology S\u2082 :=\n  HasHomology.mk' (HomologyData.ofIso e S\u2081.homologyData)", "start": [243, 1], "end": [244, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.id", "code": "@[simps]\ndef id (h : S.HomologyData) : HomologyMapData (\ud835\udfd9 S) h h where\n  left := LeftHomologyMapData.id h.left\n  right := RightHomologyMapData.id h.right", "start": [248, 1], "end": [252, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.zero", "code": "@[simps]\ndef zero (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) :\n    HomologyMapData 0 h\u2081 h\u2082 where\n  left := LeftHomologyMapData.zero h\u2081.left h\u2082.left\n  right := RightHomologyMapData.zero h\u2081.right h\u2082.right", "start": [254, 1], "end": [259, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.comp", "code": "@[simps]\ndef comp {\u03c6 : S\u2081 \u27f6 S\u2082} {\u03c6' : S\u2082 \u27f6 S\u2083} {h\u2081 : S\u2081.HomologyData}\n    {h\u2082 : S\u2082.HomologyData} {h\u2083 : S\u2083.HomologyData}\n    (\u03c8 : HomologyMapData \u03c6 h\u2081 h\u2082) (\u03c8' : HomologyMapData \u03c6' h\u2082 h\u2083) :\n    HomologyMapData (\u03c6 \u226b \u03c6') h\u2081 h\u2083 where\n  left := \u03c8.left.comp \u03c8'.left\n  right := \u03c8.right.comp \u03c8'.right", "start": [261, 1], "end": [268, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.op", "code": "@[simps]\ndef op {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.HomologyData} {h\u2082 : S\u2082.HomologyData}\n    (\u03c8 : HomologyMapData \u03c6 h\u2081 h\u2082) :\n    HomologyMapData (opMap \u03c6) h\u2082.op h\u2081.op where\n  left := \u03c8.right.op\n  right := \u03c8.left.op", "start": [270, 1], "end": [277, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.unop", "code": "@[simps]\ndef unop {S\u2081 S\u2082 : ShortComplex C\u1d52\u1d56} {\u03c6 : S\u2081 \u27f6 S\u2082}\n    {h\u2081 : S\u2081.HomologyData} {h\u2082 : S\u2082.HomologyData}\n    (\u03c8 : HomologyMapData \u03c6 h\u2081 h\u2082) :\n    HomologyMapData (unopMap \u03c6) h\u2082.unop h\u2081.unop where\n  left := \u03c8.right.unop\n  right := \u03c8.left.unop", "start": [279, 1], "end": [287, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.ofZeros", "code": "@[simps]\ndef ofZeros (\u03c6 : S\u2081 \u27f6 S\u2082) (hf\u2081 : S\u2081.f = 0) (hg\u2081 : S\u2081.g = 0) (hf\u2082 : S\u2082.f = 0) (hg\u2082 : S\u2082.g = 0) :\n    HomologyMapData \u03c6 (HomologyData.ofZeros S\u2081 hf\u2081 hg\u2081) (HomologyData.ofZeros S\u2082 hf\u2082 hg\u2082) where\n  left := LeftHomologyMapData.ofZeros \u03c6 hf\u2081 hg\u2081 hf\u2082 hg\u2082\n  right := RightHomologyMapData.ofZeros \u03c6 hf\u2081 hg\u2081 hf\u2082 hg\u2082", "start": [289, 1], "end": [295, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.ofIsColimitCokernelCofork", "code": "@[simps]\ndef ofIsColimitCokernelCofork (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hg\u2081 : S\u2081.g = 0) (c\u2081 : CokernelCofork S\u2081.f) (hc\u2081 : IsColimit c\u2081)\n    (hg\u2082 : S\u2082.g = 0) (c\u2082 : CokernelCofork S\u2082.f) (hc\u2082 : IsColimit c\u2082) (f : c\u2081.pt \u27f6 c\u2082.pt)\n    (comm : \u03c6.\u03c4\u2082 \u226b c\u2082.\u03c0 = c\u2081.\u03c0 \u226b f) :\n    HomologyMapData \u03c6 (HomologyData.ofIsColimitCokernelCofork S\u2081 hg\u2081 c\u2081 hc\u2081)\n      (HomologyData.ofIsColimitCokernelCofork S\u2082 hg\u2082 c\u2082 hc\u2082) where\n  left := LeftHomologyMapData.ofIsColimitCokernelCofork \u03c6 hg\u2081 c\u2081 hc\u2081 hg\u2082 c\u2082 hc\u2082 f comm\n  right := RightHomologyMapData.ofIsColimitCokernelCofork \u03c6 hg\u2081 c\u2081 hc\u2081 hg\u2082 c\u2082 hc\u2082 f comm", "start": [297, 1], "end": [309, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.ofIsLimitKernelFork", "code": "@[simps]\ndef ofIsLimitKernelFork (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (hf\u2081 : S\u2081.f = 0) (c\u2081 : KernelFork S\u2081.g) (hc\u2081 : IsLimit c\u2081)\n    (hf\u2082 : S\u2082.f = 0) (c\u2082 : KernelFork S\u2082.g) (hc\u2082 : IsLimit c\u2082) (f : c\u2081.pt \u27f6 c\u2082.pt)\n    (comm : c\u2081.\u03b9 \u226b \u03c6.\u03c4\u2082 = f \u226b c\u2082.\u03b9) :\n    HomologyMapData \u03c6 (HomologyData.ofIsLimitKernelFork S\u2081 hf\u2081 c\u2081 hc\u2081)\n      (HomologyData.ofIsLimitKernelFork S\u2082 hf\u2082 c\u2082 hc\u2082) where\n  left := LeftHomologyMapData.ofIsLimitKernelFork \u03c6 hf\u2081 c\u2081 hc\u2081 hf\u2082 c\u2082 hc\u2082 f comm\n  right := RightHomologyMapData.ofIsLimitKernelFork \u03c6 hf\u2081 c\u2081 hc\u2081 hf\u2082 c\u2082 hc\u2082 f comm", "start": [311, 1], "end": [323, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork", "code": "def compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)\n    (c : CokernelCofork S.f) (hc : IsColimit c) :\n    HomologyMapData (\ud835\udfd9 S) (HomologyData.ofZeros S hf hg)\n      (HomologyData.ofIsColimitCokernelCofork S hg c hc) where\n  left := LeftHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc\n  right := RightHomologyMapData.compatibilityOfZerosOfIsColimitCokernelCofork S hf hg c hc", "start": [325, 1], "end": [333, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsLimitKernelFork", "code": "@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    HomologyMapData (\ud835\udfd9 S)\n      (HomologyData.ofIsLimitKernelFork S hf c hc)\n      (HomologyData.ofZeros S hf hg) where\n  left := LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc\n  right := RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc", "start": [335, 1], "end": [345, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.ofEpiOfIsIsoOfMono", "code": "noncomputable def ofEpiOfIsIsoOfMono (\u03c6 : S\u2081 \u27f6 S\u2082) (h : HomologyData S\u2081)\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    HomologyMapData \u03c6 h (HomologyData.ofEpiOfIsIsoOfMono \u03c6 h) where\n  left := LeftHomologyMapData.ofEpiOfIsIsoOfMono \u03c6 h.left\n  right := RightHomologyMapData.ofEpiOfIsIsoOfMono \u03c6 h.right", "start": [347, 1], "end": [353, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.ofEpiOfIsIsoOfMono'", "code": "noncomputable def ofEpiOfIsIsoOfMono' (\u03c6 : S\u2081 \u27f6 S\u2082) (h : HomologyData S\u2082)\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    HomologyMapData \u03c6 (HomologyData.ofEpiOfIsIsoOfMono' \u03c6 h) h where\n  left := LeftHomologyMapData.ofEpiOfIsIsoOfMono' \u03c6 h.left\n  right := RightHomologyMapData.ofEpiOfIsIsoOfMono' \u03c6 h.right", "start": [355, 1], "end": [361, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homology", "code": "noncomputable def homology [HasHomology S] : C := S.homologyData.left.H", "start": [367, 1], "end": [368, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyIso", "code": "noncomputable def leftHomologyIso [S.HasHomology] : S.leftHomology \u2245 S.homology :=\n  leftHomologyMapIso' (Iso.refl _) _ _", "start": [370, 1], "end": [373, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.rightHomologyIso", "code": "noncomputable def rightHomologyIso [S.HasHomology] : S.rightHomology \u2245 S.homology :=\n  rightHomologyMapIso' (Iso.refl _) _ _ \u226a\u226b S.homologyData.iso.symm", "start": [375, 1], "end": [378, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.homologyIso", "code": "noncomputable def LeftHomologyData.homologyIso (h : S.LeftHomologyData) [S.HasHomology] :\n    S.homology \u2245 h.H := S.leftHomologyIso.symm \u226a\u226b h.leftHomologyIso", "start": [382, 1], "end": [385, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.homologyIso", "code": "noncomputable def RightHomologyData.homologyIso (h : S.RightHomologyData) [S.HasHomology] :\n    S.homology \u2245 h.H := S.rightHomologyIso.symm \u226a\u226b h.rightHomologyIso", "start": [387, 1], "end": [390, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.homologyIso_leftHomologyData", "code": "@[simp]\nlemma LeftHomologyData.homologyIso_leftHomologyData [S.HasHomology] :\n    S.leftHomologyData.homologyIso = S.leftHomologyIso.symm := by\n  ext\n  dsimp [homologyIso, leftHomologyIso, ShortComplex.leftHomologyIso]\n  rw [\u2190 leftHomologyMap'_comp, comp_id]", "start": [394, 1], "end": [399, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.homologyIso_rightHomologyData", "code": "@[simp]\nlemma RightHomologyData.homologyIso_rightHomologyData [S.HasHomology] :\n    S.rightHomologyData.homologyIso = S.rightHomologyIso.symm := by\n  ext\n  dsimp [homologyIso, rightHomologyIso]\n  erw [rightHomologyMap'_id, comp_id]", "start": [401, 1], "end": [406, 38], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap'", "code": "def homologyMap' (\u03c6 : S\u2081 \u27f6 S\u2082) (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) :\n    h\u2081.left.H \u27f6 h\u2082.left.H := leftHomologyMap' \u03c6 _ _", "start": [410, 1], "end": [413, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap", "code": "noncomputable def homologyMap (\u03c6 : S\u2081 \u27f6 S\u2082) [HasHomology S\u2081] [HasHomology S\u2082] :\n    S\u2081.homology \u27f6 S\u2082.homology :=\n  homologyMap' \u03c6 _ _", "start": [415, 1], "end": [419, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.homologyMap'_eq", "code": "lemma homologyMap'_eq : homologyMap' \u03c6 h\u2081 h\u2082 = \u03b3.left.\u03c6H :=\n  LeftHomologyMapData.congr_\u03c6H (Subsingleton.elim _ _)", "start": [426, 1], "end": [427, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.cyclesMap'_eq", "code": "lemma cyclesMap'_eq : cyclesMap' \u03c6 h\u2081.left h\u2082.left = \u03b3.left.\u03c6K :=\n  LeftHomologyMapData.congr_\u03c6K (Subsingleton.elim _ _)", "start": [429, 1], "end": [430, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.opcyclesMap'_eq", "code": "lemma opcyclesMap'_eq : opcyclesMap' \u03c6 h\u2081.right h\u2082.right = \u03b3.right.\u03c6Q :=\n  RightHomologyMapData.congr_\u03c6Q (Subsingleton.elim _ _)", "start": [432, 1], "end": [433, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.homologyMap_eq", "code": "lemma homologyMap_eq :\n    homologyMap \u03c6 = h\u2081.homologyIso.hom \u226b \u03b3.\u03c6H \u226b h\u2082.homologyIso.inv := by\n  dsimp [homologyMap, LeftHomologyData.homologyIso, leftHomologyIso,\n    LeftHomologyData.leftHomologyIso, homologyMap']\n  simp only [\u2190 \u03b3.leftHomologyMap'_eq, \u2190 leftHomologyMap'_comp, id_comp, comp_id]", "start": [442, 1], "end": [446, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.homologyMap_comm", "code": "lemma homologyMap_comm :\n    homologyMap \u03c6 \u226b h\u2082.homologyIso.hom = h\u2081.homologyIso.hom \u226b \u03b3.\u03c6H := by\n  simp only [\u03b3.homologyMap_eq, assoc, Iso.inv_hom_id, comp_id]", "start": [448, 1], "end": [450, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyMapData.homologyMap_eq", "code": "lemma homologyMap_eq :\n    homologyMap \u03c6 = h\u2081.homologyIso.hom \u226b \u03b3.\u03c6H \u226b h\u2082.homologyIso.inv := by\n  dsimp [homologyMap, homologyMap', RightHomologyData.homologyIso,\n    rightHomologyIso, RightHomologyData.rightHomologyIso]\n  have \u03b3' : HomologyMapData \u03c6 S\u2081.homologyData S\u2082.homologyData := default\n  simp only [\u2190 \u03b3.rightHomologyMap'_eq, assoc, \u2190 rightHomologyMap'_comp_assoc,\n    id_comp, comp_id, \u03b3'.left.leftHomologyMap'_eq, \u03b3'.right.rightHomologyMap'_eq, \u2190 \u03b3'.comm_assoc,\n    Iso.hom_inv_id]", "start": [459, 1], "end": [466, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyMapData.homologyMap_comm", "code": "lemma homologyMap_comm :\n    homologyMap \u03c6 \u226b h\u2082.homologyIso.hom = h\u2081.homologyIso.hom \u226b \u03b3.\u03c6H := by\n  simp only [\u03b3.homologyMap_eq, assoc, Iso.inv_hom_id, comp_id]", "start": [468, 1], "end": [470, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap'_id", "code": "@[simp]\nlemma homologyMap'_id (h : S.HomologyData) :\n    homologyMap' (\ud835\udfd9 S) h h = \ud835\udfd9 _ :=\n  (HomologyMapData.id h).homologyMap'_eq", "start": [474, 1], "end": [477, 41], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap_id", "code": "@[simp]\nlemma homologyMap_id [HasHomology S] :\n    homologyMap (\ud835\udfd9 S) = \ud835\udfd9 _ :=\n  homologyMap'_id _", "start": [481, 1], "end": [484, 20], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap'_zero", "code": "@[simp]\nlemma homologyMap'_zero (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) :\n    homologyMap' 0 h\u2081 h\u2082 = 0 :=\n  (HomologyMapData.zero h\u2081 h\u2082).homologyMap'_eq", "start": [486, 1], "end": [489, 47], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap_zero", "code": "@[simp]\nlemma homologyMap_zero [S\u2081.HasHomology] [S\u2082.HasHomology] :\n    homologyMap (0 : S\u2081 \u27f6 S\u2082) = 0 :=\n  homologyMap'_zero _ _", "start": [493, 1], "end": [496, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap'_comp", "code": "lemma homologyMap'_comp (\u03c6\u2081 : S\u2081 \u27f6 S\u2082) (\u03c6\u2082 : S\u2082 \u27f6 S\u2083)\n    (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) (h\u2083 : S\u2083.HomologyData) :\n    homologyMap' (\u03c6\u2081 \u226b \u03c6\u2082) h\u2081 h\u2083 = homologyMap' \u03c6\u2081 h\u2081 h\u2082 \u226b\n      homologyMap' \u03c6\u2082 h\u2082 h\u2083 :=\n  leftHomologyMap'_comp _ _ _ _ _", "start": [500, 1], "end": [504, 34], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap_comp", "code": "@[simp]\nlemma homologyMap_comp [HasHomology S\u2081] [HasHomology S\u2082] [HasHomology S\u2083]\n    (\u03c6\u2081 : S\u2081 \u27f6 S\u2082) (\u03c6\u2082 : S\u2082 \u27f6 S\u2083) :\n    homologyMap (\u03c6\u2081 \u226b \u03c6\u2082) = homologyMap \u03c6\u2081 \u226b homologyMap \u03c6\u2082 :=\n  homologyMap'_comp _ _ _ _ _", "start": [506, 1], "end": [510, 30], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMapIso'", "code": "@[simps]\ndef homologyMapIso' (e : S\u2081 \u2245 S\u2082) (h\u2081 : S\u2081.HomologyData)\n    (h\u2082 : S\u2082.HomologyData) : h\u2081.left.H \u2245 h\u2082.left.H where\n  hom := homologyMap' e.hom h\u2081 h\u2082\n  inv := homologyMap' e.inv h\u2082 h\u2081\n  hom_inv_id := by rw [\u2190 homologyMap'_comp, e.hom_inv_id, homologyMap'_id]\n  inv_hom_id := by rw [\u2190 homologyMap'_comp, e.inv_hom_id, homologyMap'_id]", "start": [512, 1], "end": [520, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap'_of_isIso", "code": "instance isIso_homologyMap'_of_isIso (\u03c6 : S\u2081 \u27f6 S\u2082) [IsIso \u03c6]\n    (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) :\n    IsIso (homologyMap' \u03c6 h\u2081 h\u2082) :=\n  (inferInstance : IsIso (homologyMapIso' (asIso \u03c6) h\u2081 h\u2082).hom)", "start": [522, 1], "end": [525, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyMapIso", "code": "@[simps]\nnoncomputable def homologyMapIso (e : S\u2081 \u2245 S\u2082) [S\u2081.HasHomology]\n    [S\u2082.HasHomology] : S\u2081.homology \u2245 S\u2082.homology where\n  hom := homologyMap e.hom\n  inv := homologyMap e.inv\n  hom_inv_id := by rw [\u2190 homologyMap_comp, e.hom_inv_id, homologyMap_id]\n  inv_hom_id := by rw [\u2190 homologyMap_comp, e.inv_hom_id, homologyMap_id]", "start": [527, 1], "end": [535, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_iso", "code": "instance isIso_homologyMap_of_iso (\u03c6 : S\u2081 \u27f6 S\u2082) [IsIso \u03c6] [S\u2081.HasHomology]\n    [S\u2082.HasHomology] :\n    IsIso (homologyMap \u03c6) :=\n  (inferInstance : IsIso (homologyMapIso (asIso \u03c6)).hom)", "start": [537, 1], "end": [540, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'", "code": "def leftRightHomologyComparison' : h\u2081.H \u27f6 h\u2082.H :=\n  h\u2082.liftH (h\u2081.descH (h\u2081.i \u226b h\u2082.p) (by simp))\n    (by rw [\u2190 cancel_epi h\u2081.\u03c0, LeftHomologyData.\u03c0_descH_assoc, assoc,\n      RightHomologyData.p_g', LeftHomologyData.wi, comp_zero])", "start": [548, 1], "end": [553, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_liftH", "code": "lemma leftRightHomologyComparison'_eq_liftH :\n    leftRightHomologyComparison' h\u2081 h\u2082 =\n      h\u2082.liftH (h\u2081.descH (h\u2081.i \u226b h\u2082.p) (by simp))\n        (by rw [\u2190 cancel_epi h\u2081.\u03c0, LeftHomologyData.\u03c0_descH_assoc, assoc,\n          RightHomologyData.p_g', LeftHomologyData.wi, comp_zero]) := rfl", "start": [555, 1], "end": [559, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.\u03c0_leftRightHomologyComparison'_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma \u03c0_leftRightHomologyComparison'_\u03b9 :\n    h\u2081.\u03c0 \u226b leftRightHomologyComparison' h\u2081 h\u2082 \u226b h\u2082.\u03b9 = h\u2081.i \u226b h\u2082.p :=\n  by simp only [leftRightHomologyComparison'_eq_liftH,\n    RightHomologyData.liftH_\u03b9, LeftHomologyData.\u03c0_descH]", "start": [561, 1], "end": [565, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_descH", "code": "lemma leftRightHomologyComparison'_eq_descH :\n    leftRightHomologyComparison' h\u2081 h\u2082 =\n      h\u2081.descH (h\u2082.liftH (h\u2081.i \u226b h\u2082.p) (by simp))\n        (by rw [\u2190 cancel_mono h\u2082.\u03b9, assoc, RightHomologyData.liftH_\u03b9,\n          LeftHomologyData.f'_i_assoc, RightHomologyData.wp, zero_comp]) := by\n  simp only [\u2190 cancel_mono h\u2082.\u03b9, \u2190 cancel_epi h\u2081.\u03c0, \u03c0_leftRightHomologyComparison'_\u03b9,\n    LeftHomologyData.\u03c0_descH_assoc, RightHomologyData.liftH_\u03b9]", "start": [567, 1], "end": [573, 63], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison", "code": "noncomputable def leftRightHomologyComparison [S.HasLeftHomology] [S.HasRightHomology] :\n    S.leftHomology \u27f6 S.rightHomology :=\n  leftRightHomologyComparison' _ _", "start": [579, 1], "end": [583, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.\u03c0_leftRightHomologyComparison_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma \u03c0_leftRightHomologyComparison_\u03b9 [S.HasLeftHomology] [S.HasRightHomology] :\n    S.leftHomology\u03c0 \u226b S.leftRightHomologyComparison \u226b S.rightHomology\u03b9 =\n      S.iCycles \u226b S.pOpcycles :=\n  \u03c0_leftRightHomologyComparison'_\u03b9 _ _", "start": [585, 1], "end": [589, 39], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_naturality", "code": "@[reassoc]\nlemma leftRightHomologyComparison'_naturality (\u03c6 : S\u2081 \u27f6 S\u2082) (h\u2081 : S\u2081.LeftHomologyData)\n    (h\u2082 : S\u2081.RightHomologyData) (h\u2081' : S\u2082.LeftHomologyData) (h\u2082' : S\u2082.RightHomologyData) :\n    leftHomologyMap' \u03c6 h\u2081 h\u2081' \u226b leftRightHomologyComparison' h\u2081' h\u2082' =\n      leftRightHomologyComparison' h\u2081 h\u2082 \u226b rightHomologyMap' \u03c6 h\u2082 h\u2082' := by\n  simp only [\u2190 cancel_epi h\u2081.\u03c0, \u2190 cancel_mono h\u2082'.\u03b9, assoc,\n    leftHomology\u03c0_naturality'_assoc, rightHomology\u03b9_naturality',\n    \u03c0_leftRightHomologyComparison'_\u03b9, \u03c0_leftRightHomologyComparison'_\u03b9_assoc,\n    cyclesMap'_i_assoc, p_opcyclesMap']", "start": [591, 1], "end": [599, 40], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_compatibility", "code": "lemma leftRightHomologyComparison'_compatibility (h\u2081 h\u2081' : S.LeftHomologyData)\n    (h\u2082 h\u2082' : S.RightHomologyData) :\n    leftRightHomologyComparison' h\u2081 h\u2082 = leftHomologyMap' (\ud835\udfd9 S) h\u2081 h\u2081' \u226b\n      leftRightHomologyComparison' h\u2081' h\u2082' \u226b rightHomologyMap' (\ud835\udfd9 S) _ _ := by\n  rw [leftRightHomologyComparison'_naturality_assoc (\ud835\udfd9 S) h\u2081 h\u2082 h\u2081' h\u2082',\n    \u2190 rightHomologyMap'_comp, comp_id, rightHomologyMap'_id, comp_id]", "start": [603, 1], "end": [608, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison_eq", "code": "lemma leftRightHomologyComparison_eq [S.HasLeftHomology] [S.HasRightHomology]\n    (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData) :\n    S.leftRightHomologyComparison = h\u2081.leftHomologyIso.hom \u226b\n      leftRightHomologyComparison' h\u2081 h\u2082 \u226b h\u2082.rightHomologyIso.inv :=\n  leftRightHomologyComparison'_compatibility _ _ _ _", "start": [610, 1], "end": [614, 53], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.leftRightHomologyComparison'_eq", "code": "@[simp]\nlemma HomologyData.leftRightHomologyComparison'_eq (h : S.HomologyData) :\n    leftRightHomologyComparison' h.left h.right = h.iso.hom := by\n  simp only [\u2190 cancel_epi h.left.\u03c0, \u2190 cancel_mono h.right.\u03b9,\n    \u03c0_leftRightHomologyComparison'_\u03b9, HomologyData.comm]", "start": [616, 1], "end": [620, 57], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison'_of_homologyData", "code": "instance isIso_leftRightHomologyComparison'_of_homologyData (h : S.HomologyData) :\n  IsIso (leftRightHomologyComparison' h.left h.right) := by\n    rw [h.leftRightHomologyComparison'_eq]\n    infer_instance", "start": [622, 1], "end": [625, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison'", "code": "instance isIso_leftRightHomologyComparison' [S.HasHomology]\n    (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData) :\n    IsIso (leftRightHomologyComparison' h\u2081 h\u2082) := by\n  rw [leftRightHomologyComparison'_compatibility h\u2081 S.homologyData.left h\u2082\n    S.homologyData.right]\n  infer_instance", "start": [627, 1], "end": [632, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison", "code": "instance isIso_leftRightHomologyComparison [S.HasHomology] :\n    IsIso S.leftRightHomologyComparison := by\n  dsimp only [leftRightHomologyComparison]\n  infer_instance", "start": [634, 1], "end": [637, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison'", "code": "@[simps]\nnoncomputable def ofIsIsoLeftRightHomologyComparison'\n    (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h\u2081 h\u2082)] :\n    S.HomologyData where\n  left := h\u2081\n  right := h\u2082\n  iso := asIso (leftRightHomologyComparison' h\u2081 h\u2082)", "start": [641, 1], "end": [651, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'", "code": "lemma leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'\n    (h : S.HomologyData) (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData) :\n    leftRightHomologyComparison' h\u2081 h\u2082 =\n      leftHomologyMap' (\ud835\udfd9 S) h\u2081 h.left \u226b h.iso.hom \u226b rightHomologyMap' (\ud835\udfd9 S) h.right h\u2082 := by\n  simpa only [h.leftRightHomologyComparison'_eq] using\n    leftRightHomologyComparison'_compatibility h\u2081 h.left h\u2082 h.right", "start": [655, 1], "end": [660, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison'_fac", "code": "@[reassoc]\nlemma leftRightHomologyComparison'_fac (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData)\n    [S.HasHomology] :\n    leftRightHomologyComparison' h\u2081 h\u2082 = h\u2081.homologyIso.inv \u226b h\u2082.homologyIso.hom := by\n  rw [leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'\n    S.homologyData h\u2081 h\u2082]\n  dsimp only [LeftHomologyData.homologyIso, LeftHomologyData.leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyMapIso', leftHomologyIso,\n    RightHomologyData.homologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', rightHomologyIso]\n  simp only [assoc, \u2190 leftHomologyMap'_comp_assoc, id_comp, \u2190 rightHomologyMap'_comp]", "start": [662, 1], "end": [672, 86], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftRightHomologyComparison_fac", "code": "@[reassoc]\nlemma leftRightHomologyComparison_fac [S.HasHomology] :\n    S.leftRightHomologyComparison = S.leftHomologyIso.hom \u226b S.rightHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv,\n    RightHomologyData.homologyIso_rightHomologyData, Iso.symm_hom] using\n      leftRightHomologyComparison'_fac S.leftHomologyData S.rightHomologyData", "start": [676, 1], "end": [681, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.right_homologyIso_eq_left_homologyIso_trans_iso", "code": "lemma HomologyData.right_homologyIso_eq_left_homologyIso_trans_iso\n    (h : S.HomologyData) [S.HasHomology] :\n    h.right.homologyIso = h.left.homologyIso \u226a\u226b h.iso := by\n  suffices h.iso = h.left.homologyIso.symm \u226a\u226b h.right.homologyIso by\n    rw [this, Iso.self_symm_id_assoc]\n  ext\n  dsimp\n  rw [\u2190 leftRightHomologyComparison'_fac, leftRightHomologyComparison'_eq]", "start": [685, 1], "end": [692, 75], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_isIso_leftRightHomologyComparison'", "code": "lemma hasHomology_of_isIso_leftRightHomologyComparison'\n    (h\u2081 : S.LeftHomologyData) (h\u2082 : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h\u2081 h\u2082)] :\n    S.HasHomology :=\n  HasHomology.mk' (HomologyData.ofIsIsoLeftRightHomologyComparison' h\u2081 h\u2082)", "start": [694, 1], "end": [698, 75], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_isIsoLeftRightHomologyComparison", "code": "lemma hasHomology_of_isIsoLeftRightHomologyComparison [S.HasLeftHomology]\n    [S.HasRightHomology] [h : IsIso S.leftRightHomologyComparison] :\n    S.HasHomology := by\n  haveI : IsIso (leftRightHomologyComparison' S.leftHomologyData S.rightHomologyData) := h\n  exact hasHomology_of_isIso_leftRightHomologyComparison' S.leftHomologyData S.rightHomologyData", "start": [700, 1], "end": [704, 97], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_hom_naturality\n    (h\u2081 : S\u2081.LeftHomologyData) (h\u2082 : S\u2082.LeftHomologyData) :\n    h\u2081.homologyIso.hom \u226b leftHomologyMap' \u03c6 h\u2081 h\u2082 =\n      homologyMap \u03c6 \u226b h\u2082.homologyIso.hom := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [\u2190 leftHomologyMap'_comp, id_comp, comp_id]", "start": [710, 1], "end": [716, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_inv_naturality\n    (h\u2081 : S\u2081.LeftHomologyData) (h\u2082 : S\u2082.LeftHomologyData) :\n    h\u2081.homologyIso.inv \u226b homologyMap \u03c6 =\n      leftHomologyMap' \u03c6 h\u2081 h\u2082 \u226b h\u2082.homologyIso.inv := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [\u2190 leftHomologyMap'_comp, id_comp, comp_id]", "start": [718, 1], "end": [724, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma leftHomologyIso_hom_naturality :\n    S\u2081.leftHomologyIso.hom \u226b homologyMap \u03c6 =\n      leftHomologyMap \u03c6 \u226b S\u2082.leftHomologyIso.hom := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_inv_naturality \u03c6 S\u2081.leftHomologyData S\u2082.leftHomologyData", "start": [726, 1], "end": [731, 94], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma leftHomologyIso_inv_naturality :\n    S\u2081.leftHomologyIso.inv \u226b leftHomologyMap \u03c6 =\n      homologyMap \u03c6 \u226b S\u2082.leftHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_hom_naturality \u03c6 S\u2081.leftHomologyData S\u2082.leftHomologyData", "start": [733, 1], "end": [738, 94], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma RightHomologyData.rightHomologyIso_hom_naturality\n    (h\u2081 : S\u2081.RightHomologyData) (h\u2082 : S\u2082.RightHomologyData) :\n    h\u2081.homologyIso.hom \u226b rightHomologyMap' \u03c6 h\u2081 h\u2082 =\n      homologyMap \u03c6 \u226b h\u2082.homologyIso.hom := by\n  rw [\u2190 cancel_epi h\u2081.homologyIso.inv, Iso.inv_hom_id_assoc,\n    \u2190 cancel_epi (leftRightHomologyComparison' S\u2081.leftHomologyData h\u2081),\n    \u2190 leftRightHomologyComparison'_naturality \u03c6 S\u2081.leftHomologyData h\u2081 S\u2082.leftHomologyData h\u2082,\n    \u2190 cancel_epi (S\u2081.leftHomologyData.homologyIso.hom),\n    LeftHomologyData.leftHomologyIso_hom_naturality_assoc,\n    leftRightHomologyComparison'_fac, leftRightHomologyComparison'_fac, assoc,\n    Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc]", "start": [740, 1], "end": [751, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma RightHomologyData.rightHomologyIso_inv_naturality\n    (h\u2081 : S\u2081.RightHomologyData) (h\u2082 : S\u2082.RightHomologyData) :\n      h\u2081.homologyIso.inv \u226b homologyMap \u03c6 =\n        rightHomologyMap' \u03c6 h\u2081 h\u2082 \u226b h\u2082.homologyIso.inv := by\n  simp only [\u2190 cancel_mono h\u2082.homologyIso.hom, assoc, Iso.inv_hom_id_assoc, comp_id,\n    \u2190 RightHomologyData.rightHomologyIso_hom_naturality \u03c6 h\u2081 h\u2082, Iso.inv_hom_id]", "start": [753, 1], "end": [759, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.rightHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma rightHomologyIso_hom_naturality :\n    S\u2081.rightHomologyIso.hom \u226b homologyMap \u03c6 =\n      rightHomologyMap \u03c6 \u226b S\u2082.rightHomologyIso.hom := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_inv_naturality \u03c6 S\u2081.rightHomologyData S\u2082.rightHomologyData", "start": [761, 1], "end": [766, 98], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.rightHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma rightHomologyIso_inv_naturality :\n    S\u2081.rightHomologyIso.inv \u226b rightHomologyMap \u03c6 =\n      homologyMap \u03c6 \u226b S\u2082.rightHomologyIso.inv := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_hom_naturality \u03c6 S\u2081.rightHomologyData S\u2082.rightHomologyData", "start": [768, 1], "end": [773, 98], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.CategoryWithHomology", "code": "class _root_.CategoryTheory.CategoryWithHomology : Prop where\n  hasHomology : \u2200 (S : ShortComplex C), S.HasHomology", "start": [779, 1], "end": [782, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyFunctor", "code": "@[simps]\nnoncomputable def homologyFunctor [CategoryWithHomology C] :\n    ShortComplex C \u2964 C where\n  obj S := S.homology\n  map f := homologyMap f", "start": [789, 1], "end": [794, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap'_of_epi_of_isIso_of_mono", "code": "instance isIso_homologyMap'_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (h\u2081 : S\u2081.HomologyData) (h\u2082 : S\u2082.HomologyData) [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    IsIso (homologyMap' \u03c6 h\u2081 h\u2082) := by\n  dsimp only [homologyMap']\n  infer_instance", "start": [798, 1], "end": [802, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_epi_of_isIso_of_mono'", "code": "lemma isIso_homologyMap_of_epi_of_isIso_of_mono' (\u03c6 : S\u2081 \u27f6 S\u2082) [S\u2081.HasHomology] [S\u2082.HasHomology]\n    (h\u2081 : Epi \u03c6.\u03c4\u2081) (h\u2082 : IsIso \u03c6.\u03c4\u2082) (h\u2083 : Mono \u03c6.\u03c4\u2083) :\n    IsIso (homologyMap \u03c6) := by\n  dsimp only [homologyMap]\n  infer_instance", "start": [804, 1], "end": [808, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_epi_of_isIso_of_mono", "code": "instance isIso_homologyMap_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082) [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    IsIso (homologyMap \u03c6) :=\n  isIso_homologyMap_of_epi_of_isIso_of_mono' \u03c6 inferInstance inferInstance inferInstance", "start": [810, 1], "end": [813, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyFunctor_map_of_epi_of_isIso_of_mono", "code": "instance isIso_homologyFunctor_map_of_epi_of_isIso_of_mono (\u03c6 : S\u2081 \u27f6 S\u2082) [CategoryWithHomology C]\n    [Epi \u03c6.\u03c4\u2081] [IsIso \u03c6.\u03c4\u2082] [Mono \u03c6.\u03c4\u2083] :\n    IsIso ((homologyFunctor C).map \u03c6) :=\n  (inferInstance : IsIso (homologyMap \u03c6))", "start": [815, 1], "end": [818, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso", "code": "instance isIso_homologyMap_of_isIso (\u03c6 : S\u2081 \u27f6 S\u2082) [S\u2081.HasHomology] [S\u2082.HasHomology] [IsIso \u03c6] :\n    IsIso (homologyMap \u03c6) := by\n  dsimp only [homologyMap, homologyMap']\n  infer_instance", "start": [820, 1], "end": [823, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03c0", "code": "noncomputable def homology\u03c0 : S.cycles \u27f6 S.homology :=\n  S.leftHomology\u03c0 \u226b S.leftHomologyIso.hom", "start": [830, 1], "end": [832, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03b9", "code": "noncomputable def homology\u03b9 : S.homology \u27f6 S.opcycles :=\n  S.rightHomologyIso.inv \u226b S.rightHomology\u03b9", "start": [834, 1], "end": [836, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03c0_comp_leftHomologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma homology\u03c0_comp_leftHomologyIso_inv:\n    S.homology\u03c0 \u226b S.leftHomologyIso.inv = S.leftHomology\u03c0 := by\n  dsimp only [homology\u03c0]\n  simp only [assoc, Iso.hom_inv_id, comp_id]", "start": [838, 1], "end": [842, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.rightHomologyIso_hom_comp_homology\u03b9", "code": "@[reassoc (attr := simp)]\nlemma rightHomologyIso_hom_comp_homology\u03b9 :\n    S.rightHomologyIso.hom \u226b S.homology\u03b9 = S.rightHomology\u03b9 := by\n  dsimp only [homology\u03b9]\n  simp only [Iso.hom_inv_id_assoc]", "start": [844, 1], "end": [848, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.toCycles_comp_homology\u03c0", "code": "@[reassoc (attr := simp)]\nlemma toCycles_comp_homology\u03c0 :\n    S.toCycles \u226b S.homology\u03c0 = 0 := by\n  dsimp only [homology\u03c0]\n  simp only [toCycles_comp_leftHomology\u03c0_assoc, zero_comp]", "start": [850, 1], "end": [854, 59], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03b9_comp_fromOpcycles", "code": "@[reassoc (attr := simp)]\nlemma homology\u03b9_comp_fromOpcycles :\n    S.homology\u03b9 \u226b S.fromOpcycles = 0 := by\n  dsimp only [homology\u03b9]\n  simp only [assoc, rightHomology\u03b9_comp_fromOpcycles, comp_zero]", "start": [856, 1], "end": [860, 65], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyIsCokernel", "code": "noncomputable def homologyIsCokernel :\n    IsColimit (CokernelCofork.of\u03c0 S.homology\u03c0 S.toCycles_comp_homology\u03c0) :=\n  IsColimit.ofIsoColimit S.leftHomologyIsCokernel\n    (Cofork.ext S.leftHomologyIso rfl)", "start": [862, 1], "end": [867, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyIsKernel", "code": "noncomputable def homologyIsKernel :\n    IsLimit (KernelFork.of\u03b9 S.homology\u03b9 S.homology\u03b9_comp_fromOpcycles) :=\n  IsLimit.ofIsoLimit S.rightHomologyIsKernel\n    (Fork.ext S.rightHomologyIso (by simp))", "start": [869, 1], "end": [874, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.descHomology", "code": "noncomputable def descHomology (k : S.cycles \u27f6 A) (hk : S.toCycles \u226b k = 0) :\n    S.homology \u27f6 A :=\n  S.homologyIsCokernel.desc (CokernelCofork.of\u03c0 k hk)", "start": [882, 1], "end": [886, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.liftHomology", "code": "noncomputable def liftHomology (k : A \u27f6 S.opcycles) (hk : k \u226b S.fromOpcycles = 0) :\n    A \u27f6 S.homology :=\n  S.homologyIsKernel.lift (KernelFork.of\u03b9 k hk)", "start": [888, 1], "end": [892, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.\u03c0_descHomology", "code": "@[reassoc (attr := simp)]\nlemma \u03c0_descHomology (k : S.cycles \u27f6 A) (hk : S.toCycles \u226b k = 0) :\n    S.homology\u03c0 \u226b S.descHomology k hk = k :=\n  Cofork.IsColimit.\u03c0_desc S.homologyIsCokernel", "start": [894, 1], "end": [897, 47], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.liftHomology_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma liftHomology_\u03b9 (k : A \u27f6 S.opcycles) (hk : k \u226b S.fromOpcycles = 0) :\n    S.liftHomology k hk \u226b S.homology\u03b9 = k :=\n  Fork.IsLimit.lift_\u03b9 S.homologyIsKernel", "start": [899, 1], "end": [902, 41], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03c0_naturality", "code": "@[reassoc (attr := simp)]\nlemma homology\u03c0_naturality (\u03c6 : S\u2081 \u27f6 S\u2082) [S\u2081.HasHomology] [S\u2082.HasHomology] :\n    S\u2081.homology\u03c0 \u226b homologyMap \u03c6 = cyclesMap \u03c6 \u226b S\u2082.homology\u03c0 := by\n  simp only [\u2190 cancel_mono S\u2082.leftHomologyIso.inv, assoc, \u2190 leftHomologyIso_inv_naturality \u03c6,\n    homology\u03c0_comp_leftHomologyIso_inv]\n  simp only [homology\u03c0, assoc, Iso.hom_inv_id_assoc, leftHomology\u03c0_naturality]", "start": [904, 1], "end": [909, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03b9_naturality", "code": "@[reassoc (attr := simp)]\nlemma homology\u03b9_naturality (\u03c6 : S\u2081 \u27f6 S\u2082) [S\u2081.HasHomology] [S\u2082.HasHomology] :\n    homologyMap \u03c6 \u226b S\u2082.homology\u03b9 = S\u2081.homology\u03b9 \u226b S\u2081.opcyclesMap \u03c6  := by\n  simp only [\u2190 cancel_epi S\u2081.rightHomologyIso.hom, rightHomologyIso_hom_naturality_assoc \u03c6,\n    rightHomologyIso_hom_comp_homology\u03b9, rightHomology\u03b9_naturality]\n  simp only [homology\u03b9, assoc, Iso.hom_inv_id_assoc]", "start": [911, 1], "end": [916, 53], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology_\u03c0_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma homology_\u03c0_\u03b9 :\n    S.homology\u03c0 \u226b S.homology\u03b9 = S.iCycles \u226b S.pOpcycles := by\n  dsimp only [homology\u03c0, homology\u03b9]\n  simpa only [assoc, S.leftRightHomologyComparison_fac] using S.\u03c0_leftRightHomologyComparison_\u03b9", "start": [918, 1], "end": [922, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyIsoKernelDesc", "code": "noncomputable def homologyIsoKernelDesc [S.HasHomology] [HasCokernel S.f]\n    [HasKernel (cokernel.desc S.f S.g S.zero)] :\n  S.homology \u2245 kernel (cokernel.desc S.f S.g S.zero) :=\n    S.rightHomologyIso.symm \u226a\u226b S.rightHomologyIsoKernelDesc", "start": [924, 1], "end": [929, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyIsoCokernelLift", "code": "noncomputable def homologyIsoCokernelLift [S.HasHomology] [HasKernel S.g]\n    [HasCokernel (kernel.lift S.g S.f S.zero)] :\n  S.homology \u2245 cokernel (kernel.lift S.g S.f S.zero) :=\n    S.leftHomologyIso.symm \u226a\u226b S.leftHomologyIsoCokernelLift", "start": [931, 1], "end": [936, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.homology\u03c0_comp_homologyIso_hom", "code": "@[reassoc (attr := simp)]\nlemma LeftHomologyData.homology\u03c0_comp_homologyIso_hom (h : S.LeftHomologyData) [S.HasHomology] :\n    S.homology\u03c0 \u226b h.homologyIso.hom = h.cyclesIso.hom \u226b h.\u03c0 := by\n  dsimp only [homology\u03c0, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id_assoc,\n    leftHomology\u03c0_comp_leftHomologyIso_hom]", "start": [938, 1], "end": [943, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.\u03c0_comp_homologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma LeftHomologyData.\u03c0_comp_homologyIso_inv (h : S.LeftHomologyData) [S.HasHomology] :\n    h.\u03c0 \u226b h.homologyIso.inv = h.cyclesIso.inv \u226b S.homology\u03c0 := by\n  dsimp only [homology\u03c0, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, \u03c0_comp_leftHomologyIso_inv_assoc]", "start": [945, 1], "end": [949, 76], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.homologyIso_inv_comp_homology\u03b9", "code": "@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_inv_comp_homology\u03b9\n    (h : S.RightHomologyData) [S.HasHomology] :\n    h.homologyIso.inv \u226b S.homology\u03b9 = h.\u03b9 \u226b h.opcyclesIso.inv := by\n  dsimp only [homology\u03b9, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, assoc, Iso.hom_inv_id_assoc,\n    rightHomologyIso_inv_comp_rightHomology\u03b9]", "start": [951, 1], "end": [957, 46], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_\u03b9\n    (h : S.RightHomologyData) [S.HasHomology] :\n    h.homologyIso.hom \u226b h.\u03b9 = S.homology\u03b9 \u226b h.opcyclesIso.hom := by\n  dsimp only [homology\u03b9, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, rightHomologyIso_hom_comp_\u03b9]", "start": [959, 1], "end": [964, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv\n    (h : S.LeftHomologyData) [S.HasHomology] :\n    h.homologyIso.hom \u226b h.leftHomologyIso.inv = S.leftHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]", "start": [966, 1], "end": [971, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv\n    (h : S.LeftHomologyData) [S.HasHomology] :\n    h.leftHomologyIso.hom \u226b h.homologyIso.inv = S.leftHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]", "start": [973, 1], "end": [978, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv\n    (h : S.RightHomologyData) [S.HasHomology] :\n    h.homologyIso.hom \u226b h.rightHomologyIso.inv = S.rightHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]", "start": [980, 1], "end": [985, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv", "code": "@[reassoc (attr := simp)]\nlemma RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv\n    (h : S.RightHomologyData) [S.HasHomology] :\n    h.rightHomologyIso.hom \u226b h.homologyIso.inv = S.rightHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]", "start": [987, 1], "end": [992, 64], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.comp_homologyMap_comp", "code": "@[reassoc]\nlemma comp_homologyMap_comp [S\u2081.HasHomology] [S\u2082.HasHomology] (\u03c6 : S\u2081 \u27f6 S\u2082)\n    (h\u2081 : S\u2081.LeftHomologyData) (h\u2082 : S\u2082.RightHomologyData) :\n    h\u2081.\u03c0 \u226b h\u2081.homologyIso.inv \u226b homologyMap \u03c6 \u226b h\u2082.homologyIso.hom \u226b h\u2082.\u03b9 =\n      h\u2081.i \u226b \u03c6.\u03c4\u2082 \u226b h\u2082.p := by\n  dsimp only [LeftHomologyData.homologyIso, RightHomologyData.homologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyIso, rightHomologyIso,\n    leftHomologyMapIso', rightHomologyMapIso',\n    LeftHomologyData.cyclesIso, RightHomologyData.opcyclesIso,\n    LeftHomologyData.leftHomologyIso, RightHomologyData.rightHomologyIso,\n    homologyMap, homologyMap']\n  simp only [assoc, rightHomology\u03b9_naturality', rightHomology\u03b9_naturality'_assoc,\n    leftHomology\u03c0_naturality'_assoc, HomologyData.comm_assoc, p_opcyclesMap'_assoc,\n    id_\u03c4\u2082, p_opcyclesMap', id_comp, cyclesMap'_i_assoc]", "start": [994, 1], "end": [1007, 56], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.\u03c0_homologyMap_\u03b9", "code": "@[reassoc]\nlemma \u03c0_homologyMap_\u03b9 [S\u2081.HasHomology] [S\u2082.HasHomology] (\u03c6 : S\u2081 \u27f6 S\u2082) :\n    S\u2081.homology\u03c0 \u226b homologyMap \u03c6 \u226b S\u2082.homology\u03b9 = S\u2081.iCycles \u226b \u03c6.\u03c4\u2082 \u226b S\u2082.pOpcycles := by\n  simp only [homology\u03b9_naturality, homology_\u03c0_\u03b9_assoc, p_opcyclesMap]", "start": [1009, 1], "end": [1012, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyOpIso", "code": "noncomputable def homologyOpIso [S.HasHomology] :\n    S.op.homology \u2245 Opposite.op S.homology :=\n  S.op.leftHomologyIso.symm \u226a\u226b S.leftHomologyOpIso \u226a\u226b S.rightHomologyIso.symm.op", "start": [1018, 1], "end": [1022, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap'_op", "code": "lemma homologyMap'_op : (homologyMap' \u03c6 h\u2081 h\u2082).op =\n    h\u2082.iso.inv.op \u226b homologyMap' (opMap \u03c6) h\u2082.op h\u2081.op \u226b h\u2081.iso.hom.op :=\n  Quiver.Hom.unop_inj (by\n    dsimp\n    have \u03b3 : HomologyMapData \u03c6 h\u2081 h\u2082 := default\n    simp only [\u03b3.homologyMap'_eq, \u03b3.op.homologyMap'_eq, HomologyData.op_left,\n      HomologyMapData.op_left, RightHomologyMapData.op_\u03c6H, Quiver.Hom.unop_op, assoc,\n      \u2190 \u03b3.comm_assoc, Iso.hom_inv_id, comp_id])", "start": [1024, 1], "end": [1031, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap_op", "code": "lemma homologyMap_op [HasHomology S\u2081] [HasHomology S\u2082] :\n    (homologyMap \u03c6).op =\n      (S\u2082.homologyOpIso).inv \u226b homologyMap (opMap \u03c6) \u226b (S\u2081.homologyOpIso).hom := by\n  dsimp only [homologyMap, homologyOpIso]\n  rw [homologyMap'_op]\n  dsimp only [Iso.symm, Iso.trans, Iso.op, Iso.refl, rightHomologyIso, leftHomologyIso,\n    leftHomologyOpIso, leftHomologyMapIso', rightHomologyMapIso',\n    LeftHomologyData.leftHomologyIso, homologyMap']\n  simp only [assoc, rightHomologyMap'_op, op_comp, \u2190 leftHomologyMap'_comp_assoc, id_comp,\n    opMap_id, comp_id, HomologyData.op_left]", "start": [1033, 1], "end": [1042, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homologyFunctorOpNatIso", "code": "noncomputable def homologyFunctorOpNatIso [CategoryWithHomology C] :\n    (homologyFunctor C).op \u2245 opFunctor C \u22d9 homologyFunctor C\u1d52\u1d56 :=\n  NatIso.ofComponents (fun S => S.unop.homologyOpIso.symm)\n    (by simp [homologyMap_op])", "start": [1046, 1], "end": [1051, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.liftCycles_homology\u03c0_eq_zero_of_boundary", "code": "lemma liftCycles_homology\u03c0_eq_zero_of_boundary [S.HasHomology]\n    (k : A \u27f6 S.X\u2082) (x : A \u27f6 S.X\u2081) (hx : k = x \u226b S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) \u226b S.homology\u03c0 = 0 := by\n  dsimp only [homology\u03c0]\n  rw [S.liftCycles_leftHomology\u03c0_eq_zero_of_boundary_assoc k x hx, zero_comp]", "start": [1055, 1], "end": [1059, 78], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03b9_descOpcycles_\u03c0_eq_zero_of_boundary", "code": "@[reassoc]\nlemma homology\u03b9_descOpcycles_\u03c0_eq_zero_of_boundary [S.HasHomology]\n    (k : S.X\u2082 \u27f6 A) (x : S.X\u2083 \u27f6 A) (hx : k = S.g \u226b x) :\n    S.homology\u03b9 \u226b S.descOpcycles k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by\n  dsimp only [homology\u03b9]\n  rw [assoc, S.rightHomology\u03b9_descOpcycles_\u03c0_eq_zero_of_boundary k x hx, comp_zero]", "start": [1061, 1], "end": [1066, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso_cyclesMap_of_epi", "code": "lemma isIso_homologyMap_of_isIso_cyclesMap_of_epi {\u03c6 : S\u2081 \u27f6 S\u2082}\n    [S\u2081.HasHomology] [S\u2082.HasHomology] (h\u2081 : IsIso (cyclesMap \u03c6)) (h\u2082 : Epi \u03c6.\u03c4\u2081) :\n    IsIso (homologyMap \u03c6) := by\n  have h : S\u2082.toCycles \u226b inv (cyclesMap \u03c6) \u226b S\u2081.homology\u03c0 = 0 := by\n    simp only [\u2190 cancel_epi \u03c6.\u03c4\u2081, \u2190 toCycles_naturality_assoc,\n      IsIso.hom_inv_id_assoc, toCycles_comp_homology\u03c0, comp_zero]\n  have \u27e8z, hz\u27e9 := CokernelCofork.IsColimit.desc' S\u2082.homologyIsCokernel _ h\n  dsimp at hz\n  refine' \u27e8\u27e8z, _, _\u27e9\u27e9\n  \u00b7 rw [\u2190 cancel_epi S\u2081.homology\u03c0, homology\u03c0_naturality_assoc, hz,\n      IsIso.hom_inv_id_assoc, comp_id]\n  \u00b7 rw [\u2190 cancel_epi S\u2082.homology\u03c0, reassoc_of% hz, homology\u03c0_naturality,\n      IsIso.inv_hom_id_assoc, comp_id]", "start": [1068, 1], "end": [1080, 39], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso_opcyclesMap_of_mono", "code": "lemma isIso_homologyMap_of_isIso_opcyclesMap_of_mono {\u03c6 : S\u2081 \u27f6 S\u2082}\n    [S\u2081.HasHomology] [S\u2082.HasHomology] (h\u2081 : IsIso (opcyclesMap \u03c6)) (h\u2082 : Mono \u03c6.\u03c4\u2083) :\n    IsIso (homologyMap \u03c6) := by\n  have h : (S\u2082.homology\u03b9 \u226b inv (opcyclesMap \u03c6)) \u226b S\u2081.fromOpcycles = 0 := by\n    simp only [\u2190 cancel_mono \u03c6.\u03c4\u2083, zero_comp, assoc, \u2190 fromOpcycles_naturality,\n      IsIso.inv_hom_id_assoc, homology\u03b9_comp_fromOpcycles]\n  have \u27e8z, hz\u27e9 := KernelFork.IsLimit.lift' S\u2081.homologyIsKernel _ h\n  dsimp at hz\n  refine' \u27e8\u27e8z, _, _\u27e9\u27e9\n  \u00b7 rw [\u2190 cancel_mono S\u2081.homology\u03b9, id_comp, assoc, hz, homology\u03b9_naturality_assoc,\n      IsIso.hom_inv_id, comp_id]\n  \u00b7 rw [\u2190 cancel_mono S\u2082.homology\u03b9, assoc, homology\u03b9_naturality, reassoc_of% hz,\n      IsIso.inv_hom_id, comp_id, id_comp]", "start": [1082, 1], "end": [1094, 42], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isZero_homology_of_isZero_X\u2082", "code": "lemma isZero_homology_of_isZero_X\u2082 (hS : IsZero S.X\u2082) [S.HasHomology] :\n    IsZero S.homology :=\n  IsZero.of_iso hS (HomologyData.ofZeros S (hS.eq_of_tgt _ _)\n    (hS.eq_of_src _ _)).left.homologyIso", "start": [1096, 1], "end": [1099, 41], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homology\u03c0", "code": "lemma isIso_homology\u03c0 (hf : S.f = 0) [S.HasHomology] :\n    IsIso S.homology\u03c0 := by\n  have := S.isIso_leftHomology\u03c0 hf\n  dsimp only [homology\u03c0]\n  infer_instance", "start": [1101, 1], "end": [1105, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.isIso_homology\u03b9", "code": "lemma isIso_homology\u03b9 (hg : S.g = 0) [S.HasHomology] :\n    IsIso S.homology\u03b9 := by\n  have := S.isIso_rightHomology\u03b9 hg\n  dsimp only [homology\u03b9]\n  infer_instance", "start": [1107, 1], "end": [1111, 17], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.asIsoHomology\u03c0", "code": "@[simps! hom]\nnoncomputable def asIsoHomology\u03c0 (hf : S.f = 0) [S.HasHomology] :\n    S.cycles \u2245 S.homology := by\n  have := S.isIso_homology\u03c0 hf\n  exact asIso S.homology\u03c0", "start": [1113, 1], "end": [1118, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.asIsoHomology\u03c0_inv_comp_homology\u03c0", "code": "@[reassoc (attr := simp)]\nlemma asIsoHomology\u03c0_inv_comp_homology\u03c0 (hf : S.f = 0) [S.HasHomology] :\n    (S.asIsoHomology\u03c0 hf).inv \u226b S.homology\u03c0 = \ud835\udfd9 _ := Iso.inv_hom_id _", "start": [1120, 1], "end": [1122, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03c0_comp_asIsoHomology\u03c0_inv", "code": "@[reassoc (attr := simp)]\nlemma homology\u03c0_comp_asIsoHomology\u03c0_inv (hf : S.f = 0) [S.HasHomology] :\n    S.homology\u03c0 \u226b (S.asIsoHomology\u03c0 hf).inv  = \ud835\udfd9 _ := (S.asIsoHomology\u03c0 hf).hom_inv_id", "start": [1124, 1], "end": [1126, 87], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.asIsoHomology\u03b9", "code": "@[simps! hom]\nnoncomputable def asIsoHomology\u03b9 (hg : S.g = 0) [S.HasHomology] :\n    S.homology \u2245 S.opcycles := by\n  have := S.isIso_homology\u03b9 hg\n  exact asIso S.homology\u03b9", "start": [1128, 1], "end": [1133, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.asIsoHomology\u03b9_inv_comp_homology\u03b9", "code": "@[reassoc (attr := simp)]\nlemma asIsoHomology\u03b9_inv_comp_homology\u03b9 (hg : S.g = 0) [S.HasHomology] :\n    (S.asIsoHomology\u03b9 hg).inv \u226b S.homology\u03b9 = \ud835\udfd9 _ := Iso.inv_hom_id _", "start": [1135, 1], "end": [1137, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.homology\u03b9_comp_asIsoHomology\u03b9_inv", "code": "@[reassoc (attr := simp)]\nlemma homology\u03b9_comp_asIsoHomology\u03b9_inv (hg : S.g = 0) [S.HasHomology] :\n    S.homology\u03b9 \u226b (S.asIsoHomology\u03b9 hg).inv  = \ud835\udfd9 _ := (S.asIsoHomology\u03b9 hg).hom_inv_id", "start": [1139, 1], "end": [1141, 87], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mono_homologyMap_of_mono_opcyclesMap'", "code": "lemma mono_homologyMap_of_mono_opcyclesMap'\n    [S\u2081.HasHomology] [S\u2082.HasHomology] (h : Mono (opcyclesMap \u03c6)) :\n    Mono (homologyMap \u03c6) := by\n  have : Mono (homologyMap \u03c6 \u226b S\u2082.homology\u03b9) := by\n    rw [homology\u03b9_naturality \u03c6]\n    apply mono_comp\n  exact mono_of_mono (homologyMap \u03c6) S\u2082.homology\u03b9", "start": [1143, 1], "end": [1149, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mono_homologyMap_of_mono_opcyclesMap", "code": "instance mono_homologyMap_of_mono_opcyclesMap\n    [S\u2081.HasHomology] [S\u2082.HasHomology] [Mono (opcyclesMap \u03c6)] :\n    Mono (homologyMap \u03c6) :=\n  mono_homologyMap_of_mono_opcyclesMap' \u03c6 inferInstance", "start": [1151, 1], "end": [1154, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.epi_homologyMap_of_epi_cyclesMap'", "code": "lemma epi_homologyMap_of_epi_cyclesMap'\n    [S\u2081.HasHomology] [S\u2082.HasHomology] (h : Epi (cyclesMap \u03c6)) :\n    Epi (homologyMap \u03c6) := by\n  have : Epi (S\u2081.homology\u03c0 \u226b homologyMap \u03c6) := by\n    rw [homology\u03c0_naturality \u03c6]\n    apply epi_comp\n  exact epi_of_epi S\u2081.homology\u03c0 (homologyMap \u03c6)", "start": [1156, 1], "end": [1162, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.epi_homologyMap_of_epi_cyclesMap", "code": "instance epi_homologyMap_of_epi_cyclesMap\n    [S\u2081.HasHomology] [S\u2082.HasHomology] [Epi (cyclesMap \u03c6)] :\n    Epi (homologyMap \u03c6) :=\n  epi_homologyMap_of_epi_cyclesMap' \u03c6 inferInstance", "start": [1164, 1], "end": [1167, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/CountableCover.lean", "imports": ["Mathlib/Order/Filter/Basic.lean", "Mathlib/SetTheory/Cardinal/Ordinal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Cardinal.mk_subtype_le_of_countable_eventually_mem_aux", "code": "lemma mk_subtype_le_of_countable_eventually_mem_aux {\u03b1 \u03b9 : Type u} {a : Cardinal}\n    [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b9} [NeBot l]\n    {t : Set \u03b1} (ht : \u2200 x \u2208 t, \u2200\u1da0 i in l, x \u2208 f i)\n    (h'f : \u2200 i, #(f i) \u2264 a) : #t \u2264 a := by\n  rcases lt_or_le a \u2135\u2080 with ha|ha\n  \n  \u00b7 obtain \u27e8n, rfl\u27e9 : \u2203 (n : \u2115), a = n := lt_aleph0.1 ha\n    apply mk_le_iff_forall_finset_subset_card_le.2 (fun s hs \u21a6 ?_)\n    have A : \u2200 x \u2208 s, \u2200\u1da0 i in l, x \u2208 f i := fun x hx \u21a6 ht x (hs hx)\n    have B : \u2200\u1da0 i in l, \u2200 x \u2208 s, x \u2208 f i := (s.eventually_all).2 A\n    rcases B.exists with \u27e8i, hi\u27e9\n    have : \u2200 i, Fintype (f i) := fun i \u21a6 (lt_aleph0_iff_fintype.1 ((h'f i).trans_lt ha)).some\n    let u : Finset \u03b1 := (f i).toFinset\n    have I1 : s.card \u2264 u.card := by\n      have : s \u2286 u := fun x hx \u21a6 by simpa only [Set.mem_toFinset] using hi x hx\n      exact Finset.card_le_of_subset this\n    have I2: (u.card : Cardinal) \u2264 n := by\n      convert h'f i; simp only [Set.toFinset_card, mk_fintype]\n    exact I1.trans (Nat.cast_le.1 I2)\n  \u00b7 have : t \u2286 \u22c3 i, f i := by\n      intro x hx\n      obtain \u27e8i, hi\u27e9 : \u2203 i, x \u2208 f i := (ht x hx).exists\n      exact mem_iUnion_of_mem i hi\n    calc #t \u2264 #(\u22c3 i, f i) := mk_le_mk_of_subset this\n      _     \u2264 sum (fun i \u21a6 #(f i)) := mk_iUnion_le_sum_mk\n      _     \u2264 sum (fun _ \u21a6 a) := sum_le_sum _ _ h'f\n      _     = #\u03b9 * a := by simp\n      _     \u2264 \u2135\u2080 * a := mul_le_mul_right' mk_le_aleph0 a\n      _     = a := aleph0_mul_eq ha", "start": [26, 1], "end": [61, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.mk_subtype_le_of_countable_eventually_mem", "code": "lemma mk_subtype_le_of_countable_eventually_mem {\u03b1 : Type u} {\u03b9 : Type v} {a : Cardinal}\n    [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b9} [NeBot l]\n    {t : Set \u03b1} (ht : \u2200 x \u2208 t, \u2200\u1da0 i in l, x \u2208 f i)\n    (h'f : \u2200 i, #(f i) \u2264 a) : #t \u2264 a := by\n  let g : ULift.{u, v} \u03b9 \u2192 Set (ULift.{v, u} \u03b1) := (ULift.down \u207b\u00b9' \u00b7) \u2218 f \u2218 ULift.down\n  suffices #(ULift.down.{v} \u207b\u00b9' t) \u2264 Cardinal.lift.{v, u} a by simpa\n  let l' : Filter (ULift.{u} \u03b9) := Filter.map ULift.up l\n  have : NeBot l' := map_neBot\n  apply mk_subtype_le_of_countable_eventually_mem_aux (\u03b9 := ULift.{u} \u03b9) (l := l') (f := g)\n  \u00b7 intro x hx\n    simpa only [Function.comp_apply, mem_preimage, eventually_map] using ht _ hx\n  \u00b7 intro i\n    simpa using h'f i.down", "start": [63, 1], "end": [77, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.mk_le_of_countable_eventually_mem", "code": "lemma mk_le_of_countable_eventually_mem {\u03b1 : Type u} {\u03b9 : Type v} {a : Cardinal}\n    [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b9} [NeBot l] (ht : \u2200 x, \u2200\u1da0 i in l, x \u2208 f i)\n    (h'f : \u2200 i, #(f i) \u2264 a) : #\u03b1 \u2264 a := by\n  rw [\u2190 mk_univ]\n  exact mk_subtype_le_of_countable_eventually_mem (l := l) (fun x _ \u21a6 ht x) h'f", "start": [79, 1], "end": [85, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.mk_of_countable_eventually_mem", "code": "lemma mk_of_countable_eventually_mem {\u03b1 : Type u} {\u03b9 : Type v} {a : Cardinal}\n    [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b9} [NeBot l] (ht : \u2200 x, \u2200\u1da0 i in l, x \u2208 f i)\n    (h'f : \u2200 i, #(f i) = a) : #\u03b1 = a := by\n  apply le_antisymm\n  \u00b7 apply mk_le_of_countable_eventually_mem ht (fun i \u21a6 (h'f i).le)\n  \u00b7 obtain \u27e8i\u27e9 : Nonempty \u03b9 := nonempty_of_neBot l\n    rw [\u2190 (h'f i)]\n    exact mk_set_le (f i)", "start": [87, 1], "end": [96, 26], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two", "code": "theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    \u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2", "start": [46, 1], "end": [50, 50], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq'", "code": "theorem norm_add_sq_eq_norm_sq_add_norm_sq' (x y : V) (h : angle x y = \u03c0 / 2) :\n    \u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016", "start": [53, 1], "end": [56, 71], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two", "code": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2", "start": [59, 1], "end": [63, 50], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq'", "code": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq' (x y : V) (h : angle x y = \u03c0 / 2) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016", "start": [66, 1], "end": [69, 71], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero", "code": "theorem angle_add_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x + y) = Real.arccos (\u2016x\u2016 / \u2016x + y\u2016)", "start": [72, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_eq_arcsin_of_inner_eq_zero", "code": "theorem angle_add_eq_arcsin_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    angle x (x + y) = Real.arcsin (\u2016y\u2016 / \u2016x + y\u2016)", "start": [80, 1], "end": [95, 63], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_eq_arctan_of_inner_eq_zero", "code": "theorem angle_add_eq_arctan_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x + y) = Real.arctan (\u2016y\u2016 / \u2016x\u2016)", "start": [98, 1], "end": [105, 101], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_pos_of_inner_eq_zero", "code": "theorem angle_add_pos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    0 < angle x (x + y)", "start": [108, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_le_pi_div_two_of_inner_eq_zero", "code": "theorem angle_add_le_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x + y) \u2264 \u03c0 / 2", "start": [119, 1], "end": [123, 51], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_lt_pi_div_two_of_inner_eq_zero", "code": "theorem angle_add_lt_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x + y) < \u03c0 / 2", "start": [126, 1], "end": [132, 67], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_add_of_inner_eq_zero", "code": "theorem cos_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x + y)) = \u2016x\u2016 / \u2016x + y\u2016", "start": [135, 1], "end": [143, 51], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_add_of_inner_eq_zero", "code": "theorem sin_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    Real.sin (angle x (x + y)) = \u2016y\u2016 / \u2016x + y\u2016", "start": [146, 1], "end": [154, 50], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.tan_angle_add_of_inner_eq_zero", "code": "theorem tan_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.tan (angle x (x + y)) = \u2016y\u2016 / \u2016x\u2016", "start": [157, 1], "end": [161, 66], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_add_mul_norm_of_inner_eq_zero", "code": "theorem cos_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x + y)) * \u2016x + y\u2016 = \u2016x\u2016", "start": [164, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero", "code": "theorem sin_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.sin (angle x (x + y)) * \u2016x + y\u2016 = \u2016y\u2016", "start": [177, 1], "end": [188, 101], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.tan_angle_add_mul_norm_of_inner_eq_zero", "code": "theorem tan_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    Real.tan (angle x (x + y)) * \u2016x\u2016 = \u2016y\u2016", "start": [191, 1], "end": [196, 41], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_cos_angle_add_of_inner_eq_zero", "code": "theorem norm_div_cos_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    \u2016x\u2016 / Real.cos (angle x (x + y)) = \u2016x + y\u2016", "start": [199, 1], "end": [206, 14], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_sin_angle_add_of_inner_eq_zero", "code": "theorem norm_div_sin_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.sin (angle x (x + y)) = \u2016x + y\u2016", "start": [209, 1], "end": [215, 51], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero", "code": "theorem norm_div_tan_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.tan (angle x (x + y)) = \u2016x\u2016", "start": [218, 1], "end": [225, 101], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero", "code": "theorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x - y) = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016)", "start": [228, 1], "end": [232, 62], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_eq_arcsin_of_inner_eq_zero", "code": "theorem angle_sub_eq_arcsin_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    angle x (x - y) = Real.arcsin (\u2016y\u2016 / \u2016x - y\u2016)", "start": [235, 1], "end": [240, 75], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_eq_arctan_of_inner_eq_zero", "code": "theorem angle_sub_eq_arctan_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x - y) = Real.arctan (\u2016y\u2016 / \u2016x\u2016)", "start": [243, 1], "end": [247, 75], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_pos_of_inner_eq_zero", "code": "theorem angle_sub_pos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    0 < angle x (x - y)", "start": [250, 1], "end": [257, 44], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_le_pi_div_two_of_inner_eq_zero", "code": "theorem angle_sub_le_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x - y) \u2264 \u03c0 / 2", "start": [260, 1], "end": [265, 51], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_lt_pi_div_two_of_inner_eq_zero", "code": "theorem angle_sub_lt_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x - y) < \u03c0 / 2", "start": [268, 1], "end": [274, 54], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_sub_of_inner_eq_zero", "code": "theorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x - y)) = \u2016x\u2016 / \u2016x - y\u2016", "start": [277, 1], "end": [282, 56], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_sub_of_inner_eq_zero", "code": "theorem sin_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    Real.sin (angle x (x - y)) = \u2016y\u2016 / \u2016x - y\u2016", "start": [285, 1], "end": [291, 69], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.tan_angle_sub_of_inner_eq_zero", "code": "theorem tan_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.tan (angle x (x - y)) = \u2016y\u2016 / \u2016x\u2016", "start": [294, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_sub_mul_norm_of_inner_eq_zero", "code": "theorem cos_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x - y)) * \u2016x - y\u2016 = \u2016x\u2016", "start": [302, 1], "end": [307, 65], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_sub_mul_norm_of_inner_eq_zero", "code": "theorem sin_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.sin (angle x (x - y)) * \u2016x - y\u2016 = \u2016y\u2016", "start": [310, 1], "end": [315, 75], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.tan_angle_sub_mul_norm_of_inner_eq_zero", "code": "theorem tan_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    Real.tan (angle x (x - y)) * \u2016x\u2016 = \u2016y\u2016", "start": [318, 1], "end": [324, 78], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_cos_angle_sub_of_inner_eq_zero", "code": "theorem norm_div_cos_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    \u2016x\u2016 / Real.cos (angle x (x - y)) = \u2016x - y\u2016", "start": [327, 1], "end": [333, 68], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_sin_angle_sub_of_inner_eq_zero", "code": "theorem norm_div_sin_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.sin (angle x (x - y)) = \u2016x - y\u2016", "start": [336, 1], "end": [342, 80], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_div_tan_angle_sub_of_inner_eq_zero", "code": "theorem norm_div_tan_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.tan (angle x (x - y)) = \u2016x\u2016", "start": [345, 1], "end": [351, 80], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two", "code": "theorem dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two (p1 p2 p3 : P) :\n    dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 \u2194\n      \u2220 p1 p2 p3 = \u03c0 / 2", "start": [363, 1], "end": [369, 75], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_arccos_of_angle_eq_pi_div_two", "code": "theorem angle_eq_arccos_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    \u2220 p\u2082 p\u2083 p\u2081 = Real.arccos (dist p\u2083 p\u2082 / dist p\u2081 p\u2083)", "start": [372, 1], "end": [378, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_arcsin_of_angle_eq_pi_div_two", "code": "theorem angle_eq_arcsin_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arcsin (dist p\u2081 p\u2082 / dist p\u2081 p\u2083)", "start": [381, 1], "end": [388, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_eq_arctan_of_angle_eq_pi_div_two", "code": "theorem angle_eq_arctan_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arctan (dist p\u2081 p\u2082 / dist p\u2083 p\u2082)", "start": [391, 1], "end": [398, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_pos_of_angle_eq_pi_div_two", "code": "theorem angle_pos_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : 0 < \u2220 p\u2082 p\u2083 p\u2081", "start": [401, 1], "end": [408, 44], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_le_pi_div_two_of_angle_eq_pi_div_two", "code": "theorem angle_le_pi_div_two_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    \u2220 p\u2082 p\u2083 p\u2081 \u2264 \u03c0 / 2", "start": [411, 1], "end": [417, 51], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_lt_pi_div_two_of_angle_eq_pi_div_two", "code": "theorem angle_lt_pi_div_two_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 < \u03c0 / 2", "start": [420, 1], "end": [427, 54], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_angle_of_angle_eq_pi_div_two", "code": "theorem cos_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.cos (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082 / dist p\u2081 p\u2083", "start": [430, 1], "end": [436, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_angle_of_angle_eq_pi_div_two", "code": "theorem sin_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : Real.sin (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2081 p\u2083", "start": [439, 1], "end": [446, 51], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_angle_of_angle_eq_pi_div_two", "code": "theorem tan_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.tan (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2083 p\u2082", "start": [449, 1], "end": [455, 48], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_angle_mul_dist_of_angle_eq_pi_div_two", "code": "theorem cos_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.cos (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2083 p\u2082", "start": [458, 1], "end": [465, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_angle_mul_dist_of_angle_eq_pi_div_two", "code": "theorem sin_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.sin (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2081 p\u2082", "start": [468, 1], "end": [475, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_angle_mul_dist_of_angle_eq_pi_div_two", "code": "theorem tan_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 = p\u2082 \u2228 p\u2083 \u2260 p\u2082) : Real.tan (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2083 p\u2082 = dist p\u2081 p\u2082", "start": [478, 1], "end": [486, 60], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_cos_angle_of_angle_eq_pi_div_two", "code": "theorem dist_div_cos_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 = p\u2082 \u2228 p\u2083 \u2260 p\u2082) : dist p\u2083 p\u2082 / Real.cos (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083", "start": [489, 1], "end": [497, 60], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_sin_angle_of_angle_eq_pi_div_two", "code": "theorem dist_div_sin_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : dist p\u2081 p\u2082 / Real.sin (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083", "start": [500, 1], "end": [508, 60], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_tan_angle_of_angle_eq_pi_div_two", "code": "theorem dist_div_tan_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : dist p\u2081 p\u2082 / Real.tan (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082", "start": [511, 1], "end": [519, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/TrivSqZeroExt.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "Mathlib/Algebra/TrivSqZeroExt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TrivSqZeroExt.nhds_def", "code": "theorem nhds_def (x : tsze R M) : nhds x = (nhds x.fst).prod (nhds x.snd)", "start": [45, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.nhds_inl", "code": "theorem nhds_inl [Zero M] (x : R) : nhds (inl x : tsze R M) = (nhds x).prod (nhds 0)", "start": [50, 1], "end": [51, 13], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.nhds_inr", "code": "theorem nhds_inr [Zero R] (m : M) : nhds (inr m : tsze R M) = (nhds 0).prod (nhds m)", "start": [54, 1], "end": [55, 13], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.continuous_fst", "code": "nonrec theorem continuous_fst : Continuous (fst : tsze R M \u2192 R)", "start": [58, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.continuous_snd", "code": "nonrec theorem continuous_snd : Continuous (snd : tsze R M \u2192 M)", "start": [62, 1], "end": [63, 17], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.continuous_inl", "code": "theorem continuous_inl [Zero M] : Continuous (inl : R \u2192 tsze R M)", "start": [66, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.continuous_inr", "code": "theorem continuous_inr [Zero R] : Continuous (inr : M \u2192 tsze R M)", "start": [70, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.embedding_inl", "code": "theorem embedding_inl [Zero M] : Embedding (inl : R \u2192 tsze R M)", "start": [74, 1], "end": [75, 76], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.embedding_inr", "code": "theorem embedding_inr [Zero R] : Embedding (inr : M \u2192 tsze R M)", "start": [78, 1], "end": [79, 76], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.fstClm", "code": "@[simps]\ndef fstClm [CommSemiring R] [AddCommMonoid M] [Module R M] : tsze R M \u2192L[R] R :=\n  { ContinuousLinearMap.fst R R M with toFun := fst }", "start": [84, 1], "end": [87, 54], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.sndClm", "code": "@[simps]\ndef sndClm [CommSemiring R] [AddCommMonoid M] [Module R M] : tsze R M \u2192L[R] M :=\n  { ContinuousLinearMap.snd R R M with\n    toFun := snd\n    cont := continuous_snd }", "start": [90, 1], "end": [95, 29], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.inlClm", "code": "@[simps]\ndef inlClm [CommSemiring R] [AddCommMonoid M] [Module R M] : R \u2192L[R] tsze R M :=\n  { ContinuousLinearMap.inl R R M with toFun := inl }", "start": [98, 1], "end": [101, 54], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.inrClm", "code": "@[simps]\ndef inrClm [CommSemiring R] [AddCommMonoid M] [Module R M] : M \u2192L[R] tsze R M :=\n  { ContinuousLinearMap.inr R R M with toFun := inr }", "start": [104, 1], "end": [107, 54], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.topologicalSemiring", "code": "theorem topologicalSemiring [Semiring R] [AddCommMonoid M] [Module R M] [Module R\u1d50\u1d52\u1d56 M]\n    [TopologicalSemiring R] [ContinuousAdd M] [ContinuousSMul R M] [ContinuousSMul R\u1d50\u1d52\u1d56 M] :\n    TopologicalSemiring (tsze R M)", "start": [125, 1], "end": [129, 42], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_inl", "code": "theorem hasSum_inl [AddCommMonoid R] [AddCommMonoid M] {f : \u03b1 \u2192 R} {a : R} (h : HasSum f a) :\n    HasSum (fun x \u21a6 inl (f x)) (inl a : tsze R M)", "start": [146, 1], "end": [148, 72], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_inr", "code": "theorem hasSum_inr [AddCommMonoid R] [AddCommMonoid M] {f : \u03b1 \u2192 M} {a : M} (h : HasSum f a) :\n    HasSum (fun x \u21a6 inr (f x)) (inr a : tsze R M)", "start": [151, 1], "end": [153, 72], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_fst", "code": "theorem hasSum_fst [AddCommMonoid R] [AddCommMonoid M] {f : \u03b1 \u2192 tsze R M} {a : tsze R M}\n    (h : HasSum f a) : HasSum (fun x \u21a6 fst (f x)) (fst a)", "start": [156, 1], "end": [158, 68], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_snd", "code": "theorem hasSum_snd [AddCommMonoid R] [AddCommMonoid M] {f : \u03b1 \u2192 tsze R M} {a : tsze R M}\n    (h : HasSum f a) : HasSum (fun x \u21a6 snd (f x)) (snd a)", "start": [161, 1], "end": [163, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/UInt.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Data/ZMod/Defs.lean", "Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Algebra/Group/Defs.lean"], "premises": [{"full_name": "UInt8.val_eq_of_lt", "code": "lemma UInt8.val_eq_of_lt {a : Nat} : a < UInt8.size -> (ofNat a).val = a := Nat.mod_eq_of_lt", "start": [8, 1], "end": [8, 93], "kind": "mathlibtacticlemma"}, {"full_name": "UInt16.val_eq_of_lt", "code": "lemma UInt16.val_eq_of_lt {a : Nat} : a < UInt16.size -> (ofNat a).val = a := Nat.mod_eq_of_lt", "start": [10, 1], "end": [10, 95], "kind": "mathlibtacticlemma"}, {"full_name": "UInt32.val_eq_of_lt", "code": "lemma UInt32.val_eq_of_lt {a : Nat} : a < UInt32.size -> (ofNat a).val = a := Nat.mod_eq_of_lt", "start": [12, 1], "end": [12, 95], "kind": "mathlibtacticlemma"}, {"full_name": "UInt64.val_eq_of_lt", "code": "lemma UInt64.val_eq_of_lt {a : Nat} : a < UInt64.size -> (ofNat a).val = a := Nat.mod_eq_of_lt", "start": [14, 1], "end": [14, 95], "kind": "mathlibtacticlemma"}, {"full_name": "USize.val_eq_of_lt", "code": "lemma USize.val_eq_of_lt {a : Nat} : a < USize.size -> (ofNat a).val = a := Nat.mod_eq_of_lt", "start": [16, 1], "end": [16, 93], "kind": "mathlibtacticlemma"}, {"full_name": "UInt8.neZero", "code": "instance UInt8.neZero : NeZero UInt8.size := \u27e8by decide\u27e9", "start": [18, 1], "end": [18, 57], "kind": "commanddeclaration"}, {"full_name": "UInt16.neZero", "code": "instance UInt16.neZero : NeZero UInt16.size := \u27e8by decide\u27e9", "start": [20, 1], "end": [20, 59], "kind": "commanddeclaration"}, {"full_name": "UInt32.neZero", "code": "instance UInt32.neZero : NeZero UInt32.size := \u27e8by decide\u27e9", "start": [22, 1], "end": [22, 59], "kind": "commanddeclaration"}, {"full_name": "UInt64.neZero", "code": "instance UInt64.neZero : NeZero UInt64.size := \u27e8by decide\u27e9", "start": [24, 1], "end": [24, 59], "kind": "commanddeclaration"}, {"full_name": "USize.neZero", "code": "instance USize.neZero : NeZero USize.size := NeZero.of_pos usize_size_gt_zero", "start": [26, 1], "end": [26, 78], "kind": "commanddeclaration"}, {"full_name": "zero_def", "code": "lemma zero_def : (0 : $typeName) = \u27e80\u27e9 := rfl", "start": [56, 7], "end": [56, 52], "kind": "mathlibtacticlemma"}, {"full_name": "one_def", "code": "lemma one_def : (1 : $typeName) = \u27e81\u27e9 := rfl", "start": [58, 7], "end": [58, 51], "kind": "mathlibtacticlemma"}, {"full_name": "neg_def", "code": "lemma neg_def (a : $typeName) : -a = \u27e8-a.val\u27e9 := rfl", "start": [60, 7], "end": [60, 59], "kind": "mathlibtacticlemma"}, {"full_name": "sub_def", "code": "lemma sub_def (a b : $typeName) : a - b = \u27e8a.val - b.val\u27e9 := rfl", "start": [62, 7], "end": [62, 71], "kind": "mathlibtacticlemma"}, {"full_name": "mul_def", "code": "lemma mul_def (a b : $typeName) : a * b = \u27e8a.val * b.val\u27e9 := rfl", "start": [64, 7], "end": [64, 71], "kind": "mathlibtacticlemma"}, {"full_name": "mod_def", "code": "lemma mod_def (a b : $typeName) : a % b = \u27e8a.val % b.val\u27e9 := rfl", "start": [66, 7], "end": [66, 71], "kind": "mathlibtacticlemma"}, {"full_name": "add_def", "code": "lemma add_def (a b : $typeName) : a + b = \u27e8a.val + b.val\u27e9 := rfl", "start": [68, 7], "end": [68, 71], "kind": "mathlibtacticlemma"}, {"full_name": "pow_def", "code": "lemma pow_def (a : $typeName) (n : \u2115) : a ^ n = \u27e8a.val ^ n\u27e9 := rfl", "start": [70, 7], "end": [70, 73], "kind": "mathlibtacticlemma"}, {"full_name": "nsmul_def", "code": "lemma nsmul_def (n : \u2115) (a : $typeName) : n \u2022 a = \u27e8n \u2022 a.val\u27e9 := rfl", "start": [72, 7], "end": [72, 75], "kind": "mathlibtacticlemma"}, {"full_name": "zsmul_def", "code": "lemma zsmul_def (z : \u2124) (a : $typeName) : z \u2022 a = \u27e8z \u2022 a.val\u27e9 := rfl", "start": [74, 7], "end": [74, 75], "kind": "mathlibtacticlemma"}, {"full_name": "natCast_def", "code": "lemma natCast_def (n : \u2115) : (n : $typeName) = \u27e8n\u27e9 := rfl", "start": [76, 7], "end": [76, 63], "kind": "mathlibtacticlemma"}, {"full_name": "intCast_def", "code": "lemma intCast_def (z : \u2124) : (z : $typeName) = \u27e8z\u27e9 := rfl", "start": [78, 7], "end": [78, 63], "kind": "mathlibtacticlemma"}, {"full_name": "eq_of_val_eq", "code": "lemma eq_of_val_eq : \u2200 {a b : $typeName}, a.val = b.val -> a = b\n      | \u27e8_\u27e9, \u27e8_\u27e9, h => congrArg mk h", "start": [80, 7], "end": [81, 37], "kind": "mathlibtacticlemma"}, {"full_name": "val_injective", "code": "lemma val_injective : Function.Injective val := @eq_of_val_eq", "start": [83, 7], "end": [83, 68], "kind": "mathlibtacticlemma"}, {"full_name": "val_eq_of_eq", "code": "lemma val_eq_of_eq : \u2200 {a b : $typeName}, a = b -> a.val = b.val\n      | \u27e8_\u27e9, \u27e8_\u27e9, h => congrArg val h", "start": [85, 7], "end": [86, 38], "kind": "mathlibtacticlemma"}, {"full_name": "mk_val_eq", "code": "@[simp] lemma mk_val_eq : \u2200 (a : $typeName), mk a.val = a\n      | \u27e8_, _\u27e9 => rfl", "start": [88, 7], "end": [89, 22], "kind": "mathlibtacticlemma"}, {"full_name": "UInt8.isUpper", "code": "def isUpper (c : UInt8) : Bool :=\n  c \u2265 65 && c \u2264 90", "start": [101, 1], "end": [103, 19], "kind": "commanddeclaration"}, {"full_name": "UInt8.isLower", "code": "def isLower (c : UInt8) : Bool :=\n  c \u2265 97 && c \u2264 122", "start": [105, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "UInt8.isAlpha", "code": "def isAlpha (c : UInt8) : Bool :=\n  c.isUpper || c.isLower", "start": [109, 1], "end": [111, 25], "kind": "commanddeclaration"}, {"full_name": "UInt8.isDigit", "code": "def isDigit (c : UInt8) : Bool :=\n  c \u2265 48 && c \u2264 57", "start": [113, 1], "end": [115, 19], "kind": "commanddeclaration"}, {"full_name": "UInt8.isAlphanum", "code": "def isAlphanum (c : UInt8) : Bool :=\n  c.isAlpha || c.isDigit", "start": [117, 1], "end": [119, 25], "kind": "commanddeclaration"}, {"full_name": "UInt8.toChar_aux", "code": "theorem toChar_aux (n : Nat) (h : n < size) : Nat.isValidChar (UInt32.ofNat n).1", "start": [121, 1], "end": [124, 35], "kind": "commanddeclaration"}, {"full_name": "UInt8.toChar", "code": "def toChar (n : UInt8) : Char := \u27e8n.toUInt32, toChar_aux n.1 n.1.2\u27e9", "start": [126, 1], "end": [127, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/DFA.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Computability/Language.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFA", "code": "structure DFA (\u03b1 : Type u) (\u03c3 : Type v) where\n  \n  step : \u03c3 \u2192 \u03b1 \u2192 \u03c3\n  \n  start : \u03c3\n  \n  accept : Set \u03c3", "start": [30, 1], "end": [38, 17], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom", "code": "def evalFrom (start : \u03c3) : List \u03b1 \u2192 \u03c3 :=\n  List.foldl M.step start", "start": [48, 1], "end": [50, 26], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_nil", "code": "@[simp]\ntheorem evalFrom_nil (s : \u03c3) : M.evalFrom s [] = s", "start": [53, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_singleton", "code": "@[simp]\ntheorem evalFrom_singleton (s : \u03c3) (a : \u03b1) : M.evalFrom s [a] = M.step s a", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_append_singleton", "code": "@[simp]\ntheorem evalFrom_append_singleton (s : \u03c3) (x : List \u03b1) (a : \u03b1) :\n    M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a", "start": [63, 1], "end": [66, 75], "kind": "commanddeclaration"}, {"full_name": "DFA.eval", "code": "def eval : List \u03b1 \u2192 \u03c3 :=\n  M.evalFrom M.start", "start": [69, 1], "end": [71, 21], "kind": "commanddeclaration"}, {"full_name": "DFA.eval_nil", "code": "@[simp]\ntheorem eval_nil : M.eval [] = M.start", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "DFA.eval_singleton", "code": "@[simp]\ntheorem eval_singleton (a : \u03b1) : M.eval [a] = M.step M.start a", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "DFA.eval_append_singleton", "code": "@[simp]\ntheorem eval_append_singleton (x : List \u03b1) (a : \u03b1) : M.eval (x ++ [a]) = M.step (M.eval x) a", "start": [84, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_of_append", "code": "theorem evalFrom_of_append (start : \u03c3) (x y : List \u03b1) :\n    M.evalFrom start (x ++ y) = M.evalFrom (M.evalFrom start x) y", "start": [89, 1], "end": [91, 23], "kind": "commanddeclaration"}, {"full_name": "DFA.accepts", "code": "def accepts : Language \u03b1 := {x | M.eval x \u2208 M.accept}", "start": [94, 1], "end": [95, 54], "kind": "commanddeclaration"}, {"full_name": "DFA.mem_accepts", "code": "theorem mem_accepts (x : List \u03b1) : x \u2208 M.accepts \u2194 M.evalFrom M.start x \u2208 M.accept", "start": [98, 1], "end": [98, 93], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_split", "code": "theorem evalFrom_split [Fintype \u03c3] {x : List \u03b1} {s t : \u03c3} (hlen : Fintype.card \u03c3 \u2264 x.length)\n    (hx : M.evalFrom s x = t) :\n    \u2203 q a b c,\n      x = a ++ b ++ c \u2227\n        a.length + b.length \u2264 Fintype.card \u03c3 \u2227\n          b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t", "start": [101, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "DFA.evalFrom_of_pow", "code": "theorem evalFrom_of_pow {x y : List \u03b1} {s : \u03c3} (hx : M.evalFrom s x = s)\n    (hy : y \u2208 ({x} : Language \u03b1)\u2217) : M.evalFrom s y = s", "start": [137, 1], "end": [148, 43], "kind": "commanddeclaration"}, {"full_name": "DFA.pumping_lemma", "code": "theorem pumping_lemma [Fintype \u03c3] {x : List \u03b1} (hx : x \u2208 M.accepts)\n    (hlen : Fintype.card \u03c3 \u2264 List.length x) :\n    \u2203 a b c,\n      x = a ++ b ++ c \u2227\n        a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 {a} * {b}\u2217 * {c} \u2264 M.accepts", "start": [151, 1], "end": [166, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Function/OfArity.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.OfArity", "code": "def OfArity (\u03b1 : Type u) : \u2115 \u2192 Type u\n  | 0 => \u03b1\n  | n + 1 => \u03b1 \u2192 OfArity \u03b1 n", "start": [25, 1], "end": [28, 29], "kind": "commanddeclaration"}, {"full_name": "Function.ofArity_zero", "code": "@[simp]\ntheorem ofArity_zero (\u03b1 : Type u) : OfArity \u03b1 0 = \u03b1", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Function.ofArity_succ", "code": "@[simp]\ntheorem ofArity_succ (\u03b1 : Type u) (n : \u2115) : OfArity \u03b1 n.succ = (\u03b1 \u2192 OfArity \u03b1 n)", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Function.OfArity.const", "code": "def const {\u03b1 : Type u} (a : \u03b1) : \u2200 n, OfArity \u03b1 n\n  | 0 => a\n  | n + 1 => fun _ => const a n", "start": [43, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "Function.OfArity.const_zero", "code": "@[simp]\ntheorem const_zero {\u03b1 : Type u} (a : \u03b1) : const a 0 = a", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Function.OfArity.const_succ", "code": "@[simp]\ntheorem const_succ {\u03b1 : Type u} (a : \u03b1) (n : \u2115) : const a n.succ = fun _ => const a n", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Function.OfArity.const_succ_apply", "code": "theorem const_succ_apply {\u03b1 : Type u} (a : \u03b1) (n : \u2115) (x : \u03b1) : const a n.succ x = const a n", "start": [59, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Function.OfArity.OfArity.inhabited", "code": "instance OfArity.inhabited {\u03b1 n} [Inhabited \u03b1] : Inhabited (OfArity \u03b1 n) :=\n  \u27e8const default _\u27e9", "start": [63, 1], "end": [64, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean", "imports": ["Mathlib/Algebra/ContinuedFractions/ConvergentsEquiv.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Topology/Order/Basic.lean", "Mathlib/Algebra/Order/Archimedean.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean"], "premises": [{"full_name": "GeneralizedContinuedFraction.of_isSimpleContinuedFraction", "code": "theorem GeneralizedContinuedFraction.of_isSimpleContinuedFraction :\n    (of v).IsSimpleContinuedFraction", "start": [51, 1], "end": [53, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleContinuedFraction.of", "code": "nonrec def SimpleContinuedFraction.of : SimpleContinuedFraction K :=\n  \u27e8of v, GeneralizedContinuedFraction.of_isSimpleContinuedFraction v\u27e9", "start": [56, 1], "end": [58, 70], "kind": "commanddeclaration"}, {"full_name": "SimpleContinuedFraction.of_isContinuedFraction", "code": "theorem SimpleContinuedFraction.of_isContinuedFraction :\n    (SimpleContinuedFraction.of v).IsContinuedFraction", "start": [61, 1], "end": [63, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuedFraction.of", "code": "def ContinuedFraction.of : ContinuedFraction K :=\n  \u27e8SimpleContinuedFraction.of v, SimpleContinuedFraction.of_isContinuedFraction v\u27e9", "start": [66, 1], "end": [68, 83], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.of_convergents_eq_convergents'", "code": "theorem of_convergents_eq_convergents' : (of v).convergents = (of v).convergents'", "start": [73, 1], "end": [74, 78], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.convergents_succ", "code": "theorem convergents_succ (n : \u2115) :\n    (of v).convergents (n + 1) = \u230av\u230b + 1 / (of (Int.fract v)\u207b\u00b9).convergents n", "start": [77, 1], "end": [82, 89], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.of_convergence_epsilon", "code": "theorem of_convergence_epsilon :\n    \u2200 \u03b5 > (0 : K), \u2203 N : \u2115, \u2200 n \u2265 N, |v - (of v).convergents n| < \u03b5", "start": [98, 1], "end": [147, 75], "kind": "commanddeclaration"}, {"full_name": "GeneralizedContinuedFraction.of_convergence", "code": "theorem of_convergence [OrderTopology K] :\n    Filter.Tendsto (of v).convergents Filter.atTop <| nhds v", "start": [152, 1], "end": [154, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Game/Short.lean", "imports": ["Mathlib/SetTheory/Cardinal/Cofinality.lean", "Mathlib/SetTheory/Game/Birthday.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.Short", "code": "inductive Short : PGame.{u} \u2192 Type (u + 1)\n  | mk :\n    \u2200 {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} (_ : \u2200 i : \u03b1, Short (L i))\n      (_ : \u2200 j : \u03b2, Short (R j)) [Fintype \u03b1] [Fintype \u03b2], Short \u27e8\u03b1, \u03b2, L, R\u27e9", "start": [36, 1], "end": [40, 77], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.subsingleton_short", "code": "instance subsingleton_short (x : PGame) : Subsingleton (Short x) := by\n  induction x with\n  | mk xl xr xL xR =>\n    constructor\n    intro a b\n    cases a; cases b\n    congr!", "start": [50, 1], "end": [56, 11], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.subsingleton_short_example", "code": "theorem subsingleton_short_example : \u2200 x : PGame, Subsingleton (Short x)", "start": [62, 1], "end": [83, 2], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Short.mk'", "code": "def Short.mk' {x : PGame} [Fintype x.LeftMoves] [Fintype x.RightMoves]\n    (sL : \u2200 i : x.LeftMoves, Short (x.moveLeft i))\n    (sR : \u2200 j : x.RightMoves, Short (x.moveRight j)) : Short x := by\n  convert Short.mk sL sR\n  cases x\n  dsimp", "start": [87, 1], "end": [94, 8], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeLeft", "code": "def fintypeLeft {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} [S : Short \u27e8\u03b1, \u03b2, L, R\u27e9] :\n    Fintype \u03b1 := by cases' S with _ _ _ _ _ _ F _; exact F", "start": [99, 1], "end": [103, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeLeftMoves", "code": "instance fintypeLeftMoves (x : PGame) [S : Short x] : Fintype x.LeftMoves := by\n  cases S; assumption", "start": [108, 1], "end": [109, 22], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeRight", "code": "def fintypeRight {\u03b1 \u03b2 : Type u} {L : \u03b1 \u2192 PGame.{u}} {R : \u03b2 \u2192 PGame.{u}} [S : Short \u27e8\u03b1, \u03b2, L, R\u27e9] :\n    Fintype \u03b2 := by cases' S with _ _ _ _ _ _ _ F; exact F", "start": [112, 1], "end": [116, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeRightMoves", "code": "instance fintypeRightMoves (x : PGame) [S : Short x] : Fintype x.RightMoves := by\n  cases S; assumption", "start": [121, 1], "end": [122, 22], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveLeftShort", "code": "instance moveLeftShort (x : PGame) [S : Short x] (i : x.LeftMoves) : Short (x.moveLeft i) := by\n  cases' S with _ _ _ _ L _ _ _; apply L", "start": [125, 1], "end": [126, 41], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveLeftShort'", "code": "def moveLeftShort' {xl xr} (xL xR) [S : Short (mk xl xr xL xR)] (i : xl) : Short (xL i) := by\n  cases' S with _ _ _ _ L _ _ _; apply L", "start": [129, 1], "end": [134, 41], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveRightShort", "code": "instance moveRightShort (x : PGame) [S : Short x] (j : x.RightMoves) : Short (x.moveRight j) := by\n  cases' S with _ _ _ _ _ R _ _; apply R", "start": [139, 1], "end": [140, 41], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.moveRightShort'", "code": "def moveRightShort' {xl xr} (xL xR) [S : Short (mk xl xr xL xR)] (j : xr) : Short (xR j) := by\n  cases' S with _ _ _ _ _ R _ _; apply R", "start": [143, 1], "end": [148, 41], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.short_birthday", "code": "theorem short_birthday (x : PGame.{u}) : [Short x] \u2192 x.birthday < Ordinal.omega", "start": [153, 1], "end": [168, 16], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Short.ofIsEmpty", "code": "def Short.ofIsEmpty {l r xL xR} [IsEmpty l] [IsEmpty r] : Short (PGame.mk l r xL xR) :=\n  Short.mk isEmptyElim isEmptyElim", "start": [171, 1], "end": [173, 35], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.short0", "code": "instance short0 : Short 0 :=\n  Short.ofIsEmpty", "start": [176, 1], "end": [177, 18], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.short1", "code": "instance short1 : Short 1 :=\n  Short.mk (fun i => by cases i; infer_instance) fun j => by cases j", "start": [180, 1], "end": [181, 69], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ListShort", "code": "class inductive ListShort : List PGame.{u} \u2192 Type (u + 1)\n  | nil : ListShort []\n  | cons' {hd : PGame.{u}} {tl : List PGame.{u}} : Short hd \u2192 ListShort tl \u2192 ListShort (hd::tl)", "start": [184, 1], "end": [190, 96], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ListShort.cons", "code": "instance ListShort.cons (hd : PGame.{u}) [short_hd : Short hd]\n                        (tl : List PGame.{u}) [short_tl : ListShort tl] :\n    ListShort (hd::tl) :=\n  cons' short_hd short_tl", "start": [195, 1], "end": [198, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.listShortGet", "code": "instance listShortGet :\n    \u2200 (L : List PGame.{u}) [ListShort L] (i : Fin (List.length L)), Short (List.get L i)\n  | [], _, n => by\n    exfalso\n    rcases n with \u27e8_, \u27e8\u27e9\u27e9\n    done\n  | _::_, ListShort.cons' S _, \u27e80, _\u27e9 => S\n  | hd::tl, ListShort.cons' _ S, \u27e8n + 1, h\u27e9 =>\n    @listShortGet tl S \u27e8n, (add_lt_add_iff_right 1).mp h\u27e9", "start": [202, 1], "end": [211, 58], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.listShortNthLe", "code": "@[deprecated listShortGet]\ninstance listShortNthLe (L : List PGame.{u}) [ListShort L] (i : Fin (List.length L)) :\n    Short (List.nthLe L i i.is_lt) := by\n  rw [List.nthLe_eq]\n  apply listShortGet", "start": [214, 1], "end": [218, 21], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOfLists", "code": "instance shortOfLists : \u2200 (L R : List PGame) [ListShort L] [ListShort R], Short (PGame.ofLists L R)\n  | L, R, _, _ => by\n    apply Short.mk\n    \u00b7 intros; infer_instance\n    \u00b7 intros; apply PGame.listShortGet", "start": [221, 1], "end": [225, 39], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOfRelabelling", "code": "def shortOfRelabelling : \u2200 {x y : PGame.{u}}, Relabelling x y \u2192 Short x \u2192 Short y\n  | x, y, \u27e8L, R, rL, rR\u27e9, S => by\n    haveI := Fintype.ofEquiv _ L\n    haveI := Fintype.ofEquiv _ R\n    exact\n      Short.mk'\n        (fun i => by rw [\u2190 L.right_inv i]; apply shortOfRelabelling (rL (L.symm i)) inferInstance)\n        fun j => by simpa using shortOfRelabelling (rR (R.symm j)) inferInstance", "start": [228, 1], "end": [236, 81], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortNeg", "code": "instance shortNeg : \u2200 (x : PGame.{u}) [Short x], Short (-x)\n  | mk xl xr xL xR, _ => by\n    exact Short.mk (fun i => shortNeg _) fun i => shortNeg _", "start": [239, 1], "end": [241, 61], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortAdd", "code": "instance shortAdd : \u2200 (x y : PGame.{u}) [Short x] [Short y], Short (x + y)\n  | mk xl xr xL xR, mk yl yr yL yR, _, _ => by\n    apply Short.mk;\n    all_goals\n      rintro \u27e8i\u27e9\n      \u00b7 apply shortAdd\n      \u00b7 change Short (mk xl xr xL xR + _); apply shortAdd\ntermination_by shortAdd x y _ _ => Prod.mk x y", "start": [245, 1], "end": [253, 47], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortNat", "code": "instance shortNat : \u2200 n : \u2115, Short n\n  | 0 => PGame.short0\n  | n + 1 => @PGame.shortAdd _ _ (shortNat n) PGame.short1", "start": [257, 1], "end": [259, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOfNat", "code": "instance shortOfNat (n : \u2115) [Nat.AtLeastTwo n] : Short (no_index (OfNat.ofNat n)) := shortNat n", "start": [262, 1], "end": [262, 96], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortBit0", "code": "instance shortBit0 (x : PGame.{u}) [Short x] : Short (bit0 x) := by dsimp [bit0]; infer_instance", "start": [266, 1], "end": [266, 97], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortBit1", "code": "instance shortBit1 (x : PGame.{u}) [Short x] : Short (bit1 x) := by dsimp [bit1]; infer_instance", "start": [270, 1], "end": [270, 97], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leLFDecidable", "code": "def leLFDecidable : \u2200 (x y : PGame.{u}) [Short x] [Short y], Decidable (x \u2264 y) \u00d7 Decidable (x \u29cf y)\n  | mk xl xr xL xR, mk yl yr yL yR, shortx, shorty => by\n    constructor\n    \u00b7 refine' @decidable_of_iff' _ _ mk_le_mk (id _)\n      apply @And.decidable _ _ ?_ ?_\n      \u00b7 apply @Fintype.decidableForallFintype xl _ ?_ _\n        intro i\n        apply (leLFDecidable _ _).2\n      \u00b7 apply @Fintype.decidableForallFintype yr _ ?_ _\n        intro i\n        apply (leLFDecidable _ _).2\n    \u00b7 refine' @decidable_of_iff' _ _ mk_lf_mk (id _)\n      apply @Or.decidable _ _ ?_ ?_\n      \u00b7 apply @Fintype.decidableExistsFintype yl _ ?_ _\n        intro i\n        apply (leLFDecidable _ _).1\n      \u00b7 apply @Fintype.decidableExistsFintype xr _ ?_ _\n        intro i\n        apply (leLFDecidable _ _).1\ntermination_by leLFDecidable x y _ _ => Prod.mk x y", "start": [273, 1], "end": [297, 52], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leDecidable", "code": "instance leDecidable (x y : PGame.{u}) [Short x] [Short y] : Decidable (x \u2264 y) :=\n  (leLFDecidable x y).1", "start": [301, 1], "end": [302, 24], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lfDecidable", "code": "instance lfDecidable (x y : PGame.{u}) [Short x] [Short y] : Decidable (x \u29cf y) :=\n  (leLFDecidable x y).2", "start": [305, 1], "end": [306, 24], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ltDecidable", "code": "instance ltDecidable (x y : PGame.{u}) [Short x] [Short y] : Decidable (x < y) :=\n  And.decidable", "start": [309, 1], "end": [310, 16], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.equivDecidable", "code": "instance equivDecidable (x y : PGame.{u}) [Short x] [Short y] : Decidable (x \u2248 y) :=\n  And.decidable", "start": [313, 1], "end": [314, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Ultraproducts.lean", "imports": ["Mathlib/ModelTheory/Quotients.lean", "Mathlib/Order/Filter/Ultrafilter.lean", "Mathlib/Order/Filter/Germ.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.Ultraproduct.setoidPrestructure", "code": "instance setoidPrestructure : L.Prestructure ((u : Filter \u03b1).productSetoid M) :=\n  { (u : Filter \u03b1).productSetoid M with\n    toStructure :=\n      { funMap := fun {n} f x a => funMap f fun i => x i a\n        RelMap := fun {n} r x => \u2200\u1da0 a : \u03b1 in u, RelMap r fun i => x i a }\n    fun_equiv := fun {n} f x y xy => by\n      refine' mem_of_superset (iInter_mem.2 xy) fun a ha => _\n      simp only [Set.mem_iInter, Set.mem_setOf_eq] at ha\n      simp only [Set.mem_setOf_eq, ha]\n    rel_equiv := fun {n} r x y xy => by\n      rw [\u2190 iff_eq_eq]\n      refine' \u27e8fun hx => _, fun hy => _\u27e9\n      \u00b7 refine' mem_of_superset (inter_mem hx (iInter_mem.2 xy)) _\n        rintro a \u27e8ha1, ha2\u27e9\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [\u2190 funext ha2]\n        exact ha1\n      \u00b7 refine' mem_of_superset (inter_mem hy (iInter_mem.2 xy)) _\n        rintro a \u27e8ha1, ha2\u27e9\n        simp only [Set.mem_iInter, Set.mem_setOf_eq] at *\n        rw [funext ha2]\n        exact ha1 }", "start": [46, 1], "end": [67, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.structure", "code": "instance \u00abstructure\u00bb : L.Structure ((u : Filter \u03b1).Product M) :=\n  Language.quotientStructure", "start": [72, 1], "end": [73, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.funMap_cast", "code": "theorem funMap_cast {n : \u2115} (f : L.Functions n) (x : Fin n \u2192 \u2200 a, M a) :\n    (funMap f fun i => (x i : (u : Filter \u03b1).Product M)) =\n      (fun a => funMap f fun i => x i a : (u : Filter \u03b1).Product M)", "start": [77, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.term_realize_cast", "code": "theorem term_realize_cast {\u03b2 : Type*} (x : \u03b2 \u2192 \u2200 a, M a) (t : L.Term \u03b2) :\n    (t.realize fun i => (x i : (u : Filter \u03b1).Product M)) =\n      (fun a => t.realize fun i => x i a : (u : Filter \u03b1).Product M)", "start": [83, 1], "end": [94, 8], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.boundedFormula_realize_cast", "code": "theorem boundedFormula_realize_cast {\u03b2 : Type*} {n : \u2115} (\u03c6 : L.BoundedFormula \u03b2 n)\n    (x : \u03b2 \u2192 \u2200 a, M a) (v : Fin n \u2192 \u2200 a, M a) :\n    (\u03c6.Realize (fun i : \u03b2 => (x i : (u : Filter \u03b1).Product M))\n        (fun i => (v i : (u : Filter \u03b1).Product M))) \u2194\n      \u2200\u1da0 a : \u03b1 in u, \u03c6.Realize (fun i : \u03b2 => x i a) fun i => v i a", "start": [99, 1], "end": [147, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.realize_formula_cast", "code": "theorem realize_formula_cast {\u03b2 : Type*} (\u03c6 : L.Formula \u03b2) (x : \u03b2 \u2192 \u2200 a, M a) :\n    (\u03c6.Realize fun i => (x i : (u : Filter \u03b1).Product M)) \u2194\n      \u2200\u1da0 a : \u03b1 in u, \u03c6.Realize fun i => x i a", "start": [150, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.sentence_realize", "code": "theorem sentence_realize (\u03c6 : L.Sentence) :\n    (u : Filter \u03b1).Product M \u22a8 \u03c6 \u2194 \u2200\u1da0 a : \u03b1 in u, M a \u22a8 \u03c6", "start": [157, 1], "end": [163, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Ultraproduct.Product.instNonempty", "code": "nonrec instance Product.instNonempty : Nonempty ((u : Filter \u03b1).Product M) :=\n  letI : \u2200 a, Inhabited (M a) := fun _ => Classical.inhabited_of_nonempty'\n  instNonempty", "start": [166, 1], "end": [168, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Skolem.lean", "imports": ["Mathlib/ModelTheory/ElementaryMaps.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.skolem\u2081", "code": "@[simps]\ndef skolem\u2081 : Language :=\n  \u27e8fun n => L.BoundedFormula Empty (n + 1), fun _ => Empty\u27e9", "start": [40, 1], "end": [44, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.card_functions_sum_skolem\u2081", "code": "theorem card_functions_sum_skolem\u2081 :\n    #(\u03a3 n, (L.sum L.skolem\u2081).Functions n) = #(\u03a3 n, L.BoundedFormula Empty (n + 1))", "start": [50, 1], "end": [62, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.card_functions_sum_skolem\u2081_le", "code": "theorem card_functions_sum_skolem\u2081_le : #(\u03a3 n, (L.sum L.skolem\u2081).Functions n) \u2264 max \u2135\u2080 L.card", "start": [65, 1], "end": [73, 8], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.skolem\u2081Structure", "code": "noncomputable instance skolem\u2081Structure : L.skolem\u2081.Structure M :=\n  \u27e8fun {_} \u03c6 x => Classical.epsilon fun a => \u03c6.Realize default (Fin.snoc x a : _ \u2192 M), fun {_} r =>\n    Empty.elim r\u27e9", "start": [76, 1], "end": [80, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.skolem\u2081_reduct_isElementary", "code": "theorem skolem\u2081_reduct_isElementary (S : (L.sum L.skolem\u2081).Substructure M) :\n    (LHom.sumInl.substructureReduct S).IsElementary", "start": [86, 1], "end": [95, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.elementarySkolem\u2081Reduct", "code": "noncomputable def elementarySkolem\u2081Reduct (S : (L.sum L.skolem\u2081).Substructure M) :\n    L.ElementarySubstructure M :=\n  \u27e8LHom.sumInl.substructureReduct S, S.skolem\u2081_reduct_isElementary\u27e9", "start": [98, 1], "end": [101, 68], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.coeSort_elementarySkolem\u2081Reduct", "code": "theorem coeSort_elementarySkolem\u2081Reduct (S : (L.sum L.skolem\u2081).Substructure M) :\n    (S.elementarySkolem\u2081Reduct : Type w) = S", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.elementarySkolem\u2081Reduct.instSmall", "code": "instance Substructure.elementarySkolem\u2081Reduct.instSmall :\n    Small (\u22a5 : (L.sum L.skolem\u2081).Substructure M).elementarySkolem\u2081Reduct := by\n  rw [coeSort_elementarySkolem\u2081Reduct]\n  infer_instance", "start": [115, 1], "end": [118, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_small_elementarySubstructure", "code": "theorem exists_small_elementarySubstructure : \u2203 S : L.ElementarySubstructure M, Small.{max u v} S", "start": [121, 1], "end": [122, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_elementarySubstructure_card_eq", "code": "theorem exists_elementarySubstructure_card_eq (s : Set M) (\u03ba : Cardinal.{w'}) (h1 : \u2135\u2080 \u2264 \u03ba)\n    (h2 : Cardinal.lift.{w'} #s \u2264 Cardinal.lift.{w} \u03ba)\n    (h3 : Cardinal.lift.{w'} L.card \u2264 Cardinal.lift.{max u v} \u03ba)\n    (h4 : Cardinal.lift.{w} \u03ba \u2264 Cardinal.lift.{w'} #M) :\n    \u2203 S : L.ElementarySubstructure M, s \u2286 S \u2227 Cardinal.lift.{w'} #S = Cardinal.lift.{w} \u03ba", "start": [127, 1], "end": [160, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Bundled.lean", "imports": ["Mathlib/CategoryTheory/ConcreteCategory/Bundled.lean", "Mathlib/ModelTheory/ElementaryMaps.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bundled.structure", "code": "protected instance CategoryTheory.Bundled.structure {L : FirstOrder.Language.{u, v}}\n    (M : CategoryTheory.Bundled.{w} L.Structure) : L.Structure M :=\n  M.str", "start": [30, 1], "end": [32, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.bundledInduced", "code": "@[simps]\ndef bundledInduced : CategoryTheory.Bundled.{w'} L.Structure :=\n  \u27e8N, g.inducedStructure\u27e9", "start": [42, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.bundledInducedEquiv", "code": "@[simp]\ndef bundledInducedEquiv : M \u2243[L] g.bundledInduced L :=\n  g.inducedStructureEquiv", "start": [48, 1], "end": [52, 26], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.equivSetoid", "code": "instance equivSetoid : Setoid (CategoryTheory.Bundled L.Structure) where\n  r M N := Nonempty (M \u2243[L] N)\n  iseqv :=\n    \u27e8fun M => \u27e8Equiv.refl L M\u27e9, fun {_ _} => Nonempty.map Equiv.symm, fun {_ _} _ =>\n      Nonempty.map2 fun MN NP => NP.comp MN\u27e9", "start": [61, 1], "end": [66, 45], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType", "code": "structure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]", "start": [73, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.instCoeSort", "code": "instance instCoeSort : CoeSort T.ModelType (Type w) :=\n  \u27e8ModelType.Carrier\u27e9", "start": [93, 1], "end": [94, 22], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.of", "code": "def of (M : Type w) [L.Structure M] [M \u22a8 T] [Nonempty M] : T.ModelType :=\n  \u27e8M\u27e9", "start": [99, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.coe_of", "code": "@[simp]\ntheorem coe_of (M : Type w) [L.Structure M] [M \u22a8 T] [Nonempty M] : (of T M : Type w) = M", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.instNonempty", "code": "instance instNonempty (M : T.ModelType) : Nonempty M :=\n  inferInstance", "start": [110, 1], "end": [111, 16], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.instInhabited", "code": "instance instInhabited : Inhabited (ModelType.{u, v, w} (\u2205 : L.Theory)) :=\n  \u27e8ModelType.of _ PUnit\u27e9", "start": [118, 1], "end": [119, 25], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.equivInduced", "code": "def equivInduced {M : ModelType.{u, v, w} T} {N : Type w'} (e : M \u2243 N) :\n    ModelType.{u, v, w'} T where\n  Carrier := N\n  struc := e.inducedStructure\n  is_model := @Equiv.theory_model L M N _ e.inducedStructure T e.inducedStructureEquiv _\n  nonempty' := e.symm.nonempty", "start": [126, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.of_small", "code": "instance of_small (M : Type w) [Nonempty M] [L.Structure M] [M \u22a8 T] [h : Small.{w'} M] :\n    Small.{w'} (ModelType.of T M) :=\n  h", "start": [135, 1], "end": [137, 4], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.shrink", "code": "noncomputable def shrink (M : ModelType.{u, v, w} T) [Small.{w'} M] : ModelType.{u, v, w'} T :=\n  equivInduced (equivShrink M)", "start": [140, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.ulift", "code": "def ulift (M : ModelType.{u, v, w} T) : ModelType.{u, v, max w w'} T :=\n  equivInduced (Equiv.ulift.{w', w}.symm : M \u2243 _)", "start": [145, 1], "end": [147, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.reduct", "code": "@[simps]\ndef reduct {L' : Language} (\u03c6 : L \u2192\u1d38 L') (M : (\u03c6.onTheory T).ModelType) : T.ModelType where\n  Carrier := M\n  struc := \u03c6.reduct M\n  nonempty' := M.nonempty'\n  is_model := (@LHom.onTheory_model L L' M (\u03c6.reduct M) _ \u03c6 _ T).1 M.is_model", "start": [150, 1], "end": [156, 78], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.defaultExpansion", "code": "@[simps]\nnoncomputable def defaultExpansion {L' : Language} {\u03c6 : L \u2192\u1d38 L'} (h : \u03c6.Injective)\n    [\u2200 (n) (f : L'.Functions n), Decidable (f \u2208 Set.range fun f : L.Functions n => \u03c6.onFunction f)]\n    [\u2200 (n) (r : L'.Relations n), Decidable (r \u2208 Set.range fun r : L.Relations n => \u03c6.onRelation r)]\n    (M : T.ModelType) [Inhabited M] : (\u03c6.onTheory T).ModelType where\n  Carrier := M\n  struc := \u03c6.defaultExpansion M\n  nonempty' := M.nonempty'\n  is_model :=\n    (@LHom.onTheory_model L L' M _ (\u03c6.defaultExpansion M) \u03c6 (h.isExpansionOn_default M) T).2\n      M.is_model", "start": [159, 1], "end": [171, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.leftStructure", "code": "instance leftStructure {L' : Language} {T : (L.sum L').Theory} (M : T.ModelType) : L.Structure M :=\n  (LHom.sumInl : L \u2192\u1d38 L.sum L').reduct M", "start": [174, 1], "end": [175, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.rightStructure", "code": "instance rightStructure {L' : Language} {T : (L.sum L').Theory} (M : T.ModelType) :\n    L'.Structure M :=\n  (LHom.sumInr : L' \u2192\u1d38 L.sum L').reduct M", "start": [178, 1], "end": [180, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.subtheoryModel", "code": "@[simps]\ndef subtheoryModel (M : T.ModelType) {T' : L.Theory} (h : T' \u2286 T) : T'.ModelType where\n  Carrier := M\n  is_model := \u27e8fun _\u03c6 h\u03c6 => realize_sentence_of_mem T (h h\u03c6)\u27e9", "start": [183, 1], "end": [187, 62], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelType.subtheoryModel_models", "code": "instance subtheoryModel_models (M : T.ModelType) {T' : L.Theory} (h : T' \u2286 T) :\n    M.subtheoryModel h \u22a8 T :=\n  M.is_model", "start": [190, 1], "end": [192, 13], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.Model.bundled", "code": "def Model.bundled {M : Type w} [LM : L.Structure M] [ne : Nonempty M] (h : M \u22a8 T) : T.ModelType :=\n  @ModelType.of L T M LM h ne", "start": [199, 1], "end": [201, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.coe_of", "code": "@[simp]\ntheorem coe_of {M : Type w} [L.Structure M] [Nonempty M] (h : M \u22a8 T) : (h.bundled : Type w) = M", "start": [204, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarilyEquivalent.toModel", "code": "def ElementarilyEquivalent.toModel {M : T.ModelType} {N : Type*} [LN : L.Structure N]\n    (h : M \u2245[L] N) : T.ModelType where\n  Carrier := N\n  struc := LN\n  nonempty' := h.nonempty\n  is_model := h.theory_model", "start": [211, 1], "end": [217, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.toModel", "code": "def ElementarySubstructure.toModel {M : T.ModelType} (S : L.ElementarySubstructure M) :\n    T.ModelType :=\n  S.elementarilyEquivalent.symm.toModel T", "start": [220, 1], "end": [223, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ElementarySubstructure.toModel.instSmall", "code": "instance ElementarySubstructure.toModel.instSmall {M : T.ModelType}\n    (S : L.ElementarySubstructure M) [h : Small S] : Small (S.toModel T) :=\n  h", "start": [226, 1], "end": [228, 4], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ProbabilityMassFunction/Monad.lean", "imports": ["Mathlib/Probability/ProbabilityMassFunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PMF.pure", "code": "def pure (a : \u03b1) : PMF \u03b1 :=\n  \u27e8fun a' => if a' = a then 1 else 0, hasSum_ite_eq _ _\u27e9", "start": [36, 1], "end": [39, 57], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_apply", "code": "@[simp]\ntheorem pure_apply : pure a a' = if a' = a then 1 else 0", "start": [44, 1], "end": [45, 64], "kind": "commanddeclaration"}, {"full_name": "PMF.support_pure", "code": "@[simp]\ntheorem support_pure : (pure a).support = {a}", "start": [48, 1], "end": [50, 46], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_pure_iff", "code": "theorem mem_support_pure_iff : a' \u2208 (pure a).support \u2194 a' = a", "start": [53, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_apply_self", "code": "theorem pure_apply_self : pure a a = 1", "start": [57, 1], "end": [58, 13], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_apply_of_ne", "code": "theorem pure_apply_of_ne (h : a' \u2260 a) : pure a a' = 0", "start": [61, 1], "end": [62, 11], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_pure_apply", "code": "@[simp]\ntheorem toOuterMeasure_pure_apply : (pure a).toOuterMeasure s = if a \u2208 s then 1 else 0", "start": [72, 1], "end": [79, 87], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_pure_apply", "code": "@[simp]\ntheorem toMeasure_pure_apply (hs : MeasurableSet s) :\n    (pure a).toMeasure s = if a \u2208 s then 1 else 0", "start": [84, 1], "end": [88, 96], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_pure", "code": "theorem toMeasure_pure : (pure a).toMeasure = Measure.dirac a", "start": [91, 1], "end": [92, 94], "kind": "commanddeclaration"}, {"full_name": "PMF.toPMF_dirac", "code": "@[simp]\ntheorem toPMF_dirac [Countable \u03b1] [h : MeasurableSingletonClass \u03b1] :\n    (Measure.dirac a).toPMF = pure a", "start": [95, 1], "end": [98, 49], "kind": "commanddeclaration"}, {"full_name": "PMF.bind", "code": "def bind (p : PMF \u03b1) (f : \u03b1 \u2192 PMF \u03b2) : PMF \u03b2 :=\n  \u27e8fun b => \u2211' a, p a * f a b,\n    ENNReal.summable.hasSum_iff.2\n      (ENNReal.tsum_comm.trans <| by simp only [ENNReal.tsum_mul_left, tsum_coe, mul_one])\u27e9", "start": [107, 1], "end": [111, 92], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_apply", "code": "@[simp]\ntheorem bind_apply (b : \u03b2) : p.bind f b = \u2211' a, p a * f a b", "start": [116, 1], "end": [117, 67], "kind": "commanddeclaration"}, {"full_name": "PMF.support_bind", "code": "@[simp]\ntheorem support_bind : (p.bind f).support = \u22c3 a \u2208 p.support, (f a).support", "start": [120, 1], "end": [122, 75], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_bind_iff", "code": "theorem mem_support_bind_iff (b : \u03b2) :\n    b \u2208 (p.bind f).support \u2194 \u2203 a \u2208 p.support, b \u2208 (f a).support", "start": [125, 1], "end": [127, 74], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_bind", "code": "@[simp]\ntheorem pure_bind (a : \u03b1) (f : \u03b1 \u2192 PMF \u03b2) : (pure a).bind f = f a", "start": [130, 1], "end": [135, 14], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_pure", "code": "@[simp]\ntheorem bind_pure : p.bind pure = p", "start": [138, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_const", "code": "@[simp]\ntheorem bind_const (p : PMF \u03b1) (q : PMF \u03b2) : (p.bind fun _ => q) = q", "start": [145, 1], "end": [147, 81], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_bind", "code": "@[simp]\ntheorem bind_bind : (p.bind f).bind g = p.bind fun a => (f a).bind g", "start": [150, 1], "end": [154, 95], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_comm", "code": "theorem bind_comm (p : PMF \u03b1) (q : PMF \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 PMF \u03b3) :\n    (p.bind fun a => q.bind (f a)) = q.bind fun b => p.bind fun a => f a b", "start": [157, 1], "end": [161, 95], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_bind_apply", "code": "@[simp]\ntheorem toOuterMeasure_bind_apply :\n    (p.bind f).toOuterMeasure s = \u2211' a, p a * (f a).toOuterMeasure s", "start": [168, 1], "end": [181, 83], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_bind_apply", "code": "@[simp]\ntheorem toMeasure_bind_apply [MeasurableSpace \u03b2] (hs : MeasurableSet s) :\n    (p.bind f).toMeasure s = \u2211' a, p a * (f a).toMeasure s", "start": [184, 1], "end": [192, 97], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport", "code": "def bindOnSupport (p : PMF \u03b1) (f : \u2200 a \u2208 p.support, PMF \u03b2) : PMF \u03b2 :=\n  \u27e8fun b => \u2211' a, p a * if h : p a = 0 then 0 else f a h b, ENNReal.summable.hasSum_iff.2 (by\n    refine' ENNReal.tsum_comm.trans (_root_.trans (tsum_congr fun a => _) p.tsum_coe)\n    simp_rw [ENNReal.tsum_mul_left]\n    split_ifs with h\n    \u00b7 simp only [h, zero_mul]\n    \u00b7 rw [(f a h).tsum_coe, mul_one])\u27e9", "start": [205, 1], "end": [213, 39], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_apply", "code": "@[simp]\ntheorem bindOnSupport_apply (b : \u03b2) :\n    p.bindOnSupport f b = \u2211' a, p a * if h : p a = 0 then 0 else f a h b", "start": [218, 1], "end": [220, 80], "kind": "commanddeclaration"}, {"full_name": "PMF.support_bindOnSupport", "code": "@[simp]\ntheorem support_bindOnSupport :\n    (p.bindOnSupport f).support = \u22c3 (a : \u03b1) (h : a \u2208 p.support), (f a h).support", "start": [223, 1], "end": [235, 66], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_bindOnSupport_iff", "code": "theorem mem_support_bindOnSupport_iff (b : \u03b2) :\n    b \u2208 (p.bindOnSupport f).support \u2194 \u2203 (a : \u03b1) (h : a \u2208 p.support), b \u2208 (f a h).support", "start": [238, 1], "end": [240, 70], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_eq_bind", "code": "@[simp]\ntheorem bindOnSupport_eq_bind (p : PMF \u03b1) (f : \u03b1 \u2192 PMF \u03b2) :\n    (p.bindOnSupport fun a _ => f a) = p.bind f", "start": [243, 1], "end": [251, 20], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_eq_zero_iff", "code": "theorem bindOnSupport_eq_zero_iff (b : \u03b2) :\n    p.bindOnSupport f b = 0 \u2194 \u2200 (a) (ha : p a \u2260 0), f a ha b = 0", "start": [254, 1], "end": [258, 53], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_bindOnSupport", "code": "@[simp]\ntheorem pure_bindOnSupport (a : \u03b1) (f : \u2200 (a' : \u03b1) (_ : a' \u2208 (pure a).support), PMF \u03b2) :\n    (pure a).bindOnSupport f = f a ((mem_support_pure_iff a a).mpr rfl)", "start": [261, 1], "end": [267, 35], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_pure", "code": "theorem bindOnSupport_pure (p : PMF \u03b1) : (p.bindOnSupport fun a _ => pure a) = p", "start": [270, 1], "end": [271, 55], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_bindOnSupport", "code": "@[simp]\ntheorem bindOnSupport_bindOnSupport (p : PMF \u03b1) (f : \u2200 a \u2208 p.support, PMF \u03b2)\n    (g : \u2200 b \u2208 (p.bindOnSupport f).support, PMF \u03b3) :\n    (p.bindOnSupport f).bindOnSupport g =\n      p.bindOnSupport fun a ha =>\n        (f a ha).bindOnSupport fun b hb =>\n          g b ((mem_support_bindOnSupport_iff f b).mpr \u27e8a, ha, hb\u27e9)", "start": [274, 1], "end": [291, 15], "kind": "commanddeclaration"}, {"full_name": "PMF.bindOnSupport_comm", "code": "theorem bindOnSupport_comm (p : PMF \u03b1) (q : PMF \u03b2) (f : \u2200 a \u2208 p.support, \u2200 b \u2208 q.support, PMF \u03b3) :\n    (p.bindOnSupport fun a ha => q.bindOnSupport (f a ha)) =\n      q.bindOnSupport fun b hb => p.bindOnSupport fun a ha => f a ha b hb", "start": [294, 1], "end": [301, 35], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_bindOnSupport_apply", "code": "@[simp]\ntheorem toOuterMeasure_bindOnSupport_apply :\n    (p.bindOnSupport f).toOuterMeasure s =\n      \u2211' a, p a * if h : p a = 0 then 0 else (f a h).toOuterMeasure s", "start": [308, 1], "end": [322, 101], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_bindOnSupport_apply", "code": "@[simp]\ntheorem toMeasure_bindOnSupport_apply [MeasurableSpace \u03b2] (hs : MeasurableSet s) :\n    (p.bindOnSupport f).toMeasure s =\n      \u2211' a, p a * if h : p a = 0 then 0 else (f a h).toMeasure s", "start": [325, 1], "end": [332, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Stonean/Limits.lean", "imports": ["Mathlib/Topology/Category/Stonean/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Stonean.finiteCoproduct", "code": "def finiteCoproduct : Stonean := Stonean.of <| \u03a3 (a : \u03b1), X a", "start": [39, 1], "end": [43, 62], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.\u03b9", "code": "def finiteCoproduct.\u03b9 (a : \u03b1) : X a \u27f6 finiteCoproduct X where\n  toFun := fun x => \u27e8a,x\u27e9\n  continuous_toFun := continuous_sigmaMk (\u03c3 := fun a => X a)", "start": [45, 1], "end": [48, 61], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.desc", "code": "def finiteCoproduct.desc {B : Stonean.{u}} (e : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    finiteCoproduct X \u27f6 B where\n  toFun := fun \u27e8a,x\u27e9 => e a x\n  continuous_toFun := by\n    apply continuous_sigma\n    intro a; exact (e a).continuous", "start": [50, 1], "end": [60, 36], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.\u03b9_desc", "code": "@[reassoc (attr := simp)]\nlemma finiteCoproduct.\u03b9_desc {B : Stonean.{u}} (e : (a : \u03b1) \u2192 (X a \u27f6 B)) (a : \u03b1) :\n    finiteCoproduct.\u03b9 X a \u226b finiteCoproduct.desc X e = e a := rfl", "start": [62, 1], "end": [64, 66], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.finiteCoproduct.hom_ext", "code": "lemma finiteCoproduct.hom_ext {B : Stonean.{u}} (f g : finiteCoproduct X \u27f6 B)\n    (h : \u2200 a : \u03b1, finiteCoproduct.\u03b9 X a \u226b f = finiteCoproduct.\u03b9 X a \u226b g) : f = g := by\n  ext \u27e8a, x\u27e9\n  specialize h a\n  apply_fun (fun q => q x) at h\n  exact h", "start": [66, 1], "end": [71, 10], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.finiteCoproduct.cocone", "code": "@[simps]\ndef finiteCoproduct.cocone (F : Discrete \u03b1 \u2964 Stonean) :\n    Cocone F where\n  pt := finiteCoproduct F.obj\n  \u03b9 := Discrete.natTrans fun a => finiteCoproduct.\u03b9 F.obj a", "start": [73, 1], "end": [78, 60], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.isColimit", "code": "@[simps]\ndef finiteCoproduct.isColimit (F : Discrete \u03b1 \u2964 Stonean) :\n    IsColimit (finiteCoproduct.cocone F) where\n  desc := fun s => finiteCoproduct.desc _ fun a => s.\u03b9.app a\n  fac := fun s \u27e8a\u27e9 => finiteCoproduct.\u03b9_desc _ _ _\n  uniq := fun s m hm => finiteCoproduct.hom_ext _ _ _ fun a => by\n    specialize hm a\n    ext t\n    apply_fun (fun q => q t) at hm\n    exact hm", "start": [80, 1], "end": [90, 13], "kind": "commanddeclaration"}, {"full_name": "Stonean.hasFiniteCoproducts", "code": "instance hasFiniteCoproducts : HasFiniteCoproducts Stonean.{u} where\n  out _ := {\n    has_colimit := fun F => {\n      exists_colimit := \u27e8{\n        cocone := finiteCoproduct.cocone F\n        isColimit := finiteCoproduct.isColimit F }\u27e9 } }", "start": [92, 1], "end": [99, 56], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.explicitCocone", "code": "@[simps]\ndef finiteCoproduct.explicitCocone : Limits.Cocone (Discrete.functor X) where\n  pt := finiteCoproduct X\n  \u03b9 := Discrete.natTrans fun \u27e8a\u27e9 => finiteCoproduct.\u03b9 X a", "start": [101, 1], "end": [107, 58], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.isColimit'", "code": "@[simps]\ndef finiteCoproduct.isColimit' : Limits.IsColimit (finiteCoproduct.explicitCocone X) where\n  desc := fun s => finiteCoproduct.desc _ fun a => s.\u03b9.app \u27e8a\u27e9\n  fac := fun s \u27e8a\u27e9 => finiteCoproduct.\u03b9_desc _ _ _\n  uniq := fun s m hm => finiteCoproduct.hom_ext _ _ _ fun a => by\n    specialize hm \u27e8a\u27e9\n    ext t\n    apply_fun (fun q => q t) at hm\n    exact hm", "start": [109, 1], "end": [120, 13], "kind": "commanddeclaration"}, {"full_name": "Stonean.coproductIsoCoproduct", "code": "noncomputable\ndef coproductIsoCoproduct : finiteCoproduct X \u2245 \u2210 X :=\nLimits.IsColimit.coconePointUniqueUpToIso\n  (finiteCoproduct.isColimit' X) (Limits.colimit.isColimit _)", "start": [122, 1], "end": [126, 62], "kind": "commanddeclaration"}, {"full_name": "Stonean.finiteCoproduct.openEmbedding_\u03b9", "code": "lemma finiteCoproduct.openEmbedding_\u03b9 {\u03b1 : Type} [Fintype \u03b1] (Z : \u03b1 \u2192 Stonean.{u}) (a : \u03b1) :\n    OpenEmbedding (finiteCoproduct.\u03b9 Z a) :=\n  openEmbedding_sigmaMk (\u03c3 := fun a => (Z a))", "start": [128, 1], "end": [131, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.Sigma.openEmbedding_\u03b9", "code": "lemma Sigma.openEmbedding_\u03b9 {\u03b1 : Type} [Fintype \u03b1] (Z : \u03b1 \u2192 Stonean.{u}) (a : \u03b1) :\n    OpenEmbedding (Sigma.\u03b9 Z a) := by\n  refine' OpenEmbedding.of_comp _ (homeoOfIso (coproductIsoCoproduct Z).symm).openEmbedding _\n  convert finiteCoproduct.openEmbedding_\u03b9 Z a\n  ext x\n  change ((Sigma.\u03b9 Z a) \u226b (coproductIsoCoproduct Z).inv) x = _\n  simp only [coproductIsoCoproduct, colimit.comp_coconePointUniqueUpToIso_inv,\n    finiteCoproduct.explicitCocone_pt, finiteCoproduct.explicitCocone_\u03b9, Discrete.natTrans_app]", "start": [133, 1], "end": [141, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullback", "code": "def pullback : Stonean where\n  compHaus := {\n    toTop := TopCat.of (f \u207b\u00b9' (Set.range i))\n    is_compact := by\n      dsimp [TopCat.of]\n      rw [\u2190 isCompact_iff_compactSpace]\n      refine IsClosed.isCompact (IsClosed.preimage f.continuous (IsCompact.isClosed ?_))\n      simp only [\u2190 Set.image_univ]\n      exact IsCompact.image isCompact_univ i.continuous\n    is_hausdorff := by\n      dsimp [TopCat.of]\n      exact inferInstance }\n  extrDisc := by\n    constructor\n    intro U hU\n    dsimp at U\n    have h : IsClopen (f \u207b\u00b9' (Set.range i))\n    \u00b7 constructor\n      \u00b7 exact IsOpen.preimage f.continuous hi.open_range\n      \u00b7 refine' IsClosed.preimage f.continuous _\n        apply IsCompact.isClosed\n        simp only [\u2190 Set.image_univ]\n        exact IsCompact.image isCompact_univ i.continuous\n    have hU' : IsOpen (Subtype.val '' U) := h.1.openEmbedding_subtype_val.isOpenMap U hU\n    have := ExtremallyDisconnected.open_closure _ hU'\n    rw [h.2.closedEmbedding_subtype_val.closure_image_eq U] at this\n    suffices hhU : closure U = Subtype.val \u207b\u00b9' (Subtype.val '' (closure U))\n    \u00b7 rw [hhU]\n      exact isOpen_induced this\n    exact ((closure U).preimage_image_eq Subtype.coe_injective).symm", "start": [155, 1], "end": [188, 69], "kind": "commanddeclaration"}, {"full_name": "Stonean.pullback.fst", "code": "def pullback.fst : pullback f hi \u27f6 X :=\n  \u27e8Subtype.val, continuous_subtype_val\u27e9", "start": [190, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "Stonean.pullback.snd", "code": "noncomputable\ndef pullback.snd : pullback f hi \u27f6 Y :=\n  \u27e8(Homeomorph.ofEmbedding i hi.toEmbedding).symm \u2218\n    Set.MapsTo.restrict f _ _ (Set.mapsTo_preimage f (Set.range i)),\n    (Homeomorph.ofEmbedding i hi.toEmbedding).symm.continuous.comp (Continuous.restrict\n    (Set.mapsTo_preimage f (Set.range i)) f.continuous)\u27e9", "start": [194, 1], "end": [200, 57], "kind": "commanddeclaration"}, {"full_name": "Stonean.pullback.lift", "code": "def pullback.lift {X Y Z W : Stonean} (f : X \u27f6 Z) {i : Y \u27f6 Z} (hi : OpenEmbedding i)\n    (a : W \u27f6 X) (b : W \u27f6 Y) (w : a \u226b f = b \u226b i) :\n    W \u27f6 pullback f hi where\n  toFun := fun z => \u27e8a z, by\n    simp only [Set.mem_preimage]\n    use (b z)\n    exact congr_fun (FunLike.ext'_iff.mp w.symm) z\u27e9\n  continuous_toFun := by\n    apply Continuous.subtype_mk\n    exact a.continuous", "start": [202, 1], "end": [216, 23], "kind": "commanddeclaration"}, {"full_name": "Stonean.pullback.condition", "code": "lemma pullback.condition {X Y Z : Stonean.{u}} (f : X \u27f6 Z) {i : Y \u27f6 Z}\n    (hi : OpenEmbedding i) : pullback.fst f hi \u226b f = pullback.snd f hi \u226b i := by\n  ext \u27e8x, h\u27e9\n  simp only [Set.mem_preimage] at h\n  obtain \u27e8y, hy\u27e9 := h\n  simp only [fst, snd, comp_apply]\n  change f x = _\n  erw [\u2190 hy, @ContinuousMap.coe_mk _ _ (Stonean.instTopologicalSpace (pullback f hi)) _ _ _]\n  congr\n  apply_fun (Homeomorph.ofEmbedding i hi.toEmbedding)\n  simpa only [Homeomorph.ofEmbedding, Homeomorph.homeomorph_mk_coe, Equiv.ofInjective_apply,\n    Homeomorph.homeomorph_mk_coe_symm, Set.MapsTo.restrict, Subtype.map, Function.comp_apply,\n    Equiv.apply_symm_apply, Subtype.mk.injEq]", "start": [218, 1], "end": [231, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullback.lift_fst", "code": "@[reassoc (attr := simp)]\nlemma pullback.lift_fst {W : Stonean} (a : W \u27f6 X) (b : W \u27f6 Y) (w : a \u226b f = b \u226b i) :\n    pullback.lift f hi a b w \u226b pullback.fst f hi = a := rfl", "start": [233, 1], "end": [235, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullback.lift_snd", "code": "@[reassoc (attr := simp)]\nlemma pullback.lift_snd {X Y Z W : Stonean} (f : X \u27f6 Z) {i : Y \u27f6 Z} (hi : OpenEmbedding i)\n    (a : W \u27f6 X) (b : W \u27f6 Y) (w : a \u226b f = b \u226b i) :\n    pullback.lift f hi a b w \u226b Stonean.pullback.snd f hi = b := by\n  congr\n  ext z\n  have := congr_fun (FunLike.ext'_iff.mp w.symm) z\n  have h : i (b z) = f (a z) := this\n  suffices : b z = (Homeomorph.ofEmbedding i hi.toEmbedding).symm (\u27e8f (a z), by rw [\u2190 h]; simp\u27e9)\n  \u00b7 exact this.symm\n  apply_fun (Homeomorph.ofEmbedding i hi.toEmbedding)\n  simpa only [Homeomorph.ofEmbedding, Homeomorph.homeomorph_mk_coe, Equiv.ofInjective_apply,\n    Homeomorph.homeomorph_mk_coe_symm, Equiv.apply_symm_apply, Subtype.mk.injEq]", "start": [237, 1], "end": [249, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullback.cone", "code": "@[simps! pt \u03c0]\nnoncomputable\ndef pullback.cone : Limits.PullbackCone f i :=\n  Limits.PullbackCone.mk (pullback.fst f hi) (pullback.snd f hi) (pullback.condition f hi)", "start": [251, 1], "end": [255, 91], "kind": "commanddeclaration"}, {"full_name": "Stonean.pullback.hom_ext", "code": "lemma pullback.hom_ext {X Y Z W : Stonean} (f : X \u27f6 Z) {i : Y \u27f6 Z} (hi : OpenEmbedding i)\n    (a : W \u27f6 (pullback.cone f hi).pt) (b : W \u27f6 (pullback.cone f hi).pt)\n    (hfst : a \u226b pullback.fst f hi = b \u226b pullback.fst f hi) : a = b := by\n  ext z\n  apply_fun (fun q => q z) at hfst\n  apply Subtype.ext\n  exact hfst", "start": [257, 1], "end": [263, 13], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullback.isLimit", "code": "def pullback.isLimit  : IsLimit (pullback.cone f hi) :=\n  Limits.PullbackCone.isLimitAux _\n    (fun s => pullback.lift f hi s.fst s.snd s.condition)\n    (fun _ => pullback.lift_fst _ _ _ _ _)\n    (fun _ => pullback.lift_snd _ _ _ _ _)\n    (fun _ _ hm => pullback.hom_ext _ _ _ _ (hm .left))", "start": [265, 1], "end": [271, 56], "kind": "commanddeclaration"}, {"full_name": "Stonean.HasPullbackOpenEmbedding", "code": "lemma HasPullbackOpenEmbedding : HasPullback f i :=\n  \u27e8pullback.cone f hi, pullback.isLimit f hi\u27e9", "start": [273, 1], "end": [274, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.pullbackIsoPullback", "code": "@[simps]\nnoncomputable\ndef pullbackIsoPullback : Stonean.pullback f hi \u2245\n    @Limits.pullback _ _ _ _ _ f i (HasPullbackOpenEmbedding f hi) :=\n  haveI : HasPullback f i := HasPullbackOpenEmbedding f hi\n  { hom :=\n      Limits.pullback.lift (pullback.fst _ hi) (pullback.snd _ hi) (pullback.condition f hi)\n    inv :=\n      pullback.lift f hi Limits.pullback.fst Limits.pullback.snd Limits.pullback.condition\n    hom_inv_id :=\n      pullback.hom_ext f hi _ _ (by simp only [pullback.cone_pt, Category.assoc, pullback.lift_fst,\n        limit.lift_\u03c0, PullbackCone.mk_pt, PullbackCone.mk_\u03c0_app, Category.id_comp])\n    inv_hom_id := by\n      refine' Limits.pullback.hom_ext (k := (pullback.lift f hi Limits.pullback.fst\n        Limits.pullback.snd Limits.pullback.condition \u226b Limits.pullback.lift\n        (pullback.fst _ hi) (pullback.snd _ hi) (pullback.condition f hi))) _ _\n      \u00b7 simp only [Category.assoc, limit.lift_\u03c0, PullbackCone.mk_pt, PullbackCone.mk_\u03c0_app,\n          pullback.lift_fst, Category.id_comp]\n      \u00b7 rw [Category.id_comp, Category.assoc, Limits.pullback.lift_snd, pullback.lift_snd] }", "start": [278, 1], "end": [297, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/Limits.lean", "imports": ["Mathlib/Topology/Category/Profinite/Basic.lean", "Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Profinite.pullback", "code": "def pullback : Profinite.{u} :=\n  letI set := { xy : X \u00d7 Y | f xy.fst = g xy.snd }\n  haveI : CompactSpace set := isCompact_iff_compactSpace.mp\n    (isClosed_eq (f.continuous.comp continuous_fst) (g.continuous.comp continuous_snd)).isCompact\n  Profinite.of set", "start": [33, 1], "end": [41, 19], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback.fst", "code": "def pullback.fst : pullback f g \u27f6 X where\n  toFun := fun \u27e8\u27e8x, _\u27e9, _\u27e9 => x\n  continuous_toFun := Continuous.comp continuous_fst continuous_subtype_val", "start": [43, 1], "end": [46, 76], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback.snd", "code": "def pullback.snd : pullback f g \u27f6 Y where\n  toFun := fun \u27e8\u27e8_, y\u27e9, _\u27e9 => y\n  continuous_toFun := Continuous.comp continuous_snd continuous_subtype_val", "start": [48, 1], "end": [51, 76], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback.condition", "code": "@[reassoc]\nlemma pullback.condition : pullback.fst f g \u226b f = pullback.snd f g \u226b g := by\n  ext \u27e8_, h\u27e9\n  exact h", "start": [53, 1], "end": [56, 10], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.pullback.lift", "code": "def pullback.lift {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    Z \u27f6 pullback f g where\n  toFun := fun z => \u27e8\u27e8a z, b z\u27e9, by apply_fun (\u00b7 z) at w; exact w\u27e9\n  continuous_toFun := by\n    apply Continuous.subtype_mk\n    rw [continuous_prod_mk]\n    exact \u27e8a.continuous, b.continuous\u27e9", "start": [58, 1], "end": [69, 39], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback.lift_fst", "code": "@[reassoc (attr := simp)]\nlemma pullback.lift_fst {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    pullback.lift f g a b w \u226b pullback.fst f g = a := rfl", "start": [71, 1], "end": [73, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.pullback.lift_snd", "code": "@[reassoc (attr := simp)]\nlemma pullback.lift_snd {Z : Profinite.{u}} (a : Z \u27f6 X) (b : Z \u27f6 Y) (w : a \u226b f = b \u226b g) :\n    pullback.lift f g a b w \u226b pullback.snd f g = b := rfl", "start": [75, 1], "end": [77, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.pullback.hom_ext", "code": "lemma pullback.hom_ext {Z : Profinite.{u}} (a b : Z \u27f6 pullback f g)\n    (hfst : a \u226b pullback.fst f g = b \u226b pullback.fst f g)\n    (hsnd : a \u226b pullback.snd f g = b \u226b pullback.snd f g) : a = b := by\n  ext z\n  apply_fun (\u00b7 z) at hfst hsnd\n  apply Subtype.ext\n  apply Prod.ext\n  \u00b7 exact hfst\n  \u00b7 exact hsnd", "start": [79, 1], "end": [87, 15], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.pullback.cone", "code": "@[simps! pt \u03c0]\ndef pullback.cone : Limits.PullbackCone f g :=\n  Limits.PullbackCone.mk (pullback.fst f g) (pullback.snd f g) (pullback.condition f g)", "start": [89, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback.isLimit", "code": "@[simps! lift]\ndef pullback.isLimit : Limits.IsLimit (pullback.cone f g) :=\n  Limits.PullbackCone.isLimitAux _\n    (fun s => pullback.lift f g s.fst s.snd s.condition)\n    (fun _ => pullback.lift_fst _ _ _ _ _)\n    (fun _ => pullback.lift_snd _ _ _ _ _)\n    (fun _ _ hm => pullback.hom_ext _ _ _ _ (hm .left) (hm .right))", "start": [94, 1], "end": [101, 68], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullbackIsoPullback", "code": "noncomputable\ndef pullbackIsoPullback : Profinite.pullback f g \u2245 Limits.pullback f g :=\nLimits.IsLimit.conePointUniqueUpToIso (pullback.isLimit f g) (Limits.limit.isLimit _)", "start": [105, 1], "end": [108, 86], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullbackHomeoPullback", "code": "noncomputable\ndef pullbackHomeoPullback : (Profinite.pullback f g).toCompHaus \u2243\u209c\n    (Limits.pullback f g).toCompHaus :=\nProfinite.homeoOfIso (pullbackIsoPullback f g)", "start": [110, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback_fst_eq", "code": "theorem pullback_fst_eq :\n    Profinite.pullback.fst f g = (pullbackIsoPullback f g).hom \u226b Limits.pullback.fst", "start": [116, 1], "end": [119, 94], "kind": "commanddeclaration"}, {"full_name": "Profinite.pullback_snd_eq", "code": "theorem pullback_snd_eq :\n    Profinite.pullback.snd f g = (pullbackIsoPullback f g).hom \u226b Limits.pullback.snd", "start": [121, 1], "end": [124, 94], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct", "code": "def finiteCoproduct : Profinite := Profinite.of <| \u03a3 (a : \u03b1), X a", "start": [134, 1], "end": [138, 66], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct.\u03b9", "code": "def finiteCoproduct.\u03b9 (a : \u03b1) : X a \u27f6 finiteCoproduct X where\n  toFun := (\u27e8a, \u00b7\u27e9)\n  continuous_toFun := continuous_sigmaMk (\u03c3 := fun a => X a)", "start": [140, 1], "end": [143, 61], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct.desc", "code": "def finiteCoproduct.desc {B : Profinite.{u}} (e : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    finiteCoproduct X \u27f6 B where\n  toFun := fun \u27e8a, x\u27e9 => e a x\n  continuous_toFun := by\n    apply continuous_sigma\n    intro a\n    exact (e a).continuous", "start": [145, 1], "end": [156, 27], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct.\u03b9_desc", "code": "@[reassoc (attr := simp)]\nlemma finiteCoproduct.\u03b9_desc {B : Profinite.{u}} (e : (a : \u03b1) \u2192 (X a \u27f6 B)) (a : \u03b1) :\n    finiteCoproduct.\u03b9 X a \u226b finiteCoproduct.desc X e = e a := rfl", "start": [158, 1], "end": [160, 66], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.finiteCoproduct.hom_ext", "code": "lemma finiteCoproduct.hom_ext {B : Profinite.{u}} (f g : finiteCoproduct X \u27f6 B)\n    (h : \u2200 a : \u03b1, finiteCoproduct.\u03b9 X a \u226b f = finiteCoproduct.\u03b9 X a \u226b g) : f = g := by\n  ext \u27e8a, x\u27e9\n  specialize h a\n  apply_fun (\u00b7 x) at h\n  exact h", "start": [162, 1], "end": [167, 10], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.finiteCoproduct.cocone", "code": "@[simps]\ndef finiteCoproduct.cocone : Limits.Cocone (Discrete.functor X) where\n  pt := finiteCoproduct X\n  \u03b9 := Discrete.natTrans fun \u27e8a\u27e9 => finiteCoproduct.\u03b9 X a", "start": [169, 1], "end": [173, 58], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct.isColimit", "code": "@[simps]\ndef finiteCoproduct.isColimit : Limits.IsColimit (finiteCoproduct.cocone X) where\n  desc := fun s => finiteCoproduct.desc _ fun a => s.\u03b9.app \u27e8a\u27e9\n  fac := fun s \u27e8a\u27e9 => finiteCoproduct.\u03b9_desc _ _ _\n  uniq := fun s m hm => finiteCoproduct.hom_ext _ _ _ fun a => by\n    specialize hm \u27e8a\u27e9\n    ext t\n    apply_fun (\u00b7 t) at hm\n    exact hm", "start": [175, 1], "end": [184, 13], "kind": "commanddeclaration"}, {"full_name": "Profinite.coproductIsoCoproduct", "code": "noncomputable\ndef coproductIsoCoproduct : finiteCoproduct X \u2245 \u2210 X :=\nLimits.IsColimit.coconePointUniqueUpToIso (finiteCoproduct.isColimit X) (Limits.colimit.isColimit _)", "start": [188, 1], "end": [191, 101], "kind": "commanddeclaration"}, {"full_name": "Profinite.Sigma.\u03b9_comp_toFiniteCoproduct", "code": "theorem Sigma.\u03b9_comp_toFiniteCoproduct (a : \u03b1) :\n    (Limits.Sigma.\u03b9 X a) \u226b (coproductIsoCoproduct X).inv = finiteCoproduct.\u03b9 X a", "start": [193, 1], "end": [196, 80], "kind": "commanddeclaration"}, {"full_name": "Profinite.coproductHomeoCoproduct", "code": "noncomputable\ndef coproductHomeoCoproduct : finiteCoproduct X \u2243\u209c (\u2210 X : _) :=\nProfinite.homeoOfIso (coproductIsoCoproduct X)", "start": [198, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "Profinite.finiteCoproduct.\u03b9_injective", "code": "lemma finiteCoproduct.\u03b9_injective (a : \u03b1) : Function.Injective (finiteCoproduct.\u03b9 X a) := by\n  intro x y hxy\n  exact eq_of_heq (Sigma.ext_iff.mp hxy).2", "start": [205, 1], "end": [207, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.finiteCoproduct.\u03b9_jointly_surjective", "code": "lemma finiteCoproduct.\u03b9_jointly_surjective (R : finiteCoproduct X) :\n    \u2203 (a : \u03b1) (r : X a), R = finiteCoproduct.\u03b9 X a r := \u27e8R.fst, R.snd, rfl\u27e9", "start": [209, 1], "end": [210, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.finiteCoproduct.\u03b9_desc_apply", "code": "lemma finiteCoproduct.\u03b9_desc_apply {B : Profinite} {\u03c0 : (a : \u03b1) \u2192 X a \u27f6 B} (a : \u03b1) :\n    \u2200 x, finiteCoproduct.desc X \u03c0 (finiteCoproduct.\u03b9 X a x) = \u03c0 a x := by\n  intro x\n  change (\u03b9 X a \u226b desc X \u03c0) _ = _\n  simp only [\u03b9_desc]", "start": [212, 1], "end": [216, 21], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Filter.lean", "imports": ["Mathlib/Data/Set/Intervals/Monotone.lean", "Mathlib/Topology/Separation.lean", "Mathlib/Order/Filter/Lift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.isOpen_Iic_principal", "code": "theorem isOpen_Iic_principal {s : Set \u03b1} : IsOpen (Iic (\ud835\udcdf s))", "start": [51, 1], "end": [52, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.isOpen_setOf_mem", "code": "theorem isOpen_setOf_mem {s : Set \u03b1} : IsOpen { l : Filter \u03b1 | s \u2208 l }", "start": [55, 1], "end": [56, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.isTopologicalBasis_Iic_principal", "code": "theorem isTopologicalBasis_Iic_principal :\n    IsTopologicalBasis (range (Iic \u2218 \ud835\udcdf : Set \u03b1 \u2192 Set (Filter \u03b1)))", "start": [59, 1], "end": [66, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.isOpen_iff", "code": "theorem isOpen_iff {s : Set (Filter \u03b1)} : IsOpen s \u2194 \u2203 T : Set (Set \u03b1), s = \u22c3 t \u2208 T, Iic (\ud835\udcdf t)", "start": [69, 1], "end": [71, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_eq", "code": "theorem nhds_eq (l : Filter \u03b1) : \ud835\udcdd l = l.lift' (Iic \u2218 \ud835\udcdf)", "start": [74, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_eq'", "code": "theorem nhds_eq' (l : Filter \u03b1) : \ud835\udcdd l = l.lift' fun s => { l' | s \u2208 l' }", "start": [80, 1], "end": [81, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds", "code": "protected theorem tendsto_nhds {la : Filter \u03b1} {lb : Filter \u03b2} {f : \u03b1 \u2192 Filter \u03b2} :\n    Tendsto f la (\ud835\udcdd lb) \u2194 \u2200 s \u2208 lb, \u2200\u1da0 a in la, s \u2208 f a", "start": [84, 1], "end": [86, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.nhds", "code": "protected theorem HasBasis.nhds {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : HasBasis l p s) :\n    HasBasis (\ud835\udcdd l) p fun i => Iic (\ud835\udcdf (s i))", "start": [89, 1], "end": [92, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pure_self", "code": "protected theorem tendsto_pure_self (l : Filter X) :\n    Tendsto (pure : X \u2192 Filter X) l (\ud835\udcdd l)", "start": [95, 1], "end": [98, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.nhds'", "code": "theorem HasBasis.nhds' {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : HasBasis l p s) :\n    HasBasis (\ud835\udcdd l) p fun i => { l' | s i \u2208 l' }", "start": [105, 1], "end": [106, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_nhds_iff", "code": "theorem mem_nhds_iff {l : Filter \u03b1} {S : Set (Filter \u03b1)} : S \u2208 \ud835\udcdd l \u2194 \u2203 t \u2208 l, Iic (\ud835\udcdf t) \u2286 S", "start": [109, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_nhds_iff'", "code": "theorem mem_nhds_iff' {l : Filter \u03b1} {S : Set (Filter \u03b1)} :\n    S \u2208 \ud835\udcdd l \u2194 \u2203 t \u2208 l, \u2200 \u2983l' : Filter \u03b1\u2984, t \u2208 l' \u2192 l' \u2208 S", "start": [113, 1], "end": [115, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_bot", "code": "@[simp]\ntheorem nhds_bot : \ud835\udcdd (\u22a5 : Filter \u03b1) = pure \u22a5", "start": [118, 1], "end": [120, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_top", "code": "@[simp]\ntheorem nhds_top : \ud835\udcdd (\u22a4 : Filter \u03b1) = \u22a4", "start": [123, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_principal", "code": "@[simp]\ntheorem nhds_principal (s : Set \u03b1) : \ud835\udcdd (\ud835\udcdf s) = \ud835\udcdf (Iic (\ud835\udcdf s))", "start": [127, 1], "end": [129, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_pure", "code": "@[simp]\ntheorem nhds_pure (x : \u03b1) : \ud835\udcdd (pure x : Filter \u03b1) = \ud835\udcdf {\u22a5, pure x}", "start": [132, 1], "end": [134, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_iInf", "code": "@[simp]\ntheorem nhds_iInf (f : \u03b9 \u2192 Filter \u03b1) : \ud835\udcdd (\u2a05 i, f i) = \u2a05 i, \ud835\udcdd (f i)", "start": [137, 1], "end": [140, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_inf", "code": "@[simp]\ntheorem nhds_inf (l\u2081 l\u2082 : Filter \u03b1) : \ud835\udcdd (l\u2081 \u2293 l\u2082) = \ud835\udcdd l\u2081 \u2293 \ud835\udcdd l\u2082", "start": [143, 1], "end": [145, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_nhds", "code": "theorem monotone_nhds : Monotone (\ud835\udcdd : Filter \u03b1 \u2192 Filter (Filter \u03b1))", "start": [148, 1], "end": [149, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.sInter_nhds", "code": "theorem sInter_nhds (l : Filter \u03b1) : \u22c2\u2080 { s | s \u2208 \ud835\udcdd l } = Iic l", "start": [152, 1], "end": [154, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_mono", "code": "@[simp]\ntheorem nhds_mono {l\u2081 l\u2082 : Filter \u03b1} : \ud835\udcdd l\u2081 \u2264 \ud835\udcdd l\u2082 \u2194 l\u2081 \u2264 l\u2082", "start": [157, 1], "end": [161, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_interior", "code": "protected theorem mem_interior {s : Set (Filter \u03b1)} {l : Filter \u03b1} :\n    l \u2208 interior s \u2194 \u2203 t \u2208 l, Iic (\ud835\udcdf t) \u2286 s", "start": [164, 1], "end": [165, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_closure", "code": "protected theorem mem_closure {s : Set (Filter \u03b1)} {l : Filter \u03b1} :\n    l \u2208 closure s \u2194 \u2200 t \u2208 l, \u2203 l' \u2208 s, t \u2208 l'", "start": [168, 1], "end": [172, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.closure_singleton", "code": "@[simp]\nprotected theorem closure_singleton (l : Filter \u03b1) : closure {l} = Ici l", "start": [175, 1], "end": [178, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.specializes_iff_le", "code": "@[simp]\ntheorem specializes_iff_le {l\u2081 l\u2082 : Filter \u03b1} : l\u2081 \u2933 l\u2082 \u2194 l\u2081 \u2264 l\u2082", "start": [181, 1], "end": [183, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_atTop", "code": "theorem nhds_atTop [Preorder \u03b1] : \ud835\udcdd atTop = \u2a05 x : \u03b1, \ud835\udcdf (Iic (\ud835\udcdf (Ici x)))", "start": [190, 1], "end": [191, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_atTop_iff", "code": "protected theorem tendsto_nhds_atTop_iff [Preorder \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 Filter \u03b2} :\n    Tendsto f l (\ud835\udcdd atTop) \u2194 \u2200 y, \u2200\u1da0 a in l, Ici y \u2208 f a", "start": [194, 1], "end": [196, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_atBot", "code": "theorem nhds_atBot [Preorder \u03b1] : \ud835\udcdd atBot = \u2a05 x : \u03b1, \ud835\udcdf (Iic (\ud835\udcdf (Iic x)))", "start": [199, 1], "end": [200, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_atBot_iff", "code": "protected theorem tendsto_nhds_atBot_iff [Preorder \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 Filter \u03b2} :\n    Tendsto f l (\ud835\udcdd atBot) \u2194 \u2200 y, \u2200\u1da0 a in l, Iic y \u2208 f a", "start": [203, 1], "end": [205, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.nhds_nhds", "code": "theorem nhds_nhds (x : X) : \ud835\udcdd (\ud835\udcdd x) = \u2a05 (s : Set X) (_ : IsOpen s) (_ : x \u2208 s), \ud835\udcdf (Iic (\ud835\udcdf s))", "start": [210, 1], "end": [211, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.inducing_nhds", "code": "theorem inducing_nhds : Inducing (\ud835\udcdd : X \u2192 Filter X)", "start": [214, 1], "end": [219, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.continuous_nhds", "code": "@[continuity]\ntheorem continuous_nhds : Continuous (\ud835\udcdd : X \u2192 Filter X)", "start": [222, 1], "end": [224, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nhds", "code": "protected theorem Tendsto.nhds {f : \u03b1 \u2192 X} {l : Filter \u03b1} {x : X} (h : Tendsto f l (\ud835\udcdd x)) :\n    Tendsto (\ud835\udcdd \u2218 f) l (\ud835\udcdd (\ud835\udcdd x))", "start": [227, 1], "end": [229, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.nhds", "code": "protected nonrec theorem ContinuousWithinAt.nhds (h : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (\ud835\udcdd \u2218 f) s x", "start": [236, 1], "end": [238, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.nhds", "code": "protected nonrec theorem ContinuousAt.nhds (h : ContinuousAt f x) : ContinuousAt (\ud835\udcdd \u2218 f) x", "start": [241, 1], "end": [242, 9], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.nhds", "code": "protected nonrec theorem ContinuousOn.nhds (h : ContinuousOn f s) : ContinuousOn (\ud835\udcdd \u2218 f) s", "start": [245, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "Continuous.nhds", "code": "protected nonrec theorem Continuous.nhds (h : Continuous f) : Continuous (\ud835\udcdd \u2218 f)", "start": [249, 1], "end": [250, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Dvd.lean", "imports": ["Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Prime.dvd_choose_add", "code": "theorem dvd_choose_add (hp : Prime p) (hap : a < p) (hbp : b < p) (h : p \u2264 a + b) :\n    p \u2223 choose (a + b) a", "start": [24, 1], "end": [29, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_choose", "code": "lemma dvd_choose (hp : Prime p) (ha : a < p) (hab : b - a < p) (h : p \u2264 b) : p \u2223 choose b a :=\n  have : a + (b - a) = b := Nat.add_sub_of_le (ha.le.trans h)\n  this \u25b8 hp.dvd_choose_add ha hab (this.symm \u25b8 h)", "start": [32, 1], "end": [34, 50], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.Prime.dvd_choose_self", "code": "lemma dvd_choose_self (hp : Prime p) (hk : k \u2260 0) (hkp : k < p) : p \u2223 choose p k :=\n  hp.dvd_choose hkp (sub_lt ((zero_le _).trans_lt hkp) hk.bot_lt) le_rfl", "start": [37, 1], "end": [38, 73], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/DFinsupp/Lex.lean", "imports": ["Mathlib/Data/DFinsupp/Order.lean", "Mathlib/Data/DFinsupp/NeLocus.lean", "Mathlib/Order/WellFoundedSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFinsupp.Lex", "code": "protected def Lex (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop) (x y : \u03a0\u2080 i, \u03b1 i) : Prop :=\n  Pi.Lex r (s _) x y", "start": [27, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Pi.lex_eq_dfinsupp_lex", "code": "theorem _root_.Pi.lex_eq_dfinsupp_lex {r : \u03b9 \u2192 \u03b9 \u2192 Prop} {s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop}\n    (a b : \u03a0\u2080 i, \u03b1 i) : Pi.Lex r (s _) (a : \u2200 i, \u03b1 i) b = DFinsupp.Lex r s a b", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lex_def", "code": "theorem lex_def {r : \u03b9 \u2192 \u03b9 \u2192 Prop} {s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop} {a b : \u03a0\u2080 i, \u03b1 i} :\n    DFinsupp.Lex r s a b \u2194 \u2203 j, (\u2200 d, r d j \u2192 a d = b d) \u2227 s j (a j) (b j)", "start": [42, 1], "end": [44, 10], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lex_lt_of_lt_of_preorder", "code": "theorem lex_lt_of_lt_of_preorder [\u2200 i, Preorder (\u03b1 i)] (r) [IsStrictOrder \u03b9 r] {x y : \u03a0\u2080 i, \u03b1 i}\n    (hlt : x < y) : \u2203 i, (\u2200 j, r j i \u2192 x j \u2264 y j \u2227 y j \u2264 x j) \u2227 x i < y i", "start": [50, 1], "end": [57, 99], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lex_lt_of_lt", "code": "theorem lex_lt_of_lt [\u2200 i, PartialOrder (\u03b1 i)] (r) [IsStrictOrder \u03b9 r] {x y : \u03a0\u2080 i, \u03b1 i}\n    (hlt : x < y) : Pi.Lex r (\u00b7 < \u00b7) x y", "start": [60, 1], "end": [63, 39], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.isStrictOrder", "code": "instance Lex.isStrictOrder [\u2200 i, PartialOrder (\u03b1 i)] :\n    IsStrictOrder (Lex (\u03a0\u2080 i, \u03b1 i)) (\u00b7 < \u00b7) :=\n  let i : IsStrictOrder (Lex (\u2200 i, \u03b1 i)) (\u00b7 < \u00b7) := Pi.Lex.isStrictOrder\n  { irrefl := toLex.surjective.forall.2 fun _ \u21a6 @irrefl _ _ i.toIsIrrefl _\n    trans := toLex.surjective.forall\u2083.2 fun _ _ _ \u21a6 @trans _ _ i.toIsTrans _ _ _ }", "start": [68, 1], "end": [72, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.partialOrder", "code": "instance Lex.partialOrder [\u2200 i, PartialOrder (\u03b1 i)] : PartialOrder (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  lt := (\u00b7 < \u00b7)\n  le x y := \u21d1(ofLex x) = \u21d1(ofLex y) \u2228 x < y\n  __ := PartialOrder.lift (fun x : Lex (\u03a0\u2080 i, \u03b1 i) \u21a6 toLex (\u21d1(ofLex x)))\n    (FunLike.coe_injective (F := DFinsupp \u03b1))", "start": [75, 1], "end": [81, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lt_trichotomy_rec", "code": "private def lt_trichotomy_rec {P : Lex (\u03a0\u2080 i, \u03b1 i) \u2192 Lex (\u03a0\u2080 i, \u03b1 i) \u2192 Sort*}\n    (h_lt : \u2200 {f g}, toLex f < toLex g \u2192 P (toLex f) (toLex g))\n    (h_eq : \u2200 {f g}, toLex f = toLex g \u2192 P (toLex f) (toLex g))\n    (h_gt : \u2200 {f g}, toLex g < toLex f \u2192 P (toLex f) (toLex g)) : \u2200 f g, P f g :=\n  Lex.rec fun f \u21a6 Lex.rec fun g \u21a6 match (motive := \u2200 y, (f.neLocus g).min = y \u2192 _) _, rfl with\n  | \u22a4, h => h_eq (neLocus_eq_empty.mp <| Finset.min_eq_top.mp h)\n  | (wit : \u03b9), h => by\n    apply (mem_neLocus.mp <| Finset.mem_of_min h).lt_or_lt.by_cases <;> intro hwit\n    \u00b7 exact h_lt \u27e8wit, fun j hj \u21a6 not_mem_neLocus.mp (Finset.not_mem_of_lt_min hj h), hwit\u27e9\n    \u00b7 exact h_gt \u27e8wit, fun j hj \u21a6\n        not_mem_neLocus.mp (Finset.not_mem_of_lt_min hj <| by rwa [neLocus_comm]), hwit\u27e9", "start": [88, 1], "end": [100, 89], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.decidableLE", "code": "irreducible_def Lex.decidableLE : @DecidableRel (Lex (\u03a0\u2080 i, \u03b1 i)) (\u00b7 \u2264 \u00b7) :=\n  lt_trichotomy_rec (fun h \u21a6 isTrue <| Or.inr h)\n    (fun h \u21a6 isTrue <| Or.inl <| congr_arg _ h)\n    fun h \u21a6 isFalse fun h' \u21a6 lt_irrefl _ (h.trans_le h')", "start": [102, 1], "end": [106, 57], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "DFinsupp.Lex.decidableLT", "code": "irreducible_def Lex.decidableLT : @DecidableRel (Lex (\u03a0\u2080 i, \u03b1 i)) (\u00b7 < \u00b7) :=\n  lt_trichotomy_rec (fun h \u21a6 isTrue h) (fun h \u21a6 isFalse h.not_lt) fun h \u21a6 isFalse h.asymm", "start": [109, 1], "end": [111, 90], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "DFinsupp.Lex.linearOrder", "code": "instance Lex.linearOrder : LinearOrder (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  __ := Lex.partialOrder\n  le_total := lt_trichotomy_rec (fun h \u21a6 Or.inl h.le) (fun h \u21a6 Or.inl h.le) fun h \u21a6 Or.inr h.le\n  decidableLT := decidableLT\n  decidableLE := decidableLE\n  decidableEq := inferInstance", "start": [119, 1], "end": [125, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toLex_monotone", "code": "theorem toLex_monotone : Monotone (@toLex (\u03a0\u2080 i, \u03b1 i))", "start": [132, 1], "end": [138, 59], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lt_of_forall_lt_of_lt", "code": "theorem lt_of_forall_lt_of_lt (a b : Lex (\u03a0\u2080 i, \u03b1 i)) (i : \u03b9) :\n    (\u2200 j < i, ofLex a j = ofLex b j) \u2192 ofLex a i < ofLex b i \u2192 a < b", "start": [141, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.covariantClass_lt_left", "code": "instance Lex.covariantClass_lt_left :\n    CovariantClass (Lex (\u03a0\u2080 i, \u03b1 i)) (Lex (\u03a0\u2080 i, \u03b1 i)) (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun _ _ _ \u27e8a, lta, ha\u27e9 \u21a6 \u27e8a, fun j ja \u21a6 congr_arg _ (lta j ja), add_lt_add_left ha _\u27e9\u27e9", "start": [162, 1], "end": [164, 90], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.covariantClass_le_left", "code": "instance Lex.covariantClass_le_left :\n    CovariantClass (Lex (\u03a0\u2080 i, \u03b1 i)) (Lex (\u03a0\u2080 i, \u03b1 i)) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  covariantClass_le_of_lt _ _ _", "start": [167, 1], "end": [169, 32], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.covariantClass_lt_right", "code": "instance Lex.covariantClass_lt_right :\n    CovariantClass (Lex (\u03a0\u2080 i, \u03b1 i)) (Lex (\u03a0\u2080 i, \u03b1 i)) (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun f _ _ \u27e8a, lta, ha\u27e9 \u21a6\n    \u27e8a, fun j ja \u21a6 congr_arg (\u00b7 + ofLex f j) (lta j ja), add_lt_add_right ha _\u27e9\u27e9", "start": [178, 1], "end": [181, 81], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.covariantClass_le_right", "code": "instance Lex.covariantClass_le_right :\n    CovariantClass (Lex (\u03a0\u2080 i, \u03b1 i)) (Lex (\u03a0\u2080 i, \u03b1 i)) (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  covariantClass_le_of_lt _ _ _", "start": [184, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.orderBot", "code": "instance Lex.orderBot [\u2200 i, CanonicallyOrderedAddCommMonoid (\u03b1 i)] :\n    OrderBot (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  bot := 0\n  bot_le _ := DFinsupp.toLex_monotone bot_le", "start": [197, 1], "end": [200, 45], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.orderedAddCancelCommMonoid", "code": "instance Lex.orderedAddCancelCommMonoid [\u2200 i, OrderedCancelAddCommMonoid (\u03b1 i)] :\n    OrderedCancelAddCommMonoid (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  add_le_add_left _ _ h _ := add_le_add_left (\u03b1 := Lex (\u2200 i, \u03b1 i)) h _\n  le_of_add_le_add_left _ _ _ := le_of_add_le_add_left (\u03b1 := Lex (\u2200 i, \u03b1 i))", "start": [202, 1], "end": [205, 77], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.orderedAddCommGroup", "code": "instance Lex.orderedAddCommGroup [\u2200 i, OrderedAddCommGroup (\u03b1 i)] :\n    OrderedAddCommGroup (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  add_le_add_left _ _ := add_le_add_left", "start": [207, 1], "end": [209, 41], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.linearOrderedCancelAddCommMonoid", "code": "instance Lex.linearOrderedCancelAddCommMonoid\n    [\u2200 i, LinearOrderedCancelAddCommMonoid (\u03b1 i)] :\n    LinearOrderedCancelAddCommMonoid (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  __ : LinearOrder (Lex (\u03a0\u2080 i, \u03b1 i)) := inferInstance\n  __ : OrderedCancelAddCommMonoid (Lex (\u03a0\u2080 i, \u03b1 i)) := inferInstance", "start": [211, 1], "end": [215, 69], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.Lex.linearOrderedAddCommGroup", "code": "instance Lex.linearOrderedAddCommGroup [\u2200 i, LinearOrderedAddCommGroup (\u03b1 i)] :\n    LinearOrderedAddCommGroup (Lex (\u03a0\u2080 i, \u03b1 i)) where\n  __ : LinearOrder (Lex (\u03a0\u2080 i, \u03b1 i)) := inferInstance\n  add_le_add_left _ _ := add_le_add_left", "start": [217, 1], "end": [220, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Upto.lean", "imports": ["Mathlib/Data/Nat/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Upto", "code": "@[reducible]\ndef Upto (p : \u2115 \u2192 Prop) : Type :=\n  { i : \u2115 // \u2200 j < i, \u00acp j }", "start": [28, 1], "end": [36, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Upto.GT", "code": "protected def GT (p) (x y : Upto p) : Prop :=\n  x.1 > y.1", "start": [43, 1], "end": [45, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.Upto.wf", "code": "protected theorem wf : (\u2203 x, p x) \u2192 WellFounded (Upto.GT p)", "start": [51, 1], "end": [60, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.Upto.zero", "code": "def zero : Nat.Upto p :=\n  \u27e80, fun _ h => False.elim (Nat.not_lt_zero _ h)\u27e9", "start": [63, 1], "end": [65, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.Upto.succ", "code": "def succ (x : Nat.Upto p) (h : \u00acp x.val) : Nat.Upto p :=\n  \u27e8x.val.succ, fun j h' => by\n    rcases Nat.lt_succ_iff_lt_or_eq.1 h' with (h' | rfl) <;> [exact x.2 _ h'; exact h]\u27e9", "start": [68, 1], "end": [71, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/DomAct/Basic.lean", "imports": ["Mathlib/Algebra/Group/Opposite.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "Mathlib/Algebra/Group/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DomMulAct", "code": "@[to_additive \"If `M` additively acts on `\u03b1`, then `DomAddAct M` acts on `\u03b1 \u2192 \u03b2` as\nwell as some bundled maps from `\u03b1`. This is a type synonym for `AddOpposite M`, so this corresponds\nto a right action of `M`.\"]\ndef DomMulAct (M : Type*) := MulOpposite M", "start": [86, 1], "end": [92, 43], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk", "code": "@[to_additive \"Equivalence between `M` and `M\u1d48\u1d50\u1d43`.\"]\ndef mk : M \u2243 M\u1d48\u1d50\u1d43 := MulOpposite.opEquiv", "start": [99, 1], "end": [101, 41], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_one", "code": "@[to_additive (attr := simp)]\nlemma mk_one [One M] : mk (1 : M) = 1 := rfl", "start": [122, 1], "end": [123, 45], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.symm_mk_one", "code": "@[to_additive (attr := simp)]\nlemma symm_mk_one [One M] : mk.symm (1 : M\u1d48\u1d50\u1d43) = 1 := rfl", "start": [125, 1], "end": [126, 58], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.mk_mul", "code": "@[to_additive (attr := simp)]\nlemma mk_mul [Mul M] (a b : M) : mk (a * b) = mk b * mk a := rfl", "start": [128, 1], "end": [129, 65], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.symm_mk_mul", "code": "@[to_additive (attr := simp)]\nlemma symm_mk_mul [Mul M] (a b : M\u1d48\u1d50\u1d43) : mk.symm (a * b) = mk.symm b * mk.symm a := rfl", "start": [131, 1], "end": [132, 88], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.mk_inv", "code": "@[to_additive (attr := simp)]\nlemma mk_inv [Inv M] (a : M) : mk (a\u207b\u00b9) = (mk a)\u207b\u00b9 := rfl", "start": [134, 1], "end": [135, 58], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.symm_mk_inv", "code": "@[to_additive (attr := simp)]\nlemma symm_mk_inv [Inv M] (a : M\u1d48\u1d50\u1d43) : mk.symm (a\u207b\u00b9) = (mk.symm a)\u207b\u00b9 := rfl", "start": [137, 1], "end": [138, 76], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.mk_pow", "code": "@[to_additive (attr := simp)]\nlemma mk_pow [Monoid M] (a : M) (n : \u2115) : mk (a ^ n) = mk a ^ n := rfl", "start": [140, 1], "end": [141, 71], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.symm_mk_pow", "code": "@[to_additive (attr := simp)]\nlemma symm_mk_pow [Monoid M] (a : M\u1d48\u1d50\u1d43) (n : \u2115) : mk.symm (a ^ n) = mk.symm a ^ n := rfl", "start": [143, 1], "end": [144, 89], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.mk_zpow", "code": "@[to_additive (attr := simp)]\nlemma mk_zpow [DivInvMonoid M] (a : M) (n : \u2124) : mk (a ^ n) = mk a ^ n := rfl", "start": [146, 1], "end": [147, 78], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.symm_mk_zpow", "code": "@[to_additive (attr := simp)]\nlemma symm_mk_zpow [DivInvMonoid M] (a : M\u1d48\u1d50\u1d43) (n : \u2124) : mk.symm (a ^ n) = mk.symm a ^ n := rfl", "start": [149, 1], "end": [150, 96], "kind": "mathlibtacticlemma"}, {"full_name": "DomMulAct.smul_apply", "code": "@[to_additive]\ntheorem smul_apply [SMul M \u03b1] (c : M\u1d48\u1d50\u1d43) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : (c \u2022 f) a = f (mk.symm c \u2022 a)", "start": [158, 1], "end": [159, 100], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_monoidHom_apply", "code": "theorem smul_monoidHom_apply (c : M\u1d48\u1d50\u1d43) (f : A \u2192* B) (a : A) : (c \u2022 f) a = f (mk.symm c \u2022 a)", "start": [208, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_monoidHom_apply", "code": "@[simp]\ntheorem mk_smul_monoidHom_apply (c : M) (f : A \u2192* B) (a : A) : (mk c \u2022 f) a = f (c \u2022 a)", "start": [211, 1], "end": [212, 95], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_addMonoidHom_apply", "code": "theorem smul_addMonoidHom_apply (c : M\u1d48\u1d50\u1d43) (f : A \u2192+ B) (a : A) : (c \u2022 f) a = f (mk.symm c \u2022 a)", "start": [233, 1], "end": [234, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_addMonoidHom_apply", "code": "@[simp]\ntheorem mk_smul_addMonoidHom_apply (c : M) (f : A \u2192+ B) (a : A) : (mk c \u2022 f) a = f (c \u2022 a)", "start": [236, 1], "end": [237, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Projective.lean", "imports": ["Mathlib/Data/Finsupp/Basic.lean", "Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "Mathlib/CategoryTheory/Preadditive/Projective.lean", "Mathlib/Algebra/Module/Projective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/EpiMono.lean"], "premises": [{"full_name": "IsProjective.iff_projective", "code": "theorem IsProjective.iff_projective {R : Type u} [Ring R] {P : Type max u v} [AddCommGroup P]\n    [Module R P] : Module.Projective R P \u2194 Projective (ModuleCat.of R P)", "start": [32, 1], "end": [43, 82], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.projective_of_free", "code": "theorem projective_of_free {\u03b9 : Type u'} (b : Basis \u03b9 R M) : Projective M", "start": [51, 1], "end": [54, 74], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.moduleCat_enoughProjectives", "code": "instance moduleCat_enoughProjectives : EnoughProjectives (ModuleCat.{max u v} R) where\n  presentation M :=\n    \u27e8{  p := ModuleCat.of R (M \u2192\u2080 R)\n        projective :=\n          projective_of_free.{v,u} (\u03b9 := M) (M := ModuleCat.of R (M \u2192\u2080 R)) <|\n            Finsupp.basisSingleOne\n        f := Finsupp.basisSingleOne.constr \u2115 _root_.id\n        epi := (epi_iff_range_eq_top _).mpr\n            (range_eq_top.2 fun m => \u27e8Finsupp.single m (1 : R), by\n              dsimp [Basis.constr]\n              simp only [Finsupp.lmapDomain_id, comp_id]\n              erw [Finsupp.total_single]\n              rw [one_smul]\n              rfl \u27e9) }\u27e9", "start": [58, 1], "end": [75, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/ExtraDegeneracy.lean", "imports": ["Mathlib/AlgebraicTopology/SimplicialSet.lean", "Mathlib/Algebra/Homology/Homotopy.lean", "Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/AlgebraicTopology/CechNerve.lean"], "premises": [{"full_name": "SimplicialObject.Augmented.ExtraDegeneracy", "code": "@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X \u27f6 drop.obj X _[0]\n  s : \u2200 n : \u2115, drop.obj X _[n] \u27f6 drop.obj X _[n + 1]\n  s'_comp_\u03b5 : s' \u226b X.hom.app (op [0]) = \ud835\udfd9 _\n  s\u2080_comp_\u03b4\u2081 : s 0 \u226b X.left.\u03b4 1 = X.hom.app (op [0]) \u226b s'\n  s_comp_\u03b4\u2080 : \u2200 n : \u2115, s n \u226b X.left.\u03b4 0 = \ud835\udfd9 _\n  s_comp_\u03b4 :\n    \u2200 (n : \u2115) (i : Fin (n + 2)), s (n + 1) \u226b X.left.\u03b4 i.succ = X.left.\u03b4 i \u226b s n\n  s_comp_\u03c3 :\n    \u2200 (n : \u2115) (i : Fin (n + 1)), s n \u226b X.left.\u03c3 i.succ = X.left.\u03c3 i \u226b s (n + 1)", "start": [58, 1], "end": [71, 80], "kind": "commanddeclaration"}, {"full_name": "SimplicialObject.Augmented.ExtraDegeneracy.map", "code": "def map {D : Type*} [Category D] {X : SimplicialObject.Augmented C} (ed : ExtraDegeneracy X)\n    (F : C \u2964 D) : ExtraDegeneracy (((whiskering _ _).obj F).obj X) where\n  s' := F.map ed.s'\n  s n := F.map (ed.s n)\n  s'_comp_\u03b5 := by\n    dsimp\n    erw [comp_id, \u2190 F.map_comp, ed.s'_comp_\u03b5, F.map_id]\n  s\u2080_comp_\u03b4\u2081 := by\n    dsimp\n    erw [comp_id, \u2190 F.map_comp, \u2190 F.map_comp, ed.s\u2080_comp_\u03b4\u2081]\n  s_comp_\u03b4\u2080 n := by\n    dsimp\n    erw [\u2190 F.map_comp, ed.s_comp_\u03b4\u2080, F.map_id]\n  s_comp_\u03b4 n i := by\n    dsimp\n    erw [\u2190 F.map_comp, \u2190 F.map_comp, ed.s_comp_\u03b4]\n    rfl\n  s_comp_\u03c3 n i := by\n    dsimp\n    erw [\u2190 F.map_comp, \u2190 F.map_comp, ed.s_comp_\u03c3]\n    rfl", "start": [79, 1], "end": [102, 8], "kind": "commanddeclaration"}, {"full_name": "SimplicialObject.Augmented.ExtraDegeneracy.ofIso", "code": "def ofIso {X Y : SimplicialObject.Augmented C} (e : X \u2245 Y) (ed : ExtraDegeneracy X) :\n    ExtraDegeneracy Y where\n  s' := (point.mapIso e).inv \u226b ed.s' \u226b (drop.mapIso e).hom.app (op [0])\n  s n := (drop.mapIso e).inv.app (op [n]) \u226b ed.s n \u226b (drop.mapIso e).hom.app (op [n + 1])\n  s'_comp_\u03b5 := by\n    simpa only [Functor.mapIso, assoc, w\u2080, ed.s'_comp_\u03b5_assoc] using (point.mapIso e).inv_hom_id\n  s\u2080_comp_\u03b4\u2081 := by\n    have h := w\u2080 e.inv\n    dsimp at h \u22a2\n    simp only [assoc, \u2190 SimplicialObject.\u03b4_naturality, ed.s\u2080_comp_\u03b4\u2081_assoc, reassoc_of% h]\n  s_comp_\u03b4\u2080 n := by\n    have h := ed.s_comp_\u03b4\u2080\n    dsimp at h \u22a2\n    simpa only [assoc, \u2190 SimplicialObject.\u03b4_naturality, reassoc_of% h] using\n      congr_app (drop.mapIso e).inv_hom_id (op [n])\n  s_comp_\u03b4 n i := by\n    have h := ed.s_comp_\u03b4 n i\n    dsimp at h \u22a2\n    simp only [assoc, \u2190 SimplicialObject.\u03b4_naturality, reassoc_of% h,\n      \u2190 SimplicialObject.\u03b4_naturality_assoc]\n  s_comp_\u03c3 n i := by\n    have h := ed.s_comp_\u03c3 n i\n    dsimp at h \u22a2\n    simp only [assoc, \u2190 SimplicialObject.\u03c3_naturality, reassoc_of% h,\n      \u2190 SimplicialObject.\u03c3_naturality_assoc]", "start": [105, 1], "end": [131, 45], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.shiftFun", "code": "def shiftFun {n : \u2115} {X : Type*} [Zero X] (f : Fin n \u2192 X) (i : Fin (n + 1)) : X :=\n  dite (i = 0) (fun _ => 0) fun h => f (i.pred h)", "start": [146, 1], "end": [149, 50], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.shiftFun_0", "code": "@[simp]\ntheorem shiftFun_0 {n : \u2115} {X : Type*} [Zero X] (f : Fin n \u2192 X) : shiftFun f 0 = 0", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.shiftFun_succ", "code": "@[simp]\ntheorem shiftFun_succ {n : \u2115} {X : Type*} [Zero X] (f : Fin n \u2192 X) (i : Fin n) :\n    shiftFun f i.succ = f i", "start": [159, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.shift", "code": "@[simp]\ndef shift {n : \u2115} {\u0394 : SimplexCategory}\n    (f : ([n] : SimplexCategory) \u27f6 \u0394) : ([n + 1] : SimplexCategory) \u27f6 \u0394 :=\n  SimplexCategory.Hom.mk\n    { toFun := shiftFun f.toOrderHom\n      monotone' := fun i\u2081 i\u2082 hi => by\n        by_cases h\u2081 : i\u2081 = 0\n        \u00b7 subst h\u2081\n          simp only [shiftFun_0, Fin.zero_le]\n        \u00b7 have h\u2082 : i\u2082 \u2260 0 := by\n            intro h\u2082\n            subst h\u2082\n            exact h\u2081 (le_antisymm hi (Fin.zero_le _))\n          cases' Fin.eq_succ_of_ne_zero h\u2081 with j\u2081 hj\u2081\n          cases' Fin.eq_succ_of_ne_zero h\u2082 with j\u2082 hj\u2082\n          substs hj\u2081 hj\u2082\n          simpa only [shiftFun_succ] using f.toOrderHom.monotone (Fin.succ_le_succ_iff.mp hi) }", "start": [170, 1], "end": [188, 96], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.extraDegeneracy", "code": "protected noncomputable def extraDegeneracy (\u0394 : SimplexCategory) :\n    SimplicialObject.Augmented.ExtraDegeneracy (standardSimplex.obj \u0394) where\n  s' _ := SimplexCategory.Hom.mk (OrderHom.const _ 0)\n  s n f := shift f\n  s'_comp_\u03b5 := by\n    dsimp\n    apply Subsingleton.elim\n  s\u2080_comp_\u03b4\u2081 := by\n    ext1 x\n    apply SimplexCategory.Hom.ext\n    ext j\n    fin_cases j\n    rfl\n  s_comp_\u03b4\u2080 n := by\n    ext1 \u03c6\n    apply SimplexCategory.Hom.ext\n    ext i : 2\n    dsimp [SimplicialObject.\u03b4, SimplexCategory.\u03b4, SSet.standardSimplex]\n    simp only [shiftFun_succ]\n  s_comp_\u03b4 n i := by\n    ext1 \u03c6\n    apply SimplexCategory.Hom.ext\n    ext j : 2\n    dsimp [SimplicialObject.\u03b4, SimplexCategory.\u03b4, SSet.standardSimplex]\n    by_cases j = 0\n    \u00b7 subst h\n      simp only [Fin.succ_succAbove_zero, shiftFun_0]\n    \u00b7 obtain \u27e8_, rfl\u27e9 := Fin.eq_succ_of_ne_zero <| h\n      simp only [Fin.succ_succAbove_succ, shiftFun_succ, Function.comp_apply,\n        Fin.succAboveEmb_apply]\n  s_comp_\u03c3 n i := by\n    ext1 \u03c6\n    apply SimplexCategory.Hom.ext\n    ext j : 2\n    dsimp [SimplicialObject.\u03c3, SimplexCategory.\u03c3, SSet.standardSimplex]\n    by_cases j = 0\n    \u00b7 subst h\n      simp only [shiftFun_0]\n      exact shiftFun_0 \u03c6.toOrderHom\n    \u00b7 obtain \u27e8_, rfl\u27e9 := Fin.eq_succ_of_ne_zero h\n      simp only [Fin.succ_predAbove_succ, shiftFun_succ, Function.comp_apply]", "start": [192, 1], "end": [233, 78], "kind": "commanddeclaration"}, {"full_name": "SSet.Augmented.StandardSimplex.nonempty_extraDegeneracy_standardSimplex", "code": "instance nonempty_extraDegeneracy_standardSimplex (\u0394 : SimplexCategory) :\n    Nonempty (SimplicialObject.Augmented.ExtraDegeneracy (standardSimplex.obj \u0394)) :=\n  \u27e8StandardSimplex.extraDegeneracy \u0394\u27e9", "start": [237, 1], "end": [239, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s", "code": "noncomputable def ExtraDegeneracy.s (n : \u2115) :\n    f.cechNerve.obj (op [n]) \u27f6 f.cechNerve.obj (op [n + 1]) :=\n  WidePullback.lift (WidePullback.base _)\n    (fun i =>\n      dite (i = 0)\n        (fun _ => WidePullback.base _ \u226b S.section_)\n        (fun h => WidePullback.\u03c0 _ (i.pred h)))\n    fun i => by\n      dsimp\n      split_ifs with h\n      \u00b7 subst h\n        simp only [assoc, SplitEpi.id, comp_id]\n      \u00b7 simp only [WidePullback.\u03c0_arrow]", "start": [261, 1], "end": [276, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_\u03c0_0", "code": "theorem ExtraDegeneracy.s_comp_\u03c0_0 (n : \u2115) :\n    ExtraDegeneracy.s f S n \u226b WidePullback.\u03c0 _ 0 =\n      @WidePullback.base _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ \u226b\n        S.section_", "start": [280, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_\u03c0_succ", "code": "theorem ExtraDegeneracy.s_comp_\u03c0_succ (n : \u2115) (i : Fin (n + 1)) :\n    ExtraDegeneracy.s f S n \u226b WidePullback.\u03c0 _ i.succ =\n      @WidePullback.\u03c0 _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ i", "start": [289, 1], "end": [296, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_base", "code": "theorem ExtraDegeneracy.s_comp_base (n : \u2115) :\n    ExtraDegeneracy.s f S n \u226b WidePullback.base _ = WidePullback.base _", "start": [300, 1], "end": [302, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Arrow.AugmentedCechNerve.extraDegeneracy", "code": "noncomputable def extraDegeneracy : SimplicialObject.Augmented.ExtraDegeneracy f.augmentedCechNerve\n    where\n  s' := S.section_ \u226b WidePullback.lift f.hom (fun _ => \ud835\udfd9 _) fun i => by rw [id_comp]\n  s n := ExtraDegeneracy.s f S n\n  s'_comp_\u03b5 := by\n    dsimp\n    simp only [augmentedCechNerve_hom_app, assoc, WidePullback.lift_base, SplitEpi.id]\n  s\u2080_comp_\u03b4\u2081 := by\n    dsimp [cechNerve, SimplicialObject.\u03b4, SimplexCategory.\u03b4]\n    ext j\n    \u00b7 fin_cases j\n      simpa only [assoc, WidePullback.lift_\u03c0, comp_id] using ExtraDegeneracy.s_comp_\u03c0_0 f S 0\n    \u00b7 simpa only [assoc, WidePullback.lift_base, SplitEpi.id, comp_id] using\n        ExtraDegeneracy.s_comp_base f S 0\n  s_comp_\u03b4\u2080 n := by\n    dsimp [cechNerve, SimplicialObject.\u03b4, SimplexCategory.\u03b4]\n    ext j\n    \u00b7 simpa only [assoc, WidePullback.lift_\u03c0, id_comp] using ExtraDegeneracy.s_comp_\u03c0_succ f S n j\n    \u00b7 simpa only [assoc, WidePullback.lift_base, id_comp] using ExtraDegeneracy.s_comp_base f S n\n  s_comp_\u03b4 n i := by\n    dsimp [cechNerve, SimplicialObject.\u03b4, SimplexCategory.\u03b4]\n    ext j\n    \u00b7 simp only [assoc, WidePullback.lift_\u03c0]\n      by_cases j = 0\n      \u00b7 subst h\n        erw [Fin.succ_succAbove_zero, ExtraDegeneracy.s_comp_\u03c0_0, ExtraDegeneracy.s_comp_\u03c0_0]\n        dsimp\n        simp only [WidePullback.lift_base_assoc]\n      \u00b7 cases' Fin.eq_succ_of_ne_zero h with k hk\n        subst hk\n        erw [Fin.succ_succAbove_succ, ExtraDegeneracy.s_comp_\u03c0_succ,\n          ExtraDegeneracy.s_comp_\u03c0_succ]\n        simp only [WidePullback.lift_\u03c0]\n    \u00b7 simp only [assoc, WidePullback.lift_base]\n      erw [ExtraDegeneracy.s_comp_base, ExtraDegeneracy.s_comp_base]\n      dsimp\n      simp only [WidePullback.lift_base]\n  s_comp_\u03c3 n i := by\n    dsimp [cechNerve, SimplicialObject.\u03c3, SimplexCategory.\u03c3]\n    ext j\n    \u00b7 simp only [assoc, WidePullback.lift_\u03c0]\n      by_cases j = 0\n      \u00b7 subst h\n        erw [ExtraDegeneracy.s_comp_\u03c0_0, ExtraDegeneracy.s_comp_\u03c0_0]\n        dsimp\n        simp only [WidePullback.lift_base_assoc]\n      \u00b7 cases' Fin.eq_succ_of_ne_zero h with k hk\n        subst hk\n        erw [Fin.succ_predAbove_succ, ExtraDegeneracy.s_comp_\u03c0_succ,\n          ExtraDegeneracy.s_comp_\u03c0_succ]\n        simp only [WidePullback.lift_\u03c0]\n    \u00b7 simp only [assoc, WidePullback.lift_base]\n      erw [ExtraDegeneracy.s_comp_base, ExtraDegeneracy.s_comp_base]\n      dsimp\n      simp only [WidePullback.lift_base]", "start": [305, 1], "end": [360, 41], "kind": "commanddeclaration"}, {"full_name": "SimplicialObject.Augmented.ExtraDegeneracy.homotopyEquiv", "code": "noncomputable def homotopyEquiv {C : Type*} [Category C] [Preadditive C] [HasZeroObject C]\n    {X : SimplicialObject.Augmented C} (ed : ExtraDegeneracy X) :\n    HomotopyEquiv (AlgebraicTopology.AlternatingFaceMapComplex.obj (drop.obj X))\n      ((ChainComplex.single\u2080 C).obj (point.obj X)) where\n  hom := AlternatingFaceMapComplex.\u03b5.app X\n  inv := (ChainComplex.fromSingle\u2080Equiv _ _).invFun ed.s'\n  homotopyInvHomId := Homotopy.ofEq (ChainComplex.to_single\u2080_ext _ _ (ed.s'_comp_\u03b5))\n  homotopyHomInvId :=\n    { hom := fun i j => by\n        by_cases i + 1 = j\n        \u00b7 exact (-ed.s i) \u226b eqToHom (by congr)\n        \u00b7 exact 0\n      zero := fun i j hij => by\n        dsimp\n        split_ifs with h\n        \u00b7 exfalso\n          exact hij h\n        \u00b7 simp only [eq_self_iff_true]\n      comm := fun i => by\n        rcases i with _|i\n        \u00b7 rw [Homotopy.prevD_chainComplex, Homotopy.dNext_zero_chainComplex, zero_add]\n          dsimp [ChainComplex.fromSingle\u2080Equiv, ChainComplex.toSingle\u2080Equiv]\n          simp only [comp_id, ite_true, zero_add, ComplexShape.down_Rel, not_true,\n            AlternatingFaceMapComplex.obj_d_eq, Preadditive.neg_comp]\n          erw [Fin.sum_univ_two]\n          simp only [Fin.val_zero, pow_zero, one_smul, Fin.val_one, pow_one, neg_smul,\n            Preadditive.comp_add, s_comp_\u03b4\u2080, drop_obj, Preadditive.comp_neg, neg_add_rev,\n            neg_neg, neg_add_cancel_right, s\u2080_comp_\u03b4\u2081]\n          rfl\n        \u00b7 rw [Homotopy.prevD_chainComplex, Homotopy.dNext_succ_chainComplex]\n          dsimp [ChainComplex.toSingle\u2080Equiv, ChainComplex.fromSingle\u2080Equiv]\n          simp only [comp_zero, ComplexShape.down_Rel, not_true, Preadditive.neg_comp,\n            AlternatingFaceMapComplex.obj_d_eq, comp_id, ite_true, Preadditive.comp_neg,\n            @Fin.sum_univ_succ _ _ (i + 2), Fin.val_zero, pow_zero, one_smul, Fin.val_succ,\n            Preadditive.comp_add, drop_obj, s_comp_\u03b4\u2080, Preadditive.sum_comp,\n            Preadditive.zsmul_comp, Preadditive.comp_sum, Preadditive.comp_zsmul,\n            zsmul_neg, ed.s_comp_\u03b4, pow_add, pow_one, mul_neg, mul_one, neg_zsmul, neg_neg,\n            neg_add_cancel_comm_assoc, add_left_neg] }", "start": [377, 1], "end": [417, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Abelian/Ext.lean", "imports": ["Mathlib/CategoryTheory/Functor/LeftDerived.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/CategoryTheory/Linear/Yoneda.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Abelian/Opposite.lean", "Mathlib/CategoryTheory/Abelian/Projective.lean"], "premises": [{"full_name": "Ext", "code": "def Ext (n : \u2115) : C\u1d52\u1d56 \u2964 C \u2964 ModuleCat R :=\n  Functor.flip\n    { obj := fun Y => (((linearYoneda R C).obj Y).rightOp.leftDerived n).leftOp\n      map := fun f =>\n        NatTrans.leftOp (NatTrans.leftDerived (NatTrans.rightOp ((linearYoneda R C).map f)) n) }", "start": [38, 1], "end": [59, 97], "kind": "commanddeclaration"}, {"full_name": "extSuccOfProjective", "code": "def extSuccOfProjective (X Y : C) [Projective X] (n : \u2115) :\n    ((Ext R C (n + 1)).obj (Opposite.op X)).obj Y \u2245 0 :=\n  let E := (((linearYoneda R C).obj Y).rightOp.leftDerivedObjProjectiveSucc n X).unop.symm\n  E \u226a\u226b\n    { hom := 0\n      inv := 0\n      hom_inv_id := by\n        let Z : (ModuleCat R)\u1d52\u1d56 := 0\n        rw [\u2190 (0 : 0 \u27f6 Z.unop).unop_op, \u2190 (0 : Z.unop \u27f6 0).unop_op, \u2190 unop_id, \u2190 unop_comp]\n        aesop }", "start": [65, 1], "end": [75, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/FdRep.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Schur.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RepresentationTheory/Basic.lean", "Mathlib/RepresentationTheory/Rep.lean", "Mathlib/Algebra/Category/FGModuleCat/Limits.lean"], "premises": [{"full_name": "FdRep", "code": "abbrev FdRep (k G : Type u) [Field k] [Monoid G] :=\n  Action (FGModuleCat.{u} k) (MonCat.of G)", "start": [47, 1], "end": [49, 43], "kind": "commanddeclaration"}, {"full_name": "FdRep.\u03c1", "code": "def \u03c1 (V : FdRep k G) : G \u2192* V \u2192\u2097[k] V :=\n  Action.\u03c1 V", "start": [81, 1], "end": [83, 13], "kind": "commanddeclaration"}, {"full_name": "FdRep.isoToLinearEquiv", "code": "def isoToLinearEquiv {V W : FdRep k G} (i : V \u2245 W) : V \u2243\u2097[k] W :=\n  FGModuleCat.isoToLinearEquiv ((Action.forget (FGModuleCat k) (MonCat.of G)).mapIso i)", "start": [86, 1], "end": [88, 88], "kind": "commanddeclaration"}, {"full_name": "FdRep.Iso.conj_\u03c1", "code": "theorem Iso.conj_\u03c1 {V W : FdRep k G} (i : V \u2245 W) (g : G) :\n    W.\u03c1 g = (FdRep.isoToLinearEquiv i).conj (V.\u03c1 g)", "start": [91, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "FdRep.of", "code": "@[simps \u03c1]\ndef of {V : Type u} [AddCommGroup V] [Module k V] [FiniteDimensional k V]\n    (\u03c1 : Representation k G V) : FdRep k G :=\n  \u27e8FGModuleCat.of k V, \u03c1\u27e9", "start": [99, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "FdRep.forget\u2082_\u03c1", "code": "theorem forget\u2082_\u03c1 (V : FdRep k G) : ((forget\u2082 (FdRep k G) (Rep k G)).obj V).\u03c1 = V.\u03c1", "start": [109, 1], "end": [110, 15], "kind": "commanddeclaration"}, {"full_name": "FdRep.finrank_hom_simple_simple", "code": "theorem finrank_hom_simple_simple [IsAlgClosed k] (V W : FdRep k G) [Simple V] [Simple W] :\n    finrank k (V \u27f6 W) = if Nonempty (V \u2245 W) then 1 else 0", "start": [129, 1], "end": [131, 49], "kind": "commanddeclaration"}, {"full_name": "FdRep.forget\u2082HomLinearEquiv", "code": "def forget\u2082HomLinearEquiv (X Y : FdRep k G) :\n    ((forget\u2082 (FdRep k G) (Rep k G)).obj X \u27f6 (forget\u2082 (FdRep k G) (Rep k G)).obj Y) \u2243\u2097[k] X \u27f6 Y\n    where\n  toFun f := \u27e8f.hom, f.comm\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := \u27e8(forget\u2082 (FGModuleCat k) (ModuleCat k)).map f.hom, f.comm\u27e9\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl", "start": [134, 1], "end": [143, 29], "kind": "commanddeclaration"}, {"full_name": "FdRep.dualTensorIsoLinHomAux", "code": "noncomputable def dualTensorIsoLinHomAux :\n    (FdRep.of \u03c1V.dual \u2297 W).V \u2245 (FdRep.of (linHom \u03c1V W.\u03c1)).V :=\n  @LinearEquiv.toFGModuleCatIso k _ (FdRep.of \u03c1V.dual \u2297 W).V (V \u2192\u2097[k] W)\n    _ _ _ _ _ _ (dualTensorHomEquiv k V W)", "start": [174, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "FdRep.dualTensorIsoLinHom", "code": "noncomputable def dualTensorIsoLinHom : FdRep.of \u03c1V.dual \u2297 W \u2245 FdRep.of (linHom \u03c1V W.\u03c1) := by\n  refine Action.mkIso (dualTensorIsoLinHomAux \u03c1V W) ?_\n  convert dualTensorHom_comm \u03c1V W.\u03c1", "start": [182, 1], "end": [186, 36], "kind": "commanddeclaration"}, {"full_name": "FdRep.dualTensorIsoLinHom_hom_hom", "code": "@[simp]\ntheorem dualTensorIsoLinHom_hom_hom : (dualTensorIsoLinHom \u03c1V W).hom.hom = dualTensorHom k V W", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/RelIso/Group.lean", "imports": ["Mathlib/Order/RelIso/Basic.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RelIso.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : r \u2243r r) : \u03b1 \u2192 \u03b1) = id", "start": [29, 1], "end": [31, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_mul", "code": "@[simp]\ntheorem coe_mul (e\u2081 e\u2082 : r \u2243r r) : ((e\u2081 * e\u2082) : \u03b1 \u2192 \u03b1) = e\u2081 \u2218 e\u2082", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.mul_apply", "code": "theorem mul_apply (e\u2081 e\u2082 : r \u2243r r) (x : \u03b1) : (e\u2081 * e\u2082) x = e\u2081 (e\u2082 x)", "start": [39, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.inv_apply_self", "code": "@[simp]\ntheorem inv_apply_self (e : r \u2243r r) (x) : e\u207b\u00b9 (e x) = x", "start": [43, 1], "end": [45, 23], "kind": "commanddeclaration"}, {"full_name": "RelIso.apply_inv_self", "code": "@[simp]\ntheorem apply_inv_self (e : r \u2243r r) (x) : e (e\u207b\u00b9 x) = x", "start": [48, 1], "end": [50, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/OrdContinuous.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Order/RelIso/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LeftOrdContinuous", "code": "def LeftOrdContinuous [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 \u2983s : Set \u03b1\u2984 \u2983x\u2984, IsLUB s x \u2192 IsLUB (f '' s) (f x)", "start": [35, 1], "end": [39, 54], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous", "code": "def RightOrdContinuous [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 \u2983s : Set \u03b1\u2984 \u2983x\u2984, IsGLB s x \u2192 IsGLB (f '' s) (f x)", "start": [42, 1], "end": [46, 54], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.id", "code": "protected theorem id : LeftOrdContinuous (id : \u03b1 \u2192 \u03b1)", "start": [55, 1], "end": [56, 32], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.order_dual", "code": "protected theorem order_dual : LeftOrdContinuous f \u2192 RightOrdContinuous (toDual \u2218 f \u2218 ofDual)", "start": [62, 1], "end": [63, 5], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_isGreatest", "code": "theorem map_isGreatest (hf : LeftOrdContinuous f) {s : Set \u03b1} {x : \u03b1} (h : IsGreatest s x) :\n    IsGreatest (f '' s) (f x)", "start": [66, 1], "end": [68, 43], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.mono", "code": "theorem mono (hf : LeftOrdContinuous f) : Monotone f", "start": [71, 1], "end": [73, 64], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.comp", "code": "theorem comp (hg : LeftOrdContinuous g) (hf : LeftOrdContinuous f) : LeftOrdContinuous (g \u2218 f)", "start": [76, 1], "end": [77, 59], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : LeftOrdContinuous f) (n : \u2115) :\n    LeftOrdContinuous f^[n]", "start": [81, 1], "end": [85, 34], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_sup", "code": "theorem map_sup (hf : LeftOrdContinuous f) (x y : \u03b1) : f (x \u2294 y) = f x \u2294 f y", "start": [94, 1], "end": [95, 66], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.le_iff", "code": "theorem le_iff (hf : LeftOrdContinuous f) (h : Injective f) {x y} : f x \u2264 f y \u2194 x \u2264 y", "start": [98, 1], "end": [99, 53], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.lt_iff", "code": "theorem lt_iff (hf : LeftOrdContinuous f) (h : Injective f) {x y} : f x < f y \u2194 x < y", "start": [102, 1], "end": [103, 44], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.toOrderEmbedding", "code": "def toOrderEmbedding (hf : LeftOrdContinuous f) (h : Injective f) : \u03b1 \u21aao \u03b2 :=\n  \u27e8\u27e8f, h\u27e9, hf.le_iff h\u27e9", "start": [108, 1], "end": [110, 24], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.coe_toOrderEmbedding", "code": "@[simp]\ntheorem coe_toOrderEmbedding (hf : LeftOrdContinuous f) (h : Injective f) :\n    \u21d1(hf.toOrderEmbedding f h) = f", "start": [115, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_sSup'", "code": "theorem map_sSup' (hf : LeftOrdContinuous f) (s : Set \u03b1) : f (sSup s) = sSup (f '' s)", "start": [127, 1], "end": [128, 36], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_sSup", "code": "theorem map_sSup (hf : LeftOrdContinuous f) (s : Set \u03b1) : f (sSup s) = \u2a06 x \u2208 s, f x", "start": [131, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_iSup", "code": "theorem map_iSup (hf : LeftOrdContinuous f) (g : \u03b9 \u2192 \u03b1) : f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_csSup", "code": "theorem map_csSup (hf : LeftOrdContinuous f) {s : Set \u03b1} (sne : s.Nonempty) (sbdd : BddAbove s) :\n    f (sSup s) = sSup (f '' s)", "start": [146, 1], "end": [148, 62], "kind": "commanddeclaration"}, {"full_name": "LeftOrdContinuous.map_ciSup", "code": "theorem map_ciSup (hf : LeftOrdContinuous f) {g : \u03b9 \u2192 \u03b1} (hg : BddAbove (range g)) :\n    f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.id", "code": "protected theorem id : RightOrdContinuous (id : \u03b1 \u2192 \u03b1)", "start": [167, 1], "end": [168, 32], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.orderDual", "code": "protected theorem orderDual : RightOrdContinuous f \u2192 LeftOrdContinuous (toDual \u2218 f \u2218 ofDual)", "start": [173, 1], "end": [174, 5], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_isLeast", "code": "theorem map_isLeast (hf : RightOrdContinuous f) {s : Set \u03b1} {x : \u03b1} (h : IsLeast s x) :\n    IsLeast (f '' s) (f x)", "start": [177, 1], "end": [179, 32], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.mono", "code": "theorem mono (hf : RightOrdContinuous f) : Monotone f", "start": [182, 1], "end": [183, 25], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.comp", "code": "theorem comp (hg : RightOrdContinuous g) (hf : RightOrdContinuous f) : RightOrdContinuous (g \u2218 f)", "start": [186, 1], "end": [187, 33], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : RightOrdContinuous f) (n : \u2115) :\n    RightOrdContinuous f^[n]", "start": [190, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_inf", "code": "theorem map_inf (hf : RightOrdContinuous f) (x y : \u03b1) : f (x \u2293 y) = f x \u2293 f y", "start": [201, 1], "end": [202, 27], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.le_iff", "code": "theorem le_iff (hf : RightOrdContinuous f) (h : Injective f) {x y} : f x \u2264 f y \u2194 x \u2264 y", "start": [205, 1], "end": [206, 24], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.lt_iff", "code": "theorem lt_iff (hf : RightOrdContinuous f) (h : Injective f) {x y} : f x < f y \u2194 x < y", "start": [209, 1], "end": [210, 24], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.toOrderEmbedding", "code": "def toOrderEmbedding (hf : RightOrdContinuous f) (h : Injective f) : \u03b1 \u21aao \u03b2 :=\n  \u27e8\u27e8f, h\u27e9, hf.le_iff h\u27e9", "start": [215, 1], "end": [217, 24], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.coe_toOrderEmbedding", "code": "@[simp]\ntheorem coe_toOrderEmbedding (hf : RightOrdContinuous f) (h : Injective f) :\n    \u21d1(hf.toOrderEmbedding f h) = f", "start": [222, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_sInf'", "code": "theorem map_sInf' (hf : RightOrdContinuous f) (s : Set \u03b1) : f (sInf s) = sInf (f '' s)", "start": [234, 1], "end": [235, 27], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_sInf", "code": "theorem map_sInf (hf : RightOrdContinuous f) (s : Set \u03b1) : f (sInf s) = \u2a05 x \u2208 s, f x", "start": [238, 1], "end": [239, 26], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_iInf", "code": "theorem map_iInf (hf : RightOrdContinuous f) (g : \u03b9 \u2192 \u03b1) : f (\u2a05 i, g i) = \u2a05 i, f (g i)", "start": [242, 1], "end": [243, 26], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_csInf", "code": "theorem map_csInf (hf : RightOrdContinuous f) {s : Set \u03b1} (sne : s.Nonempty) (sbdd : BddBelow s) :\n    f (sInf s) = sInf (f '' s)", "start": [252, 1], "end": [254, 34], "kind": "commanddeclaration"}, {"full_name": "RightOrdContinuous.map_ciInf", "code": "theorem map_ciInf (hf : RightOrdContinuous f) {g : \u03b9 \u2192 \u03b1} (hg : BddBelow (range g)) :\n    f (\u2a05 i, g i) = \u2a05 i, f (g i)", "start": [257, 1], "end": [259, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.leftOrdContinuous", "code": "protected theorem leftOrdContinuous : LeftOrdContinuous e", "start": [272, 1], "end": [275, 91], "kind": "commanddeclaration"}, {"full_name": "OrderIso.rightOrdContinuous", "code": "protected theorem rightOrdContinuous : RightOrdContinuous e", "start": [278, 1], "end": [279, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Sigma.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/List/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.keys", "code": "def keys : List (Sigma \u03b2) \u2192 List \u03b1 :=\n  map Sigma.fst", "start": [41, 1], "end": [43, 16], "kind": "commanddeclaration"}, {"full_name": "List.keys_nil", "code": "@[simp]\ntheorem keys_nil : @keys \u03b1 \u03b2 [] = []", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "List.keys_cons", "code": "@[simp]\ntheorem keys_cons {s} {l : List (Sigma \u03b2)} : (s :: l).keys = s.1 :: l.keys", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys_of_mem", "code": "theorem mem_keys_of_mem {s : Sigma \u03b2} {l : List (Sigma \u03b2)} : s \u2208 l \u2192 s.1 \u2208 l.keys", "start": [56, 1], "end": [57, 27], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_mem_keys", "code": "theorem exists_of_mem_keys {a} {l : List (Sigma \u03b2)} (h : a \u2208 l.keys) :\n    \u2203 b : \u03b2 a, Sigma.mk a b \u2208 l", "start": [60, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys", "code": "theorem mem_keys {a} {l : List (Sigma \u03b2)} : a \u2208 l.keys \u2194 \u2203 b : \u03b2 a, Sigma.mk a b \u2208 l", "start": [66, 1], "end": [67, 56], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_keys", "code": "theorem not_mem_keys {a} {l : List (Sigma \u03b2)} : a \u2209 l.keys \u2194 \u2200 b : \u03b2 a, Sigma.mk a b \u2209 l", "start": [70, 1], "end": [71, 40], "kind": "commanddeclaration"}, {"full_name": "List.not_eq_key", "code": "theorem not_eq_key {a} {l : List (Sigma \u03b2)} : a \u2209 l.keys \u2194 \u2200 s : Sigma \u03b2, s \u2208 l \u2192 a \u2260 s.1", "start": [74, 1], "end": [77, 15], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys", "code": "def NodupKeys (l : List (Sigma \u03b2)) : Prop :=\n  l.keys.Nodup", "start": [83, 1], "end": [85, 15], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_iff_pairwise", "code": "theorem nodupKeys_iff_pairwise {l} : NodupKeys l \u2194 Pairwise (fun s s' : Sigma \u03b2 => s.1 \u2260 s'.1) l", "start": [88, 1], "end": [89, 15], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.pairwise_ne", "code": "theorem NodupKeys.pairwise_ne {l} (h : NodupKeys l) :\n    Pairwise (fun s s' : Sigma \u03b2 => s.1 \u2260 s'.1) l", "start": [92, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_nil", "code": "@[simp]\ntheorem nodupKeys_nil : @NodupKeys \u03b1 \u03b2 []", "start": [97, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_cons", "code": "@[simp]\ntheorem nodupKeys_cons {s : Sigma \u03b2} {l : List (Sigma \u03b2)} :\n    NodupKeys (s :: l) \u2194 s.1 \u2209 l.keys \u2227 NodupKeys l", "start": [102, 1], "end": [104, 81], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_keys_of_nodupKeys_cons", "code": "theorem not_mem_keys_of_nodupKeys_cons {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : NodupKeys (s :: l)) :\n    s.1 \u2209 l.keys", "start": [107, 1], "end": [109, 25], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_of_nodupKeys_cons", "code": "theorem nodupKeys_of_nodupKeys_cons {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : NodupKeys (s :: l)) :\n    NodupKeys l", "start": [112, 1], "end": [114, 25], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.eq_of_fst_eq", "code": "theorem NodupKeys.eq_of_fst_eq {l : List (Sigma \u03b2)} (nd : NodupKeys l) {s s' : Sigma \u03b2} (h : s \u2208 l)\n    (h' : s' \u2208 l) : s.1 = s'.1 \u2192 s = s'", "start": [117, 1], "end": [121, 73], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.eq_of_mk_mem", "code": "theorem NodupKeys.eq_of_mk_mem {a : \u03b1} {b b' : \u03b2 a} {l : List (Sigma \u03b2)} (nd : NodupKeys l)\n    (h : Sigma.mk a b \u2208 l) (h' : Sigma.mk a b' \u2208 l) : b = b'", "start": [124, 1], "end": [126, 38], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_singleton", "code": "theorem nodupKeys_singleton (s : Sigma \u03b2) : NodupKeys [s]", "start": [129, 1], "end": [130, 20], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.sublist", "code": "theorem NodupKeys.sublist {l\u2081 l\u2082 : List (Sigma \u03b2)} (h : l\u2081 <+ l\u2082) : NodupKeys l\u2082 \u2192 NodupKeys l\u2081", "start": [133, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.nodup", "code": "protected theorem NodupKeys.nodup {l : List (Sigma \u03b2)} : NodupKeys l \u2192 Nodup l", "start": [137, 1], "end": [138, 17], "kind": "commanddeclaration"}, {"full_name": "List.perm_nodupKeys", "code": "theorem perm_nodupKeys {l\u2081 l\u2082 : List (Sigma \u03b2)} (h : l\u2081 ~ l\u2082) : NodupKeys l\u2081 \u2194 NodupKeys l\u2082", "start": [141, 1], "end": [142, 22], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_join", "code": "theorem nodupKeys_join {L : List (List (Sigma \u03b2))} :\n    NodupKeys (join L) \u2194 (\u2200 l \u2208 L, NodupKeys l) \u2227 Pairwise Disjoint (L.map keys)", "start": [145, 1], "end": [150, 31], "kind": "commanddeclaration"}, {"full_name": "List.nodup_enum_map_fst", "code": "theorem nodup_enum_map_fst (l : List \u03b1) : (l.enum.map Prod.fst).Nodup", "start": [153, 1], "end": [153, 100], "kind": "commanddeclaration"}, {"full_name": "List.mem_ext", "code": "theorem mem_ext {l\u2080 l\u2081 : List (Sigma \u03b2)} (nd\u2080 : l\u2080.Nodup) (nd\u2081 : l\u2081.Nodup)\n    (h : \u2200 x, x \u2208 l\u2080 \u2194 x \u2208 l\u2081) : l\u2080 ~ l\u2081", "start": [156, 1], "end": [158, 25], "kind": "commanddeclaration"}, {"full_name": "List.dlookup", "code": "def dlookup (a : \u03b1) : List (Sigma \u03b2) \u2192 Option (\u03b2 a)\n  | [] => none\n  | \u27e8a', b\u27e9 :: l => if h : a' = a then some (Eq.recOn h b) else dlookup a l", "start": [167, 1], "end": [171, 76], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_nil", "code": "@[simp]\ntheorem dlookup_nil (a : \u03b1) : dlookup a [] = @none (\u03b2 a)", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_cons_eq", "code": "@[simp]\ntheorem dlookup_cons_eq (l) (a : \u03b1) (b : \u03b2 a) : dlookup a (\u27e8a, b\u27e9 :: l) = some b", "start": [179, 1], "end": [181, 14], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_cons_ne", "code": "@[simp]\ntheorem dlookup_cons_ne (l) {a} : \u2200 s : Sigma \u03b2, a \u2260 s.1 \u2192 dlookup a (s :: l) = dlookup a l", "start": [184, 1], "end": [186, 32], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_isSome", "code": "theorem dlookup_isSome {a : \u03b1} : \u2200 {l : List (Sigma \u03b2)}, (dlookup a l).isSome \u2194 a \u2208 l.keys", "start": [189, 1], "end": [195, 31], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_eq_none", "code": "theorem dlookup_eq_none {a : \u03b1} {l : List (Sigma \u03b2)} : dlookup a l = none \u2194 a \u2209 l.keys", "start": [198, 1], "end": [199, 53], "kind": "commanddeclaration"}, {"full_name": "List.of_mem_dlookup", "code": "theorem of_mem_dlookup {a : \u03b1} {b : \u03b2 a} :\n    \u2200 {l : List (Sigma \u03b2)}, b \u2208 dlookup a l \u2192 Sigma.mk a b \u2208 l", "start": [202, 1], "end": [210, 30], "kind": "commanddeclaration"}, {"full_name": "List.mem_dlookup", "code": "theorem mem_dlookup {a} {b : \u03b2 a} {l : List (Sigma \u03b2)} (nd : l.NodupKeys) (h : Sigma.mk a b \u2208 l) :\n    b \u2208 dlookup a l", "start": [213, 1], "end": [217, 11], "kind": "commanddeclaration"}, {"full_name": "List.map_dlookup_eq_find", "code": "theorem map_dlookup_eq_find (a : \u03b1) :\n    \u2200 l : List (Sigma \u03b2), (dlookup a l).map (Sigma.mk a) = find? (fun s => a = s.1) l", "start": [220, 1], "end": [228, 36], "kind": "commanddeclaration"}, {"full_name": "List.mem_dlookup_iff", "code": "theorem mem_dlookup_iff {a : \u03b1} {b : \u03b2 a} {l : List (Sigma \u03b2)} (nd : l.NodupKeys) :\n    b \u2208 dlookup a l \u2194 Sigma.mk a b \u2208 l", "start": [231, 1], "end": [233, 35], "kind": "commanddeclaration"}, {"full_name": "List.perm_dlookup", "code": "theorem perm_dlookup (a : \u03b1) {l\u2081 l\u2082 : List (Sigma \u03b2)} (nd\u2081 : l\u2081.NodupKeys) (nd\u2082 : l\u2082.NodupKeys)\n    (p : l\u2081 ~ l\u2082) : dlookup a l\u2081 = dlookup a l\u2082", "start": [236, 1], "end": [238, 79], "kind": "commanddeclaration"}, {"full_name": "List.lookup_ext", "code": "theorem lookup_ext {l\u2080 l\u2081 : List (Sigma \u03b2)} (nd\u2080 : l\u2080.NodupKeys) (nd\u2081 : l\u2081.NodupKeys)\n    (h : \u2200 x y, y \u2208 l\u2080.dlookup x \u2194 y \u2208 l\u2081.dlookup x) : l\u2080 ~ l\u2081", "start": [241, 1], "end": [244, 64], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll", "code": "def lookupAll (a : \u03b1) : List (Sigma \u03b2) \u2192 List (\u03b2 a)\n  | [] => []\n  | \u27e8a', b\u27e9 :: l => if h : a' = a then Eq.recOn h b :: lookupAll a l else lookupAll a l", "start": [250, 1], "end": [253, 88], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_nil", "code": "@[simp]\ntheorem lookupAll_nil (a : \u03b1) : lookupAll a [] = @nil (\u03b2 a)", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_cons_eq", "code": "@[simp]\ntheorem lookupAll_cons_eq (l) (a : \u03b1) (b : \u03b2 a) : lookupAll a (\u27e8a, b\u27e9 :: l) = b :: lookupAll a l", "start": [261, 1], "end": [263, 14], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_cons_ne", "code": "@[simp]\ntheorem lookupAll_cons_ne (l) {a} : \u2200 s : Sigma \u03b2, a \u2260 s.1 \u2192 lookupAll a (s :: l) = lookupAll a l", "start": [266, 1], "end": [268, 32], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_eq_nil", "code": "theorem lookupAll_eq_nil {a : \u03b1} :\n    \u2200 {l : List (Sigma \u03b2)}, lookupAll a l = [] \u2194 \u2200 b : \u03b2 a, Sigma.mk a b \u2209 l", "start": [271, 1], "end": [278, 33], "kind": "commanddeclaration"}, {"full_name": "List.head?_lookupAll", "code": "theorem head?_lookupAll (a : \u03b1) : \u2200 l : List (Sigma \u03b2), head? (lookupAll a l) = dlookup a l", "start": [281, 1], "end": [286, 82], "kind": "commanddeclaration"}, {"full_name": "List.mem_lookupAll", "code": "theorem mem_lookupAll {a : \u03b1} {b : \u03b2 a} :\n    \u2200 {l : List (Sigma \u03b2)}, b \u2208 lookupAll a l \u2194 Sigma.mk a b \u2208 l", "start": [289, 1], "end": [296, 30], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_sublist", "code": "theorem lookupAll_sublist (a : \u03b1) : \u2200 l : List (Sigma \u03b2), (lookupAll a l).map (Sigma.mk a) <+ l", "start": [299, 1], "end": [307, 43], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_length_le_one", "code": "theorem lookupAll_length_le_one (a : \u03b1) {l : List (Sigma \u03b2)} (h : l.NodupKeys) :\n    length (lookupAll a l) \u2264 1", "start": [310, 1], "end": [314, 39], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_eq_dlookup", "code": "theorem lookupAll_eq_dlookup (a : \u03b1) {l : List (Sigma \u03b2)} (h : l.NodupKeys) :\n    lookupAll a l = (dlookup a l).toList", "start": [317, 1], "end": [322, 28], "kind": "commanddeclaration"}, {"full_name": "List.lookupAll_nodup", "code": "theorem lookupAll_nodup (a : \u03b1) {l : List (Sigma \u03b2)} (h : l.NodupKeys) : (lookupAll a l).Nodup", "start": [325, 1], "end": [326, 64], "kind": "commanddeclaration"}, {"full_name": "List.perm_lookupAll", "code": "theorem perm_lookupAll (a : \u03b1) {l\u2081 l\u2082 : List (Sigma \u03b2)} (nd\u2081 : l\u2081.NodupKeys) (nd\u2082 : l\u2082.NodupKeys)\n    (p : l\u2081 ~ l\u2082) : lookupAll a l\u2081 = lookupAll a l\u2082", "start": [329, 1], "end": [331, 66], "kind": "commanddeclaration"}, {"full_name": "List.kreplace", "code": "def kreplace (a : \u03b1) (b : \u03b2 a) : List (Sigma \u03b2) \u2192 List (Sigma \u03b2) :=\n  lookmap fun s => if a = s.1 then some \u27e8a, b\u27e9 else none", "start": [337, 1], "end": [339, 57], "kind": "commanddeclaration"}, {"full_name": "List.kreplace_of_forall_not", "code": "theorem kreplace_of_forall_not (a : \u03b1) (b : \u03b2 a) {l : List (Sigma \u03b2)}\n    (H : \u2200 b : \u03b2 a, Sigma.mk a b \u2209 l) : kreplace a b l = l", "start": [342, 1], "end": [348, 10], "kind": "commanddeclaration"}, {"full_name": "List.kreplace_self", "code": "theorem kreplace_self {a : \u03b1} {b : \u03b2 a} {l : List (Sigma \u03b2)} (nd : NodupKeys l)\n    (h : Sigma.mk a b \u2208 l) : kreplace a b l = l", "start": [351, 1], "end": [364, 16], "kind": "commanddeclaration"}, {"full_name": "List.keys_kreplace", "code": "theorem keys_kreplace (a : \u03b1) (b : \u03b2 a) : \u2200 l : List (Sigma \u03b2), (kreplace a b l).keys = l.keys", "start": [367, 1], "end": [371, 69], "kind": "commanddeclaration"}, {"full_name": "List.kreplace_nodupKeys", "code": "theorem kreplace_nodupKeys (a : \u03b1) (b : \u03b2 a) {l : List (Sigma \u03b2)} :\n    (kreplace a b l).NodupKeys \u2194 l.NodupKeys", "start": [374, 1], "end": [375, 83], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kreplace", "code": "theorem Perm.kreplace {a : \u03b1} {b : \u03b2 a} {l\u2081 l\u2082 : List (Sigma \u03b2)} (nd : l\u2081.NodupKeys) :\n    l\u2081 ~ l\u2082 \u2192 kreplace a b l\u2081 ~ kreplace a b l\u2082", "start": [378, 1], "end": [384, 40], "kind": "commanddeclaration"}, {"full_name": "List.kerase", "code": "def kerase (a : \u03b1) : List (Sigma \u03b2) \u2192 List (Sigma \u03b2) :=\n  eraseP fun s => a = s.1", "start": [390, 1], "end": [392, 26], "kind": "commanddeclaration"}, {"full_name": "List.kerase_nil", "code": "theorem kerase_nil {a} : @kerase _ \u03b2 _ a [] = []", "start": [396, 1], "end": [397, 6], "kind": "commanddeclaration"}, {"full_name": "List.kerase_cons_eq", "code": "@[simp]\ntheorem kerase_cons_eq {a} {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : a = s.1) :\n    kerase a (s :: l) = l", "start": [400, 1], "end": [402, 49], "kind": "commanddeclaration"}, {"full_name": "List.kerase_cons_ne", "code": "@[simp]\ntheorem kerase_cons_ne {a} {s : Sigma \u03b2} {l : List (Sigma \u03b2)} (h : a \u2260 s.1) :\n    kerase a (s :: l) = s :: kerase a l", "start": [405, 1], "end": [407, 63], "kind": "commanddeclaration"}, {"full_name": "List.kerase_of_not_mem_keys", "code": "@[simp]\ntheorem kerase_of_not_mem_keys {a} {l : List (Sigma \u03b2)} (h : a \u2209 l.keys) : kerase a l = l", "start": [410, 1], "end": [412, 79], "kind": "commanddeclaration"}, {"full_name": "List.kerase_sublist", "code": "theorem kerase_sublist (a : \u03b1) (l : List (Sigma \u03b2)) : kerase a l <+ l", "start": [415, 1], "end": [416, 19], "kind": "commanddeclaration"}, {"full_name": "List.kerase_keys_subset", "code": "theorem kerase_keys_subset (a) (l : List (Sigma \u03b2)) : (kerase a l).keys \u2286 l.keys", "start": [419, 1], "end": [420, 38], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys_of_mem_keys_kerase", "code": "theorem mem_keys_of_mem_keys_kerase {a\u2081 a\u2082} {l : List (Sigma \u03b2)} :\n    a\u2081 \u2208 (kerase a\u2082 l).keys \u2192 a\u2081 \u2208 l.keys", "start": [423, 1], "end": [425, 34], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_kerase", "code": "theorem exists_of_kerase {a : \u03b1} {l : List (Sigma \u03b2)} (h : a \u2208 l.keys) :\n    \u2203 (b : \u03b2 a) (l\u2081 l\u2082 : List (Sigma \u03b2)),\n      a \u2209 l\u2081.keys \u2227 l = l\u2081 ++ \u27e8a, b\u27e9 :: l\u2082 \u2227 kerase a l = l\u2081 ++ l\u2082", "start": [428, 1], "end": [442, 26], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys_kerase_of_ne", "code": "@[simp]\ntheorem mem_keys_kerase_of_ne {a\u2081 a\u2082} {l : List (Sigma \u03b2)} (h : a\u2081 \u2260 a\u2082) :\n    a\u2081 \u2208 (kerase a\u2082 l).keys \u2194 a\u2081 \u2208 l.keys", "start": [445, 1], "end": [452, 24], "kind": "commanddeclaration"}, {"full_name": "List.keys_kerase", "code": "theorem keys_kerase {a} {l : List (Sigma \u03b2)} : (kerase a l).keys = l.keys.erase a", "start": [455, 1], "end": [456, 72], "kind": "commanddeclaration"}, {"full_name": "List.kerase_kerase", "code": "theorem kerase_kerase {a a'} {l : List (Sigma \u03b2)} :\n    (kerase a' l).kerase a = (kerase a l).kerase a'", "start": [459, 1], "end": [471, 31], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.kerase", "code": "theorem NodupKeys.kerase (a : \u03b1) : NodupKeys l \u2192 (kerase a l).NodupKeys", "start": [474, 1], "end": [475, 42], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kerase", "code": "theorem Perm.kerase {a : \u03b1} {l\u2081 l\u2082 : List (Sigma \u03b2)} (nd : l\u2081.NodupKeys) :\n    l\u2081 ~ l\u2082 \u2192 kerase a l\u2081 ~ kerase a l\u2082", "start": [478, 1], "end": [480, 85], "kind": "commanddeclaration"}, {"full_name": "List.not_mem_keys_kerase", "code": "@[simp]\ntheorem not_mem_keys_kerase (a) {l : List (Sigma \u03b2)} (nd : l.NodupKeys) :\n    a \u2209 (kerase a l).keys", "start": [483, 1], "end": [493, 24], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kerase", "code": "@[simp]\ntheorem dlookup_kerase (a) {l : List (Sigma \u03b2)} (nd : l.NodupKeys) :\n    dlookup a (kerase a l) = none", "start": [496, 1], "end": [499, 49], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kerase_ne", "code": "@[simp]\ntheorem dlookup_kerase_ne {a a'} {l : List (Sigma \u03b2)} (h : a \u2260 a') :\n    dlookup a (kerase a' l) = dlookup a l", "start": [502, 1], "end": [516, 24], "kind": "commanddeclaration"}, {"full_name": "List.kerase_append_left", "code": "theorem kerase_append_left {a} :\n    \u2200 {l\u2081 l\u2082 : List (Sigma \u03b2)}, a \u2208 l\u2081.keys \u2192 kerase a (l\u2081 ++ l\u2082) = kerase a l\u2081 ++ l\u2082", "start": [519, 1], "end": [524, 101], "kind": "commanddeclaration"}, {"full_name": "List.kerase_append_right", "code": "theorem kerase_append_right {a} :\n    \u2200 {l\u2081 l\u2082 : List (Sigma \u03b2)}, a \u2209 l\u2081.keys \u2192 kerase a (l\u2081 ++ l\u2082) = l\u2081 ++ kerase a l\u2082", "start": [527, 1], "end": [530, 81], "kind": "commanddeclaration"}, {"full_name": "List.kerase_comm", "code": "theorem kerase_comm (a\u2081 a\u2082) (l : List (Sigma \u03b2)) :\n    kerase a\u2082 (kerase a\u2081 l) = kerase a\u2081 (kerase a\u2082 l)", "start": [533, 1], "end": [548, 59], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_kerase", "code": "theorem sizeOf_kerase {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [SizeOf (Sigma \u03b2)] (x : \u03b1)\n    (xs : List (Sigma \u03b2)) : SizeOf.sizeOf (List.kerase x xs) \u2264 SizeOf.sizeOf xs", "start": [551, 1], "end": [556, 34], "kind": "commanddeclaration"}, {"full_name": "List.kinsert", "code": "def kinsert (a : \u03b1) (b : \u03b2 a) (l : List (Sigma \u03b2)) : List (Sigma \u03b2) :=\n  \u27e8a, b\u27e9 :: kerase a l", "start": [562, 1], "end": [564, 23], "kind": "commanddeclaration"}, {"full_name": "List.kinsert_def", "code": "@[simp]\ntheorem kinsert_def {a} {b : \u03b2 a} {l : List (Sigma \u03b2)} : kinsert a b l = \u27e8a, b\u27e9 :: kerase a l", "start": [567, 1], "end": [569, 6], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys_kinsert", "code": "theorem mem_keys_kinsert {a a'} {b' : \u03b2 a'} {l : List (Sigma \u03b2)} :\n    a \u2208 (kinsert a' b' l).keys \u2194 a = a' \u2228 a \u2208 l.keys", "start": [572, 1], "end": [573, 92], "kind": "commanddeclaration"}, {"full_name": "List.kinsert_nodupKeys", "code": "theorem kinsert_nodupKeys (a) (b : \u03b2 a) {l : List (Sigma \u03b2)} (nd : l.NodupKeys) :\n    (kinsert a b l).NodupKeys", "start": [576, 1], "end": [578, 61], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kinsert", "code": "theorem Perm.kinsert {a} {b : \u03b2 a} {l\u2081 l\u2082 : List (Sigma \u03b2)} (nd\u2081 : l\u2081.NodupKeys) (p : l\u2081 ~ l\u2082) :\n    kinsert a b l\u2081 ~ kinsert a b l\u2082", "start": [581, 1], "end": [583, 24], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kinsert", "code": "theorem dlookup_kinsert {a} {b : \u03b2 a} (l : List (Sigma \u03b2)) :\n    dlookup a (kinsert a b l) = some b", "start": [586, 1], "end": [588, 39], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kinsert_ne", "code": "theorem dlookup_kinsert_ne {a a'} {b' : \u03b2 a'} {l : List (Sigma \u03b2)} (h : a \u2260 a') :\n    dlookup a (kinsert a' b' l) = dlookup a l", "start": [591, 1], "end": [592, 61], "kind": "commanddeclaration"}, {"full_name": "List.kextract", "code": "def kextract (a : \u03b1) : List (Sigma \u03b2) \u2192 Option (\u03b2 a) \u00d7 List (Sigma \u03b2)\n  | [] => (none, [])\n  | s :: l =>\n    if h : s.1 = a then (some (Eq.recOn h s.2), l)\n    else\n      let (b', l') := kextract a l\n      (b', s :: l')", "start": [598, 1], "end": [606, 20], "kind": "commanddeclaration"}, {"full_name": "List.kextract_eq_dlookup_kerase", "code": "@[simp]\ntheorem kextract_eq_dlookup_kerase (a : \u03b1) :\n    \u2200 l : List (Sigma \u03b2), kextract a l = (dlookup a l, kerase a l)", "start": [609, 1], "end": [617, 73], "kind": "commanddeclaration"}, {"full_name": "List.dedupKeys", "code": "def dedupKeys : List (Sigma \u03b2) \u2192 List (Sigma \u03b2) :=\n  List.foldr (fun x => kinsert x.1 x.2) []", "start": [623, 1], "end": [625, 43], "kind": "commanddeclaration"}, {"full_name": "List.dedupKeys_cons", "code": "theorem dedupKeys_cons {x : Sigma \u03b2} (l : List (Sigma \u03b2)) :\n    dedupKeys (x :: l) = kinsert x.1 x.2 (dedupKeys l)", "start": [628, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "List.nodupKeys_dedupKeys", "code": "theorem nodupKeys_dedupKeys (l : List (Sigma \u03b2)) : NodupKeys (dedupKeys l)", "start": [634, 1], "end": [648, 26], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_dedupKeys", "code": "theorem dlookup_dedupKeys (a : \u03b1) (l : List (Sigma \u03b2)) : dlookup a (dedupKeys l) = dlookup a l", "start": [651, 1], "end": [658, 12], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_dedupKeys", "code": "theorem sizeOf_dedupKeys {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [SizeOf (Sigma \u03b2)]\n    (xs : List (Sigma \u03b2)) : SizeOf.sizeOf (dedupKeys xs) \u2264 SizeOf.sizeOf xs", "start": [661, 1], "end": [669, 15], "kind": "commanddeclaration"}, {"full_name": "List.kunion", "code": "def kunion : List (Sigma \u03b2) \u2192 List (Sigma \u03b2) \u2192 List (Sigma \u03b2)\n  | [], l\u2082 => l\u2082\n  | s :: l\u2081, l\u2082 => s :: kunion l\u2081 (kerase s.1 l\u2082)", "start": [675, 1], "end": [679, 50], "kind": "commanddeclaration"}, {"full_name": "List.nil_kunion", "code": "@[simp]\ntheorem nil_kunion {l : List (Sigma \u03b2)} : kunion [] l = l", "start": [682, 1], "end": [684, 6], "kind": "commanddeclaration"}, {"full_name": "List.kunion_nil", "code": "@[simp]\ntheorem kunion_nil : \u2200 {l : List (Sigma \u03b2)}, kunion l [] = l", "start": [687, 1], "end": [690, 53], "kind": "commanddeclaration"}, {"full_name": "List.kunion_cons", "code": "@[simp]\ntheorem kunion_cons {s} {l\u2081 l\u2082 : List (Sigma \u03b2)} :\n    kunion (s :: l\u2081) l\u2082 = s :: kunion l\u2081 (kerase s.1 l\u2082)", "start": [693, 1], "end": [696, 6], "kind": "commanddeclaration"}, {"full_name": "List.mem_keys_kunion", "code": "@[simp]\ntheorem mem_keys_kunion {a} {l\u2081 l\u2082 : List (Sigma \u03b2)} :\n    a \u2208 (kunion l\u2081 l\u2082).keys \u2194 a \u2208 l\u2081.keys \u2228 a \u2208 l\u2082.keys", "start": [699, 1], "end": [704, 70], "kind": "commanddeclaration"}, {"full_name": "List.kunion_kerase", "code": "@[simp]\ntheorem kunion_kerase {a} :\n    \u2200 {l\u2081 l\u2082 : List (Sigma \u03b2)}, kunion (kerase a l\u2081) (kerase a l\u2082) = kerase a (kunion l\u2081 l\u2082)", "start": [707, 1], "end": [711, 90], "kind": "commanddeclaration"}, {"full_name": "List.NodupKeys.kunion", "code": "theorem NodupKeys.kunion (nd\u2081 : l\u2081.NodupKeys) (nd\u2082 : l\u2082.NodupKeys) : (kunion l\u2081 l\u2082).NodupKeys", "start": [714, 1], "end": [719, 57], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kunion_right", "code": "theorem Perm.kunion_right {l\u2081 l\u2082 : List (Sigma \u03b2)} (p : l\u2081 ~ l\u2082) (l) :\n    kunion l\u2081 l ~ kunion l\u2082 l", "start": [722, 1], "end": [729, 62], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kunion_left", "code": "theorem Perm.kunion_left :\n    \u2200 (l) {l\u2081 l\u2082 : List (Sigma \u03b2)}, l\u2081.NodupKeys \u2192 l\u2081 ~ l\u2082 \u2192 kunion l l\u2081 ~ kunion l l\u2082", "start": [732, 1], "end": [735, 84], "kind": "commanddeclaration"}, {"full_name": "List.Perm.kunion", "code": "theorem Perm.kunion {l\u2081 l\u2082 l\u2083 l\u2084 : List (Sigma \u03b2)} (nd\u2083 : l\u2083.NodupKeys) (p\u2081\u2082 : l\u2081 ~ l\u2082)\n    (p\u2083\u2084 : l\u2083 ~ l\u2084) : kunion l\u2081 l\u2083 ~ kunion l\u2082 l\u2084", "start": [738, 1], "end": [740, 55], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kunion_left", "code": "@[simp]\ntheorem dlookup_kunion_left {a} {l\u2081 l\u2082 : List (Sigma \u03b2)} (h : a \u2208 l\u2081.keys) :\n    dlookup a (kunion l\u2081 l\u2082) = dlookup a l\u2081", "start": [743, 1], "end": [753, 22], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kunion_right", "code": "@[simp]\ntheorem dlookup_kunion_right {a} {l\u2081 l\u2082 : List (Sigma \u03b2)} (h : a \u2209 l\u2081.keys) :\n    dlookup a (kunion l\u2081 l\u2082) = dlookup a l\u2082", "start": [756, 1], "end": [761, 58], "kind": "commanddeclaration"}, {"full_name": "List.mem_dlookup_kunion", "code": "theorem mem_dlookup_kunion {a} {b : \u03b2 a} {l\u2081 l\u2082 : List (Sigma \u03b2)} :\n    b \u2208 dlookup a (kunion l\u2081 l\u2082) \u2194 b \u2208 dlookup a l\u2081 \u2228 a \u2209 l\u2081.keys \u2227 b \u2208 dlookup a l\u2082", "start": [765, 1], "end": [776, 20], "kind": "commanddeclaration"}, {"full_name": "List.dlookup_kunion_eq_some", "code": "@[simp]\ntheorem dlookup_kunion_eq_some {a} {b : \u03b2 a} {l\u2081 l\u2082 : List (Sigma \u03b2)} :\n    dlookup a (kunion l\u2081 l\u2082) = some b \u2194\n      dlookup a l\u2081 = some b \u2228 a \u2209 l\u2081.keys \u2227 dlookup a l\u2082 = some b", "start": [780, 1], "end": [784, 21], "kind": "commanddeclaration"}, {"full_name": "List.mem_dlookup_kunion_middle", "code": "theorem mem_dlookup_kunion_middle {a} {b : \u03b2 a} {l\u2081 l\u2082 l\u2083 : List (Sigma \u03b2)}\n    (h\u2081 : b \u2208 dlookup a (kunion l\u2081 l\u2083)) (h\u2082 : a \u2209 keys l\u2082) :\n    b \u2208 dlookup a (kunion (kunion l\u2081 l\u2082) l\u2083)", "start": [786, 1], "end": [791, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/Kleisli.lean", "imports": ["Mathlib/CategoryTheory/Monad/Basic.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Kleisli", "code": "@[nolint unusedArguments]\ndef Kleisli (_T : Monad C) :=\n  C", "start": [30, 1], "end": [35, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Kleisli.Kleisli.category", "code": "instance Kleisli.category : Category (Kleisli T) where\n  Hom := fun X Y : C => X \u27f6 (T : C \u2964 C).obj Y\n  id X := T.\u03b7.app X\n  comp {X} {Y} {Z} f g := f \u226b (T : C \u2964 C).map g \u226b T.\u03bc.app Z\n  id_comp {X} {Y} f := by\n    dsimp rw [\u2190 T.\u03b7.naturality_assoc f, T.left_unit]\n    apply Category.comp_id\n  assoc f g h := by\n    simp only [Functor.map_comp, Category.assoc, Monad.assoc]\n    erw [T.\u03bc.naturality_assoc]", "start": [45, 1], "end": [57, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Kleisli.Adjunction.toKleisli", "code": "@[simps]\ndef toKleisli : C \u2964 Kleisli T where\n  obj X := (X : Kleisli T)\n  map {X} {Y} f := (f \u226b T.\u03b7.app Y : X \u27f6 T.obj Y)\n  map_comp {X} {Y} {Z} f g := by\n    change _ = (f \u226b (Monad.\u03b7 T).app Y) \u226b T.map (g \u226b (Monad.\u03b7 T).app Z) \u226b T.\u03bc.app Z\n    simp [\u2190 T.\u03b7.naturality g]", "start": [62, 1], "end": [70, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Kleisli.Adjunction.fromKleisli", "code": "@[simps]\ndef fromKleisli : Kleisli T \u2964 C where\n  obj X := T.obj X\n  map {_} {Y} f := T.map f \u226b T.\u03bc.app Y\n  map_id X := T.right_unit _\n  map_comp {X} {Y} {Z} f g := by\n    change T.map (f \u226b T.map g \u226b T.\u03bc.app Z) \u226b T.\u03bc.app Z = _\n    simp only [Functor.map_comp, Category.assoc]\n    erw [\u2190 T.\u03bc.naturality_assoc g, T.assoc]\n    rfl", "start": [73, 1], "end": [84, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Kleisli.Adjunction.adj", "code": "def adj : toKleisli T \u22a3 fromKleisli T :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y => Equiv.refl (X \u27f6 T.obj Y)\n      homEquiv_naturality_left_symm := fun {X} {Y} {Z} f g => by\n        change f \u226b g = (f \u226b T.\u03b7.app Y) \u226b T.map g \u226b T.\u03bc.app Z\n        rw [Category.assoc, \u2190 T.\u03b7.naturality_assoc g, Functor.id_map]\n        dsimp\n        simp [Monad.left_unit] }", "start": [87, 1], "end": [97, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Kleisli.Adjunction.toKleisliCompFromKleisliIsoSelf", "code": "def toKleisliCompFromKleisliIsoSelf : toKleisli T \u22d9 fromKleisli T \u2245 T :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [100, 1], "end": [102, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli", "code": "@[nolint unusedArguments]\ndef Cokleisli (_U : Comonad C) :=\n  C", "start": [109, 1], "end": [114, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli.Cokleisli.category", "code": "instance Cokleisli.category : Category (Cokleisli U) where\n  Hom := fun X Y : C => (U : C \u2964 C).obj X \u27f6 Y\n  id X := U.\u03b5.app X\n  comp {X} {Y} {Z} f g := U.\u03b4.app X \u226b (U : C \u2964 C).map f \u226b g\n  id_comp f := by dsimp; rw [U.right_counit_assoc]\n  assoc {X} {Y} {Z} {W} f g h := by\n    change U.\u03b4.app X \u226b U.map (U.\u03b4.app X \u226b U.map f \u226b g) \u226b h =\n      U.\u03b4.app X \u226b U.map f \u226b (U.\u03b4.app Y \u226b U.map g \u226b h)\n    simp only [Functor.map_comp, \u2190 Category.assoc, eq_whisker]\n    simp only [Category.assoc, U.\u03b4.naturality, Functor.comp_map, U.coassoc_assoc]", "start": [124, 1], "end": [136, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli.Adjunction.toCokleisli", "code": "@[simps]\ndef toCokleisli : C \u2964 Cokleisli U where\n  obj X := (X : Cokleisli U)\n  map {X} {_} f := (U.\u03b5.app X \u226b f : _)\n  map_comp {X} {Y} {_} f g := by\n    change U.\u03b5.app X \u226b f \u226b g = U.\u03b4.app X \u226b U.map (U.\u03b5.app X \u226b f) \u226b U.\u03b5.app Y \u226b g\n    simp [\u2190 U.\u03b5.naturality g]", "start": [141, 1], "end": [149, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli.Adjunction.fromCokleisli", "code": "@[simps]\ndef fromCokleisli : Cokleisli U \u2964 C where\n  obj X := U.obj X\n  map {X} {_} f := U.\u03b4.app X \u226b U.map f\n  map_id X := U.right_counit _\n  map_comp {X} {Y} {_} f g := by\n    change U.\u03b4.app X \u226b U.map (U.\u03b4.app X \u226b U.map f \u226b g) =\n      (U.\u03b4.app X \u226b U.map f) \u226b (U.\u03b4.app Y \u226b U.map g)\n    simp only [Functor.map_comp, \u2190 Category.assoc]\n    rw [Comonad.coassoc]\n    simp only [Category.assoc, NatTrans.naturality, Functor.comp_map]", "start": [152, 1], "end": [164, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli.Adjunction.adj", "code": "def adj : fromCokleisli U \u22a3 toCokleisli U :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y => Equiv.refl (U.obj X \u27f6 Y)\n      homEquiv_naturality_right := fun {X} {Y} {_} f g => by\n        change f \u226b g = U.\u03b4.app X \u226b U.map f \u226b U.\u03b5.app Y \u226b g\n        erw [\u2190 Category.assoc (U.map f), U.\u03b5.naturality]; dsimp\n        simp only [\u2190 Category.assoc, Comonad.left_counit, Category.id_comp] }", "start": [167, 1], "end": [175, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Cokleisli.Adjunction.toCokleisliCompFromCokleisliIsoSelf", "code": "def toCokleisliCompFromCokleisliIsoSelf : toCokleisli U \u22d9 fromCokleisli U \u2245 U :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [178, 1], "end": [180, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/KleisliCat.lean", "imports": ["Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.KleisliCat", "code": "@[nolint unusedArguments]\ndef KleisliCat (_ : Type u \u2192 Type v) :=\n  Type u", "start": [31, 1], "end": [35, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.KleisliCat.mk", "code": "def KleisliCat.mk (m) (\u03b1 : Type u) : KleisliCat m :=\n  \u03b1", "start": [38, 1], "end": [40, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.KleisliCat.categoryStruct", "code": "instance KleisliCat.categoryStruct {m} [Monad.{u, v} m] :\n    CategoryStruct (KleisliCat m) where\n  Hom \u03b1 \u03b2 := \u03b1 \u2192 m \u03b2\n  id _ x := pure x\n  comp f g := f >=> g", "start": [43, 1], "end": [47, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.KleisliCat.category", "code": "instance KleisliCat.category {m} [Monad.{u, v} m] [LawfulMonad m] : Category (KleisliCat m) := by\n  refine' { id_comp := _, comp_id := _, assoc := _ } <;> intros <;> refine funext (fun x => ?_) <;>\n  simp [CategoryStruct.id, CategoryStruct.comp, (\u00b7 >=> \u00b7)]", "start": [50, 1], "end": [55, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.KleisliCat.id_def", "code": "@[simp]\ntheorem KleisliCat.id_def {m} [Monad m] (\u03b1 : KleisliCat m) : \ud835\udfd9 \u03b1 = @pure m _ \u03b1", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.KleisliCat.comp_def", "code": "theorem KleisliCat.comp_def {m} [Monad m] (\u03b1 \u03b2 \u03b3 : KleisliCat m) (xs : \u03b1 \u27f6 \u03b2) (ys : \u03b2 \u27f6 \u03b3) (a : \u03b1) :\n    (xs \u226b ys) a = xs a >>= ys", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Deprecated/Subgroup.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Deprecated/Submonoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsAddSubgroup", "code": "structure IsAddSubgroup (s : Set A) extends IsAddSubmonoid s : Prop where\n  \n  neg_mem {a} : a \u2208 s \u2192 -a \u2208 s", "start": [43, 1], "end": [46, 31], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup", "code": "@[to_additive]\nstructure IsSubgroup (s : Set G) extends IsSubmonoid s : Prop where\n  \n  inv_mem {a} : a \u2208 s \u2192 a\u207b\u00b9 \u2208 s", "start": [49, 1], "end": [53, 32], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.div_mem", "code": "@[to_additive]\ntheorem IsSubgroup.div_mem {s : Set G} (hs : IsSubgroup s) {x y : G} (hx : x \u2208 s) (hy : y \u2208 s) :\n    x / y \u2208 s", "start": [56, 1], "end": [58, 84], "kind": "commanddeclaration"}, {"full_name": "Additive.isAddSubgroup", "code": "theorem Additive.isAddSubgroup {s : Set G} (hs : IsSubgroup s) : @IsAddSubgroup (Additive G) _ s", "start": [62, 1], "end": [63, 91], "kind": "commanddeclaration"}, {"full_name": "Additive.isAddSubgroup_iff", "code": "theorem Additive.isAddSubgroup_iff {s : Set G} : @IsAddSubgroup (Additive G) _ s \u2194 IsSubgroup s", "start": [66, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isSubgroup", "code": "theorem Multiplicative.isSubgroup {s : Set A} (hs : IsAddSubgroup s) :\n    @IsSubgroup (Multiplicative A) _ s", "start": [71, 1], "end": [73, 100], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isSubgroup_iff", "code": "theorem Multiplicative.isSubgroup_iff {s : Set A} :\n    @IsSubgroup (Multiplicative A) _ s \u2194 IsAddSubgroup s", "start": [76, 1], "end": [79, 33], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.of_div", "code": "@[to_additive of_add_neg]\ntheorem IsSubgroup.of_div (s : Set G) (one_mem : (1 : G) \u2208 s)\n    (div_mem : \u2200 {a b : G}, a \u2208 s \u2192 b \u2208 s \u2192 a * b\u207b\u00b9 \u2208 s) : IsSubgroup s", "start": [82, 1], "end": [94, 14], "kind": "commanddeclaration"}, {"full_name": "IsAddSubgroup.of_sub", "code": "theorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) \u2208 s)\n    (sub_mem : \u2200 {a b : A}, a \u2208 s \u2192 b \u2208 s \u2192 a - b \u2208 s) : IsAddSubgroup s", "start": [98, 1], "end": [101, 52], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.inter", "code": "@[to_additive]\ntheorem IsSubgroup.inter {s\u2081 s\u2082 : Set G} (hs\u2081 : IsSubgroup s\u2081) (hs\u2082 : IsSubgroup s\u2082) :\n    IsSubgroup (s\u2081 \u2229 s\u2082)", "start": [104, 1], "end": [108, 64], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.iInter", "code": "@[to_additive]\ntheorem IsSubgroup.iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set G} (hs : \u2200 y : \u03b9, IsSubgroup (s y)) :\n    IsSubgroup (Set.iInter s)", "start": [112, 1], "end": [117, 83], "kind": "commanddeclaration"}, {"full_name": "isSubgroup_iUnion_of_directed", "code": "@[to_additive]\ntheorem isSubgroup_iUnion_of_directed {\u03b9 : Type*} [Nonempty \u03b9] {s : \u03b9 \u2192 Set G}\n    (hs : \u2200 i, IsSubgroup (s i)) (directed : \u2200 i j, \u2203 k, s i \u2286 s k \u2227 s j \u2286 s k) :\n    IsSubgroup (\u22c3 i, s i)", "start": [121, 1], "end": [128, 95], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.inv_mem_iff", "code": "@[to_additive]\ntheorem inv_mem_iff : a\u207b\u00b9 \u2208 s \u2194 a \u2208 s", "start": [140, 1], "end": [142, 53], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mul_mem_cancel_right", "code": "@[to_additive]\ntheorem mul_mem_cancel_right (h : a \u2208 s) : b * a \u2208 s \u2194 b \u2208 s", "start": [146, 1], "end": [148, 87], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mul_mem_cancel_left", "code": "@[to_additive]\ntheorem mul_mem_cancel_left (h : a \u2208 s) : a * b \u2208 s \u2194 b \u2208 s", "start": [152, 1], "end": [154, 74], "kind": "commanddeclaration"}, {"full_name": "IsNormalAddSubgroup", "code": "structure IsNormalAddSubgroup [AddGroup A] (s : Set A) extends IsAddSubgroup s : Prop where\n  \n  normal : \u2200 n \u2208 s, \u2200 g : A, g + n + -g \u2208 s", "start": [160, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "IsNormalSubgroup", "code": "@[to_additive]\nstructure IsNormalSubgroup [Group G] (s : Set G) extends IsSubgroup s : Prop where\n  \n  normal : \u2200 n \u2208 s, \u2200 g : G, g * n * g\u207b\u00b9 \u2208 s", "start": [168, 1], "end": [174, 45], "kind": "commanddeclaration"}, {"full_name": "isNormalSubgroup_of_commGroup", "code": "@[to_additive]\ntheorem isNormalSubgroup_of_commGroup [CommGroup G] {s : Set G} (hs : IsSubgroup s) :\n    IsNormalSubgroup s", "start": [177, 1], "end": [180, 86], "kind": "commanddeclaration"}, {"full_name": "Additive.isNormalAddSubgroup", "code": "theorem Additive.isNormalAddSubgroup [Group G] {s : Set G} (hs : IsNormalSubgroup s) :\n    @IsNormalAddSubgroup (Additive G) _ s", "start": [184, 1], "end": [187, 59], "kind": "commanddeclaration"}, {"full_name": "Additive.isNormalAddSubgroup_iff", "code": "theorem Additive.isNormalAddSubgroup_iff [Group G] {s : Set G} :\n    @IsNormalAddSubgroup (Additive G) _ s \u2194 IsNormalSubgroup s", "start": [191, 1], "end": [194, 45], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isNormalSubgroup", "code": "theorem Multiplicative.isNormalSubgroup [AddGroup A] {s : Set A} (hs : IsNormalAddSubgroup s) :\n    @IsNormalSubgroup (Multiplicative A) _ s", "start": [197, 1], "end": [200, 71], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isNormalSubgroup_iff", "code": "theorem Multiplicative.isNormalSubgroup_iff [AddGroup A] {s : Set A} :\n    @IsNormalSubgroup (Multiplicative A) _ s \u2194 IsNormalAddSubgroup s", "start": [203, 1], "end": [208, 48], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mem_norm_comm", "code": "@[to_additive]\ntheorem mem_norm_comm {s : Set G} (hs : IsNormalSubgroup s) {a b : G} (hab : a * b \u2208 s) :\n    b * a \u2208 s", "start": [216, 1], "end": [220, 21], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mem_norm_comm_iff", "code": "@[to_additive]\ntheorem mem_norm_comm_iff {s : Set G} (hs : IsNormalSubgroup s) {a b : G} : a * b \u2208 s \u2194 b * a \u2208 s", "start": [224, 1], "end": [226, 39], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.trivial", "code": "@[to_additive \"the trivial additive subgroup\"]\ndef trivial (G : Type*) [Group G] : Set G :=\n  {1}", "start": [230, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mem_trivial", "code": "@[to_additive (attr := simp)]\ntheorem mem_trivial {g : G} : g \u2208 trivial G \u2194 g = 1", "start": [237, 1], "end": [239, 20], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.trivial_normal", "code": "@[to_additive]\ntheorem trivial_normal : IsNormalSubgroup (trivial G)", "start": [243, 1], "end": [245, 71], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.eq_trivial_iff", "code": "@[to_additive]\ntheorem eq_trivial_iff {s : Set G} (hs : IsSubgroup s) : s = trivial G \u2194 \u2200 x \u2208 s, x = (1 : G)", "start": [249, 1], "end": [252, 95], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.univ_subgroup", "code": "@[to_additive]\ntheorem univ_subgroup : IsNormalSubgroup (@univ G)", "start": [256, 1], "end": [257, 81], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.center", "code": "@[to_additive addCenter \"The underlying set of the center of an additive group.\"]\ndef center (G : Type*) [Group G] : Set G :=\n  { z | \u2200 g, g * z = z * g }", "start": [261, 1], "end": [264, 29], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.mem_center", "code": "@[to_additive mem_add_center]\ntheorem mem_center {a : G} : a \u2208 center G \u2194 \u2200 g, g * a = a * g", "start": [268, 1], "end": [270, 10], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.center_normal", "code": "@[to_additive add_center_normal]\ntheorem center_normal : IsNormalSubgroup (center G)", "start": [274, 1], "end": [288, 11], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.normalizer", "code": "@[to_additive addNormalizer\n      \"The underlying set of the normalizer of a subset `S : Set A` of an\n      additive group `A`. That is, the elements `a : A` such that `a + S - a = S`.\"]\ndef normalizer (s : Set G) : Set G :=\n  { g : G | \u2200 n, n \u2208 s \u2194 g * n * g\u207b\u00b9 \u2208 s }", "start": [292, 1], "end": [298, 43], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.normalizer_isSubgroup", "code": "@[to_additive]\ntheorem normalizer_isSubgroup (s : Set G) : IsSubgroup (normalizer s)", "start": [302, 1], "end": [309, 52], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.subset_normalizer", "code": "@[to_additive subset_add_normalizer]\ntheorem subset_normalizer {s : Set G} (hs : IsSubgroup s) : s \u2286 normalizer s", "start": [313, 1], "end": [316, 42], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.ker", "code": "@[to_additive \"`ker f : Set A` is the underlying subset of the kernel of a map `A \u2192 B`\"]\ndef ker [Group H] (f : G \u2192 H) : Set G :=\n  preimage f (trivial H)", "start": [327, 1], "end": [330, 25], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.mem_ker", "code": "@[to_additive]\ntheorem mem_ker [Group H] (f : G \u2192 H) {x : G} : x \u2208 ker f \u2194 f x = 1", "start": [334, 1], "end": [336, 14], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.one_ker_inv", "code": "@[to_additive]\ntheorem one_ker_inv {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f (a * b\u207b\u00b9) = 1) :\n    f a = f b", "start": [342, 1], "end": [346, 52], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.one_ker_inv'", "code": "@[to_additive]\ntheorem one_ker_inv' {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f (a\u207b\u00b9 * b) = 1) :\n    f a = f b", "start": [350, 1], "end": [355, 35], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.inv_ker_one", "code": "@[to_additive]\ntheorem inv_ker_one {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a * b\u207b\u00b9) = 1", "start": [359, 1], "end": [363, 43], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.inv_ker_one'", "code": "@[to_additive]\ntheorem inv_ker_one' {f : G \u2192 H} (hf : IsGroupHom f) {a b : G} (h : f a = f b) :\n    f (a\u207b\u00b9 * b) = 1", "start": [367, 1], "end": [371, 43], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.one_iff_ker_inv", "code": "@[to_additive]\ntheorem one_iff_ker_inv {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 f (a * b\u207b\u00b9) = 1", "start": [375, 1], "end": [377, 35], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.one_iff_ker_inv'", "code": "@[to_additive]\ntheorem one_iff_ker_inv' {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 f (a\u207b\u00b9 * b) = 1", "start": [381, 1], "end": [383, 37], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.inv_iff_ker", "code": "@[to_additive]\ntheorem inv_iff_ker {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 a * b\u207b\u00b9 \u2208 ker f", "start": [387, 1], "end": [389, 45], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.inv_iff_ker'", "code": "@[to_additive]\ntheorem inv_iff_ker' {f : G \u2192 H} (hf : IsGroupHom f) (a b : G) : f a = f b \u2194 a\u207b\u00b9 * b \u2208 ker f", "start": [393, 1], "end": [395, 46], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.image_subgroup", "code": "@[to_additive]\ntheorem image_subgroup {f : G \u2192 H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\n    IsSubgroup (f '' s)", "start": [399, 1], "end": [408, 20], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.range_subgroup", "code": "@[to_additive]\ntheorem range_subgroup {f : G \u2192 H} (hf : IsGroupHom f) : IsSubgroup (Set.range f)", "start": [412, 1], "end": [414, 71], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.preimage", "code": "@[to_additive]\ntheorem preimage {f : G \u2192 H} (hf : IsGroupHom f) {s : Set H} (hs : IsSubgroup s) :\n    IsSubgroup (f \u207b\u00b9' s)", "start": [421, 1], "end": [426, 51], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.preimage_normal", "code": "@[to_additive]\ntheorem preimage_normal {f : G \u2192 H} (hf : IsGroupHom f) {s : Set H} (hs : IsNormalSubgroup s) :\n    IsNormalSubgroup (f \u207b\u00b9' s)", "start": [430, 1], "end": [436, 95], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.isNormalSubgroup_ker", "code": "@[to_additive]\ntheorem isNormalSubgroup_ker {f : G \u2192 H} (hf : IsGroupHom f) : IsNormalSubgroup (ker f)", "start": [440, 1], "end": [442, 36], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.injective_of_trivial_ker", "code": "@[to_additive]\ntheorem injective_of_trivial_ker {f : G \u2192 H} (hf : IsGroupHom f) (h : ker f = trivial G) :\n    Function.Injective f", "start": [446, 1], "end": [452, 48], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.trivial_ker_of_injective", "code": "@[to_additive]\ntheorem trivial_ker_of_injective {f : G \u2192 H} (hf : IsGroupHom f) (h : Function.Injective f) :\n    ker f = trivial G", "start": [456, 1], "end": [464, 73], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.injective_iff_trivial_ker", "code": "@[to_additive]\ntheorem injective_iff_trivial_ker {f : G \u2192 H} (hf : IsGroupHom f) :\n    Function.Injective f \u2194 ker f = trivial G", "start": [468, 1], "end": [471, 61], "kind": "commanddeclaration"}, {"full_name": "IsGroupHom.trivial_ker_iff_eq_one", "code": "@[to_additive]\ntheorem trivial_ker_iff_eq_one {f : G \u2192 H} (hf : IsGroupHom f) :\n    ker f = trivial G \u2194 \u2200 x, f x = 1 \u2192 x = 1", "start": [475, 1], "end": [479, 89], "kind": "commanddeclaration"}, {"full_name": "AddGroup.InClosure", "code": "inductive InClosure (s : Set A) : A \u2192 Prop\n  | basic {a : A} : a \u2208 s \u2192 InClosure s a\n  | zero : InClosure s 0\n  | neg {a : A} : InClosure s a \u2192 InClosure s (-a)\n  | add {a b : A} : InClosure s a \u2192 InClosure s b \u2192 InClosure s (a + b)", "start": [489, 1], "end": [495, 72], "kind": "commanddeclaration"}, {"full_name": "Group.InClosure", "code": "@[to_additive]\ninductive InClosure (s : Set G) : G \u2192 Prop\n  | basic {a : G} : a \u2208 s \u2192 InClosure s a\n  | one : InClosure s 1\n  | inv {a : G} : InClosure s a \u2192 InClosure s a\u207b\u00b9\n  | mul {a b : G} : InClosure s a \u2192 InClosure s b \u2192 InClosure s (a * b)", "start": [506, 1], "end": [513, 72], "kind": "commanddeclaration"}, {"full_name": "Group.closure", "code": "@[to_additive\n  \"`AddGroup.closure s` is the additive subgroup generated by `s`, i.e., the\n  smallest additive subgroup containing `s`.\"]\ndef closure (s : Set G) : Set G :=\n  { a | InClosure s a }", "start": [516, 1], "end": [522, 24], "kind": "commanddeclaration"}, {"full_name": "Group.mem_closure", "code": "@[to_additive]\ntheorem mem_closure {a : G} : a \u2208 s \u2192 a \u2208 closure s", "start": [526, 1], "end": [528, 18], "kind": "commanddeclaration"}, {"full_name": "Group.closure.isSubgroup", "code": "@[to_additive]\ntheorem closure.isSubgroup (s : Set G) : IsSubgroup (closure s)", "start": [532, 1], "end": [536, 31], "kind": "commanddeclaration"}, {"full_name": "Group.subset_closure", "code": "@[to_additive]\ntheorem subset_closure {s : Set G} : s \u2286 closure s", "start": [540, 1], "end": [541, 75], "kind": "commanddeclaration"}, {"full_name": "Group.closure_subset", "code": "@[to_additive]\ntheorem closure_subset {s t : Set G} (ht : IsSubgroup t) (h : s \u2286 t) : closure s \u2286 t", "start": [545, 1], "end": [547, 84], "kind": "commanddeclaration"}, {"full_name": "Group.closure_subset_iff", "code": "@[to_additive]\ntheorem closure_subset_iff {s t : Set G} (ht : IsSubgroup t) : closure s \u2286 t \u2194 s \u2286 t", "start": [551, 1], "end": [553, 75], "kind": "commanddeclaration"}, {"full_name": "Group.closure_mono", "code": "@[to_additive]\ntheorem closure_mono {s t : Set G} (h : s \u2286 t) : closure s \u2286 closure t", "start": [557, 1], "end": [559, 77], "kind": "commanddeclaration"}, {"full_name": "Group.closure_subgroup", "code": "@[to_additive (attr := simp)]\ntheorem closure_subgroup {s : Set G} (hs : IsSubgroup s) : closure s = s", "start": [563, 1], "end": [565, 78], "kind": "commanddeclaration"}, {"full_name": "Group.exists_list_of_mem_closure", "code": "@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set G} {a : G} (h : a \u2208 closure s) :\n    \u2203 l : List G, (\u2200 x \u2208 l, x \u2208 s \u2228 x\u207b\u00b9 \u2208 s) \u2227 l.prod = a", "start": [569, 1], "end": [583, 88], "kind": "commanddeclaration"}, {"full_name": "Group.image_closure", "code": "@[to_additive]\ntheorem image_closure [Group H] {f : G \u2192 H} (hf : IsGroupHom f) (s : Set G) :\n    f '' closure s = closure (f '' s)", "start": [587, 1], "end": [607, 41], "kind": "commanddeclaration"}, {"full_name": "Group.mclosure_subset", "code": "@[to_additive]\ntheorem mclosure_subset {s : Set G} : Monoid.Closure s \u2286 closure s", "start": [611, 1], "end": [613, 79], "kind": "commanddeclaration"}, {"full_name": "Group.mclosure_inv_subset", "code": "@[to_additive]\ntheorem mclosure_inv_subset {s : Set G} : Monoid.Closure (Inv.inv \u207b\u00b9' s) \u2286 closure s", "start": [617, 1], "end": [620, 70], "kind": "commanddeclaration"}, {"full_name": "Group.closure_eq_mclosure", "code": "@[to_additive]\ntheorem closure_eq_mclosure {s : Set G} : closure s = Monoid.Closure (s \u222a Inv.inv \u207b\u00b9' s)", "start": [624, 1], "end": [643, 86], "kind": "commanddeclaration"}, {"full_name": "Group.mem_closure_union_iff", "code": "@[to_additive]\ntheorem mem_closure_union_iff {G : Type*} [CommGroup G] {s t : Set G} {x : G} :\n    x \u2208 closure (s \u222a t) \u2194 \u2203 y \u2208 closure s, \u2203 z \u2208 closure t, y * z = x", "start": [647, 1], "end": [657, 48], "kind": "commanddeclaration"}, {"full_name": "IsSubgroup.trivial_eq_closure", "code": "@[to_additive]\ntheorem trivial_eq_closure : trivial G = Group.closure \u2205", "start": [667, 1], "end": [670, 66], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOf_subset", "code": "theorem conjugatesOf_subset {t : Set G} (ht : IsNormalSubgroup t) {a : G} (h : a \u2208 t) :\n    conjugatesOf a \u2286 t", "start": [682, 1], "end": [686, 12], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOfSet_subset'", "code": "theorem conjugatesOfSet_subset' {s t : Set G} (ht : IsNormalSubgroup t) (h : s \u2286 t) :\n    conjugatesOfSet s \u2286 t", "start": [689, 1], "end": [691, 61], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure", "code": "def normalClosure (s : Set G) : Set G :=\n  closure (conjugatesOfSet s)", "start": [694, 1], "end": [697, 30], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOfSet_subset_normalClosure", "code": "theorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s \u2286 normalClosure s", "start": [700, 1], "end": [701, 17], "kind": "commanddeclaration"}, {"full_name": "Group.subset_normalClosure", "code": "theorem subset_normalClosure : s \u2286 normalClosure s", "start": [704, 1], "end": [705, 79], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure.isSubgroup", "code": "theorem normalClosure.isSubgroup (s : Set G) : IsSubgroup (normalClosure s)", "start": [708, 1], "end": [710, 41], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure.is_normal", "code": "theorem normalClosure.is_normal : IsNormalSubgroup (normalClosure s)", "start": [713, 1], "end": [723, 75], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure_subset", "code": "theorem normalClosure_subset {s t : Set G} (ht : IsNormalSubgroup t) (h : s \u2286 t) :\n    normalClosure s \u2286 t", "start": [726, 1], "end": [733, 56], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure_subset_iff", "code": "theorem normalClosure_subset_iff {s t : Set G} (ht : IsNormalSubgroup t) :\n    s \u2286 t \u2194 normalClosure s \u2286 t", "start": [736, 1], "end": [738, 67], "kind": "commanddeclaration"}, {"full_name": "Group.normalClosure_mono", "code": "theorem normalClosure_mono {s t : Set G} : s \u2286 t \u2192 normalClosure s \u2286 normalClosure t", "start": [741, 1], "end": [742, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.of", "code": "@[to_additive \"Create a bundled additive subgroup from a set `s` and `[IsAddSubgroup s]`.\"]\ndef Subgroup.of [Group G] {s : Set G} (h : IsSubgroup s) : Subgroup G\n    where\n  carrier := s\n  one_mem' := h.1.1\n  mul_mem' := h.1.2\n  inv_mem' := h.2", "start": [747, 1], "end": [754, 18], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isSubgroup", "code": "@[to_additive]\ntheorem Subgroup.isSubgroup [Group G] (K : Subgroup G) : IsSubgroup (K : Set G)", "start": [758, 1], "end": [762, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.of_normal", "code": "@[to_additive]\ntheorem Subgroup.of_normal [Group G] (s : Set G) (h : IsSubgroup s) (n : IsNormalSubgroup s) :\n    Subgroup.Normal (Subgroup.of h)", "start": [767, 1], "end": [770, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Sylow.lean", "imports": ["Mathlib/Data/SetLike/Fintype.lean", "Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/PGroup.lean", "Mathlib/GroupTheory/NoncommPiCoprod.lean", "Mathlib/Order/Atoms/Finite.lean"], "premises": [{"full_name": "Sylow", "code": "structure Sylow extends Subgroup G where\n  isPGroup' : IsPGroup p toSubgroup\n  is_maximal' : \u2200 {Q : Subgroup G}, IsPGroup p Q \u2192 toSubgroup \u2264 Q \u2192 Q = toSubgroup", "start": [52, 1], "end": [55, 83], "kind": "commanddeclaration"}, {"full_name": "Sylow.ext", "code": "@[ext]\ntheorem ext {P Q : Sylow p G} (h : (P : Subgroup G) = Q) : P = Q", "start": [74, 1], "end": [75, 95], "kind": "commanddeclaration"}, {"full_name": "Sylow.ext_iff", "code": "theorem ext_iff {P Q : Sylow p G} : P = Q \u2194 (P : Subgroup G) = Q", "start": [78, 1], "end": [79, 21], "kind": "commanddeclaration"}, {"full_name": "Sylow.mulActionLeft", "code": "instance mulActionLeft {\u03b1 : Type*} [MulAction G \u03b1] : MulAction P \u03b1 :=\n  inferInstanceAs (MulAction (P : Subgroup G) \u03b1)", "start": [93, 1], "end": [95, 49], "kind": "commanddeclaration"}, {"full_name": "Sylow.comapOfKerIsPGroup", "code": "def comapOfKerIsPGroup (h\u03d5 : IsPGroup p \u03d5.ker) (h : \u2191P \u2264 \u03d5.range) : Sylow p K :=\n  { P.1.comap \u03d5 with\n    isPGroup' := P.2.comap_of_ker_isPGroup \u03d5 h\u03d5\n    is_maximal' := fun {Q} hQ hle => by\n      show Q = P.1.comap \u03d5\n      rw [\u2190 P.3 (hQ.map \u03d5) (le_trans (ge_of_eq (map_comap_eq_self h)) (map_mono hle))]\n      exact (comap_map_eq_self ((P.1.ker_le_comap \u03d5).trans hle)).symm }", "start": [100, 1], "end": [107, 72], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_comapOfKerIsPGroup", "code": "@[simp]\ntheorem coe_comapOfKerIsPGroup (h\u03d5 : IsPGroup p \u03d5.ker) (h : \u2191P \u2264 \u03d5.range) :\n    (P.comapOfKerIsPGroup \u03d5 h\u03d5 h : Subgroup K) = Subgroup.comap \u03d5 \u2191P", "start": [110, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.comapOfInjective", "code": "def comapOfInjective (h\u03d5 : Function.Injective \u03d5) (h : \u2191P \u2264 \u03d5.range) : Sylow p K :=\n  P.comapOfKerIsPGroup \u03d5 (IsPGroup.ker_isPGroup_of_injective h\u03d5) h", "start": [116, 1], "end": [118, 67], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_comapOfInjective", "code": "@[simp]\ntheorem coe_comapOfInjective (h\u03d5 : Function.Injective \u03d5) (h : \u2191P \u2264 \u03d5.range) :\n    \u2191(P.comapOfInjective \u03d5 h\u03d5 h) = Subgroup.comap \u03d5 \u2191P", "start": [121, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.subtype", "code": "protected def subtype (h : \u2191P \u2264 N) : Sylow p N :=\n  P.comapOfInjective N.subtype Subtype.coe_injective (by rwa [subtype_range])", "start": [127, 1], "end": [129, 78], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_subtype", "code": "@[simp]\ntheorem coe_subtype (h : \u2191P \u2264 N) : \u2191(P.subtype h) = subgroupOf (\u2191P) N", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.subtype_injective", "code": "theorem subtype_injective {P Q : Sylow p G} {hP : \u2191P \u2264 N} {hQ : \u2191Q \u2264 N}\n    (h : P.subtype hP = Q.subtype hQ) : P = Q", "start": [137, 1], "end": [140, 83], "kind": "commanddeclaration"}, {"full_name": "IsPGroup.exists_le_sylow", "code": "theorem IsPGroup.exists_le_sylow {P : Subgroup G} (hP : IsPGroup p P) : \u2203 Q : Sylow p G, P \u2264 Q", "start": [145, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "Sylow.nonempty", "code": "instance Sylow.nonempty : Nonempty (Sylow p G) :=\n  nonempty_of_exists IsPGroup.of_bot.exists_le_sylow", "start": [164, 1], "end": [165, 53], "kind": "commanddeclaration"}, {"full_name": "Sylow.inhabited", "code": "noncomputable instance Sylow.inhabited : Inhabited (Sylow p G) :=\n  Classical.inhabited_of_nonempty Sylow.nonempty", "start": [168, 1], "end": [169, 49], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_comap_eq_of_ker_isPGroup", "code": "theorem Sylow.exists_comap_eq_of_ker_isPGroup {H : Type*} [Group H] (P : Sylow p H) {f : H \u2192* G}\n    (hf : IsPGroup p f.ker) : \u2203 Q : Sylow p G, (Q : Subgroup G).comap f = P", "start": [172, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_comap_eq_of_injective", "code": "theorem Sylow.exists_comap_eq_of_injective {H : Type*} [Group H] (P : Sylow p H) {f : H \u2192* G}\n    (hf : Function.Injective f) : \u2203 Q : Sylow p G, (Q : Subgroup G).comap f = P", "start": [178, 1], "end": [180, 76], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_comap_subtype_eq", "code": "theorem Sylow.exists_comap_subtype_eq {H : Subgroup G} (P : Sylow p H) :\n    \u2203 Q : Sylow p G, (Q : Subgroup G).comap H.subtype = P", "start": [183, 1], "end": [185, 55], "kind": "commanddeclaration"}, {"full_name": "Sylow.fintypeOfKerIsPGroup", "code": "noncomputable def Sylow.fintypeOfKerIsPGroup {H : Type*} [Group H] {f : H \u2192* G}\n    (hf : IsPGroup p f.ker) [Fintype (Sylow p G)] : Fintype (Sylow p H) :=\n  let h_exists := fun P : Sylow p H => P.exists_comap_eq_of_ker_isPGroup hf\n  let g : Sylow p H \u2192 Sylow p G := fun P => Classical.choose (h_exists P)\n  have hg : \u2200 P : Sylow p H, (g P).1.comap f = P := fun P => Classical.choose_spec (h_exists P)\n  Fintype.ofInjective g fun P Q h => Sylow.ext (by rw [\u2190 hg, h]; exact (h_exists Q).choose_spec)", "start": [188, 1], "end": [195, 97], "kind": "commanddeclaration"}, {"full_name": "Sylow.fintypeOfInjective", "code": "noncomputable def Sylow.fintypeOfInjective {H : Type*} [Group H] {f : H \u2192* G}\n    (hf : Function.Injective f) [Fintype (Sylow p G)] : Fintype (Sylow p H) :=\n  Sylow.fintypeOfKerIsPGroup (IsPGroup.ker_isPGroup_of_injective hf)", "start": [198, 1], "end": [201, 69], "kind": "commanddeclaration"}, {"full_name": "Sylow.pointwiseMulAction", "code": "instance Sylow.pointwiseMulAction {\u03b1 : Type*} [Group \u03b1] [MulDistribMulAction \u03b1 G] :\n    MulAction \u03b1 (Sylow p G) where\n  smul g P :=\n    \u27e8(g \u2022 P.toSubgroup : Subgroup G), P.2.map _, fun {Q} hQ hS =>\n      inv_smul_eq_iff.mp\n        (P.3 (hQ.map _) fun s hs =>\n          (congr_arg (\u00b7 \u2208 g\u207b\u00b9 \u2022 Q) (inv_smul_smul g s)).mp\n            (smul_mem_pointwise_smul (g \u2022 s) g\u207b\u00b9 Q (hS (smul_mem_pointwise_smul s g P hs))))\u27e9\n  one_smul P := Sylow.ext (one_smul \u03b1 P.toSubgroup)\n  mul_smul g h P := Sylow.ext (mul_smul g h P.toSubgroup)", "start": [215, 1], "end": [225, 58], "kind": "commanddeclaration"}, {"full_name": "Sylow.pointwise_smul_def", "code": "theorem Sylow.pointwise_smul_def {\u03b1 : Type*} [Group \u03b1] [MulDistribMulAction \u03b1 G] {g : \u03b1}\n    {P : Sylow p G} : \u2191(g \u2022 P) = g \u2022 (P : Subgroup G)", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.mulAction", "code": "instance Sylow.mulAction : MulAction G (Sylow p G) :=\n  compHom _ MulAut.conj", "start": [233, 1], "end": [234, 24], "kind": "commanddeclaration"}, {"full_name": "Sylow.smul_def", "code": "theorem Sylow.smul_def {g : G} {P : Sylow p G} : g \u2022 P = MulAut.conj g \u2022 P", "start": [237, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_subgroup_smul", "code": "theorem Sylow.coe_subgroup_smul {g : G} {P : Sylow p G} :\n    \u2191(g \u2022 P) = MulAut.conj g \u2022 (P : Subgroup G)", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_smul", "code": "theorem Sylow.coe_smul {g : G} {P : Sylow p G} : \u2191(g \u2022 P) = MulAut.conj g \u2022 (P : Set G)", "start": [246, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.smul_le", "code": "theorem Sylow.smul_le {P : Sylow p G} {H : Subgroup G} (hP : \u2191P \u2264 H) (h : H) : \u2191(h \u2022 P) \u2264 H", "start": [250, 1], "end": [251, 35], "kind": "commanddeclaration"}, {"full_name": "Sylow.smul_subtype", "code": "theorem Sylow.smul_subtype {P : Sylow p G} {H : Subgroup G} (hP : \u2191P \u2264 H) (h : H) :\n    h \u2022 P.subtype hP = (h \u2022 P).subtype (Sylow.smul_le hP h)", "start": [254, 1], "end": [256, 49], "kind": "commanddeclaration"}, {"full_name": "Sylow.smul_eq_iff_mem_normalizer", "code": "theorem Sylow.smul_eq_iff_mem_normalizer {g : G} {P : Sylow p G} :\n    g \u2022 P = P \u2194 g \u2208 (P : Subgroup G).normalizer", "start": [259, 1], "end": [267, 90], "kind": "commanddeclaration"}, {"full_name": "Sylow.smul_eq_of_normal", "code": "theorem Sylow.smul_eq_of_normal {g : G} {P : Sylow p G} [h : (P : Subgroup G).Normal] : g \u2022 P = P", "start": [270, 1], "end": [271, 84], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sylow_mem_fixedPoints_iff", "code": "theorem Subgroup.sylow_mem_fixedPoints_iff (H : Subgroup G) {P : Sylow p G} :\n    P \u2208 fixedPoints H (Sylow p G) \u2194 H \u2264 (P : Subgroup G).normalizer", "start": [274, 1], "end": [276, 85], "kind": "commanddeclaration"}, {"full_name": "IsPGroup.inf_normalizer_sylow", "code": "theorem IsPGroup.inf_normalizer_sylow {P : Subgroup G} (hP : IsPGroup p P) (Q : Sylow p G) :\n    P \u2293 (Q : Subgroup G).normalizer = P \u2293 Q", "start": [279, 1], "end": [285, 38], "kind": "commanddeclaration"}, {"full_name": "IsPGroup.sylow_mem_fixedPoints_iff", "code": "theorem IsPGroup.sylow_mem_fixedPoints_iff {P : Subgroup G} (hP : IsPGroup p P) {Q : Sylow p G} :\n    Q \u2208 fixedPoints P (Sylow p G) \u2194 P \u2264 Q", "start": [288, 1], "end": [290, 88], "kind": "commanddeclaration"}, {"full_name": "card_sylow_modEq_one", "code": "theorem card_sylow_modEq_one [Fact p.Prime] [Fintype (Sylow p G)] :\n    card (Sylow p G) \u2261 1 [MOD p]", "start": [322, 1], "end": [338, 75], "kind": "commanddeclaration"}, {"full_name": "not_dvd_card_sylow", "code": "theorem not_dvd_card_sylow [hp : Fact p.Prime] [Fintype (Sylow p G)] : \u00acp \u2223 card (Sylow p G)", "start": [341, 1], "end": [346, 81], "kind": "commanddeclaration"}, {"full_name": "Sylow.equivSMul", "code": "nonrec def Sylow.equivSMul (P : Sylow p G) (g : G) : P \u2243* (g \u2022 P : Sylow p G) :=\n  equivSMul (MulAut.conj g) P.toSubgroup", "start": [351, 1], "end": [353, 41], "kind": "commanddeclaration"}, {"full_name": "Sylow.equiv", "code": "noncomputable def Sylow.equiv [Fact p.Prime] [Finite (Sylow p G)] (P Q : Sylow p G) : P \u2243* Q := by\n  rw [\u2190 Classical.choose_spec (exists_smul_eq G P Q)]\n  exact P.equivSMul (Classical.choose (exists_smul_eq G P Q))", "start": [356, 1], "end": [359, 62], "kind": "commanddeclaration"}, {"full_name": "Sylow.orbit_eq_top", "code": "@[simp]\ntheorem Sylow.orbit_eq_top [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) : orbit G P = \u22a4", "start": [362, 1], "end": [364, 48], "kind": "commanddeclaration"}, {"full_name": "Sylow.stabilizer_eq_normalizer", "code": "theorem Sylow.stabilizer_eq_normalizer (P : Sylow p G) :\n    stabilizer G P = (P : Subgroup G).normalizer", "start": [367, 1], "end": [369, 47], "kind": "commanddeclaration"}, {"full_name": "Sylow.conj_eq_normalizer_conj_of_mem_centralizer", "code": "theorem Sylow.conj_eq_normalizer_conj_of_mem_centralizer [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) (x g : G) (hx : x \u2208 centralizer (P : Set G))\n    (hy : g\u207b\u00b9 * x * g \u2208 centralizer (P : Set G)) :\n    \u2203 n \u2208 (P : Subgroup G).normalizer, g\u207b\u00b9 * x * g = n\u207b\u00b9 * x * n", "start": [372, 1], "end": [387, 101], "kind": "commanddeclaration"}, {"full_name": "Sylow.conj_eq_normalizer_conj_of_mem", "code": "theorem Sylow.conj_eq_normalizer_conj_of_mem [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    [_hP : (P : Subgroup G).IsCommutative] (x g : G) (hx : x \u2208 P) (hy : g\u207b\u00b9 * x * g \u2208 P) :\n    \u2203 n \u2208 (P : Subgroup G).normalizer, g\u207b\u00b9 * x * g = n\u207b\u00b9 * x * n", "start": [390, 1], "end": [393, 95], "kind": "commanddeclaration"}, {"full_name": "Sylow.equivQuotientNormalizer", "code": "noncomputable def Sylow.equivQuotientNormalizer [Fact p.Prime] [Fintype (Sylow p G)]\n    (P : Sylow p G) : Sylow p G \u2243 G \u29f8 (P : Subgroup G).normalizer :=\n  calc\n    Sylow p G \u2243 (\u22a4 : Set (Sylow p G)) := (Equiv.Set.univ (Sylow p G)).symm\n    _ \u2243 orbit G P := by rw [P.orbit_eq_top]\n    _ \u2243 G \u29f8 stabilizer G P := (orbitEquivQuotientStabilizer G P)\n    _ \u2243 G \u29f8 (P : Subgroup G).normalizer := by rw [P.stabilizer_eq_normalizer]", "start": [396, 1], "end": [403, 78], "kind": "commanddeclaration"}, {"full_name": "card_sylow_eq_card_quotient_normalizer", "code": "theorem card_sylow_eq_card_quotient_normalizer [Fact p.Prime] [Fintype (Sylow p G)]\n    (P : Sylow p G) : card (Sylow p G) = card (G \u29f8 (P : Subgroup G).normalizer)", "start": [411, 1], "end": [413, 39], "kind": "commanddeclaration"}, {"full_name": "card_sylow_eq_index_normalizer", "code": "theorem card_sylow_eq_index_normalizer [Fact p.Prime] [Fintype (Sylow p G)] (P : Sylow p G) :\n    card (Sylow p G) = (P : Subgroup G).normalizer.index", "start": [416, 1], "end": [418, 98], "kind": "commanddeclaration"}, {"full_name": "card_sylow_dvd_index", "code": "theorem card_sylow_dvd_index [Fact p.Prime] [Fintype (Sylow p G)] (P : Sylow p G) :\n    card (Sylow p G) \u2223 (P : Subgroup G).index", "start": [421, 1], "end": [424, 36], "kind": "commanddeclaration"}, {"full_name": "not_dvd_index_sylow'", "code": "theorem not_dvd_index_sylow' [hp : Fact p.Prime] (P : Sylow p G) [(P : Subgroup G).Normal]\n    [fP : FiniteIndex (P : Subgroup G)] : \u00acp \u2223 (P : Subgroup G).index", "start": [427, 1], "end": [443, 30], "kind": "commanddeclaration"}, {"full_name": "not_dvd_index_sylow", "code": "theorem not_dvd_index_sylow [hp : Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (hP : relindex \u2191P (P : Subgroup G).normalizer \u2260 0) : \u00acp \u2223 (P : Subgroup G).index", "start": [446, 1], "end": [454, 53], "kind": "commanddeclaration"}, {"full_name": "Sylow.normalizer_sup_eq_top", "code": "theorem Sylow.normalizer_sup_eq_top {p : \u2115} [Fact p.Prime] {N : Subgroup G} [N.Normal]\n    [Finite (Sylow p N)] (P : Sylow p N) :\n    ((\u2191P : Subgroup N).map N.subtype).normalizer \u2294 N = \u22a4", "start": [457, 1], "end": [474, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.normalizer_sup_eq_top'", "code": "theorem Sylow.normalizer_sup_eq_top' {p : \u2115} [Fact p.Prime] {N : Subgroup G} [N.Normal]\n    [Finite (Sylow p N)] (P : Sylow p G) (hP : \u2191P \u2264 N) : (P : Subgroup G).normalizer \u2294 N = \u22a4", "start": [477, 1], "end": [482, 23], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.card_preimage_mk", "code": "theorem QuotientGroup.card_preimage_mk [Fintype G] (s : Subgroup G) (t : Set (G \u29f8 s)) :\n    Fintype.card (QuotientGroup.mk \u207b\u00b9' t) = Fintype.card s * Fintype.card t", "start": [497, 1], "end": [499, 84], "kind": "commanddeclaration"}, {"full_name": "Sylow.mem_fixedPoints_mul_left_cosets_iff_mem_normalizer", "code": "theorem mem_fixedPoints_mul_left_cosets_iff_mem_normalizer {H : Subgroup G} [Finite (H : Set G)]\n    {x : G} : (x : G \u29f8 H) \u2208 MulAction.fixedPoints H (G \u29f8 H) \u2194 x \u2208 normalizer H", "start": [503, 1], "end": [523, 75], "kind": "commanddeclaration"}, {"full_name": "Sylow.fixedPointsMulLeftCosetsEquivQuotient", "code": "def fixedPointsMulLeftCosetsEquivQuotient (H : Subgroup G) [Finite (H : Set G)] :\n    MulAction.fixedPoints H (G \u29f8 H) \u2243\n      normalizer H \u29f8 Subgroup.comap ((normalizer H).subtype : normalizer H \u2192* G) H :=\n  @subtypeQuotientEquivQuotientSubtype G (normalizer H : Set G) (_) (_)\n    (MulAction.fixedPoints H (G \u29f8 H))\n    (fun a => (@mem_fixedPoints_mul_left_cosets_iff_mem_normalizer _ _ _ \u2039_\u203a _).symm)\n    (by\n      intros\n      dsimp only [instHasEquiv]\n      rw [leftRel_apply (\u03b1 := normalizer H), leftRel_apply]\n      rfl)", "start": [526, 1], "end": [537, 11], "kind": "commanddeclaration"}, {"full_name": "Sylow.card_quotient_normalizer_modEq_card_quotient", "code": "theorem card_quotient_normalizer_modEq_card_quotient [Fintype G] {p : \u2115} {n : \u2115} [hp : Fact p.Prime]\n    {H : Subgroup G} (hH : Fintype.card H = p ^ n) :\n    Fintype.card (normalizer H \u29f8 Subgroup.comap ((normalizer H).subtype : normalizer H \u2192* G) H) \u2261\n      card (G \u29f8 H) [MOD p]", "start": [540, 1], "end": [547, 67], "kind": "commanddeclaration"}, {"full_name": "Sylow.card_normalizer_modEq_card", "code": "theorem card_normalizer_modEq_card [Fintype G] {p : \u2115} {n : \u2115} [hp : Fact p.Prime] {H : Subgroup G}\n    (hH : Fintype.card H = p ^ n) : card (normalizer H) \u2261 card G [MOD p ^ (n + 1)]", "start": [550, 1], "end": [558, 71], "kind": "commanddeclaration"}, {"full_name": "Sylow.prime_dvd_card_quotient_normalizer", "code": "theorem prime_dvd_card_quotient_normalizer [Fintype G] {p : \u2115} {n : \u2115} [hp : Fact p.Prime]\n    (hdvd : p ^ (n + 1) \u2223 card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :\n    p \u2223 card (normalizer H \u29f8 Subgroup.comap ((normalizer H).subtype : normalizer H \u2192* G) H)", "start": [561, 1], "end": [575, 93], "kind": "commanddeclaration"}, {"full_name": "Sylow.prime_pow_dvd_card_normalizer", "code": "theorem prime_pow_dvd_card_normalizer [Fintype G] {p : \u2115} {n : \u2115} [_hp : Fact p.Prime]\n    (hdvd : p ^ (n + 1) \u2223 card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :\n    p ^ (n + 1) \u2223 card (normalizer H)", "start": [578, 1], "end": [583, 87], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_subgroup_card_pow_succ", "code": "theorem exists_subgroup_card_pow_succ [Fintype G] {p : \u2115} {n : \u2115} [hp : Fact p.Prime]\n    (hdvd : p ^ (n + 1) \u2223 card G) {H : Subgroup G} (hH : Fintype.card H = p ^ n) :\n    \u2203 K : Subgroup G, Fintype.card K = p ^ (n + 1) \u2227 H \u2264 K", "start": [586, 1], "end": [624, 20], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_subgroup_card_pow_prime_le", "code": "theorem exists_subgroup_card_pow_prime_le [Fintype G] (p : \u2115) :\n    \u2200 {n m : \u2115} [_hp : Fact p.Prime] (_hdvd : p ^ m \u2223 card G) (H : Subgroup G)\n      (_hH : card H = p ^ n) (_hnm : n \u2264 m), \u2203 K : Subgroup G, card K = p ^ m \u2227 H \u2264 K", "start": [627, 1], "end": [645, 48], "kind": "commanddeclaration"}, {"full_name": "Sylow.exists_subgroup_card_pow_prime", "code": "theorem exists_subgroup_card_pow_prime [Fintype G] (p : \u2115) {n : \u2115} [Fact p.Prime]\n    (hdvd : p ^ n \u2223 card G) : \u2203 K : Subgroup G, Fintype.card K = p ^ n", "start": [648, 1], "end": [653, 12], "kind": "commanddeclaration"}, {"full_name": "Sylow.pow_dvd_card_of_pow_dvd_card", "code": "theorem pow_dvd_card_of_pow_dvd_card [Fintype G] {p n : \u2115} [hp : Fact p.Prime] (P : Sylow p G)\n    (hdvd : p ^ n \u2223 card G) : p ^ n \u2223 card P", "start": [656, 1], "end": [660, 39], "kind": "commanddeclaration"}, {"full_name": "Sylow.dvd_card_of_dvd_card", "code": "theorem dvd_card_of_dvd_card [Fintype G] {p : \u2115} [Fact p.Prime] (P : Sylow p G)\n    (hdvd : p \u2223 card G) : p \u2223 card P", "start": [663, 1], "end": [667, 23], "kind": "commanddeclaration"}, {"full_name": "Sylow.card_coprime_index", "code": "theorem card_coprime_index [Fintype G] {p : \u2115} [hp : Fact p.Prime] (P : Sylow p G) :\n    (card P).Coprime (index (P : Subgroup G))", "start": [670, 1], "end": [674, 95], "kind": "commanddeclaration"}, {"full_name": "Sylow.ne_bot_of_dvd_card", "code": "theorem ne_bot_of_dvd_card [Fintype G] {p : \u2115} [hp : Fact p.Prime] (P : Sylow p G)\n    (hdvd : p \u2223 card G) : (P : Subgroup G) \u2260 \u22a5", "start": [677, 1], "end": [681, 27], "kind": "commanddeclaration"}, {"full_name": "Sylow.card_eq_multiplicity", "code": "theorem card_eq_multiplicity [Fintype G] {p : \u2115} [hp : Fact p.Prime] (P : Sylow p G) :\n    card P = p ^ Nat.factorization (card G) p", "start": [684, 1], "end": [691, 35], "kind": "commanddeclaration"}, {"full_name": "Sylow.ofCard", "code": "def ofCard [Fintype G] {p : \u2115} [Fact p.Prime] (H : Subgroup G) [Fintype H]\n    (card_eq : card H = p ^ (card G).factorization p) : Sylow p G\n    where\n  toSubgroup := H\n  isPGroup' := IsPGroup.of_card card_eq\n  is_maximal' := by\n    obtain \u27e8P, hHP\u27e9 := (IsPGroup.of_card card_eq).exists_le_sylow\n    exact SetLike.ext'\n      (Set.eq_of_subset_of_card_le hHP (P.card_eq_multiplicity.trans card_eq.symm).le).symm \u25b8 P.3", "start": [694, 1], "end": [704, 98], "kind": "commanddeclaration"}, {"full_name": "Sylow.coe_ofCard", "code": "@[simp, norm_cast]\ntheorem coe_ofCard [Fintype G] {p : \u2115} [Fact p.Prime] (H : Subgroup G) [Fintype H]\n    (card_eq : card H = p ^ (card G).factorization p) : \u2191(ofCard H card_eq) = H", "start": [707, 1], "end": [710, 6], "kind": "commanddeclaration"}, {"full_name": "Sylow.subsingleton_of_normal", "code": "theorem subsingleton_of_normal {p : \u2115} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (h : (P : Subgroup G).Normal) : Subsingleton (Sylow p G)", "start": [713, 1], "end": [720, 18], "kind": "commanddeclaration"}, {"full_name": "Sylow.characteristic_of_normal", "code": "theorem characteristic_of_normal {p : \u2115} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (h : (P : Subgroup G).Normal) : (P : Subgroup G).Characteristic", "start": [727, 1], "end": [734, 7], "kind": "commanddeclaration"}, {"full_name": "Sylow.normal_of_normalizer_normal", "code": "theorem normal_of_normalizer_normal {p : \u2115} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G)\n    (hn : (\u2191P : Subgroup G).normalizer.Normal) : (\u2191P : Subgroup G).Normal", "start": [739, 1], "end": [741, 79], "kind": "commanddeclaration"}, {"full_name": "Sylow.normalizer_normalizer", "code": "@[simp]\ntheorem normalizer_normalizer {p : \u2115} [Fact p.Prime] [Finite (Sylow p G)] (P : Sylow p G) :\n    (\u2191P : Subgroup G).normalizer.normalizer = (\u2191P : Subgroup G).normalizer", "start": [744, 1], "end": [752, 77], "kind": "commanddeclaration"}, {"full_name": "Sylow.normal_of_all_max_subgroups_normal", "code": "theorem normal_of_all_max_subgroups_normal [Finite G]\n    (hnc : \u2200 H : Subgroup G, IsCoatom H \u2192 H.Normal) {p : \u2115} [Fact p.Prime] [Finite (Sylow p G)]\n    (P : Sylow p G) : (\u2191P : Subgroup G).Normal", "start": [755, 1], "end": [765, 66], "kind": "commanddeclaration"}, {"full_name": "Sylow.normal_of_normalizerCondition", "code": "theorem normal_of_normalizerCondition (hnc : NormalizerCondition G) {p : \u2115} [Fact p.Prime]\n    [Finite (Sylow p G)] (P : Sylow p G) : (\u2191P : Subgroup G).Normal", "start": [768, 1], "end": [771, 97], "kind": "commanddeclaration"}, {"full_name": "Sylow.directProductOfNormal", "code": "noncomputable def directProductOfNormal [Fintype G]\n    (hn : \u2200 {p : \u2115} [Fact p.Prime] (P : Sylow p G), (\u2191P : Subgroup G).Normal) :\n    (\u2200 p : (card G).factorization.support, \u2200 P : Sylow p G, (\u2191P : Subgroup G)) \u2243* G := by\n  set ps := (Fintype.card G).factorization.support\n  let P : \u2200 p, Sylow p G := default\n  have hcomm : Pairwise fun p\u2081 p\u2082 : ps => \u2200 x y : G, x \u2208 P p\u2081 \u2192 y \u2208 P p\u2082 \u2192 Commute x y := by\n    rintro \u27e8p\u2081, hp\u2081\u27e9 \u27e8p\u2082, hp\u2082\u27e9 hne\n    haveI hp\u2081' := Fact.mk (Nat.prime_of_mem_factorization hp\u2081)\n    haveI hp\u2082' := Fact.mk (Nat.prime_of_mem_factorization hp\u2082)\n    have hne' : p\u2081 \u2260 p\u2082 := by simpa using hne\n    apply Subgroup.commute_of_normal_of_disjoint _ _ (hn (P p\u2081)) (hn (P p\u2082))\n    apply IsPGroup.disjoint_of_ne p\u2081 p\u2082 hne' _ _ (P p\u2081).isPGroup' (P p\u2082).isPGroup'\n  refine' MulEquiv.trans (N := \u2200 p : ps, P p) _ _\n  show (\u2200 p : ps, \u2200 P : Sylow p G, P) \u2243* \u2200 p : ps, P p\n  \u00b7 apply @MulEquiv.piCongrRight ps (fun p => \u2200 P : Sylow p G, P) (fun p => P p) _ _\n    rintro \u27e8p, hp\u27e9\n    haveI hp' := Fact.mk (Nat.prime_of_mem_factorization hp)\n    haveI := subsingleton_of_normal _ (hn (P p))\n    change (\u2200 P : Sylow p G, P) \u2243* P p\n    exact MulEquiv.piSubsingleton _ _\n  show (\u2200 p : ps, P p) \u2243* G\n  apply MulEquiv.ofBijective (Subgroup.noncommPiCoprod hcomm)\n  apply (bijective_iff_injective_and_card _).mpr\n  constructor\n  show Injective _\n  \u00b7 apply Subgroup.injective_noncommPiCoprod_of_independent\n    apply independent_of_coprime_order hcomm\n    rintro \u27e8p\u2081, hp\u2081\u27e9 \u27e8p\u2082, hp\u2082\u27e9 hne\n    haveI hp\u2081' := Fact.mk (Nat.prime_of_mem_factorization hp\u2081)\n    haveI hp\u2082' := Fact.mk (Nat.prime_of_mem_factorization hp\u2082)\n    have hne' : p\u2081 \u2260 p\u2082 := by simpa using hne\n    apply IsPGroup.coprime_card_of_ne p\u2081 p\u2082 hne' _ _ (P p\u2081).isPGroup' (P p\u2082).isPGroup'\n  show card (\u2200 p : ps, P p) = card G\n  \u00b7 calc\n      card (\u2200 p : ps, P p) = \u220f p : ps, card (P p) := Fintype.card_pi\n      _ = \u220f p : ps, p.1 ^ (card G).factorization p.1 := by\n        congr 1 with \u27e8p, hp\u27e9\n        exact @card_eq_multiplicity _ _ _ p \u27e8Nat.prime_of_mem_factorization hp\u27e9 (P p)\n      _ = \u220f p in ps, p ^ (card G).factorization p :=\n        (Finset.prod_finset_coe (fun p => p ^ (card G).factorization p) _)\n      _ = (card G).factorization.prod (\u00b7 ^ \u00b7) := rfl\n      _ = card G := Nat.factorization_prod_pow_eq_self Fintype.card_ne_zero", "start": [776, 1], "end": [823, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Complement.lean", "imports": ["Mathlib/Data/ZMod/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.IsComplement", "code": "@[to_additive \"`S` and `T` are complements if `(+) : S \u00d7 T \u2192 G` is a bijection\"]\ndef IsComplement : Prop :=\n  Function.Bijective fun x : S \u00d7 T => x.1.1 * x.2.1", "start": [38, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'", "code": "@[to_additive \"`H` and `K` are complements if `(+) : H \u00d7 K \u2192 G` is a bijection\"]\nabbrev IsComplement' :=\n  IsComplement (H : Set G) (K : Set G)", "start": [46, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftTransversals", "code": "@[to_additive \"The set of left-complements of `T : Set G`\"]\ndef leftTransversals : Set (Set G) :=\n  { S : Set G | IsComplement S T }", "start": [53, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rightTransversals", "code": "@[to_additive \"The set of right-complements of `S : Set G`\"]\ndef rightTransversals : Set (Set G) :=\n  { T : Set G | IsComplement S T }", "start": [60, 1], "end": [63, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_def", "code": "@[to_additive]\ntheorem isComplement'_def : IsComplement' H K \u2194 IsComplement (H : Set G) (K : Set G)", "start": [69, 1], "end": [71, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_iff_existsUnique", "code": "@[to_additive]\ntheorem isComplement_iff_existsUnique :\n    IsComplement S T \u2194 \u2200 g : G, \u2203! x : S \u00d7 T, x.1.1 * x.2.1 = g", "start": [75, 1], "end": [78, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.existsUnique", "code": "@[to_additive]\ntheorem IsComplement.existsUnique (h : IsComplement S T) (g : G) :\n    \u2203! x : S \u00d7 T, x.1.1 * x.2.1 = g", "start": [82, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.symm", "code": "@[to_additive]\ntheorem IsComplement'.symm (h : IsComplement' H K) : IsComplement' K H", "start": [89, 1], "end": [99, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_comm", "code": "@[to_additive]\ntheorem isComplement'_comm : IsComplement' H K \u2194 IsComplement' K H", "start": [103, 1], "end": [105, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_top_singleton", "code": "@[to_additive]\ntheorem isComplement_top_singleton {g : G} : IsComplement (\u22a4 : Set G) {g}", "start": [109, 1], "end": [112, 57], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_singleton_top", "code": "@[to_additive]\ntheorem isComplement_singleton_top {g : G} : IsComplement ({g} : Set G) \u22a4", "start": [116, 1], "end": [119, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_singleton_left", "code": "@[to_additive]\ntheorem isComplement_singleton_left {g : G} : IsComplement {g} S \u2194 S = \u22a4", "start": [123, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_singleton_right", "code": "@[to_additive]\ntheorem isComplement_singleton_right {g : G} : IsComplement S {g} \u2194 S = \u22a4", "start": [132, 1], "end": [139, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_top_left", "code": "@[to_additive]\ntheorem isComplement_top_left : IsComplement \u22a4 S \u2194 \u2203 g : G, S = {g}", "start": [143, 1], "end": [153, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement_top_right", "code": "@[to_additive]\ntheorem isComplement_top_right : IsComplement S \u22a4 \u2194 \u2203 g : G, S = {g}", "start": [157, 1], "end": [167, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_top_bot", "code": "@[to_additive]\ntheorem isComplement'_top_bot : IsComplement' (\u22a4 : Subgroup G) \u22a5", "start": [171, 1], "end": [173, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_bot_top", "code": "@[to_additive]\ntheorem isComplement'_bot_top : IsComplement' (\u22a5 : Subgroup G) \u22a4", "start": [177, 1], "end": [179, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_bot_left", "code": "@[to_additive (attr := simp)]\ntheorem isComplement'_bot_left : IsComplement' \u22a5 H \u2194 H = \u22a4", "start": [183, 1], "end": [185, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_bot_right", "code": "@[to_additive (attr := simp)]\ntheorem isComplement'_bot_right : IsComplement' H \u22a5 \u2194 H = \u22a4", "start": [189, 1], "end": [191, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_top_left", "code": "@[to_additive (attr := simp)]\ntheorem isComplement'_top_left : IsComplement' \u22a4 H \u2194 H = \u22a5", "start": [195, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_top_right", "code": "@[to_additive (attr := simp)]\ntheorem isComplement'_top_right : IsComplement' H \u22a4 \u2194 H = \u22a5", "start": [201, 1], "end": [203, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_leftTransversals_iff_existsUnique_inv_mul_mem", "code": "@[to_additive]\ntheorem mem_leftTransversals_iff_existsUnique_inv_mul_mem :\n    S \u2208 leftTransversals T \u2194 \u2200 g : G, \u2203! s : S, (s : G)\u207b\u00b9 * g \u2208 T", "start": [207, 1], "end": [219, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_rightTransversals_iff_existsUnique_mul_inv_mem", "code": "@[to_additive]\ntheorem mem_rightTransversals_iff_existsUnique_mul_inv_mem :\n    S \u2208 rightTransversals T \u2194 \u2200 g : G, \u2203! s : S, g * (s : G)\u207b\u00b9 \u2208 T", "start": [223, 1], "end": [235, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_leftTransversals_iff_existsUnique_quotient_mk''_eq", "code": "@[to_additive]\ntheorem mem_leftTransversals_iff_existsUnique_quotient_mk''_eq :\n    S \u2208 leftTransversals (H : Set G) \u2194\n      \u2200 q : Quotient (QuotientGroup.leftRel H), \u2203! s : S, Quotient.mk'' s.1 = q", "start": [239, 1], "end": [245, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_rightTransversals_iff_existsUnique_quotient_mk''_eq", "code": "@[to_additive]\ntheorem mem_rightTransversals_iff_existsUnique_quotient_mk''_eq :\n    S \u2208 rightTransversals (H : Set G) \u2194\n      \u2200 q : Quotient (QuotientGroup.rightRel H), \u2203! s : S, Quotient.mk'' s.1 = q", "start": [249, 1], "end": [255, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_leftTransversals_iff_bijective", "code": "@[to_additive]\ntheorem mem_leftTransversals_iff_bijective :\n    S \u2208 leftTransversals (H : Set G) \u2194\n      Function.Bijective (S.restrict (Quotient.mk'' : G \u2192 Quotient (QuotientGroup.leftRel H)))", "start": [259, 1], "end": [264, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_rightTransversals_iff_bijective", "code": "@[to_additive]\ntheorem mem_rightTransversals_iff_bijective :\n    S \u2208 rightTransversals (H : Set G) \u2194\n      Function.Bijective (S.restrict (Quotient.mk'' : G \u2192 Quotient (QuotientGroup.rightRel H)))", "start": [268, 1], "end": [273, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_left_transversal", "code": "@[to_additive]\ntheorem card_left_transversal (h : S \u2208 leftTransversals (H : Set G)) : Nat.card S = H.index", "start": [277, 1], "end": [279, 83], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_right_transversal", "code": "@[to_additive]\ntheorem card_right_transversal (h : S \u2208 rightTransversals (H : Set G)) : Nat.card S = H.index", "start": [283, 1], "end": [287, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.range_mem_leftTransversals", "code": "@[to_additive]\ntheorem range_mem_leftTransversals {f : G \u29f8 H \u2192 G} (hf : \u2200 q, \u2191(f q) = q) :\n    Set.range f \u2208 leftTransversals (H : Set G)", "start": [291, 1], "end": [297, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.range_mem_rightTransversals", "code": "@[to_additive]\ntheorem range_mem_rightTransversals {f : Quotient (QuotientGroup.rightRel H) \u2192 G}\n    (hf : \u2200 q, Quotient.mk'' (f q) = q) : Set.range f \u2208 rightTransversals (H : Set G)", "start": [301, 1], "end": [307, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_left_transversal", "code": "@[to_additive]\ntheorem exists_left_transversal (g : G) : \u2203 S \u2208 leftTransversals (H : Set G), g \u2208 S", "start": [311, 1], "end": [320, 15], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_right_transversal", "code": "@[to_additive]\ntheorem exists_right_transversal (g : G) : \u2203 S \u2208 rightTransversals (H : Set G), g \u2208 S", "start": [324, 1], "end": [332, 88], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv", "code": "noncomputable def equiv {S T : Set G} (hST : IsComplement S T) : G \u2243 S \u00d7 T :=\n  (Equiv.ofBijective (fun x : S \u00d7 T => x.1.1 * x.2.1) hST).symm", "start": [338, 1], "end": [340, 64], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_symm_apply", "code": "@[simp] theorem equiv_symm_apply (x : S \u00d7 T) : (hST.equiv.symm x : G) = x.1.1 * x.2.1", "start": [344, 1], "end": [344, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_mul_equiv_snd", "code": "@[simp]\ntheorem equiv_fst_mul_equiv_snd (g : G) : \u2191(hST.equiv g).fst * (hST.equiv g).snd = g", "start": [346, 1], "end": [348, 71], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_eq_mul_inv", "code": "theorem equiv_fst_eq_mul_inv (g : G) : \u2191(hST.equiv g).fst = g * ((hST.equiv g).snd : G)\u207b\u00b9", "start": [350, 1], "end": [351, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_snd_eq_inv_mul", "code": "theorem equiv_snd_eq_inv_mul (g : G) : \u2191(hST.equiv g).snd = ((hST.equiv g).fst : G)\u207b\u00b9 * g", "start": [353, 1], "end": [354, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_eq_iff_leftCosetEquivalence", "code": "theorem equiv_fst_eq_iff_leftCosetEquivalence {g\u2081 g\u2082 : G} :\n    (hSK.equiv g\u2081).fst = (hSK.equiv g\u2082).fst \u2194 LeftCosetEquivalence K g\u2081 g\u2082", "start": [356, 1], "end": [370, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_snd_eq_iff_rightCosetEquivalence", "code": "theorem equiv_snd_eq_iff_rightCosetEquivalence {g\u2081 g\u2082 : G} :\n    (hHT.equiv g\u2081).snd = (hHT.equiv g\u2082).snd \u2194 RightCosetEquivalence H g\u2081 g\u2082", "start": [372, 1], "end": [386, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.leftCosetEquivalence_equiv_fst", "code": "theorem leftCosetEquivalence_equiv_fst (g : G) :\n    LeftCosetEquivalence K g ((hSK.equiv g).fst : G)", "start": [388, 1], "end": [391, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.rightCosetEquivalence_equiv_snd", "code": "theorem rightCosetEquivalence_equiv_snd (g : G) :\n    RightCosetEquivalence H g ((hHT.equiv g).snd : G)", "start": [393, 1], "end": [396, 76], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_eq_self_of_mem_of_one_mem", "code": "theorem equiv_fst_eq_self_of_mem_of_one_mem {g : G} (h1 : 1 \u2208 T) (hg : g \u2208 S) :\n    (hST.equiv g).fst = \u27e8g, hg\u27e9", "start": [398, 1], "end": [402, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_snd_eq_self_of_mem_of_one_mem", "code": "theorem equiv_snd_eq_self_of_mem_of_one_mem {g : G} (h1 : 1 \u2208 S) (hg : g \u2208 T) :\n    (hST.equiv g).snd = \u27e8g, hg\u27e9", "start": [404, 1], "end": [408, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_snd_eq_one_of_mem_of_one_mem", "code": "theorem equiv_snd_eq_one_of_mem_of_one_mem {g : G} (h1 : 1 \u2208 T) (hg : g \u2208 S) :\n    (hST.equiv g).snd = \u27e81, h1\u27e9", "start": [410, 1], "end": [413, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_eq_one_of_mem_of_one_mem", "code": "theorem equiv_fst_eq_one_of_mem_of_one_mem {g : G} (h1 : 1 \u2208 S) (hg : g \u2208 T) :\n    (hST.equiv g).fst = \u27e81, h1\u27e9", "start": [415, 1], "end": [418, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_mul_right", "code": "@[simp, nolint simpNF]\ntheorem equiv_mul_right (g : G) (k : K) :\n    hSK.equiv (g * k) = ((hSK.equiv g).fst, (hSK.equiv g).snd * k)", "start": [421, 1], "end": [429, 78], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_mul_right_of_mem", "code": "theorem equiv_mul_right_of_mem {g k : G} (h : k \u2208 K) :\n    hSK.equiv (g * k) = ((hSK.equiv g).fst, (hSK.equiv g).snd * \u27e8k, h\u27e9)", "start": [431, 1], "end": [433, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_mul_left", "code": "@[simp, nolint simpNF]\ntheorem equiv_mul_left (h : H) (g : G) :\n    hHT.equiv (h * g) = (h * (hHT.equiv g).fst, (hHT.equiv g).snd)", "start": [436, 1], "end": [444, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_mul_left_of_mem", "code": "theorem equiv_mul_left_of_mem {h g : G} (hh : h \u2208 H) :\n    hHT.equiv (h * g) = (\u27e8h, hh\u27e9 * (hHT.equiv g).fst, (hHT.equiv g).snd)", "start": [446, 1], "end": [448, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_one", "code": "theorem equiv_one (hs1 : 1 \u2208 S) (ht1 : 1 \u2208 T) :\n    hST.equiv 1 = (\u27e81, hs1\u27e9, \u27e81, ht1\u27e9)", "start": [450, 1], "end": [452, 54], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_fst_eq_self_iff_mem", "code": "theorem equiv_fst_eq_self_iff_mem {g : G} (h1 : 1 \u2208 T) :\n    ((hST.equiv g).fst : G) = g \u2194 g \u2208 S", "start": [454, 1], "end": [461, 54], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.equiv_snd_eq_self_iff_mem", "code": "theorem equiv_snd_eq_self_iff_mem {g : G} (h1 : 1 \u2208 S) :\n    ((hST.equiv g).snd : G) = g \u2194 g \u2208 T", "start": [463, 1], "end": [470, 54], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.coe_equiv_fst_eq_one_iff_mem", "code": "theorem coe_equiv_fst_eq_one_iff_mem {g : G} (h1 : 1 \u2208 S) :\n    ((hST.equiv g).fst : G) = 1 \u2194 g \u2208 T", "start": [472, 1], "end": [474, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.coe_equiv_snd_eq_one_iff_mem", "code": "theorem coe_equiv_snd_eq_one_iff_mem {g : G} (h1 : 1 \u2208 T) :\n    ((hST.equiv g).snd : G) = 1 \u2194 g \u2208 S", "start": [476, 1], "end": [478, 76], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.toEquiv", "code": "@[to_additive \"A left transversal is in bijection with left cosets.\"]\nnoncomputable def toEquiv (hS : S \u2208 Subgroup.leftTransversals (H : Set G)) : G \u29f8 H \u2243 S :=\n  (Equiv.ofBijective _ (Subgroup.mem_leftTransversals_iff_bijective.mp hS)).symm", "start": [484, 1], "end": [487, 81], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.mk''_toEquiv", "code": "@[to_additive]\ntheorem mk''_toEquiv (hS : S \u2208 Subgroup.leftTransversals (H : Set G)) (q : G \u29f8 H) :\n    Quotient.mk'' (toEquiv hS q : G) = q", "start": [491, 1], "end": [494, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.toEquiv_apply", "code": "@[to_additive]\ntheorem toEquiv_apply {f : G \u29f8 H \u2192 G} (hf : \u2200 q, (f q : G \u29f8 H) = q) (q : G \u29f8 H) :\n    (toEquiv (range_mem_leftTransversals hf) q : G) = f q", "start": [498, 1], "end": [502, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.toFun", "code": "@[to_additive \"A left transversal can be viewed as a function mapping each element of the group\n  to the chosen representative from that left coset.\"]\nnoncomputable def toFun (hS : S \u2208 Subgroup.leftTransversals (H : Set G)) : G \u2192 S :=\n  toEquiv hS \u2218 Quotient.mk''", "start": [506, 1], "end": [511, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.inv_toFun_mul_mem", "code": "@[to_additive]\ntheorem inv_toFun_mul_mem (hS : S \u2208 Subgroup.leftTransversals (H : Set G)) (g : G) :\n    (toFun hS g : G)\u207b\u00b9 * g \u2208 H", "start": [515, 1], "end": [518, 72], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemLeftTransversals.inv_mul_toFun_mem", "code": "@[to_additive]\ntheorem inv_mul_toFun_mem (hS : S \u2208 Subgroup.leftTransversals (H : Set G)) (g : G) :\n    g\u207b\u00b9 * toFun hS g \u2208 H", "start": [522, 1], "end": [525, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.toEquiv", "code": "@[to_additive \"A right transversal is in bijection with right cosets.\"]\nnoncomputable def toEquiv (hS : S \u2208 Subgroup.rightTransversals (H : Set G)) :\n    Quotient (QuotientGroup.rightRel H) \u2243 S :=\n  (Equiv.ofBijective _ (Subgroup.mem_rightTransversals_iff_bijective.mp hS)).symm", "start": [533, 1], "end": [537, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.mk''_toEquiv", "code": "@[to_additive]\ntheorem mk''_toEquiv (hS : S \u2208 Subgroup.rightTransversals (H : Set G))\n    (q : Quotient (QuotientGroup.rightRel H)) : Quotient.mk'' (toEquiv hS q : G) = q", "start": [541, 1], "end": [544, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.toEquiv_apply", "code": "@[to_additive]\ntheorem toEquiv_apply {f : Quotient (QuotientGroup.rightRel H) \u2192 G}\n    (hf : \u2200 q, Quotient.mk'' (f q) = q) (q : Quotient (QuotientGroup.rightRel H)) :\n    (toEquiv (range_mem_rightTransversals hf) q : G) = f q", "start": [548, 1], "end": [553, 94], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.toFun", "code": "@[to_additive \"A right transversal can be viewed as a function mapping each element of the group\n  to the chosen representative from that right coset.\"]\nnoncomputable def toFun (hS : S \u2208 Subgroup.rightTransversals (H : Set G)) : G \u2192 S :=\n  toEquiv hS \u2218 Quotient.mk''", "start": [557, 1], "end": [562, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.mul_inv_toFun_mem", "code": "@[to_additive]\ntheorem mul_inv_toFun_mem (hS : S \u2208 Subgroup.rightTransversals (H : Set G)) (g : G) :\n    g * (toFun hS g : G)\u207b\u00b9 \u2208 H", "start": [566, 1], "end": [569, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.MemRightTransversals.toFun_mul_inv_mem", "code": "@[to_additive]\ntheorem toFun_mul_inv_mem (hS : S \u2208 Subgroup.rightTransversals (H : Set G)) (g : G) :\n    (toFun hS g : G) * g\u207b\u00b9 \u2208 H", "start": [573, 1], "end": [576, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_toFun", "code": "@[to_additive]\ntheorem smul_toFun (f : F) (T : leftTransversals (H : Set G)) (g : G) :\n    (f \u2022 (toFun T.2 g : G)) = toFun (f \u2022 T).2 (f \u2022 g)", "start": [603, 1], "end": [609, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_toEquiv", "code": "@[to_additive]\ntheorem smul_toEquiv (f : F) (T : leftTransversals (H : Set G)) (q : G \u29f8 H) :\n    f \u2022 (toEquiv T.2 q : G) = toEquiv (f \u2022 T).2 (f \u2022 q)", "start": [613, 1], "end": [616, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_apply_eq_smul_apply_inv_smul", "code": "@[to_additive]\ntheorem smul_apply_eq_smul_apply_inv_smul (f : F) (T : leftTransversals (H : Set G)) (q : G \u29f8 H) :\n    (toEquiv (f \u2022 T).2 q : G) = f \u2022 (toEquiv T.2 (f\u207b\u00b9 \u2022 q) : G)", "start": [620, 1], "end": [623, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.isCompl", "code": "theorem IsComplement'.isCompl (h : IsComplement' H K) : IsCompl H K", "start": [637, 1], "end": [646, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.sup_eq_top", "code": "theorem IsComplement'.sup_eq_top (h : IsComplement' H K) : H \u2294 K = \u22a4", "start": [649, 1], "end": [650, 23], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.disjoint", "code": "theorem IsComplement'.disjoint (h : IsComplement' H K) : Disjoint H K", "start": [653, 1], "end": [654, 21], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.index_eq_card", "code": "theorem IsComplement'.index_eq_card (h : IsComplement' H K) : K.index = Nat.card H", "start": [657, 1], "end": [658, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement.card_mul", "code": "theorem IsComplement.card_mul [Fintype G] [Fintype S] [Fintype T] (h : IsComplement S T) :\n    Fintype.card S * Fintype.card T = Fintype.card G", "start": [661, 1], "end": [663, 67], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsComplement'.card_mul", "code": "theorem IsComplement'.card_mul [Fintype G] [Fintype H] [Fintype K] (h : IsComplement' H K) :\n    Fintype.card H * Fintype.card K = Fintype.card G", "start": [666, 1], "end": [668, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_of_disjoint_and_mul_eq_univ", "code": "theorem isComplement'_of_disjoint_and_mul_eq_univ (h1 : Disjoint H K)\n    (h2 : \u2191H * \u2191K = (Set.univ : Set G)) : IsComplement' H K", "start": [671, 1], "end": [675, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_of_card_mul_and_disjoint", "code": "theorem isComplement'_of_card_mul_and_disjoint [Fintype G] [Fintype H] [Fintype K]\n    (h1 : Fintype.card H * Fintype.card K = Fintype.card G) (h2 : Disjoint H K) :\n    IsComplement' H K", "start": [678, 1], "end": [682, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_iff_card_mul_and_disjoint", "code": "theorem isComplement'_iff_card_mul_and_disjoint [Fintype G] [Fintype H] [Fintype K] :\n    IsComplement' H K \u2194 Fintype.card H * Fintype.card K = Fintype.card G \u2227 Disjoint H K", "start": [685, 1], "end": [687, 95], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_of_coprime", "code": "theorem isComplement'_of_coprime [Fintype G] [Fintype H] [Fintype K]\n    (h1 : Fintype.card H * Fintype.card K = Fintype.card G)\n    (h2 : Nat.Coprime (Fintype.card H) (Fintype.card K)) : IsComplement' H K", "start": [690, 1], "end": [693, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isComplement'_stabilizer", "code": "theorem isComplement'_stabilizer {\u03b1 : Type*} [MulAction G \u03b1] (a : \u03b1)\n    (h1 : \u2200 h : H, h \u2022 a = a \u2192 h = 1) (h2 : \u2200 g : G, \u2203 h : H, h \u2022 g \u2022 a = a) :\n    IsComplement' H (MulAction.stabilizer G a)", "start": [696, 1], "end": [706, 92], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivSigmaZMod", "code": "noncomputable def quotientEquivSigmaZMod :\n    G \u29f8 H \u2243 \u03a3q : orbitRel.Quotient (zpowers g) (G \u29f8 H), ZMod (minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out') :=\n  (selfEquivSigmaOrbits (zpowers g) (G \u29f8 H)).trans\n    (sigmaCongrRight fun q => orbitZpowersEquiv g q.out')", "start": [719, 1], "end": [723, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivSigmaZMod_symm_apply", "code": "theorem quotientEquivSigmaZMod_symm_apply (q : orbitRel.Quotient (zpowers g) (G \u29f8 H))\n    (k : ZMod (minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out')) :\n    (quotientEquivSigmaZMod H g).symm \u27e8q, k\u27e9 = g ^ (k : \u2124) \u2022 q.out'", "start": [726, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivSigmaZMod_apply", "code": "theorem quotientEquivSigmaZMod_apply (q : orbitRel.Quotient (zpowers g) (G \u29f8 H)) (k : \u2124) :\n    quotientEquivSigmaZMod H g (g ^ k \u2022 q.out') = \u27e8q, k\u27e9", "start": [732, 1], "end": [735, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferFunction", "code": "noncomputable def transferFunction : G \u29f8 H \u2192 G := fun q =>\n  g ^ ((quotientEquivSigmaZMod H g q).2 : \u2124) * (quotientEquivSigmaZMod H g q).1.out'.out'", "start": [738, 1], "end": [742, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferFunction_apply", "code": "theorem transferFunction_apply (q : G \u29f8 H) :\n    transferFunction H g q =\n      g ^ ((quotientEquivSigmaZMod H g q).2 : \u2124) * (quotientEquivSigmaZMod H g q).1.out'.out'", "start": [745, 1], "end": [748, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_transferFunction", "code": "theorem coe_transferFunction (q : G \u29f8 H) : \u2191(transferFunction H g q) = q", "start": [751, 1], "end": [753, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferSet", "code": "def transferSet : Set G :=\n  Set.range (transferFunction H g)", "start": [756, 1], "end": [759, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_transferSet", "code": "theorem mem_transferSet (q : G \u29f8 H) : transferFunction H g q \u2208 transferSet H g", "start": [762, 1], "end": [763, 11], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferTransversal", "code": "def transferTransversal : leftTransversals (H : Set G) :=\n  \u27e8transferSet H g, range_mem_leftTransversals (coe_transferFunction H g)\u27e9", "start": [766, 1], "end": [769, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferTransversal_apply", "code": "theorem transferTransversal_apply (q : G \u29f8 H) :\n    \u2191(toEquiv (transferTransversal H g).2 q) = transferFunction H g q", "start": [772, 1], "end": [774, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferTransversal_apply'", "code": "theorem transferTransversal_apply' (q : orbitRel.Quotient (zpowers g) (G \u29f8 H))\n    (k : ZMod (minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out')) :\n    \u2191(toEquiv (transferTransversal H g).2 (g ^ (k : \u2124) \u2022 q.out')) = g ^ (k : \u2124) * q.out'.out'", "start": [777, 1], "end": [781, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.transferTransversal_apply''", "code": "theorem transferTransversal_apply'' (q : orbitRel.Quotient (zpowers g) (G \u29f8 H))\n    (k : ZMod (minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out')) :\n    \u2191(toEquiv (g \u2022 transferTransversal H g).2 (g ^ (k : \u2124) \u2022 q.out')) =\n      if k = 0 then g ^ minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out' * q.out'.out'\n      else g ^ (k : \u2124) * q.out'.out'", "start": [784, 1], "end": [795, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/HeytAlg.lean", "imports": ["Mathlib/Order/Category/BddDistLat.lean", "Mathlib/Order/Heyting/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HeytAlg", "code": "def HeytAlg :=\n  Bundled HeytingAlgebra", "start": [23, 1], "end": [25, 25], "kind": "commanddeclaration"}, {"full_name": "HeytAlg.of", "code": "def of (\u03b1 : Type*) [HeytingAlgebra \u03b1] : HeytAlg :=\n  Bundled.of \u03b1", "start": [36, 1], "end": [38, 15], "kind": "commanddeclaration"}, {"full_name": "HeytAlg.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [HeytingAlgebra \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "HeytAlg.bundledHom", "code": "instance bundledHom : BundledHom HeytingHom where\n  toFun \u03b1 \u03b2 [HeytingAlgebra \u03b1] [HeytingAlgebra \u03b2] := (FunLike.coe : HeytingHom \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2)\n  id := @HeytingHom.id\n  comp := @HeytingHom.comp\n  hom_ext \u03b1 \u03b2 [HeytingAlgebra \u03b1] [HeytingAlgebra \u03b2] := FunLike.coe_injective", "start": [49, 1], "end": [53, 77], "kind": "commanddeclaration"}, {"full_name": "HeytAlg.hasForgetToLat", "code": "@[simps]\ninstance hasForgetToLat : HasForget\u2082 HeytAlg BddDistLat where\n  forget\u2082 :=\n    { obj := fun X => BddDistLat.of X\n      map := fun {X Y} f => (f : BoundedLatticeHom X Y) }", "start": [68, 1], "end": [72, 58], "kind": "commanddeclaration"}, {"full_name": "HeytAlg.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : HeytAlg.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : HeytingHom _ _)\n  inv := (e.symm : HeytingHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [75, 1], "end": [81, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Biproducts.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/Algebra/Homology/ShortExact/Abelian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/Pi.lean", "Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean"], "premises": [{"full_name": "ModuleCat.binaryProductLimitCone", "code": "@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (M N : ModuleCat.{v} R) : Limits.LimitCone (pair M N) where\n  cone :=\n    { pt := ModuleCat.of R (M \u00d7 N)\n      \u03c0 :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (LinearMap.fst R M N) (LinearMap.snd R M N)\n          naturality := by rintro \u27e8\u27e8\u27e9\u27e9 \u27e8\u27e8\u27e9\u27e9 \u27e8\u27e8\u27e8\u27e9\u27e9\u27e9 <;> rfl } }\n  isLimit :=\n    { lift := fun s => LinearMap.prod (s.\u03c0.app \u27e8WalkingPair.left\u27e9) (s.\u03c0.app \u27e8WalkingPair.right\u27e9)\n      fac := by rintro s (\u27e8\u27e9 | \u27e8\u27e9) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [\u2190 w \u27e8WalkingPair.left\u27e9, \u2190 w \u27e8WalkingPair.right\u27e9]\n        rfl }", "start": [40, 1], "end": [56, 14], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.binaryProductLimitCone_cone_\u03c0_app_left", "code": "@[simp]\ntheorem binaryProductLimitCone_cone_\u03c0_app_left (M N : ModuleCat.{v} R) :\n    (binaryProductLimitCone M N).cone.\u03c0.app \u27e8WalkingPair.left\u27e9 = LinearMap.fst R M N", "start": [59, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.binaryProductLimitCone_cone_\u03c0_app_right", "code": "@[simp]\ntheorem binaryProductLimitCone_cone_\u03c0_app_right (M N : ModuleCat.{v} R) :\n    (binaryProductLimitCone M N).cone.\u03c0.app \u27e8WalkingPair.right\u27e9 = LinearMap.snd R M N", "start": [65, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.biprodIsoProd", "code": "@[simps! hom_apply]\nnoncomputable def biprodIsoProd (M N : ModuleCat.{v} R) :\n    (M \u229e N : ModuleCat.{v} R) \u2245 ModuleCat.of R (M \u00d7 N) :=\n  IsLimit.conePointUniqueUpToIso (BinaryBiproduct.isLimit M N) (binaryProductLimitCone M N).isLimit", "start": [71, 1], "end": [77, 100], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.biprodIsoProd_inv_comp_fst", "code": "@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv \u226b biprod.fst = LinearMap.fst R M N", "start": [83, 1], "end": [86, 77], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.biprodIsoProd_inv_comp_snd", "code": "@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv \u226b biprod.snd = LinearMap.snd R M N", "start": [89, 1], "end": [92, 78], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.HasLimit.lift", "code": "@[simps]\ndef lift (s : Fan f) : s.pt \u27f6 ModuleCat.of R (\u2200 j, f j) where\n  toFun x j := s.\u03c0.app \u27e8j\u27e9 x\n  map_add' x y := by\n    simp only [Functor.const_obj_obj, map_add]\n    rfl\n  map_smul' r x := by\n    simp only [Functor.const_obj_obj, map_smul]\n    rfl", "start": [99, 1], "end": [110, 8], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.HasLimit.productLimitCone", "code": "@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (\u2200 j, f j)\n      \u03c0 := Discrete.natTrans fun j => (LinearMap.proj j.as : (\u2200 j, f j) \u2192\u2097[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun s j => rfl\n      uniq := fun s m w => by\n        ext x\n        funext j\n        exact congr_arg (fun g : s.pt \u27f6 f j => (g : s.pt \u2192 f j) x) (w \u27e8j\u27e9) }", "start": [113, 1], "end": [126, 77], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.biproductIsoPi", "code": "@[simps! hom_apply]\nnoncomputable def biproductIsoPi [Fintype J] (f : J \u2192 ModuleCat.{v} R) :\n    ((\u2a01 f) : ModuleCat.{v} R) \u2245 ModuleCat.of R (\u2200 j, f j) :=\n  IsLimit.conePointUniqueUpToIso (biproduct.isLimit f) (productLimitCone f).isLimit", "start": [135, 1], "end": [141, 84], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.biproductIsoPi_inv_comp_\u03c0", "code": "@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_\u03c0 [Fintype J] (f : J \u2192 ModuleCat.{v} R) (j : J) :\n    (biproductIsoPi f).inv \u226b biproduct.\u03c0 f j = (LinearMap.proj j : (\u2200 j, f j) \u2192\u2097[R] f j)", "start": [147, 1], "end": [150, 62], "kind": "commanddeclaration"}, {"full_name": "lequivProdOfRightSplitExact", "code": "noncomputable def lequivProdOfRightSplitExact {f : B \u2192\u2097[R] M} (hj : Function.Injective j)\n    (exac : LinearMap.range j = LinearMap.ker g) (h : g.comp f = LinearMap.id) : (A \u00d7 B) \u2243\u2097[R] M :=\n  (({ right_split := \u27e8ModuleCat.asHom f, h\u27e9\n      mono := (ModuleCat.mono_iff_injective <| asHom j).mpr hj\n      exact := (exact_iff _ _).mpr exac } : RightSplit _ _).splitting.iso.trans <|\n    biprodIsoProd _ _).toLinearEquiv.symm", "start": [164, 1], "end": [171, 42], "kind": "commanddeclaration"}, {"full_name": "lequivProdOfLeftSplitExact", "code": "noncomputable def lequivProdOfLeftSplitExact {f : M \u2192\u2097[R] A} (hg : Function.Surjective g)\n    (exac : LinearMap.range j = LinearMap.ker g) (h : f.comp j = LinearMap.id) : (A \u00d7 B) \u2243\u2097[R] M :=\n  (({ left_split := \u27e8ModuleCat.asHom f, h\u27e9\n      epi := (ModuleCat.epi_iff_surjective <| asHom g).mpr hg\n      exact := (exact_iff _ _).mpr exac } : LeftSplit _ _).splitting.iso.trans <|\n    biprodIsoProd _ _).toLinearEquiv.symm", "start": [174, 1], "end": [181, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/DedekindDomain.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/Algebra/Module/Torsion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.isInternal_prime_power_torsion_of_is_torsion_by_ideal", "code": "theorem isInternal_prime_power_torsion_of_is_torsion_by_ideal {I : Ideal R} (hI : I \u2260 \u22a5)\n    (hM : Module.IsTorsionBySet R M I) :\n    DirectSum.IsInternal fun p : (factors I).toFinset =>\n      torsionBySet R M ((p : Ideal R) ^ (factors I).count \u2191p)", "start": [37, 1], "end": [61, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.isInternal_prime_power_torsion", "code": "theorem isInternal_prime_power_torsion [Module.Finite R M] (hM : Module.IsTorsion R M) :\n    DirectSum.IsInternal fun p : (factors (\u22a4 : Submodule R M).annihilator).toFinset =>\n      torsionBySet R M ((p : Ideal R) ^ (factors (\u22a4 : Submodule R M).annihilator).count \u2191p)", "start": [64, 1], "end": [74, 68], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_isInternal_prime_power_torsion", "code": "theorem exists_isInternal_prime_power_torsion [Module.Finite R M] (hM : Module.IsTorsion R M) :\n    \u2203 (P : Finset <| Ideal R) (_ : DecidableEq P) (_ : \u2200 p \u2208 P, Prime p) (e : P \u2192 \u2115),\n      DirectSum.IsInternal fun p : P => torsionBySet R M ((p : Ideal R) ^ e p)", "start": [77, 1], "end": [83, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Variance.lean", "imports": ["Mathlib/Probability/Notation.lean", "Mathlib/Probability/Integration.lean", "Mathlib/MeasureTheory/Function/L2Space.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.coe_two", "code": "private lemma coe_two : ENNReal.toReal 2 = (2 : \u211d) := rfl", "start": [49, 1], "end": [49, 58], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.evariance", "code": "def evariance {\u03a9 : Type*} {_ : MeasurableSpace \u03a9} (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) : \u211d\u22650\u221e :=\n  \u222b\u207b \u03c9, (\u2016X \u03c9 - \u03bc[X]\u2016\u208a : \u211d\u22650\u221e) ^ 2 \u2202\u03bc", "start": [53, 1], "end": [56, 38], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance", "code": "def variance {\u03a9 : Type*} {_ : MeasurableSpace \u03a9} (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) : \u211d :=\n  (evariance X \u03bc).toReal", "start": [59, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.evariance_lt_top", "code": "theorem _root_.MeasureTheory.Mem\u2112p.evariance_lt_top [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    evariance X \u03bc < \u221e", "start": [67, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_eq_top", "code": "theorem evariance_eq_top [IsFiniteMeasure \u03bc] (hXm : AEStronglyMeasurable X \u03bc) (hX : \u00acMem\u2112p X 2 \u03bc) :\n    evariance X \u03bc = \u221e", "start": [77, 1], "end": [91, 36], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_lt_top_iff_mem\u2112p", "code": "theorem evariance_lt_top_iff_mem\u2112p [IsFiniteMeasure \u03bc] (hX : AEStronglyMeasurable X \u03bc) :\n    evariance X \u03bc < \u221e \u2194 Mem\u2112p X 2 \u03bc", "start": [94, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.ofReal_variance_eq", "code": "theorem _root_.MeasureTheory.Mem\u2112p.ofReal_variance_eq [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    ENNReal.ofReal (variance X \u03bc) = evariance X \u03bc", "start": [102, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_eq_lintegral_ofReal", "code": "theorem evariance_eq_lintegral_ofReal (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) :\n    evariance X \u03bc = \u222b\u207b \u03c9, ENNReal.ofReal ((X \u03c9 - \u03bc[X]) ^ 2) \u2202\u03bc", "start": [108, 1], "end": [115, 64], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.variance_eq_of_integral_eq_zero", "code": "theorem _root_.MeasureTheory.Mem\u2112p.variance_eq_of_integral_eq_zero (hX : Mem\u2112p X 2 \u03bc)\n    (hXint : \u03bc[X] = 0) : variance X \u03bc = \u03bc[X ^ 2]", "start": [118, 1], "end": [128, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Mem\u2112p.variance_eq", "code": "theorem _root_.MeasureTheory.Mem\u2112p.variance_eq [IsFiniteMeasure \u03bc] (hX : Mem\u2112p X 2 \u03bc) :\n    variance X \u03bc = \u03bc[(X - fun _ => \u03bc[X]) ^ 2]", "start": [131, 1], "end": [143, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_zero", "code": "@[simp]\ntheorem evariance_zero : evariance 0 \u03bc = 0", "start": [146, 1], "end": [147, 66], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_eq_zero_iff", "code": "theorem evariance_eq_zero_iff (hX : AEMeasurable X \u03bc) :\n    evariance X \u03bc = 0 \u2194 X =\u1d50[\u03bc] fun _ => \u03bc[X]", "start": [150, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_mul", "code": "theorem evariance_mul (c : \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) :\n    evariance (fun \u03c9 => c * X \u03c9) \u03bc = ENNReal.ofReal (c ^ 2) * evariance X \u03bc", "start": [162, 1], "end": [174, 72], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_zero", "code": "@[simp]\ntheorem variance_zero (\u03bc : Measure \u03a9) : variance 0 \u03bc = 0", "start": [179, 1], "end": [181, 60], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_nonneg", "code": "theorem variance_nonneg (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) : 0 \u2264 variance X \u03bc", "start": [184, 1], "end": [185, 24], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_mul", "code": "theorem variance_mul (c : \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) :\n    variance (fun \u03c9 => c * X \u03c9) \u03bc = c ^ 2 * variance X \u03bc", "start": [188, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_smul", "code": "theorem variance_smul (c : \u211d) (X : \u03a9 \u2192 \u211d) (\u03bc : Measure \u03a9) :\n    variance (c \u2022 X) \u03bc = c ^ 2 * variance X \u03bc", "start": [194, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_smul'", "code": "theorem variance_smul' {A : Type*} [CommSemiring A] [Algebra A \u211d] (c : A) (X : \u03a9 \u2192 \u211d)\n    (\u03bc : Measure \u03a9) : variance (c \u2022 X) \u03bc = c ^ 2 \u2022 variance X \u03bc", "start": [199, 1], "end": [203, 42], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_def'", "code": "theorem variance_def' [@IsProbabilityMeasure \u03a9 _ \u2119] {X : \u03a9 \u2192 \u211d} (hX : Mem\u2112p X 2) :\n    Var[X] = \ud835\udd3c[X ^ 2] - \ud835\udd3c[X] ^ 2", "start": [210, 1], "end": [220, 7], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.variance_le_expectation_sq", "code": "theorem variance_le_expectation_sq [@IsProbabilityMeasure \u03a9 _ \u2119] {X : \u03a9 \u2192 \u211d}\n    (hm : AEStronglyMeasurable X \u2119) : Var[X] \u2264 \ud835\udd3c[X ^ 2]", "start": [223, 1], "end": [242, 88], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.evariance_def'", "code": "theorem evariance_def' [@IsProbabilityMeasure \u03a9 _ \u2119] {X : \u03a9 \u2192 \u211d} (hX : AEStronglyMeasurable X \u2119) :\n    eVar[X] = (\u222b\u207b \u03c9, \u2016X \u03c9\u2016\u208a ^ 2) - ENNReal.ofReal (\ud835\udd3c[X] ^ 2)", "start": [245, 1], "end": [262, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.meas_ge_le_evariance_div_sq", "code": "theorem meas_ge_le_evariance_div_sq {X : \u03a9 \u2192 \u211d} (hX : AEStronglyMeasurable X \u2119) {c : \u211d\u22650}\n    (hc : c \u2260 0) : \u2119 {\u03c9 | \u2191c \u2264 |X \u03c9 - \ud835\udd3c[X]|} \u2264 eVar[X] / c ^ 2", "start": [265, 1], "end": [280, 35], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.meas_ge_le_variance_div_sq", "code": "theorem meas_ge_le_variance_div_sq [@IsFiniteMeasure \u03a9 _ \u2119] {X : \u03a9 \u2192 \u211d} (hX : Mem\u2112p X 2) {c : \u211d}\n    (hc : 0 < c) : \u2119 {\u03c9 | c \u2264 |X \u03c9 - \ud835\udd3c[X]|} \u2264 ENNReal.ofReal (Var[X] / c ^ 2)", "start": [283, 1], "end": [291, 8], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.variance_add", "code": "theorem IndepFun.variance_add [@IsProbabilityMeasure \u03a9 _ \u2119] {X Y : \u03a9 \u2192 \u211d} (hX : Mem\u2112p X 2)\n    (hY : Mem\u2112p Y 2) (h : @IndepFun _ _ _ (_) _ _ X Y \u2119) : Var[X + Y] = Var[X] + Var[Y]", "start": [295, 1], "end": [314, 84], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IndepFun.variance_sum", "code": "theorem IndepFun.variance_sum [@IsProbabilityMeasure \u03a9 _ \u2119] {\u03b9 : Type*} {X : \u03b9 \u2192 \u03a9 \u2192 \u211d}\n    {s : Finset \u03b9} (hs : \u2200 i \u2208 s, @Mem\u2112p _ _ _ (_) (X i) 2 \u2119)\n    (h : Set.Pairwise \u2191s fun i j => @IndepFun _ _ _ (_) _ _ (X i) (X j) \u2119) :\n    Var[\u2211 i in s, X i] = \u2211 i in s, Var[X i]", "start": [318, 1], "end": [379, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/DiscreteValuationRing.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "Mathlib/RingTheory/WittVector/Domain.lean", "Mathlib/RingTheory/DiscreteValuationRing/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/WittVector/MulCoeff.lean"], "premises": [{"full_name": "WittVector.succNthValUnits", "code": "def succNthValUnits (n : \u2115) (a : Units k) (A : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) : k :=\n  -\u2191(a\u207b\u00b9 ^ p ^ (n + 1)) *\n    (A.coeff (n + 1) * \u2191(a\u207b\u00b9 ^ p ^ (n + 1)) + nthRemainder p n (truncateFun (n + 1) A) bs)", "start": [45, 1], "end": [48, 91], "kind": "commanddeclaration"}, {"full_name": "WittVector.inverseCoeff", "code": "noncomputable def inverseCoeff (a : Units k) (A : \ud835\udd4e k) : \u2115 \u2192 k\n  | 0 => \u2191a\u207b\u00b9\n  | n + 1 => succNthValUnits n a A fun i => inverseCoeff a A i.val", "start": [51, 1], "end": [57, 67], "kind": "commanddeclaration"}, {"full_name": "WittVector.mkUnit", "code": "def mkUnit {a : Units k} {A : \ud835\udd4e k} (hA : A.coeff 0 = a) : Units (\ud835\udd4e k) :=\n  Units.mkOfMulEqOne A (@WittVector.mk' p _ (inverseCoeff a A)) (by\n    ext n\n    induction' n with n _\n    \u00b7 simp [WittVector.mul_coeff_zero, inverseCoeff, hA]\n    let H_coeff := A.coeff (n + 1) * \u2191(a\u207b\u00b9 ^ p ^ (n + 1)) +\n      nthRemainder p n (truncateFun (n + 1) A) fun i : Fin (n + 1) => inverseCoeff a A i\n    have H := Units.mul_inv (a ^ p ^ (n + 1))\n    linear_combination (norm := skip) -H_coeff * H\n    have ha : (a : k) ^ p ^ (n + 1) = \u2191(a ^ p ^ (n + 1)) := by norm_cast\n    have ha_inv : (\u2191a\u207b\u00b9 : k) ^ p ^ (n + 1) = \u2191(a ^ p ^ (n + 1))\u207b\u00b9 := by norm_cast; norm_num\n    simp only [nthRemainder_spec, inverseCoeff, succNthValUnits, hA,\n      one_coeff_eq_of_pos, Nat.succ_pos', ha_inv, ha, inv_pow]\n    ring!)", "start": [60, 1], "end": [76, 11], "kind": "commanddeclaration"}, {"full_name": "WittVector.coe_mkUnit", "code": "@[simp]\ntheorem coe_mkUnit {a : Units k} {A : \ud835\udd4e k} (hA : A.coeff 0 = a) : (mkUnit hA : \ud835\udd4e k) = A", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "WittVector.isUnit_of_coeff_zero_ne_zero", "code": "theorem isUnit_of_coeff_zero_ne_zero (x : \ud835\udd4e k) (hx : x.coeff 0 \u2260 0) : IsUnit x", "start": [90, 1], "end": [93, 27], "kind": "commanddeclaration"}, {"full_name": "WittVector.irreducible", "code": "theorem irreducible : Irreducible (p : \ud835\udd4e k)", "start": [98, 1], "end": [114, 31], "kind": "commanddeclaration"}, {"full_name": "WittVector.exists_eq_pow_p_mul", "code": "theorem exists_eq_pow_p_mul (a : \ud835\udd4e k) (ha : a \u2260 0) :\n    \u2203 (m : \u2115) (b : \ud835\udd4e k), b.coeff 0 \u2260 0 \u2227 a = (p : \ud835\udd4e k) ^ m * b", "start": [123, 1], "end": [138, 62], "kind": "commanddeclaration"}, {"full_name": "WittVector.exists_eq_pow_p_mul'", "code": "theorem exists_eq_pow_p_mul' (a : \ud835\udd4e k) (ha : a \u2260 0) :\n    \u2203 (m : \u2115) (b : Units (\ud835\udd4e k)), a = (p : \ud835\udd4e k) ^ m * b", "start": [147, 1], "end": [152, 28], "kind": "commanddeclaration"}, {"full_name": "WittVector.discreteValuationRing", "code": "theorem discreteValuationRing : DiscreteValuationRing (\ud835\udd4e k)", "start": [161, 1], "end": [167, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Triangulated/Pretriangulated.lean", "imports": ["Mathlib/CategoryTheory/Limits/Constructions/FiniteProductsOfBinaryProducts.lean", "Mathlib/CategoryTheory/Triangulated/TriangleShift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Pretriangulated", "code": "class Pretriangulated [\u2200 n : \u2124, Functor.Additive (shiftFunctor C n)] where\n  \n  distinguishedTriangles : Set (Triangle C)\n  \n  isomorphic_distinguished :\n    \u2200 T\u2081 \u2208 distinguishedTriangles, \u2200 (T\u2082) (_ : T\u2082 \u2245 T\u2081), T\u2082 \u2208 distinguishedTriangles\n  \n  contractible_distinguished : \u2200 X : C, contractibleTriangle X \u2208 distinguishedTriangles\n  \n  distinguished_cocone_triangle :\n    \u2200 {X Y : C} (f : X \u27f6 Y),\n      \u2203 (Z : C) (g : Y \u27f6 Z) (h : Z \u27f6 X\u27e6(1 : \u2124)\u27e7), Triangle.mk f g h \u2208 distinguishedTriangles\n  \n  rotate_distinguished_triangle :\n    \u2200 T : Triangle C, T \u2208 distinguishedTriangles \u2194 T.rotate \u2208 distinguishedTriangles\n  \n  complete_distinguished_triangle_morphism :\n    \u2200 (T\u2081 T\u2082 : Triangle C) (_ : T\u2081 \u2208 distinguishedTriangles) (_ : T\u2082 \u2208 distinguishedTriangles)\n      (a : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081) (b : T\u2081.obj\u2082 \u27f6 T\u2082.obj\u2082) (_ : T\u2081.mor\u2081 \u226b b = a \u226b T\u2082.mor\u2081),\n      \u2203 c : T\u2081.obj\u2083 \u27f6 T\u2082.obj\u2083, T\u2081.mor\u2082 \u226b c = b \u226b T\u2082.mor\u2082 \u2227 T\u2081.mor\u2083 \u226b a\u27e61\u27e7' = c \u226b T\u2082.mor\u2083", "start": [41, 1], "end": [82, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.distinguished_iff_of_iso", "code": "lemma distinguished_iff_of_iso {T\u2081 T\u2082 : Triangle C} (e : T\u2081 \u2245 T\u2082) :\n    (T\u2081 \u2208 distTriang C) \u2194 T\u2082 \u2208 distTriang C :=\n  \u27e8fun hT\u2081 => isomorphic_distinguished _ hT\u2081 _ e.symm,\n    fun hT\u2082 => isomorphic_distinguished _ hT\u2082 _ e\u27e9", "start": [97, 1], "end": [100, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.rot_of_distTriang", "code": "theorem rot_of_distTriang (T : Triangle C) (H : T \u2208 distTriang C) : T.rotate \u2208 distTriang C", "start": [102, 1], "end": [105, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.inv_rot_of_distTriang", "code": "theorem inv_rot_of_distTriang (T : Triangle C) (H : T \u2208 distTriang C) :\n    T.invRotate \u2208 distTriang C", "start": [108, 1], "end": [113, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.comp_distTriang_mor_zero\u2081\u2082", "code": "@[reassoc]\ntheorem comp_distTriang_mor_zero\u2081\u2082 (T) (H : T \u2208 (distTriang C)) : T.mor\u2081 \u226b T.mor\u2082 = 0", "start": [116, 1], "end": [129, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.comp_distTriang_mor_zero\u2082\u2083", "code": "@[reassoc]\ntheorem comp_distTriang_mor_zero\u2082\u2083 (T : Triangle C) (H : T \u2208 distTriang C) :\n    T.mor\u2082 \u226b T.mor\u2083 = 0", "start": [132, 1], "end": [143, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.comp_distTriang_mor_zero\u2083\u2081", "code": "@[reassoc]\ntheorem comp_distTriang_mor_zero\u2083\u2081 (T : Triangle C) (H : T \u2208 distTriang C) :\n    T.mor\u2083 \u226b T.mor\u2081\u27e61\u27e7' = 0", "start": [146, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.distinguished_cocone_triangle\u2081", "code": "lemma distinguished_cocone_triangle\u2081 {Y Z : C} (g : Y \u27f6 Z) :\n    \u2203 (X : C) (f : X \u27f6 Y) (h : Z \u27f6 X\u27e6(1 : \u2124)\u27e7), Triangle.mk f g h \u2208 distTriang C := by\n  obtain \u27e8X', f', g', mem\u27e9 := distinguished_cocone_triangle g\n  exact \u27e8_, _, _, inv_rot_of_distTriang _ mem\u27e9", "start": [161, 1], "end": [165, 47], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.distinguished_cocone_triangle\u2082", "code": "lemma distinguished_cocone_triangle\u2082 {Z X : C} (h : Z \u27f6 X\u27e6(1 : \u2124)\u27e7) :\n    \u2203 (Y : C) (f : X \u27f6 Y) (g : Y \u27f6 Z), Triangle.mk f g h \u2208 distTriang C := by\n  obtain \u27e8Y', f', g', mem\u27e9 := distinguished_cocone_triangle h\n  let T' := (Triangle.mk h f' g').invRotate.invRotate\n  refine' \u27e8T'.obj\u2082, ((shiftEquiv C (1 : \u2124)).unitIso.app X).hom \u226b T'.mor\u2081, T'.mor\u2082,\n    isomorphic_distinguished _ (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ mem)) _ _\u27e9\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : \u2124)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by aesop_cat) (by aesop_cat)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])", "start": [167, 1], "end": [176, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism\u2081", "code": "lemma complete_distinguished_triangle_morphism\u2081 (T\u2081 T\u2082 : Triangle C)\n    (hT\u2081 : T\u2081 \u2208 distTriang C) (hT\u2082 : T\u2082 \u2208 distTriang C) (b : T\u2081.obj\u2082 \u27f6 T\u2082.obj\u2082)\n    (c : T\u2081.obj\u2083 \u27f6 T\u2082.obj\u2083) (comm : T\u2081.mor\u2082 \u226b c = b \u226b T\u2082.mor\u2082) :\n    \u2203 (a : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081), T\u2081.mor\u2081 \u226b b = a \u226b T\u2082.mor\u2081 \u2227\n      T\u2081.mor\u2083 \u226b a\u27e6(1 : \u2124)\u27e7' = c \u226b T\u2082.mor\u2083 := by\n  obtain \u27e8a, \u27e8ha\u2081, ha\u2082\u27e9\u27e9 := complete_distinguished_triangle_morphism _ _\n    (rot_of_distTriang _ hT\u2081) (rot_of_distTriang _ hT\u2082) b c comm\n  refine' \u27e8(shiftFunctor C (1 : \u2124)).preimage a, \u27e8_, _\u27e9\u27e9\n  \u00b7 apply (shiftFunctor C (1 : \u2124)).map_injective\n    dsimp at ha\u2082\n    rw [neg_comp, comp_neg, neg_inj] at ha\u2082\n    simpa only [Functor.map_comp, Functor.image_preimage] using ha\u2082\n  \u00b7 simpa only [Functor.image_preimage] using ha\u2081", "start": [178, 1], "end": [192, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.complete_distinguished_triangle_morphism\u2082", "code": "lemma complete_distinguished_triangle_morphism\u2082 (T\u2081 T\u2082 : Triangle C)\n    (hT\u2081 : T\u2081 \u2208 distTriang C) (hT\u2082 : T\u2082 \u2208 distTriang C) (a : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081)\n    (c : T\u2081.obj\u2083 \u27f6 T\u2082.obj\u2083) (comm : T\u2081.mor\u2083 \u226b a\u27e6(1 : \u2124)\u27e7' = c \u226b T\u2082.mor\u2083) :\n    \u2203 (b : T\u2081.obj\u2082 \u27f6 T\u2082.obj\u2082), T\u2081.mor\u2081 \u226b b = a \u226b T\u2082.mor\u2081 \u2227 T\u2081.mor\u2082 \u226b c = b \u226b T\u2082.mor\u2082 := by\n  obtain \u27e8a, \u27e8ha\u2081, ha\u2082\u27e9\u27e9 := complete_distinguished_triangle_morphism _ _\n    (inv_rot_of_distTriang _ hT\u2081) (inv_rot_of_distTriang _ hT\u2082) (c\u27e6(-1 : \u2124)\u27e7') a (by\n    dsimp\n    simp only [neg_comp, comp_neg, \u2190 Functor.map_comp_assoc, \u2190 comm,\n      Functor.map_comp, shift_shift_neg', Functor.id_obj, assoc, Iso.inv_hom_id_app, comp_id])\n  refine' \u27e8a, \u27e8ha\u2081, _\u27e9\u27e9\n  dsimp only [Triangle.invRotate, Triangle.mk] at ha\u2082\n  rw [\u2190 cancel_mono ((shiftEquiv C (1 : \u2124)).counitIso.inv.app T\u2082.obj\u2083), assoc, assoc, \u2190 ha\u2082]\n  simp only [shiftEquiv'_counitIso, shift_neg_shift', assoc, Iso.inv_hom_id_app_assoc]", "start": [194, 1], "end": [208, 87], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.contractible_distinguished\u2081", "code": "lemma contractible_distinguished\u2081 (X : C) :\n    Triangle.mk (0 : 0 \u27f6 X) (\ud835\udfd9 X) 0 \u2208 distTriang C := by\n  refine' isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguished X)) _ _\n  exact Triangle.isoMk _ _ (Functor.mapZeroObject _).symm (Iso.refl _) (Iso.refl _)\n    (by aesop_cat) (by aesop_cat) (by aesop_cat)", "start": [210, 1], "end": [216, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.contractible_distinguished\u2082", "code": "lemma contractible_distinguished\u2082 (X : C) :\n    Triangle.mk (0 : X \u27f6 0) 0 (\ud835\udfd9 (X\u27e61\u27e7)) \u2208 distTriang C := by\n  refine' isomorphic_distinguished _\n    (inv_rot_of_distTriang _ (contractible_distinguished\u2081 (X\u27e6(1 : \u2124)\u27e7))) _ _\n  exact Triangle.isoMk _ _ ((shiftEquiv C (1 : \u2124)).unitIso.app X) (Iso.refl _) (Iso.refl _)\n    (by aesop_cat) (by aesop_cat)\n    (by dsimp; simp only [shift_shiftFunctorCompIsoId_inv_app, id_comp])", "start": [218, 1], "end": [225, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.yoneda_exact\u2082", "code": "lemma yoneda_exact\u2082 {X : C} (f : T.obj\u2082 \u27f6 X) (hf : T.mor\u2081 \u226b f = 0) :\n    \u2203 (g : T.obj\u2083 \u27f6 X), f = T.mor\u2082 \u226b g := by\n  obtain \u27e8g, \u27e8hg\u2081, _\u27e9\u27e9 := complete_distinguished_triangle_morphism T _ hT\n    (contractible_distinguished\u2081 X) 0 f (by aesop_cat)\n  exact \u27e8g, by simpa using hg\u2081.symm\u27e9", "start": [231, 1], "end": [235, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.yoneda_exact\u2083", "code": "lemma yoneda_exact\u2083 {X : C} (f : T.obj\u2083 \u27f6 X) (hf : T.mor\u2082 \u226b f = 0) :\n    \u2203 (g : T.obj\u2081\u27e6(1 : \u2124)\u27e7 \u27f6 X), f = T.mor\u2083 \u226b g :=\n  yoneda_exact\u2082 _ (rot_of_distTriang _ hT) f hf", "start": [237, 1], "end": [239, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.coyoneda_exact\u2082", "code": "lemma coyoneda_exact\u2082 {X : C} (f : X \u27f6 T.obj\u2082) (hf : f \u226b T.mor\u2082 = 0) :\n    \u2203 (g : X \u27f6 T.obj\u2081), f = g \u226b T.mor\u2081 := by\n  obtain \u27e8a, \u27e8ha\u2081, _\u27e9\u27e9 := complete_distinguished_triangle_morphism\u2081 _ T\n    (contractible_distinguished X) hT f 0 (by aesop_cat)\n  exact \u27e8a, by simpa using ha\u2081\u27e9", "start": [241, 1], "end": [245, 32], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.coyoneda_exact\u2081", "code": "lemma coyoneda_exact\u2081 {X : C} (f : X \u27f6 T.obj\u2081\u27e6(1 : \u2124)\u27e7) (hf : f \u226b T.mor\u2081\u27e61\u27e7' = 0) :\n    \u2203 (g : X \u27f6 T.obj\u2083), f = g \u226b T.mor\u2083 :=\n  coyoneda_exact\u2082 _ (rot_of_distTriang _ (rot_of_distTriang _ hT)) f (by aesop_cat)", "start": [247, 1], "end": [249, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.coyoneda_exact\u2083", "code": "lemma coyoneda_exact\u2083 {X : C} (f : X \u27f6 T.obj\u2083) (hf : f \u226b T.mor\u2083 = 0) :\n    \u2203 (g : X \u27f6 T.obj\u2082), f = g \u226b T.mor\u2082 :=\n  coyoneda_exact\u2082 _ (rot_of_distTriang _ hT) f hf", "start": [251, 1], "end": [253, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2083_eq_zero_iff_epi\u2082", "code": "lemma mor\u2083_eq_zero_iff_epi\u2082 : T.mor\u2083 = 0 \u2194 Epi T.mor\u2082 := by\n  constructor\n  \u00b7 intro h\n    rw [epi_iff_cancel_zero]\n    intro X g hg\n    obtain \u27e8f, rfl\u27e9 := yoneda_exact\u2083 T hT g hg\n    rw [h, zero_comp]\n  \u00b7 intro\n    rw [\u2190 cancel_epi T.mor\u2082, comp_distTriang_mor_zero\u2082\u2083 _ hT, comp_zero]", "start": [255, 1], "end": [263, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2082_eq_zero_iff_epi\u2081", "code": "lemma mor\u2082_eq_zero_iff_epi\u2081 : T.mor\u2082 = 0 \u2194 Epi T.mor\u2081 := by\n  have h := mor\u2083_eq_zero_iff_epi\u2082 _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [\u2190 h, IsIso.comp_right_eq_zero]", "start": [265, 1], "end": [268, 37], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2081_eq_zero_iff_epi\u2083", "code": "lemma mor\u2081_eq_zero_iff_epi\u2083 : T.mor\u2081 = 0 \u2194 Epi T.mor\u2083 := by\n  have h := mor\u2083_eq_zero_iff_epi\u2082 _ (rot_of_distTriang _ hT)\n  dsimp at h\n  rw [\u2190 h, neg_eq_zero]\n  constructor\n  \u00b7 intro h\n    simp only [h, Functor.map_zero]\n  \u00b7 intro h\n    rw [\u2190 (CategoryTheory.shiftFunctor C (1 : \u2124)).map_eq_zero_iff, h]", "start": [270, 1], "end": [278, 70], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2083_eq_zero_of_epi\u2082", "code": "lemma mor\u2083_eq_zero_of_epi\u2082 (h : Epi T.mor\u2082) : T.mor\u2083 = 0 := (T.mor\u2083_eq_zero_iff_epi\u2082 hT).2 h", "start": [280, 1], "end": [280, 93], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2082_eq_zero_of_epi\u2081", "code": "lemma mor\u2082_eq_zero_of_epi\u2081 (h : Epi T.mor\u2081) : T.mor\u2082 = 0 := (T.mor\u2082_eq_zero_iff_epi\u2081 hT).2 h", "start": [281, 1], "end": [281, 93], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2081_eq_zero_of_epi\u2083", "code": "lemma mor\u2081_eq_zero_of_epi\u2083 (h : Epi T.mor\u2083) : T.mor\u2081 = 0 := (T.mor\u2081_eq_zero_iff_epi\u2083 hT).2 h", "start": [282, 1], "end": [282, 93], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.epi\u2082", "code": "lemma epi\u2082 (h : T.mor\u2083 = 0) : Epi T.mor\u2082 := (T.mor\u2083_eq_zero_iff_epi\u2082 hT).1 h", "start": [284, 1], "end": [284, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.epi\u2081", "code": "lemma epi\u2081 (h : T.mor\u2082 = 0) : Epi T.mor\u2081 := (T.mor\u2082_eq_zero_iff_epi\u2081 hT).1 h", "start": [285, 1], "end": [285, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.epi\u2083", "code": "lemma epi\u2083 (h : T.mor\u2081 = 0) : Epi T.mor\u2083 := (T.mor\u2081_eq_zero_iff_epi\u2083 hT).1 h", "start": [286, 1], "end": [286, 77], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2081_eq_zero_iff_mono\u2082", "code": "lemma mor\u2081_eq_zero_iff_mono\u2082 : T.mor\u2081 = 0 \u2194 Mono T.mor\u2082 := by\n  constructor\n  \u00b7 intro h\n    rw [mono_iff_cancel_zero]\n    intro X g hg\n    obtain \u27e8f, rfl\u27e9 := coyoneda_exact\u2082 T hT g hg\n    rw [h, comp_zero]\n  \u00b7 intro\n    rw [\u2190 cancel_mono T.mor\u2082, comp_distTriang_mor_zero\u2081\u2082 _ hT, zero_comp]", "start": [288, 1], "end": [296, 74], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2082_eq_zero_iff_mono\u2083", "code": "lemma mor\u2082_eq_zero_iff_mono\u2083 : T.mor\u2082 = 0 \u2194 Mono T.mor\u2083 :=\n  mor\u2081_eq_zero_iff_mono\u2082 _ (rot_of_distTriang _ hT)", "start": [298, 1], "end": [299, 52], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2083_eq_zero_iff_mono\u2081", "code": "lemma mor\u2083_eq_zero_iff_mono\u2081 : T.mor\u2083 = 0 \u2194 Mono T.mor\u2081 := by\n  have h := mor\u2081_eq_zero_iff_mono\u2082 _ (inv_rot_of_distTriang _ hT)\n  dsimp at h\n  rw [\u2190 h, neg_eq_zero, IsIso.comp_right_eq_zero]\n  constructor\n  \u00b7 intro h\n    simp only [h, Functor.map_zero]\n  \u00b7 intro h\n    rw [\u2190 (CategoryTheory.shiftFunctor C (-1 : \u2124)).map_eq_zero_iff, h]", "start": [301, 1], "end": [309, 71], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2081_eq_zero_of_mono\u2082", "code": "lemma mor\u2081_eq_zero_of_mono\u2082 (h : Mono T.mor\u2082) : T.mor\u2081 = 0 := (T.mor\u2081_eq_zero_iff_mono\u2082 hT).2 h", "start": [311, 1], "end": [311, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2082_eq_zero_of_mono\u2083", "code": "lemma mor\u2082_eq_zero_of_mono\u2083 (h : Mono T.mor\u2083) : T.mor\u2082 = 0 := (T.mor\u2082_eq_zero_iff_mono\u2083 hT).2 h", "start": [312, 1], "end": [312, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mor\u2083_eq_zero_of_mono\u2081", "code": "lemma mor\u2083_eq_zero_of_mono\u2081 (h : Mono T.mor\u2081) : T.mor\u2083 = 0 := (T.mor\u2083_eq_zero_iff_mono\u2081 hT).2 h", "start": [313, 1], "end": [313, 96], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mono\u2082", "code": "lemma mono\u2082 (h : T.mor\u2081 = 0) : Mono T.mor\u2082 := (T.mor\u2081_eq_zero_iff_mono\u2082 hT).1 h", "start": [315, 1], "end": [315, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mono\u2083", "code": "lemma mono\u2083 (h : T.mor\u2082 = 0) : Mono T.mor\u2083 := (T.mor\u2082_eq_zero_iff_mono\u2083 hT).1 h", "start": [316, 1], "end": [316, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.mono\u2081", "code": "lemma mono\u2081 (h : T.mor\u2083 = 0) : Mono T.mor\u2081 := (T.mor\u2083_eq_zero_iff_mono\u2081 hT).1 h", "start": [317, 1], "end": [317, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2082_iff", "code": "lemma isZero\u2082_iff : IsZero T.obj\u2082 \u2194 (T.mor\u2081 = 0 \u2227 T.mor\u2082 = 0) := by\n  constructor\n  \u00b7 intro h\n    exact \u27e8h.eq_of_tgt _ _, h.eq_of_src _ _\u27e9\n  \u00b7 intro \u27e8h\u2081, h\u2082\u27e9\n    obtain \u27e8f, hf\u27e9 := coyoneda_exact\u2082 T hT (\ud835\udfd9 _) (by rw [h\u2082, comp_zero])\n    rw [IsZero.iff_id_eq_zero, hf, h\u2081, comp_zero]", "start": [319, 1], "end": [325, 50], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2081_iff", "code": "lemma isZero\u2081_iff : IsZero T.obj\u2081 \u2194 (T.mor\u2081 = 0 \u2227 T.mor\u2083 = 0) := by\n  refine' (isZero\u2082_iff _ (inv_rot_of_distTriang _ hT)).trans _\n  dsimp\n  simp only [neg_eq_zero, IsIso.comp_right_eq_zero, Functor.map_eq_zero_iff]\n  tauto", "start": [327, 1], "end": [331, 8], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2083_iff", "code": "lemma isZero\u2083_iff : IsZero T.obj\u2083 \u2194 (T.mor\u2082 = 0 \u2227 T.mor\u2083 = 0) := by\n  refine' (isZero\u2082_iff _ (rot_of_distTriang _ hT)).trans _\n  dsimp\n  tauto", "start": [333, 1], "end": [336, 8], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2081_of_isZero\u2082\u2083", "code": "lemma isZero\u2081_of_isZero\u2082\u2083 (h\u2082 : IsZero T.obj\u2082) (h\u2083 : IsZero T.obj\u2083) : IsZero T.obj\u2081 := by\n  rw [T.isZero\u2081_iff hT]\n  exact \u27e8h\u2082.eq_of_tgt _ _, h\u2083.eq_of_src _ _\u27e9", "start": [338, 1], "end": [340, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2082_of_isZero\u2081\u2083", "code": "lemma isZero\u2082_of_isZero\u2081\u2083 (h\u2081 : IsZero T.obj\u2081) (h\u2083 : IsZero T.obj\u2083) : IsZero T.obj\u2082 := by\n  rw [T.isZero\u2082_iff hT]\n  exact \u27e8h\u2081.eq_of_src _ _, h\u2083.eq_of_tgt _ _\u27e9", "start": [342, 1], "end": [344, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2083_of_isZero\u2081\u2082", "code": "lemma isZero\u2083_of_isZero\u2081\u2082 (h\u2081 : IsZero T.obj\u2081) (h\u2082 : IsZero T.obj\u2082) : IsZero T.obj\u2083 :=\n  isZero\u2082_of_isZero\u2081\u2083 _ (rot_of_distTriang _ hT) h\u2082 (by\n    dsimp\n    simp only [IsZero.iff_id_eq_zero] at h\u2081 \u22a2\n    rw [\u2190 Functor.map_id, h\u2081, Functor.map_zero])", "start": [346, 1], "end": [350, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2081_iff_isIso\u2082", "code": "lemma isZero\u2081_iff_isIso\u2082 :\n    IsZero T.obj\u2081 \u2194 IsIso T.mor\u2082 := by\n  rw [T.isZero\u2081_iff hT]\n  constructor\n  \u00b7 intro \u27e8h\u2081, h\u2083\u27e9\n    have := T.epi\u2082 hT h\u2083\n    obtain \u27e8f, hf\u27e9 := yoneda_exact\u2082 T hT (\ud835\udfd9 _) (by rw [h\u2081, zero_comp])\n    exact \u27e8f, hf.symm, by rw [\u2190 cancel_epi T.mor\u2082, comp_id, \u2190 reassoc_of% hf]\u27e9\n  \u00b7 intro\n    rw [T.mor\u2081_eq_zero_iff_mono\u2082 hT, T.mor\u2083_eq_zero_iff_epi\u2082 hT]\n    constructor <;> infer_instance", "start": [352, 1], "end": [362, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2082_iff_isIso\u2083", "code": "lemma isZero\u2082_iff_isIso\u2083 : IsZero T.obj\u2082 \u2194 IsIso T.mor\u2083 :=\n  isZero\u2081_iff_isIso\u2082 _ (rot_of_distTriang _ hT)", "start": [364, 1], "end": [365, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2083_iff_isIso\u2081", "code": "lemma isZero\u2083_iff_isIso\u2081 : IsZero T.obj\u2083 \u2194 IsIso T.mor\u2081 := by\n  refine' Iff.trans _ (Triangle.isZero\u2081_iff_isIso\u2082 _ (inv_rot_of_distTriang _ hT))\n  dsimp\n  simp only [IsZero.iff_id_eq_zero, \u2190 Functor.map_id, Functor.map_eq_zero_iff]", "start": [367, 1], "end": [370, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2081_of_isIso\u2082", "code": "lemma isZero\u2081_of_isIso\u2082 (h : IsIso T.mor\u2082) : IsZero T.obj\u2081 := (T.isZero\u2081_iff_isIso\u2082 hT).2 h", "start": [372, 1], "end": [372, 92], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2082_of_isIso\u2083", "code": "lemma isZero\u2082_of_isIso\u2083 (h : IsIso T.mor\u2083) : IsZero T.obj\u2082 := (T.isZero\u2082_iff_isIso\u2083 hT).2 h", "start": [373, 1], "end": [373, 92], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.isZero\u2083_of_isIso\u2081", "code": "lemma isZero\u2083_of_isIso\u2081 (h : IsIso T.mor\u2081) : IsZero T.obj\u2083 := (T.isZero\u2083_iff_isIso\u2081 hT).2 h", "start": [374, 1], "end": [374, 92], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.Triangle.shift_distinguished", "code": "lemma shift_distinguished (n : \u2124) :\n    (CategoryTheory.shiftFunctor (Triangle C) n).obj T \u2208 distTriang C := by\n  revert T hT\n  let H : \u2124 \u2192 Prop := fun n => \u2200 (T : Triangle C) (_ : T \u2208 distTriang C),\n    (Triangle.shiftFunctor C n).obj T \u2208 distTriang C\n  change H n\n  have H_zero : H 0 := fun T hT =>\n    isomorphic_distinguished _ hT _ ((Triangle.shiftFunctorZero C).app T)\n  have H_one : H 1 := fun T hT =>\n    isomorphic_distinguished _ (rot_of_distTriang _\n      (rot_of_distTriang _ (rot_of_distTriang _ hT))) _\n        ((rotateRotateRotateIso C).symm.app T)\n  have H_neg_one : H (-1) := fun T hT =>\n    isomorphic_distinguished _ (inv_rot_of_distTriang _\n      (inv_rot_of_distTriang _ (inv_rot_of_distTriang _ hT))) _\n        ((invRotateInvRotateInvRotateIso C).symm.app T)\n  have H_add : \u2200 {a b c : \u2124}, H a \u2192 H b \u2192 a + b = c \u2192 H c := fun {a b c} ha hb hc T hT =>\n    isomorphic_distinguished _ (hb _ (ha _ hT)) _\n      ((Triangle.shiftFunctorAdd' C _ _ _ hc).app T)\n  obtain (n|n) := n\n  \u00b7 induction' n with n hn\n    \u00b7 exact H_zero\n    \u00b7 exact H_add hn H_one rfl\n  \u00b7 induction' n with n hn\n    \u00b7 exact H_neg_one\n    \u00b7 exact H_add hn H_neg_one rfl", "start": [376, 1], "end": [401, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.isIso\u2082_of_isIso\u2081\u2083", "code": "lemma isIso\u2082_of_isIso\u2081\u2083 {T T' : Triangle C} (\u03c6 : T \u27f6 T') (hT : T \u2208 distTriang C)\n    (hT' : T' \u2208 distTriang C) (h\u2081 : IsIso \u03c6.hom\u2081) (h\u2083 : IsIso \u03c6.hom\u2083) : IsIso \u03c6.hom\u2082 := by\n  have : Mono \u03c6.hom\u2082 := by\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    obtain \u27e8g, rfl\u27e9 := Triangle.coyoneda_exact\u2082 _ hT f\n      (by rw [\u2190 cancel_mono \u03c6.hom\u2083, assoc, \u03c6.comm\u2082, reassoc_of% hf, zero_comp, zero_comp])\n    rw [assoc] at hf\n    obtain \u27e8h, hh\u27e9 := Triangle.coyoneda_exact\u2082 T'.invRotate (inv_rot_of_distTriang _ hT')\n      (g \u226b \u03c6.hom\u2081) (by dsimp; rw [assoc, \u2190 \u03c6.comm\u2081, hf])\n    obtain \u27e8k, rfl\u27e9 : \u2203 (k : A \u27f6 T.invRotate.obj\u2081), k \u226b T.invRotate.mor\u2081 = g := by\n      refine' \u27e8h \u226b inv (\u03c6.hom\u2083\u27e6(-1 : \u2124)\u27e7'), _\u27e9\n      have eq := ((invRotate C).map \u03c6).comm\u2081\n      dsimp only [invRotate] at eq\n      rw [\u2190 cancel_mono \u03c6.hom\u2081, assoc, assoc, eq, IsIso.inv_hom_id_assoc, hh]\n    erw [assoc, comp_distTriang_mor_zero\u2081\u2082 _ (inv_rot_of_distTriang _ hT), comp_zero]\n  refine' isIso_of_yoneda_map_bijective _ (fun A => \u27e8_, _\u27e9)\n  \u00b7 intro f\u2081 f\u2082 h\n    simpa only [\u2190 cancel_mono \u03c6.hom\u2082] using h\n  \u00b7 intro y\u2082\n    obtain \u27e8x\u2083, hx\u2083\u27e9 : \u2203 (x\u2083 : A \u27f6 T.obj\u2083), x\u2083 \u226b \u03c6.hom\u2083 = y\u2082 \u226b T'.mor\u2082 :=\n      \u27e8y\u2082 \u226b T'.mor\u2082 \u226b inv \u03c6.hom\u2083, by simp\u27e9\n    obtain \u27e8x\u2082, hx\u2082\u27e9 := Triangle.coyoneda_exact\u2083 _ hT x\u2083\n      (by rw [\u2190 cancel_mono (\u03c6.hom\u2081\u27e6(1 : \u2124)\u27e7'), assoc, zero_comp, \u03c6.comm\u2083, reassoc_of% hx\u2083,\n        comp_distTriang_mor_zero\u2082\u2083 _ hT', comp_zero])\n    obtain \u27e8y\u2081, hy\u2081\u27e9 := Triangle.coyoneda_exact\u2082 _ hT' (y\u2082 - x\u2082 \u226b \u03c6.hom\u2082)\n      (by rw [sub_comp, assoc, \u2190 \u03c6.comm\u2082, \u2190 reassoc_of% hx\u2082, hx\u2083, sub_self])\n    obtain \u27e8x\u2081, hx\u2081\u27e9 : \u2203 (x\u2081 : A \u27f6 T.obj\u2081), x\u2081 \u226b \u03c6.hom\u2081 = y\u2081 := \u27e8y\u2081 \u226b inv \u03c6.hom\u2081, by simp\u27e9\n    refine' \u27e8x\u2082 + x\u2081 \u226b T.mor\u2081, _\u27e9\n    dsimp\n    rw [add_comp, assoc, \u03c6.comm\u2081, reassoc_of% hx\u2081, \u2190 hy\u2081, add_sub_cancel'_right]", "start": [419, 1], "end": [449, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.isIso\u2083_of_isIso\u2081\u2082", "code": "lemma isIso\u2083_of_isIso\u2081\u2082 {T T' : Triangle C} (\u03c6 : T \u27f6 T') (hT : T \u2208 distTriang C)\n    (hT' : T' \u2208 distTriang C) (h\u2081 : IsIso \u03c6.hom\u2081) (h\u2082 : IsIso \u03c6.hom\u2082) : IsIso \u03c6.hom\u2083 :=\n  isIso\u2082_of_isIso\u2081\u2083 ((rotate C).map \u03c6) (rot_of_distTriang _ hT)\n    (rot_of_distTriang _ hT') h\u2082 (by dsimp; infer_instance)", "start": [451, 1], "end": [454, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.isIso\u2081_of_isIso\u2082\u2083", "code": "lemma isIso\u2081_of_isIso\u2082\u2083 {T T' : Triangle C} (\u03c6 : T \u27f6 T') (hT : T \u2208 distTriang C)\n    (hT' : T' \u2208 distTriang C) (h\u2082 : IsIso \u03c6.hom\u2082) (h\u2083 : IsIso \u03c6.hom\u2083) : IsIso \u03c6.hom\u2081 :=\n  isIso\u2082_of_isIso\u2081\u2083 ((invRotate C).map \u03c6) (inv_rot_of_distTriang _ hT)\n    (inv_rot_of_distTriang _ hT') (by dsimp; infer_instance) (by dsimp; infer_instance)", "start": [456, 1], "end": [459, 88], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.binaryBiproductData", "code": "@[simps]\ndef binaryBiproductData (T : Triangle C) (hT : T \u2208 distTriang C) (hT\u2080 : T.mor\u2083 = 0)\n    (inr : T.obj\u2083 \u27f6 T.obj\u2082) (inr_snd : inr \u226b T.mor\u2082 = \ud835\udfd9 _) (fst : T.obj\u2082 \u27f6 T.obj\u2081)\n    (total : fst \u226b T.mor\u2081 + T.mor\u2082 \u226b inr = \ud835\udfd9 T.obj\u2082) :\n    BinaryBiproductData T.obj\u2081 T.obj\u2083 := by\n  have : Mono T.mor\u2081 := T.mono\u2081 hT hT\u2080\n  have eq : fst \u226b T.mor\u2081 = \ud835\udfd9 T.obj\u2082 - T.mor\u2082 \u226b inr := by rw [\u2190 total, add_sub_cancel]\n  exact\n    { bicone :=\n      { pt := T.obj\u2082\n        fst := fst\n        snd := T.mor\u2082\n        inl := T.mor\u2081\n        inr := inr\n        inl_fst := by\n          simp only [\u2190 cancel_mono T.mor\u2081, assoc, id_comp, eq, comp_sub, comp_id,\n            comp_distTriang_mor_zero\u2081\u2082_assoc _ hT, zero_comp, sub_zero]\n        inl_snd := comp_distTriang_mor_zero\u2081\u2082 _ hT\n        inr_fst := by\n          simp only [\u2190 cancel_mono T.mor\u2081, assoc, eq, comp_sub, reassoc_of% inr_snd,\n            comp_id, sub_self, zero_comp]\n        inr_snd := inr_snd }\n      isBilimit := isBinaryBilimitOfTotal _ total }", "start": [461, 1], "end": [488, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.exists_iso_binaryBiproduct_of_distTriang", "code": "lemma exists_iso_binaryBiproduct_of_distTriang (T : Triangle C) (hT : T \u2208 distTriang C)\n    (zero : T.mor\u2083 = 0) :\n    \u2203 (e : T.obj\u2082 \u2245 T.obj\u2081 \u229e T.obj\u2083), T.mor\u2081 \u226b e.hom = biprod.inl \u2227\n      T.mor\u2082 = e.hom \u226b biprod.snd := by\n  have := T.epi\u2082 hT zero\n  have := isSplitEpi_of_epi T.mor\u2082\n  obtain \u27e8fst, hfst\u27e9 := T.coyoneda_exact\u2082 hT (\ud835\udfd9 T.obj\u2082 - T.mor\u2082 \u226b section_ T.mor\u2082) (by simp)\n  let d := binaryBiproductData _ hT zero (section_ T.mor\u2082) (by simp) fst\n    (by simp only [\u2190 hfst, sub_add_cancel])\n  refine' \u27e8biprod.uniqueUpToIso _ _ d.isBilimit, \u27e8_, by simp\u27e9\u27e9\n  ext\n  \u00b7 simpa using d.bicone.inl_fst\n  \u00b7 simpa using d.bicone.inl_snd", "start": [506, 1], "end": [518, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.binaryBiproductTriangle_distinguished", "code": "lemma binaryBiproductTriangle_distinguished (X\u2081 X\u2082 : C) :\n    binaryBiproductTriangle X\u2081 X\u2082 \u2208 distTriang C := by\n  obtain \u27e8Y, g, h, mem\u27e9 := distinguished_cocone_triangle\u2082 (0 : X\u2082 \u27f6 X\u2081\u27e6(1 : \u2124)\u27e7)\n  obtain \u27e8e, \u27e8he\u2081, he\u2082\u27e9\u27e9 := exists_iso_binaryBiproduct_of_distTriang _ mem rfl\n  dsimp at he\u2081 he\u2082\n  refine' isomorphic_distinguished _ mem _ (Iso.symm _)\n  refine' Triangle.isoMk _ _ (Iso.refl _) e (Iso.refl _)\n    (by aesop_cat) (by aesop_cat) (by aesop_cat)", "start": [520, 1], "end": [527, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.binaryProductTriangle_distinguished", "code": "lemma binaryProductTriangle_distinguished (X\u2081 X\u2082 : C) :\n    binaryProductTriangle X\u2081 X\u2082 \u2208 distTriang C :=\n  isomorphic_distinguished _ (binaryBiproductTriangle_distinguished X\u2081 X\u2082) _\n    (binaryProductTriangleIsoBinaryBiproductTriangle X\u2081 X\u2082)", "start": [529, 1], "end": [532, 60], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Pretriangulated.completeDistinguishedTriangleMorphism", "code": "@[simps hom\u2081 hom\u2082]\ndef completeDistinguishedTriangleMorphism (T\u2081 T\u2082 : Triangle C)\n    (hT\u2081 : T\u2081 \u2208 distTriang C) (hT\u2082 : T\u2082 \u2208 distTriang C)\n    (a : T\u2081.obj\u2081 \u27f6 T\u2082.obj\u2081) (b : T\u2081.obj\u2082 \u27f6 T\u2082.obj\u2082) (comm : T\u2081.mor\u2081 \u226b b = a \u226b T\u2082.mor\u2081) :\n    T\u2081 \u27f6 T\u2082 :=\n    have h := complete_distinguished_triangle_morphism _ _ hT\u2081 hT\u2082 a b comm\n    { hom\u2081 := a\n      hom\u2082 := b\n      hom\u2083 := h.choose\n      comm\u2081 := comm\n      comm\u2082 := h.choose_spec.1\n      comm\u2083 := h.choose_spec.2 }", "start": [534, 1], "end": [546, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Pretriangulated.productTriangle_distinguished", "code": "lemma productTriangle_distinguished {J : Type*} (T : J \u2192 Triangle C)\n    (hT : \u2200 j, T j \u2208 distTriang C)\n    [HasProduct (fun j => (T j).obj\u2081)] [HasProduct (fun j => (T j).obj\u2082)]\n    [HasProduct (fun j => (T j).obj\u2083)] [HasProduct (fun j => (T j).obj\u2081\u27e6(1 : \u2124)\u27e7)] :\n    productTriangle T \u2208 distTriang C := by\n  \n  let f\u2081 := Pi.map (fun j => (T j).mor\u2081)\n  obtain \u27e8Z, f\u2082, f\u2083, hT'\u27e9 := distinguished_cocone_triangle f\u2081\n  let T' := Triangle.mk f\u2081 f\u2082 f\u2083\n  change T' \u2208 distTriang C at hT'\n  let \u03c6 : \u2200 j, T' \u27f6 T j := fun j => completeDistinguishedTriangleMorphism _ _\n    hT' (hT j) (Pi.\u03c0 _ j) (Pi.\u03c0 _ j) (by simp)\n  let \u03c6' := productTriangle.lift _ \u03c6\n  have h\u2081 : \u03c6'.hom\u2081 = \ud835\udfd9 _ := by aesop_cat\n  have h\u2082 : \u03c6'.hom\u2082 = \ud835\udfd9 _ := by aesop_cat\n  have : IsIso \u03c6'.hom\u2081 := by rw [h\u2081]; infer_instance\n  have : IsIso \u03c6'.hom\u2082 := by rw [h\u2082]; infer_instance\n  suffices IsIso \u03c6'.hom\u2083 by\n    have : IsIso \u03c6' := by\n      apply Triangle.isIso_of_isIsos\n      all_goals infer_instance\n    exact isomorphic_distinguished _ hT' _ (asIso \u03c6').symm\n  refine' isIso_of_yoneda_map_bijective _ (fun A => \u27e8_, _\u27e9)\n  \n  \u00b7 suffices Mono \u03c6'.hom\u2083 by\n      intro a\u2081 a\u2082 ha\n      simpa only [\u2190 cancel_mono \u03c6'.hom\u2083] using ha\n    rw [mono_iff_cancel_zero]\n    intro A f hf\n    have hf' : f \u226b T'.mor\u2083 = 0 := by\n      rw [\u2190 cancel_mono (\u03c6'.hom\u2081\u27e61\u27e7'), zero_comp, assoc, \u03c6'.comm\u2083, reassoc_of% hf, zero_comp]\n    obtain \u27e8g, hg\u27e9 := T'.coyoneda_exact\u2083 hT' f hf'\n    have hg' : \u2200 j, (g \u226b Pi.\u03c0 _ j) \u226b (T j).mor\u2082 = 0 := fun j => by\n      have : g \u226b T'.mor\u2082 \u226b \u03c6'.hom\u2083 \u226b Pi.\u03c0 _ j = 0 :=\n        by rw [\u2190 reassoc_of% hg, reassoc_of% hf, zero_comp]\n      rw [\u03c6'.comm\u2082_assoc, h\u2082, id_comp] at this\n      simpa using this\n    have hg'' := fun j => (T j).coyoneda_exact\u2082 (hT j) _ (hg' j)\n    let \u03b1 := fun j => (hg'' j).choose\n    have h\u03b1 : \u2200 j, _ = \u03b1 j \u226b _ := fun j => (hg'' j).choose_spec\n    have hg''' : g = Pi.lift \u03b1 \u226b T'.mor\u2081 := by dsimp; ext j; rw [h\u03b1]; simp\n    rw [hg, hg''', assoc, comp_distTriang_mor_zero\u2081\u2082 _ hT', comp_zero]\n  \u00b7 intro a\n    obtain \u27e8a', ha'\u27e9 : \u2203 (a' : A \u27f6 Z), a' \u226b T'.mor\u2083 = a \u226b (productTriangle T).mor\u2083 := by\n      have zero : ((productTriangle T).mor\u2083) \u226b (shiftFunctor C 1).map T'.mor\u2081 = 0 := by\n        rw [\u2190 cancel_mono (\u03c6'.hom\u2082\u27e61\u27e7'), zero_comp, assoc, \u2190 Functor.map_comp, \u03c6'.comm\u2081, h\u2081,\n          id_comp, productTriangle.zero\u2083\u2081]\n        intro j\n        exact comp_distTriang_mor_zero\u2083\u2081 _ (hT j)\n      have \u27e8g, hg\u27e9 := T'.coyoneda_exact\u2081 hT' (a \u226b (productTriangle T).mor\u2083) (by\n        rw [assoc, zero, comp_zero])\n      exact \u27e8g, hg.symm\u27e9\n    have ha'' := fun (j : J) => (T j).coyoneda_exact\u2083 (hT j) ((a - a' \u226b \u03c6'.hom\u2083) \u226b Pi.\u03c0 _ j) (by\n      simp only [sub_comp, assoc]\n      erw [\u2190 (productTriangle.\u03c0 T j).comm\u2083]\n      rw [\u2190 \u03c6'.comm\u2083_assoc]\n      rw [reassoc_of% ha', sub_eq_zero, h\u2081, Functor.map_id, id_comp])\n    let b := fun j => (ha'' j).choose\n    have hb : \u2200 j, _  = b j \u226b _ := fun j => (ha'' j).choose_spec\n    have hb' : a - a' \u226b \u03c6'.hom\u2083 = Pi.lift b \u226b (productTriangle T).mor\u2082 :=\n      Limits.Pi.hom_ext _ _ (fun j => by rw [hb]; simp)\n    have : (a' + (by exact Pi.lift b) \u226b T'.mor\u2082) \u226b \u03c6'.hom\u2083 = a := by\n      rw [add_comp, assoc, \u03c6'.comm\u2082, h\u2082, id_comp, \u2190 hb', add_sub_cancel'_right]\n    exact \u27e8_, this\u27e9", "start": [548, 1], "end": [616, 20], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Nat/Factorial/BigOperators.lean", "imports": ["Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.prod_factorial_pos", "code": "theorem prod_factorial_pos : 0 < \u220f i in s, (f i)!", "start": [28, 1], "end": [29, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_factorial_dvd_factorial_sum", "code": "theorem prod_factorial_dvd_factorial_sum : (\u220f i in s, (f i)!) \u2223 (\u2211 i in s, f i)!", "start": [32, 1], "end": [38, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_eq_prod_range", "code": "theorem descFactorial_eq_prod_range (n : \u2115) : \u2200 k, n.descFactorial k = \u220f i in range k, (n - i)", "start": [41, 1], "end": [43, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Sym.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Fintype/Vector.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Prod.lean", "Mathlib/Data/Sym/Sym2.lean"], "premises": [{"full_name": "Finset.isDiag_mk'_of_mem_diag", "code": "theorem isDiag_mk'_of_mem_diag {a : \u03b1 \u00d7 \u03b1} (h : a \u2208 s.diag) : Sym2.IsDiag \u27e6a\u27e7", "start": [37, 1], "end": [38, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.not_isDiag_mk'_of_mem_offDiag", "code": "theorem not_isDiag_mk'_of_mem_offDiag {a : \u03b1 \u00d7 \u03b1} (h : a \u2208 s.offDiag) : \u00acSym2.IsDiag \u27e6a\u27e7", "start": [41, 1], "end": [43, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2", "code": "protected def sym2 (s : Finset \u03b1) : Finset (Sym2 \u03b1) := (s \u00d7\u02e2 s).image Quotient.mk'", "start": [50, 1], "end": [51, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sym2_iff", "code": "@[simp]\ntheorem mem_sym2_iff : m \u2208 s.sym2 \u2194 \u2200 a \u2208 m, a \u2208 s", "start": [54, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.mk'_mem_sym2_iff", "code": "theorem mk'_mem_sym2_iff : \u27e6(a, b)\u27e7 \u2208 s.sym2 \u2194 a \u2208 s \u2227 b \u2208 s", "start": [64, 1], "end": [64, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2_empty", "code": "@[simp]\ntheorem sym2_empty : (\u2205 : Finset \u03b1).sym2 = \u2205", "start": [67, 1], "end": [68, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2_eq_empty", "code": "@[simp]\ntheorem sym2_eq_empty : s.sym2 = \u2205 \u2194 s = \u2205", "start": [71, 1], "end": [73, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2_nonempty", "code": "@[simp]\ntheorem sym2_nonempty : s.sym2.Nonempty \u2194 s.Nonempty", "start": [76, 1], "end": [78, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty.sym2", "code": "alias \u27e8_, nonempty.sym2\u27e9 := sym2_nonempty", "start": [81, 1], "end": [81, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.sym2_univ", "code": "@[simp]\ntheorem sym2_univ [Fintype \u03b1] : (univ : Finset \u03b1).sym2 = univ", "start": [87, 1], "end": [90, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2_singleton", "code": "@[simp]\ntheorem sym2_singleton (a : \u03b1) : ({a} : Finset \u03b1).sym2 = {Sym2.diag a}", "start": [93, 1], "end": [95, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_mem_sym2_mem_iff", "code": "@[simp]\ntheorem diag_mem_sym2_mem_iff : (\u2200 b, b \u2208 Sym2.diag a \u2192 b \u2208 s) \u2194 a \u2208 s", "start": [100, 1], "end": [103, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_mem_sym2_iff", "code": "theorem diag_mem_sym2_iff : Sym2.diag a \u2208 s.sym2 \u2194 a \u2208 s", "start": [105, 1], "end": [105, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.sym2_mono", "code": "@[simp]\ntheorem sym2_mono (h : s \u2286 t) : s.sym2 \u2286 t.sym2", "start": [108, 1], "end": [110, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.image_diag_union_image_offDiag", "code": "theorem image_diag_union_image_offDiag :\n    s.diag.image Quotient.mk' \u222a s.offDiag.image Quotient.mk' = s.sym2", "start": [113, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sym", "code": "protected def sym (s : Finset \u03b1) : \u2200 n, Finset (Sym \u03b1 n)\n  | 0 => {\u2205}\n  | n + 1 => s.sup fun a \u21a6 Finset.image (Sym.cons a) (s.sym n)", "start": [128, 1], "end": [132, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_zero", "code": "@[simp]\ntheorem sym_zero : s.sym 0 = {\u2205}", "start": [135, 1], "end": [136, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_succ", "code": "@[simp]\ntheorem sym_succ : s.sym (n + 1) = s.sup fun a \u21a6 (s.sym n).image <| Sym.cons a", "start": [139, 1], "end": [140, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sym_iff", "code": "@[simp]\ntheorem mem_sym_iff : m \u2208 s.sym n \u2194 \u2200 a \u2208 m, a \u2208 s", "start": [143, 1], "end": [160, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_empty", "code": "@[simp]\ntheorem sym_empty (n : \u2115) : (\u2205 : Finset \u03b1).sym (n + 1) = \u2205", "start": [163, 1], "end": [164, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.replicate_mem_sym", "code": "theorem replicate_mem_sym (ha : a \u2208 s) (n : \u2115) : Sym.replicate n a \u2208 s.sym n", "start": [167, 1], "end": [168, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.sym", "code": "protected theorem Nonempty.sym (h : s.Nonempty) (n : \u2115) : (s.sym n).Nonempty", "start": [171, 1], "end": [173, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_singleton", "code": "@[simp]\ntheorem sym_singleton (a : \u03b1) (n : \u2115) : ({a} : Finset \u03b1).sym n = {Sym.replicate n a}", "start": [176, 1], "end": [180, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_of_sym_eq_empty", "code": "theorem eq_empty_of_sym_eq_empty (h : s.sym n = \u2205) : s = \u2205", "start": [183, 1], "end": [185, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_eq_empty", "code": "@[simp]\ntheorem sym_eq_empty : s.sym n = \u2205 \u2194 n \u2260 0 \u2227 s = \u2205", "start": [188, 1], "end": [194, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_nonempty", "code": "@[simp]\ntheorem sym_nonempty : (s.sym n).Nonempty \u2194 n = 0 \u2228 s.Nonempty", "start": [197, 1], "end": [201, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_univ", "code": "@[simp]\ntheorem sym_univ [Fintype \u03b1] (n : \u2115) : (univ : Finset \u03b1).sym n = univ", "start": [204, 1], "end": [206, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_mono", "code": "@[simp]\ntheorem sym_mono (h : s \u2286 t) (n : \u2115) : s.sym n \u2286 t.sym n", "start": [209, 1], "end": [211, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_inter", "code": "@[simp]\ntheorem sym_inter (s t : Finset \u03b1) (n : \u2115) : (s \u2229 t).sym n = s.sym n \u2229 t.sym n", "start": [214, 1], "end": [217, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_union", "code": "@[simp]\ntheorem sym_union (s t : Finset \u03b1) (n : \u2115) : s.sym n \u222a t.sym n \u2286 (s \u222a t).sym n", "start": [220, 1], "end": [222, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_fill_mem", "code": "theorem sym_fill_mem (a : \u03b1) {i : Fin (n + 1)} {m : Sym \u03b1 (n - i)} (h : m \u2208 s.sym (n - i)) :\n    m.fill a i \u2208 (insert a s).sym n", "start": [225, 1], "end": [228, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.sym_filterNe_mem", "code": "theorem sym_filterNe_mem (a : \u03b1) (h : m \u2208 s.sym n) :\n    (m.filterNe a).2 \u2208 (Finset.erase s a).sym (n - (m.filterNe a).1)", "start": [231, 1], "end": [234, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.symInsertEquiv", "code": "@[simps]\ndef symInsertEquiv (h : a \u2209 s) : (insert a s).sym n \u2243 \u03a3i : Fin (n + 1), s.sym (n - i)\n    where\n  toFun m := \u27e8_, (m.1.filterNe a).2, by convert sym_filterNe_mem a m.2; rw [erase_insert h]\u27e9\n  invFun m := \u27e8m.2.1.fill a m.1, sym_fill_mem a m.2.2\u27e9\n  left_inv m := Subtype.ext <| m.1.fill_filterNe a\n  right_inv := fun \u27e8i, m, hm\u27e9 \u21a6 by\n    refine' Function.Injective.sigma_map (Function.injective_id) (fun i \u21a6 _) _\n    exact fun i \u21a6 Sym \u03b1 (n - i)\n    swap; exact Subtype.coe_injective\n    refine Eq.trans ?_ (Sym.filter_ne_fill a _ ?_)\n    exacts [rfl, h \u2218 mem_sym_iff.1 hm a]", "start": [237, 1], "end": [251, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/Centering.lean", "imports": ["Mathlib/Probability/Martingale/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.predictablePart", "code": "noncomputable def predictablePart {m0 : MeasurableSpace \u03a9} (f : \u2115 \u2192 \u03a9 \u2192 E) (\u2131 : Filtration \u2115 m0)\n    (\u03bc : Measure \u03a9) : \u2115 \u2192 \u03a9 \u2192 E := fun n => \u2211 i in Finset.range n, \u03bc[f (i + 1) - f i|\u2131 i]", "start": [43, 1], "end": [46, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.predictablePart_zero", "code": "@[simp]\ntheorem predictablePart_zero : predictablePart f \u2131 \u03bc 0 = 0", "start": [49, 1], "end": [51, 65], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.adapted_predictablePart", "code": "theorem adapted_predictablePart : Adapted \u2131 fun n => predictablePart f \u2131 \u03bc (n + 1)", "start": [54, 1], "end": [56, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.adapted_predictablePart'", "code": "theorem adapted_predictablePart' : Adapted \u2131 fun n => predictablePart f \u2131 \u03bc n", "start": [59, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingalePart", "code": "noncomputable def martingalePart {m0 : MeasurableSpace \u03a9} (f : \u2115 \u2192 \u03a9 \u2192 E) (\u2131 : Filtration \u2115 m0)\n    (\u03bc : Measure \u03a9) : \u2115 \u2192 \u03a9 \u2192 E := fun n => f n - predictablePart f \u2131 \u03bc n", "start": [64, 1], "end": [67, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingalePart_add_predictablePart", "code": "theorem martingalePart_add_predictablePart (\u2131 : Filtration \u2115 m0) (\u03bc : Measure \u03a9) (f : \u2115 \u2192 \u03a9 \u2192 E) :\n    martingalePart f \u2131 \u03bc + predictablePart f \u2131 \u03bc = f", "start": [70, 1], "end": [72, 21], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingalePart_eq_sum", "code": "theorem martingalePart_eq_sum : martingalePart f \u2131 \u03bc = fun n =>\n    f 0 + \u2211 i in Finset.range n, (f (i + 1) - f i - \u03bc[f (i + 1) - f i|\u2131 i])", "start": [75, 1], "end": [79, 72], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.adapted_martingalePart", "code": "theorem adapted_martingalePart (hf : Adapted \u2131 f) : Adapted \u2131 (martingalePart f \u2131 \u03bc)", "start": [82, 1], "end": [83, 42], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.integrable_martingalePart", "code": "theorem integrable_martingalePart (hf_int : \u2200 n, Integrable (f n) \u03bc) (n : \u2115) :\n    Integrable (martingalePart f \u2131 \u03bc n) \u03bc", "start": [86, 1], "end": [90, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingale_martingalePart", "code": "theorem martingale_martingalePart (hf : Adapted \u2131 f) (hf_int : \u2200 n, Integrable (f n) \u03bc)\n    [SigmaFiniteFiltration \u03bc \u2131] : Martingale (martingalePart f \u2131 \u03bc) \u2131 \u03bc", "start": [93, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingalePart_add_ae_eq", "code": "theorem martingalePart_add_ae_eq [SigmaFiniteFiltration \u03bc \u2131] {f g : \u2115 \u2192 \u03a9 \u2192 E}\n    (hf : Martingale f \u2131 \u03bc) (hg : Adapted \u2131 fun n => g (n + 1)) (hg0 : g 0 = 0)\n    (hgint : \u2200 n, Integrable (g n) \u03bc) (n : \u2115) : martingalePart (f + g) \u2131 \u03bc n =\u1d50[\u03bc] f n", "start": [135, 1], "end": [153, 13], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.predictablePart_add_ae_eq", "code": "theorem predictablePart_add_ae_eq [SigmaFiniteFiltration \u03bc \u2131] {f g : \u2115 \u2192 \u03a9 \u2192 E}\n    (hf : Martingale f \u2131 \u03bc) (hg : Adapted \u2131 fun n => g (n + 1)) (hg0 : g 0 = 0)\n    (hgint : \u2200 n, Integrable (g n) \u03bc) (n : \u2115) : predictablePart (f + g) \u2131 \u03bc n =\u1d50[\u03bc] g n", "start": [156, 1], "end": [162, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.predictablePart_bdd_difference", "code": "theorem predictablePart_bdd_difference {R : \u211d\u22650} {f : \u2115 \u2192 \u03a9 \u2192 \u211d} (\u2131 : Filtration \u2115 m0)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |predictablePart f \u2131 \u03bc (i + 1) \u03c9 - predictablePart f \u2131 \u03bc i \u03c9| \u2264 R", "start": [167, 1], "end": [171, 78], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.martingalePart_bdd_difference", "code": "theorem martingalePart_bdd_difference {R : \u211d\u22650} {f : \u2115 \u2192 \u03a9 \u2192 \u211d} (\u2131 : Filtration \u2115 m0)\n    (hbdd : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |f (i + 1) \u03c9 - f i \u03c9| \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 i, |martingalePart f \u2131 \u03bc (i + 1) \u03c9 - martingalePart f \u2131 \u03bc i \u03c9| \u2264 \u2191(2 * R)", "start": [174, 1], "end": [183, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/OptionalStopping.lean", "imports": ["Mathlib/Probability/Martingale/Basic.lean", "Mathlib/Probability/Process/HittingTime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.Submartingale.expected_stoppedValue_mono", "code": "theorem Submartingale.expected_stoppedValue_mono [SigmaFiniteFiltration \u03bc \ud835\udca2]\n    (hf : Submartingale f \ud835\udca2 \u03bc) (h\u03c4 : IsStoppingTime \ud835\udca2 \u03c4) (h\u03c0 : IsStoppingTime \ud835\udca2 \u03c0) (hle : \u03c4 \u2264 \u03c0)\n    {N : \u2115} (hbdd : \u2200 \u03c9, \u03c0 \u03c9 \u2264 N) : \u03bc[stoppedValue f \u03c4] \u2264 \u03bc[stoppedValue f \u03c0]", "start": [39, 1], "end": [63, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.submartingale_of_expected_stoppedValue_mono", "code": "theorem submartingale_of_expected_stoppedValue_mono [IsFiniteMeasure \u03bc] (hadp : Adapted \ud835\udca2 f)\n    (hint : \u2200 i, Integrable (f i) \u03bc) (hf : \u2200 \u03c4 \u03c0 : \u03a9 \u2192 \u2115, IsStoppingTime \ud835\udca2 \u03c4 \u2192 IsStoppingTime \ud835\udca2 \u03c0 \u2192\n      \u03c4 \u2264 \u03c0 \u2192 (\u2203 N, \u2200 \u03c9, \u03c0 \u03c9 \u2264 N) \u2192 \u03bc[stoppedValue f \u03c4] \u2264 \u03bc[stoppedValue f \u03c0]) :\n    Submartingale f \ud835\udca2 \u03bc", "start": [66, 1], "end": [80, 75], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.submartingale_iff_expected_stoppedValue_mono", "code": "theorem submartingale_iff_expected_stoppedValue_mono [IsFiniteMeasure \u03bc] (hadp : Adapted \ud835\udca2 f)\n    (hint : \u2200 i, Integrable (f i) \u03bc) :\n    Submartingale f \ud835\udca2 \u03bc \u2194 \u2200 \u03c4 \u03c0 : \u03a9 \u2192 \u2115, IsStoppingTime \ud835\udca2 \u03c4 \u2192 IsStoppingTime \ud835\udca2 \u03c0 \u2192\n      \u03c4 \u2264 \u03c0 \u2192 (\u2203 N, \u2200 x, \u03c0 x \u2264 N) \u2192 \u03bc[stoppedValue f \u03c4] \u2264 \u03bc[stoppedValue f \u03c0]", "start": [83, 1], "end": [91, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.stoppedProcess", "code": "protected theorem Submartingale.stoppedProcess [IsFiniteMeasure \u03bc] (h : Submartingale f \ud835\udca2 \u03bc)\n    (h\u03c4 : IsStoppingTime \ud835\udca2 \u03c4) : Submartingale (stoppedProcess f \u03c4) \ud835\udca2 \u03bc", "start": [94, 1], "end": [105, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.smul_le_stoppedValue_hitting", "code": "theorem smul_le_stoppedValue_hitting [IsFiniteMeasure \u03bc] (hsub : Submartingale f \ud835\udca2 \u03bc) {\u03b5 : \u211d\u22650}\n    (n : \u2115) : \u03b5 \u2022 \u03bc {\u03c9 | (\u03b5 : \u211d) \u2264 (range (n + 1)).sup' nonempty_range_succ fun k => f k \u03c9} \u2264\n    ENNReal.ofReal (\u222b \u03c9 in {\u03c9 | (\u03b5 : \u211d) \u2264 (range (n + 1)).sup' nonempty_range_succ fun k => f k \u03c9},\n      stoppedValue f (hitting f {y : \u211d | \u2191\u03b5 \u2264 y} 0 n) \u03c9 \u2202\u03bc)", "start": [112, 1], "end": [133, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.maximal_ineq", "code": "theorem maximal_ineq [IsFiniteMeasure \u03bc] (hsub : Submartingale f \ud835\udca2 \u03bc) (hnonneg : 0 \u2264 f) {\u03b5 : \u211d\u22650}\n    (n : \u2115) : \u03b5 \u2022 \u03bc {\u03c9 | (\u03b5 : \u211d) \u2264 (range (n + 1)).sup' nonempty_range_succ fun k => f k \u03c9} \u2264\n    ENNReal.ofReal (\u222b \u03c9 in {\u03c9 | (\u03b5 : \u211d) \u2264 (range (n + 1)).sup' nonempty_range_succ fun k => f k \u03c9},\n      f n \u03c9 \u2202\u03bc)", "start": [136, 1], "end": [218, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Martingale/Convergence.lean", "imports": ["Mathlib/Probability/Martingale/Upcrossing.lean", "Mathlib/MeasureTheory/Function/UniformIntegrable.lean", "Mathlib/MeasureTheory/Constructions/Polish.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.not_frequently_of_upcrossings_lt_top", "code": "theorem not_frequently_of_upcrossings_lt_top (hab : a < b) (h\u03c9 : upcrossings a b f \u03c9 \u2260 \u221e) :\n    \u00ac((\u2203\u1da0 n in atTop, f n \u03c9 < a) \u2227 \u2203\u1da0 n in atTop, b < f n \u03c9)", "start": [109, 1], "end": [128, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.upcrossings_eq_top_of_frequently_lt", "code": "theorem upcrossings_eq_top_of_frequently_lt (hab : a < b) (h\u2081 : \u2203\u1da0 n in atTop, f n \u03c9 < a)\n    (h\u2082 : \u2203\u1da0 n in atTop, b < f n \u03c9) : upcrossings a b f \u03c9 = \u221e", "start": [131, 1], "end": [134, 80], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_of_uncrossing_lt_top", "code": "theorem tendsto_of_uncrossing_lt_top (hf\u2081 : liminf (fun n => (\u2016f n \u03c9\u2016\u208a : \u211d\u22650\u221e)) atTop < \u221e)\n    (hf\u2082 : \u2200 a b : \u211a, a < b \u2192 upcrossings a b f \u03c9 < \u221e) :\n    \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [137, 1], "end": [153, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.upcrossings_ae_lt_top'", "code": "theorem Submartingale.upcrossings_ae_lt_top' [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) 1 \u03bc \u2264 R) (hab : a < b) : \u2200\u1d50 \u03c9 \u2202\u03bc, upcrossings a b f \u03c9 < \u221e", "start": [156, 1], "end": [185, 74], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.upcrossings_ae_lt_top", "code": "theorem Submartingale.upcrossings_ae_lt_top [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) 1 \u03bc \u2264 R) : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2200 a b : \u211a, a < b \u2192 upcrossings a b f \u03c9 < \u221e", "start": [188, 1], "end": [192, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.exists_ae_tendsto_of_bdd", "code": "theorem Submartingale.exists_ae_tendsto_of_bdd [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) 1 \u03bc \u2264 R) : \u2200\u1d50 \u03c9 \u2202\u03bc, \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [195, 1], "end": [200, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.exists_ae_trim_tendsto_of_bdd", "code": "theorem Submartingale.exists_ae_trim_tendsto_of_bdd [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) 1 \u03bc \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc.trim (sSup_le fun m \u27e8n, hn\u27e9 => hn \u25b8 \u2131.le _ : \u2a06 n, \u2131 n \u2264 m0),\n      \u2203 c, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd c)", "start": [203, 1], "end": [211, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.ae_tendsto_limitProcess", "code": "theorem Submartingale.ae_tendsto_limitProcess [IsFiniteMeasure \u03bc] (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) 1 \u03bc \u2264 R) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd (\u2131.limitProcess f \u03bc \u03c9))", "start": [214, 1], "end": [238, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.mem\u2112p_limitProcess", "code": "theorem Submartingale.mem\u2112p_limitProcess {p : \u211d\u22650\u221e} (hf : Submartingale f \u2131 \u03bc)\n    (hbdd : \u2200 n, snorm (f n) p \u03bc \u2264 R) : Mem\u2112p (\u2131.limitProcess f \u03bc) p \u03bc", "start": [241, 1], "end": [245, 83], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.tendsto_snorm_one_limitProcess", "code": "theorem Submartingale.tendsto_snorm_one_limitProcess (hf : Submartingale f \u2131 \u03bc)\n    (hunif : UniformIntegrable f 1 \u03bc) :\n    Tendsto (fun n => snorm (f n - \u2131.limitProcess f \u03bc) 1 \u03bc) atTop (\ud835\udcdd 0)", "start": [318, 1], "end": [329, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable", "code": "theorem Submartingale.ae_tendsto_limitProcess_of_uniformIntegrable (hf : Submartingale f \u2131 \u03bc)\n    (hunif : UniformIntegrable f 1 \u03bc) :\n    \u2200\u1d50 \u03c9 \u2202\u03bc, Tendsto (fun n => f n \u03c9) atTop (\ud835\udcdd (\u2131.limitProcess f \u03bc \u03c9))", "start": [332, 1], "end": [336, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.eq_condexp_of_tendsto_snorm", "code": "theorem Martingale.eq_condexp_of_tendsto_snorm {\u03bc : Measure \u03a9} (hf : Martingale f \u2131 \u03bc)\n    (hg : Integrable g \u03bc) (hgtends : Tendsto (fun n => snorm (f n - g) 1 \u03bc) atTop (\ud835\udcdd 0)) (n : \u2115) :\n    f n =\u1d50[\u03bc] \u03bc[g|\u2131 n]", "start": [339, 1], "end": [354, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Martingale.ae_eq_condexp_limitProcess", "code": "theorem Martingale.ae_eq_condexp_limitProcess (hf : Martingale f \u2131 \u03bc)\n    (hbdd : UniformIntegrable f 1 \u03bc) (n : \u2115) : f n =\u1d50[\u03bc] \u03bc[\u2131.limitProcess f \u03bc|\u2131 n]", "start": [357, 1], "end": [364, 61], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.tendsto_ae_condexp", "code": "theorem Integrable.tendsto_ae_condexp (hg : Integrable g \u03bc)\n    (hgmeas : StronglyMeasurable[\u2a06 n, \u2131 n] g) :\n    \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => (\u03bc[g|\u2131 n]) x) atTop (\ud835\udcdd (g x))", "start": [367, 1], "end": [420, 57], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.tendsto_snorm_condexp", "code": "theorem Integrable.tendsto_snorm_condexp (hg : Integrable g \u03bc)\n    (hgmeas : StronglyMeasurable[\u2a06 n, \u2131 n] g) :\n    Tendsto (fun n => snorm (\u03bc[g|\u2131 n] - g) 1 \u03bc) atTop (\ud835\udcdd 0)", "start": [423, 1], "end": [437, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_ae_condexp", "code": "theorem tendsto_ae_condexp (g : \u03a9 \u2192 \u211d) :\n    \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => (\u03bc[g|\u2131 n]) x) atTop (\ud835\udcdd ((\u03bc[g|\u2a06 n, \u2131 n]) x))", "start": [440, 1], "end": [450, 23], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.tendsto_snorm_condexp", "code": "theorem tendsto_snorm_condexp (g : \u03a9 \u2192 \u211d) :\n    Tendsto (fun n => snorm (\u03bc[g|\u2131 n] - \u03bc[g|\u2a06 n, \u2131 n]) 1 \u03bc) atTop (\ud835\udcdd 0)", "start": [453, 1], "end": [463, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Bitraversable/Basic.lean", "imports": ["Mathlib/Control/Traversable/Basic.lean", "Mathlib/Control/Bifunctor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bitraversable", "code": "class Bitraversable (t : Type u \u2192 Type u \u2192 Type u) extends Bifunctor t where\n  bitraverse :\n    \u2200 {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b1' \u03b2 \u03b2'},\n      (\u03b1 \u2192 m \u03b1') \u2192 (\u03b2 \u2192 m \u03b2') \u2192 t \u03b1 \u03b2 \u2192 m (t \u03b1' \u03b2')", "start": [45, 1], "end": [49, 52], "kind": "commanddeclaration"}, {"full_name": "bisequence", "code": "def bisequence {t m} [Bitraversable t] [Applicative m] {\u03b1 \u03b2} : t (m \u03b1) (m \u03b2) \u2192 m (t \u03b1 \u03b2) :=\n  bitraverse id id", "start": [54, 1], "end": [56, 19], "kind": "commanddeclaration"}, {"full_name": "LawfulBitraversable", "code": "class LawfulBitraversable (t : Type u \u2192 Type u \u2192 Type u) [Bitraversable t] extends\n  LawfulBifunctor t : Prop where\n  id_bitraverse : \u2200 {\u03b1 \u03b2} (x : t \u03b1 \u03b2), bitraverse (m := Id) pure pure x = pure x\n  comp_bitraverse :\n    \u2200 {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      {\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3'} (f : \u03b2 \u2192 F \u03b3) (f' : \u03b2' \u2192 F \u03b3') (g : \u03b1 \u2192 G \u03b2) (g' : \u03b1' \u2192 G \u03b2') (x : t \u03b1 \u03b1'),\n      bitraverse (Comp.mk \u2218 map f \u2218 g) (Comp.mk \u2218 map f' \u2218 g') x =\n        Comp.mk (bitraverse f f' <$> bitraverse g g' x)\n  bitraverse_eq_bimap_id :\n    \u2200 {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 \u03b2) (f' : \u03b1' \u2192 \u03b2') (x : t \u03b1 \u03b1'),\n      bitraverse (m := Id) (pure \u2218 f) (pure \u2218 f') x = pure (bimap f f' x)\n  binaturality :\n    \u2200 {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (\u03b7 : ApplicativeTransformation F G) {\u03b1 \u03b1' \u03b2 \u03b2'} (f : \u03b1 \u2192 F \u03b2) (f' : \u03b1' \u2192 F \u03b2') (x : t \u03b1 \u03b1'),\n      \u03b7 (bitraverse f f' x) = bitraverse (@\u03b7 _ \u2218 f) (@\u03b7 _ \u2218 f') x", "start": [61, 1], "end": [77, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Hall/Finite.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HallMarriageTheorem.hall_cond_of_erase", "code": "theorem hall_cond_of_erase {x : \u03b9} (a : \u03b1)\n    (ha : \u2200 s : Finset \u03b9, s.Nonempty \u2192 s \u2260 univ \u2192 s.card < (s.biUnion t).card)\n    (s' : Finset { x' : \u03b9 | x' \u2260 x }) : s'.card \u2264 (s'.biUnion fun x' => (t x').erase a).card", "start": [50, 1], "end": [70, 9], "kind": "commanddeclaration"}, {"full_name": "HallMarriageTheorem.hall_hard_inductive_step_A", "code": "theorem hall_hard_inductive_step_A {n : \u2115} (hn : Fintype.card \u03b9 = n + 1)\n    (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card)\n    (ih :\n      \u2200 {\u03b9' : Type u} [Fintype \u03b9'] (t' : \u03b9' \u2192 Finset \u03b1),\n        Fintype.card \u03b9' \u2264 n \u2192\n          (\u2200 s' : Finset \u03b9', s'.card \u2264 (s'.biUnion t').card) \u2192\n            \u2203 f : \u03b9' \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t' x)\n    (ha : \u2200 s : Finset \u03b9, s.Nonempty \u2192 s \u2260 univ \u2192 s.card < (s.biUnion t).card) :\n    \u2203 f : \u03b9 \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t x", "start": [73, 1], "end": [121, 18], "kind": "commanddeclaration"}, {"full_name": "HallMarriageTheorem.hall_cond_of_restrict", "code": "theorem hall_cond_of_restrict {\u03b9 : Type u} {t : \u03b9 \u2192 Finset \u03b1} {s : Finset \u03b9}\n    (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card) (s' : Finset (s : Set \u03b9)) :\n    s'.card \u2264 (s'.biUnion fun a' => t a').card", "start": [125, 1], "end": [133, 9], "kind": "commanddeclaration"}, {"full_name": "HallMarriageTheorem.hall_cond_of_compl", "code": "theorem hall_cond_of_compl {\u03b9 : Type u} {t : \u03b9 \u2192 Finset \u03b1} {s : Finset \u03b9}\n    (hus : s.card = (s.biUnion t).card) (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card)\n    (s' : Finset (s\u1d9c : Set \u03b9)) : s'.card \u2264 (s'.biUnion fun x' => t x' \\ s.biUnion t).card", "start": [136, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "HallMarriageTheorem.hall_hard_inductive_step_B", "code": "theorem hall_hard_inductive_step_B {n : \u2115} (hn : Fintype.card \u03b9 = n + 1)\n    (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card)\n    (ih :\n      \u2200 {\u03b9' : Type u} [Fintype \u03b9'] (t' : \u03b9' \u2192 Finset \u03b1),\n        Fintype.card \u03b9' \u2264 n \u2192\n          (\u2200 s' : Finset \u03b9', s'.card \u2264 (s'.biUnion t').card) \u2192\n            \u2203 f : \u03b9' \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t' x)\n    (s : Finset \u03b9) (hs : s.Nonempty) (hns : s \u2260 univ) (hus : s.card = (s.biUnion t).card) :\n    \u2203 f : \u03b9 \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t x", "start": [161, 1], "end": [215, 44], "kind": "commanddeclaration"}, {"full_name": "HallMarriageTheorem.hall_hard_inductive", "code": "theorem hall_hard_inductive (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card) :\n    \u2203 f : \u03b9 \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t x", "start": [223, 1], "end": [243, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.all_card_le_biUnion_card_iff_existsInjective'", "code": "theorem Finset.all_card_le_biUnion_card_iff_existsInjective' {\u03b9 \u03b1 : Type*} [Finite \u03b9]\n    [DecidableEq \u03b1] (t : \u03b9 \u2192 Finset \u03b1) :\n    (\u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card) \u2194\n      \u2203 f : \u03b9 \u2192 \u03b1, Function.Injective f \u2227 \u2200 x, f x \u2208 t x", "start": [248, 1], "end": [268, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Derivation/ToSquareZero.lean", "imports": ["Mathlib/RingTheory/Derivation/Basic.lean", "Mathlib/RingTheory/Ideal/QuotientOperations.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "diffToIdealOfQuotientCompEq", "code": "def diffToIdealOfQuotientCompEq (f\u2081 f\u2082 : A \u2192\u2090[R] B)\n    (e : (Ideal.Quotient.mk\u2090 R I).comp f\u2081 = (Ideal.Quotient.mk\u2090 R I).comp f\u2082) : A \u2192\u2097[R] I :=\n  LinearMap.codRestrict (I.restrictScalars _) (f\u2081.toLinearMap - f\u2082.toLinearMap) (by\n    intro x\n    change f\u2081 x - f\u2082 x \u2208 I\n    rw [\u2190 Ideal.Quotient.eq, \u2190 Ideal.Quotient.mk\u2090_eq_mk R, \u2190 AlgHom.comp_apply, e]\n    rfl)", "start": [28, 1], "end": [36, 9], "kind": "commanddeclaration"}, {"full_name": "diffToIdealOfQuotientCompEq_apply", "code": "@[simp]\ntheorem diffToIdealOfQuotientCompEq_apply (f\u2081 f\u2082 : A \u2192\u2090[R] B)\n    (e : (Ideal.Quotient.mk\u2090 R I).comp f\u2081 = (Ideal.Quotient.mk\u2090 R I).comp f\u2082) (x : A) :\n    ((diffToIdealOfQuotientCompEq I f\u2081 f\u2082 e) x : B) = f\u2081 x - f\u2082 x", "start": [39, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "derivationToSquareZeroOfLift", "code": "def derivationToSquareZeroOfLift (f : A \u2192\u2090[R] B)\n    (e : (Ideal.Quotient.mk\u2090 R I).comp f = IsScalarTower.toAlgHom R A (B \u29f8 I)) :\n    Derivation R A I := by\n  refine'\n    { diffToIdealOfQuotientCompEq I f (IsScalarTower.toAlgHom R A B) _ with\n      map_one_eq_zero' := _\n      leibniz' := _ }\n  \u00b7 rw [e]; ext; rfl\n  \u00b7 ext; change f 1 - algebraMap A B 1 = 0; rw [map_one, map_one, sub_self]\n  \u00b7 intro x y\n    let F := diffToIdealOfQuotientCompEq I f (IsScalarTower.toAlgHom R A B) (by rw [e]; ext; rfl)\n    have : (f x - algebraMap A B x) * (f y - algebraMap A B y) = 0 := by\n      rw [\u2190 Ideal.mem_bot, \u2190 hI, pow_two]\n      convert Ideal.mul_mem_mul (F x).2 (F y).2 using 1\n    ext\n    dsimp only [Submodule.coe_add, Submodule.coe_mk, LinearMap.coe_mk,\n      diffToIdealOfQuotientCompEq_apply, Submodule.coe_smul_of_tower, IsScalarTower.coe_toAlgHom',\n      LinearMap.toFun_eq_coe]\n    simp only [map_mul, sub_mul, mul_sub, Algebra.smul_def] at this \u22a2\n    rw [sub_eq_iff_eq_add, sub_eq_iff_eq_add] at this\n    simp only [LinearMap.coe_toAddHom, diffToIdealOfQuotientCompEq_apply, map_mul, this,\n      IsScalarTower.coe_toAlgHom']\n    ring", "start": [48, 1], "end": [72, 9], "kind": "commanddeclaration"}, {"full_name": "derivationToSquareZeroOfLift_apply", "code": "theorem derivationToSquareZeroOfLift_apply (f : A \u2192\u2090[R] B)\n    (e : (Ideal.Quotient.mk\u2090 R I).comp f = IsScalarTower.toAlgHom R A (B \u29f8 I)) (x : A) :\n    (derivationToSquareZeroOfLift I hI f e x : B) = f x - algebraMap A B x", "start": [75, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "liftOfDerivationToSquareZero", "code": "@[simps (config := { isSimp := false })]\ndef liftOfDerivationToSquareZero (f : Derivation R A I) : A \u2192\u2090[R] B :=\n  { ((I.restrictScalars R).subtype.comp f.toLinearMap + (IsScalarTower.toAlgHom R A B).toLinearMap :\n      A \u2192\u2097[R] B) with\n    toFun := fun x => f x + algebraMap A B x\n    map_one' := by dsimp; rw [map_one, f.map_one_eq_zero, Submodule.coe_zero, zero_add]\n    map_mul' := fun x y => by\n      have : (f x : B) * f y = 0 := by\n        rw [\u2190 Ideal.mem_bot, \u2190 hI, pow_two]\n        convert Ideal.mul_mem_mul (f x).2 (f y).2 using 1\n      simp only [map_mul, f.leibniz, add_mul, mul_add, Submodule.coe_add,\n        Submodule.coe_smul_of_tower, Algebra.smul_def, this]\n      ring\n    commutes' := fun r => by\n      simp only [Derivation.map_algebraMap, eq_self_iff_true, zero_add, Submodule.coe_zero, \u2190\n        IsScalarTower.algebraMap_apply R A B r]\n    map_zero' := ((I.restrictScalars R).subtype.comp f.toLinearMap +\n      (IsScalarTower.toAlgHom R A B).toLinearMap).map_zero }", "start": [81, 1], "end": [100, 61], "kind": "commanddeclaration"}, {"full_name": "liftOfDerivationToSquareZero_mk_apply", "code": "theorem liftOfDerivationToSquareZero_mk_apply (d : Derivation R A I) (x : A) :\n    Ideal.Quotient.mk I (liftOfDerivationToSquareZero I hI d x) = algebraMap A (B \u29f8 I) x", "start": [104, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "liftOfDerivationToSquareZero_mk_apply'", "code": "@[simp]\ntheorem liftOfDerivationToSquareZero_mk_apply' (d : Derivation R A I) (x : A) :\n    (Ideal.Quotient.mk I) (d x) + (algebraMap A (B \u29f8 I)) x = algebraMap A (B \u29f8 I) x", "start": [111, 1], "end": [114, 70], "kind": "commanddeclaration"}, {"full_name": "derivationToSquareZeroEquivLift", "code": "@[simps!]\ndef derivationToSquareZeroEquivLift : Derivation R A I \u2243\n    { f : A \u2192\u2090[R] B // (Ideal.Quotient.mk\u2090 R I).comp f = IsScalarTower.toAlgHom R A (B \u29f8 I) } := by\n  refine' \u27e8fun d => \u27e8liftOfDerivationToSquareZero I hI d, _\u27e9, fun f =>\n    (derivationToSquareZeroOfLift I hI f.1 f.2 : _), _, _\u27e9\n  \u00b7 ext x; exact liftOfDerivationToSquareZero_mk_apply I hI d x\n  \u00b7 intro d; ext x; exact add_sub_cancel (d x : B) (algebraMap A B x)\n  \u00b7 rintro \u27e8f, hf\u27e9; ext x; exact sub_add_cancel (f x) (algebraMap A B x)", "start": [116, 1], "end": [126, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/PiTensorProduct.lean", "imports": ["Mathlib/LinearAlgebra/Multilinear/TensorProduct.lean", "Mathlib/GroupTheory/Congruence.lean", "Mathlib/Tactic/LibrarySearch.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PiTensorProduct.Eqv", "code": "inductive Eqv : FreeAddMonoid (R \u00d7 \u2200 i, s i) \u2192 FreeAddMonoid (R \u00d7 \u2200 i, s i) \u2192 Prop\n  | of_zero : \u2200 (r : R) (f : \u2200 i, s i) (i : \u03b9) (_ : f i = 0), Eqv (FreeAddMonoid.of (r, f)) 0\n  | of_zero_scalar : \u2200 f : \u2200 i, s i, Eqv (FreeAddMonoid.of (0, f)) 0\n  | of_add : \u2200 (_ : DecidableEq \u03b9) (r : R) (f : \u2200 i, s i) (i : \u03b9) (m\u2081 m\u2082 : s i),\n      Eqv (FreeAddMonoid.of (r, update f i m\u2081) + FreeAddMonoid.of (r, update f i m\u2082))\n        (FreeAddMonoid.of (r, update f i (m\u2081 + m\u2082)))\n  | of_add_scalar : \u2200 (r r' : R) (f : \u2200 i, s i),\n      Eqv (FreeAddMonoid.of (r, f) + FreeAddMonoid.of (r', f)) (FreeAddMonoid.of (r + r', f))\n  | of_smul : \u2200 (_ : DecidableEq \u03b9) (r : R) (f : \u2200 i, s i) (i : \u03b9) (r' : R),\n      Eqv (FreeAddMonoid.of (r, update f i (r' \u2022 f i))) (FreeAddMonoid.of (r' * r, f))\n  | add_comm : \u2200 x y, Eqv (x + y) (y + x)", "start": [89, 1], "end": [101, 42], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct", "code": "def PiTensorProduct : Type _ :=\n  (addConGen (PiTensorProduct.Eqv R s)).Quotient", "start": [108, 1], "end": [111, 49], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tprodCoeff", "code": "def tprodCoeff (r : R) (f : \u2200 i, s i) : \u2a02[R] i, s i :=\n  AddCon.mk' _ <| FreeAddMonoid.of (r, f)", "start": [138, 1], "end": [142, 42], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.zero_tprodCoeff", "code": "theorem zero_tprodCoeff (f : \u2200 i, s i) : tprodCoeff R 0 f = 0", "start": [147, 1], "end": [148, 66], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.zero_tprodCoeff'", "code": "theorem zero_tprodCoeff' (z : R) (f : \u2200 i, s i) (i : \u03b9) (hf : f i = 0) : tprodCoeff R z f = 0", "start": [151, 1], "end": [152, 66], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.add_tprodCoeff", "code": "theorem add_tprodCoeff [DecidableEq \u03b9] (z : R) (f : \u2200 i, s i) (i : \u03b9) (m\u2081 m\u2082 : s i) :\n    tprodCoeff R z (update f i m\u2081) + tprodCoeff R z (update f i m\u2082) =\n      tprodCoeff R z (update f i (m\u2081 + m\u2082))", "start": [155, 1], "end": [158, 69], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.add_tprodCoeff'", "code": "theorem add_tprodCoeff' (z\u2081 z\u2082 : R) (f : \u2200 i, s i) :\n    tprodCoeff R z\u2081 f + tprodCoeff R z\u2082 f = tprodCoeff R (z\u2081 + z\u2082) f", "start": [161, 1], "end": [163, 70], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.smul_tprodCoeff_aux", "code": "theorem smul_tprodCoeff_aux [DecidableEq \u03b9] (z : R) (f : \u2200 i, s i) (i : \u03b9) (r : R) :\n    tprodCoeff R z (update f i (r \u2022 f i)) = tprodCoeff R (r * z) f", "start": [166, 1], "end": [168, 67], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.smul_tprodCoeff", "code": "theorem smul_tprodCoeff [DecidableEq \u03b9] (z : R) (f : \u2200 i, s i) (i : \u03b9) (r : R\u2081) [SMul R\u2081 R]\n    [IsScalarTower R\u2081 R R] [SMul R\u2081 (s i)] [IsScalarTower R\u2081 R (s i)] :\n    tprodCoeff R z (update f i (r \u2022 f i)) = tprodCoeff R (r \u2022 z) f", "start": [171, 1], "end": [177, 36], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.liftAddHom", "code": "def liftAddHom (\u03c6 : (R \u00d7 \u2200 i, s i) \u2192 F)\n    (C0 : \u2200 (r : R) (f : \u2200 i, s i) (i : \u03b9) (_ : f i = 0), \u03c6 (r, f) = 0)\n    (C0' : \u2200 f : \u2200 i, s i, \u03c6 (0, f) = 0)\n    (C_add : \u2200 [DecidableEq \u03b9] (r : R) (f : \u2200 i, s i) (i : \u03b9) (m\u2081 m\u2082 : s i),\n      \u03c6 (r, update f i m\u2081) + \u03c6 (r, update f i m\u2082) = \u03c6 (r, update f i (m\u2081 + m\u2082)))\n    (C_add_scalar : \u2200 (r r' : R) (f : \u2200 i, s i), \u03c6 (r, f) + \u03c6 (r', f) = \u03c6 (r + r', f))\n    (C_smul : \u2200 [DecidableEq \u03b9] (r : R) (f : \u2200 i, s i) (i : \u03b9) (r' : R),\n      \u03c6 (r, update f i (r' \u2022 f i)) = \u03c6 (r' * r, f)) :\n    (\u2a02[R] i, s i) \u2192+ F :=\n  (addConGen (PiTensorProduct.Eqv R s)).lift (FreeAddMonoid.lift \u03c6) <|\n    AddCon.addConGen_le fun x y hxy \u21a6\n      match hxy with\n      | Eqv.of_zero r' f i hf =>\n        (AddCon.ker_rel _).2 <| by simp [FreeAddMonoid.lift_eval_of, C0 r' f i hf]\n      | Eqv.of_zero_scalar f =>\n        (AddCon.ker_rel _).2 <| by simp [FreeAddMonoid.lift_eval_of, C0']\n      | Eqv.of_add inst z f i m\u2081 m\u2082 =>\n        (AddCon.ker_rel _).2 <| by simp [FreeAddMonoid.lift_eval_of, @C_add inst]\n      | Eqv.of_add_scalar z\u2081 z\u2082 f =>\n        (AddCon.ker_rel _).2 <| by simp [FreeAddMonoid.lift_eval_of, C_add_scalar]\n      | Eqv.of_smul inst z f i r' =>\n        (AddCon.ker_rel _).2 <| by simp [FreeAddMonoid.lift_eval_of, @C_smul inst]\n      | Eqv.add_comm x y =>\n        (AddCon.ker_rel _).2 <| by simp_rw [AddMonoidHom.map_add, add_comm]", "start": [180, 1], "end": [205, 76], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.induction_on'", "code": "@[elab_as_elim]\nprotected theorem induction_on' {C : (\u2a02[R] i, s i) \u2192 Prop} (z : \u2a02[R] i, s i)\n    (C1 : \u2200 {r : R} {f : \u2200 i, s i}, C (tprodCoeff R r f)) (Cp : \u2200 {x y}, C x \u2192 C y \u2192 C (x + y)) :\n    C z", "start": [208, 1], "end": [218, 21], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.hasSMul'", "code": "instance hasSMul' : SMul R\u2081 (\u2a02[R] i, s i) :=\n  \u27e8fun r \u21a6\n    liftAddHom (fun f : R \u00d7 \u2200 i, s i \u21a6 tprodCoeff R (r \u2022 f.1) f.2)\n      (fun r' f i hf \u21a6 by simp_rw [zero_tprodCoeff' _ f i hf])\n      (fun f \u21a6 by simp [zero_tprodCoeff]) (fun r' f i m\u2081 m\u2082 \u21a6 by simp [add_tprodCoeff])\n      (fun r' r'' f \u21a6 by simp [add_tprodCoeff', mul_add]) fun z f i r' \u21a6 by\n      simp [smul_tprodCoeff, mul_smul_comm]\u27e9", "start": [229, 1], "end": [235, 45], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.smul_tprodCoeff'", "code": "theorem smul_tprodCoeff' (r : R\u2081) (z : R) (f : \u2200 i, s i) :\n    r \u2022 tprodCoeff R z f = tprodCoeff R (r \u2022 z) f", "start": [241, 1], "end": [242, 57], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.smul_add", "code": "protected theorem smul_add (r : R\u2081) (x y : \u2a02[R] i, s i) : r \u2022 (x + y) = r \u2022 x + r \u2022 y", "start": [245, 1], "end": [246, 29], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.distribMulAction'", "code": "instance distribMulAction' : DistribMulAction R\u2081 (\u2a02[R] i, s i) where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_add r x y := AddMonoidHom.map_add _ _ _\n  mul_smul r r' x :=\n    PiTensorProduct.induction_on' x (fun {r'' f} \u21a6 by simp [smul_tprodCoeff', smul_smul])\n      fun {x y} ihx ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihx, ihy]\n  one_smul x :=\n    PiTensorProduct.induction_on' x (fun {r f} \u21a6 by rw [smul_tprodCoeff', one_smul])\n      fun {z y} ihz ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihz, ihy]\n  smul_zero r := AddMonoidHom.map_zero _", "start": [249, 1], "end": [258, 41], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.smulCommClass'", "code": "instance smulCommClass' [SMulCommClass R\u2081 R\u2082 R] : SMulCommClass R\u2081 R\u2082 (\u2a02[R] i, s i) :=\n  \u27e8fun {r' r''} x \u21a6\n    PiTensorProduct.induction_on' x (fun {xr xf} \u21a6 by simp only [smul_tprodCoeff', smul_comm])\n      fun {z y} ihz ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihz, ihy]\u27e9", "start": [261, 1], "end": [264, 75], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.isScalarTower'", "code": "instance isScalarTower' [SMul R\u2081 R\u2082] [IsScalarTower R\u2081 R\u2082 R] :\n    IsScalarTower R\u2081 R\u2082 (\u2a02[R] i, s i) :=\n  \u27e8fun {r' r''} x \u21a6\n    PiTensorProduct.induction_on' x (fun {xr xf} \u21a6 by simp only [smul_tprodCoeff', smul_assoc])\n      fun {z y} ihz ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihz, ihy]\u27e9", "start": [267, 1], "end": [271, 75], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.module'", "code": "instance module' [Semiring R\u2081] [Module R\u2081 R] [SMulCommClass R\u2081 R R] : Module R\u2081 (\u2a02[R] i, s i) :=\n  { PiTensorProduct.distribMulAction' with\n    add_smul := fun r r' x \u21a6\n      PiTensorProduct.induction_on' x\n        (fun {r f} \u21a6 by simp_rw [smul_tprodCoeff', add_smul, add_tprodCoeff'])\n        fun {x y} ihx ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihx, ihy, add_add_add_comm]\n    zero_smul := fun x \u21a6\n      PiTensorProduct.induction_on' x\n        (fun {r f} \u21a6 by simp_rw [smul_tprodCoeff', zero_smul, zero_tprodCoeff])\n        fun {x y} ihx ihy \u21a6 by simp_rw [PiTensorProduct.smul_add, ihx, ihy, add_zero] }", "start": [278, 1], "end": [287, 88], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tprod", "code": "def tprod : MultilinearMap R s (\u2a02[R] i, s i) where\n  toFun := tprodCoeff R 1\n  map_add' {_ f} i x y := (add_tprodCoeff (1 : R) f i x y).symm\n  map_smul' {_ f} i r x := by\n    rw [smul_tprodCoeff', \u2190 smul_tprodCoeff (1 : R) _ i, update_idem, update_same]", "start": [302, 1], "end": [307, 83], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tprod_eq_tprodCoeff_one", "code": "theorem tprod_eq_tprodCoeff_one :\n    \u21d1(tprod R : MultilinearMap R s (\u2a02[R] i, s i)) = tprodCoeff R 1", "start": [319, 1], "end": [320, 74], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tprodCoeff_eq_smul_tprod", "code": "@[simp]\ntheorem tprodCoeff_eq_smul_tprod (z : R) (f : \u2200 i, s i) : tprodCoeff R z f = z \u2022 tprod R f", "start": [322, 1], "end": [325, 24], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {C : (\u2a02[R] i, s i) \u2192 Prop} (z : \u2a02[R] i, s i)\n    (C1 : \u2200 {r : R} {f : \u2200 i, s i}, C (r \u2022 tprod R f)) (Cp : \u2200 {x y}, C x \u2192 C y \u2192 C (x + y)) :\n    C z", "start": [328, 1], "end": [333, 48], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.ext", "code": "@[ext]\ntheorem ext {\u03c6\u2081 \u03c6\u2082 : (\u2a02[R] i, s i) \u2192\u2097[R] E}\n    (H : \u03c6\u2081.compMultilinearMap (tprod R) = \u03c6\u2082.compMultilinearMap (tprod R)) : \u03c6\u2081 = \u03c6\u2082", "start": [336, 1], "end": [345, 39], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.liftAux", "code": "def liftAux (\u03c6 : MultilinearMap R s E) : (\u2a02[R] i, s i) \u2192+ E :=\n  liftAddHom (fun p : R \u00d7 \u2200 i, s i \u21a6 p.1 \u2022 \u03c6 p.2)\n    (fun z f i hf \u21a6 by simp_rw [map_coord_zero \u03c6 i hf, smul_zero])\n    (fun f \u21a6 by simp_rw [zero_smul])\n    (fun z f i m\u2081 m\u2082 \u21a6 by simp_rw [\u2190 smul_add, \u03c6.map_add])\n    (fun z\u2081 z\u2082 f \u21a6 by rw [\u2190 add_smul])\n    fun z f i r \u21a6 by simp [\u03c6.map_smul, smul_smul, mul_comm]", "start": [356, 1], "end": [365, 60], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.liftAux_tprod", "code": "theorem liftAux_tprod (\u03c6 : MultilinearMap R s E) (f : \u2200 i, s i) : liftAux \u03c6 (tprod R f) = \u03c6 f", "start": [368, 1], "end": [381, 7], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.liftAux_tprodCoeff", "code": "theorem liftAux_tprodCoeff (\u03c6 : MultilinearMap R s E) (z : R) (f : \u2200 i, s i) :\n    liftAux \u03c6 (tprodCoeff R z f) = z \u2022 \u03c6 f", "start": [385, 1], "end": [386, 50], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.liftAux.smul", "code": "theorem liftAux.smul {\u03c6 : MultilinearMap R s E} (r : R) (x : \u2a02[R] i, s i) :\n    liftAux \u03c6 (r \u2022 x) = r \u2022 liftAux \u03c6 x", "start": [389, 1], "end": [395, 80], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift", "code": "def lift : MultilinearMap R s E \u2243\u2097[R] (\u2a02[R] i, s i) \u2192\u2097[R] E where\n  toFun \u03c6 := { liftAux \u03c6 with map_smul' := liftAux.smul }\n  invFun \u03c6' := \u03c6'.compMultilinearMap (tprod R)\n  left_inv \u03c6 := by\n    ext\n    simp [liftAux_tprod, LinearMap.compMultilinearMap]\n  right_inv \u03c6 := by\n    ext\n    simp [liftAux_tprod]\n  map_add' \u03c6\u2081 \u03c6\u2082 := by\n    ext\n    simp [liftAux_tprod]\n  map_smul' r \u03c6\u2082 := by\n    ext\n    simp [liftAux_tprod]", "start": [398, 1], "end": [415, 25], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift.tprod", "code": "@[simp]\ntheorem lift.tprod (f : \u2200 i, s i) : lift \u03c6 (tprod R f) = \u03c6 f", "start": [420, 1], "end": [422, 20], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift.unique'", "code": "theorem lift.unique' {\u03c6' : (\u2a02[R] i, s i) \u2192\u2097[R] E}\n    (H : \u03c6'.compMultilinearMap (PiTensorProduct.tprod R) = \u03c6) : \u03c6' = lift \u03c6", "start": [425, 1], "end": [427, 49], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift.unique", "code": "theorem lift.unique {\u03c6' : (\u2a02[R] i, s i) \u2192\u2097[R] E} (H : \u2200 f, \u03c6' (PiTensorProduct.tprod R f) = \u03c6 f) :\n    \u03c6' = lift \u03c6", "start": [430, 1], "end": [432, 38], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift_symm", "code": "@[simp]\ntheorem lift_symm (\u03c6' : (\u2a02[R] i, s i) \u2192\u2097[R] E) : lift.symm \u03c6' = \u03c6'.compMultilinearMap (tprod R)", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift_tprod", "code": "@[simp]\ntheorem lift_tprod : lift (tprod R : MultilinearMap R s _) = LinearMap.id", "start": [440, 1], "end": [442, 30], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex", "code": "def reindex (e : \u03b9 \u2243 \u03b9\u2082) : (\u2a02[R] _ : \u03b9, M) \u2243\u2097[R] \u2a02[R] _ : \u03b9\u2082, M :=\n  LinearEquiv.ofLinear (lift (domDomCongr e.symm (tprod R : MultilinearMap R _ (\u2a02[R] _ : \u03b9\u2082, M))))\n    (lift (domDomCongr e (tprod R : MultilinearMap R _ (\u2a02[R] _ : \u03b9, M))))\n    (by\n      ext\n      simp only [LinearMap.comp_apply, LinearMap.id_apply, lift_tprod,\n        LinearMap.compMultilinearMap_apply, lift.tprod, domDomCongr_apply]\n      congr\n      ext\n      rw [e.apply_symm_apply])\n    (by\n      ext\n      simp only [LinearMap.comp_apply, LinearMap.id_apply, lift_tprod,\n        LinearMap.compMultilinearMap_apply, lift.tprod, domDomCongr_apply]\n      congr\n      ext\n      rw [e.symm_apply_apply])", "start": [449, 1], "end": [469, 31], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_tprod", "code": "@[simp]\ntheorem reindex_tprod (e : \u03b9 \u2243 \u03b9\u2082) (f : \u2200 _, M) :\n    reindex R M e (tprod R f) = tprod R fun i \u21a6 f (e.symm i)", "start": [474, 1], "end": [478, 26], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_comp_tprod", "code": "@[simp]\ntheorem reindex_comp_tprod (e : \u03b9 \u2243 \u03b9\u2082) :\n    (reindex R M e : (\u2a02[R] _ : \u03b9, M) \u2192\u2097[R] \u2a02[R] _ : \u03b9\u2082, M).compMultilinearMap (tprod R) =\n      (tprod R : MultilinearMap R (fun _ \u21a6 M) _).domDomCongr e.symm", "start": [481, 1], "end": [485, 40], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift_comp_reindex", "code": "@[simp]\ntheorem lift_comp_reindex (e : \u03b9 \u2243 \u03b9\u2082) (\u03c6 : MultilinearMap R (fun _ : \u03b9\u2082 \u21a6 M) E) :\n    lift \u03c6 \u2218\u2097 \u2191(reindex R M e) = lift (\u03c6.domDomCongr e.symm)", "start": [488, 1], "end": [492, 7], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.lift_reindex", "code": "@[simp]\ntheorem lift_reindex (e : \u03b9 \u2243 \u03b9\u2082) (\u03c6 : MultilinearMap R (fun _ \u21a6 M) E) (x : \u2a02[R] _, M) :\n    lift \u03c6 (reindex R M e x) = lift (\u03c6.domDomCongr e.symm) x", "start": [495, 1], "end": [498, 48], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_trans", "code": "@[simp]\ntheorem reindex_trans (e : \u03b9 \u2243 \u03b9\u2082) (e' : \u03b9\u2082 \u2243 \u03b9\u2083) :\n    (reindex R M e).trans (reindex R M e') = reindex R M (e.trans e')", "start": [501, 1], "end": [509, 8], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_reindex", "code": "@[simp]\ntheorem reindex_reindex (e : \u03b9 \u2243 \u03b9\u2082) (e' : \u03b9\u2082 \u2243 \u03b9\u2083) (x : \u2a02[R] _, M) :\n    reindex R M e' (reindex R M e x) = reindex R M (e.trans e') x", "start": [512, 1], "end": [515, 78], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_symm", "code": "@[simp]\ntheorem reindex_symm (e : \u03b9 \u2243 \u03b9\u2082) : (reindex R M e).symm = reindex R M e.symm", "start": [518, 1], "end": [519, 85], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.reindex_refl", "code": "@[simp]\ntheorem reindex_refl : reindex R M (Equiv.refl \u03b9) = LinearEquiv.refl R _", "start": [522, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.isEmptyEquiv", "code": "@[simps symm_apply]\ndef isEmptyEquiv [IsEmpty \u03b9] : (\u2a02[R] _ : \u03b9, M) \u2243\u2097[R] R where\n  toFun := lift (constOfIsEmpty R _ 1)\n  invFun r := r \u2022 tprod R (@isEmptyElim _ _ _)\n  left_inv x := by\n    refine x.induction_on ?_ ?_\n    \u00b7 intro x y\n      simp only [map_smul\u209b\u2097, RingHom.id_apply, lift.tprod, constOfIsEmpty_apply, const_apply,\n        smul_eq_mul, mul_one]\n      congr\n      aesop\n    \u00b7 simp only\n      intro x y hx hy\n      rw [map_add, add_smul, hx, hy]\n  right_inv t := by simp\n  map_add' := LinearMap.map_add _\n  map_smul' := fun r x => by\n    simp only\n    exact LinearMap.map_smul _ r x", "start": [532, 1], "end": [551, 35], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.isEmptyEquiv_apply_tprod", "code": "@[simp]\ntheorem isEmptyEquiv_apply_tprod [IsEmpty \u03b9] (f : \u03b9 \u2192 M) : isEmptyEquiv \u03b9 (tprod R f) = 1", "start": [554, 1], "end": [556, 15], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.subsingletonEquiv", "code": "@[simps symm_apply]\ndef subsingletonEquiv [Subsingleton \u03b9] (i\u2080 : \u03b9) : (\u2a02[R] _ : \u03b9, M) \u2243\u2097[R] M where\n  toFun := lift (MultilinearMap.ofSubsingleton R M i\u2080)\n  invFun m := tprod R fun _ \u21a6 m\n  left_inv x := by\n    dsimp only\n    have : \u2200 (f : \u03b9 \u2192 M) (z : M), (fun _ : \u03b9 \u21a6 z) = update f i\u2080 z := by\n      intro f z\n      ext i\n      rw [Subsingleton.elim i i\u2080, Function.update_same]\n    refine x.induction_on ?_ ?_\n    \u00b7 intro r f\n      simp only [LinearMap.map_smul, lift.tprod, ofSubsingleton_apply, Function.eval, this f,\n        MultilinearMap.map_smul, update_eq_self]\n    \u00b7 intro x y hx hy\n      rw [LinearMap.map_add, this 0 (_ + _), MultilinearMap.map_add, \u2190 this 0 (lift _ _), hx,\n        \u2190 this 0 (lift _ _), hy]\n  right_inv t := by simp only [ofSubsingleton_apply, lift.tprod, Function.eval_apply]\n  map_add' := LinearMap.map_add _\n  map_smul' := fun r x => by\n    simp only\n    exact LinearMap.map_smul _ r x", "start": [561, 1], "end": [585, 35], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.subsingletonEquiv_apply_tprod", "code": "@[simp]\ntheorem subsingletonEquiv_apply_tprod [Subsingleton \u03b9] (i : \u03b9) (f : \u03b9 \u2192 M) :\n    subsingletonEquiv i (tprod R f) = f i", "start": [588, 1], "end": [591, 15], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmul", "code": "private def tmul : ((\u2a02[R] _ : \u03b9, M) \u2297[R] \u2a02[R] _ : \u03b9\u2082, M) \u2192\u2097[R] \u2a02[R] _ : Sum \u03b9 \u03b9\u2082, M :=\n  TensorProduct.lift\n    { toFun := fun a \u21a6\n        PiTensorProduct.lift <|\n          PiTensorProduct.lift (MultilinearMap.currySumEquiv R _ _ M _ (tprod R)) a\n      map_add' := fun a b \u21a6 by simp only [LinearEquiv.map_add, LinearMap.map_add]\n      map_smul' := fun r a \u21a6 by\n        simp only [LinearEquiv.map_smul, LinearMap.map_smul, RingHom.id_apply] }", "start": [596, 1], "end": [604, 81], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmul_apply", "code": "private theorem tmul_apply (a : \u03b9 \u2192 M) (b : \u03b9\u2082 \u2192 M) :\n    tmul ((\u2a02\u209c[R] i, a i) \u2297\u209c[R] \u2a02\u209c[R] i, b i) = \u2a02\u209c[R] i, Sum.elim a b i", "start": [606, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmulSymm", "code": "private def tmulSymm : (\u2a02[R] _ : Sum \u03b9 \u03b9\u2082, M) \u2192\u2097[R] (\u2a02[R] _ : \u03b9, M) \u2297[R] \u2a02[R] _ : \u03b9\u2082, M :=\n  PiTensorProduct.lift <| MultilinearMap.domCoprod (tprod R) (tprod R)", "start": [611, 1], "end": [614, 71], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmulSymm_apply", "code": "private theorem tmulSymm_apply (a : Sum \u03b9 \u03b9\u2082 \u2192 M) :\n    tmulSymm (\u2a02\u209c[R] i, a i) = (\u2a02\u209c[R] i, a (Sum.inl i)) \u2297\u209c[R] \u2a02\u209c[R] i, a (Sum.inr i)", "start": [616, 1], "end": [618, 31], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmulEquiv", "code": "def tmulEquiv : ((\u2a02[R] _ : \u03b9, M) \u2297[R] \u2a02[R] _ : \u03b9\u2082, M) \u2243\u2097[R] \u2a02[R] _ : Sum \u03b9 \u03b9\u2082, M :=\n  LinearEquiv.ofLinear tmul tmulSymm\n    (by\n      ext x\n      show tmul (tmulSymm (tprod R x)) = tprod R x simp only [tmulSymm_apply, tmul_apply]\n      erw [Sum.elim_comp_inl_inr])\n    (by\n      ext x y\n      show tmulSymm (tmul (tprod R x \u2297\u209c[R] tprod R y)) = tprod R x \u2297\u209c[R] tprod R y\n      simp only [tmul_apply, tmulSymm_apply, Sum.elim_inl, Sum.elim_inr])", "start": [624, 1], "end": [641, 74], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmulEquiv_apply", "code": "@[simp]\ntheorem tmulEquiv_apply (a : \u03b9 \u2192 M) (b : \u03b9\u2082 \u2192 M) :\n    tmulEquiv (\u03b9 := \u03b9) (\u03b9\u2082 := \u03b9\u2082) R M ((\u2a02\u209c[R] i, a i) \u2297\u209c[R] \u2a02\u209c[R] i, b i) =\n    \u2a02\u209c[R] i, Sum.elim a b i", "start": [644, 1], "end": [648, 17], "kind": "commanddeclaration"}, {"full_name": "PiTensorProduct.tmulEquiv_symm_apply", "code": "@[simp]\ntheorem tmulEquiv_symm_apply (a : Sum \u03b9 \u03b9\u2082 \u2192 M) :\n    (tmulEquiv (\u03b9 := \u03b9) (\u03b9\u2082 := \u03b9\u2082) R M).symm (\u2a02\u209c[R] i, a i) =\n    (\u2a02\u209c[R] i, a (Sum.inl i)) \u2297\u209c[R] \u2a02\u209c[R] i, a (Sum.inr i)", "start": [651, 1], "end": [655, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/ConnectedComponent.lean", "imports": ["Mathlib/Combinatorics/Quiver/Subquiver.lean", "Mathlib/Combinatorics/Quiver/Symmetric.lean", "Mathlib/Combinatorics/Quiver/Path.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver.zigzagSetoid", "code": "def zigzagSetoid : Setoid V :=\n  \u27e8fun a b \u21a6 Nonempty (@Path (Symmetrify V) _ a b), fun _ \u21a6 \u27e8Path.nil\u27e9, fun \u27e8p\u27e9 \u21a6\n    \u27e8p.reverse\u27e9, fun \u27e8p\u27e9 \u27e8q\u27e9 \u21a6 \u27e8p.comp q\u27e9\u27e9", "start": [28, 1], "end": [32, 43], "kind": "commanddeclaration"}, {"full_name": "Quiver.WeaklyConnectedComponent", "code": "def WeaklyConnectedComponent : Type _ :=\n  Quotient (zigzagSetoid V)", "start": [35, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "Quiver.WeaklyConnectedComponent.mk", "code": "protected def mk : V \u2192 WeaklyConnectedComponent V :=\n  @Quotient.mk' _ (zigzagSetoid V)", "start": [46, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "Quiver.WeaklyConnectedComponent.eq", "code": "protected theorem eq (a b : V) :\n    (a : WeaklyConnectedComponent V) = b \u2194 Nonempty (@Path (Symmetrify V) _ a b)", "start": [57, 1], "end": [59, 16], "kind": "commanddeclaration"}, {"full_name": "Quiver.wideSubquiverSymmetrify", "code": "def wideSubquiverSymmetrify (H : WideSubquiver (Symmetrify V)) : WideSubquiver V :=\n  fun _ _ \u21a6 { e | H _ _ (Sum.inl e) \u2228 H _ _ (Sum.inr e) }", "start": [68, 1], "end": [71, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Morphisms/Basic.lean", "imports": ["Mathlib/CategoryTheory/MorphismProperty.lean", "Mathlib/AlgebraicGeometry/AffineScheme.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/AlgebraicGeometry/Pullbacks.lean", "Mathlib/Data/List/TFAE.lean"], "premises": [{"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty", "code": "def AffineTargetMorphismProperty :=\n  \u2200 \u2983X Y : Scheme\u2984 (_ : X \u27f6 Y) [IsAffine Y], Prop", "start": [71, 1], "end": [74, 50], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.isIso", "code": "protected def Scheme.isIso : MorphismProperty Scheme :=\n  @IsIso Scheme _", "start": [77, 1], "end": [79, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.affineTargetIsIso", "code": "protected def Scheme.affineTargetIsIso : AffineTargetMorphismProperty := fun _ _ f _ => IsIso f", "start": [82, 1], "end": [83, 96], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.toProperty", "code": "def AffineTargetMorphismProperty.toProperty (P : AffineTargetMorphismProperty) :\n    MorphismProperty Scheme := fun _ _ f => \u2203 h, @P _ _ f h", "start": [88, 1], "end": [91, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.toProperty_apply", "code": "theorem AffineTargetMorphismProperty.toProperty_apply (P : AffineTargetMorphismProperty)\n    {X Y : Scheme} (f : X \u27f6 Y) [i : IsAffine Y] : P.toProperty f \u2194 P f", "start": [94, 1], "end": [96, 58], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affine_cancel_left_isIso", "code": "theorem affine_cancel_left_isIso {P : AffineTargetMorphismProperty} (hP : P.toProperty.RespectsIso)\n    {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] [IsAffine Z] : P (f \u226b g) \u2194 P g", "start": [99, 1], "end": [101, 72], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affine_cancel_right_isIso", "code": "theorem affine_cancel_right_isIso {P : AffineTargetMorphismProperty} (hP : P.toProperty.RespectsIso)\n    {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso g] [IsAffine Z] [IsAffine Y] :\n    P (f \u226b g) \u2194 P f", "start": [104, 1], "end": [106, 97], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_mk", "code": "theorem AffineTargetMorphismProperty.respectsIso_mk {P : AffineTargetMorphismProperty}\n    (h\u2081 : \u2200 {X Y Z} (e : X \u2245 Y) (f : Y \u27f6 Z) [IsAffine Z], P f \u2192 P (e.hom \u226b f))\n    (h\u2082 : \u2200 {X Y Z} (e : Y \u2245 Z) (f : X \u27f6 Y) [h : IsAffine Y],\n      P f \u2192 @P _ _ (f \u226b e.hom) (isAffineOfIso e.inv)) :\n    P.toProperty.RespectsIso", "start": [109, 1], "end": [116, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.targetAffineLocally", "code": "def targetAffineLocally (P : AffineTargetMorphismProperty) : MorphismProperty Scheme :=\n  fun {X Y : Scheme} (f : X \u27f6 Y) => \u2200 U : Y.affineOpens, @P _ _ (f \u2223_ U) U.prop", "start": [119, 1], "end": [122, 80], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsAffineOpen.map_isIso", "code": "theorem IsAffineOpen.map_isIso {X Y : Scheme} {U : Opens Y.carrier} (hU : IsAffineOpen U)\n    (f : X \u27f6 Y) [IsIso f] : IsAffineOpen ((Opens.map f.1.base).obj U)", "start": [125, 1], "end": [128, 25], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.targetAffineLocally_respectsIso", "code": "theorem targetAffineLocally_respectsIso {P : AffineTargetMorphismProperty}\n    (hP : P.toProperty.RespectsIso) : (targetAffineLocally P).RespectsIso", "start": [131, 1], "end": [144, 67], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal", "code": "structure AffineTargetMorphismProperty.IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  \n  RespectsIso : P.toProperty.RespectsIso\n  \n  toBasicOpen :\n    \u2200 {X Y : Scheme} [IsAffine Y] (f : X \u27f6 Y) (r : Y.presheaf.obj <| op \u22a4),\n      P f \u2192 @P _ _ (f \u2223_ Y.basicOpen r) ((topIsAffineOpen Y).basicOpenIsAffine _)\n  \n  ofBasicOpenCover :\n    \u2200 {X Y : Scheme} [IsAffine Y] (f : X \u27f6 Y) (s : Finset (Y.presheaf.obj <| op \u22a4))\n      (_ : Ideal.span (s : Set (Y.presheaf.obj <| op \u22a4)) = \u22a4),\n      (\u2200 r : s, @P _ _ (f \u2223_ Y.basicOpen r.1) ((topIsAffineOpen Y).basicOpenIsAffine _)) \u2192 P f", "start": [147, 1], "end": [166, 95], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.targetAffineLocallyOfOpenCover", "code": "theorem targetAffineLocallyOfOpenCover {P : AffineTargetMorphismProperty} (hP : P.IsLocal)\n    {X Y : Scheme} (f : X \u27f6 Y) (\ud835\udcb0 : Y.OpenCover) [\u2200 i, IsAffine (\ud835\udcb0.obj i)]\n    (h\ud835\udcb0 : \u2200 i, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i)) :\n    targetAffineLocally P f", "start": [169, 1], "end": [229, 74], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE", "code": "theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_TFAE\n    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [targetAffineLocally P f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          P (pullback.snd : pullback f g \u27f6 U),\n        \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4) (hU' : \u2200 i, IsAffineOpen (U i)),\n          \u2200 i, @P _ _ (f \u2223_ U i) (hU' i)]", "start": [233, 1], "end": [278, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.isLocalOfOpenCoverImply", "code": "theorem AffineTargetMorphismProperty.isLocalOfOpenCoverImply (P : AffineTargetMorphismProperty)\n    (hP : P.toProperty.RespectsIso)\n    (H : \u2200 {X Y : Scheme.{u}} (f : X \u27f6 Y),\n      (\u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n        \u2200 i : \ud835\udcb0.J, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i)) \u2192\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          P (pullback.snd : pullback f g \u27f6 U)) :\n    P.IsLocal", "start": [281, 1], "end": [308, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_openCover_iff", "code": "theorem AffineTargetMorphismProperty.IsLocal.affine_openCover_iff {P : AffineTargetMorphismProperty}\n    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    [h\ud835\udcb0 : \u2200 i, IsAffine (\ud835\udcb0.obj i)] :\n    targetAffineLocally P f \u2194 \u2200 i, @P _ _ (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _) (h\ud835\udcb0 i)", "start": [311, 1], "end": [318, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.affine_target_iff", "code": "theorem AffineTargetMorphismProperty.IsLocal.affine_target_iff {P : AffineTargetMorphismProperty}\n    (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X \u27f6 Y) [IsAffine Y] :\n    targetAffineLocally P f \u2194 P f", "start": [321, 1], "end": [329, 92], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PropertyIsLocalAtTarget", "code": "structure PropertyIsLocalAtTarget (P : MorphismProperty Scheme) : Prop where\n  \n  RespectsIso : P.RespectsIso\n  \n  restrict : \u2200 {X Y : Scheme} (f : X \u27f6 Y) (U : Opens Y.carrier), P f \u2192 P (f \u2223_ U)\n  \n  of_openCover :\n    \u2200 {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y),\n      (\u2200 i : \ud835\udcb0.J, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i)) \u2192 P f", "start": [332, 1], "end": [345, 80], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocallyIsLocal", "code": "theorem AffineTargetMorphismProperty.IsLocal.targetAffineLocallyIsLocal\n    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) :\n    PropertyIsLocalAtTarget (targetAffineLocally P)", "start": [348, 1], "end": [381, 11], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_TFAE", "code": "theorem PropertyIsLocalAtTarget.openCover_TFAE {P : MorphismProperty Scheme}\n    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [P f,\n        \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} Y,\n          \u2200 i : \ud835\udcb0.J, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (i : \ud835\udcb0.J),\n          P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 U : Opens Y.carrier, P (f \u2223_ U),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsOpenImmersion g], P (pullback.snd : pullback f g \u27f6 U),\n        \u2203 (\u03b9 : Type u) (U : \u03b9 \u2192 Opens Y.carrier) (_ : iSup U = \u22a4), \u2200 i, P (f \u2223_ U i)]", "start": [385, 1], "end": [423, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.PropertyIsLocalAtTarget.openCover_iff", "code": "theorem PropertyIsLocalAtTarget.openCover_iff {P : MorphismProperty Scheme}\n    (hP : PropertyIsLocalAtTarget P) {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y) :\n    P f \u2194 \u2200 i, P (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _)", "start": [426, 1], "end": [433, 19], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.StableUnderBaseChange", "code": "def StableUnderBaseChange (P : AffineTargetMorphismProperty) : Prop :=\n  \u2200 \u2983X Y S : Scheme\u2984 [IsAffine S] [IsAffine X] (f : X \u27f6 S) (g : Y \u27f6 S),\n    P g \u2192 P (pullback.fst : pullback f g \u27f6 X)", "start": [438, 1], "end": [442, 46], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange", "code": "theorem IsLocal.targetAffineLocallyPullbackFstOfRightOfStableUnderBaseChange\n    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) (hP' : P.StableUnderBaseChange)\n    {X Y S : Scheme} (f : X \u27f6 S) (g : Y \u27f6 S) [IsAffine S] (H : P g) :\n    targetAffineLocally P (pullback.fst : pullback f g \u27f6 X)", "start": [445, 1], "end": [457, 24], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.stableUnderBaseChange", "code": "theorem IsLocal.stableUnderBaseChange {P : AffineTargetMorphismProperty} (hP : P.IsLocal)\n    (hP' : P.StableUnderBaseChange) : (targetAffineLocally P).StableUnderBaseChange", "start": [460, 1], "end": [486, 15], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.diagonal", "code": "def AffineTargetMorphismProperty.diagonal (P : AffineTargetMorphismProperty) :\n    AffineTargetMorphismProperty :=\n  fun {X _} f _ =>\n    \u2200 {U\u2081 U\u2082 : Scheme} (f\u2081 : U\u2081 \u27f6 X) (f\u2082 : U\u2082 \u27f6 X) [IsAffine U\u2081] [IsAffine U\u2082] [IsOpenImmersion f\u2081]\n      [IsOpenImmersion f\u2082], P (pullback.mapDesc f\u2081 f\u2082 f)", "start": [491, 1], "end": [498, 57], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.diagonal_respectsIso", "code": "theorem AffineTargetMorphismProperty.diagonal_respectsIso (P : AffineTargetMorphismProperty)\n    (hP : P.toProperty.RespectsIso) : P.diagonal.toProperty.RespectsIso", "start": [501, 1], "end": [515, 12], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.diagonalTargetAffineLocallyOfOpenCover", "code": "theorem diagonalTargetAffineLocallyOfOpenCover (P : AffineTargetMorphismProperty) (hP : P.IsLocal)\n    {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)]\n    (\ud835\udcb0' : \u2200 i, Scheme.OpenCover.{u} (pullback f (\ud835\udcb0.map i))) [\u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)]\n    (h\ud835\udcb0' : \u2200 i j k, P (pullback.mapDesc ((\ud835\udcb0' i).map j) ((\ud835\udcb0' i).map k) pullback.snd)) :\n    (targetAffineLocally P).diagonal f", "start": [518, 1], "end": [535, 29], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.diagonalOfTargetAffineLocally", "code": "theorem AffineTargetMorphismProperty.diagonalOfTargetAffineLocally\n    (P : AffineTargetMorphismProperty) (hP : P.IsLocal) {X Y U : Scheme.{u}} (f : X \u27f6 Y) (g : U \u27f6 Y)\n    [IsAffine U] [IsOpenImmersion g] (H : (targetAffineLocally P).diagonal f) :\n    P.diagonal (pullback.snd : pullback f g \u27f6 _)", "start": [538, 1], "end": [554, 38], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.diagonal_affine_openCover_TFAE", "code": "theorem AffineTargetMorphismProperty.IsLocal.diagonal_affine_openCover_TFAE\n    {P : AffineTargetMorphismProperty} (hP : P.IsLocal) {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [(targetAffineLocally P).diagonal f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, P.diagonal (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          P.diagonal (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          P.diagonal (pullback.snd : pullback f g \u27f6 _),\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)) (\ud835\udcb0' :\n          \u2200 i, Scheme.OpenCover.{u} (pullback f (\ud835\udcb0.map i))) (_ : \u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)),\n          \u2200 i j k, P (pullback.mapDesc ((\ud835\udcb0' i).map j) ((\ud835\udcb0' i).map k) pullback.snd)]", "start": [558, 1], "end": [585, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.diagonal", "code": "theorem AffineTargetMorphismProperty.IsLocal.diagonal {P : AffineTargetMorphismProperty}\n    (hP : P.IsLocal) : P.diagonal.IsLocal", "start": [588, 1], "end": [591, 70], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.diagonal_targetAffineLocally_eq_targetAffineLocally", "code": "theorem diagonal_targetAffineLocally_eq_targetAffineLocally (P : AffineTargetMorphismProperty)\n    (hP : P.IsLocal) : (targetAffineLocally P).diagonal = targetAffineLocally P.diagonal", "start": [594, 1], "end": [600, 52], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyIsLocalAtTarget", "code": "theorem universallyIsLocalAtTarget (P : MorphismProperty Scheme)\n    (hP : \u2200 {X Y : Scheme.{u}} (f : X \u27f6 Y) (\ud835\udcb0 : Scheme.OpenCover.{u} Y),\n      (\u2200 i : \ud835\udcb0.J, P (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i)) \u2192 P f) :\n    PropertyIsLocalAtTarget P.universally", "start": [603, 1], "end": [618, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.universallyIsLocalAtTargetOfMorphismRestrict", "code": "theorem universallyIsLocalAtTargetOfMorphismRestrict (P : MorphismProperty Scheme)\n    (hP\u2081 : P.RespectsIso)\n    (hP\u2082 : \u2200 {X Y : Scheme.{u}} (f : X \u27f6 Y) {\u03b9 : Type u} (U : \u03b9 \u2192 Opens Y.carrier)\n      (_ : iSup U = \u22a4), (\u2200 i, P (f \u2223_ U i)) \u2192 P f) : PropertyIsLocalAtTarget P.universally", "start": [621, 1], "end": [628, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.MorphismProperty.topologically", "code": "def MorphismProperty.topologically\n    (P : \u2200 {\u03b1 \u03b2 : Type u} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (_ : \u03b1 \u2192 \u03b2), Prop) :\n    MorphismProperty Scheme.{u} := fun _ _ f => P f.1.base", "start": [631, 1], "end": [634, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ModularForms/SlashActions.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/GeneralLinearGroup.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "Mathlib/LinearAlgebra/Matrix/SpecialLinearGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SlashAction", "code": "class SlashAction (\u03b2 G \u03b1 \u03b3 : Type*) [Group G] [AddMonoid \u03b1] [SMul \u03b3 \u03b1] where\n  map : \u03b2 \u2192 G \u2192 \u03b1 \u2192 \u03b1\n  zero_slash : \u2200 (k : \u03b2) (g : G), map k g 0 = 0\n  slash_one : \u2200 (k : \u03b2) (a : \u03b1), map k 1 a = a\n  slash_mul : \u2200 (k : \u03b2) (g h : G) (a : \u03b1), map k (g * h) a = map k h (map k g a)\n  smul_slash : \u2200 (k : \u03b2) (g : G) (a : \u03b1) (z : \u03b3), map k g (z \u2022 a) = z \u2022 map k g a\n  add_slash : \u2200 (k : \u03b2) (g : G) (a b : \u03b1), map k g (a + b) = map k g a + map k g b", "start": [44, 1], "end": [51, 83], "kind": "commanddeclaration"}, {"full_name": "SlashAction.neg_slash", "code": "@[simp]\ntheorem SlashAction.neg_slash {\u03b2 G \u03b1 \u03b3 : Type*} [Group G] [AddGroup \u03b1] [SMul \u03b3 \u03b1]\n    [SlashAction \u03b2 G \u03b1 \u03b3] (k : \u03b2) (g : G) (a : \u03b1) : (-a) \u2223[k;\u03b3] g = -a \u2223[k;\u03b3] g", "start": [60, 1], "end": [64, 71], "kind": "commanddeclaration"}, {"full_name": "SlashAction.smul_slash_of_tower", "code": "@[simp]\ntheorem SlashAction.smul_slash_of_tower {R \u03b2 G \u03b1 : Type*} (\u03b3 : Type*) [Group G] [AddGroup \u03b1]\n    [Monoid \u03b3] [MulAction \u03b3 \u03b1] [SMul R \u03b3] [SMul R \u03b1] [IsScalarTower R \u03b3 \u03b1] [SlashAction \u03b2 G \u03b1 \u03b3]\n    (k : \u03b2) (g : G) (a : \u03b1) (r : R) : (r \u2022 a) \u2223[k;\u03b3] g = r \u2022 a \u2223[k;\u03b3] g", "start": [67, 1], "end": [71, 68], "kind": "commanddeclaration"}, {"full_name": "monoidHomSlashAction", "code": "def monoidHomSlashAction {\u03b2 G H \u03b1 \u03b3 : Type*} [Group G] [AddMonoid \u03b1] [SMul \u03b3 \u03b1] [Group H]\n    [SlashAction \u03b2 G \u03b1 \u03b3] (h : H \u2192* G) : SlashAction \u03b2 H \u03b1 \u03b3 where\n  map k g := SlashAction.map \u03b3 k (h g)\n  zero_slash k g := SlashAction.zero_slash k (h g)\n  slash_one k a := by simp only [map_one, SlashAction.slash_one]\n  slash_mul k g gg a := by simp only [map_mul, SlashAction.slash_mul]\n  smul_slash _ _ := SlashAction.smul_slash _ _\n  add_slash _ g _ _ := SlashAction.add_slash _ (h g) _ _", "start": [77, 1], "end": [85, 57], "kind": "commanddeclaration"}, {"full_name": "ModularForm.slash", "code": "def slash (k : \u2124) (\u03b3 : GL(2, \u211d)\u207a) (f : \u210d \u2192 \u2102) (x : \u210d) : \u2102 :=\n  f (\u03b3 \u2022 x) * (((\u2191\u2098\u03b3).det : \u211d) : \u2102) ^ (k - 1) * UpperHalfPlane.denom \u03b3 x ^ (-k)", "start": [92, 1], "end": [94, 80], "kind": "commanddeclaration"}, {"full_name": "ModularForm.slash_mul", "code": "private theorem slash_mul (k : \u2124) (A B : GL(2, \u211d)\u207a) (f : \u210d \u2192 \u2102) :\n    f \u2223[k](A * B) = (f \u2223[k]A) \u2223[k]B", "start": [104, 1], "end": [119, 42], "kind": "commanddeclaration"}, {"full_name": "ModularForm.add_slash", "code": "private theorem add_slash (k : \u2124) (A : GL(2, \u211d)\u207a) (f g : \u210d \u2192 \u2102) :\n    (f + g) \u2223[k]A = f \u2223[k]A + g \u2223[k]A", "start": [121, 1], "end": [125, 7], "kind": "commanddeclaration"}, {"full_name": "ModularForm.slash_one", "code": "private theorem slash_one (k : \u2124) (f : \u210d \u2192 \u2102) : f \u2223[k]1 = f", "start": [127, 1], "end": [128, 35], "kind": "commanddeclaration"}, {"full_name": "ModularForm.smul_slash", "code": "private theorem smul_slash (k : \u2124) (A : GL(2, \u211d)\u207a) (f : \u210d \u2192 \u2102) (c : \u03b1) :\n    (c \u2022 f) \u2223[k]A = c \u2022 f \u2223[k]A", "start": [132, 1], "end": [138, 7], "kind": "commanddeclaration"}, {"full_name": "ModularForm.zero_slash", "code": "private theorem zero_slash (k : \u2124) (A : GL(2, \u211d)\u207a) : (0 : \u210d \u2192 \u2102) \u2223[k]A = 0", "start": [140, 1], "end": [141, 64], "kind": "commanddeclaration"}, {"full_name": "ModularForm.slash_def", "code": "theorem slash_def (A : GL(2, \u211d)\u207a) : f \u2223[k] A = slash k A f", "start": [153, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.subgroupAction", "code": "instance subgroupAction (\u0393 : Subgroup SL(2, \u2124)) : SlashAction \u2124 \u0393 (\u210d \u2192 \u2102) \u2102 :=\n  monoidHomSlashAction\n    (MonoidHom.comp Matrix.SpecialLinearGroup.toGLPos\n      (MonoidHom.comp (Matrix.SpecialLinearGroup.map (Int.castRingHom \u211d)) (Subgroup.subtype \u0393)))", "start": [157, 1], "end": [160, 97], "kind": "commanddeclaration"}, {"full_name": "ModularForm.subgroup_slash", "code": "@[simp]\ntheorem subgroup_slash (\u0393 : Subgroup SL(2, \u2124)) (\u03b3 : \u0393) : f \u2223[k] \u03b3 = f \u2223[k] (\u03b3 : GL(2, \u211d)\u207a)", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.SLAction", "code": "instance SLAction : SlashAction \u2124 SL(2, \u2124) (\u210d \u2192 \u2102) \u2102 :=\n  monoidHomSlashAction\n    (MonoidHom.comp Matrix.SpecialLinearGroup.toGLPos\n      (Matrix.SpecialLinearGroup.map (Int.castRingHom \u211d)))", "start": [168, 1], "end": [171, 59], "kind": "commanddeclaration"}, {"full_name": "ModularForm.SL_slash", "code": "@[simp]\ntheorem SL_slash (\u03b3 : SL(2, \u2124)) : f \u2223[k] \u03b3 = f \u2223[k] (\u03b3 : GL(2, \u211d)\u207a)", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "ModularForm.is_invariant_one", "code": "theorem is_invariant_one (A : SL(2, \u2124)) : (1 : \u210d \u2192 \u2102) \u2223[(0 : \u2124)] A = (1 : \u210d \u2192 \u2102)", "start": [181, 1], "end": [187, 7], "kind": "commanddeclaration"}, {"full_name": "ModularForm.slash_action_eq'_iff", "code": "theorem slash_action_eq'_iff (k : \u2124) (\u0393 : Subgroup SL(2, \u2124)) (f : \u210d \u2192 \u2102) (\u03b3 : \u0393) (z : \u210d) :\n    (f \u2223[k] \u03b3) z = f z \u2194 f (\u03b3 \u2022 z) = ((\u2191\u2098[\u2124] \u03b3 1 0 : \u2102) * z + (\u2191\u2098[\u2124] \u03b3 1 1 : \u2102)) ^ k * f z", "start": [190, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "ModularForm.mul_slash", "code": "theorem mul_slash (k1 k2 : \u2124) (A : GL(2, \u211d)\u207a) (f g : \u210d \u2192 \u2102) :\n    (f * g) \u2223[k1 + k2] A = ((\u2191\u2098A).det : \u211d) \u2022 f \u2223[k1] A * g \u2223[k2] A", "start": [204, 1], "end": [221, 7], "kind": "commanddeclaration"}, {"full_name": "ModularForm.mul_slash_SL2", "code": "theorem mul_slash_SL2 (k1 k2 : \u2124) (A : SL(2, \u2124)) (f g : \u210d \u2192 \u2102) :\n    (f * g) \u2223[k1 + k2] A = f \u2223[k1] A * g \u2223[k2] A", "start": [225, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "ModularForm.mul_slash_subgroup", "code": "theorem mul_slash_subgroup (k1 k2 : \u2124) (\u0393 : Subgroup SL(2, \u2124)) (A : \u0393) (f g : \u210d \u2192 \u2102) :\n    (f * g) \u2223[k1 + k2] A = f \u2223[k1] A * g \u2223[k2] A", "start": [236, 1], "end": [238, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/MFDeriv.lean", "imports": ["Mathlib/Geometry/Manifold/VectorBundle/Tangent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DifferentiableWithinAtProp", "code": "def DifferentiableWithinAtProp (f : H \u2192 H') (s : Set H) (x : H) : Prop :=\n  DifferentiableWithinAt \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 Set.range I) (I x)", "start": [125, 1], "end": [129, 80], "kind": "commanddeclaration"}, {"full_name": "differentiable_within_at_localInvariantProp", "code": "theorem differentiable_within_at_localInvariantProp :\n    (contDiffGroupoid \u22a4 I).LocalInvariantProp (contDiffGroupoid \u22a4 I')\n      (DifferentiableWithinAtProp I I')", "start": [132, 1], "end": [177, 94], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt", "code": "def UniqueMDiffWithinAt (s : Set M) (x : M) :=\n  UniqueDiffWithinAt \ud835\udd5c ((extChartAt I x).symm \u207b\u00b9' s \u2229 range I) ((extChartAt I x) x)", "start": [180, 1], "end": [183, 84], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn", "code": "def UniqueMDiffOn (s : Set M) :=\n  \u2200 x \u2208 s, UniqueMDiffWithinAt I s x", "start": [186, 1], "end": [188, 37], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt", "code": "def MDifferentiableWithinAt (f : M \u2192 M') (s : Set M) (x : M) :=\n  ContinuousWithinAt f s x \u2227\n    DifferentiableWithinAt \ud835\udd5c (writtenInExtChartAt I I' x f) ((extChartAt I x).symm \u207b\u00b9' s \u2229 range I)\n      ((extChartAt I x) x)", "start": [191, 1], "end": [202, 27], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_iff_liftPropWithinAt", "code": "theorem mdifferentiableWithinAt_iff_liftPropWithinAt (f : M \u2192 M') (s : Set M) (x : M) :\n    MDifferentiableWithinAt I I' f s x \u2194 LiftPropWithinAt (DifferentiableWithinAtProp I I') f s x", "start": [205, 1], "end": [207, 9], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt", "code": "def MDifferentiableAt (f : M \u2192 M') (x : M) :=\n  ContinuousAt f x \u2227\n    DifferentiableWithinAt \ud835\udd5c (writtenInExtChartAt I I' x f) (range I) ((extChartAt I x) x)", "start": [210, 1], "end": [220, 91], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_iff_liftPropAt", "code": "theorem mdifferentiableAt_iff_liftPropAt (f : M \u2192 M') (x : M) :\n    MDifferentiableAt I I' f x \u2194 LiftPropAt (DifferentiableWithinAtProp I I') f x", "start": [223, 1], "end": [228, 59], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn", "code": "def MDifferentiableOn (f : M \u2192 M') (s : Set M) :=\n  \u2200 x \u2208 s, MDifferentiableWithinAt I I' f s x", "start": [231, 1], "end": [235, 46], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable", "code": "def MDifferentiable (f : M \u2192 M') :=\n  \u2200 x, MDifferentiableAt I I' f x", "start": [238, 1], "end": [242, 34], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable", "code": "def LocalHomeomorph.MDifferentiable (f : LocalHomeomorph M M') :=\n  MDifferentiableOn I I' f f.source \u2227 MDifferentiableOn I' I f.symm f.target", "start": [245, 1], "end": [247, 77], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt", "code": "def HasMFDerivWithinAt (f : M \u2192 M') (s : Set M) (x : M)\n    (f' : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' (f x)) :=\n  ContinuousWithinAt f s x \u2227\n    HasFDerivWithinAt (writtenInExtChartAt I I' x f : E \u2192 E') f'\n      ((extChartAt I x).symm \u207b\u00b9' s \u2229 range I) ((extChartAt I x) x)", "start": [252, 1], "end": [267, 67], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt", "code": "def HasMFDerivAt (f : M \u2192 M') (x : M) (f' : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' (f x)) :=\n  ContinuousAt f x \u2227\n    HasFDerivWithinAt (writtenInExtChartAt I I' x f : E \u2192 E') f' (range I) ((extChartAt I x) x)", "start": [270, 1], "end": [280, 96], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin", "code": "def mfderivWithin (f : M \u2192 M') (s : Set M) (x : M) : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' (f x) :=\n  if MDifferentiableWithinAt I I' f s x then\n    (fderivWithin \ud835\udd5c (writtenInExtChartAt I I' x f) ((extChartAt I x).symm \u207b\u00b9' s \u2229 range I)\n        ((extChartAt I x) x) :\n      _)\n  else 0", "start": [283, 1], "end": [291, 9], "kind": "commanddeclaration"}, {"full_name": "mfderiv", "code": "def mfderiv (f : M \u2192 M') (x : M) : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' (f x) :=\n  if MDifferentiableAt I I' f x then\n    (fderivWithin \ud835\udd5c (writtenInExtChartAt I I' x f : E \u2192 E') (range I) ((extChartAt I x) x) : _)\n  else 0", "start": [294, 1], "end": [300, 9], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin", "code": "def tangentMapWithin (f : M \u2192 M') (s : Set M) : TangentBundle I M \u2192 TangentBundle I' M' := fun p =>\n  \u27e8f p.1, (mfderivWithin I I' f s p.1 : TangentSpace I p.1 \u2192 TangentSpace I' (f p.1)) p.2\u27e9", "start": [303, 1], "end": [305, 91], "kind": "commanddeclaration"}, {"full_name": "tangentMap", "code": "def tangentMap (f : M \u2192 M') : TangentBundle I M \u2192 TangentBundle I' M' := fun p =>\n  \u27e8f p.1, (mfderiv I I' f p.1 : TangentSpace I p.1 \u2192 TangentSpace I' (f p.1)) p.2\u27e9", "start": [308, 1], "end": [310, 83], "kind": "commanddeclaration"}, {"full_name": "uniqueMDiffWithinAt_univ", "code": "theorem uniqueMDiffWithinAt_univ : UniqueMDiffWithinAt I univ x", "start": [332, 1], "end": [335, 43], "kind": "commanddeclaration"}, {"full_name": "uniqueMDiffWithinAt_iff", "code": "theorem uniqueMDiffWithinAt_iff {s : Set M} {x : M} :\n    UniqueMDiffWithinAt I s x \u2194\n      UniqueDiffWithinAt \ud835\udd5c ((extChartAt I x).symm \u207b\u00b9' s \u2229 (extChartAt I x).target)\n        ((extChartAt I x) x)", "start": [340, 1], "end": [345, 75], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.mono_nhds", "code": "nonrec theorem UniqueMDiffWithinAt.mono_nhds {s t : Set M} {x : M} (hs : UniqueMDiffWithinAt I s x)\n    (ht : \ud835\udcdd[s] x \u2264 \ud835\udcdd[t] x) : UniqueMDiffWithinAt I t x", "start": [348, 1], "end": [350, 87], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.mono_of_mem", "code": "theorem UniqueMDiffWithinAt.mono_of_mem {s t : Set M} {x : M} (hs : UniqueMDiffWithinAt I s x)\n    (ht : t \u2208 \ud835\udcdd[s] x) : UniqueMDiffWithinAt I t x", "start": [352, 1], "end": [354, 40], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.mono", "code": "theorem UniqueMDiffWithinAt.mono (h : UniqueMDiffWithinAt I s x) (st : s \u2286 t) :\n    UniqueMDiffWithinAt I t x", "start": [356, 1], "end": [358, 85], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.inter'", "code": "theorem UniqueMDiffWithinAt.inter' (hs : UniqueMDiffWithinAt I s x) (ht : t \u2208 \ud835\udcdd[s] x) :\n    UniqueMDiffWithinAt I (s \u2229 t) x", "start": [361, 1], "end": [363, 59], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.inter", "code": "theorem UniqueMDiffWithinAt.inter (hs : UniqueMDiffWithinAt I s x) (ht : t \u2208 \ud835\udcdd x) :\n    UniqueMDiffWithinAt I (s \u2229 t) x", "start": [366, 1], "end": [368, 36], "kind": "commanddeclaration"}, {"full_name": "IsOpen.uniqueMDiffWithinAt", "code": "theorem IsOpen.uniqueMDiffWithinAt (xs : x \u2208 s) (hs : IsOpen s) : UniqueMDiffWithinAt I s x", "start": [371, 1], "end": [372, 83], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.inter", "code": "theorem UniqueMDiffOn.inter (hs : UniqueMDiffOn I s) (ht : IsOpen t) : UniqueMDiffOn I (s \u2229 t)", "start": [375, 1], "end": [376, 79], "kind": "commanddeclaration"}, {"full_name": "IsOpen.uniqueMDiffOn", "code": "theorem IsOpen.uniqueMDiffOn (hs : IsOpen s) : UniqueMDiffOn I s", "start": [379, 1], "end": [380, 35], "kind": "commanddeclaration"}, {"full_name": "uniqueMDiffOn_univ", "code": "theorem uniqueMDiffOn_univ : UniqueMDiffOn I (univ : Set M)", "start": [383, 1], "end": [384, 28], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.eq", "code": "nonrec theorem UniqueMDiffWithinAt.eq (U : UniqueMDiffWithinAt I s x)\n    (h : HasMFDerivWithinAt I I' f s x f') (h\u2081 : HasMFDerivWithinAt I I' f s x f\u2081') : f' = f\u2081'", "start": [395, 1], "end": [399, 24], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.eq", "code": "theorem UniqueMDiffOn.eq (U : UniqueMDiffOn I s) (hx : x \u2208 s) (h : HasMFDerivWithinAt I I' f s x f')\n    (h\u2081 : HasMFDerivWithinAt I I' f s x f\u2081') : f' = f\u2081'", "start": [402, 1], "end": [404, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.prod", "code": "nonrec theorem UniqueMDiffWithinAt.prod {x : M} {y : M'} {s t} (hs : UniqueMDiffWithinAt I s x)\n    (ht : UniqueMDiffWithinAt I' t y) : UniqueMDiffWithinAt (I.prod I') (s \u00d7\u02e2 t) (x, y)", "start": [407, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.prod", "code": "theorem UniqueMDiffOn.prod {s : Set M} {t : Set M'} (hs : UniqueMDiffOn I s)\n    (ht : UniqueMDiffOn I' t) : UniqueMDiffOn (I.prod I') (s \u00d7\u02e2 t)", "start": [413, 1], "end": [415, 33], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_iff", "code": "theorem mdifferentiableWithinAt_iff {f : M \u2192 M'} {s : Set M} {x : M} :\n    MDifferentiableWithinAt I I' f s x \u2194\n      ContinuousWithinAt f s x \u2227\n        DifferentiableWithinAt \ud835\udd5c (writtenInExtChartAt I I' x f)\n          ((extChartAt I x).target \u2229 (extChartAt I x).symm \u207b\u00b9' s) ((extChartAt I x) x)", "start": [423, 1], "end": [430, 83], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_iff_of_mem_source", "code": "theorem mdifferentiableWithinAt_iff_of_mem_source {x' : M} {y : M'}\n    (hx : x' \u2208 (chartAt H x).source) (hy : f x' \u2208 (chartAt H' y).source) :\n    MDifferentiableWithinAt I I' f s x' \u2194\n      ContinuousWithinAt f s x' \u2227\n        DifferentiableWithinAt \ud835\udd5c (extChartAt I' y \u2218 f \u2218 (extChartAt I x).symm)\n          ((extChartAt I x).symm \u207b\u00b9' s \u2229 Set.range I) ((extChartAt I x) x')", "start": [433, 1], "end": [443, 7], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_zero_of_not_mdifferentiableWithinAt", "code": "theorem mfderivWithin_zero_of_not_mdifferentiableWithinAt\n    (h : \u00acMDifferentiableWithinAt I I' f s x) : mfderivWithin I I' f s x = 0", "start": [446, 1], "end": [448, 54], "kind": "commanddeclaration"}, {"full_name": "mfderiv_zero_of_not_mdifferentiableAt", "code": "theorem mfderiv_zero_of_not_mdifferentiableAt (h : \u00acMDifferentiableAt I I' f x) :\n    mfderiv I I' f x = 0", "start": [451, 1], "end": [452, 77], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mono", "code": "theorem HasMFDerivWithinAt.mono (h : HasMFDerivWithinAt I I' f t x f') (hst : s \u2286 t) :\n    HasMFDerivWithinAt I I' f s x f'", "start": [455, 1], "end": [458, 89], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.hasMFDerivWithinAt", "code": "theorem HasMFDerivAt.hasMFDerivWithinAt (h : HasMFDerivAt I I' f x f') :\n    HasMFDerivWithinAt I I' f s x f'", "start": [461, 1], "end": [463, 93], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mdifferentiableWithinAt", "code": "theorem HasMFDerivWithinAt.mdifferentiableWithinAt (h : HasMFDerivWithinAt I I' f s x f') :\n    MDifferentiableWithinAt I I' f s x", "start": [466, 1], "end": [468, 19], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.mdifferentiableAt", "code": "theorem HasMFDerivAt.mdifferentiableAt (h : HasMFDerivAt I I' f x f') :\n    MDifferentiableAt I I' f x", "start": [471, 1], "end": [473, 19], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_univ", "code": "@[simp, mfld_simps]\ntheorem hasMFDerivWithinAt_univ : HasMFDerivWithinAt I I' f univ x f' \u2194 HasMFDerivAt I I' f x f'", "start": [476, 1], "end": [478, 87], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_unique", "code": "theorem hasMFDerivAt_unique (h\u2080 : HasMFDerivAt I I' f x f\u2080') (h\u2081 : HasMFDerivAt I I' f x f\u2081') :\n    f\u2080' = f\u2081'", "start": [481, 1], "end": [484, 46], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_inter'", "code": "theorem hasMFDerivWithinAt_inter' (h : t \u2208 \ud835\udcdd[s] x) :\n    HasMFDerivWithinAt I I' f (s \u2229 t) x f' \u2194 HasMFDerivWithinAt I I' f s x f'", "start": [487, 1], "end": [491, 49], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_inter", "code": "theorem hasMFDerivWithinAt_inter (h : t \u2208 \ud835\udcdd x) :\n    HasMFDerivWithinAt I I' f (s \u2229 t) x f' \u2194 HasMFDerivWithinAt I I' f s x f'", "start": [494, 1], "end": [498, 43], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.union", "code": "theorem HasMFDerivWithinAt.union (hs : HasMFDerivWithinAt I I' f s x f')\n    (ht : HasMFDerivWithinAt I I' f t x f') : HasMFDerivWithinAt I I' f (s \u222a t) x f'", "start": [501, 1], "end": [506, 58], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mono_of_mem", "code": "theorem HasMFDerivWithinAt.mono_of_mem (h : HasMFDerivWithinAt I I' f s x f') (ht : s \u2208 \ud835\udcdd[t] x) :\n    HasMFDerivWithinAt I I' f t x f'", "start": [509, 1], "end": [511, 69], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.hasMFDerivAt", "code": "theorem HasMFDerivWithinAt.hasMFDerivAt (h : HasMFDerivWithinAt I I' f s x f') (hs : s \u2208 \ud835\udcdd x) :\n    HasMFDerivAt I I' f x f'", "start": [514, 1], "end": [516, 82], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.hasMFDerivWithinAt", "code": "theorem MDifferentiableWithinAt.hasMFDerivWithinAt (h : MDifferentiableWithinAt I I' f s x) :\n    HasMFDerivWithinAt I I' f s x (mfderivWithin I I' f s x)", "start": [519, 1], "end": [523, 53], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.mfderivWithin", "code": "protected theorem MDifferentiableWithinAt.mfderivWithin (h : MDifferentiableWithinAt I I' f s x) :\n    mfderivWithin I I' f s x =\n      fderivWithin \ud835\udd5c (writtenInExtChartAt I I' x f : _) ((extChartAt I x).symm \u207b\u00b9' s \u2229 range I)\n        ((extChartAt I x) x)", "start": [526, 1], "end": [530, 42], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.hasMFDerivAt", "code": "theorem MDifferentiableAt.hasMFDerivAt (h : MDifferentiableAt I I' f x) :\n    HasMFDerivAt I I' f x (mfderiv I I' f x)", "start": [533, 1], "end": [537, 53], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.mfderiv", "code": "protected theorem MDifferentiableAt.mfderiv (h : MDifferentiableAt I I' f x) :\n    mfderiv I I' f x =\n      fderivWithin \ud835\udd5c (writtenInExtChartAt I I' x f : _) (range I) ((extChartAt I x) x)", "start": [540, 1], "end": [543, 36], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.mfderiv", "code": "protected theorem HasMFDerivAt.mfderiv (h : HasMFDerivAt I I' f x f') : mfderiv I I' f x = f'", "start": [546, 1], "end": [547, 64], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mfderivWithin", "code": "theorem HasMFDerivWithinAt.mfderivWithin (h : HasMFDerivWithinAt I I' f s x f')\n    (hxs : UniqueMDiffWithinAt I s x) : mfderivWithin I I' f s x = f'", "start": [550, 1], "end": [553, 61], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.mfderivWithin", "code": "theorem MDifferentiable.mfderivWithin (h : MDifferentiableAt I I' f x)\n    (hxs : UniqueMDiffWithinAt I s x) : mfderivWithin I I' f s x = mfderiv I I' f x", "start": [556, 1], "end": [559, 42], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_subset", "code": "theorem mfderivWithin_subset (st : s \u2286 t) (hs : UniqueMDiffWithinAt I s x)\n    (h : MDifferentiableWithinAt I I' f t x) :\n    mfderivWithin I I' f s x = mfderivWithin I I' f t x", "start": [562, 1], "end": [565, 76], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.mono", "code": "theorem MDifferentiableWithinAt.mono (hst : s \u2286 t) (h : MDifferentiableWithinAt I I' f t x) :\n    MDifferentiableWithinAt I I' f s x", "start": [568, 1], "end": [571, 94], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_univ", "code": "theorem mdifferentiableWithinAt_univ :\n    MDifferentiableWithinAt I I' f univ x \u2194 MDifferentiableAt I I' f x", "start": [574, 1], "end": [576, 94], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_inter", "code": "theorem mdifferentiableWithinAt_inter (ht : t \u2208 \ud835\udcdd x) :\n    MDifferentiableWithinAt I I' f (s \u2229 t) x \u2194 MDifferentiableWithinAt I I' f s x", "start": [579, 1], "end": [583, 44], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_inter'", "code": "theorem mdifferentiableWithinAt_inter' (ht : t \u2208 \ud835\udcdd[s] x) :\n    MDifferentiableWithinAt I I' f (s \u2229 t) x \u2194 MDifferentiableWithinAt I I' f s x", "start": [586, 1], "end": [590, 50], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.mdifferentiableWithinAt", "code": "theorem MDifferentiableAt.mdifferentiableWithinAt (h : MDifferentiableAt I I' f x) :\n    MDifferentiableWithinAt I I' f s x", "start": [593, 1], "end": [595, 82], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.mdifferentiableAt", "code": "theorem MDifferentiableWithinAt.mdifferentiableAt (h : MDifferentiableWithinAt I I' f s x)\n    (hs : s \u2208 \ud835\udcdd x) : MDifferentiableAt I I' f x", "start": [598, 1], "end": [601, 82], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.mdifferentiableAt", "code": "theorem MDifferentiableOn.mdifferentiableAt (h : MDifferentiableOn I I' f s) (hx : s \u2208 \ud835\udcdd x) :\n    MDifferentiableAt I I' f x", "start": [604, 1], "end": [606, 50], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.mono", "code": "theorem MDifferentiableOn.mono (h : MDifferentiableOn I I' f t) (st : s \u2286 t) :\n    MDifferentiableOn I I' f s", "start": [608, 1], "end": [609, 68], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_univ", "code": "theorem mdifferentiableOn_univ : MDifferentiableOn I I' f univ \u2194 MDifferentiable I I' f", "start": [612, 1], "end": [613, 79], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.mdifferentiableOn", "code": "theorem MDifferentiable.mdifferentiableOn (h : MDifferentiable I I' f) :\n    MDifferentiableOn I I' f s", "start": [616, 1], "end": [618, 52], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_of_locally_mdifferentiableOn", "code": "theorem mdifferentiableOn_of_locally_mdifferentiableOn\n    (h : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 MDifferentiableOn I I' f (s \u2229 u)) :\n    MDifferentiableOn I I' f s", "start": [621, 1], "end": [626, 86], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_univ", "code": "@[simp, mfld_simps]\ntheorem mfderivWithin_univ : mfderivWithin I I' f univ = mfderiv I I' f", "start": [629, 1], "end": [633, 36], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_inter", "code": "theorem mfderivWithin_inter (ht : t \u2208 \ud835\udcdd x) :\n    mfderivWithin I I' f (s \u2229 t) x = mfderivWithin I I' f s x", "start": [636, 1], "end": [639, 62], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_iff_of_mem_source", "code": "theorem mdifferentiableAt_iff_of_mem_source {x' : M} {y : M'}\n    (hx : x' \u2208 (chartAt H x).source) (hy : f x' \u2208 (chartAt H' y).source) :\n    MDifferentiableAt I I' f x' \u2194\n      ContinuousAt f x' \u2227\n        DifferentiableWithinAt \ud835\udd5c (extChartAt I' y \u2218 f \u2218 (extChartAt I x).symm) (Set.range I)\n          ((extChartAt I x) x')", "start": [642, 1], "end": [650, 70], "kind": "commanddeclaration"}, {"full_name": "ContMDiffWithinAt.mdifferentiableWithinAt", "code": "theorem ContMDiffWithinAt.mdifferentiableWithinAt (hf : ContMDiffWithinAt I I' n f s x)\n    (hn : 1 \u2264 n) : MDifferentiableWithinAt I I' f s x", "start": [657, 1], "end": [664, 101], "kind": "commanddeclaration"}, {"full_name": "ContMDiffAt.mdifferentiableAt", "code": "theorem ContMDiffAt.mdifferentiableAt (hf : ContMDiffAt I I' n f x) (hn : 1 \u2264 n) :\n    MDifferentiableAt I I' f x", "start": [667, 1], "end": [669, 84], "kind": "commanddeclaration"}, {"full_name": "ContMDiffOn.mdifferentiableOn", "code": "theorem ContMDiffOn.mdifferentiableOn (hf : ContMDiffOn I I' n f s) (hn : 1 \u2264 n) :\n    MDifferentiableOn I I' f s", "start": [672, 1], "end": [673, 83], "kind": "commanddeclaration"}, {"full_name": "ContMDiff.mdifferentiable", "code": "theorem ContMDiff.mdifferentiable (hf : ContMDiff I I' n f) (hn : 1 \u2264 n) : MDifferentiable I I' f", "start": [676, 1], "end": [677, 39], "kind": "commanddeclaration"}, {"full_name": "SmoothWithinAt.mdifferentiableWithinAt", "code": "nonrec theorem SmoothWithinAt.mdifferentiableWithinAt (hf : SmoothWithinAt I I' f s x) :\n    MDifferentiableWithinAt I I' f s x", "start": [680, 1], "end": [682, 36], "kind": "commanddeclaration"}, {"full_name": "SmoothAt.mdifferentiableAt", "code": "nonrec theorem SmoothAt.mdifferentiableAt (hf : SmoothAt I I' f x) : MDifferentiableAt I I' f x", "start": [685, 1], "end": [686, 30], "kind": "commanddeclaration"}, {"full_name": "SmoothOn.mdifferentiableOn", "code": "nonrec theorem SmoothOn.mdifferentiableOn (hf : SmoothOn I I' f s) : MDifferentiableOn I I' f s", "start": [689, 1], "end": [690, 30], "kind": "commanddeclaration"}, {"full_name": "Smooth.mdifferentiable", "code": "theorem Smooth.mdifferentiable (hf : Smooth I I' f) : MDifferentiable I I' f", "start": [693, 1], "end": [694, 38], "kind": "commanddeclaration"}, {"full_name": "Smooth.mdifferentiableAt", "code": "theorem Smooth.mdifferentiableAt (hf : Smooth I I' f) : MDifferentiableAt I I' f x", "start": [697, 1], "end": [698, 23], "kind": "commanddeclaration"}, {"full_name": "Smooth.mdifferentiableWithinAt", "code": "theorem Smooth.mdifferentiableWithinAt (hf : Smooth I I' f) : MDifferentiableWithinAt I I' f s x", "start": [701, 1], "end": [702, 47], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.continuousWithinAt", "code": "theorem HasMFDerivWithinAt.continuousWithinAt (h : HasMFDerivWithinAt I I' f s x f') :\n    ContinuousWithinAt f s x", "start": [707, 1], "end": [709, 6], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.continuousAt", "code": "theorem HasMFDerivAt.continuousAt (h : HasMFDerivAt I I' f x f') : ContinuousAt f x", "start": [712, 1], "end": [713, 6], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.continuousWithinAt", "code": "theorem MDifferentiableWithinAt.continuousWithinAt (h : MDifferentiableWithinAt I I' f s x) :\n    ContinuousWithinAt f s x", "start": [716, 1], "end": [718, 6], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.continuousAt", "code": "theorem MDifferentiableAt.continuousAt (h : MDifferentiableAt I I' f x) : ContinuousAt f x", "start": [721, 1], "end": [722, 6], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.continuousOn", "code": "theorem MDifferentiableOn.continuousOn (h : MDifferentiableOn I I' f s) : ContinuousOn f s", "start": [725, 1], "end": [726, 42], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.continuous", "code": "theorem MDifferentiable.continuous (h : MDifferentiable I I' f) : Continuous f", "start": [729, 1], "end": [730, 60], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_subset", "code": "theorem tangentMapWithin_subset {p : TangentBundle I M} (st : s \u2286 t)\n    (hs : UniqueMDiffWithinAt I s p.1) (h : MDifferentiableWithinAt I I' f t p.1) :\n    tangentMapWithin I I' f s p = tangentMapWithin I I' f t p", "start": [733, 1], "end": [737, 36], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_univ", "code": "theorem tangentMapWithin_univ : tangentMapWithin I I' f univ = tangentMap I I' f", "start": [740, 1], "end": [742, 55], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_eq_tangentMap", "code": "theorem tangentMapWithin_eq_tangentMap {p : TangentBundle I M} (hs : UniqueMDiffWithinAt I s p.1)\n    (h : MDifferentiableAt I I' f p.1) : tangentMapWithin I I' f s p = tangentMap I I' f p", "start": [745, 1], "end": [749, 53], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_proj", "code": "@[simp, mfld_simps]\ntheorem tangentMapWithin_proj {p : TangentBundle I M} :\n    (tangentMapWithin I I' f s p).proj = f p.proj", "start": [752, 1], "end": [755, 6], "kind": "commanddeclaration"}, {"full_name": "tangentMap_proj", "code": "@[simp, mfld_simps]\ntheorem tangentMap_proj {p : TangentBundle I M} : (tangentMap I I' f p).proj = f p.proj", "start": [758, 1], "end": [760, 6], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.prod_mk", "code": "theorem MDifferentiableWithinAt.prod_mk {f : M \u2192 M'} {g : M \u2192 M''}\n    (hf : MDifferentiableWithinAt I I' f s x) (hg : MDifferentiableWithinAt I I'' g s x) :\n    MDifferentiableWithinAt I (I'.prod I'') (fun x => (f x, g x)) s x", "start": [763, 1], "end": [766, 35], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.prod_mk", "code": "theorem MDifferentiableAt.prod_mk {f : M \u2192 M'} {g : M \u2192 M''} (hf : MDifferentiableAt I I' f x)\n    (hg : MDifferentiableAt I I'' g x) :\n    MDifferentiableAt I (I'.prod I'') (fun x => (f x, g x)) x", "start": [769, 1], "end": [772, 35], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.prod_mk", "code": "theorem MDifferentiableOn.prod_mk {f : M \u2192 M'} {g : M \u2192 M''} (hf : MDifferentiableOn I I' f s)\n    (hg : MDifferentiableOn I I'' g s) :\n    MDifferentiableOn I (I'.prod I'') (fun x => (f x, g x)) s", "start": [775, 1], "end": [778, 30], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.prod_mk", "code": "theorem MDifferentiable.prod_mk {f : M \u2192 M'} {g : M \u2192 M''} (hf : MDifferentiable I I' f)\n    (hg : MDifferentiable I I'' g) : MDifferentiable I (I'.prod I'') fun x => (f x, g x)", "start": [781, 1], "end": [783, 24], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.prod_mk_space", "code": "theorem MDifferentiableWithinAt.prod_mk_space {f : M \u2192 E'} {g : M \u2192 E''}\n    (hf : MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, E') f s x)\n    (hg : MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, E'') g s x) :\n    MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, E' \u00d7 E'') (fun x => (f x, g x)) s x", "start": [786, 1], "end": [790, 35], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.prod_mk_space", "code": "theorem MDifferentiableAt.prod_mk_space {f : M \u2192 E'} {g : M \u2192 E''}\n    (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f x) (hg : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E'') g x) :\n    MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E' \u00d7 E'') (fun x => (f x, g x)) x", "start": [793, 1], "end": [796, 35], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.prod_mk_space", "code": "theorem MDifferentiableOn.prod_mk_space {f : M \u2192 E'} {g : M \u2192 E''}\n    (hf : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, E') f s) (hg : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, E'') g s) :\n    MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, E' \u00d7 E'') (fun x => (f x, g x)) s", "start": [799, 1], "end": [802, 36], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.prod_mk_space", "code": "theorem MDifferentiable.prod_mk_space {f : M \u2192 E'} {g : M \u2192 E''} (hf : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') f)\n    (hg : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E'') g) : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E' \u00d7 E'') fun x => (f x, g x)", "start": [805, 1], "end": [807, 39], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.congr_of_eventuallyEq", "code": "theorem HasMFDerivWithinAt.congr_of_eventuallyEq (h : HasMFDerivWithinAt I I' f s x f')\n    (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : HasMFDerivWithinAt I I' f\u2081 s x f'", "start": [813, 1], "end": [823, 31], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.congr_mono", "code": "theorem HasMFDerivWithinAt.congr_mono (h : HasMFDerivWithinAt I I' f s x f')\n    (ht : \u2200 x \u2208 t, f\u2081 x = f x) (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) : HasMFDerivWithinAt I I' f\u2081 t x f'", "start": [826, 1], "end": [828, 68], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.congr_of_eventuallyEq", "code": "theorem HasMFDerivAt.congr_of_eventuallyEq (h : HasMFDerivAt I I' f x f') (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    HasMFDerivAt I I' f\u2081 x f'", "start": [831, 1], "end": [835, 24], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.congr_of_eventuallyEq", "code": "theorem MDifferentiableWithinAt.congr_of_eventuallyEq (h : MDifferentiableWithinAt I I' f s x)\n    (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) : MDifferentiableWithinAt I I' f\u2081 s x", "start": [838, 1], "end": [840, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.mdifferentiableWithinAt_iff", "code": "theorem Filter.EventuallyEq.mdifferentiableWithinAt_iff (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) :\n    MDifferentiableWithinAt I I' f s x \u2194 MDifferentiableWithinAt I I' f\u2081 s x", "start": [845, 1], "end": [854, 18], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.congr_mono", "code": "theorem MDifferentiableWithinAt.congr_mono (h : MDifferentiableWithinAt I I' f s x)\n    (ht : \u2200 x \u2208 t, f\u2081 x = f x) (hx : f\u2081 x = f x) (h\u2081 : t \u2286 s) :\n    MDifferentiableWithinAt I I' f\u2081 t x", "start": [859, 1], "end": [862, 88], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.congr", "code": "theorem MDifferentiableWithinAt.congr (h : MDifferentiableWithinAt I I' f s x)\n    (ht : \u2200 x \u2208 s, f\u2081 x = f x) (hx : f\u2081 x = f x) : MDifferentiableWithinAt I I' f\u2081 s x", "start": [865, 1], "end": [867, 101], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.congr_mono", "code": "theorem MDifferentiableOn.congr_mono (h : MDifferentiableOn I I' f s) (h' : \u2200 x \u2208 t, f\u2081 x = f x)\n    (h\u2081 : t \u2286 s) : MDifferentiableOn I I' f\u2081 t", "start": [870, 1], "end": [872, 43], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.congr_of_eventuallyEq", "code": "theorem MDifferentiableAt.congr_of_eventuallyEq (h : MDifferentiableAt I I' f x)\n    (hL : f\u2081 =\u1da0[\ud835\udcdd x] f) : MDifferentiableAt I I' f\u2081 x", "start": [875, 1], "end": [877, 62], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.mfderivWithin_congr_mono", "code": "theorem MDifferentiableWithinAt.mfderivWithin_congr_mono (h : MDifferentiableWithinAt I I' f s x)\n    (hs : \u2200 x \u2208 t, f\u2081 x = f x) (hx : f\u2081 x = f x) (hxt : UniqueMDiffWithinAt I t x) (h\u2081 : t \u2286 s) :\n    mfderivWithin I I' f\u2081 t x = (mfderivWithin I I' f s x : _)", "start": [880, 1], "end": [883, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.mfderivWithin_eq", "code": "theorem Filter.EventuallyEq.mfderivWithin_eq (hs : UniqueMDiffWithinAt I s x) (hL : f\u2081 =\u1da0[\ud835\udcdd[s] x] f)\n    (hx : f\u2081 x = f x) : mfderivWithin I I' f\u2081 s x = (mfderivWithin I I' f s x : _)", "start": [886, 1], "end": [892, 51], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_congr", "code": "theorem mfderivWithin_congr (hs : UniqueMDiffWithinAt I s x) (hL : \u2200 x \u2208 s, f\u2081 x = f x)\n    (hx : f\u2081 x = f x) : mfderivWithin I I' f\u2081 s x = (mfderivWithin I I' f s x : _)", "start": [895, 1], "end": [897, 97], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_congr", "code": "theorem tangentMapWithin_congr (h : \u2200 x \u2208 s, f x = f\u2081 x) (p : TangentBundle I M) (hp : p.1 \u2208 s)\n    (hs : UniqueMDiffWithinAt I s p.1) :\n    tangentMapWithin I I' f s p = tangentMapWithin I I' f\u2081 s p", "start": [900, 1], "end": [905, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.mfderiv_eq", "code": "theorem Filter.EventuallyEq.mfderiv_eq (hL : f\u2081 =\u1da0[\ud835\udcdd x] f) :\n    mfderiv I I' f\u2081 x = (mfderiv I I' f x : _)", "start": [908, 1], "end": [913, 59], "kind": "commanddeclaration"}, {"full_name": "mfderiv_congr_point", "code": "theorem mfderiv_congr_point {x' : M} (h : x = x') :\n    @Eq (E \u2192L[\ud835\udd5c] E') (mfderiv I I' f x) (mfderiv I I' f x')", "start": [916, 1], "end": [919, 79], "kind": "commanddeclaration"}, {"full_name": "mfderiv_congr", "code": "theorem mfderiv_congr {f' : M \u2192 M'} (h : f = f') :\n    @Eq (E \u2192L[\ud835\udd5c] E') (mfderiv I I' f x) (mfderiv I I' f' x)", "start": [922, 1], "end": [925, 79], "kind": "commanddeclaration"}, {"full_name": "writtenInExtChartAt_comp", "code": "theorem writtenInExtChartAt_comp (h : ContinuousWithinAt f s x) :\n    {y | writtenInExtChartAt I I'' x (g \u2218 f) y =\n          (writtenInExtChartAt I' I'' (f x) g \u2218 writtenInExtChartAt I I' x f) y} \u2208\n      \ud835\udcdd[(extChartAt I x).symm \u207b\u00b9' s \u2229 range I] (extChartAt I x) x", "start": [930, 1], "end": [938, 15], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.comp", "code": "theorem HasMFDerivWithinAt.comp (hg : HasMFDerivWithinAt I' I'' g u (f x) g')\n    (hf : HasMFDerivWithinAt I I' f s x f') (hst : s \u2286 f \u207b\u00b9' u) :\n    HasMFDerivWithinAt I I'' (g \u2218 f) s x (g'.comp f')", "start": [943, 1], "end": [967, 25], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.comp", "code": "theorem HasMFDerivAt.comp (hg : HasMFDerivAt I' I'' g (f x) g') (hf : HasMFDerivAt I I' f x f') :\n    HasMFDerivAt I I'' (g \u2218 f) x (g'.comp f')", "start": [970, 1], "end": [974, 84], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.comp_hasMFDerivWithinAt", "code": "theorem HasMFDerivAt.comp_hasMFDerivWithinAt (hg : HasMFDerivAt I' I'' g (f x) g')\n    (hf : HasMFDerivWithinAt I I' f s x f') :\n    HasMFDerivWithinAt I I'' (g \u2218 f) s x (g'.comp f')", "start": [977, 1], "end": [981, 84], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.comp", "code": "theorem MDifferentiableWithinAt.comp (hg : MDifferentiableWithinAt I' I'' g u (f x))\n    (hf : MDifferentiableWithinAt I I' f s x) (h : s \u2286 f \u207b\u00b9' u) :\n    MDifferentiableWithinAt I I'' (g \u2218 f) s x", "start": [984, 1], "end": [991, 66], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.comp", "code": "theorem MDifferentiableAt.comp (hg : MDifferentiableAt I' I'' g (f x))\n    (hf : MDifferentiableAt I I' f x) : MDifferentiableAt I I'' (g \u2218 f) x", "start": [994, 1], "end": [996, 61], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_comp", "code": "theorem mfderivWithin_comp (hg : MDifferentiableWithinAt I' I'' g u (f x))\n    (hf : MDifferentiableWithinAt I I' f s x) (h : s \u2286 f \u207b\u00b9' u) (hxs : UniqueMDiffWithinAt I s x) :\n    mfderivWithin I I'' (g \u2218 f) s x =\n      (mfderivWithin I' I'' g u (f x)).comp (mfderivWithin I I' f s x)", "start": [999, 1], "end": [1004, 80], "kind": "commanddeclaration"}, {"full_name": "mfderiv_comp", "code": "theorem mfderiv_comp (hg : MDifferentiableAt I' I'' g (f x)) (hf : MDifferentiableAt I I' f x) :\n    mfderiv I I'' (g \u2218 f) x = (mfderiv I' I'' g (f x)).comp (mfderiv I I' f x)", "start": [1007, 1], "end": [1010, 60], "kind": "commanddeclaration"}, {"full_name": "mfderiv_comp_of_eq", "code": "theorem mfderiv_comp_of_eq {x : M} {y : M'} (hg : MDifferentiableAt I' I'' g y)\n    (hf : MDifferentiableAt I I' f x) (hy : f x = y) :\n    mfderiv I I'' (g \u2218 f) x = (mfderiv I' I'' g (f x)).comp (mfderiv I I' f x)", "start": [1013, 1], "end": [1016, 39], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.comp", "code": "theorem MDifferentiableOn.comp (hg : MDifferentiableOn I' I'' g u) (hf : MDifferentiableOn I I' f s)\n    (st : s \u2286 f \u207b\u00b9' u) : MDifferentiableOn I I'' (g \u2218 f) s", "start": [1019, 1], "end": [1021, 65], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.comp", "code": "theorem MDifferentiable.comp (hg : MDifferentiable I' I'' g) (hf : MDifferentiable I I' f) :\n    MDifferentiable I I'' (g \u2218 f)", "start": [1024, 1], "end": [1025, 89], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_comp_at", "code": "theorem tangentMapWithin_comp_at (p : TangentBundle I M)\n    (hg : MDifferentiableWithinAt I' I'' g u (f p.1)) (hf : MDifferentiableWithinAt I I' f s p.1)\n    (h : s \u2286 f \u207b\u00b9' u) (hps : UniqueMDiffWithinAt I s p.1) :\n    tangentMapWithin I I'' (g \u2218 f) s p =\n      tangentMapWithin I' I'' g u (tangentMapWithin I I' f s p)", "start": [1028, 1], "end": [1035, 6], "kind": "commanddeclaration"}, {"full_name": "tangentMap_comp_at", "code": "theorem tangentMap_comp_at (p : TangentBundle I M) (hg : MDifferentiableAt I' I'' g (f p.1))\n    (hf : MDifferentiableAt I I' f p.1) :\n    tangentMap I I'' (g \u2218 f) p = tangentMap I' I'' g (tangentMap I I' f p)", "start": [1038, 1], "end": [1043, 6], "kind": "commanddeclaration"}, {"full_name": "tangentMap_comp", "code": "theorem tangentMap_comp (hg : MDifferentiable I' I'' g) (hf : MDifferentiable I I' f) :\n    tangentMap I I'' (g \u2218 f) = tangentMap I' I'' g \u2218 tangentMap I I' f", "start": [1046, 1], "end": [1048, 54], "kind": "commanddeclaration"}, {"full_name": "uniqueMDiffWithinAt_iff_uniqueDiffWithinAt", "code": "theorem uniqueMDiffWithinAt_iff_uniqueDiffWithinAt :\n    UniqueMDiffWithinAt \ud835\udcd8(\ud835\udd5c, E) s x \u2194 UniqueDiffWithinAt \ud835\udd5c s x", "start": [1068, 1], "end": [1070, 46], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.uniqueDiffWithinAt", "code": "alias \u27e8UniqueMDiffWithinAt.uniqueDiffWithinAt, UniqueDiffWithinAt.uniqueMDiffWithinAt\u27e9 :=\n  uniqueMDiffWithinAt_iff_uniqueDiffWithinAt", "start": [1073, 1], "end": [1074, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "UniqueDiffWithinAt.uniqueMDiffWithinAt", "code": "alias \u27e8UniqueMDiffWithinAt.uniqueDiffWithinAt, UniqueDiffWithinAt.uniqueMDiffWithinAt\u27e9 :=\n  uniqueMDiffWithinAt_iff_uniqueDiffWithinAt", "start": [1073, 1], "end": [1074, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "uniqueMDiffOn_iff_uniqueDiffOn", "code": "theorem uniqueMDiffOn_iff_uniqueDiffOn : UniqueMDiffOn \ud835\udcd8(\ud835\udd5c, E) s \u2194 UniqueDiffOn \ud835\udd5c s", "start": [1078, 1], "end": [1079, 81], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.uniqueDiffOn", "code": "alias \u27e8UniqueMDiffOn.uniqueDiffOn, UniqueDiffOn.uniqueMDiffOn\u27e9 := uniqueMDiffOn_iff_uniqueDiffOn", "start": [1082, 1], "end": [1082, 97], "kind": "stdtacticaliasaliaslr"}, {"full_name": "UniqueDiffOn.uniqueMDiffOn", "code": "alias \u27e8UniqueMDiffOn.uniqueDiffOn, UniqueDiffOn.uniqueMDiffOn\u27e9 := uniqueMDiffOn_iff_uniqueDiffOn", "start": [1082, 1], "end": [1082, 97], "kind": "stdtacticaliasaliaslr"}, {"full_name": "writtenInExtChartAt_model_space", "code": "theorem writtenInExtChartAt_model_space : writtenInExtChartAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') x f = f", "start": [1087, 1], "end": [1088, 6], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_iff_hasFDerivWithinAt", "code": "theorem hasMFDerivWithinAt_iff_hasFDerivWithinAt {f'} :\n    HasMFDerivWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x f' \u2194 HasFDerivWithinAt f f' s x", "start": [1091, 1], "end": [1094, 41], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.hasFDerivWithinAt", "code": "alias \u27e8HasMFDerivWithinAt.hasFDerivWithinAt, HasFDerivWithinAt.hasMFDerivWithinAt\u27e9 :=\n  hasMFDerivWithinAt_iff_hasFDerivWithinAt", "start": [1097, 1], "end": [1098, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasFDerivWithinAt.hasMFDerivWithinAt", "code": "alias \u27e8HasMFDerivWithinAt.hasFDerivWithinAt, HasFDerivWithinAt.hasMFDerivWithinAt\u27e9 :=\n  hasMFDerivWithinAt_iff_hasFDerivWithinAt", "start": [1097, 1], "end": [1098, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "hasMFDerivAt_iff_hasFDerivAt", "code": "theorem hasMFDerivAt_iff_hasFDerivAt {f'} :\n    HasMFDerivAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x f' \u2194 HasFDerivAt f f' x", "start": [1102, 1], "end": [1104, 99], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.hasFDerivAt", "code": "alias \u27e8HasMFDerivAt.hasFDerivAt, HasFDerivAt.hasMFDerivAt\u27e9 := hasMFDerivAt_iff_hasFDerivAt", "start": [1107, 1], "end": [1107, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasFDerivAt.hasMFDerivAt", "code": "alias \u27e8HasMFDerivAt.hasFDerivAt, HasFDerivAt.hasMFDerivAt\u27e9 := hasMFDerivAt_iff_hasFDerivAt", "start": [1107, 1], "end": [1107, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mdifferentiableWithinAt_iff_differentiableWithinAt", "code": "theorem mdifferentiableWithinAt_iff_differentiableWithinAt :\n    MDifferentiableWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x", "start": [1111, 1], "end": [1116, 59], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.differentiableWithinAt", "code": "alias \u27e8MDifferentiableWithinAt.differentiableWithinAt,\n    DifferentiableWithinAt.mdifferentiableWithinAt\u27e9 :=\n  mdifferentiableWithinAt_iff_differentiableWithinAt", "start": [1119, 1], "end": [1121, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "DifferentiableWithinAt.mdifferentiableWithinAt", "code": "alias \u27e8MDifferentiableWithinAt.differentiableWithinAt,\n    DifferentiableWithinAt.mdifferentiableWithinAt\u27e9 :=\n  mdifferentiableWithinAt_iff_differentiableWithinAt", "start": [1119, 1], "end": [1121, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mdifferentiableAt_iff_differentiableAt", "code": "theorem mdifferentiableAt_iff_differentiableAt :\n    MDifferentiableAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x \u2194 DifferentiableAt \ud835\udd5c f x", "start": [1125, 1], "end": [1129, 53], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.differentiableAt", "code": "alias \u27e8MDifferentiableAt.differentiableAt, DifferentiableAt.mdifferentiableAt\u27e9 :=\n  mdifferentiableAt_iff_differentiableAt", "start": [1132, 1], "end": [1133, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "DifferentiableAt.mdifferentiableAt", "code": "alias \u27e8MDifferentiableAt.differentiableAt, DifferentiableAt.mdifferentiableAt\u27e9 :=\n  mdifferentiableAt_iff_differentiableAt", "start": [1132, 1], "end": [1133, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mdifferentiableOn_iff_differentiableOn", "code": "theorem mdifferentiableOn_iff_differentiableOn :\n    MDifferentiableOn \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s \u2194 DifferentiableOn \ud835\udd5c f s", "start": [1137, 1], "end": [1141, 56], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.differentiableOn", "code": "alias \u27e8MDifferentiableOn.differentiableOn, DifferentiableOn.mdifferentiableOn\u27e9 :=\n  mdifferentiableOn_iff_differentiableOn", "start": [1144, 1], "end": [1145, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "DifferentiableOn.mdifferentiableOn", "code": "alias \u27e8MDifferentiableOn.differentiableOn, DifferentiableOn.mdifferentiableOn\u27e9 :=\n  mdifferentiableOn_iff_differentiableOn", "start": [1144, 1], "end": [1145, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mdifferentiable_iff_differentiable", "code": "theorem mdifferentiable_iff_differentiable :\n    MDifferentiable \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f \u2194 Differentiable \ud835\udd5c f", "start": [1149, 1], "end": [1152, 86], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.differentiable", "code": "alias \u27e8MDifferentiable.differentiable, Differentiable.mdifferentiable\u27e9 :=\n  mdifferentiable_iff_differentiable", "start": [1155, 1], "end": [1156, 37], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Differentiable.mdifferentiable", "code": "alias \u27e8MDifferentiable.differentiable, Differentiable.mdifferentiable\u27e9 :=\n  mdifferentiable_iff_differentiable", "start": [1155, 1], "end": [1156, 37], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mfderivWithin_eq_fderivWithin", "code": "@[simp]\ntheorem mfderivWithin_eq_fderivWithin :\n    mfderivWithin \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x = fderivWithin \ud835\udd5c f s x", "start": [1160, 1], "end": [1168, 67], "kind": "commanddeclaration"}, {"full_name": "mfderiv_eq_fderiv", "code": "@[simp]\ntheorem mfderiv_eq_fderiv : mfderiv \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x = fderiv \ud835\udd5c f x", "start": [1171, 1], "end": [1175, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasMFDerivWithinAt", "code": "protected theorem hasMFDerivWithinAt : HasMFDerivWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x f", "start": [1198, 1], "end": [1199, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.hasMFDerivAt", "code": "protected theorem hasMFDerivAt : HasMFDerivAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x f", "start": [1202, 1], "end": [1203, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mdifferentiableWithinAt", "code": "protected theorem mdifferentiableWithinAt : MDifferentiableWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x", "start": [1206, 1], "end": [1207, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mdifferentiableOn", "code": "protected theorem mdifferentiableOn : MDifferentiableOn \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s", "start": [1210, 1], "end": [1211, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mdifferentiableAt", "code": "protected theorem mdifferentiableAt : MDifferentiableAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x", "start": [1214, 1], "end": [1215, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mdifferentiable", "code": "protected theorem mdifferentiable : MDifferentiable \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f", "start": [1218, 1], "end": [1219, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mfderiv_eq", "code": "theorem mfderiv_eq : mfderiv \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x = f", "start": [1222, 1], "end": [1223, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.mfderivWithin_eq", "code": "theorem mfderivWithin_eq (hs : UniqueMDiffWithinAt \ud835\udcd8(\ud835\udd5c, E) s x) :\n    mfderivWithin \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x = f", "start": [1226, 1], "end": [1228, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.hasMFDerivWithinAt", "code": "protected theorem hasMFDerivWithinAt : HasMFDerivWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x (f : E \u2192L[\ud835\udd5c] E')", "start": [1237, 1], "end": [1238, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.hasMFDerivAt", "code": "protected theorem hasMFDerivAt : HasMFDerivAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x (f : E \u2192L[\ud835\udd5c] E')", "start": [1241, 1], "end": [1242, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mdifferentiableWithinAt", "code": "protected theorem mdifferentiableWithinAt : MDifferentiableWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x", "start": [1245, 1], "end": [1246, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mdifferentiableOn", "code": "protected theorem mdifferentiableOn : MDifferentiableOn \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s", "start": [1249, 1], "end": [1250, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mdifferentiableAt", "code": "protected theorem mdifferentiableAt : MDifferentiableAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x", "start": [1253, 1], "end": [1254, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mdifferentiable", "code": "protected theorem mdifferentiable : MDifferentiable \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f", "start": [1257, 1], "end": [1258, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mfderiv_eq", "code": "theorem mfderiv_eq : mfderiv \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f x = (f : E \u2192L[\ud835\udd5c] E')", "start": [1261, 1], "end": [1262, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearEquiv.mfderivWithin_eq", "code": "theorem mfderivWithin_eq (hs : UniqueMDiffWithinAt \ud835\udcd8(\ud835\udd5c, E) s x) :\n    mfderivWithin \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x = (f : E \u2192L[\ud835\udd5c] E')", "start": [1265, 1], "end": [1267, 40], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_id", "code": "theorem hasMFDerivAt_id (x : M) :\n    HasMFDerivAt I I (@id M) x (ContinuousLinearMap.id \ud835\udd5c (TangentSpace I x))", "start": [1278, 1], "end": [1285, 25], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_id", "code": "theorem hasMFDerivWithinAt_id (s : Set M) (x : M) :\n    HasMFDerivWithinAt I I (@id M) s x (ContinuousLinearMap.id \ud835\udd5c (TangentSpace I x))", "start": [1288, 1], "end": [1290, 43], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_id", "code": "theorem mdifferentiableAt_id : MDifferentiableAt I I (@id M) x", "start": [1293, 1], "end": [1294, 42], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_id", "code": "theorem mdifferentiableWithinAt_id : MDifferentiableWithinAt I I (@id M) s x", "start": [1297, 1], "end": [1298, 51], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_id", "code": "theorem mdifferentiable_id : MDifferentiable I I (@id M)", "start": [1301, 1], "end": [1301, 92], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_id", "code": "theorem mdifferentiableOn_id : MDifferentiableOn I I (@id M) s", "start": [1304, 1], "end": [1305, 43], "kind": "commanddeclaration"}, {"full_name": "mfderiv_id", "code": "@[simp, mfld_simps]\ntheorem mfderiv_id : mfderiv I I (@id M) x = ContinuousLinearMap.id \ud835\udd5c (TangentSpace I x)", "start": [1308, 1], "end": [1310, 45], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_id", "code": "theorem mfderivWithin_id (hxs : UniqueMDiffWithinAt I s x) :\n    mfderivWithin I I (@id M) s x = ContinuousLinearMap.id \ud835\udd5c (TangentSpace I x)", "start": [1313, 1], "end": [1316, 21], "kind": "commanddeclaration"}, {"full_name": "tangentMap_id", "code": "@[simp, mfld_simps]\ntheorem tangentMap_id : tangentMap I I (id : M \u2192 M) = id", "start": [1319, 1], "end": [1320, 94], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_id", "code": "theorem tangentMapWithin_id {p : TangentBundle I M} (hs : UniqueMDiffWithinAt I s p.proj) :\n    tangentMapWithin I I (id : M \u2192 M) s p = p", "start": [1323, 1], "end": [1328, 13], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_const", "code": "theorem hasMFDerivAt_const (c : M') (x : M) :\n    HasMFDerivAt I I' (fun _ : M => c) x (0 : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' c)", "start": [1340, 1], "end": [1343, 68], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_const", "code": "theorem hasMFDerivWithinAt_const (c : M') (s : Set M) (x : M) :\n    HasMFDerivWithinAt I I' (fun _ : M => c) s x (0 : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' c)", "start": [1346, 1], "end": [1348, 51], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_const", "code": "theorem mdifferentiableAt_const : MDifferentiableAt I I' (fun _ : M => c) x", "start": [1351, 1], "end": [1352, 50], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_const", "code": "theorem mdifferentiableWithinAt_const : MDifferentiableWithinAt I I' (fun _ : M => c) s x", "start": [1355, 1], "end": [1356, 57], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_const", "code": "theorem mdifferentiable_const : MDifferentiable I I' fun _ : M => c", "start": [1359, 1], "end": [1360, 31], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_const", "code": "theorem mdifferentiableOn_const : MDifferentiableOn I I' (fun _ : M => c) s", "start": [1363, 1], "end": [1364, 49], "kind": "commanddeclaration"}, {"full_name": "mfderiv_const", "code": "@[simp, mfld_simps]\ntheorem mfderiv_const :\n    mfderiv I I' (fun _ : M => c) x = (0 : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' c)", "start": [1367, 1], "end": [1370, 53], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_const", "code": "theorem mfderivWithin_const (hxs : UniqueMDiffWithinAt I s x) :\n    mfderivWithin I I' (fun _ : M => c) s x = (0 : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I' c)", "start": [1373, 1], "end": [1375, 57], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_fst", "code": "theorem hasMFDerivAt_fst (x : M \u00d7 M') :\n    HasMFDerivAt (I.prod I') I Prod.fst x\n      (ContinuousLinearMap.fst \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2))", "start": [1384, 1], "end": [1400, 98], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_fst", "code": "theorem hasMFDerivWithinAt_fst (s : Set (M \u00d7 M')) (x : M \u00d7 M') :\n    HasMFDerivWithinAt (I.prod I') I Prod.fst s x\n      (ContinuousLinearMap.fst \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2))", "start": [1403, 1], "end": [1406, 47], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_fst", "code": "theorem mdifferentiableAt_fst {x : M \u00d7 M'} : MDifferentiableAt (I.prod I') I Prod.fst x", "start": [1409, 1], "end": [1410, 46], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_fst", "code": "theorem mdifferentiableWithinAt_fst {s : Set (M \u00d7 M')} {x : M \u00d7 M'} :\n    MDifferentiableWithinAt (I.prod I') I Prod.fst s x", "start": [1413, 1], "end": [1415, 55], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_fst", "code": "theorem mdifferentiable_fst : MDifferentiable (I.prod I') I (Prod.fst : M \u00d7 M' \u2192 M)", "start": [1418, 1], "end": [1419, 29], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_fst", "code": "theorem mdifferentiableOn_fst {s : Set (M \u00d7 M')} : MDifferentiableOn (I.prod I') I Prod.fst s", "start": [1422, 1], "end": [1423, 47], "kind": "commanddeclaration"}, {"full_name": "mfderiv_fst", "code": "@[simp, mfld_simps]\ntheorem mfderiv_fst {x : M \u00d7 M'} :\n    mfderiv (I.prod I') I Prod.fst x =\n      ContinuousLinearMap.fst \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2)", "start": [1426, 1], "end": [1430, 36], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_fst", "code": "theorem mfderivWithin_fst {s : Set (M \u00d7 M')} {x : M \u00d7 M'}\n    (hxs : UniqueMDiffWithinAt (I.prod I') s x) :\n    mfderivWithin (I.prod I') I Prod.fst s x =\n      ContinuousLinearMap.fst \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2)", "start": [1433, 1], "end": [1437, 97], "kind": "commanddeclaration"}, {"full_name": "tangentMap_prod_fst", "code": "@[simp, mfld_simps]\ntheorem tangentMap_prod_fst {p : TangentBundle (I.prod I') (M \u00d7 M')} :\n    tangentMap (I.prod I') I Prod.fst p = \u27e8p.proj.1, p.2.1\u27e9", "start": [1440, 1], "end": [1444, 25], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_prod_fst", "code": "theorem tangentMapWithin_prod_fst {s : Set (M \u00d7 M')} {p : TangentBundle (I.prod I') (M \u00d7 M')}\n    (hs : UniqueMDiffWithinAt (I.prod I') s p.proj) :\n    tangentMapWithin (I.prod I') I Prod.fst s p = \u27e8p.proj.1, p.2.1\u27e9", "start": [1447, 1], "end": [1453, 13], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_snd", "code": "theorem hasMFDerivAt_snd (x : M \u00d7 M') :\n    HasMFDerivAt (I.prod I') I' Prod.snd x\n      (ContinuousLinearMap.snd \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2))", "start": [1456, 1], "end": [1472, 100], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_snd", "code": "theorem hasMFDerivWithinAt_snd (s : Set (M \u00d7 M')) (x : M \u00d7 M') :\n    HasMFDerivWithinAt (I.prod I') I' Prod.snd s x\n      (ContinuousLinearMap.snd \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2))", "start": [1475, 1], "end": [1478, 47], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_snd", "code": "theorem mdifferentiableAt_snd {x : M \u00d7 M'} : MDifferentiableAt (I.prod I') I' Prod.snd x", "start": [1481, 1], "end": [1482, 46], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableWithinAt_snd", "code": "theorem mdifferentiableWithinAt_snd {s : Set (M \u00d7 M')} {x : M \u00d7 M'} :\n    MDifferentiableWithinAt (I.prod I') I' Prod.snd s x", "start": [1485, 1], "end": [1487, 55], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_snd", "code": "theorem mdifferentiable_snd : MDifferentiable (I.prod I') I' (Prod.snd : M \u00d7 M' \u2192 M')", "start": [1490, 1], "end": [1491, 29], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_snd", "code": "theorem mdifferentiableOn_snd {s : Set (M \u00d7 M')} : MDifferentiableOn (I.prod I') I' Prod.snd s", "start": [1494, 1], "end": [1495, 47], "kind": "commanddeclaration"}, {"full_name": "mfderiv_snd", "code": "@[simp, mfld_simps]\ntheorem mfderiv_snd {x : M \u00d7 M'} :\n    mfderiv (I.prod I') I' Prod.snd x =\n      ContinuousLinearMap.snd \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2)", "start": [1498, 1], "end": [1502, 36], "kind": "commanddeclaration"}, {"full_name": "mfderivWithin_snd", "code": "theorem mfderivWithin_snd {s : Set (M \u00d7 M')} {x : M \u00d7 M'}\n    (hxs : UniqueMDiffWithinAt (I.prod I') s x) :\n    mfderivWithin (I.prod I') I' Prod.snd s x =\n      ContinuousLinearMap.snd \ud835\udd5c (TangentSpace I x.1) (TangentSpace I' x.2)", "start": [1505, 1], "end": [1509, 97], "kind": "commanddeclaration"}, {"full_name": "tangentMap_prod_snd", "code": "@[simp, mfld_simps]\ntheorem tangentMap_prod_snd {p : TangentBundle (I.prod I') (M \u00d7 M')} :\n    tangentMap (I.prod I') I' Prod.snd p = \u27e8p.proj.2, p.2.2\u27e9", "start": [1512, 1], "end": [1516, 25], "kind": "commanddeclaration"}, {"full_name": "tangentMapWithin_prod_snd", "code": "theorem tangentMapWithin_prod_snd {s : Set (M \u00d7 M')} {p : TangentBundle (I.prod I') (M \u00d7 M')}\n    (hs : UniqueMDiffWithinAt (I.prod I') s p.proj) :\n    tangentMapWithin (I.prod I') I' Prod.snd s p = \u27e8p.proj.2, p.2.2\u27e9", "start": [1519, 1], "end": [1525, 13], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.mfderiv_prod", "code": "theorem MDifferentiableAt.mfderiv_prod {f : M \u2192 M'} {g : M \u2192 M''} {x : M}\n    (hf : MDifferentiableAt I I' f x) (hg : MDifferentiableAt I I'' g x) :\n    mfderiv I (I'.prod I'') (fun x => (f x, g x)) x =\n      (mfderiv I I' f x).prod (mfderiv I I'' g x)", "start": [1530, 1], "end": [1536, 73], "kind": "commanddeclaration"}, {"full_name": "mfderiv_prod_left", "code": "theorem mfderiv_prod_left {x\u2080 : M} {y\u2080 : M'} :\n    mfderiv I (I.prod I') (fun x => (x, y\u2080)) x\u2080 =\n      ContinuousLinearMap.inl \ud835\udd5c (TangentSpace I x\u2080) (TangentSpace I' y\u2080)", "start": [1541, 1], "end": [1545, 58], "kind": "commanddeclaration"}, {"full_name": "mfderiv_prod_right", "code": "theorem mfderiv_prod_right {x\u2080 : M} {y\u2080 : M'} :\n    mfderiv I' (I.prod I') (fun y => (x\u2080, y)) y\u2080 =\n      ContinuousLinearMap.inr \ud835\udd5c (TangentSpace I x\u2080) (TangentSpace I' y\u2080)", "start": [1548, 1], "end": [1552, 58], "kind": "commanddeclaration"}, {"full_name": "mfderiv_prod_eq_add", "code": "theorem mfderiv_prod_eq_add {f : M \u00d7 M' \u2192 M''} {p : M \u00d7 M'}\n    (hf : MDifferentiableAt (I.prod I') I'' f p) :\n    mfderiv (I.prod I') I'' f p =\n      show E \u00d7 E' \u2192L[\ud835\udd5c] E'' from\n        mfderiv (I.prod I') I'' (fun z : M \u00d7 M' => f (z.1, p.2)) p +\n          mfderiv (I.prod I') I'' (fun z : M \u00d7 M' => f (p.1, z.2)) p", "start": [1555, 1], "end": [1574, 45], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.add", "code": "theorem HasMFDerivAt.add (hf : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') f z f')\n    (hg : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') g z g') : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') (f + g) z (f' + g')", "start": [1592, 1], "end": [1594, 33], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.add", "code": "theorem MDifferentiableAt.add (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z)\n    (hg : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') g z) : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') (f + g) z", "start": [1597, 1], "end": [1599, 58], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.add", "code": "theorem MDifferentiable.add (hf : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') f)\n    (hg : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') g) : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') (f + g)", "start": [1602, 1], "end": [1604, 20], "kind": "commanddeclaration"}, {"full_name": "mfderiv_add", "code": "theorem mfderiv_add (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z)\n    (hg : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') g z) :\n    (mfderiv I \ud835\udcd8(\ud835\udd5c, E') (f + g) z : TangentSpace I z \u2192L[\ud835\udd5c] E') =\n      @Add.add (TangentSpace I z \u2192L[\ud835\udd5c] E') _ (mfderiv I \ud835\udcd8(\ud835\udd5c, E') f z) (mfderiv I \ud835\udcd8(\ud835\udd5c, E') g z)", "start": [1608, 1], "end": [1612, 48], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.const_smul", "code": "theorem HasMFDerivAt.const_smul (hf : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') f z f') (s : \ud835\udd5c) :\n    HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') (s \u2022 f) z (s \u2022 f')", "start": [1615, 1], "end": [1617, 41], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.const_smul", "code": "theorem MDifferentiableAt.const_smul (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z) (s : \ud835\udd5c) :\n    MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') (s \u2022 f) z", "start": [1620, 1], "end": [1622, 51], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.const_smul", "code": "theorem MDifferentiable.const_smul (s : \ud835\udd5c) (hf : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') f) :\n    MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') (s \u2022 f)", "start": [1625, 1], "end": [1626, 71], "kind": "commanddeclaration"}, {"full_name": "const_smul_mfderiv", "code": "theorem const_smul_mfderiv (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z) (s : \ud835\udd5c) :\n    (mfderiv I \ud835\udcd8(\ud835\udd5c, E') (s \u2022 f) z : TangentSpace I z \u2192L[\ud835\udd5c] E') =\n      (s \u2022 mfderiv I \ud835\udcd8(\ud835\udd5c, E') f z : TangentSpace I z \u2192L[\ud835\udd5c] E')", "start": [1629, 1], "end": [1632, 41], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.neg", "code": "theorem HasMFDerivAt.neg (hf : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') f z f') :\n    HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') (-f) z (-f')", "start": [1635, 1], "end": [1637, 23], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_neg", "code": "theorem hasMFDerivAt_neg : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') (-f) z (-f') \u2194 HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') f z f'", "start": [1640, 1], "end": [1641, 67], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.neg", "code": "theorem MDifferentiableAt.neg (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z) :\n    MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') (-f) z", "start": [1644, 1], "end": [1646, 40], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_neg", "code": "theorem mdifferentiableAt_neg :\n    MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') (-f) z \u2194 MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z", "start": [1649, 1], "end": [1651, 64], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.neg", "code": "theorem MDifferentiable.neg (hf : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') f) : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') (-f)", "start": [1654, 1], "end": [1655, 22], "kind": "commanddeclaration"}, {"full_name": "mfderiv_neg", "code": "theorem mfderiv_neg (f : M \u2192 E') (x : M) :\n    (mfderiv I \ud835\udcd8(\ud835\udd5c, E') (-f) x : TangentSpace I x \u2192L[\ud835\udd5c] E') =\n      (-mfderiv I \ud835\udcd8(\ud835\udd5c, E') f x : TangentSpace I x \u2192L[\ud835\udd5c] E')", "start": [1658, 1], "end": [1664, 81], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.sub", "code": "theorem HasMFDerivAt.sub (hf : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') f z f')\n    (hg : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') g z g') : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E') (f - g) z (f' - g')", "start": [1667, 1], "end": [1669, 33], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.sub", "code": "theorem MDifferentiableAt.sub (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z)\n    (hg : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') g z) : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') (f - g) z", "start": [1672, 1], "end": [1674, 58], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.sub", "code": "theorem MDifferentiable.sub (hf : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') f)\n    (hg : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') g) : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E') (f - g)", "start": [1677, 1], "end": [1679, 20], "kind": "commanddeclaration"}, {"full_name": "mfderiv_sub", "code": "theorem mfderiv_sub (hf : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') f z)\n    (hg : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E') g z) :\n    (mfderiv I \ud835\udcd8(\ud835\udd5c, E') (f - g) z : TangentSpace I z \u2192L[\ud835\udd5c] E') =\n      @Sub.sub (TangentSpace I z \u2192L[\ud835\udd5c] E') _ (mfderiv I \ud835\udcd8(\ud835\udd5c, E') f z) (mfderiv I \ud835\udcd8(\ud835\udd5c, E') g z)", "start": [1682, 1], "end": [1686, 48], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mul'", "code": "theorem HasMFDerivWithinAt.mul' (hp : HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') p s z p')\n    (hq : HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') q s z q') :\n    HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) s z (p z \u2022 q' + p'.smulRight (q z) : E \u2192L[\ud835\udd5c] F')", "start": [1696, 1], "end": [1699, 67], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.mul'", "code": "theorem HasMFDerivAt.mul' (hp : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') p z p')\n    (hq : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') q z q') :\n    HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) z (p z \u2022 q' + p'.smulRight (q z) : E \u2192L[\ud835\udd5c] F')", "start": [1702, 1], "end": [1705, 81], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableWithinAt.mul", "code": "theorem MDifferentiableWithinAt.mul (hp : MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, F') p s z)\n    (hq : MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, F') q s z) :\n    MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) s z", "start": [1708, 1], "end": [1711, 77], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableAt.mul", "code": "theorem MDifferentiableAt.mul (hp : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, F') p z)\n    (hq : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, F') q z) : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) z", "start": [1714, 1], "end": [1716, 59], "kind": "commanddeclaration"}, {"full_name": "MDifferentiableOn.mul", "code": "theorem MDifferentiableOn.mul (hp : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, F') p s)\n    (hq : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, F') q s) : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, F') (p * q) s", "start": [1719, 1], "end": [1721, 27], "kind": "commanddeclaration"}, {"full_name": "MDifferentiable.mul", "code": "theorem MDifferentiable.mul (hp : MDifferentiable I \ud835\udcd8(\ud835\udd5c, F') p)\n    (hq : MDifferentiable I \ud835\udcd8(\ud835\udd5c, F') q) : MDifferentiable I \ud835\udcd8(\ud835\udd5c, F') (p * q)", "start": [1724, 1], "end": [1726, 20], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivWithinAt.mul", "code": "theorem HasMFDerivWithinAt.mul (hp : HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') p s z p')\n    (hq : HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') q s z q') :\n    HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) s z (p z \u2022 q' + q z \u2022 p' : E \u2192L[\ud835\udd5c] F')", "start": [1736, 1], "end": [1739, 44], "kind": "commanddeclaration"}, {"full_name": "HasMFDerivAt.mul", "code": "theorem HasMFDerivAt.mul (hp : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') p z p')\n    (hq : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') q z q') :\n    HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, F') (p * q) z (p z \u2022 q' + q z \u2022 p' : E \u2192L[\ud835\udd5c] F')", "start": [1742, 1], "end": [1745, 80], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.hasMFDerivAt", "code": "protected theorem hasMFDerivAt {x} : HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E) I x (ContinuousLinearMap.id _ _)", "start": [1757, 1], "end": [1758, 86], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.hasMFDerivWithinAt", "code": "protected theorem hasMFDerivWithinAt {s x} :\n    HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, E) I s x (ContinuousLinearMap.id _ _)", "start": [1761, 1], "end": [1763, 36], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.mdifferentiableWithinAt", "code": "protected theorem mdifferentiableWithinAt {s x} : MDifferentiableWithinAt I \ud835\udcd8(\ud835\udd5c, E) I s x", "start": [1766, 1], "end": [1767, 47], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.mdifferentiableAt", "code": "protected theorem mdifferentiableAt {x} : MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E) I x", "start": [1770, 1], "end": [1771, 35], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.mdifferentiableOn", "code": "protected theorem mdifferentiableOn {s} : MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, E) I s", "start": [1774, 1], "end": [1775, 28], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.mdifferentiable", "code": "protected theorem mdifferentiable : MDifferentiable I \ud835\udcd8(\ud835\udd5c, E) I", "start": [1778, 1], "end": [1778, 96], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.hasMFDerivWithinAt_symm", "code": "theorem hasMFDerivWithinAt_symm {x} (hx : x \u2208 range I) :\n    HasMFDerivWithinAt \ud835\udcd8(\ud835\udd5c, E) I I.symm (range I) x (ContinuousLinearMap.id _ _)", "start": [1781, 1], "end": [1784, 95], "kind": "commanddeclaration"}, {"full_name": "ModelWithCorners.mdifferentiableOn_symm", "code": "theorem mdifferentiableOn_symm : MDifferentiableOn \ud835\udcd8(\ud835\udd5c, E) I I.symm (range I)", "start": [1787, 1], "end": [1788, 57], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_atlas", "code": "theorem mdifferentiableAt_atlas (h : e \u2208 atlas H M) {x : M} (hx : x \u2208 e.source) :\n    MDifferentiableAt I I e x", "start": [1797, 1], "end": [1813, 93], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_atlas", "code": "theorem mdifferentiableOn_atlas (h : e \u2208 atlas H M) : MDifferentiableOn I I e e.source", "start": [1816, 1], "end": [1817, 72], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_atlas_symm", "code": "theorem mdifferentiableAt_atlas_symm (h : e \u2208 atlas H M) {x : H} (hx : x \u2208 e.target) :\n    MDifferentiableAt I I e.symm x", "start": [1820, 1], "end": [1835, 93], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_atlas_symm", "code": "theorem mdifferentiableOn_atlas_symm (h : e \u2208 atlas H M) : MDifferentiableOn I I e.symm e.target", "start": [1838, 1], "end": [1839, 77], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_of_mem_atlas", "code": "theorem mdifferentiable_of_mem_atlas (h : e \u2208 atlas H M) : e.MDifferentiable I I", "start": [1842, 1], "end": [1843, 66], "kind": "commanddeclaration"}, {"full_name": "mdifferentiable_chart", "code": "theorem mdifferentiable_chart (x : M) : (chartAt H x).MDifferentiable I I", "start": [1846, 1], "end": [1847, 55], "kind": "commanddeclaration"}, {"full_name": "tangentMap_chart", "code": "theorem tangentMap_chart {p q : TangentBundle I M} (h : q.1 \u2208 (chartAt H p.1).source) :\n    tangentMap I I (chartAt H p.1) q =\n      (TotalSpace.toProd _ _).symm\n        ((chartAt (ModelProd H E) p : TangentBundle I M \u2192 ModelProd H E) q)", "start": [1850, 1], "end": [1859, 60], "kind": "commanddeclaration"}, {"full_name": "tangentMap_chart_symm", "code": "theorem tangentMap_chart_symm {p : TangentBundle I M} {q : TangentBundle I H}\n    (h : q.1 \u2208 (chartAt H p.1).target) :\n    tangentMap I I (chartAt H p.1).symm q =\n      (chartAt (ModelProd H E) p).symm (TotalSpace.toProd H E q)", "start": [1862, 1], "end": [1875, 59], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.symm", "code": "nonrec theorem symm : e.symm.MDifferentiable I' I", "start": [1895, 1], "end": [1895, 61], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mdifferentiableAt", "code": "protected theorem mdifferentiableAt {x : M} (hx : x \u2208 e.source) : MDifferentiableAt I I' e x", "start": [1898, 1], "end": [1899, 67], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mdifferentiableAt_symm", "code": "theorem mdifferentiableAt_symm {x : M'} (hx : x \u2208 e.target) : MDifferentiableAt I' I e.symm x", "start": [1902, 1], "end": [1903, 67], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.symm_comp_deriv", "code": "theorem symm_comp_deriv {x : M} (hx : x \u2208 e.source) :\n    (mfderiv I' I e.symm (e x)).comp (mfderiv I I' e x) =\n      ContinuousLinearMap.id \ud835\udd5c (TangentSpace I x)", "start": [1909, 1], "end": [1919, 54], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.comp_symm_deriv", "code": "theorem comp_symm_deriv {x : M'} (hx : x \u2208 e.target) :\n    (mfderiv I I' e (e.symm x)).comp (mfderiv I' I e.symm x) =\n      ContinuousLinearMap.id \ud835\udd5c (TangentSpace I' x)", "start": [1922, 1], "end": [1925, 29], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mfderiv", "code": "protected def mfderiv {x : M} (hx : x \u2208 e.source) : TangentSpace I x \u2243L[\ud835\udd5c] TangentSpace I' (e x) :=\n  { mfderiv I I' e x with\n    invFun := mfderiv I' I e.symm (e x)\n    continuous_toFun := (mfderiv I I' e x).cont\n    continuous_invFun := (mfderiv I' I e.symm (e x)).cont\n    left_inv := fun y => by\n      have : (ContinuousLinearMap.id _ _ : TangentSpace I x \u2192L[\ud835\udd5c] TangentSpace I x) y = y := rfl\n      conv_rhs => rw [\u2190 this, \u2190 he.symm_comp_deriv hx]\n    right_inv := fun y => by\n      have :\n        (ContinuousLinearMap.id \ud835\udd5c _ : TangentSpace I' (e x) \u2192L[\ud835\udd5c] TangentSpace I' (e x)) y = y :=\n        rfl\n      conv_rhs => rw [\u2190 this, \u2190 he.comp_symm_deriv (e.map_source hx)]\n      rw [e.left_inv hx]\n      rfl }", "start": [1928, 1], "end": [1944, 12], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mfderiv_bijective", "code": "theorem mfderiv_bijective {x : M} (hx : x \u2208 e.source) : Function.Bijective (mfderiv I I' e x)", "start": [1947, 1], "end": [1948, 28], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mfderiv_injective", "code": "theorem mfderiv_injective {x : M} (hx : x \u2208 e.source) : Function.Injective (mfderiv I I' e x)", "start": [1951, 1], "end": [1952, 28], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.mfderiv_surjective", "code": "theorem mfderiv_surjective {x : M} (hx : x \u2208 e.source) : Function.Surjective (mfderiv I I' e x)", "start": [1955, 1], "end": [1956, 29], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.ker_mfderiv_eq_bot", "code": "theorem ker_mfderiv_eq_bot {x : M} (hx : x \u2208 e.source) : LinearMap.ker (mfderiv I I' e x) = \u22a5", "start": [1959, 1], "end": [1960, 36], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.range_mfderiv_eq_top", "code": "theorem range_mfderiv_eq_top {x : M} (hx : x \u2208 e.source) : LinearMap.range (mfderiv I I' e x) = \u22a4", "start": [1963, 1], "end": [1964, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.range_mfderiv_eq_univ", "code": "theorem range_mfderiv_eq_univ {x : M} (hx : x \u2208 e.source) : range (mfderiv I I' e x) = univ", "start": [1967, 1], "end": [1968, 38], "kind": "commanddeclaration"}, {"full_name": "LocalHomeomorph.MDifferentiable.trans", "code": "theorem trans (he' : e'.MDifferentiable I' I'') : (e.trans e').MDifferentiable I I''", "start": [1971, 1], "end": [1981, 69], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivAt_extChartAt", "code": "theorem hasMFDerivAt_extChartAt (h : y \u2208 (chartAt H x).source) :\n    HasMFDerivAt I \ud835\udcd8(\ud835\udd5c, E) (extChartAt I x) y (mfderiv I I (chartAt H x) y : _)", "start": [1994, 1], "end": [1996, 87], "kind": "commanddeclaration"}, {"full_name": "hasMFDerivWithinAt_extChartAt", "code": "theorem hasMFDerivWithinAt_extChartAt (h : y \u2208 (chartAt H x).source) :\n    HasMFDerivWithinAt I \ud835\udcd8(\ud835\udd5c, E) (extChartAt I x) s y (mfderiv I I (chartAt H x) y : _)", "start": [1999, 1], "end": [2001, 51], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableAt_extChartAt", "code": "theorem mdifferentiableAt_extChartAt (h : y \u2208 (chartAt H x).source) :\n    MDifferentiableAt I \ud835\udcd8(\ud835\udd5c, E) (extChartAt I x) y", "start": [2004, 1], "end": [2006, 50], "kind": "commanddeclaration"}, {"full_name": "mdifferentiableOn_extChartAt", "code": "theorem mdifferentiableOn_extChartAt :\n    MDifferentiableOn I \ud835\udcd8(\ud835\udd5c, E) (extChartAt I x) (chartAt H x).source", "start": [2009, 1], "end": [2011, 63], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.image_denseRange", "code": "theorem UniqueMDiffWithinAt.image_denseRange (hs : UniqueMDiffWithinAt I s x)\n    {f : M \u2192 M'} {f' : E \u2192L[\ud835\udd5c] E'} (hf : HasMFDerivWithinAt I I' f s x f')\n    (hd : DenseRange f') : UniqueMDiffWithinAt I' (f '' s) (f x)", "start": [2027, 1], "end": [2039, 82], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.image_denseRange'", "code": "theorem UniqueMDiffOn.image_denseRange' (hs : UniqueMDiffOn I s) {f : M \u2192 M'}\n    {f' : M \u2192 E \u2192L[\ud835\udd5c] E'} (hf : \u2200 x \u2208 s, HasMFDerivWithinAt I I' f s x (f' x))\n    (hd : \u2200 x \u2208 s, DenseRange (f' x)) :\n    UniqueMDiffOn I' (f '' s)", "start": [2041, 1], "end": [2048, 77], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.image_denseRange", "code": "theorem UniqueMDiffOn.image_denseRange (hs : UniqueMDiffOn I s) {f : M \u2192 M'}\n    (hf : MDifferentiableOn I I' f s) (hd : \u2200 x \u2208 s, DenseRange (mfderivWithin I I' f s x)) :\n    UniqueMDiffOn I' (f '' s)", "start": [2050, 1], "end": [2055, 68], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.preimage_localHomeomorph", "code": "protected theorem UniqueMDiffWithinAt.preimage_localHomeomorph (hs : UniqueMDiffWithinAt I s x)\n    {e : LocalHomeomorph M M'} (he : e.MDifferentiable I I') (hx : x \u2208 e.source) :\n    UniqueMDiffWithinAt I' (e.target \u2229 e.symm \u207b\u00b9' s) (e x)", "start": [2057, 1], "end": [2063, 42], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.uniqueMDiffOn_preimage", "code": "theorem UniqueMDiffOn.uniqueMDiffOn_preimage (hs : UniqueMDiffOn I s) {e : LocalHomeomorph M M'}\n    (he : e.MDifferentiable I I') : UniqueMDiffOn I' (e.target \u2229 e.symm \u207b\u00b9' s)", "start": [2065, 1], "end": [2069, 81], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.uniqueDiffOn_target_inter", "code": "theorem UniqueMDiffOn.uniqueDiffOn_target_inter (hs : UniqueMDiffOn I s) (x : M) :\n    UniqueDiffOn \ud835\udd5c ((extChartAt I x).target \u2229 (extChartAt I x).symm \u207b\u00b9' s)", "start": [2072, 1], "end": [2082, 80], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.uniqueDiffOn_inter_preimage", "code": "theorem UniqueMDiffOn.uniqueDiffOn_inter_preimage (hs : UniqueMDiffOn I s) (x : M) (y : M')\n    {f : M \u2192 M'} (hf : ContinuousOn f s) :\n    UniqueDiffOn \ud835\udd5c\n      ((extChartAt I x).target \u2229 (extChartAt I x).symm \u207b\u00b9' (s \u2229 f \u207b\u00b9' (extChartAt I' y).source))", "start": [2085, 1], "end": [2097, 35], "kind": "commanddeclaration"}, {"full_name": "Trivialization.mdifferentiable", "code": "theorem Trivialization.mdifferentiable (e : Trivialization F (\u03c0 F Z)) [MemTrivializationAtlas e] :\n    e.toLocalHomeomorph.MDifferentiable (I.prod \ud835\udcd8(\ud835\udd5c, F)) (I.prod \ud835\udcd8(\ud835\udd5c, F))", "start": [2106, 1], "end": [2108, 76], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.smooth_bundle_preimage", "code": "theorem UniqueMDiffWithinAt.smooth_bundle_preimage {p : TotalSpace F Z}\n    (hs : UniqueMDiffWithinAt I s p.proj) :\n    UniqueMDiffWithinAt (I.prod \ud835\udcd8(\ud835\udd5c, F)) (\u03c0 F Z \u207b\u00b9' s) p", "start": [2110, 1], "end": [2121, 66], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffWithinAt.smooth_bundle_preimage'", "code": "theorem UniqueMDiffWithinAt.smooth_bundle_preimage' {b : M} (hs : UniqueMDiffWithinAt I s b)\n    (x : Z b) : UniqueMDiffWithinAt (I.prod \ud835\udcd8(\ud835\udd5c, F)) (\u03c0 F Z \u207b\u00b9' s) \u27e8b, x\u27e9", "start": [2125, 1], "end": [2127, 42], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.smooth_bundle_preimage", "code": "theorem UniqueMDiffOn.smooth_bundle_preimage (hs : UniqueMDiffOn I s) :\n    UniqueMDiffOn (I.prod \ud835\udcd8(\ud835\udd5c, F)) (\u03c0 F Z \u207b\u00b9' s)", "start": [2129, 1], "end": [2133, 35], "kind": "commanddeclaration"}, {"full_name": "UniqueMDiffOn.tangentBundle_proj_preimage", "code": "theorem UniqueMDiffOn.tangentBundle_proj_preimage (hs : UniqueMDiffOn I s) :\n    UniqueMDiffOn I.tangent (\u03c0 E (TangentSpace I) \u207b\u00b9' s)", "start": [2136, 1], "end": [2140, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ZMod/Parity.lean", "imports": ["Mathlib/Data/ZMod/Basic.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZMod.eq_zero_iff_even", "code": "theorem eq_zero_iff_even {n : \u2115} : (n : ZMod 2) = 0 \u2194 Even n", "start": [24, 1], "end": [25, 68], "kind": "commanddeclaration"}, {"full_name": "ZMod.eq_one_iff_odd", "code": "theorem eq_one_iff_odd {n : \u2115} : (n : ZMod 2) = 1 \u2194 Odd n", "start": [28, 1], "end": [30, 11], "kind": "commanddeclaration"}, {"full_name": "ZMod.ne_zero_iff_odd", "code": "theorem ne_zero_iff_odd {n : \u2115} : (n : ZMod 2) \u2260 0 \u2194 Odd n", "start": [33, 1], "end": [36, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/Spectrum.lean", "imports": ["Mathlib/Algebra/Star/StarAlgHom.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "Mathlib/Analysis/NormedSpace/Spectrum.lean", "Mathlib/Analysis/SpecialFunctions/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "unitary.spectrum_subset_circle", "code": "theorem unitary.spectrum_subset_circle (u : unitary E) :\n    spectrum \ud835\udd5c (u : E) \u2286 Metric.sphere 0 1", "start": [31, 1], "end": [41, 61], "kind": "commanddeclaration"}, {"full_name": "spectrum.subset_circle_of_unitary", "code": "theorem spectrum.subset_circle_of_unitary {u : E} (h : u \u2208 unitary E) :\n    spectrum \ud835\udd5c u \u2286 Metric.sphere 0 1", "start": [44, 1], "end": [46, 40], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.spectralRadius_eq_nnnorm", "code": "theorem IsSelfAdjoint.spectralRadius_eq_nnnorm {a : A} (ha : IsSelfAdjoint a) :\n    spectralRadius \u2102 a = \u2016a\u2016\u208a", "start": [60, 1], "end": [69, 7], "kind": "commanddeclaration"}, {"full_name": "IsStarNormal.spectralRadius_eq_nnnorm", "code": "theorem IsStarNormal.spectralRadius_eq_nnnorm (a : A) [IsStarNormal a] :\n    spectralRadius \u2102 a = \u2016a\u2016\u208a", "start": [72, 1], "end": [86, 99], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.mem_spectrum_eq_re", "code": "theorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule \u2102 A] {a : A} (ha : IsSelfAdjoint a) {z : \u2102}\n    (hz : z \u2208 spectrum \u2102 a) : z = z.re", "start": [89, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.mem_spectrum_eq_re", "code": "theorem selfAdjoint.mem_spectrum_eq_re [StarModule \u2102 A] (a : selfAdjoint A) {z : \u2102}\n    (hz : z \u2208 spectrum \u2102 (a : A)) : z = z.re", "start": [103, 1], "end": [106, 31], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.val_re_map_spectrum", "code": "theorem IsSelfAdjoint.val_re_map_spectrum [StarModule \u2102 A] {a : A} (ha : IsSelfAdjoint a) :\n    spectrum \u2102 a = ((\u2191) \u2218 re '' spectrum \u2102 a : Set \u2102)", "start": [109, 1], "end": [114, 79], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_re_map_spectrum", "code": "theorem selfAdjoint.val_re_map_spectrum [StarModule \u2102 A] (a : selfAdjoint A) :\n    spectrum \u2102 (a : A) = ((\u2191) \u2218 re '' spectrum \u2102 (a : A) : Set \u2102)", "start": [117, 1], "end": [120, 33], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.nnnorm_apply_le", "code": "theorem nnnorm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016\u208a \u2264 \u2016a\u2016\u208a", "start": [131, 1], "end": [141, 66], "kind": "commanddeclaration"}, {"full_name": "StarAlgHom.norm_apply_le", "code": "theorem norm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016 \u2264 \u2016a\u2016", "start": [144, 1], "end": [146, 22], "kind": "commanddeclaration"}, {"full_name": "WeakDual.Complex.instStarHomClass", "code": "noncomputable instance (priority := 100) Complex.instStarHomClass : StarHomClass F A \u2102 where\n  coe \u03c6 := \u03c6\n  coe_injective' := FunLike.coe_injective'\n  map_star \u03c6 a := by\n    suffices hsa : \u2200 s : selfAdjoint A, (\u03c6 s)\u22c6 = \u03c6 s\n    \u00b7 rw [\u2190 realPart_add_I_smul_imaginaryPart a]\n      simp only [map_add, map_smul, star_add, star_smul, hsa, selfAdjoint.star_val_eq]\n    \u00b7 intro s\n      have := AlgHom.apply_mem_spectrum \u03c6 (s : A)\n      rw [selfAdjoint.val_re_map_spectrum s] at this\n      rcases this with \u27e8\u27e8_, _\u27e9, _, heq\u27e9\n      simp only [Function.comp_apply] at heq\n      rw [\u2190 heq, IsROrC.star_def]\n      exact IsROrC.conj_ofReal _", "start": [169, 1], "end": [184, 33], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.instStarAlgHomClass", "code": "noncomputable def _root_.AlgHomClass.instStarAlgHomClass : StarAlgHomClass F \u2102 A \u2102 :=\n  { WeakDual.Complex.instStarHomClass, hF with coe := fun f => f }", "start": [186, 1], "end": [189, 67], "kind": "commanddeclaration"}, {"full_name": "WeakDual.CharacterSpace.instStarAlgHomClass", "code": "noncomputable instance instStarAlgHomClass : StarAlgHomClass (characterSpace \u2102 A) \u2102 A \u2102 :=\n  { AlgHomClass.instStarAlgHomClass with coe := fun f => f }", "start": [194, 1], "end": [195, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Algebra.lean", "imports": ["Mathlib/Analysis/NormedSpace/Spectrum.lean", "Mathlib/Topology/Algebra/Module/CharacterSpace.lean", "Mathlib/Analysis/NormedSpace/WeakDual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WeakDual.CharacterSpace.norm_le_norm_one", "code": "theorem norm_le_norm_one (\u03c6 : characterSpace \ud835\udd5c A) : \u2016toNormedDual (\u03c6 : WeakDual \ud835\udd5c A)\u2016 \u2264 \u2016(1 : A)\u2016", "start": [40, 1], "end": [42, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Units.lean", "imports": ["Mathlib/Analysis/NormedSpace/Units.lean", "Mathlib/Topology/ContinuousFunction/Algebra.lean", "Mathlib/Algebra/Algebra/Spectrum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap.unitsLift", "code": "@[to_additive (attr := simps apply_val_apply symm_apply_apply_val)\n\"Equivalence between continuous maps into the additive units of an additive monoid with continuous\naddition and the additive units of the additive monoid of continuous maps.\"]\ndef unitsLift : C(X, M\u02e3) \u2243 C(X, M)\u02e3 where\n  toFun f :=\n    { val := \u27e8fun x => f x, Units.continuous_val.comp f.continuous\u27e9\n      inv := \u27e8fun x => \u2191(f x)\u207b\u00b9, Units.continuous_val.comp (continuous_inv.comp f.continuous)\u27e9\n      val_inv := ext fun x => Units.mul_inv _\n      inv_val := ext fun x => Units.inv_mul _ }\n  invFun f :=\n    { toFun := fun x =>\n        \u27e8(f : C(X, M)) x, (\u2191f\u207b\u00b9 : C(X, M)) x,\n          ContinuousMap.congr_fun f.mul_inv x, ContinuousMap.congr_fun f.inv_mul x\u27e9\n      continuous_toFun := continuous_induced_rng.2 <|\n        (f : C(X, M)).continuous.prod_mk <|\n        MulOpposite.continuous_op.comp (\u2191f\u207b\u00b9 : C(X, M)).continuous }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl", "start": [28, 1], "end": [48, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.unitsLift_apply_inv_apply", "code": "@[to_additive (attr := simp)]\nlemma unitsLift_apply_inv_apply (f : C(X, M\u02e3)) (x : X) :\n    (\u2191(ContinuousMap.unitsLift f)\u207b\u00b9 : C(X, M)) x = (f x)\u207b\u00b9 :=\n  rfl", "start": [53, 1], "end": [56, 6], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousMap.unitsLift_symm_apply_apply_inv'", "code": "@[to_additive (attr := simp)]\nlemma unitsLift_symm_apply_apply_inv' (f : C(X, M)\u02e3) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)\u207b\u00b9 = (\u2191f\u207b\u00b9 : C(X, M)) x := by\n  rfl", "start": [59, 1], "end": [62, 6], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousMap.continuous_isUnit_unit", "code": "theorem continuous_isUnit_unit {f : C(X, R)} (h : \u2200 x, IsUnit (f x)) :\n    Continuous fun x => (h x).unit", "start": [70, 1], "end": [79, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.unitsOfForallIsUnit", "code": "@[simps]\nnoncomputable def unitsOfForallIsUnit {f : C(X, R)} (h : \u2200 x, IsUnit (f x)) : C(X, R\u02e3) where\n  toFun x := (h x).unit\n  continuous_toFun := continuous_isUnit_unit h", "start": [83, 1], "end": [88, 47], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.canLift", "code": "instance canLift :\n    CanLift C(X, R) C(X, R\u02e3) (fun f => \u27e8fun x => f x, Units.continuous_val.comp f.continuous\u27e9)\n      fun f => \u2200 x, IsUnit (f x) where\n  prf f h := \u27e8unitsOfForallIsUnit h, by ext; rfl\u27e9", "start": [91, 1], "end": [94, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.isUnit_iff_forall_isUnit", "code": "theorem isUnit_iff_forall_isUnit (f : C(X, R)) : IsUnit f \u2194 \u2200 x, IsUnit (f x)", "start": [97, 1], "end": [99, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.isUnit_iff_forall_ne_zero", "code": "theorem isUnit_iff_forall_ne_zero (f : C(X, \ud835\udd5c)) : IsUnit f \u2194 \u2200 x, f x \u2260 0", "start": [108, 1], "end": [109, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.spectrum_eq_range", "code": "theorem spectrum_eq_range (f : C(X, \ud835\udd5c)) : spectrum \ud835\udd5c f = Set.range f", "start": [112, 1], "end": [116, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Factorial/DoubleFactorial.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.doubleFactorial", "code": "@[simp]\ndef doubleFactorial : \u2115 \u2192 \u2115\n  | 0 => 1\n  | 1 => 1\n  | k + 2 => (k + 2) * doubleFactorial k", "start": [28, 1], "end": [33, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.doubleFactorial_add_two", "code": "theorem doubleFactorial_add_two (n : \u2115) : (n + 2)\u203c = (n + 2) * n\u203c", "start": [39, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.doubleFactorial_add_one", "code": "theorem doubleFactorial_add_one (n : \u2115) : (n + 1)\u203c = (n + 1) * (n - 1)\u203c", "start": [43, 1], "end": [43, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_eq_mul_doubleFactorial", "code": "theorem factorial_eq_mul_doubleFactorial : \u2200 n : \u2115, (n + 1)! = (n + 1)\u203c * n\u203c", "start": [46, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.doubleFactorial_two_mul", "code": "theorem doubleFactorial_two_mul : \u2200 n : \u2115, (2 * n)\u203c = 2 ^ n * n !", "start": [53, 1], "end": [58, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.doubleFactorial_eq_prod_even", "code": "theorem doubleFactorial_eq_prod_even : \u2200 n : \u2115, (2 * n)\u203c = \u220f i in Finset.range n, 2 * (i + 1)", "start": [63, 1], "end": [68, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.doubleFactorial_eq_prod_odd", "code": "theorem doubleFactorial_eq_prod_odd :\n    \u2200 n : \u2115, (2 * n + 1)\u203c = \u220f i in Finset.range n, (2 * (i + 1) + 1)", "start": [71, 1], "end": [77, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Shift/Induced.lean", "imports": ["Mathlib/CategoryTheory/Shift/CommShift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.HasShift.Induced.zero", "code": "noncomputable def zero : s 0 \u2245 \ud835\udfed D :=\n  letI := hF.1.some\n  have := hF.2\n  ((whiskeringLeft C D D).obj F).preimageIso ((i 0) \u226a\u226b\n    isoWhiskerRight (shiftFunctorZero C A) F \u226a\u226b F.leftUnitor \u226a\u226b F.rightUnitor.symm)", "start": [37, 1], "end": [42, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasShift.Induced.add", "code": "noncomputable def add (a b : A) : s (a + b) \u2245 s a \u22d9 s b :=\n  letI := hF.1.some\n  have := hF.2\n  ((whiskeringLeft C D D).obj F).preimageIso\n    (i (a + b) \u226a\u226b isoWhiskerRight (shiftFunctorAdd C a b) F \u226a\u226b\n      Functor.associator _ _ _ \u226a\u226b\n        isoWhiskerLeft _ (i b).symm \u226a\u226b (Functor.associator _ _ _).symm \u226a\u226b\n        isoWhiskerRight (i a).symm _ \u226a\u226b Functor.associator _ _ _)", "start": [44, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasShift.Induced.zero_hom_app_obj", "code": "@[simp]\nlemma zero_hom_app_obj (X : C) :\n    (zero F s i hF).hom.app (F.obj X) =\n      (i 0).hom.app X \u226b F.map ((shiftFunctorZero C A).hom.app X) := by\n  letI := hF.1.some\n  have h : whiskerLeft F (zero F s i hF).hom = _ :=\n    ((whiskeringLeft C D D).obj F).image_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)", "start": [54, 1], "end": [61, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.HasShift.Induced.zero_inv_app_obj", "code": "@[simp]\nlemma zero_inv_app_obj (X : C) :\n    (zero F s i hF).inv.app (F.obj X) =\n      F.map ((shiftFunctorZero C A).inv.app X) \u226b (i 0).inv.app X := by\n  letI := hF.1.some\n  have h : whiskerLeft F (zero F s i hF).inv = _ :=\n    ((whiskeringLeft C D D).obj F).image_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)", "start": [63, 1], "end": [70, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.HasShift.Induced.add_hom_app_obj", "code": "@[simp]\nlemma add_hom_app_obj (a b : A) (X : C) :\n    (add F s i hF a b).hom.app (F.obj X) =\n      (i (a + b)).hom.app X \u226b F.map ((shiftFunctorAdd C a b).hom.app X) \u226b\n        (i b).inv.app ((shiftFunctor C a).obj X) \u226b (s b).map ((i a).inv.app X) := by\n  letI := hF.1.some\n  have h : whiskerLeft F (add F s i hF a b).hom = _ :=\n    ((whiskeringLeft C D D).obj F).image_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)", "start": [72, 1], "end": [80, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.HasShift.Induced.add_inv_app_obj", "code": "@[simp]\nlemma add_inv_app_obj (a b : A) (X : C) :\n    (add F s i hF a b).inv.app (F.obj X) =\n      (s b).map ((i a).hom.app X) \u226b (i b).hom.app ((shiftFunctor C a).obj X) \u226b\n        F.map ((shiftFunctorAdd C a b).inv.app X) \u226b (i (a + b)).inv.app X := by\n  letI := hF.1.some\n  have h : whiskerLeft F (add F s i hF a b).inv = _ :=\n    ((whiskeringLeft C D D).obj F).image_preimage _\n  exact (NatTrans.congr_app h X).trans (by simp)", "start": [82, 1], "end": [90, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.HasShift.induced", "code": "noncomputable def induced : HasShift D A :=\n  hasShiftMk D A\n    { F := s\n      zero := Induced.zero F s i hF\n      add := Induced.add F s i hF\n      zero_add_hom_app := fun n => by\n        have := hF.2\n        suffices (Induced.add F s i hF 0 n).hom =\n          eqToHom (by rw [zero_add]; rfl) \u226b whiskerRight (Induced.zero F s i hF).inv (s n) by\n          intro X\n          simpa using NatTrans.congr_app this X\n        apply ((whiskeringLeft C D D).obj F).map_injective\n        ext X\n        have eq := dcongr_arg (fun a => (i a).hom.app X) (zero_add n)\n        dsimp\n        simp only [Induced.add_hom_app_obj, eq, shiftFunctorAdd_zero_add_hom_app,\n          Functor.map_comp, eqToHom_map, Category.assoc, eqToHom_trans_assoc,\n          eqToHom_refl, Category.id_comp, eqToHom_app, Induced.zero_inv_app_obj]\n        erw [\u2190 NatTrans.naturality_assoc, Iso.hom_inv_id_app_assoc]\n        rfl\n      add_zero_hom_app := fun n => by\n        have := hF.2\n        suffices (Induced.add F s i hF n 0).hom =\n            eqToHom (by rw [add_zero]; rfl) \u226b whiskerLeft (s n) (Induced.zero F s i hF).inv  by\n          intro X\n          simpa using NatTrans.congr_app this X\n        apply ((whiskeringLeft C D D).obj F).map_injective\n        ext X\n        dsimp\n        erw [Induced.add_hom_app_obj, dcongr_arg (fun a => (i a).hom.app X) (add_zero n),\n          \u2190 cancel_mono ((s 0).map ((i n).hom.app X)), Category.assoc,\n          Category.assoc, Category.assoc, Category.assoc, Category.assoc,\n          Category.assoc, \u2190 (s 0).map_comp, Iso.inv_hom_id_app, Functor.map_id, Category.comp_id,\n          \u2190 NatTrans.naturality, Induced.zero_inv_app_obj,\n          shiftFunctorAdd_add_zero_hom_app]\n        simp [eqToHom_map, eqToHom_app]\n      assoc_hom_app := fun m\u2081 m\u2082 m\u2083 => by\n        have := hF.2\n        suffices (Induced.add F s i hF (m\u2081 + m\u2082) m\u2083).hom \u226b\n            whiskerRight (Induced.add F s i hF m\u2081 m\u2082).hom (s m\u2083) =\n            eqToHom (by rw [add_assoc]) \u226b (Induced.add F s i hF m\u2081 (m\u2082 + m\u2083)).hom \u226b\n              whiskerLeft (s m\u2081) (Induced.add F s i hF m\u2082 m\u2083).hom by\n          intro X\n          simpa using NatTrans.congr_app this X\n        apply ((whiskeringLeft C D D).obj F).map_injective\n        ext X\n        dsimp\n        have eq := F.congr_map (shiftFunctorAdd'_assoc_hom_app\n          m\u2081 m\u2082 m\u2083 _ _ (m\u2081+m\u2082+m\u2083) rfl rfl rfl X)\n        simp only [shiftFunctorAdd'_eq_shiftFunctorAdd] at eq\n        simp only [Functor.comp_obj, Functor.map_comp, shiftFunctorAdd',\n          Iso.trans_hom, eqToIso.hom, NatTrans.comp_app, eqToHom_app,\n          Category.assoc] at eq\n        rw [\u2190 cancel_mono ((s m\u2083).map ((s m\u2082).map ((i m\u2081).hom.app X)))]\n        simp only [Induced.add_hom_app_obj, Category.assoc, Functor.map_comp]\n        slice_lhs 4 5 =>\n          erw [\u2190 Functor.map_comp, Iso.inv_hom_id_app, Functor.map_id]\n        erw [Category.id_comp]\n        slice_lhs 6 7 =>\n          erw [\u2190 Functor.map_comp, \u2190 Functor.map_comp, Iso.inv_hom_id_app,\n            (s m\u2082).map_id, (s m\u2083).map_id]\n        erw [Category.comp_id, \u2190NatTrans.naturality_assoc, reassoc_of% eq,\n          dcongr_arg (fun a => (i a).hom.app X) (add_assoc m\u2081 m\u2082 m\u2083).symm]\n        simp only [Functor.comp_obj, eqToHom_map, eqToHom_app, NatTrans.naturality_assoc,\n          Induced.add_hom_app_obj, Functor.comp_map, Category.assoc, Iso.inv_hom_id_app_assoc,\n          eqToHom_trans_assoc, eqToHom_refl, Category.id_comp, Category.comp_id,\n          \u2190 Functor.map_comp, Iso.inv_hom_id_app, Functor.map_id] }", "start": [96, 1], "end": [164, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.shiftFunctor_of_induced", "code": "@[simp]\nlemma shiftFunctor_of_induced (a : A) :\n    letI := HasShift.induced F A s i hF\n    shiftFunctor D a = s a := by\n  rfl", "start": [168, 1], "end": [172, 6], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.shiftFunctorZero_hom_app_obj_of_induced", "code": "@[simp]\nlemma shiftFunctorZero_hom_app_obj_of_induced (X : C) :\n    letI := HasShift.induced F A s i hF\n    (shiftFunctorZero D A).hom.app (F.obj X) =\n      (i 0).hom.app X \u226b F.map ((shiftFunctorZero C A).hom.app X) := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorZero_eq, HasShift.Induced.zero_hom_app_obj]", "start": [176, 1], "end": [182, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.shiftFunctorZero_inv_app_obj_of_induced", "code": "@[simp]\nlemma shiftFunctorZero_inv_app_obj_of_induced (X : C) :\n    letI := HasShift.induced F A s i hF\n    (shiftFunctorZero D A).inv.app (F.obj X) =\n      F.map ((shiftFunctorZero C A).inv.app X) \u226b (i 0).inv.app X := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorZero_eq, HasShift.Induced.zero_inv_app_obj]", "start": [184, 1], "end": [190, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.shiftFunctorAdd_hom_app_obj_of_induced", "code": "@[simp]\nlemma shiftFunctorAdd_hom_app_obj_of_induced (a b : A) (X : C) :\n    letI := HasShift.induced F A s i hF\n    (shiftFunctorAdd D a b).hom.app (F.obj X) =\n      (i (a + b)).hom.app X \u226b\n        F.map ((shiftFunctorAdd C a b).hom.app X) \u226b\n        (i b).inv.app ((shiftFunctor C a).obj X) \u226b\n        (s b).map ((i a).inv.app X) := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorAdd_eq, HasShift.Induced.add_hom_app_obj]", "start": [194, 1], "end": [203, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.shiftFunctorAdd_inv_app_obj_of_induced", "code": "@[simp]\nlemma shiftFunctorAdd_inv_app_obj_of_induced (a b : A) (X : C) :\n    letI := HasShift.induced F A s i hF\n    (shiftFunctorAdd D a b).inv.app (F.obj X) =\n      (s b).map ((i a).hom.app X) \u226b\n      (i b).hom.app ((shiftFunctor C a).obj X) \u226b\n      F.map ((shiftFunctorAdd C a b).inv.app X) \u226b\n      (i (a + b)).inv.app X := by\n  letI := HasShift.induced F A s i\n  simp only [ShiftMkCore.shiftFunctorAdd_eq, HasShift.Induced.add_inv_app_obj]", "start": [205, 1], "end": [214, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.CommShift.ofInduced", "code": "def Functor.CommShift.ofInduced :\n    letI := HasShift.induced F A s i hF\n    F.CommShift A := by\n  letI := HasShift.induced F A s i hF\n  exact\n    { iso := fun a => (i a).symm\n      zero := by\n        ext X\n        dsimp\n        simp only [isoZero_hom_app, shiftFunctorZero_inv_app_obj_of_induced,\n          \u2190 F.map_comp_assoc, Iso.hom_inv_id_app, F.map_id, Category.id_comp]\n      add := fun a b => by\n        ext X\n        dsimp\n        simp only [isoAdd_hom_app, Iso.symm_hom, shiftFunctorAdd_inv_app_obj_of_induced,\n          shiftFunctor_of_induced]\n        erw [\u2190 Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.map_id,\n          Category.id_comp, Iso.inv_hom_id_app_assoc, \u2190F.map_comp_assoc, Iso.hom_inv_id_app,\n          F.map_id, Category.id_comp] }", "start": [218, 1], "end": [239, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.commShiftIso_eq_ofInduced", "code": "lemma Functor.commShiftIso_eq_ofInduced (a : A) :\n    letI := HasShift.induced F A s i hF\n    letI := Functor.CommShift.ofInduced F A s i hF\n    F.commShiftIso a = (i a).symm := rfl", "start": [241, 1], "end": [244, 41], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2080", "code": "@[simps! functor inverse unitIso_hom_app]\ndef equivalence\u2080 : A \u224c B' :=\n  eA.trans e'", "start": [56, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081", "code": "@[simps! functor]\ndef equivalence\u2081 : A \u224c B' :=\n  letI : IsEquivalence F :=\n    IsEquivalence.ofIso hF (IsEquivalence.ofEquivalence (equivalence\u2080 eA e'))\n  F.asEquivalence", "start": [64, 1], "end": [70, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081_inverse", "code": "theorem equivalence\u2081_inverse : (equivalence\u2081 hF).inverse = e'.inverse \u22d9 eA.inverse", "start": [73, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081CounitIso", "code": "@[simps!]\ndef equivalence\u2081CounitIso : (e'.inverse \u22d9 eA.inverse) \u22d9 F \u2245 \ud835\udfed B' :=\n  calc\n    (e'.inverse \u22d9 eA.inverse) \u22d9 F \u2245 (e'.inverse \u22d9 eA.inverse) \u22d9 eA.functor \u22d9 e'.functor :=\n      isoWhiskerLeft _ hF.symm\n    _ \u2245 e'.inverse \u22d9 (eA.inverse \u22d9 eA.functor) \u22d9 e'.functor := Iso.refl _\n    _ \u2245 e'.inverse \u22d9 \ud835\udfed _ \u22d9 e'.functor := isoWhiskerLeft _ (isoWhiskerRight eA.counitIso _)\n    _ \u2245 e'.inverse \u22d9 e'.functor := Iso.refl _\n    _ \u2245 \ud835\udfed B' := e'.counitIso", "start": [77, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081CounitIso_eq", "code": "theorem equivalence\u2081CounitIso_eq : (equivalence\u2081 hF).counitIso = equivalence\u2081CounitIso hF", "start": [89, 1], "end": [94, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081UnitIso", "code": "@[simps!]\ndef equivalence\u2081UnitIso : \ud835\udfed A \u2245 F \u22d9 e'.inverse \u22d9 eA.inverse :=\n  calc\n    \ud835\udfed A \u2245 eA.functor \u22d9 eA.inverse := eA.unitIso\n    _ \u2245 eA.functor \u22d9 \ud835\udfed A' \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 eA.functor \u22d9 (e'.functor \u22d9 e'.inverse) \u22d9 eA.inverse :=\n      isoWhiskerLeft _ (isoWhiskerRight e'.unitIso _)\n    _ \u2245 (eA.functor \u22d9 e'.functor) \u22d9 e'.inverse \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 F \u22d9 e'.inverse \u22d9 eA.inverse := isoWhiskerRight hF _", "start": [97, 1], "end": [106, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2081UnitIso_eq", "code": "theorem equivalence\u2081UnitIso_eq : (equivalence\u2081 hF).unitIso = equivalence\u2081UnitIso hF", "start": [109, 1], "end": [114, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082", "code": "@[simps! functor]\ndef equivalence\u2082 : A \u224c B :=\n  (equivalence\u2081 hF).trans eB.symm", "start": [117, 1], "end": [121, 34], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082_inverse", "code": "theorem equivalence\u2082_inverse :\n    (equivalence\u2082 eB hF).inverse = eB.functor \u22d9 e'.inverse \u22d9 eA.inverse", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082CounitIso", "code": "@[simps!]\ndef equivalence\u2082CounitIso : (eB.functor \u22d9 e'.inverse \u22d9 eA.inverse) \u22d9 F \u22d9 eB.inverse \u2245 \ud835\udfed B :=\n  calc\n    (eB.functor \u22d9 e'.inverse \u22d9 eA.inverse) \u22d9 F \u22d9 eB.inverse \u2245\n        eB.functor \u22d9 (e'.inverse \u22d9 eA.inverse \u22d9 F) \u22d9 eB.inverse :=\n      Iso.refl _\n    _ \u2245 eB.functor \u22d9 \ud835\udfed _ \u22d9 eB.inverse :=\n      isoWhiskerLeft _ (isoWhiskerRight (equivalence\u2081CounitIso hF) _)\n    _ \u2245 eB.functor \u22d9 eB.inverse := Iso.refl _\n    _ \u2245 \ud835\udfed B := eB.unitIso.symm", "start": [129, 1], "end": [139, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082CounitIso_eq", "code": "theorem equivalence\u2082CounitIso_eq :\n    (equivalence\u2082 eB hF).counitIso = equivalence\u2082CounitIso eB hF", "start": [142, 1], "end": [147, 60], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082UnitIso", "code": "@[simps!]\ndef equivalence\u2082UnitIso : \ud835\udfed A \u2245 (F \u22d9 eB.inverse) \u22d9 eB.functor \u22d9 e'.inverse \u22d9 eA.inverse :=\n  calc\n    \ud835\udfed A \u2245 F \u22d9 e'.inverse \u22d9 eA.inverse := equivalence\u2081UnitIso hF\n    _ \u2245 F \u22d9 \ud835\udfed B' \u22d9 e'.inverse \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 F \u22d9 (eB.inverse \u22d9 eB.functor) \u22d9 e'.inverse \u22d9 eA.inverse :=\n      isoWhiskerLeft _ (isoWhiskerRight eB.counitIso.symm _)\n    _ \u2245 (F \u22d9 eB.inverse) \u22d9 eB.functor \u22d9 e'.inverse \u22d9 eA.inverse := Iso.refl _", "start": [150, 1], "end": [158, 78], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence\u2082UnitIso_eq", "code": "theorem equivalence\u2082UnitIso_eq : (equivalence\u2082 eB hF).unitIso = equivalence\u2082UnitIso eB hF", "start": [161, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence", "code": "@[simps! inverse]\ndef equivalence : A \u224c B :=\n  letI : IsEquivalence G := by\n    refine' IsEquivalence.ofIso _ (IsEquivalence.ofEquivalence (equivalence\u2082 eB hF).symm)\n    calc\n      eB.functor \u22d9 e'.inverse \u22d9 eA.inverse \u2245 (eB.functor \u22d9 e'.inverse) \u22d9 eA.inverse := Iso.refl _\n      _ \u2245 (G \u22d9 eA.functor) \u22d9 eA.inverse := isoWhiskerRight hG _\n      _ \u2245 G \u22d9 \ud835\udfed A := isoWhiskerLeft _ eA.unitIso.symm\n      _ \u2245 G := Functor.rightUnitor G\n  G.asEquivalence.symm", "start": [171, 1], "end": [182, 23], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalence_functor", "code": "theorem equivalence_functor : (equivalence hF hG).functor = F \u22d9 eB.inverse", "start": [185, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.\u03c4\u2080", "code": "@[simps! hom_app]\ndef \u03c4\u2080 : eB.functor \u22d9 e'.inverse \u22d9 e'.functor \u2245 eB.functor :=\n  calc\n    eB.functor \u22d9 e'.inverse \u22d9 e'.functor \u2245 eB.functor \u22d9 \ud835\udfed _ := isoWhiskerLeft _ e'.counitIso\n    _ \u2245 eB.functor := Functor.rightUnitor _", "start": [189, 1], "end": [195, 44], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.\u03c4\u2081", "code": "@[simps! hom_app]\ndef \u03c4\u2081 (\u03b7 : G \u22d9 F \u2245 eB.functor) : eB.functor \u22d9 e'.inverse \u22d9 e'.functor \u2245 eB.functor :=\n  calc\n    eB.functor \u22d9 e'.inverse \u22d9 e'.functor \u2245 (eB.functor \u22d9 e'.inverse) \u22d9 e'.functor :=\n        Iso.refl _\n    _ \u2245 (G \u22d9 eA.functor) \u22d9 e'.functor := isoWhiskerRight hG _\n    _ \u2245 G \u22d9 eA.functor \u22d9 e'.functor := by rfl\n    _ \u2245 G \u22d9 F := isoWhiskerLeft _ hF\n    _ \u2245 eB.functor := \u03b7", "start": [198, 1], "end": [210, 24], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso", "code": "@[simps!]\ndef equivalenceCounitIso : G \u22d9 F \u22d9 eB.inverse \u2245 \ud835\udfed B :=\n  calc\n    G \u22d9 F \u22d9 eB.inverse \u2245 (G \u22d9 F) \u22d9 eB.inverse := Iso.refl _\n    _ \u2245 eB.functor \u22d9 eB.inverse := isoWhiskerRight \u03b7 _\n    _ \u2245 \ud835\udfed B := eB.unitIso.symm", "start": [215, 1], "end": [221, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalenceCounitIso_eq", "code": "theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso \u03b7", "start": [226, 1], "end": [240, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.\u03c5", "code": "@[simps!]\ndef \u03c5 : eA.functor \u2245 F \u22d9 e'.inverse :=\n  calc\n    eA.functor \u2245 eA.functor \u22d9 \ud835\udfed A' := (Functor.leftUnitor _).symm\n    _ \u2245 eA.functor \u22d9 e'.functor \u22d9 e'.inverse := (isoWhiskerLeft _ e'.unitIso)\n    _ \u2245 (eA.functor \u22d9 e'.functor) \u22d9 e'.inverse := Iso.refl _\n    _ \u2245 F \u22d9 e'.inverse := isoWhiskerRight hF _", "start": [245, 1], "end": [253, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso", "code": "@[simps!]\ndef equivalenceUnitIso : \ud835\udfed A \u2245 (F \u22d9 eB.inverse) \u22d9 G :=\n  calc\n    \ud835\udfed A \u2245 eA.functor \u22d9 eA.inverse := eA.unitIso\n    _ \u2245 (F \u22d9 e'.inverse) \u22d9 eA.inverse := isoWhiskerRight \u03b5 _\n    _ \u2245 F \u22d9 \ud835\udfed B' \u22d9 e'.inverse \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 F \u22d9 (eB.inverse \u22d9 eB.functor) \u22d9 e'.inverse \u22d9 eA.inverse :=\n      isoWhiskerLeft _ (isoWhiskerRight eB.counitIso.symm _)\n    _ \u2245 (F \u22d9 eB.inverse) \u22d9 (eB.functor \u22d9 e'.inverse) \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 (F \u22d9 eB.inverse) \u22d9 (G \u22d9 eA.functor) \u22d9 eA.inverse :=\n      isoWhiskerLeft _ (isoWhiskerRight hG _)\n    _ \u2245 (F \u22d9 eB.inverse \u22d9 G) \u22d9 eA.functor \u22d9 eA.inverse := Iso.refl _\n    _ \u2245 (F \u22d9 eB.inverse \u22d9 G) \u22d9 \ud835\udfed A := isoWhiskerLeft _ eA.unitIso.symm\n    _ \u2245 (F \u22d9 eB.inverse) \u22d9 G := Iso.refl _", "start": [258, 1], "end": [272, 43], "kind": "commanddeclaration"}, {"full_name": "AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq", "code": "theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG \u03b5", "start": [277, 1], "end": [284, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/DoldKan/EquivalenceAdditive.lean", "imports": ["Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Preadditive.DoldKan.N", "code": "@[simp]\ndef N : Karoubi (SimplicialObject C) \u2964 Karoubi (ChainComplex C \u2115) :=\n  N\u2082", "start": [33, 1], "end": [37, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.DoldKan.\u0393", "code": "@[simp]\ndef \u0393 : Karoubi (ChainComplex C \u2115) \u2964 Karoubi (SimplicialObject C) :=\n  \u0393\u2082", "start": [43, 1], "end": [47, 5], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Preadditive.DoldKan.equivalence", "code": "@[simps]\ndef equivalence : Karoubi (SimplicialObject C) \u224c Karoubi (ChainComplex C \u2115) where\n  functor := N\n  inverse := \u0393\n  unitIso := \u0393\u2082N\u2082\n  counitIso := N\u2082\u0393\u2082\n  functor_unitIso_comp P := by\n    let \u03b1 := N.mapIso (\u0393\u2082N\u2082.app P)\n    let \u03b2 := N\u2082\u0393\u2082.app (N.obj P)\n    symm\n    change \ud835\udfd9 _ = \u03b1.hom \u226b \u03b2.hom\n    rw [\u2190 Iso.inv_comp_eq, comp_id, \u2190 comp_id \u03b2.hom, \u2190 Iso.inv_comp_eq]\n    exact AlgebraicTopology.DoldKan.identity_N\u2082_objectwise P", "start": [50, 1], "end": [64, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Idempotents/SimplicialObject.lean", "imports": ["Mathlib/AlgebraicTopology/SimplicialObject.lean", "Mathlib/CategoryTheory/Idempotents/FunctorCategories.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Fold.lean", "imports": ["Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CliffordAlgebra.foldr", "code": "def foldr (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf : \u2200 m x, f m (f m x) = Q m \u2022 x) :\n    N \u2192\u2097[R] CliffordAlgebra Q \u2192\u2097[R] N :=\n  (CliffordAlgebra.lift Q \u27e8f, fun v => LinearMap.ext <| hf v\u27e9).toLinearMap.flip", "start": [48, 1], "end": [54, 80], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_\u03b9", "code": "@[simp]\ntheorem foldr_\u03b9 (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (m : M) : foldr Q f hf n (\u03b9 Q m) = f m n", "start": [57, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_algebraMap", "code": "@[simp]\ntheorem foldr_algebraMap (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (r : R) :\n    foldr Q f hf n (algebraMap R _ r) = r \u2022 n", "start": [62, 1], "end": [65, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_one", "code": "@[simp]\ntheorem foldr_one (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) : foldr Q f hf n 1 = n", "start": [68, 1], "end": [70, 43], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_mul", "code": "@[simp]\ntheorem foldr_mul (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (a b : CliffordAlgebra Q) :\n    foldr Q f hf n (a * b) = foldr Q f hf (foldr Q f hf n b) a", "start": [73, 1], "end": [76, 47], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_prod_map_\u03b9", "code": "theorem foldr_prod_map_\u03b9 (l : List M) (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) :\n    foldr Q f hf n (l.map <| \u03b9 Q).prod = List.foldr (fun m n => f m n) n l", "start": [79, 1], "end": [84, 80], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl", "code": "def foldl (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf : \u2200 m x, f m (f m x) = Q m \u2022 x) :\n    N \u2192\u2097[R] CliffordAlgebra Q \u2192\u2097[R] N :=\n  LinearMap.compl\u2082 (foldr Q f hf) reverse", "start": [91, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_reverse", "code": "@[simp]\ntheorem foldl_reverse (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (x : CliffordAlgebra Q) :\n    foldl Q f hf n (reverse x) = foldr Q f hf n x", "start": [100, 1], "end": [103, 58], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr_reverse", "code": "@[simp]\ntheorem foldr_reverse (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (x : CliffordAlgebra Q) :\n    foldr Q f hf n (reverse x) = foldl Q f hf n x", "start": [106, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_\u03b9", "code": "@[simp]\ntheorem foldl_\u03b9 (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (m : M) : foldl Q f hf n (\u03b9 Q m) = f m n", "start": [112, 1], "end": [114, 43], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_algebraMap", "code": "@[simp]\ntheorem foldl_algebraMap (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (r : R) :\n    foldl Q f hf n (algebraMap R _ r) = r \u2022 n", "start": [117, 1], "end": [120, 59], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_one", "code": "@[simp]\ntheorem foldl_one (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) : foldl Q f hf n 1 = n", "start": [123, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_mul", "code": "@[simp]\ntheorem foldl_mul (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) (a b : CliffordAlgebra Q) :\n    foldl Q f hf n (a * b) = foldl Q f hf (foldl Q f hf n a) b", "start": [128, 1], "end": [131, 85], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldl_prod_map_\u03b9", "code": "theorem foldl_prod_map_\u03b9 (l : List M) (f : M \u2192\u2097[R] N \u2192\u2097[R] N) (hf) (n : N) :\n    foldl Q f hf n (l.map <| \u03b9 Q).prod = List.foldl (fun m n => f n m) n l", "start": [134, 1], "end": [137, 101], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.right_induction", "code": "theorem right_induction {P : CliffordAlgebra Q \u2192 Prop} (hr : \u2200 r : R, P (algebraMap _ _ r))\n    (h_add : \u2200 x y, P x \u2192 P y \u2192 P (x + y)) (h_\u03b9_mul : \u2200 m x, P x \u2192 P (x * \u03b9 Q m)) : \u2200 x, P x", "start": [142, 1], "end": [159, 28], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.left_induction", "code": "theorem left_induction {P : CliffordAlgebra Q \u2192 Prop} (hr : \u2200 r : R, P (algebraMap _ _ r))\n    (h_add : \u2200 x y, P x \u2192 P y \u2192 P (x + y)) (h_mul_\u03b9 : \u2200 x m, P x \u2192 P (\u03b9 Q m * x)) : \u2200 x, P x", "start": [162, 1], "end": [169, 65], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'Aux", "code": "def foldr'Aux (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N) :\n    M \u2192\u2097[R] Module.End R (CliffordAlgebra Q \u00d7 N) := by\n  have v_mul := (Algebra.lmul R (CliffordAlgebra Q)).toLinearMap \u2218\u2097 \u03b9 Q\n  have l := v_mul.compl\u2082 (LinearMap.fst _ _ N)\n  exact\n    { toFun := fun m => (l m).prod (f m)\n      map_add' := fun v\u2082 v\u2082 =>\n        LinearMap.ext fun x =>\n          Prod.ext (LinearMap.congr_fun (l.map_add _ _) x) (LinearMap.congr_fun (f.map_add _ _) x)\n      map_smul' := fun c v =>\n        LinearMap.ext fun x =>\n          Prod.ext (LinearMap.congr_fun (l.map_smul _ _) x)\n            (LinearMap.congr_fun (f.map_smul _ _) x) }", "start": [175, 1], "end": [188, 55], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'Aux_apply_apply", "code": "theorem foldr'Aux_apply_apply (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N) (m : M) (x_fx) :\n    foldr'Aux Q f m x_fx = (\u03b9 Q m * x_fx.1, f m x_fx)", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'Aux_foldr'Aux", "code": "theorem foldr'Aux_foldr'Aux (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N)\n    (hf : \u2200 m x fx, f m (\u03b9 Q m * x, f m (x, fx)) = Q m \u2022 fx) (v : M) (x_fx) :\n    foldr'Aux Q f v (foldr'Aux Q f v x_fx) = Q v \u2022 x_fx", "start": [196, 1], "end": [201, 70], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'", "code": "def foldr' (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N)\n    (hf : \u2200 m x fx, f m (\u03b9 Q m * x, f m (x, fx)) = Q m \u2022 fx) (n : N) : CliffordAlgebra Q \u2192\u2097[R] N :=\n  LinearMap.snd _ _ _ \u2218\u2097 foldr Q (foldr'Aux Q f) (foldr'Aux_foldr'Aux Q _ hf) (1, n)", "start": [204, 1], "end": [210, 85], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'_algebraMap", "code": "theorem foldr'_algebraMap (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N)\n    (hf : \u2200 m x fx, f m (\u03b9 Q m * x, f m (x, fx)) = Q m \u2022 fx) (n r) :\n    foldr' Q f hf n (algebraMap R _ r) = r \u2022 n", "start": [213, 1], "end": [216, 50], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'_\u03b9", "code": "theorem foldr'_\u03b9 (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N)\n    (hf : \u2200 m x fx, f m (\u03b9 Q m * x, f m (x, fx)) = Q m \u2022 fx) (n m) :\n    foldr' Q f hf n (\u03b9 Q m) = f m (1, n)", "start": [219, 1], "end": [222, 41], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.foldr'_\u03b9_mul", "code": "theorem foldr'_\u03b9_mul (f : M \u2192\u2097[R] CliffordAlgebra Q \u00d7 N \u2192\u2097[R] N)\n    (hf : \u2200 m x fx, f m (\u03b9 Q m * x, f m (x, fx)) = Q m \u2022 fx) (n m) (x) :\n    foldr' Q f hf n (\u03b9 Q m * x) = f m (x, foldr' Q f hf n x)", "start": [225, 1], "end": [235, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/PEmptyInstances.lean", "imports": ["Mathlib/Tactic/ToAdditive.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemigroupPEmpty", "code": "@[to_additive]\ninstance SemigroupPEmpty : Semigroup PEmpty.{u + 1} where\n  mul x _ := by cases x\n  mul_assoc x y z := by cases x", "start": [21, 1], "end": [24, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "imports": ["Mathlib/Algebra/Hom/NonUnitalAlg.lean", "Mathlib/RingTheory/NonUnitalSubring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/UnionLift.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "NonUnitalSubalgebraClass.subtype", "code": "def subtype (s : S) : s \u2192\u2099\u2090[R] A :=\n  { NonUnitalSubsemiringClass.subtype s, SMulMemClass.subtype s with toFun := (\u2191) }", "start": [33, 1], "end": [35, 84], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebraClass.coeSubtype", "code": "@[simp]\ntheorem coeSubtype : (subtype s : s \u2192 A) = ((\u2191) : s \u2192 A)", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra", "code": "structure NonUnitalSubalgebra (R : Type u) (A : Type v) [CommSemiring R]\n    [NonUnitalNonAssocSemiring A] [Module R A]\n    extends NonUnitalSubsemiring A, Submodule R A : Type v", "start": [45, 1], "end": [48, 59], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instNonUnitalSubsemiringClass", "code": "instance instNonUnitalSubsemiringClass : NonUnitalSubsemiringClass (NonUnitalSubalgebra R A) A\n    where\n  add_mem {s} := s.add_mem'\n  mul_mem {s} := s.mul_mem'\n  zero_mem {s} := s.zero_mem'", "start": [68, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instSMulMemClass", "code": "instance instSMulMemClass : SMulMemClass (NonUnitalSubalgebra R A) R A where\n  smul_mem := @fun s => s.smul_mem'", "start": [74, 1], "end": [75, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instNonUnitalSubringClass", "code": "instance instNonUnitalSubringClass {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A]\n    [Module R A] : NonUnitalSubringClass (NonUnitalSubalgebra R A) A :=\n  { NonUnitalSubalgebra.instNonUnitalSubsemiringClass with\n    neg_mem := @fun _ x hx => neg_one_smul R x \u25b8 SMulMemClass.smul_mem _ hx }", "start": [77, 1], "end": [80, 78], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_carrier", "code": "theorem mem_carrier {s : NonUnitalSubalgebra R A} {x : A} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [82, 1], "end": [83, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.ext", "code": "@[ext]\ntheorem ext {S T : NonUnitalSubalgebra R A} (h : \u2200 x : A, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [85, 1], "end": [87, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem mem_toNonUnitalSubsemiring {S : NonUnitalSubalgebra R A} {x} :\n    x \u2208 S.toNonUnitalSubsemiring \u2194 x \u2208 S", "start": [89, 1], "end": [92, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem coe_toNonUnitalSubsemiring (S : NonUnitalSubalgebra R A) :\n    (\u2191S.toNonUnitalSubsemiring : Set A) = S", "start": [94, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubsemiring_injective", "code": "theorem toNonUnitalSubsemiring_injective :\n    Function.Injective\n      (toNonUnitalSubsemiring : NonUnitalSubalgebra R A \u2192 NonUnitalSubsemiring A)", "start": [99, 1], "end": [103, 85], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubsemiring_inj", "code": "theorem toNonUnitalSubsemiring_inj {S U : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = U.toNonUnitalSubsemiring \u2194 S = U", "start": [105, 1], "end": [107, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_toSubmodule", "code": "theorem mem_toSubmodule (S : NonUnitalSubalgebra R A) {x} : x \u2208 S.toSubmodule \u2194 x \u2208 S", "start": [109, 1], "end": [110, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_toSubmodule", "code": "@[simp]\ntheorem coe_toSubmodule (S : NonUnitalSubalgebra R A) : (\u2191S.toSubmodule : Set A) = S", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubmodule_injective", "code": "theorem toSubmodule_injective :\n    Function.Injective (toSubmodule : NonUnitalSubalgebra R A \u2192 Submodule R A)", "start": [116, 1], "end": [118, 63], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubmodule_inj", "code": "theorem toSubmodule_inj {S U : NonUnitalSubalgebra R A} : S.toSubmodule = U.toSubmodule \u2194 S = U", "start": [120, 1], "end": [121, 31], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.copy", "code": "protected def copy (S : NonUnitalSubalgebra R A) (s : Set A) (hs : s = \u2191S) :\n    NonUnitalSubalgebra R A :=\n  { S.toNonUnitalSubsemiring.copy s hs with\n    smul_mem' := fun r a (ha : a \u2208 s) => by\n      show r \u2022 a \u2208 s\n      rw [hs] at ha \u22a2\n      exact S.smul_mem' r ha }", "start": [123, 1], "end": [131, 31], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : NonUnitalSubalgebra R A) (s : Set A) (hs : s = \u2191S) :\n    (S.copy s hs : Set A) = s", "start": [133, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.copy_eq", "code": "theorem copy_eq (S : NonUnitalSubalgebra R A) (s : Set A) (hs : s = \u2191S) : S.copy s hs = S", "start": [138, 1], "end": [139, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubring", "code": "def toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : NonUnitalSubring A where\n  toNonUnitalSubsemiring := S.toNonUnitalSubsemiring\n  neg_mem' := neg_mem (s := S)", "start": [143, 1], "end": [147, 31], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_toNonUnitalSubring", "code": "@[simp]\ntheorem mem_toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    {S : NonUnitalSubalgebra R A} {x} : x \u2208 S.toNonUnitalSubring \u2194 x \u2208 S", "start": [149, 1], "end": [152, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_toNonUnitalSubring", "code": "@[simp]\ntheorem coe_toNonUnitalSubring {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : (\u2191S.toNonUnitalSubring : Set A) = S", "start": [154, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubring_injective", "code": "theorem toNonUnitalSubring_injective {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A]\n    [Module R A] :\n    Function.Injective (toNonUnitalSubring : NonUnitalSubalgebra R A \u2192 NonUnitalSubring A)", "start": [159, 1], "end": [162, 90], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubring_inj", "code": "theorem toNonUnitalSubring_inj {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A]\n    {S U : NonUnitalSubalgebra R A} : S.toNonUnitalSubring = U.toNonUnitalSubring \u2194 S = U", "start": [164, 1], "end": [166, 38], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSemiring", "code": "instance toNonUnitalSemiring {R A} [CommSemiring R] [NonUnitalSemiring A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : NonUnitalSemiring S :=\n  inferInstance", "start": [177, 1], "end": [179, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalCommSemiring", "code": "instance toNonUnitalCommSemiring {R A} [CommSemiring R] [NonUnitalCommSemiring A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : NonUnitalCommSemiring S :=\n  inferInstance", "start": [181, 1], "end": [183, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalRing", "code": "instance toNonUnitalRing {R A} [CommRing R] [NonUnitalRing A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : NonUnitalRing S :=\n  inferInstance", "start": [185, 1], "end": [187, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalCommRing", "code": "instance toNonUnitalCommRing {R A} [CommRing R] [NonUnitalCommRing A] [Module R A]\n    (S : NonUnitalSubalgebra R A) : NonUnitalCommRing S :=\n  inferInstance", "start": [189, 1], "end": [191, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubmodule'", "code": "def toSubmodule' : NonUnitalSubalgebra R A \u21aao Submodule R A\n    where\n  toEmbedding :=\n    { toFun := fun S => S.toSubmodule\n      inj' := fun S T h => ext <| by apply SetLike.ext_iff.1 h }\n  map_rel_iff' := SetLike.coe_subset_coe.symm.trans SetLike.coe_subset_coe", "start": [195, 1], "end": [201, 75], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubsemiring'", "code": "def toNonUnitalSubsemiring' : NonUnitalSubalgebra R A \u21aao NonUnitalSubsemiring A\n    where\n  toEmbedding :=\n    { toFun := fun S => S.toNonUnitalSubsemiring\n      inj' := fun S T h => ext <| by apply SetLike.ext_iff.1 h }\n  map_rel_iff' := SetLike.coe_subset_coe.symm.trans SetLike.coe_subset_coe", "start": [203, 1], "end": [210, 75], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubring'", "code": "def toNonUnitalSubring' {R : Type u} {A : Type v} [CommRing R] [NonUnitalRing A] [Module R A] :\n    NonUnitalSubalgebra R A \u21aao NonUnitalSubring A\n    where\n  toEmbedding :=\n    { toFun := fun S => S.toNonUnitalSubring\n      inj' := fun S T h => ext <| by apply SetLike.ext_iff.1 h }\n  map_rel_iff' := SetLike.coe_subset_coe.symm.trans SetLike.coe_subset_coe", "start": [212, 1], "end": [220, 75], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instModule'", "code": "instance instModule' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] : Module R' S :=\n  SMulMemClass.toModule' _ R' R A S", "start": [226, 1], "end": [227, 36], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instModule", "code": "instance instModule : Module R S :=\n  S.instModule'", "start": [229, 1], "end": [230, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instIsScalarTower'", "code": "instance instIsScalarTower' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] :\n    IsScalarTower R' R S :=\n  S.toSubmodule.isScalarTower", "start": [232, 1], "end": [234, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instSMulCommClass'", "code": "instance instSMulCommClass' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A]\n    [SMulCommClass R' R A] : SMulCommClass R' R S where\n  smul_comm r' r s := Subtype.ext <| smul_comm r' r (s : A)", "start": [239, 1], "end": [241, 60], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass R A A] : SMulCommClass R S S where\n  smul_comm r x y := Subtype.ext <| smul_comm r (x : A) (y : A)", "start": [243, 1], "end": [244, 64], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.noZeroSMulDivisors_bot", "code": "instance noZeroSMulDivisors_bot [NoZeroSMulDivisors R A] : NoZeroSMulDivisors R S :=\n  \u27e8fun {c x} h =>\n    have : c = 0 \u2228 (x : A) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg ((\u2191) : S \u2192 A) h)\n    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr\u27e9", "start": [248, 1], "end": [251, 51], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_add", "code": "protected theorem coe_add (x y : S) : (\u2191(x + y) : A) = \u2191x + \u2191y", "start": [253, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_mul", "code": "protected theorem coe_mul (x y : S) : (\u2191(x * y) : A) = \u2191x * \u2191y", "start": [256, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_zero", "code": "protected theorem coe_zero : ((0 : S) : A) = 0", "start": [259, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_neg", "code": "protected theorem coe_neg {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : NonUnitalSubalgebra R A} (x : S) : (\u2191(-x) : A) = -\u2191x", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_sub", "code": "protected theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : NonUnitalSubalgebra R A} (x y : S) : (\u2191(x - y) : A) = \u2191x - \u2191y", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] (r : R') (x : S) :\n    (r \u2022 x : A) = r \u2022 (x : A)", "start": [270, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_eq_zero", "code": "protected theorem coe_eq_zero {x : S} : (x : A) = 0 \u2194 x = 0", "start": [275, 1], "end": [276, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toNonUnitalSubsemiring_subtype", "code": "@[simp]\ntheorem toNonUnitalSubsemiring_subtype :\n    NonUnitalSubsemiringClass.subtype S = NonUnitalSubalgebraClass.subtype (R := R) S", "start": [278, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubring_subtype", "code": "@[simp]\ntheorem toSubring_subtype {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\n    (S : NonUnitalSubalgebra R A) :\n    NonUnitalSubringClass.subtype S = NonUnitalSubalgebraClass.subtype (R := R) S", "start": [283, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubmoduleEquiv", "code": "def toSubmoduleEquiv (S : NonUnitalSubalgebra R A) : S.toSubmodule \u2243\u2097[R] S :=\n  LinearEquiv.ofEq _ _ rfl", "start": [289, 1], "end": [292, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map", "code": "def map (f : F) (S : NonUnitalSubalgebra R A) : NonUnitalSubalgebra R B :=\n  { S.toNonUnitalSubsemiring.map (f : A \u2192\u2099+* B) with\n    smul_mem' := fun r b hb => by\n      rcases hb with \u27e8a, ha, rfl\u27e9\n      exact map_smul f r a \u25b8 Set.mem_image_of_mem f (S.smul_mem' r ha) }", "start": [294, 1], "end": [299, 73], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_mono", "code": "theorem map_mono {S\u2081 S\u2082 : NonUnitalSubalgebra R A} {f : F} :\n    S\u2081 \u2264 S\u2082 \u2192 (map f S\u2081 : NonUnitalSubalgebra R B) \u2264 map f S\u2082", "start": [301, 1], "end": [303, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_injective", "code": "theorem map_injective {f : F} (hf : Function.Injective f) :\n    Function.Injective (map f : NonUnitalSubalgebra R A \u2192 NonUnitalSubalgebra R B)", "start": [305, 1], "end": [308, 87], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_id", "code": "@[simp]\ntheorem map_id (S : NonUnitalSubalgebra R A) : map (NonUnitalAlgHom.id R A) S = S", "start": [310, 1], "end": [312, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_map", "code": "theorem map_map (S : NonUnitalSubalgebra R A) (g : B \u2192\u2099\u2090[R] C) (f : A \u2192\u2099\u2090[R] B) :\n    (S.map f).map g = S.map (g.comp f)", "start": [314, 1], "end": [316, 49], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_map", "code": "@[simp]\ntheorem mem_map {S : NonUnitalSubalgebra R A} {f : F} {y : B} : y \u2208 map f S \u2194 \u2203 x \u2208 S, f x = y", "start": [318, 1], "end": [320, 31], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_toSubmodule", "code": "theorem map_toSubmodule {S : NonUnitalSubalgebra R A} {f : F} :\n    (map f S).toSubmodule = Submodule.map ((\u2191f : A \u2192+[R] B) : A \u2192\u2097[R] B) S.toSubmodule", "start": [322, 1], "end": [325, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_toNonUnitalSubsemiring", "code": "theorem map_toNonUnitalSubsemiring {S : NonUnitalSubalgebra R A} {f : F} :\n    (map f S).toNonUnitalSubsemiring = S.toNonUnitalSubsemiring.map (f : A \u2192\u2099+* B)", "start": [327, 1], "end": [329, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_map", "code": "@[simp]\ntheorem coe_map (S : NonUnitalSubalgebra R A) (f : F) : (map f S : Set B) = f '' S", "start": [331, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.comap", "code": "def comap (f : F) (S : NonUnitalSubalgebra R B) : NonUnitalSubalgebra R A :=\n  { S.toNonUnitalSubsemiring.comap (f : A \u2192\u2099+* B) with\n    smul_mem' := fun r a (ha : f a \u2208 S) =>\n      show f (r \u2022 a) \u2208 S from (map_smul f r a).symm \u25b8 SMulMemClass.smul_mem r ha }", "start": [335, 1], "end": [339, 83], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.map_le", "code": "theorem map_le {S : NonUnitalSubalgebra R A} {f : F} {U : NonUnitalSubalgebra R B} :\n    map f S \u2264 U \u2194 S \u2264 comap f U", "start": [341, 1], "end": [343, 23], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.gc_map_comap", "code": "theorem gc_map_comap (f : F) :\n    GaloisConnection (map f : NonUnitalSubalgebra R A \u2192 NonUnitalSubalgebra R B) (comap f)", "start": [345, 1], "end": [347, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_comap", "code": "@[simp]\ntheorem mem_comap (S : NonUnitalSubalgebra R B) (f : F) (x : A) : x \u2208 comap f S \u2194 f x \u2208 S", "start": [349, 1], "end": [351, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap (S : NonUnitalSubalgebra R B) (f : F) : (comap f S : Set A) = f \u207b\u00b9' (S : Set B)", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.noZeroDivisors", "code": "instance noZeroDivisors {R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [NoZeroDivisors A]\n    [Module R A] (S : NonUnitalSubalgebra R A) : NoZeroDivisors S :=\n  NonUnitalSubsemiringClass.noZeroDivisors S", "start": [357, 1], "end": [359, 45], "kind": "commanddeclaration"}, {"full_name": "Submodule.toNonUnitalSubalgebra", "code": "def toNonUnitalSubalgebra (p : Submodule R A) (h_mul : \u2200 x y, x \u2208 p \u2192 y \u2208 p \u2192 x * y \u2208 p) :\n    NonUnitalSubalgebra R A :=\n  { p with\n    mul_mem' := h_mul _ _ }", "start": [367, 1], "end": [371, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem mem_toNonUnitalSubalgebra {p : Submodule R A} {h_mul} {x} :\n    x \u2208 p.toNonUnitalSubalgebra h_mul \u2194 x \u2208 p", "start": [373, 1], "end": [376, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem coe_toNonUnitalSubalgebra (p : Submodule R A) (h_mul) :\n    (p.toNonUnitalSubalgebra h_mul : Set A) = p", "start": [378, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.toNonUnitalSubalgebra_mk", "code": "theorem toNonUnitalSubalgebra_mk (p : Submodule R A) hmul :\n    p.toNonUnitalSubalgebra hmul =\n      NonUnitalSubalgebra.mk \u27e8\u27e8\u27e8p, p.add_mem\u27e9, p.zero_mem\u27e9, hmul _ _\u27e9 p.smul_mem'", "start": [383, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.toNonUnitalSubalgebra_toSubmodule", "code": "@[simp]\ntheorem toNonUnitalSubalgebra_toSubmodule (p : Submodule R A) (h_mul) :\n    (p.toNonUnitalSubalgebra h_mul).toSubmodule = p", "start": [388, 1], "end": [391, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.toSubmodule_toNonUnitalSubalgebra", "code": "@[simp]\ntheorem _root_.NonUnitalSubalgebra.toSubmodule_toNonUnitalSubalgebra (S : NonUnitalSubalgebra R A) :\n    (S.toSubmodule.toNonUnitalSubalgebra fun _ _ => mul_mem (s := S)) = S", "start": [393, 1], "end": [396, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.range", "code": "protected def range (\u03c6 : F) : NonUnitalSubalgebra R B where\n  toNonUnitalSubsemiring := NonUnitalRingHom.srange (\u03c6 : A \u2192\u2099+* B)\n  smul_mem' := fun r a => by rintro \u27e8a, rfl\u27e9; exact \u27e8r \u2022 a, map_smul \u03c6 r a\u27e9", "start": [407, 1], "end": [410, 76], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.mem_range", "code": "@[simp]\ntheorem mem_range (\u03c6 : F) {y : B} :\n    y \u2208 (NonUnitalAlgHom.range \u03c6 : NonUnitalSubalgebra R B) \u2194 \u2203 x : A, \u03c6 x = y", "start": [412, 1], "end": [415, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.mem_range_self", "code": "theorem mem_range_self (\u03c6 : F) (x : A) :\n    \u03c6 x \u2208 (NonUnitalAlgHom.range \u03c6 : NonUnitalSubalgebra R B)", "start": [417, 1], "end": [419, 43], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_range", "code": "@[simp]\ntheorem coe_range (\u03c6 : F) :\n    ((NonUnitalAlgHom.range \u03c6 : NonUnitalSubalgebra R B) : Set B) = Set.range (\u03c6 : A \u2192 B)", "start": [421, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.range_comp", "code": "theorem range_comp (f : A \u2192\u2099\u2090[R] B) (g : B \u2192\u2099\u2090[R] C) :\n    NonUnitalAlgHom.range (g.comp f) = (NonUnitalAlgHom.range f).map g", "start": [428, 1], "end": [430, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.range_comp_le_range", "code": "theorem range_comp_le_range (f : A \u2192\u2099\u2090[R] B) (g : B \u2192\u2099\u2090[R] C) :\n    NonUnitalAlgHom.range (g.comp f) \u2264 NonUnitalAlgHom.range g", "start": [432, 1], "end": [434, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.codRestrict", "code": "def codRestrict (f : F) (S : NonUnitalSubalgebra R B) (hf : \u2200 x, f x \u2208 S) : A \u2192\u2099\u2090[R] S :=\n  { NonUnitalRingHom.codRestrict (f : A \u2192\u2099+* B) S.toNonUnitalSubsemiring hf with\n    map_smul' := fun r a => Subtype.ext <| map_smul f r a }", "start": [436, 1], "end": [439, 60], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.subtype_comp_codRestrict", "code": "@[simp]\ntheorem subtype_comp_codRestrict (f : F) (S : NonUnitalSubalgebra R B) (hf : \u2200 x : A, f x \u2208 S) :\n    (NonUnitalSubalgebraClass.subtype S).comp (NonUnitalAlgHom.codRestrict f S hf) = f", "start": [441, 1], "end": [444, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_codRestrict", "code": "@[simp]\ntheorem coe_codRestrict (f : F) (S : NonUnitalSubalgebra R B) (hf : \u2200 x, f x \u2208 S) (x : A) :\n    \u2191(NonUnitalAlgHom.codRestrict f S hf x) = f x", "start": [446, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.injective_codRestrict", "code": "theorem injective_codRestrict (f : F) (S : NonUnitalSubalgebra R B) (hf : \u2200 x : A, f x \u2208 S) :\n    Function.Injective (NonUnitalAlgHom.codRestrict f S hf) \u2194 Function.Injective f", "start": [451, 1], "end": [453, 97], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.rangeRestrict", "code": "@[reducible]\ndef rangeRestrict (f : F) : A \u2192\u2099\u2090[R] (NonUnitalAlgHom.range f : NonUnitalSubalgebra R B) :=\n  NonUnitalAlgHom.codRestrict f (NonUnitalAlgHom.range f) (NonUnitalAlgHom.mem_range_self f)", "start": [455, 1], "end": [460, 93], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.equalizer", "code": "def equalizer (\u03d5 \u03c8 : F) : NonUnitalSubalgebra R A\n    where\n  carrier := {a | (\u03d5 a : B) = \u03c8 a}\n  zero_mem' := by rw [Set.mem_setOf_eq, map_zero, map_zero]\n  add_mem' {x y} (hx : \u03d5 x = \u03c8 x) (hy : \u03d5 y = \u03c8 y) := by\n    rw [Set.mem_setOf_eq, map_add, map_add, hx, hy]\n  mul_mem' {x y} (hx : \u03d5 x = \u03c8 x) (hy : \u03d5 y = \u03c8 y) := by\n    rw [Set.mem_setOf_eq, map_mul, map_mul, hx, hy]\n  smul_mem' r x (hx : \u03d5 x = \u03c8 x) := by rw [Set.mem_setOf_eq, map_smul, map_smul, hx]", "start": [462, 1], "end": [471, 85], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.mem_equalizer", "code": "@[simp]\ntheorem mem_equalizer (\u03c6 \u03c8 : F) (x : A) :\n    x \u2208 @NonUnitalAlgHom.equalizer F R A B _ _ _ _ _ _ \u03c6 \u03c8 \u2194 \u03c6 x = \u03c8 x", "start": [473, 1], "end": [476, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.fintypeRange", "code": "instance fintypeRange [Fintype A] [DecidableEq B] (\u03c6 : F) :\n    Fintype (@NonUnitalAlgHom.range F R A B _ _ _ _ _ _ \u03c6) :=\n  Set.fintypeRange \u03c6", "start": [478, 1], "end": [483, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin", "code": "def adjoin (s : Set A) : NonUnitalSubalgebra R A :=\n  { Submodule.span R (NonUnitalSubsemiring.closure s : Set A) with\n    mul_mem' :=\n      @fun a b (ha : a \u2208 Submodule.span R (NonUnitalSubsemiring.closure s : Set A))\n        (hb : b \u2208 Submodule.span R (NonUnitalSubsemiring.closure s : Set A)) =>\n      show a * b \u2208 Submodule.span R (NonUnitalSubsemiring.closure s : Set A) by\n        refine' Submodule.span_induction ha _ _ _ _\n        \u00b7 refine' Submodule.span_induction hb _ _ _ _\n          \u00b7 exact fun x (hx : x \u2208 NonUnitalSubsemiring.closure s) y\n              (hy : y \u2208 NonUnitalSubsemiring.closure s) => Submodule.subset_span (mul_mem hy hx)\n          \u00b7 exact fun x _hx => (mul_zero x).symm \u25b8 Submodule.zero_mem _\n          \u00b7 exact fun x y hx hy z hz => (mul_add z x y).symm \u25b8 add_mem (hx z hz) (hy z hz)\n          \u00b7 exact fun r x hx y hy => (mul_smul_comm r y x).symm \u25b8 SMulMemClass.smul_mem r (hx y hy)\n        \u00b7 exact (zero_mul b).symm \u25b8 Submodule.zero_mem _\n        \u00b7 exact fun x y => (add_mul x y b).symm \u25b8 add_mem\n        \u00b7 exact fun r x hx => (smul_mul_assoc r x b).symm \u25b8 SMulMemClass.smul_mem r hx }", "start": [495, 1], "end": [511, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_toSubmodule", "code": "theorem adjoin_toSubmodule (s : Set A) :\n    (adjoin R s).toSubmodule = Submodule.span R (NonUnitalSubsemiring.closure s : Set A)", "start": [513, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.subset_adjoin", "code": "@[aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_adjoin {s : Set A} : s \u2286 adjoin R s", "start": [517, 1], "end": [519, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.self_mem_adjoin_singleton", "code": "theorem self_mem_adjoin_singleton (x : A) : x \u2208 adjoin R ({x} : Set A)", "start": [521, 1], "end": [522, 57], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_induction", "code": "theorem adjoin_induction {s : Set A} {p : A \u2192 Prop} {a : A} (h : a \u2208 adjoin R s)\n    (Hs : \u2200 x \u2208 s, p x) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (H0 : p 0)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (Hsmul : \u2200 (r : R) x, p x \u2192 p (r \u2022 x)) : p a", "start": [526, 1], "end": [532, 91], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_induction\u2082", "code": "theorem adjoin_induction\u2082 {s : Set A} {p : A \u2192 A \u2192 Prop} {a b : A} (ha : a \u2208 adjoin R s)\n    (hb : b \u2208 adjoin R s) (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (H0_left : \u2200 y, p 0 y)\n    (H0_right : \u2200 x, p x 0) (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082))\n    (Hsmul_left : \u2200 (r : R) x y, p x y \u2192 p (r \u2022 x) y)\n    (Hsmul_right : \u2200 (r : R) x y, p x y \u2192 p x (r \u2022 y)) : p a b", "start": [534, 1], "end": [546, 65], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_induction'", "code": "lemma adjoin_induction' {s : Set A} {p : adjoin R s \u2192 Prop} (a : adjoin R s)\n    (Hs : \u2200 x (h : x \u2208 s), p \u27e8x, subset_adjoin R h\u27e9)\n    (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (H0 : p 0)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (Hsmul : \u2200 (r : R) x, p x \u2192 p (r \u2022 x)) : p a :=\n  Subtype.recOn a <| fun b hb => by\n  refine Exists.elim ?_ (fun (hb : b \u2208 adjoin R s) (hc : p \u27e8b, hb\u27e9) => hc)\n  apply adjoin_induction hb\n  \u00b7 exact fun x hx => \u27e8subset_adjoin R hx, Hs x hx\u27e9\n  \u00b7 exact fun x y hx hy => Exists.elim hx <| fun hx' hx => Exists.elim hy <| fun hy' hy =>\n      \u27e8add_mem hx' hy', Hadd _ _ hx hy\u27e9\n  \u00b7 exact \u27e8_, H0\u27e9\n  \u00b7 exact fun x y hx hy => Exists.elim hx <| fun hx' hx => Exists.elim hy <| fun hy' hy =>\n      \u27e8mul_mem hx' hy', Hmul _ _ hx hy\u27e9\n  \u00b7 exact fun r x hx => Exists.elim hx <| fun hx' hx => \u27e8SMulMemClass.smul_mem r hx', Hsmul r _ hx\u27e9", "start": [548, 1], "end": [562, 100], "kind": "mathlibtacticlemma"}, {"full_name": "NonUnitalAlgebra.gc", "code": "protected theorem gc : GaloisConnection (adjoin R : Set A \u2192 NonUnitalSubalgebra R A) (\u2191)", "start": [564, 1], "end": [569, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.gi", "code": "protected def gi : GaloisInsertion (adjoin R : Set A \u2192 NonUnitalSubalgebra R A) (\u2191)\n    where\n  choice s hs := (adjoin R s).copy s <| le_antisymm (NonUnitalAlgebra.gc.le_u_l s) hs\n  gc := NonUnitalAlgebra.gc\n  le_l_u S := (NonUnitalAlgebra.gc (S : Set A) (adjoin R S)).1 <| le_rfl\n  choice_eq _ _ := NonUnitalSubalgebra.copy_eq _ _ _", "start": [571, 1], "end": [577, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_le", "code": "theorem adjoin_le {S : NonUnitalSubalgebra R A} {s : Set A} (hs : s \u2286 S) : adjoin R s \u2264 S", "start": [582, 1], "end": [583, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_le_iff", "code": "theorem adjoin_le_iff {S : NonUnitalSubalgebra R A} {s : Set A} : adjoin R s \u2264 S \u2194 s \u2286 S", "start": [585, 1], "end": [586, 26], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_union", "code": "theorem adjoin_union (s t : Set A) : adjoin R (s \u222a t) = adjoin R s \u2294 adjoin R t", "start": [588, 1], "end": [589, 91], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_empty", "code": "@[simp]\ntheorem adjoin_empty : adjoin R (\u2205 : Set A) = \u22a5", "start": [593, 1], "end": [595, 81], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.adjoin_univ", "code": "@[simp]\ntheorem adjoin_univ : adjoin R (Set.univ : Set A) = \u22a4", "start": [597, 1], "end": [599, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.coe_top", "code": "@[simp]\ntheorem coe_top : (\u2191(\u22a4 : NonUnitalSubalgebra R A) : Set A) = Set.univ", "start": [603, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_top", "code": "@[simp]\ntheorem mem_top {x : A} : x \u2208 (\u22a4 : NonUnitalSubalgebra R A)", "start": [607, 1], "end": [609, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.top_toSubmodule", "code": "@[simp]\ntheorem top_toSubmodule : (\u22a4 : NonUnitalSubalgebra R A).toSubmodule = \u22a4", "start": [611, 1], "end": [613, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.top_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem top_toNonUnitalSubsemiring : (\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubsemiring = \u22a4", "start": [615, 1], "end": [617, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.top_toSubring", "code": "@[simp]\ntheorem top_toSubring {R A : Type*} [CommRing R] [NonUnitalRing A] [Module R A]\n    [IsScalarTower R A A] [SMulCommClass R A A] :\n    (\u22a4 : NonUnitalSubalgebra R A).toNonUnitalSubring = \u22a4", "start": [619, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.toSubmodule_eq_top", "code": "@[simp]\ntheorem toSubmodule_eq_top {S : NonUnitalSubalgebra R A} : S.toSubmodule = \u22a4 \u2194 S = \u22a4", "start": [625, 1], "end": [627, 69], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.toNonUnitalSubsemiring_eq_top", "code": "@[simp]\ntheorem toNonUnitalSubsemiring_eq_top {S : NonUnitalSubalgebra R A} :\n    S.toNonUnitalSubsemiring = \u22a4 \u2194 S = \u22a4", "start": [629, 1], "end": [632, 90], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.to_subring_eq_top", "code": "@[simp]\ntheorem to_subring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A]\n    {S : NonUnitalSubalgebra R A} : S.toNonUnitalSubring = \u22a4 \u2194 S = \u22a4", "start": [634, 1], "end": [637, 73], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_sup_left", "code": "theorem mem_sup_left {S T : NonUnitalSubalgebra R A} : \u2200 {x : A}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [639, 1], "end": [641, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_sup_right", "code": "theorem mem_sup_right {S T : NonUnitalSubalgebra R A} : \u2200 {x : A}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [643, 1], "end": [645, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mul_mem_sup", "code": "theorem mul_mem_sup {S T : NonUnitalSubalgebra R A} {x y : A} (hx : x \u2208 S) (hy : y \u2208 T) :\n    x * y \u2208 S \u2294 T", "start": [647, 1], "end": [649, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.map_sup", "code": "theorem map_sup (f : F) (S T : NonUnitalSubalgebra R A) :\n    ((S \u2294 T).map f : NonUnitalSubalgebra R B) = S.map f \u2294 T.map f", "start": [651, 1], "end": [653, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (S T : NonUnitalSubalgebra R A) : (\u2191(S \u2293 T) : Set A) = (S : Set A) \u2229 T", "start": [655, 1], "end": [657, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_inf", "code": "@[simp]\ntheorem mem_inf {S T : NonUnitalSubalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T", "start": [659, 1], "end": [661, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.inf_toSubmodule", "code": "@[simp]\ntheorem inf_toSubmodule (S T : NonUnitalSubalgebra R A) :\n    (S \u2293 T).toSubmodule = S.toSubmodule \u2293 T.toSubmodule", "start": [663, 1], "end": [666, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.inf_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem inf_toNonUnitalSubsemiring (S T : NonUnitalSubalgebra R A) :\n    (S \u2293 T).toNonUnitalSubsemiring = S.toNonUnitalSubsemiring \u2293 T.toNonUnitalSubsemiring", "start": [668, 1], "end": [671, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (NonUnitalSubalgebra R A)) : (\u2191(sInf S) : Set A) = \u22c2 s \u2208 S, \u2191s", "start": [673, 1], "end": [675, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_sInf", "code": "theorem mem_sInf {S : Set (NonUnitalSubalgebra R A)} {x : A} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [677, 1], "end": [678, 59], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.sInf_toSubmodule", "code": "@[simp]\ntheorem sInf_toSubmodule (S : Set (NonUnitalSubalgebra R A)) :\n    (sInf S).toSubmodule = sInf (NonUnitalSubalgebra.toSubmodule '' S)", "start": [680, 1], "end": [683, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.sInf_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem sInf_toNonUnitalSubsemiring (S : Set (NonUnitalSubalgebra R A)) :\n    (sInf S).toNonUnitalSubsemiring = sInf (NonUnitalSubalgebra.toNonUnitalSubsemiring '' S)", "start": [685, 1], "end": [688, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubalgebra R A} :\n    (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i", "start": [690, 1], "end": [692, 55], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubalgebra R A} {x : A} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [694, 1], "end": [695, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.iInf_toSubmodule", "code": "@[simp]\ntheorem iInf_toSubmodule {\u03b9 : Sort*} (S : \u03b9 \u2192 NonUnitalSubalgebra R A) :\n    (\u2a05 i, S i).toSubmodule = \u2a05 i, (S i).toSubmodule", "start": [697, 1], "end": [700, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.mem_bot", "code": "theorem mem_bot {x : A} : x \u2208 (\u22a5 : NonUnitalSubalgebra R A) \u2194 x = 0", "start": [705, 1], "end": [708, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.toSubmodule_bot", "code": "theorem toSubmodule_bot : (\u22a5 : NonUnitalSubalgebra R A).toSubmodule = \u22a5", "start": [710, 1], "end": [712, 78], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.coe_bot", "code": "@[simp]\ntheorem coe_bot : ((\u22a5 : NonUnitalSubalgebra R A) : Set A) = {0}", "start": [714, 1], "end": [716, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.eq_top_iff", "code": "theorem eq_top_iff {S : NonUnitalSubalgebra R A} : S = \u22a4 \u2194 \u2200 x : A, x \u2208 S", "start": [718, 1], "end": [719, 99], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.range_top_iff_surjective", "code": "theorem range_top_iff_surjective (f : A \u2192\u2099\u2090[R] B) :\n    NonUnitalAlgHom.range f = (\u22a4 : NonUnitalSubalgebra R B) \u2194 Function.Surjective f", "start": [721, 1], "end": [723, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.range_id", "code": "@[simp]\ntheorem range_id : NonUnitalAlgHom.range (NonUnitalAlgHom.id R A) = \u22a4", "start": [725, 1], "end": [727, 37], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.map_top", "code": "@[simp]\ntheorem map_top (f : A \u2192\u2099\u2090[R] B) : (\u22a4 : NonUnitalSubalgebra R A).map f = NonUnitalAlgHom.range f", "start": [729, 1], "end": [731, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.map_bot", "code": "@[simp]\ntheorem map_bot (f : A \u2192\u2099\u2090[R] B) : (\u22a5 : NonUnitalSubalgebra R A).map f = \u22a5", "start": [733, 1], "end": [735, 91], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.comap_top", "code": "@[simp]\ntheorem comap_top (f : A \u2192\u2099\u2090[R] B) : (\u22a4 : NonUnitalSubalgebra R B).comap f = \u22a4", "start": [737, 1], "end": [739, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgebra.toTop", "code": "def toTop : A \u2192\u2099\u2090[R] (\u22a4 : NonUnitalSubalgebra R A) :=\n  NonUnitalAlgHom.codRestrict (NonUnitalAlgHom.id R A) \u22a4 fun _ => mem_top", "start": [741, 1], "end": [743, 74], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.subsingleton_of_subsingleton", "code": "instance subsingleton_of_subsingleton [Subsingleton A] : Subsingleton (NonUnitalSubalgebra R A) :=\n  \u27e8fun B C => ext fun x => by simp only [Subsingleton.elim x 0, zero_mem B, zero_mem C]\u27e9", "start": [759, 1], "end": [760, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.subsingleton", "code": "instance _root_.NonUnitalAlgHom.subsingleton [Subsingleton (NonUnitalSubalgebra R A)] :\n    Subsingleton (A \u2192\u2099\u2090[R] B) :=\n  \u27e8fun f g =>\n    NonUnitalAlgHom.ext fun a =>\n      have : a \u2208 (\u22a5 : NonUnitalSubalgebra R A) :=\n        Subsingleton.elim (\u22a4 : NonUnitalSubalgebra R A) \u22a5 \u25b8 mem_top\n      (mem_bot.mp this).symm \u25b8 (map_zero f).trans (map_zero g).symm\u27e9", "start": [762, 1], "end": [768, 69], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.range_val", "code": "theorem range_val : NonUnitalAlgHom.range (NonUnitalSubalgebraClass.subtype S) = S", "start": [770, 1], "end": [771, 97], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion", "code": "def inclusion {S T : NonUnitalSubalgebra R A} (h : S \u2264 T) : S \u2192\u2099\u2090[R] T\n    where\n  toFun := Set.inclusion h\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_smul' _ _ := rfl", "start": [773, 1], "end": [782, 23], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion_injective", "code": "theorem inclusion_injective {S T : NonUnitalSubalgebra R A} (h : S \u2264 T) :\n    Function.Injective (inclusion h)", "start": [784, 1], "end": [785, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion_self", "code": "@[simp]\ntheorem inclusion_self {S : NonUnitalSubalgebra R A} :\n    inclusion (le_refl S) = NonUnitalAlgHom.id R S", "start": [787, 1], "end": [790, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion_mk", "code": "@[simp]\ntheorem inclusion_mk {S T : NonUnitalSubalgebra R A} (h : S \u2264 T) (x : A) (hx : x \u2208 S) :\n    inclusion h \u27e8x, hx\u27e9 = \u27e8x, h hx\u27e9", "start": [792, 1], "end": [795, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion_right", "code": "theorem inclusion_right {S T : NonUnitalSubalgebra R A} (h : S \u2264 T) (x : T) (m : (x : A) \u2208 S) :\n    inclusion h \u27e8x, m\u27e9 = x", "start": [797, 1], "end": [799, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.inclusion_inclusion", "code": "@[simp]\ntheorem inclusion_inclusion {S T U : NonUnitalSubalgebra R A} (hst : S \u2264 T) (htu : T \u2264 U) (x : S) :\n    inclusion htu (inclusion hst x) = inclusion (le_trans hst htu) x", "start": [801, 1], "end": [804, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_inclusion", "code": "@[simp]\ntheorem coe_inclusion {S T : NonUnitalSubalgebra R A} (h : S \u2264 T) (s : S) :\n    (inclusion h s : A) = s", "start": [806, 1], "end": [809, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.prod", "code": "def prod : NonUnitalSubalgebra R (A \u00d7 B) :=\n  { S.toNonUnitalSubsemiring.prod S\u2081.toNonUnitalSubsemiring with\n    carrier := S \u00d7\u02e2 S\u2081\n    smul_mem' := fun r _x hx => \u27e8SMulMemClass.smul_mem r hx.1, SMulMemClass.smul_mem r hx.2\u27e9 }", "start": [815, 1], "end": [819, 95], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_prod", "code": "@[simp]\ntheorem coe_prod : (prod S S\u2081 : Set (A \u00d7 B)) = (S : Set A) \u00d7\u02e2 S\u2081", "start": [821, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.prod_toSubmodule", "code": "theorem prod_toSubmodule : (S.prod S\u2081).toSubmodule = S.toSubmodule.prod S\u2081.toSubmodule", "start": [825, 1], "end": [826, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_prod", "code": "@[simp]\ntheorem mem_prod {S : NonUnitalSubalgebra R A} {S\u2081 : NonUnitalSubalgebra R B} {x : A \u00d7 B} :\n    x \u2208 prod S S\u2081 \u2194 x.1 \u2208 S \u2227 x.2 \u2208 S\u2081", "start": [828, 1], "end": [831, 15], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.prod_top", "code": "@[simp]\ntheorem prod_top : (prod \u22a4 \u22a4 : NonUnitalSubalgebra R (A \u00d7 B)) = \u22a4", "start": [833, 1], "end": [834, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.prod_mono", "code": "theorem prod_mono {S T : NonUnitalSubalgebra R A} {S\u2081 T\u2081 : NonUnitalSubalgebra R B} :\n    S \u2264 T \u2192 S\u2081 \u2264 T\u2081 \u2192 prod S S\u2081 \u2264 prod T T\u2081", "start": [836, 1], "end": [838, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.prod_inf_prod", "code": "@[simp]\ntheorem prod_inf_prod {S T : NonUnitalSubalgebra R A} {S\u2081 T\u2081 : NonUnitalSubalgebra R B} :\n    S.prod S\u2081 \u2293 T.prod T\u2081 = (S \u2293 T).prod (S\u2081 \u2293 T\u2081)", "start": [840, 1], "end": [843, 44], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed [Nonempty \u03b9] {S : \u03b9 \u2192 NonUnitalSubalgebra R A}\n    (dir : Directed (\u00b7 \u2264 \u00b7) S) : \u2191(iSup S) = \u22c3 i, (S i : Set A)", "start": [851, 1], "end": [874, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.iSupLift", "code": "noncomputable def iSupLift [Nonempty \u03b9] (K : \u03b9 \u2192 NonUnitalSubalgebra R A) (dir : Directed (\u00b7 \u2264 \u00b7) K)\n    (f : \u2200 i, K i \u2192\u2099\u2090[R] B) (hf : \u2200 (i j : \u03b9) (h : K i \u2264 K j), f i = (f j).comp (inclusion h))\n    (T : NonUnitalSubalgebra R A) (hT : T = iSup K) : \u21a5T \u2192\u2099\u2090[R] B := by\n  subst hT\n  exact\n      { toFun :=\n          Set.iUnionLift (fun i => \u2191(K i)) (fun i x => f i x)\n            (fun i j x hxi hxj => by\n              let \u27e8k, hik, hjk\u27e9 := dir i j\n              simp only\n              rw [hf i k hik, hf j k hjk]\n              rfl)\n            (\u2191(iSup K)) (by rw [coe_iSup_of_directed dir])\n        map_zero' := by\n          dsimp\n          exact Set.iUnionLift_const _ (fun i : \u03b9 => (0 : K i)) (fun _ => rfl) _ (by simp)\n        map_mul' := by\n          dsimp\n          apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 * \u00b7))\n          on_goal 3 => rw [coe_iSup_of_directed dir]\n          all_goals simp\n        map_add' := by\n          dsimp\n          apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 + \u00b7))\n          on_goal 3 => rw [coe_iSup_of_directed dir]\n          all_goals simp\n        map_smul' := fun r => by\n          dsimp\n          apply Set.iUnionLift_unary (coe_iSup_of_directed dir) _ (fun _ x => r \u2022 x)\n            (fun _ _ => rfl)\n          on_goal 2 => rw [coe_iSup_of_directed dir]\n          all_goals simp }", "start": [876, 1], "end": [910, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.iSupLift_inclusion", "code": "@[simp]\ntheorem iSupLift_inclusion {i : \u03b9} (x : K i) (h : K i \u2264 T) :\n    iSupLift K dir f hf T hT (inclusion h x) = f i x", "start": [916, 1], "end": [922, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.iSupLift_comp_inclusion", "code": "@[simp]\ntheorem iSupLift_comp_inclusion {i : \u03b9} (h : K i \u2264 T) :\n    (iSupLift K dir f hf T hT).comp (inclusion h) = f i", "start": [924, 1], "end": [926, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.iSupLift_mk", "code": "@[simp]\ntheorem iSupLift_mk {i : \u03b9} (x : K i) (hx : (x : A) \u2208 T) :\n    iSupLift K dir f hf T hT \u27e8x, hx\u27e9 = f i x", "start": [928, 1], "end": [933, 26], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.iSupLift_of_mem", "code": "theorem iSupLift_of_mem {i : \u03b9} (x : T) (hx : (x : A) \u2208 K i) :\n    iSupLift K dir f hf T hT x = f i \u27e8x, hx\u27e9", "start": [935, 1], "end": [939, 30], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_center", "code": "theorem _root_.Set.smul_mem_center {R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A](r : R) {a : A}\n    (ha : a \u2208 Set.center A) :\n    r \u2022 a \u2208 Set.center A", "start": [947, 1], "end": [951, 89], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.center", "code": "def center : NonUnitalSubalgebra R A :=\n  { NonUnitalSubsemiring.center A with smul_mem' := Set.smul_mem_center }", "start": [956, 1], "end": [959, 74], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_center", "code": "theorem coe_center : (center R A : Set A) = Set.center A", "start": [961, 1], "end": [962, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.center_toNonUnitalSubsemiring", "code": "@[simp]\ntheorem center_toNonUnitalSubsemiring :\n    (center R A).toNonUnitalSubsemiring = NonUnitalSubsemiring.center A", "start": [964, 1], "end": [967, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.center_toNonUnitalSubring", "code": "@[simp] lemma center_toNonUnitalSubring (R A : Type*) [CommRing R] [NonUnitalRing A]\n    [Module R A] [IsScalarTower R A A] [SMulCommClass R A A] :\n    (center R A).toNonUnitalSubring = NonUnitalSubring.center A :=\n  rfl", "start": [969, 1], "end": [972, 6], "kind": "mathlibtacticlemma"}, {"full_name": "NonUnitalSubalgebra.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (A : Type*) [NonUnitalCommSemiring A] [Module R A] [IsScalarTower R A A]\n    [SMulCommClass R A A] : center R A = \u22a4", "start": [974, 1], "end": [977, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.center.instNonUnitalCommSemiring", "code": "instance center.instNonUnitalCommSemiring : NonUnitalCommSemiring (center R A) :=\n  NonUnitalSubsemiring.center.instNonUnitalCommSemiring", "start": [981, 1], "end": [982, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.center.instNonUnitalCommRing", "code": "instance center.instNonUnitalCommRing {A : Type*} [NonUnitalRing A] [Module R A]\n    [IsScalarTower R A A] [SMulCommClass R A A] : NonUnitalCommRing (center R A) :=\n  NonUnitalSubring.center.instNonUnitalCommRing", "start": [984, 1], "end": [986, 48], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_center_iff", "code": "theorem mem_center_iff {a : A} : a \u2208 center R A \u2194 \u2200 b : A, b * a = a * b", "start": [988, 1], "end": [989, 10], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_centralizer", "code": "@[simp]\ntheorem _root_.Set.smul_mem_centralizer {s : Set A} (r : R) {a : A} (ha : a \u2208 s.centralizer) :\n    r \u2022 a \u2208 s.centralizer", "start": [998, 1], "end": [1001, 61], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.centralizer", "code": "def centralizer (s : Set A) : NonUnitalSubalgebra R A where\n  toNonUnitalSubsemiring := NonUnitalSubsemiring.centralizer s\n  smul_mem' := Set.smul_mem_centralizer", "start": [1005, 1], "end": [1008, 40], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set A) : (centralizer R s : Set A) = s.centralizer", "start": [1010, 1], "end": [1012, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {s : Set A} {z : A} : z \u2208 centralizer R s \u2194 \u2200 g \u2208 s, g * z = z * g", "start": [1014, 1], "end": [1015, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.centralizer_le", "code": "theorem centralizer_le (s t : Set A) (h : s \u2286 t) : centralizer R t \u2264 centralizer R s", "start": [1017, 1], "end": [1018, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSubalgebra.centralizer_univ", "code": "@[simp]\ntheorem centralizer_univ : centralizer R Set.univ = center R A", "start": [1020, 1], "end": [1022, 40], "kind": "commanddeclaration"}, {"full_name": "nonUnitalSubalgebraOfNonUnitalSubsemiring", "code": "def nonUnitalSubalgebraOfNonUnitalSubsemiring (S : NonUnitalSubsemiring R) :\n    NonUnitalSubalgebra \u2115 R where\n  toNonUnitalSubsemiring := S\n  smul_mem' n _x hx := nsmul_mem (S := S) hx n", "start": [1032, 1], "end": [1036, 47], "kind": "commanddeclaration"}, {"full_name": "mem_nonUnitalSubalgebraOfNonUnitalSubsemiring", "code": "@[simp]\ntheorem mem_nonUnitalSubalgebraOfNonUnitalSubsemiring {x : R} {S : NonUnitalSubsemiring R} :\n    x \u2208 nonUnitalSubalgebraOfNonUnitalSubsemiring S \u2194 x \u2208 S", "start": [1038, 1], "end": [1041, 10], "kind": "commanddeclaration"}, {"full_name": "nonUnitalSubalgebraOfNonUnitalSubring", "code": "def nonUnitalSubalgebraOfNonUnitalSubring (S : NonUnitalSubring R) : NonUnitalSubalgebra \u2124 R where\n  toNonUnitalSubsemiring := S.toNonUnitalSubsemiring\n  smul_mem' n _x hx := zsmul_mem (K := S) hx n", "start": [1049, 1], "end": [1052, 47], "kind": "commanddeclaration"}, {"full_name": "mem_nonUnitalSubalgebraOfNonUnitalSubring", "code": "@[simp]\ntheorem mem_nonUnitalSubalgebraOfNonUnitalSubring {x : R} {S : NonUnitalSubring R} :\n    x \u2208 nonUnitalSubalgebraOfNonUnitalSubring S \u2194 x \u2208 S", "start": [1054, 1], "end": [1057, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/PartrecCode.lean", "imports": ["Mathlib/Computability/Partrec.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Partrec.rfind'", "code": "theorem rfind' {f} (hf : Nat.Partrec f) :\n    Nat.Partrec\n      (Nat.unpaired fun a m =>\n        (Nat.rfind fun n => (fun m => m = 0) <$> f (Nat.pair a (n + m))).map (\u00b7 + m))", "start": [50, 1], "end": [70, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code", "code": "inductive Code : Type\n  | zero : Code\n  | succ : Code\n  | left : Code\n  | right : Code\n  | pair : Code \u2192 Code \u2192 Code\n  | comp : Code \u2192 Code \u2192 Code\n  | prec : Code \u2192 Code \u2192 Code\n  | rfind' : Code \u2192 Code", "start": [73, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.instInhabited", "code": "instance instInhabited : Inhabited Code :=\n  \u27e8zero\u27e9", "start": [98, 1], "end": [99, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.const", "code": "protected def const : \u2115 \u2192 Code\n  | 0 => zero\n  | n + 1 => comp succ (Code.const n)", "start": [102, 1], "end": [105, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.const_inj", "code": "theorem const_inj : \u2200 {n\u2081 n\u2082}, Nat.Partrec.Code.const n\u2081 = Nat.Partrec.Code.const n\u2082 \u2192 n\u2081 = n\u2082", "start": [108, 1], "end": [113, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.id", "code": "protected def id : Code :=\n  pair left right", "start": [116, 1], "end": [118, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.curry", "code": "def curry (c : Code) (n : \u2115) : Code :=\n  comp c (pair (Code.const n) Code.id)", "start": [121, 1], "end": [124, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encodeCode", "code": "def encodeCode : Code \u2192 \u2115\n  | zero => 0\n  | succ => 1\n  | left => 2\n  | right => 3\n  | pair cf cg => 2 * (2 * Nat.pair (encodeCode cf) (encodeCode cg)) + 4\n  | comp cf cg => 2 * (2 * Nat.pair (encodeCode cf) (encodeCode cg) + 1) + 4\n  | prec cf cg => (2 * (2 * Nat.pair (encodeCode cf) (encodeCode cg)) + 1) + 4\n  | rfind' cf => (2 * (2 * encodeCode cf + 1) + 1) + 4", "start": [128, 1], "end": [137, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.ofNatCode", "code": "def ofNatCode : \u2115 \u2192 Code\n  | 0 => zero\n  | 1 => succ\n  | 2 => left\n  | 3 => right\n  | n + 4 =>\n    let m := n.div2.div2\n    have hm : m < n + 4 := by\n      simp only [div2_val]\n      exact\n        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))\n          (Nat.succ_le_succ (Nat.le_add_right _ _))\n    have _m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm\n    have _m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm\n    match n.bodd, n.div2.bodd with\n    | false, false => pair (ofNatCode m.unpair.1) (ofNatCode m.unpair.2)\n    | false, true  => comp (ofNatCode m.unpair.1) (ofNatCode m.unpair.2)\n    | true , false => prec (ofNatCode m.unpair.1) (ofNatCode m.unpair.2)\n    | true , true  => rfind' (ofNatCode m)", "start": [140, 1], "end": [161, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encode_ofNatCode", "code": "private theorem encode_ofNatCode : \u2200 n, encodeCode (ofNatCode n) = n", "start": [164, 1], "end": [185, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.instDenumerable", "code": "instance instDenumerable : Denumerable Code :=\n  mk'\n    \u27e8encodeCode, ofNatCode, fun c => by\n        induction c <;> try {rfl} <;> simp [encodeCode, ofNatCode, Nat.div2_val, *],\n      encode_ofNatCode\u27e9", "start": [187, 1], "end": [191, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encodeCode_eq", "code": "theorem encodeCode_eq : encode = encodeCode", "start": [194, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.ofNatCode_eq", "code": "theorem ofNatCode_eq : ofNat Code = ofNatCode", "start": [198, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encode_lt_pair", "code": "theorem encode_lt_pair (cf cg) :\n    encode cf < encode (pair cf cg) \u2227 encode cg < encode (pair cf cg)", "start": [202, 1], "end": [208, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encode_lt_comp", "code": "theorem encode_lt_comp (cf cg) :\n    encode cf < encode (comp cf cg) \u2227 encode cg < encode (comp cf cg)", "start": [211, 1], "end": [214, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encode_lt_prec", "code": "theorem encode_lt_prec (cf cg) :\n    encode cf < encode (prec cf cg) \u2227 encode cg < encode (prec cf cg)", "start": [217, 1], "end": [220, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.encode_lt_rfind'", "code": "theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf)", "start": [223, 1], "end": [229, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.pair_prim", "code": "theorem pair_prim : Primrec\u2082 pair", "start": [234, 1], "end": [242, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.comp_prim", "code": "theorem comp_prim : Primrec\u2082 comp", "start": [245, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.prec_prim", "code": "theorem prec_prim : Primrec\u2082 prec", "start": [256, 1], "end": [264, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.rfind_prim", "code": "theorem rfind_prim : Primrec rfind'", "start": [267, 1], "end": [273, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.rec_prim'", "code": "theorem rec_prim' {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {c : \u03b1 \u2192 Code} (hc : Primrec c) {z : \u03b1 \u2192 \u03c3}\n    (hz : Primrec z) {s : \u03b1 \u2192 \u03c3} (hs : Primrec s) {l : \u03b1 \u2192 \u03c3} (hl : Primrec l) {r : \u03b1 \u2192 \u03c3}\n    (hr : Primrec r) {pr : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3} (hpr : Primrec\u2082 pr)\n    {co : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3} (hco : Primrec\u2082 co) {pc : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3}\n    (hpc : Primrec\u2082 pc) {rf : \u03b1 \u2192 Code \u00d7 \u03c3 \u2192 \u03c3} (hrf : Primrec\u2082 rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : \u03b1) (c : Code) : \u03c3 :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Primrec (fun a => F a (c a) : \u03b1 \u2192 \u03c3)", "start": [276, 1], "end": [382, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.rec_prim", "code": "theorem rec_prim {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {c : \u03b1 \u2192 Code} (hc : Primrec c) {z : \u03b1 \u2192 \u03c3}\n    (hz : Primrec z) {s : \u03b1 \u2192 \u03c3} (hs : Primrec s) {l : \u03b1 \u2192 \u03c3} (hl : Primrec l) {r : \u03b1 \u2192 \u03c3}\n    (hr : Primrec r) {pr : \u03b1 \u2192 Code \u2192 Code \u2192 \u03c3 \u2192 \u03c3 \u2192 \u03c3}\n    (hpr : Primrec fun a : \u03b1 \u00d7 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 => pr a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {co : \u03b1 \u2192 Code \u2192 Code \u2192 \u03c3 \u2192 \u03c3 \u2192 \u03c3}\n    (hco : Primrec fun a : \u03b1 \u00d7 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 => co a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {pc : \u03b1 \u2192 Code \u2192 Code \u2192 \u03c3 \u2192 \u03c3 \u2192 \u03c3}\n    (hpc : Primrec fun a : \u03b1 \u00d7 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 => pc a.1 a.2.1 a.2.2.1 a.2.2.2.1 a.2.2.2.2)\n    {rf : \u03b1 \u2192 Code \u2192 \u03c3 \u2192 \u03c3} (hrf : Primrec fun a : \u03b1 \u00d7 Code \u00d7 \u03c3 => rf a.1 a.2.1 a.2.2) :\n    let F (a : \u03b1) (c : Code) : \u03c3 :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (pr a) (co a) (pc a) (rf a)\n    Primrec fun a => F a (c a)", "start": [385, 1], "end": [489, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.rec_computable", "code": "theorem rec_computable {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {c : \u03b1 \u2192 Code} (hc : Computable c)\n    {z : \u03b1 \u2192 \u03c3} (hz : Computable z) {s : \u03b1 \u2192 \u03c3} (hs : Computable s) {l : \u03b1 \u2192 \u03c3} (hl : Computable l)\n    {r : \u03b1 \u2192 \u03c3} (hr : Computable r) {pr : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3} (hpr : Computable\u2082 pr)\n    {co : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3} (hco : Computable\u2082 co) {pc : \u03b1 \u2192 Code \u00d7 Code \u00d7 \u03c3 \u00d7 \u03c3 \u2192 \u03c3}\n    (hpc : Computable\u2082 pc) {rf : \u03b1 \u2192 Code \u00d7 \u03c3 \u2192 \u03c3} (hrf : Computable\u2082 rf) :\n    let PR (a) cf cg hf hg := pr a (cf, cg, hf, hg)\n    let CO (a) cf cg hf hg := co a (cf, cg, hf, hg)\n    let PC (a) cf cg hf hg := pc a (cf, cg, hf, hg)\n    let RF (a) cf hf := rf a (cf, hf)\n    let F (a : \u03b1) (c : Code) : \u03c3 :=\n      Nat.Partrec.Code.recOn c (z a) (s a) (l a) (r a) (PR a) (CO a) (PC a) (RF a)\n    Computable fun a => F a (c a)", "start": [498, 1], "end": [601, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval", "code": "def eval : Code \u2192 \u2115 \u2192. \u2115\n  | zero => pure 0\n  | succ => Nat.succ\n  | left => \u2191fun n : \u2115 => n.unpair.1\n  | right => \u2191fun n : \u2115 => n.unpair.2\n  | pair cf cg => fun n => Nat.pair <$> eval cf n <*> eval cg n\n  | comp cf cg => fun n => eval cg n >>= eval cf\n  | prec cf cg =>\n    Nat.unpaired fun a n =>\n      n.rec (eval cf a) fun y IH => do\n        let i \u2190 IH\n        eval cg (Nat.pair a (Nat.pair y i))\n  | rfind' cf =>\n    Nat.unpaired fun a m =>\n      (Nat.rfind fun n => (fun m => m = 0) <$> eval cf (Nat.pair a (n + m))).map (\u00b7 + m)", "start": [606, 1], "end": [634, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_prec_zero", "code": "@[simp]\ntheorem eval_prec_zero (cf cg : Code) (a : \u2115) : eval (prec cf cg) (Nat.pair a 0) = eval cf a", "start": [637, 1], "end": [642, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_prec_succ", "code": "theorem eval_prec_succ (cf cg : Code) (a k : \u2115) :\n    eval (prec cf cg) (Nat.pair a (Nat.succ k)) =\n      do {let ih \u2190 eval (prec cf cg) (Nat.pair a k); eval cg (Nat.pair a (Nat.pair k ih))}", "start": [645, 1], "end": [650, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_const", "code": "@[simp]\ntheorem eval_const : \u2200 n m, eval (Code.const n) m = Part.some n", "start": [656, 1], "end": [659, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_id", "code": "@[simp]\ntheorem eval_id (n) : eval Code.id n = Part.some n", "start": [662, 1], "end": [663, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_curry", "code": "@[simp]\ntheorem eval_curry (c n x) : eval (curry c n) x = eval c (Nat.pair n x)", "start": [666, 1], "end": [667, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.const_prim", "code": "theorem const_prim : Primrec Code.const", "start": [670, 1], "end": [674, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.curry_prim", "code": "theorem curry_prim : Primrec\u2082 curry", "start": [677, 1], "end": [679, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.curry_inj", "code": "theorem curry_inj {c\u2081 c\u2082 n\u2081 n\u2082} (h : curry c\u2081 n\u2081 = curry c\u2082 n\u2082) : c\u2081 = c\u2082 \u2227 n\u2081 = n\u2082", "start": [682, 1], "end": [686, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.smn", "code": "theorem smn :\n    \u2203 f : Code \u2192 \u2115 \u2192 Code, Computable\u2082 f \u2227 \u2200 c n x, eval (f c n) x = eval c (Nat.pair n x)", "start": [689, 1], "end": [695, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.exists_code", "code": "theorem exists_code {f : \u2115 \u2192. \u2115} : Nat.Partrec f \u2194 \u2203 c : Code, eval c = f", "start": [698, 1], "end": [728, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln", "code": "def evaln : \u2115 \u2192 Code \u2192 \u2115 \u2192 Option \u2115\n  | 0, _ => fun _ => Option.none\n  | k + 1, zero => fun n => do\n    guard (n \u2264 k)\n    return 0\n  | k + 1, succ => fun n => do\n    guard (n \u2264 k)\n    return (Nat.succ n)\n  | k + 1, left => fun n => do\n    guard (n \u2264 k)\n    return n.unpair.1\n  | k + 1, right => fun n => do\n    guard (n \u2264 k)\n    pure n.unpair.2\n  | k + 1, pair cf cg => fun n => do\n    guard (n \u2264 k)\n    Nat.pair <$> evaln (k + 1) cf n <*> evaln (k + 1) cg n\n  | k + 1, comp cf cg => fun n => do\n    guard (n \u2264 k)\n    let x \u2190 evaln (k + 1) cg n\n    evaln (k + 1) cf x\n  | k + 1, prec cf cg => fun n => do\n    guard (n \u2264 k)\n    n.unpaired fun a n =>\n      n.casesOn (evaln (k + 1) cf a) fun y => do\n        let i \u2190 evaln k (prec cf cg) (Nat.pair a y)\n        evaln (k + 1) cg (Nat.pair a (Nat.pair y i))\n  | k + 1, rfind' cf => fun n => do\n    guard (n \u2264 k)\n    n.unpaired fun a m => do\n      let x \u2190 evaln (k + 1) cf (Nat.pair a m)\n      if x = 0 then\n        pure m\n      else\n        evaln k (rfind' cf) (Nat.pair a (m + 1))\n  termination_by evaln k c => (k, c)\n  decreasing_by { decreasing_with simp (config := { arith := true }) [Zero.zero]; done }", "start": [732, 1], "end": [772, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_bound", "code": "theorem evaln_bound : \u2200 {k c n x}, x \u2208 evaln k c n \u2192 n < k", "start": [775, 1], "end": [780, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_mono", "code": "theorem evaln_mono : \u2200 {k\u2081 k\u2082 c n x}, k\u2081 \u2264 k\u2082 \u2192 x \u2208 evaln k\u2081 c n \u2192 x \u2208 evaln k\u2082 c n", "start": [783, 1], "end": [815, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_sound", "code": "theorem evaln_sound : \u2200 {k c n x}, x \u2208 evaln k c n \u2192 x \u2208 eval c n", "start": [818, 1], "end": [855, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_complete", "code": "theorem evaln_complete {c n x} : x \u2208 eval c n \u2194 \u2203 k, x \u2208 evaln k c n", "start": [858, 1], "end": [924, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.lup", "code": "private def lup (L : List (List (Option \u2115))) (p : \u2115 \u00d7 Code) (n : \u2115) := do\n  let l \u2190 L.get? (encode p)\n  let o \u2190 l.get? n\n  o", "start": [931, 1], "end": [934, 4], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.hlup", "code": "private theorem hlup : Primrec fun p : _ \u00d7 (_ \u00d7 _) \u00d7 _ => lup p.1 p.2.1 p.2.2", "start": [936, 1], "end": [940, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.G", "code": "private def G (L : List (List (Option \u2115))) : Option (List (Option \u2115)) :=\n  Option.some <|\n    let a := ofNat (\u2115 \u00d7 Code) L.length\n    let k := a.1\n    let c := a.2\n    (List.range k).map fun n =>\n      k.casesOn Option.none fun k' =>\n        Nat.Partrec.Code.recOn c\n          (some 0) (some (Nat.succ n))\n          (some n.unpair.1)\n          (some n.unpair.2)\n          (fun cf cg _ _ => do\n            let x \u2190 lup L (k, cf) n\n            let y \u2190 lup L (k, cg) n\n            some (Nat.pair x y))\n          (fun cf cg _ _ => do\n            let x \u2190 lup L (k, cg) n\n            lup L (k, cf) x)\n          (fun cf cg _ _ =>\n            let z := n.unpair.1\n            n.unpair.2.casesOn (lup L (k, cf) z) fun y => do\n              let i \u2190 lup L (k', c) (Nat.pair z y)\n              lup L (k, cg) (Nat.pair z (Nat.pair y i)))\n          (fun cf _ =>\n            let z := n.unpair.1\n            let m := n.unpair.2\n            do\n              let x \u2190 lup L (k, cf) (Nat.pair z m)\n              x.casesOn (some m) fun _ => lup L (k', c) (Nat.pair z (m + 1)))", "start": [942, 1], "end": [971, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.hG", "code": "private theorem hG : Primrec G", "start": [973, 1], "end": [1073, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_map", "code": "private theorem evaln_map (k c n) :\n    ((((List.range k).get? n).map (evaln k c)).bind fun b => b) = evaln k c n", "start": [1075, 1], "end": [1083, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.evaln_prim", "code": "theorem evaln_prim : Primrec fun a : (\u2115 \u00d7 Code) \u00d7 \u2115 => evaln a.1.1 a.1.2 a.2", "start": [1085, 1], "end": [1145, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_eq_rfindOpt", "code": "theorem eval_eq_rfindOpt (c n) : eval c n = Nat.rfindOpt fun k => evaln k c n", "start": [1154, 1], "end": [1157, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.eval_part", "code": "theorem eval_part : Partrec\u2082 eval", "start": [1160, 1], "end": [1163, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.fixed_point", "code": "theorem fixed_point {f : Code \u2192 Code} (hf : Computable f) : \u2203 c : Code, eval (f c) = eval c", "start": [1166, 1], "end": [1185, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Partrec.Code.fixed_point\u2082", "code": "theorem fixed_point\u2082 {f : Code \u2192 \u2115 \u2192. \u2115} (hf : Partrec\u2082 f) : \u2203 c : Code, eval c = f c", "start": [1188, 1], "end": [1191, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/FiniteMeasure.lean", "imports": ["Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "Mathlib/Topology/Algebra/Module/WeakDual.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MeasureTheory.FiniteMeasure", "code": "def _root_.MeasureTheory.FiniteMeasure (\u03a9 : Type*) [MeasurableSpace \u03a9] : Type _ :=\n  { \u03bc : Measure \u03a9 // IsFiniteMeasure \u03bc }", "start": [114, 1], "end": [117, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure", "code": "@[coe]\ndef toMeasure : FiniteMeasure \u03a9 \u2192 Measure \u03a9 := Subtype.val", "start": [122, 1], "end": [124, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instCoe", "code": "instance instCoe : Coe (FiniteMeasure \u03a9) (MeasureTheory.Measure \u03a9) where\n  coe := toMeasure", "start": [126, 1], "end": [128, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.isFiniteMeasure", "code": "instance isFiniteMeasure (\u03bc : FiniteMeasure \u03a9) : IsFiniteMeasure (\u03bc : Measure \u03a9) :=\n  \u03bc.prop", "start": [130, 1], "end": [131, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instCoeFun", "code": "instance instCoeFun : CoeFun (FiniteMeasure \u03a9) fun _ => Set \u03a9 \u2192 \u211d\u22650 :=\n  \u27e8fun \u03bc s => ((\u03bc : Measure \u03a9) s).toNNReal\u27e9", "start": [134, 1], "end": [135, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.ennreal_coeFn_eq_coeFn_toMeasure", "code": "@[simp]\ntheorem ennreal_coeFn_eq_coeFn_toMeasure (\u03bd : FiniteMeasure \u03a9) (s : Set \u03a9) :\n    (\u03bd s : \u211d\u22650\u221e) = (\u03bd : Measure \u03a9) s", "start": [140, 1], "end": [143, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.val_eq_toMeasure", "code": "@[simp]\ntheorem val_eq_toMeasure (\u03bd : FiniteMeasure \u03a9) : \u03bd.val = (\u03bd : Measure \u03a9)", "start": [146, 1], "end": [148, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure_injective", "code": "theorem toMeasure_injective : Function.Injective ((\u2191) : FiniteMeasure \u03a9 \u2192 Measure \u03a9)", "start": [151, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.apply_mono", "code": "theorem apply_mono (\u03bc : FiniteMeasure \u03a9) {s\u2081 s\u2082 : Set \u03a9} (h : s\u2081 \u2286 s\u2082) : \u03bc s\u2081 \u2264 \u03bc s\u2082", "start": [155, 1], "end": [158, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.mass", "code": "def mass (\u03bc : FiniteMeasure \u03a9) : \u211d\u22650 :=\n  \u03bc univ", "start": [161, 1], "end": [164, 9], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.apply_le_mass", "code": "@[simp] theorem apply_le_mass (\u03bc : FiniteMeasure \u03a9) (s : Set \u03a9) : \u03bc s \u2264 \u03bc.mass", "start": [167, 1], "end": [168, 43], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.ennreal_mass", "code": "@[simp]\ntheorem ennreal_mass {\u03bc : FiniteMeasure \u03a9} : (\u03bc.mass : \u211d\u22650\u221e) = (\u03bc : Measure \u03a9) univ", "start": [170, 1], "end": [172, 46], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instZero", "code": "instance instZero : Zero (FiniteMeasure \u03a9) where zero := \u27e80, MeasureTheory.isFiniteMeasureZero\u27e9", "start": [175, 1], "end": [175, 96], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.zero_mass", "code": "@[simp]\ntheorem zero_mass : (0 : FiniteMeasure \u03a9).mass = 0", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.mass_zero_iff", "code": "@[simp]\ntheorem mass_zero_iff (\u03bc : FiniteMeasure \u03a9) : \u03bc.mass = 0 \u2194 \u03bc = 0", "start": [183, 1], "end": [188, 44], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.mass_nonzero_iff", "code": "theorem mass_nonzero_iff (\u03bc : FiniteMeasure \u03a9) : \u03bc.mass \u2260 0 \u2194 \u03bc \u2260 0", "start": [191, 1], "end": [193, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.eq_of_forall_toMeasure_apply_eq", "code": "@[ext]\ntheorem eq_of_forall_toMeasure_apply_eq (\u03bc \u03bd : FiniteMeasure \u03a9)\n    (h : \u2200 s : Set \u03a9, MeasurableSet s \u2192 (\u03bc : Measure \u03a9) s = (\u03bd : Measure \u03a9) s) : \u03bc = \u03bd", "start": [196, 1], "end": [201, 19], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.eq_of_forall_apply_eq", "code": "theorem eq_of_forall_apply_eq (\u03bc \u03bd : FiniteMeasure \u03a9)\n    (h : \u2200 s : Set \u03a9, MeasurableSet s \u2192 \u03bc s = \u03bd s) : \u03bc = \u03bd", "start": [204, 1], "end": [207, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instInhabited", "code": "instance instInhabited : Inhabited (FiniteMeasure \u03a9) :=\n  \u27e80\u27e9", "start": [210, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instAdd", "code": "instance instAdd : Add (FiniteMeasure \u03a9) where add \u03bc \u03bd := \u27e8\u03bc + \u03bd, MeasureTheory.isFiniteMeasureAdd\u27e9", "start": [213, 1], "end": [213, 100], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instSMul", "code": "instance instSMul : SMul R (FiniteMeasure \u03a9) where\n  smul (c : R) \u03bc := \u27e8c \u2022 (\u03bc : Measure \u03a9), MeasureTheory.isFiniteMeasureSMulOfNNRealTower\u27e9", "start": [218, 1], "end": [219, 90], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure_zero", "code": "@[norm_cast]\ntheorem toMeasure_zero : ((\u2191) : FiniteMeasure \u03a9 \u2192 Measure \u03a9) 0 = 0", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure_add", "code": "@[norm_cast]\ntheorem toMeasure_add (\u03bc \u03bd : FiniteMeasure \u03a9) : \u2191(\u03bc + \u03bd) = (\u2191\u03bc + \u2191\u03bd : Measure \u03a9)", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasure_smul", "code": "@[norm_cast]\ntheorem toMeasure_smul (c : R) (\u03bc : FiniteMeasure \u03a9) : \u2191(c \u2022 \u03bc) = c \u2022 (\u03bc : Measure \u03a9)", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.coeFn_zero", "code": "@[simp, norm_cast]\ntheorem coeFn_zero : (\u21d1(0 : FiniteMeasure \u03a9) : Set \u03a9 \u2192 \u211d\u22650) = (0 : Set \u03a9 \u2192 \u211d\u22650)", "start": [239, 1], "end": [241, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.coeFn_add", "code": "@[simp, norm_cast]\ntheorem coeFn_add (\u03bc \u03bd : FiniteMeasure \u03a9) : (\u21d1(\u03bc + \u03bd) : Set \u03a9 \u2192 \u211d\u22650) = (\u21d1\u03bc + \u21d1\u03bd : Set \u03a9 \u2192 \u211d\u22650)", "start": [244, 1], "end": [249, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.coeFn_smul", "code": "@[simp, norm_cast]\ntheorem coeFn_smul [IsScalarTower R \u211d\u22650 \u211d\u22650] (c : R) (\u03bc : FiniteMeasure \u03a9) :\n    (\u21d1(c \u2022 \u03bc) : Set \u03a9 \u2192 \u211d\u22650) = c \u2022 (\u21d1\u03bc : Set \u03a9 \u2192 \u211d\u22650)", "start": [252, 1], "end": [258, 12], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instAddCommMonoid", "code": "instance instAddCommMonoid : AddCommMonoid (FiniteMeasure \u03a9) :=\n  toMeasure_injective.addCommMonoid (\u2191) toMeasure_zero toMeasure_add fun _ _ => toMeasure_smul _ _", "start": [261, 1], "end": [262, 99], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toMeasureAddMonoidHom", "code": "@[simps]\ndef toMeasureAddMonoidHom : FiniteMeasure \u03a9 \u2192+ Measure \u03a9 where\n  toFun := (\u2191)\n  map_zero' := toMeasure_zero\n  map_add' := toMeasure_add", "start": [264, 1], "end": [269, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.coeFn_smul_apply", "code": "theorem coeFn_smul_apply [IsScalarTower R \u211d\u22650 \u211d\u22650] (c : R) (\u03bc : FiniteMeasure \u03a9) (s : Set \u03a9) :\n    (c \u2022 \u03bc) s = c \u2022 \u03bc s", "start": [276, 1], "end": [278, 33], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict", "code": "def restrict (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) : FiniteMeasure \u03a9 where\n  val := (\u03bc : Measure \u03a9).restrict A\n  property := MeasureTheory.isFiniteMeasureRestrict (\u03bc : Measure \u03a9) A", "start": [282, 1], "end": [285, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_measure_eq", "code": "theorem restrict_measure_eq (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) :\n    (\u03bc.restrict A : Measure \u03a9) = (\u03bc : Measure \u03a9).restrict A", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_apply_measure", "code": "theorem restrict_apply_measure (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) {s : Set \u03a9}\n    (s_mble : MeasurableSet s) : (\u03bc.restrict A : Measure \u03a9) s = (\u03bc : Measure \u03a9) (s \u2229 A)", "start": [293, 1], "end": [295, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_apply", "code": "theorem restrict_apply (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) {s : Set \u03a9} (s_mble : MeasurableSet s) :\n    (\u03bc.restrict A) s = \u03bc (s \u2229 A)", "start": [298, 1], "end": [301, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_mass", "code": "theorem restrict_mass (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) : (\u03bc.restrict A).mass = \u03bc A", "start": [304, 1], "end": [305, 70], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_eq_zero_iff", "code": "theorem restrict_eq_zero_iff (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) : \u03bc.restrict A = 0 \u2194 \u03bc A = 0", "start": [308, 1], "end": [309, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.restrict_nonzero_iff", "code": "theorem restrict_nonzero_iff (\u03bc : FiniteMeasure \u03a9) (A : Set \u03a9) : \u03bc.restrict A \u2260 0 \u2194 \u03bc A \u2260 0", "start": [312, 1], "end": [313, 41], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN", "code": "def testAgainstNN (\u03bc : FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) : \u211d\u22650 :=\n  (\u222b\u207b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)).toNNReal", "start": [318, 1], "end": [322, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_coe_eq", "code": "@[simp]\ntheorem testAgainstNN_coe_eq {\u03bc : FiniteMeasure \u03a9} {f : \u03a9 \u2192\u1d47 \u211d\u22650} :\n    (\u03bc.testAgainstNN f : \u211d\u22650\u221e) = \u222b\u207b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)", "start": [325, 1], "end": [328, 59], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_const", "code": "theorem testAgainstNN_const (\u03bc : FiniteMeasure \u03a9) (c : \u211d\u22650) :\n    \u03bc.testAgainstNN (BoundedContinuousFunction.const \u03a9 c) = c * \u03bc.mass", "start": [331, 1], "end": [333, 30], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_mono", "code": "theorem testAgainstNN_mono (\u03bc : FiniteMeasure \u03a9) {f g : \u03a9 \u2192\u1d47 \u211d\u22650} (f_le_g : (f : \u03a9 \u2192 \u211d\u22650) \u2264 g) :\n    \u03bc.testAgainstNN f \u2264 \u03bc.testAgainstNN g", "start": [336, 1], "end": [339, 60], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_zero", "code": "@[simp]\ntheorem testAgainstNN_zero (\u03bc : FiniteMeasure \u03a9) : \u03bc.testAgainstNN 0 = 0", "start": [342, 1], "end": [344, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_one", "code": "@[simp]\ntheorem testAgainstNN_one (\u03bc : FiniteMeasure \u03a9) : \u03bc.testAgainstNN 1 = \u03bc.mass", "start": [347, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.zero_testAgainstNN_apply", "code": "@[simp]\ntheorem zero_testAgainstNN_apply (f : \u03a9 \u2192\u1d47 \u211d\u22650) : (0 : FiniteMeasure \u03a9).testAgainstNN f = 0", "start": [353, 1], "end": [355, 91], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.zero_testAgainstNN", "code": "theorem zero_testAgainstNN : (0 : FiniteMeasure \u03a9).testAgainstNN = 0", "start": [358, 1], "end": [360, 54], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.smul_testAgainstNN_apply", "code": "@[simp]\ntheorem smul_testAgainstNN_apply (c : \u211d\u22650) (\u03bc : FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    (c \u2022 \u03bc).testAgainstNN f = c \u2022 \u03bc.testAgainstNN f", "start": [363, 1], "end": [367, 28], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_add", "code": "theorem testAgainstNN_add (\u03bc : FiniteMeasure \u03a9) (f\u2081 f\u2082 : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN (f\u2081 + f\u2082) = \u03bc.testAgainstNN f\u2081 + \u03bc.testAgainstNN f\u2082", "start": [372, 1], "end": [376, 87], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_smul", "code": "theorem testAgainstNN_smul [IsScalarTower R \u211d\u22650 \u211d\u22650] [PseudoMetricSpace R] [Zero R]\n    [BoundedSMul R \u211d\u22650] (\u03bc : FiniteMeasure \u03a9) (c : R) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN (c \u2022 f) = c \u2022 \u03bc.testAgainstNN f", "start": [379, 1], "end": [387, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz_estimate", "code": "theorem testAgainstNN_lipschitz_estimate (\u03bc : FiniteMeasure \u03a9) (f g : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.testAgainstNN f \u2264 \u03bc.testAgainstNN g + nndist f g * \u03bc.mass", "start": [390, 1], "end": [405, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.testAgainstNN_lipschitz", "code": "theorem testAgainstNN_lipschitz (\u03bc : FiniteMeasure \u03a9) :\n    LipschitzWith \u03bc.mass fun f : \u03a9 \u2192\u1d47 \u211d\u22650 => \u03bc.testAgainstNN f", "start": [408, 1], "end": [425, 48], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toWeakDualBCNN", "code": "def toWeakDualBCNN (\u03bc : FiniteMeasure \u03a9) : WeakDual \u211d\u22650 (\u03a9 \u2192\u1d47 \u211d\u22650) where\n  toFun f := \u03bc.testAgainstNN f\n  map_add' := testAgainstNN_add \u03bc\n  map_smul' := testAgainstNN_smul \u03bc\n  cont := \u03bc.testAgainstNN_lipschitz.continuous", "start": [428, 1], "end": [434, 47], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.coe_toWeakDualBCNN", "code": "@[simp]\ntheorem coe_toWeakDualBCNN (\u03bc : FiniteMeasure \u03a9) : \u21d1\u03bc.toWeakDualBCNN = \u03bc.testAgainstNN", "start": [437, 1], "end": [439, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toWeakDualBCNN_apply", "code": "@[simp]\ntheorem toWeakDualBCNN_apply (\u03bc : FiniteMeasure \u03a9) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    \u03bc.toWeakDualBCNN f = (\u222b\u207b x, f x \u2202(\u03bc : Measure \u03a9)).toNNReal", "start": [442, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.instTopologicalSpace", "code": "instance instTopologicalSpace : TopologicalSpace (FiniteMeasure \u03a9) :=\n  TopologicalSpace.induced toWeakDualBCNN inferInstance", "start": [448, 1], "end": [452, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.toWeakDualBCNN_continuous", "code": "theorem toWeakDualBCNN_continuous : Continuous (@toWeakDualBCNN \u03a9 _ _ _)", "start": [454, 1], "end": [455, 25], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.continuous_testAgainstNN_eval", "code": "theorem continuous_testAgainstNN_eval (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    Continuous fun \u03bc : FiniteMeasure \u03a9 => \u03bc.testAgainstNN f", "start": [460, 1], "end": [464, 82], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.continuous_mass", "code": "theorem continuous_mass : Continuous fun \u03bc : FiniteMeasure \u03a9 => \u03bc.mass", "start": [470, 1], "end": [472, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mass", "code": "theorem _root_.Filter.Tendsto.mass {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9} (h : Tendsto \u03bcs F (\ud835\udcdd \u03bc)) : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd \u03bc.mass)", "start": [475, 1], "end": [478, 37], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_iff_weak_star_tendsto", "code": "theorem tendsto_iff_weak_star_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194 Tendsto (fun i => (\u03bcs i).toWeakDualBCNN) F (\ud835\udcdd \u03bc.toWeakDualBCNN)", "start": [481, 1], "end": [484, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_iff_forall_toWeakDualBCNN_tendsto", "code": "theorem tendsto_iff_forall_toWeakDualBCNN_tendsto {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9} {\u03bc : FiniteMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d\u22650, Tendsto (fun i => (\u03bcs i).toWeakDualBCNN f) F (\ud835\udcdd (\u03bc.toWeakDualBCNN f))", "start": [487, 1], "end": [491, 93], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_iff_forall_testAgainstNN_tendsto", "code": "theorem tendsto_iff_forall_testAgainstNN_tendsto {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9} {\u03bc : FiniteMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d\u22650, Tendsto (fun i => (\u03bcs i).testAgainstNN f) F (\ud835\udcdd (\u03bc.testAgainstNN f))", "start": [494, 1], "end": [498, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_zero_testAgainstNN_of_tendsto_zero_mass", "code": "theorem tendsto_zero_testAgainstNN_of_tendsto_zero_mass {\u03b3 : Type*} {F : Filter \u03b3}\n    {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9} (mass_lim : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd 0)) (f : \u03a9 \u2192\u1d47 \u211d\u22650) :\n    Tendsto (fun i => (\u03bcs i).testAgainstNN f) F (\ud835\udcdd 0)", "start": [501, 1], "end": [518, 24], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_zero_of_tendsto_zero_mass", "code": "theorem tendsto_zero_of_tendsto_zero_mass {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    (mass_lim : Tendsto (fun i => (\u03bcs i).mass) F (\ud835\udcdd 0)) : Tendsto \u03bcs F (\ud835\udcdd 0)", "start": [521, 1], "end": [527, 32], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_iff_forall_lintegral_tendsto", "code": "theorem tendsto_iff_forall_lintegral_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d\u22650,\n        Tendsto (fun i => \u222b\u207b x, f x \u2202(\u03bcs i : Measure \u03a9)) F (\ud835\udcdd (\u222b\u207b x, f x \u2202(\u03bc : Measure \u03a9)))", "start": [530, 1], "end": [539, 26], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_filter_of_le_const", "code": "theorem tendsto_lintegral_nn_filter_of_le_const {\u03b9 : Type*} {L : Filter \u03b9} [L.IsCountablyGenerated]\n    (\u03bc : Measure \u03a9) [IsFiniteMeasure \u03bc] {fs : \u03b9 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650} {c : \u211d\u22650}\n    (fs_le_const : \u2200\u1da0 i in L, \u2200\u1d50 \u03c9 : \u03a9 \u2202\u03bc, fs i \u03c9 \u2264 c) {f : \u03a9 \u2192 \u211d\u22650}\n    (fs_lim : \u2200\u1d50 \u03c9 : \u03a9 \u2202\u03bc, Tendsto (fun i => fs i \u03c9) L (\ud835\udcdd (f \u03c9))) :\n    Tendsto (fun i => \u222b\u207b \u03c9, fs i \u03c9 \u2202\u03bc) L (\ud835\udcdd (\u222b\u207b \u03c9, f \u03c9 \u2202\u03bc))", "start": [555, 1], "end": [574, 71], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_lintegral_nn_of_le_const", "code": "theorem tendsto_lintegral_nn_of_le_const (\u03bc : FiniteMeasure \u03a9) {fs : \u2115 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650} {c : \u211d\u22650}\n    (fs_le_const : \u2200 n \u03c9, fs n \u03c9 \u2264 c) {f : \u03a9 \u2192 \u211d\u22650}\n    (fs_lim : \u2200 \u03c9, Tendsto (fun n => fs n \u03c9) atTop (\ud835\udcdd (f \u03c9))) :\n    Tendsto (fun n => \u222b\u207b \u03c9, fs n \u03c9 \u2202(\u03bc : Measure \u03a9)) atTop (\ud835\udcdd (\u222b\u207b \u03c9, f \u03c9 \u2202(\u03bc : Measure \u03a9)))", "start": [577, 1], "end": [591, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_filter_of_le_const", "code": "theorem tendsto_testAgainstNN_filter_of_le_const {\u03b9 : Type*} {L : Filter \u03b9}\n    [L.IsCountablyGenerated] {\u03bc : FiniteMeasure \u03a9} {fs : \u03b9 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650} {c : \u211d\u22650}\n    (fs_le_const : \u2200\u1da0 i in L, \u2200\u1d50 \u03c9 : \u03a9 \u2202(\u03bc : Measure \u03a9), fs i \u03c9 \u2264 c) {f : \u03a9 \u2192\u1d47 \u211d\u22650}\n    (fs_lim : \u2200\u1d50 \u03c9 : \u03a9 \u2202(\u03bc : Measure \u03a9), Tendsto (fun i => fs i \u03c9) L (\ud835\udcdd (f \u03c9))) :\n    Tendsto (fun i => \u03bc.testAgainstNN (fs i)) L (\ud835\udcdd (\u03bc.testAgainstNN f))", "start": [594, 1], "end": [613, 69], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_testAgainstNN_of_le_const", "code": "theorem tendsto_testAgainstNN_of_le_const {\u03bc : FiniteMeasure \u03a9} {fs : \u2115 \u2192 \u03a9 \u2192\u1d47 \u211d\u22650} {c : \u211d\u22650}\n    (fs_le_const : \u2200 n \u03c9, fs n \u03c9 \u2264 c) {f : \u03a9 \u2192\u1d47 \u211d\u22650}\n    (fs_lim : \u2200 \u03c9, Tendsto (fun n => fs n \u03c9) atTop (\ud835\udcdd (f \u03c9))) :\n    Tendsto (fun n => \u03bc.testAgainstNN (fs n)) atTop (\ud835\udcdd (\u03bc.testAgainstNN f))", "start": [616, 1], "end": [633, 34], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_of_forall_integral_tendsto", "code": "theorem tendsto_of_forall_integral_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9}\n    (h :\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d,\n        Tendsto (fun i => \u222b x, f x \u2202(\u03bcs i : Measure \u03a9)) F (\ud835\udcdd (\u222b x, f x \u2202(\u03bc : Measure \u03a9)))) :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc)", "start": [650, 1], "end": [675, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_iff_forall_integral_tendsto", "code": "theorem tendsto_iff_forall_integral_tendsto {\u03b3 : Type*} {F : Filter \u03b3} {\u03bcs : \u03b3 \u2192 FiniteMeasure \u03a9}\n    {\u03bc : FiniteMeasure \u03a9} :\n    Tendsto \u03bcs F (\ud835\udcdd \u03bc) \u2194\n      \u2200 f : \u03a9 \u2192\u1d47 \u211d,\n        Tendsto (fun i => \u222b x, f x \u2202(\u03bcs i : Measure \u03a9)) F (\ud835\udcdd (\u222b x, f x \u2202(\u03bc : Measure \u03a9)))", "start": [678, 1], "end": [699, 40], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.map", "code": "noncomputable def map (\u03bd : FiniteMeasure \u03a9) (f : \u03a9 \u2192 \u03a9') : FiniteMeasure \u03a9' :=\n  \u27e8(\u03bd : Measure \u03a9).map f, by\n    constructor\n    by_cases f_aemble : AEMeasurable f \u03bd\n    \u00b7 rw [Measure.map_apply_of_aemeasurable f_aemble MeasurableSet.univ]\n      exact measure_lt_top (\u2191\u03bd) (f \u207b\u00b9' univ)\n    \u00b7 simp [Measure.map, f_aemble]\u27e9", "start": [708, 1], "end": [715, 36], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.map_apply'", "code": "lemma map_apply' (\u03bd : FiniteMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_aemble : AEMeasurable f \u03bd)\n    {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    (\u03bd.map f : Measure \u03a9') A = (\u03bd : Measure \u03a9) (f \u207b\u00b9' A) :=\n  Measure.map_apply_of_aemeasurable f_aemble A_mble", "start": [717, 1], "end": [722, 52], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.map_apply_of_aemeasurable", "code": "lemma map_apply_of_aemeasurable (\u03bd : FiniteMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_aemble : AEMeasurable f \u03bd)\n    {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    \u03bd.map f A = \u03bd (f \u207b\u00b9' A) := by\n  have := \u03bd.map_apply' f_aemble A_mble\n  exact (ENNReal.toNNReal_eq_toNNReal_iff' (measure_ne_top _ _) (measure_ne_top _ _)).mpr this", "start": [724, 1], "end": [728, 95], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.map_apply", "code": "@[simp] lemma map_apply (\u03bd : FiniteMeasure \u03a9) {f : \u03a9 \u2192 \u03a9'} (f_mble : Measurable f)\n    {A : Set \u03a9'} (A_mble : MeasurableSet A) :\n    \u03bd.map f A = \u03bd (f \u207b\u00b9' A) :=\n  map_apply_of_aemeasurable \u03bd f_mble.aemeasurable A_mble", "start": [730, 1], "end": [733, 57], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.map_add", "code": "@[simp] lemma map_add {f : \u03a9 \u2192 \u03a9'} (f_mble : Measurable f) (\u03bd\u2081 \u03bd\u2082 : FiniteMeasure \u03a9)  :\n    (\u03bd\u2081 + \u03bd\u2082).map f = \u03bd\u2081.map f + \u03bd\u2082.map f := by\n  ext s s_mble\n  simp [map_apply' _ f_mble.aemeasurable s_mble, toMeasure_add]", "start": [735, 1], "end": [738, 64], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.map_smul", "code": "@[simp] lemma map_smul {f : \u03a9 \u2192 \u03a9'} (f_mble : Measurable f) (c : \u211d\u22650) (\u03bd : FiniteMeasure \u03a9)  :\n    (c \u2022 \u03bd).map f = c \u2022 (\u03bd.map f) := by\n  ext s s_mble\n  simp [map_apply' _ f_mble.aemeasurable s_mble, toMeasure_smul]", "start": [740, 1], "end": [743, 65], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.mapHom", "code": "noncomputable def mapHom {f : \u03a9 \u2192 \u03a9'} (f_mble : Measurable f) :\n    FiniteMeasure \u03a9 \u2192\u2097[\u211d\u22650] FiniteMeasure \u03a9' where\n  toFun := fun \u03bd \u21a6 \u03bd.map f\n  map_add' := map_add f_mble\n  map_smul' := map_smul f_mble", "start": [745, 1], "end": [750, 31], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.FiniteMeasure.tendsto_map_of_tendsto_of_continuous", "code": "lemma tendsto_map_of_tendsto_of_continuous {\u03b9 : Type*} {L : Filter \u03b9}\n    (\u03bds : \u03b9 \u2192 FiniteMeasure \u03a9) (\u03bd : FiniteMeasure \u03a9) (lim : Tendsto \u03bds L (\ud835\udcdd \u03bd))\n    {f : \u03a9 \u2192 \u03a9'} (f_cont : Continuous f) :\n    Tendsto (fun i \u21a6 (\u03bds i).map f) L (\ud835\udcdd (\u03bd.map f)) := by\n  rw [FiniteMeasure.tendsto_iff_forall_lintegral_tendsto] at lim \u22a2\n  intro g\n  convert lim (g.compContinuous \u27e8f, f_cont\u27e9) <;>\n  \u00b7 simp only [map, compContinuous_apply, ContinuousMap.coe_mk]\n    refine lintegral_map ?_ f_cont.measurable\n    exact (ENNReal.continuous_coe.comp g.continuous).measurable", "start": [755, 1], "end": [767, 64], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.continuous_map", "code": "lemma continuous_map {f : \u03a9 \u2192 \u03a9'} (f_cont : Continuous f) :\n    Continuous (fun \u03bd \u21a6 FiniteMeasure.map \u03bd f) := by\n  rw [continuous_iff_continuousAt]\n  exact fun _ \u21a6 tendsto_map_of_tendsto_of_continuous _ _ continuous_id.continuousAt f_cont", "start": [769, 1], "end": [775, 91], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.FiniteMeasure.mapClm", "code": "noncomputable def mapClm {f : \u03a9 \u2192 \u03a9'} (f_cont : Continuous f) :\n    FiniteMeasure \u03a9 \u2192L[\u211d\u22650] FiniteMeasure \u03a9' where\n  toFun := fun \u03bd \u21a6 \u03bd.map f\n  map_add' := map_add f_cont.measurable\n  map_smul' := map_smul f_cont.measurable\n  cont := continuous_map f_cont", "start": [777, 1], "end": [784, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/ClassGroup.lean", "imports": ["Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/RingTheory/DedekindDomain/Ideal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "toPrincipalIdeal", "code": "irreducible_def toPrincipalIdeal : K\u02e3 \u2192* (FractionalIdeal R\u2070 K)\u02e3 :=\n  { toFun := fun x =>\n      \u27e8spanSingleton _ x, spanSingleton _ x\u207b\u00b9, by\n        simp only [spanSingleton_one, Units.mul_inv', spanSingleton_mul_spanSingleton], by\n        simp only [spanSingleton_one, Units.inv_mul', spanSingleton_mul_spanSingleton]\u27e9\n    map_mul' := fun x y =>\n      ext (by simp only [Units.val_mk, Units.val_mul, spanSingleton_mul_spanSingleton])\n    map_one' := ext (by simp only [spanSingleton_one, Units.val_mk, Units.val_one]) }", "start": [51, 1], "end": [59, 86], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "coe_toPrincipalIdeal", "code": "@[simp]\ntheorem coe_toPrincipalIdeal (x : K\u02e3) :\n    (toPrincipalIdeal R K x : FractionalIdeal R\u2070 K) = spanSingleton _ (x : K)", "start": [64, 1], "end": [67, 36], "kind": "commanddeclaration"}, {"full_name": "toPrincipalIdeal_eq_iff", "code": "@[simp]\ntheorem toPrincipalIdeal_eq_iff {I : (FractionalIdeal R\u2070 K)\u02e3} {x : K\u02e3} :\n    toPrincipalIdeal R K x = I \u2194 spanSingleton R\u2070 (x : K) = I", "start": [70, 1], "end": [73, 52], "kind": "commanddeclaration"}, {"full_name": "mem_principal_ideals_iff", "code": "theorem mem_principal_ideals_iff {I : (FractionalIdeal R\u2070 K)\u02e3} :\n    I \u2208 (toPrincipalIdeal R K).range \u2194 \u2203 x : K, spanSingleton R\u2070 x = I", "start": [76, 1], "end": [83, 32], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdeals.normal", "code": "instance PrincipalIdeals.normal : (toPrincipalIdeal R K).range.Normal :=\n  Subgroup.normal_of_comm _", "start": [86, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "ClassGroup", "code": "def ClassGroup :=\n  (FractionalIdeal R\u2070 (FractionRing R))\u02e3 \u29f8 (toPrincipalIdeal R (FractionRing R)).range", "start": [96, 1], "end": [99, 87], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk", "code": "noncomputable def ClassGroup.mk : (FractionalIdeal R\u2070 K)\u02e3 \u2192* ClassGroup R :=\n  (QuotientGroup.mk' (toPrincipalIdeal R (FractionRing R)).range).comp\n    (Units.map (FractionalIdeal.canonicalEquiv R\u2070 K (FractionRing R)))", "start": [109, 1], "end": [112, 71], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.Quot_mk_eq_mk", "code": "theorem ClassGroup.Quot_mk_eq_mk (I : (FractionalIdeal R\u2070 (FractionRing R))\u02e3) :\n    Quot.mk _ I = ClassGroup.mk I", "start": [116, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_eq_mk", "code": "theorem ClassGroup.mk_eq_mk {I J : (FractionalIdeal R\u2070 <| FractionRing R)\u02e3} :\n    ClassGroup.mk I = ClassGroup.mk J \u2194\n      \u2203 x : (FractionRing R)\u02e3, I * toPrincipalIdeal R (FractionRing R) x = J", "start": [124, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_eq_mk_of_coe_ideal", "code": "theorem ClassGroup.mk_eq_mk_of_coe_ideal {I J : (FractionalIdeal R\u2070 <| FractionRing R)\u02e3}\n    {I' J' : Ideal R} (hI : (I : FractionalIdeal R\u2070 <| FractionRing R) = I')\n    (hJ : (J : FractionalIdeal R\u2070 <| FractionRing R) = J') :\n    ClassGroup.mk I = ClassGroup.mk J \u2194\n      \u2203 x y : R, x \u2260 0 \u2227 y \u2260 0 \u2227 Ideal.span {x} * I' = Ideal.span {y} * J'", "start": [131, 1], "end": [149, 38], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_eq_one_of_coe_ideal", "code": "theorem ClassGroup.mk_eq_one_of_coe_ideal {I : (FractionalIdeal R\u2070 <| FractionRing R)\u02e3}\n    {I' : Ideal R} (hI : (I : FractionalIdeal R\u2070 <| FractionRing R) = I') :\n    ClassGroup.mk I = 1 \u2194 \u2203 x : R, x \u2260 0 \u2227 I' = Ideal.span {x}", "start": [152, 1], "end": [166, 98], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.induction", "code": "@[elab_as_elim]\ntheorem ClassGroup.induction {P : ClassGroup R \u2192 Prop}\n    (h : \u2200 I : (FractionalIdeal R\u2070 K)\u02e3, P (ClassGroup.mk I)) (x : ClassGroup R) : P x", "start": [171, 1], "end": [182, 14], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.equiv", "code": "noncomputable def ClassGroup.equiv :\n    ClassGroup R \u2243* (FractionalIdeal R\u2070 K)\u02e3 \u29f8 (toPrincipalIdeal R K).range := by\n  haveI : Subgroup.map\n    (Units.mapEquiv (canonicalEquiv R\u2070 (FractionRing R) K).toMulEquiv).toMonoidHom\n    (toPrincipalIdeal R (FractionRing R)).range = (toPrincipalIdeal R K).range := by\n    ext I\n    simp only [Subgroup.mem_map, mem_principal_ideals_iff]\n    constructor\n    \u00b7 rintro \u27e8I, \u27e8x, hx\u27e9, rfl\u27e9\n      refine \u27e8FractionRing.algEquiv R K x, ?_\u27e9\n      simp only [RingEquiv.toMulEquiv_eq_coe, MulEquiv.coe_toMonoidHom, coe_mapEquiv, \u2190 hx,\n        RingEquiv.coe_toMulEquiv, canonicalEquiv_spanSingleton]\n      rfl\n    \u00b7 rintro \u27e8x, hx\u27e9\n      refine \u27e8Units.mapEquiv (canonicalEquiv R\u2070 K (FractionRing R)).toMulEquiv I,\n        \u27e8(FractionRing.algEquiv R K).symm x, ?_\u27e9, Units.ext ?_\u27e9\n      \u00b7 simp only [RingEquiv.toMulEquiv_eq_coe, coe_mapEquiv, \u2190 hx, RingEquiv.coe_toMulEquiv,\n          canonicalEquiv_spanSingleton]\n        rfl\n      \u00b7 simp only [RingEquiv.toMulEquiv_eq_coe, MulEquiv.coe_toMonoidHom, coe_mapEquiv,\n          RingEquiv.coe_toMulEquiv, canonicalEquiv_canonicalEquiv, canonicalEquiv_self,\n          RingEquiv.refl_apply]\n  exact @QuotientGroup.congr (FractionalIdeal R\u2070 (FractionRing R))\u02e3 _ (FractionalIdeal R\u2070 K)\u02e3 _\n    (toPrincipalIdeal R (FractionRing R)).range (toPrincipalIdeal R K).range _ _\n    (Units.mapEquiv (FractionalIdeal.canonicalEquiv R\u2070 (FractionRing R) K).toMulEquiv) this", "start": [185, 1], "end": [210, 92], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.equiv_mk", "code": "@[simp]\ntheorem ClassGroup.equiv_mk (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R\u2070 K)\u02e3) :\n    ClassGroup.equiv K' (ClassGroup.mk I) =\n      QuotientGroup.mk' _ (Units.mapEquiv (\u2191(FractionalIdeal.canonicalEquiv R\u2070 K K')) I)", "start": [213, 1], "end": [222, 64], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_canonicalEquiv", "code": "@[simp]\ntheorem ClassGroup.mk_canonicalEquiv (K' : Type*) [Field K'] [Algebra R K'] [IsFractionRing R K']\n    (I : (FractionalIdeal R\u2070 K)\u02e3) :\n    ClassGroup.mk (Units.map (\u2191(canonicalEquiv R\u2070 K K')) I : (FractionalIdeal R\u2070 K')\u02e3) =\n      ClassGroup.mk I", "start": [225, 1], "end": [234, 6], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.mk0", "code": "noncomputable def FractionalIdeal.mk0 [IsDedekindDomain R] : (Ideal R)\u2070 \u2192* (FractionalIdeal R\u2070 K)\u02e3\n    where\n  toFun I := Units.mk0 I (coeIdeal_ne_zero.mpr <| mem_nonZeroDivisors_iff_ne_zero.mp I.2)\n  map_one' := by simp\n  map_mul' x y := by simp", "start": [237, 1], "end": [242, 26], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.coe_mk0", "code": "@[simp]\ntheorem FractionalIdeal.coe_mk0 [IsDedekindDomain R] (I : (Ideal R)\u2070) :\n    (FractionalIdeal.mk0 K I : FractionalIdeal R\u2070 K) = I", "start": [245, 1], "end": [247, 64], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.canonicalEquiv_mk0", "code": "theorem FractionalIdeal.canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']\n    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)\u2070) :\n    FractionalIdeal.canonicalEquiv R\u2070 K K' (FractionalIdeal.mk0 K I) = FractionalIdeal.mk0 K' I", "start": [250, 1], "end": [253, 82], "kind": "commanddeclaration"}, {"full_name": "FractionalIdeal.map_canonicalEquiv_mk0", "code": "@[simp]\ntheorem FractionalIdeal.map_canonicalEquiv_mk0 [IsDedekindDomain R] (K' : Type*) [Field K']\n    [Algebra R K'] [IsFractionRing R K'] (I : (Ideal R)\u2070) :\n    Units.map (\u2191(FractionalIdeal.canonicalEquiv R\u2070 K K')) (FractionalIdeal.mk0 K I) =\n      FractionalIdeal.mk0 K' I", "start": [256, 1], "end": [261, 56], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0", "code": "noncomputable def ClassGroup.mk0 [IsDedekindDomain R] : (Ideal R)\u2070 \u2192* ClassGroup R :=\n  ClassGroup.mk.comp (FractionalIdeal.mk0 (FractionRing R))", "start": [264, 1], "end": [266, 60], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_mk0", "code": "@[simp]\ntheorem ClassGroup.mk_mk0 [IsDedekindDomain R] (I : (Ideal R)\u2070) :\n    ClassGroup.mk (FractionalIdeal.mk0 K I) = ClassGroup.mk0 I", "start": [269, 1], "end": [273, 44], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.equiv_mk0", "code": "@[simp]\ntheorem ClassGroup.equiv_mk0 [IsDedekindDomain R] (I : (Ideal R)\u2070) :\n    ClassGroup.equiv K (ClassGroup.mk0 I) =\n      QuotientGroup.mk' (toPrincipalIdeal R K).range (FractionalIdeal.mk0 K I)", "start": [276, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring", "code": "theorem ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring [IsDedekindDomain R] {I J : (Ideal R)\u2070} :\n    ClassGroup.mk0 I =\n      ClassGroup.mk0 J \u2194 \u2203 (x : _) (_ : x \u2260 (0 : K)), spanSingleton R\u2070 x * I = J", "start": [285, 1], "end": [298, 37], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0_eq_mk0_iff", "code": "theorem ClassGroup.mk0_eq_mk0_iff [IsDedekindDomain R] {I J : (Ideal R)\u2070} :\n    ClassGroup.mk0 I = ClassGroup.mk0 J \u2194\n      \u2203 (x y : R) (_hx : x \u2260 0) (_hy : y \u2260 0), Ideal.span {x} * (I : Ideal R) =\n      Ideal.span {y} * J", "start": [303, 1], "end": [320, 71], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.integralRep", "code": "noncomputable def ClassGroup.integralRep\n    (I : FractionalIdeal R\u2070 (FractionRing R)) :\n    Ideal R :=\n  let a := I.2.choose\n  { carrier := {x | (algebraMap R _ a)\u207b\u00b9 * algebraMap R _ x \u2208 I.1}\n    add_mem' := by\n      simp only [Set.mem_setOf_eq, RingHom.map_add, mul_add]\n      exact fun ha hb => Submodule.add_mem _ ha hb\n    zero_mem' := by\n      simp only [Set.mem_setOf_eq, RingHom.map_zero, mul_zero]\n      exact Submodule.zero_mem _\n    smul_mem' := by\n      intro c _ hb\n      simp only [smul_eq_mul, Set.mem_setOf_eq, RingHom.map_mul,\n        mul_left_comm ((algebraMap R (FractionRing R)) a)\u207b\u00b9]\n      rw [\u2190 Algebra.smul_def c]\n      exact Submodule.smul_mem _ c hb }", "start": [323, 1], "end": [340, 40], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.integralRep_mem_nonZeroDivisors", "code": "theorem ClassGroup.integralRep_mem_nonZeroDivisors\n    {I} (hI : I \u2260 0) :\n    ClassGroup.integralRep I \u2208 (Ideal R)\u2070", "start": [342, 1], "end": [354, 73], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0_integralRep", "code": "theorem ClassGroup.mk0_integralRep [IsDedekindDomain R]\n    (I : (FractionalIdeal R\u2070 (FractionRing R))\u02e3) :\n    ClassGroup.mk0 \u27e8ClassGroup.integralRep I, ClassGroup.integralRep_mem_nonZeroDivisors I.ne_zero\u27e9\n      = ClassGroup.mk I", "start": [356, 1], "end": [387, 80], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0_surjective", "code": "theorem ClassGroup.mk0_surjective [IsDedekindDomain R] :\n    Function.Surjective (ClassGroup.mk0 : (Ideal R)\u2070 \u2192 ClassGroup R)", "start": [389, 1], "end": [393, 60], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk_eq_one_iff", "code": "theorem ClassGroup.mk_eq_one_iff {I : (FractionalIdeal R\u2070 K)\u02e3} :\n    ClassGroup.mk I = 1 \u2194 (I : Submodule R K).IsPrincipal", "start": [396, 1], "end": [410, 15], "kind": "commanddeclaration"}, {"full_name": "ClassGroup.mk0_eq_one_iff", "code": "theorem ClassGroup.mk0_eq_one_iff [IsDedekindDomain R] {I : Ideal R} (hI : I \u2208 (Ideal R)\u2070) :\n    ClassGroup.mk0 \u27e8I, hI\u27e9 = 1 \u2194 I.IsPrincipal", "start": [413, 1], "end": [415, 64], "kind": "commanddeclaration"}, {"full_name": "card_classGroup_eq_one", "code": "theorem card_classGroup_eq_one [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R) = 1", "start": [430, 1], "end": [435, 91], "kind": "commanddeclaration"}, {"full_name": "card_classGroup_eq_one_iff", "code": "theorem card_classGroup_eq_one_iff [IsDedekindDomain R] [Fintype (ClassGroup R)] :\n    Fintype.card (ClassGroup R) = 1 \u2194 IsPrincipalIdealRing R", "start": [438, 1], "end": [448, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ClassNumber/AdmissibleAbsoluteValue.lean", "imports": ["Mathlib/Data/Real/Basic.lean", "Mathlib/Algebra/Order/EuclideanAbsoluteValue.lean", "Mathlib/Combinatorics/Pigeonhole.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AbsoluteValue.IsAdmissible", "code": "structure IsAdmissible extends IsEuclidean abv where\n  protected card : \u211d \u2192 \u2115\n  \n  exists_partition' :\n    \u2200 (n : \u2115) {\u03b5 : \u211d} (_ : 0 < \u03b5) {b : R} (_ : b \u2260 0) (A : Fin n \u2192 R),\n      \u2203 t : Fin n \u2192 Fin (card \u03b5), \u2200 i\u2080 i\u2081, t i\u2080 = t i\u2081 \u2192 (abv (A i\u2081 % b - A i\u2080 % b) : \u211d) < abv b \u2022 \u03b5", "start": [40, 1], "end": [49, 101], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.IsAdmissible.exists_partition", "code": "theorem exists_partition {\u03b9 : Type*} [Fintype \u03b9] {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : R} (hb : b \u2260 0)\n    (A : \u03b9 \u2192 R) (h : abv.IsAdmissible) : \u2203 t : \u03b9 \u2192 Fin (h.card \u03b5),\n      \u2200 i\u2080 i\u2081, t i\u2080 = t i\u2081 \u2192 (abv (A i\u2081 % b - A i\u2080 % b) : \u211d) < abv b \u2022 \u03b5", "start": [60, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.IsAdmissible.exists_approx_aux", "code": "theorem exists_approx_aux (n : \u2115) (h : abv.IsAdmissible) :\n    \u2200 {\u03b5 : \u211d} (_h\u03b5 : 0 < \u03b5) {b : R} (_hb : b \u2260 0) (A : Fin (h.card \u03b5 ^ n).succ \u2192 Fin n \u2192 R),\n      \u2203 i\u2080 i\u2081, i\u2080 \u2260 i\u2081 \u2227 \u2200 k, (abv (A i\u2081 k % b - A i\u2080 k % b) : \u211d) < abv b \u2022 \u03b5", "start": [72, 1], "end": [120, 14], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.IsAdmissible.exists_approx", "code": "theorem exists_approx {\u03b9 : Type*} [Fintype \u03b9] {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : R} (hb : b \u2260 0)\n    (h : abv.IsAdmissible) (A : Fin (h.card \u03b5 ^ Fintype.card \u03b9).succ \u2192 \u03b9 \u2192 R) :\n    \u2203 i\u2080 i\u2081, i\u2080 \u2260 i\u2081 \u2227 \u2200 k, (abv (A i\u2081 k % b - A i\u2080 k % b) : \u211d) < abv b \u2022 \u03b5", "start": [123, 1], "end": [131, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/AbsoluteValue.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Determinant.lean", "Mathlib/Data/Int/AbsoluteValue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.det_le", "code": "theorem det_le {A : Matrix n n R} {abv : AbsoluteValue R S} {x : S} (hx : \u2200 i j, abv (A i j) \u2264 x) :\n    abv A.det \u2264 Nat.factorial (Fintype.card n) \u2022 x ^ Fintype.card n", "start": [40, 1], "end": [52, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_sum_le", "code": "theorem det_sum_le {\u03b9 : Type*} (s : Finset \u03b9) {A : \u03b9 \u2192 Matrix n n R} {abv : AbsoluteValue R S}\n    {x : S} (hx : \u2200 k i j, abv (A k i j) \u2264 x) :\n    abv (det (\u2211 k in s, A k)) \u2264\n      Nat.factorial (Fintype.card n) \u2022 (Finset.card s \u2022 x) ^ Fintype.card n", "start": [55, 1], "end": [64, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_sum_smul_le", "code": "theorem det_sum_smul_le {\u03b9 : Type*} (s : Finset \u03b9) {c : \u03b9 \u2192 R} {A : \u03b9 \u2192 Matrix n n R}\n    {abv : AbsoluteValue R S} {x : S} (hx : \u2200 k i j, abv (A k i j) \u2264 x) {y : S}\n    (hy : \u2200 k, abv (c k) \u2264 y) :\n    abv (det (\u2211 k in s, c k \u2022 A k)) \u2264\n      Nat.factorial (Fintype.card n) \u2022 (Finset.card s \u2022 y * x) ^ Fintype.card n", "start": [67, 1], "end": [76, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Mirror.lean", "imports": ["Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "Mathlib/Data/Polynomial/RingDivision.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.mirror", "code": "noncomputable def mirror :=\n  p.reverse * X ^ p.natTrailingDegree", "start": [38, 1], "end": [40, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_zero", "code": "@[simp]\ntheorem mirror_zero : (0 : R[X]).mirror = 0", "start": [43, 1], "end": [44, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_monomial", "code": "theorem mirror_monomial (n : \u2115) (a : R) : (monomial n a).mirror = monomial n a", "start": [47, 1], "end": [53, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_C", "code": "theorem mirror_C (a : R) : (C a).mirror = C a", "start": [56, 1], "end": [57, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_X", "code": "theorem mirror_X : X.mirror = (X : R[X])", "start": [61, 1], "end": [62, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_natDegree", "code": "theorem mirror_natDegree : p.mirror.natDegree = p.natDegree", "start": [66, 1], "end": [72, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_natTrailingDegree", "code": "theorem mirror_natTrailingDegree : p.mirror.natTrailingDegree = p.natTrailingDegree", "start": [75, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mirror", "code": "theorem coeff_mirror (n : \u2115) :\n    p.mirror.coeff n = p.coeff (revAt (p.natDegree + p.natTrailingDegree) n)", "start": [82, 1], "end": [97, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_eval_one", "code": "theorem mirror_eval_one : p.mirror.eval 1 = p.eval 1", "start": [101, 1], "end": [120, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_mirror", "code": "theorem mirror_mirror : p.mirror.mirror = p", "start": [123, 1], "end": [125, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_involutive", "code": "theorem mirror_involutive : Function.Involutive (mirror : R[X] \u2192 R[X])", "start": [130, 1], "end": [131, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_eq_iff", "code": "theorem mirror_eq_iff : p.mirror = q \u2194 p = q.mirror", "start": [134, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_inj", "code": "@[simp]\ntheorem mirror_inj : p.mirror = q.mirror \u2194 p = q", "start": [138, 1], "end": [140, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_eq_zero", "code": "@[simp]\ntheorem mirror_eq_zero : p.mirror = 0 \u2194 p = 0", "start": [143, 1], "end": [145, 88], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_trailingCoeff", "code": "@[simp]\ntheorem mirror_trailingCoeff : p.mirror.trailingCoeff = p.leadingCoeff", "start": [150, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_leadingCoeff", "code": "@[simp]\ntheorem mirror_leadingCoeff : p.mirror.leadingCoeff = p.trailingCoeff", "start": [156, 1], "end": [158, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_mul_mirror", "code": "theorem coeff_mul_mirror :\n    (p * p.mirror).coeff (p.natDegree + p.natTrailingDegree) = p.sum fun n => (\u00b7 ^ 2)", "start": [161, 1], "end": [169, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_mul_mirror", "code": "theorem natDegree_mul_mirror : (p * p.mirror).natDegree = 2 * p.natDegree", "start": [174, 1], "end": [177, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natTrailingDegree_mul_mirror", "code": "theorem natTrailingDegree_mul_mirror :\n    (p * p.mirror).natTrailingDegree = 2 * p.natTrailingDegree", "start": [180, 1], "end": [184, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_neg", "code": "theorem mirror_neg : (-p).mirror = -p.mirror", "start": [193, 1], "end": [194, 78], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_mul_of_domain", "code": "theorem mirror_mul_of_domain : (p * q).mirror = p.mirror * q.mirror", "start": [199, 1], "end": [206, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mirror_smul", "code": "theorem mirror_smul (a : R) : (a \u2022 p).mirror = a \u2022 p.mirror", "start": [209, 1], "end": [210, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.irreducible_of_mirror", "code": "theorem irreducible_of_mirror (h1 : \u00acIsUnit f)\n    (h2 : \u2200 k, f * f.mirror = k * k.mirror \u2192 k = f \u2228 k = -f \u2228 k = f.mirror \u2228 k = -f.mirror)\n    (h3 : \u2200 g, g \u2223 f \u2192 g \u2223 f.mirror \u2192 IsUnit g) : Irreducible f", "start": [219, 1], "end": [244, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicTopology/FundamentalGroupoid/Product.lean", "imports": ["Mathlib/CategoryTheory/Groupoid.lean", "Mathlib/Topology/Homotopy/Product.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/AlgebraicTopology/FundamentalGroupoid/Basic.lean", "Mathlib/Topology/Category/TopCat/Limits/Products.lean"], "premises": [{"full_name": "FundamentalGroupoidFunctor.proj", "code": "def proj (i : I) : \u03c0\u2093 (TopCat.of (\u2200 i, X i)) \u2964 \u03c0\u2093 (X i) :=\n  \u03c0\u2098 \u27e8_, continuous_apply i\u27e9", "start": [44, 1], "end": [47, 29], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.proj_map", "code": "@[simp]\ntheorem proj_map (i : I) (x\u2080 x\u2081 : \u03c0\u2093 (TopCat.of (\u2200 i, X i))) (p : x\u2080 \u27f6 x\u2081) :\n    (proj X i).map p = @Path.Homotopic.proj _ _ _ _ _ i p", "start": [50, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.piToPiTop", "code": "@[simps]\ndef piToPiTop : (\u2200 i, \u03c0\u2093 (X i)) \u2964 \u03c0\u2093 (TopCat.of (\u2200 i, X i)) where\n  obj g := g\n  map p := Path.Homotopic.pi p\n  map_id x := by\n    change (Path.Homotopic.pi fun i => \ud835\udfd9 (x i)) = _\n    simp only [FundamentalGroupoid.id_eq_path_refl, Path.Homotopic.pi_lift]\n    rfl\n  map_comp f g := (Path.Homotopic.comp_pi_eq_pi_comp f g).symm", "start": [60, 1], "end": [71, 63], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.piIso", "code": "@[simps]\ndef piIso : CategoryTheory.Grpd.of (\u2200 i : I, \u03c0\u2093 (X i)) \u2245 \u03c0\u2093 (TopCat.of (\u2200 i, X i)) where\n  hom := piToPiTop X\n  inv := CategoryTheory.Functor.pi' (proj X)\n  hom_inv_id := by\n    change piToPiTop X \u22d9 CategoryTheory.Functor.pi' (proj X) = \ud835\udfed _\n    apply CategoryTheory.Functor.ext ?_ ?_\n    \u00b7 intros; rfl\n    \u00b7 intros; ext; simp\n  inv_hom_id := by\n    change CategoryTheory.Functor.pi' (proj X) \u22d9 piToPiTop X = \ud835\udfed _\n    apply CategoryTheory.Functor.ext\n    \u00b7 intro _ _ f\n      suffices Path.Homotopic.pi ((CategoryTheory.Functor.pi' (proj X)).map f) = f by simpa\n      change Path.Homotopic.pi (fun i => (CategoryTheory.Functor.pi' (proj X)).map f i) = _\n      simp\n    \u00b7 intros; rfl", "start": [74, 1], "end": [93, 18], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.coneDiscreteComp", "code": "def coneDiscreteComp :\n    Limits.Cone (Discrete.functor X \u22d9 \u03c0) \u224c Limits.Cone (Discrete.functor fun i => \u03c0\u2093 (X i)) :=\n  Limits.Cones.postcomposeEquivalence (Discrete.compNatIsoDiscrete X \u03c0)", "start": [100, 1], "end": [103, 72], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.coneDiscreteComp_obj_mapCone", "code": "theorem coneDiscreteComp_obj_mapCone :\n    (coneDiscreteComp X).functor.obj (Functor.mapCone \u03c0 (TopCat.piFan.{u,u} X)) =\n      Limits.Fan.mk (\u03c0\u2093 (TopCat.of (\u2200 i, X i))) (proj X)", "start": [106, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.piTopToPiCone", "code": "def piTopToPiCone :\n    Limits.Fan.mk (\u03c0\u2093 (TopCat.of (\u2200 i, X i))) (proj X) \u27f6 Grpd.piLimitFan fun i : I => \u03c0\u2093 (X i)\n    where\n  hom := CategoryTheory.Functor.pi' (proj X)", "start": [113, 1], "end": [117, 45], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.preservesProduct", "code": "def preservesProduct : Limits.PreservesLimit (Discrete.functor X) \u03c0 := by\n  apply Limits.preservesLimitOfPreservesLimitCone (TopCat.piFanIsLimit.{u,u} X)\n  apply (Limits.IsLimit.ofConeEquiv (coneDiscreteComp X)).toFun\n  simp only [coneDiscreteComp_obj_mapCone]\n  apply Limits.IsLimit.ofIsoLimit _ (asIso (piTopToPiCone X)).symm\n  exact Grpd.piLimitFanIsLimit _", "start": [124, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.projLeft", "code": "def projLeft : \u03c0\u2093 (TopCat.of (A \u00d7 B)) \u2964 \u03c0\u2093 A :=\n  \u03c0\u2098 \u27e8_, continuous_fst\u27e9", "start": [142, 1], "end": [144, 25], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.projRight", "code": "def projRight : \u03c0\u2093 (TopCat.of (A \u00d7 B)) \u2964 \u03c0\u2093 B :=\n  \u03c0\u2098 \u27e8_, continuous_snd\u27e9", "start": [147, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.projLeft_map", "code": "@[simp]\ntheorem projLeft_map (x\u2080 x\u2081 : \u03c0\u2093 (TopCat.of (A \u00d7 B))) (p : x\u2080 \u27f6 x\u2081) :\n    (projLeft A B).map p = Path.Homotopic.projLeft p", "start": [152, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.projRight_map", "code": "@[simp]\ntheorem projRight_map (x\u2080 x\u2081 : \u03c0\u2093 (TopCat.of (A \u00d7 B))) (p : x\u2080 \u27f6 x\u2081) :\n    (projRight A B).map p = Path.Homotopic.projRight p", "start": [158, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.prodToProdTop", "code": "@[simps obj]\ndef prodToProdTop : \u03c0\u2093 A \u00d7 \u03c0\u2093 B \u2964 \u03c0\u2093 (TopCat.of (A \u00d7 B)) where\n  obj g := g\n  map {x y} p :=\n    match x, y, p with\n    | (x\u2080, x\u2081), (y\u2080, y\u2081), (p\u2080, p\u2081) => @Path.Homotopic.prod _ _ (_) (_) _ _ _ _ p\u2080 p\u2081\n  map_id := by\n    rintro \u27e8x\u2080, x\u2081\u27e9\n    simp only [CategoryTheory.prod_id, FundamentalGroupoid.id_eq_path_refl]\n    rfl\n  map_comp {x y z} f g :=\n    match x, y, z, f, g with\n    | (x\u2080, x\u2081), (y\u2080, y\u2081), (z\u2080, z\u2081), (f\u2080, f\u2081), (g\u2080, g\u2081) =>\n      (Path.Homotopic.comp_prod_eq_prod_comp f\u2080 f\u2081 g\u2080 g\u2081).symm", "start": [164, 1], "end": [181, 63], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.prodToProdTop_map", "code": "theorem prodToProdTop_map {x\u2080 x\u2081 : \u03c0\u2093 A} {y\u2080 y\u2081 : \u03c0\u2093 B} (p\u2080 : x\u2080 \u27f6 x\u2081) (p\u2081 : y\u2080 \u27f6 y\u2081) :\n    (prodToProdTop A B).map (X := (x\u2080, y\u2080)) (Y := (x\u2081, y\u2081)) (p\u2080, p\u2081) =\n      Path.Homotopic.prod p\u2080 p\u2081", "start": [184, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "FundamentalGroupoidFunctor.prodIso", "code": "@[simps]\ndef prodIso : CategoryTheory.Grpd.of (\u03c0\u2093 A \u00d7 \u03c0\u2093 B) \u2245 \u03c0\u2093 (TopCat.of (A \u00d7 B)) where\n  hom := prodToProdTop A B\n  inv := (projLeft A B).prod' (projRight A B)\n  hom_inv_id := by\n    change prodToProdTop A B \u22d9 (projLeft A B).prod' (projRight A B) = \ud835\udfed _\n    apply CategoryTheory.Functor.hext; \u00b7 intros; ext <;> simp <;> rfl\n    rintro \u27e8x\u2080, x\u2081\u27e9 \u27e8y\u2080, y\u2081\u27e9 \u27e8f\u2080, f\u2081\u27e9\n    have : Path.Homotopic.projLeft ((prodToProdTop A B).map (f\u2080, f\u2081)) = f\u2080 \u2227\n      Path.Homotopic.projRight ((prodToProdTop A B).map (f\u2080, f\u2081)) = f\u2081 :=\n        And.intro (Path.Homotopic.projLeft_prod f\u2080 f\u2081) (Path.Homotopic.projRight_prod f\u2080 f\u2081)\n    simpa\n  inv_hom_id := by\n    change (projLeft A B).prod' (projRight A B) \u22d9 prodToProdTop A B = \ud835\udfed _\n    apply CategoryTheory.Functor.hext\n    \u00b7 intros; apply Prod.ext <;> simp <;> rfl\n    rintro \u27e8x\u2080, x\u2081\u27e9 \u27e8y\u2080, y\u2081\u27e9 f\n    have := Path.Homotopic.prod_projLeft_projRight f\n    simp only [CategoryTheory.Functor.comp_obj, CategoryTheory.Functor.prod'_obj, prodToProdTop_obj,\n      CategoryTheory.Functor.comp_map, CategoryTheory.Functor.prod'_map, projLeft_map,\n      projRight_map, CategoryTheory.Functor.id_obj, CategoryTheory.Functor.id_map, heq_eq_eq]\n    apply this", "start": [190, 1], "end": [215, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Spectrum.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Diagonal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Matrix/Rank.lean", "Mathlib/LinearAlgebra/Matrix/Hermitian.lean", "Mathlib/Analysis/InnerProductSpace/Spectrum.lean"], "premises": [{"full_name": "Matrix.IsHermitian.eigenvalues\u2080", "code": "noncomputable def eigenvalues\u2080 : Fin (Fintype.card n) \u2192 \u211d :=\n  (isHermitian_iff_isSymmetric.1 hA).eigenvalues finrank_euclideanSpace", "start": [39, 1], "end": [42, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvalues", "code": "noncomputable def eigenvalues : n \u2192 \u211d := fun i =>\n  hA.eigenvalues\u2080 <| (Fintype.equivOfCardEq (Fintype.card_fin _)).symm i", "start": [45, 1], "end": [47, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorBasis", "code": "noncomputable def eigenvectorBasis : OrthonormalBasis n \ud835\udd5c (EuclideanSpace \ud835\udd5c n) :=\n  ((isHermitian_iff_isSymmetric.1 hA).eigenvectorBasis finrank_euclideanSpace).reindex\n    (Fintype.equivOfCardEq (Fintype.card_fin _))", "start": [50, 1], "end": [53, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorMatrix", "code": "noncomputable def eigenvectorMatrix : Matrix n n \ud835\udd5c :=\n  (PiLp.basisFun _ \ud835\udd5c n).toMatrix (eigenvectorBasis hA).toBasis", "start": [56, 1], "end": [58, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorMatrixInv", "code": "noncomputable def eigenvectorMatrixInv : Matrix n n \ud835\udd5c :=\n  (eigenvectorBasis hA).toBasis.toMatrix (PiLp.basisFun _ \ud835\udd5c n)", "start": [61, 1], "end": [63, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorMatrix_mul_inv", "code": "theorem eigenvectorMatrix_mul_inv : hA.eigenvectorMatrix * hA.eigenvectorMatrixInv = 1", "start": [66, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorMatrix_apply", "code": "theorem eigenvectorMatrix_apply (i j : n) : hA.eigenvectorMatrix i j = hA.eigenvectorBasis j i", "start": [76, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.transpose_eigenvectorMatrix_apply", "code": "theorem transpose_eigenvectorMatrix_apply (i : n) :\n    hA.eigenvectorMatrix\u1d40 i = hA.eigenvectorBasis i", "start": [81, 1], "end": [84, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvectorMatrixInv_apply", "code": "theorem eigenvectorMatrixInv_apply (i j : n) :\n    hA.eigenvectorMatrixInv i j = star (hA.eigenvectorBasis i j)", "start": [86, 1], "end": [90, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.conjTranspose_eigenvectorMatrixInv", "code": "theorem conjTranspose_eigenvectorMatrixInv : hA.eigenvectorMatrixInv\u1d34 = hA.eigenvectorMatrix", "start": [93, 1], "end": [95, 91], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.conjTranspose_eigenvectorMatrix", "code": "theorem conjTranspose_eigenvectorMatrix : hA.eigenvectorMatrix\u1d34 = hA.eigenvectorMatrixInv", "start": [98, 1], "end": [99, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.spectral_theorem", "code": "theorem spectral_theorem :\n    hA.eigenvectorMatrixInv * A = diagonal ((\u2191) \u2218 hA.eigenvalues) * hA.eigenvectorMatrixInv", "start": [102, 1], "end": [121, 98], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.eigenvalues_eq", "code": "theorem eigenvalues_eq (i : n) :\n    hA.eigenvalues i =\n      IsROrC.re (star (hA.eigenvectorMatrix\u1d40 i) \u2b1d\u1d65 A.mulVec (hA.eigenvectorMatrix\u1d40 i))", "start": [124, 1], "end": [133, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.det_eq_prod_eigenvalues", "code": "theorem det_eq_prod_eigenvalues : det A = \u220f i, (hA.eigenvalues i : \ud835\udd5c)", "start": [136, 1], "end": [140, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsHermitian.spectral_theorem'", "code": "lemma spectral_theorem' :\n    A = hA.eigenvectorMatrix * diagonal ((\u2191) \u2218 hA.eigenvalues) * hA.eigenvectorMatrixInv := by\n  simpa [ \u2190 Matrix.mul_assoc, hA.eigenvectorMatrix_mul_inv, Matrix.one_mul] using\n    congr_arg (hA.eigenvectorMatrix * \u00b7) hA.spectral_theorem", "start": [143, 1], "end": [149, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.IsHermitian.rank_eq_rank_diagonal", "code": "lemma rank_eq_rank_diagonal : A.rank = (Matrix.diagonal hA.eigenvalues).rank := by\n  conv_lhs => rw [hA.spectral_theorem']\n  have hE := isUnit_det_of_invertible (hA.eigenvectorMatrix)\n  have hiE := isUnit_det_of_invertible (hA.eigenvectorMatrixInv)\n  simp only [rank_mul_eq_right_of_isUnit_det hA.eigenvectorMatrix _ hE,\n    rank_mul_eq_left_of_isUnit_det hA.eigenvectorMatrixInv _ hiE,\n    rank_diagonal, Function.comp_apply, ne_eq, algebraMap.lift_map_eq_zero_iff]", "start": [151, 1], "end": [158, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.IsHermitian.rank_eq_card_non_zero_eigs", "code": "lemma rank_eq_card_non_zero_eigs : A.rank = Fintype.card {i // hA.eigenvalues i \u2260 0} := by\n  rw [rank_eq_rank_diagonal hA, Matrix.rank_diagonal]", "start": [160, 1], "end": [162, 54], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Nat/Choose/Central.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Data/Nat/GCD/Basic.lean"], "premises": [{"full_name": "Nat.centralBinom", "code": "def centralBinom (n : \u2115) :=\n  (2 * n).choose n", "start": [32, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.centralBinom_eq_two_mul_choose", "code": "theorem centralBinom_eq_two_mul_choose (n : \u2115) : centralBinom n = (2 * n).choose n", "start": [38, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.centralBinom_pos", "code": "theorem centralBinom_pos (n : \u2115) : 0 < centralBinom n", "start": [42, 1], "end": [43, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.centralBinom_ne_zero", "code": "theorem centralBinom_ne_zero (n : \u2115) : centralBinom n \u2260 0", "start": [46, 1], "end": [47, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.centralBinom_zero", "code": "@[simp]\ntheorem centralBinom_zero : centralBinom 0 = 1", "start": [50, 1], "end": [52, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_centralBinom", "code": "theorem choose_le_centralBinom (r n : \u2115) : choose (2 * n) r \u2264 centralBinom n", "start": [55, 1], "end": [60, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.two_le_centralBinom", "code": "theorem two_le_centralBinom (n : \u2115) (n_pos : 0 < n) : 2 \u2264 centralBinom n", "start": [63, 1], "end": [67, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul_centralBinom_succ", "code": "theorem succ_mul_centralBinom_succ (n : \u2115) :\n    (n + 1) * centralBinom (n + 1) = 2 * (2 * n + 1) * centralBinom n", "start": [70, 1], "end": [81, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.four_pow_lt_mul_centralBinom", "code": "theorem four_pow_lt_mul_centralBinom (n : \u2115) (n_big : 4 \u2264 n) : 4 ^ n < n * centralBinom n", "start": [84, 1], "end": [98, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.four_pow_le_two_mul_self_mul_centralBinom", "code": "theorem four_pow_le_two_mul_self_mul_centralBinom :\n    \u2200 (n : \u2115) (_ : 0 < n), 4 ^ n \u2264 2 * n * centralBinom n", "start": [101, 1], "end": [115, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.two_dvd_centralBinom_succ", "code": "theorem two_dvd_centralBinom_succ (n : \u2115) : 2 \u2223 centralBinom (n + 1)", "start": [118, 1], "end": [121, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.two_dvd_centralBinom_of_one_le", "code": "theorem two_dvd_centralBinom_of_one_le {n : \u2115} (h : 0 < n) : 2 \u2223 centralBinom n", "start": [124, 1], "end": [126, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_dvd_centralBinom", "code": "theorem succ_dvd_centralBinom (n : \u2115) : n + 1 \u2223 n.centralBinom", "start": [129, 1], "end": [138, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Slice.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Order/Antichain.lean", "Mathlib/Data/Nat/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Sized", "code": "def Sized (r : \u2115) (A : Set (Finset \u03b1)) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 A \u2192 card x = r", "start": [45, 1], "end": [47, 28], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.mono", "code": "theorem Sized.mono (h : A \u2286 B) (hB : B.Sized r) : A.Sized r", "start": [50, 1], "end": [50, 87], "kind": "commanddeclaration"}, {"full_name": "Set.sized_empty", "code": "@[simp] lemma sized_empty : (\u2205 : Set (Finset \u03b1)).Sized r := by simp [Sized]", "start": [53, 1], "end": [53, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sized_singleton", "code": "@[simp] lemma sized_singleton : ({s} : Set (Finset \u03b1)).Sized r \u2194 s.card = r := by simp [Sized]", "start": [54, 1], "end": [54, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sized_union", "code": "theorem sized_union : (A \u222a B).Sized r \u2194 A.Sized r \u2227 B.Sized r", "start": [56, 1], "end": [58, 47], "kind": "commanddeclaration"}, {"full_name": "Set.sized.union", "code": "alias \u27e8_, sized.union\u27e9 := sized_union", "start": [61, 1], "end": [61, 38], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.sized_iUnion", "code": "@[simp]\ntheorem sized_iUnion {f : \u03b9 \u2192 Set (Finset \u03b1)} : (\u22c3 i, f i).Sized r \u2194 \u2200 i, (f i).Sized r", "start": [65, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sized_iUnion\u2082", "code": "theorem sized_iUnion\u2082 {f : \u2200 i, \u03ba i \u2192 Set (Finset \u03b1)} :\n    (\u22c3 (i) (j), f i j).Sized r \u2194 \u2200 i j, (f i j).Sized r", "start": [72, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.isAntichain", "code": "protected theorem Sized.isAntichain (hA : A.Sized r) : IsAntichain (\u00b7 \u2286 \u00b7) A", "start": [77, 1], "end": [78, 99], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.subsingleton", "code": "protected theorem Sized.subsingleton (hA : A.Sized 0) : A.Subsingleton", "start": [81, 1], "end": [82, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.subsingleton'", "code": "theorem Sized.subsingleton' [Fintype \u03b1] (hA : A.Sized (Fintype.card \u03b1)) : A.Subsingleton", "start": [85, 1], "end": [86, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.empty_mem_iff", "code": "theorem Sized.empty_mem_iff (hA : A.Sized r) : \u2205 \u2208 A \u2194 A = {\u2205}", "start": [89, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.univ_mem_iff", "code": "theorem Sized.univ_mem_iff [Fintype \u03b1] (hA : A.Sized r) : Finset.univ \u2208 A \u2194 A = {Finset.univ}", "start": [93, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "Set.sized_powersetCard", "code": "theorem sized_powersetCard (s : Finset \u03b1) (r : \u2115) : (powersetCard r s : Set (Finset \u03b1)).Sized r", "start": [97, 1], "end": [98, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_powersetCard_univ_iff", "code": "theorem subset_powersetCard_univ_iff : \ud835\udc9c \u2286 powersetCard r univ \u2194 (\ud835\udc9c : Set (Finset \u03b1)).Sized r", "start": [109, 1], "end": [110, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Sized.subset_powersetCard_univ", "code": "alias \u27e8_, _root_.Set.Sized.subset_powersetCard_univ\u27e9 := subset_powersetCard_univ_iff", "start": [113, 1], "end": [113, 85], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Sized.card_le", "code": "theorem _root_.Set.Sized.card_le (h\ud835\udc9c : (\ud835\udc9c : Set (Finset \u03b1)).Sized r) :\n    card \ud835\udc9c \u2264 (Fintype.card \u03b1).choose r", "start": [116, 1], "end": [119, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.slice", "code": "def slice (\ud835\udc9c : Finset (Finset \u03b1)) (r : \u2115) : Finset (Finset \u03b1) :=\n  \ud835\udc9c.filter fun i => i.card = r", "start": [131, 1], "end": [133, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_slice", "code": "theorem mem_slice : A \u2208 \ud835\udc9c # r \u2194 A \u2208 \ud835\udc9c \u2227 A.card = r", "start": [141, 1], "end": [143, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.slice_subset", "code": "theorem slice_subset : \ud835\udc9c # r \u2286 \ud835\udc9c", "start": [146, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sized_slice", "code": "theorem sized_slice : (\ud835\udc9c # r : Set (Finset \u03b1)).Sized r", "start": [151, 1], "end": [152, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_mem_slice", "code": "theorem eq_of_mem_slice (h\u2081 : A \u2208 \ud835\udc9c # r\u2081) (h\u2082 : A \u2208 \ud835\udc9c # r\u2082) : r\u2081 = r\u2082", "start": [155, 1], "end": [156, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.ne_of_mem_slice", "code": "theorem ne_of_mem_slice (h\u2081 : A\u2081 \u2208 \ud835\udc9c # r\u2081) (h\u2082 : A\u2082 \u2208 \ud835\udc9c # r\u2082) : r\u2081 \u2260 r\u2082 \u2192 A\u2081 \u2260 A\u2082", "start": [159, 1], "end": [161, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwiseDisjoint_slice", "code": "theorem pairwiseDisjoint_slice : (Set.univ : Set \u2115).PairwiseDisjoint (slice \ud835\udc9c)", "start": [164, 1], "end": [165, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_slice", "code": "@[simp]\ntheorem biUnion_slice [DecidableEq \u03b1] : (Iic <| Fintype.card \u03b1).biUnion \ud835\udc9c.slice = \ud835\udc9c", "start": [170, 1], "end": [173, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_slice", "code": "@[simp]\ntheorem sum_card_slice : (\u2211 r in Iic (Fintype.card \u03b1), (\ud835\udc9c # r).card) = \ud835\udc9c.card", "start": [176, 1], "end": [180, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/Kernel/Disintegration.lean", "imports": ["Mathlib/Probability/Kernel/IntegralCompProd.lean", "Mathlib/MeasureTheory/Constructions/Polish.lean", "Mathlib/Probability/Kernel/CondCdf.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.condKernelReal", "code": "noncomputable def condKernelReal (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) : kernel \u03b1 \u211d where\n  val a := (condCdf \u03c1 a).measure\n  property := measurable_measure_condCdf \u03c1", "start": [63, 1], "end": [67, 43], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.condKernelReal_Iic", "code": "theorem condKernelReal_Iic (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) (a : \u03b1) (x : \u211d) :\n    condKernelReal \u03c1 a (Iic x) = ENNReal.ofReal (condCdf \u03c1 a x)", "start": [73, 1], "end": [75, 28], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernelReal_Iic", "code": "theorem set_lintegral_condKernelReal_Iic (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1] (x : \u211d)\n    {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u222b\u207b a in s, condKernelReal \u03c1 a (Iic x) \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 Iic x)", "start": [78, 1], "end": [81, 67], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernelReal_univ", "code": "theorem set_lintegral_condKernelReal_univ (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u222b\u207b a in s, condKernelReal \u03c1 a univ \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 univ)", "start": [84, 1], "end": [87, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condKernelReal_univ", "code": "theorem lintegral_condKernelReal_univ (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) :\n    \u222b\u207b a, condKernelReal \u03c1 a univ \u2202\u03c1.fst = \u03c1 univ", "start": [90, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernelReal_prod", "code": "theorem set_lintegral_condKernelReal_prod {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u211d}\n    (ht : MeasurableSet t) : \u222b\u207b a in s, condKernelReal \u03c1 a t \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 t)", "start": [98, 1], "end": [133, 55], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condKernelReal_mem", "code": "theorem lintegral_condKernelReal_mem {s : Set (\u03b1 \u00d7 \u211d)} (hs : MeasurableSet s) :\n    \u222b\u207b a, condKernelReal \u03c1 a {x | (a, x) \u2208 s} \u2202\u03c1.fst = \u03c1 s", "start": [136, 1], "end": [208, 64], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.const_eq_compProd_real", "code": "theorem kernel.const_eq_compProd_real (\u03b3 : Type*) [MeasurableSpace \u03b3] (\u03c1 : Measure (\u03b1 \u00d7 \u211d))\n    [IsFiniteMeasure \u03c1] :\n    kernel.const \u03b3 \u03c1 = kernel.const \u03b3 \u03c1.fst \u2297\u2096 kernel.prodMkLeft \u03b3 (condKernelReal \u03c1)", "start": [211, 1], "end": [217, 41], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_eq_compProd_real", "code": "theorem measure_eq_compProd_real :\n    \u03c1 = (kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit (condKernelReal \u03c1)) ()", "start": [220, 1], "end": [222, 66], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condKernelReal", "code": "theorem lintegral_condKernelReal {f : \u03b1 \u00d7 \u211d \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, \u222b\u207b y, f (a, y) \u2202condKernelReal \u03c1 a \u2202\u03c1.fst = \u222b\u207b x, f x \u2202\u03c1", "start": [225, 1], "end": [229, 36], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.ae_condKernelReal_eq_one", "code": "theorem ae_condKernelReal_eq_one {s : Set \u211d} (hs : MeasurableSet s) (h\u03c1 : \u03c1 {x | x.snd \u2208 s\u1d9c} = 0) :\n    \u2200\u1d50 a \u2202\u03c1.fst, condKernelReal \u03c1 a s = 1", "start": [232, 1], "end": [248, 40], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.exists_cond_kernel", "code": "theorem exists_cond_kernel (\u03b3 : Type*) [MeasurableSpace \u03b3] :\n    \u2203 (\u03b7 : kernel \u03b1 \u03a9) (_h : IsMarkovKernel \u03b7), kernel.const \u03b3 \u03c1 =\n      kernel.compProd (kernel.const \u03b3 \u03c1.fst) (kernel.prodMkLeft \u03b3 \u03b7)", "start": [264, 1], "end": [343, 14], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Measure.condKernel", "code": "noncomputable irreducible_def _root_.MeasureTheory.Measure.condKernel : kernel \u03b1 \u03a9 :=\n  (exists_cond_kernel \u03c1 Unit).choose", "start": [346, 1], "end": [350, 37], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "ProbabilityTheory.condKernel_def", "code": "theorem condKernel_def : \u03c1.condKernel = (exists_cond_kernel \u03c1 Unit).choose", "start": [353, 1], "end": [354, 40], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.const_unit_eq_compProd", "code": "theorem kernel.const_unit_eq_compProd :\n    kernel.const Unit \u03c1 = kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit \u03c1.condKernel", "start": [360, 1], "end": [362, 86], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.measure_eq_compProd", "code": "theorem measure_eq_compProd :\n    \u03c1 = (kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit \u03c1.condKernel) ()", "start": [365, 1], "end": [371, 59], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.kernel.const_eq_compProd", "code": "theorem kernel.const_eq_compProd (\u03b3 : Type*) [MeasurableSpace \u03b3] (\u03c1 : Measure (\u03b1 \u00d7 \u03a9))\n    [IsFiniteMeasure \u03c1] :\n    kernel.const \u03b3 \u03c1 = kernel.const \u03b3 \u03c1.fst \u2297\u2096 kernel.prodMkLeft \u03b3 \u03c1.condKernel", "start": [374, 1], "end": [383, 65], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condKernel_mem", "code": "theorem lintegral_condKernel_mem {s : Set (\u03b1 \u00d7 \u03a9)} (hs : MeasurableSet s) :\n    \u222b\u207b a, \u03c1.condKernel a {x | (a, x) \u2208 s} \u2202\u03c1.fst = \u03c1 s", "start": [386, 1], "end": [389, 88], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernel_eq_measure_prod", "code": "theorem set_lintegral_condKernel_eq_measure_prod {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u03a9}\n    (ht : MeasurableSet t) : \u222b\u207b a in s, \u03c1.condKernel a t \u2202\u03c1.fst = \u03c1 (s \u00d7\u02e2 t)", "start": [392, 1], "end": [406, 72], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.lintegral_condKernel", "code": "theorem lintegral_condKernel {f : \u03b1 \u00d7 \u03a9 \u2192 \u211d\u22650\u221e} (hf : Measurable f) :\n    \u222b\u207b a, \u222b\u207b \u03c9, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b\u207b x, f x \u2202\u03c1", "start": [409, 1], "end": [413, 36], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernel", "code": "theorem set_lintegral_condKernel {f : \u03b1 \u00d7 \u03a9 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1}\n    (hs : MeasurableSet s) {t : Set \u03a9} (ht : MeasurableSet t) :\n    \u222b\u207b a in s, \u222b\u207b \u03c9 in t, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b\u207b x in s \u00d7\u02e2 t, f x \u2202\u03c1", "start": [416, 1], "end": [422, 63], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernel_univ_right", "code": "theorem set_lintegral_condKernel_univ_right {f : \u03b1 \u00d7 \u03a9 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {s : Set \u03b1}\n    (hs : MeasurableSet s) :\n    \u222b\u207b a in s, \u222b\u207b \u03c9, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b\u207b x in s \u00d7\u02e2 univ, f x \u2202\u03c1", "start": [425, 1], "end": [428, 94], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_lintegral_condKernel_univ_left", "code": "theorem set_lintegral_condKernel_univ_left {f : \u03b1 \u00d7 \u03a9 \u2192 \u211d\u22650\u221e} (hf : Measurable f) {t : Set \u03a9}\n    (ht : MeasurableSet t) :\n    \u222b\u207b a, \u222b\u207b \u03c9 in t, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b\u207b x in univ \u00d7\u02e2 t, f x \u2202\u03c1", "start": [431, 1], "end": [434, 94], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.integral_condKernel", "code": "theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condKernel {\u03c1 : Measure (\u03b1 \u00d7 \u03a9)}\n    [IsFiniteMeasure \u03c1] {f : \u03b1 \u00d7 \u03a9 \u2192 E} (hf : AEStronglyMeasurable f \u03c1) :\n    AEStronglyMeasurable (fun x => \u222b y, f (x, y) \u2202\u03c1.condKernel x) \u03c1.fst", "start": [441, 1], "end": [445, 57], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.integral_condKernel", "code": "theorem integral_condKernel {\u03c1 : Measure (\u03b1 \u00d7 \u03a9)} [IsFiniteMeasure \u03c1] {f : \u03b1 \u00d7 \u03a9 \u2192 E}\n    (hf : Integrable f \u03c1) : \u222b a, \u222b x, f (a, x) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b \u03c9, f \u03c9 \u2202\u03c1", "start": [448, 1], "end": [454, 36], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_condKernel", "code": "theorem set_integral_condKernel {\u03c1 : Measure (\u03b1 \u00d7 \u03a9)} [IsFiniteMeasure \u03c1] {f : \u03b1 \u00d7 \u03a9 \u2192 E}\n    {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u03a9} (ht : MeasurableSet t)\n    (hf : IntegrableOn f (s \u00d7\u02e2 t) \u03c1) :\n    \u222b a in s, \u222b \u03c9 in t, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b x in s \u00d7\u02e2 t, f x \u2202\u03c1", "start": [457, 1], "end": [464, 38], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_condKernel_univ_right", "code": "theorem set_integral_condKernel_univ_right {\u03c1 : Measure (\u03b1 \u00d7 \u03a9)} [IsFiniteMeasure \u03c1] {f : \u03b1 \u00d7 \u03a9 \u2192 E}\n    {s : Set \u03b1} (hs : MeasurableSet s) (hf : IntegrableOn f (s \u00d7\u02e2 univ) \u03c1) :\n    \u222b a in s, \u222b \u03c9, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b x in s \u00d7\u02e2 univ, f x \u2202\u03c1", "start": [467, 1], "end": [470, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.set_integral_condKernel_univ_left", "code": "theorem set_integral_condKernel_univ_left {\u03c1 : Measure (\u03b1 \u00d7 \u03a9)} [IsFiniteMeasure \u03c1] {f : \u03b1 \u00d7 \u03a9 \u2192 E}\n    {t : Set \u03a9} (ht : MeasurableSet t) (hf : IntegrableOn f (univ \u00d7\u02e2 t) \u03c1) :\n    \u222b a, \u222b \u03c9 in t, f (a, \u03c9) \u2202\u03c1.condKernel a \u2202\u03c1.fst = \u222b x in univ \u00d7\u02e2 t, f x \u2202\u03c1", "start": [473, 1], "end": [476, 91], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.eq_condKernel_of_measure_eq_compProd'", "code": "theorem eq_condKernel_of_measure_eq_compProd' (\u03ba : kernel \u03b1 \u03a9) [IsSFiniteKernel \u03ba]\n    (h\u03ba : \u03c1 = (kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit \u03ba) ())\n    {s : Set \u03a9} (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202\u03c1.fst, \u03ba x s = \u03c1.condKernel x s", "start": [487, 1], "end": [505, 22], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.eq_condKernel_of_measure_eq_compProd_real", "code": "lemma eq_condKernel_of_measure_eq_compProd_real (\u03c1 : Measure (\u03b1 \u00d7 \u211d)) [IsFiniteMeasure \u03c1]\n    (\u03ba : kernel \u03b1 \u211d) [IsFiniteKernel \u03ba]\n    (h\u03ba : \u03c1 = (kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit \u03ba) ()) :\n    \u2200\u1d50 x \u2202\u03c1.fst, \u03ba x = \u03c1.condKernel x := by\n  have huniv : \u2200\u1d50 x \u2202\u03c1.fst, \u03ba x Set.univ = \u03c1.condKernel x Set.univ :=\n    eq_condKernel_of_measure_eq_compProd' \u03c1 \u03ba h\u03ba MeasurableSet.univ\n  suffices : \u2200\u1d50 x \u2202\u03c1.fst, \u2200 \u2983t\u2984, MeasurableSet t \u2192 \u03ba x t = \u03c1.condKernel x t\n  \u00b7 filter_upwards [this] with x hx\n    ext t ht; exact hx ht\n  apply MeasurableSpace.ae_induction_on_inter Real.borel_eq_generateFrom_Iic_rat\n    Real.isPiSystem_Iic_rat\n  \u00b7 simp only [OuterMeasure.empty', Filter.eventually_true]\n  \u00b7 simp only [iUnion_singleton_eq_range, mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n    exact ae_all_iff.2 <| fun q => eq_condKernel_of_measure_eq_compProd' \u03c1 \u03ba h\u03ba measurableSet_Iic\n  \u00b7 filter_upwards [huniv] with x hxuniv t ht heq\n    rw [measure_compl ht <| measure_ne_top _ _, heq, hxuniv, measure_compl ht <| measure_ne_top _ _]\n  \u00b7 refine' ae_of_all _ (fun x f hdisj hf heq => _)\n    rw [measure_iUnion hdisj hf, measure_iUnion hdisj hf]\n    exact tsum_congr heq", "start": [508, 1], "end": [526, 25], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.eq_condKernel_of_measure_eq_compProd", "code": "theorem eq_condKernel_of_measure_eq_compProd (\u03ba : kernel \u03b1 \u03a9) [IsFiniteKernel \u03ba]\n    (h\u03ba : \u03c1 = (kernel.const Unit \u03c1.fst \u2297\u2096 kernel.prodMkLeft Unit \u03ba) ()) :\n    \u2200\u1d50 x \u2202\u03c1.fst, \u03ba x = \u03c1.condKernel x", "start": [528, 1], "end": [592, 50], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.ae_integrable_condKernel_iff", "code": "theorem AEStronglyMeasurable.ae_integrable_condKernel_iff {f : \u03b1 \u00d7 \u03a9 \u2192 F}\n    (hf : AEStronglyMeasurable f \u03c1) :\n    (\u2200\u1d50 a \u2202\u03c1.fst, Integrable (fun \u03c9 => f (a, \u03c9)) (\u03c1.condKernel a)) \u2227\n      Integrable (fun a => \u222b \u03c9, \u2016f (a, \u03c9)\u2016 \u2202\u03c1.condKernel a) \u03c1.fst \u2194 Integrable f \u03c1", "start": [613, 1], "end": [620, 56], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.condKernel_ae", "code": "theorem Integrable.condKernel_ae {f : \u03b1 \u00d7 \u03a9 \u2192 F} (hf_int : Integrable f \u03c1) :\n    \u2200\u1d50 a \u2202\u03c1.fst, Integrable (fun \u03c9 => f (a, \u03c9)) (\u03c1.condKernel a)", "start": [623, 1], "end": [627, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_norm_condKernel", "code": "theorem Integrable.integral_norm_condKernel {f : \u03b1 \u00d7 \u03a9 \u2192 F} (hf_int : Integrable f \u03c1) :\n    Integrable (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03c1.condKernel x) \u03c1.fst", "start": [630, 1], "end": [634, 17], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.norm_integral_condKernel", "code": "theorem Integrable.norm_integral_condKernel {f : \u03b1 \u00d7 \u03a9 \u2192 E} (hf_int : Integrable f \u03c1) :\n    Integrable (fun x => \u2016\u222b y, f (x, y) \u2202\u03c1.condKernel x\u2016) \u03c1.fst", "start": [637, 1], "end": [643, 76], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.Integrable.integral_condKernel", "code": "theorem Integrable.integral_condKernel {f : \u03b1 \u00d7 \u03a9 \u2192 E} (hf_int : Integrable f \u03c1) :\n    Integrable (fun x => \u222b y, f (x, y) \u2202\u03c1.condKernel x) \u03c1.fst", "start": [646, 1], "end": [648, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Algebra/Ring/Basic.lean", "imports": ["Mathlib/ModelTheory/Semantics.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/ModelTheory/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.ringFunc", "code": "inductive ringFunc : \u2115 \u2192 Type\n  | add : ringFunc 2\n  | mul : ringFunc 2\n  | neg : ringFunc 1\n  | zero : ringFunc 0\n  | one : ringFunc 0\n  deriving DecidableEq", "start": [50, 1], "end": [58, 23], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.ring", "code": "def Language.ring : Language :=\n  { Functions := ringFunc\n    Relations := fun _ => Empty }", "start": [60, 1], "end": [63, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.addFunc", "code": "abbrev addFunc : Language.ring.Functions 2 := add", "start": [75, 1], "end": [77, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.mulFunc", "code": "abbrev mulFunc : Language.ring.Functions 2 := mul", "start": [79, 1], "end": [81, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.negFunc", "code": "abbrev negFunc : Language.ring.Functions 1 := neg", "start": [83, 1], "end": [85, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.zeroFunc", "code": "abbrev zeroFunc : Language.ring.Functions 0 := zero", "start": [87, 1], "end": [89, 52], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.oneFunc", "code": "abbrev oneFunc : Language.ring.Functions 0 := one", "start": [91, 1], "end": [93, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.zero_def", "code": "theorem zero_def (\u03b1 : Type*) : (0 : Language.ring.Term \u03b1) = Constants.term zeroFunc", "start": [98, 1], "end": [98, 91], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.one_def", "code": "theorem one_def (\u03b1 : Type*) : (1 : Language.ring.Term \u03b1) = Constants.term oneFunc", "start": [103, 1], "end": [103, 89], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.add_def", "code": "theorem add_def (\u03b1 : Type*) (t\u2081 t\u2082 : Language.ring.Term \u03b1) :\n    t\u2081 + t\u2082 = addFunc.apply\u2082 t\u2081 t\u2082", "start": [108, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.mul_def", "code": "theorem mul_def (\u03b1 : Type*) (t\u2081 t\u2082 : Language.ring.Term \u03b1) :\n    t\u2081 * t\u2082 = mulFunc.apply\u2082 t\u2081 t\u2082", "start": [114, 1], "end": [115, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.neg_def", "code": "theorem neg_def (\u03b1 : Type*) (t : Language.ring.Term \u03b1) :\n    -t = negFunc.apply\u2081 t", "start": [120, 1], "end": [121, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.card_ring", "code": "@[simp]\ntheorem card_ring : card Language.ring = 5", "start": [137, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.CompatibleRing", "code": "class CompatibleRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R]\n    extends Language.ring.Structure R where\n  \n  funMap_add : \u2200 x, funMap addFunc x = x 0 + x 1\n  \n  funMap_mul : \u2200 x, funMap mulFunc x = x 0 * x 1\n  \n  funMap_neg : \u2200 x, funMap negFunc x = -x 0\n  \n  funMap_zero : \u2200 x, funMap (zeroFunc : Language.ring.Constants) x = 0\n  \n  funMap_one : \u2200 x, funMap (oneFunc : Language.ring.Constants) x = 1", "start": [144, 1], "end": [169, 69], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_add", "code": "@[simp]\ntheorem realize_add (x y : ring.Term \u03b1) (v : \u03b1 \u2192 R) :\n    Term.realize v (x + y) = Term.realize v x + Term.realize v y", "start": [179, 1], "end": [182, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_mul", "code": "@[simp]\ntheorem realize_mul (x y : ring.Term \u03b1) (v : \u03b1 \u2192 R) :\n    Term.realize v (x * y) = Term.realize v x * Term.realize v y", "start": [184, 1], "end": [187, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_neg", "code": "@[simp]\ntheorem realize_neg (x : ring.Term \u03b1) (v : \u03b1 \u2192 R) :\n    Term.realize v (-x) = -Term.realize v x", "start": [189, 1], "end": [192, 29], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_zero", "code": "@[simp]\ntheorem realize_zero (v : \u03b1 \u2192 R) : Term.realize v (0 : ring.Term \u03b1) = 0", "start": [194, 1], "end": [196, 44], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.realize_one", "code": "@[simp]\ntheorem realize_one (v : \u03b1 \u2192 R) : Term.realize v (1 : ring.Term \u03b1) = 1", "start": [198, 1], "end": [200, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.compatibleRingOfRing", "code": "def compatibleRingOfRing (R : Type*) [Add R] [Mul R] [Neg R] [One R] [Zero R] :\n    CompatibleRing R :=\n  { funMap := fun {n} f =>\n      match n, f with\n      | _, .add => fun x => x 0 + x 1\n      | _, .mul => fun x => x 0 * x 1\n      | _, .neg => fun x => -x 0\n      | _, .zero => fun _ => 0\n      | _, .one => fun _ => 1\n    RelMap := Empty.elim,\n    funMap_add := fun _ => rfl,\n    funMap_mul := fun _ => rfl,\n    funMap_neg := fun _ => rfl,\n    funMap_zero := fun _ => rfl,\n    funMap_one := fun _ => rfl }", "start": [204, 1], "end": [233, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.languageEquivEquivRingEquiv", "code": "def languageEquivEquivRingEquiv {R S : Type*}\n    [NonAssocRing R] [NonAssocRing S]\n    [CompatibleRing R] [CompatibleRing S] :\n    (Language.ring.Equiv R S) \u2243 (R \u2243+* S) :=\n  { toFun := fun f =>\n    { f with\n      map_add' := by\n        intro x y\n        simpa using f.map_fun addFunc ![x, y]\n      map_mul' := by\n        intro x y\n        simpa using f.map_fun mulFunc ![x, y] }\n    invFun := fun f =>\n    { f with\n      map_fun' := fun {n} f => by\n        cases f <;> simp\n      map_rel' := fun {n} f => by cases f },\n    left_inv := fun f => by ext; rfl\n    right_inv := fun f => by ext; rfl }", "start": [235, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.addOfRingStructure", "code": "@[reducible] def addOfRingStructure : Add R :=\n  { add := fun x y => funMap addFunc ![x, y] }", "start": [258, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.mulOfRingStructure", "code": "@[reducible] def mulOfRingStructure : Mul R :=\n  { mul := fun x y => funMap mulFunc ![x, y] }", "start": [265, 1], "end": [270, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.negOfRingStructure", "code": "@[reducible] def negOfRingStructure : Neg R :=\n  { neg := fun x => funMap negFunc ![x] }", "start": [272, 1], "end": [277, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.zeroOfRingStructure", "code": "@[reducible] def zeroOfRingStructure : Zero R :=\n  { zero := funMap zeroFunc ![] }", "start": [279, 1], "end": [284, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.oneOfRingStructure", "code": "@[reducible] def oneOfRingStructure : One R :=\n  { one := funMap oneFunc ![] }", "start": [286, 1], "end": [291, 32], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Ring.compatibleRingOfRingStructure", "code": "@[reducible] def compatibleRingOfRingStructure : CompatibleRing R :=\n  { funMap_add := by\n      simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi];\n      intros; rfl\n    funMap_mul := by\n      simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi];\n      intros; rfl\n    funMap_neg := by\n      simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi];\n      intros; rfl\n    funMap_zero := by\n      simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi];\n      intros; rfl\n    funMap_one := by\n      simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi];\n      intros; rfl  }", "start": [296, 1], "end": [318, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/MinimalAxioms.lean", "imports": ["Mathlib/Algebra/Ring/MinimalAxioms.lean", "Mathlib/Algebra/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Field.ofMinimalAxioms", "code": "@[reducible]\ndef Field.ofMinimalAxioms (K : Type u)\n    [Add K] [Mul K] [Neg K] [Inv K] [Zero K] [One K]\n    (add_assoc : \u2200 a b c : K, a + b + c = a + (b + c))\n    (zero_add : \u2200 a : K, 0 + a = a)\n    (add_left_neg : \u2200 a : K, -a + a = 0)\n    (mul_assoc : \u2200 a b c : K, a * b * c = a * (b * c))\n    (mul_comm : \u2200 a b : K, a * b = b * a)\n    (one_mul : \u2200 a : K, 1 * a = a)\n    (mul_inv_cancel : \u2200 a : K, a \u2260 0 \u2192 a * a\u207b\u00b9 = 1)\n    (inv_zero : (0 : K)\u207b\u00b9 = 0)\n    (left_distrib : \u2200 a b c : K, a * (b + c) = a * b + a * c)\n    (exists_pair_ne : \u2203 x y : K, x \u2260 y) : Field K :=\n  letI := CommRing.ofMinimalAxioms add_assoc zero_add\n    add_left_neg mul_assoc mul_comm one_mul left_distrib\n  { exists_pair_ne := exists_pair_ne\n    mul_inv_cancel := mul_inv_cancel\n    inv_zero := inv_zero }", "start": [24, 1], "end": [44, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Limits/Shapes/WideEqualizers.lean", "imports": ["Mathlib/CategoryTheory/Limits/HasLimits.lean", "Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.WalkingParallelFamily", "code": "inductive WalkingParallelFamily (J : Type w) : Type w\n  | zero : WalkingParallelFamily J\n  | one : WalkingParallelFamily J", "start": [57, 1], "end": [60, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelFamily.Hom", "code": "inductive WalkingParallelFamily.Hom (J : Type w) :\n  WalkingParallelFamily J \u2192 WalkingParallelFamily J \u2192 Type w\n  | id : \u2200 X : WalkingParallelFamily.{w} J, WalkingParallelFamily.Hom J X X\n  | line : \u2200 _ : J, WalkingParallelFamily.Hom J zero one\n  deriving DecidableEq", "start": [74, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelFamily.Hom.comp", "code": "def WalkingParallelFamily.Hom.comp :\n    \u2200 {X Y Z : WalkingParallelFamily J} (_ : WalkingParallelFamily.Hom J X Y)\n      (_ : WalkingParallelFamily.Hom J Y Z), WalkingParallelFamily.Hom J X Z\n  | _, _, _, id _, h => h\n  | _, _, _, line j, id one => line j", "start": [89, 1], "end": [94, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelFamily.category", "code": "instance WalkingParallelFamily.category : SmallCategory (WalkingParallelFamily J) where\n  Hom := WalkingParallelFamily.Hom J\n  id := WalkingParallelFamily.Hom.id\n  comp := WalkingParallelFamily.Hom.comp\n  assoc f g h := by cases f <;> cases g <;> cases h <;> aesop_cat\n  comp_id f := by cases f <;> aesop_cat", "start": [101, 1], "end": [106, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.WalkingParallelFamily.hom_id", "code": "@[simp]\ntheorem WalkingParallelFamily.hom_id (X : WalkingParallelFamily J) :\n    WalkingParallelFamily.Hom.id X = \ud835\udfd9 X", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelFamily", "code": "def parallelFamily : WalkingParallelFamily J \u2964 C where\n  obj x := WalkingParallelFamily.casesOn x X Y\n  map {x y} h :=\n    match x, y, h with\n    | _, _, Hom.id _ => \ud835\udfd9 _\n    | _, _, line j => f j\n  map_comp := by\n    rintro _ _ _ \u27e8\u27e9 \u27e8\u27e9 <;>\n      \u00b7 aesop_cat", "start": [123, 1], "end": [134, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelFamily_obj_zero", "code": "@[simp]\ntheorem parallelFamily_obj_zero : (parallelFamily f).obj zero = X", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelFamily_obj_one", "code": "@[simp]\ntheorem parallelFamily_obj_one : (parallelFamily f).obj one = Y", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.parallelFamily_map_left", "code": "@[simp]\ntheorem parallelFamily_map_left {j : J} : (parallelFamily f).map (line j) = f j", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.diagramIsoParallelFamily", "code": "@[simps!]\ndef diagramIsoParallelFamily (F : WalkingParallelFamily J \u2964 C) :\n    F \u2245 parallelFamily fun j => F.map (line j) :=\n  NatIso.ofComponents (fun j => eqToIso <| by cases j <;> aesop_cat) <| by\n    rintro _ _ (_|_) <;> aesop_cat", "start": [154, 1], "end": [160, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.walkingParallelFamilyEquivWalkingParallelPair", "code": "@[simps!]\ndef walkingParallelFamilyEquivWalkingParallelPair :\n    WalkingParallelFamily.{w} (ULift Bool) \u224c WalkingParallelPair where\n  functor :=\n    parallelFamily fun p => cond p.down WalkingParallelPairHom.left WalkingParallelPairHom.right\n  inverse := parallelPair (line (ULift.up true)) (line (ULift.up false))\n  unitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|\u27e8_|_\u27e9) <;> aesop_cat)\n  counitIso := NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)) (by\n    rintro _ _ (_|_|_) <;> aesop_cat)\n  functor_unitIso_comp := by rintro (_|_) <;> aesop_cat", "start": [165, 1], "end": [177, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident", "code": "abbrev Trident :=\n  Cone (parallelFamily f)", "start": [182, 1], "end": [184, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident", "code": "abbrev Cotrident :=\n  Cocone (parallelFamily f)", "start": [187, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.\u03b9", "code": "abbrev Trident.\u03b9 (t : Trident f) :=\n  t.\u03c0.app zero", "start": [194, 1], "end": [198, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.\u03c0", "code": "abbrev Cotrident.\u03c0 (t : Cotrident f) :=\n  t.\u03b9.app one", "start": [201, 1], "end": [205, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.\u03b9_eq_app_zero", "code": "@[simp]\ntheorem Trident.\u03b9_eq_app_zero (t : Trident f) : t.\u03b9 = t.\u03c0.app zero", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.\u03c0_eq_app_one", "code": "@[simp]\ntheorem Cotrident.\u03c0_eq_app_one (t : Cotrident f) : t.\u03c0 = t.\u03b9.app one", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.app_zero", "code": "@[reassoc (attr := simp)]\ntheorem Trident.app_zero (s : Trident f) (j : J) : s.\u03c0.app zero \u226b f j = s.\u03c0.app one", "start": [218, 1], "end": [220, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.app_one", "code": "@[reassoc (attr := simp)]\ntheorem Cotrident.app_one (s : Cotrident f) (j : J) : f j \u226b s.\u03b9.app one = s.\u03b9.app zero", "start": [223, 1], "end": [225, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.of\u03b9", "code": "@[simps]\ndef Trident.of\u03b9 [Nonempty J] {P : C} (\u03b9 : P \u27f6 X) (w : \u2200 j\u2081 j\u2082, \u03b9 \u226b f j\u2081 = \u03b9 \u226b f j\u2082) : Trident f\n    where\n  pt := P\n  \u03c0 :=\n    { app := fun X => WalkingParallelFamily.casesOn X \u03b9 (\u03b9 \u226b f (Classical.arbitrary J))\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        \u00b7 simp\n        \u00b7 simp [w (Classical.arbitrary J) k] }", "start": [228, 1], "end": [241, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.of\u03c0", "code": "@[simps]\ndef Cotrident.of\u03c0 [Nonempty J] {P : C} (\u03c0 : Y \u27f6 P) (w : \u2200 j\u2081 j\u2082, f j\u2081 \u226b \u03c0 = f j\u2082 \u226b \u03c0) :\n    Cotrident f where\n  pt := P\n  \u03b9 :=\n    { app := fun X => WalkingParallelFamily.casesOn X (f (Classical.arbitrary J) \u226b \u03c0) \u03c0\n      naturality := fun i j f => by\n        dsimp\n        cases' f with _ k\n        \u00b7 simp\n        \u00b7 simp [w (Classical.arbitrary J) k] }", "start": [244, 1], "end": [257, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.\u03b9_of\u03b9", "code": "theorem Trident.\u03b9_of\u03b9 [Nonempty J] {P : C} (\u03b9 : P \u27f6 X) (w : \u2200 j\u2081 j\u2082, \u03b9 \u226b f j\u2081 = \u03b9 \u226b f j\u2082) :\n    (Trident.of\u03b9 \u03b9 w).\u03b9 = \u03b9", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.\u03c0_of\u03c0", "code": "theorem Cotrident.\u03c0_of\u03c0 [Nonempty J] {P : C} (\u03c0 : Y \u27f6 P) (w : \u2200 j\u2081 j\u2082, f j\u2081 \u226b \u03c0 = f j\u2082 \u226b \u03c0) :\n    (Cotrident.of\u03c0 \u03c0 w).\u03c0 = \u03c0", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.condition", "code": "@[reassoc]\ntheorem Trident.condition (j\u2081 j\u2082 : J) (t : Trident f) : t.\u03b9 \u226b f j\u2081 = t.\u03b9 \u226b f j\u2082", "start": [271, 1], "end": [273, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.condition", "code": "@[reassoc]\ntheorem Cotrident.condition (j\u2081 j\u2082 : J) (t : Cotrident f) : f j\u2081 \u226b t.\u03c0 = f j\u2082 \u226b t.\u03c0", "start": [276, 1], "end": [278, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.equalizer_ext", "code": "theorem Trident.equalizer_ext [Nonempty J] (s : Trident f) {W : C} {k l : W \u27f6 s.pt}\n    (h : k \u226b s.\u03b9 = l \u226b s.\u03b9) : \u2200 j : WalkingParallelFamily J, k \u226b s.\u03c0.app j = l \u226b s.\u03c0.app j", "start": [281, 1], "end": [286, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.coequalizer_ext", "code": "theorem Cotrident.coequalizer_ext [Nonempty J] (s : Cotrident f) {W : C} {k l : s.pt \u27f6 W}\n    (h : s.\u03c0 \u226b k = s.\u03c0 \u226b l) : \u2200 j : WalkingParallelFamily J, s.\u03b9.app j \u226b k = s.\u03b9.app j \u226b l", "start": [289, 1], "end": [294, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.hom_ext", "code": "theorem Trident.IsLimit.hom_ext [Nonempty J] {s : Trident f} (hs : IsLimit s) {W : C}\n    {k l : W \u27f6 s.pt} (h : k \u226b s.\u03b9 = l \u226b s.\u03b9) : k = l", "start": [299, 1], "end": [301, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.hom_ext", "code": "theorem Cotrident.IsColimit.hom_ext [Nonempty J] {s : Cotrident f} (hs : IsColimit s) {W : C}\n    {k l : s.pt \u27f6 W} (h : s.\u03c0 \u226b k = s.\u03c0 \u226b l) : k = l", "start": [304, 1], "end": [306, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.lift'", "code": "def Trident.IsLimit.lift' [Nonempty J] {s : Trident f} (hs : IsLimit s) {W : C} (k : W \u27f6 X)\n    (h : \u2200 j\u2081 j\u2082, k \u226b f j\u2081 = k \u226b f j\u2082) : { l : W \u27f6 s.pt // l \u226b Trident.\u03b9 s = k } :=\n  \u27e8hs.lift <| Trident.of\u03b9 _ h, hs.fac _ _\u27e9", "start": [311, 1], "end": [316, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.desc'", "code": "def Cotrident.IsColimit.desc' [Nonempty J] {s : Cotrident f} (hs : IsColimit s) {W : C} (k : Y \u27f6 W)\n    (h : \u2200 j\u2081 j\u2082, f j\u2081 \u226b k = f j\u2082 \u226b k) : { l : s.pt \u27f6 W // Cotrident.\u03c0 s \u226b l = k } :=\n  \u27e8hs.desc <| Cotrident.of\u03c0 _ h, hs.fac _ _\u27e9", "start": [319, 1], "end": [324, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.mk", "code": "def Trident.IsLimit.mk [Nonempty J] (t : Trident f) (lift : \u2200 s : Trident f, s.pt \u27f6 t.pt)\n    (fac : \u2200 s : Trident f, lift s \u226b t.\u03b9 = s.\u03b9)\n    (uniq :\n      \u2200 (s : Trident f) (m : s.pt \u27f6 t.pt)\n        (_ : \u2200 j : WalkingParallelFamily J, m \u226b t.\u03c0.app j = s.\u03c0.app j), m = lift s) :\n    IsLimit t :=\n  { lift\n    fac := fun s j =>\n      WalkingParallelFamily.casesOn j (fac s)\n        (by rw [\u2190 t.w (line (Classical.arbitrary J)), reassoc_of% fac, s.w])\n    uniq := uniq }", "start": [329, 1], "end": [341, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.mk'", "code": "def Trident.IsLimit.mk' [Nonempty J] (t : Trident f)\n    (create : \u2200 s : Trident f, { l // l \u226b t.\u03b9 = s.\u03b9 \u2227 \u2200 {m}, m \u226b t.\u03b9 = s.\u03b9 \u2192 m = l }) :\n    IsLimit t :=\n  Trident.IsLimit.mk t (fun s => (create s).1) (fun s => (create s).2.1) fun s _ w =>\n    (create s).2.2 (w zero)", "start": [344, 1], "end": [351, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.mk", "code": "def Cotrident.IsColimit.mk [Nonempty J] (t : Cotrident f) (desc : \u2200 s : Cotrident f, t.pt \u27f6 s.pt)\n    (fac : \u2200 s : Cotrident f, t.\u03c0 \u226b desc s = s.\u03c0)\n    (uniq :\n      \u2200 (s : Cotrident f) (m : t.pt \u27f6 s.pt)\n        (_ : \u2200 j : WalkingParallelFamily J, t.\u03b9.app j \u226b m = s.\u03b9.app j), m = desc s) :\n    IsColimit t :=\n  { desc\n    fac := fun s j =>\n      WalkingParallelFamily.casesOn j (by rw [\u2190 t.w_assoc (line (Classical.arbitrary J)), fac, s.w])\n        (fac s)\n    uniq := uniq }", "start": [354, 1], "end": [366, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.mk'", "code": "def Cotrident.IsColimit.mk' [Nonempty J] (t : Cotrident f)\n    (create :\n      \u2200 s : Cotrident f, { l : t.pt \u27f6 s.pt // t.\u03c0 \u226b l = s.\u03c0 \u2227 \u2200 {m}, t.\u03c0 \u226b m = s.\u03c0 \u2192 m = l }) :\n    IsColimit t :=\n  Cotrident.IsColimit.mk t (fun s => (create s).1) (fun s => (create s).2.1) fun s _ w =>\n    (create s).2.2 (w one)", "start": [369, 1], "end": [377, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.homIso", "code": "@[simps]\ndef Trident.IsLimit.homIso [Nonempty J] {t : Trident f} (ht : IsLimit t) (Z : C) :\n    (Z \u27f6 t.pt) \u2243 { h : Z \u27f6 X // \u2200 j\u2081 j\u2082, h \u226b f j\u2081 = h \u226b f j\u2082 } where\n  toFun k := \u27e8k \u226b t.\u03b9, by simp\u27e9\n  invFun h := (Trident.IsLimit.lift' ht _ h.prop).1\n  left_inv k := Trident.IsLimit.hom_ext ht (Trident.IsLimit.lift' _ _ _).prop\n  right_inv h := Subtype.ext (Trident.IsLimit.lift' ht _ _).prop", "start": [380, 1], "end": [391, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.IsLimit.homIso_natural", "code": "theorem Trident.IsLimit.homIso_natural [Nonempty J] {t : Trident f} (ht : IsLimit t) {Z Z' : C}\n    (q : Z' \u27f6 Z) (k : Z \u27f6 t.pt) :\n    (Trident.IsLimit.homIso ht _ (q \u226b k) : Z' \u27f6 X) =\n      q \u226b (Trident.IsLimit.homIso ht _ k : Z \u27f6 X)", "start": [394, 1], "end": [399, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.homIso", "code": "@[simps]\ndef Cotrident.IsColimit.homIso [Nonempty J] {t : Cotrident f} (ht : IsColimit t) (Z : C) :\n    (t.pt \u27f6 Z) \u2243 { h : Y \u27f6 Z // \u2200 j\u2081 j\u2082, f j\u2081 \u226b h = f j\u2082 \u226b h } where\n  toFun k := \u27e8t.\u03c0 \u226b k, by simp\u27e9\n  invFun h := (Cotrident.IsColimit.desc' ht _ h.prop).1\n  left_inv k := Cotrident.IsColimit.hom_ext ht (Cotrident.IsColimit.desc' _ _ _).prop\n  right_inv h := Subtype.ext (Cotrident.IsColimit.desc' ht _ _).prop", "start": [404, 1], "end": [415, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.IsColimit.homIso_natural", "code": "theorem Cotrident.IsColimit.homIso_natural [Nonempty J] {t : Cotrident f} {Z Z' : C} (q : Z \u27f6 Z')\n    (ht : IsColimit t) (k : t.pt \u27f6 Z) :\n    (Cotrident.IsColimit.homIso ht _ (k \u226b q) : Y \u27f6 Z') =\n      (Cotrident.IsColimit.homIso ht _ k : Y \u27f6 Z) \u226b q", "start": [420, 1], "end": [425, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.ofTrident", "code": "def Cone.ofTrident {F : WalkingParallelFamily J \u2964 C} (t : Trident fun j => F.map (line j)) : Cone F\n    where\n  pt := t.pt\n  \u03c0 :=\n    { app := fun X => t.\u03c0.app X \u226b eqToHom (by cases X <;> aesop_cat)\n      naturality := fun j j' g => by cases g <;> aesop_cat }", "start": [430, 1], "end": [443, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.ofCotrident", "code": "def Cocone.ofCotrident {F : WalkingParallelFamily J \u2964 C} (t : Cotrident fun j => F.map (line j)) :\n    Cocone F where\n  pt := t.pt\n  \u03b9 :=\n    { app := fun X => eqToHom (by cases X <;> aesop_cat) \u226b t.\u03b9.app X\n      naturality := fun j j' g => by cases g <;> dsimp <;> simp [Cotrident.app_one t] }", "start": [446, 1], "end": [459, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cone.ofTrident_\u03c0", "code": "@[simp]\ntheorem Cone.ofTrident_\u03c0 {F : WalkingParallelFamily J \u2964 C} (t : Trident fun j => F.map (line j))\n    (j) : (Cone.ofTrident t).\u03c0.app j = t.\u03c0.app j \u226b eqToHom (by cases j <;> aesop_cat)", "start": [462, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cocone.ofCotrident_\u03b9", "code": "@[simp]\ntheorem Cocone.ofCotrident_\u03b9 {F : WalkingParallelFamily J \u2964 C}\n    (t : Cotrident fun j => F.map (line j)) (j) :\n    (Cocone.ofCotrident t).\u03b9.app j = eqToHom (by cases j <;> aesop_cat) \u226b t.\u03b9.app j", "start": [468, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.ofCone", "code": "def Trident.ofCone {F : WalkingParallelFamily J \u2964 C} (t : Cone F) : Trident fun j => F.map (line j)\n    where\n  pt := t.pt\n  \u03c0 :=\n    { app := fun X => t.\u03c0.app X \u226b eqToHom (by cases X <;> aesop_cat)\n      naturality := by rintro _ _ (_|_) <;> aesop_cat }", "start": [475, 1], "end": [483, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.ofCocone", "code": "def Cotrident.ofCocone {F : WalkingParallelFamily J \u2964 C} (t : Cocone F) :\n    Cotrident fun j => F.map (line j) where\n  pt := t.pt\n  \u03b9 :=\n    { app := fun X => eqToHom (by cases X <;> aesop_cat) \u226b t.\u03b9.app X\n      naturality := by rintro _ _ (_|_) <;> aesop_cat }", "start": [486, 1], "end": [494, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.ofCone_\u03c0", "code": "@[simp]\ntheorem Trident.ofCone_\u03c0 {F : WalkingParallelFamily J \u2964 C} (t : Cone F) (j) :\n    (Trident.ofCone t).\u03c0.app j = t.\u03c0.app j \u226b eqToHom (by cases j <;> aesop_cat)", "start": [497, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.ofCocone_\u03b9", "code": "@[simp]\ntheorem Cotrident.ofCocone_\u03b9 {F : WalkingParallelFamily J \u2964 C} (t : Cocone F) (j) :\n    (Cotrident.ofCocone t).\u03b9.app j = eqToHom (by cases j <;> aesop_cat) \u226b t.\u03b9.app j", "start": [503, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.mkHom", "code": "@[simps]\ndef Trident.mkHom [Nonempty J] {s t : Trident f} (k : s.pt \u27f6 t.pt)\n    (w : k \u226b t.\u03b9 = s.\u03b9 := by aesop_cat) : s \u27f6 t where\n  hom := k\n  w := by\n    rintro \u27e8_ | _\u27e9\n    \u00b7 exact w\n    \u00b7 simpa using w =\u226b f (Classical.arbitrary J)", "start": [509, 1], "end": [518, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Trident.ext", "code": "@[simps]\ndef Trident.ext [Nonempty J] {s t : Trident f} (i : s.pt \u2245 t.pt)\n    (w : i.hom \u226b t.\u03b9 = s.\u03b9 := by aesop_cat) : s \u2245 t where\n  hom := Trident.mkHom i.hom w\n  inv := Trident.mkHom i.inv (by rw [\u2190 w, Iso.inv_hom_id_assoc])", "start": [521, 1], "end": [529, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.mkHom", "code": "@[simps]\ndef Cotrident.mkHom [Nonempty J] {s t : Cotrident f} (k : s.pt \u27f6 t.pt)\n    (w : s.\u03c0 \u226b k = t.\u03c0 := by aesop_cat) : s \u27f6 t where\n  hom := k\n  w := by\n    rintro \u27e8_ | _\u27e9\n    \u00b7 simpa using f (Classical.arbitrary J) \u226b= w\n    \u00b7 exact w", "start": [532, 1], "end": [541, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.Cotrident.ext", "code": "def Cotrident.ext [Nonempty J] {s t : Cotrident f} (i : s.pt \u2245 t.pt)\n    (w : s.\u03c0 \u226b i.hom = t.\u03c0 := by aesop_cat) : s \u2245 t where\n  hom := Cotrident.mkHom i.hom w\n  inv := Cotrident.mkHom i.inv (by rw [Iso.comp_inv_eq, w])", "start": [544, 1], "end": [551, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWideEqualizer", "code": "abbrev HasWideEqualizer :=\n  HasLimit (parallelFamily f)", "start": [558, 1], "end": [563, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer", "code": "abbrev wideEqualizer : C :=\n  limit (parallelFamily f)", "start": [568, 1], "end": [571, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.\u03b9", "code": "abbrev wideEqualizer.\u03b9 : wideEqualizer f \u27f6 X :=\n  limit.\u03c0 (parallelFamily f) zero", "start": [574, 1], "end": [577, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.trident", "code": "abbrev wideEqualizer.trident : Trident f :=\n  limit.cone (parallelFamily f)", "start": [580, 1], "end": [583, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.trident_\u03b9", "code": "@[simp]\ntheorem wideEqualizer.trident_\u03b9 : (wideEqualizer.trident f).\u03b9 = wideEqualizer.\u03b9 f", "start": [586, 1], "end": [588, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.trident_\u03c0_app_zero", "code": "@[simp 1100]\ntheorem wideEqualizer.trident_\u03c0_app_zero :\n    (wideEqualizer.trident f).\u03c0.app zero = wideEqualizer.\u03b9 f", "start": [591, 1], "end": [594, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.condition", "code": "@[reassoc]\ntheorem wideEqualizer.condition (j\u2081 j\u2082 : J) : wideEqualizer.\u03b9 f \u226b f j\u2081 = wideEqualizer.\u03b9 f \u226b f j\u2082", "start": [599, 1], "end": [601, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizerIsWideEqualizer", "code": "def wideEqualizerIsWideEqualizer [Nonempty J] :\n    IsLimit (Trident.of\u03b9 (wideEqualizer.\u03b9 f) (wideEqualizer.condition f)) :=\n  IsLimit.ofIsoLimit (limit.isLimit _) (Trident.ext (Iso.refl _))", "start": [604, 1], "end": [607, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.lift", "code": "abbrev wideEqualizer.lift [Nonempty J] {W : C} (k : W \u27f6 X) (h : \u2200 j\u2081 j\u2082, k \u226b f j\u2081 = k \u226b f j\u2082) :\n    W \u27f6 wideEqualizer f :=\n  limit.lift (parallelFamily f) (Trident.of\u03b9 k h)", "start": [614, 1], "end": [618, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.lift_\u03b9", "code": "@[reassoc (attr := simp 1100)]\ntheorem wideEqualizer.lift_\u03b9 [Nonempty J] {W : C} (k : W \u27f6 X)\n    (h : \u2200 j\u2081 j\u2082, k \u226b f j\u2081 = k \u226b f j\u2082) :\n    wideEqualizer.lift k h \u226b wideEqualizer.\u03b9 f = k", "start": [621, 1], "end": [625, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.lift'", "code": "def wideEqualizer.lift' [Nonempty J] {W : C} (k : W \u27f6 X) (h : \u2200 j\u2081 j\u2082, k \u226b f j\u2081 = k \u226b f j\u2082) :\n    { l : W \u27f6 wideEqualizer f // l \u226b wideEqualizer.\u03b9 f = k } :=\n  \u27e8wideEqualizer.lift k h, wideEqualizer.lift_\u03b9 _ _\u27e9", "start": [628, 1], "end": [632, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.hom_ext", "code": "@[ext]\ntheorem wideEqualizer.hom_ext [Nonempty J] {W : C} {k l : W \u27f6 wideEqualizer f}\n    (h : k \u226b wideEqualizer.\u03b9 f = l \u226b wideEqualizer.\u03b9 f) : k = l", "start": [635, 1], "end": [640, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideEqualizer.\u03b9_mono", "code": "instance wideEqualizer.\u03b9_mono [Nonempty J] : Mono (wideEqualizer.\u03b9 f) where\n  right_cancellation _ _ w := wideEqualizer.hom_ext w", "start": [643, 1], "end": [645, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.mono_of_isLimit_parallelFamily", "code": "theorem mono_of_isLimit_parallelFamily [Nonempty J] {c : Cone (parallelFamily f)} (i : IsLimit c) :\n    Mono (Trident.\u03b9 c) where", "start": [654, 1], "end": [657, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWideCoequalizer", "code": "abbrev HasWideCoequalizer :=\n  HasColimit (parallelFamily f)", "start": [666, 1], "end": [670, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer", "code": "abbrev wideCoequalizer : C :=\n  colimit (parallelFamily f)", "start": [675, 1], "end": [678, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.\u03c0", "code": "abbrev wideCoequalizer.\u03c0 : Y \u27f6 wideCoequalizer f :=\n  colimit.\u03b9 (parallelFamily f) one", "start": [681, 1], "end": [684, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.cotrident", "code": "abbrev wideCoequalizer.cotrident : Cotrident f :=\n  colimit.cocone (parallelFamily f)", "start": [687, 1], "end": [690, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.cotrident_\u03c0", "code": "@[simp]\ntheorem wideCoequalizer.cotrident_\u03c0 : (wideCoequalizer.cotrident f).\u03c0 = wideCoequalizer.\u03c0 f", "start": [695, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.cotrident_\u03b9_app_one", "code": "@[simp 1100]\ntheorem wideCoequalizer.cotrident_\u03b9_app_one :\n    (wideCoequalizer.cotrident f).\u03b9.app one = wideCoequalizer.\u03c0 f", "start": [702, 1], "end": [705, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.condition", "code": "@[reassoc]\ntheorem wideCoequalizer.condition (j\u2081 j\u2082 : J) :\n    f j\u2081 \u226b wideCoequalizer.\u03c0 f = f j\u2082 \u226b wideCoequalizer.\u03c0 f", "start": [710, 1], "end": [713, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizerIsWideCoequalizer", "code": "def wideCoequalizerIsWideCoequalizer [Nonempty J] :\n    IsColimit (Cotrident.of\u03c0 (wideCoequalizer.\u03c0 f) (wideCoequalizer.condition f)) :=\n  IsColimit.ofIsoColimit (colimit.isColimit _) (Cotrident.ext (Iso.refl _))", "start": [718, 1], "end": [721, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.desc", "code": "abbrev wideCoequalizer.desc [Nonempty J] {W : C} (k : Y \u27f6 W) (h : \u2200 j\u2081 j\u2082, f j\u2081 \u226b k = f j\u2082 \u226b k) :\n    wideCoequalizer f \u27f6 W :=\n  colimit.desc (parallelFamily f) (Cotrident.of\u03c0 k h)", "start": [728, 1], "end": [732, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.\u03c0_desc", "code": "@[reassoc (attr := simp 1100)]\ntheorem wideCoequalizer.\u03c0_desc [Nonempty J] {W : C} (k : Y \u27f6 W)\n    (h : \u2200 j\u2081 j\u2082, f j\u2081 \u226b k = f j\u2082 \u226b k) :\n    wideCoequalizer.\u03c0 f \u226b wideCoequalizer.desc k h = k", "start": [735, 1], "end": [739, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.desc'", "code": "def wideCoequalizer.desc' [Nonempty J] {W : C} (k : Y \u27f6 W) (h : \u2200 j\u2081 j\u2082, f j\u2081 \u226b k = f j\u2082 \u226b k) :\n    { l : wideCoequalizer f \u27f6 W // wideCoequalizer.\u03c0 f \u226b l = k } :=\n  \u27e8wideCoequalizer.desc k h, wideCoequalizer.\u03c0_desc _ _\u27e9", "start": [742, 1], "end": [746, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.hom_ext", "code": "@[ext]\ntheorem wideCoequalizer.hom_ext [Nonempty J] {W : C} {k l : wideCoequalizer f \u27f6 W}\n    (h : wideCoequalizer.\u03c0 f \u226b k = wideCoequalizer.\u03c0 f \u226b l) : k = l", "start": [749, 1], "end": [754, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.wideCoequalizer.\u03c0_epi", "code": "instance wideCoequalizer.\u03c0_epi [Nonempty J] : Epi (wideCoequalizer.\u03c0 f) where\n  left_cancellation _ _ w := wideCoequalizer.hom_ext w", "start": [757, 1], "end": [759, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.epi_of_isColimit_parallelFamily", "code": "theorem epi_of_isColimit_parallelFamily [Nonempty J] {c : Cocone (parallelFamily f)}\n    (i : IsColimit c) : Epi (c.\u03b9.app one) where", "start": [768, 1], "end": [771, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWideEqualizers", "code": "abbrev HasWideEqualizers :=\n  \u2200 J, HasLimitsOfShape (WalkingParallelFamily.{w} J) C", "start": [780, 1], "end": [782, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.HasWideCoequalizers", "code": "abbrev HasWideCoequalizers :=\n  \u2200 J, HasColimitsOfShape (WalkingParallelFamily.{w} J) C", "start": [785, 1], "end": [787, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasWideEqualizers_of_hasLimit_parallelFamily", "code": "theorem hasWideEqualizers_of_hasLimit_parallelFamily\n    [\u2200 {J : Type w} {X Y : C} {f : J \u2192 (X \u27f6 Y)}, HasLimit (parallelFamily f)] :\n    HasWideEqualizers.{w} C", "start": [790, 1], "end": [794, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasWideCoequalizers_of_hasColimit_parallelFamily", "code": "theorem hasWideCoequalizers_of_hasColimit_parallelFamily\n    [\u2200 {J : Type w} {X Y : C} {f : J \u2192 (X \u27f6 Y)}, HasColimit (parallelFamily f)] :\n    HasWideCoequalizers.{w} C", "start": [799, 1], "end": [803, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasEqualizers_of_hasWideEqualizers", "code": "instance (priority := 10) hasEqualizers_of_hasWideEqualizers [HasWideEqualizers.{w} C] :\n    HasEqualizers C :=\n  hasLimitsOfShape_of_equivalence.{w} walkingParallelFamilyEquivWalkingParallelPair", "start": [808, 1], "end": [810, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.hasCoequalizers_of_hasWideCoequalizers", "code": "instance (priority := 10) hasCoequalizers_of_hasWideCoequalizers [HasWideCoequalizers.{w} C] :\n    HasCoequalizers C :=\n  hasColimitsOfShape_of_equivalence.{w} walkingParallelFamilyEquivWalkingParallelPair", "start": [815, 1], "end": [817, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/HasseDeriv.lean", "imports": ["Mathlib/Algebra/Polynomial/BigOperators.lean", "Mathlib/Data/Nat/Choose/Vandermonde.lean", "Mathlib/Data/Nat/Choose/Cast.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Polynomial/Derivative.lean"], "premises": [{"full_name": "Polynomial.hasseDeriv", "code": "def hasseDeriv (k : \u2115) : R[X] \u2192\u2097[R] R[X] :=\n  lsum fun i => monomial (i - k) \u2218\u2097 DistribMulAction.toLinearMap R R (i.choose k)", "start": [56, 1], "end": [59, 82], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_apply", "code": "theorem hasseDeriv_apply :\n    hasseDeriv k f = f.sum fun i r => monomial (i - k) (\u2191(i.choose k) * r)", "start": [62, 1], "end": [66, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_coeff", "code": "theorem hasseDeriv_coeff (n : \u2115) :\n    (hasseDeriv k f).coeff n = (n + k).choose k * f.coeff (n + k)", "start": [69, 1], "end": [82, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_zero'", "code": "theorem hasseDeriv_zero' : hasseDeriv 0 f = f", "start": [85, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_zero", "code": "@[simp]\ntheorem hasseDeriv_zero : @hasseDeriv R _ 0 = LinearMap.id", "start": [90, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_eq_zero_of_lt_natDegree", "code": "theorem hasseDeriv_eq_zero_of_lt_natDegree (p : R[X]) (n : \u2115) (h : p.natDegree < n) :\n    hasseDeriv n p = 0", "start": [95, 1], "end": [99, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_one'", "code": "theorem hasseDeriv_one' : hasseDeriv 1 f = derivative f", "start": [102, 1], "end": [104, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_one", "code": "@[simp]\ntheorem hasseDeriv_one : @hasseDeriv R _ 1 = derivative", "start": [107, 1], "end": [109, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_monomial", "code": "@[simp]\ntheorem hasseDeriv_monomial (n : \u2115) (r : R) :\n    hasseDeriv k (monomial n r) = monomial (n - k) (\u2191(n.choose k) * r)", "start": [112, 1], "end": [126, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_C", "code": "theorem hasseDeriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0", "start": [129, 1], "end": [131, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_apply_one", "code": "theorem hasseDeriv_apply_one (hk : 0 < k) : hasseDeriv k (1 : R[X]) = 0", "start": [135, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_X", "code": "theorem hasseDeriv_X (hk : 1 < k) : hasseDeriv k (X : R[X]) = 0", "start": [139, 1], "end": [141, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.factorial_smul_hasseDeriv", "code": "theorem factorial_smul_hasseDeriv : \u21d1(k ! \u2022 @hasseDeriv R _ k) = (@derivative R _)^[k]", "start": [145, 1], "end": [163, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_comp", "code": "theorem hasseDeriv_comp (k l : \u2115) :\n    (@hasseDeriv R _ k).comp (hasseDeriv l) = (k + l).choose k \u2022 hasseDeriv (k + l)", "start": [166, 1], "end": [191, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_hasseDeriv_le", "code": "theorem natDegree_hasseDeriv_le (p : R[X]) (n : \u2115) :\n    natDegree (hasseDeriv n p) \u2264 natDegree p - n", "start": [194, 1], "end": [209, 11], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natDegree_hasseDeriv", "code": "theorem natDegree_hasseDeriv [NoZeroSMulDivisors \u2115 R] (p : R[X]) (n : \u2115) :\n    natDegree (hasseDeriv n p) = natDegree p - n", "start": [212, 1], "end": [223, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.hasseDeriv_mul", "code": "theorem hasseDeriv_mul (f g : R[X]) :\n    hasseDeriv k (f * g) = \u2211 ij in antidiagonal k, hasseDeriv ij.1 f * hasseDeriv ij.2 g", "start": [230, 1], "end": [264, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Holder.lean", "imports": ["Mathlib/Topology/MetricSpace/Lipschitz.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HolderWith", "code": "def HolderWith (C r : \u211d\u22650) (f : X \u2192 Y) : Prop :=\n  \u2200 x y, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)", "start": [48, 1], "end": [51, 62], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith", "code": "def HolderOnWith (C r : \u211d\u22650) (f : X \u2192 Y) (s : Set X) : Prop :=\n  \u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)", "start": [54, 1], "end": [58, 73], "kind": "commanddeclaration"}, {"full_name": "holderOnWith_empty", "code": "@[simp]\ntheorem holderOnWith_empty (C r : \u211d\u22650) (f : X \u2192 Y) : HolderOnWith C r f \u2205", "start": [61, 1], "end": [62, 97], "kind": "commanddeclaration"}, {"full_name": "holderOnWith_singleton", "code": "@[simp]\ntheorem holderOnWith_singleton (C r : \u211d\u22650) (f : X \u2192 Y) (x : X) : HolderOnWith C r f {x}", "start": [65, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.holderOnWith", "code": "theorem Set.Subsingleton.holderOnWith {s : Set X} (hs : s.Subsingleton) (C r : \u211d\u22650) (f : X \u2192 Y) :\n    HolderOnWith C r f s", "start": [72, 1], "end": [74, 76], "kind": "commanddeclaration"}, {"full_name": "holderOnWith_univ", "code": "theorem holderOnWith_univ {C r : \u211d\u22650} {f : X \u2192 Y} : HolderOnWith C r f univ \u2194 HolderWith C r f", "start": [77, 1], "end": [78, 63], "kind": "commanddeclaration"}, {"full_name": "holderOnWith_one", "code": "@[simp]\ntheorem holderOnWith_one {C : \u211d\u22650} {f : X \u2192 Y} {s : Set X} :\n    HolderOnWith C 1 f s \u2194 LipschitzOnWith C f s", "start": [81, 1], "end": [84, 78], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.holderOnWith", "code": "alias \u27e8_, LipschitzOnWith.holderOnWith\u27e9 := holderOnWith_one", "start": [87, 1], "end": [87, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "holderWith_one", "code": "@[simp]\ntheorem holderWith_one {C : \u211d\u22650} {f : X \u2192 Y} : HolderWith C 1 f \u2194 LipschitzWith C f", "start": [90, 1], "end": [92, 74], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.holderWith", "code": "alias \u27e8_, LipschitzWith.holderWith\u27e9 := holderWith_one", "start": [95, 1], "end": [95, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "holderWith_id", "code": "theorem holderWith_id : HolderWith 1 1 (id : X \u2192 X)", "start": [98, 1], "end": [99, 30], "kind": "commanddeclaration"}, {"full_name": "HolderWith.holderOnWith", "code": "protected theorem HolderWith.holderOnWith {C r : \u211d\u22650} {f : X \u2192 Y} (h : HolderWith C r f)\n    (s : Set X) : HolderOnWith C r f s", "start": [102, 1], "end": [103, 63], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.edist_le", "code": "theorem edist_le (h : HolderOnWith C r f s) {x y : X} (hx : x \u2208 s) (hy : y \u2208 s) :\n    edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)", "start": [110, 1], "end": [112, 14], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.edist_le_of_le", "code": "theorem edist_le_of_le (h : HolderOnWith C r f s) {x y : X} (hx : x \u2208 s) (hy : y \u2208 s) {d : \u211d\u22650\u221e}\n    (hd : edist x y \u2264 d) : edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d)", "start": [115, 1], "end": [117, 87], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.comp", "code": "theorem comp {Cg rg : \u211d\u22650} {g : Y \u2192 Z} {t : Set Y} (hg : HolderOnWith Cg rg g t) {Cf rf : \u211d\u22650}\n    {f : X \u2192 Y} (hf : HolderOnWith Cf rf f s) (hst : MapsTo f s t) :\n    HolderOnWith (Cg * NNReal.rpow Cf rg) (rg * rf) (g \u2218 f) s", "start": [120, 1], "end": [126, 64], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.comp_holderWith", "code": "theorem comp_holderWith {Cg rg : \u211d\u22650} {g : Y \u2192 Z} {t : Set Y} (hg : HolderOnWith Cg rg g t)\n    {Cf rf : \u211d\u22650} {f : X \u2192 Y} (hf : HolderWith Cf rf f) (ht : \u2200 x, f x \u2208 t) :\n    HolderWith (Cg * NNReal.rpow Cf rg) (rg * rf) (g \u2218 f)", "start": [129, 1], "end": [132, 73], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.uniformContinuousOn", "code": "protected theorem uniformContinuousOn (hf : HolderOnWith C r f s) (h0 : 0 < r) :\n    UniformContinuousOn f s", "start": [135, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.continuousOn", "code": "protected theorem continuousOn (hf : HolderOnWith C r f s) (h0 : 0 < r) : ContinuousOn f s", "start": [145, 1], "end": [146, 43], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.mono", "code": "protected theorem mono (hf : HolderOnWith C r f s) (ht : t \u2286 s) : HolderOnWith C r f t", "start": [149, 1], "end": [150, 47], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_le_of_le", "code": "theorem ediam_image_le_of_le (hf : HolderOnWith C r f s) {d : \u211d\u22650\u221e} (hd : EMetric.diam s \u2264 d) :\n    EMetric.diam (f '' s) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d)", "start": [153, 1], "end": [156, 77], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_le", "code": "theorem ediam_image_le (hf : HolderOnWith C r f s) :\n    EMetric.diam (f '' s) \u2264 (C : \u211d\u22650\u221e) * EMetric.diam s ^ (r : \u211d)", "start": [159, 1], "end": [161, 33], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_le_of_subset", "code": "theorem ediam_image_le_of_subset (hf : HolderOnWith C r f s) (ht : t \u2286 s) :\n    EMetric.diam (f '' t) \u2264 (C : \u211d\u22650\u221e) * EMetric.diam t ^ (r : \u211d)", "start": [164, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_le_of_subset_of_le", "code": "theorem ediam_image_le_of_subset_of_le (hf : HolderOnWith C r f s) (ht : t \u2286 s) {d : \u211d\u22650\u221e}\n    (hd : EMetric.diam t \u2264 d) : EMetric.diam (f '' t) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d)", "start": [169, 1], "end": [171, 39], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_inter_le_of_le", "code": "theorem ediam_image_inter_le_of_le (hf : HolderOnWith C r f s) {d : \u211d\u22650\u221e}\n    (hd : EMetric.diam t \u2264 d) : EMetric.diam (f '' (t \u2229 s)) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d)", "start": [174, 1], "end": [177, 58], "kind": "commanddeclaration"}, {"full_name": "HolderOnWith.ediam_image_inter_le", "code": "theorem ediam_image_inter_le (hf : HolderOnWith C r f s) (t : Set X) :\n    EMetric.diam (f '' (t \u2229 s)) \u2264 (C : \u211d\u22650\u221e) * EMetric.diam t ^ (r : \u211d)", "start": [180, 1], "end": [182, 39], "kind": "commanddeclaration"}, {"full_name": "HolderWith.edist_le", "code": "theorem edist_le (h : HolderWith C r f) (x y : X) :\n    edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * edist x y ^ (r : \u211d)", "start": [191, 1], "end": [193, 8], "kind": "commanddeclaration"}, {"full_name": "HolderWith.edist_le_of_le", "code": "theorem edist_le_of_le (h : HolderWith C r f) {x y : X} {d : \u211d\u22650\u221e} (hd : edist x y \u2264 d) :\n    edist (f x) (f y) \u2264 (C : \u211d\u22650\u221e) * d ^ (r : \u211d)", "start": [196, 1], "end": [198, 58], "kind": "commanddeclaration"}, {"full_name": "HolderWith.comp", "code": "theorem comp {Cg rg : \u211d\u22650} {g : Y \u2192 Z} (hg : HolderWith Cg rg g) {Cf rf : \u211d\u22650} {f : X \u2192 Y}\n    (hf : HolderWith Cf rf f) : HolderWith (Cg * NNReal.rpow Cf rg) (rg * rf) (g \u2218 f)", "start": [201, 1], "end": [203, 61], "kind": "commanddeclaration"}, {"full_name": "HolderWith.comp_holderOnWith", "code": "theorem comp_holderOnWith {Cg rg : \u211d\u22650} {g : Y \u2192 Z} (hg : HolderWith Cg rg g) {Cf rf : \u211d\u22650}\n    {f : X \u2192 Y} {s : Set X} (hf : HolderOnWith Cf rf f s) :\n    HolderOnWith (Cg * NNReal.rpow Cf rg) (rg * rf) (g \u2218 f) s", "start": [206, 1], "end": [209, 52], "kind": "commanddeclaration"}, {"full_name": "HolderWith.uniformContinuous", "code": "protected theorem uniformContinuous (hf : HolderWith C r f) (h0 : 0 < r) : UniformContinuous f", "start": [212, 1], "end": [214, 79], "kind": "commanddeclaration"}, {"full_name": "HolderWith.continuous", "code": "protected theorem continuous (hf : HolderWith C r f) (h0 : 0 < r) : Continuous f", "start": [217, 1], "end": [218, 39], "kind": "commanddeclaration"}, {"full_name": "HolderWith.ediam_image_le", "code": "theorem ediam_image_le (hf : HolderWith C r f) (s : Set X) :\n    EMetric.diam (f '' s) \u2264 (C : \u211d\u22650\u221e) * EMetric.diam s ^ (r : \u211d)", "start": [221, 1], "end": [224, 60], "kind": "commanddeclaration"}, {"full_name": "HolderWith.nndist_le_of_le", "code": "theorem nndist_le_of_le (hf : HolderWith C r f) {x y : X} {d : \u211d\u22650} (hd : nndist x y \u2264 d) :\n    nndist (f x) (f y) \u2264 C * d ^ (r : \u211d)", "start": [237, 1], "end": [243, 41], "kind": "commanddeclaration"}, {"full_name": "HolderWith.nndist_le", "code": "theorem nndist_le (hf : HolderWith C r f) (x y : X) :\n    nndist (f x) (f y) \u2264 C * nndist x y ^ (r : \u211d)", "start": [246, 1], "end": [248, 28], "kind": "commanddeclaration"}, {"full_name": "HolderWith.dist_le_of_le", "code": "theorem dist_le_of_le (hf : HolderWith C r f) {x y : X} {d : \u211d} (hd : dist x y \u2264 d) :\n    dist (f x) (f y) \u2264 C * d ^ (r : \u211d)", "start": [251, 1], "end": [256, 30], "kind": "commanddeclaration"}, {"full_name": "HolderWith.dist_le", "code": "theorem dist_le (hf : HolderWith C r f) (x y : X) : dist (f x) (f y) \u2264 C * dist x y ^ (r : \u211d)", "start": [259, 1], "end": [260, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/MetricSeparated.lean", "imports": ["Mathlib/Topology/EMetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsMetricSeparated", "code": "def IsMetricSeparated {X : Type*} [EMetricSpace X] (s t : Set X) :=\n  \u2203 r, r \u2260 0 \u2227 \u2200 x \u2208 s, \u2200 y \u2208 t, r \u2264 edist x y", "start": [25, 1], "end": [28, 47], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.symm", "code": "@[symm]\ntheorem symm (h : IsMetricSeparated s t) : IsMetricSeparated t s", "start": [35, 1], "end": [38, 58], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.comm", "code": "theorem comm : IsMetricSeparated s t \u2194 IsMetricSeparated t s", "start": [41, 1], "end": [42, 15], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.empty_left", "code": "@[simp]\ntheorem empty_left (s : Set X) : IsMetricSeparated \u2205 s", "start": [45, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.empty_right", "code": "@[simp]\ntheorem empty_right (s : Set X) : IsMetricSeparated s \u2205", "start": [50, 1], "end": [52, 22], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.disjoint", "code": "protected theorem disjoint (h : IsMetricSeparated s t) : Disjoint s t", "start": [55, 1], "end": [57, 77], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.subset_compl_right", "code": "theorem subset_compl_right (h : IsMetricSeparated s t) : s \u2286 t\u1d9c", "start": [60, 1], "end": [61, 29], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.mono", "code": "@[mono]\ntheorem mono {s' t'} (hs : s \u2286 s') (ht : t \u2286 t') :\n    IsMetricSeparated s' t' \u2192 IsMetricSeparated s t", "start": [64, 1], "end": [67, 51], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.mono_left", "code": "theorem mono_left {s'} (h' : IsMetricSeparated s' t) (hs : s \u2286 s') : IsMetricSeparated s t", "start": [70, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.mono_right", "code": "theorem mono_right {t'} (h' : IsMetricSeparated s t') (ht : t \u2286 t') : IsMetricSeparated s t", "start": [74, 1], "end": [75, 24], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.union_left", "code": "theorem union_left {s'} (h : IsMetricSeparated s t) (h' : IsMetricSeparated s' t) :\n    IsMetricSeparated (s \u222a s') t", "start": [78, 1], "end": [85, 61], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.union_left_iff", "code": "@[simp]\ntheorem union_left_iff {s'} :\n    IsMetricSeparated (s \u222a s') t \u2194 IsMetricSeparated s t \u2227 IsMetricSeparated s' t", "start": [88, 1], "end": [92, 24], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.union_right", "code": "theorem union_right {t'} (h : IsMetricSeparated s t) (h' : IsMetricSeparated s t') :\n    IsMetricSeparated s (t \u222a t')", "start": [95, 1], "end": [97, 35], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.union_right_iff", "code": "@[simp]\ntheorem union_right_iff {t'} :\n    IsMetricSeparated s (t \u222a t') \u2194 IsMetricSeparated s t \u2227 IsMetricSeparated s t'", "start": [100, 1], "end": [103, 60], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.finite_iUnion_left_iff", "code": "theorem finite_iUnion_left_iff {\u03b9 : Type*} {I : Set \u03b9} (hI : I.Finite) {s : \u03b9 \u2192 Set X}\n    {t : Set X} : IsMetricSeparated (\u22c3 i \u2208 I, s i) t \u2194 \u2200 i \u2208 I, IsMetricSeparated (s i) t", "start": [106, 1], "end": [109, 59], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.finite_iUnion_left", "code": "alias \u27e8_, finite_iUnion_left\u27e9 := finite_iUnion_left_iff", "start": [112, 1], "end": [112, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMetricSeparated.finite_iUnion_right_iff", "code": "theorem finite_iUnion_right_iff {\u03b9 : Type*} {I : Set \u03b9} (hI : I.Finite) {s : Set X}\n    {t : \u03b9 \u2192 Set X} : IsMetricSeparated s (\u22c3 i \u2208 I, t i) \u2194 \u2200 i \u2208 I, IsMetricSeparated s (t i)", "start": [115, 1], "end": [117, 59], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.finset_iUnion_left_iff", "code": "@[simp]\ntheorem finset_iUnion_left_iff {\u03b9 : Type*} {I : Finset \u03b9} {s : \u03b9 \u2192 Set X} {t : Set X} :\n    IsMetricSeparated (\u22c3 i \u2208 I, s i) t \u2194 \u2200 i \u2208 I, IsMetricSeparated (s i) t", "start": [120, 1], "end": [123, 40], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.finset_iUnion_left", "code": "alias \u27e8_, finset_iUnion_left\u27e9 := finset_iUnion_left_iff", "start": [126, 1], "end": [126, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMetricSeparated.finset_iUnion_right_iff", "code": "@[simp]\ntheorem finset_iUnion_right_iff {\u03b9 : Type*} {I : Finset \u03b9} {s : Set X} {t : \u03b9 \u2192 Set X} :\n    IsMetricSeparated s (\u22c3 i \u2208 I, t i) \u2194 \u2200 i \u2208 I, IsMetricSeparated s (t i)", "start": [129, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "IsMetricSeparated.finset_iUnion_right", "code": "alias \u27e8_, finset_iUnion_right\u27e9 := finset_iUnion_right_iff", "start": [135, 1], "end": [135, 58], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Algebra/Lie/Weights/Basic.lean", "imports": ["Mathlib/LinearAlgebra/TensorProduct/Tower.lean", "Mathlib/Algebra/Lie/Engel.lean", "Mathlib/RingTheory/Artinian.lean", "Mathlib/Algebra/Lie/Nilpotent.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "Mathlib/Algebra/Ring/Divisibility/Lemmas.lean", "Mathlib/Algebra/Lie/TensorProduct.lean"], "premises": [{"full_name": "LieModule.weight_vector_multiplication", "code": "protected theorem weight_vector_multiplication (M\u2081 M\u2082 M\u2083 : Type*)\n    [AddCommGroup M\u2081] [Module R M\u2081] [LieRingModule L M\u2081] [LieModule R L M\u2081] [AddCommGroup M\u2082]\n    [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082] [AddCommGroup M\u2083] [Module R M\u2083]\n    [LieRingModule L M\u2083] [LieModule R L M\u2083] (g : M\u2081 \u2297[R] M\u2082 \u2192\u2097\u2045R,L\u2046 M\u2083) (\u03c7\u2081 \u03c7\u2082 : R) (x : L) :\n    LinearMap.range ((g : M\u2081 \u2297[R] M\u2082 \u2192\u2097[R] M\u2083).comp (mapIncl \ud835\udd4e(M\u2081, \u03c7\u2081, x) \ud835\udd4e(M\u2082, \u03c7\u2082, x))) \u2264\n      \ud835\udd4e(M\u2083, \u03c7\u2081 + \u03c7\u2082, x)", "start": [61, 1], "end": [131, 86], "kind": "commanddeclaration"}, {"full_name": "LieModule.lie_mem_maxGenEigenspace_toEndomorphism", "code": "lemma lie_mem_maxGenEigenspace_toEndomorphism\n    {\u03c7\u2081 \u03c7\u2082 : R} {x y : L} {m : M} (hy : y \u2208 \ud835\udd4e(L, \u03c7\u2081, x)) (hm : m \u2208 \ud835\udd4e(M, \u03c7\u2082, x)) :\n    \u2045y, m\u2046 \u2208 \ud835\udd4e(M, \u03c7\u2081 + \u03c7\u2082, x) := by\n  apply LieModule.weight_vector_multiplication L M M (toModuleHom R L M) \u03c7\u2081 \u03c7\u2082\n  simp only [LieModuleHom.coe_toLinearMap, Function.comp_apply, LinearMap.coe_comp,\n    TensorProduct.mapIncl, LinearMap.mem_range]\n  use \u27e8y, hy\u27e9 \u2297\u209c \u27e8m, hm\u27e9\n  simp only [Submodule.subtype_apply, toModuleHom_apply, TensorProduct.map_tmul]", "start": [133, 1], "end": [140, 81], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.weightSpaceOf", "code": "def weightSpaceOf (\u03c7 : R) (x : L) : LieSubmodule R L M :=\n  { \ud835\udd4e(M, \u03c7, x) with\n    lie_mem := by\n      intro y m hm\n      simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n        Submodule.mem_toAddSubmonoid] at hm \u22a2\n      rw [\u2190 zero_add \u03c7]\n      exact lie_mem_maxGenEigenspace_toEndomorphism (by simp) hm }", "start": [144, 1], "end": [155, 67], "kind": "commanddeclaration"}, {"full_name": "LieModule.mem_weightSpaceOf", "code": "theorem mem_weightSpaceOf (\u03c7 : R) (x : L) (m : M) :\n    m \u2208 weightSpaceOf M \u03c7 x \u2194 \u2203 k : \u2115, ((toEndomorphism R L M x - \u03c7 \u2022 \u21911) ^ k) m = 0", "start": [161, 1], "end": [163, 23], "kind": "commanddeclaration"}, {"full_name": "LieModule.coe_weightSpaceOf_zero", "code": "theorem coe_weightSpaceOf_zero (x : L) :\n    \u2191(weightSpaceOf M (0 : R) x) = \u2a06 k, LinearMap.ker (toEndomorphism R L M x ^ k)", "start": [165, 1], "end": [167, 64], "kind": "commanddeclaration"}, {"full_name": "LieModule.weightSpace", "code": "def weightSpace (\u03c7 : L \u2192 R) : LieSubmodule R L M :=\n  \u2a05 x, weightSpaceOf M (\u03c7 x) x", "start": [169, 1], "end": [175, 31], "kind": "commanddeclaration"}, {"full_name": "LieModule.mem_weightSpace", "code": "theorem mem_weightSpace (\u03c7 : L \u2192 R) (m : M) :\n    m \u2208 weightSpace M \u03c7 \u2194 \u2200 x, \u2203 k : \u2115, ((toEndomorphism R L M x - \u03c7 x \u2022 \u21911) ^ k) m = 0", "start": [177, 1], "end": [179, 40], "kind": "commanddeclaration"}, {"full_name": "LieModule.zero_weightSpace_eq_top_of_nilpotent'", "code": "@[simp]\ntheorem zero_weightSpace_eq_top_of_nilpotent' [IsNilpotent R L M] :\n    weightSpace M (0 : L \u2192 R) = \u22a4", "start": [181, 1], "end": [186, 36], "kind": "commanddeclaration"}, {"full_name": "LieModule.coe_weightSpace_of_top", "code": "theorem coe_weightSpace_of_top (\u03c7 : L \u2192 R) :\n    (weightSpace M (\u03c7 \u2218 (\u22a4 : LieSubalgebra R L).incl) : Submodule R M) = weightSpace M \u03c7", "start": [189, 1], "end": [194, 7], "kind": "commanddeclaration"}, {"full_name": "LieModule.zero_weightSpace_eq_top_of_nilpotent", "code": "@[simp]\ntheorem zero_weightSpace_eq_top_of_nilpotent [IsNilpotent R L M] :\n    weightSpace M (0 : (\u22a4 : LieSubalgebra R L) \u2192 R) = \u22a4", "start": [197, 1], "end": [205, 28], "kind": "commanddeclaration"}, {"full_name": "LieModule.exists_weightSpace_zero_le_ker_of_isNoetherian", "code": "theorem exists_weightSpace_zero_le_ker_of_isNoetherian\n    [IsNoetherian R M] (x : L) :\n    \u2203 k : \u2115, weightSpace M (0 : L \u2192 R) \u2264 LinearMap.ker (toEndomorphism R L M x ^ k)", "start": [209, 1], "end": [215, 64], "kind": "commanddeclaration"}, {"full_name": "LieModule.isNilpotent_toEndomorphism_weightSpace_zero", "code": "theorem isNilpotent_toEndomorphism_weightSpace_zero [IsNoetherian R M]\n    (x : L) : _root_.IsNilpotent <| toEndomorphism R L (weightSpace M (0 : L \u2192 R)) x", "start": [217, 1], "end": [227, 14], "kind": "commanddeclaration"}, {"full_name": "LieModule.weightSpace_zero_normalizer_eq_self", "code": "@[simp]\nlemma weightSpace_zero_normalizer_eq_self :\n    (weightSpace M (0 : L \u2192 R)).normalizer = weightSpace M 0 := by\n  refine' le_antisymm _ (LieSubmodule.le_normalizer _)\n  intro m hm\n  rw [LieSubmodule.mem_normalizer] at hm\n  simp only [mem_weightSpace, Pi.zero_apply, zero_smul, sub_zero] at hm \u22a2\n  intro y\n  obtain \u27e8k, hk\u27e9 := hm y y\n  use k + 1\n  simpa [pow_succ', LinearMap.mul_eq_comp]", "start": [237, 1], "end": [247, 43], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.iSup_ucs_le_weightSpace_zero", "code": "lemma iSup_ucs_le_weightSpace_zero :\n    \u2a06 k, (\u22a5 : LieSubmodule R L M).ucs k \u2264 weightSpace M (0 : L \u2192 R) := by\n  simpa using LieSubmodule.ucs_le_of_normalizer_eq_self (weightSpace_zero_normalizer_eq_self R L M)", "start": [249, 1], "end": [251, 100], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.iSup_ucs_eq_weightSpace_zero", "code": "lemma iSup_ucs_eq_weightSpace_zero [IsNoetherian R M] :\n    \u2a06 k, (\u22a5 : LieSubmodule R L M).ucs k = weightSpace M (0 : L \u2192 R) := by\n  obtain \u27e8k, hk\u27e9 := (LieSubmodule.isNilpotent_iff_exists_self_le_ucs\n    <| weightSpace M (0 : L \u2192 R)).mp inferInstance\n  refine le_antisymm (iSup_ucs_le_weightSpace_zero R L M) (le_trans hk ?_)\n  exact le_iSup (fun k \u21a6 (\u22a5 : LieSubmodule R L M).ucs k) k", "start": [253, 1], "end": [259, 59], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingCompOf", "code": "def posFittingCompOf (x : L) : LieSubmodule R L M :=\n  { toSubmodule := \u2a05 k, LinearMap.range (toEndomorphism R L M x ^ k)\n    lie_mem := by\n      set \u03c6 := toEndomorphism R L M x\n      intros y m hm\n      simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,\n        Submodule.mem_toAddSubmonoid, Submodule.mem_iInf, LinearMap.mem_range] at hm \u22a2\n      intro k\n      obtain \u27e8N, hN\u27e9 := LieAlgebra.nilpotent_ad_of_nilpotent_algebra R L\n      obtain \u27e8m, rfl\u27e9 := hm (N + k)\n      let f\u2081 : Module.End R (L \u2297[R] M) := (LieAlgebra.ad R L x).rTensor M\n      let f\u2082 : Module.End R (L \u2297[R] M) := \u03c6.lTensor L\n      replace hN : f\u2081 ^ N = 0 := by ext; simp [hN]\n      have h\u2081 : Commute f\u2081 f\u2082 := by ext; simp\n      have h\u2082 : \u03c6 \u2218\u2097 toModuleHom R L M = toModuleHom R L M \u2218\u2097 (f\u2081 + f\u2082) := by ext; simp\n      obtain \u27e8q, hq\u27e9 := h\u2081.add_pow_dvd_pow_of_pow_eq_zero_right (N + k).le_succ hN\n      use toModuleHom R L M (q (y \u2297\u209c m))\n      change (\u03c6 ^ k).comp ((toModuleHom R L M : L \u2297[R] M \u2192\u2097[R] M)) _ = _\n      simp [LinearMap.commute_pow_left_of_commute h\u2082, LinearMap.comp_apply (g := (f\u2081 + f\u2082) ^ k),\n        \u2190 LinearMap.comp_apply (g := q), \u2190 LinearMap.mul_eq_comp, \u2190 hq] }", "start": [263, 1], "end": [290, 74], "kind": "commanddeclaration"}, {"full_name": "LieModule.mem_posFittingCompOf", "code": "lemma mem_posFittingCompOf (x : L) (m : M) :\n    m \u2208 posFittingCompOf R M x \u2194 \u2200 (k : \u2115), \u2203 n, (toEndomorphism R L M x ^ k) n = m := by\n  simp [posFittingCompOf]", "start": [293, 1], "end": [295, 26], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingCompOf_le_lowerCentralSeries", "code": "@[simp] lemma posFittingCompOf_le_lowerCentralSeries (x : L) (k : \u2115) :\n    posFittingCompOf R M x \u2264 lowerCentralSeries R L M k := by\n  suffices : \u2200 m l, (toEndomorphism R L M x ^ l) m \u2208 lowerCentralSeries R L M l\n  \u00b7 intro m hm\n    obtain \u27e8n, rfl\u27e9 := (mem_posFittingCompOf R x m).mp hm k\n    exact this n k\n  intro m l\n  induction' l with l ih; simp\n  simp only [lowerCentralSeries_succ, pow_succ, LinearMap.mul_apply]\n  exact LieSubmodule.lie_mem_lie _ \u22a4 (LieSubmodule.mem_top x) ih", "start": [297, 1], "end": [306, 65], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingCompOf_eq_bot_of_isNilpotent", "code": "@[simp] lemma posFittingCompOf_eq_bot_of_isNilpotent\n    [IsNilpotent R L M] (x : L) :\n    posFittingCompOf R M x = \u22a5 := by\n  simp_rw [eq_bot_iff, \u2190 iInf_lowerCentralSeries_eq_bot_of_isNilpotent, le_iInf_iff,\n    posFittingCompOf_le_lowerCentralSeries, forall_const]", "start": [308, 1], "end": [312, 58], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingComp", "code": "def posFittingComp : LieSubmodule R L M :=\n  \u2a06 x, posFittingCompOf R M x", "start": [316, 1], "end": [322, 30], "kind": "commanddeclaration"}, {"full_name": "LieModule.mem_posFittingComp", "code": "lemma mem_posFittingComp (m : M) :\n    m \u2208 posFittingComp R L M \u2194 m \u2208 \u2a06 (x : L), posFittingCompOf R M x := by\n  rfl", "start": [324, 1], "end": [326, 6], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingCompOf_le_posFittingComp", "code": "lemma posFittingCompOf_le_posFittingComp (x : L) :\n    posFittingCompOf R M x \u2264 posFittingComp R L M := by\n  rw [posFittingComp]; exact le_iSup (posFittingCompOf R M) x", "start": [328, 1], "end": [330, 62], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingComp_le_iInf_lowerCentralSeries", "code": "lemma posFittingComp_le_iInf_lowerCentralSeries :\n    posFittingComp R L M \u2264 \u2a05 k, lowerCentralSeries R L M k := by\n  simp [posFittingComp]", "start": [332, 1], "end": [334, 24], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.iInf_lowerCentralSeries_eq_posFittingComp", "code": "@[simp] lemma iInf_lowerCentralSeries_eq_posFittingComp\n    [IsNoetherian R M] [IsArtinian R M] :\n    \u2a05 k, lowerCentralSeries R L M k = posFittingComp R L M := by\n  refine le_antisymm ?_ (posFittingComp_le_iInf_lowerCentralSeries R L M)\n  apply iInf_lcs_le_of_isNilpotent_quot\n  rw [LieModule.isNilpotent_iff_forall']\n  intro x\n  obtain \u27e8k, hk\u27e9 := Filter.eventually_atTop.mp (toEndomorphism R L M x).eventually_iInf_range_pow_eq\n  use k\n  ext \u27e8m\u27e9\n  set F := posFittingComp R L M\n  replace hk : (toEndomorphism R L M x ^ k) m \u2208 F := by\n    apply posFittingCompOf_le_posFittingComp R L M x\n    simp_rw [\u2190 LieSubmodule.mem_coeSubmodule, posFittingCompOf, hk k (le_refl k)]\n    apply LinearMap.mem_range_self\n  suffices (toEndomorphism R L (M \u29f8 F) x ^ k) (LieSubmodule.Quotient.mk (N := F) m) =\n    LieSubmodule.Quotient.mk (N := F) ((toEndomorphism R L M x ^ k) m) by simpa [this]\n  have := LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute\n    (LieSubmodule.Quotient.toEndomorphism_comp_mk' F x) k) m\n  simpa using this", "start": [336, 1], "end": [356, 19], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingComp_eq_bot_of_isNilpotent", "code": "@[simp] lemma posFittingComp_eq_bot_of_isNilpotent\n    [IsNilpotent R L M] :\n    posFittingComp R L M = \u22a5 := by\n  simp [posFittingComp]", "start": [358, 1], "end": [361, 24], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.map_posFittingComp_le", "code": "lemma map_posFittingComp_le :\n    (posFittingComp R L M).map f \u2264 posFittingComp R L M\u2082 := by\n  rw [posFittingComp, posFittingComp, LieSubmodule.map_iSup]\n  refine iSup_mono fun y \u21a6 LieSubmodule.map_le_iff_le_comap.mpr fun m hm \u21a6 ?_\n  simp only [mem_posFittingCompOf] at hm\n  simp only [LieSubmodule.mem_comap, mem_posFittingCompOf]\n  intro k\n  obtain \u27e8n, hn\u27e9 := hm k\n  use f n\n  rw [LieModule.toEndomorphism_pow_apply_map, hn]", "start": [370, 1], "end": [379, 50], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.map_weightSpace_le", "code": "lemma map_weightSpace_le :\n    (weightSpace M \u03c7).map f \u2264 weightSpace M\u2082 \u03c7 := by\n  rw [LieSubmodule.map_le_iff_le_comap]\n  intro m hm\n  simp only [LieSubmodule.mem_comap, mem_weightSpace]\n  intro x\n  have : (toEndomorphism R L M\u2082 x - \u03c7 x \u2022 \u21911) \u2218\u2097 f = f \u2218\u2097 (toEndomorphism R L M x - \u03c7 x \u2022 \u21911) := by\n    ext; simp\n  obtain \u27e8k, h\u27e9 := (mem_weightSpace _ _ _).mp hm x\n  exact \u27e8k, by simpa [h] using LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute this k) m\u27e9", "start": [381, 1], "end": [390, 101], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.comap_weightSpace_eq_of_injective", "code": "lemma comap_weightSpace_eq_of_injective (hf : Function.Injective f) :\n    (weightSpace M\u2082 \u03c7).comap f = weightSpace M \u03c7 := by\n  refine le_antisymm (fun m hm \u21a6 ?_) ?_\n  \u00b7 simp only [LieSubmodule.mem_comap, mem_weightSpace] at hm\n    simp only [mem_weightSpace]\n    intro x\n    have h : (toEndomorphism R L M\u2082 x - \u03c7 x \u2022 \u21911) \u2218\u2097 f =\n             f \u2218\u2097 (toEndomorphism R L M x - \u03c7 x \u2022 \u21911) := by ext; simp\n    obtain \u27e8k, hk\u27e9 := hm x\n    use k\n    suffices : f (((toEndomorphism R L M x - \u03c7 x \u2022 \u21911) ^ k) m) = 0\n    \u00b7 rw [\u2190 f.map_zero] at this; exact hf this\n    simpa [hk] using (LinearMap.congr_fun (LinearMap.commute_pow_left_of_commute h k) m).symm\n  \u00b7 rw [\u2190 LieSubmodule.map_le_iff_le_comap]\n    exact map_weightSpace_le f", "start": [394, 1], "end": [408, 31], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.map_weightSpace_eq_of_injective", "code": "lemma map_weightSpace_eq_of_injective (hf : Function.Injective f) :\n    (weightSpace M \u03c7).map f = weightSpace M\u2082 \u03c7 \u2293 f.range := by\n  refine le_antisymm (le_inf_iff.mpr \u27e8map_weightSpace_le f, LieSubmodule.map_le_range f\u27e9) ?_\n  rintro - \u27e8hm, \u27e8m, rfl\u27e9\u27e9\n  simp only [\u2190 comap_weightSpace_eq_of_injective hf, LieSubmodule.mem_map, LieSubmodule.mem_comap]\n  exact \u27e8m, hm, rfl\u27e9", "start": [410, 1], "end": [415, 21], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.map_weightSpace_eq", "code": "lemma map_weightSpace_eq (e : M \u2243\u2097\u2045R,L\u2046 M\u2082) :\n    (weightSpace M \u03c7).map e = weightSpace M\u2082 \u03c7 := by\n  simp [map_weightSpace_eq_of_injective e.injective]", "start": [417, 1], "end": [419, 53], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.map_posFittingComp_eq", "code": "lemma map_posFittingComp_eq (e : M \u2243\u2097\u2045R,L\u2046 M\u2082) :\n    (posFittingComp R L M).map e = posFittingComp R L M\u2082 := by\n  refine le_antisymm (map_posFittingComp_le _) ?_\n  suffices posFittingComp R L M\u2082 = ((posFittingComp R L M\u2082).map (e.symm : M\u2082 \u2192\u2097\u2045R,L\u2046 M)).map e by\n    rw [this]\n    exact LieSubmodule.map_mono (map_posFittingComp_le _)\n  rw [\u2190 LieSubmodule.map_comp]\n  convert LieSubmodule.map_id\n  ext\n  simp", "start": [421, 1], "end": [430, 7], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.posFittingComp_map_incl_sup_of_codisjoint", "code": "lemma posFittingComp_map_incl_sup_of_codisjoint [IsNoetherian R M] [IsArtinian R M]\n    {N\u2081 N\u2082 : LieSubmodule R L M} (h : Codisjoint N\u2081 N\u2082) :\n    (posFittingComp R L N\u2081).map N\u2081.incl \u2294 (posFittingComp R L N\u2082).map N\u2082.incl =\n    posFittingComp R L M := by\n  obtain \u27e8l, hl\u27e9 := Filter.eventually_atTop.mp <|\n    (eventually_iInf_lowerCentralSeries_eq R L N\u2081).and <|\n    (eventually_iInf_lowerCentralSeries_eq R L N\u2082).and\n    (eventually_iInf_lowerCentralSeries_eq R L M)\n  obtain \u27e8hl\u2081, hl\u2082, hl\u2083\u27e9 := hl l (le_refl _)\n  simp_rw [\u2190 iInf_lowerCentralSeries_eq_posFittingComp, hl\u2081, hl\u2082, hl\u2083,\n    LieSubmodule.lowerCentralSeries_map_eq_lcs, \u2190LieSubmodule.lcs_sup, lowerCentralSeries, h.eq_top]", "start": [432, 1], "end": [442, 101], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.isCompl_weightSpaceOf_zero_posFittingCompOf", "code": "lemma isCompl_weightSpaceOf_zero_posFittingCompOf (x : L) :\n    IsCompl (weightSpaceOf M 0 x) (posFittingCompOf R M x) := by\n  simpa only [isCompl_iff, codisjoint_iff, disjoint_iff, \u2190 LieSubmodule.coe_toSubmodule_eq_iff,\n    LieSubmodule.sup_coe_toSubmodule, LieSubmodule.inf_coe_toSubmodule,\n    LieSubmodule.top_coeSubmodule, LieSubmodule.bot_coeSubmodule, coe_weightSpaceOf_zero] using\n    (toEndomorphism R L M x).isCompl_iSup_ker_pow_iInf_range_pow", "start": [450, 1], "end": [455, 65], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.isCompl_weightSpace_zero_posFittingComp_aux", "code": "private lemma isCompl_weightSpace_zero_posFittingComp_aux\n    (h : \u2200 N < (\u22a4 : LieSubmodule R L M), IsCompl (weightSpace N 0) (posFittingComp R L N)) :\n    IsCompl (weightSpace M 0) (posFittingComp R L M) := by\n  set M\u2080 := weightSpace M (0 : L \u2192 R)\n  set M\u2081 := posFittingComp R L M\n  rcases forall_or_exists_not (fun (x : L) \u21a6 weightSpaceOf M (0 : R) x = \u22a4)\n    with h | \u27e8x, hx : weightSpaceOf M (0 : R) x \u2260 \u22a4\u27e9\n  \u00b7 suffices IsNilpotent R L M by simp [isCompl_top_bot]\n    replace h : M\u2080 = \u22a4 := by simpa [weightSpace]\n    rw [\u2190 LieModule.isNilpotent_of_top_iff', \u2190 h]\n    infer_instance\n  \u00b7 set M\u2080\u2093 := weightSpaceOf M (0 : R) x\n    set M\u2081\u2093 := posFittingCompOf R M x\n    set M\u2080\u2093\u2080 := weightSpace M\u2080\u2093 (0 : L \u2192 R)\n    set M\u2080\u2093\u2081 := posFittingComp R L M\u2080\u2093\n    have h\u2080 : Function.Injective (LieSubmodule.incl M\u2080\u2093) := Subtype.coe_injective\n    have h\u2081 : IsCompl M\u2080\u2093 M\u2081\u2093 := isCompl_weightSpaceOf_zero_posFittingCompOf R L M x\n    have h\u2082 : IsCompl M\u2080\u2093\u2080 M\u2080\u2093\u2081 := h M\u2080\u2093 hx.lt_top\n    have h\u2083 : M\u2080\u2093\u2080.map M\u2080\u2093.incl = M\u2080 := by\n      rw [map_weightSpace_eq_of_injective h\u2080, inf_eq_left, LieSubmodule.range_incl]\n      exact iInf_le _ x\n    have h\u2084 : M\u2080\u2093\u2081.map M\u2080\u2093.incl \u2294 M\u2081\u2093 = M\u2081 := by\n      apply le_antisymm <| sup_le_iff.mpr\n        \u27e8map_posFittingComp_le _, posFittingCompOf_le_posFittingComp R L M x\u27e9\n      rw [\u2190 posFittingComp_map_incl_sup_of_codisjoint h\u2081.codisjoint]\n      exact sup_le_sup_left LieSubmodule.map_incl_le _\n    rw [\u2190 h\u2083, \u2190 h\u2084]\n    apply Disjoint.isCompl_sup_right_of_isCompl_sup_left\n    \u00b7 rw [disjoint_iff, \u2190 LieSubmodule.map_inf h\u2080, h\u2082.inf_eq_bot, LieSubmodule.map_bot]\n    \u00b7 rwa [\u2190 LieSubmodule.map_sup, h\u2082.sup_eq_top, LieModuleHom.map_top, LieSubmodule.range_incl]", "start": [457, 1], "end": [488, 97], "kind": "mathlibtacticlemma"}, {"full_name": "LieModule.isCompl_weightSpace_zero_posFittingComp", "code": "lemma isCompl_weightSpace_zero_posFittingComp :\n    IsCompl (weightSpace M 0) (posFittingComp R L M) := by\n  let P : LieSubmodule R L M \u2192 Prop := fun N \u21a6 IsCompl (weightSpace N 0) (posFittingComp R L N)\n  suffices : P \u22a4\n  \u00b7 let e := LieModuleEquiv.ofTop R L M\n    rw [\u2190 map_weightSpace_eq e, \u2190 map_posFittingComp_eq e]\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mp this\n  refine (LieSubmodule.wellFounded_of_isArtinian R L M).induction (C := P) _ fun N hN \u21a6 ?_\n  refine isCompl_weightSpace_zero_posFittingComp_aux R L N fun N' hN' \u21a6 ?_\n  suffices : IsCompl (weightSpace (N'.map N.incl) 0) (posFittingComp R L (N'.map N.incl))\n  \u00b7 have h_inj : Function.Injective N.incl := Subtype.coe_injective\n    let e := LieSubmodule.equivMapOfInjective N' h_inj\n    rw [\u2190 map_weightSpace_eq e, \u2190 map_posFittingComp_eq e] at this\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mpr this\n  exact hN _ (LieSubmodule.map_incl_lt_iff_lt_top.mpr hN')", "start": [490, 1], "end": [505, 59], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Lie/CartanSubalgebra.lean", "imports": ["Mathlib/Algebra/Lie/Nilpotent.lean", "Mathlib/Algebra/Lie/Normalizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieSubmodule.IsUcsLimit", "code": "def LieSubmodule.IsUcsLimit {M : Type*} [AddCommGroup M] [Module R M] [LieRingModule L M]\n    [LieModule R L M] (N : LieSubmodule R L M) : Prop :=\n  \u2203 k, \u2200 l, k \u2264 l \u2192 (\u22a5 : LieSubmodule R L M).ucs l = N", "start": [35, 1], "end": [42, 55], "kind": "commanddeclaration"}, {"full_name": "LieSubalgebra.IsCartanSubalgebra", "code": "class IsCartanSubalgebra : Prop where\n  nilpotent : LieAlgebra.IsNilpotent R H\n  self_normalizing : H.normalizer = H", "start": [47, 1], "end": [50, 38], "kind": "commanddeclaration"}, {"full_name": "LieSubalgebra.normalizer_eq_self_of_isCartanSubalgebra", "code": "@[simp]\ntheorem normalizer_eq_self_of_isCartanSubalgebra (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    H.toLieSubmodule.normalizer = H.toLieSubmodule", "start": [56, 1], "end": [60, 61], "kind": "commanddeclaration"}, {"full_name": "LieSubalgebra.ucs_eq_self_of_isCartanSubalgebra", "code": "@[simp]\ntheorem ucs_eq_self_of_isCartanSubalgebra (H : LieSubalgebra R L) [H.IsCartanSubalgebra] (k : \u2115) :\n    H.toLieSubmodule.ucs k = H.toLieSubmodule", "start": [63, 1], "end": [68, 14], "kind": "commanddeclaration"}, {"full_name": "LieSubalgebra.isCartanSubalgebra_iff_isUcsLimit", "code": "theorem isCartanSubalgebra_iff_isUcsLimit : H.IsCartanSubalgebra \u2194 H.toLieSubmodule.IsUcsLimit", "start": [71, 1], "end": [93, 53], "kind": "commanddeclaration"}, {"full_name": "LieIdeal.normalizer_eq_top", "code": "@[simp]\ntheorem LieIdeal.normalizer_eq_top {R : Type u} {L : Type v} [CommRing R] [LieRing L]\n    [LieAlgebra R L] (I : LieIdeal R L) : (I : LieSubalgebra R L).normalizer = \u22a4", "start": [98, 1], "end": [103, 29], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.top_isCartanSubalgebra_of_nilpotent", "code": "instance LieAlgebra.top_isCartanSubalgebra_of_nilpotent [LieAlgebra.IsNilpotent R L] :\n    LieSubalgebra.IsCartanSubalgebra (\u22a4 : LieSubalgebra R L) where\n  nilpotent := inferInstance\n  self_normalizing := by rw [\u2190 top_coe_lieSubalgebra, normalizer_eq_top, top_coe_lieSubalgebra]", "start": [108, 1], "end": [112, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/Character.lean", "imports": ["Mathlib/Algebra/Lie/Abelian.lean", "Mathlib/LinearAlgebra/Dual.lean", "Mathlib/Algebra/Lie/Solvable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LieAlgebra.LieCharacter", "code": "abbrev LieCharacter :=\n  L \u2192\u2097\u2045R\u2046 R", "start": [36, 1], "end": [38, 12], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.lieCharacter_apply_lie", "code": "theorem lieCharacter_apply_lie (\u03c7 : LieCharacter R L) (x y : L) : \u03c7 \u2045x, y\u2046 = 0", "start": [44, 1], "end": [45, 79], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.lieCharacter_apply_lie'", "code": "@[simp]\ntheorem lieCharacter_apply_lie' (\u03c7 : LieCharacter R L) (x y : L) : \u2045\u03c7 x, \u03c7 y\u2046 = 0", "start": [48, 1], "end": [50, 63], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.lieCharacter_apply_of_mem_derived", "code": "theorem lieCharacter_apply_of_mem_derived (\u03c7 : LieCharacter R L) {x : L}\n    (h : x \u2208 derivedSeries R L 1) : \u03c7 x = 0", "start": [52, 1], "end": [60, 54], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.lieCharacterEquivLinearDual", "code": "@[simps! apply symm_apply]\ndef lieCharacterEquivLinearDual [IsLieAbelian L] : LieCharacter R L \u2243 Module.Dual R L where\n  toFun \u03c7 := (\u03c7 : L \u2192\u2097[R] R)\n  invFun \u03c8 :=\n    { \u03c8 with\n      map_lie' := fun {x y} => by\n        rw [LieModule.IsTrivial.trivial, LieRing.of_associative_ring_bracket, mul_comm, sub_self,\n          LinearMap.toFun_eq_coe, LinearMap.map_zero] }\n  left_inv \u03c7 := by ext; rfl\n  right_inv \u03c8 := by ext; rfl", "start": [63, 1], "end": [73, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/UniversalEnveloping.lean", "imports": ["Mathlib/Algebra/RingQuot.lean", "Mathlib/LinearAlgebra/TensorAlgebra/Basic.lean", "Mathlib/Algebra/Lie/OfAssociative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniversalEnvelopingAlgebra.Rel", "code": "inductive Rel : TensorAlgebra R L \u2192 TensorAlgebra R L \u2192 Prop\n  | lie_compat (x y : L) : Rel (\u03b9\u209c \u2045x, y\u2046 + \u03b9\u209c y * \u03b9\u209c x) (\u03b9\u209c x * \u03b9\u209c y)", "start": [49, 1], "end": [55, 71], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra", "code": "def UniversalEnvelopingAlgebra :=\n  RingQuot (UniversalEnvelopingAlgebra.Rel R L)", "start": [60, 1], "end": [62, 48], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.instInhabited", "code": "instance instInhabited : Inhabited (UniversalEnvelopingAlgebra R L) :=\n  inferInstanceAs (Inhabited (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))", "start": [70, 1], "end": [71, 78], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.instRing", "code": "instance instRing : Ring (UniversalEnvelopingAlgebra R L) :=\n  inferInstanceAs (Ring (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))", "start": [74, 1], "end": [75, 73], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.instAlgebra", "code": "instance instAlgebra : Algebra R (UniversalEnvelopingAlgebra R L) :=\n  inferInstanceAs (Algebra R (RingQuot (UniversalEnvelopingAlgebra.Rel R L)))", "start": [78, 1], "end": [79, 78], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.mkAlgHom", "code": "def mkAlgHom : TensorAlgebra R L \u2192\u2090[R] UniversalEnvelopingAlgebra R L :=\n  RingQuot.mkAlgHom R (Rel R L)", "start": [83, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.\u03b9", "code": "@[simps!] def \u03b9 : L \u2192\u2097\u2045R\u2046 UniversalEnvelopingAlgebra R L :=\n  { (mkAlgHom R L).toLinearMap.comp \u03b9\u209c with\n    map_lie' := fun {x y} => by\n      suffices mkAlgHom R L (\u03b9\u209c \u2045x, y\u2046 + \u03b9\u209c y * \u03b9\u209c x) = mkAlgHom R L (\u03b9\u209c x * \u03b9\u209c y) by\n        rw [AlgHom.map_mul] at this; simp [LieRing.of_associative_ring_bracket, \u2190 this]\n      exact RingQuot.mkAlgHom_rel _ (Rel.lie_compat x y) }", "start": [91, 1], "end": [98, 59], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.lift", "code": "def lift : (L \u2192\u2097\u2045R\u2046 A) \u2243 (UniversalEnvelopingAlgebra R L \u2192\u2090[R] A) where\n  toFun f :=\n    RingQuot.liftAlgHom R\n      \u27e8TensorAlgebra.lift R (f : L \u2192\u2097[R] A), by\n        intro a b h; induction' h with x y\n        simp only [LieRing.of_associative_ring_bracket, map_add, TensorAlgebra.lift_\u03b9_apply,\n          LieHom.coe_toLinearMap, LieHom.map_lie, map_mul, sub_add_cancel]\u27e9\n  invFun F := (F : UniversalEnvelopingAlgebra R L \u2192\u2097\u2045R\u2046 A).comp (\u03b9 R)\n  left_inv f := by\n    ext\n    simp only [LieHom.coe_comp, Function.comp_apply, AlgHom.coe_toLieHom,\n      UniversalEnvelopingAlgebra.\u03b9_apply, mkAlgHom]\n    erw [RingQuot.liftAlgHom_mkAlgHom_apply]\n    simp only [TensorAlgebra.lift_\u03b9_apply, LieHom.coe_toLinearMap]\n  right_inv F := by\n    apply RingQuot.ringQuot_ext'\n    ext\n    simp [mkAlgHom]; rfl", "start": [103, 1], "end": [134, 25], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : UniversalEnvelopingAlgebra R L \u2192\u2090[R] A) :\n    (lift R).symm F = (F : UniversalEnvelopingAlgebra R L \u2192\u2097\u2045R\u2046 A).comp (\u03b9 R)", "start": [137, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.\u03b9_comp_lift", "code": "@[simp]\ntheorem \u03b9_comp_lift : lift R f \u2218 \u03b9 R = f", "start": [143, 1], "end": [145, 61], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.lift_\u03b9_apply", "code": "theorem lift_\u03b9_apply (x : L) : lift R f (\u03b9 R x) = f x", "start": [149, 1], "end": [150, 78], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.lift_\u03b9_apply'", "code": "@[simp]\ntheorem lift_\u03b9_apply' (x : L) :\n    lift R f ((UniversalEnvelopingAlgebra.mkAlgHom R L) (\u03b9\u209c x)) = f x", "start": [153, 1], "end": [156, 33], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.lift_unique", "code": "theorem lift_unique (g : UniversalEnvelopingAlgebra R L \u2192\u2090[R] A) : g \u2218 \u03b9 R = f \u2194 g = lift R f", "start": [158, 1], "end": [160, 45], "kind": "commanddeclaration"}, {"full_name": "UniversalEnvelopingAlgebra.hom_ext", "code": "@[ext]\ntheorem hom_ext {g\u2081 g\u2082 : UniversalEnvelopingAlgebra R L \u2192\u2090[R] A}\n    (h :\n      (g\u2081 : UniversalEnvelopingAlgebra R L \u2192\u2097\u2045R\u2046 A).comp (\u03b9 R) =\n        (g\u2082 : UniversalEnvelopingAlgebra R L \u2192\u2097\u2045R\u2046 A).comp (\u03b9 R)) :\n    g\u2081 = g\u2082", "start": [163, 1], "end": [171, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/NonUnitalNonAssocAlgebra.lean", "imports": ["Mathlib/Algebra/Lie/Basic.lean", "Mathlib/Algebra/Hom/NonUnitalAlg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CommutatorRing", "code": "def CommutatorRing (L : Type v) : Type v := L", "start": [42, 1], "end": [46, 46], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.isScalarTower", "code": "instance isScalarTower : IsScalarTower R (CommutatorRing L) (CommutatorRing L) := \u27e8smul_lie\u27e9", "start": [70, 1], "end": [72, 93], "kind": "commanddeclaration"}, {"full_name": "LieAlgebra.smulCommClass", "code": "instance smulCommClass : SMulCommClass R (CommutatorRing L) (CommutatorRing L) :=\n  \u27e8fun t x y => (lie_smul t x y).symm\u27e9", "start": [75, 1], "end": [78, 39], "kind": "commanddeclaration"}, {"full_name": "LieHom.toNonUnitalAlgHom", "code": "@[simps]\ndef toNonUnitalAlgHom (f : L \u2192\u2097\u2045R\u2046 L\u2082) : CommutatorRing L \u2192\u2099\u2090[R] CommutatorRing L\u2082 :=\n  { f with\n    toFun := f\n    map_zero' := f.map_zero\n    map_mul' := f.map_lie }", "start": [88, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "LieHom.toNonUnitalAlgHom_injective", "code": "theorem toNonUnitalAlgHom_injective :\n    Function.Injective (toNonUnitalAlgHom : _ \u2192 CommutatorRing L \u2192\u2099\u2090[R] CommutatorRing L\u2082)", "start": [98, 1], "end": [100, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/FreeNonUnitalNonAssocAlgebra.lean", "imports": ["Mathlib/Algebra/Free.lean", "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FreeNonUnitalNonAssocAlgebra", "code": "abbrev FreeNonUnitalNonAssocAlgebra :=\n  MonoidAlgebra R (FreeMagma X)", "start": [47, 1], "end": [49, 32], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.of", "code": "def of : X \u2192 FreeNonUnitalNonAssocAlgebra R X :=\n  MonoidAlgebra.ofMagma R _ \u2218 FreeMagma.of", "start": [56, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.lift", "code": "def lift : (X \u2192 A) \u2243 (FreeNonUnitalNonAssocAlgebra R X \u2192\u2099\u2090[R] A) :=\n  FreeMagma.lift.trans (MonoidAlgebra.liftMagma R)", "start": [65, 1], "end": [69, 51], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : FreeNonUnitalNonAssocAlgebra R X \u2192\u2099\u2090[R] A) :\n    (lift R).symm F = F \u2218 of R", "start": [72, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.of_comp_lift", "code": "@[simp]\ntheorem of_comp_lift (f : X \u2192 A) : lift R f \u2218 of R = f", "start": [77, 1], "end": [79, 22], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.lift_unique", "code": "@[simp]\ntheorem lift_unique (f : X \u2192 A) (F : FreeNonUnitalNonAssocAlgebra R X \u2192\u2099\u2090[R] A) :\n    F \u2218 of R = f \u2194 F = lift R f", "start": [82, 1], "end": [85, 25], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.lift_of_apply", "code": "@[simp]\ntheorem lift_of_apply (f : X \u2192 A) (x) : lift R f (of R x) = f x", "start": [88, 1], "end": [90, 33], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.lift_comp_of", "code": "@[simp]\ntheorem lift_comp_of (F : FreeNonUnitalNonAssocAlgebra R X \u2192\u2099\u2090[R] A) : lift R (F \u2218 of R) = F", "start": [93, 1], "end": [95, 30], "kind": "commanddeclaration"}, {"full_name": "FreeNonUnitalNonAssocAlgebra.hom_ext", "code": "@[ext]\ntheorem hom_ext {F\u2081 F\u2082 : FreeNonUnitalNonAssocAlgebra R X \u2192\u2099\u2090[R] A}\n    (h : \u2200 x, F\u2081 (of R x) = F\u2082 (of R x)) : F\u2081 = F\u2082", "start": [98, 1], "end": [101, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Spectral/Hom.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSpectralMap", "code": "structure IsSpectralMap (f : \u03b1 \u2192 \u03b2) extends Continuous f : Prop where\n  \n  isCompact_preimage_of_isOpen \u2983s : Set \u03b2\u2984 : IsOpen s \u2192 IsCompact s \u2192 IsCompact (f \u207b\u00b9' s)", "start": [36, 1], "end": [41, 90], "kind": "commanddeclaration"}, {"full_name": "IsCompact.preimage_of_isOpen", "code": "theorem IsCompact.preimage_of_isOpen (hf : IsSpectralMap f) (h\u2080 : IsCompact s) (h\u2081 : IsOpen s) :\n    IsCompact (f \u207b\u00b9' s)", "start": [44, 1], "end": [46, 40], "kind": "commanddeclaration"}, {"full_name": "IsSpectralMap.continuous", "code": "theorem IsSpectralMap.continuous {f : \u03b1 \u2192 \u03b2} (hf : IsSpectralMap f) : Continuous f", "start": [49, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "isSpectralMap_id", "code": "theorem isSpectralMap_id : IsSpectralMap (@id \u03b1)", "start": [53, 1], "end": [54, 34], "kind": "commanddeclaration"}, {"full_name": "IsSpectralMap.comp", "code": "theorem IsSpectralMap.comp {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} (hf : IsSpectralMap f) (hg : IsSpectralMap g) :\n    IsSpectralMap (f \u2218 g)", "start": [57, 1], "end": [60, 90], "kind": "commanddeclaration"}, {"full_name": "SpectralMap", "code": "structure SpectralMap (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  spectral' : IsSpectralMap toFun", "start": [65, 1], "end": [70, 34], "kind": "commanddeclaration"}, {"full_name": "SpectralMapClass", "code": "class SpectralMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1]\n  [TopologicalSpace \u03b2] extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_spectral (f : F) : IsSpectralMap f", "start": [75, 1], "end": [81, 41], "kind": "commanddeclaration"}, {"full_name": "SpectralMapClass.toContinuousMapClass", "code": "instance (priority := 100) SpectralMapClass.toContinuousMapClass [TopologicalSpace \u03b1]\n    [TopologicalSpace \u03b2] [SpectralMapClass F \u03b1 \u03b2] : ContinuousMapClass F \u03b1 \u03b2 :=\n  { \u2039SpectralMapClass F \u03b1 \u03b2\u203a with map_continuous := fun f => (map_spectral f).continuous }", "start": [91, 1], "end": [93, 91], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.toContinuousMap", "code": "def toContinuousMap (f : SpectralMap \u03b1 \u03b2) : ContinuousMap \u03b1 \u03b2 :=\n  \u27e8_, f.spectral'.continuous\u27e9", "start": [107, 1], "end": [109, 30], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe {f : SpectralMap \u03b1 \u03b2} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.ext", "code": "@[ext]\ntheorem ext {f g : SpectralMap \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [129, 1], "end": [131, 20], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.copy", "code": "protected def copy (f : SpectralMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : SpectralMap \u03b1 \u03b2 :=\n  \u27e8f', h.symm.subst f.spectral'\u27e9", "start": [134, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : SpectralMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.copy_eq", "code": "theorem copy_eq (f : SpectralMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [145, 1], "end": [146, 17], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.id", "code": "protected def id : SpectralMap \u03b1 \u03b1 :=\n  \u27e8id, isSpectralMap_id\u27e9", "start": [151, 1], "end": [153, 25], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(SpectralMap.id \u03b1) = id", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : SpectralMap.id \u03b1 a = a", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.comp", "code": "def comp (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) : SpectralMap \u03b1 \u03b3 :=\n  \u27e8f.toContinuousMap.comp g.toContinuousMap, f.spectral'.comp g.spectral'\u27e9", "start": [171, 1], "end": [173, 75], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.coe_comp_continuousMap", "code": "@[simp]\ntheorem coe_comp_continuousMap (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) :\n    (f \u2218 g)= (f : ContinuousMap \u03b2 \u03b3) \u2218 (g: ContinuousMap \u03b1 \u03b2)", "start": [186, 1], "end": [189, 7], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.coe_comp_continuousMap'", "code": "theorem coe_comp_continuousMap' (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) :\n    (f.comp g : ContinuousMap \u03b1 \u03b3) = (f : ContinuousMap \u03b2 \u03b3).comp g", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : SpectralMap \u03b3 \u03b4) (g : SpectralMap \u03b2 \u03b3) (h : SpectralMap \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [197, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : SpectralMap \u03b1 \u03b2) : f.comp (SpectralMap.id \u03b1) = f", "start": [203, 1], "end": [205, 20], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : SpectralMap \u03b1 \u03b2) : (SpectralMap.id \u03b2).comp f = f", "start": [208, 1], "end": [210, 20], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : SpectralMap \u03b2 \u03b3} {f : SpectralMap \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [213, 1], "end": [217, 50], "kind": "commanddeclaration"}, {"full_name": "SpectralMap.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : SpectralMap \u03b2 \u03b3} {f\u2081 f\u2082 : SpectralMap \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [220, 1], "end": [223, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Limits.lean", "imports": ["Mathlib/AlgebraicGeometry/Pullbacks.lean", "Mathlib/AlgebraicGeometry/AffineScheme.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgebraicGeometry.specZIsTerminal", "code": "noncomputable def specZIsTerminal : IsTerminal (Scheme.Spec.obj (op <| CommRingCat.of \u2124)) :=\n  @IsTerminal.isTerminalObj _ _ _ _ Scheme.Spec _ inferInstance\n    (terminalOpOfInitial CommRingCat.zIsInitial)", "start": [37, 1], "end": [40, 49], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.emptyTo", "code": "@[simps]\ndef Scheme.emptyTo (X : Scheme.{u}) : \u2205 \u27f6 X :=\n  \u27e8{  base := \u27e8fun x => PEmpty.elim x, by continuity\u27e9\n      c := { app := fun U => CommRingCat.punitIsTerminal.from _ } }, fun x => PEmpty.elim x\u27e9", "start": [54, 1], "end": [58, 93], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.empty_ext", "code": "@[ext]\ntheorem Scheme.empty_ext {X : Scheme.{u}} (f g : \u2205 \u27f6 X) : f = g", "start": [61, 1], "end": [66, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.eq_emptyTo", "code": "theorem Scheme.eq_emptyTo {X : Scheme.{u}} (f : \u2205 \u27f6 X) : f = Scheme.emptyTo X", "start": [69, 1], "end": [70, 40], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.Scheme.hom_unique_of_empty_source", "code": "instance Scheme.hom_unique_of_empty_source (X : Scheme.{u}) : Unique (\u2205 \u27f6 X) :=\n  \u27e8\u27e8Scheme.emptyTo _\u27e9, fun _ => Scheme.empty_ext _ _\u27e9", "start": [73, 1], "end": [74, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.emptyIsInitial", "code": "def emptyIsInitial : IsInitial (\u2205 : Scheme.{u}) :=\n  IsInitial.ofUnique _", "start": [76, 1], "end": [78, 23], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.emptyIsInitial_to", "code": "@[simp]\ntheorem emptyIsInitial_to : emptyIsInitial.to = Scheme.emptyTo", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.spec_punit_isEmpty", "code": "instance spec_punit_isEmpty : IsEmpty (Scheme.Spec.obj (op <| CommRingCat.of PUnit)).carrier :=\n  inferInstanceAs <| IsEmpty (PrimeSpectrum PUnit)", "start": [89, 1], "end": [90, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isOpenImmersion_of_isEmpty", "code": "instance (priority := 100) isOpenImmersion_of_isEmpty {X Y : Scheme} (f : X \u27f6 Y)\n    [IsEmpty X.carrier] : IsOpenImmersion f := by\n  apply (config := { allowSynthFailures := true }) IsOpenImmersion.of_stalk_iso\n  \u00b7 apply openEmbedding_of_continuous_injective_open\n    \u00b7 continuity\n    \u00b7 rintro (i : X.carrier); exact isEmptyElim i\n    \u00b7 intro U _; convert isOpen_empty (\u03b1 := Y); ext; rw [Set.mem_empty_iff_false, iff_false_iff]\n      exact fun x => isEmptyElim (show X.carrier from x.choose)\n  \u00b7 rintro (i : X.carrier); exact isEmptyElim i", "start": [93, 1], "end": [101, 48], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isIso_of_isEmpty", "code": "instance (priority := 100) isIso_of_isEmpty {X Y : Scheme} (f : X \u27f6 Y) [IsEmpty Y.carrier] :\n    IsIso f := by\n  haveI : IsEmpty X.carrier := \u27e8fun x => isEmptyElim (show Y.carrier from f.1.base x)\u27e9\n  have : Epi f.1.base\n  \u00b7 rw [TopCat.epi_iff_surjective]; rintro (x : Y.carrier)\n    exact isEmptyElim x\n  apply IsOpenImmersion.to_iso", "start": [104, 1], "end": [110, 31], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isInitialOfIsEmpty", "code": "noncomputable def isInitialOfIsEmpty {X : Scheme} [IsEmpty X.carrier] : IsInitial X :=\n  emptyIsInitial.ofIso (asIso <| emptyIsInitial.to _)", "start": [113, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.specPunitIsInitial", "code": "noncomputable def specPunitIsInitial : IsInitial (Scheme.Spec.obj (op <| CommRingCat.of PUnit)) :=\n  emptyIsInitial.ofIso (asIso <| emptyIsInitial.to _)", "start": [118, 1], "end": [120, 54], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isAffine_of_isEmpty", "code": "instance (priority := 100) isAffine_of_isEmpty {X : Scheme} [IsEmpty X.carrier] : IsAffine X :=\n  isAffineOfIso\n    (inv (emptyIsInitial.to X) \u226b emptyIsInitial.to (Scheme.Spec.obj (op <| CommRingCat.of PUnit)))", "start": [123, 1], "end": [125, 99], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.initial_isEmpty", "code": "instance initial_isEmpty : IsEmpty (\u22a5_ Scheme).carrier :=\n  \u27e8fun x => ((initial.to Scheme.empty : _).1.base x).elim\u27e9", "start": [133, 1], "end": [134, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.bot_isAffineOpen", "code": "theorem bot_isAffineOpen (X : Scheme) : IsAffineOpen (\u22a5 : Opens X.carrier)", "start": [137, 1], "end": [143, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UrysohnsBounded.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Bounded.lean", "Mathlib/Topology/UrysohnsLemma.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "exists_bounded_zero_one_of_closed", "code": "theorem exists_bounded_zero_one_of_closed {X : Type*} [TopologicalSpace X] [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) :\n    \u2203 f : X \u2192\u1d47 \u211d, EqOn f 0 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1", "start": [28, 1], "end": [39, 78], "kind": "commanddeclaration"}, {"full_name": "exists_bounded_mem_Icc_of_closed_of_le", "code": "theorem exists_bounded_mem_Icc_of_closed_of_le {X : Type*} [TopologicalSpace X] [NormalSpace X]\n    {s t : Set X} (hs : IsClosed s) (ht : IsClosed t) (hd : Disjoint s t) {a b : \u211d} (hle : a \u2264 b) :\n    \u2203 f : X \u2192\u1d47 \u211d, EqOn f (Function.const X a) s \u2227 EqOn f (Function.const X b) t \u2227\n    \u2200 x, f x \u2208 Icc a b", "start": [42, 1], "end": [56, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/IsoIoo.lean", "imports": ["Mathlib/Order/Monotone/Odd.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "orderIsoIooNegOneOne", "code": "@[irreducible]\ndef orderIsoIooNegOneOne (k : Type*) [LinearOrderedField k] : k \u2243o Ioo (-1 : k) 1 := by\n  refine' StrictMono.orderIsoOfRightInverse _ _ (fun x \u21a6 x / (1 - |\u2191x|)) _\n  \u00b7 refine' codRestrict (fun x \u21a6 x / (1 + |x|)) _ fun x \u21a6 abs_lt.1 _\n    have H : 0 < 1 + |x| := (abs_nonneg x).trans_lt (lt_one_add _)\n    calc\n      |x / (1 + |x|)| = |x| / (1 + |x|) := by rw [abs_div, abs_of_pos H]\n      _ < 1 := (div_lt_one H).2 (lt_one_add _)\n  \u00b7 refine' (strictMono_of_odd_strictMonoOn_nonneg _ _).codRestrict _\n    \u00b7 intro x\n      simp only [abs_neg, neg_div]\n    \u00b7 rintro x (hx : 0 \u2264 x) y (hy : 0 \u2264 y) hxy\n      simp [abs_of_nonneg, mul_add, mul_comm x y, div_lt_div_iff, hx.trans_lt (lt_one_add _),\n        hy.trans_lt (lt_one_add _), *]\n  \u00b7 refine' fun x \u21a6 Subtype.ext _\n    have : 0 < 1 - |(x : k)| := sub_pos.2 (abs_lt.2 x.2)\n    field_simp [abs_div, this.ne', abs_of_pos this]", "start": [25, 1], "end": [44, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Setoid/Partition.lean", "imports": ["Mathlib/Order/Partition/Finpartition.lean", "Mathlib/Data/Setoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Basic.lean", "Mathlib/Data/Set/Finite.lean"], "premises": [{"full_name": "Setoid.eq_of_mem_eqv_class", "code": "theorem eq_of_mem_eqv_class {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) {x b b'}\n    (hc : b \u2208 c) (hb : x \u2208 b) (hc' : b' \u2208 c) (hb' : x \u2208 b') : b = b'", "start": [46, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "Setoid.mkClasses", "code": "def mkClasses (c : Set (Set \u03b1)) (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) : Setoid \u03b1 :=\n  \u27e8fun x y => \u2200 s \u2208 c, x \u2208 s \u2192 y \u2208 s,\n    \u27e8fun _ _ _ hx => hx, fun {x _y} h s hs hy =>\n      (H x).elim\u2082 fun t ht hx _ =>\n        have : s = t := eq_of_mem_eqv_class H hs hy ht (h t ht hx)\n        this.symm \u25b8 hx,\n      fun {_x y z} h1 h2 s hs hx =>\n      (H y).elim\u2082 fun t ht hy _ =>\n        (H z).elim\u2082 fun t' ht' hz _ =>\n          have hst : s = t := eq_of_mem_eqv_class H hs (h1 _ hs hx) ht hy\n          have htt' : t = t' := eq_of_mem_eqv_class H ht (h2 _ ht hy) ht' hz\n          (hst.trans htt').symm \u25b8 hz\u27e9\u27e9", "start": [54, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "Setoid.classes", "code": "def classes (r : Setoid \u03b1) : Set (Set \u03b1) :=\n  { s | \u2203 y, s = { x | r.Rel x y } }", "start": [69, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Setoid.mem_classes", "code": "theorem mem_classes (r : Setoid \u03b1) (y) : { x | r.Rel x y } \u2208 r.classes", "start": [74, 1], "end": [75, 11], "kind": "commanddeclaration"}, {"full_name": "Setoid.classes_ker_subset_fiber_set", "code": "theorem classes_ker_subset_fiber_set {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n    (Setoid.ker f).classes \u2286 Set.range fun y => { x | f x = y }", "start": [78, 1], "end": [82, 19], "kind": "commanddeclaration"}, {"full_name": "Setoid.finite_classes_ker", "code": "theorem finite_classes_ker {\u03b1 \u03b2 : Type*} [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) : (Setoid.ker f).classes.Finite", "start": [85, 1], "end": [86, 64], "kind": "commanddeclaration"}, {"full_name": "Setoid.card_classes_ker_le", "code": "theorem card_classes_ker_le {\u03b1 \u03b2 : Type*} [Fintype \u03b2] (f : \u03b1 \u2192 \u03b2)\n    [Fintype (Setoid.ker f).classes] : Fintype.card (Setoid.ker f).classes \u2264 Fintype.card \u03b2", "start": [89, 1], "end": [92, 98], "kind": "commanddeclaration"}, {"full_name": "Setoid.eq_iff_classes_eq", "code": "theorem eq_iff_classes_eq {r\u2081 r\u2082 : Setoid \u03b1} :\n    r\u2081 = r\u2082 \u2194 \u2200 x, { y | r\u2081.Rel x y } = { y | r\u2082.Rel x y }", "start": [95, 1], "end": [98, 69], "kind": "commanddeclaration"}, {"full_name": "Setoid.rel_iff_exists_classes", "code": "theorem rel_iff_exists_classes (r : Setoid \u03b1) {x y} : r.Rel x y \u2194 \u2203 c \u2208 r.classes, x \u2208 c \u2227 y \u2208 c", "start": [101, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "Setoid.classes_inj", "code": "theorem classes_inj {r\u2081 r\u2082 : Setoid \u03b1} : r\u2081 = r\u2082 \u2194 r\u2081.classes = r\u2082.classes", "start": [107, 1], "end": [109, 101], "kind": "commanddeclaration"}, {"full_name": "Setoid.empty_not_mem_classes", "code": "theorem empty_not_mem_classes {r : Setoid \u03b1} : \u2205 \u2209 r.classes", "start": [112, 1], "end": [114, 45], "kind": "commanddeclaration"}, {"full_name": "Setoid.classes_eqv_classes", "code": "theorem classes_eqv_classes {r : Setoid \u03b1} (a) : \u2203! (b : _) (_ : b \u2208 r.classes), a \u2208 b", "start": [119, 1], "end": [124, 73], "kind": "commanddeclaration"}, {"full_name": "Setoid.eq_of_mem_classes", "code": "theorem eq_of_mem_classes {r : Setoid \u03b1} {x b} (hc : b \u2208 r.classes) (hb : x \u2208 b) {b'}\n    (hc' : b' \u2208 r.classes) (hb' : x \u2208 b') : b = b'", "start": [127, 1], "end": [130, 56], "kind": "commanddeclaration"}, {"full_name": "Setoid.eq_eqv_class_of_mem", "code": "theorem eq_eqv_class_of_mem {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) {s y}\n    (hs : s \u2208 c) (hy : y \u2208 s) : s = { x | (mkClasses c H).Rel x y }", "start": [135, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqv_class_mem", "code": "theorem eqv_class_mem {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) {y} :\n    { x | (mkClasses c H).Rel x y } \u2208 c", "start": [148, 1], "end": [152, 67], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqv_class_mem'", "code": "theorem eqv_class_mem' {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) {x} :\n    { y : \u03b1 | (mkClasses c H).Rel x y } \u2208 c", "start": [157, 1], "end": [160, 20], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqv_classes_disjoint", "code": "theorem eqv_classes_disjoint {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b) :\n    c.PairwiseDisjoint id", "start": [165, 1], "end": [169, 79], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqv_classes_of_disjoint_union", "code": "theorem eqv_classes_of_disjoint_union {c : Set (Set \u03b1)} (hu : Set.sUnion c = @Set.univ \u03b1)\n    (H : c.PairwiseDisjoint id) (a) : \u2203! (b : _) (_ : b \u2208 c), a \u2208 b", "start": [174, 1], "end": [178, 75], "kind": "commanddeclaration"}, {"full_name": "Setoid.setoidOfDisjointUnion", "code": "def setoidOfDisjointUnion {c : Set (Set \u03b1)} (hu : Set.sUnion c = @Set.univ \u03b1)\n    (H : c.PairwiseDisjoint id) : Setoid \u03b1 :=\n  Setoid.mkClasses c <| eqv_classes_of_disjoint_union hu H", "start": [181, 1], "end": [184, 59], "kind": "commanddeclaration"}, {"full_name": "Setoid.mkClasses_classes", "code": "theorem mkClasses_classes (r : Setoid \u03b1) : mkClasses r.classes classes_eqv_classes = r", "start": [187, 1], "end": [192, 73], "kind": "commanddeclaration"}, {"full_name": "Setoid.sUnion_classes", "code": "@[simp]\ntheorem sUnion_classes (r : Setoid \u03b1) : \u22c3\u2080 r.classes = Set.univ", "start": [195, 1], "end": [197, 95], "kind": "commanddeclaration"}, {"full_name": "Setoid.IsPartition", "code": "def IsPartition (c : Set (Set \u03b1)) :=\n  \u2205 \u2209 c \u2227 \u2200 a, \u2203! (b : _) (_ : b \u2208 c), a \u2208 b", "start": [204, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "Setoid.nonempty_of_mem_partition", "code": "theorem nonempty_of_mem_partition {c : Set (Set \u03b1)} (hc : IsPartition c) {s} (h : s \u2208 c) :\n    s.Nonempty", "start": [210, 1], "end": [213, 57], "kind": "commanddeclaration"}, {"full_name": "Setoid.isPartition_classes", "code": "theorem isPartition_classes (r : Setoid \u03b1) : IsPartition r.classes", "start": [216, 1], "end": [217, 47], "kind": "commanddeclaration"}, {"full_name": "Setoid.IsPartition.pairwiseDisjoint", "code": "theorem IsPartition.pairwiseDisjoint {c : Set (Set \u03b1)} (hc : IsPartition c) :\n    c.PairwiseDisjoint id", "start": [220, 1], "end": [222, 28], "kind": "commanddeclaration"}, {"full_name": "Setoid.IsPartition.sUnion_eq_univ", "code": "theorem IsPartition.sUnion_eq_univ {c : Set (Set \u03b1)} (hc : IsPartition c) : \u22c3\u2080 c = Set.univ", "start": [225, 1], "end": [231, 15], "kind": "commanddeclaration"}, {"full_name": "Setoid.exists_of_mem_partition", "code": "theorem exists_of_mem_partition {c : Set (Set \u03b1)} (hc : IsPartition c) {s} (hs : s \u2208 c) :\n    \u2203 y, s = { x | (mkClasses c hc.2).Rel x y }", "start": [234, 1], "end": [238, 38], "kind": "commanddeclaration"}, {"full_name": "Setoid.classes_mkClasses", "code": "theorem classes_mkClasses (c : Set (Set \u03b1)) (hc : IsPartition c) : (mkClasses c hc.2).classes = c", "start": [241, 1], "end": [248, 32], "kind": "commanddeclaration"}, {"full_name": "Setoid.Partition.le", "code": "instance Partition.le : LE (Subtype (@IsPartition \u03b1)) :=\n  \u27e8fun x y => mkClasses x.1 x.2.2 \u2264 mkClasses y.1 y.2.2\u27e9", "start": [251, 1], "end": [253, 57], "kind": "commanddeclaration"}, {"full_name": "Setoid.Partition.partialOrder", "code": "instance Partition.partialOrder : PartialOrder (Subtype (@IsPartition \u03b1))\n    where\n  le := (\u00b7 \u2264 \u00b7)\n  lt x y := x \u2264 y \u2227 \u00acy \u2264 x\n  le_refl _ := @le_refl (Setoid \u03b1) _ _\n  le_trans _ _ _ := @le_trans (Setoid \u03b1) _ _ _ _\n  lt_iff_le_not_le _ _ := Iff.rfl\n  le_antisymm x y hx hy := by\n    let h := @le_antisymm (Setoid \u03b1) _ _ _ hx hy\n    rw [Subtype.ext_iff_val, \u2190 classes_mkClasses x.1 x.2, \u2190 classes_mkClasses y.1 y.2, h]", "start": [256, 1], "end": [267, 90], "kind": "commanddeclaration"}, {"full_name": "Setoid.Partition.orderIso", "code": "protected def Partition.orderIso : Setoid \u03b1 \u2243o { C : Set (Set \u03b1) // IsPartition C }\n    where\n  toFun r := \u27e8r.classes, empty_not_mem_classes, classes_eqv_classes\u27e9\n  invFun C := mkClasses C.1 C.2.2\n  left_inv := mkClasses_classes\n  right_inv C := by rw [Subtype.ext_iff_val, \u2190 classes_mkClasses C.1 C.2]\n  map_rel_iff' {r s} := by\n    conv_rhs => rw [\u2190 mkClasses_classes r, \u2190 mkClasses_classes s]", "start": [272, 1], "end": [281, 66], "kind": "commanddeclaration"}, {"full_name": "Setoid.Partition.completeLattice", "code": "instance Partition.completeLattice : CompleteLattice (Subtype (@IsPartition \u03b1)) :=\n  GaloisInsertion.liftCompleteLattice <|\n    @OrderIso.toGaloisInsertion _ (Subtype (@IsPartition \u03b1)) _ (PartialOrder.toPreorder) <|\n      Partition.orderIso \u03b1", "start": [286, 1], "end": [291, 27], "kind": "commanddeclaration"}, {"full_name": "Setoid.IsPartition.finpartition", "code": "@[simps]\ndef IsPartition.finpartition {c : Finset (Set \u03b1)} (hc : Setoid.IsPartition (c : Set (Set \u03b1))) :\n    Finpartition (Set.univ : Set \u03b1) where\n  parts := c\n  supIndep := Finset.supIndep_iff_pairwiseDisjoint.mpr <| eqv_classes_disjoint hc.2\n  supParts := c.sup_id_set_eq_sUnion.trans hc.sUnion_eq_univ\n  not_bot_mem := hc.left", "start": [296, 1], "end": [303, 25], "kind": "commanddeclaration"}, {"full_name": "Finpartition.isPartition_parts", "code": "theorem Finpartition.isPartition_parts {\u03b1} (f : Finpartition (Set.univ : Set \u03b1)) :\n    Setoid.IsPartition (f.parts : Set (Set \u03b1))", "start": [308, 1], "end": [313, 35], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition", "code": "structure IndexedPartition {\u03b9 \u03b1 : Type*} (s : \u03b9 \u2192 Set \u03b1) where\n  \n  eq_of_mem : \u2200 {x i j}, x \u2208 s i \u2192 x \u2208 s j \u2192 i = j\n  \n  some : \u03b9 \u2192 \u03b1\n  \n  some_mem : \u2200 i, some i \u2208 s i\n  \n  index : \u03b1 \u2192 \u03b9\n  \n  mem_index : \u2200 x, x \u2208 s (index x)", "start": [316, 1], "end": [334, 35], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.mk'", "code": "noncomputable def IndexedPartition.mk' {\u03b9 \u03b1 : Type*} (s : \u03b9 \u2192 Set \u03b1)\n    (dis : \u2200 i j, i \u2260 j \u2192 Disjoint (s i) (s j)) (nonempty : \u2200 i, (s i).Nonempty)\n    (ex : \u2200 x, \u2203 i, x \u2208 s i) : IndexedPartition s\n    where\n  eq_of_mem {_x _i _j} hxi hxj := by_contradiction fun h => (dis _ _ h).le_bot \u27e8hxi, hxj\u27e9\n  some i := (nonempty i).some\n  some_mem i := (nonempty i).choose_spec\n  index x := (ex x).choose\n  mem_index x := (ex x).choose_spec", "start": [337, 1], "end": [346, 36], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.exists_mem", "code": "theorem exists_mem (x : \u03b1) : \u2203 i, x \u2208 s i", "start": [366, 1], "end": [367, 31], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.iUnion", "code": "theorem iUnion : \u22c3 i, s i = univ", "start": [370, 1], "end": [372, 25], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.disjoint", "code": "theorem disjoint : \u2200 {i j}, i \u2260 j \u2192 Disjoint (s i) (s j)", "start": [375, 1], "end": [376, 65], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.mem_iff_index_eq", "code": "theorem mem_iff_index_eq {x i} : x \u2208 s i \u2194 hs.index x = i", "start": [379, 1], "end": [380, 85], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.eq", "code": "theorem eq (i) : s i = { x | hs.index x = i }", "start": [383, 1], "end": [384, 39], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.setoid", "code": "protected abbrev setoid (hs : IndexedPartition s) : Setoid \u03b1 :=\n  Setoid.ker hs.index", "start": [387, 1], "end": [390, 22], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.index_some", "code": "@[simp]\ntheorem index_some (i : \u03b9) : hs.index (hs.some i) = i", "start": [393, 1], "end": [395, 42], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.some_index", "code": "theorem some_index (x : \u03b1) : hs.setoid.Rel (hs.some (hs.index x)) x", "start": [398, 1], "end": [399, 29], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.Quotient", "code": "protected def Quotient :=\n  Quotient hs.setoid", "start": [402, 1], "end": [404, 21], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.proj", "code": "def proj : \u03b1 \u2192 hs.Quotient :=\n  Quotient.mk''", "start": [407, 1], "end": [409, 16], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.proj_eq_iff", "code": "theorem proj_eq_iff {x y : \u03b1} : hs.proj x = hs.proj y \u2194 hs.index x = hs.index y", "start": [415, 1], "end": [416, 18], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.proj_some_index", "code": "@[simp]\ntheorem proj_some_index (x : \u03b1) : hs.proj (hs.some (hs.index x)) = hs.proj x", "start": [419, 1], "end": [421, 36], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.equivQuotient", "code": "def equivQuotient : \u03b9 \u2243 hs.Quotient :=\n  (Setoid.quotientKerEquivOfRightInverse hs.index hs.some <| hs.index_some).symm", "start": [424, 1], "end": [427, 81], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.equivQuotient_index_apply", "code": "@[simp]\ntheorem equivQuotient_index_apply (x : \u03b1) : hs.equivQuotient (hs.index x) = hs.proj x", "start": [430, 1], "end": [432, 39], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.equivQuotient_symm_proj_apply", "code": "@[simp]\ntheorem equivQuotient_symm_proj_apply (x : \u03b1) : hs.equivQuotient.symm (hs.proj x) = hs.index x", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.equivQuotient_index", "code": "theorem equivQuotient_index : hs.equivQuotient \u2218 hs.index = hs.proj", "start": [440, 1], "end": [441, 38], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.out", "code": "def out : hs.Quotient \u21aa \u03b1 :=\n  hs.equivQuotient.symm.toEmbedding.trans \u27e8hs.some, Function.LeftInverse.injective hs.index_some\u27e9", "start": [444, 1], "end": [447, 98], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.out_proj", "code": "@[simp]\ntheorem out_proj (x : \u03b1) : hs.out (hs.proj x) = hs.some (hs.index x)", "start": [450, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.index_out'", "code": "theorem index_out' (x : hs.Quotient) : hs.index x.out' = hs.index (hs.out x)", "start": [456, 1], "end": [458, 93], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.proj_out", "code": "@[simp]\ntheorem proj_out (x : hs.Quotient) : hs.proj (hs.out x) = x", "start": [461, 1], "end": [464, 70], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.class_of", "code": "theorem class_of {x : \u03b1} : setOf (hs.setoid.Rel x) = s (hs.index x)", "start": [467, 1], "end": [468, 59], "kind": "commanddeclaration"}, {"full_name": "IndexedPartition.proj_fiber", "code": "theorem proj_fiber (x : hs.Quotient) : hs.proj \u207b\u00b9' {x} = s (hs.equivQuotient.symm x)", "start": [471, 1], "end": [475, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Clique.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Basic.lean", "Mathlib/Data/Finset/Pairwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.IsClique", "code": "abbrev IsClique (s : Set \u03b1) : Prop :=\n  s.Pairwise G.Adj", "start": [44, 1], "end": [46, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isClique_iff", "code": "theorem isClique_iff : G.IsClique s \u2194 s.Pairwise G.Adj", "start": [49, 1], "end": [50, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isClique_iff_induce_eq", "code": "theorem isClique_iff_induce_eq : G.IsClique s \u2194 G.induce s = \u22a4", "start": [53, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.mono", "code": "theorem IsClique.mono (h : G \u2264 H) : G.IsClique s \u2192 H.IsClique s", "start": [73, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.subset", "code": "theorem IsClique.subset (h : t \u2286 s) : G.IsClique s \u2192 G.IsClique t", "start": [78, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isClique_bot_iff", "code": "@[simp]\ntheorem isClique_bot_iff : (\u22a5 : SimpleGraph \u03b1).IsClique s \u2194 (s : Set \u03b1).Subsingleton", "start": [83, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsClique.subsingleton", "code": "alias \u27e8IsClique.subsingleton, _\u27e9 := isClique_bot_iff", "start": [88, 1], "end": [88, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.IsNClique", "code": "structure IsNClique (n : \u2115) (s : Finset \u03b1) : Prop where\n  clique : G.IsClique s\n  card_eq : s.card = n", "start": [100, 1], "end": [103, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isNClique_iff", "code": "theorem isNClique_iff : G.IsNClique n s \u2194 G.IsClique s \u2227 s.card = n", "start": [106, 1], "end": [107, 43], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsNClique.mono", "code": "theorem IsNClique.mono (h : G \u2264 H) : G.IsNClique n s \u2192 H.IsNClique n s", "start": [116, 1], "end": [118, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isNClique_bot_iff", "code": "@[simp]\ntheorem isNClique_bot_iff : (\u22a5 : SimpleGraph \u03b1).IsNClique n s \u2194 n \u2264 1 \u2227 s.card = n", "start": [121, 1], "end": [126, 25], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.is3Clique_triple_iff", "code": "theorem is3Clique_triple_iff : G.IsNClique 3 {a, b, c} \u2194 G.Adj a b \u2227 G.Adj a c \u2227 G.Adj b c", "start": [131, 1], "end": [134, 38], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.is3Clique_iff", "code": "theorem is3Clique_iff :\n    G.IsNClique 3 s \u2194 \u2203 a b c, G.Adj a b \u2227 G.Adj a c \u2227 G.Adj b c \u2227 s = {a, b, c}", "start": [137, 1], "end": [144, 49], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree", "code": "def CliqueFree (n : \u2115) : Prop :=\n  \u2200 t, \u00acG.IsNClique n t", "start": [156, 1], "end": [158, 24], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsNClique.not_cliqueFree", "code": "theorem IsNClique.not_cliqueFree (hG : G.IsNClique n s) : \u00acG.CliqueFree n", "start": [163, 1], "end": [164, 17], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.not_cliqueFree_of_top_embedding", "code": "theorem not_cliqueFree_of_top_embedding {n : \u2115} (f : (\u22a4 : SimpleGraph (Fin n)) \u21aag G) :\n    \u00acG.CliqueFree n", "start": [167, 1], "end": [180, 7], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.topEmbeddingOfNotCliqueFree", "code": "noncomputable def topEmbeddingOfNotCliqueFree {n : \u2115} (h : \u00acG.CliqueFree n) :\n    (\u22a4 : SimpleGraph (Fin n)) \u21aag G := by\n  simp only [CliqueFree, isNClique_iff, isClique_iff_induce_eq, not_forall, Classical.not_not] at h\n  obtain \u27e8ha, hb\u27e9 := h.choose_spec\n  have : (\u22a4 : SimpleGraph (Fin h.choose.card)) \u2243g (\u22a4 : SimpleGraph h.choose) := by\n    apply Iso.completeGraph\n    simpa using (Fintype.equivFin h.choose).symm\n  rw [\u2190 ha] at this\n  convert (Embedding.induce \u2191h.choose.toSet).comp this.toEmbedding\n  exact hb.symm", "start": [183, 1], "end": [193, 16], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.not_cliqueFree_iff", "code": "theorem not_cliqueFree_iff (n : \u2115) : \u00acG.CliqueFree n \u2194 Nonempty ((\u22a4 : SimpleGraph (Fin n)) \u21aag G)", "start": [196, 1], "end": [197, 89], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_iff", "code": "theorem cliqueFree_iff {n : \u2115} : G.CliqueFree n \u2194 IsEmpty ((\u22a4 : SimpleGraph (Fin n)) \u21aag G)", "start": [200, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.not_cliqueFree_card_of_top_embedding", "code": "theorem not_cliqueFree_card_of_top_embedding [Fintype \u03b1] (f : (\u22a4 : SimpleGraph \u03b1) \u21aag G) :\n    \u00acG.CliqueFree (card \u03b1)", "start": [204, 1], "end": [207, 76], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_bot", "code": "theorem cliqueFree_bot (h : 2 \u2264 n) : (\u22a5 : SimpleGraph \u03b1).CliqueFree n", "start": [210, 1], "end": [213, 20], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree.mono", "code": "theorem CliqueFree.mono (h : m \u2264 n) : G.CliqueFree m \u2192 G.CliqueFree n", "start": [216, 1], "end": [219, 40], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree.anti", "code": "theorem CliqueFree.anti (h : G \u2264 H) : H.CliqueFree n \u2192 G.CliqueFree n", "start": [222, 1], "end": [223, 44], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_of_card_lt", "code": "theorem cliqueFree_of_card_lt [Fintype \u03b1] (hc : card \u03b1 < n) : G.CliqueFree n", "start": [226, 1], "end": [231, 86], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_completeMultipartiteGraph", "code": "theorem cliqueFree_completeMultipartiteGraph {\u03b9 : Type*} [Fintype \u03b9] (V : \u03b9 \u2192 Type*)\n    (hc : card \u03b9 < n) : (completeMultipartiteGraph V).CliqueFree n", "start": [234, 1], "end": [241, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFree_of_replaceVertex_cliqueFree", "code": "theorem cliqueFree_of_replaceVertex_cliqueFree [DecidableEq \u03b1] (s t : \u03b1) (h : G.CliqueFree n) :\n    (G.replaceVertex s t).CliqueFree n", "start": [243, 1], "end": [278, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueSet", "code": "def cliqueSet (n : \u2115) : Set (Finset \u03b1) :=\n  { s | G.IsNClique n s }", "start": [289, 1], "end": [291, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.mem_cliqueSet_iff", "code": "theorem mem_cliqueSet_iff : s \u2208 G.cliqueSet n \u2194 G.IsNClique n s", "start": [294, 1], "end": [295, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueSet_eq_empty_iff", "code": "@[simp]\ntheorem cliqueSet_eq_empty_iff : G.cliqueSet n = \u2205 \u2194 G.CliqueFree n", "start": [298, 1], "end": [300, 75], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree.cliqueSet", "code": "alias \u27e8_, CliqueFree.cliqueSet\u27e9 := cliqueSet_eq_empty_iff", "start": [303, 1], "end": [303, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.cliqueSet_mono", "code": "@[mono]\ntheorem cliqueSet_mono (h : G \u2264 H) : G.cliqueSet n \u2286 H.cliqueSet n", "start": [310, 1], "end": [312, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueSet_mono'", "code": "theorem cliqueSet_mono' (h : G \u2264 H) : G.cliqueSet \u2264 H.cliqueSet", "start": [315, 1], "end": [316, 27], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFinset", "code": "def cliqueFinset (n : \u2115) : Finset (Finset \u03b1) :=\n  univ.filter <| G.IsNClique n", "start": [328, 1], "end": [330, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.mem_cliqueFinset_iff", "code": "theorem mem_cliqueFinset_iff : s \u2208 G.cliqueFinset n \u2194 G.IsNClique n s", "start": [333, 1], "end": [334, 50], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.coe_cliqueFinset", "code": "@[simp]\ntheorem coe_cliqueFinset (n : \u2115) : (G.cliqueFinset n : Set (Finset \u03b1)) = G.cliqueSet n", "start": [337, 1], "end": [339, 41], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.cliqueFinset_eq_empty_iff", "code": "@[simp]\ntheorem cliqueFinset_eq_empty_iff : G.cliqueFinset n = \u2205 \u2194 G.CliqueFree n", "start": [342, 1], "end": [344, 74], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.CliqueFree.cliqueFinset", "code": "alias \u27e8_, CliqueFree.cliqueFinset\u27e9 := cliqueFinset_eq_empty_iff", "start": [347, 1], "end": [347, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SimpleGraph.cliqueFinset_mono", "code": "@[mono]\ntheorem cliqueFinset_mono (h : G \u2264 H) : G.cliqueFinset n \u2286 H.cliqueFinset n", "start": [354, 1], "end": [356, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Degree/CardPowDegree.lean", "imports": ["Mathlib/Data/Polynomial/FieldDivision.lean", "Mathlib/Algebra/Order/EuclideanAbsoluteValue.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.cardPowDegree", "code": "noncomputable def cardPowDegree : AbsoluteValue Fq[X] \u2124 :=\n  have card_pos : 0 < Fintype.card Fq := Fintype.card_pos_iff.mpr inferInstance\n  have pow_pos : \u2200 n, 0 < (Fintype.card Fq : \u2124) ^ n := fun n =>\n    pow_pos (Int.coe_nat_pos.mpr card_pos) n\n  letI := Classical.decEq Fq;\n  { toFun := fun p => if p = 0 then 0 else (Fintype.card Fq : \u2124) ^ p.natDegree\n    nonneg' := fun p => by\n      dsimp\n      split_ifs\n      \u00b7 rfl\n      exact pow_nonneg (Int.ofNat_zero_le _) _\n    eq_zero' := fun p =>\n      ite_eq_left_iff.trans <|\n        \u27e8fun h => by\n          contrapose! h\n          exact \u27e8h, (pow_pos _).ne'\u27e9, absurd\u27e9\n    add_le' := fun p q => by\n      by_cases hp : p = 0; \u00b7 simp [hp]\n      by_cases hq : q = 0; \u00b7 simp [hq]\n      by_cases hpq : p + q = 0\n      \u00b7 simp only [hpq, hp, hq, eq_self_iff_true, if_true, if_false]\n        exact add_nonneg (pow_pos _).le (pow_pos _).le\n      simp only [hpq, hp, hq, if_false]\n      refine' le_trans (pow_le_pow (by linarith) (Polynomial.natDegree_add_le _ _)) _\n      refine'\n        le_trans (le_max_iff.mpr _)\n          (max_le_add_of_nonneg (pow_nonneg (by linarith) _) (pow_nonneg (by linarith) _))\n      exact (max_choice p.natDegree q.natDegree).imp (fun h => by rw [h]) fun h => by rw [h]\n    map_mul' := fun p q => by\n      by_cases hp : p = 0; \u00b7 simp [hp]\n      by_cases hq : q = 0; \u00b7 simp [hq]\n      have hpq : p * q \u2260 0 := mul_ne_zero hp hq\n      simp only [hpq, hp, hq, eq_self_iff_true, if_true, if_false, Polynomial.natDegree_mul hp hq,\n        pow_add] }", "start": [38, 1], "end": [74, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegree_apply", "code": "theorem cardPowDegree_apply [DecidableEq Fq] (p : Fq[X]) :\n    cardPowDegree p = if p = 0 then 0 else (Fintype.card Fq : \u2124) ^ natDegree p", "start": [77, 1], "end": [81, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegree_zero", "code": "@[simp, nolint simpNF]\ntheorem cardPowDegree_zero : cardPowDegree (0 : Fq[X]) = 0", "start": [84, 1], "end": [85, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegree_nonzero", "code": "@[simp]\ntheorem cardPowDegree_nonzero (p : Fq[X]) (hp : p \u2260 0) :\n    cardPowDegree p = (Fintype.card Fq : \u2124) ^ p.natDegree", "start": [88, 1], "end": [91, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardPowDegree_isEuclidean", "code": "theorem cardPowDegree_isEuclidean : IsEuclidean (cardPowDegree : AbsoluteValue Fq[X] \u2124)", "start": [94, 1], "end": [108, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/Frm.lean", "imports": ["Mathlib/Order/Category/Lat.lean", "Mathlib/Topology/Sets/Opens.lean", "Mathlib/Topology/Category/CompHaus/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/CompleteLattice.lean"], "premises": [{"full_name": "Frm", "code": "def Frm :=\n  Bundled Frame", "start": [30, 1], "end": [32, 16], "kind": "commanddeclaration"}, {"full_name": "Frm.of", "code": "def of (\u03b1 : Type*) [Frame \u03b1] : Frm :=\n  Bundled.of \u03b1", "start": [43, 1], "end": [45, 15], "kind": "commanddeclaration"}, {"full_name": "Frm.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [Frame \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [48, 1], "end": [49, 58], "kind": "commanddeclaration"}, {"full_name": "Frm.Hom", "code": "abbrev Hom (\u03b1 \u03b2 : Type*) [Frame \u03b1] [Frame \u03b2] : Type _ :=\n  FrameHom \u03b1 \u03b2", "start": [55, 1], "end": [58, 15], "kind": "commanddeclaration"}, {"full_name": "Frm.bundledHom", "code": "instance bundledHom : BundledHom Hom where\n  toFun {\u03b1 \u03b2} _ _ := ((\u2191) : FrameHom \u03b1 \u03b2 \u2192 \u03b1 \u2192 \u03b2)\n  id {\u03b1} _ := FrameHom.id \u03b1\n  comp _ _ _ := FrameHom.comp\n  hom_ext _ _ := FunLike.coe_injective", "start": [61, 1], "end": [65, 39], "kind": "commanddeclaration"}, {"full_name": "Frm.hasForgetToLat", "code": "instance hasForgetToLat : HasForget\u2082 Frm Lat where\n  forget\u2082 :=\n    { obj := fun X => \u27e8X, _\u27e9\n      map := fun {X Y} => FrameHom.toLatticeHom }", "start": [76, 1], "end": [79, 50], "kind": "commanddeclaration"}, {"full_name": "Frm.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : Frm.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : FrameHom _ _)\n  inv := (e.symm : FrameHom _ _)\n  hom_inv_id := by\n    ext\n    exact e.symm_apply_apply _\n  inv_hom_id := by\n    ext\n    exact e.apply_symm_apply _", "start": [82, 1], "end": [92, 31], "kind": "commanddeclaration"}, {"full_name": "topCatOpToFrm", "code": "@[simps]\ndef topCatOpToFrm : TopCat\u1d52\u1d56 \u2964 Frm where\n  obj X := Frm.of (Opens (unop X : TopCat))\n  map f := Opens.comap <| Quiver.Hom.unop f\n  map_id X := Opens.comap_id", "start": [97, 1], "end": [102, 29], "kind": "commanddeclaration"}, {"full_name": "CompHausOpToFrame.faithful", "code": "instance CompHausOpToFrame.faithful : Faithful (compHausToTop.op \u22d9 topCatOpToFrm.{u}) :=\n  \u27e8fun h => Quiver.Hom.unop_inj <| Opens.comap_injective h\u27e9", "start": [106, 1], "end": [107, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CubicDiscriminant.lean", "imports": ["Mathlib/Data/Polynomial/Splits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Cubic", "code": "@[ext]\nstructure Cubic (R : Type*) where\n  (a b c d : R)", "start": [38, 1], "end": [41, 16], "kind": "commanddeclaration"}, {"full_name": "Cubic.toPoly", "code": "def toPoly (P : Cubic R) : R[X] :=\n  C P.a * X ^ 3 + C P.b * X ^ 2 + C P.c * X + C P.d", "start": [62, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "Cubic.C_mul_prod_X_sub_C_eq", "code": "theorem C_mul_prod_X_sub_C_eq [CommRing S] {w x y z : S} :\n    C w * (X - C x) * (X - C y) * (X - C z) =\n      toPoly \u27e8w, w * -(x + y + z), w * (x * y + x * z + y * z), w * -(x * y * z)\u27e9", "start": [67, 1], "end": [71, 8], "kind": "commanddeclaration"}, {"full_name": "Cubic.prod_X_sub_C_eq", "code": "theorem prod_X_sub_C_eq [CommRing S] {x y z : S} :\n    (X - C x) * (X - C y) * (X - C z) =\n      toPoly \u27e81, -(x + y + z), x * y + x * z + y * z, -(x * y * z)\u27e9", "start": [75, 1], "end": [78, 85], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeffs", "code": "private theorem coeffs : (\u2200 n > 3, P.toPoly.coeff n = 0) \u2227 P.toPoly.coeff 3 = P.a \u2227\n    P.toPoly.coeff 2 = P.b \u2227 P.toPoly.coeff 1 = P.c \u2227 P.toPoly.coeff 0 = P.d", "start": [87, 1], "end": [94, 24], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeff_eq_zero", "code": "@[simp]\ntheorem coeff_eq_zero {n : \u2115} (hn : 3 < n) : P.toPoly.coeff n = 0", "start": [96, 1], "end": [98, 16], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeff_eq_a", "code": "@[simp]\ntheorem coeff_eq_a : P.toPoly.coeff 3 = P.a", "start": [101, 1], "end": [103, 13], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeff_eq_b", "code": "@[simp]\ntheorem coeff_eq_b : P.toPoly.coeff 2 = P.b", "start": [106, 1], "end": [108, 15], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeff_eq_c", "code": "@[simp]\ntheorem coeff_eq_c : P.toPoly.coeff 1 = P.c", "start": [111, 1], "end": [113, 17], "kind": "commanddeclaration"}, {"full_name": "Cubic.coeff_eq_d", "code": "@[simp]\ntheorem coeff_eq_d : P.toPoly.coeff 0 = P.d", "start": [116, 1], "end": [118, 17], "kind": "commanddeclaration"}, {"full_name": "Cubic.a_of_eq", "code": "theorem a_of_eq (h : P.toPoly = Q.toPoly) : P.a = Q.a", "start": [121, 1], "end": [121, 93], "kind": "commanddeclaration"}, {"full_name": "Cubic.b_of_eq", "code": "theorem b_of_eq (h : P.toPoly = Q.toPoly) : P.b = Q.b", "start": [124, 1], "end": [124, 93], "kind": "commanddeclaration"}, {"full_name": "Cubic.c_of_eq", "code": "theorem c_of_eq (h : P.toPoly = Q.toPoly) : P.c = Q.c", "start": [127, 1], "end": [127, 93], "kind": "commanddeclaration"}, {"full_name": "Cubic.d_of_eq", "code": "theorem d_of_eq (h : P.toPoly = Q.toPoly) : P.d = Q.d", "start": [130, 1], "end": [130, 93], "kind": "commanddeclaration"}, {"full_name": "Cubic.toPoly_injective", "code": "theorem toPoly_injective (P Q : Cubic R) : P.toPoly = Q.toPoly \u2194 P = Q", "start": [133, 1], "end": [134, 92], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_a_eq_zero", "code": "theorem of_a_eq_zero (ha : P.a = 0) : P.toPoly = C P.b * X ^ 2 + C P.c * X + C P.d", "start": [137, 1], "end": [138, 43], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_a_eq_zero'", "code": "theorem of_a_eq_zero' : toPoly \u27e80, b, c, d\u27e9 = C b * X ^ 2 + C c * X + C d", "start": [141, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_b_eq_zero", "code": "theorem of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly = C P.c * X + C P.d", "start": [145, 1], "end": [146, 52], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_b_eq_zero'", "code": "theorem of_b_eq_zero' : toPoly \u27e80, 0, c, d\u27e9 = C c * X + C d", "start": [149, 1], "end": [150, 23], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_c_eq_zero", "code": "theorem of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly = C P.d", "start": [153, 1], "end": [154, 55], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_c_eq_zero'", "code": "theorem of_c_eq_zero' : toPoly \u27e80, 0, 0, d\u27e9 = C d", "start": [157, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_d_eq_zero", "code": "theorem of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) :\n    P.toPoly = 0", "start": [161, 1], "end": [163, 38], "kind": "commanddeclaration"}, {"full_name": "Cubic.of_d_eq_zero'", "code": "theorem of_d_eq_zero' : (\u27e80, 0, 0, 0\u27e9 : Cubic R).toPoly = 0", "start": [166, 1], "end": [167, 31], "kind": "commanddeclaration"}, {"full_name": "Cubic.zero", "code": "theorem zero : (0 : Cubic R).toPoly = 0", "start": [170, 1], "end": [171, 16], "kind": "commanddeclaration"}, {"full_name": "Cubic.toPoly_eq_zero_iff", "code": "theorem toPoly_eq_zero_iff (P : Cubic R) : P.toPoly = 0 \u2194 P = 0", "start": [174, 1], "end": [175, 32], "kind": "commanddeclaration"}, {"full_name": "Cubic.ne_zero", "code": "private theorem ne_zero (h0 : P.a \u2260 0 \u2228 P.b \u2260 0 \u2228 P.c \u2260 0 \u2228 P.d \u2260 0) : P.toPoly \u2260 0", "start": [178, 1], "end": [181, 29], "kind": "commanddeclaration"}, {"full_name": "Cubic.ne_zero_of_a_ne_zero", "code": "theorem ne_zero_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly \u2260 0", "start": [183, 1], "end": [184, 27], "kind": "commanddeclaration"}, {"full_name": "Cubic.ne_zero_of_b_ne_zero", "code": "theorem ne_zero_of_b_ne_zero (hb : P.b \u2260 0) : P.toPoly \u2260 0", "start": [187, 1], "end": [188, 41], "kind": "commanddeclaration"}, {"full_name": "Cubic.ne_zero_of_c_ne_zero", "code": "theorem ne_zero_of_c_ne_zero (hc : P.c \u2260 0) : P.toPoly \u2260 0", "start": [191, 1], "end": [192, 55], "kind": "commanddeclaration"}, {"full_name": "Cubic.ne_zero_of_d_ne_zero", "code": "theorem ne_zero_of_d_ne_zero (hd : P.d \u2260 0) : P.toPoly \u2260 0", "start": [195, 1], "end": [196, 55], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_a_ne_zero", "code": "@[simp]\ntheorem leadingCoeff_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly.leadingCoeff = P.a", "start": [199, 1], "end": [201, 24], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_a_ne_zero'", "code": "@[simp]\ntheorem leadingCoeff_of_a_ne_zero' (ha : a \u2260 0) : (toPoly \u27e8a, b, c, d\u27e9).leadingCoeff = a", "start": [204, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_b_ne_zero", "code": "@[simp]\ntheorem leadingCoeff_of_b_ne_zero (ha : P.a = 0) (hb : P.b \u2260 0) : P.toPoly.leadingCoeff = P.b", "start": [209, 1], "end": [211, 50], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_b_ne_zero'", "code": "@[simp]\ntheorem leadingCoeff_of_b_ne_zero' (hb : b \u2260 0) : (toPoly \u27e80, b, c, d\u27e9).leadingCoeff = b", "start": [214, 1], "end": [216, 35], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_c_ne_zero", "code": "@[simp]\ntheorem leadingCoeff_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c \u2260 0) :\n    P.toPoly.leadingCoeff = P.c", "start": [219, 1], "end": [222, 50], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_c_ne_zero'", "code": "@[simp]\ntheorem leadingCoeff_of_c_ne_zero' (hc : c \u2260 0) : (toPoly \u27e80, 0, c, d\u27e9).leadingCoeff = c", "start": [225, 1], "end": [227, 39], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_c_eq_zero", "code": "@[simp]\ntheorem leadingCoeff_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :\n    P.toPoly.leadingCoeff = P.d", "start": [230, 1], "end": [233, 45], "kind": "commanddeclaration"}, {"full_name": "Cubic.leadingCoeff_of_c_eq_zero'", "code": "theorem leadingCoeff_of_c_eq_zero' : (toPoly \u27e80, 0, 0, d\u27e9).leadingCoeff = d", "start": [237, 1], "end": [238, 40], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_a_eq_one", "code": "theorem monic_of_a_eq_one (ha : P.a = 1) : P.toPoly.Monic", "start": [241, 1], "end": [243, 63], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_a_eq_one'", "code": "theorem monic_of_a_eq_one' : (toPoly \u27e81, b, c, d\u27e9).Monic", "start": [246, 1], "end": [247, 24], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_b_eq_one", "code": "theorem monic_of_b_eq_one (ha : P.a = 0) (hb : P.b = 1) : P.toPoly.Monic", "start": [250, 1], "end": [252, 66], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_b_eq_one'", "code": "theorem monic_of_b_eq_one' : (toPoly \u27e80, 1, c, d\u27e9).Monic", "start": [255, 1], "end": [256, 28], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_c_eq_one", "code": "theorem monic_of_c_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 1) : P.toPoly.Monic", "start": [259, 1], "end": [261, 69], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_c_eq_one'", "code": "theorem monic_of_c_eq_one' : (toPoly \u27e80, 0, 1, d\u27e9).Monic", "start": [264, 1], "end": [265, 32], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_d_eq_one", "code": "theorem monic_of_d_eq_one (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 1) :\n    P.toPoly.Monic", "start": [268, 1], "end": [270, 53], "kind": "commanddeclaration"}, {"full_name": "Cubic.monic_of_d_eq_one'", "code": "theorem monic_of_d_eq_one' : (toPoly \u27e80, 0, 0, 1\u27e9).Monic", "start": [273, 1], "end": [274, 36], "kind": "commanddeclaration"}, {"full_name": "Cubic.equiv", "code": "@[simps]\ndef equiv : Cubic R \u2243 { p : R[X] // p.degree \u2264 3 } where\n  toFun P := \u27e8P.toPoly, degree_cubic_le\u27e9\n  invFun f := \u27e8coeff f 3, coeff f 2, coeff f 1, coeff f 0\u27e9\n  left_inv P := by ext <;> simp only [Subtype.coe_mk, coeffs]\n  right_inv f := by\n    ext (_ | _ | _ | _ | n) <;> simp only [Nat.zero_eq, Nat.succ_eq_add_one] <;> ring_nf\n      <;> try simp only [coeffs]\n    have h3 : 3 < 4 + n := by linarith only\n    rw [coeff_eq_zero h3,\n      (degree_le_iff_coeff_zero (f : R[X]) 3).mp f.2 _ <| WithBot.coe_lt_coe.mpr (by exact h3)]", "start": [284, 1], "end": [297, 96], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_a_ne_zero", "code": "@[simp]\ntheorem degree_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly.degree = 3", "start": [300, 1], "end": [302, 18], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_a_ne_zero'", "code": "@[simp]\ntheorem degree_of_a_ne_zero' (ha : a \u2260 0) : (toPoly \u27e8a, b, c, d\u27e9).degree = 3", "start": [305, 1], "end": [307, 25], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_a_eq_zero", "code": "theorem degree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.degree \u2264 2", "start": [310, 1], "end": [311, 57], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_a_eq_zero'", "code": "theorem degree_of_a_eq_zero' : (toPoly \u27e80, b, c, d\u27e9).degree \u2264 2", "start": [314, 1], "end": [315, 26], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_b_ne_zero", "code": "@[simp]\ntheorem degree_of_b_ne_zero (ha : P.a = 0) (hb : P.b \u2260 0) : P.toPoly.degree = 2", "start": [318, 1], "end": [320, 44], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_b_ne_zero'", "code": "@[simp]\ntheorem degree_of_b_ne_zero' (hb : b \u2260 0) : (toPoly \u27e80, b, c, d\u27e9).degree = 2", "start": [323, 1], "end": [325, 29], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_b_eq_zero", "code": "theorem degree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.degree \u2264 1", "start": [328, 1], "end": [329, 57], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_b_eq_zero'", "code": "theorem degree_of_b_eq_zero' : (toPoly \u27e80, 0, c, d\u27e9).degree \u2264 1", "start": [332, 1], "end": [333, 30], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_c_ne_zero", "code": "@[simp]\ntheorem degree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c \u2260 0) : P.toPoly.degree = 1", "start": [336, 1], "end": [338, 44], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_c_ne_zero'", "code": "@[simp]\ntheorem degree_of_c_ne_zero' (hc : c \u2260 0) : (toPoly \u27e80, 0, c, d\u27e9).degree = 1", "start": [341, 1], "end": [343, 33], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_c_eq_zero", "code": "theorem degree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) : P.toPoly.degree \u2264 0", "start": [346, 1], "end": [347, 55], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_c_eq_zero'", "code": "theorem degree_of_c_eq_zero' : (toPoly \u27e80, 0, 0, d\u27e9).degree \u2264 0", "start": [350, 1], "end": [351, 34], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_d_ne_zero", "code": "@[simp]\ntheorem degree_of_d_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d \u2260 0) :\n    P.toPoly.degree = 0", "start": [354, 1], "end": [357, 42], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_d_ne_zero'", "code": "@[simp]\ntheorem degree_of_d_ne_zero' (hd : d \u2260 0) : (toPoly \u27e80, 0, 0, d\u27e9).degree = 0", "start": [360, 1], "end": [362, 37], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_d_eq_zero", "code": "@[simp]\ntheorem degree_of_d_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) (hd : P.d = 0) :\n    P.toPoly.degree = \u22a5", "start": [365, 1], "end": [368, 45], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_d_eq_zero'", "code": "theorem degree_of_d_eq_zero' : (\u27e80, 0, 0, 0\u27e9 : Cubic R).toPoly.degree = \u22a5", "start": [372, 1], "end": [373, 38], "kind": "commanddeclaration"}, {"full_name": "Cubic.degree_of_zero", "code": "@[simp]\ntheorem degree_of_zero : (0 : Cubic R).toPoly.degree = \u22a5", "start": [376, 1], "end": [378, 23], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_a_ne_zero", "code": "@[simp]\ntheorem natDegree_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly.natDegree = 3", "start": [381, 1], "end": [383, 21], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_a_ne_zero'", "code": "@[simp]\ntheorem natDegree_of_a_ne_zero' (ha : a \u2260 0) : (toPoly \u27e8a, b, c, d\u27e9).natDegree = 3", "start": [386, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_a_eq_zero", "code": "theorem natDegree_of_a_eq_zero (ha : P.a = 0) : P.toPoly.natDegree \u2264 2", "start": [391, 1], "end": [392, 60], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_a_eq_zero'", "code": "theorem natDegree_of_a_eq_zero' : (toPoly \u27e80, b, c, d\u27e9).natDegree \u2264 2", "start": [395, 1], "end": [396, 29], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_b_ne_zero", "code": "@[simp]\ntheorem natDegree_of_b_ne_zero (ha : P.a = 0) (hb : P.b \u2260 0) : P.toPoly.natDegree = 2", "start": [399, 1], "end": [401, 47], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_b_ne_zero'", "code": "@[simp]\ntheorem natDegree_of_b_ne_zero' (hb : b \u2260 0) : (toPoly \u27e80, b, c, d\u27e9).natDegree = 2", "start": [404, 1], "end": [406, 32], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_b_eq_zero", "code": "theorem natDegree_of_b_eq_zero (ha : P.a = 0) (hb : P.b = 0) : P.toPoly.natDegree \u2264 1", "start": [409, 1], "end": [410, 60], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_b_eq_zero'", "code": "theorem natDegree_of_b_eq_zero' : (toPoly \u27e80, 0, c, d\u27e9).natDegree \u2264 1", "start": [413, 1], "end": [414, 33], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_c_ne_zero", "code": "@[simp]\ntheorem natDegree_of_c_ne_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c \u2260 0) :\n    P.toPoly.natDegree = 1", "start": [417, 1], "end": [420, 47], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_c_ne_zero'", "code": "@[simp]\ntheorem natDegree_of_c_ne_zero' (hc : c \u2260 0) : (toPoly \u27e80, 0, c, d\u27e9).natDegree = 1", "start": [423, 1], "end": [425, 36], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_c_eq_zero", "code": "@[simp]\ntheorem natDegree_of_c_eq_zero (ha : P.a = 0) (hb : P.b = 0) (hc : P.c = 0) :\n    P.toPoly.natDegree = 0", "start": [428, 1], "end": [431, 42], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_c_eq_zero'", "code": "theorem natDegree_of_c_eq_zero' : (toPoly \u27e80, 0, 0, d\u27e9).natDegree = 0", "start": [435, 1], "end": [436, 37], "kind": "commanddeclaration"}, {"full_name": "Cubic.natDegree_of_zero", "code": "@[simp]\ntheorem natDegree_of_zero : (0 : Cubic R).toPoly.natDegree = 0", "start": [439, 1], "end": [441, 26], "kind": "commanddeclaration"}, {"full_name": "Cubic.map", "code": "def map (\u03c6 : R \u2192+* S) (P : Cubic R) : Cubic S :=\n  \u27e8\u03c6 P.a, \u03c6 P.b, \u03c6 P.c, \u03c6 P.d\u27e9", "start": [453, 1], "end": [455, 31], "kind": "commanddeclaration"}, {"full_name": "Cubic.map_toPoly", "code": "theorem map_toPoly : (map \u03c6 P).toPoly = Polynomial.map \u03c6 P.toPoly", "start": [458, 1], "end": [459, 100], "kind": "commanddeclaration"}, {"full_name": "Cubic.roots", "code": "def roots [IsDomain R] (P : Cubic R) : Multiset R :=\n  P.toPoly.roots", "start": [477, 1], "end": [479, 17], "kind": "commanddeclaration"}, {"full_name": "Cubic.map_roots", "code": "theorem map_roots [IsDomain S] : (map \u03c6 P).roots = (Polynomial.map \u03c6 P.toPoly).roots", "start": [482, 1], "end": [483, 25], "kind": "commanddeclaration"}, {"full_name": "Cubic.mem_roots_iff", "code": "theorem mem_roots_iff [IsDomain R] (h0 : P.toPoly \u2260 0) (x : R) :\n    x \u2208 P.roots \u2194 P.a * x ^ 3 + P.b * x ^ 2 + P.c * x + P.d = 0", "start": [486, 1], "end": [489, 59], "kind": "commanddeclaration"}, {"full_name": "Cubic.card_roots_le", "code": "theorem card_roots_le [IsDomain R] [DecidableEq R] : P.roots.toFinset.card \u2264 3", "start": [492, 1], "end": [496, 71], "kind": "commanddeclaration"}, {"full_name": "Cubic.splits_iff_card_roots", "code": "theorem splits_iff_card_roots (ha : P.a \u2260 0) :\n    Splits \u03c6 P.toPoly \u2194 Multiset.card (map \u03c6 P).roots = 3", "start": [508, 1], "end": [513, 101], "kind": "commanddeclaration"}, {"full_name": "Cubic.splits_iff_roots_eq_three", "code": "theorem splits_iff_roots_eq_three (ha : P.a \u2260 0) :\n    Splits \u03c6 P.toPoly \u2194 \u2203 x y z : K, (map \u03c6 P).roots = {x, y, z}", "start": [516, 1], "end": [518, 47], "kind": "commanddeclaration"}, {"full_name": "Cubic.eq_prod_three_roots", "code": "theorem eq_prod_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    (map \u03c6 P).toPoly = C (\u03c6 P.a) * (X - C x) * (X - C y) * (X - C z)", "start": [521, 1], "end": [528, 66], "kind": "commanddeclaration"}, {"full_name": "Cubic.eq_sum_three_roots", "code": "theorem eq_sum_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    map \u03c6 P =\n      \u27e8\u03c6 P.a, \u03c6 P.a * -(x + y + z), \u03c6 P.a * (x * y + x * z + y * z), \u03c6 P.a * -(x * y * z)\u27e9", "start": [531, 1], "end": [536, 46], "kind": "commanddeclaration"}, {"full_name": "Cubic.b_eq_three_roots", "code": "theorem b_eq_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    \u03c6 P.b = \u03c6 P.a * -(x + y + z)", "start": [539, 1], "end": [541, 37], "kind": "commanddeclaration"}, {"full_name": "Cubic.c_eq_three_roots", "code": "theorem c_eq_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    \u03c6 P.c = \u03c6 P.a * (x * y + x * z + y * z)", "start": [544, 1], "end": [546, 37], "kind": "commanddeclaration"}, {"full_name": "Cubic.d_eq_three_roots", "code": "theorem d_eq_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    \u03c6 P.d = \u03c6 P.a * -(x * y * z)", "start": [549, 1], "end": [551, 37], "kind": "commanddeclaration"}, {"full_name": "Cubic.disc", "code": "def disc {R : Type*} [Ring R] (P : Cubic R) : R :=\n  P.b ^ 2 * P.c ^ 2 - 4 * P.a * P.c ^ 3 - 4 * P.b ^ 3 * P.d - 27 * P.a ^ 2 * P.d ^ 2 +\n    18 * P.a * P.b * P.c * P.d", "start": [561, 1], "end": [564, 31], "kind": "commanddeclaration"}, {"full_name": "Cubic.disc_eq_prod_three_roots", "code": "theorem disc_eq_prod_three_roots (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    \u03c6 P.disc = (\u03c6 P.a * \u03c6 P.a * (x - y) * (x - z) * (y - z)) ^ 2", "start": [567, 1], "end": [575, 8], "kind": "commanddeclaration"}, {"full_name": "Cubic.disc_ne_zero_iff_roots_ne", "code": "theorem disc_ne_zero_iff_roots_ne (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    P.disc \u2260 0 \u2194 x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z", "start": [578, 1], "end": [582, 15], "kind": "commanddeclaration"}, {"full_name": "Cubic.disc_ne_zero_iff_roots_nodup", "code": "theorem disc_ne_zero_iff_roots_nodup (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z}) :\n    P.disc \u2260 0 \u2194 (map \u03c6 P).roots.Nodup", "start": [585, 1], "end": [591, 8], "kind": "commanddeclaration"}, {"full_name": "Cubic.card_roots_of_disc_ne_zero", "code": "theorem card_roots_of_disc_ne_zero [DecidableEq K] (ha : P.a \u2260 0) (h3 : (map \u03c6 P).roots = {x, y, z})\n    (hd : P.disc \u2260 0) : (map \u03c6 P).roots.toFinset.card = 3", "start": [594, 1], "end": [598, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/FinitelyGenerated.lean", "imports": ["Mathlib/ModelTheory/Substructures.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.Substructure.FG", "code": "def FG (N : L.Substructure M) : Prop :=\n  \u2203 S : Finset M, closure L S = N", "start": [40, 1], "end": [42, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_def", "code": "theorem fg_def {N : L.Substructure M} : N.FG \u2194 \u2203 S : Set M, S.Finite \u2227 closure L S = N", "start": [45, 1], "end": [49, 20], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_iff_exists_fin_generating_family", "code": "theorem fg_iff_exists_fin_generating_family {N : L.Substructure M} :\n    N.FG \u2194 \u2203 (n : \u2115) (s : Fin n \u2192 M), closure L (range s) = N", "start": [52, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_bot", "code": "theorem fg_bot : (\u22a5 : L.Substructure M).FG", "start": [63, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_closure", "code": "theorem fg_closure {s : Set M} (hs : s.Finite) : FG (closure L s)", "start": [67, 1], "end": [68, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_closure_singleton", "code": "theorem fg_closure_singleton (x : M) : FG (closure L ({x} : Set M))", "start": [71, 1], "end": [72, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.FG.sup", "code": "theorem FG.sup {N\u2081 N\u2082 : L.Substructure M} (hN\u2081 : N\u2081.FG) (hN\u2082 : N\u2082.FG) : (N\u2081 \u2294 N\u2082).FG", "start": [75, 1], "end": [78, 77], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.FG.map", "code": "theorem FG.map {N : Type*} [L.Structure N] (f : M \u2192[L] N) {s : L.Substructure M} (hs : s.FG) :\n    (s.map f).FG", "start": [81, 1], "end": [84, 63], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.FG.of_map_embedding", "code": "theorem FG.of_map_embedding {N : Type*} [L.Structure N] (f : M \u21aa[L] N) {s : L.Substructure M}\n    (hs : (s.map f.toHom).FG) : s.FG", "start": [87, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.CG", "code": "def CG (N : L.Substructure M) : Prop :=\n  \u2203 S : Set M, S.Countable \u2227 closure L S = N", "start": [101, 1], "end": [104, 45], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_def", "code": "theorem cg_def {N : L.Substructure M} : N.CG \u2194 \u2203 S : Set M, S.Countable \u2227 closure L S = N", "start": [107, 1], "end": [108, 13], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.FG.cg", "code": "theorem FG.cg {N : L.Substructure M} (h : N.FG) : N.CG", "start": [111, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_iff_empty_or_exists_nat_generating_family", "code": "theorem cg_iff_empty_or_exists_nat_generating_family {N : L.Substructure M} :\n    N.CG \u2194 N = (\u2205 : Set M) \u2228 \u2203 s : \u2115 \u2192 M, closure L (range s) = N", "start": [116, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_bot", "code": "theorem cg_bot : (\u22a5 : L.Substructure M).CG", "start": [138, 1], "end": [139, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_closure", "code": "theorem cg_closure {s : Set M} (hs : s.Countable) : CG (closure L s)", "start": [142, 1], "end": [143, 15], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_closure_singleton", "code": "theorem cg_closure_singleton (x : M) : CG (closure L ({x} : Set M))", "start": [146, 1], "end": [147, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.CG.sup", "code": "theorem CG.sup {N\u2081 N\u2082 : L.Substructure M} (hN\u2081 : N\u2081.CG) (hN\u2082 : N\u2082.CG) : (N\u2081 \u2294 N\u2082).CG", "start": [150, 1], "end": [153, 77], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.CG.map", "code": "theorem CG.map {N : Type*} [L.Structure N] (f : M \u2192[L] N) {s : L.Substructure M} (hs : s.CG) :\n    (s.map f).CG", "start": [156, 1], "end": [159, 63], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.CG.of_map_embedding", "code": "theorem CG.of_map_embedding {N : Type*} [L.Structure N] (f : M \u21aa[L] N) {s : L.Substructure M}\n    (hs : (s.map f.toHom).CG) : s.CG", "start": [162, 1], "end": [173, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_iff_countable", "code": "theorem cg_iff_countable [Countable (\u03a3l, L.Functions l)] {s : L.Substructure M} :\n    s.CG \u2194 Countable s", "start": [176, 1], "end": [180, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.FG", "code": "class FG : Prop where\n  out : (\u22a4 : L.Substructure M).FG", "start": [193, 1], "end": [195, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.CG", "code": "class CG : Prop where\n  out : (\u22a4 : L.Substructure M).CG", "start": [198, 1], "end": [200, 34], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.fg_def", "code": "theorem fg_def : FG L M \u2194 (\u22a4 : L.Substructure M).FG", "start": [205, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.fg_iff", "code": "theorem fg_iff : FG L M \u2194 \u2203 S : Set M, S.Finite \u2227 closure L S = (\u22a4 : L.Substructure M)", "start": [209, 1], "end": [211, 35], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.FG.range", "code": "theorem FG.range {N : Type*} [L.Structure N] (h : FG L M) (f : M \u2192[L] N) : f.range.FG", "start": [214, 1], "end": [216, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.FG.map_of_surjective", "code": "theorem FG.map_of_surjective {N : Type*} [L.Structure N] (h : FG L M) (f : M \u2192[L] N)\n    (hs : Function.Surjective f) : FG L N", "start": [219, 1], "end": [223, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.cg_def", "code": "theorem cg_def : CG L M \u2194 (\u22a4 : L.Substructure M).CG", "start": [226, 1], "end": [227, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.cg_iff", "code": "theorem cg_iff : CG L M \u2194 \u2203 S : Set M, S.Countable \u2227 closure L S = (\u22a4 : L.Substructure M)", "start": [230, 1], "end": [232, 35], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.CG.range", "code": "theorem CG.range {N : Type*} [L.Structure N] (h : CG L M) (f : M \u2192[L] N) : f.range.CG", "start": [235, 1], "end": [237, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.CG.map_of_surjective", "code": "theorem CG.map_of_surjective {N : Type*} [L.Structure N] (h : CG L M) (f : M \u2192[L] N)\n    (hs : Function.Surjective f) : CG L N", "start": [240, 1], "end": [244, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.cg_iff_countable", "code": "theorem cg_iff_countable [Countable (\u03a3l, L.Functions l)] : CG L M \u2194 Countable M", "start": [247, 1], "end": [248, 77], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.FG.cg", "code": "theorem FG.cg (h : FG L M) : CG L M", "start": [251, 1], "end": [252, 27], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Structure.cg_of_fg", "code": "instance (priority := 100) cg_of_fg [h : FG L M] : CG L M :=\n  h.cg", "start": [255, 1], "end": [256, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.fg_iff", "code": "theorem Equiv.fg_iff {N : Type*} [L.Structure N] (f : M \u2243[L] N) :\n    Structure.FG L M \u2194 Structure.FG L N", "start": [261, 1], "end": [264, 64], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.fg_iff_structure_fg", "code": "theorem Substructure.fg_iff_structure_fg (S : L.Substructure M) : S.FG \u2194 Structure.FG L S", "start": [267, 1], "end": [274, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Equiv.cg_iff", "code": "theorem Equiv.cg_iff {N : Type*} [L.Structure N] (f : M \u2243[L] N) :\n    Structure.CG L M \u2194 Structure.CG L N", "start": [278, 1], "end": [281, 64], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Substructure.cg_iff_structure_cg", "code": "theorem Substructure.cg_iff_structure_cg (S : L.Substructure M) : S.CG \u2194 Structure.CG L S", "start": [284, 1], "end": [291, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/GradedAlgebra/HomogeneousLocalization.lean", "imports": ["Mathlib/RingTheory/Localization/AtPrime.lean", "Mathlib/RingTheory/GradedAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HomogeneousLocalization.NumDenSameDeg", "code": "structure NumDenSameDeg where\n  deg : \u03b9\n  (num den : \ud835\udc9c deg)\n  den_mem : (den : A) \u2208 x", "start": [88, 1], "end": [95, 26], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.ext", "code": "@[ext]\ntheorem ext {c1 c2 : NumDenSameDeg \ud835\udc9c x} (hdeg : c1.deg = c2.deg) (hnum : (c1.num : A) = c2.num)\n    (hden : (c1.den : A) = c2.den) : c1 = c2", "start": [106, 1], "end": [113, 8], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_one", "code": "@[simp]\ntheorem deg_one : (1 : NumDenSameDeg \ud835\udc9c x).deg = 0", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_one", "code": "@[simp]\ntheorem num_one : ((1 : NumDenSameDeg \ud835\udc9c x).num : A) = 1", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_one", "code": "@[simp]\ntheorem den_one : ((1 : NumDenSameDeg \ud835\udc9c x).den : A) = 1", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_zero", "code": "@[simp]\ntheorem deg_zero : (0 : NumDenSameDeg \ud835\udc9c x).deg = 0", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_zero", "code": "@[simp]\ntheorem num_zero : (0 : NumDenSameDeg \ud835\udc9c x).num = 0", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_zero", "code": "@[simp]\ntheorem den_zero : ((0 : NumDenSameDeg \ud835\udc9c x).den : A) = 1", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_mul", "code": "@[simp]\ntheorem deg_mul (c1 c2 : NumDenSameDeg \ud835\udc9c x) : (c1 * c2).deg = c1.deg + c2.deg", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_mul", "code": "@[simp]\ntheorem num_mul (c1 c2 : NumDenSameDeg \ud835\udc9c x) : ((c1 * c2).num : A) = c1.num * c2.num", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_mul", "code": "@[simp]\ntheorem den_mul (c1 c2 : NumDenSameDeg \ud835\udc9c x) : ((c1 * c2).den : A) = c1.den * c2.den", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_add", "code": "@[simp]\ntheorem deg_add (c1 c2 : NumDenSameDeg \ud835\udc9c x) : (c1 + c2).deg = c1.deg + c2.deg", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_add", "code": "@[simp]\ntheorem num_add (c1 c2 : NumDenSameDeg \ud835\udc9c x) :\n    ((c1 + c2).num : A) = c1.den * c2.num + c2.den * c1.num", "start": [194, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_add", "code": "@[simp]\ntheorem den_add (c1 c2 : NumDenSameDeg \ud835\udc9c x) : ((c1 + c2).den : A) = c1.den * c2.den", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_neg", "code": "@[simp]\ntheorem deg_neg (c : NumDenSameDeg \ud835\udc9c x) : (-c).deg = c.deg", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_neg", "code": "@[simp]\ntheorem num_neg (c : NumDenSameDeg \ud835\udc9c x) : ((-c).num : A) = -c.num", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_neg", "code": "@[simp]\ntheorem den_neg (c : NumDenSameDeg \ud835\udc9c x) : ((-c).den : A) = c.den", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_pow", "code": "@[simp]\ntheorem deg_pow (c : NumDenSameDeg \ud835\udc9c x) (n : \u2115) : (c ^ n).deg = n \u2022 c.deg", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_pow", "code": "@[simp]\ntheorem num_pow (c : NumDenSameDeg \ud835\udc9c x) (n : \u2115) : ((c ^ n).num : A) = (c.num : A) ^ n", "start": [244, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_pow", "code": "@[simp]\ntheorem den_pow (c : NumDenSameDeg \ud835\udc9c x) (n : \u2115) : ((c ^ n).den : A) = (c.den : A) ^ n", "start": [249, 1], "end": [251, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.deg_smul", "code": "@[simp]\ntheorem deg_smul (c : NumDenSameDeg \ud835\udc9c x) (m : \u03b1) : (m \u2022 c).deg = c.deg", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.num_smul", "code": "@[simp]\ntheorem num_smul (c : NumDenSameDeg \ud835\udc9c x) (m : \u03b1) : ((m \u2022 c).num : A) = m \u2022 c.num", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.den_smul", "code": "@[simp]\ntheorem den_smul (c : NumDenSameDeg \ud835\udc9c x) (m : \u03b1) : ((m \u2022 c).den : A) = c.den", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.NumDenSameDeg.embedding", "code": "def embedding (p : NumDenSameDeg \ud835\udc9c x) : at x :=\n  Localization.mk p.num \u27e8p.den, p.den_mem\u27e9", "start": [280, 1], "end": [284, 43], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization", "code": "def HomogeneousLocalization : Type _ :=\n  Quotient (Setoid.ker <| HomogeneousLocalization.NumDenSameDeg.embedding \ud835\udc9c x)", "start": [291, 1], "end": [297, 79], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.val", "code": "def val (y : HomogeneousLocalization \ud835\udc9c x) : at x :=\n  Quotient.liftOn' y (NumDenSameDeg.embedding \ud835\udc9c x) fun _ _ => id", "start": [306, 1], "end": [310, 65], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.val_mk''", "code": "@[simp]\ntheorem val_mk'' (i : NumDenSameDeg \ud835\udc9c x) :\n    val (Quotient.mk'' i) = Localization.mk (i.num : A) \u27e8i.den, i.den_mem\u27e9", "start": [313, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.val_injective", "code": "theorem val_injective : Function.Injective (HomogeneousLocalization.val (\ud835\udc9c := \ud835\udc9c) (x := x))", "start": [321, 1], "end": [322, 77], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.hasPow", "code": "instance hasPow : Pow (HomogeneousLocalization \ud835\udc9c x) \u2115 where\n  pow z n :=\n    (Quotient.map' (\u00b7 ^ n) fun c1 c2 (h : Localization.mk _ _ = Localization.mk _ _) => by\n          change Localization.mk _ _ = Localization.mk _ _\n          simp only [num_pow, den_pow]\n          convert congr_arg (fun z : at x => z ^ n) h <;> erw [Localization.mk_pow] <;> rfl :\n        HomogeneousLocalization \ud835\udc9c x \u2192 HomogeneousLocalization \ud835\udc9c x)\n      z", "start": [325, 1], "end": [332, 8], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.smul_val", "code": "@[simp]\ntheorem smul_val (y : HomogeneousLocalization \ud835\udc9c x) (n : \u03b1) : (n \u2022 y).val = n \u2022 y.val", "start": [347, 1], "end": [353, 10], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.zero_eq", "code": "theorem zero_eq : (0 : HomogeneousLocalization \ud835\udc9c x) = Quotient.mk'' 0", "start": [388, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.one_eq", "code": "theorem one_eq : (1 : HomogeneousLocalization \ud835\udc9c x) = Quotient.mk'' 1", "start": [392, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.zero_val", "code": "theorem zero_val : (0 : HomogeneousLocalization \ud835\udc9c x).val = 0", "start": [398, 1], "end": [399, 25], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.one_val", "code": "theorem one_val : (1 : HomogeneousLocalization \ud835\udc9c x).val = 1", "start": [402, 1], "end": [403, 22], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.add_val", "code": "@[simp]\ntheorem add_val (y1 y2 : HomogeneousLocalization \ud835\udc9c x) : (y1 + y2).val = y1.val + y2.val", "start": [406, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.mul_val", "code": "@[simp]\ntheorem mul_val (y1 y2 : HomogeneousLocalization \ud835\udc9c x) : (y1 * y2).val = y1.val * y2.val", "start": [416, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.neg_val", "code": "@[simp]\ntheorem neg_val (y : HomogeneousLocalization \ud835\udc9c x) : (-y).val = -y.val", "start": [426, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.sub_val", "code": "@[simp]\ntheorem sub_val (y1 y2 : HomogeneousLocalization \ud835\udc9c x) : (y1 - y2).val = y1.val - y2.val", "start": [435, 1], "end": [437, 63], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.pow_val", "code": "@[simp]\ntheorem pow_val (y : HomogeneousLocalization \ud835\udc9c x) (n : \u2115) : (y ^ n).val = y.val ^ n", "start": [440, 1], "end": [446, 10], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.natCast_val", "code": "@[simp]\ntheorem natCast_val (n : \u2115) : (n : HomogeneousLocalization \ud835\udc9c x).val = n", "start": [455, 1], "end": [457, 95], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.intCast_val", "code": "@[simp]\ntheorem intCast_val (n : \u2124) : (n : HomogeneousLocalization \ud835\udc9c x).val = n", "start": [460, 1], "end": [462, 87], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.homogenousLocalizationCommRing", "code": "instance homogenousLocalizationCommRing : CommRing (HomogeneousLocalization \ud835\udc9c x) :=\n  (HomogeneousLocalization.val_injective x).commRing _ zero_val one_val add_val mul_val neg_val\n    sub_val (smul_val x \u00b7 \u00b7) (smul_val x \u00b7 \u00b7) pow_val natCast_val intCast_val", "start": [465, 1], "end": [467, 78], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.homogeneousLocalizationAlgebra", "code": "instance homogeneousLocalizationAlgebra :\n    Algebra (HomogeneousLocalization \ud835\udc9c x) (Localization x) where\n  smul p q := p.val * q\n  toFun := val\n  map_one' := one_val\n  map_mul' := mul_val\n  map_zero' := zero_val\n  map_add' := add_val\n  commutes' _ _ := mul_comm _ _\n  smul_def' _ _ := rfl", "start": [470, 1], "end": [479, 23], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.num", "code": "def num (f : HomogeneousLocalization \ud835\udc9c x) : A :=\n  (Quotient.out' f).num", "start": [490, 1], "end": [492, 24], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.den", "code": "def den (f : HomogeneousLocalization \ud835\udc9c x) : A :=\n  (Quotient.out' f).den", "start": [495, 1], "end": [497, 24], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.deg", "code": "def deg (f : HomogeneousLocalization \ud835\udc9c x) : \u03b9 :=\n  (Quotient.out' f).deg", "start": [500, 1], "end": [503, 24], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.den_mem", "code": "theorem den_mem (f : HomogeneousLocalization \ud835\udc9c x) : f.den \u2208 x", "start": [506, 1], "end": [507, 28], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.num_mem_deg", "code": "theorem num_mem_deg (f : HomogeneousLocalization \ud835\udc9c x) : f.num \u2208 \ud835\udc9c f.deg", "start": [510, 1], "end": [511, 26], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.den_mem_deg", "code": "theorem den_mem_deg (f : HomogeneousLocalization \ud835\udc9c x) : f.den \u2208 \ud835\udc9c f.deg", "start": [514, 1], "end": [515, 26], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.eq_num_div_den", "code": "theorem eq_num_div_den (f : HomogeneousLocalization \ud835\udc9c x) :\n    f.val = Localization.mk f.num \u27e8f.den, f.den_mem\u27e9", "start": [518, 1], "end": [523, 6], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.ext_iff_val", "code": "theorem ext_iff_val (f g : HomogeneousLocalization \ud835\udc9c x) : f = g \u2194 f.val = g.val", "start": [526, 1], "end": [532, 49], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.AtPrime", "code": "abbrev AtPrime :=\n  HomogeneousLocalization \ud835\udc9c \ud835\udd2d.primeCompl", "start": [539, 1], "end": [541, 41], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.isUnit_iff_isUnit_val", "code": "theorem isUnit_iff_isUnit_val (f : HomogeneousLocalization.AtPrime \ud835\udc9c \ud835\udd2d) : IsUnit f.val \u2194 IsUnit f", "start": [544, 1], "end": [575, 43], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.localRing", "code": "instance localRing : LocalRing (HomogeneousLocalization.AtPrime \ud835\udc9c \ud835\udd2d) :=\n  LocalRing.of_isUnit_or_isUnit_one_sub_self fun a => by\n    simp only [\u2190 isUnit_iff_isUnit_val, sub_val, one_val]\n    induction' a using Quotient.inductionOn' with a\n    simp only [HomogeneousLocalization.val_mk'']\n    by_cases mem1 : a.num.1 \u2208 \ud835\udd2d\n    \u00b7 right\n      have : a.den.1 - a.num.1 \u2208 \ud835\udd2d.primeCompl := fun h =>\n        a.den_mem (sub_add_cancel a.den.val a.num.val \u25b8 Ideal.add_mem _ h mem1 : a.den.1 \u2208 \ud835\udd2d)\n      apply isUnit_of_mul_eq_one _ (Localization.mk a.den.1 \u27e8a.den.1 - a.num.1, this\u27e9)\n      simp only [sub_mul, Localization.mk_mul, one_mul, Localization.sub_mk, Submonoid.coe_mul]\n      convert Localization.mk_self (M := A) _\n      simp only [Submonoid.coe_mul]\n      ring\n    \u00b7 left\n      change _ \u2208 \ud835\udd2d.primeCompl at mem1\n      apply isUnit_of_mul_eq_one _ (Localization.mk a.den.1 \u27e8a.num.1, mem1\u27e9)\n      rw [Localization.mk_mul]\n      convert Localization.mk_self (M := A) _\n      rw [mul_comm]\n      rfl", "start": [581, 1], "end": [601, 10], "kind": "commanddeclaration"}, {"full_name": "HomogeneousLocalization.Away", "code": "abbrev Away :=\n  HomogeneousLocalization \ud835\udc9c (Submonoid.powers f)", "start": [609, 1], "end": [611, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/ProjectiveSpectrum/Topology.lean", "imports": ["Mathlib/RingTheory/GradedAlgebra/HomogeneousIdeal.lean", "Mathlib/Topology/Sets/Opens.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProjectiveSpectrum", "code": "@[ext]\nstructure ProjectiveSpectrum where\n  asHomogeneousIdeal : HomogeneousIdeal \ud835\udc9c\n  isPrime : asHomogeneousIdeal.toIdeal.IsPrime\n  not_irrelevant_le : \u00acHomogeneousIdeal.irrelevant \ud835\udc9c \u2264 asHomogeneousIdeal", "start": [51, 1], "end": [57, 74], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus", "code": "def zeroLocus (s : Set A) : Set (ProjectiveSpectrum \ud835\udc9c) :=\n  { x | s \u2286 x.asHomogeneousIdeal }", "start": [64, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.mem_zeroLocus", "code": "@[simp]\ntheorem mem_zeroLocus (x : ProjectiveSpectrum \ud835\udc9c) (s : Set A) :\n    x \u2208 zeroLocus \ud835\udc9c s \u2194 s \u2286 x.asHomogeneousIdeal", "start": [75, 1], "end": [78, 10], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_span", "code": "@[simp]\ntheorem zeroLocus_span (s : Set A) : zeroLocus \ud835\udc9c (Ideal.span s) = zeroLocus \ud835\udc9c s", "start": [81, 1], "end": [84, 61], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal", "code": "def vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) : HomogeneousIdeal \ud835\udc9c :=\n  \u2a05 (x : ProjectiveSpectrum \ud835\udc9c) (_ : x \u2208 t), x.asHomogeneousIdeal", "start": [89, 1], "end": [97, 65], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.coe_vanishingIdeal", "code": "theorem coe_vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    (vanishingIdeal t : Set A) =\n      { f | \u2200 x : ProjectiveSpectrum \ud835\udc9c, x \u2208 t \u2192 f \u2208 x.asHomogeneousIdeal }", "start": [100, 1], "end": [107, 83], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.mem_vanishingIdeal", "code": "theorem mem_vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) (f : A) :\n    f \u2208 vanishingIdeal t \u2194 \u2200 x : ProjectiveSpectrum \ud835\udc9c, x \u2208 t \u2192 f \u2208 x.asHomogeneousIdeal", "start": [110, 1], "end": [112, 63], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_singleton", "code": "@[simp]\ntheorem vanishingIdeal_singleton (x : ProjectiveSpectrum \ud835\udc9c) :\n    vanishingIdeal ({x} : Set (ProjectiveSpectrum \ud835\udc9c)) = x.asHomogeneousIdeal", "start": [115, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.subset_zeroLocus_iff_le_vanishingIdeal", "code": "theorem subset_zeroLocus_iff_le_vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) (I : Ideal A) :\n    t \u2286 zeroLocus \ud835\udc9c I \u2194 I \u2264 (vanishingIdeal t).toIdeal", "start": [121, 1], "end": [125, 91], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.gc_ideal", "code": "theorem gc_ideal :\n    @GaloisConnection (Ideal A) (Set (ProjectiveSpectrum \ud835\udc9c))\u1d52\u1d48 _ _\n      (fun I => zeroLocus \ud835\udc9c I) fun t => (vanishingIdeal t).toIdeal", "start": [130, 1], "end": [134, 56], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.gc_set", "code": "theorem gc_set :\n    @GaloisConnection (Set A) (Set (ProjectiveSpectrum \ud835\udc9c))\u1d52\u1d48 _ _\n      (fun s => zeroLocus \ud835\udc9c s) fun t => vanishingIdeal t", "start": [137, 1], "end": [142, 93], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.gc_homogeneousIdeal", "code": "theorem gc_homogeneousIdeal :\n    @GaloisConnection (HomogeneousIdeal \ud835\udc9c) (Set (ProjectiveSpectrum \ud835\udc9c))\u1d52\u1d48 _ _\n      (fun I => zeroLocus \ud835\udc9c I) fun t => vanishingIdeal t", "start": [145, 1], "end": [150, 55], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.subset_zeroLocus_iff_subset_vanishingIdeal", "code": "theorem subset_zeroLocus_iff_subset_vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) (s : Set A) :\n    t \u2286 zeroLocus \ud835\udc9c s \u2194 s \u2286 vanishingIdeal t", "start": [153, 1], "end": [155, 17], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.subset_vanishingIdeal_zeroLocus", "code": "theorem subset_vanishingIdeal_zeroLocus (s : Set A) : s \u2286 vanishingIdeal (zeroLocus \ud835\udc9c s)", "start": [158, 1], "end": [159, 22], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.ideal_le_vanishingIdeal_zeroLocus", "code": "theorem ideal_le_vanishingIdeal_zeroLocus (I : Ideal A) :\n    I \u2264 (vanishingIdeal (zeroLocus \ud835\udc9c I)).toIdeal", "start": [162, 1], "end": [164, 24], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.homogeneousIdeal_le_vanishingIdeal_zeroLocus", "code": "theorem homogeneousIdeal_le_vanishingIdeal_zeroLocus (I : HomogeneousIdeal \ud835\udc9c) :\n    I \u2264 vanishingIdeal (zeroLocus \ud835\udc9c I)", "start": [167, 1], "end": [169, 35], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.subset_zeroLocus_vanishingIdeal", "code": "theorem subset_zeroLocus_vanishingIdeal (t : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    t \u2286 zeroLocus \ud835\udc9c (vanishingIdeal t)", "start": [172, 1], "end": [174, 24], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_anti_mono", "code": "theorem zeroLocus_anti_mono {s t : Set A} (h : s \u2286 t) : zeroLocus \ud835\udc9c t \u2286 zeroLocus \ud835\udc9c s", "start": [177, 1], "end": [178, 26], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_anti_mono_ideal", "code": "theorem zeroLocus_anti_mono_ideal {s t : Ideal A} (h : s \u2264 t) :\n    zeroLocus \ud835\udc9c (t : Set A) \u2286 zeroLocus \ud835\udc9c (s : Set A)", "start": [181, 1], "end": [183, 28], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_anti_mono_homogeneousIdeal", "code": "theorem zeroLocus_anti_mono_homogeneousIdeal {s t : HomogeneousIdeal \ud835\udc9c} (h : s \u2264 t) :\n    zeroLocus \ud835\udc9c (t : Set A) \u2286 zeroLocus \ud835\udc9c (s : Set A)", "start": [186, 1], "end": [188, 39], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_anti_mono", "code": "theorem vanishingIdeal_anti_mono {s t : Set (ProjectiveSpectrum \ud835\udc9c)} (h : s \u2286 t) :\n    vanishingIdeal t \u2264 vanishingIdeal s", "start": [191, 1], "end": [193, 28], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_bot", "code": "theorem zeroLocus_bot : zeroLocus \ud835\udc9c ((\u22a5 : Ideal A) : Set A) = Set.univ", "start": [196, 1], "end": [197, 21], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_singleton_zero", "code": "@[simp]\ntheorem zeroLocus_singleton_zero : zeroLocus \ud835\udc9c ({0} : Set A) = Set.univ", "start": [200, 1], "end": [202, 18], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_empty", "code": "@[simp]\ntheorem zeroLocus_empty : zeroLocus \ud835\udc9c (\u2205 : Set A) = Set.univ", "start": [205, 1], "end": [207, 19], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_univ", "code": "@[simp]\ntheorem vanishingIdeal_univ : vanishingIdeal (\u2205 : Set (ProjectiveSpectrum \ud835\udc9c)) = \u22a4", "start": [210, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_empty_of_one_mem", "code": "theorem zeroLocus_empty_of_one_mem {s : Set A} (h : (1 : A) \u2208 s) : zeroLocus \ud835\udc9c s = \u2205", "start": [215, 1], "end": [218, 62], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_singleton_one", "code": "@[simp]\ntheorem zeroLocus_singleton_one : zeroLocus \ud835\udc9c ({1} : Set A) = \u2205", "start": [221, 1], "end": [223, 59], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_univ", "code": "@[simp]\ntheorem zeroLocus_univ : zeroLocus \ud835\udc9c (Set.univ : Set A) = \u2205", "start": [226, 1], "end": [228, 48], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_sup_ideal", "code": "theorem zeroLocus_sup_ideal (I J : Ideal A) :\n    zeroLocus \ud835\udc9c ((I \u2294 J : Ideal A) : Set A) = zeroLocus _ I \u2229 zeroLocus _ J", "start": [231, 1], "end": [233, 21], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_sup_homogeneousIdeal", "code": "theorem zeroLocus_sup_homogeneousIdeal (I J : HomogeneousIdeal \ud835\udc9c) :\n    zeroLocus \ud835\udc9c ((I \u2294 J : HomogeneousIdeal \ud835\udc9c) : Set A) = zeroLocus _ I \u2229 zeroLocus _ J", "start": [236, 1], "end": [238, 32], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_union", "code": "theorem zeroLocus_union (s s' : Set A) : zeroLocus \ud835\udc9c (s \u222a s') = zeroLocus _ s \u2229 zeroLocus _ s'", "start": [241, 1], "end": [242, 19], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_union", "code": "theorem vanishingIdeal_union (t t' : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    vanishingIdeal (t \u222a t') = vanishingIdeal t \u2293 vanishingIdeal t'", "start": [245, 1], "end": [247, 33], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_iSup_ideal", "code": "theorem zeroLocus_iSup_ideal {\u03b3 : Sort*} (I : \u03b3 \u2192 Ideal A) :\n    zeroLocus _ ((\u2a06 i, I i : Ideal A) : Set A) = \u22c2 i, zeroLocus \ud835\udc9c (I i)", "start": [250, 1], "end": [252, 22], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_iSup_homogeneousIdeal", "code": "theorem zeroLocus_iSup_homogeneousIdeal {\u03b3 : Sort*} (I : \u03b3 \u2192 HomogeneousIdeal \ud835\udc9c) :\n    zeroLocus _ ((\u2a06 i, I i : HomogeneousIdeal \ud835\udc9c) : Set A) = \u22c2 i, zeroLocus \ud835\udc9c (I i)", "start": [255, 1], "end": [257, 33], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_iUnion", "code": "theorem zeroLocus_iUnion {\u03b3 : Sort*} (s : \u03b3 \u2192 Set A) :\n    zeroLocus \ud835\udc9c (\u22c3 i, s i) = \u22c2 i, zeroLocus \ud835\udc9c (s i)", "start": [260, 1], "end": [262, 20], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_bUnion", "code": "theorem zeroLocus_bUnion (s : Set (Set A)) :\n    zeroLocus \ud835\udc9c (\u22c3 s' \u2208 s, s' : Set A) = \u22c2 s' \u2208 s, zeroLocus \ud835\udc9c s'", "start": [265, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_iUnion", "code": "theorem vanishingIdeal_iUnion {\u03b3 : Sort*} (t : \u03b3 \u2192 Set (ProjectiveSpectrum \ud835\udc9c)) :\n    vanishingIdeal (\u22c3 i, t i) = \u2a05 i, vanishingIdeal (t i)", "start": [270, 1], "end": [273, 71], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_inf", "code": "theorem zeroLocus_inf (I J : Ideal A) :\n    zeroLocus \ud835\udc9c ((I \u2293 J : Ideal A) : Set A) = zeroLocus \ud835\udc9c I \u222a zeroLocus \ud835\udc9c J", "start": [276, 1], "end": [278, 36], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.union_zeroLocus", "code": "theorem union_zeroLocus (s s' : Set A) :\n    zeroLocus \ud835\udc9c s \u222a zeroLocus \ud835\udc9c s' = zeroLocus \ud835\udc9c (Ideal.span s \u2293 Ideal.span s' : Ideal A)", "start": [281, 1], "end": [284, 7], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_mul_ideal", "code": "theorem zeroLocus_mul_ideal (I J : Ideal A) :\n    zeroLocus \ud835\udc9c ((I * J : Ideal A) : Set A) = zeroLocus \ud835\udc9c I \u222a zeroLocus \ud835\udc9c J", "start": [287, 1], "end": [289, 36], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_mul_homogeneousIdeal", "code": "theorem zeroLocus_mul_homogeneousIdeal (I J : HomogeneousIdeal \ud835\udc9c) :\n    zeroLocus \ud835\udc9c ((I * J : HomogeneousIdeal \ud835\udc9c) : Set A) = zeroLocus \ud835\udc9c I \u222a zeroLocus \ud835\udc9c J", "start": [292, 1], "end": [294, 36], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_singleton_mul", "code": "theorem zeroLocus_singleton_mul (f g : A) :\n    zeroLocus \ud835\udc9c ({f * g} : Set A) = zeroLocus \ud835\udc9c {f} \u222a zeroLocus \ud835\udc9c {g}", "start": [297, 1], "end": [299, 67], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_singleton_pow", "code": "@[simp]\ntheorem zeroLocus_singleton_pow (f : A) (n : \u2115) (hn : 0 < n) :\n    zeroLocus \ud835\udc9c ({f ^ n} : Set A) = zeroLocus \ud835\udc9c {f}", "start": [302, 1], "end": [305, 65], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.sup_vanishingIdeal_le", "code": "theorem sup_vanishingIdeal_le (t t' : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    vanishingIdeal t \u2294 vanishingIdeal t' \u2264 vanishingIdeal (t \u2229 t')", "start": [308, 1], "end": [315, 44], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.mem_compl_zeroLocus_iff_not_mem", "code": "theorem mem_compl_zeroLocus_iff_not_mem {f : A} {I : ProjectiveSpectrum \ud835\udc9c} :\n    I \u2208 (zeroLocus \ud835\udc9c {f} : Set (ProjectiveSpectrum \ud835\udc9c))\u1d9c \u2194 f \u2209 I.asHomogeneousIdeal", "start": [318, 1], "end": [320, 71], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zariskiTopology", "code": "instance zariskiTopology : TopologicalSpace (ProjectiveSpectrum \ud835\udc9c) :=\n  TopologicalSpace.ofClosed (Set.range (ProjectiveSpectrum.zeroLocus \ud835\udc9c)) \u27e8Set.univ, by simp\u27e9\n    (by\n      intro Zs h\n      rw [Set.sInter_eq_iInter]\n      let f : Zs \u2192 Set _ := fun i => Classical.choose (h i.2)\n      have H : (Set.iInter fun i \u21a6 zeroLocus \ud835\udc9c (f i)) \u2208 Set.range (zeroLocus \ud835\udc9c) :=\n        \u27e8_, zeroLocus_iUnion \ud835\udc9c _\u27e9\n      convert H using 2\n      funext i\n      exact (Classical.choose_spec (h i.2)).symm)\n    (by\n      rintro _ \u27e8s, rfl\u27e9 _ \u27e8t, rfl\u27e9\n      exact \u27e8_, (union_zeroLocus \ud835\udc9c s t).symm\u27e9)", "start": [323, 1], "end": [338, 47], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.top", "code": "def top : TopCat :=\n  TopCat.of (ProjectiveSpectrum \ud835\udc9c)", "start": [341, 1], "end": [343, 35], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.isOpen_iff", "code": "theorem isOpen_iff (U : Set (ProjectiveSpectrum \ud835\udc9c)) : IsOpen U \u2194 \u2203 s, U\u1d9c = zeroLocus \ud835\udc9c s", "start": [347, 1], "end": [348, 33], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.isClosed_iff_zeroLocus", "code": "theorem isClosed_iff_zeroLocus (Z : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    IsClosed Z \u2194 \u2203 s, Z = zeroLocus \ud835\udc9c s", "start": [351, 1], "end": [352, 95], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.isClosed_zeroLocus", "code": "theorem isClosed_zeroLocus (s : Set A) : IsClosed (zeroLocus \ud835\udc9c s)", "start": [355, 1], "end": [357, 17], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.zeroLocus_vanishingIdeal_eq_closure", "code": "theorem zeroLocus_vanishingIdeal_eq_closure (t : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    zeroLocus \ud835\udc9c (vanishingIdeal t : Set A) = closure t", "start": [360, 1], "end": [368, 46], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.vanishingIdeal_closure", "code": "theorem vanishingIdeal_closure (t : Set (ProjectiveSpectrum \ud835\udc9c)) :\n    vanishingIdeal (closure t) = vanishingIdeal t", "start": [371, 1], "end": [376, 13], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen", "code": "def basicOpen (r : A) : TopologicalSpace.Opens (ProjectiveSpectrum \ud835\udc9c) where\n  carrier := { x | r \u2209 x.asHomogeneousIdeal }\n  is_open' := \u27e8{r}, Set.ext fun _ => Set.singleton_subset_iff.trans <| Classical.not_not.symm\u27e9", "start": [381, 1], "end": [384, 95], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.mem_basicOpen", "code": "@[simp]\ntheorem mem_basicOpen (f : A) (x : ProjectiveSpectrum \ud835\udc9c) :\n    x \u2208 basicOpen \ud835\udc9c f \u2194 f \u2209 x.asHomogeneousIdeal", "start": [387, 1], "end": [390, 10], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.mem_coe_basicOpen", "code": "theorem mem_coe_basicOpen (f : A) (x : ProjectiveSpectrum \ud835\udc9c) :\n    x \u2208 (\u2191(basicOpen \ud835\udc9c f) : Set (ProjectiveSpectrum \ud835\udc9c)) \u2194 f \u2209 x.asHomogeneousIdeal", "start": [393, 1], "end": [395, 10], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.isOpen_basicOpen", "code": "theorem isOpen_basicOpen {a : A} : IsOpen (basicOpen \ud835\udc9c a : Set (ProjectiveSpectrum \ud835\udc9c))", "start": [398, 1], "end": [399, 25], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_eq_zeroLocus_compl", "code": "@[simp]\ntheorem basicOpen_eq_zeroLocus_compl (r : A) :\n    (basicOpen \ud835\udc9c r : Set (ProjectiveSpectrum \ud835\udc9c)) = (zeroLocus \ud835\udc9c {r})\u1d9c", "start": [402, 1], "end": [405, 98], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_one", "code": "@[simp]\ntheorem basicOpen_one : basicOpen \ud835\udc9c (1 : A) = \u22a4", "start": [408, 1], "end": [410, 40], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_zero", "code": "@[simp]\ntheorem basicOpen_zero : basicOpen \ud835\udc9c (0 : A) = \u22a5", "start": [413, 1], "end": [415, 40], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_mul", "code": "theorem basicOpen_mul (f g : A) : basicOpen \ud835\udc9c (f * g) = basicOpen \ud835\udc9c f \u2293 basicOpen \ud835\udc9c g", "start": [418, 1], "end": [419, 66], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_mul_le_left", "code": "theorem basicOpen_mul_le_left (f g : A) : basicOpen \ud835\udc9c (f * g) \u2264 basicOpen \ud835\udc9c f", "start": [422, 1], "end": [424, 20], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_mul_le_right", "code": "theorem basicOpen_mul_le_right (f g : A) : basicOpen \ud835\udc9c (f * g) \u2264 basicOpen \ud835\udc9c g", "start": [427, 1], "end": [429, 21], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_pow", "code": "@[simp]\ntheorem basicOpen_pow (f : A) (n : \u2115) (hn : 0 < n) : basicOpen \ud835\udc9c (f ^ n) = basicOpen \ud835\udc9c f", "start": [432, 1], "end": [434, 80], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.basicOpen_eq_union_of_projection", "code": "theorem basicOpen_eq_union_of_projection (f : A) :\n    basicOpen \ud835\udc9c f = \u2a06 i : \u2115, basicOpen \ud835\udc9c (GradedAlgebra.proj \ud835\udc9c i f)", "start": [437, 1], "end": [450, 42], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.isTopologicalBasis_basic_opens", "code": "theorem isTopologicalBasis_basic_opens :\n    TopologicalSpace.IsTopologicalBasis\n      (Set.range fun r : A => (basicOpen \ud835\udc9c r : Set (ProjectiveSpectrum \ud835\udc9c)))", "start": [453, 1], "end": [464, 67], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.as_ideal_le_as_ideal", "code": "@[simp]\ntheorem as_ideal_le_as_ideal (x y : ProjectiveSpectrum \ud835\udc9c) :\n    x.asHomogeneousIdeal \u2264 y.asHomogeneousIdeal \u2194 x \u2264 y", "start": [482, 1], "end": [485, 10], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.as_ideal_lt_as_ideal", "code": "@[simp]\ntheorem as_ideal_lt_as_ideal (x y : ProjectiveSpectrum \ud835\udc9c) :\n    x.asHomogeneousIdeal < y.asHomogeneousIdeal \u2194 x < y", "start": [488, 1], "end": [491, 10], "kind": "commanddeclaration"}, {"full_name": "ProjectiveSpectrum.le_iff_mem_closure", "code": "theorem le_iff_mem_closure (x y : ProjectiveSpectrum \ud835\udc9c) :\n    x \u2264 y \u2194 y \u2208 closure ({x} : Set (ProjectiveSpectrum \ud835\udc9c))", "start": [494, 1], "end": [498, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PFunctor/Univariate/M.lean", "imports": ["Mathlib/Data/PFunctor/Univariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PFunctor.Approx.CofixA", "code": "inductive CofixA : \u2115 \u2192 Type u\n  | continue : CofixA 0\n  | intro {n} : \u2200 a, (F.B a \u2192 CofixA n) \u2192 CofixA (succ n)", "start": [33, 1], "end": [36, 58], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.CofixA.default", "code": "protected def CofixA.default [Inhabited F.A] : \u2200 n, CofixA F n\n  | 0 => CofixA.continue\n  | succ n => CofixA.intro default fun _ => CofixA.default n", "start": [39, 1], "end": [42, 61], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.cofixA_eq_zero", "code": "theorem cofixA_eq_zero : \u2200 x y : CofixA F 0, x = y", "start": [48, 1], "end": [49, 44], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.head'", "code": "def head' : \u2200 {n}, CofixA F (succ n) \u2192 F.A\n  | _, CofixA.intro i _ => i", "start": [54, 1], "end": [58, 29], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.children'", "code": "def children' : \u2200 {n} (x : CofixA F (succ n)), F.B (head' x) \u2192 CofixA F n\n  | _, CofixA.intro _ f => f", "start": [61, 1], "end": [63, 29], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.approx_eta", "code": "theorem approx_eta {n : \u2115} (x : CofixA F (n + 1)) : x = CofixA.intro (head' x) (children' x)", "start": [66, 1], "end": [67, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.Agree", "code": "inductive Agree : \u2200 {n : \u2115}, CofixA F n \u2192 CofixA F (n + 1) \u2192 Prop\n  | continu (x : CofixA F 0) (y : CofixA F 1) : Agree x y\n  | intro {n} {a} (x : F.B a \u2192 CofixA F n) (x' : F.B a \u2192 CofixA F (n + 1)) :\n    (\u2200 i : F.B a, Agree (x i) (x' i)) \u2192 Agree (CofixA.intro a x) (CofixA.intro a x')", "start": [70, 1], "end": [75, 85], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.AllAgree", "code": "def AllAgree (x : \u2200 n, CofixA F n) :=\n  \u2200 n, Agree (x n) (x (succ n))", "start": [78, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.agree_trival", "code": "@[simp]\ntheorem agree_trival {x : CofixA F 0} {y : CofixA F 1} : Agree x y", "start": [85, 1], "end": [86, 85], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.agree_children", "code": "theorem agree_children {n : \u2115} (x : CofixA F (succ n)) (y : CofixA F (succ n + 1)) {i j}\n    (h\u2080 : HEq i j) (h\u2081 : Agree x y) : Agree (children' x i) (children' y j)", "start": [89, 1], "end": [92, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.truncate", "code": "def truncate : \u2200 {n : \u2115}, CofixA F (n + 1) \u2192 CofixA F n\n  | 0, CofixA.intro _ _ => CofixA.continue\n  | succ _, CofixA.intro i f => CofixA.intro i <| truncate \u2218 f", "start": [95, 1], "end": [98, 63], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.truncate_eq_of_agree", "code": "theorem truncate_eq_of_agree {n : \u2115} (x : CofixA F n) (y : CofixA F (succ n)) (h : Agree x y) :\n    truncate y = x", "start": [101, 1], "end": [115, 13], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.sCorec", "code": "def sCorec : X \u2192 \u2200 n, CofixA F n\n  | _, 0 => CofixA.continue\n  | j, succ _ => CofixA.intro (f j).1 fun i => sCorec ((f j).2 i) _", "start": [122, 1], "end": [126, 68], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.P_corec", "code": "theorem P_corec (i : X) (n : \u2115) : Agree (sCorec f i n) (sCorec f i (succ n))", "start": [129, 1], "end": [135, 13], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.Path", "code": "def Path (F : PFunctor.{u}) :=\n  List F.Idx", "start": [139, 1], "end": [141, 13], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.Path.inhabited", "code": "instance Path.inhabited : Inhabited (Path F) :=\n  \u27e8[]\u27e9", "start": [144, 1], "end": [145, 7], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.CofixA.instSubsingleton", "code": "instance CofixA.instSubsingleton : Subsingleton (CofixA F 0) :=\n  \u27e8by rintro \u27e8\u27e9 \u27e8\u27e9; rfl\u27e9", "start": [150, 1], "end": [151, 25], "kind": "commanddeclaration"}, {"full_name": "PFunctor.Approx.head_succ'", "code": "theorem head_succ' (n m : \u2115) (x : \u2200 n, CofixA F n) (Hconsistent : AllAgree x) :\n    head' (x (succ n)) = head' (x (succ m))", "start": [153, 1], "end": [175, 17], "kind": "commanddeclaration"}, {"full_name": "PFunctor.MIntl", "code": "structure MIntl where\n  \n  approx : \u2200 n, CofixA F n\n  \n  consistent : AllAgree approx", "start": [182, 1], "end": [189, 31], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M", "code": "def M :=\n  MIntl F", "start": [193, 1], "end": [195, 10], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.default_consistent", "code": "theorem M.default_consistent [Inhabited F.A] : \u2200 n, Agree (default : CofixA F n) default", "start": [199, 1], "end": [201, 62], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.inhabited", "code": "instance M.inhabited [Inhabited F.A] : Inhabited (M F) :=\n  \u27e8{  approx := default\n      consistent := M.default_consistent _ }\u27e9", "start": [205, 1], "end": [207, 46], "kind": "commanddeclaration"}, {"full_name": "PFunctor.MIntl.inhabited", "code": "instance MIntl.inhabited [Inhabited F.A] : Inhabited (MIntl F) :=\n  show Inhabited (M F) by infer_instance", "start": [211, 1], "end": [212, 41], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.ext'", "code": "theorem ext' (x y : M F) (H : \u2200 i : \u2115, x.approx i = y.approx i) : x = y", "start": [218, 1], "end": [222, 10], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corec", "code": "protected def corec (i : X) : M F where\n  approx := sCorec f i\n  consistent := P_corec _ _", "start": [232, 1], "end": [235, 28], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.head", "code": "def head (x : M F) :=\n  head' (x.1 1)", "start": [239, 1], "end": [242, 16], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.children", "code": "def children (x : M F) (i : F.B (head x)) : M F :=\n  let H := fun n : \u2115 => @head_succ' _ n 0 x.1 x.2\n  { approx := fun n => children' (x.1 _) (cast (congr_arg _ <| by simp only [head, H]) i)\n    consistent := by\n      intro n\n      have P' := x.2 (succ n)\n      apply agree_children _ _ _ P'\n      trans i\n      apply cast_heq\n      symm\n      apply cast_heq }", "start": [246, 1], "end": [257, 23], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.ichildren", "code": "def ichildren [Inhabited (M F)] [DecidableEq F.A] (i : F.Idx) (x : M F) : M F :=\n  if H' : i.1 = head x then children x (cast (congr_arg _ <| by simp only [head, H']) i.2)\n  else default", "start": [261, 1], "end": [265, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.head_succ", "code": "theorem head_succ (n m : \u2115) (x : M F) : head' (x.approx (succ n)) = head' (x.approx (succ m))", "start": [269, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.head_eq_head'", "code": "theorem head_eq_head' : \u2200 (x : M F) (n : \u2115), head x = head' (x.approx <| n + 1)", "start": [274, 1], "end": [275, 36], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.head'_eq_head", "code": "theorem head'_eq_head : \u2200 (x : M F) (n : \u2115), head' (x.approx <| n + 1) = head x", "start": [279, 1], "end": [280, 36], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.truncate_approx", "code": "theorem truncate_approx (x : M F) (n : \u2115) : truncate (x.approx <| n + 1) = x.approx n", "start": [284, 1], "end": [285, 44], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.dest", "code": "def dest : M F \u2192 F (M F)\n  | x => \u27e8head x, fun i => children x i\u27e9", "start": [289, 1], "end": [291, 41], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.Approx.sMk", "code": "protected def sMk (x : F (M F)) : \u2200 n, CofixA F n\n  | 0 => CofixA.continue\n  | succ n => CofixA.intro x.1 fun i => (x.2 i).approx n", "start": [297, 1], "end": [300, 57], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.Approx.P_mk", "code": "protected theorem P_mk (x : F (M F)) : AllAgree (Approx.sMk x)", "start": [304, 1], "end": [309, 29], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.mk", "code": "protected def mk (x : F (M F)) : M F\n    where\n  approx := Approx.sMk x\n  consistent := Approx.P_mk x", "start": [315, 1], "end": [319, 30], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.Agree'", "code": "inductive Agree' : \u2115 \u2192 M F \u2192 M F \u2192 Prop\n  | trivial (x y : M F) : Agree' 0 x y\n  | step {n : \u2115} {a} (x y : F.B a \u2192 M F) {x' y'} :\n      x' = M.mk \u27e8a, x\u27e9 \u2192 y' = M.mk \u27e8a, y\u27e9 \u2192 (\u2200 i, Agree' n (x i) (y i)) \u2192 Agree' (succ n) x' y'", "start": [323, 1], "end": [328, 96], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.dest_mk", "code": "@[simp]\ntheorem dest_mk (x : F (M F)) : dest (M.mk x) = x", "start": [332, 1], "end": [333, 57], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.mk_dest", "code": "@[simp]\ntheorem mk_dest (x : M F) : M.mk (dest x) = x", "start": [337, 1], "end": [361, 8], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.mk_inj", "code": "theorem mk_inj {x y : F (M F)} (h : M.mk x = M.mk y) : x = y", "start": [365, 1], "end": [365, 96], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.cases", "code": "protected def cases {r : M F \u2192 Sort w} (f : \u2200 x : F (M F), r (M.mk x)) (x : M F) : r x :=\n  suffices r (M.mk (dest x)) by\n    rw [\u2190 mk_dest x]\n    exact this\n  f _", "start": [369, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.casesOn", "code": "protected def casesOn {r : M F \u2192 Sort w} (x : M F) (f : \u2200 x : F (M F), r (M.mk x)) : r x :=\n  M.cases f x", "start": [378, 1], "end": [380, 14], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.casesOn'", "code": "protected def casesOn' {r : M F \u2192 Sort w} (x : M F) (f : \u2200 a f, r (M.mk \u27e8a, f\u27e9)) : r x :=\n  M.casesOn x (fun \u27e8a, g\u27e9 => f a g)", "start": [384, 1], "end": [387, 36], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.approx_mk", "code": "theorem approx_mk (a : F.A) (f : F.B a \u2192 M F) (i : \u2115) :\n    (M.mk \u27e8a, f\u27e9).approx (succ i) = CofixA.intro a fun j => (f j).approx i", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.agree'_refl", "code": "@[simp]\ntheorem agree'_refl {n : \u2115} (x : M F) : Agree' n x x", "start": [397, 1], "end": [402, 13], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.agree_iff_agree'", "code": "theorem agree_iff_agree' {n : \u2115} (x y : M F) :\n    Agree (x.approx n) (y.approx <| n + 1) \u2194 Agree' n x y", "start": [406, 1], "end": [432, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.cases_mk", "code": "@[simp]\ntheorem cases_mk {r : M F \u2192 Sort*} (x : F (M F)) (f : \u2200 x : F (M F), r (M.mk x)) :\n    PFunctor.M.cases f (M.mk x) = f x", "start": [436, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.casesOn_mk", "code": "@[simp]\ntheorem casesOn_mk {r : M F \u2192 Sort*} (x : F (M F)) (f : \u2200 x : F (M F), r (M.mk x)) :\n    PFunctor.M.casesOn (M.mk x) f = f x", "start": [447, 1], "end": [450, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.casesOn_mk'", "code": "@[simp]\ntheorem casesOn_mk' {r : M F \u2192 Sort*} {a} (x : F.B a \u2192 M F)\n    (f : \u2200 (a) (f : F.B a \u2192 M F), r (M.mk \u27e8a, f\u27e9)) :\n    PFunctor.M.casesOn' (M.mk \u27e8a, x\u27e9) f = f a x", "start": [454, 1], "end": [458, 45], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.IsPath", "code": "inductive IsPath : Path F \u2192 M F \u2192 Prop\n  | nil (x : M F) : IsPath [] x\n  |\n  cons (xs : Path F) {a} (x : M F) (f : F.B a \u2192 M F) (i : F.B a) :\n    x = M.mk \u27e8a, f\u27e9 \u2192 IsPath xs (f i) \u2192 IsPath (\u27e8a, i\u27e9 :: xs) x", "start": [462, 1], "end": [467, 64], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.isPath_cons", "code": "theorem isPath_cons {xs : Path F} {a a'} {f : F.B a \u2192 M F} {i : F.B a'} :\n    IsPath (\u27e8a', i\u27e9 :: xs) (M.mk \u27e8a, f\u27e9) \u2192 a = a'", "start": [471, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.isPath_cons'", "code": "theorem isPath_cons' {xs : Path F} {a} {f : F.B a \u2192 M F} {i : F.B a} :\n    IsPath (\u27e8a, i\u27e9 :: xs) (M.mk \u27e8a, f\u27e9) \u2192 IsPath xs (f i)", "start": [480, 1], "end": [485, 11], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.isubtree", "code": "def isubtree [DecidableEq F.A] [Inhabited (M F)] : Path F \u2192 M F \u2192 M F\n  | [], x => x\n  | \u27e8a, i\u27e9 :: ps, x =>\n    PFunctor.M.casesOn' (r := fun _ => M F) x (fun a' f =>\n      if h : a = a' then\n        isubtree ps (f <| cast (by rw [h]) i)\n      else\n        default (\u03b1 := M F)\n    )", "start": [489, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.iselect", "code": "def iselect [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) : M F \u2192 F.A := fun x : M F =>\n  head <| isubtree ps x", "start": [505, 1], "end": [508, 24], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.iselect_eq_default", "code": "theorem iselect_eq_default [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) (x : M F)\n    (h : \u00acIsPath ps x) : iselect ps x = head default", "start": [512, 1], "end": [529, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.head_mk", "code": "@[simp]\ntheorem head_mk (x : F (M F)) : head (M.mk x) = x.1", "start": [533, 1], "end": [538, 31], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.children_mk", "code": "theorem children_mk {a} (x : F.B a \u2192 M F) (i : F.B (head (M.mk \u27e8a, x\u27e9))) :\n    children (M.mk \u27e8a, x\u27e9) i = x (cast (by rw [head_mk]) i)", "start": [543, 1], "end": [544, 91], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.ichildren_mk", "code": "@[simp]\ntheorem ichildren_mk [DecidableEq F.A] [Inhabited (M F)] (x : F (M F)) (i : F.Idx) :\n    ichildren i (M.mk x) = x.iget i", "start": [548, 1], "end": [552, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.isubtree_cons", "code": "@[simp]\ntheorem isubtree_cons [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) {a} (f : F.B a \u2192 M F)\n    {i : F.B a} : isubtree (\u27e8_, i\u27e9 :: ps) (M.mk \u27e8a, f\u27e9) = isubtree ps (f i)", "start": [556, 1], "end": [559, 95], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.iselect_nil", "code": "@[simp]\ntheorem iselect_nil [DecidableEq F.A] [Inhabited (M F)] {a} (f : F.B a \u2192 M F) :\n    iselect nil (M.mk \u27e8a, f\u27e9) = a", "start": [563, 1], "end": [565, 41], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.iselect_cons", "code": "@[simp]\ntheorem iselect_cons [DecidableEq F.A] [Inhabited (M F)] (ps : Path F) {a} (f : F.B a \u2192 M F) {i} :\n    iselect (\u27e8a, i\u27e9 :: ps) (M.mk \u27e8a, f\u27e9) = iselect ps (f i)", "start": [569, 1], "end": [571, 101], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corec_def", "code": "theorem corec_def {X} (f : X \u2192 F X) (x\u2080 : X) : M.corec f x\u2080 = M.mk (M.corec f <$> f x\u2080)", "start": [575, 1], "end": [583, 10], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.ext_aux", "code": "theorem ext_aux [Inhabited (M F)] [DecidableEq F.A] {n : \u2115} (x y z : M F) (hx : Agree' n z x)\n    (hy : Agree' n z y) (hrec : \u2200 ps : Path F, n = ps.length \u2192 iselect ps x = iselect ps y) :\n    x.approx (n + 1) = y.approx (n + 1)", "start": [587, 1], "end": [620, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.ext", "code": "theorem ext [Inhabited (M F)] (x y : M F) (H : \u2200 ps : Path F, iselect ps x = iselect ps y) :\n    x = y", "start": [628, 1], "end": [643, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.IsBisimulation", "code": "structure IsBisimulation : Prop where\n  \n  head : \u2200 {a a'} {f f'}, M.mk \u27e8a, f\u27e9 ~ M.mk \u27e8a', f'\u27e9 \u2192 a = a'\n  \n  tail : \u2200 {a} {f f' : F.B a \u2192 M F}, M.mk \u27e8a, f\u27e9 ~ M.mk \u27e8a, f'\u27e9 \u2192 \u2200 i : F.B a, f i ~ f' i", "start": [653, 1], "end": [659, 90], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.nth_of_bisim", "code": "theorem nth_of_bisim [Inhabited (M F)] (bisim : IsBisimulation R) (s\u2081 s\u2082) (ps : Path F) :\n    (R s\u2081 s\u2082) \u2192\n      IsPath ps s\u2081 \u2228 IsPath ps s\u2082 \u2192\n        iselect ps s\u2081 = iselect ps s\u2082 \u2227\n          \u2203 (a : _) (f f' : F.B a \u2192 M F),\n            isubtree ps s\u2081 = M.mk \u27e8a, f\u27e9 \u2227\n              isubtree ps s\u2082 = M.mk \u27e8a, f'\u27e9 \u2227 \u2200 i : F.B a, f i ~ f' i", "start": [663, 1], "end": [691, 44], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.eq_of_bisim", "code": "theorem eq_of_bisim [Nonempty (M F)] (bisim : IsBisimulation R) : \u2200 s\u2081 s\u2082, R s\u2081 s\u2082 \u2192 s\u2081 = s\u2082", "start": [695, 1], "end": [704, 53], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corecOn", "code": "def corecOn {X : Type*} (x\u2080 : X) (f : X \u2192 F X) : M F :=\n  M.corec f x\u2080", "start": [712, 1], "end": [714, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.dest_corec", "code": "theorem dest_corec (g : \u03b1 \u2192 P \u03b1) (x : \u03b1) : M.dest (M.corec g x) = M.corec g <$> g x", "start": [720, 1], "end": [721, 26], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.bisim", "code": "theorem bisim (R : M P \u2192 M P \u2192 Prop)\n    (h : \u2200 x y, R x y \u2192 \u2203 a f f', M.dest x = \u27e8a, f\u27e9 \u2227 M.dest y = \u27e8a, f'\u27e9 \u2227 \u2200 i, R (f i) (f' i)) :\n    \u2200 x y, R x y \u2192 x = y", "start": [725, 1], "end": [739, 13], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.bisim'", "code": "theorem bisim' {\u03b1 : Type*} (Q : \u03b1 \u2192 Prop) (u v : \u03b1 \u2192 M P)\n    (h : \u2200 x, Q x \u2192 \u2203 a f f',\n          M.dest (u x) = \u27e8a, f\u27e9\n          \u2227 M.dest (v x) = \u27e8a, f'\u27e9\n          \u2227 \u2200 i, \u2203 x', Q x' \u2227 f i = u x' \u2227 f' i = v x'\n      ) :\n    \u2200 x, Q x \u2192 u x = v x", "start": [743, 1], "end": [755, 26], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.bisim_equiv", "code": "theorem bisim_equiv (R : M P \u2192 M P \u2192 Prop)\n    (h : \u2200 x y, R x y \u2192 \u2203 a f f', M.dest x = \u27e8a, f\u27e9 \u2227 M.dest y = \u27e8a, f'\u27e9 \u2227 \u2200 i, R (f i) (f' i)) :\n    \u2200 x y, R x y \u2192 x = y", "start": [760, 1], "end": [768, 15], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corec_unique", "code": "theorem corec_unique (g : \u03b1 \u2192 P \u03b1) (f : \u03b1 \u2192 M P) (hyp : \u2200 x, M.dest (f x) = f <$> g x) :\n    f = M.corec g", "start": [772, 1], "end": [783, 34], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corec\u2081", "code": "def corec\u2081 {\u03b1 : Type u} (F : \u2200 X, (\u03b1 \u2192 X) \u2192 \u03b1 \u2192 P X) : \u03b1 \u2192 M P :=\n  M.corec (F _ id)", "start": [787, 1], "end": [790, 19], "kind": "commanddeclaration"}, {"full_name": "PFunctor.M.corec'", "code": "def corec' {\u03b1 : Type u} (F : \u2200 {X : Type u}, (\u03b1 \u2192 X) \u2192 \u03b1 \u2192 Sum (M P) (P X)) (x : \u03b1) : M P :=\n  corec\u2081\n    (fun _ rec (a : Sum (M P) \u03b1) =>\n      let y := a >>= F (rec \u2218 Sum.inr)\n      match y with\n      | Sum.inr y => y\n      | Sum.inl y => (rec \u2218 Sum.inl) <$> M.dest y)\n    (@Sum.inr (M P) _ x)", "start": [794, 1], "end": [803, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Preadditive/InjectiveResolution.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/Injective.lean", "Mathlib/Algebra/Homology/Single.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.InjectiveResolution", "code": "structure InjectiveResolution (Z : C) where\n  cocomplex : CochainComplex C \u2115\n  \u03b9 : (CochainComplex.single\u2080 C).obj Z \u27f6 cocomplex\n  injective : \u2200 n, Injective (cocomplex.X n) := by infer_instance\n  exact\u2080 : Exact (\u03b9.f 0) (cocomplex.d 0 1) := by infer_instance\n  exact : \u2200 n, Exact (cocomplex.d n (n + 1)) (cocomplex.d (n + 1) (n + 2)) := by infer_instance\n  mono : Mono (\u03b9.f 0) := by infer_instance", "start": [41, 1], "end": [61, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasInjectiveResolution", "code": "class HasInjectiveResolution (Z : C) : Prop where\n  out : Nonempty (InjectiveResolution Z)", "start": [71, 1], "end": [73, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.HasInjectiveResolutions", "code": "class HasInjectiveResolutions : Prop where\n  out : \u2200 Z : C, HasInjectiveResolution Z", "start": [82, 1], "end": [85, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.\u03b9_f_succ", "code": "@[simp]\ntheorem \u03b9_f_succ {Z : C} (I : InjectiveResolution Z) (n : \u2115) : I.\u03b9.f (n + 1) = 0", "start": [94, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.\u03b9_f_zero_comp_complex_d", "code": "theorem \u03b9_f_zero_comp_complex_d {Z : C} (I : InjectiveResolution Z) :\n    I.\u03b9.f 0 \u226b I.cocomplex.d 0 1 = 0", "start": [102, 1], "end": [104, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.complex_d_comp", "code": "theorem complex_d_comp {Z : C} (I : InjectiveResolution Z) (n : \u2115) :\n    I.cocomplex.d n (n + 1) \u226b I.cocomplex.d (n + 1) (n + 2) = 0", "start": [109, 1], "end": [111, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InjectiveResolution.self", "code": "def self (Z : C) [CategoryTheory.Injective Z] : InjectiveResolution Z where\n  cocomplex := (CochainComplex.single\u2080 C).obj Z\n  \u03b9 := \ud835\udfd9 ((CochainComplex.single\u2080 C).obj Z)\n  injective n := by\n    cases n <;>\n      \u00b7 dsimp\n        infer_instance\n  exact\u2080 := by\n    dsimp\n    exact exact_epi_zero _\n  exact n := by\n    dsimp\n    exact exact_of_zero _ _\n  mono := by\n    dsimp\n    infer_instance", "start": [120, 1], "end": [136, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/UpperLower.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsUpperSet.smul_subset", "code": "@[to_additive]\ntheorem IsUpperSet.smul_subset (hs : IsUpperSet s) (hx : 1 \u2264 x) : x \u2022 s \u2286 s", "start": [26, 1], "end": [28, 64], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.smul_subset", "code": "@[to_additive]\ntheorem IsLowerSet.smul_subset (hs : IsLowerSet s) (hx : x \u2264 1) : x \u2022 s \u2286 s", "start": [32, 1], "end": [34, 64], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.smul", "code": "@[to_additive]\ntheorem IsUpperSet.smul (hs : IsUpperSet s) : IsUpperSet (a \u2022 s)", "start": [44, 1], "end": [45, 99], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.smul", "code": "@[to_additive]\ntheorem IsLowerSet.smul (hs : IsLowerSet s) : IsLowerSet (a \u2022 s)", "start": [49, 1], "end": [50, 99], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.smul", "code": "@[to_additive]\ntheorem Set.OrdConnected.smul (hs : s.OrdConnected) : (a \u2022 s).OrdConnected", "start": [54, 1], "end": [57, 96], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.mul_left", "code": "@[to_additive]\ntheorem IsUpperSet.mul_left (ht : IsUpperSet t) : IsUpperSet (s * t)", "start": [61, 1], "end": [64, 45], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.mul_right", "code": "@[to_additive]\ntheorem IsUpperSet.mul_right (hs : IsUpperSet s) : IsUpperSet (s * t)", "start": [68, 1], "end": [71, 20], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.mul_left", "code": "@[to_additive]\ntheorem IsLowerSet.mul_left (ht : IsLowerSet t) : IsLowerSet (s * t)", "start": [75, 1], "end": [76, 91], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.mul_right", "code": "@[to_additive]\ntheorem IsLowerSet.mul_right (hs : IsLowerSet s) : IsLowerSet (s * t)", "start": [80, 1], "end": [81, 93], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.inv", "code": "@[to_additive]\ntheorem IsUpperSet.inv (hs : IsUpperSet s) : IsLowerSet s\u207b\u00b9", "start": [85, 1], "end": [86, 95], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.inv", "code": "@[to_additive]\ntheorem IsLowerSet.inv (hs : IsLowerSet s) : IsUpperSet s\u207b\u00b9", "start": [90, 1], "end": [91, 95], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.div_left", "code": "@[to_additive]\ntheorem IsUpperSet.div_left (ht : IsUpperSet t) : IsLowerSet (s / t)", "start": [95, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.div_right", "code": "@[to_additive]\ntheorem IsUpperSet.div_right (hs : IsUpperSet s) : IsUpperSet (s / t)", "start": [102, 1], "end": [105, 21], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.div_left", "code": "@[to_additive]\ntheorem IsLowerSet.div_left (ht : IsLowerSet t) : IsUpperSet (s / t)", "start": [109, 1], "end": [110, 91], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.div_right", "code": "@[to_additive]\ntheorem IsLowerSet.div_right (hs : IsLowerSet s) : IsLowerSet (s / t)", "start": [114, 1], "end": [115, 93], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_one", "code": "@[to_additive (attr := simp,norm_cast)]\ntheorem coe_one : ((1 : UpperSet \u03b1) : Set \u03b1) = Set.Ici 1", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_mul", "code": "@[to_additive (attr := simp,norm_cast)]\ntheorem coe_mul (s t : UpperSet \u03b1) : (\u2191(s * t) : Set \u03b1) = s * t", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_div", "code": "@[to_additive (attr := simp,norm_cast)]\ntheorem coe_div (s t : UpperSet \u03b1) : (\u2191(s / t) : Set \u03b1) = s / t", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_one", "code": "@[to_additive (attr := simp)]\ntheorem Ici_one : Ici (1 : \u03b1) = 1", "start": [155, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup : CommSemigroup (UpperSet \u03b1) :=\n  { (SetLike.coe_injective.commSemigroup _ coe_mul : CommSemigroup (UpperSet \u03b1)) with }", "start": [165, 1], "end": [167, 88], "kind": "commanddeclaration"}, {"full_name": "UpperSet.one_mul", "code": "@[to_additive]\nprivate theorem one_mul (s : UpperSet \u03b1) : 1 * s = s", "start": [169, 1], "end": [174, 59], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_mul", "code": "@[to_additive (attr := simp,norm_cast)]\ntheorem coe_mul (s t : LowerSet \u03b1) : (\u2191(s * t) : Set \u03b1) = s * t", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_div", "code": "@[to_additive (attr := simp,norm_cast)]\ntheorem coe_div (s t : LowerSet \u03b1) : (\u2191(s / t) : Set \u03b1) = s / t", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_one", "code": "@[to_additive (attr := simp)]\ntheorem Iic_one : Iic (1 : \u03b1) = 1", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup : CommSemigroup (LowerSet \u03b1) :=\n  { (SetLike.coe_injective.commSemigroup _ coe_mul : CommSemigroup (LowerSet \u03b1)) with }", "start": [227, 1], "end": [229, 88], "kind": "commanddeclaration"}, {"full_name": "LowerSet.one_mul", "code": "@[to_additive]\nprivate theorem one_mul (s : LowerSet \u03b1) : 1 * s = s", "start": [231, 1], "end": [236, 59], "kind": "commanddeclaration"}, {"full_name": "upperClosure_one", "code": "@[to_additive (attr := simp)]\ntheorem upperClosure_one : upperClosure (1 : Set \u03b1) = 1", "start": [251, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_one", "code": "@[to_additive (attr := simp)]\ntheorem lowerClosure_one : lowerClosure (1 : Set \u03b1) = 1", "start": [257, 1], "end": [259, 27], "kind": "commanddeclaration"}, {"full_name": "upperClosure_smul", "code": "@[to_additive (attr := simp)]\ntheorem upperClosure_smul : upperClosure (a \u2022 s) = a \u2022 upperClosure s", "start": [263, 1], "end": [265, 43], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_smul", "code": "@[to_additive (attr := simp)]\ntheorem lowerClosure_smul : lowerClosure (a \u2022 s) = a \u2022 lowerClosure s", "start": [269, 1], "end": [271, 43], "kind": "commanddeclaration"}, {"full_name": "mul_upperClosure", "code": "@[to_additive]\ntheorem mul_upperClosure : s * upperClosure t = upperClosure (s * t)", "start": [275, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "mul_lowerClosure", "code": "@[to_additive]\ntheorem mul_lowerClosure : s * lowerClosure t = lowerClosure (s * t)", "start": [283, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "upperClosure_mul", "code": "@[to_additive]\ntheorem upperClosure_mul : \u2191(upperClosure s) * t = upperClosure (s * t)", "start": [291, 1], "end": [294, 29], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_mul", "code": "@[to_additive]\ntheorem lowerClosure_mul : \u2191(lowerClosure s) * t = lowerClosure (s * t)", "start": [298, 1], "end": [301, 29], "kind": "commanddeclaration"}, {"full_name": "upperClosure_mul_distrib", "code": "@[to_additive (attr := simp)]\ntheorem upperClosure_mul_distrib : upperClosure (s * t) = upperClosure s * upperClosure t", "start": [305, 1], "end": [308, 85], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_mul_distrib", "code": "@[to_additive (attr := simp)]\ntheorem lowerClosure_mul_distrib : lowerClosure (s * t) = lowerClosure s * lowerClosure t", "start": [312, 1], "end": [315, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Generator.lean", "imports": ["Mathlib/CategoryTheory/Limits/EssentiallySmall.lean", "Mathlib/CategoryTheory/Subobject/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Balanced.lean", "Mathlib/Data/Set/Opposite.lean", "Mathlib/CategoryTheory/Limits/Opposites.lean", "Mathlib/CategoryTheory/Subobject/WellPowered.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean"], "premises": [{"full_name": "CategoryTheory.IsSeparating", "code": "def IsSeparating (\ud835\udca2 : Set C) : Prop :=\n  \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : G \u27f6 X), h \u226b f = h \u226b g) \u2192 f = g", "start": [65, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoseparating", "code": "def IsCoseparating (\ud835\udca2 : Set C) : Prop :=\n  \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : Y \u27f6 G), f \u226b h = g \u226b h) \u2192 f = g", "start": [71, 1], "end": [74, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetecting", "code": "def IsDetecting (\ud835\udca2 : Set C) : Prop :=\n  \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : G \u27f6 Y), \u2203! h' : G \u27f6 X, h' \u226b f = h) \u2192 IsIso f", "start": [77, 1], "end": [80, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetecting", "code": "def IsCodetecting (\ud835\udca2 : Set C) : Prop :=\n  \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 G \u2208 \ud835\udca2, \u2200 (h : X \u27f6 G), \u2203! h' : Y \u27f6 G, f \u226b h' = h) \u2192 IsIso f", "start": [83, 1], "end": [87, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparating_op_iff", "code": "theorem isSeparating_op_iff (\ud835\udca2 : Set C) : IsSeparating \ud835\udca2.op \u2194 IsCoseparating \ud835\udca2", "start": [92, 1], "end": [97, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparating_op_iff", "code": "theorem isCoseparating_op_iff (\ud835\udca2 : Set C) : IsCoseparating \ud835\udca2.op \u2194 IsSeparating \ud835\udca2", "start": [100, 1], "end": [105, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparating_unop_iff", "code": "theorem isCoseparating_unop_iff (\ud835\udca2 : Set C\u1d52\u1d56) : IsCoseparating \ud835\udca2.unop \u2194 IsSeparating \ud835\udca2", "start": [108, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparating_unop_iff", "code": "theorem isSeparating_unop_iff (\ud835\udca2 : Set C\u1d52\u1d56) : IsSeparating \ud835\udca2.unop \u2194 IsCoseparating \ud835\udca2", "start": [112, 1], "end": [113, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetecting_op_iff", "code": "theorem isDetecting_op_iff (\ud835\udca2 : Set C) : IsDetecting \ud835\udca2.op \u2194 IsCodetecting \ud835\udca2", "start": [116, 1], "end": [125, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetecting_op_iff", "code": "theorem isCodetecting_op_iff (\ud835\udca2 : Set C) : IsCodetecting \ud835\udca2.op \u2194 IsDetecting \ud835\udca2", "start": [128, 1], "end": [137, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetecting_unop_iff", "code": "theorem isDetecting_unop_iff (\ud835\udca2 : Set C\u1d52\u1d56) : IsDetecting \ud835\udca2.unop \u2194 IsCodetecting \ud835\udca2", "start": [140, 1], "end": [141, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetecting_unop_iff", "code": "theorem isCodetecting_unop_iff {\ud835\udca2 : Set C\u1d52\u1d56} : IsCodetecting \ud835\udca2.unop \u2194 IsDetecting \ud835\udca2", "start": [144, 1], "end": [145, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetecting.isSeparating", "code": "theorem IsDetecting.isSeparating [HasEqualizers C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) :\n    IsSeparating \ud835\udca2", "start": [150, 1], "end": [153, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetecting.isCoseparating", "code": "theorem IsCodetecting.isCoseparating [HasCoequalizers C] {\ud835\udca2 : Set C} :\n    IsCodetecting \ud835\udca2 \u2192 IsCoseparating \ud835\udca2", "start": [158, 1], "end": [160, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSeparating.isDetecting", "code": "theorem IsSeparating.isDetecting [Balanced C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsSeparating \ud835\udca2) :\n    IsDetecting \ud835\udca2", "start": [165, 1], "end": [174, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoseparating.isCodetecting", "code": "theorem IsCoseparating.isCodetecting [Balanced C] {\ud835\udca2 : Set C} :\n    IsCoseparating \ud835\udca2 \u2192 IsCodetecting \ud835\udca2", "start": [181, 1], "end": [183, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetecting_iff_isSeparating", "code": "theorem isDetecting_iff_isSeparating [HasEqualizers C] [Balanced C] (\ud835\udca2 : Set C) :\n    IsDetecting \ud835\udca2 \u2194 IsSeparating \ud835\udca2", "start": [188, 1], "end": [190, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetecting_iff_isCoseparating", "code": "theorem isCodetecting_iff_isCoseparating [HasCoequalizers C] [Balanced C] {\ud835\udca2 : Set C} :\n    IsCodetecting \ud835\udca2 \u2194 IsCoseparating \ud835\udca2", "start": [193, 1], "end": [195, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSeparating.mono", "code": "theorem IsSeparating.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsSeparating \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\n    IsSeparating \u210b", "start": [200, 1], "end": [201, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoseparating.mono", "code": "theorem IsCoseparating.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsCoseparating \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\n    IsCoseparating \u210b", "start": [204, 1], "end": [205, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetecting.mono", "code": "theorem IsDetecting.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\n    IsDetecting \u210b", "start": [208, 1], "end": [209, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetecting.mono", "code": "theorem IsCodetecting.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsCodetecting \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\n    IsCodetecting \u210b", "start": [212, 1], "end": [213, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.thin_of_isSeparating_empty", "code": "theorem thin_of_isSeparating_empty (h : IsSeparating (\u2205 : Set C)) : Quiver.IsThin C", "start": [220, 1], "end": [221, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparating_empty_of_thin", "code": "theorem isSeparating_empty_of_thin [Quiver.IsThin C] : IsSeparating (\u2205 : Set C)", "start": [224, 1], "end": [225, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.thin_of_isCoseparating_empty", "code": "theorem thin_of_isCoseparating_empty (h : IsCoseparating (\u2205 : Set C)) : Quiver.IsThin C", "start": [228, 1], "end": [229, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparating_empty_of_thin", "code": "theorem isCoseparating_empty_of_thin [Quiver.IsThin C] : IsCoseparating (\u2205 : Set C)", "start": [232, 1], "end": [233, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoid_of_isDetecting_empty", "code": "theorem groupoid_of_isDetecting_empty (h : IsDetecting (\u2205 : Set C)) {X Y : C} (f : X \u27f6 Y) :\n    IsIso f", "start": [236, 1], "end": [238, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetecting_empty_of_groupoid", "code": "theorem isDetecting_empty_of_groupoid [\u2200 {X Y : C} (f : X \u27f6 Y), IsIso f] :\n    IsDetecting (\u2205 : Set C)", "start": [241, 1], "end": [242, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.groupoid_of_isCodetecting_empty", "code": "theorem groupoid_of_isCodetecting_empty (h : IsCodetecting (\u2205 : Set C)) {X Y : C} (f : X \u27f6 Y) :\n    IsIso f", "start": [245, 1], "end": [247, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetecting_empty_of_groupoid", "code": "theorem isCodetecting_empty_of_groupoid [\u2200 {X Y : C} (f : X \u27f6 Y), IsIso f] :\n    IsCodetecting (\u2205 : Set C)", "start": [250, 1], "end": [251, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparating_iff_epi", "code": "theorem isSeparating_iff_epi (\ud835\udca2 : Set C)\n    [\u2200 A : C, HasCoproduct fun f : \u03a3G : \ud835\udca2, (G : C) \u27f6 A => (f.1 : C)] :\n    IsSeparating \ud835\udca2 \u2194 \u2200 A : C, Epi (Sigma.desc (@Sigma.snd \ud835\udca2 fun G => (G : C) \u27f6 A))", "start": [256, 1], "end": [264, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparating_iff_mono", "code": "theorem isCoseparating_iff_mono (\ud835\udca2 : Set C)\n    [\u2200 A : C, HasProduct fun f : \u03a3G : \ud835\udca2, A \u27f6 (G : C) => (f.1 : C)] :\n    IsCoseparating \ud835\udca2 \u2194 \u2200 A : C, Mono (Pi.lift (@Sigma.snd \ud835\udca2 fun G => A \u27f6 (G : C)))", "start": [267, 1], "end": [274, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasInitial_of_isCoseparating", "code": "theorem hasInitial_of_isCoseparating [WellPowered C] [HasLimits C] {\ud835\udca2 : Set C} [Small.{v\u2081} \ud835\udca2]\n    (h\ud835\udca2 : IsCoseparating \ud835\udca2) : HasInitial C", "start": [277, 1], "end": [300, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hasTerminal_of_isSeparating", "code": "theorem hasTerminal_of_isSeparating [WellPowered C\u1d52\u1d56] [HasColimits C] {\ud835\udca2 : Set C} [Small.{v\u2081} \ud835\udca2]\n    (h\ud835\udca2 : IsSeparating \ud835\udca2) : HasTerminal C", "start": [303, 1], "end": [312, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.eq_of_le_of_isDetecting", "code": "theorem eq_of_le_of_isDetecting {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) {X : C} (P Q : Subobject X)\n    (h\u2081 : P \u2264 Q) (h\u2082 : \u2200 G \u2208 \ud835\udca2, \u2200 {f : G \u27f6 X}, Q.Factors f \u2192 P.Factors f) : P = Q", "start": [319, 1], "end": [327, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.inf_eq_of_isDetecting", "code": "theorem inf_eq_of_isDetecting [HasPullbacks C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) {X : C}\n    (P Q : Subobject X) (h : \u2200 G \u2208 \ud835\udca2, \u2200 {f : G \u27f6 X}, P.Factors f \u2192 Q.Factors f) : P \u2293 Q = P", "start": [330, 1], "end": [333, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subobject.eq_of_isDetecting", "code": "theorem eq_of_isDetecting [HasPullbacks C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) {X : C}\n    (P Q : Subobject X) (h : \u2200 G \u2208 \ud835\udca2, \u2200 {f : G \u27f6 X}, P.Factors f \u2194 Q.Factors f) : P = Q", "start": [336, 1], "end": [341, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.wellPowered_of_isDetecting", "code": "theorem wellPowered_of_isDetecting [HasPullbacks C] {\ud835\udca2 : Set C} [Small.{v\u2081} \ud835\udca2]\n    (h\ud835\udca2 : IsDetecting \ud835\udca2) : WellPowered C", "start": [347, 1], "end": [352, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.StructuredArrow.isCoseparating_proj_preimage", "code": "theorem isCoseparating_proj_preimage {\ud835\udca2 : Set C} (h\ud835\udca2 : IsCoseparating \ud835\udca2) :\n    IsCoseparating ((proj S T).obj \u207b\u00b9' \ud835\udca2)", "start": [361, 1], "end": [364, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CostructuredArrow.isSeparating_proj_preimage", "code": "theorem isSeparating_proj_preimage {\ud835\udca2 : Set C} (h\ud835\udca2 : IsSeparating \ud835\udca2) :\n    IsSeparating ((proj S T).obj \u207b\u00b9' \ud835\udca2)", "start": [373, 1], "end": [376, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSeparator", "code": "def IsSeparator (G : C) : Prop :=\n  IsSeparating ({G} : Set C)", "start": [381, 1], "end": [383, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoseparator", "code": "def IsCoseparator (G : C) : Prop :=\n  IsCoseparating ({G} : Set C)", "start": [386, 1], "end": [388, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetector", "code": "def IsDetector (G : C) : Prop :=\n  IsDetecting ({G} : Set C)", "start": [391, 1], "end": [393, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetector", "code": "def IsCodetector (G : C) : Prop :=\n  IsCodetecting ({G} : Set C)", "start": [396, 1], "end": [398, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_op_iff", "code": "theorem isSeparator_op_iff (G : C) : IsSeparator (op G) \u2194 IsCoseparator G", "start": [403, 1], "end": [404, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_op_iff", "code": "theorem isCoseparator_op_iff (G : C) : IsCoseparator (op G) \u2194 IsSeparator G", "start": [407, 1], "end": [408, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_unop_iff", "code": "theorem isCoseparator_unop_iff (G : C\u1d52\u1d56) : IsCoseparator (unop G) \u2194 IsSeparator G", "start": [411, 1], "end": [412, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_unop_iff", "code": "theorem isSeparator_unop_iff (G : C\u1d52\u1d56) : IsSeparator (unop G) \u2194 IsCoseparator G", "start": [415, 1], "end": [416, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetector_op_iff", "code": "theorem isDetector_op_iff (G : C) : IsDetector (op G) \u2194 IsCodetector G", "start": [419, 1], "end": [420, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetector_op_iff", "code": "theorem isCodetector_op_iff (G : C) : IsCodetector (op G) \u2194 IsDetector G", "start": [423, 1], "end": [424, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetector_unop_iff", "code": "theorem isCodetector_unop_iff (G : C\u1d52\u1d56) : IsCodetector (unop G) \u2194 IsDetector G", "start": [427, 1], "end": [428, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetector_unop_iff", "code": "theorem isDetector_unop_iff (G : C\u1d52\u1d56) : IsDetector (unop G) \u2194 IsCodetector G", "start": [431, 1], "end": [432, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetector.isSeparator", "code": "theorem IsDetector.isSeparator [HasEqualizers C] {G : C} : IsDetector G \u2192 IsSeparator G", "start": [437, 1], "end": [438, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetector.isCoseparator", "code": "theorem IsCodetector.isCoseparator [HasCoequalizers C] {G : C} : IsCodetector G \u2192 IsCoseparator G", "start": [441, 1], "end": [442, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSeparator.isDetector", "code": "theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G \u2192 IsDetector G", "start": [445, 1], "end": [446, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCospearator.isCodetector", "code": "theorem IsCospearator.isCodetector [Balanced C] {G : C} : IsCoseparator G \u2192 IsCodetector G", "start": [449, 1], "end": [450, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_def", "code": "theorem isSeparator_def (G : C) :\n    IsSeparator G \u2194 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : G \u27f6 X, h \u226b f = h \u226b g) \u2192 f = g", "start": [453, 1], "end": [459, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSeparator.def", "code": "theorem IsSeparator.def {G : C} :\n    IsSeparator G \u2192 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : G \u27f6 X, h \u226b f = h \u226b g) \u2192 f = g", "start": [462, 1], "end": [464, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_def", "code": "theorem isCoseparator_def (G : C) :\n    IsCoseparator G \u2194 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : Y \u27f6 G, f \u226b h = g \u226b h) \u2192 f = g", "start": [467, 1], "end": [473, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCoseparator.def", "code": "theorem IsCoseparator.def {G : C} :\n    IsCoseparator G \u2192 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : Y \u27f6 G, f \u226b h = g \u226b h) \u2192 f = g", "start": [476, 1], "end": [478, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetector_def", "code": "theorem isDetector_def (G : C) :\n    IsDetector G \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : G \u27f6 Y, \u2203! h', h' \u226b f = h) \u2192 IsIso f", "start": [481, 1], "end": [487, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsDetector.def", "code": "theorem IsDetector.def {G : C} :\n    IsDetector G \u2192 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : G \u27f6 Y, \u2203! h', h' \u226b f = h) \u2192 IsIso f", "start": [490, 1], "end": [492, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetector_def", "code": "theorem isCodetector_def (G : C) :\n    IsCodetector G \u2194 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : X \u27f6 G, \u2203! h', f \u226b h' = h) \u2192 IsIso f", "start": [495, 1], "end": [501, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsCodetector.def", "code": "theorem IsCodetector.def {G : C} :\n    IsCodetector G \u2192 \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), (\u2200 h : X \u27f6 G, \u2203! h', f \u226b h' = h) \u2192 IsIso f", "start": [504, 1], "end": [506, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_iff_faithful_coyoneda_obj", "code": "theorem isSeparator_iff_faithful_coyoneda_obj (G : C) :\n    IsSeparator G \u2194 Faithful (coyoneda.obj (op G))", "start": [509, 1], "end": [512, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_iff_faithful_yoneda_obj", "code": "theorem isCoseparator_iff_faithful_yoneda_obj (G : C) : IsCoseparator G \u2194 Faithful (yoneda.obj G)", "start": [515, 1], "end": [518, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_iff_epi", "code": "theorem isSeparator_iff_epi (G : C) [\u2200 A : C, HasCoproduct fun _ : G \u27f6 A => G] :\n    IsSeparator G \u2194 \u2200 A : C, Epi (Sigma.desc fun f : G \u27f6 A => f)", "start": [521, 1], "end": [528, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_iff_mono", "code": "theorem isCoseparator_iff_mono (G : C) [\u2200 A : C, HasProduct fun _ : A \u27f6 G => G] :\n    IsCoseparator G \u2194 \u2200 A : C, Mono (Pi.lift fun f : A \u27f6 G => f)", "start": [531, 1], "end": [538, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_coprod", "code": "theorem isSeparator_coprod (G H : C) [HasBinaryCoproduct G H] :\n    IsSeparator (G \u2a3f H) \u2194 IsSeparating ({G, H} : Set C)", "start": [545, 1], "end": [556, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_coprod_of_isSeparator_left", "code": "theorem isSeparator_coprod_of_isSeparator_left (G H : C) [HasBinaryCoproduct G H]\n    (hG : IsSeparator G) : IsSeparator (G \u2a3f H)", "start": [559, 1], "end": [561, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_coprod_of_isSeparator_right", "code": "theorem isSeparator_coprod_of_isSeparator_right (G H : C) [HasBinaryCoproduct G H]\n    (hH : IsSeparator H) : IsSeparator (G \u2a3f H)", "start": [564, 1], "end": [566, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_sigma", "code": "theorem isSeparator_sigma {\u03b2 : Type w} (f : \u03b2 \u2192 C) [HasCoproduct f] :\n    IsSeparator (\u2210 f) \u2194 IsSeparating (Set.range f)", "start": [569, 1], "end": [577, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSeparator_sigma_of_isSeparator", "code": "theorem isSeparator_sigma_of_isSeparator {\u03b2 : Type w} (f : \u03b2 \u2192 C) [HasCoproduct f] (b : \u03b2)\n    (hb : IsSeparator (f b)) : IsSeparator (\u2210 f)", "start": [580, 1], "end": [582, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_prod", "code": "theorem isCoseparator_prod (G H : C) [HasBinaryProduct G H] :\n    IsCoseparator (G \u2a2f H) \u2194 IsCoseparating ({G, H} : Set C)", "start": [585, 1], "end": [596, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_prod_of_isCoseparator_left", "code": "theorem isCoseparator_prod_of_isCoseparator_left (G H : C) [HasBinaryProduct G H]\n    (hG : IsCoseparator G) : IsCoseparator (G \u2a2f H)", "start": [599, 1], "end": [601, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_prod_of_isCoseparator_right", "code": "theorem isCoseparator_prod_of_isCoseparator_right (G H : C) [HasBinaryProduct G H]\n    (hH : IsCoseparator H) : IsCoseparator (G \u2a2f H)", "start": [604, 1], "end": [606, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_pi", "code": "theorem isCoseparator_pi {\u03b2 : Type w} (f : \u03b2 \u2192 C) [HasProduct f] :\n    IsCoseparator (\u220f f) \u2194 IsCoseparating (Set.range f)", "start": [609, 1], "end": [617, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCoseparator_pi_of_isCoseparator", "code": "theorem isCoseparator_pi_of_isCoseparator {\u03b2 : Type w} (f : \u03b2 \u2192 C) [HasProduct f] (b : \u03b2)\n    (hb : IsCoseparator (f b)) : IsCoseparator (\u220f f)", "start": [620, 1], "end": [622, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isDetector_iff_reflectsIsomorphisms_coyoneda_obj", "code": "theorem isDetector_iff_reflectsIsomorphisms_coyoneda_obj (G : C) :\n    IsDetector G \u2194 ReflectsIsomorphisms (coyoneda.obj (op G))", "start": [627, 1], "end": [636, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isCodetector_iff_reflectsIsomorphisms_yoneda_obj", "code": "theorem isCodetector_iff_reflectsIsomorphisms_yoneda_obj (G : C) :\n    IsCodetector G \u2194 ReflectsIsomorphisms (yoneda.obj G)", "start": [639, 1], "end": [647, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.wellPowered_of_isDetector", "code": "theorem wellPowered_of_isDetector [HasPullbacks C] (G : C) (hG : IsDetector G) : WellPowered C", "start": [650, 1], "end": [653, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Ideal.lean", "imports": ["Mathlib/Order/Atoms.lean", "Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Logic/Encodable/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.Ideal", "code": "structure Ideal (P) [LE P] extends LowerSet P where\n  \n  nonempty' : carrier.Nonempty\n  \n  directed' : DirectedOn (\u00b7 \u2264 \u00b7) carrier", "start": [55, 1], "end": [63, 41], "kind": "commanddeclaration"}, {"full_name": "Order.IsIdeal", "code": "@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  \n  IsLowerSet : IsLowerSet I\n  \n  Nonempty : I.Nonempty\n  \n  Directed : DirectedOn (\u00b7 \u2264 \u00b7) I", "start": [70, 1], "end": [81, 34], "kind": "commanddeclaration"}, {"full_name": "Order.IsIdeal.toIdeal", "code": "def IsIdeal.toIdeal [LE P] {I : Set P} (h : IsIdeal I) : Ideal P :=\n  \u27e8\u27e8I, h.IsLowerSet\u27e9, h.Nonempty, h.Directed\u27e9", "start": [84, 1], "end": [87, 46], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.toLowerSet_injective", "code": "theorem toLowerSet_injective : Injective (toLowerSet : Ideal P \u2192 LowerSet P)", "start": [100, 1], "end": [103, 8], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.ext", "code": "@[ext]\ntheorem ext {s t : Ideal P} : (s : Set P) = t \u2192 s = t", "start": [110, 1], "end": [112, 15], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.carrier_eq_coe", "code": "@[simp]\ntheorem carrier_eq_coe (s : Ideal P) : s.carrier = s", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_toLowerSet", "code": "@[simp]\ntheorem coe_toLowerSet (s : Ideal P) : (s.toLowerSet : Set P) = s", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.lower", "code": "protected theorem lower (s : Ideal P) : IsLowerSet (s : Set P)", "start": [125, 1], "end": [126, 11], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.nonempty", "code": "protected theorem nonempty (s : Ideal P) : (s : Set P).Nonempty", "start": [129, 1], "end": [130, 14], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.directed", "code": "protected theorem directed (s : Ideal P) : DirectedOn (\u00b7 \u2264 \u00b7) (s : Set P)", "start": [133, 1], "end": [134, 14], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isIdeal", "code": "protected theorem isIdeal (s : Ideal P) : IsIdeal (s : Set P)", "start": [137, 1], "end": [138, 36], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_compl_of_ge", "code": "theorem mem_compl_of_ge {x y : P} : x \u2264 y \u2192 x \u2208 (I : Set P)\u1d9c \u2192 y \u2208 (I : Set P)\u1d9c", "start": [141, 1], "end": [142, 18], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.instPartialOrderIdeal", "code": "instance instPartialOrderIdeal : PartialOrder (Ideal P) :=\n  PartialOrder.lift SetLike.coe SetLike.coe_injective", "start": [145, 1], "end": [147, 54], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_subset_coe", "code": "theorem coe_subset_coe : (s : Set P) \u2286 t \u2194 s \u2264 t", "start": [150, 1], "end": [151, 10], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_ssubset_coe", "code": "theorem coe_ssubset_coe : (s : Set P) \u2282 t \u2194 s < t", "start": [155, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_of_mem_of_le", "code": "@[trans]\ntheorem mem_of_mem_of_le {x : P} {I J : Ideal P} : x \u2208 I \u2192 I \u2264 J \u2192 x \u2208 J", "start": [159, 1], "end": [161, 36], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsProper", "code": "@[mk_iff]\nclass IsProper (I : Ideal P) : Prop where\n  \n  ne_univ : (I : Set P) \u2260 univ", "start": [164, 1], "end": [169, 31], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isProper_of_not_mem", "code": "theorem isProper_of_not_mem {I : Ideal P} {p : P} (nmem : p \u2209 I) : IsProper I", "start": [172, 1], "end": [176, 21], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsMaximal", "code": "@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  \n  maximal_proper : \u2200 \u2983J : Ideal P\u2984, I < J \u2192 (J : Set P) = univ", "start": [179, 1], "end": [186, 63], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.inter_nonempty", "code": "theorem inter_nonempty [IsDirected P (\u00b7 \u2265 \u00b7)] (I J : Ideal P) : (I \u2229 J : Set P).Nonempty", "start": [189, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.top_toLowerSet", "code": "@[simp]\ntheorem top_toLowerSet : (\u22a4 : Ideal P).toLowerSet = \u22a4", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : Ideal P) : Set P) = univ", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isProper_of_ne_top", "code": "theorem isProper_of_ne_top (ne_top : I \u2260 \u22a4) : IsProper I", "start": [217, 1], "end": [218, 28], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsProper.ne_top", "code": "theorem IsProper.ne_top (_ : IsProper I) : I \u2260 \u22a4", "start": [221, 1], "end": [222, 54], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.isProper", "code": "theorem _root_.IsCoatom.isProper (hI : IsCoatom I) : IsProper I", "start": [225, 1], "end": [226, 26], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isProper_iff_ne_top", "code": "theorem isProper_iff_ne_top : IsProper I \u2194 I \u2260 \u22a4", "start": [229, 1], "end": [230, 51], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsMaximal.isCoatom", "code": "theorem IsMaximal.isCoatom (_ : IsMaximal I) : IsCoatom I", "start": [233, 1], "end": [234, 77], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsMaximal.isCoatom'", "code": "theorem IsMaximal.isCoatom' [IsMaximal I] : IsCoatom I", "start": [237, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.isMaximal", "code": "theorem _root_.IsCoatom.isMaximal (hI : IsCoatom I) : IsMaximal I", "start": [241, 1], "end": [242, 81], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.isMaximal_iff_isCoatom", "code": "theorem isMaximal_iff_isCoatom : IsMaximal I \u2194 IsCoatom I", "start": [245, 1], "end": [246, 53], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.bot_mem", "code": "@[simp]\ntheorem bot_mem (s : Ideal P) : \u22a5 \u2208 s", "start": [255, 1], "end": [257, 38], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.top_of_top_mem", "code": "theorem top_of_top_mem (h : \u22a4 \u2208 I) : I = \u22a4", "start": [266, 1], "end": [268, 47], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsProper.top_not_mem", "code": "theorem IsProper.top_not_mem (hI : IsProper I) : \u22a4 \u2209 I", "start": [271, 1], "end": [271, 96], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.principal", "code": "@[simps]\ndef principal (p : P) : Ideal P where\n  toLowerSet := LowerSet.Iic p\n  nonempty' := nonempty_Iic\n  directed' _ hx _ hy := \u27e8p, le_rfl, hx, hy\u27e9", "start": [286, 1], "end": [291, 45], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.principal_le_iff", "code": "@[simp]\ntheorem principal_le_iff : principal x \u2264 I \u2194 x \u2208 I", "start": [297, 1], "end": [299, 50], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_principal", "code": "@[simp]\ntheorem mem_principal : x \u2208 principal y \u2194 x \u2264 y", "start": [302, 1], "end": [304, 10], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.principal_bot", "code": "@[simp]\ntheorem principal_bot : principal (\u22a5 : P) = \u22a5", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.principal_top", "code": "@[simp]\ntheorem principal_top : principal (\u22a4 : P) = \u22a4", "start": [329, 1], "end": [331, 43], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.sup_mem", "code": "theorem sup_mem (hx : x \u2208 s) (hy : y \u2208 s) : x \u2294 y \u2208 s", "start": [342, 1], "end": [345, 28], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.sup_mem_iff", "code": "@[simp]\ntheorem sup_mem_iff : x \u2294 y \u2208 I \u2194 x \u2208 I \u2227 y \u2208 I", "start": [348, 1], "end": [350, 85], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_sup", "code": "@[simp]\ntheorem coe_sup : \u2191(s \u2294 t) = { x | \u2203 a \u2208 s, \u2203 b \u2208 t, x \u2264 a \u2294 b }", "start": [402, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_inf", "code": "@[simp]\ntheorem coe_inf : (\u2191(s \u2293 t) : Set P) = \u2191s \u2229 \u2191t", "start": [408, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_inf", "code": "@[simp]\ntheorem mem_inf : x \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J", "start": [413, 1], "end": [415, 10], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_sup", "code": "@[simp]\ntheorem mem_sup : x \u2208 I \u2294 J \u2194 \u2203 i \u2208 I, \u2203 j \u2208 J, x \u2264 i \u2294 j", "start": [418, 1], "end": [420, 10], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.lt_sup_principal_of_not_mem", "code": "theorem lt_sup_principal_of_not_mem (hx : x \u2209 I) : I < I \u2294 principal x", "start": [423, 1], "end": [424, 91], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_sInf", "code": "@[simp]\ntheorem coe_sInf : (\u2191(sInf S) : Set P) = \u22c2 s \u2208 S, \u2191s", "start": [448, 1], "end": [450, 23], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.mem_sInf", "code": "@[simp]\ntheorem mem_sInf : x \u2208 sInf S \u2194 \u2200 s \u2208 S, x \u2208 s", "start": [453, 1], "end": [455, 53], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.eq_sup_of_le_sup", "code": "theorem eq_sup_of_le_sup {x i j : P} (hi : i \u2208 I) (hj : j \u2208 J) (hx : x \u2264 i \u2294 j) :\n    \u2203 i' \u2208 I, \u2203 j' \u2208 J, x = i' \u2294 j'", "start": [473, 1], "end": [478, 38], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.coe_sup_eq", "code": "theorem coe_sup_eq : \u2191(I \u2294 J) = { x | \u2203 i \u2208 I, \u2203 j \u2208 J, x = i \u2294 j }", "start": [481, 1], "end": [484, 38], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsProper.not_mem_of_compl_mem", "code": "theorem IsProper.not_mem_of_compl_mem (hI : IsProper I) (hxc : x\u1d9c \u2208 I) : x \u2209 I", "start": [493, 1], "end": [497, 31], "kind": "commanddeclaration"}, {"full_name": "Order.Ideal.IsProper.not_mem_or_compl_not_mem", "code": "theorem IsProper.not_mem_or_compl_not_mem (hI : IsProper I) : x \u2209 I \u2228 x\u1d9c \u2209 I", "start": [500, 1], "end": [502, 8], "kind": "commanddeclaration"}, {"full_name": "Order.Cofinal", "code": "structure Cofinal (P) [Preorder P] where\n  \n  carrier : Set P\n  \n  mem_gt : \u2200 x : P, \u2203 y \u2208 carrier, x \u2264 y", "start": [509, 1], "end": [516, 41], "kind": "commanddeclaration"}, {"full_name": "Order.Cofinal.above", "code": "noncomputable def above : P :=\n  Classical.choose <| D.mem_gt x", "start": [532, 1], "end": [534, 33], "kind": "commanddeclaration"}, {"full_name": "Order.Cofinal.above_mem", "code": "theorem above_mem : D.above x \u2208 D", "start": [537, 1], "end": [538, 42], "kind": "commanddeclaration"}, {"full_name": "Order.Cofinal.le_above", "code": "theorem le_above : x \u2264 D.above x", "start": [541, 1], "end": [542, 42], "kind": "commanddeclaration"}, {"full_name": "Order.sequenceOfCofinals", "code": "noncomputable def sequenceOfCofinals : \u2115 \u2192 P\n  | 0 => p\n  | n + 1 =>\n    match Encodable.decode n with\n    | none => sequenceOfCofinals n\n    | some i => (\ud835\udc9f i).above (sequenceOfCofinals n)", "start": [551, 1], "end": [558, 51], "kind": "commanddeclaration"}, {"full_name": "Order.sequenceOfCofinals.monotone", "code": "theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p \ud835\udc9f)", "start": [561, 1], "end": [567, 27], "kind": "commanddeclaration"}, {"full_name": "Order.sequenceOfCofinals.encode_mem", "code": "theorem sequenceOfCofinals.encode_mem (i : \u03b9) :\n    sequenceOfCofinals p \ud835\udc9f (Encodable.encode i + 1) \u2208 \ud835\udc9f i", "start": [570, 1], "end": [574, 26], "kind": "commanddeclaration"}, {"full_name": "Order.idealOfCofinals", "code": "def idealOfCofinals : Ideal P where\n  carrier := { x : P | \u2203 n, x \u2264 sequenceOfCofinals p \ud835\udc9f n }\n  lower' := fun _ _ hxy \u27e8n, hn\u27e9 \u21a6 \u27e8n, le_trans hxy hn\u27e9\n  nonempty' := \u27e8p, 0, le_rfl\u27e9\n  directed' := fun _ \u27e8n, hn\u27e9 _ \u27e8m, hm\u27e9 \u21a6\n    \u27e8_, \u27e8max n m, le_rfl\u27e9, le_trans hn <| sequenceOfCofinals.monotone p \ud835\udc9f (le_max_left _ _),\n      le_trans hm <| sequenceOfCofinals.monotone p \ud835\udc9f (le_max_right _ _)\u27e9", "start": [577, 1], "end": [589, 73], "kind": "commanddeclaration"}, {"full_name": "Order.mem_idealOfCofinals", "code": "theorem mem_idealOfCofinals : p \u2208 idealOfCofinals p \ud835\udc9f", "start": [592, 1], "end": [593, 14], "kind": "commanddeclaration"}, {"full_name": "Order.cofinal_meets_idealOfCofinals", "code": "theorem cofinal_meets_idealOfCofinals (i : \u03b9) : \u2203 x : P, x \u2208 \ud835\udc9f i \u2227 x \u2208 idealOfCofinals p \ud835\udc9f", "start": [596, 1], "end": [598, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Localization/Equivalence.lean", "imports": ["Mathlib/CategoryTheory/CatCommSq.lean", "Mathlib/CategoryTheory/Localization/Predicate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Localization.equivalence", "code": "noncomputable def equivalence : D\u2081 \u224c D\u2082 :=\n  Equivalence.mk G' F' (liftNatIso L\u2081 W\u2081 L\u2081 (G \u22d9 F') (\ud835\udfed D\u2081) (G' \u22d9 F') \u03b1.symm)\n    (liftNatIso L\u2082 W\u2082 (F \u22d9 G') L\u2082 (F' \u22d9 G') (\ud835\udfed D\u2082) \u03b2)", "start": [39, 1], "end": [42, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Localization.equivalence_counitIso_app", "code": "@[simp]\nlemma equivalence_counitIso_app (X : C\u2082) :\n    (equivalence L\u2081 W\u2081 L\u2082 W\u2082 G G' F F' \u03b1 \u03b2).counitIso.app (L\u2082.obj X) =\n      (Lifting.iso L\u2082 W\u2082 (F \u22d9 G') (F' \u22d9 G')).app X \u226a\u226b \u03b2.app X := by\n  ext\n  dsimp [equivalence, Equivalence.mk]\n  rw [liftNatTrans_app]\n  dsimp [Lifting.iso]\n  rw [comp_id]", "start": [44, 1], "end": [52, 15], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Localization.isEquivalence", "code": "noncomputable def isEquivalence : IsEquivalence G' :=\n  IsEquivalence.ofEquivalence (equivalence L\u2081 W\u2081 L\u2082 W\u2082 G G' F F' \u03b1 \u03b2)", "start": [54, 1], "end": [56, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.IsLocalization.of_equivalence_source", "code": "lemma of_equivalence_source (L\u2081 : C\u2081 \u2964 D) (W\u2081 : MorphismProperty C\u2081)\n    (L\u2082 : C\u2082 \u2964 D) (W\u2082 : MorphismProperty C\u2082)\n    (E : C\u2081 \u224c C\u2082) (hW\u2081 : W\u2081 \u2286 W\u2082.isoClosure.inverseImage E.functor) (hW\u2082 : W\u2082.IsInvertedBy L\u2082)\n    [L\u2081.IsLocalization W\u2081] (iso : E.functor \u22d9 L\u2082 \u2245 L\u2081) : L\u2082.IsLocalization W\u2082 := by\n  have h : W\u2081.IsInvertedBy (E.functor \u22d9 W\u2082.Q) := fun _ _ f hf => by\n    obtain \u27e8_, _, f', hf', \u27e8e\u27e9\u27e9 := hW\u2081 f hf\n    exact ((MorphismProperty.RespectsIso.isomorphisms _).arrow_mk_iso_iff\n      (W\u2082.Q.mapArrow.mapIso e)).1 (Localization.inverts W\u2082.Q W\u2082 _ hf')\n  exact\n    { inverts := hW\u2082\n      nonempty_isEquivalence :=\n        \u27e8Localization.isEquivalence W\u2082.Q W\u2082 L\u2081 W\u2081 L\u2082 (Construction.lift L\u2082 hW\u2082)\n          (E.functor \u22d9 W\u2082.Q) (Localization.lift (E.functor \u22d9 W\u2082.Q) h L\u2081) (by\n            calc\n              L\u2082 \u22d9 lift (E.functor \u22d9 W\u2082.Q) h L\u2081 \u2245 _ := (leftUnitor _).symm\n              _ \u2245 _ := isoWhiskerRight E.counitIso.symm _\n              _ \u2245 E.inverse \u22d9 E.functor \u22d9 L\u2082 \u22d9 lift (E.functor \u22d9 W\u2082.Q) h L\u2081 :=\n                    Functor.associator _ _ _\n              _ \u2245 E.inverse \u22d9 L\u2081 \u22d9 lift (E.functor \u22d9 W\u2082.Q) h L\u2081 :=\n                    isoWhiskerLeft E.inverse ((Functor.associator _ _ _).symm \u226a\u226b\n                      isoWhiskerRight iso _)\n              _ \u2245 E.inverse \u22d9 E.functor \u22d9 W\u2082.Q :=\n                    isoWhiskerLeft _ (Localization.fac (E.functor \u22d9 W\u2082.Q) h L\u2081)\n              _ \u2245 (E.inverse \u22d9 E.functor) \u22d9 W\u2082.Q := (Functor.associator _ _ _).symm\n              _ \u2245 \ud835\udfed C\u2082 \u22d9 W\u2082.Q := isoWhiskerRight E.counitIso _\n              _ \u2245 W\u2082.Q := leftUnitor _)\n          (Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft _ (Lifting.iso W\u2082.Q W\u2082 _ _)  \u226a\u226b iso)\u27e9 }", "start": [64, 1], "end": [93, 94], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.IsLocalization.of_equivalences", "code": "lemma of_equivalences (L\u2081 : C\u2081 \u2964 D\u2081) (W\u2081 : MorphismProperty C\u2081) [L\u2081.IsLocalization W\u2081]\n    (L\u2082 : C\u2082 \u2964 D\u2082) (W\u2082 : MorphismProperty C\u2082)\n    (E : C\u2081 \u224c C\u2082) (E' : D\u2081 \u224c D\u2082) [CatCommSq E.functor L\u2081 L\u2082 E'.functor]\n    (hW\u2081 : W\u2081 \u2286 W\u2082.isoClosure.inverseImage E.functor) (hW\u2082 : W\u2082.IsInvertedBy L\u2082) :\n    L\u2082.IsLocalization W\u2082 := by\n  haveI : (E.functor \u22d9 L\u2082).IsLocalization W\u2081 :=\n    of_equivalence_target L\u2081 W\u2081 _ E' ((CatCommSq.iso _ _ _ _).symm)\n  exact of_equivalence_source (E.functor \u22d9 L\u2082) W\u2081 L\u2082 W\u2082 E hW\u2081 hW\u2082 (Iso.refl _)", "start": [95, 1], "end": [106, 79], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Hom/Freiman.lean", "imports": ["Mathlib/Data/FunLike/Basic.lean", "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddFreimanHom", "code": "structure AddFreimanHom (A : Set \u03b1) (\u03b2 : Type*) [AddCommMonoid \u03b1] [AddCommMonoid \u03b2] (n : \u2115) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_sum_eq_map_sum' {s t : Multiset \u03b1} (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.sum = t.sum) :\n    (s.map toFun).sum = (t.map toFun).sum", "start": [57, 1], "end": [64, 42], "kind": "commanddeclaration"}, {"full_name": "FreimanHom", "code": "@[to_additive AddFreimanHom]\nstructure FreimanHom (A : Set \u03b1) (\u03b2 : Type*) [CommMonoid \u03b1] [CommMonoid \u03b2] (n : \u2115) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_prod_eq_map_prod' {s t : Multiset \u03b1} (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n) (h : s.prod = t.prod) :\n    (s.map toFun).prod = (t.map toFun).prod", "start": [67, 1], "end": [75, 44], "kind": "commanddeclaration"}, {"full_name": "AddFreimanHomClass", "code": "class AddFreimanHomClass (F : Type*) (A : outParam <| Set \u03b1) (\u03b2 : outParam <| Type*)\n  [AddCommMonoid \u03b1] [AddCommMonoid \u03b2] (n : \u2115) [FunLike F \u03b1 fun _ => \u03b2] : Prop where\n  \n  map_sum_eq_map_sum' (f : F) {s t : Multiset \u03b1} (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A)\n    (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A) (hs : Multiset.card s = n) (ht : Multiset.card t = n)\n    (h : s.sum = t.sum) :\n    (s.map f).sum = (t.map f).sum", "start": [88, 1], "end": [96, 34], "kind": "commanddeclaration"}, {"full_name": "FreimanHomClass", "code": "@[to_additive AddFreimanHomClass\n      \"`AddFreimanHomClass F A \u03b2 n` states that `F` is a type of `n`-ary\n      sums-preserving morphisms. You should extend this class when you extend `AddFreimanHom`.\"]\nclass FreimanHomClass (F : Type*) (A : outParam <| Set \u03b1) (\u03b2 : outParam <| Type*) [CommMonoid \u03b1]\n  [CommMonoid \u03b2] (n : \u2115) [FunLike F \u03b1 fun _ => \u03b2] : Prop where\n  \n  map_prod_eq_map_prod' (f : F) {s t : Multiset \u03b1} (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A)\n    (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A) (hs : Multiset.card s = n) (ht : Multiset.card t = n)\n    (h : s.prod = t.prod) :\n    (s.map f).prod = (t.map f).prod", "start": [99, 1], "end": [110, 36], "kind": "commanddeclaration"}, {"full_name": "FreimanHomClass.toFreimanHom", "code": "@[to_additive (attr := coe)\n    \" Turn an element of a type `F` satisfying `AddFreimanHomClass F A \u03b2 n` into an actual\n    `AddFreimanHom`. This is declared as the default coercion from `F` to `AddFreimanHom A \u03b2 n`.\"]\ndef _root_.FreimanHomClass.toFreimanHom [FreimanHomClass F A \u03b2 n] (f : F) : A \u2192*[n] \u03b2 where\n  toFun := FunLike.coe f\n  map_prod_eq_map_prod' := FreimanHomClass.map_prod_eq_map_prod' f", "start": [122, 1], "end": [129, 67], "kind": "commanddeclaration"}, {"full_name": "map_prod_eq_map_prod", "code": "@[to_additive]\ntheorem map_prod_eq_map_prod [FreimanHomClass F A \u03b2 n] (f : F) {s t : Multiset \u03b1}\n    (hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A)\n    (hs : Multiset.card s = n) (ht : Multiset.card t = n)\n    (h : s.prod = t.prod) : (s.map f).prod = (t.map f).prod", "start": [137, 1], "end": [142, 58], "kind": "commanddeclaration"}, {"full_name": "map_mul_map_eq_map_mul_map", "code": "@[to_additive]\ntheorem map_mul_map_eq_map_mul_map [FreimanHomClass F A \u03b2 2] (f : F) (ha : a \u2208 A) (hb : b \u2208 A)\n    (hc : c \u2208 A) (hd : d \u2208 A) (h : a * b = c * d) : f a * f b = f c * f d", "start": [146, 1], "end": [150, 97], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.funLike", "code": "@[to_additive]\ninstance funLike : FunLike (A \u2192*[n] \u03b2) \u03b1 fun _ => \u03b2 where\n  coe := toFun\n  coe_injective' f g h := by cases f; cases g; congr", "start": [156, 1], "end": [159, 53], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.freimanHomClass", "code": "@[to_additive addFreimanHomClass]\ninstance freimanHomClass : FreimanHomClass (A \u2192*[n] \u03b2) A \u03b2 n where\n  map_prod_eq_map_prod' := map_prod_eq_map_prod'", "start": [163, 1], "end": [165, 49], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.toFun_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toFun_eq_coe (f : A \u2192*[n] \u03b2) : f.toFun = f", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext \u2983f g : A \u2192*[n] \u03b2\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [187, 1], "end": [189, 20], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_mk (f : \u03b1 \u2192 \u03b2)\n    (h :\n      \u2200 s t : Multiset \u03b1,\n        (\u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) \u2192\n          (\u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A) \u2192\n            Multiset.card s = n \u2192 Multiset.card t = n \u2192\n              s.prod = t.prod \u2192 (s.map f).prod = (t.map f).prod) :\n    \u21d1(mk f (h _ _)) = f", "start": [193, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem mk_coe (f : A \u2192*[n] \u03b2) (h) : mk f h = f", "start": [206, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.id", "code": "@[to_additive (attr := simps) \"The identity map from an additive commutative monoid to itself.\"]\nprotected def id (A : Set \u03b1) (n : \u2115) : A \u2192*[n] \u03b1 where\n  toFun x := x\n  map_prod_eq_map_prod' _ _ _ _ h := by rw [map_id', map_id', h]", "start": [212, 1], "end": [216, 65], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.comp", "code": "@[to_additive \"Composition of additive Freiman homomorphisms as an additive Freiman homomorphism.\"]\nprotected def comp (f : B \u2192*[n] \u03b3) (g : A \u2192*[n] \u03b2) (hAB : A.MapsTo g B) : A \u2192*[n] \u03b3 where\n  toFun := f \u2218 g\n  map_prod_eq_map_prod' hsA htA hs ht h := by\n    rw [\u2190 map_map, \u2190 map_map]\n    apply map_prod_eq_map_prod f _ _ ((card_map _ _).trans hs)\n    \u00b7 rwa [card_map]\n    \u00b7 apply (map_prod_eq_map_prod g hsA htA hs ht h)\n    \u00b7 simpa using fun a h => hAB (hsA h)\n    \u00b7 simpa using fun a h => hAB (htA h)", "start": [221, 1], "end": [231, 41], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem coe_comp (f : B \u2192*[n] \u03b3) (g : A \u2192*[n] \u03b2) {hfg} : \u21d1(f.comp g hfg) = f \u2218 g", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.comp_apply", "code": "@[to_additive]\ntheorem comp_apply (f : B \u2192*[n] \u03b3) (g : A \u2192*[n] \u03b2) {hfg} (x : \u03b1) : f.comp g hfg x = f (g x)", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.comp_assoc", "code": "@[to_additive]\ntheorem comp_assoc (f : A \u2192*[n] \u03b2) (g : B \u2192*[n] \u03b3) (h : C \u2192*[n] \u03b4) {hf hhg hgf}\n    {hh : A.MapsTo (g.comp f hgf) C} : (h.comp g hhg).comp f hf = h.comp (g.comp f hgf) hh", "start": [247, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem cancel_right {g\u2081 g\u2082 : B \u2192*[n] \u03b3} {f : A \u2192*[n] \u03b2} (hf : Function.Surjective f) {hg\u2081 hg\u2082} :\n    g\u2081.comp f hg\u2081 = g\u2082.comp f hg\u2082 \u2194 g\u2081 = g\u2082", "start": [254, 1], "end": [257, 73], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.cancel_right_on", "code": "@[to_additive]\ntheorem cancel_right_on {g\u2081 g\u2082 : B \u2192*[n] \u03b3} {f : A \u2192*[n] \u03b2} (hf : A.SurjOn f B) {hf'} :\n    A.EqOn (g\u2081.comp f hf') (g\u2082.comp f hf') \u2194 B.EqOn g\u2081 g\u2082", "start": [261, 1], "end": [264, 32], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.cancel_left_on", "code": "@[to_additive]\ntheorem cancel_left_on {g : B \u2192*[n] \u03b3} {f\u2081 f\u2082 : A \u2192*[n] \u03b2} (hg : B.InjOn g) {hf\u2081 hf\u2082} :\n    A.EqOn (g.comp f\u2081 hf\u2081) (g.comp f\u2082 hf\u2082) \u2194 A.EqOn f\u2081 f\u2082", "start": [268, 1], "end": [271, 35], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem comp_id (f : A \u2192*[n] \u03b2) {hf} : f.comp (FreimanHom.id A n) hf = f", "start": [275, 1], "end": [277, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.id_comp", "code": "@[to_additive (attr := simp)]\ntheorem id_comp (f : A \u2192*[n] \u03b2) {hf} : (FreimanHom.id B n).comp f hf = f", "start": [281, 1], "end": [283, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.const", "code": "@[to_additive \"`AddFreimanHom.const An b` is the Freiman homomorphism sending everything to `b`.\"]\ndef const (A : Set \u03b1) (n : \u2115) (b : \u03b2) : A \u2192*[n] \u03b2 where\n  toFun _ := b\n  map_prod_eq_map_prod' _ _ hs ht _ := by\n    simp only [map_const', hs, prod_replicate, ht]", "start": [287, 1], "end": [292, 51], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.const_apply", "code": "@[to_additive (attr := simp)]\ntheorem const_apply (n : \u2115) (b : \u03b2) (x : \u03b1) : const A n b x = b", "start": [296, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.const_comp", "code": "@[to_additive (attr := simp)]\ntheorem const_comp (n : \u2115) (c : \u03b3) (f : A \u2192*[n] \u03b2) {hf} : (const B n c).comp f hf = const A n c", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem one_apply (x : \u03b1) : (1 : A \u2192*[n] \u03b2) x = 1", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem one_comp (f : A \u2192*[n] \u03b2) {hf} : (1 : B \u2192*[n] \u03b3).comp f hf = 1", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply (f g : A \u2192*[n] \u03b2) (x : \u03b1) : (f * g) x = f x * g x", "start": [339, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.mul_comp", "code": "@[to_additive]\ntheorem mul_comp (g\u2081 g\u2082 : B \u2192*[n] \u03b3) (f : A \u2192*[n] \u03b2) {hg hg\u2081 hg\u2082} :\n    (g\u2081 * g\u2082).comp f hg = g\u2081.comp f hg\u2081 * g\u2082.comp f hg\u2082", "start": [345, 1], "end": [348, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.inv_apply", "code": "@[to_additive (attr := simp)]\ntheorem inv_apply (f : A \u2192*[n] G) (x : \u03b1) : f\u207b\u00b9 x = (f x)\u207b\u00b9", "start": [363, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.inv_comp", "code": "@[to_additive (attr := simp)]\ntheorem inv_comp (f : B \u2192*[n] G) (g : A \u2192*[n] \u03b2) {hf hf'} : f\u207b\u00b9.comp g hf = (f.comp g hf')\u207b\u00b9", "start": [369, 1], "end": [371, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.div_apply", "code": "@[to_additive (attr := simp)]\ntheorem div_apply (f g : A \u2192*[n] G) (x : \u03b1) : (f / g) x = f x / g x", "start": [387, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.div_comp", "code": "@[to_additive (attr := simp)]\ntheorem div_comp (f\u2081 f\u2082 : B \u2192*[n] G) (g : A \u2192*[n] \u03b2) {hf hf\u2081 hf\u2082} :\n    (f\u2081 / f\u2082).comp g hf = f\u2081.comp g hf\u2081 / f\u2082.comp g hf\u2082", "start": [393, 1], "end": [396, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.commMonoid", "code": "@[to_additive \"`\u03b1 \u2192+[n] \u03b2` is an `AddCommMonoid`.\"]\ninstance commMonoid : CommMonoid (A \u2192*[n] \u03b2) where\n  mul_assoc a b c := by\n    ext\n    apply mul_assoc\n  one_mul a := by\n    ext\n    apply one_mul\n  mul_one a := by\n    ext\n    apply mul_one\n  mul_comm a b := by\n    ext\n    apply mul_comm", "start": [403, 1], "end": [417, 19], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.commGroup", "code": "@[to_additive\n      \"If `\u03b2` is an additive commutative group, then `A \u2192*[n] \u03b2` is an additive commutative\n      group too.\"]\ninstance commGroup {\u03b2} [CommGroup \u03b2]: CommGroup (A \u2192*[n] \u03b2) :=\n  { FreimanHom.commMonoid with\n    div_eq_mul_inv := by\n      intros\n      ext\n      apply div_eq_mul_inv\n    mul_left_inv := by\n      intros\n      ext\n      apply mul_left_inv}", "start": [421, 1], "end": [434, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.freimanHomClass", "code": "@[to_additive AddMonoidHom.addFreimanHomClass\n      \" An additive monoid homomorphism is naturally an `AddFreimanHom` on its entire\n      domain.\n\n      We can't leave the domain `A : Set \u03b1` of the `AddFreimanHom` a free variable, since it\n      wouldn't be inferrable.\"]\ninstance MonoidHom.freimanHomClass : FreimanHomClass (\u03b1 \u2192* \u03b2) Set.univ \u03b2 n where\n  map_prod_eq_map_prod' f s t _ _ _ _ h := by\n    rw [\u2190 f.map_multiset_prod, h, f.map_multiset_prod]", "start": [445, 1], "end": [457, 55], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toFreimanHom", "code": "@[to_additive AddMonoidHom.toAddFreimanHom\n      \"An `AddMonoidHom` is naturally an `AddFreimanHom`\"]\ndef MonoidHom.toFreimanHom (A : Set \u03b1) (n : \u2115) (f : \u03b1 \u2192* \u03b2) : A \u2192*[n] \u03b2 where\n  toFun := f\n  map_prod_eq_map_prod' _ _ :=\n    map_prod_eq_map_prod f (fun _ _ => Set.mem_univ _) fun _ _ => Set.mem_univ _", "start": [461, 1], "end": [467, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toFreimanHom_coe", "code": "@[to_additive (attr := simp) toAddFreimanHom_coe]\ntheorem MonoidHom.toFreimanHom_coe (f : \u03b1 \u2192* \u03b2) : (f.toFreimanHom A n : \u03b1 \u2192 \u03b2) = f", "start": [471, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toFreimanHom_injective", "code": "@[to_additive AddMonoidHom.toAddFreimanHom_injective]\ntheorem MonoidHom.toFreimanHom_injective :\n    Function.Injective (MonoidHom.toFreimanHom A n : (\u03b1 \u2192* \u03b2) \u2192 A \u2192*[n] \u03b2)", "start": [477, 1], "end": [480, 84], "kind": "commanddeclaration"}, {"full_name": "map_prod_eq_map_prod_of_le", "code": "@[to_additive]\ntheorem map_prod_eq_map_prod_of_le [FreimanHomClass F A \u03b2 n] (f : F) {s t : Multiset \u03b1}\n    (hsA : \u2200 x \u2208 s, x \u2208 A) (htA : \u2200 x \u2208 t, x \u2208 A)\n    (hs : Multiset.card s = m) (ht : Multiset.card t = m)\n    (hst : s.prod = t.prod) (h : m \u2264 n) : (s.map f).prod = (t.map f).prod", "start": [490, 1], "end": [520, 33], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.toFreimanHom", "code": "@[to_additive AddFreimanHom.toAddFreimanHom\n      \"`\u03b1 \u2192+[n] \u03b2` is naturally included in `\u03b1 \u2192+[m] \u03b2`\n      for any `m \u2264 n`\"]\ndef FreimanHom.toFreimanHom (h : m \u2264 n) (f : A \u2192*[n] \u03b2) : A \u2192*[m] \u03b2 where\n  toFun := f\n  map_prod_eq_map_prod' hsA htA hs ht hst := map_prod_eq_map_prod_of_le f hsA htA hs ht hst h", "start": [524, 1], "end": [530, 94], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.FreimanHomClass_of_le", "code": "@[to_additive AddFreimanHom.addFreimanHomClass_of_le\n      \"An additive `n`-Freiman homomorphism is\n      also an additive `m`-Freiman homomorphism for any `m \u2264 n`.\"]\ntheorem FreimanHom.FreimanHomClass_of_le [FreimanHomClass F A \u03b2 n] (h : m \u2264 n) :\n    FreimanHomClass F A \u03b2 m where", "start": [534, 1], "end": [541, 53], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.toFreimanHom_coe", "code": "@[to_additive (attr := simp) AddFreimanHom.toAddFreimanHom_coe]\ntheorem FreimanHom.toFreimanHom_coe (h : m \u2264 n) (f : A \u2192*[n] \u03b2) :\n    (f.toFreimanHom h : \u03b1 \u2192 \u03b2) = f", "start": [545, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "FreimanHom.toFreimanHom_injective", "code": "@[to_additive AddFreimanHom.toAddFreimanHom_injective]\ntheorem FreimanHom.toFreimanHom_injective (h : m \u2264 n) :\n    Function.Injective (FreimanHom.toFreimanHom h : (A \u2192*[n] \u03b2) \u2192 A \u2192*[m] \u03b2)", "start": [552, 1], "end": [555, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/AlgebraCat/Monoidal.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Transport.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Basic.lean", "Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "Mathlib/RingTheory/TensorProduct.lean"], "premises": [{"full_name": "AlgebraCat.instMonoidalCategory.tensorObj", "code": "@[simps!]\nnoncomputable abbrev tensorObj (X Y : AlgebraCat.{u} R) : AlgebraCat.{u} R :=\n  of R (X \u2297[R] Y)", "start": [30, 1], "end": [34, 18], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory.tensorHom", "code": "noncomputable abbrev tensorHom {W X Y Z : AlgebraCat.{u} R} (f : W \u27f6 X) (g : Y \u27f6 Z) :\n    tensorObj W Y \u27f6 tensorObj X Z :=\n  Algebra.TensorProduct.map f g", "start": [36, 1], "end": [40, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory.tensorUnit", "code": "@[simps!]\nabbrev tensorUnit : AlgebraCat.{u} R := of R R", "start": [42, 1], "end": [45, 47], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory.associator", "code": "noncomputable abbrev associator (X Y Z : AlgebraCat.{u} R) :\n    tensorObj (tensorObj X Y) Z \u2245 tensorObj X (tensorObj Y Z) :=\n  (Algebra.TensorProduct.assoc R X Y Z).toAlgebraIso", "start": [47, 1], "end": [51, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory.forget\u2082_map_associator_hom", "code": "theorem forget\u2082_map_associator_hom (X Y Z : AlgebraCat.{u} R) :\n    (forget\u2082 (AlgebraCat R) (ModuleCat R)).map (associator X Y Z).hom =\n      (\u03b1_\n        (forget\u2082 _ (ModuleCat R) |>.obj X)\n        (forget\u2082 _ (ModuleCat R) |>.obj Y)\n        (forget\u2082 _ (ModuleCat R) |>.obj Z)).hom", "start": [55, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory.forget\u2082_map_associator_inv", "code": "theorem forget\u2082_map_associator_inv (X Y Z : AlgebraCat.{u} R) :\n    (forget\u2082 (AlgebraCat R) (ModuleCat R)).map (associator X Y Z).inv =\n      (\u03b1_\n        (forget\u2082 _ (ModuleCat R) |>.obj X)\n        (forget\u2082 _ (ModuleCat R) |>.obj Y)\n        (forget\u2082 _ (ModuleCat R) |>.obj Z)).inv", "start": [63, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.instMonoidalCategory", "code": "noncomputable instance instMonoidalCategory : MonoidalCategory (AlgebraCat.{u} R) :=\n  Monoidal.induced\n    (forget\u2082 (AlgebraCat R) (ModuleCat R))\n    { tensorObj := instMonoidalCategory.tensorObj\n      \u03bcIsoSymm := fun X Y => Iso.refl _\n      whiskerLeft := fun X _ _ f => tensorHom (\ud835\udfd9 _) f\n      whiskerRight := @fun X\u2081 X\u2082 (f : X\u2081 \u27f6 X\u2082) Y => tensorHom f (\ud835\udfd9 _)\n      tensorHom := tensorHom\n      tensorUnit' := tensorUnit\n      \u03b5IsoSymm := Iso.refl _\n      associator := associator\n      associator_eq := fun X Y Z => by\n        dsimp only [forget\u2082_module_obj, forget\u2082_map_associator_hom]\n        simp only [eqToIso_refl, Iso.refl_trans, Iso.refl_symm, Iso.trans_hom, tensorIso_hom,\n          Iso.refl_hom, MonoidalCategory.tensor_id]\n        erw [Category.id_comp, Category.comp_id, MonoidalCategory.tensor_id, Category.comp_id]\n      leftUnitor := fun X => (Algebra.TensorProduct.lid R X).toAlgebraIso\n      rightUnitor := fun X => (Algebra.TensorProduct.rid R R X).toAlgebraIso\n      rightUnitor_eq := fun X => by\n        dsimp\n        erw [Category.id_comp, MonoidalCategory.tensor_id, Category.id_comp]\n        exact congr_arg LinearEquiv.toLinearMap <|\n          TensorProduct.AlgebraTensorModule.rid_eq_rid R X }", "start": [76, 1], "end": [98, 61], "kind": "commanddeclaration"}, {"full_name": "AlgebraCat.toModuleCatMonoidalFunctor", "code": "def toModuleCatMonoidalFunctor : MonoidalFunctor (AlgebraCat.{u} R) (ModuleCat.{u} R) :=\n  Monoidal.fromInduced (forget\u2082 (AlgebraCat R) (ModuleCat R)) _", "start": [101, 1], "end": [103, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Zsqrtd/QuadraticReciprocity.lean", "imports": ["Mathlib/NumberTheory/Zsqrtd/GaussianInt.lean", "Mathlib/NumberTheory/LegendreSymbol/QuadraticReciprocity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GaussianInt.mod_four_eq_three_of_nat_prime_of_prime", "code": "theorem mod_four_eq_three_of_nat_prime_of_prime (p : \u2115) [hp : Fact p.Prime]\n    (hpi : Prime (p : \u2124[i])) : p % 4 = 3", "start": [34, 1], "end": [84, 12], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.prime_of_nat_prime_of_mod_four_eq_three", "code": "theorem prime_of_nat_prime_of_mod_four_eq_three (p : \u2115) [hp : Fact p.Prime] (hp3 : p % 4 = 3) :\n    Prime (p : \u2124[i])", "start": [87, 1], "end": [94, 31], "kind": "commanddeclaration"}, {"full_name": "GaussianInt.prime_iff_mod_four_eq_three_of_nat_prime", "code": "theorem prime_iff_mod_four_eq_three_of_nat_prime (p : \u2115) [Fact p.Prime] :\n    Prime (p : \u2124[i]) \u2194 p % 4 = 3", "start": [97, 1], "end": [100, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/Coequalizer.lean", "imports": ["Mathlib/CategoryTheory/Monad/Algebra.lean", "Mathlib/CategoryTheory/Limits/Shapes/Reflexive.lean", "Mathlib/CategoryTheory/Limits/Shapes/SplitCoequalizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monad.FreeCoequalizer.topMap", "code": "@[simps!]\ndef FreeCoequalizer.topMap : (Monad.free T).obj (T.obj X.A) \u27f6 (Monad.free T).obj X.A :=\n  (Monad.free T).map X.a", "start": [43, 1], "end": [46, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.FreeCoequalizer.bottomMap", "code": "@[simps]\ndef FreeCoequalizer.bottomMap : (Monad.free T).obj (T.obj X.A) \u27f6 (Monad.free T).obj X.A where\n  f := T.\u03bc.app X.A\n  h := T.assoc X.A", "start": [49, 1], "end": [53, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.FreeCoequalizer.\u03c0", "code": "@[simps]\ndef FreeCoequalizer.\u03c0 : (Monad.free T).obj X.A \u27f6 X where\n  f := X.a\n  h := X.assoc.symm", "start": [56, 1], "end": [60, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.FreeCoequalizer.condition", "code": "theorem FreeCoequalizer.condition :\n    FreeCoequalizer.topMap X \u226b FreeCoequalizer.\u03c0 X =\n      FreeCoequalizer.bottomMap X \u226b FreeCoequalizer.\u03c0 X", "start": [63, 1], "end": [66, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckAlgebraCofork", "code": "@[simps!]\ndef beckAlgebraCofork : Cofork (FreeCoequalizer.topMap X) (FreeCoequalizer.bottomMap X) :=\n  Cofork.of\u03c0 _ (FreeCoequalizer.condition X)", "start": [78, 1], "end": [83, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckAlgebraCoequalizer", "code": "def beckAlgebraCoequalizer : IsColimit (beckAlgebraCofork X) :=\n  Cofork.IsColimit.mk' _ fun s => by\n    have h\u2081 : (T : C \u2964 C).map X.a \u226b s.\u03c0.f = T.\u03bc.app X.A \u226b s.\u03c0.f :=\n      congr_arg Monad.Algebra.Hom.f s.condition\n    have h\u2082 : (T : C \u2964 C).map s.\u03c0.f \u226b s.pt.a = T.\u03bc.app X.A \u226b s.\u03c0.f := s.\u03c0.h\n    refine' \u27e8\u27e8T.\u03b7.app _ \u226b s.\u03c0.f, _\u27e9, _, _\u27e9\n    \u00b7 dsimp\n      rw [Functor.map_comp, Category.assoc, h\u2082, Monad.right_unit_assoc,\n        show X.a \u226b _ \u226b _ = _ from T.\u03b7.naturality_assoc _ _, h\u2081, Monad.left_unit_assoc]\n    \u00b7 ext\n      simpa [\u2190 T.\u03b7.naturality_assoc, T.left_unit_assoc] using T.\u03b7.app ((T : C \u2964 C).obj X.A) \u226b= h\u2081\n    \u00b7 intro m hm\n      ext\n      dsimp only\n      rw [\u2190 hm]\n      apply (X.unit_assoc _).symm", "start": [86, 1], "end": [104, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckSplitCoequalizer", "code": "def beckSplitCoequalizer : IsSplitCoequalizer (T.map X.a) (T.\u03bc.app _) X.a :=\n  \u27e8T.\u03b7.app _, T.\u03b7.app _, X.assoc.symm, X.unit, T.left_unit _, (T.\u03b7.naturality _).symm\u27e9", "start": [107, 1], "end": [109, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckCofork", "code": "@[simps! pt]\ndef beckCofork : Cofork (T.map X.a) (T.\u03bc.app _) :=\n  (beckSplitCoequalizer X).asCofork", "start": [112, 1], "end": [115, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckCofork_\u03c0", "code": "@[simp]\ntheorem beckCofork_\u03c0 : (beckCofork X).\u03c0 = X.a", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckCoequalizer", "code": "def beckCoequalizer : IsColimit (beckCofork X) :=\n  (beckSplitCoequalizer X).isCoequalizer", "start": [123, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monad.beckCoequalizer_desc", "code": "@[simp]\ntheorem beckCoequalizer_desc (s : Cofork (T.toFunctor.map X.a) (T.\u03bc.app X.A)) :\n    (beckCoequalizer X).desc s = T.\u03b7.app _ \u226b s.\u03c0", "start": [128, 1], "end": [131, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/ArctanDeriv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.sin_lt", "code": "theorem sin_lt {x : \u211d} (h : 0 < x) : sin x < x", "start": [44, 1], "end": [55, 11], "kind": "commanddeclaration"}, {"full_name": "Real.sin_gt_sub_cube", "code": "theorem sin_gt_sub_cube {x : \u211d} (h : 0 < x) (h' : x \u2264 1) : x - x ^ 3 / 4 < sin x", "start": [58, 1], "end": [72, 11], "kind": "commanddeclaration"}, {"full_name": "Real.deriv_tan_sub_id", "code": "theorem deriv_tan_sub_id (x : \u211d) (h : cos x \u2260 0) :\n    deriv (fun y : \u211d => tan y - y) x = 1 / cos x ^ 2 - 1", "start": [75, 1], "end": [78, 82], "kind": "commanddeclaration"}, {"full_name": "Real.lt_tan", "code": "theorem lt_tan {x : \u211d} (h1 : 0 < x) (h2 : x < \u03c0 / 2) : x < tan x", "start": [81, 1], "end": [117, 74], "kind": "commanddeclaration"}, {"full_name": "Real.le_tan", "code": "theorem le_tan {x : \u211d} (h1 : 0 \u2264 x) (h2 : x < \u03c0 / 2) : x \u2264 tan x", "start": [120, 1], "end": [123, 35], "kind": "commanddeclaration"}, {"full_name": "Real.cos_lt_one_div_sqrt_sq_add_one", "code": "theorem cos_lt_one_div_sqrt_sq_add_one {x : \u211d} (hx1 : -(3 * \u03c0 / 2) \u2264 x) (hx2 : x \u2264 3 * \u03c0 / 2)\n    (hx3 : x \u2260 0) : cos x < \u21911 / sqrt (x ^ 2 + 1)", "start": [126, 1], "end": [147, 72], "kind": "commanddeclaration"}, {"full_name": "Real.cos_le_one_div_sqrt_sq_add_one", "code": "theorem cos_le_one_div_sqrt_sq_add_one {x : \u211d} (hx1 : -(3 * \u03c0 / 2) \u2264 x) (hx2 : x \u2264 3 * \u03c0 / 2) :\n    cos x \u2264 \u21911 / sqrt (x ^ 2 + 1)", "start": [150, 1], "end": [154, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Subobject.lean", "imports": ["Mathlib/Algebra/Category/ModuleCat/EpiMono.lean", "Mathlib/Algebra/Category/ModuleCat/Kernels.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Subobject/Limits.lean", "Mathlib/CategoryTheory/Subobject/WellPowered.lean"], "premises": [{"full_name": "ModuleCat.subobjectModule", "code": "noncomputable def subobjectModule : Subobject M \u2243o Submodule R M :=\n  OrderIso.symm\n    { invFun := fun S => LinearMap.range S.arrow\n      toFun := fun N => Subobject.mk (\u21beN.subtype)\n      right_inv := fun S => Eq.symm (by\n        fapply eq_mk_of_comm\n        \u00b7 apply LinearEquiv.toModuleIso'Left\n          apply LinearEquiv.ofBijective (LinearMap.codRestrict (LinearMap.range S.arrow) S.arrow _)\n          constructor\n          \u00b7 simp [\u2190 LinearMap.ker_eq_bot, LinearMap.ker_codRestrict]\n            rw [ker_eq_bot_of_mono]\n          \u00b7 rw [\u2190 LinearMap.range_eq_top, LinearMap.range_codRestrict, Submodule.comap_subtype_self]\n            exact LinearMap.mem_range_self _\n        \u00b7 apply LinearMap.ext\n          intro x\n          rfl)\n      left_inv := fun N => by\n        convert congr_arg LinearMap.range\n            (underlyingIso_arrow (\u21beN.subtype : of R { x // x \u2208 N } \u27f6 M)) using 1\n        \u00b7 have :\n            (underlyingIso (\u21beN.subtype : of R _ \u27f6 M)).inv =\n              (underlyingIso (\u21beN.subtype : of R _ \u27f6 M)).symm.toLinearEquiv.toLinearMap := by\n              apply LinearMap.ext\n              intro x\n              rfl\n          rw [this, comp_def, LinearEquiv.range_comp]\n        \u00b7 exact (Submodule.range_subtype _).symm\n      map_rel_iff' := fun {S T} => by\n        refine' \u27e8fun h => _, fun h => mk_le_mk_of_comm (\u219f(Submodule.ofLe h)) rfl\u27e9\n        convert LinearMap.range_comp_le_range (ofMkLEMk _ _ h) (\u21beT.subtype)\n        \u00b7 simpa only [\u2190 comp_def, ofMkLEMk_comp] using (Submodule.range_subtype _).symm\n        \u00b7 exact (Submodule.range_subtype _).symm }", "start": [37, 1], "end": [73, 51], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.wellPowered_moduleCat", "code": "instance wellPowered_moduleCat : WellPowered (ModuleCat.{v} R) :=\n  \u27e8fun M => \u27e8\u27e8_, \u27e8(subobjectModule M).toEquiv\u27e9\u27e9\u27e9\u27e9", "start": [76, 1], "end": [77, 50], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.toKernelSubobject", "code": "noncomputable def toKernelSubobject {M N : ModuleCat.{v} R} {f : M \u27f6 N} :\n    LinearMap.ker f \u2192\u2097[R] kernelSubobject f :=\n  (kernelSubobjectIso f \u226a\u226b ModuleCat.kernelIsoKer f).inv", "start": [82, 1], "end": [85, 57], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.toKernelSubobject_arrow", "code": "@[simp]\ntheorem toKernelSubobject_arrow {M N : ModuleCat R} {f : M \u27f6 N} (x : LinearMap.ker f) :\n    (kernelSubobject f).arrow (toKernelSubobject x) = x.1", "start": [88, 1], "end": [96, 12], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.cokernel_\u03c0_imageSubobject_ext", "code": "theorem cokernel_\u03c0_imageSubobject_ext {L M N : ModuleCat.{v} R} (f : L \u27f6 M) [HasImage f]\n    (g : (imageSubobject f : ModuleCat.{v} R) \u27f6 N) [HasCokernel g] {x y : N} (l : L)\n    (w : x = y + g (factorThruImageSubobject f l)) : cokernel.\u03c0 g x = cokernel.\u03c0 g y", "start": [99, 1], "end": [119, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/InvariantBasisNumber.lean", "imports": ["Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.square_of_invertible", "code": "theorem Matrix.square_of_invertible (M : Matrix n m R) (N : Matrix m n R) (h : M * N = 1)\n    (h' : N * M = 1) : Fintype.card n = Fintype.card m", "start": [22, 1], "end": [24, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Ergodic/AddCircle.lean", "imports": ["Mathlib/Data/Set/Pointwise/Iterate.lean", "Mathlib/Dynamics/Ergodic/Ergodic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/MeasureTheory/Group/AddCircle.lean", "Mathlib/MeasureTheory/Covering/DensityTheorem.lean"], "premises": [{"full_name": "AddCircle.ae_empty_or_univ_of_forall_vadd_ae_eq_self", "code": "theorem ae_empty_or_univ_of_forall_vadd_ae_eq_self {s : Set <| AddCircle T}\n    (hs : NullMeasurableSet s volume) {\u03b9 : Type*} {l : Filter \u03b9} [l.NeBot] {u : \u03b9 \u2192 AddCircle T}\n    (hu\u2081 : \u2200 i, (u i +\u1d65 s : Set _) =\u1d50[volume] s) (hu\u2082 : Tendsto (addOrderOf \u2218 u) l atTop) :\n    s =\u1d50[volume] (\u2205 : Set <| AddCircle T) \u2228 s =\u1d50[volume] univ", "start": [40, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "AddCircle.ergodic_zsmul", "code": "theorem ergodic_zsmul {n : \u2124} (hn : 1 < |n|) : Ergodic fun y : AddCircle T => n \u2022 y", "start": [102, 1], "end": [118, 86], "kind": "commanddeclaration"}, {"full_name": "AddCircle.ergodic_nsmul", "code": "theorem ergodic_nsmul {n : \u2115} (hn : 1 < n) : Ergodic fun y : AddCircle T => n \u2022 y", "start": [121, 1], "end": [122, 47], "kind": "commanddeclaration"}, {"full_name": "AddCircle.ergodic_zsmul_add", "code": "theorem ergodic_zsmul_add (x : AddCircle T) {n : \u2124} (h : 1 < |n|) : Ergodic fun y => n \u2022 y + x", "start": [125, 1], "end": [140, 7], "kind": "commanddeclaration"}, {"full_name": "AddCircle.ergodic_nsmul_add", "code": "theorem ergodic_nsmul_add (x : AddCircle T) {n : \u2115} (h : 1 < n) : Ergodic fun y => n \u2022 y + x", "start": [143, 1], "end": [144, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Covering/LiminfLimsup.lean", "imports": ["Mathlib/MeasureTheory/Covering/DensityTheorem.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "blimsup_cthickening_ae_le_of_eventually_mul_le_aux", "code": "theorem blimsup_cthickening_ae_le_of_eventually_mul_le_aux (p : \u2115 \u2192 Prop) {s : \u2115 \u2192 Set \u03b1}\n    (hs : \u2200 i, IsClosed (s i)) {r\u2081 r\u2082 : \u2115 \u2192 \u211d} (hr : Tendsto r\u2081 atTop (\ud835\udcdd[>] 0)) (hrp : 0 \u2264 r\u2081)\n    {M : \u211d} (hM : 0 < M) (hM' : M < 1) (hMr : \u2200\u1da0 i in atTop, M * r\u2081 i \u2264 r\u2082 i) :\n    (blimsup (fun i => cthickening (r\u2081 i) (s i)) atTop p : Set \u03b1) \u2264\u1d50[\u03bc]\n      (blimsup (fun i => cthickening (r\u2082 i) (s i)) atTop p : Set \u03b1)", "start": [37, 1], "end": [151, 46], "kind": "commanddeclaration"}, {"full_name": "blimsup_cthickening_ae_le_of_eventually_mul_le", "code": "theorem blimsup_cthickening_ae_le_of_eventually_mul_le (p : \u2115 \u2192 Prop) {s : \u2115 \u2192 Set \u03b1} {M : \u211d}\n    (hM : 0 < M) {r\u2081 r\u2082 : \u2115 \u2192 \u211d} (hr : Tendsto r\u2081 atTop (\ud835\udcdd[>] 0))\n    (hMr : \u2200\u1da0 i in atTop, M * r\u2081 i \u2264 r\u2082 i) :\n    (blimsup (fun i => cthickening (r\u2081 i) (s i)) atTop p : Set \u03b1) \u2264\u1d50[\u03bc]\n      (blimsup (fun i => cthickening (r\u2082 i) (s i)) atTop p : Set \u03b1)", "start": [154, 1], "end": [179, 49], "kind": "commanddeclaration"}, {"full_name": "blimsup_cthickening_mul_ae_eq", "code": "theorem blimsup_cthickening_mul_ae_eq (p : \u2115 \u2192 Prop) (s : \u2115 \u2192 Set \u03b1) {M : \u211d} (hM : 0 < M)\n    (r : \u2115 \u2192 \u211d) (hr : Tendsto r atTop (\ud835\udcdd 0)) :\n    (blimsup (fun i => cthickening (M * r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n      (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set \u03b1)", "start": [182, 1], "end": [230, 75], "kind": "commanddeclaration"}, {"full_name": "blimsup_cthickening_ae_eq_blimsup_thickening", "code": "theorem blimsup_cthickening_ae_eq_blimsup_thickening {p : \u2115 \u2192 Prop} {s : \u2115 \u2192 Set \u03b1} {r : \u2115 \u2192 \u211d}\n    (hr : Tendsto r atTop (\ud835\udcdd 0)) (hr' : \u2200\u1da0 i in atTop, p i \u2192 0 < r i) :\n    (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set \u03b1)", "start": [233, 1], "end": [244, 68], "kind": "commanddeclaration"}, {"full_name": "blimsup_thickening_mul_ae_eq_aux", "code": "theorem blimsup_thickening_mul_ae_eq_aux (p : \u2115 \u2192 Prop) (s : \u2115 \u2192 Set \u03b1) {M : \u211d} (hM : 0 < M)\n    (r : \u2115 \u2192 \u211d) (hr : Tendsto r atTop (\ud835\udcdd 0)) (hr' : \u2200\u1da0 i in atTop, p i \u2192 0 < r i) :\n    (blimsup (fun i => thickening (M * r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set \u03b1)", "start": [247, 1], "end": [257, 36], "kind": "commanddeclaration"}, {"full_name": "blimsup_thickening_mul_ae_eq", "code": "theorem blimsup_thickening_mul_ae_eq (p : \u2115 \u2192 Prop) (s : \u2115 \u2192 Set \u03b1) {M : \u211d} (hM : 0 < M) (r : \u2115 \u2192 \u211d)\n    (hr : Tendsto r atTop (\ud835\udcdd 0)) :\n    (blimsup (fun i => thickening (M * r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set \u03b1)", "start": [260, 1], "end": [288, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Specialization.lean", "imports": ["Mathlib/Order/Category/Preord.lean", "Mathlib/Topology/Separation.lean", "Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Category/TopCat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Order/UpperLowerSetTopology.lean"], "premises": [{"full_name": "Specialization", "code": "def Specialization (\u03b1 : Type*) := \u03b1", "start": [20, 1], "end": [21, 36], "kind": "commanddeclaration"}, {"full_name": "Specialization.toEquiv", "code": "@[match_pattern] def toEquiv : \u03b1 \u2243 Specialization \u03b1 := Equiv.refl _", "start": [26, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "Specialization.ofEquiv", "code": "@[match_pattern] def ofEquiv : Specialization \u03b1 \u2243 \u03b1 := Equiv.refl _", "start": [29, 1], "end": [30, 68], "kind": "commanddeclaration"}, {"full_name": "Specialization.toEquiv_symm", "code": "@[simp] lemma toEquiv_symm : (@toEquiv \u03b1).symm = ofEquiv := rfl", "start": [32, 1], "end": [32, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.ofEquiv_symm", "code": "@[simp] lemma ofEquiv_symm : (@ofEquiv \u03b1).symm = toEquiv := rfl", "start": [33, 1], "end": [33, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.toEquiv_ofEquiv", "code": "@[simp] lemma toEquiv_ofEquiv (a : Specialization \u03b1) : toEquiv (ofEquiv a) = a := rfl", "start": [34, 1], "end": [34, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.ofEquiv_toEquiv", "code": "@[simp] lemma ofEquiv_toEquiv (a : \u03b1) : ofEquiv (toEquiv a) = a := rfl", "start": [35, 1], "end": [35, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.toEquiv_inj", "code": "@[simp, nolint simpNF] lemma toEquiv_inj {a b : \u03b1} : toEquiv a = toEquiv b \u2194 a = b := Iff.rfl", "start": [37, 1], "end": [37, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.ofEquiv_inj", "code": "@[simp, nolint simpNF] lemma ofEquiv_inj {a b : Specialization \u03b1} : ofEquiv a = ofEquiv b \u2194 a = b :=\nIff.rfl", "start": [38, 1], "end": [39, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.rec", "code": "protected def rec {\u03b2 : Specialization \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toEquiv a)) (a : \u03b1) : \u03b2 a :=\nh (ofEquiv a)", "start": [41, 1], "end": [43, 14], "kind": "commanddeclaration"}, {"full_name": "Specialization.instPreorder", "code": "instance instPreorder : Preorder (Specialization \u03b1) := specializationPreorder \u03b1", "start": [47, 1], "end": [47, 80], "kind": "commanddeclaration"}, {"full_name": "Specialization.instPartialOrder", "code": "instance instPartialOrder [T0Space \u03b1] : PartialOrder (Specialization \u03b1) := specializationOrder \u03b1", "start": [48, 1], "end": [48, 97], "kind": "commanddeclaration"}, {"full_name": "Specialization.toEquiv_le_toEquiv", "code": "@[simp] lemma toEquiv_le_toEquiv {a b : \u03b1} : toEquiv a \u2264 toEquiv b \u2194 b \u2933 a := Iff.rfl", "start": [50, 1], "end": [50, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.ofEquiv_specializes_ofEquiv", "code": "@[simp] lemma ofEquiv_specializes_ofEquiv {a b : Specialization \u03b1} :\n  ofEquiv a \u2933 ofEquiv b \u2194 b \u2264 a := Iff.rfl", "start": [51, 1], "end": [52, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.isOpen_toEquiv_preimage", "code": "@[simp] lemma isOpen_toEquiv_preimage [AlexandrovDiscrete \u03b1] {s : Set (Specialization \u03b1)} :\n  IsOpen (toEquiv \u207b\u00b9' s) \u2194 IsUpperSet s := isOpen_iff_forall_specializes.trans forall_swap", "start": [54, 1], "end": [55, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.isUpperSet_ofEquiv_preimage", "code": "@[simp] lemma isUpperSet_ofEquiv_preimage [AlexandrovDiscrete \u03b1] {s : Set \u03b1} :\n  IsUpperSet (ofEquiv \u207b\u00b9' s) \u2194 IsOpen s := isOpen_toEquiv_preimage.symm", "start": [57, 1], "end": [58, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.map", "code": "def map (f : C(\u03b1, \u03b2)) : Specialization \u03b1 \u2192o Specialization \u03b2 where\n  toFun := toEquiv \u2218 f \u2218 ofEquiv\n  monotone' := f.continuous.specialization_monotone", "start": [60, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "Specialization.map_id", "code": "@[simp] lemma map_id : map (ContinuousMap.id \u03b1) = OrderHom.id := rfl", "start": [66, 1], "end": [66, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Specialization.map_comp", "code": "@[simp] lemma map_comp (g : C(\u03b2, \u03b3)) (f : C(\u03b1, \u03b2)) : map (g.comp f) = (map g).comp (map f) := rfl", "start": [67, 1], "end": [67, 98], "kind": "mathlibtacticlemma"}, {"full_name": "orderIsoSpecializationWithUpperSetTopology", "code": "def orderIsoSpecializationWithUpperSetTopology (\u03b1 : Type*) [Preorder \u03b1] :\n    \u03b1 \u2243o Specialization (WithUpperSet \u03b1) where\n  toEquiv := toUpperSet.trans toEquiv\n  map_rel_iff' := by simp", "start": [73, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "homeoWithUpperSetTopologyorderIso", "code": "def homeoWithUpperSetTopologyorderIso (\u03b1 : Type*) [TopologicalSpace \u03b1] [AlexandrovDiscrete \u03b1] :\n    \u03b1 \u2243\u209c WithUpperSet (Specialization \u03b1) :=\n(toEquiv.trans toUpperSet).toHomeomorph \u03bb s \u21a6 by simp [Set.preimage_comp]", "start": [79, 1], "end": [83, 74], "kind": "commanddeclaration"}, {"full_name": "topToPreord", "code": "@[simps]\ndef topToPreord : TopCat \u2964 Preord where\n  obj X := Preord.of $ Specialization X\n  map := Specialization.map", "start": [85, 1], "end": [89, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Game/Impartial.lean", "imports": ["Mathlib/Tactic/NthRewrite.lean", "Mathlib/SetTheory/Game/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.ImpartialAux", "code": "def ImpartialAux : PGame \u2192 Prop\n  | G => (G \u2248 -G) \u2227 (\u2200 i, ImpartialAux (G.moveLeft i)) \u2227 \u2200 j, ImpartialAux (G.moveRight j)\ntermination_by _ G => G decreasing_by pgame_wf_tac", "start": [29, 1], "end": [33, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.impartialAux_def", "code": "theorem impartialAux_def {G : PGame} :\n    G.ImpartialAux \u2194\n      (G \u2248 -G) \u2227 (\u2200 i, ImpartialAux (G.moveLeft i)) \u2227 \u2200 j, ImpartialAux (G.moveRight j)", "start": [36, 1], "end": [39, 20], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial", "code": "class Impartial (G : PGame) : Prop where\n  out : ImpartialAux G", "start": [42, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.impartial_iff_aux", "code": "theorem impartial_iff_aux {G : PGame} : G.Impartial \u2194 G.ImpartialAux", "start": [47, 1], "end": [48, 31], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.impartial_def", "code": "theorem impartial_def {G : PGame} :\n    G.Impartial \u2194 (G \u2248 -G) \u2227 (\u2200 i, Impartial (G.moveLeft i)) \u2227 \u2200 j, Impartial (G.moveRight j)", "start": [51, 1], "end": [53, 56], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.impartial_zero", "code": "instance impartial_zero : Impartial 0 := by rw [impartial_def]; dsimp; simp", "start": [58, 1], "end": [58, 76], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.impartial_star", "code": "instance impartial_star : Impartial star := by\n  rw [impartial_def]; simpa using Impartial.impartial_zero", "start": [61, 1], "end": [62, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.neg_equiv_self", "code": "theorem neg_equiv_self (G : PGame) [h : G.Impartial] : G \u2248 -G", "start": [65, 1], "end": [66, 24], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.mk'_neg_equiv_self", "code": "@[simp]\ntheorem mk'_neg_equiv_self (G : PGame) [G.Impartial] : -(\u27e6G\u27e7 : Quotient setoid) = \u27e6G\u27e7", "start": [70, 1], "end": [72, 45], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.moveLeft_impartial", "code": "instance moveLeft_impartial {G : PGame} [h : G.Impartial] (i : G.LeftMoves) :\n    (G.moveLeft i).Impartial :=\n  (impartial_def.1 h).2.1 i", "start": [75, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.moveRight_impartial", "code": "instance moveRight_impartial {G : PGame} [h : G.Impartial] (j : G.RightMoves) :\n    (G.moveRight j).Impartial :=\n  (impartial_def.1 h).2.2 j", "start": [80, 1], "end": [82, 28], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.impartial_congr", "code": "theorem impartial_congr : \u2200 {G H : PGame} (_ : G \u2261r H) [G.Impartial], H.Impartial", "start": [85, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.impartial_add", "code": "instance impartial_add : \u2200 (G H : PGame) [G.Impartial] [H.Impartial], (G + H).Impartial\n  | G, H, _, _ => by\n    rw [impartial_def]\n    refine' \u27e8Equiv.trans (add_congr (neg_equiv_self G) (neg_equiv_self _))\n        (Equiv.symm (negAddRelabelling _ _).equiv), fun k => _, fun k => _\u27e9\n    \u00b7 apply leftMoves_add_cases k\n      all_goals\n        intro i; simp only [add_moveLeft_inl, add_moveLeft_inr]\n        apply impartial_add\n    \u00b7 apply rightMoves_add_cases k\n      all_goals\n        intro i; simp only [add_moveRight_inl, add_moveRight_inr]\n        apply impartial_add\ntermination_by _ G H _ _ => (G, H)\ndecreasing_by pgame_wf_tac", "start": [95, 1], "end": [109, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.impartial_neg", "code": "instance impartial_neg : \u2200 (G : PGame) [G.Impartial], (-G).Impartial\n  | G, _ => by\n    rw [impartial_def]\n    refine' \u27e8_, fun i => _, fun i => _\u27e9\n    \u00b7 rw [neg_neg]\n      exact Equiv.symm (neg_equiv_self G)\n    \u00b7 rw [moveLeft_neg']\n      apply impartial_neg\n    \u00b7 rw [moveRight_neg']\n      apply impartial_neg\ntermination_by _ G _ => G\ndecreasing_by pgame_wf_tac", "start": [112, 1], "end": [123, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.nonpos", "code": "theorem nonpos : \u00ac0 < G", "start": [128, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.nonneg", "code": "theorem nonneg : \u00acG < 0", "start": [134, 1], "end": [137, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.equiv_or_fuzzy_zero", "code": "theorem equiv_or_fuzzy_zero : (G \u2248 0) \u2228 G \u2016 0", "start": [140, 1], "end": [146, 19], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.not_equiv_zero_iff", "code": "@[simp]\ntheorem not_equiv_zero_iff : \u00ac(G \u2248 0) \u2194 G \u2016 0", "start": [149, 1], "end": [151, 58], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.not_fuzzy_zero_iff", "code": "@[simp]\ntheorem not_fuzzy_zero_iff : \u00acG \u2016 0 \u2194 (G \u2248 0)", "start": [154, 1], "end": [156, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.add_self", "code": "theorem add_self : G + G \u2248 0", "start": [159, 1], "end": [160, 73], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.mk'_add_self", "code": "@[simp]\ntheorem mk'_add_self : (\u27e6G\u27e7 : Quotient setoid) + \u27e6G\u27e7 = 0", "start": [164, 1], "end": [166, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.equiv_iff_add_equiv_zero", "code": "theorem equiv_iff_add_equiv_zero (H : PGame) : (H \u2248 G) \u2194 (H + G \u2248 0)", "start": [169, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.equiv_iff_add_equiv_zero'", "code": "theorem equiv_iff_add_equiv_zero' (H : PGame) : (G \u2248 H) \u2194 (G + H \u2248 0)", "start": [176, 1], "end": [180, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.le_zero_iff", "code": "theorem le_zero_iff {G : PGame} [G.Impartial] : G \u2264 0 \u2194 0 \u2264 G", "start": [183, 1], "end": [184, 60], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.lf_zero_iff", "code": "theorem lf_zero_iff {G : PGame} [G.Impartial] : G \u29cf 0 \u2194 0 \u29cf G", "start": [187, 1], "end": [188, 60], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.equiv_zero_iff_le", "code": "theorem equiv_zero_iff_le : (G \u2248 0) \u2194 G \u2264 0", "start": [191, 1], "end": [192, 44], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.fuzzy_zero_iff_lf", "code": "theorem fuzzy_zero_iff_lf : G \u2016 0 \u2194 G \u29cf 0", "start": [195, 1], "end": [196, 44], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.equiv_zero_iff_ge", "code": "theorem equiv_zero_iff_ge : (G \u2248 0) \u2194 0 \u2264 G", "start": [199, 1], "end": [200, 45], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.fuzzy_zero_iff_gf", "code": "theorem fuzzy_zero_iff_gf : G \u2016 0 \u2194 0 \u29cf G", "start": [203, 1], "end": [204, 45], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.forall_leftMoves_fuzzy_iff_equiv_zero", "code": "theorem forall_leftMoves_fuzzy_iff_equiv_zero : (\u2200 i, G.moveLeft i \u2016 0) \u2194 (G \u2248 0)", "start": [207, 1], "end": [212, 29], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.forall_rightMoves_fuzzy_iff_equiv_zero", "code": "theorem forall_rightMoves_fuzzy_iff_equiv_zero : (\u2200 j, G.moveRight j \u2016 0) \u2194 (G \u2248 0)", "start": [215, 1], "end": [220, 30], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.exists_left_move_equiv_iff_fuzzy_zero", "code": "theorem exists_left_move_equiv_iff_fuzzy_zero : (\u2203 i, G.moveLeft i \u2248 0) \u2194 G \u2016 0", "start": [223, 1], "end": [227, 40], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Impartial.exists_right_move_equiv_iff_fuzzy_zero", "code": "theorem exists_right_move_equiv_iff_fuzzy_zero : (\u2203 j, G.moveRight j \u2248 0) \u2194 G \u2016 0", "start": [230, 1], "end": [234, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Contracting.lean", "imports": ["Mathlib/Data/Setoid/Basic.lean", "Mathlib/Dynamics/FixedPoints/Topology.lean", "Mathlib/Analysis/SpecificLimits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContractingWith", "code": "def ContractingWith [EMetricSpace \u03b1] (K : \u211d\u22650) (f : \u03b1 \u2192 \u03b1) :=\n  K < 1 \u2227 LipschitzWith K f", "start": [37, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.toLipschitzWith", "code": "theorem toLipschitzWith (hf : ContractingWith K f) : LipschitzWith K f", "start": [48, 1], "end": [48, 79], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.one_sub_K_pos'", "code": "theorem one_sub_K_pos' (hf : ContractingWith K f) : (0 : \u211d\u22650\u221e) < 1 - K", "start": [51, 1], "end": [51, 89], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.one_sub_K_ne_zero", "code": "theorem one_sub_K_ne_zero (hf : ContractingWith K f) : (1 : \u211d\u22650\u221e) - K \u2260 0", "start": [55, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.one_sub_K_ne_top", "code": "theorem one_sub_K_ne_top : (1 : \u211d\u22650\u221e) - K \u2260 \u221e", "start": [60, 1], "end": [62, 27], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_inequality", "code": "theorem edist_inequality (hf : ContractingWith K f) {x y} (h : edist x y \u2260 \u221e) :\n    edist x y \u2264 (edist x (f x) + edist y (f y)) / (1 - K)", "start": [66, 1], "end": [74, 86], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_le_of_fixedPoint", "code": "theorem edist_le_of_fixedPoint (hf : ContractingWith K f) {x y} (h : edist x y \u2260 \u221e)\n    (hy : IsFixedPt f y) : edist x y \u2264 edist x (f x) / (1 - K)", "start": [77, 1], "end": [79, 71], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.eq_or_edist_eq_top_of_fixedPoints", "code": "theorem eq_or_edist_eq_top_of_fixedPoints (hf : ContractingWith K f) {x y} (hx : IsFixedPt f x)\n    (hy : IsFixedPt f y) : x = y \u2228 edist x y = \u221e", "start": [82, 1], "end": [85, 98], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.restrict", "code": "theorem restrict (hf : ContractingWith K f) {s : Set \u03b1} (hs : MapsTo f s s) :\n    ContractingWith K (hs.restrict f s s)", "start": [88, 1], "end": [92, 29], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.exists_fixedPoint", "code": "theorem exists_fixedPoint (hf : ContractingWith K f) (x : \u03b1) (hx : edist x (f x) \u2260 \u221e) :\n    \u2203 y, IsFixedPt f y \u2227 Tendsto (fun n \u21a6 f^[n] x) atTop (\ud835\udcdd y) \u2227\n      \u2200 n : \u2115, edist (f^[n] x) y \u2264 edist x (f x) * (K : \u211d\u22650\u221e) ^ n / (1 - K)", "start": [95, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint", "code": "noncomputable def efixedPoint (hf : ContractingWith K f) (x : \u03b1) (hx : edist x (f x) \u2260 \u221e) : \u03b1 :=\n  Classical.choose <| hf.exists_fixedPoint x hx", "start": [116, 1], "end": [120, 48], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint_isFixedPt", "code": "theorem efixedPoint_isFixedPt (hf : ContractingWith K f) {x : \u03b1} (hx : edist x (f x) \u2260 \u221e) :\n    IsFixedPt f (efixedPoint f hf x hx)", "start": [125, 1], "end": [127, 57], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.tendsto_iterate_efixedPoint", "code": "theorem tendsto_iterate_efixedPoint (hf : ContractingWith K f) {x : \u03b1} (hx : edist x (f x) \u2260 \u221e) :\n    Tendsto (fun n \u21a6 f^[n] x) atTop (\ud835\udcdd <| efixedPoint f hf x hx)", "start": [130, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.apriori_edist_iterate_efixedPoint_le", "code": "theorem apriori_edist_iterate_efixedPoint_le (hf : ContractingWith K f) {x : \u03b1}\n    (hx : edist x (f x) \u2260 \u221e) (n : \u2115) :\n    edist (f^[n] x) (efixedPoint f hf x hx) \u2264 edist x (f x) * (K : \u211d\u22650\u221e) ^ n / (1 - K)", "start": [135, 1], "end": [138, 61], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_efixedPoint_le", "code": "theorem edist_efixedPoint_le (hf : ContractingWith K f) {x : \u03b1} (hx : edist x (f x) \u2260 \u221e) :\n    edist x (efixedPoint f hf x hx) \u2264 edist x (f x) / (1 - K)", "start": [141, 1], "end": [144, 32], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_efixedPoint_lt_top", "code": "theorem edist_efixedPoint_lt_top (hf : ContractingWith K f) {x : \u03b1} (hx : edist x (f x) \u2260 \u221e) :\n    edist x (efixedPoint f hf x hx) < \u221e", "start": [147, 1], "end": [150, 73], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint_eq_of_edist_lt_top", "code": "theorem efixedPoint_eq_of_edist_lt_top (hf : ContractingWith K f) {x : \u03b1} (hx : edist x (f x) \u2260 \u221e)\n    {y : \u03b1} (hy : edist y (f y) \u2260 \u221e) (h : edist x y \u2260 \u221e) :\n    efixedPoint f hf x hx = efixedPoint f hf y hy", "start": [153, 1], "end": [163, 65], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.exists_fixedPoint'", "code": "theorem exists_fixedPoint' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    \u2203 y \u2208 s, IsFixedPt f y \u2227 Tendsto (fun n \u21a6 f^[n] x) atTop (\ud835\udcdd y) \u2227\n      \u2200 n : \u2115, edist (f^[n] x) y \u2264 edist x (f x) * (K : \u211d\u22650\u221e) ^ n / (1 - K)", "start": [166, 1], "end": [178, 8], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint'", "code": "noncomputable def efixedPoint' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) (x : \u03b1) (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    \u03b1 :=\n  Classical.choose <| hf.exists_fixedPoint' hsc hsf hxs hx", "start": [184, 1], "end": [190, 59], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint_mem'", "code": "theorem efixedPoint_mem' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    efixedPoint' f hsc hsf hf x hxs hx \u2208 s", "start": [195, 1], "end": [198, 68], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint_isFixedPt'", "code": "theorem efixedPoint_isFixedPt' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    IsFixedPt f (efixedPoint' f hsc hsf hf x hxs hx)", "start": [201, 1], "end": [204, 70], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.tendsto_iterate_efixedPoint'", "code": "theorem tendsto_iterate_efixedPoint' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    Tendsto (fun n \u21a6 f^[n] x) atTop (\ud835\udcdd <| efixedPoint' f hsc hsf hf x hxs hx)", "start": [207, 1], "end": [210, 72], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.apriori_edist_iterate_efixedPoint_le'", "code": "theorem apriori_edist_iterate_efixedPoint_le' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e)\n    (n : \u2115) :\n    edist (f^[n] x) (efixedPoint' f hsc hsf hf x hxs hx) \u2264\n      edist x (f x) * (K : \u211d\u22650\u221e) ^ n / (1 - K)", "start": [213, 1], "end": [218, 74], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_efixedPoint_le'", "code": "theorem edist_efixedPoint_le' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    edist x (efixedPoint' f hsc hsf hf x hxs hx) \u2264 edist x (f x) / (1 - K)", "start": [221, 1], "end": [225, 25], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.edist_efixedPoint_lt_top'", "code": "theorem edist_efixedPoint_lt_top' {s : Set \u03b1} (hsc : IsComplete s) (hsf : MapsTo f s s)\n    (hf : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s) (hx : edist x (f x) \u2260 \u221e) :\n    edist x (efixedPoint' f hsc hsf hf x hxs hx) < \u221e", "start": [228, 1], "end": [232, 73], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.efixedPoint_eq_of_edist_lt_top'", "code": "theorem efixedPoint_eq_of_edist_lt_top' (hf : ContractingWith K f) {s : Set \u03b1} (hsc : IsComplete s)\n    (hsf : MapsTo f s s) (hfs : ContractingWith K <| hsf.restrict f s s) {x : \u03b1} (hxs : x \u2208 s)\n    (hx : edist x (f x) \u2260 \u221e) {t : Set \u03b1} (htc : IsComplete t) (htf : MapsTo f t t)\n    (hft : ContractingWith K <| htf.restrict f t t) {y : \u03b1} (hyt : y \u2208 t) (hy : edist y (f y) \u2260 \u221e)\n    (hxy : edist x y \u2260 \u221e) :\n    efixedPoint' f hsc hsf hfs x hxs hx = efixedPoint' f htc htf hft y hyt hy", "start": [235, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.one_sub_K_pos", "code": "theorem one_sub_K_pos (hf : ContractingWith K f) : (0 : \u211d) < 1 - K", "start": [264, 1], "end": [265, 17], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.dist_le_mul", "code": "theorem dist_le_mul (x y : \u03b1) : dist (f x) (f y) \u2264 K * dist x y", "start": [269, 1], "end": [270, 37], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.dist_inequality", "code": "theorem dist_inequality (x y) : dist x y \u2264 (dist x (f x) + dist y (f y)) / (1 - K)", "start": [273, 1], "end": [278, 93], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.dist_le_of_fixedPoint", "code": "theorem dist_le_of_fixedPoint (x) {y} (hy : IsFixedPt f y) : dist x y \u2264 dist x (f x) / (1 - K)", "start": [281, 1], "end": [282, 71], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.fixedPoint_unique'", "code": "theorem fixedPoint_unique' {x y} (hx : IsFixedPt f x) (hy : IsFixedPt f y) : x = y", "start": [285, 1], "end": [286, 80], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.dist_fixedPoint_fixedPoint_of_dist_le'", "code": "theorem dist_fixedPoint_fixedPoint_of_dist_le' (g : \u03b1 \u2192 \u03b1) {x y} (hx : IsFixedPt f x)\n    (hy : IsFixedPt g y) {C} (hfg : \u2200 z, dist (f z) (g z) \u2264 C) : dist x y \u2264 C / (1 - K)", "start": [289, 1], "end": [297, 69], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.fixedPoint", "code": "noncomputable def fixedPoint : \u03b1 :=\n  efixedPoint f hf _ (edist_ne_top (Classical.choice \u2039Nonempty \u03b1\u203a) _)", "start": [304, 1], "end": [306, 70], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.fixedPoint_isFixedPt", "code": "theorem fixedPoint_isFixedPt : IsFixedPt f (fixedPoint f hf)", "start": [311, 1], "end": [313, 29], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.fixedPoint_unique", "code": "theorem fixedPoint_unique {x} (hx : IsFixedPt f x) : x = fixedPoint f hf", "start": [316, 1], "end": [317, 51], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.dist_fixedPoint_le", "code": "theorem dist_fixedPoint_le (x) : dist x (fixedPoint f hf) \u2264 dist x (f x) / (1 - K)", "start": [320, 1], "end": [321, 53], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.aposteriori_dist_iterate_fixedPoint_le", "code": "theorem aposteriori_dist_iterate_fixedPoint_le (x n) :\n    dist (f^[n] x) (fixedPoint f hf) \u2264 dist (f^[n] x) (f^[n + 1] x) / (1 - K)", "start": [324, 1], "end": [328, 30], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.apriori_dist_iterate_fixedPoint_le", "code": "theorem apriori_dist_iterate_fixedPoint_le (x n) :\n    dist (f^[n] x) (fixedPoint f hf) \u2264 dist x (f x) * (K : \u211d) ^ n / (1 - K)", "start": [331, 1], "end": [334, 99], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.tendsto_iterate_fixedPoint", "code": "theorem tendsto_iterate_fixedPoint (x) :\n    Tendsto (fun n \u21a6 f^[n] x) atTop (\ud835\udcdd <| fixedPoint f hf)", "start": [337, 1], "end": [341, 30], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.fixedPoint_lipschitz_in_map", "code": "theorem fixedPoint_lipschitz_in_map {g : \u03b1 \u2192 \u03b1} (hg : ContractingWith K g) {C}\n    (hfg : \u2200 z, dist (f z) (g z) \u2264 C) : dist (fixedPoint f hf) (fixedPoint g hg) \u2264 C / (1 - K)", "start": [344, 1], "end": [346, 98], "kind": "commanddeclaration"}, {"full_name": "ContractingWith.isFixedPt_fixedPoint_iterate", "code": "theorem isFixedPt_fixedPoint_iterate {n : \u2115} (hf : ContractingWith K f^[n]) :\n    IsFixedPt f (hf.fixedPoint f^[n])", "start": [349, 1], "end": [362, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/DedekindDomain/AdicValuation.lean", "imports": ["Mathlib/Topology/Algebra/ValuedField.lean", "Mathlib/RingTheory/DedekindDomain/Ideal.lean", "Mathlib/RingTheory/Valuation/ValuationSubring.lean", "Mathlib/Algebra/Order/Group/TypeTags.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Valuation/ExtendToLocalization.lean"], "premises": [{"full_name": "IsDedekindDomain.HeightOneSpectrum.intValuationDef", "code": "def intValuationDef (r : R) : \u2124\u2098\u2080 :=\n  if r = 0 then 0\n  else\n    Multiplicative.ofAdd\n      (-(Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {r} : Ideal R)).factors : \u2124)", "start": [75, 1], "end": [82, 96], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.intValuationDef_if_pos", "code": "theorem intValuationDef_if_pos {r : R} (hr : r = 0) : v.intValuationDef r = 0", "start": [85, 1], "end": [86, 12], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.intValuationDef_if_neg", "code": "theorem intValuationDef_if_neg {r : R} (hr : r \u2260 0) :\n    v.intValuationDef r =\n      Multiplicative.ofAdd\n        (-(Associates.mk v.asIdeal).count (Associates.mk (Ideal.span {r} : Ideal R)).factors : \u2124)", "start": [89, 1], "end": [93, 12], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_ne_zero", "code": "theorem int_valuation_ne_zero (x : R) (hx : x \u2260 0) : v.intValuationDef x \u2260 0", "start": [96, 1], "end": [99, 29], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_ne_zero'", "code": "theorem int_valuation_ne_zero' (x : nonZeroDivisors R) : v.intValuationDef x \u2260 0", "start": [102, 1], "end": [104, 60], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_zero_le", "code": "theorem int_valuation_zero_le (x : nonZeroDivisors R) : 0 < v.intValuationDef x", "start": [107, 1], "end": [110, 31], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_le_one", "code": "theorem int_valuation_le_one (x : R) : v.intValuationDef x \u2264 1", "start": [113, 1], "end": [120, 31], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_lt_one_iff_dvd", "code": "theorem int_valuation_lt_one_iff_dvd (r : R) :\n    v.intValuationDef r < 1 \u2194 v.asIdeal \u2223 Ideal.span {r}", "start": [123, 1], "end": [134, 70], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_le_pow_iff_dvd", "code": "theorem int_valuation_le_pow_iff_dvd (r : R) (n : \u2115) :\n    v.intValuationDef r \u2264 Multiplicative.ofAdd (-(n : \u2124)) \u2194 v.asIdeal ^ n \u2223 Ideal.span {r}", "start": [137, 1], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.IntValuation.map_zero'", "code": "theorem IntValuation.map_zero' : v.intValuationDef 0 = 0", "start": [150, 1], "end": [152, 39], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.IntValuation.map_one'", "code": "theorem IntValuation.map_one' : v.intValuationDef 1 = 1", "start": [155, 1], "end": [160, 22], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.IntValuation.map_mul'", "code": "theorem IntValuation.map_mul' (x y : R) :\n    v.intValuationDef (x * y) = v.intValuationDef x * v.intValuationDef y", "start": [163, 1], "end": [175, 10], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.IntValuation.le_max_iff_min_le", "code": "theorem IntValuation.le_max_iff_min_le {a b c : \u2115} :\n    Multiplicative.ofAdd (-c : \u2124) \u2264\n        max (Multiplicative.ofAdd (-a : \u2124)) (Multiplicative.ofAdd (-b : \u2124)) \u2194\n      min a b \u2264 c", "start": [178, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.IntValuation.map_add_le_max'", "code": "theorem IntValuation.map_add_le_max' (x y : R) :\n    v.intValuationDef (x + y) \u2264 max (v.intValuationDef x) (v.intValuationDef y)", "start": [186, 1], "end": [219, 39], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.intValuation", "code": "def intValuation : Valuation R \u2124\u2098\u2080 where\n  toFun := v.intValuationDef\n  map_zero' := IntValuation.map_zero' v\n  map_one' := IntValuation.map_one' v\n  map_mul' := IntValuation.map_mul' v\n  map_add_le_max' := IntValuation.map_add_le_max' v", "start": [222, 1], "end": [228, 52], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.int_valuation_exists_uniformizer", "code": "theorem int_valuation_exists_uniformizer :\n    \u2203 \u03c0 : R, v.intValuationDef \u03c0 = Multiplicative.ofAdd (-1 : \u2124)", "start": [231, 1], "end": [253, 41], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation", "code": "def valuation (v : HeightOneSpectrum R) : Valuation K \u2124\u2098\u2080 :=\n  v.intValuation.extendToLocalization\n    (fun r hr => Set.mem_compl <| v.int_valuation_ne_zero' \u27e8r, hr\u27e9) K", "start": [259, 1], "end": [263, 70], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_def", "code": "theorem valuation_def (x : K) :\n    v.valuation x =\n      v.intValuation.extendToLocalization\n        (fun r hr => Set.mem_compl (v.int_valuation_ne_zero' \u27e8r, hr\u27e9)) K x", "start": [266, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_of_mk'", "code": "theorem valuation_of_mk' {r : R} {s : nonZeroDivisors R} :\n    v.valuation (IsLocalization.mk' K r s) = v.intValuation r / v.intValuation s", "start": [273, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_of_algebraMap", "code": "theorem valuation_of_algebraMap (r : R) : v.valuation (algebraMap R K r) = v.intValuation r", "start": [283, 1], "end": [285, 69], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_le_one", "code": "theorem valuation_le_one (r : R) : v.valuation (algebraMap R K r) \u2264 1", "start": [288, 1], "end": [290, 63], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_lt_one_iff_dvd", "code": "theorem valuation_lt_one_iff_dvd (r : R) :\n    v.valuation (algebraMap R K r) < 1 \u2194 v.asIdeal \u2223 Ideal.span {r}", "start": [293, 1], "end": [296, 71], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_exists_uniformizer", "code": "theorem valuation_exists_uniformizer : \u2203 \u03c0 : K, v.valuation \u03c0 = Multiplicative.ofAdd (-1 : \u2124)", "start": [301, 1], "end": [306, 11], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuation_uniformizer_ne_zero", "code": "theorem valuation_uniformizer_ne_zero : Classical.choose (v.valuation_exists_uniformizer K) \u2260 0", "start": [309, 1], "end": [312, 72], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicValued", "code": "def adicValued : Valued K \u2124\u2098\u2080 :=\n  Valued.mk' v.valuation", "start": [324, 1], "end": [326, 25], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicValued_apply", "code": "theorem adicValued_apply {x : K} : (v.adicValued.v : _) x = v.valuation x", "start": [329, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicCompletion", "code": "def adicCompletion :=\n  @UniformSpace.Completion K v.adicValued.toUniformSpace", "start": [335, 1], "end": [337, 57], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion", "code": "instance valuedAdicCompletion : Valued (v.adicCompletion K) \u2124\u2098\u2080 :=\n  @Valued.valuedCompletion _ _ _ _ v.adicValued", "start": [347, 1], "end": [348, 48], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.valuedAdicCompletion_def", "code": "theorem valuedAdicCompletion_def {x : v.adicCompletion K} :\n    Valued.v x = @Valued.extension K _ _ _ (adicValued v) x", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicCompletion_completeSpace", "code": "instance adicCompletion_completeSpace : CompleteSpace (v.adicCompletion K) :=\n  @UniformSpace.Completion.completeSpace K v.adicValued.toUniformSpace", "start": [356, 1], "end": [357, 71], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.AdicCompletion.instCoe", "code": "instance AdicCompletion.instCoe : Coe K (v.adicCompletion K) :=\n  (inferInstance : Coe K (@UniformSpace.Completion K v.adicValued.toUniformSpace))", "start": [365, 1], "end": [366, 83], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicCompletionIntegers", "code": "def adicCompletionIntegers : ValuationSubring (v.adicCompletion K) :=\n  Valued.v.valuationSubring", "start": [368, 1], "end": [370, 28], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.mem_adicCompletionIntegers", "code": "theorem mem_adicCompletionIntegers {x : v.adicCompletion K} :\n    x \u2208 v.adicCompletionIntegers K \u2194 (Valued.v x : \u2124\u2098\u2080) \u2264 1", "start": [378, 1], "end": [380, 10], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicValued.has_uniform_continuous_const_smul'", "code": "instance (priority := 100) adicValued.has_uniform_continuous_const_smul' :\n    @UniformContinuousConstSMul R K v.adicValued.toUniformSpace _ :=\n  @uniformContinuousConstSMul_of_continuousConstSMul R K _ _ _ v.adicValued.toUniformSpace _ _", "start": [385, 1], "end": [387, 95], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.adicValued.uniformContinuousConstSMul", "code": "instance adicValued.uniformContinuousConstSMul :\n    @UniformContinuousConstSMul K K v.adicValued.toUniformSpace _ :=\n  @Ring.uniformContinuousConstSMul K _ v.adicValued.toUniformSpace _ _", "start": [390, 1], "end": [392, 71], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.AdicCompletion.algebra'", "code": "instance AdicCompletion.algebra' : Algebra R (v.adicCompletion K) :=\n  @UniformSpace.Completion.algebra K _ v.adicValued.toUniformSpace _ _ R _ _\n    (adicValued.has_uniform_continuous_const_smul' R K v)", "start": [395, 1], "end": [397, 58], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.coe_smul_adicCompletion", "code": "@[simp]\ntheorem coe_smul_adicCompletion (r : R) (x : K) :\n    (\u2191(r \u2022 x) : v.adicCompletion K) = r \u2022 (\u2191x : v.adicCompletion K)", "start": [400, 1], "end": [403, 76], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.algebraMap_adicCompletion'", "code": "theorem algebraMap_adicCompletion' :\n    \u21d1(algebraMap R <| v.adicCompletion K) = (\u2191) \u2218 algebraMap R K", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.algebraMap_adicCompletion", "code": "theorem algebraMap_adicCompletion :\n    \u21d1(algebraMap K <| v.adicCompletion K) = ((\u2191) : K \u2192 adicCompletion K v)", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.coe_smul_adicCompletionIntegers", "code": "@[simp]\ntheorem coe_smul_adicCompletionIntegers (r : R) (x : v.adicCompletionIntegers K) :\n    (\u2191(r \u2022 x) : v.adicCompletion K) = r \u2022 (x : v.adicCompletion K)", "start": [470, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "IsDedekindDomain.HeightOneSpectrum.AdicCompletion.instIsScalarTower'", "code": "instance AdicCompletion.instIsScalarTower' :\n    IsScalarTower R (v.adicCompletionIntegers K) (v.adicCompletion K) where\n  smul_assoc x y z := by simp only [Algebra.smul_def]; apply mul_assoc", "start": [485, 1], "end": [487, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Complex/Determinant.lean", "imports": ["Mathlib/Data/Complex/Module.lean", "Mathlib/LinearAlgebra/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.det_conjAe", "code": "@[simp]\ntheorem det_conjAe : LinearMap.det conjAe.toLinearMap = -1", "start": [22, 1], "end": [26, 7], "kind": "commanddeclaration"}, {"full_name": "Complex.linearEquiv_det_conjAe", "code": "@[simp]\ntheorem linearEquiv_det_conjAe : LinearEquiv.det conjAe.toLinearEquiv = -1", "start": [29, 1], "end": [33, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/Instances/Real.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/PiL2.lean", "Mathlib/Geometry/Manifold/SmoothManifoldWithCorners.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanHalfSpace", "code": "def EuclideanHalfSpace (n : \u2115) [Zero (Fin n)] : Type :=\n  { x : EuclideanSpace \u211d (Fin n) // 0 \u2264 x 0 }", "start": [48, 1], "end": [52, 46], "kind": "commanddeclaration"}, {"full_name": "EuclideanQuadrant", "code": "def EuclideanQuadrant (n : \u2115) : Type :=\n  { x : EuclideanSpace \u211d (Fin n) // \u2200 i : Fin n, 0 \u2264 x i }", "start": [55, 1], "end": [60, 59], "kind": "commanddeclaration"}, {"full_name": "EuclideanQuadrant.ext", "code": "@[ext] theorem EuclideanQuadrant.ext (x y : EuclideanQuadrant n) (h : x.1 = y.1) : x = y", "start": [82, 1], "end": [84, 15], "kind": "commanddeclaration"}, {"full_name": "EuclideanHalfSpace.ext", "code": "@[ext] theorem EuclideanHalfSpace.ext [Zero (Fin n)] (x y : EuclideanHalfSpace n)\n    (h : x.1 = y.1) : x = y", "start": [86, 1], "end": [89, 15], "kind": "commanddeclaration"}, {"full_name": "range_half_space", "code": "theorem range_half_space (n : \u2115) [Zero (Fin n)] :\n    (range fun x : EuclideanHalfSpace n => x.val) = { y | 0 \u2264 y 0 }", "start": [91, 1], "end": [93, 20], "kind": "commanddeclaration"}, {"full_name": "range_quadrant", "code": "theorem range_quadrant (n : \u2115) :\n    (range fun x : EuclideanQuadrant n => x.val) = { y | \u2200 i : Fin n, 0 \u2264 y i }", "start": [96, 1], "end": [98, 20], "kind": "commanddeclaration"}, {"full_name": "modelWithCornersEuclideanHalfSpace", "code": "def modelWithCornersEuclideanHalfSpace (n : \u2115) [Zero (Fin n)] :\n    ModelWithCorners \u211d (EuclideanSpace \u211d (Fin n)) (EuclideanHalfSpace n) where\n  toFun := Subtype.val\n  invFun x := \u27e8update x 0 (max (x 0) 0), by simp [le_refl]\u27e9\n  source := univ\n  target := { x | 0 \u2264 x 0 }\n  map_source' x _ := x.property\n  map_target' _ _ := mem_univ _\n  left_inv' := fun \u27e8xval, xprop\u27e9 _ => by\n    rw [Subtype.mk_eq_mk, update_eq_iff]\n    exact \u27e8max_eq_left xprop, fun i _ => rfl\u27e9\n  right_inv' x hx := update_eq_iff.2 \u27e8max_eq_left hx, fun i _ => rfl\u27e9\n  source_eq := rfl\n  unique_diff' := by\n    have : UniqueDiffOn \u211d _ :=\n      UniqueDiffOn.pi (Fin n) (fun _ => \u211d) _ _ fun i (_ : i \u2208 ({0} : Set (Fin n))) =>\n        uniqueDiffOn_Ici 0\n    simpa only [singleton_pi] using this\n  continuous_toFun := continuous_subtype_val\n  continuous_invFun :=\n    (continuous_id.update 0 <| (continuous_apply 0).max continuous_const).subtype_mk _", "start": [103, 1], "end": [127, 87], "kind": "commanddeclaration"}, {"full_name": "modelWithCornersEuclideanQuadrant", "code": "def modelWithCornersEuclideanQuadrant (n : \u2115) :\n    ModelWithCorners \u211d (EuclideanSpace \u211d (Fin n)) (EuclideanQuadrant n) where\n  toFun := Subtype.val\n  invFun x := \u27e8fun i => max (x i) 0, fun i => by simp only [le_refl, or_true_iff, le_max_iff]\u27e9\n  source := univ\n  target := { x | \u2200 i, 0 \u2264 x i }\n  map_source' x _ := x.property\n  map_target' x _ := mem_univ _\n  left_inv' x _ := by ext i; simp only [Subtype.coe_mk, x.2 i, max_eq_left]\n  right_inv' x hx := by ext1 i; simp only [hx i, max_eq_left]\n  source_eq := rfl\n  unique_diff' := by\n    have this : UniqueDiffOn \u211d _ :=\n      UniqueDiffOn.univ_pi (Fin n) (fun _ => \u211d) _ fun _ => uniqueDiffOn_Ici 0\n    simpa only [pi_univ_Ici] using this\n  continuous_toFun := continuous_subtype_val\n  continuous_invFun := Continuous.subtype_mk\n    (continuous_pi fun i => (continuous_id.max continuous_const).comp (continuous_apply i)) _", "start": [130, 1], "end": [150, 94], "kind": "commanddeclaration"}, {"full_name": "IccLeftChart", "code": "def IccLeftChart (x y : \u211d) [h : Fact (x < y)] :\n    LocalHomeomorph (Icc x y) (EuclideanHalfSpace 1) where\n  source := { z : Icc x y | z.val < y }\n  target := { z : EuclideanHalfSpace 1 | z.val 0 < y - x }\n  toFun := fun z : Icc x y => \u27e8fun _ => z.val - x, sub_nonneg.mpr z.property.1\u27e9\n  invFun z := \u27e8min (z.val 0 + x) y, by simp [le_refl, z.prop, le_of_lt h.out]\u27e9\n  map_source' := by simp only [imp_self, sub_lt_sub_iff_right, mem_setOf_eq, forall_true_iff]\n  map_target' := by\n    simp only [min_lt_iff, mem_setOf_eq]; intro z hz; left\n    linarith\n  left_inv' := by\n    rintro \u27e8z, hz\u27e9 h'z\n    simp only [mem_setOf_eq, mem_Icc] at hz h'z\n    simp only [hz, min_eq_left, sub_add_cancel]\n  right_inv' := by\n    rintro \u27e8z, hz\u27e9 h'z\n    rw [Subtype.mk_eq_mk]\n    funext i\n    dsimp at hz h'z\n    have A : x + z 0 \u2264 y := by linarith\n    rw [Subsingleton.elim i 0]\n    simp only [A, add_comm, add_sub_cancel', min_eq_left]\n  open_source :=\n    haveI : IsOpen { z : \u211d | z < y } := isOpen_Iio\n    this.preimage continuous_subtype_val\n  open_target := by\n    have : IsOpen { z : \u211d | z < y - x } := isOpen_Iio\n    have : IsOpen { z : EuclideanSpace \u211d (Fin 1) | z 0 < y - x } :=\n      this.preimage (@continuous_apply (Fin 1) (fun _ => \u211d) _ 0)\n    exact this.preimage continuous_subtype_val\n  continuous_toFun := by\n    apply Continuous.continuousOn\n    apply Continuous.subtype_mk\n    have : Continuous fun (z : \u211d) (_ : Fin 1) => z - x :=\n      Continuous.sub (continuous_pi fun _ => continuous_id) continuous_const\n    exact this.comp continuous_subtype_val\n  continuous_invFun := by\n    apply Continuous.continuousOn\n    apply Continuous.subtype_mk\n    have A : Continuous fun z : \u211d => min (z + x) y :=\n      (continuous_id.add continuous_const).min continuous_const\n    have B : Continuous fun z : EuclideanSpace \u211d (Fin 1) => z 0 := continuous_apply 0\n    exact (A.comp B).comp continuous_subtype_val", "start": [165, 1], "end": [210, 49], "kind": "commanddeclaration"}, {"full_name": "IccRightChart", "code": "def IccRightChart (x y : \u211d) [h : Fact (x < y)] :\n    LocalHomeomorph (Icc x y) (EuclideanHalfSpace 1) where\n  source := { z : Icc x y | x < z.val }\n  target := { z : EuclideanHalfSpace 1 | z.val 0 < y - x }\n  toFun z := \u27e8fun _ => y - z.val, sub_nonneg.mpr z.property.2\u27e9\n  invFun z :=\n    \u27e8max (y - z.val 0) x, by simp [le_refl, z.prop, le_of_lt h.out, sub_eq_add_neg]\u27e9\n  map_source' := by simp only [imp_self, mem_setOf_eq, sub_lt_sub_iff_left, forall_true_iff]\n  map_target' := by\n    simp only [lt_max_iff, mem_setOf_eq]; intro z hz; left\n    linarith\n  left_inv' := by\n    rintro \u27e8z, hz\u27e9 h'z\n    simp only [mem_setOf_eq, mem_Icc] at hz h'z\n    simp only [hz, sub_eq_add_neg, max_eq_left, add_add_neg_cancel'_right, neg_add_rev, neg_neg]\n  right_inv' := by\n    rintro \u27e8z, hz\u27e9 h'z\n    rw [Subtype.mk_eq_mk]\n    funext i\n    dsimp at hz h'z\n    have A : x \u2264 y - z 0 := by linarith\n    rw [Subsingleton.elim i 0]\n    simp only [A, sub_sub_cancel, max_eq_left]\n  open_source :=\n    haveI : IsOpen { z : \u211d | x < z } := isOpen_Ioi\n    this.preimage continuous_subtype_val\n  open_target := by\n    have : IsOpen { z : \u211d | z < y - x } := isOpen_Iio\n    have : IsOpen { z : EuclideanSpace \u211d (Fin 1) | z 0 < y - x } :=\n      this.preimage (@continuous_apply (Fin 1) (fun _ => \u211d) _ 0)\n    exact this.preimage continuous_subtype_val\n  continuous_toFun := by\n    apply Continuous.continuousOn\n    apply Continuous.subtype_mk\n    have : Continuous fun (z : \u211d) (_ : Fin 1) => y - z :=\n      continuous_const.sub (continuous_pi fun _ => continuous_id)\n    exact this.comp continuous_subtype_val\n  continuous_invFun := by\n    apply Continuous.continuousOn\n    apply Continuous.subtype_mk\n    have A : Continuous fun z : \u211d => max (y - z) x :=\n      (continuous_const.sub continuous_id).max continuous_const\n    have B : Continuous fun z : EuclideanSpace \u211d (Fin 1) => z 0 := continuous_apply 0\n    exact (A.comp B).comp continuous_subtype_val", "start": [213, 1], "end": [259, 49], "kind": "commanddeclaration"}, {"full_name": "IccManifold", "code": "instance IccManifold (x y : \u211d) [h : Fact (x < y)] :\n    ChartedSpace (EuclideanHalfSpace 1) (Icc x y) where\n  atlas := {IccLeftChart x y, IccRightChart x y}\n  chartAt z := if z.val < y then IccLeftChart x y else IccRightChart x y\n  mem_chart_source z := by\n    by_cases h' : z.val < y\n    \u00b7 simp only [h', if_true]\n      exact h'\n    \u00b7 simp only [h', if_false]\n      apply lt_of_lt_of_le h.out\n      simpa only [not_lt] using h'\n  chart_mem_atlas z := by by_cases h' : (z : \u211d) < y <;> simp [h']", "start": [262, 1], "end": [276, 66], "kind": "commanddeclaration"}, {"full_name": "Icc_smooth_manifold", "code": "instance Icc_smooth_manifold (x y : \u211d) [Fact (x < y)] :\n    SmoothManifoldWithCorners (\ud835\udce1\u2202 1) (Icc x y) := by\n  have M : ContDiff \u211d \u221e (show EuclideanSpace \u211d (Fin 1) \u2192 EuclideanSpace \u211d (Fin 1)\n      from fun z i => -z i + (y - x)) :=\n    contDiff_id.neg.add contDiff_const\n  apply smoothManifoldWithCorners_of_contDiffOn\n  intro e e' he he'\n  simp only [atlas, mem_singleton_iff, mem_insert_iff] at he he'\n  \n  rcases he with (rfl | rfl) <;> rcases he' with (rfl | rfl)\n  \u00b7 exact (mem_groupoid_of_pregroupoid.mpr (symm_trans_mem_contDiffGroupoid _ _ _)).1\n  \u00b7 apply M.contDiffOn.congr\n    rintro _ \u27e8\u27e8hz\u2081, hz\u2082\u27e9, \u27e8\u27e8z, hz\u2080\u27e9, rfl\u27e9\u27e9\n    simp only [modelWithCornersEuclideanHalfSpace, IccLeftChart, IccRightChart, update_same,\n      max_eq_left, hz\u2080, lt_sub_iff_add_lt, mfld_simps] at hz\u2081 hz\u2082\n    rw [min_eq_left hz\u2081.le, lt_add_iff_pos_left] at hz\u2082\n    ext i\n    rw [Subsingleton.elim i 0]\n    simp only [modelWithCornersEuclideanHalfSpace, IccLeftChart, IccRightChart, *, PiLp.add_apply,\n      PiLp.neg_apply, max_eq_left, min_eq_left hz\u2081.le, update_same, mfld_simps]\n    abel\n  \u00b7 apply M.contDiffOn.congr\n    rintro _ \u27e8\u27e8hz\u2081, hz\u2082\u27e9, \u27e8z, hz\u2080\u27e9, rfl\u27e9\n    simp only [modelWithCornersEuclideanHalfSpace, IccLeftChart, IccRightChart, max_lt_iff,\n      update_same, max_eq_left hz\u2080, mfld_simps] at hz\u2081 hz\u2082\n    rw [lt_sub_comm] at hz\u2081\n    ext i\n    rw [Subsingleton.elim i 0]\n    simp only [modelWithCornersEuclideanHalfSpace, IccLeftChart, IccRightChart, PiLp.add_apply,\n      PiLp.neg_apply, update_same, max_eq_left, hz\u2080, hz\u2081.le, mfld_simps]\n    abel\n  \u00b7exact (mem_groupoid_of_pregroupoid.mpr (symm_trans_mem_contDiffGroupoid _ _ _)).1", "start": [279, 1], "end": [317, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/BallAction.lean", "imports": ["Mathlib/Analysis/Normed/Field/UnitBall.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mulActionClosedBallBall", "code": "instance mulActionClosedBallBall : MulAction (closedBall (0 : \ud835\udd5c) 1) (ball (0 : E) r) where\n  smul c x :=\n    \u27e8(c : \ud835\udd5c) \u2022 \u2191x,\n      mem_ball_zero_iff.2 <| by\n        simpa only [norm_smul, one_mul] using\n          mul_lt_mul' (mem_closedBall_zero_iff.1 c.2) (mem_ball_zero_iff.1 x.2) (norm_nonneg _)\n            one_pos\u27e9\n  one_smul x := Subtype.ext <| one_smul \ud835\udd5c _\n  mul_smul c\u2081 c\u2082 x := Subtype.ext <| mul_smul _ _ _", "start": [29, 1], "end": [37, 52], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_closedBall_ball", "code": "instance continuousSMul_closedBall_ball : ContinuousSMul (closedBall (0 : \ud835\udd5c) 1) (ball (0 : E) r) :=\n  \u27e8(continuous_subtype_val.fst'.smul continuous_subtype_val.snd').subtype_mk _\u27e9", "start": [40, 1], "end": [41, 80], "kind": "commanddeclaration"}, {"full_name": "mulActionClosedBallClosedBall", "code": "instance mulActionClosedBallClosedBall : MulAction (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : E) r)\n    where\n  smul c x :=\n    \u27e8(c : \ud835\udd5c) \u2022 \u2191x,\n      mem_closedBall_zero_iff.2 <| by\n        simpa only [norm_smul, one_mul] using\n          mul_le_mul (mem_closedBall_zero_iff.1 c.2) (mem_closedBall_zero_iff.1 x.2) (norm_nonneg _)\n            zero_le_one\u27e9\n  one_smul x := Subtype.ext <| one_smul \ud835\udd5c _\n  mul_smul c\u2081 c\u2082 x := Subtype.ext <| mul_smul _ _ _", "start": [44, 1], "end": [53, 52], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_closedBall_closedBall", "code": "instance continuousSMul_closedBall_closedBall :\n    ContinuousSMul (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : E) r) :=\n  \u27e8(continuous_subtype_val.fst'.smul continuous_subtype_val.snd').subtype_mk _\u27e9", "start": [56, 1], "end": [58, 80], "kind": "commanddeclaration"}, {"full_name": "mulActionSphereBall", "code": "instance mulActionSphereBall : MulAction (sphere (0 : \ud835\udd5c) 1) (ball (0 : E) r) where\n  smul c x := inclusion sphere_subset_closedBall c \u2022 x\n  one_smul _ := Subtype.ext <| one_smul _ _\n  mul_smul _ _ _ := Subtype.ext <| mul_smul _ _ _", "start": [65, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_sphere_ball", "code": "instance continuousSMul_sphere_ball : ContinuousSMul (sphere (0 : \ud835\udd5c) 1) (ball (0 : E) r) :=\n  \u27e8(continuous_subtype_val.fst'.smul continuous_subtype_val.snd').subtype_mk _\u27e9", "start": [71, 1], "end": [72, 80], "kind": "commanddeclaration"}, {"full_name": "mulActionSphereClosedBall", "code": "instance mulActionSphereClosedBall : MulAction (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : E) r) where\n  smul c x := inclusion sphere_subset_closedBall c \u2022 x\n  one_smul _ := Subtype.ext <| one_smul _ _\n  mul_smul _ _ _ := Subtype.ext <| mul_smul _ _ _", "start": [75, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_sphere_closedBall", "code": "instance continuousSMul_sphere_closedBall :\n    ContinuousSMul (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : E) r) :=\n  \u27e8(continuous_subtype_val.fst'.smul continuous_subtype_val.snd').subtype_mk _\u27e9", "start": [81, 1], "end": [83, 80], "kind": "commanddeclaration"}, {"full_name": "mulActionSphereSphere", "code": "instance mulActionSphereSphere : MulAction (sphere (0 : \ud835\udd5c) 1) (sphere (0 : E) r) where\n  smul c x :=\n    \u27e8(c : \ud835\udd5c) \u2022 \u2191x,\n      mem_sphere_zero_iff_norm.2 <| by\n        rw [norm_smul, mem_sphere_zero_iff_norm.1 c.coe_prop, mem_sphere_zero_iff_norm.1 x.coe_prop,\n          one_mul]\u27e9\n  one_smul x := Subtype.ext <| one_smul _ _\n  mul_smul c\u2081 c\u2082 x := Subtype.ext <| mul_smul _ _ _", "start": [86, 1], "end": [93, 52], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_sphere_sphere", "code": "instance continuousSMul_sphere_sphere : ContinuousSMul (sphere (0 : \ud835\udd5c) 1) (sphere (0 : E) r) :=\n  \u27e8(continuous_subtype_val.fst'.smul continuous_subtype_val.snd').subtype_mk _\u27e9", "start": [96, 1], "end": [97, 80], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_closedBall_closedBall_closedBall", "code": "instance isScalarTower_closedBall_closedBall_closedBall :\n    IsScalarTower (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [106, 1], "end": [108, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_closedBall_closedBall_ball", "code": "instance isScalarTower_closedBall_closedBall_ball :\n    IsScalarTower (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [111, 1], "end": [113, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_closedBall_closedBall", "code": "instance isScalarTower_sphere_closedBall_closedBall :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [116, 1], "end": [118, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_closedBall_ball", "code": "instance isScalarTower_sphere_closedBall_ball :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [121, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_sphere_closedBall", "code": "instance isScalarTower_sphere_sphere_closedBall :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [126, 1], "end": [128, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_sphere_ball", "code": "instance isScalarTower_sphere_sphere_ball :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [131, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_sphere_sphere", "code": "instance isScalarTower_sphere_sphere_sphere :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (sphere (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [136, 1], "end": [138, 68], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_sphere_ball_ball", "code": "instance isScalarTower_sphere_ball_ball :\n    IsScalarTower (sphere (0 : \ud835\udd5c) 1) (ball (0 : \ud835\udd5c') 1) (ball (0 : \ud835\udd5c') 1) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : \ud835\udd5c')\u27e9", "start": [141, 1], "end": [143, 69], "kind": "commanddeclaration"}, {"full_name": "isScalarTower_closedBall_ball_ball", "code": "instance isScalarTower_closedBall_ball_ball :\n    IsScalarTower (closedBall (0 : \ud835\udd5c) 1) (ball (0 : \ud835\udd5c') 1) (ball (0 : \ud835\udd5c') 1) :=\n  \u27e8fun a b c => Subtype.ext <| smul_assoc (a : \ud835\udd5c) (b : \ud835\udd5c') (c : \ud835\udd5c')\u27e9", "start": [146, 1], "end": [148, 69], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_closedBall_closedBall_closedBall", "code": "instance instSMulCommClass_closedBall_closedBall_closedBall :\n    SMulCommClass (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [157, 1], "end": [159, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_closedBall_closedBall_ball", "code": "instance instSMulCommClass_closedBall_closedBall_ball :\n    SMulCommClass (closedBall (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [162, 1], "end": [164, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_closedBall_closedBall", "code": "instance instSMulCommClass_sphere_closedBall_closedBall :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [167, 1], "end": [169, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_closedBall_ball", "code": "instance instSMulCommClass_sphere_closedBall_ball :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (closedBall (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [172, 1], "end": [174, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_ball_ball", "code": "instance instSMulCommClass_sphere_ball_ball [NormedAlgebra \ud835\udd5c \ud835\udd5c'] :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (ball (0 : \ud835\udd5c') 1) (ball (0 : \ud835\udd5c') 1) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : \ud835\udd5c')\u27e9", "start": [177, 1], "end": [179, 68], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_sphere_closedBall", "code": "instance instSMulCommClass_sphere_sphere_closedBall :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (closedBall (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [182, 1], "end": [184, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_sphere_ball", "code": "instance instSMulCommClass_sphere_sphere_ball :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (ball (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [187, 1], "end": [189, 67], "kind": "commanddeclaration"}, {"full_name": "instSMulCommClass_sphere_sphere_sphere", "code": "instance instSMulCommClass_sphere_sphere_sphere :\n    SMulCommClass (sphere (0 : \ud835\udd5c) 1) (sphere (0 : \ud835\udd5c') 1) (sphere (0 : E) r) :=\n  \u27e8fun a b c => Subtype.ext <| smul_comm (a : \ud835\udd5c) (b : \ud835\udd5c') (c : E)\u27e9", "start": [192, 1], "end": [194, 67], "kind": "commanddeclaration"}, {"full_name": "ne_neg_of_mem_sphere", "code": "theorem ne_neg_of_mem_sphere {r : \u211d} (hr : r \u2260 0) (x : sphere (0 : E) r) : x \u2260 -x", "start": [203, 1], "end": [204, 76], "kind": "commanddeclaration"}, {"full_name": "ne_neg_of_mem_unit_sphere", "code": "theorem ne_neg_of_mem_unit_sphere (x : sphere (0 : E) 1) : x \u2260 -x", "start": [207, 1], "end": [208, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Array.lean", "imports": ["Mathlib/Logic/Equiv/List.lean", "Mathlib/Data/Vector/Basic.lean", "Mathlib/Control/Traversable/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.arrayEquivList", "code": "def arrayEquivList (\u03b1 : Type*) : Array \u03b1 \u2243 List \u03b1 :=\n  \u27e8Array.data, Array.mk, fun _ => rfl, fun _ => rfl\u27e9", "start": [49, 1], "end": [51, 53], "kind": "commanddeclaration"}, {"full_name": "Array.encodable", "code": "instance Array.encodable {\u03b1} [Encodable \u03b1] : Encodable (Array \u03b1) :=\n  Encodable.ofEquiv _ (Equiv.arrayEquivList _)", "start": [78, 1], "end": [80, 47], "kind": "commanddeclaration"}, {"full_name": "Array.countable", "code": "instance Array.countable {\u03b1} [Countable \u03b1] : Countable (Array \u03b1) :=\n  Countable.of_equiv _ (Equiv.arrayEquivList \u03b1).symm", "start": [83, 1], "end": [85, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SuccPred/LinearLocallyFinite.lean", "imports": ["Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Data/Countable/Basic.lean", "Mathlib/Order/SuccPred/Basic.lean", "Mathlib/Logic/Encodable/Basic.lean"], "premises": [{"full_name": "LinearLocallyFiniteOrder.succFn", "code": "noncomputable def succFn (i : \u03b9) : \u03b9 :=\n  (exists_glb_Ioi i).choose", "start": [63, 1], "end": [66, 28], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.succFn_spec", "code": "theorem succFn_spec (i : \u03b9) : IsGLB (Set.Ioi i) (succFn i)", "start": [69, 1], "end": [70, 33], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.le_succFn", "code": "theorem le_succFn (i : \u03b9) : i \u2264 succFn i", "start": [73, 1], "end": [75, 31], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.isGLB_Ioc_of_isGLB_Ioi", "code": "theorem isGLB_Ioc_of_isGLB_Ioi {i j k : \u03b9} (hij_lt : i < j) (h : IsGLB (Set.Ioi i) k) :\n    IsGLB (Set.Ioc i j) k", "start": [78, 1], "end": [85, 51], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.isMax_of_succFn_le", "code": "theorem isMax_of_succFn_le [LocallyFiniteOrder \u03b9] (i : \u03b9) (hi : succFn i \u2264 i) : IsMax i", "start": [88, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.succFn_le_of_lt", "code": "theorem succFn_le_of_lt (i j : \u03b9) (hij : i < j) : succFn i \u2264 j", "start": [103, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.le_of_lt_succFn", "code": "theorem le_of_lt_succFn (j i : \u03b9) (hij : j < succFn i) : j \u2264 i", "start": [109, 1], "end": [113, 64], "kind": "commanddeclaration"}, {"full_name": "LinearLocallyFiniteOrder.isSuccArchimedean", "code": "instance (priority := 100) LinearLocallyFiniteOrder.isSuccArchimedean [LocallyFiniteOrder \u03b9] :\n    IsSuccArchimedean \u03b9 where\n  exists_succ_iterate_of_le := by\n    intro i j hij\n    rw [le_iff_lt_or_eq] at hij\n    cases' hij with hij hij\n    swap\n    \u00b7 refine' \u27e80, _\u27e9\n      simpa only [Function.iterate_zero, id.def] using hij\n    by_contra h\n    push_neg at h\n    have h_lt : \u2200 n, succ^[n] i < j := by\n      intro n\n      induction' n with n hn\n      \u00b7 simpa only [Function.iterate_zero, id.def] using hij\n      \u00b7 refine' lt_of_le_of_ne _ (h _)\n        rw [Function.iterate_succ', Function.comp_apply]\n        exact succ_le_of_lt hn\n    have h_mem : \u2200 n, succ^[n] i \u2208 Finset.Icc i j :=\n      fun n \u21a6 Finset.mem_Icc.mpr \u27e8le_succ_iterate n i, (h_lt n).le\u27e9\n    obtain \u27e8n, m, hnm, h_eq\u27e9 : \u2203 n m, n < m \u2227 succ^[n] i = succ^[m] i := by\n      let f : \u2115 \u2192 Finset.Icc i j := fun n \u21a6 \u27e8succ^[n] i, h_mem n\u27e9\n      obtain \u27e8n, m, hnm_ne, hfnm\u27e9 : \u2203 n m, n \u2260 m \u2227 f n = f m\n      exact Finite.exists_ne_map_eq_of_infinite f\n      have hnm_eq : succ^[n] i = succ^[m] i := by simpa only [Subtype.mk_eq_mk] using hfnm\n      cases' le_total n m with h_le h_le\n      \u00b7 exact \u27e8n, m, lt_of_le_of_ne h_le hnm_ne, hnm_eq\u27e9\n      \u00b7 exact \u27e8m, n, lt_of_le_of_ne h_le hnm_ne.symm, hnm_eq.symm\u27e9\n    have h_max : IsMax (succ^[n] i) := isMax_iterate_succ_of_eq_of_ne h_eq hnm.ne\n    exact not_le.mpr (h_lt n) (h_max (h_lt n).le)", "start": [128, 1], "end": [157, 50], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.isPredArchimedean_of_isSuccArchimedean", "code": "instance (priority := 100) LinearOrder.isPredArchimedean_of_isSuccArchimedean [SuccOrder \u03b9]\n    [PredOrder \u03b9] [IsSuccArchimedean \u03b9] : IsPredArchimedean \u03b9 where\n  exists_pred_iterate_of_le := by\n    intro i j hij\n    have h_exists := exists_succ_iterate_of_le hij\n    obtain \u27e8n, hn_eq, hn_lt_ne\u27e9 : \u2203 n, succ^[n] i = j \u2227 \u2200 m < n, succ^[m] i \u2260 j\n    exact \u27e8Nat.find h_exists, Nat.find_spec h_exists, fun m hmn \u21a6 Nat.find_min h_exists hmn\u27e9\n    refine' \u27e8n, _\u27e9\n    rw [\u2190 hn_eq]\n    induction' n with n\n    \u00b7 simp only [Nat.zero_eq, Function.iterate_zero, id.def]\n    \u00b7 rw [pred_succ_iterate_of_not_isMax]\n      rw [Nat.succ_sub_succ_eq_sub, tsub_zero]\n      suffices succ^[n] i < succ^[n.succ] i from not_isMax_of_lt this\n      refine' lt_of_le_of_ne _ _\n      \u00b7 rw [Function.iterate_succ']\n        exact le_succ _\n      \u00b7 rw [hn_eq]\n        exact hn_lt_ne _ (Nat.lt_succ_self n)", "start": [160, 1], "end": [178, 46], "kind": "commanddeclaration"}, {"full_name": "toZ", "code": "def toZ (i0 i : \u03b9) : \u2124 :=\n  dite (i0 \u2264 i) (fun hi \u21a6 Nat.find (exists_succ_iterate_of_le hi)) fun hi \u21a6\n    -Nat.find (exists_pred_iterate_of_le (not_le.mp hi).le)", "start": [188, 1], "end": [193, 60], "kind": "commanddeclaration"}, {"full_name": "toZ_of_ge", "code": "theorem toZ_of_ge (hi : i0 \u2264 i) : toZ i0 i = Nat.find (exists_succ_iterate_of_le hi)", "start": [196, 1], "end": [197, 13], "kind": "commanddeclaration"}, {"full_name": "toZ_of_lt", "code": "theorem toZ_of_lt (hi : i < i0) : toZ i0 i = -Nat.find (exists_pred_iterate_of_le hi.le)", "start": [200, 1], "end": [201, 26], "kind": "commanddeclaration"}, {"full_name": "toZ_of_eq", "code": "@[simp]\ntheorem toZ_of_eq : toZ i0 i0 = 0", "start": [204, 1], "end": [209, 37], "kind": "commanddeclaration"}, {"full_name": "iterate_succ_toZ", "code": "theorem iterate_succ_toZ (i : \u03b9) (hi : i0 \u2264 i) : succ^[(toZ i0 i).toNat] i0 = i", "start": [212, 1], "end": [214, 53], "kind": "commanddeclaration"}, {"full_name": "iterate_pred_toZ", "code": "theorem iterate_pred_toZ (i : \u03b9) (hi : i < i0) : pred^[(-toZ i0 i).toNat] i0 = i", "start": [217, 1], "end": [219, 56], "kind": "commanddeclaration"}, {"full_name": "toZ_nonneg", "code": "theorem toZ_nonneg (hi : i0 \u2264 i) : 0 \u2264 toZ i0 i", "start": [222, 1], "end": [224, 26], "kind": "commanddeclaration"}, {"full_name": "toZ_neg", "code": "theorem toZ_neg (hi : i < i0) : toZ i0 i < 0", "start": [227, 1], "end": [234, 97], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_succ_le", "code": "theorem toZ_iterate_succ_le (n : \u2115) : toZ i0 (succ^[n] i0) \u2264 n", "start": [237, 1], "end": [240, 28], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_pred_ge", "code": "theorem toZ_iterate_pred_ge (n : \u2115) : -(n : \u2124) \u2264 toZ i0 (pred^[n] i0)", "start": [243, 1], "end": [250, 30], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_succ_of_not_isMax", "code": "theorem toZ_iterate_succ_of_not_isMax (n : \u2115) (hn : \u00acIsMax (succ^[n] i0)) :\n    toZ i0 (succ^[n] i0) = n", "start": [253, 1], "end": [262, 63], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_pred_of_not_isMin", "code": "theorem toZ_iterate_pred_of_not_isMin (n : \u2115) (hn : \u00acIsMin (pred^[n] i0)) :\n    toZ i0 (pred^[n] i0) = -n", "start": [265, 1], "end": [282, 65], "kind": "commanddeclaration"}, {"full_name": "le_of_toZ_le", "code": "theorem le_of_toZ_le {j : \u03b9} (h_le : toZ i0 i \u2264 toZ i0 j) : i \u2264 j", "start": [285, 1], "end": [293, 26], "kind": "commanddeclaration"}, {"full_name": "toZ_mono", "code": "theorem toZ_mono {i j : \u03b9} (h_le : i \u2264 j) : toZ i0 i \u2264 toZ i0 j", "start": [296, 1], "end": [342, 92], "kind": "commanddeclaration"}, {"full_name": "toZ_le_iff", "code": "theorem toZ_le_iff (i j : \u03b9) : toZ i0 i \u2264 toZ i0 j \u2194 i \u2264 j", "start": [345, 1], "end": [346, 27], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_succ", "code": "theorem toZ_iterate_succ [NoMaxOrder \u03b9] (n : \u2115) : toZ i0 (succ^[n] i0) = n", "start": [349, 1], "end": [350, 48], "kind": "commanddeclaration"}, {"full_name": "toZ_iterate_pred", "code": "theorem toZ_iterate_pred [NoMinOrder \u03b9] (n : \u2115) : toZ i0 (pred^[n] i0) = -n", "start": [353, 1], "end": [354, 48], "kind": "commanddeclaration"}, {"full_name": "injective_toZ", "code": "theorem injective_toZ : Function.Injective (toZ i0)", "start": [357, 1], "end": [358, 71], "kind": "commanddeclaration"}, {"full_name": "orderIsoRangeToZOfLinearSuccPredArch", "code": "noncomputable def orderIsoRangeToZOfLinearSuccPredArch [h\u03b9 : Nonempty \u03b9] :\n    \u03b9 \u2243o Set.range (toZ h\u03b9.some) where\n  toEquiv := Equiv.ofInjective _ injective_toZ\n  map_rel_iff' := by intro i j; exact toZ_le_iff i j", "start": [367, 1], "end": [371, 53], "kind": "commanddeclaration"}, {"full_name": "countable_of_linear_succ_pred_arch", "code": "instance (priority := 100) countable_of_linear_succ_pred_arch : Countable \u03b9 := by\n  cases' isEmpty_or_nonempty \u03b9 with _ h\u03b9\n  \u00b7 infer_instance\n  \u00b7 exact Countable.of_equiv _ orderIsoRangeToZOfLinearSuccPredArch.symm.toEquiv", "start": [375, 1], "end": [378, 81], "kind": "commanddeclaration"}, {"full_name": "orderIsoIntOfLinearSuccPredArch", "code": "noncomputable def orderIsoIntOfLinearSuccPredArch [NoMaxOrder \u03b9] [NoMinOrder \u03b9] [h\u03b9 : Nonempty \u03b9] :\n    \u03b9 \u2243o \u2124 where\n  toFun := toZ h\u03b9.some\n  invFun n := if 0 \u2264 n then succ^[n.toNat] h\u03b9.some else pred^[(-n).toNat] h\u03b9.some\n  left_inv i := by\n    cases' le_or_lt h\u03b9.some i with hi hi\n    \u00b7 have h_nonneg : 0 \u2264 toZ h\u03b9.some i := toZ_nonneg hi\n      simp_rw [if_pos h_nonneg]\n      exact iterate_succ_toZ i hi\n    \u00b7 have h_neg : toZ h\u03b9.some i < 0 := toZ_neg hi\n      simp_rw [if_neg (not_le.mpr h_neg)]\n      exact iterate_pred_toZ i hi\n  right_inv n := by\n    cases' le_or_lt 0 n with hn hn\n    \u00b7 simp_rw [if_pos hn]\n      rw [toZ_iterate_succ]\n      exact Int.toNat_of_nonneg hn\n    \u00b7 simp_rw [if_neg (not_le.mpr hn)]\n      rw [toZ_iterate_pred]\n      simp only [hn.le, Int.toNat_of_nonneg, Right.nonneg_neg_iff, neg_neg]\n  map_rel_iff' := by intro i j; exact toZ_le_iff i j", "start": [381, 1], "end": [402, 53], "kind": "commanddeclaration"}, {"full_name": "orderIsoNatOfLinearSuccPredArch", "code": "def orderIsoNatOfLinearSuccPredArch [NoMaxOrder \u03b9] [OrderBot \u03b9] : \u03b9 \u2243o \u2115 where\n  toFun i := (toZ \u22a5 i).toNat\n  invFun n := succ^[n] \u22a5\n  left_inv i := by\n    dsimp only\n    exact iterate_succ_toZ i bot_le\n  right_inv n := by\n    dsimp only\n    rw [toZ_iterate_succ]\n    exact Int.toNat_coe_nat n\n  map_rel_iff' := by\n    intro i j\n    simp only [Equiv.coe_fn_mk, Int.toNat_le]\n    rw [\u2190 @toZ_le_iff \u03b9 _ _ _ _ \u22a5, Int.toNat_of_nonneg (toZ_nonneg bot_le)]", "start": [405, 1], "end": [419, 76], "kind": "commanddeclaration"}, {"full_name": "orderIsoRangeOfLinearSuccPredArch", "code": "def orderIsoRangeOfLinearSuccPredArch [OrderBot \u03b9] [OrderTop \u03b9] :\n    \u03b9 \u2243o Finset.range ((toZ \u22a5 (\u22a4 : \u03b9)).toNat + 1) where\n  toFun i :=\n    \u27e8(toZ \u22a5 i).toNat,\n      Finset.mem_range_succ_iff.mpr (Int.toNat_le_toNat ((toZ_le_iff _ _).mpr le_top))\u27e9\n  invFun n := succ^[n] \u22a5\n  left_inv i := iterate_succ_toZ i bot_le\n  right_inv n := by\n    ext1\n    simp only [Subtype.coe_mk]\n    refine' le_antisymm _ _\n    \u00b7 rw [Int.toNat_le]\n      exact toZ_iterate_succ_le _\n    by_cases hn_max : IsMax (succ^[\u2191n] (\u22a5 : \u03b9))\n    \u00b7 rw [\u2190 isTop_iff_isMax, isTop_iff_eq_top] at hn_max\n      rw [hn_max]\n      exact Nat.lt_succ_iff.mp (Finset.mem_range.mp n.prop)\n    \u00b7 rw [toZ_iterate_succ_of_not_isMax _ hn_max]\n      simp only [Int.toNat_coe_nat, le_refl]\n  map_rel_iff' := by\n    intro i j\n    simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, Int.toNat_le]\n    rw [\u2190 @toZ_le_iff \u03b9 _ _ _ _ \u22a5, Int.toNat_of_nonneg (toZ_nonneg bot_le)]", "start": [422, 1], "end": [446, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Interval.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonemptyInterval", "code": "structure NonemptyInterval (\u03b1 : Type*) [LE \u03b1] extends Prod \u03b1 \u03b1 where\n  \n  fst_le_snd : fst \u2264 snd", "start": [29, 1], "end": [40, 25], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toProd_injective", "code": "theorem toProd_injective : Injective (toProd : NonemptyInterval \u03b1 \u2192 \u03b1 \u00d7 \u03b1)", "start": [49, 1], "end": [50, 29], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.ext", "code": "theorem ext (s t : NonemptyInterval \u03b1) (h : s.toProd = t.toProd) : s = t", "start": [55, 1], "end": [55, 95], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.ext_iff", "code": "theorem ext_iff (s t : NonemptyInterval \u03b1) : s = t \u2194 s.toProd = t.toProd", "start": [60, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toDualProd", "code": "def toDualProd : NonemptyInterval \u03b1 \u2192 \u03b1\u1d52\u1d48 \u00d7 \u03b1 :=\n  toProd", "start": [64, 1], "end": [66, 9], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toDualProd_apply", "code": "@[simp]\ntheorem toDualProd_apply (s : NonemptyInterval \u03b1) : s.toDualProd = (toDual s.fst, s.snd)", "start": [69, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toDualProd_injective", "code": "theorem toDualProd_injective : Injective (toDualProd : NonemptyInterval \u03b1 \u2192 \u03b1\u1d52\u1d48 \u00d7 \u03b1)", "start": [74, 1], "end": [75, 19], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.le", "code": "instance le : LE (NonemptyInterval \u03b1) :=\n  \u27e8fun s t => t.fst \u2264 s.fst \u2227 s.snd \u2264 t.snd\u27e9", "start": [84, 1], "end": [85, 45], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.le_def", "code": "theorem le_def : s \u2264 t \u2194 t.fst \u2264 s.fst \u2227 s.snd \u2264 t.snd", "start": [87, 1], "end": [88, 10], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.toDualProdHom", "code": "@[simps]\ndef toDualProdHom : NonemptyInterval \u03b1 \u21aao \u03b1\u1d52\u1d48 \u00d7 \u03b1 where\n  toFun := toDualProd\n  inj' := toDualProd_injective\n  map_rel_iff' := Iff.rfl", "start": [91, 1], "end": [96, 26], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.dual", "code": "def dual : NonemptyInterval \u03b1 \u2243 NonemptyInterval \u03b1\u1d52\u1d48 where\n  toFun s := \u27e8s.toProd.swap, s.fst_le_snd\u27e9\n  invFun s := \u27e8s.toProd.swap, s.fst_le_snd\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [99, 1], "end": [104, 21], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_dual", "code": "@[simp]\ntheorem fst_dual (s : NonemptyInterval \u03b1) : s.dual.fst = toDual s.snd", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_dual", "code": "@[simp]\ntheorem snd_dual (s : NonemptyInterval \u03b1) : s.dual.snd = toDual s.fst", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mem_mk", "code": "@[simp]\ntheorem mem_mk {hx : x.1 \u2264 x.2} : a \u2208 mk x hx \u2194 x.1 \u2264 a \u2227 a \u2264 x.2", "start": [133, 1], "end": [135, 10], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mem_def", "code": "theorem mem_def : a \u2208 s \u2194 s.fst \u2264 a \u2227 a \u2264 s.snd", "start": [138, 1], "end": [139, 10], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_nonempty", "code": "theorem coe_nonempty (s : NonemptyInterval \u03b1) : (s : Set \u03b1).Nonempty", "start": [143, 1], "end": [144, 30], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure", "code": "@[simps]\ndef pure (a : \u03b1) : NonemptyInterval \u03b1 :=\n  \u27e8\u27e8a, a\u27e9, le_rfl\u27e9", "start": [147, 1], "end": [150, 19], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mem_pure_self", "code": "theorem mem_pure_self (a : \u03b1) : a \u2208 pure a", "start": [153, 1], "end": [154, 19], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.pure_injective", "code": "theorem pure_injective : Injective (pure : \u03b1 \u2192 NonemptyInterval \u03b1)", "start": [157, 1], "end": [158, 33], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.dual_pure", "code": "@[simp]\ntheorem dual_pure (a : \u03b1) : dual (pure a) = pure (toDual a)", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.map", "code": "@[simps!]\ndef map (f : \u03b1 \u2192o \u03b2) (a : NonemptyInterval \u03b1) : NonemptyInterval \u03b2 :=\n  \u27e8a.toProd.map f f, f.mono a.fst_le_snd\u27e9", "start": [175, 1], "end": [178, 42], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.map_pure", "code": "@[simp]\ntheorem map_pure (f : \u03b1 \u2192o \u03b2) (a : \u03b1) : (pure a).map f = pure (f a)", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) (a : NonemptyInterval \u03b1) :\n    (a.map f).map g = a.map (g.comp f)", "start": [186, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.dual_map", "code": "@[simp]\ntheorem dual_map (f : \u03b1 \u2192o \u03b2) (a : NonemptyInterval \u03b1) :\n    dual (a.map f) = a.dual.map (OrderHom.dual f)", "start": [192, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.map\u2082", "code": "@[simps]\ndef map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h\u2080 : \u2200 b, Monotone fun a => f a b) (h\u2081 : \u2200 a, Monotone (f a)) :\n    NonemptyInterval \u03b1 \u2192 NonemptyInterval \u03b2 \u2192 NonemptyInterval \u03b3 := fun s t =>\n  \u27e8(f s.fst t.fst, f s.snd t.snd), (h\u2080 _ s.fst_le_snd).trans <| h\u2081 _ t.fst_le_snd\u27e9", "start": [198, 1], "end": [202, 83], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.map\u2082_pure", "code": "@[simp]\ntheorem map\u2082_pure (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h\u2080 h\u2081) (a : \u03b1) (b : \u03b2) :\n    map\u2082 f h\u2080 h\u2081 (pure a) (pure b) = pure (f a b)", "start": [205, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.dual_map\u2082", "code": "@[simp]\ntheorem dual_map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h\u2080 h\u2081 s t) :\n    dual (map\u2082 f h\u2080 h\u2081 s t) =\n      map\u2082 (fun a b => toDual <| f (ofDual a) <| ofDual b) (fun _ => (h\u2080 _).dual)\n        (fun _ => (h\u2081 _).dual) (dual s) (dual t)", "start": [211, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.dual_top", "code": "@[simp]\ntheorem dual_top : dual (\u22a4 : NonemptyInterval \u03b1) = \u22a4", "start": [225, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coeHom", "code": "def coeHom : NonemptyInterval \u03b1 \u21aao Set \u03b1 :=\n  OrderEmbedding.ofMapLEIff (fun s => Icc s.fst s.snd) fun s _ => Icc_subset_Icc_iff s.fst_le_snd", "start": [239, 1], "end": [241, 98], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.setLike", "code": "instance setLike : SetLike (NonemptyInterval \u03b1) \u03b1 where\n  coe s := Icc s.fst s.snd\n  coe_injective' := coeHom.injective", "start": [244, 1], "end": [246, 37], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_subset_coe", "code": "@[norm_cast] theorem coe_subset_coe : (s : Set \u03b1) \u2286 t \u2194 (s : NonemptyInterval \u03b1) \u2264 t", "start": [248, 1], "end": [250, 26], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_ssubset_coe", "code": "@[norm_cast] theorem coe_ssubset_coe : (s : Set \u03b1) \u2282 t \u2194 s < t", "start": [253, 1], "end": [255, 26], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_coeHom", "code": "@[simp]\ntheorem coe_coeHom : (coeHom : NonemptyInterval \u03b1 \u2192 Set \u03b1) = ((\u2191) : NonemptyInterval \u03b1 \u2192 Set \u03b1)", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_pure", "code": "@[simp, norm_cast]\ntheorem coe_pure (a : \u03b1) : (pure a : Set \u03b1) = {a}", "start": [263, 1], "end": [265, 13], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mem_pure", "code": "@[simp]\ntheorem mem_pure : b \u2208 pure a \u2194 b = a", "start": [268, 1], "end": [270, 54], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top [BoundedOrder \u03b1] : ((\u22a4 : NonemptyInterval \u03b1) : Set \u03b1) = univ", "start": [273, 1], "end": [275, 14], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_dual", "code": "@[simp, norm_cast]\ntheorem coe_dual (s : NonemptyInterval \u03b1) : (dual s : Set \u03b1\u1d52\u1d48) = ofDual \u207b\u00b9' s", "start": [278, 1], "end": [280, 11], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.subset_coe_map", "code": "theorem subset_coe_map (f : \u03b1 \u2192o \u03b2) (s : NonemptyInterval \u03b1) : f '' s \u2286 s.map f", "start": [283, 1], "end": [284, 60], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.fst_sup", "code": "@[simp]\ntheorem fst_sup (s t : NonemptyInterval \u03b1) : (s \u2294 t).fst = s.fst \u2293 t.fst", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.snd_sup", "code": "@[simp]\ntheorem snd_sup (s t : NonemptyInterval \u03b1) : (s \u2294 t).snd = s.snd \u2294 t.snd", "start": [304, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "Interval", "code": "@[reducible] def Interval (\u03b1 : Type*) [LE \u03b1] :=\n  WithBot (NonemptyInterval \u03b1)", "start": [313, 1], "end": [320, 31], "kind": "commanddeclaration"}, {"full_name": "Interval.canLift", "code": "instance canLift : CanLift (Interval \u03b1) (NonemptyInterval \u03b1) (\u2191) fun r => r \u2260 \u22a5 :=\n  WithBot.canLift", "start": [337, 1], "end": [338, 18], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : NonemptyInterval \u03b1 \u2192 Interval \u03b1)", "start": [341, 1], "end": [342, 24], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_inj", "code": "@[norm_cast] theorem coe_inj {s t : NonemptyInterval \u03b1} : (s : Interval \u03b1) = t \u2194 s = t", "start": [345, 1], "end": [347, 18], "kind": "commanddeclaration"}, {"full_name": "Interval.forall", "code": "protected\ntheorem \u00abforall\u00bb {p : Interval \u03b1 \u2192 Prop} : (\u2200 s, p s) \u2194 p \u22a5 \u2227 \u2200 s : NonemptyInterval \u03b1, p s", "start": [350, 1], "end": [352, 16], "kind": "commanddeclaration"}, {"full_name": "Interval.exists", "code": "protected\ntheorem \u00abexists\u00bb {p : Interval \u03b1 \u2192 Prop} : (\u2203 s, p s) \u2194 p \u22a5 \u2228 \u2203 s : NonemptyInterval \u03b1, p s", "start": [355, 1], "end": [357, 16], "kind": "commanddeclaration"}, {"full_name": "Interval.dual", "code": "def dual : Interval \u03b1 \u2243 Interval \u03b1\u1d52\u1d48 :=\n  NonemptyInterval.dual.optionCongr", "start": [363, 1], "end": [365, 36], "kind": "commanddeclaration"}, {"full_name": "Interval.pure", "code": "def pure (a : \u03b1) : Interval \u03b1 :=\n  NonemptyInterval.pure a", "start": [377, 1], "end": [379, 26], "kind": "commanddeclaration"}, {"full_name": "Interval.pure_injective", "code": "theorem pure_injective : Injective (pure : \u03b1 \u2192 Interval \u03b1)", "start": [382, 1], "end": [383, 53], "kind": "commanddeclaration"}, {"full_name": "Interval.dual_pure", "code": "@[simp]\ntheorem dual_pure (a : \u03b1) : dual (pure a) = pure (toDual a)", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.dual_bot", "code": "@[simp]\ntheorem dual_bot : dual (\u22a5 : Interval \u03b1) = \u22a5", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.pure_ne_bot", "code": "@[simp]\ntheorem pure_ne_bot {a : \u03b1} : pure a \u2260 \u22a5", "start": [396, 1], "end": [398, 21], "kind": "commanddeclaration"}, {"full_name": "Interval.bot_ne_pure", "code": "@[simp]\ntheorem bot_ne_pure {a : \u03b1} : \u22a5 \u2260 pure a", "start": [401, 1], "end": [403, 21], "kind": "commanddeclaration"}, {"full_name": "Interval.map", "code": "def map (f : \u03b1 \u2192o \u03b2) : Interval \u03b1 \u2192 Interval \u03b2 :=\n  WithBot.map (NonemptyInterval.map f)", "start": [409, 1], "end": [411, 39], "kind": "commanddeclaration"}, {"full_name": "Interval.map_pure", "code": "@[simp]\ntheorem map_pure (f : \u03b1 \u2192o \u03b2) (a : \u03b1) : (pure a).map f = pure (f a)", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) (s : Interval \u03b1) : (s.map f).map g = s.map (g.comp f)", "start": [419, 1], "end": [421, 23], "kind": "commanddeclaration"}, {"full_name": "Interval.dual_map", "code": "@[simp]\ntheorem dual_map (f : \u03b1 \u2192o \u03b2) (s : Interval \u03b1) : dual (s.map f) = s.dual.map (OrderHom.dual f)", "start": [424, 1], "end": [428, 33], "kind": "commanddeclaration"}, {"full_name": "Interval.boundedOrder", "code": "instance boundedOrder : BoundedOrder (Interval \u03b1) :=\n  WithBot.instBoundedOrder", "start": [433, 1], "end": [434, 27], "kind": "commanddeclaration"}, {"full_name": "Interval.dual_top", "code": "@[simp]\ntheorem dual_top : dual (\u22a4 : Interval \u03b1) = \u22a4", "start": [436, 1], "end": [438, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.partialOrder", "code": "instance partialOrder : PartialOrder (Interval \u03b1) :=\n  WithBot.partialOrder", "start": [447, 1], "end": [448, 23], "kind": "commanddeclaration"}, {"full_name": "Interval.coeHom", "code": "def coeHom : Interval \u03b1 \u21aao Set \u03b1 :=\n  OrderEmbedding.ofMapLEIff\n    (fun s =>\n      match s with\n      | \u22a5 => \u2205\n      | some s => s)\n    fun s t =>\n    match s, t with\n    | \u22a5, _ => iff_of_true bot_le bot_le\n    | some s, \u22a5 =>\n      iff_of_false (fun h => s.coe_nonempty.ne_empty <| le_bot_iff.1 h) (WithBot.not_coe_le_bot _)\n    | some _, some _ => (@NonemptyInterval.coeHom \u03b1 _).le_iff_le.trans WithBot.some_le_some.symm", "start": [450, 1], "end": [462, 97], "kind": "commanddeclaration"}, {"full_name": "Interval.setLike", "code": "instance setLike : SetLike (Interval \u03b1) \u03b1 where\n  coe := coeHom\n  coe_injective' := coeHom.injective", "start": [465, 1], "end": [467, 37], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_subset_coe", "code": "@[norm_cast] theorem coe_subset_coe : (s : Set \u03b1) \u2286 t \u2194 s \u2264 t", "start": [469, 1], "end": [471, 26], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_sSubset_coe", "code": "@[norm_cast] theorem coe_sSubset_coe : (s : Set \u03b1) \u2282 t \u2194 s < t", "start": [474, 1], "end": [476, 26], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_pure", "code": "@[simp, norm_cast]\ntheorem coe_pure (a : \u03b1) : (pure a : Set \u03b1) = {a}", "start": [479, 1], "end": [481, 13], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe (s : NonemptyInterval \u03b1) : ((s : Interval \u03b1) : Set \u03b1) = s", "start": [484, 1], "end": [486, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : Interval \u03b1) : Set \u03b1) = \u2205", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top [BoundedOrder \u03b1] : ((\u22a4 : Interval \u03b1) : Set \u03b1) = univ", "start": [494, 1], "end": [496, 14], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_dual", "code": "@[simp, norm_cast]\ntheorem coe_dual (s : Interval \u03b1) : (dual s : Set \u03b1\u1d52\u1d48) = ofDual \u207b\u00b9' s", "start": [499, 1], "end": [503, 50], "kind": "commanddeclaration"}, {"full_name": "Interval.subset_coe_map", "code": "theorem subset_coe_map (f : \u03b1 \u2192o \u03b2) : \u2200 s : Interval \u03b1, f '' s \u2286 s.map f", "start": [506, 1], "end": [508, 51], "kind": "commanddeclaration"}, {"full_name": "Interval.mem_pure", "code": "@[simp]\ntheorem mem_pure : b \u2208 pure a \u2194 b = a", "start": [511, 1], "end": [512, 96], "kind": "commanddeclaration"}, {"full_name": "Interval.mem_pure_self", "code": "theorem mem_pure_self (a : \u03b1) : a \u2208 pure a", "start": [515, 1], "end": [516, 17], "kind": "commanddeclaration"}, {"full_name": "Interval.semilatticeSup", "code": "instance semilatticeSup : SemilatticeSup (Interval \u03b1) :=\n  WithBot.semilatticeSup", "start": [525, 1], "end": [526, 25], "kind": "commanddeclaration"}, {"full_name": "Interval.lattice", "code": "instance lattice : Lattice (Interval \u03b1) :=\n  { Interval.semilatticeSup with\n    inf := fun s t =>\n      match s, t with\n      | \u22a5, _ => \u22a5\n      | _, \u22a5 => \u22a5\n      | some s, some t =>\n        if h : s.fst \u2264 t.snd \u2227 t.fst \u2264 s.snd then\n          some\n            \u27e8\u27e8s.fst \u2294 t.fst, s.snd \u2293 t.snd\u27e9,\n              sup_le (le_inf s.fst_le_snd h.1) <| le_inf h.2 t.fst_le_snd\u27e9\n        else \u22a5\n    inf_le_left := fun s t =>\n      match s, t with\n      | \u22a5, \u22a5 => bot_le\n      | \u22a5, some _ => bot_le\n      | some s, \u22a5 => bot_le\n      | some s, some t => by\n        change dite _ _ _ \u2264 _\n        split_ifs\n        \u00b7 exact WithBot.some_le_some.2 \u27e8le_sup_left, inf_le_left\u27e9\n        \u00b7 exact bot_le\n    inf_le_right := fun s t =>\n      match s, t with\n      | \u22a5, \u22a5 => bot_le\n      | \u22a5, some t => bot_le\n      | some _, \u22a5 => bot_le\n      | some s, some t => by\n        change dite _ _ _ \u2264 _\n        split_ifs\n        \u00b7 exact WithBot.some_le_some.2 \u27e8le_sup_right, inf_le_right\u27e9\n        \u00b7 exact bot_le\n    le_inf := fun s t c =>\n      match s, t, c with\n      | \u22a5, t, c => fun _ _ => bot_le\n      | some s, t, c => fun hb hc => by\n        lift t to NonemptyInterval \u03b1 using ne_bot_of_le_ne_bot WithBot.coe_ne_bot hb\n        lift c to NonemptyInterval \u03b1 using ne_bot_of_le_ne_bot WithBot.coe_ne_bot hc\n        change _ \u2264 dite _ _ _\n        rw [WithBot.some_eq_coe, WithBot.coe_le_coe] at hb hc\n        simp only [WithBot.some_eq_coe, WithBot.coe_le_coe] rw [dif_pos, WithBot.coe_le_coe]\n        exact \u27e8sup_le hb.1 hc.1, le_inf hb.2 hc.2\u27e9\n        rcases hb with \u27e8hb\u2081, hb\u2082\u27e9\n        rcases hc with \u27e8hc\u2081, hc\u2082\u27e9\n        change t.toProd.fst \u2264 s.toProd.fst at hb\u2081\n        change s.toProd.snd \u2264 t.toProd.snd at hb\u2082\n        change c.toProd.fst \u2264 s.toProd.fst at hc\u2081\n        change s.toProd.snd \u2264 c.toProd.snd at hc\u2082\n        exact \u27e8hb\u2081.trans <| s.fst_le_snd.trans hc\u2082, hc\u2081.trans <| s.fst_le_snd.trans hb\u2082\u27e9 }", "start": [532, 1], "end": [586, 91], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : Interval \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = \u2191s \u2229 \u2191t", "start": [588, 1], "end": [608, 59], "kind": "commanddeclaration"}, {"full_name": "Interval.disjoint_coe", "code": "@[simp, norm_cast]\ntheorem disjoint_coe (s t : Interval \u03b1) : Disjoint (s : Set \u03b1) t \u2194 Disjoint s t", "start": [613, 1], "end": [617, 8], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_pure_interval", "code": "@[simp, norm_cast]\ntheorem coe_pure_interval (a : \u03b1) : (pure a : Interval \u03b1) = Interval.pure a", "start": [630, 1], "end": [632, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_eq_pure", "code": "@[simp, norm_cast]\ntheorem coe_eq_pure : (s : Interval \u03b1) = Interval.pure a \u2194 s = pure a", "start": [635, 1], "end": [637, 45], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_top_interval", "code": "@[simp, norm_cast]\ntheorem coe_top_interval [BoundedOrder \u03b1] : ((\u22a4 : NonemptyInterval \u03b1) : Interval \u03b1) = \u22a4", "start": [640, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.mem_coe_interval", "code": "@[simp, norm_cast]\ntheorem mem_coe_interval [PartialOrder \u03b1] {s : NonemptyInterval \u03b1} {x : \u03b1} :\n    x \u2208 (s : Interval \u03b1) \u2194 x \u2208 s", "start": [647, 1], "end": [650, 10], "kind": "commanddeclaration"}, {"full_name": "NonemptyInterval.coe_sup_interval", "code": "@[simp, norm_cast]\ntheorem coe_sup_interval [Lattice \u03b1] (s t : NonemptyInterval \u03b1) :\n    (\u2191(s \u2294 t) : Interval \u03b1) = \u2191s \u2294 \u2191t", "start": [653, 1], "end": [656, 6], "kind": "commanddeclaration"}, {"full_name": "Interval.completeLattice", "code": "noncomputable instance completeLattice [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] :\n    CompleteLattice (Interval \u03b1) := by\n  classical\n  exact\n      { Interval.lattice, Interval.boundedOrder with\n        sSup := fun S =>\n          if h : S \u2286 {\u22a5} then \u22a5\n          else\n            some\n              \u27e8\u27e8\u2a05 (s : NonemptyInterval \u03b1) (_ : \u2191s \u2208 S), s.fst,\n                  \u2a06 (s : NonemptyInterval \u03b1) (_ : \u2191s \u2208 S), s.snd\u27e9, by\n                obtain \u27e8s, hs, ha\u27e9 := not_subset.1 h\n                lift s to NonemptyInterval \u03b1 using ha\n                exact iInf\u2082_le_of_le s hs (le_iSup\u2082_of_le s hs s.fst_le_snd)\u27e9\n        le_sSup := fun s s ha => by\n          dsimp only split_ifs with h\n          \u00b7 exact (h ha).le\n          cases s\n          \u00b7 exact bot_le\n          \u00b7 apply WithBot.some_le_some.2\n            constructor\n            \u00b7 apply iInf\u2082_le\n              exact ha\n            \u00b7 exact le_iSup\u2082_of_le _ ha le_rfl\n        sSup_le := fun s s ha => by\n          dsimp only split_ifs with h\n          \u00b7 exact bot_le\n          obtain \u27e8b, hs, hb\u27e9 := not_subset.1 h\n          lift s to NonemptyInterval \u03b1 using ne_bot_of_le_ne_bot hb (ha _ hs)\n          exact\n            WithBot.coe_le_coe.2\n              \u27e8le_iInf\u2082 fun c hc => (WithBot.coe_le_coe.1 <| ha _ hc).1,\n                iSup\u2082_le fun c hc => (WithBot.coe_le_coe.1 <| ha _ hc).2\u27e9\n        sInf := fun S =>\n          if h :\n              \u22a5 \u2209 S \u2227\n                \u2200 \u2983s : NonemptyInterval \u03b1\u2984,\n                  \u2191s \u2208 S \u2192 \u2200 \u2983t : NonemptyInterval \u03b1\u2984, \u2191t \u2208 S \u2192 s.fst \u2264 t.snd then\n            some\n              \u27e8\u27e8\u2a06 (s : NonemptyInterval \u03b1) (_ : \u2191s \u2208 S), s.fst,\n                  \u2a05 (s : NonemptyInterval \u03b1) (_ : \u2191s \u2208 S), s.snd\u27e9,\n                iSup\u2082_le fun s hs => le_iInf\u2082 <| h.2 hs\u27e9\n          else \u22a5\n        sInf_le := fun s\u2081 s ha => by\n          dsimp only split_ifs with h\n          \u00b7 lift s to NonemptyInterval \u03b1 using ne_of_mem_of_not_mem ha h.1\n            let f := fun (s : NonemptyInterval \u03b1) (_ : \u2191s \u2208 s\u2081) => s.toProd.fst\n            exact WithBot.coe_le_coe.2 \u27e8le_iSup\u2082 (f := f) s ha, iInf\u2082_le s ha\u27e9\n          \u00b7 exact bot_le\n        le_sInf := by\n          intro S s ha\n          cases s with\n          | none => exact bot_le\n          | some s =>\n            dsimp split_ifs with h\n            \u00b7 exact WithBot.some_le_some.2\n                \u27e8iSup\u2082_le fun t hb => (WithBot.coe_le_coe.1 <| ha _ hb).1,\n                  le_iInf\u2082 fun t hb => (WithBot.coe_le_coe.1 <| ha _ hb).2\u27e9\n            \u00b7 rw [not_and_or, not_not] at h\n              rcases h with h | h\n              \u00b7 exact ha _ h\n              \u00b7 exfalso\n                apply h\n                intro b hb c hc\n                have h\u2081 := (WithBot.coe_le_coe.1 <| ha _ hb).1\n                repeat rw [NonemptyInterval.toDualProd_apply] at h\u2081\n                rw [OrderDual.toDual_le_toDual] at h\u2081\n                exact h\u2081.trans (s.fst_le_snd.trans (WithBot.coe_le_coe.1 <| ha _ hc).2)\n  }", "start": [667, 1], "end": [749, 4], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (S : Set (Interval \u03b1)) :\n    \u2191(sInf S) = \u22c2 s \u2208 S, (s : Set \u03b1)", "start": [751, 1], "end": [768, 59], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (f : \u03b9 \u2192 Interval \u03b1) :\n    \u2191(\u2a05 i, f i) = \u22c2 i, (f i : Set \u03b1)", "start": [771, 1], "end": [773, 55], "kind": "commanddeclaration"}, {"full_name": "Interval.coe_iInf\u2082", "code": "@[norm_cast]\ntheorem coe_iInf\u2082 [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (f : \u2200 i, \u03ba i \u2192 Interval \u03b1) :\n    \u2191(\u2a05 (i) (j), f i j) = \u22c2 (i) (j), (f i j : Set \u03b1)", "start": [777, 1], "end": [779, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/FilterProduct.lean", "imports": ["Mathlib/Order/Filter/Ultrafilter.lean", "Mathlib/Order/Filter/Germ.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.Germ.groupWithZero", "code": "instance groupWithZero [GroupWithZero \u03b2] : GroupWithZero \u03b2* :=\n  { Germ.divInvMonoid, Germ.monoidWithZero with\n    mul_inv_cancel := fun f => inductionOn f fun f hf => coe_eq.2 <|\n      (\u03c6.em fun y => f y = 0).elim (fun H => (hf <| coe_eq.2 H).elim) fun H =>\n        H.mono fun x => mul_inv_cancel\n    inv_zero := coe_eq.2 <| by\n       simp only [Function.comp, inv_zero]\n       exact EventuallyEq.refl _ fun _ => 0 }", "start": [40, 1], "end": [47, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.divisionSemiring", "code": "instance divisionSemiring [DivisionSemiring \u03b2] : DivisionSemiring \u03b2* where\n  toSemiring := Germ.semiring\n  __ := Germ.groupWithZero", "start": [49, 1], "end": [51, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.divisionRing", "code": "instance divisionRing [DivisionRing \u03b2] : DivisionRing \u03b2* :=\n  { Germ.ring, Germ.divisionSemiring with }", "start": [53, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.semifield", "code": "instance semifield [Semifield \u03b2] : Semifield \u03b2* :=\n  { Germ.commSemiring, Germ.divisionSemiring with }", "start": [56, 1], "end": [57, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.field", "code": "instance field [Field \u03b2] : Field \u03b2* :=\n  { Germ.commRing, Germ.divisionRing with }", "start": [59, 1], "end": [60, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_lt", "code": "theorem coe_lt [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} : (f : \u03b2*) < g \u2194 \u2200* x, f x < g x", "start": [62, 1], "end": [63, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.coe_pos", "code": "theorem coe_pos [Preorder \u03b2] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} : 0 < (f : \u03b2*) \u2194 \u2200* x, 0 < f x", "start": [66, 1], "end": [67, 9], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_lt", "code": "theorem const_lt [Preorder \u03b2] {x y : \u03b2} : x < y \u2192 (\u2191x : \u03b2*) < \u2191y", "start": [70, 1], "end": [71, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_lt_iff", "code": "@[simp, norm_cast]\ntheorem const_lt_iff [Preorder \u03b2] {x y : \u03b2} : (\u2191x : \u03b2*) < \u2191y \u2194 x < y", "start": [74, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.lt_def", "code": "theorem lt_def [Preorder \u03b2] : ((\u00b7 < \u00b7) : \u03b2* \u2192 \u03b2* \u2192 Prop) = LiftRel (\u00b7 < \u00b7)", "start": [79, 1], "end": [81, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.isTotal", "code": "instance isTotal [LE \u03b2] [IsTotal \u03b2 (\u00b7 \u2264 \u00b7)] : IsTotal \u03b2* (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun f g =>\n    inductionOn\u2082 f g fun _f _g => eventually_or.1 <| eventually_of_forall fun _x => total_of _ _ _\u27e9", "start": [84, 1], "end": [86, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.linearOrder", "code": "noncomputable instance linearOrder [LinearOrder \u03b2] : LinearOrder \u03b2* :=\n  Lattice.toLinearOrder _", "start": [88, 1], "end": [90, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.linearOrderedCommGroup", "code": "@[to_additive]\nnoncomputable instance linearOrderedCommGroup [LinearOrderedCommGroup \u03b2] :\n    LinearOrderedCommGroup \u03b2* :=\n  { Germ.orderedCommGroup, Germ.linearOrder with }", "start": [92, 1], "end": [95, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.strictOrderedSemiring", "code": "instance strictOrderedSemiring [StrictOrderedSemiring \u03b2] : StrictOrderedSemiring \u03b2* :=\n  { Germ.orderedSemiring, Germ.orderedAddCancelCommMonoid,\n    Germ.nontrivial with\n    mul_lt_mul_of_pos_left := fun x y z =>\n      inductionOn\u2083 x y z fun _f _g _h hfg hh =>\n        coe_lt.2 <| (coe_lt.1 hh).mp <| (coe_lt.1 hfg).mono fun _a => mul_lt_mul_of_pos_left\n    mul_lt_mul_of_pos_right := fun x y z =>\n      inductionOn\u2083 x y z fun _f _g _h hfg hh =>\n        coe_lt.2 <| (coe_lt.1 hh).mp <| (coe_lt.1 hfg).mono fun _a => mul_lt_mul_of_pos_right }", "start": [97, 1], "end": [105, 96], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.strictOrderedCommSemiring", "code": "instance strictOrderedCommSemiring [StrictOrderedCommSemiring \u03b2] : StrictOrderedCommSemiring \u03b2* :=\n  { Germ.strictOrderedSemiring, Germ.orderedCommSemiring with }", "start": [107, 1], "end": [108, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.strictOrderedRing", "code": "instance strictOrderedRing [StrictOrderedRing \u03b2] : StrictOrderedRing \u03b2* :=\n  { Germ.ring,\n    Germ.strictOrderedSemiring with\n    zero_le_one := const_le zero_le_one\n    mul_pos := fun x y =>\n      inductionOn\u2082 x y fun _f _g hf hg =>\n        coe_pos.2 <| (coe_pos.1 hg).mp <| (coe_pos.1 hf).mono fun _x => mul_pos }", "start": [110, 1], "end": [116, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.strictOrderedCommRing", "code": "instance strictOrderedCommRing [StrictOrderedCommRing \u03b2] : StrictOrderedCommRing \u03b2* :=\n  { Germ.strictOrderedRing, Germ.orderedCommRing with }", "start": [118, 1], "end": [119, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.linearOrderedRing", "code": "noncomputable instance linearOrderedRing [LinearOrderedRing \u03b2] : LinearOrderedRing \u03b2* :=\n  { Germ.strictOrderedRing, Germ.linearOrder with }", "start": [121, 1], "end": [122, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.linearOrderedField", "code": "noncomputable instance linearOrderedField [LinearOrderedField \u03b2] : LinearOrderedField \u03b2* :=\n  { Germ.linearOrderedRing, Germ.field with }", "start": [124, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.linearOrderedCommRing", "code": "noncomputable instance linearOrderedCommRing [LinearOrderedCommRing \u03b2] : LinearOrderedCommRing \u03b2* :=\n  { Germ.linearOrderedRing, Germ.commMonoid with }", "start": [127, 1], "end": [128, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.max_def", "code": "theorem max_def [LinearOrder \u03b2] (x y : \u03b2*) : max x y = map\u2082 max x y", "start": [130, 1], "end": [136, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.min_def", "code": "theorem min_def [K : LinearOrder \u03b2] (x y : \u03b2*) : min x y = map\u2082 min x y", "start": [139, 1], "end": [145, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.abs_def", "code": "theorem abs_def [LinearOrderedAddCommGroup \u03b2] (x : \u03b2*) : |x| = map abs x", "start": [148, 1], "end": [149, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_max", "code": "@[simp]\ntheorem const_max [LinearOrder \u03b2] (x y : \u03b2) : (\u2191(max x y : \u03b2) : \u03b2*) = max \u2191x \u2191y", "start": [152, 1], "end": [154, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_min", "code": "@[simp]\ntheorem const_min [LinearOrder \u03b2] (x y : \u03b2) : (\u2191(min x y : \u03b2) : \u03b2*) = min \u2191x \u2191y", "start": [157, 1], "end": [159, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Germ.const_abs", "code": "@[simp]\ntheorem const_abs [LinearOrderedAddCommGroup \u03b2] (x : \u03b2) : (\u2191|x| : \u03b2*) = |\u2191x|", "start": [162, 1], "end": [164, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GradedMulAction.lean", "imports": ["Mathlib/Algebra/GradedMonoid.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GradedMonoid.GSmul", "code": "class GSmul [VAdd \u03b9A \u03b9M] where\n  \n  smul {i j} : A i \u2192 M j \u2192 M (i +\u1d65 j)", "start": [61, 1], "end": [65, 38], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.GMul.toGSmul", "code": "instance GMul.toGSmul [Add \u03b9A] [GMul A] : GSmul A A where smul := GMul.mul", "start": [68, 1], "end": [69, 75], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.GSmul.toSMul", "code": "instance GSmul.toSMul [VAdd \u03b9A \u03b9M] [GSmul A M] : SMul (GradedMonoid A) (GradedMonoid M) :=\n  \u27e8fun x y \u21a6 \u27e8_, GSmul.smul x.snd y.snd\u27e9\u27e9", "start": [72, 1], "end": [73, 42], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.mk_smul_mk", "code": "theorem mk_smul_mk [VAdd \u03b9A \u03b9M] [GSmul A M] {i j} (a : A i) (b : M j) :\n    mk i a \u2022 mk j b = mk (i +\u1d65 j) (GSmul.smul a b)", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.GMulAction", "code": "class GMulAction [AddMonoid \u03b9A] [VAdd \u03b9A \u03b9M] [GMonoid A] extends GSmul A M where\n  \n  one_smul (b : GradedMonoid M) : (1 : GradedMonoid A) \u2022 b = b\n  \n  mul_smul (a a' : GradedMonoid A) (b : GradedMonoid M) : (a * a') \u2022 b = a \u2022 a' \u2022 b", "start": [81, 1], "end": [86, 84], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.GMonoid.toGMulAction", "code": "instance GMonoid.toGMulAction [AddMonoid \u03b9A] [GMonoid A] : GMulAction A A :=\n  { GMul.toGSmul _ with\n    one_smul := GMonoid.one_mul\n    mul_smul := GMonoid.mul_assoc }", "start": [89, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "GradedMonoid.GMulAction.toMulAction", "code": "instance GMulAction.toMulAction [AddMonoid \u03b9A] [GMonoid A] [VAdd \u03b9A \u03b9M] [GMulAction A M] :\n    MulAction (GradedMonoid A) (GradedMonoid M)\n    where\n  one_smul := GMulAction.one_smul\n  mul_smul := GMulAction.mul_smul", "start": [96, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "SetLike.GradedSmul", "code": "class SetLike.GradedSmul {S R N M : Type*} [SetLike S R] [SetLike N M] [SMul R M] [VAdd \u03b9A \u03b9B]\n  (A : \u03b9A \u2192 S) (B : \u03b9B \u2192 N) : Prop where\n  \n  smul_mem : \u2200 \u2983i : \u03b9A\u2984 \u2983j : \u03b9B\u2984 {ai bj}, ai \u2208 A i \u2192 bj \u2208 B j \u2192 ai \u2022 bj \u2208 B (i +\u1d65 j)", "start": [114, 1], "end": [118, 85], "kind": "commanddeclaration"}, {"full_name": "SetLike.toGSmul", "code": "instance SetLike.toGSmul {S R N M : Type*} [SetLike S R] [SetLike N M] [SMul R M] [VAdd \u03b9A \u03b9B]\n    (A : \u03b9A \u2192 S) (B : \u03b9B \u2192 N) [SetLike.GradedSmul A B] :\n    GradedMonoid.GSmul (fun i \u21a6 A i) fun i \u21a6 B i where\n  smul a b := \u27e8a.1 \u2022 b.1, SetLike.GradedSmul.smul_mem a.2 b.2\u27e9", "start": [121, 1], "end": [124, 63], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_GSmul", "code": "@[simp,nolint simpNF]\ntheorem SetLike.coe_GSmul {S R N M : Type*} [SetLike S R] [SetLike N M] [SMul R M] [VAdd \u03b9A \u03b9B]\n    (A : \u03b9A \u2192 S) (B : \u03b9B \u2192 N) [SetLike.GradedSmul A B] {i : \u03b9A} {j : \u03b9B} (x : A i) (y : B j) :\n    (@GradedMonoid.GSmul.smul \u03b9A \u03b9B (fun i \u21a6 A i) (fun i \u21a6 B i) _ _ i j x y : M) = x.1 \u2022 y.1", "start": [135, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.GradedMul.toGradedSmul", "code": "instance SetLike.GradedMul.toGradedSmul [AddMonoid \u03b9A] [Monoid R] {S : Type*} [SetLike S R]\n    (A : \u03b9A \u2192 S) [SetLike.GradedMonoid A] : SetLike.GradedSmul A A where\n  smul_mem _ _ _ _ hi hj := SetLike.GradedMonoid.toGradedMul.mul_mem hi hj", "start": [142, 1], "end": [145, 75], "kind": "commanddeclaration"}, {"full_name": "SetLike.Homogeneous.graded_smul", "code": "theorem SetLike.Homogeneous.graded_smul [VAdd \u03b9A \u03b9B] [SMul R M] {A : \u03b9A \u2192 S} {B : \u03b9B \u2192 N}\n    [SetLike.GradedSmul A B] {a : R} {b : M} :\n    SetLike.Homogeneous A a \u2192 SetLike.Homogeneous B b \u2192 SetLike.Homogeneous B (a \u2022 b)", "start": [154, 1], "end": [157, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/Star/Unitization.lean", "imports": ["Mathlib/Analysis/NormedSpace/Unitization.lean", "Mathlib/Analysis/NormedSpace/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousLinearMap.op_norm_mul_flip_apply", "code": "lemma op_norm_mul_flip_apply (a : E) : \u2016(mul \ud835\udd5c E).flip a\u2016 = \u2016a\u2016 := by\n  refine le_antisymm\n    (op_norm_le_bound _ (norm_nonneg _) fun b => by simpa only [mul_comm] using norm_mul_le b a) ?_\n  suffices \u2016mul \ud835\udd5c E (star a)\u2016 \u2264 \u2016(mul \ud835\udd5c E).flip a\u2016 by simpa using this\n  refine op_norm_le_bound _ (norm_nonneg _) fun b => ?_\n  calc \u2016mul \ud835\udd5c E (star a) b\u2016 = \u2016(mul \ud835\udd5c E).flip a (star b)\u2016 := by simpa using norm_star (star b * a)\n    _ \u2264 \u2016(mul \ud835\udd5c E).flip a\u2016 * \u2016b\u2016 := by simpa using le_op_norm ((mul \ud835\udd5c E).flip a) (star b)", "start": [32, 1], "end": [38, 90], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearMap.op_nnnorm_mul_flip_apply", "code": "lemma op_nnnorm_mul_flip_apply (a : E) : \u2016(mul \ud835\udd5c E).flip a\u2016\u208a = \u2016a\u2016\u208a :=\n  Subtype.ext (op_norm_mul_flip_apply \ud835\udd5c a)", "start": [40, 1], "end": [41, 43], "kind": "mathlibtacticlemma"}, {"full_name": "ContinuousLinearMap.isometry_mul_flip", "code": "lemma isometry_mul_flip : Isometry (mul \ud835\udd5c E).flip :=\n  AddMonoidHomClass.isometry_of_norm _ (op_norm_mul_flip_apply \ud835\udd5c)", "start": [45, 1], "end": [46, 66], "kind": "mathlibtacticlemma"}, {"full_name": "CstarRing.instRegularNormedAlgebra", "code": "instance CstarRing.instRegularNormedAlgebra : RegularNormedAlgebra \ud835\udd5c E where\n  isometry_mul' := AddMonoidHomClass.isometry_of_norm (mul \ud835\udd5c E) fun a => NNReal.eq_iff.mpr <|\n    show \u2016mul \ud835\udd5c E a\u2016\u208a = \u2016a\u2016\u208a by\n    rw [\u2190 sSup_closed_unit_ball_eq_nnnorm]\n    refine' csSup_eq_of_forall_le_of_forall_lt_exists_gt _ _ fun r hr => _\n    \u00b7 exact (Metric.nonempty_closedBall.mpr zero_le_one).image _\n    \u00b7 rintro - \u27e8x, hx, rfl\u27e9\n      exact\n        ((mul \ud835\udd5c E a).unit_le_op_norm x <| mem_closedBall_zero_iff.mp hx).trans\n          (op_norm_mul_apply_le \ud835\udd5c E a)\n    \u00b7 have ha : 0 < \u2016a\u2016\u208a := zero_le'.trans_lt hr\n      rw [\u2190 inv_inv \u2016a\u2016\u208a, NNReal.lt_inv_iff_mul_lt (inv_ne_zero ha.ne')] at hr\n      obtain \u27e8k, hk\u2081, hk\u2082\u27e9 :=\n        NormedField.exists_lt_nnnorm_lt \ud835\udd5c (mul_lt_mul_of_pos_right hr <| inv_pos.2 ha)\n      refine' \u27e8_, \u27e8k \u2022 star a, _, rfl\u27e9, _\u27e9\n      \u00b7 simpa only [mem_closedBall_zero_iff, norm_smul, one_mul, norm_star] using\n          (NNReal.le_inv_iff_mul_le ha.ne').1 (one_mul \u2016a\u2016\u208a\u207b\u00b9 \u25b8 hk\u2082.le : \u2016k\u2016\u208a \u2264 \u2016a\u2016\u208a\u207b\u00b9)\n      \u00b7 simp only [map_smul, nnnorm_smul, mul_apply', mul_smul_comm, CstarRing.nnnorm_self_mul_star]\n        rwa [\u2190 NNReal.div_lt_iff (mul_pos ha ha).ne', div_eq_mul_inv, mul_inv, \u2190 mul_assoc]", "start": [55, 1], "end": [74, 92], "kind": "commanddeclaration"}, {"full_name": "Unitization.norm_splitMul_snd_sq", "code": "theorem Unitization.norm_splitMul_snd_sq (x : Unitization \ud835\udd5c E) :\n    \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016 ^ 2 \u2264 \u2016(Unitization.splitMul \ud835\udd5c E (star x * x)).snd\u2016", "start": [82, 1], "end": [122, 83], "kind": "commanddeclaration"}, {"full_name": "Unitization.instCstarRing", "code": "instance Unitization.instCstarRing : CstarRing (Unitization \ud835\udd5c E) where\n  norm_star_mul_self {x} := by\n    simp only [Unitization.norm_def, Prod.norm_def, \u2190 sup_eq_max]\n    have h\u2081 : \u2200 x : Unitization \ud835\udd5c E,\n        \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016 \u2264 \u2016(Unitization.splitMul \ud835\udd5c E (star x)).snd\u2016 := by\n      simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star, Unitization.fst_star]\n      intro x\n      \n      by_cases h : algebraMap \ud835\udd5c (E \u2192L[\ud835\udd5c] E) x.fst + mul \ud835\udd5c E x.snd = 0\n      \u00b7 simp only [h, norm_zero, norm_le_zero_iff]\n        exact norm_nonneg _\n      \u00b7 have : \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016 ^ 2 \u2264\n          \u2016(Unitization.splitMul \ud835\udd5c E (star x)).snd\u2016 * \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016 :=\n          (norm_splitMul_snd_sq \ud835\udd5c x).trans <| by\n            rw [map_mul, Prod.snd_mul]\n            exact norm_mul_le _ _\n        rw [sq] at this\n        rw [\u2190 Ne.def, \u2190 norm_pos_iff] at h\n        simp only [add_zero, Unitization.splitMul_apply, Unitization.snd_star,\n          Unitization.fst_star, star_star] at this\n        exact (mul_le_mul_right h).mp this\n    have h\u2082 : \u2016(Unitization.splitMul \ud835\udd5c E (star x * x)).snd\u2016\n        = \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016 ^ 2 := by\n      refine le_antisymm ?_ (norm_splitMul_snd_sq \ud835\udd5c x)\n      rw [map_mul, Prod.snd_mul]\n      exact (norm_mul_le _ _).trans <| by\n        rw [sq]\n        gcongr\n        simpa only [star_star] using h\u2081 (star x)\n    have h\u2083 : \u2016(Unitization.splitMul \ud835\udd5c E (star x * x)).fst\u2016\n        = \u2016(Unitization.splitMul \ud835\udd5c E x).fst\u2016 ^ 2 := by\n      simp only [Unitization.splitMul_apply, Unitization.fst_mul, Unitization.fst_star, add_zero,\n        norm_mul, norm_star, sq]\n    rw [h\u2082, h\u2083]\n    \n    by_cases h : \u2016(Unitization.splitMul \ud835\udd5c E x).fst\u2016 \u2264 \u2016(Unitization.splitMul \ud835\udd5c E x).snd\u2016\n    \u00b7 rw [sq, sq, sup_eq_right.mpr h, sup_eq_right.mpr (mul_self_le_mul_self (norm_nonneg _) h)]\n    \u00b7 replace h := (not_le.mp h).le\n      rw [sq, sq, sup_eq_left.mpr h, sup_eq_left.mpr (mul_self_le_mul_self (norm_nonneg _) h)]", "start": [126, 1], "end": [171, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Regularity/Increment.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Regularity/Chunk.lean", "Mathlib/Combinatorics/SimpleGraph/Regularity/Energy.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SzemerediRegularity.increment", "code": "noncomputable def increment : Finpartition (univ : Finset \u03b1) :=\n  P.bind fun _ => chunk hP G \u03b5", "start": [53, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.card_increment", "code": "theorem card_increment (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hPG : \u00acP.IsUniform G \u03b5) :\n    (increment hP G \u03b5).parts.card = stepBound P.parts.card", "start": [67, 1], "end": [80, 60], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.increment_isEquipartition", "code": "theorem increment_isEquipartition (hP : P.IsEquipartition) (G : SimpleGraph \u03b1) (\u03b5 : \u211d) :\n    (increment hP G \u03b5).IsEquipartition", "start": [83, 1], "end": [89, 38], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.distinct_pairs_increment", "code": "private theorem distinct_pairs_increment :\n    (P.parts.offDiag.attach.biUnion fun UV =>\n      (chunk hP G \u03b5 (mem_offDiag.1 UV.2).1).parts \u00d7\u02e2\n      (chunk hP G \u03b5 (mem_offDiag.1 UV.2).2.1).parts) \u2286\n    (increment hP G \u03b5).parts.offDiag", "start": [92, 1], "end": [105, 30], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.pairContrib", "code": "private noncomputable def pairContrib (G : SimpleGraph \u03b1) (\u03b5 : \u211d) (hP : P.IsEquipartition)\n    (x : { x // x \u2208 P.parts.offDiag }) : \u211a :=\n  \u2211 i in (chunk hP G \u03b5 (mem_offDiag.1 x.2).1).parts \u00d7\u02e2 (chunk hP G \u03b5 (mem_offDiag.1 x.2).2.1).parts,\n    (G.edgeDensity i.fst i.snd : \u211a) ^ 2", "start": [107, 1], "end": [111, 40], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.offDiag_pairs_le_increment_energy", "code": "theorem offDiag_pairs_le_increment_energy :\n    \u2211 x in P.parts.offDiag.attach, pairContrib G \u03b5 hP x / ((increment hP G \u03b5).parts.card : \u211a) ^ 2 \u2264\n    (increment hP G \u03b5).energy G", "start": [113, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.pairContrib_lower_bound", "code": "theorem pairContrib_lower_bound [Nonempty \u03b1] (x : { i // i \u2208 P.parts.offDiag }) (h\u03b5\u2081 : \u03b5 \u2264 1)\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5) :\n    ((G.edgeDensity x.1.1 x.1.2 : \u211d) ^ 2 - \u03b5 ^ 5 / \u219125 +\n      if G.IsUniform \u03b5 x.1.1 x.1.2 then (0 : \u211d) else \u03b5 ^ 4 / 3) \u2264\n    pairContrib G \u03b5 hP x / \u219116 ^ P.parts.card", "start": [133, 1], "end": [143, 78], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.uniform_add_nonuniform_eq_offDiag_pairs", "code": "theorem uniform_add_nonuniform_eq_offDiag_pairs [Nonempty \u03b1] (h\u03b5\u2081 : \u03b5 \u2264 1) (hP\u2087 : 7 \u2264 P.parts.card)\n    (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1) (hP\u03b5 : \u2191100 \u2264 \u21914 ^ P.parts.card * \u03b5 ^ 5)\n    (hPG : \u00acP.IsUniform G \u03b5) :\n    (\u2211 x in P.parts.offDiag, (G.edgeDensity x.1 x.2 : \u211d) ^ 2 +\n      \u2191P.parts.card ^ 2 * (\u03b5 ^ 5 / 4) : \u211d) / (P.parts.card : \u211d) ^ 2 \u2264\n    \u2211 x in P.parts.offDiag.attach,\n      (pairContrib G \u03b5 hP x : \u211d) / ((increment hP G \u03b5).parts.card : \u211d) ^ 2", "start": [146, 1], "end": [185, 72], "kind": "commanddeclaration"}, {"full_name": "SzemerediRegularity.energy_increment", "code": "theorem energy_increment [Nonempty \u03b1] (hP : P.IsEquipartition) (hP\u2087 : 7 \u2264 P.parts.card)\n    (h\u03b5 : \u2191100 < \u21914 ^ P.parts.card * \u03b5 ^ 5) (hP\u03b1 : P.parts.card * 16 ^ P.parts.card \u2264 card \u03b1)\n    (hPG : \u00acP.IsUniform G \u03b5) (h\u03b5\u2081 : \u03b5 \u2264 1) :\n    \u2191(P.energy G) + \u03b5 ^ 5 / 4 \u2264 (increment hP G \u03b5).energy G", "start": [188, 1], "end": [197, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Lie/SkewAdjoint.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/BilinearForm.lean", "Mathlib/Algebra/Lie/Matrix.lean", "Mathlib/Tactic/NoncommRing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BilinForm.isSkewAdjoint_bracket", "code": "theorem BilinForm.isSkewAdjoint_bracket {f g : Module.End R M} (hf : f \u2208 B.skewAdjointSubmodule)\n    (hg : g \u2208 B.skewAdjointSubmodule) : \u2045f, g\u2046 \u2208 B.skewAdjointSubmodule", "start": [47, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "skewAdjointLieSubalgebra", "code": "def skewAdjointLieSubalgebra : LieSubalgebra R (Module.End R M) :=\n  { B.skewAdjointSubmodule with\n    lie_mem' := B.isSkewAdjoint_bracket }", "start": [56, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "skewAdjointLieSubalgebraEquiv", "code": "def skewAdjointLieSubalgebraEquiv :\n    skewAdjointLieSubalgebra (B.comp (\u2191e : N \u2192\u2097[R] M) \u2191e) \u2243\u2097\u2045R\u2046 skewAdjointLieSubalgebra B := by\n  apply LieEquiv.ofSubalgebras _ _ e.lieConj\n  ext f\n  simp only [LieSubalgebra.mem_coe, Submodule.mem_map_equiv, LieSubalgebra.mem_map_submodule,\n    LinearEquiv.coe_coe]\n  exact (BilinForm.isPairSelfAdjoint_equiv (-B) B e f).symm", "start": [65, 1], "end": [73, 60], "kind": "commanddeclaration"}, {"full_name": "skewAdjointLieSubalgebraEquiv_apply", "code": "@[simp]\ntheorem skewAdjointLieSubalgebraEquiv_apply (f : skewAdjointLieSubalgebra (B.comp \u2191e \u2191e)) :\n    \u2191(skewAdjointLieSubalgebraEquiv B e f) = e.lieConj f", "start": [76, 1], "end": [79, 39], "kind": "commanddeclaration"}, {"full_name": "skewAdjointLieSubalgebraEquiv_symm_apply", "code": "@[simp]\ntheorem skewAdjointLieSubalgebraEquiv_symm_apply (f : skewAdjointLieSubalgebra B) :\n    \u2191((skewAdjointLieSubalgebraEquiv B e).symm f) = e.symm.lieConj f", "start": [82, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.lie_transpose", "code": "theorem Matrix.lie_transpose (A B : Matrix n n R) : \u2045A, B\u2046\u1d40 = \u2045B\u1d40, A\u1d40\u2046", "start": [98, 1], "end": [99, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.isSkewAdjoint_bracket", "code": "theorem Matrix.isSkewAdjoint_bracket {A B : Matrix n n R} (hA : A \u2208 skewAdjointMatricesSubmodule J)\n    (hB : B \u2208 skewAdjointMatricesSubmodule J) : \u2045A, B\u2046 \u2208 skewAdjointMatricesSubmodule J", "start": [103, 1], "end": [112, 15], "kind": "commanddeclaration"}, {"full_name": "skewAdjointMatricesLieSubalgebra", "code": "def skewAdjointMatricesLieSubalgebra : LieSubalgebra R (Matrix n n R) :=\n  { skewAdjointMatricesSubmodule J with\n    lie_mem' := J.isSkewAdjoint_bracket }", "start": [115, 1], "end": [118, 42], "kind": "commanddeclaration"}, {"full_name": "mem_skewAdjointMatricesLieSubalgebra", "code": "@[simp]\ntheorem mem_skewAdjointMatricesLieSubalgebra (A : Matrix n n R) :\n    A \u2208 skewAdjointMatricesLieSubalgebra J \u2194 A \u2208 skewAdjointMatricesSubmodule J", "start": [121, 1], "end": [124, 10], "kind": "commanddeclaration"}, {"full_name": "skewAdjointMatricesLieSubalgebraEquiv", "code": "def skewAdjointMatricesLieSubalgebraEquiv (P : Matrix n n R) (h : Invertible P) :\n    skewAdjointMatricesLieSubalgebra J \u2243\u2097\u2045R\u2046 skewAdjointMatricesLieSubalgebra (P\u1d40 * J * P) :=\n  LieEquiv.ofSubalgebras _ _ (P.lieConj h).symm <| by\n    ext A\n    suffices P.lieConj h A \u2208 skewAdjointMatricesSubmodule J \u2194\n        A \u2208 skewAdjointMatricesSubmodule (P\u1d40 * J * P) by\n      simp only [LieSubalgebra.mem_coe, Submodule.mem_map_equiv, LieSubalgebra.mem_map_submodule,\n        LinearEquiv.coe_coe]\n      exact this\n    simp [Matrix.IsSkewAdjoint, J.isAdjointPair_equiv' _ _ P (isUnit_of_invertible P)]", "start": [127, 1], "end": [138, 87], "kind": "commanddeclaration"}, {"full_name": "skewAdjointMatricesLieSubalgebraEquiv_apply", "code": "theorem skewAdjointMatricesLieSubalgebraEquiv_apply (P : Matrix n n R) (h : Invertible P)\n    (A : skewAdjointMatricesLieSubalgebra J) :\n    \u2191(skewAdjointMatricesLieSubalgebraEquiv J P h A) = P\u207b\u00b9 * (A : Matrix n n R) * P", "start": [142, 1], "end": [145, 47], "kind": "commanddeclaration"}, {"full_name": "skewAdjointMatricesLieSubalgebraEquivTranspose", "code": "def skewAdjointMatricesLieSubalgebraEquivTranspose {m : Type w} [DecidableEq m] [Fintype m]\n    (e : Matrix n n R \u2243\u2090[R] Matrix m m R) (h : \u2200 A, (e A)\u1d40 = e A\u1d40) :\n    skewAdjointMatricesLieSubalgebra J \u2243\u2097\u2045R\u2046 skewAdjointMatricesLieSubalgebra (e J) :=\n  LieEquiv.ofSubalgebras _ _ e.toLieEquiv <| by\n    ext A\n    suffices J.IsSkewAdjoint (e.symm A) \u2194 (e J).IsSkewAdjoint A by\n      simpa [- LieSubalgebra.mem_map, LieSubalgebra.mem_map_submodule]\n    simp only [Matrix.IsSkewAdjoint, Matrix.IsAdjointPair, \u2190 h,\n      \u2190 Function.Injective.eq_iff e.injective, map_mul, AlgEquiv.apply_symm_apply, map_neg]", "start": [148, 1], "end": [159, 92], "kind": "commanddeclaration"}, {"full_name": "skewAdjointMatricesLieSubalgebraEquivTranspose_apply", "code": "@[simp]\ntheorem skewAdjointMatricesLieSubalgebraEquivTranspose_apply {m : Type w} [DecidableEq m]\n    [Fintype m] (e : Matrix n n R \u2243\u2090[R] Matrix m m R) (h : \u2200 A, (e A)\u1d40 = e A\u1d40)\n    (A : skewAdjointMatricesLieSubalgebra J) :\n    (skewAdjointMatricesLieSubalgebraEquivTranspose J e h A : Matrix m m R) = e A", "start": [162, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "mem_skewAdjointMatricesLieSubalgebra_unit_smul", "code": "theorem mem_skewAdjointMatricesLieSubalgebra_unit_smul (u : R\u02e3) (J A : Matrix n n R) :\n    A \u2208 skewAdjointMatricesLieSubalgebra (u \u2022 J) \u2194 A \u2208 skewAdjointMatricesLieSubalgebra J", "start": [170, 1], "end": [176, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/SymplecticGroup.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.J", "code": "def J : Matrix (Sum l l) (Sum l l) R :=\n  Matrix.fromBlocks 0 (-1) 1 0", "start": [36, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.J_transpose", "code": "@[simp]\ntheorem J_transpose : (J l R)\u1d40 = -J l R", "start": [42, 1], "end": [46, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.J_squared", "code": "theorem J_squared : J l R * J l R = -1", "start": [52, 1], "end": [55, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.J_inv", "code": "theorem J_inv : (J l R)\u207b\u00b9 = -J l R", "start": [59, 1], "end": [62, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.J_det_mul_J_det", "code": "theorem J_det_mul_J_det : det (J l R) * det (J l R) = 1", "start": [66, 1], "end": [70, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.isUnit_det_J", "code": "theorem isUnit_det_J : IsUnit (det (J l R))", "start": [74, 1], "end": [75, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.symplecticGroup", "code": "def symplecticGroup : Submonoid (Matrix (Sum l l) (Sum l l) R) where\n  carrier := { A | A * J l R * A\u1d40 = J l R }\n  mul_mem' {a b} ha hb := by\n    simp only [Set.mem_setOf_eq, transpose_mul] at *\n    rw [\u2190 Matrix.mul_assoc, a.mul_assoc, a.mul_assoc, hb]\n    exact ha\n  one_mem' := by simp", "start": [83, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.mem_iff", "code": "theorem mem_iff {A : Matrix (Sum l l) (Sum l l) R} :\n    A \u2208 symplecticGroup l R \u2194 A * J l R * A\u1d40 = J l R", "start": [101, 1], "end": [102, 82], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.coeMatrix", "code": "instance coeMatrix : Coe (symplecticGroup l R) (Matrix (Sum l l) (Sum l l) R) :=\n  \u27e8Subtype.val\u27e9", "start": [106, 1], "end": [107, 16], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.J_mem", "code": "theorem J_mem : J l R \u2208 symplecticGroup l R", "start": [114, 1], "end": [116, 7], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.symJ", "code": "def symJ : symplecticGroup l R :=\n  \u27e8J l R, J_mem l R\u27e9", "start": [120, 1], "end": [122, 21], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.coe_J", "code": "@[simp]\ntheorem coe_J : \u2191(symJ l R) = J l R", "start": [128, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.neg_mem", "code": "theorem neg_mem (h : A \u2208 symplecticGroup l R) : -A \u2208 symplecticGroup l R", "start": [137, 1], "end": [139, 11], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.symplectic_det", "code": "theorem symplectic_det (hA : A \u2208 symplecticGroup l R) : IsUnit <| det A", "start": [142, 1], "end": [151, 11], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.transpose_mem", "code": "theorem transpose_mem (hA : A \u2208 symplecticGroup l R) : A\u1d40 \u2208 symplecticGroup l R", "start": [154, 1], "end": [170, 33], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.transpose_mem_iff", "code": "@[simp]\ntheorem transpose_mem_iff : A\u1d40 \u2208 symplecticGroup l R \u2194 A \u2208 symplecticGroup l R", "start": [173, 1], "end": [175, 61], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.mem_iff'", "code": "theorem mem_iff' : A \u2208 symplecticGroup l R \u2194 A\u1d40 * J l R * A = J l R", "start": [178, 1], "end": [179, 57], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.hasInv", "code": "instance hasInv : Inv (symplecticGroup l R) where\n  inv A := \u27e8(-J l R) * (A : Matrix (Sum l l) (Sum l l) R)\u1d40 * J l R,\n      mul_mem (mul_mem (neg_mem <| J_mem _ _) <| transpose_mem A.2) <| J_mem _ _\u27e9", "start": [182, 1], "end": [184, 82], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.coe_inv", "code": "theorem coe_inv (A : symplecticGroup l R) : (\u2191A\u207b\u00b9 : Matrix _ _ _) = (-J l R) * (\u2191A)\u1d40 * J l R", "start": [186, 1], "end": [186, 100], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.inv_left_mul_aux", "code": "theorem inv_left_mul_aux (hA : A \u2208 symplecticGroup l R) : -(J l R * A\u1d40 * J l R * A) = 1", "start": [189, 1], "end": [198, 51], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.coe_inv'", "code": "theorem coe_inv' (A : symplecticGroup l R) : (\u2191A\u207b\u00b9 : Matrix (Sum l l) (Sum l l) R) = (\u2191A)\u207b\u00b9", "start": [201, 1], "end": [203, 35], "kind": "commanddeclaration"}, {"full_name": "SymplecticGroup.inv_eq_symplectic_inv", "code": "theorem inv_eq_symplectic_inv (A : Matrix (Sum l l) (Sum l l) R) (hA : A \u2208 symplecticGroup l R) :\n    A\u207b\u00b9 = (-J l R) * A\u1d40 * J l R", "start": [206, 1], "end": [208, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/AlgebraicGeometry/Properties.lean", "imports": ["Mathlib/Algebra/Category/Ring/Constructions.lean", "Mathlib/AlgebraicGeometry/AffineScheme.lean", "Mathlib/RingTheory/Nilpotent.lean", "Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/LocalProperties.lean"], "premises": [{"full_name": "AlgebraicGeometry.IsReduced", "code": "class IsReduced : Prop where\n  component_reduced : \u2200 U, IsReduced (X.presheaf.obj (op U)) := by infer_instance", "start": [50, 1], "end": [52, 82], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isReducedOfStalkIsReduced", "code": "theorem isReducedOfStalkIsReduced [\u2200 x : X.carrier, _root_.IsReduced (X.presheaf.stalk x)] :\n    IsReduced X", "start": [57, 1], "end": [64, 27], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.stalk_isReduced_of_reduced", "code": "instance stalk_isReduced_of_reduced [IsReduced X] (x : X.carrier) :\n    _root_.IsReduced (X.presheaf.stalk x) := by\n  constructor\n  rintro g \u27e8n, e\u27e9\n  obtain \u27e8U, hxU, s, rfl\u27e9 := X.presheaf.germ_exist x g\n  rw [\u2190 map_pow, \u2190 map_zero (X.presheaf.germ \u27e8x, hxU\u27e9)] at e\n  obtain \u27e8V, hxV, iU, iV, e'\u27e9 := X.presheaf.germ_eq x hxU hxU _ 0 e\n  rw [map_pow, map_zero] at e'\n  replace e' := (IsNilpotent.mk _ _ e').eq_zero (R := X.presheaf.obj <| op V)\n  erw [\u2190 ConcreteCategory.congr_hom (X.presheaf.germ_res iU \u27e8x, hxV\u27e9) s]\n  rw [comp_apply, e', map_zero]", "start": [67, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isReducedOfOpenImmersion", "code": "theorem isReducedOfOpenImmersion {X Y : Scheme} (f : X \u27f6 Y) [H : IsOpenImmersion f]\n    [IsReduced Y] : IsReduced X", "start": [80, 1], "end": [89, 69], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affine_isReduced_iff", "code": "theorem affine_isReduced_iff (R : CommRingCat) :\n    IsReduced (Scheme.Spec.obj <| op R) \u2194 _root_.IsReduced R", "start": [100, 1], "end": [107, 100], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isReducedOfIsAffineIsReduced", "code": "theorem isReducedOfIsAffineIsReduced [IsAffine X] [h : _root_.IsReduced (X.presheaf.obj (op \u22a4))] :\n    IsReduced X", "start": [110, 1], "end": [114, 41], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.reduce_to_affine_global", "code": "theorem reduce_to_affine_global (P : \u2200 (X : Scheme) (_ : Opens X.carrier), Prop)\n    (h\u2081 : \u2200 (X : Scheme) (U : Opens X.carrier),\n      (\u2200 x : U, \u2203 (V : _) (_ : x.1 \u2208 V) (_ : V \u27f6 U), P X V) \u2192 P X U)\n    (h\u2082 : \u2200 {X Y} (f : X \u27f6 Y) [hf : IsOpenImmersion f],\n      \u2203 (U : Set X.carrier) (V : Set Y.carrier) (hU : U = \u22a4) (hV : V = Set.range f.1.base),\n        P X \u27e8U, hU.symm \u25b8 isOpen_univ\u27e9 \u2192 P Y \u27e8V, hV.symm \u25b8 hf.base_open.open_range\u27e9)\n    (h\u2083 : \u2200 R : CommRingCat, P (Scheme.Spec.obj <| op R) \u22a4) :\n    \u2200 (X : Scheme) (U : Opens X.carrier), P X U", "start": [117, 1], "end": [141, 11], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.reduce_to_affine_nbhd", "code": "theorem reduce_to_affine_nbhd (P : \u2200 (X : Scheme) (_ : X.carrier), Prop)\n    (h\u2081 : \u2200 (R : CommRingCat) (x : PrimeSpectrum R), P (Scheme.Spec.obj <| op R) x)\n    (h\u2082 : \u2200 {X Y} (f : X \u27f6 Y) [IsOpenImmersion f] (x : X.carrier), P X x \u2192 P Y (f.1.base x)) :\n    \u2200 (X : Scheme) (x : X.carrier), P X x", "start": [144, 1], "end": [152, 11], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.eq_zero_of_basicOpen_eq_bot", "code": "theorem eq_zero_of_basicOpen_eq_bot {X : Scheme} [hX : IsReduced X] {U : Opens X.carrier}\n    (s : X.presheaf.obj (op U)) (hs : X.basicOpen s = \u22a5) : s = 0", "start": [155, 1], "end": [189, 46], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.basicOpen_eq_bot_iff", "code": "@[simp]\ntheorem basicOpen_eq_bot_iff {X : Scheme} [IsReduced X] {U : Opens X.carrier}\n    (s : X.presheaf.obj <| op U) : X.basicOpen s = \u22a5 \u2194 s = 0", "start": [192, 1], "end": [197, 7], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.IsIntegral", "code": "class IsIntegral : Prop where\n  nonempty : Nonempty X.carrier := by infer_instance\n  component_integral : \u2200 (U : Opens X.carrier) [Nonempty U], IsDomain (X.presheaf.obj (op U)) := by\n    infer_instance", "start": [200, 1], "end": [205, 19], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isReducedOfIsIntegral", "code": "instance (priority := 900) isReducedOfIsIntegral [IsIntegral X] : IsReduced X := by\n  constructor\n  intro U\n  cases' U.1.eq_empty_or_nonempty with h h\n  \u00b7 have : U = \u22a5 := SetLike.ext' h\n    haveI := CommRingCat.subsingleton_of_isTerminal (X.sheaf.isTerminalOfEqEmpty this)\n    change _root_.IsReduced (X.sheaf.val.obj (op U))\n    infer_instance\n  \u00b7 haveI : Nonempty U := by simpa\n    infer_instance", "start": [214, 1], "end": [223, 19], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.is_irreducible_of_isIntegral", "code": "instance is_irreducible_of_isIntegral [IsIntegral X] : IrreducibleSpace X.carrier := by\n  by_contra H\n  replace H : \u00acIsPreirreducible (\u22a4 : Set X.carrier) := fun h =>\n    H { toPreirreducibleSpace := \u27e8h\u27e9\n        toNonempty := inferInstance }\n  simp_rw [isPreirreducible_iff_closed_union_closed, not_forall, not_or] at H\n  rcases H with \u27e8S, T, hS, hT, h\u2081, h\u2082, h\u2083\u27e9\n  erw [not_forall] at h\u2082 h\u2083\n  simp_rw [not_forall] at h\u2082 h\u2083\n  haveI : Nonempty (\u27e8S\u1d9c, hS.1\u27e9 : Opens X.carrier) := \u27e8\u27e8_, h\u2082.choose_spec.choose_spec\u27e9\u27e9\n  haveI : Nonempty (\u27e8T\u1d9c, hT.1\u27e9 : Opens X.carrier) := \u27e8\u27e8_, h\u2083.choose_spec.choose_spec\u27e9\u27e9\n  haveI : Nonempty (\u27e8S\u1d9c, hS.1\u27e9 \u2294 \u27e8T\u1d9c, hT.1\u27e9 : Opens X.carrier) :=\n    \u27e8\u27e8_, Or.inl h\u2082.choose_spec.choose_spec\u27e9\u27e9\n  let e : X.presheaf.obj _ \u2245 CommRingCat.of _ :=\n    (X.sheaf.isProductOfDisjoint \u27e8_, hS.1\u27e9 \u27e8_, hT.1\u27e9 ?_).conePointUniqueUpToIso\n      (CommRingCat.prodFanIsLimit _ _)\n  apply (config := { allowSynthFailures := true }) false_of_nontrivial_of_product_domain\n  \u00b7 exact e.symm.commRingCatIsoToRingEquiv.toMulEquiv.isDomain _\n  \u00b7 apply X.toLocallyRingedSpace.component_nontrivial\n  \u00b7 apply X.toLocallyRingedSpace.component_nontrivial\n  \u00b7 ext x\n    constructor\n    \u00b7 rintro \u27e8hS, hT\u27e9\n      cases' h\u2081 (show x \u2208 \u22a4 by trivial) with h h\n      exacts [hS h, hT h]\n    \u00b7 intro x\n      refine' x.rec (by contradiction)", "start": [226, 1], "end": [252, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isIntegralOfIsIrreducibleIsReduced", "code": "theorem isIntegralOfIsIrreducibleIsReduced [IsReduced X] [H : IrreducibleSpace X.carrier] :\n    IsIntegral X", "start": [255, 1], "end": [274, 37], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isIntegral_iff_is_irreducible_and_isReduced", "code": "theorem isIntegral_iff_is_irreducible_and_isReduced :\n    IsIntegral X \u2194 IrreducibleSpace X.carrier \u2227 IsReduced X", "start": [277, 1], "end": [280, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isIntegralOfOpenImmersion", "code": "theorem isIntegralOfOpenImmersion {X Y : Scheme} (f : X \u27f6 Y) [H : IsOpenImmersion f]\n    [IsIntegral Y] [Nonempty X.carrier] : IsIntegral X", "start": [283, 1], "end": [294, 79], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.affine_isIntegral_iff", "code": "theorem affine_isIntegral_iff (R : CommRingCat) :\n    IsIntegral (Scheme.Spec.obj <| op R) \u2194 IsDomain R", "start": [304, 1], "end": [307, 87], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.isIntegralOfIsAffineIsDomain", "code": "theorem isIntegralOfIsAffineIsDomain [IsAffine X] [Nonempty X.carrier]\n    [h : IsDomain (X.presheaf.obj (op \u22a4))] : IsIntegral X", "start": [310, 1], "end": [314, 42], "kind": "commanddeclaration"}, {"full_name": "AlgebraicGeometry.map_injective_of_isIntegral", "code": "theorem map_injective_of_isIntegral [IsIntegral X] {U V : Opens X.carrier} (i : U \u27f6 V)\n    [H : Nonempty U] : Function.Injective (X.presheaf.map i.op)", "start": [317, 1], "end": [327, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Closed/Cartesian.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/FiniteProducts.lean", "Mathlib/CategoryTheory/Adjunction/Mates.lean", "Mathlib/CategoryTheory/EpiMono.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Closed/Monoidal.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Monoidal/OfHasFiniteProducts.lean", "Mathlib/CategoryTheory/Adjunction/Limits.lean"], "premises": [{"full_name": "CategoryTheory.Exponentiable", "code": "abbrev Exponentiable {C : Type u} [Category.{v} C] [HasFiniteProducts C] (X : C) :=\n  Closed X", "start": [46, 1], "end": [50, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.binaryProductExponentiable", "code": "def binaryProductExponentiable {C : Type u} [Category.{v} C] [HasFiniteProducts C] {X Y : C}\n    (hX : Exponentiable X) (hY : Exponentiable Y) : Exponentiable (X \u2a2f Y) :=\n  tensorClosed hX hY", "start": [53, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.terminalExponentiable", "code": "def terminalExponentiable {C : Type u} [Category.{v} C] [HasFiniteProducts C] :\n    Exponentiable (\u22a4_ C) :=\n  unitClosed", "start": [62, 1], "end": [68, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed", "code": "abbrev CartesianClosed (C : Type u) [Category.{v} C] [HasFiniteProducts C] :=\n  MonoidalClosed C", "start": [71, 1], "end": [75, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.mk", "code": "def CartesianClosed.mk (C : Type u) [Category.{v} C] [HasFiniteProducts C]\n    (h : \u2200 X, IsLeftAdjoint (@MonoidalCategory.tensorLeft _ _\n      (monoidalOfHasFiniteProducts C) X)) :\n    CartesianClosed C :=\n  \u27e8fun X => \u27e8h X\u27e9\u27e9", "start": [79, 1], "end": [84, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp", "code": "abbrev exp : C \u2964 C :=\n  ihom A", "start": [90, 1], "end": [92, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.adjunction", "code": "abbrev adjunction : prod.functor.obj A \u22a3 exp A :=\n  ihom.adjunction A", "start": [97, 1], "end": [99, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.ev", "code": "abbrev ev : exp A \u22d9 prod.functor.obj A \u27f6 \ud835\udfed C :=\n  ihom.ev A", "start": [102, 1], "end": [104, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.coev", "code": "abbrev coev : \ud835\udfed C \u27f6 prod.functor.obj A \u22d9 exp A :=\n  ihom.coev A", "start": [107, 1], "end": [109, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.delabPrefunctorObjExp", "code": "@[delab app.Prefunctor.obj]\ndef delabPrefunctorObjExp : Delab := do\n  let e \u2190 getExpr\n  guard $ e.isAppOfArity' ``Prefunctor.obj 6\n  let A \u2190 withNaryArg 4 do\n    let e \u2190 getExpr\n    guard $ e.isAppOfArity' ``Functor.toPrefunctor 5\n    withNaryArg 4 do\n      let e \u2190 getExpr\n      guard $ e.isAppOfArity' ``exp 5\n      withNaryArg 2 delab\n  let B \u2190 withNaryArg 5 delab\n  `($A \u27f9 $B)", "start": [118, 1], "end": [131, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.ev_coev", "code": "@[simp, reassoc]\ntheorem ev_coev : Limits.prod.map (\ud835\udfd9 A) ((coev A).app B) \u226b (ev A).app (A \u2a2f B) = \ud835\udfd9 (A \u2a2f B)", "start": [138, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.exp.coev_ev", "code": "@[simp, reassoc]\ntheorem coev_ev : (coev A).app (A \u27f9 B) \u226b (exp A).map ((ev A).app B) = \ud835\udfd9 (A \u27f9 B)", "start": [143, 1], "end": [145, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry", "code": "def curry : (A \u2a2f Y \u27f6 X) \u2192 (Y \u27f6 A \u27f9 X) :=\n  (exp.adjunction A).homEquiv _ _", "start": [158, 1], "end": [160, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry", "code": "def uncurry : (Y \u27f6 A \u27f9 X) \u2192 (A \u2a2f Y \u27f6 X) :=\n  ((exp.adjunction A).homEquiv _ _).symm", "start": [163, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.homEquiv_apply_eq", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_apply_eq (f : A \u2a2f Y \u27f6 X) : (exp.adjunction A).homEquiv _ _ f = curry f", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.homEquiv_symm_apply_eq", "code": "@[simp, nolint simpNF]\ntheorem homEquiv_symm_apply_eq (f : Y \u27f6 A \u27f9 X) :\n    ((exp.adjunction A).homEquiv _ _).symm f = uncurry f", "start": [175, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_natural_left", "code": "@[reassoc]\ntheorem curry_natural_left (f : X \u27f6 X') (g : A \u2a2f X' \u27f6 Y) :\n    curry (Limits.prod.map (\ud835\udfd9 _) f \u226b g) = f \u226b curry g", "start": [181, 1], "end": [184, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_natural_right", "code": "@[reassoc]\ntheorem curry_natural_right (f : A \u2a2f X \u27f6 Y) (g : Y \u27f6 Y') :\n    curry (f \u226b g) = curry f \u226b (exp _).map g", "start": [187, 1], "end": [190, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_natural_right", "code": "@[reassoc]\ntheorem uncurry_natural_right (f : X \u27f6 A \u27f9 Y) (g : Y \u27f6 Y') :\n    uncurry (f \u226b (exp _).map g) = uncurry f \u226b g", "start": [193, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_natural_left", "code": "@[reassoc]\ntheorem uncurry_natural_left (f : X \u27f6 X') (g : X' \u27f6 A \u27f9 Y) :\n    uncurry (f \u226b g) = Limits.prod.map (\ud835\udfd9 _) f \u226b uncurry g", "start": [199, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_curry", "code": "@[simp]\ntheorem uncurry_curry (f : A \u2a2f X \u27f6 Y) : uncurry (curry f) = f", "start": [205, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_uncurry", "code": "@[simp]\ntheorem curry_uncurry (f : X \u27f6 A \u27f9 Y) : curry (uncurry f) = f", "start": [210, 1], "end": [212, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_eq_iff", "code": "theorem curry_eq_iff (f : A \u2a2f Y \u27f6 X) (g : Y \u27f6 A \u27f9 X) : curry f = g \u2194 f = uncurry g", "start": [216, 1], "end": [217, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.eq_curry_iff", "code": "theorem eq_curry_iff (f : A \u2a2f Y \u27f6 X) (g : Y \u27f6 A \u27f9 X) : g = curry f \u2194 uncurry g = f", "start": [221, 1], "end": [222, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_eq", "code": "theorem uncurry_eq (g : Y \u27f6 A \u27f9 X) : uncurry g = Limits.prod.map (\ud835\udfd9 A) g \u226b (exp.ev A).app X", "start": [226, 1], "end": [227, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_eq", "code": "theorem curry_eq (g : A \u2a2f Y \u27f6 X) : curry g = (exp.coev A).app Y \u226b (exp A).map g", "start": [230, 1], "end": [231, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_id_eq_ev", "code": "theorem uncurry_id_eq_ev (A X : C) [Exponentiable A] : uncurry (\ud835\udfd9 (A \u27f9 X)) = (exp.ev A).app X", "start": [234, 1], "end": [235, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_id_eq_coev", "code": "theorem curry_id_eq_coev (A X : C) [Exponentiable A] : curry (\ud835\udfd9 _) = (exp.coev A).app X", "start": [238, 1], "end": [239, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.curry_injective", "code": "theorem curry_injective : Function.Injective (curry : (A \u2a2f Y \u27f6 X) \u2192 (Y \u27f6 A \u27f9 X))", "start": [242, 1], "end": [243, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CartesianClosed.uncurry_injective", "code": "theorem uncurry_injective : Function.Injective (uncurry : (Y \u27f6 A \u27f9 X) \u2192 (A \u2a2f Y \u27f6 X))", "start": [246, 1], "end": [247, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.expTerminalIsoSelf", "code": "def expTerminalIsoSelf [Exponentiable (\u22a4_ C)] : (\u22a4_ C) \u27f9 X \u2245 X :=\n  Yoneda.ext ((\u22a4_ C) \u27f9 X) X\n    (fun {Y} f => (prod.leftUnitor Y).inv \u226b CartesianClosed.uncurry f)\n    (fun {Y} f => CartesianClosed.curry ((prod.leftUnitor Y).hom \u226b f))\n    (fun g => by\n      rw [curry_eq_iff, Iso.hom_inv_id_assoc])\n    (fun g => by simp)\n    (fun f g => by\n      dsimp [-prod.leftUnitor_inv]\n      rw [uncurry_natural_left, prod.leftUnitor_inv_naturality_assoc f])", "start": [254, 1], "end": [268, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.internalizeHom", "code": "def internalizeHom (f : A \u27f6 Y) : \u22a4_ C \u27f6 A \u27f9 Y :=\n  CartesianClosed.curry (Limits.prod.fst \u226b f)", "start": [271, 1], "end": [273, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pre", "code": "def pre (f : B \u27f6 A) [Exponentiable B] : exp A \u27f6 exp B :=\n  transferNatTransSelf (exp.adjunction _) (exp.adjunction _) (prod.functor.map f)", "start": [280, 1], "end": [282, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prod_map_pre_app_comp_ev", "code": "theorem prod_map_pre_app_comp_ev (f : B \u27f6 A) [Exponentiable B] (X : C) :\n    Limits.prod.map (\ud835\udfd9 B) ((pre f).app X) \u226b (exp.ev B).app X =\n      Limits.prod.map f (\ud835\udfd9 (A \u27f9 X)) \u226b (exp.ev A).app X", "start": [285, 1], "end": [288, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uncurry_pre", "code": "theorem uncurry_pre (f : B \u27f6 A) [Exponentiable B] (X : C) :\n    CartesianClosed.uncurry ((pre f).app X) = Limits.prod.map f (\ud835\udfd9 _) \u226b (exp.ev A).app X", "start": [291, 1], "end": [293, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.coev_app_comp_pre_app", "code": "theorem coev_app_comp_pre_app (f : B \u27f6 A) [Exponentiable B] :\n    (exp.coev A).app X \u226b (pre f).app (A \u2a2f X) =\n      (exp.coev B).app X \u226b (exp B).map (Limits.prod.map f (\ud835\udfd9 _))", "start": [296, 1], "end": [299, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pre_id", "code": "@[simp]\ntheorem pre_id (A : C) [Exponentiable A] : pre (\ud835\udfd9 A) = \ud835\udfd9 _", "start": [302, 1], "end": [303, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.pre_map", "code": "@[simp]\ntheorem pre_map {A\u2081 A\u2082 A\u2083 : C} [Exponentiable A\u2081] [Exponentiable A\u2082] [Exponentiable A\u2083]\n    (f : A\u2081 \u27f6 A\u2082) (g : A\u2082 \u27f6 A\u2083) : pre (f \u226b g) = pre g \u226b pre f", "start": [306, 1], "end": [309, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.internalHom", "code": "def internalHom [CartesianClosed C] : C\u1d52\u1d56 \u2964 C \u2964 C where\n  obj X := exp X.unop\n  map f := pre f.unop", "start": [314, 1], "end": [317, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.zeroMul", "code": "@[simps]\ndef zeroMul {I : C} (t : IsInitial I) : A \u2a2f I \u2245 I where\n  hom := Limits.prod.snd\n  inv := t.to _\n  hom_inv_id := by\n    have : (prod.snd : A \u2a2f I \u27f6 I) = CartesianClosed.uncurry (t.to _) := by\n      rw [\u2190 curry_eq_iff]\n      apply t.hom_ext\n    rw [this, \u2190 uncurry_natural_right, \u2190 eq_curry_iff]\n    apply t.hom_ext\n  inv_hom_id := t.hom_ext _ _", "start": [320, 1], "end": [331, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mulZero", "code": "def mulZero {I : C} (t : IsInitial I) : I \u2a2f A \u2245 I :=\n  Limits.prod.braiding _ _ \u226a\u226b zeroMul t", "start": [334, 1], "end": [336, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.powZero", "code": "def powZero {I : C} (t : IsInitial I) [CartesianClosed C] : I \u27f9 B \u2245 \u22a4_ C where\n  hom := default\n  inv := CartesianClosed.curry ((mulZero t).hom \u226b t.to _)\n  hom_inv_id := by\n    rw [\u2190 curry_natural_left, curry_eq_iff, \u2190 cancel_epi (mulZero t).inv]\n    apply t.hom_ext", "start": [339, 1], "end": [346, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.prodCoprodDistrib", "code": "def prodCoprodDistrib [HasBinaryCoproducts C] [CartesianClosed C] (X Y Z : C) :\n    (Z \u2a2f X) \u2a3f Z \u2a2f Y \u2245 Z \u2a2f X \u2a3f Y where\n  hom := coprod.desc (Limits.prod.map (\ud835\udfd9 _) coprod.inl) (Limits.prod.map (\ud835\udfd9 _) coprod.inr)\n  inv :=\n    CartesianClosed.uncurry\n      (coprod.desc (CartesianClosed.curry coprod.inl) (CartesianClosed.curry coprod.inr))\n  hom_inv_id := by\n    ext\n    rw [coprod.inl_desc_assoc, comp_id, \u2190 uncurry_natural_left, coprod.inl_desc, uncurry_curry]\n    rw [coprod.inr_desc_assoc, comp_id, \u2190 uncurry_natural_left, coprod.inr_desc, uncurry_curry]\n  inv_hom_id := by\n    rw [\u2190 uncurry_natural_right, \u2190 eq_curry_iff]\n    ext\n    rw [coprod.inl_desc_assoc, \u2190 curry_natural_right, coprod.inl_desc, \u2190 curry_natural_left,\n      comp_id]\n    rw [coprod.inr_desc_assoc, \u2190 curry_natural_right, coprod.inr_desc, \u2190 curry_natural_left,\n      comp_id]", "start": [351, 1], "end": [368, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.strict_initial", "code": "theorem strict_initial {I : C} (t : IsInitial I) (f : A \u27f6 I) : IsIso f", "start": [371, 1], "end": [380, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.to_initial_isIso", "code": "instance to_initial_isIso [HasInitial C] (f : A \u27f6 \u22a5_ C) : IsIso f :=\n  strict_initial initialIsInitial _", "start": [383, 1], "end": [384, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.initial_mono", "code": "theorem initial_mono {I : C} (B : C) (t : IsInitial I) [CartesianClosed C] : Mono (t.to B)", "start": [387, 1], "end": [392, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Initial.mono_to", "code": "instance Initial.mono_to [HasInitial C] (B : C) [CartesianClosed C] : Mono (initial.to B) :=\n  initial_mono B initialIsInitial", "start": [395, 1], "end": [396, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cartesianClosedOfEquiv", "code": "def cartesianClosedOfEquiv (e : C \u224c D) [h : CartesianClosed C] : CartesianClosed D where\n  closed X :=\n    { isAdj := by\n        haveI q : Exponentiable (e.inverse.obj X) := inferInstance\n        have : IsLeftAdjoint (prod.functor.obj (e.inverse.obj X)) := q.isAdj\n        have : e.functor \u22d9 prod.functor.obj X \u22d9 e.inverse \u2245\n            prod.functor.obj (e.inverse.obj X) := by\n          apply NatIso.ofComponents _ _\n          \u00b7 intro Y\n            apply asIso (prodComparison e.inverse X (e.functor.obj Y)) \u226a\u226b _\n            apply prod.mapIso (Iso.refl _) (e.unitIso.app Y).symm\n          \u00b7 intro Y Z g\n            dsimp\n            simp [prodComparison, prod.comp_lift, \u2190 e.inverse.map_comp, \u2190 e.inverse.map_comp_assoc]\n            \u00b7 have : IsLeftAdjoint (e.functor \u22d9 prod.functor.obj X \u22d9 e.inverse) :=\n            Adjunction.leftAdjointOfNatIso this.symm\n          have : IsLeftAdjoint (e.inverse \u22d9 e.functor \u22d9 prod.functor.obj X \u22d9 e.inverse) :=\n            Adjunction.leftAdjointOfComp e.inverse _\n          have :\n            (e.inverse \u22d9 e.functor \u22d9 prod.functor.obj X \u22d9 e.inverse) \u22d9 e.functor \u2245\n              prod.functor.obj X := by\n            apply isoWhiskerRight e.counitIso (prod.functor.obj X \u22d9 e.inverse \u22d9 e.functor) \u226a\u226b _\n            change prod.functor.obj X \u22d9 e.inverse \u22d9 e.functor \u2245 prod.functor.obj X\n            apply isoWhiskerLeft (prod.functor.obj X) e.counitIso\n          skip\n          apply Adjunction.leftAdjointOfNatIso this }", "start": [405, 1], "end": [437, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Asymptotics/SuperpolynomialDecay.lean", "imports": ["Mathlib/Analysis/Normed/Order/Basic.lean", "Mathlib/Data/Polynomial/Eval.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Asymptotics/Asymptotics.lean", "Mathlib/Topology/Algebra/Order/LiminfLimsup.lean"], "premises": [{"full_name": "Asymptotics.SuperpolynomialDecay", "code": "def SuperpolynomialDecay {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b2] [CommSemiring \u03b2] (l : Filter \u03b1)\n    (k : \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 n : \u2115, Tendsto (fun a : \u03b1 => k a ^ n * f a) l (\ud835\udcdd 0)", "start": [56, 1], "end": [60, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.congr'", "code": "theorem SuperpolynomialDecay.congr' (hf : SuperpolynomialDecay l k f) (hfg : f =\u1da0[l] g) :\n    SuperpolynomialDecay l k g", "start": [69, 1], "end": [71, 63], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.congr", "code": "theorem SuperpolynomialDecay.congr (hf : SuperpolynomialDecay l k f) (hfg : \u2200 x, f x = g x) :\n    SuperpolynomialDecay l k g", "start": [74, 1], "end": [76, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_zero", "code": "@[simp]\ntheorem superpolynomialDecay_zero (l : Filter \u03b1) (k : \u03b1 \u2192 \u03b2) : SuperpolynomialDecay l k 0", "start": [79, 1], "end": [81, 76], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.add", "code": "theorem SuperpolynomialDecay.add [ContinuousAdd \u03b2] (hf : SuperpolynomialDecay l k f)\n    (hg : SuperpolynomialDecay l k g) : SuperpolynomialDecay l k (f + g)", "start": [84, 1], "end": [86, 71], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul", "code": "theorem SuperpolynomialDecay.mul [ContinuousMul \u03b2] (hf : SuperpolynomialDecay l k f)\n    (hg : SuperpolynomialDecay l k g) : SuperpolynomialDecay l k (f * g)", "start": [89, 1], "end": [91, 78], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul_const", "code": "theorem SuperpolynomialDecay.mul_const [ContinuousMul \u03b2] (hf : SuperpolynomialDecay l k f) (c : \u03b2) :\n    SuperpolynomialDecay l k fun n => f n * c", "start": [94, 1], "end": [96, 70], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.const_mul", "code": "theorem SuperpolynomialDecay.const_mul [ContinuousMul \u03b2] (hf : SuperpolynomialDecay l k f) (c : \u03b2) :\n    SuperpolynomialDecay l k fun n => c * f n", "start": [99, 1], "end": [101, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.param_mul", "code": "theorem SuperpolynomialDecay.param_mul (hf : SuperpolynomialDecay l k f) :\n    SuperpolynomialDecay l k (k * f)", "start": [104, 1], "end": [108, 85], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul_param", "code": "theorem SuperpolynomialDecay.mul_param (hf : SuperpolynomialDecay l k f) :\n    SuperpolynomialDecay l k (f * k)", "start": [111, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.param_pow_mul", "code": "theorem SuperpolynomialDecay.param_pow_mul (hf : SuperpolynomialDecay l k f) (n : \u2115) :\n    SuperpolynomialDecay l k (k ^ n * f)", "start": [116, 1], "end": [120, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul_param_pow", "code": "theorem SuperpolynomialDecay.mul_param_pow (hf : SuperpolynomialDecay l k f) (n : \u2115) :\n    SuperpolynomialDecay l k (f * k ^ n)", "start": [123, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.polynomial_mul", "code": "theorem SuperpolynomialDecay.polynomial_mul [ContinuousAdd \u03b2] [ContinuousMul \u03b2]\n    (hf : SuperpolynomialDecay l k f) (p : \u03b2[X]) :\n    SuperpolynomialDecay l k fun x => (p.eval <| k x) * f x", "start": [128, 1], "end": [132, 61], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul_polynomial", "code": "theorem SuperpolynomialDecay.mul_polynomial [ContinuousAdd \u03b2] [ContinuousMul \u03b2]\n    (hf : SuperpolynomialDecay l k f) (p : \u03b2[X]) :\n    SuperpolynomialDecay l k fun x => f x * (p.eval <| k x)", "start": [135, 1], "end": [138, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.trans_eventuallyLE", "code": "theorem SuperpolynomialDecay.trans_eventuallyLE (hk : 0 \u2264\u1da0[l] k) (hg : SuperpolynomialDecay l k g)\n    (hg' : SuperpolynomialDecay l k g') (hfg : g \u2264\u1da0[l] f) (hfg' : f \u2264\u1da0[l] g') :\n    SuperpolynomialDecay l k f", "start": [147, 1], "end": [152, 88], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_abs_tendsto_zero", "code": "theorem superpolynomialDecay_iff_abs_tendsto_zero :\n    SuperpolynomialDecay l k f \u2194 \u2200 n : \u2115, Tendsto (fun a : \u03b1 => |k a ^ n * f a|) l (\ud835\udcdd 0)", "start": [163, 1], "end": [166, 51], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_abs", "code": "theorem superpolynomialDecay_iff_superpolynomialDecay_abs :\n    SuperpolynomialDecay l k f \u2194 SuperpolynomialDecay l (fun a => |k a|) fun a => |f a|", "start": [169, 1], "end": [172, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.trans_eventually_abs_le", "code": "theorem SuperpolynomialDecay.trans_eventually_abs_le (hf : SuperpolynomialDecay l k f)\n    (hfg : abs \u2218 g \u2264\u1da0[l] abs \u2218 f) : SuperpolynomialDecay l k g", "start": [177, 1], "end": [186, 58], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.trans_abs_le", "code": "theorem SuperpolynomialDecay.trans_abs_le (hf : SuperpolynomialDecay l k f)\n    (hfg : \u2200 x, |g x| \u2264 |f x|) : SuperpolynomialDecay l k g", "start": [189, 1], "end": [191, 56], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_mul_const_iff", "code": "theorem superpolynomialDecay_mul_const_iff [ContinuousMul \u03b2] {c : \u03b2} (hc0 : c \u2260 0) :\n    (SuperpolynomialDecay l k fun n => f n * c) \u2194 SuperpolynomialDecay l k f", "start": [200, 1], "end": [203, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_const_mul_iff", "code": "theorem superpolynomialDecay_const_mul_iff [ContinuousMul \u03b2] {c : \u03b2} (hc0 : c \u2260 0) :\n    (SuperpolynomialDecay l k fun n => c * f n) \u2194 SuperpolynomialDecay l k f", "start": [206, 1], "end": [209, 19], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_abs_isBoundedUnder", "code": "theorem superpolynomialDecay_iff_abs_isBoundedUnder (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f \u2194\n    \u2200 z : \u2115, IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun a : \u03b1 => |k a ^ z * f a|", "start": [222, 1], "end": [238, 82], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_zpow_tendsto_zero", "code": "theorem superpolynomialDecay_iff_zpow_tendsto_zero (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f \u2194 \u2200 z : \u2124, Tendsto (fun a : \u03b1 => k a ^ z * f a) l (\ud835\udcdd 0)", "start": [241, 1], "end": [251, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.param_zpow_mul", "code": "theorem SuperpolynomialDecay.param_zpow_mul (hk : Tendsto k l atTop)\n    (hf : SuperpolynomialDecay l k f) (z : \u2124) :\n    SuperpolynomialDecay l k fun a => k a ^ z * f a", "start": [256, 1], "end": [261, 47], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.mul_param_zpow", "code": "theorem SuperpolynomialDecay.mul_param_zpow (hk : Tendsto k l atTop)\n    (hf : SuperpolynomialDecay l k f) (z : \u2124) : SuperpolynomialDecay l k fun a => f a * k a ^ z", "start": [264, 1], "end": [266, 55], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.inv_param_mul", "code": "theorem SuperpolynomialDecay.inv_param_mul (hk : Tendsto k l atTop)\n    (hf : SuperpolynomialDecay l k f) : SuperpolynomialDecay l k (k\u207b\u00b9 * f)", "start": [269, 1], "end": [271, 40], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.SuperpolynomialDecay.param_inv_mul", "code": "theorem SuperpolynomialDecay.param_inv_mul (hk : Tendsto k l atTop)\n    (hf : SuperpolynomialDecay l k f) : SuperpolynomialDecay l k (f * k\u207b\u00b9)", "start": [274, 1], "end": [276, 52], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_param_mul_iff", "code": "theorem superpolynomialDecay_param_mul_iff (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k (k * f) \u2194 SuperpolynomialDecay l k f", "start": [281, 1], "end": [286, 26], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_mul_param_iff", "code": "theorem superpolynomialDecay_mul_param_iff (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k (f * k) \u2194 SuperpolynomialDecay l k f", "start": [289, 1], "end": [291, 67], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_param_pow_mul_iff", "code": "theorem superpolynomialDecay_param_pow_mul_iff (hk : Tendsto k l atTop) (n : \u2115) :\n    SuperpolynomialDecay l k (k ^ n * f) \u2194 SuperpolynomialDecay l k f", "start": [294, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_mul_param_pow_iff", "code": "theorem superpolynomialDecay_mul_param_pow_iff (hk : Tendsto k l atTop) (n : \u2115) :\n    SuperpolynomialDecay l k (f * k ^ n) \u2194 SuperpolynomialDecay l k f", "start": [302, 1], "end": [304, 73], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_norm_tendsto_zero", "code": "theorem superpolynomialDecay_iff_norm_tendsto_zero :\n    SuperpolynomialDecay l k f \u2194 \u2200 n : \u2115, Tendsto (fun a : \u03b1 => \u2016k a ^ n * f a\u2016) l (\ud835\udcdd 0)", "start": [317, 1], "end": [320, 48], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_superpolynomialDecay_norm", "code": "theorem superpolynomialDecay_iff_superpolynomialDecay_norm :\n    SuperpolynomialDecay l k f \u2194 SuperpolynomialDecay l (fun a => \u2016k a\u2016) fun a => \u2016f a\u2016", "start": [323, 1], "end": [325, 92], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_isBigO", "code": "theorem superpolynomialDecay_iff_isBigO (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f \u2194 \u2200 z : \u2124, f =O[l] fun a : \u03b1 => k a ^ z", "start": [332, 1], "end": [348, 8], "kind": "commanddeclaration"}, {"full_name": "Asymptotics.superpolynomialDecay_iff_isLittleO", "code": "theorem superpolynomialDecay_iff_isLittleO (hk : Tendsto k l atTop) :\n    SuperpolynomialDecay l k f \u2194 \u2200 z : \u2124, f =o[l] fun a : \u03b1 => k a ^ z", "start": [352, 1], "end": [362, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Complex/AbsMax.lean", "imports": ["Mathlib/Topology/Algebra/Order/ExtrClosure.lean", "Mathlib/Analysis/NormedSpace/Extr.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Complex/CauchyIntegral.lean", "Mathlib/Analysis/NormedSpace/Completion.lean"], "premises": [{"full_name": "Complex.norm_max_aux\u2081", "code": "theorem norm_max_aux\u2081 [CompleteSpace F] {f : \u2102 \u2192 F} {z w : \u2102}\n    (hd : DiffContOnCl \u2102 f (ball z (dist w z)))\n    (hz : IsMaxOn (norm \u2218 f) (closedBall z (dist w z)) z) : \u2016f w\u2016 = \u2016f z\u2016", "start": [106, 1], "end": [137, 40], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_max_aux\u2082", "code": "theorem norm_max_aux\u2082 {f : \u2102 \u2192 F} {z w : \u2102} (hd : DiffContOnCl \u2102 f (ball z (dist w z)))\n    (hz : IsMaxOn (norm \u2218 f) (closedBall z (dist w z)) z) : \u2016f w\u2016 = \u2016f z\u2016", "start": [144, 1], "end": [151, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_max_aux\u2083", "code": "theorem norm_max_aux\u2083 {f : \u2102 \u2192 F} {z w : \u2102} {r : \u211d} (hr : dist w z = r)\n    (hd : DiffContOnCl \u2102 f (ball z r)) (hz : IsMaxOn (norm \u2218 f) (ball z r) z) : \u2016f w\u2016 = \u2016f z\u2016", "start": [159, 1], "end": [164, 80], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eqOn_closedBall_of_isMaxOn", "code": "theorem norm_eqOn_closedBall_of_isMaxOn {f : E \u2192 F} {z : E} {r : \u211d}\n    (hd : DiffContOnCl \u2102 f (ball z r)) (hz : IsMaxOn (norm \u2218 f) (ball z r) z) :\n    EqOn (norm \u2218 f) (const E \u2016f z\u2016) (closedBall z r)", "start": [178, 1], "end": [196, 54], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eq_norm_of_isMaxOn_of_ball_subset", "code": "theorem norm_eq_norm_of_isMaxOn_of_ball_subset {f : E \u2192 F} {s : Set E} {z w : E}\n    (hd : DiffContOnCl \u2102 f s) (hz : IsMaxOn (norm \u2218 f) s z) (hsub : ball z (dist w z) \u2286 s) :\n    \u2016f w\u2016 = \u2016f z\u2016", "start": [199, 1], "end": [205, 95], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eventually_eq_of_isLocalMax", "code": "theorem norm_eventually_eq_of_isLocalMax {f : E \u2192 F} {c : E}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, \u2016f y\u2016 = \u2016f c\u2016", "start": [208, 1], "end": [218, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.isOpen_setOf_mem_nhds_and_isMaxOn_norm", "code": "theorem isOpen_setOf_mem_nhds_and_isMaxOn_norm {f : E \u2192 F} {s : Set E}\n    (hd : DifferentiableOn \u2102 f s) : IsOpen {z | s \u2208 \ud835\udcdd z \u2227 IsMaxOn (norm \u2218 f) s z}", "start": [221, 1], "end": [226, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eqOn_of_isPreconnected_of_isMaxOn", "code": "theorem norm_eqOn_of_isPreconnected_of_isMaxOn {f : E \u2192 F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn \u2102 f U) (hcU : c \u2208 U)\n    (hm : IsMaxOn (norm \u2218 f) U c) : EqOn (norm \u2218 f) (const E \u2016f c\u2016) U", "start": [229, 1], "end": [248, 62], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_eqOn_closure_of_isPreconnected_of_isMaxOn", "code": "theorem norm_eqOn_closure_of_isPreconnected_of_isMaxOn {f : E \u2192 F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl \u2102 f U) (hcU : c \u2208 U)\n    (hm : IsMaxOn (norm \u2218 f) U c) : EqOn (norm \u2218 f) (const E \u2016f c\u2016) (closure U)", "start": [251, 1], "end": [259, 70], "kind": "commanddeclaration"}, {"full_name": "Complex.eqOn_of_isPreconnected_of_isMaxOn_norm", "code": "theorem eqOn_of_isPreconnected_of_isMaxOn_norm {f : E \u2192 F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DifferentiableOn \u2102 f U) (hcU : c \u2208 U)\n    (hm : IsMaxOn (norm \u2218 f) U c) : EqOn f (const E (f c)) U", "start": [278, 1], "end": [289, 97], "kind": "commanddeclaration"}, {"full_name": "Complex.eqOn_closure_of_isPreconnected_of_isMaxOn_norm", "code": "theorem eqOn_closure_of_isPreconnected_of_isMaxOn_norm {f : E \u2192 F} {U : Set E} {c : E}\n    (hc : IsPreconnected U) (ho : IsOpen U) (hd : DiffContOnCl \u2102 f U) (hcU : c \u2208 U)\n    (hm : IsMaxOn (norm \u2218 f) U c) : EqOn f (const E (f c)) (closure U)", "start": [292, 1], "end": [300, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.eq_of_isMaxOn_of_ball_subset", "code": "theorem eq_of_isMaxOn_of_ball_subset {f : E \u2192 F} {s : Set E} {z w : E} (hd : DiffContOnCl \u2102 f s)\n    (hz : IsMaxOn (norm \u2218 f) s z) (hsub : ball z (dist w z) \u2286 s) : f w = f z", "start": [303, 1], "end": [313, 81], "kind": "commanddeclaration"}, {"full_name": "Complex.eqOn_closedBall_of_isMaxOn_norm", "code": "theorem eqOn_closedBall_of_isMaxOn_norm {f : E \u2192 F} {z : E} {r : \u211d}\n    (hd : DiffContOnCl \u2102 f (ball z r)) (hz : IsMaxOn (norm \u2218 f) (ball z r) z) :\n    EqOn f (const E (f z)) (closedBall z r)", "start": [316, 1], "end": [327, 60], "kind": "commanddeclaration"}, {"full_name": "Complex.eventually_eq_of_isLocalMax_norm", "code": "theorem eventually_eq_of_isLocalMax_norm {f : E \u2192 F} {c : E}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, f y = f c", "start": [330, 1], "end": [340, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.eventually_eq_or_eq_zero_of_isLocalMin_norm", "code": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm {f : E \u2192 \u2102} {c : E}\n    (hf : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) :\n    (\u2200\u1da0 z in \ud835\udcdd c, f z = f c) \u2228 f c = 0", "start": [343, 1], "end": [351, 82], "kind": "commanddeclaration"}, {"full_name": "Complex.exists_mem_frontier_isMaxOn_norm", "code": "theorem exists_mem_frontier_isMaxOn_norm [FiniteDimensional \u2102 E] {f : E \u2192 F} {U : Set E}\n    (hb : IsBounded U) (hne : U.Nonempty) (hd : DiffContOnCl \u2102 f U) :\n    \u2203 z \u2208 frontier U, IsMaxOn (norm \u2218 f) (closure U) z", "start": [366, 1], "end": [382, 56], "kind": "commanddeclaration"}, {"full_name": "Complex.norm_le_of_forall_mem_frontier_norm_le", "code": "theorem norm_le_of_forall_mem_frontier_norm_le {f : E \u2192 F} {U : Set E} (hU : IsBounded U)\n    (hd : DiffContOnCl \u2102 f U) {C : \u211d} (hC : \u2200 z \u2208 frontier U, \u2016f z\u2016 \u2264 C) {z : E}\n    (hz : z \u2208 closure U) : \u2016f z\u2016 \u2264 C", "start": [385, 1], "end": [406, 66], "kind": "commanddeclaration"}, {"full_name": "Complex.eqOn_closure_of_eqOn_frontier", "code": "theorem eqOn_closure_of_eqOn_frontier {f g : E \u2192 F} {U : Set E} (hU : IsBounded U)\n    (hf : DiffContOnCl \u2102 f U) (hg : DiffContOnCl \u2102 g U) (hfg : EqOn f g (frontier U)) :\n    EqOn f g (closure U)", "start": [409, 1], "end": [416, 16], "kind": "commanddeclaration"}, {"full_name": "Complex.eqOn_of_eqOn_frontier", "code": "theorem eqOn_of_eqOn_frontier {f g : E \u2192 F} {U : Set E} (hU : IsBounded U) (hf : DiffContOnCl \u2102 f U)\n    (hg : DiffContOnCl \u2102 g U) (hfg : EqOn f g (frontier U)) : EqOn f g U", "start": [419, 1], "end": [423, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat/Monoidal.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/Transport.lean", "Mathlib/LinearAlgebra/QuadraticForm/TensorProduct/Isometries.lean", "Mathlib/LinearAlgebra/QuadraticForm/QuadraticModuleCat.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/ModuleCat/Monoidal/Basic.lean"], "premises": [{"full_name": "QuadraticModuleCat.instMonoidalCategory.tensorObj", "code": "@[simps! form]\nnoncomputable abbrev tensorObj (X Y : QuadraticModuleCat.{u} R) : QuadraticModuleCat.{u} R :=\n  of (X.form.tmul Y.form)", "start": [42, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instMonoidalCategory.tensorHom", "code": "noncomputable abbrev tensorHom {W X Y Z : QuadraticModuleCat.{u} R} (f : W \u27f6 X) (g : Y \u27f6 Z) :\n    tensorObj W Y \u27f6 tensorObj X Z :=\n  \u27e8f.toIsometry.tmul g.toIsometry\u27e9", "start": [47, 1], "end": [52, 35], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instMonoidalCategory.associator", "code": "noncomputable abbrev associator (X Y Z : QuadraticModuleCat.{u} R) :\n    tensorObj (tensorObj X Y) Z \u2245 tensorObj X (tensorObj Y Z) :=\n  ofIso (tensorAssoc X.form Y.form Z.form)", "start": [54, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instMonoidalCategory.forget\u2082_map_associator_hom", "code": "theorem forget\u2082_map_associator_hom (X Y Z : QuadraticModuleCat.{u} R) :\n    (forget\u2082 (QuadraticModuleCat R) (ModuleCat R)).map (associator X Y Z).hom =\n      (\u03b1_ X.toModuleCat Y.toModuleCat Z.toModuleCat).hom", "start": [61, 1], "end": [63, 64], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instMonoidalCategory.forget\u2082_map_associator_inv", "code": "theorem forget\u2082_map_associator_inv (X Y Z : QuadraticModuleCat.{u} R) :\n    (forget\u2082 (QuadraticModuleCat R) (ModuleCat R)).map (associator X Y Z).inv =\n      (\u03b1_ X.toModuleCat Y.toModuleCat Z.toModuleCat).inv", "start": [65, 1], "end": [67, 64], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.instMonoidalCategory", "code": "noncomputable instance instMonoidalCategory : MonoidalCategory (QuadraticModuleCat.{u} R) :=\n  Monoidal.induced\n    (forget\u2082 (QuadraticModuleCat R) (ModuleCat R))\n    { tensorObj := instMonoidalCategory.tensorObj\n      \u03bcIsoSymm := fun X Y => Iso.refl _\n      whiskerLeft := fun X _ _ f => tensorHom (\ud835\udfd9 _) f\n      whiskerRight := @fun X\u2081 X\u2082 (f : X\u2081 \u27f6 X\u2082) Y => tensorHom f (\ud835\udfd9 _)\n      tensorHom := tensorHom\n      tensorUnit' := of (sq (R := R))\n      \u03b5IsoSymm := Iso.refl _\n      associator := associator\n      associator_eq := fun X Y Z => by\n        dsimp only [forget\u2082_obj, forget\u2082_map_associator_hom]\n        simp only [eqToIso_refl, Iso.refl_trans, Iso.refl_symm, Iso.trans_hom, tensorIso_hom,\n          Iso.refl_hom, MonoidalCategory.tensor_id]\n        erw [Category.id_comp, Category.comp_id, MonoidalCategory.tensor_id, Category.comp_id]\n        rfl\n      leftUnitor := fun X => ofIso (tensorLId X.form)\n      rightUnitor := fun X => ofIso (tensorRId X.form) }", "start": [73, 1], "end": [91, 57], "kind": "commanddeclaration"}, {"full_name": "QuadraticModuleCat.toModuleCatMonoidalFunctor", "code": "def toModuleCatMonoidalFunctor : MonoidalFunctor (QuadraticModuleCat.{u} R) (ModuleCat.{u} R) :=\n  Monoidal.fromInduced (forget\u2082 (QuadraticModuleCat R) (ModuleCat R)) _", "start": [94, 1], "end": [96, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "imports": ["Mathlib/Data/ZMod/Basic.lean", "Mathlib/GroupTheory/Exponent.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DihedralGroup", "code": "inductive DihedralGroup (n : \u2115) : Type\n  | r : ZMod n \u2192 DihedralGroup n\n  | sr : ZMod n \u2192 DihedralGroup n\n  deriving DecidableEq", "start": [22, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.mul", "code": "private def mul : DihedralGroup n \u2192 DihedralGroup n \u2192 DihedralGroup n\n  | r i, r j => r (i + j)\n  | r i, sr j => sr (j - i)\n  | sr i, r j => sr (i + j)\n  | sr i, sr j => r (j - i)", "start": [36, 1], "end": [42, 28], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.one", "code": "private def one : DihedralGroup n :=\n  r 0", "start": [44, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.inv", "code": "private def inv : DihedralGroup n \u2192 DihedralGroup n\n  | r i => r (-i)\n  | sr i => sr i", "start": [52, 1], "end": [56, 17], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.r_mul_r", "code": "@[simp]\ntheorem r_mul_r (i j : ZMod n) : r i * r j = r (i + j)", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.r_mul_sr", "code": "@[simp]\ntheorem r_mul_sr (i j : ZMod n) : r i * sr j = sr (j - i)", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.sr_mul_r", "code": "@[simp]\ntheorem sr_mul_r (i j : ZMod n) : sr i * r j = sr (i + j)", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.sr_mul_sr", "code": "@[simp]\ntheorem sr_mul_sr (i j : ZMod n) : sr i * sr j = r (j - i)", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.one_def", "code": "theorem one_def : (1 : DihedralGroup n) = r 0", "start": [98, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.fintypeHelper", "code": "private def fintypeHelper : Sum (ZMod n) (ZMod n) \u2243 DihedralGroup n where\n  invFun i := match i with\n    | r j => Sum.inl j\n    | sr j => Sum.inr j\n  toFun i := match i with\n    | Sum.inl j => r j\n    | Sum.inr j => sr j\n  left_inv := by rintro (x | x) <;> rfl\n  right_inv := by rintro (x | x) <;> rfl", "start": [102, 1], "end": [110, 41], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.card", "code": "theorem card [NeZero n] : Fintype.card (DihedralGroup n) = 2 * n", "start": [123, 1], "end": [126, 83], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.nat_card", "code": "theorem nat_card : Nat.card (DihedralGroup n) = 2 * n", "start": [129, 1], "end": [132, 40], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.r_one_pow", "code": "@[simp]\ntheorem r_one_pow (k : \u2115) : (r 1 : DihedralGroup n) ^ k = r k", "start": [134, 1], "end": [142, 21], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.r_one_pow_n", "code": "theorem r_one_pow_n : r (1 : ZMod n) ^ n = 1", "start": [146, 1], "end": [149, 29], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.sr_mul_self", "code": "theorem sr_mul_self (i : ZMod n) : sr i * sr i = 1", "start": [153, 1], "end": [153, 91], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.orderOf_sr", "code": "@[simp]\ntheorem orderOf_sr (i : ZMod n) : orderOf (sr i) = 2", "start": [156, 1], "end": [164, 43], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.orderOf_r_one", "code": "@[simp]\ntheorem orderOf_r_one : orderOf (r 1 : DihedralGroup n) = n", "start": [167, 1], "end": [184, 44], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.orderOf_r", "code": "theorem orderOf_r [NeZero n] (i : ZMod n) : orderOf (r i) = n / Nat.gcd n i.val", "start": [187, 1], "end": [191, 47], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.exponent", "code": "theorem exponent : Monoid.exponent (DihedralGroup n) = lcm n 2", "start": [194, 1], "end": [209, 32], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.OddCommuteEquiv", "code": "@[simps]\ndef OddCommuteEquiv (hn : Odd n) : { p : DihedralGroup n \u00d7 DihedralGroup n // Commute p.1 p.2 } \u2243\n    ZMod n \u2295 ZMod n \u2295 ZMod n \u2295 ZMod n \u00d7 ZMod n :=\n  let u := ZMod.unitOfCoprime 2 (Nat.prime_two.coprime_iff_not_dvd.mpr hn.not_two_dvd_nat)\n  have hu : \u2200 a : ZMod n, a + a = 0 \u2194 a = 0 := fun a => ZMod.add_self_eq_zero_iff_eq_zero hn\n  { toFun := fun\n      | \u27e8\u27e8sr i, r _\u27e9, _\u27e9 => Sum.inl i\n      | \u27e8\u27e8r _, sr j\u27e9, _\u27e9 => Sum.inr (Sum.inl j)\n      | \u27e8\u27e8sr i, sr j\u27e9, _\u27e9 => Sum.inr (Sum.inr (Sum.inl (i + j)))\n      | \u27e8\u27e8r i, r j\u27e9, _\u27e9 => Sum.inr (Sum.inr (Sum.inr \u27e8i, j\u27e9))\n    invFun := fun\n      | .inl i => \u27e8\u27e8sr i, r 0\u27e9, congrArg sr ((add_zero i).trans (sub_zero i).symm)\u27e9\n      | .inr (.inl j) => \u27e8\u27e8r 0, sr j\u27e9, congrArg sr ((sub_zero j).trans (add_zero j).symm)\u27e9\n      | .inr (.inr (.inl k)) => \u27e8\u27e8sr (u\u207b\u00b9 * k), sr (u\u207b\u00b9 * k)\u27e9, rfl\u27e9\n      | .inr (.inr (.inr \u27e8i, j\u27e9)) => \u27e8\u27e8r i, r j\u27e9, congrArg r (add_comm i j)\u27e9\n    left_inv := fun\n      | \u27e8\u27e8r i, r j\u27e9, h\u27e9 => rfl\n      | \u27e8\u27e8r i, sr j\u27e9, h\u27e9 => by\n        simpa [sub_eq_add_neg, neg_eq_iff_add_eq_zero, hu, eq_comm (a := i) (b := 0)] using h.eq\n      | \u27e8\u27e8sr i, r j\u27e9, h\u27e9 => by\n        simpa [sub_eq_add_neg, eq_neg_iff_add_eq_zero, hu, eq_comm (a := j) (b := 0)] using h.eq\n      | \u27e8\u27e8sr i, sr j\u27e9, h\u27e9 => by\n        replace h := r.inj h\n        rw [\u2190neg_sub, neg_eq_iff_add_eq_zero, hu, sub_eq_zero] at h\n        rw [Subtype.ext_iff, Prod.ext_iff, sr.injEq, sr.injEq, h, and_self, \u2190two_mul]\n        exact u.inv_mul_cancel_left j\n    right_inv := fun\n      | .inl i => rfl\n      | .inr (.inl j) => rfl\n      | .inr (.inr (.inl k)) =>\n        congrArg (Sum.inr \u2218 Sum.inr \u2218 Sum.inl) $ two_mul (u\u207b\u00b9 * k) \u25b8 u.mul_inv_cancel_left k\n      | .inr (.inr (.inr \u27e8i, j\u27e9)) => rfl }", "start": [212, 1], "end": [245, 43], "kind": "commanddeclaration"}, {"full_name": "DihedralGroup.card_commute_odd", "code": "lemma card_commute_odd (hn : Odd n) :\n    Nat.card { p : DihedralGroup n \u00d7 DihedralGroup n // Commute p.1 p.2 } = n * (n + 3) := by\n  have hn' : NeZero n := \u27e8hn.pos.ne'\u27e9\n  simp_rw [Nat.card_congr (OddCommuteEquiv hn), Nat.card_sum, Nat.card_prod, Nat.card_zmod]\n  ring", "start": [247, 1], "end": [252, 7], "kind": "mathlibtacticlemma"}, {"full_name": "DihedralGroup.card_conjClasses_odd", "code": "lemma card_conjClasses_odd (hn : Odd n) :\n    Nat.card (ConjClasses (DihedralGroup n)) = (n + 3) / 2 := by\n  rw [\u2190Nat.mul_div_mul_left _ 2 hn.pos, \u2190 card_commute_odd hn, mul_comm,\n    card_comm_eq_card_conjClasses_mul_card, nat_card, Nat.mul_div_left _ (mul_pos two_pos hn.pos)]", "start": [254, 1], "end": [257, 99], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/PellMatiyasevic.lean", "imports": ["Mathlib/Tactic/Monotonicity.lean", "Mathlib/NumberTheory/Zsqrtd/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/ModEq.lean", "Mathlib/Algebra/Star/Unitary.lean"], "premises": [{"full_name": "Pell.IsPell", "code": "def IsPell : \u2124\u221ad \u2192 Prop\n  | \u27e8x, y\u27e9 => x * x - d * y * y = 1", "start": [63, 1], "end": [66, 36], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_norm", "code": "theorem isPell_norm : \u2200 {b : \u2124\u221ad}, IsPell b \u2194 b * star b = 1", "start": [69, 1], "end": [70, 62], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_iff_mem_unitary", "code": "theorem isPell_iff_mem_unitary : \u2200 {b : \u2124\u221ad}, IsPell b \u2194 b \u2208 unitary (\u2124\u221ad)", "start": [73, 1], "end": [74, 84], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_mul", "code": "theorem isPell_mul {b c : \u2124\u221ad} (hb : IsPell b) (hc : IsPell c) : IsPell (b * c)", "start": [77, 1], "end": [79, 51], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_star", "code": "theorem isPell_star : \u2200 {b : \u2124\u221ad}, IsPell b \u2194 IsPell (star b)", "start": [82, 1], "end": [83, 47], "kind": "commanddeclaration"}, {"full_name": "Pell.d", "code": "private def d (_a1 : 1 < a) :=\n  a * a - 1", "start": [93, 1], "end": [94, 12], "kind": "commanddeclaration"}, {"full_name": "Pell.d_pos", "code": "@[simp]\ntheorem d_pos : 0 < d a1", "start": [96, 1], "end": [98, 91], "kind": "commanddeclaration"}, {"full_name": "Pell.pell", "code": "def pell : \u2115 \u2192 \u2115 \u00d7 \u2115\n  | 0 => (1, 0)\n  | n+1 => ((pell n).1 * a + d a1 * (pell n).2, (pell n).1 + (pell n).2 * a)", "start": [102, 1], "end": [108, 77], "kind": "commanddeclaration"}, {"full_name": "Pell.xn", "code": "def xn (n : \u2115) : \u2115 :=\n  (pell a1 n).1", "start": [111, 1], "end": [113, 16], "kind": "commanddeclaration"}, {"full_name": "Pell.yn", "code": "def yn (n : \u2115) : \u2115 :=\n  (pell a1 n).2", "start": [116, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "Pell.pell_val", "code": "@[simp]\ntheorem pell_val (n : \u2115) : pell a1 n = (xn a1 n, yn a1 n)", "start": [121, 1], "end": [125, 20], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_zero", "code": "@[simp]\ntheorem xn_zero : xn a1 0 = 1", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_zero", "code": "@[simp]\ntheorem yn_zero : yn a1 0 = 0", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_succ", "code": "@[simp]\ntheorem xn_succ (n : \u2115) : xn a1 (n + 1) = xn a1 n * a + d a1 * yn a1 n", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_succ", "code": "@[simp]\ntheorem yn_succ (n : \u2115) : yn a1 (n + 1) = xn a1 n + yn a1 n * a", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_one", "code": "theorem xn_one : xn a1 1 = a", "start": [149, 1], "end": [149, 40], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_one", "code": "theorem yn_one : yn a1 1 = 1", "start": [153, 1], "end": [153, 40], "kind": "commanddeclaration"}, {"full_name": "Pell.xz", "code": "def xz (n : \u2115) : \u2124 :=\n  xn a1 n", "start": [156, 1], "end": [158, 10], "kind": "commanddeclaration"}, {"full_name": "Pell.yz", "code": "def yz (n : \u2115) : \u2124 :=\n  yn a1 n", "start": [161, 1], "end": [163, 10], "kind": "commanddeclaration"}, {"full_name": "Pell.az", "code": "def az (a : \u2115) : \u2124 :=\n  a", "start": [168, 1], "end": [170, 4], "kind": "commanddeclaration"}, {"full_name": "Pell.asq_pos", "code": "theorem asq_pos : 0 < a * a", "start": [175, 1], "end": [177, 81], "kind": "commanddeclaration"}, {"full_name": "Pell.dz_val", "code": "theorem dz_val : \u2191(d a1) = az a * az a - 1", "start": [180, 1], "end": [182, 42], "kind": "commanddeclaration"}, {"full_name": "Pell.xz_succ", "code": "@[simp]\ntheorem xz_succ (n : \u2115) : (xz a1 (n + 1)) = xz a1 n * az a + d a1 * yz a1 n", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.yz_succ", "code": "@[simp]\ntheorem yz_succ (n : \u2115) : yz a1 (n + 1) = xz a1 n + yz a1 n * az a", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd", "code": "def pellZd (n : \u2115) : \u2124\u221a(d a1) :=\n  \u27e8xn a1 n, yn a1 n\u27e9", "start": [195, 1], "end": [197, 21], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_re", "code": "@[simp]\ntheorem pellZd_re (n : \u2115) : (pellZd a1 n).re = xn a1 n", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_im", "code": "@[simp]\ntheorem pellZd_im (n : \u2115) : (pellZd a1 n).im = yn a1 n", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_nat", "code": "theorem isPell_nat {x y : \u2115} : IsPell (\u27e8x, y\u27e9 : \u2124\u221a(d a1)) \u2194 x * x - d a1 * y * y = 1", "start": [210, 1], "end": [216, 75], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_succ", "code": "@[simp]\ntheorem pellZd_succ (n : \u2115) : pellZd a1 (n + 1) = pellZd a1 n * \u27e8a, 1\u27e9", "start": [219, 1], "end": [220, 95], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_one", "code": "theorem isPell_one : IsPell (\u27e8a, 1\u27e9 : \u2124\u221a(d a1))", "start": [223, 1], "end": [224, 55], "kind": "commanddeclaration"}, {"full_name": "Pell.isPell_pellZd", "code": "theorem isPell_pellZd : \u2200 n : \u2115, IsPell (pellZd a1 n)", "start": [227, 1], "end": [231, 52], "kind": "commanddeclaration"}, {"full_name": "Pell.pell_eqz", "code": "@[simp]\ntheorem pell_eqz (n : \u2115) : xz a1 n * xz a1 n - d a1 * yz a1 n * yz a1 n = 1", "start": [234, 1], "end": [236, 21], "kind": "commanddeclaration"}, {"full_name": "Pell.pell_eq", "code": "@[simp]\ntheorem pell_eq (n : \u2115) : xn a1 n * xn a1 n - d a1 * yn a1 n * yn a1 n = 1", "start": [239, 1], "end": [246, 53], "kind": "commanddeclaration"}, {"full_name": "Pell.dnsq", "code": "instance dnsq : Zsqrtd.Nonsquare (d a1) :=\n  \u27e8fun n h =>\n    have : n * n + 1 = a * a := by rw [\u2190 h]; exact Nat.succ_pred_eq_of_pos (asq_pos a1)\n    have na : n < a := Nat.mul_self_lt_mul_self_iff.2 (by rw [\u2190 this]; exact Nat.lt_succ_self _)\n    have : (n + 1) * (n + 1) \u2264 n * n + 1 := by rw [this]; exact Nat.mul_self_le_mul_self na\n    have : n + n \u2264 0 :=\n      @Nat.le_of_add_le_add_right _ (n * n + 1) _ (by ring_nf at this \u22a2; assumption)\n    Nat.ne_of_gt (d_pos a1) <| by\n      rwa [Nat.eq_zero_of_le_zero ((Nat.le_add_left _ _).trans this)] at h\u27e9", "start": [249, 1], "end": [257, 76], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_ge_a_pow", "code": "theorem xn_ge_a_pow : \u2200 n : \u2115, a ^ n \u2264 xn a1 n", "start": [260, 1], "end": [264, 83], "kind": "commanddeclaration"}, {"full_name": "Pell.n_lt_a_pow", "code": "theorem n_lt_a_pow : \u2200 n : \u2115, n < a ^ n", "start": [267, 1], "end": [276, 72], "kind": "commanddeclaration"}, {"full_name": "Pell.n_lt_xn", "code": "theorem n_lt_xn (n) : n < xn a1 n", "start": [279, 1], "end": [280, 54], "kind": "commanddeclaration"}, {"full_name": "Pell.x_pos", "code": "theorem x_pos (n) : 0 < xn a1 n", "start": [283, 1], "end": [284, 48], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_pell_lem", "code": "theorem eq_pell_lem : \u2200 (n) (b : \u2124\u221a(d a1)), 1 \u2264 b \u2192 IsPell b \u2192\n    b \u2264 pellZd a1 n \u2192 \u2203 n, b = pellZd a1 n", "start": [287, 1], "end": [331, 49], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_pellZd", "code": "theorem eq_pellZd (b : \u2124\u221a(d a1)) (b1 : 1 \u2264 b) (hp : IsPell b) : \u2203 n, b = pellZd a1 n", "start": [334, 1], "end": [341, 32], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_pell", "code": "theorem eq_pell {x y : \u2115} (hp : x * x - d a1 * y * y = 1) : \u2203 n, x = xn a1 n \u2227 y = yn a1 n", "start": [344, 1], "end": [355, 31], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_add", "code": "theorem pellZd_add (m) : \u2200 n, pellZd a1 (m + n) = pellZd a1 m * pellZd a1 n", "start": [358, 1], "end": [360, 88], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_add", "code": "theorem xn_add (m n) : xn a1 (m + n) = xn a1 m * xn a1 n + d a1 * yn a1 m * yn a1 n", "start": [363, 1], "end": [367, 16], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_add", "code": "theorem yn_add (m n) : yn a1 (m + n) = xn a1 m * yn a1 n + yn a1 m * xn a1 n", "start": [370, 1], "end": [374, 16], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_sub", "code": "theorem pellZd_sub {m n} (h : n \u2264 m) : pellZd a1 (m - n) = pellZd a1 m * star (pellZd a1 n)", "start": [377, 1], "end": [380, 89], "kind": "commanddeclaration"}, {"full_name": "Pell.xz_sub", "code": "theorem xz_sub {m n} (h : n \u2264 m) :\n    xz a1 (m - n) = xz a1 m * xz a1 n - d a1 * yz a1 m * yz a1 n", "start": [383, 1], "end": [386, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.yz_sub", "code": "theorem yz_sub {m n} (h : n \u2264 m) : yz a1 (m - n) = xz a1 n * yz a1 m - xz a1 m * yz a1 n", "start": [389, 1], "end": [391, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.xy_coprime", "code": "theorem xy_coprime (n) : (xn a1 n).Coprime (yn a1 n)", "start": [394, 1], "end": [398, 92], "kind": "commanddeclaration"}, {"full_name": "Pell.strictMono_y", "code": "theorem strictMono_y : StrictMono (yn a1)", "start": [401, 1], "end": [409, 72], "kind": "commanddeclaration"}, {"full_name": "Pell.strictMono_x", "code": "theorem strictMono_x : StrictMono (xn a1)", "start": [412, 1], "end": [420, 23], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_ge_n", "code": "theorem yn_ge_n : \u2200 n, n \u2264 yn a1 n", "start": [423, 1], "end": [426, 99], "kind": "commanddeclaration"}, {"full_name": "Pell.y_mul_dvd", "code": "theorem y_mul_dvd (n) : \u2200 k, yn a1 n \u2223 yn a1 (n * k)", "start": [429, 1], "end": [432, 94], "kind": "commanddeclaration"}, {"full_name": "Pell.y_dvd_iff", "code": "theorem y_dvd_iff (m n) : yn a1 m \u2223 yn a1 n \u2194 m \u2223 n", "start": [435, 1], "end": [451, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.xy_modEq_yn", "code": "theorem xy_modEq_yn (n) :\n    \u2200 k, xn a1 (n * k) \u2261 xn a1 n ^ k [MOD yn a1 n ^ 2] \u2227 yn a1 (n * k) \u2261\n        k * xn a1 n ^ (k - 1) * yn a1 n [MOD yn a1 n ^ 3]", "start": [454, 1], "end": [484, 17], "kind": "commanddeclaration"}, {"full_name": "Pell.ysq_dvd_yy", "code": "theorem ysq_dvd_yy (n) : yn a1 n * yn a1 n \u2223 yn a1 (n * yn a1 n)", "start": [487, 1], "end": [490, 70], "kind": "commanddeclaration"}, {"full_name": "Pell.dvd_of_ysq_dvd", "code": "theorem dvd_of_ysq_dvd {n t} (h : yn a1 n * yn a1 n \u2223 yn a1 t) : yn a1 n \u2223 t", "start": [493, 1], "end": [503, 96], "kind": "commanddeclaration"}, {"full_name": "Pell.pellZd_succ_succ", "code": "theorem pellZd_succ_succ (n) :\n    pellZd a1 (n + 2) + pellZd a1 n = (2 * a : \u2115) * pellZd a1 (n + 1)", "start": [506, 1], "end": [516, 92], "kind": "commanddeclaration"}, {"full_name": "Pell.xy_succ_succ", "code": "theorem xy_succ_succ (n) :\n    xn a1 (n + 2) + xn a1 n =\n      2 * a * xn a1 (n + 1) \u2227 yn a1 (n + 2) + yn a1 n = 2 * a * yn a1 (n + 1)", "start": [519, 1], "end": [525, 75], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_succ_succ", "code": "theorem xn_succ_succ (n) : xn a1 (n + 2) + xn a1 n = 2 * a * xn a1 (n + 1)", "start": [528, 1], "end": [529, 24], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_succ_succ", "code": "theorem yn_succ_succ (n) : yn a1 (n + 2) + yn a1 n = 2 * a * yn a1 (n + 1)", "start": [532, 1], "end": [533, 24], "kind": "commanddeclaration"}, {"full_name": "Pell.xz_succ_succ", "code": "theorem xz_succ_succ (n) : xz a1 (n + 2) = (2 * a : \u2115) * xz a1 (n + 1) - xz a1 n", "start": [536, 1], "end": [537, 87], "kind": "commanddeclaration"}, {"full_name": "Pell.yz_succ_succ", "code": "theorem yz_succ_succ (n) : yz a1 (n + 2) = (2 * a : \u2115) * yz a1 (n + 1) - yz a1 n", "start": [540, 1], "end": [541, 87], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_modEq_a_sub_one", "code": "theorem yn_modEq_a_sub_one : \u2200 n, yn a1 n \u2261 n [MOD a - 1]", "start": [544, 1], "end": [550, 76], "kind": "commanddeclaration"}, {"full_name": "Pell.yn_modEq_two", "code": "theorem yn_modEq_two : \u2200 n, yn a1 n \u2261 n [MOD 2]", "start": [553, 1], "end": [559, 88], "kind": "commanddeclaration"}, {"full_name": "Pell.x_sub_y_dvd_pow_lem", "code": "theorem x_sub_y_dvd_pow_lem (y2 y1 y0 yn1 yn0 xn1 xn0 ay a2 : \u2124) :\n    (a2 * yn1 - yn0) * ay + y2 - (a2 * xn1 - xn0) =\n      y2 - a2 * y1 + y0 + a2 * (yn1 * ay + y1 - xn1) - (yn0 * ay + y0 - xn0)", "start": [564, 1], "end": [567, 10], "kind": "commanddeclaration"}, {"full_name": "Pell.x_sub_y_dvd_pow", "code": "theorem x_sub_y_dvd_pow (y : \u2115) :\n    \u2200 n, (2 * a * y - y * y - 1 : \u2124) \u2223 yz a1 n * (a - y) + \u2191(y ^ n) - xz a1 n", "start": [572, 1], "end": [584, 28], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x2n_add_lem", "code": "theorem xn_modEq_x2n_add_lem (n j) : xn a1 n \u2223 d a1 * yn a1 n * (yn a1 n * xn a1 j) + xn a1 j", "start": [587, 1], "end": [594, 61], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x2n_add", "code": "theorem xn_modEq_x2n_add (n j) : xn a1 (2 * n + j) + xn a1 j \u2261 0 [MOD xn a1 n]", "start": [597, 1], "end": [602, 100], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x2n_sub_lem", "code": "theorem xn_modEq_x2n_sub_lem {n j} (h : j \u2264 n) : xn a1 (2 * n - j) + xn a1 j \u2261 0 [MOD xn a1 n]", "start": [605, 1], "end": [618, 71], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x2n_sub", "code": "theorem xn_modEq_x2n_sub {n j} (h : j \u2264 2 * n) : xn a1 (2 * n - j) + xn a1 j \u2261 0 [MOD xn a1 n]", "start": [621, 1], "end": [626, 50], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x4n_add", "code": "theorem xn_modEq_x4n_add (n j) : xn a1 (4 * n + j) \u2261 xn a1 j [MOD xn a1 n]", "start": [629, 1], "end": [633, 27], "kind": "commanddeclaration"}, {"full_name": "Pell.xn_modEq_x4n_sub", "code": "theorem xn_modEq_x4n_sub {n j} (h : j \u2264 2 * n) : xn a1 (4 * n - j) \u2261 xn a1 j [MOD xn a1 n]", "start": [636, 1], "end": [641, 27], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq_lem1", "code": "theorem eq_of_xn_modEq_lem1 {i n} : \u2200 {j}, i < j \u2192 j < n \u2192 xn a1 i % xn a1 n < xn a1 j % xn a1 n", "start": [644, 1], "end": [653, 46], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq_lem2", "code": "theorem eq_of_xn_modEq_lem2 {n} (h : 2 * xn a1 n = xn a1 (n + 1)) : a = 2 \u2227 n = 0", "start": [656, 1], "end": [664, 45], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq_lem3", "code": "theorem eq_of_xn_modEq_lem3 {i n} (npos : 0 < n) :\n    \u2200 {j}, i < j \u2192 j \u2264 2 * n \u2192 j \u2260 n \u2192 \u00ac(a = 2 \u2227 n = 1 \u2227 i = 0 \u2227 j = 2) \u2192\n        xn a1 i % xn a1 n < xn a1 j % xn a1 n", "start": [667, 1], "end": [741, 70], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq_le", "code": "theorem eq_of_xn_modEq_le {i j n} (ij : i \u2264 j) (j2n : j \u2264 2 * n)\n    (h : xn a1 i \u2261 xn a1 j [MOD xn a1 n])\n    (ntriv : \u00ac(a = 2 \u2227 n = 1 \u2227 i = 0 \u2227 j = 2)) : i = j", "start": [744, 1], "end": [764, 97], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq", "code": "theorem eq_of_xn_modEq {i j n} (i2n : i \u2264 2 * n) (j2n : j \u2264 2 * n)\n    (h : xn a1 i \u2261 xn a1 j [MOD xn a1 n])\n    (ntriv : a = 2 \u2192 n = 1 \u2192 (i = 0 \u2192 j \u2260 2) \u2227 (i = 2 \u2192 j \u2260 0)) : i = j", "start": [767, 1], "end": [773, 96], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_of_xn_modEq'", "code": "theorem eq_of_xn_modEq' {i j n} (ipos : 0 < i) (hin : i \u2264 n) (j4n : j \u2264 4 * n)\n    (h : xn a1 j \u2261 xn a1 i [MOD xn a1 n]) : j = i \u2228 j + i = 4 * n", "start": [776, 1], "end": [797, 38], "kind": "commanddeclaration"}, {"full_name": "Pell.modEq_of_xn_modEq", "code": "theorem modEq_of_xn_modEq {i j n} (ipos : 0 < i) (hin : i \u2264 n)\n    (h : xn a1 j \u2261 xn a1 i [MOD xn a1 n]) :\n    j \u2261 i [MOD 4 * n] \u2228 j + i \u2261 0 [MOD 4 * n]", "start": [800, 1], "end": [820, 33], "kind": "commanddeclaration"}, {"full_name": "Pell.xy_modEq_of_modEq", "code": "theorem xy_modEq_of_modEq {a b c} (a1 : 1 < a) (b1 : 1 < b) (h : a \u2261 b [MOD c]) :\n    \u2200 n, xn a1 n \u2261 xn b1 n [MOD c] \u2227 yn a1 n \u2261 yn b1 n [MOD c]", "start": [825, 1], "end": [835, 74], "kind": "commanddeclaration"}, {"full_name": "Pell.matiyasevic", "code": "theorem matiyasevic {a k x y} :\n    (\u2203 a1 : 1 < a, xn a1 k = x \u2227 yn a1 k = y) \u2194\n      1 < a \u2227 k \u2264 y \u2227 (x = 1 \u2227 y = 0 \u2228\n        \u2203 u v s t b : \u2115,\n          x * x - (a * a - 1) * y * y = 1 \u2227 u * u - (a * a - 1) * v * v = 1 \u2227\n          s * s - (b * b - 1) * t * t = 1 \u2227 1 < b \u2227 b \u2261 1 [MOD 4 * y] \u2227\n          b \u2261 a [MOD u] \u2227 0 < v \u2227 y * y \u2223 v \u2227 s \u2261 x [MOD u] \u2227 t \u2261 k [MOD 4 * y])", "start": [838, 1], "end": [923, 85], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_pow_of_pell_lem", "code": "theorem eq_pow_of_pell_lem {a y k : \u2115} (hy0 : y \u2260 0) (hk0 : k \u2260 0) (hyk : y ^ k < a) :\n    (\u2191(y ^ k) : \u2124) < 2 * a * y - y * y - 1", "start": [926, 1], "end": [939, 41], "kind": "commanddeclaration"}, {"full_name": "Pell.eq_pow_of_pell", "code": "theorem eq_pow_of_pell {m n k} :\n    n ^ k = m \u2194 k = 0 \u2227 m = 1 \u22280 < k \u2227 (n = 0 \u2227 m = 0 \u2228\n      0 < n \u2227 \u2203 (w a t z : \u2115) (a1 : 1 < a), xn a1 k \u2261 yn a1 k * (a - n) + m [MOD t] \u2227\n      2 * a * n = t + (n * n + 1) \u2227 m < t \u2227\n      n \u2264 w \u2227 k \u2264 w \u2227 a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1)", "start": [942, 1], "end": [1011, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector3.lean", "imports": ["Mathlib/Data/Fin/Fin2.lean", "Mathlib/Mathport/Notation.lean", "Mathlib/Init/Align.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector3", "code": "def Vector3 (\u03b1 : Type u) (n : \u2115) : Type u :=\n  Fin2 n \u2192 \u03b1", "start": [27, 1], "end": [29, 13], "kind": "commanddeclaration"}, {"full_name": "Vector3.nil", "code": "@[match_pattern]\ndef nil : Vector3 \u03b1 0 :=\n  fun.", "start": [37, 1], "end": [40, 7], "kind": "commanddeclaration"}, {"full_name": "Vector3.cons", "code": "@[match_pattern]\ndef cons (a : \u03b1) (v : Vector3 \u03b1 n) : Vector3 \u03b1 (succ n) := fun i => by\n  refine' i.cases' _ _\n  exact a\n  exact v", "start": [43, 1], "end": [48, 10], "kind": "commanddeclaration"}, {"full_name": "Vector3.unexpandNil", "code": "@[app_unexpander Vector3.nil] def unexpandNil : Lean.PrettyPrinter.Unexpander\n  | `($(_)) => `([])", "start": [59, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "Vector3.unexpandCons", "code": "@[app_unexpander Vector3.cons] def unexpandCons : Lean.PrettyPrinter.Unexpander\n  | `($(_) $x [])      => `([$x])\n  | `($(_) $x [$xs,*]) => `([$x, $xs,*])\n  | _                  => throw ()", "start": [63, 1], "end": [66, 35], "kind": "commanddeclaration"}, {"full_name": "Vector3.cons_fz", "code": "@[simp]\ntheorem cons_fz (a : \u03b1) (v : Vector3 \u03b1 n) : (a :: v) fz = a", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.cons_fs", "code": "@[simp]\ntheorem cons_fs (a : \u03b1) (v : Vector3 \u03b1 n) (i) : (a :: v) (fs i) = v i", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.nth", "code": "@[reducible]\ndef nth (i : Fin2 n) (v : Vector3 \u03b1 n) : \u03b1 :=\n  v i", "start": [83, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.ofFn", "code": "@[reducible]\ndef ofFn (f : Fin2 n \u2192 \u03b1) : Vector3 \u03b1 n :=\n  f", "start": [89, 1], "end": [92, 4], "kind": "commanddeclaration"}, {"full_name": "Vector3.head", "code": "def head (v : Vector3 \u03b1 (succ n)) : \u03b1 :=\n  v fz", "start": [95, 1], "end": [97, 7], "kind": "commanddeclaration"}, {"full_name": "Vector3.tail", "code": "def tail (v : Vector3 \u03b1 (succ n)) : Vector3 \u03b1 n := fun i => v (fs i)", "start": [100, 1], "end": [101, 69], "kind": "commanddeclaration"}, {"full_name": "Vector3.eq_nil", "code": "theorem eq_nil (v : Vector3 \u03b1 0) : v = []", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "Vector3.cons_head_tail", "code": "theorem cons_head_tail (v : Vector3 \u03b1 (succ n)) : (head v :: tail v) = v", "start": [108, 1], "end": [109, 51], "kind": "commanddeclaration"}, {"full_name": "Vector3.nilElim", "code": "@[elab_as_elim]  def nilElim {C : Vector3 \u03b1 0 \u2192 Sort u} (H : C []) (v : Vector3 \u03b1 0) : C v := by\n  rw [eq_nil v]; apply H", "start": [112, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "Vector3.consElim", "code": "@[elab_as_elim]  def consElim {C : Vector3 \u03b1 (succ n) \u2192 Sort u} (H : \u2200 (a : \u03b1) (t : Vector3 \u03b1 n), C (a :: t))\n    (v : Vector3 \u03b1 (succ n)) : C v := by rw [\u2190 cons_head_tail v]; apply H", "start": [118, 1], "end": [121, 74], "kind": "commanddeclaration"}, {"full_name": "Vector3.consElim_cons", "code": "@[simp]\ntheorem consElim_cons {C H a t} : @consElim \u03b1 n C H (a :: t) = H a t", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.recOn", "code": "@[elab_as_elim]\nprotected def recOn {C : \u2200 {n}, Vector3 \u03b1 n \u2192 Sort u} {n} (v : Vector3 \u03b1 n) (H0 : C [])\n    (Hs : \u2200 {n} (a) (w : Vector3 \u03b1 n), C w \u2192 C (a :: w)) : C v :=\n  match n with\n  | 0 => v.nilElim H0\n  | _ + 1 => v.consElim fun a t => Hs a t (Vector3.recOn t H0 Hs)", "start": [129, 1], "end": [135, 66], "kind": "commanddeclaration"}, {"full_name": "Vector3.recOn_nil", "code": "@[simp]\ntheorem recOn_nil {C H0 Hs} : @Vector3.recOn \u03b1 (@C) 0 [] H0 @Hs = H0", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.recOn_cons", "code": "@[simp]\ntheorem recOn_cons {C H0 Hs n a v} :\n    @Vector3.recOn \u03b1 (@C) (succ n) (a :: v) H0 @Hs = Hs a v (@Vector3.recOn \u03b1 (@C) n v H0 @Hs)", "start": [143, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.append", "code": "def append (v : Vector3 \u03b1 m) (w : Vector3 \u03b1 n) : Vector3 \u03b1 (n + m) :=\n  v.recOn w (fun a _ IH => a :: IH)", "start": [149, 1], "end": [151, 36], "kind": "commanddeclaration"}, {"full_name": "Vector3.append_nil", "code": "@[simp]\ntheorem append_nil (w : Vector3 \u03b1 n) : [] +-+ w = w", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.append_cons", "code": "@[simp]\ntheorem append_cons (a : \u03b1) (v : Vector3 \u03b1 m) (w : Vector3 \u03b1 n) : (a :: v) +-+ w = a :: v +-+ w", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "Vector3.append_left", "code": "@[simp]\ntheorem append_left :\n    \u2200 {m} (i : Fin2 m) (v : Vector3 \u03b1 m) {n} (w : Vector3 \u03b1 n), (v +-+ w) (left n i) = v i", "start": [169, 1], "end": [173, 78], "kind": "commanddeclaration"}, {"full_name": "Vector3.append_add", "code": "@[simp]\ntheorem append_add :\n    \u2200 {m} (v : Vector3 \u03b1 m) {n} (w : Vector3 \u03b1 n) (i : Fin2 n), (v +-+ w) (add i m) = w i", "start": [176, 1], "end": [180, 75], "kind": "commanddeclaration"}, {"full_name": "Vector3.insert", "code": "def insert (a : \u03b1) (v : Vector3 \u03b1 n) (i : Fin2 (succ n)) : Vector3 \u03b1 (succ n) := fun j =>\n  (a :: v) (insertPerm i j)", "start": [183, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "Vector3.insert_fz", "code": "@[simp]\ntheorem insert_fz (a : \u03b1) (v : Vector3 \u03b1 n) : insert a v fz = a :: v", "start": [188, 1], "end": [190, 58], "kind": "commanddeclaration"}, {"full_name": "Vector3.insert_fs", "code": "@[simp]\ntheorem insert_fs (a : \u03b1) (b : \u03b1) (v : Vector3 \u03b1 n) (i : Fin2 (succ n)) :\n    insert a (b :: v) (fs i) = b :: insert a v i", "start": [193, 1], "end": [198, 67], "kind": "commanddeclaration"}, {"full_name": "Vector3.append_insert", "code": "theorem append_insert (a : \u03b1) (t : Vector3 \u03b1 m) (v : Vector3 \u03b1 n) (i : Fin2 (succ n))\n    (e : succ n + m = succ (n + m)) :\n    insert a (t +-+ v) (Eq.recOn e (i.add m)) = Eq.recOn e (t +-+ insert a v i)", "start": [201, 1], "end": [213, 39], "kind": "commanddeclaration"}, {"full_name": "VectorEx", "code": "def VectorEx : \u2200 k, (Vector3 \u03b1 k \u2192 Prop) \u2192 Prop\n  | 0, f => f []\n  | succ k, f => \u2203 x : \u03b1, VectorEx k fun v => f (x :: v)", "start": [222, 1], "end": [225, 57], "kind": "commanddeclaration"}, {"full_name": "VectorAll", "code": "def VectorAll : \u2200 k, (Vector3 \u03b1 k \u2192 Prop) \u2192 Prop\n  | 0, f => f []\n  | succ k, f => \u2200 x : \u03b1, VectorAll k fun v => f (x :: v)", "start": [228, 1], "end": [231, 58], "kind": "commanddeclaration"}, {"full_name": "exists_vector_zero", "code": "theorem exists_vector_zero (f : Vector3 \u03b1 0 \u2192 Prop) : Exists f \u2194 f []", "start": [234, 1], "end": [235, 68], "kind": "commanddeclaration"}, {"full_name": "exists_vector_succ", "code": "theorem exists_vector_succ (f : Vector3 \u03b1 (succ n) \u2192 Prop) : Exists f \u2194 \u2203 x v, f (x :: v)", "start": [238, 1], "end": [239, 91], "kind": "commanddeclaration"}, {"full_name": "vectorEx_iff_exists", "code": "theorem vectorEx_iff_exists : \u2200 {n} (f : Vector3 \u03b1 n \u2192 Prop), VectorEx n f \u2194 Exists f", "start": [242, 1], "end": [245, 88], "kind": "commanddeclaration"}, {"full_name": "vectorAll_iff_forall", "code": "theorem vectorAll_iff_forall : \u2200 {n} (f : Vector3 \u03b1 n \u2192 Prop), VectorAll n f \u2194 \u2200 v, f v", "start": [248, 1], "end": [252, 61], "kind": "commanddeclaration"}, {"full_name": "VectorAllP", "code": "def VectorAllP (p : \u03b1 \u2192 Prop) (v : Vector3 \u03b1 n) : Prop :=\n  Vector3.recOn v True fun a v IH =>\n    @Vector3.recOn _ (fun _ => Prop) _ v (p a) fun _ _ _ => p a \u2227 IH", "start": [255, 1], "end": [259, 69], "kind": "commanddeclaration"}, {"full_name": "vectorAllP_nil", "code": "@[simp]\ntheorem vectorAllP_nil (p : \u03b1 \u2192 Prop) : VectorAllP p [] = True", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "vectorAllP_singleton", "code": "@[simp, nolint simpNF] theorem vectorAllP_singleton (p : \u03b1 \u2192 Prop) (x : \u03b1) : VectorAllP p (cons x []) = p x", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "vectorAllP_cons", "code": "@[simp]\ntheorem vectorAllP_cons (p : \u03b1 \u2192 Prop) (x : \u03b1) (v : Vector3 \u03b1 n) :\n    VectorAllP p (x :: v) \u2194 p x \u2227 VectorAllP p v", "start": [272, 1], "end": [275, 61], "kind": "commanddeclaration"}, {"full_name": "vectorAllP_iff_forall", "code": "theorem vectorAllP_iff_forall (p : \u03b1 \u2192 Prop) (v : Vector3 \u03b1 n) :\n    VectorAllP p v \u2194 \u2200 i, p (v i)", "start": [278, 1], "end": [289, 27], "kind": "commanddeclaration"}, {"full_name": "VectorAllP.imp", "code": "theorem VectorAllP.imp {p q : \u03b1 \u2192 Prop} (h : \u2200 x, p x \u2192 q x) {v : Vector3 \u03b1 n}\n    (al : VectorAllP p v) : VectorAllP q v", "start": [292, 1], "end": [294, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/LocalAtTarget.lean", "imports": ["Mathlib/Topology/Sets/Opens.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.restrictPreimage_inducing", "code": "theorem Set.restrictPreimage_inducing (s : Set \u03b2) (h : Inducing f) :\n    Inducing (s.restrictPreimage f)", "start": [30, 1], "end": [35, 49], "kind": "commanddeclaration"}, {"full_name": "Inducing.restrictPreimage", "code": "alias Inducing.restrictPreimage := Set.restrictPreimage_inducing", "start": [38, 1], "end": [38, 65], "kind": "stdtacticaliasalias"}, {"full_name": "Set.restrictPreimage_embedding", "code": "theorem Set.restrictPreimage_embedding (s : Set \u03b2) (h : Embedding f) :\n    Embedding (s.restrictPreimage f)", "start": [41, 1], "end": [43, 51], "kind": "commanddeclaration"}, {"full_name": "Embedding.restrictPreimage", "code": "alias Embedding.restrictPreimage := Set.restrictPreimage_embedding", "start": [46, 1], "end": [46, 67], "kind": "stdtacticaliasalias"}, {"full_name": "Set.restrictPreimage_openEmbedding", "code": "theorem Set.restrictPreimage_openEmbedding (s : Set \u03b2) (h : OpenEmbedding f) :\n    OpenEmbedding (s.restrictPreimage f)", "start": [49, 1], "end": [52, 86], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.restrictPreimage", "code": "alias OpenEmbedding.restrictPreimage := Set.restrictPreimage_openEmbedding", "start": [55, 1], "end": [55, 75], "kind": "stdtacticaliasalias"}, {"full_name": "Set.restrictPreimage_closedEmbedding", "code": "theorem Set.restrictPreimage_closedEmbedding (s : Set \u03b2) (h : ClosedEmbedding f) :\n    ClosedEmbedding (s.restrictPreimage f)", "start": [58, 1], "end": [61, 86], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.restrictPreimage", "code": "alias ClosedEmbedding.restrictPreimage := Set.restrictPreimage_closedEmbedding", "start": [64, 1], "end": [64, 79], "kind": "stdtacticaliasalias"}, {"full_name": "Set.restrictPreimage_isClosedMap", "code": "theorem Set.restrictPreimage_isClosedMap (s : Set \u03b2) (H : IsClosedMap f) :\n    IsClosedMap (s.restrictPreimage f)", "start": [67, 1], "end": [76, 81], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_inter_of_iSup_eq_top", "code": "theorem isOpen_iff_inter_of_iSup_eq_top (s : Set \u03b2) : IsOpen s \u2194 \u2200 i, IsOpen (s \u2229 U i)", "start": [79, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_coe_preimage_of_iSup_eq_top", "code": "theorem isOpen_iff_coe_preimage_of_iSup_eq_top (s : Set \u03b2) :\n    IsOpen s \u2194 \u2200 i, IsOpen ((\u2191) \u207b\u00b9' s : Set (U i))", "start": [90, 1], "end": [97, 47], "kind": "commanddeclaration"}, {"full_name": "isClosed_iff_coe_preimage_of_iSup_eq_top", "code": "theorem isClosed_iff_coe_preimage_of_iSup_eq_top (s : Set \u03b2) :\n    IsClosed s \u2194 \u2200 i, IsClosed ((\u2191) \u207b\u00b9' s : Set (U i))", "start": [100, 1], "end": [102, 59], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_iff_isClosedMap_of_iSup_eq_top", "code": "theorem isClosedMap_iff_isClosedMap_of_iSup_eq_top :\n    IsClosedMap f \u2194 \u2200 i, IsClosedMap ((U i).1.restrictPreimage f)", "start": [105, 1], "end": [115, 81], "kind": "commanddeclaration"}, {"full_name": "inducing_iff_inducing_of_iSup_eq_top", "code": "theorem inducing_iff_inducing_of_iSup_eq_top (h : Continuous f) :\n    Inducing f \u2194 \u2200 i, Inducing ((U i).1.restrictPreimage f)", "start": [118, 1], "end": [134, 58], "kind": "commanddeclaration"}, {"full_name": "embedding_iff_embedding_of_iSup_eq_top", "code": "theorem embedding_iff_embedding_of_iSup_eq_top (h : Continuous f) :\n    Embedding f \u2194 \u2200 i, Embedding ((U i).1.restrictPreimage f)", "start": [137, 1], "end": [145, 9], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_iff_openEmbedding_of_iSup_eq_top", "code": "theorem openEmbedding_iff_openEmbedding_of_iSup_eq_top (h : Continuous f) :\n    OpenEmbedding f \u2194 \u2200 i, OpenEmbedding ((U i).1.restrictPreimage f)", "start": [148, 1], "end": [155, 52], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_iff_closedEmbedding_of_iSup_eq_top", "code": "theorem closedEmbedding_iff_closedEmbedding_of_iSup_eq_top (h : Continuous f) :\n    ClosedEmbedding f \u2194 \u2200 i, ClosedEmbedding ((U i).1.restrictPreimage f)", "start": [158, 1], "end": [165, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SetFamily/Intersecting.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Order/UpperLower/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Intersecting", "code": "def Intersecting (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 \u00acDisjoint a b", "start": [40, 1], "end": [42, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.mono", "code": "@[mono]\ntheorem Intersecting.mono (h : t \u2286 s) (hs : s.Intersecting) : t.Intersecting", "start": [45, 1], "end": [47, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.not_bot_mem", "code": "theorem Intersecting.not_bot_mem (hs : s.Intersecting) : \u22a5 \u2209 s", "start": [50, 1], "end": [50, 100], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.ne_bot", "code": "theorem Intersecting.ne_bot (hs : s.Intersecting) (ha : a \u2208 s) : a \u2260 \u22a5", "start": [53, 1], "end": [54, 41], "kind": "commanddeclaration"}, {"full_name": "Set.intersecting_empty", "code": "theorem intersecting_empty : (\u2205 : Set \u03b1).Intersecting", "start": [57, 1], "end": [57, 77], "kind": "commanddeclaration"}, {"full_name": "Set.intersecting_singleton", "code": "@[simp]\ntheorem intersecting_singleton : ({a} : Set \u03b1).Intersecting \u2194 a \u2260 \u22a5", "start": [60, 1], "end": [61, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.insert", "code": "protected theorem Intersecting.insert (hs : s.Intersecting) (ha : a \u2260 \u22a5)\n    (h : \u2200 b \u2208 s, \u00acDisjoint a b) : (insert a s).Intersecting", "start": [64, 1], "end": [70, 19], "kind": "commanddeclaration"}, {"full_name": "Set.intersecting_insert", "code": "theorem intersecting_insert :\n    (insert a s).Intersecting \u2194 s.Intersecting \u2227 a \u2260 \u22a5 \u2227 \u2200 b \u2208 s, \u00acDisjoint a b", "start": [73, 1], "end": [78, 37], "kind": "commanddeclaration"}, {"full_name": "Set.intersecting_iff_pairwise_not_disjoint", "code": "theorem intersecting_iff_pairwise_not_disjoint :\n    s.Intersecting \u2194 (s.Pairwise fun a b => \u00acDisjoint a b) \u2227 s \u2260 {\u22a5}", "start": [81, 1], "end": [92, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.intersecting", "code": "protected theorem Subsingleton.intersecting (hs : s.Subsingleton) : s.Intersecting \u2194 s \u2260 {\u22a5}", "start": [95, 1], "end": [96, 81], "kind": "commanddeclaration"}, {"full_name": "Set.intersecting_iff_eq_empty_of_subsingleton", "code": "theorem intersecting_iff_eq_empty_of_subsingleton [Subsingleton \u03b1] (s : Set \u03b1) :\n    s.Intersecting \u2194 s = \u2205", "start": [99, 1], "end": [107, 51], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.isUpperSet", "code": "protected theorem Intersecting.isUpperSet (hs : s.Intersecting)\n    (h : \u2200 t : Set \u03b1, t.Intersecting \u2192 s \u2286 t \u2192 s = t) : IsUpperSet s", "start": [110, 1], "end": [118, 101], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.isUpperSet'", "code": "theorem Intersecting.isUpperSet' {s : Finset \u03b1} (hs : (s : Set \u03b1).Intersecting)\n    (h : \u2200 t : Finset \u03b1, (t : Set \u03b1).Intersecting \u2192 s \u2286 t \u2192 s = t) : IsUpperSet (s : Set \u03b1)", "start": [121, 1], "end": [130, 101], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.exists_mem_set", "code": "theorem Intersecting.exists_mem_set {\ud835\udc9c : Set (Set \u03b1)} (h\ud835\udc9c : \ud835\udc9c.Intersecting) {s t : Set \u03b1}\n    (hs : s \u2208 \ud835\udc9c) (ht : t \u2208 \ud835\udc9c) : \u2203 a, a \u2208 s \u2227 a \u2208 t", "start": [135, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.exists_mem_finset", "code": "theorem Intersecting.exists_mem_finset [DecidableEq \u03b1] {\ud835\udc9c : Set (Finset \u03b1)} (h\ud835\udc9c : \ud835\udc9c.Intersecting)\n    {s t : Finset \u03b1} (hs : s \u2208 \ud835\udc9c) (ht : t \u2208 \ud835\udc9c) : \u2203 a, a \u2208 s \u2227 a \u2208 t", "start": [140, 1], "end": [142, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.not_compl_mem", "code": "theorem Intersecting.not_compl_mem {s : Set \u03b1} (hs : s.Intersecting) {a : \u03b1} (ha : a \u2208 s) :\n    a\u1d9c \u2209 s", "start": [147, 1], "end": [148, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.not_mem", "code": "theorem Intersecting.not_mem {s : Set \u03b1} (hs : s.Intersecting) {a : \u03b1} (ha : a\u1d9c \u2208 s) : a \u2209 s", "start": [151, 1], "end": [152, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.disjoint_map_compl", "code": "theorem Intersecting.disjoint_map_compl {s : Finset \u03b1} (hs : (s : Set \u03b1).Intersecting) :\n    Disjoint s (s.map \u27e8compl, compl_injective\u27e9)", "start": [155, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.card_le", "code": "theorem Intersecting.card_le [Fintype \u03b1] {s : Finset \u03b1} (hs : (s : Set \u03b1).Intersecting) :\n    2 * s.card \u2264 Fintype.card \u03b1", "start": [163, 1], "end": [167, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.is_max_iff_card_eq", "code": "theorem Intersecting.is_max_iff_card_eq (hs : (s : Set \u03b1).Intersecting) :\n    (\u2200 t : Finset \u03b1, (t : Set \u03b1).Intersecting \u2192 s \u2286 t \u2192 s = t) \u2194 2 * s.card = Fintype.card \u03b1", "start": [173, 1], "end": [194, 75], "kind": "commanddeclaration"}, {"full_name": "Set.Intersecting.exists_card_eq", "code": "theorem Intersecting.exists_card_eq (hs : (s : Set \u03b1).Intersecting) :\n    \u2203 t, s \u2286 t \u2227 2 * t.card = Fintype.card \u03b1 \u2227 (t : Set \u03b1).Intersecting", "start": [197, 1], "end": [210, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SetFamily/HarrisKleitman.lean", "imports": ["Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Combinatorics/SetFamily/Compression/Down.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLowerSet.nonMemberSubfamily", "code": "theorem IsLowerSet.nonMemberSubfamily (h : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1))) :\n    IsLowerSet (\ud835\udc9c.nonMemberSubfamily a : Set (Finset \u03b1))", "start": [36, 1], "end": [39, 39], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.memberSubfamily", "code": "theorem IsLowerSet.memberSubfamily (h : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1))) :\n    IsLowerSet (\ud835\udc9c.memberSubfamily a : Set (Finset \u03b1))", "start": [42, 1], "end": [46, 65], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.memberSubfamily_subset_nonMemberSubfamily", "code": "theorem IsLowerSet.memberSubfamily_subset_nonMemberSubfamily (h : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1))) :\n    \ud835\udc9c.memberSubfamily a \u2286 \ud835\udc9c.nonMemberSubfamily a", "start": [49, 1], "end": [52, 46], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.le_card_inter_finset'", "code": "theorem IsLowerSet.le_card_inter_finset' (h\ud835\udc9c : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsLowerSet (\u212c : Set (Finset \u03b1))) (h\ud835\udc9cs : \u2200 t \u2208 \ud835\udc9c, t \u2286 s) (h\u212cs : \u2200 t \u2208 \u212c, t \u2286 s) :\n    \ud835\udc9c.card * \u212c.card \u2264 2 ^ s.card * (\ud835\udc9c \u2229 \u212c).card", "start": [55, 1], "end": [91, 54], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.le_card_inter_finset", "code": "theorem IsLowerSet.le_card_inter_finset (h\ud835\udc9c : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsLowerSet (\u212c : Set (Finset \u03b1))) : \ud835\udc9c.card * \u212c.card \u2264 2 ^ Fintype.card \u03b1 * (\ud835\udc9c \u2229 \u212c).card", "start": [96, 1], "end": [99, 80], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.card_inter_le_finset", "code": "theorem IsUpperSet.card_inter_le_finset (h\ud835\udc9c : IsUpperSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsLowerSet (\u212c : Set (Finset \u03b1))) :\n    2 ^ Fintype.card \u03b1 * (\ud835\udc9c \u2229 \u212c).card \u2264 \ud835\udc9c.card * \u212c.card", "start": [102, 1], "end": [110, 29], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.card_inter_le_finset", "code": "theorem IsLowerSet.card_inter_le_finset (h\ud835\udc9c : IsLowerSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsUpperSet (\u212c : Set (Finset \u03b1))) :\n    2 ^ Fintype.card \u03b1 * (\ud835\udc9c \u2229 \u212c).card \u2264 \ud835\udc9c.card * \u212c.card", "start": [113, 1], "end": [118, 35], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.le_card_inter_finset", "code": "theorem IsUpperSet.le_card_inter_finset (h\ud835\udc9c : IsUpperSet (\ud835\udc9c : Set (Finset \u03b1)))\n    (h\u212c : IsUpperSet (\u212c : Set (Finset \u03b1))) :\n    \ud835\udc9c.card * \u212c.card \u2264 2 ^ Fintype.card \u03b1 * (\ud835\udc9c \u2229 \u212c).card", "start": [121, 1], "end": [132, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Exact.lean", "imports": ["Mathlib/LinearAlgebra/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Exact", "code": "def Exact [Zero P] : Prop := \u2200 y, g y = 0 \u2194 y \u2208 Set.range f", "start": [37, 1], "end": [39, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Exact.comp_eq_zero", "code": "lemma Exact.comp_eq_zero [Zero P] (h : Exact f g) : g.comp f = 0 :=\n  funext fun _ => (h _).mpr <| Set.mem_range_self _", "start": [41, 1], "end": [42, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Exact.linearMap_ker_eq", "code": "lemma Exact.linearMap_ker_eq (hfg : Exact f g) : ker g = range f :=\n  SetLike.ext hfg", "start": [56, 1], "end": [57, 18], "kind": "mathlibtacticlemma"}, {"full_name": "Function.LinearMap.exact_iff", "code": "lemma LinearMap.exact_iff : Exact f g \u2194 LinearMap.ker g = LinearMap.range f :=\n  Iff.symm <| SetLike.ext_iff", "start": [59, 1], "end": [60, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Exact.linearMap_comp_eq_zero", "code": "lemma Exact.linearMap_comp_eq_zero (h : Exact f g) : g.comp f = 0 :=\n  FunLike.coe_injective h.comp_eq_zero", "start": [62, 1], "end": [63, 39], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Nat/Dist.lean", "imports": ["Mathlib/Data/Nat/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.dist", "code": "def dist (n m : \u2115) :=\n  n - m + (m - n)", "start": [19, 1], "end": [21, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.dist.def", "code": "theorem dist.def (n m : \u2115) : dist n m = n - m + (m - n)", "start": [24, 1], "end": [25, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_comm", "code": "theorem dist_comm (n m : \u2115) : dist n m = dist m n", "start": [28, 1], "end": [28, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_self", "code": "@[simp]\ntheorem dist_self (n : \u2115) : dist n n = 0", "start": [31, 1], "end": [32, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_dist_eq_zero", "code": "theorem eq_of_dist_eq_zero {n m : \u2115} (h : dist n m = 0) : n = m", "start": [35, 1], "end": [40, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_eq_zero", "code": "theorem dist_eq_zero {n m : \u2115} (h : n = m) : dist n m = 0", "start": [43, 1], "end": [43, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_eq_sub_of_le", "code": "theorem dist_eq_sub_of_le {n m : \u2115} (h : n \u2264 m) : dist n m = m - n", "start": [46, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_eq_sub_of_le_right", "code": "theorem dist_eq_sub_of_le_right {n m : \u2115} (h : m \u2264 n) : dist n m = n - m", "start": [50, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_tri_left", "code": "theorem dist_tri_left (n m : \u2115) : m \u2264 dist n m + n", "start": [54, 1], "end": [55, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_tri_right", "code": "theorem dist_tri_right (n m : \u2115) : m \u2264 n + dist n m", "start": [58, 1], "end": [58, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_tri_left'", "code": "theorem dist_tri_left' (n m : \u2115) : n \u2264 dist n m + m", "start": [61, 1], "end": [61, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_tri_right'", "code": "theorem dist_tri_right' (n m : \u2115) : n \u2264 m + dist n m", "start": [64, 1], "end": [64, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_zero_right", "code": "theorem dist_zero_right (n : \u2115) : dist n 0 = n", "start": [67, 1], "end": [68, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_zero_left", "code": "theorem dist_zero_left (n : \u2115) : dist 0 n = n", "start": [71, 1], "end": [72, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_add_add_right", "code": "theorem dist_add_add_right (n k m : \u2115) : dist (n + k) (m + k) = dist n m", "start": [75, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_add_add_left", "code": "theorem dist_add_add_left (k n m : \u2115) : dist (k + n) (k + m) = dist n m", "start": [82, 1], "end": [83, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_eq_intro", "code": "theorem dist_eq_intro {n m k l : \u2115} (h : n + m = k + l) : dist n k = dist l m", "start": [86, 1], "end": [90, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.dist.triangle_inequality", "code": "theorem dist.triangle_inequality (n m k : \u2115) : dist n k \u2264 dist n m + dist m k", "start": [93, 1], "end": [97, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_mul_right", "code": "theorem dist_mul_right (n k m : \u2115) : dist (n * k) (m * k) = dist n m * k", "start": [100, 1], "end": [101, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_mul_left", "code": "theorem dist_mul_left (k n m : \u2115) : dist (k * n) (k * m) = k * dist n m", "start": [104, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_eq_max_sub_min", "code": "theorem dist_eq_max_sub_min {i j : \u2115} : dist i j = (max i j) - min i j", "start": [108, 1], "end": [111, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_succ_succ", "code": "theorem dist_succ_succ {i j : Nat} : dist (succ i) (succ j) = dist i j", "start": [113, 1], "end": [114, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.dist_pos_of_ne", "code": "theorem dist_pos_of_ne {i j : Nat} : i \u2260 j \u2192 0 < dist i j", "start": [117, 1], "end": [121, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Ordmap/Ordnode.lean", "imports": ["Mathlib/Data/List/Defs.lean", "Mathlib/Order/Compare.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/PSub.lean", "Mathlib/Init/Data/Nat/Bitwise.lean"], "premises": [{"full_name": "Ordnode", "code": "inductive Ordnode (\u03b1 : Type u) : Type u\n  | nil : Ordnode \u03b1\n  | node (size : \u2115) (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1", "start": [72, 1], "end": [77, 72], "kind": "commanddeclaration"}, {"full_name": "Ordnode.delta", "code": "@[inline]\ndef delta :=\n  3", "start": [93, 1], "end": [103, 4], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ratio", "code": "@[inline]\ndef ratio :=\n  2", "start": [106, 1], "end": [115, 4], "kind": "commanddeclaration"}, {"full_name": "Ordnode.singleton", "code": "@[inline]\nprotected def singleton (a : \u03b1) : Ordnode \u03b1 :=\n  node 1 nil a nil", "start": [118, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size", "code": "@[inline]\ndef size : Ordnode \u03b1 \u2192 \u2115\n  | nil => 0\n  | node sz _ _ _ => sz", "start": [132, 1], "end": [138, 24], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_nil", "code": "theorem size_nil : size (nil : Ordnode \u03b1) = 0", "start": [141, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.size_node", "code": "theorem size_node (sz : \u2115) (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : size (node sz l x r) = sz", "start": [143, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "Ordnode.empty", "code": "@[inline]\ndef empty : Ordnode \u03b1 \u2192 Bool\n  | nil => true\n  | node _ _ _ _ => false", "start": [149, 1], "end": [156, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dual", "code": "@[simp]\ndef dual : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node s l x r => node s (dual r) x (dual l)", "start": [159, 1], "end": [167, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.node'", "code": "@[inline, reducible]\ndef node' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 :=\n  node (size l + size r + 1) l x r", "start": [170, 1], "end": [175, 35], "kind": "commanddeclaration"}, {"full_name": "Ordnode.repr", "code": "def repr {\u03b1} [Repr \u03b1] (o : Ordnode \u03b1) (n : \u2115) : Std.Format :=\n  match o with\n  | nil => (Std.Format.text \"\u2205\")\n  | node _ l x r =>\n      let fmt := Std.Format.joinSep\n        [repr l n, Repr.reprPrec x n, repr r n]\n        \" \"\n      Std.Format.paren fmt", "start": [178, 1], "end": [188, 27], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceL", "code": "def balanceL (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 := by\n  cases' id r with rs\n  \u00b7 cases' id l with ls ll lx lr\n    \u00b7 exact \u03b9 x\n    \u00b7 cases' id ll with lls\n      \u00b7 cases' lr with _ _ lrx\n        \u00b7 exact node 2 l x nil\n        \u00b7 exact node 3 (\u03b9 lx) lrx \u03b9 x\n      \u00b7 cases' id lr with lrs lrl lrx lrr\n        \u00b7 exact node 3 ll lx \u03b9 x\n        \u00b7 exact\n            if lrs < ratio * lls then node (ls + 1) ll lx (node (lrs + 1) lr x nil)\n            else\n              node (ls + 1) (node (lls + size lrl + 1) ll lx lrl) lrx\n                (node (size lrr + 1) lrr x nil)\n  \u00b7 cases' id l with ls ll lx lr\n    \u00b7 exact node (rs + 1) nil x r\n    \u00b7 refine' if ls > delta * rs then _ else node (ls + rs + 1) l x r\n      cases' id ll with lls\n      \u00b7 exact nil\n      cases' id lr with lrs lrl lrx lrr\n      \u00b7 exact nil\n      exact\n        if lrs < ratio * lls then node (ls + rs + 1) ll lx (node (rs + lrs + 1) lr x r)\n        else\n          node (ls + rs + 1) (node (lls + size lrl + 1) ll lx lrl) lrx\n            (node (size lrr + rs + 1) lrr x r)", "start": [195, 1], "end": [228, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balanceR", "code": "def balanceR (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 := by\n  cases' id l with ls\n  \u00b7 cases' id r with rs rl rx rr\n    \u00b7 exact \u03b9 x\n    \u00b7 cases' id rr with rrs\n      \u00b7 cases' rl with _ _ rlx\n        \u00b7 exact node 2 nil x r\n        \u00b7 exact node 3 (\u03b9 x) rlx \u03b9 rx\n      \u00b7 cases' id rl with rls rll rlx rlr\n        \u00b7 exact node 3 (\u03b9 x) rx rr\n        \u00b7 exact\n            if rls < ratio * rrs then node (rs + 1) (node (rls + 1) nil x rl) rx rr\n            else\n              node (rs + 1) (node (size rll + 1) nil x rll) rlx\n                (node (size rlr + rrs + 1) rlr rx rr)\n  \u00b7 cases' id r with rs rl rx rr\n    \u00b7 exact node (ls + 1) l x nil\n    \u00b7 refine' if rs > delta * ls then _ else node (ls + rs + 1) l x r\n      cases' id rr with rrs\n      \u00b7 exact nil\n      cases' id rl with rls rll rlx rlr\n      \u00b7 exact nil\n      exact\n        if rls < ratio * rrs then node (ls + rs + 1) (node (ls + rls + 1) l x rl) rx rr\n        else\n          node (ls + rs + 1) (node (ls + size rll + 1) l x rll) rlx\n            (node (size rlr + rrs + 1) rlr rx rr)", "start": [231, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.balance", "code": "def balance (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) : Ordnode \u03b1 := by\n  cases' id l with ls ll lx lr\n  \u00b7 cases' id r with rs rl rx rr\n    \u00b7 exact \u03b9 x\n    \u00b7 cases' id rl with rls rll rlx rlr\n      \u00b7 cases id rr\n        \u00b7 exact node 2 nil x r\n        \u00b7 exact node 3 (\u03b9 x) rx rr\n      \u00b7 cases' id rr with rrs\n        \u00b7 exact node 3 (\u03b9 x) rlx \u03b9 rx\n        \u00b7 exact\n            if rls < ratio * rrs then node (rs + 1) (node (rls + 1) nil x rl) rx rr\n            else\n              node (rs + 1) (node (size rll + 1) nil x rll) rlx\n                (node (size rlr + rrs + 1) rlr rx rr)\n  \u00b7 cases' id r with rs rl rx rr\n    \u00b7 cases' id ll with lls\n      \u00b7 cases' lr with _ _ lrx\n        \u00b7 exact node 2 l x nil\n        \u00b7 exact node 3 (\u03b9 lx) lrx \u03b9 x\n      \u00b7 cases' id lr with lrs lrl lrx lrr\n        \u00b7 exact node 3 ll lx \u03b9 x\n        \u00b7 exact\n            if lrs < ratio * lls then node (ls + 1) ll lx (node (lrs + 1) lr x nil)\n            else\n              node (ls + 1) (node (lls + size lrl + 1) ll lx lrl) lrx\n                (node (size lrr + 1) lrr x nil)\n    \u00b7 refine'\n        if delta * ls < rs then _ else if delta * rs < ls then _ else node (ls + rs + 1) l x r\n      \u00b7 cases' id rl with rls rll rlx rlr\n        \u00b7 exact nil\n        cases' id rr with rrs\n        \u00b7 exact nil\n        exact\n          if rls < ratio * rrs then node (ls + rs + 1) (node (ls + rls + 1) l x rl) rx rr\n          else\n            node (ls + rs + 1) (node (ls + size rll + 1) l x rll) rlx\n              (node (size rlr + rrs + 1) rlr rx rr)\n      \u00b7 cases' id ll with lls\n        \u00b7 exact nil\n        cases' id lr with lrs lrl lrx lrr\n        \u00b7 exact nil\n        exact\n          if lrs < ratio * lls then node (ls + rs + 1) ll lx (node (lrs + rs + 1) lr x r)\n          else\n            node (ls + rs + 1) (node (lls + size lrl + 1) ll lx lrl) lrx\n              (node (size lrr + rs + 1) lrr x r)", "start": [267, 1], "end": [322, 49], "kind": "commanddeclaration"}, {"full_name": "Ordnode.All", "code": "def All (P : \u03b1 \u2192 Prop) : Ordnode \u03b1 \u2192 Prop\n  | nil => True\n  | node _ l x r => All P l \u2227 P x \u2227 All P r", "start": [325, 1], "end": [331, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.All.decidable", "code": "instance All.decidable {P : \u03b1 \u2192 Prop} : (t : Ordnode \u03b1) \u2192 [DecidablePred P] \u2192 Decidable (All P t)\n  | nil => decidableTrue\n  | node _ l _ r =>\n    have : Decidable (All P l) := All.decidable l\n    have : Decidable (All P r) := All.decidable r\n    And.decidable", "start": [334, 1], "end": [339, 18], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Any", "code": "def Any (P : \u03b1 \u2192 Prop) : Ordnode \u03b1 \u2192 Prop\n  | nil => False\n  | node _ l x r => Any P l \u2228 P x \u2228 Any P r", "start": [342, 1], "end": [348, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Any.decidable", "code": "instance Any.decidable {P : \u03b1 \u2192 Prop} : (t: Ordnode \u03b1 ) \u2192 [DecidablePred P] \u2192 Decidable (Any P t)\n  | nil => decidableFalse\n  | node _ l _ r =>\n    have : Decidable (Any P l) := Any.decidable l\n    have : Decidable (Any P r) := Any.decidable r\n    Or.decidable", "start": [351, 1], "end": [356, 17], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Emem", "code": "def Emem (x : \u03b1) : Ordnode \u03b1 \u2192 Prop :=\n  Any (Eq x)", "start": [359, 1], "end": [366, 13], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Emem.decidable", "code": "instance Emem.decidable (x : \u03b1) [DecidableEq \u03b1] : \u2200 t, Decidable (Emem x t) := by\n  dsimp [Emem]; infer_instance", "start": [369, 1], "end": [370, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Amem", "code": "def Amem [LE \u03b1] (x : \u03b1) : Ordnode \u03b1 \u2192 Prop :=\n  Any fun y => x \u2264 y \u2227 y \u2264 x", "start": [373, 1], "end": [391, 29], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Amem.decidable", "code": "instance Amem.decidable [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x : \u03b1) :\n    \u2200 t, Decidable (Amem x t) := by\n  dsimp [Amem]; infer_instance", "start": [394, 1], "end": [396, 31], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMin'", "code": "def findMin' : Ordnode \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | nil, x => x\n  | node _ l x _, _ => findMin' l x", "start": [399, 1], "end": [405, 36], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMin", "code": "def findMin : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l x _ => some (findMin' l x)", "start": [408, 1], "end": [414, 40], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMax'", "code": "def findMax' : \u03b1 \u2192 Ordnode \u03b1 \u2192 \u03b1\n  | x, nil => x\n  | _, node _ _ x r => findMax' x r", "start": [417, 1], "end": [423, 36], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findMax", "code": "def findMax : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ _ x r => some (findMax' x r)", "start": [426, 1], "end": [432, 40], "kind": "commanddeclaration"}, {"full_name": "Ordnode.eraseMin", "code": "def eraseMin : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node _ nil _ r => r\n  | node _ (node sz l' y r') x r => balanceR (eraseMin (node sz l' y r')) x r", "start": [435, 1], "end": [442, 78], "kind": "commanddeclaration"}, {"full_name": "Ordnode.eraseMax", "code": "def eraseMax : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node _ l _ nil => l\n  | node _ l x (node sz l' y r') => balanceL l x (eraseMax (node sz l' y r'))", "start": [445, 1], "end": [452, 78], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMin'", "code": "def splitMin' : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 \u03b1 \u00d7 Ordnode \u03b1\n  | nil, x, r => (x, r)\n  | node _ ll lx lr, x, r =>\n    let (xm, l') := splitMin' ll lx lr\n    (xm, balanceR l' x r)", "start": [455, 1], "end": [462, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMin", "code": "def splitMin : Ordnode \u03b1 \u2192 Option (\u03b1 \u00d7 Ordnode \u03b1)\n  | nil => none\n  | node _ l x r => splitMin' l x r", "start": [465, 1], "end": [471, 36], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMax'", "code": "def splitMax' : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1 \u00d7 \u03b1\n  | l, x, nil => (l, x)\n  | l, x, node _ rl rx rr =>\n    let (r', xm) := splitMax' rl rx rr\n    (balanceL l x r', xm)", "start": [474, 1], "end": [481, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitMax", "code": "def splitMax : Ordnode \u03b1 \u2192 Option (Ordnode \u03b1 \u00d7 \u03b1)\n  | nil => none\n  | node _ x l r => splitMax' x l r", "start": [484, 1], "end": [490, 36], "kind": "commanddeclaration"}, {"full_name": "Ordnode.glue", "code": "def glue : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil, r => r\n  | l@(node _ _ _ _), nil => l\n  | l@(node sl ll lx lr), r@(node sr rl rx rr) =>\n    if sl > sr then\n      let (l', m) := splitMax' ll lx lr\n      balanceR l' m r\n    else\n      let (m, r') := splitMin' rl rx rr\n      balanceL l m r'", "start": [493, 1], "end": [505, 22], "kind": "commanddeclaration"}, {"full_name": "Ordnode.merge", "code": "def merge (l : Ordnode \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1 :=\n  (Ordnode.recOn (motive := fun _ => Ordnode \u03b1 \u2192 Ordnode \u03b1) l fun r => r)\n    fun ls ll lx lr _ IHlr r =>\n      (Ordnode.recOn (motive := fun _ => Ordnode \u03b1) r (node ls ll lx lr))\n        fun rs rl rx rr IHrl _ =>\n          if delta * ls < rs then balanceL IHrl rx rr\n          else\n            if delta * rs < ls then balanceR ll lx (IHlr <| node rs rl rx rr)\n            else glue (node ls ll lx lr) (node rs rl rx rr)", "start": [508, 1], "end": [520, 60], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insertMax", "code": "def insertMax : Ordnode \u03b1 \u2192 \u03b1 \u2192 Ordnode \u03b1\n  | nil, x => \u03b9 x\n  | node _ l y r, x => balanceR l y (insertMax r x)", "start": [523, 1], "end": [530, 52], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insertMin", "code": "def insertMin (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => \u03b9 x\n  | node _ l y r => balanceR (insertMin x l) y r", "start": [533, 1], "end": [540, 49], "kind": "commanddeclaration"}, {"full_name": "Ordnode.link", "code": "def link (l : Ordnode \u03b1) (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1 :=\n  match l with\n  | nil => insertMin x\n  | node ls ll lx lr => fun r \u21a6\n    match r with\n    | nil => insertMax l x\n    | node rs rl rx rr =>\n      if delta * ls < rs then balanceL (link ll x rl) rx rr\n      else if delta * rs < ls then balanceR ll lx (link lr x rr)\n      else node' l x r", "start": [543, 1], "end": [564, 23], "kind": "commanddeclaration"}, {"full_name": "Ordnode.filter", "code": "def filter (p : \u03b1 \u2192 Prop) [DecidablePred p] : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node _ l x r => if p x then\n                      link (filter p l) x (filter p r) else\n                      merge (filter p l) (filter p r)", "start": [567, 1], "end": [575, 54], "kind": "commanddeclaration"}, {"full_name": "Ordnode.partition", "code": "def partition (p : \u03b1 \u2192 Prop) [DecidablePred p] : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u00d7 Ordnode \u03b1\n  | nil => (nil, nil)\n  | node _ l x r =>\n    let (l\u2081, l\u2082) := partition p l\n    let (r\u2081, r\u2082) := partition p r\n    if p x then (link l\u2081 x r\u2081, merge l\u2082 r\u2082) else (merge l\u2081 r\u2081, link l\u2082 x r\u2082)", "start": [578, 1], "end": [586, 77], "kind": "commanddeclaration"}, {"full_name": "Ordnode.map", "code": "def map {\u03b2} (f : \u03b1 \u2192 \u03b2) : Ordnode \u03b1 \u2192 Ordnode \u03b2\n  | nil => nil\n  | node s l x r => node s (map f l) (f x) (map f r)", "start": [595, 1], "end": [602, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.fold", "code": "def fold {\u03b2} (z : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b2) : Ordnode \u03b1 \u2192 \u03b2\n  | nil => z\n  | node _ l x r => f (fold z f l) x (fold z f r)", "start": [611, 1], "end": [619, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.foldl", "code": "def foldl {\u03b2} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) : \u03b2 \u2192 Ordnode \u03b1 \u2192 \u03b2\n  | z, nil => z\n  | z, node _ l x r => foldl f (f (foldl f z l) x) r", "start": [628, 1], "end": [633, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.foldr", "code": "def foldr {\u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : Ordnode \u03b1 \u2192 \u03b2 \u2192 \u03b2\n  | nil, z => z\n  | node _ l x r, z => foldr f l (f x (foldr f r z))", "start": [642, 1], "end": [647, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.toList", "code": "def toList (t : Ordnode \u03b1) : List \u03b1 :=\n  foldr List.cons t []", "start": [650, 1], "end": [655, 23], "kind": "commanddeclaration"}, {"full_name": "Ordnode.toRevList", "code": "def toRevList (t : Ordnode \u03b1) : List \u03b1 :=\n  foldl (flip List.cons) [] t", "start": [658, 1], "end": [663, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.Equiv", "code": "def Equiv (t\u2081 t\u2082 : Ordnode \u03b1) : Prop :=\n  t\u2081.size = t\u2082.size \u2227 t\u2081.toList = t\u2082.toList", "start": [673, 1], "end": [678, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.powerset", "code": "def powerset (t : Ordnode \u03b1) : Ordnode (Ordnode \u03b1) :=\n  insertMin nil <| foldr (fun x ts => glue (insertMin (\u03b9 x) (map (insertMin x) ts)) ts) t nil", "start": [683, 1], "end": [687, 94], "kind": "commanddeclaration"}, {"full_name": "Ordnode.prod", "code": "protected def prod {\u03b2} (t\u2081 : Ordnode \u03b1) (t\u2082 : Ordnode \u03b2) : Ordnode (\u03b1 \u00d7 \u03b2) :=\n  fold nil (fun s\u2081 a s\u2082 => merge s\u2081 <| merge (map (Prod.mk a) t\u2082) s\u2082) t\u2081", "start": [690, 1], "end": [694, 73], "kind": "commanddeclaration"}, {"full_name": "Ordnode.copair", "code": "protected def copair {\u03b2} (t\u2081 : Ordnode \u03b1) (t\u2082 : Ordnode \u03b2) : Ordnode (Sum \u03b1 \u03b2) :=\n  merge (map Sum.inl t\u2081) (map Sum.inr t\u2082)", "start": [697, 1], "end": [702, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.pmap", "code": "def pmap {P : \u03b1 \u2192 Prop} {\u03b2} (f : \u2200 a, P a \u2192 \u03b2) : \u2200 t : Ordnode \u03b1, All P t \u2192 Ordnode \u03b2\n  | nil, _ => nil\n  | node s l x r, \u27e8hl, hx, hr\u27e9 => node s (pmap f l hl) (f x hx) (pmap f r hr)", "start": [713, 1], "end": [719, 78], "kind": "commanddeclaration"}, {"full_name": "Ordnode.attach'", "code": "def attach' {P : \u03b1 \u2192 Prop} : \u2200 t, All P t \u2192 Ordnode { a // P a } :=\n  pmap Subtype.mk", "start": [722, 1], "end": [727, 18], "kind": "commanddeclaration"}, {"full_name": "Ordnode.nth", "code": "def nth : Ordnode \u03b1 \u2192 \u2115 \u2192 Option \u03b1\n  | nil, _ => none\n  | node _ l x r, i =>\n    match Nat.psub' i (size l) with\n    | none => nth l i\n    | some 0 => some x\n    | some (j + 1) => nth r j", "start": [730, 1], "end": [740, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.removeNth", "code": "def removeNth : Ordnode \u03b1 \u2192 \u2115 \u2192 Ordnode \u03b1\n  | nil, _ => nil\n  | node _ l x r, i =>\n    match Nat.psub' i (size l) with\n    | none => balanceR (removeNth l i) x r\n    | some 0 => glue l r\n    | some (j + 1) => balanceL l x (removeNth r j)", "start": [743, 1], "end": [753, 51], "kind": "commanddeclaration"}, {"full_name": "Ordnode.takeAux", "code": "def takeAux : Ordnode \u03b1 \u2192 \u2115 \u2192 Ordnode \u03b1\n  | nil, _ => nil\n  | node _ l x r, i =>\n    if i = 0 then nil\n    else\n      match Nat.psub' i (size l) with\n      | none => takeAux l i\n      | some 0 => l\n      | some (j + 1) => link l x (takeAux r j)", "start": [756, 1], "end": [769, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.take", "code": "def take (i : \u2115) (t : Ordnode \u03b1) : Ordnode \u03b1 :=\n  if size t \u2264 i then t else takeAux t i", "start": [772, 1], "end": [777, 40], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dropAux", "code": "def dropAux : Ordnode \u03b1 \u2192 \u2115 \u2192 Ordnode \u03b1\n  | nil, _ => nil\n  | t@(node _ l x r), i =>\n    if i = 0 then t\n    else\n      match Nat.psub' i (size l) with\n      | none => link (dropAux l i) x r\n      | some 0 => insertMin x r\n      | some (j + 1) => dropAux r j", "start": [780, 1], "end": [793, 36], "kind": "commanddeclaration"}, {"full_name": "Ordnode.drop", "code": "def drop (i : \u2115) (t : Ordnode \u03b1) : Ordnode \u03b1 :=\n  if size t \u2264 i then nil else dropAux t i", "start": [796, 1], "end": [801, 42], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitAtAux", "code": "def splitAtAux : Ordnode \u03b1 \u2192 \u2115 \u2192 Ordnode \u03b1 \u00d7 Ordnode \u03b1\n  | nil, _ => (nil, nil)\n  | t@(node _ l x r), i =>\n    if i = 0 then (nil, t)\n    else\n      match Nat.psub' i (size l) with\n      | none =>\n        let (l\u2081, l\u2082) := splitAtAux l i\n        (l\u2081, link l\u2082 x r)\n      | some 0 => (glue l r, insertMin x r)\n      | some (j + 1) =>\n        let (r\u2081, r\u2082) := splitAtAux r j\n        (link l x r\u2081, r\u2082)", "start": [804, 1], "end": [821, 26], "kind": "commanddeclaration"}, {"full_name": "Ordnode.splitAt", "code": "def splitAt (i : \u2115) (t : Ordnode \u03b1) : Ordnode \u03b1 \u00d7 Ordnode \u03b1 :=\n  if size t \u2264 i then (t, nil) else splitAtAux t i", "start": [824, 1], "end": [829, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.takeWhile", "code": "def takeWhile (p : \u03b1 \u2192 Prop) [DecidablePred p] : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node _ l x r => if p x then link l x (takeWhile p r) else takeWhile p l", "start": [832, 1], "end": [839, 76], "kind": "commanddeclaration"}, {"full_name": "Ordnode.dropWhile", "code": "def dropWhile (p : \u03b1 \u2192 Prop) [DecidablePred p] : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | node _ l x r => if p x then dropWhile p r else link (dropWhile p l) x r", "start": [842, 1], "end": [849, 76], "kind": "commanddeclaration"}, {"full_name": "Ordnode.span", "code": "def span (p : \u03b1 \u2192 Prop) [DecidablePred p] : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u00d7 Ordnode \u03b1\n  | nil => (nil, nil)\n  | node _ l x r =>\n    if p x then\n      let (r\u2081, r\u2082) := span p r\n      (link l x r\u2081, r\u2082)\n    else\n      let (l\u2081, l\u2082) := span p l\n      (l\u2081, link l\u2082 x r)", "start": [852, 1], "end": [865, 24], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ofAscListAux\u2081", "code": "def ofAscListAux\u2081 : \u2200 l : List \u03b1, \u2115 \u2192 Ordnode \u03b1 \u00d7 { l' : List \u03b1 // l'.length \u2264 l.length }\n  | [] => fun _ => (nil, \u27e8[], le_rfl\u27e9)\n  | x :: xs => fun s =>\n    if s = 1 then (\u03b9 x, \u27e8xs, Nat.le_succ _\u27e9)\n    else\n      match ofAscListAux\u2081 xs (s <<< 1) with\n      | (t, \u27e8[], _\u27e9) => (t, \u27e8[], Nat.zero_le _\u27e9)\n      | (l, \u27e8y :: ys, h\u27e9) =>\n        have := Nat.le_succ_of_le h\n        let (r, \u27e8zs, h'\u27e9) := ofAscListAux\u2081 ys (s <<< 1)\n        (link l y r, \u27e8zs, le_trans h' (le_of_lt this)\u27e9)\n        termination_by ofAscListAux\u2081 l => l.length", "start": [868, 1], "end": [885, 51], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ofAscListAux\u2082", "code": "def ofAscListAux\u2082 : List \u03b1 \u2192 Ordnode \u03b1 \u2192 \u2115 \u2192 Ordnode \u03b1\n  | [] => fun t _ => t\n  | x :: xs => fun l s =>\n    match ofAscListAux\u2081 xs s with\n    | (r, \u27e8ys, h\u27e9) =>\n      have := Nat.lt_succ_of_le h\n      ofAscListAux\u2082 ys (link l x r) (s <<< 1)\n      termination_by ofAscListAux\u2082 l => l.length", "start": [888, 1], "end": [896, 49], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ofAscList", "code": "def ofAscList : List \u03b1 \u2192 Ordnode \u03b1\n  | [] => nil\n  | x :: xs => ofAscListAux\u2082 xs (\u03b9 x) 1", "start": [899, 1], "end": [905, 40], "kind": "commanddeclaration"}, {"full_name": "Ordnode.mem", "code": "def mem (x : \u03b1) : Ordnode \u03b1 \u2192 Bool\n  | nil => false\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt => mem x l\n    | Ordering.eq => true\n    | Ordering.gt => mem x r", "start": [912, 1], "end": [928, 29], "kind": "commanddeclaration"}, {"full_name": "Ordnode.find", "code": "def find (x : \u03b1) : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt => find x l\n    | Ordering.eq => some y\n    | Ordering.gt => find x r", "start": [931, 1], "end": [947, 30], "kind": "commanddeclaration"}, {"full_name": "Ordnode.mem.decidable", "code": "instance mem.decidable (x : \u03b1) (t : Ordnode \u03b1) : Decidable (x \u2208 t) :=\n  Bool.decEq _ _", "start": [953, 1], "end": [954, 17], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insertWith", "code": "def insertWith (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => \u03b9 x\n  | node sz l y r =>\n    match cmpLE x y with\n    | Ordering.lt => balanceL (insertWith f x l) y r\n    | Ordering.eq => node sz l (f y) r\n    | Ordering.gt => balanceR l y (insertWith f x r)", "start": [957, 1], "end": [974, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.adjustWith", "code": "def adjustWith (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | _t@(node sz l y r) =>\n    match cmpLE x y with\n    | Ordering.lt => node sz (adjustWith f x l) y r\n    | Ordering.eq => node sz l (f y) r\n    | Ordering.gt => node sz l y (adjustWith f x r)", "start": [977, 1], "end": [994, 52], "kind": "commanddeclaration"}, {"full_name": "Ordnode.updateWith", "code": "def updateWith (f : \u03b1 \u2192 Option \u03b1) (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | _t@(node sz l y r) =>\n    match cmpLE x y with\n    | Ordering.lt => balanceR (updateWith f x l) y r\n    | Ordering.eq =>\n      match f y with\n      | none => glue l r\n      | some a => node sz l a r\n    | Ordering.gt => balanceL l y (updateWith f x r)", "start": [997, 1], "end": [1013, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.alter", "code": "def alter (f : Option \u03b1 \u2192 Option \u03b1) (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => Option.recOn (f none) nil Ordnode.singleton\n  | _t@(node sz l y r) =>\n    match cmpLE x y with\n    | Ordering.lt => balance (alter f x l) y r\n    | Ordering.eq =>\n      match f (some y) with\n      | none => glue l r\n      | some a => node sz l a r\n    | Ordering.gt => balance l y (alter f x r)", "start": [1016, 1], "end": [1033, 47], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert", "code": "protected def insert (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => \u03b9 x\n  | node sz l y r =>\n    match cmpLE x y with\n    | Ordering.lt => balanceL (Ordnode.insert x l) y r\n    | Ordering.eq => node sz l x r\n    | Ordering.gt => balanceR l y (Ordnode.insert x r)", "start": [1036, 1], "end": [1052, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.insert'", "code": "def insert' (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => \u03b9 x\n  | t@(node _ l y r) =>\n    match cmpLE x y with\n    | Ordering.lt => balanceL (insert' x l) y r\n    | Ordering.eq => t\n    | Ordering.gt => balanceR l y (insert' x r)", "start": [1058, 1], "end": [1074, 48], "kind": "commanddeclaration"}, {"full_name": "Ordnode.split", "code": "def split (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u00d7 Ordnode \u03b1\n  | nil => (nil, nil)\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt =>\n      let (lt, gt) := split x l\n      (lt, link gt y r)\n    | Ordering.eq => (l, r)\n    | Ordering.gt =>\n      let (lt, gt) := split x r\n      (link l y lt, gt)", "start": [1077, 1], "end": [1098, 24], "kind": "commanddeclaration"}, {"full_name": "Ordnode.split3", "code": "def split3 (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u00d7 Option \u03b1 \u00d7 Ordnode \u03b1\n  | nil => (nil, none, nil)\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt =>\n      let (lt, f, gt) := split3 x l\n      (lt, f, link gt y r)\n    | Ordering.eq => (l, some y, r)\n    | Ordering.gt =>\n      let (lt, f, gt) := split3 x r\n      (link l y lt, f, gt)", "start": [1101, 1], "end": [1122, 27], "kind": "commanddeclaration"}, {"full_name": "Ordnode.erase", "code": "def erase (x : \u03b1) : Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil => nil\n  | _t@(node _ l y r) =>\n    match cmpLE x y with\n    | Ordering.lt => balanceR (erase x l) y r\n    | Ordering.eq => glue l r\n    | Ordering.gt => balanceL l y (erase x r)", "start": [1125, 1], "end": [1141, 46], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findLtAux", "code": "def findLtAux (x : \u03b1) : Ordnode \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | nil, best => best\n  | node _ l y r, best => if x \u2264 y then findLtAux x l best else findLtAux x r y", "start": [1144, 1], "end": [1147, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findLt", "code": "def findLt (x : \u03b1) : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l y r => if x \u2264 y then findLt x l else some (findLtAux x r y)", "start": [1150, 1], "end": [1157, 73], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findGtAux", "code": "def findGtAux (x : \u03b1) : Ordnode \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | nil, best => best\n  | node _ l y r, best => if y \u2264 x then findGtAux x r best else findGtAux x l y", "start": [1160, 1], "end": [1163, 80], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findGt", "code": "def findGt (x : \u03b1) : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l y r => if y \u2264 x then findGt x r else some (findGtAux x l y)", "start": [1166, 1], "end": [1173, 73], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findLeAux", "code": "def findLeAux (x : \u03b1) : Ordnode \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | nil, best => best\n  | node _ l y r, best =>\n    match cmpLE x y with\n    | Ordering.lt => findLeAux x l best\n    | Ordering.eq => y\n    | Ordering.gt => findLeAux x r y", "start": [1176, 1], "end": [1183, 37], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findLe", "code": "def findLe (x : \u03b1) : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt => findLe x l\n    | Ordering.eq => some y\n    | Ordering.gt => some (findLeAux x r y)", "start": [1186, 1], "end": [1197, 44], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findGeAux", "code": "def findGeAux (x : \u03b1) : Ordnode \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  | nil, best => best\n  | node _ l y r, best =>\n    match cmpLE x y with\n    | Ordering.lt => findGeAux x l y\n    | Ordering.eq => y\n    | Ordering.gt => findGeAux x r best", "start": [1200, 1], "end": [1207, 40], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findGe", "code": "def findGe (x : \u03b1) : Ordnode \u03b1 \u2192 Option \u03b1\n  | nil => none\n  | node _ l y r =>\n    match cmpLE x y with\n    | Ordering.lt => some (findGeAux x l y)\n    | Ordering.eq => some y\n    | Ordering.gt => findGe x r", "start": [1211, 1], "end": [1222, 32], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findIndexAux", "code": "def findIndexAux (x : \u03b1) : Ordnode \u03b1 \u2192 \u2115 \u2192 Option \u2115\n  | nil, _ => none\n  | node _ l y r, i =>\n    match cmpLE x y with\n    | Ordering.lt => findIndexAux x l i\n    | Ordering.eq => some (i + size l)\n    | Ordering.gt => findIndexAux x r (i + size l + 1)", "start": [1225, 1], "end": [1232, 55], "kind": "commanddeclaration"}, {"full_name": "Ordnode.findIndex", "code": "def findIndex (x : \u03b1) (t : Ordnode \u03b1) : Option \u2115 :=\n  findIndexAux x t 0", "start": [1235, 1], "end": [1242, 21], "kind": "commanddeclaration"}, {"full_name": "Ordnode.isSubsetAux", "code": "def isSubsetAux : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Bool\n  | nil, _ => true\n  | _, nil => false\n  | node _ l x r, t =>\n    let (lt, found, gt) := split3 x t\n    found.isSome && isSubsetAux l lt && isSubsetAux r gt", "start": [1245, 1], "end": [1251, 57], "kind": "commanddeclaration"}, {"full_name": "Ordnode.isSubset", "code": "def isSubset (t\u2081 t\u2082 : Ordnode \u03b1) : Bool :=\n  decide (size t\u2081 \u2264 size t\u2082) && isSubsetAux t\u2081 t\u2082", "start": [1254, 1], "end": [1259, 50], "kind": "commanddeclaration"}, {"full_name": "Ordnode.disjoint", "code": "def disjoint : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Bool\n  | nil, _ => true\n  | _, nil => true\n  | node _ l x r, t =>\n    let (lt, found, gt) := split3 x t\n    found.isNone && disjoint l lt && disjoint r gt", "start": [1262, 1], "end": [1271, 51], "kind": "commanddeclaration"}, {"full_name": "Ordnode.union", "code": "def union : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | t\u2081, nil => t\u2081\n  | nil, t\u2082 => t\u2082\n  | t\u2081@(node s\u2081 l\u2081 x\u2081 r\u2081), t\u2082@(node s\u2082 _ x\u2082 _) =>\n    if s\u2082 = 1 then insert' x\u2082 t\u2081\n    else\n      if s\u2081 = 1 then insert x\u2081 t\u2082\n      else\n        let (l\u2082', r\u2082') := split x\u2081 t\u2082\n        link (union l\u2081 l\u2082') x\u2081 (union r\u2081 r\u2082')", "start": [1274, 1], "end": [1292, 46], "kind": "commanddeclaration"}, {"full_name": "Ordnode.diff", "code": "def diff : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | t\u2081, nil => t\u2081\n  | t\u2081, t\u2082@(node _ l\u2082 x r\u2082) =>\n    cond t\u2081.empty t\u2082 <|\n      let (l\u2081, r\u2081) := split x t\u2081\n      let l\u2081\u2082 := diff l\u2081 l\u2082\n      let r\u2081\u2082 := diff r\u2081 r\u2082\n      if size l\u2081\u2082 + size r\u2081\u2082 = size t\u2081 then t\u2081 else merge l\u2081\u2082 r\u2081\u2082", "start": [1295, 1], "end": [1306, 66], "kind": "commanddeclaration"}, {"full_name": "Ordnode.inter", "code": "def inter : Ordnode \u03b1 \u2192 Ordnode \u03b1 \u2192 Ordnode \u03b1\n  | nil, _ => nil\n  | t\u2081@(node _ l\u2081 x r\u2081), t\u2082 =>\n    cond t\u2082.empty t\u2081 <|\n      let (l\u2082, y, r\u2082) := split3 x t\u2082\n      let l\u2081\u2082 := inter l\u2081 l\u2082\n      let r\u2081\u2082 := inter r\u2081 r\u2082\n      cond y.isSome (link l\u2081\u2082 x r\u2081\u2082) (merge l\u2081\u2082 r\u2081\u2082)", "start": [1309, 1], "end": [1321, 53], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ofList", "code": "def ofList (l : List \u03b1) : Ordnode \u03b1 :=\n  l.foldr insert nil", "start": [1324, 1], "end": [1334, 21], "kind": "commanddeclaration"}, {"full_name": "Ordnode.ofList'", "code": "def ofList' : List \u03b1 \u2192 Ordnode \u03b1\n  | [] => nil\n  | x :: xs => if List.Chain (fun a b => \u00acb \u2264 a) x xs then ofAscList (x :: xs) else ofList (x :: xs)", "start": [1337, 1], "end": [1344, 101], "kind": "commanddeclaration"}, {"full_name": "Ordnode.image", "code": "def image {\u03b1 \u03b2} [LE \u03b2] [@DecidableRel \u03b2 (\u00b7 \u2264 \u00b7)] (f : \u03b1 \u2192 \u03b2) (t : Ordnode \u03b1) : Ordnode \u03b2 :=\n  ofList (t.toList.map f)", "start": [1347, 1], "end": [1354, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Functor.lean", "imports": ["Mathlib/Data/Multiset/Bind.lean", "Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Control/Traversable/Instances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.functor", "code": "instance functor : Functor Multiset where map := @map", "start": [23, 1], "end": [23, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.fmap_def", "code": "@[simp]\ntheorem fmap_def {\u03b1' \u03b2'} {s : Multiset \u03b1'} (f : \u03b1' \u2192 \u03b2') : f <$> s = s.map f", "start": [25, 1], "end": [27, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.traverse", "code": "def traverse : Multiset \u03b1' \u2192 F (Multiset \u03b2') := by\n  refine' Quotient.lift (Functor.map Coe.coe \u2218 Traversable.traverse f) _\n  introv p; unfold Function.comp\n  induction p\n  case nil => rfl\n  case cons x l\u2081 l\u2082 _ h =>\n    have :\n      Multiset.cons <$> f x <*> Coe.coe <$> Traversable.traverse f l\u2081 =\n        Multiset.cons <$> f x <*> Coe.coe <$> Traversable.traverse f l\u2082 := by rw [h]\n    simpa [functor_norm] using this\n  case swap x y l =>\n    have :\n      (fun a b (l : List \u03b2') \u21a6 (\u2191(a :: b :: l) : Multiset \u03b2')) <$> f y <*> f x =\n        (fun a b l \u21a6 \u2191(a :: b :: l)) <$> f x <*> f y := by\n      rw [CommApplicative.commutative_map]\n      congr\n      funext a b l\n      simpa [flip] using Perm.swap a b l\n    simp [(\u00b7 \u2218 \u00b7), this, functor_norm, Coe.coe]\n  case trans => simp [*]", "start": [38, 1], "end": [60, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.pure_def", "code": "@[simp]\ntheorem pure_def {\u03b1} : (pure : \u03b1 \u2192 Multiset \u03b1) = singleton", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_def", "code": "@[simp]\ntheorem bind_def {\u03b1 \u03b2} : (\u00b7 >>= \u00b7) = @bind \u03b1 \u03b2", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.lift_coe", "code": "@[simp]\ntheorem lift_coe {\u03b1 \u03b2 : Type*} (x : List \u03b1) (f : List \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b : List \u03b1, a \u2248 b \u2192 f a = f b) : Quotient.lift f h (x : Multiset \u03b1) = f x", "start": [88, 1], "end": [91, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_comp_coe", "code": "@[simp]\ntheorem map_comp_coe {\u03b1 \u03b2} (h : \u03b1 \u2192 \u03b2) :\n    Functor.map h \u2218 Coe.coe = (Coe.coe \u2218 Functor.map h : List \u03b1 \u2192 Multiset \u03b2)", "start": [94, 1], "end": [97, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.id_traverse", "code": "theorem id_traverse {\u03b1 : Type*} (x : Multiset \u03b1) : traverse (pure : \u03b1 \u2192 Id \u03b1) x = x", "start": [100, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.comp_traverse", "code": "theorem comp_traverse {G H : Type _ \u2192 Type _} [Applicative G] [Applicative H] [CommApplicative G]\n    [CommApplicative H] {\u03b1 \u03b2 \u03b3 : Type _} (g : \u03b1 \u2192 G \u03b2) (h : \u03b2 \u2192 H \u03b3) (x : Multiset \u03b1) :\n    traverse (Comp.mk \u2218 Functor.map h \u2218 g) x =\n    Comp.mk (Functor.map (traverse h) (traverse g x))", "start": [106, 1], "end": [114, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_traverse", "code": "theorem map_traverse {G : Type* \u2192 Type _} [Applicative G] [CommApplicative G] {\u03b1 \u03b2 \u03b3 : Type _}\n    (g : \u03b1 \u2192 G \u03b2) (h : \u03b2 \u2192 \u03b3) (x : Multiset \u03b1) :\n    Functor.map (Functor.map h) (traverse g x) = traverse (Functor.map h \u2218 g) x", "start": [117, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.traverse_map", "code": "theorem traverse_map {G : Type* \u2192 Type _} [Applicative G] [CommApplicative G] {\u03b1 \u03b2 \u03b3 : Type _}\n    (g : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 G \u03b3) (x : Multiset \u03b1) : traverse h (map g x) = traverse (h \u2218 g) x", "start": [127, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.naturality", "code": "theorem naturality {G H : Type _ \u2192 Type _} [Applicative G] [Applicative H] [CommApplicative G]\n    [CommApplicative H] (eta : ApplicativeTransformation G H) {\u03b1 \u03b2 : Type _} (f : \u03b1 \u2192 G \u03b2)\n    (x : Multiset \u03b1) : eta (traverse f x) = traverse (@eta _ \u2218 f) x", "start": [135, 1], "end": [141, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Kronecker.lean", "imports": ["Mathlib/LinearAlgebra/Matrix/Determinant.lean", "Mathlib/Data/Matrix/Block.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Matrix/NonsingularInverse.lean", "Mathlib/RingTheory/TensorProduct.lean", "Mathlib/LinearAlgebra/TensorProduct.lean", "Mathlib/Data/Matrix/Basic.lean"], "premises": [{"full_name": "Matrix.kroneckerMap", "code": "def kroneckerMap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) : Matrix (l \u00d7 n) (m \u00d7 p) \u03b3 :=\n  of fun (i : l \u00d7 n) (j : m \u00d7 p) => f (A i.1 j.1) (B i.2 j.2)", "start": [57, 1], "end": [59, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_apply", "code": "@[simp]\ntheorem kroneckerMap_apply (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (i j) :\n    kroneckerMap f A B i j = f (A i.1 j.1) (B i.2 j.2)", "start": [63, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_transpose", "code": "theorem kroneckerMap_transpose (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f A\u1d40 B\u1d40 = (kroneckerMap f A B)\u1d40", "start": [69, 1], "end": [71, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_map_left", "code": "theorem kroneckerMap_map_left (f : \u03b1' \u2192 \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b1') (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f (A.map g) B = kroneckerMap (fun a b => f (g a) b) A B", "start": [74, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_map_right", "code": "theorem kroneckerMap_map_right (f : \u03b1 \u2192 \u03b2' \u2192 \u03b3) (g : \u03b2 \u2192 \u03b2') (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f A (B.map g) = kroneckerMap (fun a b => f a (g b)) A B", "start": [79, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_map", "code": "theorem kroneckerMap_map (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b3') (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    (kroneckerMap f A B).map g = kroneckerMap (fun a b => g (f a b)) A B", "start": [84, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_zero_left", "code": "@[simp]\ntheorem kroneckerMap_zero_left [Zero \u03b1] [Zero \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : \u2200 b, f 0 b = 0)\n    (B : Matrix n p \u03b2) : kroneckerMap f (0 : Matrix l m \u03b1) B = 0", "start": [89, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_zero_right", "code": "@[simp]\ntheorem kroneckerMap_zero_right [Zero \u03b2] [Zero \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : \u2200 a, f a 0 = 0)\n    (A : Matrix l m \u03b1) : kroneckerMap f A (0 : Matrix n p \u03b2) = 0", "start": [95, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_add_left", "code": "theorem kroneckerMap_add_left [Add \u03b1] [Add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hf : \u2200 a\u2081 a\u2082 b, f (a\u2081 + a\u2082) b = f a\u2081 b + f a\u2082 b) (A\u2081 A\u2082 : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f (A\u2081 + A\u2082) B = kroneckerMap f A\u2081 B + kroneckerMap f A\u2082 B", "start": [101, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_add_right", "code": "theorem kroneckerMap_add_right [Add \u03b2] [Add \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hf : \u2200 a b\u2081 b\u2082, f a (b\u2081 + b\u2082) = f a b\u2081 + f a b\u2082) (A : Matrix l m \u03b1) (B\u2081 B\u2082 : Matrix n p \u03b2) :\n    kroneckerMap f A (B\u2081 + B\u2082) = kroneckerMap f A B\u2081 + kroneckerMap f A B\u2082", "start": [107, 1], "end": [110, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_smul_left", "code": "theorem kroneckerMap_smul_left [SMul R \u03b1] [SMul R \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (r : R)\n    (hf : \u2200 a b, f (r \u2022 a) b = r \u2022 f a b) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f (r \u2022 A) B = r \u2022 kroneckerMap f A B", "start": [113, 1], "end": [116, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_smul_right", "code": "theorem kroneckerMap_smul_right [SMul R \u03b2] [SMul R \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (r : R)\n    (hf : \u2200 a b, f a (r \u2022 b) = r \u2022 f a b) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) :\n    kroneckerMap f A (r \u2022 B) = r \u2022 kroneckerMap f A B", "start": [119, 1], "end": [122, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_diagonal_diagonal", "code": "theorem kroneckerMap_diagonal_diagonal [Zero \u03b1] [Zero \u03b2] [Zero \u03b3] [DecidableEq m] [DecidableEq n]\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf\u2081 : \u2200 b, f 0 b = 0) (hf\u2082 : \u2200 a, f a 0 = 0) (a : m \u2192 \u03b1) (b : n \u2192 \u03b2) :\n    kroneckerMap f (diagonal a) (diagonal b) = diagonal fun mn => f (a mn.1) (b mn.2)", "start": [125, 1], "end": [129, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_diagonal_right", "code": "theorem kroneckerMap_diagonal_right [Zero \u03b2] [Zero \u03b3] [DecidableEq n] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hf : \u2200 a, f a 0 = 0) (A : Matrix l m \u03b1) (b : n \u2192 \u03b2) :\n    kroneckerMap f A (diagonal b) = blockDiagonal fun i => A.map fun a => f a (b i)", "start": [132, 1], "end": [136, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_diagonal_left", "code": "theorem kroneckerMap_diagonal_left [Zero \u03b1] [Zero \u03b3] [DecidableEq l] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hf : \u2200 b, f 0 b = 0) (a : l \u2192 \u03b1) (B : Matrix m n \u03b2) :\n    kroneckerMap f (diagonal a) B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _)\n        (blockDiagonal fun i => B.map fun b => f (a i) b)", "start": [139, 1], "end": [145, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_one_one", "code": "@[simp]\ntheorem kroneckerMap_one_one [Zero \u03b1] [Zero \u03b2] [Zero \u03b3] [One \u03b1] [One \u03b2] [One \u03b3] [DecidableEq m]\n    [DecidableEq n] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf\u2081 : \u2200 b, f 0 b = 0) (hf\u2082 : \u2200 a, f a 0 = 0)\n    (hf\u2083 : f 1 1 = 1) : kroneckerMap f (1 : Matrix m m \u03b1) (1 : Matrix n n \u03b2) = 1", "start": [148, 1], "end": [152, 91], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_reindex", "code": "theorem kroneckerMap_reindex (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (el : l \u2243 l') (em : m \u2243 m') (en : n \u2243 n') (ep : p \u2243 p')\n    (M : Matrix l m \u03b1) (N : Matrix n p \u03b2) :\n    kroneckerMap f (reindex el em M) (reindex en ep N) =\n      reindex (el.prodCongr en) (em.prodCongr ep) (kroneckerMap f M N)", "start": [155, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_reindex_left", "code": "theorem kroneckerMap_reindex_left (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (el : l \u2243 l') (em : m \u2243 m') (M : Matrix l m \u03b1)\n    (N : Matrix n n' \u03b2) :\n    kroneckerMap f (Matrix.reindex el em M) N =\n      reindex (el.prodCongr (Equiv.refl _)) (em.prodCongr (Equiv.refl _)) (kroneckerMap f M N)", "start": [163, 1], "end": [167, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_reindex_right", "code": "theorem kroneckerMap_reindex_right (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (em : m \u2243 m') (en : n \u2243 n') (M : Matrix l l' \u03b1)\n    (N : Matrix m n \u03b2) :\n    kroneckerMap f M (reindex em en N) =\n      reindex ((Equiv.refl _).prodCongr em) ((Equiv.refl _).prodCongr en) (kroneckerMap f M N)", "start": [170, 1], "end": [174, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_assoc", "code": "theorem kroneckerMap_assoc {\u03b4 \u03be \u03c9 \u03c9' : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4 \u2192 \u03c9) (f' : \u03b1 \u2192 \u03be \u2192 \u03c9')\n    (g' : \u03b2 \u2192 \u03b4 \u2192 \u03be) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (D : Matrix q r \u03b4) (\u03c6 : \u03c9 \u2243 \u03c9')\n    (h\u03c6 : \u2200 a b d, \u03c6 (g (f a b) d) = f' a (g' b d)) :\n    (reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)).trans (Equiv.mapMatrix \u03c6)\n        (kroneckerMap g (kroneckerMap f A B) D) =\n      kroneckerMap f' A (kroneckerMap g' B D)", "start": [177, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMap_assoc\u2081", "code": "theorem kroneckerMap_assoc\u2081 {\u03b4 \u03be \u03c9 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4 \u2192 \u03c9) (f' : \u03b1 \u2192 \u03be \u2192 \u03c9)\n    (g' : \u03b2 \u2192 \u03b4 \u2192 \u03be) (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (D : Matrix q r \u03b4)\n    (h : \u2200 a b d, g (f a b) d = f' a (g' b d)) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)\n        (kroneckerMap g (kroneckerMap f A B) D) =\n      kroneckerMap f' A (kroneckerMap g' B D)", "start": [186, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMapBilinear", "code": "@[simps!]\ndef kroneckerMapBilinear [CommSemiring R] [AddCommMonoid \u03b1] [AddCommMonoid \u03b2] [AddCommMonoid \u03b3]\n    [Module R \u03b1] [Module R \u03b2] [Module R \u03b3] (f : \u03b1 \u2192\u2097[R] \u03b2 \u2192\u2097[R] \u03b3) :\n    Matrix l m \u03b1 \u2192\u2097[R] Matrix n p \u03b2 \u2192\u2097[R] Matrix (l \u00d7 n) (m \u00d7 p) \u03b3 :=\n  LinearMap.mk\u2082 R (kroneckerMap fun r s => f r s) (kroneckerMap_add_left _ <| f.map_add\u2082)\n    (fun _ => kroneckerMap_smul_left _ _ <| f.map_smul\u2082 _)\n    (kroneckerMap_add_right _ fun a => (f a).map_add) fun r =>\n    kroneckerMap_smul_right _ _ fun a => (f a).map_smul r", "start": [195, 1], "end": [203, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerMapBilinear_mul_mul", "code": "theorem kroneckerMapBilinear_mul_mul [CommSemiring R] [Fintype m] [Fintype m']\n    [NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2] [NonUnitalNonAssocSemiring \u03b3]\n    [Module R \u03b1] [Module R \u03b2] [Module R \u03b3] (f : \u03b1 \u2192\u2097[R] \u03b2 \u2192\u2097[R] \u03b3)\n    (h_comm : \u2200 a b a' b', f (a * b) (a' * b') = f a a' * f b b') (A : Matrix l m \u03b1)\n    (B : Matrix m n \u03b1) (A' : Matrix l' m' \u03b2) (B' : Matrix m' n' \u03b2) :\n    kroneckerMapBilinear f (A * B) (A' * B') =\n      kroneckerMapBilinear f A A' * kroneckerMapBilinear f B B'", "start": [206, 1], "end": [219, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_kroneckerMapBilinear", "code": "theorem trace_kroneckerMapBilinear [CommSemiring R] [Fintype m] [Fintype n] [AddCommMonoid \u03b1]\n    [AddCommMonoid \u03b2] [AddCommMonoid \u03b3] [Module R \u03b1] [Module R \u03b2] [Module R \u03b3]\n    (f : \u03b1 \u2192\u2097[R] \u03b2 \u2192\u2097[R] \u03b3) (A : Matrix m m \u03b1) (B : Matrix n n \u03b2) :\n    trace (kroneckerMapBilinear f A B) = f (trace A) (trace B)", "start": [222, 1], "end": [230, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_kroneckerMapBilinear", "code": "theorem det_kroneckerMapBilinear [CommSemiring R] [Fintype m] [Fintype n] [DecidableEq m]\n    [DecidableEq n] [CommRing \u03b1] [CommRing \u03b2] [CommRing \u03b3] [Module R \u03b1] [Module R \u03b2] [Module R \u03b3]\n    (f : \u03b1 \u2192\u2097[R] \u03b2 \u2192\u2097[R] \u03b3) (h_comm : \u2200 a b a' b', f (a * b) (a' * b') = f a a' * f b b')\n    (A : Matrix m m \u03b1) (B : Matrix n n \u03b2) :\n    det (kroneckerMapBilinear f A B) =\n      det (A.map fun a => f a 1) ^ Fintype.card n * det (B.map fun b => f 1 b) ^ Fintype.card m", "start": [233, 1], "end": [253, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker", "code": "@[simp]\ndef kronecker [Mul \u03b1] : Matrix l m \u03b1 \u2192 Matrix n p \u03b1 \u2192 Matrix (l \u00d7 n) (m \u00d7 p) \u03b1 :=\n  kroneckerMap (\u00b7 * \u00b7)", "start": [265, 1], "end": [269, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_apply", "code": "@[simp]\ntheorem kronecker_apply [Mul \u03b1] (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) (i\u2081 i\u2082 j\u2081 j\u2082) :\n    (A \u2297\u2096 B) (i\u2081, i\u2082) (j\u2081, j\u2082) = A i\u2081 j\u2081 * B i\u2082 j\u2082", "start": [276, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerBilinear", "code": "def kroneckerBilinear [CommSemiring R] [Semiring \u03b1] [Algebra R \u03b1] :\n    Matrix l m \u03b1 \u2192\u2097[R] Matrix n p \u03b1 \u2192\u2097[R] Matrix (l \u00d7 n) (m \u00d7 p) \u03b1 :=\n  kroneckerMapBilinear (Algebra.lmul R \u03b1)", "start": [282, 1], "end": [285, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_kronecker", "code": "theorem zero_kronecker [MulZeroClass \u03b1] (B : Matrix n p \u03b1) : (0 : Matrix l m \u03b1) \u2297\u2096 B = 0", "start": [293, 1], "end": [294, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_zero", "code": "theorem kronecker_zero [MulZeroClass \u03b1] (A : Matrix l m \u03b1) : A \u2297\u2096 (0 : Matrix n p \u03b1) = 0", "start": [298, 1], "end": [299, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_kronecker", "code": "theorem add_kronecker [Distrib \u03b1] (A\u2081 A\u2082 : Matrix l m \u03b1) (B : Matrix n p \u03b1) :\n    (A\u2081 + A\u2082) \u2297\u2096 B = A\u2081 \u2297\u2096 B + A\u2082 \u2297\u2096 B", "start": [302, 1], "end": [304, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_add", "code": "theorem kronecker_add [Distrib \u03b1] (A : Matrix l m \u03b1) (B\u2081 B\u2082 : Matrix n p \u03b1) :\n    A \u2297\u2096 (B\u2081 + B\u2082) = A \u2297\u2096 B\u2081 + A \u2297\u2096 B\u2082", "start": [307, 1], "end": [309, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_kronecker", "code": "theorem smul_kronecker [Monoid R] [Monoid \u03b1] [MulAction R \u03b1] [IsScalarTower R \u03b1 \u03b1] (r : R)\n    (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) : (r \u2022 A) \u2297\u2096 B = r \u2022 A \u2297\u2096 B", "start": [312, 1], "end": [314, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_smul", "code": "theorem kronecker_smul [Monoid R] [Monoid \u03b1] [MulAction R \u03b1] [SMulCommClass R \u03b1 \u03b1] (r : R)\n    (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) : A \u2297\u2096 (r \u2022 B) = r \u2022 A \u2297\u2096 B", "start": [317, 1], "end": [319, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_kronecker_diagonal", "code": "theorem diagonal_kronecker_diagonal [MulZeroClass \u03b1] [DecidableEq m] [DecidableEq n] (a : m \u2192 \u03b1)\n    (b : n \u2192 \u03b1) : diagonal a \u2297\u2096 diagonal b = diagonal fun mn => a mn.1 * b mn.2", "start": [322, 1], "end": [324, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_diagonal", "code": "theorem kronecker_diagonal [MulZeroClass \u03b1] [DecidableEq n] (A : Matrix l m \u03b1) (b : n \u2192 \u03b1) :\n    A \u2297\u2096 diagonal b = blockDiagonal fun i => MulOpposite.op (b i) \u2022 A", "start": [327, 1], "end": [329, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_kronecker", "code": "theorem diagonal_kronecker [MulZeroClass \u03b1] [DecidableEq l] (a : l \u2192 \u03b1) (B : Matrix m n \u03b1) :\n    diagonal a \u2297\u2096 B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _) (blockDiagonal fun i => a i \u2022 B)", "start": [332, 1], "end": [335, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_kronecker_one", "code": "theorem one_kronecker_one [MulZeroOneClass \u03b1] [DecidableEq m] [DecidableEq n] :\n    (1 : Matrix m m \u03b1) \u2297\u2096 (1 : Matrix n n \u03b1) = 1", "start": [339, 1], "end": [341, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_one", "code": "theorem kronecker_one [MulZeroOneClass \u03b1] [DecidableEq n] (A : Matrix l m \u03b1) :\n    A \u2297\u2096 (1 : Matrix n n \u03b1) = blockDiagonal fun _ => A", "start": [344, 1], "end": [346, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_kronecker", "code": "theorem one_kronecker [MulZeroOneClass \u03b1] [DecidableEq l] (B : Matrix m n \u03b1) :\n    (1 : Matrix l l \u03b1) \u2297\u2096 B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _) (blockDiagonal fun _ => B)", "start": [349, 1], "end": [353, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_kronecker_mul", "code": "theorem mul_kronecker_mul [Fintype m] [Fintype m'] [CommSemiring \u03b1] (A : Matrix l m \u03b1)\n    (B : Matrix m n \u03b1) (A' : Matrix l' m' \u03b1) (B' : Matrix m' n' \u03b1) :\n    (A * B) \u2297\u2096 (A' * B') = A \u2297\u2096 A' * B \u2297\u2096 B'", "start": [356, 1], "end": [359, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_assoc", "code": "theorem kronecker_assoc [Semigroup \u03b1] (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) (C : Matrix q r \u03b1) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r) (A \u2297\u2096 B \u2297\u2096 C) = A \u2297\u2096 (B \u2297\u2096 C)", "start": [363, 1], "end": [365, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.kronecker_assoc'", "code": "@[simp]\ntheorem kronecker_assoc' [Semigroup \u03b1] (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) (C : Matrix q r \u03b1) :\n    submatrix (A \u2297\u2096 B \u2297\u2096 C) (Equiv.prodAssoc l n q).symm (Equiv.prodAssoc m p r).symm =\n    A \u2297\u2096 (B \u2297\u2096 C)", "start": [368, 1], "end": [372, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_kronecker", "code": "theorem trace_kronecker [Fintype m] [Fintype n] [Semiring \u03b1] (A : Matrix m m \u03b1) (B : Matrix n n \u03b1) :\n    trace (A \u2297\u2096 B) = trace A * trace B", "start": [374, 1], "end": [376, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_kronecker", "code": "theorem det_kronecker [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] [CommRing R]\n    (A : Matrix m m R) (B : Matrix n n R) :\n    det (A \u2297\u2096 B) = det A ^ Fintype.card n * det B ^ Fintype.card m", "start": [379, 1], "end": [387, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.inv_kronecker", "code": "theorem inv_kronecker [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n] [CommRing R]\n    (A : Matrix m m R) (B : Matrix n n R) : (A \u2297\u2096 B)\u207b\u00b9 = A\u207b\u00b9 \u2297\u2096 B\u207b\u00b9", "start": [390, 1], "end": [412, 94], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul", "code": "@[simp]\ndef kroneckerTMul : Matrix l m \u03b1 \u2192 Matrix n p \u03b2 \u2192 Matrix (l \u00d7 n) (m \u00d7 p) (\u03b1 \u2297[R] \u03b2) :=\n  kroneckerMap (\u00b7 \u2297\u209c \u00b7)", "start": [436, 1], "end": [440, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_apply", "code": "@[simp]\ntheorem kroneckerTMul_apply (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (i\u2081 i\u2082 j\u2081 j\u2082) :\n    (A \u2297\u2096\u209c B) (i\u2081, i\u2082) (j\u2081, j\u2082) = A i\u2081 j\u2081 \u2297\u209c[R] B i\u2082 j\u2082", "start": [450, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMulBilinear", "code": "def kroneckerTMulBilinear :\n    Matrix l m \u03b1 \u2192\u2097[R] Matrix n p \u03b2 \u2192\u2097[R] Matrix (l \u00d7 n) (m \u00d7 p) (\u03b1 \u2297[R] \u03b2) :=\n  kroneckerMapBilinear (TensorProduct.mk R \u03b1 \u03b2)", "start": [456, 1], "end": [459, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_kroneckerTMul", "code": "theorem zero_kroneckerTMul (B : Matrix n p \u03b2) : (0 : Matrix l m \u03b1) \u2297\u2096\u209c[R] B = 0", "start": [467, 1], "end": [468, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_zero", "code": "theorem kroneckerTMul_zero (A : Matrix l m \u03b1) : A \u2297\u2096\u209c[R] (0 : Matrix n p \u03b2) = 0", "start": [472, 1], "end": [473, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_kroneckerTMul", "code": "theorem add_kroneckerTMul (A\u2081 A\u2082 : Matrix l m \u03b1) (B : Matrix n p \u03b1) :\n    (A\u2081 + A\u2082) \u2297\u2096\u209c[R] B = A\u2081 \u2297\u2096\u209c B + A\u2082 \u2297\u2096\u209c B", "start": [476, 1], "end": [478, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_add", "code": "theorem kroneckerTMul_add (A : Matrix l m \u03b1) (B\u2081 B\u2082 : Matrix n p \u03b1) :\n    A \u2297\u2096\u209c[R] (B\u2081 + B\u2082) = A \u2297\u2096\u209c B\u2081 + A \u2297\u2096\u209c B\u2082", "start": [481, 1], "end": [483, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_kroneckerTMul", "code": "theorem smul_kroneckerTMul (r : R) (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) :\n    (r \u2022 A) \u2297\u2096\u209c[R] B = r \u2022 A \u2297\u2096\u209c B", "start": [486, 1], "end": [488, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_smul", "code": "theorem kroneckerTMul_smul (r : R) (A : Matrix l m \u03b1) (B : Matrix n p \u03b1) :\n    A \u2297\u2096\u209c[R] (r \u2022 B) = r \u2022 A \u2297\u2096\u209c B", "start": [491, 1], "end": [493, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_kroneckerTMul_diagonal", "code": "theorem diagonal_kroneckerTMul_diagonal [DecidableEq m] [DecidableEq n] (a : m \u2192 \u03b1) (b : n \u2192 \u03b1) :\n    diagonal a \u2297\u2096\u209c[R] diagonal b = diagonal fun mn => a mn.1 \u2297\u209c b mn.2", "start": [496, 1], "end": [498, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_diagonal", "code": "theorem kroneckerTMul_diagonal [DecidableEq n] (A : Matrix l m \u03b1) (b : n \u2192 \u03b1) :\n    A \u2297\u2096\u209c[R] diagonal b = blockDiagonal fun i => A.map fun a => a \u2297\u209c[R] b i", "start": [501, 1], "end": [503, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_kroneckerTMul", "code": "theorem diagonal_kroneckerTMul [DecidableEq l] (a : l \u2192 \u03b1) (B : Matrix m n \u03b1) :\n    diagonal a \u2297\u2096\u209c[R] B =\n      Matrix.reindex (Equiv.prodComm _ _) (Equiv.prodComm _ _)\n        (blockDiagonal fun i => B.map fun b => a i \u2297\u209c[R] b)", "start": [506, 1], "end": [510, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_assoc", "code": "theorem kroneckerTMul_assoc (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (C : Matrix q r \u03b3) :\n    reindex (Equiv.prodAssoc l n q) (Equiv.prodAssoc m p r)\n        (((A \u2297\u2096\u209c[R] B) \u2297\u2096\u209c[R] C).map (TensorProduct.assoc R \u03b1 \u03b2 \u03b3)) =\n      A \u2297\u2096\u209c[R] B \u2297\u2096\u209c[R] C", "start": [514, 1], "end": [518, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.kroneckerTMul_assoc'", "code": "@[simp]\ntheorem kroneckerTMul_assoc' (A : Matrix l m \u03b1) (B : Matrix n p \u03b2) (C : Matrix q r \u03b3) :\n    submatrix (((A \u2297\u2096\u209c[R] B) \u2297\u2096\u209c[R] C).map (TensorProduct.assoc R \u03b1 \u03b2 \u03b3))\n      (Equiv.prodAssoc l n q).symm (Equiv.prodAssoc m p r).symm = A \u2297\u2096\u209c[R] B \u2297\u2096\u209c[R] C", "start": [521, 1], "end": [525, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_kroneckerTMul", "code": "theorem trace_kroneckerTMul [Fintype m] [Fintype n] (A : Matrix m m \u03b1) (B : Matrix n n \u03b2) :\n    trace (A \u2297\u2096\u209c[R] B) = trace A \u2297\u209c[R] trace B", "start": [527, 1], "end": [529, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_kroneckerTMul_one", "code": "@[simp]\ntheorem one_kroneckerTMul_one [DecidableEq m] [DecidableEq n] :\n    (1 : Matrix m m \u03b1) \u2297\u2096\u209c[R] (1 : Matrix n n \u03b1) = 1", "start": [544, 1], "end": [547, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_kroneckerTMul_mul", "code": "theorem mul_kroneckerTMul_mul [Fintype m] [Fintype m'] (A : Matrix l m \u03b1) (B : Matrix m n \u03b1)\n    (A' : Matrix l' m' \u03b2) (B' : Matrix m' n' \u03b2) :\n    (A * B) \u2297\u2096\u209c[R] (A' * B') = A \u2297\u2096\u209c[R] A' * B \u2297\u2096\u209c[R] B'", "start": [550, 1], "end": [553, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.det_kroneckerTMul", "code": "theorem det_kroneckerTMul [Fintype m] [Fintype n] [DecidableEq m] [DecidableEq n]\n    (A : Matrix m m \u03b1) (B : Matrix n n \u03b2) :\n    det (A \u2297\u2096\u209c[R] B) = (det A ^ Fintype.card n) \u2297\u209c[R] (det B ^ Fintype.card m)", "start": [562, 1], "end": [570, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Orthogonal.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.HasOrthogonalRows", "code": "def HasOrthogonalRows [Fintype n] : Prop :=\n  \u2200 \u2983i\u2081 i\u2082\u2984, i\u2081 \u2260 i\u2082 \u2192 dotProduct (A i\u2081) (A i\u2082) = 0", "start": [38, 1], "end": [41, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.HasOrthogonalCols", "code": "def HasOrthogonalCols [Fintype m] : Prop :=\n  HasOrthogonalRows A\u1d40", "start": [44, 1], "end": [47, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_hasOrthogonalRows_iff_hasOrthogonalCols", "code": "@[simp]\ntheorem transpose_hasOrthogonalRows_iff_hasOrthogonalCols [Fintype m] :\n    A\u1d40.HasOrthogonalRows \u2194 A.HasOrthogonalCols", "start": [50, 1], "end": [54, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_hasOrthogonalCols_iff_hasOrthogonalRows", "code": "@[simp]\ntheorem transpose_hasOrthogonalCols_iff_hasOrthogonalRows [Fintype n] :\n    A\u1d40.HasOrthogonalCols \u2194 A.HasOrthogonalRows", "start": [57, 1], "end": [61, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.HasOrthogonalRows.hasOrthogonalCols", "code": "theorem HasOrthogonalRows.hasOrthogonalCols [Fintype m] (h : A\u1d40.HasOrthogonalRows) :\n    A.HasOrthogonalCols", "start": [66, 1], "end": [68, 4], "kind": "commanddeclaration"}, {"full_name": "Matrix.HasOrthogonalCols.transpose_hasOrthogonalRows", "code": "theorem HasOrthogonalCols.transpose_hasOrthogonalRows [Fintype m] (h : A.HasOrthogonalCols) :\n    A\u1d40.HasOrthogonalRows", "start": [71, 1], "end": [73, 4], "kind": "commanddeclaration"}, {"full_name": "Matrix.HasOrthogonalCols.hasOrthogonalRows", "code": "theorem HasOrthogonalCols.hasOrthogonalRows [Fintype n] (h : A\u1d40.HasOrthogonalCols) :\n    A.HasOrthogonalRows", "start": [76, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "Matrix.HasOrthogonalRows.transpose_hasOrthogonalCols", "code": "theorem HasOrthogonalRows.transpose_hasOrthogonalCols [Fintype n] (h : A.HasOrthogonalRows) :\n    A\u1d40.HasOrthogonalCols", "start": [81, 1], "end": [83, 4], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Name.lean", "imports": ["Mathlib/Lean/SMap.lean", "lake-packages/std/Std/Data/HashMap.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isBlackListed", "code": "private def isBlackListed (declName : Name) : CoreM Bool := do\n  if declName.toString.startsWith \"Lean\" then return true\n  let env \u2190 getEnv\n  pure $ declName.isInternal'\n   || isAuxRecursor env declName\n   || isNoConfusion env declName\n  <||> isRec declName <||> isMatcher declName", "start": [19, 1], "end": [25, 46], "kind": "commanddeclaration"}, {"full_name": "allNames", "code": "def allNames (p : Name \u2192 Bool) : CoreM (Array Name) := do\n  (\u2190 getEnv).constants.foldM (init := #[]) fun names n _ => do\n    if p n && !(\u2190 isBlackListed n) then\n      return names.push n\n    else\n      return names", "start": [27, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "allNamesByModule", "code": "def allNamesByModule (p : Name \u2192 Bool) : CoreM (Std.HashMap Name (Array Name)) := do\n  (\u2190 getEnv).constants.foldM (init := Std.HashMap.empty) fun names n _ => do\n    if p n && !(\u2190 isBlackListed n) then\n      let some m \u2190 findModuleOf? n | return names\n      match names.find? m with\n      | some others => return names.insert m (others.push n)\n      | none => return names.insert m #[n]\n    else\n      return names", "start": [37, 1], "end": [50, 19], "kind": "commanddeclaration"}, {"full_name": "getModule", "code": "def getModule (name : Name) (s := \"\") : Name :=\n  match name with\n    | .anonymous => s\n    | .num _ _ => panic s!\"panic in `getModule`: did not expect numerical name: {name}.\"\n    | .str pre s => getModule pre s", "start": [52, 1], "end": [57, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Action.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Elements.lean", "Mathlib/CategoryTheory/SingleObj.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean", "Mathlib/GroupTheory/SemidirectProduct.lean", "Mathlib/CategoryTheory/IsConnected.lean"], "premises": [{"full_name": "CategoryTheory.actionAsFunctor", "code": "@[simps]\ndef actionAsFunctor : SingleObj M \u2964 Type u where\n  obj _ := X\n  map := (\u00b7 \u2022 \u00b7)\n  map_id _ := funext <| MulAction.one_smul\n  map_comp f g := funext fun x => (smul_smul g f x).symm", "start": [34, 1], "end": [41, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory", "code": "def ActionCategory :=\n  (actionAsFunctor M X).Elements", "start": [44, 1], "end": [48, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.\u03c0", "code": "def \u03c0 : ActionCategory M X \u2964 SingleObj M :=\n  CategoryOfElements.\u03c0 _", "start": [57, 1], "end": [60, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.\u03c0_map", "code": "@[simp]\ntheorem \u03c0_map (p q : ActionCategory M X) (f : p \u27f6 q) : (\u03c0 M X).map f = f.val", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.\u03c0_obj", "code": "@[simp]\ntheorem \u03c0_obj (p : ActionCategory M X) : (\u03c0 M X).obj p = SingleObj.star M", "start": [68, 1], "end": [70, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.back", "code": "protected def back : ActionCategory M X \u2192 X := fun x => x.snd", "start": [75, 1], "end": [77, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.coe_back", "code": "@[simp]\ntheorem coe_back (x : X) : ActionCategory.back (x : ActionCategory M X) = x", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.back_coe", "code": "@[simp]\ntheorem back_coe (x : ActionCategory M X) : \u2191x.back = x", "start": [88, 1], "end": [89, 75], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.objEquiv", "code": "def objEquiv : X \u2243 ActionCategory M X where\n  toFun x := x\n  invFun x := x.back\n  left_inv := coe_back\n  right_inv := back_coe", "start": [94, 1], "end": [99, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.hom_as_subtype", "code": "theorem hom_as_subtype (p q : ActionCategory M X) : (p \u27f6 q) = { m : M // m \u2022 p.back = q.back }", "start": [102, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.stabilizerIsoEnd", "code": "def stabilizerIsoEnd : Stabilizer.submonoid M x \u2243* @End (ActionCategory M X) _ x :=\n  MulEquiv.refl _", "start": [114, 1], "end": [117, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.stabilizerIsoEnd_apply", "code": "@[simp]\ntheorem stabilizerIsoEnd_apply (f : Stabilizer.submonoid M x) :\n    (stabilizerIsoEnd M x) f = f", "start": [120, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.stabilizerIsoEnd_symm_apply", "code": "@[simp 1100]\ntheorem stabilizerIsoEnd_symm_apply (f : End _) : (stabilizerIsoEnd M x).symm f = f", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.id_val", "code": "@[simp]\nprotected theorem id_val (x : ActionCategory M X) : Subtype.val (\ud835\udfd9 x) = 1", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.comp_val", "code": "@[simp]\nprotected theorem comp_val {x y z : ActionCategory M X} (f : x \u27f6 y) (g : y \u27f6 z) :\n    (f \u226b g).val = g.val * f.val", "start": [138, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.endMulEquivSubgroup", "code": "def endMulEquivSubgroup (H : Subgroup G) : End (objEquiv G (G \u29f8 H) \u2191(1 : G)) \u2243* H :=\n  MulEquiv.trans (stabilizerIsoEnd G ((1 : G) : G \u29f8 H)).symm\n    (MulEquiv.subgroupCongr <| stabilizer_quotient H)", "start": [156, 1], "end": [159, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.homOfPair", "code": "def homOfPair (t : X) (g : G) : @Quiver.Hom (ActionCategory G X) _ (g\u207b\u00b9 \u2022 t) t :=\n  Subtype.mk g (smul_inv_smul g t)", "start": [162, 1], "end": [164, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.homOfPair.val", "code": "@[simp]\ntheorem homOfPair.val (t : X) (g : G) : (homOfPair t g).val = g", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.cases", "code": "protected def cases {P : \u2200 \u2983a b : ActionCategory G X\u2984, (a \u27f6 b) \u2192 Sort*}\n    (hyp : \u2200 t g, P (homOfPair t g)) \u2983a b\u2984 (f : a \u27f6 b) : P f := by\n  refine' cast _ (hyp b.back f.val)\n  rcases a with \u27e8\u27e8\u27e9, a : X\u27e9\n  rcases b with \u27e8\u27e8\u27e9, b : X\u27e9\n  rcases f with \u27e8g : G, h : g \u2022 a = b\u27e9\n  cases inv_smul_eq_iff.mpr h.symm\n  rfl", "start": [172, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.cases'", "code": "lemma cases' \u2983a' b' : ActionCategory G X\u2984 (f : a' \u27f6 b') :\n    \u2203 (a b : X) (g : G) (ha : a' = a) (hb : b' = b) (hg : a = g\u207b\u00b9 \u2022 b),\n      f = eqToHom (by rw [ha, hg]) \u226b homOfPair b g \u226b eqToHom (by rw [hb]) := by\n  revert a' b' f\n  exact ActionCategory.cases (fun t g => \u27e8g\u207b\u00b9 \u2022 t, t, g, rfl, rfl, rfl, by simp\u27e9)", "start": [184, 1], "end": [188, 82], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ActionCategory.curry", "code": "@[simps]\ndef curry (F : ActionCategory G X \u2964 SingleObj H) : G \u2192* (X \u2192 H) \u22ca[mulAutArrow] G :=\n  have F_map_eq : \u2200 {a b} {f : a \u27f6 b}, F.map f = (F.map (homOfPair b.back f.val) : H) := by\n    apply ActionCategory.cases\n    intros\n    rfl\n  { toFun := fun g => \u27e8fun b => F.map (homOfPair b g), g\u27e9\n    map_one' := by\n      congr\n      dsimp\n      ext1\n      ext b\n      exact F_map_eq.symm.trans (F.map_id b)\n      rfl\n    map_mul' := by\n      intro g h\n      congr\n      ext b\n      exact F_map_eq.symm.trans (F.map_comp (homOfPair (g\u207b\u00b9 \u2022 b) h) (homOfPair b g))\n      rfl }", "start": [192, 1], "end": [213, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ActionCategory.uncurry", "code": "@[simps]\ndef uncurry (F : G \u2192* (X \u2192 H) \u22ca[mulAutArrow] G) (sane : \u2200 g, (F g).right = g) :\n    ActionCategory G X \u2964 SingleObj H where\n  obj _ := ()\n  map {_ b} f := (F f.val).left b.back\n  map_id x := by\n    dsimp\n    rw [F.map_one]\n    rfl\n  map_comp f g := by\n    obtain \u27e8_, z, \u03b3\u2081, rfl, rfl, rfl, rfl\u27e9 := ActionCategory.cases' g\n    obtain \u27e8_, y, \u03b3\u2082, rfl, hy, rfl, rfl\u27e9 := ActionCategory.cases' f\n    obtain rfl : y = \u03b3\u2081\u207b\u00b9 \u2022 z := congr_arg Sigma.snd hy.symm\n    simp [sane]\n    rfl", "start": [216, 1], "end": [237, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "imports": ["Mathlib/GroupTheory/FreeGroup/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsFreeGroup", "code": "class IsFreeGroup (G : Type u) [Group G] where\n  \n  Generators : Type u\n  \n  MulEquiv' : FreeGroup Generators \u2243* G", "start": [42, 1], "end": [50, 40], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.MulEquiv", "code": "def MulEquiv : FreeGroup (Generators G) \u2243* G := IsFreeGroup.MulEquiv'", "start": [61, 1], "end": [62, 70], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.toFreeGroup", "code": "@[simps!]\ndef toFreeGroup : G \u2243* FreeGroup (Generators G) :=\n  (MulEquiv G).symm", "start": [64, 1], "end": [67, 20], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.of", "code": "def of : Generators G \u2192 G :=\n  (MulEquiv G).toFun \u2218 FreeGroup.of", "start": [74, 1], "end": [76, 36], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.of_eq_freeGroup_of", "code": "@[simp]\ntheorem of_eq_freeGroup_of {A : Type u} : @of (FreeGroup A) _ _ = FreeGroup.of", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.lift", "code": "def lift : (Generators G \u2192 H) \u2243 (G \u2192* H) :=\n  FreeGroup.lift.trans\n    { toFun := fun f => f.comp (MulEquiv G).symm.toMonoidHom\n      invFun := fun f => f.comp (MulEquiv G).toMonoidHom\n      left_inv := fun f => by\n        ext\n        simp\n      right_inv := fun f => by\n        ext\n        simp }", "start": [86, 1], "end": [97, 15], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.lift'_eq_freeGroup_lift", "code": "@[simp]\ntheorem lift'_eq_freeGroup_lift {A : Type u} : @lift (FreeGroup A) _ _ H _ = FreeGroup.lift", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.lift_of", "code": "@[simp]\ntheorem lift_of (f : Generators G \u2192 H) (a : Generators G) : lift f (of a) = f a", "start": [105, 1], "end": [107, 40], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (f : G \u2192* H) (a : Generators G) : (lift.symm f) a = f (of a)", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.ext_hom", "code": "@[ext 1050] theorem ext_hom \u2983f g : G \u2192* H\u2984 (h : \u2200 a : Generators G, f (of a) = g (of a)) : f = g", "start": [115, 1], "end": [118, 33], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.unique_lift", "code": "theorem unique_lift (f : Generators G \u2192 H) : \u2203! F : G \u2192* H, \u2200 a, F (of a) = f a", "start": [121, 1], "end": [127, 76], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.ofLift", "code": "def ofLift {G : Type u} [Group G] (X : Type u) (of : X \u2192 G)\n    (lift : \u2200 {H : Type u} [Group H], (X \u2192 H) \u2243 (G \u2192* H))\n    (lift_of : \u2200 {H : Type u} [Group H], \u2200 (f : X \u2192 H) (a), lift f (of a) = f a) : IsFreeGroup G\n    where\n  Generators := X\n  MulEquiv' :=\n    MonoidHom.toMulEquiv (FreeGroup.lift of) (lift FreeGroup.of)\n      (by\n        apply FreeGroup.ext_hom; intro x\n        simp only [MonoidHom.coe_comp, Function.comp_apply, MonoidHom.id_apply, FreeGroup.lift.of,\n          lift_of])\n      (by\n        let lift_symm_of : \u2200 {H : Type u} [Group H], \u2200 (f : G \u2192* H) (a), lift.symm f a = f (of a) :=\n          by intro H _ f a; simp [\u2190 lift_of (lift.symm f)]\n        apply lift.symm.injective; ext x\n        simp only [MonoidHom.coe_comp, Function.comp_apply, MonoidHom.id_apply, FreeGroup.lift.of,\n          lift_of, lift_symm_of])", "start": [130, 1], "end": [148, 34], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.ofUniqueLift", "code": "noncomputable def ofUniqueLift {G : Type u} [Group G] (X : Type u) (of : X \u2192 G)\n    (h : \u2200 {H : Type u} [Group H] (f : X \u2192 H), \u2203! F : G \u2192* H, \u2200 a, F (of a) = f a) :\n    IsFreeGroup G :=\n  let lift {H : Type u} [Group H] : (X \u2192 H) \u2243 (G \u2192* H) :=\n    { toFun := fun f => Classical.choose (h f)\n      invFun := fun F => F \u2218 of\n      left_inv := fun f => funext (Classical.choose_spec (h f)).left\n      right_inv := fun F => ((Classical.choose_spec (h (F \u2218 of))).right F fun _ => rfl).symm }\n  let lift_of {H : Type u} [Group H] (f : X \u2192 H) (a : X) : lift f (of a) = f a :=\n    congr_fun (lift.symm_apply_apply f) a\n  ofLift X of @lift @lift_of", "start": [151, 1], "end": [163, 29], "kind": "commanddeclaration"}, {"full_name": "IsFreeGroup.ofMulEquiv", "code": "def ofMulEquiv {H : Type _} [Group H] (h : G \u2243* H) : IsFreeGroup H\n    where\n  Generators := Generators G\n  MulEquiv' := (MulEquiv G).trans h", "start": [166, 1], "end": [170, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/Arborescence.lean", "imports": ["Mathlib/Combinatorics/Quiver/Path.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Combinatorics/Quiver/Subquiver.lean", "Mathlib/Order/WellFounded.lean"], "premises": [{"full_name": "Quiver.Arborescence", "code": "class Arborescence (V : Type u) [Quiver.{v} V] : Type max u v where\n  \n  root : V\n  \n  uniquePath : \u2200 b : V, Unique (Path root b)", "start": [39, 1], "end": [45, 45], "kind": "commanddeclaration"}, {"full_name": "Quiver.root", "code": "def root (V : Type u) [Quiver V] [Arborescence V] : V :=\n  Arborescence.root", "start": [48, 1], "end": [50, 20], "kind": "commanddeclaration"}, {"full_name": "Quiver.arborescenceMk", "code": "noncomputable def arborescenceMk {V : Type u} [Quiver V] (r : V) (height : V \u2192 \u2115)\n    (height_lt : \u2200 \u2983a b\u2984, (a \u27f6 b) \u2192 height a < height b)\n    (unique_arrow : \u2200 \u2983a b c : V\u2984 (e : a \u27f6 c) (f : b \u27f6 c), a = b \u2227 HEq e f)\n    (root_or_arrow : \u2200 b, b = r \u2228 \u2203 a, Nonempty (a \u27f6 b)) :\n    Arborescence V where\n  root := r\n  uniquePath b :=\n    \u27e8Classical.inhabited_of_nonempty (by\n      rcases show \u2203 n, height b < n from \u27e8_, Nat.lt.base _\u27e9 with \u27e8n, hn\u27e9\n      induction' n with n ih generalizing b\n      \u00b7 exact False.elim (Nat.not_lt_zero _ hn)\n      rcases root_or_arrow b with (\u27e8\u27e8\u27e9\u27e9 | \u27e8a, \u27e8e\u27e9\u27e9)\n      \u00b7 exact \u27e8Path.nil\u27e9\n      \u00b7 rcases ih a (lt_of_lt_of_le (height_lt e) (Nat.lt_succ_iff.mp hn)) with \u27e8p\u27e9\n        exact \u27e8p.cons e\u27e9), by\n      have height_le : \u2200 {a b}, Path a b \u2192 height a \u2264 height b := by\n        intro a b p\n        induction' p with b c _ e ih\n        rfl\n        exact le_of_lt (lt_of_le_of_lt ih (height_lt e))\n      suffices \u2200 p q : Path r b, p = q by\n        intro p\n        apply this\n      intro p q\n      induction' p with a c p e ih <;> cases' q with b _ q f\n      \u00b7 rfl\n      \u00b7 exact False.elim (lt_irrefl _ (lt_of_le_of_lt (height_le q) (height_lt f)))\n      \u00b7 exact False.elim (lt_irrefl _ (lt_of_le_of_lt (height_le p) (height_lt e)))\n      \u00b7 rcases unique_arrow e f with \u27e8\u27e8\u27e9, \u27e8\u27e9\u27e9\n        rw [ih]\u27e9", "start": [56, 1], "end": [90, 17], "kind": "commanddeclaration"}, {"full_name": "Quiver.RootedConnected", "code": "class RootedConnected {V : Type u} [Quiver V] (r : V) : Prop where\n  nonempty_path : \u2200 b : V, Nonempty (Path r b)", "start": [93, 1], "end": [95, 47], "kind": "commanddeclaration"}, {"full_name": "Quiver.shortestPath", "code": "noncomputable def shortestPath (b : V) : Path r b :=\n  WellFounded.min (measure Path.length).wf Set.univ Set.univ_nonempty", "start": [104, 1], "end": [106, 70], "kind": "commanddeclaration"}, {"full_name": "Quiver.shortest_path_spec", "code": "theorem shortest_path_spec {a : V} (p : Path r a) : (shortestPath r a).length \u2264 p.length", "start": [109, 1], "end": [111, 71], "kind": "commanddeclaration"}, {"full_name": "Quiver.geodesicSubtree", "code": "def geodesicSubtree : WideSubquiver V := fun a b =>\n  { e | \u2203 p : Path r a, shortestPath r b = p.cons e }", "start": [114, 1], "end": [116, 54], "kind": "commanddeclaration"}, {"full_name": "Quiver.geodesicArborescence", "code": "noncomputable instance geodesicArborescence : Arborescence (geodesicSubtree r) :=\n  arborescenceMk r (fun a => (shortestPath r a).length)\n    (by\n      rintro a b \u27e8e, p, h\u27e9\n      simp_rw [h, Path.length_cons, Nat.lt_succ_iff]\n      apply shortest_path_spec)\n    (by\n      rintro a b c \u27e8e, p, h\u27e9 \u27e8f, q, j\u27e9\n      cases h.symm.trans j\n      constructor <;> rfl)\n    (by\n      intro b\n      rcases hp : shortestPath r b with (_ | \u27e8p, e\u27e9)\n      \u00b7 exact Or.inl rfl\n      \u00b7 exact Or.inr \u27e8_, \u27e8\u27e8e, p, hp\u27e9\u27e9\u27e9)", "start": [119, 1], "end": [133, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/QPF/Multivariate/Basic.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvQPF", "code": "class MvQPF {n : \u2115} (F : TypeVec.{u} n \u2192 Type*) [MvFunctor F] where\n  P : MvPFunctor.{u} n\n  abs : \u2200 {\u03b1}, P \u03b1 \u2192 F \u03b1\n  repr : \u2200 {\u03b1}, F \u03b1 \u2192 P \u03b1\n  abs_repr : \u2200 {\u03b1} (x : F \u03b1), abs (repr x) = x\n  abs_map : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u27f9 \u03b2) (p : P \u03b1), abs (f <$$> p) = f <$$> abs p", "start": [83, 1], "end": [90, 73], "kind": "commanddeclaration"}, {"full_name": "MvQPF.id_map", "code": "protected theorem id_map {\u03b1 : TypeVec n} (x : F \u03b1) : TypeVec.id <$$> x = x", "start": [104, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "MvQPF.comp_map", "code": "@[simp]\ntheorem comp_map {\u03b1 \u03b2 \u03b3 : TypeVec n} (f : \u03b1 \u27f9 \u03b2) (g : \u03b2 \u27f9 \u03b3) (x : F \u03b1) :\n    (g \u229a f) <$$> x = g <$$> f <$$> x", "start": [111, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "MvQPF.lawfulMvFunctor", "code": "instance (priority := 100) lawfulMvFunctor : LawfulMvFunctor F where\n  id_map := @MvQPF.id_map n F _ _\n  comp_map := @comp_map n F _ _", "start": [120, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftP_iff", "code": "theorem liftP_iff {\u03b1 : TypeVec n} (p : \u2200 \u2983i\u2984, \u03b1 i \u2192 Prop) (x : F \u03b1) :\n    LiftP p x \u2194 \u2203 a f, x = abs \u27e8a, f\u27e9 \u2227 \u2200 i j, p (f i j)", "start": [126, 1], "end": [138, 26], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftR_iff", "code": "theorem liftR_iff {\u03b1 : TypeVec n} (r : \u2200  {i}, \u03b1 i \u2192 \u03b1 i \u2192 Prop) (x y : F \u03b1) :\n    LiftR r x y \u2194 \u2203 a f\u2080 f\u2081, x = abs \u27e8a, f\u2080\u27e9 \u2227 y = abs \u27e8a, f\u2081\u27e9 \u2227 \u2200 i j, r (f\u2080 i j) (f\u2081 i j)", "start": [141, 1], "end": [157, 27], "kind": "commanddeclaration"}, {"full_name": "MvQPF.mem_supp", "code": "theorem mem_supp {\u03b1 : TypeVec n} (x : F \u03b1) (i) (u : \u03b1 i) :\n    u \u2208 supp x i \u2194 \u2200 a f, abs \u27e8a, f\u27e9 = x \u2192 u \u2208 f i '' univ", "start": [164, 1], "end": [177, 22], "kind": "commanddeclaration"}, {"full_name": "MvQPF.supp_eq", "code": "theorem supp_eq {\u03b1 : TypeVec n} {i} (x : F \u03b1) :\n    supp x i = { u | \u2200 a f, abs \u27e8a, f\u27e9 = x \u2192 u \u2208 f i '' univ }", "start": [180, 1], "end": [181, 89], "kind": "commanddeclaration"}, {"full_name": "MvQPF.has_good_supp_iff", "code": "theorem has_good_supp_iff {\u03b1 : TypeVec n} (x : F \u03b1) :\n    (\u2200 p, LiftP p x \u2194 \u2200 (i), \u2200 u \u2208 supp x i, p i u) \u2194\n      \u2203 a f, abs \u27e8a, f\u27e9 = x \u2227 \u2200 i a' f', abs \u27e8a', f'\u27e9 = x \u2192 f i '' univ \u2286 f' i '' univ", "start": [184, 1], "end": [207, 40], "kind": "commanddeclaration"}, {"full_name": "MvQPF.IsUniform", "code": "def IsUniform : Prop :=\n  \u2200 \u2983\u03b1 : TypeVec n\u2984 (a a' : q.P.A) (f : q.P.B a \u27f9 \u03b1) (f' : q.P.B a' \u27f9 \u03b1),\n    abs \u27e8a, f\u27e9 = abs \u27e8a', f'\u27e9 \u2192 \u2200 i, f i '' univ = f' i '' univ", "start": [210, 1], "end": [214, 64], "kind": "commanddeclaration"}, {"full_name": "MvQPF.LiftPPreservation", "code": "def LiftPPreservation : Prop :=\n  \u2200 \u2983\u03b1 : TypeVec n\u2984 (p : \u2200 \u2983i\u2984, \u03b1 i \u2192 Prop) (x : q.P \u03b1), LiftP p (abs x) \u2194 LiftP p x", "start": [217, 1], "end": [219, 85], "kind": "commanddeclaration"}, {"full_name": "MvQPF.SuppPreservation", "code": "def SuppPreservation : Prop :=\n  \u2200 \u2983\u03b1\u2984 (x : q.P \u03b1), supp (abs x) = supp x", "start": [222, 1], "end": [224, 43], "kind": "commanddeclaration"}, {"full_name": "MvQPF.supp_eq_of_isUniform", "code": "theorem supp_eq_of_isUniform (h : q.IsUniform) {\u03b1 : TypeVec n} (a : q.P.A) (f : q.P.B a \u27f9 \u03b1) :\n    \u2200 i, supp (abs \u27e8a, f\u27e9) i = f i '' univ", "start": [227, 1], "end": [233, 36], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftP_iff_of_isUniform", "code": "theorem liftP_iff_of_isUniform (h : q.IsUniform) {\u03b1 : TypeVec n} (x : F \u03b1) (p : \u2200 i, \u03b1 i \u2192 Prop) :\n    LiftP p x \u2194 \u2200 (i), \u2200 u \u2208 supp x i, p i u", "start": [236, 1], "end": [248, 29], "kind": "commanddeclaration"}, {"full_name": "MvQPF.supp_map", "code": "theorem supp_map (h : q.IsUniform) {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (x : F \u03b1) (i) :\n    supp (g <$$> x) i = g i '' supp x i", "start": [251, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "MvQPF.suppPreservation_iff_isUniform", "code": "theorem suppPreservation_iff_isUniform : q.SuppPreservation \u2194 q.IsUniform", "start": [258, 1], "end": [264, 51], "kind": "commanddeclaration"}, {"full_name": "MvQPF.suppPreservation_iff_liftpPreservation", "code": "theorem suppPreservation_iff_liftpPreservation : q.SuppPreservation \u2194 q.LiftPPreservation", "start": [267, 1], "end": [279, 38], "kind": "commanddeclaration"}, {"full_name": "MvQPF.liftpPreservation_iff_uniform", "code": "theorem liftpPreservation_iff_uniform : q.LiftPPreservation \u2194 q.IsUniform", "start": [282, 1], "end": [283, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/Flow.lean", "imports": ["Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Logic/Function/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsInvariant", "code": "def IsInvariant (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1) (s : Set \u03b1) : Prop :=\n  \u2200 t, MapsTo (\u03d5 t) s s", "start": [43, 1], "end": [46, 24], "kind": "commanddeclaration"}, {"full_name": "isInvariant_iff_image", "code": "theorem isInvariant_iff_image : IsInvariant \u03d5 s \u2194 \u2200 t, \u03d5 t '' s \u2286 s", "start": [51, 1], "end": [52, 33], "kind": "commanddeclaration"}, {"full_name": "IsFwInvariant", "code": "def IsFwInvariant [Preorder \u03c4] [Zero \u03c4] (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983t\u2984, 0 \u2264 t \u2192 MapsTo (\u03d5 t) s s", "start": [55, 1], "end": [58, 34], "kind": "commanddeclaration"}, {"full_name": "IsInvariant.isFwInvariant", "code": "theorem IsInvariant.isFwInvariant [Preorder \u03c4] [Zero \u03c4] {\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1} {s : Set \u03b1}\n    (h : IsInvariant \u03d5 s) : IsFwInvariant \u03d5 s", "start": [61, 1], "end": [62, 66], "kind": "commanddeclaration"}, {"full_name": "IsFwInvariant.isInvariant", "code": "theorem IsFwInvariant.isInvariant [CanonicallyOrderedAddCommMonoid \u03c4] {\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1} {s : Set \u03b1}\n    (h : IsFwInvariant \u03d5 s) : IsInvariant \u03d5 s", "start": [65, 1], "end": [68, 72], "kind": "commanddeclaration"}, {"full_name": "isFwInvariant_iff_isInvariant", "code": "theorem isFwInvariant_iff_isInvariant [CanonicallyOrderedAddCommMonoid \u03c4] {\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1}\n    {s : Set \u03b1} :\n    IsFwInvariant \u03d5 s \u2194 IsInvariant \u03d5 s", "start": [71, 1], "end": [76, 57], "kind": "commanddeclaration"}, {"full_name": "Flow", "code": "structure Flow (\u03c4 : Type*) [TopologicalSpace \u03c4] [AddMonoid \u03c4] [ContinuousAdd \u03c4] (\u03b1 : Type*)\n  [TopologicalSpace \u03b1] where\n  toFun : \u03c4 \u2192 \u03b1 \u2192 \u03b1\n  cont' : Continuous (uncurry toFun)\n  map_add' : \u2200 t\u2081 t\u2082 x, toFun (t\u2081 + t\u2082) x = toFun t\u2081 (toFun t\u2082 x)\n  map_zero' : \u2200 x, toFun 0 x = x", "start": [86, 1], "end": [93, 33], "kind": "commanddeclaration"}, {"full_name": "Flow.ext", "code": "@[ext]\ntheorem ext : \u2200 {\u03d5\u2081 \u03d5\u2082 : Flow \u03c4 \u03b1}, (\u2200 t x, \u03d5\u2081 t x = \u03d5\u2082 t x) \u2192 \u03d5\u2081 = \u03d5\u2082", "start": [109, 1], "end": [114, 16], "kind": "commanddeclaration"}, {"full_name": "Flow.continuous", "code": "@[continuity]\nprotected theorem continuous {\u03b2 : Type*} [TopologicalSpace \u03b2] {t : \u03b2 \u2192 \u03c4} (ht : Continuous t)\n    {f : \u03b2 \u2192 \u03b1} (hf : Continuous f) : Continuous fun x => \u03d5 (t x) (f x)", "start": [117, 1], "end": [120, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.flow", "code": "alias _root_.Continuous.flow := Flow.continuous", "start": [123, 1], "end": [123, 48], "kind": "stdtacticaliasalias"}, {"full_name": "Flow.map_add", "code": "theorem map_add (t\u2081 t\u2082 : \u03c4) (x : \u03b1) : \u03d5 (t\u2081 + t\u2082) x = \u03d5 t\u2081 (\u03d5 t\u2082 x)", "start": [126, 1], "end": [126, 88], "kind": "commanddeclaration"}, {"full_name": "Flow.map_zero", "code": "@[simp]\ntheorem map_zero : \u03d5 0 = id", "start": [129, 1], "end": [130, 50], "kind": "commanddeclaration"}, {"full_name": "Flow.map_zero_apply", "code": "theorem map_zero_apply (x : \u03b1) : \u03d5 0 x = x", "start": [133, 1], "end": [133, 60], "kind": "commanddeclaration"}, {"full_name": "Flow.fromIter", "code": "def fromIter {g : \u03b1 \u2192 \u03b1} (h : Continuous g) : Flow \u2115 \u03b1 where\n  toFun n x := g^[n] x\n  cont' := continuous_prod_of_discrete_left.mpr (Continuous.iterate h)\n  map_add' := iterate_add_apply _\n  map_zero' _x := rfl", "start": [136, 1], "end": [142, 22], "kind": "commanddeclaration"}, {"full_name": "Flow.restrict", "code": "def restrict {s : Set \u03b1} (h : IsInvariant \u03d5 s) : Flow \u03c4 (\u21a5s) where\n  toFun t := (h t).restrict _ _ _\n  cont' := (\u03d5.continuous continuous_fst continuous_subtype_val.snd').subtype_mk _\n  map_add' _ _ _ := Subtype.ext (map_add _ _ _ _)\n  map_zero' _ := Subtype.ext (map_zero_apply _ _)", "start": [145, 1], "end": [150, 50], "kind": "commanddeclaration"}, {"full_name": "Flow.isInvariant_iff_image_eq", "code": "theorem isInvariant_iff_image_eq (s : Set \u03b1) : IsInvariant \u03d5 s \u2194 \u2200 t, \u03d5 t '' s = s", "start": [160, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "Flow.reverse", "code": "def reverse : Flow \u03c4 \u03b1 where\n  toFun t := \u03d5 (-t)\n  cont' := \u03d5.continuous continuous_fst.neg continuous_snd\n  map_add' _ _ _ := by dsimp; rw [neg_add, map_add]\n  map_zero' _ := by dsimp; rw [neg_zero, map_zero_apply]", "start": [167, 1], "end": [173, 57], "kind": "commanddeclaration"}, {"full_name": "Flow.continuous_toFun", "code": "@[continuity]\ntheorem continuous_toFun (t : \u03c4) : Continuous (\u03d5.toFun t)", "start": [179, 1], "end": [183, 16], "kind": "commanddeclaration"}, {"full_name": "Flow.toHomeomorph", "code": "def toHomeomorph (t : \u03c4) : (\u03b1 \u2243\u209c \u03b1) where\n  toFun := \u03d5 t\n  invFun := \u03d5 (-t)\n  left_inv x := by rw [\u2190 map_add, neg_add_self, map_zero_apply]\n  right_inv x := by rw [\u2190 map_add, add_neg_self, map_zero_apply]", "start": [185, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "Flow.image_eq_preimage", "code": "theorem image_eq_preimage (t : \u03c4) (s : Set \u03b1) : \u03d5 t '' s = \u03d5 (-t) \u207b\u00b9' s", "start": [193, 1], "end": [194, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/EulerSineProd.lean", "Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "Mathlib/Analysis/Analytic/IsolatedZeros.lean", "Mathlib/Analysis/Convolution.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.betaIntegral", "code": "noncomputable def betaIntegral (u v : \u2102) : \u2102 :=\n  \u222b x : \u211d in (0)..1, (x : \u2102) ^ (u - 1) * (1 - (x : \u2102)) ^ (v - 1)", "start": [58, 1], "end": [60, 65], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_convergent_left", "code": "theorem betaIntegral_convergent_left {u : \u2102} (hu : 0 < re u) (v : \u2102) :\n    IntervalIntegrable (fun x =>\n      (x : \u2102) ^ (u - 1) * (1 - (x : \u2102)) ^ (v - 1) : \u211d \u2192 \u2102) volume 0 (1 / 2)", "start": [63, 1], "end": [77, 67], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_convergent", "code": "theorem betaIntegral_convergent {u v : \u2102} (hu : 0 < re u) (hv : 0 < re v) :\n    IntervalIntegrable (fun x =>\n      (x : \u2102) ^ (u - 1) * (1 - (x : \u2102)) ^ (v - 1) : \u211d \u2192 \u2102) volume 0 1", "start": [80, 1], "end": [91, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_symm", "code": "theorem betaIntegral_symm (u v : \u2102) : betaIntegral v u = betaIntegral u v", "start": [94, 1], "end": [101, 13], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_eval_one_right", "code": "theorem betaIntegral_eval_one_right {u : \u2102} (hu : 0 < re u) : betaIntegral u 1 = 1 / u", "start": [104, 1], "end": [110, 68], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_scaled", "code": "theorem betaIntegral_scaled (s t : \u2102) {a : \u211d} (ha : 0 < a) :\n    \u222b x in (0)..a, (x : \u2102) ^ (s - 1) * ((a : \u2102) - x) ^ (t - 1) =\n    (a : \u2102) ^ (s + t - 1) * betaIntegral s t", "start": [113, 1], "end": [131, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_mul_Gamma_eq_betaIntegral", "code": "theorem Gamma_mul_Gamma_eq_betaIntegral {s t : \u2102} (hs : 0 < re s) (ht : 0 < re t) :\n    Gamma s * Gamma t = Gamma (s + t) * betaIntegral s t", "start": [134, 1], "end": [150, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_recurrence", "code": "theorem betaIntegral_recurrence {u v : \u2102} (hu : 0 < re u) (hv : 0 < re v) :\n    u * betaIntegral u (v + 1) = v * betaIntegral (u + 1) v", "start": [153, 1], "end": [208, 49], "kind": "commanddeclaration"}, {"full_name": "Complex.betaIntegral_eval_nat_add_one_right", "code": "theorem betaIntegral_eval_nat_add_one_right {u : \u2102} (hu : 0 < re u) (n : \u2115) :\n    betaIntegral u (n + 1) = n ! / \u220f j : \u2115 in Finset.range (n + 1), (u + j)", "start": [211, 1], "end": [226, 20], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq", "code": "noncomputable def GammaSeq (s : \u2102) (n : \u2115) :=\n  (n : \u2102) ^ s * n ! / \u220f j : \u2115 in Finset.range (n + 1), (s + j)", "start": [240, 1], "end": [243, 63], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq_eq_betaIntegral_of_re_pos", "code": "theorem GammaSeq_eq_betaIntegral_of_re_pos {s : \u2102} (hs : 0 < re s) (n : \u2115) :\n    GammaSeq s n = (n : \u2102) ^ s * betaIntegral s (n + 1)", "start": [246, 1], "end": [248, 75], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq_add_one_left", "code": "theorem GammaSeq_add_one_left (s : \u2102) {n : \u2115} (hn : n \u2260 0) :\n    GammaSeq (s + 1) n / s = n / (n + 1 + s) * GammaSeq s n", "start": [251, 1], "end": [261, 9], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq_eq_approx_Gamma_integral", "code": "theorem GammaSeq_eq_approx_Gamma_integral {s : \u2102} (hs : 0 < re s) {n : \u2115} (hn : n \u2260 0) :\n    GammaSeq s n = \u222b x : \u211d in (0)..n, \u2191((1 - x / n) ^ n) * (x : \u2102) ^ (s - 1)", "start": [264, 1], "end": [285, 33], "kind": "commanddeclaration"}, {"full_name": "Complex.approx_Gamma_integral_tendsto_Gamma_integral", "code": "theorem approx_Gamma_integral_tendsto_Gamma_integral {s : \u2102} (hs : 0 < re s) :\n    Tendsto (fun n : \u2115 => \u222b x : \u211d in (0)..n, \u2191((1 - x / n) ^ n) * (x : \u2102) ^ (s - 1)) atTop\n      (\ud835\udcdd <| Gamma s)", "start": [288, 1], "end": [348, 43], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq_tendsto_Gamma", "code": "theorem GammaSeq_tendsto_Gamma (s : \u2102) : Tendsto (GammaSeq s) atTop (\ud835\udcdd <| Gamma s)", "start": [351, 1], "end": [381, 48], "kind": "commanddeclaration"}, {"full_name": "Complex.GammaSeq_mul", "code": "theorem GammaSeq_mul (z : \u2102) {n : \u2115} (hn : n \u2260 0) :\n    GammaSeq z n * GammaSeq (1 - z) n =\n      n / (n + \u21911 - z) * (\u21911 / (z * \u220f j in Finset.range n, (\u21911 - z ^ 2 / ((j : \u2102) + 1) ^ 2)))", "start": [395, 1], "end": [416, 72], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_mul_Gamma_one_sub", "code": "theorem Gamma_mul_Gamma_one_sub (z : \u2102) : Gamma z * Gamma (1 - z) = \u03c0 / sin (\u03c0 * z)", "start": [419, 1], "end": [443, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_ne_zero", "code": "theorem Gamma_ne_zero {s : \u2102} (hs : \u2200 m : \u2115, s \u2260 -m) : Gamma s \u2260 0", "start": [446, 1], "end": [466, 14], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_eq_zero_iff", "code": "theorem Gamma_eq_zero_iff (s : \u2102) : Gamma s = 0 \u2194 \u2203 m : \u2115, s = -m", "start": [469, 1], "end": [472, 51], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_ne_zero_of_re_pos", "code": "theorem Gamma_ne_zero_of_re_pos {s : \u2102} (hs : 0 < re s) : Gamma s \u2260 0", "start": [475, 1], "end": [479, 92], "kind": "commanddeclaration"}, {"full_name": "Real.GammaSeq", "code": "noncomputable def GammaSeq (s : \u211d) (n : \u2115) :=\n  (n : \u211d) ^ s * n ! / \u220f j : \u2115 in Finset.range (n + 1), (s + j)", "start": [486, 1], "end": [489, 63], "kind": "commanddeclaration"}, {"full_name": "Real.GammaSeq_tendsto_Gamma", "code": "theorem GammaSeq_tendsto_Gamma (s : \u211d) : Tendsto (GammaSeq s) atTop (\ud835\udcdd <| Gamma s)", "start": [492, 1], "end": [500, 66], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_mul_Gamma_one_sub", "code": "theorem Gamma_mul_Gamma_one_sub (s : \u211d) : Gamma s * Gamma (1 - s) = \u03c0 / sin (\u03c0 * s)", "start": [503, 1], "end": [507, 42], "kind": "commanddeclaration"}, {"full_name": "Complex.one_div_Gamma_eq_self_mul_one_div_Gamma_add_one", "code": "theorem one_div_Gamma_eq_self_mul_one_div_Gamma_add_one (s : \u2102) :\n    (Gamma s)\u207b\u00b9 = s * (Gamma (s + 1))\u207b\u00b9", "start": [527, 1], "end": [532, 50], "kind": "commanddeclaration"}, {"full_name": "Complex.differentiable_one_div_Gamma", "code": "theorem differentiable_one_div_Gamma : Differentiable \u2102 fun s : \u2102 => (Gamma s)\u207b\u00b9", "start": [535, 1], "end": [554, 61], "kind": "commanddeclaration"}, {"full_name": "Complex.Gamma_mul_Gamma_add_half", "code": "theorem Gamma_mul_Gamma_add_half (s : \u2102) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : \u2102) ^ (1 - 2 * s) * \u2191(Real.sqrt \u03c0)", "start": [574, 1], "end": [604, 43], "kind": "commanddeclaration"}, {"full_name": "Real.Gamma_mul_Gamma_add_half", "code": "theorem Gamma_mul_Gamma_add_half (s : \u211d) :\n    Gamma s * Gamma (s + 1 / 2) = Gamma (2 * s) * (2 : \u211d) ^ (1 - 2 * s) * sqrt \u03c0", "start": [613, 1], "end": [617, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ZetaValues.lean", "imports": ["Mathlib/NumberTheory/BernoulliPolynomials.lean", "Mathlib/Analysis/PSeries.lean", "Mathlib/Analysis/Calculus/Deriv/Polynomial.lean", "Mathlib/Analysis/Fourier/AddCircle.lean", "Mathlib/MeasureTheory/Integral/IntervalIntegral.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "bernoulliFun", "code": "def bernoulliFun (k : \u2115) (x : \u211d) : \u211d :=\n  (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli k)).eval x", "start": [48, 1], "end": [50, 68], "kind": "commanddeclaration"}, {"full_name": "bernoulliFun_eval_zero", "code": "theorem bernoulliFun_eval_zero (k : \u2115) : bernoulliFun k 0 = bernoulli k", "start": [53, 1], "end": [54, 90], "kind": "commanddeclaration"}, {"full_name": "bernoulliFun_endpoints_eq_of_ne_one", "code": "theorem bernoulliFun_endpoints_eq_of_ne_one {k : \u2115} (hk : k \u2260 1) :\n    bernoulliFun k 1 = bernoulliFun k 0", "start": [57, 1], "end": [60, 54], "kind": "commanddeclaration"}, {"full_name": "bernoulliFun_eval_one", "code": "theorem bernoulliFun_eval_one (k : \u2115) : bernoulliFun k 1 = bernoulliFun k 0 + ite (k = 1) 1 0", "start": [63, 1], "end": [68, 67], "kind": "commanddeclaration"}, {"full_name": "hasDerivAt_bernoulliFun", "code": "theorem hasDerivAt_bernoulliFun (k : \u2115) (x : \u211d) :\n    HasDerivAt (bernoulliFun k) (k * bernoulliFun (k - 1) x) x", "start": [71, 1], "end": [75, 96], "kind": "commanddeclaration"}, {"full_name": "antideriv_bernoulliFun", "code": "theorem antideriv_bernoulliFun (k : \u2115) (x : \u211d) :\n    HasDerivAt (fun x => bernoulliFun (k + 1) x / (k + 1)) (bernoulliFun k x) x", "start": [78, 1], "end": [82, 7], "kind": "commanddeclaration"}, {"full_name": "integral_bernoulliFun_eq_zero", "code": "theorem integral_bernoulliFun_eq_zero {k : \u2115} (hk : k \u2260 0) :\n    \u222b x : \u211d in (0)..1, bernoulliFun k x = 0", "start": [85, 1], "end": [92, 9], "kind": "commanddeclaration"}, {"full_name": "bernoulliFourierCoeff", "code": "def bernoulliFourierCoeff (k : \u2115) (n : \u2124) : \u2102 :=\n  fourierCoeffOn zero_lt_one (fun x => bernoulliFun k x) n", "start": [102, 1], "end": [104, 59], "kind": "commanddeclaration"}, {"full_name": "bernoulliFourierCoeff_recurrence", "code": "theorem bernoulliFourierCoeff_recurrence (k : \u2115) {n : \u2124} (hn : n \u2260 0) :\n    bernoulliFourierCoeff k n =\n      1 / (-2 * \u03c0 * I * n) * (ite (k = 1) 1 0 - k * bernoulliFourierCoeff (k - 1) n)", "start": [107, 1], "end": [122, 68], "kind": "commanddeclaration"}, {"full_name": "bernoulli_zero_fourier_coeff", "code": "theorem bernoulli_zero_fourier_coeff {n : \u2124} (hn : n \u2260 0) : bernoulliFourierCoeff 0 n = 0", "start": [125, 1], "end": [127, 52], "kind": "commanddeclaration"}, {"full_name": "bernoulliFourierCoeff_zero", "code": "theorem bernoulliFourierCoeff_zero {k : \u2115} (hk : k \u2260 0) : bernoulliFourierCoeff k 0 = 0", "start": [130, 1], "end": [134, 17], "kind": "commanddeclaration"}, {"full_name": "bernoulliFourierCoeff_eq", "code": "theorem bernoulliFourierCoeff_eq {k : \u2115} (hk : k \u2260 0) (n : \u2124) :\n    bernoulliFourierCoeff k n = -k ! / (2 * \u03c0 * I * n) ^ k", "start": [137, 1], "end": [153, 14], "kind": "commanddeclaration"}, {"full_name": "periodizedBernoulli", "code": "def periodizedBernoulli (k : \u2115) : \ud835\udd4c \u2192 \u211d :=\n  AddCircle.liftIco 1 0 (bernoulliFun k)", "start": [165, 1], "end": [167, 41], "kind": "commanddeclaration"}, {"full_name": "periodizedBernoulli.continuous", "code": "theorem periodizedBernoulli.continuous {k : \u2115} (hk : k \u2260 1) : Continuous (periodizedBernoulli k)", "start": [170, 1], "end": [173, 43], "kind": "commanddeclaration"}, {"full_name": "fourierCoeff_bernoulli_eq", "code": "theorem fourierCoeff_bernoulli_eq {k : \u2115} (hk : k \u2260 0) (n : \u2124) :\n    fourierCoeff ((\u2191) \u2218 periodizedBernoulli k : \ud835\udd4c \u2192 \u2102) n = -k ! / (2 * \u03c0 * I * n) ^ k", "start": [176, 1], "end": [181, 60], "kind": "commanddeclaration"}, {"full_name": "summable_bernoulli_fourier", "code": "theorem summable_bernoulli_fourier {k : \u2115} (hk : 2 \u2264 k) :\n    Summable (fun n => -k ! / (2 * \u03c0 * I * n) ^ k : \u2124 \u2192 \u2102)", "start": [184, 1], "end": [199, 67], "kind": "commanddeclaration"}, {"full_name": "hasSum_one_div_pow_mul_fourier_mul_bernoulliFun", "code": "theorem hasSum_one_div_pow_mul_fourier_mul_bernoulliFun {k : \u2115} (hk : 2 \u2264 k) {x : \u211d}\n    (hx : x \u2208 Icc (0 : \u211d) 1) :\n    HasSum (fun n : \u2124 => 1 / (n : \u2102) ^ k * fourier n (x : \ud835\udd4c))\n      (-(2 * \u03c0 * I) ^ k / k ! * bernoulliFun k x)", "start": [202, 1], "end": [233, 55], "kind": "commanddeclaration"}, {"full_name": "hasSum_one_div_nat_pow_mul_fourier", "code": "theorem hasSum_one_div_nat_pow_mul_fourier {k : \u2115} (hk : 2 \u2264 k) {x : \u211d} (hx : x \u2208 Icc (0 : \u211d) 1) :\n    HasSum\n      (fun n : \u2115 =>\n        (1 : \u2102) / (n : \u2102) ^ k * (fourier n (x : \ud835\udd4c) + (-1 : \u2102) ^ k * fourier (-n) (x : \ud835\udd4c)))\n      (-(2 * \u03c0 * I) ^ k / k ! * bernoulliFun k x)", "start": [241, 1], "end": [255, 85], "kind": "commanddeclaration"}, {"full_name": "hasSum_one_div_nat_pow_mul_cos", "code": "theorem hasSum_one_div_nat_pow_mul_cos {k : \u2115} (hk : k \u2260 0) {x : \u211d} (hx : x \u2208 Icc (0 : \u211d) 1) :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ (2 * k) * Real.cos (2 * \u03c0 * n * x))\n      ((-1 : \u211d) ^ (k + 1) * (2 * \u03c0) ^ (2 * k) / 2 / (2 * k)! *\n        (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k))).eval x)", "start": [258, 1], "end": [292, 9], "kind": "commanddeclaration"}, {"full_name": "hasSum_one_div_nat_pow_mul_sin", "code": "theorem hasSum_one_div_nat_pow_mul_sin {k : \u2115} (hk : k \u2260 0) {x : \u211d} (hx : x \u2208 Icc (0 : \u211d) 1) :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ (2 * k + 1) * Real.sin (2 * \u03c0 * n * x))\n      ((-1 : \u211d) ^ (k + 1) * (2 * \u03c0) ^ (2 * k + 1) / 2 / (2 * k + 1)! *\n        (Polynomial.map (algebraMap \u211a \u211d) (Polynomial.bernoulli (2 * k + 1))).eval x)", "start": [295, 1], "end": [336, 9], "kind": "commanddeclaration"}, {"full_name": "hasSum_zeta_nat", "code": "theorem hasSum_zeta_nat {k : \u2115} (hk : k \u2260 0) :\n    HasSum (fun n : \u2115 => 1 / (n : \u211d) ^ (2 * k))\n      ((-1 : \u211d) ^ (k + 1) * (2 : \u211d) ^ (2 * k - 1) * \u03c0 ^ (2 * k) *\n        bernoulli (2 * k) / (2 * k)!)", "start": [339, 1], "end": [355, 7], "kind": "commanddeclaration"}, {"full_name": "hasSum_zeta_two", "code": "theorem hasSum_zeta_two : HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 2) (\u03c0 ^ 2 / 6)", "start": [362, 1], "end": [365, 45], "kind": "commanddeclaration"}, {"full_name": "hasSum_zeta_four", "code": "theorem hasSum_zeta_four : HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 4) (\u03c0 ^ 4 / 90)", "start": [368, 1], "end": [371, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.bernoulli_three_eval_one_quarter", "code": "theorem Polynomial.bernoulli_three_eval_one_quarter :\n    (Polynomial.bernoulli 3).eval (1 / 4) = 3 / 64", "start": [374, 1], "end": [382, 11], "kind": "commanddeclaration"}, {"full_name": "hasSum_L_function_mod_four_eval_three", "code": "theorem hasSum_L_function_mod_four_eval_three :\n    HasSum (fun n : \u2115 => (1 : \u211d) / (n : \u211d) ^ 3 * Real.sin (\u03c0 * n / 2)) (\u03c0 ^ 3 / 32)", "start": [385, 1], "end": [402, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/ModularForms/JacobiTheta/Basic.lean", "imports": ["Mathlib/Analysis/Complex/LocallyUniformLimit.lean", "Mathlib/Analysis/SpecialFunctions/Gaussian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/FunctionsBoundedAtInfty.lean", "Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean"], "premises": [{"full_name": "jacobiTheta", "code": "noncomputable def jacobiTheta (z : \u2102) : \u2102 :=\n  \u2211' n : \u2124, cexp (\u03c0 * I * (n : \u2102) ^ 2 * z)", "start": [31, 1], "end": [33, 43], "kind": "commanddeclaration"}, {"full_name": "norm_exp_mul_sq_le", "code": "theorem norm_exp_mul_sq_le {z : \u2102} (hz : 0 < z.im) (n : \u2124) :\n    \u2016cexp (\u03c0 * I * (n : \u2102) ^ 2 * z)\u2016 \u2264 rexp (-\u03c0 * z.im) ^ n.natAbs", "start": [36, 1], "end": [50, 95], "kind": "commanddeclaration"}, {"full_name": "exists_summable_bound_exp_mul_sq", "code": "theorem exists_summable_bound_exp_mul_sq {R : \u211d} (hR : 0 < R) :\n    \u2203 bd : \u2124 \u2192 \u211d, Summable bd \u2227 \u2200 {\u03c4 : \u2102} (_ : R \u2264 \u03c4.im) (n : \u2124),\n      \u2016cexp (\u03c0 * I * (n : \u2102) ^ 2 * \u03c4)\u2016 \u2264 bd n", "start": [53, 1], "end": [64, 55], "kind": "commanddeclaration"}, {"full_name": "summable_exp_mul_sq", "code": "theorem summable_exp_mul_sq {z : \u2102} (hz : 0 < z.im) :\n    Summable fun n : \u2124 => cexp (\u03c0 * I * (n : \u2102) ^ 2 * z)", "start": [67, 1], "end": [70, 95], "kind": "commanddeclaration"}, {"full_name": "jacobiTheta_two_add", "code": "theorem jacobiTheta_two_add (z : \u2102) : jacobiTheta (2 + z) = jacobiTheta z", "start": [73, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "jacobiTheta_T_sq_smul", "code": "theorem jacobiTheta_T_sq_smul (\u03c4 : \u210d) : jacobiTheta \u2191(ModularGroup.T ^ 2 \u2022 \u03c4) = jacobiTheta \u03c4", "start": [80, 1], "end": [84, 12], "kind": "commanddeclaration"}, {"full_name": "jacobiTheta_S_smul", "code": "theorem jacobiTheta_S_smul (\u03c4 : \u210d) :\n    jacobiTheta \u2191(ModularGroup.S \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4", "start": [88, 1], "end": [112, 13], "kind": "commanddeclaration"}, {"full_name": "hasSum_nat_jacobiTheta", "code": "theorem hasSum_nat_jacobiTheta {z : \u2102} (hz : 0 < im z) :\n    HasSum (fun n : \u2115 => cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * z)) ((jacobiTheta z - 1) / 2)", "start": [116, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "jacobiTheta_eq_tsum_nat", "code": "theorem jacobiTheta_eq_tsum_nat {z : \u2102} (hz : 0 < im z) :\n    jacobiTheta z = \u21911 + \u21912 * \u2211' n : \u2115, cexp (\u03c0 * I * ((n : \u2102) + 1) ^ 2 * z)", "start": [128, 1], "end": [131, 21], "kind": "commanddeclaration"}, {"full_name": "norm_jacobiTheta_sub_one_le", "code": "theorem norm_jacobiTheta_sub_one_le {z : \u2102} (hz : 0 < im z) :\n    \u2016jacobiTheta z - 1\u2016 \u2264 2 / (1 - rexp (-\u03c0 * z.im)) * rexp (-\u03c0 * z.im)", "start": [134, 1], "end": [157, 100], "kind": "commanddeclaration"}, {"full_name": "isBigO_at_im_infty_jacobiTheta_sub_one", "code": "theorem isBigO_at_im_infty_jacobiTheta_sub_one :\n    (fun \u03c4 => jacobiTheta \u03c4 - 1) =O[comap im atTop] fun \u03c4 => rexp (-\u03c0 * \u03c4.im)", "start": [160, 1], "end": [172, 60], "kind": "commanddeclaration"}, {"full_name": "differentiableAt_jacobiTheta", "code": "theorem differentiableAt_jacobiTheta {z : \u2102} (hz : 0 < im z) :\n    DifferentiableAt \u2102 jacobiTheta z", "start": [176, 1], "end": [189, 94], "kind": "commanddeclaration"}, {"full_name": "continuousAt_jacobiTheta", "code": "theorem continuousAt_jacobiTheta {z : \u2102} (hz : 0 < im z) : ContinuousAt jacobiTheta z", "start": [192, 1], "end": [193, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/ConcreteCategory/UnbundledHom.lean", "imports": ["Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.UnbundledHom", "code": "class UnbundledHom {c : Type u \u2192 Type u} (hom : \u2200 \u2983\u03b1 \u03b2\u2984, c \u03b1 \u2192 c \u03b2 \u2192 (\u03b1 \u2192 \u03b2) \u2192 Prop) : Prop where\n  hom_id : \u2200 {\u03b1} (ia : c \u03b1), hom ia ia id\n  hom_comp : \u2200 {\u03b1 \u03b2 \u03b3} {I\u03b1 : c \u03b1} {I\u03b2 : c \u03b2} {I\u03b3 : c \u03b3} {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (_ : hom I\u03b2 I\u03b3 g)\n      (_ : hom I\u03b1 I\u03b2 f), hom I\u03b1 I\u03b3 (g \u2218 f)", "start": [24, 1], "end": [30, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.UnbundledHom.bundledHom", "code": "instance bundledHom : BundledHom fun \u03b1 \u03b2 (I\u03b1 : c \u03b1) (I\u03b2 : c \u03b2) => Subtype (hom I\u03b1 I\u03b2) where\n  toFun _ _ := Subtype.val\n  id I\u03b1 := \u27e8id, hom_id I\u03b1\u27e9\n  id_toFun _ := rfl\n  comp _ _ _ g f := \u27e8g.1 \u2218 f.1, hom_comp g.2 f.2\u27e9\n  comp_toFun _ _ _ _ _ := rfl\n  hom_ext _ _ _ _ := Subtype.eq", "start": [39, 1], "end": [45, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.UnbundledHom.mkHasForget\u2082", "code": "def mkHasForget\u2082 : HasForget\u2082 (Bundled c) (Bundled c') :=\n  BundledHom.mkHasForget\u2082 obj (fun f => \u27e8f.val, map f.property\u27e9) fun _ => rfl", "start": [56, 1], "end": [59, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Qify.lean", "imports": ["Mathlib/Tactic/Zify.lean", "Mathlib/Data/Rat/Cast/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/NormCast.lean"], "premises": [{"full_name": "Mathlib.Tactic.Qify.int_cast_eq", "code": "@[qify_simps] lemma int_cast_eq (a b : \u2124) : a = b \u2194 (a : \u211a) = (b : \u211a) := by simp only [Int.cast_inj]", "start": [66, 1], "end": [66, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Qify.int_cast_le", "code": "@[qify_simps] lemma int_cast_le (a b : \u2124) : a \u2264 b \u2194 (a : \u211a) \u2264 (b : \u211a) := Int.cast_le.symm", "start": [67, 1], "end": [67, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Qify.int_cast_lt", "code": "@[qify_simps] lemma int_cast_lt (a b : \u2124) : a < b \u2194 (a : \u211a) < (b : \u211a) := Int.cast_lt.symm", "start": [68, 1], "end": [68, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Qify.int_cast_ne", "code": "@[qify_simps] lemma int_cast_ne (a b : \u2124) : a \u2260 b \u2194 (a : \u211a) \u2260 (b : \u211a) := by\n  simp only [ne_eq, Int.cast_inj]", "start": [69, 1], "end": [70, 34], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/LinearAlgebra/CliffordAlgebra/Star.lean", "imports": ["Mathlib/LinearAlgebra/CliffordAlgebra/Conjugation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CliffordAlgebra.instStarRing", "code": "instance instStarRing : StarRing (CliffordAlgebra Q) where\n  star x := reverse (involute x)\n  star_involutive x := by\n    simp only [reverse_involute_commute.eq, reverse_reverse, involute_involute]\n  star_mul x y := by simp only [map_mul, reverse.map_mul]\n  star_add x y := by simp only [map_add]", "start": [36, 1], "end": [41, 41], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.star_def", "code": "theorem star_def (x : CliffordAlgebra Q) : star x = reverse (involute x)", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.star_def'", "code": "theorem star_def' (x : CliffordAlgebra Q) : star x = involute (reverse x)", "start": [47, 1], "end": [48, 21], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.star_\u03b9", "code": "@[simp]\ntheorem star_\u03b9 (m : M) : star (\u03b9 Q m) = -\u03b9 Q m", "start": [51, 1], "end": [52, 99], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.star_smul", "code": "@[simp]\ntheorem star_smul (r : R) (x : CliffordAlgebra Q) : star (r \u2022 x) = r \u2022 star x", "start": [55, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "CliffordAlgebra.star_algebraMap", "code": "@[simp]\ntheorem star_algebraMap (r : R) :\n    star (algebraMap R (CliffordAlgebra Q) r) = algebraMap R (CliffordAlgebra Q) r", "start": [63, 1], "end": [66, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/DualNumber.lean", "imports": ["Mathlib/Algebra/TrivSqZeroExt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DualNumber", "code": "abbrev DualNumber (R : Type*) : Type _ :=\n  TrivSqZeroExt R R", "start": [42, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "DualNumber.eps", "code": "def DualNumber.eps [Zero R] [One R] : DualNumber R :=\n  TrivSqZeroExt.inr 1", "start": [47, 1], "end": [49, 22], "kind": "commanddeclaration"}, {"full_name": "DualNumber.fst_eps", "code": "@[simp]\ntheorem fst_eps [Zero R] [One R] : fst \u03b5 = (0 : R)", "start": [64, 1], "end": [66, 14], "kind": "commanddeclaration"}, {"full_name": "DualNumber.snd_eps", "code": "@[simp]\ntheorem snd_eps [Zero R] [One R] : snd \u03b5 = (1 : R)", "start": [69, 1], "end": [71, 14], "kind": "commanddeclaration"}, {"full_name": "DualNumber.snd_mul", "code": "@[simp]\ntheorem snd_mul [Semiring R] (x y : R[\u03b5]) : snd (x * y) = fst x * snd y + snd x * fst y", "start": [74, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "DualNumber.eps_mul_eps", "code": "@[simp]\ntheorem eps_mul_eps [Semiring R] : (\u03b5 * \u03b5 : R[\u03b5]) = 0", "start": [80, 1], "end": [82, 20], "kind": "commanddeclaration"}, {"full_name": "DualNumber.inr_eq_smul_eps", "code": "@[simp]\ntheorem inr_eq_smul_eps [MulZeroOneClass R] (r : R) : inr r = (r \u2022 \u03b5 : R[\u03b5])", "start": [85, 1], "end": [87, 41], "kind": "commanddeclaration"}, {"full_name": "DualNumber.algHom_ext", "code": "@[ext]\ntheorem algHom_ext {A} [CommSemiring R] [Semiring A] [Algebra R A] \u2983f g : R[\u03b5] \u2192\u2090[R] A\u2984\n    (h : f \u03b5 = g \u03b5) : f = g", "start": [90, 1], "end": [94, 41], "kind": "commanddeclaration"}, {"full_name": "DualNumber.lift", "code": "@[simps!]\ndef lift : { e : A // e * e = 0 } \u2243 (R[\u03b5] \u2192\u2090[R] A) :=\n  Equiv.trans\n    (show { e : A // e * e = 0 } \u2243 { f : R \u2192\u2097[R] A // \u2200 x y, f x * f y = 0 } from\n      (LinearMap.ringLmapEquivSelf R \u2115 A).symm.toEquiv.subtypeEquiv fun a => by\n        dsimp\n        simp_rw [smul_mul_smul]\n        refine' \u27e8fun h x y => h.symm \u25b8 smul_zero _, fun h => by simpa using h 1 1\u27e9)\n    TrivSqZeroExt.lift", "start": [99, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "DualNumber.lift_apply_eps", "code": "theorem lift_apply_eps (e : { e : A // e * e = 0 }) : @lift R _ _ _ _ e (\u03b5 : R[\u03b5]) = e", "start": [116, 1], "end": [117, 79], "kind": "commanddeclaration"}, {"full_name": "DualNumber.lift_eps", "code": "@[simp]\ntheorem lift_eps : lift \u27e8\u03b5, eps_mul_eps\u27e9 = AlgHom.id R R[\u03b5]", "start": [121, 1], "end": [123, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/QuadraticForm/Prod.lean", "imports": ["Mathlib/LinearAlgebra/QuadraticForm/IsometryEquiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuadraticForm.prod", "code": "@[simps!]\ndef prod (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) : QuadraticForm R (M\u2081 \u00d7 M\u2082) :=\n  Q\u2081.comp (LinearMap.fst _ _ _) + Q\u2082.comp (LinearMap.snd _ _ _)", "start": [49, 1], "end": [53, 64], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.IsometryEquiv.prod", "code": "@[simps toLinearEquiv]\ndef IsometryEquiv.prod\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2081' : QuadraticForm R N\u2081} {Q\u2082' : QuadraticForm R N\u2082}\n    (e\u2081 : Q\u2081.IsometryEquiv Q\u2081') (e\u2082 : Q\u2082.IsometryEquiv Q\u2082') :\n    (Q\u2081.prod Q\u2082).IsometryEquiv (Q\u2081'.prod Q\u2082') where\n  map_app' x := congr_arg\u2082 (\u00b7 + \u00b7) (e\u2081.map_app x.1) (e\u2082.map_app x.2)\n  toLinearEquiv := LinearEquiv.prod e\u2081.toLinearEquiv e\u2082.toLinearEquiv", "start": [56, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Isometry.inl", "code": "@[simps!]\ndef Isometry.inl (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) : Q\u2081 \u2192q\u1d62 (Q\u2081.prod Q\u2082) where\n  toLinearMap := LinearMap.inl R _ _\n  map_app' m\u2081 := by simp", "start": [68, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Isometry.inr", "code": "@[simps!]\ndef Isometry.inr (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) : Q\u2082 \u2192q\u1d62 (Q\u2081.prod Q\u2082) where\n  toLinearMap := LinearMap.inr R _ _\n  map_app' m\u2081 := by simp", "start": [74, 1], "end": [78, 25], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Equivalent.prod", "code": "theorem Equivalent.prod {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082}\n    {Q\u2081' : QuadraticForm R N\u2081} {Q\u2082' : QuadraticForm R N\u2082} (e\u2081 : Q\u2081.Equivalent Q\u2081')\n    (e\u2082 : Q\u2082.Equivalent Q\u2082') : (Q\u2081.prod Q\u2082).Equivalent (Q\u2081'.prod Q\u2082')", "start": [80, 1], "end": [83, 41], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.IsometryEquiv.prodComm", "code": "@[simps!]\ndef IsometryEquiv.prodComm (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    (Q\u2081.prod Q\u2082).IsometryEquiv (Q\u2082.prod Q\u2081) where\n  toLinearEquiv := LinearEquiv.prodComm _ _ _\n  map_app' _ := add_comm _ _", "start": [86, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.IsometryEquiv.prodProdProdComm", "code": "@[simps!]\ndef IsometryEquiv.prodProdProdComm\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082)\n    (Q\u2083 : QuadraticForm R N\u2081) (Q\u2084 : QuadraticForm R N\u2082) :\n    ((Q\u2081.prod Q\u2082).prod (Q\u2083.prod Q\u2084)).IsometryEquiv ((Q\u2081.prod Q\u2083).prod (Q\u2082.prod Q\u2084)) where\n  toLinearEquiv := LinearEquiv.prodProdProdComm _ _ _ _ _\n  map_app' _ := add_add_add_comm _ _ _ _", "start": [93, 1], "end": [100, 41], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.anisotropic_of_prod", "code": "theorem anisotropic_of_prod {R} [OrderedCommRing R] [Module R M\u2081] [Module R M\u2082]\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082} (h : (Q\u2081.prod Q\u2082).Anisotropic) :\n    Q\u2081.Anisotropic \u2227 Q\u2082.Anisotropic", "start": [102, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.nonneg_prod_iff", "code": "theorem nonneg_prod_iff {R} [OrderedCommRing R] [Module R M\u2081] [Module R M\u2082]\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082} :\n    (\u2200 x, 0 \u2264 (Q\u2081.prod Q\u2082) x) \u2194 (\u2200 x, 0 \u2264 Q\u2081 x) \u2227 \u2200 x, 0 \u2264 Q\u2082 x", "start": [116, 1], "end": [126, 37], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.posDef_prod_iff", "code": "theorem posDef_prod_iff {R} [OrderedCommRing R] [Module R M\u2081] [Module R M\u2082]\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082} :\n    (Q\u2081.prod Q\u2082).PosDef \u2194 Q\u2081.PosDef \u2227 Q\u2082.PosDef", "start": [129, 1], "end": [141, 26], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.PosDef.prod", "code": "theorem PosDef.prod {R} [OrderedCommRing R] [Module R M\u2081] [Module R M\u2082]\n    {Q\u2081 : QuadraticForm R M\u2081} {Q\u2082 : QuadraticForm R M\u2082} (h\u2081 : Q\u2081.PosDef) (h\u2082 : Q\u2082.PosDef) :\n    (Q\u2081.prod Q\u2082).PosDef", "start": [144, 1], "end": [147, 31], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.polar_prod", "code": "@[simp] theorem polar_prod (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) (x y : M\u2081 \u00d7 M\u2082) :\n    polar (Q\u2081.prod Q\u2082) x y = polar Q\u2081 x.1 y.1 + polar Q\u2082 x.2 y.2", "start": [158, 1], "end": [161, 7], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.polarBilin_prod", "code": "@[simp] theorem polarBilin_prod (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    (Q\u2081.prod Q\u2082).polarBilin =\n      Q\u2081.polarBilin.comp (.fst _ _ _) (.fst _ _ _) +\n      Q\u2082.polarBilin.comp (.snd _ _ _) (.snd _ _ _)", "start": [163, 1], "end": [167, 34], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.associated_prod", "code": "@[simp] theorem associated_prod [Invertible (2 : R)]\n    (Q\u2081 : QuadraticForm R M\u2081) (Q\u2082 : QuadraticForm R M\u2082) :\n    associated (Q\u2081.prod Q\u2082) =\n      Q\u2081.associated.comp (.fst _ _ _) (.fst _ _ _) +\n      Q\u2082.associated.comp (.snd _ _ _) (.snd _ _ _)", "start": [169, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.pi", "code": "def pi [Fintype \u03b9] (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) : QuadraticForm R (\u2200 i, M\u1d62 i) :=\n  \u2211 i, (Q i).comp (LinearMap.proj i : _ \u2192\u2097[R] M\u1d62 i)", "start": [191, 1], "end": [193, 52], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.pi_apply", "code": "@[simp]\ntheorem pi_apply [Fintype \u03b9] (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) (x : \u2200 i, M\u1d62 i) :\n    pi Q x = \u2211 i, Q i (x i)", "start": [196, 1], "end": [199, 18], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.pi_apply_single", "code": "theorem pi_apply_single [Fintype \u03b9] [DecidableEq \u03b9]\n    (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) (i : \u03b9) (m : M\u1d62 i) :\n    pi Q (Pi.single i m) = Q i m", "start": [202, 1], "end": [206, 39], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.IsometryEquiv.pi", "code": "@[simps toLinearEquiv]\ndef IsometryEquiv.pi [Fintype \u03b9]\n    {Q : \u2200 i, QuadraticForm R (M\u1d62 i)} {Q' : \u2200 i, QuadraticForm R (N\u1d62 i)}\n    (e : \u2200 i, (Q i).IsometryEquiv (Q' i)) : (pi Q).IsometryEquiv (pi Q') where\n  map_app' x := by\n    simp only [pi_apply, LinearEquiv.piCongrRight, LinearEquiv.toFun_eq_coe,\n      IsometryEquiv.coe_toLinearEquiv, IsometryEquiv.map_app]\n  toLinearEquiv := LinearEquiv.piCongrRight fun i => (e i : M\u1d62 i \u2243\u2097[R] N\u1d62 i)", "start": [208, 1], "end": [217, 77], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Isometry.single", "code": "@[simps!]\ndef Isometry.single [Fintype \u03b9] [DecidableEq \u03b9] (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) (i : \u03b9) :\n    Q i \u2192q\u1d62 pi Q where\n  toLinearMap := LinearMap.single i\n  map_app' := pi_apply_single _ _", "start": [220, 1], "end": [225, 34], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Equivalent.pi", "code": "theorem Equivalent.pi [Fintype \u03b9] {Q : \u2200 i, QuadraticForm R (M\u1d62 i)}\n    {Q' : \u2200 i, QuadraticForm R (N\u1d62 i)} (e : \u2200 i, (Q i).Equivalent (Q' i)) :\n    (pi Q).Equivalent (pi Q')", "start": [227, 1], "end": [230, 53], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.anisotropic_of_pi", "code": "theorem anisotropic_of_pi [Fintype \u03b9] {R} [OrderedCommRing R] [\u2200 i, Module R (M\u1d62 i)]\n    {Q : \u2200 i, QuadraticForm R (M\u1d62 i)} (h : (pi Q).Anisotropic) : \u2200 i, (Q i).Anisotropic", "start": [233, 1], "end": [246, 42], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.nonneg_pi_iff", "code": "theorem nonneg_pi_iff [Fintype \u03b9] {R} [OrderedCommRing R] [\u2200 i, Module R (M\u1d62 i)]\n    {Q : \u2200 i, QuadraticForm R (M\u1d62 i)} : (\u2200 x, 0 \u2264 pi Q x) \u2194 \u2200 i x, 0 \u2264 Q i x", "start": [249, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.posDef_pi_iff", "code": "theorem posDef_pi_iff [Fintype \u03b9] {R} [OrderedCommRing R] [\u2200 i, Module R (M\u1d62 i)]\n    {Q : \u2200 i, QuadraticForm R (M\u1d62 i)} : (pi Q).PosDef \u2194 \u2200 i, (Q i).PosDef", "start": [263, 1], "end": [274, 20], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Ring.polar_pi", "code": "@[simp] theorem polar_pi (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) (x y : \u2200 i, M\u1d62 i) :\n    polar (pi Q) x y = \u2211 i, polar (Q i) (x i) (y i)", "start": [286, 1], "end": [289, 59], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Ring.polarBilin_pi", "code": "@[simp] theorem polarBilin_pi (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) :\n    (pi Q).polarBilin = \u2211 i, (Q i).polarBilin.comp (.proj i) (.proj i)", "start": [291, 1], "end": [293, 64], "kind": "commanddeclaration"}, {"full_name": "QuadraticForm.Ring.associated_pi", "code": "@[simp] theorem associated_pi [Invertible (2 : R)] (Q : \u2200 i, QuadraticForm R (M\u1d62 i)) :\n    associated (pi Q) = \u2211 i, (Q i).associated.comp (.proj i) (.proj i)", "start": [295, 1], "end": [299, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/QuaternionBasis.lean", "imports": ["Mathlib/Tactic/Ring.lean", "Mathlib/Algebra/Quaternion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "QuaternionAlgebra.Basis", "code": "structure Basis {R : Type*} (A : Type*) [CommRing R] [Ring A] [Algebra R A] (c\u2081 c\u2082 : R) where\n  (i j k : A)\n  i_mul_i : i * i = c\u2081 \u2022 (1 : A)\n  j_mul_j : j * j = c\u2082 \u2022 (1 : A)\n  i_mul_j : i * j = k\n  j_mul_i : j * i = -k", "start": [31, 1], "end": [42, 23], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.ext", "code": "@[ext]\nprotected theorem ext \u2983q\u2081 q\u2082 : Basis A c\u2081 c\u2082\u2984 (hi : q\u2081.i = q\u2082.i) (hj : q\u2081.j = q\u2082.j) : q\u2081 = q\u2082", "start": [51, 1], "end": [58, 8], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.self", "code": "@[simps i j k]\nprotected def self : Basis \u210d[R,c\u2081,c\u2082] c\u2081 c\u2082 where\n  i := \u27e80, 1, 0, 0\u27e9\n  i_mul_i := by ext <;> simp\n  j := \u27e80, 0, 1, 0\u27e9\n  j_mul_j := by ext <;> simp\n  k := \u27e80, 0, 0, 1\u27e9\n  i_mul_j := by ext <;> simp\n  j_mul_i := by ext <;> simp", "start": [63, 1], "end": [72, 29], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.i_mul_k", "code": "@[simp]\ntheorem i_mul_k : q.i * q.k = c\u2081 \u2022 q.j", "start": [84, 1], "end": [86, 64], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.k_mul_i", "code": "@[simp]\ntheorem k_mul_i : q.k * q.i = -c\u2081 \u2022 q.j", "start": [89, 1], "end": [91, 65], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.k_mul_j", "code": "@[simp]\ntheorem k_mul_j : q.k * q.j = c\u2082 \u2022 q.i", "start": [94, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.j_mul_k", "code": "@[simp]\ntheorem j_mul_k : q.j * q.k = -c\u2082 \u2022 q.i", "start": [99, 1], "end": [101, 67], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.k_mul_k", "code": "@[simp]\ntheorem k_mul_k : q.k * q.k = -((c\u2081 * c\u2082) \u2022 (1 : A))", "start": [104, 1], "end": [107, 94], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift", "code": "def lift (x : \u210d[R,c\u2081,c\u2082]) : A :=\n  algebraMap R _ x.re + x.imI \u2022 q.i + x.imJ \u2022 q.j + x.imK \u2022 q.k", "start": [110, 1], "end": [112, 64], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift_zero", "code": "theorem lift_zero : q.lift (0 : \u210d[R,c\u2081,c\u2082]) = 0", "start": [115, 1], "end": [115, 66], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift_one", "code": "theorem lift_one : q.lift (1 : \u210d[R,c\u2081,c\u2082]) = 1", "start": [118, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift_add", "code": "theorem lift_add (x y : \u210d[R,c\u2081,c\u2082]) : q.lift (x + y) = q.lift x + q.lift y", "start": [121, 1], "end": [123, 7], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift_mul", "code": "theorem lift_mul (x y : \u210d[R,c\u2081,c\u2082]) : q.lift (x * y) = q.lift x * q.lift y", "start": [126, 1], "end": [136, 7], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.lift_smul", "code": "theorem lift_smul (r : R) (x : \u210d[R,c\u2081,c\u2082]) : q.lift (r \u2022 x) = r \u2022 q.lift x", "start": [139, 1], "end": [140, 44], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.liftHom", "code": "@[simps!]\ndef liftHom : \u210d[R,c\u2081,c\u2082] \u2192\u2090[R] A :=\n  AlgHom.mk'\n    { toFun := q.lift\n      map_zero' := q.lift_zero\n      map_one' := q.lift_one\n      map_add' := q.lift_add\n      map_mul' := q.lift_mul } q.lift_smul", "start": [143, 1], "end": [151, 43], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.Basis.compHom", "code": "@[simps i j k]\ndef compHom (F : A \u2192\u2090[R] B) : Basis B c\u2081 c\u2082 where\n  i := F q.i\n  i_mul_i := by rw [\u2190 F.map_mul, q.i_mul_i, F.map_smul, F.map_one]\n  j := F q.j\n  j_mul_j := by rw [\u2190 F.map_mul, q.j_mul_j, F.map_smul, F.map_one]\n  k := F q.k\n  i_mul_j := by rw [\u2190 F.map_mul, q.i_mul_j]\n  j_mul_i := by rw [\u2190 F.map_mul, q.j_mul_i, F.map_neg]", "start": [154, 1], "end": [163, 55], "kind": "commanddeclaration"}, {"full_name": "QuaternionAlgebra.lift", "code": "@[simps]\ndef lift : Basis A c\u2081 c\u2082 \u2243 (\u210d[R,c\u2081,c\u2082] \u2192\u2090[R] A) where\n  toFun := Basis.liftHom\n  invFun := (Basis.self R).compHom\n  left_inv q := by ext <;> simp [Basis.lift]\n  right_inv F := by\n    ext\n    dsimp [Basis.lift]\n    rw [\u2190 F.commutes]\n    simp only [\u2190 F.commutes, \u2190 F.map_smul, \u2190 F.map_add, mk_add_mk, smul_mk, smul_zero,\n      algebraMap_eq]\n    congr <;> simp", "start": [168, 1], "end": [180, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Acyclic.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "Mathlib/Tactic/Linarith.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.IsAcyclic", "code": "def IsAcyclic : Prop := \u2200 \u2983v : V\u2984 (c : G.Walk v v), \u00acc.IsCycle", "start": [51, 1], "end": [52, 63], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsTree", "code": "@[mk_iff]\nstructure IsTree : Prop where\n  \n  protected isConnected : G.Connected\n  \n  protected IsAcyclic : G.IsAcyclic", "start": [55, 1], "end": [61, 36], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isAcyclic_bot", "code": "@[simp] lemma isAcyclic_bot : IsAcyclic (\u22a5 : SimpleGraph V) := \u03bb _a _w hw \u21a6 hw.ne_bot rfl", "start": [66, 1], "end": [66, 90], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.isAcyclic_iff_forall_adj_isBridge", "code": "theorem isAcyclic_iff_forall_adj_isBridge :\n    G.IsAcyclic \u2194 \u2200 \u2983v w : V\u2984, G.Adj v w \u2192 G.IsBridge \u27e6(v, w)\u27e7", "start": [68, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isAcyclic_iff_forall_edge_isBridge", "code": "theorem isAcyclic_iff_forall_edge_isBridge :\n    G.IsAcyclic \u2194 \u2200 \u2983e\u2984, e \u2208 (G.edgeSet) \u2192 G.IsBridge e", "start": [83, 1], "end": [85, 56], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsAcyclic.path_unique", "code": "theorem IsAcyclic.path_unique {G : SimpleGraph V} (h : G.IsAcyclic) {v w : V} (p q : G.Path v w) :\n    p = q", "start": [88, 1], "end": [115, 64], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isAcyclic_of_path_unique", "code": "theorem isAcyclic_of_path_unique (h : \u2200 (v w : V) (p q : G.Path v w), p = q) : G.IsAcyclic", "start": [118, 1], "end": [127, 19], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isAcyclic_iff_path_unique", "code": "theorem isAcyclic_iff_path_unique : G.IsAcyclic \u2194 \u2200 \u2983v w : V\u2984 (p q : G.Path v w), p = q", "start": [130, 1], "end": [131, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.isTree_iff_existsUnique_path", "code": "theorem isTree_iff_existsUnique_path :\n    G.IsTree \u2194 Nonempty V \u2227 \u2200 v w : V, \u2203! p : G.Walk v w, p.IsPath", "start": [134, 1], "end": [154, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.IsTree.existsUnique_path", "code": "lemma IsTree.existsUnique_path (hG : G.IsTree) : \u2200 v w, \u2203! p : G.Walk v w, p.IsPath :=\n  (isTree_iff_existsUnique_path.1 hG).2", "start": [157, 1], "end": [158, 40], "kind": "mathlibtacticlemma"}, {"full_name": "SimpleGraph.IsTree.card_edgeFinset", "code": "lemma IsTree.card_edgeFinset [Fintype V] [Fintype G.edgeSet] (hG : G.IsTree) :\n    Finset.card G.edgeFinset + 1 = Fintype.card V := by\n  have := hG.isConnected.nonempty\n  inhabit V\n  classical\n  have : Finset.card ({default} : Finset V)\u1d9c + 1 = Fintype.card V := by\n    rw [Finset.card_compl, Finset.card_singleton, Nat.sub_add_cancel Fintype.card_pos]\n  rw [\u2190 this, add_left_inj]\n  choose f hf hf' using (hG.existsUnique_path \u00b7 default)\n  refine Eq.symm <| Finset.card_congr\n          (fun w hw => ((f w).firstDart <| ?notNil).edge)\n          (fun a ha => ?memEdges) ?inj ?surj\n  case notNil => exact not_nil_of_ne (by simpa using hw)\n  case memEdges => simp\n  case inj =>\n    intros a b ha hb h\n    wlog h' : (f a).length \u2264 (f b).length generalizing a b\n    \u00b7 exact Eq.symm (this _ _ hb ha h.symm (le_of_not_le h'))\n    rw [dart_edge_eq_iff] at h\n    obtain (h | h) := h\n    \u00b7 exact (congrArg (\u00b7.fst) h)\n    \u00b7 have h1 : ((f a).firstDart <| not_nil_of_ne (by simpa using ha)).snd = b :=\n        congrArg (\u00b7.snd) h\n      have h3 := congrArg length (hf' _ (((f _).tail _).copy h1 rfl) ?_)\n      rw [length_copy, \u2190 add_left_inj 1, length_tail_add_one] at h3\n      \u00b7 exfalso\n        linarith\n      \u00b7 simp only [ne_eq, eq_mp_eq_cast, id_eq, isPath_copy]\n        exact (hf _).tail _\n  case surj =>\n    simp only [mem_edgeFinset, Finset.mem_compl, Finset.mem_singleton, Sym2.forall, mem_edgeSet]\n    intros x y h\n    wlog h' : (f x).length \u2264 (f y).length generalizing x y\n    \u00b7 rw [Sym2.eq_swap]\n      exact this y x h.symm (le_of_not_le h')\n    refine \u27e8y, ?_, dart_edge_eq_mk'_iff.2 <| Or.inr ?_\u27e9\n    \u00b7 rintro rfl\n      rw [\u2190 hf' _ nil IsPath.nil, length_nil,\n          \u2190 hf' _ (.cons h .nil) (IsPath.nil.cons <| by simpa using h.ne),\n          length_cons, length_nil] at h'\n      simp [le_zero_iff, Nat.one_ne_zero] at h'\n    rw [\u2190 hf' _ (.cons h.symm (f x)) ((cons_isPath_iff _ _).2 \u27e8hf _, fun hy => ?contra\u27e9)]\n    rfl\n    case contra =>\n      suffices : (f x).takeUntil y hy = .cons h .nil\n      \u00b7 rw [\u2190 take_spec _ hy] at h'\n        simp [this, hf' _ _ ((hf _).dropUntil hy)] at h'\n      refine (hG.existsUnique_path _ _).unique ((hf _).takeUntil _) ?_\n      simp [h.ne]", "start": [160, 1], "end": [208, 18], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/CategoryTheory/Sites/Surjective.lean", "imports": ["Mathlib/CategoryTheory/Sites/Subsheaf.lean", "Mathlib/CategoryTheory/Sites/CompatibleSheafification.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.imageSieve", "code": "@[simps (config := .lemmasOnly)]\ndef imageSieve {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) {U : C} (s : G.obj (op U)) : Sieve U where\n  arrows V i := \u2203 t : F.obj (op V), f.app _ t = G.map i.op s\n  downward_closed := by\n    rintro V W i \u27e8t, ht\u27e9 j\n    refine' \u27e8F.map j.op t, _\u27e9\n    rw [op_comp, G.map_comp, comp_apply, \u2190 ht, elementwise_of% f.naturality]", "start": [39, 1], "end": [47, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.imageSieve_eq_sieveOfSection", "code": "theorem imageSieve_eq_sieveOfSection {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) {U : C} (s : G.obj (op U)) :\n    imageSieve f s = (imagePresheaf (whiskerRight f (forget A))).sieveOfSection s", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.imageSieve_whisker_forget", "code": "theorem imageSieve_whisker_forget {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) {U : C} (s : G.obj (op U)) :\n    imageSieve (whiskerRight f (forget A)) s = imageSieve f s", "start": [55, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.imageSieve_app", "code": "theorem imageSieve_app {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) {U : C} (s : F.obj (op U)) :\n    imageSieve f (f.app _ s) = \u22a4", "start": [60, 1], "end": [65, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsLocallySurjective", "code": "def IsLocallySurjective {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) : Prop :=\n  \u2200 (U : C) (s : G.obj (op U)), imageSieve f s \u2208 J U", "start": [68, 1], "end": [71, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top", "code": "theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) :\n    IsLocallySurjective J f \u2194 (imagePresheaf (whiskerRight f (forget A))).sheafify J = \u22a4", "start": [74, 1], "end": [78, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_iff_imagePresheaf_sheafify_eq_top'", "code": "theorem isLocallySurjective_iff_imagePresheaf_sheafify_eq_top' {F G : C\u1d52\u1d56 \u2964 Type w} (f : F \u27f6 G) :\n    IsLocallySurjective J f \u2194 (imagePresheaf f).sheafify J = \u22a4", "start": [81, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_iff_isIso", "code": "theorem isLocallySurjective_iff_isIso {F G : Sheaf J (Type w)} (f : F \u27f6 G) :\n    IsLocallySurjective J f.1 \u2194 IsIso (imageSheaf\u03b9 f)", "start": [88, 1], "end": [94, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_iff_whisker_forget", "code": "theorem isLocallySurjective_iff_whisker_forget {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) :\n    IsLocallySurjective J f \u2194 IsLocallySurjective J (whiskerRight f (forget A))", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_of_surjective", "code": "theorem isLocallySurjective_of_surjective {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G)\n    (H : \u2200 U, Function.Surjective (f.app U)) : IsLocallySurjective J f", "start": [103, 1], "end": [108, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isLocallySurjective_of_iso", "code": "theorem isLocallySurjective_of_iso {F G : C\u1d52\u1d56 \u2964 A} (f : F \u27f6 G) [IsIso f] :\n    IsLocallySurjective J f", "start": [111, 1], "end": [117, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsLocallySurjective.comp", "code": "theorem IsLocallySurjective.comp {F\u2081 F\u2082 F\u2083 : C\u1d52\u1d56 \u2964 A} {f\u2081 : F\u2081 \u27f6 F\u2082} {f\u2082 : F\u2082 \u27f6 F\u2083}\n    (h\u2081 : IsLocallySurjective J f\u2081) (h\u2082 : IsLocallySurjective J f\u2082) :\n    IsLocallySurjective J (f\u2081 \u226b f\u2082)", "start": [120, 1], "end": [133, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sheafificationIsoImagePresheaf", "code": "noncomputable def sheafificationIsoImagePresheaf :\n    J.sheafify F \u2245 ((imagePresheaf (J.toSheafify F)).sheafify J).toPresheaf where\n  hom :=\n    J.sheafifyLift (toImagePresheafSheafify J _)\n      ((isSheaf_iff_isSheaf_of_type J _).mpr <|\n        Subpresheaf.sheafify_isSheaf _ <|\n          (isSheaf_iff_isSheaf_of_type J _).mp <| sheafify_isSheaf J _)\n  inv := Subpresheaf.\u03b9 _\n  hom_inv_id :=\n    J.sheafify_hom_ext _ _ (J.sheafify_isSheaf _) (by simp [toImagePresheafSheafify])\n  inv_hom_id := by\n    rw [\u2190 cancel_mono (Subpresheaf.\u03b9 _), Category.id_comp, Category.assoc]\n    refine' Eq.trans _ (Category.comp_id _)\n    congr 1\n    exact J.sheafify_hom_ext _ _ (J.sheafify_isSheaf _) (by simp [toImagePresheafSheafify])", "start": [140, 1], "end": [155, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.toSheafify_isLocallySurjective", "code": "theorem toSheafify_isLocallySurjective (F : C\u1d52\u1d56 \u2964 B) : IsLocallySurjective J (J.toSheafify F)", "start": [168, 1], "end": [173, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Cone/Dual.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Projection.lean", "Mathlib/Analysis/Convex/Cone/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.innerDualCone", "code": "def Set.innerDualCone (s : Set H) : ConvexCone \u211d H where\n  carrier := { y | \u2200 x \u2208 s, 0 \u2264 \u27eax, y\u27eb }\n  smul_mem' c hc y hy x hx := by\n    rw [real_inner_smul_right]\n    exact mul_nonneg hc.le (hy x hx)\n  add_mem' u hu v hv x hx := by\n    rw [inner_add_right]\n    exact add_nonneg (hu x hx) (hv x hx)", "start": [41, 1], "end": [50, 41], "kind": "commanddeclaration"}, {"full_name": "mem_innerDualCone", "code": "@[simp]\ntheorem mem_innerDualCone (y : H) (s : Set H) : y \u2208 s.innerDualCone \u2194 \u2200 x \u2208 s, 0 \u2264 \u27eax, y\u27eb", "start": [53, 1], "end": [55, 10], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_empty", "code": "@[simp]\ntheorem innerDualCone_empty : (\u2205 : Set H).innerDualCone = \u22a4", "start": [58, 1], "end": [60, 41], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_zero", "code": "@[simp]\ntheorem innerDualCone_zero : (0 : Set H).innerDualCone = \u22a4", "start": [63, 1], "end": [66, 76], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_univ", "code": "@[simp]\ntheorem innerDualCone_univ : (univ : Set H).innerDualCone = 0", "start": [69, 1], "end": [75, 83], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_le_innerDualCone", "code": "theorem innerDualCone_le_innerDualCone (h : t \u2286 s) : s.innerDualCone \u2264 t.innerDualCone", "start": [78, 1], "end": [79, 31], "kind": "commanddeclaration"}, {"full_name": "pointed_innerDualCone", "code": "theorem pointed_innerDualCone : s.innerDualCone.Pointed", "start": [82, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_singleton", "code": "theorem innerDualCone_singleton (x : H) :\n    ({x} : Set H).innerDualCone = (ConvexCone.positive \u211d \u211d).comap (inner\u209b\u2097 \u211d x)", "start": [85, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_union", "code": "theorem innerDualCone_union (s t : Set H) :\n    (s \u222a t).innerDualCone = s.innerDualCone \u2293 t.innerDualCone", "start": [92, 1], "end": [95, 43], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_insert", "code": "theorem innerDualCone_insert (x : H) (s : Set H) :\n    (insert x s).innerDualCone = Set.innerDualCone {x} \u2293 s.innerDualCone", "start": [98, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_iUnion", "code": "theorem innerDualCone_iUnion {\u03b9 : Sort*} (f : \u03b9 \u2192 Set H) :\n    (\u22c3 i, f i).innerDualCone = \u2a05 i, (f i).innerDualCone", "start": [103, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_sUnion", "code": "theorem innerDualCone_sUnion (S : Set (Set H)) :\n    (\u22c3\u2080 S).innerDualCone = sInf (Set.innerDualCone '' S)", "start": [112, 1], "end": [114, 64], "kind": "commanddeclaration"}, {"full_name": "innerDualCone_eq_iInter_innerDualCone_singleton", "code": "theorem innerDualCone_eq_iInter_innerDualCone_singleton :\n    (s.innerDualCone : Set H) = \u22c2 i : s, (({\u2191i} : Set H).innerDualCone : Set H)", "start": [117, 1], "end": [120, 78], "kind": "commanddeclaration"}, {"full_name": "isClosed_innerDualCone", "code": "theorem isClosed_innerDualCone : IsClosed (s.innerDualCone : Set H)", "start": [123, 1], "end": [133, 70], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.pointed_of_nonempty_of_isClosed", "code": "theorem ConvexCone.pointed_of_nonempty_of_isClosed (K : ConvexCone \u211d H) (ne : (K : Set H).Nonempty)\n    (hc : IsClosed (K : Set H)) : K.Pointed", "start": [137, 1], "end": [154, 93], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem", "code": "theorem ConvexCone.hyperplane_separation_of_nonempty_of_isClosed_of_nmem (K : ConvexCone \u211d H)\n    (ne : (K : Set H).Nonempty) (hc : IsClosed (K : Set H)) {b : H} (disj : b \u2209 K) :\n    \u2203 y : H, (\u2200 x : H, x \u2208 K \u2192 0 \u2264 \u27eax, y\u27eb_\u211d) \u2227 \u27eay, b\u27eb_\u211d < 0", "start": [161, 1], "end": [193, 49], "kind": "commanddeclaration"}, {"full_name": "ConvexCone.innerDualCone_of_innerDualCone_eq_self", "code": "theorem ConvexCone.innerDualCone_of_innerDualCone_eq_self (K : ConvexCone \u211d H)\n    (ne : (K : Set H).Nonempty) (hc : IsClosed (K : Set H)) :\n    ((K : Set H).innerDualCone : Set H).innerDualCone = K", "start": [197, 1], "end": [208, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Nonneg/Module.lean", "imports": ["Mathlib/Algebra/Order/Nonneg/Ring.lean", "Mathlib/Algebra/Order/Module.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nonneg.instSMul", "code": "instance instSMul : SMul \ud835\udd5c\u22650 \ud835\udd5c' where\n  smul c x := c.val \u2022 x", "start": [33, 1], "end": [34, 24], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_smul", "code": "@[simp, norm_cast]\nlemma coe_smul (a : \ud835\udd5c\u22650) (x : \ud835\udd5c') : (a : \ud835\udd5c) \u2022 x = a \u2022 x :=\n  rfl", "start": [36, 1], "end": [38, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Nonneg.mk_smul", "code": "@[simp]\nlemma mk_smul (a) (ha) (x : \ud835\udd5c') : (\u27e8a, ha\u27e9 : \ud835\udd5c\u22650) \u2022 x = a \u2022 x :=\n  rfl", "start": [40, 1], "end": [42, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Nonneg.instIsScalarTower", "code": "instance instIsScalarTower : IsScalarTower \ud835\udd5c\u22650 \ud835\udd5c' E :=\n  SMul.comp.isScalarTower \u2191Nonneg.coeRingHom", "start": [50, 1], "end": [51, 45], "kind": "commanddeclaration"}, {"full_name": "Nonneg.instSMulWithZero", "code": "instance instSMulWithZero : SMulWithZero \ud835\udd5c\u22650 \ud835\udd5c' where\n  smul_zero _ := smul_zero _\n  zero_smul _ := zero_smul _ _", "start": [59, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "Nonneg.instOrderedSmul", "code": "instance instOrderedSmul : OrderedSMul \ud835\udd5c\u22650 E :=\n  \u27e8hE.1, hE.2\u27e9", "start": [69, 1], "end": [70, 15], "kind": "commanddeclaration"}, {"full_name": "Nonneg.instModule", "code": "instance instModule : Module \ud835\udd5c\u22650 E :=\n  Module.compHom E (@Nonneg.coeRingHom \ud835\udd5c _)", "start": [78, 1], "end": [80, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/ULift.lean", "imports": ["Mathlib/Algebra/Ring/ULift.lean", "Mathlib/Algebra/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ULift.up_ratCast", "code": "@[simp, norm_cast]\ntheorem up_ratCast [RatCast \u03b1] (q : \u211a) : up (q : \u03b1) = q", "start": [26, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.down_ratCast", "code": "@[simp, norm_cast]\ntheorem down_ratCast [RatCast \u03b1] (q : \u211a) : down (q : ULift \u03b1) = q", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.divisionSemiring", "code": "instance divisionSemiring [DivisionSemiring \u03b1] : DivisionSemiring (ULift \u03b1) := by\n  refine' down_injective.divisionSemiring down .. <;> intros <;> rfl", "start": [36, 1], "end": [37, 69], "kind": "commanddeclaration"}, {"full_name": "ULift.semifield", "code": "instance semifield [Semifield \u03b1] : Semifield (ULift \u03b1) :=\n  { ULift.divisionSemiring, ULift.commGroupWithZero with }", "start": [40, 1], "end": [41, 59], "kind": "commanddeclaration"}, {"full_name": "ULift.divisionRing", "code": "instance divisionRing [DivisionRing \u03b1] : DivisionRing (ULift \u03b1) := by\n  refine' down_injective.divisionRing down .. <;> intros <;> rfl", "start": [44, 1], "end": [45, 65], "kind": "commanddeclaration"}, {"full_name": "ULift.field", "code": "instance field [Field \u03b1] : Field (ULift \u03b1) :=\n  { ULift.semifield, ULift.divisionRing with }", "start": [48, 1], "end": [49, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Localization/Cardinality.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/RingTheory/Artinian.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLocalization.card_le", "code": "theorem card_le : #L \u2264 #R", "start": [37, 1], "end": [48, 55], "kind": "commanddeclaration"}, {"full_name": "IsLocalization.card", "code": "theorem card (hS : S \u2264 R\u2070) : #R = #L", "start": [53, 1], "end": [55, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/Divisibility.lean", "imports": ["Mathlib/Algebra/IsPrimePow.lean", "Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/Tactic/WLOG.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Cardinal.isUnit_iff", "code": "@[simp]\ntheorem isUnit_iff : IsUnit a \u2194 a = 1", "start": [42, 1], "end": [58, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_of_dvd", "code": "theorem le_of_dvd : \u2200 {a b : Cardinal}, b \u2260 0 \u2192 a \u2223 b \u2192 a \u2264 b", "start": [65, 1], "end": [68, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.dvd_of_le_of_aleph0_le", "code": "theorem dvd_of_le_of_aleph0_le (ha : a \u2260 0) (h : a \u2264 b) (hb : \u2135\u2080 \u2264 b) : a \u2223 b", "start": [71, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prime_of_aleph0_le", "code": "@[simp]\ntheorem prime_of_aleph0_le (ha : \u2135\u2080 \u2264 a) : Prime a", "start": [75, 1], "end": [88, 67], "kind": "commanddeclaration"}, {"full_name": "Cardinal.not_irreducible_of_aleph0_le", "code": "theorem not_irreducible_of_aleph0_le (ha : \u2135\u2080 \u2264 a) : \u00acIrreducible a", "start": [91, 1], "end": [95, 11], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_coe_dvd_iff", "code": "@[simp, norm_cast]\ntheorem nat_coe_dvd_iff : (n : Cardinal) \u2223 m \u2194 n \u2223 m", "start": [98, 1], "end": [107, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_is_prime_iff", "code": "@[simp]\ntheorem nat_is_prime_iff : Prime (n : Cardinal) \u2194 n.Prime", "start": [110, 1], "end": [133, 82], "kind": "commanddeclaration"}, {"full_name": "Cardinal.is_prime_iff", "code": "theorem is_prime_iff {a : Cardinal} : Prime a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 p : \u2115, a = p \u2227 p.Prime", "start": [136, 1], "end": [140, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isPrimePow_iff", "code": "theorem isPrimePow_iff {a : Cardinal} : IsPrimePow a \u2194 \u2135\u2080 \u2264 a \u2228 \u2203 n : \u2115, a = n \u2227 IsPrimePow n", "start": [143, 1], "end": [156, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MvPolynomial/Cardinal.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/Data/Finsupp/Fintype.lean", "Mathlib/Data/MvPolynomial/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPolynomial.cardinal_mk_eq_max_lift", "code": "@[simp]\ntheorem cardinal_mk_eq_max_lift [Nonempty \u03c3] [Nontrivial R] :\n    #(MvPolynomial \u03c3 R) = max (max (Cardinal.lift.{u} #R) <| Cardinal.lift.{v} #\u03c3) \u2135\u2080", "start": [33, 1], "end": [37, 68], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.cardinal_mk_eq_lift", "code": "@[simp]\ntheorem cardinal_mk_eq_lift [IsEmpty \u03c3] : #(MvPolynomial \u03c3 R) = Cardinal.lift.{u} #R", "start": [40, 1], "end": [42, 74], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.cardinal_lift_mk_le_max", "code": "theorem cardinal_lift_mk_le_max {\u03c3 : Type u} {R : Type v} [CommSemiring R] : #(MvPolynomial \u03c3 R) \u2264\n    max (max (Cardinal.lift.{u} #R) <| Cardinal.lift.{v} #\u03c3) \u2135\u2080", "start": [45, 1], "end": [51, 37], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.cardinal_mk_eq_max", "code": "theorem cardinal_mk_eq_max [Nonempty \u03c3] [Nontrivial R] :\n    #(MvPolynomial \u03c3 R) = max (max #R #\u03c3) \u2135\u2080", "start": [58, 1], "end": [59, 56], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.cardinal_mk_le_max", "code": "theorem cardinal_mk_le_max : #(MvPolynomial \u03c3 R) \u2264 max (max #R #\u03c3) \u2135\u2080", "start": [62, 1], "end": [65, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/PolynomialGaloisGroup.lean", "imports": ["Mathlib/GroupTheory/Perm/Cycle/Type.lean", "Mathlib/Analysis/Complex/Polynomial.lean", "Mathlib/FieldTheory/Galois.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.Gal", "code": "def Gal :=\n  p.SplittingField \u2243\u2090[F] p.SplittingField", "start": [54, 1], "end": [56, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.instGroup", "code": "instance instGroup : Group (Gal p) :=\n  inferInstanceAs (Group (p.SplittingField \u2243\u2090[F] p.SplittingField))", "start": [63, 1], "end": [64, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.instFintype", "code": "instance instFintype : Fintype (Gal p) :=\n  inferInstanceAs (Fintype (p.SplittingField \u2243\u2090[F] p.SplittingField))", "start": [65, 1], "end": [66, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.applyMulSemiringAction", "code": "instance applyMulSemiringAction : MulSemiringAction p.Gal p.SplittingField :=\n  AlgEquiv.applyMulSemiringAction", "start": [72, 1], "end": [73, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.ext", "code": "@[ext]\ntheorem ext {\u03c3 \u03c4 : p.Gal} (h : \u2200 x \u2208 p.rootSet p.SplittingField, \u03c3 x = \u03c4 x) : \u03c3 = \u03c4", "start": [76, 1], "end": [82, 75], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalOfSplits", "code": "def uniqueGalOfSplits (h : p.Splits (RingHom.id F)) : Unique p.Gal where\n  default := 1\n  uniq f :=\n    AlgEquiv.ext fun x => by\n      obtain \u27e8y, rfl\u27e9 :=\n        Algebra.mem_bot.mp\n          ((SetLike.ext_iff.mp ((IsSplittingField.splits_iff _ p).mp h) x).mp Algebra.mem_top)\n      rw [AlgEquiv.commutes, AlgEquiv.commutes]", "start": [85, 1], "end": [93, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalZero", "code": "instance uniqueGalZero : Unique (0 : F[X]).Gal :=\n  uniqueGalOfSplits _ (splits_zero _)", "start": [99, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalOne", "code": "instance uniqueGalOne : Unique (1 : F[X]).Gal :=\n  uniqueGalOfSplits _ (splits_one _)", "start": [103, 1], "end": [104, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalC", "code": "instance uniqueGalC (x : F) : Unique (C x).Gal :=\n  uniqueGalOfSplits _ (splits_C _ _)", "start": [107, 1], "end": [108, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalX", "code": "instance uniqueGalX : Unique (X : F[X]).Gal :=\n  uniqueGalOfSplits _ (splits_X _)", "start": [112, 1], "end": [113, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalXSubC", "code": "instance uniqueGalXSubC (x : F) : Unique (X - C x).Gal :=\n  uniqueGalOfSplits _ (splits_X_sub_C _)", "start": [117, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.uniqueGalXPow", "code": "instance uniqueGalXPow (n : \u2115) : Unique (X ^ n : F[X]).Gal :=\n  uniqueGalOfSplits _ (splits_X_pow _ _)", "start": [122, 1], "end": [123, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrict", "code": "def restrict [Fact (p.Splits (algebraMap F E))] : (E \u2243\u2090[F] E) \u2192* p.Gal :=\n  AlgEquiv.restrictNormalHom p.SplittingField", "start": [140, 1], "end": [142, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrict_surjective", "code": "theorem restrict_surjective [Fact (p.Splits (algebraMap F E))] [Normal F E] :\n    Function.Surjective (restrict p E)", "start": [145, 1], "end": [147, 42], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.mapRoots", "code": "def mapRoots [Fact (p.Splits (algebraMap F E))] : rootSet p p.SplittingField \u2192 rootSet p E :=\n  Set.MapsTo.restrict (IsScalarTower.toAlgHom F p.SplittingField E) _ _ <| rootSet_mapsTo _", "start": [152, 1], "end": [155, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.mapRoots_bijective", "code": "theorem mapRoots_bijective [h : Fact (p.Splits (algebraMap F E))] :\n    Function.Bijective (mapRoots p E)", "start": [158, 1], "end": [171, 93], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.rootsEquivRoots", "code": "def rootsEquivRoots [Fact (p.Splits (algebraMap F E))] : rootSet p p.SplittingField \u2243 rootSet p E :=\n  Equiv.ofBijective (mapRoots p E) (mapRoots_bijective p E)", "start": [174, 1], "end": [176, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionAux", "code": "instance galActionAux : MulAction p.Gal (rootSet p p.SplittingField) where\n  smul \u03d5 := Set.MapsTo.restrict \u03d5 _ _ <| rootSet_mapsTo \u03d5.toAlgHom\n  one_smul _ := by ext; rfl\n  mul_smul _ _ _ := by ext; rfl", "start": [179, 1], "end": [182, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.smul", "code": "instance smul [Fact (p.Splits (algebraMap F E))] : SMul p.Gal (rootSet p E) where\n  smul \u03d5 x := rootsEquivRoots p E (\u03d5 \u2022 (rootsEquivRoots p E).symm x)", "start": [186, 1], "end": [187, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.smul_def", "code": "theorem smul_def [Fact (p.Splits (algebraMap F E))] (\u03d5 : p.Gal) (x : rootSet p E) :\n    \u03d5 \u2022 x = rootsEquivRoots p E (\u03d5 \u2022 (rootsEquivRoots p E).symm x)", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galAction", "code": "instance galAction [Fact (p.Splits (algebraMap F E))] : MulAction p.Gal (rootSet p E) where\n  one_smul _ := by simp only [smul_def, Equiv.apply_symm_apply, one_smul]\n  mul_smul _ _ _ := by\n    simp only [smul_def, Equiv.apply_symm_apply, Equiv.symm_apply_apply, mul_smul]", "start": [194, 1], "end": [198, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrict_smul", "code": "@[simp]\ntheorem restrict_smul [Fact (p.Splits (algebraMap F E))] (\u03d5 : E \u2243\u2090[F] E) (x : rootSet p E) :\n    \u2191(restrict p E \u03d5 \u2022 x) = \u03d5 x", "start": [203, 1], "end": [211, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionHom", "code": "def galActionHom [Fact (p.Splits (algebraMap F E))] : p.Gal \u2192* Equiv.Perm (rootSet p E) :=\n  MulAction.toPermHom _ _", "start": [216, 1], "end": [218, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionHom_restrict", "code": "theorem galActionHom_restrict [Fact (p.Splits (algebraMap F E))] (\u03d5 : E \u2243\u2090[F] E) (x : rootSet p E) :\n    \u2191(galActionHom p E (restrict p E \u03d5) x) = \u03d5 x", "start": [221, 1], "end": [223, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionHom_injective", "code": "theorem galActionHom_injective [Fact (p.Splits (algebraMap F E))] :\n    Function.Injective (galActionHom p E)", "start": [226, 1], "end": [238, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictDvd", "code": "def restrictDvd (hpq : p \u2223 q) : q.Gal \u2192* p.Gal :=\n  haveI := Classical.dec (q = 0)\n  if hq : q = 0 then 1\n  else\n    @restrict F _ p _ _ _\n      \u27e8splits_of_splits_of_dvd (algebraMap F q.SplittingField) hq (SplittingField.splits q) hpq\u27e9", "start": [245, 1], "end": [251, 97], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictDvd_def", "code": "theorem restrictDvd_def [Decidable (q = 0)] (hpq : p \u2223 q) :\n    restrictDvd hpq =\n      if hq : q = 0 then 1\n      else\n        @restrict F _ p _ _ _\n          \u27e8splits_of_splits_of_dvd (algebraMap F q.SplittingField) hq (SplittingField.splits q)\n              hpq\u27e9", "start": [254, 1], "end": [263, 14], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictDvd_surjective", "code": "theorem restrictDvd_surjective (hpq : p \u2223 q) (hq : q \u2260 0) : Function.Surjective (restrictDvd hpq)", "start": [266, 1], "end": [272, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictProd", "code": "def restrictProd : (p * q).Gal \u2192* p.Gal \u00d7 q.Gal :=\n  MonoidHom.prod (restrictDvd (dvd_mul_right p q)) (restrictDvd (dvd_mul_left q p))", "start": [277, 1], "end": [279, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictProd_injective", "code": "theorem restrictProd_injective : Function.Injective (restrictProd p q)", "start": [282, 1], "end": [313, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.mul_splits_in_splittingField_of_mul", "code": "theorem mul_splits_in_splittingField_of_mul {p\u2081 q\u2081 p\u2082 q\u2082 : F[X]} (hq\u2081 : q\u2081 \u2260 0) (hq\u2082 : q\u2082 \u2260 0)\n    (h\u2081 : p\u2081.Splits (algebraMap F q\u2081.SplittingField))\n    (h\u2082 : p\u2082.Splits (algebraMap F q\u2082.SplittingField)) :\n    (p\u2081 * p\u2082).Splits (algebraMap F (q\u2081 * q\u2082).SplittingField)", "start": [316, 1], "end": [330, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.splits_in_splittingField_of_comp", "code": "theorem splits_in_splittingField_of_comp (hq : q.natDegree \u2260 0) :\n    p.Splits (algebraMap F (p.comp q).SplittingField)", "start": [333, 1], "end": [376, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictComp", "code": "def restrictComp (hq : q.natDegree \u2260 0) : (p.comp q).Gal \u2192* p.Gal :=\n  let h : Fact (Splits (algebraMap F (p.comp q).SplittingField) p) :=\n    \u27e8splits_in_splittingField_of_comp p q hq\u27e9\n  @restrict F _ p _ _ _ h", "start": [379, 1], "end": [383, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.restrictComp_surjective", "code": "theorem restrictComp_surjective (hq : q.natDegree \u2260 0) :\n    Function.Surjective (restrictComp p q hq)", "start": [386, 1], "end": [393, 32], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.card_of_separable", "code": "theorem card_of_separable (hp : p.Separable) : Fintype.card p.Gal = finrank F p.SplittingField", "start": [398, 1], "end": [402, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.prime_degree_dvd_card", "code": "theorem prime_degree_dvd_card [CharZero F] (p_irr : Irreducible p) (p_deg : p.natDegree.Prime) :\n    p.natDegree \u2223 Fintype.card p.Gal", "start": [405, 1], "end": [423, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.splits_\u211a_\u2102", "code": "theorem splits_\u211a_\u2102 {p : \u211a[X]} : Fact (p.Splits (algebraMap \u211a \u2102))", "start": [428, 1], "end": [429, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.card_complex_roots_eq_card_real_add_card_not_gal_inv", "code": "theorem card_complex_roots_eq_card_real_add_card_not_gal_inv (p : \u211a[X]) :\n    (p.rootSet \u2102).toFinset.card =\n      (p.rootSet \u211d).toFinset.card +\n        (galActionHom p \u2102 (restrict p \u2102\n        (AlgEquiv.restrictScalars \u211a Complex.conjAe))).support.card", "start": [434, 1], "end": [486, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionHom_bijective_of_prime_degree", "code": "theorem galActionHom_bijective_of_prime_degree {p : \u211a[X]} (p_irr : Irreducible p)\n    (p_deg : p.natDegree.Prime)\n    (p_roots : Fintype.card (p.rootSet \u2102) = Fintype.card (p.rootSet \u211d) + 2) :\n    Function.Bijective (galActionHom p \u2102)", "start": [489, 1], "end": [516, 72], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Gal.galActionHom_bijective_of_prime_degree'", "code": "theorem galActionHom_bijective_of_prime_degree' {p : \u211a[X]} (p_irr : Irreducible p)\n    (p_deg : p.natDegree.Prime)\n    (p_roots1 : Fintype.card (p.rootSet \u211d) + 1 \u2264 Fintype.card (p.rootSet \u2102))\n    (p_roots2 : Fintype.card (p.rootSet \u2102) \u2264 Fintype.card (p.rootSet \u211d) + 3) :\n    Function.Bijective (galActionHom p \u2102)", "start": [519, 1], "end": [544, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DList/Basic.lean", "imports": ["Mathlib/Tactic/Basic.lean", "Mathlib/Data/DList/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.DList.join", "code": "def DList.join {\u03b1 : Type*} : List (DList \u03b1) \u2192 DList \u03b1\n  | [] => DList.empty\n  | x :: xs => x ++ DList.join xs", "start": [27, 1], "end": [31, 34], "kind": "commanddeclaration"}, {"full_name": "Std.DList_singleton", "code": "@[simp]\ntheorem DList_singleton {\u03b1 : Type*} {a : \u03b1} : DList.singleton a = DList.lazy_ofList [a]", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Std.DList_lazy", "code": "@[simp]\ntheorem DList_lazy {\u03b1 : Type*} {l : List \u03b1} : DList.lazy_ofList l = Std.DList.ofList l", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/FlagRange.lean", "imports": ["Mathlib/Order/Cover.lean", "Mathlib/Data/Fin/Basic.lean", "Mathlib/Order/Chain.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsMaxChain.range_fin_of_covby", "code": "theorem IsMaxChain.range_fin_of_covby (h0 : f 0 = \u22a5) (hlast : f (.last n) = \u22a4)\n    (hcovby : \u2200 k : Fin n, f k.castSucc \u2a7f f k.succ) :\n    IsMaxChain (\u00b7 \u2264 \u00b7) (range f)", "start": [26, 1], "end": [43, 80], "kind": "commanddeclaration"}, {"full_name": "Flag.rangeFin", "code": "@[simps]\ndef Flag.rangeFin (f : Fin (n + 1) \u2192 \u03b1) (h0 : f 0 = \u22a5) (hlast : f (.last n) = \u22a4)\n    (hcovby : \u2200 k : Fin n, f k.castSucc \u2a7f f k.succ) : Flag \u03b1 where\n  carrier := range f\n  Chain' := (IsMaxChain.range_fin_of_covby h0 hlast hcovby).1\n  max_chain' := (IsMaxChain.range_fin_of_covby h0 hlast hcovby).2", "start": [45, 1], "end": [55, 66], "kind": "commanddeclaration"}, {"full_name": "Flag.mem_rangeFin", "code": "@[simp] theorem Flag.mem_rangeFin {x h0 hlast hcovby} :\n    x \u2208 rangeFin f h0 hlast hcovby \u2194 \u2203 k, f k = x", "start": [57, 1], "end": [59, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Young/YoungDiagram.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Data/Finset/Preimage.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "YoungDiagram", "code": "@[ext]\nstructure YoungDiagram where\n  \n  cells : Finset (\u2115 \u00d7 \u2115)\n  \n  isLowerSet : IsLowerSet (cells : Set (\u2115 \u00d7 \u2115))", "start": [55, 1], "end": [66, 48], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_cells", "code": "@[simp]\ntheorem mem_cells {\u03bc : YoungDiagram} (c : \u2115 \u00d7 \u2115) : c \u2208 \u03bc.cells \u2194 c \u2208 \u03bc", "start": [77, 1], "end": [79, 10], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_mk", "code": "@[simp]\ntheorem mem_mk (c : \u2115 \u00d7 \u2115) (cells) (isLowerSet) :\n    c \u2208 YoungDiagram.mk cells isLowerSet \u2194 c \u2208 cells", "start": [82, 1], "end": [85, 10], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.decidableMem", "code": "instance decidableMem (\u03bc : YoungDiagram) : DecidablePred (\u00b7 \u2208 \u03bc) :=\n  inferInstanceAs (DecidablePred (\u00b7 \u2208 \u03bc.cells))", "start": [88, 1], "end": [89, 48], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.up_left_mem", "code": "theorem up_left_mem (\u03bc : YoungDiagram) {i1 i2 j1 j2 : \u2115} (hi : i1 \u2264 i2) (hj : j1 \u2264 j2)\n    (hcell : (i2, j2) \u2208 \u03bc) : (i1, j1) \u2208 \u03bc", "start": [92, 1], "end": [96, 50], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cells_subset_iff", "code": "@[simp]\ntheorem cells_subset_iff {\u03bc \u03bd : YoungDiagram} : \u03bc.cells \u2286 \u03bd.cells \u2194 \u03bc \u2264 \u03bd", "start": [101, 1], "end": [103, 10], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cells_ssubset_iff", "code": "@[simp]\ntheorem cells_ssubset_iff {\u03bc \u03bd : YoungDiagram} : \u03bc.cells \u2282 \u03bd.cells \u2194 \u03bc < \u03bd", "start": [106, 1], "end": [108, 10], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cells_sup", "code": "@[simp]\ntheorem cells_sup (\u03bc \u03bd : YoungDiagram) : (\u03bc \u2294 \u03bd).cells = \u03bc.cells \u222a \u03bd.cells", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (\u03bc \u03bd : YoungDiagram) : \u2191(\u03bc \u2294 \u03bd) = (\u03bc \u222a \u03bd : Set (\u2115 \u00d7 \u2115))", "start": [123, 1], "end": [125, 23], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_sup", "code": "@[simp]\ntheorem mem_sup {\u03bc \u03bd : YoungDiagram} {x : \u2115 \u00d7 \u2115} : x \u2208 \u03bc \u2294 \u03bd \u2194 x \u2208 \u03bc \u2228 x \u2208 \u03bd", "start": [128, 1], "end": [130, 19], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cells_inf", "code": "@[simp]\ntheorem cells_inf (\u03bc \u03bd : YoungDiagram) : (\u03bc \u2293 \u03bd).cells = \u03bc.cells \u2229 \u03bd.cells", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (\u03bc \u03bd : YoungDiagram) : \u2191(\u03bc \u2293 \u03bd) = (\u03bc \u2229 \u03bd : Set (\u2115 \u00d7 \u2115))", "start": [145, 1], "end": [147, 23], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_inf", "code": "@[simp]\ntheorem mem_inf {\u03bc \u03bd : YoungDiagram} {x : \u2115 \u00d7 \u2115} : x \u2208 \u03bc \u2293 \u03bd \u2194 x \u2208 \u03bc \u2227 x \u2208 \u03bd", "start": [150, 1], "end": [152, 19], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cells_bot", "code": "@[simp]\ntheorem cells_bot : (\u22a5 : YoungDiagram).cells = \u2205", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.coe_bot", "code": "@[norm_cast]\ntheorem coe_bot : (\u22a5 : YoungDiagram).cells = (\u2205 : Set (\u2115 \u00d7 \u2115))", "start": [174, 1], "end": [179, 60], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.not_mem_bot", "code": "@[simp]\ntheorem not_mem_bot (x : \u2115 \u00d7 \u2115) : x \u2209 (\u22a5 : YoungDiagram)", "start": [182, 1], "end": [184, 25], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.card", "code": "@[reducible]\nprotected def card (\u03bc : YoungDiagram) : \u2115 :=\n  \u03bc.cells.card", "start": [196, 1], "end": [199, 15], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose", "code": "def transpose (\u03bc : YoungDiagram) : YoungDiagram where\n  cells := (Equiv.prodComm _ _).finsetCongr \u03bc.cells\n  isLowerSet _ _ h := by\n    simp only [Finset.mem_coe, Equiv.finsetCongr_apply, Finset.mem_map_equiv]\n    intro hcell\n    apply \u03bc.isLowerSet _ hcell\n    simp [h]", "start": [204, 1], "end": [211, 13], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_transpose", "code": "@[simp]\ntheorem mem_transpose {\u03bc : YoungDiagram} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.transpose \u2194 c.swap \u2208 \u03bc", "start": [214, 1], "end": [216, 19], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose_transpose", "code": "@[simp]\ntheorem transpose_transpose (\u03bc : YoungDiagram) : \u03bc.transpose.transpose = \u03bc", "start": [219, 1], "end": [222, 7], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose_eq_iff_eq_transpose", "code": "theorem transpose_eq_iff_eq_transpose {\u03bc \u03bd : YoungDiagram} : \u03bc.transpose = \u03bd \u2194 \u03bc = \u03bd.transpose", "start": [225, 1], "end": [228, 11], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose_eq_iff", "code": "@[simp]\ntheorem transpose_eq_iff {\u03bc \u03bd : YoungDiagram} : \u03bc.transpose = \u03bd.transpose \u2194 \u03bc = \u03bd", "start": [231, 1], "end": [234, 7], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.le_of_transpose_le", "code": "protected theorem le_of_transpose_le {\u03bc \u03bd : YoungDiagram} (h_le : \u03bc.transpose \u2264 \u03bd) :\n    \u03bc \u2264 \u03bd.transpose", "start": [238, 1], "end": [242, 8], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose_le_iff", "code": "@[simp]\ntheorem transpose_le_iff {\u03bc \u03bd : YoungDiagram} : \u03bc.transpose \u2264 \u03bd.transpose \u2194 \u03bc \u2264 \u03bd", "start": [245, 1], "end": [251, 46], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transpose_mono", "code": "@[mono]\nprotected theorem transpose_mono {\u03bc \u03bd : YoungDiagram} (h_le : \u03bc \u2264 \u03bd) : \u03bc.transpose \u2264 \u03bd.transpose", "start": [254, 1], "end": [256, 28], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.transposeOrderIso", "code": "@[simps]\ndef transposeOrderIso : YoungDiagram \u2243o YoungDiagram :=\n  \u27e8\u27e8transpose, transpose, fun _ => by simp, fun _ => by simp\u27e9, by simp\u27e9", "start": [259, 1], "end": [262, 72], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.row", "code": "def row (\u03bc : YoungDiagram) (i : \u2115) : Finset (\u2115 \u00d7 \u2115) :=\n  \u03bc.cells.filter fun c => c.fst = i", "start": [281, 1], "end": [283, 36], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_row_iff", "code": "theorem mem_row_iff {\u03bc : YoungDiagram} {i : \u2115} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.row i \u2194 c \u2208 \u03bc \u2227 c.fst = i", "start": [286, 1], "end": [287, 13], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mk_mem_row_iff", "code": "theorem mk_mem_row_iff {\u03bc : YoungDiagram} {i j : \u2115} : (i, j) \u2208 \u03bc.row i \u2194 (i, j) \u2208 \u03bc", "start": [290, 1], "end": [290, 101], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.exists_not_mem_row", "code": "protected theorem exists_not_mem_row (\u03bc : YoungDiagram) (i : \u2115) : \u2203 j, (i, j) \u2209 \u03bc", "start": [293, 1], "end": [300, 16], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLen", "code": "def rowLen (\u03bc : YoungDiagram) (i : \u2115) : \u2115 :=\n  Nat.find <| \u03bc.exists_not_mem_row i", "start": [303, 1], "end": [305, 37], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_iff_lt_rowLen", "code": "theorem mem_iff_lt_rowLen {\u03bc : YoungDiagram} {i j : \u2115} : (i, j) \u2208 \u03bc \u2194 j < \u03bc.rowLen i", "start": [308, 1], "end": [311, 77], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.row_eq_prod", "code": "theorem row_eq_prod {\u03bc : YoungDiagram} {i : \u2115} : \u03bc.row i = {i} \u00d7\u02e2 Finset.range (\u03bc.rowLen i)", "start": [314, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLen_eq_card", "code": "theorem rowLen_eq_card (\u03bc : YoungDiagram) {i : \u2115} : \u03bc.rowLen i = (\u03bc.row i).card", "start": [322, 1], "end": [323, 21], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLen_anti", "code": "@[mono]\ntheorem rowLen_anti (\u03bc : YoungDiagram) (i1 i2 : \u2115) (hi : i1 \u2264 i2) : \u03bc.rowLen i2 \u2264 \u03bc.rowLen i1", "start": [326, 1], "end": [331, 39], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.col", "code": "def col (\u03bc : YoungDiagram) (j : \u2115) : Finset (\u2115 \u00d7 \u2115) :=\n  \u03bc.cells.filter fun c => c.snd = j", "start": [343, 1], "end": [345, 36], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_col_iff", "code": "theorem mem_col_iff {\u03bc : YoungDiagram} {j : \u2115} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.col j \u2194 c \u2208 \u03bc \u2227 c.snd = j", "start": [348, 1], "end": [349, 13], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mk_mem_col_iff", "code": "theorem mk_mem_col_iff {\u03bc : YoungDiagram} {i j : \u2115} : (i, j) \u2208 \u03bc.col j \u2194 (i, j) \u2208 \u03bc", "start": [352, 1], "end": [352, 101], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.exists_not_mem_col", "code": "protected theorem exists_not_mem_col (\u03bc : YoungDiagram) (j : \u2115) : \u2203 i, (i, j) \u2209 \u03bc.cells", "start": [355, 1], "end": [357, 7], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.colLen", "code": "def colLen (\u03bc : YoungDiagram) (j : \u2115) : \u2115 :=\n  Nat.find <| \u03bc.exists_not_mem_col j", "start": [360, 1], "end": [362, 37], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.colLen_transpose", "code": "@[simp]\ntheorem colLen_transpose (\u03bc : YoungDiagram) (j : \u2115) : \u03bc.transpose.colLen j = \u03bc.rowLen j", "start": [365, 1], "end": [367, 24], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLen_transpose", "code": "@[simp]\ntheorem rowLen_transpose (\u03bc : YoungDiagram) (i : \u2115) : \u03bc.transpose.rowLen i = \u03bc.colLen i", "start": [370, 1], "end": [372, 24], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_iff_lt_colLen", "code": "theorem mem_iff_lt_colLen {\u03bc : YoungDiagram} {i j : \u2115} : (i, j) \u2208 \u03bc \u2194 i < \u03bc.colLen j", "start": [375, 1], "end": [377, 7], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.col_eq_prod", "code": "theorem col_eq_prod {\u03bc : YoungDiagram} {j : \u2115} : \u03bc.col j = Finset.range (\u03bc.colLen j) \u00d7\u02e2 {j}", "start": [380, 1], "end": [385, 6], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.colLen_eq_card", "code": "theorem colLen_eq_card (\u03bc : YoungDiagram) {j : \u2115} : \u03bc.colLen j = (\u03bc.col j).card", "start": [388, 1], "end": [389, 21], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.colLen_anti", "code": "@[mono]\ntheorem colLen_anti (\u03bc : YoungDiagram) (j1 j2 : \u2115) (hj : j1 \u2264 j2) : \u03bc.colLen j2 \u2264 \u03bc.colLen j1", "start": [392, 1], "end": [394, 60], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLens", "code": "def rowLens (\u03bc : YoungDiagram) : List \u2115 :=\n  (List.range <| \u03bc.colLen 0).map \u03bc.rowLen", "start": [410, 1], "end": [412, 42], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.get_rowLens", "code": "@[simp]\ntheorem get_rowLens {\u03bc : YoungDiagram} {i} :\n    \u03bc.rowLens.get i = \u03bc.rowLen i", "start": [416, 1], "end": [418, 89], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.length_rowLens", "code": "@[simp]\ntheorem length_rowLens {\u03bc : YoungDiagram} : \u03bc.rowLens.length = \u03bc.colLen 0", "start": [421, 1], "end": [423, 58], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLens_sorted", "code": "theorem rowLens_sorted (\u03bc : YoungDiagram) : \u03bc.rowLens.Sorted (\u00b7 \u2265 \u00b7)", "start": [426, 1], "end": [427, 49], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.pos_of_mem_rowLens", "code": "theorem pos_of_mem_rowLens (\u03bc : YoungDiagram) (x : \u2115) (hx : x \u2208 \u03bc.rowLens) : 0 < x", "start": [430, 1], "end": [433, 69], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.cellsOfRowLens", "code": "protected def cellsOfRowLens : List \u2115 \u2192 Finset (\u2115 \u00d7 \u2115)\n  | [] => \u2205\n  | w::ws =>\n    ({0} : Finset \u2115) \u00d7\u02e2 Finset.range w \u222a\n      (YoungDiagram.cellsOfRowLens ws).map\n        (Embedding.prodMap \u27e8_, Nat.succ_injective\u27e9 (Embedding.refl \u2115))", "start": [452, 1], "end": [458, 71], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_cellsOfRowLens", "code": "protected theorem mem_cellsOfRowLens {w : List \u2115} {c : \u2115 \u00d7 \u2115} :\n    c \u2208 YoungDiagram.cellsOfRowLens w \u2194 \u2203 h : c.fst < w.length, c.snd < w.get \u27e8c.fst, h\u27e9", "start": [462, 1], "end": [469, 67], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.ofRowLens", "code": "def ofRowLens (w : List \u2115) (hw : w.Sorted (\u00b7 \u2265 \u00b7)) : YoungDiagram\n    where\n  cells := YoungDiagram.cellsOfRowLens w\n  isLowerSet := by\n    rintro \u27e8i2, j2\u27e9 \u27e8i1, j1\u27e9 \u27e8hi : i1 \u2264 i2, hj : j1 \u2264 j2\u27e9 hcell\n    rw [Finset.mem_coe, YoungDiagram.mem_cellsOfRowLens] at hcell \u22a2\n    obtain \u27e8h1, h2\u27e9 := hcell\n    refine' \u27e8hi.trans_lt h1, _\u27e9\n    calc\n      j1 \u2264 j2 := hj\n      _ < w.get \u27e8i2, _\u27e9  := h2\n      _ \u2264 w.get \u27e8i1, _\u27e9 := by\n        obtain rfl | h := eq_or_lt_of_le hi\n        \u00b7 convert le_refl (w.get \u27e8i1, h1\u27e9)\n        \u00b7 exact List.pairwise_iff_get.mp hw _ _ h", "start": [473, 1], "end": [488, 50], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.mem_ofRowLens", "code": "theorem mem_ofRowLens {w : List \u2115} {hw : w.Sorted (\u00b7 \u2265 \u00b7)} {c : \u2115 \u00d7 \u2115} :\n    c \u2208 ofRowLens w hw \u2194 \u2203 h : c.fst < w.length, c.snd < w.get \u27e8c.fst, h\u27e9", "start": [492, 1], "end": [494, 34], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLens_length_ofRowLens", "code": "theorem rowLens_length_ofRowLens {w : List \u2115} {hw : w.Sorted (\u00b7 \u2265 \u00b7)} (hpos : \u2200 x \u2208 w, 0 < x) :\n    (ofRowLens w hw).rowLens.length = w.length", "start": [497, 1], "end": [502, 71], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLen_ofRowLens", "code": "theorem rowLen_ofRowLens {w : List \u2115} {hw : w.Sorted (\u00b7 \u2265 \u00b7)} (i : Fin w.length) :\n    (ofRowLens w hw).rowLen i = w.get i", "start": [506, 1], "end": [509, 48], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.ofRowLens_to_rowLens_eq_self", "code": "theorem ofRowLens_to_rowLens_eq_self {\u03bc : YoungDiagram} : ofRowLens _ (rowLens_sorted \u03bc) = \u03bc", "start": [512, 1], "end": [516, 74], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.rowLens_ofRowLens_eq_self", "code": "theorem rowLens_ofRowLens_eq_self {w : List \u2115} {hw : w.Sorted (\u00b7 \u2265 \u00b7)} (hpos : \u2200 x \u2208 w, 0 < x) :\n    (ofRowLens w hw).rowLens = w", "start": [519, 1], "end": [524, 50], "kind": "commanddeclaration"}, {"full_name": "YoungDiagram.equivListRowLens", "code": "@[simps]\ndef equivListRowLens : YoungDiagram \u2243 { w : List \u2115 // w.Sorted (\u00b7 \u2265 \u00b7) \u2227 \u2200 x \u2208 w, 0 < x }\n    where\n  toFun \u03bc := \u27e8\u03bc.rowLens, \u03bc.rowLens_sorted, \u03bc.pos_of_mem_rowLens\u27e9\n  invFun ww := ofRowLens ww.1 ww.2.1\n  left_inv _ := ofRowLens_to_rowLens_eq_self\n  right_inv := fun \u27e8_, hw\u27e9 => Subtype.mk_eq_mk.mpr (rowLens_ofRowLens_eq_self hw.2)", "start": [527, 1], "end": [535, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Recall.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/MutualDef.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/DeriveTraversable.lean", "imports": ["Mathlib/Control/Traversable/Lemmas.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Deriving.Traversable.nestedMap", "code": "partial def nestedMap (f v t : Expr) : TermElabM Expr := do\n  let t \u2190 instantiateMVars t\n  if \u2190 withNewMCtxDepth <| isDefEq t v then\n    return f\n  else if !v.occurs t.appFn! then\n    let cl \u2190 mkAppM ``Functor #[t.appFn!]\n    let inst \u2190 synthInstance cl\n    let f' \u2190 nestedMap f v t.appArg!\n    mkAppOptM ``Functor.map #[t.appFn!, inst, none, none, f']\n  else throwError \"type {t} is not a functor with respect to variable {v}\"", "start": [23, 1], "end": [37, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mapField", "code": "def mapField (n : Name) (cl f \u03b1 \u03b2 e : Expr) : TermElabM Expr := do\n  let t \u2190 whnf (\u2190 inferType e)\n  if t.getAppFn.constName = some n then\n    throwError \"recursive types not supported\"\n  else if \u03b1.eqv e then\n    return \u03b2\n  else if \u03b1.occurs t then\n    let f' \u2190 nestedMap f \u03b1 t\n    return f'.app e\n  else if \u2190\n      (match t with\n        | .app t' _ => withNewMCtxDepth <| isDefEq t' cl\n        | _ => return false) then\n    mkAppM ``Comp.mk #[e]\n  else\n    return e", "start": [39, 1], "end": [55, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.getAuxDefOfDeclName", "code": "def getAuxDefOfDeclName : TermElabM FVarId := do\n  let some declName \u2190 getDeclName? | throwError \"no 'declName?'\"\n  let auxDeclMap := (\u2190 read).auxDeclToFullName\n  let fvars := auxDeclMap.fold (init := []) fun fvars fvar fullName =>\n    if fullName = declName then fvars.concat fvar else fvars\n  match fvars with\n  | [] => throwError \"no auxiliary local declaration corresponding to the current declaration\"\n  | [fvar] => return fvar\n  | _ => throwError \"multiple local declarations corresponding to the current declaration\"", "start": [57, 1], "end": [67, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mapConstructor", "code": "def mapConstructor (c n : Name) (f \u03b1 \u03b2 : Expr) (args\u2080 : List Expr)\n    (args\u2081 : List (Bool \u00d7 Expr)) (m : MVarId) : TermElabM Unit := do\n  let ad \u2190 getAuxDefOfDeclName\n  let g \u2190 m.getType >>= instantiateMVars\n  let args' \u2190 args\u2081.mapM (fun (y : Bool \u00d7 Expr) =>\n      if y.1 then return mkAppN (.fvar ad) #[\u03b1, \u03b2, f, y.2]\n      else mapField n g.appFn! f \u03b1 \u03b2 y.2)\n  mkAppOptM c ((args\u2080 ++ args').map some).toArray >>= m.assign", "start": [69, 1], "end": [77, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mkCasesOnMatch", "code": "def mkCasesOnMatch (type : Name) (levels : List Level) (params : List Expr) (motive : Expr)\n    (indices : List Expr) (val : Expr)\n    (rhss : (ctor : Name) \u2192 (fields : List FVarId) \u2192 TermElabM Expr) : TermElabM Expr := do\n  let matcherName \u2190 getDeclName? >>= (fun n? => Lean.mkAuxName (n?.getD type ++ \"match\") 1)\n  let matchType \u2190 generalizeTelescope (indices.concat val).toArray fun iargs =>\n    mkForallFVars iargs (motive.beta iargs)\n  let iinfo \u2190 getConstInfoInduct type\n  let lhss \u2190 iinfo.ctors.mapM fun ctor => do\n    let cinfo \u2190 getConstInfoCtor ctor\n    let catype \u2190\n      instantiateForall (cinfo.type.instantiateLevelParams cinfo.levelParams levels) params.toArray\n    forallBoundedTelescope catype cinfo.numFields fun cargs _ => do\n      let fvarDecls \u2190 cargs.toList.mapM fun carg => getFVarLocalDecl carg\n      let fieldPats := cargs.toList.map fun carg => Pattern.var carg.fvarId!\n      let patterns := [Pattern.ctor cinfo.name levels params fieldPats]\n      return { ref := .missing\n               fvarDecls\n               patterns }\n  let mres \u2190 Term.mkMatcher { matcherName\n                              matchType\n                              discrInfos := mkArray (indices.length + 1) {}\n                              lhss }\n  mres.addMatcher\n  let rhss \u2190 lhss.mapM fun altLHS => do\n    let [.ctor ctor _ _ cpats] := altLHS.patterns | unreachable!\n    withExistingLocalDecls altLHS.fvarDecls do\n      let fields := altLHS.fvarDecls.map LocalDecl.fvarId\n      let rhsBody \u2190 rhss ctor fields\n      if cpats.isEmpty then\n        mkFunUnit rhsBody\n      else\n        mkLambdaFVars (fields.map Expr.fvar).toArray rhsBody\n  return mkAppN mres.matcher (motive :: indices ++ [val] ++ rhss).toArray", "start": [79, 1], "end": [118, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.getFVarIdsNotImplementationDetails", "code": "def getFVarIdsNotImplementationDetails : MetaM (List FVarId) := do\n  let lctx \u2190 getLCtx\n  return lctx.decls.foldl (init := []) fun r decl? => match decl? with\n    | some decl => if decl.isImplementationDetail then r else r.concat decl.fvarId\n    | none      => r", "start": [120, 1], "end": [125, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.getFVarsNotImplementationDetails", "code": "def getFVarsNotImplementationDetails : MetaM (List Expr) :=\n  List.map Expr.fvar <$> getFVarIdsNotImplementationDetails", "start": [127, 1], "end": [129, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mkMap", "code": "def mkMap (type : Name) (m : MVarId) : TermElabM Unit := do\n  let levels \u2190 getLevelNames\n  let vars \u2190 getFVarsNotImplementationDetails\n  let (#[\u03b1, \u03b2, f, x], m) \u2190 m.introN 4 [`\u03b1, `\u03b2, `f, `x] | failure\n  m.withContext do\n    let xtype \u2190 x.getType\n    let target \u2190 m.getType >>= instantiateMVars\n    let motive \u2190 mkLambdaFVars #[.fvar x] target\n    let e \u2190\n      mkCasesOnMatch type (levels.map Level.param) (vars.concat (.fvar \u03b1)) motive [] (.fvar x)\n        fun ctor fields => do\n          let m \u2190 mkFreshExprSyntheticOpaqueMVar target\n          let args := fields.map Expr.fvar\n          let args\u2080 \u2190 args.mapM fun a => do\n            let b := xtype.occurs (\u2190 inferType a)\n            return (b, a)\n          mapConstructor\n            ctor type (.fvar f) (.fvar \u03b1) (.fvar \u03b2) (vars.concat (.fvar \u03b2)) args\u2080 m.mvarId!\n          instantiateMVars m\n    m.assign e", "start": [131, 1], "end": [151, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.deriveFunctor", "code": "def deriveFunctor (m : MVarId) : TermElabM Unit := do\n  let levels \u2190 getLevelNames\n  let vars \u2190 getFVarsNotImplementationDetails\n  let .app (.const ``Functor _) F \u2190 m.getType >>= instantiateMVars | failure\n  let some n := F.getAppFn.constName? | failure\n  let d \u2190 getConstInfo n\n  let [m] \u2190 run m <| evalTactic (\u2190 `(tactic| refine { map := @(?_) })) | failure\n  let t \u2190 m.getType >>= instantiateMVars\n  let n' := n ++ \"map\"\n  withDeclName n' <| withAuxDecl \"map\" t n' fun ad => do\n    let m' := (\u2190 mkFreshExprSyntheticOpaqueMVar t).mvarId!\n    mkMap n m'\n    let e \u2190 instantiateMVars (mkMVar m')\n    let e := e.replaceFVar ad (mkAppN (.const n' (levels.map Level.param)) vars.toArray)\n    let e' \u2190 mkLambdaFVars vars.toArray e\n    let t' \u2190 mkForallFVars vars.toArray t\n    addPreDefinitions\n      #[{ ref := .missing\n          kind := .def\n          levelParams := levels\n          modifiers :=\n            { isUnsafe := d.isUnsafe\n              attrs :=\n                #[{ kind := .global\n                    name := `specialize\n                    stx := \u2190 `(attr| specialize) }] }\n          declName := n'\n          type := t'\n          value := e' }] {}\n  m.assign (mkAppN (mkConst n' (levels.map Level.param)) vars.toArray)", "start": [153, 1], "end": [183, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mkInstanceNameForTypeExpr", "code": "def mkInstanceNameForTypeExpr (type : Expr) : TermElabM Name := do\n  let result \u2190 do\n    let ref \u2190 IO.mkRef \"\"\n    Meta.forEachExpr type fun e => do\n      if e.isForall then ref.modify (\u00b7 ++ \"ForAll\")\n      else if e.isProp then ref.modify (\u00b7 ++ \"Prop\")\n      else if e.isType then ref.modify (\u00b7 ++ \"Type\")\n      else if e.isSort then ref.modify (\u00b7 ++ \"Sort\")\n      else if e.isConst then\n        match e.constName!.eraseMacroScopes with\n        | .str _ str =>\n            if str.front.isLower then\n              ref.modify (\u00b7 ++ str.capitalize)\n            else\n              ref.modify (\u00b7 ++ str)\n        | _ => pure ()\n    ref.get\n  liftMacroM <| mkUnusedBaseName <| Name.mkSimple (\"inst\" ++ result)", "start": [185, 1], "end": [203, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mkOneInstance", "code": "def mkOneInstance (n cls : Name) (tac : MVarId \u2192 TermElabM Unit)\n    (mkInst : Name \u2192 Expr \u2192 TermElabM Expr := fun n arg => mkAppM n #[arg]) : TermElabM Unit := do\n  let .inductInfo decl \u2190 getConstInfo n |\n    throwError m!\"failed to derive '{cls}', '{n}' is not an inductive type\"\n  let clsDecl \u2190 getConstInfo cls\n  let ls := decl.levelParams.map Level.param\n  let tgt := Lean.mkConst n ls\n  let tgt \u2190 forallTelescope decl.type fun params _ => do\n    let params := params.pop\n    let tgt := mkAppN tgt params\n    let tgt \u2190 mkInst cls tgt\n    params.zipWithIndex.foldrM (fun (param, i) tgt => do\n      let tgt \u2190 (do\n        guard (i < decl.numParams)\n        let paramCls \u2190 mkAppM cls #[param]\n        return mkForall `a .instImplicit paramCls tgt) <|> return tgt\n      mkForallFVars #[param] tgt) tgt\n  (discard <| liftM (synthInstance tgt)) <|> do\n    let m := (\u2190 mkFreshExprSyntheticOpaqueMVar tgt).mvarId!\n    let (_, m') \u2190 m.intros\n    withLevelNames decl.levelParams <| m'.withContext <| tac m'\n    let val \u2190 instantiateMVars (mkMVar m)\n    let isUnsafe := decl.isUnsafe || clsDecl.isUnsafe\n    let instN \u2190 m'.withContext do\n      let type \u2190 m'.getType >>= instantiateMVars\n      mkInstanceNameForTypeExpr type\n    addPreDefinitions\n      #[{ ref := .missing\n          kind := .def\n          levelParams := decl.levelParams\n          modifiers :=\n            { isUnsafe\n              attrs :=\n                #[{ kind := .global\n                    name := `instance\n                    stx := \u2190 `(attr| instance) }] }\n          declName := instN\n          type := tgt\n          value := val }] {}", "start": [205, 1], "end": [247, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.higherOrderDeriveHandler", "code": "def higherOrderDeriveHandler (cls : Name) (tac : MVarId \u2192 TermElabM Unit)\n    (deps : List DerivingHandlerNoArgs := [])\n    (mkInst : Name \u2192 Expr \u2192 TermElabM Expr := fun n arg => mkAppM n #[arg]) :\n    DerivingHandlerNoArgs := fun a => do\n  let #[n] := a | return false let ok \u2190 deps.mapM fun f => f a\n  unless ok.and do return false\n  liftTermElabM <| mkOneInstance n cls tac mkInst\n  return true", "start": [249, 1], "end": [258, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.functorDeriveHandler", "code": "def functorDeriveHandler : DerivingHandlerNoArgs :=\n  higherOrderDeriveHandler ``Functor deriveFunctor []", "start": [260, 1], "end": [262, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.deriveLawfulFunctor", "code": "def deriveLawfulFunctor (m : MVarId) : TermElabM Unit := do\n  let rules (l\u2081 : List (Name \u00d7 Bool)) (l\u2082 : List (Name)) (b : Bool) : MetaM Simp.Context := do\n    let mut s : SimpTheorems := {}\n    s \u2190 l\u2081.foldlM (fun s (n, b) => s.addConst n (inv := b)) s\n    s \u2190 l\u2082.foldlM (fun s n => s.addDeclToUnfold n) s\n    if b then\n      let hs \u2190 getPropHyps\n      s \u2190 hs.foldlM (fun s f => f.getDecl >>= fun d => s.add (.fvar f) #[] d.toExpr) s\n    return { simpTheorems := #[s] }\n  let .app (.app (.const ``LawfulFunctor _) F) _ \u2190 m.getType >>= instantiateMVars | failure\n  let some n := F.getAppFn.constName? | failure\n  let [mcn, mim, mcm] \u2190 m.applyConst ``LawfulFunctor.mk | failure\n  let (_, mcn) \u2190 mcn.introN 2\n  mcn.refl\n  let (#[_, x], mim) \u2190 mim.introN 2 | failure\n  let (some mim, _) \u2190 dsimpGoal mim (\u2190 rules [] [``Functor.map] false) | failure\n  let xs \u2190 mim.induction x (mkRecName n)\n  xs.forM fun \u27e8mim, _, _\u27e9 =>\n    mim.withContext do\n      if let (some (_, mim), _) \u2190\n          simpGoal mim (\u2190 rules [(``Functor.map_id, false)] [n ++ \"map\"] true) then\n        mim.refl\n  let (#[_, _, _, _, _, x], mcm) \u2190 mcm.introN 6 | failure\n  let (some mcm, _) \u2190 dsimpGoal mcm (\u2190 rules [] [``Functor.map] false) | failure\n  let xs \u2190 mcm.induction x (mkRecName n)\n  xs.forM fun \u27e8mcm, _, _\u27e9 =>\n    mcm.withContext do\n      if let (some (_, mcm), _) \u2190\n          simpGoal mcm (\u2190 rules [(``Functor.map_comp_map, true)] [n ++ \"map\"] true) then\n        mcm.refl", "start": [266, 1], "end": [296, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.lawfulFunctorDeriveHandler", "code": "def lawfulFunctorDeriveHandler : DerivingHandlerNoArgs :=\n  higherOrderDeriveHandler ``LawfulFunctor deriveLawfulFunctor [functorDeriveHandler]\n    (fun n arg => mkAppOptM n #[arg, none])", "start": [298, 1], "end": [301, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.nestedTraverse", "code": "partial def nestedTraverse (f v t : Expr) : TermElabM Expr := do\n  let t \u2190 instantiateMVars t\n  if \u2190 withNewMCtxDepth <| isDefEq t v then\n    return f\n  else if !v.occurs t.appFn! then\n    let cl \u2190 mkAppM ``Traversable #[t.appFn!]\n    let inst \u2190 synthInstance cl\n    let f' \u2190 nestedTraverse f v t.appArg!\n    mkAppOptM ``Traversable.traverse #[t.appFn!, inst, none, none, none, none, f']\n  else throwError \"type {t} is not traversable with respect to variable {v}\"", "start": [305, 1], "end": [317, 77], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.traverseField", "code": "def traverseField (n : Name) (cl f v e : Expr) : TermElabM (Bool \u00d7 Expr) := do\n  let t \u2190 whnf (\u2190 inferType e)\n  if t.getAppFn.constName = some n then\n    throwError \"recursive types not supported\"\n  else if v.occurs t then\n    let f' \u2190 nestedTraverse f v t\n    return (true, f'.app e)\n  else if \u2190\n      (match t with\n        | .app t' _ => withNewMCtxDepth <| isDefEq t' cl\n        | _ => return false) then\n    Prod.mk true <$> mkAppM ``Comp.mk #[e]\n  else\n    return (false, e)", "start": [319, 1], "end": [336, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.traverseConstructor", "code": "def traverseConstructor (c n : Name) (applInst f \u03b1 \u03b2 : Expr) (args\u2080 : List Expr)\n    (args\u2081 : List (Bool \u00d7 Expr)) (m : MVarId) : TermElabM Unit := do\n  let ad \u2190 getAuxDefOfDeclName\n  let g \u2190 m.getType >>= instantiateMVars\n  let args' \u2190 args\u2081.mapM (fun (y : Bool \u00d7 Expr) =>\n      if y.1 then return (true, mkAppN (.fvar ad) #[g.appFn!, applInst, \u03b1, \u03b2, f, y.2])\n      else traverseField n g.appFn! f \u03b1 y.2)\n  let gargs := args'.filterMap (fun y => if y.1 then some y.2 else none)\n  let v \u2190 mkFunCtor c (args\u2080.map (fun e => (false, e)) ++ args')\n  let pureInst \u2190 mkAppOptM ``Applicative.toPure #[none, applInst]\n  let constr' \u2190 mkAppOptM ``Pure.pure #[none, pureInst, none, v]\n  let r \u2190 gargs.foldlM\n      (fun e garg => mkFunUnit garg >>= fun e' => mkAppM ``Seq.seq #[e, e']) constr'\n  m.assign r\nwhere\n  \n  mkFunCtor (c : Name) (args : List (Bool \u00d7 Expr)) (fvars : Array Expr := #[])\n      (aargs : Array Expr := #[]) : TermElabM Expr := do\n    match args with\n    | (true, x) :: xs =>\n      let n \u2190 mkFreshUserName `x\n      let t \u2190 inferType x\n      withLocalDeclD n t.appArg! fun y => mkFunCtor c xs (fvars.push y) (aargs.push y)\n    | (false, x) :: xs => mkFunCtor c xs fvars (aargs.push x)\n    | [] => liftM <| mkAppOptM c (aargs.map some) >>= mkLambdaFVars fvars", "start": [338, 1], "end": [367, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.mkTraverse", "code": "def mkTraverse (type : Name) (m : MVarId) : TermElabM Unit := do\n  let vars \u2190 getFVarsNotImplementationDetails\n  let levels \u2190 getLevelNames\n  let (#[_, applInst, \u03b1, \u03b2, f, x], m) \u2190 m.introN 6 [`m, `applInst, `\u03b1, `\u03b2, `f, `x] | failure\n  m.withContext do\n    let xtype \u2190 x.getType\n    let target \u2190 m.getType >>= instantiateMVars\n    let motive \u2190 mkLambdaFVars #[.fvar x] target\n    let e \u2190\n      mkCasesOnMatch type (levels.map Level.param) (vars.concat (.fvar \u03b1)) motive [] (.fvar x)\n        fun ctor fields => do\n          let m \u2190 mkFreshExprSyntheticOpaqueMVar target\n          let args := fields.map Expr.fvar\n          let args\u2080 \u2190 args.mapM fun a => do\n            let b := xtype.occurs (\u2190 inferType a)\n            return (b, a)\n          traverseConstructor\n            ctor type (.fvar applInst) (.fvar f) (.fvar \u03b1) (.fvar \u03b2)\n            (vars.concat (.fvar \u03b2)) args\u2080 m.mvarId!\n          instantiateMVars m\n    m.assign e", "start": [369, 1], "end": [390, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.deriveTraversable", "code": "def deriveTraversable (m : MVarId) : TermElabM Unit := do\n  let levels \u2190 getLevelNames\n  let vars \u2190 getFVarsNotImplementationDetails\n  let .app (.const ``Traversable _) F \u2190 m.getType >>= instantiateMVars | failure\n  let some n := F.getAppFn.constName? | failure\n  let d \u2190 getConstInfo n\n  let [m] \u2190 run m <| evalTactic (\u2190 `(tactic| refine { traverse := @(?_) })) | failure\n  let t \u2190 m.getType >>= instantiateMVars\n  let n' := n ++ \"traverse\"\n  withDeclName n' <| withAuxDecl \"traverse\" t n' fun ad => do\n    let m' := (\u2190 mkFreshExprSyntheticOpaqueMVar t).mvarId!\n    mkTraverse n m'\n    let e \u2190 instantiateMVars (mkMVar m')\n    let e := e.replaceFVar ad (mkAppN (.const n' (levels.map Level.param)) vars.toArray)\n    let e' \u2190 mkLambdaFVars vars.toArray e\n    let t' \u2190 mkForallFVars vars.toArray t\n    addPreDefinitions\n      #[{ ref := .missing\n          kind := .def\n          levelParams := levels\n          modifiers :=\n            { isUnsafe := d.isUnsafe\n              visibility := .protected }\n          declName := n'\n          type := t'\n          value := e' }] {}\n  m.assign (mkAppN (mkConst n' (levels.map Level.param)) vars.toArray)", "start": [392, 1], "end": [419, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.traversableDeriveHandler", "code": "def traversableDeriveHandler : DerivingHandlerNoArgs :=\n  higherOrderDeriveHandler ``Traversable deriveTraversable [functorDeriveHandler]", "start": [421, 1], "end": [423, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.simpFunctorGoal", "code": "def simpFunctorGoal (m : MVarId) (s : Simp.Context) (discharge? : Option Simp.Discharge := none)\n    (simplifyTarget : Bool := true) (fvarIdsToSimp : Array FVarId := #[])\n    (usedSimps : Simp.UsedSimps := {}) :\n    MetaM (Option (Array FVarId \u00d7 MVarId) \u00d7 Simp.UsedSimps) := do\n  let some e \u2190 getSimpExtension? `functor_norm | failure\n  let s' \u2190 e.getTheorems\n  simpGoal m { s with simpTheorems := s.simpTheorems.push s' } discharge? simplifyTarget\n    fvarIdsToSimp usedSimps", "start": [427, 1], "end": [435, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.traversableLawStarter", "code": "def traversableLawStarter (m : MVarId) (n : Name) (s : MetaM Simp.Context)\n    (tac : Array FVarId \u2192 InductionSubgoal \u2192 MVarId \u2192 MetaM Unit) : MetaM Unit := do\n  let s' \u2190 [``Traversable.traverse, ``Functor.map].foldlM\n      (fun s n => s.addDeclToUnfold n) ({} : SimpTheorems)\n  let (fi, m) \u2190 m.intros\n  m.withContext do\n    if let (some m, _) \u2190 dsimpGoal m { simpTheorems := #[s'] } then\n      let ma \u2190 m.induction fi.back (mkRecName n)\n      ma.forM fun is =>\n        is.mvarId.withContext do\n          if let (some (_, m), _) \u2190 simpFunctorGoal is.mvarId (\u2190 s) then\n            tac fi is m", "start": [436, 1], "end": [455, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.deriveLawfulTraversable", "code": "def deriveLawfulTraversable (m : MVarId) : TermElabM Unit := do\n  let rules (l\u2081 : List (Name \u00d7 Bool)) (l\u2082 : List (Name)) (b : Bool) : MetaM Simp.Context := do\n    let mut s : SimpTheorems := {}\n    s \u2190 l\u2081.foldlM (fun s (n, b) => s.addConst n (inv := b)) s\n    s \u2190 l\u2082.foldlM (fun s n => s.addDeclToUnfold n) s\n    if b then\n      let hs \u2190 getPropHyps\n      s \u2190 hs.foldlM (fun s f => f.getDecl >>= fun d => s.add (.fvar f) #[] d.toExpr) s\n    return { config := { failIfUnchanged := false }, simpTheorems := #[s] }\n  let .app (.app (.const ``LawfulTraversable _) F) _ \u2190 m.getType >>= instantiateMVars | failure\n  let some n := F.getAppFn.constName? | failure\n  let [mit, mct, mtmi, mn] \u2190 m.applyConst ``LawfulTraversable.mk | failure\n  let defEqns : MetaM Simp.Context := rules [] [n ++ \"map\", n ++ \"traverse\"] true\n  traversableLawStarter mit n defEqns fun _ _ m => m.refl\n  traversableLawStarter mct n defEqns fun _ _ m => do\n    if let (some (_, m), _) \u2190\n        simpFunctorGoal m (\u2190 rules [] [n ++ \"map\", n ++ \"traverse\", ``Function.comp] true) then\n    m.refl\n  traversableLawStarter mtmi n defEqns fun _ _ m => do\n    if let (some (_, m), _) \u2190\n        simpGoal m (\u2190 rules [(``Traversable.traverse_eq_map_id', false)] [] false) then\n    m.refl\n  traversableLawStarter mn n defEqns fun _ _ m => do\n    if let (some (_, m), _) \u2190\n        simpGoal m (\u2190 rules [(``Traversable.naturality_pf, false)] [] false) then\n    m.refl", "start": [457, 1], "end": [483, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.Traversable.lawfulTraversableDeriveHandler", "code": "def lawfulTraversableDeriveHandler : DerivingHandlerNoArgs :=\n  higherOrderDeriveHandler ``LawfulTraversable deriveLawfulTraversable\n    [traversableDeriveHandler, lawfulFunctorDeriveHandler] (fun n arg => mkAppOptM n #[arg, none])", "start": [485, 1], "end": [488, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/Congrm.lean", "imports": ["Mathlib/Tactic/Congrm.lean", "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "makeCongrmString", "code": "@[nolint unusedArguments]\ndef makeCongrmString (pos : Array Lean.SubExpr.GoalsLocation) (goalType : Expr)\n    (_ : SelectInsertParams) : MetaM (String \u00d7 String \u00d7 Option (String.Pos \u00d7 String.Pos)) := do\n  let subexprPos := getGoalLocations pos\n  unless goalType.isAppOf `Eq || goalType.isAppOf `Iff do\n    throwError \"The goal must be an equality or iff.\"\n  let mut goalTypeWithMetaVars := goalType\n  for pos in subexprPos do\n    goalTypeWithMetaVars \u2190 insertMetaVar goalTypeWithMetaVars pos\n\n  let side := if subexprPos[0]!.toArray[0]! = 0 then 1 else 2\n  let sideExpr := goalTypeWithMetaVars.getAppArgs[side]!\n  let res := \"congrm \" ++ (toString (\u2190 Meta.ppExpr sideExpr)).renameMetaVar\n  return (res, res, none)", "start": [22, 1], "end": [36, 26], "kind": "commanddeclaration"}, {"full_name": "CongrmSelectionPanel.rpc", "code": "@[server_rpc_method]\ndef CongrmSelectionPanel.rpc := mkSelectionPanelRPC makeCongrmString\n  \"Use shift-click to select sub-expressions in the goal that should become holes in congrm.\"\n  \"Congrm \ud83d\udd0d\"", "start": [38, 1], "end": [42, 13], "kind": "commanddeclaration"}, {"full_name": "CongrmSelectionPanel", "code": "@[widget_module]\ndef CongrmSelectionPanel : Component SelectInsertParams :=\n  mk_rpc_widget% CongrmSelectionPanel.rpc", "start": [44, 1], "end": [47, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Change.lean", "imports": ["Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/SlimCheck.lean", "imports": ["Mathlib/Testing/SlimCheck/Testable.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Data/List/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/NormNum/IsCoprime.lean", "imports": ["Mathlib/RingTheory/Coprime/Lemmas.lean", "Mathlib/Tactic/NormNum/GCD.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Tactic.NormNum.int_not_isCoprime_helper", "code": "theorem int_not_isCoprime_helper (x y : \u2124) (d : \u2115) (hd : Int.gcd x y = d)\n    (h : Nat.beq d 1 = false) : \u00ac IsCoprime x y", "start": [23, 1], "end": [26, 33], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isInt_isCoprime", "code": "theorem isInt_isCoprime : {x y nx ny : \u2124} \u2192\n    IsInt x nx \u2192 IsInt y ny \u2192 IsCoprime nx ny \u2192 IsCoprime x y", "start": [28, 1], "end": [30, 37], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.isInt_not_isCoprime", "code": "theorem isInt_not_isCoprime : {x y nx ny : \u2124} \u2192\n    IsInt x nx \u2192 IsInt y ny \u2192 \u00ac IsCoprime nx ny \u2192 \u00ac IsCoprime x y", "start": [32, 1], "end": [34, 37], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveIntIsCoprime", "code": "def proveIntIsCoprime (ex ey : Q(\u2124)) : Q(IsCoprime $ex $ey) \u2295 Q(\u00ac IsCoprime $ex $ey) :=\n  let \u27e8ed, pf\u27e9 := proveIntGCD ex ey\n  if ed.natLit! = 1 then\n    have pf' : Q(Int.gcd $ex $ey = 1) := pf\n    Sum.inl q(Int.isCoprime_iff_gcd_eq_one.mpr $pf')\n  else\n    have h : Q(Nat.beq $ed 1 = false) := (q(Eq.refl false) : Expr)\n    Sum.inr q(int_not_isCoprime_helper $ex $ey $ed $pf $h)", "start": [36, 1], "end": [45, 59], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalIntIsCoprime", "code": "@[norm_num IsCoprime (_ : \u2124) (_ : \u2124)]\ndef evalIntIsCoprime : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app _ (x : Q(\u2124))) (y : Q(\u2124)) \u2190 Meta.whnfR e | failure\n  let \u27e8ex, p\u27e9 \u2190 deriveInt x _\n  let \u27e8ey, q\u27e9 \u2190 deriveInt y _\n  match proveIntIsCoprime ex ey with\n  | .inl pf =>\n    have pf' : Q(IsCoprime $x $y) := q(isInt_isCoprime $p $q $pf)\n    return .isTrue pf'\n  | .inr pf =>\n    have pf' : Q(\u00ac IsCoprime $x $y) := q(isInt_not_isCoprime $p $q $pf)\n    return .isFalse pf'", "start": [47, 1], "end": [59, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Explode.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Explode/Pretty.lean", "Mathlib/Tactic/Explode/Datatypes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Explode.ppConst", "code": "def ppConst (e : Expr) : MessageData :=\n  if not e.isConst then\n    panic! \"not a constant\"\n  else\n    .ofPPFormat { pp := fun\n      | some ctx => ctx.runMetaM <| withOptions (pp.tagAppFns.set \u00b7 true) <|\n          PrettyPrinter.ppExprWithInfos (delab := PrettyPrinter.Delaborator.delabConst) e\n      | none     => return f!\"{e}\" }", "start": [22, 1], "end": [35, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Explode.explodeCore", "code": "partial def explodeCore (e : Expr) (depth : Nat) (entries : Entries) (start : Bool := false) :\n    MetaM (Option Entry \u00d7 Entries) := do\n  trace[explode] \"depth = {depth}, start = {start}, e = {e}\"\n  let e := e.cleanupAnnotations\n  if let some entry := entries.find? e then\n    trace[explode] \"already seen\"\n    return (entry, entries)\n  if !(\u2190 select e) then\n    trace[explode] \"filtered out\"\n    return (none, entries)\n  match e with\n  | .lam .. => do\n    trace[explode] \".lam\"\n    Meta.lambdaTelescope e fun args body => do\n      let mut entries' := entries\n      let mut rdeps := []\n      for arg in args, i in [0:args.size] do\n        let (argEntry, entries'') := entries'.add arg\n          { type     := \u2190 addMessageContext <| \u2190 Meta.inferType arg\n            depth    := depth\n            status   :=\n              if start\n              then Status.sintro\n              else if i == 0 then Status.intro else Status.cintro\n            thm      := \u2190 addMessageContext <| arg\n            deps     := []\n            useAsDep := \u2190 select arg }\n        entries' := entries''\n        rdeps := some argEntry.line! :: rdeps\n      let (bodyEntry?, entries) \u2190\n        explodeCore body (if start then depth else depth + 1) entries'\n      rdeps := consDep bodyEntry? rdeps\n      let (entry, entries) := entries.add e\n        { type     := \u2190 addMessageContext <| \u2190 Meta.inferType e\n          depth    := depth\n          status   := Status.lam\n          thm      := \"\u2200I\" deps     := rdeps.reverse\n          useAsDep := true }\n      return (entry, entries)\n  | .app .. => do\n    trace[explode] \".app\"\n\n    let fn := e.getAppFn\n    let args := e.getAppArgs\n\n    let (fnEntry?, entries) \u2190\n      if fn.isConst then\n        pure (none, entries)\n      else\n        explodeCore fn depth entries\n    let deps := if fn.isConst then [] else consDep fnEntry? []\n\n    let mut entries' := entries\n    let mut rdeps := []\n    for arg in args do\n      let (appEntry?, entries'') \u2190 explodeCore arg depth entries'\n      entries' := entries''\n      rdeps := consDep appEntry? rdeps\n    let deps := deps ++ rdeps.reverse\n\n    let (entry, entries) := entries'.add e\n      { type     := \u2190 addMessageContext <| \u2190 Meta.inferType e\n        depth    := depth\n        status   := Status.reg\n        thm      := \u2190 addMessageContext <| if fn.isConst then ppConst fn else \"\u2200E\"\n        deps     := deps\n        useAsDep := true }\n    return (entry, entries)\n  | .letE varName varType val body _ => do\n    trace[explode] \".letE\"\n    let varType := varType.cleanupAnnotations\n    Meta.withLocalDeclD varName varType fun var => do\n      let (valEntry?, entries) \u2190 explodeCore val depth entries\n      let entries := valEntry?.map (entries.addSynonym var) |>.getD entries\n      explodeCore (body.instantiate1 var) depth entries\n  | _ => do\n    trace[explode] \".{e.ctorName} (default handler)\"\n    let (entry, entries) := entries.add e\n      { type     := \u2190 addMessageContext <| \u2190 Meta.inferType e\n        depth    := depth\n        status   := Status.reg\n        thm      := \u2190 addMessageContext e\n        deps     := []\n        useAsDep := \u2190 select e }\n    return (entry, entries)\nwhere\n  \n  consDep (entry? : Option Entry) (deps : List (Option Nat)) : List (Option Nat) :=\n    if let some entry := entry? then\n      if includeAllDeps || entry.useAsDep then entry.line! :: deps else deps\n    else\n      deps", "start": [38, 1], "end": [152, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Explode.explode", "code": "def explode (e : Expr) (filterProofs : Bool := true) : MetaM Entries := do\n  let filter (e : Expr) : MetaM Bool :=\n    if filterProofs then Meta.isProof e else return true\n  let (_, entries) \u2190 explodeCore (start := true) filter false e 0 default\n  return entries", "start": [154, 1], "end": [159, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/LiftLets.lean", "imports": ["Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.LiftLetsConfig", "code": "structure Lean.Expr.LiftLetsConfig where\n  \n  proofs : Bool := false\n  \n  merge : Bool := true", "start": [17, 1], "end": [24, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.liftLetsAux", "code": "private partial def Lean.Expr.liftLetsAux (config : LiftLetsConfig) (e : Expr) (fvars : Array Expr)\n    (f : Array Expr \u2192 Expr \u2192 MetaM Expr) : MetaM Expr := do\n  if (e.find? Expr.isLet).isNone then\n    return \u2190 f fvars e\n  if !config.proofs then\n    if \u2190 Meta.isProof e then\n      return \u2190 f fvars e\n  match e with\n  | .letE n t v b _ =>\n    t.liftLetsAux config fvars fun fvars t' =>\n      v.liftLetsAux config fvars fun fvars v' => do\n        if config.merge then\n          let fvar? \u2190 fvars.findM? (fun fvar => do\n            let decl \u2190 fvar.fvarId!.getDecl\n            return decl.type == t' && decl.value? == some v')\n          if let some fvar' := fvar? then\n            return \u2190 (b.instantiate1 fvar').liftLetsAux config fvars f\n        withLetDecl n t' v' fun fvar =>\n          (b.instantiate1 fvar).liftLetsAux config (fvars.push fvar) f\n  | .app x y =>\n    x.liftLetsAux config fvars fun fvars x' => y.liftLetsAux config fvars fun fvars y' =>\n      f fvars (.app x' y')\n  | .proj n idx s =>\n    s.liftLetsAux config fvars fun fvars s' => f fvars (.proj n idx s')\n  | .lam n t b i =>\n    t.liftLetsAux config fvars fun fvars t => do\n      let e' \u2190 withLocalDecl n i t fun fvar => do\n        (b.instantiate1 fvar).liftLetsAux config fvars fun fvars2 b => do\n          let deps \u2190 collectForwardDeps #[fvar] false\n          let fvars2 := fvars2[fvars.size:].toArray\n          let (fvars2, fvars2') := fvars2.partition deps.contains\n          mkLetFVars fvars2' (\u2190 mkLambdaFVars #[fvar] (\u2190 mkLetFVars fvars2 b))\n      insideLets e' fvars fun fvars e'' => f fvars e''\n  | .forallE n t b i =>\n    t.liftLetsAux config fvars fun fvars t => do\n      let e' \u2190 withLocalDecl n i t fun fvar => do\n        (b.instantiate1 fvar).liftLetsAux config fvars fun fvars2 b => do\n          let deps \u2190 collectForwardDeps #[fvar] false\n          let fvars2 := fvars2[fvars.size:].toArray\n          let (fvars2, fvars2') := fvars2.partition deps.contains\n          mkLetFVars fvars2' (\u2190 mkForallFVars #[fvar] (\u2190 mkLetFVars fvars2 b))\n      insideLets e' fvars fun fvars e'' => f fvars e''\n  | .mdata _ e => e.liftLetsAux config fvars f\n  | _ => f fvars e\nwhere\n  insideLets {\u03b1} (e : Expr) (fvars : Array Expr) (f : Array Expr \u2192 Expr \u2192 MetaM \u03b1) : MetaM \u03b1 := do\n    match e with\n    | .letE n t v b _ =>\n      withLetDecl n t v fun fvar => insideLets (b.instantiate1 fvar) (fvars.push fvar) f\n    | _ => f fvars e", "start": [26, 1], "end": [88, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.liftLets", "code": "def Lean.Expr.liftLets (e : Expr) (f : Array Expr \u2192 Expr \u2192 MetaM Expr)\n    (config : LiftLetsConfig := {}) : MetaM Expr :=\n  e.liftLetsAux config #[] f", "start": [90, 1], "end": [99, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/BigOperators.lean", "imports": ["Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/List/FinRange.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.Nat.UnifyZeroOrSuccResult", "code": "inductive Nat.UnifyZeroOrSuccResult (n : Q(\u2115))\n  \n  | zero (pf : $n =Q 0)\n  \n  | succ (n' : Q(\u2115)) (pf : $n =Q Nat.succ $n')", "start": [49, 1], "end": [55, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Nat.unifyZeroOrSucc", "code": "def Nat.unifyZeroOrSucc (n : Q(\u2115)) : MetaM (Nat.UnifyZeroOrSuccResult n) := do\n  match \u2190 isDefEqQ n q(0) with\n  | .defEq pf => return .zero pf\n  | .notDefEq => do\n    let n' : Q(\u2115) \u2190 mkFreshExprMVar q(\u2115)\n    let \u27e8(_pf : $n =Q Nat.succ $n')\u27e9 \u2190 assertDefEqQ n q(Nat.succ $n')\n    let (.some (n'_val : Q(\u2115))) \u2190 getExprMVarAssignment? n'.mvarId! |\n      throwError \"could not figure out value of `?n` from `{n} =?= Nat.succ ?n`\"\n    pure (.succ n'_val \u27e8\u27e9)", "start": [57, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.List.ProveNilOrConsResult", "code": "inductive List.ProveNilOrConsResult {\u03b1 : Q(Type u)} (s : Q(List $\u03b1))\n  \n  | nil (pf : Q($s = []))\n  \n  | cons (a : Q($\u03b1)) (s' : Q(List $\u03b1)) (pf : Q($s = List.cons $a $s'))", "start": [74, 1], "end": [80, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.List.ProveNilOrConsResult.uncheckedCast", "code": "def List.ProveNilOrConsResult.uncheckedCast {\u03b1 : Q(Type u)} {\u03b2 : Q(Type v)}\n    (s : Q(List $\u03b1)) (t : Q(List $\u03b2)) :\n    List.ProveNilOrConsResult s \u2192 List.ProveNilOrConsResult t\n  | .nil pf => .nil pf\n  | .cons a s' pf => .cons a s' pf", "start": [82, 1], "end": [90, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.List.ProveNilOrConsResult.eq_trans", "code": "def List.ProveNilOrConsResult.eq_trans {\u03b1 : Q(Type u)} {s t : Q(List $\u03b1)}\n    (eq : Q($s = $t)) :\n    List.ProveNilOrConsResult t \u2192 List.ProveNilOrConsResult s\n  | .nil pf => .nil q(Eq.trans $eq $pf)\n  | .cons a s' pf => .cons a s' q(Eq.trans $eq $pf)", "start": [92, 1], "end": [98, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.List.range_zero'", "code": "lemma List.range_zero' {n : \u2115} (pn : NormNum.IsNat n 0) :\n    List.range n = [] := by rw [pn.out, Nat.cast_zero, List.range_zero]", "start": [100, 1], "end": [101, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.List.range_succ_eq_map'", "code": "lemma List.range_succ_eq_map' {n nn n' : \u2115} (pn : NormNum.IsNat n nn) (pn' : nn = Nat.succ n') :\n    List.range n = 0 :: List.map Nat.succ (List.range n') := by\n  rw [pn.out, Nat.cast_id, pn', List.range_succ_eq_map]", "start": [103, 1], "end": [105, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.List.proveNilOrCons", "code": "partial def List.proveNilOrCons {\u03b1 : Q(Type u)} (s : Q(List $\u03b1)) :\n    MetaM (List.ProveNilOrConsResult s) :=\n  s.withApp fun e a =>\n  match (e, e.constName, a) with\n  | (_, ``EmptyCollection.emptyCollection, _) => haveI : $s =Q {} := \u27e8\u27e9; pure (.nil q(.refl []))\n  | (_, ``List.nil, _) => haveI : $s =Q [] := \u27e8\u27e9; pure (.nil q(rfl))\n  | (_, ``List.cons, #[_, (a : Q($\u03b1)), (s' : Q(List $\u03b1))]) =>\n    haveI : $s =Q $a :: $s' := \u27e8\u27e9; pure (.cons a s' q(rfl))\n  | (_, ``List.range, #[(n : Q(\u2115))]) =>\n    have s : Q(List \u2115) := s; .uncheckedCast _ _ <$> show MetaM (ProveNilOrConsResult s) from do\n    let \u27e8nn, pn\u27e9 \u2190 NormNum.deriveNat n _\n    haveI' : $s =Q .range $n := \u27e8\u27e9\n    let nnL := nn.natLit!\n    if nnL = 0 then\n      haveI' : $nn =Q 0 := \u27e8\u27e9\n      return .nil q(List.range_zero' $pn)\n    else\n      have n' : Q(\u2115) := mkRawNatLit (nnL - 1)\n      have : $nn =Q .succ $n' := \u27e8\u27e9\n      return .cons _ _ q(List.range_succ_eq_map' $pn (.refl $nn))\n  | (_, ``List.finRange, #[(n : Q(\u2115))]) =>\n    have s : Q(List (Fin $n)) := s\n    .uncheckedCast _ _ <$> show MetaM (ProveNilOrConsResult s) from do\n    haveI' : $s =Q .finRange $n := \u27e8\u27e9\n    return match \u2190 Nat.unifyZeroOrSucc n with | .zero _pf => .nil q(List.finRange_zero)\n    | .succ n' _pf => .cons _ _ q(List.finRange_succ_eq_map $n')\n  | (.const ``List.map [v, _], _, #[(\u03b2 : Q(Type v)), _, (f : Q($\u03b2 \u2192 $\u03b1)), (xxs : Q(List $\u03b2))]) => do\n    haveI' : $s =Q ($xxs).map $f := \u27e8\u27e9\n    return match \u2190 List.proveNilOrCons xxs with\n    | .nil pf => .nil q(($pf \u25b8 List.map_nil : List.map _ _ = _))\n    | .cons x xs pf => .cons q($f $x) q(($xs).map $f)\n      q(($pf \u25b8 List.map_cons $f $x $xs : List.map _ _ = _))\n  | (_, fn, args) =>\n    throwError \"List.proveNilOrCons: unsupported List expression {s} ({fn}, {args})\"", "start": [108, 1], "end": [146, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Multiset.ProveZeroOrConsResult", "code": "inductive Multiset.ProveZeroOrConsResult {\u03b1 : Q(Type u)} (s : Q(Multiset $\u03b1))\n  \n  | zero (pf : Q($s = 0))\n  \n  | cons (a : Q($\u03b1)) (s' : Q(Multiset $\u03b1)) (pf : Q($s = Multiset.cons $a $s'))", "start": [148, 1], "end": [154, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Multiset.ProveZeroOrConsResult.uncheckedCast", "code": "def Multiset.ProveZeroOrConsResult.uncheckedCast {\u03b1 : Q(Type u)} {\u03b2 : Q(Type v)}\n    (s : Q(Multiset $\u03b1)) (t : Q(Multiset $\u03b2)) :\n    Multiset.ProveZeroOrConsResult s \u2192 Multiset.ProveZeroOrConsResult t\n  | .zero pf => .zero pf\n  | .cons a s' pf => .cons a s' pf", "start": [156, 1], "end": [164, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Multiset.ProveZeroOrConsResult.eq_trans", "code": "def Multiset.ProveZeroOrConsResult.eq_trans {\u03b1 : Q(Type u)} {s t : Q(Multiset $\u03b1)}\n    (eq : Q($s = $t)) :\n    Multiset.ProveZeroOrConsResult t \u2192 Multiset.ProveZeroOrConsResult s\n  | .zero pf => .zero q(Eq.trans $eq $pf)\n  | .cons a s' pf => .cons a s' q(Eq.trans $eq $pf)", "start": [166, 1], "end": [172, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Multiset.insert_eq_cons", "code": "lemma Multiset.insert_eq_cons {\u03b1 : Type*} [DecidableEq \u03b1] (a : \u03b1) (s : Multiset \u03b1) :\n    insert a s = Multiset.cons a s := by\n  ext; simp", "start": [174, 1], "end": [176, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Multiset.range_zero'", "code": "lemma Multiset.range_zero' {n : \u2115} (pn : NormNum.IsNat n 0) :\n    Multiset.range n = 0 := by rw [pn.out, Nat.cast_zero, Multiset.range_zero]", "start": [178, 1], "end": [179, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Multiset.range_succ'", "code": "lemma Multiset.range_succ' {n nn n' : \u2115} (pn : NormNum.IsNat n nn) (pn' : nn = Nat.succ n') :\n    Multiset.range n = n' ::\u2098 Multiset.range n' := by\n  rw [pn.out, Nat.cast_id, pn', Multiset.range_succ]", "start": [181, 1], "end": [183, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Multiset.proveZeroOrCons", "code": "partial def Multiset.proveZeroOrCons {\u03b1 : Q(Type u)} (s : Q(Multiset $\u03b1)) :\n    MetaM (Multiset.ProveZeroOrConsResult s) :=\n  match s.getAppFnArgs with\n  | (``EmptyCollection.emptyCollection, _) => haveI : $s =Q {} := \u27e8\u27e9; pure (.zero q(rfl))\n  | (``Zero.zero, _) => haveI : $s =Q 0 := \u27e8\u27e9; pure (.zero q(rfl))\n  | (``Multiset.cons, #[_, (a : Q($\u03b1)), (s' : Q(Multiset $\u03b1))]) =>\n    haveI : $s =Q .cons $a $s' := \u27e8\u27e9\n    pure (.cons a s' q(rfl))\n  | (``Multiset.ofList, #[_, (val : Q(List $\u03b1))]) => do\n    haveI : $s =Q .ofList $val := \u27e8\u27e9\n    return match \u2190 List.proveNilOrCons val with\n    | .nil pf => .zero q($pf \u25b8 Multiset.coe_nil : Multiset.ofList _ = _)\n    | .cons a s' pf => .cons a q($s') q($pf \u25b8 Multiset.cons_coe $a $s' : Multiset.ofList _ = _)\n  | (``Multiset.range, #[(n : Q(\u2115))]) => do\n    have s : Q(Multiset \u2115) := s; .uncheckedCast _ _ <$> show MetaM (ProveZeroOrConsResult s) from do\n    let \u27e8nn, pn\u27e9 \u2190 NormNum.deriveNat n _\n    haveI' : $s =Q .range $n := \u27e8\u27e9\n    let nnL := nn.natLit!\n    if nnL = 0 then\n      haveI' : $nn =Q 0 := \u27e8\u27e9\n      return .zero q(Multiset.range_zero' $pn)\n    else\n      have n' : Q(\u2115) := mkRawNatLit (nnL - 1)\n      haveI' : $nn =Q ($n').succ := \u27e8\u27e9\n      return .cons _ _ q(Multiset.range_succ' $pn rfl)\n  | (fn, args) =>\n    throwError \"Multiset.proveZeroOrCons: unsupported multiset expression {s} ({fn}, {args})\"", "start": [185, 1], "end": [215, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Finset.ProveEmptyOrConsResult", "code": "inductive Finset.ProveEmptyOrConsResult {\u03b1 : Q(Type u)} (s : Q(Finset $\u03b1))\n  \n  | empty (pf : Q($s = \u2205))\n  \n  | cons (a : Q($\u03b1)) (s' : Q(Finset $\u03b1)) (h : Q($a \u2209 $s')) (pf : Q($s = Finset.cons $a $s' $h))", "start": [217, 1], "end": [223, 96], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Finset.ProveEmptyOrConsResult.uncheckedCast", "code": "def Finset.ProveEmptyOrConsResult.uncheckedCast {\u03b1 : Q(Type u)} {\u03b2 : Q(Type v)}\n    (s : Q(Finset $\u03b1)) (t : Q(Finset $\u03b2)) :\n    Finset.ProveEmptyOrConsResult s \u2192 Finset.ProveEmptyOrConsResult t\n  | .empty pf => .empty pf\n  | .cons a s' h pf => .cons a s' h pf", "start": [225, 1], "end": [233, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Finset.ProveEmptyOrConsResult.eq_trans", "code": "def Finset.ProveEmptyOrConsResult.eq_trans {\u03b1 : Q(Type u)} {s t : Q(Finset $\u03b1)}\n    (eq : Q($s = $t)) :\n    Finset.ProveEmptyOrConsResult t \u2192 Finset.ProveEmptyOrConsResult s\n  | .empty pf => .empty q(Eq.trans $eq $pf)\n  | .cons a s' h pf => .cons a s' h q(Eq.trans $eq $pf)", "start": [235, 1], "end": [241, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Finset.insert_eq_cons", "code": "lemma Finset.insert_eq_cons {\u03b1 : Type*} [DecidableEq \u03b1] (a : \u03b1) (s : Finset \u03b1) (h : a \u2209 s) :\n    insert a s = Finset.cons a s h := by\n  ext; simp", "start": [243, 1], "end": [245, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Finset.range_zero'", "code": "lemma Finset.range_zero' {n : \u2115} (pn : NormNum.IsNat n 0) :\n    Finset.range n = {} := by rw [pn.out, Nat.cast_zero, Finset.range_zero]", "start": [247, 1], "end": [248, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Finset.range_succ'", "code": "lemma Finset.range_succ' {n nn n' : \u2115} (pn : NormNum.IsNat n nn) (pn' : nn = Nat.succ n') :\n    Finset.range n = Finset.cons n' (Finset.range n') Finset.not_mem_range_self := by\n  rw [pn.out, Nat.cast_id, pn', Finset.range_succ, Finset.insert_eq_cons]", "start": [250, 1], "end": [252, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Finset.univ_eq_elems", "code": "lemma Finset.univ_eq_elems {\u03b1 : Type*} [Fintype \u03b1] (elems : Finset \u03b1)\n    (complete : \u2200 x : \u03b1, x \u2208 elems) :\n    Finset.univ = elems := by\n  ext x; simpa using complete x", "start": [254, 1], "end": [257, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Finset.proveEmptyOrCons", "code": "partial def Finset.proveEmptyOrCons {\u03b1 : Q(Type u)} (s : Q(Finset $\u03b1)) :\n    MetaM (ProveEmptyOrConsResult s) :=\n  match s.getAppFnArgs with\n  | (``EmptyCollection.emptyCollection, _) => haveI : $s =Q {} := \u27e8\u27e9; pure (.empty q(rfl))\n  | (``Finset.cons, #[_, (a : Q($\u03b1)), (s' : Q(Finset $\u03b1)), (h : Q(\u00ac $a \u2208 $s'))]) =>\n    haveI : $s =Q .cons $a $s' $h := \u27e8\u27e9\n    pure (.cons a s' h q(.refl $s))\n  | (``Finset.mk, #[_, (val : Q(Multiset $\u03b1)), (nd : Q(Multiset.Nodup $val))]) => do\n    match \u2190 Multiset.proveZeroOrCons val with\n    | .zero pf => pure <| .empty (q($pf \u25b8 Finset.mk_zero) : Q(Finset.mk $val $nd = \u2205))\n    | .cons a s' pf => do\n      let h : Q(Multiset.Nodup ($a ::\u2098 $s')) := q($pf \u25b8 $nd)\n      let nd' : Q(Multiset.Nodup $s') := q((Multiset.nodup_cons.mp $h).2)\n      let h' : Q($a \u2209 $s') := q((Multiset.nodup_cons.mp $h).1)\n      return (.cons a q(Finset.mk $s' $nd') h'\n        (q($pf \u25b8 Finset.mk_cons $h) : Q(Finset.mk $val $nd = Finset.cons $a \u27e8$s', $nd'\u27e9 $h')))\n  | (``Finset.range, #[(n : Q(\u2115))]) =>\n    have s : Q(Finset \u2115) := s; .uncheckedCast _ _ <$> show MetaM (ProveEmptyOrConsResult s) from do\n    let \u27e8nn, pn\u27e9 \u2190 NormNum.deriveNat n _\n    haveI' : $s =Q .range $n := \u27e8\u27e9\n    let nnL := nn.natLit!\n    if nnL = 0 then\n      haveI : $nn =Q 0 := \u27e8\u27e9\n      return .empty q(Finset.range_zero' $pn)\n    else\n      have n' : Q(\u2115) := mkRawNatLit (nnL - 1)\n      haveI' : $nn =Q ($n').succ := \u27e8\u27e9\n      return .cons n' _ _ q(Finset.range_succ' $pn (.refl $nn))\n  | (``Finset.univ, #[_, (instFT : Q(Fintype $\u03b1))]) => do\n    haveI' : $s =Q .univ := \u27e8\u27e9\n    match (\u2190 whnfI instFT).getAppFnArgs with\n    | (``Fintype.mk, #[_, (elems : Q(Finset $\u03b1)), (complete : Q(\u2200 x : $\u03b1, x \u2208 $elems))]) => do\n      let res \u2190 Finset.proveEmptyOrCons elems\n      pure <| res.eq_trans q(Finset.univ_eq_elems $elems $complete)\n    | e =>\n      throwError \"Finset.proveEmptyOrCons: could not determine elements of Fintype instance {e}\"\n  | (fn, args) =>\n    throwError \"Finset.proveEmptyOrCons: unsupported finset expression {s} ({fn}, {args})\"", "start": [259, 1], "end": [300, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.eq_trans", "code": "def Result.eq_trans {\u03b1 : Q(Type u)} {a b : Q($\u03b1)} (eq : Q($a = $b)) : Result b \u2192 Result a\n  | .isBool true proof =>\n    have a : Q(Prop) := a\n    have b : Q(Prop) := b\n    have eq : Q($a = $b) := eq\n    have proof : Q($b) := proof\n    Result.isTrue (x := a) q($eq \u25b8 $proof)\n  | .isBool false proof =>\n    have a : Q(Prop) := a\n    have b : Q(Prop) := b\n    have eq : Q($a = $b) := eq\n    have proof : Q(\u00ac $b) := proof\n  Result.isFalse (x := a) q($eq \u25b8 $proof)\n  | .isNat inst lit proof => Result.isNat inst lit q($eq \u25b8 $proof)\n  | .isNegNat inst lit proof => Result.isNegNat inst lit q($eq \u25b8 $proof)\n  | .isRat inst q n d proof => Result.isRat inst q n d q($eq \u25b8 $proof)", "start": [304, 1], "end": [320, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Finset.sum_empty", "code": "protected lemma Finset.sum_empty {\u03b2 \u03b1 : Type*} [CommSemiring \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    IsNat (Finset.sum \u2205 f) 0 :=\n  \u27e8by simp\u27e9", "start": [322, 1], "end": [324, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.NormNum.Finset.prod_empty", "code": "protected lemma Finset.prod_empty {\u03b2 \u03b1 : Type*} [CommSemiring \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    IsNat (Finset.prod \u2205 f) 1 :=\n  \u27e8by simp\u27e9", "start": [326, 1], "end": [328, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.NormNum.evalFinsetBigop", "code": "partial def evalFinsetBigop {\u03b1 : Q(Type u)} {\u03b2 : Q(Type v)}\n    (op : Q(Finset $\u03b1 \u2192 ($\u03b1 \u2192 $\u03b2) \u2192 $\u03b2))\n    (f : Q($\u03b1 \u2192 $\u03b2))\n    (res_empty : Result q($op Finset.empty $f))\n    (res_cons : {a : Q($\u03b1)} -> {s' : Q(Finset $\u03b1)} -> {h : Q($a \u2209 $s')} ->\n      Result (\u03b1 := \u03b2) q($f $a) -> Result (\u03b1 := \u03b2) q($op $s' $f) ->\n      MetaM (Result (\u03b1 := \u03b2) q($op (Finset.cons $a $s' $h) $f))) :\n    (s : Q(Finset $\u03b1)) \u2192 MetaM (Result (\u03b1 := \u03b2) q($op $s $f))\n  | s => do\n    match \u2190 Finset.proveEmptyOrCons s with\n    | .empty pf => pure <| res_empty.eq_trans q(congr_fun (congr_arg _ $pf) _)\n    | .cons a s' h pf => do\n      let fa : Q($\u03b2) := Expr.app f a\n      let res_fa \u2190 derive fa\n      let res_op_s' : Result q($op $s' $f) \u2190 evalFinsetBigop op f res_empty @res_cons s'\n      let res \u2190 res_cons res_fa res_op_s'\n      let eq : Q($op $s $f = $op (Finset.cons $a $s' $h) $f) := q(congr_fun (congr_arg _ $pf) _)\n      pure (res.eq_trans eq)", "start": [330, 1], "end": [349, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalFinsetProd", "code": "@[norm_num @Finset.prod _ _ _ _ _]\npartial def evalFinsetProd : NormNumExt where eval {u \u03b2} e := do\n  let .app (.app (.app (.app (.app (.const `Finset.prod [_, v]) \u03b2') \u03b1) _) s) f \u2190\n    whnfR e | failure\n  guard <| \u2190withNewMCtxDepth <| isDefEq \u03b2 \u03b2'\n  have \u03b1 : Q(Type v) := \u03b1\n  have s : Q(Finset $\u03b1) := s\n  have f : Q($\u03b1 \u2192 $\u03b2) := f\n  let instCS : Q(CommSemiring $\u03b2) \u2190 synthInstanceQ q(CommSemiring $\u03b2) <|>\n    throwError \"not a commutative semiring: {\u03b2}\"\n  let instS : Q(Semiring $\u03b2) := q(CommSemiring.toSemiring)\n  let n : Q(\u2115) := .lit (.natVal 1)\n  let pf : Q(IsNat (Finset.prod \u2205 $f) $n) := q(@Finset.prod_empty $\u03b2 $\u03b1 $instCS $f)\n  let res_empty := Result.isNat _ n pf\n\n  evalFinsetBigop q(Finset.prod) f res_empty (fun {a s' h} res_fa res_prod_s' \u21a6 do\n      let fa : Q($\u03b2) := Expr.app f a\n      let res \u2190 evalMul.core q($fa * Finset.prod $s' $f) q(HMul.hMul) _ _ instS res_fa\n        res_prod_s'\n      let eq : Q(Finset.prod (Finset.cons $a $s' $h) $f = $fa * Finset.prod $s' $f) :=\n        q(Finset.prod_cons $h)\n      pure <| res.eq_trans eq)\n    s", "start": [351, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalFinsetSum", "code": "@[norm_num @Finset.sum _ _ _ _ _]\npartial def evalFinsetSum : NormNumExt where eval {u \u03b2} e := do\n  let .app (.app (.app (.app (.app (.const `Finset.sum [_, v]) \u03b2') \u03b1) _) s) f \u2190\n    whnfR e | failure\n  guard <| \u2190withNewMCtxDepth <| isDefEq \u03b2 \u03b2'\n  have \u03b1 : Q(Type v) := \u03b1\n  have s : Q(Finset $\u03b1) := s\n  have f : Q($\u03b1 \u2192 $\u03b2) := f\n  let instCS : Q(CommSemiring $\u03b2) \u2190 synthInstanceQ q(CommSemiring $\u03b2) <|>\n    throwError \"not a commutative semiring: {\u03b2}\"\n  let n : Q(\u2115) := mkRawNatLit 0\n  let pf : Q(IsNat (Finset.sum \u2205 $f) $n) := q(@Finset.sum_empty $\u03b2 $\u03b1 $instCS $f)\n  let res_empty := Result.isNat _ n pf\n\n  evalFinsetBigop q(Finset.sum) f res_empty (fun {a s' h} res_fa res_sum_s' \u21a6 do\n      let fa : Q($\u03b2) := Expr.app f a\n      let res \u2190 evalAdd.core q($fa + Finset.sum $s' $f) q(HAdd.hAdd) _ _ res_fa res_sum_s'\n      let eq : Q(Finset.sum (Finset.cons $a $s' $h) $f = $fa + Finset.sum $s' $f) :=\n        q(Finset.sum_cons $h)\n      pure <| res.eq_trans eq)\n    s", "start": [380, 1], "end": [404, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/LegendreSymbol.lean", "imports": ["Mathlib/NumberTheory/LegendreSymbol/JacobiSymbol.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.jacobiSymNat", "code": "def jacobiSymNat (a b : \u2115) : \u2124 :=\n  jacobiSym a b", "start": [54, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.zero_right", "code": "theorem jacobiSymNat.zero_right (a : \u2115) : jacobiSymNat a 0 = 1", "start": [67, 1], "end": [69, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.one_right", "code": "theorem jacobiSymNat.one_right (a : \u2115) : jacobiSymNat a 1 = 1", "start": [72, 1], "end": [73, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.zero_left", "code": "theorem jacobiSymNat.zero_left (b : \u2115) (hb : Nat.beq (b / 2) 0 = false) : jacobiSymNat 0 b = 0", "start": [76, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.one_left", "code": "theorem jacobiSymNat.one_left (b : \u2115) : jacobiSymNat 1 b = 1", "start": [87, 1], "end": [88, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.LegendreSym.to_jacobiSym", "code": "theorem LegendreSym.to_jacobiSym (p : \u2115) (pp : Fact p.Prime) (a r : \u2124)\n    (hr : IsInt (jacobiSym a p) r) : IsInt (legendreSym p a) r", "start": [92, 1], "end": [95, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.JacobiSym.mod_left", "code": "theorem JacobiSym.mod_left (a : \u2124) (b ab' : \u2115) (ab r b' : \u2124) (hb' : (b : \u2124) = b')\n    (hab : a % b' = ab) (h : (ab' : \u2124) = ab) (hr : jacobiSymNat ab' b = r) : jacobiSym a b = r", "start": [98, 1], "end": [101, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.mod_left", "code": "theorem jacobiSymNat.mod_left (a b ab : \u2115) (r : \u2124) (hab : a % b = ab) (hr : jacobiSymNat ab b = r) :\n    jacobiSymNat a b = r", "start": [104, 1], "end": [106, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_even", "code": "theorem jacobiSymNat.even_even (a b : \u2115) (hb\u2080 : Nat.beq (b / 2) 0 = false) (ha : a % 2 = 0)\n    (hb\u2081 : b % 2 = 0) : jacobiSymNat a b = 0", "start": [109, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.odd_even", "code": "theorem jacobiSymNat.odd_even (a b c : \u2115) (r : \u2124) (ha : a % 2 = 1) (hb : b % 2 = 0) (hc : b / 2 = c)\n    (hr : jacobiSymNat a c = r) :\n    jacobiSymNat a b = r", "start": [121, 1], "end": [132, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.double_even", "code": "theorem jacobiSymNat.double_even (a b c : \u2115) (r : \u2124) (ha : a % 4 = 0) (hb : b % 2 = 1)\n    (hc : a / 4 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = r", "start": [135, 1], "end": [141, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_odd\u2081", "code": "theorem jacobiSymNat.even_odd\u2081 (a b c : \u2115) (r : \u2124) (ha : a % 2 = 0) (hb : b % 8 = 1)\n    (hc : a / 2 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = r", "start": [144, 1], "end": [155, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_odd\u2087", "code": "theorem jacobiSymNat.even_odd\u2087 (a b c : \u2115) (r : \u2124) (ha : a % 2 = 0) (hb : b % 8 = 7)\n    (hc : a / 2 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = r", "start": [158, 1], "end": [167, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_odd\u2083", "code": "theorem jacobiSymNat.even_odd\u2083 (a b c : \u2115) (r : \u2124) (ha : a % 2 = 0) (hb : b % 8 = 3)\n    (hc : a / 2 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = -r", "start": [170, 1], "end": [179, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.even_odd\u2085", "code": "theorem jacobiSymNat.even_odd\u2085 (a b c : \u2115) (r : \u2124) (ha : a % 2 = 0) (hb : b % 8 = 5)\n    (hc : a / 2 = c) (hr : jacobiSymNat c b = r) : jacobiSymNat a b = -r", "start": [182, 1], "end": [191, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2081", "code": "theorem jacobiSymNat.qr\u2081 (a b : \u2115) (r : \u2124) (ha : a % 4 = 1) (hb : b % 2 = 1)\n    (hr : jacobiSymNat b a = r) : jacobiSymNat a b = r", "start": [194, 1], "end": [197, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2081_mod", "code": "theorem jacobiSymNat.qr\u2081_mod (a b ab : \u2115) (r : \u2124) (ha : a % 4 = 1) (hb : b % 2 = 1)\n    (hab : b % a = ab) (hr : jacobiSymNat ab a = r) : jacobiSymNat a b = r", "start": [200, 1], "end": [202, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2081'", "code": "theorem jacobiSymNat.qr\u2081' (a b : \u2115) (r : \u2124) (ha : a % 2 = 1) (hb : b % 4 = 1)\n    (hr : jacobiSymNat b a = r) : jacobiSymNat a b = r", "start": [205, 1], "end": [207, 93], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2081'_mod", "code": "theorem jacobiSymNat.qr\u2081'_mod (a b ab : \u2115) (r : \u2124) (ha : a % 2 = 1) (hb : b % 4 = 1)\n    (hab : b % a = ab) (hr : jacobiSymNat ab a = r) : jacobiSymNat a b = r", "start": [210, 1], "end": [212, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2083", "code": "theorem jacobiSymNat.qr\u2083 (a b : \u2115) (r : \u2124) (ha : a % 4 = 3) (hb : b % 4 = 3)\n    (hr : jacobiSymNat b a = r) : jacobiSymNat a b = -r", "start": [215, 1], "end": [217, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.jacobiSymNat.qr\u2083_mod", "code": "theorem jacobiSymNat.qr\u2083_mod (a b ab : \u2115) (r : \u2124) (ha : a % 4 = 3) (hb : b % 4 = 3)\n    (hab : b % a = ab) (hr : jacobiSymNat ab a = r) : jacobiSymNat a b = -r", "start": [220, 1], "end": [222, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_jacobiSym", "code": "theorem isInt_jacobiSym : {a na : \u2124} \u2192 {b nb : \u2115} \u2192 {r : \u2124} \u2192\n    IsInt a na \u2192 IsNat b nb \u2192 jacobiSym na nb = r \u2192 IsInt (jacobiSym a b) r", "start": [225, 1], "end": [227, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_jacobiSymNat", "code": "theorem isInt_jacobiSymNat : {a na : \u2115} \u2192 {b nb : \u2115} \u2192 {r : \u2124} \u2192\n    IsNat a na \u2192 IsNat b nb \u2192 jacobiSymNat na nb = r \u2192 IsInt (jacobiSymNat a b) r", "start": [229, 1], "end": [231, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.proveJacobiSymOdd", "code": "partial def proveJacobiSymOdd (ea eb : Q(\u2115)) : (er : Q(\u2124)) \u00d7 Q(jacobiSymNat $ea $eb = $er) :=\n  match eb.natLit! with\n  | 1 =>\n    haveI : $eb =Q 1 := \u27e8\u27e9\n    \u27e8mkRawIntLit 1, q(jacobiSymNat.one_right $ea)\u27e9\n  | b =>\n    match ea.natLit! with\n    | 0 =>\n      haveI : $ea =Q 0 := \u27e8\u27e9\n      have hb : Q(Nat.beq ($eb / 2) 0 = false) := (q(Eq.refl false) : Expr)\n      \u27e8mkRawIntLit 0, q(jacobiSymNat.zero_left $eb $hb)\u27e9\n    | 1 =>\n      haveI : $ea =Q 1 := \u27e8\u27e9\n      \u27e8mkRawIntLit 1, q(jacobiSymNat.one_left $eb)\u27e9\n    | a =>\n      match a % 2 with\n      | 0 =>\n        match a % 4 with\n        | 0 =>\n          have ha : Q(Nat.mod $ea 4 = 0) := (q(Eq.refl 0) : Expr)\n          have hb : Q(Nat.mod $eb 2 = 1) := (q(Eq.refl 1) : Expr)\n          have ec : Q(\u2115) := mkRawNatLit (a / 4)\n          have hc : Q(Nat.div $ea 4 = $ec) := (q(Eq.refl $ec) : Expr)\n          have \u27e8er, p\u27e9 := proveJacobiSymOdd ec eb\n          \u27e8er, q(jacobiSymNat.double_even $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n        | _ =>\n          have ha : Q(Nat.mod $ea 2 = 0) := (q(Eq.refl 0) : Expr)\n          have ec : Q(\u2115) := mkRawNatLit (a / 2)\n          have hc : Q(Nat.div $ea 2 = $ec) := (q(Eq.refl $ec) : Expr)\n          have \u27e8er, p\u27e9 := proveJacobiSymOdd ec eb\n          match b % 8 with\n          | 1 =>\n            have hb : Q(Nat.mod $eb 8 = 1) := (q(Eq.refl 1) : Expr)\n            \u27e8er, q(jacobiSymNat.even_odd\u2081 $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n          | 3 =>\n            have er' := mkRawIntLit (-er.intLit!)\n            have hb : Q(Nat.mod $eb 8 = 3) := (q(Eq.refl 3) : Expr)\n            show (_ : Q(\u2124)) \u00d7 Q(jacobiSymNat $ea $eb = -$er) from\n              \u27e8er', q(jacobiSymNat.even_odd\u2083 $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n          | 5 =>\n            have er' := mkRawIntLit (-er.intLit!)\n            haveI : $er' =Q -$er := \u27e8\u27e9\n            have hb : Q(Nat.mod $eb 8 = 5) := (q(Eq.refl 5) : Expr)\n            \u27e8er', q(jacobiSymNat.even_odd\u2085 $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n          | _ =>\n            have hb : Q(Nat.mod $eb 8 = 7) := (q(Eq.refl 7) : Expr)\n            \u27e8er, q(jacobiSymNat.even_odd\u2087 $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n      | _ =>\n        have eab : Q(\u2115) := mkRawNatLit (b % a)\n        have hab : Q(Nat.mod $eb $ea = $eab) := (q(Eq.refl $eab) : Expr)\n        have \u27e8er, p\u27e9 := proveJacobiSymOdd eab ea\n        match a % 4 with\n        | 1 =>\n          have ha : Q(Nat.mod $ea 4 = 1) := (q(Eq.refl 1) : Expr)\n          have hb : Q(Nat.mod $eb 2 = 1) := (q(Eq.refl 1) : Expr)\n          \u27e8er, q(jacobiSymNat.qr\u2081_mod $ea $eb $eab $er $ha $hb $hab $p)\u27e9\n        | _ =>\n          match b % 4 with\n          | 1 =>\n            have ha : Q(Nat.mod $ea 2 = 1) := (q(Eq.refl 1) : Expr)\n            have hb : Q(Nat.mod $eb 4 = 1) := (q(Eq.refl 1) : Expr)\n            \u27e8er, q(jacobiSymNat.qr\u2081'_mod $ea $eb $eab $er $ha $hb $hab $p)\u27e9\n          | _ =>\n            have er' := mkRawIntLit (-er.intLit!)\n            haveI : $er' =Q -$er := \u27e8\u27e9\n            have ha : Q(Nat.mod $ea 4 = 3) := (q(Eq.refl 3) : Expr)\n            have hb : Q(Nat.mod $eb 4 = 3) := (q(Eq.refl 3) : Expr)\n            \u27e8er', q(jacobiSymNat.qr\u2083_mod $ea $eb $eab $er $ha $hb $hab $p)\u27e9", "start": [252, 1], "end": [321, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.proveJacobiSymNat", "code": "partial def proveJacobiSymNat (ea eb : Q(\u2115)) : (er : Q(\u2124)) \u00d7 Q(jacobiSymNat $ea $eb = $er) :=\n  match eb.natLit! with\n  | 0 =>\n    haveI : $eb =Q 0 := \u27e8\u27e9\n    \u27e8mkRawIntLit 1, q(jacobiSymNat.zero_right $ea)\u27e9\n  | 1 =>\n    haveI : $eb =Q 1 := \u27e8\u27e9\n    \u27e8mkRawIntLit 1, q(jacobiSymNat.one_right $ea)\u27e9\n  | b =>\n    match b % 2 with\n    | 0 =>\n      match ea.natLit! with\n      | 0 =>\n        have hb : Q(Nat.beq ($eb / 2) 0 = false) := (q(Eq.refl false) : Expr)\n        show (er : Q(\u2124)) \u00d7 Q(jacobiSymNat 0 $eb = $er) from\n          \u27e8mkRawIntLit 0, q(jacobiSymNat.zero_left $eb $hb)\u27e9\n      | 1 =>\n        show (er : Q(\u2124)) \u00d7 Q(jacobiSymNat 1 $eb = $er) from\n          \u27e8mkRawIntLit 1, q(jacobiSymNat.one_left $eb)\u27e9\n      | a =>\n        match a % 2 with\n        | 0 =>\n          have hb\u2080 : Q(Nat.beq ($eb / 2) 0 = false) := (q(Eq.refl false) : Expr)\n          have ha : Q(Nat.mod $ea 2 = 0) := (q(Eq.refl 0) : Expr)\n          have hb\u2081 : Q(Nat.mod $eb 2 = 0) := (q(Eq.refl 0) : Expr)\n          \u27e8mkRawIntLit 0, q(jacobiSymNat.even_even $ea $eb $hb\u2080 $ha $hb\u2081)\u27e9\n        | _ =>\n          have ha : Q(Nat.mod $ea 2 = 1) := (q(Eq.refl 1) : Expr)\n          have hb : Q(Nat.mod $eb 2 = 0) := (q(Eq.refl 0) : Expr)\n          have ec : Q(\u2115) := mkRawNatLit (b / 2)\n          have hc : Q(Nat.div $eb 2 = $ec) := (q(Eq.refl $ec) : Expr)\n          have \u27e8er, p\u27e9 := proveJacobiSymOdd ea ec\n          \u27e8er, q(jacobiSymNat.odd_even $ea $eb $ec $er $ha $hb $hc $p)\u27e9\n    | _ =>\n      have a := ea.natLit!\n      if b \u2264 a then\n        have eab : Q(\u2115) := mkRawNatLit (a % b)\n        have hab : Q(Nat.mod $ea $eb = $eab) := (q(Eq.refl $eab) : Expr)\n        have \u27e8er, p\u27e9 := proveJacobiSymOdd eab eb\n        \u27e8er, q(jacobiSymNat.mod_left $ea $eb $eab $er $hab $p)\u27e9\n      else\n        proveJacobiSymOdd ea eb", "start": [324, 1], "end": [367, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.proveJacobiSym", "code": "partial def proveJacobiSym (ea : Q(\u2124)) (eb : Q(\u2115)) : (er : Q(\u2124)) \u00d7 Q(jacobiSym $ea $eb = $er) :=\n  match eb.natLit! with\n  | 0 =>\n    haveI : $eb =Q 0 := \u27e8\u27e9\n    \u27e8mkRawIntLit 1, q(jacobiSym.zero_right $ea)\u27e9\n  | 1 =>\n    haveI : $eb =Q 1 := \u27e8\u27e9\n    \u27e8mkRawIntLit 1, q(jacobiSym.one_right $ea)\u27e9\n  | b =>\n    have eb' := mkRawIntLit b\n    have hb' : Q(($eb : \u2124) = $eb') := (q(Eq.refl $eb') : Expr)\n    have ab := ea.intLit! % b\n    have eab := mkRawIntLit ab\n    have hab : Q(Int.emod $ea $eb' = $eab) := (q(Eq.refl $eab) : Expr)\n    have eab' : Q(\u2115) := mkRawNatLit ab.toNat\n    have hab' : Q(($eab' : \u2124) = $eab) := (q(Eq.refl $eab) : Expr)\n    have \u27e8er, p\u27e9 := proveJacobiSymNat eab' eb\n    \u27e8er, q(JacobiSym.mod_left $ea $eb $eab' $eab $er $eb' $hb' $hab $hab' $p)\u27e9", "start": [370, 1], "end": [389, 79], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalJacobiSym", "code": "@[norm_num jacobiSym _ _]\ndef evalJacobiSym : NormNumExt where eval {u \u03b1} e := do\n    let .app (.app _ (a : Q(\u2124))) (b : Q(\u2115)) \u2190 Meta.whnfR e | failure\n    let \u27e8ea, pa\u27e9 \u2190 deriveInt a _\n    let \u27e8eb, pb\u27e9 \u2190 deriveNat b _\n    haveI' : u =QL 0 := \u27e8\u27e9 haveI' : $\u03b1 =Q \u2124 := \u27e8\u27e9\n    have \u27e8er, pr\u27e9 := proveJacobiSym ea eb\n    haveI' : $e =Q jacobiSym $a $b := \u27e8\u27e9\n    return .isInt _ er er.intLit! q(isInt_jacobiSym $pa $pb $pr)", "start": [409, 1], "end": [418, 65], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalJacobiSymNat", "code": "@[norm_num jacobiSymNat _ _]\ndef evalJacobiSymNat : NormNumExt where eval {u \u03b1} e := do\n    let .app (.app _ (a : Q(\u2115))) (b : Q(\u2115)) \u2190 Meta.whnfR e | failure\n    let \u27e8ea, pa\u27e9 \u2190 deriveNat a _\n    let \u27e8eb, pb\u27e9 \u2190 deriveNat b _\n    haveI' : u =QL 0 := \u27e8\u27e9 haveI' : $\u03b1 =Q \u2124 := \u27e8\u27e9\n    have \u27e8er, pr\u27e9 := proveJacobiSymNat ea eb\n    haveI' : $e =Q jacobiSymNat $a $b := \u27e8\u27e9\n    return .isInt _ er er.intLit!  q(isInt_jacobiSymNat $pa $pb $pr)", "start": [421, 1], "end": [430, 69], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalLegendreSym", "code": "@[norm_num legendreSym _ _]\ndef evalLegendreSym : NormNumExt where eval {u \u03b1} e := do\n    let .app (.app (.app _ (p : Q(\u2115))) (fp : Q(Fact (Nat.Prime $p)))) (a : Q(\u2124)) \u2190 Meta.whnfR e |\n      failure\n    let \u27e8ea, pa\u27e9 \u2190 deriveInt a _\n    let \u27e8ep, pp\u27e9 \u2190 deriveNat p _\n    haveI' : u =QL 0 := \u27e8\u27e9 haveI' : $\u03b1 =Q \u2124 := \u27e8\u27e9\n    have \u27e8er, pr\u27e9 := proveJacobiSym ea ep\n    haveI' : $e =Q legendreSym $p $a := \u27e8\u27e9\n    return .isInt _ er er.intLit!\n      q(LegendreSym.to_jacobiSym $p $fp $a $er (isInt_jacobiSym $pa $pp $pr))", "start": [432, 1], "end": [443, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/Calc.lean", "imports": ["lake-packages/std/Std/CodeAction.lean", "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "Mathlib/Data/String/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "createCalc", "code": "@[tactic_code_action calcTactic]\ndef createCalc : TacticCodeAction := fun params _snap ctx _stack node => do\n  let .node (.ofTacticInfo info) _ := node | return #[]\n  if info.goalsBefore.isEmpty then return #[]\n  let eager := {\n    title := s!\"Generate a calc block.\"\n    kind? := \"quickfix\"\n  }\n  let doc \u2190 readDoc\n  return #[{\n    eager\n    lazy? := some do\n      let tacPos := doc.meta.text.utf8PosToLspPos info.stx.getPos?.get!\n      let endPos := doc.meta.text.utf8PosToLspPos info.stx.getTailPos?.get!\n      let goal := info.goalsBefore[0]!\n      let goalFmt \u2190 ctx.runMetaM {} <| goal.withContext do Meta.ppExpr (\u2190 goal.getType)\n      return { eager with\n        edit? := some <|.ofTextEdit params.textDocument.uri\n          { range := \u27e8tacPos, endPos\u27e9, newText := s!\"calc {goalFmt} := by sorry\" }\n      }\n  }]", "start": [22, 1], "end": [43, 5], "kind": "commanddeclaration"}, {"full_name": "CalcParams", "code": "structure CalcParams extends SelectInsertParams where\n  \n  isFirst : Bool\n  \n  indent : Nat\n  deriving SelectInsertParamsClass, RpcEncodable", "start": [51, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "suggestSteps", "code": "def suggestSteps (pos : Array Lean.SubExpr.GoalsLocation) (goalType : Expr) (params : CalcParams) :\n    MetaM (String \u00d7 String \u00d7 Option (String.Pos \u00d7 String.Pos)) := do\n  let subexprPos := getGoalLocations pos\n  let some (rel, lhs, rhs) \u2190 Lean.Elab.Term.getCalcRelation? goalType |\n      throwError \"invalid 'calc' step, relation expected{indentExpr goalType}\"\n  let relApp := mkApp2 rel\n    (\u2190 mkFreshExprMVar none)\n    (\u2190 mkFreshExprMVar none)\n  let some relStr := (\u2190 Meta.ppExpr relApp) |> toString |>.splitOn |>.get? 1\n    | throwError \"could not find relation symbol in {relApp}\"\n  let isSelectedLeft := subexprPos.any (fun L \u21a6 #[0, 1].isPrefixOf L.toArray)\n  let isSelectedRight := subexprPos.any (fun L \u21a6 #[1].isPrefixOf L.toArray)\n\n  let mut goalType := goalType\n  for pos in subexprPos do\n    goalType \u2190 insertMetaVar goalType pos\n  let some (_, newLhs, newRhs) \u2190 Lean.Elab.Term.getCalcRelation? goalType | unreachable!\n\n  let lhsStr := (toString <| \u2190 Meta.ppExpr lhs).renameMetaVar\n  let newLhsStr := (toString <| \u2190 Meta.ppExpr newLhs).renameMetaVar\n  let rhsStr := (toString <| \u2190 Meta.ppExpr rhs).renameMetaVar\n  let newRhsStr := (toString <| \u2190 Meta.ppExpr newRhs).renameMetaVar\n\n  let spc := String.replicate params.indent ' '\n  let insertedCode := match isSelectedLeft, isSelectedRight with\n  | true, true =>\n    if params.isFirst then\n      s!\"{lhsStr} {relStr} {newLhsStr} := by sorry\\n{spc}_ {relStr} {newRhsStr} := by sorry\\n\" ++\n      s!\"{spc}_ {relStr} {rhsStr} := by sorry\"\n    else\n      s!\"_ {relStr} {newLhsStr} := by sorry\\n{spc}_ {relStr} {newRhsStr} := by sorry\\n\" ++\n      s!\"{spc}_ {relStr} {rhsStr} := by sorry\"\n  | false, true  =>\n    if params.isFirst then\n      s!\"{lhsStr} {relStr} {newRhsStr} := by sorry\\n{spc}_ {relStr} {rhsStr} := by sorry\"\n    else\n      s!\"_ {relStr} {newRhsStr} := by sorry\\n{spc}_ {relStr} {rhsStr} := by sorry\"\n  | true, false =>\n    if params.isFirst then\n      s!\"{lhsStr} {relStr} {newLhsStr} := by sorry\\n{spc}_ {relStr} {rhsStr} := by sorry\"\n    else\n      s!\"_ {relStr} {newLhsStr} := by sorry\\n{spc}_ {relStr} {rhsStr} := by sorry\"\n  | false, false => \"This should not happen\"\n\n  let stepInfo := match isSelectedLeft, isSelectedRight with\n  | true, true => \"Create two new steps\"\n  | true, false | false, true => \"Create a new step\"\n  | false, false => \"This should not happen\"\n  let pos : String.Pos := insertedCode.find (fun c => c == '?')\n  return (stepInfo, insertedCode, some (pos, \u27e8pos.byteIdx + 2\u27e9) )", "start": [61, 1], "end": [111, 66], "kind": "commanddeclaration"}, {"full_name": "CalcPanel.rpc", "code": "@[server_rpc_method]\ndef CalcPanel.rpc := mkSelectionPanelRPC suggestSteps\n  \"Please select subterms.\"\n  \"Calc \ud83d\udd0d\"", "start": [113, 1], "end": [117, 11], "kind": "commanddeclaration"}, {"full_name": "CalcPanel", "code": "@[widget_module]\ndef CalcPanel : Component CalcParams :=\n  mk_rpc_widget% CalcPanel.rpc", "start": [119, 1], "end": [122, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Sat/FromLRAT.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sat.Literal", "code": "inductive Literal\n  | pos : Nat \u2192 Literal\n  | neg : Nat \u2192 Literal", "start": [49, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "Sat.Literal.ofInt", "code": "def Literal.ofInt (i : Int) : Literal :=\n  if i < 0 then Literal.neg (-i-1).toNat else Literal.pos (i-1).toNat", "start": [55, 1], "end": [58, 70], "kind": "commanddeclaration"}, {"full_name": "Sat.Literal.negate", "code": "def Literal.negate : Literal \u2192 Literal\n  | pos i => neg i\n  | neg i => pos i", "start": [60, 1], "end": [63, 19], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause", "code": "def Clause := List Literal", "start": [71, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.nil", "code": "def Clause.nil : Clause := []", "start": [74, 1], "end": [74, 30], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.cons", "code": "def Clause.cons : Literal \u2192 Clause \u2192 Clause := List.cons", "start": [75, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla", "code": "abbrev Fmla := List Clause", "start": [77, 1], "end": [78, 27], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.one", "code": "def Fmla.one (c : Clause) : Fmla := [c]", "start": [80, 1], "end": [81, 40], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.and", "code": "def Fmla.and (a b : Fmla) : Fmla := a ++ b", "start": [83, 1], "end": [84, 43], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.subsumes", "code": "structure Fmla.subsumes (f f' : Fmla) : Prop where\n  prop : \u2200 x, x \u2208 f' \u2192 x \u2208 f", "start": [86, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.subsumes_self", "code": "theorem Fmla.subsumes_self (f : Fmla) : f.subsumes f", "start": [91, 1], "end": [91, 70], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.subsumes_left", "code": "theorem Fmla.subsumes_left (f f\u2081 f\u2082 : Fmla) (H : f.subsumes (f\u2081.and f\u2082)) : f.subsumes f\u2081", "start": [92, 1], "end": [93, 51], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.subsumes_right", "code": "theorem Fmla.subsumes_right (f f\u2081 f\u2082 : Fmla) (H : f.subsumes (f\u2081.and f\u2082)) : f.subsumes f\u2082", "start": [94, 1], "end": [95, 51], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation", "code": "def Valuation := Nat \u2192 Prop", "start": [97, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.neg", "code": "def Valuation.neg (v : Valuation) : Literal \u2192 Prop\n  | Literal.pos i => \u00ac v i\n  | Literal.neg i => v i", "start": [100, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.satisfies", "code": "def Valuation.satisfies (v : Valuation) : Clause \u2192 Prop\n  | [] => False\n  | l::c => v.neg l \u2192 v.satisfies c", "start": [105, 1], "end": [111, 36], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.satisfies_fmla", "code": "structure Valuation.satisfies_fmla (v : Valuation) (f : Fmla) : Prop where\n  prop : \u2200 c, c \u2208 f \u2192 v.satisfies c", "start": [113, 1], "end": [116, 36], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.proof", "code": "def Fmla.proof (f : Fmla) (c : Clause) : Prop :=\n  \u2200 v : Valuation, v.satisfies_fmla f \u2192 v.satisfies c", "start": [118, 1], "end": [120, 54], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.proof_of_subsumes", "code": "theorem Fmla.proof_of_subsumes (H : Fmla.subsumes f (Fmla.one c)) : f.proof c", "start": [122, 1], "end": [124, 45], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.by_cases", "code": "theorem Valuation.by_cases {v : Valuation} {l}\n    (h\u2081 : v.neg l.negate \u2192 False) (h\u2082 : v.neg l \u2192 False) : False", "start": [126, 1], "end": [139, 25], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.implies", "code": "def Valuation.implies (v : Valuation) (p : Prop) : List Prop \u2192 Nat \u2192 Prop\n  | [], _ => p\n  | a::as, n => (v n \u2194 a) \u2192 v.implies p as (n+1)", "start": [141, 1], "end": [145, 49], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.mk", "code": "def Valuation.mk : List Prop \u2192 Valuation\n  | [], _ => False\n  | a::_, 0 => a\n  | _::as, n+1 => mk as n", "start": [147, 1], "end": [152, 26], "kind": "commanddeclaration"}, {"full_name": "Sat.Valuation.mk_implies", "code": "theorem Valuation.mk_implies {as ps} (as\u2081) : as = List.reverseAux as\u2081 ps \u2192\n    (Valuation.mk as).implies p ps as\u2081.length \u2192 p", "start": [154, 1], "end": [166, 71], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.reify", "code": "structure Fmla.reify (v : Valuation) (f : Fmla) (p : Prop) : Prop where\n  prop : \u00ac v.satisfies_fmla f \u2192 p", "start": [168, 1], "end": [170, 34], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.refute", "code": "theorem Fmla.refute {ps} (f : Fmla) (hf : f.proof [])\n    (hv : \u2200 v, Valuation.implies v (Fmla.reify v f p) ps 0) : p", "start": [172, 1], "end": [177, 48], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.reify_or", "code": "theorem Fmla.reify_or (h\u2081 : Fmla.reify v f\u2081 a) (h\u2082 : Fmla.reify v f\u2082 b) :\n    Fmla.reify v (f\u2081.and f\u2082) (a \u2228 b)", "start": [179, 1], "end": [185, 53], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.reify", "code": "structure Clause.reify (v : Valuation) (c : Clause) (p : Prop) : Prop where\n  prop : \u00ac v.satisfies c \u2192 p", "start": [187, 1], "end": [189, 29], "kind": "commanddeclaration"}, {"full_name": "Sat.Fmla.reify_one", "code": "theorem Fmla.reify_one (h : Clause.reify v c a) : Fmla.reify v (Fmla.one c) a", "start": [191, 1], "end": [193, 59], "kind": "commanddeclaration"}, {"full_name": "Sat.Literal.reify", "code": "structure Literal.reify (v : Valuation) (l : Literal) (p : Prop) : Prop where\n  prop : v.neg l \u2192 p", "start": [195, 1], "end": [197, 21], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.reify_and", "code": "theorem Clause.reify_and (h\u2081 : Literal.reify v l a) (h\u2082 : Clause.reify v c b) :\n    Clause.reify v (Clause.cons l c) (a \u2227 b)", "start": [199, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.reify_zero", "code": "theorem Clause.reify_zero : Clause.reify v Clause.nil True", "start": [204, 1], "end": [205, 80], "kind": "commanddeclaration"}, {"full_name": "Sat.Clause.reify_one", "code": "theorem Clause.reify_one (h\u2081 : Literal.reify v l a) : Clause.reify v (Clause.nil.cons l) a", "start": [207, 1], "end": [209, 60], "kind": "commanddeclaration"}, {"full_name": "Sat.Literal.reify_pos", "code": "theorem Literal.reify_pos (h : v n \u2194 a) : (Literal.pos n).reify v \u00aca", "start": [211, 1], "end": [212, 81], "kind": "commanddeclaration"}, {"full_name": "Sat.Literal.reify_neg", "code": "theorem Literal.reify_neg (h : v n \u2194 a) : (Literal.neg n).reify v a", "start": [214, 1], "end": [215, 77], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Clause", "code": "structure Clause where\n  \n  lits : Array Int\n  \n  expr : Expr\n  \n  proof : Expr", "start": [221, 1], "end": [232, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildClause", "code": "def buildClause (arr : Array Int) : Expr :=\n  let nil  := mkConst ``Sat.Clause.nil\n  let cons := mkConst ``Sat.Clause.cons\n  arr.foldr (fun i e \u21a6 mkApp2 cons (toExpr $ Sat.Literal.ofInt i) e) nil", "start": [234, 1], "end": [239, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildConj", "code": "partial def buildConj (arr : Array (Array Int)) (start stop : Nat) : Expr :=\n  match stop - start with\n  | 0 => panic! \"empty\"\n  | 1 => mkApp (mkConst ``Sat.Fmla.one) (buildClause arr[start]!)\n  | len =>\n    let mid := start + len / 2\n    mkApp2 (mkConst ``Sat.Fmla.and) (buildConj arr start mid) (buildConj arr mid stop)", "start": [241, 1], "end": [248, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildClauses", "code": "partial def buildClauses (arr : Array (Array Int)) (ctx : Expr) (start stop : Nat)\n  (f p : Expr) (accum : Nat \u00d7 HashMap Nat Clause) : Nat \u00d7 HashMap Nat Clause :=\n  match stop - start with\n  | 0 => panic! \"empty\"\n  | 1 =>\n    let c := f.appArg!\n    let proof := mkApp3 (mkConst ``Sat.Fmla.proof_of_subsumes) ctx c p\n    let n := accum.1 + 1\n    (n, accum.2.insert n { lits := arr[start]!, expr := c, proof })\n  | len =>\n    let mid := start + len / 2\n    let f\u2081 := f.appFn!.appArg!\n    let f\u2082 := f.appArg!\n    let p\u2081 := mkApp4 (mkConst ``Sat.Fmla.subsumes_left) ctx f\u2081 f\u2082 p\n    let p\u2082 := mkApp4 (mkConst ``Sat.Fmla.subsumes_right) ctx f\u2081 f\u2082 p\n    let accum := buildClauses arr ctx start mid f\u2081 p\u2081 accum\n    buildClauses arr ctx mid stop f\u2082 p\u2082 accum", "start": [250, 1], "end": [268, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.LClause", "code": "structure LClause where\n  \n  lits : Array Int\n  \n  expr : Expr\n  \n  depth : Nat", "start": [270, 1], "end": [280, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildProofStep", "code": "partial def buildProofStep (db : HashMap Nat Clause)\n  (ns pf : Array Int) (ctx clause : Expr) : Except String Expr := Id.run do\n  let mut lams := #[]\n  let mut args := #[]\n  let mut gctx : HashMap Nat LClause := {}\n  for i in pf do\n    let i := i.natAbs\n    let some cl := db.find? i | return Except.error \"missing clause\"\n    if !gctx.contains i then\n      lams := lams.push (mkApp2 (mkConst ``Sat.Fmla.proof) ctx cl.expr)\n      args := args.push cl.proof\n      gctx := gctx.insert i {\n        lits := cl.lits\n        expr := cl.expr\n        depth := args.size\n      }\n  let n := args.size\n  let mut f :=\n    (mkAppN \u00b7 args) \u2218\n    lams.foldr (mkLambda `c default) \u2218\n    mkLambda `v default (mkConst ``Sat.Valuation) \u2218\n    mkLambda `hv default (mkApp2 (mkConst ``Sat.Valuation.satisfies_fmla) (mkBVar 0) ctx)\n  let v depth := mkBVar (depth + 1)\n  let hv depth := mkBVar depth\n  lams := #[]\n  let mut clause := clause\n  let mut depth := 0\n  let mut lctx : HashMap Int Nat := {}\n  for i in ns do\n    let l := clause.appFn!.appArg!\n    clause := clause.appArg!\n    lams := lams.push (mkApp2 (mkConst ``Sat.Valuation.neg) (v depth) l)\n    depth := depth.succ\n    lctx := lctx.insert i depth\n  f := f \u2218 lams.foldr (mkLambda `h default)\n  for (step : Int) in pf do\n    if step < 0 then return Except.error \"unimplemented: RAT step\"\n    let some cl := gctx.find? step.toNat | return Except.error \"missing clause\"\n    let mut unit := none\n    for i in cl.lits do\n      unless lctx.contains i do\n        if unit.isSome then return Except.error s!\"not unit: {cl.lits}\"\n        depth := depth.succ\n        unit := some i\n    let mut pr := mkApp2 (mkBVar (depth + n + 2 - cl.depth)) (v depth) (hv depth)\n    for i in cl.lits do\n      pr := mkApp pr <| mkBVar (match lctx.find? i with | some k => depth - k | _ => 0)\n    let some u := unit | return Except.ok <| f pr\n    let lit := toExpr $ Sat.Literal.ofInt u\n    let nlit := toExpr $ Sat.Literal.ofInt (-u)\n    let d1 := depth-1\n    let app := mkApp3 (mkConst ``Sat.Valuation.by_cases) (v d1) nlit <|\n      mkLambda `h default (mkApp2 (mkConst ``Sat.Valuation.neg) (v d1) lit) pr\n    let dom := mkApp2 (mkConst ``Sat.Valuation.neg) (v d1) nlit\n    f := fun e \u21a6 f <| mkApp app <| mkLambda `h default dom e\n    lctx := lctx.insert (-u) depth\n  return Except.error s!\"no refutation: {ns}, {pf}, {lctx.toList}\"", "start": [282, 1], "end": [371, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.LRATStep", "code": "inductive LRATStep\n  | \n    add (id : Nat) (lits : Array Int) (proof : Array Int) : LRATStep\n  | \n    del (ids : Array Nat) : LRATStep", "start": [373, 1], "end": [378, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildProof", "code": "partial def buildProof (arr : Array (Array Int)) (ctx ctx' : Expr)\n  (steps : Array LRATStep) : MetaM Expr := do\n  let p := mkApp (mkConst ``Sat.Fmla.subsumes_self) ctx\n  let mut db := (buildClauses arr ctx 0 arr.size ctx' p default).2\n  for step in steps do\n    match step with\n    | LRATStep.del ds => db := ds.foldl (\u00b7.erase \u00b7) db\n    | LRATStep.add i ns pf =>\n      let e := buildClause ns\n      match buildProofStep db ns pf ctx e with\n      | Except.ok proof =>\n        if ns.isEmpty then return proof\n        db := db.insert i { lits := ns, expr := e, proof }\n      | Except.error msg => throwError msg\n  throwError \"failed to prove empty clause\"", "start": [380, 1], "end": [401, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.buildReify", "code": "partial def buildReify (ctx ctx' proof : Expr) (nvars : Nat) : Expr \u00d7 Expr := Id.run do\n  let (e, pr) := reifyFmla ctx'\n  let mut pr := pr\n  for i in [0:nvars] do\n    let j := nvars-i-1\n    let ty := mkApp2 (mkConst ``Iff) (mkApp (mkBVar j) (mkRawNatLit j)) (mkBVar nvars)\n    pr := mkLambda `h default ty pr\n  pr := mkLambda `v default (mkConst ``Sat.Valuation) pr\n  let mut e := e.lowerLooseBVars (nvars+1) (nvars+1)\n  let cons := mkApp (mkConst ``List.cons [levelZero]) (mkSort levelZero)\n  let nil := mkApp (mkConst ``List.nil [levelZero]) (mkSort levelZero)\n  let rec mkPS depth e\n  | 0 => e\n  | n+1 => mkPS (depth+1) (mkApp2 cons (mkBVar depth) e) n\n  pr := mkApp5 (mkConst ``Sat.Fmla.refute) e (mkPS 0 nil nvars) ctx proof pr\n  for _ in [0:nvars] do\n    e := mkForall `a default (mkSort levelZero) e\n    pr := mkLambda `a default (mkSort levelZero) pr\n  pure (e, pr)\nwhere\n  \n  v := mkBVar nvars\n  \n  reifyFmla f :=\n    match f.getAppFn.constName! with\n    | ``Sat.Fmla.and =>\n      let f\u2081 := f.appFn!.appArg!\n      let f\u2082 := f.appArg!\n      let (e\u2081, h\u2081) := reifyFmla f\u2081\n      let (e\u2082, h\u2082) := reifyFmla f\u2082\n      (mkApp2 (mkConst ``Or) e\u2081 e\u2082, mkApp7 (mkConst ``Sat.Fmla.reify_or) v f\u2081 e\u2081 f\u2082 e\u2082 h\u2081 h\u2082)\n    | ``Sat.Fmla.one =>\n      let c := f.appArg!\n      let (e, h) := reifyClause c\n      (e, mkApp4 (mkConst ``Sat.Fmla.reify_one) v c e h)\n    | _ => panic! \"not a valid formula\"\n  \n  reifyClause c :=\n    if c.appFn!.isConst then\n      (mkConst ``True, mkApp (mkConst ``Sat.Clause.reify_zero) v)\n    else reifyClause1 c\n  \n  reifyClause1 c :=\n    let l := c.appFn!.appArg!\n    let c := c.appArg!\n    let (e\u2081, h\u2081) := reifyLiteral l\n    if c.isConst then\n      (e\u2081, mkApp4 (mkConst ``Sat.Clause.reify_one) v l e\u2081 h\u2081)\n    else\n      let (e\u2082, h\u2082) := reifyClause1 c\n      (mkApp2 (mkConst ``And) e\u2081 e\u2082, mkApp7 (mkConst ``Sat.Clause.reify_and) v l e\u2081 c e\u2082 h\u2081 h\u2082)\n  \n  reifyLiteral l :=\n    let n := l.appArg!\n    let (e, h) := reifyVar n\n    match l.appFn!.constName! with\n    | ``Sat.Literal.pos =>\n      (mkApp (mkConst ``Not) e, mkApp4 (mkConst ``Sat.Literal.reify_pos) v e n h)\n    | ``Sat.Literal.neg =>\n      (e, mkApp4 (mkConst ``Sat.Literal.reify_neg) v e n h)\n    | _ => panic! \"not a valid literal\"\n  \n  reifyVar v :=\n    let n := v.natLit?.get!\n    (mkBVar (2 * nvars - n), mkBVar (nvars - n - 1))", "start": [403, 1], "end": [488, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseNat", "code": "def parseNat : Parsec Nat := Json.Parser.natMaybeZero", "start": [494, 1], "end": [495, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseInt", "code": "def parseInt : Parsec Int := do\n  if (\u2190 peek!) = '-' then skip; pure $ -(\u2190 parseNat) else parseNat", "start": [497, 1], "end": [499, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseInts", "code": "partial def parseInts (arr : Array Int := #[]) : Parsec (Array Int) := do\n  match \u2190 parseInt <* ws with\n  | 0 => pure arr\n  | n => parseInts (arr.push n)", "start": [501, 1], "end": [505, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseNats", "code": "partial def parseNats (arr : Array Nat := #[]) : Parsec (Array Nat) := do\n  match \u2190 parseNat <* ws with\n  | 0 => pure arr\n  | n => parseNats (arr.push n)", "start": [507, 1], "end": [511, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseDimacs", "code": "def parseDimacs : Parsec (Nat \u00d7 Array (Array Int)) := do\n  pstring \"p cnf\" *> ws\n  let nvars \u2190 parseNat <* ws\n  let nclauses \u2190 parseNat <* ws\n  let mut clauses := Array.mkEmpty nclauses\n  for _ in [:nclauses] do\n    clauses := clauses.push (\u2190 parseInts)\n  pure (nvars, clauses)", "start": [513, 1], "end": [522, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.Parser.parseLRAT", "code": "def parseLRAT : Parsec (Array LRATStep) := many do\n  let step \u2190 parseNat <* ws\n  if (\u2190 peek!) = 'd' then skip <* ws; pure $ LRATStep.del (\u2190 parseNats)\n  else ws; pure $ LRATStep.add step (\u2190 parseInts) (\u2190 parseInts)", "start": [524, 1], "end": [528, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.fromLRATAux", "code": "def fromLRATAux (cnf lrat : String) (name : Name) : MetaM (Nat \u00d7 Expr \u00d7 Expr \u00d7 Expr) := do\n  let Parsec.ParseResult.success _ (nvars, arr) := Parser.parseDimacs cnf.mkIterator\n    | throwError \"parse CNF failed\"\n  if arr.isEmpty then throwError \"empty CNF\"\n  let ctx' := buildConj arr 0 arr.size\n  let ctxName \u2190 mkAuxName (name ++ `ctx) 1\n  addDecl $ Declaration.defnDecl {\n    name := ctxName\n    levelParams := []\n    type        := mkConst ``Sat.Fmla\n    value       := ctx'\n    hints       := ReducibilityHints.regular 0\n    safety      := DefinitionSafety.safe\n  }\n  let ctx := mkConst ctxName\n  let Parsec.ParseResult.success _ steps := Parser.parseLRAT lrat.mkIterator\n    | throwError \"parse LRAT failed\"\n  let proof \u2190 buildProof arr ctx ctx' steps\n  let declName \u2190 mkAuxName (name ++ `proof) 1\n  addDecl $ Declaration.thmDecl {\n    name := declName\n    levelParams := []\n    type        := mkApp2 (mkConst ``Sat.Fmla.proof) ctx (buildClause #[])\n    value       := proof\n  }\n  return (nvars, ctx, ctx', mkConst declName)", "start": [532, 1], "end": [565, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Sat.fromLRAT", "code": "def fromLRAT (cnf lrat : String) (name : Name) : MetaM Unit := do\n  let (nvars, ctx, ctx', proof) \u2190 fromLRATAux cnf lrat name\n  let (type, value) := buildReify ctx ctx' proof nvars\n  addDecl $ Declaration.thmDecl { name, levelParams := [], type, value }", "start": [567, 1], "end": [576, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/NatFib.lean", "imports": ["Mathlib/Data/Nat/Fib.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.IsFibAux", "code": "def IsFibAux (n a b : \u2115) :=\n  fib n = a \u2227 fib (n + 1) = b", "start": [20, 1], "end": [22, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_zero", "code": "theorem isFibAux_zero : IsFibAux 0 0 1", "start": [24, 1], "end": [25, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_one", "code": "theorem isFibAux_one : IsFibAux 1 1 1", "start": [27, 1], "end": [28, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_two_mul", "code": "theorem isFibAux_two_mul {n a b n' a' b' : \u2115} (H : IsFibAux n a b)\n    (hn : 2 * n = n') (h1 : a * (2 * b - a) = a') (h2 : a * a + b * b = b') :\n    IsFibAux n' a' b'", "start": [30, 1], "end": [34, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_two_mul_add_one", "code": "theorem isFibAux_two_mul_add_one {n a b n' a' b' : \u2115} (H : IsFibAux n a b)\n    (hn : 2 * n + 1 = n') (h1 : a * a + b * b = a') (h2 : b * (2 * a + b) = b') :\n    IsFibAux n' a' b'", "start": [36, 1], "end": [40, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.proveNatFibAux", "code": "partial def proveNatFibAux (en' : Q(\u2115)) : (ea' eb' : Q(\u2115)) \u00d7 Q(IsFibAux $en' $ea' $eb') :=\n  match en'.natLit! with\n  | 0 =>\n    show (ea' eb' : Q(\u2115)) \u00d7 Q(IsFibAux 0 $ea' $eb') from\n    \u27e8mkRawNatLit 0, mkRawNatLit 1, q(isFibAux_zero)\u27e9\n  | 1 =>\n    show (ea' eb' : Q(\u2115)) \u00d7 Q(IsFibAux 1 $ea' $eb') from\n    \u27e8mkRawNatLit 1, mkRawNatLit 1, q(isFibAux_one)\u27e9\n  | n' =>\n    have en : Q(\u2115) := mkRawNatLit <| n' / 2\n    let \u27e8ea, eb, H\u27e9 := proveNatFibAux en\n    let a := ea.natLit!\n    let b := eb.natLit!\n    if n' % 2 == 0 then\n      have hn : Q(2 * $en = $en') := (q(Eq.refl $en') : Expr)\n      have ea' : Q(\u2115) := mkRawNatLit <| a * (2 * b - a)\n      have eb' : Q(\u2115) := mkRawNatLit <| a * a + b * b\n      have h1 : Q($ea * (2 * $eb - $ea) = $ea') := (q(Eq.refl $ea') : Expr)\n      have h2 : Q($ea * $ea + $eb * $eb = $eb') := (q(Eq.refl $eb') : Expr)\n      \u27e8ea', eb', q(isFibAux_two_mul $H $hn $h1 $h2)\u27e9\n    else\n      have hn : Q(2 * $en + 1 = $en') := (q(Eq.refl $en') : Expr)\n      have ea' : Q(\u2115) := mkRawNatLit <| a * a + b * b\n      have eb' : Q(\u2115) := mkRawNatLit <| b * (2 * a + b)\n      have h1 : Q($ea * $ea + $eb * $eb = $ea') := (q(Eq.refl $ea') : Expr)\n      have h2 : Q($eb * (2 * $ea + $eb) = $eb') := (q(Eq.refl $eb') : Expr)\n      \u27e8ea', eb', q(isFibAux_two_mul_add_one $H $hn $h1 $h2)\u27e9", "start": [42, 1], "end": [68, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_two_mul_done", "code": "theorem isFibAux_two_mul_done {n a b n' a' : \u2115} (H : IsFibAux n a b)\n    (hn : 2 * n = n') (h : a * (2 * b - a) = a') : fib n' = a'", "start": [70, 1], "end": [72, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isFibAux_two_mul_add_one_done", "code": "theorem isFibAux_two_mul_add_one_done {n a b n' a' : \u2115} (H : IsFibAux n a b)\n    (hn : 2 * n + 1 = n') (h : a * a + b * b = a') : fib n' = a'", "start": [74, 1], "end": [76, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.proveNatFib", "code": "def proveNatFib (en' : Q(\u2115)) : (em : Q(\u2115)) \u00d7 Q(Nat.fib $en' = $em) :=\n  match en'.natLit! with\n  | 0 => show (em : Q(\u2115)) \u00d7 Q(Nat.fib 0 = $em) from \u27e8mkRawNatLit 0, q(Nat.fib_zero)\u27e9\n  | 1 => show (em : Q(\u2115)) \u00d7 Q(Nat.fib 1 = $em) from \u27e8mkRawNatLit 1, q(Nat.fib_one)\u27e9\n  | 2 => show (em : Q(\u2115)) \u00d7 Q(Nat.fib 2 = $em) from \u27e8mkRawNatLit 1, q(Nat.fib_two)\u27e9\n  | n' =>\n    have en : Q(\u2115) := mkRawNatLit <| n' / 2\n    let \u27e8ea, eb, H\u27e9 := proveNatFibAux en\n    let a := ea.natLit!\n    let b := eb.natLit!\n    if n' % 2 == 0 then\n      have hn : Q(2 * $en = $en') := (q(Eq.refl $en') : Expr)\n      have ea' : Q(\u2115) := mkRawNatLit <| a * (2 * b - a)\n      have h1 : Q($ea * (2 * $eb - $ea) = $ea') := (q(Eq.refl $ea') : Expr)\n      \u27e8ea', q(isFibAux_two_mul_done $H $hn $h1)\u27e9\n    else\n      have hn : Q(2 * $en + 1 = $en') := (q(Eq.refl $en') : Expr)\n      have ea' : Q(\u2115) := mkRawNatLit <| a * a + b * b\n      have h1 : Q($ea * $ea + $eb * $eb = $ea') := (q(Eq.refl $ea') : Expr)\n      \u27e8ea', q(isFibAux_two_mul_add_one_done $H $hn $h1)\u27e9", "start": [78, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_fib", "code": "theorem isNat_fib : {x nx z : \u2115} \u2192 IsNat x nx \u2192 Nat.fib nx = z \u2192 IsNat (Nat.fib x) z", "start": [101, 1], "end": [102, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatFib", "code": "@[norm_num Nat.fib _]\ndef evalNatFib : NormNumExt where eval {u \u03b1} e := do\n  let .app _ (x : Q(\u2115)) \u2190 Meta.whnfR e | failure\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8ex, p\u27e9 \u2190 deriveNat x s\u2115\n  let \u27e8ey, pf\u27e9 := proveNatFib ex\n  let pf' : Q(IsNat (Nat.fib $x) $ey) := q(isNat_fib $p $pf)\n  return .isNat s\u2115 ey pf'", "start": [104, 1], "end": [112, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/MoveAdd.lean", "imports": ["Mathlib/Init/Order/LinearOrder.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.getExprInputs", "code": "def Lean.Expr.getExprInputs : Expr \u2192 Array Expr\n  | app fn arg        => #[fn, arg]\n  | lam _ bt bb _     => #[bt, bb]\n  | forallE _ bt bb _ => #[bt, bb]\n  | letE _ t v b _    => #[t, v, b]\n  | mdata _ e         => #[e]\n  | proj _ _ e        => #[e]\n  | _ => #[]", "start": [102, 1], "end": [111, 13], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.size", "code": "partial\ndef Lean.Expr.size (e : Expr) : \u2115 := (e.getExprInputs.map size).foldl (\u00b7 + \u00b7) 1", "start": [113, 1], "end": [115, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.uniquify", "code": "def uniquify : List \u03b1 \u2192 List (\u03b1 \u00d7 \u2115)\n  | []    => []\n  | m::ms =>\n    let lms := uniquify ms\n    (m, 0) :: (lms.map fun (x, n) => if x == m then (x, n + 1) else (x, n))", "start": [137, 1], "end": [148, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.weight", "code": "def weight (L : List (\u03b1 \u00d7 Bool)) (a : \u03b1) : \u2124 :=\n  let l := L.length\n  match L.find? (Prod.fst \u00b7 == a) with\n    | some (_, b) => if b then - l + (L.indexOf (a, b) : \u2124) else (L.indexOf (a, b) + 1 : \u2124)\n    | none => 0", "start": [152, 1], "end": [173, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.reorderUsing", "code": "def reorderUsing (toReorder : List \u03b1) (instructions : List (\u03b1 \u00d7 Bool)) : List \u03b1 :=\n  let uInstructions :=\n    let (as, as?) := instructions.unzip\n    (uniquify as).zip as?\n  let uToReorder := (uniquify toReorder).toArray\n  let reorder := uToReorder.qsort fun x y =>\n    match uInstructions.find? (Prod.fst \u00b7 == x), uInstructions.find? (Prod.fst \u00b7 == y) with\n      | none, none => (uToReorder.getIdx? x).get! \u2264 (uToReorder.getIdx? y).get!\n      | _, _ => weight uInstructions x \u2264 weight uInstructions y\n  (reorder.map Prod.fst).toList", "start": [175, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.prepareOp", "code": "def prepareOp (sum : Expr) : Expr :=\n  let opargs := sum.getAppArgs\n  (opargs.toList.take (opargs.size - 2)).foldl (fun x y => Expr.app x y) sum.getAppFn", "start": [204, 1], "end": [216, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.sumList", "code": "partial\ndef sumList (prepOp : Expr) : List Expr \u2192 Expr\n  | []    => default\n  | [a]    => a\n  | a::as => as.foldl (fun x y => Expr.app (prepOp.app x) y) a", "start": [218, 1], "end": [229, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.getAddends", "code": "partial def getAddends (sum : Expr) : MetaM (Array Expr) := do\n  if sum.isAppOf op then\n    let inR \u2190 sum.getAppArgs.filterM fun r => do isDefEq R (\u2190 inferType r <|> pure R)\n    let new \u2190 inR.mapM (getAddends \u00b7)\n    return new.foldl Array.append  #[]\n  else return #[sum]", "start": [238, 1], "end": [245, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.getOps", "code": "partial def getOps (sum : Expr) : MetaM (Array ((Array Expr) \u00d7 Expr)) := do\n  let summands \u2190 getAddends op (\u2190 inferType sum <|> return sum) sum\n  let (first, rest) := if summands.size == 1 then (#[], sum.getExprInputs) else\n    (#[(summands, sum)], summands)\n  let rest \u2190 rest.mapM getOps\n  return rest.foldl Array.append first", "start": [247, 1], "end": [257, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.rankSums", "code": "def rankSums (tgt : Expr) (instructions : List (Expr \u00d7 Bool)) : MetaM (List (Expr \u00d7 Expr)) := do\n  let sums \u2190 getOps op (\u2190 instantiateMVars tgt)\n  let candidates := sums.map fun (addends, sum) => do\n    let reord := reorderUsing addends.toList instructions\n    let resummed := sumList (prepareOp sum) reord\n    if (resummed != sum) then some (sum, resummed) else none\n  return (candidates.toList.reduceOption.toArray.qsort\n    (fun x y : Expr \u00d7 Expr \u21a6 (y.1.size  \u2264 x.1.size))).toList", "start": [259, 1], "end": [279, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.permuteExpr", "code": "def permuteExpr (tgt : Expr) (instructions : List (Expr \u00d7 Bool)) : MetaM Expr := do\n  let permInstructions \u2190 rankSums op tgt instructions\n  if permInstructions == [] then throwError \"The goal is already in the required form\"\n  let mut permTgt := tgt\n  for (old, new) in permInstructions do\n    permTgt := permTgt.replace (if \u00b7 == old then new else none)\n  return permTgt", "start": [281, 1], "end": [292, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.pairUp", "code": "def pairUp : List (Expr \u00d7 Bool \u00d7 Syntax) \u2192 List Expr \u2192\n    MetaM ((List (Expr \u00d7 Bool)) \u00d7 List (Expr \u00d7 Bool \u00d7 Syntax))\n  | (m::ms), l => do\n    match \u2190 l.findM? (isDefEq \u00b7 m.1) with\n      | none => let (found, unfound) \u2190 pairUp ms l; return (found, m::unfound)\n      | some d => let (found, unfound) \u2190 pairUp ms (l.erase d)\n                  return ((d, m.2.1)::found, unfound)\n  | _, _ => return ([], [])", "start": [294, 1], "end": [324, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.move_oper_simpCtx", "code": "def move_oper_simpCtx : MetaM Simp.Context := do\n  let simpNames := Elab.Tactic.simpOnlyBuiltins ++ [\n    ``add_comm, ``add_assoc, ``add_left_comm,  ``mul_comm, ``mul_assoc, ``mul_left_comm,  ``and_comm, ``and_assoc, ``and_left_comm,  ``or_comm,  ``or_assoc,  ``or_left_comm,   ``max_comm, ``max_assoc, ``max_left_comm,  ``min_comm, ``min_assoc, ``min_left_comm   ]\n  let simpThms \u2190 simpNames.foldlM (\u00b7.addConst \u00b7) ({} : SimpTheorems)\n  return { simpTheorems := #[simpThms] }", "start": [326, 1], "end": [340, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.reorderAndSimp", "code": "def reorderAndSimp (mv : MVarId) (instr : List (Expr \u00d7 Bool)) :\n    MetaM (List MVarId) := do\n  let permExpr \u2190 permuteExpr op (\u2190 mv.getType'') instr\n  let eqmpr \u2190 mkAppM ``Eq.mpr #[\u2190 mkFreshExprMVar (\u2190 mkEq (\u2190 mv.getType) permExpr)]\n  let twoGoals \u2190 mv.apply eqmpr\n  guard (twoGoals.length == 2) <|>\n    throwError m!\"There should only be 2 goals, instead of {twoGoals.length}\"\n  let permGoal \u2190 twoGoals.filterM fun v => return !(\u2190 v.isAssigned)\n  match \u2190 (simpGoal (permGoal[1]!) (\u2190 move_oper_simpCtx)) with\n    | (some x, _) => throwError m!\"'move_oper' could not solve {indentD x.2}\"\n    | (none, _) => return permGoal", "start": [342, 1], "end": [364, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.unifyMovements", "code": "def unifyMovements (data : Array (Expr \u00d7 Bool \u00d7 Syntax)) (tgt : Expr) :\n    MetaM (List (Expr \u00d7 Bool) \u00d7 (List MessageData \u00d7 List Syntax) \u00d7 Array MessageData) := do\n  let ops \u2190 getOps op tgt\n  let atoms := (ops.map Prod.fst).flatten.toList.filter (!isBVar \u00b7)\n  let (instr, neverMatched) \u2190 pairUp data.toList atoms\n  let dbgMsg := #[m!\"Matching of input variables:\\n* pre-match:  {\n    data.map (Prod.snd \u2218 Prod.snd)}\\n* post-match: {instr}\",\n    m!\"\\nMaximum number of iterations: {ops.size}\"]\n  let errMsg := neverMatched.map fun (t, a, stx) => (if a then m!\"\u2190 {t}\" else m!\"{t}\", stx)\n  return (instr, errMsg.unzip, dbgMsg)", "start": [366, 1], "end": [388, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.MoveAdd.parseArrows", "code": "def parseArrows : TSyntax `Lean.Parser.Tactic.rwRuleSeq \u2192 TermElabM (Array (Expr \u00d7 Bool \u00d7 Syntax))\n  | `(rwRuleSeq| [$rs,*]) => do\n    rs.getElems.mapM fun rstx => do\n      let r : Syntax := rstx\n      return (\u2190 Term.elabTerm r[1]! none, ! r[0]!.isNone, rstx)\n  | _ => failure", "start": [393, 1], "end": [408, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/NatSqrt.lean", "imports": ["Mathlib/Data/Nat/Sqrt.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Tactic.NormNum.nat_sqrt_helper", "code": "lemma nat_sqrt_helper {x y r : \u2115} (hr : y * y + r = x) (hle : Nat.ble r (2 * y)) :\n    Nat.sqrt x = y := by\n  rw [\u2190 hr, \u2190 pow_two]\n  rw [two_mul] at hle\n  exact Nat.sqrt_add_eq' _ (Nat.le_of_ble_eq_true hle)", "start": [20, 1], "end": [24, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Tactic.NormNum.isNat_sqrt", "code": "theorem isNat_sqrt : {x nx z : \u2115} \u2192 IsNat x nx \u2192 Nat.sqrt nx = z \u2192 IsNat (Nat.sqrt x) z", "start": [26, 1], "end": [27, 33], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.proveNatSqrt", "code": "def proveNatSqrt (ex : Q(\u2115)) : (ey : Q(\u2115)) \u00d7 Q(Nat.sqrt $ex = $ey) :=\n  match ex.natLit! with\n  | 0 => show (ey : Q(\u2115)) \u00d7 Q(Nat.sqrt 0 = $ey) from \u27e8mkRawNatLit 0, q(Nat.sqrt_zero)\u27e9\n  | 1 => show (ey : Q(\u2115)) \u00d7 Q(Nat.sqrt 1 = $ey) from \u27e8mkRawNatLit 1, q(Nat.sqrt_one)\u27e9\n  | x =>\n    let y := Nat.sqrt x\n    have ey : Q(\u2115) := mkRawNatLit y\n    have er : Q(\u2115) := mkRawNatLit (x - y * y)\n    have hr : Q($ey * $ey + $er = $ex) := (q(Eq.refl $ex) : Expr)\n    have hle : Q(Nat.ble $er (2 * $ey)) := (q(Eq.refl true) : Expr)\n    \u27e8ey, q(nat_sqrt_helper $hr $hle)\u27e9", "start": [29, 1], "end": [41, 38], "kind": "commanddeclaration"}, {"full_name": "Tactic.NormNum.evalNatSqrt", "code": "@[norm_num Nat.sqrt _]\ndef evalNatSqrt : NormNumExt where eval {u \u03b1} e := do\n  let .app _ (x : Q(\u2115)) \u2190 Meta.whnfR e | failure\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8ex, p\u27e9 \u2190 deriveNat x s\u2115\n  let \u27e8ey, pf\u27e9 := proveNatSqrt ex\n  let pf' : Q(IsNat (Nat.sqrt $x) $ey) := q(isNat_sqrt $p $pf)\n  return .isNat s\u2115 ey pf'", "start": [43, 1], "end": [51, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/Conv.lean", "imports": ["Mathlib/Tactic/Widget/SelectPanelUtils.lean", "Mathlib/Data/String/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SolveReturn", "code": "private structure SolveReturn where\n  expr : Expr\n  val? : Option String\n  listRest : List Nat", "start": [19, 1], "end": [22, 22], "kind": "commanddeclaration"}, {"full_name": "solveLevel", "code": "private def solveLevel (expr : Expr) (path : List Nat) : MetaM SolveReturn := match expr with\n  | Expr.app _ _ => do\n    let mut descExp := expr\n    let mut count := 0\n    let mut explicitList := []\n\n    while descExp.isApp do\n      if (\u2190Lean.Meta.inferType descExp.appFn!).bindingInfo!.isExplicit then\n        explicitList := true::explicitList\n        count := count + 1\n      else\n        explicitList := false::explicitList\n      descExp := descExp.appFn!\n\n    let mut mutablePath := path\n    let mut length := count\n    explicitList := List.reverse explicitList\n    while !mutablePath.isEmpty && mutablePath.head! == 0 do\n      if explicitList.head! == true then\n        count := count - 1\n      explicitList := explicitList.tail!\n      mutablePath := mutablePath.tail!\n\n    let mut nextExp := expr\n    while length > count do\n      nextExp := nextExp.appFn!\n      length := length - 1\n    nextExp := nextExp.appArg!\n\n    let pathRest := if mutablePath.isEmpty then [] else mutablePath.tail!\n\n    return { expr := nextExp, val? := toString count , listRest := pathRest }\n\n  | Expr.lam n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.forallE n _ b _ => do\n    let name := match n with\n      | Name.str _ s => s\n      | _ => panic! \"no name found\"\n    return { expr := b, val? := name, listRest := path.tail! }\n\n  | Expr.mdata _ b => do\n    match b with\n      | Expr.mdata _ _ => return { expr := b, val? := none, listRest := path }\n      | _ => return { expr := b.appFn!.appArg!, val? := none, listRest := path.tail!.tail! }\n\n  | _ => do\n    return {\n      expr := \u2190(Lean.Core.viewSubexpr path.head! expr)\n      val? := toString (path.head! + 1)\n      listRest := path.tail!\n    }", "start": [24, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "insertEnter", "code": "@[nolint unusedArguments]\ndef insertEnter (locations : Array Lean.SubExpr.GoalsLocation) (goalType : Expr)\n    (params : SelectInsertParams): MetaM (String \u00d7 String \u00d7 Option (String.Pos \u00d7 String.Pos)) := do\n  let some pos := locations[0]? | throwError \"You must select something.\"\n  let \u27e8_, .target subexprPos\u27e9 := pos | throwError \"You must select something in the goal.\"\n  let mut list := (SubExpr.Pos.toArray subexprPos).toList\n    let mut expr := goalType\n  let mut retList := []\n  while !list.isEmpty do\n    let res \u2190 solveLevel expr list\n    expr := res.expr\n    retList := match res.val? with\n      | none => retList\n      | some val => val::retList\n    list := res.listRest\n\n  retList := List.reverse retList\n  let spc := String.replicate (SelectInsertParamsClass.replaceRange params).start.character ' '\n  let mut enterval := s!\"conv =>\\n{spc} enter {retList}\"\n  if enterval.contains '0' then enterval := \"Error: Not a valid conv target\"\n  if retList.isEmpty then enterval := \"\"\n  return (\"Generate conv\", enterval, none)", "start": [85, 1], "end": [110, 43], "kind": "commanddeclaration"}, {"full_name": "ConvSelectionPanel.rpc", "code": "@[server_rpc_method]\ndef ConvSelectionPanel.rpc :=\nmkSelectionPanelRPC insertEnter\n  \"Use shift-click to select one sub-expression in the goal that you want to zoom on.\"\n  \"Conv \ud83d\udd0d\" (onlyOne := true)", "start": [112, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "ConvSelectionPanel", "code": "@[widget_module]\ndef ConvSelectionPanel : Component SelectInsertParams :=\n  mk_rpc_widget% ConvSelectionPanel.rpc", "start": [119, 1], "end": [122, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CancelDenoms.lean", "imports": ["Mathlib/Tactic/NormNum/Ineq.lean", "Mathlib/Tactic/CancelDenoms/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Clean.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Expr.cleanConsts", "code": "def cleanConsts : List Name :=\n  [``id]", "start": [19, 1], "end": [23, 9], "kind": "commanddeclaration"}, {"full_name": "Lean.Expr.clean", "code": "def clean (e : Expr) : Expr :=\n  e.replace fun\n    | .app (.app (.const n _) _) e' => if n \u2208 cleanConsts then some e' else none\n    | .app (.lam _ _ (.bvar 0) _) e' => some e'\n    | e =>\n      match letFunAnnotation? e with\n      | some (.app (.lam _ _ (.bvar 0) _) e') => some e'\n      | _ => none", "start": [25, 1], "end": [34, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.elabClean", "code": "@[term_elab cleanStx, inherit_doc cleanStx]\ndef elabClean : Term.TermElab := fun stx expectedType? =>\n  match stx with\n  | `(clean% $t) => do\n    let e \u2190 Term.withSynthesize <| Term.elabTerm t expectedType?\n    return (\u2190 instantiateMVars e).clean\n  | _ => throwUnsupportedSyntax", "start": [60, 1], "end": [66, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Polyrith.lean", "imports": ["Mathlib/Data/Rat/Basic.lean", "Mathlib/Tactic/LinearCombination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Polyrith.Poly", "code": "inductive Poly\n  | const : \u211a \u2192 Poly\n  | var : \u2115 \u2192 Poly\n  | hyp : Term \u2192 Poly\n  | add : Poly \u2192 Poly \u2192 Poly\n  | sub : Poly \u2192 Poly \u2192 Poly\n  | mul : Poly \u2192 Poly \u2192 Poly\n  | div : Poly \u2192 Poly \u2192 Poly\n  | pow : Poly \u2192 Poly \u2192 Poly\n  | neg : Poly \u2192 Poly\n  deriving BEq, Repr", "start": [67, 1], "end": [81, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.format", "code": "def Poly.format : Poly \u2192 Lean.Format\n  | .const z => toString z\n  | .var n => s!\"var{n}\"\n  | .hyp e => s!\"hyp{e}\" | .add p q => s!\"({p.format} + {q.format})\"\n  | .sub p q => s!\"({p.format} - {q.format})\"\n  | .mul p q => s!\"({p.format} * {q.format})\"\n  | .div p q => s!\"({p.format} / {q.format})\" | .pow p q => s!\"({p.format} ^ {q.format})\"\n  | .neg p => s!\"-{p.format}\"", "start": [83, 1], "end": [99, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.toSyntax", "code": "def Poly.toSyntax : Poly \u2192 Unhygienic Syntax.Term\n  | .const z => pure (quote z)\n  | .var n => pure vars[n]!\n  | .hyp stx => pure stx\n  | .add p q => do `($(\u2190 p.toSyntax) + $(\u2190 q.toSyntax))\n  | .sub p q => do `($(\u2190 p.toSyntax) - $(\u2190 q.toSyntax))\n  | .mul p q => do `($(\u2190 p.toSyntax) * $(\u2190 q.toSyntax))\n  | .div p q => do `($(\u2190 p.toSyntax) / $(\u2190 q.toSyntax))\n  | .pow p q => do `($(\u2190 p.toSyntax) ^ $(\u2190 q.toSyntax))\n  | .neg p => do `(-$(\u2190 p.toSyntax))", "start": [116, 1], "end": [126, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.parse", "code": "partial def parse {u} {\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1))\n    (c : Ring.Cache s\u03b1) (e : Q($\u03b1)) : AtomM Poly := do\n  let els := do\n    try pure <| Poly.const (\u2190 (\u2190 NormNum.derive e).toRat)\n    catch _ => pure <| Poly.var (\u2190 addAtom e)\n  let .const n _ := (\u2190 withReducible <| whnf e).getAppFn | els\n  match n, c.r\u03b1 with\n  | ``HAdd.hAdd, _ | ``Add.add, _ => match e with\n    | ~q($a + $b) => pure <| (\u2190 parse s\u03b1 c a).add (\u2190 parse s\u03b1 c b)\n    | _ => els\n  | ``HMul.hMul, _ | ``Mul.mul, _ => match e with\n    | ~q($a * $b) => pure <| (\u2190 parse s\u03b1 c a).mul (\u2190 parse s\u03b1 c b)\n    | _ => els\n  | ``HSMul.hSMul, _ => match e with\n    | ~q(($a : \u2115) \u2022 ($b : \u00ab$\u03b1\u00bb)) => pure <| (\u2190 parse s\u2115 .nat a).mul (\u2190 parse s\u03b1 c b)\n    | _ => els\n  | ``HPow.hPow, _ | ``Pow.pow, _ => match e with\n    | ~q($a ^ $b) =>\n      try pure <| (\u2190 parse s\u03b1 c a).pow (.const (\u2190 (\u2190 NormNum.derive (u := .zero) b).toRat))\n      catch _ => els\n    | _ => els\n  | ``Neg.neg, some _ => match e with\n    | ~q(-$a) => pure <| (\u2190 parse s\u03b1 c a).neg\n  | ``HSub.hSub, some _ | ``Sub.sub, some _ => match e with\n    | ~q($a - $b) => pure <| (\u2190 parse s\u03b1 c a).sub (\u2190 parse s\u03b1 c b)\n    | _ => els\n  | _, _ => els", "start": [128, 1], "end": [155, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Source", "code": "inductive Source where\n  \n  | input : Nat \u2192 Source\n  \n  | fvar : FVarId \u2192 Source", "start": [157, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.parseContext", "code": "def parseContext (only : Bool) (hyps : Array Expr) (tgt : Expr) :\n    AtomM (Expr \u00d7 Array (Source \u00d7 Poly) \u00d7 Poly) := do\n  let fail {\u03b1} : AtomM \u03b1 := throwError \"polyrith failed: target is not an equality in semirings\"\n  let some (\u03b1, e\u2081, e\u2082) := (\u2190 whnfR <|\u2190 instantiateMVars tgt).eq? | fail\n  let .sort u \u2190 instantiateMVars (\u2190 whnf (\u2190 inferType \u03b1)) | unreachable!\n  let some v := u.dec | throwError \"not a type{indentExpr \u03b1}\"\n  have \u03b1 : Q(Type v) := \u03b1\n  have e\u2081 : Q($\u03b1) := e\u2081; have e\u2082 : Q($\u03b1) := e\u2082\n  let s\u03b1 \u2190 synthInstanceQ (q(CommSemiring $\u03b1) : Q(Type v))\n  let c \u2190 mkCache s\u03b1\n  let tgt := (\u2190 parse s\u03b1 c e\u2081).sub (\u2190 parse s\u03b1 c e\u2082)\n  let rec\n    \n    processHyp src ty out := do\n      if let some (\u03b2, e\u2081, e\u2082) := (\u2190 instantiateMVars ty).eq? then\n        if \u2190 withTransparency (\u2190 read).red <| isDefEq \u03b1 \u03b2 then\n          return out.push (src, (\u2190 parse s\u03b1 c e\u2081).sub (\u2190 parse s\u03b1 c e\u2082))\n      pure out\n  let mut out := #[]\n  if !only then\n    for ldecl in \u2190 getLCtx do\n      out \u2190 processHyp (.fvar ldecl.fvarId) ldecl.type out\n  for hyp in hyps, i in [:hyps.size] do\n    out \u2190 processHyp (.input i) (\u2190 inferType hyp) out\n  pure (\u03b1, out, tgt)", "start": [164, 1], "end": [189, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.createSageArgs", "code": "def createSageArgs (trace : Bool) (\u03b1 : Expr) (atoms : Nat)\n    (hyps : Array (Source \u00d7 Poly)) (tgt : Poly) : Array String :=\n  let hyps := hyps.map (toString \u00b7.2) |>.toList.toString\n  #[toString trace, toString \u03b1, toString atoms, hyps, toString tgt]", "start": [191, 1], "end": [195, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.unNeg?", "code": "def Poly.unNeg? : Poly \u2192 Option Poly\n  | .mul a b => return .mul (\u2190 a.unNeg?) b\n  | .const i => if i < 0 then some (.const (-i)) else none\n  | .neg p => p\n  | _ => none", "start": [202, 1], "end": [207, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.add'", "code": "def Poly.add' : Poly \u2192 Poly \u2192 Poly\n  | .const 0, p => match p.unNeg? with\n    | some np => .neg np\n    | none => p\n  | p, .const 0 => p\n  | a, b => match b.unNeg? with\n    | some nb => a.sub nb\n    | none => a.add b", "start": [209, 1], "end": [218, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.mul'", "code": "def Poly.mul' : Poly \u2192 Poly \u2192 Poly\n  | .const 0, _ => .const 0\n  | .const 1, p\n  | p, .const 1 => p\n  | a, b => a.mul b", "start": [220, 1], "end": [226, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.unDiv?", "code": "def Poly.unDiv? : Poly \u2192 Option (Poly \u00d7 \u2115)\n  | .mul a b => do let (a, r) \u2190 a.unDiv?; return (.mul' a b, r)\n  | .const r => if r.num = 1 \u2227 r.den \u2260 1 then some (.const r.num, r.den) else none\n  | .neg p => do let (p, r) \u2190 p.unDiv?; return (.neg p, r)\n  | _ => none", "start": [228, 1], "end": [233, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.pow'", "code": "def Poly.pow' : \u2115 \u2192 \u2115 \u2192 Poly\n  | _, 0 => .const 1\n  | i, 1 => .var i\n  | i, k => .pow (.var i) (.const k)", "start": [235, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.Poly.sumM", "code": "def Poly.sumM [Monad m] (a : Array \u03b1) (f : \u03b1 \u2192 m Poly) : m Poly :=\n  a.foldlM (init := .const 0) fun p a => return p.add' (\u2190 f a)", "start": [241, 1], "end": [243, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.SageSuccess", "code": "structure SageSuccess where\n  \n  trace : Option String := none\n  \n  data : Option (Array Poly) := none\n  deriving FromJson, Repr", "start": [253, 1], "end": [261, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.SageError", "code": "structure SageError where\n  \n  name : String\n  \n  value : String\n  deriving FromJson", "start": [263, 1], "end": [269, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.SageResult", "code": "def SageResult := Except SageError SageSuccess", "start": [271, 1], "end": [272, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.sageOutput", "code": "def sageOutput (args : Array String) : IO SageResult := do\n  let path := (\u2190 getMathlibDir) / \"scripts\" / \"polyrith_sage.py\"\n  unless \u2190 path.pathExists do\n    throw <| IO.userError \"could not find python script scripts/polyrith_sage.py\"\n  let out \u2190 IO.Process.output { cmd := \"python3\", args := #[path.toString] ++ args }\n  if out.exitCode != 0 then\n    throw <| IO.userError <|\n      s!\"scripts/polyrith_sage.py exited with code {out.exitCode}:\\n\\n{out.stderr}\"\n  match Json.parse out.stdout >>= fromJson? with\n  | .ok v => return v\n  | .error e => throw <| .userError e", "start": [280, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Polyrith.polyrith", "code": "def polyrith (g : MVarId) (only : Bool) (hyps : Array Expr)\n    (traceOnly := false) : MetaM (Except MVarId (TSyntax `tactic)) := do\n  IO.sleep 10 g.withContext <| AtomM.run .reducible do\n    let (\u03b1, hyps', tgt) \u2190 parseContext only hyps (\u2190 g.getType)\n    let rec\n      \n      byRing msg := do\n        let stx \u2190 `(tactic| ring)\n        try\n          let ([], _) \u2190 Elab.runTactic g stx | failure\n          return .ok stx\n        catch _ => throwError \"{msg} and the goal is not provable by ring\"\n    if hyps'.isEmpty then\n      return \u2190 byRing \"polyrith did not find any relevant hypotheses\"\n    let vars := (\u2190 get).atoms.size\n    match \u2190 sageOutput (createSageArgs traceOnly \u03b1 vars hyps' tgt) with\n    | .ok { trace, data } =>\n      if let some trace := trace then logInfo trace\n      if let some polys := data then\n        let vars \u2190 liftM <| (\u2190 get).atoms.mapM delab\n        let p \u2190 Poly.sumM (polys.zip hyps') fun (p, src, _) => do\n          let h := .hyp (\u2190 delab (match src with | .input i => hyps[i]! | .fvar h => .fvar h))\n          pure <| match p.unDiv? with\n          | some (p, den) => (p.mul' h).div (.const den)\n          | none => p.mul' h\n        let stx := (withRef (\u2190 getRef) <| p.toSyntax vars).run\n        let tac \u2190\n          if let .const 0 := p then `(tactic| linear_combination)\n          else `(tactic| linear_combination $stx:term)\n        try\n          guard (\u2190 Elab.runTactic g tac).1.isEmpty\n        catch _ => throwError\n          \"polyrith found the following certificate, but it failed to close the goal:\\n{stx}\"\n        pure <| .ok tac\n      else if traceOnly then\n        return .error g\n      else throwError \"internal error: no output available\"\n    | .error { name, value } =>\n      throwError \"polyrith failed to retrieve a solution from Sage! {name}: {value}\"", "start": [297, 1], "end": [361, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/CommDiag.lean", "imports": ["lake-packages/proofwidgets/ProofWidgets/Presentation/Expr.lean", "Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/proofwidgets/ProofWidgets/Component/PenroseDiagram.lean", "lake-packages/proofwidgets/ProofWidgets/Component/Panel/SelectionPanel.lean"], "premises": [{"full_name": "Lean.Expr.app7?", "code": "@[inline] def _root_.Lean.Expr.app7? (e : Expr) (fName : Name) :\n    Option (Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr \u00d7 Expr) :=\n  if e.isAppOfArity fName 7 then\n    some (\n      e.appFn!.appFn!.appFn!.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appFn!.appArg!,\n      e.appFn!.appFn!.appArg!,\n      e.appFn!.appArg!,\n      e.appArg!\n    )\n  else\n    none", "start": [17, 1], "end": [32, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.homType?", "code": "def homType? (e : Expr) : Option (Expr \u00d7 Expr) := do\n  let some (_, _, A, B) := e.app4? ``Quiver.Hom | none\n  return (A, B)", "start": [41, 1], "end": [44, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.homComp?", "code": "def homComp? (f : Expr) : Option (Expr \u00d7 Expr) := do\n  let some (_, _, _, _, _, f, g) := f.app7? ``CategoryStruct.comp | none\n  return (f, g)", "start": [46, 1], "end": [49, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.ExprEmbeds", "code": "abbrev ExprEmbeds := Array (String \u00d7 Expr)", "start": [51, 1], "end": [52, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.mkCommDiag", "code": "def mkCommDiag (sub : String) (embeds : ExprEmbeds) : MetaM Html := do\n  let embeds \u2190 embeds.mapM fun (s, h) =>\n      return (s, <InteractiveCode fmt={\u2190 Widget.ppExprTagged h} />)\n  return (\n    <PenroseDiagram\n      embeds={embeds}\n      dsl={include_str \"..\"/\"..\"/\"..\"/\"widget\"/\"src\"/\"penrose\"/\"commutative.dsl\"}\n      sty={include_str \"..\"/\"..\"/\"..\"/\"widget\"/\"src\"/\"penrose\"/\"commutative.sty\"}\n      sub={sub} />)", "start": [57, 1], "end": [67, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.subTriangle", "code": "def subTriangle := include_str \"..\"/\"..\"/\"..\"/\"widget\"/\"src\"/\"penrose\"/\"triangle.sub\"", "start": [71, 1], "end": [79, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.commTriangleM?", "code": "def commTriangleM? (e : Expr) : MetaM (Option Html) := do\n  let e \u2190 instantiateMVars e\n  let some (_, lhs, rhs) := e.eq? | return none\n  if let some (f, g) := homComp? lhs then\n    let some (A, C) := homType? (\u2190 inferType rhs) | return none\n    let some (_, B) := homType? (\u2190 inferType f) | return none\n    return some <| \u2190 mkCommDiag subTriangle\n      #[(\"A\", A), (\"B\", B), (\"C\", C),\n        (\"f\", f), (\"g\", g), (\"h\", rhs)]\n  let some (f, g) := homComp? rhs | return none\n  let some (A, C) := homType? (\u2190 inferType lhs) | return none\n  let some (_, B) := homType? (\u2190 inferType f) | return none\n  return some <| \u2190 mkCommDiag subTriangle\n    #[(\"A\", A), (\"B\", B), (\"C\", C),\n      (\"f\", f), (\"g\", g), (\"h\", lhs)]", "start": [81, 1], "end": [97, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.commutativeTrianglePresenter", "code": "@[expr_presenter]\ndef commutativeTrianglePresenter : ExprPresenter where\n  userName := \"Commutative triangle\"\n  layoutKind := .block\n  present type := do\n    if let some d \u2190 commTriangleM? type then\n      return d\n    throwError \"Couldn't find a commutative triangle.\"", "start": [99, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.subSquare", "code": "def subSquare := include_str \"..\"/\"..\"/\"..\"/\"widget\"/\"src\"/\"penrose\"/\"square.sub\"", "start": [110, 1], "end": [118, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.commSquareM?", "code": "def commSquareM? (e : Expr) : MetaM (Option Html) := do\n  let e \u2190 instantiateMVars e\n  let some (_, lhs, rhs) := e.eq? | return none\n  let some (f, g) := homComp? lhs | return none\n  let some (i, h) := homComp? rhs | return none\n  let some (A, B) := homType? (\u2190 inferType f) | return none\n  let some (D, C) := homType? (\u2190 inferType h) | return none\n  some <$> mkCommDiag subSquare\n    #[(\"A\", A), (\"B\", B), (\"C\", C), (\"D\", D),\n      (\"f\", f), (\"g\", g), (\"h\", h), (\"i\", i)]", "start": [120, 1], "end": [130, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Widget.commutativeSquarePresenter", "code": "@[expr_presenter]\ndef commutativeSquarePresenter : ExprPresenter where\n  userName := \"Commutative square\"\n  layoutKind := .block\n  present type := do\n    if let some d \u2190 commSquareM? type then\n      return d\n    throwError \"Couldn't find a commutative square.\"", "start": [132, 1], "end": [139, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ModCases.lean", "imports": ["Mathlib/Data/Int/ModEq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.ModCases.OnModCases", "code": "def OnModCases (n : \u2115) (a : \u2124) (lb : \u2115) (p : Sort*) :=\n\u2200 z, lb \u2264 z \u2227 z < n \u2227 a \u2261 \u2191z [ZMOD \u2191n] \u2192 p", "start": [19, 1], "end": [26, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ModCases.onModCases_start", "code": "@[inline] def onModCases_start (p : Sort*) (a : \u2124) (n : \u2115) (hn : Nat.ble 1 n = true)\n    (H : OnModCases n a (nat_lit 0) p) : p :=\n  H (a % \u2191n).toNat <| by\n    have := ofNat_pos.2 <| Nat.le_of_ble_eq_true hn\n    have nonneg := emod_nonneg a <| Int.ne_of_gt this\n    refine \u27e8Nat.zero_le _, ?_, ?_\u27e9\n    \u00b7 rw [Int.toNat_lt nonneg]; exact Int.emod_lt_of_pos _ this\n    \u00b7 rw [Int.ModEq, Int.toNat_of_nonneg nonneg, emod_emod]", "start": [28, 1], "end": [39, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ModCases.onModCases_stop", "code": "@[inline] def onModCases_stop (p : Sort*) (n : \u2115) (a : \u2124) : OnModCases n a n p :=\n  fun _ h => (Nat.not_lt.2 h.1 h.2.1).elim", "start": [41, 1], "end": [46, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ModCases.onModCases_succ", "code": "@[inline] def onModCases_succ {p : Sort*} {n : \u2115} {a : \u2124} (b : \u2115)\n    (h : a \u2261 OfNat.ofNat b [ZMOD OfNat.ofNat n] \u2192 p) (H : OnModCases n a (Nat.add b 1) p) :\n    OnModCases n a b p :=\n  fun z \u27e8h\u2081, h\u2082\u27e9 => if e : b = z then h (e \u25b8 h\u2082.2) else H _ \u27e8Nat.lt_of_le_of_ne h\u2081 e, h\u2082\u27e9", "start": [48, 1], "end": [56, 90], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ModCases.proveOnModCases", "code": "partial def proveOnModCases (n : Q(\u2115)) (a : Q(\u2124)) (b : Q(\u2115)) (p : Q(Sort u)) :\n    MetaM (Q(OnModCases $n $a $b $p) \u00d7 List MVarId) := do\n  if n.natLit! \u2264 b.natLit! then\n    haveI' : $b =Q $n := \u27e8\u27e9\n    pure (q(onModCases_stop $p $n $a), [])\n  else\n    let ty := q($a \u2261 OfNat.ofNat $b [ZMOD OfNat.ofNat $n] \u2192 $p)\n    let g \u2190 mkFreshExprMVarQ ty\n    have b1 : Q(\u2115) := mkRawNatLit (b.natLit! + 1)\n    haveI' : $b1 =Q ($b).succ := \u27e8\u27e9\n    let (pr, acc) \u2190 proveOnModCases n a b1 p\n    pure (q(onModCases_succ $b $g $pr), g.mvarId! :: acc)", "start": [58, 1], "end": [73, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Widget/Gcongr.lean", "imports": ["Mathlib/Tactic/GCongr.lean", "Mathlib/Tactic/Widget/SelectPanelUtils.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "makeGCongrString", "code": "@[nolint unusedArguments]\ndef makeGCongrString (pos : Array Lean.SubExpr.GoalsLocation) (goalType : Expr)\n    (_ : SelectInsertParams) : MetaM (String \u00d7 String \u00d7 Option (String.Pos \u00d7 String.Pos)) := do\nlet subexprPos := getGoalLocations pos\nunless goalType.isAppOf `LE.le || goalType.isAppOf `LT.lt || goalType.isAppOf `Int.ModEq do\n  panic! \"The goal must be a \u2264 or < or \u2261.\"\nlet mut goalTypeWithMetaVars := goalType\nfor pos in subexprPos do\n  goalTypeWithMetaVars \u2190 insertMetaVar goalTypeWithMetaVars pos\n\nlet side := if goalType.isAppOf `Int.ModEq then\n              if subexprPos[0]!.toArray[0]! = 0 then 1 else 2\n            else\n              if subexprPos[0]!.toArray[0]! = 0 then 2 else 3\nlet sideExpr := goalTypeWithMetaVars.getAppArgs[side]!\nlet res := \"gcongr \" ++ (toString (\u2190 Meta.ppExpr sideExpr)).renameMetaVar\nreturn (res, res, none)", "start": [17, 1], "end": [34, 24], "kind": "commanddeclaration"}, {"full_name": "GCongrSelectionPanel.rpc", "code": "@[server_rpc_method]\ndef GCongrSelectionPanel.rpc := mkSelectionPanelRPC makeGCongrString\n  \"Use shift-click to select sub-expressions in the goal that should become holes in gcongr.\"\n  \"GCongr \ud83d\udd0d\"", "start": [36, 1], "end": [40, 13], "kind": "commanddeclaration"}, {"full_name": "GCongrSelectionPanel", "code": "@[widget_module]\ndef GCongrSelectionPanel : Component SelectInsertParams :=\n  mk_rpc_widget% GCongrSelectionPanel.rpc", "start": [42, 1], "end": [45, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/BirkhoffSum/NormedSpace.lean", "imports": ["Mathlib/Data/IsROrC/Basic.lean", "Mathlib/Dynamics/BirkhoffSum/Average.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.IsFixedPt.tendsto_birkhoffAverage", "code": "theorem Function.IsFixedPt.tendsto_birkhoffAverage\n    (R : Type*) [DivisionSemiring R] [CharZero R]\n    [AddCommMonoid E] [TopologicalSpace E] [Module R E]\n    {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (h : f.IsFixedPt x) (g : \u03b1 \u2192 E) :\n    Tendsto (birkhoffAverage R f g \u00b7 x) atTop (\ud835\udcdd (g x))", "start": [27, 1], "end": [38, 39], "kind": "commanddeclaration"}, {"full_name": "dist_birkhoffSum_apply_birkhoffSum", "code": "theorem dist_birkhoffSum_apply_birkhoffSum (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x : \u03b1) :\n    dist (birkhoffSum f g n (f x)) (birkhoffSum f g n x) = dist (g (f^[n] x)) (g x)", "start": [42, 1], "end": [44, 62], "kind": "commanddeclaration"}, {"full_name": "dist_birkhoffSum_birkhoffSum_le", "code": "theorem dist_birkhoffSum_birkhoffSum_le (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffSum f g n x) (birkhoffSum f g n y) \u2264\n      \u2211 k in Finset.range n, dist (g (f^[k] x)) (g (f^[k] y))", "start": [46, 1], "end": [49, 24], "kind": "commanddeclaration"}, {"full_name": "dist_birkhoffAverage_birkhoffAverage", "code": "theorem dist_birkhoffAverage_birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) =\n      dist (birkhoffSum f g n x) (birkhoffSum f g n y) / n", "start": [53, 1], "end": [56, 53], "kind": "commanddeclaration"}, {"full_name": "dist_birkhoffAverage_birkhoffAverage_le", "code": "theorem dist_birkhoffAverage_birkhoffAverage_le (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) \u2264\n      (\u2211 k in Finset.range n, dist (g (f^[k] x)) (g (f^[k] y))) / n", "start": [58, 1], "end": [62, 50], "kind": "commanddeclaration"}, {"full_name": "dist_birkhoffAverage_apply_birkhoffAverage", "code": "theorem dist_birkhoffAverage_apply_birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n (f x)) (birkhoffAverage \ud835\udd5c f g n x) =\n      dist (g (f^[n] x)) (g x) / n", "start": [64, 1], "end": [67, 82], "kind": "commanddeclaration"}, {"full_name": "tendsto_birkhoffAverage_apply_sub_birkhoffAverage", "code": "theorem tendsto_birkhoffAverage_apply_sub_birkhoffAverage {f : \u03b1 \u2192 \u03b1} {g : \u03b1 \u2192 E} {x : \u03b1}\n    (h : Bornology.IsBounded (range (g <| f^[\u00b7] x))) :\n    Tendsto (fun n \u21a6 birkhoffAverage \ud835\udd5c f g n (f x) - birkhoffAverage \ud835\udd5c f g n x) atTop (\ud835\udcdd 0)", "start": [69, 1], "end": [84, 15], "kind": "commanddeclaration"}, {"full_name": "tendsto_birkhoffAverage_apply_sub_birkhoffAverage'", "code": "theorem tendsto_birkhoffAverage_apply_sub_birkhoffAverage' {g : \u03b1 \u2192 E}\n    (h : Bornology.IsBounded (range g)) (f : \u03b1 \u2192 \u03b1) (x : \u03b1):\n    Tendsto (fun n \u21a6 birkhoffAverage \ud835\udd5c f g n (f x) - birkhoffAverage \ud835\udd5c f g n x) atTop (\ud835\udcdd 0)", "start": [86, 1], "end": [95, 97], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_birkhoffAverage", "code": "theorem uniformEquicontinuous_birkhoffAverage (hf : LipschitzWith 1 f) (hg : UniformContinuous g) :\n    UniformEquicontinuous (birkhoffAverage \ud835\udd5c f g)", "start": [103, 1], "end": [122, 87], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_tendsto_birkhoffAverage", "code": "theorem isClosed_setOf_tendsto_birkhoffAverage\n    (hf : LipschitzWith 1 f) (hg : UniformContinuous g) (hl : Continuous l) :\n    IsClosed {x | Tendsto (birkhoffAverage \ud835\udd5c f g \u00b7 x) atTop (\ud835\udcdd (l x))}", "start": [124, 1], "end": [132, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/SimpleGraph/Ends/Defs.lean", "imports": ["Mathlib/Combinatorics/SimpleGraph/Connectivity.lean", "Mathlib/CategoryTheory/CofilteredSystem.lean", "Mathlib/Data/Finite/Set.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SimpleGraph.ComponentCompl", "code": "@[reducible]\ndef ComponentCompl :=\n  (G.induce K\u1d9c).ConnectedComponent", "start": [26, 1], "end": [29, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplMk", "code": "@[reducible]\ndef componentComplMk (G : SimpleGraph V) {v : V} (vK : v \u2209 K) : G.ComponentCompl K :=\n  connectedComponentMk (G.induce K\u1d9c) \u27e8v, vK\u27e9", "start": [34, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.supp", "code": "def ComponentCompl.supp (C : G.ComponentCompl K) : Set V :=\n  { v : V | \u2203 h : v \u2209 K, G.componentComplMk h = C }", "start": [40, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.supp_injective", "code": "@[ext]\ntheorem ComponentCompl.supp_injective :\n    Function.Injective (ComponentCompl.supp : G.ComponentCompl K \u2192 Set V)", "start": [45, 1], "end": [51, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.supp_inj", "code": "theorem ComponentCompl.supp_inj {C D : G.ComponentCompl K} : C.supp = D.supp \u2194 C = D", "start": [54, 1], "end": [55, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.setLike", "code": "instance ComponentCompl.setLike : SetLike (G.ComponentCompl K) V where\n  coe := ComponentCompl.supp\n  coe_injective' _ _ := ComponentCompl.supp_inj.mp", "start": [58, 1], "end": [60, 51], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.mem_supp_iff", "code": "@[simp]\ntheorem ComponentCompl.mem_supp_iff {v : V} {C : ComponentCompl G K} :\n    v \u2208 C \u2194 \u2203 vK : v \u2209 K, G.componentComplMk vK = C", "start": [63, 1], "end": [66, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplMk_mem", "code": "theorem componentComplMk_mem (G : SimpleGraph V) {v : V} (vK : v \u2209 K) : v \u2208 G.componentComplMk vK", "start": [69, 1], "end": [70, 12], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplMk_eq_of_adj", "code": "theorem componentComplMk_eq_of_adj (G : SimpleGraph V) {v w : V} (vK : v \u2209 K) (wK : w \u2209 K)\n    (a : G.Adj v w) : G.componentComplMk vK = G.componentComplMk wK", "start": [73, 1], "end": [77, 10], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentCompl_nonempty_of_infinite", "code": "instance componentCompl_nonempty_of_infinite (G : SimpleGraph V) [Infinite V] (K : Finset V) :\n    Nonempty (G.ComponentCompl K) :=\n  let \u27e8_, kK\u27e9 := K.finite_toSet.infinite_compl.nonempty\n  \u27e8componentComplMk _ kK\u27e9", "start": [80, 1], "end": [84, 26], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.lift", "code": "protected def lift {\u03b2 : Sort*} (f : \u2200 \u2983v\u2984 (_ : v \u2209 K), \u03b2)\n    (h : \u2200 \u2983v w\u2984 (hv : v \u2209 K) (hw : w \u2209 K) (_ : G.Adj v w), f hv = f hw) : G.ComponentCompl K \u2192 \u03b2 :=\n  ConnectedComponent.lift (fun vv => f vv.prop) fun v w p => by\n    induction' p with _ u v w a q ih\n    \u00b7 rintro _\n      rfl\n    \u00b7 rintro h'\n      exact (h u.prop v.prop a).trans (ih h'.of_cons)", "start": [88, 1], "end": [98, 54], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.ind", "code": "@[elab_as_elim] protected theorem ind {\u03b2 : G.ComponentCompl K \u2192 Prop}\n    (f : \u2200 \u2983v\u2984 (hv : v \u2209 K), \u03b2 (G.componentComplMk hv)) : \u2200 C : G.ComponentCompl K, \u03b2 C", "start": [101, 1], "end": [105, 30], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.coeGraph", "code": "@[reducible]\nprotected def coeGraph (C : ComponentCompl G K) : SimpleGraph C :=\n  G.induce (C : Set V)", "start": [108, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.coe_inj", "code": "theorem coe_inj {C D : G.ComponentCompl K} : (C : Set V) = (D : Set V) \u2194 C = D", "start": [114, 1], "end": [115, 21], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.nonempty", "code": "@[simp]\nprotected theorem nonempty (C : G.ComponentCompl K) : (C : Set V).Nonempty", "start": [118, 1], "end": [120, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.exists_eq_mk", "code": "protected theorem exists_eq_mk (C : G.ComponentCompl K) :\n    \u2203 (v : _) (h : v \u2209 K), G.componentComplMk h = C", "start": [123, 1], "end": [125, 13], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.disjoint_right", "code": "protected theorem disjoint_right (C : G.ComponentCompl K) : Disjoint K C", "start": [128, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.not_mem_of_mem", "code": "theorem not_mem_of_mem {C : G.ComponentCompl K} {c : V} (cC : c \u2208 C) : c \u2209 K", "start": [133, 1], "end": [134, 48], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.pairwise_disjoint", "code": "protected theorem pairwise_disjoint :\n    Pairwise fun C D : G.ComponentCompl K => Disjoint (C : Set V) (D : Set V)", "start": [137, 1], "end": [141, 72], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.mem_of_adj", "code": "theorem mem_of_adj : \u2200 {C : G.ComponentCompl K} (c d : V), c \u2208 C \u2192 d \u2209 K \u2192 G.Adj c d \u2192 d \u2208 C", "start": [144, 1], "end": [150, 33], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.exists_adj_boundary_pair", "code": "theorem exists_adj_boundary_pair (Gc : G.Preconnected) (hK : K.Nonempty) :\n    \u2200 C : G.ComponentCompl K, \u2203 ck : V \u00d7 V, ck.1 \u2208 C \u2227 ck.2 \u2208 K \u2227 G.Adj ck.1 ck.2", "start": [153, 1], "end": [171, 73], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom", "code": "@[reducible]\ndef hom (h : K \u2286 L) (C : G.ComponentCompl L) : G.ComponentCompl K :=\n  C.map <| induceHom Hom.id <| Set.compl_subset_compl.2 h", "start": [174, 1], "end": [179, 58], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.subset_hom", "code": "theorem subset_hom (C : G.ComponentCompl L) (h : K \u2286 L) : (C : Set V) \u2286 (C.hom h : Set V)", "start": [182, 1], "end": [184, 35], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplMk_mem_hom", "code": "theorem _root_.SimpleGraph.componentComplMk_mem_hom\n    (G : SimpleGraph V) {v : V} (vK : v \u2209 K) (h : L \u2286 K) :\n    v \u2208 (G.componentComplMk vK).hom h", "start": [187, 1], "end": [190, 67], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_eq_iff_le", "code": "theorem hom_eq_iff_le (C : G.ComponentCompl L) (h : K \u2286 L) (D : G.ComponentCompl K) :\n    C.hom h = D \u2194 (C : Set V) \u2286 (D : Set V)", "start": [193, 1], "end": [195, 85], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_eq_iff_not_disjoint", "code": "theorem hom_eq_iff_not_disjoint (C : G.ComponentCompl L) (h : K \u2286 L) (D : G.ComponentCompl K) :\n    C.hom h = D \u2194 \u00acDisjoint (C : Set V) (D : Set V)", "start": [198, 1], "end": [208, 8], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_refl", "code": "theorem hom_refl (C : G.ComponentCompl L) : C.hom (subset_refl L) = C", "start": [211, 1], "end": [213, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_trans", "code": "theorem hom_trans (C : G.ComponentCompl L) (h : K \u2286 L) (h' : M \u2286 K) :\n    C.hom (h'.trans h) = (C.hom h).hom h'", "start": [216, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_mk", "code": "theorem hom_mk {v : V} (vnL : v \u2209 L) (h : K \u2286 L) :\n    (G.componentComplMk vnL).hom h = G.componentComplMk (Set.not_mem_subset h vnL)", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.hom_infinite", "code": "theorem hom_infinite (C : G.ComponentCompl L) (h : K \u2286 L) (Cinf : (C : Set V).Infinite) :\n    (C.hom h : Set V).Infinite", "start": [228, 1], "end": [230, 42], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.ComponentCompl.infinite_iff_in_all_ranges", "code": "theorem infinite_iff_in_all_ranges {K : Finset V} (C : G.ComponentCompl K) :\n    C.supp.Infinite \u2194 \u2200 (L) (h : K \u2286 L), \u2203 D : G.ComponentCompl L, D.hom h = C", "start": [233, 1], "end": [246, 74], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentCompl_finite", "code": "instance componentCompl_finite [LocallyFinite G] [Gpc : Fact G.Preconnected] (K : Finset V) :\n    Finite (G.ComponentCompl K) := by\n  classical\n  rcases K.eq_empty_or_nonempty with rfl | h\n  \u00b7 dsimp [ComponentCompl]\n    rw [Finset.coe_empty, Set.compl_empty]\n    have := Gpc.out.subsingleton_connectedComponent\n    exact Finite.of_equiv _ (induceUnivIso G).connectedComponentEquiv.symm\n  \u00b7 let touch (C : G.ComponentCompl K) : {v : V | \u2203 k : V, k \u2208 K \u2227 G.Adj k v} :=\n      let p := C.exists_adj_boundary_pair Gpc.out h\n      \u27e8p.choose.1, p.choose.2, p.choose_spec.2.1, p.choose_spec.2.2.symm\u27e9\n    have touch_inj : touch.Injective := fun C D h' => ComponentCompl.pairwise_disjoint.eq\n      (Set.not_disjoint_iff.mpr \u27e8touch C, (C.exists_adj_boundary_pair Gpc.out h).choose_spec.1,\n                                 h'.symm \u25b8 (D.exists_adj_boundary_pair Gpc.out h).choose_spec.1\u27e9)\n    have : Finite (Set.range touch) := by\n      refine @Subtype.finite _ (Set.Finite.to_subtype ?_) _\n      apply Set.Finite.ofFinset (K.biUnion (fun v => G.neighborFinset v))\n      simp only [Finset.mem_biUnion, mem_neighborFinset, Set.mem_setOf_eq, implies_true]\n    apply Finite.of_injective_finite_range touch_inj", "start": [253, 1], "end": [278, 53], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.componentComplFunctor", "code": "@[simps]\ndef componentComplFunctor : (Finset V)\u1d52\u1d56 \u2964 Type u where\n  obj K := G.ComponentCompl K.unop\n  map f := ComponentCompl.hom (le_of_op_hom f)\n  map_id _ := funext fun C => C.hom_refl\n  map_comp h h' := funext fun C => C.hom_trans (le_of_op_hom h) (le_of_op_hom h')", "start": [286, 1], "end": [294, 82], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.end", "code": "protected def \u00abend\u00bb :=\n  (componentComplFunctor G).sections", "start": [297, 1], "end": [299, 37], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.end_hom_mk_of_mk", "code": "theorem end_hom_mk_of_mk {s} (sec : s \u2208 G.end) {K L : (Finset V)\u1d52\u1d56} (h : L \u27f6 K) {v : V}\n    (vnL : v \u2209 L.unop) (hs : s L = G.componentComplMk vnL) :\n    s K = G.componentComplMk (Set.not_mem_subset (le_of_op_hom h : _ \u2286 _) vnL)", "start": [302, 1], "end": [306, 57], "kind": "commanddeclaration"}, {"full_name": "SimpleGraph.infinite_iff_in_eventualRange", "code": "theorem infinite_iff_in_eventualRange {K : (Finset V)\u1d52\u1d56} (C : G.componentComplFunctor.obj K) :\n    C.supp.Infinite \u2194 C \u2208 G.componentComplFunctor.eventualRange K", "start": [309, 1], "end": [315, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/Abelian.lean", "imports": ["Mathlib/CategoryTheory/Preadditive/AdditiveFunctor.lean", "Mathlib/CategoryTheory/Sites/LeftExact.lean", "Mathlib/CategoryTheory/Abelian/Transfer.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Abelian/FunctorCategory.lean", "Mathlib/CategoryTheory/Preadditive/FunctorCategory.lean"], "premises": [{"full_name": "CategoryTheory.hasFiniteProductsSheaf", "code": "instance hasFiniteProductsSheaf : HasFiniteProducts (Sheaf J D) where\n  out j := { has_limit := fun F => by infer_instance }", "start": [52, 1], "end": [53, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sheafIsAbelian", "code": "instance sheafIsAbelian [HasFiniteLimits D] : Abelian (Sheaf J D) :=\n  let adj := sheafificationAdjunction J D\n  abelianOfAdjunction _ _ (asIso adj.counit) adj", "start": [66, 1], "end": [68, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.presheafToSheaf_additive", "code": "instance presheafToSheaf_additive : (presheafToSheaf J D).Additive :=\n  (presheafToSheaf J D).additive_of_preservesBinaryBiproducts", "start": [74, 1], "end": [75, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/GroupCat/Abelian.lean", "imports": ["Mathlib/Algebra/Category/GroupCat/Limits.lean", "Mathlib/Algebra/Category/GroupCat/Kernels.lean", "Mathlib/Algebra/Category/GroupCat/ZModuleEquivalence.lean", "Mathlib/Algebra/Category/ModuleCat/Abelian.lean", "Mathlib/CategoryTheory/Limits/ConcreteCategory.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Category/GroupCat/Colimits.lean", "Mathlib/CategoryTheory/Abelian/FunctorCategory.lean", "Mathlib/Algebra/Category/GroupCat/FilteredColimits.lean"], "premises": [{"full_name": "AddCommGroupCat.normalMono", "code": "def normalMono (_ : Mono f) : NormalMono f :=\n  equivalenceReflectsNormalMono (forget\u2082 (ModuleCat.{u} \u2124) AddCommGroupCat.{u}).inv <|\n    ModuleCat.normalMono _ inferInstance", "start": [31, 1], "end": [34, 41], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.normalEpi", "code": "def normalEpi (_ : Epi f) : NormalEpi f :=\n  equivalenceReflectsNormalEpi (forget\u2082 (ModuleCat.{u} \u2124) AddCommGroupCat.{u}).inv <|\n    ModuleCat.normalEpi _ inferInstance", "start": [38, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupCat.exact_iff", "code": "theorem exact_iff : Exact f g \u2194 f.range = g.ker", "start": [51, 1], "end": [57, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Condensed/Basic.lean", "imports": ["Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean", "Mathlib/CategoryTheory/Sites/Sheaf.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Condensed", "code": "def Condensed (C : Type w) [Category.{v} C] :=\n  Sheaf (coherentTopology CompHaus.{u}) C", "start": [42, 1], "end": [47, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Category/ModuleCat/Algebra.lean", "imports": ["Mathlib/Algebra/Algebra/RestrictScalars.lean", "Mathlib/Algebra/Category/ModuleCat/Basic.lean", "Mathlib/CategoryTheory/Linear/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ModuleCat.moduleOfAlgebraModule", "code": "def moduleOfAlgebraModule (M : ModuleCat.{v} A) : Module k M :=\n  RestrictScalars.module k A M", "start": [46, 1], "end": [48, 31], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.isScalarTower_of_algebra_moduleCat", "code": "theorem isScalarTower_of_algebra_moduleCat (M : ModuleCat.{v} A) : IsScalarTower k A M", "start": [53, 1], "end": [54, 38], "kind": "commanddeclaration"}, {"full_name": "ModuleCat.linearOverField", "code": "instance linearOverField : Linear k (ModuleCat.{v} A) where\n  homModule M N := LinearMap.module\n  smul_comp := by\n    intros\n    ext\n    dsimp only [coe_comp, Function.comp_apply]\n    rw [LinearMap.smul_apply, LinearMap.map_smul_of_tower]\n    rfl", "start": [63, 1], "end": [72, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/SemiNormedGroupCat.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/CategoryTheory/ConcreteCategory/BundledHom.lean", "Mathlib/CategoryTheory/Elementwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Limits/Shapes/ZeroMorphisms.lean"], "premises": [{"full_name": "SemiNormedGroupCat", "code": "def SemiNormedGroupCat : Type (u + 1) :=\n  Bundled SeminormedAddCommGroup", "start": [28, 1], "end": [30, 33], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.bundledHom", "code": "instance bundledHom : BundledHom @NormedAddGroupHom where\n  toFun := @NormedAddGroupHom.toFun\n  id := @NormedAddGroupHom.id\n  comp := @NormedAddGroupHom.comp", "start": [35, 1], "end": [38, 34], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.of", "code": "def of (M : Type u) [SeminormedAddCommGroup M] : SemiNormedGroupCat :=\n  Bundled.of M", "start": [53, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.toAddMonoidHomClass", "code": "instance toAddMonoidHomClass {V W : SemiNormedGroupCat} : AddMonoidHomClass (V \u27f6 W) V W where\n  coe := (forget SemiNormedGroupCat).map\n  coe_injective' := fun f g h => by cases f; cases g; congr\n  map_add f := f.map_add'\n  map_zero f := (AddMonoidHom.mk' f.toFun f.map_add').map_zero", "start": [62, 1], "end": [66, 63], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.ext", "code": "@[ext]\nlemma ext {M N : SemiNormedGroupCat} {f\u2081 f\u2082 : M \u27f6 N} (h : \u2200 (x : M), f\u2081 x = f\u2082 x) : f\u2081 = f\u2082 :=\n  FunLike.ext _ _ h", "start": [69, 1], "end": [71, 20], "kind": "mathlibtacticlemma"}, {"full_name": "SemiNormedGroupCat.coe_of", "code": "@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGroupCat.of V : Type u) = V", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.coe_id", "code": "@[simp (high)]\ntheorem coe_id (V : SemiNormedGroupCat) : (\ud835\udfd9 V : V \u2192 V) = id", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.coe_comp", "code": "@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGroupCat} (f : M \u27f6 N) (g : N \u27f6 K) :\n    (f \u226b g : M \u2192 K) = g \u2218 f", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.ofUnique", "code": "instance ofUnique (V : Type u) [SeminormedAddCommGroup V] [i : Unique V] :\n    Unique (SemiNormedGroupCat.of V) :=\n  i", "start": [94, 1], "end": [96, 4], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.zero_apply", "code": "@[simp]\ntheorem zero_apply {V W : SemiNormedGroupCat} (x : V) : (0 : V \u27f6 W) x = 0", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.isZero_of_subsingleton", "code": "theorem isZero_of_subsingleton (V : SemiNormedGroupCat) [Subsingleton V] : Limits.IsZero V", "start": [109, 1], "end": [112, 33], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.hasZeroObject", "code": "instance hasZeroObject : Limits.HasZeroObject SemiNormedGroupCat.{u} :=\n  \u27e8\u27e8of PUnit, isZero_of_subsingleton _\u27e9\u27e9", "start": [115, 1], "end": [116, 41], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat.iso_isometry_of_normNoninc", "code": "theorem iso_isometry_of_normNoninc {V W : SemiNormedGroupCat} (i : V \u2245 W) (h1 : i.hom.NormNoninc)\n    (h2 : i.inv.NormNoninc) : Isometry i.hom", "start": [119, 1], "end": [127, 26], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081", "code": "def SemiNormedGroupCat\u2081 : Type (u + 1) :=\n  Bundled SeminormedAddCommGroup", "start": [132, 1], "end": [136, 33], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.instFunLike", "code": "instance instFunLike (X Y : SemiNormedGroupCat\u2081) : FunLike (X \u27f6 Y) X (fun _ => Y) where\n  coe f := f.1.toFun\n  coe_injective' _ _ h := Subtype.val_inj.mp (NormedAddGroupHom.coe_injective h)", "start": [150, 1], "end": [152, 81], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.hom_ext", "code": "@[ext]\ntheorem hom_ext {M N : SemiNormedGroupCat\u2081} (f g : M \u27f6 N) (w : (f : M \u2192 N) = (g : M \u2192 N)) :\n    f = g", "start": [154, 1], "end": [157, 51], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.toAddMonoidHomClass", "code": "instance toAddMonoidHomClass {V W : SemiNormedGroupCat\u2081} : AddMonoidHomClass (V \u27f6 W) V W where\n  map_add f := f.1.map_add'\n  map_zero f := (AddMonoidHom.mk' f.1 f.1.map_add').map_zero", "start": [167, 1], "end": [169, 61], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.of", "code": "def of (M : Type u) [SeminormedAddCommGroup M] : SemiNormedGroupCat\u2081 :=\n  Bundled.of M", "start": [171, 1], "end": [173, 15], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.mkHom", "code": "def mkHom {M N : SemiNormedGroupCat} (f : M \u27f6 N) (i : f.NormNoninc) :\n    SemiNormedGroupCat\u2081.of M \u27f6 SemiNormedGroupCat\u2081.of N :=\n  \u27e8f, i\u27e9", "start": [179, 1], "end": [182, 9], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.mkHom_apply", "code": "theorem mkHom_apply {M N : SemiNormedGroupCat} (f : M \u27f6 N) (i : f.NormNoninc) (x) :\n    mkHom f i x = f x", "start": [186, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.mkIso", "code": "@[simps]\ndef mkIso {M N : SemiNormedGroupCat} (f : M \u2245 N) (i : f.hom.NormNoninc) (i' : f.inv.NormNoninc) :\n    SemiNormedGroupCat\u2081.of M \u2245 SemiNormedGroupCat\u2081.of N where\n  hom := mkHom f.hom i\n  inv := mkHom f.inv i'\n  hom_inv_id := by apply Subtype.eq; exact f.hom_inv_id\n  inv_hom_id := by apply Subtype.eq; exact f.inv_hom_id", "start": [191, 1], "end": [198, 56], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.coe_of", "code": "@[simp]\ntheorem coe_of (V : Type u) [SeminormedAddCommGroup V] : (SemiNormedGroupCat\u2081.of V : Type u) = V", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.coe_id", "code": "@[simp (high)]\ntheorem coe_id (V : SemiNormedGroupCat\u2081) : \u21d1(\ud835\udfd9 V) = id", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.coe_comp", "code": "@[simp (high)]\ntheorem coe_comp {M N K : SemiNormedGroupCat\u2081} (f : M \u27f6 N) (g : N \u27f6 K) :\n    (f \u226b g : M \u2192 K) = g \u2218 f", "start": [218, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.ofUnique", "code": "instance ofUnique (V : Type u) [SeminormedAddCommGroup V] [i : Unique V] :\n    Unique (SemiNormedGroupCat\u2081.of V) :=\n  i", "start": [230, 1], "end": [232, 4], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.zero_apply", "code": "@[simp]\ntheorem zero_apply {V W : SemiNormedGroupCat\u2081} (x : V) : (0 : V \u27f6 W) x = 0", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.isZero_of_subsingleton", "code": "theorem isZero_of_subsingleton (V : SemiNormedGroupCat\u2081) [Subsingleton V] : Limits.IsZero V", "start": [246, 1], "end": [249, 33], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.hasZeroObject", "code": "instance hasZeroObject : Limits.HasZeroObject SemiNormedGroupCat\u2081.{u} :=\n  \u27e8\u27e8of PUnit, isZero_of_subsingleton _\u27e9\u27e9", "start": [252, 1], "end": [253, 41], "kind": "commanddeclaration"}, {"full_name": "SemiNormedGroupCat\u2081.iso_isometry", "code": "theorem iso_isometry {V W : SemiNormedGroupCat\u2081} (i : V \u2245 W) : Isometry i.hom", "start": [256, 1], "end": [264, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/ExteriorAlgebra/Basic.lean", "imports": ["Mathlib/LinearAlgebra/CliffordAlgebra/Basic.lean", "Mathlib/LinearAlgebra/Alternating/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ExteriorAlgebra", "code": "@[reducible]\ndef ExteriorAlgebra :=\n  CliffordAlgebra (0 : QuadraticForm R M)", "start": [51, 1], "end": [55, 42], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9", "code": "@[reducible]\ndef \u03b9 : M \u2192\u2097[R] ExteriorAlgebra R M :=\n  CliffordAlgebra.\u03b9 _", "start": [62, 1], "end": [66, 22], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_sq_zero", "code": "theorem \u03b9_sq_zero (m : M) : \u03b9 R m * \u03b9 R m = 0", "start": [71, 1], "end": [74, 56], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.comp_\u03b9_sq_zero", "code": "theorem comp_\u03b9_sq_zero (g : ExteriorAlgebra R M \u2192\u2090[R] A) (m : M) : g (\u03b9 R m) * g (\u03b9 R m) = 0", "start": [80, 1], "end": [81, 52], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.lift", "code": "@[simps! symm_apply]\ndef lift : { f : M \u2192\u2097[R] A // \u2200 m, f m * f m = 0 } \u2243 (ExteriorAlgebra R M \u2192\u2090[R] A) :=\n  Equiv.trans (Equiv.subtypeEquiv (Equiv.refl _) <| by simp) <| CliffordAlgebra.lift _", "start": [86, 1], "end": [92, 87], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_comp_lift", "code": "@[simp]\ntheorem \u03b9_comp_lift (f : M \u2192\u2097[R] A) (cond : \u2200 m, f m * f m = 0) :\n    (lift R \u27e8f, cond\u27e9).toLinearMap.comp (\u03b9 R) = f", "start": [95, 1], "end": [98, 34], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.lift_\u03b9_apply", "code": "@[simp]\ntheorem lift_\u03b9_apply (f : M \u2192\u2097[R] A) (cond : \u2200 m, f m * f m = 0) (x) :\n    lift R \u27e8f, cond\u27e9 (\u03b9 R x) = f x", "start": [101, 1], "end": [104, 37], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.lift_unique", "code": "@[simp]\ntheorem lift_unique (f : M \u2192\u2097[R] A) (cond : \u2200 m, f m * f m = 0) (g : ExteriorAlgebra R M \u2192\u2090[R] A) :\n    g.toLinearMap.comp (\u03b9 R) = f \u2194 g = lift R \u27e8f, cond\u27e9", "start": [107, 1], "end": [110, 36], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.lift_comp_\u03b9", "code": "@[simp]\ntheorem lift_comp_\u03b9 (g : ExteriorAlgebra R M \u2192\u2090[R] A) :\n    lift R \u27e8g.toLinearMap.comp (\u03b9 R), comp_\u03b9_sq_zero _\u27e9 = g", "start": [115, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.hom_ext", "code": "@[ext]\ntheorem hom_ext {f g : ExteriorAlgebra R M \u2192\u2090[R] A}\n    (h : f.toLinearMap.comp (\u03b9 R) = g.toLinearMap.comp (\u03b9 R)) : f = g", "start": [121, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.induction", "code": "@[elab_as_elim]\ntheorem induction {C : ExteriorAlgebra R M \u2192 Prop}\n    (h_grade0 : \u2200 r, C (algebraMap R (ExteriorAlgebra R M) r)) (h_grade1 : \u2200 x, C (\u03b9 R x))\n    (h_mul : \u2200 a b, C a \u2192 C b \u2192 C (a * b)) (h_add : \u2200 a b, C a \u2192 C b \u2192 C (a + b))\n    (a : ExteriorAlgebra R M) : C a", "start": [128, 1], "end": [136, 60], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.algebraMapInv", "code": "def algebraMapInv : ExteriorAlgebra R M \u2192\u2090[R] R :=\n  ExteriorAlgebra.lift R \u27e8(0 : M \u2192\u2097[R] R), fun m => by simp\u27e9", "start": [139, 1], "end": [141, 61], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.algebraMap_leftInverse", "code": "theorem algebraMap_leftInverse :\n    Function.LeftInverse algebraMapInv (algebraMap R <| ExteriorAlgebra R M)", "start": [146, 1], "end": [148, 23], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.algebraMap_inj", "code": "@[simp]\ntheorem algebraMap_inj (x y : R) :\n    algebraMap R (ExteriorAlgebra R M) x = algebraMap R (ExteriorAlgebra R M) y \u2194 x = y", "start": [151, 1], "end": [154, 46], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.algebraMap_eq_zero_iff", "code": "@[simp]\ntheorem algebraMap_eq_zero_iff (x : R) : algebraMap R (ExteriorAlgebra R M) x = 0 \u2194 x = 0", "start": [157, 1], "end": [159, 72], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.algebraMap_eq_one_iff", "code": "@[simp]\ntheorem algebraMap_eq_one_iff (x : R) : algebraMap R (ExteriorAlgebra R M) x = 1 \u2194 x = 1", "start": [162, 1], "end": [164, 71], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.isUnit_algebraMap", "code": "theorem isUnit_algebraMap (r : R) : IsUnit (algebraMap R (ExteriorAlgebra R M) r) \u2194 IsUnit r", "start": [167, 1], "end": [168, 57], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.invertibleAlgebraMapEquiv", "code": "@[simps!]\ndef invertibleAlgebraMapEquiv (r : R) :\n    Invertible (algebraMap R (ExteriorAlgebra R M) r) \u2243 Invertible r :=\n  invertibleEquivOfLeftInverse _ _ _ (algebraMap_leftInverse M)", "start": [171, 1], "end": [175, 64], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.toTrivSqZeroExt", "code": "def toTrivSqZeroExt [Module R\u1d50\u1d52\u1d56 M] [IsCentralScalar R M] :\n    ExteriorAlgebra R M \u2192\u2090[R] TrivSqZeroExt R M :=\n  lift R \u27e8TrivSqZeroExt.inrHom R M, fun m => TrivSqZeroExt.inr_mul_inr R m m\u27e9", "start": [180, 1], "end": [184, 78], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.toTrivSqZeroExt_\u03b9", "code": "@[simp]\ntheorem toTrivSqZeroExt_\u03b9 [Module R\u1d50\u1d52\u1d56 M] [IsCentralScalar R M] (x : M) :\n    toTrivSqZeroExt (\u03b9 R x) = TrivSqZeroExt.inr x", "start": [187, 1], "end": [190, 23], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Inv", "code": "def \u03b9Inv : ExteriorAlgebra R M \u2192\u2097[R] M := by\n  letI : Module R\u1d50\u1d52\u1d56 M := Module.compHom _ ((RingHom.id R).fromOpposite mul_comm)\n  haveI : IsCentralScalar R M := \u27e8fun r m => rfl\u27e9\n  exact (TrivSqZeroExt.sndHom R M).comp toTrivSqZeroExt.toLinearMap", "start": [193, 1], "end": [200, 68], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_leftInverse", "code": "theorem \u03b9_leftInverse : Function.LeftInverse \u03b9Inv.1 (\u03b9 R : M \u2192 ExteriorAlgebra R M)", "start": [204, 1], "end": [208, 14], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_inj", "code": "@[simp]\ntheorem \u03b9_inj (x y : M) : \u03b9 R x = \u03b9 R y \u2194 x = y", "start": [213, 1], "end": [215, 33], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_eq_zero_iff", "code": "@[simp]\ntheorem \u03b9_eq_zero_iff (x : M) : \u03b9 R x = 0 \u2194 x = 0", "start": [220, 1], "end": [221, 95], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_eq_algebraMap_iff", "code": "@[simp]\ntheorem \u03b9_eq_algebraMap_iff (x : M) (r : R) : \u03b9 R x = algebraMap R _ r \u2194 x = 0 \u2227 r = 0", "start": [224, 1], "end": [234, 46], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_ne_one", "code": "@[simp]\ntheorem \u03b9_ne_one [Nontrivial R] (x : M) : \u03b9 R x \u2260 1", "start": [237, 1], "end": [240, 32], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_range_disjoint_one", "code": "theorem \u03b9_range_disjoint_one :\n    Disjoint (LinearMap.range (\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M))\n      (1 : Submodule R (ExteriorAlgebra R M))", "start": [243, 1], "end": [250, 30], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_add_mul_swap", "code": "@[simp]\ntheorem \u03b9_add_mul_swap (x y : M) : \u03b9 R x * \u03b9 R y + \u03b9 R y * \u03b9 R x = 0", "start": [253, 1], "end": [257, 25], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9_mul_prod_list", "code": "theorem \u03b9_mul_prod_list {n : \u2115} (f : Fin n \u2192 M) (i : Fin n) :\n    (\u03b9 R <| f i) * (List.ofFn fun i => \u03b9 R <| f i).prod = 0", "start": [260, 1], "end": [273, 47], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Multi", "code": "def \u03b9Multi (n : \u2115) : AlternatingMap R M (ExteriorAlgebra R M) (Fin n) :=\n  let F := (MultilinearMap.mkPiAlgebraFin R n (ExteriorAlgebra R M)).compLinearMap fun _ => \u03b9 R\n  { F with\n    map_eq_zero_of_eq' := fun f x y hfxy hxy => by\n      dsimp\n      clear F\n      wlog h : x < y\n      \u00b7 exact this R (A := A) n f y x hfxy.symm hxy.symm (hxy.lt_or_lt.resolve_left h)\n      clear hxy\n      induction' n with n hn\n      \u00b7 exact x.elim0\n      \u00b7 rw [List.ofFn_succ, List.prod_cons]\n        by_cases hx : x = 0\n        \u00b7 rw [hx] at hfxy h\n          rw [hfxy, \u2190 Fin.succ_pred y (ne_of_lt h).symm]\n          exact \u03b9_mul_prod_list (f \u2218 Fin.succ) _\n        \u00b7 convert mul_zero (\u03b9 R (f 0))\n          refine'\n            hn\n              (fun i => f <| Fin.succ i) (x.pred hx)\n              (y.pred (ne_of_lt <| lt_of_le_of_lt x.zero_le h).symm) _\n              (Fin.pred_lt_pred_iff.mpr h)\n          simp only [Fin.succ_pred]\n          exact hfxy\n    toFun := F }", "start": [278, 1], "end": [308, 17], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Multi_apply", "code": "theorem \u03b9Multi_apply {n : \u2115} (v : Fin n \u2192 M) : \u03b9Multi R n v = (List.ofFn fun i => \u03b9 R (v i)).prod", "start": [313, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Multi_zero_apply", "code": "@[simp]\ntheorem \u03b9Multi_zero_apply (v : Fin 0 \u2192 M) : \u03b9Multi R 0 v = 1", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Multi_succ_apply", "code": "@[simp]\ntheorem \u03b9Multi_succ_apply {n : \u2115} (v : Fin n.succ \u2192 M) :\n    \u03b9Multi R _ v = \u03b9 R (v 0) * \u03b9Multi R _ (Matrix.vecTail v)", "start": [322, 1], "end": [325, 64], "kind": "commanddeclaration"}, {"full_name": "ExteriorAlgebra.\u03b9Multi_succ_curryLeft", "code": "theorem \u03b9Multi_succ_curryLeft {n : \u2115} (m : M) :\n    (\u03b9Multi R n.succ).curryLeft m = (LinearMap.mulLeft R (\u03b9 R m)).compAlternatingMap (\u03b9Multi R n)", "start": [328, 1], "end": [333, 10], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toExterior", "code": "def toExterior : TensorAlgebra R M \u2192\u2090[R] ExteriorAlgebra R M :=\n  TensorAlgebra.lift R (ExteriorAlgebra.\u03b9 R : M \u2192\u2097[R] ExteriorAlgebra R M)", "start": [342, 1], "end": [345, 75], "kind": "commanddeclaration"}, {"full_name": "TensorAlgebra.toExterior_\u03b9", "code": "@[simp]\ntheorem toExterior_\u03b9 (m : M) :\n    TensorAlgebra.toExterior (TensorAlgebra.\u03b9 R m) = ExteriorAlgebra.\u03b9 R m", "start": [348, 1], "end": [351, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/VectorBundle/Hom.lean", "imports": ["Mathlib/Analysis/NormedSpace/OperatorNorm.lean", "Mathlib/Topology/VectorBundle/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bundle.ContinuousLinearMap", "code": "@[reducible]\nprotected def Bundle.ContinuousLinearMap [\u2200 x, TopologicalSpace (E\u2081 x)]\n    [\u2200 x, TopologicalSpace (E\u2082 x)] : \u2200 _ : B, Type _ := fun x => E\u2081 x \u2192SL[\u03c3] E\u2082 x", "start": [57, 1], "end": [64, 82], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.module", "code": "instance Bundle.ContinuousLinearMap.module [\u2200 x, TopologicalSpace (E\u2081 x)]\n    [\u2200 x, TopologicalSpace (E\u2082 x)] [\u2200 x, TopologicalAddGroup (E\u2082 x)]\n    [\u2200 x, ContinuousConstSMul \ud835\udd5c\u2082 (E\u2082 x)] : \u2200 x, Module \ud835\udd5c\u2082 (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082 x) :=\n  fun _ => inferInstance", "start": [68, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMapCoordChange", "code": "def continuousLinearMapCoordChange [e\u2081.IsLinear \ud835\udd5c\u2081] [e\u2081'.IsLinear \ud835\udd5c\u2081] [e\u2082.IsLinear \ud835\udd5c\u2082]\n    [e\u2082'.IsLinear \ud835\udd5c\u2082] (b : B) : (F\u2081 \u2192SL[\u03c3] F\u2082) \u2192L[\ud835\udd5c\u2082] F\u2081 \u2192SL[\u03c3] F\u2082 :=\n  ((e\u2081'.coordChangeL \ud835\udd5c\u2081 e\u2081 b).symm.arrowCongrSL (e\u2082.coordChangeL \ud835\udd5c\u2082 e\u2082' b) :\n    (F\u2081 \u2192SL[\u03c3] F\u2082) \u2243L[\ud835\udd5c\u2082] F\u2081 \u2192SL[\u03c3] F\u2082)", "start": [81, 1], "end": [89, 40], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousOn_continuousLinearMapCoordChange", "code": "theorem continuousOn_continuousLinearMapCoordChange [VectorBundle \ud835\udd5c\u2081 F\u2081 E\u2081] [VectorBundle \ud835\udd5c\u2082 F\u2082 E\u2082]\n    [MemTrivializationAtlas e\u2081] [MemTrivializationAtlas e\u2081'] [MemTrivializationAtlas e\u2082]\n    [MemTrivializationAtlas e\u2082'] :\n    ContinuousOn (continuousLinearMapCoordChange \u03c3 e\u2081 e\u2081' e\u2082 e\u2082')\n      (e\u2081.baseSet \u2229 e\u2082.baseSet \u2229 (e\u2081'.baseSet \u2229 e\u2082'.baseSet))", "start": [98, 1], "end": [118, 41], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMap", "code": "def continuousLinearMap :\n    Pretrivialization (F\u2081 \u2192SL[\u03c3] F\u2082) (\u03c0 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082)) where\n  toFun p := \u27e8p.1, .comp (e\u2082.continuousLinearMapAt \ud835\udd5c\u2082 p.1) (p.2.comp (e\u2081.symmL \ud835\udd5c\u2081 p.1))\u27e9\n  invFun p := \u27e8p.1, .comp (e\u2082.symmL \ud835\udd5c\u2082 p.1) (p.2.comp (e\u2081.continuousLinearMapAt \ud835\udd5c\u2081 p.1))\u27e9\n  source := Bundle.TotalSpace.proj \u207b\u00b9' (e\u2081.baseSet \u2229 e\u2082.baseSet)\n  target := (e\u2081.baseSet \u2229 e\u2082.baseSet) \u00d7\u02e2 Set.univ\n  map_source' := fun \u27e8x, L\u27e9 h => \u27e8h, Set.mem_univ _\u27e9\n  map_target' := fun \u27e8x, f\u27e9 h => h.1\n  left_inv' := fun \u27e8x, L\u27e9 \u27e8h\u2081, h\u2082\u27e9 => by\n    simp only [TotalSpace.mk_inj]\n    ext (v : E\u2081 x)\n    dsimp only [comp_apply]\n    rw [Trivialization.symmL_continuousLinearMapAt, Trivialization.symmL_continuousLinearMapAt]\n    exacts [h\u2081, h\u2082]\n  right_inv' := fun \u27e8x, f\u27e9 \u27e8\u27e8h\u2081, h\u2082\u27e9, _\u27e9 => by\n    simp only [Prod.mk_inj_left]\n    ext v\n    dsimp only [comp_apply]\n    rw [Trivialization.continuousLinearMapAt_symmL, Trivialization.continuousLinearMapAt_symmL]\n    exacts [h\u2081, h\u2082]\n  open_target := (e\u2081.open_baseSet.inter e\u2082.open_baseSet).prod isOpen_univ\n  baseSet := e\u2081.baseSet \u2229 e\u2082.baseSet\n  open_baseSet := e\u2081.open_baseSet.inter e\u2082.open_baseSet\n  source_eq := rfl\n  target_eq := rfl\n  proj_toFun _ _ := rfl", "start": [124, 1], "end": [154, 24], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMap.isLinear", "code": "instance continuousLinearMap.isLinear [\u2200 x, ContinuousAdd (E\u2082 x)] [\u2200 x, ContinuousSMul \ud835\udd5c\u2082 (E\u2082 x)] :\n    (Pretrivialization.continuousLinearMap \u03c3 e\u2081 e\u2082).IsLinear \ud835\udd5c\u2082 where\n  linear x _ :=\n    { map_add := fun L L' =>\n        show (e\u2082.continuousLinearMapAt \ud835\udd5c\u2082 x).comp ((L + L').comp (e\u2081.symmL \ud835\udd5c\u2081 x)) = _ by\n          simp_rw [add_comp, comp_add]\n          rfl\n      map_smul := fun c L =>\n        show (e\u2082.continuousLinearMapAt \ud835\udd5c\u2082 x).comp ((c \u2022 L).comp (e\u2081.symmL \ud835\udd5c\u2081 x)) = _ by\n          simp_rw [smul_comp, comp_smul\u209b\u2097, RingHom.id_apply]\n          rfl }", "start": [158, 1], "end": [168, 16], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMap_apply", "code": "theorem continuousLinearMap_apply (p : TotalSpace (F\u2081 \u2192SL[\u03c3] F\u2082) fun x => E\u2081 x \u2192SL[\u03c3] E\u2082 x) :\n    (continuousLinearMap \u03c3 e\u2081 e\u2082) p =\n      \u27e8p.1, .comp (e\u2082.continuousLinearMapAt \ud835\udd5c\u2082 p.1) (p.2.comp (e\u2081.symmL \ud835\udd5c\u2081 p.1))\u27e9", "start": [171, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMap_symm_apply", "code": "theorem continuousLinearMap_symm_apply (p : B \u00d7 (F\u2081 \u2192SL[\u03c3] F\u2082)) :\n    (continuousLinearMap \u03c3 e\u2081 e\u2082).toLocalEquiv.symm p =\n      \u27e8p.1, .comp (e\u2082.symmL \ud835\udd5c\u2082 p.1) (p.2.comp (e\u2081.continuousLinearMapAt \ud835\udd5c\u2081 p.1))\u27e9", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMap_symm_apply'", "code": "theorem continuousLinearMap_symm_apply' {b : B} (hb : b \u2208 e\u2081.baseSet \u2229 e\u2082.baseSet)\n    (L : F\u2081 \u2192SL[\u03c3] F\u2082) :\n    (continuousLinearMap \u03c3 e\u2081 e\u2082).symm b L =\n      (e\u2082.symmL \ud835\udd5c\u2082 b).comp (L.comp <| e\u2081.continuousLinearMapAt \ud835\udd5c\u2081 b)", "start": [183, 1], "end": [187, 33], "kind": "commanddeclaration"}, {"full_name": "Pretrivialization.continuousLinearMapCoordChange_apply", "code": "theorem continuousLinearMapCoordChange_apply (b : B)\n    (hb : b \u2208 e\u2081.baseSet \u2229 e\u2082.baseSet \u2229 (e\u2081'.baseSet \u2229 e\u2082'.baseSet)) (L : F\u2081 \u2192SL[\u03c3] F\u2082) :\n    continuousLinearMapCoordChange \u03c3 e\u2081 e\u2081' e\u2082 e\u2082' b L =\n      (continuousLinearMap \u03c3 e\u2081' e\u2082' \u27e8b, (continuousLinearMap \u03c3 e\u2081 e\u2082).symm b L\u27e9).2", "start": [190, 1], "end": [202, 46], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.vectorPrebundle", "code": "def Bundle.ContinuousLinearMap.vectorPrebundle :\n    VectorPrebundle \ud835\udd5c\u2082 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082) where\n  pretrivializationAtlas :=\n    {e | \u2203 (e\u2081 : Trivialization F\u2081 (\u03c0 F\u2081 E\u2081)) (e\u2082 : Trivialization F\u2082 (\u03c0 F\u2082 E\u2082))\n      (_ : MemTrivializationAtlas e\u2081) (_ : MemTrivializationAtlas e\u2082),\n        e = Pretrivialization.continuousLinearMap \u03c3 e\u2081 e\u2082}\n  pretrivialization_linear' := by\n    rintro _ \u27e8e\u2081, he\u2081, e\u2082, he\u2082, rfl\u27e9\n    infer_instance\n  pretrivializationAt x :=\n    Pretrivialization.continuousLinearMap \u03c3 (trivializationAt F\u2081 E\u2081 x) (trivializationAt F\u2082 E\u2082 x)\n  mem_base_pretrivializationAt x :=\n    \u27e8mem_baseSet_trivializationAt F\u2081 E\u2081 x, mem_baseSet_trivializationAt F\u2082 E\u2082 x\u27e9\n  pretrivialization_mem_atlas x :=\n    \u27e8trivializationAt F\u2081 E\u2081 x, trivializationAt F\u2082 E\u2082 x, inferInstance, inferInstance, rfl\u27e9\n  exists_coordChange := by\n    rintro _ \u27e8e\u2081, e\u2082, he\u2081, he\u2082, rfl\u27e9 _ \u27e8e\u2081', e\u2082', he\u2081', he\u2082', rfl\u27e9\n    exact \u27e8continuousLinearMapCoordChange \u03c3 e\u2081 e\u2081' e\u2082 e\u2082',\n      continuousOn_continuousLinearMapCoordChange,\n      continuousLinearMapCoordChange_apply \u03c3 e\u2081 e\u2081' e\u2082 e\u2082'\u27e9\n  totalSpaceMk_inducing := by\n    intro b\n    let L\u2081 : E\u2081 b \u2243L[\ud835\udd5c\u2081] F\u2081 :=\n      (trivializationAt F\u2081 E\u2081 b).continuousLinearEquivAt \ud835\udd5c\u2081 b\n        (mem_baseSet_trivializationAt _ _ _)\n    let L\u2082 : E\u2082 b \u2243L[\ud835\udd5c\u2082] F\u2082 :=\n      (trivializationAt F\u2082 E\u2082 b).continuousLinearEquivAt \ud835\udd5c\u2082 b\n        (mem_baseSet_trivializationAt _ _ _)\n    let \u03c6 : (E\u2081 b \u2192SL[\u03c3] E\u2082 b) \u2243L[\ud835\udd5c\u2082] F\u2081 \u2192SL[\u03c3] F\u2082 := L\u2081.arrowCongrSL L\u2082\n    have : Inducing fun x => (b, \u03c6 x) := inducing_const_prod.mpr \u03c6.toHomeomorph.inducing\n    convert this\n    ext f\n    dsimp [Pretrivialization.continuousLinearMap_apply]\n    rw [Trivialization.linearMapAt_def_of_mem _ (mem_baseSet_trivializationAt _ _ _)]\n    rfl", "start": [217, 1], "end": [255, 8], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.topologicalSpaceTotalSpace", "code": "instance Bundle.ContinuousLinearMap.topologicalSpaceTotalSpace :\n    TopologicalSpace (TotalSpace (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082)) :=\n  (Bundle.ContinuousLinearMap.vectorPrebundle \u03c3 F\u2081 E\u2081 F\u2082 E\u2082).totalSpaceTopology", "start": [258, 1], "end": [262, 80], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.fiberBundle", "code": "instance Bundle.ContinuousLinearMap.fiberBundle :\n    FiberBundle (F\u2081 \u2192SL[\u03c3] F\u2082) fun x => E\u2081 x \u2192SL[\u03c3] E\u2082 x :=\n  (Bundle.ContinuousLinearMap.vectorPrebundle \u03c3 F\u2081 E\u2081 F\u2082 E\u2082).toFiberBundle", "start": [265, 1], "end": [268, 75], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.vectorBundle", "code": "instance Bundle.ContinuousLinearMap.vectorBundle :\n    VectorBundle \ud835\udd5c\u2082 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082) :=\n  (Bundle.ContinuousLinearMap.vectorPrebundle \u03c3 F\u2081 E\u2081 F\u2082 E\u2082).toVectorBundle", "start": [271, 1], "end": [274, 76], "kind": "commanddeclaration"}, {"full_name": "Trivialization.continuousLinearMap", "code": "def Trivialization.continuousLinearMap :\n    Trivialization (F\u2081 \u2192SL[\u03c3] F\u2082) (\u03c0 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082)) :=\n  VectorPrebundle.trivializationOfMemPretrivializationAtlas _ \u27e8e\u2081, e\u2082, he\u2081, he\u2082, rfl\u27e9", "start": [279, 1], "end": [284, 86], "kind": "commanddeclaration"}, {"full_name": "Bundle.ContinuousLinearMap.memTrivializationAtlas", "code": "instance Bundle.ContinuousLinearMap.memTrivializationAtlas :\n    MemTrivializationAtlas\n      (e\u2081.continuousLinearMap \u03c3 e\u2082 :\n        Trivialization (F\u2081 \u2192SL[\u03c3] F\u2082) (\u03c0 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082))) where\n  out := \u27e8_, \u27e8e\u2081, e\u2082, by infer_instance, by infer_instance, rfl\u27e9, rfl\u27e9", "start": [287, 1], "end": [291, 71], "kind": "commanddeclaration"}, {"full_name": "Trivialization.baseSet_continuousLinearMap", "code": "@[simp]\ntheorem Trivialization.baseSet_continuousLinearMap :\n    (e\u2081.continuousLinearMap \u03c3 e\u2082).baseSet = e\u2081.baseSet \u2229 e\u2082.baseSet", "start": [296, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "Trivialization.continuousLinearMap_apply", "code": "theorem Trivialization.continuousLinearMap_apply\n    (p : TotalSpace (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082)) :\n    e\u2081.continuousLinearMap \u03c3 e\u2082 p =\n      \u27e8p.1, (e\u2082.continuousLinearMapAt \ud835\udd5c\u2082 p.1 : _ \u2192L[\ud835\udd5c\u2082] _).comp\n        (p.2.comp (e\u2081.symmL \ud835\udd5c\u2081 p.1 : F\u2081 \u2192L[\ud835\udd5c\u2081] E\u2081 p.1) : F\u2081 \u2192SL[\u03c3] E\u2082 p.1)\u27e9", "start": [302, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "hom_trivializationAt_apply", "code": "theorem hom_trivializationAt_apply (x\u2080 : B)\n    (x : TotalSpace (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082)) :\n    trivializationAt (F\u2081 \u2192SL[\u03c3] F\u2082) (fun x => E\u2081 x \u2192SL[\u03c3] E\u2082 x) x\u2080 x =\n      \u27e8x.1, inCoordinates F\u2081 E\u2081 F\u2082 E\u2082 x\u2080 x.1 x\u2080 x.1 x.2\u27e9", "start": [310, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "hom_trivializationAt_source", "code": "@[simp, mfld_simps]\ntheorem hom_trivializationAt_source (x\u2080 : B) :\n    (trivializationAt (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082) x\u2080).source =\n      \u03c0 (F\u2081 \u2192SL[\u03c3] F\u2082) (Bundle.ContinuousLinearMap \u03c3 E\u2081 E\u2082) \u207b\u00b9'\n        ((trivializationAt F\u2081 E\u2081 x\u2080).baseSet \u2229 (trivializationAt F\u2082 E\u2082 x\u2080).baseSet)", "start": [317, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "hom_trivializationAt_target", "code": "@[simp, mfld_simps]\ntheorem hom_trivializationAt_target (x\u2080 : B) :\n    (trivializationAt (F\u2081 \u2192SL[\u03c3] F\u2082) (fun x => E\u2081 x \u2192SL[\u03c3] E\u2082 x) x\u2080).target =\n      ((trivializationAt F\u2081 E\u2081 x\u2080).baseSet \u2229 (trivializationAt F\u2082 E\u2082 x\u2080).baseSet) \u00d7\u02e2 Set.univ", "start": [325, 1], "end": [329, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/Norm.lean", "imports": ["Mathlib/NumberTheory/NumberField/Basic.lean", "Mathlib/RingTheory/Norm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingOfIntegers.norm", "code": "@[simps!]\nnoncomputable def norm [IsSeparable K L] : \ud835\udcde L \u2192* \ud835\udcde K :=\n  ((Algebra.norm K).restrict (\ud835\udcde L)).codRestrict (\ud835\udcde K) fun x => isIntegral_norm K x.2", "start": [33, 1], "end": [36, 85], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.coe_algebraMap_norm", "code": "theorem coe_algebraMap_norm [IsSeparable K L] (x : \ud835\udcde L) :\n    (algebraMap (\ud835\udcde K) (\ud835\udcde L) (norm K x) : L) = algebraMap K L (Algebra.norm K (x : L))", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.coe_norm_algebraMap", "code": "theorem coe_norm_algebraMap [IsSeparable K L] (x : \ud835\udcde K) :\n    (norm K (algebraMap (\ud835\udcde K) (\ud835\udcde L) x) : K) = Algebra.norm K (algebraMap K L x)", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.norm_algebraMap", "code": "theorem norm_algebraMap [IsSeparable K L] (x : \ud835\udcde K) :\n    norm K (algebraMap (\ud835\udcde K) (\ud835\udcde L) x) = x ^ finrank K L", "start": [49, 1], "end": [52, 30], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.isUnit_norm_of_isGalois", "code": "theorem isUnit_norm_of_isGalois [IsGalois K L] {x : \ud835\udcde L} : IsUnit (norm K x) \u2194 IsUnit x", "start": [55, 1], "end": [68, 88], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.dvd_norm", "code": "theorem dvd_norm [IsGalois K L] (x : \ud835\udcde L) : x \u2223 algebraMap (\ud835\udcde K) (\ud835\udcde L) (norm K x)", "start": [71, 1], "end": [80, 62], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.norm_norm", "code": "theorem norm_norm [IsSeparable K L] [Algebra F L] [IsSeparable F L] [FiniteDimensional F L]\n    [IsScalarTower K F L] (x : \ud835\udcde L) : norm K (norm F x) = norm K x", "start": [85, 1], "end": [87, 92], "kind": "commanddeclaration"}, {"full_name": "RingOfIntegers.isUnit_norm", "code": "theorem isUnit_norm [CharZero K] {x : \ud835\udcde F} : IsUnit (norm K x) \u2194 IsUnit x", "start": [92, 1], "end": [107, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/NumberField/CanonicalEmbedding.lean", "imports": ["Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Module/Zlattice.lean", "Mathlib/MeasureTheory/Measure/Haar/NormedSpace.lean", "Mathlib/RingTheory/Discriminant.lean", "Mathlib/NumberTheory/NumberField/Embeddings.lean"], "premises": [{"full_name": "NumberField.canonicalEmbedding", "code": "def _root_.NumberField.canonicalEmbedding : K \u2192+* ((K \u2192+* \u2102) \u2192 \u2102) := Pi.ringHom fun \u03c6 => \u03c6", "start": [52, 1], "end": [53, 91], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding_injective", "code": "theorem _root_.NumberField.canonicalEmbedding_injective [NumberField K] :\n    Function.Injective (NumberField.canonicalEmbedding K)", "start": [55, 1], "end": [56, 81], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.apply_at", "code": "@[simp]\ntheorem apply_at (\u03c6 : K \u2192+* \u2102) (x : K) : (NumberField.canonicalEmbedding K x) \u03c6 = \u03c6 x", "start": [60, 1], "end": [61, 93], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.conj_apply", "code": "theorem conj_apply {x : ((K \u2192+* \u2102) \u2192 \u2102)} (\u03c6 : K \u2192+* \u2102)\n    (hx : x \u2208 Submodule.span \u211d (Set.range (canonicalEmbedding K))) :\n    conj (x \u03c6) = x (ComplexEmbedding.conjugate \u03c6)", "start": [65, 1], "end": [76, 36], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.nnnorm_eq", "code": "theorem nnnorm_eq [NumberField K] (x : K) :\n    \u2016canonicalEmbedding K x\u2016\u208a = Finset.univ.sup (fun \u03c6 : K \u2192+* \u2102 => \u2016\u03c6 x\u2016\u208a)", "start": [78, 1], "end": [80, 36], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.norm_le_iff", "code": "theorem norm_le_iff [NumberField K] (x : K) (r : \u211d) :\n    \u2016canonicalEmbedding K x\u2016 \u2264 r \u2194 \u2200 \u03c6 : K \u2192+* \u2102, \u2016\u03c6 x\u2016 \u2264 r", "start": [82, 1], "end": [91, 24], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.integerLattice", "code": "def integerLattice : Subring ((K \u2192+* \u2102) \u2192 \u2102) :=\n  (RingHom.range (algebraMap (\ud835\udcde K) K)).map (canonicalEmbedding K)", "start": [95, 1], "end": [97, 66], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.integerLattice.inter_ball_finite", "code": "theorem integerLattice.inter_ball_finite [NumberField K] (r : \u211d) :\n    ((integerLattice K : Set ((K \u2192+* \u2102) \u2192 \u2102)) \u2229 Metric.closedBall 0 r).Finite", "start": [99, 1], "end": [111, 57], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.latticeBasis", "code": "noncomputable def latticeBasis [NumberField K] :\n    Basis (Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) \u2102 ((K \u2192+* \u2102) \u2192 \u2102) := by\n  classical\n  let B := Pi.basisFun \u2102 (K \u2192+* \u2102)\n    let e : (K \u2192+* \u2102) \u2243 Free.ChooseBasisIndex \u2124 (\ud835\udcde K) :=\n      equivOfCardEq ((Embeddings.card K \u2102).trans (finrank_eq_card_basis (integralBasis K)))\n    let M := B.toMatrix (fun i => canonicalEmbedding K (integralBasis K (e i)))\n    suffices M.det \u2260 0 by\n      rw [\u2190 isUnit_iff_ne_zero, \u2190 Basis.det_apply, \u2190 is_basis_iff_det] at this\n      refine basisOfLinearIndependentOfCardEqFinrank\n        ((linearIndependent_equiv e.symm).mpr this.1) ?_\n      rw [\u2190 finrank_eq_card_chooseBasisIndex, RingOfIntegers.rank, finrank_fintype_fun_eq_card,\n        Embeddings.card]\n  let N := Algebra.embeddingsMatrixReindex \u211a \u2102 (fun i => integralBasis K (e i))\n      RingHom.equivRatAlgHom\n    rw [show M = N.transpose by { ext:2; rfl }]\n    rw [Matrix.det_transpose, \u2190 @pow_ne_zero_iff \u2102 _ _ _ 2 (by norm_num)]\n    convert (map_ne_zero_iff _ (algebraMap \u211a \u2102).injective).mpr\n      (Algebra.discr_not_zero_of_basis \u211a (integralBasis K))\n    rw [\u2190 Algebra.discr_reindex \u211a (integralBasis K) e.symm]\n    exact (Algebra.discr_eq_det_embeddingsMatrixReindex_pow_two \u211a \u2102\n      (fun i => integralBasis K (e i)) RingHom.equivRatAlgHom).symm", "start": [115, 1], "end": [142, 68], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.latticeBasis_apply", "code": "@[simp]\ntheorem latticeBasis_apply [NumberField K] (i : Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) :\n    latticeBasis K i = (canonicalEmbedding K) (integralBasis K i)", "start": [144, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "NumberField.canonicalEmbedding.mem_span_latticeBasis", "code": "theorem mem_span_latticeBasis [NumberField K] (x : (K \u2192+* \u2102) \u2192 \u2102) :\n    x \u2208 Submodule.span \u2124 (Set.range (latticeBasis K)) \u2194 x \u2208 canonicalEmbedding K '' (\ud835\udcde K)", "start": [150, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding", "code": "noncomputable def _root_.NumberField.mixedEmbedding : K \u2192+* (E K) :=\n  RingHom.prod (Pi.ringHom fun w => embedding_of_isReal w.prop)\n    (Pi.ringHom fun w => w.val.embedding)", "start": [170, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.finrank", "code": "protected theorem finrank [NumberField K] : finrank \u211d (E K) = finrank \u211a K", "start": [183, 1], "end": [188, 51], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding_injective", "code": "theorem _root_.NumberField.mixedEmbedding_injective [NumberField K] :\n    Function.Injective (NumberField.mixedEmbedding K)", "start": [190, 1], "end": [192, 28], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.commMap", "code": "noncomputable def commMap : ((K \u2192+* \u2102) \u2192 \u2102) \u2192\u2097[\u211d] (E K) :=\n{ toFun := fun x => \u27e8fun w => (x w.val.embedding).re, fun w => x w.val.embedding\u27e9\n  map_add' := by\n    simp only [Pi.add_apply, Complex.add_re, Prod.mk_add_mk, Prod.mk.injEq]\n    exact fun _ _ => \u27e8rfl, rfl\u27e9\n  map_smul' := by\n    simp only [Pi.smul_apply, Complex.real_smul, Complex.mul_re, Complex.ofReal_re,\n      Complex.ofReal_im, zero_mul, sub_zero, RingHom.id_apply, Prod.smul_mk, Prod.mk.injEq]\n    exact fun _ _ => \u27e8rfl, rfl\u27e9 }", "start": [196, 1], "end": [206, 34], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.commMap_apply_of_isReal", "code": "theorem commMap_apply_of_isReal (x : (K \u2192+* \u2102) \u2192 \u2102) {w : InfinitePlace K} (hw : IsReal w) :\n    (commMap K x).1 \u27e8w, hw\u27e9 = (x w.embedding).re", "start": [208, 1], "end": [209, 56], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.commMap_apply_of_isComplex", "code": "theorem commMap_apply_of_isComplex (x : (K \u2192+* \u2102) \u2192 \u2102) {w : InfinitePlace K} (hw : IsComplex w) :\n    (commMap K x).2 \u27e8w, hw\u27e9 = x w.embedding", "start": [211, 1], "end": [212, 51], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.commMap_canonical_eq_mixed", "code": "@[simp]\ntheorem commMap_canonical_eq_mixed (x : K) :\n    commMap K (canonicalEmbedding K x) = mixedEmbedding K x", "start": [214, 1], "end": [219, 19], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.disjoint_span_commMap_ker", "code": "theorem disjoint_span_commMap_ker [NumberField K]:\n    Disjoint (Submodule.span \u211d (Set.range (canonicalEmbedding.latticeBasis K)))\n      (LinearMap.ker (commMap K))", "start": [221, 1], "end": [247, 57], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.latticeBasis", "code": "noncomputable def latticeBasis [NumberField K] :\n    Basis (Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) \u211d (E K) := by\n  classical\n    have := LinearIndependent.map (LinearIndependent.restrict_scalars\n      (by { simpa only [Complex.real_smul, mul_one] using Complex.ofReal_injective })\n      (canonicalEmbedding.latticeBasis K).linearIndependent)\n      (disjoint_span_commMap_ker K)\n    refine basisOfLinearIndependentOfCardEqFinrank this ?_\n    rw [\u2190 finrank_eq_card_chooseBasisIndex, RingOfIntegers.rank, finrank_prod, finrank_pi,\n      finrank_pi_fintype, Complex.finrank_real_complex, Finset.sum_const, Finset.card_univ,\n      \u2190 card_real_embeddings, Algebra.id.smul_eq_mul, mul_comm, \u2190 card_complex_embeddings,\n      \u2190 NumberField.Embeddings.card K \u2102, Fintype.card_subtype_compl,\n      Nat.add_sub_of_le (Fintype.card_subtype_le _)]", "start": [255, 1], "end": [271, 53], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.latticeBasis_apply", "code": "@[simp]\ntheorem latticeBasis_apply [NumberField K] (i : Free.ChooseBasisIndex \u2124 (\ud835\udcde K)) :\n    latticeBasis K i = (mixedEmbedding K) (integralBasis K i)", "start": [273, 1], "end": [277, 92], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.mem_span_latticeBasis", "code": "theorem mem_span_latticeBasis [NumberField K] (x : (E K)) :\n    x \u2208 Submodule.span \u2124 (Set.range (latticeBasis K)) \u2194 x \u2208 mixedEmbedding K '' (\ud835\udcde K)", "start": [279, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLt", "code": "abbrev convexBodyLt : Set (E K) :=\n  (Set.univ.pi (fun w : { w : InfinitePlace K // IsReal w } => ball 0 (f w))) \u00d7\u02e2\n  (Set.univ.pi (fun w : { w : InfinitePlace K // IsComplex w } => ball 0 (f w)))", "start": [297, 1], "end": [301, 81], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLt_mem", "code": "theorem convexBodyLt_mem {x : K} :\n    mixedEmbedding K x \u2208 (convexBodyLt K f) \u2194 \u2200 w : InfinitePlace K, w x < f w", "start": [303, 1], "end": [308, 41], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLt_symmetric", "code": "theorem convexBodyLt_symmetric (x : E K) (hx : x \u2208 (convexBodyLt K f)) :\n    -x \u2208 (convexBodyLt K f)", "start": [310, 1], "end": [315, 11], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLt_convex", "code": "theorem convexBodyLt_convex : Convex \u211d (convexBodyLt K f)", "start": [317, 1], "end": [318, 96], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLtFactor", "code": "noncomputable abbrev convexBodyLtFactor : \u211d\u22650\u221e :=\n  (2 : \u211d\u22650\u221e) ^ card {w : InfinitePlace K // IsReal w} *\n    volume (ball (0 : \u2102) 1) ^ card {w : InfinitePlace K // IsComplex w}", "start": [327, 1], "end": [330, 72], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLtFactor_pos", "code": "theorem convexBodyLtFactor_pos : 0 < (convexBodyLtFactor K)", "start": [332, 1], "end": [334, 78], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLtFactor_lt_top", "code": "theorem convexBodyLtFactor_lt_top : (convexBodyLtFactor K) < \u22a4", "start": [336, 1], "end": [339, 54], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.convexBodyLt_volume", "code": "theorem convexBodyLt_volume :\n    volume (convexBodyLt K f) = (convexBodyLtFactor K) * \u220f w, (f w) ^ (mult w)", "start": [341, 1], "end": [370, 101], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.adjust_f", "code": "theorem adjust_f {w\u2081 : InfinitePlace K} (B : \u211d\u22650) (hf : \u2200 w, w \u2260 w\u2081\u2192 f w \u2260 0) :\n    \u2203 g : InfinitePlace K \u2192 \u211d\u22650, (\u2200 w, w \u2260 w\u2081 \u2192 g w = f w) \u2227 \u220f w, (g w) ^ mult w = B", "start": [374, 1], "end": [388, 40], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.minkowskiBound", "code": "noncomputable def minkowskiBound : \u211d\u22650\u221e :=\n  volume (fundamentalDomain (latticeBasis K)) * 2 ^ (finrank \u211d (E K))", "start": [398, 1], "end": [401, 70], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.minkowskiBound_lt_top", "code": "theorem minkowskiBound_lt_top : minkowskiBound K < \u22a4", "start": [403, 1], "end": [406, 69], "kind": "commanddeclaration"}, {"full_name": "NumberField.mixedEmbedding.exists_ne_zero_mem_ringOfIntegers_lt", "code": "theorem exists_ne_zero_mem_ringOfIntegers_lt (h : minkowskiBound K < volume (convexBodyLt K f)) :\n    \u2203 (a : \ud835\udcde K), a \u2260 0 \u2227 \u2200 w : InfinitePlace K, w a < f w", "start": [410, 1], "end": [428, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/Norm.lean", "imports": ["Mathlib/RingTheory/DedekindDomain/PID.lean", "Mathlib/RingTheory/Localization/NormTrace.lean", "Mathlib/LinearAlgebra/FreeModule/Determinant.lean", "Mathlib/Data/Int/Associated.lean", "Mathlib/Algebra/CharP/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/LocalProperties.lean", "Mathlib/Data/Int/AbsoluteValue.lean", "Mathlib/Data/Finsupp/Fintype.lean", "Mathlib/LinearAlgebra/FreeModule/IdealQuotient.lean"], "premises": [{"full_name": "Submodule.cardQuot", "code": "noncomputable def cardQuot (S : Submodule R M) : \u2115 :=\n  AddSubgroup.index S.toAddSubgroup", "start": [62, 1], "end": [66, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.cardQuot_apply", "code": "@[simp]\ntheorem cardQuot_apply (S : Submodule R M) [h : Fintype (M \u29f8 S)] :\n    cardQuot S = Fintype.card (M \u29f8 S)", "start": [69, 1], "end": [74, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.cardQuot_bot", "code": "@[simp]\ntheorem cardQuot_bot [Infinite M] : cardQuot (\u22a5 : Submodule R M) = 0", "start": [79, 1], "end": [81, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.cardQuot_top", "code": "theorem cardQuot_top : cardQuot (\u22a4 : Submodule R M) = 1", "start": [85, 1], "end": [86, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.cardQuot_eq_one_iff", "code": "@[simp]\ntheorem cardQuot_eq_one_iff {P : Submodule R M} : cardQuot P = 1 \u2194 P = \u22a4", "start": [91, 1], "end": [93, 61], "kind": "commanddeclaration"}, {"full_name": "cardQuot_mul_of_coprime", "code": "theorem cardQuot_mul_of_coprime [IsDedekindDomain S] [Module.Free \u2124 S] [Module.Finite \u2124 S]\n    {I J : Ideal S} (coprime : IsCoprime I J) : cardQuot (I * J) = cardQuot I * cardQuot J", "start": [106, 1], "end": [129, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_add_mem_pow_succ_inj", "code": "theorem Ideal.mul_add_mem_pow_succ_inj (P : Ideal S) {i : \u2115} (a d d' e e' : S) (a_mem : a \u2208 P ^ i)\n    (e_mem : e \u2208 P ^ (i + 1)) (e'_mem : e' \u2208 P ^ (i + 1)) (h : d - d' \u2208 P) :\n    a * d + e - (a * d' + e') \u2208 P ^ (i + 1)", "start": [132, 1], "end": [141, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_mul_add_mem_pow_succ", "code": "theorem Ideal.exists_mul_add_mem_pow_succ [IsDedekindDomain S] {i : \u2115} (a c : S) (a_mem : a \u2208 P ^ i)\n    (a_not_mem : a \u2209 P ^ (i + 1)) (c_mem : c \u2208 P ^ i) :\n    \u2203 d : S, \u2203 e \u2208 P ^ (i + 1), a * d + e = c", "start": [148, 1], "end": [163, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_prime_of_mul_mem_pow", "code": "theorem Ideal.mem_prime_of_mul_mem_pow [IsDedekindDomain S] {P : Ideal S} [P_prime : P.IsPrime]\n    (hP : P \u2260 \u22a5) {i : \u2115} {a b : S} (a_not_mem : a \u2209 P ^ (i + 1)) (ab_mem : a * b \u2208 P ^ (i + 1)) :\n    b \u2208 P", "start": [166, 1], "end": [171, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_add_mem_pow_succ_unique", "code": "theorem Ideal.mul_add_mem_pow_succ_unique [IsDedekindDomain S] {i : \u2115} (a d d' e e' : S)\n    (a_not_mem : a \u2209 P ^ (i + 1)) (e_mem : e \u2208 P ^ (i + 1)) (e'_mem : e' \u2208 P ^ (i + 1))\n    (h : a * d + e - (a * d' + e') \u2208 P ^ (i + 1)) : d - d' \u2208 P", "start": [174, 1], "end": [182, 55], "kind": "commanddeclaration"}, {"full_name": "cardQuot_pow_of_prime", "code": "theorem cardQuot_pow_of_prime [IsDedekindDomain S] [Module.Finite \u2124 S] [Module.Free \u2124 S] {i : \u2115} :\n    cardQuot (P ^ i) = cardQuot P ^ i", "start": [185, 1], "end": [224, 53], "kind": "commanddeclaration"}, {"full_name": "cardQuot_mul", "code": "theorem cardQuot_mul [IsDedekindDomain S] [Module.Free \u2124 S] [Module.Finite \u2124 S] (I J : Ideal S) :\n    cardQuot (I * J) = cardQuot I * cardQuot J", "start": [229, 1], "end": [246, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm", "code": "noncomputable def Ideal.absNorm [Infinite S] [IsDedekindDomain S] [Module.Free \u2124 S]\n    [Module.Finite \u2124 S] : Ideal S \u2192*\u2080 \u2115 where\n  toFun := Submodule.cardQuot\n  map_mul' I J := by dsimp only; rw [cardQuot_mul]\n  map_one' := by dsimp only; rw [Ideal.one_eq_top, cardQuot_top]\n  map_zero' := by rw [Ideal.zero_eq_bot, cardQuot_bot]", "start": [249, 1], "end": [255, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_apply", "code": "theorem absNorm_apply (I : Ideal S) : absNorm I = cardQuot I", "start": [262, 1], "end": [262, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_bot", "code": "@[simp]\ntheorem absNorm_bot : absNorm (\u22a5 : Ideal S) = 0", "start": [265, 1], "end": [266, 96], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_top", "code": "@[simp]\ntheorem absNorm_top : absNorm (\u22a4 : Ideal S) = 1", "start": [269, 1], "end": [270, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_eq_one_iff", "code": "@[simp]\ntheorem absNorm_eq_one_iff {I : Ideal S} : absNorm I = 1 \u2194 I = \u22a4", "start": [273, 1], "end": [275, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_ne_zero_iff", "code": "theorem absNorm_ne_zero_iff (I : Ideal S) : Ideal.absNorm I \u2260 0 \u2194 Finite (S \u29f8 I)", "start": [278, 1], "end": [280, 71], "kind": "commanddeclaration"}, {"full_name": "Ideal.natAbs_det_equiv", "code": "theorem natAbs_det_equiv (I : Ideal S) {E : Type*} [AddEquivClass E S I] (e : E) :\n    Int.natAbs\n        (LinearMap.det\n          ((Submodule.subtype I).restrictScalars \u2124 \u2218\u2097 AddMonoidHom.toIntLinearMap (e : S \u2192+ I))) =\n      Ideal.absNorm I", "start": [283, 1], "end": [345, 15], "kind": "commanddeclaration"}, {"full_name": "Ideal.natAbs_det_basis_change", "code": "theorem natAbs_det_basis_change {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (b : Basis \u03b9 \u2124 S)\n    (I : Ideal S) (bI : Basis \u03b9 \u2124 I) : (b.det ((\u2191) \u2218 bI)).natAbs = Ideal.absNorm I", "start": [348, 1], "end": [358, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_span_singleton", "code": "@[simp]\ntheorem absNorm_span_singleton (r : S) :\n    absNorm (span ({r} : Set S)) = (Algebra.norm \u2124 r).natAbs", "start": [361, 1], "end": [373, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_dvd_absNorm_of_le", "code": "theorem absNorm_dvd_absNorm_of_le {I J : Ideal S} (h : J \u2264 I) : Ideal.absNorm I \u2223 Ideal.absNorm J", "start": [376, 1], "end": [377, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_dvd_norm_of_mem", "code": "theorem absNorm_dvd_norm_of_mem {I : Ideal S} {x : S} (h : x \u2208 I) :\n    \u2191(Ideal.absNorm I) \u2223 Algebra.norm \u2124 x", "start": [380, 1], "end": [383, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_span_insert", "code": "@[simp]\ntheorem absNorm_span_insert (r : S) (s : Set S) :\n    absNorm (span (insert r s)) \u2223 gcd (absNorm (span s)) (Algebra.norm \u2124 r).natAbs", "start": [386, 1], "end": [393, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_eq_zero_iff", "code": "theorem absNorm_eq_zero_iff {I : Ideal S} : Ideal.absNorm I = 0 \u2194 I = \u22a5", "start": [396, 1], "end": [406, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.irreducible_of_irreducible_absNorm", "code": "theorem irreducible_of_irreducible_absNorm {I : Ideal S} (hI : Irreducible (Ideal.absNorm I)) :\n    Irreducible I", "start": [408, 1], "end": [416, 58], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrime_of_irreducible_absNorm", "code": "theorem isPrime_of_irreducible_absNorm {I : Ideal S} (hI : Irreducible (Ideal.absNorm I)) :\n    I.IsPrime", "start": [419, 1], "end": [422, 97], "kind": "commanddeclaration"}, {"full_name": "Ideal.prime_of_irreducible_absNorm_span", "code": "theorem prime_of_irreducible_absNorm_span {a : S} (ha : a \u2260 0)\n    (hI : Irreducible (Ideal.absNorm (Ideal.span ({a} : Set S)))) : Prime a", "start": [425, 1], "end": [427, 73], "kind": "commanddeclaration"}, {"full_name": "Ideal.absNorm_mem", "code": "theorem absNorm_mem (I : Ideal S) : \u2191(Ideal.absNorm I) \u2208 I", "start": [430, 1], "end": [432, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_absNorm_le", "code": "theorem span_singleton_absNorm_le (I : Ideal S) : Ideal.span {(Ideal.absNorm I : S)} \u2264 I", "start": [435, 1], "end": [436, 92], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_absNorm", "code": "theorem span_singleton_absNorm {I : Ideal S} (hI : (Ideal.absNorm I).Prime) :\n    Ideal.span (singleton (Ideal.absNorm I : \u2124)) = I.comap (algebraMap \u2124 S)", "start": [439, 1], "end": [449, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.finite_setOf_absNorm_eq", "code": "theorem finite_setOf_absNorm_eq [CharZero S] {n : \u2115} (hn : 0 < n) :\n    {I : Ideal S | Ideal.absNorm I = n}.Finite", "start": [451, 1], "end": [465, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.norm_dvd_iff", "code": "theorem norm_dvd_iff {x : S} (hx : Prime (Algebra.norm \u2124 x)) {y : \u2124} :\n    Algebra.norm \u2124 x \u2223 y \u2194 x \u2223 y", "start": [468, 1], "end": [473, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm", "code": "def spanNorm (I : Ideal S) : Ideal R :=\n  Ideal.span (Algebra.norm R '' (I : Set S))", "start": [489, 1], "end": [494, 45], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_bot", "code": "@[simp]\ntheorem spanNorm_bot [Nontrivial S] [Module.Free R S] [Module.Finite R S] :\n    spanNorm R (\u22a5 : Ideal S) = \u22a5", "start": [497, 1], "end": [499, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_eq_bot_iff", "code": "@[simp]\ntheorem spanNorm_eq_bot_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S]\n    {I : Ideal S} : spanNorm R I = \u22a5 \u2194 I = \u22a5", "start": [504, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.norm_mem_spanNorm", "code": "theorem norm_mem_spanNorm {I : Ideal S} (x : S) (hx : x \u2208 I) : Algebra.norm R x \u2208 I.spanNorm R", "start": [516, 1], "end": [517, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_singleton", "code": "@[simp]\ntheorem spanNorm_singleton {r : S} : spanNorm R (span ({r} : Set S)) = span {Algebra.norm R r}", "start": [520, 1], "end": [528, 92], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_top", "code": "@[simp]\ntheorem spanNorm_top : spanNorm R (\u22a4 : Ideal S) = \u22a4", "start": [531, 1], "end": [536, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_spanNorm", "code": "theorem map_spanNorm (I : Ideal S) {T : Type*} [CommRing T] (f : R \u2192+* T) :\n    map f (spanNorm R I) = span (f \u2218 Algebra.norm R '' (I : Set S))", "start": [539, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_mono", "code": "@[mono]\ntheorem spanNorm_mono {I J : Ideal S} (h : I \u2264 J) : spanNorm R I \u2264 spanNorm R J", "start": [546, 1], "end": [548, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_localization", "code": "theorem spanNorm_localization (I : Ideal S) [Module.Finite R S] [Module.Free R S] (M : Submonoid R)\n    {R\u2098 : Type*} (S\u2098 : Type*) [CommRing R\u2098] [Algebra R R\u2098] [CommRing S\u2098] [Algebra S S\u2098]\n    [Algebra R\u2098 S\u2098] [Algebra R S\u2098] [IsScalarTower R R\u2098 S\u2098] [IsScalarTower R S S\u2098]\n    [IsLocalization M R\u2098] [IsLocalization (Algebra.algebraMapSubmonoid S M) S\u2098] :\n    spanNorm R\u2098 (I.map (algebraMap S S\u2098)) = (spanNorm R I).map (algebraMap R R\u2098)", "start": [551, 1], "end": [576, 69], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_mul_spanNorm_le", "code": "theorem spanNorm_mul_spanNorm_le (I J : Ideal S) :\n    spanNorm R I * spanNorm R J \u2264 spanNorm R (I * J)", "start": [579, 1], "end": [584, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_mul_of_bot_or_top", "code": "theorem spanNorm_mul_of_bot_or_top [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S]\n    (eq_bot_or_top : \u2200 I : Ideal R, I = \u22a5 \u2228 I = \u22a4) (I J : Ideal S) :\n    spanNorm R (I * J) = spanNorm R I * spanNorm R J", "start": [587, 1], "end": [601, 15], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_mul_of_field", "code": "@[simp]\ntheorem spanNorm_mul_of_field {K : Type*} [Field K] [Algebra K S] [IsDomain S] [Module.Finite K S]\n    (I J : Ideal S) : spanNorm K (I * J) = spanNorm K I * spanNorm K J", "start": [604, 1], "end": [607, 49], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_mul", "code": "theorem spanNorm_mul (I J : Ideal S) : spanNorm R (I * J) = spanNorm R I * spanNorm R J", "start": [614, 1], "end": [646, 75], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm", "code": "def relNorm : Ideal S \u2192*\u2080 Ideal R where\n  toFun := spanNorm R\n  map_zero' := spanNorm_bot R\n  map_one' := by dsimp only; rw [one_eq_top, spanNorm_top R, one_eq_top]\n  map_mul' := spanNorm_mul R", "start": [649, 1], "end": [655, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_apply", "code": "theorem relNorm_apply (I : Ideal S) : relNorm R I = span (Algebra.norm R '' (I : Set S) : Set R)", "start": [658, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.spanNorm_eq", "code": "@[simp]\ntheorem spanNorm_eq (I : Ideal S) : spanNorm R I = relNorm R I", "start": [662, 1], "end": [663, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_bot", "code": "@[simp]\ntheorem relNorm_bot : relNorm R (\u22a5 : Ideal S) = \u22a5", "start": [666, 1], "end": [668, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_top", "code": "@[simp]\ntheorem relNorm_top : relNorm R (\u22a4 : Ideal S) = \u22a4", "start": [671, 1], "end": [673, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_eq_bot_iff", "code": "@[simp]\ntheorem relNorm_eq_bot_iff {I : Ideal S} : relNorm R I = \u22a5 \u2194 I = \u22a5", "start": [678, 1], "end": [680, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.norm_mem_relNorm", "code": "theorem norm_mem_relNorm (I : Ideal S) {x : S} (hx : x \u2208 I) : Algebra.norm R x \u2208 relNorm R I", "start": [685, 1], "end": [686, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_singleton", "code": "@[simp]\ntheorem relNorm_singleton (r : S) : relNorm R (span ({r} : Set S)) = span {Algebra.norm R r}", "start": [689, 1], "end": [691, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_relNorm", "code": "theorem map_relNorm (I : Ideal S) {T : Type*} [CommRing T] (f : R \u2192+* T) :\n    map f (relNorm R I) = span (f \u2218 Algebra.norm R '' (I : Set S))", "start": [694, 1], "end": [696, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.relNorm_mono", "code": "@[mono]\ntheorem relNorm_mono {I J : Ideal S} (h : I \u2264 J) : relNorm R I \u2264 relNorm R J", "start": [699, 1], "end": [701, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Gershgorin.lean", "imports": ["Mathlib/Analysis/Normed/Field/Basic.lean", "Mathlib/LinearAlgebra/Eigenspace/Basic.lean", "Mathlib/LinearAlgebra/Determinant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "eigenvalue_mem_ball", "code": "theorem eigenvalue_mem_ball {\u03bc : K} (h\u03bc : Module.End.HasEigenvalue (Matrix.toLin' A) \u03bc) :\n    \u2203 k, \u03bc \u2208 Metric.closedBall (A k k) (\u2211 j in Finset.univ.erase k, \u2016A k j\u2016)", "start": [25, 1], "end": [58, 95], "kind": "commanddeclaration"}, {"full_name": "det_ne_zero_of_sum_row_lt_diag", "code": "theorem det_ne_zero_of_sum_row_lt_diag (h : \u2200 k, \u2211 j in Finset.univ.erase k, \u2016A k j\u2016 < \u2016A k k\u2016) :\n    A.det \u2260 0", "start": [60, 1], "end": [68, 87], "kind": "commanddeclaration"}, {"full_name": "det_ne_zero_of_sum_col_lt_diag", "code": "theorem det_ne_zero_of_sum_col_lt_diag (h : \u2200 k, \u2211 i in Finset.univ.erase k, \u2016A i k\u2016 < \u2016A k k\u2016) :\n    A.det \u2260 0", "start": [70, 1], "end": [74, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Expr.lean", "imports": ["lake-packages/Qq/Qq.lean", "Mathlib/Init/ZeroOne.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Expr.instOne", "code": "def Expr.instOne {u : Lean.Level} (\u03b1 : Q(Type u)) (_ : Q(One $\u03b1)) : One Q($\u03b1) where\n  one := q(1 : $\u03b1)", "start": [19, 1], "end": [21, 19], "kind": "commanddeclaration"}, {"full_name": "Expr.instZero", "code": "def Expr.instZero {u : Lean.Level} (\u03b1 : Q(Type u)) (_ : Q(Zero $\u03b1)) : Zero Q($\u03b1) where\n  zero := q(0 : $\u03b1)", "start": [24, 1], "end": [26, 20], "kind": "commanddeclaration"}, {"full_name": "Expr.instMul", "code": "def Expr.instMul {u : Lean.Level} (\u03b1 : Q(Type u)) (_ : Q(Mul $\u03b1)) : Mul Q($\u03b1) where\n  mul x y := q($x * $y)", "start": [29, 1], "end": [31, 24], "kind": "commanddeclaration"}, {"full_name": "Expr.instAdd", "code": "def Expr.instAdd {u : Lean.Level} (\u03b1 : Q(Type u)) (_ : Q(Add $\u03b1)) : Add Q($\u03b1) where\n  add x y := q($x + $y)", "start": [34, 1], "end": [36, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Reflection.lean", "imports": ["Mathlib/Data/Matrix/Notation.lean", "Mathlib/Data/Matrix/Basic.lean", "Mathlib/Data/Fin/Tuple/Reflection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.Forall", "code": "def Forall : \u2200 {m n} (_ : Matrix (Fin m) (Fin n) \u03b1 \u2192 Prop), Prop\n  | 0, _, P => P (of ![])\n  | _ + 1, _, P => FinVec.Forall fun r => Forall fun A => P (of (Matrix.vecCons r A))", "start": [43, 1], "end": [46, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.forall_iff", "code": "theorem forall_iff : \u2200 {m n} (P : Matrix (Fin m) (Fin n) \u03b1 \u2192 Prop), Forall P \u2194 \u2200 x, P x", "start": [49, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.Exists", "code": "def Exists : \u2200 {m n} (_ : Matrix (Fin m) (Fin n) \u03b1 \u2192 Prop), Prop\n  | 0, _, P => P (of ![])\n  | _ + 1, _, P => FinVec.Exists fun r => Exists fun A => P (of (Matrix.vecCons r A))", "start": [67, 1], "end": [70, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.exists_iff", "code": "theorem exists_iff : \u2200 {m n} (P : Matrix (Fin m) (Fin n) \u03b1 \u2192 Prop), Exists P \u2194 \u2203 x, P x", "start": [73, 1], "end": [84, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose\u1d63", "code": "def transpose\u1d63 : \u2200 {m n}, Matrix (Fin m) (Fin n) \u03b1 \u2192 Matrix (Fin n) (Fin m) \u03b1\n  | _, 0, _ => of ![]\n  | _, _ + 1, A =>\n    of <| vecCons (FinVec.map (fun v : Fin _ \u2192 \u03b1 => v 0) A) (transpose\u1d63 (A.submatrix id Fin.succ))", "start": [91, 1], "end": [95, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose\u1d63_eq", "code": "@[simp]\ntheorem transpose\u1d63_eq : \u2200 {m n} (A : Matrix (Fin m) (Fin n) \u03b1), transpose\u1d63 A = transpose A", "start": [98, 1], "end": [113, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct\u1d63", "code": "def dotProduct\u1d63 [Mul \u03b1] [Add \u03b1] [Zero \u03b1] {m} (a b : Fin m \u2192 \u03b1) : \u03b1 :=\n  FinVec.sum <| FinVec.seq (FinVec.map (\u00b7 * \u00b7) a) b", "start": [119, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct\u1d63_eq", "code": "@[simp]\ntheorem dotProduct\u1d63_eq [Mul \u03b1] [AddCommMonoid \u03b1] {m} (a b : Fin m \u2192 \u03b1) :\n    dotProduct\u1d63 a b = dotProduct a b", "start": [124, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul\u1d63", "code": "def mul\u1d63 [Mul \u03b1] [Add \u03b1] [Zero \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (B : Matrix (Fin m) (Fin n) \u03b1) :\n    Matrix (Fin l) (Fin n) \u03b1 :=\n  of <| FinVec.map (fun v\u2081 => FinVec.map (fun v\u2082 => dotProduct\u1d63 v\u2081 v\u2082) B\u1d40) A", "start": [141, 1], "end": [144, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul\u1d63_eq", "code": "@[simp]\ntheorem mul\u1d63_eq [Mul \u03b1] [AddCommMonoid \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1)\n    (B : Matrix (Fin m) (Fin n) \u03b1) : mul\u1d63 A B = A * B", "start": [147, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec\u1d63", "code": "def mulVec\u1d63 [Mul \u03b1] [Add \u03b1] [Zero \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (v : Fin m \u2192 \u03b1) : Fin l \u2192 \u03b1 :=\n  FinVec.map (fun a => dotProduct\u1d63 a v) A", "start": [171, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec\u1d63_eq", "code": "@[simp]\ntheorem mulVec\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (v : Fin m \u2192 \u03b1) :\n    mulVec\u1d63 A v = A.mulVec v", "start": [176, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul\u1d63", "code": "def vecMul\u1d63 [Mul \u03b1] [Add \u03b1] [Zero \u03b1] (v : Fin l \u2192 \u03b1) (A : Matrix (Fin l) (Fin m) \u03b1) : Fin m \u2192 \u03b1 :=\n  FinVec.map (fun a => dotProduct\u1d63 v a) A\u1d40", "start": [195, 1], "end": [197, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul\u1d63_eq", "code": "@[simp]\ntheorem vecMul\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (v : Fin l \u2192 \u03b1) (A : Matrix (Fin l) (Fin m) \u03b1) :\n    vecMul\u1d63 v A = vecMul v A", "start": [200, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.etaExpand", "code": "def etaExpand {m n} (A : Matrix (Fin m) (Fin n) \u03b1) : Matrix (Fin m) (Fin n) \u03b1 :=\n  Matrix.of (FinVec.etaExpand fun i => FinVec.etaExpand fun j => A i j)", "start": [219, 1], "end": [221, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.etaExpand_eq", "code": "theorem etaExpand_eq {m n} (A : Matrix (Fin m) (Fin n) \u03b1) : etaExpand A = A", "start": [224, 1], "end": [235, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Tropical/Basic.lean", "imports": ["Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Algebra/SMulWithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/MinMax.lean", "Mathlib/Algebra/GroupPower/Order.lean"], "premises": [{"full_name": "Tropical", "code": "def Tropical : Type u :=\n  R", "start": [52, 1], "end": [54, 4], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop", "code": "def trop : R \u2192 Tropical R :=\n  id", "start": [61, 1], "end": [66, 5], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop", "code": "def untrop : Tropical R \u2192 R :=\n  id", "start": [69, 1], "end": [73, 5], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_injective", "code": "theorem trop_injective : Function.Injective (trop : R \u2192 Tropical R)", "start": [76, 1], "end": [76, 85], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_injective", "code": "theorem untrop_injective : Function.Injective (untrop : Tropical R \u2192 R)", "start": [79, 1], "end": [79, 89], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_inj_iff", "code": "@[simp]\ntheorem trop_inj_iff (x y : R) : trop x = trop y \u2194 x = y", "start": [82, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_inj_iff", "code": "@[simp]\ntheorem untrop_inj_iff (x y : Tropical R) : untrop x = untrop y \u2194 x = y", "start": [87, 1], "end": [89, 10], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_untrop", "code": "@[simp]\ntheorem trop_untrop (x : Tropical R) : trop (untrop x) = x", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_trop", "code": "@[simp]\ntheorem untrop_trop (x : R) : untrop (trop x) = x", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.leftInverse_trop", "code": "theorem leftInverse_trop : Function.LeftInverse (trop : R \u2192 Tropical R) untrop", "start": [105, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "Tropical.rightInverse_trop", "code": "theorem rightInverse_trop : Function.RightInverse (trop : R \u2192 Tropical R) untrop", "start": [109, 1], "end": [110, 14], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropEquiv", "code": "def tropEquiv : R \u2243 Tropical R where\n  toFun := trop\n  invFun := untrop\n  left_inv := untrop_trop\n  right_inv := trop_untrop", "start": [113, 1], "end": [119, 27], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropEquiv_coe_fn", "code": "@[simp]\ntheorem tropEquiv_coe_fn : (tropEquiv : R \u2192 Tropical R) = trop", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropEquiv_symm_coe_fn", "code": "@[simp]\ntheorem tropEquiv_symm_coe_fn : (tropEquiv.symm : Tropical R \u2192 R) = untrop", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_eq_iff_eq_untrop", "code": "theorem trop_eq_iff_eq_untrop {x : R} {y} : trop x = y \u2194 x = untrop y", "start": [132, 1], "end": [133, 39], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_eq_iff_eq_trop", "code": "theorem untrop_eq_iff_eq_trop {x} {y : R} : untrop x = y \u2194 x = trop y", "start": [136, 1], "end": [137, 44], "kind": "commanddeclaration"}, {"full_name": "Tropical.injective_trop", "code": "theorem injective_trop : Function.Injective (trop : R \u2192 Tropical R)", "start": [140, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "Tropical.injective_untrop", "code": "theorem injective_untrop : Function.Injective (untrop : Tropical R \u2192 R)", "start": [144, 1], "end": [145, 27], "kind": "commanddeclaration"}, {"full_name": "Tropical.surjective_trop", "code": "theorem surjective_trop : Function.Surjective (trop : R \u2192 Tropical R)", "start": [148, 1], "end": [149, 23], "kind": "commanddeclaration"}, {"full_name": "Tropical.surjective_untrop", "code": "theorem surjective_untrop : Function.Surjective (untrop : Tropical R \u2192 R)", "start": [152, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropRec", "code": "@[simp]\ndef tropRec {F : Tropical R \u2192 Sort v} (h : \u2200 X, F (trop X)) : \u2200 X, F X := fun X => h (untrop X)", "start": [159, 1], "end": [162, 96], "kind": "commanddeclaration"}, {"full_name": "Tropical.instLETropical", "code": "instance instLETropical [LE R] : LE (Tropical R) where le x y := untrop x \u2264 untrop y", "start": [170, 1], "end": [170, 85], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_le_iff", "code": "@[simp]\ntheorem untrop_le_iff [LE R] {x y : Tropical R} : untrop x \u2264 untrop y \u2194 x \u2264 y", "start": [172, 1], "end": [174, 10], "kind": "commanddeclaration"}, {"full_name": "Tropical.decidableLE", "code": "instance decidableLE [LE R] [DecidableRel ((\u00b7 \u2264 \u00b7) : R \u2192 R \u2192 Prop)] :\n    DecidableRel ((\u00b7 \u2264 \u00b7) : Tropical R \u2192 Tropical R \u2192 Prop) := fun x y =>\n  \u2039DecidableRel (\u00b7 \u2264 \u00b7)\u203a (untrop x) (untrop y)", "start": [177, 1], "end": [179, 47], "kind": "commanddeclaration"}, {"full_name": "Tropical.instLTTropical", "code": "instance instLTTropical [LT R] : LT (Tropical R) where lt x y := untrop x < untrop y", "start": [182, 1], "end": [182, 85], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_lt_iff", "code": "@[simp]\ntheorem untrop_lt_iff [LT R] {x y : Tropical R} : untrop x < untrop y \u2194 x < y", "start": [184, 1], "end": [186, 10], "kind": "commanddeclaration"}, {"full_name": "Tropical.decidableLT", "code": "instance decidableLT [LT R] [DecidableRel ((\u00b7 < \u00b7) : R \u2192 R \u2192 Prop)] :\n    DecidableRel ((\u00b7 < \u00b7) : Tropical R \u2192 Tropical R \u2192 Prop) := fun x y =>\n  \u2039DecidableRel (\u00b7 < \u00b7)\u203a (untrop x) (untrop y)", "start": [189, 1], "end": [191, 47], "kind": "commanddeclaration"}, {"full_name": "Tropical.instPreorderTropical", "code": "instance instPreorderTropical [Preorder R] : Preorder (Tropical R) :=\n  { instLETropical, instLTTropical with\n    le_refl := fun x => le_refl (untrop x)\n    le_trans := fun _ _ _ h h' => le_trans (\u03b1 := R) h h'\n    lt_iff_le_not_le := fun _ _ => lt_iff_le_not_le (\u03b1 := R) }", "start": [194, 1], "end": [198, 63], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropOrderIso", "code": "def tropOrderIso [Preorder R] : R \u2243o Tropical R :=\n  { tropEquiv with map_rel_iff' := untrop_le_iff }", "start": [200, 1], "end": [202, 51], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropOrderIso_coe_fn", "code": "@[simp]\ntheorem tropOrderIso_coe_fn [Preorder R] : (tropOrderIso : R \u2192 Tropical R) = trop", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.tropOrderIso_symm_coe_fn", "code": "@[simp]\ntheorem tropOrderIso_symm_coe_fn [Preorder R] : (tropOrderIso.symm : Tropical R \u2192 R) = untrop", "start": [210, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_monotone", "code": "theorem trop_monotone [Preorder R] : Monotone (trop : R \u2192 Tropical R)", "start": [215, 1], "end": [215, 87], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_monotone", "code": "theorem untrop_monotone [Preorder R] : Monotone (untrop : Tropical R \u2192 R)", "start": [218, 1], "end": [218, 91], "kind": "commanddeclaration"}, {"full_name": "Tropical.instPartialOrderTropical", "code": "instance instPartialOrderTropical [PartialOrder R] : PartialOrder (Tropical R) :=\n  { instPreorderTropical with le_antisymm := fun _ _ h h' => untrop_injective (le_antisymm h h') }", "start": [221, 1], "end": [222, 99], "kind": "commanddeclaration"}, {"full_name": "Tropical.instZeroTropical", "code": "instance instZeroTropical [Top R] : Zero (Tropical R) :=\n  \u27e8trop \u22a4\u27e9", "start": [224, 1], "end": [225, 11], "kind": "commanddeclaration"}, {"full_name": "Tropical.instTopTropical", "code": "instance instTopTropical [Top R] : Top (Tropical R) :=\n  \u27e80\u27e9", "start": [227, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_zero", "code": "@[simp]\ntheorem untrop_zero [Top R] : untrop (0 : Tropical R) = \u22a4", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_top", "code": "@[simp]\ntheorem trop_top [Top R] : trop (\u22a4 : R) = 0", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_coe_ne_zero", "code": "@[simp]\ntheorem trop_coe_ne_zero (x : R) : trop (x : WithTop R) \u2260 0", "start": [240, 1], "end": [242, 7], "kind": "commanddeclaration"}, {"full_name": "Tropical.zero_ne_trop_coe", "code": "@[simp]\ntheorem zero_ne_trop_coe (x : R) : (0 : Tropical (WithTop R)) \u2260 trop x", "start": [245, 1], "end": [247, 7], "kind": "commanddeclaration"}, {"full_name": "Tropical.le_zero", "code": "@[simp]\ntheorem le_zero [LE R] [OrderTop R] (x : Tropical R) : x \u2264 0", "start": [250, 1], "end": [252, 18], "kind": "commanddeclaration"}, {"full_name": "Tropical.instAddCommSemigroupTropical", "code": "instance instAddCommSemigroupTropical : AddCommSemigroup (Tropical R) where\n  add := (\u00b7 + \u00b7)\n  add_assoc _ _ _ := untrop_injective (min_assoc _ _ _)\n  add_comm _ _ := untrop_injective (min_comm _ _)", "start": [264, 1], "end": [267, 50], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_add", "code": "@[simp]\ntheorem untrop_add (x y : Tropical R) : untrop (x + y) = min (untrop x) (untrop y)", "start": [269, 1], "end": [271, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_min", "code": "@[simp]\ntheorem trop_min (x y : R) : trop (min x y) = trop x + trop y", "start": [274, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_inf", "code": "@[simp]\ntheorem trop_inf (x y : R) : trop (x \u2293 y) = trop x + trop y", "start": [279, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_add_def", "code": "theorem trop_add_def (x y : Tropical R) : x + y = trop (min (untrop x) (untrop y))", "start": [284, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instLinearOrderTropical", "code": "instance instLinearOrderTropical : LinearOrder (Tropical R) :=\n  { instPartialOrderTropical with\n    le_total := fun a b => le_total (untrop a) (untrop b)\n    decidableLE := Tropical.decidableLE\n    max := fun a b => trop (max (untrop a) (untrop b))\n    max_def := fun a b => untrop_injective (by simp [max_def]; split_ifs <;> simp)\n    min := (\u00b7 + \u00b7)\n    min_def := fun a b => untrop_injective (by simp [min_def]; split_ifs <;> simp) }", "start": [288, 1], "end": [295, 85], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_sup", "code": "@[simp]\ntheorem untrop_sup (x y : Tropical R) : untrop (x \u2294 y) = untrop x \u2294 untrop y", "start": [297, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_max", "code": "@[simp]\ntheorem untrop_max (x y : Tropical R) : untrop (max x y) = max (untrop x) (untrop y)", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.min_eq_add", "code": "@[simp]\ntheorem min_eq_add : (min : Tropical R \u2192 Tropical R \u2192 Tropical R) = (\u00b7 + \u00b7)", "start": [307, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.inf_eq_add", "code": "@[simp]\ntheorem inf_eq_add : ((\u00b7 \u2293 \u00b7) : Tropical R \u2192 Tropical R \u2192 Tropical R) = (\u00b7 + \u00b7)", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_max_def", "code": "theorem trop_max_def (x y : Tropical R) : max x y = trop (max (untrop x) (untrop y))", "start": [317, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_sup_def", "code": "theorem trop_sup_def (x y : Tropical R) : x \u2294 y = trop (untrop x \u2294 untrop y)", "start": [321, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_left", "code": "@[simp]\ntheorem add_eq_left \u2983x y : Tropical R\u2984 (h : x \u2264 y) : x + y = x", "start": [325, 1], "end": [327, 38], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_right", "code": "@[simp]\ntheorem add_eq_right \u2983x y : Tropical R\u2984 (h : y \u2264 x) : x + y = y", "start": [330, 1], "end": [332, 38], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_left_iff", "code": "theorem add_eq_left_iff {x y : Tropical R} : x + y = x \u2194 x \u2264 y", "start": [335, 1], "end": [336, 77], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_right_iff", "code": "theorem add_eq_right_iff {x y : Tropical R} : x + y = y \u2194 y \u2264 x", "start": [339, 1], "end": [340, 78], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_self", "code": "theorem add_self (x : Tropical R) : x + x = x", "start": [344, 1], "end": [345, 41], "kind": "commanddeclaration"}, {"full_name": "Tropical.bit0", "code": "@[simp]\ntheorem bit0 (x : Tropical R) : bit0 x = x", "start": [349, 1], "end": [351, 13], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_iff", "code": "theorem add_eq_iff {x y z : Tropical R} : x + y = z \u2194 x = z \u2227 x \u2264 y \u2228 y = z \u2227 y \u2264 x", "start": [354, 1], "end": [356, 20], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_eq_zero_iff", "code": "@[simp]\ntheorem add_eq_zero_iff {a b : Tropical (WithTop R)} : a + b = 0 \u2194 a = 0 \u2227 b = 0", "start": [359, 1], "end": [367, 9], "kind": "commanddeclaration"}, {"full_name": "Tropical.instAddCommMonoidTropical", "code": "instance instAddCommMonoidTropical [OrderTop R] : AddCommMonoid (Tropical R) :=\n  { instZeroTropical, instAddCommSemigroupTropical with\n    zero_add := fun _ => untrop_injective (min_top_left _)\n    add_zero := fun _ => untrop_injective (min_top_right _) }", "start": [370, 1], "end": [373, 62], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_add", "code": "@[simp]\ntheorem trop_add [Add R] (x y : R) : trop (x + y) = trop x * trop y", "start": [383, 1], "end": [385, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_mul", "code": "@[simp]\ntheorem untrop_mul [Add R] (x y : Tropical R) : untrop (x * y) = untrop x + untrop y", "start": [388, 1], "end": [390, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_mul_def", "code": "theorem trop_mul_def [Add R] (x y : Tropical R) : x * y = trop (untrop x + untrop y)", "start": [393, 1], "end": [394, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instOneTropical", "code": "instance instOneTropical [Zero R] : One (Tropical R) :=\n  \u27e8trop 0\u27e9", "start": [397, 1], "end": [398, 11], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_zero", "code": "@[simp]\ntheorem trop_zero [Zero R] : trop (0 : R) = 1", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_one", "code": "@[simp]\ntheorem untrop_one [Zero R] : untrop (1 : Tropical R) = 0", "start": [405, 1], "end": [407, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instAddMonoidWithOneTropical", "code": "instance instAddMonoidWithOneTropical [LinearOrder R] [OrderTop R] [Zero R] :\n    AddMonoidWithOne (Tropical R) :=\n  { instOneTropical, instAddCommMonoidTropical with\n    natCast := fun n => if n = 0 then 0 else 1\n    natCast_zero := rfl\n    natCast_succ := fun n => (untrop_inj_iff _ _).1 (by cases n <;> simp [Nat.cast]) }", "start": [410, 1], "end": [415, 87], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_inv", "code": "@[simp]\ntheorem untrop_inv [Neg R] (x : Tropical R) : untrop x\u207b\u00b9 = -untrop x", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_div", "code": "@[simp]\ntheorem untrop_div [Sub R] (x y : Tropical R) : untrop (x / y) = untrop x - untrop y", "start": [431, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instSemigroupTropical", "code": "instance instSemigroupTropical [AddSemigroup R] : Semigroup (Tropical R) where\n  mul := (\u00b7 * \u00b7)\n  mul_assoc _ _ _ := untrop_injective (add_assoc _ _ _)", "start": [436, 1], "end": [438, 56], "kind": "commanddeclaration"}, {"full_name": "Tropical.instCommSemigroupTropical", "code": "instance instCommSemigroupTropical [AddCommSemigroup R] : CommSemigroup (Tropical R) :=\n  { instSemigroupTropical with mul_comm := fun _ _ => untrop_injective (add_comm _ _) }", "start": [440, 1], "end": [441, 88], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_pow", "code": "@[simp]\ntheorem untrop_pow {\u03b1 : Type*} [SMul \u03b1 R] (x : Tropical R) (n : \u03b1) :\n    untrop (x ^ n) = n \u2022 untrop x", "start": [445, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_smul", "code": "@[simp]\ntheorem trop_smul {\u03b1 : Type*} [SMul \u03b1 R] (x : R) (n : \u03b1) : trop (n \u2022 x) = trop x ^ n", "start": [451, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instMulOneClassTropical", "code": "instance instMulOneClassTropical [AddZeroClass R] : MulOneClass (Tropical R) where\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  one_mul _ := untrop_injective <| zero_add _\n  mul_one _ := untrop_injective <| add_zero _", "start": [456, 1], "end": [460, 46], "kind": "commanddeclaration"}, {"full_name": "Tropical.instMonoidTropical", "code": "instance instMonoidTropical [AddMonoid R] : Monoid (Tropical R) :=\n  { instMulOneClassTropical, instSemigroupTropical with\n    npow := fun n x => x ^ n\n    npow_zero := fun _ => untrop_injective <| by simp\n    npow_succ := fun _ _ => untrop_injective <| succ_nsmul _ _ }", "start": [462, 1], "end": [466, 65], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_nsmul", "code": "@[simp]\ntheorem trop_nsmul [AddMonoid R] (x : R) (n : \u2115) : trop (n \u2022 x) = trop x ^ n", "start": [468, 1], "end": [470, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.instCommMonoidTropical", "code": "instance instCommMonoidTropical [AddCommMonoid R] : CommMonoid (Tropical R) :=\n  { instMonoidTropical, instCommSemigroupTropical with }", "start": [473, 1], "end": [474, 57], "kind": "commanddeclaration"}, {"full_name": "Tropical.instGroupTropical", "code": "instance instGroupTropical [AddGroup R] : Group (Tropical R) :=\n  { instMonoidTropical with\n    inv := Inv.inv\n    div_eq_mul_inv := fun _ _ => untrop_injective <| by simp [sub_eq_add_neg]\n    mul_left_inv := fun _ => untrop_injective <| add_left_neg _\n    zpow := fun n x => trop <| n \u2022 untrop x\n    zpow_zero' := fun _ => untrop_injective <| zero_zsmul _\n    zpow_succ' := fun _ _ => untrop_injective <| SubNegMonoid.zsmul_succ' _ _\n    zpow_neg' := fun _ _ => untrop_injective <| SubNegMonoid.zsmul_neg' _ _ }", "start": [476, 1], "end": [484, 78], "kind": "commanddeclaration"}, {"full_name": "Tropical.untrop_zpow", "code": "@[simp]\ntheorem untrop_zpow [AddGroup R] (x : Tropical R) (n : \u2124) : untrop (x ^ n) = n \u2022 untrop x", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.trop_zsmul", "code": "@[simp]\ntheorem trop_zsmul [AddGroup R] (x : R) (n : \u2124) : trop (n \u2022 x) = trop x ^ n", "start": [494, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "Tropical.covariant_mul", "code": "instance covariant_mul [LE R] [Add R] [CovariantClass R R (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (Tropical R) (Tropical R) (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ y z h => add_le_add_left (show untrop y \u2264 untrop z from h) _\u27e9", "start": [503, 1], "end": [505, 71], "kind": "commanddeclaration"}, {"full_name": "Tropical.covariant_swap_mul", "code": "instance covariant_swap_mul [LE R] [Add R] [CovariantClass R R (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (Tropical R) (Tropical R) (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ y z h => add_le_add_right (show untrop y \u2264 untrop z from h) _\u27e9", "start": [508, 1], "end": [510, 72], "kind": "commanddeclaration"}, {"full_name": "Tropical.covariant_add", "code": "instance covariant_add [LinearOrder R] : CovariantClass (Tropical R) (Tropical R) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun x y z h => by\n    cases' le_total x y with hx hy\n    \u00b7 rw [add_eq_left hx, add_eq_left (hx.trans h)]\n    \u00b7 rw [add_eq_right hy]\n      cases' le_total x z with hx hx\n      \u00b7 rwa [add_eq_left hx]\n      \u00b7 rwa [add_eq_right hx]\u27e9", "start": [513, 1], "end": [520, 31], "kind": "commanddeclaration"}, {"full_name": "Tropical.covariant_mul_lt", "code": "instance covariant_mul_lt [LT R] [Add R] [CovariantClass R R (\u00b7 + \u00b7) (\u00b7 < \u00b7)] :\n    CovariantClass (Tropical R) (Tropical R) (\u00b7 * \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun _ _ _ h => add_lt_add_left (untrop_lt_iff.2 h) _\u27e9", "start": [523, 1], "end": [525, 57], "kind": "commanddeclaration"}, {"full_name": "Tropical.covariant_swap_mul_lt", "code": "instance covariant_swap_mul_lt [Preorder R] [Add R]\n    [CovariantClass R R (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    CovariantClass (Tropical R) (Tropical R) (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun _ y z h => add_lt_add_right (show untrop y < untrop z from h) _\u27e9", "start": [528, 1], "end": [531, 72], "kind": "commanddeclaration"}, {"full_name": "Tropical.instDistribTropical", "code": "instance instDistribTropical [LinearOrder R] [Add R] [CovariantClass R R (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass R R (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    Distrib (Tropical R) where\n  mul := (\u00b7 * \u00b7)\n  add := (\u00b7 + \u00b7)\n  left_distrib _ _ _ := untrop_injective (min_add_add_left _ _ _).symm\n  right_distrib _ _ _ := untrop_injective (min_add_add_right _ _ _).symm", "start": [534, 1], "end": [540, 73], "kind": "commanddeclaration"}, {"full_name": "Tropical.add_pow", "code": "@[simp]\ntheorem add_pow [LinearOrder R] [AddMonoid R] [CovariantClass R R (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass R R (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (x y : Tropical R) (n : \u2115) :\n    (x + y) ^ n = x ^ n + y ^ n", "start": [542, 1], "end": [548, 67], "kind": "commanddeclaration"}, {"full_name": "Tropical.succ_nsmul", "code": "@[simp]\ntheorem succ_nsmul {R} [LinearOrder R] [OrderTop R] (x : Tropical R) (n : \u2115) : (n + 1) \u2022 x = x", "start": [565, 1], "end": [569, 44], "kind": "commanddeclaration"}, {"full_name": "Tropical.mul_eq_zero_iff", "code": "theorem mul_eq_zero_iff {R : Type*} [LinearOrderedAddCommMonoid R] {a b : Tropical (WithTop R)} :\n    a * b = 0 \u2194 a = 0 \u2228 b = 0", "start": [577, 1], "end": [578, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/OreLocalization/OreSet.lean", "imports": ["Mathlib/Algebra/Ring/Regular.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OreLocalization.OreSet", "code": "class OreSet {R : Type*} [Monoid R] (S : Submonoid R) where\n  \n  ore_left_cancel : \u2200 (r\u2081 r\u2082 : R) (s : S), \u2191s * r\u2081 = s * r\u2082 \u2192 \u2203 s' : S, r\u2081 * s' = r\u2082 * s'\n  \n  oreNum : R \u2192 S \u2192 R\n  \n  oreDenom : R \u2192 S \u2192 S\n  \n  ore_eq : \u2200 (r : R) (s : S), r * oreDenom r s = s * oreNum r s", "start": [28, 1], "end": [40, 64], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.ore_left_cancel", "code": "theorem ore_left_cancel (r\u2081 r\u2082 : R) (s : S) (h : \u2191s * r\u2081 = s * r\u2082) : \u2203 s' : S, r\u2081 * s' = r\u2082 * s'", "start": [45, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreNum", "code": "def oreNum (r : R) (s : S) : R :=\n  OreSet.oreNum r s", "start": [51, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreDenom", "code": "def oreDenom (r : R) (s : S) : S :=\n  OreSet.oreDenom r s", "start": [56, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.ore_eq", "code": "theorem ore_eq (r : R) (s : S) : r * oreDenom r s = s * oreNum r s", "start": [61, 1], "end": [63, 20], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreCondition", "code": "def oreCondition (r : R) (s : S) : \u03a3'r' : R, \u03a3's' : S, r * s' = s * r' :=\n  \u27e8oreNum r s, oreDenom r s, ore_eq r s\u27e9", "start": [66, 1], "end": [69, 41], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreSetBot", "code": "instance oreSetBot : OreSet (\u22a5 : Submonoid R)\n    where\n  ore_left_cancel _ _ s h :=\n    \u27e8s, by\n      rcases s with \u27e8s, hs\u27e9\n      rw [Submonoid.mem_bot] at hs\n      subst hs\n      rw [one_mul, one_mul] at h\n      subst h\n      rfl\u27e9\n  oreNum r _ := r\n  oreDenom _ s := s\n  ore_eq _ s := by\n    rcases s with \u27e8s, hs\u27e9\n    rw [Submonoid.mem_bot] at hs\n    simp [hs]", "start": [72, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreSetComm", "code": "instance (priority := 100) oreSetComm {R} [CommMonoid R] (S : Submonoid R) : OreSet S\n    where\n  ore_left_cancel m n s h := \u27e8s, by rw [mul_comm n s, mul_comm m s, h]\u27e9\n  oreNum r _ := r\n  oreDenom _ s := s\n  ore_eq r s := by rw [mul_comm]", "start": [91, 1], "end": [97, 33], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreSetOfCancelMonoidWithZero", "code": "def oreSetOfCancelMonoidWithZero {R : Type*} [CancelMonoidWithZero R] {S : Submonoid R}\n    (oreNum : R \u2192 S \u2192 R) (oreDenom : R \u2192 S \u2192 S)\n    (ore_eq : \u2200 (r : R) (s : S), r * oreDenom r s = s * oreNum r s) : OreSet S :=\n  { ore_left_cancel := fun _ _ s h => \u27e8s, mul_eq_mul_right_iff.mpr (mul_eq_mul_left_iff.mp h)\u27e9\n    oreNum\n    oreDenom\n    ore_eq }", "start": [102, 1], "end": [110, 13], "kind": "commanddeclaration"}, {"full_name": "OreLocalization.oreSetOfNoZeroDivisors", "code": "def oreSetOfNoZeroDivisors {R : Type*} [Ring R] [NoZeroDivisors R] {S : Submonoid R}\n    (oreNum : R \u2192 S \u2192 R) (oreDenom : R \u2192 S \u2192 S)\n    (ore_eq : \u2200 (r : R) (s : S), r * oreDenom r s = s * oreNum r s) : OreSet S :=\n  letI : CancelMonoidWithZero R := NoZeroDivisors.toCancelMonoidWithZero\n  oreSetOfCancelMonoidWithZero oreNum oreDenom ore_eq", "start": [113, 1], "end": [119, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Sphere/Power.lean", "imports": ["Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InnerProductGeometry.mul_norm_eq_abs_sub_sq_norm", "code": "theorem mul_norm_eq_abs_sub_sq_norm {x y z : V} (h\u2081 : \u2203 k : \u211d, k \u2260 1 \u2227 x + y = k \u2022 (x - y))\n    (h\u2082 : \u2016z - y\u2016 = \u2016z + y\u2016) : \u2016x - y\u2016 * \u2016x + y\u2016 = |\u2016z + y\u2016 ^ 2 - \u2016z - x\u2016 ^ 2|", "start": [40, 1], "end": [64, 72], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mul_dist_eq_abs_sub_sq_dist", "code": "theorem mul_dist_eq_abs_sub_sq_dist {a b p q : P} (hp : \u2203 k : \u211d, k \u2260 1 \u2227 b -\u1d65 p = k \u2022 (a -\u1d65 p))\n    (hq : dist a q = dist b q) : dist a p * dist b p = |dist b q ^ 2 - dist p q ^ 2|", "start": [82, 1], "end": [96, 42], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mul_dist_eq_mul_dist_of_cospherical", "code": "theorem mul_dist_eq_mul_dist_of_cospherical {a b c d p : P} (h : Cospherical ({a, b, c, d} : Set P))\n    (hapb : \u2203 k\u2081 : \u211d, k\u2081 \u2260 1 \u2227 b -\u1d65 p = k\u2081 \u2022 (a -\u1d65 p))\n    (hcpd : \u2203 k\u2082 : \u211d, k\u2082 \u2260 1 \u2227 d -\u1d65 p = k\u2082 \u2022 (c -\u1d65 p)) :\n    dist a p * dist b p = dist c p * dist d p", "start": [99, 1], "end": [109, 90], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi", "code": "theorem mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi {a b c d p : P}\n    (h : Cospherical ({a, b, c, d} : Set P)) (hapb : \u2220 a p b = \u03c0) (hcpd : \u2220 c p d = \u03c0) :\n    dist a p * dist b p = dist c p * dist d p", "start": [112, 1], "end": [118, 92], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_zero", "code": "theorem mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_zero {a b c d p : P}\n    (h : Cospherical ({a, b, c, d} : Set P)) (hab : a \u2260 b) (hcd : c \u2260 d) (hapb : \u2220 a p b = 0)\n    (hcpd : \u2220 c p d = 0) : dist a p * dist b p = dist c p * dist d p", "start": [121, 1], "end": [129, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Triangle.lean", "imports": ["Mathlib/Tactic/IntervalCases.lean", "Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/Affine.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle", "code": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle (x y : V) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 - 2 * \u2016x\u2016 * \u2016y\u2016 * Real.cos (angle x y)", "start": [65, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_sub_eq_angle_sub_rev_of_norm_eq", "code": "theorem angle_sub_eq_angle_sub_rev_of_norm_eq {x y : V} (h : \u2016x\u2016 = \u2016y\u2016) :\n    angle x (x - y) = angle y (y - x)", "start": [74, 1], "end": [79, 96], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi", "code": "theorem norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi {x y : V}\n    (h : angle x (x - y) = angle y (y - x)) (hpi : angle x y \u2260 \u03c0) : \u2016x\u2016 = \u2016y\u2016", "start": [82, 1], "end": [108, 20], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle", "code": "theorem cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    Real.cos (angle x (x - y) + angle y (y - x)) = -Real.cos (angle x y)", "start": [111, 1], "end": [147, 9], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_sub_add_angle_sub_rev_eq_sin_angle", "code": "theorem sin_angle_sub_add_angle_sub_rev_eq_sin_angle {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    Real.sin (angle x (x - y) + angle y (y - x)) = Real.sin (angle x y)", "start": [150, 1], "end": [188, 9], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.cos_angle_add_angle_sub_add_angle_sub_eq_neg_one", "code": "theorem cos_angle_add_angle_sub_add_angle_sub_eq_neg_one {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    Real.cos (angle x y + angle x (x - y) + angle y (y - x)) = -1", "start": [191, 1], "end": [197, 28], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.sin_angle_add_angle_sub_add_angle_sub_eq_zero", "code": "theorem sin_angle_add_angle_sub_add_angle_sub_eq_zero {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    Real.sin (angle x y + angle x (x - y) + angle y (y - x)) = 0", "start": [200, 1], "end": [206, 7], "kind": "commanddeclaration"}, {"full_name": "InnerProductGeometry.angle_add_angle_sub_add_angle_sub_eq_pi", "code": "theorem angle_add_angle_sub_add_angle_sub_eq_pi {x y : V} (hx : x \u2260 0) (hy : y \u2260 0) :\n    angle x y + angle x (x - y) + angle y (y - x) = \u03c0", "start": [209, 1], "end": [250, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle", "code": "theorem dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle (p1 p2 p3 : P) :\n    dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 -\n      2 * dist p1 p2 * dist p3 p2 * Real.cos (\u2220 p1 p2 p3)", "start": [272, 1], "end": [281, 53], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.law_cos", "code": "alias law_cos := dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle", "start": [284, 1], "end": [284, 88], "kind": "stdtacticaliasalias"}, {"full_name": "EuclideanGeometry.angle_eq_angle_of_dist_eq", "code": "theorem angle_eq_angle_of_dist_eq {p1 p2 p3 : P} (h : dist p1 p2 = dist p1 p3) :\n    \u2220 p1 p2 p3 = \u2220 p1 p3 p2", "start": [287, 1], "end": [294, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_eq_of_angle_eq_angle_of_angle_ne_pi", "code": "theorem dist_eq_of_angle_eq_angle_of_angle_ne_pi {p1 p2 p3 : P} (h : \u2220 p1 p2 p3 = \u2220 p1 p3 p2)\n    (hpi : \u2220 p2 p1 p3 \u2260 \u03c0) : dist p1 p2 = dist p1 p3", "start": [297, 1], "end": [304, 67], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.angle_add_angle_add_angle_eq_pi", "code": "theorem angle_add_angle_add_angle_eq_pi {p1 p2 p3 : P} (h2 : p2 \u2260 p1) (h3 : p3 \u2260 p1) :\n    \u2220 p1 p2 p3 + \u2220 p2 p3 p1 + \u2220 p3 p1 p2 = \u03c0", "start": [307, 1], "end": [317, 34], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi", "code": "theorem oangle_add_oangle_add_oangle_eq_pi [Module.Oriented \u211d V (Fin 2)]\n    [Fact (FiniteDimensional.finrank \u211d V = 2)] {p1 p2 p3 : P} (h21 : p2 \u2260 p1) (h32 : p3 \u2260 p2)\n    (h13 : p1 \u2260 p3) : \u2221 p1 p2 p3 + \u2221 p2 p3 p1 + \u2221 p3 p1 p2 = \u03c0", "start": [320, 1], "end": [327, 29], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_sq_mul_dist_add_dist_sq_mul_dist", "code": "theorem dist_sq_mul_dist_add_dist_sq_mul_dist (a b c p : P) (h : \u2220 b p c = \u03c0) :\n    dist a b ^ 2 * dist c p + dist a c ^ 2 * dist b p =\n    dist b c * (dist a p ^ 2 + dist b p * dist c p)", "start": [330, 1], "end": [337, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq", "code": "theorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint \u211d b c) ^ 2 + (dist b c / 2) ^ 2)", "start": [340, 1], "end": [352, 97], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_mul_of_eq_angle_of_dist_mul", "code": "theorem dist_mul_of_eq_angle_of_dist_mul (a b c a' b' c' : P) (r : \u211d) (h : \u2220 a' b' c' = \u2220 a b c)\n    (hab : dist a' b' = r * dist a b) (hcb : dist c' b' = r * dist c b) :\n    dist a' c' = r * dist a c", "start": [355, 1], "end": [372, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/AlgebraicIndependent.lean", "imports": ["Mathlib/Data/MvPolynomial/Supported.lean", "Mathlib/RingTheory/Adjoin/Basic.lean", "Mathlib/RingTheory/Algebraic.lean", "Mathlib/RingTheory/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/MvPolynomial/Equiv.lean", "Mathlib/LinearAlgebra/LinearIndependent.lean"], "premises": [{"full_name": "AlgebraicIndependent", "code": "def AlgebraicIndependent : Prop :=\n  Injective (MvPolynomial.aeval x : MvPolynomial \u03b9 R \u2192\u2090[R] A)", "start": [62, 1], "end": [66, 62], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_iff_ker_eq_bot", "code": "theorem algebraicIndependent_iff_ker_eq_bot :\n    AlgebraicIndependent R x \u2194\n      RingHom.ker (MvPolynomial.aeval x : MvPolynomial \u03b9 R \u2192\u2090[R] A).toRingHom = \u22a5", "start": [71, 1], "end": [74, 37], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_iff", "code": "theorem algebraicIndependent_iff :\n    AlgebraicIndependent R x \u2194\n      \u2200 p : MvPolynomial \u03b9 R, MvPolynomial.aeval (x : \u03b9 \u2192 A) p = 0 \u2192 p = 0", "start": [77, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.eq_zero_of_aeval_eq_zero", "code": "theorem AlgebraicIndependent.eq_zero_of_aeval_eq_zero (h : AlgebraicIndependent R x) :\n    \u2200 p : MvPolynomial \u03b9 R, MvPolynomial.aeval (x : \u03b9 \u2192 A) p = 0 \u2192 p = 0", "start": [83, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_iff_injective_aeval", "code": "theorem algebraicIndependent_iff_injective_aeval :\n    AlgebraicIndependent R x \u2194 Injective (MvPolynomial.aeval x : MvPolynomial \u03b9 R \u2192\u2090[R] A)", "start": [88, 1], "end": [90, 10], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_empty_type_iff", "code": "@[simp]\ntheorem algebraicIndependent_empty_type_iff [IsEmpty \u03b9] :\n    AlgebraicIndependent R x \u2194 Injective (algebraMap R A)", "start": [93, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.algebraMap_injective", "code": "theorem algebraMap_injective : Injective (algebraMap R A)", "start": [107, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.linearIndependent", "code": "theorem linearIndependent : LinearIndependent R x", "start": [113, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.injective", "code": "protected theorem injective [Nontrivial R] : Injective x", "start": [125, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.ne_zero", "code": "theorem ne_zero [Nontrivial R] (i : \u03b9) : x i \u2260 0", "start": [129, 1], "end": [130, 33], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.comp", "code": "theorem comp (f : \u03b9' \u2192 \u03b9) (hf : Function.Injective f) : AlgebraicIndependent R (x \u2218 f)", "start": [133, 1], "end": [135, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.coe_range", "code": "theorem coe_range : AlgebraicIndependent R ((\u2191) : range x \u2192 A)", "start": [138, 1], "end": [139, 53], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.map", "code": "theorem map {f : A \u2192\u2090[R] A'} (hf_inj : Set.InjOn f (adjoin R (range x))) :\n    AlgebraicIndependent R (f \u2218 x)", "start": [142, 1], "end": [153, 36], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.map'", "code": "theorem map' {f : A \u2192\u2090[R] A'} (hf_inj : Injective f) : AlgebraicIndependent R (f \u2218 x)", "start": [156, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.of_comp", "code": "theorem of_comp (f : A \u2192\u2090[R] A') (hfv : AlgebraicIndependent R (f \u2218 x)) :\n    AlgebraicIndependent R x", "start": [160, 1], "end": [164, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.algebraicIndependent_iff", "code": "theorem AlgHom.algebraicIndependent_iff (f : A \u2192\u2090[R] A') (hf : Injective f) :\n    AlgebraicIndependent R (f \u2218 x) \u2194 AlgebraicIndependent R x", "start": [171, 1], "end": [173, 67], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_of_subsingleton", "code": "@[nontriviality]\ntheorem algebraicIndependent_of_subsingleton [Subsingleton R] : AlgebraicIndependent R x", "start": [176, 1], "end": [178, 62], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_equiv", "code": "theorem algebraicIndependent_equiv (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 A} :\n    AlgebraicIndependent R (f \u2218 e) \u2194 AlgebraicIndependent R f", "start": [181, 1], "end": [184, 35], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_equiv'", "code": "theorem algebraicIndependent_equiv' (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 A} {g : \u03b9 \u2192 A} (h : f \u2218 e = g) :\n    AlgebraicIndependent R g \u2194 AlgebraicIndependent R f", "start": [187, 1], "end": [189, 35], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_subtype_range", "code": "theorem algebraicIndependent_subtype_range {\u03b9} {f : \u03b9 \u2192 A} (hf : Injective f) :\n    AlgebraicIndependent R ((\u2191) : range f \u2192 A) \u2194 AlgebraicIndependent R f", "start": [192, 1], "end": [194, 71], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.of_subtype_range", "code": "alias \u27e8AlgebraicIndependent.of_subtype_range, _\u27e9 := algebraicIndependent_subtype_range", "start": [197, 1], "end": [197, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "algebraicIndependent_image", "code": "theorem algebraicIndependent_image {\u03b9} {s : Set \u03b9} {f : \u03b9 \u2192 A} (hf : Set.InjOn f s) :\n    (AlgebraicIndependent R fun x : s => f x) \u2194 AlgebraicIndependent R fun x : f '' s => (x : A)", "start": [200, 1], "end": [202, 66], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_adjoin", "code": "theorem algebraicIndependent_adjoin (hs : AlgebraicIndependent R x) :\n    @AlgebraicIndependent \u03b9 R (adjoin R (range x))\n      (fun i : \u03b9 => \u27e8x i, subset_adjoin (mem_range_self i)\u27e9) _ _ _", "start": [205, 1], "end": [208, 59], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.restrictScalars", "code": "theorem AlgebraicIndependent.restrictScalars {K : Type*} [CommRing K] [Algebra R K] [Algebra K A]\n    [IsScalarTower R K A] (hinj : Function.Injective (algebraMap R K))\n    (ai : AlgebraicIndependent K x) : AlgebraicIndependent R x", "start": [211, 1], "end": [221, 62], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_finset_map_embedding_subtype", "code": "theorem algebraicIndependent_finset_map_embedding_subtype (s : Set A)\n    (li : AlgebraicIndependent R ((\u2191) : s \u2192 A)) (t : Finset s) :\n    AlgebraicIndependent R ((\u2191) : Finset.map (Embedding.subtype s) t \u2192 A)", "start": [224, 1], "end": [239, 41], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded", "code": "theorem algebraicIndependent_bounded_of_finset_algebraicIndependent_bounded {n : \u2115}\n    (H : \u2200 s : Finset A, (AlgebraicIndependent R fun i : s => (i : A)) \u2192 s.card \u2264 n) :\n    \u2200 s : Set A, AlgebraicIndependent R ((\u2191) : s \u2192 A) \u2192 Cardinal.mk s \u2264 n", "start": [242, 1], "end": [252, 63], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.restrict_of_comp_subtype", "code": "theorem AlgebraicIndependent.restrict_of_comp_subtype {s : Set \u03b9}\n    (hs : AlgebraicIndependent R (x \u2218 (\u2191) : s \u2192 A)) : AlgebraicIndependent R (s.restrict x)", "start": [257, 1], "end": [259, 5], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_empty_iff", "code": "theorem algebraicIndependent_empty_iff :\n    AlgebraicIndependent R ((\u2191) : (\u2205 : Set A) \u2192 A) \u2194 Injective (algebraMap R A)", "start": [264, 1], "end": [265, 91], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mono", "code": "theorem AlgebraicIndependent.mono {t s : Set A} (h : t \u2286 s)\n    (hx : AlgebraicIndependent R ((\u2191) : s \u2192 A)) : AlgebraicIndependent R ((\u2191) : t \u2192 A)", "start": [270, 1], "end": [272, 76], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.to_subtype_range", "code": "theorem AlgebraicIndependent.to_subtype_range {\u03b9} {f : \u03b9 \u2192 A} (hf : AlgebraicIndependent R f) :\n    AlgebraicIndependent R ((\u2191) : range f \u2192 A)", "start": [277, 1], "end": [280, 56], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.to_subtype_range'", "code": "theorem AlgebraicIndependent.to_subtype_range' {\u03b9} {f : \u03b9 \u2192 A} (hf : AlgebraicIndependent R f) {t}\n    (ht : range f = t) : AlgebraicIndependent R ((\u2191) : t \u2192 A)", "start": [283, 1], "end": [285, 27], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_comp_subtype", "code": "theorem algebraicIndependent_comp_subtype {s : Set \u03b9} :\n    AlgebraicIndependent R (x \u2218 (\u2191) : s \u2192 A) \u2194\n      \u2200 p \u2208 MvPolynomial.supported R s, aeval x p = 0 \u2192 p = 0", "start": [288, 1], "end": [295, 64], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_subtype", "code": "theorem algebraicIndependent_subtype {s : Set A} :\n    AlgebraicIndependent R ((\u2191) : s \u2192 A) \u2194\n      \u2200 p : MvPolynomial A R, p \u2208 MvPolynomial.supported R s \u2192 aeval id p = 0 \u2192 p = 0", "start": [298, 1], "end": [301, 52], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_of_finite", "code": "theorem algebraicIndependent_of_finite (s : Set A)\n    (H : \u2200 (t) (_ : t \u2286 s), t.Finite \u2192 AlgebraicIndependent R ((\u2191) : t \u2192 A)) :\n    AlgebraicIndependent R ((\u2191) : s \u2192 A)", "start": [304, 1], "end": [308, 98], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.image_of_comp", "code": "theorem AlgebraicIndependent.image_of_comp {\u03b9 \u03b9'} (s : Set \u03b9) (f : \u03b9 \u2192 \u03b9') (g : \u03b9' \u2192 A)\n    (hs : AlgebraicIndependent R fun x : s => g (f x)) :\n    AlgebraicIndependent R fun x : f '' s => g x", "start": [311, 1], "end": [316, 81], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.image", "code": "theorem AlgebraicIndependent.image {\u03b9} {s : Set \u03b9} {f : \u03b9 \u2192 A}\n    (hs : AlgebraicIndependent R fun x : s => f x) :\n    AlgebraicIndependent R fun x : f '' s => (x : A)", "start": [319, 1], "end": [322, 55], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_iUnion_of_directed", "code": "theorem algebraicIndependent_iUnion_of_directed {\u03b7 : Type*} [Nonempty \u03b7] {s : \u03b7 \u2192 Set A}\n    (hs : Directed (\u00b7 \u2286 \u00b7) s) (h : \u2200 i, AlgebraicIndependent R ((\u2191) : s i \u2192 A)) :\n    AlgebraicIndependent R ((\u2191) : (\u22c3 i, s i) \u2192 A)", "start": [325, 1], "end": [331, 95], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_sUnion_of_directed", "code": "theorem algebraicIndependent_sUnion_of_directed {s : Set (Set A)} (hsn : s.Nonempty)\n    (hs : DirectedOn (\u00b7 \u2286 \u00b7) s) (h : \u2200 a \u2208 s, AlgebraicIndependent R ((\u2191) : a \u2192 A)) :\n    AlgebraicIndependent R ((\u2191) : \u22c3\u2080 s \u2192 A)", "start": [334, 1], "end": [339, 83], "kind": "commanddeclaration"}, {"full_name": "exists_maximal_algebraicIndependent", "code": "theorem exists_maximal_algebraicIndependent (s t : Set A) (hst : s \u2286 t)\n    (hs : AlgebraicIndependent R ((\u2191) : s \u2192 A)) :\n    \u2203 u : Set A, AlgebraicIndependent R ((\u2191) : u \u2192 A) \u2227 s \u2286 u \u2227 u \u2286 t \u2227\n      \u2200 x : Set A, AlgebraicIndependent R ((\u2191) : x \u2192 A) \u2192 u \u2286 x \u2192 x \u2286 t \u2192 x = u", "start": [342, 1], "end": [360, 51], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.aevalEquiv", "code": "@[simps!]\ndef AlgebraicIndependent.aevalEquiv (hx : AlgebraicIndependent R x) :\n    MvPolynomial \u03b9 R \u2243\u2090[R] Algebra.adjoin R (range x) := by\n  apply\n    AlgEquiv.ofBijective (AlgHom.codRestrict (@aeval R A \u03b9 _ _ _ x) (Algebra.adjoin R (range x)) _)\n  swap\n  \u00b7 intro x\n    rw [adjoin_range_eq_range_aeval]\n    exact AlgHom.mem_range_self _ _\n  \u00b7 constructor\n    \u00b7 exact (AlgHom.injective_codRestrict _ _ _).2 hx\n    \u00b7 rintro \u27e8x, hx\u27e9\n      rw [adjoin_range_eq_range_aeval] at hx\n      rcases hx with \u27e8y, rfl\u27e9\n      use y\n      ext\n      simp", "start": [367, 1], "end": [385, 11], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.algebraMap_aevalEquiv", "code": "theorem AlgebraicIndependent.algebraMap_aevalEquiv (hx : AlgebraicIndependent R x)\n    (p : MvPolynomial \u03b9 R) :\n    algebraMap (Algebra.adjoin R (range x)) A (hx.aevalEquiv p) = aeval x p", "start": [389, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.repr", "code": "def AlgebraicIndependent.repr (hx : AlgebraicIndependent R x) :\n    Algebra.adjoin R (range x) \u2192\u2090[R] MvPolynomial \u03b9 R :=\n  hx.aevalEquiv.symm", "start": [395, 1], "end": [399, 21], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.aeval_repr", "code": "@[simp]\ntheorem AlgebraicIndependent.aeval_repr (p) : aeval x (hx.repr p) = p", "start": [402, 1], "end": [404, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.aeval_comp_repr", "code": "theorem AlgebraicIndependent.aeval_comp_repr : (aeval x).comp hx.repr = Subalgebra.val _", "start": [407, 1], "end": [408, 30], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.repr_ker", "code": "theorem AlgebraicIndependent.repr_ker :\n    RingHom.ker (hx.repr : adjoin R (range x) \u2192+* MvPolynomial \u03b9 R) = \u22a5", "start": [411, 1], "end": [413, 64], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin", "code": "def AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin (hx : AlgebraicIndependent R x) :\n    MvPolynomial (Option \u03b9) R \u2243+* Polynomial (adjoin R (Set.range x)) :=\n  (MvPolynomial.optionEquivLeft _ _).toRingEquiv.trans\n    (Polynomial.mapEquiv hx.aevalEquiv.toRingEquiv)", "start": [419, 1], "end": [424, 52], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply", "code": "@[simp]\ntheorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_apply\n    (hx : AlgebraicIndependent R x) (y) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin y =\n      Polynomial.map (hx.aevalEquiv : MvPolynomial \u03b9 R \u2192+* adjoin R (range x))\n        (aeval (fun o : Option \u03b9 => o.elim Polynomial.X fun s : \u03b9 => Polynomial.C (X s)) y)", "start": [427, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C", "code": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_C\n    (hx : AlgebraicIndependent R x) (r) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (C r) = Polynomial.C (algebraMap _ _ r)", "start": [437, 1], "end": [442, 58], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none", "code": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n    (hx : AlgebraicIndependent R x) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X", "start": [447, 1], "end": [451, 22], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some", "code": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_some\n    (hx : AlgebraicIndependent R x) (i) :\n    hx.mvPolynomialOptionEquivPolynomialAdjoin (X (some i)) =\n      Polynomial.C (hx.aevalEquiv (X i))", "start": [456, 1], "end": [461, 39], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin", "code": "theorem AlgebraicIndependent.aeval_comp_mvPolynomialOptionEquivPolynomialAdjoin\n    (hx : AlgebraicIndependent R x) (a : A) :\n    RingHom.comp\n        (\u2191(Polynomial.aeval a : Polynomial (adjoin R (Set.range x)) \u2192\u2090[_] A) :\n          Polynomial (adjoin R (Set.range x)) \u2192+* A)\n        hx.mvPolynomialOptionEquivPolynomialAdjoin.toRingHom =\n      \u2191(MvPolynomial.aeval fun o : Option \u03b9 => o.elim a x : MvPolynomial (Option \u03b9) R \u2192\u2090[R] A)", "start": [466, 1], "end": [483, 65], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.option_iff", "code": "theorem AlgebraicIndependent.option_iff (hx : AlgebraicIndependent R x) (a : A) :\n    (AlgebraicIndependent R fun o : Option \u03b9 => o.elim a x) \u2194\n      \u00acIsAlgebraic (adjoin R (Set.range x)) a", "start": [486, 1], "end": [493, 59], "kind": "commanddeclaration"}, {"full_name": "IsTranscendenceBasis", "code": "def IsTranscendenceBasis (x : \u03b9 \u2192 A) : Prop :=\n  AlgebraicIndependent R x \u2227\n    \u2200 (s : Set A) (_ : AlgebraicIndependent R ((\u2191) : s \u2192 A)) (_ : range x \u2264 s), range x = s", "start": [498, 1], "end": [501, 92], "kind": "commanddeclaration"}, {"full_name": "exists_isTranscendenceBasis", "code": "theorem exists_isTranscendenceBasis (h : Injective (algebraMap R A)) :\n    \u2203 s : Set A, IsTranscendenceBasis R ((\u2191) : s \u2192 A)", "start": [504, 1], "end": [512, 55], "kind": "commanddeclaration"}, {"full_name": "AlgebraicIndependent.isTranscendenceBasis_iff", "code": "theorem AlgebraicIndependent.isTranscendenceBasis_iff {\u03b9 : Type w} {R : Type u} [CommRing R]\n    [Nontrivial R] {A : Type v} [CommRing A] [Algebra R A] {x : \u03b9 \u2192 A}\n    (i : AlgebraicIndependent R x) :\n    IsTranscendenceBasis R x \u2194\n      \u2200 (\u03ba : Type v) (w : \u03ba \u2192 A) (_ : AlgebraicIndependent R w) (j : \u03b9 \u2192 \u03ba) (_ : w \u2218 j = x),\n        Surjective j", "start": [517, 1], "end": [535, 18], "kind": "commanddeclaration"}, {"full_name": "IsTranscendenceBasis.isAlgebraic", "code": "theorem IsTranscendenceBasis.isAlgebraic [Nontrivial R] (hx : IsTranscendenceBasis R x) :\n    IsAlgebraic (adjoin R (range x)) A", "start": [538, 1], "end": [555, 65], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_empty_type", "code": "theorem algebraicIndependent_empty_type [IsEmpty \u03b9] [Nontrivial A] : AlgebraicIndependent K x", "start": [564, 1], "end": [566, 28], "kind": "commanddeclaration"}, {"full_name": "algebraicIndependent_empty", "code": "theorem algebraicIndependent_empty [Nontrivial A] :\n    AlgebraicIndependent K ((\u2191) : (\u2205 : Set A) \u2192 A)", "start": [569, 1], "end": [571, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Cardinal.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/Data/Polynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial.cardinal_mk_eq_max", "code": "@[simp]\ntheorem cardinal_mk_eq_max {R : Type u} [Semiring R] [Nontrivial R] : #(R[X]) = max #R \u2135\u2080", "start": [27, 1], "end": [31, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.cardinal_mk_le_max", "code": "theorem cardinal_mk_le_max {R : Type u} [Semiring R] : #(R[X]) \u2264 max #R \u2135\u2080", "start": [34, 1], "end": [37, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Arsinh.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Trigonometric/Deriv.lean", "Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.arsinh", "code": "def arsinh (x : \u211d) :=\n  log (x + sqrt (1 + x ^ 2))", "start": [51, 1], "end": [54, 29], "kind": "commanddeclaration"}, {"full_name": "Real.exp_arsinh", "code": "theorem exp_arsinh (x : \u211d) : exp (arsinh x) = x + sqrt (1 + x ^ 2)", "start": [57, 1], "end": [61, 7], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_zero", "code": "@[simp]\ntheorem arsinh_zero : arsinh 0 = 0", "start": [64, 1], "end": [65, 55], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_neg", "code": "@[simp]\ntheorem arsinh_neg (x : \u211d) : arsinh (-x) = -arsinh x", "start": [68, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_arsinh", "code": "@[simp]\ntheorem sinh_arsinh (x : \u211d) : sinh (arsinh x) = x", "start": [76, 1], "end": [79, 73], "kind": "commanddeclaration"}, {"full_name": "Real.cosh_arsinh", "code": "@[simp]\ntheorem cosh_arsinh (x : \u211d) : cosh (arsinh x) = sqrt (1 + x ^ 2)", "start": [82, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_surjective", "code": "theorem sinh_surjective : Surjective sinh", "start": [87, 1], "end": [89, 37], "kind": "commanddeclaration"}, {"full_name": "Real.sinh_bijective", "code": "theorem sinh_bijective : Bijective sinh", "start": [92, 1], "end": [94, 36], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_sinh", "code": "@[simp]\ntheorem arsinh_sinh (x : \u211d) : arsinh (sinh x) = x", "start": [97, 1], "end": [100, 72], "kind": "commanddeclaration"}, {"full_name": "Real.sinhEquiv", "code": "@[simps]\ndef sinhEquiv : \u211d \u2243 \u211d where\n  toFun := sinh\n  invFun := arsinh\n  left_inv := arsinh_sinh\n  right_inv := sinh_arsinh", "start": [103, 1], "end": [109, 27], "kind": "commanddeclaration"}, {"full_name": "Real.sinhOrderIso", "code": "@[simps! (config := .asFn)]\ndef sinhOrderIso : \u211d \u2243o \u211d where\n  toEquiv := sinhEquiv\n  map_rel_iff' := @sinh_le_sinh", "start": [112, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "Real.sinhHomeomorph", "code": "@[simps! (config := .asFn)]\ndef sinhHomeomorph : \u211d \u2243\u209c \u211d :=\n  sinhOrderIso.toHomeomorph", "start": [119, 1], "end": [122, 28], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_bijective", "code": "theorem arsinh_bijective : Bijective arsinh", "start": [125, 1], "end": [126, 27], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_injective", "code": "theorem arsinh_injective : Injective arsinh", "start": [129, 1], "end": [130, 27], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_surjective", "code": "theorem arsinh_surjective : Surjective arsinh", "start": [133, 1], "end": [134, 28], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_strictMono", "code": "theorem arsinh_strictMono : StrictMono arsinh", "start": [137, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_inj", "code": "@[simp]\ntheorem arsinh_inj : arsinh x = arsinh y \u2194 x = y", "start": [141, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_le_arsinh", "code": "@[simp]\ntheorem arsinh_le_arsinh : arsinh x \u2264 arsinh y \u2194 x \u2264 y", "start": [146, 1], "end": [148, 30], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_lt_arsinh", "code": "@[simp]\ntheorem arsinh_lt_arsinh : arsinh x < arsinh y \u2194 x < y", "start": [151, 1], "end": [153, 30], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_eq_zero_iff", "code": "@[simp]\ntheorem arsinh_eq_zero_iff : arsinh x = 0 \u2194 x = 0", "start": [156, 1], "end": [158, 39], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_nonneg_iff", "code": "@[simp]\ntheorem arsinh_nonneg_iff : 0 \u2264 arsinh x \u2194 0 \u2264 x", "start": [161, 1], "end": [162, 99], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_nonpos_iff", "code": "@[simp]\ntheorem arsinh_nonpos_iff : arsinh x \u2264 0 \u2194 x \u2264 0", "start": [165, 1], "end": [166, 99], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_pos_iff", "code": "@[simp]\ntheorem arsinh_pos_iff : 0 < arsinh x \u2194 0 < x", "start": [169, 1], "end": [171, 43], "kind": "commanddeclaration"}, {"full_name": "Real.arsinh_neg_iff", "code": "@[simp]\ntheorem arsinh_neg_iff : arsinh x < 0 \u2194 x < 0", "start": [174, 1], "end": [176, 43], "kind": "commanddeclaration"}, {"full_name": "Real.hasStrictDerivAt_arsinh", "code": "theorem hasStrictDerivAt_arsinh (x : \u211d) : HasStrictDerivAt arsinh (sqrt (1 + x ^ 2))\u207b\u00b9 x", "start": [179, 1], "end": [182, 29], "kind": "commanddeclaration"}, {"full_name": "Real.hasDerivAt_arsinh", "code": "theorem hasDerivAt_arsinh (x : \u211d) : HasDerivAt arsinh (sqrt (1 + x ^ 2))\u207b\u00b9 x", "start": [185, 1], "end": [186, 41], "kind": "commanddeclaration"}, {"full_name": "Real.differentiable_arsinh", "code": "theorem differentiable_arsinh : Differentiable \u211d arsinh", "start": [189, 1], "end": [190, 41], "kind": "commanddeclaration"}, {"full_name": "Real.contDiff_arsinh", "code": "theorem contDiff_arsinh {n : \u2115\u221e} : ContDiff \u211d n arsinh", "start": [193, 1], "end": [194, 95], "kind": "commanddeclaration"}, {"full_name": "Real.continuous_arsinh", "code": "@[continuity]\ntheorem continuous_arsinh : Continuous arsinh", "start": [197, 1], "end": [199, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.arsinh", "code": "theorem Filter.Tendsto.arsinh {\u03b1 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 \u211d} {a : \u211d}\n    (h : Tendsto f l (\ud835\udcdd a)) : Tendsto (fun x => arsinh (f x)) l (\ud835\udcdd (arsinh a))", "start": [206, 1], "end": [208, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.arsinh", "code": "nonrec theorem ContinuousAt.arsinh (h : ContinuousAt f a) :\n    ContinuousAt (fun x => arsinh (f x)) a", "start": [215, 1], "end": [217, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.arsinh", "code": "nonrec theorem ContinuousWithinAt.arsinh (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => arsinh (f x)) s a", "start": [220, 1], "end": [222, 11], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.arsinh", "code": "theorem ContinuousOn.arsinh (h : ContinuousOn f s) : ContinuousOn (fun x => arsinh (f x)) s", "start": [225, 1], "end": [226, 30], "kind": "commanddeclaration"}, {"full_name": "Continuous.arsinh", "code": "theorem Continuous.arsinh (h : Continuous f) : Continuous fun x => arsinh (f x)", "start": [229, 1], "end": [230, 27], "kind": "commanddeclaration"}, {"full_name": "HasStrictFDerivAt.arsinh", "code": "theorem HasStrictFDerivAt.arsinh (hf : HasStrictFDerivAt f f' a) :\n    HasStrictFDerivAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') a", "start": [240, 1], "end": [242, 58], "kind": "commanddeclaration"}, {"full_name": "HasFDerivAt.arsinh", "code": "theorem HasFDerivAt.arsinh (hf : HasFDerivAt f f' a) :\n    HasFDerivAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') a", "start": [245, 1], "end": [247, 46], "kind": "commanddeclaration"}, {"full_name": "HasFDerivWithinAt.arsinh", "code": "theorem HasFDerivWithinAt.arsinh (hf : HasFDerivWithinAt f f' s a) :\n    HasFDerivWithinAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') s a", "start": [250, 1], "end": [252, 52], "kind": "commanddeclaration"}, {"full_name": "DifferentiableAt.arsinh", "code": "theorem DifferentiableAt.arsinh (h : DifferentiableAt \u211d f a) :\n    DifferentiableAt \u211d (fun x => arsinh (f x)) a", "start": [255, 1], "end": [257, 37], "kind": "commanddeclaration"}, {"full_name": "DifferentiableWithinAt.arsinh", "code": "theorem DifferentiableWithinAt.arsinh (h : DifferentiableWithinAt \u211d f s a) :\n    DifferentiableWithinAt \u211d (fun x => arsinh (f x)) s a", "start": [260, 1], "end": [262, 60], "kind": "commanddeclaration"}, {"full_name": "DifferentiableOn.arsinh", "code": "theorem DifferentiableOn.arsinh (h : DifferentiableOn \u211d f s) :\n    DifferentiableOn \u211d (fun x => arsinh (f x)) s", "start": [265, 1], "end": [266, 80], "kind": "commanddeclaration"}, {"full_name": "Differentiable.arsinh", "code": "theorem Differentiable.arsinh (h : Differentiable \u211d f) : Differentiable \u211d fun x => arsinh (f x)", "start": [269, 1], "end": [270, 31], "kind": "commanddeclaration"}, {"full_name": "ContDiffAt.arsinh", "code": "theorem ContDiffAt.arsinh (h : ContDiffAt \u211d n f a) : ContDiffAt \u211d n (fun x => arsinh (f x)) a", "start": [273, 1], "end": [274, 38], "kind": "commanddeclaration"}, {"full_name": "ContDiffWithinAt.arsinh", "code": "theorem ContDiffWithinAt.arsinh (h : ContDiffWithinAt \u211d n f s a) :\n    ContDiffWithinAt \u211d n (fun x => arsinh (f x)) s a", "start": [277, 1], "end": [279, 55], "kind": "commanddeclaration"}, {"full_name": "ContDiff.arsinh", "code": "theorem ContDiff.arsinh (h : ContDiff \u211d n f) : ContDiff \u211d n fun x => arsinh (f x)", "start": [282, 1], "end": [283, 25], "kind": "commanddeclaration"}, {"full_name": "ContDiffOn.arsinh", "code": "theorem ContDiffOn.arsinh (h : ContDiffOn \u211d n f s) : ContDiffOn \u211d n (fun x => arsinh (f x)) s", "start": [286, 1], "end": [287, 30], "kind": "commanddeclaration"}, {"full_name": "HasStrictDerivAt.arsinh", "code": "theorem HasStrictDerivAt.arsinh (hf : HasStrictDerivAt f f' a) :\n    HasStrictDerivAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') a", "start": [296, 1], "end": [298, 40], "kind": "commanddeclaration"}, {"full_name": "HasDerivAt.arsinh", "code": "theorem HasDerivAt.arsinh (hf : HasDerivAt f f' a) :\n    HasDerivAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') a", "start": [301, 1], "end": [303, 34], "kind": "commanddeclaration"}, {"full_name": "HasDerivWithinAt.arsinh", "code": "theorem HasDerivWithinAt.arsinh (hf : HasDerivWithinAt f f' s a) :\n    HasDerivWithinAt (fun x => arsinh (f x)) ((sqrt (1 + f a ^ 2))\u207b\u00b9 \u2022 f') s a", "start": [306, 1], "end": [308, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "imports": ["Mathlib/Analysis/InnerProductSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.inversion", "code": "def inversion (c : P) (R : \u211d) (x : P) : P :=\n  (R / dist x c) ^ 2 \u2022 (x -\u1d65 c) +\u1d65 c", "start": [39, 1], "end": [43, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_eq_lineMap", "code": "theorem inversion_eq_lineMap (c : P) (R : \u211d) (x : P) :\n    inversion c R x = lineMap c x ((R / dist x c) ^ 2)", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_vsub_center", "code": "theorem inversion_vsub_center (c : P) (R : \u211d) (x : P) :\n    inversion c R x -\u1d65 c = (R / dist x c) ^ 2 \u2022 (x -\u1d65 c)", "start": [58, 1], "end": [60, 16], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_self", "code": "@[simp]\ntheorem inversion_self (c : P) (R : \u211d) : inversion c R c = c", "start": [63, 1], "end": [64, 84], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_zero_radius", "code": "@[simp]\ntheorem inversion_zero_radius (c x : P) : inversion c 0 x = c", "start": [67, 1], "end": [68, 85], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_mul", "code": "theorem inversion_mul (c : P) (a R : \u211d) (x : P) :\n    inversion c (a * R) x = homothety c (a ^ 2) (inversion c R x)", "start": [70, 1], "end": [73, 13], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_dist_center", "code": "@[simp]\ntheorem inversion_dist_center (c x : P) : inversion c (dist x c) x = x", "start": [75, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_dist_center'", "code": "@[simp]\ntheorem inversion_dist_center' (c x : P) : inversion c (dist c x) x = x", "start": [83, 1], "end": [85, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_of_mem_sphere", "code": "theorem inversion_of_mem_sphere (h : x \u2208 Metric.sphere c R) : inversion c R x = x", "start": [87, 1], "end": [88, 36], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_inversion_center", "code": "theorem dist_inversion_center (c x : P) (R : \u211d) : dist (inversion c R x) c = R ^ 2 / dist x c", "start": [91, 1], "end": [97, 81], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_center_inversion", "code": "theorem dist_center_inversion (c x : P) (R : \u211d) : dist c (inversion c R x) = R ^ 2 / dist c x", "start": [100, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_inversion", "code": "@[simp]\ntheorem inversion_inversion (c : P) {R : \u211d} (hR : R \u2260 0) (x : P) :\n    inversion c R (inversion c R x) = x", "start": [106, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_involutive", "code": "theorem inversion_involutive (c : P) {R : \u211d} (hR : R \u2260 0) : Involutive (inversion c R)", "start": [117, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_surjective", "code": "theorem inversion_surjective (c : P) {R : \u211d} (hR : R \u2260 0) : Surjective (inversion c R)", "start": [121, 1], "end": [122, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_injective", "code": "theorem inversion_injective (c : P) {R : \u211d} (hR : R \u2260 0) : Injective (inversion c R)", "start": [125, 1], "end": [126, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_bijective", "code": "theorem inversion_bijective (c : P) {R : \u211d} (hR : R \u2260 0) : Bijective (inversion c R)", "start": [129, 1], "end": [130, 40], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_eq_center", "code": "theorem inversion_eq_center (hR : R \u2260 0) : inversion c R x = c \u2194 x = c", "start": [133, 1], "end": [134, 59], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.inversion_eq_center'", "code": "@[simp]\ntheorem inversion_eq_center' : inversion c R x = c \u2194 x = c \u2228 R = 0", "start": [136, 1], "end": [138, 57], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.center_eq_inversion", "code": "theorem center_eq_inversion (hR : R \u2260 0) : c = inversion c R x \u2194 x = c", "start": [140, 1], "end": [141, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.center_eq_inversion'", "code": "@[simp]\ntheorem center_eq_inversion' : c = inversion c R x \u2194 x = c \u2228 R = 0", "start": [143, 1], "end": [145, 37], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_inversion_inversion", "code": "theorem dist_inversion_inversion (hx : x \u2260 c) (hy : y \u2260 c) (R : \u211d) :\n    dist (inversion c R x) (inversion c R y) = R ^ 2 / (dist x c * dist y c) * dist x y", "start": [156, 1], "end": [162, 68], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_inversion_mul_dist_center_eq", "code": "theorem dist_inversion_mul_dist_center_eq (hx : x \u2260 c) (hy : y \u2260 c) :\n    dist (inversion c R x) y * dist x c = dist x (inversion c R y) * dist y c", "start": [165, 1], "end": [172, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist", "code": "theorem mul_dist_le_mul_dist_add_mul_dist (a b c d : P) :\n    dist a c * dist b d \u2264 dist a b * dist c d + dist b c * dist a d", "start": [178, 1], "end": [198, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inversion", "code": "protected theorem Filter.Tendsto.inversion {l : Filter \u03b1} {fc fx : \u03b1 \u2192 P} {fR : \u03b1 \u2192 \u211d}\n    (hc : Tendsto fc l (\ud835\udcdd c)) (hR : Tendsto fR l (\ud835\udcdd R)) (hx : Tendsto fx l (\ud835\udcdd x))\n    (hne : x \u2260 c) :\n    Tendsto (fun a \u21a6 inversion (fc a) (fR a) (fx a)) l (\ud835\udcdd (inversion c R x))", "start": [209, 1], "end": [213, 82], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.inversion", "code": "protected nonrec theorem ContinuousWithinAt.inversion (hc : ContinuousWithinAt c s a\u2080)\n    (hR : ContinuousWithinAt R s a\u2080) (hx : ContinuousWithinAt x s a\u2080) (hne : x a\u2080 \u2260 c a\u2080) :\n    ContinuousWithinAt (fun a \u21a6 inversion (c a) (R a) (x a)) s a\u2080", "start": [217, 1], "end": [220, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.inversion", "code": "protected nonrec theorem ContinuousAt.inversion (hc : ContinuousAt c a\u2080) (hR : ContinuousAt R a\u2080)\n    (hx : ContinuousAt x a\u2080) (hne : x a\u2080 \u2260 c a\u2080) :\n    ContinuousAt (fun a \u21a6 inversion (c a) (R a) (x a)) a\u2080", "start": [222, 1], "end": [225, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.inversion", "code": "protected theorem ContinuousOn.inversion (hc : ContinuousOn c s) (hR : ContinuousOn R s)\n    (hx : ContinuousOn x s) (hne : \u2200 a \u2208 s, x a \u2260 c a) :\n    ContinuousOn (fun a \u21a6 inversion (c a) (R a) (x a)) s", "start": [227, 1], "end": [230, 53], "kind": "commanddeclaration"}, {"full_name": "Continuous.inversion", "code": "protected theorem Continuous.inversion (hc : Continuous c) (hR : Continuous R) (hx : Continuous x)\n    (hne : \u2200 a, x a \u2260 c a) : Continuous (fun a \u21a6 inversion (c a) (R a) (x a))", "start": [232, 1], "end": [235, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Limits.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/FunctorCategory.lean", "Mathlib/CategoryTheory/Monoidal/Functorial.lean", "Mathlib/CategoryTheory/Limits/HasLimits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Limits.limitFunctorial", "code": "instance limitFunctorial : Functorial fun F : J \u2964 C => limit F where\n  map' := Limits.lim.map", "start": [37, 1], "end": [38, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitFunctorial_map", "code": "@[simp]\ntheorem limitFunctorial_map {F G : J \u2964 C} (\u03b1 : F \u27f6 G) :\n    map (fun F : J \u2964 C => limit F) \u03b1 = Limits.lim.map \u03b1", "start": [41, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limitLaxMonoidal", "code": "@[simps]\ninstance limitLaxMonoidal : LaxMonoidal fun F : J \u2964 C => limit F where\n  \u03b5 :=\n    limit.lift _\n      { pt := _\n        \u03c0 := { app := fun j => \ud835\udfd9 _ } }\n  \u03bc F G :=\n    limit.lift (F \u2297 G)\n      { pt := limit F \u2297 limit G\n        \u03c0 :=\n          { app := fun j => limit.\u03c0 F j \u2297 limit.\u03c0 G j\n            naturality := fun j j' f => by\n              dsimp\n              simp only [Category.id_comp, \u2190 tensor_comp, limit.w] } }\n  \u03bc_natural f g := by\n    ext; dsimp\n    simp only [limit.lift_\u03c0, Cones.postcompose_obj_\u03c0, Monoidal.tensorHom_app, limit.lift_map,\n      NatTrans.comp_app, Category.assoc, \u2190 tensor_comp, limMap_\u03c0]\n  associativity X Y Z := by\n    ext j; dsimp\n    simp only [limit.lift_\u03c0, Cones.postcompose_obj_\u03c0, Monoidal.associator_hom_app, limit.lift_map,\n      NatTrans.comp_app, Category.assoc]\n    slice_lhs 2 2 => rw [\u2190 tensor_id_comp_id_tensor]\n    slice_lhs 1 2 =>\n      rw [\u2190 comp_tensor_id, limit.lift_\u03c0]\n      dsimp\n    slice_lhs 1 2 => rw [tensor_id_comp_id_tensor]\n    conv_lhs => rw [associator_naturality]\n    conv_rhs => rw [\u2190 id_tensor_comp_tensor_id (limit.\u03c0 (Y \u2297 Z) j)]\n    slice_rhs 2 3 =>\n      rw [\u2190 id_tensor_comp, limit.lift_\u03c0]\n      dsimp\n    dsimp; simp\n  left_unitality X := by\n    ext j; dsimp\n    simp only [limit.lift_map, Category.assoc, limit.lift_\u03c0, Cones.postcompose_obj_pt,\n      Cones.postcompose_obj_\u03c0, NatTrans.comp_app, Functor.const_obj_obj, Monoidal.tensorObj_obj,\n      Monoidal.tensorUnit_obj, Monoidal.leftUnitor_hom_app]\n    conv_rhs => rw [\u2190 tensor_id_comp_id_tensor (limit.\u03c0 X j)]\n    slice_rhs 1 2 =>\n      rw [\u2190 comp_tensor_id]\n      erw [limit.lift_\u03c0]\n      dsimp\n    slice_rhs 2 3 => rw [leftUnitor_naturality]\n    simp\n  right_unitality X := by\n    ext j; dsimp\n    simp only [limit.lift_map, Category.assoc, limit.lift_\u03c0, Cones.postcompose_obj_pt,\n      Cones.postcompose_obj_\u03c0, NatTrans.comp_app, Functor.const_obj_obj, Monoidal.tensorObj_obj,\n      Monoidal.tensorUnit_obj, Monoidal.rightUnitor_hom_app]\n    conv_rhs => rw [\u2190 id_tensor_comp_tensor_id _ (limit.\u03c0 X j)]\n    slice_rhs 1 2 =>\n      rw [\u2190 id_tensor_comp]\n      erw [limit.lift_\u03c0]\n      dsimp\n    slice_rhs 2 3 => rw [rightUnitor_naturality]\n    simp", "start": [49, 1], "end": [105, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax", "code": "def limLax : LaxMonoidalFunctor (J \u2964 C) C :=\n  LaxMonoidalFunctor.of fun F : J \u2964 C => limit F", "start": [108, 1], "end": [110, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax_obj", "code": "@[simp]\ntheorem limLax_obj (F : J \u2964 C) : limLax.obj F = limit F", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax_obj'", "code": "theorem limLax_obj' (F : J \u2964 C) : limLax.obj F = lim.obj F", "start": [118, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax_map", "code": "@[simp]\ntheorem limLax_map {F G : J \u2964 C} (\u03b1 : F \u27f6 G) : limLax.map \u03b1 = lim.map \u03b1", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax_\u03b5", "code": "@[simp]\ntheorem limLax_\u03b5 :\n    (@limLax J _ C _ _ _).\u03b5 =\n      limit.lift _\n        { pt := _\n          \u03c0 := { app := fun j => \ud835\udfd9 _ } }", "start": [127, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Limits.limLax_\u03bc", "code": "@[simp]\ntheorem limLax_\u03bc (F G : J \u2964 C) :\n    (@limLax J _ C _ _ _).\u03bc F G =\n      limit.lift (F \u2297 G)\n        { pt := limit F \u2297 limit G\n          \u03c0 :=\n            { app := fun j => limit.\u03c0 F j \u2297 limit.\u03c0 G j\n              naturality := fun j j' f => by\n                dsimp\n                simp only [Category.id_comp, \u2190 tensor_comp, limit.w] } }", "start": [136, 1], "end": [146, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Internal/FunctorCategory.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/FunctorCategory.lean", "Mathlib/CategoryTheory/Monoidal/CommMon_.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.Functor.obj", "code": "@[simps]\ndef Functor.obj (A : Mon_ (C \u2964 D)) : C \u2964 Mon_ D where\n  obj X :=\n    { X := A.X.obj X\n      one := A.one.app X\n      mul := A.mul.app X\n      one_mul := congr_app A.one_mul X\n      mul_one := congr_app A.mul_one X\n      mul_assoc := congr_app A.mul_assoc X }\n  map f :=\n    { hom := A.X.map f\n      one_hom := by rw [\u2190 A.one.naturality, tensorUnit_map]; dsimp; rw [Category.id_comp]\n      mul_hom := by dsimp; rw [\u2190 A.mul.naturality, tensorObj_map] }\n  map_id X := by ext; dsimp; rw [CategoryTheory.Functor.map_id]\n  map_comp f g := by ext; dsimp; rw [Functor.map_comp]", "start": [47, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.functor", "code": "@[simps]\ndef functor : Mon_ (C \u2964 D) \u2964 C \u2964 Mon_ D where\n  obj := Functor.obj\n  map f :=\n    { app := fun X =>\n        { hom := f.hom.app X\n          one_hom := congr_app f.one_hom X\n          mul_hom := congr_app f.mul_hom X } }", "start": [64, 1], "end": [74, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.Inverse.obj", "code": "@[simps]\ndef Inverse.obj (F : C \u2964 Mon_ D) : Mon_ (C \u2964 D) where\n  X := F \u22d9 Mon_.forget D\n  one := { app := fun X => (F.obj X).one }\n  mul := { app := fun X => (F.obj X).mul }\n  one_mul := by ext X; exact (F.obj X).one_mul\n  mul_one := by ext X; exact (F.obj X).mul_one\n  mul_assoc := by ext X; exact (F.obj X).mul_assoc", "start": [80, 1], "end": [89, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.inverse", "code": "@[simps]\ndef inverse : (C \u2964 Mon_ D) \u2964 Mon_ (C \u2964 D) where\n  obj := Inverse.obj\n  map \u03b1 :=\n    { hom :=\n        { app := fun X => (\u03b1.app X).hom\n          naturality := fun X Y f => congr_arg Mon_.Hom.hom (\u03b1.naturality f) }\n      one_hom := by ext x; dsimp; rw [(\u03b1.app x).one_hom]\n      mul_hom := by ext x; dsimp; rw [(\u03b1.app x).mul_hom] }", "start": [91, 1], "end": [102, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.unitIso", "code": "@[simps!]\ndef unitIso : \ud835\udfed (Mon_ (C \u2964 D)) \u2245 functor \u22d9 inverse :=\n  NatIso.ofComponents\n    (fun A =>\n      { hom :=\n          { hom := { app := fun _ => \ud835\udfd9 _ }\n            one_hom := by ext X; dsimp; simp only [Category.comp_id]\n            mul_hom := by\n              ext X; dsimp; simp only [tensor_id, Category.id_comp, Category.comp_id] }\n        inv :=\n          { hom := { app := fun _ => \ud835\udfd9 _ }\n            one_hom := by ext X; dsimp; simp only [Category.comp_id]\n            mul_hom := by\n              ext X\n              dsimp\n              simp only [tensor_id, Category.id_comp, Category.comp_id] } })\n    fun f => by\n      ext X\n      simp only [Functor.id_map, Mon_.comp_hom', NatTrans.comp_app, Category.comp_id,\n        Functor.comp_map, inverse_map_hom_app, functor_map_app_hom, Category.id_comp]", "start": [106, 1], "end": [127, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.MonFunctorCategoryEquivalence.counitIso", "code": "@[simps!]\ndef counitIso : inverse \u22d9 functor \u2245 \ud835\udfed (C \u2964 Mon_ D) :=\n  NatIso.ofComponents\n    (fun A =>\n      NatIso.ofComponents\n        (fun X =>\n          { hom := { hom := \ud835\udfd9 _ }\n            inv := { hom := \ud835\udfd9 _ } })\n        (by aesop_cat))\n    (by aesop_cat)", "start": [131, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.monFunctorCategoryEquivalence", "code": "@[simps]\ndef monFunctorCategoryEquivalence : Mon_ (C \u2964 D) \u224c C \u2964 Mon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso", "start": [150, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.functor", "code": "@[simps!]\ndef functor : CommMon_ (C \u2964 D) \u2964 C \u2964 CommMon_ D where\n  obj A :=\n    { (monFunctorCategoryEquivalence C D).functor.obj A.toMon_ with\n      obj := fun X =>\n        { ((monFunctorCategoryEquivalence C D).functor.obj A.toMon_).obj X with\n          mul_comm := congr_app A.mul_comm X } }\n  map f := { app := fun X => ((monFunctorCategoryEquivalence C D).functor.map f).app X }", "start": [169, 1], "end": [179, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.inverse", "code": "@[simps!]\ndef inverse : (C \u2964 CommMon_ D) \u2964 CommMon_ (C \u2964 D) where\n  obj F :=\n    { (monFunctorCategoryEquivalence C D).inverse.obj (F \u22d9 CommMon_.forget\u2082Mon_ D) with\n      mul_comm := by ext X; exact (F.obj X).mul_comm }\n  map \u03b1 := (monFunctorCategoryEquivalence C D).inverse.map (whiskerRight \u03b1 _)", "start": [183, 1], "end": [191, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.unitIso", "code": "@[simps!]\ndef unitIso : \ud835\udfed (CommMon_ (C \u2964 D)) \u2245 functor \u22d9 inverse :=\n  NatIso.ofComponents\n    (fun A =>\n      { hom :=\n          { hom := { app := fun _ => \ud835\udfd9 _ }\n            one_hom := by ext X; dsimp; simp only [Category.comp_id]\n            mul_hom := by ext X; dsimp; simp only [tensor_id, Category.id_comp, Category.comp_id] }\n        inv :=\n          { hom := { app := fun _ => \ud835\udfd9 _ }\n            one_hom := by ext X; dsimp; simp only [Category.comp_id]\n            mul_hom := by\n              ext X\n              dsimp\n              simp only [tensor_id, Category.id_comp, Category.comp_id] } })\n    fun f => by\n      ext X\n      dsimp\n      simp only [Category.id_comp, Category.comp_id]", "start": [195, 1], "end": [215, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.CommMonFunctorCategoryEquivalence.counitIso", "code": "@[simps!]\ndef counitIso : inverse \u22d9 functor \u2245 \ud835\udfed (C \u2964 CommMon_ D) :=\n  NatIso.ofComponents\n    (fun A =>\n      NatIso.ofComponents\n        (fun X =>\n          { hom := { hom := \ud835\udfd9 _ }\n            inv := { hom := \ud835\udfd9 _ } })\n        (by aesop_cat))\n    (by aesop_cat)", "start": [219, 1], "end": [230, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Monoidal.commMonFunctorCategoryEquivalence", "code": "@[simps]\ndef commMonFunctorCategoryEquivalence : CommMon_ (C \u2964 D) \u224c C \u2964 CommMon_ D where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso", "start": [238, 1], "end": [247, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Convex/Exposed.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/Analysis/Convex/Extreme.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Order/Basic.lean", "Mathlib/Analysis/Convex/Function.lean"], "premises": [{"full_name": "IsExposed", "code": "def IsExposed (A B : Set E) : Prop :=\n  B.Nonempty \u2192 \u2203 l : E \u2192L[\ud835\udd5c] \ud835\udd5c, B = { x \u2208 A | \u2200 y \u2208 A, l y \u2264 l x }", "start": [58, 1], "end": [61, 67], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toExposed", "code": "def ContinuousLinearMap.toExposed (l : E \u2192L[\ud835\udd5c] \ud835\udd5c) (A : Set E) : Set E :=\n  { x \u2208 A | \u2200 y \u2208 A, l y \u2264 l x }", "start": [71, 1], "end": [74, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousLinearMap.toExposed.isExposed", "code": "theorem ContinuousLinearMap.toExposed.isExposed : IsExposed \ud835\udd5c A (l.toExposed A)", "start": [77, 1], "end": [77, 101], "kind": "commanddeclaration"}, {"full_name": "isExposed_empty", "code": "theorem isExposed_empty : IsExposed \ud835\udd5c A \u2205", "start": [80, 1], "end": [82, 11], "kind": "commanddeclaration"}, {"full_name": "IsExposed.subset", "code": "protected theorem subset (hAB : IsExposed \ud835\udd5c A B) : B \u2286 A", "start": [87, 1], "end": [90, 13], "kind": "commanddeclaration"}, {"full_name": "IsExposed.refl", "code": "@[refl]\nprotected theorem refl (A : Set E) : IsExposed \ud835\udd5c A A", "start": [93, 1], "end": [95, 81], "kind": "commanddeclaration"}, {"full_name": "IsExposed.antisymm", "code": "protected theorem antisymm (hB : IsExposed \ud835\udd5c A B) (hA : IsExposed \ud835\udd5c B A) : A = B", "start": [98, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "IsExposed.mono", "code": "protected theorem mono (hC : IsExposed \ud835\udd5c A C) (hBA : B \u2286 A) (hCB : C \u2286 B) : IsExposed \ud835\udd5c B C", "start": [106, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "IsExposed.eq_inter_halfspace'", "code": "theorem eq_inter_halfspace' {A B : Set E} (hAB : IsExposed \ud835\udd5c A B) (hB : B.Nonempty) :\n    \u2203 l : E \u2192L[\ud835\udd5c] \ud835\udd5c, \u2203 a, B = { x \u2208 A | a \u2264 l x }", "start": [113, 1], "end": [121, 48], "kind": "commanddeclaration"}, {"full_name": "IsExposed.eq_inter_halfspace", "code": "theorem eq_inter_halfspace [Nontrivial \ud835\udd5c] {A B : Set E} (hAB : IsExposed \ud835\udd5c A B) :\n    \u2203 l : E \u2192L[\ud835\udd5c] \ud835\udd5c, \u2203 a, B = { x \u2208 A | a \u2264 l x }", "start": [124, 1], "end": [136, 35], "kind": "commanddeclaration"}, {"full_name": "IsExposed.inter", "code": "protected theorem inter [ContinuousAdd \ud835\udd5c] {A B C : Set E} (hB : IsExposed \ud835\udd5c A B)\n    (hC : IsExposed \ud835\udd5c A C) : IsExposed \ud835\udd5c A (B \u2229 C)", "start": [139, 1], "end": [152, 101], "kind": "commanddeclaration"}, {"full_name": "IsExposed.sInter", "code": "theorem sInter [ContinuousAdd \ud835\udd5c] {F : Finset (Set E)} (hF : F.Nonempty)\n    (hAF : \u2200 B \u2208 F, IsExposed \ud835\udd5c A B) : IsExposed \ud835\udd5c A (\u22c2\u2080 F)", "start": [155, 1], "end": [165, 69], "kind": "commanddeclaration"}, {"full_name": "IsExposed.inter_left", "code": "theorem inter_left (hC : IsExposed \ud835\udd5c A C) (hCB : C \u2286 B) : IsExposed \ud835\udd5c (A \u2229 B) C", "start": [168, 1], "end": [172, 96], "kind": "commanddeclaration"}, {"full_name": "IsExposed.inter_right", "code": "theorem inter_right (hC : IsExposed \ud835\udd5c B C) (hCA : C \u2286 A) : IsExposed \ud835\udd5c (A \u2229 B) C", "start": [175, 1], "end": [177, 26], "kind": "commanddeclaration"}, {"full_name": "IsExposed.isClosed", "code": "protected theorem isClosed [OrderClosedTopology \ud835\udd5c] {A B : Set E} (hAB : IsExposed \ud835\udd5c A B)\n    (hA : IsClosed A) : IsClosed B", "start": [180, 1], "end": [185, 68], "kind": "commanddeclaration"}, {"full_name": "IsExposed.isCompact", "code": "protected theorem isCompact [OrderClosedTopology \ud835\udd5c] [T2Space E] {A B : Set E}\n    (hAB : IsExposed \ud835\udd5c A B) (hA : IsCompact A) : IsCompact B", "start": [188, 1], "end": [190, 62], "kind": "commanddeclaration"}, {"full_name": "Set.exposedPoints", "code": "def Set.exposedPoints (A : Set E) : Set E :=\n  { x \u2208 A | \u2203 l : E \u2192L[\ud835\udd5c] \ud835\udd5c, \u2200 y \u2208 A, l y \u2264 l x \u2227 (l x \u2264 l y \u2192 y = x) }", "start": [197, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "exposed_point_def", "code": "theorem exposed_point_def :\n    x \u2208 A.exposedPoints \ud835\udd5c \u2194 x \u2208 A \u2227 \u2203 l : E \u2192L[\ud835\udd5c] \ud835\udd5c, \u2200 y \u2208 A, l y \u2264 l x \u2227 (l x \u2264 l y \u2192 y = x)", "start": [205, 1], "end": [207, 10], "kind": "commanddeclaration"}, {"full_name": "exposedPoints_subset", "code": "theorem exposedPoints_subset : A.exposedPoints \ud835\udd5c \u2286 A", "start": [210, 1], "end": [210, 73], "kind": "commanddeclaration"}, {"full_name": "exposedPoints_empty", "code": "@[simp]\ntheorem exposedPoints_empty : (\u2205 : Set E).exposedPoints \ud835\udd5c = \u2205", "start": [213, 1], "end": [215, 42], "kind": "commanddeclaration"}, {"full_name": "mem_exposedPoints_iff_exposed_singleton", "code": "theorem mem_exposedPoints_iff_exposed_singleton : x \u2208 A.exposedPoints \ud835\udd5c \u2194 IsExposed \ud835\udd5c A {x}", "start": [218, 1], "end": [230, 82], "kind": "commanddeclaration"}, {"full_name": "IsExposed.convex", "code": "protected theorem convex (hAB : IsExposed \ud835\udd5c A B) (hA : Convex \ud835\udd5c A) : Convex \ud835\udd5c B", "start": [242, 1], "end": [249, 49], "kind": "commanddeclaration"}, {"full_name": "IsExposed.isExtreme", "code": "protected theorem isExtreme (hAB : IsExposed \ud835\udd5c A B) : IsExtreme \ud835\udd5c A B", "start": [252, 1], "end": [262, 21], "kind": "commanddeclaration"}, {"full_name": "exposedPoints_subset_extremePoints", "code": "theorem exposedPoints_subset_extremePoints : A.exposedPoints \ud835\udd5c \u2286 A.extremePoints \ud835\udd5c", "start": [267, 1], "end": [268, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/HahnBanach/Separation.lean", "imports": ["Mathlib/Topology/Algebra/Module/FiniteDimension.lean", "Mathlib/Topology/Algebra/Module/LocallyConvex.lean", "Mathlib/Analysis/Convex/Cone/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/Convex/Gauge.lean"], "premises": [{"full_name": "separate_convex_open_set", "code": "theorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module \u211d E] [ContinuousSMul \u211d E] {s : Set E} (hs\u2080 : (0 : E) \u2208 s) (hs\u2081 : Convex \u211d s)\n    (hs\u2082 : IsOpen s) {x\u2080 : E} (hx\u2080 : x\u2080 \u2209 s) : \u2203 f : E \u2192L[\u211d] \u211d, f x\u2080 = 1 \u2227 \u2200 x \u2208 s, f x < 1", "start": [44, 1], "end": [76, 62], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_open", "code": "theorem geometric_hahn_banach_open (hs\u2081 : Convex \u211d s) (hs\u2082 : IsOpen s) (ht : Convex \u211d t)\n    (disj : Disjoint s t) : \u2203 (f : E \u2192L[\u211d] \u211d) (u : \u211d), (\u2200 a \u2208 s, f a < u) \u2227 \u2200 b \u2208 t, u \u2264 f b", "start": [82, 1], "end": [112, 89], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_open_point", "code": "theorem geometric_hahn_banach_open_point (hs\u2081 : Convex \u211d s) (hs\u2082 : IsOpen s) (disj : x \u2209 s) :\n    \u2203 f : E \u2192L[\u211d] \u211d, \u2200 a \u2208 s, f a < f x", "start": [115, 1], "end": [119, 69], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_point_open", "code": "theorem geometric_hahn_banach_point_open (ht\u2081 : Convex \u211d t) (ht\u2082 : IsOpen t) (disj : x \u2209 t) :\n    \u2203 f : E \u2192L[\u211d] \u211d, \u2200 b \u2208 t, f x < f b", "start": [122, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_open_open", "code": "theorem geometric_hahn_banach_open_open (hs\u2081 : Convex \u211d s) (hs\u2082 : IsOpen s) (ht\u2081 : Convex \u211d t)\n    (ht\u2083 : IsOpen t) (disj : Disjoint s t) :\n    \u2203 (f : E \u2192L[\u211d] \u211d) (u : \u211d), (\u2200 a \u2208 s, f a < u) \u2227 \u2200 b \u2208 t, u < f b", "start": [128, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_compact_closed", "code": "theorem geometric_hahn_banach_compact_closed (hs\u2081 : Convex \u211d s) (hs\u2082 : IsCompact s)\n    (ht\u2081 : Convex \u211d t) (ht\u2082 : IsClosed t) (disj : Disjoint s t) :\n    \u2203 (f : E \u2192L[\u211d] \u211d) (u v : \u211d), (\u2200 a \u2208 s, f a < u) \u2227 u < v \u2227 \u2200 b \u2208 t, v < f b", "start": [151, 1], "end": [166, 21], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_closed_compact", "code": "theorem geometric_hahn_banach_closed_compact (hs\u2081 : Convex \u211d s) (hs\u2082 : IsClosed s)\n    (ht\u2081 : Convex \u211d t) (ht\u2082 : IsCompact t) (disj : Disjoint s t) :\n    \u2203 (f : E \u2192L[\u211d] \u211d) (u v : \u211d), (\u2200 a \u2208 s, f a < u) \u2227 u < v \u2227 \u2200 b \u2208 t, v < f b", "start": [169, 1], "end": [176, 72], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_point_closed", "code": "theorem geometric_hahn_banach_point_closed (ht\u2081 : Convex \u211d t) (ht\u2082 : IsClosed t) (disj : x \u2209 t) :\n    \u2203 (f : E \u2192L[\u211d] \u211d) (u : \u211d), f x < u \u2227 \u2200 b \u2208 t, u < f b", "start": [179, 1], "end": [184, 52], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_closed_point", "code": "theorem geometric_hahn_banach_closed_point (hs\u2081 : Convex \u211d s) (hs\u2082 : IsClosed s) (disj : x \u2209 s) :\n    \u2203 (f : E \u2192L[\u211d] \u211d) (u : \u211d), (\u2200 a \u2208 s, f a < u) \u2227 u < f x", "start": [187, 1], "end": [192, 51], "kind": "commanddeclaration"}, {"full_name": "geometric_hahn_banach_point_point", "code": "theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x \u2260 y) :\n    \u2203 f : E \u2192L[\u211d] \u211d, f x < f y", "start": [195, 1], "end": [201, 46], "kind": "commanddeclaration"}, {"full_name": "iInter_halfspaces_eq", "code": "theorem iInter_halfspaces_eq (hs\u2081 : Convex \u211d s) (hs\u2082 : IsClosed s) :\n    \u22c2 l : E \u2192L[\u211d] \u211d, { x | \u2203 y \u2208 s, l x \u2264 l y } = s", "start": [204, 1], "end": [212, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Derangements/Finite.lean", "imports": ["Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Combinatorics/Derangements/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "card_derangements_invariant", "code": "theorem card_derangements_invariant {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] [Fintype \u03b2]\n    [DecidableEq \u03b2] (h : card \u03b1 = card \u03b2) : card (derangements \u03b1) = card (derangements \u03b2)", "start": [41, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "card_derangements_fin_add_two", "code": "theorem card_derangements_fin_add_two (n : \u2115) :\n    card (derangements (Fin (n + 2))) =\n      (n + 1) * card (derangements (Fin n)) + (n + 1) * card (derangements (Fin (n + 1)))", "start": [46, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "numDerangements", "code": "def numDerangements : \u2115 \u2192 \u2115\n  | 0 => 1\n  | 1 => 0\n  | n + 2 => (n + 1) * (numDerangements n + numDerangements (n + 1))", "start": [66, 1], "end": [70, 69], "kind": "commanddeclaration"}, {"full_name": "numDerangements_zero", "code": "@[simp]\ntheorem numDerangements_zero : numDerangements 0 = 1", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "numDerangements_one", "code": "@[simp]\ntheorem numDerangements_one : numDerangements 1 = 0", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "numDerangements_add_two", "code": "theorem numDerangements_add_two (n : \u2115) :\n    numDerangements (n + 2) = (n + 1) * (numDerangements n + numDerangements (n + 1))", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "numDerangements_succ", "code": "theorem numDerangements_succ (n : \u2115) :\n    (numDerangements (n + 1) : \u2124) = (n + 1) * (numDerangements n : \u2124) - (-1) ^ n", "start": [88, 1], "end": [93, 9], "kind": "commanddeclaration"}, {"full_name": "card_derangements_fin_eq_numDerangements", "code": "theorem card_derangements_fin_eq_numDerangements {n : \u2115} :\n    card (derangements (Fin n)) = numDerangements n", "start": [96, 1], "end": [107, 71], "kind": "commanddeclaration"}, {"full_name": "card_derangements_eq_numDerangements", "code": "theorem card_derangements_eq_numDerangements (\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1] :\n    card (derangements \u03b1) = numDerangements (card \u03b1)", "start": [110, 1], "end": [113, 49], "kind": "commanddeclaration"}, {"full_name": "numDerangements_sum", "code": "theorem numDerangements_sum (n : \u2115) :\n    (numDerangements n : \u2124) =\n      \u2211 k in Finset.range (n + 1), (-1 : \u2124) ^ k * Nat.ascFactorial k (n - k)", "start": [116, 1], "end": [127, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Liouville/Residual.lean", "imports": ["Mathlib/NumberTheory/Liouville/Basic.lean", "Mathlib/Topology/Instances/Irrational.lean", "Mathlib/Topology/MetricSpace/Baire.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "setOf_liouville_eq_iInter_iUnion", "code": "theorem setOf_liouville_eq_iInter_iUnion :\n    { x | Liouville x } =\n      \u22c2 n : \u2115, \u22c3 (a : \u2124) (b : \u2124) (_ : 1 < b),\n      ball ((a : \u211d) / b) (1 / (b : \u211d) ^ n) \\ {(a : \u211d) / b}", "start": [24, 1], "end": [30, 57], "kind": "commanddeclaration"}, {"full_name": "isG\u03b4_setOf_liouville", "code": "theorem isG\u03b4_setOf_liouville : IsG\u03b4 { x | Liouville x }", "start": [33, 1], "end": [37, 58], "kind": "commanddeclaration"}, {"full_name": "setOf_liouville_eq_irrational_inter_iInter_iUnion", "code": "theorem setOf_liouville_eq_irrational_inter_iInter_iUnion :\n    { x | Liouville x } =\n      { x | Irrational x } \u2229 \u22c2 n : \u2115, \u22c3 (a : \u2124) (b : \u2124) (hb : 1 < b),\n      ball (a / b) (1 / (b : \u211d) ^ n)", "start": [41, 1], "end": [52, 85], "kind": "commanddeclaration"}, {"full_name": "eventually_residual_liouville", "code": "theorem eventually_residual_liouville : \u2200\u1da0 x in residual \u211d, Liouville x", "start": [55, 1], "end": [69, 60], "kind": "commanddeclaration"}, {"full_name": "dense_liouville", "code": "theorem dense_liouville : Dense { x | Liouville x }", "start": [72, 1], "end": [74, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Liouville/LiouvilleWith.lean", "imports": ["Mathlib/NumberTheory/Liouville/Basic.lean", "Mathlib/Topology/Instances/Irrational.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LiouvilleWith", "code": "def LiouvilleWith (p x : \u211d) : Prop :=\n  \u2203 C, \u2203\u1da0 n : \u2115 in atTop, \u2203 m : \u2124, x \u2260 m / n \u2227 |x - m / n| < C / n ^ p", "start": [43, 1], "end": [50, 71], "kind": "commanddeclaration"}, {"full_name": "liouvilleWith_one", "code": "theorem liouvilleWith_one (x : \u211d) : LiouvilleWith 1 x", "start": [53, 1], "end": [65, 29], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.exists_pos", "code": "theorem exists_pos (h : LiouvilleWith p x) :\n    \u2203 (C : \u211d) (_h\u2080 : 0 < C),\n      \u2203\u1da0 n : \u2115 in atTop, 1 \u2264 n \u2227 \u2203 m : \u2124, x \u2260 m / n \u2227 |x - m / n| < C / n ^ p", "start": [72, 1], "end": [83, 83], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mono", "code": "theorem mono (h : LiouvilleWith p x) (hle : q \u2264 p) : LiouvilleWith q x", "start": [86, 1], "end": [92, 60], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.frequently_lt_rpow_neg", "code": "theorem frequently_lt_rpow_neg (h : LiouvilleWith p x) (hlt : q < p) :\n    \u2203\u1da0 n : \u2115 in atTop, \u2203 m : \u2124, x \u2260 m / n \u2227 |x - m / n| < n ^ (-q)", "start": [95, 1], "end": [108, 50], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_rat", "code": "theorem mul_rat (h : LiouvilleWith p x) (hr : r \u2260 0) : LiouvilleWith p (x * r)", "start": [111, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_rat_iff", "code": "theorem mul_rat_iff (hr : r \u2260 0) : LiouvilleWith p (x * r) \u2194 LiouvilleWith p x", "start": [130, 1], "end": [136, 27], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_mul_iff", "code": "theorem rat_mul_iff (hr : r \u2260 0) : LiouvilleWith p (r * x) \u2194 LiouvilleWith p x", "start": [139, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_mul", "code": "theorem rat_mul (h : LiouvilleWith p x) (hr : r \u2260 0) : LiouvilleWith p (r * x)", "start": [145, 1], "end": [146, 23], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_int_iff", "code": "theorem mul_int_iff (hm : m \u2260 0) : LiouvilleWith p (x * m) \u2194 LiouvilleWith p x", "start": [149, 1], "end": [150, 63], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_int", "code": "theorem mul_int (h : LiouvilleWith p x) (hm : m \u2260 0) : LiouvilleWith p (x * m)", "start": [153, 1], "end": [154, 23], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_mul_iff", "code": "theorem int_mul_iff (hm : m \u2260 0) : LiouvilleWith p (m * x) \u2194 LiouvilleWith p x", "start": [157, 1], "end": [158, 32], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_mul", "code": "theorem int_mul (h : LiouvilleWith p x) (hm : m \u2260 0) : LiouvilleWith p (m * x)", "start": [161, 1], "end": [162, 23], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_nat_iff", "code": "theorem mul_nat_iff (hn : n \u2260 0) : LiouvilleWith p (x * n) \u2194 LiouvilleWith p x", "start": [165, 1], "end": [166, 63], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.mul_nat", "code": "theorem mul_nat (h : LiouvilleWith p x) (hn : n \u2260 0) : LiouvilleWith p (x * n)", "start": [169, 1], "end": [170, 23], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_mul_iff", "code": "theorem nat_mul_iff (hn : n \u2260 0) : LiouvilleWith p (n * x) \u2194 LiouvilleWith p x", "start": [173, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_mul", "code": "theorem nat_mul (h : LiouvilleWith p x) (hn : n \u2260 0) : LiouvilleWith p (n * x)", "start": [177, 1], "end": [178, 36], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_rat", "code": "theorem add_rat (h : LiouvilleWith p x) (r : \u211a) : LiouvilleWith p (x + r)", "start": [181, 1], "end": [195, 59], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_rat_iff", "code": "@[simp]\ntheorem add_rat_iff : LiouvilleWith p (x + r) \u2194 LiouvilleWith p x", "start": [198, 1], "end": [200, 65], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_add_iff", "code": "@[simp]\ntheorem rat_add_iff : LiouvilleWith p (r + x) \u2194 LiouvilleWith p x", "start": [203, 1], "end": [204, 99], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_add", "code": "theorem rat_add (h : LiouvilleWith p x) (r : \u211a) : LiouvilleWith p (r + x)", "start": [207, 1], "end": [208, 29], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_int_iff", "code": "@[simp]\ntheorem add_int_iff : LiouvilleWith p (x + m) \u2194 LiouvilleWith p x", "start": [211, 1], "end": [213, 41], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_add_iff", "code": "@[simp]\ntheorem int_add_iff : LiouvilleWith p (m + x) \u2194 LiouvilleWith p x", "start": [216, 1], "end": [217, 99], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_nat_iff", "code": "@[simp]\ntheorem add_nat_iff : LiouvilleWith p (x + n) \u2194 LiouvilleWith p x", "start": [220, 1], "end": [222, 41], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_add_iff", "code": "@[simp]\ntheorem nat_add_iff : LiouvilleWith p (n + x) \u2194 LiouvilleWith p x", "start": [225, 1], "end": [226, 99], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_int", "code": "theorem add_int (h : LiouvilleWith p x) (m : \u2124) : LiouvilleWith p (x + m)", "start": [229, 1], "end": [230, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_add", "code": "theorem int_add (h : LiouvilleWith p x) (m : \u2124) : LiouvilleWith p (m + x)", "start": [233, 1], "end": [234, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.add_nat", "code": "theorem add_nat (h : LiouvilleWith p x) (n : \u2115) : LiouvilleWith p (x + n)", "start": [237, 1], "end": [238, 14], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_add", "code": "theorem nat_add (h : LiouvilleWith p x) (n : \u2115) : LiouvilleWith p (n + x)", "start": [241, 1], "end": [242, 14], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.neg", "code": "protected theorem neg (h : LiouvilleWith p x) : LiouvilleWith p (-x)", "start": [245, 1], "end": [252, 30], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.neg_iff", "code": "@[simp]\ntheorem neg_iff : LiouvilleWith p (-x) \u2194 LiouvilleWith p x", "start": [255, 1], "end": [257, 50], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_rat_iff", "code": "@[simp]\ntheorem sub_rat_iff : LiouvilleWith p (x - r) \u2194 LiouvilleWith p x", "start": [260, 1], "end": [262, 51], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_rat", "code": "theorem sub_rat (h : LiouvilleWith p x) (r : \u211a) : LiouvilleWith p (x - r)", "start": [265, 1], "end": [266, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_int_iff", "code": "@[simp]\ntheorem sub_int_iff : LiouvilleWith p (x - m) \u2194 LiouvilleWith p x", "start": [269, 1], "end": [271, 39], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_int", "code": "theorem sub_int (h : LiouvilleWith p x) (m : \u2124) : LiouvilleWith p (x - m)", "start": [274, 1], "end": [275, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_nat_iff", "code": "@[simp]\ntheorem sub_nat_iff : LiouvilleWith p (x - n) \u2194 LiouvilleWith p x", "start": [278, 1], "end": [280, 39], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.sub_nat", "code": "theorem sub_nat (h : LiouvilleWith p x) (n : \u2115) : LiouvilleWith p (x - n)", "start": [283, 1], "end": [284, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_sub_iff", "code": "@[simp]\ntheorem rat_sub_iff : LiouvilleWith p (r - x) \u2194 LiouvilleWith p x", "start": [287, 1], "end": [288, 94], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.rat_sub", "code": "theorem rat_sub (h : LiouvilleWith p x) (r : \u211a) : LiouvilleWith p (r - x)", "start": [291, 1], "end": [292, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_sub_iff", "code": "@[simp]\ntheorem int_sub_iff : LiouvilleWith p (m - x) \u2194 LiouvilleWith p x", "start": [295, 1], "end": [296, 94], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.int_sub", "code": "theorem int_sub (h : LiouvilleWith p x) (m : \u2124) : LiouvilleWith p (m - x)", "start": [299, 1], "end": [300, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_sub_iff", "code": "@[simp]\ntheorem nat_sub_iff : LiouvilleWith p (n - x) \u2194 LiouvilleWith p x", "start": [303, 1], "end": [304, 94], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.nat_sub", "code": "theorem nat_sub (h : LiouvilleWith p x) (n : \u2115) : LiouvilleWith p (n - x)", "start": [307, 1], "end": [308, 18], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.ne_cast_int", "code": "theorem ne_cast_int (h : LiouvilleWith p x) (hp : 1 < p) (m : \u2124) : x \u2260 m", "start": [311, 1], "end": [321, 21], "kind": "commanddeclaration"}, {"full_name": "LiouvilleWith.irrational", "code": "protected theorem irrational (h : LiouvilleWith p x) (hp : 1 < p) : Irrational x", "start": [324, 1], "end": [331, 56], "kind": "commanddeclaration"}, {"full_name": "Liouville.frequently_exists_num", "code": "theorem frequently_exists_num (hx : Liouville x) (n : \u2115) :\n    \u2203\u1da0 b : \u2115 in atTop, \u2203 a : \u2124, x \u2260 a / b \u2227 |x - a / b| < 1 / (b : \u211d) ^ n", "start": [342, 1], "end": [368, 35], "kind": "commanddeclaration"}, {"full_name": "Liouville.liouvilleWith", "code": "protected theorem liouvilleWith (hx : Liouville x) (p : \u211d) : LiouvilleWith p x", "start": [371, 1], "end": [377, 22], "kind": "commanddeclaration"}, {"full_name": "forall_liouvilleWith_iff", "code": "theorem forall_liouvilleWith_iff {x : \u211d} : (\u2200 p, LiouvilleWith p x) \u2194 Liouville x", "start": [382, 1], "end": [389, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct/Opposite.lean", "imports": ["Mathlib/RingTheory/TensorProduct.lean", "Mathlib/Algebra/Algebra/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.TensorProduct.opAlgEquiv", "code": "def opAlgEquiv : A\u1d50\u1d52\u1d56 \u2297[R] B\u1d50\u1d52\u1d56 \u2243\u2090[S] (A \u2297[R] B)\u1d50\u1d52\u1d56 :=\n  letI e\u2081 : A\u1d50\u1d52\u1d56 \u2297[R] B\u1d50\u1d52\u1d56 \u2243\u2097[S] (A \u2297[R] B)\u1d50\u1d52\u1d56 :=\n    TensorProduct.AlgebraTensorModule.congr\n      (opLinearEquiv S).symm (opLinearEquiv R).symm \u226a\u226b\u2097 opLinearEquiv S\n  letI e\u2082 : A \u2297[R] B \u2243\u2097[S] (A\u1d50\u1d52\u1d56 \u2297[R] B\u1d50\u1d52\u1d56)\u1d50\u1d52\u1d56 :=\n    TensorProduct.AlgebraTensorModule.congr (opLinearEquiv S) (opLinearEquiv R) \u226a\u226b\u2097 opLinearEquiv S\n  AlgEquiv.ofAlgHom\n    (algHomOfLinearMapTensorProduct e\u2081.toLinearMap\n      (fun a\u2081 a\u2082 b\u2081 b\u2082 => unop_injective rfl) (unop_injective rfl))\n    (AlgHom.opComm <| algHomOfLinearMapTensorProduct e\u2082.toLinearMap\n      (fun a\u2081 a\u2082 b\u2081 b\u2082 => unop_injective rfl) (unop_injective rfl))\n    (AlgHom.op.symm.injective <| by ext <;> rfl) (by ext <;> rfl)", "start": [30, 1], "end": [43, 66], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.opAlgEquiv_apply", "code": "theorem opAlgEquiv_apply (x : A\u1d50\u1d52\u1d56 \u2297[R] B\u1d50\u1d52\u1d56) :\n    opAlgEquiv R S A B x =\n      op (_root_.TensorProduct.map\n        (opLinearEquiv R).symm.toLinearMap (opLinearEquiv R).symm.toLinearMap x)", "start": [45, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.opAlgEquiv_symm_apply", "code": "theorem opAlgEquiv_symm_apply (x : (A \u2297[R] B)\u1d50\u1d52\u1d56) :\n    (opAlgEquiv R S A B).symm x =\n      _root_.TensorProduct.map (opLinearEquiv R).toLinearMap (opLinearEquiv R).toLinearMap x.unop", "start": [51, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.opAlgEquiv_tmul", "code": "@[simp]\ntheorem opAlgEquiv_tmul (a : A\u1d50\u1d52\u1d56) (b : B\u1d50\u1d52\u1d56) :\n    opAlgEquiv R S A B (a \u2297\u209c[R] b) = op (a.unop \u2297\u209c b.unop)", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.TensorProduct.opAlgEquiv_symm_tmul", "code": "@[simp]\ntheorem opAlgEquiv_symm_tmul (a : A) (b : B) :\n    (opAlgEquiv R S A B).symm (op <| a \u2297\u209c[R] b) = op a \u2297\u209c op b", "start": [61, 1], "end": [64, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/LocalRing.lean", "imports": ["Mathlib/Data/Nat/Factorization/Basic.lean", "Mathlib/Algebra/CharP/Basic.lean", "Mathlib/RingTheory/Ideal/LocalRing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/IsPrimePow.lean"], "premises": [{"full_name": "charP_zero_or_prime_power", "code": "theorem charP_zero_or_prime_power (R : Type*) [CommRing R] [LocalRing R] (q : \u2115)\n    [char_R_q : CharP R q] : q = 0 \u2228 IsPrimePow q", "start": [24, 1], "end": [67, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Estimator.lean", "imports": ["Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Lean/Thunk.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Order/RelClasses.lean"], "premises": [{"full_name": "EstimatorData", "code": "class EstimatorData (a : Thunk \u03b1) (\u03b5 : Type*) where\n  \n  bound : \u03b5 \u2192 \u03b1\n  \n  improve : \u03b5 \u2192 Option \u03b5", "start": [36, 1], "end": [47, 25], "kind": "commanddeclaration"}, {"full_name": "Estimator", "code": "class Estimator [Preorder \u03b1] (a : Thunk \u03b1) (\u03b5 : Type*) extends EstimatorData a \u03b5 where\n  \n  bound_le e : bound e \u2264 a.get\n  \n  improve_spec e : match improve e with\n    | none => bound e = a.get\n    | some e' => bound e < bound e'", "start": [49, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "Estimator.improveUntilAux", "code": "def Estimator.improveUntilAux [PartialOrder \u03b1]\n    (a : Thunk \u03b1) (p : \u03b1 \u2192 Bool) [Estimator a \u03b5]\n    [WellFoundedGT (range (bound a : \u03b5 \u2192 \u03b1))]\n    (e : \u03b5) (r : Bool) : Except (Option \u03b5) \u03b5 :=\n    if p (bound a e) then\n      return e\n    else\n      match improve a e, improve_spec e with\n      | none, _ => .error <| if r then none else e\n      | some e', _ =>\n        improveUntilAux a p e' true\ntermination_by Estimator.improveUntilAux p I e r => (\u27e8_, mem_range_self e\u27e9 : range (bound a))", "start": [76, 1], "end": [88, 94], "kind": "commanddeclaration"}, {"full_name": "Estimator.improveUntil", "code": "def Estimator.improveUntil [PartialOrder \u03b1] (a : Thunk \u03b1) (p : \u03b1 \u2192 Bool)\n    [Estimator a \u03b5] [WellFoundedGT (range (bound a : \u03b5 \u2192 \u03b1))] (e : \u03b5) :\n    Except (Option \u03b5) \u03b5 :=\n  Estimator.improveUntilAux a p e false", "start": [90, 1], "end": [97, 40], "kind": "commanddeclaration"}, {"full_name": "Estimator.improveUntilAux_spec", "code": "theorem Estimator.improveUntilAux_spec (a : Thunk \u03b1) (p : \u03b1 \u2192 Bool)\n    [Estimator a \u03b5] [WellFoundedGT (range (bound a : \u03b5 \u2192 \u03b1))] (e : \u03b5) (r : Bool) :\n    match Estimator.improveUntilAux a p e r with\n    | .error _ => \u00ac p a.get\n    | .ok e' => p (bound a e')", "start": [102, 1], "end": [122, 99], "kind": "commanddeclaration"}, {"full_name": "Estimator.improveUntil_spec", "code": "theorem Estimator.improveUntil_spec\n    (a : Thunk \u03b1) (p : \u03b1 \u2192 Bool) [Estimator a \u03b5] [WellFoundedGT (range (bound a : \u03b5 \u2192 \u03b1))] (e : \u03b5) :\n    match Estimator.improveUntil a p e with\n    | .error _ => \u00ac p a.get\n    | .ok e' => p (bound a e')", "start": [124, 1], "end": [133, 45], "kind": "commanddeclaration"}, {"full_name": "Estimator.fst", "code": "structure Estimator.fst [Preorder \u03b1] [Preorder \u03b2]\n    (p : Thunk (\u03b1 \u00d7 \u03b2)) (\u03b5 : Type*) [Estimator p \u03b5] where\n  \n  inner : \u03b5", "start": [142, 1], "end": [151, 12], "kind": "commanddeclaration"}, {"full_name": "Estimator.fstInst", "code": "def Estimator.fstInst [PartialOrder \u03b1] [DecidableRel ((\u00b7 : \u03b1) < \u00b7)] [PartialOrder \u03b2]\n    [\u2200 (p : \u03b1 \u00d7 \u03b2), WellFoundedGT { q // q \u2264 p }]\n    (a : Thunk \u03b1) (b : Thunk \u03b2) {\u03b5 : Type*} (i : Estimator (a.prod b) \u03b5) :\n    Estimator a (Estimator.fst (a.prod b) \u03b5) where\n  bound_le e := (Estimator.bound_le e.inner : bound (a.prod b) e.inner \u2264 (a.get, b.get)).1\n  improve_spec e := by\n    let bd := (bound (a.prod b) e.inner).1\n    have := Estimator.improveUntil_spec (a.prod b) (fun p => bd < p.1) e.inner\n    revert this\n    simp only [EstimatorData.improve, decide_eq_true_eq]\n    match Estimator.improveUntil (a.prod b) _ _ with\n    | .error _ =>\n      simp only [Option.map_none']\n      exact fun w =>\n        eq_of_le_of_not_lt\n          (Estimator.bound_le e.inner : bound (a.prod b) e.inner \u2264 (a.get, b.get)).1 w\n    | .ok e' => exact fun w => w", "start": [162, 1], "end": [181, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/EditDistance/Bounds.lean", "imports": ["Mathlib/Data/List/MinMax.lean", "Mathlib/Data/List/Infix.lean", "Mathlib/Data/List/EditDistance/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "suffixLevenshtein_minimum_le_levenshtein_cons", "code": "theorem suffixLevenshtein_minimum_le_levenshtein_cons (xs : List \u03b1) (y ys) :\n    (suffixLevenshtein C xs ys).1.minimum \u2264 levenshtein C xs (y :: ys)", "start": [25, 1], "end": [55, 25], "kind": "commanddeclaration"}, {"full_name": "le_suffixLevenshtein_cons_minimum", "code": "theorem le_suffixLevenshtein_cons_minimum (xs : List \u03b1) (y ys) :\n    (suffixLevenshtein C xs ys).1.minimum \u2264 (suffixLevenshtein C xs (y :: ys)).1.minimum", "start": [57, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "le_suffixLevenshtein_append_minimum", "code": "theorem le_suffixLevenshtein_append_minimum (xs : List \u03b1) (ys\u2081 ys\u2082) :\n    (suffixLevenshtein C xs ys\u2082).1.minimum \u2264 (suffixLevenshtein C xs (ys\u2081 ++ ys\u2082)).1.minimum", "start": [75, 1], "end": [79, 78], "kind": "commanddeclaration"}, {"full_name": "suffixLevenshtein_minimum_le_levenshtein_append", "code": "theorem suffixLevenshtein_minimum_le_levenshtein_append (xs ys\u2081 ys\u2082) :\n    (suffixLevenshtein C xs ys\u2082).1.minimum \u2264 levenshtein C xs (ys\u2081 ++ ys\u2082)", "start": [81, 1], "end": [87, 62], "kind": "commanddeclaration"}, {"full_name": "le_levenshtein_cons", "code": "theorem le_levenshtein_cons (xs : List \u03b1) (y ys) :\n    \u2203 xs', xs' <:+ xs \u2227 levenshtein C xs' ys \u2264 levenshtein C xs (y :: ys)", "start": [89, 1], "end": [92, 67], "kind": "commanddeclaration"}, {"full_name": "le_levenshtein_append", "code": "theorem le_levenshtein_append (xs : List \u03b1) (ys\u2081 ys\u2082) :\n    \u2203 xs', xs' <:+ xs \u2227 levenshtein C xs' ys\u2082 \u2264 levenshtein C xs (ys\u2081 ++ ys\u2082)", "start": [94, 1], "end": [97, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/LinearPMap.lean", "imports": ["Mathlib/Topology/Algebra/Module/Basic.lean", "Mathlib/LinearAlgebra/LinearPMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearPMap.IsClosed", "code": "def IsClosed (f : E \u2192\u2097.[R] F) : Prop :=\n  _root_.IsClosed (f.graph : Set (E \u00d7 F))", "start": [61, 1], "end": [63, 42], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable", "code": "def IsClosable (f : E \u2192\u2097.[R] F) : Prop :=\n  \u2203 f' : LinearPMap R E F, f.graph.topologicalClosure = f'.graph", "start": [70, 1], "end": [72, 65], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosed.isClosable", "code": "theorem IsClosed.isClosable {f : E \u2192\u2097.[R] F} (hf : f.IsClosed) : f.IsClosable", "start": [75, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.leIsClosable", "code": "theorem IsClosable.leIsClosable {f g : E \u2192\u2097.[R] F} (hf : f.IsClosable) (hfg : g \u2264 f) :\n    g.IsClosable", "start": [80, 1], "end": [89, 63], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.existsUnique", "code": "theorem IsClosable.existsUnique {f : E \u2192\u2097.[R] F} (hf : f.IsClosable) :\n    \u2203! f' : E \u2192\u2097.[R] F, f.graph.topologicalClosure = f'.graph", "start": [92, 1], "end": [96, 20], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.closure", "code": "noncomputable def closure (f : E \u2192\u2097.[R] F) : E \u2192\u2097.[R] F :=\n  if hf : f.IsClosable then hf.choose else f", "start": [101, 1], "end": [104, 45], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.closure_def", "code": "theorem closure_def {f : E \u2192\u2097.[R] F} (hf : f.IsClosable) : f.closure = hf.choose", "start": [107, 1], "end": [108, 21], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.closure_def'", "code": "theorem closure_def' {f : E \u2192\u2097.[R] F} (hf : \u00acf.IsClosable) : f.closure = f", "start": [111, 1], "end": [111, 100], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.graph_closure_eq_closure_graph", "code": "theorem IsClosable.graph_closure_eq_closure_graph {f : E \u2192\u2097.[R] F} (hf : f.IsClosable) :\n    f.graph.topologicalClosure = f.closure.graph", "start": [114, 1], "end": [119, 23], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_closure", "code": "theorem le_closure (f : E \u2192\u2097.[R] F) : f \u2264 f.closure", "start": [122, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.closure_mono", "code": "theorem IsClosable.closure_mono {f g : E \u2192\u2097.[R] F} (hg : g.IsClosable) (h : f \u2264 g) :\n    f.closure \u2264 g.closure", "start": [131, 1], "end": [136, 61], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.closure_isClosed", "code": "theorem IsClosable.closure_isClosed {f : E \u2192\u2097.[R] F} (hf : f.IsClosable) : f.closure.IsClosed", "start": [139, 1], "end": [142, 44], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.IsClosable.closureIsClosable", "code": "theorem IsClosable.closureIsClosable {f : E \u2192\u2097.[R] F} (hf : f.IsClosable) : f.closure.IsClosable", "start": [145, 1], "end": [147, 33], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.isClosable_iff_exists_closed_extension", "code": "theorem isClosable_iff_exists_closed_extension {f : E \u2192\u2097.[R] F} :\n    f.IsClosable \u2194 \u2203 (g : E \u2192\u2097.[R] F) (_ : g.IsClosed), f \u2264 g", "start": [150, 1], "end": [153, 34], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.HasCore", "code": "structure HasCore (f : E \u2192\u2097.[R] F) (S : Submodule R E) : Prop where\n  le_domain : S \u2264 f.domain\n  closure_eq : (f.domRestrict S).closure = f", "start": [159, 1], "end": [162, 45], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.hasCore_def", "code": "theorem hasCore_def {f : E \u2192\u2097.[R] F} {S : Submodule R E} (h : f.HasCore S) :\n    (f.domRestrict S).closure = f", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.closureHasCore", "code": "theorem closureHasCore (f : E \u2192\u2097.[R] F) : f.closure.HasCore f.domain", "start": [170, 1], "end": [183, 42], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.closure_inverse_graph", "code": "theorem closure_inverse_graph (hf : LinearMap.ker f.toFun = \u22a5) (hf' : f.IsClosable)\n    (hcf : LinearMap.ker f.closure.toFun = \u22a5) :\n    f.closure.inverse.graph = f.inverse.graph.topologicalClosure", "start": [192, 1], "end": [207, 48], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_isClosable_iff", "code": "theorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = \u22a5) (hf' : f.IsClosable) :\n    f.inverse.IsClosable \u2194 LinearMap.ker f.closure.toFun = \u22a5", "start": [209, 1], "end": [229, 48], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_closure", "code": "theorem inverse_closure (hf : LinearMap.ker f.toFun = \u22a5) (hf' : f.IsClosable)\n    (hcf : LinearMap.ker f.closure.toFun = \u22a5) :\n    f.inverse.closure = f.closure.inverse", "start": [231, 1], "end": [237, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Surreal/Basic.lean", "imports": ["Mathlib/Algebra/Order/Hom/Monoid.lean", "Mathlib/SetTheory/Game/Ordinal.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.Numeric", "code": "def Numeric : PGame \u2192 Prop\n  | \u27e8_, _, L, R\u27e9 => (\u2200 i j, L i < R j) \u2227 (\u2200 i, Numeric (L i)) \u2227 \u2200 j, Numeric (R j)", "start": [65, 1], "end": [68, 83], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_def", "code": "theorem numeric_def {x : PGame} :\n    Numeric x \u2194\n      (\u2200 i j, x.moveLeft i < x.moveRight j) \u2227\n        (\u2200 i, Numeric (x.moveLeft i)) \u2227 \u2200 j, Numeric (x.moveRight j)", "start": [71, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.mk", "code": "theorem mk {x : PGame} (h\u2081 : \u2200 i j, x.moveLeft i < x.moveRight j) (h\u2082 : \u2200 i, Numeric (x.moveLeft i))\n    (h\u2083 : \u2200 j, Numeric (x.moveRight j)) : Numeric x", "start": [80, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.left_lt_right", "code": "theorem left_lt_right {x : PGame} (o : Numeric x) (i : x.LeftMoves) (j : x.RightMoves) :\n    x.moveLeft i < x.moveRight j", "start": [85, 1], "end": [86, 62], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.moveLeft", "code": "theorem moveLeft {x : PGame} (o : Numeric x) (i : x.LeftMoves) : Numeric (x.moveLeft i)", "start": [89, 1], "end": [90, 25], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.moveRight", "code": "theorem moveRight {x : PGame} (o : Numeric x) (j : x.RightMoves) : Numeric (x.moveRight j)", "start": [93, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_rec", "code": "@[elab_as_elim]\ntheorem numeric_rec {C : PGame \u2192 Prop}\n    (H : \u2200 (l r) (L : l \u2192 PGame) (R : r \u2192 PGame), (\u2200 i j, L i < R j) \u2192\n      (\u2200 i, Numeric (L i)) \u2192 (\u2200 i, Numeric (R i)) \u2192 (\u2200 i, C (L i)) \u2192 (\u2200 i, C (R i)) \u2192\n      C \u27e8l, r, L, R\u27e9) :\n    \u2200 x, Numeric x \u2192 C x", "start": [99, 1], "end": [106, 88], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Relabelling.numeric_imp", "code": "theorem Relabelling.numeric_imp {x y : PGame} (r : x \u2261r y) (ox : Numeric x) : Numeric y", "start": [109, 1], "end": [115, 53], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Relabelling.numeric_congr", "code": "theorem Relabelling.numeric_congr {x y : PGame} (r : x \u2261r y) : Numeric x \u2194 Numeric y", "start": [118, 1], "end": [120, 38], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lf_asymm", "code": "theorem lf_asymm {x y : PGame} (ox : Numeric x) (oy : Numeric y) : x \u29cf y \u2192 \u00acy \u29cf x", "start": [123, 1], "end": [131, 67], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.le_of_lf", "code": "theorem le_of_lf {x y : PGame} (h : x \u29cf y) (ox : Numeric x) (oy : Numeric y) : x \u2264 y", "start": [134, 1], "end": [135, 30], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.LF.le", "code": "alias LF.le := le_of_lf", "start": [138, 1], "end": [138, 24], "kind": "stdtacticaliasalias"}, {"full_name": "SetTheory.PGame.lt_of_lf", "code": "theorem lt_of_lf {x y : PGame} (h : x \u29cf y) (ox : Numeric x) (oy : Numeric y) : x < y", "start": [141, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.LF.lt", "code": "alias LF.lt := lt_of_lf", "start": [145, 1], "end": [145, 24], "kind": "stdtacticaliasalias"}, {"full_name": "SetTheory.PGame.lf_iff_lt", "code": "theorem lf_iff_lt {x y : PGame} (ox : Numeric x) (oy : Numeric y) : x \u29cf y \u2194 x < y", "start": [148, 1], "end": [149, 34], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.le_iff_forall_lt", "code": "theorem le_iff_forall_lt {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x \u2264 y \u2194 (\u2200 i, x.moveLeft i < y) \u2227 \u2200 j, x < y.moveRight j", "start": [152, 1], "end": [157, 54], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lt_iff_exists_le", "code": "theorem lt_iff_exists_le {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x < y \u2194 (\u2203 i, x \u2264 y.moveLeft i) \u2228 \u2203 j, x.moveRight j \u2264 y", "start": [160, 1], "end": [163, 43], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lt_of_exists_le", "code": "theorem lt_of_exists_le {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    ((\u2203 i, x \u2264 y.moveLeft i) \u2228 \u2203 j, x.moveRight j \u2264 y) \u2192 x < y", "start": [166, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lt_def", "code": "theorem lt_def {x y : PGame} (ox : x.Numeric) (oy : y.Numeric) :\n    x < y \u2194\n      (\u2203 i, (\u2200 i', x.moveLeft i' < y.moveLeft i) \u2227 \u2200 j, x < (y.moveLeft i).moveRight j) \u2228\n        \u2203 j, (\u2200 i, (x.moveRight j).moveLeft i < y) \u2227 \u2200 j', x.moveRight j < y.moveRight j'", "start": [171, 1], "end": [179, 54], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.not_fuzzy", "code": "theorem not_fuzzy {x y : PGame} (ox : Numeric x) (oy : Numeric y) : \u00acFuzzy x y", "start": [182, 1], "end": [183, 51], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.lt_or_equiv_or_gt", "code": "theorem lt_or_equiv_or_gt {x y : PGame} (ox : Numeric x) (oy : Numeric y) :\n    x < y \u2228 (x \u2248 y) \u2228 y < x", "start": [186, 1], "end": [188, 88], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_of_isEmpty", "code": "theorem numeric_of_isEmpty (x : PGame) [IsEmpty x.LeftMoves] [IsEmpty x.RightMoves] : Numeric x", "start": [191, 1], "end": [192, 49], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_of_isEmpty_leftMoves", "code": "theorem numeric_of_isEmpty_leftMoves (x : PGame) [IsEmpty x.LeftMoves] :\n    (\u2200 j, Numeric (x.moveRight j)) \u2192 Numeric x", "start": [195, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_of_isEmpty_rightMoves", "code": "theorem numeric_of_isEmpty_rightMoves (x : PGame) [IsEmpty x.RightMoves]\n    (H : \u2200 i, Numeric (x.moveLeft i)) : Numeric x", "start": [200, 1], "end": [202, 50], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_zero", "code": "theorem numeric_zero : Numeric 0", "start": [205, 1], "end": [206, 23], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_one", "code": "theorem numeric_one : Numeric 1", "start": [209, 1], "end": [210, 56], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.neg", "code": "theorem Numeric.neg : \u2200 {x : PGame} (_ : Numeric x), Numeric (-x)", "start": [213, 1], "end": [215, 92], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.moveLeft_lt", "code": "theorem moveLeft_lt {x : PGame} (o : Numeric x) (i) : x.moveLeft i < x", "start": [220, 1], "end": [221, 38], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.moveLeft_le", "code": "theorem moveLeft_le {x : PGame} (o : Numeric x) (i) : x.moveLeft i \u2264 x", "start": [224, 1], "end": [225, 23], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.lt_moveRight", "code": "theorem lt_moveRight {x : PGame} (o : Numeric x) (j) : x < x.moveRight j", "start": [228, 1], "end": [229, 40], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.le_moveRight", "code": "theorem le_moveRight {x : PGame} (o : Numeric x) (j) : x \u2264 x.moveRight j", "start": [232, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.add", "code": "theorem add : \u2200 {x y : PGame} (_ : Numeric x) (_ : Numeric y), Numeric (x + y)", "start": [236, 1], "end": [254, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.Numeric.sub", "code": "theorem sub {x y : PGame} (ox : Numeric x) (oy : Numeric y) : Numeric (x - y)", "start": [257, 1], "end": [258, 16], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_nat", "code": "theorem numeric_nat : \u2200 n : \u2115, Numeric n", "start": [263, 1], "end": [266, 45], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.numeric_toPGame", "code": "theorem numeric_toPGame (o : Ordinal) : o.toPGame.Numeric", "start": [269, 1], "end": [273, 67], "kind": "commanddeclaration"}, {"full_name": "Surreal", "code": "def Surreal :=\n  Quotient (inferInstanceAs <| Setoid (Subtype Numeric))", "start": [282, 1], "end": [286, 57], "kind": "commanddeclaration"}, {"full_name": "Surreal.mk", "code": "def mk (x : PGame) (h : x.Numeric) : Surreal :=\n  \u27e6\u27e8x, h\u27e9\u27e7", "start": [291, 1], "end": [293, 11], "kind": "commanddeclaration"}, {"full_name": "Surreal.lift", "code": "def lift {\u03b1} (f : \u2200 x, Numeric x \u2192 \u03b1)\n    (H : \u2200 {x y} (hx : Numeric x) (hy : Numeric y), x.Equiv y \u2192 f x hx = f y hy) : Surreal \u2192 \u03b1 :=\n  Quotient.lift (fun x : { x // Numeric x } => f x.1 x.2) fun x y => H x.2 y.2", "start": [305, 1], "end": [308, 79], "kind": "commanddeclaration"}, {"full_name": "Surreal.lift\u2082", "code": "def lift\u2082 {\u03b1} (f : \u2200 x y, Numeric x \u2192 Numeric y \u2192 \u03b1)\n    (H :\n      \u2200 {x\u2081 y\u2081 x\u2082 y\u2082} (ox\u2081 : Numeric x\u2081) (oy\u2081 : Numeric y\u2081) (ox\u2082 : Numeric x\u2082) (oy\u2082 : Numeric y\u2082),\n        x\u2081.Equiv x\u2082 \u2192 y\u2081.Equiv y\u2082 \u2192 f x\u2081 y\u2081 ox\u2081 oy\u2081 = f x\u2082 y\u2082 ox\u2082 oy\u2082) :\n    Surreal \u2192 Surreal \u2192 \u03b1 :=\n  lift (fun x ox => lift (fun y oy => f x y ox oy) fun _ _ => H _ _ _ _ equiv_rfl)\n    fun _ _ h => funext <| Quotient.ind fun _ => H _ _ _ _ h equiv_rfl", "start": [311, 1], "end": [318, 71], "kind": "commanddeclaration"}, {"full_name": "Surreal.instLE", "code": "instance instLE : LE Surreal :=\n  \u27e8lift\u2082 (fun x y _ _ => x \u2264 y) fun _ _ _ _ hx hy => propext (le_congr hx hy)\u27e9", "start": [321, 1], "end": [322, 79], "kind": "commanddeclaration"}, {"full_name": "Surreal.instLT", "code": "instance instLT : LT Surreal :=\n  \u27e8lift\u2082 (fun x y _ _ => x < y) fun _ _ _ _ hx hy => propext (lt_congr hx hy)\u27e9", "start": [325, 1], "end": [326, 79], "kind": "commanddeclaration"}, {"full_name": "Surreal.orderedAddCommGroup", "code": "instance orderedAddCommGroup : OrderedAddCommGroup Surreal where\n  add := (\u00b7 + \u00b7)\n  add_assoc := by rintro \u27e8_\u27e9 \u27e8_\u27e9 \u27e8_\u27e9; exact Quotient.sound add_assoc_equiv\n  zero := 0\n  zero_add := by rintro \u27e8a\u27e9; exact Quotient.sound (zero_add_equiv a)\n  add_zero := by rintro \u27e8a\u27e9; exact Quotient.sound (add_zero_equiv a)\n  neg := Neg.neg\n  add_left_neg := by rintro \u27e8a\u27e9; exact Quotient.sound (add_left_neg_equiv a)\n  add_comm := by rintro \u27e8_\u27e9 \u27e8_\u27e9; exact Quotient.sound add_comm_equiv\n  le := (\u00b7 \u2264 \u00b7)\n  lt := (\u00b7 < \u00b7)\n  le_refl := by rintro \u27e8_\u27e9; apply @le_rfl PGame\n  le_trans := by rintro \u27e8_\u27e9 \u27e8_\u27e9 \u27e8_\u27e9; apply @le_trans PGame\n  lt_iff_le_not_le := by rintro \u27e8_, ox\u27e9 \u27e8_, oy\u27e9; apply @lt_iff_le_not_le PGame\n  le_antisymm := by rintro \u27e8_\u27e9 \u27e8_\u27e9 h\u2081 h\u2082; exact Quotient.sound \u27e8h\u2081, h\u2082\u27e9\n  add_le_add_left := by rintro \u27e8_\u27e9 \u27e8_\u27e9 hx \u27e8_\u27e9; exact @add_le_add_left PGame _ _ _ _ _ hx _", "start": [340, 1], "end": [355, 91], "kind": "commanddeclaration"}, {"full_name": "Surreal.toGame", "code": "def toGame : Surreal \u2192+o Game where\n  toFun := lift (fun x _ => \u27e6x\u27e7) fun _ _ => Quot.sound\n  map_zero' := rfl\n  map_add' := by rintro \u27e8_, _\u27e9 \u27e8_, _\u27e9; rfl\n  monotone' := by rintro \u27e8_, _\u27e9 \u27e8_, _\u27e9; exact id", "start": [367, 1], "end": [372, 49], "kind": "commanddeclaration"}, {"full_name": "Surreal.zero_toGame", "code": "theorem zero_toGame : toGame 0 = 0", "start": [375, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "Surreal.one_toGame", "code": "@[simp]\ntheorem one_toGame : toGame 1 = 1", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "Surreal.nat_toGame", "code": "@[simp]\ntheorem nat_toGame : \u2200 n : \u2115, toGame n = n", "start": [384, 1], "end": [386, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.toSurreal", "code": "noncomputable def toSurreal : Ordinal \u21aao Surreal where\n  toFun o := mk _ (numeric_toPGame o)\n  inj' a b h := toPGame_equiv_iff.1 (by apply Quotient.exact h) map_rel_iff' := @toPGame_le_iff", "start": [395, 1], "end": [399, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Padics/RingHoms.lean", "imports": ["Mathlib/NumberTheory/Padics/PadicIntegers.lean", "Mathlib/Data/ZMod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PadicInt.modPart", "code": "def modPart : \u2124 :=\n  r.num * gcdA r.den p % p", "start": [57, 1], "end": [66, 27], "kind": "commanddeclaration"}, {"full_name": "PadicInt.modPart_lt_p", "code": "theorem modPart_lt_p : modPart p r < p", "start": [71, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "PadicInt.modPart_nonneg", "code": "theorem modPart_nonneg : 0 \u2264 modPart p r", "start": [77, 1], "end": [78, 60], "kind": "commanddeclaration"}, {"full_name": "PadicInt.isUnit_den", "code": "theorem isUnit_den (r : \u211a) (h : \u2016(r : \u211a_[p])\u2016 \u2264 1) : IsUnit (r.den : \u2124_[p])", "start": [81, 1], "end": [100, 91], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_sub_modPart_aux", "code": "theorem norm_sub_modPart_aux (r : \u211a) (h : \u2016(r : \u211a_[p])\u2016 \u2264 1) :\n    \u2191p \u2223 r.num - r.num * r.den.gcdA p % p * \u2191r.den", "start": [103, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "PadicInt.norm_sub_modPart", "code": "theorem norm_sub_modPart (h : \u2016(r : \u211a_[p])\u2016 \u2264 1) : \u2016(\u27e8r, h\u27e9 - modPart p r : \u2124_[p])\u2016 < 1", "start": [123, 1], "end": [133, 33], "kind": "commanddeclaration"}, {"full_name": "PadicInt.exists_mem_range_of_norm_rat_le_one", "code": "theorem exists_mem_range_of_norm_rat_le_one (h : \u2016(r : \u211a_[p])\u2016 \u2264 1) :\n    \u2203 n : \u2124, 0 \u2264 n \u2227 n < p \u2227 \u2016(\u27e8r, h\u27e9 - n : \u2124_[p])\u2016 < 1", "start": [136, 1], "end": [138, 72], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmod_congr_of_sub_mem_span_aux", "code": "theorem zmod_congr_of_sub_mem_span_aux (n : \u2115) (x : \u2124_[p]) (a b : \u2124)\n    (ha : x - a \u2208 (Ideal.span {(p : \u2124_[p]) ^ n}))\n    (hb : x - b \u2208 (Ideal.span {(p : \u2124_[p]) ^ n})) : (a : ZMod (p ^ n)) = b", "start": [141, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmod_congr_of_sub_mem_span", "code": "theorem zmod_congr_of_sub_mem_span (n : \u2115) (x : \u2124_[p]) (a b : \u2115)\n    (ha : x - a \u2208 (Ideal.span {(p : \u2124_[p]) ^ n}))\n    (hb : x - b \u2208 (Ideal.span {(p : \u2124_[p]) ^ n})) : (a : ZMod (p ^ n)) = b", "start": [152, 1], "end": [155, 59], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmod_congr_of_sub_mem_max_ideal", "code": "theorem zmod_congr_of_sub_mem_max_ideal (x : \u2124_[p]) (m n : \u2115) (hm : x - m \u2208 maximalIdeal \u2124_[p])\n    (hn : x - n \u2208 maximalIdeal \u2124_[p]) : (m : ZMod p) = n", "start": [158, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "PadicInt.exists_mem_range", "code": "theorem exists_mem_range : \u2203 n : \u2115, n < p \u2227 x - n \u2208 maximalIdeal \u2124_[p]", "start": [171, 1], "end": [190, 17], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmodRepr", "code": "def zmodRepr : \u2115 :=\n  Classical.choose (exists_mem_range x)", "start": [193, 1], "end": [197, 40], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmodRepr_spec", "code": "theorem zmodRepr_spec : zmodRepr x < p \u2227 x - zmodRepr x \u2208 maximalIdeal \u2124_[p]", "start": [200, 1], "end": [201, 45], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmodRepr_lt_p", "code": "theorem zmodRepr_lt_p : zmodRepr x < p", "start": [204, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "PadicInt.sub_zmodRepr_mem", "code": "theorem sub_zmodRepr_mem : x - zmodRepr x \u2208 maximalIdeal \u2124_[p]", "start": [208, 1], "end": [209, 22], "kind": "commanddeclaration"}, {"full_name": "PadicInt.toZModHom", "code": "def toZModHom (v : \u2115) (f : \u2124_[p] \u2192 \u2115) (f_spec : \u2200 x, x - f x \u2208 (Ideal.span {\u2191v} : Ideal \u2124_[p]))\n    (f_congr :\n      \u2200 (x : \u2124_[p]) (a b : \u2115),\n        x - a \u2208 (Ideal.span {\u2191v} : Ideal \u2124_[p]) \u2192\n          x - b \u2208 (Ideal.span {\u2191v} : Ideal \u2124_[p]) \u2192 (a : ZMod v) = b) :\n    \u2124_[p] \u2192+* ZMod v where\n  toFun x := f x\n  map_zero' := by\n    dsimp only\n    rw [f_congr (0 : \u2124_[p]) _ 0, cast_zero]\n    \u00b7 exact f_spec _\n    \u00b7 simp only [sub_zero, cast_zero, Submodule.zero_mem]\n  map_one' := by\n    dsimp only\n    rw [f_congr (1 : \u2124_[p]) _ 1, cast_one]\n    \u00b7 exact f_spec _\n    \u00b7 simp only [sub_self, cast_one, Submodule.zero_mem]\n  map_add' := by\n    intro x y\n    dsimp only\n    rw [f_congr (x + y) _ (f x + f y), cast_add]\n    \u00b7 exact f_spec _\n    \u00b7 convert Ideal.add_mem _ (f_spec x) (f_spec y) using 1\n      rw [cast_add]\n      ring\n  map_mul' := by\n    intro x y\n    dsimp only\n    rw [f_congr (x * y) _ (f x * f y), cast_mul]\n    \u00b7 exact f_spec _\n    \u00b7 let I : Ideal \u2124_[p] := Ideal.span {\u2191v}\n      convert I.add_mem (I.mul_mem_left x (f_spec y)) (I.mul_mem_right \u2191(f y) (f_spec x)) using 1\n      rw [cast_mul]\n      ring", "start": [212, 1], "end": [247, 11], "kind": "commanddeclaration"}, {"full_name": "PadicInt.toZMod", "code": "def toZMod : \u2124_[p] \u2192+* ZMod p :=\n  toZModHom p zmodRepr\n    (by\n      rw [\u2190 maximalIdeal_eq_span_p]\n      exact sub_zmodRepr_mem)\n    (by\n      rw [\u2190 maximalIdeal_eq_span_p]\n      exact zmod_congr_of_sub_mem_max_ideal)", "start": [250, 1], "end": [260, 45], "kind": "commanddeclaration"}, {"full_name": "PadicInt.toZMod_spec", "code": "theorem toZMod_spec : x - (toZMod x : \u2124_[p]) \u2208 maximalIdeal \u2124_[p]", "start": [263, 1], "end": [279, 46], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ker_toZMod", "code": "theorem ker_toZMod : RingHom.ker (toZMod : \u2124_[p] \u2192+* ZMod p) = maximalIdeal \u2124_[p]", "start": [282, 1], "end": [293, 27], "kind": "commanddeclaration"}, {"full_name": "PadicInt.appr", "code": "noncomputable def appr : \u2124_[p] \u2192 \u2115 \u2192 \u2115\n  | _x, 0 => 0\n  | x, n + 1 =>\n    let y := x - appr x n\n    if hy : y = 0 then appr x n\n    else\n      let u := (unitCoeff hy : \u2124_[p])\n      appr x n + p ^ n * (toZMod ((u * (p : \u2124_[p]) ^ (y.valuation - n).natAbs) : \u2124_[p])).val", "start": [296, 1], "end": [306, 93], "kind": "commanddeclaration"}, {"full_name": "PadicInt.appr_lt", "code": "theorem appr_lt (x : \u2124_[p]) (n : \u2115) : x.appr n < p ^ n", "start": [309, 1], "end": [325, 48], "kind": "commanddeclaration"}, {"full_name": "PadicInt.appr_mono", "code": "theorem appr_mono (x : \u2124_[p]) : Monotone x.appr", "start": [328, 1], "end": [333, 25], "kind": "commanddeclaration"}, {"full_name": "PadicInt.dvd_appr_sub_appr", "code": "theorem dvd_appr_sub_appr (x : \u2124_[p]) (m n : \u2115) (h : m \u2264 n) : p ^ m \u2223 x.appr n - x.appr m", "start": [336, 1], "end": [347, 45], "kind": "commanddeclaration"}, {"full_name": "PadicInt.appr_spec", "code": "theorem appr_spec (n : \u2115) : \u2200 x : \u2124_[p], x - appr x n \u2208 Ideal.span {(p : \u2124_[p]) ^ n}", "start": [350, 1], "end": [388, 56], "kind": "commanddeclaration"}, {"full_name": "PadicInt.toZModPow", "code": "def toZModPow (n : \u2115) : \u2124_[p] \u2192+* ZMod (p ^ n) :=\n  toZModHom (p ^ n) (fun x => appr x n)\n    (by\n      intros\n      rw [Nat.cast_pow]\n      exact appr_spec n _)\n    (by\n      intro x a b ha hb\n      apply zmod_congr_of_sub_mem_span n x a b\n      \u00b7 simpa using ha\n      \u00b7 simpa using hb)", "start": [391, 1], "end": [402, 24], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ker_toZModPow", "code": "theorem ker_toZModPow (n : \u2115) :\n    RingHom.ker (toZModPow n : \u2124_[p] \u2192+* ZMod (p ^ n)) = Ideal.span {(p : \u2124_[p]) ^ n}", "start": [405, 1], "end": [421, 20], "kind": "commanddeclaration"}, {"full_name": "PadicInt.zmod_cast_comp_toZModPow", "code": "theorem zmod_cast_comp_toZModPow (m n : \u2115) (h : m \u2264 n) :\n    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (@toZModPow p _ n) = @toZModPow p _ m", "start": [425, 1], "end": [440, 72], "kind": "commanddeclaration"}, {"full_name": "PadicInt.cast_toZModPow", "code": "@[simp]\ntheorem cast_toZModPow (m n : \u2115) (h : m \u2264 n) (x : \u2124_[p]) : \u2191(toZModPow n x) = toZModPow m x", "start": [443, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "PadicInt.denseRange_nat_cast", "code": "theorem denseRange_nat_cast : DenseRange (Nat.cast : \u2115 \u2192 \u2124_[p])", "start": [449, 1], "end": [458, 18], "kind": "commanddeclaration"}, {"full_name": "PadicInt.denseRange_int_cast", "code": "theorem denseRange_int_cast : DenseRange (Int.cast : \u2124 \u2192 \u2124_[p])", "start": [461, 1], "end": [467, 31], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHom", "code": "def nthHom (r : R) : \u2115 \u2192 \u2124 := fun n => (f n r : ZMod (p ^ n)).val", "start": [482, 1], "end": [487, 66], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHom_zero", "code": "@[simp]\ntheorem nthHom_zero : nthHom f 0 = 0", "start": [490, 1], "end": [491, 62], "kind": "commanddeclaration"}, {"full_name": "PadicInt.pow_dvd_nthHom_sub", "code": "theorem pow_dvd_nthHom_sub (r : R) (i j : \u2115) (h : i \u2264 j) :\n    (p : \u2124) ^ i \u2223 nthHom f r j - nthHom f r i", "start": [496, 1], "end": [502, 96], "kind": "commanddeclaration"}, {"full_name": "PadicInt.isCauSeq_nthHom", "code": "theorem isCauSeq_nthHom (r : R) : IsCauSeq (padicNorm p) fun n => nthHom f r n", "start": [505, 1], "end": [513, 54], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHomSeq", "code": "def nthHomSeq (r : R) : PadicSeq p :=\n  \u27e8fun n => nthHom f r n, isCauSeq_nthHom f_compat r\u27e9", "start": [516, 1], "end": [521, 54], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHomSeq_one", "code": "theorem nthHomSeq_one : nthHomSeq f_compat 1 \u2248 1", "start": [525, 1], "end": [532, 52], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHomSeq_add", "code": "theorem nthHomSeq_add (r s : R) :\n    nthHomSeq f_compat (r + s) \u2248 nthHomSeq f_compat r + nthHomSeq f_compat s", "start": [535, 1], "end": [548, 86], "kind": "commanddeclaration"}, {"full_name": "PadicInt.nthHomSeq_mul", "code": "theorem nthHomSeq_mul (r s : R) :\n    nthHomSeq f_compat (r * s) \u2248 nthHomSeq f_compat r * nthHomSeq f_compat s", "start": [551, 1], "end": [563, 74], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom", "code": "def limNthHom (r : R) : \u2124_[p] :=\n  ofIntSeq (nthHom f r) (isCauSeq_nthHom f_compat r)", "start": [566, 1], "end": [571, 53], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom_spec", "code": "theorem limNthHom_spec (r : R) :\n    \u2200 \u03b5 : \u211d, 0 < \u03b5 \u2192 \u2203 N : \u2115, \u2200 n \u2265 N, \u2016limNthHom f_compat r - nthHom f r n\u2016 < \u03b5", "start": [574, 1], "end": [585, 16], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom_zero", "code": "theorem limNthHom_zero : limNthHom f_compat 0 = 0", "start": [588, 1], "end": [588, 78], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom_one", "code": "theorem limNthHom_one : limNthHom f_compat 1 = 1", "start": [591, 1], "end": [592, 54], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom_add", "code": "theorem limNthHom_add (r s : R) :\n    limNthHom f_compat (r + s) = limNthHom f_compat r + limNthHom f_compat s", "start": [595, 1], "end": [597, 58], "kind": "commanddeclaration"}, {"full_name": "PadicInt.limNthHom_mul", "code": "theorem limNthHom_mul (r s : R) :\n    limNthHom f_compat (r * s) = limNthHom f_compat r * limNthHom f_compat s", "start": [600, 1], "end": [602, 58], "kind": "commanddeclaration"}, {"full_name": "PadicInt.lift", "code": "def lift : R \u2192+* \u2124_[p] where\n  toFun := limNthHom f_compat\n  map_one' := limNthHom_one f_compat\n  map_mul' := limNthHom_mul f_compat\n  map_zero' := limNthHom_zero f_compat\n  map_add' := limNthHom_add f_compat", "start": [606, 1], "end": [614, 37], "kind": "commanddeclaration"}, {"full_name": "PadicInt.lift_sub_val_mem_span", "code": "theorem lift_sub_val_mem_span (r : R) (n : \u2115) :\n    lift f_compat r - (f n r).val \u2208 (Ideal.span {(p : \u2124_[p]) ^ n})", "start": [617, 1], "end": [631, 22], "kind": "commanddeclaration"}, {"full_name": "PadicInt.lift_spec", "code": "theorem lift_spec (n : \u2115) : (toZModPow n).comp (lift f_compat) = f n", "start": [634, 1], "end": [641, 30], "kind": "commanddeclaration"}, {"full_name": "PadicInt.lift_unique", "code": "theorem lift_unique (g : R \u2192+* \u2124_[p]) (hg : \u2200 n, (toZModPow n).comp g = f n) :\n    lift f_compat = g", "start": [644, 1], "end": [655, 90], "kind": "commanddeclaration"}, {"full_name": "PadicInt.lift_self", "code": "@[simp]\ntheorem lift_self (z : \u2124_[p]) : @lift p _ \u2124_[p] _ toZModPow zmod_cast_comp_toZModPow z = z", "start": [658, 1], "end": [662, 30], "kind": "commanddeclaration"}, {"full_name": "PadicInt.ext_of_toZModPow", "code": "theorem ext_of_toZModPow {x y : \u2124_[p]} : (\u2200 n, toZModPow n x = toZModPow n y) \u2194 x = y", "start": [667, 1], "end": [673, 8], "kind": "commanddeclaration"}, {"full_name": "PadicInt.toZModPow_eq_iff_ext", "code": "theorem toZModPow_eq_iff_ext {R : Type*} [NonAssocSemiring R] {g g' : R \u2192+* \u2124_[p]} :\n    (\u2200 n, (toZModPow n).comp g = (toZModPow n).comp g') \u2194 g = g'", "start": [676, 1], "end": [686, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Distribution/AEEqOfIntegralContDiff.lean", "imports": ["Mathlib/Geometry/Manifold/PartitionOfUnity.lean", "Mathlib/Geometry/Manifold/Metrizable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ae_eq_zero_of_integral_smooth_smul_eq_zero", "code": "theorem ae_eq_zero_of_integral_smooth_smul_eq_zero (hf : LocallyIntegrable f \u03bc)\n    (h : \u2200 (g : M \u2192 \u211d), Smooth I \ud835\udcd8(\u211d) g \u2192 HasCompactSupport g \u2192 \u222b x, g x \u2022 f x \u2202\u03bc = 0) :\n    \u2200\u1d50 x \u2202\u03bc, f x = 0", "start": [38, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "ae_eq_of_integral_smooth_smul_eq", "code": "theorem ae_eq_of_integral_smooth_smul_eq\n    (hf : LocallyIntegrable f \u03bc) (hf' : LocallyIntegrable f' \u03bc) (h : \u2200 (g : M \u2192 \u211d),\n      Smooth I \ud835\udcd8(\u211d) g \u2192 HasCompactSupport g \u2192 \u222b x, g x \u2022 f x \u2202\u03bc = \u222b x, g x \u2022 f' x \u2202\u03bc) :\n    \u2200\u1d50 x \u2202\u03bc, f x = f' x", "start": [113, 1], "end": [128, 31], "kind": "commanddeclaration"}, {"full_name": "ae_eq_zero_of_integral_contDiff_smul_eq_zero", "code": "theorem ae_eq_zero_of_integral_contDiff_smul_eq_zero (hf : LocallyIntegrable f \u03bc)\n    (h : \u2200 (g : E \u2192 \u211d), ContDiff \u211d \u22a4 g \u2192 HasCompactSupport g \u2192 \u222b x, g x \u2022 f x \u2202\u03bc = 0) :\n    \u2200\u1d50 x \u2202\u03bc, f x = 0", "start": [136, 1], "end": [142, 55], "kind": "commanddeclaration"}, {"full_name": "ae_eq_of_integral_contDiff_smul_eq", "code": "theorem ae_eq_of_integral_contDiff_smul_eq\n    (hf : LocallyIntegrable f \u03bc) (hf' : LocallyIntegrable f' \u03bc) (h : \u2200 (g : E \u2192 \u211d),\n      ContDiff \u211d \u22a4 g \u2192 HasCompactSupport g \u2192 \u222b x, g x \u2022 f x \u2202\u03bc = \u222b x, g x \u2022 f' x \u2202\u03bc) :\n    \u2200\u1d50 x \u2202\u03bc, f x = f' x", "start": [144, 1], "end": [152, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Calculus/LineDeriv/Measurable.lean", "imports": ["Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "measurableSet_lineDifferentiableAt", "code": "theorem measurableSet_lineDifferentiableAt (hf : Continuous f) :\n    MeasurableSet {x : E | LineDifferentiableAt \ud835\udd5c f x v}", "start": [34, 1], "end": [39, 85], "kind": "commanddeclaration"}, {"full_name": "measurable_lineDeriv", "code": "theorem measurable_lineDeriv [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f) : Measurable (fun x \u21a6 lineDeriv \ud835\udd5c f x v)", "start": [41, 1], "end": [46, 71], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_lineDeriv", "code": "theorem stronglyMeasurable_lineDeriv [SecondCountableTopologyEither E F] (hf : Continuous f) :\n    StronglyMeasurable (fun x \u21a6 lineDeriv \ud835\udd5c f x v)", "start": [48, 1], "end": [53, 90], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_lineDeriv", "code": "theorem aemeasurable_lineDeriv [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f) (\u03bc : Measure E) :\n    AEMeasurable (fun x \u21a6 lineDeriv \ud835\udd5c f x v) \u03bc", "start": [55, 1], "end": [58, 41], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_lineDeriv", "code": "theorem aestronglyMeasurable_lineDeriv [SecondCountableTopologyEither E F]\n    (hf : Continuous f) (\u03bc : Measure E) :\n    AEStronglyMeasurable (fun x \u21a6 lineDeriv \ud835\udd5c f x v) \u03bc", "start": [60, 1], "end": [63, 57], "kind": "commanddeclaration"}, {"full_name": "measurableSet_lineDifferentiableAt_uncurry", "code": "theorem measurableSet_lineDifferentiableAt_uncurry (hf : Continuous f) :\n    MeasurableSet {p : E \u00d7 E | LineDifferentiableAt \ud835\udd5c f p.1 p.2}", "start": [73, 1], "end": [82, 40], "kind": "commanddeclaration"}, {"full_name": "measurable_lineDeriv_uncurry", "code": "theorem measurable_lineDeriv_uncurry [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f) : Measurable (fun (p : E \u00d7 E) \u21a6 lineDeriv \ud835\udd5c f p.1 p.2)", "start": [84, 1], "end": [91, 73], "kind": "commanddeclaration"}, {"full_name": "stronglyMeasurable_lineDeriv_uncurry", "code": "theorem stronglyMeasurable_lineDeriv_uncurry (hf : Continuous f) :\n    StronglyMeasurable (fun (p : E \u00d7 E) \u21a6 lineDeriv \ud835\udd5c f p.1 p.2)", "start": [93, 1], "end": [100, 92], "kind": "commanddeclaration"}, {"full_name": "aemeasurable_lineDeriv_uncurry", "code": "theorem aemeasurable_lineDeriv_uncurry [MeasurableSpace F] [BorelSpace F]\n    (hf : Continuous f) (\u03bc : Measure (E \u00d7 E)) :\n    AEMeasurable (fun (p : E \u00d7 E) \u21a6 lineDeriv \ud835\udd5c f p.1 p.2) \u03bc", "start": [102, 1], "end": [105, 49], "kind": "commanddeclaration"}, {"full_name": "aestronglyMeasurable_lineDeriv_uncurry", "code": "theorem aestronglyMeasurable_lineDeriv_uncurry (hf : Continuous f) (\u03bc : Measure (E \u00d7 E)) :\n    AEStronglyMeasurable (fun (p : E \u00d7 E) \u21a6 lineDeriv \ud835\udd5c f p.1 p.2) \u03bc", "start": [107, 1], "end": [109, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Measure/Haar/Disintegration.lean", "imports": ["Mathlib/MeasureTheory/Measure/Haar/Basic.lean", "Mathlib/Analysis/NormedSpace/FiniteDimension.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.exists_map_addHaar_eq_smul_addHaar'", "code": "theorem LinearMap.exists_map_addHaar_eq_smul_addHaar' (h : Function.Surjective L) :\n    \u2203 (c : \u211d\u22650\u221e), 0 < c \u2227 c < \u221e \u2227 \u03bc.map L = (c * addHaar (univ : Set (LinearMap.ker L))) \u2022 \u03bd", "start": [39, 1], "end": [96, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_map_addHaar_eq_smul_addHaar", "code": "theorem LinearMap.exists_map_addHaar_eq_smul_addHaar (h : Function.Surjective L) :\n    \u2203 (c : \u211d\u22650\u221e), 0 < c \u2227 \u03bc.map L = c \u2022 \u03bd", "start": [98, 1], "end": [103, 52], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.ae_comp_linearMap_mem_iff", "code": "lemma ae_comp_linearMap_mem_iff (h : Function.Surjective L) {s : Set F} (hs : MeasurableSet s) :\n    (\u2200\u1d50 x \u2202\u03bc, L x \u2208 s) \u2194 \u2200\u1d50 y \u2202\u03bd, y \u2208 s := by\n  have : FiniteDimensional \ud835\udd5c E := finiteDimensional_of_locallyCompactSpace \ud835\udd5c\n  have : AEMeasurable L \u03bc := L.continuous_of_finiteDimensional.aemeasurable\n  apply (ae_map_iff this hs).symm.trans\n  rcases L.exists_map_addHaar_eq_smul_addHaar \u03bc \u03bd h with \u27e8c, c_pos, hc\u27e9\n  rw [hc]\n  exact ae_smul_measure_iff c_pos.ne'", "start": [107, 1], "end": [116, 38], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ae_ae_add_linearMap_mem_iff", "code": "lemma ae_ae_add_linearMap_mem_iff [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s) :\n    (\u2200\u1d50 y \u2202\u03bd, \u2200\u1d50 x \u2202\u03bc, y + L x \u2208 s) \u2194 \u2200\u1d50 y \u2202\u03bd, y \u2208 s := by\n  have : FiniteDimensional \ud835\udd5c E := finiteDimensional_of_locallyCompactSpace \ud835\udd5c\n  have : FiniteDimensional \ud835\udd5c F := finiteDimensional_of_locallyCompactSpace \ud835\udd5c\n  have : ProperSpace E := properSpace_of_locallyCompactSpace \ud835\udd5c\n  have : ProperSpace F := properSpace_of_locallyCompactSpace \ud835\udd5c\n  let M : F \u00d7 E \u2192\u2097[\ud835\udd5c] F := LinearMap.id.coprod L\n  have M_cont : Continuous M := M.continuous_of_finiteDimensional\n  have hM : Function.Surjective M := by simp [\u2190 LinearMap.range_eq_top, LinearMap.range_coprod]\n  have A : \u2200 x, M x \u2208 s \u2194 x \u2208 M \u207b\u00b9' s := fun x \u21a6 Iff.rfl\n  simp_rw [\u2190 ae_comp_linearMap_mem_iff M (\u03bd.prod \u03bc) \u03bd hM hs, A]\n  rw [Measure.ae_prod_mem_iff_ae_ae_mem]\n  simp only [mem_preimage, LinearMap.coprod_apply, LinearMap.id_coe, id_eq]\n  exact M_cont.measurable hs", "start": [118, 1], "end": [134, 29], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.ae_mem_of_ae_add_linearMap_mem", "code": "lemma ae_mem_of_ae_add_linearMap_mem [LocallyCompactSpace F] {s : Set F} (hs : MeasurableSet s)\n    (h : \u2200 y, \u2200\u1d50 x \u2202\u03bc, y + L x \u2208 s) : \u2200\u1d50 y \u2202\u03bd, y \u2208 s :=\n  (ae_ae_add_linearMap_mem_iff L \u03bc \u03bd hs).1 (Filter.eventually_of_forall h)", "start": [136, 1], "end": [141, 75], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Analysis/BoundedVariation.lean", "imports": ["Mathlib/Algebra/Group/Basic.lean", "Mathlib/Tactic/WLOG.lean", "Mathlib/Analysis/Calculus/Deriv/Add.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Function.lean", "Mathlib/Analysis/Calculus/Monotone.lean", "Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "Mathlib/Analysis/Calculus/FDeriv/Equiv.lean"], "premises": [{"full_name": "eVariationOn", "code": "noncomputable def eVariationOn (f : \u03b1 \u2192 E) (s : Set \u03b1) : \u211d\u22650\u221e :=\n  \u2a06 p : \u2115 \u00d7 { u : \u2115 \u2192 \u03b1 // Monotone u \u2227 \u2200 i, u i \u2208 s },\n    \u2211 i in Finset.range p.1, edist (f (p.2.1 (i + 1))) (f (p.2.1 i))", "start": [60, 1], "end": [65, 69], "kind": "commanddeclaration"}, {"full_name": "BoundedVariationOn", "code": "def BoundedVariationOn (f : \u03b1 \u2192 E) (s : Set \u03b1) :=\n  eVariationOn f s \u2260 \u221e", "start": [68, 1], "end": [70, 23], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn", "code": "def LocallyBoundedVariationOn (f : \u03b1 \u2192 E) (s : Set \u03b1) :=\n  \u2200 a b, a \u2208 s \u2192 b \u2208 s \u2192 BoundedVariationOn f (s \u2229 Icc a b)", "start": [73, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.nonempty_monotone_mem", "code": "theorem nonempty_monotone_mem {s : Set \u03b1} (hs : s.Nonempty) :\n    Nonempty { u // Monotone u \u2227 \u2200 i : \u2115, u i \u2208 s }", "start": [83, 1], "end": [86, 57], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.eq_of_edist_zero_on", "code": "theorem eq_of_edist_zero_on {f f' : \u03b1 \u2192 E} {s : Set \u03b1} (h : \u2200 \u2983x\u2984, x \u2208 s \u2192 edist (f x) (f' x) = 0) :\n    eVariationOn f s = eVariationOn f' s", "start": [89, 1], "end": [94, 93], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.eq_of_eqOn", "code": "theorem eq_of_eqOn {f f' : \u03b1 \u2192 E} {s : Set \u03b1} (h : EqOn f f' s) :\n    eVariationOn f s = eVariationOn f' s", "start": [97, 1], "end": [99, 59], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.sum_le", "code": "theorem sum_le (f : \u03b1 \u2192 E) {s : Set \u03b1} (n : \u2115) {u : \u2115 \u2192 \u03b1} (hu : Monotone u) (us : \u2200 i, u i \u2208 s) :\n    (\u2211 i in Finset.range n, edist (f (u (i + 1))) (f (u i))) \u2264 eVariationOn f s", "start": [102, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.sum_le_of_monotoneOn_Icc", "code": "theorem sum_le_of_monotoneOn_Icc (f : \u03b1 \u2192 E) {s : Set \u03b1} {m n : \u2115} {u : \u2115 \u2192 \u03b1}\n    (hu : MonotoneOn u (Icc m n)) (us : \u2200 i \u2208 Icc m n, u i \u2208 s) :\n    (\u2211 i in Finset.Ico m n, edist (f (u (i + 1))) (f (u i))) \u2264 eVariationOn f s", "start": [107, 1], "end": [124, 96], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.sum_le_of_monotoneOn_Iic", "code": "theorem sum_le_of_monotoneOn_Iic (f : \u03b1 \u2192 E) {s : Set \u03b1} {n : \u2115} {u : \u2115 \u2192 \u03b1}\n    (hu : MonotoneOn u (Iic n)) (us : \u2200 i \u2264 n, u i \u2208 s) :\n    (\u2211 i in Finset.range n, edist (f (u (i + 1))) (f (u i))) \u2264 eVariationOn f s", "start": [127, 1], "end": [130, 101], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.mono", "code": "theorem mono (f : \u03b1 \u2192 E) {s t : Set \u03b1} (hst : t \u2286 s) : eVariationOn f t \u2264 eVariationOn f s", "start": [133, 1], "end": [136, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedVariationOn.mono", "code": "theorem _root_.BoundedVariationOn.mono {f : \u03b1 \u2192 E} {s : Set \u03b1} (h : BoundedVariationOn f s)\n    {t : Set \u03b1} (ht : t \u2286 s) : BoundedVariationOn f t", "start": [139, 1], "end": [141, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedVariationOn.locallyBoundedVariationOn", "code": "theorem _root_.BoundedVariationOn.locallyBoundedVariationOn {f : \u03b1 \u2192 E} {s : Set \u03b1}\n    (h : BoundedVariationOn f s) : LocallyBoundedVariationOn f s", "start": [144, 1], "end": [146, 33], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.edist_le", "code": "theorem edist_le (f : \u03b1 \u2192 E) {s : Set \u03b1} {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) :\n    edist (f x) (f y) \u2264 eVariationOn f s", "start": [149, 1], "end": [161, 59], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.eq_zero_iff", "code": "theorem eq_zero_iff (f : \u03b1 \u2192 E) {s : Set \u03b1} :\n    eVariationOn f s = 0 \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) = 0", "start": [164, 1], "end": [174, 65], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.constant_on", "code": "theorem constant_on {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : (f '' s).Subsingleton) :\n    eVariationOn f s = 0", "start": [177, 1], "end": [181, 48], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.subsingleton", "code": "@[simp]\nprotected theorem subsingleton (f : \u03b1 \u2192 E) {s : Set \u03b1} (hs : s.Subsingleton) :\n    eVariationOn f s = 0", "start": [184, 1], "end": [187, 27], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.lowerSemicontinuous_aux", "code": "theorem lowerSemicontinuous_aux {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b1 \u2192 E} {p : Filter \u03b9} {f : \u03b1 \u2192 E} {s : Set \u03b1}\n    (Ffs : \u2200 x \u2208 s, Tendsto (fun i => F i x) p (\ud835\udcdd (f x))) {v : \u211d\u22650\u221e} (hv : v < eVariationOn f s) :\n    \u2200\u1da0 n : \u03b9 in p, v < eVariationOn (F n) s", "start": [190, 1], "end": [201, 97], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.lowerSemicontinuous", "code": "protected theorem lowerSemicontinuous (s : Set \u03b1) :\n    LowerSemicontinuous fun f : \u03b1 \u2192\u1d64[s.image singleton] E => eVariationOn f s", "start": [204, 1], "end": [212, 98], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.lowerSemicontinuous_uniformOn", "code": "theorem lowerSemicontinuous_uniformOn (s : Set \u03b1) :\n    LowerSemicontinuous fun f : \u03b1 \u2192\u1d64[{s}] E => eVariationOn f s", "start": [215, 1], "end": [222, 68], "kind": "commanddeclaration"}, {"full_name": "BoundedVariationOn.dist_le", "code": "theorem _root_.BoundedVariationOn.dist_le {E : Type*} [PseudoMetricSpace E] {f : \u03b1 \u2192 E}\n    {s : Set \u03b1} (h : BoundedVariationOn f s) {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) :\n    dist (f x) (f y) \u2264 (eVariationOn f s).toReal", "start": [225, 1], "end": [229, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedVariationOn.sub_le", "code": "theorem _root_.BoundedVariationOn.sub_le {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (h : BoundedVariationOn f s)\n    {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) : f x - f y \u2264 (eVariationOn f s).toReal", "start": [232, 1], "end": [236, 24], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.add_point", "code": "theorem add_point (f : \u03b1 \u2192 E) {s : Set \u03b1} {x : \u03b1} (hx : x \u2208 s) (u : \u2115 \u2192 \u03b1) (hu : Monotone u)\n    (us : \u2200 i, u i \u2208 s) (n : \u2115) :\n    \u2203 (v : \u2115 \u2192 \u03b1) (m : \u2115), Monotone v \u2227 (\u2200 i, v i \u2208 s) \u2227 x \u2208 v '' Iio m \u2227\n      (\u2211 i in Finset.range n, edist (f (u (i + 1))) (f (u i))) \u2264\n        \u2211 j in Finset.range m, edist (f (v (j + 1))) (f (v j))", "start": [239, 1], "end": [392, 42], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.add_le_union", "code": "theorem add_le_union (f : \u03b1 \u2192 E) {s t : Set \u03b1} (h : \u2200 x \u2208 s, \u2200 y \u2208 t, x \u2264 y) :\n    eVariationOn f s + eVariationOn f t \u2264 eVariationOn f (s \u222a t)", "start": [395, 1], "end": [463, 52], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.union", "code": "theorem union (f : \u03b1 \u2192 E) {s t : Set \u03b1} {x : \u03b1} (hs : IsGreatest s x) (ht : IsLeast t x) :\n    eVariationOn f (s \u222a t) = eVariationOn f s + eVariationOn f t", "start": [466, 1], "end": [505, 19], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.Icc_add_Icc", "code": "theorem Icc_add_Icc (f : \u03b1 \u2192 E) {s : Set \u03b1} {a b c : \u03b1} (hab : a \u2264 b) (hbc : b \u2264 c) (hb : b \u2208 s) :\n    eVariationOn f (s \u2229 Icc a b) + eVariationOn f (s \u2229 Icc b c) = eVariationOn f (s \u2229 Icc a c)", "start": [508, 1], "end": [514, 92], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_le_of_monotoneOn", "code": "theorem comp_le_of_monotoneOn (f : \u03b1 \u2192 E) {s : Set \u03b1} {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : MonotoneOn \u03c6 t)\n    (\u03c6st : MapsTo \u03c6 t s) : eVariationOn (f \u2218 \u03c6) t \u2264 eVariationOn f s", "start": [521, 1], "end": [524, 97], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_le_of_antitoneOn", "code": "theorem comp_le_of_antitoneOn (f : \u03b1 \u2192 E) {s : Set \u03b1} {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : AntitoneOn \u03c6 t)\n    (\u03c6st : MapsTo \u03c6 t s) : eVariationOn (f \u2218 \u03c6) t \u2264 eVariationOn f s", "start": [527, 1], "end": [539, 58], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_eq_of_monotoneOn", "code": "theorem comp_eq_of_monotoneOn (f : \u03b1 \u2192 E) {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : MonotoneOn \u03c6 t) :\n    eVariationOn (f \u2218 \u03c6) t = eVariationOn f (\u03c6 '' t)", "start": [542, 1], "end": [555, 41], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_inter_Icc_eq_of_monotoneOn", "code": "theorem comp_inter_Icc_eq_of_monotoneOn (f : \u03b1 \u2192 E) {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : MonotoneOn \u03c6 t)\n    {x y : \u03b2} (hx : x \u2208 t) (hy : y \u2208 t) :\n    eVariationOn (f \u2218 \u03c6) (t \u2229 Icc x y) = eVariationOn f (\u03c6 '' t \u2229 Icc (\u03c6 x) (\u03c6 y))", "start": [558, 1], "end": [576, 72], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_eq_of_antitoneOn", "code": "theorem comp_eq_of_antitoneOn (f : \u03b1 \u2192 E) {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : AntitoneOn \u03c6 t) :\n    eVariationOn (f \u2218 \u03c6) t = eVariationOn f (\u03c6 '' t)", "start": [579, 1], "end": [592, 41], "kind": "commanddeclaration"}, {"full_name": "eVariationOn.comp_ofDual", "code": "theorem comp_ofDual (f : \u03b1 \u2192 E) (s : Set \u03b1) :\n    eVariationOn (f \u2218 ofDual) (ofDual \u207b\u00b9' s) = eVariationOn f s", "start": [597, 1], "end": [600, 35], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.eVariationOn_le", "code": "theorem MonotoneOn.eVariationOn_le {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (hf : MonotoneOn f s) {a b : \u03b1}\n    (as : a \u2208 s) (bs : b \u2208 s) : eVariationOn f (s \u2229 Icc a b) \u2264 ENNReal.ofReal (f b - f a)", "start": [609, 1], "end": [627, 79], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.locallyBoundedVariationOn", "code": "theorem MonotoneOn.locallyBoundedVariationOn {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (hf : MonotoneOn f s) :\n    LocallyBoundedVariationOn f s", "start": [630, 1], "end": [632, 65], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo", "code": "noncomputable def variationOnFromTo (f : \u03b1 \u2192 E) (s : Set \u03b1) (a b : \u03b1) : \u211d :=\n  if a \u2264 b then (eVariationOn f (s \u2229 Icc a b)).toReal else -(eVariationOn f (s \u2229 Icc b a)).toReal", "start": [635, 1], "end": [639, 98], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.self", "code": "protected theorem self (a : \u03b1) : variationOnFromTo f s a a = 0", "start": [646, 1], "end": [649, 46], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.nonneg_of_le", "code": "protected theorem nonneg_of_le {a b : \u03b1} (h : a \u2264 b) : 0 \u2264 variationOnFromTo f s a b", "start": [652, 1], "end": [653, 65], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_neg_swap", "code": "protected theorem eq_neg_swap (a b : \u03b1) :\n    variationOnFromTo f s a b = -variationOnFromTo f s b a", "start": [656, 1], "end": [661, 75], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.nonpos_of_ge", "code": "protected theorem nonpos_of_ge {a b : \u03b1} (h : b \u2264 a) : variationOnFromTo f s a b \u2264 0", "start": [664, 1], "end": [666, 68], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_of_le", "code": "protected theorem eq_of_le {a b : \u03b1} (h : a \u2264 b) :\n    variationOnFromTo f s a b = (eVariationOn f (s \u2229 Icc a b)).toReal", "start": [669, 1], "end": [671, 11], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_of_ge", "code": "protected theorem eq_of_ge {a b : \u03b1} (h : b \u2264 a) :\n    variationOnFromTo f s a b = -(eVariationOn f (s \u2229 Icc b a)).toReal", "start": [674, 1], "end": [676, 80], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.add", "code": "protected theorem add {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s) {a b c : \u03b1}\n    (ha : a \u2208 s) (hb : b \u2208 s) (hc : c \u2208 s) :\n    variationOnFromTo f s a b + variationOnFromTo f s b c = variationOnFromTo f s a c", "start": [679, 1], "end": [690, 95], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.edist_zero_of_eq_zero", "code": "protected theorem edist_zero_of_eq_zero {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s)\n    {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (h : variationOnFromTo f s a b = 0) :\n    edist (f a) (f b) = 0", "start": [693, 1], "end": [704, 52], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_left_iff", "code": "protected theorem eq_left_iff {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s)\n    {a b c : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (hc : c \u2208 s) :\n    variationOnFromTo f s a b = variationOnFromTo f s a c \u2194 variationOnFromTo f s b c = 0", "start": [707, 1], "end": [710, 69], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_zero_iff_of_le", "code": "protected theorem eq_zero_iff_of_le {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s)\n    {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (ab : a \u2264 b) :\n    variationOnFromTo f s a b = 0 \u2194\n      \u2200 \u2983x\u2984 (_hx : x \u2208 s \u2229 Icc a b) \u2983y\u2984 (_hy : y \u2208 s \u2229 Icc a b), edist (f x) (f y) = 0", "start": [713, 1], "end": [718, 30], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_zero_iff_of_ge", "code": "protected theorem eq_zero_iff_of_ge {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s)\n    {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (ba : b \u2264 a) :\n    variationOnFromTo f s a b = 0 \u2194\n      \u2200 \u2983x\u2984 (_hx : x \u2208 s \u2229 Icc b a) \u2983y\u2984 (_hy : y \u2208 s \u2229 Icc b a), edist (f x) (f y) = 0", "start": [721, 1], "end": [726, 58], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.eq_zero_iff", "code": "protected theorem eq_zero_iff {f : \u03b1 \u2192 E} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s) {a b : \u03b1}\n    (ha : a \u2208 s) (hb : b \u2208 s) :\n    variationOnFromTo f s a b = 0 \u2194\n      \u2200 \u2983x\u2984 (_hx : x \u2208 s \u2229 uIcc a b) \u2983y\u2984 (_hy : y \u2208 s \u2229 uIcc a b), edist (f x) (f y) = 0", "start": [729, 1], "end": [737, 58], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.monotoneOn", "code": "protected theorem monotoneOn (hf : LocallyBoundedVariationOn f s) {a : \u03b1} (as : a \u2208 s) :\n    MonotoneOn (variationOnFromTo f s a) s", "start": [742, 1], "end": [746, 71], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.antitoneOn", "code": "protected theorem antitoneOn (hf : LocallyBoundedVariationOn f s) {b : \u03b1} (bs : b \u2208 s) :\n    AntitoneOn (fun a => variationOnFromTo f s a b) s", "start": [749, 1], "end": [754, 70], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.sub_self_monotoneOn", "code": "protected theorem sub_self_monotoneOn {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (hf : LocallyBoundedVariationOn f s)\n    {a : \u03b1} (as : a \u2208 s) : MonotoneOn (variationOnFromTo f s a - f) s", "start": [757, 1], "end": [770, 64], "kind": "commanddeclaration"}, {"full_name": "variationOnFromTo.comp_eq_of_monotoneOn", "code": "protected theorem comp_eq_of_monotoneOn {\u03b2 : Type*} [LinearOrder \u03b2] (f : \u03b1 \u2192 E) {t : Set \u03b2}\n    (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : MonotoneOn \u03c6 t) {x y : \u03b2} (hx : x \u2208 t) (hy : y \u2208 t) :\n    variationOnFromTo (f \u2218 \u03c6) t x y = variationOnFromTo f (\u03c6 '' t) (\u03c6 x) (\u03c6 y)", "start": [774, 1], "end": [781, 65], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn", "code": "theorem LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn {f : \u03b1 \u2192 \u211d} {s : Set \u03b1}\n    (h : LocallyBoundedVariationOn f s) :\n    \u2203 p q : \u03b1 \u2192 \u211d, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q", "start": [786, 1], "end": [795, 33], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.comp_eVariationOn_le", "code": "theorem LipschitzOnWith.comp_eVariationOn_le {f : E \u2192 F} {C : \u211d\u22650} {t : Set E}\n    (h : LipschitzOnWith C f t) {g : \u03b1 \u2192 E} {s : Set \u03b1} (hg : MapsTo g s t) :\n    eVariationOn (f \u2218 g) s \u2264 C * eVariationOn g s", "start": [804, 1], "end": [814, 83], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.comp_boundedVariationOn", "code": "theorem LipschitzOnWith.comp_boundedVariationOn {f : E \u2192 F} {C : \u211d\u22650} {t : Set E}\n    (hf : LipschitzOnWith C f t) {g : \u03b1 \u2192 E} {s : Set \u03b1} (hg : MapsTo g s t)\n    (h : BoundedVariationOn g s) : BoundedVariationOn (f \u2218 g) s", "start": [817, 1], "end": [820, 93], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.comp_locallyBoundedVariationOn", "code": "theorem LipschitzOnWith.comp_locallyBoundedVariationOn {f : E \u2192 F} {C : \u211d\u22650} {t : Set E}\n    (hf : LipschitzOnWith C f t) {g : \u03b1 \u2192 E} {s : Set \u03b1} (hg : MapsTo g s t)\n    (h : LocallyBoundedVariationOn g s) : LocallyBoundedVariationOn (f \u2218 g) s", "start": [823, 1], "end": [827, 82], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comp_boundedVariationOn", "code": "theorem LipschitzWith.comp_boundedVariationOn {f : E \u2192 F} {C : \u211d\u22650} (hf : LipschitzWith C f)\n    {g : \u03b1 \u2192 E} {s : Set \u03b1} (h : BoundedVariationOn g s) : BoundedVariationOn (f \u2218 g) s", "start": [830, 1], "end": [832, 72], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comp_locallyBoundedVariationOn", "code": "theorem LipschitzWith.comp_locallyBoundedVariationOn {f : E \u2192 F} {C : \u211d\u22650}\n    (hf : LipschitzWith C f) {g : \u03b1 \u2192 E} {s : Set \u03b1} (h : LocallyBoundedVariationOn g s) :\n    LocallyBoundedVariationOn (f \u2218 g) s", "start": [835, 1], "end": [838, 79], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.locallyBoundedVariationOn", "code": "theorem LipschitzOnWith.locallyBoundedVariationOn {f : \u211d \u2192 E} {C : \u211d\u22650} {s : Set \u211d}\n    (hf : LipschitzOnWith C f s) : LocallyBoundedVariationOn f s", "start": [841, 1], "end": [844, 53], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.locallyBoundedVariationOn", "code": "theorem LipschitzWith.locallyBoundedVariationOn {f : \u211d \u2192 E} {C : \u211d\u22650} (hf : LipschitzWith C f)\n    (s : Set \u211d) : LocallyBoundedVariationOn f s", "start": [847, 1], "end": [849, 51], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.ae_differentiableWithinAt_of_mem_real", "code": "theorem ae_differentiableWithinAt_of_mem_real {f : \u211d \u2192 \u211d} {s : Set \u211d}\n    (h : LocallyBoundedVariationOn f s) : \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [860, 1], "end": [869, 30], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.ae_differentiableWithinAt_of_mem_pi", "code": "theorem ae_differentiableWithinAt_of_mem_pi {\u03b9 : Type*} [Fintype \u03b9] {f : \u211d \u2192 \u03b9 \u2192 \u211d} {s : Set \u211d}\n    (h : LocallyBoundedVariationOn f s) : \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [872, 1], "end": [881, 53], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.ae_differentiableWithinAt_of_mem", "code": "theorem ae_differentiableWithinAt_of_mem {f : \u211d \u2192 V} {s : Set \u211d}\n    (h : LocallyBoundedVariationOn f s) : \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [884, 1], "end": [896, 53], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.ae_differentiableWithinAt", "code": "theorem ae_differentiableWithinAt {f : \u211d \u2192 V} {s : Set \u211d} (h : LocallyBoundedVariationOn f s)\n    (hs : MeasurableSet s) : \u2200\u1d50 x \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x", "start": [899, 1], "end": [904, 43], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedVariationOn.ae_differentiableAt", "code": "theorem ae_differentiableAt {f : \u211d \u2192 V} (h : LocallyBoundedVariationOn f univ) :\n    \u2200\u1d50 x, DifferentiableAt \u211d f x", "start": [907, 1], "end": [913, 24], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt_of_mem_real", "code": "theorem LipschitzOnWith.ae_differentiableWithinAt_of_mem_real {C : \u211d\u22650} {f : \u211d \u2192 V} {s : Set \u211d}\n    (h : LipschitzOnWith C f s) : \u2200\u1d50 x, x \u2208 s \u2192 DifferentiableWithinAt \u211d f s x", "start": [918, 1], "end": [924, 63], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.ae_differentiableWithinAt_real", "code": "theorem LipschitzOnWith.ae_differentiableWithinAt_real {C : \u211d\u22650} {f : \u211d \u2192 V} {s : Set \u211d}\n    (h : LipschitzOnWith C f s) (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202volume.restrict s, DifferentiableWithinAt \u211d f s x", "start": [927, 1], "end": [933, 59], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ae_differentiableAt_real", "code": "theorem LipschitzWith.ae_differentiableAt_real {C : \u211d\u22650} {f : \u211d \u2192 V} (h : LipschitzWith C f) :\n    \u2200\u1d50 x, DifferentiableAt \u211d f x", "start": [936, 1], "end": [941, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector/Snoc.lean", "imports": ["Mathlib/Data/Vector/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector.snoc", "code": "def snoc : Vector \u03b1 n \u2192 \u03b1 \u2192 Vector \u03b1 (n+1) :=\n  fun xs x => append xs (x ::\u1d65 Vector.nil)", "start": [23, 1], "end": [25, 43], "kind": "commanddeclaration"}, {"full_name": "Vector.snoc_cons", "code": "@[simp]\ntheorem snoc_cons : (x ::\u1d65 xs).snoc y = x ::\u1d65 (xs.snoc y)", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.snoc_nil", "code": "@[simp]\ntheorem snoc_nil : (nil.snoc x) = x ::\u1d65 nil", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.reverse_cons", "code": "@[simp]\ntheorem reverse_cons : reverse (x ::\u1d65 xs) = (reverse xs).snoc x", "start": [41, 1], "end": [45, 8], "kind": "commanddeclaration"}, {"full_name": "Vector.reverse_snoc", "code": "@[simp]\ntheorem reverse_snoc : reverse (xs.snoc x) = x ::\u1d65 (reverse xs)", "start": [47, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.replicate_succ_to_snoc", "code": "theorem replicate_succ_to_snoc (val : \u03b1) :\n    replicate (n+1) val = (replicate n val).snoc val", "start": [55, 1], "end": [65, 22], "kind": "commanddeclaration"}, {"full_name": "Vector.revInductionOn", "code": "@[elab_as_elim]\ndef revInductionOn {C : \u2200 {n : \u2115}, Vector \u03b1 n \u2192 Sort*} {n : \u2115} (v : Vector \u03b1 n)\n    (nil : C nil)\n    (snoc : \u2200 {n : \u2115} (xs : Vector \u03b1 n) (x : \u03b1), C xs \u2192 C (xs.snoc x)) :\n    C v :=\n  cast (by simp) <| inductionOn\n    (C := fun v => C v.reverse)\n    v.reverse\n    nil\n    (@fun n x xs (r : C xs.reverse) => cast (by simp) <| snoc xs.reverse x r)", "start": [74, 1], "end": [90, 78], "kind": "commanddeclaration"}, {"full_name": "Vector.revInductionOn\u2082", "code": "@[elab_as_elim]\ndef revInductionOn\u2082 {C : \u2200 {n : \u2115}, Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Sort*} {n : \u2115}\n    (v : Vector \u03b1 n) (w : Vector \u03b2 n)\n    (nil : C nil nil)\n    (snoc : \u2200 {n : \u2115} (xs : Vector \u03b1 n) (ys : Vector \u03b2 n) (x : \u03b1) (y : \u03b2),\n      C xs ys \u2192 C (xs.snoc x) (ys.snoc y)) :\n    C v w :=\n  cast (by simp) <| inductionOn\u2082\n    (C := fun v w => C v.reverse w.reverse)\n    v.reverse\n    w.reverse\n    nil\n    (@fun n x y xs ys (r : C xs.reverse ys.reverse) =>\n      cast (by simp) <| snoc xs.reverse ys.reverse x y r)", "start": [92, 1], "end": [107, 58], "kind": "commanddeclaration"}, {"full_name": "Vector.revCasesOn", "code": "@[elab_as_elim]\ndef revCasesOn {C : \u2200 {n : \u2115}, Vector \u03b1 n \u2192 Sort*} {n : \u2115} (v : Vector \u03b1 n)\n    (nil : C nil)\n    (snoc : \u2200 {n : \u2115} (xs : Vector \u03b1 n) (x : \u03b1), C (xs.snoc x)) :\n    C v :=\n  revInductionOn v nil fun xs x _ => snoc xs x", "start": [109, 1], "end": [116, 47], "kind": "commanddeclaration"}, {"full_name": "Vector.map_snoc", "code": "@[simp]\ntheorem map_snoc : map f (xs.snoc x) = (map f xs).snoc (f x)", "start": [128, 1], "end": [130, 53], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_nil", "code": "@[simp]\ntheorem mapAccumr_nil : mapAccumr f Vector.nil s = (s, Vector.nil)", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_snoc", "code": "@[simp]\ntheorem mapAccumr_snoc :\n    mapAccumr f (xs.snoc x) s\n    = let q := f x s\n      let r := mapAccumr f xs q.1\n      (r.1, r.2.snoc q.2)", "start": [136, 1], "end": [144, 12], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_snoc", "code": "@[simp]\ntheorem map\u2082_snoc : map\u2082 f (xs.snoc x) (ys.snoc y) = (map\u2082 f xs ys).snoc (f x y)", "start": [148, 1], "end": [150, 58], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_nil", "code": "@[simp]\ntheorem mapAccumr\u2082_nil : mapAccumr\u2082 f Vector.nil Vector.nil s = (s, Vector.nil)", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_snoc", "code": "@[simp]\ntheorem mapAccumr\u2082_snoc (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03c6) (x : \u03b1) (y : \u03b2) :\n    mapAccumr\u2082 f (xs.snoc x) (ys.snoc y) c\n    = let q := f x y c\n      let r := mapAccumr\u2082 f xs ys q.1\n      (r.1, r.2.snoc q.2)", "start": [156, 1], "end": [162, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/FLT/Basic.lean", "imports": ["Mathlib/Data/Rat/Defs.lean", "Mathlib/Tactic/Positivity.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "FermatLastTheoremWith", "code": "def FermatLastTheoremWith (\u03b1 : Type*) [Semiring \u03b1] (n : \u2115) : Prop :=\n  \u2200 a b c : \u03b1, a \u2260 0 \u2192 b \u2260 0 \u2192 c \u2260 0 \u2192 a ^ n + b ^ n \u2260 c ^ n", "start": [20, 1], "end": [22, 61], "kind": "commanddeclaration"}, {"full_name": "FermatLastTheoremFor", "code": "def FermatLastTheoremFor (n : \u2115) : Prop := FermatLastTheoremWith \u2115 n", "start": [24, 1], "end": [25, 69], "kind": "commanddeclaration"}, {"full_name": "FermatLastTheorem", "code": "def FermatLastTheorem : Prop := \u2200 n \u2265 3, FermatLastTheoremFor n", "start": [27, 1], "end": [29, 64], "kind": "commanddeclaration"}, {"full_name": "fermatLastTheoremFor_zero", "code": "lemma fermatLastTheoremFor_zero : FermatLastTheoremFor 0 :=\n  fun _ _ _ _ _ _ \u21a6 by norm_num", "start": [31, 1], "end": [32, 32], "kind": "mathlibtacticlemma"}, {"full_name": "not_fermatLastTheoremFor_one", "code": "lemma not_fermatLastTheoremFor_one : \u00ac FermatLastTheoremFor 1 :=\n  fun h \u21a6 h 1 1 2 (by norm_num) (by norm_num) (by norm_num) (by norm_num)", "start": [34, 1], "end": [35, 74], "kind": "mathlibtacticlemma"}, {"full_name": "not_fermatLastTheoremFor_two", "code": "lemma not_fermatLastTheoremFor_two : \u00ac FermatLastTheoremFor 2 :=\n  fun h \u21a6 h 3 4 5 (by norm_num) (by norm_num) (by norm_num) (by norm_num)", "start": [37, 1], "end": [38, 74], "kind": "mathlibtacticlemma"}, {"full_name": "FermatLastTheoremWith.mono", "code": "lemma FermatLastTheoremWith.mono (hmn : m \u2223 n) (hm : FermatLastTheoremWith \u03b1 m) :\n    FermatLastTheoremWith \u03b1 n := by\n  rintro a b c ha hb hc\n  obtain \u27e8k, rfl\u27e9 := hmn\n  simp_rw [pow_mul']\n  refine hm _ _ _ ?_ ?_ ?_ <;> exact pow_ne_zero _ \u2039_\u203a", "start": [42, 1], "end": [47, 55], "kind": "mathlibtacticlemma"}, {"full_name": "FermatLastTheoremFor.mono", "code": "lemma FermatLastTheoremFor.mono (hmn : m \u2223 n) (hm : FermatLastTheoremFor m) :\n    FermatLastTheoremFor n := by\n  exact FermatLastTheoremWith.mono hmn hm", "start": [49, 1], "end": [51, 42], "kind": "mathlibtacticlemma"}, {"full_name": "fermatLastTheoremWith_nat_int_rat_tfae", "code": "lemma fermatLastTheoremWith_nat_int_rat_tfae (n : \u2115) :\n    TFAE [FermatLastTheoremWith \u2115 n, FermatLastTheoremWith \u2124 n, FermatLastTheoremWith \u211a n] := by\n  tfae_have 1 \u2192 2\n  \u00b7 rintro h a b c ha hb hc habc\n    obtain hn | hn := n.even_or_odd\n    \u00b7 refine' h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [hn.pow_abs, habc]\n    obtain ha | ha := ha.lt_or_lt <;> obtain hb | hb := hb.lt_or_lt <;>\n      obtain hc | hc := hc.lt_or_lt\n    \u00b7 refine' h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_neg, neg_pow a, neg_pow b, neg_pow c, \u2190mul_add, habc, *]\n    \u00b7 exact (by positivity : 0 < c ^ n).not_lt $ habc.symm.trans_lt $ add_neg (hn.pow_neg ha) $\n        hn.pow_neg hb\n    \u00b7 refine' h b.natAbs c.natAbs a.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, add_neg_eq_iff_eq_add,\n        eq_neg_add_iff_add_eq, *]\n    \u00b7 refine' h a.natAbs c.natAbs b.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, neg_add_eq_iff_eq_add,\n        eq_neg_add_iff_add_eq, *]\n    \u00b7 refine' h c.natAbs a.natAbs b.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, neg_add_eq_iff_eq_add,\n        eq_add_neg_iff_add_eq, *]\n    \u00b7 refine' h c.natAbs b.natAbs a.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_pos, abs_of_neg, hn.neg_pow, habc, add_neg_eq_iff_eq_add,\n        eq_add_neg_iff_add_eq, *]\n    \u00b7 exact (by positivity : 0 < a ^ n + b ^ n).not_lt $ habc.trans_lt $ hn.pow_neg hc\n    \u00b7 refine' h a.natAbs b.natAbs c.natAbs (by positivity) (by positivity) (by positivity)\n        (Int.coe_nat_inj'.1 _)\n      push_cast\n      simp only [abs_of_pos, habc, *]\n  tfae_have 2 \u2192 3\n  \u00b7 rintro h a b c ha hb hc habc\n    rw [\u2190Rat.num_ne_zero] at ha hb hc\n    have : a.den \u2260 0 := a.den_pos.ne'\n    have : b.den \u2260 0 := b.den_pos.ne'\n    have : c.den \u2260 0 := c.den_pos.ne'\n    refine' h (a.num * b.den * c.den) (a.den * b.num * c.den) (a.den * b.den * c.num)\n      (by positivity) (by positivity) (by positivity) _\n    have : (a.den * b.den * c.den : \u211a) ^ n \u2260 0 := by positivity\n    refine' Int.cast_injective $ (div_left_inj' this).1 _\n    push_cast\n    simp only [add_div, \u2190div_pow, mul_div_mul_comm, div_self (by positivity : (a.den : \u211a) \u2260 0),\n      div_self (by positivity : (b.den : \u211a) \u2260 0), div_self (by positivity : (c.den : \u211a) \u2260 0),\n      one_mul, mul_one, Rat.num_div_den, habc]\n  tfae_have 3 \u2192 1\n  \u00b7 rintro h a b c\n    exact_mod_cast h a b c\n  tfae_finish", "start": [53, 1], "end": [112, 14], "kind": "mathlibtacticlemma"}, {"full_name": "fermatLastTheoremFor_iff_nat", "code": "lemma fermatLastTheoremFor_iff_nat {n : \u2115} : FermatLastTheoremFor n \u2194 FermatLastTheoremWith \u2115 n :=\n  Iff.rfl", "start": [114, 1], "end": [115, 10], "kind": "mathlibtacticlemma"}, {"full_name": "fermatLastTheoremFor_iff_int", "code": "lemma fermatLastTheoremFor_iff_int {n : \u2115} : FermatLastTheoremFor n \u2194 FermatLastTheoremWith \u2124 n :=\n  (fermatLastTheoremWith_nat_int_rat_tfae n).out 0 1", "start": [117, 1], "end": [118, 53], "kind": "mathlibtacticlemma"}, {"full_name": "fermatLastTheoremFor_iff_rat", "code": "lemma fermatLastTheoremFor_iff_rat {n : \u2115} : FermatLastTheoremFor n \u2194 FermatLastTheoremWith \u211a n :=\n  (fermatLastTheoremWith_nat_int_rat_tfae n).out 0 2", "start": [120, 1], "end": [121, 53], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/NumberTheory/PythagoreanTriples.lean", "imports": ["Mathlib/Data/Int/NatPrime.lean", "Mathlib/Algebra/Field/Basic.lean", "Mathlib/Data/ZMod/Basic.lean", "Mathlib/Tactic/FieldSimp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Int/Basic.lean", "Mathlib/Tactic/Ring.lean"], "premises": [{"full_name": "sq_ne_two_fin_zmod_four", "code": "theorem sq_ne_two_fin_zmod_four (z : ZMod 4) : z * z \u2260 2", "start": [30, 1], "end": [32, 41], "kind": "commanddeclaration"}, {"full_name": "Int.sq_ne_two_mod_four", "code": "theorem Int.sq_ne_two_mod_four (z : \u2124) : z * z % 4 \u2260 2", "start": [35, 1], "end": [38, 40], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple", "code": "def PythagoreanTriple (x y z : \u2124) : Prop :=\n  x * x + y * y = z * z", "start": [45, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "pythagoreanTriple_comm", "code": "theorem pythagoreanTriple_comm {x y z : \u2124} : PythagoreanTriple x y z \u2194 PythagoreanTriple y x z", "start": [50, 1], "end": [54, 16], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.zero", "code": "theorem PythagoreanTriple.zero : PythagoreanTriple 0 0 0", "start": [57, 1], "end": [59, 52], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.eq", "code": "theorem eq : x * x + y * y = z * z", "start": [66, 1], "end": [67, 4], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.symm", "code": "@[symm]\ntheorem symm : PythagoreanTriple y x z", "start": [70, 1], "end": [71, 74], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.mul", "code": "theorem mul (k : \u2124) : PythagoreanTriple (k * x) (k * y) (k * z)", "start": [74, 1], "end": [80, 35], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.mul_iff", "code": "theorem mul_iff (k : \u2124) (hk : k \u2260 0) :\n    PythagoreanTriple (k * x) (k * y) (k * z) \u2194 PythagoreanTriple x y z", "start": [83, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.IsClassified", "code": "@[nolint unusedArguments]\ndef IsClassified (_ : PythagoreanTriple x y z) :=\n  \u2203 k m n : \u2124,\n    (x = k * (m ^ 2 - n ^ 2) \u2227 y = k * (2 * m * n) \u2228\n        x = k * (2 * m * n) \u2227 y = k * (m ^ 2 - n ^ 2)) \u2227\n      Int.gcd m n = 1", "start": [94, 1], "end": [103, 22], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.IsPrimitiveClassified", "code": "@[nolint unusedArguments]\ndef IsPrimitiveClassified (_ : PythagoreanTriple x y z) :=\n  \u2203 m n : \u2124,\n    (x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n \u2228 x = 2 * m * n \u2227 y = m ^ 2 - n ^ 2) \u2227\n      Int.gcd m n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0)", "start": [106, 1], "end": [115, 72], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.mul_isClassified", "code": "theorem mul_isClassified (k : \u2124) (hc : h.IsClassified) : (h.mul k).IsClassified", "start": [118, 1], "end": [127, 25], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.even_odd_of_coprime", "code": "theorem even_odd_of_coprime (hc : Int.gcd x y = 1) :\n    x % 2 = 0 \u2227 y % 2 = 1 \u2228 x % 2 = 1 \u2227 y % 2 = 0", "start": [130, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.gcd_dvd", "code": "theorem gcd_dvd : (Int.gcd x y : \u2124) \u2223 z", "start": [161, 1], "end": [179, 26], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.normalize", "code": "theorem normalize : PythagoreanTriple (x / Int.gcd x y) (y / Int.gcd x y) (z / Int.gcd x y)", "start": [182, 1], "end": [204, 90], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isClassified_of_isPrimitiveClassified", "code": "theorem isClassified_of_isPrimitiveClassified (hp : h.IsPrimitiveClassified) : h.IsClassified", "start": [207, 1], "end": [212, 16], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isClassified_of_normalize_isPrimitiveClassified", "code": "theorem isClassified_of_normalize_isPrimitiveClassified (hc : h.normalize.IsPrimitiveClassified) :\n    h.IsClassified", "start": [215, 1], "end": [222, 20], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.ne_zero_of_coprime", "code": "theorem ne_zero_of_coprime (hc : Int.gcd x y = 1) : z \u2260 0", "start": [225, 1], "end": [235, 70], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isPrimitiveClassified_of_coprime_of_zero_left", "code": "theorem isPrimitiveClassified_of_coprime_of_zero_left (hc : Int.gcd x y = 1) (hx : x = 0) :\n    h.IsPrimitiveClassified", "start": [238, 1], "end": [249, 13], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.coprime_of_coprime", "code": "theorem coprime_of_coprime (hc : Int.gcd x y = 1) : Int.gcd y z = 1", "start": [252, 1], "end": [260, 52], "kind": "commanddeclaration"}, {"full_name": "circleEquivGen", "code": "def circleEquivGen (hk : \u2200 x : K, 1 + x ^ 2 \u2260 0) :\n    K \u2243 { p : K \u00d7 K // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 } where\n  toFun x :=\n    \u27e8\u27e82 * x / (1 + x ^ 2), (1 - x ^ 2) / (1 + x ^ 2)\u27e9, by\n      field_simp [hk x, div_pow]\n      ring, by\n      simp only [Ne.def, div_eq_iff (hk x), neg_mul, one_mul, neg_add, sub_eq_add_neg, add_left_inj]\n      simpa only [eq_neg_iff_add_eq_zero, one_pow] using hk 1\u27e9\n  invFun p := (p : K \u00d7 K).1 / ((p : K \u00d7 K).2 + 1)\n  left_inv x := by\n    have h2 : (1 + 1 : K) = 2 := by norm_num have h3 : (2 : K) \u2260 0 := by\n      convert hk 1\n      rw [one_pow 2, h2]\n    field_simp [hk x, h2, add_assoc, add_comm, add_sub_cancel'_right, mul_comm]\n  right_inv := fun \u27e8\u27e8x, y\u27e9, hxy, hy\u27e9 => by\n    change x ^ 2 + y ^ 2 = 1 at hxy\n    have h2 : y + 1 \u2260 0 := mt eq_neg_of_add_eq_zero_left hy\n    have h3 : (y + 1) ^ 2 + x ^ 2 = 2 * (y + 1) := by\n      rw [(add_neg_eq_iff_eq_add.mpr hxy.symm).symm]\n      ring\n    have h4 : (2 : K) \u2260 0 := by\n      convert hk 1\n      rw [one_pow 2]\n      ring simp only [Prod.mk.inj_iff, Subtype.mk_eq_mk]\n    constructor\n    \u00b7 field_simp [h3]\n      ring\n    \u00b7 field_simp [h3]\n      rw [\u2190 add_neg_eq_iff_eq_add.mpr hxy.symm]\n      ring", "start": [276, 1], "end": [309, 11], "kind": "commanddeclaration"}, {"full_name": "circleEquivGen_apply", "code": "@[simp]\ntheorem circleEquivGen_apply (hk : \u2200 x : K, 1 + x ^ 2 \u2260 0) (x : K) :\n    (circleEquivGen hk x : K \u00d7 K) = \u27e82 * x / (1 + x ^ 2), (1 - x ^ 2) / (1 + x ^ 2)\u27e9", "start": [312, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "circleEquivGen_symm_apply", "code": "@[simp]\ntheorem circleEquivGen_symm_apply (hk : \u2200 x : K, 1 + x ^ 2 \u2260 0)\n    (v : { p : K \u00d7 K // p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1 }) :\n    (circleEquivGen hk).symm v = (v : K \u00d7 K).1 / ((v : K \u00d7 K).2 + 1)", "start": [318, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_sq_add_of_even_odd", "code": "private theorem coprime_sq_sub_sq_add_of_even_odd {m n : \u2124} (h : Int.gcd m n = 1) (hm : m % 2 = 0)\n    (hn : n % 2 = 1) : Int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1", "start": [327, 1], "end": [350, 72], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_sq_add_of_odd_even", "code": "private theorem coprime_sq_sub_sq_add_of_odd_even {m n : \u2124} (h : Int.gcd m n = 1) (hm : m % 2 = 1)\n    (hn : n % 2 = 0) : Int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1", "start": [352, 1], "end": [356, 70], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_mul_of_even_odd", "code": "private theorem coprime_sq_sub_mul_of_even_odd {m n : \u2124} (h : Int.gcd m n = 1) (hm : m % 2 = 0)\n    (hn : n % 2 = 1) : Int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1", "start": [358, 1], "end": [387, 51], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_mul_of_odd_even", "code": "private theorem coprime_sq_sub_mul_of_odd_even {m n : \u2124} (h : Int.gcd m n = 1) (hm : m % 2 = 1)\n    (hn : n % 2 = 0) : Int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1", "start": [389, 1], "end": [393, 67], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_mul", "code": "private theorem coprime_sq_sub_mul {m n : \u2124} (h : Int.gcd m n = 1)\n    (hmn : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0) :\n    Int.gcd (m ^ 2 - n ^ 2) (2 * m * n) = 1", "start": [395, 1], "end": [400, 60], "kind": "commanddeclaration"}, {"full_name": "coprime_sq_sub_sq_sum_of_odd_odd", "code": "private theorem coprime_sq_sub_sq_sum_of_odd_odd {m n : \u2124} (h : Int.gcd m n = 1) (hm : m % 2 = 1)\n    (hn : n % 2 = 1) :\n    2 \u2223 m ^ 2 + n ^ 2 \u2227\n      2 \u2223 m ^ 2 - n ^ 2 \u2227\n        (m ^ 2 - n ^ 2) / 2 % 2 = 0 \u2227 Int.gcd ((m ^ 2 - n ^ 2) / 2) ((m ^ 2 + n ^ 2) / 2) = 1", "start": [402, 1], "end": [432, 9], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isPrimitiveClassified_aux", "code": "theorem isPrimitiveClassified_aux (hc : x.gcd y = 1) (hzpos : 0 < z) {m n : \u2124}\n    (hm2n2 : 0 < m ^ 2 + n ^ 2) (hv2 : (x : \u211a) / z = 2 * m * n / ((m : \u211a) ^ 2 + (n : \u211a) ^ 2))\n    (hw2 : (y : \u211a) / z = ((m : \u211a) ^ 2 - (n : \u211a) ^ 2) / ((m : \u211a) ^ 2 + (n : \u211a) ^ 2))\n    (H : Int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1) (co : Int.gcd m n = 1)\n    (pp : m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0) : h.IsPrimitiveClassified", "start": [438, 1], "end": [454, 12], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isPrimitiveClassified_of_coprime_of_odd_of_pos", "code": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos (hc : Int.gcd x y = 1) (hyo : y % 2 = 1)\n    (hzpos : 0 < z) : h.IsPrimitiveClassified", "start": [457, 1], "end": [555, 13], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isPrimitiveClassified_of_coprime_of_pos", "code": "theorem isPrimitiveClassified_of_coprime_of_pos (hc : Int.gcd x y = 1) (hzpos : 0 < z) :\n    h.IsPrimitiveClassified", "start": [558, 1], "end": [564, 18], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.isPrimitiveClassified_of_coprime", "code": "theorem isPrimitiveClassified_of_coprime (hc : Int.gcd x y = 1) : h.IsPrimitiveClassified", "start": [567, 1], "end": [573, 33], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.classified", "code": "theorem classified : h.IsClassified", "start": [576, 1], "end": [588, 56], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.coprime_classification", "code": "theorem coprime_classification :\n    PythagoreanTriple x y z \u2227 Int.gcd x y = 1 \u2194\n      \u2203 m n,\n        (x = m ^ 2 - n ^ 2 \u2227 y = 2 * m * n \u2228 x = 2 * m * n \u2227 y = m ^ 2 - n ^ 2) \u2227\n          (z = m ^ 2 + n ^ 2 \u2228 z = -(m ^ 2 + n ^ 2)) \u2227\n            Int.gcd m n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0)", "start": [591, 1], "end": [617, 77], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.coprime_classification'", "code": "theorem coprime_classification' {x y z : \u2124} (h : PythagoreanTriple x y z)\n    (h_coprime : Int.gcd x y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) :\n    \u2203 m n,\n      x = m ^ 2 - n ^ 2 \u2227\n        y = 2 * m * n \u2227\n          z = m ^ 2 + n ^ 2 \u2227\n            Int.gcd m n = 1 \u2227 (m % 2 = 0 \u2227 n % 2 = 1 \u2228 m % 2 = 1 \u2227 n % 2 = 0) \u2227 0 \u2264 m", "start": [620, 1], "end": [670, 31], "kind": "commanddeclaration"}, {"full_name": "PythagoreanTriple.classification", "code": "theorem classification :\n    PythagoreanTriple x y z \u2194\n      \u2203 k m n,\n        (x = k * (m ^ 2 - n ^ 2) \u2227 y = k * (2 * m * n) \u2228\n            x = k * (2 * m * n) \u2227 y = k * (m ^ 2 - n ^ 2)) \u2227\n          (z = k * (m ^ 2 + n ^ 2) \u2228 z = -k * (m ^ 2 + n ^ 2))", "start": [673, 1], "end": [696, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Seq/WSeq.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Data/Seq/Seq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Stream'.WSeq", "code": "def WSeq (\u03b1) :=\n  Seq (Option \u03b1)", "start": [30, 1], "end": [42, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ofSeq", "code": "@[coe]\ndef ofSeq : Seq \u03b1 \u2192 WSeq \u03b1 :=\n  (\u00b7 <$> \u00b7) some", "start": [56, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ofList", "code": "@[coe]\ndef ofList (l : List \u03b1) : WSeq \u03b1 :=\n  ofSeq l", "start": [62, 1], "end": [65, 10], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ofStream", "code": "@[coe]\ndef ofStream (l : Stream' \u03b1) : WSeq \u03b1 :=\n  ofSeq l", "start": [68, 1], "end": [71, 10], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.coeSeq", "code": "instance coeSeq : Coe (Seq \u03b1) (WSeq \u03b1) :=\n  \u27e8ofSeq\u27e9", "start": [74, 1], "end": [75, 10], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.coeList", "code": "instance coeList : Coe (List \u03b1) (WSeq \u03b1) :=\n  \u27e8ofList\u27e9", "start": [78, 1], "end": [79, 11], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.coeStream", "code": "instance coeStream : Coe (Stream' \u03b1) (WSeq \u03b1) :=\n  \u27e8ofStream\u27e9", "start": [82, 1], "end": [83, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.nil", "code": "def nil : WSeq \u03b1 :=\n  Seq.nil", "start": [86, 1], "end": [88, 10], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.inhabited", "code": "instance inhabited : Inhabited (WSeq \u03b1) :=\n  \u27e8nil\u27e9", "start": [91, 1], "end": [92, 8], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.cons", "code": "def cons (a : \u03b1) : WSeq \u03b1 \u2192 WSeq \u03b1 :=\n  Seq.cons (some a)", "start": [95, 1], "end": [97, 20], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.think", "code": "def think : WSeq \u03b1 \u2192 WSeq \u03b1 :=\n  Seq.cons none", "start": [100, 1], "end": [102, 16], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct", "code": "def destruct : WSeq \u03b1 \u2192 Computation (Option (\u03b1 \u00d7 WSeq \u03b1)) :=\n  Computation.corec fun s =>\n    match Seq.destruct s with\n    | none => Sum.inl none\n    | some (none, s') => Sum.inr s'\n    | some (some a, s') => Sum.inl (some (a, s'))", "start": [105, 1], "end": [112, 50], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.recOn", "code": "def recOn {C : WSeq \u03b1 \u2192 Sort v} (s : WSeq \u03b1) (h1 : C nil) (h2 : \u2200 x s, C (cons x s))\n    (h3 : \u2200 s, C (think s)) : C s :=\n  Seq.recOn s h1 fun o => Option.recOn o h3 h2", "start": [115, 1], "end": [118, 47], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Mem", "code": "protected def Mem (a : \u03b1) (s : WSeq \u03b1) :=\n  Seq.Mem (some a) s", "start": [121, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.membership", "code": "instance membership : Membership \u03b1 (WSeq \u03b1) :=\n  \u27e8WSeq.Mem\u27e9", "start": [126, 1], "end": [127, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.not_mem_nil", "code": "theorem not_mem_nil (a : \u03b1) : a \u2209 @nil \u03b1", "start": [130, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head", "code": "def head (s : WSeq \u03b1) : Computation (Option \u03b1) :=\n  Computation.map (Prod.fst <$> \u00b7) (destruct s)", "start": [134, 1], "end": [137, 48], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.flatten", "code": "def flatten : Computation (WSeq \u03b1) \u2192 WSeq \u03b1 :=\n  Seq.corec fun c =>\n    match Computation.destruct c with\n    | Sum.inl s => Seq.omap (return \u00b7) (Seq.destruct s)\n    | Sum.inr c' => some (none, c')", "start": [140, 1], "end": [146, 36], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail", "code": "def tail (s : WSeq \u03b1) : WSeq \u03b1 :=\n  flatten <| (fun o => Option.recOn o nil Prod.snd) <$> destruct s", "start": [149, 1], "end": [153, 67], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.drop", "code": "def drop (s : WSeq \u03b1) : \u2115 \u2192 WSeq \u03b1\n  | 0 => s\n  | n + 1 => tail (drop s n)", "start": [156, 1], "end": [159, 29], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?", "code": "def get? (s : WSeq \u03b1) (n : \u2115) : Computation (Option \u03b1) :=\n  head (drop s n)", "start": [162, 1], "end": [164, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList", "code": "def toList (s : WSeq \u03b1) : Computation (List \u03b1) :=\n  @Computation.corec (List \u03b1) (List \u03b1 \u00d7 WSeq \u03b1)\n    (fun \u27e8l, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s'))\n    ([], s)", "start": [167, 1], "end": [175, 12], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.length", "code": "def length (s : WSeq \u03b1) : Computation \u2115 :=\n  @Computation.corec \u2115 (\u2115 \u00d7 WSeq \u03b1)\n    (fun \u27e8n, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl n\n      | some (none, s') => Sum.inr (n, s')\n      | some (some _, s') => Sum.inr (n + 1, s'))\n    (0, s)", "start": [178, 1], "end": [186, 11], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.IsFinite", "code": "class IsFinite (s : WSeq \u03b1) : Prop where\n  out : (toList s).Terminates", "start": [189, 1], "end": [192, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList_terminates", "code": "instance toList_terminates (s : WSeq \u03b1) [h : IsFinite s] : (toList s).Terminates :=\n  h.out", "start": [195, 1], "end": [196, 8], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get", "code": "def get (s : WSeq \u03b1) [IsFinite s] : List \u03b1 :=\n  (toList s).get", "start": [199, 1], "end": [201, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Productive", "code": "class Productive (s : WSeq \u03b1) : Prop where\n  get?_terminates : \u2200 n, (get? s n).Terminates", "start": [204, 1], "end": [208, 47], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.productive_iff", "code": "theorem productive_iff (s : WSeq \u03b1) : Productive s \u2194 \u2200 n, (get? s n).Terminates", "start": [212, 1], "end": [213, 31], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_terminates", "code": "instance get?_terminates (s : WSeq \u03b1) [h : Productive s] : \u2200 n, (get? s n).Terminates :=\n  h.get?_terminates", "start": [216, 1], "end": [217, 20], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_terminates", "code": "instance head_terminates (s : WSeq \u03b1) [Productive s] : (head s).Terminates :=\n  s.get?_terminates 0", "start": [220, 1], "end": [221, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.updateNth", "code": "def updateNth (s : WSeq \u03b1) (n : \u2115) (a : \u03b1) : WSeq \u03b1 :=\n  @Seq.corec (Option \u03b1) (\u2115 \u00d7 WSeq \u03b1)\n    (fun \u27e8n, s\u27e9 =>\n      match Seq.destruct s, n with\n      | none, _ => none\n      | some (none, s'), n => some (none, n, s')\n      | some (some a', s'), 0 => some (some a', 0, s')\n      | some (some _, s'), 1 => some (some a, 0, s')\n      | some (some a', s'), n + 2 => some (some a', n + 1, s'))\n    (n + 1, s)", "start": [224, 1], "end": [234, 15], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.removeNth", "code": "def removeNth (s : WSeq \u03b1) (n : \u2115) : WSeq \u03b1 :=\n  @Seq.corec (Option \u03b1) (\u2115 \u00d7 WSeq \u03b1)\n    (fun \u27e8n, s\u27e9 =>\n      match Seq.destruct s, n with\n      | none, _ => none\n      | some (none, s'), n => some (none, n, s')\n      | some (some a', s'), 0 => some (some a', 0, s')\n      | some (some _, s'), 1 => some (none, 0, s')\n      | some (some a', s'), n + 2 => some (some a', n + 1, s'))\n    (n + 1, s)", "start": [237, 1], "end": [247, 15], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.filterMap", "code": "def filterMap (f : \u03b1 \u2192 Option \u03b2) : WSeq \u03b1 \u2192 WSeq \u03b2 :=\n  Seq.corec fun s =>\n    match Seq.destruct s with\n    | none => none\n    | some (none, s') => some (none, s')\n    | some (some a, s') => some (f a, s')", "start": [250, 1], "end": [256, 42], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.filter", "code": "def filter (p : \u03b1 \u2192 Prop) [DecidablePred p] : WSeq \u03b1 \u2192 WSeq \u03b1 :=\n  filterMap fun a => if p a then some a else none", "start": [259, 1], "end": [261, 50], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.find", "code": "def find (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : WSeq \u03b1) : Computation (Option \u03b1) :=\n  head <| filter p s", "start": [265, 1], "end": [267, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.zipWith", "code": "def zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s1 : WSeq \u03b1) (s2 : WSeq \u03b2) : WSeq \u03b3 :=\n  @Seq.corec (Option \u03b3) (WSeq \u03b1 \u00d7 WSeq \u03b2)\n    (fun \u27e8s1, s2\u27e9 =>\n      match Seq.destruct s1, Seq.destruct s2 with\n      | some (none, s1'), some (none, s2') => some (none, s1', s2')\n      | some (some _, _), some (none, s2') => some (none, s1, s2')\n      | some (none, s1'), some (some _, _) => some (none, s1', s2)\n      | some (some a1, s1'), some (some a2, s2') => some (some (f a1 a2), s1', s2')\n      | _, _ => none)\n    (s1, s2)", "start": [270, 1], "end": [280, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.zip", "code": "def zip : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 WSeq (\u03b1 \u00d7 \u03b2) :=\n  zipWith Prod.mk", "start": [283, 1], "end": [285, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.findIndexes", "code": "def findIndexes (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : WSeq \u03b1) : WSeq \u2115 :=\n  (zip s (Stream'.nats : WSeq \u2115)).filterMap fun \u27e8a, n\u27e9 => if p a then some n else none", "start": [288, 1], "end": [290, 87], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.findIndex", "code": "def findIndex (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : WSeq \u03b1) : Computation \u2115 :=\n  (fun o => Option.getD o 0) <$> head (findIndexes p s)", "start": [293, 1], "end": [295, 56], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.indexOf", "code": "def indexOf [DecidableEq \u03b1] (a : \u03b1) : WSeq \u03b1 \u2192 Computation \u2115 :=\n  findIndex (Eq a)", "start": [298, 1], "end": [300, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.indexesOf", "code": "def indexesOf [DecidableEq \u03b1] (a : \u03b1) : WSeq \u03b1 \u2192 WSeq \u2115 :=\n  findIndexes (Eq a)", "start": [303, 1], "end": [305, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.union", "code": "def union (s1 s2 : WSeq \u03b1) : WSeq \u03b1 :=\n  @Seq.corec (Option \u03b1) (WSeq \u03b1 \u00d7 WSeq \u03b1)\n    (fun \u27e8s1, s2\u27e9 =>\n      match Seq.destruct s1, Seq.destruct s2 with\n      | none, none => none\n      | some (a1, s1'), none => some (a1, s1', nil)\n      | none, some (a2, s2') => some (a2, nil, s2')\n      | some (none, s1'), some (none, s2') => some (none, s1', s2')\n      | some (some a1, s1'), some (none, s2') => some (some a1, s1', s2')\n      | some (none, s1'), some (some a2, s2') => some (some a2, s1', s2')\n      | some (some a1, s1'), some (some a2, s2') => some (some a1, cons a2 s1', s2'))\n    (s1, s2)", "start": [308, 1], "end": [321, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.isEmpty", "code": "def isEmpty (s : WSeq \u03b1) : Computation Bool :=\n  Computation.map Option.isNone <| head s", "start": [324, 1], "end": [326, 42], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.compute", "code": "def compute (s : WSeq \u03b1) : WSeq \u03b1 :=\n  match Seq.destruct s with\n  | some (none, s') => s'\n  | _ => s", "start": [329, 1], "end": [333, 11], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.take", "code": "def take (s : WSeq \u03b1) (n : \u2115) : WSeq \u03b1 :=\n  @Seq.corec (Option \u03b1) (\u2115 \u00d7 WSeq \u03b1)\n    (fun \u27e8n, s\u27e9 =>\n      match n, Seq.destruct s with\n      | 0, _ => none\n      | _ + 1, none => none\n      | m + 1, some (none, s') => some (none, m + 1, s')\n      | m + 1, some (some a, s') => some (some a, m, s'))\n    (n, s)", "start": [336, 1], "end": [345, 11], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.splitAt", "code": "def splitAt (s : WSeq \u03b1) (n : \u2115) : Computation (List \u03b1 \u00d7 WSeq \u03b1) :=\n  @Computation.corec (List \u03b1 \u00d7 WSeq \u03b1) (\u2115 \u00d7 List \u03b1 \u00d7 WSeq \u03b1)\n    (fun \u27e8n, l, s\u27e9 =>\n      match n, Seq.destruct s with\n      | 0, _ => Sum.inl (l.reverse, s)\n      | _ + 1, none => Sum.inl (l.reverse, s)\n      | _ + 1, some (none, s') => Sum.inr (n, l, s')\n      | m + 1, some (some a, s') => Sum.inr (m, a::l, s'))\n    (n, [], s)", "start": [348, 1], "end": [358, 15], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.any", "code": "def any (s : WSeq \u03b1) (p : \u03b1 \u2192 Bool) : Computation Bool :=\n  Computation.corec\n    (fun s : WSeq \u03b1 =>\n      match Seq.destruct s with\n      | none => Sum.inl false\n      | some (none, s') => Sum.inr s'\n      | some (some a, s') => if p a then Sum.inl true else Sum.inr s')\n    s", "start": [361, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.all", "code": "def all (s : WSeq \u03b1) (p : \u03b1 \u2192 Bool) : Computation Bool :=\n  Computation.corec\n    (fun s : WSeq \u03b1 =>\n      match Seq.destruct s with\n      | none => Sum.inl true\n      | some (none, s') => Sum.inr s'\n      | some (some a, s') => if p a then Sum.inr s' else Sum.inl false)\n    s", "start": [372, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.scanl", "code": "def scanl (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) (s : WSeq \u03b2) : WSeq \u03b1 :=\n  cons a <|\n    @Seq.corec (Option \u03b1) (\u03b1 \u00d7 WSeq \u03b2)\n      (fun \u27e8a, s\u27e9 =>\n        match Seq.destruct s with\n        | none => none\n        | some (none, s') => some (none, a, s')\n        | some (some b, s') =>\n          let a' := f a b\n          some (some a', a', s'))\n      (a, s)", "start": [383, 1], "end": [396, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.inits", "code": "def inits (s : WSeq \u03b1) : WSeq (List \u03b1) :=\n  cons [] <|\n    @Seq.corec (Option (List \u03b1)) (Std.DList \u03b1 \u00d7 WSeq \u03b1)\n      (fun \u27e8l, s\u27e9 =>\n        match Seq.destruct s with\n        | none => none\n        | some (none, s') => some (none, l, s')\n        | some (some a, s') =>\n          let l' := l.push a\n          some (some l'.toList, l', s'))\n      (Std.DList.empty, s)", "start": [399, 1], "end": [410, 27], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.collect", "code": "def collect (s : WSeq \u03b1) (n : \u2115) : List \u03b1 :=\n  (Seq.take n s).filterMap id", "start": [413, 1], "end": [416, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.append", "code": "def append : WSeq \u03b1 \u2192 WSeq \u03b1 \u2192 WSeq \u03b1 :=\n  Seq.append", "start": [419, 1], "end": [422, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : WSeq \u03b1 \u2192 WSeq \u03b2 :=\n  Seq.map (Option.map f)", "start": [425, 1], "end": [427, 25], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join", "code": "def join (S : WSeq (WSeq \u03b1)) : WSeq \u03b1 :=\n  Seq.join\n    ((fun o : Option (WSeq \u03b1) =>\n        match o with\n        | none => Seq1.ret none\n        | some s => (none, s)) <$>\n      S)", "start": [430, 1], "end": [438, 9], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.bind", "code": "def bind (s : WSeq \u03b1) (f : \u03b1 \u2192 WSeq \u03b2) : WSeq \u03b2 :=\n  join (map f s)", "start": [441, 1], "end": [443, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRelO", "code": "@[simp]\ndef LiftRelO (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 Prop) :\n    Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Option (\u03b2 \u00d7 WSeq \u03b2) \u2192 Prop\n  | none, none => True\n  | some (a, s), some (b, t) => R a b \u2227 C s t\n  | _, _ => False", "start": [446, 1], "end": [452, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRelO.imp", "code": "theorem LiftRelO.imp {R S : \u03b1 \u2192 \u03b2 \u2192 Prop} {C D : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 Prop} (H1 : \u2200 a b, R a b \u2192 S a b)\n    (H2 : \u2200 s t, C s t \u2192 D s t) : \u2200 {o p}, LiftRelO R C o p \u2192 LiftRelO S D o p", "start": [455, 1], "end": [460, 41], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRelO.imp_right", "code": "theorem LiftRelO.imp_right (R : \u03b1 \u2192 \u03b2 \u2192 Prop) {C D : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 Prop}\n    (H : \u2200 s t, C s t \u2192 D s t) {o p} : LiftRelO R C o p \u2192 LiftRelO R D o p", "start": [463, 1], "end": [465, 33], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.BisimO", "code": "@[simp]\ndef BisimO (R : WSeq \u03b1 \u2192 WSeq \u03b1 \u2192 Prop) : Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Prop :=\n  LiftRelO (\u00b7 = \u00b7) R", "start": [468, 1], "end": [471, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.BisimO.imp", "code": "theorem BisimO.imp {R S : WSeq \u03b1 \u2192 WSeq \u03b1 \u2192 Prop} (H : \u2200 s t, R s t \u2192 S s t) {o p} :\n    BisimO R o p \u2192 BisimO S o p", "start": [474, 1], "end": [476, 25], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel", "code": "def LiftRel (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (s : WSeq \u03b1) (t : WSeq \u03b2) : Prop :=\n  \u2203 C : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 Prop,\n    C s t \u2227 \u2200 {s t}, C s t \u2192 Computation.LiftRel (LiftRelO R C) (destruct s) (destruct t)", "start": [479, 1], "end": [484, 90], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv", "code": "def Equiv : WSeq \u03b1 \u2192 WSeq \u03b1 \u2192 Prop :=\n  LiftRel (\u00b7 = \u00b7)", "start": [487, 1], "end": [492, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_destruct", "code": "theorem liftRel_destruct {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : WSeq \u03b1} {t : WSeq \u03b2} :\n    LiftRel R s t \u2192 Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t)", "start": [495, 1], "end": [500, 39], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_destruct_iff", "code": "theorem liftRel_destruct_iff {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : WSeq \u03b1} {t : WSeq \u03b2} :\n    LiftRel R s t \u2194 Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t)", "start": [503, 1], "end": [517, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_congr", "code": "theorem destruct_congr {s t : WSeq \u03b1} :\n    s ~\u02b7 t \u2192 Computation.LiftRel (BisimO (\u00b7 ~\u02b7 \u00b7)) (destruct s) (destruct t)", "start": [523, 1], "end": [525, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_congr_iff", "code": "theorem destruct_congr_iff {s t : WSeq \u03b1} :\n    s ~\u02b7 t \u2194 Computation.LiftRel (BisimO (\u00b7 ~\u02b7 \u00b7)) (destruct s) (destruct t)", "start": [528, 1], "end": [530, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.refl", "code": "theorem LiftRel.refl (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Reflexive R) : Reflexive (LiftRel R)", "start": [533, 1], "end": [542, 12], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRelO.swap", "code": "theorem LiftRelO.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (C) :\n    swap (LiftRelO R C) = LiftRelO (swap R) (swap C)", "start": [545, 1], "end": [549, 50], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.swap_lem", "code": "theorem LiftRel.swap_lem {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s1 s2} (h : LiftRel R s1 s2) :\n    LiftRel (swap R) s2 s1", "start": [552, 1], "end": [556, 27], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.swap", "code": "theorem LiftRel.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : swap (LiftRel R) = LiftRel (swap R)", "start": [559, 1], "end": [560, 79], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.symm", "code": "theorem LiftRel.symm (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Symmetric R) : Symmetric (LiftRel R)", "start": [563, 1], "end": [564, 91], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.trans", "code": "theorem LiftRel.trans (R : \u03b1 \u2192 \u03b1 \u2192 Prop) (H : Transitive R) : Transitive (LiftRel R)", "start": [567, 1], "end": [596, 31], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.LiftRel.equiv", "code": "theorem LiftRel.equiv (R : \u03b1 \u2192 \u03b1 \u2192 Prop) : Equivalence R \u2192 Equivalence (LiftRel R)", "start": [599, 1], "end": [600, 101], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv.refl", "code": "@[refl]\ntheorem Equiv.refl : \u2200 s : WSeq \u03b1, s ~\u02b7 s", "start": [603, 1], "end": [605, 31], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv.symm", "code": "@[symm]\ntheorem Equiv.symm : \u2200 {s t : WSeq \u03b1}, s ~\u02b7 t \u2192 t ~\u02b7 s", "start": [608, 1], "end": [610, 39], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv.trans", "code": "@[trans]\ntheorem Equiv.trans : \u2200 {s t u : WSeq \u03b1}, s ~\u02b7 t \u2192 t ~\u02b7 u \u2192 s ~\u02b7 u", "start": [613, 1], "end": [615, 41], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv.equivalence", "code": "theorem Equiv.equivalence : Equivalence (@Equiv \u03b1)", "start": [618, 1], "end": [619, 49], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_nil", "code": "@[simp]\ntheorem destruct_nil : destruct (nil : WSeq \u03b1) = Computation.pure none", "start": [624, 1], "end": [626, 35], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_cons", "code": "@[simp]\ntheorem destruct_cons (a : \u03b1) (s) : destruct (cons a s) = Computation.pure (some (a, s))", "start": [629, 1], "end": [631, 77], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_think", "code": "@[simp]\ntheorem destruct_think (s : WSeq \u03b1) : destruct (think s) = (destruct s).think", "start": [634, 1], "end": [636, 79], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.seq_destruct_nil", "code": "@[simp]\ntheorem seq_destruct_nil : Seq.destruct (nil : WSeq \u03b1) = none", "start": [639, 1], "end": [641, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.seq_destruct_cons", "code": "@[simp]\ntheorem seq_destruct_cons (a : \u03b1) (s) : Seq.destruct (cons a s) = some (some a, s)", "start": [644, 1], "end": [646, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.seq_destruct_think", "code": "@[simp]\ntheorem seq_destruct_think (s : WSeq \u03b1) : Seq.destruct (think s) = some (none, s)", "start": [649, 1], "end": [651, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_nil", "code": "@[simp]\ntheorem head_nil : head (nil : WSeq \u03b1) = Computation.pure none", "start": [654, 1], "end": [655, 81], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_cons", "code": "@[simp]\ntheorem head_cons (a : \u03b1) (s) : head (cons a s) = Computation.pure (some a)", "start": [658, 1], "end": [659, 94], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_think", "code": "@[simp]\ntheorem head_think (s : WSeq \u03b1) : head (think s) = (head s).think", "start": [662, 1], "end": [663, 84], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.flatten_pure", "code": "@[simp]\ntheorem flatten_pure (s : WSeq \u03b1) : flatten (Computation.pure s) = s", "start": [666, 1], "end": [674, 9], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.flatten_think", "code": "@[simp]\ntheorem flatten_think (c : Computation (WSeq \u03b1)) : flatten c.think = think (flatten c)", "start": [677, 1], "end": [679, 51], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_flatten", "code": "@[simp]\ntheorem destruct_flatten (c : Computation (WSeq \u03b1)) : destruct (flatten c) = c >>= destruct", "start": [682, 1], "end": [695, 36], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_terminates_iff", "code": "theorem head_terminates_iff (s : WSeq \u03b1) : Terminates (head s) \u2194 Terminates (destruct s)", "start": [698, 1], "end": [699, 36], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail_nil", "code": "@[simp]\ntheorem tail_nil : tail (nil : WSeq \u03b1) = nil", "start": [702, 1], "end": [703, 63], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail_cons", "code": "@[simp]\ntheorem tail_cons (a : \u03b1) (s) : tail (cons a s) = s", "start": [706, 1], "end": [707, 70], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail_think", "code": "@[simp]\ntheorem tail_think (s : WSeq \u03b1) : tail (think s) = (tail s).think", "start": [710, 1], "end": [711, 84], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_nil", "code": "@[simp]\ntheorem dropn_nil (n) : drop (nil : WSeq \u03b1) n = nil", "start": [714, 1], "end": [715, 89], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_cons", "code": "@[simp]\ntheorem dropn_cons (a : \u03b1) (s) (n) : drop (cons a s) (n + 1) = drop s n", "start": [718, 1], "end": [724, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_think", "code": "@[simp]\ntheorem dropn_think (s : WSeq \u03b1) (n) : drop (think s) n = (drop s n).think", "start": [727, 1], "end": [729, 33], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_add", "code": "theorem dropn_add (s : WSeq \u03b1) (m) : \u2200 n, drop s (m + n) = drop (drop s m) n", "start": [732, 1], "end": [734, 46], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_tail", "code": "theorem dropn_tail (s : WSeq \u03b1) (n) : drop (tail s) n = drop s (n + 1)", "start": [737, 1], "end": [740, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_add", "code": "theorem get?_add (s : WSeq \u03b1) (m n) : get? s (m + n) = get? (drop s m) n", "start": [743, 1], "end": [744, 35], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_tail", "code": "theorem get?_tail (s : WSeq \u03b1) (n) : get? (tail s) n = get? s (n + 1)", "start": [747, 1], "end": [748, 34], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_nil", "code": "@[simp]\ntheorem join_nil : join nil = (nil : WSeq \u03b1)", "start": [751, 1], "end": [753, 15], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_think", "code": "@[simp]\ntheorem join_think (S : WSeq (WSeq \u03b1)) : join (think S) = think (join S)", "start": [756, 1], "end": [760, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_cons", "code": "@[simp]\ntheorem join_cons (s : WSeq \u03b1) (S) : join (cons s S) = think (append s (join S))", "start": [763, 1], "end": [767, 28], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.nil_append", "code": "@[simp]\ntheorem nil_append (s : WSeq \u03b1) : append nil s = s", "start": [770, 1], "end": [772, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.cons_append", "code": "@[simp]\ntheorem cons_append (a : \u03b1) (s t) : append (cons a s) t = cons a (append s t)", "start": [775, 1], "end": [777, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.think_append", "code": "@[simp]\ntheorem think_append (s t : WSeq \u03b1) : append (think s) t = think (append s t)", "start": [780, 1], "end": [782, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.append_nil", "code": "@[simp]\ntheorem append_nil (s : WSeq \u03b1) : append s nil = s", "start": [785, 1], "end": [787, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.append_assoc", "code": "@[simp]\ntheorem append_assoc (s t u : WSeq \u03b1) : append (append s t) u = append s (append t u)", "start": [790, 1], "end": [792, 25], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail.aux", "code": "@[simp]\ndef tail.aux : Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Computation (Option (\u03b1 \u00d7 WSeq \u03b1))\n  | none => Computation.pure none\n  | some (_, s) => destruct s", "start": [795, 1], "end": [799, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_tail", "code": "theorem destruct_tail (s : WSeq \u03b1) : destruct (tail s) = destruct s >>= tail.aux", "start": [802, 1], "end": [804, 101], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.drop.aux", "code": "@[simp]\ndef drop.aux : \u2115 \u2192 Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Computation (Option (\u03b1 \u00d7 WSeq \u03b1))\n  | 0 => Computation.pure\n  | n + 1 => fun a => tail.aux a >>= drop.aux n", "start": [807, 1], "end": [811, 48], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.drop.aux_none", "code": "theorem drop.aux_none : \u2200 n, @drop.aux \u03b1 n none = Computation.pure none", "start": [814, 1], "end": [818, 37], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_dropn", "code": "theorem destruct_dropn : \u2200 (s : WSeq \u03b1) (n), destruct (drop s n) = destruct s >>= drop.aux n", "start": [821, 1], "end": [825, 8], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_terminates_of_head_tail_terminates", "code": "theorem head_terminates_of_head_tail_terminates (s : WSeq \u03b1) [T : Terminates (head (tail s))] :\n    Terminates (head s)", "start": [828, 1], "end": [837, 39], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_some_of_destruct_tail_some", "code": "theorem destruct_some_of_destruct_tail_some {s : WSeq \u03b1} {a} (h : some a \u2208 destruct (tail s)) :\n    \u2203 a', some a' \u2208 destruct s", "start": [840, 1], "end": [848, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_some_of_head_tail_some", "code": "theorem head_some_of_head_tail_some {s : WSeq \u03b1} {a} (h : some a \u2208 head (tail s)) :\n    \u2203 a', some a' \u2208 head s", "start": [851, 1], "end": [857, 65], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_some_of_get?_some", "code": "theorem head_some_of_get?_some {s : WSeq \u03b1} {a n} (h : some a \u2208 get? s n) :\n    \u2203 a', some a' \u2208 head s", "start": [860, 1], "end": [866, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.productive_tail", "code": "instance productive_tail (s : WSeq \u03b1) [Productive s] : Productive (tail s) :=\n  \u27e8fun n => by rw [get?_tail]; infer_instance\u27e9", "start": [869, 1], "end": [870, 47], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.productive_dropn", "code": "instance productive_dropn (s : WSeq \u03b1) [Productive s] (n) : Productive (drop s n) :=\n  \u27e8fun m => by rw [\u2190 get?_add]; infer_instance\u27e9", "start": [873, 1], "end": [874, 48], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toSeq", "code": "def toSeq (s : WSeq \u03b1) [Productive s] : Seq \u03b1 :=\n  \u27e8fun n => (get? s n).get,\n   fun {n} h => by\n    cases e : Computation.get (get? s (n + 1))\n    \u00b7 assumption\n    have := Computation.mem_of_get_eq _ e\n    simp [get?] at this h\n    cases' head_some_of_head_tail_some this with a' h'\n    have := mem_unique h' (@Computation.mem_of_get_eq _ _ _ _ h)\n    contradiction\u27e9", "start": [877, 1], "end": [888, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_terminates_le", "code": "theorem get?_terminates_le {s : WSeq \u03b1} {m n} (h : m \u2264 n) :\n    Terminates (get? s n) \u2192 Terminates (get? s m)", "start": [891, 1], "end": [894, 76], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_terminates_of_get?_terminates", "code": "theorem head_terminates_of_get?_terminates {s : WSeq \u03b1} {n} :\n    Terminates (get? s n) \u2192 Terminates (head s)", "start": [897, 1], "end": [899, 37], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_terminates_of_get?_terminates", "code": "theorem destruct_terminates_of_get?_terminates {s : WSeq \u03b1} {n} (T : Terminates (get? s n)) :\n    Terminates (destruct s)", "start": [902, 1], "end": [904, 68], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_rec_on", "code": "theorem mem_rec_on {C : WSeq \u03b1 \u2192 Prop} {a s} (M : a \u2208 s) (h1 : \u2200 b s', a = b \u2228 C s' \u2192 C (cons b s'))\n    (h2 : \u2200 s, C s \u2192 C (think s)) : C s", "start": [907, 1], "end": [918, 16], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_think", "code": "@[simp]\ntheorem mem_think (s : WSeq \u03b1) (a) : a \u2208 think s \u2194 a \u2208 s", "start": [921, 1], "end": [929, 38], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.eq_or_mem_iff_mem", "code": "theorem eq_or_mem_iff_mem {s : WSeq \u03b1} {a a' s'} :\n    some (a', s') \u2208 destruct s \u2192 (a \u2208 s \u2194 a = a' \u2228 a \u2208 s')", "start": [932, 1], "end": [952, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_cons_iff", "code": "@[simp]\ntheorem mem_cons_iff (s : WSeq \u03b1) (b) {a} : a \u2208 cons b s \u2194 a = b \u2228 a \u2208 s", "start": [955, 1], "end": [957, 41], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_cons_of_mem", "code": "theorem mem_cons_of_mem {s : WSeq \u03b1} (b) {a} (h : a \u2208 s) : a \u2208 cons b s", "start": [960, 1], "end": [961, 34], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_cons", "code": "theorem mem_cons (s : WSeq \u03b1) (a) : a \u2208 cons a s", "start": [964, 1], "end": [965, 36], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_of_mem_tail", "code": "theorem mem_of_mem_tail {s : WSeq \u03b1} {a} : a \u2208 tail s \u2192 a \u2208 s", "start": [968, 1], "end": [978, 8], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_of_mem_dropn", "code": "theorem mem_of_mem_dropn {s : WSeq \u03b1} {a} : \u2200 {n}, a \u2208 drop s n \u2192 a \u2208 s", "start": [981, 1], "end": [983, 60], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_mem", "code": "theorem get?_mem {s : WSeq \u03b1} {a n} : some a \u2208 get? s n \u2192 a \u2208 s", "start": [986, 1], "end": [999, 35], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_get?_of_mem", "code": "theorem exists_get?_of_mem {s : WSeq \u03b1} {a} (h : a \u2208 s) : \u2203 n, some a \u2208 get? s n", "start": [1002, 1], "end": [1018, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_dropn_of_mem", "code": "theorem exists_dropn_of_mem {s : WSeq \u03b1} {a} (h : a \u2208 s) :\n    \u2203 n s', some (a, s') \u2208 destruct (drop s n)", "start": [1021, 1], "end": [1033, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_dropn_destruct", "code": "theorem liftRel_dropn_destruct {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} (H : LiftRel R s t) :\n    \u2200 n, Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct (drop s n)) (destruct (drop t n))", "start": [1036, 1], "end": [1048, 91], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_of_liftRel_left", "code": "theorem exists_of_liftRel_left {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} (H : LiftRel R s t) {a} (h : a \u2208 s) :\n    \u2203 b, b \u2208 t \u2227 R a b", "start": [1051, 1], "end": [1059, 75], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_of_liftRel_right", "code": "theorem exists_of_liftRel_right {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} (H : LiftRel R s t) {b} (h : b \u2208 t) :\n    \u2203 a, a \u2208 s \u2227 R a b", "start": [1062, 1], "end": [1063, 88], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_terminates_of_mem", "code": "theorem head_terminates_of_mem {s : WSeq \u03b1} {a} (h : a \u2208 s) : Terminates (head s)", "start": [1066, 1], "end": [1068, 46], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.of_mem_append", "code": "theorem of_mem_append {s\u2081 s\u2082 : WSeq \u03b1} {a : \u03b1} : a \u2208 append s\u2081 s\u2082 \u2192 a \u2208 s\u2081 \u2228 a \u2208 s\u2082", "start": [1071, 1], "end": [1072, 20], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_append_left", "code": "theorem mem_append_left {s\u2081 s\u2082 : WSeq \u03b1} {a : \u03b1} : a \u2208 s\u2081 \u2192 a \u2208 append s\u2081 s\u2082", "start": [1075, 1], "end": [1076, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_of_mem_map", "code": "theorem exists_of_mem_map {f} {b : \u03b2} : \u2200 {s : WSeq \u03b1}, b \u2208 map f s \u2192 \u2203 a, a \u2208 s \u2227 f a = b", "start": [1079, 1], "end": [1085, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_nil", "code": "@[simp]\ntheorem liftRel_nil (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : LiftRel R nil nil", "start": [1088, 1], "end": [1092, 49], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_cons", "code": "@[simp]\ntheorem liftRel_cons (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (a b s t) :\n    LiftRel R (cons a s) (cons b t) \u2194 R a b \u2227 LiftRel R s t", "start": [1095, 1], "end": [1100, 49], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_think_left", "code": "@[simp]\ntheorem liftRel_think_left (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (s t) : LiftRel R (think s) t \u2194 LiftRel R s t", "start": [1103, 1], "end": [1105, 56], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_think_right", "code": "@[simp]\ntheorem liftRel_think_right (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (s t) : LiftRel R s (think t) \u2194 LiftRel R s t", "start": [1108, 1], "end": [1110, 56], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.cons_congr", "code": "theorem cons_congr {s t : WSeq \u03b1} (a : \u03b1) (h : s ~\u02b7 t) : cons a s ~\u02b7 cons a t", "start": [1113, 1], "end": [1114, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.think_equiv", "code": "theorem think_equiv (s : WSeq \u03b1) : think s ~\u02b7 s", "start": [1117, 1], "end": [1117, 91], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.think_congr", "code": "theorem think_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) : think s ~\u02b7 think t", "start": [1120, 1], "end": [1121, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_congr", "code": "theorem head_congr : \u2200 {s t : WSeq \u03b1}, s ~\u02b7 t \u2192 head s ~ head t", "start": [1124, 1], "end": [1142, 38], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.flatten_equiv", "code": "theorem flatten_equiv {c : Computation (WSeq \u03b1)} {s} (h : s \u2208 c) : flatten c ~\u02b7 s", "start": [1145, 1], "end": [1150, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_flatten", "code": "theorem liftRel_flatten {R : \u03b1 \u2192 \u03b2 \u2192 Prop} {c1 : Computation (WSeq \u03b1)} {c2 : Computation (WSeq \u03b2)}\n    (h : c1.LiftRel (LiftRel R) c2) : LiftRel R (flatten c1) (flatten c2)", "start": [1153, 1], "end": [1165, 59], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.flatten_congr", "code": "theorem flatten_congr {c1 c2 : Computation (WSeq \u03b1)} :\n    Computation.LiftRel Equiv c1 c2 \u2192 flatten c1 ~\u02b7 flatten c2", "start": [1168, 1], "end": [1170, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail_congr", "code": "theorem tail_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) : tail s ~\u02b7 tail t", "start": [1173, 1], "end": [1186, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_congr", "code": "theorem dropn_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) (n) : drop s n ~\u02b7 drop t n", "start": [1189, 1], "end": [1190, 45], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_congr", "code": "theorem get?_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) (n) : get? s n ~ get? t n", "start": [1193, 1], "end": [1194, 31], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_congr", "code": "theorem mem_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) (a) : a \u2208 s \u2194 a \u2208 t", "start": [1197, 1], "end": [1201, 37], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.productive_congr", "code": "theorem productive_congr {s t : WSeq \u03b1} (h : s ~\u02b7 t) : Productive s \u2194 Productive t", "start": [1204, 1], "end": [1205, 94], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.Equiv.ext", "code": "theorem Equiv.ext {s t : WSeq \u03b1} (h : \u2200 n, get? s n ~ get? t n) : s ~\u02b7 t", "start": [1208, 1], "end": [1228, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.length_eq_map", "code": "theorem length_eq_map (s : WSeq \u03b1) : length s = Computation.map List.length (toList s)", "start": [1231, 1], "end": [1250, 34], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ofList_nil", "code": "@[simp]\ntheorem ofList_nil : ofList [] = (nil : WSeq \u03b1)", "start": [1253, 1], "end": [1255, 6], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ofList_cons", "code": "@[simp]\ntheorem ofList_cons (a : \u03b1) (l) : ofList (a::l) = cons a (ofList l)", "start": [1258, 1], "end": [1260, 98], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList'_nil", "code": "@[simp]\ntheorem toList'_nil (l : List \u03b1) :\n    Computation.corec (fun \u27e8l, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, nil) = Computation.pure l.reverse", "start": [1263, 1], "end": [1270, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList'_cons", "code": "@[simp]\ntheorem toList'_cons (l : List \u03b1) (s : WSeq \u03b1) (a : \u03b1) :\n    Computation.corec (fun \u27e8l, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, cons a s) =\n      (Computation.corec (fun \u27e8l, s\u27e9 =>\n        match Seq.destruct s with\n        | none => Sum.inl l.reverse\n        | some (none, s') => Sum.inr (l, s')\n        | some (some a, s') => Sum.inr (a::l, s')) (a::l, s)).think", "start": [1273, 1], "end": [1285, 46], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList'_think", "code": "@[simp]\ntheorem toList'_think (l : List \u03b1) (s : WSeq \u03b1) :\n    Computation.corec (fun \u27e8l, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, think s) =\n      (Computation.corec (fun \u27e8l, s\u27e9 =>\n        match Seq.destruct s with\n        | none => Sum.inl l.reverse\n        | some (none, s') => Sum.inr (l, s')\n        | some (some a, s') => Sum.inr (a::l, s')) (l, s)).think", "start": [1288, 1], "end": [1300, 47], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList'_map", "code": "theorem toList'_map (l : List \u03b1) (s : WSeq \u03b1) :\n    Computation.corec (fun \u27e8l, s\u27e9 =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, s) = (\u00b7 ++ \u00b7) l.reverse <$> toList s", "start": [1303, 1], "end": [1327, 35], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList_cons", "code": "@[simp]\ntheorem toList_cons (a : \u03b1) (s) : toList (cons a s) = (List.cons a <$> toList s).think", "start": [1330, 1], "end": [1332, 75], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList_nil", "code": "@[simp]\ntheorem toList_nil : toList (nil : WSeq \u03b1) = Computation.pure []", "start": [1335, 1], "end": [1337, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toList_ofList", "code": "theorem toList_ofList (l : List \u03b1) : l \u2208 toList (ofList l)", "start": [1340, 1], "end": [1341, 90], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_ofSeq", "code": "@[simp]\ntheorem destruct_ofSeq (s : Seq \u03b1) :\n    destruct (ofSeq s) = Computation.pure (s.head.map fun a => (a, ofSeq s.tail))", "start": [1344, 1], "end": [1354, 20], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.head_ofSeq", "code": "@[simp]\ntheorem head_ofSeq (s : Seq \u03b1) : head (ofSeq s) = Computation.pure s.head", "start": [1357, 1], "end": [1359, 40], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.tail_ofSeq", "code": "@[simp]\ntheorem tail_ofSeq (s : Seq \u03b1) : tail (ofSeq s) = ofSeq s.tail", "start": [1362, 1], "end": [1365, 8], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.dropn_ofSeq", "code": "@[simp]\ntheorem dropn_ofSeq (s : Seq \u03b1) : \u2200 n, drop (ofSeq s) n = ofSeq (s.drop n)", "start": [1368, 1], "end": [1373, 37], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.get?_ofSeq", "code": "theorem get?_ofSeq (s : Seq \u03b1) (n) : get? (ofSeq s) n = Computation.pure (Seq.get? s n)", "start": [1376, 1], "end": [1377, 61], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.productive_ofSeq", "code": "instance productive_ofSeq (s : Seq \u03b1) : Productive (ofSeq s) :=\n  \u27e8fun n => by rw [get?_ofSeq]; infer_instance\u27e9", "start": [1380, 1], "end": [1381, 48], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.toSeq_ofSeq", "code": "theorem toSeq_ofSeq (s : Seq \u03b1) : toSeq (ofSeq s) = s", "start": [1384, 1], "end": [1387, 33], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ret", "code": "def ret (a : \u03b1) : WSeq \u03b1 :=\n  ofList [a]", "start": [1390, 1], "end": [1392, 13], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_nil", "code": "@[simp]\ntheorem map_nil (f : \u03b1 \u2192 \u03b2) : map f nil = nil", "start": [1395, 1], "end": [1397, 6], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_cons", "code": "@[simp]\ntheorem map_cons (f : \u03b1 \u2192 \u03b2) (a s) : map f (cons a s) = cons (f a) (map f s)", "start": [1400, 1], "end": [1402, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_think", "code": "@[simp]\ntheorem map_think (f : \u03b1 \u2192 \u03b2) (s) : map f (think s) = think (map f s)", "start": [1405, 1], "end": [1407, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_id", "code": "@[simp]\ntheorem map_id (s : WSeq \u03b1) : map id s = s", "start": [1410, 1], "end": [1411, 60], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_ret", "code": "@[simp]\ntheorem map_ret (f : \u03b1 \u2192 \u03b2) (a) : map f (ret a) = ret (f a)", "start": [1414, 1], "end": [1415, 77], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_append", "code": "@[simp]\ntheorem map_append (f : \u03b1 \u2192 \u03b2) (s t) : map f (append s t) = append (map f s) (map f t)", "start": [1418, 1], "end": [1420, 23], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_comp", "code": "theorem map_comp (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (s : WSeq \u03b1) : map (g \u2218 f) s = map g (map f s)", "start": [1423, 1], "end": [1426, 17], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.mem_map", "code": "theorem mem_map (f : \u03b1 \u2192 \u03b2) {a : \u03b1} {s : WSeq \u03b1} : a \u2208 s \u2192 f a \u2208 map f s", "start": [1429, 1], "end": [1430, 29], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_of_mem_join", "code": "theorem exists_of_mem_join {a : \u03b1} : \u2200 {S : WSeq (WSeq \u03b1)}, a \u2208 join S \u2192 \u2203 s, s \u2208 S \u2227 a \u2208 s", "start": [1434, 1], "end": [1467, 25], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.exists_of_mem_bind", "code": "theorem exists_of_mem_bind {s : WSeq \u03b1} {f : \u03b1 \u2192 WSeq \u03b2} {b} (h : b \u2208 bind s f) :\n    \u2203 a \u2208 s, b \u2208 f a", "start": [1470, 1], "end": [1474, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_map", "code": "theorem destruct_map (f : \u03b1 \u2192 \u03b2) (s : WSeq \u03b1) :\n    destruct (map f s) = Computation.map (Option.map (Prod.map f (map f))) (destruct s)", "start": [1477, 1], "end": [1489, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_map", "code": "theorem liftRel_map {\u03b4} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (S : \u03b3 \u2192 \u03b4 \u2192 Prop) {s1 : WSeq \u03b1} {s2 : WSeq \u03b2}\n    {f1 : \u03b1 \u2192 \u03b3} {f2 : \u03b2 \u2192 \u03b4} (h1 : LiftRel R s1 s2) (h2 : \u2200 {a b}, R a b \u2192 S (f1 a) (f2 b)) :\n    LiftRel S (map f1 s1) (map f2 s2)", "start": [1492, 1], "end": [1506, 41], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_congr", "code": "theorem map_congr (f : \u03b1 \u2192 \u03b2) {s t : WSeq \u03b1} (h : s ~\u02b7 t) : map f s ~\u02b7 map f t", "start": [1509, 1], "end": [1510, 45], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_append.aux", "code": "@[simp]\ndef destruct_append.aux (t : WSeq \u03b1) : Option (\u03b1 \u00d7 WSeq \u03b1) \u2192 Computation (Option (\u03b1 \u00d7 WSeq \u03b1))\n  | none => destruct t\n  | some (a, s) => Computation.pure (some (a, append s t))", "start": [1513, 1], "end": [1517, 59], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_append", "code": "theorem destruct_append (s t : WSeq \u03b1) :\n    destruct (append s t) = (destruct s).bind (destruct_append.aux t)", "start": [1520, 1], "end": [1531, 27], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_join.aux", "code": "@[simp]\ndef destruct_join.aux : Option (WSeq \u03b1 \u00d7 WSeq (WSeq \u03b1)) \u2192 Computation (Option (\u03b1 \u00d7 WSeq \u03b1))\n  | none => Computation.pure none\n  | some (s, S) => (destruct (append s (join S))).think", "start": [1534, 1], "end": [1538, 56], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.destruct_join", "code": "theorem destruct_join (S : WSeq (WSeq \u03b1)) :\n    destruct (join S) = (destruct S).bind destruct_join.aux", "start": [1541, 1], "end": [1554, 37], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_append", "code": "theorem liftRel_append (R : \u03b1 \u2192 \u03b2 \u2192 Prop) {s1 s2 : WSeq \u03b1} {t1 t2 : WSeq \u03b2} (h1 : LiftRel R s1 t1)\n    (h2 : LiftRel R s2 t2) : LiftRel R (append s1 s2) (append t1 t2)", "start": [1557, 1], "end": [1583, 47], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_join.lem", "code": "theorem liftRel_join.lem (R : \u03b1 \u2192 \u03b2 \u2192 Prop) {S T} {U : WSeq \u03b1 \u2192 WSeq \u03b2 \u2192 Prop}\n    (ST : LiftRel (LiftRel R) S T)\n    (HU :\n      \u2200 s1 s2,\n        (\u2203 s t S T,\n            s1 = append s (join S) \u2227\n              s2 = append t (join T) \u2227 LiftRel R s t \u2227 LiftRel (LiftRel R) S T) \u2192\n          U s1 s2)\n    {a} (ma : a \u2208 destruct (join S)) : \u2203 b, b \u2208 destruct (join T) \u2227 LiftRelO R U a b", "start": [1586, 1], "end": [1635, 66], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_join", "code": "theorem liftRel_join (R : \u03b1 \u2192 \u03b2 \u2192 Prop) {S : WSeq (WSeq \u03b1)} {T : WSeq (WSeq \u03b2)}\n    (h : LiftRel (LiftRel R) S T) : LiftRel R (join S) (join T)", "start": [1638, 1], "end": [1664, 22], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_congr", "code": "theorem join_congr {S T : WSeq (WSeq \u03b1)} (h : LiftRel Equiv S T) : join S ~\u02b7 join T", "start": [1667, 1], "end": [1668, 19], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.liftRel_bind", "code": "theorem liftRel_bind {\u03b4} (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (S : \u03b3 \u2192 \u03b4 \u2192 Prop) {s1 : WSeq \u03b1} {s2 : WSeq \u03b2}\n    {f1 : \u03b1 \u2192 WSeq \u03b3} {f2 : \u03b2 \u2192 WSeq \u03b4} (h1 : LiftRel R s1 s2)\n    (h2 : \u2200 {a b}, R a b \u2192 LiftRel S (f1 a) (f2 b)) : LiftRel S (bind s1 f1) (bind s2 f2)", "start": [1671, 1], "end": [1674, 42], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.bind_congr", "code": "theorem bind_congr {s1 s2 : WSeq \u03b1} {f1 f2 : \u03b1 \u2192 WSeq \u03b2} (h1 : s1 ~\u02b7 s2) (h2 : \u2200 a, f1 a ~\u02b7 f2 a) :\n    bind s1 f1 ~\u02b7 bind s2 f2", "start": [1677, 1], "end": [1679, 57], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_ret", "code": "@[simp]\ntheorem join_ret (s : WSeq \u03b1) : join (ret s) ~\u02b7 s", "start": [1682, 1], "end": [1683, 86], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_map_ret", "code": "@[simp]\ntheorem join_map_ret (s : WSeq \u03b1) : join (map ret s) ~\u02b7 s", "start": [1686, 1], "end": [1701, 24], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_append", "code": "@[simp]\ntheorem join_append (S T : WSeq (WSeq \u03b1)) : join (append S T) ~\u02b7 append (join S) (join T)", "start": [1704, 1], "end": [1729, 30], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.bind_ret", "code": "@[simp]\ntheorem bind_ret (f : \u03b1 \u2192 \u03b2) (s) : bind s (ret \u2218 f) ~\u02b7 map f s", "start": [1732, 1], "end": [1736, 21], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.ret_bind", "code": "@[simp]\ntheorem ret_bind (a : \u03b1) (f : \u03b1 \u2192 WSeq \u03b2) : bind (ret a) f ~\u02b7 f a", "start": [1739, 1], "end": [1740, 84], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.map_join", "code": "@[simp]\ntheorem map_join (f : \u03b1 \u2192 \u03b2) (S) : map f (join S) = join (map (map f) S)", "start": [1743, 1], "end": [1758, 36], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.join_join", "code": "@[simp]\ntheorem join_join (SS : WSeq (WSeq (WSeq \u03b1))) : join (join SS) ~\u02b7 join (map join SS)", "start": [1761, 1], "end": [1792, 35], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.bind_assoc", "code": "@[simp]\ntheorem bind_assoc (s : WSeq \u03b1) (f : \u03b1 \u2192 WSeq \u03b2) (g : \u03b2 \u2192 WSeq \u03b3) :\n    bind (bind s f) g ~\u02b7 bind s fun x : \u03b1 => bind (f x) g", "start": [1795, 1], "end": [1799, 18], "kind": "commanddeclaration"}, {"full_name": "Stream'.WSeq.monad", "code": "instance monad : Monad WSeq where\n  map := @map\n  pure := @ret\n  bind := @bind", "start": [1802, 1], "end": [1805, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Complex.hasSum_cos'", "code": "theorem Complex.hasSum_cos' (z : \u2102) :\n    HasSum (fun n : \u2115 => (z * Complex.I) ^ (2 * n) / \u2191(2 * n)!) (Complex.cos z)", "start": [31, 1], "end": [45, 55], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_sin'", "code": "theorem Complex.hasSum_sin' (z : \u2102) :\n    HasSum (fun n : \u2115 => (z * Complex.I) ^ (2 * n + 1) / \u2191(2 * n + 1)! / Complex.I)\n      (Complex.sin z)", "start": [48, 1], "end": [63, 99], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_cos", "code": "theorem Complex.hasSum_cos (z : \u2102) :\n    HasSum (fun n : \u2115 => (-1) ^ n * z ^ (2 * n) / \u2191(2 * n)!) (Complex.cos z)", "start": [66, 1], "end": [70, 53], "kind": "commanddeclaration"}, {"full_name": "Complex.hasSum_sin", "code": "theorem Complex.hasSum_sin (z : \u2102) :\n    HasSum (fun n : \u2115 => (-1) ^ n * z ^ (2 * n + 1) / \u2191(2 * n + 1)!) (Complex.sin z)", "start": [73, 1], "end": [78, 98], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_eq_tsum'", "code": "theorem Complex.cos_eq_tsum' (z : \u2102) :\n    Complex.cos z = \u2211' n : \u2115, (z * Complex.I) ^ (2 * n) / \u2191(2 * n)!", "start": [81, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_eq_tsum'", "code": "theorem Complex.sin_eq_tsum' (z : \u2102) :\n    Complex.sin z = \u2211' n : \u2115, (z * Complex.I) ^ (2 * n + 1) / \u2191(2 * n + 1)! / Complex.I", "start": [86, 1], "end": [88, 39], "kind": "commanddeclaration"}, {"full_name": "Complex.cos_eq_tsum", "code": "theorem Complex.cos_eq_tsum (z : \u2102) :\n    Complex.cos z = \u2211' n : \u2115, (-1) ^ n * z ^ (2 * n) / \u2191(2 * n)!", "start": [91, 1], "end": [93, 38], "kind": "commanddeclaration"}, {"full_name": "Complex.sin_eq_tsum", "code": "theorem Complex.sin_eq_tsum (z : \u2102) :\n    Complex.sin z = \u2211' n : \u2115, (-1) ^ n * z ^ (2 * n + 1) / \u2191(2 * n + 1)!", "start": [96, 1], "end": [98, 38], "kind": "commanddeclaration"}, {"full_name": "Real.hasSum_cos", "code": "theorem Real.hasSum_cos (r : \u211d) :\n    HasSum (fun n : \u2115 => (-1) ^ n * r ^ (2 * n) / \u2191(2 * n)!) (Real.cos r)", "start": [101, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "Real.hasSum_sin", "code": "theorem Real.hasSum_sin (r : \u211d) :\n    HasSum (fun n : \u2115 => (-1) ^ n * r ^ (2 * n + 1) / \u2191(2 * n + 1)!) (Real.sin r)", "start": [107, 1], "end": [110, 38], "kind": "commanddeclaration"}, {"full_name": "Real.cos_eq_tsum", "code": "theorem Real.cos_eq_tsum (r : \u211d) : Real.cos r = \u2211' n : \u2115, (-1) ^ n * r ^ (2 * n) / \u2191(2 * n)!", "start": [113, 1], "end": [114, 35], "kind": "commanddeclaration"}, {"full_name": "Real.sin_eq_tsum", "code": "theorem Real.sin_eq_tsum (r : \u211d) :\n    Real.sin r = \u2211' n : \u2115, (-1) ^ n * r ^ (2 * n + 1) / \u2191(2 * n + 1)!", "start": [117, 1], "end": [119, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Quaternion.lean", "imports": ["Mathlib/Algebra/Quaternion.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Algebra/Algebra.lean", "Mathlib/Analysis/InnerProductSpace/PiL2.lean", "Mathlib/Analysis/InnerProductSpace/Basic.lean"], "premises": [{"full_name": "Quaternion.inner_self", "code": "theorem inner_self (a : \u210d) : \u27eaa, a\u27eb = normSq a", "start": [46, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.inner_def", "code": "theorem inner_def (a b : \u210d) : \u27eaa, b\u27eb = (a * star b).re", "start": [50, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.normSq_eq_norm_mul_self", "code": "theorem normSq_eq_norm_mul_self (a : \u210d) : normSq a = \u2016a\u2016 * \u2016a\u2016", "start": [66, 1], "end": [67, 54], "kind": "commanddeclaration"}, {"full_name": "Quaternion.norm_coe", "code": "@[simp, norm_cast]\ntheorem norm_coe (a : \u211d) : \u2016(a : \u210d)\u2016 = \u2016a\u2016", "start": [73, 1], "end": [75, 94], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nnnorm_coe", "code": "@[simp, norm_cast]\ntheorem nnnorm_coe (a : \u211d) : \u2016(a : \u210d)\u2016\u208a = \u2016a\u2016\u208a", "start": [78, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Quaternion.norm_star", "code": "@[simp, nolint simpNF] theorem norm_star (a : \u210d) : \u2016star a\u2016 = \u2016a\u2016", "start": [83, 1], "end": [85, 61], "kind": "commanddeclaration"}, {"full_name": "Quaternion.nnnorm_star", "code": "@[simp, nolint simpNF] theorem nnnorm_star (a : \u210d) : \u2016star a\u2016\u208a = \u2016a\u2016\u208a", "start": [88, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex", "code": "@[coe] def coeComplex (z : \u2102) : \u210d := \u27e8z.re, z.im, 0, 0\u27e9", "start": [107, 1], "end": [108, 56], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_re", "code": "@[simp, norm_cast]\ntheorem coeComplex_re (z : \u2102) : (z : \u210d).re = z.re", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_imI", "code": "@[simp, norm_cast]\ntheorem coeComplex_imI (z : \u2102) : (z : \u210d).imI = z.im", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_imJ", "code": "@[simp, norm_cast]\ntheorem coeComplex_imJ (z : \u2102) : (z : \u210d).imJ = 0", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_imK", "code": "@[simp, norm_cast]\ntheorem coeComplex_imK (z : \u2102) : (z : \u210d).imK = 0", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_add", "code": "@[simp, norm_cast]\ntheorem coeComplex_add (z w : \u2102) : \u2191(z + w) = (z + w : \u210d)", "start": [132, 1], "end": [133, 77], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_mul", "code": "@[simp, norm_cast]\ntheorem coeComplex_mul (z w : \u2102) : \u2191(z * w) = (z * w : \u210d)", "start": [136, 1], "end": [137, 77], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_zero", "code": "@[simp, norm_cast]\ntheorem coeComplex_zero : ((0 : \u2102) : \u210d) = 0", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_one", "code": "@[simp, norm_cast]\ntheorem coeComplex_one : ((1 : \u2102) : \u210d) = 1", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_real_complex_mul", "code": "@[simp, norm_cast, nolint simpNF] theorem coe_real_complex_mul (r : \u211d) (z : \u2102) : (r \u2022 z : \u210d) = \u2191r * \u2191z", "start": [150, 1], "end": [151, 88], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coeComplex_coe", "code": "@[simp, norm_cast]\ntheorem coeComplex_coe (r : \u211d) : ((r : \u2102) : \u210d) = r", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.ofComplex", "code": "def ofComplex : \u2102 \u2192\u2090[\u211d] \u210d where\n  toFun := (\u2191)\n  map_one' := rfl\n  map_zero' := rfl\n  map_add' := coeComplex_add\n  map_mul' := coeComplex_mul\n  commutes' _ := rfl", "start": [159, 1], "end": [166, 21], "kind": "commanddeclaration"}, {"full_name": "Quaternion.coe_ofComplex", "code": "@[simp]\ntheorem coe_ofComplex : \u21d1ofComplex = coeComplex", "start": [169, 1], "end": [170, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.norm_piLp_equiv_symm_equivTuple", "code": "theorem norm_piLp_equiv_symm_equivTuple (x : \u210d) :\n    \u2016(WithLp.equiv 2 (Fin 4 \u2192 _)).symm (equivTuple \u211d x)\u2016 = \u2016x\u2016", "start": [173, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "Quaternion.linearIsometryEquivTuple", "code": "@[simps apply symm_apply]\nnoncomputable def linearIsometryEquivTuple : \u210d \u2243\u2097\u1d62[\u211d] EuclideanSpace \u211d (Fin 4) :=\n  { (QuaternionAlgebra.linearEquivTuple (-1 : \u211d) (-1 : \u211d)).trans\n      (WithLp.linearEquiv 2 \u211d (Fin 4 \u2192 \u211d)).symm with\n    toFun := fun a => (WithLp.equiv _ (Fin 4 \u2192 _)).symm ![a.1, a.2, a.3, a.4]\n    invFun := fun a => \u27e8a 0, a 1, a 2, a 3\u27e9\n    norm_map' := norm_piLp_equiv_symm_equivTuple }", "start": [183, 1], "end": [190, 51], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_coe", "code": "@[continuity]\ntheorem continuous_coe : Continuous (coe : \u211d \u2192 \u210d)", "start": [193, 1], "end": [195, 28], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_normSq", "code": "@[continuity]\ntheorem continuous_normSq : Continuous (normSq : \u210d \u2192 \u211d)", "start": [198, 1], "end": [201, 78], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_re", "code": "@[continuity]\ntheorem continuous_re : Continuous fun q : \u210d => q.re", "start": [204, 1], "end": [206, 64], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_imI", "code": "@[continuity]\ntheorem continuous_imI : Continuous fun q : \u210d => q.imI", "start": [209, 1], "end": [211, 64], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_imJ", "code": "@[continuity]\ntheorem continuous_imJ : Continuous fun q : \u210d => q.imJ", "start": [214, 1], "end": [216, 64], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_imK", "code": "@[continuity]\ntheorem continuous_imK : Continuous fun q : \u210d => q.imK", "start": [219, 1], "end": [221, 64], "kind": "commanddeclaration"}, {"full_name": "Quaternion.continuous_im", "code": "@[continuity]\ntheorem continuous_im : Continuous fun q : \u210d => q.im", "start": [224, 1], "end": [226, 89], "kind": "commanddeclaration"}, {"full_name": "Quaternion.hasSum_coe", "code": "@[simp, norm_cast]\ntheorem hasSum_coe {f : \u03b1 \u2192 \u211d} {r : \u211d} : HasSum (fun a => (f a : \u210d)) (\u2191r : \u210d) \u2194 HasSum f r", "start": [238, 1], "end": [241, 85], "kind": "commanddeclaration"}, {"full_name": "Quaternion.summable_coe", "code": "@[simp, norm_cast]\ntheorem summable_coe {f : \u03b1 \u2192 \u211d} : (Summable fun a => (f a : \u210d)) \u2194 Summable f", "start": [244, 1], "end": [248, 55], "kind": "commanddeclaration"}, {"full_name": "Quaternion.tsum_coe", "code": "@[norm_cast]\ntheorem tsum_coe (f : \u03b1 \u2192 \u211d) : (\u2211' a, (f a : \u210d)) = \u2191(\u2211' a, f a)", "start": [251, 1], "end": [255, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Derivation/Lie.lean", "imports": ["Mathlib/RingTheory/Derivation/Basic.lean", "Mathlib/Algebra/Lie/OfAssociative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Derivation.commutator_coe_linear_map", "code": "@[simp]\ntheorem commutator_coe_linear_map : \u2191\u2045D1, D2\u2046 = \u2045(D1 : Module.End R A), (D2 : Module.End R A)\u2046", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Derivation.commutator_apply", "code": "theorem commutator_apply : \u2045D1, D2\u2046 a = D1 (D2 a) - D2 (D1 a)", "start": [45, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Derivation.instLieAlgebra", "code": "instance instLieAlgebra: LieAlgebra R (Derivation R A A) :=\n  { Derivation.instModule with\n    lie_smul := fun r d e => by\n      ext a; simp only [commutator_apply, map_smul, smul_sub, smul_apply] }", "start": [55, 1], "end": [58, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Manifold/DerivationBundle.lean", "imports": ["Mathlib/Geometry/Manifold/Algebra/SmoothFunctions.lean", "Mathlib/RingTheory/Derivation/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "smoothFunctionsAlgebra", "code": "instance smoothFunctionsAlgebra : Algebra \ud835\udd5c C^\u221e\u27eeI, M; \ud835\udd5c\u27ef := by infer_instance", "start": [32, 1], "end": [32, 78], "kind": "commanddeclaration"}, {"full_name": "smooth_functions_tower", "code": "instance smooth_functions_tower : IsScalarTower \ud835\udd5c C^\u221e\u27eeI, M; \ud835\udd5c\u27ef C^\u221e\u27eeI, M; \ud835\udd5c\u27ef := by infer_instance", "start": [35, 1], "end": [35, 97], "kind": "commanddeclaration"}, {"full_name": "PointedSmoothMap", "code": "@[nolint unusedArguments]\ndef PointedSmoothMap (_ : M) :=\n  C^n\u27eeI, M; \ud835\udd5c\u27ef", "start": [38, 1], "end": [42, 15], "kind": "commanddeclaration"}, {"full_name": "PointedSmoothMap.funLike", "code": "instance funLike {x : M} : FunLike C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9 M fun _ => \ud835\udd5c :=\n  ContMDiffMap.funLike", "start": [53, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "PointedSmoothMap.evalAlgebra", "code": "instance evalAlgebra {x : M} : Algebra C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9 \ud835\udd5c :=\n  (SmoothMap.evalRingHom x : C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9 \u2192+* \ud835\udd5c).toAlgebra", "start": [74, 1], "end": [76, 62], "kind": "commanddeclaration"}, {"full_name": "PointedSmoothMap.eval", "code": "def eval (x : M) : C^\u221e\u27eeI, M; \ud835\udd5c\u27ef \u2192\u2090[C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9] \ud835\udd5c :=\n  Algebra.ofId C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9 \ud835\udd5c", "start": [79, 1], "end": [81, 33], "kind": "commanddeclaration"}, {"full_name": "PointedSmoothMap.smul_def", "code": "theorem smul_def (x : M) (f : C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9) (k : \ud835\udd5c) : f \u2022 k = f x * k", "start": [84, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "PointDerivation", "code": "@[reducible]\ndef PointDerivation (x : M) :=\n  Derivation \ud835\udd5c C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9 \ud835\udd5c", "start": [96, 1], "end": [100, 33], "kind": "commanddeclaration"}, {"full_name": "SmoothFunction.evalAt", "code": "def SmoothFunction.evalAt (x : M) : C^\u221e\u27eeI, M; \ud835\udd5c\u27ef \u2192\u2097[C^\u221e\u27eeI, M; \ud835\udd5c\u27ef\u27e8x\u27e9] \ud835\udd5c :=\n  (PointedSmoothMap.eval x).toLinearMap", "start": [109, 1], "end": [112, 40], "kind": "commanddeclaration"}, {"full_name": "Derivation.evalAt", "code": "def evalAt (x : M) : Derivation \ud835\udd5c C^\u221e\u27eeI, M; \ud835\udd5c\u27ef C^\u221e\u27eeI, M; \ud835\udd5c\u27ef \u2192\u2097[\ud835\udd5c] PointDerivation I x :=\n  (SmoothFunction.evalAt I x).compDer", "start": [119, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "Derivation.evalAt_apply", "code": "theorem evalAt_apply (x : M) : evalAt x X f = (X f) x", "start": [124, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "hfdifferential", "code": "def hfdifferential {f : C^\u221e\u27eeI, M; I', M'\u27ef} {x : M} {y : M'} (h : f x = y) :\n    PointDerivation I x \u2192\u2097[\ud835\udd5c] PointDerivation I' y where\n  toFun v :=\n    Derivation.mk'\n      { toFun := fun g => v (g.comp f)\n        map_add' := fun g g' => by dsimp; rw [SmoothMap.add_comp, Derivation.map_add]\n        map_smul' := fun k g => by\n          dsimp; rw [SmoothMap.smul_comp, Derivation.map_smul, smul_eq_mul] }\n      fun g g' => by\n        dsimp\n        rw [SmoothMap.mul_comp, Derivation.leibniz,\n          PointedSmoothMap.smul_def, ContMDiffMap.comp_apply,\n          PointedSmoothMap.smul_def, ContMDiffMap.comp_apply, h]\n        norm_cast\n  map_smul' k v := rfl\n  map_add' v w := rfl", "start": [134, 1], "end": [152, 22], "kind": "commanddeclaration"}, {"full_name": "fdifferential", "code": "def fdifferential (f : C^\u221e\u27eeI, M; I', M'\u27ef) (x : M) :\n    PointDerivation I x \u2192\u2097[\ud835\udd5c] PointDerivation I' (f x) :=\n  hfdifferential (rfl : f x = f x)", "start": [155, 1], "end": [158, 35], "kind": "commanddeclaration"}, {"full_name": "apply_fdifferential", "code": "@[simp]\ntheorem apply_fdifferential (f : C^\u221e\u27eeI, M; I', M'\u27ef) {x : M} (v : PointDerivation I x)\n    (g : C^\u221e\u27eeI', M'; \ud835\udd5c\u27ef) : \ud835\udc85 f x v g = v (g.comp f)", "start": [167, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "apply_hfdifferential", "code": "@[simp]\ntheorem apply_hfdifferential {f : C^\u221e\u27eeI, M; I', M'\u27ef} {x : M} {y : M'} (h : f x = y)\n    (v : PointDerivation I x) (g : C^\u221e\u27eeI', M'; \ud835\udd5c\u27ef) : \ud835\udc85\u2095 h v g = \ud835\udc85 f x v g", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "fdifferential_comp", "code": "@[simp]\ntheorem fdifferential_comp (g : C^\u221e\u27eeI', M'; I'', M''\u27ef) (f : C^\u221e\u27eeI, M; I', M'\u27ef) (x : M) :\n    \ud835\udc85 (g.comp f) x = (\ud835\udc85 g (f x)).comp (\ud835\udc85 f x)", "start": [183, 1], "end": [186, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/PreservesHomology.lean", "imports": ["Mathlib/CategoryTheory/Limits/Preserves/Finite.lean", "Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "Mathlib/CategoryTheory/Limits/Preserves/Shapes/Kernels.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.PreservesHomology", "code": "class PreservesHomology (F : C \u2964 D) [PreservesZeroMorphisms F] where\n  \n  preservesKernels \u2983X Y : C\u2984 (f : X \u27f6 Y) : PreservesLimit (parallelPair f 0) F :=\n    by infer_instance\n  \n  preservesCokernels \u2983X Y : C\u2984 (f : X \u27f6 Y) : PreservesColimit (parallelPair f 0) F :=\n    by infer_instance", "start": [36, 1], "end": [43, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesHomology.preservesKernel", "code": "def PreservesHomology.preservesKernel [F.PreservesHomology] {X Y : C} (f : X \u27f6 Y) :\n    PreservesLimit (parallelPair f 0) F :=\n  PreservesHomology.preservesKernels _", "start": [47, 1], "end": [50, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesHomology.preservesCokernel", "code": "def PreservesHomology.preservesCokernel [F.PreservesHomology] {X Y : C} (f : X \u27f6 Y) :\n    PreservesColimit (parallelPair f 0) F :=\n  PreservesHomology.preservesCokernels _", "start": [52, 1], "end": [55, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preservesHomologyOfExact", "code": "noncomputable instance preservesHomologyOfExact\n    [PreservesFiniteLimits F] [PreservesFiniteColimits F] :\n  F.PreservesHomology where", "start": [57, 1], "end": [59, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy", "code": "class IsPreservedBy [F.PreservesZeroMorphisms] where\n  \n  g : PreservesLimit (parallelPair S.g 0) F\n  \n  f' : PreservesColimit (parallelPair h.f' 0) F", "start": [71, 1], "end": [77, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.isPreservedByOfPreservesHomology", "code": "noncomputable instance isPreservedByOfPreservesHomology [F.PreservesHomology] :\n    h.IsPreservedBy F where\n  g := Functor.PreservesHomology.preservesKernel _ _\n  f' := Functor.PreservesHomology.preservesCokernel _ _", "start": [81, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.hg", "code": "def IsPreservedBy.hg : PreservesLimit (parallelPair S.g 0) F :=\n  @IsPreservedBy.g _ _ _ _ _ _ _ h F _ _", "start": [88, 1], "end": [91, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.IsPreservedBy.hf'", "code": "def IsPreservedBy.hf' : PreservesColimit (parallelPair h.f' 0) F := IsPreservedBy.f'", "start": [93, 1], "end": [95, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.map", "code": "@[simps]\nnoncomputable def map : (S.map F).LeftHomologyData := by\n  have := IsPreservedBy.hg h F\n  have := IsPreservedBy.hf' h F\n  have wi : F.map h.i \u226b F.map S.g = 0 := by rw [\u2190 F.map_comp, h.wi, F.map_zero]\n  have hi := KernelFork.mapIsLimit _ h.hi F\n  let f' : F.obj S.X\u2081 \u27f6 F.obj h.K := hi.lift (KernelFork.of\u03b9 (S.map F).f (S.map F).zero)\n  have hf' : f' = F.map h.f' := Fork.IsLimit.hom_ext hi (by\n    rw [Fork.IsLimit.lift_\u03b9 hi]\n    simp only [KernelFork.map_\u03b9, Fork.\u03b9_of\u03b9, map_f, \u2190 F.map_comp, f'_i])\n  have w\u03c0 : f' \u226b F.map h.\u03c0 = 0 := by rw [hf', \u2190 F.map_comp, f'_\u03c0, F.map_zero]\n  have h\u03c0 : IsColimit (CokernelCofork.of\u03c0 (F.map h.\u03c0) w\u03c0) := by\n    let e : parallelPair f' 0 \u2245 parallelPair (F.map h.f') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hf') (by simp)\n    refine' IsColimit.precomposeInvEquiv e _\n      (IsColimit.ofIsoColimit (CokernelCofork.mapIsColimit _ h.h\u03c0' F) _)\n    exact Cofork.ext (Iso.refl _) (by simp)\n  exact\n    { K := F.obj h.K\n      H := F.obj h.H\n      i := F.map h.i\n      \u03c0 := F.map h.\u03c0\n      wi := wi\n      hi := hi\n      w\u03c0 := w\u03c0\n      h\u03c0 := h\u03c0 }", "start": [97, 1], "end": [124, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.map_f'", "code": "@[simp]\nlemma map_f' : (h.map F).f' = F.map h.f' := by\n  rw [\u2190 cancel_mono (h.map F).i, f'_i, map_f, map_i, \u2190 F.map_comp, f'_i]", "start": [126, 1], "end": [128, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.map", "code": "@[simps]\ndef LeftHomologyMapData.map {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.LeftHomologyData}\n    {h\u2082 : S\u2082.LeftHomologyData} (\u03c8 : LeftHomologyMapData \u03c6 h\u2081 h\u2082) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [h\u2081.IsPreservedBy F] [h\u2082.IsPreservedBy F] :\n    LeftHomologyMapData (F.mapShortComplex.map \u03c6) (h\u2081.map F) (h\u2082.map F) where\n  \u03c6K := F.map \u03c8.\u03c6K\n  \u03c6H := F.map \u03c8.\u03c6H\n  commi := by simpa only [F.map_comp] using F.congr_map \u03c8.commi\n  commf' := by simpa only [LeftHomologyData.map_f', F.map_comp] using F.congr_map \u03c8.commf'\n  comm\u03c0 := by simpa only [F.map_comp] using F.congr_map \u03c8.comm\u03c0", "start": [132, 1], "end": [144, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy", "code": "class IsPreservedBy [F.PreservesZeroMorphisms] where\n  \n  f : PreservesColimit (parallelPair S.f 0) F\n  \n  g' : PreservesLimit (parallelPair h.g' 0) F", "start": [150, 1], "end": [156, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.isPreservedByOfPreservesHomology", "code": "noncomputable instance isPreservedByOfPreservesHomology [F.PreservesHomology] :\n    h.IsPreservedBy F where\n  f := Functor.PreservesHomology.preservesCokernel F _\n  g' := Functor.PreservesHomology.preservesKernel F _", "start": [160, 1], "end": [163, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.hf", "code": "def IsPreservedBy.hf : PreservesColimit (parallelPair S.f 0) F :=\n  @IsPreservedBy.f _ _ _ _ _ _ _ h F _ _", "start": [167, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.IsPreservedBy.hg'", "code": "def IsPreservedBy.hg' : PreservesLimit (parallelPair h.g' 0) F :=\n  @IsPreservedBy.g' _ _ _ _ _ _ _ h F _ _", "start": [172, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.map", "code": "@[simps]\nnoncomputable def map : (S.map F).RightHomologyData := by\n  have := IsPreservedBy.hf h F\n  have := IsPreservedBy.hg' h F\n  have wp : F.map S.f \u226b F.map h.p = 0 := by rw [\u2190 F.map_comp, h.wp, F.map_zero]\n  have hp := CokernelCofork.mapIsColimit _ h.hp F\n  let g' : F.obj h.Q \u27f6 F.obj S.X\u2083 := hp.desc (CokernelCofork.of\u03c0 (S.map F).g (S.map F).zero)\n  have hg' : g' = F.map h.g' := by\n    apply Cofork.IsColimit.hom_ext hp\n    rw [Cofork.IsColimit.\u03c0_desc hp]\n    simp only [Cofork.\u03c0_of\u03c0, CokernelCofork.map_\u03c0, map_g, \u2190 F.map_comp, p_g']\n  have w\u03b9 : F.map h.\u03b9 \u226b g' = 0 := by rw [hg', \u2190 F.map_comp, \u03b9_g', F.map_zero]\n  have h\u03b9 : IsLimit (KernelFork.of\u03b9 (F.map h.\u03b9) w\u03b9) := by\n    let e : parallelPair g' 0 \u2245 parallelPair (F.map h.g') 0 :=\n      parallelPair.ext (Iso.refl _) (Iso.refl _) (by simpa using hg') (by simp)\n    refine' IsLimit.postcomposeHomEquiv e _\n      (IsLimit.ofIsoLimit (KernelFork.mapIsLimit _ h.h\u03b9' F) _)\n    exact Fork.ext (Iso.refl _) (by simp)\n  exact\n    { Q := F.obj h.Q\n      H := F.obj h.H\n      p := F.map h.p\n      \u03b9 := F.map h.\u03b9\n      wp := wp\n      hp := hp\n      w\u03b9 := w\u03b9\n      h\u03b9 := h\u03b9 }", "start": [177, 1], "end": [205, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.map_g'", "code": "@[simp]\nlemma map_g' : (h.map F).g' = F.map h.g' := by\n  rw [\u2190 cancel_epi (h.map F).p, p_g', map_g, map_p, \u2190 F.map_comp, p_g']", "start": [207, 1], "end": [209, 72], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyMapData.map", "code": "@[simps]\ndef RightHomologyMapData.map {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.RightHomologyData}\n    {h\u2082 : S\u2082.RightHomologyData} (\u03c8 : RightHomologyMapData \u03c6 h\u2081 h\u2082) (F : C \u2964 D)\n    [F.PreservesZeroMorphisms] [h\u2081.IsPreservedBy F] [h\u2082.IsPreservedBy F] :\n    RightHomologyMapData (F.mapShortComplex.map \u03c6) (h\u2081.map F) (h\u2082.map F) where\n  \u03c6Q := F.map \u03c8.\u03c6Q\n  \u03c6H := F.map \u03c8.\u03c6H\n  commp := by simpa only [F.map_comp] using F.congr_map \u03c8.commp\n  commg' := by simpa only [RightHomologyData.map_g', F.map_comp] using F.congr_map \u03c8.commg'\n  comm\u03b9 := by simpa only [F.map_comp] using F.congr_map \u03c8.comm\u03b9", "start": [213, 1], "end": [225, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.map", "code": "@[simps]\nnoncomputable def HomologyData.map (h : S.HomologyData) (F : C \u2964 D) [F.PreservesZeroMorphisms]\n    [h.left.IsPreservedBy F] [h.right.IsPreservedBy F] :\n    (S.map F).HomologyData where\n  left := h.left.map F\n  right := h.right.map F\n  iso := F.mapIso h.iso\n  comm := by simpa only [F.map_comp] using F.congr_map h.comm", "start": [227, 1], "end": [237, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.map", "code": "@[simps]\ndef HomologyMapData.map {\u03c6 : S\u2081 \u27f6 S\u2082} {h\u2081 : S\u2081.HomologyData} {h\u2082 : S\u2082.HomologyData}\n    (\u03c8 : HomologyMapData \u03c6 h\u2081 h\u2082) (F : C \u2964 D) [F.PreservesZeroMorphisms]\n    [h\u2081.left.IsPreservedBy F] [h\u2081.right.IsPreservedBy F]\n    [h\u2082.left.IsPreservedBy F] [h\u2082.right.IsPreservedBy F] :\n    HomologyMapData (F.mapShortComplex.map \u03c6) (h\u2081.map F) (h\u2082.map F) where\n  left := \u03c8.left.map F\n  right := \u03c8.right.map F", "start": [239, 1], "end": [249, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesLeftHomologyOf", "code": "class PreservesLeftHomologyOf where\n  \n  isPreservedBy : \u2200 (h : S.LeftHomologyData), h.IsPreservedBy F", "start": [257, 1], "end": [261, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesRightHomologyOf", "code": "class PreservesRightHomologyOf where\n  \n  isPreservedBy : \u2200 (h : S.RightHomologyData), h.IsPreservedBy F", "start": [263, 1], "end": [267, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesHomology.preservesLeftHomologyOf", "code": "noncomputable instance PreservesHomology.preservesLeftHomologyOf [F.PreservesHomology] :\n    F.PreservesLeftHomologyOf S := \u27e8inferInstance\u27e9", "start": [269, 1], "end": [270, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesHomology.preservesRightHomologyOf", "code": "noncomputable instance PreservesHomology.preservesRightHomologyOf [F.PreservesHomology] :\n    F.PreservesRightHomologyOf S := \u27e8inferInstance\u27e9", "start": [272, 1], "end": [273, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesLeftHomologyOf.mk'", "code": "def PreservesLeftHomologyOf.mk' (h : S.LeftHomologyData) [h.IsPreservedBy F] :\n    F.PreservesLeftHomologyOf S where\n  isPreservedBy h' :=\n    { g := ShortComplex.LeftHomologyData.IsPreservedBy.hg h F\n      f' := by\n        have := ShortComplex.LeftHomologyData.IsPreservedBy.hf' h F\n        let e : parallelPair h.f' 0 \u2245 parallelPair h'.f' 0 :=\n          parallelPair.ext (Iso.refl _) (ShortComplex.cyclesMapIso' (Iso.refl S) h h')\n            (by simp) (by simp)\n        exact preservesColimitOfIsoDiagram F e }", "start": [277, 1], "end": [288, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.PreservesRightHomologyOf.mk'", "code": "def PreservesRightHomologyOf.mk' (h : S.RightHomologyData) [h.IsPreservedBy F] :\n    F.PreservesRightHomologyOf S where\n  isPreservedBy h' :=\n    { f := ShortComplex.RightHomologyData.IsPreservedBy.hf h F\n      g' := by\n        have := ShortComplex.RightHomologyData.IsPreservedBy.hg' h F\n        let e : parallelPair h.g' 0 \u2245 parallelPair h'.g' 0 :=\n          parallelPair.ext (ShortComplex.opcyclesMapIso' (Iso.refl S) h h') (Iso.refl _)\n            (by simp) (by simp)\n        exact preservesLimitOfIsoDiagram F e }", "start": [290, 1], "end": [301, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.isPreservedByOfPreserves", "code": "instance LeftHomologyData.isPreservedByOfPreserves [F.PreservesLeftHomologyOf S] :\n    h\u2081.IsPreservedBy F :=\n  Functor.PreservesLeftHomologyOf.isPreservedBy _", "start": [310, 1], "end": [312, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.isPreservedByOfPreserves", "code": "instance RightHomologyData.isPreservedByOfPreserves [F.PreservesRightHomologyOf S] :\n    h\u2082.IsPreservedBy F :=\n  Functor.PreservesRightHomologyOf.isPreservedBy _", "start": [314, 1], "end": [316, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasLeftHomology_of_preserves", "code": "instance hasLeftHomology_of_preserves [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.map F).HasLeftHomology :=\n  HasLeftHomology.mk' (S.leftHomologyData.map F)", "start": [320, 1], "end": [322, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasLeftHomology_of_preserves'", "code": "instance hasLeftHomology_of_preserves' [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (F.mapShortComplex.obj S).HasLeftHomology :=\n  by dsimp; infer_instance", "start": [324, 1], "end": [326, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasRightHomology_of_preserves", "code": "instance hasRightHomology_of_preserves [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (S.map F).HasRightHomology :=\n  HasRightHomology.mk' (S.rightHomologyData.map F)", "start": [328, 1], "end": [330, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasRightHomology_of_preserves'", "code": "instance hasRightHomology_of_preserves' [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (F.mapShortComplex.obj S).HasRightHomology :=\n  by dsimp; infer_instance", "start": [332, 1], "end": [334, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_preserves", "code": "instance hasHomology_of_preserves [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    (S.map F).HasHomology :=\n  HasHomology.mk' (S.homologyData.map F)", "start": [336, 1], "end": [339, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.hasHomology_of_preserves'", "code": "instance hasHomology_of_preserves' [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    (F.mapShortComplex.obj S).HasHomology :=\n  by dsimp; infer_instance", "start": [341, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.map_cyclesMap'", "code": "lemma map_cyclesMap' : F.map (ShortComplex.cyclesMap' \u03c6 hl\u2081 hl\u2082) =\n    ShortComplex.cyclesMap' (F.mapShortComplex.map \u03c6) (hl\u2081.map F) (hl\u2082.map F) := by\n  have \u03b3 : ShortComplex.LeftHomologyMapData \u03c6 hl\u2081 hl\u2082 := default\n  rw [\u03b3.cyclesMap'_eq, (\u03b3.map F).cyclesMap'_eq,  ShortComplex.LeftHomologyMapData.map_\u03c6K]", "start": [360, 1], "end": [363, 90], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.map_leftHomologyMap'", "code": "lemma map_leftHomologyMap' : F.map (ShortComplex.leftHomologyMap' \u03c6 hl\u2081 hl\u2082) =\n    ShortComplex.leftHomologyMap' (F.mapShortComplex.map \u03c6) (hl\u2081.map F) (hl\u2082.map F) := by\n  have \u03b3 : ShortComplex.LeftHomologyMapData \u03c6 hl\u2081 hl\u2082 := default\n  rw [\u03b3.leftHomologyMap'_eq, (\u03b3.map F).leftHomologyMap'_eq,\n    ShortComplex.LeftHomologyMapData.map_\u03c6H]", "start": [365, 1], "end": [369, 45], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.map_opcyclesMap'", "code": "lemma map_opcyclesMap' : F.map (ShortComplex.opcyclesMap' \u03c6 hr\u2081 hr\u2082) =\n    ShortComplex.opcyclesMap' (F.mapShortComplex.map \u03c6) (hr\u2081.map F) (hr\u2082.map F) := by\n  have \u03b3 : ShortComplex.RightHomologyMapData \u03c6 hr\u2081 hr\u2082 := default\n  rw [\u03b3.opcyclesMap'_eq, (\u03b3.map F).opcyclesMap'_eq,  ShortComplex.RightHomologyMapData.map_\u03c6Q]", "start": [377, 1], "end": [380, 95], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.map_rightHomologyMap'", "code": "lemma map_rightHomologyMap' : F.map (ShortComplex.rightHomologyMap' \u03c6 hr\u2081 hr\u2082) =\n    ShortComplex.rightHomologyMap' (F.mapShortComplex.map \u03c6) (hr\u2081.map F) (hr\u2082.map F) := by\n  have \u03b3 : ShortComplex.RightHomologyMapData \u03c6 hr\u2081 hr\u2082 := default\n  rw [\u03b3.rightHomologyMap'_eq, (\u03b3.map F).rightHomologyMap'_eq,\n    ShortComplex.RightHomologyMapData.map_\u03c6H]", "start": [382, 1], "end": [386, 46], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.map_homologyMap'", "code": "lemma HomologyData.map_homologyMap'\n    [h\u2081.left.IsPreservedBy F] [h\u2081.right.IsPreservedBy F]\n    [h\u2082.left.IsPreservedBy F] [h\u2082.right.IsPreservedBy F] :\n    F.map (ShortComplex.homologyMap' \u03c6 h\u2081 h\u2082) =\n      ShortComplex.homologyMap' (F.mapShortComplex.map \u03c6) (h\u2081.map F) (h\u2082.map F) :=\n  LeftHomologyData.map_leftHomologyMap' _ _ _ _", "start": [390, 1], "end": [395, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapCyclesIso", "code": "noncomputable def mapCyclesIso [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.map F).cycles \u2245 F.obj S.cycles :=\n  (S.leftHomologyData.map F).cyclesIso", "start": [397, 1], "end": [401, 39], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.mapLeftHomologyIso", "code": "noncomputable def mapLeftHomologyIso [S.HasLeftHomology] [F.PreservesLeftHomologyOf S] :\n    (S.map F).leftHomology \u2245 F.obj S.leftHomology :=\n  (S.leftHomologyData.map F).leftHomologyIso", "start": [403, 1], "end": [407, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.mapOpcyclesIso", "code": "noncomputable def mapOpcyclesIso [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (S.map F).opcycles \u2245 F.obj S.opcycles :=\n  (S.rightHomologyData.map F).opcyclesIso", "start": [409, 1], "end": [413, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.mapRightHomologyIso", "code": "noncomputable def mapRightHomologyIso [S.HasRightHomology] [F.PreservesRightHomologyOf S] :\n    (S.map F).rightHomology \u2245 F.obj S.rightHomology :=\n  (S.rightHomologyData.map F).rightHomologyIso", "start": [415, 1], "end": [419, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso", "code": "noncomputable def mapHomologyIso [S.HasHomology] [(S.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S] :\n    (S.map F).homology \u2245 F.obj S.homology :=\n  (S.homologyData.left.map F).homologyIso", "start": [421, 1], "end": [426, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso'", "code": "noncomputable def mapHomologyIso' [S.HasHomology] [(S.map F).HasHomology]\n    [F.PreservesRightHomologyOf S] :\n    (S.map F).homology \u2245 F.obj S.homology :=\n  (S.homologyData.right.map F).homologyIso \u226a\u226b F.mapIso S.homologyData.right.homologyIso.symm", "start": [428, 1], "end": [433, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.mapCyclesIso_eq", "code": "lemma LeftHomologyData.mapCyclesIso_eq [S.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S] :\n    S.mapCyclesIso F = (hl.map F).cyclesIso \u226a\u226b F.mapIso hl.cyclesIso.symm := by\n  ext\n  dsimp [mapCyclesIso, cyclesIso]\n  simp only [map_cyclesMap', \u2190 cyclesMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]", "start": [437, 1], "end": [443, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.mapLeftHomologyIso_eq", "code": "lemma LeftHomologyData.mapLeftHomologyIso_eq [S.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S] :\n    S.mapLeftHomologyIso F = (hl.map F).leftHomologyIso \u226a\u226b F.mapIso hl.leftHomologyIso.symm := by\n  ext\n  dsimp [mapLeftHomologyIso, leftHomologyIso]\n  simp only [map_leftHomologyMap', \u2190 leftHomologyMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]", "start": [445, 1], "end": [451, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.mapOpcyclesIso_eq", "code": "lemma RightHomologyData.mapOpcyclesIso_eq [S.HasRightHomology]\n    [F.PreservesRightHomologyOf S] :\n    S.mapOpcyclesIso F = (hr.map F).opcyclesIso \u226a\u226b F.mapIso hr.opcyclesIso.symm := by\n  ext\n  dsimp [mapOpcyclesIso, opcyclesIso]\n  simp only [map_opcyclesMap', \u2190 opcyclesMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]", "start": [453, 1], "end": [459, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.mapRightHomologyIso_eq", "code": "lemma RightHomologyData.mapRightHomologyIso_eq [S.HasRightHomology]\n    [F.PreservesRightHomologyOf S] :\n    S.mapRightHomologyIso F = (hr.map F).rightHomologyIso \u226a\u226b\n      F.mapIso hr.rightHomologyIso.symm := by\n  ext\n  dsimp [mapRightHomologyIso, rightHomologyIso]\n  simp only [map_rightHomologyMap', \u2190 rightHomologyMap'_comp, Functor.map_id, comp_id,\n    Functor.mapShortComplex_obj]", "start": [461, 1], "end": [468, 33], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.mapHomologyIso_eq", "code": "lemma LeftHomologyData.mapHomologyIso_eq [S.HasHomology]\n    [(S.map F).HasHomology] [F.PreservesLeftHomologyOf S] :\n    S.mapHomologyIso F = (hl.map F).homologyIso \u226a\u226b F.mapIso hl.homologyIso.symm := by\n  ext\n  dsimp only [mapHomologyIso, homologyIso, ShortComplex.leftHomologyIso,\n    leftHomologyMapIso', leftHomologyIso, Functor.mapIso,\n    Iso.symm, Iso.trans, Iso.refl]\n  simp only [F.map_comp, map_leftHomologyMap', \u2190 leftHomologyMap'_comp, comp_id,\n    Functor.map_id, Functor.mapShortComplex_obj]", "start": [470, 1], "end": [478, 49], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.mapHomologyIso'_eq", "code": "lemma RightHomologyData.mapHomologyIso'_eq [S.HasHomology]\n    [(S.map F).HasHomology] [F.PreservesRightHomologyOf S] :\n    S.mapHomologyIso' F = (hr.map F).homologyIso \u226a\u226b F.mapIso hr.homologyIso.symm := by\n  ext\n  dsimp only [Iso.trans, Iso.symm, Iso.refl, Functor.mapIso, mapHomologyIso', homologyIso,\n    rightHomologyIso, rightHomologyMapIso', ShortComplex.rightHomologyIso]\n  simp only [assoc, F.map_comp, map_rightHomologyMap', \u2190 rightHomologyMap'_comp_assoc]", "start": [480, 1], "end": [486, 87], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapCyclesIso_hom_naturality", "code": "@[reassoc]\nlemma mapCyclesIso_hom_naturality [S\u2081.HasLeftHomology] [S\u2082.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    cyclesMap (F.mapShortComplex.map \u03c6) \u226b (S\u2082.mapCyclesIso F).hom =\n      (S\u2081.mapCyclesIso F).hom \u226b F.map (cyclesMap \u03c6) := by\n  dsimp only [cyclesMap, mapCyclesIso, LeftHomologyData.cyclesIso, cyclesMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_cyclesMap', Functor.mapShortComplex_obj, \u2190 cyclesMap'_comp,\n    comp_id, id_comp]", "start": [488, 1], "end": [495, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapCyclesIso_inv_naturality", "code": "@[reassoc]\nlemma mapCyclesIso_inv_naturality [S\u2081.HasLeftHomology] [S\u2082.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    F.map (cyclesMap \u03c6) \u226b (S\u2082.mapCyclesIso F).inv =\n      (S\u2081.mapCyclesIso F).inv \u226b cyclesMap (F.mapShortComplex.map \u03c6) := by\n  rw [\u2190 cancel_epi (S\u2081.mapCyclesIso F).hom, \u2190 mapCyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [497, 1], "end": [503, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapLeftHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma mapLeftHomologyIso_hom_naturality [S\u2081.HasLeftHomology] [S\u2082.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    leftHomologyMap (F.mapShortComplex.map \u03c6) \u226b (S\u2082.mapLeftHomologyIso F).hom =\n      (S\u2081.mapLeftHomologyIso F).hom \u226b F.map (leftHomologyMap \u03c6) := by\n  dsimp only [leftHomologyMap, mapLeftHomologyIso, LeftHomologyData.leftHomologyIso,\n    leftHomologyMapIso', Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', Functor.mapShortComplex_obj,\n    \u2190 leftHomologyMap'_comp, comp_id, id_comp]", "start": [505, 1], "end": [513, 47], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapLeftHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma mapLeftHomologyIso_inv_naturality [S\u2081.HasLeftHomology] [S\u2082.HasLeftHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    F.map (leftHomologyMap \u03c6) \u226b (S\u2082.mapLeftHomologyIso F).inv =\n      (S\u2081.mapLeftHomologyIso F).inv \u226b leftHomologyMap (F.mapShortComplex.map \u03c6) := by\n  rw [\u2190 cancel_epi (S\u2081.mapLeftHomologyIso F).hom, \u2190 mapLeftHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [515, 1], "end": [521, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapOpcyclesIso_hom_naturality", "code": "@[reassoc]\nlemma mapOpcyclesIso_hom_naturality [S\u2081.HasRightHomology] [S\u2082.HasRightHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    opcyclesMap (F.mapShortComplex.map \u03c6) \u226b (S\u2082.mapOpcyclesIso F).hom =\n      (S\u2081.mapOpcyclesIso F).hom \u226b F.map (opcyclesMap \u03c6) := by\n  dsimp only [opcyclesMap, mapOpcyclesIso, RightHomologyData.opcyclesIso,\n    opcyclesMapIso', Iso.refl]\n  simp only [RightHomologyData.map_opcyclesMap', Functor.mapShortComplex_obj, \u2190 opcyclesMap'_comp,\n    comp_id, id_comp]", "start": [523, 1], "end": [531, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapOpcyclesIso_inv_naturality", "code": "@[reassoc]\nlemma mapOpcyclesIso_inv_naturality [S\u2081.HasRightHomology] [S\u2082.HasRightHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    F.map (opcyclesMap \u03c6) \u226b (S\u2082.mapOpcyclesIso F).inv =\n      (S\u2081.mapOpcyclesIso F).inv \u226b opcyclesMap (F.mapShortComplex.map \u03c6) := by\n  rw [\u2190 cancel_epi (S\u2081.mapOpcyclesIso F).hom, \u2190 mapOpcyclesIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [533, 1], "end": [539, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapRightHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma mapRightHomologyIso_hom_naturality [S\u2081.HasRightHomology] [S\u2082.HasRightHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    rightHomologyMap (F.mapShortComplex.map \u03c6) \u226b (S\u2082.mapRightHomologyIso F).hom =\n      (S\u2081.mapRightHomologyIso F).hom \u226b F.map (rightHomologyMap \u03c6) := by\n  dsimp only [rightHomologyMap, mapRightHomologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', Iso.refl]\n  simp only [RightHomologyData.map_rightHomologyMap', Functor.mapShortComplex_obj,\n    \u2190 rightHomologyMap'_comp, comp_id, id_comp]", "start": [541, 1], "end": [549, 48], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapRightHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma mapRightHomologyIso_inv_naturality [S\u2081.HasRightHomology] [S\u2082.HasRightHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    F.map (rightHomologyMap \u03c6) \u226b (S\u2082.mapRightHomologyIso F).inv =\n      (S\u2081.mapRightHomologyIso F).inv \u226b rightHomologyMap (F.mapShortComplex.map \u03c6) := by\n  rw [\u2190 cancel_epi (S\u2081.mapRightHomologyIso F).hom, \u2190 mapRightHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [551, 1], "end": [557, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso_hom_naturality", "code": "@[reassoc]\nlemma mapHomologyIso_hom_naturality [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [(S\u2081.map F).HasHomology] [(S\u2082.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    @homologyMap _ _ _ (S\u2081.map F) (S\u2082.map F) (F.mapShortComplex.map \u03c6) _ _ \u226b\n      (S\u2082.mapHomologyIso F).hom = (S\u2081.mapHomologyIso F).hom \u226b F.map (homologyMap \u03c6) := by\n  dsimp only [homologyMap, homologyMap', mapHomologyIso, LeftHomologyData.homologyIso,\n    LeftHomologyData.leftHomologyIso, leftHomologyMapIso', leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl]\n  simp only [LeftHomologyData.map_leftHomologyMap', \u2190 leftHomologyMap'_comp, comp_id, id_comp]", "start": [559, 1], "end": [568, 95], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso_inv_naturality", "code": "@[reassoc]\nlemma mapHomologyIso_inv_naturality [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [(S\u2081.map F).HasHomology] [(S\u2082.map F).HasHomology]\n    [F.PreservesLeftHomologyOf S\u2081] [F.PreservesLeftHomologyOf S\u2082] :\n    F.map (homologyMap \u03c6) \u226b (S\u2082.mapHomologyIso F).inv =\n      (S\u2081.mapHomologyIso F).inv \u226b\n      @homologyMap _ _ _ (S\u2081.map F) (S\u2082.map F) (F.mapShortComplex.map \u03c6) _ _ := by\n  rw [\u2190 cancel_epi (S\u2081.mapHomologyIso F).hom, \u2190 mapHomologyIso_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [570, 1], "end": [578, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso'_hom_naturality", "code": "@[reassoc]\nlemma mapHomologyIso'_hom_naturality [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [(S\u2081.map F).HasHomology] [(S\u2082.map F).HasHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    @homologyMap _ _ _ (S\u2081.map F) (S\u2082.map F) (F.mapShortComplex.map \u03c6) _ _ \u226b\n      (S\u2082.mapHomologyIso' F).hom = (S\u2081.mapHomologyIso' F).hom \u226b F.map (homologyMap \u03c6) := by\n  dsimp only [Iso.trans, Iso.symm, Functor.mapIso, mapHomologyIso']\n  simp only [\u2190 RightHomologyData.rightHomologyIso_hom_naturality_assoc _\n    ((homologyData S\u2081).right.map F) ((homologyData S\u2082).right.map F), assoc,\n    \u2190 RightHomologyData.map_rightHomologyMap', \u2190 F.map_comp,\n    RightHomologyData.rightHomologyIso_inv_naturality _\n      (homologyData S\u2081).right (homologyData S\u2082).right]", "start": [580, 1], "end": [591, 55], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso'_inv_naturality", "code": "@[reassoc]\nlemma mapHomologyIso'_inv_naturality [S\u2081.HasHomology] [S\u2082.HasHomology]\n    [(S\u2081.map F).HasHomology] [(S\u2082.map F).HasHomology]\n    [F.PreservesRightHomologyOf S\u2081] [F.PreservesRightHomologyOf S\u2082] :\n    F.map (homologyMap \u03c6) \u226b (S\u2082.mapHomologyIso' F).inv = (S\u2081.mapHomologyIso' F).inv \u226b\n      @homologyMap _ _ _ (S\u2081.map F) (S\u2082.map F) (F.mapShortComplex.map \u03c6) _ _ := by\n  rw [\u2190 cancel_epi (S\u2081.mapHomologyIso' F).hom, \u2190 mapHomologyIso'_hom_naturality_assoc,\n    Iso.hom_inv_id, comp_id, Iso.hom_inv_id_assoc]", "start": [593, 1], "end": [600, 51], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.mapHomologyIso'_eq_mapHomologyIso", "code": "lemma mapHomologyIso'_eq_mapHomologyIso [S.HasHomology] [F.PreservesLeftHomologyOf S]\n    [F.PreservesRightHomologyOf S] :\n    S.mapHomologyIso' F = S.mapHomologyIso F := by\n  ext\n  rw [S.homologyData.left.mapHomologyIso_eq F, S.homologyData.right.mapHomologyIso'_eq F]\n  dsimp only [Iso.trans, Iso.symm, Iso.refl, Functor.mapIso, RightHomologyData.homologyIso,\n    rightHomologyIso, RightHomologyData.rightHomologyIso, LeftHomologyData.homologyIso,\n    leftHomologyIso, LeftHomologyData.leftHomologyIso]\n  simp only [RightHomologyData.map_H, rightHomologyMapIso'_inv, rightHomologyMapIso'_hom, assoc,\n    Functor.map_comp, RightHomologyData.map_rightHomologyMap', Functor.mapShortComplex_obj,\n    Functor.map_id, LeftHomologyData.map_H, leftHomologyMapIso'_inv, leftHomologyMapIso'_hom,\n    LeftHomologyData.map_leftHomologyMap', \u2190 rightHomologyMap'_comp_assoc, \u2190 leftHomologyMap'_comp,\n    \u2190 leftHomologyMap'_comp_assoc, id_comp]\n  have \u03b3 : HomologyMapData (\ud835\udfd9 (S.map F)) (map S F).homologyData (S.homologyData.map F) := default\n  have eq := \u03b3.comm\n  rw [\u2190 \u03b3.left.leftHomologyMap'_eq, \u2190 \u03b3.right.rightHomologyMap'_eq] at eq\n  dsimp at eq\n  simp only [\u2190 reassoc_of% eq, \u2190 F.map_comp, Iso.hom_inv_id, F.map_id, comp_id]", "start": [604, 1], "end": [621, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyMapData.natTransApp", "code": "@[simps]\ndef LeftHomologyMapData.natTransApp (h : LeftHomologyData S) (\u03c4 : F \u27f6 G) :\n    LeftHomologyMapData (S.mapNatTrans \u03c4) (h.map F) (h.map G) where\n  \u03c6K := \u03c4.app h.K\n  \u03c6H := \u03c4.app h.H", "start": [632, 1], "end": [640, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyMapData.natTransApp", "code": "@[simps]\ndef RightHomologyMapData.natTransApp (h : RightHomologyData S) (\u03c4 : F \u27f6 G) :\n    RightHomologyMapData (S.mapNatTrans \u03c4) (h.map F) (h.map G) where\n  \u03c6Q := \u03c4.app h.Q\n  \u03c6H := \u03c4.app h.H", "start": [642, 1], "end": [650, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyMapData.natTransApp", "code": "@[simps]\ndef HomologyMapData.natTransApp (h : HomologyData S) (\u03c4 : F \u27f6 G) :\n    HomologyMapData (S.mapNatTrans \u03c4) (h.map F) (h.map G) where\n  left := LeftHomologyMapData.natTransApp h.left \u03c4\n  right := RightHomologyMapData.natTransApp h.right \u03c4", "start": [652, 1], "end": [660, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyMap_mapNatTrans", "code": "lemma homologyMap_mapNatTrans [S.HasHomology] (\u03c4 : F \u27f6 G) :\n    homologyMap (S.mapNatTrans \u03c4) =\n      (S.mapHomologyIso F).hom \u226b \u03c4.app S.homology \u226b (S.mapHomologyIso G).inv :=\n  (LeftHomologyMapData.natTransApp S.homologyData.left \u03c4).homologyMap_eq", "start": [664, 1], "end": [667, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cyclesFunctorIso", "code": "noncomputable def cyclesFunctorIso [F.PreservesHomology] :\n    F.mapShortComplex \u22d9 ShortComplex.cyclesFunctor D \u2245\n      ShortComplex.cyclesFunctor C \u22d9 F :=\n  NatIso.ofComponents (fun S => S.mapCyclesIso F)\n    (fun f => ShortComplex.mapCyclesIso_hom_naturality f F)", "start": [675, 1], "end": [682, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.leftHomologyFunctorIso", "code": "noncomputable def leftHomologyFunctorIso [F.PreservesHomology] :\n    F.mapShortComplex \u22d9 ShortComplex.leftHomologyFunctor D \u2245\n      ShortComplex.leftHomologyFunctor C \u22d9 F :=\n  NatIso.ofComponents (fun S => S.mapLeftHomologyIso F)\n    (fun f => ShortComplex.mapLeftHomologyIso_hom_naturality f F)", "start": [684, 1], "end": [691, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.opcyclesFunctorIso", "code": "noncomputable def opcyclesFunctorIso [F.PreservesHomology] :\n    F.mapShortComplex \u22d9 ShortComplex.opcyclesFunctor D \u2245\n      ShortComplex.opcyclesFunctor C \u22d9 F :=\n  NatIso.ofComponents (fun S => S.mapOpcyclesIso F)\n    (fun f => ShortComplex.mapOpcyclesIso_hom_naturality f F)", "start": [693, 1], "end": [700, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.rightHomologyFunctorIso", "code": "noncomputable def rightHomologyFunctorIso [F.PreservesHomology] :\n    F.mapShortComplex \u22d9 ShortComplex.rightHomologyFunctor D \u2245\n      ShortComplex.rightHomologyFunctor C \u22d9 F :=\n  NatIso.ofComponents (fun S => S.mapRightHomologyIso F)\n    (fun f => ShortComplex.mapRightHomologyIso_hom_naturality f F)", "start": [702, 1], "end": [709, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.homologyFunctorIso", "code": "noncomputable def homologyFunctorIso\n    [CategoryWithHomology C] [CategoryWithHomology D] [F.PreservesHomology] :\n    F.mapShortComplex \u22d9 ShortComplex.homologyFunctor D \u2245\n      ShortComplex.homologyFunctor C \u22d9 F :=\n  NatIso.ofComponents (fun S => S.mapHomologyIso F)\n    (fun f => ShortComplex.mapHomologyIso_hom_naturality f F)", "start": [713, 1], "end": [721, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/Abelian.lean", "imports": ["Mathlib/CategoryTheory/Abelian/Basic.lean", "Mathlib/Algebra/Homology/ShortComplex/Homology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.abelianImageToKernel", "code": "noncomputable def abelianImageToKernel : Abelian.image S.f \u27f6 kernel S.g :=\n  kernel.lift S.g (Abelian.image.\u03b9 S.f)\n    (by simp only [\u2190 cancel_epi (Abelian.factorThruImage S.f),\n      kernel.lift_\u03b9_assoc, zero, comp_zero])", "start": [38, 1], "end": [43, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_\u03b9", "code": "@[reassoc (attr := simp)]\nlemma abelianImageToKernel_comp_kernel_\u03b9 :\n    S.abelianImageToKernel \u226b kernel.\u03b9 S.g = Abelian.image.\u03b9 S.f :=\n  kernel.lift_\u03b9 _ _ _", "start": [45, 1], "end": [48, 22], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.abelianImageToKernel_comp_kernel_\u03b9_comp_cokernel_\u03c0", "code": "@[reassoc (attr := simp 1100)]\nlemma abelianImageToKernel_comp_kernel_\u03b9_comp_cokernel_\u03c0 :\n    S.abelianImageToKernel \u226b kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f = 0 := by\n  simp only [abelianImageToKernel_comp_kernel_\u03b9_assoc, kernel.condition]", "start": [53, 1], "end": [56, 73], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.abelianImageToKernelIsKernel", "code": "noncomputable def abelianImageToKernelIsKernel :\n    IsLimit (KernelFork.of\u03b9 S.abelianImageToKernel\n      S.abelianImageToKernel_comp_kernel_\u03b9_comp_cokernel_\u03c0) :=\n  KernelFork.IsLimit.of\u03b9 _ _\n    (fun k hk => kernel.lift _ (k \u226b kernel.\u03b9 S.g) (by rw [assoc, hk]))\n    (fun k hk => by simp only [\u2190 cancel_mono (kernel.\u03b9 S.g), assoc,\n      abelianImageToKernel_comp_kernel_\u03b9, kernel.lift_\u03b9])\n    (fun k hk b hb => by simp only [\u2190 cancel_mono S.abelianImageToKernel,\n      \u2190 cancel_mono (kernel.\u03b9 S.g), hb, assoc, abelianImageToKernel_comp_kernel_\u03b9, kernel.lift_\u03b9])", "start": [58, 1], "end": [67, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian", "code": "@[simps]\nnoncomputable def ofAbelian : S.LeftHomologyData := by\n  let \u03b3 := kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f\n  let f' := kernel.lift S.g S.f S.zero\n  have hf' : f' = kernel.lift \u03b3 f' (by simp) \u226b kernel.\u03b9 \u03b3 := by rw [kernel.lift_\u03b9]\n  have w\u03c0 : f' \u226b cokernel.\u03c0 (kernel.\u03b9 \u03b3) = 0 := by\n    rw [hf']\n    simp only [assoc, cokernel.condition, comp_zero]\n  let e : Abelian.image S.f \u2245 kernel \u03b3 :=\n    IsLimit.conePointUniqueUpToIso S.abelianImageToKernelIsKernel (limit.isLimit _)\n  have he : e.hom \u226b kernel.\u03b9 \u03b3 = S.abelianImageToKernel :=\n    IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingParallelPair.zero\n  have fac : f' = Abelian.factorThruImage S.f \u226b e.hom \u226b kernel.\u03b9 \u03b3 := by\n    rw [hf', he]\n    simp only [kernel.lift_\u03b9, abelianImageToKernel, \u2190 cancel_mono (kernel.\u03b9 S.g), assoc]\n  have h\u03c0 : IsColimit (CokernelCofork.of\u03c0 _ w\u03c0) :=\n    CokernelCofork.IsColimit.of\u03c0 _ _\n    (fun x hx => cokernel.desc _ x (by\n      simpa only [\u2190 cancel_epi e.hom, \u2190 cancel_epi (Abelian.factorThruImage S.f),\n        comp_zero, fac, assoc] using hx))\n    (fun x hx => cokernel.\u03c0_desc _ _ _)\n    (fun x hx b hb => coequalizer.hom_ext (by simp only [hb, cokernel.\u03c0_desc]))\n  exact\n    { K := kernel S.g,\n      H := Abelian.coimage (kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f)\n      i := kernel.\u03b9 _,\n      \u03c0 := cokernel.\u03c0 _\n      wi := kernel.condition _\n      hi := kernelIsKernel _\n      w\u03c0 := w\u03c0\n      h\u03c0 := h\u03c0 }", "start": [71, 1], "end": [103, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.cokernelToAbelianCoimage", "code": "noncomputable def cokernelToAbelianCoimage : cokernel S.f \u27f6 Abelian.coimage S.g :=\n  cokernel.desc S.f (Abelian.coimage.\u03c0 S.g) (by\n    simp only [\u2190 cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n      cokernel.\u03c0_desc, zero, zero_comp])", "start": [107, 1], "end": [112, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.cokernel_\u03c0_comp_cokernelToAbelianCoimage", "code": "@[reassoc (attr := simp)]\nlemma cokernel_\u03c0_comp_cokernelToAbelianCoimage :\n    cokernel.\u03c0 S.f \u226b S.cokernelToAbelianCoimage = Abelian.coimage.\u03c0 S.g :=\n  cokernel.\u03c0_desc _ _ _", "start": [114, 1], "end": [117, 24], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.kernel_\u03b9_comp_cokernel_\u03c0_comp_cokernelToAbelianCoimage", "code": "lemma kernel_\u03b9_comp_cokernel_\u03c0_comp_cokernelToAbelianCoimage :\n    (kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f) \u226b S.cokernelToAbelianCoimage = 0 := by simp", "start": [122, 1], "end": [123, 80], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.ShortComplex.cokernelToAbelianCoimageIsCokernel", "code": "noncomputable def cokernelToAbelianCoimageIsCokernel :\n    IsColimit (CokernelCofork.of\u03c0 S.cokernelToAbelianCoimage\n      S.kernel_\u03b9_comp_cokernel_\u03c0_comp_cokernelToAbelianCoimage) :=\n  CokernelCofork.IsColimit.of\u03c0 _ _\n    (fun k hk => cokernel.desc _ (cokernel.\u03c0 S.f \u226b k) (by simpa only [assoc] using hk))\n    (fun k hk => by simp only [\u2190 cancel_epi (cokernel.\u03c0 S.f),\n        cokernel_\u03c0_comp_cokernelToAbelianCoimage_assoc, cokernel.\u03c0_desc])\n    (fun k hk b hb => by\n      simp only [\u2190 cancel_epi S.cokernelToAbelianCoimage, \u2190 cancel_epi (cokernel.\u03c0 S.f), hb,\n        cokernel_\u03c0_comp_cokernelToAbelianCoimage_assoc, cokernel.\u03c0_desc])", "start": [125, 1], "end": [135, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.RightHomologyData.ofAbelian", "code": "@[simps]\nnoncomputable def ofAbelian : S.RightHomologyData := by\n  let \u03b3 := kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f\n  let g' := cokernel.desc S.f S.g S.zero\n  have hg' : g' = cokernel.\u03c0 \u03b3 \u226b cokernel.desc \u03b3 g' (by simp) := by rw [cokernel.\u03c0_desc]\n  have w\u03b9 : kernel.\u03b9 (cokernel.\u03c0 \u03b3) \u226b g' = 0 := by rw [hg', kernel.condition_assoc, zero_comp]\n  let e : cokernel \u03b3 \u2245 Abelian.coimage S.g :=\n    IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) S.cokernelToAbelianCoimageIsCokernel\n  have he : cokernel.\u03c0 \u03b3 \u226b e.hom = S.cokernelToAbelianCoimage :=\n    IsColimit.comp_coconePointUniqueUpToIso_hom _ _ WalkingParallelPair.one\n  have fac : g' = cokernel.\u03c0 \u03b3 \u226b e.hom \u226b Abelian.factorThruCoimage S.g := by\n    rw [hg', reassoc_of% he]\n    simp only [cokernel.\u03c0_desc, \u2190 cancel_epi (cokernel.\u03c0 S.f),\n      cokernel_\u03c0_comp_cokernelToAbelianCoimage_assoc]\n  have h\u03b9 : IsLimit (KernelFork.of\u03b9 _ w\u03b9) :=\n    KernelFork.IsLimit.of\u03b9 _ _\n      (fun x hx => kernel.lift _ x (by\n        simpa only [\u2190 cancel_mono e.hom, \u2190 cancel_mono (Abelian.factorThruCoimage S.g), assoc,\n          zero_comp, fac] using hx))\n      (fun x hx => kernel.lift_\u03b9 _ _ _)\n      (fun x hx b hb => equalizer.hom_ext (by simp only [hb, kernel.lift_\u03b9]))\n  exact\n    { Q := cokernel S.f,\n      H := Abelian.image (kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f)\n      p := cokernel.\u03c0 _\n      \u03b9 := kernel.\u03b9 _\n      wp := cokernel.condition _\n      hp := cokernelIsCokernel _\n      w\u03b9 := w\u03b9\n      h\u03b9 := h\u03b9 }", "start": [139, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.HomologyData.ofAbelian", "code": "noncomputable def HomologyData.ofAbelian : S.HomologyData where\n  left := LeftHomologyData.ofAbelian S\n  right := RightHomologyData.ofAbelian S\n  iso := Abelian.coimageIsoImage (kernel.\u03b9 S.g \u226b cokernel.\u03c0 S.f)", "start": [174, 1], "end": [178, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.categoryWithHomology_of_abelian", "code": "instance _root_.CategoryTheory.categoryWithHomology_of_abelian :\n    CategoryWithHomology C where\n  hasHomology S := HasHomology.mk' (HomologyData.ofAbelian S)", "start": [180, 1], "end": [182, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/ShortComplex/FunctorEquivalence.lean", "imports": ["Mathlib/Algebra/Homology/ShortComplex/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ShortComplex.FunctorEquivalence.functor", "code": "@[simps]\ndef functor : ShortComplex (J \u2964 C) \u2964 J \u2964 ShortComplex C where\n  obj S :=\n    { obj := fun j => S.map ((evaluation J C).obj j)\n      map := fun f => S.mapNatTrans ((evaluation J C).map f) }\n  map \u03c6 :=\n    { app := fun j => ((evaluation J C).obj j).mapShortComplex.map \u03c6 }", "start": [29, 1], "end": [36, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.FunctorEquivalence.inverse", "code": "@[simps]\ndef inverse : (J \u2964 ShortComplex C) \u2964 ShortComplex (J \u2964 C) where\n  obj F :=\n    { f := whiskerLeft F \u03c0\u2081To\u03c0\u2082\n      g := whiskerLeft F \u03c0\u2082To\u03c0\u2083\n      zero := by aesop_cat }\n  map \u03c6 := Hom.mk (whiskerRight \u03c6 \u03c0\u2081) (whiskerRight \u03c6 \u03c0\u2082) (whiskerRight \u03c6 \u03c0\u2083)\n    (by aesop_cat) (by aesop_cat)", "start": [38, 1], "end": [46, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.FunctorEquivalence.unitIso", "code": "@[simps!]\ndef unitIso : \ud835\udfed _ \u2245 functor J C \u22d9 inverse J C :=\n  NatIso.ofComponents (fun _ => isoMk\n    (NatIso.ofComponents (fun _ => Iso.refl _) (by aesop_cat))\n    (NatIso.ofComponents (fun _ => Iso.refl _) (by aesop_cat))\n    (NatIso.ofComponents (fun _ => Iso.refl _) (by aesop_cat))\n    (by aesop_cat) (by aesop_cat)) (by aesop_cat)", "start": [48, 1], "end": [56, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.FunctorEquivalence.counitIso", "code": "@[simps!]\ndef counitIso : inverse J C \u22d9 functor J C \u2245 \ud835\udfed _:=\n  NatIso.ofComponents (fun _ => NatIso.ofComponents\n    (fun _ => isoMk (Iso.refl _) (Iso.refl _) (Iso.refl _)\n      (by aesop_cat) (by aesop_cat)) (by aesop_cat)) (by aesop_cat)", "start": [58, 1], "end": [64, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ShortComplex.functorEquivalence", "code": "@[simps]\ndef functorEquivalence : ShortComplex (J \u2964 C) \u224c J \u2964 ShortComplex C where\n  functor := FunctorEquivalence.functor J C\n  inverse := FunctorEquivalence.inverse J C\n  unitIso := FunctorEquivalence.unitIso J C\n  counitIso := FunctorEquivalence.counitIso J C", "start": [68, 1], "end": [74, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Module/Cardinality.lean", "imports": ["Mathlib/SetTheory/Cardinal/CountableCover.lean", "Mathlib/Topology/Perfect.lean", "Mathlib/Data/Real/Cardinality.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Analysis/SpecificLimits/Normed.lean"], "premises": [{"full_name": "continuum_le_cardinal_of_nontriviallyNormedField", "code": "theorem continuum_le_cardinal_of_nontriviallyNormedField\n    (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] : \ud835\udd20 \u2264 #\ud835\udd5c", "start": [27, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "continuum_le_cardinal_of_module", "code": "theorem continuum_le_cardinal_of_module\n    (\ud835\udd5c : Type u) (E : Type v) [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c]\n    [AddCommGroup E] [Module \ud835\udd5c E] [Nontrivial E] : \ud835\udd20 \u2264 #E", "start": [46, 1], "end": [53, 53], "kind": "commanddeclaration"}, {"full_name": "cardinal_eq_of_mem_nhds_zero", "code": "lemma cardinal_eq_of_mem_nhds_zero\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]\n    [TopologicalSpace E] [ContinuousSMul \ud835\udd5c E] {s : Set E} (hs : s \u2208 \ud835\udcdd (0 : E)) : #s = #E := by\n  \n  obtain \u27e8c, hc\u27e9 : \u2203 x : \ud835\udd5c , 1 < \u2016x\u2016 := NormedField.exists_lt_norm \ud835\udd5c 1\n  have cn_ne : \u2200 n, c^n \u2260 0 := by\n    intro n\n    apply pow_ne_zero\n    rintro rfl\n    simp only [norm_zero] at hc\n    exact lt_irrefl _ (hc.trans zero_lt_one)\n  have A : \u2200 (x : E), \u2200\u1da0 n in (atTop : Filter \u2115), x \u2208 c^n \u2022 s := by\n    intro x\n    have : Tendsto (fun n \u21a6 (c^n) \u207b\u00b9 \u2022 x) atTop (\ud835\udcdd ((0 : \ud835\udd5c) \u2022 x)) := by\n      have : Tendsto (fun n \u21a6 (c^n)\u207b\u00b9) atTop (\ud835\udcdd 0) := by\n        simp_rw [\u2190 inv_pow]\n        apply tendsto_pow_atTop_nhds_0_of_norm_lt_1\n        rw [norm_inv]\n        exact inv_lt_one hc\n      exact Tendsto.smul_const this x\n    rw [zero_smul] at this\n    filter_upwards [this hs] with n (hn : (c ^ n)\u207b\u00b9 \u2022 x \u2208 s)\n    exact (mem_smul_set_iff_inv_smul_mem\u2080 (cn_ne n) _ _).2 hn\n  have B : \u2200 n, #(c^n \u2022 s) = #s := by\n    intro n\n    have : c^n \u2022 s \u2243 s :=\n    { toFun := fun x \u21a6 \u27e8(c^n)\u207b\u00b9 \u2022 x.1, (mem_smul_set_iff_inv_smul_mem\u2080 (cn_ne n) _ _).1 x.2\u27e9\n      invFun := fun x \u21a6 \u27e8(c^n) \u2022 x.1, smul_mem_smul_set x.2\u27e9\n      left_inv := fun x \u21a6 by simp [smul_smul, mul_inv_cancel (cn_ne n)]\n      right_inv := fun x \u21a6 by simp [smul_smul, inv_mul_cancel (cn_ne n)] }\n    exact Cardinal.mk_congr this\n  apply (Cardinal.mk_of_countable_eventually_mem A B).symm", "start": [55, 1], "end": [92, 59], "kind": "mathlibtacticlemma"}, {"full_name": "cardinal_eq_of_mem_nhds", "code": "theorem cardinal_eq_of_mem_nhds\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\n    {s : Set E} {x : E} (hs : s \u2208 \ud835\udcdd x) : #s = #E", "start": [94, 1], "end": [105, 15], "kind": "commanddeclaration"}, {"full_name": "cardinal_eq_of_isOpen", "code": "theorem cardinal_eq_of_isOpen\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E] {s : Set E}\n    (hs : IsOpen s) (h's : s.Nonempty) : #s = #E", "start": [107, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "continuum_le_cardinal_of_isOpen", "code": "theorem continuum_le_cardinal_of_isOpen\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] [AddCommGroup E]\n    [Module \ud835\udd5c E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\n    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : \ud835\udd20 \u2264 #s", "start": [116, 1], "end": [122, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.dense_compl", "code": "theorem Set.Countable.dense_compl\n    {E : Type u} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] [AddCommGroup E]\n    [Module \ud835\udd5c E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\n    {s : Set E} (hs : s.Countable) : Dense s\u1d9c", "start": [124, 1], "end": [138, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Circumcenter.lean", "imports": ["Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "Mathlib/Tactic/DeriveFintype.lean", "Mathlib/LinearAlgebra/AffineSpace/FiniteDimensional.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanGeometry.dist_eq_iff_dist_orthogonalProjection_eq", "code": "theorem dist_eq_iff_dist_orthogonalProjection_eq {s : AffineSubspace \u211d P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p1 p2 : P} (p3 : P) (hp1 : p1 \u2208 s) (hp2 : p2 \u2208 s) :\n    dist p1 p3 = dist p2 p3 \u2194\n      dist p1 (orthogonalProjection s p3) = dist p2 (orthogonalProjection s p3)", "start": [48, 1], "end": [58, 7], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_set_eq_iff_dist_orthogonalProjection_eq", "code": "theorem dist_set_eq_iff_dist_orthogonalProjection_eq {s : AffineSubspace \u211d P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hps : ps \u2286 s) (p : P) :\n    (Set.Pairwise ps fun p1 p2 => dist p1 p = dist p2 p) \u2194\n      Set.Pairwise ps fun p1 p2 =>\n        dist p1 (orthogonalProjection s p) = dist p2 (orthogonalProjection s p)", "start": [61, 1], "end": [71, 88], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_dist_eq_iff_exists_dist_orthogonalProjection_eq", "code": "theorem exists_dist_eq_iff_exists_dist_orthogonalProjection_eq {s : AffineSubspace \u211d P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hps : ps \u2286 s) (p : P) :\n    (\u2203 r, \u2200 p1 \u2208 ps, dist p1 p = r) \u2194 \u2203 r, \u2200 p1 \u2208 ps, dist p1 \u2191(orthogonalProjection s p) = r", "start": [74, 1], "end": [83, 10], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.existsUnique_dist_eq_of_insert", "code": "theorem existsUnique_dist_eq_of_insert {s : AffineSubspace \u211d P}\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps \u2286 s)\n    (hp : p \u2209 s) (hu : \u2203! cs : Sphere P, cs.center \u2208 s \u2227 ps \u2286 (cs : Set P)) :\n    \u2203! cs\u2082 : Sphere P,\n      cs\u2082.center \u2208 affineSpan \u211d (insert p (s : Set P)) \u2227 insert p ps \u2286 (cs\u2082 : Set P)", "start": [86, 1], "end": [184, 9], "kind": "commanddeclaration"}, {"full_name": "AffineIndependent.existsUnique_dist_eq", "code": "theorem _root_.AffineIndependent.existsUnique_dist_eq {\u03b9 : Type*} [hne : Nonempty \u03b9] [Finite \u03b9]\n    {p : \u03b9 \u2192 P} (ha : AffineIndependent \u211d p) :\n    \u2203! cs : Sphere P, cs.center \u2208 affineSpan \u211d (Set.range p) \u2227 Set.range p \u2286 (cs : Set P)", "start": [187, 1], "end": [237, 11], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumsphere", "code": "def circumsphere {n : \u2115} (s : Simplex \u211d P n) : Sphere P :=\n  s.Independent.existsUnique_dist_eq.choose", "start": [251, 1], "end": [253, 44], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumsphere_unique_dist_eq", "code": "theorem circumsphere_unique_dist_eq {n : \u2115} (s : Simplex \u211d P n) :\n    (s.circumsphere.center \u2208 affineSpan \u211d (Set.range s.points) \u2227\n        Set.range s.points \u2286 s.circumsphere) \u2227\n      \u2200 cs : Sphere P,\n        cs.center \u2208 affineSpan \u211d (Set.range s.points) \u2227 Set.range s.points \u2286 cs \u2192\n          cs = s.circumsphere", "start": [256, 1], "end": [263, 49], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter", "code": "def circumcenter {n : \u2115} (s : Simplex \u211d P n) : P :=\n  s.circumsphere.center", "start": [266, 1], "end": [268, 24], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumradius", "code": "def circumradius {n : \u2115} (s : Simplex \u211d P n) : \u211d :=\n  s.circumsphere.radius", "start": [271, 1], "end": [273, 24], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumsphere_center", "code": "@[simp]\ntheorem circumsphere_center {n : \u2115} (s : Simplex \u211d P n) : s.circumsphere.center = s.circumcenter", "start": [276, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumsphere_radius", "code": "@[simp]\ntheorem circumsphere_radius {n : \u2115} (s : Simplex \u211d P n) : s.circumsphere.radius = s.circumradius", "start": [282, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_mem_affineSpan", "code": "theorem circumcenter_mem_affineSpan {n : \u2115} (s : Simplex \u211d P n) :\n    s.circumcenter \u2208 affineSpan \u211d (Set.range s.points)", "start": [288, 1], "end": [291, 36], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.dist_circumcenter_eq_circumradius", "code": "@[simp]\ntheorem dist_circumcenter_eq_circumradius {n : \u2115} (s : Simplex \u211d P n) (i : Fin (n + 1)) :\n    dist (s.points i) s.circumcenter = s.circumradius", "start": [294, 1], "end": [299, 85], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.mem_circumsphere", "code": "theorem mem_circumsphere {n : \u2115} (s : Simplex \u211d P n) (i : Fin (n + 1)) :\n    s.points i \u2208 s.circumsphere", "start": [302, 1], "end": [305, 40], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.dist_circumcenter_eq_circumradius'", "code": "@[simp]\ntheorem dist_circumcenter_eq_circumradius' {n : \u2115} (s : Simplex \u211d P n) :\n    \u2200 i, dist s.circumcenter (s.points i) = s.circumradius", "start": [308, 1], "end": [315, 46], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.eq_circumcenter_of_dist_eq", "code": "theorem eq_circumcenter_of_dist_eq {n : \u2115} (s : Simplex \u211d P n) {p : P}\n    (hp : p \u2208 affineSpan \u211d (Set.range s.points)) {r : \u211d} (hr : \u2200 i, dist (s.points i) p = r) :\n    p = s.circumcenter", "start": [318, 1], "end": [330, 12], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.eq_circumradius_of_dist_eq", "code": "theorem eq_circumradius_of_dist_eq {n : \u2115} (s : Simplex \u211d P n) {p : P}\n    (hp : p \u2208 affineSpan \u211d (Set.range s.points)) {r : \u211d} (hr : \u2200 i, dist (s.points i) p = r) :\n    r = s.circumradius", "start": [333, 1], "end": [345, 12], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumradius_nonneg", "code": "theorem circumradius_nonneg {n : \u2115} (s : Simplex \u211d P n) : 0 \u2264 s.circumradius", "start": [348, 1], "end": [350, 54], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumradius_pos", "code": "theorem circumradius_pos {n : \u2115} (s : Simplex \u211d P (n + 1)) : 0 < s.circumradius", "start": [353, 1], "end": [361, 19], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_eq_point", "code": "theorem circumcenter_eq_point (s : Simplex \u211d P 0) (i : Fin 1) : s.circumcenter = s.points i", "start": [364, 1], "end": [371, 42], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_eq_centroid", "code": "theorem circumcenter_eq_centroid (s : Simplex \u211d P 1) :\n    s.circumcenter = Finset.univ.centroid \u211d s.points", "start": [374, 1], "end": [391, 36], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumsphere_reindex", "code": "@[simp]\ntheorem circumsphere_reindex {m n : \u2115} (s : Simplex \u211d P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) :\n    (s.reindex e).circumsphere = s.circumsphere", "start": [394, 1], "end": [400, 56], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_reindex", "code": "@[simp]\ntheorem circumcenter_reindex {m n : \u2115} (s : Simplex \u211d P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) :\n    (s.reindex e).circumcenter = s.circumcenter", "start": [403, 1], "end": [406, 99], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumradius_reindex", "code": "@[simp]\ntheorem circumradius_reindex {m n : \u2115} (s : Simplex \u211d P m) (e : Fin (m + 1) \u2243 Fin (n + 1)) :\n    (s.reindex e).circumradius = s.circumradius", "start": [409, 1], "end": [412, 99], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.orthogonalProjectionSpan", "code": "def orthogonalProjectionSpan {n : \u2115} (s : Simplex \u211d P n) :\n    P \u2192\u1d43[\u211d] affineSpan \u211d (Set.range s.points) :=\n  orthogonalProjection (affineSpan \u211d (Set.range s.points))", "start": [417, 1], "end": [420, 59], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.orthogonalProjection_vadd_smul_vsub_orthogonalProjection", "code": "theorem orthogonalProjection_vadd_smul_vsub_orthogonalProjection {n : \u2115} (s : Simplex \u211d P n)\n    {p1 : P} (p2 : P) (r : \u211d) (hp : p1 \u2208 affineSpan \u211d (Set.range s.points)) :\n    s.orthogonalProjectionSpan (r \u2022 (p2 -\u1d65 s.orthogonalProjectionSpan p2 : V) +\u1d65 p1) = \u27e8p1, hp\u27e9", "start": [423, 1], "end": [430, 83], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection", "code": "theorem coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection {n : \u2115} {r\u2081 : \u211d}\n    (s : Simplex \u211d P n) {p p\u2081o : P} (hp\u2081o : p\u2081o \u2208 affineSpan \u211d (Set.range s.points)) :\n    \u2191(s.orthogonalProjectionSpan (r\u2081 \u2022 (p -\u1d65 \u2191(s.orthogonalProjectionSpan p)) +\u1d65 p\u2081o)) = p\u2081o", "start": [433, 1], "end": [436, 95], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq", "code": "theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : \u2115}\n    (s : Simplex \u211d P n) {p1 : P} (p2 : P) (hp1 : p1 \u2208 affineSpan \u211d (Set.range s.points)) :\n    dist p1 p2 * dist p1 p2 =\n      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +\n        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2)", "start": [439, 1], "end": [449, 64], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.dist_circumcenter_sq_eq_sq_sub_circumradius", "code": "theorem dist_circumcenter_sq_eq_sq_sub_circumradius {n : \u2115} {r : \u211d} (s : Simplex \u211d P n) {p\u2081 : P}\n    (h\u2081 : \u2200 i : Fin (n + 1), dist (s.points i) p\u2081 = r)\n    (h\u2081' : \u2191(s.orthogonalProjectionSpan p\u2081) = s.circumcenter)\n    (h : s.points 0 \u2208 affineSpan \u211d (Set.range s.points)) :\n    dist p\u2081 s.circumcenter * dist p\u2081 s.circumcenter = r * r - s.circumradius * s.circumradius", "start": [452, 1], "end": [459, 92], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.orthogonalProjection_eq_circumcenter_of_exists_dist_eq", "code": "theorem orthogonalProjection_eq_circumcenter_of_exists_dist_eq {n : \u2115} (s : Simplex \u211d P n) {p : P}\n    (hr : \u2203 r, \u2200 i, dist (s.points i) p = r) :\n    \u2191(s.orthogonalProjectionSpan p) = s.circumcenter", "start": [462, 1], "end": [478, 99], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.orthogonalProjection_eq_circumcenter_of_dist_eq", "code": "theorem orthogonalProjection_eq_circumcenter_of_dist_eq {n : \u2115} (s : Simplex \u211d P n) {p : P} {r : \u211d}\n    (hr : \u2200 i, dist (s.points i) p = r) : \u2191(s.orthogonalProjectionSpan p) = s.circumcenter", "start": [481, 1], "end": [486, 67], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.orthogonalProjection_circumcenter", "code": "theorem orthogonalProjection_circumcenter {n : \u2115} (s : Simplex \u211d P n) {fs : Finset (Fin (n + 1))}\n    {m : \u2115} (h : fs.card = m + 1) :\n    \u2191((s.face h).orthogonalProjectionSpan s.circumcenter) = (s.face h).circumcenter", "start": [489, 1], "end": [497, 62], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_eq_of_range_eq", "code": "theorem circumcenter_eq_of_range_eq {n : \u2115} {s\u2081 s\u2082 : Simplex \u211d P n}\n    (h : Set.range s\u2081.points = Set.range s\u2082.points) : s\u2081.circumcenter = s\u2082.circumcenter", "start": [500, 1], "end": [511, 44], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.PointsWithCircumcenterIndex", "code": "inductive PointsWithCircumcenterIndex (n : \u2115)\n  | point_index : Fin (n + 1) \u2192 PointsWithCircumcenterIndex n\n  | circumcenter_index : PointsWithCircumcenterIndex n\n  deriving Fintype", "start": [514, 1], "end": [522, 19], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointsWithCircumcenterIndexInhabited", "code": "instance pointsWithCircumcenterIndexInhabited (n : \u2115) : Inhabited (PointsWithCircumcenterIndex n) :=\n  \u27e8circumcenter_index\u27e9", "start": [527, 1], "end": [528, 23], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointIndexEmbedding", "code": "def pointIndexEmbedding (n : \u2115) : Fin (n + 1) \u21aa PointsWithCircumcenterIndex n :=\n  \u27e8fun i => point_index i, fun _ _ h => by injection h\u27e9", "start": [531, 1], "end": [533, 56], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_pointsWithCircumcenter", "code": "theorem sum_pointsWithCircumcenter {\u03b1 : Type*} [AddCommMonoid \u03b1] {n : \u2115}\n    (f : PointsWithCircumcenterIndex n \u2192 \u03b1) :\n    \u2211 i, f i = (\u2211 i : Fin (n + 1), f (point_index i)) + f circumcenter_index", "start": [536, 1], "end": [550, 14], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointsWithCircumcenter", "code": "def pointsWithCircumcenter {n : \u2115} (s : Simplex \u211d P n) : PointsWithCircumcenterIndex n \u2192 P\n  | point_index i => s.points i\n  | circumcenter_index => s.circumcenter", "start": [553, 1], "end": [556, 41], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointsWithCircumcenter_point", "code": "@[simp]\ntheorem pointsWithCircumcenter_point {n : \u2115} (s : Simplex \u211d P n) (i : Fin (n + 1)) :\n    s.pointsWithCircumcenter (point_index i) = s.points i", "start": [559, 1], "end": [564, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointsWithCircumcenter_eq_circumcenter", "code": "@[simp]\ntheorem pointsWithCircumcenter_eq_circumcenter {n : \u2115} (s : Simplex \u211d P n) :\n    s.pointsWithCircumcenter circumcenter_index = s.circumcenter", "start": [567, 1], "end": [572, 6], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.pointWeightsWithCircumcenter", "code": "def pointWeightsWithCircumcenter {n : \u2115} (i : Fin (n + 1)) : PointsWithCircumcenterIndex n \u2192 \u211d\n  | point_index j => if j = i then 1 else 0\n  | circumcenter_index => 0", "start": [575, 1], "end": [579, 28], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_pointWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_pointWeightsWithCircumcenter {n : \u2115} (i : Fin (n + 1)) :\n    \u2211 j, pointWeightsWithCircumcenter i j = 1", "start": [582, 1], "end": [588, 9], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.point_eq_affineCombination_of_pointsWithCircumcenter", "code": "theorem point_eq_affineCombination_of_pointsWithCircumcenter {n : \u2115} (s : Simplex \u211d P n)\n    (i : Fin (n + 1)) :\n    s.points i =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination \u211d s.pointsWithCircumcenter\n        (pointWeightsWithCircumcenter i)", "start": [591, 1], "end": [606, 8], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.centroidWeightsWithCircumcenter", "code": "def centroidWeightsWithCircumcenter {n : \u2115} (fs : Finset (Fin (n + 1))) :\n    PointsWithCircumcenterIndex n \u2192 \u211d\n  | point_index i => if i \u2208 fs then (card fs : \u211d)\u207b\u00b9 else 0\n  | circumcenter_index => 0", "start": [609, 1], "end": [614, 28], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_centroidWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_centroidWeightsWithCircumcenter {n : \u2115} {fs : Finset (Fin (n + 1))} (h : fs.Nonempty) :\n    \u2211 i, centroidWeightsWithCircumcenter fs i = 1", "start": [617, 1], "end": [623, 9], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter", "code": "theorem centroid_eq_affineCombination_of_pointsWithCircumcenter {n : \u2115} (s : Simplex \u211d P n)\n    (fs : Finset (Fin (n + 1))) :\n    fs.centroid \u211d s.points =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination \u211d s.pointsWithCircumcenter\n        (centroidWeightsWithCircumcenter fs)", "start": [626, 1], "end": [639, 8], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenterWeightsWithCircumcenter", "code": "def circumcenterWeightsWithCircumcenter (n : \u2115) : PointsWithCircumcenterIndex n \u2192 \u211d\n  | point_index _ => 0\n  | circumcenter_index => 1", "start": [642, 1], "end": [645, 28], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_circumcenterWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_circumcenterWeightsWithCircumcenter (n : \u2115) :\n    \u2211 i, circumcenterWeightsWithCircumcenter n i = 1", "start": [648, 1], "end": [654, 9], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter", "code": "theorem circumcenter_eq_affineCombination_of_pointsWithCircumcenter {n : \u2115} (s : Simplex \u211d P n) :\n    s.circumcenter =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination \u211d s.pointsWithCircumcenter\n        (circumcenterWeightsWithCircumcenter n)", "start": [657, 1], "end": [665, 28], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reflectionCircumcenterWeightsWithCircumcenter", "code": "def reflectionCircumcenterWeightsWithCircumcenter {n : \u2115} (i\u2081 i\u2082 : Fin (n + 1)) :\n    PointsWithCircumcenterIndex n \u2192 \u211d\n  | point_index i => if i = i\u2081 \u2228 i = i\u2082 then 1 else 0\n  | circumcenter_index => -1", "start": [668, 1], "end": [673, 29], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.sum_reflectionCircumcenterWeightsWithCircumcenter", "code": "@[simp]\ntheorem sum_reflectionCircumcenterWeightsWithCircumcenter {n : \u2115} {i\u2081 i\u2082 : Fin (n + 1)}\n    (h : i\u2081 \u2260 i\u2082) : \u2211 i, reflectionCircumcenterWeightsWithCircumcenter i\u2081 i\u2082 i = 1", "start": [676, 1], "end": [684, 63], "kind": "commanddeclaration"}, {"full_name": "Affine.Simplex.reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter", "code": "theorem reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter {n : \u2115}\n    (s : Simplex \u211d P n) {i\u2081 i\u2082 : Fin (n + 1)} (h : i\u2081 \u2260 i\u2082) :\n    reflection (affineSpan \u211d (s.points '' {i\u2081, i\u2082})) s.circumcenter =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination \u211d s.pointsWithCircumcenter\n        (reflectionCircumcenterWeightsWithCircumcenter i\u2081 i\u2082)", "start": [687, 1], "end": [715, 11], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_iff_exists_mem_of_complete", "code": "theorem cospherical_iff_exists_mem_of_complete {s : AffineSubspace \u211d P} {ps : Set P} (h : ps \u2286 s)\n    [Nonempty s] [HasOrthogonalProjection s.direction] :\n    Cospherical ps \u2194 \u2203 center \u2208 s, \u2203 radius : \u211d, \u2200 p \u2208 ps, dist p center = radius", "start": [729, 1], "end": [739, 36], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cospherical_iff_exists_mem_of_finiteDimensional", "code": "theorem cospherical_iff_exists_mem_of_finiteDimensional {s : AffineSubspace \u211d P} {ps : Set P}\n    (h : ps \u2286 s) [Nonempty s] [FiniteDimensional \u211d s.direction] :\n    Cospherical ps \u2194 \u2203 center \u2208 s, \u2203 radius : \u211d, \u2200 p \u2208 ps, dist p center = radius", "start": [742, 1], "end": [749, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumradius_eq_of_cospherical_subset", "code": "theorem exists_circumradius_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P}\n    (h : ps \u2286 s) [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction]\n    (hd : finrank \u211d s.direction = n) (hc : Cospherical ps) :\n    \u2203 r : \u211d, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumradius = r", "start": [752, 1], "end": [770, 63], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumradius_eq_of_cospherical_subset", "code": "theorem circumradius_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P} (h : ps \u2286 s)\n    [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = n)\n    (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n} (hsx\u2081 : Set.range sx\u2081.points \u2286 ps)\n    (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) : sx\u2081.circumradius = sx\u2082.circumradius", "start": [773, 1], "end": [780, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumradius_eq_of_cospherical", "code": "theorem exists_circumradius_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) :\n    \u2203 r : \u211d, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumradius = r", "start": [783, 1], "end": [791, 26], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumradius_eq_of_cospherical", "code": "theorem circumradius_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n}\n    (hsx\u2081 : Set.range sx\u2081.points \u2286 ps) (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) :\n    sx\u2081.circumradius = sx\u2082.circumradius", "start": [794, 1], "end": [801, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumcenter_eq_of_cospherical_subset", "code": "theorem exists_circumcenter_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P}\n    (h : ps \u2286 s) [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction]\n    (hd : finrank \u211d s.direction = n) (hc : Cospherical ps) :\n    \u2203 c : P, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumcenter = c", "start": [804, 1], "end": [822, 63], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumcenter_eq_of_cospherical_subset", "code": "theorem circumcenter_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P} (h : ps \u2286 s)\n    [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = n)\n    (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n} (hsx\u2081 : Set.range sx\u2081.points \u2286 ps)\n    (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) : sx\u2081.circumcenter = sx\u2082.circumcenter", "start": [825, 1], "end": [832, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumcenter_eq_of_cospherical", "code": "theorem exists_circumcenter_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) :\n    \u2203 c : P, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumcenter = c", "start": [835, 1], "end": [843, 26], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumcenter_eq_of_cospherical", "code": "theorem circumcenter_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n}\n    (hsx\u2081 : Set.range sx\u2081.points \u2286 ps) (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) :\n    sx\u2081.circumcenter = sx\u2082.circumcenter", "start": [846, 1], "end": [853, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumsphere_eq_of_cospherical_subset", "code": "theorem exists_circumsphere_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P}\n    (h : ps \u2286 s) [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction]\n    (hd : finrank \u211d s.direction = n) (hc : Cospherical ps) :\n    \u2203 c : Sphere P, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumsphere = c", "start": [856, 1], "end": [864, 71], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumsphere_eq_of_cospherical_subset", "code": "theorem circumsphere_eq_of_cospherical_subset {s : AffineSubspace \u211d P} {ps : Set P} (h : ps \u2286 s)\n    [Nonempty s] {n : \u2115} [FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = n)\n    (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n} (hsx\u2081 : Set.range sx\u2081.points \u2286 ps)\n    (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) : sx\u2081.circumsphere = sx\u2082.circumsphere", "start": [867, 1], "end": [874, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.exists_circumsphere_eq_of_cospherical", "code": "theorem exists_circumsphere_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) :\n    \u2203 c : Sphere P, \u2200 sx : Simplex \u211d P n, Set.range sx.points \u2286 ps \u2192 sx.circumsphere = c", "start": [877, 1], "end": [885, 26], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.circumsphere_eq_of_cospherical", "code": "theorem circumsphere_eq_of_cospherical {ps : Set P} {n : \u2115} [FiniteDimensional \u211d V]\n    (hd : finrank \u211d V = n) (hc : Cospherical ps) {sx\u2081 sx\u2082 : Simplex \u211d P n}\n    (hsx\u2081 : Set.range sx\u2081.points \u2286 ps) (hsx\u2082 : Set.range sx\u2082.points \u2286 ps) :\n    sx\u2081.circumsphere = sx\u2082.circumsphere", "start": [888, 1], "end": [895, 32], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.eq_or_eq_reflection_of_dist_eq", "code": "theorem eq_or_eq_reflection_of_dist_eq {n : \u2115} {s : Simplex \u211d P n} {p p\u2081 p\u2082 : P} {r : \u211d}\n    (hp\u2081 : p\u2081 \u2208 affineSpan \u211d (insert p (Set.range s.points)))\n    (hp\u2082 : p\u2082 \u2208 affineSpan \u211d (insert p (Set.range s.points))) (h\u2081 : \u2200 i, dist (s.points i) p\u2081 = r)\n    (h\u2082 : \u2200 i, dist (s.points i) p\u2082 = r) :\n    p\u2081 = p\u2082 \u2228 p\u2081 = reflection (affineSpan \u211d (Set.range s.points)) p\u2082", "start": [898, 1], "end": [947, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Geometry/Euclidean/Angle/Oriented/RightAngle.lean", "imports": ["Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "Mathlib/Geometry/Euclidean/Angle/Unoriented/RightAngle.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Orientation.oangle_add_right_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_right_eq_arccos_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle x (x + y) = Real.arccos (\u2016x\u2016 / \u2016x + y\u2016)", "start": [36, 1], "end": [43, 51], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_left_eq_arccos_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x + y) y = Real.arccos (\u2016y\u2016 / \u2016x + y\u2016)", "start": [46, 1], "end": [51, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_right_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_right_eq_arcsin_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle x (x + y) = Real.arcsin (\u2016y\u2016 / \u2016x + y\u2016)", "start": [54, 1], "end": [62, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_left_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_left_eq_arcsin_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x + y) y = Real.arcsin (\u2016x\u2016 / \u2016x + y\u2016)", "start": [65, 1], "end": [70, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_right_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_right_eq_arctan_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle x (x + y) = Real.arctan (\u2016y\u2016 / \u2016x\u2016)", "start": [73, 1], "end": [80, 94], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_left_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_add_left_eq_arctan_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x + y) y = Real.arctan (\u2016x\u2016 / \u2016y\u2016)", "start": [83, 1], "end": [88, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_add_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (o.oangle x (x + y)) = \u2016x\u2016 / \u2016x + y\u2016", "start": [91, 1], "end": [97, 101], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_add_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (o.oangle (x + y) y) = \u2016y\u2016 / \u2016x + y\u2016", "start": [100, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_add_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (o.oangle x (x + y)) = \u2016y\u2016 / \u2016x + y\u2016", "start": [108, 1], "end": [115, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_add_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (o.oangle (x + y) y) = \u2016x\u2016 / \u2016x + y\u2016", "start": [118, 1], "end": [123, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_add_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (o.oangle x (x + y)) = \u2016y\u2016 / \u2016x\u2016", "start": [126, 1], "end": [132, 101], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_add_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (o.oangle (x + y) y) = \u2016x\u2016 / \u2016y\u2016", "start": [135, 1], "end": [140, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.cos (o.oangle x (x + y)) * \u2016x + y\u2016 = \u2016x\u2016", "start": [143, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.cos (o.oangle (x + y) y) * \u2016x + y\u2016 = \u2016y\u2016", "start": [154, 1], "end": [160, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.sin (o.oangle x (x + y)) * \u2016x + y\u2016 = \u2016y\u2016", "start": [163, 1], "end": [171, 51], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.sin (o.oangle (x + y) y) * \u2016x + y\u2016 = \u2016x\u2016", "start": [174, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_add_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.tan (o.oangle x (x + y)) * \u2016x\u2016 = \u2016y\u2016", "start": [183, 1], "end": [192, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_add_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.tan (o.oangle (x + y) y) * \u2016y\u2016 = \u2016x\u2016", "start": [195, 1], "end": [201, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_cos_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_cos_oangle_add_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.cos (o.oangle x (x + y)) = \u2016x + y\u2016", "start": [204, 1], "end": [213, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_cos_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_cos_oangle_add_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.cos (o.oangle (x + y) y) = \u2016x + y\u2016", "start": [216, 1], "end": [222, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_sin_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_sin_oangle_add_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.sin (o.oangle x (x + y)) = \u2016x + y\u2016", "start": [225, 1], "end": [234, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_sin_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_sin_oangle_add_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.sin (o.oangle (x + y) y) = \u2016x + y\u2016", "start": [237, 1], "end": [243, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_tan_oangle_add_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.tan (o.oangle x (x + y)) = \u2016x\u2016", "start": [246, 1], "end": [255, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_tan_oangle_add_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_tan_oangle_add_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.tan (o.oangle (x + y) y) = \u2016y\u2016", "start": [258, 1], "end": [264, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_right_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_right_eq_arccos_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle y (y - x) = Real.arccos (\u2016y\u2016 / \u2016y - x\u2016)", "start": [267, 1], "end": [274, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_left_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_left_eq_arccos_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x - y) x = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016)", "start": [277, 1], "end": [281, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_right_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_right_eq_arcsin_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle y (y - x) = Real.arcsin (\u2016x\u2016 / \u2016y - x\u2016)", "start": [284, 1], "end": [292, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_left_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_left_eq_arcsin_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x - y) x = Real.arcsin (\u2016y\u2016 / \u2016x - y\u2016)", "start": [295, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_right_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_right_eq_arctan_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle y (y - x) = Real.arctan (\u2016x\u2016 / \u2016y\u2016)", "start": [302, 1], "end": [309, 99], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_left_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_sub_left_eq_arctan_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    o.oangle (x - y) x = Real.arctan (\u2016y\u2016 / \u2016x\u2016)", "start": [312, 1], "end": [316, 66], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (o.oangle y (y - x)) = \u2016y\u2016 / \u2016y - x\u2016", "start": [319, 1], "end": [327, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (o.oangle (x - y) x) = \u2016x\u2016 / \u2016x - y\u2016", "start": [330, 1], "end": [335, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (o.oangle y (y - x)) = \u2016x\u2016 / \u2016y - x\u2016", "start": [338, 1], "end": [347, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (o.oangle (x - y) x) = \u2016y\u2016 / \u2016x - y\u2016", "start": [350, 1], "end": [355, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (o.oangle y (y - x)) = \u2016x\u2016 / \u2016y\u2016", "start": [358, 1], "end": [366, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V} (h : o.oangle x y = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (o.oangle (x - y) x) = \u2016y\u2016 / \u2016x\u2016", "start": [369, 1], "end": [374, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.cos (o.oangle y (y - x)) * \u2016y - x\u2016 = \u2016y\u2016", "start": [377, 1], "end": [385, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.cos_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.cos (o.oangle (x - y) x) * \u2016x - y\u2016 = \u2016x\u2016", "start": [388, 1], "end": [393, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.sin (o.oangle y (y - x)) * \u2016y - x\u2016 = \u2016x\u2016", "start": [396, 1], "end": [404, 55], "kind": "commanddeclaration"}, {"full_name": "Orientation.sin_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.sin (o.oangle (x - y) x) * \u2016x - y\u2016 = \u2016y\u2016", "start": [407, 1], "end": [412, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_sub_right_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.tan (o.oangle y (y - x)) * \u2016y\u2016 = \u2016x\u2016", "start": [415, 1], "end": [424, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_sub_left_mul_norm_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : Real.Angle.tan (o.oangle (x - y) x) * \u2016x\u2016 = \u2016y\u2016", "start": [427, 1], "end": [432, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_cos_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_cos_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.cos (o.oangle y (y - x)) = \u2016y - x\u2016", "start": [435, 1], "end": [444, 60], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_cos_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_cos_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.cos (o.oangle (x - y) x) = \u2016x - y\u2016", "start": [447, 1], "end": [452, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_sin_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_sin_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.sin (o.oangle y (y - x)) = \u2016y - x\u2016", "start": [455, 1], "end": [464, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_sin_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_sin_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.sin (o.oangle (x - y) x) = \u2016x - y\u2016", "start": [467, 1], "end": [472, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_tan_oangle_sub_right_of_oangle_eq_pi_div_two", "code": "theorem norm_div_tan_oangle_sub_right_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016x\u2016 / Real.Angle.tan (o.oangle y (y - x)) = \u2016y\u2016", "start": [475, 1], "end": [484, 59], "kind": "commanddeclaration"}, {"full_name": "Orientation.norm_div_tan_oangle_sub_left_of_oangle_eq_pi_div_two", "code": "theorem norm_div_tan_oangle_sub_left_of_oangle_eq_pi_div_two {x y : V}\n    (h : o.oangle x y = \u2191(\u03c0 / 2)) : \u2016y\u2016 / Real.Angle.tan (o.oangle (x - y) x) = \u2016x\u2016", "start": [487, 1], "end": [492, 69], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_right_smul_rotation_pi_div_two", "code": "theorem oangle_add_right_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    o.oangle x (x + r \u2022 o.rotation (\u03c0 / 2 : \u211d) x) = Real.arctan r", "start": [495, 1], "end": [517, 39], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_add_left_smul_rotation_pi_div_two", "code": "theorem oangle_add_left_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    o.oangle (x + r \u2022 o.rotation (\u03c0 / 2 : \u211d) x) (r \u2022 o.rotation (\u03c0 / 2 : \u211d) x)\n      = Real.arctan r\u207b\u00b9", "start": [520, 1], "end": [531, 15], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_right_smul_rotation_pi_div_two", "code": "theorem tan_oangle_add_right_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    Real.Angle.tan (o.oangle x (x + r \u2022 o.rotation (\u03c0 / 2 : \u211d) x)) = r", "start": [534, 1], "end": [538, 90], "kind": "commanddeclaration"}, {"full_name": "Orientation.tan_oangle_add_left_smul_rotation_pi_div_two", "code": "theorem tan_oangle_add_left_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    Real.Angle.tan (o.oangle (x + r \u2022 o.rotation (\u03c0 / 2 : \u211d) x) (r \u2022 o.rotation (\u03c0 / 2 : \u211d) x)) =\n      r\u207b\u00b9", "start": [541, 1], "end": [546, 92], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_right_smul_rotation_pi_div_two", "code": "theorem oangle_sub_right_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    o.oangle (r \u2022 o.rotation (\u03c0 / 2 : \u211d) x) (r \u2022 o.rotation (\u03c0 / 2 : \u211d) x - x)\n      = Real.arctan r\u207b\u00b9", "start": [549, 1], "end": [558, 21], "kind": "commanddeclaration"}, {"full_name": "Orientation.oangle_sub_left_smul_rotation_pi_div_two", "code": "theorem oangle_sub_left_smul_rotation_pi_div_two {x : V} (h : x \u2260 0) (r : \u211d) :\n    o.oangle (x - r \u2022 o.rotation (\u03c0 / 2 : \u211d) x) x = Real.arctan r", "start": [561, 1], "end": [572, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_right_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_right_eq_arccos_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2082 p\u2083 p\u2081 = Real.arccos (dist p\u2083 p\u2082 / dist p\u2081 p\u2083)", "start": [584, 1], "end": [589, 92], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_left_eq_arccos_of_oangle_eq_pi_div_two", "code": "theorem oangle_left_eq_arccos_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2083 p\u2081 p\u2082 = Real.arccos (dist p\u2081 p\u2082 / dist p\u2081 p\u2083)", "start": [592, 1], "end": [598, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_right_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_right_eq_arcsin_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2082 p\u2083 p\u2081 = Real.arcsin (dist p\u2081 p\u2082 / dist p\u2081 p\u2083)", "start": [601, 1], "end": [607, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_left_eq_arcsin_of_oangle_eq_pi_div_two", "code": "theorem oangle_left_eq_arcsin_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2083 p\u2081 p\u2082 = Real.arcsin (dist p\u2083 p\u2082 / dist p\u2081 p\u2083)", "start": [610, 1], "end": [617, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_right_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_right_eq_arctan_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2082 p\u2083 p\u2081 = Real.arctan (dist p\u2081 p\u2082 / dist p\u2083 p\u2082)", "start": [620, 1], "end": [626, 44], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.oangle_left_eq_arctan_of_oangle_eq_pi_div_two", "code": "theorem oangle_left_eq_arctan_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    \u2221 p\u2083 p\u2081 p\u2082 = Real.arctan (dist p\u2083 p\u2082 / dist p\u2081 p\u2082)", "start": [629, 1], "end": [635, 43], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082 / dist p\u2081 p\u2083", "start": [638, 1], "end": [643, 86], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.cos (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2081 p\u2082 / dist p\u2081 p\u2083", "start": [646, 1], "end": [652, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2081 p\u2083", "start": [655, 1], "end": [661, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.sin (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2083 p\u2082 / dist p\u2081 p\u2083", "start": [664, 1], "end": [671, 21], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2083 p\u2082", "start": [674, 1], "end": [679, 86], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) :\n    Real.Angle.tan (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2083 p\u2082 / dist p\u2081 p\u2082", "start": [682, 1], "end": [687, 90], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_oangle_right_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_right_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.cos (\u2221 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2083 p\u2082", "start": [690, 1], "end": [696, 95], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.cos_oangle_left_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem cos_oangle_left_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.cos (\u2221 p\u2083 p\u2081 p\u2082) * dist p\u2081 p\u2083 = dist p\u2081 p\u2082", "start": [699, 1], "end": [705, 99], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_oangle_right_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_right_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.sin (\u2221 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2081 p\u2082", "start": [708, 1], "end": [714, 95], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.sin_oangle_left_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem sin_oangle_left_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.sin (\u2221 p\u2083 p\u2081 p\u2082) * dist p\u2081 p\u2083 = dist p\u2083 p\u2082", "start": [717, 1], "end": [723, 99], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_oangle_right_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_right_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.tan (\u2221 p\u2082 p\u2083 p\u2081) * dist p\u2083 p\u2082 = dist p\u2081 p\u2082", "start": [726, 1], "end": [733, 53], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.tan_oangle_left_mul_dist_of_oangle_eq_pi_div_two", "code": "theorem tan_oangle_left_mul_dist_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : Real.Angle.tan (\u2221 p\u2083 p\u2081 p\u2082) * dist p\u2081 p\u2082 = dist p\u2083 p\u2082", "start": [736, 1], "end": [743, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_cos_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem dist_div_cos_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2083 p\u2082 / Real.Angle.cos (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083", "start": [746, 1], "end": [753, 53], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_cos_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem dist_div_cos_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2081 p\u2082 / Real.Angle.cos (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2081 p\u2083", "start": [756, 1], "end": [763, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_sin_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem dist_div_sin_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2081 p\u2082 / Real.Angle.sin (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083", "start": [766, 1], "end": [773, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_sin_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem dist_div_sin_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2083 p\u2082 / Real.Angle.sin (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2081 p\u2083", "start": [776, 1], "end": [783, 53], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_tan_oangle_right_of_oangle_eq_pi_div_two", "code": "theorem dist_div_tan_oangle_right_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2081 p\u2082 / Real.Angle.tan (\u2221 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082", "start": [786, 1], "end": [793, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanGeometry.dist_div_tan_oangle_left_of_oangle_eq_pi_div_two", "code": "theorem dist_div_tan_oangle_left_of_oangle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P}\n    (h : \u2221 p\u2081 p\u2082 p\u2083 = \u2191(\u03c0 / 2)) : dist p\u2083 p\u2082 / Real.Angle.tan (\u2221 p\u2083 p\u2081 p\u2082) = dist p\u2081 p\u2082", "start": [796, 1], "end": [803, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Jacobson.lean", "imports": ["Mathlib/RingTheory/JacobsonIdeal.lean", "Mathlib/RingTheory/Ideal/Over.lean", "Mathlib/RingTheory/Localization/Away/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ideal.IsJacobson", "code": "class IsJacobson (R : Type*) [CommRing R] : Prop where\n  out' : \u2200 I : Ideal R, I.IsRadical \u2192 I.jacobson = I", "start": [51, 1], "end": [55, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_iff", "code": "theorem isJacobson_iff {R} [CommRing R] :\n    IsJacobson R \u2194 \u2200 I : Ideal R, I.IsRadical \u2192 I.jacobson = I", "start": [58, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsJacobson.out", "code": "theorem IsJacobson.out {R} [CommRing R] :\n    IsJacobson R \u2192 \u2200 {I : Ideal R}, I.IsRadical \u2192 I.jacobson = I", "start": [63, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_iff_prime_eq", "code": "theorem isJacobson_iff_prime_eq : IsJacobson R \u2194 \u2200 P : Ideal R, IsPrime P \u2192 P.jacobson = P", "start": [68, 1], "end": [78, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_iff_sInf_maximal", "code": "theorem isJacobson_iff_sInf_maximal : IsJacobson R \u2194 \u2200 {I : Ideal R}, I.IsPrime \u2192\n    \u2203 M : Set (Ideal R), (\u2200 J \u2208 M, IsMaximal J \u2228 J = \u22a4) \u2227 I = sInf M", "start": [81, 1], "end": [87, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_iff_sInf_maximal'", "code": "theorem isJacobson_iff_sInf_maximal' : IsJacobson R \u2194 \u2200 {I : Ideal R}, I.IsPrime \u2192\n    \u2203 M : Set (Ideal R), (\u2200 J \u2208 M, \u2200 (K : Ideal R), J < K \u2192 K = \u22a4) \u2227 I = sInf M", "start": [90, 1], "end": [93, 83], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_eq_jacobson", "code": "theorem radical_eq_jacobson [H : IsJacobson R] (I : Ideal R) : I.radical = I.jacobson", "start": [96, 1], "end": [98, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_field", "code": "instance (priority := 100) isJacobson_field {K : Type*} [Field K] : IsJacobson K :=\n  \u27e8fun I _ => Or.recOn (eq_bot_or_top I)\n    (fun h => le_antisymm (sInf_le \u27e8le_rfl, h.symm \u25b8 bot_isMaximal\u27e9) (h.symm \u25b8 bot_le)) fun h =>\n      by rw [h, jacobson_eq_top_iff]\u27e9", "start": [101, 1], "end": [105, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_of_surjective", "code": "theorem isJacobson_of_surjective [H : IsJacobson R] :\n    (\u2203 f : R \u2192+* S, Function.Surjective \u2191f) \u2192 IsJacobson S", "start": [108, 1], "end": [117, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_quotient", "code": "instance (priority := 100) isJacobson_quotient [IsJacobson R] : IsJacobson (R \u29f8 I) :=\n  isJacobson_of_surjective \u27e8Quotient.mk I, by\n    rintro \u27e8x\u27e9\n    use x\n    rfl\u27e9", "start": [120, 1], "end": [124, 9], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_iso", "code": "theorem isJacobson_iso (e : R \u2243+* S) : IsJacobson R \u2194 IsJacobson S", "start": [127, 1], "end": [129, 81], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_of_isIntegral", "code": "theorem isJacobson_of_isIntegral [Algebra R S] (hRS : Algebra.IsIntegral R S) (hR : IsJacobson R) :\n    IsJacobson S", "start": [132, 1], "end": [148, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_of_isIntegral'", "code": "theorem isJacobson_of_isIntegral' (f : R \u2192+* S) (hf : f.IsIntegral) (hR : IsJacobson R) :\n    IsJacobson S", "start": [151, 1], "end": [152, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.disjoint_powers_iff_not_mem", "code": "theorem disjoint_powers_iff_not_mem (hI : I.IsRadical) :\n    Disjoint (Submonoid.powers y : Set R) \u2191I \u2194 y \u2209 I.1", "start": [165, 1], "end": [170, 59], "kind": "commanddeclaration"}, {"full_name": "Ideal.isMaximal_iff_isMaximal_disjoint", "code": "theorem isMaximal_iff_isMaximal_disjoint [H : IsJacobson R] (J : Ideal S) :\n    J.IsMaximal \u2194 (comap (algebraMap R S) J).IsMaximal \u2227 y \u2209 Ideal.comap (algebraMap R S) J", "start": [175, 1], "end": [205, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.isMaximal_of_isMaximal_disjoint", "code": "theorem isMaximal_of_isMaximal_disjoint [IsJacobson R] (I : Ideal R) (hI : I.IsMaximal)\n    (hy : y \u2209 I) : (map (algebraMap R S) I).IsMaximal", "start": [210, 1], "end": [219, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.orderIsoOfMaximal", "code": "def orderIsoOfMaximal [IsJacobson R] :\n    { p : Ideal S // p.IsMaximal } \u2243o { p : Ideal R // p.IsMaximal \u2227 y \u2209 p } where\n  toFun p := \u27e8Ideal.comap (algebraMap R S) p.1, (isMaximal_iff_isMaximal_disjoint S y p.1).1 p.2\u27e9\n  invFun p := \u27e8Ideal.map (algebraMap R S) p.1, isMaximal_of_isMaximal_disjoint y p.1 p.2.1 p.2.2\u27e9\n  left_inv J := Subtype.eq (map_comap (powers y) S J)\n  right_inv I := Subtype.eq (comap_map_of_isPrime_disjoint _ _ I.1 (IsMaximal.isPrime I.2.1)\n    ((disjoint_powers_iff_not_mem y I.2.1.isPrime.isRadical).2 I.2.2))\n  map_rel_iff' {I I'} := \u27e8fun h => show I.val \u2264 I'.val from\n    map_comap (powers y) S I.val \u25b8 map_comap (powers y) S I'.val \u25b8 Ideal.map_mono h,\n    fun h _ hx => h hx\u27e9", "start": [222, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.isJacobson_localization", "code": "theorem isJacobson_localization [H : IsJacobson R] : IsJacobson S", "start": [236, 1], "end": [264, 74], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.Subring.mem_closure_image_of", "code": "lemma Subring.mem_closure_image_of {S T : Type*} [CommRing S] [CommRing T] (g : S \u2192+* T)\n    (u : Set S) (x : S) (hx : x \u2208 Subring.closure u) : g x \u2208 Subring.closure (g '' u) := by\n  rw [Subring.mem_closure] at hx \u22a2\n  intro T\u2081 h\u2081\n  rw [\u2190 Subring.mem_comap]\n  apply hx\n  simp only [Subring.coe_comap, \u2190 Set.image_subset_iff, SetLike.mem_coe]\n  exact h\u2081", "start": [277, 1], "end": [284, 11], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.Polynomial.mem_closure_X_union_C", "code": "lemma mem_closure_X_union_C {R : Type*} [Ring R] (p : R[X]) :\n    p \u2208 Subring.closure (insert X {f | f.degree \u2264 0} : Set R[X]) := by\n  refine' Polynomial.induction_on p _ _ _\n  \u00b7 intro r\n    apply Subring.subset_closure\n    apply Set.mem_insert_of_mem\n    exact degree_C_le\n  \u00b7 intros p1 p2 h1 h2\n    exact Subring.add_mem _ h1 h2\n  \u00b7 intros n r hr\n    rw [pow_succ', \u2190 mul_assoc]\n    apply Subring.mul_mem _ hr\n    apply Subring.subset_closure\n    apply Set.mem_insert", "start": [287, 1], "end": [300, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.Polynomial.isIntegral_isLocalization_polynomial_quotient", "code": "theorem isIntegral_isLocalization_polynomial_quotient\n    (P : Ideal R[X]) (pX : R[X]) (hpX : pX \u2208 P) [Algebra (R \u29f8 P.comap (C : R \u2192+* R[X])) R\u2098]\n    [IsLocalization.Away (pX.map (Quotient.mk (P.comap (C : R \u2192+* R[X])))).leadingCoeff R\u2098]\n    [Algebra (R[X] \u29f8 P) S\u2098] [IsLocalization ((Submonoid.powers (pX.map (Quotient.mk (P.comap\n      (C : R \u2192+* R[X])))).leadingCoeff).map (quotientMap P C le_rfl) : Submonoid (R[X] \u29f8 P)) S\u2098] :\n    (IsLocalization.map S\u2098 (quotientMap P C le_rfl) (Submonoid.powers (pX.map (Quotient.mk (P.comap\n      (C : R \u2192+* R[X])))).leadingCoeff).le_comap_map : R\u2098 \u2192+* S\u2098).IsIntegral", "start": [306, 1], "end": [363, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.jacobson_bot_of_integral_localization", "code": "theorem jacobson_bot_of_integral_localization {R : Type*} [CommRing R] [IsDomain R] [IsJacobson R]\n    (R\u2098 S\u2098 : Type*) [CommRing R\u2098] [CommRing S\u2098] (\u03c6 : R \u2192+* S) (h\u03c6 : Function.Injective \u2191\u03c6) (x : R)\n    (hx : x \u2260 0) [Algebra R R\u2098] [IsLocalization.Away x R\u2098] [Algebra S S\u2098]\n    [IsLocalization ((Submonoid.powers x).map \u03c6 : Submonoid S) S\u2098]\n    (h\u03c6' :\n      RingHom.IsIntegral (IsLocalization.map S\u2098 \u03c6 (Submonoid.powers x).le_comap_map : R\u2098 \u2192+* S\u2098)) :\n    (\u22a5 : Ideal S).jacobson = (\u22a5 : Ideal S)", "start": [366, 1], "end": [409, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isJacobson_polynomial_of_domain", "code": "private theorem isJacobson_polynomial_of_domain (R : Type*) [CommRing R] [IsDomain R]\n    [hR : IsJacobson R] (P : Ideal R[X]) [IsPrime P] (hP : \u2200 x : R, C x \u2208 P \u2192 x = 0) :\n    P.jacobson = P", "start": [412, 1], "end": [433, 92], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isJacobson_polynomial_of_isJacobson", "code": "theorem isJacobson_polynomial_of_isJacobson (hR : IsJacobson R) : IsJacobson R[X]", "start": [435, 1], "end": [461, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isJacobson_polynomial_iff_isJacobson", "code": "theorem isJacobson_polynomial_iff_isJacobson : IsJacobson R[X] \u2194 IsJacobson R", "start": [464, 1], "end": [468, 71], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isMaximal_comap_C_of_isMaximal", "code": "theorem isMaximal_comap_C_of_isMaximal [Nontrivial R] (hP' : \u2200 x : R, C x \u2208 P \u2192 x = 0) :\n    IsMaximal (comap (C : R \u2192+* R[X]) P : Ideal R)", "start": [482, 1], "end": [523, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.quotient_mk_comp_C_isIntegral_of_jacobson'", "code": "private theorem quotient_mk_comp_C_isIntegral_of_jacobson' [Nontrivial R] (hR : IsJacobson R)\n    (hP' : \u2200 x : R, C x \u2208 P \u2192 x = 0) : ((Quotient.mk P).comp C : R \u2192+* R[X] \u29f8 P).IsIntegral", "start": [527, 1], "end": [560, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.quotient_mk_comp_C_isIntegral_of_jacobson", "code": "theorem quotient_mk_comp_C_isIntegral_of_jacobson :\n    ((Quotient.mk P).comp C : R \u2192+* R[X] \u29f8 P).IsIntegral", "start": [562, 1], "end": [586, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isMaximal_comap_C_of_isJacobson", "code": "theorem isMaximal_comap_C_of_isJacobson : (P.comap (C : R \u2192+* R[X])).IsMaximal", "start": [590, 1], "end": [593, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.Polynomial.isMaximal_comap_C_of_isJacobson'", "code": "lemma isMaximal_comap_C_of_isJacobson' {P : Ideal R[X]} (hP : IsMaximal P) :\n    (P.comap (C : R \u2192+* R[X])).IsMaximal := by\n  haveI := hP\n  exact isMaximal_comap_C_of_isJacobson P", "start": [597, 1], "end": [600, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.Polynomial.comp_C_integral_of_surjective_of_jacobson", "code": "theorem comp_C_integral_of_surjective_of_jacobson {S : Type*} [Field S] (f : R[X] \u2192+* S)\n    (hf : Function.Surjective \u2191f) : (f.comp C).IsIntegral", "start": [602, 1], "end": [612, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.isJacobson_MvPolynomial_fin", "code": "theorem isJacobson_MvPolynomial_fin {R : Type u} [CommRing R] [H : IsJacobson R] :\n    \u2200 n : \u2115, IsJacobson (MvPolynomial (Fin n) R)", "start": [624, 1], "end": [629, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.isJacobson", "code": "instance isJacobson {R : Type*} [CommRing R] {\u03b9 : Type*} [Finite \u03b9] [IsJacobson R] :\n    IsJacobson (MvPolynomial \u03b9 R) := by\n  cases nonempty_fintype \u03b9\n  haveI := Classical.decEq \u03b9\n  let e := Fintype.equivFin \u03b9\n  rw [isJacobson_iso (renameEquiv R e).toRingEquiv]\n  exact isJacobson_MvPolynomial_fin _", "start": [632, 1], "end": [642, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.C\u2090", "code": "private noncomputable def C\u2090 (R : Type u) (S : Type v)\n    [CommRing R] [CommRing S] [Algebra R S] : S \u2192\u2090[R] S[X] :=\n  { Polynomial.C with commutes' := fun r => by rfl }", "start": [650, 1], "end": [653, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.aux_IH", "code": "private lemma aux_IH {R : Type u} {S : Type v} {T : Type w}\n  [CommRing R] [CommRing S] [CommRing T] [IsJacobson S] [Algebra R S] [Algebra R T]\n  (IH : \u2200 (Q : Ideal S), (IsMaximal Q) \u2192 RingHom.IsIntegral (algebraMap R (S \u29f8 Q)))\n  (v : S[X] \u2243\u2090[R] T) (P : Ideal T) (hP : P.IsMaximal) :\n  RingHom.IsIntegral (algebraMap R (T \u29f8 P)) := by\n  let Q := P.comap v.toAlgHom.toRingHom\n  have hw : Ideal.map v Q = P := map_comap_of_surjective v v.surjective P\n  haveI hQ : IsMaximal Q := comap_isMaximal_of_surjective _ v.surjective\n  let w : (S[X] \u29f8 Q) \u2243\u2090[R] (T \u29f8 P) := Ideal.quotientEquivAlg Q P v hw.symm\n  let Q' := Q.comap (Polynomial.C)\n  let w' : (S \u29f8 Q') \u2192\u2090[R] (S[X] \u29f8 Q) := Ideal.quotientMap\u2090 Q (C\u2090 R S) le_rfl\n  have h_eq : algebraMap R (T \u29f8 P) =\n    w.toRingEquiv.toRingHom.comp (w'.toRingHom.comp (algebraMap R (S \u29f8 Q'))) := by\n    ext r\n    simp only [AlgEquiv.toAlgHom_eq_coe, AlgHom.toRingHom_eq_coe, AlgEquiv.toRingEquiv_eq_coe,\n      RingEquiv.toRingHom_eq_coe, AlgHom.comp_algebraMap_of_tower, coe_comp, coe_coe,\n      AlgEquiv.coe_ringEquiv, Function.comp_apply, AlgEquiv.commutes]\n  rw [h_eq]\n  apply RingHom.isIntegral_trans\n  apply RingHom.isIntegral_trans\n  \u00b7 apply IH\n    apply Polynomial.isMaximal_comap_C_of_isJacobson'\n    exact hQ\n  \u00b7 suffices : w'.toRingHom = Ideal.quotientMap Q (Polynomial.C) le_rfl\n    \u00b7 rw [this]\n      rw [isIntegral_quotientMap_iff _]\n      apply Polynomial.quotient_mk_comp_C_isIntegral_of_jacobson\n    \u00b7 rfl\n  \u00b7 apply RingHom.isIntegral_of_surjective\n    exact w.surjective", "start": [655, 1], "end": [684, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Ideal.MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson'", "code": "private theorem quotient_mk_comp_C_isIntegral_of_jacobson' {R : Type*} [CommRing R] [IsJacobson R]\n    (P : Ideal (MvPolynomial (Fin n) R)) (hP : P.IsMaximal) :\n    RingHom.IsIntegral (algebraMap R (MvPolynomial (Fin n) R \u29f8 P))", "start": [686, 1], "end": [693, 49], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.quotient_mk_comp_C_isIntegral_of_jacobson", "code": "theorem quotient_mk_comp_C_isIntegral_of_jacobson {R : Type*} [CommRing R] [IsJacobson R]\n    (P : Ideal (MvPolynomial (Fin n) R)) [hP : P.IsMaximal] :\n    RingHom.IsIntegral (RingHom.comp (Quotient.mk P) (MvPolynomial.C))", "start": [695, 1], "end": [700, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.MvPolynomial.comp_C_integral_of_surjective_of_jacobson", "code": "theorem comp_C_integral_of_surjective_of_jacobson {R : Type*} [CommRing R] [IsJacobson R]\n    {\u03c3 : Type*} [Finite \u03c3] {S : Type*} [Field S] (f : MvPolynomial \u03c3 R \u2192+* S)\n    (hf : Function.Surjective \u2191f) : (f.comp C).IsIntegral", "start": [704, 1], "end": [726, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/MvPolynomial.lean", "imports": ["Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "Mathlib/RingTheory/MvPolynomial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/MvPolynomial/CommRing.lean"], "premises": [{"full_name": "MvPolynomial.quotient_mk_comp_C_injective", "code": "theorem quotient_mk_comp_C_injective (I : Ideal (MvPolynomial \u03c3 K)) (hI : I \u2260 \u22a4) :\n    Function.Injective ((Ideal.Quotient.mk I).comp MvPolynomial.C)", "start": [38, 1], "end": [44, 79], "kind": "commanddeclaration"}, {"full_name": "MvPolynomial.rank_mvPolynomial", "code": "theorem rank_mvPolynomial : Module.rank K (MvPolynomial \u03c3 K) = Cardinal.mk (\u03c3 \u2192\u2080 \u2115)", "start": [58, 1], "end": [59, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/NormedSpace/TrivSqZeroExt.lean", "imports": ["Mathlib/Analysis/NormedSpace/Exponential.lean", "Mathlib/Topology/Instances/TrivSqZeroExt.lean", "Mathlib/Analysis/NormedSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TrivSqZeroExt.hasSum_fst_expSeries", "code": "theorem hasSum_fst_expSeries [Field \ud835\udd5c] [Ring R] [AddCommGroup M] [Algebra \ud835\udd5c R] [Module R M]\n    [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M] [Module \ud835\udd5c M] [IsScalarTower \ud835\udd5c R M]\n    [IsScalarTower \ud835\udd5c R\u1d50\u1d52\u1d56 M] [TopologicalRing R] [TopologicalAddGroup M] [ContinuousSMul R M]\n    [ContinuousSMul R\u1d50\u1d52\u1d56 M] (x : tsze R M) {e : R}\n    (h : HasSum (fun n => expSeries \ud835\udd5c R n fun _ => x.fst) e) :\n    HasSum (fun n => fst (expSeries \ud835\udd5c (tsze R M) n fun _ => x)) e", "start": [47, 1], "end": [54, 37], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_snd_expSeries_of_smul_comm", "code": "theorem hasSum_snd_expSeries_of_smul_comm [Field \ud835\udd5c] [CharZero \ud835\udd5c] [Ring R] [AddCommGroup M]\n    [Algebra \ud835\udd5c R] [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M] [Module \ud835\udd5c M]\n    [IsScalarTower \ud835\udd5c R M] [IsScalarTower \ud835\udd5c R\u1d50\u1d52\u1d56 M] [TopologicalRing R] [TopologicalAddGroup M]\n    [ContinuousSMul R M] [ContinuousSMul R\u1d50\u1d52\u1d56 M] (x : tsze R M)\n    (hx : MulOpposite.op x.fst \u2022 x.snd = x.fst \u2022 x.snd) {e : R}\n    (h : HasSum (fun n => expSeries \ud835\udd5c R n fun _ => x.fst) e) :\n    HasSum (fun n => snd (expSeries \ud835\udd5c (tsze R M) n fun _ => x)) (e \u2022 x.snd)", "start": [57, 1], "end": [78, 10], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.hasSum_expSeries_of_smul_comm", "code": "theorem hasSum_expSeries_of_smul_comm [Field \ud835\udd5c] [CharZero \ud835\udd5c] [Ring R] [AddCommGroup M] [Algebra \ud835\udd5c R]\n    [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M] [Module \ud835\udd5c M] [IsScalarTower \ud835\udd5c R M]\n    [IsScalarTower \ud835\udd5c R\u1d50\u1d52\u1d56 M] [TopologicalRing R] [TopologicalAddGroup M] [ContinuousSMul R M]\n    [ContinuousSMul R\u1d50\u1d52\u1d56 M] (x : tsze R M) (hx : MulOpposite.op x.fst \u2022 x.snd = x.fst \u2022 x.snd)\n    {e : R} (h : HasSum (fun n => expSeries \ud835\udd5c R n fun _ => x.fst) e) :\n    HasSum (fun n => expSeries \ud835\udd5c (tsze R M) n fun _ => x) (inl e + inr (e \u2022 x.snd))", "start": [81, 1], "end": [90, 67], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.exp_def_of_smul_comm", "code": "theorem exp_def_of_smul_comm (x : tsze R M) (hx : MulOpposite.op x.fst \u2022 x.snd = x.fst \u2022 x.snd) :\n    exp \ud835\udd5c x = inl (exp \ud835\udd5c x.fst) + inr (exp \ud835\udd5c x.fst \u2022 x.snd)", "start": [109, 1], "end": [113, 31], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.exp_inl", "code": "@[simp]\ntheorem exp_inl (x : R) : exp \ud835\udd5c (inl x : tsze R M) = inl (exp \ud835\udd5c x)", "start": [116, 1], "end": [119, 48], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.exp_inr", "code": "@[simp]\ntheorem exp_inr (m : M) : exp \ud835\udd5c (inr m : tsze R M) = 1 + inr m", "start": [122, 1], "end": [125, 69], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.exp_def", "code": "theorem exp_def (x : tsze R M) : exp \ud835\udd5c x = inl (exp \ud835\udd5c x.fst) + inr (exp \ud835\udd5c x.fst \u2022 x.snd)", "start": [144, 1], "end": [145, 49], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.fst_exp", "code": "@[simp]\ntheorem fst_exp (x : tsze R M) : fst (exp \ud835\udd5c x) = exp \ud835\udd5c x.fst", "start": [148, 1], "end": [150, 52], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.snd_exp", "code": "@[simp]\ntheorem snd_exp (x : tsze R M) : snd (exp \ud835\udd5c x) = exp \ud835\udd5c x.fst \u2022 x.snd", "start": [153, 1], "end": [155, 52], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.eq_smul_exp_of_invertible", "code": "theorem eq_smul_exp_of_invertible (x : tsze R M) [Invertible x.fst] :\n    x = x.fst \u2022 exp \ud835\udd5c (\u215f x.fst \u2022 inr x.snd)", "start": [158, 1], "end": [162, 65], "kind": "commanddeclaration"}, {"full_name": "TrivSqZeroExt.eq_smul_exp_of_ne_zero", "code": "theorem eq_smul_exp_of_ne_zero (x : tsze R M) (hx : x.fst \u2260 0) :\n    x = x.fst \u2022 exp \ud835\udd5c (x.fst\u207b\u00b9 \u2022 inr x.snd)", "start": [181, 1], "end": [186, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/DifferentialObject.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/CategoryTheory/Shift/Basic.lean", "Mathlib/CategoryTheory/ConcreteCategory/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.DifferentialObject", "code": "structure DifferentialObject where\n  \n  obj : C\n  \n  d : obj \u27f6 obj\u27e6(1 : S)\u27e7\n  \n  d_squared : d \u226b d\u27e6(1 : S)\u27e7' = 0 := by aesop_cat", "start": [35, 1], "end": [45, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.Hom", "code": "@[ext] structure Hom (X Y : DifferentialObject S C) where\n  \n  f : X.obj \u27f6 Y.obj\n  comm : X.d \u226b f\u27e61\u27e7' = f \u226b Y.d := by aesop_cat", "start": [56, 1], "end": [61, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.Hom.id", "code": "@[simps]\ndef id (X : DifferentialObject S C) : Hom X X where\n  f := \ud835\udfd9 X.obj", "start": [68, 1], "end": [71, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.Hom.comp", "code": "@[simps]\ndef comp {X Y Z : DifferentialObject S C} (f : Hom X Y) (g : Hom Y Z) : Hom X Z where\n  f := f.f \u226b g.f", "start": [74, 1], "end": [77, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.categoryOfDifferentialObjects", "code": "instance categoryOfDifferentialObjects : Category (DifferentialObject S C) where\n  Hom := Hom\n  id := Hom.id\n  comp f g := Hom.comp f g", "start": [82, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.ext", "code": "@[ext]\ntheorem ext {A B : DifferentialObject S C} {f g : A \u27f6 B} (w : f.f = g.f := by aesop_cat) : f = g", "start": [89, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.id_f", "code": "@[simp]\ntheorem id_f (X : DifferentialObject S C) : (\ud835\udfd9 X : X \u27f6 X).f = \ud835\udfd9 X.obj", "start": [93, 1], "end": [94, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.comp_f", "code": "@[simp]\ntheorem comp_f {X Y Z : DifferentialObject S C} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (f \u226b g).f = f.f \u226b g.f", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.eqToHom_f", "code": "@[simp]\ntheorem eqToHom_f {X Y : DifferentialObject S C} (h : X = Y) :\n    Hom.f (eqToHom h) = eqToHom (congr_arg _ h)", "start": [103, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.forget", "code": "def forget : DifferentialObject S C \u2964 C where\n  obj X := X.obj\n  map f := f.f", "start": [113, 1], "end": [116, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.forget_faithful", "code": "instance forget_faithful : Faithful (forget S C) where", "start": [119, 1], "end": [119, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.zero_f", "code": "@[simp]\ntheorem zero_f (P Q : DifferentialObject S C) : (0 : P \u27f6 Q).f = 0", "start": [128, 1], "end": [129, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.hasZeroMorphisms", "code": "instance hasZeroMorphisms : HasZeroMorphisms (DifferentialObject S C) where", "start": [132, 1], "end": [132, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.isoApp", "code": "@[simps]\ndef isoApp {X Y : DifferentialObject S C} (f : X \u2245 Y) : X.obj \u2245 Y.obj where\n  hom := f.hom.f\n  inv := f.inv.f\n  hom_inv_id := by rw [\u2190 comp_f, Iso.hom_inv_id, id_f]\n  inv_hom_id := by rw [\u2190 comp_f, Iso.inv_hom_id, id_f]", "start": [135, 1], "end": [141, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.isoApp_refl", "code": "@[simp]\ntheorem isoApp_refl (X : DifferentialObject S C) : isoApp (Iso.refl X) = Iso.refl X.obj", "start": [144, 1], "end": [145, 95], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.isoApp_symm", "code": "@[simp]\ntheorem isoApp_symm {X Y : DifferentialObject S C} (f : X \u2245 Y) : isoApp f.symm = (isoApp f).symm", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.isoApp_trans", "code": "@[simp]\ntheorem isoApp_trans {X Y Z : DifferentialObject S C} (f : X \u2245 Y) (g : Y \u2245 Z) :\n    isoApp (f \u226a\u226b g) = isoApp f \u226a\u226b isoApp g", "start": [153, 1], "end": [155, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.mkIso", "code": "@[simps]\ndef mkIso {X Y : DifferentialObject S C} (f : X.obj \u2245 Y.obj) (hf : X.d \u226b f.hom\u27e61\u27e7' = f.hom \u226b Y.d) :\n    X \u2245 Y where\n  hom := \u27e8f.hom, hf\u27e9\n  inv := \u27e8f.inv, by\n    rw [\u2190 Functor.mapIso_inv, Iso.comp_inv_eq, Category.assoc, Iso.eq_inv_comp, Functor.mapIso_hom,\n      hf]\u27e9\n  hom_inv_id := by ext1; dsimp; exact f.hom_inv_id\n  inv_hom_id := by ext1; dsimp; exact f.inv_hom_id", "start": [158, 1], "end": [168, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapDifferentialObject", "code": "@[simps]\ndef mapDifferentialObject (F : C \u2964 D)\n    (\u03b7 : (shiftFunctor C (1 : S)).comp F \u27f6 F.comp (shiftFunctor D (1 : S)))\n    (hF : \u2200 c c', F.map (0 : c \u27f6 c') = 0) : DifferentialObject S C \u2964 DifferentialObject S D where\n  obj X :=\n    { obj := F.obj X.obj\n      d := F.map X.d \u226b \u03b7.app X.obj\n      d_squared := by\n        rw [Functor.map_comp, \u2190 Functor.comp_map F (shiftFunctor D (1 : S))]\n        slice_lhs 2 3 => rw [\u2190 \u03b7.naturality X.d]\n        rw [Functor.comp_map]\n        slice_lhs 1 2 => rw [\u2190 F.map_comp, X.d_squared, hF]\n        rw [zero_comp, zero_comp] }\n  map f :=\n    { f := F.map f.f\n      comm := by\n        dsimp\n        slice_lhs 2 3 => rw [\u2190 Functor.comp_map F (shiftFunctor D (1 : S)), \u2190 \u03b7.naturality f.f]\n        slice_lhs 1 2 => rw [Functor.comp_map, \u2190 F.map_comp, f.comm, F.map_comp]\n        rw [Category.assoc] }\n  map_id := by intros; ext; simp\n  map_comp := by intros; ext; simp", "start": [181, 1], "end": [204, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.hasZeroObject", "code": "instance hasZeroObject : HasZeroObject (DifferentialObject S C) := by\n  refine' \u27e8\u27e8\u27e80, 0, by aesop_cat\u27e9, fun X => \u27e8\u27e8\u27e8\u27e80, by aesop_cat\u27e9\u27e9, fun f => _\u27e9\u27e9,\n    fun X => \u27e8\u27e8\u27e8\u27e80, by aesop_cat\u27e9\u27e9, fun f => _\u27e9\u27e9\u27e9\u27e9 <;> ext <;>\n    simp only [eq_iff_true_of_subsingleton]", "start": [222, 1], "end": [227, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.concreteCategoryOfDifferentialObjects", "code": "instance concreteCategoryOfDifferentialObjects : ConcreteCategory (DifferentialObject S C) where\n  forget := forget S C \u22d9 CategoryTheory.forget C", "start": [238, 1], "end": [239, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.shiftFunctor", "code": "@[simps]\ndef shiftFunctor (n : S) : DifferentialObject S C \u2964 DifferentialObject S C where\n  obj X :=\n    { obj := X.obj\u27e6n\u27e7\n      d := X.d\u27e6n\u27e7' \u226b (shiftComm _ _ _).hom\n      d_squared := by\n        rw [Functor.map_comp, Category.assoc, shiftComm_hom_comp_assoc, \u2190 Functor.map_comp_assoc,\n          X.d_squared, Functor.map_zero, zero_comp] }\n  map f :=\n    { f := f.f\u27e6n\u27e7'\n      comm := by\n        dsimp\n        erw [Category.assoc, shiftComm_hom_comp, \u2190 Functor.map_comp_assoc, f.comm,\n          Functor.map_comp_assoc]\n        rfl }\n  map_id X := by ext1; dsimp; rw [Functor.map_id]\n  map_comp f g := by ext1; dsimp; rw [Functor.map_comp]", "start": [258, 1], "end": [275, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.shiftFunctorAdd", "code": "@[simps!]\nnonrec def shiftFunctorAdd (m n : S) :\n    shiftFunctor C (m + n) \u2245 shiftFunctor C m \u22d9 shiftFunctor C n := by\n  refine' NatIso.ofComponents (fun X => mkIso (shiftAdd X.obj _ _) _) (fun f => _)\n  \u00b7 dsimp\n    rw [\u2190 cancel_epi ((shiftFunctorAdd C m n).inv.app X.obj)]\n    simp only [Category.assoc, Iso.inv_hom_id_app_assoc]\n    erw [\u2190 NatTrans.naturality_assoc]\n    dsimp\n    simp only [Functor.map_comp, Category.assoc,\n      shiftFunctorComm_hom_app_comp_shift_shiftFunctorAdd_hom_app 1 m n X.obj,\n      Iso.inv_hom_id_app_assoc]\n  \u00b7 ext; dsimp; exact NatTrans.naturality _ _", "start": [278, 1], "end": [291, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.DifferentialObject.shiftZero", "code": "@[simps!]\ndef shiftZero : shiftFunctor C (0 : S) \u2245 \ud835\udfed (DifferentialObject S C) := by\n  refine' NatIso.ofComponents (fun X => mkIso ((shiftFunctorZero C S).app X.obj) _) (fun f => _)\n  \u00b7 erw [\u2190 NatTrans.naturality]\n    dsimp\n    simp only [shiftFunctorZero_hom_app_shift, Category.assoc]\n  \u00b7 aesop_cat", "start": [296, 1], "end": [303, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Char.lean", "imports": ["Mathlib/Init/Order/Defs.lean", "Mathlib/Data/UInt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Char.toUInt8", "code": "def Char.toUInt8 (n : Char) : UInt8 := n.1.toUInt8", "start": [19, 1], "end": [20, 51], "kind": "commanddeclaration"}, {"full_name": "Char.utf8Size_pos", "code": "theorem Char.utf8Size_pos (c : Char) : 0 < c.utf8Size", "start": [22, 1], "end": [25, 9], "kind": "commanddeclaration"}, {"full_name": "Char.ofNat_toNat", "code": "theorem Char.ofNat_toNat {c : Char} (h : isValidCharNat c.toNat) : Char.ofNat c.toNat = c", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Pi.lean", "imports": ["Mathlib/Algebra/CharP/Basic.lean", "Mathlib/Algebra/Ring/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CharP.pi", "code": "instance pi (\u03b9 : Type u) [hi : Nonempty \u03b9] (R : Type v) [Semiring R] (p : \u2115) [CharP R p] :\n    CharP (\u03b9 \u2192 R) p :=\n  \u27e8fun x =>\n    let \u27e8i\u27e9 := hi\n    Iff.symm <|\n      (CharP.cast_eq_zero_iff R p x).symm.trans\n        \u27e8fun h =>\n          funext fun j =>\n            show Pi.evalRingHom (fun _ => R) j (\u2191x : \u03b9 \u2192 R) = 0 by rw [map_natCast, h],\n          fun h => map_natCast (Pi.evalRingHom (fun _ : \u03b9 => R) i) x \u25b8 by rw [h, RingHom.map_zero]\u27e9\u27e9", "start": [20, 1], "end": [29, 101], "kind": "commanddeclaration"}, {"full_name": "CharP.pi'", "code": "instance pi' (\u03b9 : Type u) [Nonempty \u03b9] (R : Type v) [CommRing R] (p : \u2115) [CharP R p] :\n    CharP (\u03b9 \u2192 R) p :=\n  CharP.pi \u03b9 R p", "start": [33, 1], "end": [35, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharP/Subring.lean", "imports": ["Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CharP.subsemiring", "code": "instance subsemiring (R : Type u) [Semiring R] (p : \u2115) [CharP R p] (S : Subsemiring R) :\n    CharP S p :=\n  \u27e8fun x =>\n    Iff.symm <|\n      (CharP.cast_eq_zero_iff R p x).symm.trans\n        \u27e8fun h => Subtype.eq <| show S.subtype x = 0 by rw [map_natCast, h], fun h =>\n          map_natCast S.subtype x \u25b8 by rw [h, RingHom.map_zero]\u27e9\u27e9", "start": [20, 1], "end": [26, 66], "kind": "commanddeclaration"}, {"full_name": "CharP.subring", "code": "instance subring (R : Type u) [Ring R] (p : \u2115) [CharP R p] (S : Subring R) : CharP S p :=\n  \u27e8fun x =>\n    Iff.symm <|\n      (CharP.cast_eq_zero_iff R p x).symm.trans\n        \u27e8fun h => Subtype.eq <| show S.subtype x = 0 by rw [map_natCast, h], fun h =>\n          map_natCast S.subtype x \u25b8 by rw [h, RingHom.map_zero]\u27e9\u27e9", "start": [29, 1], "end": [34, 66], "kind": "commanddeclaration"}, {"full_name": "CharP.subring'", "code": "instance subring' (R : Type u) [CommRing R] (p : \u2115) [CharP R p] (S : Subring R) : CharP S p :=\n  CharP.subring R p S", "start": [37, 1], "end": [38, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sums/Basic.lean", "imports": ["Mathlib/CategoryTheory/EqToHom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.sum", "code": "instance sum : Category.{v\u2081} (Sum C D) where\n  Hom X Y :=\n    match X, Y with\n    | inl X, inl Y => X \u27f6 Y\n    | inl _, inr _ => PEmpty\n    | inr _, inl _ => PEmpty\n    | inr X, inr Y => X \u27f6 Y\n  id X :=\n    match X with\n    | inl X => \ud835\udfd9 X\n    | inr X => \ud835\udfd9 X\n  comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => f \u226b g\n    | inr X, inr Y, inr Z, f, g => f \u226b g\n  assoc := @fun W X Y Z f g h =>\n    match X, Y, Z, W with\n    | inl X, inl Y, inl Z, inl W => Category.assoc f g h\n    | inr X, inr Y, inr Z, inr W => Category.assoc f g h", "start": [38, 1], "end": [58, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hom_inl_inr_false", "code": "@[aesop norm -10 destruct (rule_sets [CategoryTheory])]\ntheorem hom_inl_inr_false {X : C} {Y : D} (f : Sum.inl X \u27f6 Sum.inr Y) : False", "start": [61, 1], "end": [63, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hom_inr_inl_false", "code": "@[aesop norm -10 destruct (rule_sets [CategoryTheory])]\ntheorem hom_inr_inl_false {X : C} {Y : D} (f : Sum.inr X \u27f6 Sum.inl Y) : False", "start": [65, 1], "end": [67, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum_comp_inl", "code": "@[simp, nolint simpComm]\ntheorem sum_comp_inl {P Q R : C} (f : (inl P : Sum C D) \u27f6 inl Q) (g : (inl Q : Sum C D) \u27f6 inl R) :\n    @CategoryStruct.comp _ _ P Q R (f : P \u27f6 Q) (g : Q \u27f6 R) =\n      @CategoryStruct.comp _ _ (inl P) (inl Q) (inl R) (f : P \u27f6 Q) (g : Q \u27f6 R)", "start": [70, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.sum_comp_inr", "code": "@[simp, nolint simpComm]\ntheorem sum_comp_inr {P Q R : D} (f : (inr P : Sum C D) \u27f6 inr Q) (g : (inr Q : Sum C D) \u27f6 inr R) :\n    @CategoryStruct.comp _ _ P Q R (f : P \u27f6 Q) (g : Q \u27f6 R) =\n      @CategoryStruct.comp _ _ (inr P) (inr Q) (inr R) (f : P \u27f6 Q) (g : Q \u27f6 R)", "start": [78, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.inl_", "code": "@[simps]\ndef inl_ : C \u2964 Sum C D where\n  obj X := inl X\n  map := @fun X Y f => f", "start": [92, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.inr_", "code": "@[simps]\ndef inr_ : D \u2964 Sum C D where\n  obj X := inr X\n  map := @fun X Y f => f", "start": [99, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.swap", "code": "def swap : Sum C D \u2964 Sum D C where\n  obj X :=\n    match X with\n    | inl X => inr X\n    | inr X => inl X\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl _, inl _, f => f\n    | inr _, inr _, f => f\n  map_comp := fun {X} {Y} {Z} _ _ =>\n    match X, Y, Z with\n    | inl X, inl Y, inl Z => by rfl\n    | inr X, inr Y, inr Z => by rfl", "start": [109, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.swap_obj_inl", "code": "@[simp]\ntheorem swap_obj_inl (X : C) : (swap C D).obj (inl X) = inr X", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.swap_obj_inr", "code": "@[simp]\ntheorem swap_obj_inr (X : D) : (swap C D).obj (inr X) = inl X", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.swap_map_inl", "code": "@[simp]\ntheorem swap_map_inl {X Y : C} {f : inl X \u27f6 inl Y} : (swap C D).map f = f", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.swap_map_inr", "code": "@[simp]\ntheorem swap_map_inr {X Y : D} {f : inr X \u27f6 inr Y} : (swap C D).map f = f", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.Swap.equivalence", "code": "def equivalence : Sum C D \u224c Sum D C :=\n  Equivalence.mk (swap C D) (swap D C)\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)))\n    (NatIso.ofComponents (fun X => eqToIso (by cases X <;> rfl)))", "start": [147, 1], "end": [151, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.Swap.isEquivalence", "code": "instance isEquivalence : IsEquivalence (swap C D) :=\n  (by infer_instance : IsEquivalence (equivalence C D).functor)", "start": [154, 1], "end": [155, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Sum.Swap.symmetry", "code": "def symmetry : swap C D \u22d9 swap D C \u2245 \ud835\udfed (Sum C D) :=\n  (equivalence C D).unitIso.symm", "start": [158, 1], "end": [160, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sum", "code": "def sum (F : A \u2964 B) (G : C \u2964 D) : Sum A C \u2964 Sum B D\n    where\n  obj X :=\n    match X with\n    | inl X => inl (F.obj X)\n    | inr X => inr (G.obj X)\n  map := @fun X Y f =>\n    match X, Y, f with\n    | inl X, inl Y, f => F.map f\n    | inr X, inr Y, f => G.map f\n  map_id := @fun X => by cases X <;> (erw [Functor.map_id]; rfl)\n  map_comp := @fun X Y Z f g =>\n    match X, Y, Z, f, g with\n    | inl X, inl Y, inl Z, f, g => by erw [F.map_comp]; rfl\n    | inr X, inr Y, inr Z, f, g => by erw [G.map_comp]; rfl", "start": [172, 1], "end": [187, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sum_obj_inl", "code": "@[simp]\ntheorem sum_obj_inl (F : A \u2964 B) (G : C \u2964 D) (a : A) : (F.sum G).obj (inl a) = inl (F.obj a)", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sum_obj_inr", "code": "@[simp]\ntheorem sum_obj_inr (F : A \u2964 B) (G : C \u2964 D) (c : C) : (F.sum G).obj (inr c) = inr (G.obj c)", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sum_map_inl", "code": "@[simp]\ntheorem sum_map_inl (F : A \u2964 B) (G : C \u2964 D) {a a' : A} (f : inl a \u27f6 inl a') :\n    (F.sum G).map f = F.map f", "start": [200, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.sum_map_inr", "code": "@[simp]\ntheorem sum_map_inr (F : A \u2964 B) (G : C \u2964 D) {c c' : C} (f : inr c \u27f6 inr c') :\n    (F.sum G).map f = G.map f", "start": [206, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.sum", "code": "def sum {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) : F.sum H \u27f6 G.sum I\n    where\n  app X :=\n    match X with\n    | inl X => \u03b1.app X\n    | inr X => \u03b2.app X\n  naturality X Y f :=\n    match X, Y, f with\n    | inl X, inl Y, f => by erw [\u03b1.naturality]; rfl\n    | inr X, inr Y, f => by erw [\u03b2.naturality]; rfl", "start": [216, 1], "end": [226, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.sum_app_inl", "code": "@[simp]\ntheorem sum_app_inl {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) (a : A) :\n    (sum \u03b1 \u03b2).app (inl a) = \u03b1.app a", "start": [229, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.sum_app_inr", "code": "@[simp]\ntheorem sum_app_inr {F G : A \u2964 B} {H I : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) (c : C) :\n    (sum \u03b1 \u03b2).app (inr c) = \u03b2.app c", "start": [235, 1], "end": [238, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Computability/NFA.lean", "imports": ["Mathlib/Data/Fintype/Powerset.lean", "Mathlib/Computability/DFA.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NFA", "code": "structure NFA (\u03b1 : Type u) (\u03c3 : Type v) where\n  step : \u03c3 \u2192 \u03b1 \u2192 Set \u03c3\n  start : Set \u03c3\n  accept : Set \u03c3", "start": [34, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "NFA.stepSet", "code": "def stepSet (S : Set \u03c3) (a : \u03b1) : Set \u03c3 :=\n  \u22c3 s \u2208 S, M.step s a", "start": [51, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "NFA.mem_stepSet", "code": "theorem mem_stepSet (s : \u03c3) (S : Set \u03c3) (a : \u03b1) : s \u2208 M.stepSet S a \u2194 \u2203 t \u2208 S, s \u2208 M.step t a", "start": [56, 1], "end": [57, 17], "kind": "commanddeclaration"}, {"full_name": "NFA.stepSet_empty", "code": "@[simp]\ntheorem stepSet_empty (a : \u03b1) : M.stepSet \u2205 a = \u2205", "start": [60, 1], "end": [61, 71], "kind": "commanddeclaration"}, {"full_name": "NFA.evalFrom", "code": "def evalFrom (start : Set \u03c3) : List \u03b1 \u2192 Set \u03c3 :=\n  List.foldl M.stepSet start", "start": [64, 1], "end": [67, 29], "kind": "commanddeclaration"}, {"full_name": "NFA.evalFrom_nil", "code": "@[simp]\ntheorem evalFrom_nil (S : Set \u03c3) : M.evalFrom S [] = S", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "NFA.evalFrom_singleton", "code": "@[simp]\ntheorem evalFrom_singleton (S : Set \u03c3) (a : \u03b1) : M.evalFrom S [a] = M.stepSet S a", "start": [75, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "NFA.evalFrom_append_singleton", "code": "@[simp]\ntheorem evalFrom_append_singleton (S : Set \u03c3) (x : List \u03b1) (a : \u03b1) :\n    M.evalFrom S (x ++ [a]) = M.stepSet (M.evalFrom S x) a", "start": [80, 1], "end": [83, 75], "kind": "commanddeclaration"}, {"full_name": "NFA.eval", "code": "def eval : List \u03b1 \u2192 Set \u03c3 :=\n  M.evalFrom M.start", "start": [86, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "NFA.eval_nil", "code": "@[simp]\ntheorem eval_nil : M.eval [] = M.start", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "NFA.eval_singleton", "code": "@[simp]\ntheorem eval_singleton (a : \u03b1) : M.eval [a] = M.stepSet M.start a", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "NFA.eval_append_singleton", "code": "@[simp]\ntheorem eval_append_singleton (x : List \u03b1) (a : \u03b1) : M.eval (x ++ [a]) = M.stepSet (M.eval x) a", "start": [102, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "NFA.accepts", "code": "def accepts : Language \u03b1 := {x | \u2203 S \u2208 M.accept, S \u2208 M.eval x}", "start": [107, 1], "end": [108, 63], "kind": "commanddeclaration"}, {"full_name": "NFA.mem_accepts", "code": "theorem mem_accepts : x \u2208 M.accepts \u2194 \u2203 S \u2208 M.accept, S \u2208 M.evalFrom M.start x", "start": [111, 1], "end": [111, 89], "kind": "commanddeclaration"}, {"full_name": "NFA.toDFA", "code": "def toDFA : DFA \u03b1 (Set \u03c3) where\n  step := M.stepSet\n  start := M.start\n  accept := { S | \u2203 s \u2208 S, s \u2208 M.accept }", "start": [113, 1], "end": [118, 42], "kind": "commanddeclaration"}, {"full_name": "NFA.toDFA_correct", "code": "@[simp]\ntheorem toDFA_correct : M.toDFA.accepts = M.accepts", "start": [121, 1], "end": [125, 57], "kind": "commanddeclaration"}, {"full_name": "NFA.pumping_lemma", "code": "theorem pumping_lemma [Fintype \u03c3] {x : List \u03b1} (hx : x \u2208 M.accepts)\n    (hlen : Fintype.card (Set \u03c3) \u2264 List.length x) :\n    \u2203 a b c,\n      x = a ++ b ++ c \u2227\n        a.length + b.length \u2264 Fintype.card (Set \u03c3) \u2227 b \u2260 [] \u2227 {a} * {b}\u2217 * {c} \u2264 M.accepts", "start": [128, 1], "end": [134, 38], "kind": "commanddeclaration"}, {"full_name": "DFA.toNFA", "code": "@[simps] def toNFA (M : DFA \u03b1 \u03c3') : NFA \u03b1 \u03c3'\n    where\n  step s a := {M.step s a}\n  start := {M.start}\n  accept := M.accept", "start": [141, 1], "end": [147, 21], "kind": "commanddeclaration"}, {"full_name": "DFA.toNFA_evalFrom_match", "code": "@[simp]\ntheorem toNFA_evalFrom_match (M : DFA \u03b1 \u03c3) (start : \u03c3) (s : List \u03b1) :\n    M.toNFA.evalFrom {start} s = {M.evalFrom start s}", "start": [150, 1], "end": [158, 10], "kind": "commanddeclaration"}, {"full_name": "DFA.toNFA_correct", "code": "@[simp]\ntheorem toNFA_correct (M : DFA \u03b1 \u03c3) : M.toNFA.accepts = M.accepts", "start": [161, 1], "end": [168, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Nth.lean", "imports": ["Mathlib/Data/Set/Intervals/Monotone.lean", "Mathlib/Order/OrderIsoNat.lean", "Mathlib/Data/Nat/Count.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.nth", "code": "noncomputable def nth (p : \u2115 \u2192 Prop) (n : \u2115) : \u2115 := by\n  classical exact\n    if h : Set.Finite (setOf p) then (h.toFinset.sort (\u00b7 \u2264 \u00b7)).getD n 0\n    else @Nat.Subtype.orderIsoOfNat (setOf p) (Set.Infinite.to_subtype h) n", "start": [45, 1], "end": [51, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_of_card_le", "code": "theorem nth_of_card_le (hf : (setOf p).Finite) {n : \u2115} (hn : hf.toFinset.card \u2264 n) : nth p n = 0", "start": [61, 1], "end": [62, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_getD_sort", "code": "theorem nth_eq_getD_sort (h : (setOf p).Finite) (n : \u2115) :\n    nth p n = (h.toFinset.sort (\u00b7 \u2264 \u00b7)).getD n 0", "start": [65, 1], "end": [67, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_orderEmbOfFin", "code": "theorem nth_eq_orderEmbOfFin (hf : (setOf p).Finite) {n : \u2115} (hn : n < hf.toFinset.card) :\n    nth p n = hf.toFinset.orderEmbOfFin rfl \u27e8n, hn\u27e9", "start": [70, 1], "end": [72, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_strictMonoOn", "code": "theorem nth_strictMonoOn (hf : (setOf p).Finite) :\n    StrictMonoOn (nth p) (Set.Iio hf.toFinset.card)", "start": [75, 1], "end": [79, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_lt_nth_of_lt_card", "code": "theorem nth_lt_nth_of_lt_card (hf : (setOf p).Finite) {m n : \u2115} (h : m < n)\n    (hn : n < hf.toFinset.card) : nth p m < nth p n", "start": [82, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_le_nth_of_lt_card", "code": "theorem nth_le_nth_of_lt_card (hf : (setOf p).Finite) {m n : \u2115} (h : m \u2264 n)\n    (hn : n < hf.toFinset.card) : nth p m \u2264 nth p n", "start": [87, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_nth_lt_nth_of_lt_card", "code": "theorem lt_of_nth_lt_nth_of_lt_card (hf : (setOf p).Finite) {m n : \u2115} (h : nth p m < nth p n)\n    (hm : m < hf.toFinset.card) : m < n", "start": [92, 1], "end": [94, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_nth_le_nth_of_lt_card", "code": "theorem le_of_nth_le_nth_of_lt_card (hf : (setOf p).Finite) {m n : \u2115} (h : nth p m \u2264 nth p n)\n    (hm : m < hf.toFinset.card) : m \u2264 n", "start": [97, 1], "end": [99, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_injOn", "code": "theorem nth_injOn (hf : (setOf p).Finite) : (Set.Iio hf.toFinset.card).InjOn (nth p)", "start": [102, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.range_nth_of_finite", "code": "theorem range_nth_of_finite (hf : (setOf p).Finite) : Set.range (nth p) = insert 0 (setOf p)", "start": [106, 1], "end": [108, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.image_nth_Iio_card", "code": "@[simp]\ntheorem image_nth_Iio_card (hf : (setOf p).Finite) : nth p '' Set.Iio hf.toFinset.card = setOf p", "start": [111, 1], "end": [118, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_mem_of_lt_card", "code": "theorem nth_mem_of_lt_card {n : \u2115} (hf : (setOf p).Finite) (hlt : n < hf.toFinset.card) :\n    p (nth p n)", "start": [121, 1], "end": [123, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_lt_card_finite_nth_eq", "code": "theorem exists_lt_card_finite_nth_eq (hf : (setOf p).Finite) {x} (h : p x) :\n    \u2203 n, n < hf.toFinset.card \u2227 nth p n = x", "start": [126, 1], "end": [128, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_apply_eq_orderIsoOfNat", "code": "theorem nth_apply_eq_orderIsoOfNat (hf : (setOf p).Infinite) (n : \u2115) :\n    nth p n = @Nat.Subtype.orderIsoOfNat (setOf p) hf.to_subtype n", "start": [135, 1], "end": [137, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_orderIsoOfNat", "code": "theorem nth_eq_orderIsoOfNat (hf : (setOf p).Infinite) :\n    nth p = (\u2191) \u2218 @Nat.Subtype.orderIsoOfNat (setOf p) hf.to_subtype", "start": [140, 1], "end": [143, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_strictMono", "code": "theorem nth_strictMono (hf : (setOf p).Infinite) : StrictMono (nth p)", "start": [146, 1], "end": [148, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_injective", "code": "theorem nth_injective (hf : (setOf p).Infinite) : Function.Injective (nth p)", "start": [151, 1], "end": [152, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_monotone", "code": "theorem nth_monotone (hf : (setOf p).Infinite) : Monotone (nth p)", "start": [155, 1], "end": [156, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_lt_nth", "code": "theorem nth_lt_nth (hf : (setOf p).Infinite) {k n} : nth p k < nth p n \u2194 k < n", "start": [159, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_le_nth", "code": "theorem nth_le_nth (hf : (setOf p).Infinite) {k n} : nth p k \u2264 nth p n \u2194 k \u2264 n", "start": [163, 1], "end": [164, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.range_nth_of_infinite", "code": "theorem range_nth_of_infinite (hf : (setOf p).Infinite) : Set.range (nth p) = setOf p", "start": [167, 1], "end": [171, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_mem_of_infinite", "code": "theorem nth_mem_of_infinite (hf : (setOf p).Infinite) (n : \u2115) : p (nth p n)", "start": [174, 1], "end": [175, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_lt_card_nth_eq", "code": "theorem exists_lt_card_nth_eq {x} (h : p x) :\n    \u2203 n, (\u2200 hf : (setOf p).Finite, n < hf.toFinset.card) \u2227 nth p n = x", "start": [182, 1], "end": [189, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.subset_range_nth", "code": "theorem subset_range_nth : setOf p \u2286 Set.range (nth p)", "start": [192, 1], "end": [194, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.range_nth_subset", "code": "theorem range_nth_subset : Set.range (nth p) \u2286 insert 0 (setOf p)", "start": [197, 1], "end": [199, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_mem", "code": "theorem nth_mem (n : \u2115) (h : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) : p (nth p n)", "start": [202, 1], "end": [204, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_lt_nth'", "code": "theorem nth_lt_nth' {m n : \u2115} (hlt : m < n) (h : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) :\n    nth p m < nth p n", "start": [207, 1], "end": [210, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_le_nth'", "code": "theorem nth_le_nth' {m n : \u2115} (hle : m \u2264 n) (h : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) :\n    nth p m \u2264 nth p n", "start": [213, 1], "end": [216, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.le_nth", "code": "theorem le_nth {n : \u2115} (h : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) : n \u2264 nth p n", "start": [219, 1], "end": [222, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.isLeast_nth", "code": "theorem isLeast_nth {n} (h : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) :\n    IsLeast {i | p i \u2227 \u2200 k < n, nth p k < i} (nth p n)", "start": [225, 1], "end": [229, 101], "kind": "commanddeclaration"}, {"full_name": "Nat.isLeast_nth_of_lt_card", "code": "theorem isLeast_nth_of_lt_card {n : \u2115} (hf : (setOf p).Finite) (hn : n < hf.toFinset.card) :\n    IsLeast {i | p i \u2227 \u2200 k < n, nth p k < i} (nth p n)", "start": [232, 1], "end": [234, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.isLeast_nth_of_infinite", "code": "theorem isLeast_nth_of_infinite (hf : (setOf p).Infinite) (n : \u2115) :\n    IsLeast {i | p i \u2227 \u2200 k < n, nth p k < i} (nth p n)", "start": [237, 1], "end": [239, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_sInf", "code": "theorem nth_eq_sInf (p : \u2115 \u2192 Prop) (n : \u2115) : nth p n = sInf {x | p x \u2227 \u2200 k < n, nth p k < x}", "start": [242, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_zero", "code": "theorem nth_zero : nth p 0 = sInf (setOf p)", "start": [257, 1], "end": [257, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_zero_of_zero", "code": "@[simp]\ntheorem nth_zero_of_zero (h : p 0) : nth p 0 = 0", "start": [260, 1], "end": [261, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_zero_of_exists", "code": "theorem nth_zero_of_exists [DecidablePred p] (h : \u2203 n, p n) : nth p 0 = Nat.find h", "start": [264, 1], "end": [265, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_zero", "code": "theorem nth_eq_zero {n} :\n    nth p n = 0 \u2194 p 0 \u2227 n = 0 \u2228 \u2203 hf : (setOf p).Finite, hf.toFinset.card \u2264 n", "start": [268, 1], "end": [274, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_eq_zero_mono", "code": "theorem nth_eq_zero_mono (h\u2080 : \u00acp 0) {a b : \u2115} (hab : a \u2264 b) (ha : nth p a = 0) : nth p b = 0", "start": [277, 1], "end": [279, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.le_nth_of_lt_nth_succ", "code": "theorem le_nth_of_lt_nth_succ {k a : \u2115} (h : a < nth p (k + 1)) (ha : p a) : a \u2264 nth p k", "start": [282, 1], "end": [291, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.count_nth_zero", "code": "@[simp]\ntheorem count_nth_zero : count p (nth p 0) = 0", "start": [298, 1], "end": [301, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_range_nth_subset_insert", "code": "theorem filter_range_nth_subset_insert (k : \u2115) :\n    (range (nth p (k + 1))).filter p \u2286 insert (nth p k) ((range (nth p k)).filter p)", "start": [304, 1], "end": [308, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_range_nth_eq_insert", "code": "theorem filter_range_nth_eq_insert {k : \u2115}\n    (hlt : \u2200 hf : (setOf p).Finite, k + 1 < hf.toFinset.card) :\n    (range (nth p (k + 1))).filter p = insert (nth p k) ((range (nth p k)).filter p)", "start": [313, 1], "end": [321, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_range_nth_eq_insert_of_finite", "code": "theorem filter_range_nth_eq_insert_of_finite (hf : (setOf p).Finite) {k : \u2115}\n    (hlt : k + 1 < hf.toFinset.card) :\n    (range (nth p (k + 1))).filter p = insert (nth p k) ((range (nth p k)).filter p)", "start": [324, 1], "end": [327, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.filter_range_nth_eq_insert_of_infinite", "code": "theorem filter_range_nth_eq_insert_of_infinite (hp : (setOf p).Infinite) (k : \u2115) :\n    (range (nth p (k + 1))).filter p = insert (nth p k) ((range (nth p k)).filter p)", "start": [330, 1], "end": [332, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.count_nth", "code": "theorem count_nth {n : \u2115} (hn : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) :\n    count p (nth p n) = n", "start": [335, 1], "end": [341, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.count_nth_of_lt_card_finite", "code": "theorem count_nth_of_lt_card_finite {n : \u2115} (hp : (setOf p).Finite) (hlt : n < hp.toFinset.card) :\n    count p (nth p n) = n", "start": [344, 1], "end": [346, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.count_nth_of_infinite", "code": "theorem count_nth_of_infinite (hp : (setOf p).Infinite) (n : \u2115) : count p (nth p n) = n", "start": [349, 1], "end": [350, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.count_nth_succ", "code": "theorem count_nth_succ {n : \u2115} (hn : \u2200 hf : (setOf p).Finite, n < hf.toFinset.card) :\n    count p (nth p n + 1) = n + 1", "start": [353, 1], "end": [354, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_count", "code": "@[simp]\ntheorem nth_count {n : \u2115} (hpn : p n) : nth p (count p n) = n", "start": [357, 1], "end": [360, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_lt_of_lt_count", "code": "theorem nth_lt_of_lt_count {n k : \u2115} (h : k < count p n) : nth p k < n", "start": [363, 1], "end": [366, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.le_nth_of_count_le", "code": "theorem le_nth_of_count_le {n k : \u2115} (h : n \u2264 nth p k) : count p n \u2264 k", "start": [369, 1], "end": [370, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.nth_count_eq_sInf", "code": "theorem nth_count_eq_sInf (n : \u2115) : nth p (count p n) = sInf {i : \u2115 | p i \u2227 n \u2264 i}", "start": [375, 1], "end": [380, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.le_nth_count'", "code": "theorem le_nth_count' {n : \u2115} (hpn : \u2203 k, p k \u2227 n \u2264 k) : n \u2264 nth p (count p n)", "start": [385, 1], "end": [386, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.le_nth_count", "code": "theorem le_nth_count (hp : (setOf p).Infinite) (n : \u2115) : n \u2264 nth p (count p n)", "start": [389, 1], "end": [391, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.giCountNth", "code": "noncomputable def giCountNth (hp : (setOf p).Infinite) : GaloisInsertion (count p) (nth p) :=\n  GaloisInsertion.monotoneIntro (nth_monotone hp) (count_monotone p) (le_nth_count hp)\n    (count_nth_of_infinite hp)", "start": [394, 1], "end": [398, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.gc_count_nth", "code": "theorem gc_count_nth (hp : (setOf p).Infinite) : GaloisConnection (count p) (nth p)", "start": [401, 1], "end": [402, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.count_le_iff_le_nth", "code": "theorem count_le_iff_le_nth (hp : (setOf p).Infinite) {a b : \u2115} : count p a \u2264 b \u2194 a \u2264 nth p b", "start": [405, 1], "end": [406, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_nth_iff_count_lt", "code": "theorem lt_nth_iff_count_lt (hp : (setOf p).Infinite) {a b : \u2115} : a < count p b \u2194 nth p a < b", "start": [409, 1], "end": [410, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PFunctor/Multivariate/W.lean", "imports": ["Mathlib/Data/PFunctor/Multivariate/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MvPFunctor.WPath", "code": "inductive WPath : P.last.W \u2192 Fin2 n \u2192 Type u\n  | root (a : P.A) (f : P.last.B a \u2192 P.last.W) (i : Fin2 n) (c : P.drop.B a i) : WPath \u27e8a, f\u27e9 i\n  | child (a : P.A) (f : P.last.B a \u2192 P.last.W) (i : Fin2 n) (j : P.last.B a)\n    (c : WPath (f j) i) : WPath \u27e8a, f\u27e9 i", "start": [59, 1], "end": [63, 41], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.WPath.inhabited", "code": "instance WPath.inhabited (x : P.last.W) {i} [I : Inhabited (P.drop.B x.head i)] :\n    Inhabited (WPath P x i) :=\n  \u27e8match x, I with\n    | \u27e8a, f\u27e9, I => WPath.root a f i (@default _ I)\u27e9", "start": [67, 1], "end": [70, 52], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathCasesOn", "code": "def wPathCasesOn {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W} (g' : P.drop.B a \u27f9 \u03b1)\n    (g : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1) : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1 := by\n  intro i x;\n  match x with\n  | WPath.root _ _ i c => exact g' i c\n  | WPath.child _ _ i j c => exact g j i c", "start": [74, 1], "end": [80, 43], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathDestLeft", "code": "def wPathDestLeft {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (h : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1) : P.drop.B a \u27f9 \u03b1 := fun i c => h i (WPath.root a f i c)", "start": [84, 1], "end": [86, 85], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathDestRight", "code": "def wPathDestRight {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (h : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1) : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1 := fun j i c =>\n  h i (WPath.child a f i j c)", "start": [90, 1], "end": [93, 30], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathDestLeft_wPathCasesOn", "code": "theorem wPathDestLeft_wPathCasesOn {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (g' : P.drop.B a \u27f9 \u03b1) (g : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1) :\n    P.wPathDestLeft (P.wPathCasesOn g' g) = g'", "start": [97, 1], "end": [99, 54], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathDestRight_wPathCasesOn", "code": "theorem wPathDestRight_wPathCasesOn {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (g' : P.drop.B a \u27f9 \u03b1) (g : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1) :\n    P.wPathDestRight (P.wPathCasesOn g' g) = g", "start": [103, 1], "end": [105, 54], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wPathCasesOn_eta", "code": "theorem wPathCasesOn_eta {\u03b1 : TypeVec n} {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (h : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1) : P.wPathCasesOn (P.wPathDestLeft h) (P.wPathDestRight h) = h", "start": [109, 1], "end": [111, 27], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.comp_wPathCasesOn", "code": "theorem comp_wPathCasesOn {\u03b1 \u03b2 : TypeVec n} (h : \u03b1 \u27f9 \u03b2) {a : P.A} {f : P.last.B a \u2192 P.last.W}\n    (g' : P.drop.B a \u27f9 \u03b1) (g : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1) :\n    h \u229a P.wPathCasesOn g' g = P.wPathCasesOn (h \u229a g') fun i => h \u229a g i", "start": [115, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wp", "code": "def wp : MvPFunctor n where\n  A := P.last.W\n  B := P.WPath", "start": [122, 1], "end": [128, 15], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.W", "code": "def W (\u03b1 : TypeVec n) : Type _ :=\n  P.wp \u03b1", "start": [132, 1], "end": [135, 9], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.mvfunctorW", "code": "instance mvfunctorW : MvFunctor P.W := by delta MvPFunctor.W; infer_instance", "start": [139, 1], "end": [139, 77], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wpMk", "code": "def wpMk {\u03b1 : TypeVec n} (a : P.A) (f : P.last.B a \u2192 P.last.W) (f' : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1) :\n    P.W \u03b1 :=\n  \u27e8\u27e8a, f\u27e9, f'\u27e9", "start": [148, 1], "end": [151, 15], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wpRec", "code": "def wpRec {\u03b1 : TypeVec n} {C : Type*}\n    (g : \u2200 (a : P.A) (f : P.last.B a \u2192 P.last.W), P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1 \u2192 (P.last.B a \u2192 C) \u2192 C) :\n    \u2200 (x : P.last.W) (_ : P.WPath x \u27f9 \u03b1), C\n  | \u27e8a, f\u27e9, f' => g a f f' fun i => wpRec g (f i) (P.wPathDestRight f' i)", "start": [155, 1], "end": [158, 74], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wpRec_eq", "code": "theorem wpRec_eq {\u03b1 : TypeVec n} {C : Type*}\n    (g : \u2200 (a : P.A) (f : P.last.B a \u2192 P.last.W), P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1 \u2192 (P.last.B a \u2192 C) \u2192 C)\n    (a : P.A) (f : P.last.B a \u2192 P.last.W) (f' : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1) :\n    P.wpRec g \u27e8a, f\u27e9 f' = g a f f' fun i => P.wpRec g (f i) (P.wPathDestRight f' i)", "start": [162, 1], "end": [165, 91], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wp_ind", "code": "theorem wp_ind {\u03b1 : TypeVec n} {C : \u2200 x : P.last.W, P.WPath x \u27f9 \u03b1 \u2192 Prop}\n    (ih : \u2200 (a : P.A) (f : P.last.B a \u2192 P.last.W) (f' : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1),\n        (\u2200 i : P.last.B a, C (f i) (P.wPathDestRight f' i)) \u2192 C \u27e8a, f\u27e9 f') :\n    \u2200 (x : P.last.W) (f' : P.WPath x \u27f9 \u03b1), C x f'", "start": [170, 1], "end": [174, 52], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wMk", "code": "def wMk {\u03b1 : TypeVec n} (a : P.A) (f' : P.drop.B a \u27f9 \u03b1) (f : P.last.B a \u2192 P.W \u03b1) : P.W \u03b1 :=\n  let g : P.last.B a \u2192 P.last.W := fun i => (f i).fst\n  let g' : P.WPath \u27e8a, g\u27e9 \u27f9 \u03b1 := P.wPathCasesOn f' fun i => (f i).snd\n  \u27e8\u27e8a, g\u27e9, g'\u27e9", "start": [186, 1], "end": [190, 15], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wRec", "code": "def wRec {\u03b1 : TypeVec n} {C : Type*}\n    (g : \u2200 a : P.A, P.drop.B a \u27f9 \u03b1 \u2192 (P.last.B a \u2192 P.W \u03b1) \u2192 (P.last.B a \u2192 C) \u2192 C) : P.W \u03b1 \u2192 C\n  | \u27e8a, f'\u27e9 =>\n    let g' (a : P.A) (f : P.last.B a \u2192 P.last.W) (h : P.WPath \u27e8a, f\u27e9 \u27f9 \u03b1)\n      (h' : P.last.B a \u2192 C) : C :=\n      g a (P.wPathDestLeft h) (fun i => \u27e8f i, P.wPathDestRight h i\u27e9) h'\n    P.wpRec g' a f'", "start": [194, 1], "end": [201, 20], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wRec_eq", "code": "theorem wRec_eq {\u03b1 : TypeVec n} {C : Type*}\n    (g : \u2200 a : P.A, P.drop.B a \u27f9 \u03b1 \u2192 (P.last.B a \u2192 P.W \u03b1) \u2192 (P.last.B a \u2192 C) \u2192 C) (a : P.A)\n    (f' : P.drop.B a \u27f9 \u03b1) (f : P.last.B a \u2192 P.W \u03b1) :\n    P.wRec g (P.wMk a f' f) = g a f' f fun i => P.wRec g (f i)", "start": [205, 1], "end": [212, 8], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.w_ind", "code": "theorem w_ind {\u03b1 : TypeVec n} {C : P.W \u03b1 \u2192 Prop}\n    (ih : \u2200 (a : P.A) (f' : P.drop.B a \u27f9 \u03b1) (f : P.last.B a \u2192 P.W \u03b1),\n        (\u2200 i, C (f i)) \u2192 C (P.wMk a f' f)) :\n    \u2200 x, C x", "start": [216, 1], "end": [228, 12], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.w_cases", "code": "theorem w_cases {\u03b1 : TypeVec n} {C : P.W \u03b1 \u2192 Prop}\n    (ih : \u2200 (a : P.A) (f' : P.drop.B a \u27f9 \u03b1) (f : P.last.B a \u2192 P.W \u03b1), C (P.wMk a f' f)) :\n    \u2200 x, C x", "start": [232, 1], "end": [234, 53], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wMap", "code": "def wMap {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) : P.W \u03b1 \u2192 P.W \u03b2 := fun x => g <$$> x", "start": [238, 1], "end": [239, 76], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wMk_eq", "code": "theorem wMk_eq {\u03b1 : TypeVec n} (a : P.A) (f : P.last.B a \u2192 P.last.W) (g' : P.drop.B a \u27f9 \u03b1)\n    (g : \u2200 j : P.last.B a, P.WPath (f j) \u27f9 \u03b1) :\n    (P.wMk a g' fun i => \u27e8f i, g i\u27e9) = \u27e8\u27e8a, f\u27e9, P.wPathCasesOn g' g\u27e9", "start": [243, 1], "end": [245, 76], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.w_map_wMk", "code": "theorem w_map_wMk {\u03b1 \u03b2 : TypeVec n} (g : \u03b1 \u27f9 \u03b2) (a : P.A) (f' : P.drop.B a \u27f9 \u03b1)\n    (f : P.last.B a \u2192 P.W \u03b1) : g <$$> P.wMk a f' f = P.wMk a (g \u229a f') fun i => g <$$> f i", "start": [249, 1], "end": [266, 28], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.objAppend1", "code": "@[reducible]\ndef objAppend1 {\u03b1 : TypeVec n} {\u03b2 : Type u} (a : P.A) (f' : P.drop.B a \u27f9 \u03b1)\n    (f : P.last.B a \u2192 \u03b2) : P (\u03b1 ::: \u03b2) :=\n  \u27e8a, splitFun f' f\u27e9", "start": [272, 1], "end": [277, 21], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.map_objAppend1", "code": "theorem map_objAppend1 {\u03b1 \u03b3 : TypeVec n} (g : \u03b1 \u27f9 \u03b3) (a : P.A) (f' : P.drop.B a \u27f9 \u03b1)\n    (f : P.last.B a \u2192 P.W \u03b1) :\n    appendFun g (P.wMap g) <$$> P.objAppend1 a f' f =\n      P.objAppend1 a (g \u229a f') fun x => P.wMap g (f x)", "start": [280, 1], "end": [284, 74], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wMk'", "code": "def wMk' {\u03b1 : TypeVec n} : P (\u03b1 ::: P.W \u03b1) \u2192 P.W \u03b1\n  | \u27e8a, f\u27e9 => P.wMk a (dropFun f) (lastFun f)", "start": [294, 1], "end": [296, 46], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wDest'", "code": "def wDest' {\u03b1 : TypeVec.{u} n} : P.W \u03b1 \u2192 P (\u03b1.append1 (P.W \u03b1)) :=\n  P.wRec fun a f' f _ => \u27e8a, splitFun f' f\u27e9", "start": [300, 1], "end": [302, 44], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wDest'_wMk", "code": "theorem wDest'_wMk {\u03b1 : TypeVec n} (a : P.A) (f' : P.drop.B a \u27f9 \u03b1) (f : P.last.B a \u2192 P.W \u03b1) :\n    P.wDest' (P.wMk a f' f) = \u27e8a, splitFun f' f\u27e9", "start": [306, 1], "end": [307, 76], "kind": "commanddeclaration"}, {"full_name": "MvPFunctor.wDest'_wMk'", "code": "theorem wDest'_wMk' {\u03b1 : TypeVec n} (x : P (\u03b1.append1 (P.W \u03b1))) : P.wDest' (P.wMk' x) = x", "start": [311, 1], "end": [312, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/ZFC/Basic.lean", "imports": ["Mathlib/Logic/Function/OfArity.lean", "Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Small/Basic.lean", "Mathlib/Order/WellFounded.lean"], "premises": [{"full_name": "PSet", "code": "inductive PSet : Type (u + 1)\n  | mk (\u03b1 : Type u) (A : \u03b1 \u2192 PSet) : PSet", "start": [69, 1], "end": [74, 42], "kind": "commanddeclaration"}, {"full_name": "PSet.Type", "code": "def \u00abType\u00bb : PSet \u2192 Type u\n  | \u27e8\u03b1, _\u27e9 => \u03b1", "start": [79, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "PSet.Func", "code": "def Func : \u2200 x : PSet, x.Type \u2192 PSet\n  | \u27e8_, A\u27e9 => A", "start": [84, 1], "end": [86, 16], "kind": "commanddeclaration"}, {"full_name": "PSet.mk_type", "code": "@[simp]\ntheorem mk_type (\u03b1 A) : \u00abType\u00bb \u27e8\u03b1, A\u27e9 = \u03b1", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "PSet.mk_func", "code": "@[simp]\ntheorem mk_func (\u03b1 A) : Func \u27e8\u03b1, A\u27e9 = A", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "PSet.eta", "code": "@[simp]\ntheorem eta : \u2200 x : PSet, mk x.Type x.Func = x", "start": [99, 1], "end": [101, 18], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv", "code": "def Equiv : PSet \u2192 PSet \u2192 Prop\n  | \u27e8_, A\u27e9, \u27e8_, B\u27e9 => (\u2200 a, \u2203 b, Equiv (A a) (B b)) \u2227 (\u2200 b, \u2203 a, Equiv (A a) (B b))", "start": [104, 1], "end": [107, 84], "kind": "commanddeclaration"}, {"full_name": "PSet.equiv_iff", "code": "theorem equiv_iff :\n    \u2200 {x y : PSet},\n      Equiv x y \u2194 (\u2200 i, \u2203 j, Equiv (x.Func i) (y.Func j)) \u2227 \u2200 j, \u2203 i, Equiv (x.Func i) (y.Func j)", "start": [110, 1], "end": [113, 30], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.exists_left", "code": "theorem Equiv.exists_left {x y : PSet} (h : Equiv x y) : \u2200 i, \u2203 j, Equiv (x.Func i) (y.Func j)", "start": [116, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.exists_right", "code": "theorem Equiv.exists_right {x y : PSet} (h : Equiv x y) : \u2200 j, \u2203 i, Equiv (x.Func i) (y.Func j)", "start": [120, 1], "end": [121, 20], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.refl", "code": "@[refl]\nprotected theorem Equiv.refl : \u2200 x, Equiv x x", "start": [124, 1], "end": [126, 71], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.rfl", "code": "protected theorem Equiv.rfl {x} : Equiv x x", "start": [129, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.euc", "code": "protected theorem Equiv.euc : \u2200 {x y z}, Equiv x y \u2192 Equiv z y \u2192 Equiv x z", "start": [133, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.symm", "code": "@[symm]\nprotected theorem Equiv.symm {x y} : Equiv x y \u2192 Equiv y x", "start": [145, 1], "end": [147, 21], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.comm", "code": "protected theorem Equiv.comm {x y} : Equiv x y \u2194 Equiv y x", "start": [150, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.trans", "code": "@[trans]\nprotected theorem Equiv.trans {x y z} (h1 : Equiv x y) (h2 : Equiv y z) : Equiv x z", "start": [154, 1], "end": [156, 17], "kind": "commanddeclaration"}, {"full_name": "PSet.equiv_of_isEmpty", "code": "protected theorem equiv_of_isEmpty (x y : PSet) [IsEmpty x.Type] [IsEmpty y.Type] : Equiv x y", "start": [159, 1], "end": [160, 25], "kind": "commanddeclaration"}, {"full_name": "PSet.setoid", "code": "instance setoid : Setoid PSet :=\n  \u27e8PSet.Equiv, Equiv.refl, Equiv.symm, Equiv.trans\u27e9", "start": [163, 1], "end": [164, 52], "kind": "commanddeclaration"}, {"full_name": "PSet.Subset", "code": "protected def Subset (x y : PSet) : Prop :=\n  \u2200 a, \u2203 b, Equiv (x.Func a) (y.Func b)", "start": [167, 1], "end": [170, 40], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.ext", "code": "theorem Equiv.ext : \u2200 x y : PSet, Equiv x y \u2194 x \u2286 y \u2227 y \u2286 x", "start": [185, 1], "end": [194, 28], "kind": "commanddeclaration"}, {"full_name": "PSet.Subset.congr_left", "code": "theorem Subset.congr_left : \u2200 {x y z : PSet}, Equiv x y \u2192 (x \u2286 z \u2194 y \u2286 z)", "start": [197, 1], "end": [206, 30], "kind": "commanddeclaration"}, {"full_name": "PSet.Subset.congr_right", "code": "theorem Subset.congr_right : \u2200 {x y z : PSet}, Equiv x y \u2192 (z \u2286 x \u2194 z \u2286 y)", "start": [209, 1], "end": [218, 37], "kind": "commanddeclaration"}, {"full_name": "PSet.Mem", "code": "protected def Mem (x y : PSet.{u}) : Prop :=\n  \u2203 b, Equiv x (y.Func b)", "start": [221, 1], "end": [223, 26], "kind": "commanddeclaration"}, {"full_name": "PSet.Mem.mk", "code": "theorem Mem.mk {\u03b1 : Type u} (A : \u03b1 \u2192 PSet) (a : \u03b1) : A a \u2208 mk \u03b1 A", "start": [229, 1], "end": [230, 24], "kind": "commanddeclaration"}, {"full_name": "PSet.func_mem", "code": "theorem func_mem (x : PSet) (i : x.Type) : x.Func i \u2208 x", "start": [233, 1], "end": [235, 15], "kind": "commanddeclaration"}, {"full_name": "PSet.Mem.ext", "code": "theorem Mem.ext : \u2200 {x y : PSet.{u}}, (\u2200 w : PSet.{u}, w \u2208 x \u2194 w \u2208 y) \u2192 Equiv x y", "start": [238, 1], "end": [242, 20], "kind": "commanddeclaration"}, {"full_name": "PSet.Mem.congr_right", "code": "theorem Mem.congr_right : \u2200 {x y : PSet.{u}}, Equiv x y \u2192 \u2200 {w : PSet.{u}}, w \u2208 x \u2194 w \u2208 y", "start": [245, 1], "end": [252, 22], "kind": "commanddeclaration"}, {"full_name": "PSet.equiv_iff_mem", "code": "theorem equiv_iff_mem {x y : PSet.{u}} : Equiv x y \u2194 \u2200 {w : PSet.{u}}, w \u2208 x \u2194 w \u2208 y", "start": [255, 1], "end": [261, 22], "kind": "commanddeclaration"}, {"full_name": "PSet.Mem.congr_left", "code": "theorem Mem.congr_left : \u2200 {x y : PSet.{u}}, Equiv x y \u2192 \u2200 {w : PSet.{u}}, x \u2208 w \u2194 y \u2208 w", "start": [264, 1], "end": [265, 93], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_wf_aux", "code": "private theorem mem_wf_aux : \u2200 {x y : PSet.{u}}, Equiv x y \u2192 Acc (\u00b7 \u2208 \u00b7) y", "start": [268, 1], "end": [275, 26], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_wf", "code": "theorem mem_wf : @WellFounded PSet (\u00b7 \u2208 \u00b7)", "start": [277, 1], "end": [278, 40], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_asymm", "code": "theorem mem_asymm {x y : PSet} : x \u2208 y \u2192 y \u2209 x", "start": [290, 1], "end": [291, 8], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_irrefl", "code": "theorem mem_irrefl (x : PSet) : x \u2209 x", "start": [294, 1], "end": [295, 11], "kind": "commanddeclaration"}, {"full_name": "PSet.toSet", "code": "def toSet (u : PSet.{u}) : Set PSet.{u} :=\n  { x | x \u2208 u }", "start": [298, 1], "end": [300, 16], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_toSet", "code": "@[simp]\ntheorem mem_toSet (a u : PSet.{u}) : a \u2208 u.toSet \u2194 a \u2208 u", "start": [303, 1], "end": [305, 10], "kind": "commanddeclaration"}, {"full_name": "PSet.Nonempty", "code": "protected def Nonempty (u : PSet) : Prop :=\n  u.toSet.Nonempty", "start": [308, 1], "end": [310, 19], "kind": "commanddeclaration"}, {"full_name": "PSet.nonempty_def", "code": "theorem nonempty_def (u : PSet) : u.Nonempty \u2194 \u2203 x, x \u2208 u", "start": [313, 1], "end": [314, 10], "kind": "commanddeclaration"}, {"full_name": "PSet.nonempty_of_mem", "code": "theorem nonempty_of_mem {x u : PSet} (h : x \u2208 u) : u.Nonempty", "start": [317, 1], "end": [318, 9], "kind": "commanddeclaration"}, {"full_name": "PSet.nonempty_toSet_iff", "code": "@[simp]\ntheorem nonempty_toSet_iff {u : PSet} : u.toSet.Nonempty \u2194 u.Nonempty", "start": [321, 1], "end": [323, 10], "kind": "commanddeclaration"}, {"full_name": "PSet.nonempty_type_iff_nonempty", "code": "theorem nonempty_type_iff_nonempty {x : PSet} : Nonempty x.Type \u2194 PSet.Nonempty x", "start": [326, 1], "end": [327, 55], "kind": "commanddeclaration"}, {"full_name": "PSet.nonempty_of_nonempty_type", "code": "theorem nonempty_of_nonempty_type (x : PSet) [h : Nonempty x.Type] : PSet.Nonempty x", "start": [330, 1], "end": [331, 33], "kind": "commanddeclaration"}, {"full_name": "PSet.Equiv.eq", "code": "theorem Equiv.eq {x y : PSet} : Equiv x y \u2194 toSet x = toSet y", "start": [334, 1], "end": [336, 39], "kind": "commanddeclaration"}, {"full_name": "PSet.empty", "code": "protected def empty : PSet :=\n  \u27e8_, PEmpty.elim\u27e9", "start": [342, 1], "end": [344, 19], "kind": "commanddeclaration"}, {"full_name": "PSet.not_mem_empty", "code": "@[simp]\ntheorem not_mem_empty (x : PSet.{u}) : x \u2209 (\u2205 : PSet.{u})", "start": [356, 1], "end": [358, 23], "kind": "commanddeclaration"}, {"full_name": "PSet.toSet_empty", "code": "@[simp]\ntheorem toSet_empty : toSet \u2205 = \u2205", "start": [361, 1], "end": [362, 53], "kind": "commanddeclaration"}, {"full_name": "PSet.empty_subset", "code": "@[simp]\ntheorem empty_subset (x : PSet.{u}) : (\u2205 : PSet) \u2286 x", "start": [365, 1], "end": [366, 72], "kind": "commanddeclaration"}, {"full_name": "PSet.not_nonempty_empty", "code": "@[simp]\ntheorem not_nonempty_empty : \u00acPSet.Nonempty \u2205", "start": [369, 1], "end": [370, 73], "kind": "commanddeclaration"}, {"full_name": "PSet.equiv_empty", "code": "protected theorem equiv_empty (x : PSet) [IsEmpty x.Type] : Equiv x \u2205", "start": [373, 1], "end": [374, 28], "kind": "commanddeclaration"}, {"full_name": "PSet.insert", "code": "protected def insert (x y : PSet) : PSet :=\n  \u27e8Option y.Type, fun o => Option.casesOn o x y.Func\u27e9", "start": [377, 1], "end": [379, 54], "kind": "commanddeclaration"}, {"full_name": "PSet.ofNat", "code": "def ofNat : \u2115 \u2192 PSet\n  | 0 => \u2205\n  | n + 1 => insert (ofNat n) (ofNat n)", "start": [394, 1], "end": [397, 40], "kind": "commanddeclaration"}, {"full_name": "PSet.omega", "code": "def omega : PSet :=\n  \u27e8ULift \u2115, fun n => ofNat n.down\u27e9", "start": [400, 1], "end": [402, 35], "kind": "commanddeclaration"}, {"full_name": "PSet.sep", "code": "protected def sep (p : PSet \u2192 Prop) (x : PSet) : PSet :=\n  \u27e8{ a // p (x.Func a) }, fun y => x.Func y.1\u27e9", "start": [405, 1], "end": [407, 47], "kind": "commanddeclaration"}, {"full_name": "PSet.powerset", "code": "def powerset (x : PSet) : PSet :=\n  \u27e8Set x.Type, fun p => \u27e8{ a // p a }, fun y => x.Func y.1\u27e9\u27e9", "start": [413, 1], "end": [415, 61], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_powerset", "code": "@[simp]\ntheorem mem_powerset : \u2200 {x y : PSet}, y \u2208 powerset x \u2194 y \u2286 x", "start": [418, 1], "end": [425, 36], "kind": "commanddeclaration"}, {"full_name": "PSet.sUnion", "code": "def sUnion (a : PSet) : PSet :=\n  \u27e8\u03a3x, (a.Func x).Type, fun \u27e8x, y\u27e9 => (a.Func x).Func y\u27e9", "start": [428, 1], "end": [430, 57], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_sUnion", "code": "@[simp]\ntheorem mem_sUnion : \u2200 {x y : PSet.{u}}, y \u2208 \u22c3\u2080 x \u2194 \u2203 z \u2208 x, y \u2208 z", "start": [436, 1], "end": [447, 31], "kind": "commanddeclaration"}, {"full_name": "PSet.toSet_sUnion", "code": "@[simp]\ntheorem toSet_sUnion (x : PSet.{u}) : (\u22c3\u2080 x).toSet = \u22c3\u2080 (toSet '' x.toSet)", "start": [450, 1], "end": [453, 7], "kind": "commanddeclaration"}, {"full_name": "PSet.image", "code": "def image (f : PSet.{u} \u2192 PSet.{u}) (x : PSet.{u}) : PSet :=\n  \u27e8x.Type, f \u2218 x.Func\u27e9", "start": [456, 1], "end": [458, 23], "kind": "commanddeclaration"}, {"full_name": "PSet.mem_image", "code": "theorem mem_image {f : PSet.{u} \u2192 PSet.{u}} (H : \u2200 x y, Equiv x y \u2192 Equiv (f x) (f y)) :\n    \u2200 {x y : PSet.{u}}, y \u2208 image f x \u2194 \u2203 z \u2208 x, Equiv y (f z)", "start": [462, 1], "end": [465, 94], "kind": "commanddeclaration"}, {"full_name": "PSet.Lift", "code": "protected def Lift : PSet.{u} \u2192 PSet.{max u v}\n  | \u27e8\u03b1, A\u27e9 => \u27e8ULift.{v, u} \u03b1, fun \u27e8x\u27e9 => PSet.Lift (A x)\u27e9", "start": [468, 1], "end": [470, 59], "kind": "commanddeclaration"}, {"full_name": "PSet.embed", "code": "@[nolint checkUnivs]\ndef embed : PSet.{max (u + 1) v} :=\n  \u27e8ULift.{v, u + 1} PSet, fun \u27e8x\u27e9 => PSet.Lift.{u, max (u + 1) v} x\u27e9", "start": [474, 1], "end": [477, 69], "kind": "commanddeclaration"}, {"full_name": "PSet.lift_mem_embed", "code": "theorem lift_mem_embed : \u2200 x : PSet.{u}, PSet.Lift.{u, max (u + 1) v} x \u2208 embed.{u, v}", "start": [480, 1], "end": [481, 19], "kind": "commanddeclaration"}, {"full_name": "PSet.Arity.Equiv", "code": "def Arity.Equiv : \u2200 {n}, OfArity PSet.{u} n \u2192 OfArity PSet.{u} n \u2192 Prop\n  | 0, a, b => PSet.Equiv a b\n  | _ + 1, a, b => \u2200 x y : PSet, PSet.Equiv x y \u2192 Arity.Equiv (a x) (b y)", "start": [484, 1], "end": [488, 74], "kind": "commanddeclaration"}, {"full_name": "PSet.Arity.equiv_const", "code": "theorem Arity.equiv_const {a : PSet.{u}} : \u2200 n, Arity.Equiv (OfArity.const a n) (OfArity.const a n)", "start": [491, 1], "end": [493, 46], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp", "code": "def Resp (n) :=\n  { x : OfArity PSet.{u} n // Arity.Equiv x x }", "start": [496, 1], "end": [499, 48], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.inhabited", "code": "instance Resp.inhabited {n} : Inhabited (Resp n) :=\n  \u27e8\u27e8OfArity.const default _, Arity.equiv_const _\u27e9\u27e9", "start": [502, 1], "end": [503, 51], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.f", "code": "def Resp.f {n} (f : Resp (n + 1)) (x : PSet) : Resp n :=\n  \u27e8f.1 x, f.2 _ _ <| Equiv.refl x\u27e9", "start": [506, 1], "end": [509, 35], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.Equiv", "code": "def Resp.Equiv {n} (a b : Resp n) : Prop :=\n  Arity.Equiv a.1 b.1", "start": [512, 1], "end": [514, 22], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.Equiv.refl", "code": "@[refl]\nprotected theorem Resp.Equiv.refl {n} (a : Resp n) : Resp.Equiv a a", "start": [517, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.Equiv.euc", "code": "protected theorem Resp.Equiv.euc :\n    \u2200 {n} {a b c : Resp n}, Resp.Equiv a b \u2192 Resp.Equiv c b \u2192 Resp.Equiv a c", "start": [522, 1], "end": [526, 89], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.Equiv.symm", "code": "@[symm]\nprotected theorem Resp.Equiv.symm {n} {a b : Resp n} : Resp.Equiv a b \u2192 Resp.Equiv b a", "start": [529, 1], "end": [531, 26], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.Equiv.trans", "code": "@[trans]\nprotected theorem Resp.Equiv.trans {n} {x y z : Resp n} (h1 : Resp.Equiv x y)\n    (h2 : Resp.Equiv y z) : Resp.Equiv x z", "start": [534, 1], "end": [537, 17], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.setoid", "code": "instance Resp.setoid {n} : Setoid (Resp n) :=\n  \u27e8Resp.Equiv, Resp.Equiv.refl, Resp.Equiv.symm, Resp.Equiv.trans\u27e9", "start": [540, 1], "end": [541, 67], "kind": "commanddeclaration"}, {"full_name": "ZFSet", "code": "def ZFSet : Type (u + 1) :=\n  Quotient PSet.setoid.{u}", "start": [546, 1], "end": [549, 27], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.evalAux", "code": "def evalAux :\n    \u2200 {n}, { f : Resp n \u2192 OfArity ZFSet.{u} n // \u2200 a b : Resp n, Resp.Equiv a b \u2192 f a = f b }\n  | 0 => \u27e8fun a => \u27e6a.1\u27e7, fun _ _ h => Quotient.sound h\u27e9\n  | n + 1 =>\n    let F : Resp (n + 1) \u2192 OfArity ZFSet (n + 1) := fun a =>\n      @Quotient.lift _ _ PSet.setoid (fun x => evalAux.1 (a.f x)) fun _ _ h =>\n        evalAux.2 _ _ (a.2 _ _ h)\n    \u27e8F, fun b c h =>\n      funext <|\n        (@Quotient.ind _ _ fun q => F b q = F c q) fun z =>\n          evalAux.2 (Resp.f b z) (Resp.f c z) (h _ _ (PSet.Equiv.refl z))\u27e9", "start": [556, 1], "end": [567, 75], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.eval", "code": "def eval (n) : Resp n \u2192 OfArity ZFSet.{u} n :=\n  evalAux.1", "start": [570, 1], "end": [572, 12], "kind": "commanddeclaration"}, {"full_name": "PSet.Resp.eval_val", "code": "theorem eval_val {n f x} : (@eval (n + 1) f : ZFSet \u2192 OfArity ZFSet n) \u27e6x\u27e7 = eval n (Resp.f f x)", "start": [575, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "PSet.Definable", "code": "class inductive Definable (n) : OfArity ZFSet.{u} n \u2192 Type (u + 1)\n  | mk (f) : Definable n (Resp.eval n f)", "start": [581, 1], "end": [585, 41], "kind": "commanddeclaration"}, {"full_name": "PSet.Definable.EqMk", "code": "def Definable.EqMk {n} (f) : \u2200 {s : OfArity ZFSet.{u} n} (_ : Resp.eval _ f = s), Definable n s\n  | _, rfl => \u27e8f\u27e9", "start": [590, 1], "end": [592, 18], "kind": "commanddeclaration"}, {"full_name": "PSet.Definable.Resp", "code": "def Definable.Resp {n} : \u2200 (s : OfArity ZFSet.{u} n) [Definable n s], Resp n\n  | _, \u27e8f\u27e9 => f", "start": [595, 1], "end": [597, 16], "kind": "commanddeclaration"}, {"full_name": "PSet.Definable.eq", "code": "theorem Definable.eq {n} :\n    \u2200 (s : OfArity ZFSet.{u} n) [H : Definable n s], (@Definable.Resp n s H).eval _ = s", "start": [600, 1], "end": [602, 18], "kind": "commanddeclaration"}, {"full_name": "Classical.allDefinable", "code": "noncomputable def allDefinable : \u2200 {n} (F : OfArity ZFSet n), Definable n F\n  | 0, F =>\n    let p := @Quotient.exists_rep PSet _ F\n    @Definable.EqMk 0 \u27e8choose p, Equiv.rfl\u27e9 _ (choose_spec p)\n  | n + 1, (F : OfArity ZFSet (n + 1)) => by\n    have I := fun x => allDefinable (F x)\n    refine' @Definable.EqMk (n + 1) \u27e8fun x : PSet => (@Definable.Resp _ _ (I \u27e6x\u27e7)).1, _\u27e9 _ _\n    \u00b7 dsimp [Arity.Equiv]\n      intro x y h\n      rw [@Quotient.sound PSet _ _ _ h]\n      exact (Definable.Resp (F \u27e6y\u27e7)).2\n    refine' funext fun q => Quotient.inductionOn q fun x => _\n    simp_rw [Resp.eval_val, Resp.f]\n    exact @Definable.eq _ (F \u27e6x\u27e7) (I \u27e6x\u27e7)", "start": [611, 1], "end": [625, 42], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mk", "code": "def mk : PSet \u2192 ZFSet :=\n  Quotient.mk''", "start": [634, 1], "end": [636, 16], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mk_eq", "code": "@[simp]\ntheorem mk_eq (x : PSet) : @Eq ZFSet \u27e6x\u27e7 (mk x)", "start": [639, 1], "end": [641, 6], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mk_out", "code": "@[simp]\ntheorem mk_out : \u2200 x : ZFSet, mk x.out = x", "start": [644, 1], "end": [646, 18], "kind": "commanddeclaration"}, {"full_name": "ZFSet.eq", "code": "theorem eq {x y : PSet} : mk x = mk y \u2194 Equiv x y", "start": [649, 1], "end": [650, 14], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sound", "code": "theorem sound {x y : PSet} (h : PSet.Equiv x y) : mk x = mk y", "start": [653, 1], "end": [654, 19], "kind": "commanddeclaration"}, {"full_name": "ZFSet.exact", "code": "theorem exact {x y : PSet} : mk x = mk y \u2192 PSet.Equiv x y", "start": [657, 1], "end": [658, 17], "kind": "commanddeclaration"}, {"full_name": "ZFSet.eval_mk", "code": "@[simp]\ntheorem eval_mk {n f x} :\n    (@Resp.eval (n + 1) f : ZFSet \u2192 OfArity ZFSet n) (mk x) = Resp.eval n (Resp.f f x)", "start": [661, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Mem", "code": "protected def Mem : ZFSet \u2192 ZFSet \u2192 Prop :=\n  Quotient.lift\u2082 PSet.Mem fun _ _ _ _ hx hy =>\n    propext ((Mem.congr_left hx).trans (Mem.congr_right hy))", "start": [667, 1], "end": [670, 61], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mk_mem_iff", "code": "@[simp]\ntheorem mk_mem_iff {x y : PSet} : mk x \u2208 mk y \u2194 x \u2208 y", "start": [676, 1], "end": [678, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet", "code": "def toSet (u : ZFSet.{u}) : Set ZFSet.{u} :=\n  { x | x \u2208 u }", "start": [681, 1], "end": [683, 16], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_toSet", "code": "@[simp]\ntheorem mem_toSet (a u : ZFSet.{u}) : a \u2208 u.toSet \u2194 a \u2208 u", "start": [686, 1], "end": [688, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.small_toSet", "code": "instance small_toSet (x : ZFSet.{u}) : Small.{u} x.toSet :=\n  Quotient.inductionOn x fun a => by\n    let f : a.Type \u2192 (mk a).toSet := fun i => \u27e8mk <| a.Func i, func_mem a i\u27e9\n    suffices Function.Surjective f by exact small_of_surjective this\n    rintro \u27e8y, hb\u27e9\n    induction y using Quotient.inductionOn\n    cases' hb with i h\n    exact \u27e8i, Subtype.coe_injective (Quotient.sound h.symm)\u27e9", "start": [691, 1], "end": [698, 61], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Nonempty", "code": "protected def Nonempty (u : ZFSet) : Prop :=\n  u.toSet.Nonempty", "start": [701, 1], "end": [703, 19], "kind": "commanddeclaration"}, {"full_name": "ZFSet.nonempty_def", "code": "theorem nonempty_def (u : ZFSet) : u.Nonempty \u2194 \u2203 x, x \u2208 u", "start": [706, 1], "end": [707, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.nonempty_of_mem", "code": "theorem nonempty_of_mem {x u : ZFSet} (h : x \u2208 u) : u.Nonempty", "start": [710, 1], "end": [711, 9], "kind": "commanddeclaration"}, {"full_name": "ZFSet.nonempty_toSet_iff", "code": "@[simp]\ntheorem nonempty_toSet_iff {u : ZFSet} : u.toSet.Nonempty \u2194 u.Nonempty", "start": [714, 1], "end": [716, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Subset", "code": "protected def Subset (x y : ZFSet.{u}) :=\n  \u2200 \u2983z\u2984, z \u2208 x \u2192 z \u2208 y", "start": [719, 1], "end": [721, 23], "kind": "commanddeclaration"}, {"full_name": "ZFSet.hasSubset", "code": "instance hasSubset : HasSubset ZFSet :=\n  \u27e8ZFSet.Subset\u27e9", "start": [724, 1], "end": [725, 17], "kind": "commanddeclaration"}, {"full_name": "ZFSet.subset_def", "code": "theorem subset_def {x y : ZFSet.{u}} : x \u2286 y \u2194 \u2200 \u2983z\u2984, z \u2208 x \u2192 z \u2208 y", "start": [728, 1], "end": [729, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.subset_iff", "code": "@[simp]\ntheorem subset_iff : \u2200 {x y : PSet}, mk x \u2286 mk y \u2194 x \u2286 y", "start": [738, 1], "end": [744, 26], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_subset_iff", "code": "@[simp]\ntheorem toSet_subset_iff {x y : ZFSet} : x.toSet \u2286 y.toSet \u2194 x \u2286 y", "start": [747, 1], "end": [749, 36], "kind": "commanddeclaration"}, {"full_name": "ZFSet.ext", "code": "@[ext]\ntheorem ext {x y : ZFSet.{u}} : (\u2200 z : ZFSet.{u}, z \u2208 x \u2194 z \u2208 y) \u2192 x = y", "start": [752, 1], "end": [754, 81], "kind": "commanddeclaration"}, {"full_name": "ZFSet.ext_iff", "code": "theorem ext_iff {x y : ZFSet.{u}} : x = y \u2194 \u2200 z : ZFSet.{u}, z \u2208 x \u2194 z \u2208 y", "start": [757, 1], "end": [758, 30], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_injective", "code": "theorem toSet_injective : Function.Injective toSet", "start": [761, 1], "end": [761, 90], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_inj", "code": "@[simp]\ntheorem toSet_inj {x y : ZFSet} : x.toSet = y.toSet \u2194 x = y", "start": [764, 1], "end": [766, 25], "kind": "commanddeclaration"}, {"full_name": "ZFSet.empty", "code": "protected def empty : ZFSet :=\n  mk \u2205", "start": [772, 1], "end": [774, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.not_mem_empty", "code": "@[simp]\ntheorem not_mem_empty (x) : x \u2209 (\u2205 : ZFSet.{u})", "start": [783, 1], "end": [785, 44], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_empty", "code": "@[simp]\ntheorem toSet_empty : toSet \u2205 = \u2205", "start": [788, 1], "end": [789, 53], "kind": "commanddeclaration"}, {"full_name": "ZFSet.empty_subset", "code": "@[simp]\ntheorem empty_subset (x : ZFSet.{u}) : (\u2205 : ZFSet) \u2286 x", "start": [792, 1], "end": [794, 70], "kind": "commanddeclaration"}, {"full_name": "ZFSet.not_nonempty_empty", "code": "@[simp]\ntheorem not_nonempty_empty : \u00acZFSet.Nonempty \u2205", "start": [797, 1], "end": [798, 75], "kind": "commanddeclaration"}, {"full_name": "ZFSet.nonempty_mk_iff", "code": "@[simp]\ntheorem nonempty_mk_iff {x : PSet} : (mk x).Nonempty \u2194 x.Nonempty", "start": [801, 1], "end": [806, 15], "kind": "commanddeclaration"}, {"full_name": "ZFSet.eq_empty", "code": "theorem eq_empty (x : ZFSet.{u}) : x = \u2205 \u2194 \u2200 y : ZFSet.{u}, y \u2209 x", "start": [809, 1], "end": [811, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.eq_empty_or_nonempty", "code": "theorem eq_empty_or_nonempty (u : ZFSet) : u = \u2205 \u2228 u.Nonempty", "start": [814, 1], "end": [816, 12], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Insert", "code": "protected def Insert : ZFSet \u2192 ZFSet \u2192 ZFSet :=\n  Resp.eval 2\n    \u27e8PSet.insert, fun _ _ uv \u27e8_, _\u27e9 \u27e8_, _\u27e9 \u27e8\u03b1\u03b2, \u03b2\u03b1\u27e9 =>\n      \u27e8fun o =>\n        match o with\n        | some a =>\n          let \u27e8b, hb\u27e9 := \u03b1\u03b2 a\n          \u27e8some b, hb\u27e9\n        | none => \u27e8none, uv\u27e9,\n        fun o =>\n        match o with\n        | some b =>\n          let \u27e8a, ha\u27e9 := \u03b2\u03b1 b\n          \u27e8some a, ha\u27e9\n        | none => \u27e8none, uv\u27e9\u27e9\u27e9", "start": [819, 1], "end": [834, 31], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_insert_iff", "code": "@[simp]\ntheorem mem_insert_iff {x y z : ZFSet.{u}} : x \u2208 insert y z \u2194 x = y \u2228 x \u2208 z", "start": [846, 1], "end": [857, 48], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_insert", "code": "theorem mem_insert (x y : ZFSet) : x \u2208 insert x y", "start": [860, 1], "end": [861, 33], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_insert_of_mem", "code": "theorem mem_insert_of_mem {y z : ZFSet} (x) (h : z \u2208 y) : z \u2208 insert x y", "start": [864, 1], "end": [865, 31], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_insert", "code": "@[simp]\ntheorem toSet_insert (x y : ZFSet) : (insert x y).toSet = insert x y.toSet", "start": [868, 1], "end": [871, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_singleton", "code": "@[simp]\ntheorem mem_singleton {x y : ZFSet.{u}} : x \u2208 @singleton ZFSet.{u} ZFSet.{u} _ y \u2194 x = y", "start": [874, 1], "end": [877, 83], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_singleton", "code": "@[simp]\ntheorem toSet_singleton (x : ZFSet) : ({x} : ZFSet).toSet = {x}", "start": [880, 1], "end": [883, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.insert_nonempty", "code": "theorem insert_nonempty (u v : ZFSet) : (insert u v).Nonempty", "start": [886, 1], "end": [887, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.singleton_nonempty", "code": "theorem singleton_nonempty (u : ZFSet) : ZFSet.Nonempty {u}", "start": [890, 1], "end": [891, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_pair", "code": "theorem mem_pair {x y z : ZFSet.{u}} : x \u2208 ({y, z} : ZFSet) \u2194 x = y \u2228 x = z", "start": [894, 1], "end": [895, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.omega", "code": "def omega : ZFSet :=\n  mk PSet.omega", "start": [898, 1], "end": [900, 16], "kind": "commanddeclaration"}, {"full_name": "ZFSet.omega_zero", "code": "@[simp]\ntheorem omega_zero : \u2205 \u2208 omega", "start": [903, 1], "end": [905, 19], "kind": "commanddeclaration"}, {"full_name": "ZFSet.omega_succ", "code": "@[simp]\ntheorem omega_succ {n} : n \u2208 omega.{u} \u2192 insert n n \u2208 omega.{u}", "start": [908, 1], "end": [915, 15], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sep", "code": "protected def sep (p : ZFSet \u2192 Prop) : ZFSet \u2192 ZFSet :=\n  Resp.eval 1\n    \u27e8PSet.sep fun y => p (mk y), fun \u27e8\u03b1, A\u27e9 \u27e8\u03b2, B\u27e9 \u27e8\u03b1\u03b2, \u03b2\u03b1\u27e9 =>\n      \u27e8fun \u27e8a, pa\u27e9 =>\n        let \u27e8b, hb\u27e9 := \u03b1\u03b2 a\n        \u27e8\u27e8b, by simpa only [mk_func, \u2190 ZFSet.sound hb]\u27e9, hb\u27e9,\n        fun \u27e8b, pb\u27e9 =>\n        let \u27e8a, ha\u27e9 := \u03b2\u03b1 b\n        \u27e8\u27e8a, by simpa only [mk_func, ZFSet.sound ha]\u27e9, ha\u27e9\u27e9\u27e9", "start": [918, 1], "end": [927, 61], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_sep", "code": "@[simp]\ntheorem mem_sep {p : ZFSet.{u} \u2192 Prop} {x y : ZFSet.{u}} :\n    y \u2208 ZFSet.sep p x \u2194 y \u2208 x \u2227 p y", "start": [934, 1], "end": [942, 12], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_sep", "code": "@[simp]\ntheorem toSet_sep (a : ZFSet) (p : ZFSet \u2192 Prop) :\n    (ZFSet.sep p a).toSet = { x \u2208 a.toSet | p x }", "start": [945, 1], "end": [949, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.powerset", "code": "def powerset : ZFSet \u2192 ZFSet :=\n  Resp.eval 1\n    \u27e8PSet.powerset, fun \u27e8_, A\u27e9 \u27e8_, B\u27e9 \u27e8\u03b1\u03b2, \u03b2\u03b1\u27e9 =>\n      \u27e8fun p =>\n        \u27e8{ b | \u2203 a, p a \u2227 Equiv (A a) (B b) }, fun \u27e8a, pa\u27e9 =>\n          let \u27e8b, ab\u27e9 := \u03b1\u03b2 a\n          \u27e8\u27e8b, a, pa, ab\u27e9, ab\u27e9,\n          fun \u27e8_, a, pa, ab\u27e9 => \u27e8\u27e8a, pa\u27e9, ab\u27e9\u27e9,\n        fun q =>\n        \u27e8{ a | \u2203 b, q b \u2227 Equiv (A a) (B b) }, fun \u27e8_, b, qb, ab\u27e9 => \u27e8\u27e8b, qb\u27e9, ab\u27e9, fun \u27e8b, qb\u27e9 =>\n          let \u27e8a, ab\u27e9 := \u03b2\u03b1 b\n          \u27e8\u27e8a, b, qb, ab\u27e9, ab\u27e9\u27e9\u27e9\u27e9", "start": [952, 1], "end": [964, 34], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_powerset", "code": "@[simp]\ntheorem mem_powerset {x y : ZFSet.{u}} : y \u2208 powerset x \u2194 y \u2286 x", "start": [967, 1], "end": [970, 95], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sUnion_lem", "code": "theorem sUnion_lem {\u03b1 \u03b2 : Type u} (A : \u03b1 \u2192 PSet) (B : \u03b2 \u2192 PSet) (\u03b1\u03b2 : \u2200 a, \u2203 b, Equiv (A a) (B b)) :\n    \u2200 a, \u2203 b, Equiv ((sUnion \u27e8\u03b1, A\u27e9).Func a) ((sUnion \u27e8\u03b2, B\u27e9).Func b)", "start": [973, 1], "end": [986, 43], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sUnion", "code": "def sUnion : ZFSet \u2192 ZFSet :=\n  Resp.eval 1\n    \u27e8PSet.sUnion, fun \u27e8_, A\u27e9 \u27e8_, B\u27e9 \u27e8\u03b1\u03b2, \u03b2\u03b1\u27e9 =>\n      \u27e8sUnion_lem A B \u03b1\u03b2, fun a =>\n        Exists.elim\n          (sUnion_lem B A (fun b => Exists.elim (\u03b2\u03b1 b) fun c hc => \u27e8c, PSet.Equiv.symm hc\u27e9) a)\n          fun b hb => \u27e8b, PSet.Equiv.symm hb\u27e9\u27e9\u27e9", "start": [989, 1], "end": [996, 48], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sInter", "code": "noncomputable def sInter (x : ZFSet) : ZFSet := by\n   classical exact if h : x.Nonempty then ZFSet.sep (fun y => \u2200 z \u2208 x, y \u2208 z) h.some else \u2205", "start": [1002, 1], "end": [1005, 92], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_sUnion", "code": "@[simp]\ntheorem mem_sUnion {x y : ZFSet.{u}} : y \u2208 \u22c3\u2080 x \u2194 \u2203 z \u2208 x, y \u2208 z", "start": [1011, 1], "end": [1015, 91], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_sInter", "code": "theorem mem_sInter {x y : ZFSet} (h : x.Nonempty) : y \u2208 \u22c2\u2080 x \u2194 \u2200 z \u2208 x, y \u2208 z", "start": [1018, 1], "end": [1021, 32], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sUnion_empty", "code": "@[simp]\ntheorem sUnion_empty : \u22c3\u2080 (\u2205 : ZFSet.{u}) = \u2205", "start": [1024, 1], "end": [1027, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sInter_empty", "code": "@[simp]\ntheorem sInter_empty : \u22c2\u2080 (\u2205 : ZFSet) = \u2205", "start": [1030, 1], "end": [1031, 64], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_of_mem_sInter", "code": "theorem mem_of_mem_sInter {x y z : ZFSet} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z", "start": [1034, 1], "end": [1037, 36], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_sUnion_of_mem", "code": "theorem mem_sUnion_of_mem {x y z : ZFSet} (hy : y \u2208 z) (hz : z \u2208 x) : y \u2208 \u22c3\u2080 x", "start": [1040, 1], "end": [1041, 27], "kind": "commanddeclaration"}, {"full_name": "ZFSet.not_mem_sInter_of_not_mem", "code": "theorem not_mem_sInter_of_not_mem {x y z : ZFSet} (hy : \u00acy \u2208 z) (hz : z \u2208 x) : \u00acy \u2208 \u22c2\u2080 x", "start": [1044, 1], "end": [1045, 42], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sUnion_singleton", "code": "@[simp]\ntheorem sUnion_singleton {x : ZFSet.{u}} : \u22c3\u2080 ({x} : ZFSet) = x", "start": [1048, 1], "end": [1050, 70], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sInter_singleton", "code": "@[simp]\ntheorem sInter_singleton {x : ZFSet.{u}} : \u22c2\u2080 ({x} : ZFSet) = x", "start": [1053, 1], "end": [1055, 88], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_sUnion", "code": "@[simp]\ntheorem toSet_sUnion (x : ZFSet.{u}) : (\u22c3\u2080 x).toSet = \u22c3\u2080 (toSet '' x.toSet)", "start": [1058, 1], "end": [1061, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_sInter", "code": "theorem toSet_sInter {x : ZFSet.{u}} (h : x.Nonempty) : (\u22c2\u2080 x).toSet = \u22c2\u2080 (toSet '' x.toSet)", "start": [1064, 1], "end": [1066, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.singleton_injective", "code": "theorem singleton_injective : Function.Injective (@singleton ZFSet ZFSet _)", "start": [1069, 1], "end": [1071, 51], "kind": "commanddeclaration"}, {"full_name": "ZFSet.singleton_inj", "code": "@[simp]\ntheorem singleton_inj {x y : ZFSet} : ({x} : ZFSet) = {y} \u2194 x = y", "start": [1074, 1], "end": [1076, 29], "kind": "commanddeclaration"}, {"full_name": "ZFSet.union", "code": "protected def union (x y : ZFSet.{u}) : ZFSet.{u} :=\n  \u22c3\u2080 {x, y}", "start": [1079, 1], "end": [1081, 12], "kind": "commanddeclaration"}, {"full_name": "ZFSet.inter", "code": "protected def inter (x y : ZFSet.{u}) : ZFSet.{u} :=\n  ZFSet.sep (fun z => z \u2208 y) x", "start": [1084, 1], "end": [1086, 31], "kind": "commanddeclaration"}, {"full_name": "ZFSet.diff", "code": "protected def diff (x y : ZFSet.{u}) : ZFSet.{u} :=\n  ZFSet.sep (fun z => z \u2209 y) x", "start": [1089, 1], "end": [1091, 31], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_union", "code": "@[simp]\ntheorem toSet_union (x y : ZFSet.{u}) : (x \u222a y).toSet = x.toSet \u222a y.toSet", "start": [1103, 1], "end": [1106, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_inter", "code": "@[simp]\ntheorem toSet_inter (x y : ZFSet.{u}) : (x \u2229 y).toSet = x.toSet \u2229 y.toSet", "start": [1109, 1], "end": [1113, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_sdiff", "code": "@[simp]\ntheorem toSet_sdiff (x y : ZFSet.{u}) : (x \\ y).toSet = x.toSet \\ y.toSet", "start": [1116, 1], "end": [1120, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_union", "code": "@[simp]\ntheorem mem_union {x y z : ZFSet.{u}} : z \u2208 x \u222a y \u2194 z \u2208 x \u2228 z \u2208 y", "start": [1123, 1], "end": [1126, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_inter", "code": "@[simp]\ntheorem mem_inter {x y z : ZFSet.{u}} : z \u2208 x \u2229 y \u2194 z \u2208 x \u2227 z \u2208 y", "start": [1129, 1], "end": [1131, 44], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_diff", "code": "@[simp]\ntheorem mem_diff {x y z : ZFSet.{u}} : z \u2208 x \\ y \u2194 z \u2208 x \u2227 z \u2209 y", "start": [1134, 1], "end": [1136, 44], "kind": "commanddeclaration"}, {"full_name": "ZFSet.sUnion_pair", "code": "@[simp]\ntheorem sUnion_pair {x y : ZFSet.{u}} : \u22c3\u2080 ({x, y} : ZFSet.{u}) = x \u222a y", "start": [1139, 1], "end": [1141, 6], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_wf", "code": "theorem mem_wf : @WellFounded ZFSet (\u00b7 \u2208 \u00b7)", "start": [1144, 1], "end": [1146, 91], "kind": "commanddeclaration"}, {"full_name": "ZFSet.inductionOn", "code": "@[elab_as_elim]\ntheorem inductionOn {p : ZFSet \u2192 Prop} (x) (h : \u2200 x, (\u2200 y \u2208 x, p y) \u2192 p x) : p x", "start": [1149, 1], "end": [1152, 23], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_asymm", "code": "theorem mem_asymm {x y : ZFSet} : x \u2208 y \u2192 y \u2209 x", "start": [1165, 1], "end": [1166, 8], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_irrefl", "code": "theorem mem_irrefl (x : ZFSet) : x \u2209 x", "start": [1169, 1], "end": [1170, 11], "kind": "commanddeclaration"}, {"full_name": "ZFSet.regularity", "code": "theorem regularity (x : ZFSet.{u}) (h : x \u2260 \u2205) : \u2203 y \u2208 x, x \u2229 y = \u2205", "start": [1173, 1], "end": [1179, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.image", "code": "def image (f : ZFSet \u2192 ZFSet) [Definable 1 f] : ZFSet \u2192 ZFSet :=\n  let \u27e8r, hr\u27e9 := @Definable.Resp 1 f _\n  Resp.eval 1\n    \u27e8PSet.image r, fun _ _ e =>\n      Mem.ext fun _ =>\n        (mem_image hr).trans <|\n          Iff.trans\n              \u27e8fun \u27e8w, h1, h2\u27e9 => \u27e8w, (Mem.congr_right e).1 h1, h2\u27e9, fun \u27e8w, h1, h2\u27e9 =>\n                \u27e8w, (Mem.congr_right e).2 h1, h2\u27e9\u27e9 <|\n            (mem_image hr).symm\u27e9", "start": [1182, 1], "end": [1192, 33], "kind": "commanddeclaration"}, {"full_name": "ZFSet.image.mk", "code": "theorem image.mk :\n    \u2200 (f : ZFSet.{u} \u2192 ZFSet.{u}) [H : Definable 1 f] (x) {y} (_ : y \u2208 x), f y \u2208 @image f H x", "start": [1195, 1], "end": [1197, 86], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_image", "code": "@[simp]\ntheorem mem_image :\n    \u2200 {f : ZFSet.{u} \u2192 ZFSet.{u}} [H : Definable 1 f] {x y : ZFSet.{u}},\n      y \u2208 @image f H x \u2194 \u2203 z \u2208 x, f z = y", "start": [1200, 1], "end": [1207, 29], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_image", "code": "@[simp]\ntheorem toSet_image (f : ZFSet \u2192 ZFSet) [H : Definable 1 f] (x : ZFSet) :\n    (image f x).toSet = f '' x.toSet", "start": [1210, 1], "end": [1214, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.range", "code": "noncomputable def range {\u03b1 : Type u} (f : \u03b1 \u2192 ZFSet.{max u v}) : ZFSet.{max u v} :=\n  \u27e6\u27e8ULift.{v} \u03b1, Quotient.out \u2218 f \u2218 ULift.down\u27e9\u27e7", "start": [1217, 1], "end": [1220, 49], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_range", "code": "@[simp]\ntheorem mem_range {\u03b1 : Type u} {f : \u03b1 \u2192 ZFSet.{max u v}} {x : ZFSet.{max u v}} :\n    x \u2208 range.{u, v} f \u2194 x \u2208 Set.range f", "start": [1223, 1], "end": [1232, 59], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_range", "code": "@[simp]\ntheorem toSet_range {\u03b1 : Type u} (f : \u03b1 \u2192 ZFSet.{max u v}) :\n    (range.{u, v} f).toSet = Set.range f", "start": [1235, 1], "end": [1239, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.pair", "code": "def pair (x y : ZFSet.{u}) : ZFSet.{u} :=\n  {{x}, {x, y}}", "start": [1242, 1], "end": [1244, 16], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_pair", "code": "@[simp]\ntheorem toSet_pair (x y : ZFSet.{u}) : (pair x y).toSet = {{x}, {x, y}}", "start": [1247, 1], "end": [1248, 90], "kind": "commanddeclaration"}, {"full_name": "ZFSet.pairSep", "code": "def pairSep (p : ZFSet.{u} \u2192 ZFSet.{u} \u2192 Prop) (x y : ZFSet.{u}) : ZFSet.{u} :=\n  ZFSet.sep (fun z => \u2203 a \u2208 x, \u2203 b \u2208 y, z = pair a b \u2227 p a b) (powerset (powerset (x \u222a y)))", "start": [1251, 1], "end": [1253, 92], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_pairSep", "code": "@[simp]\ntheorem mem_pairSep {p} {x y z : ZFSet.{u}} :\n    z \u2208 pairSep p x y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = pair a b \u2227 p a b", "start": [1256, 1], "end": [1265, 56], "kind": "commanddeclaration"}, {"full_name": "ZFSet.pair_injective", "code": "theorem pair_injective : Function.Injective2 pair", "start": [1268, 1], "end": [1287, 17], "kind": "commanddeclaration"}, {"full_name": "ZFSet.pair_inj", "code": "@[simp]\ntheorem pair_inj {x y x' y' : ZFSet} : pair x y = pair x' y' \u2194 x = x' \u2227 y = y'", "start": [1290, 1], "end": [1292, 24], "kind": "commanddeclaration"}, {"full_name": "ZFSet.prod", "code": "def prod : ZFSet.{u} \u2192 ZFSet.{u} \u2192 ZFSet.{u} :=\n  pairSep fun _ _ => True", "start": [1295, 1], "end": [1297, 26], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_prod", "code": "@[simp]\ntheorem mem_prod {x y z : ZFSet.{u}} : z \u2208 prod x y \u2194 \u2203 a \u2208 x, \u2203 b \u2208 y, z = pair a b", "start": [1300, 1], "end": [1302, 14], "kind": "commanddeclaration"}, {"full_name": "ZFSet.pair_mem_prod", "code": "theorem pair_mem_prod {x y a b : ZFSet.{u}} : pair a b \u2208 prod x y \u2194 a \u2208 x \u2227 b \u2208 y", "start": [1305, 1], "end": [1306, 7], "kind": "commanddeclaration"}, {"full_name": "ZFSet.IsFunc", "code": "def IsFunc (x y f : ZFSet.{u}) : Prop :=\n  f \u2286 prod x y \u2227 \u2200 z : ZFSet.{u}, z \u2208 x \u2192 \u2203! w, pair z w \u2208 f", "start": [1309, 1], "end": [1312, 61], "kind": "commanddeclaration"}, {"full_name": "ZFSet.funs", "code": "def funs (x y : ZFSet.{u}) : ZFSet.{u} :=\n  ZFSet.sep (IsFunc x y) (powerset (prod x y))", "start": [1315, 1], "end": [1317, 47], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_funs", "code": "@[simp]\ntheorem mem_funs {x y f : ZFSet.{u}} : f \u2208 funs x y \u2194 IsFunc x y f", "start": [1320, 1], "end": [1321, 93], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mapDefinableAux", "code": "@[nolint unusedArguments]\nnoncomputable instance mapDefinableAux (f : ZFSet \u2192 ZFSet) [Definable 1 f] :\n    Definable 1 fun y => pair y (f y) :=\n  @Classical.allDefinable 1 _", "start": [1327, 1], "end": [1330, 30], "kind": "commanddeclaration"}, {"full_name": "ZFSet.map", "code": "noncomputable def map (f : ZFSet \u2192 ZFSet) [Definable 1 f] : ZFSet \u2192 ZFSet :=\n  image fun y => pair y (f y)", "start": [1333, 1], "end": [1335, 30], "kind": "commanddeclaration"}, {"full_name": "ZFSet.mem_map", "code": "@[simp]\ntheorem mem_map {f : ZFSet \u2192 ZFSet} [Definable 1 f] {x y : ZFSet} :\n    y \u2208 map f x \u2194 \u2203 z \u2208 x, pair z (f z) = y", "start": [1338, 1], "end": [1341, 12], "kind": "commanddeclaration"}, {"full_name": "ZFSet.map_unique", "code": "theorem map_unique {f : ZFSet.{u} \u2192 ZFSet.{u}} [H : Definable 1 f] {x z : ZFSet.{u}}\n    (zx : z \u2208 x) : \u2203! w, pair z w \u2208 map f x", "start": [1344, 1], "end": [1349, 19], "kind": "commanddeclaration"}, {"full_name": "ZFSet.map_isFunc", "code": "@[simp]\ntheorem map_isFunc {f : ZFSet \u2192 ZFSet} [Definable 1 f] {x y : ZFSet} :\n    IsFunc x y (map f x) \u2194 \u2200 z \u2208 x, f z \u2208 y", "start": [1352, 1], "end": [1362, 28], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Hereditarily", "code": "def Hereditarily (p : ZFSet \u2192 Prop) (x : ZFSet) : Prop :=\n  p x \u2227 \u2200 y \u2208 x, Hereditarily p y\ntermination_by _ => x", "start": [1365, 1], "end": [1369, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.hereditarily_iff", "code": "theorem hereditarily_iff : Hereditarily p x \u2194 p x \u2227 \u2200 y \u2208 x, Hereditarily p y", "start": [1376, 1], "end": [1377, 22], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Hereditarily.def", "code": "alias \u27e8Hereditarily.def, _\u27e9 := hereditarily_iff", "start": [1380, 1], "end": [1380, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ZFSet.Hereditarily.self", "code": "theorem Hereditarily.self (h : x.Hereditarily p) : p x", "start": [1383, 1], "end": [1384, 10], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Hereditarily.mem", "code": "theorem Hereditarily.mem (h : x.Hereditarily p) (hy : y \u2208 x) : y.Hereditarily p", "start": [1387, 1], "end": [1388, 15], "kind": "commanddeclaration"}, {"full_name": "ZFSet.Hereditarily.empty", "code": "theorem Hereditarily.empty : Hereditarily p x \u2192 p \u2205", "start": [1391, 1], "end": [1396, 29], "kind": "commanddeclaration"}, {"full_name": "Class", "code": "def Class :=\n  Set ZFSet deriving HasSubset, EmptyCollection, Nonempty, Union, Inter, HasCompl, SDiff", "start": [1403, 1], "end": [1408, 89], "kind": "commanddeclaration"}, {"full_name": "Class.sep", "code": "protected def sep (p : ZFSet \u2192 Prop) (A : Class) : Class :=\n  {y | A y \u2227 p y}", "start": [1417, 1], "end": [1419, 18], "kind": "commanddeclaration"}, {"full_name": "Class.ext", "code": "@[ext]\ntheorem ext {x y : Class.{u}} : (\u2200 z : ZFSet.{u}, x z \u2194 y z) \u2192 x = y", "start": [1421, 1], "end": [1423, 10], "kind": "commanddeclaration"}, {"full_name": "Class.ext_iff", "code": "theorem ext_iff {x y : Class.{u}} : x = y \u2194 \u2200 z, x z \u2194 y z", "start": [1426, 1], "end": [1427, 14], "kind": "commanddeclaration"}, {"full_name": "Class.ofSet", "code": "@[coe]\ndef ofSet (x : ZFSet.{u}) : Class.{u} :=\n  { y | y \u2208 x }", "start": [1430, 1], "end": [1433, 16], "kind": "commanddeclaration"}, {"full_name": "Class.univ", "code": "def univ : Class :=\n  Set.univ", "start": [1439, 1], "end": [1441, 11], "kind": "commanddeclaration"}, {"full_name": "Class.ToSet", "code": "def ToSet (B : Class.{u}) (A : Class.{u}) : Prop :=\n  \u2203 x : ZFSet, \u2191x = A \u2227 B x", "start": [1444, 1], "end": [1446, 28], "kind": "commanddeclaration"}, {"full_name": "Class.Mem", "code": "protected def Mem (A B : Class.{u}) : Prop :=\n  ToSet.{u} B A", "start": [1449, 1], "end": [1451, 16], "kind": "commanddeclaration"}, {"full_name": "Class.mem_def", "code": "theorem mem_def (A B : Class.{u}) : A \u2208 B \u2194 \u2203 x : ZFSet, \u2191x = A \u2227 B x", "start": [1457, 1], "end": [1458, 10], "kind": "commanddeclaration"}, {"full_name": "Class.not_mem_empty", "code": "@[simp]\ntheorem not_mem_empty (x : Class.{u}) : x \u2209 (\u2205 : Class.{u})", "start": [1461, 1], "end": [1462, 82], "kind": "commanddeclaration"}, {"full_name": "Class.not_empty_hom", "code": "@[simp]\ntheorem not_empty_hom (x : ZFSet.{u}) : \u00ac(\u2205 : Class.{u}) x", "start": [1465, 1], "end": [1467, 5], "kind": "commanddeclaration"}, {"full_name": "Class.mem_univ", "code": "@[simp]\ntheorem mem_univ {A : Class.{u}} : A \u2208 univ.{u} \u2194 \u2203 x : ZFSet.{u}, \u2191x = A", "start": [1470, 1], "end": [1472, 39], "kind": "commanddeclaration"}, {"full_name": "Class.mem_univ_hom", "code": "@[simp]\ntheorem mem_univ_hom (x : ZFSet.{u}) : univ.{u} x", "start": [1475, 1], "end": [1477, 10], "kind": "commanddeclaration"}, {"full_name": "Class.eq_univ_iff_forall", "code": "theorem eq_univ_iff_forall {A : Class.{u}} : A = univ \u2194 \u2200 x : ZFSet, A x", "start": [1480, 1], "end": [1481, 25], "kind": "commanddeclaration"}, {"full_name": "Class.eq_univ_of_forall", "code": "theorem eq_univ_of_forall {A : Class.{u}} : (\u2200 x : ZFSet, A x) \u2192 A = univ", "start": [1484, 1], "end": [1485, 24], "kind": "commanddeclaration"}, {"full_name": "Class.mem_wf", "code": "theorem mem_wf : @WellFounded Class.{u} (\u00b7 \u2208 \u00b7)", "start": [1488, 1], "end": [1496, 17], "kind": "commanddeclaration"}, {"full_name": "Class.mem_asymm", "code": "theorem mem_asymm {x y : Class} : x \u2208 y \u2192 y \u2209 x", "start": [1509, 1], "end": [1510, 8], "kind": "commanddeclaration"}, {"full_name": "Class.mem_irrefl", "code": "theorem mem_irrefl (x : Class) : x \u2209 x", "start": [1513, 1], "end": [1514, 11], "kind": "commanddeclaration"}, {"full_name": "Class.univ_not_mem_univ", "code": "theorem univ_not_mem_univ : univ \u2209 univ", "start": [1517, 1], "end": [1521, 15], "kind": "commanddeclaration"}, {"full_name": "Class.congToClass", "code": "def congToClass (x : Set Class.{u}) : Class.{u} :=\n  { y | \u2191y \u2208 x }", "start": [1524, 1], "end": [1526, 17], "kind": "commanddeclaration"}, {"full_name": "Class.congToClass_empty", "code": "@[simp]\ntheorem congToClass_empty : congToClass \u2205 = \u2205", "start": [1529, 1], "end": [1533, 28], "kind": "commanddeclaration"}, {"full_name": "Class.classToCong", "code": "def classToCong (x : Class.{u}) : Set Class.{u} :=\n  { y | y \u2208 x }", "start": [1536, 1], "end": [1538, 16], "kind": "commanddeclaration"}, {"full_name": "Class.classToCong_empty", "code": "@[simp]\ntheorem classToCong_empty : classToCong \u2205 = \u2205", "start": [1541, 1], "end": [1544, 21], "kind": "commanddeclaration"}, {"full_name": "Class.powerset", "code": "def powerset (x : Class) : Class :=\n  congToClass (Set.powerset x)", "start": [1547, 1], "end": [1549, 31], "kind": "commanddeclaration"}, {"full_name": "Class.sUnion", "code": "def sUnion (x : Class) : Class :=\n  \u22c3\u2080 classToCong x", "start": [1552, 1], "end": [1554, 19], "kind": "commanddeclaration"}, {"full_name": "Class.sInter", "code": "def sInter (x : Class) : Class :=\n  \u22c2\u2080 classToCong x", "start": [1560, 1], "end": [1562, 19], "kind": "commanddeclaration"}, {"full_name": "Class.ofSet.inj", "code": "theorem ofSet.inj {x y : ZFSet.{u}} (h : (x : Class.{u}) = y) : x = y", "start": [1567, 1], "end": [1570, 11], "kind": "commanddeclaration"}, {"full_name": "Class.toSet_of_ZFSet", "code": "@[simp]\ntheorem toSet_of_ZFSet (A : Class.{u}) (x : ZFSet.{u}) : ToSet A x \u2194 A x", "start": [1573, 1], "end": [1575, 75], "kind": "commanddeclaration"}, {"full_name": "Class.coe_mem", "code": "@[simp, norm_cast]\ntheorem coe_mem {x : ZFSet.{u}} {A : Class.{u}} : \u2191x \u2208 A \u2194 A x", "start": [1578, 1], "end": [1580, 21], "kind": "commanddeclaration"}, {"full_name": "Class.coe_apply", "code": "@[simp]\ntheorem coe_apply {x y : ZFSet.{u}} : (y : Class.{u}) x \u2194 x \u2208 y", "start": [1583, 1], "end": [1585, 10], "kind": "commanddeclaration"}, {"full_name": "Class.coe_subset", "code": "@[simp, norm_cast]\ntheorem coe_subset (x y : ZFSet.{u}) : (x : Class.{u}) \u2286 y \u2194 x \u2286 y", "start": [1588, 1], "end": [1590, 10], "kind": "commanddeclaration"}, {"full_name": "Class.coe_sep", "code": "@[simp, norm_cast]\ntheorem coe_sep (p : Class.{u}) (x : ZFSet.{u}) :\n    (ZFSet.sep p x : Class) = { y \u2208 x | p y }", "start": [1593, 1], "end": [1596, 29], "kind": "commanddeclaration"}, {"full_name": "Class.coe_empty", "code": "@[simp, norm_cast]\ntheorem coe_empty : \u2191(\u2205 : ZFSet.{u}) = (\u2205 : Class.{u})", "start": [1599, 1], "end": [1601, 56], "kind": "commanddeclaration"}, {"full_name": "Class.coe_insert", "code": "@[simp, norm_cast]\ntheorem coe_insert (x y : ZFSet.{u}) : \u2191(insert x y) = @insert ZFSet.{u} Class.{u} _ x y", "start": [1604, 1], "end": [1606, 36], "kind": "commanddeclaration"}, {"full_name": "Class.coe_union", "code": "@[simp, norm_cast]\ntheorem coe_union (x y : ZFSet.{u}) : \u2191(x \u222a y) = (x : Class.{u}) \u222a y", "start": [1609, 1], "end": [1611, 31], "kind": "commanddeclaration"}, {"full_name": "Class.coe_inter", "code": "@[simp, norm_cast]\ntheorem coe_inter (x y : ZFSet.{u}) : \u2191(x \u2229 y) = (x : Class.{u}) \u2229 y", "start": [1614, 1], "end": [1616, 31], "kind": "commanddeclaration"}, {"full_name": "Class.coe_diff", "code": "@[simp, norm_cast]\ntheorem coe_diff (x y : ZFSet.{u}) : \u2191(x \\ y) = (x : Class.{u}) \\ y", "start": [1619, 1], "end": [1621, 30], "kind": "commanddeclaration"}, {"full_name": "Class.coe_powerset", "code": "@[simp, norm_cast]\ntheorem coe_powerset (x : ZFSet.{u}) : \u2191x.powerset = powerset.{u} x", "start": [1624, 1], "end": [1626, 34], "kind": "commanddeclaration"}, {"full_name": "Class.powerset_apply", "code": "@[simp]\ntheorem powerset_apply {A : Class.{u}} {x : ZFSet.{u}} : powerset A x \u2194 \u2191x \u2286 A", "start": [1629, 1], "end": [1631, 10], "kind": "commanddeclaration"}, {"full_name": "Class.sUnion_apply", "code": "@[simp]\ntheorem sUnion_apply {x : Class} {y : ZFSet} : (\u22c3\u2080 x) y \u2194 \u2203 z : ZFSet, x z \u2227 y \u2208 z", "start": [1634, 1], "end": [1639, 55], "kind": "commanddeclaration"}, {"full_name": "Class.coe_sUnion", "code": "@[simp, norm_cast]\ntheorem coe_sUnion (x : ZFSet.{u}) : \u2191(\u22c3\u2080 x : ZFSet) = \u22c3\u2080 (x : Class.{u})", "start": [1642, 1], "end": [1645, 63], "kind": "commanddeclaration"}, {"full_name": "Class.mem_sUnion", "code": "@[simp]\ntheorem mem_sUnion {x y : Class.{u}} : y \u2208 \u22c3\u2080 x \u2194 \u2203 z, z \u2208 x \u2227 y \u2208 z", "start": [1648, 1], "end": [1654, 32], "kind": "commanddeclaration"}, {"full_name": "Class.sInter_apply", "code": "theorem sInter_apply {x : Class.{u}} {y : ZFSet.{u}} : (\u22c2\u2080 x) y \u2194 \u2200 z : ZFSet.{u}, x z \u2192 y \u2208 z", "start": [1657, 1], "end": [1660, 16], "kind": "commanddeclaration"}, {"full_name": "Class.coe_sInter", "code": "@[simp, norm_cast]\ntheorem coe_sInter {x : ZFSet.{u}} (h : x.Nonempty) : \u2191(\u22c2\u2080 x : ZFSet) = \u22c2\u2080 (x : Class.{u})", "start": [1663, 1], "end": [1665, 64], "kind": "commanddeclaration"}, {"full_name": "Class.mem_of_mem_sInter", "code": "theorem mem_of_mem_sInter {x y z : Class} (hy : y \u2208 \u22c2\u2080 x) (hz : z \u2208 x) : y \u2208 z", "start": [1668, 1], "end": [1670, 28], "kind": "commanddeclaration"}, {"full_name": "Class.mem_sInter", "code": "theorem mem_sInter {x y : Class.{u}} (h : x.Nonempty) : y \u2208 \u22c2\u2080 x \u2194 \u2200 z, z \u2208 x \u2192 y \u2208 z", "start": [1673, 1], "end": [1679, 60], "kind": "commanddeclaration"}, {"full_name": "Class.sUnion_empty", "code": "@[simp]\ntheorem sUnion_empty : \u22c3\u2080 (\u2205 : Class.{u}) = (\u2205 : Class.{u})", "start": [1682, 1], "end": [1685, 7], "kind": "commanddeclaration"}, {"full_name": "Class.sInter_empty", "code": "@[simp]\ntheorem sInter_empty : \u22c2\u2080 (\u2205 : Class.{u}) = univ", "start": [1688, 1], "end": [1690, 57], "kind": "commanddeclaration"}, {"full_name": "Class.eq_univ_of_powerset_subset", "code": "theorem eq_univ_of_powerset_subset {A : Class} (hA : powerset A \u2286 A) : A = univ", "start": [1693, 1], "end": [1703, 79], "kind": "commanddeclaration"}, {"full_name": "Class.iota", "code": "def iota (A : Class) : Class :=\n  \u22c3\u2080 { x | \u2200 y, A y \u2194 y = x }", "start": [1707, 1], "end": [1709, 30], "kind": "commanddeclaration"}, {"full_name": "Class.iota_val", "code": "theorem iota_val (A : Class) (x : ZFSet) (H : \u2200 y, A y \u2194 y = x) : iota A = \u2191x", "start": [1712, 1], "end": [1715, 28], "kind": "commanddeclaration"}, {"full_name": "Class.iota_ex", "code": "theorem iota_ex (A) : iota.{u} A \u2208 univ.{u}", "start": [1718, 1], "end": [1725, 91], "kind": "commanddeclaration"}, {"full_name": "Class.fval", "code": "def fval (F A : Class.{u}) : Class.{u} :=\n  iota fun y => ToSet (fun x => F (ZFSet.pair x y)) A", "start": [1728, 1], "end": [1730, 54], "kind": "commanddeclaration"}, {"full_name": "Class.fval_ex", "code": "theorem fval_ex (F A : Class.{u}) : F \u2032 A \u2208 univ.{u}", "start": [1736, 1], "end": [1737, 12], "kind": "commanddeclaration"}, {"full_name": "ZFSet.map_fval", "code": "@[simp]\ntheorem map_fval {f : ZFSet.{u} \u2192 ZFSet.{u}} [H : PSet.Definable 1 f] {x y : ZFSet.{u}}\n    (h : y \u2208 x) : (ZFSet.map f x \u2032 y : Class.{u}) = f y", "start": [1744, 1], "end": [1754, 27], "kind": "commanddeclaration"}, {"full_name": "ZFSet.choice", "code": "noncomputable def choice : ZFSet :=\n  @map (fun y => Classical.epsilon fun z => z \u2208 y) (Classical.allDefinable _) x", "start": [1759, 1], "end": [1761, 80], "kind": "commanddeclaration"}, {"full_name": "ZFSet.choice_mem_aux", "code": "theorem choice_mem_aux (y : ZFSet.{u}) (yx : y \u2208 x) :\n    (Classical.epsilon fun z : ZFSet.{u} => z \u2208 y) \u2208 y", "start": [1764, 1], "end": [1767, 83], "kind": "commanddeclaration"}, {"full_name": "ZFSet.choice_isFunc", "code": "theorem choice_isFunc : IsFunc x (\u22c3\u2080 x) (choice x)", "start": [1771, 1], "end": [1773, 50], "kind": "commanddeclaration"}, {"full_name": "ZFSet.choice_mem", "code": "theorem choice_mem (y : ZFSet.{u}) (yx : y \u2208 x) : (choice x \u2032 y : Class.{u}) \u2208 (y : Class.{u})", "start": [1776, 1], "end": [1779, 32], "kind": "commanddeclaration"}, {"full_name": "ZFSet.toSet_equiv_aux", "code": "private lemma toSet_equiv_aux {s : Set ZFSet.{u}} (hs : Small.{u} s) :\n  (mk $ PSet.mk (Shrink s) fun x \u21a6 ((equivShrink s).symm x).1.out).toSet = s := by\n    ext x\n    rw [mem_toSet, \u2190mk_out x, mk_mem_iff, mk_out]\n    refine' \u27e8_, \u03bb xs \u21a6 \u27e8equivShrink s (Subtype.mk x xs), _\u27e9\u27e9\n    \u00b7 rintro \u27e8b, h2\u27e9\n      rw [\u2190ZFSet.eq, ZFSet.mk_out] at h2\n      simp [h2]\n    \u00b7 simp [PSet.Equiv.refl]", "start": [1782, 1], "end": [1790, 29], "kind": "mathlibtacticlemma"}, {"full_name": "ZFSet.toSet_equiv", "code": "@[simps apply_coe]\nnoncomputable def toSet_equiv : ZFSet.{u} \u2243 {s : Set ZFSet.{u} // Small.{u, u+1} s} where\n  toFun x := \u27e8x.toSet, x.small_toSet\u27e9\n  invFun := \u03bb \u27e8s, h\u27e9 \u21a6 mk $ PSet.mk (Shrink s) fun x \u21a6 ((equivShrink.{u, u+1} s).symm x).1.out\n  left_inv := Function.rightInverse_of_injective_of_leftInverse (by intros x y; simp)\n    \u03bb s \u21a6 Subtype.coe_injective $ toSet_equiv_aux s.2\n  right_inv s := Subtype.coe_injective $ toSet_equiv_aux s.2", "start": [1792, 1], "end": [1799, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Coprod/Basic.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/PUnitInstances.lean", "Mathlib/GroupTheory/Congruence.lean"], "premises": [{"full_name": "Monoid.coprodCon", "code": "@[to_additive \"The minimal additive congruence relation `c` on `FreeAddMonoid (M \u2295 N)`\nsuch that `FreeAddMonoid.of \u2218 Sum.inl` and `FreeAddMonoid.of \u2218 Sum.inr`\nare additive monoid homomorphisms to the quotient by `c`.\"]\ndef coprodCon (M N : Type*) [MulOneClass M] [MulOneClass N] : Con (FreeMonoid (M \u2295 N)) :=\n  sInf {c |\n    (\u2200 x y : M, c (of (Sum.inl (x * y))) (of (Sum.inl x) * of (Sum.inl y)))\n    \u2227 (\u2200 x y : N, c (of (Sum.inr (x * y))) (of (Sum.inr x) * of (Sum.inr y)))\n    \u2227 c (of <| Sum.inl 1) 1 \u2227 c (of <| Sum.inr 1) 1}", "start": [124, 1], "end": [134, 53], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod", "code": "@[to_additive \"Coproduct of two additive monoids or groups.\"]\ndef Coprod (M N : Type*) [MulOneClass M] [MulOneClass N] := (coprodCon M N).Quotient", "start": [136, 1], "end": [138, 85], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk", "code": "@[to_additive \"The natural projection `FreeAddMonoid (M \u2295 N) \u2192+ AddMonoid.Coprod M N`.\"]\ndef mk : FreeMonoid (M \u2295 N) \u2192* M \u2217 N := Con.mk' _", "start": [152, 1], "end": [154, 50], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.con_ker_mk", "code": "@[to_additive (attr := simp)]\ntheorem con_ker_mk : Con.ker mk = coprodCon M N", "start": [156, 1], "end": [157, 65], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk_surjective", "code": "@[to_additive]\ntheorem mk_surjective : Surjective (@mk M N _ _)", "start": [159, 1], "end": [160, 73], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mrange_mk", "code": "@[to_additive (attr := simp)]\ntheorem mrange_mk : MonoidHom.mrange (@mk M N _ _) = \u22a4", "start": [162, 1], "end": [163, 73], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk_eq_mk", "code": "@[to_additive]\ntheorem mk_eq_mk {w\u2081 w\u2082 : FreeMonoid (M \u2295 N)} : mk w\u2081 = mk w\u2082 \u2194 coprodCon M N w\u2081 w\u2082", "start": [165, 1], "end": [166, 96], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.inl", "code": "@[to_additive \"The natural embedding `M \u2192+ AddMonoid.Coprod M N`.\"]\ndef inl : M \u2192* M \u2217 N where\n  toFun := fun x => mk (of (.inl x))\n  map_one' := mk_eq_mk.2 fun _c hc => hc.2.2.1\n  map_mul' := fun x y => mk_eq_mk.2 fun _c hc => hc.1 x y", "start": [168, 1], "end": [173, 58], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.inr", "code": "@[to_additive \"The natural embedding `N \u2192+ AddMonoid.Coprod M N`.\"]\ndef inr : N \u2192* M \u2217 N where\n  toFun := fun x => mk (of (.inr x))\n  map_one' := mk_eq_mk.2 fun _c hc => hc.2.2.2\n  map_mul' := fun x y => mk_eq_mk.2 fun _c hc => hc.2.1 x y", "start": [175, 1], "end": [180, 60], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk_of_inl", "code": "@[to_additive (attr := simp)]\ntheorem mk_of_inl (x : M) : (mk (of (.inl x)) : M \u2217 N) = inl x", "start": [182, 1], "end": [183, 70], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk_of_inr", "code": "@[to_additive (attr := simp)]\ntheorem mk_of_inr (x : N) : (mk (of (.inr x)) : M \u2217 N) = inr x", "start": [185, 1], "end": [186, 70], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.induction_on'", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on' {C : M \u2217 N \u2192 Prop} (m : M \u2217 N)\n    (one : C 1)\n    (inl_mul : \u2200 m x, C x \u2192 C (inl m * x))\n    (inr_mul : \u2200 n x, C x \u2192 C (inr n * x)) : C m", "start": [188, 1], "end": [199, 42], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.induction_on", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : M \u2217 N \u2192 Prop} (m : M \u2217 N)\n    (inl : \u2200 m, C (inl m)) (inr : \u2200 n, C (inr n)) (mul : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C m", "start": [201, 1], "end": [204, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift", "code": "@[to_additive \"Lift an additive monoid homomorphism `FreeAddMonoid (M \u2295 N) \u2192+ P` satisfying\nadditional properties to `AddMonoid.Coprod M N \u2192+ P`.\n\nCompared to `AddMonoid.Coprod.lift`,\nthis definition allows a user to provide a custom computational behavior.\nAlso, it only needs `AddZeroclass` assumptions\nwhile `AddMonoid.Coprod.lift` needs an `AddMonoid` structure. \"]\ndef clift (f : FreeMonoid (M \u2295 N) \u2192* P)\n    (hM\u2081 : f (of (.inl 1)) = 1) (hN\u2081 : f (of (.inr 1)) = 1)\n    (hM : \u2200 x y, f (of (.inl (x * y))) = f (of (.inl x) * of (.inl y)))\n    (hN : \u2200 x y, f (of (.inr (x * y))) = f (of (.inr x) * of (.inr y))) :\n    M \u2217 N \u2192* P :=\n  Con.lift _ f <| sInf_le \u27e8hM, hN, hM\u2081.trans (map_one f).symm, hN\u2081.trans (map_one f).symm\u27e9", "start": [206, 1], "end": [225, 91], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift_apply_inl", "code": "@[to_additive (attr := simp)]\ntheorem clift_apply_inl (f : FreeMonoid (M \u2295 N) \u2192* P) (hM\u2081 hN\u2081 hM hN) (x : M) :\n    clift f hM\u2081 hN\u2081 hM hN (inl x) = f (of (.inl x))", "start": [227, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift_apply_inr", "code": "@[to_additive (attr := simp)]\ntheorem clift_apply_inr (f : FreeMonoid (M \u2295 N) \u2192* P) (hM\u2081 hN\u2081 hM hN) (x : N) :\n    clift f hM\u2081 hN\u2081 hM hN (inr x) = f (of (.inr x))", "start": [232, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem clift_apply_mk (f : FreeMonoid (M \u2295 N) \u2192* P) (hM\u2081 hN\u2081 hM hN w) :\n    clift f hM\u2081 hN\u2081 hM hN (mk w) = f w", "start": [237, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift_comp_mk", "code": "@[to_additive (attr := simp)]\ntheorem clift_comp_mk (f : FreeMonoid (M \u2295 N) \u2192* P) (hM\u2081 hN\u2081 hM hN) :\n    (clift f hM\u2081 hN\u2081 hM hN).comp mk = f", "start": [242, 1], "end": [245, 19], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mclosure_range_inl_union_inr", "code": "@[to_additive (attr := simp)]\ntheorem mclosure_range_inl_union_inr :\n    Submonoid.closure (range (inl : M \u2192* M \u2217 N) \u222a range (inr : N \u2192* M \u2217 N)) = \u22a4", "start": [247, 1], "end": [251, 37], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mrange_inl_sup_mrange_inr", "code": "@[to_additive (attr := simp)] theorem mrange_inl_sup_mrange_inr :\n    MonoidHom.mrange (inl : M \u2192* M \u2217 N) \u2294 MonoidHom.mrange (inr : N \u2192* M \u2217 N) = \u22a4", "start": [253, 1], "end": [256, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.codisjoint_mrange_inl_mrange_inr", "code": "@[to_additive]\ntheorem codisjoint_mrange_inl_mrange_inr :\n    Codisjoint (MonoidHom.mrange (inl : M \u2192* M \u2217 N)) (MonoidHom.mrange inr)", "start": [258, 1], "end": [261, 45], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mrange_eq", "code": "@[to_additive] theorem mrange_eq (f : M \u2217 N \u2192* P) :\n    MonoidHom.mrange f = MonoidHom.mrange (f.comp inl) \u2294 MonoidHom.mrange (f.comp inr)", "start": [263, 1], "end": [266, 26], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.hom_ext", "code": "@[to_additive (attr := ext 1100)\n  \"Extensionality lemma for additive monoid homomorphisms `AddMonoid.Coprod M N \u2192+ P`.\n  If two homomorphisms agree on the ranges of `AddMonoid.Coprod.inl` and `AddMonoid.Coprod.inr`,\n  then they are equal.\"]\ntheorem hom_ext {f g : M \u2217 N \u2192* P} (h\u2081 : f.comp inl = g.comp inl) (h\u2082 : f.comp inr = g.comp inr) :\n    f = g", "start": [268, 1], "end": [278, 83], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.clift_mk", "code": "@[to_additive (attr := simp)]\ntheorem clift_mk :\n    clift (mk : FreeMonoid (M \u2295 N) \u2192* M \u2217 N) (map_one inl) (map_one inr) (map_mul inl)\n      (map_mul inr) = .id _", "start": [280, 1], "end": [284, 18], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map", "code": "@[to_additive \"Map `AddMonoid.Coprod M N` to `AddMonoid.Coprod M' N'`\nby applying `Sum.map f g` to each element of the underlying list.\"]\ndef map (f : M \u2192* M') (g : N \u2192* N') : M \u2217 N \u2192* M' \u2217 N' :=\n  clift (mk.comp <| FreeMonoid.map <| Sum.map f g)\n    (by simp only [MonoidHom.comp_apply, map_of, Sum.map_inl, map_one, mk_of_inl])\n    (by simp only [MonoidHom.comp_apply, map_of, Sum.map_inr, map_one, mk_of_inr])\n    (fun x y => by simp only [MonoidHom.comp_apply, map_of, Sum.map_inl, map_mul, mk_of_inl])\n    fun x y => by simp only [MonoidHom.comp_apply, map_of, Sum.map_inr, map_mul, mk_of_inr]", "start": [286, 1], "end": [294, 92], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_mk_ofList", "code": "@[to_additive (attr := simp)]\ntheorem map_mk_ofList (f : M \u2192* M') (g : N \u2192* N') (l : List (M \u2295 N)) :\n    map f g (mk (ofList l)) = mk (ofList (l.map (Sum.map f g)))", "start": [296, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_apply_inl", "code": "@[to_additive (attr := simp)]\ntheorem map_apply_inl (f : M \u2192* M') (g : N \u2192* N') (x : M) : map f g (inl x) = inl (f x)", "start": [301, 1], "end": [302, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_apply_inr", "code": "@[to_additive (attr := simp)]\ntheorem map_apply_inr (f : M \u2192* M') (g : N \u2192* N') (x : N) : map f g (inr x) = inr (g x)", "start": [304, 1], "end": [305, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem map_comp_inl (f : M \u2192* M') (g : N \u2192* N') : (map f g).comp inl = inl.comp f", "start": [307, 1], "end": [308, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem map_comp_inr (f : M \u2192* M') (g : N \u2192* N') : (map f g).comp inr = inr.comp g", "start": [310, 1], "end": [311, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_id_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id_id : map (.id M) (.id N) = .id (M \u2217 N)", "start": [313, 1], "end": [314, 73], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_comp_map", "code": "@[to_additive]\ntheorem map_comp_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' \u2192* M'') (g' : N' \u2192* N'')\n    (f : M \u2192* M') (g : N \u2192* N') : (map f' g').comp (map f g) = map (f'.comp f) (g'.comp g)", "start": [316, 1], "end": [319, 18], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.map_map", "code": "@[to_additive]\ntheorem map_map {M'' N''} [MulOneClass M''] [MulOneClass N''] (f' : M' \u2192* M'') (g' : N' \u2192* N'')\n    (f : M \u2192* M') (g : N \u2192* N') (x : M \u2217 N) :\n    map f' g' (map f g x) = map (f'.comp f) (g'.comp g) x", "start": [321, 1], "end": [325, 47], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap", "code": "@[to_additive \"Map `AddMonoid.Coprod M N` to `AddMonoid.Coprod N M`\n  by applying `Sum.swap` to each element of the underlying list.\n\nSee also `AddEquiv.coprodComm` for an `AddEquiv` version.\"]\ndef swap : M \u2217 N \u2192* N \u2217 M :=\n  clift (mk.comp <| FreeMonoid.map Sum.swap)\n    (by simp only [MonoidHom.comp_apply, map_of, Sum.swap_inl, mk_of_inr, map_one])\n    (by simp only [MonoidHom.comp_apply, map_of, Sum.swap_inr, mk_of_inl, map_one])\n    (fun x y => by simp only [MonoidHom.comp_apply, map_of, Sum.swap_inl, mk_of_inr, map_mul])\n    (fun x y => by simp only [MonoidHom.comp_apply, map_of, Sum.swap_inr, mk_of_inl, map_mul])", "start": [329, 1], "end": [341, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_comp_swap", "code": "@[to_additive (attr := simp)]\ntheorem swap_comp_swap : (swap M N).comp (swap N M) = .id _", "start": [343, 1], "end": [344, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_swap", "code": "@[to_additive (attr := simp)]\ntheorem swap_swap (x : M \u2217 N) : swap N M (swap M N x) = x", "start": [348, 1], "end": [350, 43], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_comp_map", "code": "@[to_additive]\ntheorem swap_comp_map (f : M \u2192* M') (g : N \u2192* N') :\n    (swap M' N').comp (map f g) = (map g f).comp (swap M N)", "start": [352, 1], "end": [355, 18], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_map", "code": "@[to_additive]\ntheorem swap_map (f : M \u2192* M') (g : N \u2192* N') (x : M \u2217 N) :\n    swap M' N' (map f g x) = map g f (swap M N x)", "start": [357, 1], "end": [360, 42], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_comp_inl", "code": "@[to_additive (attr := simp)] theorem swap_comp_inl : (swap M N).comp inl = inr", "start": [362, 1], "end": [362, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_inl", "code": "@[to_additive (attr := simp)] theorem swap_inl (x : M) : swap M N (inl x) = inr x", "start": [363, 1], "end": [363, 89], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_comp_inr", "code": "@[to_additive (attr := simp)] theorem swap_comp_inr : (swap M N).comp inr = inl", "start": [364, 1], "end": [364, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_inr", "code": "@[to_additive (attr := simp)] theorem swap_inr (x : N) : swap M N (inr x) = inl x", "start": [365, 1], "end": [365, 89], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_injective", "code": "@[to_additive]\ntheorem swap_injective : Injective (swap M N)", "start": [367, 1], "end": [368, 81], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_inj", "code": "@[to_additive (attr := simp)]\ntheorem swap_inj {x y : M \u2217 N} : swap M N x = swap M N y \u2194 x = y", "start": [370, 1], "end": [371, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem swap_eq_one {x : M \u2217 N} : swap M N x = 1 \u2194 x = 1", "start": [373, 1], "end": [374, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_surjective", "code": "@[to_additive]\ntheorem swap_surjective : Surjective (swap M N)", "start": [376, 1], "end": [377, 84], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.swap_bijective", "code": "@[to_additive]\ntheorem swap_bijective : Bijective (swap M N)", "start": [379, 1], "end": [380, 83], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mker_swap", "code": "@[to_additive (attr := simp)]\ntheorem mker_swap : MonoidHom.mker (swap M N) = \u22a5", "start": [382, 1], "end": [383, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mrange_swap", "code": "@[to_additive (attr := simp)]\ntheorem mrange_swap : MonoidHom.mrange (swap M N) = \u22a4", "start": [385, 1], "end": [387, 55], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift", "code": "@[to_additive \"Lift a pair of additive monoid homomorphisms `f : M \u2192+ P`, `g : N \u2192+ P`\nto an additive monoid homomorphism `AddMonoid.Coprod M N \u2192+ P`.\n\nSee also `AddMonoid.Coprod.clift` for a version that allows custom computational behavior\nand works for an `AddZeroClass` codomain.\"]\ndef lift (f : M \u2192* P) (g : N \u2192* P) : (M \u2217 N) \u2192* P :=\n  clift (FreeMonoid.lift <| Sum.elim f g) (map_one f) (map_one g) (map_mul f) (map_mul g)", "start": [395, 1], "end": [407, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem lift_apply_mk (f : M \u2192* P) (g : N \u2192* P) (x : FreeMonoid (M \u2295 N)) :\n    lift f g (mk x) = FreeMonoid.lift (Sum.elim f g) x", "start": [409, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_apply_inl", "code": "@[to_additive (attr := simp)]\ntheorem lift_apply_inl (f : M \u2192* P) (g : N \u2192* P) (x : M) : lift f g (inl x) = f x", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_unique", "code": "@[to_additive]\ntheorem lift_unique {f : M \u2192* P} {g : N \u2192* P} {fg : M \u2217 N \u2192* P} (h\u2081 : fg.comp inl = f)\n    (h\u2082 : fg.comp inr = g) : fg = lift f g", "start": [418, 1], "end": [421, 16], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_inl (f : M \u2192* P) (g : N \u2192* P) : (lift f g).comp inl = f", "start": [423, 1], "end": [424, 81], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_apply_inr", "code": "@[to_additive (attr := simp)]\ntheorem lift_apply_inr (f : M \u2192* P) (g : N \u2192* P) (x : N) : lift f g (inr x) = g x", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_inr (f : M \u2192* P) (g : N \u2192* P) : (lift f g).comp inr = g", "start": [430, 1], "end": [431, 81], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_comp_swap", "code": "@[to_additive (attr := simp)]\ntheorem lift_comp_swap (f : M \u2192* P) (g : N \u2192* P) : (lift f g).comp (swap N M) = lift g f", "start": [433, 1], "end": [435, 18], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_swap", "code": "@[to_additive (attr := simp)]\ntheorem lift_swap (f : M \u2192* P) (g : N \u2192* P) (x : N \u2217 M) : lift f g (swap N M x) = lift g f x", "start": [437, 1], "end": [439, 43], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.comp_lift", "code": "@[to_additive]\ntheorem comp_lift {P' : Type*} [Monoid P'] (f : P \u2192* P') (g\u2081 : M \u2192* P) (g\u2082 : N \u2192* P) :\n    f.comp (lift g\u2081 g\u2082) = lift (f.comp g\u2081) (f.comp g\u2082)", "start": [441, 1], "end": [445, 60], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.liftEquiv", "code": "@[to_additive \"`AddMonoid.Coprod.lift` as an equivalence.\"]\ndef liftEquiv : (M \u2192* P) \u00d7 (N \u2192* P) \u2243 (M \u2217 N \u2192* P) where\n  toFun fg := lift fg.1 fg.2\n  invFun f := (f.comp inl, f.comp inr)\n  left_inv _ := rfl\n  right_inv _ := Eq.symm <| lift_unique rfl rfl", "start": [447, 1], "end": [453, 48], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mrange_lift", "code": "@[to_additive (attr := simp)]\ntheorem mrange_lift (f : M \u2192* P) (g : N \u2192* P) :\n    MonoidHom.mrange (lift f g) = MonoidHom.mrange f \u2294 MonoidHom.mrange g", "start": [455, 1], "end": [458, 19], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst", "code": "@[to_additive \"The natural projection `AddMonoid.Coprod M N \u2192+ M`.\"]\ndef fst : M \u2217 N \u2192* M := lift (.id M) 1", "start": [471, 1], "end": [473, 39], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd", "code": "@[to_additive \"The natural projection `AddMonoid.Coprod M N \u2192+ N`.\"]\ndef snd : M \u2217 N \u2192* N := lift 1 (.id N)", "start": [475, 1], "end": [477, 39], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd", "code": "@[to_additive \"The natural projection `AddMonoid.Coprod M N \u2192+ M \u00d7 N`.\"]\ndef toProd : M \u2217 N \u2192* M \u00d7 N := lift (.inl _ _) (.inr _ _)", "start": [479, 1], "end": [481, 58], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_comp_inl", "code": "@[to_additive (attr := simp)] theorem fst_comp_inl : (fst : M \u2217 N \u2192* M).comp inl = .id _", "start": [483, 1], "end": [483, 96], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_apply_inl", "code": "@[to_additive (attr := simp)] theorem fst_apply_inl (x : M) : fst (inl x : M \u2217 N) = x", "start": [484, 1], "end": [484, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_comp_inr", "code": "@[to_additive (attr := simp)] theorem fst_comp_inr : (fst : M \u2217 N \u2192* M).comp inr = 1", "start": [485, 1], "end": [485, 92], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_apply_inr", "code": "@[to_additive (attr := simp)] theorem fst_apply_inr (x : N) : fst (inr x : M \u2217 N) = 1", "start": [486, 1], "end": [486, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_comp_inl", "code": "@[to_additive (attr := simp)] theorem snd_comp_inl : (snd : M \u2217 N \u2192* N).comp inl = 1", "start": [487, 1], "end": [487, 92], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_apply_inl", "code": "@[to_additive (attr := simp)] theorem snd_apply_inl (x : M) : snd (inl x : M \u2217 N) = 1", "start": [488, 1], "end": [488, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_comp_inr", "code": "@[to_additive (attr := simp)] theorem snd_comp_inr : (snd : M \u2217 N \u2192* N).comp inr = .id _", "start": [489, 1], "end": [489, 96], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_apply_inr", "code": "@[to_additive (attr := simp)] theorem snd_apply_inr (x : N) : snd (inr x : M \u2217 N) = x", "start": [490, 1], "end": [490, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem toProd_comp_inl : (toProd : M \u2217 N \u2192* M \u00d7 N).comp inl = .inl _ _", "start": [492, 1], "end": [493, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem toProd_comp_inr : (toProd : M \u2217 N \u2192* M \u00d7 N).comp inr = .inr _ _", "start": [495, 1], "end": [496, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd_apply_inl", "code": "@[to_additive (attr := simp)]\ntheorem toProd_apply_inl (x : M) : toProd (inl x : M \u2217 N) = (x, 1)", "start": [498, 1], "end": [499, 74], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd_apply_inr", "code": "@[to_additive (attr := simp)]\ntheorem toProd_apply_inr (x : N) : toProd (inr x : M \u2217 N) = (1, x)", "start": [501, 1], "end": [502, 74], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_prod_snd", "code": "@[to_additive (attr := simp)]\ntheorem fst_prod_snd : (fst : M \u2217 N \u2192* M).prod snd = toProd", "start": [504, 1], "end": [505, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.prod_mk_fst_snd", "code": "@[to_additive (attr := simp)]\ntheorem prod_mk_fst_snd (x : M \u2217 N) : (fst x, snd x) = toProd x", "start": [507, 1], "end": [509, 44], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_comp_toProd", "code": "@[to_additive (attr := simp)]\ntheorem fst_comp_toProd : (MonoidHom.fst M N).comp toProd = fst", "start": [511, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_toProd", "code": "@[to_additive (attr := simp)]\ntheorem fst_toProd (x : M \u2217 N) : (toProd x).1 = fst x", "start": [515, 1], "end": [517, 30], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_comp_toProd", "code": "@[to_additive (attr := simp)]\ntheorem snd_comp_toProd : (MonoidHom.snd M N).comp toProd = snd", "start": [519, 1], "end": [521, 47], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_toProd", "code": "@[to_additive (attr := simp)]\ntheorem snd_toProd (x : M \u2217 N) : (toProd x).2 = snd x", "start": [523, 1], "end": [525, 30], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_comp_swap", "code": "@[to_additive (attr := simp)]\ntheorem fst_comp_swap : fst.comp (swap M N) = snd", "start": [527, 1], "end": [528, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_swap", "code": "@[to_additive (attr := simp)]\ntheorem fst_swap (x : M \u2217 N) : fst (swap M N x) = snd x", "start": [530, 1], "end": [531, 75], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_comp_swap", "code": "@[to_additive (attr := simp)]\ntheorem snd_comp_swap : snd.comp (swap M N) = fst", "start": [533, 1], "end": [534, 72], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_swap", "code": "@[to_additive (attr := simp)]\ntheorem snd_swap (x : M \u2217 N) : snd (swap M N x) = fst x", "start": [536, 1], "end": [537, 75], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_inr_inl", "code": "@[to_additive (attr := simp)]\ntheorem lift_inr_inl : lift (inr : M \u2192* N \u2217 M) inl = swap M N", "start": [539, 1], "end": [540, 81], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.lift_inl_inr", "code": "@[to_additive (attr := simp)]\ntheorem lift_inl_inr : lift (inl : M \u2192* M \u2217 N) inr = .id _", "start": [542, 1], "end": [543, 78], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.inl_injective", "code": "@[to_additive]\ntheorem inl_injective : Injective (inl : M \u2192* M \u2217 N)", "start": [545, 1], "end": [546, 92], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.inr_injective", "code": "@[to_additive]\ntheorem inr_injective : Injective (inr : N \u2192* M \u2217 N)", "start": [548, 1], "end": [549, 92], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.fst_surjective", "code": "@[to_additive]\ntheorem fst_surjective : Surjective (fst : M \u2217 N \u2192* M)", "start": [551, 1], "end": [552, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.snd_surjective", "code": "@[to_additive]\ntheorem snd_surjective : Surjective (snd : M \u2217 N \u2192* N)", "start": [554, 1], "end": [555, 95], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.toProd_surjective", "code": "@[to_additive]\ntheorem toProd_surjective : Surjective (toProd : M \u2217 N \u2192* M \u00d7 N)", "start": [557, 1], "end": [559, 93], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.mk_of_inv_mul", "code": "@[to_additive]\ntheorem mk_of_inv_mul : \u2200 x : G \u2295 H, mk (of (x.map Inv.inv Inv.inv)) * mk (of x) = 1", "start": [567, 1], "end": [570, 53], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.con_mul_left_inv", "code": "@[to_additive]\ntheorem con_mul_left_inv (x : FreeMonoid (G \u2295 H)) :\n    coprodCon G H (ofList (x.toList.map (Sum.map Inv.inv Inv.inv)).reverse * x) 1", "start": [572, 1], "end": [580, 69], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.inv_def", "code": "@[to_additive]\ntheorem inv_def (w : FreeMonoid (G \u2295 H)) :\n    (mk w)\u207b\u00b9 = mk (ofList (w.toList.map (Sum.map Inv.inv Inv.inv)).reverse)", "start": [587, 1], "end": [590, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.closure_range_inl_union_inr", "code": "@[to_additive (attr := simp)]\ntheorem closure_range_inl_union_inr :\n    Subgroup.closure (range (inl : G \u2192* G \u2217 H) \u222a range inr) = \u22a4", "start": [596, 1], "end": [599, 74], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.range_inl_sup_range_inr", "code": "@[to_additive (attr := simp)] theorem range_inl_sup_range_inr :\n    MonoidHom.range (inl : G \u2192* G \u2217 H) \u2294 MonoidHom.range inr = \u22a4", "start": [601, 1], "end": [604, 69], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.codisjoint_range_inl_range_inr", "code": "@[to_additive]\ntheorem codisjoint_range_inl_range_inr :\n    Codisjoint (MonoidHom.range (inl : G \u2192* G \u2217 H)) (MonoidHom.range inr)", "start": [606, 1], "end": [609, 43], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.range_swap", "code": "@[to_additive (attr := simp)] theorem range_swap : MonoidHom.range (swap G H) = \u22a4", "start": [611, 1], "end": [612, 54], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.range_eq", "code": "@[to_additive] theorem range_eq (f : G \u2217 H \u2192* K) :\n    MonoidHom.range f = MonoidHom.range (f.comp inl) \u2294 MonoidHom.range (f.comp inr)", "start": [616, 1], "end": [619, 25], "kind": "commanddeclaration"}, {"full_name": "Monoid.Coprod.range_lift", "code": "@[to_additive (attr := simp)] theorem range_lift (f : G \u2192* K) (g : H \u2192* K) :\n    MonoidHom.range (lift f g) = MonoidHom.range f \u2294 MonoidHom.range g", "start": [621, 1], "end": [623, 18], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodCongr", "code": "@[to_additive (attr := simps! (config := { fullyApplied := false })) \"Lift two additive monoid\nequivalences `e : M \u2243+ N` and `e' : M' \u2243+ N'` to an additive monoid equivalence\n`(AddMonoid.Coprod M M') \u2243+ (AddMonoid.Coprod N N')`.\"]\ndef coprodCongr (e : M \u2243* N) (e' : M' \u2243* N') : (M \u2217 M') \u2243* (N \u2217 N') :=\n  (Coprod.map (e : M \u2192* N) (e' : M' \u2192* N')).toMulEquiv (Coprod.map e.symm e'.symm)\n    (by ext <;> simp) (by ext <;> simp)", "start": [638, 1], "end": [645, 40], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodComm", "code": "@[to_additive (attr := simps! (config := { fullyApplied := false }))\n  \"An `AddEquiv` version of `AddMonoid.Coprod.swap`.\"]\ndef coprodComm : M \u2217 N \u2243* N \u2217 M :=\n  (Coprod.swap _ _).toMulEquiv (Coprod.swap _ _) (Coprod.swap_comp_swap _ _)\n    (Coprod.swap_comp_swap _ _)", "start": [649, 1], "end": [654, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc", "code": "@[to_additive \"An additive equivalence between `AddMonoid.Coprod (AddMonoid.Coprod M N) P` and\n`AddMonoid.Coprod M (AddMonoid.Coprod N P)`.\"]\ndef coprodAssoc : (M \u2217 N) \u2217 P \u2243* M \u2217 (N \u2217 P) :=\n  MonoidHom.toMulEquiv\n    (Coprod.lift (Coprod.map (.id M) inl) (inr.comp inr))\n    (Coprod.lift (inl.comp inl) (Coprod.map inr (.id P)))\n    (by ext <;> rfl) (by ext <;> rfl)", "start": [660, 1], "end": [667, 38], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_apply_inl_inl", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inl (x : M) : coprodAssoc M N P (inl (inl x)) = inl x", "start": [671, 1], "end": [672, 91], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_apply_inl_inr", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inl_inr (x : N) : coprodAssoc M N P (inl (inr x)) = inr (inl x)", "start": [674, 1], "end": [675, 97], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_apply_inr", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_apply_inr (x : P) : coprodAssoc M N P (inr x) = inr (inr x)", "start": [677, 1], "end": [678, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_symm_apply_inl", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inl (x : M) : (coprodAssoc M N P).symm (inl x) = inl (inl x)", "start": [680, 1], "end": [682, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_symm_apply_inr_inl", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inl (x : N) :\n    (coprodAssoc M N P).symm (inr (inl x)) = inl (inr x)", "start": [684, 1], "end": [687, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodAssoc_symm_apply_inr_inr", "code": "@[to_additive (attr := simp)]\ntheorem coprodAssoc_symm_apply_inr_inr (x : P) :\n    (coprodAssoc M N P).symm (inr (inr x)) = inr x", "start": [689, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.coprodPUnit", "code": "@[simps! (config := {fullyApplied := false})]\ndef coprodPUnit : M \u2217 PUnit \u2243* M :=\n  MonoidHom.toMulEquiv fst inl (hom_ext rfl <| Subsingleton.elim _ _) fst_comp_inl", "start": [696, 1], "end": [699, 83], "kind": "commanddeclaration"}, {"full_name": "Monoid.MulEquiv.punitCoprod", "code": "@[simps! (config := {fullyApplied := false})]\ndef punitCoprod : PUnit \u2217 M \u2243* M :=\n  MonoidHom.toMulEquiv snd inr (hom_ext (Subsingleton.elim _ _) rfl) snd_comp_inr", "start": [701, 1], "end": [704, 82], "kind": "commanddeclaration"}, {"full_name": "Monoid.AddEquiv.coprodUnit", "code": "@[simps! (config := {fullyApplied := false})]\ndef coprodUnit : AddMonoid.Coprod M PUnit \u2243+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.fst AddMonoid.Coprod.inl\n    (AddMonoid.Coprod.hom_ext rfl <| Subsingleton.elim _ _) AddMonoid.Coprod.fst_comp_inl", "start": [714, 1], "end": [718, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid.AddEquiv.punitCoprod", "code": "@[simps! (config := {fullyApplied := false})]\ndef punitCoprod : AddMonoid.Coprod PUnit M \u2243+ M :=\n  AddMonoidHom.toAddEquiv AddMonoid.Coprod.snd AddMonoid.Coprod.inr\n    (AddMonoid.Coprod.hom_ext (Subsingleton.elim _ _) rfl) AddMonoid.Coprod.snd_comp_inr", "start": [720, 1], "end": [724, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/DiscreteQuotient.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Topology/LocallyConstant/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DiscreteQuotient", "code": "@[ext] structure DiscreteQuotient (X : Type*) [TopologicalSpace X] extends Setoid X where\n  \n  protected isOpen_setOf_rel : \u2200 x, IsOpen (setOf (toSetoid.Rel x))", "start": [69, 1], "end": [73, 68], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.toSetoid_injective", "code": "lemma toSetoid_injective : Function.Injective (@toSetoid X _)\n  | \u27e8_, _\u27e9, \u27e8_, _\u27e9, _ => by congr", "start": [81, 1], "end": [82, 34], "kind": "mathlibtacticlemma"}, {"full_name": "DiscreteQuotient.ofClopen", "code": "def ofClopen {A : Set X} (h : IsClopen A) : DiscreteQuotient X where\n  toSetoid := \u27e8fun x y => x \u2208 A \u2194 y \u2208 A, fun _ => Iff.rfl, Iff.symm, Iff.trans\u27e9\n  isOpen_setOf_rel x := by by_cases hx : x \u2208 A <;> simp [Setoid.Rel, hx, h.1, h.2, \u2190 compl_setOf]", "start": [84, 1], "end": [87, 98], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.refl", "code": "theorem refl : \u2200 x, S.Rel x x", "start": [90, 1], "end": [90, 41], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.symm", "code": "theorem symm (x y : X) : S.Rel x y \u2192 S.Rel y x", "start": [93, 1], "end": [93, 58], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.trans", "code": "theorem trans (x y z : X) : S.Rel x y \u2192 S.Rel y z \u2192 S.Rel x z", "start": [96, 1], "end": [96, 74], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj", "code": "def proj : X \u2192 S := Quotient.mk''", "start": [108, 1], "end": [109, 34], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.fiber_eq", "code": "theorem fiber_eq (x : X) : S.proj \u207b\u00b9' {S.proj x} = setOf (S.Rel x)", "start": [112, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_surjective", "code": "theorem proj_surjective : Function.Surjective S.proj", "start": [116, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_quotientMap", "code": "theorem proj_quotientMap : QuotientMap S.proj", "start": [120, 1], "end": [121, 22], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_continuous", "code": "theorem proj_continuous : Continuous S.proj", "start": [124, 1], "end": [125, 32], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_isLocallyConstant", "code": "theorem proj_isLocallyConstant : IsLocallyConstant S.proj", "start": [133, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.isClopen_preimage", "code": "theorem isClopen_preimage (A : Set S) : IsClopen (S.proj \u207b\u00b9' A)", "start": [137, 1], "end": [138, 51], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.isOpen_preimage", "code": "theorem isOpen_preimage (A : Set S) : IsOpen (S.proj \u207b\u00b9' A)", "start": [141, 1], "end": [142, 28], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.isClosed_preimage", "code": "theorem isClosed_preimage (A : Set S) : IsClosed (S.proj \u207b\u00b9' A)", "start": [145, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.isClopen_setOf_rel", "code": "theorem isClopen_setOf_rel (x : X) : IsClopen (setOf (S.Rel x))", "start": [149, 1], "end": [151, 26], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.inhabitedQuotient", "code": "instance inhabitedQuotient [Inhabited X] : Inhabited S := \u27e8S.proj default\u27e9", "start": [166, 1], "end": [166, 75], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.comap", "code": "def comap (S : DiscreteQuotient Y) : DiscreteQuotient X where\n  toSetoid := Setoid.comap f S.1\n  isOpen_setOf_rel _ := (S.2 _).preimage f.continuous", "start": [181, 1], "end": [184, 54], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.comap_id", "code": "@[simp]\ntheorem comap_id : S.comap (ContinuousMap.id X) = S", "start": [187, 1], "end": [188, 59], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.comap_comp", "code": "@[simp]\ntheorem comap_comp (S : DiscreteQuotient Z) : S.comap (g.comp f) = (S.comap g).comap f", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.comap_mono", "code": "@[mono]\ntheorem comap_mono {A B : DiscreteQuotient Y} (h : A \u2264 B) : A.comap f \u2264 B.comap f", "start": [196, 1], "end": [197, 94], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE", "code": "def ofLE (h : A \u2264 B) : A \u2192 B :=\n  Quotient.map' (fun x => x) h", "start": [206, 1], "end": [208, 31], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_refl", "code": "@[simp]\ntheorem ofLE_refl : ofLE (le_refl A) = id", "start": [211, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_refl_apply", "code": "theorem ofLE_refl_apply (a : A) : ofLE (le_refl A) a = a", "start": [217, 1], "end": [217, 68], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_ofLE", "code": "@[simp]\ntheorem ofLE_ofLE (h\u2081 : A \u2264 B) (h\u2082 : B \u2264 C) (x : A) :\n    ofLE h\u2082 (ofLE h\u2081 x) = ofLE (h\u2081.trans h\u2082) x", "start": [220, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_comp_ofLE", "code": "@[simp]\ntheorem ofLE_comp_ofLE (h\u2081 : A \u2264 B) (h\u2082 : B \u2264 C) : ofLE h\u2082 \u2218 ofLE h\u2081 = ofLE (le_trans h\u2081 h\u2082)", "start": [227, 1], "end": [229, 26], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_continuous", "code": "theorem ofLE_continuous (h : A \u2264 B) : Continuous (ofLE h)", "start": [232, 1], "end": [233, 33], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_proj", "code": "@[simp]\ntheorem ofLE_proj (h : A \u2264 B) (x : X) : ofLE h (A.proj x) = B.proj x", "start": [236, 1], "end": [238, 29], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_comp_proj", "code": "@[simp]\ntheorem ofLE_comp_proj (h : A \u2264 B) : ofLE h \u2218 A.proj = B.proj", "start": [241, 1], "end": [243, 24], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_bot_eq", "code": "@[simp]\ntheorem proj_bot_eq [LocallyConnectedSpace X] {x y : X} :\n    proj \u22a5 x = proj \u22a5 y \u2194 connectedComponent x = connectedComponent y", "start": [261, 1], "end": [264, 16], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_bot_inj", "code": "theorem proj_bot_inj [DiscreteTopology X] {x y : X} : proj \u22a5 x = proj \u22a5 y \u2194 x = y", "start": [267, 1], "end": [267, 93], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_bot_injective", "code": "theorem proj_bot_injective [DiscreteTopology X] : Injective (\u22a5 : DiscreteQuotient X).proj", "start": [270, 1], "end": [271, 28], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.proj_bot_bijective", "code": "theorem proj_bot_bijective [DiscreteTopology X] : Bijective (\u22a5 : DiscreteQuotient X).proj", "start": [274, 1], "end": [275, 42], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.LEComap", "code": "def LEComap : Prop :=\n  A \u2264 B.comap f", "start": [282, 1], "end": [285, 16], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.leComap_id", "code": "theorem leComap_id : LEComap (.id X) A A", "start": [288, 1], "end": [288, 51], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.leComap_id_iff", "code": "@[simp]\ntheorem leComap_id_iff : LEComap (ContinuousMap.id X) A A' \u2194 A \u2264 A'", "start": [293, 1], "end": [295, 10], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.LEComap.comp", "code": "theorem LEComap.comp : LEComap g B C \u2192 LEComap f A B \u2192 LEComap (g.comp f) A C", "start": [298, 1], "end": [298, 90], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.LEComap.mono", "code": "@[mono]\ntheorem LEComap.mono (h : LEComap f A B) (hA : A' \u2264 A) (hB : B \u2264 B') : LEComap f A' B'", "start": [301, 1], "end": [303, 41], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map", "code": "def map (f : C(X, Y)) (cond : LEComap f A B) : A \u2192 B := Quotient.map' f cond", "start": [306, 1], "end": [307, 77], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_continuous", "code": "theorem map_continuous (cond : LEComap f A B) : Continuous (map f cond)", "start": [310, 1], "end": [311, 33], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_comp_proj", "code": "@[simp]\ntheorem map_comp_proj (cond : LEComap f A B) : map f cond \u2218 A.proj = B.proj \u2218 f", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_proj", "code": "@[simp]\ntheorem map_proj (cond : LEComap f A B) (x : X) : map f cond (A.proj x) = B.proj (f x)", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_id", "code": "@[simp]\ntheorem map_id : map _ (leComap_id A) = id", "start": [324, 1], "end": [325, 61], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_comp", "code": "theorem map_comp (h1 : LEComap g B C) (h2 : LEComap f A B) :\n    map (g.comp f) (h1.comp h2) = map g h1 \u2218 map f h2", "start": [329, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_map", "code": "@[simp]\ntheorem ofLE_map (cond : LEComap f A B) (h : B \u2264 B') (a : A) :\n    ofLE h (map f cond a) = map f (cond.mono le_rfl h) a", "start": [335, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.ofLE_comp_map", "code": "@[simp]\ntheorem ofLE_comp_map (cond : LEComap f A B) (h : B \u2264 B') :\n    ofLE h \u2218 map f cond = map f (cond.mono le_rfl h)", "start": [342, 1], "end": [345, 28], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_ofLE", "code": "@[simp]\ntheorem map_ofLE (cond : LEComap f A B) (h : A' \u2264 A) (c : A') :\n    map f cond (ofLE h c) = map f (cond.mono h le_rfl) c", "start": [348, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.map_comp_ofLE", "code": "@[simp]\ntheorem map_comp_ofLE (cond : LEComap f A B) (h : A' \u2264 A) :\n    map f cond \u2218 ofLE h = map f (cond.mono h le_rfl)", "start": [355, 1], "end": [358, 28], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.eq_of_forall_proj_eq", "code": "theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n    {x y : X} (h : \u2200 Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y", "start": [363, 1], "end": [368, 53], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.fiber_subset_ofLE", "code": "theorem fiber_subset_ofLE {A B : DiscreteQuotient X} (h : A \u2264 B) (a : A) :\n    A.proj \u207b\u00b9' {a} \u2286 B.proj \u207b\u00b9' {ofLE h a}", "start": [371, 1], "end": [375, 25], "kind": "commanddeclaration"}, {"full_name": "DiscreteQuotient.exists_of_compat", "code": "theorem exists_of_compat [CompactSpace X] (Qs : (Q : DiscreteQuotient X) \u2192 Q)\n    (compat : \u2200 (A B : DiscreteQuotient X) (h : A \u2264 B), ofLE h (Qs _) = Qs _) :\n    \u2203 x : X, \u2200 Q : DiscreteQuotient X, Q.proj x = Qs _", "start": [378, 1], "end": [389, 29], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.discreteQuotient", "code": "def discreteQuotient : DiscreteQuotient X where\n  toSetoid := .comap f \u22a5\n  isOpen_setOf_rel _ := f.isLocallyConstant _", "start": [403, 1], "end": [406, 46], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.lift", "code": "def lift : LocallyConstant f.discreteQuotient \u03b1 :=\n  \u27e8fun a => Quotient.liftOn' a f fun _ _ => id, fun _ => isOpen_discrete _\u27e9", "start": [409, 1], "end": [412, 76], "kind": "commanddeclaration"}, {"full_name": "LocallyConstant.lift_comp_proj", "code": "@[simp]\ntheorem lift_comp_proj : f.lift \u2218 f.discreteQuotient.proj = f", "start": [415, 1], "end": [416, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/TopCat/Limits/Cofiltered.lean", "imports": ["Mathlib/Topology/Category/TopCat/Limits/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.isTopologicalBasis_cofiltered_limit", "code": "theorem isTopologicalBasis_cofiltered_limit (T : \u2200 j, Set (Set (F.obj j)))\n    (hT : \u2200 j, IsTopologicalBasis (T j)) (univ : \u2200 i : J, Set.univ \u2208 T i)\n    (inter : \u2200 (i) (U1 U2 : Set (F.obj i)), U1 \u2208 T i \u2192 U2 \u2208 T i \u2192 U1 \u2229 U2 \u2208 T i)\n    (compat : \u2200 (i j : J) (f : i \u27f6 j) (V : Set (F.obj j)) (_hV : V \u2208 T j), F.map f \u207b\u00b9' V \u2208 T i) :\n    IsTopologicalBasis\n      {U : Set C.pt | \u2203 (j : _) (V : Set (F.obj j)), V \u2208 T j \u2227 U = C.\u03c0.app j \u207b\u00b9' V}", "start": [38, 1], "end": [125, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/DiophantineApproximation.lean", "imports": ["Mathlib/Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean", "Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean", "Mathlib/Data/Real/Irrational.lean", "Mathlib/RingTheory/Coprime/Lemmas.lean", "Mathlib/Combinatorics/Pigeonhole.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Data/Int/Units.lean"], "premises": [{"full_name": "Real.exists_int_int_abs_mul_sub_le", "code": "theorem exists_int_int_abs_mul_sub_le (\u03be : \u211d) {n : \u2115} (n_pos : 0 < n) :\n    \u2203 j k : \u2124, 0 < k \u2227 k \u2264 n \u2227 |\u2191k * \u03be - j| \u2264 1 / (n + 1)", "start": [90, 1], "end": [135, 57], "kind": "commanddeclaration"}, {"full_name": "Real.exists_nat_abs_mul_sub_round_le", "code": "theorem exists_nat_abs_mul_sub_round_le (\u03be : \u211d) {n : \u2115} (n_pos : 0 < n) :\n    \u2203 k : \u2115, 0 < k \u2227 k \u2264 n \u2227 |\u2191k * \u03be - round (\u2191k * \u03be)| \u2264 1 / (n + 1)", "start": [138, 1], "end": [147, 95], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_abs_sub_le_and_den_le", "code": "theorem exists_rat_abs_sub_le_and_den_le (\u03be : \u211d) {n : \u2115} (n_pos : 0 < n) :\n    \u2203 q : \u211a, |\u03be - q| \u2264 1 / ((n + 1) * q.den) \u2227 q.den \u2264 n", "start": [150, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_abs_sub_lt_and_lt_of_irrational", "code": "theorem exists_rat_abs_sub_lt_and_lt_of_irrational {\u03be : \u211d} (h\u03be : Irrational \u03be) (q : \u211a) :\n    \u2203 q' : \u211a, |\u03be - q'| < 1 / (q'.den : \u211d) ^ 2 \u2227 |\u03be - q'| < |\u03be - q|", "start": [183, 1], "end": [202, 63], "kind": "commanddeclaration"}, {"full_name": "Real.infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational", "code": "theorem infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational {\u03be : \u211d} (h\u03be : Irrational \u03be) :\n    {q : \u211a | |\u03be - q| < 1 / (q.den : \u211d) ^ 2}.Infinite", "start": [205, 1], "end": [214, 58], "kind": "commanddeclaration"}, {"full_name": "Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq", "code": "theorem den_le_and_le_num_le_of_sub_lt_one_div_den_sq {\u03be q : \u211a}\n    (h : |\u03be - q| < 1 / (q.den : \u211a) ^ 2) :\n    q.den \u2264 \u03be.den \u2227 \u2308\u03be * q.den\u2309 - 1 \u2264 q.num \u2227 q.num \u2264 \u230a\u03be * q.den\u230b + 1", "start": [233, 1], "end": [261, 101], "kind": "commanddeclaration"}, {"full_name": "Rat.finite_rat_abs_sub_lt_one_div_den_sq", "code": "theorem finite_rat_abs_sub_lt_one_div_den_sq (\u03be : \u211a) :\n    {q : \u211a | |\u03be - q| < 1 / (q.den : \u211a) ^ 2}.Finite", "start": [264, 1], "end": [283, 101], "kind": "commanddeclaration"}, {"full_name": "Real.infinite_rat_abs_sub_lt_one_div_den_sq_iff_irrational", "code": "theorem Real.infinite_rat_abs_sub_lt_one_div_den_sq_iff_irrational (\u03be : \u211d) :\n    {q : \u211a | |\u03be - q| < 1 / (q.den : \u211d) ^ 2}.Infinite \u2194 Irrational \u03be", "start": [288, 1], "end": [297, 12], "kind": "commanddeclaration"}, {"full_name": "Real.convergent", "code": "noncomputable def convergent : \u211d \u2192 \u2115 \u2192 \u211a\n  | \u03be, 0 => \u230a\u03be\u230b\n  | \u03be, n + 1 => \u230a\u03be\u230b + (convergent (fract \u03be)\u207b\u00b9 n)\u207b\u00b9", "start": [326, 1], "end": [339, 51], "kind": "commanddeclaration"}, {"full_name": "Real.convergent_zero", "code": "@[simp]\ntheorem convergent_zero (\u03be : \u211d) : \u03be.convergent 0 = \u230a\u03be\u230b", "start": [342, 1], "end": [345, 6], "kind": "commanddeclaration"}, {"full_name": "Real.convergent_succ", "code": "@[simp]\ntheorem convergent_succ (\u03be : \u211d) (n : \u2115) :\n    \u03be.convergent (n + 1) = \u230a\u03be\u230b + ((fract \u03be)\u207b\u00b9.convergent n)\u207b\u00b9", "start": [348, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "Real.convergent_of_zero", "code": "@[simp]\ntheorem convergent_of_zero (n : \u2115) : convergent 0 n = 0", "start": [357, 1], "end": [362, 91], "kind": "commanddeclaration"}, {"full_name": "Real.convergent_of_int", "code": "@[simp]\ntheorem convergent_of_int {\u03be : \u2124} (n : \u2115) : convergent \u03be n = \u03be", "start": [365, 1], "end": [371, 16], "kind": "commanddeclaration"}, {"full_name": "Real.continued_fraction_convergent_eq_convergent", "code": "theorem continued_fraction_convergent_eq_convergent (\u03be : \u211d) (n : \u2115) :\n    (GeneralizedContinuedFraction.of \u03be).convergents n = \u03be.convergent n", "start": [381, 1], "end": [389, 14], "kind": "commanddeclaration"}, {"full_name": "Real.ContfracLegendre.Ass", "code": "def ContfracLegendre.Ass (\u03be : \u211d) (u v : \u2124) : Prop :=\n  IsCoprime u v \u2227 (v = 1 \u2192 (-(1 / 2) : \u211d) < \u03be - u) \u2227\n    |\u03be - u / v| < ((v : \u211d) * (2 * v - 1))\u207b\u00b9", "start": [406, 1], "end": [409, 44], "kind": "commanddeclaration"}, {"full_name": "Real.aux\u2080", "code": "private theorem aux\u2080 {v : \u2124} (hv : 0 < v) : (0 : \u211d) < v \u2227 (0 : \u211d) < 2 * v - 1", "start": [414, 1], "end": [415, 44], "kind": "commanddeclaration"}, {"full_name": "Real.aux\u2081", "code": "private theorem aux\u2081 : 0 < fract \u03be", "start": [421, 1], "end": [437, 24], "kind": "commanddeclaration"}, {"full_name": "Real.aux\u2082", "code": "private theorem aux\u2082 : 0 < u - \u230a\u03be\u230b * v \u2227 u - \u230a\u03be\u230b * v < v", "start": [440, 1], "end": [474, 74], "kind": "commanddeclaration"}, {"full_name": "Real.aux\u2083", "code": "private theorem aux\u2083 :\n    |(fract \u03be)\u207b\u00b9 - v / (u - \u230a\u03be\u230b * v)| < (((u : \u211d) - \u230a\u03be\u230b * v) * (2 * (u - \u230a\u03be\u230b * v) - 1))\u207b\u00b9", "start": [477, 1], "end": [513, 28], "kind": "commanddeclaration"}, {"full_name": "Real.invariant", "code": "private theorem invariant : ContfracLegendre.Ass (fract \u03be)\u207b\u00b9 v (u - \u230a\u03be\u230b * v)", "start": [516, 1], "end": [528, 62], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_eq_convergent'", "code": "theorem exists_rat_eq_convergent' {v : \u2115} (h' : ContfracLegendre.Ass \u03be u v) :\n    \u2203 n, (u / v : \u211a) = \u03be.convergent n", "start": [535, 1], "end": [579, 80], "kind": "commanddeclaration"}, {"full_name": "Real.exists_rat_eq_convergent", "code": "theorem exists_rat_eq_convergent {q : \u211a} (h : |\u03be - q| < 1 / (2 * (q.den : \u211d) ^ 2)) :\n    \u2203 n, q = \u03be.convergent n", "start": [582, 1], "end": [597, 101], "kind": "commanddeclaration"}, {"full_name": "Real.exists_continued_fraction_convergent_eq_rat", "code": "theorem exists_continued_fraction_convergent_eq_rat {q : \u211a}\n    (h : |\u03be - q| < 1 / (2 * (q.den : \u211d) ^ 2)) :\n    \u2203 n, (GeneralizedContinuedFraction.of \u03be).convergents n = q", "start": [600, 1], "end": [608, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Subterminal.lean", "imports": ["Mathlib/CategoryTheory/Limits/Shapes/Terminal.lean", "Mathlib/CategoryTheory/Limits/Shapes/BinaryProducts.lean", "Mathlib/CategoryTheory/Subobject/MonoOver.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.IsSubterminal", "code": "def IsSubterminal (A : C) : Prop :=\n  \u2200 \u2983Z : C\u2984 (f g : Z \u27f6 A), f = g", "start": [42, 1], "end": [44, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSubterminal.def", "code": "theorem IsSubterminal.def : IsSubterminal A \u2194 \u2200 \u2983Z : C\u2984 (f g : Z \u27f6 A), f = g", "start": [47, 1], "end": [48, 10], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSubterminal.mono_isTerminal_from", "code": "theorem IsSubterminal.mono_isTerminal_from (hA : IsSubterminal A) {T : C} (hT : IsTerminal T) :\n    Mono (hT.from A)", "start": [51, 1], "end": [56, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSubterminal.mono_terminal_from", "code": "theorem IsSubterminal.mono_terminal_from [HasTerminal C] (hA : IsSubterminal A) :\n    Mono (terminal.from A)", "start": [59, 1], "end": [64, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSubterminal_of_mono_isTerminal_from", "code": "theorem isSubterminal_of_mono_isTerminal_from {T : C} (hT : IsTerminal T) [Mono (hT.from A)] :\n    IsSubterminal A", "start": [67, 1], "end": [73, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSubterminal_of_mono_terminal_from", "code": "theorem isSubterminal_of_mono_terminal_from [HasTerminal C] [Mono (terminal.from A)] :\n    IsSubterminal A", "start": [76, 1], "end": [82, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSubterminal_of_isTerminal", "code": "theorem isSubterminal_of_isTerminal {T : C} (hT : IsTerminal T) : IsSubterminal T", "start": [85, 1], "end": [86, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSubterminal_of_terminal", "code": "theorem isSubterminal_of_terminal [HasTerminal C] : IsSubterminal (\u22a4_ C)", "start": [89, 1], "end": [90, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSubterminal.isIso_diag", "code": "theorem IsSubterminal.isIso_diag (hA : IsSubterminal A) [HasBinaryProduct A A] : IsIso (diag A)", "start": [93, 1], "end": [100, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isSubterminal_of_isIso_diag", "code": "theorem isSubterminal_of_isIso_diag [HasBinaryProduct A A] [IsIso (diag A)] : IsSubterminal A", "start": [103, 1], "end": [109, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsSubterminal.isoDiag", "code": "@[simps!]\ndef IsSubterminal.isoDiag (hA : IsSubterminal A) [HasBinaryProduct A A] : A \u2a2f A \u2245 A := by\n  letI := IsSubterminal.isIso_diag hA\n  apply (asIso (diag A)).symm", "start": [112, 1], "end": [116, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Subterminals", "code": "def Subterminals (C : Type u\u2081) [Category.{v\u2081} C] :=\n  FullSubcategory fun A : C => IsSubterminal A", "start": [121, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subterminalInclusion", "code": "@[simps!]\ndef subterminalInclusion : Subterminals C \u2964 C :=\n  fullSubcategoryInclusion _", "start": [136, 1], "end": [139, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subterminals_thin", "code": "instance subterminals_thin (X Y : Subterminals C) : Subsingleton (X \u27f6 Y) :=\n  \u27e8fun f g => Y.2 f g\u27e9", "start": [148, 1], "end": [149, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subterminalsEquivMonoOverTerminal", "code": "@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C \u224c MonoOver (\u22a4_ C) where\n  functor :=\n    { obj := fun X => \u27e8Over.mk (terminal.from X.1), X.2.mono_terminal_from\u27e9\n      map := fun f => MonoOver.homMk f (by ext1 \u27e8\u27e8\u27e9\u27e9) }\n  inverse :=\n    { obj := fun X =>\n        \u27e8X.obj.left, fun Z f g => by\n          rw [\u2190 cancel_mono X.arrow]\n          apply Subsingleton.elim\u27e9\n      map := fun f => f.1 }\n  unitIso := NatIso.ofComponents fun X => Iso.refl _\n  counitIso := NatIso.ofComponents fun X => MonoOver.isoMk (Iso.refl _)", "start": [152, 1], "end": [170, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subterminals_to_monoOver_terminal_comp_forget", "code": "@[simp]\ntheorem subterminals_to_monoOver_terminal_comp_forget [HasTerminal C] :\n    (subterminalsEquivMonoOverTerminal C).functor \u22d9 MonoOver.forget _ \u22d9 Over.forget _ =\n      subterminalInclusion C", "start": [173, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.monoOver_terminal_to_subterminals_comp", "code": "@[simp]\ntheorem monoOver_terminal_to_subterminals_comp [HasTerminal C] :\n    (subterminalsEquivMonoOverTerminal C).inverse \u22d9 subterminalInclusion C =\n      MonoOver.forget _ \u22d9 Over.forget _", "start": [180, 1], "end": [184, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Bicategory/Extension.lean", "imports": ["Mathlib/CategoryTheory/Bicategory/Basic.lean", "Mathlib/CategoryTheory/StructuredArrow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Bicategory.LeftExtension", "code": "abbrev LeftExtension (f : a \u27f6 b) (g : a \u27f6 c) := StructuredArrow g (precomp _ f)", "start": [38, 1], "end": [49, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftExtension.extension", "code": "abbrev extension (t : LeftExtension f g) : b \u27f6 c := t.right", "start": [55, 1], "end": [56, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftExtension.unit", "code": "abbrev unit (t : LeftExtension f g) : g \u27f6 f \u226b t.extension := t.hom", "start": [58, 1], "end": [59, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftExtension.alongId", "code": "def alongId (g : a \u27f6 c) : LeftExtension (\ud835\udfd9 a) g := StructuredArrow.mk (\u03bb_ g).inv", "start": [61, 1], "end": [62, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftLift", "code": "abbrev LeftLift (f : b \u27f6 a) (g : c \u27f6 a) := StructuredArrow g (postcomp _ f)", "start": [68, 1], "end": [79, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftLift.lift", "code": "abbrev lift (t : LeftLift f g) : c \u27f6 b := t.right", "start": [85, 1], "end": [86, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftLift.unit", "code": "abbrev unit (t : LeftLift f g) : g \u27f6 t.lift \u226b f := t.hom", "start": [88, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.LeftLift.alongId", "code": "def alongId (g : c \u27f6 a) : LeftLift (\ud835\udfd9 a) g := StructuredArrow.mk (\u03c1_ g).inv", "start": [91, 1], "end": [92, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightExtension", "code": "abbrev RightExtension (f : a \u27f6 b) (g : a \u27f6 c) := CostructuredArrow (precomp _ f) g", "start": [98, 1], "end": [109, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightExtension.extension", "code": "abbrev extension (t : RightExtension f g) : b \u27f6 c := t.left", "start": [115, 1], "end": [116, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightExtension.counit", "code": "abbrev counit (t : RightExtension f g) : f \u226b t.extension \u27f6 g := t.hom", "start": [118, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightExtension.alongId", "code": "def alongId (g : a \u27f6 c) : RightExtension (\ud835\udfd9 a) g := CostructuredArrow.mk (\u03bb_ g).hom", "start": [121, 1], "end": [122, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightLift", "code": "abbrev RightLift (f : b \u27f6 a) (g : c \u27f6 a) := CostructuredArrow (postcomp _ f) g", "start": [128, 1], "end": [139, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightLift.lift", "code": "abbrev lift (t : RightLift f g) : c \u27f6 b := t.left", "start": [145, 1], "end": [146, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightLift.counit", "code": "abbrev counit (t : RightLift f g) : t.lift \u226b f \u27f6 g := t.hom", "start": [148, 1], "end": [149, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Bicategory.RightLift.alongId", "code": "def alongId (g : c \u27f6 a) : RightLift (\ud835\udfd9 a) g := CostructuredArrow.mk (\u03c1_ g).hom", "start": [151, 1], "end": [152, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Injective.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/Data/TypeMax.lean", "Mathlib/CategoryTheory/Preadditive/Injective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/LinearPMap.lean", "Mathlib/Algebra/Category/ModuleCat/EpiMono.lean"], "premises": [{"full_name": "Module.Injective", "code": "class Module.Injective : Prop where\n  out : \u2200 (X Y : TypeMax.{v,u}) [AddCommGroup X] [AddCommGroup Y] [Module R X] [Module R Y]\n    (f : X \u2192\u2097[R] Y) (_ : Function.Injective f) (g : X \u2192\u2097[R] Q),\n    \u2203 h : Y \u2192\u2097[R] Q, \u2200 x, h (f x) = g x", "start": [45, 1], "end": [60, 40], "kind": "commanddeclaration"}, {"full_name": "Module.injective_object_of_injective_module", "code": "theorem Module.injective_object_of_injective_module [Module.Injective.{u, v} R Q] :\n    CategoryTheory.Injective.{max u v} (\u27e8Q\u27e9 : ModuleCat.{max u v} R)", "start": [64, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "Module.injective_module_of_injective_object", "code": "theorem Module.injective_module_of_injective_object\n    [CategoryTheory.Injective.{max u v} (\u27e8Q\u27e9 : ModuleCat.{max u v} R)] :\n    Module.Injective.{u, v} R Q", "start": [71, 1], "end": [79, 32], "kind": "commanddeclaration"}, {"full_name": "Module.injective_iff_injective_object", "code": "theorem Module.injective_iff_injective_object :\n    Module.Injective.{u, v} R Q \u2194\n      CategoryTheory.Injective.{max u v} (\u27e8Q\u27e9 : ModuleCat.{max u v} R)", "start": [82, 1], "end": [86, 62], "kind": "commanddeclaration"}, {"full_name": "Module.Baer", "code": "def Module.Baer : Prop :=\n  \u2200 (I : Ideal R) (g : I \u2192\u2097[R] Q), \u2203 g' : R \u2192\u2097[R] Q, \u2200 (x : R) (mem : x \u2208 I), g' x = g \u27e8x, mem\u27e9", "start": [89, 1], "end": [92, 96], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf", "code": "structure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i \u2264 domain\n  is_extension : \u2200 m : M, f m = toLinearPMap \u27e8i m, le \u27e8m, rfl\u27e9\u27e9", "start": [102, 1], "end": [107, 64], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf.ext", "code": "@[ext]\ntheorem ExtensionOf.ext {a b : ExtensionOf i f} (domain_eq : a.domain = b.domain)\n    (to_fun_eq :\n      \u2200 \u2983x : a.domain\u2984 \u2983y : b.domain\u2984, (x : N) = y \u2192 a.toLinearPMap x = b.toLinearPMap y) :\n    a = b", "start": [115, 1], "end": [123, 43], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf.ext_iff", "code": "theorem ExtensionOf.ext_iff {a b : ExtensionOf i f} :\n    a = b \u2194 \u2203 _ : a.domain = b.domain, \u2200 \u2983x : a.domain\u2984 \u2983y : b.domain\u2984,\n    (x : N) = y \u2192 a.toLinearPMap x = b.toLinearPMap y", "start": [127, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.chain_linearPMap_of_chain_extensionOf", "code": "theorem chain_linearPMap_of_chain_extensionOf {c : Set (ExtensionOf i f)}\n    (hchain : IsChain (\u00b7 \u2264 \u00b7) c) :\n    IsChain (\u00b7 \u2264 \u00b7) <| (fun x : ExtensionOf i f => x.toLinearPMap) '' c", "start": [167, 1], "end": [171, 50], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf.max", "code": "def ExtensionOf.max {c : Set (ExtensionOf i f)} (hchain : IsChain (\u00b7 \u2264 \u00b7) c)\n    (hnonempty : c.Nonempty) : ExtensionOf i f :=\n  {\n    LinearPMap.sSup _\n      (IsChain.directedOn <|\n        chain_linearPMap_of_chain_extensionOf\n          hchain) with\n    le := by\n      refine' le_trans hnonempty.some.le <|\n        (LinearPMap.le_sSup _ <|\n            (Set.mem_image _ _ _).mpr \u27e8hnonempty.some, hnonempty.choose_spec, rfl\u27e9).1\n      exact (IsChain.directedOn <| chain_linearPMap_of_chain_extensionOf hchain)\n    is_extension := fun m => by\n      refine' Eq.trans (hnonempty.some.is_extension m) _\n      symm\n      generalize_proofs _ h1\n      exact\n        LinearPMap.sSup_apply (IsChain.directedOn <| chain_linearPMap_of_chain_extensionOf hchain)\n          ((Set.mem_image _ _ _).mpr \u27e8hnonempty.some, hnonempty.choose_spec, rfl\u27e9) \u27e8i m, h1\u27e9 }", "start": [175, 1], "end": [197, 95], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf.le_max", "code": "theorem ExtensionOf.le_max {c : Set (ExtensionOf i f)} (hchain : IsChain (\u00b7 \u2264 \u00b7) c)\n    (hnonempty : c.Nonempty) (a : ExtensionOf i f) (ha : a \u2208 c) :\n    a \u2264 ExtensionOf.max hchain hnonempty", "start": [201, 1], "end": [205, 43], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOf.inhabited", "code": "instance ExtensionOf.inhabited : Inhabited (ExtensionOf i f) where\n  default :=\n    { domain := LinearMap.range i\n      toFun :=\n        { toFun := fun x => f x.2.choose\n          map_add' := fun x y => by\n            have eq1 : _ + _ = (x + y).1 := congr_arg\u2082 (\u00b7 + \u00b7) x.2.choose_spec y.2.choose_spec\n            rw [\u2190 map_add, \u2190 (x + y).2.choose_spec] at eq1\n            dsimp\n            rw [\u2190 Fact.out (p := Function.Injective i) eq1, map_add]\n          map_smul' := fun r x => by\n            have eq1 : r \u2022 _ = (r \u2022 x).1 := congr_arg ((\u00b7 \u2022 \u00b7) r) x.2.choose_spec\n            rw [\u2190 LinearMap.map_smul, \u2190 (r \u2022 x).2.choose_spec] at eq1\n            dsimp\n            rw [\u2190 Fact.out (p := Function.Injective i) eq1, LinearMap.map_smul] }\n      le := le_refl _\n      is_extension := fun m => by\n        simp only [LinearPMap.mk_apply, LinearMap.coe_mk]\n        dsimp\n        apply congrArg\n        exact Fact.out (p := Function.Injective i)\n          (\u27e8i m, \u27e8_, rfl\u27e9\u27e9 : LinearMap.range i).2.choose_spec.symm }", "start": [211, 1], "end": [232, 69], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMax", "code": "def extensionOfMax : ExtensionOf i f :=\n  (@zorn_nonempty_partialOrder (ExtensionOf i f) _ \u27e8Inhabited.default\u27e9 fun _ hchain hnonempty =>\n      \u27e8ExtensionOf.max hchain hnonempty, ExtensionOf.le_max hchain hnonempty\u27e9).choose", "start": [236, 1], "end": [240, 86], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMax_is_max", "code": "theorem extensionOfMax_is_max :\n    \u2200 a : ExtensionOf i f, extensionOfMax i f \u2264 a \u2192 a = extensionOfMax i f", "start": [244, 1], "end": [247, 91], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.supExtensionOfMaxSingleton", "code": "@[reducible]\ndef supExtensionOfMaxSingleton (y : N) : Submodule R N :=\n  (extensionOfMax i f).domain \u2294 (Submodule.span R {y})", "start": [253, 1], "end": [255, 55], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMax_adjoin.aux1", "code": "private theorem extensionOfMax_adjoin.aux1 {y : N} (x : supExtensionOfMaxSingleton i f y) :\n    \u2203 (a : (extensionOfMax i f).domain) (b : R), x.1 = a.1 + b \u2022 y", "start": [259, 1], "end": [266, 46], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.fst", "code": "def ExtensionOfMaxAdjoin.fst {y : N} (x : supExtensionOfMaxSingleton i f y) :\n    (extensionOfMax i f).domain :=\n  (extensionOfMax_adjoin.aux1 i x).choose", "start": [271, 1], "end": [274, 42], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.snd", "code": "def ExtensionOfMaxAdjoin.snd {y : N} (x : supExtensionOfMaxSingleton i f y) : R :=\n  (extensionOfMax_adjoin.aux1 i x).choose_spec.choose", "start": [278, 1], "end": [280, 54], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.eqn", "code": "theorem ExtensionOfMaxAdjoin.eqn {y : N} (x : supExtensionOfMaxSingleton i f y) :\n    \u2191x = \u2191(ExtensionOfMaxAdjoin.fst i x) + ExtensionOfMaxAdjoin.snd i x \u2022 y", "start": [284, 1], "end": [286, 59], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.ideal", "code": "def ExtensionOfMaxAdjoin.ideal (y : N) : Ideal R :=\n  (extensionOfMax i f).domain.comap ((LinearMap.id : R \u2192\u2097[R] R).smulRight y)", "start": [293, 1], "end": [295, 77], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.idealTo", "code": "def ExtensionOfMaxAdjoin.idealTo (y : N) : ExtensionOfMaxAdjoin.ideal i f y \u2192\u2097[R] Q where\n  toFun (z : { x // x \u2208 ideal i f y }) := (extensionOfMax i f).toLinearPMap \u27e8(\u2191z : R) \u2022 y, z.prop\u27e9\n  map_add' (z1 z2 : { x // x \u2208 ideal i f y }) := by\n    simp_rw [\u2190 (extensionOfMax i f).toLinearPMap.map_add]\n    congr\n    apply add_smul\n  map_smul' z1 (z2 : {x // x \u2208 ideal i f y}) := by\n    simp_rw [\u2190 (extensionOfMax i f).toLinearPMap.map_smul]\n    congr 2\n    apply mul_smul", "start": [299, 1], "end": [311, 19], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo", "code": "def ExtensionOfMaxAdjoin.extendIdealTo (h : Module.Baer R Q) (y : N) : R \u2192\u2097[R] Q :=\n  (h (ExtensionOfMaxAdjoin.ideal i f y) (ExtensionOfMaxAdjoin.idealTo i f y)).choose", "start": [315, 1], "end": [318, 85], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_is_extension", "code": "theorem ExtensionOfMaxAdjoin.extendIdealTo_is_extension (h : Module.Baer R Q) (y : N) :\n    \u2200 (x : R) (mem : x \u2208 ExtensionOfMaxAdjoin.ideal i f y),\n      ExtensionOfMaxAdjoin.extendIdealTo i f h y x = ExtensionOfMaxAdjoin.idealTo i f y \u27e8x, mem\u27e9", "start": [322, 1], "end": [325, 90], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_wd'", "code": "theorem ExtensionOfMaxAdjoin.extendIdealTo_wd' (h : Module.Baer R Q) {y : N} (r : R)\n    (eq1 : r \u2022 y = 0) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r = 0", "start": [329, 1], "end": [338, 48], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_wd", "code": "theorem ExtensionOfMaxAdjoin.extendIdealTo_wd (h : Module.Baer R Q) {y : N} (r r' : R)\n    (eq1 : r \u2022 y = r' \u2022 y) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    ExtensionOfMaxAdjoin.extendIdealTo i f h y r'", "start": [342, 1], "end": [347, 34], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_eq", "code": "theorem ExtensionOfMaxAdjoin.extendIdealTo_eq (h : Module.Baer R Q) {y : N} (r : R)\n    (hr : r \u2022 y \u2208 (extensionOfMax i f).domain) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    (extensionOfMax i f).toLinearPMap \u27e8r \u2022 y, hr\u27e9", "start": [351, 1], "end": [356, 83], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extensionToFun", "code": "def ExtensionOfMaxAdjoin.extensionToFun (h : Module.Baer R Q) {y : N} :\n    supExtensionOfMaxSingleton i f y \u2192 Q := fun x =>\n  (extensionOfMax i f).toLinearPMap (ExtensionOfMaxAdjoin.fst i x) +\n    ExtensionOfMaxAdjoin.extendIdealTo i f h y (ExtensionOfMaxAdjoin.snd i x)", "start": [360, 1], "end": [365, 78], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.ExtensionOfMaxAdjoin.extensionToFun_wd", "code": "theorem ExtensionOfMaxAdjoin.extensionToFun_wd (h : Module.Baer R Q) {y : N}\n    (x : supExtensionOfMaxSingleton i f y) (a : (extensionOfMax i f).domain)\n    (r : R) (eq1 : \u2191x = \u2191a + r \u2022 y) :\n    ExtensionOfMaxAdjoin.extensionToFun i f h x =\n      (extensionOfMax i f).toLinearPMap a + ExtensionOfMaxAdjoin.extendIdealTo i f h y r", "start": [369, 1], "end": [390, 61], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMaxAdjoin", "code": "def extensionOfMaxAdjoin (h : Module.Baer R Q) (y : N) : ExtensionOf i f where\n  domain := supExtensionOfMaxSingleton i f y le := le_trans (extensionOfMax i f).le le_sup_left\n  toFun :=\n    { toFun := ExtensionOfMaxAdjoin.extensionToFun i f h\n      map_add' := fun a b => by\n        have eq1 :\n          \u2191a + \u2191b =\n            \u2191(ExtensionOfMaxAdjoin.fst i a + ExtensionOfMaxAdjoin.fst i b) +\n              (ExtensionOfMaxAdjoin.snd i a + ExtensionOfMaxAdjoin.snd i b) \u2022 y := by\n          rw [ExtensionOfMaxAdjoin.eqn, ExtensionOfMaxAdjoin.eqn, add_smul, Submodule.coe_add]\n          ac_rfl\n        rw [ExtensionOfMaxAdjoin.extensionToFun_wd (y := y) i f h (a + b) _ _ eq1,\n          LinearPMap.map_add, map_add]\n        unfold ExtensionOfMaxAdjoin.extensionToFun\n        abel\n      map_smul' := fun r a => by\n        dsimp\n        have eq1 :\n          r \u2022 (a : N) =\n            \u2191(r \u2022 ExtensionOfMaxAdjoin.fst i a) + (r \u2022 ExtensionOfMaxAdjoin.snd i a) \u2022 y := by\n          rw [ExtensionOfMaxAdjoin.eqn, smul_add, smul_eq_mul, mul_smul]\n          rfl\n        rw [ExtensionOfMaxAdjoin.extensionToFun_wd i f h (r \u2022 a) _ _ eq1, LinearMap.map_smul,\n          LinearPMap.map_smul, \u2190 smul_add]\n        congr }\n  is_extension m := by\n    dsimp\n    rw [(extensionOfMax i f).is_extension,\n      ExtensionOfMaxAdjoin.extensionToFun_wd i f h _ \u27e8i m, _\u27e9 0 _, map_zero, add_zero]\n    simp", "start": [394, 1], "end": [425, 9], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMax_le", "code": "theorem extensionOfMax_le (h : Module.Baer R Q) {y : N} :\n    extensionOfMax i f \u2264 extensionOfMaxAdjoin i f h y", "start": [429, 1], "end": [435, 17], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.extensionOfMax_to_submodule_eq_top", "code": "theorem extensionOfMax_to_submodule_eq_top (h : Module.Baer R Q) :\n    (extensionOfMax i f).domain = \u22a4", "start": [439, 1], "end": [445, 86], "kind": "commanddeclaration"}, {"full_name": "Module.Baer.injective", "code": "protected theorem injective (h : Module.Baer R Q) : Module.Injective R Q", "start": [449, 1], "end": [464, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Embedding.lean", "imports": ["Mathlib/Logic/Embedding/Set.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.sumEmbeddingEquivProdEmbeddingDisjoint", "code": "def sumEmbeddingEquivProdEmbeddingDisjoint {\u03b1 \u03b2 \u03b3 : Type*} :\n    (Sum \u03b1 \u03b2 \u21aa \u03b3) \u2243 { f : (\u03b1 \u21aa \u03b3) \u00d7 (\u03b2 \u21aa \u03b3) // Disjoint (Set.range f.1) (Set.range f.2) } where\n  toFun f :=\n    \u27e8(inl.trans f, inr.trans f), by\n      rw [Set.disjoint_left]\n      rintro _ \u27e8a, h\u27e9 \u27e8b, rfl\u27e9\n      simp only [trans_apply, inl_apply, inr_apply] at h\n      have : Sum.inl a = Sum.inr b := f.injective h\n      simp only at this\u27e9\n  invFun := fun \u27e8\u27e8f, g\u27e9, disj\u27e9 =>\n    \u27e8fun x =>\n      match x with\n      | Sum.inl a => f a\n      | Sum.inr b => g b, by\n      rintro (a\u2081 | b\u2081) (a\u2082 | b\u2082) f_eq <;>\n        simp only [Equiv.coe_fn_symm_mk, Sum.elim_inl, Sum.elim_inr] at f_eq\n      \u00b7 rw [f.injective f_eq]\n      \u00b7 exfalso\n        refine disj.le_bot \u27e8\u27e8a\u2081, f_eq\u27e9, \u27e8b\u2082, by simp [f_eq]\u27e9\u27e9\n      \u00b7 exfalso\n        exact disj.le_bot \u27e8\u27e8a\u2082, rfl\u27e9, \u27e8b\u2081, f_eq\u27e9\u27e9\n      \u00b7 rw [g.injective f_eq]\u27e9\n  left_inv f := by\n    dsimp only\n    ext x\n    cases x <;> simp!\n  right_inv := fun \u27e8\u27e8f, g\u27e9, _\u27e9 => by\n    simp only [Prod.mk.inj_iff]\n    constructor", "start": [22, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.codRestrict", "code": "def codRestrict (\u03b1 : Type*) {\u03b2 : Type*} (bs : Set \u03b2) :\n    { f : \u03b1 \u21aa \u03b2 // \u2200 a, f a \u2208 bs } \u2243\n      (\u03b1 \u21aa bs) where\n  toFun f := (f : \u03b1 \u21aa \u03b2).codRestrict bs f.prop\n  invFun f := \u27e8f.trans (Function.Embedding.subtype _), fun a => (f a).prop\u27e9\n  left_inv x := by ext; rfl\n  right_inv x := by ext; rfl", "start": [54, 1], "end": [62, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodEmbeddingDisjointEquivSigmaEmbeddingRestricted", "code": "def prodEmbeddingDisjointEquivSigmaEmbeddingRestricted {\u03b1 \u03b2 \u03b3 : Type*} :\n    { f : (\u03b1 \u21aa \u03b3) \u00d7 (\u03b2 \u21aa \u03b3) // Disjoint (Set.range f.1) (Set.range f.2) } \u2243\n      \u03a3f : \u03b1 \u21aa \u03b3, \u03b2 \u21aa \u21a5(Set.range f)\u1d9c :=\n  (subtypeProdEquivSigmaSubtype fun (a : \u03b1 \u21aa \u03b3) (b : \u03b2 \u21aa _) =>\n        Disjoint (Set.range a) (Set.range b)).trans <|\n    Equiv.sigmaCongrRight fun a =>\n      (subtypeEquivProp <| by\n            ext f\n            rw [\u2190 Set.range_subset_iff, Set.subset_compl_iff_disjoint_right, disjoint_comm]).trans\n        (codRestrict _ _)", "start": [65, 1], "end": [76, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumEmbeddingEquivSigmaEmbeddingRestricted", "code": "def sumEmbeddingEquivSigmaEmbeddingRestricted {\u03b1 \u03b2 \u03b3 : Type*} :\n    (Sum \u03b1 \u03b2 \u21aa \u03b3) \u2243 \u03a3f : \u03b1 \u21aa \u03b3, \u03b2 \u21aa \u21a5(Set.range f)\u1d9c :=\n  Equiv.trans sumEmbeddingEquivProdEmbeddingDisjoint\n    prodEmbeddingDisjointEquivSigmaEmbeddingRestricted", "start": [79, 1], "end": [85, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniqueEmbeddingEquivResult", "code": "def uniqueEmbeddingEquivResult {\u03b1 \u03b2 : Type*} [Unique \u03b1] :\n    (\u03b1 \u21aa \u03b2) \u2243 \u03b2 where\n  toFun f := f default\n  invFun x := \u27e8fun _ => x, fun _ _ _ => Subsingleton.elim _ _\u27e9\n  left_inv _ := by\n    ext x\n    simp_rw [Function.Embedding.coeFn_mk]\n    congr 1\n    exact Subsingleton.elim _ x\n  right_inv _ := by simp", "start": [88, 1], "end": [98, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Game/State.lean", "imports": ["Mathlib/SetTheory/Game/Short.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetTheory.PGame.State", "code": "class State (S : Type u) where\n  turnBound : S \u2192 \u2115\n  l : S \u2192 Finset S\n  r : S \u2192 Finset S\n  left_bound : \u2200 {s t : S}, t \u2208 l s \u2192 turnBound t < turnBound s\n  right_bound : \u2200 {s t : S}, t \u2208 r s \u2192 turnBound t < turnBound s", "start": [31, 1], "end": [43, 65], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.turnBound_ne_zero_of_left_move", "code": "theorem turnBound_ne_zero_of_left_move {s t : S} (m : t \u2208 l s) : turnBound s \u2260 0", "start": [50, 1], "end": [54, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.turnBound_ne_zero_of_right_move", "code": "theorem turnBound_ne_zero_of_right_move {s t : S} (m : t \u2208 r s) : turnBound s \u2260 0", "start": [57, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.turnBound_of_left", "code": "theorem turnBound_of_left {s t : S} (m : t \u2208 l s) (n : \u2115) (h : turnBound s \u2264 n + 1) :\n    turnBound t \u2264 n", "start": [64, 1], "end": [66, 58], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.turnBound_of_right", "code": "theorem turnBound_of_right {s t : S} (m : t \u2208 r s) (n : \u2115) (h : turnBound s \u2264 n + 1) :\n    turnBound t \u2264 n", "start": [69, 1], "end": [71, 59], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ofStateAux", "code": "def ofStateAux : \u2200 (n : \u2115) (s : S), turnBound s \u2264 n \u2192 PGame\n  | 0, s, h =>\n    PGame.mk { t // t \u2208 l s } { t // t \u2208 r s }\n      (fun t => by exfalso; exact turnBound_ne_zero_of_left_move t.2 (nonpos_iff_eq_zero.mp h))\n      fun t => by exfalso; exact turnBound_ne_zero_of_right_move t.2 (nonpos_iff_eq_zero.mp h)\n  | n + 1, s, h =>\n    PGame.mk { t // t \u2208 l s } { t // t \u2208 r s }\n      (fun t => ofStateAux n t (turnBound_of_left t.2 n h)) fun t =>\n      ofStateAux n t (turnBound_of_right t.2 n h)", "start": [74, 1], "end": [85, 50], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ofStateAuxRelabelling", "code": "def ofStateAuxRelabelling :\n    \u2200 (s : S) (n m : \u2115) (hn : turnBound s \u2264 n) (hm : turnBound s \u2264 m),\n      Relabelling (ofStateAux n s hn) (ofStateAux m s hm)\n  | s, 0, 0, hn, hm => by\n    dsimp [PGame.ofStateAux]\n    fconstructor; rfl; rfl\n    \u00b7 intro i; dsimp at i; exfalso\n      exact turnBound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp hn)\n    \u00b7 intro j; dsimp at j; exfalso\n      exact turnBound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp hm)\n  | s, 0, m + 1, hn, hm => by\n    dsimp [PGame.ofStateAux]\n    fconstructor; rfl; rfl\n    \u00b7 intro i; dsimp at i; exfalso\n      exact turnBound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp hn)\n    \u00b7 intro j; dsimp at j; exfalso\n      exact turnBound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp hn)\n  | s, n + 1, 0, hn, hm => by\n    dsimp [PGame.ofStateAux]\n    fconstructor; rfl; rfl\n    \u00b7 intro i; dsimp at i; exfalso\n      exact turnBound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp hm)\n    \u00b7 intro j; dsimp at j; exfalso\n      exact turnBound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp hm)\n  | s, n + 1, m + 1, hn, hm => by\n    dsimp [PGame.ofStateAux]\n    fconstructor; rfl; rfl\n    \u00b7 intro i\n      apply ofStateAuxRelabelling\n    \u00b7 intro j\n      apply ofStateAuxRelabelling", "start": [88, 1], "end": [119, 34], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.ofState", "code": "def ofState (s : S) : PGame :=\n  ofStateAux (turnBound s) s (refl _)", "start": [122, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leftMovesOfStateAux", "code": "def leftMovesOfStateAux (n : \u2115) {s : S} (h : turnBound s \u2264 n) :\n    LeftMoves (ofStateAux n s h) \u2243 { t // t \u2208 l s } := by induction n <;> rfl", "start": [127, 1], "end": [130, 78], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.leftMovesOfState", "code": "def leftMovesOfState (s : S) : LeftMoves (ofState s) \u2243 { t // t \u2208 l s } :=\n  leftMovesOfStateAux _ _", "start": [133, 1], "end": [135, 26], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.rightMovesOfStateAux", "code": "def rightMovesOfStateAux (n : \u2115) {s : S} (h : turnBound s \u2264 n) :\n    RightMoves (ofStateAux n s h) \u2243 { t // t \u2208 r s } := by induction n <;> rfl", "start": [138, 1], "end": [141, 79], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.rightMovesOfState", "code": "def rightMovesOfState (s : S) : RightMoves (ofState s) \u2243 { t // t \u2208 r s } :=\n  rightMovesOfStateAux _ _", "start": [144, 1], "end": [147, 27], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.relabellingMoveLeftAux", "code": "def relabellingMoveLeftAux (n : \u2115) {s : S} (h : turnBound s \u2264 n)\n    (t : LeftMoves (ofStateAux n s h)) :\n    Relabelling (moveLeft (ofStateAux n s h) t)\n      (ofStateAux (n - 1) ((leftMovesOfStateAux n h) t : S)\n        (turnBound_of_left ((leftMovesOfStateAux n h) t).2 (n - 1)\n          (Nat.le_trans h le_tsub_add))) := by\n  induction n\n  \u00b7 have t' := (leftMovesOfStateAux 0 h) t\n    exfalso; exact turnBound_ne_zero_of_left_move t'.2 (nonpos_iff_eq_zero.mp h)\n  \u00b7 rfl", "start": [150, 1], "end": [162, 8], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.relabellingMoveLeft", "code": "def relabellingMoveLeft (s : S) (t : LeftMoves (ofState s)) :\n    Relabelling (moveLeft (ofState s) t) (ofState ((leftMovesOfState s).toFun t : S)) := by\n  trans\n  apply relabellingMoveLeftAux\n  apply ofStateAuxRelabelling", "start": [165, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.relabellingMoveRightAux", "code": "def relabellingMoveRightAux (n : \u2115) {s : S} (h : turnBound s \u2264 n)\n    (t : RightMoves (ofStateAux n s h)) :\n    Relabelling (moveRight (ofStateAux n s h) t)\n      (ofStateAux (n - 1) ((rightMovesOfStateAux n h) t : S)\n        (turnBound_of_right ((rightMovesOfStateAux n h) t).2 (n - 1)\n          (Nat.le_trans h le_tsub_add))) := by\n  induction n\n  \u00b7 have t' := (rightMovesOfStateAux 0 h) t\n    exfalso; exact turnBound_ne_zero_of_right_move t'.2 (nonpos_iff_eq_zero.mp h)\n  \u00b7 rfl", "start": [175, 1], "end": [187, 8], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.relabellingMoveRight", "code": "def relabellingMoveRight (s : S) (t : RightMoves (ofState s)) :\n    Relabelling (moveRight (ofState s) t) (ofState ((rightMovesOfState s).toFun t : S)) := by\n  trans\n  apply relabellingMoveRightAux\n  apply ofStateAuxRelabelling", "start": [190, 1], "end": [197, 30], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeLeftMovesOfStateAux", "code": "instance fintypeLeftMovesOfStateAux (n : \u2115) (s : S) (h : turnBound s \u2264 n) :\n    Fintype (LeftMoves (ofStateAux n s h)) := by\n  apply Fintype.ofEquiv _ (leftMovesOfStateAux _ _).symm", "start": [200, 1], "end": [202, 57], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.fintypeRightMovesOfStateAux", "code": "instance fintypeRightMovesOfStateAux (n : \u2115) (s : S) (h : turnBound s \u2264 n) :\n    Fintype (RightMoves (ofStateAux n s h)) := by\n  apply Fintype.ofEquiv _ (rightMovesOfStateAux _ _).symm", "start": [205, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOfStateAux", "code": "instance shortOfStateAux : \u2200 (n : \u2115) {s : S} (h : turnBound s \u2264 n), Short (ofStateAux n s h)\n  | 0, s, h =>\n    Short.mk'\n      (fun i => by\n        have i := (leftMovesOfStateAux _ _).toFun i\n        exfalso\n        exact turnBound_ne_zero_of_left_move i.2 (nonpos_iff_eq_zero.mp h))\n      fun j => by\n      have j := (rightMovesOfStateAux _ _).toFun j\n      exfalso\n      exact turnBound_ne_zero_of_right_move j.2 (nonpos_iff_eq_zero.mp h)\n  | n + 1, s, h =>\n    Short.mk'\n      (fun i =>\n        shortOfRelabelling (relabellingMoveLeftAux (n + 1) h i).symm (shortOfStateAux n _))\n      fun j =>\n      shortOfRelabelling (relabellingMoveRightAux (n + 1) h j).symm (shortOfStateAux n _)", "start": [210, 1], "end": [226, 90], "kind": "commanddeclaration"}, {"full_name": "SetTheory.PGame.shortOfState", "code": "instance shortOfState (s : S) : Short (ofState s) := by\n  dsimp [PGame.ofState]\n  infer_instance", "start": [229, 1], "end": [231, 17], "kind": "commanddeclaration"}, {"full_name": "SetTheory.Game.ofState", "code": "def ofState {S : Type u} [PGame.State S] (s : S) : Game :=\n  \u27e6PGame.ofState s\u27e7", "start": [238, 1], "end": [240, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/IsAdjoinRoot.lean", "imports": ["Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "Mathlib/RingTheory/PowerBasis.lean", "Mathlib/Data/Polynomial/AlgebraMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsAdjoinRoot", "code": "structure IsAdjoinRoot {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) : Type max u v where\n  map : R[X] \u2192+* S\n  map_surjective : Function.Surjective map\n  ker_map : RingHom.ker map = Ideal.span {f}\n  algebraMap_eq : algebraMap R S = map.comp Polynomial.C", "start": [77, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic", "code": "structure IsAdjoinRootMonic {R : Type u} (S : Type v) [CommSemiring R] [Semiring S] [Algebra R S]\n    (f : R[X]) extends IsAdjoinRoot S f where\n  Monic : Monic f", "start": [96, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.root", "code": "def root (h : IsAdjoinRoot S f) : S :=\n  h.map X", "start": [118, 1], "end": [120, 10], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.subsingleton", "code": "theorem subsingleton (h : IsAdjoinRoot S f) [Subsingleton R] : Subsingleton S", "start": [123, 1], "end": [124, 32], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.algebraMap_apply", "code": "theorem algebraMap_apply (h : IsAdjoinRoot S f) (x : R) :\n    algebraMap R S x = h.map (Polynomial.C x)", "start": [127, 1], "end": [128, 93], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.mem_ker_map", "code": "@[simp]\ntheorem mem_ker_map (h : IsAdjoinRoot S f) {p} : p \u2208 RingHom.ker h.map \u2194 f \u2223 p", "start": [131, 1], "end": [133, 43], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.map_eq_zero_iff", "code": "theorem map_eq_zero_iff (h : IsAdjoinRoot S f) {p} : h.map p = 0 \u2194 f \u2223 p", "start": [136, 1], "end": [137, 40], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.map_X", "code": "@[simp]\ntheorem map_X (h : IsAdjoinRoot S f) : h.map X = h.root", "start": [140, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.map_self", "code": "@[simp]\ntheorem map_self (h : IsAdjoinRoot S f) : h.map f = 0", "start": [145, 1], "end": [146, 87], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aeval_eq", "code": "@[simp]\ntheorem aeval_eq (h : IsAdjoinRoot S f) (p : R[X]) : aeval h.root p = h.map p", "start": [149, 1], "end": [154, 30], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aeval_root", "code": "theorem aeval_root (h : IsAdjoinRoot S f) : aeval h.root f = 0", "start": [158, 1], "end": [158, 93], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.repr", "code": "def repr (h : IsAdjoinRoot S f) (x : S) : R[X] :=\n  (h.map_surjective x).choose", "start": [161, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.map_repr", "code": "theorem map_repr (h : IsAdjoinRoot S f) (x : S) : h.map (h.repr x) = x", "start": [169, 1], "end": [170, 35], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.repr_zero_mem_span", "code": "theorem repr_zero_mem_span (h : IsAdjoinRoot S f) : h.repr 0 \u2208 Ideal.span ({f} : Set R[X])", "start": [173, 1], "end": [175, 48], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.repr_add_sub_repr_add_repr_mem_span", "code": "theorem repr_add_sub_repr_add_repr_mem_span (h : IsAdjoinRoot S f) (x y : S) :\n    h.repr (x + y) - (h.repr x + h.repr y) \u2208 Ideal.span ({f} : Set R[X])", "start": [178, 1], "end": [181, 100], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.ext_map", "code": "theorem ext_map (h h' : IsAdjoinRoot S f) (eq : \u2200 x, h.map x = h'.map x) : h = h'", "start": [184, 1], "end": [188, 23], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.ext", "code": "@[ext]\ntheorem ext (h h' : IsAdjoinRoot S f) (eq : h.root = h'.root) : h = h'", "start": [191, 1], "end": [195, 64], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.eval\u2082_repr_eq_eval\u2082_of_map_eq", "code": "theorem eval\u2082_repr_eq_eval\u2082_of_map_eq (h : IsAdjoinRoot S f) (z : S) (w : R[X])\n    (hzw : h.map w = z) : (h.repr z).eval\u2082 i x = w.eval\u2082 i x", "start": [202, 1], "end": [207, 63], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift", "code": "def lift (h : IsAdjoinRoot S f) : S \u2192+* T where\n  toFun z := (h.repr z).eval\u2082 i x\n  map_zero' := by\n    dsimp only rw [h.eval\u2082_repr_eq_eval\u2082_of_map_eq hx _ _ (map_zero _), eval\u2082_zero]\n  map_add' z w := by\n    dsimp only rw [h.eval\u2082_repr_eq_eval\u2082_of_map_eq hx _ (h.repr z + h.repr w), eval\u2082_add]\n    \u00b7 rw [map_add, map_repr, map_repr]\n  map_one' := by\n    dsimp only rw [h.eval\u2082_repr_eq_eval\u2082_of_map_eq hx _ _ (map_one _), eval\u2082_one]\n  map_mul' z w := by\n    dsimp only rw [h.eval\u2082_repr_eq_eval\u2082_of_map_eq hx _ (h.repr z * h.repr w), eval\u2082_mul]\n    \u00b7 rw [map_mul, map_repr, map_repr]", "start": [213, 1], "end": [230, 39], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_map", "code": "@[simp]\ntheorem lift_map (h : IsAdjoinRoot S f) (z : R[X]) : h.lift i x hx (h.map z) = z.eval\u2082 i x", "start": [235, 1], "end": [239, 50], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_root", "code": "@[simp]\ntheorem lift_root (h : IsAdjoinRoot S f) : h.lift i x hx h.root = x", "start": [242, 1], "end": [244, 36], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_algebraMap", "code": "@[simp]\ntheorem lift_algebraMap (h : IsAdjoinRoot S f) (a : R) : h.lift i x hx (algebraMap R S a) = i a", "start": [247, 1], "end": [249, 48], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.apply_eq_lift", "code": "theorem apply_eq_lift (h : IsAdjoinRoot S f) (g : S \u2192+* T) (hmap : \u2200 a, g (algebraMap R S a) = i a)\n    (hroot : g h.root = x) (a : S) : g a = h.lift i x hx a", "start": [252, 1], "end": [257, 21], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.eq_lift", "code": "theorem eq_lift (h : IsAdjoinRoot S f) (g : S \u2192+* T) (hmap : \u2200 a, g (algebraMap R S a) = i a)\n    (hroot : g h.root = x) : g = h.lift i x hx", "start": [260, 1], "end": [263, 48], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.liftHom", "code": "def liftHom (h : IsAdjoinRoot S f) : S \u2192\u2090[R] T :=\n  { h.lift (algebraMap R T) x hx' with commutes' := fun a => h.lift_algebraMap hx' a }", "start": [271, 1], "end": [274, 87], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.coe_liftHom", "code": "@[simp]\ntheorem coe_liftHom (h : IsAdjoinRoot S f) :\n    (h.liftHom x hx' : S \u2192+* T) = h.lift (algebraMap R T) x hx'", "start": [279, 1], "end": [281, 71], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_algebraMap_apply", "code": "theorem lift_algebraMap_apply (h : IsAdjoinRoot S f) (z : S) :\n    h.lift (algebraMap R T) x hx' z = h.liftHom x hx' z", "start": [284, 1], "end": [285, 63], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.liftHom_map", "code": "@[simp]\ntheorem liftHom_map (h : IsAdjoinRoot S f) (z : R[X]) : h.liftHom x hx' (h.map z) = aeval x z", "start": [288, 1], "end": [290, 52], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.liftHom_root", "code": "@[simp]\ntheorem liftHom_root (h : IsAdjoinRoot S f) : h.liftHom x hx' h.root = x", "start": [293, 1], "end": [295, 42], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.eq_liftHom", "code": "theorem eq_liftHom (h : IsAdjoinRoot S f) (g : S \u2192\u2090[R] T) (hroot : g h.root = x) :\n    g = h.liftHom x hx'", "start": [298, 1], "end": [301, 54], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRoot", "code": "protected def isAdjoinRoot : IsAdjoinRoot (AdjoinRoot f) f where\n  map := AdjoinRoot.mk f\n  map_surjective := Ideal.Quotient.mk_surjective\n  ker_map := by\n    ext\n    rw [RingHom.mem_ker, \u2190 @AdjoinRoot.mk_self _ _ f, AdjoinRoot.mk_eq_mk, Ideal.mem_span_singleton,\n      \u2190 dvd_add_left (dvd_refl f), sub_add_cancel]\n  algebraMap_eq := AdjoinRoot.algebraMap_eq f", "start": [312, 1], "end": [320, 46], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRootMonic", "code": "protected def isAdjoinRootMonic (hf : Monic f) : IsAdjoinRootMonic (AdjoinRoot f) f :=\n  { AdjoinRoot.isAdjoinRoot f with Monic := hf }", "start": [323, 1], "end": [326, 49], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRoot_map_eq_mk", "code": "@[simp]\ntheorem isAdjoinRoot_map_eq_mk : (AdjoinRoot.isAdjoinRoot f).map = AdjoinRoot.mk f", "start": [329, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRootMonic_map_eq_mk", "code": "@[simp]\ntheorem isAdjoinRootMonic_map_eq_mk (hf : f.Monic) :\n    (AdjoinRoot.isAdjoinRootMonic f hf).map = AdjoinRoot.mk f", "start": [334, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRoot_root_eq_root", "code": "@[simp]\ntheorem isAdjoinRoot_root_eq_root : (AdjoinRoot.isAdjoinRoot f).root = AdjoinRoot.root f", "start": [340, 1], "end": [342, 84], "kind": "commanddeclaration"}, {"full_name": "AdjoinRoot.isAdjoinRootMonic_root_eq_root", "code": "@[simp]\ntheorem isAdjoinRootMonic_root_eq_root (hf : Monic f) :\n    (AdjoinRoot.isAdjoinRootMonic f hf).root = AdjoinRoot.root f", "start": [345, 1], "end": [348, 89], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.map_modByMonic", "code": "theorem map_modByMonic (h : IsAdjoinRootMonic S f) (g : R[X]) : h.map (g %\u2098 f) = h.map g", "start": [357, 1], "end": [360, 17], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.modByMonic_repr_map", "code": "theorem modByMonic_repr_map (h : IsAdjoinRootMonic S f) (g : R[X]) :\n    h.repr (h.map g) %\u2098 f = g %\u2098 f", "start": [363, 1], "end": [365, 97], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.modByMonicHom", "code": "def modByMonicHom (h : IsAdjoinRootMonic S f) : S \u2192\u2097[R] R[X] where\n  toFun x := h.repr x %\u2098 f\n  map_add' x y := by\n    conv_lhs =>\n      rw [\u2190 h.map_repr x, \u2190 h.map_repr y, \u2190 map_add]\n      dsimp only rw [h.modByMonic_repr_map, add_modByMonic]\n  map_smul' c x := by\n    rw [RingHom.id_apply, \u2190 h.map_repr x, Algebra.smul_def, h.algebraMap_apply, \u2190 map_mul]\n    dsimp only rw [h.modByMonic_repr_map, \u2190 smul_eq_C_mul, smul_modByMonic, h.map_repr]", "start": [368, 1], "end": [379, 77], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.modByMonicHom_map", "code": "@[simp]\ntheorem modByMonicHom_map (h : IsAdjoinRootMonic S f) (g : R[X]) :\n    h.modByMonicHom (h.map g) = g %\u2098 f", "start": [382, 1], "end": [384, 66], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.map_modByMonicHom", "code": "@[simp]\ntheorem map_modByMonicHom (h : IsAdjoinRootMonic S f) (x : S) : h.map (h.modByMonicHom x) = x", "start": [387, 1], "end": [391, 32], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.modByMonicHom_root_pow", "code": "@[simp]\ntheorem modByMonicHom_root_pow (h : IsAdjoinRootMonic S f) {n : \u2115} (hdeg : n < natDegree f) :\n    h.modByMonicHom (h.root ^ n) = X ^ n", "start": [394, 1], "end": [400, 48], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.modByMonicHom_root", "code": "@[simp]\ntheorem modByMonicHom_root (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.modByMonicHom h.root = X", "start": [403, 1], "end": [405, 79], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.basis", "code": "def basis (h : IsAdjoinRootMonic S f) : Basis (Fin (natDegree f)) R S :=\n  Basis.ofRepr\n    { toFun := fun x => (h.modByMonicHom x).toFinsupp.comapDomain _ (Fin.val_injective.injOn _)\n      invFun := fun g => h.map (ofFinsupp (g.mapDomain _))\n      left_inv := fun x => by\n        cases subsingleton_or_nontrivial R\n        \u00b7 haveI := h.subsingleton\n          exact Subsingleton.elim _ _\n        simp only\n        rw [Finsupp.mapDomain_comapDomain, Polynomial.eta, h.map_modByMonicHom x]\n        \u00b7 exact Fin.val_injective\n        intro i hi\n        refine Set.mem_range.mpr \u27e8\u27e8i, ?_\u27e9, rfl\u27e9\n        contrapose! hi\n        simp only [Polynomial.toFinsupp_apply, Classical.not_not, Finsupp.mem_support_iff, Ne.def,\n          modByMonicHom, LinearMap.coe_mk, Finset.mem_coe]\n        by_cases hx : h.toIsAdjoinRoot.repr x %\u2098 f = 0\n        \u00b7 simp [hx]\n        refine coeff_eq_zero_of_natDegree_lt (lt_of_lt_of_le ?_ hi)\n        dsimp rw [natDegree_lt_natDegree_iff hx]\n        \u00b7 exact degree_modByMonic_lt _ h.Monic\n      right_inv := fun g => by\n        nontriviality R\n        ext i\n        simp only [h.modByMonicHom_map, Finsupp.comapDomain_apply, Polynomial.toFinsupp_apply]\n        rw [(Polynomial.modByMonic_eq_self_iff h.Monic).mpr, Polynomial.coeff]\n        dsimp only rw [Finsupp.mapDomain_apply Fin.val_injective]\n        rw [degree_eq_natDegree h.Monic.ne_zero, degree_lt_iff_coeff_zero]\n        intro m hm\n        rw [Polynomial.coeff]\n        dsimp only rw [Finsupp.mapDomain_notin_range]\n        rw [Set.mem_range, not_exists]\n        rintro i rfl\n        exact i.prop.not_le hm\n      map_add' := fun x y => by\n        dsimp only rw [map_add, toFinsupp_add, Finsupp.comapDomain_add_of_injective Fin.val_injective]\n      map_smul' := fun c x => by\n        dsimp only rw [map_smul, toFinsupp_smul, Finsupp.comapDomain_smul_of_injective Fin.val_injective,\n          RingHom.id_apply] }", "start": [408, 1], "end": [457, 30], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.basis_apply", "code": "@[simp]\ntheorem basis_apply (h : IsAdjoinRootMonic S f) (i) : h.basis i = h.root ^ (i : \u2115)", "start": [464, 1], "end": [472, 22], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.deg_pos", "code": "theorem deg_pos [Nontrivial S] (h : IsAdjoinRootMonic S f) : 0 < natDegree f", "start": [475, 1], "end": [477, 36], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.deg_ne_zero", "code": "theorem deg_ne_zero [Nontrivial S] (h : IsAdjoinRootMonic S f) : natDegree f \u2260 0", "start": [480, 1], "end": [481, 16], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.powerBasis", "code": "@[simps! gen dim basis]\ndef powerBasis (h : IsAdjoinRootMonic S f) : PowerBasis R S where\n  gen := h.root\n  dim := natDegree f\n  basis := h.basis\n  basis_eq_pow := h.basis_apply", "start": [484, 1], "end": [490, 32], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.basis_repr", "code": "@[simp]\ntheorem basis_repr (h : IsAdjoinRootMonic S f) (x : S) (i : Fin (natDegree f)) :\n    h.basis.repr x i = (h.modByMonicHom x).coeff (i : \u2115)", "start": [493, 1], "end": [497, 61], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.basis_one", "code": "theorem basis_one (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.basis \u27e81, hdeg\u27e9 = h.root", "start": [500, 1], "end": [501, 77], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.liftPoly\u2097", "code": "@[simps!]\ndef liftPoly\u2097 {T : Type*} [AddCommGroup T] [Module R T] (h : IsAdjoinRootMonic S f)\n    (g : R[X] \u2192\u2097[R] T) : S \u2192\u2097[R] T :=\n  g.comp h.modByMonicHom", "start": [504, 1], "end": [508, 25], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff", "code": "def coeff (h : IsAdjoinRootMonic S f) : S \u2192\u2097[R] \u2115 \u2192 R :=\n  h.liftPoly\u2097\n    { toFun := Polynomial.coeff\n      map_add' := fun p q => funext (Polynomial.coeff_add p q)\n      map_smul' := fun c p => funext (Polynomial.coeff_smul c p) }", "start": [511, 1], "end": [517, 67], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_apply_lt", "code": "theorem coeff_apply_lt (h : IsAdjoinRootMonic S f) (z : S) (i : \u2115) (hi : i < natDegree f) :\n    h.coeff z i = h.basis.repr z \u27e8i, hi\u27e9", "start": [520, 1], "end": [524, 6], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_apply_coe", "code": "theorem coeff_apply_coe (h : IsAdjoinRootMonic S f) (z : S) (i : Fin (natDegree f)) :\n    h.coeff z i = h.basis.repr z i", "start": [527, 1], "end": [528, 66], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_apply_le", "code": "theorem coeff_apply_le (h : IsAdjoinRootMonic S f) (z : S) (i : \u2115) (hi : natDegree f \u2264 i) :\n    h.coeff z i = 0", "start": [531, 1], "end": [538, 92], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_apply", "code": "theorem coeff_apply (h : IsAdjoinRootMonic S f) (z : S) (i : \u2115) :\n    h.coeff z i = if hi : i < natDegree f then h.basis.repr z \u27e8i, hi\u27e9 else 0", "start": [541, 1], "end": [545, 49], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_root_pow", "code": "theorem coeff_root_pow (h : IsAdjoinRootMonic S f) {n} (hn : n < natDegree f) :\n    h.coeff (h.root ^ n) = Pi.single n 1", "start": [548, 1], "end": [563, 20], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_one", "code": "theorem coeff_one [Nontrivial S] (h : IsAdjoinRootMonic S f) : h.coeff 1 = Pi.single 0 1", "start": [566, 1], "end": [567, 46], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_root", "code": "theorem coeff_root (h : IsAdjoinRootMonic S f) (hdeg : 1 < natDegree f) :\n    h.coeff h.root = Pi.single 1 1", "start": [570, 1], "end": [571, 79], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_algebraMap", "code": "theorem coeff_algebraMap [Nontrivial S] (h : IsAdjoinRootMonic S f) (x : R) :\n    h.coeff (algebraMap R S x) = Pi.single 0 x", "start": [574, 1], "end": [580, 7], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.ext_elem", "code": "theorem ext_elem (h : IsAdjoinRootMonic S f) \u2983x y : S\u2984\n    (hxy : \u2200 i < natDegree f, h.coeff x i = h.coeff y i) : x = y", "start": [583, 1], "end": [588, 22], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.ext_elem_iff", "code": "theorem ext_elem_iff (h : IsAdjoinRootMonic S f) {x y : S} :\n    x = y \u2194 \u2200 i < natDegree f, h.coeff x i = h.coeff y i", "start": [591, 1], "end": [593, 55], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.coeff_injective", "code": "theorem coeff_injective (h : IsAdjoinRootMonic S f) : Function.Injective h.coeff", "start": [596, 1], "end": [597, 34], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.isIntegral_root", "code": "theorem isIntegral_root (h : IsAdjoinRootMonic S f) : IsIntegral R h.root", "start": [600, 1], "end": [601, 29], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_self_apply", "code": "@[simp]\ntheorem lift_self_apply (h : IsAdjoinRoot S f) (x : S) :\n    h.lift (algebraMap R S) h.root h.aeval_root x = x", "start": [616, 1], "end": [619, 57], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_self", "code": "theorem lift_self (h : IsAdjoinRoot S f) :\n    h.lift (algebraMap R S) h.root h.aeval_root = RingHom.id S", "start": [622, 1], "end": [624, 32], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv", "code": "def aequiv (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) : S \u2243\u2090[R] T :=\n  { h.liftHom h'.root h'.aeval_root with\n    toFun := h.liftHom h'.root h'.aeval_root\n    invFun := h'.liftHom h.root h.aeval_root\n    left_inv := fun x => by rw [\u2190 h.map_repr x, liftHom_map, aeval_eq, liftHom_map, aeval_eq]\n    right_inv := fun x => by rw [\u2190 h'.map_repr x, liftHom_map, aeval_eq, liftHom_map, aeval_eq] }", "start": [633, 1], "end": [643, 98], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_map", "code": "@[simp]\ntheorem aequiv_map (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) (z : R[X]) :\n    h.aequiv h' (h.map z) = h'.map z", "start": [646, 1], "end": [648, 95], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_root", "code": "@[simp]\ntheorem aequiv_root (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) : h.aequiv h' h.root = h'.root", "start": [651, 1], "end": [653, 48], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_self", "code": "@[simp]\ntheorem aequiv_self (h : IsAdjoinRoot S f) : h.aequiv h = AlgEquiv.refl", "start": [656, 1], "end": [658, 35], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_symm", "code": "@[simp]\ntheorem aequiv_symm (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f) :\n    (h.aequiv h').symm = h'.aequiv h", "start": [661, 1], "end": [663, 52], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.lift_aequiv", "code": "@[simp]\ntheorem lift_aequiv {U : Type*} [CommRing U] (h : IsAdjoinRoot S f) (h' : IsAdjoinRoot T f)\n    (i : R \u2192+* U) (x hx z) : h'.lift i x hx (h.aequiv h' z) = h.lift i x hx z", "start": [666, 1], "end": [669, 54], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.liftHom_aequiv", "code": "@[simp]\ntheorem liftHom_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (x : U) (hx z) : h'.liftHom x hx (h.aequiv h' z) = h.liftHom x hx z", "start": [672, 1], "end": [675, 28], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_aequiv", "code": "@[simp]\ntheorem aequiv_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (h'' : IsAdjoinRoot U f) (x) :\n    (h'.aequiv h'') (h.aequiv h' x) = h.aequiv h'' x", "start": [678, 1], "end": [682, 40], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_trans", "code": "@[simp]\ntheorem aequiv_trans {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (h'' : IsAdjoinRoot U f) :\n    (h.aequiv h').trans (h'.aequiv h'') = h.aequiv h''", "start": [685, 1], "end": [688, 99], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.ofEquiv", "code": "@[simps! map_apply]\ndef ofEquiv (h : IsAdjoinRoot S f) (e : S \u2243\u2090[R] T) : IsAdjoinRoot T f where\n  map := ((e : S \u2243+* T) : S \u2192+* T).comp h.map\n  map_surjective := e.surjective.comp h.map_surjective\n  ker_map := by\n    rw [\u2190 RingHom.comap_ker, RingHom.ker_coe_equiv, \u2190 RingHom.ker_eq_comap_bot, h.ker_map]\n  algebraMap_eq := by\n    ext\n    simp only [AlgEquiv.commutes, RingHom.comp_apply, AlgEquiv.coe_ringEquiv,\n      RingEquiv.coe_toRingHom, \u2190 h.algebraMap_apply]", "start": [691, 1], "end": [705, 53], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.ofEquiv_root", "code": "@[simp]\ntheorem ofEquiv_root (h : IsAdjoinRoot S f) (e : S \u2243\u2090[R] T) : (h.ofEquiv e).root = e h.root", "start": [708, 1], "end": [709, 99], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.aequiv_ofEquiv", "code": "@[simp]\ntheorem aequiv_ofEquiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot T f) (e : T \u2243\u2090[R] U) : h.aequiv (h'.ofEquiv e) = (h.aequiv h').trans e", "start": [712, 1], "end": [715, 94], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRoot.ofEquiv_aequiv", "code": "@[simp]\ntheorem ofEquiv_aequiv {U : Type*} [CommRing U] [Algebra R U] (h : IsAdjoinRoot S f)\n    (h' : IsAdjoinRoot U f) (e : S \u2243\u2090[R] T) :\n    (h.ofEquiv e).aequiv h' = e.symm.trans (h.aequiv h')", "start": [718, 1], "end": [724, 36], "kind": "commanddeclaration"}, {"full_name": "IsAdjoinRootMonic.minpoly_eq", "code": "theorem minpoly_eq [IsDomain R] [IsDomain S] [NoZeroSMulDivisors R S] [IsIntegrallyClosed R]\n    (h : IsAdjoinRootMonic S f) (hirr : Irreducible f) : minpoly R h.root = f", "start": [733, 1], "end": [742, 19], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin.powerBasis'_minpoly_gen", "code": "theorem Algebra.adjoin.powerBasis'_minpoly_gen [IsDomain R] [IsDomain S] [NoZeroSMulDivisors R S]\n    [IsIntegrallyClosed R] {x : S} (hx' : IsIntegral R x) :\n    minpoly R x = minpoly R (Algebra.adjoin.powerBasis' hx').gen", "start": [751, 1], "end": [760, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/AbsoluteValue.lean", "imports": ["Mathlib/Algebra/Order/AbsoluteValue.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AbsoluteValue.uniformSpace", "code": "def uniformSpace : UniformSpace R :=\n  .ofFun (fun x y => abv (y - x)) (by simp) (fun x y => abv.map_sub y x)\n    (fun x y z => (abv.sub_le _ _ _).trans_eq (add_comm _ _))\n    fun \u03b5 \u03b50 => \u27e8\u03b5 / 2, half_pos \u03b50, fun _ h\u2081 _ h\u2082 => (add_lt_add h\u2081 h\u2082).trans_eq (add_halves \u03b5)\u27e9", "start": [35, 1], "end": [39, 98], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.hasBasis_uniformity", "code": "theorem hasBasis_uniformity :\n    \ud835\udce4[abv.uniformSpace].HasBasis ((0 : \ud835\udd5c) < \u00b7) fun \u03b5 => { p : R \u00d7 R | abv (p.2 - p.1) < \u03b5 }", "start": [42, 1], "end": [44, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Analysis/Filter.lean", "imports": ["Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CFilter", "code": "structure CFilter (\u03b1 \u03c3 : Type*) [PartialOrder \u03b1] where\n  f : \u03c3 \u2192 \u03b1\n  pt : \u03c3\n  inf : \u03c3 \u2192 \u03c3 \u2192 \u03c3\n  inf_le_left : \u2200 a b : \u03c3, f (inf a b) \u2264 f a\n  inf_le_right : \u2200 a b : \u03c3, f (inf a b) \u2264 f b", "start": [26, 1], "end": [34, 46], "kind": "commanddeclaration"}, {"full_name": "CFilter.coe_mk", "code": "theorem coe_mk (f pt inf h\u2081 h\u2082 a) : (@CFilter.mk \u03b1 \u03c3 _ f pt inf h\u2081 h\u2082) a = f a", "start": [59, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "CFilter.ofEquiv", "code": "def ofEquiv (E : \u03c3 \u2243 \u03c4) : CFilter \u03b1 \u03c3 \u2192 CFilter \u03b1 \u03c4\n  | \u27e8f, p, g, h\u2081, h\u2082\u27e9 =>\n    { f := fun a \u21a6 f (E.symm a)\n      pt := E p\n      inf := fun a b \u21a6 E (g (E.symm a) (E.symm b))\n      inf_le_left := fun a b \u21a6 by simpa using h\u2081 (E.symm a) (E.symm b)\n      inf_le_right := fun a b \u21a6 by simpa using h\u2082 (E.symm a) (E.symm b) }", "start": [63, 1], "end": [70, 74], "kind": "commanddeclaration"}, {"full_name": "CFilter.ofEquiv_val", "code": "@[simp]\ntheorem ofEquiv_val (E : \u03c3 \u2243 \u03c4) (F : CFilter \u03b1 \u03c3) (a : \u03c4) : F.ofEquiv E a = F (E.symm a)", "start": [73, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "CFilter.toFilter", "code": "def toFilter (F : CFilter (Set \u03b1) \u03c3) : Filter \u03b1 where\n  sets := { a | \u2203 b, F b \u2286 a }\n  univ_sets := \u27e8F.pt, subset_univ _\u27e9\n  sets_of_superset := fun \u27e8b, h\u27e9 s \u21a6 \u27e8b, Subset.trans h s\u27e9\n  inter_sets := fun \u27e8a, h\u2081\u27e9 \u27e8b, h\u2082\u27e9 \u21a6 \u27e8F.inf a b,\n    subset_inter (Subset.trans (F.inf_le_left _ _) h\u2081) (Subset.trans (F.inf_le_right _ _) h\u2082)\u27e9", "start": [80, 1], "end": [87, 95], "kind": "commanddeclaration"}, {"full_name": "CFilter.mem_toFilter_sets", "code": "@[simp]\ntheorem mem_toFilter_sets (F : CFilter (Set \u03b1) \u03c3) {a : Set \u03b1} : a \u2208 F.toFilter \u2194 \u2203 b, F b \u2286 a", "start": [90, 1], "end": [92, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer", "code": "structure Filter.Realizer (f : Filter \u03b1) where\n  \u03c3 : Type*\n  F : CFilter (Set \u03b1) \u03c3\n  eq : F.toFilter = f", "start": [98, 1], "end": [102, 22], "kind": "commanddeclaration"}, {"full_name": "CFilter.toRealizer", "code": "protected def CFilter.toRealizer (F : CFilter (Set \u03b1) \u03c3) : F.toFilter.Realizer :=\n  \u27e8\u03c3, F, rfl\u27e9", "start": [105, 1], "end": [107, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.mem_sets", "code": "theorem mem_sets {f : Filter \u03b1} (F : f.Realizer) {a : Set \u03b1} : a \u2208 f \u2194 \u2203 b, F.F b \u2286 a", "start": [112, 1], "end": [113, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ofEq", "code": "def ofEq {f g : Filter \u03b1} (e : f = g) (F : f.Realizer) : g.Realizer :=\n  \u27e8F.\u03c3, F.F, F.eq.trans e\u27e9", "start": [116, 1], "end": [119, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ofFilter", "code": "def ofFilter (f : Filter \u03b1) : f.Realizer :=\n  \u27e8f.sets,\n    { f := Subtype.val\n      pt := \u27e8univ, univ_mem\u27e9\n      inf := fun \u27e8_, h\u2081\u27e9 \u27e8_, h\u2082\u27e9 \u21a6 \u27e8_, inter_mem h\u2081 h\u2082\u27e9\n      inf_le_left := fun \u27e8x, _\u27e9 \u27e8y, _\u27e9 \u21a6 inter_subset_left x y\n      inf_le_right := fun \u27e8x, _\u27e9 \u27e8y, _\u27e9 \u21a6 inter_subset_right x y },\n    filter_eq <| Set.ext fun _ \u21a6 by simp [exists_mem_subset_iff]\u27e9", "start": [122, 1], "end": [130, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ofEquiv", "code": "def ofEquiv {f : Filter \u03b1} (F : f.Realizer) (E : F.\u03c3 \u2243 \u03c4) : f.Realizer :=\n  \u27e8\u03c4, F.F.ofEquiv E, by\n    refine' Eq.trans _ F.eq\n    exact filter_eq (Set.ext fun _ \u21a6\n      \u27e8fun \u27e8s, h\u27e9 \u21a6 \u27e8E.symm s, by simpa using h\u27e9, fun \u27e8t, h\u27e9 \u21a6 \u27e8E t, by simp [h]\u27e9\u27e9)\u27e9", "start": [133, 1], "end": [138, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ofEquiv_\u03c3", "code": "@[simp]\ntheorem ofEquiv_\u03c3 {f : Filter \u03b1} (F : f.Realizer) (E : F.\u03c3 \u2243 \u03c4) : (F.ofEquiv E).\u03c3 = \u03c4", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ofEquiv_F", "code": "@[simp]\ntheorem ofEquiv_F {f : Filter \u03b1} (F : f.Realizer) (E : F.\u03c3 \u2243 \u03c4) (s : \u03c4) :\n    (F.ofEquiv E).F s = F.F (E.symm s)", "start": [146, 1], "end": [148, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.principal", "code": "protected def principal (s : Set \u03b1) : (principal s).Realizer :=\n  \u27e8Unit,\n    { f := fun _ \u21a6 s\n      pt := ()\n      inf := fun _ _ \u21a6 ()\n      inf_le_left := fun _ _ \u21a6 le_rfl\n      inf_le_right := fun _ _ \u21a6 le_rfl },\n    filter_eq <| Set.ext fun _ \u21a6 \u27e8fun \u27e8_, s\u27e9 \u21a6 s, fun h \u21a6 \u27e8(), h\u27e9\u27e9\u27e9", "start": [152, 1], "end": [160, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.principal_\u03c3", "code": "@[simp]\ntheorem principal_\u03c3 (s : Set \u03b1) : (Realizer.principal s).\u03c3 = Unit", "start": [163, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.principal_F", "code": "@[simp]\ntheorem principal_F (s : Set \u03b1) (u : Unit) : (Realizer.principal s).F u = s", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.top", "code": "protected def top : (\u22a4 : Filter \u03b1).Realizer :=\n  (Realizer.principal _).ofEq principal_univ", "start": [177, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.top_\u03c3", "code": "@[simp]\ntheorem top_\u03c3 : (@Realizer.top \u03b1).\u03c3 = Unit", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.top_F", "code": "@[simp]\ntheorem top_F (u : Unit) : (@Realizer.top \u03b1).F u = univ", "start": [187, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.bot", "code": "protected def bot : (\u22a5 : Filter \u03b1).Realizer :=\n  (Realizer.principal _).ofEq principal_empty", "start": [193, 1], "end": [195, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.bot_\u03c3", "code": "@[simp]\ntheorem bot_\u03c3 : (@Realizer.bot \u03b1).\u03c3 = Unit", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.bot_F", "code": "@[simp]\ntheorem bot_F (u : Unit) : (@Realizer.bot \u03b1).F u = \u2205", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.map", "code": "protected def map (m : \u03b1 \u2192 \u03b2) {f : Filter \u03b1} (F : f.Realizer) : (map m f).Realizer :=\n  \u27e8F.\u03c3,\n    { f := fun s \u21a6 image m (F.F s)\n      pt := F.F.pt\n      inf := F.F.inf\n      inf_le_left := fun _ _ \u21a6 image_subset _ (F.F.inf_le_left _ _)\n      inf_le_right := fun _ _ \u21a6 image_subset _ (F.F.inf_le_right _ _) },\n    filter_eq <| Set.ext fun _ \u21a6 by\n      simp only [CFilter.toFilter, image_subset_iff, mem_setOf_eq, Filter.mem_sets, mem_map]\n      rw [F.mem_sets]\u27e9", "start": [209, 1], "end": [219, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.map_\u03c3", "code": "@[simp]\ntheorem map_\u03c3 (m : \u03b1 \u2192 \u03b2) {f : Filter \u03b1} (F : f.Realizer) : (F.map m).\u03c3 = F.\u03c3", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.map_F", "code": "@[simp]\ntheorem map_F (m : \u03b1 \u2192 \u03b2) {f : Filter \u03b1} (F : f.Realizer) (s) : (F.map m).F s = image m (F.F s)", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.comap", "code": "protected def comap (m : \u03b1 \u2192 \u03b2) {f : Filter \u03b2} (F : f.Realizer) : (comap m f).Realizer :=\n  \u27e8F.\u03c3,\n    { f := fun s \u21a6 preimage m (F.F s)\n      pt := F.F.pt\n      inf := F.F.inf\n      inf_le_left := fun _ _ \u21a6 preimage_mono (F.F.inf_le_left _ _)\n      inf_le_right := fun _ _ \u21a6 preimage_mono (F.F.inf_le_right _ _) },\n    filter_eq <| Set.ext fun _ \u21a6 by\n      cases F; subst f\n      exact \u27e8fun \u27e8s, h\u27e9 \u21a6 \u27e8_, \u27e8s, Subset.refl _\u27e9, h\u27e9,\n        fun \u27e8_, \u27e8s, h\u27e9, h\u2082\u27e9 \u21a6 \u27e8s, Subset.trans (preimage_mono h) h\u2082\u27e9\u27e9\u27e9", "start": [233, 1], "end": [244, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.sup", "code": "protected def sup {f g : Filter \u03b1} (F : f.Realizer) (G : g.Realizer) : (f \u2294 g).Realizer :=\n  \u27e8F.\u03c3 \u00d7 G.\u03c3,\n    { f := fun \u27e8s, t\u27e9 \u21a6 F.F s \u222a G.F t\n      pt := (F.F.pt, G.F.pt)\n      inf := fun \u27e8a, a'\u27e9 \u27e8b, b'\u27e9 \u21a6 (F.F.inf a b, G.F.inf a' b')\n      inf_le_left := fun _ _ \u21a6 union_subset_union (F.F.inf_le_left _ _) (G.F.inf_le_left _ _)\n      inf_le_right := fun _ _ \u21a6 union_subset_union (F.F.inf_le_right _ _) (G.F.inf_le_right _ _) },\n    filter_eq <| Set.ext fun _ \u21a6 by cases F; cases G; substs f g; simp [CFilter.toFilter]\u27e9", "start": [247, 1], "end": [255, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.inf", "code": "protected def inf {f g : Filter \u03b1} (F : f.Realizer) (G : g.Realizer) : (f \u2293 g).Realizer :=\n  \u27e8F.\u03c3 \u00d7 G.\u03c3,\n    { f := fun \u27e8s, t\u27e9 \u21a6 F.F s \u2229 G.F t\n      pt := (F.F.pt, G.F.pt)\n      inf := fun \u27e8a, a'\u27e9 \u27e8b, b'\u27e9 \u21a6 (F.F.inf a b, G.F.inf a' b')\n      inf_le_left := fun _ _ \u21a6 inter_subset_inter (F.F.inf_le_left _ _) (G.F.inf_le_left _ _)\n      inf_le_right := fun _ _ \u21a6 inter_subset_inter (F.F.inf_le_right _ _) (G.F.inf_le_right _ _) },\n    by\n      cases F; cases G; substs f g; simp only [CFilter.toFilter, Prod.exists]; ext\n      constructor\n      \u00b7 rintro \u27e8s, t, h\u27e9\n        apply mem_inf_of_inter _ _ h\n        use s\n        use t\n      \u00b7 rintro \u27e8_, \u27e8a, ha\u27e9, _, \u27e8b, hb\u27e9, rfl\u27e9\n        exact \u27e8a, b, inter_subset_inter ha hb\u27e9\u27e9", "start": [258, 1], "end": [274, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.cofinite", "code": "protected def cofinite [DecidableEq \u03b1] : (@cofinite \u03b1).Realizer :=\n  \u27e8Finset \u03b1,\n    { f := fun s \u21a6 { a | a \u2209 s }\n      pt := \u2205\n      inf := (\u00b7 \u222a \u00b7)\n      inf_le_left := fun _ _ _ \u21a6 mt (Finset.mem_union_left _)\n      inf_le_right := fun _ _ _ \u21a6 mt (Finset.mem_union_right _) },\n    filter_eq <|\n      Set.ext fun _ \u21a6\n        \u27e8fun \u27e8s, h\u27e9 \u21a6 s.finite_toSet.subset (compl_subset_comm.1 h), fun h \u21a6\n          \u27e8h.toFinset, by simp [Subset.rfl]\u27e9\u27e9\u27e9", "start": [277, 1], "end": [288, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.bind", "code": "protected def bind {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} (F : f.Realizer) (G : \u2200 i, (m i).Realizer) :\n    (f.bind m).Realizer :=\n  \u27e8\u03a3s : F.\u03c3, \u2200 i \u2208 F.F s, (G i).\u03c3,\n    { f := fun \u27e8s, f\u27e9 \u21a6 \u22c3 i \u2208 F.F s, (G i).F (f i (by assumption))\n      pt := \u27e8F.F.pt, fun i _ \u21a6 (G i).F.pt\u27e9\n      inf := fun \u27e8a, f\u27e9 \u27e8b, f'\u27e9 \u21a6\n        \u27e8F.F.inf a b, fun i h \u21a6\n          (G i).F.inf (f i (F.F.inf_le_left _ _ h)) (f' i (F.F.inf_le_right _ _ h))\u27e9\n      inf_le_left := fun _ _ _ \u21a6 by\n        simp only [mem_iUnion, forall_exists_index]\n        exact fun i h\u2081 h\u2082 \u21a6 \u27e8i, F.F.inf_le_left _ _ h\u2081, (G i).F.inf_le_left _ _ h\u2082\u27e9\n      inf_le_right := fun _ _ _ \u21a6 by\n        simp only [mem_iUnion, forall_exists_index]\n        exact fun i h\u2081 h\u2082 \u21a6 \u27e8i, F.F.inf_le_right _ _ h\u2081, (G i).F.inf_le_right _ _ h\u2082\u27e9 },\n    filter_eq <| Set.ext fun _ \u21a6 by\n      cases' F with _ F _; subst f\n      simp only [CFilter.toFilter, iUnion_subset_iff, Sigma.exists, Filter.mem_sets, mem_bind]\n      exact\n        \u27e8fun \u27e8s, f, h\u27e9 \u21a6\n          \u27e8F s, \u27e8s, Subset.refl _\u27e9, fun i H \u21a6 (G i).mem_sets.2 \u27e8f i H, fun _ h' \u21a6 h i H h'\u27e9\u27e9,\n          fun \u27e8_, \u27e8s, h\u27e9, f\u27e9 \u21a6\n          let \u27e8f', h'\u27e9 := Classical.axiom_of_choice fun i : F s \u21a6 (G i).mem_sets.1 (f i (h i.2))\n          \u27e8s, fun i h \u21a6 f' \u27e8i, h\u27e9, fun _ H _ m \u21a6 h' \u27e8_, H\u27e9 m\u27e9\u27e9\u27e9", "start": [291, 1], "end": [314, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.iSup", "code": "protected def iSup {f : \u03b1 \u2192 Filter \u03b2} (F : \u2200 i, (f i).Realizer) : (\u2a06 i, f i).Realizer :=\n  let F' : (\u2a06 i, f i).Realizer :=\n    (Realizer.bind Realizer.top F).ofEq <|\n      filter_eq <| Set.ext <| by simp [Filter.bind, eq_univ_iff_forall, iSup_sets_eq]\n  F'.ofEquiv <|\n    show (\u03a3_ : Unit, \u2200 i : \u03b1, True \u2192 (F i).\u03c3) \u2243 \u2200 i, (F i).\u03c3 from\n      \u27e8fun \u27e8_, f\u27e9 i \u21a6 f i \u27e8\u27e9, fun f \u21a6 \u27e8(), fun i _ \u21a6 f i\u27e9, fun _ \u21a6 rfl, fun _ \u21a6 rfl\u27e9", "start": [318, 1], "end": [325, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.prod", "code": "protected def prod {f g : Filter \u03b1} (F : f.Realizer) (G : g.Realizer) : (f.prod g).Realizer :=\n  (F.comap _).inf (G.comap _)", "start": [328, 1], "end": [330, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.le_iff", "code": "theorem le_iff {f g : Filter \u03b1} (F : f.Realizer) (G : g.Realizer) :\n    f \u2264 g \u2194 \u2200 b : G.\u03c3, \u2203 a : F.\u03c3, F.F a \u2264 G.F b", "start": [333, 1], "end": [339, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.tendsto_iff", "code": "theorem tendsto_iff (f : \u03b1 \u2192 \u03b2) {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (L\u2081 : l\u2081.Realizer)\n    (L\u2082 : l\u2082.Realizer) : Tendsto f l\u2081 l\u2082 \u2194 \u2200 b, \u2203 a, \u2200 x \u2208 L\u2081.F a, f x \u2208 L\u2082.F b", "start": [342, 1], "end": [344, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.Realizer.ne_bot_iff", "code": "theorem ne_bot_iff {f : Filter \u03b1} (F : f.Realizer) : f \u2260 \u22a5 \u2194 \u2200 a : F.\u03c3, (F.F a).Nonempty", "start": [347, 1], "end": [352, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/ModelTheory/Satisfiability.lean", "imports": ["Mathlib/ModelTheory/Bundled.lean", "Mathlib/ModelTheory/Skolem.lean", "Mathlib/ModelTheory/Ultraproducts.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FirstOrder.Language.Theory.IsSatisfiable", "code": "def IsSatisfiable : Prop :=\n  Nonempty (ModelType.{u, v, max u v} T)", "start": [63, 1], "end": [65, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsFinitelySatisfiable", "code": "def IsFinitelySatisfiable : Prop :=\n  \u2200 T0 : Finset L.Sentence, (T0 : L.Theory) \u2286 T \u2192 IsSatisfiable (T0 : L.Theory)", "start": [68, 1], "end": [70, 80], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.Model.isSatisfiable", "code": "theorem Model.isSatisfiable (M : Type w) [Nonempty M] [L.Structure M] [M \u22a8 T] :\n    T.IsSatisfiable", "start": [75, 1], "end": [77, 87], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsSatisfiable.mono", "code": "theorem IsSatisfiable.mono (h : T'.IsSatisfiable) (hs : T \u2286 T') : T.IsSatisfiable", "start": [80, 1], "end": [81, 63], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_empty", "code": "theorem isSatisfiable_empty (L : Language.{u, v}) : IsSatisfiable (\u2205 : L.Theory)", "start": [84, 1], "end": [85, 12], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_of_isSatisfiable_onTheory", "code": "theorem isSatisfiable_of_isSatisfiable_onTheory {L' : Language.{w, w'}} (\u03c6 : L \u2192\u1d38 L')\n    (h : (\u03c6.onTheory T).IsSatisfiable) : T.IsSatisfiable", "start": [88, 1], "end": [90, 40], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_onTheory_iff", "code": "theorem isSatisfiable_onTheory_iff {L' : Language.{w, w'}} {\u03c6 : L \u2192\u1d38 L'} (h : \u03c6.Injective) :\n    (\u03c6.onTheory T).IsSatisfiable \u2194 T.IsSatisfiable", "start": [93, 1], "end": [98, 59], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsSatisfiable.isFinitelySatisfiable", "code": "theorem IsSatisfiable.isFinitelySatisfiable (h : T.IsSatisfiable) : T.IsFinitelySatisfiable", "start": [101, 1], "end": [102, 18], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_iff_isFinitelySatisfiable", "code": "theorem isSatisfiable_iff_isFinitelySatisfiable {T : L.Theory} :\n    T.IsSatisfiable \u2194 T.IsFinitelySatisfiable", "start": [105, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_directed_union_iff", "code": "theorem isSatisfiable_directed_union_iff {\u03b9 : Type*} [Nonempty \u03b9] {T : \u03b9 \u2192 L.Theory}\n    (h : Directed (\u00b7 \u2286 \u00b7) T) : Theory.IsSatisfiable (\u22c3 i, T i) \u2194 \u2200 i, (T i).IsSatisfiable", "start": [129, 1], "end": [135, 23], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_card_le", "code": "theorem isSatisfiable_union_distinctConstantsTheory_of_card_le (T : L.Theory) (s : Set \u03b1)\n    (M : Type w') [Nonempty M] [L.Structure M] [M \u22a8 T]\n    (h : Cardinal.lift.{w'} #s \u2264 Cardinal.lift.{w} #M) :\n    ((L.lhomWithConstants \u03b1).onTheory T \u222a L.distinctConstantsTheory s).IsSatisfiable", "start": [138, 1], "end": [154, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_union_distinctConstantsTheory_of_infinite", "code": "theorem isSatisfiable_union_distinctConstantsTheory_of_infinite (T : L.Theory) (s : Set \u03b1)\n    (M : Type w') [L.Structure M] [M \u22a8 T] [Infinite M] :\n    ((L.lhomWithConstants \u03b1).onTheory T \u222a L.distinctConstantsTheory s).IsSatisfiable", "start": [157, 1], "end": [170, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.exists_large_model_of_infinite_model", "code": "theorem exists_large_model_of_infinite_model (T : L.Theory) (\u03ba : Cardinal.{w}) (M : Type w')\n    [L.Structure M] [M \u22a8 T] [Infinite M] :\n    \u2203 N : ModelType.{_, _, max u v w} T, Cardinal.lift.{max u v w} \u03ba \u2264 #N", "start": [173, 1], "end": [186, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset", "code": "theorem isSatisfiable_iUnion_iff_isSatisfiable_iUnion_finset {\u03b9 : Type*} (T : \u03b9 \u2192 L.Theory) :\n    IsSatisfiable (\u22c3 i, T i) \u2194 \u2200 s : Finset \u03b9, IsSatisfiable (\u22c3 i \u2208 s, T i)", "start": [189, 1], "end": [201, 24], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_le", "code": "theorem exists_elementaryEmbedding_card_eq_of_le (M : Type w') [L.Structure M] [Nonempty M]\n    (\u03ba : Cardinal.{w}) (h1 : \u2135\u2080 \u2264 \u03ba) (h2 : lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba)\n    (h3 : lift.{w'} \u03ba \u2264 Cardinal.lift.{w} #M) :\n    \u2203 N : Bundled L.Structure, Nonempty (N \u21aa\u2091[L] M) \u2227 #N = \u03ba", "start": [208, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_elementaryEmbedding_card_eq_of_ge", "code": "theorem exists_elementaryEmbedding_card_eq_of_ge (M : Type w') [L.Structure M] [iM : Infinite M]\n    (\u03ba : Cardinal.{w}) (h1 : Cardinal.lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba)\n    (h2 : Cardinal.lift.{w} #M \u2264 Cardinal.lift.{w'} \u03ba) :\n    \u2203 N : Bundled L.Structure, Nonempty (M \u21aa\u2091[L] N) \u2227 #N = \u03ba", "start": [231, 1], "end": [252, 62], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_elementaryEmbedding_card_eq", "code": "theorem exists_elementaryEmbedding_card_eq (M : Type w') [L.Structure M] [iM : Infinite M]\n    (\u03ba : Cardinal.{w}) (h1 : \u2135\u2080 \u2264 \u03ba) (h2 : lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba) :\n    \u2203 N : Bundled L.Structure, (Nonempty (N \u21aa\u2091[L] M) \u2228 Nonempty (M \u21aa\u2091[L] N)) \u2227 #N = \u03ba", "start": [257, 1], "end": [269, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.exists_elementarilyEquivalent_card_eq", "code": "theorem exists_elementarilyEquivalent_card_eq (M : Type w') [L.Structure M] [Infinite M]\n    (\u03ba : Cardinal.{w}) (h1 : \u2135\u2080 \u2264 \u03ba) (h2 : lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba) :\n    \u2203 N : CategoryTheory.Bundled L.Structure, (M \u2245[L] N) \u2227 #N = \u03ba", "start": [272, 1], "end": [280, 51], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.exists_model_card_eq", "code": "theorem exists_model_card_eq (h : \u2203 M : ModelType.{u, v, max u v} T, Infinite M) (\u03ba : Cardinal.{w})\n    (h1 : \u2135\u2080 \u2264 \u03ba) (h2 : Cardinal.lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba) :\n    \u2203 N : ModelType.{u, v, w} T, #N = \u03ba", "start": [287, 1], "end": [295, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelsBoundedFormula", "code": "def ModelsBoundedFormula (\u03c6 : L.BoundedFormula \u03b1 n) : Prop :=\n  \u2200 (M : ModelType.{u, v, max u v} T) (v : \u03b1 \u2192 M) (xs : Fin n \u2192 M), \u03c6.Realize v xs", "start": [300, 1], "end": [303, 83], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_formula_iff", "code": "theorem models_formula_iff {\u03c6 : L.Formula \u03b1} :\n    T \u22a8\u1d47 \u03c6 \u2194 \u2200 (M : ModelType.{u, v, max u v} T) (v : \u03b1 \u2192 M), \u03c6.Realize v", "start": [313, 1], "end": [315, 66], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_sentence_iff", "code": "theorem models_sentence_iff {\u03c6 : L.Sentence} : T \u22a8\u1d47 \u03c6 \u2194 \u2200 M : ModelType.{u, v, max u v} T, M \u22a8 \u03c6", "start": [318, 1], "end": [319, 70], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_sentence_of_mem", "code": "theorem models_sentence_of_mem {\u03c6 : L.Sentence} (h : \u03c6 \u2208 T) : T \u22a8\u1d47 \u03c6", "start": [322, 1], "end": [323, 61], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_iff_not_satisfiable", "code": "theorem models_iff_not_satisfiable (\u03c6 : L.Sentence) : T \u22a8\u1d47 \u03c6 \u2194 \u00acIsSatisfiable (T \u222a {\u03c6.not})", "start": [326, 1], "end": [341, 10], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.ModelsBoundedFormula.realize_sentence", "code": "theorem ModelsBoundedFormula.realize_sentence {\u03c6 : L.Sentence} (h : T \u22a8\u1d47 \u03c6) (M : Type*)\n    [L.Structure M] [M \u22a8 T] [Nonempty M] : M \u22a8 \u03c6", "start": [344, 1], "end": [353, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_of_models_theory", "code": "theorem models_of_models_theory {T' : L.Theory}\n    (h : \u2200 \u03c6 : L.Sentence, \u03c6 \u2208 T' \u2192 T \u22a8\u1d47 \u03c6)\n    {\u03c6 : L.Formula \u03b1} (h\u03c6 : T' \u22a8\u1d47 \u03c6) : T \u22a8\u1d47 \u03c6", "start": [356, 1], "end": [363, 14], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.models_iff_finset_models", "code": "theorem models_iff_finset_models {\u03c6 : L.Sentence} :\n    T \u22a8\u1d47 \u03c6 \u2194 \u2203 T0 : Finset L.Sentence, (T0 : L.Theory) \u2286 T \u2227 (T0 : L.Theory) \u22a8\u1d47 \u03c6", "start": [365, 1], "end": [381, 38], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsComplete", "code": "def IsComplete (T : L.Theory) : Prop :=\n  T.IsSatisfiable \u2227 \u2200 \u03c6 : L.Sentence, T \u22a8\u1d47 \u03c6 \u2228 T \u22a8\u1d47 \u03c6.not", "start": [383, 1], "end": [385, 58], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsComplete.models_not_iff", "code": "theorem models_not_iff (h : T.IsComplete) (\u03c6 : L.Sentence) : T \u22a8\u1d47 \u03c6.not \u2194 \u00acT \u22a8\u1d47 \u03c6", "start": [390, 1], "end": [400, 30], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsComplete.realize_sentence_iff", "code": "theorem realize_sentence_iff (h : T.IsComplete) (\u03c6 : L.Sentence) (M : Type*) [L.Structure M]\n    [M \u22a8 T] [Nonempty M] : M \u22a8 \u03c6 \u2194 T \u22a8\u1d47 \u03c6", "start": [403, 1], "end": [409, 37], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsMaximal", "code": "def IsMaximal (T : L.Theory) : Prop :=\n  T.IsSatisfiable \u2227 \u2200 \u03c6 : L.Sentence, \u03c6 \u2208 T \u2228 \u03c6.not \u2208 T", "start": [414, 1], "end": [417, 56], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsMaximal.isComplete", "code": "theorem IsMaximal.isComplete (h : T.IsMaximal) : T.IsComplete", "start": [420, 1], "end": [421, 89], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsMaximal.mem_or_not_mem", "code": "theorem IsMaximal.mem_or_not_mem (h : T.IsMaximal) (\u03c6 : L.Sentence) : \u03c6 \u2208 T \u2228 \u03c6.not \u2208 T", "start": [424, 1], "end": [425, 8], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsMaximal.mem_of_models", "code": "theorem IsMaximal.mem_of_models (h : T.IsMaximal) {\u03c6 : L.Sentence} (h\u03c6 : T \u22a8\u1d47 \u03c6) : \u03c6 \u2208 T", "start": [428, 1], "end": [431, 15], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.IsMaximal.mem_iff_models", "code": "theorem IsMaximal.mem_iff_models (h : T.IsMaximal) (\u03c6 : L.Sentence) : \u03c6 \u2208 T \u2194 T \u22a8\u1d47 \u03c6", "start": [434, 1], "end": [435, 44], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent", "code": "def SemanticallyEquivalent (T : L.Theory) (\u03c6 \u03c8 : L.BoundedFormula \u03b1 n) : Prop :=\n  T \u22a8\u1d47 \u03c6.iff \u03c8", "start": [438, 1], "end": [442, 15], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.refl", "code": "@[refl]\ntheorem SemanticallyEquivalent.refl (\u03c6 : L.BoundedFormula \u03b1 n) : T.SemanticallyEquivalent \u03c6 \u03c6", "start": [445, 1], "end": [447, 51], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.symm", "code": "@[symm]\ntheorem SemanticallyEquivalent.symm {\u03c6 \u03c8 : L.BoundedFormula \u03b1 n}\n    (h : T.SemanticallyEquivalent \u03c6 \u03c8) : T.SemanticallyEquivalent \u03c8 \u03c6", "start": [453, 1], "end": [457, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.trans", "code": "@[trans]\ntheorem SemanticallyEquivalent.trans {\u03c6 \u03c8 \u03b8 : L.BoundedFormula \u03b1 n}\n    (h1 : T.SemanticallyEquivalent \u03c6 \u03c8) (h2 : T.SemanticallyEquivalent \u03c8 \u03b8) :\n    T.SemanticallyEquivalent \u03c6 \u03b8", "start": [460, 1], "end": [467, 39], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.realize_bd_iff", "code": "theorem SemanticallyEquivalent.realize_bd_iff {\u03c6 \u03c8 : L.BoundedFormula \u03b1 n} {M : Type max u v}\n    [Nonempty M] [L.Structure M] [T.Model M] (h : T.SemanticallyEquivalent \u03c6 \u03c8)\n    {v : \u03b1 \u2192 M} {xs : Fin n \u2192 M} : \u03c6.Realize v xs \u2194 \u03c8.Realize v xs", "start": [470, 1], "end": [473, 59], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.realize_iff", "code": "theorem SemanticallyEquivalent.realize_iff {\u03c6 \u03c8 : L.Formula \u03b1} {M : Type max u v} [Nonempty M]\n    [L.Structure M] (_hM : T.Model M) (h : T.SemanticallyEquivalent \u03c6 \u03c8) {v : \u03b1 \u2192 M} :\n    \u03c6.Realize v \u2194 \u03c8.Realize v", "start": [476, 1], "end": [479, 19], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.semanticallyEquivalentSetoid", "code": "def semanticallyEquivalentSetoid (T : L.Theory) : Setoid (L.BoundedFormula \u03b1 n) where\n  r := SemanticallyEquivalent T\n  iseqv := \u27e8fun _ => refl _, fun {_ _} h => h.symm, fun {_ _ _} h1 h2 => h1.trans h2\u27e9", "start": [482, 1], "end": [485, 86], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.all", "code": "protected theorem SemanticallyEquivalent.all {\u03c6 \u03c8 : L.BoundedFormula \u03b1 (n + 1)}\n    (h : T.SemanticallyEquivalent \u03c6 \u03c8) : T.SemanticallyEquivalent \u03c6.all \u03c8.all", "start": [488, 1], "end": [492, 62], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.ex", "code": "protected theorem SemanticallyEquivalent.ex {\u03c6 \u03c8 : L.BoundedFormula \u03b1 (n + 1)}\n    (h : T.SemanticallyEquivalent \u03c6 \u03c8) : T.SemanticallyEquivalent \u03c6.ex \u03c8.ex", "start": [495, 1], "end": [499, 61], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.not", "code": "protected theorem SemanticallyEquivalent.not {\u03c6 \u03c8 : L.BoundedFormula \u03b1 n}\n    (h : T.SemanticallyEquivalent \u03c6 \u03c8) : T.SemanticallyEquivalent \u03c6.not \u03c8.not", "start": [502, 1], "end": [506, 49], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Theory.SemanticallyEquivalent.imp", "code": "protected theorem SemanticallyEquivalent.imp {\u03c6 \u03c8 \u03c6' \u03c8' : L.BoundedFormula \u03b1 n}\n    (h : T.SemanticallyEquivalent \u03c6 \u03c8) (h' : T.SemanticallyEquivalent \u03c6' \u03c8') :\n    T.SemanticallyEquivalent (\u03c6.imp \u03c6') (\u03c8.imp \u03c8')", "start": [509, 1], "end": [514, 67], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.completeTheory.isSatisfiable", "code": "theorem isSatisfiable [Nonempty M] : (L.completeTheory M).IsSatisfiable", "start": [524, 1], "end": [525, 31], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.completeTheory.mem_or_not_mem", "code": "theorem mem_or_not_mem (\u03c6 : L.Sentence) : \u03c6 \u2208 L.completeTheory M \u2228 \u03c6.not \u2208 L.completeTheory M", "start": [528, 1], "end": [529, 92], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.completeTheory.isMaximal", "code": "theorem isMaximal [Nonempty M] : (L.completeTheory M).IsMaximal", "start": [532, 1], "end": [533, 42], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.completeTheory.isComplete", "code": "theorem isComplete [Nonempty M] : (L.completeTheory M).IsComplete", "start": [536, 1], "end": [537, 44], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.semanticallyEquivalent_not_not", "code": "theorem semanticallyEquivalent_not_not : T.SemanticallyEquivalent \u03c6 \u03c6.not.not", "start": [546, 1], "end": [547, 7], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.imp_semanticallyEquivalent_not_sup", "code": "theorem imp_semanticallyEquivalent_not_sup : T.SemanticallyEquivalent (\u03c6.imp \u03c8) (\u03c6.not \u2294 \u03c8)", "start": [550, 1], "end": [551, 41], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.sup_semanticallyEquivalent_not_inf_not", "code": "theorem sup_semanticallyEquivalent_not_inf_not :\n    T.SemanticallyEquivalent (\u03c6 \u2294 \u03c8) (\u03c6.not \u2293 \u03c8.not).not", "start": [554, 1], "end": [555, 99], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.inf_semanticallyEquivalent_not_sup_not", "code": "theorem inf_semanticallyEquivalent_not_sup_not :\n    T.SemanticallyEquivalent (\u03c6 \u2293 \u03c8) (\u03c6.not \u2294 \u03c8.not).not", "start": [558, 1], "end": [560, 28], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.all_semanticallyEquivalent_not_ex_not", "code": "theorem all_semanticallyEquivalent_not_ex_not (\u03c6 : L.BoundedFormula \u03b1 (n + 1)) :\n    T.SemanticallyEquivalent \u03c6.all \u03c6.not.ex.not", "start": [563, 1], "end": [564, 73], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.ex_semanticallyEquivalent_not_all_not", "code": "theorem ex_semanticallyEquivalent_not_all_not (\u03c6 : L.BoundedFormula \u03b1 (n + 1)) :\n    T.SemanticallyEquivalent \u03c6.ex \u03c6.not.all.not", "start": [567, 1], "end": [568, 73], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.semanticallyEquivalent_all_liftAt", "code": "theorem semanticallyEquivalent_all_liftAt : T.SemanticallyEquivalent \u03c6 (\u03c6.liftAt 1 n).all", "start": [571, 1], "end": [574, 48], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Formula.semanticallyEquivalent_not_not", "code": "theorem semanticallyEquivalent_not_not : T.SemanticallyEquivalent \u03c6 \u03c6.not.not", "start": [583, 1], "end": [584, 50], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Formula.imp_semanticallyEquivalent_not_sup", "code": "theorem imp_semanticallyEquivalent_not_sup : T.SemanticallyEquivalent (\u03c6.imp \u03c8) (\u03c6.not \u2294 \u03c8)", "start": [587, 1], "end": [588, 56], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Formula.sup_semanticallyEquivalent_not_inf_not", "code": "theorem sup_semanticallyEquivalent_not_inf_not :\n    T.SemanticallyEquivalent (\u03c6 \u2294 \u03c8) (\u03c6.not \u2293 \u03c8.not).not", "start": [591, 1], "end": [593, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.Formula.inf_semanticallyEquivalent_not_sup_not", "code": "theorem inf_semanticallyEquivalent_not_sup_not :\n    T.SemanticallyEquivalent (\u03c6 \u2293 \u03c8) (\u03c6.not \u2294 \u03c8.not).not", "start": [596, 1], "end": [598, 60], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not", "code": "theorem IsQF.induction_on_sup_not {P : L.BoundedFormula \u03b1 n \u2192 Prop} {\u03c6 : L.BoundedFormula \u03b1 n}\n    (h : IsQF \u03c6) (hf : P (\u22a5 : L.BoundedFormula \u03b1 n))\n    (ha : \u2200 \u03c8 : L.BoundedFormula \u03b1 n, IsAtomic \u03c8 \u2192 P \u03c8)\n    (hsup : \u2200 {\u03c6\u2081 \u03c6\u2082}, P \u03c6\u2081 \u2192 P \u03c6\u2082 \u2192 P (\u03c6\u2081 \u2294 \u03c6\u2082)) (hnot : \u2200 {\u03c6}, P \u03c6 \u2192 P \u03c6.not)\n    (hse :\n      \u2200 {\u03c6\u2081 \u03c6\u2082 : L.BoundedFormula \u03b1 n}, Theory.SemanticallyEquivalent \u2205 \u03c6\u2081 \u03c6\u2082 \u2192 (P \u03c6\u2081 \u2194 P \u03c6\u2082)) :\n    P \u03c6", "start": [605, 1], "end": [613, 75], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not", "code": "theorem IsQF.induction_on_inf_not {P : L.BoundedFormula \u03b1 n \u2192 Prop} {\u03c6 : L.BoundedFormula \u03b1 n}\n    (h : IsQF \u03c6) (hf : P (\u22a5 : L.BoundedFormula \u03b1 n))\n    (ha : \u2200 \u03c8 : L.BoundedFormula \u03b1 n, IsAtomic \u03c8 \u2192 P \u03c8)\n    (hinf : \u2200 {\u03c6\u2081 \u03c6\u2082}, P \u03c6\u2081 \u2192 P \u03c6\u2082 \u2192 P (\u03c6\u2081 \u2293 \u03c6\u2082)) (hnot : \u2200 {\u03c6}, P \u03c6 \u2192 P \u03c6.not)\n    (hse :\n      \u2200 {\u03c6\u2081 \u03c6\u2082 : L.BoundedFormula \u03b1 n}, Theory.SemanticallyEquivalent \u2205 \u03c6\u2081 \u03c6\u2082 \u2192 (P \u03c6\u2081 \u2194 P \u03c6\u2082)) :\n    P \u03c6", "start": [616, 1], "end": [626, 39], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.semanticallyEquivalent_toPrenex", "code": "theorem semanticallyEquivalent_toPrenex (\u03c6 : L.BoundedFormula \u03b1 n) :\n    (\u2205 : L.Theory).SemanticallyEquivalent \u03c6 \u03c6.toPrenex", "start": [629, 1], "end": [631, 37], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.induction_on_all_ex", "code": "theorem induction_on_all_ex {P : \u2200 {m}, L.BoundedFormula \u03b1 m \u2192 Prop} (\u03c6 : L.BoundedFormula \u03b1 n)\n    (hqf : \u2200 {m} {\u03c8 : L.BoundedFormula \u03b1 m}, IsQF \u03c8 \u2192 P \u03c8)\n    (hall : \u2200 {m} {\u03c8 : L.BoundedFormula \u03b1 (m + 1)}, P \u03c8 \u2192 P \u03c8.all)\n    (hex : \u2200 {m} {\u03c6 : L.BoundedFormula \u03b1 (m + 1)}, P \u03c6 \u2192 P \u03c6.ex)\n    (hse : \u2200 {m} {\u03c6\u2081 \u03c6\u2082 : L.BoundedFormula \u03b1 m},\n      Theory.SemanticallyEquivalent \u2205 \u03c6\u2081 \u03c6\u2082 \u2192 (P \u03c6\u2081 \u2194 P \u03c6\u2082)) :\n    P \u03c6", "start": [634, 1], "end": [647, 17], "kind": "commanddeclaration"}, {"full_name": "FirstOrder.Language.BoundedFormula.induction_on_exists_not", "code": "theorem induction_on_exists_not {P : \u2200 {m}, L.BoundedFormula \u03b1 m \u2192 Prop} (\u03c6 : L.BoundedFormula \u03b1 n)\n    (hqf : \u2200 {m} {\u03c8 : L.BoundedFormula \u03b1 m}, IsQF \u03c8 \u2192 P \u03c8)\n    (hnot : \u2200 {m} {\u03c6 : L.BoundedFormula \u03b1 m}, P \u03c6 \u2192 P \u03c6.not)\n    (hex : \u2200 {m} {\u03c6 : L.BoundedFormula \u03b1 (m + 1)}, P \u03c6 \u2192 P \u03c6.ex)\n    (hse : \u2200 {m} {\u03c6\u2081 \u03c6\u2082 : L.BoundedFormula \u03b1 m},\n      Theory.SemanticallyEquivalent \u2205 \u03c6\u2081 \u03c6\u2082 \u2192 (P \u03c6\u2081 \u2194 P \u03c6\u2082)) :\n    P \u03c6", "start": [650, 1], "end": [659, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.Categorical", "code": "def Categorical : Prop :=\n  \u2200 M N : T.ModelType, #M = \u03ba \u2192 #N = \u03ba \u2192 Nonempty (M \u2243[L] N)", "start": [674, 1], "end": [676, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.Categorical.isComplete", "code": "theorem Categorical.isComplete (h : \u03ba.Categorical T) (h1 : \u2135\u2080 \u2264 \u03ba)\n    (h2 : Cardinal.lift.{w} L.card \u2264 Cardinal.lift.{max u v} \u03ba) (hS : T.IsSatisfiable)\n    (hT : \u2200 M : Theory.ModelType.{u, v, max u v} T, Infinite M) : T.IsComplete", "start": [679, 1], "end": [698, 78], "kind": "commanddeclaration"}, {"full_name": "Cardinal.empty_theory_categorical", "code": "theorem empty_theory_categorical (T : Language.empty.Theory) : \u03ba.Categorical T", "start": [701, 1], "end": [702, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.empty_infinite_Theory_isComplete", "code": "theorem empty_infinite_Theory_isComplete : Language.empty.infiniteTheory.IsComplete", "start": [705, 1], "end": [709, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Probability/ProbabilityMassFunction/Constructions.lean", "imports": ["Mathlib/Probability/ProbabilityMassFunction/Monad.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PMF.map", "code": "def map (f : \u03b1 \u2192 \u03b2) (p : PMF \u03b1) : PMF \u03b2 :=\n  bind p (pure \u2218 f)", "start": [40, 1], "end": [42, 20], "kind": "commanddeclaration"}, {"full_name": "PMF.monad_map_eq_map", "code": "theorem monad_map_eq_map {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (p : PMF \u03b1) : f <$> p = p.map f", "start": [47, 1], "end": [47, 91], "kind": "commanddeclaration"}, {"full_name": "PMF.map_apply", "code": "@[simp]\ntheorem map_apply : (map f p) b = \u2211' a, if b = f a then p a else 0", "start": [50, 1], "end": [51, 84], "kind": "commanddeclaration"}, {"full_name": "PMF.support_map", "code": "@[simp]\ntheorem support_map : (map f p).support = f '' p.support", "start": [54, 1], "end": [56, 47], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_map_iff", "code": "theorem mem_support_map_iff : b \u2208 (map f p).support \u2194 \u2203 a \u2208 p.support, f a = b", "start": [59, 1], "end": [59, 90], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_pure_comp", "code": "theorem bind_pure_comp : bind p (pure \u2218 f) = map f p", "start": [62, 1], "end": [62, 60], "kind": "commanddeclaration"}, {"full_name": "PMF.map_id", "code": "theorem map_id : map id p = p", "start": [65, 1], "end": [66, 14], "kind": "commanddeclaration"}, {"full_name": "PMF.map_comp", "code": "theorem map_comp (g : \u03b2 \u2192 \u03b3) : (p.map f).map g = p.map (g \u2218 f)", "start": [69, 1], "end": [69, 95], "kind": "commanddeclaration"}, {"full_name": "PMF.pure_map", "code": "theorem pure_map (a : \u03b1) : (pure a).map f = pure (f a)", "start": [72, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "PMF.map_bind", "code": "theorem map_bind (q : \u03b1 \u2192 PMF \u03b2) (f : \u03b2 \u2192 \u03b3) : (p.bind q).map f = p.bind fun a => (q a).map f", "start": [76, 1], "end": [77, 18], "kind": "commanddeclaration"}, {"full_name": "PMF.bind_map", "code": "@[simp]\ntheorem bind_map (p : PMF \u03b1) (f : \u03b1 \u2192 \u03b2) (q : \u03b2 \u2192 PMF \u03b3) : (p.map f).bind q = p.bind (q \u2218 f)", "start": [80, 1], "end": [82, 72], "kind": "commanddeclaration"}, {"full_name": "PMF.map_const", "code": "@[simp]\ntheorem map_const : p.map (Function.const \u03b1 b) = pure b", "start": [85, 1], "end": [87, 61], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_map_apply", "code": "@[simp]\ntheorem toOuterMeasure_map_apply : (p.map f).toOuterMeasure s = p.toOuterMeasure (f \u207b\u00b9' s)", "start": [94, 1], "end": [96, 62], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_map_apply", "code": "@[simp]\ntheorem toMeasure_map_apply [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] (hf : Measurable f)\n    (hs : MeasurableSet s) : (p.map f).toMeasure s = p.toMeasure (f \u207b\u00b9' s)", "start": [99, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "PMF.seq", "code": "def seq (q : PMF (\u03b1 \u2192 \u03b2)) (p : PMF \u03b1) : PMF \u03b2 :=\n  q.bind fun m => p.bind fun a => pure (m a)", "start": [113, 1], "end": [115, 45], "kind": "commanddeclaration"}, {"full_name": "PMF.monad_seq_eq_seq", "code": "theorem monad_seq_eq_seq {\u03b1 \u03b2 : Type u} (q : PMF (\u03b1 \u2192 \u03b2)) (p : PMF \u03b1) : q <*> p = q.seq p", "start": [120, 1], "end": [120, 97], "kind": "commanddeclaration"}, {"full_name": "PMF.seq_apply", "code": "@[simp]\ntheorem seq_apply : (seq q p) b = \u2211' (f : \u03b1 \u2192 \u03b2) (a : \u03b1), if b = f a then q f * p a else 0", "start": [123, 1], "end": [127, 62], "kind": "commanddeclaration"}, {"full_name": "PMF.support_seq", "code": "@[simp]\ntheorem support_seq : (seq q p).support = \u22c3 f \u2208 q.support, f '' p.support", "start": [130, 1], "end": [132, 65], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_seq_iff", "code": "theorem mem_support_seq_iff : b \u2208 (seq q p).support \u2194 \u2203 f \u2208 q.support, b \u2208 f '' p.support", "start": [135, 1], "end": [135, 101], "kind": "commanddeclaration"}, {"full_name": "PMF.ofFinset", "code": "def ofFinset (f : \u03b1 \u2192 \u211d\u22650\u221e) (s : Finset \u03b1) (h : \u2211 a in s, f a = 1)\n    (h' : \u2200 (a) (_ : a \u2209 s), f a = 0) : PMF \u03b1 :=\n  \u27e8f, h \u25b8 hasSum_sum_of_ne_finset_zero h'\u27e9", "start": [153, 1], "end": [157, 43], "kind": "commanddeclaration"}, {"full_name": "PMF.ofFinset_apply", "code": "@[simp]\ntheorem ofFinset_apply (a : \u03b1) : ofFinset f s h h' a = f a", "start": [162, 1], "end": [163, 66], "kind": "commanddeclaration"}, {"full_name": "PMF.support_ofFinset", "code": "@[simp]\ntheorem support_ofFinset : (ofFinset f s h h').support = \u2191s \u2229 Function.support f", "start": [166, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_ofFinset_iff", "code": "theorem mem_support_ofFinset_iff (a : \u03b1) : a \u2208 (ofFinset f s h h').support \u2194 a \u2208 s \u2227 f a \u2260 0", "start": [171, 1], "end": [172, 7], "kind": "commanddeclaration"}, {"full_name": "PMF.ofFinset_apply_of_not_mem", "code": "theorem ofFinset_apply_of_not_mem {a : \u03b1} (ha : a \u2209 s) : ofFinset f s h h' a = 0", "start": [175, 1], "end": [176, 10], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_ofFinset_apply", "code": "@[simp]\ntheorem toOuterMeasure_ofFinset_apply :\n    (ofFinset f s h h').toOuterMeasure t = \u2211' x, t.indicator f x", "start": [183, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_ofFinset_apply", "code": "@[simp]\ntheorem toMeasure_ofFinset_apply [MeasurableSpace \u03b1] (ht : MeasurableSet t) :\n    (ofFinset f s h h').toMeasure t = \u2211' x, t.indicator f x", "start": [189, 1], "end": [192, 96], "kind": "commanddeclaration"}, {"full_name": "PMF.ofFintype", "code": "def ofFintype [Fintype \u03b1] (f : \u03b1 \u2192 \u211d\u22650\u221e) (h : \u2211 a, f a = 1) : PMF \u03b1 :=\n  ofFinset f Finset.univ h fun a ha => absurd (Finset.mem_univ a) ha", "start": [201, 1], "end": [203, 69], "kind": "commanddeclaration"}, {"full_name": "PMF.ofFintype_apply", "code": "@[simp]\ntheorem ofFintype_apply (a : \u03b1) : ofFintype f h a = f a", "start": [208, 1], "end": [209, 63], "kind": "commanddeclaration"}, {"full_name": "PMF.support_ofFintype", "code": "@[simp]\ntheorem support_ofFintype : (ofFintype f h).support = Function.support f", "start": [212, 1], "end": [213, 80], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_ofFintype_iff", "code": "theorem mem_support_ofFintype_iff (a : \u03b1) : a \u2208 (ofFintype f h).support \u2194 f a \u2260 0", "start": [216, 1], "end": [216, 93], "kind": "commanddeclaration"}, {"full_name": "PMF.toOuterMeasure_ofFintype_apply", "code": "@[simp high]\ntheorem toOuterMeasure_ofFintype_apply : (ofFintype f h).toOuterMeasure s = \u2211' x, s.indicator f x", "start": [223, 1], "end": [225, 41], "kind": "commanddeclaration"}, {"full_name": "PMF.toMeasure_ofFintype_apply", "code": "@[simp]\ntheorem toMeasure_ofFintype_apply [MeasurableSpace \u03b1] (hs : MeasurableSet s) :\n    (ofFintype f h).toMeasure s = \u2211' x, s.indicator f x", "start": [228, 1], "end": [231, 94], "kind": "commanddeclaration"}, {"full_name": "PMF.normalize", "code": "def normalize (f : \u03b1 \u2192 \u211d\u22650\u221e) (hf0 : tsum f \u2260 0) (hf : tsum f \u2260 \u221e) : PMF \u03b1 :=\n  \u27e8fun a => f a * (\u2211' x, f x)\u207b\u00b9,\n    ENNReal.summable.hasSum_iff.2 (ENNReal.tsum_mul_right.trans (ENNReal.mul_inv_cancel hf0 hf))\u27e9", "start": [240, 1], "end": [244, 98], "kind": "commanddeclaration"}, {"full_name": "PMF.normalize_apply", "code": "@[simp]\ntheorem normalize_apply (a : \u03b1) : (normalize f hf0 hf) a = f a * (\u2211' x, f x)\u207b\u00b9", "start": [249, 1], "end": [250, 86], "kind": "commanddeclaration"}, {"full_name": "PMF.support_normalize", "code": "@[simp]\ntheorem support_normalize : (normalize f hf0 hf).support = Function.support f", "start": [253, 1], "end": [255, 49], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_normalize_iff", "code": "theorem mem_support_normalize_iff (a : \u03b1) : a \u2208 (normalize f hf0 hf).support \u2194 f a \u2260 0", "start": [258, 1], "end": [258, 98], "kind": "commanddeclaration"}, {"full_name": "PMF.filter", "code": "def filter (p : PMF \u03b1) (s : Set \u03b1) (h : \u2203 a \u2208 s, a \u2208 p.support) : PMF \u03b1 :=\n  PMF.normalize (s.indicator p) (by simpa using h) (p.tsum_coe_indicator_ne_top s)", "start": [265, 1], "end": [267, 83], "kind": "commanddeclaration"}, {"full_name": "PMF.filter_apply", "code": "@[simp]\ntheorem filter_apply (a : \u03b1) :\n    (p.filter s h) a = s.indicator p a * (\u2211' a', (s.indicator p) a')\u207b\u00b9", "start": [272, 1], "end": [275, 31], "kind": "commanddeclaration"}, {"full_name": "PMF.filter_apply_eq_zero_of_not_mem", "code": "theorem filter_apply_eq_zero_of_not_mem {a : \u03b1} (ha : a \u2209 s) : (p.filter s h) a = 0", "start": [278, 1], "end": [279, 88], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_filter_iff", "code": "theorem mem_support_filter_iff {a : \u03b1} : a \u2208 (p.filter s h).support \u2194 a \u2208 s \u2227 a \u2208 p.support", "start": [282, 1], "end": [283, 70], "kind": "commanddeclaration"}, {"full_name": "PMF.support_filter", "code": "@[simp]\ntheorem support_filter : (p.filter s h).support = s \u2229 p.support", "start": [286, 1], "end": [288, 44], "kind": "commanddeclaration"}, {"full_name": "PMF.filter_apply_eq_zero_iff", "code": "theorem filter_apply_eq_zero_iff (a : \u03b1) : (p.filter s h) a = 0 \u2194 a \u2209 s \u2228 a \u2209 p.support", "start": [291, 1], "end": [292, 73], "kind": "commanddeclaration"}, {"full_name": "PMF.filter_apply_ne_zero_iff", "code": "theorem filter_apply_ne_zero_iff (a : \u03b1) : (p.filter s h) a \u2260 0 \u2194 a \u2208 s \u2227 a \u2208 p.support", "start": [295, 1], "end": [296, 86], "kind": "commanddeclaration"}, {"full_name": "PMF.bernoulli", "code": "def bernoulli (p : \u211d\u22650\u221e) (h : p \u2264 1) : PMF Bool :=\n  ofFintype (fun b => cond b p (1 - p)) (by simp [h])", "start": [303, 1], "end": [305, 54], "kind": "commanddeclaration"}, {"full_name": "PMF.bernoulli_apply", "code": "@[simp]\ntheorem bernoulli_apply : bernoulli p h b = cond b p (1 - p)", "start": [310, 1], "end": [311, 68], "kind": "commanddeclaration"}, {"full_name": "PMF.support_bernoulli", "code": "@[simp]\ntheorem support_bernoulli : (bernoulli p h).support = { b | cond b (p \u2260 0) (p \u2260 1) }", "start": [314, 1], "end": [320, 83], "kind": "commanddeclaration"}, {"full_name": "PMF.mem_support_bernoulli_iff", "code": "theorem mem_support_bernoulli_iff : b \u2208 (bernoulli p h).support \u2194 cond b (p \u2260 0) (p \u2260 1)", "start": [323, 1], "end": [323, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Stonean/EffectiveEpi.lean", "imports": ["Mathlib/Topology/Category/CompHaus/EffectiveEpi.lean", "Mathlib/Topology/Category/Stonean/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Stonean.EffectiveEpiFamily.F", "code": "abbrev F := Stonean.toCompHaus", "start": [45, 1], "end": [46, 31], "kind": "commanddeclaration"}, {"full_name": "Stonean.EffectiveEpiFamily.lift_desc_condition", "code": "lemma lift_desc_condition {W : Stonean} {e : (a : \u03b1) \u2192 X a \u27f6 W}\n    (h : \u2200 {Z : Stonean} (a\u2081 a\u2082 : \u03b1) (g\u2081 : Z \u27f6 X a\u2081) (g\u2082 : Z \u27f6 X a\u2082),\n      g\u2081 \u226b \u03c0 a\u2081 = g\u2082 \u226b \u03c0 a\u2082 \u2192 g\u2081 \u226b e a\u2081 = g\u2082 \u226b e a\u2082) :\n    \u2200 {Z : CompHaus} (a\u2081 a\u2082 : \u03b1) (g\u2081 : Z \u27f6 F.obj (X a\u2081)) (g\u2082 : Z \u27f6 F.obj (X a\u2082)),\n        g\u2081 \u226b (\u03c0 a\u2081) = g\u2082 \u226b (\u03c0 a\u2082) \u2192 g\u2081 \u226b e a\u2081 = g\u2082 \u226b e a\u2082 := by\n  intro Z a\u2081 a\u2082 g\u2081 g\u2082 hg\n  let \u03b2Z := Z.presentation\n  let g\u2081' := F.preimage (presentation.\u03c0 Z \u226b g\u2081 : F.obj \u03b2Z \u27f6 F.obj (X a\u2081))\n  let g\u2082' := F.preimage (presentation.\u03c0 Z \u226b g\u2082 : F.obj \u03b2Z \u27f6 F.obj (X a\u2082))\n  apply Epi.left_cancellation (f := presentation.\u03c0 Z)\n  change g\u2081' \u226b e a\u2081 = g\u2082' \u226b e a\u2082\n  apply h\n  change presentation.\u03c0 Z \u226b g\u2081 \u226b \u03c0 a\u2081 = presentation.\u03c0 Z \u226b g\u2082 \u226b \u03c0 a\u2082\n  simp [hg]", "start": [49, 1], "end": [83, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Stonean.EffectiveEpiFamily.struct", "code": "noncomputable\ndef struct : EffectiveEpiFamilyStruct X \u03c0 where\n  desc := fun {W} e h => Stonean.toCompHaus.preimage <|\n    (CompHaus.effectiveEpiFamily_of_jointly_surjective (F.obj <| X \u00b7) \u03c0 surj).desc\n    (fun (a : \u03b1) => F.map (e a)) (lift_desc_condition \u03c0 h)\n  fac := by\n    let fam : EffectiveEpiFamily (F.obj <| X \u00b7) \u03c0 :=\n      CompHaus.effectiveEpiFamily_of_jointly_surjective (F.obj <| X \u00b7) \u03c0 surj\n    intro W e he a\n    have fac\u2081 :  F.map (\u03c0 a \u226b _) = F.map (e a) :=\n      EffectiveEpiFamily.fac (F.obj <| X \u00b7) \u03c0 e (lift_desc_condition \u03c0 he) a\n    exact Faithful.map_injective fac\u2081\n  uniq := by\n    let fam : EffectiveEpiFamily (F.obj <| X \u00b7) \u03c0 :=\n      CompHaus.effectiveEpiFamily_of_jointly_surjective (F.obj <| X \u00b7) \u03c0 surj\n    intro W e he m hm\n    have Fhm : \u2200 (a : \u03b1), \u03c0 a \u226b F.map m = e a\n    \u00b7 intro a\n      simp_all only [toCompHaus_map]\n    have uniq\u2081 : F.map m = F.map _ :=\n      EffectiveEpiFamily.uniq (F.obj <| X \u00b7) \u03c0 e (lift_desc_condition \u03c0 he) (F.map m) Fhm\n    exact Faithful.map_injective uniq\u2081", "start": [85, 1], "end": [111, 39], "kind": "commanddeclaration"}, {"full_name": "Stonean.effectiveEpiFamily_of_jointly_surjective", "code": "theorem effectiveEpiFamily_of_jointly_surjective\n    {\u03b1 : Type} [Fintype \u03b1] {B : Stonean}\n    (X : \u03b1 \u2192 Stonean) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B))\n    (surj : \u2200 b : B, \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b) :\n    EffectiveEpiFamily X \u03c0", "start": [117, 1], "end": [123, 47], "kind": "commanddeclaration"}, {"full_name": "Stonean.effectiveEpiFamily_tfae", "code": "theorem effectiveEpiFamily_tfae {\u03b1 : Type} [Fintype \u03b1] {B : Stonean}\n    (X : \u03b1 \u2192 Stonean) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    TFAE [\n      EffectiveEpiFamily X \u03c0,\n      Epi (Limits.Sigma.desc \u03c0),\n      \u2200 (b : B), \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b ]", "start": [126, 1], "end": [166, 14], "kind": "commanddeclaration"}, {"full_name": "Stonean.effectiveEpi_iff_surjective", "code": "lemma effectiveEpi_iff_surjective {X Y : Stonean} (f : X \u27f6 Y) :\n    EffectiveEpi f \u2194 Function.Surjective f := by\n  rw [\u2190 epi_iff_surjective]\n  exact effectiveEpi_iff_epi (fun _ _ \u21a6 (effectiveEpiFamily_tfae _ _).out 0 1) f", "start": [168, 1], "end": [171, 81], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.EffectiveEpiFamily.toCompHaus", "code": "theorem _root_.CategoryTheory.EffectiveEpiFamily.toCompHaus\n    {\u03b1 : Type} [Fintype \u03b1] {B : Stonean.{u}}\n    {X : \u03b1 \u2192 Stonean.{u}} {\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)} (H : EffectiveEpiFamily X \u03c0) :\n    EffectiveEpiFamily (toCompHaus.obj <| X \u00b7) (toCompHaus.map <| \u03c0 \u00b7)", "start": [179, 1], "end": [184, 70], "kind": "commanddeclaration"}, {"full_name": "Stonean.instPrecoherent", "code": "instance instPrecoherent : Precoherent Stonean.{u} := by\n  constructor\n  intro B\u2081 B\u2082 f \u03b1 _ X\u2081 \u03c0\u2081 h\u2081\n  refine \u27e8\u03b1, inferInstance, fun a => (CompHaus.pullback f (\u03c0\u2081 a)).presentation, fun a =>\n    toCompHaus.preimage (presentation.\u03c0 _ \u226b (CompHaus.pullback.fst _ _)), ?_, id, fun a =>\n    toCompHaus.preimage (presentation.\u03c0 _ \u226b (CompHaus.pullback.snd _ _ )), fun a => ?_\u27e9\n  \u00b7 refine ((effectiveEpiFamily_tfae _ _).out 0 2).2 (fun b => ?_)\n    have h\u2081' := ((CompHaus.effectiveEpiFamily_tfae _ _).out 0 2).1 h\u2081.toCompHaus\n    obtain \u27e8a, x, h\u27e9 := h\u2081' (f b)\n    obtain \u27e8c, hc\u27e9 := (CompHaus.epi_iff_surjective _).1\n      (presentation.epi_\u03c0 (CompHaus.pullback f (\u03c0\u2081 a))) \u27e8\u27e8b, x\u27e9, h.symm\u27e9\n    refine \u27e8a, c, ?_\u27e9\n    change toCompHaus.map (toCompHaus.preimage _) _ = _\n    simp only [image_preimage, toCompHaus_obj, comp_apply, hc]\n    rfl\n  \u00b7 apply map_injective toCompHaus\n    simp only [map_comp, image_preimage, Category.assoc]\n    congr 1\n    ext \u27e8\u27e8_, _\u27e9, h\u27e9\n    exact h.symm", "start": [186, 1], "end": [205, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/InducedTopology.lean", "imports": ["Mathlib/CategoryTheory/Sites/DenseSubsite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.LocallyCoverDense", "code": "def LocallyCoverDense (K : GrothendieckTopology D) (G : C \u2964 D) : Prop :=\n  \u2200 \u2983X\u2984 (T : K (G.obj X)), (T.val.functorPullback G).functorPushforward G \u2208 K (G.obj X)", "start": [50, 1], "end": [54, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocallyCoverDense.pushforward_cover_iff_cover_pullback", "code": "theorem pushforward_cover_iff_cover_pullback {X : C} (S : Sieve X) :\n    K _ (S.functorPushforward G) \u2194 \u2203 T : K (G.obj X), T.val.functorPullback G = S", "start": [61, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocallyCoverDense.inducedTopology", "code": "@[simps]\ndef inducedTopology : GrothendieckTopology C where\n  sieves X S := K _ (S.functorPushforward G)\n  top_mem' X := by\n    change K _ _\n    rw [Sieve.functorPushforward_top]\n    exact K.top_mem _\n  pullback_stable' X Y S f hS := by\n    have : S.pullback f = ((S.functorPushforward G).pullback (G.map f)).functorPullback G := by\n      conv_lhs => rw [\u2190 (Sieve.fullyFaithfulFunctorGaloisCoinsertion G X).u_l_eq S]\n      ext\n      change (S.functorPushforward G) _ \u2194 (S.functorPushforward G) _\n      rw [G.map_comp]\n    rw [this]\n    change K _ _\n    apply Hld \u27e8_, K.pullback_stable (G.map f) hS\u27e9\n  transitive' X S hS S' H' := by\n    apply K.transitive hS\n    rintro Y _ \u27e8Z, g, i, hg, rfl\u27e9\n    rw [Sieve.pullback_comp]\n    apply K.pullback_stable i\n    refine' K.superset_covering _ (H' hg)\n    rintro W _ \u27e8Z', g', i', hg, rfl\u27e9\n    refine' \u27e8Z', g' \u226b g , i', hg, _\u27e9\n    simp", "start": [70, 1], "end": [97, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocallyCoverDense.inducedTopology_coverLifting", "code": "theorem inducedTopology_coverLifting : CoverLifting Hld.inducedTopology K G", "start": [100, 1], "end": [102, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LocallyCoverDense.inducedTopology_coverPreserving", "code": "theorem inducedTopology_coverPreserving : CoverPreserving Hld.inducedTopology K G", "start": [105, 1], "end": [107, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CoverDense.locallyCoverDense", "code": "theorem CoverDense.locallyCoverDense [Full G] (H : CoverDense K G) : LocallyCoverDense K G", "start": [112, 1], "end": [119, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CoverDense.inducedTopology", "code": "abbrev CoverDense.inducedTopology [Full G] [Faithful G] (H : CoverDense K G) :\n    GrothendieckTopology C :=\n  H.locallyCoverDense.inducedTopology", "start": [122, 1], "end": [126, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.over_forget_locallyCoverDense", "code": "theorem over_forget_locallyCoverDense (X : C) : LocallyCoverDense J (Over.forget X)", "start": [131, 1], "end": [139, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CoverDense.sheafEquiv", "code": "noncomputable def CoverDense.sheafEquiv [Full G] [Faithful G] (H : CoverDense K G) [HasLimits A] :\n    Sheaf H.inducedTopology A \u224c Sheaf K A :=\n  H.sheafEquivOfCoverPreservingCoverLifting H.locallyCoverDense.inducedTopology_coverPreserving\n    H.locallyCoverDense.inducedTopology_coverLifting", "start": [152, 1], "end": [160, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Category/Profinite/EffectiveEpi.lean", "imports": ["Mathlib/CategoryTheory/Sites/Coherent.lean", "Mathlib/Topology/Category/Profinite/Limits.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Profinite.EffectiveEpiFamily.relation", "code": "def relation : Setoid (finiteCoproduct X) where\n  r a b := \u2203 (Z : Profinite) (z : Z) (fst : Z \u27f6 X a.fst) (snd : Z \u27f6 X b.fst),\n    fst \u226b \u03c0 _ = snd \u226b \u03c0 _ \u2227 fst z = a.snd \u2227 snd z = b.snd\n  iseqv := by\n    constructor\n    \u00b7 rintro \u27e8a, x\u27e9\n      exact \u27e8X a, x, \ud835\udfd9 _, \ud835\udfd9 _, by simp, rfl, rfl\u27e9\n    \u00b7 rintro \u27e8a, x\u27e9 \u27e8b, y\u27e9 \u27e8Z, z, fst, snd, w, h1, h2\u27e9\n      exact \u27e8Z, z, snd, fst, w.symm, h2, h1\u27e9\n    \u00b7 rintro \u27e8a, x\u27e9 \u27e8b, y\u27e9 \u27e8z, c\u27e9 \u27e8Z, z, fstZ, sndZ, hZ, hZ1, hZ2\u27e9\n      rintro \u27e8W, w, fstW, sndW, hW, hW1, hW2\u27e9\n      refine \u27e8pullback sndZ fstW, \u27e8\u27e8z, w\u27e9, by dsimp; rw [hZ2, hW1]\u27e9,\n        pullback.fst _ _ \u226b fstZ, pullback.snd _ _ \u226b sndW, ?_, hZ1, hW2\u27e9\n      dsimp only at *\n      simp only [Category.assoc, hZ, \u2190 hW]\n      apply ContinuousMap.ext\n      rintro \u27e8\u27e8u, v\u27e9, h\u27e9\n      change \u03c0 b (sndZ u) = \u03c0 b (fstW v)\n      rw [h]", "start": [48, 1], "end": [70, 13], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Fun", "code": "def \u03b9Fun : Quotient (relation \u03c0) \u2192 B :=\n  Quotient.lift (fun \u27e8a, x\u27e9 => \u03c0 a x) <| by\n    rintro \u27e8a, x\u27e9 \u27e8b, y\u27e9 \u27e8Z, z, fst, snd, h, hx, hy\u27e9\n    dsimp only at *\n    rw [\u2190 hx, \u2190 hy]\n    apply_fun (\u00b7 z) at h\n    exact h", "start": [72, 1], "end": [82, 12], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Fun_continuous", "code": "lemma \u03b9Fun_continuous : Continuous (\u03b9Fun \u03c0) := by\n  apply Continuous.quotient_lift\n  apply continuous_sigma\n  intro a\n  exact (\u03c0 a).continuous", "start": [84, 1], "end": [89, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Fun_injective", "code": "lemma \u03b9Fun_injective : (\u03b9Fun \u03c0).Injective := by\n  rintro \u27e8\u27e8a, x\u27e9\u27e9 \u27e8\u27e8b, y\u27e9\u27e9 (h : \u03c0 _ _ = \u03c0 _ _)\n  apply Quotient.sound'\n  refine \u27e8pullback (\u03c0 a) (\u03c0 b), \u27e8\u27e8x, y\u27e9, h\u27e9, pullback.fst _ _, pullback.snd _ _, ?_, rfl, rfl\u27e9\n  ext \u27e8_, h\u27e9\n  exact h", "start": [91, 1], "end": [97, 10], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.EffectiveEpiFamily.QB'", "code": "def QB' : CompHaus :=\n  haveI : T2Space (Quotient <| relation \u03c0) :=\n    \u27e8fun _ _ h => separated_by_continuous (\u03b9Fun_continuous \u03c0) <| (\u03b9Fun_injective \u03c0).ne h \u27e9\n  CompHaus.of (Quotient <| relation \u03c0)", "start": [99, 1], "end": [103, 39], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Hom'", "code": "def \u03b9Hom' : (QB' \u03c0) \u27f6 B.toCompHaus := \u27e8\u03b9Fun \u03c0, \u03b9Fun_continuous \u03c0\u27e9", "start": [105, 1], "end": [106, 66], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Iso'", "code": "noncomputable\ndef \u03b9Iso' : (QB' \u03c0) \u2245 B.toCompHaus :=\n  have : IsIso (\u03b9Hom' \u03c0) := by\n    apply CompHaus.isIso_of_bijective\n    refine \u27e8\u03b9Fun_injective _, ?_\u27e9\n    intro b\n    obtain \u27e8a, x, h\u27e9 := surj b\n    exact \u27e8Quotient.mk _ \u27e8a, x\u27e9, h\u27e9\n  asIso (\u03b9Hom' \u03c0)", "start": [108, 1], "end": [117, 18], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.QB", "code": "def QB : Profinite where\n  toCompHaus := QB' \u03c0\n  IsTotallyDisconnected := \u27e8(CompHaus.homeoOfIso (\u03b9Iso' \u03c0 surj)).embedding.isTotallyDisconnected\n    (isTotallyDisconnected_of_totallyDisconnectedSpace _)\u27e9", "start": [119, 1], "end": [123, 59], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Hom", "code": "def \u03b9Hom : (QB \u03c0 surj) \u27f6 B := \u27e8\u03b9Fun \u03c0, \u03b9Fun_continuous \u03c0\u27e9", "start": [125, 1], "end": [126, 58], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03b9Iso", "code": "noncomputable\ndef \u03b9Iso : (QB \u03c0 surj) \u2245 B :=\n  have : IsIso (\u03b9Hom \u03c0 surj) := by\n    apply Profinite.isIso_of_bijective\n    refine \u27e8\u03b9Fun_injective _, ?_\u27e9\n    intro b\n    obtain \u27e8a, x, h\u27e9 := surj b\n    exact \u27e8Quotient.mk _ \u27e8a, x\u27e9, h\u27e9\n  asIso (\u03b9Hom \u03c0 surj)", "start": [128, 1], "end": [137, 22], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03c0'", "code": "def \u03c0' : (a : \u03b1) \u2192 (X a \u27f6 QB \u03c0 surj) := fun a =>\n  { toFun := fun x => Quotient.mk _ \u27e8a, x\u27e9\n    continuous_toFun := by\n      apply Continuous.comp\n      apply continuous_quot_mk\n      apply continuous_sigmaMk (\u03c3 := (X \u00b7)) }", "start": [139, 1], "end": [145, 46], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.structAux", "code": "def structAux : EffectiveEpiFamilyStruct X (\u03c0' \u03c0 surj) where\n  desc := fun e h => {\n    toFun := Quotient.lift (fun \u27e8a, x\u27e9 => e a x) <| by\n      rintro \u27e8a, x\u27e9 \u27e8b, y\u27e9 \u27e8Z, z, fst, snd, hh, hx, hy\u27e9\n      dsimp at *\n      rw [\u2190 hx, \u2190 hy]\n      specialize h _ _ fst snd ?_\n      \u00b7 ext z\n        apply \u03b9Fun_injective\n        apply_fun (\u00b7 z) at hh\n        exact hh\n      apply_fun (\u00b7 z) at h\n      exact h\n    continuous_toFun := by\n      apply Continuous.quotient_lift\n      apply continuous_sigma\n      intro a\n      exact (e a).continuous }\n  fac := by\n    intro Z e h a\n    ext\n    rfl\n  uniq := by\n    intro Z e h m hm\n    ext \u27e8\u27e8a, x\u27e9\u27e9\n    specialize hm a\n    apply_fun (\u00b7 x) at hm\n    exact hm", "start": [147, 1], "end": [175, 13], "kind": "commanddeclaration"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03c0'_comp_\u03b9_hom", "code": "@[reassoc]\nlemma \u03c0'_comp_\u03b9_hom (a : \u03b1) : \u03c0' \u03c0 surj a \u226b (\u03b9Iso \u03c0 surj).hom = \u03c0 a := by\n  ext\n  rfl", "start": [177, 1], "end": [181, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.EffectiveEpiFamily.\u03c0_comp_\u03b9_inv", "code": "@[reassoc]\nlemma \u03c0_comp_\u03b9_inv (a : \u03b1) : \u03c0 a \u226b (\u03b9Iso \u03c0 surj).inv = \u03c0' \u03c0 surj a := by\n  rw [Iso.comp_inv_eq]\n  exact \u03c0'_comp_\u03b9_hom _ surj _", "start": [183, 1], "end": [187, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.EffectiveEpiFamily.struct", "code": "noncomputable\ndef struct : EffectiveEpiFamilyStruct X \u03c0 where\n  desc := fun e h => (\u03b9Iso \u03c0 surj).inv \u226b (structAux \u03c0 surj).desc e (fun a\u2081 a\u2082 g\u2081 g\u2082 hh => by\n    apply h\n    rw [\u2190 cancel_mono (\u03b9Iso _ surj).inv]\n    simpa only [Category.assoc, \u03c0_comp_\u03b9_inv])\n  fac := by\n    intro W e h a\n    simp only [Eq.ndrec, id_eq, eq_mpr_eq_cast, \u03c0_comp_\u03b9_inv_assoc, (structAux \u03c0 surj).fac]\n  uniq := by\n    intro W e h m hm\n    dsimp\n    rw [Iso.eq_inv_comp]\n    apply (structAux \u03c0 surj).uniq\n    intro a\n    simpa using hm a", "start": [189, 1], "end": [208, 21], "kind": "commanddeclaration"}, {"full_name": "Profinite.effectiveEpiFamily_of_jointly_surjective", "code": "theorem effectiveEpiFamily_of_jointly_surjective\n    {\u03b1 : Type} [Fintype \u03b1] {B : Profinite}\n    (X : \u03b1 \u2192 Profinite) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B))\n    (surj : \u2200 b : B, \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b) :\n    EffectiveEpiFamily X \u03c0", "start": [214, 1], "end": [220, 49], "kind": "commanddeclaration"}, {"full_name": "Profinite.effectiveEpiFamily_tfae", "code": "theorem effectiveEpiFamily_tfae {\u03b1 : Type} [Fintype \u03b1] {B : Profinite}\n    (X : \u03b1 \u2192 Profinite) (\u03c0 : (a : \u03b1) \u2192 (X a \u27f6 B)) :\n    TFAE [\n      EffectiveEpiFamily X \u03c0,\n      Epi (Limits.Sigma.desc \u03c0),\n      \u2200 (b : B), \u2203 (a : \u03b1) (x : X a), \u03c0 a x = b ]", "start": [223, 1], "end": [265, 14], "kind": "commanddeclaration"}, {"full_name": "Profinite.effectiveEpi_iff_surjective", "code": "lemma effectiveEpi_iff_surjective {X Y : Profinite} (f : X \u27f6 Y) :\n    EffectiveEpi f \u2194 Function.Surjective f := by\n  rw [\u2190 epi_iff_surjective]\n  exact effectiveEpi_iff_epi (fun _ _ \u21a6 (effectiveEpiFamily_tfae _ _).out 0 1) f", "start": [267, 1], "end": [270, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Profinite.instPrecoherent", "code": "instance instPrecoherent : Precoherent Profinite := by\n  constructor\n  intro B\u2081 B\u2082 f \u03b1 _ X\u2081 \u03c0\u2081 h\u2081\n  refine \u27e8\u03b1, inferInstance, (pullback f <| \u03c0\u2081 \u00b7), fun a => pullback.fst _ _, ?_,\n    id, fun a => pullback.snd _ _, ?_\u27e9\n  \u00b7 have := (effectiveEpiFamily_tfae _ \u03c0\u2081).out 0 2\n    rw [this] at h\u2081\n    clear this\n    have := (effectiveEpiFamily_tfae _ (fun a => pullback.fst f (\u03c0\u2081 a))).out 0 2\n    rw [this]\n    clear this\n    intro b\u2082\n    obtain \u27e8a, x, h\u27e9 := h\u2081 (f b\u2082)\n    exact \u27e8a, \u27e8\u27e8b\u2082, x\u27e9, h.symm\u27e9, rfl\u27e9\n  \u00b7 intro a\n    dsimp\n    ext \u27e8\u27e8_, _\u27e9, h\u27e9\n    exact h.symm", "start": [276, 1], "end": [294, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Sites/Closed.lean", "imports": ["Mathlib/CategoryTheory/Sites/SheafOfTypes.lean", "Mathlib/Order/Closure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.GrothendieckTopology.close", "code": "@[simps]\ndef close {X : C} (S : Sieve X) : Sieve X where\n  arrows _ f := J\u2081.Covers S f\n  downward_closed hS := J\u2081.arrow_stable _ _ hS", "start": [60, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.le_close", "code": "theorem le_close {X : C} (S : Sieve X) : S \u2264 J\u2081.close S", "start": [67, 1], "end": [69, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.IsClosed", "code": "def IsClosed {X : C} (S : Sieve X) : Prop :=\n  \u2200 \u2983Y : C\u2984 (f : Y \u27f6 X), J\u2081.Covers S f \u2192 S f", "start": [72, 1], "end": [79, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.covers_iff_mem_of_isClosed", "code": "theorem covers_iff_mem_of_isClosed {X : C} {S : Sieve X} (h : J\u2081.IsClosed S) {Y : C} (f : Y \u27f6 X) :\n    J\u2081.Covers S f \u2194 S f", "start": [82, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.isClosed_pullback", "code": "theorem isClosed_pullback {X Y : C} (f : Y \u27f6 X) (S : Sieve X) :\n    J\u2081.IsClosed S \u2192 J\u2081.IsClosed (S.pullback f)", "start": [88, 1], "end": [91, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.le_close_of_isClosed", "code": "theorem le_close_of_isClosed {X : C} {S T : Sieve X} (h : S \u2264 T) (hT : J\u2081.IsClosed T) :\n    J\u2081.close S \u2264 T", "start": [94, 1], "end": [99, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.close_isClosed", "code": "theorem close_isClosed {X : C} (S : Sieve X) : J\u2081.IsClosed (J\u2081.close S)", "start": [102, 1], "end": [104, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.isClosed_iff_close_eq_self", "code": "theorem isClosed_iff_close_eq_self {X : C} (S : Sieve X) : J\u2081.IsClosed S \u2194 J\u2081.close S = S", "start": [107, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.close_eq_self_of_isClosed", "code": "theorem close_eq_self_of_isClosed {X : C} {S : Sieve X} (hS : J\u2081.IsClosed S) : J\u2081.close S = S", "start": [121, 1], "end": [122, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.pullback_close", "code": "theorem pullback_close {X Y : C} (f : Y \u27f6 X) (S : Sieve X) :\n    J\u2081.close (S.pullback f) = (J\u2081.close S).pullback f", "start": [125, 1], "end": [134, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.monotone_close", "code": "@[mono]\ntheorem monotone_close {X : C} : Monotone (J\u2081.close : Sieve X \u2192 Sieve X)", "start": [137, 1], "end": [139, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.close_close", "code": "@[simp]\ntheorem close_close {X : C} (S : Sieve X) : J\u2081.close (J\u2081.close S) = J\u2081.close S", "start": [142, 1], "end": [145, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.close_eq_top_iff_mem", "code": "theorem close_eq_top_iff_mem {X : C} (S : Sieve X) : J\u2081.close S = \u22a4 \u2194 S \u2208 J\u2081 X", "start": [148, 1], "end": [162, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.closureOperator", "code": "@[simps!]\ndef closureOperator (X : C) : ClosureOperator (Sieve X) :=\n  ClosureOperator.mk' J\u2081.close\n    (fun _ S\u2082 h => J\u2081.le_close_of_isClosed (h.trans (J\u2081.le_close _)) (J\u2081.close_isClosed S\u2082))\n    J\u2081.le_close fun S => J\u2081.le_close_of_isClosed le_rfl (J\u2081.close_isClosed S)", "start": [165, 1], "end": [170, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.GrothendieckTopology.closed_iff_closed", "code": "@[simp]\ntheorem closed_iff_closed {X : C} (S : Sieve X) :\n    S \u2208 (J\u2081.closureOperator X).closed \u2194 J\u2081.IsClosed S", "start": [173, 1], "end": [176, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.closedSieves", "code": "@[simps]\ndef Functor.closedSieves : C\u1d52\u1d56 \u2964 Type max v u where\n  obj X := { S : Sieve X.unop // J\u2081.IsClosed S }\n  map f S := \u27e8S.1.pullback f.unop, J\u2081.isClosed_pullback f.unop _ S.2\u27e9", "start": [181, 1], "end": [188, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.classifier_isSheaf", "code": "theorem classifier_isSheaf : Presieve.IsSheaf J\u2081 (Functor.closedSieves J\u2081)", "start": [191, 1], "end": [242, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.le_topology_of_closedSieves_isSheaf", "code": "theorem le_topology_of_closedSieves_isSheaf {J\u2081 J\u2082 : GrothendieckTopology C}\n    (h : Presieve.IsSheaf J\u2081 (Functor.closedSieves J\u2082)) : J\u2081 \u2264 J\u2082", "start": [245, 1], "end": [265, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.topology_eq_iff_same_sheaves", "code": "theorem topology_eq_iff_same_sheaves {J\u2081 J\u2082 : GrothendieckTopology C} :\n    J\u2081 = J\u2082 \u2194 \u2200 P : C\u1d52\u1d56 \u2964 Type max v u, Presieve.IsSheaf J\u2081 P \u2194 Presieve.IsSheaf J\u2082 P", "start": [268, 1], "end": [282, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.topologyOfClosureOperator", "code": "@[simps]\ndef topologyOfClosureOperator (c : \u2200 X : C, ClosureOperator (Sieve X))\n    (hc : \u2200 \u2983X Y : C\u2984 (f : Y \u27f6 X) (S : Sieve X), c _ (S.pullback f) = (c _ S).pullback f) :\n    GrothendieckTopology C where\n  sieves X := { S | c X S = \u22a4 }\n  top_mem' X := top_unique ((c X).le_closure _)\n  pullback_stable' X Y S f hS := by\n    rw [Set.mem_setOf_eq] at hS\n    rw [Set.mem_setOf_eq, hc, hS, Sieve.pullback_top]\n  transitive' X S hS R hR := by\n    rw [Set.mem_setOf_eq] at hS\n    rw [Set.mem_setOf_eq, \u2190 (c X).idempotent, eq_top_iff, \u2190 hS]\n    apply (c X).monotone fun Y f hf => _\n    intros Y f hf\n    rw [Sieve.pullback_eq_top_iff_mem, \u2190 hc]\n    apply hR hf", "start": [285, 1], "end": [305, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.topologyOfClosureOperator_self", "code": "theorem topologyOfClosureOperator_self :\n    (topologyOfClosureOperator J\u2081.closureOperator fun X Y => J\u2081.pullback_close) = J\u2081", "start": [308, 1], "end": [314, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.topologyOfClosureOperator_close", "code": "theorem topologyOfClosureOperator_close (c : \u2200 X : C, ClosureOperator (Sieve X))\n    (pb : \u2200 \u2983X Y : C\u2984 (f : Y \u27f6 X) (S : Sieve X), c Y (S.pullback f) = (c X S).pullback f) (X : C)\n    (S : Sieve X) : (topologyOfClosureOperator c pb).close S = c X S", "start": [317, 1], "end": [322, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ProperMap.lean", "imports": ["Mathlib/Topology/StoneCech.lean", "Mathlib/Topology/Homeomorph.lean", "Mathlib/Topology/Filter.lean", "Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsProperMap", "code": "@[mk_iff isProperMap_iff_clusterPt]\nstructure IsProperMap (f : X \u2192 Y) extends Continuous f : Prop where\n  \n  clusterPt_of_mapClusterPt :\n    \u2200 \u2983\u2131 : Filter X\u2984, \u2200 \u2983y : Y\u2984, MapClusterPt y \u2131 f \u2192 \u2203 x, f x = y \u2227 ClusterPt x \u2131", "start": [80, 1], "end": [88, 83], "kind": "commanddeclaration"}, {"full_name": "IsProperMap.continuous", "code": "lemma IsProperMap.continuous (h : IsProperMap f) : Continuous f := h.toContinuous", "start": [94, 1], "end": [95, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Homeomorph.isProperMap", "code": "@[simp] lemma Homeomorph.isProperMap (e : X \u2243\u209c Y) : IsProperMap e := by\n  rw [isProperMap_iff_clusterPt]\n  refine \u27e8e.continuous, fun \u2131 y \u21a6 ?_\u27e9\n  simp_rw [MapClusterPt, ClusterPt, \u2190 Filter.push_pull', map_neBot_iff, e.comap_nhds_eq,\n    \u2190 e.coe_toEquiv, \u2190 e.eq_symm_apply, exists_eq_left]\n  exact id", "start": [97, 1], "end": [103, 11], "kind": "mathlibtacticlemma"}, {"full_name": "isProperMap_id", "code": "@[simp] lemma isProperMap_id : IsProperMap (id : X \u2192 X) := (Homeomorph.refl X).isProperMap", "start": [105, 1], "end": [106, 91], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.isClosedMap", "code": "lemma IsProperMap.isClosedMap (h : IsProperMap f) : IsClosedMap f := by\n  rw [isClosedMap_iff_clusterPt]\n  exact fun s y \u21a6 h.clusterPt_of_mapClusterPt (\u2131 := \ud835\udcdf s) (y := y)", "start": [108, 1], "end": [111, 66], "kind": "mathlibtacticlemma"}, {"full_name": "isProperMap_iff_ultrafilter", "code": "lemma isProperMap_iff_ultrafilter : IsProperMap f \u2194 Continuous f \u2227\n    \u2200 \u2983\ud835\udcb0 : Ultrafilter X\u2984, \u2200 \u2983y : Y\u2984, Tendsto f \ud835\udcb0 (\ud835\udcdd y) \u2192 \u2203 x, f x = y \u2227 \ud835\udcb0 \u2264 \ud835\udcdd x := by\n  rw [isProperMap_iff_clusterPt]\n  refine and_congr_right (fun _ \u21a6 ?_)\n  constructor <;> intro H\n  \u00b7 intro \ud835\udcb0 y (hY : (Ultrafilter.map f \ud835\udcb0 : Filter Y) \u2264 _)\n    simp_rw [\u2190 Ultrafilter.clusterPt_iff] at hY \u22a2\n    exact H hY\n  \u00b7 simp_rw [MapClusterPt, ClusterPt, \u2190 Filter.push_pull', map_neBot_iff, \u2190 exists_ultrafilter_iff,\n      forall_exists_index]\n    intro \u2131 y \ud835\udcb0 hy\n    rcases H (tendsto_iff_comap.mpr <| hy.trans inf_le_left) with \u27e8x, hxy, hx\u27e9\n    exact \u27e8x, hxy, \ud835\udcb0, le_inf hx (hy.trans inf_le_right)\u27e9", "start": [113, 1], "end": [127, 57], "kind": "mathlibtacticlemma"}, {"full_name": "isProperMap_iff_ultrafilter_of_t2", "code": "lemma isProperMap_iff_ultrafilter_of_t2 [T2Space Y] : IsProperMap f \u2194 Continuous f \u2227\n    \u2200 \u2983\ud835\udcb0 : Ultrafilter X\u2984, \u2200 \u2983y : Y\u2984, Tendsto f \ud835\udcb0 (\ud835\udcdd y) \u2192 \u2203 x, \ud835\udcb0.1 \u2264 \ud835\udcdd x :=\n  isProperMap_iff_ultrafilter.trans <| and_congr_right fun hc \u21a6 forall\u2083_congr fun _\ud835\udcb0 _y hy \u21a6\n    exists_congr fun x \u21a6 and_iff_right_of_imp fun h \u21a6\n      tendsto_nhds_unique ((hc.tendsto x).mono_left h) hy", "start": [129, 1], "end": [133, 58], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.ultrafilter_le_nhds_of_tendsto", "code": "lemma IsProperMap.ultrafilter_le_nhds_of_tendsto (h : IsProperMap f) \u2983\ud835\udcb0 : Ultrafilter X\u2984 \u2983y : Y\u2984\n    (hy : Tendsto f \ud835\udcb0 (\ud835\udcdd y)) : \u2203 x, f x = y \u2227 \ud835\udcb0 \u2264 \ud835\udcdd x :=\n  (isProperMap_iff_ultrafilter.mp h).2 hy", "start": [135, 1], "end": [139, 42], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.prod_map", "code": "lemma IsProperMap.prod_map {g : Z \u2192 W} (hf : IsProperMap f) (hg : IsProperMap g) :\n    IsProperMap (Prod.map f g) := by\n  simp_rw [isProperMap_iff_ultrafilter] at hf hg \u22a2\n  constructor\n  \u00b7 exact hf.1.prod_map hg.1\n  \u00b7 intro \ud835\udcb0 \u27e8y, w\u27e9 hyw\n  simp_rw [nhds_prod_eq, tendsto_prod_iff'] at hyw\n  rcases hf.2 (show Tendsto f (Ultrafilter.map fst \ud835\udcb0) (\ud835\udcdd y) by simpa using hyw.1) with\n      \u27e8x, hxy, hx\u27e9\n    rcases hg.2 (show Tendsto g (Ultrafilter.map snd \ud835\udcb0) (\ud835\udcdd w) by simpa using hyw.2) with\n      \u27e8z, hzw, hz\u27e9\n  refine \u27e8\u27e8x, z\u27e9, Prod.ext hxy hzw, ?_\u27e9\n    rw [nhds_prod_eq, le_prod]\n    exact \u27e8hx, hz\u27e9", "start": [141, 1], "end": [163, 19], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.pi_map", "code": "lemma IsProperMap.pi_map {X Y : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]\n    [\u2200 i, TopologicalSpace (Y i)] {f : (i : \u03b9) \u2192 X i \u2192 Y i} (h : \u2200 i, IsProperMap (f i)) :\n    IsProperMap (fun (x : \u2200 i, X i) i \u21a6 f i (x i)) := by\n  simp_rw [isProperMap_iff_ultrafilter] at h \u22a2\n  constructor\n  \u00b7 exact continuous_pi fun i \u21a6 (h i).1.comp (continuous_apply i)\n  \u00b7 intro \ud835\udcb0 y hy\n  have : \u2200 i, Tendsto (f i) (Ultrafilter.map (eval i) \ud835\udcb0) (\ud835\udcdd (y i)) :=\n      by simpa [tendsto_pi_nhds] using hy\n  choose x hxy hx using fun i \u21a6 (h i).2 (this i)\n  refine \u27e8x, funext hxy, ?_\u27e9\n    rwa [nhds_pi, le_pi]", "start": [165, 1], "end": [185, 25], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.isCompact_preimage", "code": "lemma IsProperMap.isCompact_preimage (h : IsProperMap f) {K : Set Y} (hK : IsCompact K) :\n    IsCompact (f \u207b\u00b9' K) := by\n  rw [isCompact_iff_ultrafilter_le_nhds]\n  intro \ud835\udcb0 h\ud835\udcb0\n  rw [\u2190 comap_principal, \u2190 map_le_iff_le_comap, \u2190 Ultrafilter.coe_map] at h\ud835\udcb0\n  rcases hK.ultrafilter_le_nhds _ h\ud835\udcb0 with \u27e8y, hyK, hy\u27e9\n  rcases h.ultrafilter_le_nhds_of_tendsto hy with \u27e8x, rfl, hx\u27e9\n  exact \u27e8x, hyK, hx\u27e9", "start": [187, 1], "end": [202, 21], "kind": "mathlibtacticlemma"}, {"full_name": "isProperMap_iff_isClosedMap_and_compact_fibers", "code": "theorem isProperMap_iff_isClosedMap_and_compact_fibers :\n    IsProperMap f \u2194 Continuous f \u2227 IsClosedMap f \u2227 \u2200 y, IsCompact (f \u207b\u00b9' {y})", "start": [204, 1], "end": [229, 30], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_isClosedMap_and_tendsto_cofinite", "code": "lemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :\n    IsProperMap f \u2194 Continuous f \u2227 IsClosedMap f \u2227 Tendsto f (cocompact X) cofinite := by\n  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,\n    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]\n  refine and_congr_right fun f_cont \u21a6 and_congr_right fun _ \u21a6\n    \u27e8fun H y \u21a6 (H y).compl_mem_cocompact, fun H y \u21a6 ?_\u27e9\n  rcases mem_cocompact.mp (H y) with \u27e8K, hK, hKy\u27e9\n  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)\n    (compl_le_compl_iff_le.mp hKy)", "start": [231, 1], "end": [241, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Continuous.isProperMap", "code": "theorem Continuous.isProperMap [CompactSpace X] [T2Space Y] (hf : Continuous f) : IsProperMap f", "start": [243, 1], "end": [245, 83], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_isCompact_preimage", "code": "theorem isProperMap_iff_isCompact_preimage [T2Space Y] [WeaklyLocallyCompactSpace Y] :\n    IsProperMap f \u2194 Continuous f \u2227 \u2200 \u2983K\u2984, IsCompact K \u2192 IsCompact (f \u207b\u00b9' K)", "start": [247, 1], "end": [265, 18], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_tendsto_cocompact", "code": "lemma isProperMap_iff_tendsto_cocompact [T2Space Y] [WeaklyLocallyCompactSpace Y] :\n    IsProperMap f \u2194 Continuous f \u2227 Tendsto f (cocompact X) (cocompact Y) := by\n  simp_rw [isProperMap_iff_isCompact_preimage, hasBasis_cocompact.tendsto_right_iff,\n    \u2190 mem_preimage, eventually_mem_set, preimage_compl]\n  refine and_congr_right fun f_cont \u21a6\n    \u27e8fun H K hK \u21a6 (H hK).compl_mem_cocompact, fun H K hK \u21a6 ?_\u27e9\n  rcases mem_cocompact.mp (H K hK) with \u27e8K', hK', hK'y\u27e9\n  exact hK'.of_isClosed_subset (hK.isClosed.preimage f_cont)\n    (compl_le_compl_iff_le.mp hK'y)", "start": [267, 1], "end": [276, 36], "kind": "mathlibtacticlemma"}, {"full_name": "IsProperMap.universally_closed", "code": "theorem IsProperMap.universally_closed (Z) [TopologicalSpace Z] (h : IsProperMap f) :\n    IsClosedMap (Prod.map f id : X \u00d7 Z \u2192 Y \u00d7 Z)", "start": [278, 1], "end": [285, 42], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_isClosedMap_filter", "code": "theorem isProperMap_iff_isClosedMap_filter {X : Type u} {Y : Type v} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} :\n    IsProperMap f \u2194 Continuous f \u2227 IsClosedMap\n      (Prod.map f id : X \u00d7 Filter X \u2192 Y \u00d7 Filter X)", "start": [287, 1], "end": [329, 17], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_isClosedMap_ultrafilter", "code": "theorem isProperMap_iff_isClosedMap_ultrafilter {X : Type u} {Y : Type v} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} :\n    IsProperMap f \u2194 Continuous f \u2227 IsClosedMap\n      (Prod.map f id : X \u00d7 Ultrafilter X \u2192 Y \u00d7 Ultrafilter X)", "start": [331, 1], "end": [354, 17], "kind": "commanddeclaration"}, {"full_name": "isProperMap_iff_universally_closed", "code": "theorem isProperMap_iff_universally_closed {X : Type u} {Y : Type v} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X \u2192 Y} :\n    IsProperMap f \u2194 Continuous f \u2227 \u2200 (Z : Type u) [TopologicalSpace Z],\n      IsClosedMap (Prod.map f id : X \u00d7 Z \u2192 Y \u00d7 Z)", "start": [356, 1], "end": [370, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/NumberTheory/Cyclotomic/Discriminant.lean", "imports": ["Mathlib/NumberTheory/Cyclotomic/PrimitiveRoots.lean", "Mathlib/RingTheory/Discriminant.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPrimitiveRoot.discr_zeta_eq_discr_zeta_sub_one", "code": "theorem discr_zeta_eq_discr_zeta_sub_one (h\u03b6 : IsPrimitiveRoot \u03b6 n) :\n    discr \u211a (h\u03b6.powerBasis \u211a).basis = discr \u211a (h\u03b6.subOnePowerBasis \u211a).basis", "start": [38, 1], "end": [51, 62], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.discr_prime_pow_ne_two", "code": "theorem discr_prime_pow_ne_two [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : \u2115).Prime]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (\u2191(p ^ (k + 1)) : \u2115) K))\n    (hk : p ^ (k + 1) \u2260 2) : discr K (h\u03b6.powerBasis K).basis =\n      (-1) ^ ((p ^ (k + 1) : \u2115).totient / 2) * p ^ ((p : \u2115) ^ k * ((p - 1) * (k + 1) - 1))", "start": [62, 1], "end": [126, 40], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.discr_prime_pow_ne_two'", "code": "theorem discr_prime_pow_ne_two' [IsCyclotomicExtension {p ^ (k + 1)} K L] [hp : Fact (p : \u2115).Prime]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ (k + 1))) (hirr : Irreducible (cyclotomic (\u2191(p ^ (k + 1)) : \u2115) K))\n    (hk : p ^ (k + 1) \u2260 2) : discr K (h\u03b6.powerBasis K).basis =\n      (-1) ^ ((p : \u2115) ^ k * (p - 1) / 2) * p ^ ((p : \u2115) ^ k * ((p - 1) * (k + 1) - 1))", "start": [129, 1], "end": [136, 91], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.discr_prime_pow", "code": "theorem discr_prime_pow [hcycl : IsCyclotomicExtension {p ^ k} K L] [hp : Fact (p : \u2115).Prime]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k)) (hirr : Irreducible (cyclotomic (\u2191(p ^ k) : \u2115) K)) :\n    discr K (h\u03b6.powerBasis K).basis =\n      (-1) ^ ((p ^ k : \u2115).totient / 2) * p ^ ((p : \u2115) ^ (k - 1) * ((p - 1) * k - 1))", "start": [139, 1], "end": [180, 46], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow", "code": "theorem discr_prime_pow_eq_unit_mul_pow [IsCyclotomicExtension {p ^ k} K L]\n    [hp : Fact (p : \u2115).Prime] (h\u03b6 : IsPrimitiveRoot \u03b6 \u2191(p ^ k))\n    (hirr : Irreducible (cyclotomic (\u2191(p ^ k) : \u2115) K)) :\n    \u2203 (u : \u2124\u02e3) (n : \u2115), discr K (h\u03b6.powerBasis K).basis = u * p ^ n", "start": [183, 1], "end": [194, 61], "kind": "commanddeclaration"}, {"full_name": "IsCyclotomicExtension.discr_odd_prime", "code": "theorem discr_odd_prime [IsCyclotomicExtension {p} K L] [hp : Fact (p : \u2115).Prime]\n    (h\u03b6 : IsPrimitiveRoot \u03b6 p) (hirr : Irreducible (cyclotomic p K)) (hodd : p \u2260 2) :\n    discr K (h\u03b6.powerBasis K).basis = (-1) ^ (((p : \u2115) - 1) / 2) * p ^ ((p : \u2115) - 2)", "start": [197, 1], "end": [209, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Polynomial/Eisenstein/IsIntegral.lean", "imports": ["Mathlib/RingTheory/Norm.lean", "Mathlib/RingTheory/IntegrallyClosed.lean", "Mathlib/Data/Nat/Choose/Dvd.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Polynomial/Cyclotomic/Expand.lean"], "premises": [{"full_name": "cyclotomic_comp_X_add_one_isEisensteinAt", "code": "theorem cyclotomic_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] :\n    ((cyclotomic p \u2124).comp (X + 1)).IsEisensteinAt \ud835\udcdf", "start": [44, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt", "code": "theorem cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] (n : \u2115) :\n    ((cyclotomic (p ^ (n + 1)) \u2124).comp (X + 1)).IsEisensteinAt \ud835\udcdf", "start": [77, 1], "end": [117, 61], "kind": "commanddeclaration"}, {"full_name": "dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt", "code": "theorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p \u2022 z)\n    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt \ud835\udcdf) : p \u2223 Q.coeff 0", "start": [135, 1], "end": [216, 9], "kind": "commanddeclaration"}, {"full_name": "mem_adjoin_of_dvd_coeff_of_dvd_aeval", "code": "theorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type*} [CommSemiring A] [CommRing B]\n    [Algebra A B] [NoZeroSMulDivisors A B] {Q : A[X]} {p : A} {x z : B} (hp : p \u2260 0)\n    (hQ : \u2200 i \u2208 range (Q.natDegree + 1), p \u2223 Q.coeff i) (hz : aeval x Q = p \u2022 z) :\n    z \u2208 adjoin A ({x} : Set B)", "start": [219, 1], "end": [234, 93], "kind": "commanddeclaration"}, {"full_name": "mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt", "code": "theorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)\n    (hz : p \u2022 z \u2208 adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt \ud835\udcdf) :\n    z \u2208 adjoin R ({B.gen} : Set L)", "start": [237, 1], "end": [376, 89], "kind": "commanddeclaration"}, {"full_name": "mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt", "code": "theorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : \u2115} {z : L} (hzint : IsIntegral R z)\n    (hz : p ^ n \u2022 z \u2208 adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt \ud835\udcdf) :\n    z \u2208 adjoin R ({B.gen} : Set L)", "start": [379, 1], "end": [394, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Lex.lean", "imports": ["Mathlib/Data/Finsupp/Order.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/Data/DFinsupp/Lex.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.Lex", "code": "protected def Lex (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : N \u2192 N \u2192 Prop) (x y : \u03b1 \u2192\u2080 N) : Prop :=\n  Pi.Lex r s x y", "start": [27, 1], "end": [33, 17], "kind": "commanddeclaration"}, {"full_name": "Pi.lex_eq_finsupp_lex", "code": "theorem _root_.Pi.lex_eq_finsupp_lex {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : N \u2192 N \u2192 Prop} (a b : \u03b1 \u2192\u2080 N) :\n    Pi.Lex r s a b = Finsupp.Lex r s a b", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lex_def", "code": "theorem lex_def {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : N \u2192 N \u2192 Prop} {a b : \u03b1 \u2192\u2080 N} :\n    Finsupp.Lex r s a b \u2194 \u2203 j, (\u2200 d, r d j \u2192 a d = b d) \u2227 s (a j) (b j)", "start": [42, 1], "end": [44, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lex_eq_invImage_dfinsupp_lex", "code": "theorem lex_eq_invImage_dfinsupp_lex (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : N \u2192 N \u2192 Prop) :\n    Finsupp.Lex r s = InvImage (DFinsupp.Lex r fun _ \u21a6 s) toDFinsupp", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lex_lt_of_lt_of_preorder", "code": "theorem lex_lt_of_lt_of_preorder [Preorder N] (r) [IsStrictOrder \u03b1 r] {x y : \u03b1 \u2192\u2080 N} (hlt : x < y) :\n    \u2203 i, (\u2200 j, r j i \u2192 x j \u2264 y j \u2227 y j \u2264 x j) \u2227 x i < y i", "start": [55, 1], "end": [57, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lex_lt_of_lt", "code": "theorem lex_lt_of_lt [PartialOrder N] (r) [IsStrictOrder \u03b1 r] {x y : \u03b1 \u2192\u2080 N} (hlt : x < y) :\n    Pi.Lex r (\u00b7 < \u00b7) x y", "start": [60, 1], "end": [62, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.isStrictOrder", "code": "instance Lex.isStrictOrder [LinearOrder \u03b1] [PartialOrder N] :\n    IsStrictOrder (Lex (\u03b1 \u2192\u2080 N)) (\u00b7 < \u00b7) :=\n  let i : IsStrictOrder (Lex (\u03b1 \u2192 N)) (\u00b7 < \u00b7) := Pi.Lex.isStrictOrder\n  { irrefl := toLex.surjective.forall.2 fun _ \u21a6 @irrefl _ _ i.toIsIrrefl _\n    trans := toLex.surjective.forall\u2083.2 fun _ _ _ \u21a6 @trans _ _ i.toIsTrans _ _ _ }", "start": [65, 1], "end": [69, 83], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.partialOrder", "code": "instance Lex.partialOrder [PartialOrder N] : PartialOrder (Lex (\u03b1 \u2192\u2080 N)) where\n  lt := (\u00b7 < \u00b7)\n  le x y := \u21d1(ofLex x) = \u21d1(ofLex y) \u2228 x < y\n  __ := PartialOrder.lift (fun x : Lex (\u03b1 \u2192\u2080 N) \u21a6 toLex (\u21d1(ofLex x)))\n    (FunLike.coe_injective (F := Finsupp \u03b1 N))", "start": [74, 1], "end": [80, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.linearOrder", "code": "instance Lex.linearOrder [LinearOrder N] : LinearOrder (Lex (\u03b1 \u2192\u2080 N)) where\n  lt := (\u00b7 < \u00b7)\n  le := (\u00b7 \u2264 \u00b7)\n  __ := LinearOrder.lift' (toLex \u2218 toDFinsupp \u2218 ofLex) finsuppEquivDFinsupp.injective", "start": [83, 1], "end": [87, 86], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toLex_monotone", "code": "theorem toLex_monotone : Monotone (@toLex (\u03b1 \u2192\u2080 N))", "start": [92, 1], "end": [93, 100], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lt_of_forall_lt_of_lt", "code": "theorem lt_of_forall_lt_of_lt (a b : Lex (\u03b1 \u2192\u2080 N)) (i : \u03b1) :\n    (\u2200 j < i, ofLex a j = ofLex b j) \u2192 ofLex a i < ofLex b i \u2192 a < b", "start": [96, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.covariantClass_lt_left", "code": "instance Lex.covariantClass_lt_left :\n    CovariantClass (Lex (\u03b1 \u2192\u2080 N)) (Lex (\u03b1 \u2192\u2080 N)) (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun _ _ _ \u27e8a, lta, ha\u27e9 \u21a6 \u27e8a, fun j ja \u21a6 congr_arg _ (lta j ja), add_lt_add_left ha _\u27e9\u27e9", "start": [119, 1], "end": [121, 90], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.covariantClass_le_left", "code": "instance Lex.covariantClass_le_left :\n    CovariantClass (Lex (\u03b1 \u2192\u2080 N)) (Lex (\u03b1 \u2192\u2080 N)) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  covariantClass_le_of_lt _ _ _", "start": [124, 1], "end": [126, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.covariantClass_lt_right", "code": "instance Lex.covariantClass_lt_right :\n    CovariantClass (Lex (\u03b1 \u2192\u2080 N)) (Lex (\u03b1 \u2192\u2080 N)) (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun f _ _ \u27e8a, lta, ha\u27e9 \u21a6\n    \u27e8a, fun j ja \u21a6 congr_arg (\u00b7 + ofLex f j) (lta j ja), add_lt_add_right ha _\u27e9\u27e9", "start": [135, 1], "end": [138, 81], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.covariantClass_le_right", "code": "instance Lex.covariantClass_le_right :\n    CovariantClass (Lex (\u03b1 \u2192\u2080 N)) (Lex (\u03b1 \u2192\u2080 N)) (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  covariantClass_le_of_lt _ _ _", "start": [141, 1], "end": [143, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.orderBot", "code": "instance Lex.orderBot [CanonicallyOrderedAddCommMonoid N] : OrderBot (Lex (\u03b1 \u2192\u2080 N)) where\n  bot := 0\n  bot_le _ := Finsupp.toLex_monotone bot_le", "start": [154, 1], "end": [156, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.orderedAddCancelCommMonoid", "code": "noncomputable instance Lex.orderedAddCancelCommMonoid [OrderedCancelAddCommMonoid N] :\n    OrderedCancelAddCommMonoid (Lex (\u03b1 \u2192\u2080 N)) where\n  add_le_add_left _ _ h _ := add_le_add_left (\u03b1 := Lex (\u03b1 \u2192 N)) h _\n  le_of_add_le_add_left _ _ _ := le_of_add_le_add_left (\u03b1 := Lex (\u03b1 \u2192 N))", "start": [158, 1], "end": [161, 74], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.orderedAddCommGroup", "code": "noncomputable instance Lex.orderedAddCommGroup [OrderedAddCommGroup N] :\n    OrderedAddCommGroup (Lex (\u03b1 \u2192\u2080 N)) where\n  add_le_add_left _ _ := add_le_add_left", "start": [163, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.linearOrderedCancelAddCommMonoid", "code": "noncomputable instance Lex.linearOrderedCancelAddCommMonoid [LinearOrderedCancelAddCommMonoid N] :\n    LinearOrderedCancelAddCommMonoid (Lex (\u03b1 \u2192\u2080 N)) where\n  __ : LinearOrder (Lex (\u03b1 \u2192\u2080 N)) := inferInstance\n  __ : OrderedCancelAddCommMonoid (Lex (\u03b1 \u2192\u2080 N)) := inferInstance", "start": [167, 1], "end": [170, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.Lex.linearOrderedAddCommGroup", "code": "noncomputable instance Lex.linearOrderedAddCommGroup [LinearOrderedAddCommGroup N] :\n    LinearOrderedAddCommGroup (Lex (\u03b1 \u2192\u2080 N)) where\n  __ : LinearOrder (Lex (\u03b1 \u2192\u2080 N)) := inferInstance\n  add_le_add_left _ _ := add_le_add_left", "start": [172, 1], "end": [175, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Fix.lean", "imports": ["Mathlib/Data/Nat/Upto.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Part.lean", "Mathlib/Data/Stream/Defs.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "Fix", "code": "class Fix (\u03b1 : Type*) where\n  \n  fix : (\u03b1 \u2192 \u03b1) \u2192 \u03b1", "start": [33, 1], "end": [37, 20], "kind": "commanddeclaration"}, {"full_name": "Part.Fix.approx", "code": "def Fix.approx : Stream' (\u2200 a, Part (\u03b2 a))\n  | 0 => \u22a5\n  | Nat.succ i => f (Fix.approx i)", "start": [48, 1], "end": [52, 35], "kind": "commanddeclaration"}, {"full_name": "Part.fixAux", "code": "def fixAux {p : \u2115 \u2192 Prop} (i : Nat.Upto p) (g : \u2200 j : Nat.Upto p, i < j \u2192 \u2200 a, Part (\u03b2 a)) :\n    \u2200 a, Part (\u03b2 a) :=\n  f fun x : \u03b1 => (assert \u00acp i.val) fun h : \u00acp i.val => g (i.succ h) (Nat.lt_succ_self _) x", "start": [55, 1], "end": [58, 91], "kind": "commanddeclaration"}, {"full_name": "Part.fix", "code": "protected def fix (x : \u03b1) : Part (\u03b2 x) :=\n  (Part.assert (\u2203 i, (Fix.approx f i x).Dom)) fun h =>\n    WellFounded.fix.{1} (Nat.Upto.wf h) (fixAux f) Nat.Upto.zero x", "start": [61, 1], "end": [71, 67], "kind": "commanddeclaration"}, {"full_name": "Part.fix_def", "code": "protected theorem fix_def {x : \u03b1} (h' : \u2203 i, (Fix.approx f i x).Dom) :\n    Part.fix f x = Fix.approx f (Nat.succ (Nat.find h')) x", "start": [74, 1], "end": [108, 55], "kind": "commanddeclaration"}, {"full_name": "Part.fix_def'", "code": "theorem fix_def' {x : \u03b1} (h' : \u00ac\u2203 i, (Fix.approx f i x).Dom) : Part.fix f x = none", "start": [111, 1], "end": [113, 21], "kind": "commanddeclaration"}, {"full_name": "Part.hasFix", "code": "instance hasFix : Fix (Part \u03b1) :=\n  \u27e8fun f => Part.fix (fun x u => f (x u)) ()\u27e9", "start": [122, 1], "end": [123, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.Part.hasFix", "code": "instance Part.hasFix {\u03b2} : Fix (\u03b1 \u2192 Part \u03b2) :=\n  \u27e8Part.fix\u27e9", "start": [132, 1], "end": [133, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/MeasureTheory/Function/AEEqFun/DomAct.lean", "imports": ["Mathlib/MeasureTheory/Function/AEEqFun.lean", "Mathlib/GroupTheory/GroupAction/DomAct/Basic.lean", "Mathlib/MeasureTheory/Group/Action.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DomMulAct.smul_aeeqFun_aeeq", "code": "@[to_additive]\ntheorem smul_aeeqFun_aeeq (c : M\u1d48\u1d50\u1d43) (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) :\n    c \u2022 f =\u1d50[\u03bc] (f <| mk.symm c \u2022 \u00b7)", "start": [40, 1], "end": [43, 34], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.mk_smul_mk_aeeqFun", "code": "@[to_additive (attr := simp)]\ntheorem mk_smul_mk_aeeqFun (c : M) (f : \u03b1 \u2192 \u03b2) (hf : AEStronglyMeasurable f \u03bc) :\n    mk c \u2022 AEEqFun.mk f hf = AEEqFun.mk (f <| c \u2022 \u00b7)\n      (hf.comp_measurePreserving (measurePreserving_smul _ _))", "start": [45, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "DomMulAct.smul_aeeqFun_const", "code": "@[to_additive (attr := simp)]\ntheorem smul_aeeqFun_const (c : M\u1d48\u1d50\u1d43) (b : \u03b2) :\n    c \u2022 (AEEqFun.const \u03b1 b : \u03b1 \u2192\u2098[\u03bc] \u03b2) = AEEqFun.const \u03b1 b", "start": [51, 1], "end": [54, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Jordan/Basic.lean", "imports": ["Mathlib/Algebra/Lie/OfAssociative.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsJordan", "code": "class IsJordan [Mul A] : Prop where\n  lmul_comm_rmul : \u2200 a b : A, a * b * a = a * (b * a)\n  lmul_lmul_comm_lmul : \u2200 a b : A, a * a * (a * b) = a * (a * a * b)\n  lmul_lmul_comm_rmul : \u2200 a b : A, a * a * (b * a) = a * a * b * a\n  lmul_comm_rmul_rmul : \u2200 a b : A, a * b * (a * a) = a * (b * (a * a))\n  rmul_comm_rmul_rmul : \u2200 a b : A, b * a * (a * a) = b * (a * a) * a", "start": [79, 1], "end": [85, 69], "kind": "commanddeclaration"}, {"full_name": "IsCommJordan", "code": "class IsCommJordan [Mul A] : Prop where\n  mul_comm : \u2200 a b : A, a * b = b * a\n  lmul_comm_rmul_rmul : \u2200 a b : A, a * b * (a * a) = a * (b * (a * a))", "start": [88, 1], "end": [91, 71], "kind": "commanddeclaration"}, {"full_name": "IsCommJordan.toIsJordan", "code": "instance (priority := 100) IsCommJordan.toIsJordan [Mul A] [IsCommJordan A] : IsJordan A where\n  lmul_comm_rmul a b := by rw [IsCommJordan.mul_comm, IsCommJordan.mul_comm a b]\n  lmul_lmul_comm_lmul a b := by\n    rw [IsCommJordan.mul_comm (a * a) (a * b), IsCommJordan.lmul_comm_rmul_rmul,\n      IsCommJordan.mul_comm b (a * a)]\n  lmul_comm_rmul_rmul := IsCommJordan.lmul_comm_rmul_rmul\n  lmul_lmul_comm_rmul a b := by\n    rw [IsCommJordan.mul_comm (a * a) (b * a), IsCommJordan.mul_comm b a,\n      IsCommJordan.lmul_comm_rmul_rmul, IsCommJordan.mul_comm, IsCommJordan.mul_comm b (a * a)]\n  rmul_comm_rmul_rmul a b := by\n    rw [IsCommJordan.mul_comm b a, IsCommJordan.lmul_comm_rmul_rmul, IsCommJordan.mul_comm]", "start": [95, 1], "end": [106, 92], "kind": "commanddeclaration"}, {"full_name": "Semigroup.isJordan", "code": "instance (priority := 100) Semigroup.isJordan [Semigroup A] : IsJordan A where\n  lmul_comm_rmul a b := by rw [mul_assoc]\n  lmul_lmul_comm_lmul a b := by rw [mul_assoc, mul_assoc]\n  lmul_comm_rmul_rmul a b := by rw [mul_assoc]\n  lmul_lmul_comm_rmul a b := by rw [\u2190 mul_assoc]\n  rmul_comm_rmul_rmul a b := by rw [\u2190 mul_assoc, \u2190 mul_assoc]", "start": [110, 1], "end": [116, 62], "kind": "commanddeclaration"}, {"full_name": "CommSemigroup.isCommJordan", "code": "instance (priority := 100) CommSemigroup.isCommJordan [CommSemigroup A] : IsCommJordan A where\n  mul_comm := mul_comm\n  lmul_comm_rmul_rmul _ _ := mul_assoc _ _ _", "start": [120, 1], "end": [122, 45], "kind": "commanddeclaration"}, {"full_name": "commute_lmul_rmul", "code": "@[simp]\ntheorem commute_lmul_rmul (a : A) : Commute (L a) (R a)", "start": [138, 1], "end": [140, 63], "kind": "commanddeclaration"}, {"full_name": "commute_lmul_lmul_sq", "code": "@[simp]\ntheorem commute_lmul_lmul_sq (a : A) : Commute (L a) (L (a * a))", "start": [143, 1], "end": [145, 68], "kind": "commanddeclaration"}, {"full_name": "commute_lmul_rmul_sq", "code": "@[simp]\ntheorem commute_lmul_rmul_sq (a : A) : Commute (L a) (R (a * a))", "start": [148, 1], "end": [150, 68], "kind": "commanddeclaration"}, {"full_name": "commute_lmul_sq_rmul", "code": "@[simp]\ntheorem commute_lmul_sq_rmul (a : A) : Commute (L (a * a)) (R a)", "start": [153, 1], "end": [155, 61], "kind": "commanddeclaration"}, {"full_name": "commute_rmul_rmul_sq", "code": "@[simp]\ntheorem commute_rmul_rmul_sq (a : A) : Commute (R a) (R (a * a))", "start": [158, 1], "end": [160, 68], "kind": "commanddeclaration"}, {"full_name": "two_nsmul_lie_lmul_lmul_add_eq_lie_lmul_lmul_add", "code": "theorem two_nsmul_lie_lmul_lmul_add_eq_lie_lmul_lmul_add (a b : A) :\n    2 \u2022 (\u2045L a, L (a * b)\u2046 + \u2045L b, L (b * a)\u2046) = \u2045L (a * a), L b\u2046 + \u2045L (b * b), L a\u2046", "start": [173, 1], "end": [180, 7], "kind": "commanddeclaration"}, {"full_name": "aux0", "code": "private theorem aux0 {a b c : A} : \u2045L (a + b + c), L ((a + b + c) * (a + b + c))\u2046 =\n    \u2045L a + L b + L c, L (a * a) + L (b * b) + L (c * c) +\n    2 \u2022 L (a * b) + 2 \u2022 L (c * a) + 2 \u2022 L (b * c)\u2046", "start": [186, 1], "end": [195, 7], "kind": "commanddeclaration"}, {"full_name": "aux1", "code": "private theorem aux1 {a b c : A} :\n    \u2045L a + L b + L c, L (a * a) + L (b * b) + L (c * c) +\n    2 \u2022 L (a * b) + 2 \u2022 L (c * a) + 2 \u2022 L (b * c)\u2046\n    =\n    \u2045L a, L (a * a)\u2046 + \u2045L a, L (b * b)\u2046 + \u2045L a, L (c * c)\u2046 +\n    \u2045L a, 2 \u2022 L (a * b)\u2046 + \u2045L a, 2 \u2022 L (c * a)\u2046 + \u2045L a, 2 \u2022 L (b * c)\u2046 +\n    (\u2045L b, L (a * a)\u2046 + \u2045L b, L (b * b)\u2046 + \u2045L b, L (c * c)\u2046 +\n    \u2045L b, 2 \u2022 L (a * b)\u2046 + \u2045L b, 2 \u2022 L (c * a)\u2046 + \u2045L b, 2 \u2022 L (b * c)\u2046) +\n    (\u2045L c, L (a * a)\u2046 + \u2045L c, L (b * b)\u2046 + \u2045L c, L (c * c)\u2046 +\n    \u2045L c, 2 \u2022 L (a * b)\u2046 + \u2045L c, 2 \u2022 L (c * a)\u2046 + \u2045L c, 2 \u2022 L (b * c)\u2046)", "start": [197, 1], "end": [208, 26], "kind": "commanddeclaration"}, {"full_name": "aux2", "code": "private theorem aux2 {a b c : A} :\n    \u2045L a, L (a * a)\u2046 + \u2045L a, L (b * b)\u2046 + \u2045L a, L (c * c)\u2046 +\n    \u2045L a, 2 \u2022 L (a * b)\u2046 + \u2045L a, 2 \u2022 L (c * a)\u2046 + \u2045L a, 2 \u2022 L (b * c)\u2046 +\n    (\u2045L b, L (a * a)\u2046 + \u2045L b, L (b * b)\u2046 + \u2045L b, L (c * c)\u2046 +\n    \u2045L b, 2 \u2022 L (a * b)\u2046 + \u2045L b, 2 \u2022 L (c * a)\u2046 + \u2045L b, 2 \u2022 L (b * c)\u2046) +\n    (\u2045L c, L (a * a)\u2046 + \u2045L c, L (b * b)\u2046 + \u2045L c, L (c * c)\u2046 +\n    \u2045L c, 2 \u2022 L (a * b)\u2046 + \u2045L c, 2 \u2022 L (c * a)\u2046 + \u2045L c, 2 \u2022 L (b * c)\u2046)\n    =\n    \u2045L a, L (b * b)\u2046 + \u2045L b, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046) +\n    (\u2045L a, L (c * c)\u2046 + \u2045L c, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (c * a)\u2046 + \u2045L c, L (c * a)\u2046)) +\n    (\u2045L b, L (c * c)\u2046 + \u2045L c, L (b * b)\u2046 + 2 \u2022 (\u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046)) +\n    (2 \u2022 \u2045L a, L (b * c)\u2046 + 2 \u2022 \u2045L b, L (c * a)\u2046 + 2 \u2022 \u2045L c, L (a * b)\u2046)", "start": [211, 1], "end": [226, 7], "kind": "commanddeclaration"}, {"full_name": "aux3", "code": "private theorem aux3 {a b c : A} :\n    \u2045L a, L (b * b)\u2046 + \u2045L b, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (a * b)\u2046 + \u2045L b, L (a * b)\u2046) +\n    (\u2045L a, L (c * c)\u2046 + \u2045L c, L (a * a)\u2046 + 2 \u2022 (\u2045L a, L (c * a)\u2046 + \u2045L c, L (c * a)\u2046)) +\n    (\u2045L b, L (c * c)\u2046 + \u2045L c, L (b * b)\u2046 + 2 \u2022 (\u2045L b, L (b * c)\u2046 + \u2045L c, L (b * c)\u2046)) +\n    (2 \u2022 \u2045L a, L (b * c)\u2046 + 2 \u2022 \u2045L b, L (c * a)\u2046 + 2 \u2022 \u2045L c, L (a * b)\u2046)\n    =\n    2 \u2022 \u2045L a, L (b * c)\u2046 + 2 \u2022 \u2045L b, L (c * a)\u2046 + 2 \u2022 \u2045L c, L (a * b)\u2046", "start": [228, 1], "end": [242, 7], "kind": "commanddeclaration"}, {"full_name": "two_nsmul_lie_lmul_lmul_add_add_eq_zero", "code": "theorem two_nsmul_lie_lmul_lmul_add_add_eq_zero (a b c : A) :\n    2 \u2022 (\u2045L a, L (b * c)\u2046 + \u2045L b, L (c * a)\u2046 + \u2045L c, L (a * b)\u2046) = 0", "start": [244, 1], "end": [250, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/Normed/Group/HomCompletion.lean", "imports": ["Mathlib/Analysis/Normed/Group/Hom.lean", "Mathlib/Analysis/Normed/Group/Completion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NormedAddGroupHom.completion", "code": "def NormedAddGroupHom.completion (f : NormedAddGroupHom G H) :\n    NormedAddGroupHom (Completion G) (Completion H) :=\n  .ofLipschitz (f.toAddMonoidHom.completion f.continuous) f.lipschitz.completion_map", "start": [61, 1], "end": [64, 85], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_def", "code": "theorem NormedAddGroupHom.completion_def (f : NormedAddGroupHom G H) (x : Completion G) :\n    f.completion x = Completion.map f x", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_coe_to_fun", "code": "@[simp]\ntheorem NormedAddGroupHom.completion_coe_to_fun (f : NormedAddGroupHom G H) :\n    (f.completion : Completion G \u2192 Completion H) = Completion.map f", "start": [72, 1], "end": [74, 75], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_coe", "code": "theorem NormedAddGroupHom.completion_coe (f : NormedAddGroupHom G H) (g : G) :\n    f.completion g = f g", "start": [78, 1], "end": [80, 43], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_coe'", "code": "@[simp]\ntheorem NormedAddGroupHom.completion_coe' (f : NormedAddGroupHom G H) (g : G) :\n    Completion.map f g = f g", "start": [83, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "normedAddGroupHomCompletionHom", "code": "@[simps]\ndef normedAddGroupHomCompletionHom :\n    NormedAddGroupHom G H \u2192+ NormedAddGroupHom (Completion G) (Completion H) where\n  toFun := NormedAddGroupHom.completion\n  map_zero' := toAddMonoidHom_injective AddMonoidHom.completion_zero\n  map_add' f g := toAddMonoidHom_injective <|\n    f.toAddMonoidHom.completion_add g.toAddMonoidHom f.continuous g.continuous", "start": [88, 1], "end": [95, 79], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_id", "code": "@[simp]\ntheorem NormedAddGroupHom.completion_id :\n    (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (Completion G)", "start": [99, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_comp", "code": "theorem NormedAddGroupHom.completion_comp (f : NormedAddGroupHom G H) (g : NormedAddGroupHom H K) :\n    g.completion.comp f.completion = (g.comp f).completion", "start": [107, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_neg", "code": "theorem NormedAddGroupHom.completion_neg (f : NormedAddGroupHom G H) :\n    (-f).completion = -f.completion", "start": [116, 1], "end": [118, 74], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_add", "code": "theorem NormedAddGroupHom.completion_add (f g : NormedAddGroupHom G H) :\n    (f + g).completion = f.completion + g.completion", "start": [121, 1], "end": [123, 45], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_sub", "code": "theorem NormedAddGroupHom.completion_sub (f g : NormedAddGroupHom G H) :\n    (f - g).completion = f.completion - g.completion", "start": [126, 1], "end": [128, 76], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.zero_completion", "code": "@[simp]\ntheorem NormedAddGroupHom.zero_completion : (0 : NormedAddGroupHom G H).completion = 0", "start": [131, 1], "end": [133, 42], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.toCompl", "code": "@[simps] def NormedAddCommGroup.toCompl : NormedAddGroupHom G (Completion G) where\n  toFun := (\u2191)\n  map_add' := Completion.toCompl.map_add\n  bound' := \u27e81, by simp [le_refl]\u27e9", "start": [136, 1], "end": [141, 35], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.norm_toCompl", "code": "theorem NormedAddCommGroup.norm_toCompl (x : G) : \u2016toCompl x\u2016 = \u2016x\u2016", "start": [146, 1], "end": [147, 24], "kind": "commanddeclaration"}, {"full_name": "NormedAddCommGroup.denseRange_toCompl", "code": "theorem NormedAddCommGroup.denseRange_toCompl : DenseRange (toCompl : G \u2192 Completion G)", "start": [150, 1], "end": [151, 37], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.completion_toCompl", "code": "@[simp]\ntheorem NormedAddGroupHom.completion_toCompl (f : NormedAddGroupHom G H) :\n    f.completion.comp toCompl = toCompl.comp f", "start": [154, 1], "end": [156, 65], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.norm_completion", "code": "@[simp]\ntheorem NormedAddGroupHom.norm_completion (f : NormedAddGroupHom G H) : \u2016f.completion\u2016 = \u2016f\u2016", "start": [159, 1], "end": [162, 41], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker_le_ker_completion", "code": "theorem NormedAddGroupHom.ker_le_ker_completion (f : NormedAddGroupHom G H) :\n    (toCompl.comp <| incl f.ker).range \u2264 f.completion.ker", "start": [165, 1], "end": [168, 42], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.ker_completion", "code": "theorem NormedAddGroupHom.ker_completion {f : NormedAddGroupHom G H} {C : \u211d}\n    (h : f.SurjectiveOnWith f.range C) :\n    (f.completion.ker : Set <| Completion G) = closure (toCompl.comp <| incl f.ker).range", "start": [171, 1], "end": [193, 66], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.extension", "code": "def NormedAddGroupHom.extension (f : NormedAddGroupHom G H) : NormedAddGroupHom (Completion G) H :=\n  .ofLipschitz (f.toAddMonoidHom.extension f.continuous) <|\n    let _ := MetricSpace.ofT0PseudoMetricSpace H\n    f.lipschitz.completion_extension", "start": [204, 1], "end": [209, 37], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.extension_def", "code": "theorem NormedAddGroupHom.extension_def (f : NormedAddGroupHom G H) (v : G) :\n    f.extension v = Completion.extension f v", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.extension_coe", "code": "@[simp]\ntheorem NormedAddGroupHom.extension_coe (f : NormedAddGroupHom G H) (v : G) : f.extension v = f v", "start": [217, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.extension_coe_to_fun", "code": "theorem NormedAddGroupHom.extension_coe_to_fun (f : NormedAddGroupHom G H) :\n    (f.extension : Completion G \u2192 H) = Completion.extension f", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "NormedAddGroupHom.extension_unique", "code": "theorem NormedAddGroupHom.extension_unique (f : NormedAddGroupHom G H)\n    {g : NormedAddGroupHom (Completion G) H} (hg : \u2200 v, f v = g v) : f.extension = g", "start": [227, 1], "end": [231, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Homology/Opposite.lean", "imports": ["Mathlib/CategoryTheory/Abelian/Opposite.lean", "Mathlib/Algebra/Homology/Additive.lean", "Mathlib/CategoryTheory/Abelian/Homology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "imageToKernel_op", "code": "theorem imageToKernel_op {X Y Z : V} (f : X \u27f6 Y) (g : Y \u27f6 Z) (w : f \u226b g = 0) :\n    imageToKernel g.op f.op (by rw [\u2190 op_comp, w, op_zero]) =\n      (imageSubobjectIso _ \u226a\u226b (imageOpOp _).symm).hom \u226b\n        (cokernel.desc f (factorThruImage g)\n              (by rw [\u2190 cancel_mono (image.\u03b9 g), Category.assoc, image.fac, w, zero_comp])).op \u226b\n          (kernelSubobjectIso _ \u226a\u226b kernelOpOp _).inv", "start": [39, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "imageToKernel_unop", "code": "theorem imageToKernel_unop {X Y Z : V\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) (w : f \u226b g = 0) :\n    imageToKernel g.unop f.unop (by rw [\u2190 unop_comp, w, unop_zero]) =\n      (imageSubobjectIso _ \u226a\u226b (imageUnopUnop _).symm).hom \u226b\n        (cokernel.desc f (factorThruImage g)\n              (by rw [\u2190 cancel_mono (image.\u03b9 g), Category.assoc, image.fac, w, zero_comp])).unop \u226b\n          (kernelSubobjectIso _ \u226a\u226b kernelUnopUnop _).inv", "start": [52, 1], "end": [62, 97], "kind": "commanddeclaration"}, {"full_name": "homologyOp", "code": "def homologyOp {X Y Z : V} (f : X \u27f6 Y) (g : Y \u27f6 Z) (w : f \u226b g = 0) :\n    homology g.op f.op (by rw [\u2190 op_comp, w, op_zero]) \u2245 Opposite.op (homology f g w) :=\n  cokernelIsoOfEq (imageToKernel_op _ _ w) \u226a\u226b cokernelEpiComp _ _ \u226a\u226b cokernelCompIsIso _ _ \u226a\u226b\n    cokernelOpOp _ \u226a\u226b (homologyIsoKernelDesc _ _ _ \u226a\u226b\n    kernelIsoOfEq (by ext; simp only [image.fac, cokernel.\u03c0_desc, cokernel.\u03c0_desc_assoc]) \u226a\u226b\n    kernelCompMono _ (image.\u03b9 g)).op", "start": [65, 1], "end": [72, 37], "kind": "commanddeclaration"}, {"full_name": "homologyUnop", "code": "def homologyUnop {X Y Z : V\u1d52\u1d56} (f : X \u27f6 Y) (g : Y \u27f6 Z) (w : f \u226b g = 0) :\n    homology g.unop f.unop (by rw [\u2190 unop_comp, w, unop_zero]) \u2245 Opposite.unop (homology f g w) :=\n  cokernelIsoOfEq (imageToKernel_unop _ _ w) \u226a\u226b cokernelEpiComp _ _ \u226a\u226b cokernelCompIsIso _ _ \u226a\u226b\n    cokernelUnopUnop _ \u226a\u226b (homologyIsoKernelDesc _ _ _ \u226a\u226b\n    kernelIsoOfEq (by ext; simp only [image.fac, cokernel.\u03c0_desc, cokernel.\u03c0_desc_assoc]) \u226a\u226b\n    kernelCompMono _ (image.\u03b9 g)).unop", "start": [75, 1], "end": [82, 39], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.op", "code": "@[simps]\nprotected def op (X : HomologicalComplex V c) : HomologicalComplex V\u1d52\u1d56 c.symm where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [\u2190 op_comp, X.d_comp_d, op_zero]", "start": [95, 1], "end": [101, 64], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opSymm", "code": "@[simps]\nprotected def opSymm (X : HomologicalComplex V c.symm) : HomologicalComplex V\u1d52\u1d56 c where\n  X i := op (X.X i)\n  d i j := (X.d j i).op\n  shape i j hij := by simp only; rw [X.shape j i hij, op_zero]\n  d_comp_d' _ _ _ _ _ := by rw [\u2190 op_comp, X.d_comp_d, op_zero]", "start": [104, 1], "end": [110, 64], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unop", "code": "@[simps]\nprotected def unop (X : HomologicalComplex V\u1d52\u1d56 c) : HomologicalComplex V c.symm where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [\u2190 unop_comp, X.d_comp_d, unop_zero]", "start": [113, 1], "end": [119, 68], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopSymm", "code": "@[simps]\nprotected def unopSymm (X : HomologicalComplex V\u1d52\u1d56 c.symm) : HomologicalComplex V c where\n  X i := unop (X.X i)\n  d i j := (X.d j i).unop\n  shape i j hij := by simp only; rw [X.shape j i hij, unop_zero]\n  d_comp_d' _ _ _ _ _ := by rw [\u2190 unop_comp, X.d_comp_d, unop_zero]", "start": [122, 1], "end": [128, 68], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opFunctor", "code": "@[simps]\ndef opFunctor : (HomologicalComplex V c)\u1d52\u1d56 \u2964 HomologicalComplex V\u1d52\u1d56 c.symm where\n  obj X := (unop X).op\n  map f :=\n    { f := fun i => (f.unop.f i).op\n      comm' := fun i j _ => by simp only [op_d, \u2190 op_comp, f.unop.comm] }", "start": [133, 1], "end": [139, 74], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opInverse", "code": "@[simps]\ndef opInverse : HomologicalComplex V\u1d52\u1d56 c.symm \u2964 (HomologicalComplex V c)\u1d52\u1d56 where\n  obj X := op X.unopSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).unop\n      comm' := fun i j _ => by simp only [unopSymm_d, \u2190 unop_comp, f.comm] }", "start": [142, 1], "end": [148, 77], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opUnitIso", "code": "def opUnitIso : \ud835\udfed (HomologicalComplex V c)\u1d52\u1d56 \u2245 opFunctor V c \u22d9 opInverse V c :=\n  NatIso.ofComponents\n    (fun X =>\n      (HomologicalComplex.Hom.isoOfComponents (fun i => Iso.refl _) fun i j _ => by\n            simp only [Iso.refl_hom, Category.id_comp, unopSymm_d, op_d, Quiver.Hom.unop_op,\n              Category.comp_id] :\n          (Opposite.unop X).op.unopSymm \u2245 unop X).op)\n    (by\n      intro X Y f\n      refine' Quiver.Hom.unop_inj _\n      ext x\n      simp only [Quiver.Hom.unop_op, Functor.id_map, Iso.op_hom, Functor.comp_map, unop_comp,\n        comp_f, Hom.isoOfComponents_hom_f]\n      erw [Category.id_comp, Category.comp_id (f.unop.f x)])", "start": [151, 1], "end": [165, 61], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opCounitIso", "code": "def opCounitIso : opInverse V c \u22d9 opFunctor V c \u2245 \ud835\udfed (HomologicalComplex V\u1d52\u1d56 c.symm) :=\n  NatIso.ofComponents\n    fun X => HomologicalComplex.Hom.isoOfComponents fun i => Iso.refl _", "start": [168, 1], "end": [171, 72], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opEquivalence", "code": "@[simps]\ndef opEquivalence : (HomologicalComplex V c)\u1d52\u1d56 \u224c HomologicalComplex V\u1d52\u1d56 c.symm where\n  functor := opFunctor V c\n  inverse := opInverse V c\n  unitIso := opUnitIso V c\n  counitIso := opCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _", "start": [174, 1], "end": [186, 29], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopFunctor", "code": "@[simps]\ndef unopFunctor : (HomologicalComplex V\u1d52\u1d56 c)\u1d52\u1d56 \u2964 HomologicalComplex V c.symm where\n  obj X := (unop X).unop\n  map f :=\n    { f := fun i => (f.unop.f i).unop\n      comm' := fun i j _ => by simp only [unop_d, \u2190 unop_comp, f.unop.comm] }", "start": [189, 1], "end": [195, 78], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopInverse", "code": "@[simps]\ndef unopInverse : HomologicalComplex V c.symm \u2964 (HomologicalComplex V\u1d52\u1d56 c)\u1d52\u1d56 where\n  obj X := op X.opSymm\n  map f := Quiver.Hom.op\n    { f := fun i => (f.f i).op\n      comm' := fun i j _ => by simp only [opSymm_d, \u2190 op_comp, f.comm] }", "start": [198, 1], "end": [204, 73], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopUnitIso", "code": "def unopUnitIso : \ud835\udfed (HomologicalComplex V\u1d52\u1d56 c)\u1d52\u1d56 \u2245 unopFunctor V c \u22d9 unopInverse V c :=\n  NatIso.ofComponents\n    (fun X =>\n      (HomologicalComplex.Hom.isoOfComponents (fun i => Iso.refl _) fun i j _ => by\n            simp only [Iso.refl_hom, Category.id_comp, unopSymm_d, op_d, Quiver.Hom.unop_op,\n              Category.comp_id] :\n          (Opposite.unop X).op.unopSymm \u2245 unop X).op)\n    (by\n      intro X Y f\n      refine' Quiver.Hom.unop_inj _\n      ext x\n      simp only [Quiver.Hom.unop_op, Functor.id_map, Iso.op_hom, Functor.comp_map, unop_comp,\n        comp_f, Hom.isoOfComponents_hom_f]\n      erw [Category.id_comp, Category.comp_id (f.unop.f x)])", "start": [207, 1], "end": [221, 61], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopCounitIso", "code": "def unopCounitIso : unopInverse V c \u22d9 unopFunctor V c \u2245 \ud835\udfed (HomologicalComplex V c.symm) :=\n  NatIso.ofComponents\n    fun X => HomologicalComplex.Hom.isoOfComponents fun i => Iso.refl _", "start": [224, 1], "end": [227, 72], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopEquivalence", "code": "@[simps]\ndef unopEquivalence : (HomologicalComplex V\u1d52\u1d56 c)\u1d52\u1d56 \u224c HomologicalComplex V c.symm where\n  functor := unopFunctor V c\n  inverse := unopInverse V c\n  unitIso := unopUnitIso V c\n  counitIso := unopCounitIso V c\n  functor_unitIso_comp X := by\n    ext\n    simp only [opUnitIso, opCounitIso, NatIso.ofComponents_hom_app, Iso.op_hom, comp_f,\n      opFunctor_map_f, Quiver.Hom.unop_op, Hom.isoOfComponents_hom_f]\n    exact Category.comp_id _", "start": [230, 1], "end": [242, 29], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.opFunctor_additive", "code": "instance opFunctor_additive : (@opFunctor \u03b9 V _ c _).Additive where", "start": [247, 1], "end": [247, 68], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.unopFunctor_additive", "code": "instance unopFunctor_additive : (@unopFunctor \u03b9 V _ c _).Additive where", "start": [250, 1], "end": [250, 72], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.homologyOpDef", "code": "def homologyOpDef : C.op.homology i \u2245\n    _root_.homology (C.dFrom i).op (C.dTo i).op (by rw [\u2190 op_comp, C.dTo_comp_dFrom i, op_zero]) :=\n  Iso.refl _", "start": [257, 1], "end": [260, 13], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.homologyOp", "code": "nonrec def homologyOp : C.op.homology i \u2245 Opposite.op (C.homology i) :=\n  homologyOpDef _ _ \u226a\u226b homologyOp _ _ _", "start": [263, 1], "end": [266, 40], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.homologyUnopDef", "code": "def homologyUnopDef (C : HomologicalComplex V\u1d52\u1d56 c) :\n    C.unop.homology i \u2245\n      _root_.homology (C.dFrom i).unop (C.dTo i).unop\n        (by rw [\u2190 unop_comp, C.dTo_comp_dFrom i, unop_zero]) :=\n  Iso.refl _", "start": [269, 1], "end": [274, 13], "kind": "commanddeclaration"}, {"full_name": "HomologicalComplex.homologyUnop", "code": "nonrec def homologyUnop (C : HomologicalComplex V\u1d52\u1d56 c) :\n    C.unop.homology i \u2245 Opposite.unop (C.homology i) :=\n  homologyUnopDef _ _ \u226a\u226b homologyUnop _ _ _", "start": [277, 1], "end": [281, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/GroupCohomology/Resolution.lean", "imports": ["Mathlib/CategoryTheory/Abelian/Ext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RepresentationTheory/Rep.lean", "Mathlib/AlgebraicTopology/ExtraDegeneracy.lean", "Mathlib/Algebra/Category/ModuleCat/Projective.lean"], "premises": [{"full_name": "GroupCohomology.Resolution.actionDiagonalSucc", "code": "def actionDiagonalSucc (G : Type u) [Group G] :\n    \u2200 n : \u2115, diagonal G (n + 1) \u2245 leftRegular G \u2297 Action.mk (Fin n \u2192 G) 1\n  | 0 =>\n    diagonalOneIsoLeftRegular G \u226a\u226b\n      (\u03c1_ _).symm \u226a\u226b tensorIso (Iso.refl _) (tensorUnitIso (Equiv.equivOfUnique PUnit _).toIso)\n  | n + 1 =>\n    diagonalSucc _ _ \u226a\u226b\n      tensorIso (Iso.refl _) (actionDiagonalSucc G n) \u226a\u226b\n        leftRegularTensorIso _ _ \u226a\u226b\n          tensorIso (Iso.refl _)\n            (mkIso (Equiv.piFinSuccAboveEquiv (fun _ => G) 0).symm.toIso fun _ => rfl)", "start": [91, 1], "end": [104, 87], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.actionDiagonalSucc_hom_apply", "code": "theorem actionDiagonalSucc_hom_apply {G : Type u} [Group G] {n : \u2115} (f : Fin (n + 1) \u2192 G) :\n    (actionDiagonalSucc G n).hom.hom f = (f 0, fun i => (f (Fin.castSucc i))\u207b\u00b9 * f i.succ)", "start": [108, 1], "end": [124, 43], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.actionDiagonalSucc_inv_apply", "code": "theorem actionDiagonalSucc_inv_apply {G : Type u} [Group G] {n : \u2115} (g : G) (f : Fin n \u2192 G) :\n    (actionDiagonalSucc G n).inv.hom (g, f) = (g \u2022 Fin.partialProd f : Fin (n + 1) \u2192 G)", "start": [128, 1], "end": [153, 10], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.diagonalSucc", "code": "def diagonalSucc (n : \u2115) :\n    diagonal k G (n + 1) \u2245 leftRegular k G \u2297 trivial k G ((Fin n \u2192 G) \u2192\u2080 k) :=\n  (linearization k G).mapIso (actionDiagonalSucc G n) \u226a\u226b\n    (asIso ((linearization k G).\u03bc (Action.leftRegular G) _)).symm \u226a\u226b\n      tensorIso (Iso.refl _) (linearizationTrivialIso k G (Fin n \u2192 G))", "start": [163, 1], "end": [171, 71], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.diagonalSucc_hom_single", "code": "theorem diagonalSucc_hom_single (f : G\u207f\u207a\u00b9) (a : k) :\n    (diagonalSucc k G n).hom.hom (single f a) =\n      single (f 0) 1 \u2297\u209c single (fun i => (f (Fin.castSucc i))\u207b\u00b9 * f i.succ) a", "start": [176, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.diagonalSucc_inv_single_single", "code": "theorem diagonalSucc_inv_single_single (g : G) (f : G\u207f) (a b : k) :\n    (diagonalSucc k G n).inv.hom (Finsupp.single g a \u2297\u209c Finsupp.single f b) =\n      single (g \u2022 partialProd f) (a * b)", "start": [200, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.diagonalSucc_inv_single_left", "code": "theorem diagonalSucc_inv_single_left (g : G) (f : G\u207f \u2192\u2080 k) (r : k) :\n    (diagonalSucc k G n).inv.hom (Finsupp.single g r \u2297\u209c f) =\n      Finsupp.lift (G\u207f\u207a\u00b9 \u2192\u2080 k) k G\u207f (fun f => single (g \u2022 partialProd f) r) f", "start": [221, 1], "end": [240, 33], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.diagonalSucc_inv_single_right", "code": "theorem diagonalSucc_inv_single_right (g : G \u2192\u2080 k) (f : G\u207f) (r : k) :\n    (diagonalSucc k G n).inv.hom (g \u2297\u209c Finsupp.single f r) =\n      Finsupp.lift _ k G (fun a => single (a \u2022 partialProd f) r) g", "start": [243, 1], "end": [261, 33], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.ofMulActionBasisAux", "code": "def ofMulActionBasisAux :\n    MonoidAlgebra k G \u2297[k] ((Fin n \u2192 G) \u2192\u2080 k) \u2243\u2097[MonoidAlgebra k G]\n      (ofMulAction k G (Fin (n + 1) \u2192 G)).asModule :=\n  { (Rep.equivalenceModuleMonoidAlgebra.1.mapIso (diagonalSucc k G n).symm).toLinearEquiv with\n    map_smul' := fun r x => by\n      erw [RingHom.id_apply, LinearEquiv.toFun_eq_coe, \u2190 LinearEquiv.map_smul]\n      congr 1\n\n      show _ = Representation.asAlgebraHom (tensorObj (Rep.leftRegular k G)\n        (Rep.trivial k G ((Fin n \u2192 G) \u2192\u2080 k))).\u03c1 r _\n      refine' x.induction_on _ (fun x y => _) fun y z hy hz => _\n      \u00b7 rw [smul_zero, map_zero]\n      \u00b7 rw [TensorProduct.smul_tmul', smul_eq_mul, \u2190ofMulAction_self_smul_eq_mul]\n        exact (smul_tprod_one_asModule (Representation.ofMulAction k G G) r x y).symm\n      \u00b7 rw [smul_add, hz, hy, map_add] }", "start": [270, 1], "end": [295, 41], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.ofMulActionBasis", "code": "def ofMulActionBasis :\n    Basis (Fin n \u2192 G) (MonoidAlgebra k G) (ofMulAction k G (Fin (n + 1) \u2192 G)).asModule :=\n  Basis.map\n    (Algebra.TensorProduct.basis (MonoidAlgebra k G)\n      (Finsupp.basisSingleOne : Basis (Fin n \u2192 G) k ((Fin n \u2192 G) \u2192\u2080 k)))\n    (ofMulActionBasisAux k G n)", "start": [298, 1], "end": [305, 32], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.ofMulAction_free", "code": "theorem ofMulAction_free :\n    Module.Free (MonoidAlgebra k G) (ofMulAction k G (Fin (n + 1) \u2192 G)).asModule", "start": [308, 1], "end": [310, 48], "kind": "commanddeclaration"}, {"full_name": "Rep.diagonalHomEquiv", "code": "noncomputable def diagonalHomEquiv :\n    (Rep.ofMulAction k G (Fin (n + 1) \u2192 G) \u27f6 A) \u2243\u2097[k] (Fin n \u2192 G) \u2192 A :=\n  Linear.homCongr k\n        ((diagonalSucc k G n).trans ((Representation.ofMulAction k G G).repOfTprodIso 1))\n        (Iso.refl _) \u226a\u226b\u2097\n      (Rep.MonoidalClosed.linearHomEquivComm _ _ _ \u226a\u226b\u2097 Rep.leftRegularHomEquiv _) \u226a\u226b\u2097\n    (Finsupp.llift A k k (Fin n \u2192 G)).symm", "start": [323, 1], "end": [331, 43], "kind": "commanddeclaration"}, {"full_name": "Rep.diagonalHomEquiv_apply", "code": "theorem diagonalHomEquiv_apply (f : Rep.ofMulAction k G (Fin (n + 1) \u2192 G) \u27f6 A) (x : Fin n \u2192 G) :\n    diagonalHomEquiv n A f x = f.hom (Finsupp.single (Fin.partialProd x) 1)", "start": [337, 1], "end": [351, 57], "kind": "commanddeclaration"}, {"full_name": "Rep.diagonalHomEquiv_symm_apply", "code": "theorem diagonalHomEquiv_symm_apply (f : (Fin n \u2192 G) \u2192 A) (x : Fin (n + 1) \u2192 G) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single x 1) =\n      A.\u03c1 (x 0) (f fun i : Fin n => (x (Fin.castSucc i))\u207b\u00b9 * x i.succ)", "start": [356, 1], "end": [392, 19], "kind": "commanddeclaration"}, {"full_name": "Rep.diagonalHomEquiv_symm_partialProd_succ", "code": "theorem diagonalHomEquiv_symm_partialProd_succ (f : (Fin n \u2192 G) \u2192 A) (g : Fin (n + 1) \u2192 G)\n    (a : Fin (n + 1)) :\n    ((diagonalHomEquiv n A).symm f).hom (Finsupp.single (Fin.partialProd g \u2218 a.succ.succAbove) 1)\n      = f (Fin.contractNth a (\u00b7 * \u00b7) g)", "start": [396, 1], "end": [408, 70], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover", "code": "def classifyingSpaceUniversalCover [Monoid G] : SimplicialObject (Action (Type u) <| MonCat.of G)\n    where\n  obj n := Action.ofMulAction G (Fin (n.unop.len + 1) \u2192 G)\n  map f :=\n    { hom := fun x => x \u2218 f.unop.toOrderHom\n      comm := fun _ => rfl }\n  map_id _ := rfl\n  map_comp _ _ := rfl", "start": [416, 1], "end": [424, 22], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.cechNerveTerminalFromIso", "code": "def cechNerveTerminalFromIso :\n    cechNerveTerminalFrom (Action.ofMulAction G G) \u2245 classifyingSpaceUniversalCover G :=\n  NatIso.ofComponents (fun n => limit.isoLimitCone (Action.ofMulActionLimitCone _ _)) fun f => by\n    refine' IsLimit.hom_ext (Action.ofMulActionLimitCone.{u, 0} G fun _ => G).2 fun j => _\n    dsimp only [cechNerveTerminalFrom, Pi.lift]\n    rw [Category.assoc, limit.isoLimitCone_hom_\u03c0, limit.lift_\u03c0, Category.assoc]\n    exact (limit.isoLimitCone_hom_\u03c0 _ _).symm", "start": [433, 1], "end": [441, 46], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.cechNerveTerminalFromIsoCompForget", "code": "def cechNerveTerminalFromIsoCompForget :\n    cechNerveTerminalFrom G \u2245 classifyingSpaceUniversalCover G \u22d9 forget _ :=\n  NatIso.ofComponents (fun _ => Types.productIso _) fun _ =>\n    Matrix.ext fun _ _ => Types.Limit.lift_\u03c0_apply _ _ _ _", "start": [444, 1], "end": [449, 59], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.compForgetAugmented", "code": "def compForgetAugmented : SimplicialObject.Augmented (Type u) :=\n  SimplicialObject.augment (classifyingSpaceUniversalCover G \u22d9 forget _) (terminal _)\n    (terminal.from _) fun _ _ _ => Subsingleton.elim _ _", "start": [456, 1], "end": [460, 57], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.extraDegeneracyAugmentedCechNerve", "code": "def extraDegeneracyAugmentedCechNerve :\n    ExtraDegeneracy (Arrow.mk <| terminal.from G).augmentedCechNerve :=\n  AugmentedCechNerve.extraDegeneracy (Arrow.mk <| terminal.from G)\n    \u27e8fun _ => (1 : G),\n      @Subsingleton.elim _ (@Unique.instSubsingleton _ (Limits.uniqueToTerminal _)) _ _\u27e9", "start": [463, 1], "end": [469, 89], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.extraDegeneracyCompForgetAugmented", "code": "def extraDegeneracyCompForgetAugmented : ExtraDegeneracy (compForgetAugmented G) := by\n  refine'\n    ExtraDegeneracy.ofIso (_ : (Arrow.mk <| terminal.from G).augmentedCechNerve \u2245 _)\n      (extraDegeneracyAugmentedCechNerve G)\n  exact\n    Comma.isoMk (CechNerveTerminalFrom.iso G \u226a\u226b cechNerveTerminalFromIsoCompForget G)\n      (Iso.refl _) (by ext : 1; exact IsTerminal.hom_ext terminalIsTerminal _ _)", "start": [472, 1], "end": [480, 81], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.compForgetAugmented.toModule", "code": "def compForgetAugmented.toModule : SimplicialObject.Augmented (ModuleCat.{u} k) :=\n  ((SimplicialObject.Augmented.whiskering _ _).obj (ModuleCat.free k)).obj (compForgetAugmented G)", "start": [483, 1], "end": [487, 99], "kind": "commanddeclaration"}, {"full_name": "classifyingSpaceUniversalCover.extraDegeneracyCompForgetAugmentedToModule", "code": "def extraDegeneracyCompForgetAugmentedToModule :\n    ExtraDegeneracy (compForgetAugmented.toModule k G) :=\n  ExtraDegeneracy.map (extraDegeneracyCompForgetAugmented G) (ModuleCat.free k)", "start": [491, 1], "end": [497, 80], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.resolution", "code": "def GroupCohomology.resolution [Monoid G] :=\n  (AlgebraicTopology.alternatingFaceMapComplex (Rep k G)).obj\n    (classifyingSpaceUniversalCover G \u22d9 (Rep.linearization k G).1.1)", "start": [505, 1], "end": [509, 69], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.d", "code": "def d (G : Type u) (n : \u2115) : ((Fin (n + 1) \u2192 G) \u2192\u2080 k) \u2192\u2097[k] (Fin n \u2192 G) \u2192\u2080 k :=\n  Finsupp.lift ((Fin n \u2192 G) \u2192\u2080 k) k (Fin (n + 1) \u2192 G) fun g =>\n    (@Finset.univ (Fin (n + 1)) _).sum fun p =>\n      Finsupp.single (g \u2218 p.succAbove) ((-1 : k) ^ (p : \u2115))", "start": [518, 1], "end": [523, 60], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.d_of", "code": "@[simp]\ntheorem d_of {G : Type u} {n : \u2115} (c : Fin (n + 1) \u2192 G) :\n    d k G n (Finsupp.single c 1) =\n      Finset.univ.sum fun p : Fin (n + 1) =>\n        Finsupp.single (c \u2218 p.succAbove) ((-1 : k) ^ (p : \u2115))", "start": [528, 1], "end": [533, 14], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.xIso", "code": "def xIso (n : \u2115) : (GroupCohomology.resolution k G).X n \u2245 Rep.ofMulAction k G (Fin (n + 1) \u2192 G) :=\n  Iso.refl _", "start": [538, 1], "end": [541, 13], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.x_projective", "code": "theorem x_projective (G : Type u) [Group G] (n : \u2115) :\n    Projective ((GroupCohomology.resolution k G).X n)", "start": [545, 1], "end": [550, 33], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.d_eq", "code": "theorem d_eq (n : \u2115) : ((GroupCohomology.resolution k G).d (n + 1) n).hom = d k G (n + 1)", "start": [554, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.forget\u2082ToModuleCat", "code": "def forget\u2082ToModuleCat :=\n  ((forget\u2082 (Rep k G) (ModuleCat.{u} k)).mapHomologicalComplex _).obj\n    (GroupCohomology.resolution k G)", "start": [576, 1], "end": [579, 37], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.compForgetAugmentedIso", "code": "def compForgetAugmentedIso :\n    AlternatingFaceMapComplex.obj\n        (SimplicialObject.Augmented.drop.obj (compForgetAugmented.toModule k G)) \u2245\n      GroupCohomology.Resolution.forget\u2082ToModuleCat k G :=\n  eqToIso\n    (Functor.congr_obj (map_alternatingFaceMapComplex (forget\u2082 (Rep k G) (ModuleCat.{u} k))).symm\n      (classifyingSpaceUniversalCover G \u22d9 (Rep.linearization k G).1.1))", "start": [583, 1], "end": [593, 72], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.forget\u2082ToModuleCatHomotopyEquiv", "code": "def forget\u2082ToModuleCatHomotopyEquiv :\n    HomotopyEquiv (GroupCohomology.Resolution.forget\u2082ToModuleCat k G)\n      ((ChainComplex.single\u2080 (ModuleCat k)).obj ((forget\u2082 (Rep k G) _).obj <| Rep.trivial k G k)) :=\n  (HomotopyEquiv.ofIso (compForgetAugmentedIso k G).symm).trans <|\n    (SimplicialObject.Augmented.ExtraDegeneracy.homotopyEquiv\n          (extraDegeneracyCompForgetAugmentedToModule k G)).trans\n      (HomotopyEquiv.ofIso <|\n        (ChainComplex.single\u2080 (ModuleCat.{u} k)).mapIso\n          (@Finsupp.LinearEquiv.finsuppUnique k k _ _ _ (\u22a4_ Type u)\n              Types.terminalIso.toEquiv.unique).toModuleIso)", "start": [596, 1], "end": [607, 61], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.\u03b5", "code": "def \u03b5 : Rep.ofMulAction k G (Fin 1 \u2192 G) \u27f6 Rep.trivial k G k where\n  hom := Finsupp.total _ _ _ fun _ => (1 : k)\n  comm g := Finsupp.lhom_ext' fun _ => LinearMap.ext_ring (by\n    show\n      Finsupp.total (Fin 1 \u2192 G) k k (fun _ => (1 : k)) (Finsupp.mapDomain _ (Finsupp.single _ _)) =\n        Finsupp.total (Fin 1 \u2192 G) k k (fun _ => (1 : k)) (Finsupp.single _ _)\n    simp only [Finsupp.mapDomain_single, Finsupp.total_single])", "start": [611, 1], "end": [618, 64], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.forget\u2082ToModuleCatHomotopyEquiv_f_0_eq", "code": "theorem forget\u2082ToModuleCatHomotopyEquiv_f_0_eq :\n    (forget\u2082ToModuleCatHomotopyEquiv k G).1.f 0 = (forget\u2082 (Rep k G) _).map (\u03b5 k G)", "start": [621, 1], "end": [646, 94], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.d_comp_\u03b5", "code": "theorem d_comp_\u03b5 : (GroupCohomology.resolution k G).d 1 0 \u226b \u03b5 k G = 0", "start": [650, 1], "end": [658, 35], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.\u03b5ToSingle\u2080", "code": "def \u03b5ToSingle\u2080 :\n    GroupCohomology.resolution k G \u27f6 (ChainComplex.single\u2080 _).obj (Rep.trivial k G k) :=\n  ((GroupCohomology.resolution k G).toSingle\u2080Equiv _).symm \u27e8\u03b5 k G, d_comp_\u03b5 k G\u27e9", "start": [661, 1], "end": [665, 81], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.\u03b5ToSingle\u2080_comp_eq", "code": "theorem \u03b5ToSingle\u2080_comp_eq :\n    ((forget\u2082 _ (ModuleCat.{u} k)).mapHomologicalComplex _).map (\u03b5ToSingle\u2080 k G) \u226b\n        (ChainComplex.single\u2080MapHomologicalComplex _).hom.app _ =\n      (forget\u2082ToModuleCatHomotopyEquiv k G).hom", "start": [668, 1], "end": [675, 58], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.Resolution.quasiIsoOfForget\u2082\u03b5ToSingle\u2080", "code": "theorem quasiIsoOfForget\u2082\u03b5ToSingle\u2080 :\n    QuasiIso (((forget\u2082 _ (ModuleCat.{u} k)).mapHomologicalComplex _).map (\u03b5ToSingle\u2080 k G))", "start": [678, 1], "end": [683, 91], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.projectiveResolution", "code": "def GroupCohomology.projectiveResolution : ProjectiveResolution (Rep.trivial k G k) :=\n  toSingle\u2080ProjectiveResolution (\u03b5ToSingle\u2080 k G) (x_projective k G)", "start": [697, 1], "end": [699, 68], "kind": "commanddeclaration"}, {"full_name": "GroupCohomology.extIso", "code": "def GroupCohomology.extIso (V : Rep k G) (n : \u2115) :\n    ((Ext k (Rep k G) n).obj (Opposite.op <| Rep.trivial k G k)).obj V \u2245\n      (((((linearYoneda k (Rep k G)).obj V).rightOp.mapHomologicalComplex _).obj\n              (GroupCohomology.resolution k G)).homology\n          n).unop := (((linearYoneda k (Rep k G)).obj V).rightOp.leftDerivedObjIso n\n     (GroupCohomology.projectiveResolution k G)).unop.symm", "start": [707, 1], "end": [715, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RepresentationTheory/Invariants.lean", "imports": ["Mathlib/RepresentationTheory/Basic.lean", "Mathlib/RepresentationTheory/FdRep.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GroupAlgebra.average", "code": "noncomputable def average : MonoidAlgebra k G :=\n  \u215f (Fintype.card G : k) \u2022 \u2211 g : G, of k G g", "start": [37, 1], "end": [40, 45], "kind": "commanddeclaration"}, {"full_name": "GroupAlgebra.mul_average_left", "code": "@[simp]\ntheorem mul_average_left (g : G) : \u2191(Finsupp.single g 1) * average k G = average k G", "start": [43, 1], "end": [51, 65], "kind": "commanddeclaration"}, {"full_name": "GroupAlgebra.mul_average_right", "code": "@[simp]\ntheorem mul_average_right (g : G) : average k G * \u2191(Finsupp.single g 1) = average k G", "start": [54, 1], "end": [62, 66], "kind": "commanddeclaration"}, {"full_name": "Representation.invariants", "code": "def invariants : Submodule k V where\n  carrier := setOf fun v => \u2200 g : G, \u03c1 g v = v\n  zero_mem' g := by simp only [map_zero]\n  add_mem' hv hw g := by simp only [hv g, hw g, map_add]\n  smul_mem' r v hv g := by simp only [hv g, LinearMap.map_smul\u209b\u2097, RingHom.id_apply]", "start": [77, 1], "end": [83, 84], "kind": "commanddeclaration"}, {"full_name": "Representation.mem_invariants", "code": "@[simp]\ntheorem mem_invariants (v : V) : v \u2208 invariants \u03c1 \u2194 \u2200 g : G, \u03c1 g v = v", "start": [86, 1], "end": [87, 81], "kind": "commanddeclaration"}, {"full_name": "Representation.invariants_eq_inter", "code": "theorem invariants_eq_inter : (invariants \u03c1).carrier = \u22c2 g : G, Function.fixedPoints (\u03c1 g)", "start": [90, 1], "end": [91, 33], "kind": "commanddeclaration"}, {"full_name": "Representation.averageMap", "code": "@[simp]\nnoncomputable def averageMap : V \u2192\u2097[k] V :=\n  asAlgebraHom \u03c1 (average k G)", "start": [96, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "Representation.averageMap_invariant", "code": "theorem averageMap_invariant (v : V) : averageMap \u03c1 v \u2208 invariants \u03c1", "start": [103, 1], "end": [107, 22], "kind": "commanddeclaration"}, {"full_name": "Representation.averageMap_id", "code": "theorem averageMap_id (v : V) (hv : v \u2208 invariants \u03c1) : averageMap \u03c1 v = v", "start": [110, 1], "end": [114, 85], "kind": "commanddeclaration"}, {"full_name": "Representation.isProj_averageMap", "code": "theorem isProj_averageMap : LinearMap.IsProj \u03c1.invariants \u03c1.averageMap", "start": [117, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "Representation.linHom.mem_invariants_iff_comm", "code": "theorem mem_invariants_iff_comm {X Y : Rep k G} (f : X.V \u2192\u2097[k] Y.V) (g : G) :\n    (linHom X.\u03c1 Y.\u03c1) g f = f \u2194 f.comp (X.\u03c1 g) = (Y.\u03c1 g).comp f", "start": [133, 1], "end": [139, 13], "kind": "commanddeclaration"}, {"full_name": "Representation.linHom.invariantsEquivRepHom", "code": "@[simps]\ndef invariantsEquivRepHom (X Y : Rep k G) : (linHom X.\u03c1 Y.\u03c1).invariants \u2243\u2097[k] X \u27f6 Y where\n  toFun f := \u27e8f.val, fun g => (mem_invariants_iff_comm _ g).1 (f.property g)\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := \u27e8f.hom, fun g => (mem_invariants_iff_comm _ g).2 (f.comm g)\u27e9\n  left_inv _ := by apply Subtype.ext; ext; rfl right_inv _ := by ext; rfl", "start": [142, 1], "end": [151, 29], "kind": "commanddeclaration"}, {"full_name": "Representation.linHom.invariantsEquivFdRepHom", "code": "def invariantsEquivFdRepHom (X Y : FdRep k G) : (linHom X.\u03c1 Y.\u03c1).invariants \u2243\u2097[k] X \u27f6 Y := by\n  rw [\u2190 FdRep.forget\u2082_\u03c1, \u2190 FdRep.forget\u2082_\u03c1]\n  exact linHom.invariantsEquivRepHom\n    ((forget\u2082 (FdRep k G) (Rep k G)).obj X) ((forget\u2082 (FdRep k G) (Rep k G)).obj Y) \u226a\u226b\u2097\n    FdRep.forget\u2082HomLinearEquiv X Y", "start": [161, 1], "end": [168, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/UniqueProds.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "Mathlib/LinearAlgebra/Basis/VectorSpace.lean", "Mathlib/Data/DFinsupp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniqueMul", "code": "@[to_additive\n      \"Let `G` be a Type with addition, let `A B : Finset G` be finite subsets and\nlet `a0 b0 : G` be two elements.  `UniqueAdd A B a0 b0` asserts `a0 + b0` can be written in at\nmost one way as a sum of an element from `A` and an element from `B`.\"]\ndef UniqueMul {G} [Mul G] (A B : Finset G) (a0 b0 : G) : Prop :=\n  \u2200 \u2983a b\u2984, a \u2208 A \u2192 b \u2208 B \u2192 a * b = a0 * b0 \u2192 a = a0 \u2227 b = b0", "start": [50, 1], "end": [58, 61], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.of_subsingleton", "code": "@[to_additive (attr := nontriviality, simp)]\ntheorem of_subsingleton [Subsingleton G] : UniqueMul A B a0 b0", "start": [66, 1], "end": [67, 86], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.of_card_le_one", "code": "@[to_additive]\ntheorem of_card_le_one (hA : A.Nonempty) (hB : B.Nonempty) (hA1 : A.card \u2264 1) (hB1 : B.card \u2264 1) :\n    \u2203 a \u2208 A, \u2203 b \u2208 B, UniqueMul A B a b", "start": [69, 1], "end": [74, 69], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.mt", "code": "@[to_additive]\ntheorem mt (h : UniqueMul A B a0 b0) :\n    \u2200 \u2983a b\u2984, a \u2208 A \u2192 b \u2208 B \u2192 a \u2260 a0 \u2228 b \u2260 b0 \u2192 a * b \u2260 a0 * b0", "start": [76, 1], "end": [80, 18], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.subsingleton", "code": "@[to_additive]\ntheorem subsingleton (h : UniqueMul A B a0 b0) :\n    Subsingleton { ab : G \u00d7 G // ab.1 \u2208 A \u2227 ab.2 \u2208 B \u2227 ab.1 * ab.2 = a0 * b0 }", "start": [83, 1], "end": [89, 53], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.set_subsingleton", "code": "@[to_additive]\ntheorem set_subsingleton (h : UniqueMul A B a0 b0) :\n    Set.Subsingleton { ab : G \u00d7 G | ab.1 \u2208 A \u2227 ab.2 \u2208 B \u2227 ab.1 * ab.2 = a0 * b0 }", "start": [93, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.iff_existsUnique", "code": "@[to_additive]\ntheorem iff_existsUnique (aA : a0 \u2208 A) (bB : b0 \u2208 B) :\n    UniqueMul A B a0 b0 \u2194 \u2203! ab, ab \u2208 A \u00d7\u02e2 B \u2227 ab.1 * ab.2 = a0 * b0", "start": [106, 1], "end": [114, 79], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.iff_card_le_one", "code": "@[to_additive]\ntheorem iff_card_le_one [DecidableEq G] (ha0 : a0 \u2208 A) (hb0 : b0 \u2208 B) :\n    UniqueMul A B a0 b0 \u2194 ((A \u00d7\u02e2 B).filter (fun p \u21a6 p.1 * p.2 = a0 * b0)).card \u2264 1", "start": [119, 1], "end": [126, 79], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.exists_iff_exists_existsUnique", "code": "@[to_additive]\ntheorem exists_iff_exists_existsUnique :\n    (\u2203 a0 b0 : G, a0 \u2208 A \u2227 b0 \u2208 B \u2227 UniqueMul A B a0 b0) \u2194\n      \u2203 g : G, \u2203! ab, ab \u2208 A \u00d7\u02e2 B \u2227 ab.1 * ab.2 = g", "start": [130, 1], "end": [138, 58], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.mulHom_preimage", "code": "@[to_additive \"`UniqueAdd` is preserved by inverse images under injective, additive maps.\"]\ntheorem mulHom_preimage (f : G \u2192\u2099* H) (hf : Function.Injective f) (a0 b0 : G) {A B : Finset H}\n    (u : UniqueMul A B (f a0) (f b0)) :\n    UniqueMul (A.preimage f (Set.injOn_of_injective hf _))\n      (B.preimage f (Set.injOn_of_injective hf _)) a0 b0", "start": [142, 1], "end": [150, 69], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.mulHom_image_iff", "code": "@[to_additive\n      \"`UniqueAdd` is preserved under additive maps that are injective.\n\nSee `UniqueAdd.addHom_map_iff` for a version with swapped bundling.\"]\ntheorem mulHom_image_iff [DecidableEq H] (f : G \u2192\u2099* H) (hf : Function.Injective f) :\n    UniqueMul (A.image f) (B.image f) (f a0) (f b0) \u2194 UniqueMul A B a0 b0", "start": [154, 1], "end": [170, 21], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.mulHom_map_iff", "code": "@[to_additive\n      \"`UniqueAdd` is preserved under embeddings that are additive.\n\nSee `UniqueAdd.addHom_image_iff` for a version with swapped bundling.\"]\ntheorem mulHom_map_iff (f : G \u21aa H) (mul : \u2200 x y, f (x * y) = f x * f y) :\n    UniqueMul (A.map f) (B.map f) (f a0) (f b0) \u2194 UniqueMul A B a0 b0", "start": [174, 1], "end": [183, 80], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.of_mulOpposite", "code": "@[to_additive]\ntheorem of_mulOpposite\n    (h : UniqueMul (B.map \u27e8_, op_injective\u27e9) (A.map \u27e8_, op_injective\u27e9) (op b0) (op a0)) :\n    UniqueMul A B a0 b0", "start": [190, 1], "end": [194, 89], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.to_mulOpposite", "code": "@[to_additive]\ntheorem to_mulOpposite (h : UniqueMul A B a0 b0) :\n    UniqueMul (B.map \u27e8_, op_injective\u27e9) (A.map \u27e8_, op_injective\u27e9) (op b0) (op a0)", "start": [196, 1], "end": [199, 89], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.iff_mulOpposite", "code": "@[to_additive]\ntheorem iff_mulOpposite :\n    UniqueMul (B.map \u27e8_, op_injective\u27e9) (A.map \u27e8_, op_injective\u27e9) (op b0) (op a0) \u2194\n      UniqueMul A B a0 b0", "start": [201, 1], "end": [205, 33], "kind": "commanddeclaration"}, {"full_name": "UniqueMul.of_image_filter", "code": "@[to_additive]\ntheorem of_image_filter [DecidableEq H]\n    (f : G \u2192\u2099* H) {A B : Finset G} {aG bG : G} {aH bH : H} (hae : f aG = aH) (hbe : f bG = bH)\n    (huH : UniqueMul (A.image f) (B.image f) aH bH)\n    (huG : UniqueMul (A.filter (f \u00b7 = aH)) (B.filter (f \u00b7 = bH)) aG bG) :\n    UniqueMul A B aG bG", "start": [210, 1], "end": [219, 48], "kind": "commanddeclaration"}, {"full_name": "UniqueSums", "code": "class UniqueSums (G) [Add G] : Prop where\n\n  uniqueAdd_of_nonempty :\n    \u2200 {A B : Finset G}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueAdd A B a0 b0", "start": [223, 1], "end": [230, 90], "kind": "commanddeclaration"}, {"full_name": "UniqueProds", "code": "class UniqueProds (G) [Mul G] : Prop where\n\n  uniqueMul_of_nonempty :\n    \u2200 {A B : Finset G}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0", "start": [233, 1], "end": [240, 90], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueSums", "code": "class TwoUniqueSums (G) [Add G] : Prop where\n\n  uniqueAdd_of_one_lt_card : \u2200 {A B : Finset G}, 1 < A.card * B.card \u2192\n    \u2203 p1 \u2208 A \u00d7\u02e2 B, \u2203 p2 \u2208 A \u00d7\u02e2 B, p1 \u2260 p2 \u2227 UniqueAdd A B p1.1 p1.2 \u2227 UniqueAdd A B p2.1 p2.2", "start": [245, 1], "end": [252, 94], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds", "code": "class TwoUniqueProds (G) [Mul G] : Prop where\n\n  uniqueMul_of_one_lt_card : \u2200 {A B : Finset G}, 1 < A.card * B.card \u2192\n    \u2203 p1 \u2208 A \u00d7\u02e2 B, \u2203 p2 \u2208 A \u00d7\u02e2 B, p1 \u2260 p2 \u2227 UniqueMul A B p1.1 p1.2 \u2227 UniqueMul A B p2.1 p2.2", "start": [254, 1], "end": [261, 94], "kind": "commanddeclaration"}, {"full_name": "uniqueMul_of_twoUniqueMul", "code": "@[to_additive]\nlemma uniqueMul_of_twoUniqueMul {G} [Mul G] {A B : Finset G} (h : 1 < A.card * B.card \u2192\n    \u2203 p1 \u2208 A \u00d7\u02e2 B, \u2203 p2 \u2208 A \u00d7\u02e2 B, p1 \u2260 p2 \u2227 UniqueMul A B p1.1 p1.2 \u2227 UniqueMul A B p2.1 p2.2)\n    (hA : A.Nonempty) (hB : B.Nonempty) : \u2203 a \u2208 A, \u2203 b \u2208 B, UniqueMul A B a b := by\n  by_cases hc : A.card \u2264 1 \u2227 B.card \u2264 1\n  \u00b7 exact UniqueMul.of_card_le_one hA hB hc.1 hc.2\n  simp_rw [not_and_or, not_le] at hc\n  rw [\u2190 Finset.card_pos] at hA hB\n  obtain \u27e8p, hp, _, _, _, hu, _\u27e9 := h (Nat.one_lt_mul_iff.mpr \u27e8hA, hB, hc\u27e9)\n  rw [Finset.mem_product] at hp\n  exact \u27e8p.1, hp.1, p.2, hp.2, hu\u27e9", "start": [265, 1], "end": [275, 35], "kind": "mathlibtacticlemma"}, {"full_name": "TwoUniqueProds.toUniqueProds", "code": "@[to_additive] instance TwoUniqueProds.toUniqueProds (G) [Mul G] [TwoUniqueProds G] :\n    UniqueProds G where\n  uniqueMul_of_nonempty := uniqueMul_of_twoUniqueMul uniqueMul_of_one_lt_card", "start": [277, 1], "end": [279, 78], "kind": "commanddeclaration"}, {"full_name": "I", "code": "private abbrev I : Bool \u2192 Type max u v := Bool.rec (ULift.{v} G) (ULift.{u} H)", "start": [307, 1], "end": [307, 79], "kind": "commanddeclaration"}, {"full_name": "Prod.upMulHom", "code": "@[to_additive] private def Prod.upMulHom : G \u00d7 H \u2192\u2099* \u2200 b, I G H b :=\n  \u27e8fun x \u21a6 Bool.rec \u27e8x.1\u27e9 \u27e8x.2\u27e9, fun x y \u21a6 by ext (_|_) <;> rfl\u27e9", "start": [310, 1], "end": [311, 65], "kind": "commanddeclaration"}, {"full_name": "downMulHom", "code": "@[to_additive] private def downMulHom : ULift G \u2192\u2099* G := \u27e8ULift.down, fun _ _ \u21a6 rfl\u27e9", "start": [312, 1], "end": [312, 85], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.mulHom_image_of_injective", "code": "@[to_additive]\ntheorem mulHom_image_of_injective (f : H \u2192\u2099* G) (hf : Function.Injective f) (uG : UniqueProds G) :\n    UniqueProds H where", "start": [320, 1], "end": [328, 69], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.mulHom_image_iff", "code": "@[to_additive \"`UniqueSums` is preserved under additive equivalences.\"]\ntheorem mulHom_image_iff (f : G \u2243* H) :\n    UniqueProds G \u2194 UniqueProds H", "start": [330, 1], "end": [334, 93], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.of_mulOpposite", "code": "@[to_additive]\ntheorem of_mulOpposite (h : UniqueProds G\u1d50\u1d52\u1d56) : UniqueProds G where", "start": [337, 1], "end": [342, 81], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.toIsLeftCancelMul", "code": "@[to_additive] private theorem toIsLeftCancelMul [UniqueProds G] : IsLeftCancelMul G where", "start": [347, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.toIsCancelMul", "code": "@[to_additive] theorem toIsCancelMul [UniqueProds G] : IsCancelMul G where", "start": [359, 1], "end": [362, 80], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.of_same", "code": "@[to_additive] theorem of_same {G} [Semigroup G] [IsCancelMul G]\n    (h : \u2200 {A : Finset G}, A.Nonempty \u2192 \u2203 a1 \u2208 A, \u2203 a2 \u2208 A, UniqueMul A A a1 a2) :\n    UniqueProds G where", "start": [366, 1], "end": [382, 56], "kind": "commanddeclaration"}, {"full_name": "UniqueProds.toTwoUniqueProds_of_group", "code": "@[to_additive] theorem toTwoUniqueProds_of_group {G}\n    [Group G] [UniqueProds G] : TwoUniqueProds G where", "start": [384, 1], "end": [436, 92], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds.mulHom_image_of_injective", "code": "@[to_additive]\ntheorem mulHom_image_of_injective (f : H \u2192\u2099* G) (hf : Function.Injective f)\n    (uG : TwoUniqueProds G) : TwoUniqueProds H where", "start": [484, 1], "end": [497, 22], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds.mulHom_image_iff", "code": "@[to_additive \"`TwoUniqueSums` is preserved under additive equivalences.\"]\ntheorem mulHom_image_iff (f : G \u2243* H) : TwoUniqueProds G \u2194 TwoUniqueProds H", "start": [499, 1], "end": [502, 93], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds.of_mulOpposite", "code": "@[to_additive]\ntheorem of_mulOpposite (h : TwoUniqueProds G\u1d50\u1d52\u1d56) : TwoUniqueProds G where", "start": [543, 1], "end": [555, 36], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds.of_Covariant_right", "code": "@[to_additive\n  \"This instance asserts that if `G` has a right-cancellative addition, a linear order,\n  and addition is strictly monotone w.r.t. the second argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_Covariant_right [IsRightCancelMul G]\n    [LinearOrder G] [CovariantClass G G (\u00b7 * \u00b7) (\u00b7 < \u00b7)] :\n    TwoUniqueProds G where\n  uniqueMul_of_one_lt_card {A B} hc := by\n    obtain \u27e8hA, hB, -\u27e9 := Nat.one_lt_mul_iff.mp hc\n    rw [card_pos] at hA hB\n    rw [\u2190 card_product] at hc\n    obtain \u27e8a0, b0, ha0, hb0, he0\u27e9 := mem_mul.mp (max'_mem _ <| hA.mul hB)\n    obtain \u27e8a1, b1, ha1, hb1, he1\u27e9 := mem_mul.mp (min'_mem _ <| hA.mul hB)\n    have : UniqueMul A B a0 b0\n    \u00b7 intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b0\n      \u00b7 exact ((he0 \u25b8 he \u25b8 mul_lt_mul_left' hl a).not_le <| le_max' _ _ <| mul_mem_mul ha hb0).elim\n      \u00b7 exact \u27e8mul_right_cancel he, rfl\u27e9\n      \u00b7 exact ((he0 \u25b8 mul_lt_mul_left' hl a0).not_le <| le_max' _ _ <| mul_mem_mul ha0 hb).elim\n    refine \u27e8_, mk_mem_product ha0 hb0, _, mk_mem_product ha1 hb1, fun he \u21a6 ?_, this, ?_\u27e9\n    \u00b7 rw [Prod.mk.inj_iff] at he; rw [he.1, he.2, he1] at he0\n      obtain \u27e8\u27e8a2, b2\u27e9, h2, hne\u27e9 := exists_ne_of_one_lt_card hc (a0, b0)\n      rw [mem_product] at h2\n      refine (min'_lt_max' _ (mul_mem_mul ha0 hb0) (mul_mem_mul h2.1 h2.2) fun he \u21a6 hne ?_).ne he0\n      exact Prod.ext_iff.mpr (this h2.1 h2.2 he.symm)\n    \u00b7 intro a b ha hb he\n      obtain hl | rfl | hl := lt_trichotomy b b1\n      \u00b7 exact ((he1 \u25b8 mul_lt_mul_left' hl a1).not_le <| min'_le _ _ <| mul_mem_mul ha1 hb).elim\n      \u00b7 exact \u27e8mul_right_cancel he, rfl\u27e9\n      \u00b7 exact ((he1 \u25b8 he \u25b8 mul_lt_mul_left' hl a).not_le <| min'_le _ _ <| mul_mem_mul ha hb1).elim", "start": [561, 1], "end": [591, 100], "kind": "commanddeclaration"}, {"full_name": "TwoUniqueProds.of_Covariant_left", "code": "@[to_additive\n  \"This instance asserts that if `G` has a left-cancellative addition, a linear order, and\n  addition is strictly monotone w.r.t. the first argument, then `G` has `TwoUniqueSums`.\" ]\ninstance (priority := 100) of_Covariant_left [IsLeftCancelMul G]\n    [LinearOrder G] [CovariantClass G G (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] :\n    TwoUniqueProds G :=\n  let _ := LinearOrder.lift' (unop : G\u1d50\u1d52\u1d56 \u2192 G) unop_injective\n  let _ : CovariantClass G\u1d50\u1d52\u1d56 G\u1d50\u1d52\u1d56 (\u00b7 * \u00b7) (\u00b7 < \u00b7) :=\n  { elim := fun _ _ _ bc \u21a6 mul_lt_mul_right' (\u03b1 := G) bc (unop _) }\n  of_mulOpposite of_Covariant_right", "start": [595, 1], "end": [606, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Types/Coyoneda.lean", "imports": ["Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean", "Mathlib/CategoryTheory/Monoidal/Types/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.coyonedaTensorUnit", "code": "noncomputable\ndef coyonedaTensorUnit (C : Type u) [Category.{v} C] [MonoidalCategory C] :\n    LaxMonoidalFunctor C (Type v) :=\n  { coyoneda.obj (op (\ud835\udfd9_ C)) with\n    \u03b5 := fun _p => \ud835\udfd9 _\n    \u03bc := fun X Y p => (\u03bb_ (\ud835\udfd9_ C)).inv \u226b (p.1 \u2297 p.2)\n    \u03bc_natural := by aesop_cat\n    associativity := fun X Y Z => by\n      ext \u27e8\u27e8f, g\u27e9, h\u27e9; dsimp at f g h\n      dsimp; simp only [Iso.cancel_iso_inv_left, Category.assoc]\n      conv_lhs =>\n        rw [\u2190 Category.id_comp h, tensor_comp, Category.assoc, associator_naturality, \u2190\n          Category.assoc, unitors_inv_equal, triangle_assoc_comp_right_inv]\n      conv_rhs => rw [\u2190 Category.id_comp f, tensor_comp]\n    left_unitality := by aesop_cat\n    right_unitality := fun X => by\n      ext \u27e8f, \u27e8\u27e9\u27e9; dsimp at f\n      dsimp; simp only [Category.assoc]\n      rw [rightUnitor_naturality, unitors_inv_equal, Iso.inv_hom_id_assoc] }", "start": [36, 1], "end": [55, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monoidal/Center.lean", "imports": ["Mathlib/CategoryTheory/Functor/ReflectsIso.lean", "Mathlib/CategoryTheory/Monoidal/CoherenceLemmas.lean", "Mathlib/CategoryTheory/Monoidal/Braided.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.HalfBraiding", "code": "structure HalfBraiding (X : C) where\n  \u03b2 : \u2200 U, X \u2297 U \u2245 U \u2297 X\n  monoidal : \u2200 U U', (\u03b2 (U \u2297 U')).hom =\n      (\u03b1_ _ _ _).inv \u226b\n        ((\u03b2 U).hom \u2297 \ud835\udfd9 U') \u226b (\u03b1_ _ _ _).hom \u226b (\ud835\udfd9 U \u2297 (\u03b2 U').hom) \u226b (\u03b1_ _ _ _).inv := by\n    aesop_cat\n  naturality : \u2200 {U U'} (f : U \u27f6 U'), (\ud835\udfd9 X \u2297 f) \u226b (\u03b2 U').hom = (\u03b2 U).hom \u226b (f \u2297 \ud835\udfd9 X) := by\n    aesop_cat", "start": [47, 1], "end": [62, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center", "code": "def Center :=\n  \u03a3 X : C, HalfBraiding X", "start": [71, 1], "end": [76, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.Hom", "code": "@[ext] structure Hom (X Y : Center C) where\n  f : X.1 \u27f6 Y.1\n  comm : \u2200 U, (f \u2297 \ud835\udfd9 U) \u226b (Y.2.\u03b2 U).hom = (X.2.\u03b2 U).hom \u226b (\ud835\udfd9 U \u2297 f) := by aesop_cat", "start": [83, 1], "end": [87, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.ext", "code": "@[ext]\ntheorem ext {X Y : Center C} (f g : X \u27f6 Y) (w : f.f = g.f) : f = g", "start": [95, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.id_f", "code": "@[simp]\ntheorem id_f (X : Center C) : Hom.f (\ud835\udfd9 X) = \ud835\udfd9 X.1", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.comp_f", "code": "@[simp]\ntheorem comp_f {X Y Z : Center C} (f : X \u27f6 Y) (g : Y \u27f6 Z) : (f \u226b g).f = f.f \u226b g.f", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.isoMk", "code": "@[simps]\ndef isoMk {X Y : Center C} (f : X \u27f6 Y) [IsIso f.f] : X \u2245 Y where\n  hom := f\n  inv := \u27e8inv f.f,\n    fun U => by simp [\u2190 cancel_epi (f.f \u2297 \ud835\udfd9 U), \u2190 comp_tensor_id_assoc, \u2190 id_tensor_comp]\u27e9", "start": [114, 1], "end": [121, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.isIso_of_f_isIso", "code": "instance isIso_of_f_isIso {X Y : Center C} (f : X \u27f6 Y) [IsIso f.f] : IsIso f := by\n  change IsIso (isoMk f).hom\n  infer_instance", "start": [124, 1], "end": [126, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensorObj", "code": "@[simps]\ndef tensorObj (X Y : Center C) : Center C :=\n  \u27e8X.1 \u2297 Y.1,\n    { \u03b2 := fun U =>\n        \u03b1_ _ _ _ \u226a\u226b\n          (Iso.refl X.1 \u2297 Y.2.\u03b2 U) \u226a\u226b (\u03b1_ _ _ _).symm \u226a\u226b (X.2.\u03b2 U \u2297 Iso.refl Y.1) \u226a\u226b \u03b1_ _ _ _\n      monoidal := fun U U' => by\n        dsimp\n        simp only [comp_tensor_id, id_tensor_comp, Category.assoc, HalfBraiding.monoidal]\n        slice_rhs 6 8 => rw [pentagon]\n        slice_rhs 5 6 => rw [associator_naturality]\n        slice_rhs 7 8 => rw [\u2190 associator_naturality]\n        slice_rhs 6 7 =>\n          rw [tensor_id, tensor_id, tensor_id_comp_id_tensor, \u2190 id_tensor_comp_tensor_id,\n            \u2190 tensor_id, \u2190 tensor_id]\n        slice_rhs 10 10 => rw [associator_inv_conjugation]\n        slice_rhs 7 7 => rw [associator_inv_conjugation]\n        slice_rhs 6 6 => rw [associator_conjugation]\n        slice_rhs 3 3 => rw [associator_conjugation]\n        coherence\n      naturality := fun f => by\n        dsimp\n        rw [Category.assoc, Category.assoc, Category.assoc, Category.assoc,\n          id_tensor_associator_naturality_assoc, \u2190 id_tensor_comp_assoc, HalfBraiding.naturality,\n          id_tensor_comp_assoc, associator_inv_naturality_assoc, \u2190 comp_tensor_id_assoc,\n          HalfBraiding.naturality, comp_tensor_id_assoc, associator_naturality, \u2190 tensor_id] }\u27e9", "start": [129, 1], "end": [160, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensorHom", "code": "@[simps]\ndef tensorHom {X\u2081 Y\u2081 X\u2082 Y\u2082 : Center C} (f : X\u2081 \u27f6 Y\u2081) (g : X\u2082 \u27f6 Y\u2082) :\n    tensorObj X\u2081 X\u2082 \u27f6 tensorObj Y\u2081 Y\u2082 where\n  f := f.f \u2297 g.f\n  comm U := by\n    dsimp\n    rw [Category.assoc, Category.assoc, Category.assoc, Category.assoc, associator_naturality_assoc,\n      \u2190 tensor_id_comp_id_tensor, Category.assoc, \u2190 id_tensor_comp_assoc, g.comm,\n      id_tensor_comp_assoc, tensor_id_comp_id_tensor_assoc, \u2190 id_tensor_comp_tensor_id,\n      Category.assoc, associator_inv_naturality_assoc, id_tensor_associator_inv_naturality_assoc,\n      tensor_id, id_tensor_comp_tensor_id_assoc, \u2190 tensor_id_comp_id_tensor g.f, Category.assoc,\n      \u2190 comp_tensor_id_assoc, f.comm, comp_tensor_id_assoc, id_tensor_associator_naturality,\n      associator_naturality_assoc, \u2190 id_tensor_comp, tensor_id_comp_id_tensor]", "start": [163, 1], "end": [176, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensorUnit", "code": "@[simps]\ndef tensorUnit : Center C :=\n  \u27e8\ud835\udfd9_ C,\n    { \u03b2 := fun U => \u03bb_ U \u226a\u226b (\u03c1_ U).symm\n      monoidal := fun U U' => by simp\n      naturality := fun f => by\n        dsimp\n        rw [leftUnitor_naturality_assoc, rightUnitor_inv_naturality, Category.assoc] }\u27e9", "start": [179, 1], "end": [187, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.associator", "code": "def associator (X Y Z : Center C) : tensorObj (tensorObj X Y) Z \u2245 tensorObj X (tensorObj Y Z) :=\n  isoMk\n    \u27e8(\u03b1_ X.1 Y.1 Z.1).hom, fun U => by\n      dsimp\n      simp only [comp_tensor_id, id_tensor_comp, \u2190 tensor_id, associator_conjugation]\n      coherence\u27e9", "start": [190, 1], "end": [196, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.leftUnitor", "code": "def leftUnitor (X : Center C) : tensorObj tensorUnit X \u2245 X :=\n  isoMk\n    \u27e8(\u03bb_ X.1).hom, fun U => by\n      dsimp\n      simp only [Category.comp_id, Category.assoc, tensor_inv_hom_id, comp_tensor_id,\n        tensor_id_comp_id_tensor, triangle_assoc_comp_right_inv]\n      rw [\u2190 leftUnitor_tensor, leftUnitor_naturality, leftUnitor_tensor'_assoc]\u27e9", "start": [199, 1], "end": [206, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.rightUnitor", "code": "def rightUnitor (X : Center C) : tensorObj X tensorUnit \u2245 X :=\n  isoMk\n    \u27e8(\u03c1_ X.1).hom, fun U => by\n      dsimp\n      simp only [tensor_id_comp_id_tensor_assoc, triangle_assoc, id_tensor_comp, Category.assoc]\n      rw [\u2190 tensor_id_comp_id_tensor_assoc (\u03c1_ U).inv, cancel_epi, \u2190 rightUnitor_tensor_inv_assoc,\n        \u2190 rightUnitor_inv_naturality_assoc]\n      simp\u27e9", "start": [209, 1], "end": [217, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensor_fst", "code": "@[simp]\ntheorem tensor_fst (X Y : Center C) : (X \u2297 Y).1 = X.1 \u2297 Y.1", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensor_\u03b2", "code": "@[simp]\ntheorem tensor_\u03b2 (X Y : Center C) (U : C) :\n    (X \u2297 Y).2.\u03b2 U =\n      \u03b1_ _ _ _ \u226a\u226b\n        (Iso.refl X.1 \u2297 Y.2.\u03b2 U) \u226a\u226b (\u03b1_ _ _ _).symm \u226a\u226b (X.2.\u03b2 U \u2297 Iso.refl Y.1) \u226a\u226b \u03b1_ _ _ _", "start": [243, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensor_f", "code": "@[simp]\ntheorem tensor_f {X\u2081 Y\u2081 X\u2082 Y\u2082 : Center C} (f : X\u2081 \u27f6 Y\u2081) (g : X\u2082 \u27f6 Y\u2082) : (f \u2297 g).f = f.f \u2297 g.f", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.tensorUnit_\u03b2", "code": "@[simp]\ntheorem tensorUnit_\u03b2 (U : C) : (\ud835\udfd9_ (Center C)).2.\u03b2 U = \u03bb_ U \u226a\u226b (\u03c1_ U).symm", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.associator_hom_f", "code": "@[simp]\ntheorem associator_hom_f (X Y Z : Center C) : Hom.f (\u03b1_ X Y Z).hom = (\u03b1_ X.1 Y.1 Z.1).hom", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.associator_inv_f", "code": "@[simp]\ntheorem associator_inv_f (X Y Z : Center C) : Hom.f (\u03b1_ X Y Z).inv = (\u03b1_ X.1 Y.1 Z.1).inv", "start": [266, 1], "end": [269, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.leftUnitor_hom_f", "code": "@[simp]\ntheorem leftUnitor_hom_f (X : Center C) : Hom.f (\u03bb_ X).hom = (\u03bb_ X.1).hom", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.leftUnitor_inv_f", "code": "@[simp]\ntheorem leftUnitor_inv_f (X : Center C) : Hom.f (\u03bb_ X).inv = (\u03bb_ X.1).inv", "start": [277, 1], "end": [280, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.rightUnitor_hom_f", "code": "@[simp]\ntheorem rightUnitor_hom_f (X : Center C) : Hom.f (\u03c1_ X).hom = (\u03c1_ X.1).hom", "start": [283, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.rightUnitor_inv_f", "code": "@[simp]\ntheorem rightUnitor_inv_f (X : Center C) : Hom.f (\u03c1_ X).inv = (\u03c1_ X.1).inv", "start": [288, 1], "end": [291, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.forget", "code": "@[simps]\ndef forget : MonoidalFunctor (Center C) C where\n  obj X := X.1\n  map f := f.f\n  \u03b5 := \ud835\udfd9 (\ud835\udfd9_ C)\n  \u03bc X Y := \ud835\udfd9 (X.1 \u2297 Y.1)", "start": [300, 1], "end": [306, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.braiding", "code": "@[simps!]\ndef braiding (X Y : Center C) : X \u2297 Y \u2245 Y \u2297 X :=\n  isoMk\n    \u27e8(X.2.\u03b2 Y.1).hom, fun U => by\n      dsimp\n      simp only [Category.assoc]\n      rw [\u2190 IsIso.inv_comp_eq, IsIso.Iso.inv_hom, \u2190 HalfBraiding.monoidal_assoc,\n        \u2190 HalfBraiding.naturality_assoc, HalfBraiding.monoidal]\n      simp\u27e9", "start": [314, 1], "end": [323, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.braidedCategoryCenter", "code": "instance braidedCategoryCenter : BraidedCategory (Center C) where\n  braiding := braiding\n  braiding_naturality f g := by\n    ext\n    dsimp\n    rw [\u2190 tensor_id_comp_id_tensor, Category.assoc, HalfBraiding.naturality, f.comm_assoc,\n      id_tensor_comp_tensor_id]", "start": [326, 1], "end": [332, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.ofBraidedObj", "code": "@[simps]\ndef ofBraidedObj (X : C) : Center C :=\n  \u27e8X, {\n      \u03b2 := fun Y => \u03b2_ X Y\n      monoidal := fun U U' => by\n        rw [Iso.eq_inv_comp, \u2190 Category.assoc, \u2190 Category.assoc, Iso.eq_comp_inv, Category.assoc,\n          Category.assoc]\n        exact hexagon_forward X U U' }\u27e9", "start": [342, 1], "end": [350, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Center.ofBraided", "code": "@[simps]\ndef ofBraided : MonoidalFunctor C (Center C) where\n  obj := ofBraidedObj\n  map f :=\n    { f\n      comm := fun U => braiding_naturality _ _ }\n  \u03b5 :=\n    { f := \ud835\udfd9 _\n      comm := fun U => by\n        dsimp\n        rw [tensor_id, Category.id_comp, tensor_id, Category.comp_id, \u2190 braiding_rightUnitor,\n          Category.assoc, Iso.hom_inv_id, Category.comp_id] }\n  \u03bc X Y :=\n    { f := \ud835\udfd9 _\n      comm := fun U => by\n        dsimp\n        rw [tensor_id, tensor_id, Category.id_comp, Category.comp_id, \u2190 Iso.inv_comp_eq,\n          \u2190 Category.assoc, \u2190 Category.assoc, \u2190 Iso.comp_inv_eq, Category.assoc, hexagon_reverse,\n          Category.assoc] }", "start": [355, 1], "end": [375, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Partial.lean", "imports": ["Mathlib/Data/PFun.lean", "Mathlib/Order/Filter/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.rmap", "code": "def rmap (r : Rel \u03b1 \u03b2) (l : Filter \u03b1) : Filter \u03b2 where\n  sets := { s | r.core s \u2208 l }\n  univ_sets := by simp\n  sets_of_superset hs st := mem_of_superset hs (Rel.core_mono _ st)\n  inter_sets hs ht := by\n    simp only [Set.mem_setOf_eq]\n    convert inter_mem hs ht\n    rw [\u2190Rel.core_inter]", "start": [56, 1], "end": [65, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.rmap_sets", "code": "theorem rmap_sets (r : Rel \u03b1 \u03b2) (l : Filter \u03b1) : (l.rmap r).sets = r.core \u207b\u00b9' l.sets", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_rmap", "code": "@[simp]\ntheorem mem_rmap (r : Rel \u03b1 \u03b2) (l : Filter \u03b1) (s : Set \u03b2) : s \u2208 l.rmap r \u2194 r.core s \u2208 l", "start": [72, 1], "end": [74, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.rmap_rmap", "code": "@[simp]\ntheorem rmap_rmap (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) (l : Filter \u03b1) :\n    rmap s (rmap r l) = rmap (r.comp s) l", "start": [77, 1], "end": [80, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.rmap_compose", "code": "@[simp]\ntheorem rmap_compose (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) : rmap s \u2218 rmap r = rmap (r.comp s)", "start": [83, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.RTendsto", "code": "def RTendsto (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :=\n  l\u2081.rmap r \u2264 l\u2082", "start": [88, 1], "end": [92, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.rtendsto_def", "code": "theorem rtendsto_def (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    RTendsto r l\u2081 l\u2082 \u2194 \u2200 s \u2208 l\u2082, r.core s \u2208 l\u2081", "start": [95, 1], "end": [97, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap", "code": "def rcomap (r : Rel \u03b1 \u03b2) (f : Filter \u03b2) : Filter \u03b1 where\n  sets := Rel.image (fun s t => r.core s \u2286 t) f.sets\n  univ_sets := \u27e8Set.univ, univ_mem, Set.subset_univ _\u27e9\n  sets_of_superset := fun \u27e8a', ha', ma'a\u27e9 ab => \u27e8a', ha', ma'a.trans ab\u27e9\n  inter_sets := fun \u27e8a', ha\u2081, ha\u2082\u27e9 \u27e8b', hb\u2081, hb\u2082\u27e9 =>\n    \u27e8a' \u2229 b', inter_mem ha\u2081 hb\u2081, (r.core_inter a' b').subset.trans (Set.inter_subset_inter ha\u2082 hb\u2082)\u27e9", "start": [100, 1], "end": [107, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap_sets", "code": "theorem rcomap_sets (r : Rel \u03b1 \u03b2) (f : Filter \u03b2) :\n    (rcomap r f).sets = Rel.image (fun s t => r.core s \u2286 t) f.sets", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap_rcomap", "code": "theorem rcomap_rcomap (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) (l : Filter \u03b3) :\n    rcomap r (rcomap s l) = rcomap (r.comp s) l", "start": [115, 1], "end": [122, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap_compose", "code": "@[simp]\ntheorem rcomap_compose (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) : rcomap r \u2218 rcomap s = rcomap (r.comp s)", "start": [125, 1], "end": [127, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.rtendsto_iff_le_rcomap", "code": "theorem rtendsto_iff_le_rcomap (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    RTendsto r l\u2081 l\u2082 \u2194 l\u2081 \u2264 l\u2082.rcomap r", "start": [130, 1], "end": [136, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap'", "code": "def rcomap' (r : Rel \u03b1 \u03b2) (f : Filter \u03b2) : Filter \u03b1 where\n  sets := Rel.image (fun s t => r.preimage s \u2286 t) f.sets\n  univ_sets := \u27e8Set.univ, univ_mem, Set.subset_univ _\u27e9\n  sets_of_superset := fun \u27e8a', ha', ma'a\u27e9 ab => \u27e8a', ha', ma'a.trans ab\u27e9\n  inter_sets := fun \u27e8a', ha\u2081, ha\u2082\u27e9 \u27e8b', hb\u2081, hb\u2082\u27e9 =>\n    \u27e8a' \u2229 b', inter_mem ha\u2081 hb\u2081,\n      (@Rel.preimage_inter _ _ r _ _).trans (Set.inter_subset_inter ha\u2082 hb\u2082)\u27e9", "start": [142, 1], "end": [150, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_rcomap'", "code": "@[simp]\ntheorem mem_rcomap' (r : Rel \u03b1 \u03b2) (l : Filter \u03b2) (s : Set \u03b1) :\n    s \u2208 l.rcomap' r \u2194 \u2203 t \u2208 l, r.preimage t \u2286 s", "start": [153, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap'_sets", "code": "theorem rcomap'_sets (r : Rel \u03b1 \u03b2) (f : Filter \u03b2) :\n    (rcomap' r f).sets = Rel.image (fun s t => r.preimage s \u2286 t) f.sets", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap'_rcomap'", "code": "@[simp]\ntheorem rcomap'_rcomap' (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) (l : Filter \u03b3) :\n    rcomap' r (rcomap' s l) = rcomap' (r.comp s) l", "start": [164, 1], "end": [173, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.rcomap'_compose", "code": "@[simp]\ntheorem rcomap'_compose (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) : rcomap' r \u2218 rcomap' s = rcomap' (r.comp s)", "start": [176, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.RTendsto'", "code": "def RTendsto' (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :=\n  l\u2081 \u2264 l\u2082.rcomap' r", "start": [181, 1], "end": [185, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.rtendsto'_def", "code": "theorem rtendsto'_def (r : Rel \u03b1 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    RTendsto' r l\u2081 l\u2082 \u2194 \u2200 s \u2208 l\u2082, r.preimage s \u2208 l\u2081", "start": [188, 1], "end": [192, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_rtendsto", "code": "theorem tendsto_iff_rtendsto (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 RTendsto (Function.graph f) l\u2081 l\u2082", "start": [195, 1], "end": [197, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_rtendsto'", "code": "theorem tendsto_iff_rtendsto' (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 RTendsto' (Function.graph f) l\u2081 l\u2082", "start": [200, 1], "end": [202, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.pmap", "code": "def pmap (f : \u03b1 \u2192. \u03b2) (l : Filter \u03b1) : Filter \u03b2 :=\n  Filter.rmap f.graph' l", "start": [208, 1], "end": [211, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_pmap", "code": "@[simp]\ntheorem mem_pmap (f : \u03b1 \u2192. \u03b2) (l : Filter \u03b1) (s : Set \u03b2) : s \u2208 l.pmap f \u2194 f.core s \u2208 l", "start": [214, 1], "end": [216, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.PTendsto", "code": "def PTendsto (f : \u03b1 \u2192. \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :=\n  l\u2081.pmap f \u2264 l\u2082", "start": [219, 1], "end": [223, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.ptendsto_def", "code": "theorem ptendsto_def (f : \u03b1 \u2192. \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    PTendsto f l\u2081 l\u2082 \u2194 \u2200 s \u2208 l\u2082, f.core s \u2208 l\u2081", "start": [226, 1], "end": [228, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.ptendsto_iff_rtendsto", "code": "theorem ptendsto_iff_rtendsto (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192. \u03b2) :\n    PTendsto f l\u2081 l\u2082 \u2194 RTendsto f.graph' l\u2081 l\u2082", "start": [231, 1], "end": [233, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.pmap_res", "code": "theorem pmap_res (l : Filter \u03b1) (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    pmap (PFun.res f s) l = map f (l \u2293 \ud835\udcdf s)", "start": [236, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_ptendsto", "code": "theorem tendsto_iff_ptendsto (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f (l\u2081 \u2293 \ud835\udcdf s) l\u2082 \u2194 PTendsto (PFun.res f s) l\u2081 l\u2082", "start": [243, 1], "end": [245, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_ptendsto_univ", "code": "theorem tendsto_iff_ptendsto_univ (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 PTendsto (PFun.res f Set.univ) l\u2081 l\u2082", "start": [248, 1], "end": [251, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.pcomap'", "code": "def pcomap' (f : \u03b1 \u2192. \u03b2) (l : Filter \u03b2) : Filter \u03b1 :=\n  Filter.rcomap' f.graph' l", "start": [254, 1], "end": [257, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.PTendsto'", "code": "def PTendsto' (f : \u03b1 \u2192. \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :=\n  l\u2081 \u2264 l\u2082.rcomap' f.graph'", "start": [260, 1], "end": [264, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.ptendsto'_def", "code": "theorem ptendsto'_def (f : \u03b1 \u2192. \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    PTendsto' f l\u2081 l\u2082 \u2194 \u2200 s \u2208 l\u2082, f.preimage s \u2208 l\u2081", "start": [267, 1], "end": [269, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.ptendsto_of_ptendsto'", "code": "theorem ptendsto_of_ptendsto' {f : \u03b1 \u2192. \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    PTendsto' f l\u2081 l\u2082 \u2192 PTendsto f l\u2081 l\u2082", "start": [272, 1], "end": [275, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.ptendsto'_of_ptendsto", "code": "theorem ptendsto'_of_ptendsto {f : \u03b1 \u2192. \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (h : f.Dom \u2208 l\u2081) :\n    PTendsto f l\u2081 l\u2082 \u2192 PTendsto' f l\u2081 l\u2082", "start": [278, 1], "end": [283, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SemiconjSup.lean", "imports": ["Mathlib/Logic/Function/Conjugate.lean", "Mathlib/Order/OrdContinuous.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Bounds/OrderIso.lean", "Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "Mathlib/Order/RelIso/Group.lean"], "premises": [{"full_name": "IsOrderRightAdjoint", "code": "def IsOrderRightAdjoint [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :=\n  \u2200 y, IsLUB { x | f x \u2264 y } (g y)", "start": [41, 1], "end": [45, 35], "kind": "commanddeclaration"}, {"full_name": "isOrderRightAdjoint_sSup", "code": "theorem isOrderRightAdjoint_sSup [CompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y }", "start": [48, 1], "end": [49, 81], "kind": "commanddeclaration"}, {"full_name": "isOrderRightAdjoint_csSup", "code": "theorem isOrderRightAdjoint_csSup [ConditionallyCompleteLattice \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hne : \u2200 y, \u2203 x, f x \u2264 y) (hbdd : \u2200 y, BddAbove { x | f x \u2264 y }) :\n    IsOrderRightAdjoint f fun y => sSup { x | f x \u2264 y }", "start": [52, 1], "end": [54, 97], "kind": "commanddeclaration"}, {"full_name": "IsOrderRightAdjoint.unique", "code": "protected theorem unique [PartialOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b1}\n    (h\u2081 : IsOrderRightAdjoint f g\u2081) (h\u2082 : IsOrderRightAdjoint f g\u2082) : g\u2081 = g\u2082", "start": [59, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "IsOrderRightAdjoint.right_mono", "code": "theorem right_mono [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : IsOrderRightAdjoint f g) :\n    Monotone g", "start": [64, 1], "end": [65, 82], "kind": "commanddeclaration"}, {"full_name": "IsOrderRightAdjoint.orderIso_comp", "code": "theorem orderIso_comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : IsOrderRightAdjoint f g) (e : \u03b2 \u2243o \u03b3) : IsOrderRightAdjoint (e \u2218 f) (g \u2218 e.symm)", "start": [68, 1], "end": [70, 57], "kind": "commanddeclaration"}, {"full_name": "IsOrderRightAdjoint.comp_orderIso", "code": "theorem comp_orderIso [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : IsOrderRightAdjoint f g) (e : \u03b3 \u2243o \u03b1) : IsOrderRightAdjoint (f \u2218 e) (e.symm \u2218 g)", "start": [73, 1], "end": [78, 12], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.symm_adjoint", "code": "theorem Semiconj.symm_adjoint [PartialOrder \u03b1] [Preorder \u03b2] {fa : \u03b1 \u2243o \u03b1} {fb : \u03b2 \u21aao \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (h : Function.Semiconj g fa fb) {g' : \u03b2 \u2192 \u03b1} (hg' : IsOrderRightAdjoint g g') :\n    Function.Semiconj g' fb fa", "start": [85, 1], "end": [96, 63], "kind": "commanddeclaration"}, {"full_name": "Function.semiconj_of_isLUB", "code": "theorem semiconj_of_isLUB [PartialOrder \u03b1] [Group G] (f\u2081 f\u2082 : G \u2192* \u03b1 \u2243o \u03b1) {h : \u03b1 \u2192 \u03b1}\n    (H : \u2200 x, IsLUB (range fun g' => (f\u2081 g')\u207b\u00b9 (f\u2082 g' x)) (h x)) (g : G) :\n    Function.Semiconj h (f\u2082 g) (f\u2081 g)", "start": [101, 1], "end": [107, 29], "kind": "commanddeclaration"}, {"full_name": "Function.sSup_div_semiconj", "code": "theorem sSup_div_semiconj [CompleteLattice \u03b1] [Group G] (f\u2081 f\u2082 : G \u2192* \u03b1 \u2243o \u03b1) (g : G) :\n    Function.Semiconj (fun x => \u2a06 g' : G, (f\u2081 g')\u207b\u00b9 (f\u2082 g' x)) (f\u2082 g) (f\u2081 g)", "start": [110, 1], "end": [117, 50], "kind": "commanddeclaration"}, {"full_name": "Function.csSup_div_semiconj", "code": "theorem csSup_div_semiconj [ConditionallyCompleteLattice \u03b1] [Group G] (f\u2081 f\u2082 : G \u2192* \u03b1 \u2243o \u03b1)\n    (hbdd : \u2200 x, BddAbove (range fun g => (f\u2081 g)\u207b\u00b9 (f\u2082 g x))) (g : G) :\n    Function.Semiconj (fun x => \u2a06 g' : G, (f\u2081 g')\u207b\u00b9 (f\u2082 g' x)) (f\u2082 g) (f\u2081 g)", "start": [120, 1], "end": [129, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/AList.lean", "imports": ["Mathlib/Data/List/Sigma.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AList", "code": "structure AList (\u03b2 : \u03b1 \u2192 Type v) : Type max u v where\n  \n  entries : List (Sigma \u03b2)\n  \n  nodupKeys : entries.NodupKeys", "start": [44, 1], "end": [51, 32], "kind": "commanddeclaration"}, {"full_name": "List.toAList", "code": "def List.toAList [DecidableEq \u03b1] {\u03b2 : \u03b1 \u2192 Type v} (l : List (Sigma \u03b2)) : AList \u03b2 where\n  entries := _\n  nodupKeys := nodupKeys_dedupKeys l", "start": [54, 1], "end": [58, 37], "kind": "commanddeclaration"}, {"full_name": "AList.ext", "code": "@[ext]\ntheorem ext : \u2200 {s t : AList \u03b2}, s.entries = t.entries \u2192 s = t", "start": [63, 1], "end": [65, 37], "kind": "commanddeclaration"}, {"full_name": "AList.ext_iff", "code": "theorem ext_iff {s t : AList \u03b2} : s = t \u2194 s.entries = t.entries", "start": [68, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "AList.keys", "code": "def keys (s : AList \u03b2) : List \u03b1 :=\n  s.entries.keys", "start": [78, 1], "end": [80, 17], "kind": "commanddeclaration"}, {"full_name": "AList.keys_nodup", "code": "theorem keys_nodup (s : AList \u03b2) : s.keys.Nodup", "start": [83, 1], "end": [84, 14], "kind": "commanddeclaration"}, {"full_name": "AList.mem_keys", "code": "theorem mem_keys {a : \u03b1} {s : AList \u03b2} : a \u2208 s \u2194 a \u2208 s.keys", "start": [94, 1], "end": [95, 10], "kind": "commanddeclaration"}, {"full_name": "AList.mem_of_perm", "code": "theorem mem_of_perm {a : \u03b1} {s\u2081 s\u2082 : AList \u03b2} (p : s\u2081.entries ~ s\u2082.entries) : a \u2208 s\u2081 \u2194 a \u2208 s\u2082", "start": [98, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "AList.not_mem_empty", "code": "@[simp]\ntheorem not_mem_empty (a : \u03b1) : a \u2209 (\u2205 : AList \u03b2)", "start": [112, 1], "end": [114, 16], "kind": "commanddeclaration"}, {"full_name": "AList.empty_entries", "code": "@[simp]\ntheorem empty_entries : (\u2205 : AList \u03b2).entries = []", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "AList.keys_empty", "code": "@[simp]\ntheorem keys_empty : (\u2205 : AList \u03b2).keys = []", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "AList.singleton", "code": "def singleton (a : \u03b1) (b : \u03b2 a) : AList \u03b2 :=\n  \u27e8[\u27e8a, b\u27e9], nodupKeys_singleton _\u27e9", "start": [130, 1], "end": [132, 36], "kind": "commanddeclaration"}, {"full_name": "AList.singleton_entries", "code": "@[simp]\ntheorem singleton_entries (a : \u03b1) (b : \u03b2 a) : (singleton a b).entries = [Sigma.mk a b]", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "AList.keys_singleton", "code": "@[simp]\ntheorem keys_singleton (a : \u03b1) (b : \u03b2 a) : (singleton a b).keys = [a]", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "AList.lookup", "code": "def lookup (a : \u03b1) (s : AList \u03b2) : Option (\u03b2 a) :=\n  s.entries.dlookup a", "start": [152, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_empty", "code": "@[simp]\ntheorem lookup_empty (a) : lookup a (\u2205 : AList \u03b2) = none", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_isSome", "code": "theorem lookup_isSome {a : \u03b1} {s : AList \u03b2} : (s.lookup a).isSome \u2194 a \u2208 s", "start": [162, 1], "end": [163, 17], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_eq_none", "code": "theorem lookup_eq_none {a : \u03b1} {s : AList \u03b2} : lookup a s = none \u2194 a \u2209 s", "start": [166, 1], "end": [167, 18], "kind": "commanddeclaration"}, {"full_name": "AList.mem_lookup_iff", "code": "theorem mem_lookup_iff {a : \u03b1} {b : \u03b2 a} {s : AList \u03b2} :\n    b \u2208 lookup a s \u2194 Sigma.mk a b \u2208 s.entries", "start": [170, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "AList.perm_lookup", "code": "theorem perm_lookup {a : \u03b1} {s\u2081 s\u2082 : AList \u03b2} (p : s\u2081.entries ~ s\u2082.entries) :\n    s\u2081.lookup a = s\u2082.lookup a", "start": [175, 1], "end": [177, 45], "kind": "commanddeclaration"}, {"full_name": "AList.keys_subset_keys_of_entries_subset_entries", "code": "theorem keys_subset_keys_of_entries_subset_entries\n    {s\u2081 s\u2082 : AList \u03b2} (h : s\u2081.entries \u2286 s\u2082.entries) : s\u2081.keys \u2286 s\u2082.keys", "start": [183, 1], "end": [190, 27], "kind": "commanddeclaration"}, {"full_name": "AList.replace", "code": "def replace (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) : AList \u03b2 :=\n  \u27e8kreplace a b s.entries, (kreplace_nodupKeys a b).2 s.nodupKeys\u27e9", "start": [195, 1], "end": [198, 67], "kind": "commanddeclaration"}, {"full_name": "AList.keys_replace", "code": "@[simp]\ntheorem keys_replace (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) : (replace a b s).keys = s.keys", "start": [201, 1], "end": [203, 22], "kind": "commanddeclaration"}, {"full_name": "AList.mem_replace", "code": "@[simp]\ntheorem mem_replace {a a' : \u03b1} {b : \u03b2 a} {s : AList \u03b2} : a' \u2208 replace a b s \u2194 a' \u2208 s", "start": [206, 1], "end": [208, 42], "kind": "commanddeclaration"}, {"full_name": "AList.perm_replace", "code": "theorem perm_replace {a : \u03b1} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\n    s\u2081.entries ~ s\u2082.entries \u2192 (replace a b s\u2081).entries ~ (replace a b s\u2082).entries", "start": [211, 1], "end": [213, 29], "kind": "commanddeclaration"}, {"full_name": "AList.foldl", "code": "def foldl {\u03b4 : Type w} (f : \u03b4 \u2192 \u2200 a, \u03b2 a \u2192 \u03b4) (d : \u03b4) (m : AList \u03b2) : \u03b4 :=\n  m.entries.foldl (fun r a => f r a.1 a.2) d", "start": [218, 1], "end": [220, 45], "kind": "commanddeclaration"}, {"full_name": "AList.erase", "code": "def erase (a : \u03b1) (s : AList \u03b2) : AList \u03b2 :=\n  \u27e8s.entries.kerase a, s.nodupKeys.kerase a\u27e9", "start": [230, 1], "end": [232, 45], "kind": "commanddeclaration"}, {"full_name": "AList.keys_erase", "code": "@[simp]\ntheorem keys_erase (a : \u03b1) (s : AList \u03b2) : (erase a s).keys = s.keys.erase a", "start": [235, 1], "end": [237, 14], "kind": "commanddeclaration"}, {"full_name": "AList.mem_erase", "code": "@[simp]\ntheorem mem_erase {a a' : \u03b1} {s : AList \u03b2} : a' \u2208 erase a s \u2194 a' \u2260 a \u2227 a' \u2208 s", "start": [240, 1], "end": [242, 68], "kind": "commanddeclaration"}, {"full_name": "AList.perm_erase", "code": "theorem perm_erase {a : \u03b1} {s\u2081 s\u2082 : AList \u03b2} :\n    s\u2081.entries ~ s\u2082.entries \u2192 (erase a s\u2081).entries ~ (erase a s\u2082).entries", "start": [245, 1], "end": [247, 27], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_erase", "code": "@[simp]\ntheorem lookup_erase (a) (s : AList \u03b2) : lookup a (erase a s) = none", "start": [250, 1], "end": [252, 31], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_erase_ne", "code": "@[simp]\ntheorem lookup_erase_ne {a a'} {s : AList \u03b2} (h : a \u2260 a') : lookup a (erase a' s) = lookup a s", "start": [255, 1], "end": [257, 22], "kind": "commanddeclaration"}, {"full_name": "AList.erase_erase", "code": "theorem erase_erase (a a' : \u03b1) (s : AList \u03b2) : (s.erase a).erase a' = (s.erase a').erase a", "start": [260, 1], "end": [261, 23], "kind": "commanddeclaration"}, {"full_name": "AList.insert", "code": "def insert (a : \u03b1) (b : \u03b2 a) (s : AList \u03b2) : AList \u03b2 :=\n  \u27e8kinsert a b s.entries, kinsert_nodupKeys a b s.nodupKeys\u27e9", "start": [267, 1], "end": [270, 61], "kind": "commanddeclaration"}, {"full_name": "AList.insert_entries", "code": "@[simp]\ntheorem insert_entries {a} {b : \u03b2 a} {s : AList \u03b2} :\n    (insert a b s).entries = Sigma.mk a b :: kerase a s.entries", "start": [273, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "AList.insert_entries_of_neg", "code": "theorem insert_entries_of_neg {a} {b : \u03b2 a} {s : AList \u03b2} (h : a \u2209 s) :\n    (insert a b s).entries = \u27e8a, b\u27e9 :: s.entries", "start": [279, 1], "end": [280, 101], "kind": "commanddeclaration"}, {"full_name": "AList.insert_of_neg", "code": "theorem insert_of_neg {a} {b : \u03b2 a} {s : AList \u03b2} (h : a \u2209 s) :\n    insert a b s = \u27e8\u27e8a, b\u27e9 :: s.entries, nodupKeys_cons.2 \u27e8h, s.2\u27e9\u27e9", "start": [284, 1], "end": [286, 33], "kind": "commanddeclaration"}, {"full_name": "AList.insert_empty", "code": "@[simp]\ntheorem insert_empty (a) (b : \u03b2 a) : insert a b \u2205 = singleton a b", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "AList.mem_insert", "code": "@[simp]\ntheorem mem_insert {a a'} {b' : \u03b2 a'} (s : AList \u03b2) : a \u2208 insert a' b' s \u2194 a = a' \u2228 a \u2208 s", "start": [294, 1], "end": [296, 19], "kind": "commanddeclaration"}, {"full_name": "AList.keys_insert", "code": "@[simp]\ntheorem keys_insert {a} {b : \u03b2 a} (s : AList \u03b2) : (insert a b s).keys = a :: s.keys.erase a", "start": [299, 1], "end": [301, 35], "kind": "commanddeclaration"}, {"full_name": "AList.perm_insert", "code": "theorem perm_insert {a} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} (p : s\u2081.entries ~ s\u2082.entries) :\n    (insert a b s\u2081).entries ~ (insert a b s\u2082).entries", "start": [304, 1], "end": [306, 59], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_insert", "code": "@[simp]\ntheorem lookup_insert {a} {b : \u03b2 a} (s : AList \u03b2) : lookup a (insert a b s) = some b", "start": [309, 1], "end": [311, 46], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_insert_ne", "code": "@[simp]\ntheorem lookup_insert_ne {a a'} {b' : \u03b2 a'} {s : AList \u03b2} (h : a \u2260 a') :\n    lookup a (insert a' b' s) = lookup a s", "start": [314, 1], "end": [317, 23], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_to_alist", "code": "@[simp]\ntheorem lookup_to_alist {a} (s : List (Sigma \u03b2)) : lookup a s.toAList = s.dlookup a", "start": [320, 1], "end": [322, 47], "kind": "commanddeclaration"}, {"full_name": "AList.insert_insert", "code": "@[simp]\ntheorem insert_insert {a} {b b' : \u03b2 a} (s : AList \u03b2) :\n    (s.insert a b).insert a b' = s.insert a b'", "start": [325, 1], "end": [328, 65], "kind": "commanddeclaration"}, {"full_name": "AList.insert_insert_of_ne", "code": "theorem insert_insert_of_ne {a a'} {b : \u03b2 a} {b' : \u03b2 a'} (s : AList \u03b2) (h : a \u2260 a') :\n    ((s.insert a b).insert a' b').entries ~ ((s.insert a' b').insert a b).entries", "start": [331, 1], "end": [334, 45], "kind": "commanddeclaration"}, {"full_name": "AList.insert_singleton_eq", "code": "@[simp]\ntheorem insert_singleton_eq {a : \u03b1} {b b' : \u03b2 a} : insert a b (singleton a b') = singleton a b", "start": [337, 1], "end": [341, 36], "kind": "commanddeclaration"}, {"full_name": "AList.entries_toAList", "code": "@[simp]\ntheorem entries_toAList (xs : List (Sigma \u03b2)) : (List.toAList xs).entries = dedupKeys xs", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "AList.toAList_cons", "code": "theorem toAList_cons (a : \u03b1) (b : \u03b2 a) (xs : List (Sigma \u03b2)) :\n    List.toAList (\u27e8a, b\u27e9 :: xs) = insert a b xs.toAList", "start": [349, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "AList.mk_cons_eq_insert", "code": "theorem mk_cons_eq_insert (c : Sigma \u03b2) (l : List (Sigma \u03b2)) (h : (c :: l).NodupKeys) :\n    (\u27e8c :: l, h\u27e9 : AList \u03b2) = insert c.1 c.2 \u27e8l, nodupKeys_of_nodupKeys_cons h\u27e9", "start": [354, 1], "end": [356, 89], "kind": "commanddeclaration"}, {"full_name": "AList.insertRec", "code": "@[elab_as_elim]\ndef insertRec {C : AList \u03b2 \u2192 Sort*} (H0 : C \u2205)\n    (IH : \u2200 (a : \u03b1) (b : \u03b2 a) (l : AList \u03b2), a \u2209 l \u2192 C l \u2192 C (l.insert a b)) :\n    \u2200 l : AList \u03b2, C l\n  | \u27e8[], _\u27e9 => H0\n  | \u27e8c :: l, h\u27e9 => by\n    rw [mk_cons_eq_insert]\n    refine' IH _ _ _ _ (insertRec H0 IH _)\n    exact not_mem_keys_of_nodupKeys_cons h", "start": [359, 1], "end": [368, 43], "kind": "commanddeclaration"}, {"full_name": "AList.insertRec_empty", "code": "@[simp]\ntheorem insertRec_empty {C : AList \u03b2 \u2192 Sort*} (H0 : C \u2205)\n    (IH : \u2200 (a : \u03b1) (b : \u03b2 a) (l : AList \u03b2), a \u2209 l \u2192 C l \u2192 C (l.insert a b)) :\n    @insertRec \u03b1 \u03b2 _ C H0 IH \u2205 = H0", "start": [374, 1], "end": [379, 17], "kind": "commanddeclaration"}, {"full_name": "AList.insertRec_insert", "code": "theorem insertRec_insert {C : AList \u03b2 \u2192 Sort*} (H0 : C \u2205)\n    (IH : \u2200 (a : \u03b1) (b : \u03b2 a) (l : AList \u03b2), a \u2209 l \u2192 C l \u2192 C (l.insert a b)) {c : Sigma \u03b2}\n    {l : AList \u03b2} (h : c.1 \u2209 l) :\n    @insertRec \u03b1 \u03b2 _ C H0 IH (l.insert c.1 c.2) = IH c.1 c.2 l h (@insertRec \u03b1 \u03b2 _ C H0 IH l)", "start": [382, 1], "end": [393, 17], "kind": "commanddeclaration"}, {"full_name": "AList.insertRec_insert_mk", "code": "theorem insertRec_insert_mk {C : AList \u03b2 \u2192 Sort*} (H0 : C \u2205)\n    (IH : \u2200 (a : \u03b1) (b : \u03b2 a) (l : AList \u03b2), a \u2209 l \u2192 C l \u2192 C (l.insert a b)) {a : \u03b1} (b : \u03b2 a)\n    {l : AList \u03b2} (h : a \u2209 l) :\n    @insertRec \u03b1 \u03b2 _ C H0 IH (l.insert a b) = IH a b l h (@insertRec \u03b1 \u03b2 _ C H0 IH l)", "start": [396, 1], "end": [400, 45], "kind": "commanddeclaration"}, {"full_name": "AList.extract", "code": "def extract (a : \u03b1) (s : AList \u03b2) : Option (\u03b2 a) \u00d7 AList \u03b2 :=\n  have : (kextract a s.entries).2.NodupKeys := by\n    rw [kextract_eq_dlookup_kerase]; exact s.nodupKeys.kerase _\n  match kextract a s.entries, this with\n  | (b, l), h => (b, \u27e8l, h\u27e9)", "start": [406, 1], "end": [411, 29], "kind": "commanddeclaration"}, {"full_name": "AList.extract_eq_lookup_erase", "code": "@[simp]\ntheorem extract_eq_lookup_erase (a : \u03b1) (s : AList \u03b2) : extract a s = (lookup a s, erase a s)", "start": [414, 1], "end": [416, 38], "kind": "commanddeclaration"}, {"full_name": "AList.union", "code": "def union (s\u2081 s\u2082 : AList \u03b2) : AList \u03b2 :=\n  \u27e8s\u2081.entries.kunion s\u2082.entries, s\u2081.nodupKeys.kunion s\u2082.nodupKeys\u27e9", "start": [422, 1], "end": [426, 67], "kind": "commanddeclaration"}, {"full_name": "AList.union_entries", "code": "@[simp]\ntheorem union_entries {s\u2081 s\u2082 : AList \u03b2} : (s\u2081 \u222a s\u2082).entries = kunion s\u2081.entries s\u2082.entries", "start": [432, 1], "end": [434, 6], "kind": "commanddeclaration"}, {"full_name": "AList.empty_union", "code": "@[simp]\ntheorem empty_union {s : AList \u03b2} : (\u2205 : AList \u03b2) \u222a s = s", "start": [437, 1], "end": [439, 10], "kind": "commanddeclaration"}, {"full_name": "AList.union_empty", "code": "@[simp]\ntheorem union_empty {s : AList \u03b2} : s \u222a (\u2205 : AList \u03b2) = s", "start": [442, 1], "end": [444, 17], "kind": "commanddeclaration"}, {"full_name": "AList.mem_union", "code": "@[simp]\ntheorem mem_union {a} {s\u2081 s\u2082 : AList \u03b2} : a \u2208 s\u2081 \u222a s\u2082 \u2194 a \u2208 s\u2081 \u2228 a \u2208 s\u2082", "start": [447, 1], "end": [449, 18], "kind": "commanddeclaration"}, {"full_name": "AList.perm_union", "code": "theorem perm_union {s\u2081 s\u2082 s\u2083 s\u2084 : AList \u03b2} (p\u2081\u2082 : s\u2081.entries ~ s\u2082.entries)\n    (p\u2083\u2084 : s\u2083.entries ~ s\u2084.entries) : (s\u2081 \u222a s\u2083).entries ~ (s\u2082 \u222a s\u2084).entries", "start": [452, 1], "end": [454, 37], "kind": "commanddeclaration"}, {"full_name": "AList.union_erase", "code": "theorem union_erase (a : \u03b1) (s\u2081 s\u2082 : AList \u03b2) : erase a (s\u2081 \u222a s\u2082) = erase a s\u2081 \u222a erase a s\u2082", "start": [457, 1], "end": [458, 25], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_union_left", "code": "@[simp]\ntheorem lookup_union_left {a} {s\u2081 s\u2082 : AList \u03b2} : a \u2208 s\u2081 \u2192 lookup a (s\u2081 \u222a s\u2082) = lookup a s\u2081", "start": [461, 1], "end": [463, 22], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_union_right", "code": "@[simp]\ntheorem lookup_union_right {a} {s\u2081 s\u2082 : AList \u03b2} : a \u2209 s\u2081 \u2192 lookup a (s\u2081 \u222a s\u2082) = lookup a s\u2082", "start": [466, 1], "end": [468, 23], "kind": "commanddeclaration"}, {"full_name": "AList.mem_lookup_union", "code": "theorem mem_lookup_union {a} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\n    b \u2208 lookup a (s\u2081 \u222a s\u2082) \u2194 b \u2208 lookup a s\u2081 \u2228 a \u2209 s\u2081 \u2227 b \u2208 lookup a s\u2082", "start": [472, 1], "end": [474, 21], "kind": "commanddeclaration"}, {"full_name": "AList.lookup_union_eq_some", "code": "@[simp]\ntheorem lookup_union_eq_some {a} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\n    lookup a (s\u2081 \u222a s\u2082) = some b \u2194 lookup a s\u2081 = some b \u2228 a \u2209 s\u2081 \u2227 lookup a s\u2082 = some b", "start": [478, 1], "end": [481, 21], "kind": "commanddeclaration"}, {"full_name": "AList.mem_lookup_union_middle", "code": "theorem mem_lookup_union_middle {a} {b : \u03b2 a} {s\u2081 s\u2082 s\u2083 : AList \u03b2} :\n    b \u2208 lookup a (s\u2081 \u222a s\u2083) \u2192 a \u2209 s\u2082 \u2192 b \u2208 lookup a (s\u2081 \u222a s\u2082 \u222a s\u2083)", "start": [483, 1], "end": [485, 28], "kind": "commanddeclaration"}, {"full_name": "AList.insert_union", "code": "theorem insert_union {a} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} : insert a b (s\u2081 \u222a s\u2082) = insert a b s\u2081 \u222a s\u2082", "start": [488, 1], "end": [489, 15], "kind": "commanddeclaration"}, {"full_name": "AList.union_assoc", "code": "theorem union_assoc {s\u2081 s\u2082 s\u2083 : AList \u03b2} : (s\u2081 \u222a s\u2082 \u222a s\u2083).entries ~ (s\u2081 \u222a (s\u2082 \u222a s\u2083)).entries", "start": [492, 1], "end": [494, 57], "kind": "commanddeclaration"}, {"full_name": "AList.Disjoint", "code": "def Disjoint (s\u2081 s\u2082 : AList \u03b2) : Prop :=\n  \u2200 k \u2208 s\u2081.keys, \u00ack \u2208 s\u2082.keys", "start": [502, 1], "end": [504, 30], "kind": "commanddeclaration"}, {"full_name": "AList.union_comm_of_disjoint", "code": "theorem union_comm_of_disjoint {s\u2081 s\u2082 : AList \u03b2} (h : Disjoint s\u2081 s\u2082) :\n    (s\u2081 \u222a s\u2082).entries ~ (s\u2082 \u222a s\u2081).entries", "start": [509, 1], "end": [531, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Constructions.lean", "imports": ["Mathlib/Data/Finset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FiniteInter", "code": "structure FiniteInter : Prop where\n  \n  univ_mem : Set.univ \u2208 S\n  \n  inter_mem : \u2200 \u2983s\u2984, s \u2208 S \u2192 \u2200 \u2983t\u2984, t \u2208 S \u2192 s \u2229 t \u2208 S", "start": [29, 1], "end": [34, 54], "kind": "commanddeclaration"}, {"full_name": "FiniteInter.finiteInterClosure", "code": "inductive finiteInterClosure : Set (Set \u03b1)\n  | basic {s} : s \u2208 S \u2192 finiteInterClosure s\n  | univ : finiteInterClosure Set.univ\n  | inter {s t} : finiteInterClosure s \u2192 finiteInterClosure t \u2192 finiteInterClosure (s \u2229 t)", "start": [39, 1], "end": [43, 91], "kind": "commanddeclaration"}, {"full_name": "FiniteInter.finiteInterClosure_finiteInter", "code": "theorem finiteInterClosure_finiteInter : FiniteInter (finiteInterClosure S)", "start": [46, 1], "end": [48, 59], "kind": "commanddeclaration"}, {"full_name": "FiniteInter.finiteInter_mem", "code": "theorem finiteInter_mem (cond : FiniteInter S) (F : Finset (Set \u03b1)) :\n    \u2191F \u2286 S \u2192 \u22c2\u2080 (\u2191F : Set (Set \u03b1)) \u2208 S", "start": [53, 1], "end": [62, 61], "kind": "commanddeclaration"}, {"full_name": "FiniteInter.finiteInterClosure_insert", "code": "theorem finiteInterClosure_insert {A : Set \u03b1} (cond : FiniteInter S) (P)\n    (H : P \u2208 finiteInterClosure (insert A S)) : P \u2208 S \u2228 \u2203 Q \u2208 S, P = A \u2229 Q", "start": [65, 1], "end": [81, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Monad/Types.lean", "imports": ["Mathlib/Control/Basic.lean", "Mathlib/CategoryTheory/Monad/Basic.lean", "Mathlib/CategoryTheory/Category/KleisliCat.lean", "Mathlib/CategoryTheory/Monad/Kleisli.lean", "Mathlib/CategoryTheory/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.ofTypeMonad", "code": "@[simps!]\ndef ofTypeMonad : Monad (Type u) where\n  toFunctor := ofTypeFunctor m\n  \u03b7' := \u27e8@pure m _, fun \u03b1 \u03b2 f => funext fun x => (LawfulApplicative.map_pure f x).symm\u27e9\n  \u03bc' := \u27e8@joinM m _, fun \u03b1 \u03b2 (f : \u03b1 \u2192 \u03b2) => funext fun a => by apply joinM_map_map\u27e9\n  assoc' \u03b1 := funext fun a => by apply joinM_map_joinM\n  left_unit' \u03b1 := funext fun a => by apply joinM_pure\n  right_unit' \u03b1 := funext fun a => by apply joinM_map_pure", "start": [34, 1], "end": [43, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq", "code": "@[simps]\ndef eq : KleisliCat m \u224c Kleisli (ofTypeMonad m) where\n  functor :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun X => rfl\n      map_comp := fun f g => by\n        funext t\n        change _ = joinM (g <$> (f t))\n        simp only [joinM, seq_bind_eq, Function.comp.left_id]\n        rfl }\n  inverse :=\n    { obj := fun X => X\n      map := fun f => f\n      map_id := fun X => rfl\n      map_comp := fun f g => by\n        letI : _root_.Monad (ofTypeMonad m).obj :=\n          show _root_.Monad m from inferInstance\n        letI : LawfulMonad (ofTypeMonad m).obj :=\n          show LawfulMonad m from inferInstance\n        funext t\n        dsimp\n        change joinM (g <$> (f t)) = _\n        simp only [joinM, seq_bind_eq, Function.comp.left_id]\n        rfl }\n  unitIso := by\n    refine' NatIso.ofComponents (fun X => Iso.refl X) fun f => _\n    change f >=> pure = pure >=> f\n    simp [functor_norm]\n  counitIso := NatIso.ofComponents fun X => Iso.refl X", "start": [46, 1], "end": [84, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FreeAlgebra.lean", "imports": ["Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "Mathlib/LinearAlgebra/Dimension.lean", "Mathlib/LinearAlgebra/Basis.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/FreeModule/StrongRankCondition.lean", "Mathlib/Algebra/FreeAlgebra.lean"], "premises": [{"full_name": "FreeAlgebra.basisFreeMonoid", "code": "noncomputable def basisFreeMonoid : Basis (FreeMonoid X) R (FreeAlgebra R X) :=\n  Finsupp.basisSingleOne.map (equivMonoidAlgebraFreeMonoid (R := R) (X := X)).symm.toLinearEquiv", "start": [31, 1], "end": [35, 97], "kind": "commanddeclaration"}, {"full_name": "FreeAlgebra.rank_eq", "code": "theorem rank_eq [CommRing R] [Nontrivial R] :\n    Module.rank R (FreeAlgebra R X) = Cardinal.lift.{u} (Cardinal.mk (List X))", "start": [44, 1], "end": [47, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Deprecated/Subring.lean", "imports": ["Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Deprecated/Subgroup.lean", "Mathlib/Deprecated/Group.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSubring", "code": "structure IsSubring (S : Set R) extends IsAddSubgroup S, IsSubmonoid S : Prop", "start": [38, 1], "end": [40, 78], "kind": "commanddeclaration"}, {"full_name": "IsSubring.subring", "code": "def IsSubring.subring {S : Set R} (hs : IsSubring S) : Subring R where\n  carrier := S\n  one_mem' := hs.one_mem\n  mul_mem' := hs.mul_mem\n  zero_mem' := hs.zero_mem\n  add_mem' := hs.add_mem\n  neg_mem' := hs.neg_mem", "start": [43, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.isSubring_preimage", "code": "theorem isSubring_preimage {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) {s : Set S}\n    (hs : IsSubring s) : IsSubring (f \u207b\u00b9' s)", "start": [55, 1], "end": [58, 66], "kind": "commanddeclaration"}, {"full_name": "RingHom.isSubring_image", "code": "theorem isSubring_image {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) {s : Set R}\n    (hs : IsSubring s) : IsSubring (f '' s)", "start": [61, 1], "end": [64, 63], "kind": "commanddeclaration"}, {"full_name": "RingHom.isSubring_set_range", "code": "theorem isSubring_set_range {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) :\n    IsSubring (Set.range f)", "start": [67, 1], "end": [69, 98], "kind": "commanddeclaration"}, {"full_name": "IsSubring.inter", "code": "theorem IsSubring.inter {S\u2081 S\u2082 : Set R} (hS\u2081 : IsSubring S\u2081) (hS\u2082 : IsSubring S\u2082) :\n    IsSubring (S\u2081 \u2229 S\u2082)", "start": [76, 1], "end": [79, 65], "kind": "commanddeclaration"}, {"full_name": "IsSubring.iInter", "code": "theorem IsSubring.iInter {\u03b9 : Sort*} {S : \u03b9 \u2192 Set R} (h : \u2200 y : \u03b9, IsSubring (S y)) :\n    IsSubring (Set.iInter S)", "start": [82, 1], "end": [85, 58], "kind": "commanddeclaration"}, {"full_name": "isSubring_iUnion_of_directed", "code": "theorem isSubring_iUnion_of_directed {\u03b9 : Type*} [Nonempty \u03b9] {s : \u03b9 \u2192 Set R}\n    (h : \u2200 i, IsSubring (s i)) (directed : \u2200 i j, \u2203 k, s i \u2286 s k \u2227 s j \u2286 s k) :\n    IsSubring (\u22c3 i, s i)", "start": [88, 1], "end": [92, 93], "kind": "commanddeclaration"}, {"full_name": "Ring.closure", "code": "def closure (s : Set R) :=\n  AddGroup.closure (Monoid.Closure s)", "start": [97, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "Ring.exists_list_of_mem_closure", "code": "theorem exists_list_of_mem_closure {a : R} (h : a \u2208 closure s) :\n    \u2203 L : List (List R), (\u2200 l \u2208 L, \u2200 x \u2208 l, x \u2208 s \u2228 x = (-1 : R)) \u2227 (L.map List.prod).sum = a", "start": [107, 1], "end": [123, 94], "kind": "commanddeclaration"}, {"full_name": "Ring.InClosure.recOn", "code": "@[elab_as_elim]\nprotected theorem InClosure.recOn {C : R \u2192 Prop} {x : R} (hx : x \u2208 closure s) (h1 : C 1)\n    (hneg1 : C (-1)) (hs : \u2200 z \u2208 s, \u2200 n, C n \u2192 C (z * n)) (ha : \u2200 {x y}, C x \u2192 C y \u2192 C (x + y)) :\n    C x", "start": [126, 1], "end": [165, 84], "kind": "commanddeclaration"}, {"full_name": "Ring.closure.isSubring", "code": "theorem closure.isSubring : IsSubring (closure s)", "start": [168, 1], "end": [181, 84], "kind": "commanddeclaration"}, {"full_name": "Ring.mem_closure", "code": "theorem mem_closure {a : R} : a \u2208 s \u2192 a \u2208 closure s", "start": [184, 1], "end": [185, 56], "kind": "commanddeclaration"}, {"full_name": "Ring.subset_closure", "code": "theorem subset_closure : s \u2286 closure s", "start": [188, 1], "end": [189, 22], "kind": "commanddeclaration"}, {"full_name": "Ring.closure_subset", "code": "theorem closure_subset {t : Set R} (ht : IsSubring t) : s \u2286 t \u2192 closure s \u2286 t", "start": [192, 1], "end": [193, 86], "kind": "commanddeclaration"}, {"full_name": "Ring.closure_subset_iff", "code": "theorem closure_subset_iff {s t : Set R} (ht : IsSubring t) : closure s \u2286 t \u2194 s \u2286 t", "start": [196, 1], "end": [198, 85], "kind": "commanddeclaration"}, {"full_name": "Ring.closure_mono", "code": "theorem closure_mono {s t : Set R} (H : s \u2286 t) : closure s \u2286 closure t", "start": [201, 1], "end": [202, 72], "kind": "commanddeclaration"}, {"full_name": "Ring.image_closure", "code": "theorem image_closure {S : Type*} [Ring S] (f : R \u2192+* S) (s : Set R) :\n    f '' closure s = closure (f '' s)", "start": [205, 1], "end": [222, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/CharP.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "Mathlib/Algebra/CharP/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.charP", "code": "instance Matrix.charP [DecidableEq n] [Nonempty n] (p : \u2115) [CharP R p] : CharP (Matrix n n R) p :=\n  \u27e8by\n    intro k\n    rw [\u2190 CharP.cast_eq_zero_iff R p k, \u2190 Nat.cast_zero, \u2190 map_natCast <| scalar n]\n    convert @scalar_inj n _ _ _ _ _ (@Nat.cast R NonAssocSemiring.toNatCast k) 0\n    simp\u27e9", "start": [20, 1], "end": [25, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Transfer.lean", "imports": ["Mathlib/GroupTheory/Complement.lean", "Mathlib/GroupTheory/Sylow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.leftTransversals.diff", "code": "@[to_additive \"The difference of two left transversals\"]\nnoncomputable def diff : A :=\n  let \u03b1 := MemLeftTransversals.toEquiv S.2\n  let \u03b2 := MemLeftTransversals.toEquiv T.2\n  (@Finset.univ (G \u29f8 H) H.fintypeQuotientOfFiniteIndex).prod fun q =>\n    \u03d5\n      \u27e8(\u03b1 q : G)\u207b\u00b9 * \u03b2 q,\n        QuotientGroup.leftRel_apply.mp <|\n          Quotient.exact' ((\u03b1.symm_apply_apply q).trans (\u03b2.symm_apply_apply q).symm)\u27e9", "start": [44, 1], "end": [53, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftTransversals.diff_mul_diff", "code": "@[to_additive]\ntheorem diff_mul_diff : diff \u03d5 R S * diff \u03d5 S T = diff \u03d5 R T", "start": [57, 1], "end": [63, 84], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftTransversals.diff_self", "code": "@[to_additive]\ntheorem diff_self : diff \u03d5 T T = 1", "start": [67, 1], "end": [69, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftTransversals.diff_inv", "code": "@[to_additive]\ntheorem diff_inv : (diff \u03d5 S T)\u207b\u00b9 = diff \u03d5 T S", "start": [73, 1], "end": [75, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftTransversals.smul_diff_smul", "code": "@[to_additive]\ntheorem smul_diff_smul (g : G) : diff \u03d5 (g \u2022 S) (g \u2022 T) = diff \u03d5 S T", "start": [79, 1], "end": [89, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer", "code": "@[to_additive \"Given `\u03d5 : H \u2192+ A` from `H : AddSubgroup G` to an additive commutative group `A`,\nthe transfer homomorphism is `transfer \u03d5 : G \u2192+ A`.\"]\nnoncomputable def transfer [FiniteIndex H] : G \u2192* A :=\n  let T : leftTransversals (H : Set G) := Inhabited.default\n  { toFun := fun g => diff \u03d5 T (g \u2022 T)\n    map_one' := by simp only; rw [one_smul, diff_self] map_mul' := fun g h => by simp only; rw [mul_smul, \u2190 diff_mul_diff, smul_diff_smul] }", "start": [101, 1], "end": [109, 90], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer_def", "code": "@[to_additive]\ntheorem transfer_def [FiniteIndex H] (g : G) : transfer \u03d5 g = diff \u03d5 T (g \u2022 T)", "start": [115, 1], "end": [117, 84], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer_eq_prod_quotient_orbitRel_zpowers_quot", "code": "theorem transfer_eq_prod_quotient_orbitRel_zpowers_quot [FiniteIndex H] (g : G)\n    [Fintype (Quotient (orbitRel (zpowers g) (G \u29f8 H)))] :\n    transfer \u03d5 g =\n      \u220f q : Quotient (orbitRel (zpowers g) (G \u29f8 H)),\n        \u03d5\n          \u27e8q.out'.out'\u207b\u00b9 * g ^ Function.minimalPeriod ((\u00b7 \u2022 \u00b7) g) q.out' * q.out'.out',\n            QuotientGroup.out'_conj_pow_minimalPeriod_mem H g q.out'\u27e9", "start": [121, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer_eq_pow_aux", "code": "theorem transfer_eq_pow_aux (g : G)\n    (key : \u2200 (k : \u2115) (g\u2080 : G), g\u2080\u207b\u00b9 * g ^ k * g\u2080 \u2208 H \u2192 g\u2080\u207b\u00b9 * g ^ k * g\u2080 = g ^ k) :\n    g ^ H.index \u2208 H", "start": [146, 1], "end": [166, 94], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer_eq_pow", "code": "theorem transfer_eq_pow [FiniteIndex H] (g : G)\n    (key : \u2200 (k : \u2115) (g\u2080 : G), g\u2080\u207b\u00b9 * g ^ k * g\u2080 \u2208 H \u2192 g\u2080\u207b\u00b9 * g ^ k * g\u2080 = g ^ k) :\n    transfer \u03d5 g = \u03d5 \u27e8g ^ H.index, transfer_eq_pow_aux g key\u27e9", "start": [169, 1], "end": [185, 14], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transfer_center_eq_pow", "code": "theorem transfer_center_eq_pow [FiniteIndex (center G)] (g : G) :\n    transfer (MonoidHom.id (center G)) g = \u27e8g ^ (center G).index, (center G).pow_index_mem g\u27e9", "start": [188, 1], "end": [190, 100], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferCenterPow", "code": "noncomputable def transferCenterPow [FiniteIndex (center G)] : G \u2192* center G where\n  toFun g := \u27e8g ^ (center G).index, (center G).pow_index_mem g\u27e9\n  map_one' := Subtype.ext (one_pow (center G).index)\n  map_mul' a b := by simp_rw [\u2190 show \u2200 _, (_ : center G) = _ from transfer_center_eq_pow, map_mul]", "start": [195, 1], "end": [199, 99], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferCenterPow_apply", "code": "@[simp]\ntheorem transferCenterPow_apply [FiniteIndex (center G)] (g : G) :\n    \u2191(transferCenterPow G g) = g ^ (center G).index", "start": [204, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferSylow", "code": "noncomputable def transferSylow [FiniteIndex (P : Subgroup G)] : G \u2192* (P : Subgroup G) :=\n  @transfer G _ P P\n    (@Subgroup.IsCommutative.commGroup G _ P\n      \u27e8\u27e8fun a b => Subtype.ext (hP (le_normalizer b.2) a a.2)\u27e9\u27e9)\n    (MonoidHom.id P) _", "start": [214, 1], "end": [219, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferSylow_eq_pow_aux", "code": "theorem transferSylow_eq_pow_aux (g : G) (hg : g \u2208 P) (k : \u2115) (g\u2080 : G)\n    (h : g\u2080\u207b\u00b9 * g ^ k * g\u2080 \u2208 P) : g\u2080\u207b\u00b9 * g ^ k * g\u2080 = g ^ k", "start": [224, 1], "end": [231, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferSylow_eq_pow", "code": "theorem transferSylow_eq_pow (g : G) (hg : g \u2208 P) :\n    transferSylow P hP g =\n      \u27e8g ^ (P : Subgroup G).index, transfer_eq_pow_aux g (transferSylow_eq_pow_aux P hP g hg)\u27e9", "start": [236, 1], "end": [241, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.transferSylow_restrict_eq_pow", "code": "theorem transferSylow_restrict_eq_pow : \u21d1((transferSylow P hP).restrict (P : Subgroup G)) =\n    (fun x : P => x ^ (P : Subgroup G).index)", "start": [244, 1], "end": [246, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_transferSylow_isComplement'", "code": "theorem ker_transferSylow_isComplement' : IsComplement' (transferSylow P hP).ker P", "start": [249, 1], "end": [262, 77], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.not_dvd_card_ker_transferSylow", "code": "theorem not_dvd_card_ker_transferSylow : \u00acp \u2223 Nat.card (transferSylow P hP).ker", "start": [265, 1], "end": [267, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_transferSylow_disjoint", "code": "theorem ker_transferSylow_disjoint (Q : Subgroup G) (hQ : IsPGroup p Q) :\n    Disjoint (transferSylow P hP).ker Q", "start": [270, 1], "end": [275, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/BooleanRing.lean", "imports": ["Mathlib/Tactic/Abel.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Lattice.lean", "Mathlib/Algebra/PUnitInstances.lean", "Mathlib/Tactic/Ring.lean"], "premises": [{"full_name": "BooleanRing", "code": "class BooleanRing (\u03b1) extends Ring \u03b1 where\n  \n  mul_self : \u2200 a : \u03b1, a * a = a", "start": [46, 1], "end": [49, 32], "kind": "commanddeclaration"}, {"full_name": "mul_self", "code": "@[simp]\ntheorem mul_self : a * a = a", "start": [59, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "add_self", "code": "@[simp]\ntheorem add_self : a + a = 0", "start": [64, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "neg_eq", "code": "@[simp]\ntheorem neg_eq : -a = a", "start": [74, 1], "end": [79, 40], "kind": "commanddeclaration"}, {"full_name": "add_eq_zero'", "code": "theorem add_eq_zero' : a + b = 0 \u2194 a = b", "start": [82, 1], "end": [85, 32], "kind": "commanddeclaration"}, {"full_name": "mul_add_mul", "code": "@[simp]\ntheorem mul_add_mul : a * b + b * a = 0", "start": [88, 1], "end": [96, 34], "kind": "commanddeclaration"}, {"full_name": "sub_eq_add", "code": "@[simp]\ntheorem sub_eq_add : a - b = a + b", "start": [99, 1], "end": [100, 84], "kind": "commanddeclaration"}, {"full_name": "mul_one_add_self", "code": "@[simp]\ntheorem mul_one_add_self : a * (1 + a) = 0", "start": [103, 1], "end": [104, 91], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.toCommRing", "code": "instance (priority := 100) BooleanRing.toCommRing : CommRing \u03b1 :=\n  { (inferInstance : BooleanRing \u03b1) with\n    mul_comm := fun a b => by rw [\u2190 add_eq_zero', mul_add_mul] }", "start": [108, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "AsBoolAlg", "code": "def AsBoolAlg (\u03b1 : Type*) :=\n  \u03b1", "start": [123, 1], "end": [125, 4], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg", "code": "def toBoolAlg : \u03b1 \u2243 AsBoolAlg \u03b1 :=\n  Equiv.refl _", "start": [128, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg", "code": "def ofBoolAlg : AsBoolAlg \u03b1 \u2243 \u03b1 :=\n  Equiv.refl _", "start": [133, 1], "end": [135, 15], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_symm_eq", "code": "@[simp]\ntheorem toBoolAlg_symm_eq : (@toBoolAlg \u03b1).symm = ofBoolAlg", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_symm_eq", "code": "@[simp]\ntheorem ofBoolAlg_symm_eq : (@ofBoolAlg \u03b1).symm = toBoolAlg", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_ofBoolAlg", "code": "@[simp]\ntheorem toBoolAlg_ofBoolAlg (a : AsBoolAlg \u03b1) : toBoolAlg (ofBoolAlg a) = a", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_toBoolAlg", "code": "@[simp]\ntheorem ofBoolAlg_toBoolAlg (a : \u03b1) : ofBoolAlg (toBoolAlg a) = a", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_inj", "code": "theorem toBoolAlg_inj {a b : \u03b1} : toBoolAlg a = toBoolAlg b \u2194 a = b", "start": [159, 1], "end": [160, 10], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_inj", "code": "theorem ofBoolAlg_inj {a b : AsBoolAlg \u03b1} : ofBoolAlg a = ofBoolAlg b \u2194 a = b", "start": [164, 1], "end": [165, 10], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.sup", "code": "def sup : Sup \u03b1 :=\n  \u27e8fun x y => x + y + x * y\u27e9", "start": [175, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.inf", "code": "def inf : Inf \u03b1 :=\n  \u27e8(\u00b7 * \u00b7)\u27e9", "start": [180, 1], "end": [182, 12], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.sup_comm", "code": "theorem sup_comm (a b : \u03b1) : a \u2294 b = b \u2294 a", "start": [190, 1], "end": [192, 7], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.inf_comm", "code": "theorem inf_comm (a b : \u03b1) : a \u2293 b = b \u2293 a", "start": [195, 1], "end": [197, 7], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.sup_assoc", "code": "theorem sup_assoc (a b c : \u03b1) : a \u2294 b \u2294 c = a \u2294 (b \u2294 c)", "start": [200, 1], "end": [202, 7], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.inf_assoc", "code": "theorem inf_assoc (a b c : \u03b1) : a \u2293 b \u2293 c = a \u2293 (b \u2293 c)", "start": [205, 1], "end": [207, 7], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.sup_inf_self", "code": "theorem sup_inf_self (a b : \u03b1) : a \u2294 a \u2293 b = a", "start": [210, 1], "end": [212, 60], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.inf_sup_self", "code": "theorem inf_sup_self (a b : \u03b1) : a \u2293 (a \u2294 b) = a", "start": [215, 1], "end": [217, 88], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.le_sup_inf_aux", "code": "theorem le_sup_inf_aux (a b c : \u03b1) : (a + b + a * b) * (a + c + a * c) = a + b * c + a * (b * c)", "start": [220, 1], "end": [226, 79], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.le_sup_inf", "code": "theorem le_sup_inf (a b c : \u03b1) : (a \u2294 b) \u2293 (a \u2294 c) \u2294 (a \u2294 b \u2293 c) = a \u2294 b \u2293 c", "start": [230, 1], "end": [232, 52], "kind": "commanddeclaration"}, {"full_name": "BooleanRing.toBooleanAlgebra", "code": "def toBooleanAlgebra : BooleanAlgebra \u03b1 :=\n  { Lattice.mk' sup_comm sup_assoc inf_comm inf_assoc sup_inf_self inf_sup_self with\n    le_sup_inf := le_sup_inf\n    top := 1\n    le_top := fun a => show a + 1 + a * 1 = 1 by rw [mul_one, (add_comm a 1),\n                                                     add_assoc, add_self, add_zero]\n    bot := 0\n    bot_le := fun a => show 0 + a + 0 * a = a by rw [zero_mul, zero_add, add_zero]\n    compl := fun a => 1 + a\n    inf_compl_le_bot := fun a =>\n      show a * (1 + a) + 0 + a * (1 + a) * 0 = 0 by norm_num [mul_add, mul_self, add_self]\n    top_le_sup_compl := fun a => by\n      change\n        1 + (a + (1 + a) + a * (1 + a)) + 1 * (a + (1 + a) + a * (1 + a)) =\n          a + (1 + a) + a * (1 + a)\n      norm_num [mul_add, mul_self, add_self]\n      rw [\u2190 add_assoc, add_self] }", "start": [235, 1], "end": [262, 35], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_top", "code": "@[simp]\ntheorem ofBoolAlg_top : ofBoolAlg (\u22a4 : AsBoolAlg \u03b1) = 1", "start": [273, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_bot", "code": "@[simp]\ntheorem ofBoolAlg_bot : ofBoolAlg (\u22a5 : AsBoolAlg \u03b1) = 0", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_sup", "code": "@[simp]\ntheorem ofBoolAlg_sup (a b : AsBoolAlg \u03b1) :\n    ofBoolAlg (a \u2294 b) = ofBoolAlg a + ofBoolAlg b + ofBoolAlg a * ofBoolAlg b", "start": [283, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_inf", "code": "@[simp]\ntheorem ofBoolAlg_inf (a b : AsBoolAlg \u03b1) : ofBoolAlg (a \u2293 b) = ofBoolAlg a * ofBoolAlg b", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_compl", "code": "@[simp]\ntheorem ofBoolAlg_compl (a : AsBoolAlg \u03b1) : ofBoolAlg a\u1d9c = 1 + ofBoolAlg a", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_sdiff", "code": "@[simp]\ntheorem ofBoolAlg_sdiff (a b : AsBoolAlg \u03b1) : ofBoolAlg (a \\ b) = ofBoolAlg a * (1 + ofBoolAlg b)", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "of_boolalg_symmDiff_aux", "code": "private theorem of_boolalg_symmDiff_aux (a b : \u03b1) : (a + b + a * b) * (1 + a * b) = a + b", "start": [304, 1], "end": [308, 61], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_symmDiff", "code": "@[simp]\ntheorem ofBoolAlg_symmDiff (a b : AsBoolAlg \u03b1) : ofBoolAlg (a \u2206 b) = ofBoolAlg a + ofBoolAlg b", "start": [310, 1], "end": [313, 36], "kind": "commanddeclaration"}, {"full_name": "ofBoolAlg_mul_ofBoolAlg_eq_left_iff", "code": "@[simp]\ntheorem ofBoolAlg_mul_ofBoolAlg_eq_left_iff {a b : AsBoolAlg \u03b1} :\n    ofBoolAlg a * ofBoolAlg b = ofBoolAlg a \u2194 a \u2264 b", "start": [316, 1], "end": [319, 35], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_zero", "code": "@[simp]\ntheorem toBoolAlg_zero : toBoolAlg (0 : \u03b1) = \u22a5", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_one", "code": "@[simp]\ntheorem toBoolAlg_one : toBoolAlg (1 : \u03b1) = \u22a4", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_mul", "code": "@[simp]\ntheorem toBoolAlg_mul (a b : \u03b1) : toBoolAlg (a * b) = toBoolAlg a \u2293 toBoolAlg b", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_add_add_mul", "code": "@[simp, nolint simpNF]\ntheorem toBoolAlg_add_add_mul (a b : \u03b1) : toBoolAlg (a + b + a * b) = toBoolAlg a \u2294 toBoolAlg b", "start": [338, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolAlg_add", "code": "@[simp]\ntheorem toBoolAlg_add (a b : \u03b1) : toBoolAlg (a + b) = toBoolAlg a \u2206 toBoolAlg b", "start": [343, 1], "end": [345, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.asBoolAlg", "code": "@[simps]\nprotected def RingHom.asBoolAlg (f : \u03b1 \u2192+* \u03b2) : BoundedLatticeHom (AsBoolAlg \u03b1) (AsBoolAlg \u03b2) where\n  toFun := toBoolAlg \u2218 f \u2218 ofBoolAlg\n  map_sup' a b := by\n    dsimp\n    simp_rw [map_add f, map_mul f, toBoolAlg_add_add_mul]\n  map_inf' := f.map_mul'\n  map_top' := f.map_one'\n  map_bot' := f.map_zero'", "start": [348, 1], "end": [358, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.asBoolAlg_id", "code": "@[simp]\ntheorem RingHom.asBoolAlg_id : (RingHom.id \u03b1).asBoolAlg = BoundedLatticeHom.id _", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.asBoolAlg_comp", "code": "@[simp]\ntheorem RingHom.asBoolAlg_comp (g : \u03b2 \u2192+* \u03b3) (f : \u03b1 \u2192+* \u03b2) :\n    (g.comp f).asBoolAlg = g.asBoolAlg.comp f.asBoolAlg", "start": [366, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "AsBoolRing", "code": "def AsBoolRing (\u03b1 : Type*) :=\n  \u03b1", "start": [379, 1], "end": [381, 4], "kind": "commanddeclaration"}, {"full_name": "toBoolRing", "code": "def toBoolRing : \u03b1 \u2243 AsBoolRing \u03b1 :=\n  Equiv.refl _", "start": [384, 1], "end": [386, 15], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing", "code": "def ofBoolRing : AsBoolRing \u03b1 \u2243 \u03b1 :=\n  Equiv.refl _", "start": [389, 1], "end": [391, 15], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_symm_eq", "code": "@[simp]\ntheorem toBoolRing_symm_eq : (@toBoolRing \u03b1).symm = ofBoolRing", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_symm_eq", "code": "@[simp]\ntheorem ofBoolRing_symm_eq : (@ofBoolRing \u03b1).symm = toBoolRing", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_ofBoolRing", "code": "@[simp]\ntheorem toBoolRing_ofBoolRing (a : AsBoolRing \u03b1) : toBoolRing (ofBoolRing a) = a", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_toBoolRing", "code": "@[simp]\ntheorem ofBoolRing_toBoolRing (a : \u03b1) : ofBoolRing (toBoolRing a) = a", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_inj", "code": "theorem toBoolRing_inj {a b : \u03b1} : toBoolRing a = toBoolRing b \u2194 a = b", "start": [415, 1], "end": [416, 10], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_inj", "code": "theorem ofBoolRing_inj {a b : AsBoolRing \u03b1} : ofBoolRing a = ofBoolRing b \u2194 a = b", "start": [420, 1], "end": [421, 10], "kind": "commanddeclaration"}, {"full_name": "GeneralizedBooleanAlgebra.toNonUnitalCommRing", "code": "@[reducible]\ndef GeneralizedBooleanAlgebra.toNonUnitalCommRing [GeneralizedBooleanAlgebra \u03b1] :\n    NonUnitalCommRing \u03b1 where\n  add := (\u00b7 \u2206 \u00b7)\n  add_assoc := symmDiff_assoc\n  zero := \u22a5\n  zero_add := bot_symmDiff\n  add_zero := symmDiff_bot\n  zero_mul _ := bot_inf_eq\n  mul_zero _ := inf_bot_eq\n  neg := id\n  add_left_neg := symmDiff_self\n  add_comm := symmDiff_comm\n  mul := (\u00b7 \u2293 \u00b7)\n  mul_assoc _ _ _ := inf_assoc\n  mul_comm _ _ := inf_comm\n  left_distrib := inf_symmDiff_distrib_left\n  right_distrib := inf_symmDiff_distrib_right", "start": [428, 1], "end": [453, 46], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.toBooleanRing", "code": "@[reducible]\ndef BooleanAlgebra.toBooleanRing : BooleanRing \u03b1 :=\n  { GeneralizedBooleanAlgebra.toNonUnitalCommRing with\n    one := \u22a4\n    one_mul := fun _ => top_inf_eq\n    mul_one := fun _ => inf_top_eq\n    mul_self := fun b => inf_idem }", "start": [462, 1], "end": [476, 36], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_zero", "code": "@[simp]\ntheorem ofBoolRing_zero : ofBoolRing (0 : AsBoolRing \u03b1) = \u22a5", "start": [485, 1], "end": [487, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_one", "code": "@[simp]\ntheorem ofBoolRing_one : ofBoolRing (1 : AsBoolRing \u03b1) = \u22a4", "start": [490, 1], "end": [492, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_neg", "code": "@[simp, nolint simpNF]\ntheorem ofBoolRing_neg (a : AsBoolRing \u03b1) : ofBoolRing (-a) = ofBoolRing a", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_add", "code": "@[simp]\ntheorem ofBoolRing_add (a b : AsBoolRing \u03b1) : ofBoolRing (a + b) = ofBoolRing a \u2206 ofBoolRing b", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_sub", "code": "@[simp, nolint simpNF]\ntheorem ofBoolRing_sub (a b : AsBoolRing \u03b1) : ofBoolRing (a - b) = ofBoolRing a \u2206 ofBoolRing b", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_mul", "code": "@[simp]\ntheorem ofBoolRing_mul (a b : AsBoolRing \u03b1) : ofBoolRing (a * b) = ofBoolRing a \u2293 ofBoolRing b", "start": [512, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "ofBoolRing_le_ofBoolRing_iff", "code": "@[simp]\ntheorem ofBoolRing_le_ofBoolRing_iff {a b : AsBoolRing \u03b1} :\n    ofBoolRing a \u2264 ofBoolRing b \u2194 a * b = a", "start": [517, 1], "end": [520, 19], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_bot", "code": "@[simp]\ntheorem toBoolRing_bot : toBoolRing (\u22a5 : \u03b1) = 0", "start": [523, 1], "end": [525, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_top", "code": "@[simp]\ntheorem toBoolRing_top : toBoolRing (\u22a4 : \u03b1) = 1", "start": [528, 1], "end": [530, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_inf", "code": "@[simp]\ntheorem toBoolRing_inf (a b : \u03b1) : toBoolRing (a \u2293 b) = toBoolRing a * toBoolRing b", "start": [533, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "toBoolRing_symmDiff", "code": "@[simp]\ntheorem toBoolRing_symmDiff (a b : \u03b1) : toBoolRing (a \u2206 b) = toBoolRing a + toBoolRing b", "start": [538, 1], "end": [540, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.asBoolRing", "code": "@[simps]\nprotected def BoundedLatticeHom.asBoolRing (f : BoundedLatticeHom \u03b1 \u03b2) :\n    AsBoolRing \u03b1 \u2192+* AsBoolRing \u03b2 where\n  toFun := toBoolRing \u2218 f \u2218 ofBoolRing\n  map_zero' := f.map_bot'\n  map_one' := f.map_top'\n  map_add' := map_symmDiff' f\n  map_mul' := f.map_inf'", "start": [543, 1], "end": [552, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.asBoolRing_id", "code": "@[simp]\ntheorem BoundedLatticeHom.asBoolRing_id : (BoundedLatticeHom.id \u03b1).asBoolRing = RingHom.id _", "start": [555, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.asBoolRing_comp", "code": "@[simp]\ntheorem BoundedLatticeHom.asBoolRing_comp (g : BoundedLatticeHom \u03b2 \u03b3) (f : BoundedLatticeHom \u03b1 \u03b2) :\n    (g.comp f).asBoolRing = g.asBoolRing.comp f.asBoolRing", "start": [560, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.asBoolAlgAsBoolRing", "code": "@[simps!]\ndef OrderIso.asBoolAlgAsBoolRing (\u03b1 : Type*) [BooleanAlgebra \u03b1] : AsBoolAlg (AsBoolRing \u03b1) \u2243o \u03b1 :=\n  \u27e8ofBoolAlg.trans ofBoolRing,\n   ofBoolRing_le_ofBoolRing_iff.trans ofBoolAlg_mul_ofBoolAlg_eq_left_iff\u27e9", "start": [571, 1], "end": [576, 75], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.asBoolRingAsBoolAlg", "code": "@[simps!]\ndef RingEquiv.asBoolRingAsBoolAlg (\u03b1 : Type*) [BooleanRing \u03b1] : AsBoolRing (AsBoolAlg \u03b1) \u2243+* \u03b1 :=\n  { ofBoolRing.trans ofBoolAlg with\n    map_mul' := fun _a _b => rfl\n    map_add' := ofBoolAlg_symmDiff }", "start": [579, 1], "end": [585, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Category/BoolAlg.lean", "imports": ["Mathlib/Order/Category/HeytAlg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "BoolAlg", "code": "def BoolAlg :=\n  Bundled BooleanAlgebra", "start": [24, 1], "end": [26, 25], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.instBooleanAlgebra", "code": "instance instBooleanAlgebra (X : BoolAlg) : BooleanAlgebra X :=\n  X.str", "start": [34, 1], "end": [35, 8], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.of", "code": "def of (\u03b1 : Type*) [BooleanAlgebra \u03b1] : BoolAlg :=\n  Bundled.of \u03b1", "start": [37, 1], "end": [39, 15], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.coe_of", "code": "@[simp]\ntheorem coe_of (\u03b1 : Type*) [BooleanAlgebra \u03b1] : \u21a5(of \u03b1) = \u03b1", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.toBddDistLat", "code": "def toBddDistLat (X : BoolAlg) : BddDistLat :=\n  BddDistLat.of X", "start": [50, 1], "end": [52, 18], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.coe_toBddDistLat", "code": "@[simp]\ntheorem coe_toBddDistLat (X : BoolAlg) : \u21a5X.toBddDistLat = \u21a5X", "start": [55, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.hasForgetToBddDistLat", "code": "instance hasForgetToBddDistLat : HasForget\u2082 BoolAlg BddDistLat :=\n  InducedCategory.hasForget\u2082 toBddDistLat", "start": [66, 1], "end": [67, 42], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.hasForgetToHeytAlg", "code": "@[simps]\ninstance hasForgetToHeytAlg : HasForget\u2082 BoolAlg HeytAlg where\n  forget\u2082 :=\n    { obj := fun X => {\u03b1 := X}\n      map := fun {X Y} (f : BoundedLatticeHom X Y) => show HeytingHom X Y from f }", "start": [74, 1], "end": [81, 83], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.Iso.mk", "code": "@[simps]\ndef Iso.mk {\u03b1 \u03b2 : BoolAlg.{u}} (e : \u03b1 \u2243o \u03b2) : \u03b1 \u2245 \u03b2 where\n  hom := (e : BoundedLatticeHom \u03b1 \u03b2)\n  inv := (e.symm : BoundedLatticeHom \u03b2 \u03b1)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _", "start": [86, 1], "end": [92, 51], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.dual", "code": "@[simps]\ndef dual : BoolAlg \u2964 BoolAlg where\n  obj X := of X\u1d52\u1d48\n  map {X Y} := BoundedLatticeHom.dual", "start": [95, 1], "end": [99, 38], "kind": "commanddeclaration"}, {"full_name": "BoolAlg.dualEquiv", "code": "@[simps functor inverse]\ndef dualEquiv : BoolAlg \u224c BoolAlg where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X", "start": [102, 1], "end": [108, 74], "kind": "commanddeclaration"}, {"full_name": "boolAlg_dual_comp_forget_to_bddDistLat", "code": "theorem boolAlg_dual_comp_forget_to_bddDistLat :\n    BoolAlg.dual \u22d9 forget\u2082 BoolAlg BddDistLat =\n    forget\u2082 BoolAlg BddDistLat \u22d9 BddDistLat.dual", "start": [113, 1], "end": [116, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Sups.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Order/SupClosed.lean", "Mathlib/Data/Set/NAry.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasSups", "code": "class HasSups (\u03b1 : Type*) where\n  sups : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [38, 1], "end": [40, 19], "kind": "commanddeclaration"}, {"full_name": "HasInfs", "code": "class HasInfs (\u03b1 : Type*) where\n  infs : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [43, 1], "end": [45, 19], "kind": "commanddeclaration"}, {"full_name": "Set.hasSups", "code": "protected def hasSups : HasSups (Set \u03b1) :=\n  \u27e8image2 (\u00b7 \u2294 \u00b7)\u27e9", "start": [61, 1], "end": [63, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sups", "code": "@[simp]\ntheorem mem_sups : c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c", "start": [73, 1], "end": [74, 80], "kind": "commanddeclaration"}, {"full_name": "Set.sup_mem_sups", "code": "theorem sup_mem_sups : a \u2208 s \u2192 b \u2208 t \u2192 a \u2294 b \u2208 s \u22bb t", "start": [77, 1], "end": [78, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sups_subset", "code": "theorem sups_subset : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u22bb t\u2081 \u2286 s\u2082 \u22bb t\u2082", "start": [81, 1], "end": [82, 16], "kind": "commanddeclaration"}, {"full_name": "Set.sups_subset_left", "code": "theorem sups_subset_left : t\u2081 \u2286 t\u2082 \u2192 s \u22bb t\u2081 \u2286 s \u22bb t\u2082", "start": [85, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "Set.sups_subset_right", "code": "theorem sups_subset_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u22bb t \u2286 s\u2082 \u22bb t", "start": [89, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_sups_left", "code": "theorem image_subset_sups_left : b \u2208 t \u2192 (fun a => a \u2294 b) '' s \u2286 s \u22bb t", "start": [93, 1], "end": [94, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_sups_right", "code": "theorem image_subset_sups_right : a \u2208 s \u2192 (\u00b7 \u2294 \u00b7) a '' t \u2286 s \u22bb t", "start": [97, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "Set.forall_sups_iff", "code": "theorem forall_sups_iff {p : \u03b1 \u2192 Prop} : (\u2200 c \u2208 s \u22bb t, p c) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, p (a \u2294 b)", "start": [101, 1], "end": [102, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sups_subset_iff", "code": "@[simp]\ntheorem sups_subset_iff : s \u22bb t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2294 b \u2208 u", "start": [105, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sups_nonempty", "code": "@[simp]\ntheorem sups_nonempty : (s \u22bb t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [110, 1], "end": [112, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.sups", "code": "protected theorem Nonempty.sups : s.Nonempty \u2192 t.Nonempty \u2192 (s \u22bb t).Nonempty", "start": [115, 1], "end": [116, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_sups_left", "code": "theorem Nonempty.of_sups_left : (s \u22bb t).Nonempty \u2192 s.Nonempty", "start": [119, 1], "end": [120, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_sups_right", "code": "theorem Nonempty.of_sups_right : (s \u22bb t).Nonempty \u2192 t.Nonempty", "start": [123, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "Set.empty_sups", "code": "@[simp]\ntheorem empty_sups : \u2205 \u22bb t = \u2205", "start": [127, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sups_empty", "code": "@[simp]\ntheorem sups_empty : s \u22bb \u2205 = \u2205", "start": [132, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "Set.sups_eq_empty", "code": "@[simp]\ntheorem sups_eq_empty : s \u22bb t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [137, 1], "end": [139, 22], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_sups", "code": "@[simp]\ntheorem singleton_sups : {a} \u22bb t = t.image fun b => a \u2294 b", "start": [142, 1], "end": [144, 24], "kind": "commanddeclaration"}, {"full_name": "Set.sups_singleton", "code": "@[simp]\ntheorem sups_singleton : s \u22bb {b} = s.image fun a => a \u2294 b", "start": [147, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_sups_singleton", "code": "theorem singleton_sups_singleton : ({a} \u22bb {b} : Set \u03b1) = {a \u2294 b}", "start": [152, 1], "end": [153, 19], "kind": "commanddeclaration"}, {"full_name": "Set.sups_union_left", "code": "theorem sups_union_left : (s\u2081 \u222a s\u2082) \u22bb t = s\u2081 \u22bb t \u222a s\u2082 \u22bb t", "start": [156, 1], "end": [157, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sups_union_right", "code": "theorem sups_union_right : s \u22bb (t\u2081 \u222a t\u2082) = s \u22bb t\u2081 \u222a s \u22bb t\u2082", "start": [160, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "Set.sups_inter_subset_left", "code": "theorem sups_inter_subset_left : (s\u2081 \u2229 s\u2082) \u22bb t \u2286 s\u2081 \u22bb t \u2229 s\u2082 \u22bb t", "start": [164, 1], "end": [165, 27], "kind": "commanddeclaration"}, {"full_name": "Set.sups_inter_subset_right", "code": "theorem sups_inter_subset_right : s \u22bb (t\u2081 \u2229 t\u2082) \u2286 s \u22bb t\u2081 \u2229 s \u22bb t\u2082", "start": [168, 1], "end": [169, 28], "kind": "commanddeclaration"}, {"full_name": "Set.image_sups", "code": "lemma image_sups (f : F) (s t : Set \u03b1) : f '' (s \u22bb t) = f '' s \u22bb f '' t :=\n  image_image2_distrib $ map_sup f", "start": [172, 1], "end": [173, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Set.subset_sups_self", "code": "lemma subset_sups_self : s \u2286 s \u22bb s := \u03bb _a ha \u21a6 mem_sups.2 \u27e8_, ha, _, ha, sup_idem\u27e9", "start": [175, 1], "end": [175, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sups_subset_self", "code": "lemma sups_subset_self : s \u22bb s \u2286 s \u2194 SupClosed s := sups_subset_iff", "start": [176, 1], "end": [176, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sups_eq_self", "code": "@[simp] lemma sups_eq_self : s \u22bb s = s \u2194 SupClosed s :=\n  subset_sups_self.le.le_iff_eq.symm.trans sups_subset_self", "start": [178, 1], "end": [179, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sep_sups_le", "code": "lemma sep_sups_le (s t : Set \u03b1) (a : \u03b1) :\n    {b \u2208 s \u22bb t | b \u2264 a} = {b \u2208 s | b \u2264 a} \u22bb {b \u2208 t | b \u2264 a} := by ext; aesop", "start": [181, 1], "end": [182, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_image_sup_left", "code": "theorem iUnion_image_sup_left : \u22c3 a \u2208 s, (\u00b7 \u2294 \u00b7) a '' t = s \u22bb t", "start": [186, 1], "end": [187, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_image_sup_right", "code": "theorem iUnion_image_sup_right : \u22c3 b \u2208 t, (\u00b7 \u2294 b) '' s = s \u22bb t", "start": [190, 1], "end": [191, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image_sup_prod", "code": "@[simp]\ntheorem image_sup_prod (s t : Set \u03b1) : Set.image2 (fun x x_1 => x \u2294 x_1) s t = s \u22bb t", "start": [194, 1], "end": [199, 33], "kind": "commanddeclaration"}, {"full_name": "Set.sups_assoc", "code": "theorem sups_assoc : s \u22bb t \u22bb u = s \u22bb (t \u22bb u)", "start": [202, 1], "end": [203, 38], "kind": "commanddeclaration"}, {"full_name": "Set.sups_comm", "code": "theorem sups_comm : s \u22bb t = t \u22bb s", "start": [206, 1], "end": [207, 34], "kind": "commanddeclaration"}, {"full_name": "Set.sups_left_comm", "code": "theorem sups_left_comm : s \u22bb (t \u22bb u) = t \u22bb (s \u22bb u)", "start": [210, 1], "end": [211, 33], "kind": "commanddeclaration"}, {"full_name": "Set.sups_right_comm", "code": "theorem sups_right_comm : s \u22bb t \u22bb u = s \u22bb u \u22bb t", "start": [214, 1], "end": [215, 35], "kind": "commanddeclaration"}, {"full_name": "Set.sups_sups_sups_comm", "code": "theorem sups_sups_sups_comm : s \u22bb t \u22bb (u \u22bb v) = s \u22bb u \u22bb (t \u22bb v)", "start": [218, 1], "end": [219, 45], "kind": "commanddeclaration"}, {"full_name": "Set.hasInfs", "code": "protected def hasInfs : HasInfs (Set \u03b1) :=\n  \u27e8image2 (\u00b7 \u2293 \u00b7)\u27e9", "start": [228, 1], "end": [230, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mem_infs", "code": "@[simp]\ntheorem mem_infs : c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c", "start": [240, 1], "end": [241, 80], "kind": "commanddeclaration"}, {"full_name": "Set.inf_mem_infs", "code": "theorem inf_mem_infs : a \u2208 s \u2192 b \u2208 t \u2192 a \u2293 b \u2208 s \u22bc t", "start": [244, 1], "end": [245, 20], "kind": "commanddeclaration"}, {"full_name": "Set.infs_subset", "code": "theorem infs_subset : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u22bc t\u2081 \u2286 s\u2082 \u22bc t\u2082", "start": [248, 1], "end": [249, 16], "kind": "commanddeclaration"}, {"full_name": "Set.infs_subset_left", "code": "theorem infs_subset_left : t\u2081 \u2286 t\u2082 \u2192 s \u22bc t\u2081 \u2286 s \u22bc t\u2082", "start": [252, 1], "end": [253, 21], "kind": "commanddeclaration"}, {"full_name": "Set.infs_subset_right", "code": "theorem infs_subset_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u22bc t \u2286 s\u2082 \u22bc t", "start": [256, 1], "end": [257, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_infs_left", "code": "theorem image_subset_infs_left : b \u2208 t \u2192 (fun a => a \u2293 b) '' s \u2286 s \u22bc t", "start": [260, 1], "end": [261, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_infs_right", "code": "theorem image_subset_infs_right : a \u2208 s \u2192 (\u00b7 \u2293 \u00b7) a '' t \u2286 s \u22bc t", "start": [264, 1], "end": [265, 28], "kind": "commanddeclaration"}, {"full_name": "Set.forall_infs_iff", "code": "theorem forall_infs_iff {p : \u03b1 \u2192 Prop} : (\u2200 c \u2208 s \u22bc t, p c) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, p (a \u2293 b)", "start": [268, 1], "end": [269, 20], "kind": "commanddeclaration"}, {"full_name": "Set.infs_subset_iff", "code": "@[simp]\ntheorem infs_subset_iff : s \u22bc t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2293 b \u2208 u", "start": [272, 1], "end": [274, 20], "kind": "commanddeclaration"}, {"full_name": "Set.infs_nonempty", "code": "@[simp]\ntheorem infs_nonempty : (s \u22bc t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [277, 1], "end": [279, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.infs", "code": "protected theorem Nonempty.infs : s.Nonempty \u2192 t.Nonempty \u2192 (s \u22bc t).Nonempty", "start": [282, 1], "end": [283, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_infs_left", "code": "theorem Nonempty.of_infs_left : (s \u22bc t).Nonempty \u2192 s.Nonempty", "start": [286, 1], "end": [287, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_infs_right", "code": "theorem Nonempty.of_infs_right : (s \u22bc t).Nonempty \u2192 t.Nonempty", "start": [290, 1], "end": [291, 27], "kind": "commanddeclaration"}, {"full_name": "Set.empty_infs", "code": "@[simp]\ntheorem empty_infs : \u2205 \u22bc t = \u2205", "start": [294, 1], "end": [296, 20], "kind": "commanddeclaration"}, {"full_name": "Set.infs_empty", "code": "@[simp]\ntheorem infs_empty : s \u22bc \u2205 = \u2205", "start": [299, 1], "end": [301, 21], "kind": "commanddeclaration"}, {"full_name": "Set.infs_eq_empty", "code": "@[simp]\ntheorem infs_eq_empty : s \u22bc t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [304, 1], "end": [306, 22], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_infs", "code": "@[simp]\ntheorem singleton_infs : {a} \u22bc t = t.image fun b => a \u2293 b", "start": [309, 1], "end": [311, 24], "kind": "commanddeclaration"}, {"full_name": "Set.infs_singleton", "code": "@[simp]\ntheorem infs_singleton : s \u22bc {b} = s.image fun a => a \u2293 b", "start": [314, 1], "end": [316, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_infs_singleton", "code": "theorem singleton_infs_singleton : ({a} \u22bc {b} : Set \u03b1) = {a \u2293 b}", "start": [319, 1], "end": [320, 19], "kind": "commanddeclaration"}, {"full_name": "Set.infs_union_left", "code": "theorem infs_union_left : (s\u2081 \u222a s\u2082) \u22bc t = s\u2081 \u22bc t \u222a s\u2082 \u22bc t", "start": [323, 1], "end": [324, 20], "kind": "commanddeclaration"}, {"full_name": "Set.infs_union_right", "code": "theorem infs_union_right : s \u22bc (t\u2081 \u222a t\u2082) = s \u22bc t\u2081 \u222a s \u22bc t\u2082", "start": [327, 1], "end": [328, 21], "kind": "commanddeclaration"}, {"full_name": "Set.infs_inter_subset_left", "code": "theorem infs_inter_subset_left : (s\u2081 \u2229 s\u2082) \u22bc t \u2286 s\u2081 \u22bc t \u2229 s\u2082 \u22bc t", "start": [331, 1], "end": [332, 27], "kind": "commanddeclaration"}, {"full_name": "Set.infs_inter_subset_right", "code": "theorem infs_inter_subset_right : s \u22bc (t\u2081 \u2229 t\u2082) \u2286 s \u22bc t\u2081 \u2229 s \u22bc t\u2082", "start": [335, 1], "end": [336, 28], "kind": "commanddeclaration"}, {"full_name": "Set.image_infs", "code": "lemma image_infs (f : F) (s t : Set \u03b1) : f '' (s \u22bc t) = f '' s \u22bc f '' t :=\n  image_image2_distrib $ map_inf f", "start": [339, 1], "end": [340, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Set.subset_infs_self", "code": "lemma subset_infs_self : s \u2286 s \u22bc s := \u03bb _a ha \u21a6 mem_infs.2 \u27e8_, ha, _, ha, inf_idem\u27e9", "start": [342, 1], "end": [342, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Set.infs_self_subset", "code": "lemma infs_self_subset : s \u22bc s \u2286 s \u2194 InfClosed s := infs_subset_iff", "start": [343, 1], "end": [343, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.infs_self", "code": "@[simp] lemma infs_self : s \u22bc s = s \u2194 InfClosed s :=\n  subset_infs_self.le.le_iff_eq.symm.trans infs_self_subset", "start": [345, 1], "end": [346, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sep_infs_le", "code": "lemma sep_infs_le (s t : Set \u03b1) (a : \u03b1) :\n    {b \u2208 s \u22bc t | a \u2264 b} = {b \u2208 s | a \u2264 b} \u22bc {b \u2208 t | a \u2264 b} := by ext; aesop", "start": [348, 1], "end": [349, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_image_inf_left", "code": "theorem iUnion_image_inf_left : \u22c3 a \u2208 s, (\u00b7 \u2293 \u00b7) a '' t = s \u22bc t", "start": [353, 1], "end": [354, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_image_inf_right", "code": "theorem iUnion_image_inf_right : \u22c3 b \u2208 t, (\u00b7 \u2293 b) '' s = s \u22bc t", "start": [357, 1], "end": [358, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image_inf_prod", "code": "@[simp]\ntheorem image_inf_prod (s t : Set \u03b1) : Set.image2 (fun x x_1 => x \u2293 x_1) s t = s \u22bc t", "start": [361, 1], "end": [366, 33], "kind": "commanddeclaration"}, {"full_name": "Set.infs_assoc", "code": "theorem infs_assoc : s \u22bc t \u22bc u = s \u22bc (t \u22bc u)", "start": [369, 1], "end": [370, 38], "kind": "commanddeclaration"}, {"full_name": "Set.infs_comm", "code": "theorem infs_comm : s \u22bc t = t \u22bc s", "start": [373, 1], "end": [374, 34], "kind": "commanddeclaration"}, {"full_name": "Set.infs_left_comm", "code": "theorem infs_left_comm : s \u22bc (t \u22bc u) = t \u22bc (s \u22bc u)", "start": [377, 1], "end": [378, 33], "kind": "commanddeclaration"}, {"full_name": "Set.infs_right_comm", "code": "theorem infs_right_comm : s \u22bc t \u22bc u = s \u22bc u \u22bc t", "start": [381, 1], "end": [382, 35], "kind": "commanddeclaration"}, {"full_name": "Set.infs_infs_infs_comm", "code": "theorem infs_infs_infs_comm : s \u22bc t \u22bc (u \u22bc v) = s \u22bc u \u22bc (t \u22bc v)", "start": [385, 1], "end": [386, 45], "kind": "commanddeclaration"}, {"full_name": "Set.sups_infs_subset_left", "code": "theorem sups_infs_subset_left : s \u22bb t \u22bc u \u2286 (s \u22bb t) \u22bc (s \u22bb u)", "start": [397, 1], "end": [398, 55], "kind": "commanddeclaration"}, {"full_name": "Set.sups_infs_subset_right", "code": "theorem sups_infs_subset_right : t \u22bc u \u22bb s \u2286 (t \u22bb s) \u22bc (u \u22bb s)", "start": [401, 1], "end": [402, 57], "kind": "commanddeclaration"}, {"full_name": "Set.infs_sups_subset_left", "code": "theorem infs_sups_subset_left : s \u22bc (t \u22bb u) \u2286 s \u22bc t \u22bb s \u22bc u", "start": [405, 1], "end": [406, 55], "kind": "commanddeclaration"}, {"full_name": "Set.infs_sups_subset_right", "code": "theorem infs_sups_subset_right : (t \u22bb u) \u22bc s \u2286 t \u22bc s \u22bb u \u22bc s", "start": [409, 1], "end": [410, 57], "kind": "commanddeclaration"}, {"full_name": "upperClosure_sups", "code": "@[simp]\ntheorem upperClosure_sups [SemilatticeSup \u03b1] (s t : Set \u03b1) :\n    upperClosure (s \u22bb t) = upperClosure s \u2294 upperClosure t", "start": [419, 1], "end": [429, 51], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_infs", "code": "@[simp]\ntheorem lowerClosure_infs [SemilatticeInf \u03b1] (s t : Set \u03b1) :\n    lowerClosure (s \u22bc t) = lowerClosure s \u2293 lowerClosure t", "start": [432, 1], "end": [442, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Adjunction/Whiskering.lean", "imports": ["Mathlib/CategoryTheory/Whiskering.lean", "Mathlib/CategoryTheory/Adjunction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Adjunction.whiskerRight", "code": "@[simps! unit_app_app counit_app_app]\nprotected def whiskerRight (adj : F \u22a3 G) :\n    (whiskeringRight C D E).obj F \u22a3 (whiskeringRight C E D).obj G :=\n  mkOfUnitCounit\n    { unit :=\n        { app := fun X =>\n            (Functor.rightUnitor _).inv \u226b whiskerLeft X adj.unit \u226b (Functor.associator _ _ _).inv\n          naturality := by intros; ext; dsimp; simp }\n      counit :=\n        { app := fun X =>\n            (Functor.associator _ _ _).hom \u226b whiskerLeft X adj.counit \u226b (Functor.rightUnitor _).hom\n          naturality := by intros; ext; dsimp; simp }\n      left_triangle  := by ext; dsimp; simp\n      right_triangle := by ext; dsimp; simp\n    }", "start": [26, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Adjunction.whiskerLeft", "code": "@[simps! unit_app_app counit_app_app]\nprotected def whiskerLeft (adj : F \u22a3 G) :\n    (whiskeringLeft E D C).obj G \u22a3 (whiskeringLeft D E C).obj F :=\n  mkOfUnitCounit\n    { unit :=\n        { app := fun X =>\n            (Functor.leftUnitor _).inv \u226b whiskerRight adj.unit X \u226b (Functor.associator _ _ _).hom\n          naturality := by intros; ext; dsimp; simp }\n      counit :=\n        { app := fun X =>\n            (Functor.associator _ _ _).inv \u226b whiskerRight adj.counit X \u226b (Functor.leftUnitor _).hom\n          naturality := by intros; ext; dsimp; simp }\n      left_triangle  := by ext x; dsimp; simp [Category.id_comp, Category.comp_id, \u2190 x.map_comp]\n      right_triangle := by ext x; dsimp; simp [Category.id_comp, Category.comp_id, \u2190 x.map_comp]\n    }", "start": [45, 1], "end": [61, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/PID.lean", "imports": ["Mathlib/Algebra/Module/Projective.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Module/DedekindDomain.lean", "Mathlib/LinearAlgebra/FreeModule/PID.lean", "Mathlib/Algebra/Category/ModuleCat/Biproducts.lean"], "premises": [{"full_name": "Submodule.isInternal_prime_power_torsion_of_pid", "code": "theorem Submodule.isInternal_prime_power_torsion_of_pid [Module.Finite R M]\n    (hM : Module.IsTorsion R M) :\n    DirectSum.IsInternal fun p : (factors (\u22a4 : Submodule R M).annihilator).toFinset =>\n      torsionBy R M\n        (IsPrincipal.generator (p : Ideal R) ^\n          (factors (\u22a4 : Submodule R M).annihilator).count \u2191p)", "start": [68, 1], "end": [79, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_isInternal_prime_power_torsion_of_pid", "code": "theorem Submodule.exists_isInternal_prime_power_torsion_of_pid [Module.Finite R M]\n    (hM : Module.IsTorsion R M) :\n    \u2203 (\u03b9 : Type u) (_ : Fintype \u03b9) (_ : DecidableEq \u03b9) (p : \u03b9 \u2192 R) (_ : \u2200 i, Irreducible <| p i)\n        (e : \u03b9 \u2192 \u2115), DirectSum.IsInternal fun i => torsionBy R M <| p i ^ e i", "start": [82, 1], "end": [93, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.torsionOf_eq_span_pow_pOrder", "code": "theorem _root_.Ideal.torsionOf_eq_span_pow_pOrder (x : M) :\n    torsionOf R M x = span {p ^ pOrder hM x}", "start": [106, 1], "end": [119, 23], "kind": "commanddeclaration"}, {"full_name": "Module.p_pow_smul_lift", "code": "theorem p_pow_smul_lift {x y : M} {k : \u2115} (hM' : Module.IsTorsionBy R M (p ^ pOrder hM y))\n    (h : p ^ k \u2022 x \u2208 R \u2219 y) : \u2203 a : R, p ^ k \u2022 x = p ^ k \u2022 a \u2022 y", "start": [122, 1], "end": [145, 17], "kind": "commanddeclaration"}, {"full_name": "Module.exists_smul_eq_zero_and_mk_eq", "code": "theorem exists_smul_eq_zero_and_mk_eq {z : M} (hz : Module.IsTorsionBy R M (p ^ pOrder hM z))\n    {k : \u2115} (f : (R \u29f8 R \u2219 p ^ k) \u2192\u2097[R] M \u29f8 R \u2219 z) :\n    \u2203 x : M, p ^ k \u2022 x = 0 \u2227 Submodule.Quotient.mk (p := span R {z}) x = f 1", "start": [150, 1], "end": [162, 41], "kind": "commanddeclaration"}, {"full_name": "Module.torsion_by_prime_power_decomposition", "code": "theorem torsion_by_prime_power_decomposition (hN : Module.IsTorsion' N (Submonoid.powers p))\n    [h' : Module.Finite R N] :\n    \u2203 (d : \u2115) (k : Fin d \u2192 \u2115), Nonempty <| N \u2243\u2097[R] \u2a01 i : Fin d, R \u29f8 R \u2219 p ^ (k i : \u2115)", "start": [168, 1], "end": [230, 16], "kind": "commanddeclaration"}, {"full_name": "Module.equiv_directSum_of_isTorsion", "code": "theorem equiv_directSum_of_isTorsion [h' : Module.Finite R N] (hN : Module.IsTorsion R N) :\n    \u2203 (\u03b9 : Type u) (_ : Fintype \u03b9) (p : \u03b9 \u2192 R) (_ : \u2200 i, Irreducible <| p i) (e : \u03b9 \u2192 \u2115),\n      Nonempty <| N \u2243\u2097[R] \u2a01 i : \u03b9, R \u29f8 R \u2219 p i ^ e i", "start": [235, 1], "end": [260, 12], "kind": "commanddeclaration"}, {"full_name": "Module.equiv_free_prod_directSum", "code": "theorem equiv_free_prod_directSum [h' : Module.Finite R N] :\n    \u2203 (n : \u2115) (\u03b9 : Type u) (_ : Fintype \u03b9) (p : \u03b9 \u2192 R) (_ : \u2200 i, Irreducible <| p i) (e : \u03b9 \u2192 \u2115),\n      Nonempty <| N \u2243\u2097[R] (Fin n \u2192\u2080 R) \u00d7 \u2a01 i : \u03b9, R \u29f8 R \u2219 p i ^ e i", "start": [263, 1], "end": [281, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Sheaves/PUnit.lean", "imports": ["Mathlib/Topology/Sheaves/SheafCondition/Sites.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopCat.Presheaf.isSheaf_of_isTerminal_of_indiscrete", "code": "theorem isSheaf_of_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = \u22a4) (F : Presheaf C X)\n    (it : IsTerminal <| F.obj <| op \u22a5) : F.IsSheaf", "start": [25, 1], "end": [42, 17], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.isSheaf_iff_isTerminal_of_indiscrete", "code": "theorem isSheaf_iff_isTerminal_of_indiscrete {X : TopCat.{w}} (hind : X.str = \u22a4)\n    (F : Presheaf C X) : F.IsSheaf \u2194 Nonempty (IsTerminal <| F.obj <| op \u22a5)", "start": [46, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.isSheaf_on_punit_of_isTerminal", "code": "theorem isSheaf_on_punit_of_isTerminal (F : Presheaf C (TopCat.of PUnit))\n    (it : IsTerminal <| F.obj <| op \u22a5) : F.IsSheaf", "start": [52, 1], "end": [54, 95], "kind": "commanddeclaration"}, {"full_name": "TopCat.Presheaf.isSheaf_on_punit_iff_isTerminal", "code": "theorem isSheaf_on_punit_iff_isTerminal (F : Presheaf C (TopCat.of PUnit)) :\n    F.IsSheaf \u2194 Nonempty (IsTerminal <| F.obj <| op \u22a5)", "start": [57, 1], "end": [59, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Pi/Wallis.lean", "imports": ["Mathlib/Analysis/SpecialFunctions/Integrals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.Wallis.W", "code": "noncomputable def W (k : \u2115) : \u211d :=\n  \u220f i in range k, (2 * i + 2) / (2 * i + 1) * ((2 * i + 2) / (2 * i + 3))", "start": [47, 1], "end": [49, 74], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.W_succ", "code": "theorem W_succ (k : \u2115) :\n    W (k + 1) = W k * ((2 * k + 2) / (2 * k + 1) * ((2 * k + 2) / (2 * k + 3)))", "start": [52, 1], "end": [54, 22], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.W_pos", "code": "theorem W_pos (k : \u2115) : 0 < W k", "start": [57, 1], "end": [61, 76], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.W_eq_factorial_ratio", "code": "theorem W_eq_factorial_ratio (n : \u2115) :\n    W n = 2 ^ (4 * n) * n ! ^ 4 / ((2 * n)! ^ 2 * (2 * n + 1))", "start": [64, 1], "end": [77, 12], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.W_eq_integral_sin_pow_div_integral_sin_pow", "code": "theorem W_eq_integral_sin_pow_div_integral_sin_pow (k : \u2115) : (\u03c0 / 2)\u207b\u00b9 * W k =\n    (\u222b x : \u211d in (0)..\u03c0, sin x ^ (2 * k + 1)) / \u222b x : \u211d in (0)..\u03c0, sin x ^ (2 * k)", "start": [80, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.W_le", "code": "theorem W_le (k : \u2115) : W k \u2264 \u03c0 / 2", "start": [87, 1], "end": [90, 33], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.le_W", "code": "theorem le_W (k : \u2115) : ((2 : \u211d) * k + 1) / (2 * k + 2) * (\u03c0 / 2) \u2264 W k", "start": [93, 1], "end": [100, 12], "kind": "commanddeclaration"}, {"full_name": "Real.Wallis.tendsto_W_nhds_pi_div_two", "code": "theorem tendsto_W_nhds_pi_div_two : Tendsto W atTop (\ud835\udcdd <| \u03c0 / 2)", "start": [103, 1], "end": [116, 61], "kind": "commanddeclaration"}, {"full_name": "Real.tendsto_prod_pi_div_two", "code": "theorem Real.tendsto_prod_pi_div_two :\n    Tendsto (fun k => \u220f i in range k, ((2 : \u211d) * i + 2) / (2 * i + 1) * ((2 * i + 2) / (2 * i + 3)))\n      atTop (\ud835\udcdd (\u03c0 / 2))", "start": [123, 1], "end": [127, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Small/Group.lean", "imports": ["Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/Logic/Small/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "equivShrink_symm_zero", "code": "@[simp]\nlemma equivShrink_symm_zero [Zero \u03b1] [Small \u03b1] : (equivShrink \u03b1).symm 0 = 0 :=\n  (equivShrink \u03b1).symm_apply_apply 0", "start": [25, 1], "end": [27, 37], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_one", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_symm_one [One \u03b1] [Small \u03b1] : (equivShrink \u03b1).symm 1 = 1 :=\n  (equivShrink \u03b1).symm_apply_apply 1", "start": [29, 1], "end": [31, 37], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_add", "code": "@[simp]\nlemma equivShrink_symm_add [Add \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x + y) = (equivShrink \u03b1).symm x + (equivShrink \u03b1).symm y := by\n  rw [Equiv.add_def]\n  simp", "start": [38, 1], "end": [42, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_add", "code": "@[simp]\nlemma equivShrink_add [Add \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x + y) = equivShrink \u03b1 x + equivShrink \u03b1 y := by\n  rw [Equiv.add_def]\n  simp", "start": [44, 1], "end": [48, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_mul", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_symm_mul [Mul \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x * y) = (equivShrink \u03b1).symm x * (equivShrink \u03b1).symm y := by\n  rw [Equiv.mul_def]\n  simp", "start": [50, 1], "end": [54, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_mul", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_mul [Mul \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x * y) = equivShrink \u03b1 x * equivShrink \u03b1 y := by\n  rw [Equiv.mul_def]\n  simp", "start": [56, 1], "end": [60, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_sub", "code": "@[simp]\nlemma equivShrink_symm_sub [Sub \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x - y) = (equivShrink \u03b1).symm x - (equivShrink \u03b1).symm y := by\n  rw [Equiv.sub_def]\n  simp", "start": [67, 1], "end": [71, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_sub", "code": "@[simp]\nlemma equivShrink_sub [Sub \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x - y) = equivShrink \u03b1 x - equivShrink \u03b1 y := by\n  rw [Equiv.sub_def]\n  simp", "start": [73, 1], "end": [77, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_div", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_symm_div [Div \u03b1] [Small \u03b1] (x y : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (x / y) = (equivShrink \u03b1).symm x / (equivShrink \u03b1).symm y := by\n  rw [Equiv.div_def]\n  simp", "start": [79, 1], "end": [83, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_div", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_div [Div \u03b1] [Small \u03b1] (x y : \u03b1) :\n    equivShrink \u03b1 (x / y) = equivShrink \u03b1 x / equivShrink \u03b1 y := by\n  rw [Equiv.div_def]\n  simp", "start": [85, 1], "end": [89, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_neg", "code": "@[simp]\nlemma equivShrink_symm_neg [Neg \u03b1] [Small \u03b1] (x : Shrink \u03b1) :\n    (equivShrink \u03b1).symm (-x) = -(equivShrink \u03b1).symm x := by\n  rw [Equiv.neg_def]\n  simp", "start": [96, 1], "end": [100, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_neg", "code": "@[simp]\nlemma equivShrink_neg [Neg \u03b1] [Small \u03b1] (x : \u03b1) :\n    equivShrink \u03b1 (-x) = -equivShrink \u03b1 x := by\n  rw [Equiv.neg_def]\n  simp", "start": [102, 1], "end": [106, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_symm_inv", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_symm_inv [Inv \u03b1] [Small \u03b1] (x : Shrink \u03b1) :\n    (equivShrink \u03b1).symm x\u207b\u00b9 = ((equivShrink \u03b1).symm x)\u207b\u00b9 := by\n  rw [Equiv.inv_def]\n  simp", "start": [108, 1], "end": [112, 7], "kind": "mathlibtacticlemma"}, {"full_name": "equivShrink_inv", "code": "@[to_additive existing (attr := simp)]\nlemma equivShrink_inv [Inv \u03b1] [Small \u03b1] (x : \u03b1) :\n    equivShrink \u03b1 x\u207b\u00b9 = (equivShrink \u03b1 x)\u207b\u00b9 := by\n  rw [Equiv.inv_def]\n  simp", "start": [114, 1], "end": [118, 7], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Logic/Small/Ring.lean", "imports": ["Mathlib/Logic/Equiv/TransferInstance.lean", "Mathlib/Logic/Small/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Probability/IdentDistrib.lean", "imports": ["Mathlib/Probability/Variance.lean", "Mathlib/MeasureTheory/Function/UniformIntegrable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ProbabilityTheory.IdentDistrib", "code": "structure IdentDistrib (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3)\n    (\u03bc : Measure \u03b1 := by volume_tac)\n    (\u03bd : Measure \u03b2 := by volume_tac) : Prop where\n  aemeasurable_fst : AEMeasurable f \u03bc\n  aemeasurable_snd : AEMeasurable g \u03bd\n  map_eq : Measure.map f \u03bc = Measure.map g \u03bd", "start": [65, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.refl", "code": "protected theorem refl (hf : AEMeasurable f \u03bc) : IdentDistrib f f \u03bc \u03bc", "start": [82, 1], "end": [85, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.symm", "code": "protected theorem symm (h : IdentDistrib f g \u03bc \u03bd) : IdentDistrib g f \u03bd \u03bc", "start": [88, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.trans", "code": "protected theorem trans {\u03c1 : Measure \u03b4} {h : \u03b4 \u2192 \u03b3} (h\u2081 : IdentDistrib f g \u03bc \u03bd)\n    (h\u2082 : IdentDistrib g h \u03bd \u03c1) : IdentDistrib f h \u03bc \u03c1", "start": [94, 1], "end": [98, 42], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.comp_of_aemeasurable", "code": "protected theorem comp_of_aemeasurable {u : \u03b3 \u2192 \u03b4} (h : IdentDistrib f g \u03bc \u03bd)\n    (hu : AEMeasurable u (Measure.map f \u03bc)) : IdentDistrib (u \u2218 f) (u \u2218 g) \u03bc \u03bd", "start": [101, 1], "end": [108, 25], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.comp", "code": "protected theorem comp {u : \u03b3 \u2192 \u03b4} (h : IdentDistrib f g \u03bc \u03bd) (hu : Measurable u) :\n    IdentDistrib (u \u2218 f) (u \u2218 g) \u03bc \u03bd", "start": [111, 1], "end": [113, 41], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.of_ae_eq", "code": "protected theorem of_ae_eq {g : \u03b1 \u2192 \u03b3} (hf : AEMeasurable f \u03bc) (heq : f =\u1d50[\u03bc] g) :\n    IdentDistrib f g \u03bc \u03bc", "start": [116, 1], "end": [120, 38], "kind": "commanddeclaration"}, {"full_name": "MeasureTheory.AEMeasurable.identDistrib_mk", "code": "lemma _root_.MeasureTheory.AEMeasurable.identDistrib_mk\n    (hf : AEMeasurable f \u03bc) : IdentDistrib f (hf.mk f) \u03bc \u03bc :=\n  IdentDistrib.of_ae_eq hf hf.ae_eq_mk", "start": [123, 1], "end": [125, 39], "kind": "mathlibtacticlemma"}, {"full_name": "MeasureTheory.AEStronglyMeasurable.identDistrib_mk", "code": "lemma _root_.MeasureTheory.AEStronglyMeasurable.identDistrib_mk\n    [TopologicalSpace \u03b3] [PseudoMetrizableSpace \u03b3] [BorelSpace \u03b3]\n    (hf : AEStronglyMeasurable f \u03bc) : IdentDistrib f (hf.mk f) \u03bc \u03bc :=\n  IdentDistrib.of_ae_eq hf.aemeasurable hf.ae_eq_mk", "start": [127, 1], "end": [130, 52], "kind": "mathlibtacticlemma"}, {"full_name": "ProbabilityTheory.IdentDistrib.measure_mem_eq", "code": "theorem measure_mem_eq (h : IdentDistrib f g \u03bc \u03bd) {s : Set \u03b3} (hs : MeasurableSet s) :\n    \u03bc (f \u207b\u00b9' s) = \u03bd (g \u207b\u00b9' s)", "start": [132, 1], "end": [135, 71], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.measure_preimage_eq", "code": "alias measure_preimage_eq := measure_mem_eq", "start": [138, 1], "end": [138, 44], "kind": "stdtacticaliasalias"}, {"full_name": "ProbabilityTheory.IdentDistrib.ae_snd", "code": "theorem ae_snd (h : IdentDistrib f g \u03bc \u03bd) {p : \u03b3 \u2192 Prop} (pmeas : MeasurableSet {x | p x})\n    (hp : \u2200\u1d50 x \u2202\u03bc, p (f x)) : \u2200\u1d50 x \u2202\u03bd, p (g x)", "start": [141, 1], "end": [145, 51], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.ae_mem_snd", "code": "theorem ae_mem_snd (h : IdentDistrib f g \u03bc \u03bd) {t : Set \u03b3} (tmeas : MeasurableSet t)\n    (ht : \u2200\u1d50 x \u2202\u03bc, f x \u2208 t) : \u2200\u1d50 x \u2202\u03bd, g x \u2208 t", "start": [148, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.aestronglyMeasurable_fst", "code": "theorem aestronglyMeasurable_fst [TopologicalSpace \u03b3] [MetrizableSpace \u03b3] [OpensMeasurableSpace \u03b3]\n    [SecondCountableTopology \u03b3] (h : IdentDistrib f g \u03bc \u03bd) : AEStronglyMeasurable f \u03bc", "start": [153, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.aestronglyMeasurable_snd", "code": "theorem aestronglyMeasurable_snd [TopologicalSpace \u03b3] [MetrizableSpace \u03b3] [BorelSpace \u03b3]\n    (h : IdentDistrib f g \u03bc \u03bd) (hf : AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable g \u03bd", "start": [161, 1], "end": [168, 56], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.aestronglyMeasurable_iff", "code": "theorem aestronglyMeasurable_iff [TopologicalSpace \u03b3] [MetrizableSpace \u03b3] [BorelSpace \u03b3]\n    (h : IdentDistrib f g \u03bc \u03bd) : AEStronglyMeasurable f \u03bc \u2194 AEStronglyMeasurable g \u03bd", "start": [171, 1], "end": [173, 90], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.essSup_eq", "code": "theorem essSup_eq [ConditionallyCompleteLinearOrder \u03b3] [TopologicalSpace \u03b3] [OpensMeasurableSpace \u03b3]\n    [OrderClosedTopology \u03b3] (h : IdentDistrib f g \u03bc \u03bd) : essSup f \u03bc = essSup g \u03bd", "start": [176, 1], "end": [180, 30], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.lintegral_eq", "code": "theorem lintegral_eq {f : \u03b1 \u2192 \u211d\u22650\u221e} {g : \u03b2 \u2192 \u211d\u22650\u221e} (h : IdentDistrib f g \u03bc \u03bd) :\n    \u222b\u207b x, f x \u2202\u03bc = \u222b\u207b x, g x \u2202\u03bd", "start": [183, 1], "end": [187, 65], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.integral_eq", "code": "theorem integral_eq [NormedAddCommGroup \u03b3] [NormedSpace \u211d \u03b3] [BorelSpace \u03b3]\n    (h : IdentDistrib f g \u03bc \u03bd) : \u222b x, f x \u2202\u03bc = \u222b x, g x \u2202\u03bd", "start": [190, 1], "end": [206, 46], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.snorm_eq", "code": "theorem snorm_eq [NormedAddCommGroup \u03b3] [OpensMeasurableSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd)\n    (p : \u211d\u22650\u221e) : snorm f p \u03bc = snorm g p \u03bd", "start": [209, 1], "end": [221, 14], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.mem\u2112p_snd", "code": "theorem mem\u2112p_snd [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] {p : \u211d\u22650\u221e} (h : IdentDistrib f g \u03bc \u03bd)\n    (hf : Mem\u2112p f p \u03bc) : Mem\u2112p g p \u03bd", "start": [224, 1], "end": [228, 13], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.mem\u2112p_iff", "code": "theorem mem\u2112p_iff [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] {p : \u211d\u22650\u221e} (h : IdentDistrib f g \u03bc \u03bd) :\n    Mem\u2112p f p \u03bc \u2194 Mem\u2112p g p \u03bd", "start": [231, 1], "end": [233, 60], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.integrable_snd", "code": "theorem integrable_snd [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd)\n    (hf : Integrable f \u03bc) : Integrable g \u03bd", "start": [236, 1], "end": [239, 23], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.integrable_iff", "code": "theorem integrable_iff [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd) :\n    Integrable f \u03bc \u2194 Integrable g \u03bd", "start": [242, 1], "end": [244, 70], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.norm", "code": "protected theorem norm [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd) :\n    IdentDistrib (fun x => \u2016f x\u2016) (fun x => \u2016g x\u2016) \u03bc \u03bd", "start": [247, 1], "end": [249, 25], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.nnnorm", "code": "protected theorem nnnorm [NormedAddCommGroup \u03b3] [BorelSpace \u03b3] (h : IdentDistrib f g \u03bc \u03bd) :\n    IdentDistrib (fun x => \u2016f x\u2016\u208a) (fun x => \u2016g x\u2016\u208a) \u03bc \u03bd", "start": [252, 1], "end": [254, 27], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.pow", "code": "protected theorem pow [Pow \u03b3 \u2115] [MeasurablePow \u03b3 \u2115] (h : IdentDistrib f g \u03bc \u03bd) {n : \u2115} :\n    IdentDistrib (fun x => f x ^ n) (fun x => g x ^ n) \u03bc \u03bd", "start": [257, 1], "end": [259, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.sq", "code": "protected theorem sq [Pow \u03b3 \u2115] [MeasurablePow \u03b3 \u2115] (h : IdentDistrib f g \u03bc \u03bd) :\n    IdentDistrib (fun x => f x ^ 2) (fun x => g x ^ 2) \u03bc \u03bd", "start": [262, 1], "end": [264, 37], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.coe_nnreal_ennreal", "code": "protected theorem coe_nnreal_ennreal {f : \u03b1 \u2192 \u211d\u22650} {g : \u03b2 \u2192 \u211d\u22650} (h : IdentDistrib f g \u03bc \u03bd) :\n    IdentDistrib (fun x => (f x : \u211d\u22650\u221e)) (fun x => (g x : \u211d\u22650\u221e)) \u03bc \u03bd", "start": [267, 1], "end": [269, 39], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.mul_const", "code": "@[to_additive]\ntheorem mul_const [Mul \u03b3] [MeasurableMul \u03b3] (h : IdentDistrib f g \u03bc \u03bd) (c : \u03b3) :\n    IdentDistrib (fun x => f x * c) (fun x => g x * c) \u03bc \u03bd", "start": [272, 1], "end": [275, 34], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.const_mul", "code": "@[to_additive]\ntheorem const_mul [Mul \u03b3] [MeasurableMul \u03b3] (h : IdentDistrib f g \u03bc \u03bd) (c : \u03b3) :\n    IdentDistrib (fun x => c * f x) (fun x => c * g x) \u03bc \u03bd", "start": [279, 1], "end": [282, 34], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.div_const", "code": "@[to_additive]\ntheorem div_const [Div \u03b3] [MeasurableDiv \u03b3] (h : IdentDistrib f g \u03bc \u03bd) (c : \u03b3) :\n    IdentDistrib (fun x => f x / c) (fun x => g x / c) \u03bc \u03bd", "start": [286, 1], "end": [289, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.const_div", "code": "@[to_additive]\ntheorem const_div [Div \u03b3] [MeasurableDiv \u03b3] (h : IdentDistrib f g \u03bc \u03bd) (c : \u03b3) :\n    IdentDistrib (fun x => c / f x) (fun x => c / g x) \u03bc \u03bd", "start": [293, 1], "end": [296, 48], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.evariance_eq", "code": "theorem evariance_eq {f : \u03b1 \u2192 \u211d} {g : \u03b2 \u2192 \u211d} (h : IdentDistrib f g \u03bc \u03bd) :\n    evariance f \u03bc = evariance g \u03bd", "start": [300, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.IdentDistrib.variance_eq", "code": "theorem variance_eq {f : \u03b1 \u2192 \u211d} {g : \u03b2 \u2192 \u211d} (h : IdentDistrib f g \u03bc \u03bd) :\n    variance f \u03bc = variance g \u03bd", "start": [307, 1], "end": [308, 73], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.Mem\u2112p.uniformIntegrable_of_identDistrib_aux", "code": "theorem Mem\u2112p.uniformIntegrable_of_identDistrib_aux {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 E} {j : \u03b9} {p : \u211d\u22650\u221e}\n    (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (h\u2112p : Mem\u2112p (f j) p \u03bc) (hfmeas : \u2200 i, StronglyMeasurable (f i))\n    (hf : \u2200 i, IdentDistrib (f i) (f j) \u03bc \u03bc) : UniformIntegrable f p \u03bc", "start": [320, 1], "end": [344, 90], "kind": "commanddeclaration"}, {"full_name": "ProbabilityTheory.Mem\u2112p.uniformIntegrable_of_identDistrib", "code": "theorem Mem\u2112p.uniformIntegrable_of_identDistrib {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 E} {j : \u03b9} {p : \u211d\u22650\u221e}\n    (hp : 1 \u2264 p) (hp' : p \u2260 \u221e) (h\u2112p : Mem\u2112p (f j) p \u03bc) (hf : \u2200 i, IdentDistrib (f i) (f j) \u03bc \u03bc) :\n    UniformIntegrable f p \u03bc", "start": [347, 1], "end": [360, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Analysis/SpecificLimits/FloorPow.lean", "imports": ["Mathlib/Analysis/SpecificLimits/Basic.lean", "Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tendsto_div_of_monotone_of_exists_subseq_tendsto_div", "code": "theorem tendsto_div_of_monotone_of_exists_subseq_tendsto_div (u : \u2115 \u2192 \u211d) (l : \u211d)\n    (hmono : Monotone u)\n    (hlim : \u2200 a : \u211d, 1 < a \u2192 \u2203 c : \u2115 \u2192 \u2115, (\u2200\u1da0 n in atTop, (c (n + 1) : \u211d) \u2264 a * c n) \u2227\n      Tendsto c atTop atTop \u2227 Tendsto (fun n => u (c n) / c n) atTop (\ud835\udcdd l)) :\n    Tendsto (fun n => u n / n) atTop (\ud835\udcdd l)", "start": [28, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "tendsto_div_of_monotone_of_tendsto_div_floor_pow", "code": "theorem tendsto_div_of_monotone_of_tendsto_div_floor_pow (u : \u2115 \u2192 \u211d) (l : \u211d) (hmono : Monotone u)\n    (c : \u2115 \u2192 \u211d) (cone : \u2200 k, 1 < c k) (clim : Tendsto c atTop (\ud835\udcdd 1))\n    (hc : \u2200 k, Tendsto (fun n : \u2115 => u \u230ac k ^ n\u230b\u208a / \u230ac k ^ n\u230b\u208a) atTop (\ud835\udcdd l)) :\n    Tendsto (fun n => u n / n) atTop (\ud835\udcdd l)", "start": [206, 1], "end": [239, 35], "kind": "commanddeclaration"}, {"full_name": "sum_div_pow_sq_le_div_sq", "code": "theorem sum_div_pow_sq_le_div_sq (N : \u2115) {j : \u211d} (hj : 0 < j) {c : \u211d} (hc : 1 < c) :\n    (\u2211 i in (range N).filter (j < c ^ \u00b7), (1 : \u211d) / (c ^ i) ^ 2) \u2264 c ^ 3 * (c - 1)\u207b\u00b9 / j ^ 2", "start": [242, 1], "end": [299, 79], "kind": "commanddeclaration"}, {"full_name": "mul_pow_le_nat_floor_pow", "code": "theorem mul_pow_le_nat_floor_pow {c : \u211d} (hc : 1 < c) (i : \u2115) : (1 - c\u207b\u00b9) * c ^ i \u2264 \u230ac ^ i\u230b\u208a", "start": [303, 1], "end": [313, 48], "kind": "commanddeclaration"}, {"full_name": "sum_div_nat_floor_pow_sq_le_div_sq", "code": "theorem sum_div_nat_floor_pow_sq_le_div_sq (N : \u2115) {j : \u211d} (hj : 0 < j) {c : \u211d} (hc : 1 < c) :\n    (\u2211 i in (range N).filter (j < \u230ac ^ \u00b7\u230b\u208a), (1 : \u211d) / (\u230ac ^ i\u230b\u208a : \u211d) ^ 2) \u2264\n      c ^ 5 * (c - 1)\u207b\u00b9 ^ 3 / j ^ 2", "start": [317, 1], "end": [352, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PNat/Interval.lean", "imports": ["Mathlib/Data/PNat/Defs.lean", "Mathlib/Data/Nat/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PNat.Icc_eq_finset_subtype", "code": "theorem Icc_eq_finset_subtype : Icc a b = (Icc (a : \u2115) b).subtype fun n : \u2115 => 0 < n", "start": [28, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.Ico_eq_finset_subtype", "code": "theorem Ico_eq_finset_subtype : Ico a b = (Ico (a : \u2115) b).subtype fun n : \u2115 => 0 < n", "start": [32, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.Ioc_eq_finset_subtype", "code": "theorem Ioc_eq_finset_subtype : Ioc a b = (Ioc (a : \u2115) b).subtype fun n : \u2115 => 0 < n", "start": [36, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.Ioo_eq_finset_subtype", "code": "theorem Ioo_eq_finset_subtype : Ioo a b = (Ioo (a : \u2115) b).subtype fun n : \u2115 => 0 < n", "start": [40, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.uIcc_eq_finset_subtype", "code": "theorem uIcc_eq_finset_subtype : uIcc a b = (uIcc (a : \u2115) b).subtype fun n : \u2115 => 0 < n", "start": [44, 1], "end": [44, 95], "kind": "commanddeclaration"}, {"full_name": "PNat.map_subtype_embedding_Icc", "code": "theorem map_subtype_embedding_Icc : (Icc a b).map (Embedding.subtype _) = Icc \u2191a \u2191b", "start": [47, 1], "end": [48, 81], "kind": "commanddeclaration"}, {"full_name": "PNat.map_subtype_embedding_Ico", "code": "theorem map_subtype_embedding_Ico : (Ico a b).map (Embedding.subtype _) = Ico \u2191a \u2191b", "start": [51, 1], "end": [52, 81], "kind": "commanddeclaration"}, {"full_name": "PNat.map_subtype_embedding_Ioc", "code": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype _) = Ioc \u2191a \u2191b", "start": [55, 1], "end": [56, 81], "kind": "commanddeclaration"}, {"full_name": "PNat.map_subtype_embedding_Ioo", "code": "theorem map_subtype_embedding_Ioo : (Ioo a b).map (Embedding.subtype _) = Ioo \u2191a \u2191b", "start": [59, 1], "end": [60, 81], "kind": "commanddeclaration"}, {"full_name": "PNat.map_subtype_embedding_uIcc", "code": "theorem map_subtype_embedding_uIcc : (uIcc a b).map (Embedding.subtype _) = uIcc \u2191a \u2191b", "start": [63, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "PNat.card_Icc", "code": "@[simp]\ntheorem card_Icc : (Icc a b).card = b + 1 - a", "start": [67, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.card_Ico", "code": "@[simp]\ntheorem card_Ico : (Ico a b).card = b - a", "start": [76, 1], "end": [82, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.card_Ioc", "code": "@[simp]\ntheorem card_Ioc : (Ioc a b).card = b - a", "start": [85, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.card_Ioo", "code": "@[simp]\ntheorem card_Ioo : (Ioo a b).card = b - a - 1", "start": [94, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "PNat.card_uIcc", "code": "@[simp]\ntheorem card_uIcc : (uIcc a b).card = (b - a : \u2124).natAbs + 1", "start": [103, 1], "end": [105, 61], "kind": "commanddeclaration"}, {"full_name": "PNat.card_fintype_Icc", "code": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = b + 1 - a", "start": [109, 1], "end": [110, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.card_fintype_Ico", "code": "theorem card_fintype_Ico : Fintype.card (Set.Ico a b) = b - a", "start": [114, 1], "end": [115, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.card_fintype_Ioc", "code": "theorem card_fintype_Ioc : Fintype.card (Set.Ioc a b) = b - a", "start": [119, 1], "end": [120, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.card_fintype_Ioo", "code": "theorem card_fintype_Ioo : Fintype.card (Set.Ioo a b) = b - a - 1", "start": [124, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.card_fintype_uIcc", "code": "theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a : \u2124).natAbs + 1", "start": [129, 1], "end": [130, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Fintype.lean", "imports": ["Mathlib/Data/Fintype/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "card_units_lt", "code": "theorem card_units_lt (M\u2080 : Type*) [MonoidWithZero M\u2080] [Nontrivial M\u2080] [Fintype M\u2080] :\n    Fintype.card M\u2080\u02e3 < Fintype.card M\u2080", "start": [17, 1], "end": [19, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/WittVector/FrobeniusFractionField.lean", "imports": ["Mathlib/RingTheory/WittVector/DiscreteValuationRing.lean", "Mathlib/FieldTheory/IsAlgClosed/Basic.lean", "Mathlib/Data/Nat/Cast/WithTop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WittVector.RecursionMain.succNthDefiningPoly", "code": "def succNthDefiningPoly (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) : Polynomial k :=\n  X ^ p * C (a\u2081.coeff 0 ^ p ^ (n + 1)) - X * C (a\u2082.coeff 0 ^ p ^ (n + 1)) +\n    C\n      (a\u2081.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n            nthRemainder p n (fun v => bs v ^ p) (truncateFun (n + 1) a\u2081) -\n          a\u2082.coeff (n + 1) * bs 0 ^ p ^ (n + 1) -\n        nthRemainder p n bs (truncateFun (n + 1) a\u2082))", "start": [69, 1], "end": [76, 54], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionMain.succNthDefiningPoly_degree", "code": "theorem succNthDefiningPoly_degree [IsDomain k] (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k)\n    (ha\u2081 : a\u2081.coeff 0 \u2260 0) (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    (succNthDefiningPoly p n a\u2081 a\u2082 bs).degree = p", "start": [79, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionMain.root_exists", "code": "theorem root_exists (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) (ha\u2081 : a\u2081.coeff 0 \u2260 0)\n    (ha\u2082 : a\u2082.coeff 0 \u2260 0) : \u2203 b : k, (succNthDefiningPoly p n a\u2081 a\u2082 bs).IsRoot b", "start": [104, 1], "end": [108, 41], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionMain.succNthVal", "code": "def succNthVal (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) (ha\u2081 : a\u2081.coeff 0 \u2260 0)\n    (ha\u2082 : a\u2082.coeff 0 \u2260 0) : k :=\n  Classical.choose (root_exists p n a\u2081 a\u2082 bs ha\u2081 ha\u2082)", "start": [111, 1], "end": [114, 54], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionMain.succNthVal_spec", "code": "theorem succNthVal_spec (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) (ha\u2081 : a\u2081.coeff 0 \u2260 0)\n    (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    (succNthDefiningPoly p n a\u2081 a\u2082 bs).IsRoot (succNthVal p n a\u2081 a\u2082 bs ha\u2081 ha\u2082)", "start": [117, 1], "end": [120, 59], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionMain.succNthVal_spec'", "code": "theorem succNthVal_spec' (n : \u2115) (a\u2081 a\u2082 : \ud835\udd4e k) (bs : Fin (n + 1) \u2192 k) (ha\u2081 : a\u2081.coeff 0 \u2260 0)\n    (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    succNthVal p n a\u2081 a\u2082 bs ha\u2081 ha\u2082 ^ p * a\u2081.coeff 0 ^ p ^ (n + 1) +\n          a\u2081.coeff (n + 1) * (bs 0 ^ p) ^ p ^ (n + 1) +\n        nthRemainder p n (fun v => bs v ^ p) (truncateFun (n + 1) a\u2081) =\n      succNthVal p n a\u2081 a\u2082 bs ha\u2081 ha\u2082 * a\u2082.coeff 0 ^ p ^ (n + 1) +\n          a\u2082.coeff (n + 1) * bs 0 ^ p ^ (n + 1) +\n        nthRemainder p n bs (truncateFun (n + 1) a\u2082)", "start": [123, 1], "end": [137, 7], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionBase.solution_pow", "code": "theorem solution_pow (a\u2081 a\u2082 : \ud835\udd4e k) : \u2203 x : k, x ^ (p - 1) = a\u2082.coeff 0 / a\u2081.coeff 0", "start": [148, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionBase.solution", "code": "def solution (a\u2081 a\u2082 : \ud835\udd4e k) : k :=\n  Classical.choose <| solution_pow p a\u2081 a\u2082", "start": [155, 1], "end": [157, 43], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionBase.solution_spec", "code": "theorem solution_spec (a\u2081 a\u2082 : \ud835\udd4e k) : solution p a\u2081 a\u2082 ^ (p - 1) = a\u2082.coeff 0 / a\u2081.coeff 0", "start": [160, 1], "end": [161, 48], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionBase.solution_nonzero", "code": "theorem solution_nonzero {a\u2081 a\u2082 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0) (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    solution p a\u2081 a\u2082 \u2260 0", "start": [164, 1], "end": [172, 39], "kind": "commanddeclaration"}, {"full_name": "WittVector.RecursionBase.solution_spec'", "code": "theorem solution_spec' {a\u2081 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0) (a\u2082 : \ud835\udd4e k) :\n    solution p a\u2081 a\u2082 ^ p * a\u2081.coeff 0 = solution p a\u2081 a\u2082 * a\u2082.coeff 0", "start": [175, 1], "end": [186, 29], "kind": "commanddeclaration"}, {"full_name": "WittVector.frobeniusRotationCoeff", "code": "noncomputable def frobeniusRotationCoeff {a\u2081 a\u2082 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0)\n    (ha\u2082 : a\u2082.coeff 0 \u2260 0) : \u2115 \u2192 k\n  | 0 => solution p a\u2081 a\u2082\n  | n + 1 => succNthVal p n a\u2081 a\u2082 (fun i => frobeniusRotationCoeff ha\u2081 ha\u2082 i.val) ha\u2081 ha\u2082\ndecreasing_by apply Fin.is_lt", "start": [199, 1], "end": [205, 30], "kind": "commanddeclaration"}, {"full_name": "WittVector.frobeniusRotation", "code": "def frobeniusRotation {a\u2081 a\u2082 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0) (ha\u2082 : a\u2082.coeff 0 \u2260 0) : \ud835\udd4e k :=\n  WittVector.mk p (frobeniusRotationCoeff p ha\u2081 ha\u2082)", "start": [208, 1], "end": [212, 53], "kind": "commanddeclaration"}, {"full_name": "WittVector.frobeniusRotation_nonzero", "code": "theorem frobeniusRotation_nonzero {a\u2081 a\u2082 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0) (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    frobeniusRotation p ha\u2081 ha\u2082 \u2260 0", "start": [215, 1], "end": [219, 91], "kind": "commanddeclaration"}, {"full_name": "WittVector.frobenius_frobeniusRotation", "code": "theorem frobenius_frobeniusRotation {a\u2081 a\u2082 : \ud835\udd4e k} (ha\u2081 : a\u2081.coeff 0 \u2260 0) (ha\u2082 : a\u2082.coeff 0 \u2260 0) :\n    frobenius (frobeniusRotation p ha\u2081 ha\u2082) * a\u2081 = frobeniusRotation p ha\u2081 ha\u2082 * a\u2082", "start": [222, 1], "end": [240, 8], "kind": "commanddeclaration"}, {"full_name": "WittVector.exists_frobenius_solution_fractionRing_aux", "code": "theorem exists_frobenius_solution_fractionRing_aux (m n : \u2115) (r' q' : \ud835\udd4e k) (hr' : r'.coeff 0 \u2260 0)\n    (hq' : q'.coeff 0 \u2260 0) (hq : (p : \ud835\udd4e k) ^ n * q' \u2208 nonZeroDivisors (\ud835\udd4e k)) :\n    let b : \ud835\udd4e k := frobeniusRotation p hr' hq'\n    IsFractionRing.fieldEquivOfRingEquiv (frobeniusEquiv p k)\n          (algebraMap (\ud835\udd4e k) (FractionRing (\ud835\udd4e k)) b) *\n        Localization.mk ((p : \ud835\udd4e k) ^ m * r') \u27e8(p : \ud835\udd4e k) ^ n * q', hq\u27e9 =\n      (p : Localization (nonZeroDivisors (\ud835\udd4e k))) ^ (m - n : \u2124) *\n        algebraMap (\ud835\udd4e k) (FractionRing (\ud835\udd4e k)) b", "start": [245, 1], "end": [271, 62], "kind": "commanddeclaration"}, {"full_name": "WittVector.exists_frobenius_solution_fractionRing", "code": "theorem exists_frobenius_solution_fractionRing {a : FractionRing (\ud835\udd4e k)} (ha : a \u2260 0) :\n    \u2203 (b : FractionRing (\ud835\udd4e k)) (hb : b \u2260 0) (m : \u2124),\n      \u03c6 b * a = (p : FractionRing (\ud835\udd4e k)) ^ m * b", "start": [274, 1], "end": [289, 74], "kind": "commanddeclaration"}]}
