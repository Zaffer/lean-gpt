{"path": "Mathlib/Algebra/Order/Monoid/OrderDual.lean", "imports": ["Mathlib/Algebra/Group/OrderSynonym.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderDual.contravariantClass_mul_le", "code": "@[to_additive]\ninstance contravariantClass_mul_le [LE \u03b1] [Mul \u03b1] [c : ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n    ContravariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [22, 1], "end": [25, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.covariantClass_mul_le", "code": "@[to_additive]\ninstance covariantClass_mul_le [LE \u03b1] [Mul \u03b1] [c : CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [29, 1], "end": [32, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.contravariantClass_swap_mul_le", "code": "@[to_additive]\ninstance contravariantClass_swap_mul_le [LE \u03b1] [Mul \u03b1]\n    [c : ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    ContravariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [36, 1], "end": [40, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.covariantClass_swap_mul_le", "code": "@[to_additive]\ninstance covariantClass_swap_mul_le [LE \u03b1] [Mul \u03b1]\n    [c : CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [44, 1], "end": [48, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.contravariantClass_mul_lt", "code": "@[to_additive]\ninstance contravariantClass_mul_lt [LT \u03b1] [Mul \u03b1] [c : ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (\u00b7 * \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [52, 1], "end": [55, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.covariantClass_mul_lt", "code": "@[to_additive]\ninstance covariantClass_mul_lt [LT \u03b1] [Mul \u03b1] [c : CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] :\n    CovariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (\u00b7 * \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [59, 1], "end": [62, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.contravariantClass_swap_mul_lt", "code": "@[to_additive]\ninstance contravariantClass_swap_mul_lt [LT \u03b1] [Mul \u03b1]\n    [c : ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] :\n    ContravariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [66, 1], "end": [70, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.covariantClass_swap_mul_lt", "code": "@[to_additive]\ninstance covariantClass_swap_mul_lt [LT \u03b1] [Mul \u03b1]\n    [c : CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] :\n    CovariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8c.1.flip\u27e9", "start": [74, 1], "end": [78, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.orderedCommMonoid", "code": "@[to_additive]\ninstance orderedCommMonoid [OrderedCommMonoid \u03b1] : OrderedCommMonoid \u03b1\u1d52\u1d48 :=\n  { OrderDual.instPartialOrder \u03b1, OrderDual.instCommMonoid with\n    mul_le_mul_left := fun _ _ h c => mul_le_mul_left' h c }", "start": [82, 1], "end": [85, 61], "kind": "commanddeclaration"}, {"full_name": "OrderDual.OrderedCancelCommMonoid.to_contravariantClass", "code": "@[to_additive OrderDual.OrderedCancelAddCommMonoid.to_contravariantClass]\ninstance OrderedCancelCommMonoid.to_contravariantClass [OrderedCancelCommMonoid \u03b1] :\n    ContravariantClass \u03b1\u1d52\u1d48 \u03b1\u1d52\u1d48 Mul.mul LE.le where\n    elim a b c := @OrderedCancelCommMonoid.le_of_mul_le_mul_left \u03b1 _ a c b", "start": [89, 1], "end": [95, 75], "kind": "commanddeclaration"}, {"full_name": "OrderDual.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance orderedCancelCommMonoid [OrderedCancelCommMonoid \u03b1] : OrderedCancelCommMonoid \u03b1\u1d52\u1d48 :=\n  { OrderDual.orderedCommMonoid, @OrderDual.instCancelCommMonoid \u03b1 _ with\n    le_of_mul_le_mul_left := fun _ _ _ : \u03b1 => le_of_mul_le_mul_left' }", "start": [100, 1], "end": [103, 71], "kind": "commanddeclaration"}, {"full_name": "OrderDual.linearOrderedCancelCommMonoid", "code": "@[to_additive]\ninstance linearOrderedCancelCommMonoid [LinearOrderedCancelCommMonoid \u03b1] :\n    LinearOrderedCancelCommMonoid \u03b1\u1d52\u1d48 :=\n  { OrderDual.instLinearOrder \u03b1, OrderDual.orderedCancelCommMonoid with }", "start": [105, 1], "end": [108, 74], "kind": "commanddeclaration"}, {"full_name": "OrderDual.linearOrderedCommMonoid", "code": "@[to_additive]\ninstance linearOrderedCommMonoid [LinearOrderedCommMonoid \u03b1] : LinearOrderedCommMonoid \u03b1\u1d52\u1d48 :=\n  { OrderDual.instLinearOrder \u03b1, OrderDual.orderedCommMonoid with }", "start": [110, 1], "end": [112, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Units.lean", "imports": ["Mathlib/Algebra/Group/Units.lean", "Mathlib/Order/MinMax.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.val_le_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_le_val [Monoid \u03b1] [Preorder \u03b1] {a b : \u03b1\u02e3} : (a : \u03b1) \u2264 b \u2194 a \u2264 b", "start": [24, 1], "end": [26, 10], "kind": "commanddeclaration"}, {"full_name": "Units.val_lt_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_lt_val [Monoid \u03b1] [Preorder \u03b1] {a b : \u03b1\u02e3} : (a : \u03b1) < b \u2194 a < b", "start": [30, 1], "end": [32, 10], "kind": "commanddeclaration"}, {"full_name": "Units.instPartialOrderUnits", "code": "@[to_additive]\ninstance instPartialOrderUnits [Monoid \u03b1] [PartialOrder \u03b1] : PartialOrder \u03b1\u02e3 :=\n  PartialOrder.lift val Units.ext", "start": [36, 1], "end": [38, 34], "kind": "commanddeclaration"}, {"full_name": "Units.orderEmbeddingVal", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n  \"`val : add_units \u03b1 \u2192 \u03b1` as an order embedding.\"]\ndef orderEmbeddingVal [Monoid \u03b1] [LinearOrder \u03b1] : \u03b1\u02e3 \u21aao \u03b1 :=\n  \u27e8\u27e8val, ext\u27e9, Iff.rfl\u27e9", "start": [46, 1], "end": [50, 24], "kind": "commanddeclaration"}, {"full_name": "Units.max_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem max_val [Monoid \u03b1] [LinearOrder \u03b1] {a b : \u03b1\u02e3} : (max a b).val = max a.val b.val", "start": [54, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "Units.min_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem min_val [Monoid \u03b1] [LinearOrder \u03b1] {a b : \u03b1\u02e3} : (min a b).val = min a.val b.val", "start": [60, 1], "end": [62, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Semiconj.lean", "imports": ["Mathlib/Init/Classical.lean", "Mathlib/Algebra/Group/Semiconj/Units.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy.zero_right", "code": "@[simp]\ntheorem zero_right [MulZeroClass G\u2080] (a : G\u2080) : SemiconjBy a 0 0", "start": [22, 1], "end": [24, 45], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.zero_left", "code": "@[simp]\ntheorem zero_left [MulZeroClass G\u2080] (x y : G\u2080) : SemiconjBy 0 x y", "start": [27, 1], "end": [29, 45], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_symm_left_iff\u2080", "code": "@[simp]\ntheorem inv_symm_left_iff\u2080 : SemiconjBy a\u207b\u00b9 x y \u2194 SemiconjBy a y x", "start": [34, 1], "end": [37, 54], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_symm_left\u2080", "code": "theorem inv_symm_left\u2080 (h : SemiconjBy a x y) : SemiconjBy a\u207b\u00b9 y x", "start": [40, 1], "end": [41, 36], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_right\u2080", "code": "theorem inv_right\u2080 (h : SemiconjBy a x y) : SemiconjBy a x\u207b\u00b9 y\u207b\u00b9", "start": [44, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_right_iff\u2080", "code": "@[simp]\ntheorem inv_right_iff\u2080 : SemiconjBy a x\u207b\u00b9 y\u207b\u00b9 \u2194 SemiconjBy a x y", "start": [56, 1], "end": [58, 62], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.div_right", "code": "theorem div_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x / x') (y / y')", "start": [61, 1], "end": [64, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Commute/Units.lean", "imports": ["Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Group/Semiconj/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Commute.units_inv_right", "code": "@[to_additive]\ntheorem units_inv_right : Commute a u \u2192 Commute a \u2191u\u207b\u00b9", "start": [25, 1], "end": [27, 29], "kind": "commanddeclaration"}, {"full_name": "Commute.units_inv_right_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_inv_right_iff : Commute a \u2191u\u207b\u00b9 \u2194 Commute a u", "start": [31, 1], "end": [33, 33], "kind": "commanddeclaration"}, {"full_name": "Commute.units_inv_left", "code": "@[to_additive]\ntheorem units_inv_left : Commute (\u2191u) a \u2192 Commute (\u2191u\u207b\u00b9) a", "start": [37, 1], "end": [39, 33], "kind": "commanddeclaration"}, {"full_name": "Commute.units_inv_left_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_inv_left_iff : Commute (\u2191u\u207b\u00b9) a \u2194 Commute (\u2191u) a", "start": [43, 1], "end": [45, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.units_val", "code": "@[to_additive]\ntheorem units_val : Commute u\u2081 u\u2082 \u2192 Commute (u\u2081 : M) u\u2082", "start": [49, 1], "end": [51, 23], "kind": "commanddeclaration"}, {"full_name": "Commute.units_of_val", "code": "@[to_additive]\ntheorem units_of_val : Commute (u\u2081 : M) u\u2082 \u2192 Commute u\u2081 u\u2082", "start": [55, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "Commute.units_val_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_val_iff : Commute (u\u2081 : M) u\u2082 \u2194 Commute u\u2081 u\u2082", "start": [61, 1], "end": [63, 27], "kind": "commanddeclaration"}, {"full_name": "Units.leftOfMul", "code": "@[to_additive \"If the sum of two commuting elements is an additive unit, then the left summand is\nan additive unit.\"]\ndef _root_.Units.leftOfMul (u : M\u02e3) (a b : M) (hu : a * b = u) (hc : Commute a b) : M\u02e3 where\n  val := a\n  inv := b * \u2191u\u207b\u00b9\n  val_inv := by rw [\u2190 mul_assoc, hu, u.mul_inv]\n  inv_val := by\n    have : Commute a u := hu \u25b8 (Commute.refl _).mul_right hc\n    rw [\u2190 this.units_inv_right.right_comm, \u2190 hc.eq, hu, u.mul_inv]", "start": [67, 1], "end": [76, 67], "kind": "commanddeclaration"}, {"full_name": "Units.rightOfMul", "code": "@[to_additive \"If the sum of two commuting elements is an additive unit, then the right summand\nis an additive unit.\"]\ndef _root_.Units.rightOfMul (u : M\u02e3) (a b : M) (hu : a * b = u) (hc : Commute a b) : M\u02e3 :=\n  u.leftOfMul b a (hc.eq \u25b8 hu) hc.symm", "start": [80, 1], "end": [84, 39], "kind": "commanddeclaration"}, {"full_name": "Commute.isUnit_mul_iff", "code": "@[to_additive]\ntheorem isUnit_mul_iff (h : Commute a b) : IsUnit (a * b) \u2194 IsUnit a \u2227 IsUnit b", "start": [88, 1], "end": [91, 24], "kind": "commanddeclaration"}, {"full_name": "isUnit_mul_self_iff", "code": "@[to_additive (attr := simp)]\ntheorem _root_.isUnit_mul_self_iff : IsUnit (a * a) \u2194 IsUnit a", "start": [95, 1], "end": [97, 57], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_right", "code": "@[to_additive]\ntheorem inv_right : Commute a b \u2192 Commute a b\u207b\u00b9", "start": [108, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_right_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_right_iff : Commute a b\u207b\u00b9 \u2194 Commute a b", "start": [114, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_left", "code": "@[to_additive]\ntheorem inv_left : Commute a b \u2192 Commute a\u207b\u00b9 b", "start": [120, 1], "end": [122, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_left_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_left_iff : Commute a\u207b\u00b9 b \u2194 Commute a b", "start": [126, 1], "end": [128, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_mul_cancel", "code": "@[to_additive]\nprotected theorem inv_mul_cancel (h : Commute a b) : a\u207b\u00b9 * b * a = b", "start": [132, 1], "end": [134, 43], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_mul_cancel_assoc", "code": "@[to_additive]\ntheorem inv_mul_cancel_assoc (h : Commute a b) : a\u207b\u00b9 * (b * a) = b", "start": [138, 1], "end": [140, 37], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_comm", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_comm : a\u207b\u00b9 * b * a = b", "start": [152, 1], "end": [154, 35], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_comm_assoc", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_comm_assoc : a\u207b\u00b9 * (b * a) = b", "start": [158, 1], "end": [160, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Semiconj.lean", "imports": ["Mathlib/Algebra/Group/Semiconj/Defs.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy.add_right", "code": "@[simp]\ntheorem add_right [Distrib R] {a x y x' y' : R} (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x + x') (y + y')", "start": [32, 1], "end": [35, 67], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.add_left", "code": "@[simp]\ntheorem add_left [Distrib R] {a b x y : R} (ha : SemiconjBy a x y) (hb : SemiconjBy b x y) :\n    SemiconjBy (a + b) x y", "start": [38, 1], "end": [41, 68], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_right", "code": "theorem neg_right (h : SemiconjBy a x y) : SemiconjBy a (-x) (-y)", "start": [48, 1], "end": [49, 49], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_right_iff", "code": "@[simp]\ntheorem neg_right_iff : SemiconjBy a (-x) (-y) \u2194 SemiconjBy a x y", "start": [52, 1], "end": [54, 71], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_left", "code": "theorem neg_left (h : SemiconjBy a x y) : SemiconjBy (-a) x y", "start": [57, 1], "end": [58, 49], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_left_iff", "code": "@[simp]\ntheorem neg_left_iff : SemiconjBy (-a) x y \u2194 SemiconjBy a x y", "start": [61, 1], "end": [63, 57], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_one_right", "code": "theorem neg_one_right (a : R) : SemiconjBy a (-1) (-1)", "start": [73, 1], "end": [74, 26], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.neg_one_left", "code": "theorem neg_one_left (x : R) : SemiconjBy (-1) x x", "start": [78, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.sub_right", "code": "@[simp]\ntheorem sub_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x - x') (y - y')", "start": [88, 1], "end": [91, 61], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.sub_left", "code": "@[simp]\ntheorem sub_left (ha : SemiconjBy a x y) (hb : SemiconjBy b x y) :\n    SemiconjBy (a - b) x y", "start": [94, 1], "end": [97, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Units.lean", "imports": ["Mathlib/Algebra/Ring/InjSurj.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.val_neg", "code": "@[simp, norm_cast]\nprotected theorem val_neg (u : \u03b1\u02e3) : (\u2191(-u) : \u03b1) = -u", "start": [33, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Units.coe_neg_one", "code": "@[simp, norm_cast]\nprotected theorem coe_neg_one : ((-1 : \u03b1\u02e3) : \u03b1) = -1", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Units.neg_divp", "code": "@[field_simps]\ntheorem neg_divp (a : \u03b1) (u : \u03b1\u02e3) : -(a /\u209a u) = -a /\u209a u", "start": [48, 1], "end": [49, 88], "kind": "commanddeclaration"}, {"full_name": "Units.divp_add_divp_same", "code": "@[field_simps 1010]\ntheorem divp_add_divp_same (a b : \u03b1) (u : \u03b1\u02e3) : a /\u209a u + b /\u209a u = (a + b) /\u209a u", "start": [59, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "Units.divp_sub_divp_same", "code": "@[field_simps 1010]\ntheorem divp_sub_divp_same (a b : \u03b1) (u : \u03b1\u02e3) : a /\u209a u - b /\u209a u = (a - b) /\u209a u", "start": [65, 1], "end": [67, 68], "kind": "commanddeclaration"}, {"full_name": "Units.add_divp", "code": "@[field_simps]\ntheorem add_divp (a b : \u03b1) (u : \u03b1\u02e3) : a + b /\u209a u = (a * u + b) /\u209a u", "start": [70, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "Units.sub_divp", "code": "@[field_simps]\ntheorem sub_divp (a b : \u03b1) (u : \u03b1\u02e3) : a - b /\u209a u = (a * u - b) /\u209a u", "start": [75, 1], "end": [77, 56], "kind": "commanddeclaration"}, {"full_name": "Units.divp_add", "code": "@[field_simps]\ntheorem divp_add (a b : \u03b1) (u : \u03b1\u02e3) : a /\u209a u + b = (a + b * u) /\u209a u", "start": [80, 1], "end": [82, 56], "kind": "commanddeclaration"}, {"full_name": "Units.divp_sub", "code": "@[field_simps]\ntheorem divp_sub (a b : \u03b1) (u : \u03b1\u02e3) : a /\u209a u - b = (a - b * u) /\u209a u", "start": [85, 1], "end": [88, 41], "kind": "commanddeclaration"}, {"full_name": "IsUnit.neg", "code": "theorem IsUnit.neg [Monoid \u03b1] [HasDistribNeg \u03b1] {a : \u03b1} : IsUnit a \u2192 IsUnit (-a)", "start": [95, 1], "end": [96, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.neg_iff", "code": "@[simp]\ntheorem IsUnit.neg_iff [Monoid \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) : IsUnit (-a) \u2194 IsUnit a", "start": [99, 1], "end": [101, 43], "kind": "commanddeclaration"}, {"full_name": "isUnit_neg_one", "code": "theorem isUnit_neg_one [Monoid \u03b1] [HasDistribNeg \u03b1] : IsUnit (-1 : \u03b1)", "start": [104, 1], "end": [104, 88], "kind": "commanddeclaration"}, {"full_name": "IsUnit.sub_iff", "code": "theorem IsUnit.sub_iff [Ring \u03b1] {x y : \u03b1} : IsUnit (x - y) \u2194 IsUnit (y - x)", "start": [106, 1], "end": [107, 57], "kind": "commanddeclaration"}, {"full_name": "Units.divp_add_divp", "code": "@[field_simps]\ntheorem divp_add_divp [CommRing \u03b1] (a b : \u03b1) (u\u2081 u\u2082 : \u03b1\u02e3) :\n    a /\u209a u\u2081 + b /\u209a u\u2082 = (a * u\u2082 + u\u2081 * b) /\u209a (u\u2081 * u\u2082)", "start": [112, 1], "end": [118, 13], "kind": "commanddeclaration"}, {"full_name": "Units.divp_sub_divp", "code": "@[field_simps]\ntheorem divp_sub_divp [CommRing \u03b1] (a b : \u03b1) (u\u2081 u\u2082 : \u03b1\u02e3) :\n    a /\u209a u\u2081 - b /\u209a u\u2082 = (a * u\u2082 - u\u2081 * b) /\u209a (u\u2081 * u\u2082)", "start": [122, 1], "end": [125, 63], "kind": "commanddeclaration"}, {"full_name": "Units.add_eq_mul_one_add_div", "code": "theorem add_eq_mul_one_add_div [Semiring R] {a : R\u02e3} {b : R} : \u2191a + b = a * (1 + \u2191a\u207b\u00b9 * b)", "start": [128, 1], "end": [129, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Divisibility/Units.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.coe_dvd", "code": "theorem coe_dvd : \u2191u \u2223 a", "start": [24, 1], "end": [27, 22], "kind": "commanddeclaration"}, {"full_name": "Units.dvd_mul_right", "code": "theorem dvd_mul_right : a \u2223 b * u \u2194 a \u2223 b", "start": [30, 1], "end": [34, 67], "kind": "commanddeclaration"}, {"full_name": "Units.mul_right_dvd", "code": "theorem mul_right_dvd : a * u \u2223 b \u2194 a \u2223 b", "start": [37, 1], "end": [40, 75], "kind": "commanddeclaration"}, {"full_name": "Units.dvd_mul_left", "code": "theorem dvd_mul_left : a \u2223 u * b \u2194 a \u2223 b", "start": [49, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "Units.mul_left_dvd", "code": "theorem mul_left_dvd : \u2191u * a \u2223 b \u2194 a \u2223 b", "start": [56, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "IsUnit.dvd", "code": "@[simp]\ntheorem dvd : u \u2223 a", "start": [73, 1], "end": [77, 22], "kind": "commanddeclaration"}, {"full_name": "IsUnit.dvd_mul_right", "code": "@[simp]\ntheorem dvd_mul_right : a \u2223 b * u \u2194 a \u2223 b", "start": [80, 1], "end": [83, 28], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_right_dvd", "code": "@[simp]\ntheorem mul_right_dvd : a * u \u2223 b \u2194 a \u2223 b", "start": [86, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "IsUnit.dvd_mul_left", "code": "@[simp]\ntheorem dvd_mul_left : a \u2223 u * b \u2194 a \u2223 b", "start": [99, 1], "end": [104, 27], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_left_dvd", "code": "@[simp]\ntheorem mul_left_dvd : u * a \u2223 b \u2194 a \u2223 b", "start": [107, 1], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "isUnit_iff_dvd_one", "code": "theorem isUnit_iff_dvd_one {x : \u03b1} : IsUnit x \u2194 x \u2223 1", "start": [123, 1], "end": [124, 73], "kind": "commanddeclaration"}, {"full_name": "isUnit_iff_forall_dvd", "code": "theorem isUnit_iff_forall_dvd {x : \u03b1} : IsUnit x \u2194 \u2200 y, x \u2223 y", "start": [127, 1], "end": [128, 74], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_dvd_unit", "code": "theorem isUnit_of_dvd_unit {x y : \u03b1} (xy : x \u2223 y) (hu : IsUnit y) : IsUnit x", "start": [131, 1], "end": [132, 62], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_dvd_one", "code": "theorem isUnit_of_dvd_one {a : \u03b1} (h : a \u2223 1) : IsUnit (a : \u03b1)", "start": [135, 1], "end": [136, 27], "kind": "commanddeclaration"}, {"full_name": "not_isUnit_of_not_isUnit_dvd", "code": "theorem not_isUnit_of_not_isUnit_dvd {a b : \u03b1} (ha : \u00acIsUnit a) (hb : a \u2223 b) : \u00acIsUnit b", "start": [139, 1], "end": [140, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Prod.lean", "imports": ["Mathlib/Data/Set/Image.lean", "Mathlib/Data/SProd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.prod", "code": "def prod (s : Set \u03b1) (t : Set \u03b2) : Set (\u03b1 \u00d7 \u03b2) :=\n  { p | p.1 \u2208 s \u2227 p.2 \u2208 t }", "start": [38, 1], "end": [40, 28], "kind": "commanddeclaration"}, {"full_name": "Set.instSProd", "code": "@[default_instance]\ninstance instSProd : SProd (Set \u03b1) (Set \u03b2) (Set (\u03b1 \u00d7 \u03b2)) where\n  sprod := Set.prod", "start": [43, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq", "code": "theorem prod_eq (s : Set \u03b1) (t : Set \u03b2) : s \u00d7\u02e2 t = Prod.fst \u207b\u00b9' s \u2229 Prod.snd \u207b\u00b9' t", "start": [47, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_prod_eq", "code": "theorem mem_prod_eq {p : \u03b1 \u00d7 \u03b2} : (p \u2208 s \u00d7\u02e2 t) = (p.1 \u2208 s \u2227 p.2 \u2208 t)", "start": [51, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_prod", "code": "@[simp, mfld_simps]\ntheorem mem_prod {p : \u03b1 \u00d7 \u03b2} : p \u2208 s \u00d7\u02e2 t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [55, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mk_mem_set_prod_eq", "code": "@[mfld_simps]\ntheorem prod_mk_mem_set_prod_eq : ((a, b) \u2208 s \u00d7\u02e2 t) = (a \u2208 s \u2227 b \u2208 t)", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mk_mem_prod", "code": "theorem mk_mem_prod (ha : a \u2208 s) (hb : b \u2208 t) : (a, b) \u2208 s \u00d7\u02e2 t", "start": [66, 1], "end": [67, 11], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.prod", "code": "theorem Subsingleton.prod (hs : s.Subsingleton) (ht : t.Subsingleton) :\n    (s \u00d7\u02e2 t).Subsingleton", "start": [70, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemProd", "code": "noncomputable instance decidableMemProd [DecidablePred (\u00b7 \u2208 s)] [DecidablePred (\u00b7 \u2208 t)] :\n    DecidablePred (\u00b7 \u2208 s \u00d7\u02e2 t) := fun _ => And.decidable", "start": [74, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mono", "code": "theorem prod_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : s\u2081 \u00d7\u02e2 t\u2081 \u2286 s\u2082 \u00d7\u02e2 t\u2082", "start": [78, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mono_left", "code": "theorem prod_mono_left (hs : s\u2081 \u2286 s\u2082) : s\u2081 \u00d7\u02e2 t \u2286 s\u2082 \u00d7\u02e2 t", "start": [82, 1], "end": [83, 26], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mono_right", "code": "theorem prod_mono_right (ht : t\u2081 \u2286 t\u2082) : s \u00d7\u02e2 t\u2081 \u2286 s \u00d7\u02e2 t\u2082", "start": [86, 1], "end": [87, 26], "kind": "commanddeclaration"}, {"full_name": "Set.prod_self_subset_prod_self", "code": "@[simp]\ntheorem prod_self_subset_prod_self : s\u2081 \u00d7\u02e2 s\u2081 \u2286 s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 \u2286 s\u2082", "start": [90, 1], "end": [92, 76], "kind": "commanddeclaration"}, {"full_name": "Set.prod_self_ssubset_prod_self", "code": "@[simp]\ntheorem prod_self_ssubset_prod_self : s\u2081 \u00d7\u02e2 s\u2081 \u2282 s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 \u2282 s\u2082", "start": [95, 1], "end": [97, 79], "kind": "commanddeclaration"}, {"full_name": "Set.prod_subset_iff", "code": "theorem prod_subset_iff {P : Set (\u03b1 \u00d7 \u03b2)} : s \u00d7\u02e2 t \u2286 P \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, (x, y) \u2208 P", "start": [100, 1], "end": [101, 81], "kind": "commanddeclaration"}, {"full_name": "Set.forall_prod_set", "code": "theorem forall_prod_set {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} : (\u2200 x \u2208 s \u00d7\u02e2 t, p x) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, p (x, y)", "start": [104, 1], "end": [105, 18], "kind": "commanddeclaration"}, {"full_name": "Set.exists_prod_set", "code": "theorem exists_prod_set {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} : (\u2203 x \u2208 s \u00d7\u02e2 t, p x) \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, p (x, y)", "start": [108, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "Set.prod_empty", "code": "@[simp]\ntheorem prod_empty : s \u00d7\u02e2 (\u2205 : Set \u03b2) = \u2205", "start": [112, 1], "end": [115, 24], "kind": "commanddeclaration"}, {"full_name": "Set.empty_prod", "code": "@[simp]\ntheorem empty_prod : (\u2205 : Set \u03b1) \u00d7\u02e2 t = \u2205", "start": [118, 1], "end": [121, 24], "kind": "commanddeclaration"}, {"full_name": "Set.univ_prod_univ", "code": "@[simp, mfld_simps]\ntheorem univ_prod_univ : @univ \u03b1 \u00d7\u02e2 @univ \u03b2 = univ", "start": [124, 1], "end": [127, 23], "kind": "commanddeclaration"}, {"full_name": "Set.univ_prod", "code": "theorem univ_prod {t : Set \u03b2} : (univ : Set \u03b1) \u00d7\u02e2 t = Prod.snd \u207b\u00b9' t", "start": [130, 1], "end": [130, 90], "kind": "commanddeclaration"}, {"full_name": "Set.prod_univ", "code": "theorem prod_univ {s : Set \u03b1} : s \u00d7\u02e2 (univ : Set \u03b2) = Prod.fst \u207b\u00b9' s", "start": [133, 1], "end": [133, 90], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_prod", "code": "@[simp]\ntheorem singleton_prod : ({a} : Set \u03b1) \u00d7\u02e2 t = Prod.mk a '' t", "start": [136, 1], "end": [139, 32], "kind": "commanddeclaration"}, {"full_name": "Set.prod_singleton", "code": "@[simp]\ntheorem prod_singleton : s \u00d7\u02e2 ({b} : Set \u03b2) = (fun a => (a, b)) '' s", "start": [142, 1], "end": [145, 32], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_prod_singleton", "code": "theorem singleton_prod_singleton : ({a} : Set \u03b1) \u00d7\u02e2 ({b} : Set \u03b2) = {(a, b)}", "start": [148, 1], "end": [148, 88], "kind": "commanddeclaration"}, {"full_name": "Set.union_prod", "code": "@[simp]\ntheorem union_prod : (s\u2081 \u222a s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u222a s\u2082 \u00d7\u02e2 t", "start": [151, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "Set.prod_union", "code": "@[simp]\ntheorem prod_union : s \u00d7\u02e2 (t\u2081 \u222a t\u2082) = s \u00d7\u02e2 t\u2081 \u222a s \u00d7\u02e2 t\u2082", "start": [157, 1], "end": [160, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_prod", "code": "theorem inter_prod : (s\u2081 \u2229 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2229 s\u2082 \u00d7\u02e2 t", "start": [163, 1], "end": [165, 55], "kind": "commanddeclaration"}, {"full_name": "Set.prod_inter", "code": "theorem prod_inter : s \u00d7\u02e2 (t\u2081 \u2229 t\u2082) = s \u00d7\u02e2 t\u2081 \u2229 s \u00d7\u02e2 t\u2082", "start": [168, 1], "end": [170, 54], "kind": "commanddeclaration"}, {"full_name": "Set.prod_inter_prod", "code": "@[mfld_simps]\ntheorem prod_inter_prod : s\u2081 \u00d7\u02e2 t\u2081 \u2229 s\u2082 \u00d7\u02e2 t\u2082 = (s\u2081 \u2229 s\u2082) \u00d7\u02e2 (t\u2081 \u2229 t\u2082)", "start": [173, 1], "end": [176, 34], "kind": "commanddeclaration"}, {"full_name": "Set.compl_prod_eq_union", "code": "lemma compl_prod_eq_union {\u03b1 \u03b2 : Type*} (s : Set \u03b1) (t : Set \u03b2) :\n    (s \u00d7\u02e2 t)\u1d9c = (s\u1d9c \u00d7\u02e2 univ) \u222a (univ \u00d7\u02e2 t\u1d9c) := by\n  ext p\n  simp only [mem_compl_iff, mem_prod, not_and, mem_union, mem_univ, and_true, true_and]\n  constructor <;> intro h\n  \u00b7 by_cases fst_in_s : p.fst \u2208 s\n    \u00b7 exact Or.inr (h fst_in_s)\n    \u00b7 exact Or.inl fst_in_s\n  \u00b7 intro fst_in_s\n    simpa only [fst_in_s, not_true, false_or] using h", "start": [179, 1], "end": [188, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_prod", "code": "@[simp]\ntheorem disjoint_prod : Disjoint (s\u2081 \u00d7\u02e2 t\u2081) (s\u2082 \u00d7\u02e2 t\u2082) \u2194 Disjoint s\u2081 s\u2082 \u2228 Disjoint t\u2081 t\u2082", "start": [190, 1], "end": [193, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Disjoint.set_prod_left", "code": "theorem Disjoint.set_prod_left (hs : Disjoint s\u2081 s\u2082) (t\u2081 t\u2082 : Set \u03b2) :\n    Disjoint (s\u2081 \u00d7\u02e2 t\u2081) (s\u2082 \u00d7\u02e2 t\u2082)", "start": [196, 1], "end": [198, 79], "kind": "commanddeclaration"}, {"full_name": "Set.Disjoint.set_prod_right", "code": "theorem Disjoint.set_prod_right (ht : Disjoint t\u2081 t\u2082) (s\u2081 s\u2082 : Set \u03b1) :\n    Disjoint (s\u2081 \u00d7\u02e2 t\u2081) (s\u2082 \u00d7\u02e2 t\u2082)", "start": [201, 1], "end": [203, 79], "kind": "commanddeclaration"}, {"full_name": "Set.insert_prod", "code": "theorem insert_prod : insert a s \u00d7\u02e2 t = Prod.mk a '' t \u222a s \u00d7\u02e2 t", "start": [206, 1], "end": [208, 77], "kind": "commanddeclaration"}, {"full_name": "Set.prod_insert", "code": "theorem prod_insert : s \u00d7\u02e2 insert b t = (fun a => (a, b)) '' s \u222a s \u00d7\u02e2 t", "start": [211, 1], "end": [221, 28], "kind": "commanddeclaration"}, {"full_name": "Set.prod_preimage_eq", "code": "theorem prod_preimage_eq {f : \u03b3 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b2} :\n    (f \u207b\u00b9' s) \u00d7\u02e2 (g \u207b\u00b9' t) = (fun p : \u03b3 \u00d7 \u03b4 => (f p.1, g p.2)) \u207b\u00b9' s \u00d7\u02e2 t", "start": [224, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "Set.prod_preimage_left", "code": "theorem prod_preimage_left {f : \u03b3 \u2192 \u03b1} :\n    (f \u207b\u00b9' s) \u00d7\u02e2 t = (fun p : \u03b3 \u00d7 \u03b2 => (f p.1, p.2)) \u207b\u00b9' s \u00d7\u02e2 t", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "Set.prod_preimage_right", "code": "theorem prod_preimage_right {g : \u03b4 \u2192 \u03b2} :\n    s \u00d7\u02e2 (g \u207b\u00b9' t) = (fun p : \u03b1 \u00d7 \u03b4 => (p.1, g p.2)) \u207b\u00b9' s \u00d7\u02e2 t", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_prod_map_prod", "code": "theorem preimage_prod_map_prod (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (s : Set \u03b2) (t : Set \u03b4) :\n    Prod.map f g \u207b\u00b9' s \u00d7\u02e2 t = (f \u207b\u00b9' s) \u00d7\u02e2 (g \u207b\u00b9' t)", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod", "code": "theorem mk_preimage_prod (f : \u03b3 \u2192 \u03b1) (g : \u03b3 \u2192 \u03b2) :\n    (fun x => (f x, g x)) \u207b\u00b9' s \u00d7\u02e2 t = f \u207b\u00b9' s \u2229 g \u207b\u00b9' t", "start": [244, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_left", "code": "@[simp]\ntheorem mk_preimage_prod_left (hb : b \u2208 t) : (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = s", "start": [249, 1], "end": [252, 12], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_right", "code": "@[simp]\ntheorem mk_preimage_prod_right (ha : a \u2208 s) : Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = t", "start": [255, 1], "end": [258, 12], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_left_eq_empty", "code": "@[simp]\ntheorem mk_preimage_prod_left_eq_empty (hb : b \u2209 t) : (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = \u2205", "start": [261, 1], "end": [264, 12], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_right_eq_empty", "code": "@[simp]\ntheorem mk_preimage_prod_right_eq_empty (ha : a \u2209 s) : Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = \u2205", "start": [267, 1], "end": [270, 12], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_left_eq_if", "code": "theorem mk_preimage_prod_left_eq_if [DecidablePred (\u00b7 \u2208 t)] :\n    (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then s else \u2205", "start": [273, 1], "end": [274, 94], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_right_eq_if", "code": "theorem mk_preimage_prod_right_eq_if [DecidablePred (\u00b7 \u2208 s)] :\n    Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then t else \u2205", "start": [277, 1], "end": [278, 86], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_left_fn_eq_if", "code": "theorem mk_preimage_prod_left_fn_eq_if [DecidablePred (\u00b7 \u2208 t)] (f : \u03b3 \u2192 \u03b1) :\n    (fun a => (f a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then f \u207b\u00b9' s else \u2205", "start": [281, 1], "end": [283, 76], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_prod_right_fn_eq_if", "code": "theorem mk_preimage_prod_right_fn_eq_if [DecidablePred (\u00b7 \u2208 s)] (g : \u03b4 \u2192 \u03b2) :\n    (fun b => (a, g b)) \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then g \u207b\u00b9' t else \u2205", "start": [286, 1], "end": [288, 78], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_swap_prod", "code": "@[simp]\ntheorem preimage_swap_prod (s : Set \u03b1) (t : Set \u03b2) : Prod.swap \u207b\u00b9' s \u00d7\u02e2 t = t \u00d7\u02e2 s", "start": [291, 1], "end": [294, 18], "kind": "commanddeclaration"}, {"full_name": "Set.image_swap_prod", "code": "@[simp]\ntheorem image_swap_prod (s : Set \u03b1) (t : Set \u03b2) : Prod.swap '' s \u00d7\u02e2 t = t \u00d7\u02e2 s", "start": [297, 1], "end": [299, 55], "kind": "commanddeclaration"}, {"full_name": "Set.prod_image_image_eq", "code": "theorem prod_image_image_eq {m\u2081 : \u03b1 \u2192 \u03b3} {m\u2082 : \u03b2 \u2192 \u03b4} :\n    (m\u2081 '' s) \u00d7\u02e2 (m\u2082 '' t) = (fun p : \u03b1 \u00d7 \u03b2 => (m\u2081 p.1, m\u2082 p.2)) '' s \u00d7\u02e2 t", "start": [302, 1], "end": [305, 88], "kind": "commanddeclaration"}, {"full_name": "Set.prod_range_range_eq", "code": "theorem prod_range_range_eq {m\u2081 : \u03b1 \u2192 \u03b3} {m\u2082 : \u03b2 \u2192 \u03b4} :\n    range m\u2081 \u00d7\u02e2 range m\u2082 = range fun p : \u03b1 \u00d7 \u03b2 => (m\u2081 p.1, m\u2082 p.2)", "start": [308, 1], "end": [310, 25], "kind": "commanddeclaration"}, {"full_name": "Set.range_prod_map", "code": "@[simp, mfld_simps]\ntheorem range_prod_map {m\u2081 : \u03b1 \u2192 \u03b3} {m\u2082 : \u03b2 \u2192 \u03b4} : range (Prod.map m\u2081 m\u2082) = range m\u2081 \u00d7\u02e2 range m\u2082", "start": [313, 1], "end": [315, 27], "kind": "commanddeclaration"}, {"full_name": "Set.prod_range_univ_eq", "code": "theorem prod_range_univ_eq {m\u2081 : \u03b1 \u2192 \u03b3} :\n    range m\u2081 \u00d7\u02e2 (univ : Set \u03b2) = range fun p : \u03b1 \u00d7 \u03b2 => (m\u2081 p.1, p.2)", "start": [318, 1], "end": [320, 25], "kind": "commanddeclaration"}, {"full_name": "Set.prod_univ_range_eq", "code": "theorem prod_univ_range_eq {m\u2082 : \u03b2 \u2192 \u03b4} :\n    (univ : Set \u03b1) \u00d7\u02e2 range m\u2082 = range fun p : \u03b1 \u00d7 \u03b2 => (p.1, m\u2082 p.2)", "start": [323, 1], "end": [325, 25], "kind": "commanddeclaration"}, {"full_name": "Set.range_pair_subset", "code": "theorem range_pair_subset (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) :\n    (range fun x => (f x, g x)) \u2286 range f \u00d7\u02e2 range g", "start": [328, 1], "end": [332, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.prod", "code": "theorem Nonempty.prod : s.Nonempty \u2192 t.Nonempty \u2192 (s \u00d7\u02e2 t).Nonempty", "start": [335, 1], "end": [336, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.fst", "code": "theorem Nonempty.fst : (s \u00d7\u02e2 t).Nonempty \u2192 s.Nonempty", "start": [339, 1], "end": [339, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.snd", "code": "theorem Nonempty.snd : (s \u00d7\u02e2 t).Nonempty \u2192 t.Nonempty", "start": [342, 1], "end": [342, 84], "kind": "commanddeclaration"}, {"full_name": "Set.prod_nonempty_iff", "code": "@[simp]\ntheorem prod_nonempty_iff : (s \u00d7\u02e2 t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [345, 1], "end": [347, 51], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_empty_iff", "code": "@[simp]\ntheorem prod_eq_empty_iff : s \u00d7\u02e2 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [350, 1], "end": [352, 76], "kind": "commanddeclaration"}, {"full_name": "Set.prod_sub_preimage_iff", "code": "theorem prod_sub_preimage_iff {W : Set \u03b3} {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} :\n    s \u00d7\u02e2 t \u2286 f \u207b\u00b9' W \u2194 \u2200 a b, a \u2208 s \u2192 b \u2208 t \u2192 f (a, b) \u2208 W", "start": [355, 1], "end": [356, 83], "kind": "commanddeclaration"}, {"full_name": "Set.image_prod_mk_subset_prod", "code": "theorem image_prod_mk_subset_prod {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} :\n    (fun x => (f x, g x)) '' s \u2286 (f '' s) \u00d7\u02e2 (g '' s)", "start": [359, 1], "end": [362, 68], "kind": "commanddeclaration"}, {"full_name": "Set.image_prod_mk_subset_prod_left", "code": "theorem image_prod_mk_subset_prod_left (hb : b \u2208 t) : (fun a => (a, b)) '' s \u2286 s \u00d7\u02e2 t", "start": [365, 1], "end": [367, 17], "kind": "commanddeclaration"}, {"full_name": "Set.image_prod_mk_subset_prod_right", "code": "theorem image_prod_mk_subset_prod_right (ha : a \u2208 s) : Prod.mk a '' t \u2286 s \u00d7\u02e2 t", "start": [370, 1], "end": [372, 17], "kind": "commanddeclaration"}, {"full_name": "Set.prod_subset_preimage_fst", "code": "theorem prod_subset_preimage_fst (s : Set \u03b1) (t : Set \u03b2) : s \u00d7\u02e2 t \u2286 Prod.fst \u207b\u00b9' s", "start": [375, 1], "end": [376, 24], "kind": "commanddeclaration"}, {"full_name": "Set.fst_image_prod_subset", "code": "theorem fst_image_prod_subset (s : Set \u03b1) (t : Set \u03b2) : Prod.fst '' s \u00d7\u02e2 t \u2286 s", "start": [379, 1], "end": [380, 53], "kind": "commanddeclaration"}, {"full_name": "Set.fst_image_prod", "code": "theorem fst_image_prod (s : Set \u03b2) {t : Set \u03b1} (ht : t.Nonempty) : Prod.fst '' s \u00d7\u02e2 t = s", "start": [383, 1], "end": [386, 28], "kind": "commanddeclaration"}, {"full_name": "Set.prod_subset_preimage_snd", "code": "theorem prod_subset_preimage_snd (s : Set \u03b1) (t : Set \u03b2) : s \u00d7\u02e2 t \u2286 Prod.snd \u207b\u00b9' t", "start": [389, 1], "end": [390, 25], "kind": "commanddeclaration"}, {"full_name": "Set.snd_image_prod_subset", "code": "theorem snd_image_prod_subset (s : Set \u03b1) (t : Set \u03b2) : Prod.snd '' s \u00d7\u02e2 t \u2286 t", "start": [393, 1], "end": [394, 53], "kind": "commanddeclaration"}, {"full_name": "Set.snd_image_prod", "code": "theorem snd_image_prod {s : Set \u03b1} (hs : s.Nonempty) (t : Set \u03b2) : Prod.snd '' s \u00d7\u02e2 t = t", "start": [397, 1], "end": [400, 32], "kind": "commanddeclaration"}, {"full_name": "Set.prod_diff_prod", "code": "theorem prod_diff_prod : s \u00d7\u02e2 t \\ s\u2081 \u00d7\u02e2 t\u2081 = s \u00d7\u02e2 (t \\ t\u2081) \u222a (s \\ s\u2081) \u00d7\u02e2 t", "start": [403, 1], "end": [405, 65], "kind": "commanddeclaration"}, {"full_name": "Set.prod_subset_prod_iff", "code": "theorem prod_subset_prod_iff : s \u00d7\u02e2 t \u2286 s\u2081 \u00d7\u02e2 t\u2081 \u2194 s \u2286 s\u2081 \u2227 t \u2286 t\u2081 \u2228 s = \u2205 \u2228 t = \u2205", "start": [408, 1], "end": [421, 28], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_prod_iff_of_nonempty", "code": "theorem prod_eq_prod_iff_of_nonempty (h : (s \u00d7\u02e2 t).Nonempty) :\n    s \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t\u2081 \u2194 s = s\u2081 \u2227 t = t\u2081", "start": [424, 1], "end": [433, 8], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_prod_iff", "code": "theorem prod_eq_prod_iff :\n    s \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t\u2081 \u2194 s = s\u2081 \u2227 t = t\u2081 \u2228 (s = \u2205 \u2228 t = \u2205) \u2227 (s\u2081 = \u2205 \u2228 t\u2081 = \u2205)", "start": [436, 1], "end": [446, 43], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_iff_eq", "code": "@[simp]\ntheorem prod_eq_iff_eq (ht : t.Nonempty) : s \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2194 s = s\u2081", "start": [449, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "Monotone.set_prod", "code": "theorem _root_.Monotone.set_prod (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x \u00d7\u02e2 g x", "start": [461, 1], "end": [463, 39], "kind": "commanddeclaration"}, {"full_name": "Antitone.set_prod", "code": "theorem _root_.Antitone.set_prod (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x \u00d7\u02e2 g x", "start": [466, 1], "end": [468, 39], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.set_prod", "code": "theorem _root_.MonotoneOn.set_prod (hf : MonotoneOn f s) (hg : MonotoneOn g s) :\n    MonotoneOn (fun x => f x \u00d7\u02e2 g x) s", "start": [471, 1], "end": [472, 97], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.set_prod", "code": "theorem _root_.AntitoneOn.set_prod (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => f x \u00d7\u02e2 g x) s", "start": [475, 1], "end": [476, 97], "kind": "commanddeclaration"}, {"full_name": "Set.diagonal", "code": "def diagonal (\u03b1 : Type*) : Set (\u03b1 \u00d7 \u03b1) :=\n  { p | p.1 = p.2 }", "start": [494, 1], "end": [496, 20], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diagonal", "code": "theorem mem_diagonal (x : \u03b1) : (x, x) \u2208 diagonal \u03b1", "start": [499, 1], "end": [499, 73], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diagonal_iff", "code": "@[simp]\ntheorem mem_diagonal_iff {x : \u03b1 \u00d7 \u03b1} : x \u2208 diagonal \u03b1 \u2194 x.1 = x.2", "start": [502, 1], "end": [504, 10], "kind": "commanddeclaration"}, {"full_name": "Set.diagonal_nonempty", "code": "lemma diagonal_nonempty [Nonempty \u03b1] : (diagonal \u03b1).Nonempty :=\n  Nonempty.elim \u2039_\u203a <| fun x => \u27e8_, mem_diagonal x\u27e9", "start": [507, 1], "end": [508, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Set.decidableMemDiagonal", "code": "instance decidableMemDiagonal [h : DecidableEq \u03b1] (x : \u03b1 \u00d7 \u03b1) : Decidable (x \u2208 diagonal \u03b1) :=\n  h x.1 x.2", "start": [511, 1], "end": [512, 12], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_coe_coe_diagonal", "code": "theorem preimage_coe_coe_diagonal (s : Set \u03b1) :\n    Prod.map (fun x : s => (x : \u03b1)) (fun x : s => (x : \u03b1)) \u207b\u00b9' diagonal \u03b1 = diagonal s", "start": [515, 1], "end": [518, 22], "kind": "commanddeclaration"}, {"full_name": "Set.range_diag", "code": "@[simp]\ntheorem range_diag : (range fun x => (x, x)) = diagonal \u03b1", "start": [521, 1], "end": [524, 27], "kind": "commanddeclaration"}, {"full_name": "Set.diagonal_subset_iff", "code": "theorem diagonal_subset_iff {s} : diagonal \u03b1 \u2286 s \u2194 \u2200 x, (x, x) \u2208 s", "start": [527, 1], "end": [528, 38], "kind": "commanddeclaration"}, {"full_name": "Set.prod_subset_compl_diagonal_iff_disjoint", "code": "@[simp]\ntheorem prod_subset_compl_diagonal_iff_disjoint : s \u00d7\u02e2 t \u2286 (diagonal \u03b1)\u1d9c \u2194 Disjoint s t", "start": [531, 1], "end": [533, 52], "kind": "commanddeclaration"}, {"full_name": "Set.diag_preimage_prod", "code": "@[simp]\ntheorem diag_preimage_prod (s t : Set \u03b1) : (fun x => (x, x)) \u207b\u00b9' s \u00d7\u02e2 t = s \u2229 t", "start": [536, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "Set.diag_preimage_prod_self", "code": "theorem diag_preimage_prod_self (s : Set \u03b1) : (fun x => (x, x)) \u207b\u00b9' s \u00d7\u02e2 s = s", "start": [541, 1], "end": [542, 15], "kind": "commanddeclaration"}, {"full_name": "Set.diag_image", "code": "theorem diag_image (s : Set \u03b1) : (fun x => (x, x)) '' s = diagonal \u03b1 \u2229 s \u00d7\u02e2 s", "start": [545, 1], "end": [552, 35], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag", "code": "def offDiag (s : Set \u03b1) : Set (\u03b1 \u00d7 \u03b1) :=\n  { x | x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2 }", "start": [561, 1], "end": [563, 40], "kind": "commanddeclaration"}, {"full_name": "Set.mem_offDiag", "code": "@[simp]\ntheorem mem_offDiag : x \u2208 s.offDiag \u2194 x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2", "start": [566, 1], "end": [568, 10], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_mono", "code": "theorem offDiag_mono : Monotone (offDiag : Set \u03b1 \u2192 Set (\u03b1 \u00d7 \u03b1))", "start": [571, 1], "end": [572, 41], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_nonempty", "code": "@[simp]\ntheorem offDiag_nonempty : s.offDiag.Nonempty \u2194 s.Nontrivial", "start": [575, 1], "end": [577, 47], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_eq_empty", "code": "@[simp]\ntheorem offDiag_eq_empty : s.offDiag = \u2205 \u2194 s.Subsingleton", "start": [580, 1], "end": [582, 79], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.offDiag_nonempty", "code": "alias \u27e8_, Nontrivial.offDiag_nonempty\u27e9 := offDiag_nonempty", "start": [585, 1], "end": [585, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Subsingleton.offDiag_eq_empty", "code": "alias \u27e8_, Subsingleton.offDiag_eq_empty\u27e9 := offDiag_nonempty", "start": [588, 1], "end": [588, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.offDiag_subset_prod", "code": "theorem offDiag_subset_prod : s.offDiag \u2286 s \u00d7\u02e2 s", "start": [593, 1], "end": [593, 79], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_eq_sep_prod", "code": "theorem offDiag_eq_sep_prod : s.offDiag = { x \u2208 s \u00d7\u02e2 s | x.1 \u2260 x.2 }", "start": [596, 1], "end": [597, 30], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_empty", "code": "@[simp]\ntheorem offDiag_empty : (\u2205 : Set \u03b1).offDiag = \u2205", "start": [600, 1], "end": [601, 59], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_singleton", "code": "@[simp]\ntheorem offDiag_singleton (a : \u03b1) : ({a} : Set \u03b1).offDiag = \u2205", "start": [604, 1], "end": [605, 73], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_univ", "code": "@[simp]\ntheorem offDiag_univ : (univ : Set \u03b1).offDiag = (diagonal \u03b1)\u1d9c", "start": [608, 1], "end": [610, 17], "kind": "commanddeclaration"}, {"full_name": "Set.prod_sdiff_diagonal", "code": "@[simp]\ntheorem prod_sdiff_diagonal : s \u00d7\u02e2 s \\ diagonal \u03b1 = s.offDiag", "start": [613, 1], "end": [615, 25], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_diagonal_offDiag", "code": "@[simp]\ntheorem disjoint_diagonal_offDiag : Disjoint (diagonal \u03b1) s.offDiag", "start": [618, 1], "end": [620, 45], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_inter", "code": "theorem offDiag_inter : (s \u2229 t).offDiag = s.offDiag \u2229 t.offDiag", "start": [623, 1], "end": [626, 10], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_union", "code": "theorem offDiag_union (h : Disjoint s t) :\n    (s \u222a t).offDiag = s.offDiag \u222a t.offDiag \u222a s \u00d7\u02e2 t \u222a t \u00d7\u02e2 s", "start": [631, 1], "end": [643, 49], "kind": "commanddeclaration"}, {"full_name": "Set.offDiag_insert", "code": "theorem offDiag_insert (ha : a \u2209 s) : (insert a s).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}", "start": [646, 1], "end": [650, 14], "kind": "commanddeclaration"}, {"full_name": "Set.pi", "code": "def pi (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) : Set (\u2200 i, \u03b1 i) :=\n  { f | \u2200 i \u2208 s, f i \u2208 t i }", "start": [662, 1], "end": [666, 29], "kind": "commanddeclaration"}, {"full_name": "Set.mem_pi", "code": "@[simp]\ntheorem mem_pi {f : \u2200 i, \u03b1 i} : f \u2208 s.pi t \u2194 \u2200 i \u2208 s, f i \u2208 t i", "start": [669, 1], "end": [671, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_univ_pi", "code": "theorem mem_univ_pi {f : \u2200 i, \u03b1 i} : f \u2208 pi univ t \u2194 \u2200 i, f i \u2208 t i", "start": [675, 1], "end": [675, 79], "kind": "commanddeclaration"}, {"full_name": "Set.empty_pi", "code": "@[simp]\ntheorem empty_pi (s : \u2200 i, Set (\u03b1 i)) : pi \u2205 s = univ", "start": [678, 1], "end": [681, 12], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_univ_pi", "code": "theorem subsingleton_univ_pi (ht : \u2200 i, (t i).Subsingleton) :\n    (univ.pi t).Subsingleton", "start": [684, 1], "end": [686, 51], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ", "code": "@[simp]\ntheorem pi_univ (s : Set \u03b9) : (pi s fun i => (univ : Set (\u03b1 i))) = univ", "start": [688, 1], "end": [690, 44], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_ite", "code": "@[simp]\ntheorem pi_univ_ite (s : Set \u03b9) [DecidablePred (\u00b7 \u2208 s)] (t : \u2200 i, Set (\u03b1 i)) :\n    (pi univ fun i => if i \u2208 s then t i else univ) = s.pi t", "start": [693, 1], "end": [696, 89], "kind": "commanddeclaration"}, {"full_name": "Set.pi_mono", "code": "theorem pi_mono (h : \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) : pi s t\u2081 \u2286 pi s t\u2082", "start": [698, 1], "end": [698, 101], "kind": "commanddeclaration"}, {"full_name": "Set.pi_inter_distrib", "code": "theorem pi_inter_distrib : (s.pi fun i => t i \u2229 t\u2081 i) = s.pi t \u2229 s.pi t\u2081", "start": [701, 1], "end": [702, 64], "kind": "commanddeclaration"}, {"full_name": "Set.pi_congr", "code": "theorem pi_congr (h : s\u2081 = s\u2082) (h' : \u2200 i \u2208 s\u2081, t\u2081 i = t\u2082 i) : s\u2081.pi t\u2081 = s\u2082.pi t\u2082", "start": [705, 1], "end": [706, 63], "kind": "commanddeclaration"}, {"full_name": "Set.pi_eq_empty", "code": "theorem pi_eq_empty (hs : i \u2208 s) (ht : t i = \u2205) : s.pi t = \u2205", "start": [709, 1], "end": [712, 30], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_eq_empty", "code": "theorem univ_pi_eq_empty (ht : t i = \u2205) : pi univ t = \u2205", "start": [715, 1], "end": [716, 30], "kind": "commanddeclaration"}, {"full_name": "Set.pi_nonempty_iff", "code": "theorem pi_nonempty_iff : (s.pi t).Nonempty \u2194 \u2200 i, \u2203 x, i \u2208 s \u2192 x \u2208 t i", "start": [719, 1], "end": [720, 40], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_nonempty_iff", "code": "theorem univ_pi_nonempty_iff : (pi univ t).Nonempty \u2194 \u2200 i, (t i).Nonempty", "start": [723, 1], "end": [724, 40], "kind": "commanddeclaration"}, {"full_name": "Set.pi_eq_empty_iff", "code": "theorem pi_eq_empty_iff : s.pi t = \u2205 \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205", "start": [727, 1], "end": [731, 88], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_eq_empty_iff", "code": "@[simp]\ntheorem univ_pi_eq_empty_iff : pi univ t = \u2205 \u2194 \u2203 i, t i = \u2205", "start": [734, 1], "end": [736, 59], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_empty", "code": "@[simp]\ntheorem univ_pi_empty [h : Nonempty \u03b9] : pi univ (fun _ => \u2205 : \u2200 i, Set (\u03b1 i)) = \u2205", "start": [739, 1], "end": [741, 53], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_univ_pi", "code": "@[simp]\ntheorem disjoint_univ_pi : Disjoint (pi univ t\u2081) (pi univ t\u2082) \u2194 \u2203 i, Disjoint (t\u2081 i) (t\u2082 i)", "start": [744, 1], "end": [746, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Disjoint.set_pi", "code": "theorem Disjoint.set_pi (hi : i \u2208 s) (ht : Disjoint (t\u2081 i) (t\u2082 i)) : Disjoint (s.pi t\u2081) (s.pi t\u2082)", "start": [749, 1], "end": [750, 72], "kind": "commanddeclaration"}, {"full_name": "Set.pi_eq_empty_iff'", "code": "theorem pi_eq_empty_iff' : s.pi t = \u2205 \u2194 \u2203 i \u2208 s, t i = \u2205", "start": [757, 1], "end": [757, 86], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_pi", "code": "@[simp]\ntheorem disjoint_pi : Disjoint (s.pi t\u2081) (s.pi t\u2082) \u2194 \u2203 i \u2208 s, Disjoint (t\u2081 i) (t\u2082 i)", "start": [760, 1], "end": [762, 80], "kind": "commanddeclaration"}, {"full_name": "Set.range_dcomp", "code": "theorem range_dcomp (f : \u2200 i, \u03b1 i \u2192 \u03b2 i) :\n    (range fun g : \u2200 i, \u03b1 i => fun i => f i (g i)) = pi univ fun i => range (f i)", "start": [768, 1], "end": [774, 63], "kind": "commanddeclaration"}, {"full_name": "Set.insert_pi", "code": "@[simp]\ntheorem insert_pi (i : \u03b9) (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    pi (insert i s) t = eval i \u207b\u00b9' t i \u2229 pi s t", "start": [777, 1], "end": [781, 32], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_pi", "code": "@[simp]\ntheorem singleton_pi (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = eval i \u207b\u00b9' t i", "start": [784, 1], "end": [787, 12], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_pi'", "code": "theorem singleton_pi' (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = { x | x i \u2208 t i }", "start": [790, 1], "end": [791, 19], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_singleton", "code": "theorem univ_pi_singleton (f : \u2200 i, \u03b1 i) : (pi univ fun i => {f i}) = ({f} : Set (\u2200 i, \u03b1 i))", "start": [794, 1], "end": [795, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_pi", "code": "theorem preimage_pi (s : Set \u03b9) (t : \u2200 i, Set (\u03b2 i)) (f : \u2200 i, \u03b1 i \u2192 \u03b2 i) :\n    (fun (g : \u2200 i, \u03b1 i) i => f _ (g i)) \u207b\u00b9' s.pi t = s.pi fun i => f i \u207b\u00b9' t i", "start": [798, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "Set.pi_if", "code": "theorem pi_if {p : \u03b9 \u2192 Prop} [h : DecidablePred p] (s : Set \u03b9) (t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)) :\n    (pi s fun i => if p i then t\u2081 i else t\u2082 i) =\n      pi ({ i \u2208 s | p i }) t\u2081 \u2229 pi ({ i \u2208 s | \u00acp i }) t\u2082", "start": [803, 1], "end": [812, 30], "kind": "commanddeclaration"}, {"full_name": "Set.union_pi", "code": "theorem union_pi : (s\u2081 \u222a s\u2082).pi t = s\u2081.pi t \u2229 s\u2082.pi t", "start": [815, 1], "end": [816, 43], "kind": "commanddeclaration"}, {"full_name": "Set.pi_inter_compl", "code": "@[simp]\ntheorem pi_inter_compl (s : Set \u03b9) : pi s t \u2229 pi s\u1d9c t = pi univ t", "start": [819, 1], "end": [821, 36], "kind": "commanddeclaration"}, {"full_name": "Set.pi_update_of_not_mem", "code": "theorem pi_update_of_not_mem [DecidableEq \u03b9] (hi : i \u2209 s) (f : \u2200 j, \u03b1 j) (a : \u03b1 i)\n    (t : \u2200 j, \u03b1 j \u2192 Set (\u03b2 j)) : (s.pi fun j => t j (update f i a j)) = s.pi fun j => t j (f j)", "start": [824, 1], "end": [828, 31], "kind": "commanddeclaration"}, {"full_name": "Set.pi_update_of_mem", "code": "theorem pi_update_of_mem [DecidableEq \u03b9] (hi : i \u2208 s) (f : \u2200 j, \u03b1 j) (a : \u03b1 i)\n    (t : \u2200 j, \u03b1 j \u2192 Set (\u03b2 j)) :\n    (s.pi fun j => t j (update f i a j)) = { x | x i \u2208 t i a } \u2229 (s \\ {i}).pi fun j => t j (f j)", "start": [831, 1], "end": [838, 81], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_update", "code": "theorem univ_pi_update [DecidableEq \u03b9] {\u03b2 : \u2200 _, Type*} (i : \u03b9) (f : \u2200 j, \u03b1 j) (a : \u03b1 i)\n    (t : \u2200 j, \u03b1 j \u2192 Set (\u03b2 j)) :\n    (pi univ fun j => t j (update f i a j)) = { x | x i \u2208 t i a } \u2229 pi {i}\u1d9c fun j => t j (f j)", "start": [841, 1], "end": [844, 62], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_update_univ", "code": "theorem univ_pi_update_univ [DecidableEq \u03b9] (i : \u03b9) (s : Set (\u03b1 i)) :\n    pi univ (update (fun j : \u03b9 => (univ : Set (\u03b1 j))) i s) = eval i \u207b\u00b9' s", "start": [847, 1], "end": [849, 100], "kind": "commanddeclaration"}, {"full_name": "Set.eval_image_pi_subset", "code": "theorem eval_image_pi_subset (hs : i \u2208 s) : eval i '' s.pi t \u2286 t i", "start": [852, 1], "end": [853, 41], "kind": "commanddeclaration"}, {"full_name": "Set.eval_image_univ_pi_subset", "code": "theorem eval_image_univ_pi_subset : eval i '' pi univ t \u2286 t i", "start": [856, 1], "end": [857, 36], "kind": "commanddeclaration"}, {"full_name": "Set.subset_eval_image_pi", "code": "theorem subset_eval_image_pi (ht : (s.pi t).Nonempty) (i : \u03b9) : t i \u2286 eval i '' s.pi t", "start": [860, 1], "end": [864, 57], "kind": "commanddeclaration"}, {"full_name": "Set.eval_image_pi", "code": "theorem eval_image_pi (hs : i \u2208 s) (ht : (s.pi t).Nonempty) : eval i '' s.pi t = t i", "start": [867, 1], "end": [868, 65], "kind": "commanddeclaration"}, {"full_name": "Set.eval_image_univ_pi", "code": "@[simp]\ntheorem eval_image_univ_pi (ht : (pi univ t).Nonempty) :\n    (fun f : \u2200 i, \u03b1 i => f i) '' pi univ t = t i", "start": [871, 1], "end": [874, 32], "kind": "commanddeclaration"}, {"full_name": "Set.pi_subset_pi_iff", "code": "theorem pi_subset_pi_iff : pi s t\u2081 \u2286 pi s t\u2082 \u2194 (\u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) \u2228 pi s t\u2081 = \u2205", "start": [877, 1], "end": [883, 45], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_subset_univ_pi_iff", "code": "theorem univ_pi_subset_univ_pi_iff : pi univ t\u2081 \u2286 pi univ t\u2082 \u2194 (\u2200 i, t\u2081 i \u2286 t\u2082 i) \u2228 \u2203 i, t\u2081 i = \u2205", "start": [886, 1], "end": [887, 29], "kind": "commanddeclaration"}, {"full_name": "Set.eval_preimage", "code": "theorem eval_preimage [DecidableEq \u03b9] {s : Set (\u03b1 i)} :\n    eval i \u207b\u00b9' s = pi univ (update (fun i => univ) i s)", "start": [890, 1], "end": [893, 80], "kind": "commanddeclaration"}, {"full_name": "Set.eval_preimage'", "code": "theorem eval_preimage' [DecidableEq \u03b9] {s : Set (\u03b1 i)} :\n    eval i \u207b\u00b9' s = pi {i} (update (fun i => univ) i s)", "start": [896, 1], "end": [899, 7], "kind": "commanddeclaration"}, {"full_name": "Set.update_preimage_pi", "code": "theorem update_preimage_pi [DecidableEq \u03b9] {f : \u2200 i, \u03b1 i} (hi : i \u2208 s)\n    (hf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j) : update f i \u207b\u00b9' s.pi t = t i", "start": [902, 1], "end": [911, 22], "kind": "commanddeclaration"}, {"full_name": "Set.update_preimage_univ_pi", "code": "theorem update_preimage_univ_pi [DecidableEq \u03b9] {f : \u2200 i, \u03b1 i} (hf : \u2200 (j) (_ : j \u2260 i), f j \u2208 t j) :\n    update f i \u207b\u00b9' pi univ t = t i", "start": [914, 1], "end": [916, 50], "kind": "commanddeclaration"}, {"full_name": "Set.subset_pi_eval_image", "code": "theorem subset_pi_eval_image (s : Set \u03b9) (u : Set (\u2200 i, \u03b1 i)) : u \u2286 pi s fun i => eval i '' u", "start": [919, 1], "end": [920, 31], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_ite", "code": "theorem univ_pi_ite (s : Set \u03b9) [DecidablePred (\u00b7 \u2208 s)] (t : \u2200 i, Set (\u03b1 i)) :\n    (pi univ fun i => if i \u2208 s then t i else univ) = s.pi t", "start": [923, 1], "end": [928, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_symm_preimage_pi", "code": "theorem piCongrLeft_symm_preimage_pi (f : \u03b9' \u2243 \u03b9) (s : Set \u03b9') (t : \u2200 i, Set (\u03b1 i)) :\n    (f.piCongrLeft \u03b1).symm \u207b\u00b9' s.pi (fun i' => t <| f i') = (f '' s).pi t", "start": [940, 1], "end": [942, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_symm_preimage_univ_pi", "code": "theorem piCongrLeft_symm_preimage_univ_pi (f : \u03b9' \u2243 \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    (f.piCongrLeft \u03b1).symm \u207b\u00b9' univ.pi (fun i' => t <| f i') = univ.pi t", "start": [944, 1], "end": [946, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_preimage_pi", "code": "theorem piCongrLeft_preimage_pi (f : \u03b9' \u2243 \u03b9) (s : Set \u03b9') (t : \u2200 i, Set (\u03b1 i)) :\n    f.piCongrLeft \u03b1 \u207b\u00b9' (f '' s).pi t = s.pi fun i => t (f i)", "start": [948, 1], "end": [952, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_preimage_univ_pi", "code": "theorem piCongrLeft_preimage_univ_pi (f : \u03b9' \u2243 \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    f.piCongrLeft \u03b1 \u207b\u00b9' univ.pi t = univ.pi fun i => t (f i)", "start": [954, 1], "end": [956, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumPiEquivProdPi_symm_preimage_univ_pi", "code": "theorem sumPiEquivProdPi_symm_preimage_univ_pi (\u03c0 : \u03b9 \u2295 \u03b9' \u2192 Type*) (t : \u2200 i, Set (\u03c0 i)) :\n    (sumPiEquivProdPi \u03c0).symm \u207b\u00b9' univ.pi t =\n    univ.pi (fun i => t (.inl i)) \u00d7\u02e2 univ.pi fun i => t (.inr i)", "start": [958, 1], "end": [965, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/BigOperators/Basic.lean", "imports": ["Mathlib/Data/List/Forall2.lean", "Mathlib/Data/Int/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.prod_nil", "code": "@[to_additive (attr := simp)]\ntheorem prod_nil : ([] : List M).prod = 1", "start": [28, 1], "end": [30, 6], "kind": "commanddeclaration"}, {"full_name": "List.prod_singleton", "code": "@[to_additive]\ntheorem prod_singleton : [a].prod = a", "start": [34, 1], "end": [36, 12], "kind": "commanddeclaration"}, {"full_name": "List.prod_cons", "code": "@[to_additive (attr := simp)]\ntheorem prod_cons : (a :: l).prod = a * l.prod", "start": [40, 1], "end": [45, 25], "kind": "commanddeclaration"}, {"full_name": "List.prod_append", "code": "@[to_additive (attr := simp)]\ntheorem prod_append : (l\u2081 ++ l\u2082).prod = l\u2081.prod * l\u2082.prod", "start": [49, 1], "end": [53, 41], "kind": "commanddeclaration"}, {"full_name": "List.prod_concat", "code": "@[to_additive]\ntheorem prod_concat : (l.concat a).prod = l.prod * a", "start": [57, 1], "end": [59, 53], "kind": "commanddeclaration"}, {"full_name": "List.prod_join", "code": "@[to_additive (attr := simp)]\ntheorem prod_join {l : List (List M)} : l.join.prod = (l.map List.prod).prod", "start": [63, 1], "end": [65, 79], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_foldr", "code": "@[to_additive]\ntheorem prod_eq_foldr : \u2200 {l : List M}, l.prod = foldr (\u00b7 * \u00b7) 1 l", "start": [69, 1], "end": [72, 61], "kind": "commanddeclaration"}, {"full_name": "List.prod_replicate", "code": "@[to_additive (attr := simp)]\ntheorem prod_replicate (n : \u2115) (a : M) : (replicate n a).prod = a ^ n", "start": [76, 1], "end": [81, 49], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_pow_card", "code": "@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card (l : List M) (m : M) (h : \u2200 x \u2208 l, x = m) : l.prod = m ^ l.length", "start": [85, 1], "end": [87, 58], "kind": "commanddeclaration"}, {"full_name": "List.prod_hom_rel", "code": "@[to_additive]\ntheorem prod_hom_rel (l : List \u03b9) {r : M \u2192 N \u2192 Prop} {f : \u03b9 \u2192 M} {g : \u03b9 \u2192 N} (h\u2081 : r 1 1)\n    (h\u2082 : \u2200 \u2983i a b\u2984, r a b \u2192 r (f i * a) (g i * b)) : r (l.map f).prod (l.map g).prod", "start": [91, 1], "end": [94, 74], "kind": "commanddeclaration"}, {"full_name": "List.prod_hom", "code": "@[to_additive]\ntheorem prod_hom (l : List M) {F : Type*} [MonoidHomClass F M N] (f : F) :\n    (l.map f).prod = f l.prod", "start": [98, 1], "end": [102, 76], "kind": "commanddeclaration"}, {"full_name": "List.prod_hom\u2082", "code": "@[to_additive]\ntheorem prod_hom\u2082 (l : List \u03b9) (f : M \u2192 N \u2192 P) (hf : \u2200 a b c d, f (a * b) (c * d) = f a c * f b d)\n    (hf' : f 1 1 = 1) (f\u2081 : \u03b9 \u2192 M) (f\u2082 : \u03b9 \u2192 N) :\n    (l.map fun i => f (f\u2081 i) (f\u2082 i)).prod = f (l.map f\u2081).prod (l.map f\u2082).prod", "start": [106, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "List.prod_map_mul", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_mul {\u03b1 : Type*} [CommMonoid \u03b1] {l : List \u03b9} {f g : \u03b9 \u2192 \u03b1} :\n    (l.map fun i => f i * g i).prod = (l.map f).prod * (l.map g).prod", "start": [121, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "List.prod_map_neg", "code": "@[simp]\ntheorem prod_map_neg {\u03b1} [CommMonoid \u03b1] [HasDistribNeg \u03b1] (l : List \u03b1) :\n    (l.map Neg.neg).prod = (-1) ^ l.length * l.prod", "start": [128, 1], "end": [132, 49], "kind": "commanddeclaration"}, {"full_name": "List.prod_map_hom", "code": "@[to_additive]\ntheorem prod_map_hom (L : List \u03b9) (f : \u03b9 \u2192 M) {G : Type*} [MonoidHomClass G M N] (g : G) :\n    (L.map (g \u2218 f)).prod = g (L.map f).prod", "start": [135, 1], "end": [137, 75], "kind": "commanddeclaration"}, {"full_name": "List.prod_isUnit", "code": "@[to_additive]\ntheorem prod_isUnit : \u2200 {L : List M} (_ : \u2200 m \u2208 L, IsUnit m), IsUnit L.prod", "start": [141, 1], "end": [146, 100], "kind": "commanddeclaration"}, {"full_name": "List.prod_isUnit_iff", "code": "@[to_additive]\ntheorem prod_isUnit_iff {\u03b1 : Type*} [CommMonoid \u03b1] {L : List \u03b1} :\n    IsUnit L.prod \u2194 \u2200 m \u2208 L, IsUnit m", "start": [150, 1], "end": [157, 100], "kind": "commanddeclaration"}, {"full_name": "List.prod_take_mul_prod_drop", "code": "@[to_additive (attr := simp)]\ntheorem prod_take_mul_prod_drop : \u2200 (L : List M) (i : \u2115), (L.take i).prod * (L.drop i).prod = L.prod", "start": [161, 1], "end": [167, 68], "kind": "commanddeclaration"}, {"full_name": "List.prod_take_succ", "code": "@[to_additive (attr := simp)]\ntheorem prod_take_succ :\n    \u2200 (L : List M) (i : \u2115) (p), (L.take (i + 1)).prod = (L.take i).prod * L.nthLe i p", "start": [171, 1], "end": [180, 9], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_of_prod_ne_one", "code": "@[to_additive \"A list with sum not zero must have positive length.\"]\ntheorem length_pos_of_prod_ne_one (L : List M) (h : L.prod \u2260 1) : 0 < L.length", "start": [184, 1], "end": [190, 9], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_of_one_lt_prod", "code": "@[to_additive length_pos_of_sum_pos \"A list with positive sum must have positive length.\"]\ntheorem length_pos_of_one_lt_prod [Preorder M] (L : List M) (h : 1 < L.prod) : 0 < L.length", "start": [194, 1], "end": [197, 36], "kind": "commanddeclaration"}, {"full_name": "List.length_pos_of_prod_lt_one", "code": "@[to_additive \"A list with negative sum must have positive length.\"]\ntheorem length_pos_of_prod_lt_one [Preorder M] (L : List M) (h : L.prod < 1) : 0 < L.length", "start": [201, 1], "end": [204, 35], "kind": "commanddeclaration"}, {"full_name": "List.prod_set", "code": "@[to_additive]\ntheorem prod_set :\n    \u2200 (L : List M) (n : \u2115) (a : M),\n      (L.set n a).prod =\n        ((L.take n).prod * if n < L.length then a else 1) * (L.drop (n + 1)).prod", "start": [208, 1], "end": [215, 67], "kind": "commanddeclaration"}, {"full_name": "List.get?_zero_mul_tail_prod", "code": "@[to_additive \"We'd like to state this as `L.headI + L.tail.sum = L.sum`, but because `L.headI`\n  relies on an inhabited instance to return a garbage value on the empty list, this is not possible.\n  Instead, we write the statement in terms of `(L.get? 0).getD 0`.\"]\ntheorem get?_zero_mul_tail_prod (l : List M) : (l.get? 0).getD 1 * l.tail.prod = l.prod", "start": [221, 1], "end": [229, 19], "kind": "commanddeclaration"}, {"full_name": "List.headI_mul_tail_prod_of_ne_nil", "code": "@[to_additive \"Same as `get?_zero_add_tail_sum`, but avoiding the `List.headI` garbage complication\n  by requiring the list to be nonempty.\"]\ntheorem headI_mul_tail_prod_of_ne_nil [Inhabited M] (l : List M) (h : l \u2260 []) :\n    l.headI * l.tail.prod = l.prod", "start": [233, 1], "end": [238, 75], "kind": "commanddeclaration"}, {"full_name": "Commute.list_prod_right", "code": "@[to_additive]\ntheorem _root_.Commute.list_prod_right (l : List M) (y : M) (h : \u2200 x \u2208 l, Commute y x) :\n    Commute y l.prod", "start": [242, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "Commute.list_prod_left", "code": "@[to_additive]\ntheorem _root_.Commute.list_prod_left (l : List M) (y : M) (h : \u2200 x \u2208 l, Commute x y) :\n    Commute l.prod y", "start": [253, 1], "end": [256, 65], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.prod_le_prod'", "code": "@[to_additive sum_le_sum]\ntheorem Forall\u2082.prod_le_prod' [Preorder M] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {l\u2081 l\u2082 : List M} (h : Forall\u2082 (\u00b7 \u2264 \u00b7) l\u2081 l\u2082) :\n    l\u2081.prod \u2264 l\u2082.prod", "start": [260, 1], "end": [266, 53], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.prod_le_prod'", "code": "@[to_additive sum_le_sum \"If `l\u2081` is a sublist of `l\u2082` and all elements of `l\u2082` are nonnegative,\n  then `l\u2081.sum \u2264 l\u2082.sum`.\n  One can prove a stronger version assuming `\u2200 a \u2208 l\u2082.diff l\u2081, 0 \u2264 a` instead of `\u2200 a \u2208 l\u2082, 0 \u2264 a`\n  but this lemma is not yet in `mathlib`.\"]\ntheorem Sublist.prod_le_prod' [Preorder M] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {l\u2081 l\u2082 : List M} (h : l\u2081 <+ l\u2082)\n    (h\u2081 : \u2200 a \u2208 l\u2082, (1 : M) \u2264 a) : l\u2081.prod \u2264 l\u2082.prod", "start": [270, 1], "end": [287, 40], "kind": "commanddeclaration"}, {"full_name": "List.SublistForall\u2082.prod_le_prod'", "code": "@[to_additive sum_le_sum]\ntheorem SublistForall\u2082.prod_le_prod' [Preorder M]\n    [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    {l\u2081 l\u2082 : List M} (h : SublistForall\u2082 (\u00b7 \u2264 \u00b7) l\u2081 l\u2082) (h\u2081 : \u2200 a \u2208 l\u2082, (1 : M) \u2264 a) :\n    l\u2081.prod \u2264 l\u2082.prod", "start": [291, 1], "end": [297, 52], "kind": "commanddeclaration"}, {"full_name": "List.prod_le_prod'", "code": "@[to_additive sum_le_sum]\ntheorem prod_le_prod' [Preorder M] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {l : List \u03b9} {f g : \u03b9 \u2192 M} (h : \u2200 i \u2208 l, f i \u2264 g i) :\n    (l.map f).prod \u2264 (l.map g).prod", "start": [301, 1], "end": [305, 36], "kind": "commanddeclaration"}, {"full_name": "List.prod_lt_prod'", "code": "@[to_additive sum_lt_sum]\ntheorem prod_lt_prod' [Preorder M] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {l : List \u03b9} (f g : \u03b9 \u2192 M)\n    (h\u2081 : \u2200 i \u2208 l, f i \u2264 g i) (h\u2082 : \u2203 i \u2208 l, f i < g i) : (l.map f).prod < (l.map g).prod", "start": [309, 1], "end": [319, 54], "kind": "commanddeclaration"}, {"full_name": "List.prod_lt_prod_of_ne_nil", "code": "@[to_additive]\ntheorem prod_lt_prod_of_ne_nil [Preorder M] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {l : List \u03b9} (hl : l \u2260 []) (f g : \u03b9 \u2192 M)\n    (hlt : \u2200 i \u2208 l, f i < g i) : (l.map f).prod < (l.map g).prod", "start": [323, 1], "end": [329, 63], "kind": "commanddeclaration"}, {"full_name": "List.prod_le_pow_card", "code": "@[to_additive sum_le_card_nsmul]\ntheorem prod_le_pow_card [Preorder M] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (l : List M) (n : M) (h : \u2200 x \u2208 l, x \u2264 n) :\n    l.prod \u2264 n ^ l.length", "start": [333, 1], "end": [337, 78], "kind": "commanddeclaration"}, {"full_name": "List.exists_lt_of_prod_lt'", "code": "@[to_additive exists_lt_of_sum_lt]\ntheorem exists_lt_of_prod_lt' [LinearOrder M] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {l : List \u03b9} (f g : \u03b9 \u2192 M)\n    (h : (l.map f).prod < (l.map g).prod) : \u2203 i \u2208 l, f i < g i", "start": [341, 1], "end": [346, 24], "kind": "commanddeclaration"}, {"full_name": "List.exists_le_of_prod_le'", "code": "@[to_additive exists_le_of_sum_le]\ntheorem exists_le_of_prod_le' [LinearOrder M] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {l : List \u03b9} (hl : l \u2260 []) (f g : \u03b9 \u2192 M)\n    (h : (l.map f).prod \u2264 (l.map g).prod) : \u2203 x \u2208 l, f x \u2264 g x", "start": [350, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "List.one_le_prod_of_one_le", "code": "@[to_additive sum_nonneg]\ntheorem one_le_prod_of_one_le [Preorder M] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {l : List M}\n    (hl\u2081 : \u2200 x \u2208 l, (1 : M) \u2264 x) : 1 \u2264 l.prod", "start": [360, 1], "end": [368, 95], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_zero", "code": "theorem prod_eq_zero {L : List M\u2080} (h : (0 : M\u2080) \u2208 L) : L.prod = 0", "start": [378, 1], "end": [386, 76], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_zero_iff", "code": "@[simp]\ntheorem prod_eq_zero_iff [Nontrivial M\u2080] [NoZeroDivisors M\u2080] {L : List M\u2080} :\n    L.prod = 0 \u2194 (0 : M\u2080) \u2208 L", "start": [389, 1], "end": [396, 56], "kind": "commanddeclaration"}, {"full_name": "List.prod_ne_zero", "code": "theorem prod_ne_zero [Nontrivial M\u2080] [NoZeroDivisors M\u2080] {L : List M\u2080} (hL : (0 : M\u2080) \u2209 L) :\n    L.prod \u2260 0", "start": [399, 1], "end": [401, 27], "kind": "commanddeclaration"}, {"full_name": "List.prod_inv_reverse", "code": "@[to_additive \"This is the `List.sum` version of `add_neg_rev`\"]\ntheorem prod_inv_reverse : \u2200 L : List G, L.prod\u207b\u00b9 = (L.map fun x => x\u207b\u00b9).reverse.prod", "start": [410, 1], "end": [414, 45], "kind": "commanddeclaration"}, {"full_name": "List.prod_reverse_noncomm", "code": "@[to_additive \"A non-commutative variant of `List.sum_reverse`\"]\ntheorem prod_reverse_noncomm : \u2200 L : List G, L.reverse.prod = (L.map fun x => x\u207b\u00b9).prod\u207b\u00b9", "start": [418, 1], "end": [421, 26], "kind": "commanddeclaration"}, {"full_name": "List.prod_drop_succ", "code": "@[to_additive (attr := simp)\n  \"Counterpart to `List.sum_take_succ` when we have a negation operation\"]\ntheorem prod_drop_succ :\n    \u2200 (L : List G) (i : \u2115) (p), (L.drop (i + 1)).prod = (L.nthLe i p)\u207b\u00b9 * (L.drop i).prod", "start": [426, 1], "end": [433, 47], "kind": "commanddeclaration"}, {"full_name": "List.prod_inv", "code": "@[to_additive \"This is the `List.sum` version of `add_neg`\"]\ntheorem prod_inv : \u2200 L : List G, L.prod\u207b\u00b9 = (L.map fun x => x\u207b\u00b9).prod", "start": [443, 1], "end": [447, 47], "kind": "commanddeclaration"}, {"full_name": "List.prod_set'", "code": "@[to_additive \"Alternative version of `List.sum_set` when the list is over a group\"]\ntheorem prod_set' (L : List G) (n : \u2115) (a : G) :\n    (L.set n a).prod = L.prod * if hn : n < L.length then (L.nthLe n hn)\u207b\u00b9 * a else 1", "start": [451, 1], "end": [460, 61], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_prod_take_eq", "code": "@[to_additive]\ntheorem eq_of_prod_take_eq [LeftCancelMonoid M] {L L' : List M} (h : L.length = L'.length)\n    (h' : \u2200 i \u2264 L.length, (L.take i).prod = (L'.take i).prod) : L = L'", "start": [466, 1], "end": [472, 31], "kind": "commanddeclaration"}, {"full_name": "List.monotone_prod_take", "code": "@[to_additive]\ntheorem monotone_prod_take [CanonicallyOrderedCommMonoid M] (L : List M) :\n    Monotone fun i => (L.take i).prod", "start": [476, 1], "end": [483, 73], "kind": "commanddeclaration"}, {"full_name": "List.one_lt_prod_of_one_lt", "code": "@[to_additive sum_pos]\ntheorem one_lt_prod_of_one_lt [OrderedCommMonoid M] :\n    \u2200 (l : List M) (_ : \u2200 x \u2208 l, (1 : M) < x) (_ : l \u2260 []), 1 < l.prod", "start": [487, 1], "end": [499, 26], "kind": "commanddeclaration"}, {"full_name": "List.single_le_prod", "code": "@[to_additive]\ntheorem single_le_prod [OrderedCommMonoid M] {l : List M} (hl\u2081 : \u2200 x \u2208 l, (1 : M) \u2264 x) :\n    \u2200 x \u2208 l, x \u2264 l.prod", "start": [503, 1], "end": [511, 95], "kind": "commanddeclaration"}, {"full_name": "List.all_one_of_le_one_le_of_prod_eq_one", "code": "@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\ntheorem all_one_of_le_one_le_of_prod_eq_one [OrderedCommMonoid M] {l : List M}\n    (hl\u2081 : \u2200 x \u2208 l, (1 : M) \u2264 x) (hl\u2082 : l.prod = 1) {x : M} (hx : x \u2208 l) : x = 1", "start": [515, 1], "end": [518, 64], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_one", "code": "@[to_additive\n      \"Slightly more general version of `List.sum_eq_zero_iff` for a non-ordered `AddMonoid`\"]\ntheorem prod_eq_one [Monoid M] {l : List M} (hl : \u2200 x \u2208 l, x = (1 : M)) : l.prod = 1", "start": [522, 1], "end": [529, 13], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_ne_one_of_prod_ne_one", "code": "@[to_additive]\ntheorem exists_mem_ne_one_of_prod_ne_one [Monoid M] {l : List M} (h : l.prod \u2260 1) :\n    \u2203 x \u2208 l, x \u2260 (1 : M)", "start": [533, 1], "end": [535, 91], "kind": "commanddeclaration"}, {"full_name": "List.sum_le_foldr_max", "code": "theorem sum_le_foldr_max [AddMonoid M] [AddMonoid N] [LinearOrder N] (f : M \u2192 N) (h0 : f 0 \u2264 0)\n    (hadd : \u2200 x y, f (x + y) \u2264 max (f x) (f y)) (l : List M) : f l.sum \u2264 (l.map f).foldr max 0", "start": [540, 1], "end": [545, 48], "kind": "commanddeclaration"}, {"full_name": "List.prod_erase", "code": "@[to_additive (attr := simp)]\ntheorem prod_erase [DecidableEq M] [CommMonoid M] {a} :\n    \u2200 {l : List M}, a \u2208 l \u2192 a * (l.erase a).prod = l.prod", "start": [548, 1], "end": [554, 98], "kind": "commanddeclaration"}, {"full_name": "List.prod_map_erase", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_erase [DecidableEq \u03b9] [CommMonoid M] (f : \u03b9 \u2192 M) {a} :\n    \u2200 {l : List \u03b9}, a \u2208 l \u2192 f a * ((l.erase a).map f).prod = (l.map f).prod", "start": [558, 1], "end": [565, 35], "kind": "commanddeclaration"}, {"full_name": "List.sum_const_nat", "code": "theorem sum_const_nat (m n : \u2115) : sum (replicate m n) = m * n", "start": [569, 1], "end": [570, 20], "kind": "commanddeclaration"}, {"full_name": "List.prod_pos", "code": "theorem prod_pos [StrictOrderedSemiring R] (l : List R) (h : \u2200 a \u2208 l, (0 : R) < a) :\n    0 < l.prod", "start": [573, 1], "end": [580, 90], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.list_prod_pos", "code": "@[simp] lemma _root_.CanonicallyOrderedCommSemiring.list_prod_pos\n    {\u03b1 : Type*} [CanonicallyOrderedCommSemiring \u03b1] [Nontrivial \u03b1] :\n    \u2200 {l : List \u03b1}, 0 < l.prod \u2194 (\u2200 x \u2208 l, (0 : \u03b1) < x)\n  | [] => by simp\n  | (x :: xs) => by simp_rw [prod_cons, forall_mem_cons, CanonicallyOrderedCommSemiring.mul_pos,\n    list_prod_pos]", "start": [583, 1], "end": [589, 19], "kind": "mathlibtacticlemma"}, {"full_name": "List.headI_add_tail_sum", "code": "theorem headI_add_tail_sum (L : List \u2115) : L.headI + L.tail.sum = L.sum", "start": [598, 1], "end": [600, 19], "kind": "commanddeclaration"}, {"full_name": "List.headI_le_sum", "code": "theorem headI_le_sum (L : List \u2115) : L.headI \u2264 L.sum", "start": [603, 1], "end": [605, 38], "kind": "commanddeclaration"}, {"full_name": "List.tail_sum", "code": "theorem tail_sum (L : List \u2115) : L.tail.sum = L.sum - L.headI", "start": [608, 1], "end": [610, 64], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_nil", "code": "@[to_additive (attr := simp)]\ntheorem alternatingProd_nil : alternatingProd ([] : List \u03b1) = 1", "start": [619, 1], "end": [621, 6], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_singleton", "code": "@[to_additive (attr := simp)]\ntheorem alternatingProd_singleton (a : \u03b1) : alternatingProd [a] = a", "start": [625, 1], "end": [627, 6], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_cons_cons'", "code": "@[to_additive]\ntheorem alternatingProd_cons_cons' (a b : \u03b1) (l : List \u03b1) :\n    alternatingProd (a :: b :: l) = a * b\u207b\u00b9 * alternatingProd l", "start": [631, 1], "end": [634, 6], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_cons_cons", "code": "@[to_additive]\ntheorem alternatingProd_cons_cons [DivInvMonoid \u03b1] (a b : \u03b1) (l : List \u03b1) :\n    alternatingProd (a :: b :: l) = a / b * alternatingProd l", "start": [640, 1], "end": [643, 50], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_cons'", "code": "@[to_additive]\ntheorem alternatingProd_cons' :\n    \u2200 (a : \u03b1) (l : List \u03b1), alternatingProd (a :: l) = a * (alternatingProd l)\u207b\u00b9", "start": [649, 1], "end": [654, 92], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_cons", "code": "@[to_additive (attr := simp)]\ntheorem alternatingProd_cons (a : \u03b1) (l : List \u03b1) :\n    alternatingProd (a :: l) = a / alternatingProd l", "start": [658, 1], "end": [661, 45], "kind": "commanddeclaration"}, {"full_name": "List.sum_nat_mod", "code": "lemma sum_nat_mod (l : List \u2115) (n : \u2115) : l.sum % n = (l.map (\u00b7 % n)).sum % n := by\n  induction l <;> simp [Nat.add_mod, *]", "start": [667, 1], "end": [668, 40], "kind": "mathlibtacticlemma"}, {"full_name": "List.prod_nat_mod", "code": "lemma prod_nat_mod (l : List \u2115) (n : \u2115) : l.prod % n = (l.map (\u00b7 % n)).prod % n := by\n  induction l <;> simp [Nat.mul_mod, *]", "start": [671, 1], "end": [672, 40], "kind": "mathlibtacticlemma"}, {"full_name": "List.sum_int_mod", "code": "lemma sum_int_mod (l : List \u2124) (n : \u2124) : l.sum % n = (l.map (\u00b7 % n)).sum % n := by\n  induction l <;> simp [Int.add_emod, *]", "start": [675, 1], "end": [676, 41], "kind": "mathlibtacticlemma"}, {"full_name": "List.prod_int_mod", "code": "lemma prod_int_mod (l : List \u2124) (n : \u2124) : l.prod % n = (l.map (\u00b7 % n)).prod % n := by\n  induction l <;> simp [Int.mul_emod, *]", "start": [679, 1], "end": [680, 41], "kind": "mathlibtacticlemma"}, {"full_name": "map_list_prod", "code": "@[to_additive]\ntheorem map_list_prod {F : Type*} [MonoidHomClass F M N] (f : F) (l : List M) :\n    f l.prod = (l.map f).prod", "start": [689, 1], "end": [692, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_list_prod", "code": "@[to_additive \"Deprecated, use `_root_.map_list_sum` instead.\"]\nprotected theorem map_list_prod (f : M \u2192* N) (l : List M) : f l.prod = (l.map f).prod", "start": [698, 1], "end": [701, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Instances.lean", "imports": ["Mathlib/Algebra/Order/Monoid/OrderDual.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderDual.orderedCommGroup", "code": "@[to_additive]\ninstance OrderDual.orderedCommGroup [OrderedCommGroup \u03b1] : OrderedCommGroup \u03b1\u1d52\u1d48 :=\n  { OrderDual.orderedCommMonoid, OrderDual.instGroup with }", "start": [19, 1], "end": [21, 60], "kind": "commanddeclaration"}, {"full_name": "OrderDual.linearOrderedCommGroup", "code": "@[to_additive]\ninstance OrderDual.linearOrderedCommGroup [LinearOrderedCommGroup \u03b1] : LinearOrderedCommGroup \u03b1\u1d52\u1d48 :=\n  { OrderDual.orderedCommGroup, OrderDual.instLinearOrder \u03b1 with }", "start": [25, 1], "end": [27, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Equiv/Units/GroupWithZero.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.mulLeft\u2080", "code": "@[simps! (config := { fullyApplied := false })]\nprotected def mulLeft\u2080 (a : G) (ha : a \u2260 0) : Perm G :=\n  (Units.mk0 a ha).mulLeft", "start": [24, 1], "end": [28, 27], "kind": "commanddeclaration"}, {"full_name": "mulLeft_bijective\u2080", "code": "theorem _root_.mulLeft_bijective\u2080 (a : G) (ha : a \u2260 0) : Function.Bijective ((\u00b7 * \u00b7) a : G \u2192 G)", "start": [33, 1], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulRight\u2080", "code": "@[simps! (config := { fullyApplied := false })]\nprotected def mulRight\u2080 (a : G) (ha : a \u2260 0) : Perm G :=\n  (Units.mk0 a ha).mulRight", "start": [37, 1], "end": [41, 28], "kind": "commanddeclaration"}, {"full_name": "mulRight_bijective\u2080", "code": "theorem _root_.mulRight_bijective\u2080 (a : G) (ha : a \u2260 0) : Function.Bijective ((\u00b7 * a) : G \u2192 G)", "start": [46, 1], "end": [47, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Units.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Units.lean", "Mathlib/Algebra/Order/Monoid/Defs.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.orderedCommGroup", "code": "@[to_additive\n      \"The units of an ordered commutative additive monoid form an ordered commutative\n      additive group.\"]\ninstance Units.orderedCommGroup [OrderedCommMonoid \u03b1] : OrderedCommGroup \u03b1\u02e3 :=\n  { Units.instPartialOrderUnits, Units.instCommGroupUnits with\n    mul_le_mul_left := fun _ _ h _ => (@mul_le_mul_left' \u03b1 _ _ _ _ _ h _) }", "start": [19, 1], "end": [25, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/TypeTags.lean", "imports": ["Mathlib/Algebra/Group/TypeTags.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiplicative.preorder", "code": "instance Multiplicative.preorder : \u2200 [Preorder \u03b1], Preorder (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [28, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.preorder", "code": "instance Additive.preorder : \u2200 [Preorder \u03b1], Preorder (Additive \u03b1) :=\n  fun {inst} => inst", "start": [31, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.partialOrder", "code": "instance Multiplicative.partialOrder : \u2200 [PartialOrder \u03b1], PartialOrder (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [34, 1], "end": [35, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.partialOrder", "code": "instance Additive.partialOrder : \u2200 [PartialOrder \u03b1], PartialOrder (Additive \u03b1) :=\n  fun {inst} => inst", "start": [37, 1], "end": [38, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.linearOrder", "code": "instance Multiplicative.linearOrder : \u2200 [LinearOrder \u03b1], LinearOrder (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [40, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.linearOrder", "code": "instance Additive.linearOrder : \u2200 [LinearOrder \u03b1], LinearOrder (Additive \u03b1) :=\n  fun {inst} => inst", "start": [43, 1], "end": [44, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.orderBot", "code": "instance Multiplicative.orderBot [LE \u03b1] : \u2200 [OrderBot \u03b1], OrderBot (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [46, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.orderBot", "code": "instance Additive.orderBot [LE \u03b1] : \u2200 [OrderBot \u03b1], OrderBot (Additive \u03b1) :=\n  fun {inst} => inst", "start": [49, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.orderTop", "code": "instance Multiplicative.orderTop [LE \u03b1] : \u2200 [OrderTop \u03b1], OrderTop (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [52, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.orderTop", "code": "instance Additive.orderTop [LE \u03b1] : \u2200 [OrderTop \u03b1], OrderTop (Additive \u03b1) :=\n  fun {inst} => inst", "start": [55, 1], "end": [56, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.boundedOrder", "code": "instance Multiplicative.boundedOrder [LE \u03b1] : \u2200 [BoundedOrder \u03b1], BoundedOrder (Multiplicative \u03b1) :=\n  fun {inst} => inst", "start": [58, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Additive.boundedOrder", "code": "instance Additive.boundedOrder [LE \u03b1] : \u2200 [BoundedOrder \u03b1], BoundedOrder (Additive \u03b1) :=\n  fun {inst} => inst", "start": [61, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.orderedCommMonoid", "code": "instance Multiplicative.orderedCommMonoid [OrderedAddCommMonoid \u03b1] :\n    OrderedCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.partialOrder, Multiplicative.commMonoid with\n    mul_le_mul_left := @OrderedAddCommMonoid.add_le_add_left \u03b1 _ }", "start": [64, 1], "end": [67, 67], "kind": "commanddeclaration"}, {"full_name": "Additive.orderedAddCommMonoid", "code": "instance Additive.orderedAddCommMonoid [OrderedCommMonoid \u03b1] :\n    OrderedAddCommMonoid (Additive \u03b1) :=\n  { Additive.partialOrder, Additive.addCommMonoid with\n    add_le_add_left := @OrderedCommMonoid.mul_le_mul_left \u03b1 _ }", "start": [69, 1], "end": [72, 64], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.orderedCancelAddCommMonoid", "code": "instance Multiplicative.orderedCancelAddCommMonoid [OrderedCancelAddCommMonoid \u03b1] :\n    OrderedCancelCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.orderedCommMonoid with\n    le_of_mul_le_mul_left := @OrderedCancelAddCommMonoid.le_of_add_le_add_left \u03b1 _ }", "start": [74, 1], "end": [77, 85], "kind": "commanddeclaration"}, {"full_name": "Additive.orderedCancelAddCommMonoid", "code": "instance Additive.orderedCancelAddCommMonoid [OrderedCancelCommMonoid \u03b1] :\n    OrderedCancelAddCommMonoid (Additive \u03b1) :=\n  { Additive.orderedAddCommMonoid with\n    le_of_add_le_add_left := @OrderedCancelCommMonoid.le_of_mul_le_mul_left \u03b1 _ }", "start": [79, 1], "end": [82, 82], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.linearOrderedCommMonoid", "code": "instance Multiplicative.linearOrderedCommMonoid [LinearOrderedAddCommMonoid \u03b1] :\n    LinearOrderedCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.linearOrder, Multiplicative.orderedCommMonoid with }", "start": [84, 1], "end": [86, 72], "kind": "commanddeclaration"}, {"full_name": "Additive.linearOrderedAddCommMonoid", "code": "instance Additive.linearOrderedAddCommMonoid [LinearOrderedCommMonoid \u03b1] :\n    LinearOrderedAddCommMonoid (Additive \u03b1) :=\n  { Additive.linearOrder, Additive.orderedAddCommMonoid with }", "start": [88, 1], "end": [90, 63], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.existsMulOfLe", "code": "instance Multiplicative.existsMulOfLe [Add \u03b1] [LE \u03b1] [ExistsAddOfLE \u03b1] :\n    ExistsMulOfLE (Multiplicative \u03b1) :=\n  \u27e8@exists_add_of_le \u03b1 _ _ _\u27e9", "start": [92, 1], "end": [94, 30], "kind": "commanddeclaration"}, {"full_name": "Additive.existsAddOfLe", "code": "instance Additive.existsAddOfLe [Mul \u03b1] [LE \u03b1] [ExistsMulOfLE \u03b1] : ExistsAddOfLE (Additive \u03b1) :=\n  \u27e8@exists_mul_of_le \u03b1 _ _ _\u27e9", "start": [96, 1], "end": [97, 30], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.canonicallyOrderedCommMonoid", "code": "instance Multiplicative.canonicallyOrderedCommMonoid [CanonicallyOrderedAddCommMonoid \u03b1] :\n    CanonicallyOrderedCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.orderedCommMonoid, Multiplicative.orderBot,\n    Multiplicative.existsMulOfLe with le_self_mul := @le_self_add \u03b1 _ }", "start": [99, 1], "end": [102, 72], "kind": "commanddeclaration"}, {"full_name": "Additive.canonicallyOrderedAddCommMonoid", "code": "instance Additive.canonicallyOrderedAddCommMonoid [CanonicallyOrderedCommMonoid \u03b1] :\n    CanonicallyOrderedAddCommMonoid (Additive \u03b1) :=\n  { Additive.orderedAddCommMonoid, Additive.orderBot, Additive.existsAddOfLe with\n    le_self_add := @le_self_mul \u03b1 _ }", "start": [104, 1], "end": [107, 38], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.canonicallyLinearOrderedCommMonoid", "code": "instance Multiplicative.canonicallyLinearOrderedCommMonoid\n    [CanonicallyLinearOrderedAddCommMonoid \u03b1] :\n    CanonicallyLinearOrderedCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.canonicallyOrderedCommMonoid, Multiplicative.linearOrder with }", "start": [109, 1], "end": [112, 83], "kind": "commanddeclaration"}, {"full_name": "Additive.ofMul_le", "code": "@[simp]\ntheorem ofMul_le {a b : \u03b1} : ofMul a \u2264 ofMul b \u2194 a \u2264 b", "start": [122, 1], "end": [124, 10], "kind": "commanddeclaration"}, {"full_name": "Additive.ofMul_lt", "code": "@[simp]\ntheorem ofMul_lt {a b : \u03b1} : ofMul a < ofMul b \u2194 a < b", "start": [127, 1], "end": [129, 10], "kind": "commanddeclaration"}, {"full_name": "Additive.toMul_le", "code": "@[simp]\ntheorem toMul_le {a b : Additive \u03b1} : toMul a \u2264 toMul b \u2194 a \u2264 b", "start": [132, 1], "end": [134, 10], "kind": "commanddeclaration"}, {"full_name": "Additive.toMul_lt", "code": "@[simp]\ntheorem toMul_lt {a b : Additive \u03b1} : toMul a < toMul b \u2194 a < b", "start": [137, 1], "end": [139, 10], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.ofAdd_le", "code": "@[simp]\ntheorem ofAdd_le {a b : \u03b1} : ofAdd a \u2264 ofAdd b \u2194 a \u2264 b", "start": [148, 1], "end": [150, 10], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.ofAdd_lt", "code": "@[simp]\ntheorem ofAdd_lt {a b : \u03b1} : ofAdd a < ofAdd b \u2194 a < b", "start": [153, 1], "end": [155, 10], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toAdd_le", "code": "@[simp]\ntheorem toAdd_le {a b : Multiplicative \u03b1} : toAdd a \u2264 toAdd b \u2194 a \u2264 b", "start": [158, 1], "end": [160, 10], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toAdd_lt", "code": "@[simp]\ntheorem toAdd_lt {a b : Multiplicative \u03b1} : toAdd a < toAdd b \u2194 a < b", "start": [163, 1], "end": [165, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Basic.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Defs.lean", "Mathlib/Algebra/Group/InjSurj.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.orderedCommMonoid", "code": "@[to_additive (attr := reducible) \"Pullback an `OrderedAddCommMonoid` under an injective map.\"]\ndef Function.Injective.orderedCommMonoid [OrderedCommMonoid \u03b1] {\u03b2 : Type*} [One \u03b2] [Mul \u03b2]\n    [Pow \u03b2 \u2115] (f : \u03b2 \u2192 \u03b1) (hf : Function.Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    OrderedCommMonoid \u03b2 :=\n  { PartialOrder.lift f hf,\n    hf.commMonoid f one mul npow with\n    mul_le_mul_left := fun a b ab c =>\n      show f (c * a) \u2264 f (c * b) by\n        rw [mul, mul]\n        apply mul_le_mul_left'\n        exact ab }", "start": [25, 1], "end": [38, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCommMonoid", "code": "@[to_additive (attr := reducible) \"Pullback an `OrderedAddCommMonoid` under an injective map.\"]\ndef Function.Injective.linearOrderedCommMonoid [LinearOrderedCommMonoid \u03b1] {\u03b2 : Type*} [One \u03b2]\n    [Mul \u03b2] [Pow \u03b2 \u2115] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Function.Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedCommMonoid \u03b2 :=\n  { hf.orderedCommMonoid f one mul npow, LinearOrder.lift f hf hsup hinf with }", "start": [42, 1], "end": [50, 80], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.mulLeft", "code": "@[to_additive (attr := simps!)\n      \"The order embedding sending `b` to `a + b`, for some fixed `a`.\n       See also `OrderIso.addLeft` when working in an additive ordered group.\"]\ndef OrderEmbedding.mulLeft {\u03b1 : Type*} [Mul \u03b1] [LinearOrder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (m : \u03b1) : \u03b1 \u21aao \u03b1 :=\n  OrderEmbedding.ofStrictMono (fun n => m * n) fun _ _ w => mul_lt_mul_left' w m", "start": [55, 1], "end": [62, 81], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.mulRight", "code": "@[to_additive (attr := simps!)\n      \"The order embedding sending `b` to `b + a`, for some fixed `a`.\n       See also `OrderIso.addRight` when working in an additive ordered group.\"]\ndef OrderEmbedding.mulRight {\u03b1 : Type*} [Mul \u03b1] [LinearOrder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (m : \u03b1) : \u03b1 \u21aao \u03b1 :=\n  OrderEmbedding.ofStrictMono (fun n => n * m) fun _ _ w => mul_lt_mul_right' w m", "start": [68, 1], "end": [75, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Ring/Defs.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonUnitalRingHom", "code": "structure NonUnitalRingHom (\u03b1 \u03b2 : Type*) [NonUnitalNonAssocSemiring \u03b1]\n  [NonUnitalNonAssocSemiring \u03b2] extends \u03b1 \u2192\u2099* \u03b2, \u03b1 \u2192+ \u03b2", "start": [51, 1], "end": [59, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHomClass", "code": "class NonUnitalRingHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [NonUnitalNonAssocSemiring \u03b1]\n  [NonUnitalNonAssocSemiring \u03b2] extends MulHomClass F \u03b1 \u03b2, AddMonoidHomClass F \u03b1 \u03b2", "start": [77, 1], "end": [80, 83], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHomClass.toNonUnitalRingHom", "code": "@[coe]\ndef NonUnitalRingHomClass.toNonUnitalRingHom (f : F) : \u03b1 \u2192\u2099+* \u03b2 :=\n  { (f : \u03b1 \u2192\u2099* \u03b2), (f : \u03b1 \u2192+ \u03b2) with }", "start": [85, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_toMulHom", "code": "@[simp]\ntheorem coe_toMulHom (f : \u03b1 \u2192\u2099+* \u03b2) : \u21d1f.toMulHom = f", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_mulHom_mk", "code": "@[simp]\ntheorem coe_mulHom_mk (f : \u03b1 \u2192 \u03b2) (h\u2081 h\u2082 h\u2083) :\n    ((\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9 : \u03b1 \u2192\u2099+* \u03b2) : \u03b1 \u2192\u2099* \u03b2) = \u27e8f, h\u2081\u27e9", "start": [135, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_toAddMonoidHom", "code": "theorem coe_toAddMonoidHom (f : \u03b1 \u2192\u2099+* \u03b2) : \u21d1f.toAddMonoidHom = f", "start": [141, 1], "end": [141, 73], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_addMonoidHom_mk", "code": "@[simp]\ntheorem coe_addMonoidHom_mk (f : \u03b1 \u2192 \u03b2) (h\u2081 h\u2082 h\u2083) :\n    ((\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9 : \u03b1 \u2192\u2099+* \u03b2) : \u03b1 \u2192+ \u03b2) = \u27e8\u27e8f, h\u2082\u27e9, h\u2083\u27e9", "start": [144, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.copy", "code": "protected def copy (f : \u03b1 \u2192\u2099+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192\u2099+* \u03b2 :=\n  { f.toMulHom.copy f' h, f.toAddMonoidHom.copy f' h with }", "start": [150, 1], "end": [153, 60], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192\u2099+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192\u2099+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [161, 1], "end": [162, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.ext", "code": "@[ext]\ntheorem ext \u2983f g : \u03b1 \u2192\u2099+* \u03b2\u2984 : (\u2200 x, f x = g x) \u2192 f = g", "start": [172, 1], "end": [174, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.ext_iff", "code": "theorem ext_iff {f g : \u03b1 \u2192\u2099+* \u03b2} : f = g \u2194 \u2200 x, f x = g x", "start": [177, 1], "end": [178, 18], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : \u03b1 \u2192\u2099+* \u03b2) (h\u2081 h\u2082 h\u2083) : NonUnitalRingHom.mk (MulHom.mk f h\u2081) h\u2082 h\u2083 = f", "start": [181, 1], "end": [183, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_addMonoidHom_injective", "code": "theorem coe_addMonoidHom_injective : Injective fun f : \u03b1 \u2192\u2099+* \u03b2 => (f : \u03b1 \u2192+ \u03b2)", "start": [186, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_mulHom_injective", "code": "theorem coe_mulHom_injective : Injective fun f : \u03b1 \u2192\u2099+* \u03b2 => (f : \u03b1 \u2192\u2099* \u03b2)", "start": [191, 1], "end": [192, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.id", "code": "protected def id (\u03b1 : Type*) [NonUnitalNonAssocSemiring \u03b1] : \u03b1 \u2192\u2099+* \u03b1 := by\n  refine' { toFun := id.. } <;> intros <;> rfl", "start": [199, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : \u03b1 \u2192\u2099+* \u03b2) = 0", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : \u03b1) : (0 : \u03b1 \u2192\u2099+* \u03b2) x = 0", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.id_apply", "code": "@[simp]\ntheorem id_apply (x : \u03b1) : NonUnitalRingHom.id \u03b1 x = x", "start": [221, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_addMonoidHom_id", "code": "@[simp]\ntheorem coe_addMonoidHom_id : (NonUnitalRingHom.id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1", "start": [226, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_mulHom_id", "code": "@[simp]\ntheorem coe_mulHom_id : (NonUnitalRingHom.id \u03b1 : \u03b1 \u2192\u2099* \u03b1) = MulHom.id \u03b1", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.comp", "code": "def comp (g : \u03b2 \u2192\u2099+* \u03b3) (f : \u03b1 \u2192\u2099+* \u03b2) : \u03b1 \u2192\u2099+* \u03b3 :=\n  { g.toMulHom.comp f.toMulHom, g.toAddMonoidHom.comp f.toAddMonoidHom with }", "start": [238, 1], "end": [240, 78], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.comp_assoc", "code": "theorem comp_assoc {\u03b4} {_ : NonUnitalNonAssocSemiring \u03b4} (f : \u03b1 \u2192\u2099+* \u03b2) (g : \u03b2 \u2192\u2099+* \u03b3)\n    (h : \u03b3 \u2192\u2099+* \u03b4) : (h.comp g).comp f = h.comp (g.comp f)", "start": [243, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (g : \u03b2 \u2192\u2099+* \u03b3) (f : \u03b1 \u2192\u2099+* \u03b2) : \u21d1(g.comp f) = g \u2218 f", "start": [249, 1], "end": [251, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : \u03b2 \u2192\u2099+* \u03b3) (f : \u03b1 \u2192\u2099+* \u03b2) (x : \u03b1) : g.comp f x = g (f x)", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_comp_addMonoidHom", "code": "@[simp]\ntheorem coe_comp_addMonoidHom (g : \u03b2 \u2192\u2099+* \u03b3) (f : \u03b1 \u2192\u2099+* \u03b2) :\n    AddMonoidHom.mk \u27e8g \u2218 f, (g.comp f).map_zero'\u27e9 (g.comp f).map_add' = (g : \u03b2 \u2192+ \u03b3).comp f", "start": [260, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_comp_mulHom", "code": "@[simp]\ntheorem coe_comp_mulHom (g : \u03b2 \u2192\u2099+* \u03b3) (f : \u03b1 \u2192\u2099+* \u03b2) :\n    MulHom.mk (g \u2218 f) (g.comp f).map_mul' = (g : \u03b2 \u2192\u2099* \u03b3).comp f", "start": [266, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.comp_zero", "code": "@[simp]\ntheorem comp_zero (g : \u03b2 \u2192\u2099+* \u03b3) : g.comp (0 : \u03b1 \u2192\u2099+* \u03b2) = 0", "start": [272, 1], "end": [275, 7], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.zero_comp", "code": "@[simp]\ntheorem zero_comp (f : \u03b1 \u2192\u2099+* \u03b2) : (0 : \u03b2 \u2192\u2099+* \u03b3).comp f = 0", "start": [278, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192\u2099+* \u03b2) : f.comp (NonUnitalRingHom.id \u03b1) = f", "start": [284, 1], "end": [286, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192\u2099+* \u03b2) : (NonUnitalRingHom.id \u03b2).comp f = f", "start": [289, 1], "end": [291, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.one_def", "code": "theorem one_def : (1 : \u03b1 \u2192\u2099+* \u03b1) = NonUnitalRingHom.id \u03b1", "start": [304, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : \u03b1 \u2192\u2099+* \u03b1) = id", "start": [308, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.mul_def", "code": "theorem mul_def (f g : \u03b1 \u2192\u2099+* \u03b1) : f * g = f.comp g", "start": [313, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : \u03b1 \u2192\u2099+* \u03b1) : \u21d1(f * g) = f \u2218 g", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192\u2099+* \u03b3} {f : \u03b1 \u2192\u2099+* \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [322, 1], "end": [325, 64], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192\u2099+* \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192\u2099+* \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [328, 1], "end": [331, 86], "kind": "commanddeclaration"}, {"full_name": "RingHom", "code": "structure RingHom (\u03b1 : Type*) (\u03b2 : Type*) [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2] extends\n  \u03b1 \u2192* \u03b2, \u03b1 \u2192+ \u03b2, \u03b1 \u2192\u2099+* \u03b2, \u03b1 \u2192*\u2080 \u03b2", "start": [336, 1], "end": [341, 36], "kind": "commanddeclaration"}, {"full_name": "RingHomClass", "code": "class RingHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [NonAssocSemiring \u03b1]\n  [NonAssocSemiring \u03b2] extends MonoidHomClass F \u03b1 \u03b2, AddMonoidHomClass F \u03b1 \u03b2,\n  MonoidWithZeroHomClass F \u03b1 \u03b2", "start": [369, 1], "end": [377, 31], "kind": "commanddeclaration"}, {"full_name": "map_bit1", "code": "@[simp] lemma map_bit1 [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2] [RingHomClass F \u03b1 \u03b2]\n    (f : F) (a : \u03b1) : (f (bit1 a) : \u03b2) = bit1 (f a) := by simp [bit1]", "start": [381, 1], "end": [383, 70], "kind": "mathlibtacticlemma"}, {"full_name": "RingHomClass.toRingHom", "code": "@[coe]\ndef RingHomClass.toRingHom (f : F) : \u03b1 \u2192+* \u03b2 :=\n  { (f : \u03b1 \u2192* \u03b2), (f : \u03b1 \u2192+ \u03b2) with }", "start": [389, 1], "end": [393, 38], "kind": "commanddeclaration"}, {"full_name": "RingHomClass.toNonUnitalRingHomClass", "code": "instance (priority := 100) RingHomClass.toNonUnitalRingHomClass : NonUnitalRingHomClass F \u03b1 \u03b2 :=\n  { \u2039RingHomClass F \u03b1 \u03b2\u203a with }", "start": [399, 1], "end": [400, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.instRingHomClass", "code": "instance instRingHomClass : RingHomClass (\u03b1 \u2192+* \u03b2) \u03b1 \u03b2 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    apply FunLike.coe_injective'\n    exact h\n  map_add := RingHom.map_add'\n  map_zero := RingHom.map_zero'\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'", "start": [416, 1], "end": [427, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.toFun_eq_coe", "code": "theorem toFun_eq_coe (f : \u03b1 \u2192+* \u03b2) : f.toFun = f", "start": [444, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u03b1 \u2192* \u03b2) (h\u2081 h\u2082) : ((\u27e8f, h\u2081, h\u2082\u27e9 : \u03b1 \u2192+* \u03b2) : \u03b1 \u2192 \u03b2) = f", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_coe", "code": "@[simp]\ntheorem coe_coe {F : Type*} [RingHomClass F \u03b1 \u03b2] (f : F) : ((f : \u03b1 \u2192+* \u03b2) : \u03b1 \u2192 \u03b2) = f", "start": [453, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coeToMonoidHom", "code": "instance coeToMonoidHom : Coe (\u03b1 \u2192+* \u03b2) (\u03b1 \u2192* \u03b2) :=\n  \u27e8RingHom.toMonoidHom\u27e9", "start": [460, 1], "end": [461, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.toMonoidHom_eq_coe", "code": "@[simp]\ntheorem toMonoidHom_eq_coe (f : \u03b1 \u2192+* \u03b2) : f.toMonoidHom = f", "start": [467, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.toMonoidWithZeroHom_eq_coe", "code": "theorem toMonoidWithZeroHom_eq_coe (f : \u03b1 \u2192+* \u03b2) : (f.toMonoidWithZeroHom : \u03b1 \u2192 \u03b2) = f", "start": [474, 1], "end": [475, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_monoidHom_mk", "code": "@[simp]\ntheorem coe_monoidHom_mk (f : \u03b1 \u2192* \u03b2) (h\u2081 h\u2082) : ((\u27e8f, h\u2081, h\u2082\u27e9 : \u03b1 \u2192+* \u03b2) : \u03b1 \u2192* \u03b2) = f", "start": [478, 1], "end": [480, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.toAddMonoidHom_eq_coe", "code": "@[simp]\ntheorem toAddMonoidHom_eq_coe (f : \u03b1 \u2192+* \u03b2) : f.toAddMonoidHom = f", "start": [486, 1], "end": [488, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_addMonoidHom_mk", "code": "@[simp]\ntheorem coe_addMonoidHom_mk (f : \u03b1 \u2192 \u03b2) (h\u2081 h\u2082 h\u2083 h\u2084) :\n    ((\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083, h\u2084\u27e9 : \u03b1 \u2192+* \u03b2) : \u03b1 \u2192+ \u03b2) = \u27e8\u27e8f, h\u2083\u27e9, h\u2084\u27e9", "start": [491, 1], "end": [494, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.copy", "code": "def copy (f : \u03b1 \u2192+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192+* \u03b2 :=\n  { f.toMonoidWithZeroHom.copy f' h, f.toAddMonoidHom.copy f' h with }", "start": [497, 1], "end": [500, 71], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [503, 1], "end": [505, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192+* \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [508, 1], "end": [509, 17], "kind": "commanddeclaration"}, {"full_name": "RingHom.congr_fun", "code": "theorem congr_fun {f g : \u03b1 \u2192+* \u03b2} (h : f = g) (x : \u03b1) : f x = g x", "start": [518, 1], "end": [519, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.congr_arg", "code": "theorem congr_arg (f : \u03b1 \u2192+* \u03b2) {x y : \u03b1} (h : x = y) : f x = f y", "start": [522, 1], "end": [523, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_inj", "code": "theorem coe_inj \u2983f g : \u03b1 \u2192+* \u03b2\u2984 (h : (f : \u03b1 \u2192 \u03b2) = g) : f = g", "start": [526, 1], "end": [527, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.ext", "code": "@[ext]\ntheorem ext \u2983f g : \u03b1 \u2192+* \u03b2\u2984 : (\u2200 x, f x = g x) \u2192 f = g", "start": [530, 1], "end": [532, 18], "kind": "commanddeclaration"}, {"full_name": "RingHom.ext_iff", "code": "theorem ext_iff {f g : \u03b1 \u2192+* \u03b2} : f = g \u2194 \u2200 x, f x = g x", "start": [535, 1], "end": [536, 18], "kind": "commanddeclaration"}, {"full_name": "RingHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : \u03b1 \u2192+* \u03b2) (h\u2081 h\u2082 h\u2083 h\u2084) : RingHom.mk \u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9 h\u2083 h\u2084 = f", "start": [539, 1], "end": [541, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_addMonoidHom_injective", "code": "theorem coe_addMonoidHom_injective : Injective (fun f : \u03b1 \u2192+* \u03b2 => (f : \u03b1 \u2192+ \u03b2))", "start": [544, 1], "end": [545, 43], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_monoidHom_injective", "code": "theorem coe_monoidHom_injective : Injective (fun f : \u03b1 \u2192+* \u03b2 => (f : \u03b1 \u2192* \u03b2))", "start": [549, 1], "end": [550, 31], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_zero", "code": "protected theorem map_zero (f : \u03b1 \u2192+* \u03b2) : f 0 = 0", "start": [553, 1], "end": [555, 13], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_one", "code": "protected theorem map_one (f : \u03b1 \u2192+* \u03b2) : f 1 = 1", "start": [558, 1], "end": [560, 12], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_add", "code": "protected theorem map_add (f : \u03b1 \u2192+* \u03b2) : \u2200 a b, f (a + b) = f a + f b", "start": [563, 1], "end": [565, 12], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_mul", "code": "protected theorem map_mul (f : \u03b1 \u2192+* \u03b2) : \u2200 a b, f (a * b) = f a * f b", "start": [568, 1], "end": [570, 12], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_ite_zero_one", "code": "@[simp]\ntheorem map_ite_zero_one {F : Type*} [RingHomClass F \u03b1 \u03b2] (f : F) (p : Prop) [Decidable p] :\n    f (ite p 0 1) = ite p 0 1", "start": [573, 1], "end": [576, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_ite_one_zero", "code": "@[simp]\ntheorem map_ite_one_zero {F : Type*} [RingHomClass F \u03b1 \u03b2] (f : F) (p : Prop) [Decidable p] :\n    f (ite p 1 0) = ite p 1 0", "start": [579, 1], "end": [582, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.codomain_trivial_iff_map_one_eq_zero", "code": "theorem codomain_trivial_iff_map_one_eq_zero : (0 : \u03b2) = 1 \u2194 f 1 = 0", "start": [585, 1], "end": [586, 97], "kind": "commanddeclaration"}, {"full_name": "RingHom.codomain_trivial_iff_range_trivial", "code": "theorem codomain_trivial_iff_range_trivial : (0 : \u03b2) = 1 \u2194 \u2200 x, f x = 0", "start": [589, 1], "end": [592, 73], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_one_ne_zero", "code": "theorem map_one_ne_zero [Nontrivial \u03b2] : f 1 \u2260 0", "start": [595, 1], "end": [597, 60], "kind": "commanddeclaration"}, {"full_name": "RingHom.domain_nontrivial", "code": "theorem domain_nontrivial [Nontrivial \u03b2] : Nontrivial \u03b1", "start": [600, 1], "end": [602, 77], "kind": "commanddeclaration"}, {"full_name": "RingHom.codomain_trivial", "code": "theorem codomain_trivial (f : \u03b1 \u2192+* \u03b2) [h : Subsingleton \u03b1] : Subsingleton \u03b2", "start": [605, 1], "end": [607, 62], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_neg", "code": "protected theorem map_neg [NonAssocRing \u03b1] [NonAssocRing \u03b2] (f : \u03b1 \u2192+* \u03b2) (x : \u03b1) : f (-x) = -f x", "start": [612, 1], "end": [614, 14], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_sub", "code": "protected theorem map_sub [NonAssocRing \u03b1] [NonAssocRing \u03b2] (f : \u03b1 \u2192+* \u03b2) (x y : \u03b1) :\n    f (x - y) = f x - f y", "start": [617, 1], "end": [620, 16], "kind": "commanddeclaration"}, {"full_name": "RingHom.mk'", "code": "def mk' [NonAssocSemiring \u03b1] [NonAssocRing \u03b2] (f : \u03b1 \u2192* \u03b2)\n    (map_add : \u2200 a b, f (a + b) = f a + f b) : \u03b1 \u2192+* \u03b2 :=\n  { AddMonoidHom.mk' f map_add, f with }", "start": [623, 1], "end": [626, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.id", "code": "def id (\u03b1 : Type*) [NonAssocSemiring \u03b1] : \u03b1 \u2192+* \u03b1 := by\n  refine' { toFun := _root_.id.. } <;> intros <;> rfl", "start": [631, 1], "end": [633, 54], "kind": "commanddeclaration"}, {"full_name": "RingHom.id_apply", "code": "@[simp]\ntheorem id_apply (x : \u03b1) : RingHom.id \u03b1 x = x", "start": [639, 1], "end": [641, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_addMonoidHom_id", "code": "@[simp]\ntheorem coe_addMonoidHom_id : (id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1", "start": [644, 1], "end": [646, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_monoidHom_id", "code": "@[simp]\ntheorem coe_monoidHom_id : (id \u03b1 : \u03b1 \u2192* \u03b1) = MonoidHom.id \u03b1", "start": [649, 1], "end": [651, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.comp", "code": "def comp (g : \u03b2 \u2192+* \u03b3) (f : \u03b1 \u2192+* \u03b2) : \u03b1 \u2192+* \u03b3 :=\n  { g.toNonUnitalRingHom.comp f.toNonUnitalRingHom with toFun := g \u2218 f, map_one' := by simp }", "start": [656, 1], "end": [658, 94], "kind": "commanddeclaration"}, {"full_name": "RingHom.comp_assoc", "code": "theorem comp_assoc {\u03b4} {_ : NonAssocSemiring \u03b4} (f : \u03b1 \u2192+* \u03b2) (g : \u03b2 \u2192+* \u03b3) (h : \u03b3 \u2192+* \u03b4) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [661, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (hnp : \u03b2 \u2192+* \u03b3) (hmn : \u03b1 \u2192+* \u03b2) : (hnp.comp hmn : \u03b1 \u2192 \u03b3) = hnp \u2218 hmn", "start": [667, 1], "end": [669, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.comp_apply", "code": "theorem comp_apply (hnp : \u03b2 \u2192+* \u03b3) (hmn : \u03b1 \u2192+* \u03b2) (x : \u03b1) :\n    (hnp.comp hmn : \u03b1 \u2192 \u03b3) x = hnp (hmn x)", "start": [672, 1], "end": [674, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192+* \u03b2) : f.comp (id \u03b1) = f", "start": [677, 1], "end": [679, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192+* \u03b2) : (id \u03b2).comp f = f", "start": [682, 1], "end": [684, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.one_def", "code": "theorem one_def : (1 : \u03b1 \u2192+* \u03b1) = id \u03b1", "start": [694, 1], "end": [695, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mul_def", "code": "theorem mul_def (f g : \u03b1 \u2192+* \u03b1) : f * g = f.comp g", "start": [698, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : \u03b1 \u2192+* \u03b1) = _root_.id", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : \u03b1 \u2192+* \u03b1) : \u21d1(f * g) = f \u2218 g", "start": [707, 1], "end": [709, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : \u03b2 \u2192+* \u03b3} {f : \u03b1 \u2192+* \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [712, 1], "end": [715, 72], "kind": "commanddeclaration"}, {"full_name": "RingHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : \u03b2 \u2192+* \u03b3} {f\u2081 f\u2082 : \u03b1 \u2192+* \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [718, 1], "end": [721, 94], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mkRingHomOfMulSelfOfTwoNeZero", "code": "def mkRingHomOfMulSelfOfTwoNeZero (h : \u2200 x, f (x * x) = f x * f x) (h_two : (2 : \u03b1) \u2260 0)\n    (h_one : f 1 = 1) : \u03b2 \u2192+* \u03b1 :=\n  { f with\n    map_one' := h_one,\n    map_mul' := fun x y => by\n      have hxy := h (x + y)\n      rw [mul_add, add_mul, add_mul, f.map_add, f.map_add, f.map_add, f.map_add, h x, h y, add_mul,\n        mul_add, mul_add, \u2190 sub_eq_zero, add_comm (f x * f x + f (y * x)), \u2190 sub_sub, \u2190 sub_sub,\n        \u2190 sub_sub, mul_comm y x, mul_comm (f y) (f x)] at hxy\n      simp only [add_assoc, add_sub_assoc, add_sub_cancel'_right] at hxy\n      rw [sub_sub, \u2190 two_mul, \u2190 add_sub_assoc, \u2190 two_mul, \u2190 mul_sub, mul_eq_zero (M\u2080 := \u03b1),\n        sub_eq_zero, or_iff_not_imp_left] at hxy\n      exact hxy h_two }", "start": [733, 1], "end": [748, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_fn_mkRingHomOfMulSelfOfTwoNeZero", "code": "@[simp]\ntheorem coe_fn_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :\n    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : \u03b2 \u2192 \u03b1) = f", "start": [751, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero", "code": "theorem coe_addMonoidHom_mkRingHomOfMulSelfOfTwoNeZero (h h_two h_one) :\n    (f.mkRingHomOfMulSelfOfTwoNeZero h h_two h_one : \u03b2 \u2192+ \u03b1) = f", "start": [759, 1], "end": [762, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Commute.lean", "imports": ["Mathlib/Algebra/Group/Commute/Units.lean", "Mathlib/Algebra/GroupWithZero/Semiconj.lean", "Mathlib/Tactic/Nontriviality.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ring.mul_inverse_rev'", "code": "theorem mul_inverse_rev' {a b : M\u2080} (h : Commute a b) :\n    inverse (a * b) = inverse b * inverse a", "start": [26, 1], "end": [33, 65], "kind": "commanddeclaration"}, {"full_name": "Ring.mul_inverse_rev", "code": "theorem mul_inverse_rev {M\u2080} [CommMonoidWithZero M\u2080] (a b : M\u2080) :\n    Ring.inverse (a * b) = inverse b * inverse a", "start": [36, 1], "end": [38, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.ring_inverse_ring_inverse", "code": "theorem Commute.ring_inverse_ring_inverse {a b : M\u2080} (h : Commute a b) :\n    Commute (Ring.inverse a) (Ring.inverse b)", "start": [43, 1], "end": [46, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.zero_right", "code": "@[simp]\ntheorem zero_right [MulZeroClass G\u2080] (a : G\u2080) : Commute a 0", "start": [51, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "Commute.zero_left", "code": "@[simp]\ntheorem zero_left [MulZeroClass G\u2080] (a : G\u2080) : Commute 0 a", "start": [56, 1], "end": [58, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_left_iff\u2080", "code": "@[simp]\ntheorem inv_left_iff\u2080 : Commute a\u207b\u00b9 b \u2194 Commute a b", "start": [63, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_left\u2080", "code": "theorem inv_left\u2080 (h : Commute a b) : Commute a\u207b\u00b9 b", "start": [68, 1], "end": [69, 20], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_right_iff\u2080", "code": "@[simp]\ntheorem inv_right_iff\u2080 : Commute a b\u207b\u00b9 \u2194 Commute a b", "start": [72, 1], "end": [74, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_right\u2080", "code": "theorem inv_right\u2080 (h : Commute a b) : Commute a b\u207b\u00b9", "start": [77, 1], "end": [78, 21], "kind": "commanddeclaration"}, {"full_name": "Commute.div_right", "code": "@[simp]\ntheorem div_right (hab : Commute a b) (hac : Commute a c) : Commute a (b / c)", "start": [81, 1], "end": [83, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.div_left", "code": "@[simp]\ntheorem div_left (hac : Commute a c) (hbc : Commute b c) : Commute (a / b) c", "start": [86, 1], "end": [89, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupPower/Basic.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Group/TypeTags.lean", "Mathlib/Algebra/Group/Commute/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "pow_ite", "code": "@[to_additive (attr := simp) ite_nsmul]\ntheorem pow_ite (P : Prop) [Decidable P] (a : M) (b c : \u2115) :\n    (a ^ if P then b else c) = if P then a ^ b else a ^ c", "start": [51, 1], "end": [53, 82], "kind": "commanddeclaration"}, {"full_name": "ite_pow", "code": "@[to_additive (attr := simp) nsmul_ite]\ntheorem ite_pow (P : Prop) [Decidable P] (a b : M) (c : \u2115) :\n    (if P then a else b) ^ c = if P then a ^ c else b ^ c", "start": [56, 1], "end": [58, 82], "kind": "commanddeclaration"}, {"full_name": "nsmul_zero", "code": "theorem nsmul_zero (n : \u2115) : n \u2022 (0 : A) = 0", "start": [72, 1], "end": [75, 34], "kind": "commanddeclaration"}, {"full_name": "one_nsmul", "code": "@[simp]\ntheorem one_nsmul (a : A) : 1 \u2022 a = a", "start": [78, 1], "end": [79, 82], "kind": "commanddeclaration"}, {"full_name": "add_nsmul", "code": "theorem add_nsmul (a : A) (m n : \u2115) : (m + n) \u2022 a = m \u2022 a + n \u2022 a", "start": [82, 1], "end": [85, 95], "kind": "commanddeclaration"}, {"full_name": "one_pow", "code": "@[to_additive existing nsmul_zero, simp]\ntheorem one_pow (n : \u2115) : (1 : M) ^ n = 1", "start": [89, 1], "end": [93, 31], "kind": "commanddeclaration"}, {"full_name": "pow_one", "code": "@[to_additive existing (attr := simp) one_nsmul]\ntheorem pow_one (a : M) : a ^ 1 = a", "start": [96, 1], "end": [97, 75], "kind": "commanddeclaration"}, {"full_name": "pow_two", "code": "@[to_additive two_nsmul \"\"]\ntheorem pow_two (a : M) : a ^ 2 = a * a", "start": [100, 1], "end": [102, 69], "kind": "commanddeclaration"}, {"full_name": "sq", "code": "alias sq := pow_two", "start": [106, 1], "end": [106, 20], "kind": "stdtacticaliasalias"}, {"full_name": "pow_three'", "code": "@[to_additive three'_nsmul]\ntheorem pow_three' (a : M) : a ^ 3 = a * a * a", "start": [109, 1], "end": [110, 77], "kind": "commanddeclaration"}, {"full_name": "pow_three", "code": "@[to_additive three_nsmul]\ntheorem pow_three (a : M) : a ^ 3 = a * (a * a)", "start": [113, 1], "end": [114, 77], "kind": "commanddeclaration"}, {"full_name": "pow_add", "code": "@[to_additive existing add_nsmul]\ntheorem pow_add (a : M) (m n : \u2115) : a ^ (m + n) = a ^ m * a ^ n", "start": [117, 1], "end": [121, 66], "kind": "commanddeclaration"}, {"full_name": "pow_mul", "code": "@[to_additive mul_nsmul]\ntheorem pow_mul (a : M) (m n : \u2115) : a ^ (m * n) = (a ^ m) ^ n", "start": [124, 1], "end": [128, 46], "kind": "commanddeclaration"}, {"full_name": "pow_mul'", "code": "@[to_additive mul_nsmul']\ntheorem pow_mul' (a : M) (m n : \u2115) : a ^ (m * n) = (a ^ n) ^ m", "start": [134, 1], "end": [135, 96], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_pow", "code": "@[to_additive]\ntheorem Commute.mul_pow {a b : M} (h : Commute a b) (n : \u2115) : (a * b) ^ n = a ^ n * b ^ n", "start": [139, 1], "end": [143, 69], "kind": "commanddeclaration"}, {"full_name": "pow_mul_comm'", "code": "@[to_additive]\ntheorem pow_mul_comm' (a : M) (n : \u2115) : a ^ n * a = a * a ^ n", "start": [147, 1], "end": [149, 23], "kind": "commanddeclaration"}, {"full_name": "pow_boole", "code": "@[to_additive boole_nsmul]\ntheorem pow_boole (P : Prop) [Decidable P] (a : M) :\n    (a ^ if P then 1 else 0) = if P then a else 1", "start": [153, 1], "end": [155, 61], "kind": "commanddeclaration"}, {"full_name": "pow_right_comm", "code": "@[to_additive nsmul_left_comm]\ntheorem pow_right_comm (a : M) (m n : \u2115) : (a ^ m) ^ n = (a ^ n) ^ m", "start": [158, 1], "end": [160, 40], "kind": "commanddeclaration"}, {"full_name": "pow_mul_pow_sub", "code": "@[to_additive nsmul_add_sub_nsmul]\ntheorem pow_mul_pow_sub (a : M) {m n : \u2115} (h : m \u2264 n) : a ^ m * a ^ (n - m) = a ^ n", "start": [164, 1], "end": [166, 53], "kind": "commanddeclaration"}, {"full_name": "pow_sub_mul_pow", "code": "@[to_additive sub_nsmul_nsmul_add]\ntheorem pow_sub_mul_pow (a : M) {m n : \u2115} (h : m \u2264 n) : a ^ (n - m) * a ^ m = a ^ n", "start": [170, 1], "end": [172, 39], "kind": "commanddeclaration"}, {"full_name": "pow_eq_pow_mod", "code": "@[to_additive nsmul_eq_mod_nsmul \"If `n \u2022 x = 0`, then `m \u2022 x` is the same as `(m % n) \u2022 x`\"]\ntheorem pow_eq_pow_mod {M : Type*} [Monoid M] {x : M} (m : \u2115) {n : \u2115} (h : x ^ n = 1) :\n    x ^ m = x ^ (m % n)", "start": [176, 1], "end": [182, 48], "kind": "commanddeclaration"}, {"full_name": "pow_mul_comm", "code": "@[to_additive]\ntheorem pow_mul_comm (a : M) (m n : \u2115) : a ^ m * a ^ n = a ^ n * a ^ m", "start": [186, 1], "end": [188, 29], "kind": "commanddeclaration"}, {"full_name": "pow_bit0", "code": "@[to_additive bit0_nsmul]\ntheorem pow_bit0 (a : M) (n : \u2115) : a ^ bit0 n = a ^ n * a ^ n", "start": [196, 1], "end": [198, 16], "kind": "commanddeclaration"}, {"full_name": "pow_bit1", "code": "@[to_additive bit1_nsmul]\ntheorem pow_bit1 (a : M) (n : \u2115) : a ^ bit1 n = a ^ n * a ^ n * a", "start": [202, 1], "end": [204, 33], "kind": "commanddeclaration"}, {"full_name": "pow_bit0'", "code": "@[to_additive bit0_nsmul']\ntheorem pow_bit0' (a : M) (n : \u2115) : a ^ bit0 n = (a * a) ^ n", "start": [208, 1], "end": [210, 42], "kind": "commanddeclaration"}, {"full_name": "pow_bit1'", "code": "@[to_additive bit1_nsmul']\ntheorem pow_bit1' (a : M) (n : \u2115) : a ^ bit1 n = (a * a) ^ n * a", "start": [214, 1], "end": [216, 34], "kind": "commanddeclaration"}, {"full_name": "pow_mul_pow_eq_one", "code": "@[to_additive]\ntheorem pow_mul_pow_eq_one {a b : M} (n : \u2115) (h : a * b = 1) : a ^ n * b ^ n = 1", "start": [222, 1], "end": [229, 31], "kind": "commanddeclaration"}, {"full_name": "dvd_pow", "code": "theorem dvd_pow {x y : M} (hxy : x \u2223 y) : \u2200 {n : \u2115} (_ : n \u2260 0), x \u2223 y ^ n", "start": [233, 1], "end": [237, 26], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.pow", "code": "alias Dvd.dvd.pow := dvd_pow", "start": [240, 1], "end": [240, 29], "kind": "stdtacticaliasalias"}, {"full_name": "dvd_pow_self", "code": "theorem dvd_pow_self (a : M) {n : \u2115} (hn : n \u2260 0) : a \u2223 a ^ n", "start": [242, 1], "end": [243, 17], "kind": "commanddeclaration"}, {"full_name": "mul_pow", "code": "@[to_additive nsmul_add]\ntheorem mul_pow (a b : M) (n : \u2115) : (a * b) ^ n = a ^ n * b ^ n", "start": [256, 1], "end": [258, 30], "kind": "commanddeclaration"}, {"full_name": "powMonoidHom", "code": "@[to_additive (attr := simps)\n      \"Multiplication by a natural `n` on a commutative additive\n       monoid, considered as a morphism of additive monoids.\"]\ndef powMonoidHom (n : \u2115) : M \u2192* M where\n  toFun := (\u00b7 ^ n)\n  map_one' := one_pow _\n  map_mul' a b := mul_pow a b n", "start": [262, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "zpow_one", "code": "@[to_additive (attr := simp) one_zsmul]\ntheorem zpow_one (a : G) : a ^ (1 : \u2124) = a", "start": [284, 1], "end": [287, 23], "kind": "commanddeclaration"}, {"full_name": "zpow_two", "code": "@[to_additive two_zsmul]\ntheorem zpow_two (a : G) : a ^ (2 : \u2124) = a * a", "start": [291, 1], "end": [294, 23], "kind": "commanddeclaration"}, {"full_name": "zpow_neg_one", "code": "@[to_additive neg_one_zsmul]\ntheorem zpow_neg_one (x : G) : x ^ (-1 : \u2124) = x\u207b\u00b9", "start": [298, 1], "end": [300, 60], "kind": "commanddeclaration"}, {"full_name": "zpow_neg_coe_of_pos", "code": "@[to_additive]\ntheorem zpow_neg_coe_of_pos (a : G) : \u2200 {n : \u2115}, 0 < n \u2192 a ^ (-(n : \u2124)) = (a ^ n)\u207b\u00b9", "start": [304, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "inv_pow", "code": "@[to_additive (attr := simp)]\ntheorem inv_pow (a : \u03b1) : \u2200 n : \u2115, a\u207b\u00b9 ^ n = (a ^ n)\u207b\u00b9", "start": [316, 1], "end": [319, 67], "kind": "commanddeclaration"}, {"full_name": "one_zpow", "code": "@[to_additive zsmul_zero, simp]\ntheorem one_zpow : \u2200 n : \u2124, (1 : \u03b1) ^ n = 1", "start": [324, 1], "end": [327, 57], "kind": "commanddeclaration"}, {"full_name": "zpow_neg", "code": "@[to_additive (attr := simp) neg_zsmul]\ntheorem zpow_neg (a : \u03b1) : \u2200 n : \u2124, a ^ (-n) = (a ^ n)\u207b\u00b9", "start": [331, 1], "end": [339, 8], "kind": "commanddeclaration"}, {"full_name": "mul_zpow_neg_one", "code": "@[to_additive neg_one_zsmul_add]\ntheorem mul_zpow_neg_one (a b : \u03b1) : (a * b) ^ (-1 : \u2124) = b ^ (-1 : \u2124) * a ^ (-1 : \u2124)", "start": [343, 1], "end": [345, 46], "kind": "commanddeclaration"}, {"full_name": "inv_zpow", "code": "@[to_additive zsmul_neg]\ntheorem inv_zpow (a : \u03b1) : \u2200 n : \u2124, a\u207b\u00b9 ^ n = (a ^ n)\u207b\u00b9", "start": [349, 1], "end": [352, 62], "kind": "commanddeclaration"}, {"full_name": "inv_zpow'", "code": "@[to_additive (attr := simp) zsmul_neg']\ntheorem inv_zpow' (a : \u03b1) (n : \u2124) : a\u207b\u00b9 ^ n = a ^ (-n)", "start": [356, 1], "end": [357, 85], "kind": "commanddeclaration"}, {"full_name": "one_div_pow", "code": "@[to_additive nsmul_zero_sub]\ntheorem one_div_pow (a : \u03b1) (n : \u2115) : (1 / a) ^ n = 1 / a ^ n", "start": [361, 1], "end": [362, 97], "kind": "commanddeclaration"}, {"full_name": "one_div_zpow", "code": "@[to_additive zsmul_zero_sub]\ntheorem one_div_zpow (a : \u03b1) (n : \u2124) : (1 / a) ^ n = 1 / a ^ n", "start": [366, 1], "end": [367, 99], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_zpow", "code": "@[to_additive AddCommute.zsmul_add]\nprotected theorem Commute.mul_zpow (h : Commute a b) : \u2200 i : \u2124, (a * b) ^ i = a ^ i * b ^ i", "start": [371, 1], "end": [374, 71], "kind": "commanddeclaration"}, {"full_name": "mul_zpow", "code": "@[to_additive zsmul_add]\ntheorem mul_zpow (a b : \u03b1) : \u2200 n : \u2124, (a * b) ^ n = a ^ n * b ^ n", "start": [384, 1], "end": [386, 29], "kind": "commanddeclaration"}, {"full_name": "div_pow", "code": "@[to_additive (attr := simp) nsmul_sub]\ntheorem div_pow (a b : \u03b1) (n : \u2115) : (a / b) ^ n = a ^ n / b ^ n", "start": [390, 1], "end": [392, 47], "kind": "commanddeclaration"}, {"full_name": "div_zpow", "code": "@[to_additive (attr := simp) zsmul_sub]\ntheorem div_zpow (a b : \u03b1) (n : \u2124) : (a / b) ^ n = a ^ n / b ^ n", "start": [396, 1], "end": [398, 49], "kind": "commanddeclaration"}, {"full_name": "zpowGroupHom", "code": "@[to_additive (attr := simps)\n      \"Multiplication by an integer `n` on a commutative additive group, considered as an\n       additive group homomorphism.\"]\ndef zpowGroupHom (n : \u2124) : \u03b1 \u2192* \u03b1 where\n  toFun := (\u00b7 ^ n)\n  map_one' := one_zpow n\n  map_mul' a b := mul_zpow a b n", "start": [402, 1], "end": [410, 33], "kind": "commanddeclaration"}, {"full_name": "pow_sub", "code": "@[to_additive sub_nsmul]\ntheorem pow_sub (a : G) {m n : \u2115} (h : n \u2264 m) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9", "start": [422, 1], "end": [424, 66], "kind": "commanddeclaration"}, {"full_name": "pow_inv_comm", "code": "@[to_additive]\ntheorem pow_inv_comm (a : G) (m n : \u2115) : a\u207b\u00b9 ^ m * a ^ n = a ^ n * a\u207b\u00b9 ^ m", "start": [428, 1], "end": [430, 40], "kind": "commanddeclaration"}, {"full_name": "inv_pow_sub", "code": "@[to_additive sub_nsmul_neg]\ntheorem inv_pow_sub (a : G) {m n : \u2115} (h : n \u2264 m) : a\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n", "start": [434, 1], "end": [436, 48], "kind": "commanddeclaration"}, {"full_name": "pow_dvd_pow", "code": "theorem pow_dvd_pow [Monoid R] (a : R) {m n : \u2115} (h : m \u2264 n) : a ^ m \u2223 a ^ n", "start": [442, 1], "end": [443, 71], "kind": "commanddeclaration"}, {"full_name": "ofAdd_nsmul", "code": "theorem ofAdd_nsmul [AddMonoid A] (x : A) (n : \u2115) :\n    Multiplicative.ofAdd (n \u2022 x) = Multiplicative.ofAdd x ^ n", "start": [446, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "ofAdd_zsmul", "code": "theorem ofAdd_zsmul [SubNegMonoid A] (x : A) (n : \u2124) :\n    Multiplicative.ofAdd (n \u2022 x) = Multiplicative.ofAdd x ^ n", "start": [451, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "ofMul_pow", "code": "theorem ofMul_pow [Monoid A] (x : A) (n : \u2115) : Additive.ofMul (x ^ n) = n \u2022 Additive.ofMul x", "start": [456, 1], "end": [457, 6], "kind": "commanddeclaration"}, {"full_name": "ofMul_zpow", "code": "theorem ofMul_zpow [DivInvMonoid G] (x : G) (n : \u2124) :\n    Additive.ofMul (x ^ n) = n \u2022 Additive.ofMul x", "start": [460, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.zpow_right", "code": "@[to_additive (attr := simp)]\ntheorem SemiconjBy.zpow_right [Group G] {a x y : G} (h : SemiconjBy a x y) :\n    \u2200 m : \u2124, SemiconjBy a (x ^ m) (y ^ m)", "start": [465, 1], "end": [471, 22], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_right", "code": "@[to_additive (attr := simp)]\ntheorem zpow_right (h : Commute a b) (m : \u2124) : Commute a (b ^ m)", "start": [479, 1], "end": [481, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_left", "code": "@[to_additive (attr := simp)]\ntheorem zpow_left (h : Commute a b) (m : \u2124) : Commute (a ^ m) b", "start": [485, 1], "end": [487, 29], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_zpow", "code": "@[to_additive]\ntheorem zpow_zpow (h : Commute a b) (m n : \u2124) : Commute (a ^ m) (b ^ n)", "start": [491, 1], "end": [493, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.self_zpow", "code": "@[to_additive]\ntheorem self_zpow : Commute a (a ^ n)", "start": [499, 1], "end": [501, 32], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_self", "code": "@[to_additive]\ntheorem zpow_self : Commute (a ^ n) a", "start": [505, 1], "end": [507, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_zpow_self", "code": "@[to_additive]\ntheorem zpow_zpow_self : Commute (a ^ m) (a ^ n)", "start": [511, 1], "end": [513, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Commute.lean", "imports": ["Mathlib/Algebra/Ring/Units.lean", "Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Ring/Semiconj.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Commute.add_right", "code": "@[simp]\ntheorem add_right [Distrib R] {a b c : R} : Commute a b \u2192 Commute a c \u2192 Commute a (b + c)", "start": [33, 1], "end": [35, 23], "kind": "commanddeclaration"}, {"full_name": "Commute.add_left", "code": "@[simp]\ntheorem add_left [Distrib R] {a b c : R} : Commute a c \u2192 Commute b c \u2192 Commute (a + b) c", "start": [39, 1], "end": [41, 22], "kind": "commanddeclaration"}, {"full_name": "Commute.bit0_right", "code": "@[deprecated]\ntheorem bit0_right [Distrib R] {x y : R} (h : Commute x y) : Commute x (bit0 y)", "start": [48, 1], "end": [50, 16], "kind": "commanddeclaration"}, {"full_name": "Commute.bit0_left", "code": "@[deprecated]\ntheorem bit0_left [Distrib R] {x y : R} (h : Commute x y) : Commute (bit0 x) y", "start": [53, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "Commute.bit1_right", "code": "@[deprecated]\ntheorem bit1_right [NonAssocSemiring R] {x y : R} (h : Commute x y) : Commute x (bit1 y)", "start": [58, 1], "end": [60, 47], "kind": "commanddeclaration"}, {"full_name": "Commute.bit1_left", "code": "@[deprecated]\ntheorem bit1_left [NonAssocSemiring R] {x y : R} (h : Commute x y) : Commute (bit1 x) y", "start": [63, 1], "end": [65, 44], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_self_sub_mul_self_eq", "code": "theorem mul_self_sub_mul_self_eq [NonUnitalNonAssocRing R] {a b : R} (h : Commute a b) :\n    a * a - b * b = (a + b) * (a - b)", "start": [70, 1], "end": [73, 59], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_self_sub_mul_self_eq'", "code": "theorem mul_self_sub_mul_self_eq' [NonUnitalNonAssocRing R] {a b : R} (h : Commute a b) :\n    a * a - b * b = (a - b) * (a + b)", "start": [76, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_self_eq_mul_self_iff", "code": "theorem mul_self_eq_mul_self_iff [NonUnitalNonAssocRing R] [NoZeroDivisors R] {a b : R}\n    (h : Commute a b) : a * a = b * b \u2194 a = b \u2228 a = -b", "start": [81, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_right", "code": "theorem neg_right : Commute a b \u2192 Commute a (-b)", "start": [91, 1], "end": [92, 23], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_right_iff", "code": "@[simp]\ntheorem neg_right_iff : Commute a (-b) \u2194 Commute a b", "start": [95, 1], "end": [97, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_left", "code": "theorem neg_left : Commute a b \u2192 Commute (-a) b", "start": [100, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_left_iff", "code": "@[simp]\ntheorem neg_left_iff : Commute (-a) b \u2194 Commute a b", "start": [104, 1], "end": [106, 26], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_one_right", "code": "theorem neg_one_right (a : R) : Commute a (-1)", "start": [117, 1], "end": [118, 29], "kind": "commanddeclaration"}, {"full_name": "Commute.neg_one_left", "code": "theorem neg_one_left (a : R) : Commute (-1) a", "start": [123, 1], "end": [124, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.sub_right", "code": "@[simp]\ntheorem sub_right : Commute a b \u2192 Commute a c \u2192 Commute a (b - c)", "start": [133, 1], "end": [135, 23], "kind": "commanddeclaration"}, {"full_name": "Commute.sub_left", "code": "@[simp]\ntheorem sub_left : Commute a c \u2192 Commute b c \u2192 Commute (a - b) c", "start": [138, 1], "end": [140, 22], "kind": "commanddeclaration"}, {"full_name": "mul_self_sub_mul_self", "code": "theorem mul_self_sub_mul_self [CommRing R] (a b : R) : a * a - b * b = (a + b) * (a - b)", "start": [147, 1], "end": [149, 45], "kind": "commanddeclaration"}, {"full_name": "mul_self_sub_one", "code": "theorem mul_self_sub_one [NonAssocRing R] (a : R) : a * a - 1 = (a + 1) * (a - 1)", "start": [152, 1], "end": [153, 65], "kind": "commanddeclaration"}, {"full_name": "mul_self_eq_mul_self_iff", "code": "theorem mul_self_eq_mul_self_iff [CommRing R] [NoZeroDivisors R] {a b : R} :\n    a * a = b * b \u2194 a = b \u2228 a = -b", "start": [156, 1], "end": [158, 45], "kind": "commanddeclaration"}, {"full_name": "mul_self_eq_one_iff", "code": "theorem mul_self_eq_one_iff [NonAssocRing R] [NoZeroDivisors R] {a : R} :\n    a * a = 1 \u2194 a = 1 \u2228 a = -1", "start": [161, 1], "end": [163, 65], "kind": "commanddeclaration"}, {"full_name": "Units.inv_eq_self_iff", "code": "theorem inv_eq_self_iff [Ring R] [NoZeroDivisors R] (u : R\u02e3) : u\u207b\u00b9 = u \u2194 u = 1 \u2228 u = -1", "start": [168, 1], "end": [174, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "imports": ["Mathlib/Algebra/Divisibility/Units.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "eq_zero_of_zero_dvd", "code": "theorem eq_zero_of_zero_dvd (h : 0 \u2223 a) : a = 0", "start": [26, 1], "end": [27, 47], "kind": "commanddeclaration"}, {"full_name": "zero_dvd_iff", "code": "@[simp]\ntheorem zero_dvd_iff : 0 \u2223 a \u2194 a = 0", "start": [30, 1], "end": [36, 24], "kind": "commanddeclaration"}, {"full_name": "dvd_zero", "code": "@[simp]\ntheorem dvd_zero (a : \u03b1) : a \u2223 0", "start": [39, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "mul_dvd_mul_iff_left", "code": "theorem mul_dvd_mul_iff_left [CancelMonoidWithZero \u03b1] {a b c : \u03b1} (ha : a \u2260 0) :\n    a * b \u2223 a * c \u2194 b \u2223 c", "start": [46, 1], "end": [50, 61], "kind": "commanddeclaration"}, {"full_name": "mul_dvd_mul_iff_right", "code": "theorem mul_dvd_mul_iff_right [CancelCommMonoidWithZero \u03b1] {a b c : \u03b1} (hc : c \u2260 0) :\n    a * c \u2223 b * c \u2194 a \u2223 b", "start": [53, 1], "end": [57, 65], "kind": "commanddeclaration"}, {"full_name": "DvdNotUnit", "code": "def DvdNotUnit (a b : \u03b1) : Prop :=\n  a \u2260 0 \u2227 \u2203 x, \u00acIsUnit x \u2227 b = a * x", "start": [64, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "dvdNotUnit_of_dvd_of_not_dvd", "code": "theorem dvdNotUnit_of_dvd_of_not_dvd {a b : \u03b1} (hd : a \u2223 b) (hnd : \u00acb \u2223 a) : DvdNotUnit a b", "start": [70, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "dvd_and_not_dvd_iff", "code": "theorem dvd_and_not_dvd_iff [CancelCommMonoidWithZero \u03b1] {x y : \u03b1} :\n    x \u2223 y \u2227 \u00acy \u2223 x \u2194 DvdNotUnit x y", "start": [82, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "ne_zero_of_dvd_ne_zero", "code": "theorem ne_zero_of_dvd_ne_zero {p q : \u03b1} (h\u2081 : q \u2260 0) (h\u2082 : p \u2223 q) : p \u2260 0", "start": [102, 1], "end": [104, 31], "kind": "commanddeclaration"}, {"full_name": "dvd_antisymm", "code": "theorem dvd_antisymm : a \u2223 b \u2192 b \u2223 a \u2192 a = b", "start": [113, 1], "end": [116, 40], "kind": "commanddeclaration"}, {"full_name": "dvd_antisymm'", "code": "theorem dvd_antisymm' : a \u2223 b \u2192 b \u2223 a \u2192 b = a", "start": [122, 1], "end": [123, 20], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.antisymm", "code": "alias Dvd.dvd.antisymm := dvd_antisymm", "start": [126, 1], "end": [126, 39], "kind": "stdtacticaliasalias"}, {"full_name": "Dvd.dvd.antisymm'", "code": "alias Dvd.dvd.antisymm' := dvd_antisymm'", "start": [129, 1], "end": [129, 41], "kind": "stdtacticaliasalias"}, {"full_name": "eq_of_forall_dvd", "code": "theorem eq_of_forall_dvd (h : \u2200 c, a \u2223 c \u2194 b \u2223 c) : a = b", "start": [132, 1], "end": [133, 48], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_dvd'", "code": "theorem eq_of_forall_dvd' (h : \u2200 c, c \u2223 a \u2194 c \u2223 b) : a = b", "start": [136, 1], "end": [137, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Function.lean", "imports": ["Mathlib/Data/Set/Prod.lean", "Mathlib/Logic/Function/Conjugate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.restrict", "code": "def restrict (s : Set \u03b1) (f : \u2200 a : \u03b1, \u03c0 a) : \u2200 a : s, \u03c0 a := fun x => f x", "start": [45, 1], "end": [47, 75], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_eq", "code": "theorem restrict_eq (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : s.restrict f = f \u2218 Subtype.val", "start": [50, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (x : s) : s.restrict f x = f x", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_eq_iff", "code": "theorem restrict_eq_iff {f : \u2200 a, \u03c0 a} {s : Set \u03b1} {g : \u2200 a : s, \u03c0 a} :\n    restrict s f = g \u2194 \u2200 (a) (ha : a \u2208 s), f a = g \u27e8a, ha\u27e9", "start": [59, 1], "end": [61, 34], "kind": "commanddeclaration"}, {"full_name": "Set.eq_restrict_iff", "code": "theorem eq_restrict_iff {s : Set \u03b1} {f : \u2200 a : s, \u03c0 a} {g : \u2200 a, \u03c0 a} :\n    f = restrict s g \u2194 \u2200 (a) (ha : a \u2208 s), f \u27e8a, ha\u27e9 = g a", "start": [64, 1], "end": [66, 34], "kind": "commanddeclaration"}, {"full_name": "Set.range_restrict", "code": "@[simp]\ntheorem range_restrict (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Set.range (s.restrict f) = f '' s", "start": [69, 1], "end": [71, 69], "kind": "commanddeclaration"}, {"full_name": "Set.image_restrict", "code": "theorem image_restrict (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) :\n    s.restrict f '' (Subtype.val \u207b\u00b9' t) = f '' (t \u2229 s)", "start": [74, 1], "end": [76, 81], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_dite", "code": "@[simp]\ntheorem restrict_dite {s : Set \u03b1} [\u2200 x, Decidable (x \u2208 s)] (f : \u2200 a \u2208 s, \u03b2)\n    (g : \u2200 (a) (_ : a \u2209 s), \u03b2) :\n    (s.restrict fun a => if h : a \u2208 s then f a h else g a h) = (fun a : s => f a a.2)", "start": [79, 1], "end": [83, 30], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_dite_compl", "code": "@[simp]\ntheorem restrict_dite_compl {s : Set \u03b1} [\u2200 x, Decidable (x \u2208 s)] (f : \u2200 a \u2208 s, \u03b2)\n    (g : \u2200 (a) (_ : a \u2209 s), \u03b2) :\n    (s\u1d9c.restrict fun a => if h : a \u2208 s then f a h else g a h) = (fun a : (s\u1d9c : Set \u03b1) => g a a.2)", "start": [86, 1], "end": [90, 30], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_ite", "code": "@[simp]\ntheorem restrict_ite (f g : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [\u2200 x, Decidable (x \u2208 s)] :\n    (s.restrict fun a => if a \u2208 s then f a else g a) = s.restrict f", "start": [93, 1], "end": [96, 20], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_ite_compl", "code": "@[simp]\ntheorem restrict_ite_compl (f g : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [\u2200 x, Decidable (x \u2208 s)] :\n    (s\u1d9c.restrict fun a => if a \u2208 s then f a else g a) = s\u1d9c.restrict g", "start": [99, 1], "end": [102, 26], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_piecewise", "code": "@[simp]\ntheorem restrict_piecewise (f g : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [\u2200 x, Decidable (x \u2208 s)] :\n    s.restrict (piecewise s f g) = s.restrict f", "start": [105, 1], "end": [108, 21], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_piecewise_compl", "code": "@[simp]\ntheorem restrict_piecewise_compl (f g : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [\u2200 x, Decidable (x \u2208 s)] :\n    s\u1d9c.restrict (piecewise s f g) = s\u1d9c.restrict g", "start": [111, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_extend_range", "code": "theorem restrict_extend_range (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (g' : \u03b2 \u2192 \u03b3) :\n    (range f).restrict (extend f g g') = fun x => g x.coe_prop.choose", "start": [117, 1], "end": [120, 26], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_extend_compl_range", "code": "@[simp]\ntheorem restrict_extend_compl_range (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (g' : \u03b2 \u2192 \u03b3) :\n    (range f)\u1d9c.restrict (extend f g g') = g' \u2218 Subtype.val", "start": [123, 1], "end": [127, 32], "kind": "commanddeclaration"}, {"full_name": "Set.range_extend_subset", "code": "theorem range_extend_subset (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (g' : \u03b2 \u2192 \u03b3) :\n    range (extend f g g') \u2286 range g \u222a g' '' (range f)\u1d9c", "start": [130, 1], "end": [136, 68], "kind": "commanddeclaration"}, {"full_name": "Set.range_extend", "code": "theorem range_extend {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (g : \u03b1 \u2192 \u03b3) (g' : \u03b2 \u2192 \u03b3) :\n    range (extend f g g') = range g \u222a g' '' (range f)\u1d9c", "start": [139, 1], "end": [143, 69], "kind": "commanddeclaration"}, {"full_name": "Set.codRestrict", "code": "def codRestrict (f : \u03b9 \u2192 \u03b1) (s : Set \u03b1) (h : \u2200 x, f x \u2208 s) : \u03b9 \u2192 s := fun x => \u27e8f x, h x\u27e9", "start": [146, 1], "end": [148, 90], "kind": "commanddeclaration"}, {"full_name": "Set.val_codRestrict_apply", "code": "@[simp]\ntheorem val_codRestrict_apply (f : \u03b9 \u2192 \u03b1) (s : Set \u03b1) (h : \u2200 x, f x \u2208 s) (x : \u03b9) :\n    (codRestrict f s h x : \u03b1) = f x", "start": [151, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_comp_codRestrict", "code": "@[simp]\ntheorem restrict_comp_codRestrict {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b2} {b : Set \u03b1} (h : \u2200 x, f x \u2208 b) :\n    b.restrict g \u2218 b.codRestrict f h = g \u2218 f", "start": [157, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Set.injective_codRestrict", "code": "@[simp]\ntheorem injective_codRestrict {f : \u03b9 \u2192 \u03b1} {s : Set \u03b1} (h : \u2200 x, f x \u2208 s) :\n    Injective (codRestrict f s h) \u2194 Injective f", "start": [163, 1], "end": [166, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.codRestrict", "code": "alias \u27e8_, _root_.Function.Injective.codRestrict\u27e9 := injective_codRestrict", "start": [169, 1], "end": [169, 74], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.EqOn", "code": "def EqOn (f\u2081 f\u2082 : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 s \u2192 f\u2081 x = f\u2082 x", "start": [178, 1], "end": [181, 29], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_empty", "code": "@[simp]\ntheorem eqOn_empty (f\u2081 f\u2082 : \u03b1 \u2192 \u03b2) : EqOn f\u2081 f\u2082 \u2205", "start": [184, 1], "end": [185, 73], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_singleton", "code": "@[simp]\ntheorem eqOn_singleton : Set.EqOn f\u2081 f\u2082 {a} \u2194 f\u2081 a = f\u2082 a", "start": [188, 1], "end": [190, 18], "kind": "commanddeclaration"}, {"full_name": "Set.restrict_eq_restrict_iff", "code": "@[simp]\ntheorem restrict_eq_restrict_iff : restrict s f\u2081 = restrict s f\u2082 \u2194 EqOn f\u2081 f\u2082 s", "start": [193, 1], "end": [195, 18], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.symm", "code": "@[symm]\ntheorem EqOn.symm (h : EqOn f\u2081 f\u2082 s) : EqOn f\u2082 f\u2081 s", "start": [198, 1], "end": [199, 79], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_comm", "code": "theorem eqOn_comm : EqOn f\u2081 f\u2082 s \u2194 EqOn f\u2082 f\u2081 s", "start": [202, 1], "end": [203, 25], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_refl", "code": "theorem eqOn_refl (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : EqOn f f s", "start": [208, 1], "end": [208, 73], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.trans", "code": "theorem EqOn.trans (h\u2081 : EqOn f\u2081 f\u2082 s) (h\u2082 : EqOn f\u2082 f\u2083 s) : EqOn f\u2081 f\u2083 s", "start": [216, 1], "end": [217, 24], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.image_eq", "code": "theorem EqOn.image_eq (heq : EqOn f\u2081 f\u2082 s) : f\u2081 '' s = f\u2082 '' s", "start": [220, 1], "end": [221, 18], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.inter_preimage_eq", "code": "theorem EqOn.inter_preimage_eq (heq : EqOn f\u2081 f\u2082 s) (t : Set \u03b2) : s \u2229 f\u2081 \u207b\u00b9' t = s \u2229 f\u2082 \u207b\u00b9' t", "start": [224, 1], "end": [225, 90], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.mono", "code": "theorem EqOn.mono (hs : s\u2081 \u2286 s\u2082) (hf : EqOn f\u2081 f\u2082 s\u2082) : EqOn f\u2081 f\u2082 s\u2081", "start": [228, 1], "end": [228, 96], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_union", "code": "@[simp]\ntheorem eqOn_union : EqOn f\u2081 f\u2082 (s\u2081 \u222a s\u2082) \u2194 EqOn f\u2081 f\u2082 s\u2081 \u2227 EqOn f\u2081 f\u2082 s\u2082", "start": [231, 1], "end": [233, 15], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.union", "code": "theorem EqOn.union (h\u2081 : EqOn f\u2081 f\u2082 s\u2081) (h\u2082 : EqOn f\u2081 f\u2082 s\u2082) : EqOn f\u2081 f\u2082 (s\u2081 \u222a s\u2082)", "start": [236, 1], "end": [237, 24], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.comp_left", "code": "theorem EqOn.comp_left (h : s.EqOn f\u2081 f\u2082) : s.EqOn (g \u2218 f\u2081) (g \u2218 f\u2082)", "start": [240, 1], "end": [241, 22], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_range", "code": "@[simp]\ntheorem eqOn_range {\u03b9 : Sort*} {f : \u03b9 \u2192 \u03b1} {g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} :\n    EqOn g\u2081 g\u2082 (range f) \u2194 g\u2081 \u2218 f = g\u2082 \u2218 f", "start": [244, 1], "end": [247, 44], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.comp_eq", "code": "alias \u27e8EqOn.comp_eq, _\u27e9 := eqOn_range", "start": [250, 1], "end": [250, 38], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MonotoneOn.congr", "code": "theorem _root_.MonotoneOn.congr (h\u2081 : MonotoneOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) : MonotoneOn f\u2082 s", "start": [260, 1], "end": [263, 21], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.congr", "code": "theorem _root_.AntitoneOn.congr (h\u2081 : AntitoneOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) : AntitoneOn f\u2082 s", "start": [266, 1], "end": [267, 24], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.congr", "code": "theorem _root_.StrictMonoOn.congr (h\u2081 : StrictMonoOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) :\n    StrictMonoOn f\u2082 s", "start": [270, 1], "end": [274, 21], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.congr", "code": "theorem _root_.StrictAntiOn.congr (h\u2081 : StrictAntiOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) : StrictAntiOn f\u2082 s", "start": [277, 1], "end": [278, 24], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.congr_monotoneOn", "code": "theorem EqOn.congr_monotoneOn (h : s.EqOn f\u2081 f\u2082) : MonotoneOn f\u2081 s \u2194 MonotoneOn f\u2082 s", "start": [281, 1], "end": [282, 52], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.congr_antitoneOn", "code": "theorem EqOn.congr_antitoneOn (h : s.EqOn f\u2081 f\u2082) : AntitoneOn f\u2081 s \u2194 AntitoneOn f\u2082 s", "start": [285, 1], "end": [286, 52], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.congr_strictMonoOn", "code": "theorem EqOn.congr_strictMonoOn (h : s.EqOn f\u2081 f\u2082) : StrictMonoOn f\u2081 s \u2194 StrictMonoOn f\u2082 s", "start": [289, 1], "end": [290, 52], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.congr_strictAntiOn", "code": "theorem EqOn.congr_strictAntiOn (h : s.EqOn f\u2081 f\u2082) : StrictAntiOn f\u2081 s \u2194 StrictAntiOn f\u2082 s", "start": [293, 1], "end": [294, 52], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mono", "code": "theorem _root_.MonotoneOn.mono (h : MonotoneOn f s) (h' : s\u2082 \u2286 s) : MonotoneOn f s\u2082", "start": [306, 1], "end": [307, 37], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mono", "code": "theorem _root_.AntitoneOn.mono (h : AntitoneOn f s) (h' : s\u2082 \u2286 s) : AntitoneOn f s\u2082", "start": [310, 1], "end": [311, 37], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.mono", "code": "theorem _root_.StrictMonoOn.mono (h : StrictMonoOn f s) (h' : s\u2082 \u2286 s) : StrictMonoOn f s\u2082", "start": [314, 1], "end": [315, 37], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.mono", "code": "theorem _root_.StrictAntiOn.mono (h : StrictAntiOn f s) (h' : s\u2082 \u2286 s) : StrictAntiOn f s\u2082", "start": [318, 1], "end": [319, 37], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.monotone", "code": "protected theorem _root_.MonotoneOn.monotone (h : MonotoneOn f s) :\n    Monotone (f \u2218 Subtype.val : s \u2192 \u03b2)", "start": [322, 1], "end": [324, 45], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.monotone", "code": "protected theorem _root_.AntitoneOn.monotone (h : AntitoneOn f s) :\n    Antitone (f \u2218 Subtype.val : s \u2192 \u03b2)", "start": [327, 1], "end": [329, 45], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.strictMono", "code": "protected theorem _root_.StrictMonoOn.strictMono (h : StrictMonoOn f s) :\n    StrictMono (f \u2218 Subtype.val : s \u2192 \u03b2)", "start": [332, 1], "end": [334, 45], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.strictAnti", "code": "protected theorem _root_.StrictAntiOn.strictAnti (h : StrictAntiOn f s) :\n    StrictAnti (f \u2218 Subtype.val : s \u2192 \u03b2)", "start": [337, 1], "end": [339, 45], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo", "code": "def MapsTo (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 s \u2192 f x \u2208 t", "start": [347, 1], "end": [349, 25], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.restrict", "code": "def MapsTo.restrict (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) (h : MapsTo f s t) : s \u2192 t :=\n  Subtype.map f h", "start": [352, 1], "end": [355, 18], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.restrict_commutes", "code": "theorem MapsTo.restrict_commutes (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) (h : MapsTo f s t) :\n    Subtype.val \u2218 h.restrict f s t = f \u2218 Subtype.val", "start": [358, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.val_restrict_apply", "code": "@[simp]\ntheorem MapsTo.val_restrict_apply (h : MapsTo f s t) (x : s) : (h.restrict f s t x : \u03b2) = f x", "start": [362, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "Set.codRestrict_restrict", "code": "@[simp]\ntheorem codRestrict_restrict (h : \u2200 x : s, f x \u2208 t) :\n    codRestrict (s.restrict f) t h = MapsTo.restrict f s t fun x hx => h \u27e8x, hx\u27e9", "start": [367, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.restrict_eq_codRestrict", "code": "theorem MapsTo.restrict_eq_codRestrict (h : MapsTo f s t) :\n    h.restrict f s t = codRestrict (s.restrict f) t fun x => h x.2", "start": [374, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.coe_restrict", "code": "theorem MapsTo.coe_restrict (h : Set.MapsTo f s t) :\n    Subtype.val \u2218 h.restrict f s t = s.restrict f", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.range_restrict", "code": "theorem MapsTo.range_restrict (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) (h : MapsTo f s t) :\n    range (h.restrict f s t) = Subtype.val \u207b\u00b9' (f '' s)", "start": [385, 1], "end": [387, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iff_exists_map_subtype", "code": "theorem mapsTo_iff_exists_map_subtype : MapsTo f s t \u2194 \u2203 g : s \u2192 t, \u2200 x : s, f x = g x", "start": [390, 1], "end": [393, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo'", "code": "theorem mapsTo' : MapsTo f s t \u2194 f '' s \u2286 t", "start": [396, 1], "end": [397, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_prod_map_diagonal", "code": "theorem mapsTo_prod_map_diagonal : MapsTo (Prod.map f f) (diagonal \u03b1) (diagonal \u03b2)", "start": [400, 1], "end": [401, 40], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.subset_preimage", "code": "theorem MapsTo.subset_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hf : MapsTo f s t) :\n    s \u2286 f \u207b\u00b9' t", "start": [404, 1], "end": [406, 5], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_singleton", "code": "@[simp]\ntheorem mapsTo_singleton {x : \u03b1} : MapsTo f {x} t \u2194 f x \u2208 t", "start": [409, 1], "end": [411, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_empty", "code": "theorem mapsTo_empty (f : \u03b1 \u2192 \u03b2) (t : Set \u03b2) : MapsTo f \u2205 t", "start": [414, 1], "end": [415, 17], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.image_subset", "code": "theorem MapsTo.image_subset (h : MapsTo f s t) : f '' s \u2286 t", "start": [418, 1], "end": [419, 14], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.congr", "code": "theorem MapsTo.congr (h\u2081 : MapsTo f\u2081 s t) (h : EqOn f\u2081 f\u2082 s) : MapsTo f\u2082 s t", "start": [422, 1], "end": [423, 15], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.comp_right", "code": "theorem EqOn.comp_right (hg : t.EqOn g\u2081 g\u2082) (hf : s.MapsTo f t) : s.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f)", "start": [426, 1], "end": [427, 26], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.mapsTo_iff", "code": "theorem EqOn.mapsTo_iff (H : EqOn f\u2081 f\u2082 s) : MapsTo f\u2081 s t \u2194 MapsTo f\u2082 s t", "start": [430, 1], "end": [431, 48], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.comp", "code": "theorem MapsTo.comp (h\u2081 : MapsTo g t p) (h\u2082 : MapsTo f s t) : MapsTo (g \u2218 f) s p", "start": [434, 1], "end": [435, 12], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_id", "code": "theorem mapsTo_id (s : Set \u03b1) : MapsTo id s s", "start": [438, 1], "end": [438, 61], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.iterate", "code": "theorem MapsTo.iterate {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} (h : MapsTo f s s) : \u2200 n, MapsTo f^[n] s s", "start": [441, 1], "end": [443, 41], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.iterate_restrict", "code": "theorem MapsTo.iterate_restrict {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} (h : MapsTo f s s) (n : \u2115) :\n    (h.restrict f s s)^[n] = (h.iterate n).restrict _ _ _", "start": [446, 1], "end": [452, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_of_subsingleton'", "code": "lemma mapsTo_of_subsingleton' [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) (h : s.Nonempty \u2192 t.Nonempty) :\n    MapsTo f s t :=\n  fun a ha \u21a6 Subsingleton.mem_iff_nonempty.2 $ h \u27e8a, ha\u27e9", "start": [455, 1], "end": [457, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mapsTo_of_subsingleton", "code": "lemma mapsTo_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) : MapsTo f s s :=\n  mapsTo_of_subsingleton' _ id", "start": [460, 1], "end": [461, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Set.MapsTo.mono", "code": "theorem MapsTo.mono (hf : MapsTo f s\u2081 t\u2081) (hs : s\u2082 \u2286 s\u2081) (ht : t\u2081 \u2286 t\u2082) : MapsTo f s\u2082 t\u2082", "start": [464, 1], "end": [465, 31], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.mono_left", "code": "theorem MapsTo.mono_left (hf : MapsTo f s\u2081 t) (hs : s\u2082 \u2286 s\u2081) : MapsTo f s\u2082 t", "start": [468, 1], "end": [469, 13], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.mono_right", "code": "theorem MapsTo.mono_right (hf : MapsTo f s t\u2081) (ht : t\u2081 \u2286 t\u2082) : MapsTo f s t\u2082", "start": [472, 1], "end": [473, 13], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.union_union", "code": "theorem MapsTo.union_union (h\u2081 : MapsTo f s\u2081 t\u2081) (h\u2082 : MapsTo f s\u2082 t\u2082) :\n    MapsTo f (s\u2081 \u222a s\u2082) (t\u2081 \u222a t\u2082)", "start": [476, 1], "end": [478, 64], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.union", "code": "theorem MapsTo.union (h\u2081 : MapsTo f s\u2081 t) (h\u2082 : MapsTo f s\u2082 t) : MapsTo f (s\u2081 \u222a s\u2082) t", "start": [481, 1], "end": [482, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_union", "code": "@[simp]\ntheorem mapsTo_union : MapsTo f (s\u2081 \u222a s\u2082) t \u2194 MapsTo f s\u2081 t \u2227 MapsTo f s\u2082 t", "start": [485, 1], "end": [490, 28], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.inter", "code": "theorem MapsTo.inter (h\u2081 : MapsTo f s t\u2081) (h\u2082 : MapsTo f s t\u2082) : MapsTo f s (t\u2081 \u2229 t\u2082)", "start": [493, 1], "end": [494, 17], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.inter_inter", "code": "theorem MapsTo.inter_inter (h\u2081 : MapsTo f s\u2081 t\u2081) (h\u2082 : MapsTo f s\u2082 t\u2082) :\n    MapsTo f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "start": [497, 1], "end": [498, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_inter", "code": "@[simp]\ntheorem mapsTo_inter : MapsTo f s (t\u2081 \u2229 t\u2082) \u2194 MapsTo f s t\u2081 \u2227 MapsTo f s t\u2082", "start": [501, 1], "end": [506, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_univ", "code": "theorem mapsTo_univ (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : MapsTo f s univ", "start": [509, 1], "end": [509, 84], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_image", "code": "theorem mapsTo_image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : MapsTo f s (f '' s)", "start": [512, 1], "end": [512, 86], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_preimage", "code": "theorem mapsTo_preimage (f : \u03b1 \u2192 \u03b2) (t : Set \u03b2) : MapsTo f (f \u207b\u00b9' t) t", "start": [515, 1], "end": [516, 16], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_range", "code": "theorem mapsTo_range (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : MapsTo f s (range f)", "start": [519, 1], "end": [520, 67], "kind": "commanddeclaration"}, {"full_name": "Set.maps_image_to", "code": "@[simp]\ntheorem maps_image_to (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b1) (s : Set \u03b3) (t : Set \u03b2) :\n    MapsTo f (g '' s) t \u2194 MapsTo (f \u2218 g) s t", "start": [523, 1], "end": [526, 67], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.comp_left", "code": "lemma MapsTo.comp_left (g : \u03b2 \u2192 \u03b3) (hf : MapsTo f s t) : MapsTo (g \u2218 f) s (g '' t) :=\n  fun x hx \u21a6 \u27e8f x, hf hx, rfl\u27e9", "start": [529, 1], "end": [530, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Set.MapsTo.comp_right", "code": "lemma MapsTo.comp_right {s : Set \u03b2} {t : Set \u03b3} (hg : MapsTo g s t) (f : \u03b1 \u2192 \u03b2) :\n    MapsTo (g \u2218 f) (f \u207b\u00b9' s) t := fun _ hx \u21a6 hg hx", "start": [533, 1], "end": [534, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Set.maps_univ_to", "code": "@[simp]\ntheorem maps_univ_to (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : MapsTo f univ s \u2194 \u2200 a, f a \u2208 s", "start": [537, 1], "end": [539, 48], "kind": "commanddeclaration"}, {"full_name": "Set.maps_range_to", "code": "@[simp]\ntheorem maps_range_to (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b1) (s : Set \u03b2) :\n    MapsTo f (range g) s \u2194 MapsTo (f \u2218 g) univ s", "start": [542, 1], "end": [544, 88], "kind": "commanddeclaration"}, {"full_name": "Set.surjective_mapsTo_image_restrict", "code": "theorem surjective_mapsTo_image_restrict (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    Surjective ((mapsTo_image f s).restrict f s (f '' s))", "start": [547, 1], "end": [549, 29], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.mem_iff", "code": "theorem MapsTo.mem_iff (h : MapsTo f s t) (hc : MapsTo f s\u1d9c t\u1d9c) {x} : f x \u2208 t \u2194 x \u2208 s", "start": [552, 1], "end": [553, 59], "kind": "commanddeclaration"}, {"full_name": "Set.restrictPreimage", "code": "@[simps!]\ndef restrictPreimage : f \u207b\u00b9' t \u2192 t :=\n  (Set.mapsTo_preimage f t).restrict _ _ _", "start": [563, 1], "end": [566, 43], "kind": "commanddeclaration"}, {"full_name": "Set.range_restrictPreimage", "code": "theorem range_restrictPreimage : range (t.restrictPreimage f) = Subtype.val \u207b\u00b9' range f", "start": [570, 1], "end": [573, 47], "kind": "commanddeclaration"}, {"full_name": "Set.restrictPreimage_injective", "code": "lemma restrictPreimage_injective (hf : Injective f) : Injective (t.restrictPreimage f) :=\n  fun _ _ e => Subtype.coe_injective <| hf <| Subtype.mk.inj e", "start": [578, 1], "end": [579, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Set.restrictPreimage_surjective", "code": "lemma restrictPreimage_surjective (hf : Surjective f) : Surjective (t.restrictPreimage f) :=\n  fun x => \u27e8\u27e8_, ((hf x).choose_spec.symm \u25b8 x.2 : _ \u2208 t)\u27e9, Subtype.ext (hf x).choose_spec\u27e9", "start": [582, 1], "end": [583, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Set.restrictPreimage_bijective", "code": "lemma restrictPreimage_bijective (hf : Bijective f) : Bijective (t.restrictPreimage f) :=\n  \u27e8t.restrictPreimage_injective hf.1, t.restrictPreimage_surjective hf.2\u27e9", "start": [586, 1], "end": [587, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.restrictPreimage", "code": "alias _root_.Function.Injective.restrictPreimage := Set.restrictPreimage_injective", "start": [590, 1], "end": [590, 83], "kind": "stdtacticaliasalias"}, {"full_name": "Function.Surjective.restrictPreimage", "code": "alias _root_.Function.Surjective.restrictPreimage := Set.restrictPreimage_surjective", "start": [591, 1], "end": [591, 85], "kind": "stdtacticaliasalias"}, {"full_name": "Function.Bijective.restrictPreimage", "code": "alias _root_.Function.Bijective.restrictPreimage := Set.restrictPreimage_bijective", "start": [592, 1], "end": [592, 83], "kind": "stdtacticaliasalias"}, {"full_name": "Set.InjOn", "code": "def InjOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983x\u2081 : \u03b1\u2984, x\u2081 \u2208 s \u2192 \u2200 \u2983x\u2082 : \u03b1\u2984, x\u2082 \u2208 s \u2192 f x\u2081 = f x\u2082 \u2192 x\u2081 = x\u2082", "start": [602, 1], "end": [604, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.injOn", "code": "theorem Subsingleton.injOn (hs : s.Subsingleton) (f : \u03b1 \u2192 \u03b2) : InjOn f s", "start": [607, 1], "end": [608, 11], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_empty", "code": "@[simp]\ntheorem injOn_empty (f : \u03b1 \u2192 \u03b2) : InjOn f \u2205", "start": [611, 1], "end": [613, 29], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_singleton", "code": "@[simp]\ntheorem injOn_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : InjOn f {a}", "start": [615, 1], "end": [617, 33], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.eq_iff", "code": "theorem InjOn.eq_iff {x y} (h : InjOn f s) (hx : x \u2208 s) (hy : y \u2208 s) : f x = f y \u2194 x = y", "start": [620, 1], "end": [621, 30], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.ne_iff", "code": "theorem InjOn.ne_iff {x y} (h : InjOn f s) (hx : x \u2208 s) (hy : y \u2208 s) : f x \u2260 f y \u2194 x \u2260 y", "start": [624, 1], "end": [625, 23], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.ne", "code": "alias \u27e8_, InjOn.ne\u27e9 := InjOn.ne_iff", "start": [628, 1], "end": [628, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.InjOn.congr", "code": "theorem InjOn.congr (h\u2081 : InjOn f\u2081 s) (h : EqOn f\u2081 f\u2082 s) : InjOn f\u2082 s", "start": [631, 1], "end": [632, 25], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.injOn_iff", "code": "theorem EqOn.injOn_iff (H : EqOn f\u2081 f\u2082 s) : InjOn f\u2081 s \u2194 InjOn f\u2082 s", "start": [635, 1], "end": [636, 48], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.mono", "code": "theorem InjOn.mono (h : s\u2081 \u2286 s\u2082) (ht : InjOn f s\u2082) : InjOn f s\u2081", "start": [639, 1], "end": [640, 21], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_union", "code": "theorem injOn_union (h : Disjoint s\u2081 s\u2082) :\n    InjOn f (s\u2081 \u222a s\u2082) \u2194 InjOn f s\u2081 \u2227 InjOn f s\u2082 \u2227 \u2200 x \u2208 s\u2081, \u2200 y \u2208 s\u2082, f x \u2260 f y", "start": [643, 1], "end": [651, 97], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_insert", "code": "theorem injOn_insert {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (has : a \u2209 s) :\n    Set.InjOn f (insert a s) \u2194 Set.InjOn f s \u2227 f a \u2209 f '' s", "start": [654, 1], "end": [658, 7], "kind": "commanddeclaration"}, {"full_name": "Set.injective_iff_injOn_univ", "code": "theorem injective_iff_injOn_univ : Injective f \u2194 InjOn f univ", "start": [661, 1], "end": [662, 71], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_of_injective", "code": "theorem injOn_of_injective (h : Injective f) (s : Set \u03b1) : InjOn f s", "start": [665, 1], "end": [665, 97], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.injOn", "code": "alias _root_.Function.Injective.injOn := injOn_of_injective", "start": [668, 1], "end": [668, 60], "kind": "stdtacticaliasalias"}, {"full_name": "Set.injOn_subtype_val", "code": "theorem injOn_subtype_val {s : Set { x // p x }} : Set.InjOn Subtype.val s", "start": [672, 1], "end": [673, 32], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_id", "code": "lemma injOn_id (s : Set \u03b1) : InjOn id s := injective_id.injOn _", "start": [675, 1], "end": [675, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Set.InjOn.comp", "code": "theorem InjOn.comp (hg : InjOn g t) (hf : InjOn f s) (h : MapsTo f s t) : InjOn (g \u2218 f) s", "start": [678, 1], "end": [679, 56], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.iterate", "code": "lemma InjOn.iterate {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} (h : InjOn f s) (hf : MapsTo f s s) :\n    \u2200 n, InjOn f^[n] s\n  | 0 => injOn_id _\n  | (n + 1) => (h.iterate hf n).comp h hf", "start": [682, 1], "end": [685, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Set.injOn_of_subsingleton", "code": "lemma injOn_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : InjOn f s :=\n  (injective_of_subsingleton _).injOn _", "start": [688, 1], "end": [689, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.injOn_range", "code": "theorem _root_.Function.Injective.injOn_range (h : Injective (g \u2218 f)) : InjOn g (range f)", "start": [692, 1], "end": [694, 26], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_iff_injective", "code": "theorem injOn_iff_injective : InjOn f s \u2194 Injective (s.restrict f)", "start": [697, 1], "end": [699, 51], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.injective", "code": "alias \u27e8InjOn.injective, _\u27e9 := Set.injOn_iff_injective", "start": [702, 1], "end": [702, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.MapsTo.restrict_inj", "code": "theorem MapsTo.restrict_inj (h : MapsTo f s t) : Injective (h.restrict f s t) \u2194 InjOn f s", "start": [705, 1], "end": [706, 77], "kind": "commanddeclaration"}, {"full_name": "Set.exists_injOn_iff_injective", "code": "theorem exists_injOn_iff_injective [Nonempty \u03b2] :\n    (\u2203 f : \u03b1 \u2192 \u03b2, InjOn f s) \u2194 \u2203 f : s \u2192 \u03b2, Injective f", "start": [709, 1], "end": [714, 41], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_preimage", "code": "theorem injOn_preimage {B : Set (Set \u03b2)} (hB : B \u2286 \ud835\udcab range f) : InjOn (preimage f) B", "start": [717, 1], "end": [718, 75], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.mem_of_mem_image", "code": "theorem InjOn.mem_of_mem_image {x} (hf : InjOn f s) (hs : s\u2081 \u2286 s) (h : x \u2208 s) (h\u2081 : f x \u2208 f '' s\u2081) :\n    x \u2208 s\u2081", "start": [722, 1], "end": [725, 23], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.mem_image_iff", "code": "theorem InjOn.mem_image_iff {x} (hf : InjOn f s) (hs : s\u2081 \u2286 s) (hx : x \u2208 s) :\n    f x \u2208 f '' s\u2081 \u2194 x \u2208 s\u2081", "start": [728, 1], "end": [730, 50], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.preimage_image_inter", "code": "theorem InjOn.preimage_image_inter (hf : InjOn f s) (hs : s\u2081 \u2286 s) : f \u207b\u00b9' (f '' s\u2081) \u2229 s = s\u2081", "start": [733, 1], "end": [734, 101], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.cancel_left", "code": "theorem EqOn.cancel_left (h : s.EqOn (g \u2218 f\u2081) (g \u2218 f\u2082)) (hg : t.InjOn g) (hf\u2081 : s.MapsTo f\u2081 t)\n    (hf\u2082 : s.MapsTo f\u2082 t) : s.EqOn f\u2081 f\u2082", "start": [737, 1], "end": [738, 84], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.cancel_left", "code": "theorem InjOn.cancel_left (hg : t.InjOn g) (hf\u2081 : s.MapsTo f\u2081 t) (hf\u2082 : s.MapsTo f\u2082 t) :\n    s.EqOn (g \u2218 f\u2081) (g \u2218 f\u2082) \u2194 s.EqOn f\u2081 f\u2082", "start": [741, 1], "end": [743, 54], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.image_inter", "code": "lemma InjOn.image_inter {s t u : Set \u03b1} (hf : u.InjOn f) (hs : s \u2286 u) (ht : t \u2286 u) :\n    f '' (s \u2229 t) = f '' s \u2229 f '' t := by\n  apply Subset.antisymm (image_inter_subset _ _ _)\n  intro x \u27e8\u27e8y, ys, hy\u27e9, \u27e8z, zt, hz\u27e9\u27e9\n  have : y = z := by\n    apply hf (hs ys) (ht zt)\n    rwa [\u2190 hz] at hy\n  rw [\u2190 this] at zt\n  exact \u27e8y, \u27e8ys, zt\u27e9, hy\u27e9", "start": [746, 1], "end": [754, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Disjoint.image", "code": "theorem _root_.Disjoint.image {s t u : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (h : Disjoint s t) (hf : u.InjOn f)\n    (hs : s \u2286 u) (ht : t \u2286 u) : Disjoint (f '' s) (f '' t)", "start": [757, 1], "end": [760, 46], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn", "code": "def SurjOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  t \u2286 f '' s", "start": [766, 1], "end": [768, 13], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.subset_range", "code": "theorem SurjOn.subset_range (h : SurjOn f s t) : t \u2286 range f", "start": [771, 1], "end": [772, 43], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iff_exists_map_subtype", "code": "theorem surjOn_iff_exists_map_subtype :\n    SurjOn f s t \u2194 \u2203 (t' : Set \u03b2) (g : s \u2192 t'), t \u2286 t' \u2227 Surjective g \u2227 \u2200 x : s, f x = g x", "start": [775, 1], "end": [781, 47], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_empty", "code": "theorem surjOn_empty (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : SurjOn f s \u2205", "start": [784, 1], "end": [785, 17], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_singleton", "code": "@[simp] lemma surjOn_singleton : SurjOn f s {b} \u2194 b \u2208 f '' s := singleton_subset_iff", "start": [788, 1], "end": [788, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Set.surjOn_image", "code": "theorem surjOn_image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : SurjOn f s (f '' s)", "start": [791, 1], "end": [792, 13], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.comap_nonempty", "code": "theorem SurjOn.comap_nonempty (h : SurjOn f s t) (ht : t.Nonempty) : s.Nonempty", "start": [795, 1], "end": [796, 23], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.congr", "code": "theorem SurjOn.congr (h : SurjOn f\u2081 s t) (H : EqOn f\u2081 f\u2082 s) : SurjOn f\u2082 s t", "start": [799, 1], "end": [800, 29], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.surjOn_iff", "code": "theorem EqOn.surjOn_iff (h : EqOn f\u2081 f\u2082 s) : SurjOn f\u2081 s t \u2194 SurjOn f\u2082 s t", "start": [803, 1], "end": [804, 48], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.mono", "code": "theorem SurjOn.mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) (hf : SurjOn f s\u2081 t\u2082) : SurjOn f s\u2082 t\u2081", "start": [807, 1], "end": [808, 58], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.union", "code": "theorem SurjOn.union (h\u2081 : SurjOn f s t\u2081) (h\u2082 : SurjOn f s t\u2082) : SurjOn f s (t\u2081 \u222a t\u2082)", "start": [811, 1], "end": [812, 44], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.union_union", "code": "theorem SurjOn.union_union (h\u2081 : SurjOn f s\u2081 t\u2081) (h\u2082 : SurjOn f s\u2082 t\u2082) :\n    SurjOn f (s\u2081 \u222a s\u2082) (t\u2081 \u222a t\u2082)", "start": [815, 1], "end": [818, 55], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.inter_inter", "code": "theorem SurjOn.inter_inter (h\u2081 : SurjOn f s\u2081 t\u2081) (h\u2082 : SurjOn f s\u2082 t\u2082) (h : InjOn f (s\u2081 \u222a s\u2082)) :\n    SurjOn f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "start": [821, 1], "end": [827, 38], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.inter", "code": "theorem SurjOn.inter (h\u2081 : SurjOn f s\u2081 t) (h\u2082 : SurjOn f s\u2082 t) (h : InjOn f (s\u2081 \u222a s\u2082)) :\n    SurjOn f (s\u2081 \u2229 s\u2082) t", "start": [830, 1], "end": [832, 37], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_id", "code": "lemma surjOn_id (s : Set \u03b1) : SurjOn id s s := by simp [SurjOn, subset_rfl]", "start": [836, 1], "end": [836, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Set.SurjOn.comp", "code": "theorem SurjOn.comp (hg : SurjOn g t p) (hf : SurjOn f s t) : SurjOn (g \u2218 f) s p", "start": [839, 1], "end": [840, 90], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.iterate", "code": "lemma SurjOn.iterate {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} (h : SurjOn f s s) : \u2200 n, SurjOn f^[n] s s\n  | 0 => surjOn_id _\n  | (n + 1) => (h.iterate n).comp h", "start": [843, 1], "end": [845, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Set.SurjOn.comp_left", "code": "lemma SurjOn.comp_left (hf : SurjOn f s t) (g : \u03b2 \u2192 \u03b3) : SurjOn (g \u2218 f) s (g '' t) := by\n  rw [SurjOn, image_comp g f]; exact image_subset _ hf", "start": [848, 1], "end": [849, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Set.SurjOn.comp_right", "code": "lemma SurjOn.comp_right {s : Set \u03b2} {t : Set \u03b3} (hf : Surjective f) (hg : SurjOn g s t) :\n    SurjOn (g \u2218 f) (f \u207b\u00b9' s) t := by\n  rwa [SurjOn, image_comp g f, image_preimage_eq _ hf]", "start": [852, 1], "end": [854, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Set.surjOn_of_subsingleton'", "code": "lemma surjOn_of_subsingleton' [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) (h : t.Nonempty \u2192 s.Nonempty) :\n    SurjOn f s t :=\n  fun _ ha \u21a6 Subsingleton.mem_iff_nonempty.2 $ (h \u27e8_, ha\u27e9).image _", "start": [857, 1], "end": [859, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Set.surjOn_of_subsingleton", "code": "lemma surjOn_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) : SurjOn f s s :=\n  surjOn_of_subsingleton' _ id", "start": [862, 1], "end": [863, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Set.surjective_iff_surjOn_univ", "code": "theorem surjective_iff_surjOn_univ : Surjective f \u2194 SurjOn f univ univ", "start": [866, 1], "end": [867, 40], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iff_surjective", "code": "theorem surjOn_iff_surjective : SurjOn f s univ \u2194 Surjective (s.restrict f)", "start": [870, 1], "end": [876, 16], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.image_eq_of_mapsTo", "code": "theorem SurjOn.image_eq_of_mapsTo (h\u2081 : SurjOn f s t) (h\u2082 : MapsTo f s t) : f '' s = t", "start": [879, 1], "end": [880, 44], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_iff_surjOn_mapsTo", "code": "theorem image_eq_iff_surjOn_mapsTo : f '' s = t \u2194 s.SurjOn f t \u2227 s.MapsTo f t", "start": [883, 1], "end": [886, 45], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.mapsTo_compl", "code": "theorem SurjOn.mapsTo_compl (h : SurjOn f s t) (h' : Injective f) : MapsTo f s\u1d9c t\u1d9c", "start": [889, 1], "end": [892, 21], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.surjOn_compl", "code": "theorem MapsTo.surjOn_compl (h : MapsTo f s t) (h' : Surjective f) : SurjOn f s\u1d9c t\u1d9c", "start": [895, 1], "end": [896, 67], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.cancel_right", "code": "theorem EqOn.cancel_right (hf : s.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f)) (hf' : s.SurjOn f t) : t.EqOn g\u2081 g\u2082", "start": [899, 1], "end": [902, 14], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.cancel_right", "code": "theorem SurjOn.cancel_right (hf : s.SurjOn f t) (hf' : s.MapsTo f t) :\n    s.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) \u2194 t.EqOn g\u2081 g\u2082", "start": [905, 1], "end": [907, 58], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_comp_right_iff", "code": "theorem eqOn_comp_right_iff : s.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) \u2194 (f '' s).EqOn g\u2081 g\u2082", "start": [910, 1], "end": [911, 54], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn", "code": "def BijOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  MapsTo f s t \u2227 InjOn f s \u2227 SurjOn f s t", "start": [917, 1], "end": [919, 42], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.mapsTo", "code": "theorem BijOn.mapsTo (h : BijOn f s t) : MapsTo f s t", "start": [922, 1], "end": [923, 9], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.injOn", "code": "theorem BijOn.injOn (h : BijOn f s t) : InjOn f s", "start": [926, 1], "end": [927, 15], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.surjOn", "code": "theorem BijOn.surjOn (h : BijOn f s t) : SurjOn f s t", "start": [930, 1], "end": [931, 16], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.mk", "code": "theorem BijOn.mk (h\u2081 : MapsTo f s t) (h\u2082 : InjOn f s) (h\u2083 : SurjOn f s t) : BijOn f s t", "start": [934, 1], "end": [935, 15], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_empty", "code": "theorem bijOn_empty (f : \u03b1 \u2192 \u03b2) : BijOn f \u2205 \u2205", "start": [938, 1], "end": [939, 54], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_singleton", "code": "@[simp] lemma bijOn_singleton : BijOn f {a} {b} \u2194 f a = b := by simp [BijOn, eq_comm]", "start": [942, 1], "end": [942, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.inter_mapsTo", "code": "theorem BijOn.inter_mapsTo (h\u2081 : BijOn f s\u2081 t\u2081) (h\u2082 : MapsTo f s\u2082 t\u2082) (h\u2083 : s\u2081 \u2229 f \u207b\u00b9' t\u2082 \u2286 s\u2082) :\n    BijOn f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "start": [945, 1], "end": [949, 50], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.inter_bijOn", "code": "theorem MapsTo.inter_bijOn (h\u2081 : MapsTo f s\u2081 t\u2081) (h\u2082 : BijOn f s\u2082 t\u2082) (h\u2083 : s\u2082 \u2229 f \u207b\u00b9' t\u2081 \u2286 s\u2081) :\n    BijOn f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "start": [952, 1], "end": [954, 62], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.inter", "code": "theorem BijOn.inter (h\u2081 : BijOn f s\u2081 t\u2081) (h\u2082 : BijOn f s\u2082 t\u2082) (h : InjOn f (s\u2081 \u222a s\u2082)) :\n    BijOn f (s\u2081 \u2229 s\u2082) (t\u2081 \u2229 t\u2082)", "start": [957, 1], "end": [960, 39], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.union", "code": "theorem BijOn.union (h\u2081 : BijOn f s\u2081 t\u2081) (h\u2082 : BijOn f s\u2082 t\u2082) (h : InjOn f (s\u2081 \u222a s\u2082)) :\n    BijOn f (s\u2081 \u222a s\u2082) (t\u2081 \u222a t\u2082)", "start": [963, 1], "end": [965, 72], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.subset_range", "code": "theorem BijOn.subset_range (h : BijOn f s t) : t \u2286 range f", "start": [968, 1], "end": [969, 24], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.bijOn_image", "code": "theorem InjOn.bijOn_image (h : InjOn f s) : BijOn f s (f '' s)", "start": [972, 1], "end": [973, 48], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.congr", "code": "theorem BijOn.congr (h\u2081 : BijOn f\u2081 s t) (h : EqOn f\u2081 f\u2082 s) : BijOn f\u2082 s t", "start": [976, 1], "end": [977, 70], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.bijOn_iff", "code": "theorem EqOn.bijOn_iff (H : EqOn f\u2081 f\u2082 s) : BijOn f\u2081 s t \u2194 BijOn f\u2082 s t", "start": [980, 1], "end": [981, 48], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.image_eq", "code": "theorem BijOn.image_eq (h : BijOn f s t) : f '' s = t", "start": [984, 1], "end": [985, 39], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_id", "code": "lemma bijOn_id (s : Set \u03b1) : BijOn id s s := \u27e8s.mapsTo_id, s.injOn_id, s.surjOn_id\u27e9", "start": [988, 1], "end": [988, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.comp", "code": "theorem BijOn.comp (hg : BijOn g t p) (hf : BijOn f s t) : BijOn (g \u2218 f) s p", "start": [991, 1], "end": [992, 100], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.iterate", "code": "lemma BijOn.iterate {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} (h : BijOn f s s) : \u2200 n, BijOn f^[n] s s\n  | 0 => s.bijOn_id\n  | (n + 1) => (h.iterate n).comp h", "start": [995, 1], "end": [997, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Set.bijOn_of_subsingleton'", "code": "lemma bijOn_of_subsingleton' [Subsingleton \u03b1] [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : s.Nonempty \u2194 t.Nonempty) : BijOn f s t :=\n  \u27e8mapsTo_of_subsingleton' _ h.1, injOn_of_subsingleton _ _, surjOn_of_subsingleton' _ h.2\u27e9", "start": [1000, 1], "end": [1002, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Set.bijOn_of_subsingleton", "code": "lemma bijOn_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b1) (s : Set \u03b1) : BijOn f s s :=\n  bijOn_of_subsingleton' _ Iff.rfl", "start": [1005, 1], "end": [1006, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.bijective", "code": "theorem BijOn.bijective (h : BijOn f s t) : Bijective (h.mapsTo.restrict f s t)", "start": [1009, 1], "end": [1012, 31], "kind": "commanddeclaration"}, {"full_name": "Set.bijective_iff_bijOn_univ", "code": "theorem bijective_iff_bijOn_univ : Bijective f \u2194 BijOn f univ univ", "start": [1015, 1], "end": [1022, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.bijOn_univ", "code": "alias \u27e8_root_.Function.Bijective.bijOn_univ, _\u27e9 := bijective_iff_bijOn_univ", "start": [1025, 1], "end": [1025, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.BijOn.compl", "code": "theorem BijOn.compl (hst : BijOn f s t) (hf : Bijective f) : BijOn f s\u1d9c t\u1d9c", "start": [1028, 1], "end": [1029, 77], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn", "code": "def LeftInvOn (f' : \u03b2 \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983x\u2984, x \u2208 s \u2192 f' (f x) = x", "start": [1035, 1], "end": [1037, 30], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.eqOn", "code": "theorem LeftInvOn.eqOn (h : LeftInvOn f' f s) : EqOn (f' \u2218 f) id s", "start": [1040, 1], "end": [1041, 4], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.eq", "code": "theorem LeftInvOn.eq (h : LeftInvOn f' f s) {x} (hx : x \u2208 s) : f' (f x) = x", "start": [1044, 1], "end": [1045, 7], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.congr_left", "code": "theorem LeftInvOn.congr_left (h\u2081 : LeftInvOn f\u2081' f s) {t : Set \u03b2} (h\u2081' : MapsTo f s t)\n    (heq : EqOn f\u2081' f\u2082' t) : LeftInvOn f\u2082' f s", "start": [1048, 1], "end": [1049, 83], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.congr_right", "code": "theorem LeftInvOn.congr_right (h\u2081 : LeftInvOn f\u2081' f\u2081 s) (heq : EqOn f\u2081 f\u2082 s) : LeftInvOn f\u2081' f\u2082 s", "start": [1052, 1], "end": [1053, 29], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.injOn", "code": "theorem LeftInvOn.injOn (h : LeftInvOn f\u2081' f s) : InjOn f s", "start": [1056, 1], "end": [1060, 19], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.surjOn", "code": "theorem LeftInvOn.surjOn (h : LeftInvOn f' f s) (hf : MapsTo f s t) : SurjOn f' t s", "start": [1063, 1], "end": [1064, 21], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.mapsTo", "code": "theorem LeftInvOn.mapsTo (h : LeftInvOn f' f s) (hf : SurjOn f s t) :\n    MapsTo f' t s", "start": [1067, 1], "end": [1070, 19], "kind": "commanddeclaration"}, {"full_name": "Set.leftInvOn_id", "code": "lemma leftInvOn_id (s : Set \u03b1) : LeftInvOn id id s := fun _ _ \u21a6 rfl", "start": [1073, 1], "end": [1073, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.LeftInvOn.comp", "code": "theorem LeftInvOn.comp (hf' : LeftInvOn f' f s) (hg' : LeftInvOn g' g t) (hf : MapsTo f s t) :\n    LeftInvOn (f' \u2218 g') (g \u2218 f) s", "start": [1076, 1], "end": [1080, 19], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.mono", "code": "theorem LeftInvOn.mono (hf : LeftInvOn f' f s) (ht : s\u2081 \u2286 s) : LeftInvOn f' f s\u2081", "start": [1083, 1], "end": [1084, 13], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.image_inter'", "code": "theorem LeftInvOn.image_inter' (hf : LeftInvOn f' f s) : f '' (s\u2081 \u2229 s) = f' \u207b\u00b9' s\u2081 \u2229 f '' s", "start": [1087, 1], "end": [1092, 50], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.image_inter", "code": "theorem LeftInvOn.image_inter (hf : LeftInvOn f' f s) :\n    f '' (s\u2081 \u2229 s) = f' \u207b\u00b9' (s\u2081 \u2229 s) \u2229 f '' s", "start": [1095, 1], "end": [1099, 81], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.image_image", "code": "theorem LeftInvOn.image_image (hf : LeftInvOn f' f s) : f' '' (f '' s) = s", "start": [1102, 1], "end": [1103, 50], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.image_image'", "code": "theorem LeftInvOn.image_image' (hf : LeftInvOn f' f s) (hs : s\u2081 \u2286 s) : f' '' (f '' s\u2081) = s\u2081", "start": [1106, 1], "end": [1107, 27], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn", "code": "@[reducible]\ndef RightInvOn (f' : \u03b2 \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) (t : Set \u03b2) : Prop :=\n  LeftInvOn f f' t", "start": [1113, 1], "end": [1116, 19], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.eqOn", "code": "theorem RightInvOn.eqOn (h : RightInvOn f' f t) : EqOn (f \u2218 f') id t", "start": [1119, 1], "end": [1120, 4], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.eq", "code": "theorem RightInvOn.eq (h : RightInvOn f' f t) {y} (hy : y \u2208 t) : f (f' y) = y", "start": [1123, 1], "end": [1124, 7], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.rightInvOn_image", "code": "theorem LeftInvOn.rightInvOn_image (h : LeftInvOn f' f s) : RightInvOn f' f (f '' s)", "start": [1127, 1], "end": [1128, 57], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.congr_left", "code": "theorem RightInvOn.congr_left (h\u2081 : RightInvOn f\u2081' f t) (heq : EqOn f\u2081' f\u2082' t) :\n    RightInvOn f\u2082' f t", "start": [1131, 1], "end": [1133, 21], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.congr_right", "code": "theorem RightInvOn.congr_right (h\u2081 : RightInvOn f' f\u2081 t) (hg : MapsTo f' t s) (heq : EqOn f\u2081 f\u2082 s) :\n    RightInvOn f' f\u2082 t", "start": [1136, 1], "end": [1138, 33], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.surjOn", "code": "theorem RightInvOn.surjOn (hf : RightInvOn f' f t) (hf' : MapsTo f' t s) : SurjOn f s t", "start": [1141, 1], "end": [1142, 26], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.mapsTo", "code": "theorem RightInvOn.mapsTo (h : RightInvOn f' f t) (hf : SurjOn f' t s) : MapsTo f s t", "start": [1145, 1], "end": [1146, 24], "kind": "commanddeclaration"}, {"full_name": "Set.rightInvOn_id", "code": "lemma rightInvOn_id (s : Set \u03b1) : RightInvOn id id s := fun _ _ \u21a6 rfl", "start": [1149, 1], "end": [1149, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Set.RightInvOn.comp", "code": "theorem RightInvOn.comp (hf : RightInvOn f' f t) (hg : RightInvOn g' g p) (g'pt : MapsTo g' p t) :\n    RightInvOn (f' \u2218 g') (g \u2218 f) p", "start": [1152, 1], "end": [1154, 28], "kind": "commanddeclaration"}, {"full_name": "Set.RightInvOn.mono", "code": "theorem RightInvOn.mono (hf : RightInvOn f' f t) (ht : t\u2081 \u2286 t) : RightInvOn f' f t\u2081", "start": [1157, 1], "end": [1158, 23], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.rightInvOn_of_leftInvOn", "code": "theorem InjOn.rightInvOn_of_leftInvOn (hf : InjOn f s) (hf' : LeftInvOn f f' t)\n    (h\u2081 : MapsTo f s t) (h\u2082 : MapsTo f' t s) : RightInvOn f f' s", "start": [1161, 1], "end": [1163, 33], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_of_leftInvOn_of_rightInvOn", "code": "theorem eqOn_of_leftInvOn_of_rightInvOn (h\u2081 : LeftInvOn f\u2081' f s) (h\u2082 : RightInvOn f\u2082' f t)\n    (h : MapsTo f\u2082' t s) : EqOn f\u2081' f\u2082' t", "start": [1166, 1], "end": [1170, 27], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.leftInvOn_of_rightInvOn", "code": "theorem SurjOn.leftInvOn_of_rightInvOn (hf : SurjOn f s t) (hf' : RightInvOn f f' s) :\n    LeftInvOn f f' t", "start": [1173, 1], "end": [1176, 21], "kind": "commanddeclaration"}, {"full_name": "Set.InvOn", "code": "def InvOn (g : \u03b2 \u2192 \u03b1) (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) : Prop :=\n  LeftInvOn g f s \u2227 RightInvOn g f t", "start": [1182, 1], "end": [1184, 37], "kind": "commanddeclaration"}, {"full_name": "Set.invOn_id", "code": "lemma invOn_id (s : Set \u03b1) : InvOn id id s s := \u27e8s.leftInvOn_id, s.rightInvOn_id\u27e9", "start": [1187, 1], "end": [1187, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Set.InvOn.comp", "code": "lemma InvOn.comp (hf : InvOn f' f s t) (hg : InvOn g' g t p) (fst : MapsTo f s t)\n    (g'pt : MapsTo g' p t) :\n    InvOn (f' \u2218 g') (g \u2218 f) s p :=\n  \u27e8hf.1.comp hg.1 fst, hf.2.comp hg.2 g'pt\u27e9", "start": [1190, 1], "end": [1193, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Set.InvOn.symm", "code": "@[symm]\ntheorem InvOn.symm (h : InvOn f' f s t) : InvOn f f' t s", "start": [1196, 1], "end": [1198, 20], "kind": "commanddeclaration"}, {"full_name": "Set.InvOn.mono", "code": "theorem InvOn.mono (h : InvOn f' f s t) (hs : s\u2081 \u2286 s) (ht : t\u2081 \u2286 t) : InvOn f' f s\u2081 t\u2081", "start": [1201, 1], "end": [1202, 29], "kind": "commanddeclaration"}, {"full_name": "Set.InvOn.bijOn", "code": "theorem InvOn.bijOn (h : InvOn f' f s t) (hf : MapsTo f s t) (hf' : MapsTo f' t s) : BijOn f s t", "start": [1205, 1], "end": [1209, 41], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn", "code": "noncomputable def invFunOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (b : \u03b2) : \u03b1 :=\n  if h : \u2203 a, a \u2208 s \u2227 f a = b then Classical.choose h else Classical.choice \u2039Nonempty \u03b1\u203a", "start": [1223, 1], "end": [1226, 89], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_pos", "code": "theorem invFunOn_pos (h : \u2203 a \u2208 s, f a = b) : invFunOn f s b \u2208 s \u2227 f (invFunOn f s b) = b", "start": [1229, 1], "end": [1231, 32], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_mem", "code": "theorem invFunOn_mem (h : \u2203 a \u2208 s, f a = b) : invFunOn f s b \u2208 s", "start": [1234, 1], "end": [1235, 24], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_eq", "code": "theorem invFunOn_eq (h : \u2203 a \u2208 s, f a = b) : f (invFunOn f s b) = b", "start": [1238, 1], "end": [1239, 25], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_neg", "code": "theorem invFunOn_neg (h : \u00ac\u2203 a \u2208 s, f a = b) : invFunOn f s b = Classical.choice \u2039Nonempty \u03b1\u203a", "start": [1242, 1], "end": [1243, 30], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_apply_mem", "code": "@[simp]\ntheorem invFunOn_apply_mem (h : a \u2208 s) : invFunOn f s (f a) \u2208 s", "start": [1246, 1], "end": [1248, 27], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_apply_eq", "code": "theorem invFunOn_apply_eq (h : a \u2208 s) : f (invFunOn f s (f a)) = f a", "start": [1251, 1], "end": [1252, 26], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.leftInvOn_invFunOn", "code": "theorem InjOn.leftInvOn_invFunOn [Nonempty \u03b1] (h : InjOn f s) : LeftInvOn (invFunOn f s) f s", "start": [1263, 1], "end": [1264, 67], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.invFunOn_image", "code": "theorem InjOn.invFunOn_image [Nonempty \u03b1] (h : InjOn f s\u2082) (ht : s\u2081 \u2286 s\u2082) :\n    invFunOn f s\u2082 '' (f '' s\u2081) = s\u2081", "start": [1267, 1], "end": [1269, 39], "kind": "commanddeclaration"}, {"full_name": "Function.leftInvOn_invFunOn_of_subset_image_image", "code": "theorem _root_.Function.leftInvOn_invFunOn_of_subset_image_image [Nonempty \u03b1]\n    (h : s \u2286 (invFunOn f s) '' (f '' s)) : LeftInvOn (invFunOn f s) f s", "start": [1272, 1], "end": [1276, 40], "kind": "commanddeclaration"}, {"full_name": "Set.injOn_iff_invFunOn_image_image_eq_self", "code": "theorem injOn_iff_invFunOn_image_image_eq_self [Nonempty \u03b1] :\n    InjOn f s \u2194 (invFunOn f s) '' (f '' s) = s", "start": [1278, 1], "end": [1281, 77], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_injOn_image", "code": "theorem _root_.Function.invFunOn_injOn_image [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    Set.InjOn (invFunOn f s) (f '' s)", "start": [1283, 1], "end": [1286, 74], "kind": "commanddeclaration"}, {"full_name": "Function.invFunOn_image_image_subset", "code": "theorem _root_.Function.invFunOn_image_image_subset [Nonempty \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) :\n    (invFunOn f s) '' (f '' s) \u2286 s", "start": [1288, 1], "end": [1290, 61], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.rightInvOn_invFunOn", "code": "theorem SurjOn.rightInvOn_invFunOn [Nonempty \u03b1] (h : SurjOn f s t) :\n    RightInvOn (invFunOn f s) f t", "start": [1292, 1], "end": [1293, 70], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.invOn_invFunOn", "code": "theorem BijOn.invOn_invFunOn [Nonempty \u03b1] (h : BijOn f s t) : InvOn (invFunOn f s) f s t", "start": [1296, 1], "end": [1297, 61], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.invOn_invFunOn", "code": "theorem SurjOn.invOn_invFunOn [Nonempty \u03b1] (h : SurjOn f s t) :\n    InvOn (invFunOn f s) f (invFunOn f s '' t) t", "start": [1300, 1], "end": [1304, 32], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.mapsTo_invFunOn", "code": "theorem SurjOn.mapsTo_invFunOn [Nonempty \u03b1] (h : SurjOn f s t) : MapsTo (invFunOn f s) t s", "start": [1307, 1], "end": [1308, 54], "kind": "commanddeclaration"}, {"full_name": "Set.SurjOn.bijOn_subset", "code": "theorem SurjOn.bijOn_subset [Nonempty \u03b1] (h : SurjOn f s t) : BijOn f (invFunOn f s '' t) t", "start": [1311, 1], "end": [1314, 33], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iff_exists_bijOn_subset", "code": "theorem surjOn_iff_exists_bijOn_subset : SurjOn f s t \u2194 \u2203 (s' : _) (_ : s' \u2286 s), BijOn f s' t", "start": [1317, 1], "end": [1325, 47], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_invFun_of_mem", "code": "theorem preimage_invFun_of_mem [n : Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Injective f) {s : Set \u03b1}\n    (h : Classical.choice n \u2208 s) : invFun f \u207b\u00b9' s = f '' s \u222a (range f)\u1d9c", "start": [1328, 1], "end": [1334, 101], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_invFun_of_not_mem", "code": "theorem preimage_invFun_of_not_mem [n : Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Injective f) {s : Set \u03b1}\n    (h : Classical.choice n \u2209 s) : invFun f \u207b\u00b9' s = f '' s", "start": [1337, 1], "end": [1343, 53], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.symm", "code": "lemma BijOn.symm {g : \u03b2 \u2192 \u03b1} (h : InvOn f g t s) (hf : BijOn f s t) : BijOn g t s :=\n  \u27e8h.2.mapsTo hf.surjOn, h.1.injOn, h.2.surjOn hf.mapsTo\u27e9", "start": [1346, 1], "end": [1347, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Set.bijOn_comm", "code": "lemma bijOn_comm {g : \u03b2 \u2192 \u03b1} (h : InvOn f g t s) : BijOn f s t \u2194 BijOn g t s :=\n  \u27e8BijOn.symm h, BijOn.symm h.symm\u27e9", "start": [1350, 1], "end": [1351, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.restrict", "code": "protected theorem restrict (h : Monotone f) (s : Set \u03b1) : Monotone (s.restrict f)", "start": [1363, 1], "end": [1364, 8], "kind": "commanddeclaration"}, {"full_name": "Monotone.codRestrict", "code": "protected theorem codRestrict (h : Monotone f) {s : Set \u03b2} (hs : \u2200 x, f x \u2208 s) :\n    Monotone (s.codRestrict f hs)", "start": [1367, 1], "end": [1369, 4], "kind": "commanddeclaration"}, {"full_name": "Monotone.rangeFactorization", "code": "protected theorem rangeFactorization (h : Monotone f) : Monotone (Set.rangeFactorization f)", "start": [1372, 1], "end": [1373, 4], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_empty", "code": "@[simp]\ntheorem piecewise_empty [\u2200 i : \u03b1, Decidable (i \u2208 (\u2205 : Set \u03b1))] : piecewise \u2205 f g = g", "start": [1385, 1], "end": [1388, 19], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_univ", "code": "@[simp]\ntheorem piecewise_univ [\u2200 i : \u03b1, Decidable (i \u2208 (Set.univ : Set \u03b1))] :\n    piecewise Set.univ f g = f", "start": [1391, 1], "end": [1395, 19], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_insert_self", "code": "theorem piecewise_insert_self {j : \u03b1} [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g j = f j", "start": [1399, 1], "end": [1400, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Compl.decidableMem", "code": "instance Compl.decidableMem (j : \u03b1) : Decidable (j \u2208 s\u1d9c) :=\n  instDecidableNot", "start": [1405, 1], "end": [1406, 19], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_insert", "code": "theorem piecewise_insert [DecidableEq \u03b1] (j : \u03b1) [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g = Function.update (s.piecewise f g) j (f j)", "start": [1409, 1], "end": [1416, 41], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_eq_of_mem", "code": "@[simp]\ntheorem piecewise_eq_of_mem {i : \u03b1} (hi : i \u2208 s) : s.piecewise f g i = f i", "start": [1419, 1], "end": [1421, 12], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_eq_of_not_mem", "code": "@[simp]\ntheorem piecewise_eq_of_not_mem {i : \u03b1} (hi : i \u2209 s) : s.piecewise f g i = g i", "start": [1424, 1], "end": [1426, 12], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_singleton", "code": "theorem piecewise_singleton (x : \u03b1) [\u2200 y, Decidable (y \u2208 ({x} : Set \u03b1))] [DecidableEq \u03b1]\n    (f g : \u03b1 \u2192 \u03b2) : piecewise {x} f g = Function.update g x (f x)", "start": [1429, 1], "end": [1435, 14], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_eqOn", "code": "theorem piecewise_eqOn (f g : \u03b1 \u2192 \u03b2) : EqOn (s.piecewise f g) f s", "start": [1438, 1], "end": [1439, 28], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_eqOn_compl", "code": "theorem piecewise_eqOn_compl (f g : \u03b1 \u2192 \u03b2) : EqOn (s.piecewise f g) g s\u1d9c", "start": [1442, 1], "end": [1443, 32], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_le", "code": "theorem piecewise_le {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {s : Set \u03b1} [\u2200 j, Decidable (j \u2208 s)]\n    {f\u2081 f\u2082 g : \u2200 i, \u03b4 i} (h\u2081 : \u2200 i \u2208 s, f\u2081 i \u2264 g i) (h\u2082 : \u2200 (i) (_ : i \u2209 s), f\u2082 i \u2264 g i) :\n    s.piecewise f\u2081 f\u2082 \u2264 g", "start": [1446, 1], "end": [1448, 85], "kind": "commanddeclaration"}, {"full_name": "Set.le_piecewise", "code": "theorem le_piecewise {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {s : Set \u03b1} [\u2200 j, Decidable (j \u2208 s)]\n    {f\u2081 f\u2082 g : \u2200 i, \u03b4 i} (h\u2081 : \u2200 i \u2208 s, g i \u2264 f\u2081 i) (h\u2082 : \u2200 (i) (_ : i \u2209 s), g i \u2264 f\u2082 i) :\n    g \u2264 s.piecewise f\u2081 f\u2082", "start": [1451, 1], "end": [1454, 55], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_le_piecewise", "code": "theorem piecewise_le_piecewise {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {s : Set \u03b1}\n    [\u2200 j, Decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, \u03b4 i} (h\u2081 : \u2200 i \u2208 s, f\u2081 i \u2264 g\u2081 i)\n    (h\u2082 : \u2200 (i) (_ : i \u2209 s), f\u2082 i \u2264 g\u2082 i) : s.piecewise f\u2081 f\u2082 \u2264 s.piecewise g\u2081 g\u2082", "start": [1457, 1], "end": [1460, 45], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_insert_of_ne", "code": "@[simp]\ntheorem piecewise_insert_of_ne {i j : \u03b1} (h : i \u2260 j) [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g i = s.piecewise f g i", "start": [1463, 1], "end": [1465, 79], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_compl", "code": "@[simp]\ntheorem piecewise_compl [\u2200 i, Decidable (i \u2208 s\u1d9c)] : s\u1d9c.piecewise f g = s.piecewise g f", "start": [1468, 1], "end": [1470, 68], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_range_comp", "code": "@[simp]\ntheorem piecewise_range_comp {\u03b9 : Sort*} (f : \u03b9 \u2192 \u03b1) [\u2200 j, Decidable (j \u2208 range f)]\n    (g\u2081 g\u2082 : \u03b1 \u2192 \u03b2) : (range f).piecewise g\u2081 g\u2082 \u2218 f = g\u2081 \u2218 f", "start": [1473, 1], "end": [1476, 30], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.piecewise_ite", "code": "theorem MapsTo.piecewise_ite {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2}\n    [\u2200 i, Decidable (i \u2208 s)] (h\u2081 : MapsTo f\u2081 (s\u2081 \u2229 s) (t\u2081 \u2229 t))\n    (h\u2082 : MapsTo f\u2082 (s\u2082 \u2229 s\u1d9c) (t\u2082 \u2229 t\u1d9c)) :\n    MapsTo (s.piecewise f\u2081 f\u2082) (s.ite s\u2081 s\u2082) (t.ite t\u2081 t\u2082)", "start": [1479, 1], "end": [1485, 71], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_piecewise", "code": "theorem eqOn_piecewise {f f' g : \u03b1 \u2192 \u03b2} {t} :\n    EqOn (s.piecewise f f') g t \u2194 EqOn f g (t \u2229 s) \u2227 EqOn f' g (t \u2229 s\u1d9c)", "start": [1488, 1], "end": [1491, 64], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.piecewise_ite'", "code": "theorem EqOn.piecewise_ite' {f f' g : \u03b1 \u2192 \u03b2} {t t'} (h : EqOn f g (t \u2229 s))\n    (h' : EqOn f' g (t' \u2229 s\u1d9c)) : EqOn (s.piecewise f f') g (s.ite t t')", "start": [1494, 1], "end": [1496, 27], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.piecewise_ite", "code": "theorem EqOn.piecewise_ite {f f' g : \u03b1 \u2192 \u03b2} {t t'} (h : EqOn f g t) (h' : EqOn f' g t') :\n    EqOn (s.piecewise f f') g (s.ite t t')", "start": [1499, 1], "end": [1501, 86], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_preimage", "code": "theorem piecewise_preimage (f g : \u03b1 \u2192 \u03b2) (t) : s.piecewise f g \u207b\u00b9' t = s.ite (f \u207b\u00b9' t) (g \u207b\u00b9' t)", "start": [1504, 1], "end": [1505, 55], "kind": "commanddeclaration"}, {"full_name": "Set.apply_piecewise", "code": "theorem apply_piecewise {\u03b4' : \u03b1 \u2192 Sort*} (h : \u2200 i, \u03b4 i \u2192 \u03b4' i) {x : \u03b1} :\n    h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x", "start": [1508, 1], "end": [1510, 36], "kind": "commanddeclaration"}, {"full_name": "Set.apply_piecewise\u2082", "code": "theorem apply_piecewise\u2082 {\u03b4' \u03b4'' : \u03b1 \u2192 Sort*} (f' g' : \u2200 i, \u03b4' i) (h : \u2200 i, \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i)\n    {x : \u03b1} :\n    h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x", "start": [1513, 1], "end": [1517, 39], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_op", "code": "theorem piecewise_op {\u03b4' : \u03b1 \u2192 Sort*} (h : \u2200 i, \u03b4 i \u2192 \u03b4' i) :\n    (s.piecewise (fun x => h x (f x)) fun x => h x (g x)) = fun x => h x (s.piecewise f g x)", "start": [1520, 1], "end": [1522, 49], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_op\u2082", "code": "theorem piecewise_op\u2082 {\u03b4' \u03b4'' : \u03b1 \u2192 Sort*} (f' g' : \u2200 i, \u03b4' i) (h : \u2200 i, \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i) :\n    (s.piecewise (fun x => h x (f x) (f' x)) fun x => h x (g x) (g' x)) = fun x =>\n      h x (s.piecewise f g x) (s.piecewise f' g' x)", "start": [1525, 1], "end": [1528, 54], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_same", "code": "@[simp]\ntheorem piecewise_same : s.piecewise f f = f", "start": [1531, 1], "end": [1534, 36], "kind": "commanddeclaration"}, {"full_name": "Set.range_piecewise", "code": "theorem range_piecewise (f g : \u03b1 \u2192 \u03b2) : range (s.piecewise f g) = f '' s \u222a g '' s\u1d9c", "start": [1537, 1], "end": [1541, 64], "kind": "commanddeclaration"}, {"full_name": "Set.injective_piecewise_iff", "code": "theorem injective_piecewise_iff {f g : \u03b1 \u2192 \u03b2} :\n    Injective (s.piecewise f g) \u2194\n      InjOn f s \u2227 InjOn g s\u1d9c \u2227 \u2200 x \u2208 s, \u2200 (y) (_ : y \u2209 s), f x \u2260 g y", "start": [1545, 1], "end": [1551, 70], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_mem_pi", "code": "theorem piecewise_mem_pi {\u03b4 : \u03b1 \u2192 Type*} {t : Set \u03b1} {t' : \u2200 i, Set (\u03b4 i)} {f g} (hf : f \u2208 pi t t')\n    (hg : g \u2208 pi t t') : s.piecewise f g \u2208 pi t t'", "start": [1554, 1], "end": [1557, 54], "kind": "commanddeclaration"}, {"full_name": "Set.pi_piecewise", "code": "@[simp]\ntheorem pi_piecewise {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} (s s' : Set \u03b9) (t t' : \u2200 i, Set (\u03b1 i))\n    [\u2200 x, Decidable (x \u2208 s')] : pi s (s'.piecewise t t') = pi (s \u2229 s') t \u2229 pi (s \\ s') t'", "start": [1560, 1], "end": [1563, 14], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_piecewise", "code": "theorem univ_pi_piecewise {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} (s : Set \u03b9) (t t' : \u2200 i, Set (\u03b1 i))\n    [\u2200 x, Decidable (x \u2208 s)] : pi univ (s.piecewise t t') = pi s t \u2229 pi s\u1d9c t'", "start": [1567, 1], "end": [1569, 28], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_piecewise_univ", "code": "theorem univ_pi_piecewise_univ {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i))\n    [\u2200 x, Decidable (x \u2208 s)] : pi univ (s.piecewise t fun _ => univ) = pi s t", "start": [1571, 1], "end": [1572, 89], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.injOn", "code": "theorem StrictMonoOn.injOn [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (H : StrictMonoOn f s) : s.InjOn f", "start": [1579, 1], "end": [1581, 62], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.injOn", "code": "theorem StrictAntiOn.injOn [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (H : StrictAntiOn f s) : s.InjOn f", "start": [1584, 1], "end": [1586, 38], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.comp", "code": "theorem StrictMonoOn.comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {t : Set \u03b2} (hg : StrictMonoOn g t) (hf : StrictMonoOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g \u2218 f) s", "start": [1589, 1], "end": [1591, 88], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.comp_strictAntiOn", "code": "theorem StrictMonoOn.comp_strictAntiOn [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3}\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hg : StrictMonoOn g t) (hf : StrictAntiOn f s)\n    (hs : Set.MapsTo f s t) : StrictAntiOn (g \u2218 f) s", "start": [1594, 1], "end": [1597, 37], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.comp", "code": "theorem StrictAntiOn.comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    {t : Set \u03b2} (hg : StrictAntiOn g t) (hf : StrictAntiOn f s) (hs : Set.MapsTo f s t) :\n    StrictMonoOn (g \u2218 f) s", "start": [1600, 1], "end": [1602, 88], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.comp_strictMonoOn", "code": "theorem StrictAntiOn.comp_strictMonoOn [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3}\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hg : StrictAntiOn g t) (hf : StrictMonoOn f s)\n    (hs : Set.MapsTo f s t) : StrictAntiOn (g \u2218 f) s", "start": [1605, 1], "end": [1608, 37], "kind": "commanddeclaration"}, {"full_name": "strictMono_restrict", "code": "@[simp]\ntheorem strictMono_restrict [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    StrictMono (s.restrict f) \u2194 StrictMonoOn f s", "start": [1611, 1], "end": [1613, 101], "kind": "commanddeclaration"}, {"full_name": "StrictMono.of_restrict", "code": "alias \u27e8_root_.StrictMono.of_restrict, _root_.StrictMonoOn.restrict\u27e9 := strictMono_restrict", "start": [1616, 1], "end": [1616, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMonoOn.restrict", "code": "alias \u27e8_root_.StrictMono.of_restrict, _root_.StrictMonoOn.restrict\u27e9 := strictMono_restrict", "start": [1616, 1], "end": [1616, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMono.codRestrict", "code": "theorem StrictMono.codRestrict [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : StrictMono f)\n    {s : Set \u03b2} (hs : \u2200 x, f x \u2208 s) : StrictMono (Set.codRestrict f s hs)", "start": [1620, 1], "end": [1622, 5], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.comp_injOn", "code": "theorem Injective.comp_injOn (hg : Injective g) (hf : s.InjOn f) : s.InjOn (g \u2218 f)", "start": [1631, 1], "end": [1632, 44], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.surjOn", "code": "theorem Surjective.surjOn (hf : Surjective f) (s : Set \u03b2) : SurjOn f univ s", "start": [1635, 1], "end": [1636, 73], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.leftInvOn", "code": "theorem LeftInverse.leftInvOn {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g) (s : Set \u03b2) : LeftInvOn f g s", "start": [1639, 1], "end": [1640, 17], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.rightInvOn", "code": "theorem RightInverse.rightInvOn {g : \u03b2 \u2192 \u03b1} (h : RightInverse f g) (s : Set \u03b1) :\n    RightInvOn f g s", "start": [1643, 1], "end": [1644, 39], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.rightInvOn_range", "code": "theorem LeftInverse.rightInvOn_range {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g) :\n    RightInvOn f g (range g)", "start": [1647, 1], "end": [1649, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_image", "code": "theorem mapsTo_image (h : Semiconj f fa fb) (ha : MapsTo fa s t) : MapsTo fb (f '' s) (f '' t)", "start": [1654, 1], "end": [1655, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_range", "code": "theorem mapsTo_range (h : Semiconj f fa fb) : MapsTo fb (range f) (range f)", "start": [1658, 1], "end": [1659, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.surjOn_image", "code": "theorem surjOn_image (h : Semiconj f fa fb) (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t)", "start": [1662, 1], "end": [1666, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.surjOn_range", "code": "theorem surjOn_range (h : Semiconj f fa fb) (ha : Surjective fa) :\n    SurjOn fb (range f) (range f)", "start": [1669, 1], "end": [1672, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.injOn_image", "code": "theorem injOn_image (h : Semiconj f fa fb) (ha : InjOn fa s) (hf : InjOn f (fa '' s)) :\n    InjOn fb (f '' s)", "start": [1675, 1], "end": [1679, 89], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.injOn_range", "code": "theorem injOn_range (h : Semiconj f fa fb) (ha : Injective fa) (hf : InjOn f (range fa)) :\n    InjOn fb (range f)", "start": [1682, 1], "end": [1685, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.bijOn_image", "code": "theorem bijOn_image (h : Semiconj f fa fb) (ha : BijOn fa s t) (hf : InjOn f t) :\n    BijOn fb (f '' s) (f '' t)", "start": [1688, 1], "end": [1691, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.bijOn_range", "code": "theorem bijOn_range (h : Semiconj f fa fb) (ha : Bijective fa) (hf : Injective f) :\n    BijOn fb (range f) (range f)", "start": [1694, 1], "end": [1697, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_preimage", "code": "theorem mapsTo_preimage (h : Semiconj f fa fb) {s t : Set \u03b2} (hb : MapsTo fb s t) :\n    MapsTo fa (f \u207b\u00b9' s) (f \u207b\u00b9' t)", "start": [1700, 1], "end": [1701, 89], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.injOn_preimage", "code": "theorem injOn_preimage (h : Semiconj f fa fb) {s : Set \u03b2} (hb : InjOn fb s)\n    (hf : InjOn f (f \u207b\u00b9' s)) : InjOn fa (f \u207b\u00b9' s)", "start": [1704, 1], "end": [1709, 33], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_not_mem_range'", "code": "theorem update_comp_eq_of_not_mem_range' {\u03b1 \u03b2 : Sort _} {\u03b3 : \u03b2 \u2192 Sort*} [DecidableEq \u03b2]\n    (g : \u2200 b, \u03b3 b) {f : \u03b1 \u2192 \u03b2} {i : \u03b2} (a : \u03b3 i) (h : i \u2209 Set.range f) :\n    (fun j => (Function.update g i a) (f j)) = fun j => g (f j)", "start": [1714, 1], "end": [1717, 59], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_eq_of_not_mem_range", "code": "theorem update_comp_eq_of_not_mem_range {\u03b1 \u03b2 \u03b3 : Sort _} [DecidableEq \u03b2] (g : \u03b2 \u2192 \u03b3) {f : \u03b1 \u2192 \u03b2}\n    {i : \u03b2} (a : \u03b3) (h : i \u2209 Set.range f) : Function.update g i a \u2218 f = g \u2218 f", "start": [1720, 1], "end": [1723, 41], "kind": "commanddeclaration"}, {"full_name": "Function.insert_injOn", "code": "theorem insert_injOn (s : Set \u03b1) : s\u1d9c.InjOn fun a => insert a s", "start": [1726, 1], "end": [1727, 20], "kind": "commanddeclaration"}, {"full_name": "Function.monotoneOn_of_rightInvOn_of_mapsTo", "code": "theorem monotoneOn_of_rightInvOn_of_mapsTo {\u03b1 \u03b2 : Sort _} [PartialOrder \u03b1] [LinearOrder \u03b2]\n    {\u03c6 : \u03b2 \u2192 \u03b1} {\u03c8 : \u03b1 \u2192 \u03b2} {t : Set \u03b2} {s : Set \u03b1} (h\u03c6 : MonotoneOn \u03c6 t)\n    (\u03c6\u03c8s : Set.RightInvOn \u03c8 \u03c6 s) (\u03c8ts : Set.MapsTo \u03c8 s t) : MonotoneOn \u03c8 s", "start": [1730, 1], "end": [1739, 20], "kind": "commanddeclaration"}, {"full_name": "Function.antitoneOn_of_rightInvOn_of_mapsTo", "code": "theorem antitoneOn_of_rightInvOn_of_mapsTo {\u03b1 \u03b2 : Sort _} [PartialOrder \u03b1] [LinearOrder \u03b2]\n    {\u03c6 : \u03b2 \u2192 \u03b1} {\u03c8 : \u03b1 \u2192 \u03b2} {t : Set \u03b2} {s : Set \u03b1} (h\u03c6 : AntitoneOn \u03c6 t)\n    (\u03c6\u03c8s : Set.RightInvOn \u03c8 \u03c6 s) (\u03c8ts : Set.MapsTo \u03c8 s t) : AntitoneOn \u03c8 s", "start": [1742, 1], "end": [1745, 71], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.extendDomain", "code": "protected lemma MapsTo.extendDomain (h : MapsTo g s t) :\n    MapsTo (g.extendDomain f) ((\u2191) \u2218 f '' s) ((\u2191) \u2218 f '' t) := by\n  rintro _ \u27e8a, ha, rfl\u27e9; exact \u27e8_, h ha, by simp_rw [Function.comp_apply, extendDomain_apply_image]\u27e9", "start": [1755, 1], "end": [1757, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Set.SurjOn.extendDomain", "code": "protected lemma SurjOn.extendDomain (h : SurjOn g s t) :\n    SurjOn (g.extendDomain f) ((\u2191) \u2218 f '' s) ((\u2191) \u2218 f '' t) := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  obtain \u27e8b, hb, rfl\u27e9 := h ha\n  exact \u27e8_, \u27e8_, hb, rfl\u27e9, by simp_rw [Function.comp_apply, extendDomain_apply_image]\u27e9", "start": [1760, 1], "end": [1764, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.extendDomain", "code": "protected lemma BijOn.extendDomain (h : BijOn g s t) :\n    BijOn (g.extendDomain f) ((\u2191) \u2218 f '' s) ((\u2191) \u2218 f '' t) :=\n  \u27e8h.mapsTo.extendDomain, (g.extendDomain f).injective.injOn _, h.surjOn.extendDomain\u27e9", "start": [1767, 1], "end": [1769, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Set.LeftInvOn.extendDomain", "code": "protected lemma LeftInvOn.extendDomain (h : LeftInvOn g\u2081 g\u2082 s) :\n    LeftInvOn (g\u2081.extendDomain f) (g\u2082.extendDomain f) ((\u2191) \u2218 f '' s) := by\n  rintro _ \u27e8a, ha, rfl\u27e9; simp_rw [Function.comp_apply, extendDomain_apply_image, h ha]", "start": [1772, 1], "end": [1774, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Set.RightInvOn.extendDomain", "code": "protected lemma RightInvOn.extendDomain (h : RightInvOn g\u2081 g\u2082 t) :\n    RightInvOn (g\u2081.extendDomain f) (g\u2082.extendDomain f) ((\u2191) \u2218 f '' t) := by\n  rintro _ \u27e8a, ha, rfl\u27e9; simp_rw [Function.comp_apply, extendDomain_apply_image, h ha]", "start": [1777, 1], "end": [1779, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Set.InvOn.extendDomain", "code": "protected lemma InvOn.extendDomain (h : InvOn g\u2081 g\u2082 s t) :\n    InvOn (g\u2081.extendDomain f) (g\u2082.extendDomain f) ((\u2191) \u2218 f '' s) ((\u2191) \u2218 f '' t) :=\n  \u27e8h.1.extendDomain, h.2.extendDomain\u27e9", "start": [1782, 1], "end": [1784, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.bijOn'", "code": "lemma bijOn' (h\u2081 : MapsTo e s t) (h\u2082 : MapsTo e.symm t s) : BijOn e s t :=\n  \u27e8h\u2081, e.injective.injOn _, fun b hb \u21a6 \u27e8e.symm b, h\u2082 hb, apply_symm_apply _ _\u27e9\u27e9", "start": [1792, 1], "end": [1793, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.bijOn", "code": "protected lemma bijOn (h : \u2200 a, e a \u2208 t \u2194 a \u2208 s) : BijOn e s t :=\n  e.bijOn' (fun a \u21a6 (h _).2) $ fun b hb \u21a6 (h _).1 $ by rwa [apply_symm_apply]", "start": [1796, 1], "end": [1797, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.invOn", "code": "lemma invOn : InvOn e e.symm t s :=\n  \u27e8e.rightInverse_symm.leftInvOn _, e.leftInverse_symm.leftInvOn _\u27e9", "start": [1800, 1], "end": [1801, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.bijOn_image", "code": "lemma bijOn_image : BijOn e s (e '' s) := (e.injective.injOn _).bijOn_image", "start": [1804, 1], "end": [1804, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.bijOn_symm_image", "code": "lemma bijOn_symm_image : BijOn e.symm (e '' s) s := e.bijOn_image.symm e.invOn", "start": [1806, 1], "end": [1806, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.bijOn_symm", "code": "@[simp] lemma bijOn_symm : BijOn e.symm t s \u2194 BijOn e s t := bijOn_comm e.symm.invOn", "start": [1811, 1], "end": [1811, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.of_equiv_symm", "code": "alias \u27e8_root_.Set.BijOn.of_equiv_symm, _root_.Set.BijOn.equiv_symm\u27e9 := bijOn_symm", "start": [1814, 1], "end": [1814, 82], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.BijOn.equiv_symm", "code": "alias \u27e8_root_.Set.BijOn.of_equiv_symm, _root_.Set.BijOn.equiv_symm\u27e9 := bijOn_symm", "start": [1814, 1], "end": [1814, 82], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Equiv.bijOn_swap", "code": "lemma bijOn_swap (ha : a \u2208 s) (hb : b \u2208 s) : BijOn (swap a b) s s :=\n  (swap a b).bijOn $ fun x \u21a6 by\n    obtain rfl | hxa := eq_or_ne x a <;>\n    obtain rfl | hxb := eq_or_ne x b <;>\n    simp [*, swap_apply_of_ne_of_ne]", "start": [1820, 1], "end": [1824, 37], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/List/Count.lean", "imports": ["Mathlib/Data/List/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.countP_join", "code": "theorem countP_join : \u2200 l : List (List \u03b1), countP p l.join = (l.map (countP p)).sum", "start": [47, 1], "end": [49, 77], "kind": "commanddeclaration"}, {"full_name": "List.length_filter_lt_length_iff_exists", "code": "theorem length_filter_lt_length_iff_exists (l) :\n    length (filter p l) < length l \u2194 \u2203 x \u2208 l, \u00acp x", "start": [58, 1], "end": [61, 38], "kind": "commanddeclaration"}, {"full_name": "List.count_cons'", "code": "@[deprecated] theorem count_cons' (a b : \u03b1) (l : List \u03b1) :\n    count a (b :: l) = count a l + if a = b then 1 else 0", "start": [88, 1], "end": [91, 22], "kind": "commanddeclaration"}, {"full_name": "List.count_join", "code": "theorem count_join (l : List (List \u03b1)) (a : \u03b1) : l.join.count a = (l.map (count a)).sum", "start": [114, 1], "end": [115, 18], "kind": "commanddeclaration"}, {"full_name": "List.count_bind", "code": "theorem count_bind {\u03b1 \u03b2} [DecidableEq \u03b2] (l : List \u03b1) (f : \u03b1 \u2192 List \u03b2) (x : \u03b2) :\n    count x (l.bind f) = sum (map (count x \u2218 f) l)", "start": [146, 1], "end": [147, 93], "kind": "commanddeclaration"}, {"full_name": "List.count_map_of_injective", "code": "@[simp]\ntheorem count_map_of_injective {\u03b1 \u03b2} [DecidableEq \u03b1] [DecidableEq \u03b2] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (hf : Function.Injective f) (x : \u03b1) : count (f x) (map f l) = count x l", "start": [150, 1], "end": [153, 52], "kind": "commanddeclaration"}, {"full_name": "List.prod_map_eq_pow_single", "code": "@[to_additive]\ntheorem prod_map_eq_pow_single [Monoid \u03b2] (a : \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (hf : \u2200 a', a' \u2260 a \u2192 a' \u2208 l \u2192 f a' = 1) : (l.map f).prod = f a ^ l.count a", "start": [164, 1], "end": [173, 77], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_pow_single", "code": "@[to_additive]\ntheorem prod_eq_pow_single [Monoid \u03b1] (a : \u03b1)\n    (h : \u2200 a', a' \u2260 a \u2192 a' \u2208 l \u2192 a' = 1) : l.prod = a ^ l.count a", "start": [177, 1], "end": [180, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Pairwise.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Set.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "Pairwise", "code": "def Pairwise (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n  \u2200 \u2983i j\u2984, i \u2260 j \u2192 r i j", "start": [33, 1], "end": [35, 25], "kind": "commanddeclaration"}, {"full_name": "Pairwise.mono", "code": "theorem Pairwise.mono (hr : Pairwise r) (h : \u2200 \u2983i j\u2984, r i j \u2192 p i j) : Pairwise p", "start": [38, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "Pairwise.eq", "code": "protected theorem Pairwise.eq (h : Pairwise r) : \u00acr a b \u2192 a = b", "start": [42, 1], "end": [43, 27], "kind": "commanddeclaration"}, {"full_name": "Function.injective_iff_pairwise_ne", "code": "theorem Function.injective_iff_pairwise_ne : Injective f \u2194 Pairwise ((\u00b7 \u2260 \u00b7) on f)", "start": [46, 1], "end": [47, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.pairwise_ne", "code": "alias \u27e8Function.Injective.pairwise_ne, _\u27e9 := Function.injective_iff_pairwise_ne", "start": [50, 1], "end": [50, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Pairwise", "code": "protected def Pairwise (s : Set \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n  \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 x \u2260 y \u2192 r x y", "start": [55, 1], "end": [57, 46], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_of_forall", "code": "theorem pairwise_of_forall (s : Set \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 a b, r a b) : s.Pairwise r", "start": [60, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.imp_on", "code": "theorem Pairwise.imp_on (h : s.Pairwise r) (hrp : s.Pairwise fun \u2983a b : \u03b1\u2984 => r a b \u2192 p a b) :\n    s.Pairwise p", "start": [64, 1], "end": [66, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.imp", "code": "theorem Pairwise.imp (h : s.Pairwise r) (hpq : \u2200 \u2983a b : \u03b1\u2984, r a b \u2192 p a b) : s.Pairwise p", "start": [69, 1], "end": [70, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.eq", "code": "protected theorem Pairwise.eq (hs : s.Pairwise r) (ha : a \u2208 s) (hb : b \u2208 s) (h : \u00acr a b) : a = b", "start": [73, 1], "end": [74, 42], "kind": "commanddeclaration"}, {"full_name": "Reflexive.set_pairwise_iff", "code": "theorem _root_.Reflexive.set_pairwise_iff (hr : Reflexive r) :\n    s.Pairwise r \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 r a b", "start": [77, 1], "end": [80, 9], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.on_injective", "code": "theorem Pairwise.on_injective (hs : s.Pairwise r) (hf : Function.Injective f) (hfs : \u2200 x, f x \u2208 s) :\n    Pairwise (r on f)", "start": [83, 1], "end": [84, 71], "kind": "commanddeclaration"}, {"full_name": "Pairwise.set_pairwise", "code": "theorem Pairwise.set_pairwise (h : Pairwise r) (s : Set \u03b1) : s.Pairwise r", "start": [89, 1], "end": [89, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Lex.lean", "imports": ["Mathlib/Order/RelClasses.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Lex", "code": "inductive Lex (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : List \u03b1 \u2192 List \u03b1 \u2192 Prop\n  | nil {a l} : Lex r [] (a :: l)\n  | cons {a l\u2081 l\u2082} (h : Lex r l\u2081 l\u2082) : Lex r (a :: l\u2081) (a :: l\u2082)\n  | rel {a\u2081 l\u2081 a\u2082 l\u2082} (h : r a\u2081 a\u2082) : Lex r (a\u2081 :: l\u2081) (a\u2082 :: l\u2082)", "start": [40, 1], "end": [46, 66], "kind": "commanddeclaration"}, {"full_name": "List.Lex.cons_iff", "code": "theorem cons_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsIrrefl \u03b1 r] {a l\u2081 l\u2082} :\n    Lex r (a :: l\u2081) (a :: l\u2082) \u2194 Lex r l\u2081 l\u2082", "start": [54, 1], "end": [56, 98], "kind": "commanddeclaration"}, {"full_name": "List.Lex.not_nil_right", "code": "@[simp]\ntheorem not_nil_right (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (l : List \u03b1) : \u00acLex r l []", "start": [59, 1], "end": [61, 7], "kind": "commanddeclaration"}, {"full_name": "List.Lex.nil_left_or_eq_nil", "code": "theorem nil_left_or_eq_nil {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (l : List \u03b1) : List.Lex r [] l \u2228 l = []", "start": [64, 1], "end": [67, 27], "kind": "commanddeclaration"}, {"full_name": "List.Lex.singleton_iff", "code": "@[simp]\ntheorem singleton_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (a b : \u03b1) : List.Lex r [a] [b] \u2194 r a b", "start": [69, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "List.Lex.isOrderConnected", "code": "instance isOrderConnected (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsOrderConnected \u03b1 r] [IsTrichotomous \u03b1 r] :\n    IsOrderConnected (List \u03b1) (Lex r) where\n  conn := aux where\n    aux\n    | _, [], c :: l\u2083, nil => Or.inr nil\n    | _, [], c :: l\u2083, rel _ => Or.inr nil\n    | _, [], c :: l\u2083, cons _ => Or.inr nil\n    | _, b :: l\u2082, c :: l\u2083, nil => Or.inl nil\n    | a :: l\u2081, b :: l\u2082, c :: l\u2083, rel h => (IsOrderConnected.conn _ b _ h).imp rel rel\n    | a :: l\u2081, b :: l\u2082, _ :: l\u2083, cons h => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      \u00b7 exact Or.inl (rel ab)\n      \u00b7 exact (aux _ l\u2082 _ h).imp cons cons\n      \u00b7 exact Or.inr (rel ab)", "start": [73, 1], "end": [86, 30], "kind": "commanddeclaration"}, {"full_name": "List.Lex.isTrichotomous", "code": "instance isTrichotomous (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrichotomous \u03b1 r] :\n    IsTrichotomous (List \u03b1) (Lex r) where\n  trichotomous := aux where\n    aux\n    | [], [] => Or.inr (Or.inl rfl)\n    | [], b :: l\u2082 => Or.inl nil\n    | a :: l\u2081, [] => Or.inr (Or.inr nil)\n    | a :: l\u2081, b :: l\u2082 => by\n      rcases trichotomous_of r a b with (ab | rfl | ab)\n      \u00b7 exact Or.inl (rel ab)\n      \u00b7 exact (aux l\u2081 l\u2082).imp cons (Or.imp (congr_arg _) cons)\n      \u00b7 exact Or.inr (Or.inr (rel ab))", "start": [92, 1], "end": [103, 39], "kind": "commanddeclaration"}, {"full_name": "List.Lex.isAsymm", "code": "instance isAsymm (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsAsymm \u03b1 r] : IsAsymm (List \u03b1) (Lex r) where\n  asymm := aux where\n    aux\n    | _, _, Lex.rel h\u2081, Lex.rel h\u2082 => asymm h\u2081 h\u2082\n    | _, _, Lex.rel h\u2081, Lex.cons _ => asymm h\u2081 h\u2081\n    | _, _, Lex.cons _, Lex.rel h\u2082 => asymm h\u2082 h\u2082\n    | _, _, Lex.cons h\u2081, Lex.cons h\u2082 => aux _ _ h\u2081 h\u2082", "start": [109, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "List.Lex.isStrictTotalOrder", "code": "instance isStrictTotalOrder (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsStrictTotalOrder \u03b1 r] :\n    IsStrictTotalOrder (List \u03b1) (Lex r) :=\n  { isStrictWeakOrder_of_isOrderConnected with }", "start": [121, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "List.Lex.decidableRel", "code": "instance decidableRel [DecidableEq \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] : DecidableRel (Lex r)\n  | l\u2081, [] => isFalse fun h => by cases h\n  | [], b :: l\u2082 => isTrue Lex.nil\n  | a :: l\u2081, b :: l\u2082 => by\n    haveI := decidableRel r l\u2081 l\u2082\n    refine' decidable_of_iff (r a b \u2228 a = b \u2227 Lex r l\u2081 l\u2082) \u27e8fun h => _, fun h => _\u27e9\n    \u00b7 rcases h with (h | \u27e8rfl, h\u27e9)\n      \u00b7 exact Lex.rel h\n      \u00b7 exact Lex.cons h\n    \u00b7 rcases h with (_ | h | h)\n      \u00b7 exact Or.inr \u27e8rfl, h\u27e9\n      \u00b7 exact Or.inl h", "start": [126, 1], "end": [137, 23], "kind": "commanddeclaration"}, {"full_name": "List.Lex.append_right", "code": "theorem append_right (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u2200 {s\u2081 s\u2082} (t), Lex r s\u2081 s\u2082 \u2192 Lex r s\u2081 (s\u2082 ++ t)", "start": [140, 1], "end": [143, 28], "kind": "commanddeclaration"}, {"full_name": "List.Lex.append_left", "code": "theorem append_left (R : \u03b1 \u2192 \u03b1 \u2192 Prop) {t\u2081 t\u2082} (h : Lex R t\u2081 t\u2082) : \u2200 s, Lex R (s ++ t\u2081) (s ++ t\u2082)", "start": [146, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "List.Lex.imp", "code": "theorem imp {r s : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, r a b \u2192 s a b) : \u2200 l\u2081 l\u2082, Lex r l\u2081 l\u2082 \u2192 Lex s l\u2081 l\u2082", "start": [151, 1], "end": [154, 33], "kind": "commanddeclaration"}, {"full_name": "List.Lex.to_ne", "code": "theorem to_ne : \u2200 {l\u2081 l\u2082 : List \u03b1}, Lex (\u00b7 \u2260 \u00b7) l\u2081 l\u2082 \u2192 l\u2081 \u2260 l\u2082", "start": [157, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Decidable.List.Lex.ne_iff", "code": "theorem _root_.Decidable.List.Lex.ne_iff [DecidableEq \u03b1] {l\u2081 l\u2082 : List \u03b1}\n    (H : length l\u2081 \u2264 length l\u2082) : Lex (\u00b7 \u2260 \u00b7) l\u2081 l\u2082 \u2194 l\u2081 \u2260 l\u2082", "start": [162, 1], "end": [173, 23], "kind": "commanddeclaration"}, {"full_name": "List.Lex.ne_iff", "code": "theorem ne_iff {l\u2081 l\u2082 : List \u03b1} (H : length l\u2081 \u2264 length l\u2082) : Lex (\u00b7 \u2260 \u00b7) l\u2081 l\u2082 \u2194 l\u2081 \u2260 l\u2082", "start": [176, 1], "end": [178, 36], "kind": "commanddeclaration"}, {"full_name": "List.LT'", "code": "instance LT' [LT \u03b1] : LT (List \u03b1) :=\n  \u27e8Lex (\u00b7 < \u00b7)\u27e9", "start": [184, 1], "end": [185, 16], "kind": "commanddeclaration"}, {"full_name": "List.nil_lt_cons", "code": "theorem nil_lt_cons [LT \u03b1] (a : \u03b1) (l : List \u03b1) : [] < a :: l", "start": [188, 1], "end": [189, 10], "kind": "commanddeclaration"}, {"full_name": "List.LE'", "code": "instance LE' [LinearOrder \u03b1] : LE (List \u03b1) :=\n  Preorder.toLE", "start": [196, 1], "end": [197, 16], "kind": "commanddeclaration"}, {"full_name": "List.lt_iff_lex_lt", "code": "theorem lt_iff_lex_lt [LinearOrder \u03b1] (l l' : List \u03b1) : lt l l' \u2194 Lex (\u00b7 < \u00b7) l l'", "start": [200, 1], "end": [212, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/MinMax.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Lemmas.lean", "Mathlib/Order/MinMax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "fn_min_mul_fn_max", "code": "@[to_additive]\ntheorem fn_min_mul_fn_max [LinearOrder \u03b1] [CommSemigroup \u03b2] (f : \u03b1 \u2192 \u03b2) (n m : \u03b1) :\n    f (min n m) * f (max n m) = f n * f m", "start": [24, 1], "end": [26, 100], "kind": "commanddeclaration"}, {"full_name": "min_mul_max", "code": "@[to_additive]\ntheorem min_mul_max [LinearOrder \u03b1] [CommSemigroup \u03b1] (n m : \u03b1) : min n m * max n m = n * m", "start": [30, 1], "end": [32, 27], "kind": "commanddeclaration"}, {"full_name": "min_mul_mul_left", "code": "@[to_additive]\ntheorem min_mul_mul_left (a b c : \u03b1) : min (a * b) (a * c) = a * min b c", "start": [48, 1], "end": [50, 42], "kind": "commanddeclaration"}, {"full_name": "max_mul_mul_left", "code": "@[to_additive]\ntheorem max_mul_mul_left (a b c : \u03b1) : max (a * b) (a * c) = a * max b c", "start": [54, 1], "end": [56, 42], "kind": "commanddeclaration"}, {"full_name": "min_mul_mul_right", "code": "@[to_additive]\ntheorem min_mul_mul_right (a b c : \u03b1) : min (a * c) (b * c) = min a b * c", "start": [66, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "max_mul_mul_right", "code": "@[to_additive]\ntheorem max_mul_mul_right (a b c : \u03b1) : max (a * c) (b * c) = max a b * c", "start": [72, 1], "end": [74, 42], "kind": "commanddeclaration"}, {"full_name": "lt_or_lt_of_mul_lt_mul", "code": "@[to_additive]\ntheorem lt_or_lt_of_mul_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 * b\u2081 < a\u2082 * b\u2082 \u2192 a\u2081 < a\u2082 \u2228 b\u2081 < b\u2082", "start": [80, 1], "end": [85, 37], "kind": "commanddeclaration"}, {"full_name": "le_or_lt_of_mul_le_mul", "code": "@[to_additive]\ntheorem le_or_lt_of_mul_le_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 * b\u2081 \u2264 a\u2082 * b\u2082 \u2192 a\u2081 \u2264 a\u2082 \u2228 b\u2081 < b\u2082", "start": [89, 1], "end": [94, 48], "kind": "commanddeclaration"}, {"full_name": "lt_or_le_of_mul_le_mul", "code": "@[to_additive]\ntheorem lt_or_le_of_mul_le_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 * b\u2081 \u2264 a\u2082 * b\u2082 \u2192 a\u2081 < a\u2082 \u2228 b\u2081 \u2264 b\u2082", "start": [98, 1], "end": [103, 48], "kind": "commanddeclaration"}, {"full_name": "le_or_le_of_mul_le_mul", "code": "@[to_additive]\ntheorem le_or_le_of_mul_le_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 * b\u2081 \u2264 a\u2082 * b\u2082 \u2192 a\u2081 \u2264 a\u2082 \u2228 b\u2081 \u2264 b\u2082", "start": [107, 1], "end": [112, 48], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_iff_of_le_of_le", "code": "@[to_additive]\ntheorem mul_lt_mul_iff_of_le_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (ha : a\u2081 \u2264 a\u2082)\n    (hb : b\u2081 \u2264 b\u2082) : a\u2081 * b\u2081 < a\u2082 * b\u2082 \u2194 a\u2081 < a\u2082 \u2228 b\u2081 < b\u2082", "start": [116, 1], "end": [124, 40], "kind": "commanddeclaration"}, {"full_name": "min_le_mul_of_one_le_right", "code": "@[to_additive]\ntheorem min_le_mul_of_one_le_right [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (hb : 1 \u2264 b) :\n    min a b \u2264 a * b", "start": [132, 1], "end": [135, 55], "kind": "commanddeclaration"}, {"full_name": "min_le_mul_of_one_le_left", "code": "@[to_additive]\ntheorem min_le_mul_of_one_le_left [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1}\n    (ha : 1 \u2264 a) : min a b \u2264 a * b", "start": [139, 1], "end": [142, 54], "kind": "commanddeclaration"}, {"full_name": "max_le_mul_of_one_le", "code": "@[to_additive]\ntheorem max_le_mul_of_one_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n    max a b \u2264 a * b", "start": [146, 1], "end": [150, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Basic.lean", "imports": ["Mathlib/Data/Set/Prod.lean", "Mathlib/Order/MinMax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Ioo", "code": "def Ioo (a b : \u03b1) :=\n  { x | a < x \u2227 x < b }", "start": [43, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ico", "code": "def Ico (a b : \u03b1) :=\n  { x | a \u2264 x \u2227 x < b }", "start": [48, 1], "end": [50, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Iio", "code": "def Iio (a : \u03b1) :=\n  { x | x < a }", "start": [53, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "Set.Icc", "code": "def Icc (a b : \u03b1) :=\n  { x | a \u2264 x \u2227 x \u2264 b }", "start": [58, 1], "end": [60, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Iic", "code": "def Iic (b : \u03b1) :=\n  { x | x \u2264 b }", "start": [63, 1], "end": [65, 16], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc", "code": "def Ioc (a b : \u03b1) :=\n  { x | a < x \u2227 x \u2264 b }", "start": [68, 1], "end": [70, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ici", "code": "def Ici (a : \u03b1) :=\n  { x | a \u2264 x }", "start": [73, 1], "end": [75, 16], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi", "code": "def Ioi (a : \u03b1) :=\n  { x | a < x }", "start": [78, 1], "end": [80, 16], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_def", "code": "theorem Ioo_def (a b : \u03b1) : { x | a < x \u2227 x < b } = Ioo a b", "start": [83, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_def", "code": "theorem Ico_def (a b : \u03b1) : { x | a \u2264 x \u2227 x < b } = Ico a b", "start": [87, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_def", "code": "theorem Iio_def (a : \u03b1) : { x | x < a } = Iio a", "start": [91, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_def", "code": "theorem Icc_def (a b : \u03b1) : { x | a \u2264 x \u2227 x \u2264 b } = Icc a b", "start": [95, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_def", "code": "theorem Iic_def (b : \u03b1) : { x | x \u2264 b } = Iic b", "start": [99, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_def", "code": "theorem Ioc_def (a b : \u03b1) : { x | a < x \u2227 x \u2264 b } = Ioc a b", "start": [103, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_def", "code": "theorem Ici_def (a : \u03b1) : { x | a \u2264 x } = Ici a", "start": [107, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_def", "code": "theorem Ioi_def (a : \u03b1) : { x | a < x } = Ioi a", "start": [111, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ioo", "code": "@[simp]\ntheorem mem_Ioo : x \u2208 Ioo a b \u2194 a < x \u2227 x < b", "start": [115, 1], "end": [117, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ico", "code": "@[simp]\ntheorem mem_Ico : x \u2208 Ico a b \u2194 a \u2264 x \u2227 x < b", "start": [120, 1], "end": [122, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Iio", "code": "@[simp]\ntheorem mem_Iio : x \u2208 Iio b \u2194 x < b", "start": [125, 1], "end": [127, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc", "code": "@[simp]\ntheorem mem_Icc : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b", "start": [130, 1], "end": [132, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Iic", "code": "@[simp]\ntheorem mem_Iic : x \u2208 Iic b \u2194 x \u2264 b", "start": [135, 1], "end": [137, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ioc", "code": "@[simp]\ntheorem mem_Ioc : x \u2208 Ioc a b \u2194 a < x \u2227 x \u2264 b", "start": [140, 1], "end": [142, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ici", "code": "@[simp]\ntheorem mem_Ici : x \u2208 Ici a \u2194 a \u2264 x", "start": [145, 1], "end": [147, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ioi", "code": "@[simp]\ntheorem mem_Ioi : x \u2208 Ioi a \u2194 a < x", "start": [150, 1], "end": [152, 10], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIoo", "code": "instance decidableMemIoo [Decidable (a < x \u2227 x < b)] : Decidable (x \u2208 Ioo a b) := by assumption", "start": [155, 1], "end": [155, 96], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIco", "code": "instance decidableMemIco [Decidable (a \u2264 x \u2227 x < b)] : Decidable (x \u2208 Ico a b) := by assumption", "start": [158, 1], "end": [158, 96], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIio", "code": "instance decidableMemIio [Decidable (x < b)] : Decidable (x \u2208 Iio b) := by assumption", "start": [161, 1], "end": [161, 86], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIcc", "code": "instance decidableMemIcc [Decidable (a \u2264 x \u2227 x \u2264 b)] : Decidable (x \u2208 Icc a b) := by assumption", "start": [164, 1], "end": [164, 96], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIic", "code": "instance decidableMemIic [Decidable (x \u2264 b)] : Decidable (x \u2208 Iic b) := by assumption", "start": [167, 1], "end": [167, 86], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIoc", "code": "instance decidableMemIoc [Decidable (a < x \u2227 x \u2264 b)] : Decidable (x \u2208 Ioc a b) := by assumption", "start": [170, 1], "end": [170, 96], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIci", "code": "instance decidableMemIci [Decidable (a \u2264 x)] : Decidable (x \u2208 Ici a) := by assumption", "start": [173, 1], "end": [173, 86], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemIoi", "code": "instance decidableMemIoi [Decidable (a < x)] : Decidable (x \u2208 Ioi a) := by assumption", "start": [176, 1], "end": [176, 86], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_Ioo", "code": "theorem left_mem_Ioo : a \u2208 Ioo a b \u2194 False", "start": [181, 1], "end": [181, 66], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_Ico", "code": "theorem left_mem_Ico : a \u2208 Ico a b \u2194 a < b", "start": [186, 1], "end": [186, 64], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_Icc", "code": "theorem left_mem_Icc : a \u2208 Icc a b \u2194 a \u2264 b", "start": [191, 1], "end": [191, 64], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_Ioc", "code": "theorem left_mem_Ioc : a \u2208 Ioc a b \u2194 False", "start": [196, 1], "end": [196, 66], "kind": "commanddeclaration"}, {"full_name": "Set.left_mem_Ici", "code": "theorem left_mem_Ici : a \u2208 Ici a", "start": [199, 1], "end": [199, 44], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_Ioo", "code": "theorem right_mem_Ioo : b \u2208 Ioo a b \u2194 False", "start": [204, 1], "end": [204, 67], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_Ico", "code": "theorem right_mem_Ico : b \u2208 Ico a b \u2194 False", "start": [209, 1], "end": [209, 67], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_Icc", "code": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b", "start": [214, 1], "end": [214, 65], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_Ioc", "code": "theorem right_mem_Ioc : b \u2208 Ioc a b \u2194 a < b", "start": [219, 1], "end": [219, 65], "kind": "commanddeclaration"}, {"full_name": "Set.right_mem_Iic", "code": "theorem right_mem_Iic : a \u2208 Iic a", "start": [222, 1], "end": [222, 45], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Ici", "code": "@[simp]\ntheorem dual_Ici : Ici (toDual a) = ofDual \u207b\u00b9' Iic a", "start": [225, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Iic", "code": "@[simp]\ntheorem dual_Iic : Iic (toDual a) = ofDual \u207b\u00b9' Ici a", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Ioi", "code": "@[simp]\ntheorem dual_Ioi : Ioi (toDual a) = ofDual \u207b\u00b9' Iio a", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Iio", "code": "@[simp]\ntheorem dual_Iio : Iio (toDual a) = ofDual \u207b\u00b9' Ioi a", "start": [240, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Icc", "code": "@[simp]\ntheorem dual_Icc : Icc (toDual a) (toDual b) = ofDual \u207b\u00b9' Icc b a", "start": [245, 1], "end": [247, 28], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Ioc", "code": "@[simp]\ntheorem dual_Ioc : Ioc (toDual a) (toDual b) = ofDual \u207b\u00b9' Ico b a", "start": [250, 1], "end": [252, 28], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Ico", "code": "@[simp]\ntheorem dual_Ico : Ico (toDual a) (toDual b) = ofDual \u207b\u00b9' Ioc b a", "start": [255, 1], "end": [257, 28], "kind": "commanddeclaration"}, {"full_name": "Set.dual_Ioo", "code": "@[simp]\ntheorem dual_Ioo : Ioo (toDual a) (toDual b) = ofDual \u207b\u00b9' Ioo b a", "start": [260, 1], "end": [262, 28], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Icc", "code": "@[simp]\ntheorem nonempty_Icc : (Icc a b).Nonempty \u2194 a \u2264 b", "start": [265, 1], "end": [267, 67], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ico", "code": "@[simp]\ntheorem nonempty_Ico : (Ico a b).Nonempty \u2194 a < b", "start": [270, 1], "end": [272, 70], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioc", "code": "@[simp]\ntheorem nonempty_Ioc : (Ioc a b).Nonempty \u2194 a < b", "start": [275, 1], "end": [277, 71], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ici", "code": "@[simp]\ntheorem nonempty_Ici : (Ici a).Nonempty", "start": [280, 1], "end": [282, 20], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Iic", "code": "@[simp]\ntheorem nonempty_Iic : (Iic a).Nonempty", "start": [285, 1], "end": [287, 21], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioo", "code": "@[simp]\ntheorem nonempty_Ioo [DenselyOrdered \u03b1] : (Ioo a b).Nonempty \u2194 a < b", "start": [290, 1], "end": [292, 51], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioi", "code": "@[simp]\ntheorem nonempty_Ioi [NoMaxOrder \u03b1] : (Ioi a).Nonempty", "start": [295, 1], "end": [297, 14], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Iio", "code": "@[simp]\ntheorem nonempty_Iio [NoMinOrder \u03b1] : (Iio a).Nonempty", "start": [300, 1], "end": [302, 14], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Icc_subtype", "code": "theorem nonempty_Icc_subtype (h : a \u2264 b) : Nonempty (Icc a b)", "start": [305, 1], "end": [306, 43], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ico_subtype", "code": "theorem nonempty_Ico_subtype (h : a < b) : Nonempty (Ico a b)", "start": [309, 1], "end": [310, 43], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioc_subtype", "code": "theorem nonempty_Ioc_subtype (h : a < b) : Nonempty (Ioc a b)", "start": [313, 1], "end": [314, 43], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ici_subtype", "code": "instance nonempty_Ici_subtype : Nonempty (Ici a) :=\n  Nonempty.to_subtype nonempty_Ici", "start": [317, 1], "end": [319, 35], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Iic_subtype", "code": "instance nonempty_Iic_subtype : Nonempty (Iic a) :=\n  Nonempty.to_subtype nonempty_Iic", "start": [322, 1], "end": [324, 35], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioo_subtype", "code": "theorem nonempty_Ioo_subtype [DenselyOrdered \u03b1] (h : a < b) : Nonempty (Ioo a b)", "start": [327, 1], "end": [328, 43], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ioi_subtype", "code": "instance nonempty_Ioi_subtype [NoMaxOrder \u03b1] : Nonempty (Ioi a) :=\n  Nonempty.to_subtype nonempty_Ioi", "start": [331, 1], "end": [333, 35], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Iio_subtype", "code": "instance nonempty_Iio_subtype [NoMinOrder \u03b1] : Nonempty (Iio a) :=\n  Nonempty.to_subtype nonempty_Iio", "start": [336, 1], "end": [338, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_eq_empty", "code": "@[simp]\ntheorem Icc_eq_empty (h : \u00aca \u2264 b) : Icc a b = \u2205", "start": [357, 1], "end": [359, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_eq_empty", "code": "@[simp]\ntheorem Ico_eq_empty (h : \u00aca < b) : Ico a b = \u2205", "start": [362, 1], "end": [364, 69], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_eq_empty", "code": "@[simp]\ntheorem Ioc_eq_empty (h : \u00aca < b) : Ioc a b = \u2205", "start": [367, 1], "end": [369, 69], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_eq_empty", "code": "@[simp]\ntheorem Ioo_eq_empty (h : \u00aca < b) : Ioo a b = \u2205", "start": [372, 1], "end": [374, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_eq_empty_of_lt", "code": "@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = \u2205", "start": [377, 1], "end": [379, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_eq_empty_of_le", "code": "@[simp]\ntheorem Ico_eq_empty_of_le (h : b \u2264 a) : Ico a b = \u2205", "start": [382, 1], "end": [384, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_eq_empty_of_le", "code": "@[simp]\ntheorem Ioc_eq_empty_of_le (h : b \u2264 a) : Ioc a b = \u2205", "start": [387, 1], "end": [389, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_eq_empty_of_le", "code": "@[simp]\ntheorem Ioo_eq_empty_of_le (h : b \u2264 a) : Ioo a b = \u2205", "start": [392, 1], "end": [394, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_self", "code": "theorem Ico_self (a : \u03b1) : Ico a a = \u2205", "start": [399, 1], "end": [400, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_self", "code": "theorem Ioc_self (a : \u03b1) : Ioc a a = \u2205", "start": [405, 1], "end": [406, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_self", "code": "theorem Ioo_self (a : \u03b1) : Ioo a a = \u2205", "start": [411, 1], "end": [412, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_subset_Ici", "code": "theorem Ici_subset_Ici : Ici a \u2286 Ici b \u2194 b \u2264 a", "start": [415, 1], "end": [416, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_subset_Iic", "code": "theorem Iic_subset_Iic : Iic a \u2286 Iic b \u2194 a \u2264 b", "start": [419, 1], "end": [420, 28], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_subset_Ioi", "code": "theorem Ici_subset_Ioi : Ici a \u2286 Ioi b \u2194 b < a", "start": [423, 1], "end": [424, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_subset_Iio", "code": "theorem Iic_subset_Iio : Iic a \u2286 Iio b \u2194 a < b", "start": [427, 1], "end": [428, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioo", "code": "theorem Ioo_subset_Ioo (h\u2081 : a\u2082 \u2264 a\u2081) (h\u2082 : b\u2081 \u2264 b\u2082) : Ioo a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082", "start": [431, 1], "end": [432, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioo_left", "code": "theorem Ioo_subset_Ioo_left (h : a\u2081 \u2264 a\u2082) : Ioo a\u2082 b \u2286 Ioo a\u2081 b", "start": [435, 1], "end": [436, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioo_right", "code": "theorem Ioo_subset_Ioo_right (h : b\u2081 \u2264 b\u2082) : Ioo a b\u2081 \u2286 Ioo a b\u2082", "start": [439, 1], "end": [440, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ico", "code": "theorem Ico_subset_Ico (h\u2081 : a\u2082 \u2264 a\u2081) (h\u2082 : b\u2081 \u2264 b\u2082) : Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082", "start": [443, 1], "end": [444, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ico_left", "code": "theorem Ico_subset_Ico_left (h : a\u2081 \u2264 a\u2082) : Ico a\u2082 b \u2286 Ico a\u2081 b", "start": [447, 1], "end": [448, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ico_right", "code": "theorem Ico_subset_Ico_right (h : b\u2081 \u2264 b\u2082) : Ico a b\u2081 \u2286 Ico a b\u2082", "start": [451, 1], "end": [452, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc", "code": "theorem Icc_subset_Icc (h\u2081 : a\u2082 \u2264 a\u2081) (h\u2082 : b\u2081 \u2264 b\u2082) : Icc a\u2081 b\u2081 \u2286 Icc a\u2082 b\u2082", "start": [455, 1], "end": [456, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc_left", "code": "theorem Icc_subset_Icc_left (h : a\u2081 \u2264 a\u2082) : Icc a\u2082 b \u2286 Icc a\u2081 b", "start": [459, 1], "end": [460, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc_right", "code": "theorem Icc_subset_Icc_right (h : b\u2081 \u2264 b\u2082) : Icc a b\u2081 \u2286 Icc a b\u2082", "start": [463, 1], "end": [464, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ioo", "code": "theorem Icc_subset_Ioo (ha : a\u2082 < a\u2081) (hb : b\u2081 < b\u2082) : Icc a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082", "start": [467, 1], "end": [468, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ici_self", "code": "theorem Icc_subset_Ici_self : Icc a b \u2286 Ici a", "start": [471, 1], "end": [471, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Iic_self", "code": "theorem Icc_subset_Iic_self : Icc a b \u2286 Iic b", "start": [474, 1], "end": [474, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Iic_self", "code": "theorem Ioc_subset_Iic_self : Ioc a b \u2286 Iic b", "start": [477, 1], "end": [477, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc", "code": "theorem Ioc_subset_Ioc (h\u2081 : a\u2082 \u2264 a\u2081) (h\u2082 : b\u2081 \u2264 b\u2082) : Ioc a\u2081 b\u2081 \u2286 Ioc a\u2082 b\u2082", "start": [480, 1], "end": [481, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc_left", "code": "theorem Ioc_subset_Ioc_left (h : a\u2081 \u2264 a\u2082) : Ioc a\u2082 b \u2286 Ioc a\u2081 b", "start": [484, 1], "end": [485, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc_right", "code": "theorem Ioc_subset_Ioc_right (h : b\u2081 \u2264 b\u2082) : Ioc a b\u2081 \u2286 Ioc a b\u2082", "start": [488, 1], "end": [489, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ioo_left", "code": "theorem Ico_subset_Ioo_left (h\u2081 : a\u2081 < a\u2082) : Ico a\u2082 b \u2286 Ioo a\u2081 b", "start": [492, 1], "end": [493, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioo_right", "code": "theorem Ioc_subset_Ioo_right (h : b\u2081 < b\u2082) : Ioc a b\u2081 \u2286 Ioo a b\u2082", "start": [496, 1], "end": [497, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ico_right", "code": "theorem Icc_subset_Ico_right (h\u2081 : b\u2081 < b\u2082) : Icc a b\u2081 \u2286 Ico a b\u2082", "start": [500, 1], "end": [501, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ico_self", "code": "theorem Ioo_subset_Ico_self : Ioo a b \u2286 Ico a b", "start": [504, 1], "end": [504, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioc_self", "code": "theorem Ioo_subset_Ioc_self : Ioo a b \u2286 Ioc a b", "start": [507, 1], "end": [507, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Icc_self", "code": "theorem Ico_subset_Icc_self : Ico a b \u2286 Icc a b", "start": [510, 1], "end": [510, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Icc_self", "code": "theorem Ioc_subset_Icc_self : Ioc a b \u2286 Icc a b", "start": [513, 1], "end": [513, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Icc_self", "code": "theorem Ioo_subset_Icc_self : Ioo a b \u2286 Icc a b", "start": [516, 1], "end": [517, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Iio_self", "code": "theorem Ico_subset_Iio_self : Ico a b \u2286 Iio b", "start": [520, 1], "end": [520, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Iio_self", "code": "theorem Ioo_subset_Iio_self : Ioo a b \u2286 Iio b", "start": [523, 1], "end": [523, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioi_self", "code": "theorem Ioc_subset_Ioi_self : Ioc a b \u2286 Ioi a", "start": [526, 1], "end": [526, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioi_self", "code": "theorem Ioo_subset_Ioi_self : Ioo a b \u2286 Ioi a", "start": [529, 1], "end": [529, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ici_self", "code": "theorem Ioi_subset_Ici_self : Ioi a \u2286 Ici a", "start": [532, 1], "end": [532, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iic_self", "code": "theorem Iio_subset_Iic_self : Iio a \u2286 Iic a", "start": [535, 1], "end": [535, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ici_self", "code": "theorem Ico_subset_Ici_self : Ico a b \u2286 Ici a", "start": [538, 1], "end": [538, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_ssubset_Ici_self", "code": "theorem Ioi_ssubset_Ici_self : Ioi a \u2282 Ici a", "start": [541, 1], "end": [542, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_ssubset_Iic_self", "code": "theorem Iio_ssubset_Iic_self : Iio a \u2282 Iic a", "start": [545, 1], "end": [546, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc_iff", "code": "theorem Icc_subset_Icc_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Icc a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [549, 1], "end": [551, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ioo_iff", "code": "theorem Icc_subset_Ioo_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 < b\u2082", "start": [554, 1], "end": [556, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ico_iff", "code": "theorem Icc_subset_Ico_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 < b\u2082", "start": [559, 1], "end": [561, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ioc_iff", "code": "theorem Icc_subset_Ioc_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ioc a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [564, 1], "end": [566, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Iio_iff", "code": "theorem Icc_subset_Iio_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Iio b\u2082 \u2194 b\u2081 < b\u2082", "start": [569, 1], "end": [570, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ioi_iff", "code": "theorem Icc_subset_Ioi_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ioi a\u2082 \u2194 a\u2082 < a\u2081", "start": [573, 1], "end": [574, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Iic_iff", "code": "theorem Icc_subset_Iic_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Iic b\u2082 \u2194 b\u2081 \u2264 b\u2082", "start": [577, 1], "end": [578, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ici_iff", "code": "theorem Icc_subset_Ici_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ici a\u2082 \u2194 a\u2082 \u2264 a\u2081", "start": [581, 1], "end": [582, 59], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_ssubset_Icc_left", "code": "theorem Icc_ssubset_Icc_left (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 < a\u2081) (hb : b\u2081 \u2264 b\u2082) : Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082", "start": [585, 1], "end": [587, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_ssubset_Icc_right", "code": "theorem Icc_ssubset_Icc_right (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 < b\u2082) :\n    Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082", "start": [590, 1], "end": [593, 72], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ioi", "code": "theorem Ioi_subset_Ioi (h : a \u2264 b) : Ioi b \u2286 Ioi a", "start": [596, 1], "end": [598, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ici", "code": "theorem Ioi_subset_Ici (h : a \u2264 b) : Ioi b \u2286 Ici a", "start": [601, 1], "end": [604, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iio", "code": "theorem Iio_subset_Iio (h : a \u2264 b) : Iio a \u2286 Iio b", "start": [607, 1], "end": [609, 86], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iic", "code": "theorem Iio_subset_Iic (h : a \u2264 b) : Iio a \u2286 Iic b", "start": [612, 1], "end": [615, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_inter_Iic", "code": "theorem Ici_inter_Iic : Ici a \u2229 Iic b = Icc a b", "start": [618, 1], "end": [619, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_inter_Iio", "code": "theorem Ici_inter_Iio : Ici a \u2229 Iio b = Ico a b", "start": [622, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_inter_Iic", "code": "theorem Ioi_inter_Iic : Ioi a \u2229 Iic b = Ioc a b", "start": [626, 1], "end": [627, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_inter_Iio", "code": "theorem Ioi_inter_Iio : Ioi a \u2229 Iio b = Ioo a b", "start": [630, 1], "end": [631, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_inter_Ici", "code": "theorem Iic_inter_Ici : Iic a \u2229 Ici b = Icc b a", "start": [634, 1], "end": [635, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_inter_Ici", "code": "theorem Iio_inter_Ici : Iio a \u2229 Ici b = Ico b a", "start": [638, 1], "end": [639, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_inter_Ioi", "code": "theorem Iic_inter_Ioi : Iic a \u2229 Ioi b = Ioc b a", "start": [642, 1], "end": [643, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_inter_Ioi", "code": "theorem Iio_inter_Ioi : Iio a \u2229 Ioi b = Ioo b a", "start": [646, 1], "end": [647, 17], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc_of_Ioo", "code": "theorem mem_Icc_of_Ioo (h : x \u2208 Ioo a b) : x \u2208 Icc a b", "start": [650, 1], "end": [651, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ico_of_Ioo", "code": "theorem mem_Ico_of_Ioo (h : x \u2208 Ioo a b) : x \u2208 Ico a b", "start": [654, 1], "end": [655, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ioc_of_Ioo", "code": "theorem mem_Ioc_of_Ioo (h : x \u2208 Ioo a b) : x \u2208 Ioc a b", "start": [658, 1], "end": [659, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc_of_Ico", "code": "theorem mem_Icc_of_Ico (h : x \u2208 Ico a b) : x \u2208 Icc a b", "start": [662, 1], "end": [663, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc_of_Ioc", "code": "theorem mem_Icc_of_Ioc (h : x \u2208 Ioc a b) : x \u2208 Icc a b", "start": [666, 1], "end": [667, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ici_of_Ioi", "code": "theorem mem_Ici_of_Ioi (h : x \u2208 Ioi a) : x \u2208 Ici a", "start": [670, 1], "end": [671, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Iic_of_Iio", "code": "theorem mem_Iic_of_Iio (h : x \u2208 Iio a) : x \u2208 Iic a", "start": [674, 1], "end": [675, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_eq_empty_iff", "code": "theorem Icc_eq_empty_iff : Icc a b = \u2205 \u2194 \u00aca \u2264 b", "start": [678, 1], "end": [679, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_eq_empty_iff", "code": "theorem Ico_eq_empty_iff : Ico a b = \u2205 \u2194 \u00aca < b", "start": [682, 1], "end": [683, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_eq_empty_iff", "code": "theorem Ioc_eq_empty_iff : Ioc a b = \u2205 \u2194 \u00aca < b", "start": [686, 1], "end": [687, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_eq_empty_iff", "code": "theorem Ioo_eq_empty_iff [DenselyOrdered \u03b1] : Ioo a b = \u2205 \u2194 \u00aca < b", "start": [690, 1], "end": [691, 62], "kind": "commanddeclaration"}, {"full_name": "IsTop.Iic_eq", "code": "theorem _root_.IsTop.Iic_eq (h : IsTop a) : Iic a = univ", "start": [694, 1], "end": [695, 22], "kind": "commanddeclaration"}, {"full_name": "IsBot.Ici_eq", "code": "theorem _root_.IsBot.Ici_eq (h : IsBot a) : Ici a = univ", "start": [698, 1], "end": [699, 22], "kind": "commanddeclaration"}, {"full_name": "IsMax.Ioi_eq", "code": "theorem _root_.IsMax.Ioi_eq (h : IsMax a) : Ioi a = \u2205", "start": [702, 1], "end": [703, 45], "kind": "commanddeclaration"}, {"full_name": "IsMin.Iio_eq", "code": "theorem _root_.IsMin.Iio_eq (h : IsMin a) : Iio a = \u2205", "start": [706, 1], "end": [707, 45], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_inter_Ioc_of_le", "code": "theorem Iic_inter_Ioc_of_le (h : a \u2264 c) : Iic a \u2229 Ioc b c = Ioc b a", "start": [710, 1], "end": [711, 73], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Icc_of_lt", "code": "theorem not_mem_Icc_of_lt (ha : c < a) : c \u2209 Icc a b", "start": [714, 1], "end": [714, 79], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Icc_of_gt", "code": "theorem not_mem_Icc_of_gt (hb : b < c) : c \u2209 Icc a b", "start": [717, 1], "end": [717, 79], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ico_of_lt", "code": "theorem not_mem_Ico_of_lt (ha : c < a) : c \u2209 Ico a b", "start": [720, 1], "end": [720, 79], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioc_of_gt", "code": "theorem not_mem_Ioc_of_gt (hb : b < c) : c \u2209 Ioc a b", "start": [723, 1], "end": [723, 79], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioi_self", "code": "theorem not_mem_Ioi_self : a \u2209 Ioi a", "start": [728, 1], "end": [728, 52], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Iio_self", "code": "theorem not_mem_Iio_self : b \u2209 Iio b", "start": [733, 1], "end": [733, 52], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioc_of_le", "code": "theorem not_mem_Ioc_of_le (ha : c \u2264 a) : c \u2209 Ioc a b", "start": [736, 1], "end": [736, 96], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ico_of_ge", "code": "theorem not_mem_Ico_of_ge (hb : b \u2264 c) : c \u2209 Ico a b", "start": [739, 1], "end": [739, 96], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioo_of_le", "code": "theorem not_mem_Ioo_of_le (ha : c \u2264 a) : c \u2209 Ioo a b", "start": [742, 1], "end": [742, 96], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioo_of_ge", "code": "theorem not_mem_Ioo_of_ge (hb : b \u2264 c) : c \u2209 Ioo a b", "start": [745, 1], "end": [745, 96], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_self", "code": "@[simp]\ntheorem Icc_self (a : \u03b1) : Icc a a = {a}", "start": [754, 1], "end": [756, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_eq_singleton_iff", "code": "@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} \u2194 a = c \u2227 b = c", "start": [759, 1], "end": [767, 21], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_Icc_of_ge", "code": "lemma subsingleton_Icc_of_ge (hba : b \u2264 a) : Set.Subsingleton (Icc a b) :=\n  fun _x \u27e8hax, hxb\u27e9 _y \u27e8hay, hyb\u27e9 \u21a6 le_antisymm\n    (le_implies_le_of_le_of_le hxb hay hba) (le_implies_le_of_le_of_le hyb hax hba)", "start": [770, 1], "end": [772, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Set.subsingleton_Icc_iff", "code": "@[simp] lemma subsingleton_Icc_iff {\u03b1 : Type*} [LinearOrder \u03b1] {a b : \u03b1} :\n    Set.Subsingleton (Icc a b) \u2194 b \u2264 a := by\n  refine' \u27e8fun h \u21a6 _, subsingleton_Icc_of_ge\u27e9\n  contrapose! h\n  simp only [ge_iff_le, gt_iff_lt, not_subsingleton_iff]\n  exact \u27e8a, \u27e8le_refl _, h.le\u27e9, b, \u27e8h.le, le_refl _\u27e9, h.ne\u27e9", "start": [775, 1], "end": [780, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc_diff_left", "code": "@[simp]\ntheorem Icc_diff_left : Icc a b \\ {a} = Ioc a b", "start": [782, 1], "end": [784, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_right", "code": "@[simp]\ntheorem Icc_diff_right : Icc a b \\ {b} = Ico a b", "start": [787, 1], "end": [789, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_diff_left", "code": "@[simp]\ntheorem Ico_diff_left : Ico a b \\ {a} = Ioo a b", "start": [792, 1], "end": [794, 69], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_diff_right", "code": "@[simp]\ntheorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b", "start": [797, 1], "end": [799, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_both", "code": "@[simp]\ntheorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b", "start": [802, 1], "end": [804, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_diff_left", "code": "@[simp]\ntheorem Ici_diff_left : Ici a \\ {a} = Ioi a", "start": [807, 1], "end": [809, 51], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_diff_right", "code": "@[simp]\ntheorem Iic_diff_right : Iic a \\ {a} = Iio a", "start": [812, 1], "end": [814, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_diff_Ioo_same", "code": "@[simp]\ntheorem Ico_diff_Ioo_same (h : a < b) : Ico a b \\ Ioo a b = {a}", "start": [817, 1], "end": [819, 91], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_diff_Ioo_same", "code": "@[simp]\ntheorem Ioc_diff_Ioo_same (h : a < b) : Ioc a b \\ Ioo a b = {b}", "start": [822, 1], "end": [824, 93], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_Ico_same", "code": "@[simp]\ntheorem Icc_diff_Ico_same (h : a \u2264 b) : Icc a b \\ Ico a b = {b}", "start": [827, 1], "end": [829, 93], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_Ioc_same", "code": "@[simp]\ntheorem Icc_diff_Ioc_same (h : a \u2264 b) : Icc a b \\ Ioc a b = {a}", "start": [832, 1], "end": [834, 91], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_Ioo_same", "code": "@[simp]\ntheorem Icc_diff_Ioo_same (h : a \u2264 b) : Icc a b \\ Ioo a b = {a, b}", "start": [837, 1], "end": [840, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_diff_Ioi_same", "code": "@[simp]\ntheorem Ici_diff_Ioi_same : Ici a \\ Ioi a = {a}", "start": [843, 1], "end": [845, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_diff_Iio_same", "code": "@[simp]\ntheorem Iic_diff_Iio_same : Iic a \\ Iio a = {a}", "start": [848, 1], "end": [850, 86], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_union_left", "code": "theorem Ioi_union_left : Ioi a \u222a {a} = Ici a", "start": [855, 1], "end": [856, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_right", "code": "theorem Iio_union_right : Iio a \u222a {a} = Iic a", "start": [861, 1], "end": [862, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_left", "code": "theorem Ioo_union_left (hab : a < b) : Ioo a b \u222a {a} = Ico a b", "start": [865, 1], "end": [867, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_right", "code": "theorem Ioo_union_right (hab : a < b) : Ioo a b \u222a {b} = Ioc a b", "start": [870, 1], "end": [871, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_both", "code": "theorem Ioo_union_both (h : a \u2264 b) : Ioo a b \u222a {a, b} = Icc a b", "start": [874, 1], "end": [878, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_left", "code": "theorem Ioc_union_left (hab : a \u2264 b) : Ioc a b \u222a {a} = Icc a b", "start": [880, 1], "end": [882, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_right", "code": "theorem Ico_union_right (hab : a \u2264 b) : Ico a b \u222a {b} = Icc a b", "start": [885, 1], "end": [886, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_insert_right", "code": "@[simp]\ntheorem Ico_insert_right (h : a \u2264 b) : insert b (Ico a b) = Icc a b", "start": [889, 1], "end": [891, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_insert_left", "code": "@[simp]\ntheorem Ioc_insert_left (h : a \u2264 b) : insert a (Ioc a b) = Icc a b", "start": [894, 1], "end": [896, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_insert_left", "code": "@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b", "start": [899, 1], "end": [901, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_insert_right", "code": "@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b", "start": [904, 1], "end": [906, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_insert", "code": "@[simp]\ntheorem Iio_insert : insert a (Iio a) = Iic a", "start": [909, 1], "end": [911, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_insert", "code": "@[simp]\ntheorem Ioi_insert : insert a (Ioi a) = Ici a", "start": [914, 1], "end": [916, 66], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Ici_Ioi_of_subset_of_subset", "code": "theorem mem_Ici_Ioi_of_subset_of_subset {s : Set \u03b1} (ho : Ioi a \u2286 s) (hc : s \u2286 Ici a) :\n    s \u2208 ({Ici a, Ioi a} : Set (Set \u03b1))", "start": [919, 1], "end": [925, 100], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Iic_Iio_of_subset_of_subset", "code": "theorem mem_Iic_Iio_of_subset_of_subset {s : Set \u03b1} (ho : Iio a \u2286 s) (hc : s \u2286 Iic a) :\n    s \u2208 ({Iic a, Iio a} : Set (Set \u03b1))", "start": [928, 1], "end": [930, 51], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset", "code": "theorem mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset {s : Set \u03b1} (ho : Ioo a b \u2286 s) (hc : s \u2286 Icc a b) :\n    s \u2208 ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set \u03b1))", "start": [933, 1], "end": [950, 42], "kind": "commanddeclaration"}, {"full_name": "Set.eq_left_or_mem_Ioo_of_mem_Ico", "code": "theorem eq_left_or_mem_Ioo_of_mem_Ico {x : \u03b1} (hmem : x \u2208 Ico a b) : x = a \u2228 x \u2208 Ioo a b", "start": [953, 1], "end": [954, 49], "kind": "commanddeclaration"}, {"full_name": "Set.eq_right_or_mem_Ioo_of_mem_Ioc", "code": "theorem eq_right_or_mem_Ioo_of_mem_Ioc {x : \u03b1} (hmem : x \u2208 Ioc a b) : x = b \u2228 x \u2208 Ioo a b", "start": [957, 1], "end": [958, 48], "kind": "commanddeclaration"}, {"full_name": "Set.eq_endpoints_or_mem_Ioo_of_mem_Icc", "code": "theorem eq_endpoints_or_mem_Ioo_of_mem_Icc {x : \u03b1} (hmem : x \u2208 Icc a b) :\n    x = a \u2228 x = b \u2228 x \u2208 Ioo a b", "start": [961, 1], "end": [963, 80], "kind": "commanddeclaration"}, {"full_name": "IsMax.Ici_eq", "code": "theorem _root_.IsMax.Ici_eq (h : IsMax a) : Ici a = {a}", "start": [966, 1], "end": [967, 68], "kind": "commanddeclaration"}, {"full_name": "IsMin.Iic_eq", "code": "theorem _root_.IsMin.Iic_eq (h : IsMin a) : Iic a = {a}", "start": [970, 1], "end": [971, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_injective", "code": "theorem Ici_injective : Injective (Ici : \u03b1 \u2192 Set \u03b1)", "start": [974, 1], "end": [975, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_injective", "code": "theorem Iic_injective : Injective (Iic : \u03b1 \u2192 Set \u03b1)", "start": [978, 1], "end": [979, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_inj", "code": "theorem Ici_inj : Ici a = Ici b \u2194 a = b", "start": [982, 1], "end": [983, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_inj", "code": "theorem Iic_inj : Iic a = Iic b \u2194 a = b", "start": [986, 1], "end": [987, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_top", "code": "@[simp]\ntheorem Ici_top [PartialOrder \u03b1] [OrderTop \u03b1] : Ici (\u22a4 : \u03b1) = {\u22a4}", "start": [994, 1], "end": [996, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_top", "code": "@[simp]\ntheorem Ioi_top : Ioi (\u22a4 : \u03b1) = \u2205", "start": [1001, 1], "end": [1003, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_top", "code": "@[simp]\ntheorem Iic_top : Iic (\u22a4 : \u03b1) = univ", "start": [1006, 1], "end": [1008, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_top", "code": "@[simp]\ntheorem Icc_top : Icc a \u22a4 = Ici a", "start": [1011, 1], "end": [1012, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_top", "code": "@[simp]\ntheorem Ioc_top : Ioc a \u22a4 = Ioi a", "start": [1015, 1], "end": [1016, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_bot", "code": "@[simp]\ntheorem Iic_bot [PartialOrder \u03b1] [OrderBot \u03b1] : Iic (\u22a5 : \u03b1) = {\u22a5}", "start": [1023, 1], "end": [1025, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_bot", "code": "@[simp]\ntheorem Iio_bot : Iio (\u22a5 : \u03b1) = \u2205", "start": [1030, 1], "end": [1032, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_bot", "code": "@[simp]\ntheorem Ici_bot : Ici (\u22a5 : \u03b1) = univ", "start": [1035, 1], "end": [1037, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_bot", "code": "@[simp]\ntheorem Icc_bot : Icc \u22a5 a = Iic a", "start": [1040, 1], "end": [1041, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_bot", "code": "@[simp]\ntheorem Ico_bot : Ico \u22a5 a = Iio a", "start": [1044, 1], "end": [1045, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_bot_top", "code": "theorem Icc_bot_top [PartialOrder \u03b1] [BoundedOrder \u03b1] : Icc (\u22a5 : \u03b1) \u22a4 = univ", "start": [1050, 1], "end": [1050, 88], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ici", "code": "theorem not_mem_Ici : c \u2209 Ici a \u2194 c < a", "start": [1057, 1], "end": [1058, 9], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Iic", "code": "theorem not_mem_Iic : c \u2209 Iic b \u2194 b < c", "start": [1061, 1], "end": [1062, 9], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Ioi", "code": "theorem not_mem_Ioi : c \u2209 Ioi a \u2194 c \u2264 a", "start": [1065, 1], "end": [1066, 9], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_Iio", "code": "theorem not_mem_Iio : c \u2209 Iio b \u2194 b \u2264 c", "start": [1069, 1], "end": [1070, 9], "kind": "commanddeclaration"}, {"full_name": "Set.compl_Iic", "code": "@[simp]\ntheorem compl_Iic : (Iic a)\u1d9c = Ioi a", "start": [1073, 1], "end": [1075, 22], "kind": "commanddeclaration"}, {"full_name": "Set.compl_Ici", "code": "@[simp]\ntheorem compl_Ici : (Ici a)\u1d9c = Iio a", "start": [1078, 1], "end": [1080, 22], "kind": "commanddeclaration"}, {"full_name": "Set.compl_Iio", "code": "@[simp]\ntheorem compl_Iio : (Iio a)\u1d9c = Ici a", "start": [1083, 1], "end": [1085, 22], "kind": "commanddeclaration"}, {"full_name": "Set.compl_Ioi", "code": "@[simp]\ntheorem compl_Ioi : (Ioi a)\u1d9c = Iic a", "start": [1088, 1], "end": [1090, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_diff_Ici", "code": "@[simp]\ntheorem Ici_diff_Ici : Ici a \\ Ici b = Ico a b", "start": [1093, 1], "end": [1094, 92], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_diff_Ioi", "code": "@[simp]\ntheorem Ici_diff_Ioi : Ici a \\ Ioi b = Icc a b", "start": [1097, 1], "end": [1098, 92], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_diff_Ioi", "code": "@[simp]\ntheorem Ioi_diff_Ioi : Ioi a \\ Ioi b = Ioc a b", "start": [1101, 1], "end": [1102, 92], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_diff_Ici", "code": "@[simp]\ntheorem Ioi_diff_Ici : Ioi a \\ Ici b = Ioo a b", "start": [1105, 1], "end": [1106, 92], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_diff_Iic", "code": "@[simp]\ntheorem Iic_diff_Iic : Iic b \\ Iic a = Ioc a b", "start": [1109, 1], "end": [1111, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_diff_Iic", "code": "@[simp]\ntheorem Iio_diff_Iic : Iio b \\ Iic a = Ioo a b", "start": [1114, 1], "end": [1116, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_diff_Iio", "code": "@[simp]\ntheorem Iic_diff_Iio : Iic b \\ Iio a = Icc a b", "start": [1119, 1], "end": [1121, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_diff_Iio", "code": "@[simp]\ntheorem Iio_diff_Iio : Iio b \\ Iio a = Ico a b", "start": [1124, 1], "end": [1126, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_injective", "code": "theorem Ioi_injective : Injective (Ioi : \u03b1 \u2192 Set \u03b1)", "start": [1129, 1], "end": [1130, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_injective", "code": "theorem Iio_injective : Injective (Iio : \u03b1 \u2192 Set \u03b1)", "start": [1133, 1], "end": [1134, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_inj", "code": "theorem Ioi_inj : Ioi a = Ioi b \u2194 a = b", "start": [1137, 1], "end": [1138, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_inj", "code": "theorem Iio_inj : Iio a = Iio b \u2194 a = b", "start": [1141, 1], "end": [1142, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ico_iff", "code": "theorem Ico_subset_Ico_iff (h\u2081 : a\u2081 < b\u2081) : Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [1145, 1], "end": [1149, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc_iff", "code": "theorem Ioc_subset_Ioc_iff (h\u2081 : a\u2081 < b\u2081) : Ioc a\u2081 b\u2081 \u2286 Ioc a\u2082 b\u2082 \u2194 b\u2081 \u2264 b\u2082 \u2227 a\u2082 \u2264 a\u2081", "start": [1152, 1], "end": [1153, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioo_iff", "code": "theorem Ioo_subset_Ioo_iff [DenselyOrdered \u03b1] (h\u2081 : a\u2081 < b\u2081) :\n    Ioo a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [1156, 1], "end": [1165, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_eq_Ico_iff", "code": "theorem Ico_eq_Ico_iff (h : a\u2081 < b\u2081 \u2228 a\u2082 < b\u2082) : Ico a\u2081 b\u2081 = Ico a\u2082 b\u2082 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082", "start": [1168, 1], "end": [1178, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_eq_singleton_iff_isTop", "code": "lemma Ici_eq_singleton_iff_isTop {x : \u03b1} : (Ici x = {x}) \u2194 IsTop x := by\n  refine \u27e8fun h y \u21a6 ?_, fun h \u21a6 by ext y; simp [(h y).ge_iff_eq]\u27e9\n  by_contra H\n  push_neg at H\n  have : y \u2208 Ici x := H.le\n  rw [h, mem_singleton_iff] at this\n  exact lt_irrefl y (this.le.trans_lt H)", "start": [1181, 1], "end": [1187, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Ioi_subset_Ioi_iff", "code": "@[simp]\ntheorem Ioi_subset_Ioi_iff : Ioi b \u2286 Ioi a \u2194 a \u2264 b", "start": [1191, 1], "end": [1195, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ici_iff", "code": "@[simp]\ntheorem Ioi_subset_Ici_iff [DenselyOrdered \u03b1] : Ioi b \u2286 Ici a \u2194 a \u2264 b", "start": [1198, 1], "end": [1203, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iio_iff", "code": "@[simp]\ntheorem Iio_subset_Iio_iff : Iio a \u2286 Iio b \u2194 a \u2264 b", "start": [1206, 1], "end": [1210, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iic_iff", "code": "@[simp]\ntheorem Iio_subset_Iic_iff [DenselyOrdered \u03b1] : Iio a \u2286 Iic b \u2194 a \u2264 b", "start": [1213, 1], "end": [1215, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioi_of_le", "code": "theorem Iic_union_Ioi_of_le (h : a \u2264 b) : Iic b \u222a Ioi a = univ", "start": [1224, 1], "end": [1225, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ici_of_le", "code": "theorem Iio_union_Ici_of_le (h : a \u2264 b) : Iio b \u222a Ici a = univ", "start": [1228, 1], "end": [1229, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ici_of_le", "code": "theorem Iic_union_Ici_of_le (h : a \u2264 b) : Iic b \u222a Ici a = univ", "start": [1232, 1], "end": [1233, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ioi_of_lt", "code": "theorem Iio_union_Ioi_of_lt (h : a < b) : Iio b \u222a Ioi a = univ", "start": [1236, 1], "end": [1237, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ici", "code": "@[simp]\ntheorem Iic_union_Ici : Iic a \u222a Ici a = univ", "start": [1240, 1], "end": [1242, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ici", "code": "@[simp]\ntheorem Iio_union_Ici : Iio a \u222a Ici a = univ", "start": [1245, 1], "end": [1247, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioi", "code": "@[simp]\ntheorem Iic_union_Ioi : Iic a \u222a Ioi a = univ", "start": [1250, 1], "end": [1252, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ioi", "code": "@[simp]\ntheorem Iio_union_Ioi : Iio a \u222a Ioi a = {a}\u1d9c", "start": [1255, 1], "end": [1257, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ioi'", "code": "theorem Ioo_union_Ioi' (h\u2081 : c < b) : Ioo a b \u222a Ioi c = Ioi (min a c)", "start": [1263, 1], "end": [1269, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ioi", "code": "theorem Ioo_union_Ioi (h : c < max a b) : Ioo a b \u222a Ioi c = Ioi (min a c)", "start": [1272, 1], "end": [1276, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ioo_union_Ici", "code": "theorem Ioi_subset_Ioo_union_Ici : Ioi a \u2286 Ioo a b \u222a Ici b", "start": [1279, 1], "end": [1280, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ici_eq_Ioi", "code": "@[simp]\ntheorem Ioo_union_Ici_eq_Ioi (h : a < b) : Ioo a b \u222a Ici b = Ioi a", "start": [1283, 1], "end": [1285, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_subset_Ico_union_Ici", "code": "theorem Ici_subset_Ico_union_Ici : Ici a \u2286 Ico a b \u222a Ici b", "start": [1288, 1], "end": [1289, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ici_eq_Ici", "code": "@[simp]\ntheorem Ico_union_Ici_eq_Ici (h : a \u2264 b) : Ico a b \u222a Ici b = Ici a", "start": [1292, 1], "end": [1294, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ici'", "code": "theorem Ico_union_Ici' (h\u2081 : c \u2264 b) : Ico a b \u222a Ici c = Ici (min a c)", "start": [1297, 1], "end": [1303, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ici", "code": "theorem Ico_union_Ici (h : c \u2264 max a b) : Ico a b \u222a Ici c = Ici (min a c)", "start": [1306, 1], "end": [1309, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ioc_union_Ioi", "code": "theorem Ioi_subset_Ioc_union_Ioi : Ioi a \u2286 Ioc a b \u222a Ioi b", "start": [1312, 1], "end": [1313, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioi_eq_Ioi", "code": "@[simp]\ntheorem Ioc_union_Ioi_eq_Ioi (h : a \u2264 b) : Ioc a b \u222a Ioi b = Ioi a", "start": [1316, 1], "end": [1318, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioi'", "code": "theorem Ioc_union_Ioi' (h\u2081 : c \u2264 b) : Ioc a b \u222a Ioi c = Ioi (min a c)", "start": [1321, 1], "end": [1327, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioi", "code": "theorem Ioc_union_Ioi (h : c \u2264 max a b) : Ioc a b \u222a Ioi c = Ioi (min a c)", "start": [1330, 1], "end": [1333, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_subset_Icc_union_Ioi", "code": "theorem Ici_subset_Icc_union_Ioi : Ici a \u2286 Icc a b \u222a Ioi b", "start": [1336, 1], "end": [1337, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ioi_eq_Ici", "code": "@[simp]\ntheorem Icc_union_Ioi_eq_Ici (h : a \u2264 b) : Icc a b \u222a Ioi b = Ici a", "start": [1340, 1], "end": [1343, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_subset_Ioc_union_Ici", "code": "theorem Ioi_subset_Ioc_union_Ici : Ioi a \u2286 Ioc a b \u222a Ici b", "start": [1346, 1], "end": [1347, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ici_eq_Ioi", "code": "@[simp]\ntheorem Ioc_union_Ici_eq_Ioi (h : a < b) : Ioc a b \u222a Ici b = Ioi a", "start": [1350, 1], "end": [1352, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_subset_Icc_union_Ici", "code": "theorem Ici_subset_Icc_union_Ici : Ici a \u2286 Icc a b \u222a Ici b", "start": [1355, 1], "end": [1356, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ici_eq_Ici", "code": "@[simp]\ntheorem Icc_union_Ici_eq_Ici (h : a \u2264 b) : Icc a b \u222a Ici b = Ici a", "start": [1359, 1], "end": [1361, 82], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ici'", "code": "theorem Icc_union_Ici' (h\u2081 : c \u2264 b) : Icc a b \u222a Ici c = Ici (min a c)", "start": [1364, 1], "end": [1370, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ici", "code": "theorem Icc_union_Ici (h : c \u2264 max a b) : Icc a b \u222a Ici c = Ici (min a c)", "start": [1373, 1], "end": [1379, 15], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_subset_Iio_union_Icc", "code": "theorem Iic_subset_Iio_union_Icc : Iic b \u2286 Iio a \u222a Icc a b", "start": [1385, 1], "end": [1386, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Icc_eq_Iic", "code": "@[simp]\ntheorem Iio_union_Icc_eq_Iic (h : a \u2264 b) : Iio a \u222a Icc a b = Iic b", "start": [1389, 1], "end": [1392, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iio_union_Ico", "code": "theorem Iio_subset_Iio_union_Ico : Iio b \u2286 Iio a \u222a Ico a b", "start": [1395, 1], "end": [1396, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ico_eq_Iio", "code": "@[simp]\ntheorem Iio_union_Ico_eq_Iio (h : a \u2264 b) : Iio a \u222a Ico a b = Iio b", "start": [1399, 1], "end": [1402, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ico'", "code": "theorem Iio_union_Ico' (h\u2081 : c \u2264 b) : Iio b \u222a Ico c d = Iio (max b d)", "start": [1405, 1], "end": [1411, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ico", "code": "theorem Iio_union_Ico (h : min c d \u2264 b) : Iio b \u222a Ico c d = Iio (max b d)", "start": [1414, 1], "end": [1417, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_subset_Iic_union_Ioc", "code": "theorem Iic_subset_Iic_union_Ioc : Iic b \u2286 Iic a \u222a Ioc a b", "start": [1420, 1], "end": [1421, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioc_eq_Iic", "code": "@[simp]\ntheorem Iic_union_Ioc_eq_Iic (h : a \u2264 b) : Iic a \u222a Ioc a b = Iic b", "start": [1424, 1], "end": [1427, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioc'", "code": "theorem Iic_union_Ioc' (h\u2081 : c < b) : Iic b \u222a Ioc c d = Iic (max b d)", "start": [1430, 1], "end": [1436, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioc", "code": "theorem Iic_union_Ioc (h : min c d < b) : Iic b \u222a Ioc c d = Iic (max b d)", "start": [1439, 1], "end": [1443, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iic_union_Ioo", "code": "theorem Iio_subset_Iic_union_Ioo : Iio b \u2286 Iic a \u222a Ioo a b", "start": [1446, 1], "end": [1447, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ioo_eq_Iio", "code": "@[simp]\ntheorem Iic_union_Ioo_eq_Iio (h : a < b) : Iic a \u222a Ioo a b = Iio b", "start": [1450, 1], "end": [1453, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ioo'", "code": "theorem Iio_union_Ioo' (h\u2081 : c < b) : Iio b \u222a Ioo c d = Iio (max b d)", "start": [1456, 1], "end": [1462, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_union_Ioo", "code": "theorem Iio_union_Ioo (h : min c d < b) : Iio b \u222a Ioo c d = Iio (max b d)", "start": [1465, 1], "end": [1469, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_subset_Iic_union_Icc", "code": "theorem Iic_subset_Iic_union_Icc : Iic b \u2286 Iic a \u222a Icc a b", "start": [1472, 1], "end": [1473, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Icc_eq_Iic", "code": "@[simp]\ntheorem Iic_union_Icc_eq_Iic (h : a \u2264 b) : Iic a \u222a Icc a b = Iic b", "start": [1476, 1], "end": [1479, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Icc'", "code": "theorem Iic_union_Icc' (h\u2081 : c \u2264 b) : Iic b \u222a Icc c d = Iic (max b d)", "start": [1482, 1], "end": [1488, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Icc", "code": "theorem Iic_union_Icc (h : min c d \u2264 b) : Iic b \u222a Icc c d = Iic (max b d)", "start": [1491, 1], "end": [1497, 15], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_subset_Iic_union_Ico", "code": "theorem Iio_subset_Iic_union_Ico : Iio b \u2286 Iic a \u222a Ico a b", "start": [1500, 1], "end": [1501, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_union_Ico_eq_Iio", "code": "@[simp]\ntheorem Iic_union_Ico_eq_Iio (h : a < b) : Iic a \u222a Ico a b = Iio b", "start": [1504, 1], "end": [1507, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioo_union_Ico", "code": "theorem Ioo_subset_Ioo_union_Ico : Ioo a c \u2286 Ioo a b \u222a Ico b c", "start": [1513, 1], "end": [1514, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ico_eq_Ioo", "code": "@[simp]\ntheorem Ioo_union_Ico_eq_Ioo (h\u2081 : a < b) (h\u2082 : b \u2264 c) : Ioo a b \u222a Ico b c = Ioo a c", "start": [1517, 1], "end": [1521, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Ico_union_Ico", "code": "theorem Ico_subset_Ico_union_Ico : Ico a c \u2286 Ico a b \u222a Ico b c", "start": [1524, 1], "end": [1525, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ico_eq_Ico", "code": "@[simp]\ntheorem Ico_union_Ico_eq_Ico (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : Ico a b \u222a Ico b c = Ico a c", "start": [1528, 1], "end": [1532, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ico'", "code": "theorem Ico_union_Ico' (h\u2081 : c \u2264 b) (h\u2082 : a \u2264 d) : Ico a b \u222a Ico c d = Ico (min a c) (max b d)", "start": [1535, 1], "end": [1544, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Ico", "code": "theorem Ico_union_Ico (h\u2081 : min a b \u2264 max c d) (h\u2082 : min c d \u2264 max a b) :\n    Ico a b \u222a Ico c d = Ico (min a c) (max b d)", "start": [1547, 1], "end": [1551, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Ico_union_Icc", "code": "theorem Icc_subset_Ico_union_Icc : Icc a c \u2286 Ico a b \u222a Icc b c", "start": [1554, 1], "end": [1555, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_union_Icc_eq_Icc", "code": "@[simp]\ntheorem Ico_union_Icc_eq_Icc (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : Ico a b \u222a Icc b c = Icc a c", "start": [1558, 1], "end": [1562, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioo_union_Icc", "code": "theorem Ioc_subset_Ioo_union_Icc : Ioc a c \u2286 Ioo a b \u222a Icc b c", "start": [1565, 1], "end": [1566, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Icc_eq_Ioc", "code": "@[simp]\ntheorem Ioo_union_Icc_eq_Ioc (h\u2081 : a < b) (h\u2082 : b \u2264 c) : Ioo a b \u222a Icc b c = Ioc a c", "start": [1569, 1], "end": [1573, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioc_union_Ioo", "code": "theorem Ioo_subset_Ioc_union_Ioo : Ioo a c \u2286 Ioc a b \u222a Ioo b c", "start": [1579, 1], "end": [1580, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioo_eq_Ioo", "code": "@[simp]\ntheorem Ioc_union_Ioo_eq_Ioo (h\u2081 : a \u2264 b) (h\u2082 : b < c) : Ioc a b \u222a Ioo b c = Ioo a c", "start": [1583, 1], "end": [1587, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Icc_union_Ioo", "code": "theorem Ico_subset_Icc_union_Ioo : Ico a c \u2286 Icc a b \u222a Ioo b c", "start": [1590, 1], "end": [1591, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ioo_eq_Ico", "code": "@[simp]\ntheorem Icc_union_Ioo_eq_Ico (h\u2081 : a \u2264 b) (h\u2082 : b < c) : Icc a b \u222a Ioo b c = Ico a c", "start": [1594, 1], "end": [1598, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc_union_Ioc", "code": "theorem Icc_subset_Icc_union_Ioc : Icc a c \u2286 Icc a b \u222a Ioc b c", "start": [1601, 1], "end": [1602, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ioc_eq_Icc", "code": "@[simp]\ntheorem Icc_union_Ioc_eq_Icc (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : Icc a b \u222a Ioc b c = Icc a c", "start": [1605, 1], "end": [1609, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc_union_Ioc", "code": "theorem Ioc_subset_Ioc_union_Ioc : Ioc a c \u2286 Ioc a b \u222a Ioc b c", "start": [1612, 1], "end": [1613, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc_eq_Ioc", "code": "@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : Ioc a b \u222a Ioc b c = Ioc a c", "start": [1616, 1], "end": [1620, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc'", "code": "theorem Ioc_union_Ioc' (h\u2081 : c \u2264 b) (h\u2082 : a \u2264 d) : Ioc a b \u222a Ioc c d = Ioc (min a c) (max b d)", "start": [1623, 1], "end": [1632, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc", "code": "theorem Ioc_union_Ioc (h\u2081 : min a b \u2264 max c d) (h\u2082 : min c d \u2264 max a b) :\n    Ioc a b \u222a Ioc c d = Ioc (min a c) (max b d)", "start": [1635, 1], "end": [1639, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_subset_Ioc_union_Ico", "code": "theorem Ioo_subset_Ioc_union_Ico : Ioo a c \u2286 Ioc a b \u222a Ico b c", "start": [1645, 1], "end": [1646, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ico_eq_Ioo", "code": "@[simp]\ntheorem Ioc_union_Ico_eq_Ioo (h\u2081 : a < b) (h\u2082 : b < c) : Ioc a b \u222a Ico b c = Ioo a c", "start": [1649, 1], "end": [1654, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_subset_Icc_union_Ico", "code": "theorem Ico_subset_Icc_union_Ico : Ico a c \u2286 Icc a b \u222a Ico b c", "start": [1657, 1], "end": [1658, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Ico_eq_Ico", "code": "@[simp]\ntheorem Icc_union_Ico_eq_Ico (h\u2081 : a \u2264 b) (h\u2082 : b < c) : Icc a b \u222a Ico b c = Ico a c", "start": [1661, 1], "end": [1665, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset_Icc_union_Icc", "code": "theorem Icc_subset_Icc_union_Icc : Icc a c \u2286 Icc a b \u222a Icc b c", "start": [1668, 1], "end": [1669, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Icc_eq_Icc", "code": "@[simp]\ntheorem Icc_union_Icc_eq_Icc (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) : Icc a b \u222a Icc b c = Icc a c", "start": [1672, 1], "end": [1676, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Icc'", "code": "theorem Icc_union_Icc' (h\u2081 : c \u2264 b) (h\u2082 : a \u2264 d) : Icc a b \u222a Icc c d = Icc (min a c) (max b d)", "start": [1679, 1], "end": [1688, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_union_Icc", "code": "theorem Icc_union_Icc (h\u2081 : min a b < max c d) (h\u2082 : min c d < max a b) :\n    Icc a b \u222a Icc c d = Icc (min a c) (max b d)", "start": [1691, 1], "end": [1700, 99], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_subset_Ioc_union_Icc", "code": "theorem Ioc_subset_Ioc_union_Icc : Ioc a c \u2286 Ioc a b \u222a Icc b c", "start": [1703, 1], "end": [1704, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Icc_eq_Ioc", "code": "@[simp]\ntheorem Ioc_union_Icc_eq_Ioc (h\u2081 : a < b) (h\u2082 : b \u2264 c) : Ioc a b \u222a Icc b c = Ioc a c", "start": [1707, 1], "end": [1711, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ioo'", "code": "theorem Ioo_union_Ioo' (h\u2081 : c < b) (h\u2082 : a < d) : Ioo a b \u222a Ioo c d = Ioo (min a c) (max b d)", "start": [1714, 1], "end": [1723, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_union_Ioo", "code": "theorem Ioo_union_Ioo (h\u2081 : min a b < max c d) (h\u2082 : min c d < max a b) :\n    Ioo a b \u222a Ioo c d = Ioo (min a c) (max b d)", "start": [1726, 1], "end": [1733, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_inter_Iic", "code": "@[simp]\ntheorem Iic_inter_Iic {a b : \u03b1} : Iic a \u2229 Iic b = Iic (a \u2293 b)", "start": [1744, 1], "end": [1747, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_inter_Iic", "code": "@[simp]\ntheorem Ioc_inter_Iic (a b c : \u03b1) : Ioc a b \u2229 Iic c = Ioc a (b \u2293 c)", "start": [1750, 1], "end": [1752, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_inter_Ici", "code": "@[simp]\ntheorem Ici_inter_Ici {a b : \u03b1} : Ici a \u2229 Ici b = Ici (a \u2294 b)", "start": [1761, 1], "end": [1764, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_inter_Ici", "code": "@[simp]\ntheorem Ico_inter_Ici (a b c : \u03b1) : Ico a b \u2229 Ici c = Ico (a \u2294 c) b", "start": [1767, 1], "end": [1769, 75], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_inter_Icc", "code": "theorem Icc_inter_Icc : Icc a\u2081 b\u2081 \u2229 Icc a\u2082 b\u2082 = Icc (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082)", "start": [1778, 1], "end": [1779, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_inter_Icc_eq_singleton", "code": "@[simp]\ntheorem Icc_inter_Icc_eq_singleton (hab : a \u2264 b) (hbc : b \u2264 c) : Icc a b \u2229 Icc b c = {b}", "start": [1782, 1], "end": [1784, 72], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_inter_Ioi", "code": "@[simp]\ntheorem Ioi_inter_Ioi : Ioi a \u2229 Ioi b = Ioi (a \u2294 b)", "start": [1795, 1], "end": [1797, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_inter_Iio", "code": "@[simp]\ntheorem Iio_inter_Iio : Iio a \u2229 Iio b = Iio (a \u2293 b)", "start": [1800, 1], "end": [1802, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_inter_Ico", "code": "theorem Ico_inter_Ico : Ico a\u2081 b\u2081 \u2229 Ico a\u2082 b\u2082 = Ico (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082)", "start": [1805, 1], "end": [1806, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_inter_Ioc", "code": "theorem Ioc_inter_Ioc : Ioc a\u2081 b\u2081 \u2229 Ioc a\u2082 b\u2082 = Ioc (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082)", "start": [1809, 1], "end": [1810, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_inter_Ioo", "code": "theorem Ioo_inter_Ioo : Ioo a\u2081 b\u2081 \u2229 Ioo a\u2082 b\u2082 = Ioo (a\u2081 \u2294 a\u2082) (b\u2081 \u2293 b\u2082)", "start": [1813, 1], "end": [1814, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_inter_Ioo_of_left_lt", "code": "theorem Ioc_inter_Ioo_of_left_lt (h : b\u2081 < b\u2082) : Ioc a\u2081 b\u2081 \u2229 Ioo a\u2082 b\u2082 = Ioc (max a\u2081 a\u2082) b\u2081", "start": [1817, 1], "end": [1819, 99], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_inter_Ioo_of_right_le", "code": "theorem Ioc_inter_Ioo_of_right_le (h : b\u2082 \u2264 b\u2081) : Ioc a\u2081 b\u2081 \u2229 Ioo a\u2082 b\u2082 = Ioo (max a\u2081 a\u2082) b\u2082", "start": [1822, 1], "end": [1825, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_inter_Ioc_of_left_le", "code": "theorem Ioo_inter_Ioc_of_left_le (h : b\u2081 \u2264 b\u2082) : Ioo a\u2081 b\u2081 \u2229 Ioc a\u2082 b\u2082 = Ioo (max a\u2081 a\u2082) b\u2081", "start": [1828, 1], "end": [1829, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_inter_Ioc_of_right_lt", "code": "theorem Ioo_inter_Ioc_of_right_lt (h : b\u2082 < b\u2081) : Ioo a\u2081 b\u2081 \u2229 Ioc a\u2082 b\u2082 = Ioc (max a\u2081 a\u2082) b\u2082", "start": [1832, 1], "end": [1833, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_diff_Iio", "code": "@[simp]\ntheorem Ico_diff_Iio : Ico a b \\ Iio c = Ico (max a c) b", "start": [1836, 1], "end": [1838, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_diff_Ioi", "code": "@[simp]\ntheorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c)", "start": [1841, 1], "end": [1843, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_inter_Ioi", "code": "@[simp]\ntheorem Ioc_inter_Ioi : Ioc a b \u2229 Ioi c = Ioc (a \u2294 c) b", "start": [1846, 1], "end": [1849, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_inter_Iio", "code": "@[simp]\ntheorem Ico_inter_Iio : Ico a b \u2229 Iio c = Ico a (min b c)", "start": [1852, 1], "end": [1854, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_diff_Iic", "code": "@[simp]\ntheorem Ioc_diff_Iic : Ioc a b \\ Iic c = Ioc (max a c) b", "start": [1857, 1], "end": [1859, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc_right", "code": "@[simp]\ntheorem Ioc_union_Ioc_right : Ioc a b \u222a Ioc a c = Ioc a (max b c)", "start": [1862, 1], "end": [1864, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc_left", "code": "@[simp]\ntheorem Ioc_union_Ioc_left : Ioc a c \u222a Ioc b c = Ioc (min a b) c", "start": [1867, 1], "end": [1869, 85], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc_symm", "code": "@[simp]\ntheorem Ioc_union_Ioc_symm : Ioc a b \u222a Ioc b a = Ioc (min a b) (max a b)", "start": [1872, 1], "end": [1875, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_union_Ioc_union_Ioc_cycle", "code": "@[simp]\ntheorem Ioc_union_Ioc_union_Ioc_cycle :\n    Ioc a b \u222a Ioc b c \u222a Ioc c a = Ioc (min a (min b c)) (max a (max b c))", "start": [1878, 1], "end": [1889, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_prod_Iic", "code": "@[simp]\ntheorem Iic_prod_Iic (a : \u03b1) (b : \u03b2) : Iic a \u00d7\u02e2 Iic b = Iic (a, b)", "start": [1903, 1], "end": [1905, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_prod_Ici", "code": "@[simp]\ntheorem Ici_prod_Ici (a : \u03b1) (b : \u03b2) : Ici a \u00d7\u02e2 Ici b = Ici (a, b)", "start": [1908, 1], "end": [1910, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_prod_eq", "code": "theorem Ici_prod_eq (a : \u03b1 \u00d7 \u03b2) : Ici a = Ici a.1 \u00d7\u02e2 Ici a.2", "start": [1913, 1], "end": [1914, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_prod_eq", "code": "theorem Iic_prod_eq (a : \u03b1 \u00d7 \u03b2) : Iic a = Iic a.1 \u00d7\u02e2 Iic a.2", "start": [1917, 1], "end": [1918, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_prod_Icc", "code": "@[simp]\ntheorem Icc_prod_Icc (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) : Icc a\u2081 a\u2082 \u00d7\u02e2 Icc b\u2081 b\u2082 = Icc (a\u2081, b\u2081) (a\u2082, b\u2082)", "start": [1921, 1], "end": [1924, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_prod_eq", "code": "theorem Icc_prod_eq (a b : \u03b1 \u00d7 \u03b2) : Icc a b = Icc a.1 b.1 \u00d7\u02e2 Icc a.2 b.2", "start": [1927, 1], "end": [1927, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/WithZero.lean", "imports": ["Mathlib/Algebra/GroupWithZero/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/Basic.lean", "Mathlib/Algebra/Order/Monoid/TypeTags.lean", "Mathlib/Algebra/Order/Group/Units.lean", "Mathlib/Algebra/Hom/Equiv/Units/GroupWithZero.lean", "Mathlib/Algebra/Order/Group/Instances.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean"], "premises": [{"full_name": "LinearOrderedCommGroupWithZero", "code": "class LinearOrderedCommGroupWithZero (\u03b1 : Type*) extends LinearOrderedCommMonoidWithZero \u03b1,\n  CommGroupWithZero \u03b1", "start": [34, 1], "end": [36, 22], "kind": "commanddeclaration"}, {"full_name": "instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual", "code": "instance instLinearOrderedCommMonoidWithZeroMultiplicativeOrderDual\n    [LinearOrderedAddCommMonoidWithTop \u03b1] :\n    LinearOrderedCommMonoidWithZero (Multiplicative \u03b1\u1d52\u1d48) :=\n  { Multiplicative.orderedCommMonoid, Multiplicative.linearOrder with\n    zero := Multiplicative.ofAdd (\u22a4 : \u03b1)\n    zero_mul := @top_add _ (_)\n    mul_zero := @add_top _ (_)\n    zero_le_one := (le_top : (0 : \u03b1) \u2264 \u22a4) }", "start": [43, 1], "end": [52, 44], "kind": "commanddeclaration"}, {"full_name": "instLinearOrderedCommMonoidWithZeroWithZero", "code": "instance instLinearOrderedCommMonoidWithZeroWithZero [LinearOrderedCommMonoid \u03b1] :\n    LinearOrderedCommMonoidWithZero (WithZero \u03b1) :=\n  { WithZero.linearOrder, WithZero.commMonoidWithZero with\n    mul_le_mul_left := fun _ _ \u21a6 mul_le_mul_left', zero_le_one := WithZero.zero_le _ }", "start": [62, 1], "end": [65, 87], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCommMonoidWithZero", "code": "@[reducible]\ndef Function.Injective.linearOrderedCommMonoidWithZero {\u03b2 : Type*} [Zero \u03b2] [One \u03b2] [Mul \u03b2]\n    [Pow \u03b2 \u2115] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Function.Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedCommMonoidWithZero \u03b2 :=\n  { LinearOrder.lift f hf hsup hinf, hf.orderedCommMonoid f one mul npow,\n    hf.commMonoidWithZero f zero one mul npow with\n    zero_le_one :=\n      show f 0 \u2264 f 1 by simp only [zero, one, LinearOrderedCommMonoidWithZero.zero_le_one] }", "start": [78, 1], "end": [89, 93], "kind": "commanddeclaration"}, {"full_name": "zero_le'", "code": "@[simp]\ntheorem zero_le' : 0 \u2264 a", "start": [92, 1], "end": [93, 99], "kind": "commanddeclaration"}, {"full_name": "not_lt_zero'", "code": "@[simp]\ntheorem not_lt_zero' : \u00aca < 0", "start": [96, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "le_zero_iff", "code": "@[simp]\ntheorem le_zero_iff : a \u2264 0 \u2194 a = 0", "start": [101, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "zero_lt_iff", "code": "theorem zero_lt_iff : 0 < a \u2194 a \u2260 0", "start": [106, 1], "end": [107, 53], "kind": "commanddeclaration"}, {"full_name": "ne_zero_of_lt", "code": "theorem ne_zero_of_lt (h : b < a) : a \u2260 0", "start": [110, 1], "end": [110, 93], "kind": "commanddeclaration"}, {"full_name": "instLinearOrderedAddCommMonoidWithTopAdditiveOrderDual", "code": "instance instLinearOrderedAddCommMonoidWithTopAdditiveOrderDual :\n    LinearOrderedAddCommMonoidWithTop (Additive \u03b1\u1d52\u1d48) :=\n  { Additive.orderedAddCommMonoid, Additive.linearOrder with\n    top := (0 : \u03b1)\n    top_add' := fun a \u21a6 zero_mul (Additive.toMul a)\n    le_top := fun _ \u21a6 zero_le' }", "start": [113, 1], "end": [118, 33], "kind": "commanddeclaration"}, {"full_name": "mul_le_one\u2080", "code": "theorem mul_le_one\u2080 (ha : a \u2264 1) (hb : b \u2264 1) : a * b \u2264 1", "start": [126, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "one_le_mul\u2080", "code": "theorem one_le_mul\u2080 (ha : 1 \u2264 a) (hb : 1 \u2264 b) : 1 \u2264 a * b", "start": [131, 1], "end": [133, 19], "kind": "commanddeclaration"}, {"full_name": "le_of_le_mul_right", "code": "theorem le_of_le_mul_right (h : c \u2260 0) (hab : a * c \u2264 b * c) : a \u2264 b", "start": [136, 1], "end": [137, 71], "kind": "commanddeclaration"}, {"full_name": "le_mul_inv_of_mul_le", "code": "theorem le_mul_inv_of_mul_le (h : c \u2260 0) (hab : a * c \u2264 b) : a \u2264 b * c\u207b\u00b9", "start": [140, 1], "end": [141, 48], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_of_le_mul", "code": "theorem mul_inv_le_of_le_mul (hab : a \u2264 b * c) : a * c\u207b\u00b9 \u2264 b", "start": [144, 1], "end": [147, 56], "kind": "commanddeclaration"}, {"full_name": "inv_le_one\u2080", "code": "theorem inv_le_one\u2080 (ha : a \u2260 0) : a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "start": [150, 1], "end": [151, 41], "kind": "commanddeclaration"}, {"full_name": "one_le_inv\u2080", "code": "theorem one_le_inv\u2080 (ha : a \u2260 0) : 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "start": [154, 1], "end": [155, 41], "kind": "commanddeclaration"}, {"full_name": "le_mul_inv_iff\u2080", "code": "theorem le_mul_inv_iff\u2080 (hc : c \u2260 0) : a \u2264 b * c\u207b\u00b9 \u2194 a * c \u2264 b", "start": [158, 1], "end": [159, 72], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_iff\u2080", "code": "theorem mul_inv_le_iff\u2080 (hc : c \u2260 0) : a * c\u207b\u00b9 \u2264 b \u2194 a \u2264 b * c", "start": [162, 1], "end": [163, 86], "kind": "commanddeclaration"}, {"full_name": "div_le_div\u2080", "code": "theorem div_le_div\u2080 (a b c d : \u03b1) (hb : b \u2260 0) (hd : d \u2260 0) : a * b\u207b\u00b9 \u2264 c * d\u207b\u00b9 \u2194 a * d \u2264 c * b", "start": [166, 1], "end": [167, 65], "kind": "commanddeclaration"}, {"full_name": "Units.zero_lt", "code": "@[simp]\ntheorem Units.zero_lt (u : \u03b1\u02e3) : (0 : \u03b1) < u", "start": [170, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_lt_of_le\u2080", "code": "theorem mul_lt_mul_of_lt_of_le\u2080 (hab : a \u2264 b) (hb : b \u2260 0) (hcd : c < d) : a * c < b * d", "start": [175, 1], "end": [186, 39], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul\u2080", "code": "theorem mul_lt_mul\u2080 (hab : a < b) (hcd : c < d) : a * c < b * d", "start": [189, 1], "end": [190, 57], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_of_lt_mul\u2080", "code": "theorem mul_inv_lt_of_lt_mul\u2080 (h : x < y * z) : x * z\u207b\u00b9 < y", "start": [193, 1], "end": [195, 52], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_of_lt_mul\u2080", "code": "theorem inv_mul_lt_of_lt_mul\u2080 (h : x < y * z) : y\u207b\u00b9 * x < z", "start": [198, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "mul_lt_right\u2080", "code": "theorem mul_lt_right\u2080 (c : \u03b1) (h : a < b) (hc : c \u2260 0) : a * c < b * c", "start": [203, 1], "end": [205, 32], "kind": "commanddeclaration"}, {"full_name": "inv_lt_inv\u2080", "code": "theorem inv_lt_inv\u2080 (ha : a \u2260 0) (hb : b \u2260 0) : a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a", "start": [208, 1], "end": [212, 19], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv\u2080", "code": "theorem inv_le_inv\u2080 (ha : a \u2260 0) (hb : b \u2260 0) : a\u207b\u00b9 \u2264 b\u207b\u00b9 \u2194 b \u2264 a", "start": [215, 1], "end": [221, 19], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_of_le\u2080", "code": "theorem lt_of_mul_lt_mul_of_le\u2080 (h : a * b < c * d) (hc : 0 < c) (hh : c \u2264 a) : b < d", "start": [224, 1], "end": [228, 81], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_right\u2080", "code": "theorem mul_le_mul_right\u2080 (hc : c \u2260 0) : a * c \u2264 b * c \u2194 a \u2264 b", "start": [231, 1], "end": [232, 61], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_left\u2080", "code": "theorem mul_le_mul_left\u2080 (ha : a \u2260 0) : a * b \u2264 a * c \u2194 b \u2264 c", "start": [235, 1], "end": [237, 29], "kind": "commanddeclaration"}, {"full_name": "div_le_div_right\u2080", "code": "theorem div_le_div_right\u2080 (hc : c \u2260 0) : a / c \u2264 b / c \u2194 a \u2264 b", "start": [240, 1], "end": [241, 74], "kind": "commanddeclaration"}, {"full_name": "div_le_div_left\u2080", "code": "theorem div_le_div_left\u2080 (ha : a \u2260 0) (hb : b \u2260 0) (hc : c \u2260 0) : a / b \u2264 a / c \u2194 c \u2264 b", "start": [244, 1], "end": [245, 69], "kind": "commanddeclaration"}, {"full_name": "le_div_iff\u2080", "code": "theorem le_div_iff\u2080 (hc : c \u2260 0) : a \u2264 b / c \u2194 a * c \u2264 b", "start": [248, 1], "end": [249, 42], "kind": "commanddeclaration"}, {"full_name": "div_le_iff\u2080", "code": "theorem div_le_iff\u2080 (hc : c \u2260 0) : a / c \u2264 b \u2194 a \u2264 b * c", "start": [252, 1], "end": [253, 42], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulLeft\u2080'", "code": "@[simps! (config := { simpRhs := true }) apply toEquiv]\ndef OrderIso.mulLeft\u2080' {a : \u03b1} (ha : a \u2260 0) : \u03b1 \u2243o \u03b1 :=\n  { Equiv.mulLeft\u2080 a ha with map_rel_iff' := mul_le_mul_left\u2080 ha }", "start": [256, 1], "end": [261, 67], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulLeft\u2080'_symm", "code": "theorem OrderIso.mulLeft\u2080'_symm {a : \u03b1} (ha : a \u2260 0) :\n    (OrderIso.mulLeft\u2080' ha).symm = OrderIso.mulLeft\u2080' (inv_ne_zero ha)", "start": [266, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulRight\u2080'", "code": "@[simps! (config := { simpRhs := true }) apply toEquiv]\ndef OrderIso.mulRight\u2080' {a : \u03b1} (ha : a \u2260 0) : \u03b1 \u2243o \u03b1 :=\n  { Equiv.mulRight\u2080 a ha with map_rel_iff' := mul_le_mul_right\u2080 ha }", "start": [272, 1], "end": [277, 69], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulRight\u2080'_symm", "code": "theorem OrderIso.mulRight\u2080'_symm {a : \u03b1} (ha : a \u2260 0) :\n    (OrderIso.mulRight\u2080' ha).symm = OrderIso.mulRight\u2080' (inv_ne_zero ha)", "start": [282, 1], "end": [285, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/Abs.lean", "imports": ["Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "abs_one", "code": "@[simp]\ntheorem abs_one : |(1 : \u03b1)| = 1", "start": [23, 1], "end": [25, 25], "kind": "commanddeclaration"}, {"full_name": "abs_two", "code": "@[simp]\ntheorem abs_two : |(2 : \u03b1)| = 2", "start": [28, 1], "end": [30, 25], "kind": "commanddeclaration"}, {"full_name": "abs_mul", "code": "theorem abs_mul (a b : \u03b1) : |a * b| = |a| * |b|", "start": [33, 1], "end": [37, 27], "kind": "commanddeclaration"}, {"full_name": "absHom", "code": "def absHom : \u03b1 \u2192*\u2080 \u03b1 :=\n  { toFun := abs\n    map_zero' := abs_zero\n    map_one' := abs_one\n    map_mul' := abs_mul }", "start": [40, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "abs_mul_abs_self", "code": "@[simp]\ntheorem abs_mul_abs_self (a : \u03b1) : |a| * |a| = a * a", "start": [48, 1], "end": [50, 62], "kind": "commanddeclaration"}, {"full_name": "abs_mul_self", "code": "@[simp]\ntheorem abs_mul_self (a : \u03b1) : |a * a| = a * a", "start": [53, 1], "end": [54, 84], "kind": "commanddeclaration"}, {"full_name": "abs_eq_self", "code": "@[simp]\ntheorem abs_eq_self : |a| = a \u2194 0 \u2264 a", "start": [57, 1], "end": [58, 66], "kind": "commanddeclaration"}, {"full_name": "abs_eq_neg_self", "code": "@[simp]\ntheorem abs_eq_neg_self : |a| = -a \u2194 a \u2264 0", "start": [61, 1], "end": [62, 71], "kind": "commanddeclaration"}, {"full_name": "abs_cases", "code": "theorem abs_cases (a : \u03b1) : |a| = a \u2227 0 \u2264 a \u2228 |a| = -a \u2227 a < 0", "start": [65, 1], "end": [74, 48], "kind": "commanddeclaration"}, {"full_name": "max_zero_add_max_neg_zero_eq_abs_self", "code": "@[simp]\ntheorem max_zero_add_max_neg_zero_eq_abs_self (a : \u03b1) : max a 0 + max (-a) 0 = |a|", "start": [77, 1], "end": [80, 51], "kind": "commanddeclaration"}, {"full_name": "abs_eq_iff_mul_self_eq", "code": "theorem abs_eq_iff_mul_self_eq : |a| = |b| \u2194 a * a = b * b", "start": [83, 1], "end": [85, 58], "kind": "commanddeclaration"}, {"full_name": "abs_lt_iff_mul_self_lt", "code": "theorem abs_lt_iff_mul_self_lt : |a| < |b| \u2194 a * a < b * b", "start": [88, 1], "end": [90, 63], "kind": "commanddeclaration"}, {"full_name": "abs_le_iff_mul_self_le", "code": "theorem abs_le_iff_mul_self_le : |a| \u2264 |b| \u2194 a * a \u2264 b * b", "start": [93, 1], "end": [95, 63], "kind": "commanddeclaration"}, {"full_name": "abs_le_one_iff_mul_self_le_one", "code": "theorem abs_le_one_iff_mul_self_le_one : |a| \u2264 1 \u2194 a * a \u2264 1", "start": [98, 1], "end": [99, 70], "kind": "commanddeclaration"}, {"full_name": "abs_sub_sq", "code": "theorem abs_sub_sq (a b : \u03b1) : |a - b| * |a - b| = a * a + b * b - (1 + 1) * a * b", "start": [108, 1], "end": [111, 37], "kind": "commanddeclaration"}, {"full_name": "abs_dvd", "code": "@[simp]\ntheorem abs_dvd (a b : \u03b1) : |a| \u2223 b \u2194 a \u2223 b", "start": [120, 1], "end": [122, 58], "kind": "commanddeclaration"}, {"full_name": "abs_dvd_self", "code": "theorem abs_dvd_self (a : \u03b1) : |a| \u2223 a", "start": [125, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "dvd_abs", "code": "@[simp]\ntheorem dvd_abs (a b : \u03b1) : a \u2223 |b| \u2194 a \u2223 b", "start": [129, 1], "end": [131, 58], "kind": "commanddeclaration"}, {"full_name": "self_dvd_abs", "code": "theorem self_dvd_abs (a : \u03b1) : a \u2223 |a|", "start": [134, 1], "end": [135, 33], "kind": "commanddeclaration"}, {"full_name": "abs_dvd_abs", "code": "theorem abs_dvd_abs (a b : \u03b1) : |a| \u2223 |b| \u2194 a \u2223 b", "start": [138, 1], "end": [139, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupPower/Ring.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Algebra/Ring/Commute.lean", "Mathlib/Algebra/Hom/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Algebra/GroupWithZero/Commute.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/Data/Nat/Order/Basic.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "zero_pow", "code": "theorem zero_pow : \u2200 {n : \u2115}, 0 < n \u2192 (0 : M) ^ n = 0", "start": [32, 1], "end": [33, 43], "kind": "commanddeclaration"}, {"full_name": "zero_pow'", "code": "@[simp]\ntheorem zero_pow' : \u2200 n : \u2115, n \u2260 0 \u2192 (0 : M) ^ n = 0", "start": [36, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "zero_pow_eq", "code": "theorem zero_pow_eq (n : \u2115) : (0 : M) ^ n = if n = 0 then 1 else 0", "start": [44, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "pow_eq_zero_of_le", "code": "theorem pow_eq_zero_of_le {x : M} {n m : \u2115} (hn : n \u2264 m) (hx : x ^ n = 0) : x ^ m = 0", "start": [50, 1], "end": [51, 57], "kind": "commanddeclaration"}, {"full_name": "pow_eq_zero", "code": "theorem pow_eq_zero [NoZeroDivisors M] {x : M} {n : \u2115} (H : x ^ n = 0) : x = 0", "start": [54, 1], "end": [59, 45], "kind": "commanddeclaration"}, {"full_name": "pow_eq_zero_iff", "code": "@[simp]\ntheorem pow_eq_zero_iff [NoZeroDivisors M] {a : M} {n : \u2115} (hn : 0 < n) : a ^ n = 0 \u2194 a = 0", "start": [62, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "pow_eq_zero_iff'", "code": "theorem pow_eq_zero_iff' [NoZeroDivisors M] [Nontrivial M] {a : M} {n : \u2115} :\n    a ^ n = 0 \u2194 a = 0 \u2227 n \u2260 0", "start": [69, 1], "end": [70, 86], "kind": "commanddeclaration"}, {"full_name": "pow_ne_zero_iff", "code": "theorem pow_ne_zero_iff [NoZeroDivisors M] {a : M} {n : \u2115} (hn : 0 < n) : a ^ n \u2260 0 \u2194 a \u2260 0", "start": [73, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "ne_zero_pow", "code": "theorem ne_zero_pow {a : M} {n : \u2115} (hn : n \u2260 0) : a ^ n \u2260 0 \u2192 a \u2260 0", "start": [77, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "pow_ne_zero", "code": "@[field_simps]\ntheorem pow_ne_zero [NoZeroDivisors M] {a : M} (n : \u2115) (h : a \u2260 0) : a ^ n \u2260 0", "start": [83, 1], "end": [85, 19], "kind": "commanddeclaration"}, {"full_name": "NeZero.pow", "code": "instance NeZero.pow [NoZeroDivisors M] {x : M} [NeZero x] {n : \u2115} : NeZero (x ^ n) :=\n  \u27e8pow_ne_zero n NeZero.out\u27e9", "start": [88, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "sq_eq_zero_iff", "code": "theorem sq_eq_zero_iff [NoZeroDivisors M] {a : M} : a ^ 2 = 0 \u2194 a = 0", "start": [92, 1], "end": [93, 26], "kind": "commanddeclaration"}, {"full_name": "zero_pow_eq_zero", "code": "@[simp]\ntheorem zero_pow_eq_zero [Nontrivial M] {n : \u2115} : (0 : M) ^ n = 0 \u2194 0 < n", "start": [96, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_pow", "code": "theorem Ring.inverse_pow (r : M) : \u2200 n : \u2115, Ring.inverse r ^ n = Ring.inverse (r ^ n)", "start": [105, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "powMonoidWithZeroHom", "code": "def powMonoidWithZeroHom : M \u2192*\u2080 M :=\n  { powMonoidHom n with map_zero' := zero_pow hn }", "start": [118, 1], "end": [120, 51], "kind": "commanddeclaration"}, {"full_name": "coe_powMonoidWithZeroHom", "code": "@[simp]\ntheorem coe_powMonoidWithZeroHom : (powMonoidWithZeroHom hn : M \u2192 M) = fun x \u21a6 (x^n : M)", "start": [123, 1], "end": [124, 96], "kind": "commanddeclaration"}, {"full_name": "powMonoidWithZeroHom_apply", "code": "@[simp]\ntheorem powMonoidWithZeroHom_apply (a : M) : powMonoidWithZeroHom hn a = a ^ n", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "pow_dvd_pow_iff", "code": "theorem pow_dvd_pow_iff [CancelCommMonoidWithZero R] {x : R} {n m : \u2115} (h0 : x \u2260 0)\n    (h1 : \u00acIsUnit x) : x ^ n \u2223 x ^ m \u2194 n \u2264 m", "start": [134, 1], "end": [146, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_pow", "code": "protected theorem RingHom.map_pow (f : R \u2192+* S) (a) : \u2200 n : \u2115, f (a ^ n) = f a ^ n", "start": [153, 1], "end": [154, 14], "kind": "commanddeclaration"}, {"full_name": "min_pow_dvd_add", "code": "theorem min_pow_dvd_add {n m : \u2115} {a b c : R} (ha : c ^ n \u2223 a) (hb : c ^ m \u2223 b) :\n    c ^ min n m \u2223 a + b", "start": [157, 1], "end": [161, 22], "kind": "commanddeclaration"}, {"full_name": "add_sq", "code": "theorem add_sq (a b : R) : (a + b) ^ 2 = a ^ 2 + 2 * a * b + b ^ 2", "start": [170, 1], "end": [171, 34], "kind": "commanddeclaration"}, {"full_name": "add_sq'", "code": "theorem add_sq' (a b : R) : (a + b) ^ 2 = a ^ 2 + b ^ 2 + 2 * a * b", "start": [174, 1], "end": [175, 56], "kind": "commanddeclaration"}, {"full_name": "add_pow_two", "code": "alias add_pow_two := add_sq", "start": [178, 1], "end": [178, 28], "kind": "stdtacticaliasalias"}, {"full_name": "neg_one_pow_eq_or", "code": "theorem neg_one_pow_eq_or : \u2200 n : \u2115, (-1 : R) ^ n = 1 \u2228 (-1 : R) ^ n = -1", "start": [189, 1], "end": [193, 43], "kind": "commanddeclaration"}, {"full_name": "neg_pow", "code": "theorem neg_pow (a : R) (n : \u2115) : (-a) ^ n = (-1) ^ n * a ^ n", "start": [198, 1], "end": [199, 53], "kind": "commanddeclaration"}, {"full_name": "neg_pow'", "code": "theorem neg_pow' (a : R) (n : \u2115) : (-a) ^ n = a ^ n * (-1) ^ n", "start": [202, 1], "end": [203, 54], "kind": "commanddeclaration"}, {"full_name": "neg_pow_bit0", "code": "theorem neg_pow_bit0 (a : R) (n : \u2115) : (-a) ^ bit0 n = a ^ bit0 n", "start": [208, 1], "end": [209, 41], "kind": "commanddeclaration"}, {"full_name": "neg_pow_bit1", "code": "@[simp]\ntheorem neg_pow_bit1 (a : R) (n : \u2115) : (-a) ^ bit1 n = -a ^ bit1 n", "start": [212, 1], "end": [214, 63], "kind": "commanddeclaration"}, {"full_name": "neg_sq", "code": "theorem neg_sq (a : R) : (-a) ^ 2 = a ^ 2", "start": [219, 1], "end": [219, 58], "kind": "commanddeclaration"}, {"full_name": "neg_one_sq", "code": "theorem neg_one_sq : (-1 : R) ^ 2 = 1", "start": [223, 1], "end": [223, 67], "kind": "commanddeclaration"}, {"full_name": "neg_pow_two", "code": "alias neg_pow_two := neg_sq", "start": [226, 1], "end": [226, 28], "kind": "stdtacticaliasalias"}, {"full_name": "neg_one_pow_two", "code": "alias neg_one_pow_two := neg_one_sq", "start": [229, 1], "end": [229, 36], "kind": "stdtacticaliasalias"}, {"full_name": "Commute.sq_sub_sq", "code": "protected theorem Commute.sq_sub_sq (h : Commute a b) : a ^ 2 - b ^ 2 = (a + b) * (a - b)", "start": [238, 1], "end": [239, 42], "kind": "commanddeclaration"}, {"full_name": "neg_one_pow_mul_eq_zero_iff", "code": "@[simp]\ntheorem neg_one_pow_mul_eq_zero_iff {n : \u2115} {r : R} : (-1) ^ n * r = 0 \u2194 r = 0", "start": [242, 1], "end": [244, 55], "kind": "commanddeclaration"}, {"full_name": "mul_neg_one_pow_eq_zero_iff", "code": "@[simp]\ntheorem mul_neg_one_pow_eq_zero_iff {n : \u2115} {r : R} : r * (-1) ^ n = 0 \u2194 r = 0", "start": [247, 1], "end": [249, 55], "kind": "commanddeclaration"}, {"full_name": "Commute.sq_eq_sq_iff_eq_or_eq_neg", "code": "protected theorem Commute.sq_eq_sq_iff_eq_or_eq_neg (h : Commute a b) :\n    a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b", "start": [254, 1], "end": [256, 93], "kind": "commanddeclaration"}, {"full_name": "sq_eq_one_iff", "code": "@[simp]\ntheorem sq_eq_one_iff : a ^ 2 = 1 \u2194 a = 1 \u2228 a = -1", "start": [259, 1], "end": [261, 66], "kind": "commanddeclaration"}, {"full_name": "sq_ne_one_iff", "code": "theorem sq_ne_one_iff : a ^ 2 \u2260 1 \u2194 a \u2260 1 \u2227 a \u2260 -1", "start": [264, 1], "end": [265, 33], "kind": "commanddeclaration"}, {"full_name": "sq_sub_sq", "code": "theorem sq_sub_sq (a b : R) : a ^ 2 - b ^ 2 = (a + b) * (a - b)", "start": [274, 1], "end": [275, 30], "kind": "commanddeclaration"}, {"full_name": "pow_two_sub_pow_two", "code": "alias pow_two_sub_pow_two := sq_sub_sq", "start": [278, 1], "end": [278, 39], "kind": "stdtacticaliasalias"}, {"full_name": "sub_sq", "code": "theorem sub_sq (a b : R) : (a - b) ^ 2 = a ^ 2 - 2 * a * b + b ^ 2", "start": [281, 1], "end": [282, 65], "kind": "commanddeclaration"}, {"full_name": "sub_pow_two", "code": "alias sub_pow_two := sub_sq", "start": [285, 1], "end": [285, 28], "kind": "stdtacticaliasalias"}, {"full_name": "sub_sq'", "code": "theorem sub_sq' (a b : R) : (a - b) ^ 2 = a ^ 2 + b ^ 2 - 2 * a * b", "start": [288, 1], "end": [289, 66], "kind": "commanddeclaration"}, {"full_name": "sq_eq_sq_iff_eq_or_eq_neg", "code": "theorem sq_eq_sq_iff_eq_or_eq_neg : a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b", "start": [294, 1], "end": [295, 46], "kind": "commanddeclaration"}, {"full_name": "eq_or_eq_neg_of_sq_eq_sq", "code": "theorem eq_or_eq_neg_of_sq_eq_sq (a b : R) : a ^ 2 = b ^ 2 \u2192 a = b \u2228 a = -b", "start": [298, 1], "end": [299, 30], "kind": "commanddeclaration"}, {"full_name": "Units.sq_eq_sq_iff_eq_or_eq_neg", "code": "protected theorem sq_eq_sq_iff_eq_or_eq_neg {a b : R\u02e3} : a ^ 2 = b ^ 2 \u2194 a = b \u2228 a = -b", "start": [305, 1], "end": [306, 82], "kind": "commanddeclaration"}, {"full_name": "Units.eq_or_eq_neg_of_sq_eq_sq", "code": "protected theorem eq_or_eq_neg_of_sq_eq_sq (a b : R\u02e3) (h : a ^ 2 = b ^ 2) : a = b \u2228 a = -b", "start": [309, 1], "end": [310, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Set.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.range_eq_univ", "code": "@[simp]\ntheorem range_eq_univ {\u03b1 : Type*} {\u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) : range e = univ", "start": [35, 1], "end": [37, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_eq_preimage", "code": "protected theorem image_eq_preimage {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) : e '' s = e.symm \u207b\u00b9' s", "start": [40, 1], "end": [41, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_equiv", "code": "@[simp 1001]\ntheorem _root_.Set.mem_image_equiv {\u03b1 \u03b2} {S : Set \u03b1} {f : \u03b1 \u2243 \u03b2} {x : \u03b2} :\n    x \u2208 f '' S \u2194 f.symm x \u2208 S", "start": [44, 1], "end": [47, 43], "kind": "commanddeclaration"}, {"full_name": "Set.image_equiv_eq_preimage_symm", "code": "theorem _root_.Set.image_equiv_eq_preimage_symm {\u03b1 \u03b2} (S : Set \u03b1) (f : \u03b1 \u2243 \u03b2) :\n    f '' S = f.symm \u207b\u00b9' S", "start": [50, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_equiv_eq_image_symm", "code": "theorem _root_.Set.preimage_equiv_eq_image_symm {\u03b1 \u03b2} (S : Set \u03b1) (f : \u03b2 \u2243 \u03b1) :\n    f \u207b\u00b9' S = f.symm '' S", "start": [56, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.subset_image", "code": "@[simp high]\nprotected theorem subset_image {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    e.symm '' t \u2286 s \u2194 t \u2286 e '' s", "start": [63, 1], "end": [65, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.subset_image'", "code": "@[simp high]\nprotected theorem subset_image' {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    s \u2286 e.symm '' t \u2194 e '' s \u2286 t", "start": [69, 1], "end": [74, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_image_image", "code": "@[simp]\ntheorem symm_image_image {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) : e.symm '' (e '' s) = s", "start": [77, 1], "end": [79, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.eq_image_iff_symm_image_eq", "code": "theorem eq_image_iff_symm_image_eq {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    t = e '' s \u2194 e.symm '' t = s", "start": [82, 1], "end": [84, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_symm_image", "code": "@[simp]\ntheorem image_symm_image {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b2) : e '' (e.symm '' s) = s", "start": [87, 1], "end": [89, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_preimage", "code": "@[simp]\ntheorem image_preimage {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b2) : e '' (e \u207b\u00b9' s) = s", "start": [92, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.preimage_image", "code": "@[simp]\ntheorem preimage_image {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e '' s) = s", "start": [97, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_compl", "code": "protected theorem image_compl {\u03b1 \u03b2} (f : Equiv \u03b1 \u03b2) (s : Set \u03b1) : f '' s\u1d9c = (f '' s)\u1d9c", "start": [102, 1], "end": [103, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_preimage_preimage", "code": "@[simp]\ntheorem symm_preimage_preimage {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b2) : e.symm \u207b\u00b9' (e \u207b\u00b9' s) = s", "start": [106, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.preimage_symm_preimage", "code": "@[simp]\ntheorem preimage_symm_preimage {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s", "start": [111, 1], "end": [113, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.preimage_subset", "code": "@[simp]\ntheorem preimage_subset {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s t : Set \u03b2) : e \u207b\u00b9' s \u2286 e \u207b\u00b9' t \u2194 s \u2286 t", "start": [116, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_subset", "code": "theorem image_subset {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s t : Set \u03b1) : e '' s \u2286 e '' t \u2194 s \u2286 t", "start": [122, 1], "end": [123, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.image_eq_iff_eq", "code": "@[simp]\ntheorem image_eq_iff_eq {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s t : Set \u03b1) : e '' s = e '' t \u2194 s = t", "start": [126, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.preimage_eq_iff_eq_image", "code": "theorem preimage_eq_iff_eq_image {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s t) : e \u207b\u00b9' s = t \u2194 s = e '' t", "start": [131, 1], "end": [132, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.eq_preimage_iff_image_eq", "code": "theorem eq_preimage_iff_image_eq {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (s t) : s = e \u207b\u00b9' t \u2194 e '' s = t", "start": [135, 1], "end": [136, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_assoc_preimage", "code": "@[simp]\ntheorem prod_assoc_preimage {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    Equiv.prodAssoc \u03b1 \u03b2 \u03b3 \u207b\u00b9' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u", "start": [139, 1], "end": [143, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_assoc_symm_preimage", "code": "@[simp]\ntheorem prod_assoc_symm_preimage {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm \u207b\u00b9' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u", "start": [146, 1], "end": [150, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_assoc_image", "code": "theorem prod_assoc_image {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    Equiv.prodAssoc \u03b1 \u03b2 \u03b3 '' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u", "start": [155, 1], "end": [157, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_assoc_symm_image", "code": "theorem prod_assoc_symm_image {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm '' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u", "start": [160, 1], "end": [162, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.setProdEquivSigma", "code": "def setProdEquivSigma {\u03b1 \u03b2 : Type*} (s : Set (\u03b1 \u00d7 \u03b2)) :\n    s \u2243 \u03a3x : \u03b1, { y : \u03b2 | (x, y) \u2208 s } where\n  toFun x := \u27e8x.1.1, x.1.2, by simp\u27e9\n  invFun x := \u27e8(x.1, x.2.1), x.2.2\u27e9\n  left_inv := fun \u27e8\u27e8x, y\u27e9, h\u27e9 => rfl\n  right_inv := fun \u27e8x, y, h\u27e9 => rfl", "start": [165, 1], "end": [171, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.setCongr", "code": "@[simps! apply]\ndef setCongr {\u03b1 : Type*} {s t : Set \u03b1} (h : s = t) : s \u2243 t :=\n  subtypeEquivProp h", "start": [174, 1], "end": [177, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.image", "code": "@[simps]\ndef image {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) (s : Set \u03b1) :\n    s \u2243 e '' s where\n  toFun x := \u27e8e x.1, by simp\u27e9\n  invFun y :=\n    \u27e8e.symm y.1, by\n      rcases y with \u27e8-, \u27e8a, \u27e8m, rfl\u27e9\u27e9\u27e9\n      simpa using m\u27e9\n  left_inv x := by simp\n  right_inv y := by simp", "start": [183, 1], "end": [194, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.univ", "code": "protected def univ (\u03b1) : @univ \u03b1 \u2243 \u03b1 :=\n  \u27e8Subtype.val, fun a => \u27e8a, trivial\u27e9, fun \u27e8_, _\u27e9 => rfl, fun _ => rfl\u27e9", "start": [202, 1], "end": [204, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.empty", "code": "protected def empty (\u03b1) : (\u2205 : Set \u03b1) \u2243 Empty :=\n  equivEmpty _", "start": [207, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.pempty", "code": "protected def pempty (\u03b1) : (\u2205 : Set \u03b1) \u2243 PEmpty :=\n  equivPEmpty _", "start": [212, 1], "end": [214, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union'", "code": "protected def union' {\u03b1} {s t : Set \u03b1} (p : \u03b1 \u2192 Prop) [DecidablePred p] (hs : \u2200 x \u2208 s, p x)\n    (ht : \u2200 x \u2208 t, \u00acp x) : (s \u222a t : Set \u03b1) \u2243 s \u2295 t where\n  toFun x :=\n    if hp : p x then Sum.inl \u27e8_, x.2.resolve_right fun xt => ht _ xt hp\u27e9\n    else Sum.inr \u27e8_, x.2.resolve_left fun xs => hp (hs _ xs)\u27e9\n  invFun o :=\n    match o with\n    | Sum.inl x => \u27e8x, Or.inl x.2\u27e9\n    | Sum.inr x => \u27e8x, Or.inr x.2\u27e9\n  left_inv := fun \u27e8x, h'\u27e9 => by by_cases h : p x <;> simp [h]\n  right_inv o := by\n    rcases o with (\u27e8x, h\u27e9 | \u27e8x, h\u27e9) <;> [simp [hs _ h]; simp [ht _ h]]", "start": [217, 1], "end": [230, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union", "code": "protected def union {\u03b1} {s t : Set \u03b1} [DecidablePred fun x => x \u2208 s] (H : s \u2229 t \u2286 \u2205) :\n    (s \u222a t : Set \u03b1) \u2243 s \u2295 t :=\n  Set.union' (fun x => x \u2208 s) (fun _ => id) fun _ xt xs => H \u27e8xs, xt\u27e9", "start": [233, 1], "end": [236, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union_apply_left", "code": "theorem union_apply_left {\u03b1} {s t : Set \u03b1} [DecidablePred fun x => x \u2208 s] (H : s \u2229 t \u2286 \u2205)\n    {a : (s \u222a t : Set \u03b1)} (ha : \u2191a \u2208 s) : Equiv.Set.union H a = Sum.inl \u27e8a, ha\u27e9", "start": [239, 1], "end": [241, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union_apply_right", "code": "theorem union_apply_right {\u03b1} {s t : Set \u03b1} [DecidablePred fun x => x \u2208 s] (H : s \u2229 t \u2286 \u2205)\n    {a : (s \u222a t : Set \u03b1)} (ha : \u2191a \u2208 t) : Equiv.Set.union H a = Sum.inr \u27e8a, ha\u27e9", "start": [244, 1], "end": [246, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union_symm_apply_left", "code": "@[simp]\ntheorem union_symm_apply_left {\u03b1} {s t : Set \u03b1} [DecidablePred fun x => x \u2208 s] (H : s \u2229 t \u2286 \u2205)\n    (a : s) : (Equiv.Set.union H).symm (Sum.inl a) = \u27e8a, subset_union_left _ _ a.2\u27e9", "start": [249, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.union_symm_apply_right", "code": "@[simp]\ntheorem union_symm_apply_right {\u03b1} {s t : Set \u03b1} [DecidablePred fun x => x \u2208 s] (H : s \u2229 t \u2286 \u2205)\n    (a : t) : (Equiv.Set.union H).symm (Sum.inr a) = \u27e8a, subset_union_right _ _ a.2\u27e9", "start": [255, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.singleton", "code": "protected def singleton {\u03b1} (a : \u03b1) : ({a} : Set \u03b1) \u2243 PUnit.{u} :=\n  \u27e8fun _ => PUnit.unit, fun _ => \u27e8a, mem_singleton _\u27e9, fun \u27e8x, h\u27e9 => by\n    simp at h\n    subst x\n    rfl, fun \u27e8\u27e9 => rfl\u27e9", "start": [261, 1], "end": [266, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.ofEq", "code": "@[simps! apply symm_apply]\nprotected def ofEq {\u03b1 : Type u} {s t : Set \u03b1} (h : s = t) : s \u2243 t :=\n  Equiv.setCongr h", "start": [269, 1], "end": [274, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.insert", "code": "protected def insert {\u03b1} {s : Set.{u} \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} (H : a \u2209 s) :\n    (insert a s : Set \u03b1) \u2243 Sum s PUnit.{u + 1} :=\n  calc\n    (insert a s : Set \u03b1) \u2243 \u21a5(s \u222a {a}) := Equiv.Set.ofEq (by simp)\n    _ \u2243 Sum s ({a} : Set \u03b1) := Equiv.Set.union fun x \u27e8hx, _\u27e9 => by simp_all\n    _ \u2243 Sum s PUnit.{u + 1} := sumCongr (Equiv.refl _) (Equiv.Set.singleton _)", "start": [277, 1], "end": [283, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.insert_symm_apply_inl", "code": "@[simp]\ntheorem insert_symm_apply_inl {\u03b1} {s : Set.{u} \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} (H : a \u2209 s)\n    (b : s) : (Equiv.Set.insert H).symm (Sum.inl b) = \u27e8b, Or.inr b.2\u27e9", "start": [286, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.insert_symm_apply_inr", "code": "@[simp]\ntheorem insert_symm_apply_inr {\u03b1} {s : Set.{u} \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} (H : a \u2209 s)\n    (b : PUnit.{u + 1}) : (Equiv.Set.insert H).symm (Sum.inr b) = \u27e8a, Or.inl rfl\u27e9", "start": [292, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.insert_apply_left", "code": "@[simp]\ntheorem insert_apply_left {\u03b1} {s : Set.{u} \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} (H : a \u2209 s) :\n    Equiv.Set.insert H \u27e8a, Or.inl rfl\u27e9 = Sum.inr PUnit.unit", "start": [298, 1], "end": [301, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.insert_apply_right", "code": "@[simp]\ntheorem insert_apply_right {\u03b1} {s : Set.{u} \u03b1} [DecidablePred (\u00b7 \u2208 s)] {a : \u03b1} (H : a \u2209 s) (b : s) :\n    Equiv.Set.insert H \u27e8b, Or.inr b.2\u27e9 = Sum.inl b", "start": [304, 1], "end": [307, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl", "code": "protected def sumCompl {\u03b1} (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] : Sum s (s\u1d9c : Set \u03b1) \u2243 \u03b1 :=\n  calc\n    Sum s (s\u1d9c : Set \u03b1) \u2243 \u21a5(s \u222a s\u1d9c) := (Equiv.Set.union (by simp [Set.ext_iff])).symm\n    _ \u2243 @univ \u03b1 := Equiv.Set.ofEq (by simp)\n    _ \u2243 \u03b1 := Equiv.Set.univ _", "start": [310, 1], "end": [315, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_apply_inl", "code": "@[simp]\ntheorem sumCompl_apply_inl {\u03b1 : Type u} (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] (x : s) :\n    Equiv.Set.sumCompl s (Sum.inl x) = x", "start": [318, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_apply_inr", "code": "@[simp]\ntheorem sumCompl_apply_inr {\u03b1 : Type u} (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] (x : (s\u1d9c : Set \u03b1)) :\n    Equiv.Set.sumCompl s (Sum.inr x) = x", "start": [324, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_symm_apply_of_mem", "code": "theorem sumCompl_symm_apply_of_mem {\u03b1 : Type u} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {x : \u03b1}\n    (hx : x \u2208 s) : (Equiv.Set.sumCompl s).symm x = Sum.inl \u27e8x, hx\u27e9", "start": [330, 1], "end": [334, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_symm_apply_of_not_mem", "code": "theorem sumCompl_symm_apply_of_not_mem {\u03b1 : Type u} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {x : \u03b1}\n    (hx : x \u2209 s) : (Equiv.Set.sumCompl s).symm x = Sum.inr \u27e8x, hx\u27e9", "start": [337, 1], "end": [341, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_symm_apply", "code": "@[simp]\ntheorem sumCompl_symm_apply {\u03b1 : Type*} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {x : s} :\n    (Equiv.Set.sumCompl s).symm x = Sum.inl x", "start": [344, 1], "end": [347, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumCompl_symm_apply_compl", "code": "@[simp]\ntheorem sumCompl_symm_apply_compl {\u03b1 : Type*} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)]\n    {x : (s\u1d9c : Set \u03b1)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x", "start": [350, 1], "end": [353, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumDiffSubset", "code": "protected def sumDiffSubset {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) [DecidablePred (\u00b7 \u2208 s)] :\n    Sum s (t \\ s : Set \u03b1) \u2243 t :=\n  calc\n    Sum s (t \\ s : Set \u03b1) \u2243 (s \u222a t \\ s : Set \u03b1) :=\n      (Equiv.Set.union (by simp [inter_diff_self])).symm\n    _ \u2243 t := Equiv.Set.ofEq (by simp [union_diff_self, union_eq_self_of_subset_left h])", "start": [356, 1], "end": [363, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumDiffSubset_apply_inl", "code": "@[simp]\ntheorem sumDiffSubset_apply_inl {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) [DecidablePred (\u00b7 \u2208 s)] (x : s) :\n    Equiv.Set.sumDiffSubset h (Sum.inl x) = inclusion h x", "start": [366, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumDiffSubset_apply_inr", "code": "@[simp]\ntheorem sumDiffSubset_apply_inr {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) [DecidablePred (\u00b7 \u2208 s)]\n    (x : (t \\ s : Set \u03b1)) : Equiv.Set.sumDiffSubset h (Sum.inr x) = inclusion (diff_subset t s) x", "start": [372, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumDiffSubset_symm_apply_of_mem", "code": "theorem sumDiffSubset_symm_apply_of_mem {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) [DecidablePred (\u00b7 \u2208 s)]\n    {x : t} (hx : x.1 \u2208 s) : (Equiv.Set.sumDiffSubset h).symm x = Sum.inl \u27e8x, hx\u27e9", "start": [378, 1], "end": [382, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sumDiffSubset_symm_apply_of_not_mem", "code": "theorem sumDiffSubset_symm_apply_of_not_mem {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) [DecidablePred (\u00b7 \u2208 s)]\n    {x : t} (hx : x.1 \u2209 s) : (Equiv.Set.sumDiffSubset h).symm x = Sum.inr \u27e8x, \u27e8x.2, hx\u27e9\u27e9", "start": [385, 1], "end": [389, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.unionSumInter", "code": "protected def unionSumInter {\u03b1 : Type u} (s t : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] :\n    Sum (s \u222a t : Set \u03b1) (s \u2229 t : Set \u03b1) \u2243 Sum s t :=\n  calc\n    Sum (s \u222a t : Set \u03b1) (s \u2229 t : Set \u03b1)\n      \u2243 Sum (s \u222a t \\ s : Set \u03b1) (s \u2229 t : Set \u03b1) := by rw [union_diff_self]\n    _ \u2243 Sum (Sum s (t \\ s : Set \u03b1)) (s \u2229 t : Set \u03b1) :=\n      sumCongr (Set.union <| subset_empty_iff.2 (inter_diff_self _ _)) (Equiv.refl _)\n    _ \u2243 Sum s (Sum (t \\ s : Set \u03b1) (s \u2229 t : Set \u03b1)) := sumAssoc _ _ _\n    _ \u2243 Sum s (t \\ s \u222a s \u2229 t : Set \u03b1) :=\n      sumCongr (Equiv.refl _)\n        (by\n          refine' (Set.union' (\u00b7 \u2209 s) _ _).symm\n          exacts [fun x hx => hx.2, fun x hx => not_not_intro hx.1])\n    _ \u2243 Sum s t := by\n      { rw [(_ : t \\ s \u222a s \u2229 t = t)]\n        rw [union_comm, inter_comm, inter_union_diff] }", "start": [392, 1], "end": [409, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.compl", "code": "protected def compl {\u03b1 : Type u} {\u03b2 : Type v} {s : Set \u03b1} {t : Set \u03b2} [DecidablePred (\u00b7 \u2208 s)]\n    [DecidablePred (\u00b7 \u2208 t)] (e\u2080 : s \u2243 t) :\n    { e : \u03b1 \u2243 \u03b2 // \u2200 x : s, e x = e\u2080 x } \u2243 ((s\u1d9c : Set \u03b1) \u2243 (t\u1d9c : Set \u03b2)) where\n  toFun e :=\n    subtypeEquiv e fun a =>\n      not_congr <|\n        Iff.symm <|\n          MapsTo.mem_iff (mapsTo_iff_exists_map_subtype.2 \u27e8e\u2080, e.2\u27e9)\n            (SurjOn.mapsTo_compl\n              (surjOn_iff_exists_map_subtype.2 \u27e8t, e\u2080, Subset.refl t, e\u2080.surjective, e.2\u27e9)\n              e.1.injective)\n  invFun e\u2081 :=\n    Subtype.mk\n      (calc\n        \u03b1 \u2243 Sum s (s\u1d9c : Set \u03b1) := (Set.sumCompl s).symm\n        _ \u2243 Sum t (t\u1d9c : Set \u03b2) := e\u2080.sumCongr e\u2081\n        _ \u2243 \u03b2 := Set.sumCompl t\n        )\n      fun x => by\n      simp only [Sum.map_inl, trans_apply, sumCongr_apply, Set.sumCompl_apply_inl,\n        Set.sumCompl_symm_apply, Trans.trans]\n  left_inv e := by\n    ext x\n    by_cases hx : x \u2208 s\n    \u00b7 simp only [Set.sumCompl_symm_apply_of_mem hx, \u2190 e.prop \u27e8x, hx\u27e9, Sum.map_inl, sumCongr_apply,\n        trans_apply, Subtype.coe_mk, Set.sumCompl_apply_inl, Trans.trans]\n    \u00b7 simp only [Set.sumCompl_symm_apply_of_not_mem hx, Sum.map_inr, subtypeEquiv_apply,\n        Set.sumCompl_apply_inr, trans_apply, sumCongr_apply, Subtype.coe_mk, Trans.trans]\n  right_inv e :=\n    Equiv.ext fun x => by\n      simp only [Sum.map_inr, subtypeEquiv_apply, Set.sumCompl_apply_inr, Function.comp_apply,\n        sumCongr_apply, Equiv.coe_trans, Subtype.coe_eta, Subtype.coe_mk, Trans.trans,\n        Set.sumCompl_symm_apply_compl]", "start": [412, 1], "end": [447, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.prod", "code": "protected def prod {\u03b1 \u03b2} (s : Set \u03b1) (t : Set \u03b2) : \u21a5(s \u00d7\u02e2 t) \u2243 s \u00d7 t :=\n  @subtypeProdEquivProd \u03b1 \u03b2 s t", "start": [450, 1], "end": [452, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.univPi", "code": "@[simps]\nprotected def univPi {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (s : \u2200 a, Set (\u03b2 a)) :\n    pi univ s \u2243 \u2200 a, s a where\n  toFun f a := \u27e8(f : \u2200 a, \u03b2 a) a, f.2 a (mem_univ a)\u27e9\n  invFun f := \u27e8fun a => f a, fun a _ => (f a).2\u27e9\n  left_inv := fun \u27e8f, hf\u27e9 => by\n    ext a\n    rfl\n  right_inv f := by\n    ext a\n    rfl", "start": [455, 1], "end": [466, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.imageOfInjOn", "code": "protected noncomputable def imageOfInjOn {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (H : InjOn f s) :\n    s \u2243 f '' s :=\n  \u27e8fun p => \u27e8f p, mem_image_of_mem f p.2\u27e9, fun p =>\n    \u27e8Classical.choose p.2, (Classical.choose_spec p.2).1\u27e9, fun \u27e8_, h\u27e9 =>\n    Subtype.eq\n      (H (Classical.choose_spec (mem_image_of_mem f h)).1 h\n        (Classical.choose_spec (mem_image_of_mem f h)).2),\n    fun \u27e8_, h\u27e9 => Subtype.eq (Classical.choose_spec h).2\u27e9", "start": [471, 1], "end": [479, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.image", "code": "@[simps! apply]\nprotected noncomputable def image {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (H : Injective f) : s \u2243 f '' s :=\n  Equiv.Set.imageOfInjOn f s (H.injOn s)", "start": [482, 1], "end": [485, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.image_symm_apply", "code": "@[simp]\nprotected theorem image_symm_apply {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (H : Injective f) (x : \u03b1)\n    (h : x \u2208 s) : (Set.image f s H).symm \u27e8f x, \u27e8x, \u27e8h, rfl\u27e9\u27e9\u27e9 = \u27e8x, h\u27e9", "start": [489, 1], "end": [493, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.image_symm_preimage", "code": "theorem image_symm_preimage {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (u s : Set \u03b1) :\n    (fun x => (Set.image f s hf).symm x : f '' s \u2192 \u03b1) \u207b\u00b9' u = Subtype.val \u207b\u00b9' (f '' u)", "start": [496, 1], "end": [500, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.congr", "code": "@[simps]\nprotected def congr {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) : Set \u03b1 \u2243 Set \u03b2 :=\n  \u27e8fun s => e '' s, fun t => e.symm '' t, symm_image_image e, symm_image_image e.symm\u27e9", "start": [503, 1], "end": [506, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.sep", "code": "protected def sep {\u03b1 : Type u} (s : Set \u03b1) (t : \u03b1 \u2192 Prop) :\n    ({ x \u2208 s | t x } : Set \u03b1) \u2243 { x : s | t x } :=\n  (Equiv.subtypeSubtypeEquivSubtypeInter s t).symm", "start": [511, 1], "end": [514, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.powerset", "code": "protected def powerset {\u03b1} (S : Set \u03b1) :\n    \ud835\udcab S \u2243 Set S where\n  toFun := fun x : \ud835\udcab S => Subtype.val \u207b\u00b9' (x : Set \u03b1)\n  invFun := fun x : Set S => \u27e8Subtype.val '' x, by rintro _ \u27e8a : S, _, rfl\u27e9; exact a.2\u27e9\n  left_inv x := by ext y;exact \u27e8fun \u27e8\u27e8_, _\u27e9, h, rfl\u27e9 => h, fun h => \u27e8\u27e8_, x.2 h\u27e9, h, rfl\u27e9\u27e9\n  right_inv x := by ext; simp", "start": [517, 1], "end": [523, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.rangeSplittingImageEquiv", "code": "@[simps]\nnoncomputable def rangeSplittingImageEquiv {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (s : Set (range f)) :\n    rangeSplitting f '' s \u2243 s where\n  toFun x :=\n    \u27e8\u27e8f x, by simp\u27e9, by\n      rcases x with \u27e8x, \u27e8y, \u27e8m, rfl\u27e9\u27e9\u27e9\n      simpa [apply_rangeSplitting f] using m\u27e9\n  invFun x := \u27e8rangeSplitting f x, \u27e8x, \u27e8x.2, rfl\u27e9\u27e9\u27e9\n  left_inv x := by\n    rcases x with \u27e8x, \u27e8y, \u27e8m, rfl\u27e9\u27e9\u27e9\n    simp [apply_rangeSplitting f]\n  right_inv x := by simp [apply_rangeSplitting f]", "start": [526, 1], "end": [540, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.rangeInl", "code": "@[simps symm_apply_coe]\ndef rangeInl (\u03b1 \u03b2 : Type*) : Set.range (Sum.inl : \u03b1 \u2192 \u03b1 \u2295 \u03b2) \u2243 \u03b1 where\n  toFun\n  | \u27e8.inl x, _\u27e9 => x\n  | \u27e8.inr _, h\u27e9 => False.elim <| by rcases h with \u27e8x, h'\u27e9; cases h'\n  invFun x := \u27e8.inl x, mem_range_self _\u27e9\n  left_inv := fun \u27e8_, _, rfl\u27e9 => rfl\n  right_inv x := rfl", "start": [545, 1], "end": [553, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.rangeInl_apply_inl", "code": "@[simp] lemma rangeInl_apply_inl {\u03b1 : Type*} (\u03b2 : Type*) (x : \u03b1) :\n    (rangeInl \u03b1 \u03b2) \u27e8.inl x, mem_range_self _\u27e9 = x :=\n  rfl", "start": [555, 1], "end": [557, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Set.rangeInr", "code": "@[simps symm_apply_coe]\ndef rangeInr (\u03b1 \u03b2 : Type*) : Set.range (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2) \u2243 \u03b2 where\n  toFun\n  | \u27e8.inl _, h\u27e9 => False.elim <| by rcases h with \u27e8x, h'\u27e9; cases h'\n  | \u27e8.inr x, _\u27e9 => x\n  invFun x := \u27e8.inr x, mem_range_self _\u27e9\n  left_inv := fun \u27e8_, _, rfl\u27e9 => rfl\n  right_inv x := rfl", "start": [559, 1], "end": [567, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Set.rangeInr_apply_inr", "code": "@[simp] lemma rangeInr_apply_inr (\u03b1 : Type*) {\u03b2 : Type*} (x : \u03b2) :\n    (rangeInr \u03b1 \u03b2) \u27e8.inr x, mem_range_self _\u27e9 = x :=\n  rfl", "start": [569, 1], "end": [571, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.ofLeftInverse", "code": "@[simps]\ndef ofLeftInverse {\u03b1 \u03b2 : Sort _} (f : \u03b1 \u2192 \u03b2) (f_inv : Nonempty \u03b1 \u2192 \u03b2 \u2192 \u03b1)\n    (hf : \u2200 h : Nonempty \u03b1, LeftInverse (f_inv h) f) :\n    \u03b1 \u2243 range f where\n  toFun a := \u27e8f a, a, rfl\u27e9\n  invFun b := f_inv (nonempty_of_exists b.2) b\n  left_inv a := hf \u27e8a\u27e9 a\n  right_inv := fun \u27e8b, a, ha\u27e9 =>\n    Subtype.eq <| show f (f_inv \u27e8a\u27e9 b) = b from Eq.trans (congr_arg f <| ha \u25b8 hf _ a) ha", "start": [575, 1], "end": [590, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofLeftInverse'", "code": "abbrev ofLeftInverse' {\u03b1 \u03b2 : Sort _} (f : \u03b1 \u2192 \u03b2) (f_inv : \u03b2 \u2192 \u03b1) (hf : LeftInverse f_inv f) :\n    \u03b1 \u2243 range f :=\n  ofLeftInverse f (fun _ => f_inv) fun _ => hf", "start": [595, 1], "end": [601, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofInjective", "code": "@[simps! apply]\nnoncomputable def ofInjective {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (hf : Injective f) : \u03b1 \u2243 range f :=\n  Equiv.ofLeftInverse f (fun _ => Function.invFun f) fun _ => Function.leftInverse_invFun hf", "start": [604, 1], "end": [607, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.apply_ofInjective_symm", "code": "theorem apply_ofInjective_symm {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (b : range f) :\n    f ((ofInjective f hf).symm b) = b", "start": [611, 1], "end": [613, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofInjective_symm_apply", "code": "@[simp]\ntheorem ofInjective_symm_apply {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (a : \u03b1) :\n    (ofInjective f hf).symm \u27e8f a, \u27e8a, rfl\u27e9\u27e9 = a", "start": [616, 1], "end": [620, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_ofInjective_symm", "code": "theorem coe_ofInjective_symm {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    ((ofInjective f hf).symm : range f \u2192 \u03b1) = rangeSplitting f", "start": [623, 1], "end": [627, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.self_comp_ofInjective_symm", "code": "@[simp]\ntheorem self_comp_ofInjective_symm {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    f \u2218 (ofInjective f hf).symm = Subtype.val", "start": [630, 1], "end": [633, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofLeftInverse_eq_ofInjective", "code": "theorem ofLeftInverse_eq_ofInjective {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (f_inv : Nonempty \u03b1 \u2192 \u03b2 \u2192 \u03b1)\n    (hf : \u2200 h : Nonempty \u03b1, LeftInverse (f_inv h) f) :\n    ofLeftInverse f f_inv hf =\n      ofInjective f ((isEmpty_or_nonempty \u03b1).elim (fun h _ _ _ => Subsingleton.elim _ _)\n        (fun h => (hf h).injective))", "start": [636, 1], "end": [642, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofLeftInverse'_eq_ofInjective", "code": "theorem ofLeftInverse'_eq_ofInjective {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (f_inv : \u03b2 \u2192 \u03b1)\n    (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective", "start": [645, 1], "end": [648, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.set_forall_iff", "code": "protected theorem set_forall_iff {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) {p : Set \u03b1 \u2192 Prop} :\n    (\u2200 a, p a) \u2194 \u2200 a, p (e \u207b\u00b9' a)", "start": [651, 1], "end": [653, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.preimage_piEquivPiSubtypeProd_symm_pi", "code": "theorem preimage_piEquivPiSubtypeProd_symm_pi {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] (s : \u2200 i, Set (\u03b2 i)) :\n    (piEquivPiSubtypeProd p \u03b2).symm \u207b\u00b9' pi univ s =\n      (pi univ fun i : { i // p i } => s i) \u00d7\u02e2 pi univ fun i : { i // \u00acp i } => s i", "start": [656, 1], "end": [668, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaPreimageEquiv", "code": "@[simps!]\ndef sigmaPreimageEquiv {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) : (\u03a3b, f \u207b\u00b9' {b}) \u2243 \u03b1 :=\n  sigmaFiberEquiv f", "start": [672, 1], "end": [676, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofPreimageEquiv", "code": "@[simps!]\ndef ofPreimageEquiv {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (e : \u2200 c, f \u207b\u00b9' {c} \u2243 g \u207b\u00b9' {c}) : \u03b1 \u2243 \u03b2 :=\n  Equiv.ofFiberEquiv e", "start": [683, 1], "end": [686, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofPreimageEquiv_map", "code": "theorem ofPreimageEquiv_map {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (e : \u2200 c, f \u207b\u00b9' {c} \u2243 g \u207b\u00b9' {c})\n    (a : \u03b1) : g (ofPreimageEquiv e a) = f a", "start": [691, 1], "end": [693, 29], "kind": "commanddeclaration"}, {"full_name": "Set.BijOn.equiv", "code": "noncomputable def Set.BijOn.equiv {\u03b1 : Type*} {\u03b2 : Type*} {s : Set \u03b1} {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2)\n    (h : BijOn f s t) : s \u2243 t :=\n  Equiv.ofBijective _ h.bijective", "start": [698, 1], "end": [702, 34], "kind": "commanddeclaration"}, {"full_name": "dite_comp_equiv_update", "code": "theorem dite_comp_equiv_update {\u03b1 : Type*} {\u03b2 : Sort*} {\u03b3 : Sort*} {p : \u03b1 \u2192 Prop}\n    (e : \u03b2 \u2243 Subtype p)\n    (v : \u03b2 \u2192 \u03b3) (w : \u03b1 \u2192 \u03b3) (j : \u03b2) (x : \u03b3) [DecidableEq \u03b2] [DecidableEq \u03b1]\n    [\u2200 j, Decidable (p j)] :\n    (fun i : \u03b1 => if h : p i then (Function.update v j x) (e.symm \u27e8i, h\u27e9) else w i) =\n      Function.update (fun i : \u03b1 => if h : p i then v (e.symm \u27e8i, h\u27e9) else w i) (e j) x", "start": [705, 1], "end": [726, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Pairwise.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Data/List/Lex.lean", "Mathlib/Logic/Pairwise.lean", "Mathlib/Data/List/Count.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Pairwise.forall_of_forall", "code": "theorem Pairwise.forall_of_forall (H : Symmetric R) (H\u2081 : \u2200 x \u2208 l, R x x) (H\u2082 : l.Pairwise R) :\n    \u2200 \u2983x\u2984, x \u2208 l \u2192 \u2200 \u2983y\u2984, y \u2208 l \u2192 R x y", "start": [77, 1], "end": [79, 55], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.forall", "code": "theorem Pairwise.forall (hR : Symmetric R) (hl : l.Pairwise R) :\n    \u2200 \u2983a\u2984, a \u2208 l \u2192 \u2200 \u2983b\u2984, b \u2208 l \u2192 a \u2260 b \u2192 R a b", "start": [82, 1], "end": [87, 46], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.set_pairwise", "code": "theorem Pairwise.set_pairwise (hl : Pairwise R l) (hr : Symmetric R) : { x | x \u2208 l }.Pairwise R", "start": [90, 1], "end": [91, 15], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_map'", "code": "@[deprecated] theorem pairwise_map' (f : \u03b2 \u2192 \u03b1) :\n    \u2200 {l : List \u03b2}, Pairwise R (map f l) \u2194 Pairwise (fun a b : \u03b2 => R (f a) (f b)) l", "start": [105, 1], "end": [110, 46], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_pmap", "code": "theorem pairwise_pmap {p : \u03b2 \u2192 Prop} {f : \u2200 b, p b \u2192 \u03b1} {l : List \u03b2} (h : \u2200 x \u2208 l, p x) :\n    Pairwise R (l.pmap f h) \u2194\n      Pairwise (fun b\u2081 b\u2082 => \u2200 (h\u2081 : p b\u2081) (h\u2082 : p b\u2082), R (f b\u2081 h\u2081) (f b\u2082 h\u2082)) l", "start": [125, 1], "end": [134, 19], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.pmap", "code": "theorem Pairwise.pmap {l : List \u03b1} (hl : Pairwise R l) {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2}\n    (h : \u2200 x \u2208 l, p x) {S : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    (hS : \u2200 \u2983x\u2984 (hx : p x) \u2983y\u2984 (hy : p y), R x y \u2192 S (f x hx) (f y hy)) :\n    Pairwise S (l.pmap f h)", "start": [137, 1], "end": [142, 31], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_of_forall_mem_list", "code": "theorem pairwise_of_forall_mem_list {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : \u2200 a \u2208 l, \u2200 b \u2208 l, r a b) :\n    l.Pairwise r", "start": [153, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_of_reflexive_of_forall_ne", "code": "theorem pairwise_of_reflexive_of_forall_ne {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r)\n    (h : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b) : l.Pairwise r", "start": [160, 1], "end": [168, 14], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_iff_nthLe", "code": "@[deprecated pairwise_iff_get]\ntheorem pairwise_iff_nthLe {R} {l : List \u03b1} : Pairwise R l \u2194\n    \u2200 (i j) (h\u2081 : j < length l) (h\u2082 : i < j), R (nthLe l i (lt_trans h\u2082 h\u2081)) (nthLe l j h\u2081)", "start": [172, 1], "end": [177, 35], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.pwFilter", "code": "alias \u27e8_, Pairwise.pwFilter\u27e9 := pwFilter_eq_self", "start": [203, 1], "end": [203, 49], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Data/Set/Pairwise/Basic.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Logic/Pairwise.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "pairwise_on_bool", "code": "theorem pairwise_on_bool (hr : Symmetric r) {a b : \u03b1} :\n    Pairwise (r on fun c => cond c a b) \u2194 r a b", "start": [41, 1], "end": [42, 101], "kind": "commanddeclaration"}, {"full_name": "pairwise_disjoint_on_bool", "code": "theorem pairwise_disjoint_on_bool [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1} :\n    Pairwise (Disjoint on fun c => cond c a b) \u2194 Disjoint a b", "start": [45, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "Symmetric.pairwise_on", "code": "theorem Symmetric.pairwise_on [LinearOrder \u03b9] (hr : Symmetric r) (f : \u03b9 \u2192 \u03b1) :\n    Pairwise (r on f) \u2194 \u2200 \u2983m n\u2984, m < n \u2192 r (f m) (f n)", "start": [50, 1], "end": [52, 99], "kind": "commanddeclaration"}, {"full_name": "pairwise_disjoint_on", "code": "theorem pairwise_disjoint_on [SemilatticeInf \u03b1] [OrderBot \u03b1] [LinearOrder \u03b9] (f : \u03b9 \u2192 \u03b1) :\n    Pairwise (Disjoint on f) \u2194 \u2200 \u2983m n\u2984, m < n \u2192 Disjoint (f m) (f n)", "start": [55, 1], "end": [57, 40], "kind": "commanddeclaration"}, {"full_name": "pairwise_disjoint_mono", "code": "theorem pairwise_disjoint_mono [SemilatticeInf \u03b1] [OrderBot \u03b1] (hs : Pairwise (Disjoint on f))\n    (h : g \u2264 f) : Pairwise (Disjoint on g)", "start": [60, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.mono", "code": "theorem Pairwise.mono (h : t \u2286 s) (hs : s.Pairwise r) : t.Pairwise r", "start": [67, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.mono'", "code": "theorem Pairwise.mono' (H : r \u2264 p) (hr : s.Pairwise r) : s.Pairwise p", "start": [71, 1], "end": [72, 11], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_top", "code": "theorem pairwise_top (s : Set \u03b1) : s.Pairwise \u22a4", "start": [75, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.pairwise", "code": "protected theorem Subsingleton.pairwise (h : s.Subsingleton) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : s.Pairwise r", "start": [79, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_empty", "code": "@[simp]\ntheorem pairwise_empty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : (\u2205 : Set \u03b1).Pairwise r", "start": [83, 1], "end": [85, 32], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_singleton", "code": "@[simp]\ntheorem pairwise_singleton (a : \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Set.Pairwise {a} r", "start": [88, 1], "end": [90, 36], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_iff_of_refl", "code": "theorem pairwise_iff_of_refl [IsRefl \u03b1 r] : s.Pairwise r \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 r a b", "start": [93, 1], "end": [94, 91], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.of_refl", "code": "alias \u27e8Pairwise.of_refl, _\u27e9 := pairwise_iff_of_refl", "start": [97, 1], "end": [97, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Nonempty.pairwise_iff_exists_forall", "code": "theorem Nonempty.pairwise_iff_exists_forall [IsEquiv \u03b1 r] {s : Set \u03b9} (hs : s.Nonempty) :\n    s.Pairwise (r on f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z", "start": [100, 1], "end": [109, 84], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.pairwise_eq_iff_exists_eq", "code": "theorem Nonempty.pairwise_eq_iff_exists_eq {s : Set \u03b1} (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b9} :\n    (s.Pairwise fun x y => f x = f y) \u2194 \u2203 z, \u2200 x \u2208 s, f x = z", "start": [112, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_iff_exists_forall", "code": "theorem pairwise_iff_exists_forall [Nonempty \u03b9] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b9) {r : \u03b9 \u2192 \u03b9 \u2192 Prop}\n    [IsEquiv \u03b9 r] : s.Pairwise (r on f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z", "start": [121, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_eq_iff_exists_eq", "code": "theorem pairwise_eq_iff_exists_eq [Nonempty \u03b9] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b9) :\n    (s.Pairwise fun x y => f x = f y) \u2194 \u2203 z, \u2200 x \u2208 s, f x = z", "start": [128, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_union", "code": "theorem pairwise_union :\n    (s \u222a t).Pairwise r \u2194\n    s.Pairwise r \u2227 t.Pairwise r \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a", "start": [137, 1], "end": [143, 80], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_union_of_symmetric", "code": "theorem pairwise_union_of_symmetric (hr : Symmetric r) :\n    (s \u222a t).Pairwise r \u2194 s.Pairwise r \u2227 t.Pairwise r \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b", "start": [146, 1], "end": [148, 62], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_insert", "code": "theorem pairwise_insert :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a", "start": [151, 1], "end": [154, 15], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_insert_of_not_mem", "code": "theorem pairwise_insert_of_not_mem (ha : a \u2209 s) :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r a b \u2227 r b a", "start": [157, 1], "end": [160, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.insert", "code": "protected theorem Pairwise.insert (hs : s.Pairwise r) (h : \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a) :\n    (insert a s).Pairwise r", "start": [163, 1], "end": [165, 28], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.insert_of_not_mem", "code": "theorem Pairwise.insert_of_not_mem (ha : a \u2209 s) (hs : s.Pairwise r) (h : \u2200 b \u2208 s, r a b \u2227 r b a) :\n    (insert a s).Pairwise r", "start": [168, 1], "end": [170, 44], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_insert_of_symmetric", "code": "theorem pairwise_insert_of_symmetric (hr : Symmetric r) :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b", "start": [173, 1], "end": [175, 54], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_insert_of_symmetric_of_not_mem", "code": "theorem pairwise_insert_of_symmetric_of_not_mem (hr : Symmetric r) (ha : a \u2209 s) :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r a b", "start": [178, 1], "end": [180, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.insert_of_symmetric", "code": "theorem Pairwise.insert_of_symmetric (hs : s.Pairwise r) (hr : Symmetric r)\n    (h : \u2200 b \u2208 s, a \u2260 b \u2192 r a b) : (insert a s).Pairwise r", "start": [183, 1], "end": [185, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.insert_of_symmetric_of_not_mem", "code": "theorem Pairwise.insert_of_symmetric_of_not_mem (hs : s.Pairwise r) (hr : Symmetric r) (ha : a \u2209 s)\n    (h : \u2200 b \u2208 s, r a b) : (insert a s).Pairwise r", "start": [188, 1], "end": [190, 60], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_pair", "code": "theorem pairwise_pair : Set.Pairwise {a, b} r \u2194 a \u2260 b \u2192 r a b \u2227 r b a", "start": [193, 1], "end": [193, 99], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_pair_of_symmetric", "code": "theorem pairwise_pair_of_symmetric (hr : Symmetric r) : Set.Pairwise {a, b} r \u2194 a \u2260 b \u2192 r a b", "start": [196, 1], "end": [197, 41], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_univ", "code": "theorem pairwise_univ : (univ : Set \u03b1).Pairwise r \u2194 Pairwise r", "start": [200, 1], "end": [201, 61], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_bot_iff", "code": "@[simp]\ntheorem pairwise_bot_iff : s.Pairwise (\u22a5 : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 (s : Set \u03b1).Subsingleton", "start": [204, 1], "end": [206, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Pairwise.subsingleton", "code": "alias \u27e8Pairwise.subsingleton, _\u27e9 := pairwise_bot_iff", "start": [209, 1], "end": [209, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.InjOn.pairwise_image", "code": "theorem InjOn.pairwise_image {s : Set \u03b9} (h : s.InjOn f) :\n    (f '' s).Pairwise r \u2194 s.Pairwise (r on f)", "start": [212, 1], "end": [214, 67], "kind": "commanddeclaration"}, {"full_name": "pairwise_subtype_iff_pairwise_set", "code": "theorem pairwise_subtype_iff_pairwise_set (s : Set \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    (Pairwise fun (x : s) (y : s) => r x y) \u2194 s.Pairwise r", "start": [221, 1], "end": [223, 93], "kind": "commanddeclaration"}, {"full_name": "Pairwise.set_of_subtype", "code": "alias \u27e8Pairwise.set_of_subtype, Set.Pairwise.subtype\u27e9 := pairwise_subtype_iff_pairwise_set", "start": [226, 1], "end": [226, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Pairwise.subtype", "code": "alias \u27e8Pairwise.set_of_subtype, Set.Pairwise.subtype\u27e9 := pairwise_subtype_iff_pairwise_set", "start": [226, 1], "end": [226, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.PairwiseDisjoint", "code": "def PairwiseDisjoint (s : Set \u03b9) (f : \u03b9 \u2192 \u03b1) : Prop :=\n  s.Pairwise (Disjoint on f)", "start": [236, 1], "end": [243, 29], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.subset", "code": "theorem PairwiseDisjoint.subset (ht : t.PairwiseDisjoint f) (h : s \u2286 t) : s.PairwiseDisjoint f", "start": [246, 1], "end": [247, 21], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.mono_on", "code": "theorem PairwiseDisjoint.mono_on (hs : s.PairwiseDisjoint f) (h : \u2200 \u2983i\u2984, i \u2208 s \u2192 g i \u2264 f i) :\n    s.PairwiseDisjoint g", "start": [250, 1], "end": [251, 85], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.mono", "code": "theorem PairwiseDisjoint.mono (hs : s.PairwiseDisjoint f) (h : g \u2264 f) : s.PairwiseDisjoint g", "start": [254, 1], "end": [255, 28], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_empty", "code": "@[simp]\ntheorem pairwiseDisjoint_empty : (\u2205 : Set \u03b9).PairwiseDisjoint f", "start": [258, 1], "end": [260, 19], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_singleton", "code": "@[simp]\ntheorem pairwiseDisjoint_singleton (i : \u03b9) (f : \u03b9 \u2192 \u03b1) : PairwiseDisjoint {i} f", "start": [263, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_insert", "code": "theorem pairwiseDisjoint_insert {i : \u03b9} :\n    (insert i s).PairwiseDisjoint f \u2194\n      s.PairwiseDisjoint f \u2227 \u2200 j \u2208 s, i \u2260 j \u2192 Disjoint (f i) (f j)", "start": [268, 1], "end": [271, 61], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_insert_of_not_mem", "code": "theorem pairwiseDisjoint_insert_of_not_mem {i : \u03b9} (hi : i \u2209 s) :\n    (insert i s).PairwiseDisjoint f \u2194 s.PairwiseDisjoint f \u2227 \u2200 j \u2208 s, Disjoint (f i) (f j)", "start": [274, 1], "end": [276, 74], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.insert", "code": "protected theorem PairwiseDisjoint.insert (hs : s.PairwiseDisjoint f) {i : \u03b9}\n    (h : \u2200 j \u2208 s, i \u2260 j \u2192 Disjoint (f i) (f j)) : (insert i s).PairwiseDisjoint f", "start": [279, 1], "end": [281, 36], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.insert_of_not_mem", "code": "theorem PairwiseDisjoint.insert_of_not_mem (hs : s.PairwiseDisjoint f) {i : \u03b9} (hi : i \u2209 s)\n    (h : \u2200 j \u2208 s, Disjoint (f i) (f j)) : (insert i s).PairwiseDisjoint f", "start": [284, 1], "end": [286, 52], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.image_of_le", "code": "theorem PairwiseDisjoint.image_of_le (hs : s.PairwiseDisjoint f) {g : \u03b9 \u2192 \u03b9} (hg : f \u2218 g \u2264 f) :\n    (g '' s).PairwiseDisjoint f", "start": [289, 1], "end": [292, 60], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.pairwiseDisjoint_image", "code": "theorem InjOn.pairwiseDisjoint_image {g : \u03b9' \u2192 \u03b9} {s : Set \u03b9'} (h : s.InjOn g) :\n    (g '' s).PairwiseDisjoint f \u2194 s.PairwiseDisjoint (f \u2218 g)", "start": [295, 1], "end": [297, 19], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.range", "code": "theorem PairwiseDisjoint.range (g : s \u2192 \u03b9) (hg : \u2200 i : s, f (g i) \u2264 f i)\n    (ht : s.PairwiseDisjoint f) : (range g).PairwiseDisjoint f", "start": [300, 1], "end": [303, 87], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_union", "code": "theorem pairwiseDisjoint_union :\n    (s \u222a t).PairwiseDisjoint f \u2194\n      s.PairwiseDisjoint f \u2227\n        t.PairwiseDisjoint f \u2227 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 t \u2192 i \u2260 j \u2192 Disjoint (f i) (f j)", "start": [306, 1], "end": [310, 60], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.union", "code": "theorem PairwiseDisjoint.union (hs : s.PairwiseDisjoint f) (ht : t.PairwiseDisjoint f)\n    (h : \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 t \u2192 i \u2260 j \u2192 Disjoint (f i) (f j)) : (s \u222a t).PairwiseDisjoint f", "start": [313, 1], "end": [315, 39], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.elim", "code": "theorem PairwiseDisjoint.elim (hs : s.PairwiseDisjoint f) {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s)\n    (h : \u00acDisjoint (f i) (f j)) : i = j", "start": [319, 1], "end": [321, 16], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.elim'", "code": "theorem PairwiseDisjoint.elim' (hs : s.PairwiseDisjoint f) {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s)\n    (h : f i \u2293 f j \u2260 \u22a5) : i = j", "start": [331, 1], "end": [333, 42], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.eq_of_le", "code": "theorem PairwiseDisjoint.eq_of_le (hs : s.PairwiseDisjoint f) {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s)\n    (hf : f i \u2260 \u22a5) (hij : f i \u2264 f j) : i = j", "start": [336, 1], "end": [338, 68], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_range_singleton", "code": "theorem pairwiseDisjoint_range_singleton :\n    (range (singleton : \u03b9 \u2192 Set \u03b9)).PairwiseDisjoint id", "start": [347, 1], "end": [350, 50], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_fiber", "code": "theorem pairwiseDisjoint_fiber (f : \u03b9 \u2192 \u03b1) (s : Set \u03b1) : s.PairwiseDisjoint fun a => f \u207b\u00b9' {a}", "start": [353, 1], "end": [354, 95], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.elim_set", "code": "theorem PairwiseDisjoint.elim_set {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (hs : s.PairwiseDisjoint f) {i j : \u03b9}\n    (hi : i \u2208 s) (hj : j \u2208 s) (a : \u03b1) (hai : a \u2208 f i) (haj : a \u2208 f j) : i = j", "start": [358, 1], "end": [360, 52], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.prod", "code": "theorem PairwiseDisjoint.prod {f : \u03b9 \u2192 Set \u03b1} {g : \u03b9' \u2192 Set \u03b2} (hs : s.PairwiseDisjoint f)\n    (ht : t.PairwiseDisjoint g) :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint fun i => f i.1 \u00d7\u02e2 g i.2", "start": [363, 1], "end": [368, 83], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_pi", "code": "theorem pairwiseDisjoint_pi {\u03b9' \u03b1 : \u03b9 \u2192 Type*} {s : \u2200 i, Set (\u03b9' i)} {f : \u2200 i, \u03b9' i \u2192 Set (\u03b1 i)}\n    (hs : \u2200 i, (s i).PairwiseDisjoint (f i)) :\n    ((univ : Set \u03b9).pi s).PairwiseDisjoint fun I => (univ : Set \u03b9).pi fun i => f _ (I i)", "start": [371, 1], "end": [378, 92], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_image_right_iff", "code": "theorem pairwiseDisjoint_image_right_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : \u2200 a \u2208 s, Injective (f a)) :\n    (s.PairwiseDisjoint fun a => f a '' t) \u2194 (s \u00d7\u02e2 t).InjOn fun p => f p.1 p.2", "start": [381, 1], "end": [393, 83], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_image_left_iff", "code": "theorem pairwiseDisjoint_image_left_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : \u2200 b \u2208 t, Injective fun a => f a b) :\n    (t.PairwiseDisjoint fun b => (fun a => f a b) '' s) \u2194 (s \u00d7\u02e2 t).InjOn fun p => f p.1 p.2", "start": [396, 1], "end": [408, 83], "kind": "commanddeclaration"}, {"full_name": "Set.exists_ne_mem_inter_of_not_pairwiseDisjoint", "code": "lemma exists_ne_mem_inter_of_not_pairwiseDisjoint\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac s.PairwiseDisjoint f) :\n    \u2203 i \u2208 s, \u2203 j \u2208 s, \u2203 (_hij : i \u2260 j) (x : \u03b1), x \u2208 f i \u2229 f j := by\n  change \u00ac \u2200 i, i \u2208 s \u2192 \u2200 j, j \u2208 s \u2192 i \u2260 j \u2192 \u2200 t, t \u2264 f i \u2192 t \u2264 f j \u2192 t \u2264 \u22a5 at h\n  simp only [not_forall] at h\n  obtain \u27e8i, hi, j, hj, h_ne, t, hfi, hfj, ht\u27e9 := h\n  replace ht : t.Nonempty := by\n    rwa [le_bot_iff, bot_eq_empty, \u2190 Ne.def, \u2190 nonempty_iff_ne_empty] at ht\n  obtain \u27e8x, hx\u27e9 := ht\n  exact \u27e8i, hi, j, hj, h_ne, x, hfi hx, hfj hx\u27e9", "start": [411, 1], "end": [420, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Set.exists_lt_mem_inter_of_not_pairwiseDisjoint", "code": "lemma exists_lt_mem_inter_of_not_pairwiseDisjoint [LinearOrder \u03b9]\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac s.PairwiseDisjoint f) :\n    \u2203 i \u2208 s, \u2203 j \u2208 s, \u2203 (_hij : i < j) (x : \u03b1), x \u2208 f i \u2229 f j := by\n  obtain \u27e8i, hi, j, hj, hne, x, hx\u2081, hx\u2082\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  cases' lt_or_lt_iff_ne.mpr hne with h_lt h_lt\n  \u00b7 exact \u27e8i, hi, j, hj, h_lt, x, hx\u2081, hx\u2082\u27e9\n  \u00b7 exact \u27e8j, hj, i, hi, h_lt, x, hx\u2082, hx\u2081\u27e9", "start": [422, 1], "end": [428, 44], "kind": "mathlibtacticlemma"}, {"full_name": "exists_ne_mem_inter_of_not_pairwise_disjoint", "code": "lemma exists_ne_mem_inter_of_not_pairwise_disjoint\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac Pairwise (Disjoint on f)) :\n    \u2203 (i j : \u03b9) (_hij : i \u2260 j) (x : \u03b1), x \u2208 f i \u2229 f j := by\n  rw [\u2190 pairwise_univ] at h\n  obtain \u27e8i, _hi, j, _hj, h\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  exact \u27e8i, j, h\u27e9", "start": [432, 1], "end": [437, 18], "kind": "mathlibtacticlemma"}, {"full_name": "exists_lt_mem_inter_of_not_pairwise_disjoint", "code": "lemma exists_lt_mem_inter_of_not_pairwise_disjoint [LinearOrder \u03b9]\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac Pairwise (Disjoint on f)) :\n    \u2203 (i j : \u03b9) (_ : i < j) (x : \u03b1), x \u2208 f i \u2229 f j := by\n  rw [\u2190 pairwise_univ] at h\n  obtain \u27e8i, _hi, j, _hj, h\u27e9 := exists_lt_mem_inter_of_not_pairwiseDisjoint h\n  exact \u27e8i, j, h\u27e9", "start": [439, 1], "end": [444, 18], "kind": "mathlibtacticlemma"}, {"full_name": "pairwise_disjoint_fiber", "code": "theorem pairwise_disjoint_fiber (f : \u03b9 \u2192 \u03b1) : Pairwise (Disjoint on fun a : \u03b1 => f \u207b\u00b9' {a})", "start": [446, 1], "end": [447, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Lattice.lean", "imports": ["Mathlib/Algebra/Order/Monoid/MinMax.lean", "Mathlib/Data/List/Infix.lean", "Mathlib/Data/List/Count.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Disjoint.symm", "code": "@[symm]\ntheorem Disjoint.symm (d : Disjoint l\u2081 l\u2082) : Disjoint l\u2082 l\u2081", "start": [43, 1], "end": [44, 86], "kind": "commanddeclaration"}, {"full_name": "List.mem_union_left", "code": "theorem mem_union_left (h : a \u2208 l\u2081) (l\u2082 : List \u03b1) : a \u2208 l\u2081 \u222a l\u2082", "start": [82, 1], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "List.mem_union_right", "code": "theorem mem_union_right (l\u2081 : List \u03b1) (h : a \u2208 l\u2082) : a \u2208 l\u2081 \u222a l\u2082", "start": [86, 1], "end": [87, 29], "kind": "commanddeclaration"}, {"full_name": "List.sublist_suffix_of_union", "code": "theorem sublist_suffix_of_union : \u2200 l\u2081 l\u2082 : List \u03b1, \u2203 t, t <+ l\u2081 \u2227 t ++ l\u2082 = l\u2081 \u222a l\u2082", "start": [90, 1], "end": [99, 69], "kind": "commanddeclaration"}, {"full_name": "List.suffix_union_right", "code": "theorem suffix_union_right (l\u2081 l\u2082 : List \u03b1) : l\u2082 <:+ l\u2081 \u222a l\u2082", "start": [102, 1], "end": [103, 57], "kind": "commanddeclaration"}, {"full_name": "List.union_sublist_append", "code": "theorem union_sublist_append (l\u2081 l\u2082 : List \u03b1) : l\u2081 \u222a l\u2082 <+ l\u2081 ++ l\u2082", "start": [106, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_union", "code": "theorem forall_mem_union : (\u2200 x \u2208 l\u2081 \u222a l\u2082, p x) \u2194 (\u2200 x \u2208 l\u2081, p x) \u2227 \u2200 x \u2208 l\u2082, p x", "start": [111, 1], "end": [112, 48], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_of_forall_mem_union_left", "code": "theorem forall_mem_of_forall_mem_union_left (h : \u2200 x \u2208 l\u2081 \u222a l\u2082, p x) : \u2200 x \u2208 l\u2081, p x", "start": [115, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_of_forall_mem_union_right", "code": "theorem forall_mem_of_forall_mem_union_right (h : \u2200 x \u2208 l\u2081 \u222a l\u2082, p x) : \u2200 x \u2208 l\u2082, p x", "start": [119, 1], "end": [120, 27], "kind": "commanddeclaration"}, {"full_name": "List.inter_nil", "code": "@[simp]\ntheorem inter_nil (l : List \u03b1) : [] \u2229 l = []", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "List.inter_cons_of_mem", "code": "@[simp]\ntheorem inter_cons_of_mem (l\u2081 : List \u03b1) (h : a \u2208 l\u2082) : (a :: l\u2081) \u2229 l\u2082 = a :: l\u2081 \u2229 l\u2082", "start": [135, 1], "end": [137, 61], "kind": "commanddeclaration"}, {"full_name": "List.inter_cons_of_not_mem", "code": "@[simp]\ntheorem inter_cons_of_not_mem (l\u2081 : List \u03b1) (h : a \u2209 l\u2082) : (a :: l\u2081) \u2229 l\u2082 = l\u2081 \u2229 l\u2082", "start": [140, 1], "end": [142, 61], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_inter_left", "code": "theorem mem_of_mem_inter_left : a \u2208 l\u2081 \u2229 l\u2082 \u2192 a \u2208 l\u2081", "start": [145, 1], "end": [146, 20], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_inter_right", "code": "theorem mem_of_mem_inter_right (h : a \u2208 l\u2081 \u2229 l\u2082) : a \u2208 l\u2082", "start": [149, 1], "end": [149, 92], "kind": "commanddeclaration"}, {"full_name": "List.mem_inter_of_mem_of_mem", "code": "theorem mem_inter_of_mem_of_mem (h\u2081 : a \u2208 l\u2081) (h\u2082 : a \u2208 l\u2082) : a \u2208 l\u2081 \u2229 l\u2082", "start": [152, 1], "end": [153, 43], "kind": "commanddeclaration"}, {"full_name": "List.inter_subset_left", "code": "theorem inter_subset_left (l\u2081 l\u2082 : List \u03b1) : l\u2081 \u2229 l\u2082 \u2286 l\u2081", "start": [158, 1], "end": [159, 18], "kind": "commanddeclaration"}, {"full_name": "List.inter_subset_right", "code": "theorem inter_subset_right (l\u2081 l\u2082 : List \u03b1) : l\u2081 \u2229 l\u2082 \u2286 l\u2082", "start": [162, 1], "end": [162, 94], "kind": "commanddeclaration"}, {"full_name": "List.subset_inter", "code": "theorem subset_inter {l l\u2081 l\u2082 : List \u03b1} (h\u2081 : l \u2286 l\u2081) (h\u2082 : l \u2286 l\u2082) : l \u2286 l\u2081 \u2229 l\u2082", "start": [165, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "List.inter_eq_nil_iff_disjoint", "code": "theorem inter_eq_nil_iff_disjoint : l\u2081 \u2229 l\u2082 = [] \u2194 Disjoint l\u2081 l\u2082", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_inter_of_forall_left", "code": "theorem forall_mem_inter_of_forall_left (h : \u2200 x \u2208 l\u2081, p x) (l\u2082 : List \u03b1) :\n    \u2200 x, x \u2208 l\u2081 \u2229 l\u2082 \u2192 p x", "start": [174, 1], "end": [176, 51], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_inter_of_forall_right", "code": "theorem forall_mem_inter_of_forall_right (l\u2081 : List \u03b1) (h : \u2200 x \u2208 l\u2082, p x) :\n    \u2200 x, x \u2208 l\u2081 \u2229 l\u2082 \u2192 p x", "start": [179, 1], "end": [181, 52], "kind": "commanddeclaration"}, {"full_name": "List.inter_reverse", "code": "@[simp]\ntheorem inter_reverse {xs ys : List \u03b1} : xs.inter ys.reverse = xs.inter ys", "start": [184, 1], "end": [186, 38], "kind": "commanddeclaration"}, {"full_name": "List.nil_bagInter", "code": "@[simp]\ntheorem nil_bagInter (l : List \u03b1) : [].bagInter l = []", "start": [196, 1], "end": [197, 77], "kind": "commanddeclaration"}, {"full_name": "List.bagInter_nil", "code": "@[simp]\ntheorem bagInter_nil (l : List \u03b1) : l.bagInter [] = []", "start": [200, 1], "end": [201, 77], "kind": "commanddeclaration"}, {"full_name": "List.cons_bagInter_of_pos", "code": "@[simp]\ntheorem cons_bagInter_of_pos (l\u2081 : List \u03b1) (h : a \u2208 l\u2082) :\n    (a :: l\u2081).bagInter l\u2082 = a :: l\u2081.bagInter (l\u2082.erase a)", "start": [204, 1], "end": [209, 62], "kind": "commanddeclaration"}, {"full_name": "List.cons_bagInter_of_neg", "code": "@[simp]\ntheorem cons_bagInter_of_neg (l\u2081 : List \u03b1) (h : a \u2209 l\u2082) :\n    (a :: l\u2081).bagInter l\u2082 = l\u2081.bagInter l\u2082", "start": [212, 1], "end": [216, 83], "kind": "commanddeclaration"}, {"full_name": "List.mem_bagInter", "code": "@[simp]\ntheorem mem_bagInter {a : \u03b1} : \u2200 {l\u2081 l\u2082 : List \u03b1}, a \u2208 l\u2081.bagInter l\u2082 \u2194 a \u2208 l\u2081 \u2227 a \u2208 l\u2082", "start": [219, 1], "end": [232, 22], "kind": "commanddeclaration"}, {"full_name": "List.count_bagInter", "code": "@[simp]\ntheorem count_bagInter {a : \u03b1} :\n    \u2200 {l\u2081 l\u2082 : List \u03b1}, count a (l\u2081.bagInter l\u2082) = min (count a l\u2081) (count a l\u2082)", "start": [235, 1], "end": [252, 33], "kind": "commanddeclaration"}, {"full_name": "List.bagInter_sublist_left", "code": "theorem bagInter_sublist_left : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2081.bagInter l\u2082 <+ l\u2081", "start": [255, 1], "end": [261, 34], "kind": "commanddeclaration"}, {"full_name": "List.bagInter_nil_iff_inter_nil", "code": "theorem bagInter_nil_iff_inter_nil : \u2200 l\u2081 l\u2082 : List \u03b1, l\u2081.bagInter l\u2082 = [] \u2194 l\u2081 \u2229 l\u2082 = []", "start": [264, 1], "end": [268, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupPower/Order.lean", "imports": ["Mathlib/Algebra/GroupPower/Ring.lean", "Mathlib/Init/Data/Nat/Basic.lean", "Mathlib/Algebra/Order/Ring/Abs.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "pow_le_pow_of_le_left'", "code": "@[to_additive (attr := mono) nsmul_le_nsmul_of_le_right]\ntheorem pow_le_pow_of_le_left' [CovariantClass M M (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : M} (hab : a \u2264 b) :\n    \u2200 i : \u2115, a ^ i \u2264 b ^ i", "start": [40, 1], "end": [46, 57], "kind": "commanddeclaration"}, {"full_name": "one_le_pow_of_one_le'", "code": "@[to_additive nsmul_nonneg]\ntheorem one_le_pow_of_one_le' {a : M} (H : 1 \u2264 a) : \u2200 n : \u2115, 1 \u2264 a ^ n", "start": [50, 1], "end": [55, 51], "kind": "commanddeclaration"}, {"full_name": "pow_le_one'", "code": "@[to_additive nsmul_nonpos]\ntheorem pow_le_one' {a : M} (H : a \u2264 1) (n : \u2115) : a ^ n \u2264 1", "start": [59, 1], "end": [61, 41], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow'", "code": "@[to_additive nsmul_le_nsmul]\ntheorem pow_le_pow' {a : M} {n m : \u2115} (ha : 1 \u2264 a) (h : n \u2264 m) : a ^ n \u2264 a ^ m", "start": [65, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_of_le_one'", "code": "@[to_additive nsmul_le_nsmul_of_nonpos]\ntheorem pow_le_pow_of_le_one' {a : M} {n m : \u2115} (ha : a \u2264 1) (h : n \u2264 m) : a ^ m \u2264 a ^ n", "start": [74, 1], "end": [76, 36], "kind": "commanddeclaration"}, {"full_name": "one_lt_pow'", "code": "@[to_additive nsmul_pos]\ntheorem one_lt_pow' {a : M} (ha : 1 < a) {k : \u2115} (hk : k \u2260 0) : 1 < a ^ k", "start": [80, 1], "end": [87, 29], "kind": "commanddeclaration"}, {"full_name": "pow_lt_one'", "code": "@[to_additive nsmul_neg]\ntheorem pow_lt_one' {a : M} (ha : a < 1) {k : \u2115} (hk : k \u2260 0) : a ^ k < 1", "start": [91, 1], "end": [93, 35], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow'", "code": "@[to_additive nsmul_lt_nsmul]\ntheorem pow_lt_pow' [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a : M} {n m : \u2115} (ha : 1 < a)\n    (h : n < m) : a ^ n < a ^ m", "start": [97, 1], "end": [102, 66], "kind": "commanddeclaration"}, {"full_name": "pow_strictMono_left", "code": "@[to_additive nsmul_strictMono_right]\ntheorem pow_strictMono_left [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a : M} (ha : 1 < a) :\n    StrictMono ((\u00b7 ^ \u00b7) a : \u2115 \u2192 M)", "start": [106, 1], "end": [108, 64], "kind": "commanddeclaration"}, {"full_name": "Left.one_le_pow_of_le", "code": "@[to_additive Left.pow_nonneg]\ntheorem Left.one_le_pow_of_le (hx : 1 \u2264 x) : \u2200 {n : \u2115}, 1 \u2264 x ^ n", "start": [112, 1], "end": [117, 57], "kind": "commanddeclaration"}, {"full_name": "Left.pow_le_one_of_le", "code": "@[to_additive Left.pow_nonpos]\ntheorem Left.pow_le_one_of_le (hx : x \u2264 1) : \u2200 {n : \u2115}, x ^ n \u2264 1", "start": [121, 1], "end": [126, 57], "kind": "commanddeclaration"}, {"full_name": "Right.one_le_pow_of_le", "code": "@[to_additive Right.pow_nonneg]\ntheorem Right.one_le_pow_of_le (hx : 1 \u2264 x) : \u2200 {n : \u2115}, 1 \u2264 x ^ n", "start": [136, 1], "end": [141, 59], "kind": "commanddeclaration"}, {"full_name": "Right.pow_le_one_of_le", "code": "@[to_additive Right.pow_nonpos]\ntheorem Right.pow_le_one_of_le (hx : x \u2264 1) : \u2200 {n : \u2115}, x ^ n \u2264 1", "start": [145, 1], "end": [150, 59], "kind": "commanddeclaration"}, {"full_name": "StrictMono.pow_right'", "code": "@[to_additive StrictMono.nsmul_left]\ntheorem StrictMono.pow_right' (hf : StrictMono f) : \u2200 {n : \u2115}, n \u2260 0 \u2192 StrictMono fun a => f a ^ n", "start": [161, 1], "end": [167, 60], "kind": "commanddeclaration"}, {"full_name": "pow_strictMono_right'", "code": "@[to_additive nsmul_strictMono_left]  theorem pow_strictMono_right' {n : \u2115} (hn : n \u2260 0) : StrictMono fun a : M => a ^ n", "start": [171, 1], "end": [174, 30], "kind": "commanddeclaration"}, {"full_name": "Monotone.pow_right", "code": "@[to_additive Monotone.nsmul_left]\ntheorem Monotone.pow_right {f : \u03b2 \u2192 M} (hf : Monotone f) : \u2200 n : \u2115, Monotone fun a => f a ^ n", "start": [185, 1], "end": [190, 44], "kind": "commanddeclaration"}, {"full_name": "pow_mono_right", "code": "@[to_additive nsmul_mono_left]\ntheorem pow_mono_right (n : \u2115) : Monotone fun a : M => a ^ n", "start": [194, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "Left.pow_lt_one_of_lt", "code": "@[to_additive Left.pow_neg]\ntheorem Left.pow_lt_one_of_lt [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {n : \u2115} {x : M} (hn : 0 < n)\n    (h : x < 1) : x ^ n < 1", "start": [202, 1], "end": [209, 29], "kind": "commanddeclaration"}, {"full_name": "Right.pow_lt_one_of_lt", "code": "@[to_additive Right.pow_neg]\ntheorem Right.pow_lt_one_of_lt [CovariantClass M M (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {n : \u2115} {x : M}\n    (hn : 0 < n) (h : x < 1) : x ^ n < 1", "start": [213, 1], "end": [220, 29], "kind": "commanddeclaration"}, {"full_name": "one_le_pow_iff", "code": "@[to_additive nsmul_nonneg_iff]\ntheorem one_le_pow_iff {x : M} {n : \u2115} (hn : n \u2260 0) : 1 \u2264 x ^ n \u2194 1 \u2264 x", "start": [234, 1], "end": [236, 89], "kind": "commanddeclaration"}, {"full_name": "pow_le_one_iff", "code": "@[to_additive]\ntheorem pow_le_one_iff {x : M} {n : \u2115} (hn : n \u2260 0) : x ^ n \u2264 1 \u2194 x \u2264 1", "start": [240, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "one_lt_pow_iff", "code": "@[to_additive nsmul_pos_iff]\ntheorem one_lt_pow_iff {x : M} {n : \u2115} (hn : n \u2260 0) : 1 < x ^ n \u2194 1 < x", "start": [246, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "pow_lt_one_iff", "code": "@[to_additive]\ntheorem pow_lt_one_iff {x : M} {n : \u2115} (hn : n \u2260 0) : x ^ n < 1 \u2194 x < 1", "start": [252, 1], "end": [254, 45], "kind": "commanddeclaration"}, {"full_name": "pow_eq_one_iff", "code": "@[to_additive]\ntheorem pow_eq_one_iff {x : M} {n : \u2115} (hn : n \u2260 0) : x ^ n = 1 \u2194 x = 1", "start": [258, 1], "end": [261, 44], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_iff'", "code": "@[to_additive nsmul_le_nsmul_iff]\ntheorem pow_le_pow_iff' (ha : 1 < a) : a ^ m \u2264 a ^ n \u2194 m \u2264 n", "start": [267, 1], "end": [269, 37], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_iff'", "code": "@[to_additive nsmul_lt_nsmul_iff]\ntheorem pow_lt_pow_iff' (ha : 1 < a) : a ^ m < a ^ n \u2194 m < n", "start": [273, 1], "end": [275, 37], "kind": "commanddeclaration"}, {"full_name": "lt_of_pow_lt_pow'", "code": "@[to_additive lt_of_nsmul_lt_nsmul]\ntheorem lt_of_pow_lt_pow' {a b : M} (n : \u2115) : a ^ n < b ^ n \u2192 a < b", "start": [285, 1], "end": [287, 32], "kind": "commanddeclaration"}, {"full_name": "min_lt_of_mul_lt_sq", "code": "@[to_additive min_lt_of_add_lt_two_nsmul]\ntheorem min_lt_of_mul_lt_sq {a b c : M} (h : a * b < c ^ 2) : min a b < c", "start": [291, 1], "end": [293, 65], "kind": "commanddeclaration"}, {"full_name": "lt_max_of_sq_lt_mul", "code": "@[to_additive lt_max_of_two_nsmul_lt_add]\ntheorem lt_max_of_sq_lt_mul {a b c : M} (h : a ^ 2 < b * c) : a < max b c", "start": [297, 1], "end": [299, 69], "kind": "commanddeclaration"}, {"full_name": "le_of_pow_le_pow'", "code": "@[to_additive le_of_nsmul_le_nsmul]\ntheorem le_of_pow_le_pow' {a b : M} {n : \u2115} (hn : n \u2260 0) : a ^ n \u2264 b ^ n \u2192 a \u2264 b", "start": [309, 1], "end": [311, 41], "kind": "commanddeclaration"}, {"full_name": "min_le_of_mul_le_sq", "code": "@[to_additive min_le_of_add_le_two_nsmul]\ntheorem min_le_of_mul_le_sq {a b c : M} (h : a * b \u2264 c ^ 2) : min a b \u2264 c", "start": [315, 1], "end": [317, 65], "kind": "commanddeclaration"}, {"full_name": "le_max_of_sq_le_mul", "code": "@[to_additive le_max_of_two_nsmul_le_add]\ntheorem le_max_of_sq_le_mul {a b c : M} (h : a ^ 2 \u2264 b * c) : a \u2264 max b c", "start": [321, 1], "end": [323, 69], "kind": "commanddeclaration"}, {"full_name": "Left.pow_lt_one_iff'", "code": "@[to_additive Left.nsmul_neg_iff]\ntheorem Left.pow_lt_one_iff' [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {n : \u2115} {x : M} (hn : 0 < n) :\n    x ^ n < 1 \u2194 x < 1", "start": [329, 1], "end": [333, 24], "kind": "commanddeclaration"}, {"full_name": "Left.pow_lt_one_iff", "code": "theorem Left.pow_lt_one_iff [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {n : \u2115} {x : M} (hn : 0 < n) :\n    x ^ n < 1 \u2194 x < 1", "start": [336, 1], "end": [337, 49], "kind": "commanddeclaration"}, {"full_name": "Right.pow_lt_one_iff", "code": "@[to_additive]\ntheorem Right.pow_lt_one_iff [CovariantClass M M (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {n : \u2115} {x : M}\n    (hn : 0 < n) : x ^ n < 1 \u2194 x < 1", "start": [340, 1], "end": [347, 31], "kind": "commanddeclaration"}, {"full_name": "one_le_zpow", "code": "@[to_additive zsmul_nonneg]\ntheorem one_le_zpow {x : G} (H : 1 \u2264 x) {n : \u2124} (hn : 0 \u2264 n) : 1 \u2264 x ^ n", "start": [359, 1], "end": [363, 32], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.pow_pos", "code": "theorem pow_pos {a : R} (H : 0 < a) (n : \u2115) : 0 < a ^ n", "start": [373, 1], "end": [374, 43], "kind": "commanddeclaration"}, {"full_name": "zero_pow_le_one", "code": "theorem zero_pow_le_one : \u2200 n : \u2115, (0 : R) ^ n \u2264 1", "start": [383, 1], "end": [387, 22], "kind": "commanddeclaration"}, {"full_name": "pow_add_pow_le", "code": "theorem pow_add_pow_le (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hn : n \u2260 0) : x ^ n + y ^ n \u2264 (x + y) ^ n", "start": [390, 1], "end": [408, 69], "kind": "commanddeclaration"}, {"full_name": "pow_le_one", "code": "theorem pow_le_one : \u2200 (n : \u2115) (_ : 0 \u2264 a) (_ : a \u2264 1), a ^ n \u2264 1", "start": [411, 1], "end": [413, 86], "kind": "commanddeclaration"}, {"full_name": "pow_lt_one", "code": "theorem pow_lt_one (h\u2080 : 0 \u2264 a) (h\u2081 : a < 1) : \u2200 {n : \u2115} (_ : n \u2260 0), a ^ n < 1", "start": [416, 1], "end": [420, 76], "kind": "commanddeclaration"}, {"full_name": "one_le_pow_of_one_le", "code": "theorem one_le_pow_of_one_le (H : 1 \u2264 a) : \u2200 n : \u2115, 1 \u2264 a ^ n", "start": [423, 1], "end": [428, 83], "kind": "commanddeclaration"}, {"full_name": "pow_mono", "code": "theorem pow_mono (h : 1 \u2264 a) : Monotone fun n : \u2115 => a ^ n", "start": [431, 1], "end": [434, 71], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow", "code": "theorem pow_le_pow (ha : 1 \u2264 a) (h : n \u2264 m) : a ^ n \u2264 a ^ m", "start": [437, 1], "end": [438, 16], "kind": "commanddeclaration"}, {"full_name": "le_self_pow", "code": "theorem le_self_pow (ha : 1 \u2264 a) (h : m \u2260 0) : a \u2264 a ^ m", "start": [441, 1], "end": [442, 69], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_of_le_left", "code": "@[mono]\ntheorem pow_le_pow_of_le_left {a b : R} (ha : 0 \u2264 a) (hab : a \u2264 b) : \u2200 i : \u2115, a ^ i \u2264 b ^ i", "start": [445, 1], "end": [455, 26], "kind": "commanddeclaration"}, {"full_name": "one_lt_pow", "code": "theorem one_lt_pow (ha : 1 < a) : \u2200 {n : \u2115} (_ : n \u2260 0), 1 < a ^ n", "start": [458, 1], "end": [462, 67], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_of_lt_left", "code": "theorem pow_lt_pow_of_lt_left (h : x < y) (hx : 0 \u2264 x) : \u2200 {n : \u2115}, 0 < n \u2192 x ^ n < y ^ n", "start": [471, 1], "end": [475, 97], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_pow", "code": "theorem strictMonoOn_pow (hn : 0 < n) : StrictMonoOn (fun x : R => x ^ n) (Set.Ici 0)", "start": [478, 1], "end": [479, 50], "kind": "commanddeclaration"}, {"full_name": "pow_strictMono_right", "code": "theorem pow_strictMono_right (h : 1 < a) : StrictMono fun n : \u2115 => a ^ n", "start": [482, 1], "end": [485, 97], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow", "code": "theorem pow_lt_pow (h : 1 < a) (h2 : n < m) : a ^ n < a ^ m", "start": [488, 1], "end": [489, 28], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_iff", "code": "theorem pow_lt_pow_iff (h : 1 < a) : a ^ n < a ^ m \u2194 n < m", "start": [492, 1], "end": [493, 37], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_iff", "code": "theorem pow_le_pow_iff (h : 1 < a) : a ^ n \u2264 a ^ m \u2194 n \u2264 m", "start": [496, 1], "end": [497, 37], "kind": "commanddeclaration"}, {"full_name": "self_lt_pow", "code": "theorem self_lt_pow (h : 1 < a) (h2 : 1 < m) : a < a ^ m", "start": [500, 1], "end": [503, 33], "kind": "commanddeclaration"}, {"full_name": "self_le_pow", "code": "theorem self_le_pow (h : 1 \u2264 a) (h2 : 1 \u2264 m) : a \u2264 a ^ m", "start": [505, 1], "end": [506, 48], "kind": "commanddeclaration"}, {"full_name": "strictAnti_pow", "code": "theorem strictAnti_pow (h\u2080 : 0 < a) (h\u2081 : a < 1) : StrictAnti fun n : \u2115 => a ^ n", "start": [508, 1], "end": [510, 89], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_iff_of_lt_one", "code": "theorem pow_lt_pow_iff_of_lt_one (h\u2080 : 0 < a) (h\u2081 : a < 1) : a ^ m < a ^ n \u2194 n < m", "start": [513, 1], "end": [514, 35], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_of_lt_one", "code": "theorem pow_lt_pow_of_lt_one (h : 0 < a) (ha : a < 1) {i j : \u2115} (hij : i < j) : a ^ j < a ^ i", "start": [517, 1], "end": [518, 40], "kind": "commanddeclaration"}, {"full_name": "pow_lt_self_of_lt_one", "code": "theorem pow_lt_self_of_lt_one (h\u2080 : 0 < a) (h\u2081 : a < 1) (hn : 1 < n) : a ^ n < a", "start": [521, 1], "end": [524, 23], "kind": "commanddeclaration"}, {"full_name": "sq_pos_of_pos", "code": "theorem sq_pos_of_pos (ha : 0 < a) : 0 < a ^ 2", "start": [527, 1], "end": [529, 22], "kind": "commanddeclaration"}, {"full_name": "pow_bit0_pos_of_neg", "code": "theorem pow_bit0_pos_of_neg (ha : a < 0) (n : \u2115) : 0 < a ^ bit0 n", "start": [539, 1], "end": [541, 48], "kind": "commanddeclaration"}, {"full_name": "pow_bit1_neg", "code": "theorem pow_bit1_neg (ha : a < 0) (n : \u2115) : a ^ bit1 n < 0", "start": [544, 1], "end": [546, 60], "kind": "commanddeclaration"}, {"full_name": "sq_pos_of_neg", "code": "theorem sq_pos_of_neg (ha : a < 0) : 0 < a ^ 2", "start": [549, 1], "end": [550, 27], "kind": "commanddeclaration"}, {"full_name": "pow_le_one_iff_of_nonneg", "code": "theorem pow_le_one_iff_of_nonneg {a : R} (ha : 0 \u2264 a) {n : \u2115} (hn : n \u2260 0) : a ^ n \u2264 1 \u2194 a \u2264 1", "start": [559, 1], "end": [562, 36], "kind": "commanddeclaration"}, {"full_name": "one_le_pow_iff_of_nonneg", "code": "theorem one_le_pow_iff_of_nonneg {a : R} (ha : 0 \u2264 a) {n : \u2115} (hn : n \u2260 0) : 1 \u2264 a ^ n \u2194 1 \u2264 a", "start": [565, 1], "end": [568, 39], "kind": "commanddeclaration"}, {"full_name": "one_lt_pow_iff_of_nonneg", "code": "theorem one_lt_pow_iff_of_nonneg {a : R} (ha : 0 \u2264 a) {n : \u2115} (hn : n \u2260 0) : 1 < a ^ n \u2194 1 < a", "start": [571, 1], "end": [572, 58], "kind": "commanddeclaration"}, {"full_name": "pow_lt_one_iff_of_nonneg", "code": "theorem pow_lt_one_iff_of_nonneg {a : R} (ha : 0 \u2264 a) {n : \u2115} (hn : n \u2260 0) : a ^ n < 1 \u2194 a < 1", "start": [575, 1], "end": [576, 58], "kind": "commanddeclaration"}, {"full_name": "sq_le_one_iff", "code": "theorem sq_le_one_iff {a : R} (ha : 0 \u2264 a) : a ^ 2 \u2264 1 \u2194 a \u2264 1", "start": [579, 1], "end": [580, 51], "kind": "commanddeclaration"}, {"full_name": "sq_lt_one_iff", "code": "theorem sq_lt_one_iff {a : R} (ha : 0 \u2264 a) : a ^ 2 < 1 \u2194 a < 1", "start": [583, 1], "end": [584, 51], "kind": "commanddeclaration"}, {"full_name": "one_le_sq_iff", "code": "theorem one_le_sq_iff {a : R} (ha : 0 \u2264 a) : 1 \u2264 a ^ 2 \u2194 1 \u2264 a", "start": [587, 1], "end": [588, 51], "kind": "commanddeclaration"}, {"full_name": "one_lt_sq_iff", "code": "theorem one_lt_sq_iff {a : R} (ha : 0 \u2264 a) : 1 < a ^ 2 \u2194 1 < a", "start": [591, 1], "end": [592, 51], "kind": "commanddeclaration"}, {"full_name": "pow_left_inj", "code": "@[simp]\ntheorem pow_left_inj {x y : R} {n : \u2115} (Hxpos : 0 \u2264 x) (Hypos : 0 \u2264 y) (Hnpos : 0 < n) :\n    x ^ n = y ^ n \u2194 x = y", "start": [595, 1], "end": [598, 56], "kind": "commanddeclaration"}, {"full_name": "lt_of_pow_lt_pow", "code": "theorem lt_of_pow_lt_pow {a b : R} (n : \u2115) (hb : 0 \u2264 b) (h : a ^ n < b ^ n) : a < b", "start": [601, 1], "end": [602, 72], "kind": "commanddeclaration"}, {"full_name": "le_of_pow_le_pow", "code": "theorem le_of_pow_le_pow {a b : R} (n : \u2115) (hb : 0 \u2264 b) (hn : 0 < n) (h : a ^ n \u2264 b ^ n) : a \u2264 b", "start": [605, 1], "end": [606, 73], "kind": "commanddeclaration"}, {"full_name": "sq_eq_sq", "code": "@[simp]\ntheorem sq_eq_sq {a b : R} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : a ^ 2 = b ^ 2 \u2194 a = b", "start": [609, 1], "end": [611, 33], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_self_lt_mul_self", "code": "theorem lt_of_mul_self_lt_mul_self (hb : 0 \u2264 b) : a * a < b * b \u2192 a < b", "start": [614, 1], "end": [616, 30], "kind": "commanddeclaration"}, {"full_name": "pow_abs", "code": "theorem pow_abs (a : R) (n : \u2115) : |a| ^ n = |a ^ n|", "start": [625, 1], "end": [626, 51], "kind": "commanddeclaration"}, {"full_name": "abs_neg_one_pow", "code": "theorem abs_neg_one_pow (n : \u2115) : |(-1 : R) ^ n| = 1", "start": [629, 1], "end": [629, 101], "kind": "commanddeclaration"}, {"full_name": "abs_pow_eq_one", "code": "theorem abs_pow_eq_one (a : R) {n : \u2115} (h : 0 < n) : |a ^ n| = 1 \u2194 |a| = 1", "start": [632, 1], "end": [634, 48], "kind": "commanddeclaration"}, {"full_name": "pow_bit0_nonneg", "code": "theorem pow_bit0_nonneg (a : R) (n : \u2115) : 0 \u2264 a ^ bit0 n", "start": [640, 1], "end": [642, 26], "kind": "commanddeclaration"}, {"full_name": "sq_nonneg", "code": "theorem sq_nonneg (a : R) : 0 \u2264 a ^ 2", "start": [645, 1], "end": [646, 22], "kind": "commanddeclaration"}, {"full_name": "pow_two_nonneg", "code": "alias pow_two_nonneg := sq_nonneg", "start": [649, 1], "end": [649, 34], "kind": "stdtacticaliasalias"}, {"full_name": "pow_bit0_pos", "code": "theorem pow_bit0_pos {a : R} (h : a \u2260 0) (n : \u2115) : 0 < a ^ bit0 n", "start": [652, 1], "end": [653, 56], "kind": "commanddeclaration"}, {"full_name": "sq_pos_of_ne_zero", "code": "theorem sq_pos_of_ne_zero (a : R) (h : a \u2260 0) : 0 < a ^ 2", "start": [656, 1], "end": [657, 19], "kind": "commanddeclaration"}, {"full_name": "pow_two_pos_of_ne_zero", "code": "alias pow_two_pos_of_ne_zero := sq_pos_of_ne_zero", "start": [660, 1], "end": [660, 50], "kind": "stdtacticaliasalias"}, {"full_name": "pow_bit0_pos_iff", "code": "theorem pow_bit0_pos_iff (a : R) {n : \u2115} (hn : n \u2260 0) : 0 < a ^ bit0 n \u2194 a \u2260 0", "start": [663, 1], "end": [667, 22], "kind": "commanddeclaration"}, {"full_name": "sq_pos_iff", "code": "theorem sq_pos_iff (a : R) : 0 < a ^ 2 \u2194 a \u2260 0", "start": [672, 1], "end": [673, 33], "kind": "commanddeclaration"}, {"full_name": "sq_abs", "code": "@[simp]\ntheorem sq_abs (x : R) : |x| ^ 2 = x ^ 2", "start": [679, 1], "end": [680, 88], "kind": "commanddeclaration"}, {"full_name": "abs_sq", "code": "theorem abs_sq (x : R) : |x ^ 2| = x ^ 2", "start": [683, 1], "end": [683, 84], "kind": "commanddeclaration"}, {"full_name": "sq_lt_sq", "code": "theorem sq_lt_sq : x ^ 2 < y ^ 2 \u2194 |x| < |y|", "start": [686, 1], "end": [688, 78], "kind": "commanddeclaration"}, {"full_name": "sq_lt_sq'", "code": "theorem sq_lt_sq' (h1 : -y < x) (h2 : x < y) : x ^ 2 < y ^ 2", "start": [691, 1], "end": [692, 66], "kind": "commanddeclaration"}, {"full_name": "sq_le_sq", "code": "theorem sq_le_sq : x ^ 2 \u2264 y ^ 2 \u2194 |x| \u2264 |y|", "start": [695, 1], "end": [697, 78], "kind": "commanddeclaration"}, {"full_name": "sq_le_sq'", "code": "theorem sq_le_sq' (h1 : -y \u2264 x) (h2 : x \u2264 y) : x ^ 2 \u2264 y ^ 2", "start": [700, 1], "end": [701, 62], "kind": "commanddeclaration"}, {"full_name": "abs_lt_of_sq_lt_sq", "code": "theorem abs_lt_of_sq_lt_sq (h : x ^ 2 < y ^ 2) (hy : 0 \u2264 y) : |x| < y", "start": [704, 1], "end": [705, 39], "kind": "commanddeclaration"}, {"full_name": "abs_lt_of_sq_lt_sq'", "code": "theorem abs_lt_of_sq_lt_sq' (h : x ^ 2 < y ^ 2) (hy : 0 \u2264 y) : -y < x \u2227 x < y", "start": [708, 1], "end": [709, 39], "kind": "commanddeclaration"}, {"full_name": "abs_le_of_sq_le_sq", "code": "theorem abs_le_of_sq_le_sq (h : x ^ 2 \u2264 y ^ 2) (hy : 0 \u2264 y) : |x| \u2264 y", "start": [712, 1], "end": [713, 39], "kind": "commanddeclaration"}, {"full_name": "abs_le_of_sq_le_sq'", "code": "theorem abs_le_of_sq_le_sq' (h : x ^ 2 \u2264 y ^ 2) (hy : 0 \u2264 y) : -y \u2264 x \u2227 x \u2264 y", "start": [716, 1], "end": [717, 39], "kind": "commanddeclaration"}, {"full_name": "sq_eq_sq_iff_abs_eq_abs", "code": "theorem sq_eq_sq_iff_abs_eq_abs (x y : R) : x ^ 2 = y ^ 2 \u2194 |x| = |y|", "start": [720, 1], "end": [721, 40], "kind": "commanddeclaration"}, {"full_name": "sq_le_one_iff_abs_le_one", "code": "@[simp]\ntheorem sq_le_one_iff_abs_le_one (x : R) : x ^ 2 \u2264 1 \u2194 |x| \u2264 1", "start": [724, 1], "end": [726, 56], "kind": "commanddeclaration"}, {"full_name": "sq_lt_one_iff_abs_lt_one", "code": "@[simp]\ntheorem sq_lt_one_iff_abs_lt_one (x : R) : x ^ 2 < 1 \u2194 |x| < 1", "start": [729, 1], "end": [731, 56], "kind": "commanddeclaration"}, {"full_name": "one_le_sq_iff_one_le_abs", "code": "@[simp]\ntheorem one_le_sq_iff_one_le_abs (x : R) : 1 \u2264 x ^ 2 \u2194 1 \u2264 |x|", "start": [734, 1], "end": [736, 56], "kind": "commanddeclaration"}, {"full_name": "one_lt_sq_iff_one_lt_abs", "code": "@[simp]\ntheorem one_lt_sq_iff_one_lt_abs (x : R) : 1 < x ^ 2 \u2194 1 < |x|", "start": [739, 1], "end": [741, 56], "kind": "commanddeclaration"}, {"full_name": "pow_four_le_pow_two_of_pow_two_le", "code": "theorem pow_four_le_pow_two_of_pow_two_le {x y : R} (h : x ^ 2 \u2264 y) : x ^ 4 \u2264 y ^ 2", "start": [744, 1], "end": [745, 65], "kind": "commanddeclaration"}, {"full_name": "two_mul_le_add_sq", "code": "theorem two_mul_le_add_sq (a b : R) : 2 * a * b \u2264 a ^ 2 + b ^ 2", "start": [754, 1], "end": [756, 86], "kind": "commanddeclaration"}, {"full_name": "two_mul_le_add_pow_two", "code": "alias two_mul_le_add_pow_two := two_mul_le_add_sq", "start": [759, 1], "end": [759, 50], "kind": "stdtacticaliasalias"}, {"full_name": "pow_pos_iff", "code": "theorem pow_pos_iff (hn : 0 < n) : 0 < a ^ n \u2194 0 < a", "start": [768, 1], "end": [769, 44], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow_succ", "code": "theorem pow_lt_pow_succ (ha : 1 < a) : a ^ n < a ^ n.succ", "start": [778, 1], "end": [780, 70], "kind": "commanddeclaration"}, {"full_name": "pow_lt_pow\u2080", "code": "theorem pow_lt_pow\u2080 (ha : 1 < a) (hmn : m < n) : a ^ m < a ^ n", "start": [783, 1], "end": [785, 64], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_neg_one", "code": "theorem map_neg_one : f (-1) = 1", "start": [794, 1], "end": [795, 84], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_neg", "code": "@[simp]\ntheorem map_neg (x : R) : f (-x) = f x", "start": [798, 1], "end": [799, 95], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_sub_swap", "code": "theorem map_sub_swap (x y : R) : f (x - y) = f (y - x)", "start": [802, 1], "end": [802, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/Set.lean", "imports": ["Mathlib/Logic/Equiv/Set.lean", "Mathlib/Data/Set/Image.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderIso.range_eq", "code": "theorem range_eq (e : \u03b1 \u2243o \u03b2) : Set.range e = Set.univ", "start": [27, 1], "end": [28, 24], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_image_image", "code": "@[simp]\ntheorem symm_image_image (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e.symm '' (e '' s) = s", "start": [31, 1], "end": [33, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_symm_image", "code": "@[simp]\ntheorem image_symm_image (e : \u03b1 \u2243o \u03b2) (s : Set \u03b2) : e '' (e.symm '' s) = s", "start": [36, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_eq_preimage", "code": "theorem image_eq_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e '' s = e.symm \u207b\u00b9' s", "start": [41, 1], "end": [42, 32], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_symm_preimage", "code": "@[simp]\ntheorem preimage_symm_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s", "start": [45, 1], "end": [47, 37], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_preimage_preimage", "code": "@[simp]\ntheorem symm_preimage_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b2) : e.symm \u207b\u00b9' (e \u207b\u00b9' s) = s", "start": [50, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_preimage", "code": "@[simp]\ntheorem image_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b2) : e '' (e \u207b\u00b9' s) = s", "start": [55, 1], "end": [57, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_image", "code": "@[simp]\ntheorem preimage_image (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e '' s) = s", "start": [60, 1], "end": [62, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.setCongr", "code": "def setCongr (s t : Set \u03b1) (h : s = t) :\n    s \u2243o t where\n  toEquiv := Equiv.setCongr h\n  map_rel_iff' := Iff.rfl", "start": [71, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "OrderIso.Set.univ", "code": "def Set.univ : (Set.univ : Set \u03b1) \u2243o \u03b1 where\n  toEquiv := Equiv.Set.univ \u03b1\n  map_rel_iff' := Iff.rfl", "start": [78, 1], "end": [81, 26], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.orderIso", "code": "protected noncomputable def StrictMonoOn.orderIso {\u03b1 \u03b2} [LinearOrder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (s : Set \u03b1) (hf : StrictMonoOn f s) :\n    s \u2243o f '' s where\n  toEquiv := hf.injOn.bijOn_image.equiv _\n  map_rel_iff' := hf.le_iff_le (Subtype.property _) (Subtype.property _)", "start": [86, 1], "end": [92, 73], "kind": "commanddeclaration"}, {"full_name": "StrictMono.orderIso", "code": "@[simps! apply]\nprotected noncomputable def orderIso :\n    \u03b1 \u2243o Set.range f where\n  toEquiv := Equiv.ofInjective f h_mono.injective\n  map_rel_iff' := h_mono.le_iff_le", "start": [101, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "StrictMono.orderIsoOfSurjective", "code": "noncomputable def orderIsoOfSurjective : \u03b1 \u2243o \u03b2 :=\n  (h_mono.orderIso f).trans <|\n    (OrderIso.setCongr _ _ h_surj.range_eq).trans OrderIso.Set.univ", "start": [111, 1], "end": [114, 68], "kind": "commanddeclaration"}, {"full_name": "StrictMono.coe_orderIsoOfSurjective", "code": "@[simp]\ntheorem coe_orderIsoOfSurjective : (orderIsoOfSurjective f h_mono h_surj : \u03b1 \u2192 \u03b2) = f", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "StrictMono.orderIsoOfSurjective_symm_apply_self", "code": "@[simp]\ntheorem orderIsoOfSurjective_symm_apply_self (a : \u03b1) :\n    (orderIsoOfSurjective f h_mono h_surj).symm (f a) = a", "start": [122, 1], "end": [125, 60], "kind": "commanddeclaration"}, {"full_name": "StrictMono.orderIsoOfSurjective_self_symm_apply", "code": "theorem orderIsoOfSurjective_self_symm_apply (b : \u03b2) :\n    f ((orderIsoOfSurjective f h_mono h_surj).symm b) = b", "start": [128, 1], "end": [130, 60], "kind": "commanddeclaration"}, {"full_name": "OrderIso.compl", "code": "@[simps]\ndef OrderIso.compl : \u03b1 \u2243o \u03b1\u1d52\u1d48 where\n  toFun := OrderDual.toDual \u2218 HasCompl.compl\n  invFun := HasCompl.compl \u2218 OrderDual.ofDual\n  left_inv := compl_compl\n  right_inv := compl_compl (\u03b1 := \u03b1\u1d52\u1d48)\n  map_rel_iff' := compl_le_compl_iff_le", "start": [139, 1], "end": [146, 40], "kind": "commanddeclaration"}, {"full_name": "compl_strictAnti", "code": "theorem compl_strictAnti : StrictAnti (compl : \u03b1 \u2192 \u03b1)", "start": [151, 1], "end": [152, 32], "kind": "commanddeclaration"}, {"full_name": "compl_antitone", "code": "theorem compl_antitone : Antitone (compl : \u03b1 \u2192 \u03b1)", "start": [155, 1], "end": [156, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Zip.lean", "imports": ["Mathlib/Algebra/Order/Monoid/MinMax.lean", "Mathlib/Data/List/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.zipWith_eq_nil_iff", "code": "@[simp]\ntheorem zipWith_eq_nil_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {l l'} : zipWith f l l' = [] \u2194 l = [] \u2228 l' = []", "start": [38, 1], "end": [40, 32], "kind": "commanddeclaration"}, {"full_name": "List.zip_swap", "code": "@[simp]\ntheorem zip_swap : \u2200 (l\u2081 : List \u03b1) (l\u2082 : List \u03b2), (zip l\u2081 l\u2082).map Prod.swap = zip l\u2082 l\u2081", "start": [46, 1], "end": [51, 75], "kind": "commanddeclaration"}, {"full_name": "List.all\u2082_zipWith", "code": "theorem all\u2082_zipWith {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {p : \u03b3 \u2192 Prop} :\n    \u2200 {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} (_h : length l\u2081 = length l\u2082),\n      All\u2082 p (zipWith f l\u2081 l\u2082) \u2194 Forall\u2082 (fun x y => p (f x y)) l\u2081 l\u2082", "start": [58, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "List.lt_length_left_of_zipWith", "code": "theorem lt_length_left_of_zipWith {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {i : \u2115} {l : List \u03b1} {l' : List \u03b2}\n    (h : i < (zipWith f l l').length) : i < l.length", "start": [67, 1], "end": [70, 15], "kind": "commanddeclaration"}, {"full_name": "List.lt_length_right_of_zipWith", "code": "theorem lt_length_right_of_zipWith {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {i : \u2115} {l : List \u03b1} {l' : List \u03b2}\n    (h : i < (zipWith f l l').length) : i < l'.length", "start": [73, 1], "end": [76, 16], "kind": "commanddeclaration"}, {"full_name": "List.lt_length_left_of_zip", "code": "theorem lt_length_left_of_zip {i : \u2115} {l : List \u03b1} {l' : List \u03b2} (h : i < (zip l l').length) :\n    i < l.length", "start": [79, 1], "end": [81, 30], "kind": "commanddeclaration"}, {"full_name": "List.lt_length_right_of_zip", "code": "theorem lt_length_right_of_zip {i : \u2115} {l : List \u03b1} {l' : List \u03b2} (h : i < (zip l l').length) :\n    i < l'.length", "start": [84, 1], "end": [86, 31], "kind": "commanddeclaration"}, {"full_name": "List.zip_append", "code": "theorem zip_append :\n    \u2200 {l\u2081 r\u2081 : List \u03b1} {l\u2082 r\u2082 : List \u03b2} (_h : length l\u2081 = length l\u2082),\n      zip (l\u2081 ++ r\u2081) (l\u2082 ++ r\u2082) = zip l\u2081 l\u2082 ++ zip r\u2081 r\u2082", "start": [89, 1], "end": [95, 68], "kind": "commanddeclaration"}, {"full_name": "List.zip_map'", "code": "theorem zip_map' (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) :\n    \u2200 l : List \u03b1, zip (l.map f) (l.map g) = l.map fun a => (f a, g a)", "start": [105, 1], "end": [108, 58], "kind": "commanddeclaration"}, {"full_name": "List.map_zipWith", "code": "theorem map_zipWith {\u03b4 : Type*} (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4 \u2192 \u03b1) (l : List \u03b3) (l' : List \u03b4) :\n    map f (zipWith g l l') = zipWith (fun x y => f (g x y)) l l'", "start": [111, 1], "end": [117, 16], "kind": "commanddeclaration"}, {"full_name": "List.mem_zip", "code": "theorem mem_zip {a b} : \u2200 {l\u2081 : List \u03b1} {l\u2082 : List \u03b2}, (a, b) \u2208 zip l\u2081 l\u2082 \u2192 a \u2208 l\u2081 \u2227 b \u2208 l\u2082", "start": [120, 1], "end": [125, 51], "kind": "commanddeclaration"}, {"full_name": "List.map_fst_zip", "code": "theorem map_fst_zip :\n    \u2200 (l\u2081 : List \u03b1) (l\u2082 : List \u03b2), l\u2081.length \u2264 l\u2082.length \u2192 map Prod.fst (zip l\u2081 l\u2082) = l\u2081", "start": [128, 1], "end": [135, 35], "kind": "commanddeclaration"}, {"full_name": "List.map_snd_zip", "code": "theorem map_snd_zip :\n    \u2200 (l\u2081 : List \u03b1) (l\u2082 : List \u03b2), l\u2082.length \u2264 l\u2081.length \u2192 map Prod.snd (zip l\u2081 l\u2082) = l\u2082", "start": [138, 1], "end": [147, 29], "kind": "commanddeclaration"}, {"full_name": "List.unzip_eq_map", "code": "theorem unzip_eq_map : \u2200 l : List (\u03b1 \u00d7 \u03b2), unzip l = (l.map Prod.fst, l.map Prod.snd)", "start": [154, 1], "end": [156, 71], "kind": "commanddeclaration"}, {"full_name": "List.unzip_left", "code": "theorem unzip_left (l : List (\u03b1 \u00d7 \u03b2)) : (unzip l).1 = l.map Prod.fst", "start": [159, 1], "end": [159, 100], "kind": "commanddeclaration"}, {"full_name": "List.unzip_right", "code": "theorem unzip_right (l : List (\u03b1 \u00d7 \u03b2)) : (unzip l).2 = l.map Prod.snd", "start": [162, 1], "end": [162, 101], "kind": "commanddeclaration"}, {"full_name": "List.unzip_swap", "code": "theorem unzip_swap (l : List (\u03b1 \u00d7 \u03b2)) : unzip (l.map Prod.swap) = (unzip l).swap", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "List.zip_unzip", "code": "theorem zip_unzip : \u2200 l : List (\u03b1 \u00d7 \u03b2), zip (unzip l).1 (unzip l).2 = l", "start": [170, 1], "end": [172, 73], "kind": "commanddeclaration"}, {"full_name": "List.unzip_zip_left", "code": "theorem unzip_zip_left :\n    \u2200 {l\u2081 : List \u03b1} {l\u2082 : List \u03b2}, length l\u2081 \u2264 length l\u2082 \u2192 (unzip (zip l\u2081 l\u2082)).1 = l\u2081", "start": [175, 1], "end": [180, 81], "kind": "commanddeclaration"}, {"full_name": "List.unzip_zip_right", "code": "theorem unzip_zip_right {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} (h : length l\u2082 \u2264 length l\u2081) :\n    (unzip (zip l\u2081 l\u2082)).2 = l\u2082", "start": [183, 1], "end": [184, 89], "kind": "commanddeclaration"}, {"full_name": "List.unzip_zip", "code": "theorem unzip_zip {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} (h : length l\u2081 = length l\u2082) :\n    unzip (zip l\u2081 l\u2082) = (l\u2081, l\u2082)", "start": [187, 1], "end": [190, 63], "kind": "commanddeclaration"}, {"full_name": "List.zip_of_prod", "code": "theorem zip_of_prod {l : List \u03b1} {l' : List \u03b2} {lp : List (\u03b1 \u00d7 \u03b2)} (hl : lp.map Prod.fst = l)\n    (hr : lp.map Prod.snd = l') : lp = l.zip l'", "start": [193, 1], "end": [195, 85], "kind": "commanddeclaration"}, {"full_name": "List.map_prod_left_eq_zip", "code": "theorem map_prod_left_eq_zip {l : List \u03b1} (f : \u03b1 \u2192 \u03b2) :\n    (l.map fun x => (x, f x)) = l.zip (l.map f)", "start": [198, 1], "end": [202, 17], "kind": "commanddeclaration"}, {"full_name": "List.map_prod_right_eq_zip", "code": "theorem map_prod_right_eq_zip {l : List \u03b1} (f : \u03b1 \u2192 \u03b2) :\n    (l.map fun x => (f x, x)) = (l.map f).zip l", "start": [205, 1], "end": [209, 17], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_comm", "code": "theorem zipWith_comm (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2), zipWith f la lb = zipWith (fun b a => f a b) lb la", "start": [212, 1], "end": [216, 59], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_congr", "code": "@[congr]\ntheorem zipWith_congr (f g : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (la : List \u03b1) (lb : List \u03b2)\n    (h : List.Forall\u2082 (fun a b => f a b = g a b) la lb) : zipWith f la lb = zipWith g la lb", "start": [219, 1], "end": [224, 30], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_comm_of_comm", "code": "theorem zipWith_comm_of_comm (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (comm : \u2200 x y : \u03b1, f x y = f y x) (l l' : List \u03b1) :\n    zipWith f l l' = zipWith f l' l", "start": [227, 1], "end": [230, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_same", "code": "@[simp]\ntheorem zipWith_same (f : \u03b1 \u2192 \u03b1 \u2192 \u03b4) : \u2200 l : List \u03b1, zipWith f l l = l.map fun a => f a a", "start": [233, 1], "end": [236, 47], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_zipWith_left", "code": "theorem zipWith_zipWith_left (f : \u03b4 \u2192 \u03b3 \u2192 \u03b5) (g : \u03b1 \u2192 \u03b2 \u2192 \u03b4) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2) (lc : List \u03b3),\n      zipWith f (zipWith g la lb) lc = zipWith3 (fun a b c => f (g a b) c) la lb lc", "start": [239, 1], "end": [245, 89], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_zipWith_right", "code": "theorem zipWith_zipWith_right (f : \u03b1 \u2192 \u03b4 \u2192 \u03b5) (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2) (lc : List \u03b3),\n      zipWith f la (zipWith g lb lc) = zipWith3 (fun a b c => f a (g b c)) la lb lc", "start": [248, 1], "end": [254, 90], "kind": "commanddeclaration"}, {"full_name": "List.zipWith3_same_left", "code": "@[simp]\ntheorem zipWith3_same_left (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2), zipWith3 f la la lb = zipWith (fun a b => f a a b) la lb", "start": [257, 1], "end": [262, 73], "kind": "commanddeclaration"}, {"full_name": "List.zipWith3_same_mid", "code": "@[simp]\ntheorem zipWith3_same_mid (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1 \u2192 \u03b3) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2), zipWith3 f la lb la = zipWith (fun a b => f a b a) la lb", "start": [265, 1], "end": [270, 72], "kind": "commanddeclaration"}, {"full_name": "List.zipWith3_same_right", "code": "@[simp]\ntheorem zipWith3_same_right (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2 \u2192 \u03b3) :\n    \u2200 (la : List \u03b1) (lb : List \u03b2), zipWith3 f la lb lb = zipWith (fun a b => f a b b) la lb", "start": [273, 1], "end": [278, 74], "kind": "commanddeclaration"}, {"full_name": "List.length_revzip", "code": "@[simp]\ntheorem length_revzip (l : List \u03b1) : length (revzip l) = length l", "start": [284, 1], "end": [286, 59], "kind": "commanddeclaration"}, {"full_name": "List.unzip_revzip", "code": "@[simp]\ntheorem unzip_revzip (l : List \u03b1) : (revzip l).unzip = (l, l.reverse)", "start": [289, 1], "end": [291, 36], "kind": "commanddeclaration"}, {"full_name": "List.revzip_map_fst", "code": "@[simp]\ntheorem revzip_map_fst (l : List \u03b1) : (revzip l).map Prod.fst = l", "start": [294, 1], "end": [296, 34], "kind": "commanddeclaration"}, {"full_name": "List.revzip_map_snd", "code": "@[simp]\ntheorem revzip_map_snd (l : List \u03b1) : (revzip l).map Prod.snd = l.reverse", "start": [299, 1], "end": [301, 35], "kind": "commanddeclaration"}, {"full_name": "List.reverse_revzip", "code": "theorem reverse_revzip (l : List \u03b1) : reverse l.revzip = revzip l.reverse", "start": [304, 1], "end": [306, 69], "kind": "commanddeclaration"}, {"full_name": "List.revzip_swap", "code": "theorem revzip_swap (l : List \u03b1) : (revzip l).map Prod.swap = revzip l.reverse", "start": [309, 1], "end": [309, 99], "kind": "commanddeclaration"}, {"full_name": "List.get?_zip_with", "code": "theorem get?_zip_with (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) (i : \u2115) :\n    (zipWith f l\u2081 l\u2082).get? i = ((l\u2081.get? i).map f).bind fun g => (l\u2082.get? i).map g", "start": [312, 1], "end": [319, 75], "kind": "commanddeclaration"}, {"full_name": "List.get?_zip_with_eq_some", "code": "theorem get?_zip_with_eq_some {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) (z : \u03b3) (i : \u2115) :\n    (zipWith f l\u2081 l\u2082).get? i = some z \u2194\n      \u2203 x y, l\u2081.get? i = some x \u2227 l\u2082.get? i = some y \u2227 f x y = z", "start": [322, 1], "end": [328, 25], "kind": "commanddeclaration"}, {"full_name": "List.get?_zip_eq_some", "code": "theorem get?_zip_eq_some (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) (z : \u03b1 \u00d7 \u03b2) (i : \u2115) :\n    (zip l\u2081 l\u2082).get? i = some z \u2194 l\u2081.get? i = some z.1 \u2227 l\u2082.get? i = some z.2", "start": [331, 1], "end": [338, 30], "kind": "commanddeclaration"}, {"full_name": "List.get_zipWith", "code": "@[simp]\ntheorem get_zipWith {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {l : List \u03b1} {l' : List \u03b2} {i : Fin (zipWith f l l').length} :\n    (zipWith f l l').get i =\n      f (l.get \u27e8i, lt_length_left_of_zipWith i.isLt\u27e9)\n        (l'.get \u27e8i, lt_length_right_of_zipWith i.isLt\u27e9)", "start": [341, 1], "end": [349, 66], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_zipWith", "code": "@[simp]\ntheorem nthLe_zipWith {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {l : List \u03b1} {l' : List \u03b2} {i : \u2115}\n    {h : i < (zipWith f l l').length} :\n    (zipWith f l l').nthLe i h =\n      f (l.nthLe i (lt_length_left_of_zipWith h)) (l'.nthLe i (lt_length_right_of_zipWith h))", "start": [351, 1], "end": [356, 28], "kind": "commanddeclaration"}, {"full_name": "List.get_zip", "code": "@[simp]\ntheorem get_zip {l : List \u03b1} {l' : List \u03b2} {i : Fin (zip l l').length} :\n    (zip l l').get i =\n      (l.get \u27e8i, lt_length_left_of_zip i.isLt\u27e9, l'.get \u27e8i, lt_length_right_of_zip i.isLt\u27e9)", "start": [359, 1], "end": [363, 14], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_zip", "code": "@[simp]\ntheorem nthLe_zip {l : List \u03b1} {l' : List \u03b2} {i : \u2115} {h : i < (zip l l').length} :\n    (zip l l').nthLe i h =\n      (l.nthLe i (lt_length_left_of_zip h), l'.nthLe i (lt_length_right_of_zip h))", "start": [365, 1], "end": [369, 16], "kind": "commanddeclaration"}, {"full_name": "List.mem_zip_inits_tails", "code": "theorem mem_zip_inits_tails {l : List \u03b1} {init tail : List \u03b1} :\n    (init, tail) \u2208 zip l.inits l.tails \u2194 init ++ tail = l", "start": [372, 1], "end": [386, 17], "kind": "commanddeclaration"}, {"full_name": "List.map_uncurry_zip_eq_zipWith", "code": "theorem map_uncurry_zip_eq_zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b1) (l' : List \u03b2) :\n    map (Function.uncurry f) (l.zip l') = zipWith f l l'", "start": [389, 1], "end": [396, 16], "kind": "commanddeclaration"}, {"full_name": "List.sum_zipWith_distrib_left", "code": "@[simp]\ntheorem sum_zipWith_distrib_left {\u03b3 : Type*} [Semiring \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (n : \u03b3) (l : List \u03b1)\n    (l' : List \u03b2) : (l.zipWith (fun x y => n * f x y) l').sum = n * (l.zipWith f l').sum", "start": [399, 1], "end": [406, 25], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_distrib_take", "code": "theorem zipWith_distrib_take : (zipWith f l l').take n = zipWith f (l.take n) (l'.take n)", "start": [416, 1], "end": [423, 18], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_distrib_drop", "code": "theorem zipWith_distrib_drop : (zipWith f l l').drop n = zipWith f (l.drop n) (l'.drop n)", "start": [426, 1], "end": [433, 18], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_distrib_tail", "code": "theorem zipWith_distrib_tail : (zipWith f l l').tail = zipWith f l.tail l'.tail", "start": [436, 1], "end": [437, 45], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_append", "code": "theorem zipWith_append (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l la : List \u03b1) (l' lb : List \u03b2)\n    (h : l.length = l'.length) :\n    zipWith f (l ++ la) (l' ++ lb) = zipWith f l l' ++ zipWith f la lb", "start": [440, 1], "end": [449, 20], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_distrib_reverse", "code": "theorem zipWith_distrib_reverse (h : l.length = l'.length) :\n    (zipWith f l l').reverse = zipWith f l.reverse l'.reverse", "start": [452, 1], "end": [460, 51], "kind": "commanddeclaration"}, {"full_name": "List.prod_mul_prod_eq_prod_zipWith_mul_prod_drop", "code": "@[to_additive]\ntheorem prod_mul_prod_eq_prod_zipWith_mul_prod_drop :\n    \u2200 L L' : List \u03b1,\n      L.prod * L'.prod =\n        (zipWith (\u00b7 * \u00b7) L L').prod * (L.drop L'.length).prod * (L'.drop L.length).prod", "start": [469, 1], "end": [482, 11], "kind": "commanddeclaration"}, {"full_name": "List.prod_mul_prod_eq_prod_zipWith_of_length_eq", "code": "@[to_additive]\ntheorem prod_mul_prod_eq_prod_zipWith_of_length_eq (L L' : List \u03b1) (h : L.length = L'.length) :\n    L.prod * L'.prod = (zipWith (\u00b7 * \u00b7) L L').prod", "start": [486, 1], "end": [490, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Nodup.lean", "imports": ["Mathlib/Data/List/Forall2.lean", "Mathlib/Data/List/Lattice.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/Pairwise.lean"], "premises": [{"full_name": "List.forall_mem_ne", "code": "@[simp]\ntheorem forall_mem_ne {a : \u03b1} {l : List \u03b1} : (\u2200 a' : \u03b1, a' \u2208 l \u2192 \u00aca = a') \u2194 a \u2209 l", "start": [29, 1], "end": [31, 56], "kind": "commanddeclaration"}, {"full_name": "List.nodup_nil", "code": "@[simp]\ntheorem nodup_nil : @Nodup \u03b1 []", "start": [34, 1], "end": [36, 15], "kind": "commanddeclaration"}, {"full_name": "List.nodup_cons", "code": "@[simp]\ntheorem nodup_cons {a : \u03b1} {l : List \u03b1} : Nodup (a :: l) \u2194 a \u2209 l \u2227 Nodup l", "start": [39, 1], "end": [41, 50], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.nodup", "code": "protected theorem Pairwise.nodup {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsIrrefl \u03b1 r] (h : Pairwise r l) :\n    Nodup l", "start": [44, 1], "end": [46, 21], "kind": "commanddeclaration"}, {"full_name": "List.rel_nodup", "code": "theorem rel_nodup {r : \u03b1 \u2192 \u03b2 \u2192 Prop} (hr : Relator.BiUnique r) : (Forall\u2082 r \u21d2 (\u00b7 \u2194 \u00b7)) Nodup Nodup", "start": [49, 1], "end": [53, 76], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.cons", "code": "protected theorem Nodup.cons (ha : a \u2209 l) (hl : Nodup l) : Nodup (a :: l)", "start": [56, 1], "end": [57, 24], "kind": "commanddeclaration"}, {"full_name": "List.nodup_singleton", "code": "theorem nodup_singleton (a : \u03b1) : Nodup [a]", "start": [60, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.of_cons", "code": "theorem Nodup.of_cons (h : Nodup (a :: l)) : Nodup l", "start": [64, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.not_mem", "code": "theorem Nodup.not_mem (h : (a :: l).Nodup) : a \u2209 l", "start": [68, 1], "end": [69, 21], "kind": "commanddeclaration"}, {"full_name": "List.not_nodup_cons_of_mem", "code": "theorem not_nodup_cons_of_mem : a \u2208 l \u2192 \u00acNodup (a :: l)", "start": [72, 1], "end": [73, 31], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.sublist", "code": "protected theorem Nodup.sublist : l\u2081 <+ l\u2082 \u2192 Nodup l\u2082 \u2192 Nodup l\u2081", "start": [76, 1], "end": [77, 19], "kind": "commanddeclaration"}, {"full_name": "List.not_nodup_pair", "code": "theorem not_nodup_pair (a : \u03b1) : \u00acNodup [a, a]", "start": [80, 1], "end": [81, 48], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_sublist", "code": "theorem nodup_iff_sublist {l : List \u03b1} : Nodup l \u2194 \u2200 a, \u00ac[a, a] <+ l", "start": [84, 1], "end": [89, 53], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_injective_get", "code": "theorem nodup_iff_injective_get {l : List \u03b1} :\n    Nodup l \u2194 Function.Injective l.get", "start": [93, 1], "end": [102, 71], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_nthLe_inj", "code": "@[deprecated nodup_iff_injective_get]\ntheorem nodup_iff_nthLe_inj {l : List \u03b1} :\n    Nodup l \u2194 \u2200 i j h\u2081 h\u2082, nthLe l i h\u2081 = nthLe l j h\u2082 \u2192 i = j", "start": [105, 1], "end": [110, 59], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.get_inj_iff", "code": "theorem Nodup.get_inj_iff {l : List \u03b1} (h : Nodup l) {i j : Fin l.length} :\n    l.get i = l.get j \u2194 i = j", "start": [113, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.nthLe_inj_iff", "code": "@[deprecated Nodup.get_inj_iff]\ntheorem Nodup.nthLe_inj_iff {l : List \u03b1} (h : Nodup l) {i j : \u2115} (hi : i < l.length)\n    (hj : j < l.length) : l.nthLe i hi = l.nthLe j hj \u2194 i = j", "start": [118, 1], "end": [121, 81], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_get?_ne_get?", "code": "theorem nodup_iff_get?_ne_get? {l : List \u03b1} :\n    l.Nodup \u2194 \u2200 i j : \u2115, i < j \u2192 j < l.length \u2192 l.get? i \u2260 l.get? j", "start": [124, 1], "end": [133, 24], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.ne_singleton_iff", "code": "theorem Nodup.ne_singleton_iff {l : List \u03b1} (h : Nodup l) (x : \u03b1) :\n    l \u2260 [x] \u2194 l = [] \u2228 \u2203 y \u2208 l, y \u2260 x", "start": [136, 1], "end": [147, 44], "kind": "commanddeclaration"}, {"full_name": "List.not_nodup_of_get_eq_of_ne", "code": "theorem not_nodup_of_get_eq_of_ne (xs : List \u03b1) (n m : Fin xs.length)\n    (h : xs.get n = xs.get m) (hne : n \u2260 m) : \u00acNodup xs", "start": [150, 1], "end": [153, 33], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_eq_of_ne_imp_not_nodup", "code": "@[deprecated not_nodup_of_get_eq_of_ne]\ntheorem nthLe_eq_of_ne_imp_not_nodup (xs : List \u03b1) (n m : \u2115) (hn : n < xs.length)\n    (hm : m < xs.length) (h : xs.nthLe n hn = xs.nthLe m hm) (hne : n \u2260 m) : \u00acNodup xs", "start": [156, 1], "end": [161, 33], "kind": "commanddeclaration"}, {"full_name": "List.get_indexOf", "code": "theorem get_indexOf [DecidableEq \u03b1] {l : List \u03b1} (H : Nodup l) (i : Fin l.length) :\n    indexOf (get l i) l = i", "start": [165, 1], "end": [169, 40], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_index_of", "code": "@[simp, deprecated get_indexOf]\ntheorem nthLe_index_of [DecidableEq \u03b1] {l : List \u03b1} (H : Nodup l) (n h) :\n    indexOf (nthLe l n h) l = n", "start": [172, 1], "end": [175, 93], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_count_le_one", "code": "theorem nodup_iff_count_le_one [DecidableEq \u03b1] {l : List \u03b1} : Nodup l \u2194 \u2200 a, count a l \u2264 1", "start": [178, 1], "end": [182, 36], "kind": "commanddeclaration"}, {"full_name": "List.nodup_replicate", "code": "theorem nodup_replicate (a : \u03b1) : \u2200 {n : \u2115}, Nodup (replicate n a) \u2194 n \u2264 1", "start": [185, 1], "end": [191, 44], "kind": "commanddeclaration"}, {"full_name": "List.count_eq_one_of_mem", "code": "@[simp]\ntheorem count_eq_one_of_mem [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (d : Nodup l) (h : a \u2208 l) :\n    count a l = 1", "start": [194, 1], "end": [197, 96], "kind": "commanddeclaration"}, {"full_name": "List.count_eq_of_nodup", "code": "theorem count_eq_of_nodup [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (d : Nodup l) :\n    count a l = if a \u2208 l then 1 else 0", "start": [200, 1], "end": [204, 37], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.of_append_left", "code": "theorem Nodup.of_append_left : Nodup (l\u2081 ++ l\u2082) \u2192 Nodup l\u2081", "start": [207, 1], "end": [208, 44], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.of_append_right", "code": "theorem Nodup.of_append_right : Nodup (l\u2081 ++ l\u2082) \u2192 Nodup l\u2082", "start": [211, 1], "end": [212, 45], "kind": "commanddeclaration"}, {"full_name": "List.nodup_append", "code": "theorem nodup_append {l\u2081 l\u2082 : List \u03b1} : Nodup (l\u2081 ++ l\u2082) \u2194 Nodup l\u2081 \u2227 Nodup l\u2082 \u2227 Disjoint l\u2081 l\u2082", "start": [215, 1], "end": [216, 57], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_of_nodup_append", "code": "theorem disjoint_of_nodup_append {l\u2081 l\u2082 : List \u03b1} (d : Nodup (l\u2081 ++ l\u2082)) : Disjoint l\u2081 l\u2082", "start": [219, 1], "end": [220, 25], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.append", "code": "theorem Nodup.append (d\u2081 : Nodup l\u2081) (d\u2082 : Nodup l\u2082) (dj : Disjoint l\u2081 l\u2082) : Nodup (l\u2081 ++ l\u2082)", "start": [223, 1], "end": [224, 30], "kind": "commanddeclaration"}, {"full_name": "List.nodup_append_comm", "code": "theorem nodup_append_comm {l\u2081 l\u2082 : List \u03b1} : Nodup (l\u2081 ++ l\u2082) \u2194 Nodup (l\u2082 ++ l\u2081)", "start": [227, 1], "end": [228, 57], "kind": "commanddeclaration"}, {"full_name": "List.nodup_middle", "code": "theorem nodup_middle {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    Nodup (l\u2081 ++ a :: l\u2082) \u2194 Nodup (a :: (l\u2081 ++ l\u2082))", "start": [231, 1], "end": [234, 25], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.of_map", "code": "theorem Nodup.of_map (f : \u03b1 \u2192 \u03b2) {l : List \u03b1} : Nodup (map f l) \u2192 Nodup l", "start": [237, 1], "end": [238, 51], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.map_on", "code": "theorem Nodup.map_on {f : \u03b1 \u2192 \u03b2} (H : \u2200 x \u2208 l, \u2200 y \u2208 l, f x = f y \u2192 x = y) (d : Nodup l) :\n    (map f l).Nodup", "start": [241, 1], "end": [243, 85], "kind": "commanddeclaration"}, {"full_name": "List.inj_on_of_nodup_map", "code": "theorem inj_on_of_nodup_map {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} (d : Nodup (map f l)) :\n    \u2200 \u2983x\u2984, x \u2208 l \u2192 \u2200 \u2983y\u2984, y \u2208 l \u2192 f x = f y \u2192 x = y", "start": [246, 1], "end": [256, 28], "kind": "commanddeclaration"}, {"full_name": "List.nodup_map_iff_inj_on", "code": "theorem nodup_map_iff_inj_on {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} (d : Nodup l) :\n    Nodup (map f l) \u2194 \u2200 x \u2208 l, \u2200 y \u2208 l, f x = f y \u2192 x = y", "start": [259, 1], "end": [261, 45], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.map", "code": "protected theorem Nodup.map {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : Nodup l \u2192 Nodup (map f l)", "start": [264, 1], "end": [265, 37], "kind": "commanddeclaration"}, {"full_name": "List.nodup_map_iff", "code": "theorem nodup_map_iff {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} (hf : Injective f) : Nodup (map f l) \u2194 Nodup l", "start": [268, 1], "end": [269, 33], "kind": "commanddeclaration"}, {"full_name": "List.nodup_attach", "code": "@[simp]\ntheorem nodup_attach {l : List \u03b1} : Nodup (attach l) \u2194 Nodup l", "start": [272, 1], "end": [275, 60], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.of_attach", "code": "alias \u27e8Nodup.of_attach, Nodup.attach\u27e9 := nodup_attach", "start": [278, 1], "end": [278, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.Nodup.attach", "code": "alias \u27e8Nodup.of_attach, Nodup.attach\u27e9 := nodup_attach", "start": [278, 1], "end": [278, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.Nodup.pmap", "code": "theorem Nodup.pmap {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {l : List \u03b1} {H}\n    (hf : \u2200 a ha b hb, f a ha = f b hb \u2192 a = b) (h : Nodup l) : Nodup (pmap f l H)", "start": [285, 1], "end": [288, 89], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.filter", "code": "theorem Nodup.filter (p : \u03b1 \u2192 Bool) {l} : Nodup l \u2192 Nodup (filter p l)", "start": [291, 1], "end": [292, 44], "kind": "commanddeclaration"}, {"full_name": "List.nodup_reverse", "code": "@[simp]\ntheorem nodup_reverse {l : List \u03b1} : Nodup (reverse l) \u2194 Nodup l", "start": [295, 1], "end": [297, 66], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.erase_eq_filter", "code": "theorem Nodup.erase_eq_filter [DecidableEq \u03b1] {l} (d : Nodup l) (a : \u03b1) :\n    l.erase a = l.filter (\u00b7 \u2260 a)", "start": [300, 1], "end": [310, 13], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.erase", "code": "theorem Nodup.erase [DecidableEq \u03b1] (a : \u03b1) : Nodup l \u2192 Nodup (l.erase a)", "start": [313, 1], "end": [314, 37], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.diff", "code": "theorem Nodup.diff [DecidableEq \u03b1] : l\u2081.Nodup \u2192 (l\u2081.diff l\u2082).Nodup", "start": [317, 1], "end": [318, 36], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.mem_erase_iff", "code": "theorem Nodup.mem_erase_iff [DecidableEq \u03b1] (d : Nodup l) : a \u2208 l.erase b \u2194 a \u2260 b \u2227 a \u2208 l", "start": [321, 1], "end": [322, 67], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.not_mem_erase", "code": "theorem Nodup.not_mem_erase [DecidableEq \u03b1] (h : Nodup l) : a \u2209 l.erase a", "start": [325, 1], "end": [326, 30], "kind": "commanddeclaration"}, {"full_name": "List.nodup_join", "code": "theorem nodup_join {L : List (List \u03b1)} :\n    Nodup (join L) \u2194 (\u2200 l \u2208 L, Nodup l) \u2227 Pairwise Disjoint L", "start": [329, 1], "end": [331, 70], "kind": "commanddeclaration"}, {"full_name": "List.nodup_bind", "code": "theorem nodup_bind {l\u2081 : List \u03b1} {f : \u03b1 \u2192 List \u03b2} :\n    Nodup (l\u2081.bind f) \u2194\n      (\u2200 x \u2208 l\u2081, Nodup (f x)) \u2227 Pairwise (fun a b : \u03b1 => Disjoint (f a) (f b)) l\u2081", "start": [334, 1], "end": [340, 67], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.product", "code": "protected theorem Nodup.product {l\u2082 : List \u03b2} (d\u2081 : l\u2081.Nodup) (d\u2082 : l\u2082.Nodup) :\n    (l\u2081 \u00d7\u02e2 l\u2082).Nodup", "start": [343, 1], "end": [350, 21], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.sigma", "code": "theorem Nodup.sigma {\u03c3 : \u03b1 \u2192 Type*} {l\u2082 : \u2200 a , List (\u03c3 a)} (d\u2081 : Nodup l\u2081)\n    (d\u2082 : \u2200 a , Nodup (l\u2082 a)) : (l\u2081.sigma l\u2082).Nodup", "start": [353, 1], "end": [360, 21], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.filterMap", "code": "protected theorem Nodup.filterMap {f : \u03b1 \u2192 Option \u03b2} (h : \u2200 a a' b, b \u2208 f a \u2192 b \u2208 f a' \u2192 a = a') :\n    Nodup l \u2192 Nodup (filterMap f l)", "start": [363, 1], "end": [365, 98], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.concat", "code": "protected theorem Nodup.concat (h : a \u2209 l) (h' : l.Nodup) : (l.concat a).Nodup", "start": [368, 1], "end": [369, 86], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.insert", "code": "protected theorem Nodup.insert [DecidableEq \u03b1] (h : l.Nodup) : (l.insert a).Nodup", "start": [372, 1], "end": [374, 76], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.union", "code": "theorem Nodup.union [DecidableEq \u03b1] (l\u2081 : List \u03b1) (h : Nodup l\u2082) : (l\u2081 \u222a l\u2082).Nodup", "start": [377, 1], "end": [380, 24], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.inter", "code": "theorem Nodup.inter [DecidableEq \u03b1] (l\u2082 : List \u03b1) : Nodup l\u2081 \u2192 Nodup (l\u2081 \u2229 l\u2082)", "start": [383, 1], "end": [384, 17], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.diff_eq_filter", "code": "theorem Nodup.diff_eq_filter [DecidableEq \u03b1] :\n    \u2200 {l\u2081 l\u2082 : List \u03b1} (_ : l\u2081.Nodup), l\u2081.diff l\u2082 = l\u2081.filter (\u00b7 \u2209 l\u2082)", "start": [387, 1], "end": [393, 48], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.mem_diff_iff", "code": "theorem Nodup.mem_diff_iff [DecidableEq \u03b1] (hl\u2081 : l\u2081.Nodup) : a \u2208 l\u2081.diff l\u2082 \u2194 a \u2208 l\u2081 \u2227 a \u2209 l\u2082", "start": [396, 1], "end": [397, 58], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.set", "code": "protected theorem Nodup.set :\n    \u2200 {l : List \u03b1} {n : \u2115} {a : \u03b1} (_ : l.Nodup) (_ : a \u2209 l), (l.set n a).Nodup", "start": [400, 1], "end": [408, 52], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.map_update", "code": "theorem Nodup.map_update [DecidableEq \u03b1] {l : List \u03b1} (hl : l.Nodup) (f : \u03b1 \u2192 \u03b2) (x : \u03b1) (y : \u03b2) :\n    l.map (Function.update f x y) =\n      if x \u2208 l then (l.map f).set (l.indexOf x) y else l.map f", "start": [411, 1], "end": [420, 56], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.pairwise_of_forall_ne", "code": "theorem Nodup.pairwise_of_forall_ne {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hl : l.Nodup)\n    (h : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b) : l.Pairwise r", "start": [423, 1], "end": [431, 14], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.pairwise_of_set_pairwise", "code": "theorem Nodup.pairwise_of_set_pairwise {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hl : l.Nodup)\n    (h : { x | x \u2208 l }.Pairwise r) : l.Pairwise r", "start": [434, 1], "end": [436, 29], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.pairwise_coe", "code": "@[simp]\ntheorem Nodup.pairwise_coe [IsSymm \u03b1 r] (hl : l.Nodup) :\n    { a | a \u2208 l }.Pairwise r \u2194 l.Pairwise r", "start": [439, 1], "end": [448, 24], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.take_eq_filter_mem", "code": "theorem Nodup.take_eq_filter_mem [DecidableEq \u03b1] :\n    \u2200 {l : List \u03b1} {n : \u2115} (_ : l.Nodup), l.take n = l.filter (\u00b7 \u2208 l.take n)", "start": [452, 1], "end": [462, 70], "kind": "commanddeclaration"}, {"full_name": "Option.toList_nodup", "code": "theorem Option.toList_nodup {\u03b1} : \u2200 o : Option \u03b1, o.toList.Nodup", "start": [465, 1], "end": [467, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Chain.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Data/List/Pairwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Chain.iff", "code": "theorem Chain.iff {S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2194 S a b) {a : \u03b1} {l : List \u03b1} :\n    Chain R a l \u2194 Chain S a l", "start": [40, 1], "end": [42, 67], "kind": "commanddeclaration"}, {"full_name": "List.Chain.iff_mem", "code": "theorem Chain.iff_mem {a : \u03b1} {l : List \u03b1} :\n    Chain R a l \u2194 Chain (fun x y => x \u2208 a :: l \u2227 y \u2208 l \u2227 R x y) a l", "start": [45, 1], "end": [51, 34], "kind": "commanddeclaration"}, {"full_name": "List.chain_singleton", "code": "theorem chain_singleton {a b : \u03b1} : Chain R a [b] \u2194 R a b", "start": [54, 1], "end": [55, 50], "kind": "commanddeclaration"}, {"full_name": "List.chain_split", "code": "theorem chain_split {a b : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    Chain R a (l\u2081 ++ b :: l\u2082) \u2194 Chain R a (l\u2081 ++ [b]) \u2227 Chain R b l\u2082", "start": [58, 1], "end": [61, 91], "kind": "commanddeclaration"}, {"full_name": "List.chain_append_cons_cons", "code": "@[simp]\ntheorem chain_append_cons_cons {a b c : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    Chain R a (l\u2081 ++ b :: c :: l\u2082) \u2194 Chain R a (l\u2081 ++ [b]) \u2227 R b c \u2227 Chain R c l\u2082", "start": [64, 1], "end": [67, 31], "kind": "commanddeclaration"}, {"full_name": "List.chain_iff_forall\u2082", "code": "theorem chain_iff_forall\u2082 :\n    \u2200 {a : \u03b1} {l : List \u03b1}, Chain R a l \u2194 l = [] \u2228 Forall\u2082 R (a :: dropLast l) l", "start": [70, 1], "end": [75, 47], "kind": "commanddeclaration"}, {"full_name": "List.chain_append_singleton_iff_forall\u2082", "code": "theorem chain_append_singleton_iff_forall\u2082 : Chain R a (l ++ [b]) \u2194 Forall\u2082 R (a :: l) (l ++ [b])", "start": [78, 1], "end": [79, 30], "kind": "commanddeclaration"}, {"full_name": "List.chain_map", "code": "theorem chain_map (f : \u03b2 \u2192 \u03b1) {b : \u03b2} {l : List \u03b2} :\n    Chain R (f b) (map f l) \u2194 Chain (fun a b : \u03b2 => R (f a) (f b)) b l", "start": [82, 1], "end": [84, 75], "kind": "commanddeclaration"}, {"full_name": "List.chain_of_chain_map", "code": "theorem chain_of_chain_map {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, S (f a) (f b) \u2192 R a b)\n    {a : \u03b1} {l : List \u03b1} (p : Chain S (f a) (map f l)) : Chain R a l", "start": [87, 1], "end": [89, 28], "kind": "commanddeclaration"}, {"full_name": "List.chain_map_of_chain", "code": "theorem chain_map_of_chain {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, R a b \u2192 S (f a) (f b))\n    {a : \u03b1} {l : List \u03b1} (p : Chain R a l) : Chain S (f a) (map f l)", "start": [92, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "List.chain_pmap_of_chain", "code": "theorem chain_pmap_of_chain {S : \u03b2 \u2192 \u03b2 \u2192 Prop} {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2}\n    (H : \u2200 a b ha hb, R a b \u2192 S (f a ha) (f b hb)) {a : \u03b1} {l : List \u03b1} (hl\u2081 : Chain R a l)\n    (ha : p a) (hl\u2082 : \u2200 a \u2208 l, p a) : Chain S (f a ha) (List.pmap f l hl\u2082)", "start": [97, 1], "end": [102, 77], "kind": "commanddeclaration"}, {"full_name": "List.chain_of_chain_pmap", "code": "theorem chain_of_chain_pmap {S : \u03b2 \u2192 \u03b2 \u2192 Prop} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l : List \u03b1}\n    (hl\u2081 : \u2200 a \u2208 l, p a) {a : \u03b1} (ha : p a) (hl\u2082 : Chain S (f a ha) (List.pmap f l hl\u2081))\n    (H : \u2200 a b ha hb, S (f a ha) (f b hb) \u2192 R a b) : Chain R a l", "start": [105, 1], "end": [110, 81], "kind": "commanddeclaration"}, {"full_name": "List.Chain.pairwise", "code": "protected theorem Chain.pairwise [IsTrans \u03b1 R] :\n    \u2200 {a : \u03b1} {l : List \u03b1}, Chain R a l \u2192 Pairwise R (a :: l)", "start": [115, 1], "end": [122, 80], "kind": "commanddeclaration"}, {"full_name": "List.chain_iff_pairwise", "code": "theorem chain_iff_pairwise [IsTrans \u03b1 R] {a : \u03b1} {l : List \u03b1} : Chain R a l \u2194 Pairwise R (a :: l)", "start": [125, 1], "end": [126, 35], "kind": "commanddeclaration"}, {"full_name": "List.Chain.sublist", "code": "protected theorem Chain.sublist [IsTrans \u03b1 R] (hl : l\u2082.Chain R a) (h : l\u2081 <+ l\u2082) :\n    l\u2081.Chain R a", "start": [129, 1], "end": [132, 35], "kind": "commanddeclaration"}, {"full_name": "List.Chain.rel", "code": "protected theorem Chain.rel [IsTrans \u03b1 R] (hl : l.Chain R a) (hb : b \u2208 l) : R a b", "start": [135, 1], "end": [137, 35], "kind": "commanddeclaration"}, {"full_name": "List.chain_iff_get", "code": "theorem chain_iff_get {R} : \u2200 {a : \u03b1} {l : List \u03b1}, Chain R a l \u2194\n    (\u2200 h : 0 < length l, R a (get l \u27e80, h\u27e9)) \u2227\n      \u2200 (i : \u2115) (h : i < l.length - 1),\n        R (get l \u27e8i, lt_of_lt_pred h\u27e9) (get l \u27e8i+1, lt_pred_iff.mp h\u27e9)", "start": [140, 1], "end": [162, 37], "kind": "commanddeclaration"}, {"full_name": "List.chain_iff_nthLe", "code": "@[deprecated chain_iff_get]\ntheorem chain_iff_nthLe {R} {a : \u03b1} {l : List \u03b1} : Chain R a l \u2194\n    (\u2200 h : 0 < length l, R a (nthLe l 0 h)) \u2227\n    \u2200 (i) (h : i < length l - 1),\n    R (nthLe l i (lt_of_lt_pred h)) (nthLe l (i + 1) (lt_pred_iff.mp h))", "start": [165, 1], "end": [170, 38], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.imp", "code": "theorem Chain'.imp {S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2192 S a b) {l : List \u03b1} (p : Chain' R l) :\n    Chain' S l", "start": [173, 1], "end": [174, 64], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.iff", "code": "theorem Chain'.iff {S : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, R a b \u2194 S a b) {l : List \u03b1} :\n    Chain' R l \u2194 Chain' S l", "start": [177, 1], "end": [179, 69], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.iff_mem", "code": "theorem Chain'.iff_mem : \u2200 {l : List \u03b1}, Chain' R l \u2194 Chain' (fun x y => x \u2208 l \u2227 y \u2208 l \u2227 R x y) l", "start": [182, 1], "end": [186, 37], "kind": "commanddeclaration"}, {"full_name": "List.chain'_nil", "code": "@[simp]\ntheorem chain'_nil : Chain' R []", "start": [189, 1], "end": [191, 10], "kind": "commanddeclaration"}, {"full_name": "List.chain'_singleton", "code": "@[simp]\ntheorem chain'_singleton (a : \u03b1) : Chain' R [a]", "start": [194, 1], "end": [196, 12], "kind": "commanddeclaration"}, {"full_name": "List.chain'_cons", "code": "@[simp]\ntheorem chain'_cons {x y l} : Chain' R (x :: y :: l) \u2194 R x y \u2227 Chain' R (y :: l)", "start": [199, 1], "end": [201, 13], "kind": "commanddeclaration"}, {"full_name": "List.chain'_isInfix", "code": "theorem chain'_isInfix : \u2200 l : List \u03b1, Chain' (fun x y => [x, y] <:+: l) l", "start": [204, 1], "end": [209, 96], "kind": "commanddeclaration"}, {"full_name": "List.chain'_split", "code": "theorem chain'_split {a : \u03b1} :\n    \u2200 {l\u2081 l\u2082 : List \u03b1}, Chain' R (l\u2081 ++ a :: l\u2082) \u2194 Chain' R (l\u2081 ++ [a]) \u2227 Chain' R (a :: l\u2082)", "start": [212, 1], "end": [215, 29], "kind": "commanddeclaration"}, {"full_name": "List.chain'_append_cons_cons", "code": "@[simp]\ntheorem chain'_append_cons_cons {b c : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    Chain' R (l\u2081 ++ b :: c :: l\u2082) \u2194 Chain' R (l\u2081 ++ [b]) \u2227 R b c \u2227 Chain' R (c :: l\u2082)", "start": [218, 1], "end": [221, 33], "kind": "commanddeclaration"}, {"full_name": "List.chain'_map", "code": "theorem chain'_map (f : \u03b2 \u2192 \u03b1) {l : List \u03b2} :\n    Chain' R (map f l) \u2194 Chain' (fun a b : \u03b2 => R (f a) (f b)) l", "start": [224, 1], "end": [226, 39], "kind": "commanddeclaration"}, {"full_name": "List.chain'_of_chain'_map", "code": "theorem chain'_of_chain'_map {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, S (f a) (f b) \u2192 R a b)\n    {l : List \u03b1} (p : Chain' S (map f l)) : Chain' R l", "start": [229, 1], "end": [231, 29], "kind": "commanddeclaration"}, {"full_name": "List.chain'_map_of_chain'", "code": "theorem chain'_map_of_chain' {S : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b : \u03b1, R a b \u2192 S (f a) (f b))\n    {l : List \u03b1} (p : Chain' R l) : Chain' S (map f l)", "start": [234, 1], "end": [236, 30], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.chain'", "code": "theorem Pairwise.chain' : \u2200 {l : List \u03b1}, Pairwise R l \u2192 Chain' R l", "start": [239, 1], "end": [241, 34], "kind": "commanddeclaration"}, {"full_name": "List.chain'_iff_pairwise", "code": "theorem chain'_iff_pairwise [IsTrans \u03b1 R] : \u2200 {l : List \u03b1}, Chain' R l \u2194 Pairwise R l", "start": [244, 1], "end": [246, 33], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.sublist", "code": "protected theorem Chain'.sublist [IsTrans \u03b1 R] (hl : l\u2082.Chain' R) (h : l\u2081 <+ l\u2082) : l\u2081.Chain' R", "start": [249, 1], "end": [251, 21], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.cons", "code": "theorem Chain'.cons {x y l} (h\u2081 : R x y) (h\u2082 : Chain' R (y :: l)) : Chain' R (x :: y :: l)", "start": [254, 1], "end": [255, 25], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.tail", "code": "theorem Chain'.tail : \u2200 {l} (_ : Chain' R l), Chain' R l.tail", "start": [258, 1], "end": [261, 47], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.rel_head", "code": "theorem Chain'.rel_head {x y l} (h : Chain' R (x :: y :: l)) : R x y", "start": [264, 1], "end": [265, 22], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.rel_head?", "code": "theorem Chain'.rel_head? {x l} (h : Chain' R (x :: l)) \u2983y\u2984 (hy : y \u2208 head? l) : R x y", "start": [268, 1], "end": [270, 19], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.cons'", "code": "theorem Chain'.cons' {x} : \u2200 {l : List \u03b1}, Chain' R l \u2192 (\u2200 y \u2208 l.head?, R x y) \u2192 Chain' R (x :: l)", "start": [273, 1], "end": [275, 40], "kind": "commanddeclaration"}, {"full_name": "List.chain'_cons'", "code": "theorem chain'_cons' {x l} : Chain' R (x :: l) \u2194 (\u2200 y \u2208 head? l, R x y) \u2227 Chain' R l", "start": [278, 1], "end": [279, 64], "kind": "commanddeclaration"}, {"full_name": "List.chain'_append", "code": "theorem chain'_append :\n    \u2200 {l\u2081 l\u2082 : List \u03b1},\n      Chain' R (l\u2081 ++ l\u2082) \u2194 Chain' R l\u2081 \u2227 Chain' R l\u2082 \u2227 \u2200 x \u2208 l\u2081.getLast?, \u2200 y \u2208 l\u2082.head?, R x y", "start": [282, 1], "end": [290, 9], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.append", "code": "theorem Chain'.append (h\u2081 : Chain' R l\u2081) (h\u2082 : Chain' R l\u2082)\n    (h : \u2200 x \u2208 l\u2081.getLast?, \u2200 y \u2208 l\u2082.head?, R x y) : Chain' R (l\u2081 ++ l\u2082)", "start": [293, 1], "end": [295, 30], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.left_of_append", "code": "theorem Chain'.left_of_append (h : Chain' R (l\u2081 ++ l\u2082)) : Chain' R l\u2081", "start": [298, 1], "end": [299, 24], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.right_of_append", "code": "theorem Chain'.right_of_append (h : Chain' R (l\u2081 ++ l\u2082)) : Chain' R l\u2082", "start": [302, 1], "end": [303, 26], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.infix", "code": "theorem Chain'.infix (h : Chain' R l) (h' : l\u2081 <:+: l) : Chain' R l\u2081", "start": [306, 1], "end": [308, 41], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.suffix", "code": "theorem Chain'.suffix (h : Chain' R l) (h' : l\u2081 <:+ l) : Chain' R l\u2081", "start": [311, 1], "end": [312, 21], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.prefix", "code": "theorem Chain'.prefix (h : Chain' R l) (h' : l\u2081 <+: l) : Chain' R l\u2081", "start": [315, 1], "end": [316, 21], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.drop", "code": "theorem Chain'.drop (h : Chain' R l) (n : \u2115) : Chain' R (drop n l)", "start": [319, 1], "end": [320, 29], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.init", "code": "theorem Chain'.init (h : Chain' R l) : Chain' R l.dropLast", "start": [323, 1], "end": [324, 29], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.take", "code": "theorem Chain'.take (h : Chain' R l) (n : \u2115) : Chain' R (take n l)", "start": [327, 1], "end": [328, 29], "kind": "commanddeclaration"}, {"full_name": "List.chain'_pair", "code": "theorem chain'_pair {x y} : Chain' R [x, y] \u2194 R x y", "start": [331, 1], "end": [332, 58], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.imp_head", "code": "theorem Chain'.imp_head {x y} (h : \u2200 {z}, R x z \u2192 R y z) {l} (hl : Chain' R (x :: l)) :\n    Chain' R (y :: l)", "start": [335, 1], "end": [337, 49], "kind": "commanddeclaration"}, {"full_name": "List.chain'_reverse", "code": "theorem chain'_reverse : \u2200 {l}, Chain' R (reverse l) \u2194 Chain' (flip R) l", "start": [340, 1], "end": [345, 91], "kind": "commanddeclaration"}, {"full_name": "List.chain'_iff_get", "code": "theorem chain'_iff_get {R} : \u2200 {l : List \u03b1}, Chain' R l \u2194\n    \u2200 (i : \u2115) (h : i < length l - 1),\n      R (get l \u27e8i, lt_of_lt_pred h\u27e9) (get l \u27e8i + 1, lt_pred_iff.mp h\u27e9)", "start": [348, 1], "end": [360, 61], "kind": "commanddeclaration"}, {"full_name": "List.chain'_iff_nthLe", "code": "@[deprecated chain'_iff_get]\ntheorem chain'_iff_nthLe {R} {l : List \u03b1} : Chain' R l \u2194\n    \u2200 (i) (h : i < length l - 1),\n      R (nthLe l i (lt_of_lt_pred h)) (nthLe l (i + 1) (lt_pred_iff.mp h))", "start": [363, 1], "end": [367, 42], "kind": "commanddeclaration"}, {"full_name": "List.Chain'.append_overlap", "code": "theorem Chain'.append_overlap {l\u2081 l\u2082 l\u2083 : List \u03b1} (h\u2081 : Chain' R (l\u2081 ++ l\u2082))\n    (h\u2082 : Chain' R (l\u2082 ++ l\u2083)) (hn : l\u2082 \u2260 []) : Chain' R (l\u2081 ++ l\u2082 ++ l\u2083)", "start": [370, 1], "end": [375, 79], "kind": "commanddeclaration"}, {"full_name": "List.chain'_join", "code": "lemma chain'_join : \u2200 {L : List (List \u03b1)}, [] \u2209 L \u2192\n    (Chain' R L.join \u2194 (\u2200 l \u2208 L, Chain' R l) \u2227\n    L.Chain' (fun l\u2081 l\u2082 => \u2200\u1d49 (x \u2208 l\u2081.getLast?) (y \u2208 l\u2082.head?), R x y))\n| [], _ => by simp\n| [l], _ => by simp [join]\n| (l\u2081 :: l\u2082 :: L), hL => by\n    rw [mem_cons, not_or, \u2190 Ne.def] at hL\n    rw [join, chain'_append, chain'_join hL.2, forall_mem_cons, chain'_cons]\n    rw [mem_cons, not_or, \u2190 Ne.def] at hL\n    simp only [forall_mem_cons, and_assoc, join, head?_append_of_ne_nil _ hL.2.1.symm]\n    exact Iff.rfl.and (Iff.rfl.and $ Iff.rfl.and and_comm)", "start": [379, 1], "end": [389, 59], "kind": "mathlibtacticlemma"}, {"full_name": "List.exists_chain_of_relationReflTransGen", "code": "theorem exists_chain_of_relationReflTransGen (h : Relation.ReflTransGen r a b) :\n    \u2203 l, Chain r a l \u2227 getLast (a :: l) (cons_ne_nil _ _) = b", "start": [391, 1], "end": [402, 28], "kind": "commanddeclaration"}, {"full_name": "List.Chain.induction", "code": "theorem Chain.induction (p : \u03b1 \u2192 Prop) (l : List \u03b1) (h : Chain r a l)\n    (hb : getLast (a :: l) (cons_ne_nil _ _) = b) (carries : \u2200 \u2983x y : \u03b1\u2984, r x y \u2192 p y \u2192 p x)\n    (final : p b) : \u2200 i \u2208 a :: l, p i", "start": [405, 1], "end": [419, 39], "kind": "commanddeclaration"}, {"full_name": "List.Chain.induction_head", "code": "@[elab_as_elim]\ntheorem Chain.induction_head (p : \u03b1 \u2192 Prop) (l : List \u03b1) (h : Chain r a l)\n    (hb : getLast (a :: l) (cons_ne_nil _ _) = b) (carries : \u2200 \u2983x y : \u03b1\u2984, r x y \u2192 p y \u2192 p x)\n    (final : p b) : p a", "start": [422, 1], "end": [430, 65], "kind": "commanddeclaration"}, {"full_name": "List.relationReflTransGen_of_exists_chain", "code": "theorem relationReflTransGen_of_exists_chain (l : List \u03b1) (hl\u2081 : Chain r a l)\n    (hl\u2082 : getLast (a :: l) (cons_ne_nil _ _) = b) : Relation.ReflTransGen r a b", "start": [433, 1], "end": [441, 31], "kind": "commanddeclaration"}, {"full_name": "List.chains", "code": "abbrev List.chains := { l : List \u03b1 // l.Chain' (flip r) }", "start": [452, 1], "end": [453, 58], "kind": "commanddeclaration"}, {"full_name": "List.lex_chains", "code": "abbrev List.lex_chains (l m : List.chains r) : Prop := List.Lex r l.val m.val", "start": [455, 1], "end": [456, 78], "kind": "commanddeclaration"}, {"full_name": "Acc.list_chain'", "code": "theorem Acc.list_chain' {l : List.chains r} (acc : \u2200 a \u2208 l.val.head?, Acc r a) :\n    Acc (List.lex_chains r) l", "start": [460, 1], "end": [490, 22], "kind": "commanddeclaration"}, {"full_name": "WellFounded.list_chain'", "code": "theorem WellFounded.list_chain' (hwf : WellFounded r) :\n    WellFounded (List.lex_chains r)", "start": [492, 1], "end": [495, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Pow.lean", "imports": ["Mathlib/Algebra/GroupPower/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.pow_lt_pow_of_lt_left", "code": "theorem pow_lt_pow_of_lt_left {x y : \u2115} (H : x < y) {i} (h : 0 < i) : x ^ i < y ^ i", "start": [27, 1], "end": [28, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_pow_of_lt_right", "code": "theorem pow_lt_pow_of_lt_right {x : \u2115} (H : 1 < x) {i j : \u2115} (h : i < j) : x ^ i < x ^ j", "start": [31, 1], "end": [32, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_pow_succ", "code": "theorem pow_lt_pow_succ {p : \u2115} (h : 1 < p) (n : \u2115) : p ^ n < p ^ (n + 1)", "start": [35, 1], "end": [36, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.le_self_pow", "code": "theorem le_self_pow {n : \u2115} (hn : n \u2260 0) : \u2200 m : \u2115, m \u2264 m ^ n", "start": [39, 1], "end": [41, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_pow_self", "code": "theorem lt_pow_self {p : \u2115} (h : 1 < p) : \u2200 n : \u2115, n < p ^ n", "start": [44, 1], "end": [49, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_two_pow", "code": "theorem lt_two_pow (n : \u2115) : n < 2 ^ n", "start": [52, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_pow", "code": "theorem one_le_pow (n m : \u2115) (h : 0 < m) : 1 \u2264 m ^ n", "start": [56, 1], "end": [58, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_pow'", "code": "theorem one_le_pow' (n m : \u2115) : 1 \u2264 (m + 1) ^ n", "start": [61, 1], "end": [62, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_two_pow", "code": "theorem one_le_two_pow (n : \u2115) : 1 \u2264 2 ^ n", "start": [65, 1], "end": [66, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_pow", "code": "theorem one_lt_pow (n m : \u2115) (h\u2080 : 0 < n) (h\u2081 : 1 < m) : 1 < m ^ n", "start": [69, 1], "end": [71, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_pow'", "code": "theorem one_lt_pow' (n m : \u2115) : 1 < (m + 2) ^ (n + 1)", "start": [74, 1], "end": [75, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_pow_iff", "code": "@[simp]\ntheorem one_lt_pow_iff {k n : \u2115} (h : 0 \u2260 k) : 1 < n ^ k \u2194 1 < n", "start": [78, 1], "end": [90, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_two_pow", "code": "theorem one_lt_two_pow (n : \u2115) (h\u2080 : 0 < n) : 1 < 2 ^ n", "start": [93, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_two_pow'", "code": "theorem one_lt_two_pow' (n : \u2115) : 1 < 2 ^ (n + 1)", "start": [97, 1], "end": [98, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_right_strictMono", "code": "theorem pow_right_strictMono {x : \u2115} (k : 2 \u2264 x) : StrictMono fun n : \u2115 => x ^ n", "start": [101, 1], "end": [102, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_iff_le_right", "code": "theorem pow_le_iff_le_right {x m n : \u2115} (k : 2 \u2264 x) : x ^ m \u2264 x ^ n \u2194 m \u2264 n", "start": [105, 1], "end": [106, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_iff_lt_right", "code": "theorem pow_lt_iff_lt_right {x m n : \u2115} (k : 2 \u2264 x) : x ^ m < x ^ n \u2194 m < n", "start": [109, 1], "end": [110, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_right_injective", "code": "theorem pow_right_injective {x : \u2115} (k : 2 \u2264 x) : Function.Injective fun n : \u2115 => x ^ n", "start": [113, 1], "end": [114, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_left_strictMono", "code": "theorem pow_left_strictMono {m : \u2115} (k : 1 \u2264 m) : StrictMono fun x : \u2115 => x ^ m", "start": [117, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_lt_mul_pow_succ", "code": "theorem mul_lt_mul_pow_succ {n a q : \u2115} (a0 : 0 < a) (q1 : 1 < q) : n * q < a * q ^ (n + 1)", "start": [121, 1], "end": [123, 79], "kind": "commanddeclaration"}, {"full_name": "StrictMono.nat_pow", "code": "theorem StrictMono.nat_pow {n : \u2115} (hn : 1 \u2264 n) {f : \u2115 \u2192 \u2115} (hf : StrictMono f) :\n    StrictMono fun m => f m ^ n", "start": [128, 1], "end": [130, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_le_iff_le_left", "code": "theorem pow_le_iff_le_left {m x y : \u2115} (k : 1 \u2264 m) : x ^ m \u2264 y ^ m \u2194 x \u2264 y", "start": [135, 1], "end": [136, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_iff_lt_left", "code": "theorem pow_lt_iff_lt_left {m x y : \u2115} (k : 1 \u2264 m) : x ^ m < y ^ m \u2194 x < y", "start": [139, 1], "end": [140, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_left_injective", "code": "theorem pow_left_injective {m : \u2115} (k : 1 \u2264 m) : Function.Injective fun x : \u2115 => x ^ m", "start": [143, 1], "end": [144, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sq_sub_sq", "code": "theorem sq_sub_sq (a b : \u2115) : a ^ 2 - b ^ 2 = (a + b) * (a - b)", "start": [147, 1], "end": [149, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_two_sub_pow_two", "code": "alias pow_two_sub_pow_two := sq_sub_sq", "start": [152, 1], "end": [152, 39], "kind": "stdtacticaliasalias"}, {"full_name": "Nat.pow_mod", "code": "theorem pow_mod (a b n : \u2115) : a ^ b % n = (a % n) ^ b % n", "start": [158, 1], "end": [160, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_pow_succ", "code": "theorem mod_pow_succ {b : \u2115} (w m : \u2115) : m % b ^ succ w = b * (m / b % b ^ w) + m % b", "start": [163, 1], "end": [191, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_dvd_pow_iff_pow_le_pow", "code": "theorem pow_dvd_pow_iff_pow_le_pow {k l : \u2115} : \u2200 {x : \u2115} (_ : 0 < x), x ^ k \u2223 x ^ l \u2194 x ^ k \u2264 x ^ l", "start": [194, 1], "end": [204, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_dvd_pow_iff_le_right", "code": "theorem pow_dvd_pow_iff_le_right {x k l : \u2115} (w : 1 < x) : x ^ k \u2223 x ^ l \u2194 k \u2264 l", "start": [207, 1], "end": [209, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_dvd_pow_iff_le_right'", "code": "theorem pow_dvd_pow_iff_le_right' {b k l : \u2115} : (b + 2) ^ k \u2223 (b + 2) ^ l \u2194 k \u2264 l", "start": [212, 1], "end": [213, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.not_pos_pow_dvd", "code": "theorem not_pos_pow_dvd : \u2200 {p k : \u2115} (_ : 1 < p) (_ : 1 < k), \u00acp ^ k \u2223 p", "start": [216, 1], "end": [225, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_dvd_of_le_of_pow_dvd", "code": "theorem pow_dvd_of_le_of_pow_dvd {p m n k : \u2115} (hmn : m \u2264 n) (hdiv : p ^ n \u2223 k) : p ^ m \u2223 k", "start": [228, 1], "end": [229, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_pow_dvd", "code": "theorem dvd_of_pow_dvd {p k m : \u2115} (hk : 1 \u2264 k) (hpk : p ^ k \u2223 m) : p \u2223 m", "start": [232, 1], "end": [233, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_div", "code": "theorem pow_div {x m n : \u2115} (h : n \u2264 m) (hx : 0 < x) : x ^ m / x ^ n = x ^ (m - n)", "start": [236, 1], "end": [237, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_pow_dvd_right", "code": "theorem lt_of_pow_dvd_right {p i n : \u2115} (hn : n \u2260 0) (hp : 2 \u2264 p) (h : p ^ i \u2223 n) : i < n", "start": [240, 1], "end": [242, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Join.lean", "imports": ["Mathlib/Data/List/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.join_singleton", "code": "theorem join_singleton (l : List \u03b1) : [l].join = l", "start": [26, 1], "end": [26, 85], "kind": "commanddeclaration"}, {"full_name": "List.join_eq_nil", "code": "@[simp]\ntheorem join_eq_nil : \u2200 {L : List (List \u03b1)}, join L = [] \u2194 \u2200 l \u2208 L, l = []", "start": [29, 1], "end": [32, 79], "kind": "commanddeclaration"}, {"full_name": "List.join_append", "code": "@[simp]\ntheorem join_append (L\u2081 L\u2082 : List (List \u03b1)) : join (L\u2081 ++ L\u2082) = join L\u2081 ++ join L\u2082", "start": [35, 1], "end": [39, 13], "kind": "commanddeclaration"}, {"full_name": "List.join_concat", "code": "theorem join_concat (L : List (List \u03b1)) (l : List \u03b1) : join (L.concat l) = join L ++ l", "start": [42, 1], "end": [42, 98], "kind": "commanddeclaration"}, {"full_name": "List.join_filter_isEmpty_eq_false", "code": "@[simp]\ntheorem join_filter_isEmpty_eq_false [DecidablePred fun l : List \u03b1 => l.isEmpty = false] :\n    \u2200 {L : List (List \u03b1)}, join (L.filter fun l => l.isEmpty = false) = L.join", "start": [48, 1], "end": [56, 67], "kind": "commanddeclaration"}, {"full_name": "List.join_filter_ne_nil", "code": "@[simp]\ntheorem join_filter_ne_nil [DecidablePred fun l : List \u03b1 => l \u2260 []] {L : List (List \u03b1)} :\n    join (L.filter fun l => l \u2260 []) = L.join", "start": [59, 1], "end": [62, 60], "kind": "commanddeclaration"}, {"full_name": "List.join_join", "code": "theorem join_join (l : List (List (List \u03b1))) : l.join.join = (l.map join).join", "start": [65, 1], "end": [66, 27], "kind": "commanddeclaration"}, {"full_name": "List.length_join", "code": "@[simp]\ntheorem length_join (L : List (List \u03b1)) : length (join L) = sum (map length L)", "start": [69, 1], "end": [71, 75], "kind": "commanddeclaration"}, {"full_name": "List.length_bind", "code": "@[simp]\ntheorem length_bind (l : List \u03b1) (f : \u03b1 \u2192 List \u03b2) :\n    length (List.bind l f) = sum (map (length \u2218 f) l)", "start": [74, 1], "end": [76, 97], "kind": "commanddeclaration"}, {"full_name": "List.bind_eq_nil", "code": "@[simp]\ntheorem bind_eq_nil {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} : List.bind l f = [] \u2194 \u2200 x \u2208 l, f x = []", "start": [79, 1], "end": [82, 80], "kind": "commanddeclaration"}, {"full_name": "List.take_sum_join", "code": "theorem take_sum_join (L : List (List \u03b1)) (i : \u2115) :\n    L.join.take ((L.map length).take i).sum = (L.take i).join", "start": [85, 1], "end": [91, 38], "kind": "commanddeclaration"}, {"full_name": "List.drop_sum_join", "code": "theorem drop_sum_join (L : List (List \u03b1)) (i : \u2115) :\n    L.join.drop ((L.map length).take i).sum = (L.drop i).join", "start": [94, 1], "end": [100, 38], "kind": "commanddeclaration"}, {"full_name": "List.drop_take_succ_eq_cons_get", "code": "theorem drop_take_succ_eq_cons_get (L : List \u03b1) (i : Fin L.length) :\n    (L.take (i + 1)).drop i = [get L i]", "start": [103, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "List.drop_take_succ_eq_cons_nthLe", "code": "@[deprecated drop_take_succ_eq_cons_get]\ntheorem drop_take_succ_eq_cons_nthLe (L : List \u03b1) {i : \u2115} (hi : i < L.length) :\n    (L.take (i + 1)).drop i = [nthLe L i hi]", "start": [114, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "List.drop_take_succ_join_eq_get", "code": "theorem drop_take_succ_join_eq_get (L : List (List \u03b1)) (i : Fin L.length) :\n    (L.join.take ((L.map length).take (i + 1)).sum).drop ((L.map length).take i).sum =\n      get L i", "start": [132, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "List.drop_take_succ_join_eq_nthLe", "code": "@[deprecated drop_take_succ_join_eq_get]\ntheorem drop_take_succ_join_eq_nthLe (L : List (List \u03b1)) {i : \u2115} (hi : i < L.length) :\n    (L.join.take ((L.map length).take (i + 1)).sum).drop ((L.map length).take i).sum =\n      nthLe L i hi", "start": [144, 1], "end": [153, 79], "kind": "commanddeclaration"}, {"full_name": "List.sum_take_map_length_lt1", "code": "@[deprecated]\ntheorem sum_take_map_length_lt1 (L : List (List \u03b1)) {i j : \u2115} (hi : i < L.length)\n    (hj : j < (nthLe L i hi).length) :\n    ((L.map length).take i).sum + j < ((L.map length).take (i + 1)).sum", "start": [157, 1], "end": [162, 31], "kind": "commanddeclaration"}, {"full_name": "List.sum_take_map_length_lt2", "code": "@[deprecated]\ntheorem sum_take_map_length_lt2 (L : List (List \u03b1)) {i j : \u2115} (hi : i < L.length)\n    (hj : j < (nthLe L i hi).length) : ((L.map length).take i).sum + j < L.join.length", "start": [166, 1], "end": [172, 27], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_join", "code": "@[deprecated]\ntheorem nthLe_join (L : List (List \u03b1)) {i j : \u2115} (hi : i < L.length)\n    (hj : j < (nthLe L i hi).length) :\n    nthLe L.join (((L.map length).take i).sum + j) (sum_take_map_length_lt2 L hi hj) =\n      nthLe (nthLe L i hi) j hj", "start": [176, 1], "end": [185, 73], "kind": "commanddeclaration"}, {"full_name": "List.eq_iff_join_eq", "code": "theorem eq_iff_join_eq (L L' : List (List \u03b1)) :\n    L = L' \u2194 L.join = L'.join \u2227 map length L = map length L'", "start": [188, 1], "end": [198, 88], "kind": "commanddeclaration"}, {"full_name": "List.join_drop_length_sub_one", "code": "theorem join_drop_length_sub_one {L : List (List \u03b1)} (h : L \u2260 []) :\n    (L.drop (L.length - 1)).join = L.getLast h", "start": [201, 1], "end": [205, 9], "kind": "commanddeclaration"}, {"full_name": "List.append_join_map_append", "code": "theorem append_join_map_append (L : List (List \u03b1)) (x : List \u03b1) :\n    x ++ (List.map (fun l => l ++ x) L).join = (List.map (fun l => x ++ l) L).join ++ x", "start": [208, 1], "end": [214, 86], "kind": "commanddeclaration"}, {"full_name": "List.reverse_join", "code": "theorem reverse_join (L : List (List \u03b1)) :\n    L.join.reverse = (List.map List.reverse L).reverse.join", "start": [217, 1], "end": [222, 72], "kind": "commanddeclaration"}, {"full_name": "List.join_reverse", "code": "theorem join_reverse (L : List (List \u03b1)) :\n    L.reverse.join = (List.map List.reverse L).join.reverse", "start": [225, 1], "end": [228, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Basic.lean", "imports": ["Mathlib/Order/RelIso/Basic.lean", "Mathlib/Order/Hom/Set.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Fin/Basic.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "finZeroElim", "code": "def finZeroElim {\u03b1 : Fin 0 \u2192 Sort*} (x : Fin 0) : \u03b1 x :=\n  x.elim0", "start": [83, 1], "end": [85, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.elim0'", "code": "def elim0' {\u03b1 : Sort*} (x : Fin 0) : \u03b1 :=\n  x.elim0", "start": [93, 1], "end": [95, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.val_injective", "code": "theorem val_injective : Function.Injective (@Fin.val n)", "start": [103, 1], "end": [104, 19], "kind": "commanddeclaration"}, {"full_name": "Fin.size_positive", "code": "lemma size_positive : Fin n \u2192 0 < n\n  | \u27e8x, h\u27e9 =>\n    match Nat.eq_or_lt_of_le (Nat.zero_le x) with\n    | Or.inl h_eq => h_eq \u25b8 h\n    | Or.inr h_lt => Nat.lt_trans h_lt h", "start": [107, 1], "end": [112, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Fin.size_positive'", "code": "lemma size_positive' [Nonempty (Fin n)] : 0 < n :=\n  \u2039Nonempty (Fin n)\u203a.elim fun i \u21a6 Fin.size_positive i", "start": [114, 1], "end": [115, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Fin.prop", "code": "protected theorem prop (a : Fin n) : a.val < n", "start": [117, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.equivSubtype", "code": "@[simps apply symm_apply]\ndef equivSubtype : Fin n \u2243 { i // i < n } where\n  toFun a := \u27e8a.1, a.2\u27e9\n  invFun a := \u27e8a.1, a.2\u27e9\n  left_inv := fun \u27e8_, _\u27e9 => rfl\n  right_inv := fun \u27e8_, _\u27e9 => rfl", "start": [125, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.val_eq_val", "code": "theorem val_eq_val (a b : Fin n) : (a : \u2115) = b \u2194 a = b", "start": [147, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_iff_veq", "code": "theorem eq_iff_veq (a b : Fin n) : a = b \u2194 a.1 = b.1", "start": [151, 1], "end": [152, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.ne_iff_vne", "code": "theorem ne_iff_vne (a b : Fin n) : a \u2260 b \u2194 a.1 \u2260 b.1", "start": [155, 1], "end": [156, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_eq_mk", "code": "@[simp, nolint simpNF]\ntheorem mk_eq_mk {a h a' h'} : @mk n a h = @mk n a' h' \u2194 a = a'", "start": [161, 1], "end": [163, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.heq_fun_iff", "code": "protected theorem heq_fun_iff {\u03b1 : Sort*} {k l : \u2115} (h : k = l) {f : Fin k \u2192 \u03b1} {g : Fin l \u2192 \u03b1} :\n    HEq f g \u2194 \u2200 i : Fin k, f i = g \u27e8(i : \u2115), h \u25b8 i.2\u27e9", "start": [176, 1], "end": [181, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.heq_fun\u2082_iff", "code": "protected theorem heq_fun\u2082_iff {\u03b1 : Sort*} {k l k' l' : \u2115} (h : k = l) (h' : k' = l')\n    {f : Fin k \u2192 Fin k' \u2192 \u03b1} {g : Fin l \u2192 Fin l' \u2192 \u03b1} :\n    HEq f g \u2194 \u2200 (i : Fin k) (j : Fin k'), f i j = g \u27e8(i : \u2115), h \u25b8 i.2\u27e9 \u27e8(j : \u2115), h' \u25b8 j.2\u27e9", "start": [184, 1], "end": [192, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.heq_ext_iff", "code": "protected theorem heq_ext_iff {k l : \u2115} (h : k = l) {i : Fin k} {j : Fin l} :\n    HEq i j \u2194 (i : \u2115) = (j : \u2115)", "start": [194, 1], "end": [197, 20], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_iff_val_lt_val", "code": "theorem lt_iff_val_lt_val {a b : Fin n} : a < b \u2194 (a : \u2115) < b", "start": [215, 1], "end": [216, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.le_iff_val_le_val", "code": "theorem le_iff_val_le_val {a b : Fin n} : a \u2264 b \u2194 (a : \u2115) \u2264 b", "start": [219, 1], "end": [220, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.val_fin_lt", "code": "@[norm_cast, simp]\ntheorem val_fin_lt {n : \u2115} {a b : Fin n} : (a : \u2115) < (b : \u2115) \u2194 a < b", "start": [226, 1], "end": [229, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.val_fin_le", "code": "@[norm_cast, simp]\ntheorem val_fin_le {n : \u2115} {a b : Fin n} : (a : \u2115) \u2264 (b : \u2115) \u2194 a \u2264 b", "start": [232, 1], "end": [235, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.min_val", "code": "theorem min_val {a : Fin n} : min (a : \u2115) n = a", "start": [247, 1], "end": [247, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.max_val", "code": "theorem max_val {a : Fin n} : max (a : \u2115) n = n", "start": [251, 1], "end": [251, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.val_strictMono", "code": "theorem val_strictMono : StrictMono (val : Fin n \u2192 \u2115)", "start": [256, 1], "end": [256, 71], "kind": "commanddeclaration"}, {"full_name": "Fin.orderIsoSubtype", "code": "@[simps! apply symm_apply]\ndef orderIsoSubtype : Fin n \u2243o { i // i < n } :=\n  equivSubtype.toOrderIso (by simp [Monotone]) (by simp [Monotone])", "start": [259, 1], "end": [262, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.valEmbedding", "code": "@[simps apply]\ndef valEmbedding : Fin n \u21aa \u2115 :=\n  \u27e8val, val_injective\u27e9", "start": [267, 1], "end": [270, 23], "kind": "commanddeclaration"}, {"full_name": "Fin.equivSubtype_symm_trans_valEmbedding", "code": "@[simp]\ntheorem equivSubtype_symm_trans_valEmbedding :\n    equivSubtype.symm.toEmbedding.trans valEmbedding = Embedding.subtype (\u00b7 < n)", "start": [273, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.valOrderEmbedding", "code": "@[simps! apply]\ndef valOrderEmbedding (n) : Fin n \u21aao \u2115 :=\n  \u27e8valEmbedding, Iff.rfl\u27e9", "start": [279, 1], "end": [282, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.Lt.isWellOrder", "code": "instance Lt.isWellOrder (n) : IsWellOrder (Fin n) (\u00b7 < \u00b7) :=\n  (valOrderEmbedding n).isWellOrder", "start": [285, 1], "end": [287, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat''", "code": "def ofNat'' [NeZero n] (i : \u2115) : Fin n :=\n  \u27e8i % n, mod_lt _ <| NeZero.pos n\u27e9", "start": [303, 1], "end": [305, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.val_zero'", "code": "@[simp]\ntheorem val_zero' (n : \u2115) [NeZero n] : ((0 : Fin n) : \u2115) = 0", "start": [315, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_le'", "code": "@[simp]\nprotected theorem zero_le' [NeZero n] (a : Fin n) : 0 \u2264 a", "start": [326, 1], "end": [332, 20], "kind": "commanddeclaration"}, {"full_name": "Fin.pos_iff_ne_zero'", "code": "theorem pos_iff_ne_zero' [NeZero n] (a : Fin n) : 0 < a \u2194 a \u2260 0", "start": [338, 1], "end": [343, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_involutive", "code": "theorem rev_involutive : Involutive (rev : Fin n \u2192 Fin n)", "start": [349, 1], "end": [353, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.revPerm", "code": "@[simps! apply symm_apply]\ndef revPerm : Equiv.Perm (Fin n) :=\n  Involutive.toPerm rev rev_involutive", "start": [356, 1], "end": [360, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_injective", "code": "theorem rev_injective : Injective (@rev n)", "start": [365, 1], "end": [366, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_surjective", "code": "theorem rev_surjective : Surjective (@rev n)", "start": [369, 1], "end": [370, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.rev_bijective", "code": "theorem rev_bijective : Bijective (@rev n)", "start": [373, 1], "end": [374, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.revPerm_symm", "code": "@[simp]\ntheorem revPerm_symm : (@revPerm n).symm = revPerm", "start": [381, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.revOrderIso", "code": "@[simps! apply toEquiv]\ndef revOrderIso {n} : (Fin n)\u1d52\u1d48 \u2243o Fin n :=\n  \u27e8OrderDual.ofDual.trans revPerm, rev_le_rev\u27e9", "start": [392, 1], "end": [395, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.revOrderIso_symm_apply", "code": "@[simp]\ntheorem revOrderIso_symm_apply (i : Fin n) : revOrderIso.symm i = OrderDual.toDual (rev i)", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.top_eq_last", "code": "theorem top_eq_last (n : \u2115) : \u22a4 = Fin.last n", "start": [424, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.bot_eq_zero", "code": "theorem bot_eq_zero (n : \u2115) : \u22a5 = (0 : Fin (n + 1))", "start": [428, 1], "end": [429, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_orderIso_apply", "code": "@[simp]\ntheorem coe_orderIso_apply (e : Fin n \u2243o Fin m) (i : Fin n) : (e i : \u2115) = i", "start": [438, 1], "end": [452, 67], "kind": "commanddeclaration"}, {"full_name": "Fin.orderIso_subsingleton", "code": "instance orderIso_subsingleton : Subsingleton (Fin n \u2243o \u03b1) :=\n  \u27e8fun e e' => by\n    ext i\n    rw [\u2190 e.symm.apply_eq_iff_eq, e.symm_apply_apply, \u2190 e'.trans_apply, ext_iff,\n      coe_orderIso_apply]\u27e9", "start": [455, 1], "end": [459, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.orderIso_subsingleton'", "code": "instance orderIso_subsingleton' : Subsingleton (\u03b1 \u2243o Fin n) :=\n  OrderIso.symm_injective.subsingleton", "start": [462, 1], "end": [463, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.orderIsoUnique", "code": "instance orderIsoUnique : Unique (Fin n \u2243o Fin n) :=\n  Unique.mk' _", "start": [466, 1], "end": [467, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_unique", "code": "theorem strictMono_unique {f g : Fin n \u2192 \u03b1} (hf : StrictMono f) (hg : StrictMono g)\n    (h : range f = range g) : f = g", "start": [470, 1], "end": [475, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.orderEmbedding_eq", "code": "theorem orderEmbedding_eq {f g : Fin n \u21aao \u03b1} (h : range f = range g) : f = g", "start": [478, 1], "end": [480, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.val_one'", "code": "@[simp]\ntheorem val_one' (n : \u2115) [NeZero n] : ((1 : Fin n) : \u2115) = 1 % n", "start": [496, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.val_one''", "code": "theorem val_one'' {n : \u2115} : ((1 : Fin (n + 1)) : \u2115) = 1 % (n + 1)", "start": [502, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.nontrivial", "code": "instance nontrivial {n : \u2115} : Nontrivial (Fin (n + 2)) where\n  exists_pair_ne := \u27e80, 1, (ne_iff_vne 0 1).mpr (by simp only [val_one, val_zero])\u27e9", "start": [508, 1], "end": [509, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.nontrivial_iff_two_le", "code": "theorem nontrivial_iff_two_le : Nontrivial (Fin n) \u2194 2 \u2264 n", "start": [511, 1], "end": [513, 80], "kind": "commanddeclaration"}, {"full_name": "Fin.addCommSemigroup", "code": "instance addCommSemigroup (n : \u2115) : AddCommSemigroup (Fin n) where\n  add := (\u00b7 + \u00b7)\n  add_assoc := by simp [eq_iff_veq, add_def, add_assoc]\n  add_comm := by simp [eq_iff_veq, add_def, add_comm]", "start": [521, 1], "end": [524, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.add_zero", "code": "protected theorem add_zero [NeZero n] (k : Fin n) : k + 0 = k", "start": [528, 1], "end": [529, 67], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_add", "code": "protected theorem zero_add [NeZero n] (k : Fin n) : 0 + k = k", "start": [533, 1], "end": [534, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat'_zero", "code": "@[simp] lemma ofNat'_zero [NeZero n] : (Fin.ofNat' 0 h : Fin n) = 0 := rfl", "start": [542, 1], "end": [542, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Fin.ofNat'_one", "code": "@[simp] lemma ofNat'_one [NeZero n] : (Fin.ofNat' 1 h : Fin n) = 1 := rfl", "start": [543, 1], "end": [543, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Fin.addCommMonoid", "code": "instance addCommMonoid (n : \u2115) [NeZero n] : AddCommMonoid (Fin n) where\n  zero_add := Fin.zero_add\n  add_zero := Fin.add_zero\n  __ := Fin.addCommSemigroup n", "start": [551, 1], "end": [554, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.instAddMonoidWithOne", "code": "instance instAddMonoidWithOne (n) [NeZero n] : AddMonoidWithOne (Fin n) where\n  __ := inferInstanceAs (AddCommMonoid (Fin n))\n  natCast n := Fin.ofNat'' n\n  natCast_zero := rfl\n  natCast_succ _ := eq_of_veq (add_mod _ _ _)", "start": [557, 1], "end": [561, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.val_add_eq_ite", "code": "theorem val_add_eq_ite {n : \u2115} (a b : Fin n) :\n    (\u2191(a + b) : \u2115) = if n \u2264 a + b then a + b - n else a + b", "start": [569, 1], "end": [572, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.val_bit0", "code": "@[deprecated]\ntheorem val_bit0 {n : \u2115} (k : Fin n) : ((bit0 k : Fin n) : \u2115) = bit0 (k : \u2115) % n", "start": [578, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.val_bit1", "code": "@[deprecated]\ntheorem val_bit1 {n : \u2115} [NeZero n] (k : Fin n) :\n    ((bit1 k : Fin n) : \u2115) = bit1 (k : \u2115) % n", "start": [584, 1], "end": [593, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_bit0", "code": "@[simp, deprecated]\ntheorem mk_bit0 {m n : \u2115} (h : bit0 m < n) :\n    (\u27e8bit0 m, h\u27e9 : Fin n) = (bit0 \u27e8m, (Nat.le_add_right m m).trans_lt h\u27e9 : Fin _)", "start": [605, 1], "end": [608, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.mk_bit1", "code": "@[simp, deprecated]\ntheorem mk_bit1 {m n : \u2115} [NeZero n] (h : bit1 m < n) :\n    (\u27e8bit1 m, h\u27e9 : Fin n) =\n      (bit1 \u27e8m, (Nat.le_add_right m m).trans_lt ((m + m).lt_succ_self.trans h)\u27e9 : Fin _)", "start": [611, 1], "end": [617, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.ofNat_eq_val", "code": "@[simp]\ntheorem ofNat_eq_val (n : \u2115) [NeZero n] (a : \u2115) : (Fin.ofNat'' a : Fin n) = a", "start": [629, 1], "end": [631, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.val_cast_of_lt", "code": "theorem val_cast_of_lt {n : \u2115} [NeZero n] {a : \u2115} (h : a < n) : (a : Fin n).val = a", "start": [635, 1], "end": [639, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_val_eq_self", "code": "theorem cast_val_eq_self {n : \u2115} [NeZero n] (a : Fin n) : (a.val : Fin n) = a", "start": [642, 1], "end": [646, 30], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_nat_eq_last", "code": "theorem cast_nat_eq_last (n) : (n : Fin (n + 1)) = Fin.last n", "start": [655, 1], "end": [657, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.le_val_last", "code": "theorem le_val_last (i : Fin (n + 1)) : i \u2264 n", "start": [660, 1], "end": [662, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_eq_one_iff", "code": "@[simp]\ntheorem zero_eq_one_iff [NeZero n] : (0 : Fin n) = 1 \u2194 n = 1", "start": [671, 1], "end": [679, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.one_eq_zero_iff", "code": "@[simp]\ntheorem one_eq_zero_iff [NeZero n] : (1 : Fin n) = 0 \u2194 n = 1", "start": [682, 1], "end": [683, 97], "kind": "commanddeclaration"}, {"full_name": "Fin.succEmbedding", "code": "def succEmbedding (n : \u2115) : Fin n \u21aao Fin (n + 1) :=\n  (OrderEmbedding.ofStrictMono Fin.succ) fun _ _ h => succ_lt_succ h", "start": [697, 1], "end": [699, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.val_succEmbedding", "code": "@[simp]\ntheorem val_succEmbedding : \u21d1(succEmbedding n) = Fin.succ", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_injective", "code": "theorem succ_injective (n : \u2115) : Injective (@Fin.succ n)", "start": [710, 1], "end": [711, 30], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_zero_eq_one'", "code": "@[simp]\ntheorem succ_zero_eq_one' [NeZero n] : Fin.succ (0 : Fin n) = 1", "start": [717, 1], "end": [721, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_one_eq_two'", "code": "@[simp]\ntheorem succ_one_eq_two' [NeZero n] : Fin.succ (1 : Fin (n + 1)) = 2", "start": [726, 1], "end": [734, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.le_zero_iff'", "code": "@[simp]\ntheorem le_zero_iff' {n : \u2115} [NeZero n] {k : Fin n} : k \u2264 0 \u2194 k = 0", "start": [749, 1], "end": [755, 99], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_refl", "code": "@[simp] theorem cast_refl {n : Nat} (h : n = n) :\n    Fin.cast h = id", "start": [764, 1], "end": [765, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_castLE", "code": "theorem strictMono_castLE (h : n \u2264 m) : StrictMono (castLE h : Fin n \u2192 Fin m)", "start": [767, 1], "end": [768, 17], "kind": "commanddeclaration"}, {"full_name": "Fin.castLEEmb", "code": "@[simps! apply toEmbedding]\ndef castLEEmb (h : n \u2264 m) : Fin n \u21aao Fin m :=\n  OrderEmbedding.ofStrictMono (castLE h) (strictMono_castLE h)", "start": [770, 1], "end": [773, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.range_castLE", "code": "@[simp]\ntheorem range_castLE {n k : \u2115} (h : n \u2264 k) : Set.range (castLE h) = { i : Fin k | (i : \u2115) < n }", "start": [780, 1], "end": [782, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_of_injective_castLEEmb_symm", "code": "@[simp]\ntheorem coe_of_injective_castLEEmb_symm {n k : \u2115} (h : n \u2264 k) (i : Fin k) (hi) :\n    ((Equiv.ofInjective _ (castLEEmb h).injective).symm \u27e8i, hi\u27e9 : \u2115) = i", "start": [785, 1], "end": [789, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.leftInverse_cast", "code": "theorem leftInverse_cast (eq : n = m) : LeftInverse (cast eq.symm) (cast eq)", "start": [796, 1], "end": [797, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.rightInverse_cast", "code": "theorem rightInverse_cast (eq : n = m) : RightInverse (cast eq.symm) (cast eq)", "start": [799, 1], "end": [800, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_le_cast", "code": "theorem cast_le_cast (eq : n = m) {a b : Fin n} : cast eq a \u2264 cast eq b \u2194 a \u2264 b", "start": [802, 1], "end": [803, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.castIso", "code": "@[simps]\ndef castIso (eq : n = m) : Fin n \u2243o Fin m where\n  toEquiv := \u27e8cast eq, cast eq.symm, leftInverse_cast eq, rightInverse_cast eq\u27e9\n  map_rel_iff' := cast_le_cast eq", "start": [805, 1], "end": [810, 34], "kind": "commanddeclaration"}, {"full_name": "Fin.symm_castIso", "code": "@[simp]\ntheorem symm_castIso (h : n = m) : (castIso h).symm = castIso h.symm", "start": [813, 1], "end": [814, 80], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_zero", "code": "@[simp]\ntheorem cast_zero {n' : \u2115} [NeZero n] {h : n = n'} : cast h (0 : Fin n) =\n    by { haveI : NeZero n' := by {rw [\u2190 h]; infer_instance}; exact 0}", "start": [819, 1], "end": [822, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.castIso_refl", "code": "@[simp]\ntheorem castIso_refl (h : n = n := rfl) : castIso h = OrderIso.refl (Fin n)", "start": [831, 1], "end": [834, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.castIso_to_equiv", "code": "theorem castIso_to_equiv (h : n = m) : (castIso h).toEquiv = Equiv.cast (h \u25b8 rfl)", "start": [839, 1], "end": [843, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_eq_cast", "code": "theorem cast_eq_cast (h : n = m) : (cast h : Fin n \u2192 Fin m) = _root_.cast (h \u25b8 rfl)", "start": [846, 1], "end": [851, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_castAdd", "code": "theorem strictMono_castAdd (m) : StrictMono (castAdd m : Fin n \u2192 Fin (n + m))", "start": [854, 1], "end": [855, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.castAddEmb", "code": "@[simps! apply toEmbedding]\ndef castAddEmb (m) : Fin n \u21aao Fin (n + m) :=\n  OrderEmbedding.ofStrictMono (castAdd m) (strictMono_castAdd m)", "start": [857, 1], "end": [861, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_castSucc", "code": "theorem strictMono_castSucc : StrictMono (castSucc : Fin n \u2192 Fin (n + 1))", "start": [885, 1], "end": [886, 23], "kind": "commanddeclaration"}, {"full_name": "Fin.castSuccEmb", "code": "@[simps! apply toEmbedding]\ndef castSuccEmb : Fin n \u21aao Fin (n + 1) :=\n  OrderEmbedding.ofStrictMono castSucc strictMono_castSucc", "start": [888, 1], "end": [891, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_injective", "code": "theorem castSucc_injective (n : \u2115) : Injective (@Fin.castSucc n)", "start": [908, 1], "end": [909, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_zero'", "code": "@[simp]\ntheorem castSucc_zero' [NeZero n] : castSucc (0 : Fin n) = 0", "start": [915, 1], "end": [921, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_pos'", "code": "theorem castSucc_pos' [NeZero n] {i : Fin n} (h : 0 < i) : 0 < castSucc i", "start": [925, 1], "end": [930, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_eq_zero_iff'", "code": "@[simp]\ntheorem castSucc_eq_zero_iff' [NeZero n] (a : Fin n) : castSucc a = 0 \u2194 a = 0", "start": [933, 1], "end": [939, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_ne_zero_iff'", "code": "theorem castSucc_ne_zero_iff' [NeZero n] (a : Fin n) : castSucc a \u2260 0 \u2194 a \u2260 0", "start": [942, 1], "end": [947, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_eq_castSucc", "code": "@[norm_cast, simp]\ntheorem coe_eq_castSucc {a : Fin n} : (a : Fin (n + 1)) = castSucc a", "start": [952, 1], "end": [955, 45], "kind": "commanddeclaration"}, {"full_name": "Fin.range_castSucc", "code": "@[simp]\ntheorem range_castSucc {n : \u2115} : Set.range (castSucc : Fin n \u2192 Fin n.succ) =\n    ({ i | (i : \u2115) < n } : Set (Fin n.succ))", "start": [961, 1], "end": [964, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_of_injective_castSucc_symm", "code": "@[simp]\ntheorem coe_of_injective_castSucc_symm {n : \u2115} (i : Fin n.succ) (hi) :\n    ((Equiv.ofInjective castSucc (castSucc_injective _)).symm \u27e8i, hi\u27e9 : \u2115) = i", "start": [967, 1], "end": [971, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_addNat", "code": "theorem strictMono_addNat (m) : StrictMono ((addNat \u00b7 m) : Fin n \u2192 Fin (n + m))", "start": [976, 1], "end": [977, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.addNatEmb", "code": "@[simps! apply toEmbedding]\ndef addNatEmb (m) : Fin n \u21aao Fin (n + m) :=\n  OrderEmbedding.ofStrictMono (addNat \u00b7 m) (strictMono_addNat m)", "start": [979, 1], "end": [983, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_natAdd", "code": "theorem strictMono_natAdd (n) {m} : StrictMono (natAdd n : Fin m \u2192 Fin (n + m))", "start": [999, 1], "end": [1000, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.natAddEmb", "code": "@[simps! apply toEmbedding]\ndef natAddEmb (n) {m} : Fin m \u21aao Fin (n + m) :=\n  OrderEmbedding.ofStrictMono (natAdd n) (strictMono_natAdd n)", "start": [1002, 1], "end": [1005, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.divNat", "code": "def divNat (i : Fin (m * n)) : Fin m :=\n  \u27e8i / n, Nat.div_lt_of_lt_mul <| mul_comm m n \u25b8 i.prop\u27e9", "start": [1067, 1], "end": [1069, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_divNat", "code": "@[simp]\ntheorem coe_divNat (i : Fin (m * n)) : (i.divNat : \u2115) = i / n", "start": [1072, 1], "end": [1074, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.modNat", "code": "def modNat (i : Fin (m * n)) : Fin n :=\n  \u27e8i % n, Nat.mod_lt _ <| pos_of_mul_pos_right i.pos m.zero_le\u27e9", "start": [1077, 1], "end": [1079, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_modNat", "code": "@[simp]\ntheorem coe_modNat (i : Fin (m * n)) : (i.modNat : \u2115) = i % n", "start": [1082, 1], "end": [1084, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.liftFun_iff_succ", "code": "theorem liftFun_iff_succ {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] {f : Fin (n + 1) \u2192 \u03b1} :\n    ((\u00b7 < \u00b7) \u21d2 r) f f \u2194 \u2200 i : Fin n, r (f (castSucc i)) (f i.succ)", "start": [1128, 1], "end": [1138, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_iff_lt_succ", "code": "theorem strictMono_iff_lt_succ {\u03b1 : Type*} [Preorder \u03b1] {f : Fin (n + 1) \u2192 \u03b1} :\n    StrictMono f \u2194 \u2200 i : Fin n, f (castSucc i) < f i.succ", "start": [1141, 1], "end": [1145, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.monotone_iff_le_succ", "code": "theorem monotone_iff_le_succ {\u03b1 : Type*} [Preorder \u03b1] {f : Fin (n + 1) \u2192 \u03b1} :\n    Monotone f \u2194 \u2200 i : Fin n, f (castSucc i) \u2264 f i.succ", "start": [1148, 1], "end": [1151, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.strictAnti_iff_succ_lt", "code": "theorem strictAnti_iff_succ_lt {\u03b1 : Type*} [Preorder \u03b1] {f : Fin (n + 1) \u2192 \u03b1} :\n    StrictAnti f \u2194 \u2200 i : Fin n, f i.succ < f (castSucc i)", "start": [1154, 1], "end": [1158, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.antitone_iff_succ_le", "code": "theorem antitone_iff_succ_le {\u03b1 : Type*} [Preorder \u03b1] {f : Fin (n + 1) \u2192 \u03b1} :\n    Antitone f \u2194 \u2200 i : Fin n, f i.succ \u2264 f (castSucc i)", "start": [1161, 1], "end": [1164, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.neg", "code": "instance neg (n : \u2115) : Neg (Fin n) :=\n  \u27e8fun a => \u27e8(n - a) % n, Nat.mod_lt _ a.pos\u27e9\u27e9", "start": [1171, 1], "end": [1173, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.addCommGroup", "code": "instance addCommGroup (n : \u2115) [NeZero n] : AddCommGroup (Fin n) :=\n  { Fin.addCommMonoid n, Fin.neg n with\n    add_left_neg := fun \u27e8a, ha\u27e9 =>\n      Fin.ext <|\n        _root_.trans (Nat.mod_add_mod _ _ _) <| by\n          rw [Fin.val_zero', tsub_add_cancel_of_le, Nat.mod_self]\n          exact le_of_lt ha\n    sub_eq_add_neg := fun \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 =>\n      Fin.ext <| show (a + (n - b)) % n = (a + (n - b) % n) % n by simp\n    sub := Fin.sub }", "start": [1175, 1], "end": [1185, 21], "kind": "commanddeclaration"}, {"full_name": "Fin.instInvolutiveNeg", "code": "instance instInvolutiveNeg (n : \u2115) : InvolutiveNeg (Fin n) where\n  neg := Neg.neg\n  neg_neg := Nat.casesOn n finZeroElim fun _i => neg_neg", "start": [1187, 1], "end": [1190, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.instIsCancelAdd", "code": "instance instIsCancelAdd (n : \u2115) : IsCancelAdd (Fin n) where\n  add_left_cancel := Nat.casesOn n finZeroElim fun _i _ _ _ => add_left_cancel\n  add_right_cancel := Nat.casesOn n finZeroElim fun _i _ _ _ => add_right_cancel", "start": [1193, 1], "end": [1196, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.instAddLeftCancelSemigroup", "code": "instance instAddLeftCancelSemigroup (n : \u2115) : AddLeftCancelSemigroup (Fin n) :=\n  { Fin.addCommSemigroup n, Fin.instIsCancelAdd n with }", "start": [1199, 1], "end": [1201, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.instAddRightCancelSemigroup", "code": "instance instAddRightCancelSemigroup (n : \u2115) : AddRightCancelSemigroup (Fin n) :=\n  { Fin.addCommSemigroup n, Fin.instIsCancelAdd n with }", "start": [1204, 1], "end": [1206, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_neg", "code": "protected theorem coe_neg (a : Fin n) : ((-a : Fin n) : \u2115) = (n - a) % n", "start": [1209, 1], "end": [1210, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_sub", "code": "protected theorem coe_sub (a b : Fin n) : ((a - b : Fin n) : \u2115) = (a + (n - b)) % n", "start": [1213, 1], "end": [1214, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_fin_one", "code": "@[simp]\ntheorem coe_fin_one (a : Fin 1) : (a : \u2115) = 0", "start": [1217, 1], "end": [1218, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_neg_one", "code": "@[simp]\ntheorem coe_neg_one : \u2191(-1 : Fin (n + 1)) = n", "start": [1221, 1], "end": [1226, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_sub_one", "code": "theorem coe_sub_one {n} (a : Fin (n + 1)) : \u2191(a - 1) = if a = 0 then n else a - 1", "start": [1229, 1], "end": [1237, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_sub_iff_le", "code": "theorem coe_sub_iff_le {n : \u2115} {a b : Fin n} : (\u2191(a - b) : \u2115) = a - b \u2194 b \u2264 a", "start": [1240, 1], "end": [1248, 82], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_sub_iff_lt", "code": "theorem coe_sub_iff_lt {n : \u2115} {a b : Fin n} : (\u2191(a - b) : \u2115) = n + a - b \u2194 a < b", "start": [1251, 1], "end": [1261, 12], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_sub_one_iff", "code": "@[simp]\ntheorem lt_sub_one_iff {n : \u2115} {k : Fin (n + 2)} : k < k - 1 \u2194 k = 0", "start": [1264, 1], "end": [1272, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.le_sub_one_iff", "code": "@[simp]\ntheorem le_sub_one_iff {n : \u2115} {k : Fin (n + 1)} : k \u2264 k - 1 \u2194 k = 0", "start": [1275, 1], "end": [1281, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.sub_one_lt_iff", "code": "@[simp]\ntheorem sub_one_lt_iff {n : \u2115} {k : Fin (n + 1)} : k - 1 < k \u2194 0 < k", "start": [1284, 1], "end": [1286, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.last_sub", "code": "theorem last_sub (i : Fin (n + 1)) : last n - i = Fin.rev i", "start": [1289, 1], "end": [1290, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove", "code": "def succAbove (p : Fin (n + 1)) (i : Fin n) : Fin (n + 1) :=\n  if i.1 < p.1 then castSucc i else succ i", "start": [1297, 1], "end": [1299, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.strictMono_succAbove", "code": "theorem strictMono_succAbove (p : Fin (n + 1)) : StrictMono (succAbove p)", "start": [1301, 1], "end": [1304, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.succAboveEmb", "code": "@[simps! apply toEmbedding]\ndef succAboveEmb (p : Fin (n + 1)) : Fin n \u21aao Fin (n + 1) :=\n  OrderEmbedding.ofStrictMono (succAbove p) (strictMono_succAbove p)", "start": [1307, 1], "end": [1311, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_below", "code": "theorem succAbove_below (p : Fin (n + 1)) (i : Fin n) (h : castSucc i < p) :\n    p.succAbove i = castSucc i", "start": [1314, 1], "end": [1317, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_ne_zero_zero", "code": "@[simp]\ntheorem succAbove_ne_zero_zero [NeZero n] {a : Fin (n + 1)} (ha : a \u2260 0) : a.succAbove 0 = 0", "start": [1320, 1], "end": [1324, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_eq_zero_iff", "code": "theorem succAbove_eq_zero_iff [NeZero n] {a : Fin (n + 1)} {b : Fin n} (ha : a \u2260 0) :\n    a.succAbove b = 0 \u2194 b = 0", "start": [1327, 1], "end": [1329, 100], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_ne_zero", "code": "theorem succAbove_ne_zero [NeZero n] {a : Fin (n + 1)} {b : Fin n} (ha : a \u2260 0) (hb : b \u2260 0) :\n    a.succAbove b \u2260 0", "start": [1332, 1], "end": [1334, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_zero", "code": "@[simp]\ntheorem succAbove_zero : succAbove (0 : Fin (n + 1)) = Fin.succ", "start": [1337, 1], "end": [1340, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_last", "code": "@[simp]\ntheorem succAbove_last : succAbove (Fin.last n) = castSucc", "start": [1343, 1], "end": [1347, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_last_apply", "code": "theorem succAbove_last_apply (i : Fin n) : succAbove (Fin.last n) i = castSucc i", "start": [1350, 1], "end": [1351, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_above", "code": "theorem succAbove_above (p : Fin (n + 1)) (i : Fin n) (h : p \u2264 castSucc i) :\n    p.succAbove i = i.succ", "start": [1354, 1], "end": [1357, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_lt_ge", "code": "theorem succAbove_lt_ge (p : Fin (n + 1)) (i : Fin n) : castSucc i < p \u2228 p \u2264 castSucc i", "start": [1360, 1], "end": [1362, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_lt_gt", "code": "theorem succAbove_lt_gt (p : Fin (n + 1)) (i : Fin n) : castSucc i < p \u2228 p < i.succ", "start": [1365, 1], "end": [1368, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_lt_iff", "code": "@[simp]\ntheorem succAbove_lt_iff (p : Fin (n + 1)) (i : Fin n) : p.succAbove i < p \u2194 castSucc i < p", "start": [1371, 1], "end": [1383, 12], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_succAbove_iff", "code": "theorem lt_succAbove_iff (p : Fin (n + 1)) (i : Fin n) : p < p.succAbove i \u2194 p \u2264 castSucc i", "start": [1386, 1], "end": [1397, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_ne", "code": "theorem succAbove_ne (p : Fin (n + 1)) (i : Fin n) : p.succAbove i \u2260 p", "start": [1400, 1], "end": [1406, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_pos", "code": "theorem succAbove_pos [NeZero n] (p : Fin (n + 1)) (i : Fin n) (h : 0 < i) : 0 < p.succAbove i", "start": [1409, 1], "end": [1413, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_castLT", "code": "@[simp]\ntheorem succAbove_castLT {x y : Fin (n + 1)} (h : x < y)\n    (hx : x.1 < n := lt_of_lt_of_le h y.le_last) : y.succAbove (x.castLT hx) = x", "start": [1416, 1], "end": [1420, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_pred", "code": "@[simp]\ntheorem succAbove_pred {x y : Fin (n + 1)} (h : x < y)\n    (hy : y \u2260 0 := (x.zero_le.trans_lt h).ne') : x.succAbove (y.pred hy) = y", "start": [1423, 1], "end": [1427, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.castLT_succAbove", "code": "theorem castLT_succAbove {x : Fin n} {y : Fin (n + 1)} (h : castSucc x < y)\n    (h' : (y.succAbove x).1 < n := lt_of_lt_of_le ((succAbove_lt_iff _ _).2 h) (le_last y)) :\n    (y.succAbove x).castLT h' = x", "start": [1430, 1], "end": [1432, 91], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_succAbove", "code": "theorem pred_succAbove {x : Fin n} {y : Fin (n + 1)} (h : y \u2264 castSucc x)\n    (h' : (y.succAbove x) \u2260 0 := (y.zero_le.trans_lt <| (lt_succAbove_iff _ _).2 h).ne') :\n    (y.succAbove x).pred h' = x", "start": [1435, 1], "end": [1437, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_succAbove_eq", "code": "theorem exists_succAbove_eq {x y : Fin (n + 1)} (h : x \u2260 y) : \u2203 z, y.succAbove z = x", "start": [1440, 1], "end": [1442, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_succAbove_eq_iff", "code": "@[simp]\ntheorem exists_succAbove_eq_iff {x y : Fin (n + 1)} : (\u2203 z, x.succAbove z = y) \u2194 y \u2260 x", "start": [1445, 1], "end": [1449, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.range_succAbove", "code": "@[simp]\ntheorem range_succAbove (p : Fin (n + 1)) : Set.range p.succAbove = {p}\u1d9c", "start": [1452, 1], "end": [1455, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.range_succ", "code": "@[simp]\ntheorem range_succ (n : \u2115) : Set.range (Fin.succ : Fin n \u2192 Fin (n + 1)) = {0}\u1d9c", "start": [1458, 1], "end": [1461, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_succ_eq_iff", "code": "@[simp]\ntheorem exists_succ_eq_iff {x : Fin (n + 1)} : (\u2203 y, Fin.succ y = x) \u2194 x \u2260 0", "start": [1464, 1], "end": [1466, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_right_injective", "code": "theorem succAbove_right_injective {x : Fin (n + 1)} : Injective (succAbove x)", "start": [1469, 1], "end": [1471, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_right_inj", "code": "theorem succAbove_right_inj {x : Fin (n + 1)} : x.succAbove a = x.succAbove b \u2194 a = b", "start": [1474, 1], "end": [1476, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_left_injective", "code": "theorem succAbove_left_injective : Injective (@succAbove n)", "start": [1479, 1], "end": [1481, 92], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_left_inj", "code": "@[simp]\ntheorem succAbove_left_inj {x y : Fin (n + 1)} : x.succAbove = y.succAbove \u2194 x = y", "start": [1484, 1], "end": [1487, 34], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_succAbove", "code": "@[simp]\ntheorem zero_succAbove {n : \u2115} (i : Fin n) : (0 : Fin (n + 1)).succAbove i = i.succ", "start": [1490, 1], "end": [1492, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_succAbove_zero", "code": "@[simp]\ntheorem succ_succAbove_zero {n : \u2115} [NeZero n] (i : Fin n) : succAbove i.succ 0 = 0", "start": [1495, 1], "end": [1497, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_succAbove_succ", "code": "@[simp]\ntheorem succ_succAbove_succ {n : \u2115} (i : Fin (n + 1)) (j : Fin n) :\n    i.succ.succAbove j.succ = (i.succAbove j).succ", "start": [1500, 1], "end": [1511, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.one_succAbove_zero", "code": "theorem one_succAbove_zero {n : \u2115} : (1 : Fin (n + 2)).succAbove 0 = 0", "start": [1515, 1], "end": [1516, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_succAbove_one", "code": "@[simp]\ntheorem succ_succAbove_one {n : \u2115} [NeZero n] (i : Fin (n + 1)) :\n    i.succ.succAbove 1 = (i.succAbove 0).succ", "start": [1519, 1], "end": [1525, 34], "kind": "commanddeclaration"}, {"full_name": "Fin.one_succAbove_succ", "code": "@[simp]\ntheorem one_succAbove_succ {n : \u2115} (j : Fin n) :\n    (1 : Fin (n + 2)).succAbove j.succ = j.succ.succ", "start": [1528, 1], "end": [1532, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.one_succAbove_one", "code": "@[simp]\ntheorem one_succAbove_one {n : \u2115} : (1 : Fin (n + 3)).succAbove 1 = 2", "start": [1535, 1], "end": [1539, 13], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove", "code": "def predAbove (p : Fin n) (i : Fin (n + 1)) : Fin n :=\n  if h : castSucc p < i then i.pred ((ne_iff_vne i 0).mpr (Nat.not_eq_zero_of_lt h))\n  else i.castLT (Nat.lt_of_le_of_lt (Nat.ge_of_not_lt h) p.2)", "start": [1546, 1], "end": [1549, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_right_monotone", "code": "theorem predAbove_right_monotone (p : Fin n) : Monotone p.predAbove", "start": [1552, 1], "end": [1562, 12], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_left_monotone", "code": "theorem predAbove_left_monotone (i : Fin (n + 1)) :\n    Monotone fun p => predAbove p i", "start": [1565, 1], "end": [1573, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred", "code": "def castPred (i : Fin (n + 2)) : Fin (n + 1) := predAbove (last n) i", "start": [1576, 1], "end": [1578, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_zero", "code": "@[simp]\ntheorem castPred_zero : castPred (0 : Fin (n + 2)) = 0", "start": [1581, 1], "end": [1583, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_one", "code": "@[simp]\ntheorem castPred_one : castPred (1 : Fin (n + 2)) = 1", "start": [1586, 1], "end": [1590, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_zero", "code": "@[simp]\ntheorem predAbove_zero {i : Fin (n + 2)} (hi : i \u2260 0) : predAbove 0 i = i.pred hi", "start": [1593, 1], "end": [1597, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_last", "code": "@[simp]\ntheorem castPred_last : castPred (last (n + 1)) = last n", "start": [1600, 1], "end": [1602, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_mk", "code": "theorem castPred_mk (n i : \u2115) (h : i < n + 1) : castPred \u27e8i, lt_succ_of_lt h\u27e9 = \u27e8i, h\u27e9", "start": [1606, 1], "end": [1609, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_mk'", "code": "@[simp]\ntheorem castPred_mk' (n i : \u2115) (h\u2081 : i < n + 2) (h\u2082 : i < n + 1) : castPred \u27e8i, h\u2081\u27e9 = \u27e8i, h\u2082\u27e9", "start": [1613, 1], "end": [1615, 20], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castPred", "code": "theorem coe_castPred {n : \u2115} (a : Fin (n + 2)) (hx : a < Fin.last _) :\n    (a.castPred : \u2115) = a", "start": [1617, 1], "end": [1621, 11], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_below", "code": "theorem predAbove_below (p : Fin (n + 1)) (i : Fin (n + 2)) (h : i \u2264 castSucc p) :\n    p.predAbove i = i.castPred", "start": [1624, 1], "end": [1627, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_last", "code": "@[simp]\ntheorem predAbove_last : predAbove (Fin.last n) = castPred", "start": [1630, 1], "end": [1632, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_last_apply", "code": "theorem predAbove_last_apply (i : Fin n) : predAbove (Fin.last n) i = i.castPred", "start": [1635, 1], "end": [1636, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_above", "code": "theorem predAbove_above (p : Fin n) (i : Fin (n + 1)) (h : castSucc p < i) :\n    p.predAbove i = i.pred ((zero_le <| castSucc p).trans_lt h).ne.symm", "start": [1639, 1], "end": [1641, 22], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_monotone", "code": "theorem castPred_monotone : Monotone (@castPred n)", "start": [1644, 1], "end": [1645, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_predAbove", "code": "@[simp]\ntheorem succAbove_predAbove {p : Fin n} {i : Fin (n + 1)} (h : i \u2260 castSucc p) :\n    p.castSucc.succAbove (p.predAbove i) = i", "start": [1648, 1], "end": [1668, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.predAbove_succAbove", "code": "@[simp]\ntheorem predAbove_succAbove (p : Fin n) (i : Fin n) :\n    p.predAbove ((castSucc p).succAbove i) = i", "start": [1671, 1], "end": [1686, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_pred_eq_pred_castSucc", "code": "theorem castSucc_pred_eq_pred_castSucc {a : Fin (n + 1)} (ha : a \u2260 0)\n    (ha' := a.castSucc_ne_zero_iff.mpr ha) :\n    castSucc (a.pred ha) = (castSucc a).pred ha'", "start": [1689, 1], "end": [1693, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.pred_succAbove_pred", "code": "theorem pred_succAbove_pred {a : Fin (n + 2)} {b : Fin (n + 1)} (ha : a \u2260 0) (hb : b \u2260 0)\n    (hk := succAbove_ne_zero ha hb) :\n    (a.pred ha).succAbove (b.pred hb) = (a.succAbove b).pred hk", "start": [1696, 1], "end": [1708, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.succ_predAbove_succ", "code": "@[simp]\ntheorem succ_predAbove_succ {n : \u2115} (a : Fin n) (b : Fin (n + 1)) :\n    a.succ.predAbove b.succ = (a.predAbove b).succ", "start": [1711, 1], "end": [1734, 70], "kind": "commanddeclaration"}, {"full_name": "Fin.castPred_castSucc", "code": "@[simp]\ntheorem castPred_castSucc (i : Fin (n + 1)) : castPred (castSucc i) = i", "start": [1737, 1], "end": [1739, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.castSucc_castPred", "code": "theorem castSucc_castPred {i : Fin (n + 2)} (h : i < last (n + 1)) :\n    castSucc i.castPred = i", "start": [1742, 1], "end": [1746, 19], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castPred_le_self", "code": "theorem coe_castPred_le_self (i : Fin (n + 2)) : (i.castPred : \u2115) \u2264 i", "start": [1749, 1], "end": [1754, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_castPred_lt_iff", "code": "theorem coe_castPred_lt_iff {i : Fin (n + 2)} : (i.castPred : \u2115) < i \u2194 i = Fin.last _", "start": [1757, 1], "end": [1762, 9], "kind": "commanddeclaration"}, {"full_name": "Fin.lt_last_iff_coe_castPred", "code": "theorem lt_last_iff_coe_castPred {i : Fin (n + 2)} :\n    i < Fin.last _ \u2194 (i.castPred : \u2115) = i", "start": [1765, 1], "end": [1771, 9], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_ofNat_eq_mod", "code": "@[simp]\ntheorem coe_ofNat_eq_mod (m n : \u2115) [NeZero m] :\n    ((n : Fin m) : \u2115) = n % m", "start": [1778, 1], "end": [1781, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_one'", "code": "protected theorem mul_one' [NeZero n] (k : Fin n) : k * 1 = k", "start": [1793, 1], "end": [1798, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.one_mul'", "code": "protected theorem one_mul' [NeZero n] (k : Fin n) : (1 : Fin n) * k = k", "start": [1803, 1], "end": [1804, 34], "kind": "commanddeclaration"}, {"full_name": "Fin.mul_zero'", "code": "protected theorem mul_zero' [NeZero n] (k : Fin n) : k * 0 = 0", "start": [1807, 1], "end": [1807, 96], "kind": "commanddeclaration"}, {"full_name": "Fin.zero_mul'", "code": "protected theorem zero_mul' [NeZero n] (k : Fin n) : (0 : Fin n) * k = 0", "start": [1810, 1], "end": [1811, 29], "kind": "commanddeclaration"}, {"full_name": "Fin.toExpr", "code": "instance toExpr (n : \u2115) : Lean.ToExpr (Fin n) where\n  toTypeExpr := q(Fin $n)\n  toExpr := match n with\n    | 0 => finZeroElim\n    | k + 1 => fun i => show Q(Fin $n) from\n      have i : Q(Nat) := Lean.mkRawNatLit i have : Q(NeZero $n) := haveI : $n =Q $k + 1 := \u27e8\u27e9; by exact q(NeZero.succ)\n      q(OfNat.ofNat $i)", "start": [1817, 1], "end": [1824, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Range.lean", "imports": ["Mathlib/Data/List/Chain.lean", "Mathlib/Data/List/Nodup.lean", "Mathlib/Data/List/Zip.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.range'_one", "code": "@[simp] theorem range'_one {step} : range' s 1 step = [s]", "start": [34, 1], "end": [34, 65], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_lt_range'", "code": "theorem pairwise_lt_range' : \u2200 s n (step := 1) (_ : 0 < step := by simp),\n  Pairwise (\u00b7 < \u00b7) (range' s n step)", "start": [44, 1], "end": [47, 67], "kind": "commanddeclaration"}, {"full_name": "List.nodup_range'", "code": "theorem nodup_range' (s n : \u2115) (step := 1) (h : 0 < step := by simp) : Nodup (range' s n step)", "start": [50, 1], "end": [51, 54], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_range'", "code": "@[simp]\ntheorem nthLe_range' {n m step} (i) (H : i < (range' n m step).length) :\n    nthLe (range' n m step) i H = n + step * i", "start": [59, 1], "end": [61, 65], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_range'_1", "code": "theorem nthLe_range'_1 {n m} (i) (H : i < (range' n m).length) :\n    nthLe (range' n m) i H = n + i", "start": [64, 1], "end": [65, 46], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_lt_range", "code": "theorem pairwise_lt_range (n : \u2115) : Pairwise (\u00b7 < \u00b7) (range n)", "start": [77, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_le_range", "code": "theorem pairwise_le_range (n : \u2115) : Pairwise (\u00b7 \u2264 \u00b7) (range n)", "start": [81, 1], "end": [82, 53], "kind": "commanddeclaration"}, {"full_name": "List.nodup_range", "code": "theorem nodup_range (n : \u2115) : Nodup (range n)", "start": [85, 1], "end": [85, 94], "kind": "commanddeclaration"}, {"full_name": "List.chain'_range_succ", "code": "theorem chain'_range_succ (r : \u2115 \u2192 \u2115 \u2192 Prop) (n : \u2115) :\n    Chain' r (range n.succ) \u2194 \u2200 m < n, r m m.succ", "start": [96, 1], "end": [104, 28], "kind": "commanddeclaration"}, {"full_name": "List.chain_range_succ", "code": "theorem chain_range_succ (r : \u2115 \u2192 \u2115 \u2192 Prop) (n a : \u2115) :\n    Chain r a (range n.succ) \u2194 r a 0 \u2227 \u2200 m < n, r m m.succ", "start": [107, 1], "end": [110, 25], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_gt_iota", "code": "theorem pairwise_gt_iota (n : \u2115) : Pairwise (\u00b7 > \u00b7) (iota n)", "start": [117, 1], "end": [118, 85], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iota", "code": "theorem nodup_iota (n : \u2115) : Nodup (iota n)", "start": [121, 1], "end": [122, 43], "kind": "commanddeclaration"}, {"full_name": "List.finRange", "code": "def finRange (n : \u2115) : List (Fin n) :=\n  (range n).pmap Fin.mk fun _ => List.mem_range.1", "start": [128, 1], "end": [130, 50], "kind": "commanddeclaration"}, {"full_name": "List.finRange_zero", "code": "@[simp]\ntheorem finRange_zero : finRange 0 = []", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "List.mem_finRange", "code": "@[simp]\ntheorem mem_finRange {n : \u2115} (a : Fin n) : a \u2208 finRange n", "start": [138, 1], "end": [143, 11], "kind": "commanddeclaration"}, {"full_name": "List.nodup_finRange", "code": "theorem nodup_finRange (n : \u2115) : (finRange n).Nodup", "start": [146, 1], "end": [147, 82], "kind": "commanddeclaration"}, {"full_name": "List.length_finRange", "code": "@[simp]\ntheorem length_finRange (n : \u2115) : (finRange n).length = n", "start": [150, 1], "end": [152, 43], "kind": "commanddeclaration"}, {"full_name": "List.finRange_eq_nil", "code": "@[simp]\ntheorem finRange_eq_nil {n : \u2115} : finRange n = [] \u2194 n = 0", "start": [155, 1], "end": [157, 41], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_lt_finRange", "code": "theorem pairwise_lt_finRange (n : \u2115) : Pairwise (\u00b7 < \u00b7) (finRange n)", "start": [160, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_le_finRange", "code": "theorem pairwise_le_finRange (n : \u2115) : Pairwise (\u00b7 \u2264 \u00b7) (finRange n)", "start": [163, 1], "end": [164, 54], "kind": "commanddeclaration"}, {"full_name": "List.prod_range_succ", "code": "@[to_additive]\ntheorem prod_range_succ {\u03b1 : Type u} [Monoid \u03b1] (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    ((range n.succ).map f).prod = ((range n).map f).prod * f n", "start": [166, 1], "end": [169, 88], "kind": "commanddeclaration"}, {"full_name": "List.prod_range_succ'", "code": "@[to_additive\n  \"A variant of `sum_range_succ` which pulls off the first term in the sum rather than the last.\"]\ntheorem prod_range_succ' {\u03b1 : Type u} [Monoid \u03b1] (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    ((range n.succ).map f).prod = f 0 * ((range n).map fun i => f (succ i)).prod", "start": [173, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "List.enum_eq_zip_range", "code": "theorem enum_eq_zip_range (l : List \u03b1) : l.enum = (range l.length).zip l", "start": [187, 1], "end": [188, 48], "kind": "commanddeclaration"}, {"full_name": "List.unzip_enum_eq_prod", "code": "@[simp]\ntheorem unzip_enum_eq_prod (l : List \u03b1) : l.enum.unzip = (range l.length, l)", "start": [191, 1], "end": [193, 57], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_eq_zip_range'", "code": "theorem enumFrom_eq_zip_range' (l : List \u03b1) {n : \u2115} : l.enumFrom n = (range' n l.length).zip l", "start": [196, 1], "end": [197, 60], "kind": "commanddeclaration"}, {"full_name": "List.unzip_enumFrom_eq_prod", "code": "@[simp]\ntheorem unzip_enumFrom_eq_prod (l : List \u03b1) {n : \u2115} :\n    (l.enumFrom n).unzip = (range' n l.length, l)", "start": [200, 1], "end": [203, 63], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_range", "code": "@[simp]\ntheorem nthLe_range {n} (i) (H : i < (range n).length) : nthLe (range n) i H = i", "start": [207, 1], "end": [209, 16], "kind": "commanddeclaration"}, {"full_name": "List.get_finRange", "code": "@[simp]\ntheorem get_finRange {n : \u2115} {i : \u2115} (h) :\n    (finRange n).get \u27e8i, h\u27e9 = \u27e8i, length_finRange n \u25b8 h\u27e9", "start": [213, 1], "end": [216, 44], "kind": "commanddeclaration"}, {"full_name": "List.finRange_map_get", "code": "@[simp]\ntheorem finRange_map_get (l : List \u03b1) : (finRange l.length).map l.get = l", "start": [219, 1], "end": [221, 35], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_finRange", "code": "@[simp]\ntheorem nthLe_finRange {n : \u2115} {i : \u2115} (h) :\n    (finRange n).nthLe i h = \u27e8i, length_finRange n \u25b8 h\u27e9", "start": [225, 1], "end": [228, 17], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_finRange", "code": "@[simp] theorem indexOf_finRange (i : Fin k) : (finRange k).indexOf i = i", "start": [231, 1], "end": [235, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Dedup.lean", "imports": ["Mathlib/Data/List/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.dedup_nil", "code": "@[simp]\ntheorem dedup_nil : dedup [] = ([] : List \u03b1)", "start": [29, 1], "end": [31, 6], "kind": "commanddeclaration"}, {"full_name": "List.dedup_cons_of_mem'", "code": "theorem dedup_cons_of_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2208 dedup l) : dedup (a :: l) = dedup l", "start": [34, 1], "end": [35, 73], "kind": "commanddeclaration"}, {"full_name": "List.dedup_cons_of_not_mem'", "code": "theorem dedup_cons_of_not_mem' {a : \u03b1} {l : List \u03b1} (h : a \u2209 dedup l) :\n    dedup (a :: l) = a :: dedup l", "start": [38, 1], "end": [40, 64], "kind": "commanddeclaration"}, {"full_name": "List.mem_dedup", "code": "@[simp]\ntheorem mem_dedup {a : \u03b1} {l : List \u03b1} : a \u2208 dedup l \u2194 a \u2208 l", "start": [43, 1], "end": [48, 54], "kind": "commanddeclaration"}, {"full_name": "List.dedup_cons_of_mem", "code": "@[simp]\ntheorem dedup_cons_of_mem {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : dedup (a :: l) = dedup l", "start": [51, 1], "end": [53, 38], "kind": "commanddeclaration"}, {"full_name": "List.dedup_cons_of_not_mem", "code": "@[simp]\ntheorem dedup_cons_of_not_mem {a : \u03b1} {l : List \u03b1} (h : a \u2209 l) : dedup (a :: l) = a :: dedup l", "start": [56, 1], "end": [58, 45], "kind": "commanddeclaration"}, {"full_name": "List.dedup_sublist", "code": "theorem dedup_sublist : \u2200 l : List \u03b1, dedup l <+ l", "start": [61, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "List.dedup_subset", "code": "theorem dedup_subset : \u2200 l : List \u03b1, dedup l \u2286 l", "start": [65, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "List.subset_dedup", "code": "theorem subset_dedup (l : List \u03b1) : l \u2286 dedup l", "start": [69, 1], "end": [69, 72], "kind": "commanddeclaration"}, {"full_name": "List.nodup_dedup", "code": "theorem nodup_dedup : \u2200 l : List \u03b1, Nodup (dedup l)", "start": [72, 1], "end": [73, 20], "kind": "commanddeclaration"}, {"full_name": "List.headI_dedup", "code": "theorem headI_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.headI = if l.headI \u2208 l.tail then l.tail.dedup.headI else l.headI", "start": [76, 1], "end": [80, 75], "kind": "commanddeclaration"}, {"full_name": "List.tail_dedup", "code": "theorem tail_dedup [Inhabited \u03b1] (l : List \u03b1) :\n    l.dedup.tail = if l.headI \u2208 l.tail then l.tail.dedup.tail else l.tail.dedup", "start": [83, 1], "end": [87, 75], "kind": "commanddeclaration"}, {"full_name": "List.dedup_eq_self", "code": "theorem dedup_eq_self {l : List \u03b1} : dedup l = l \u2194 Nodup l", "start": [90, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "List.dedup_eq_cons", "code": "theorem dedup_eq_cons (l : List \u03b1) (a : \u03b1) (l' : List \u03b1) :\n    l.dedup = a :: l' \u2194 a \u2208 l \u2227 a \u2209 l' \u2227 l.dedup.tail = l'", "start": [94, 1], "end": [104, 84], "kind": "commanddeclaration"}, {"full_name": "List.dedup_eq_nil", "code": "@[simp]\ntheorem dedup_eq_nil (l : List \u03b1) : l.dedup = [] \u2194 l = []", "start": [107, 1], "end": [113, 65], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.dedup", "code": "protected theorem Nodup.dedup {l : List \u03b1} (h : l.Nodup) : l.dedup = l", "start": [116, 1], "end": [117, 25], "kind": "commanddeclaration"}, {"full_name": "List.dedup_idem", "code": "@[simp]\ntheorem dedup_idem {l : List \u03b1} : dedup (dedup l) = dedup l", "start": [120, 1], "end": [122, 16], "kind": "commanddeclaration"}, {"full_name": "List.dedup_append", "code": "theorem dedup_append (l\u2081 l\u2082 : List \u03b1) : dedup (l\u2081 ++ l\u2082) = l\u2081 \u222a dedup l\u2082", "start": [125, 1], "end": [131, 55], "kind": "commanddeclaration"}, {"full_name": "List.replicate_dedup", "code": "theorem replicate_dedup {x : \u03b1} : \u2200 {k}, k \u2260 0 \u2192 (replicate k x).dedup = [x]", "start": [134, 1], "end": [139, 38], "kind": "commanddeclaration"}, {"full_name": "List.count_dedup", "code": "theorem count_dedup (l : List \u03b1) (a : \u03b1) : l.dedup.count a = if a \u2208 l then 1 else 0", "start": [142, 1], "end": [143, 58], "kind": "commanddeclaration"}, {"full_name": "List.sum_map_count_dedup_filter_eq_countP", "code": "theorem sum_map_count_dedup_filter_eq_countP (p : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    ((l.dedup.filter p).map fun x => l.count x).sum = l.countP p", "start": [146, 1], "end": [168, 27], "kind": "commanddeclaration"}, {"full_name": "List.sum_map_count_dedup_eq_length", "code": "theorem sum_map_count_dedup_eq_length (l : List \u03b1) :\n    (l.dedup.map fun x => l.count x).sum = l.length", "start": [171, 1], "end": [173, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Factorial/Basic.lean", "imports": ["Mathlib/Tactic/GCongr/Core.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/Nat/Pow.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "Nat.factorial", "code": "def factorial : \u2115 \u2192 \u2115\n  | 0 => 1\n  | succ n => succ n * factorial n", "start": [29, 1], "end": [32, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_zero", "code": "@[simp]\ntheorem factorial_zero : 0! = 1", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_succ", "code": "theorem factorial_succ (n : \u2115) : n.succ ! = (n + 1) * n !", "start": [47, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_one", "code": "theorem factorial_one : 1! = 1", "start": [53, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_two", "code": "theorem factorial_two : 2! = 2", "start": [58, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_factorial_pred", "code": "theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n !", "start": [62, 1], "end": [63, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_pos", "code": "theorem factorial_pos : \u2200 n, 0 < n !", "start": [66, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_ne_zero", "code": "theorem factorial_ne_zero (n : \u2115) : n ! \u2260 0", "start": [71, 1], "end": [72, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_dvd_factorial", "code": "theorem factorial_dvd_factorial {m n} (h : m \u2264 n) : m ! \u2223 n !", "start": [75, 1], "end": [80, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_factorial", "code": "theorem dvd_factorial : \u2200 {m n}, 0 < m \u2192 m \u2264 n \u2192 m \u2223 n !", "start": [83, 1], "end": [84, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_le", "code": "@[mono]\ntheorem factorial_le {m n} (h : m \u2264 n) : m ! \u2264 n !", "start": [87, 1], "end": [89, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_pow_le_factorial", "code": "theorem factorial_mul_pow_le_factorial : \u2200 {m n : \u2115}, m ! * m.succ ^ n \u2264 (m + n)!", "start": [93, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.monotone_factorial", "code": "theorem monotone_factorial : Monotone factorial", "start": [103, 1], "end": [103, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_le_of_le", "code": "@[gcongr]\nlemma factorial_le_of_le {m n : \u2115} (h : n \u2264 m) : n ! \u2264 m ! := monotone_factorial h", "start": [106, 1], "end": [107, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.factorial_lt", "code": "theorem factorial_lt (hn : 0 < n) : n ! < m ! \u2194 n < m", "start": [109, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_lt_of_lt", "code": "@[gcongr]\nlemma factorial_lt_of_lt {m n : \u2115} (hn : 0 < n) (h : n < m) : n ! < m ! := (factorial_lt hn).mpr h", "start": [120, 1], "end": [121, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.one_lt_factorial", "code": "theorem one_lt_factorial : 1 < n ! \u2194 1 < n", "start": [123, 1], "end": [124, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_eq_one", "code": "theorem factorial_eq_one : n ! = 1 \u2194 n \u2264 1", "start": [128, 1], "end": [134, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_inj", "code": "theorem factorial_inj (hn : 1 < n !) : n ! = m ! \u2194 n = m", "start": [137, 1], "end": [145, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.self_le_factorial", "code": "theorem self_le_factorial : \u2200 n : \u2115, n \u2264 n !", "start": [148, 1], "end": [150, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_factorial_self", "code": "theorem lt_factorial_self {n : \u2115} (hi : 3 \u2264 n) : n < n !", "start": [155, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.add_factorial_succ_lt_factorial_add_succ", "code": "theorem add_factorial_succ_lt_factorial_add_succ {i : \u2115} (n : \u2115) (hi : 2 \u2264 i) :\n    i + (n + 1)! < (i + n + 1)!", "start": [164, 1], "end": [177, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.add_factorial_lt_factorial_add", "code": "theorem add_factorial_lt_factorial_add {i n : \u2115} (hi : 2 \u2264 i) (hn : 1 \u2264 n) :\n    i + n ! < (i + n)!", "start": [180, 1], "end": [185, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.add_factorial_succ_le_factorial_add_succ", "code": "theorem add_factorial_succ_le_factorial_add_succ (i : \u2115) (n : \u2115) :\n    i + (n + 1)! \u2264 (i + (n + 1))!", "start": [188, 1], "end": [203, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.add_factorial_le_factorial_add", "code": "theorem add_factorial_le_factorial_add (i : \u2115) {n : \u2115} (n1 : 1 \u2264 n) : i + n ! \u2264 (i + n)!", "start": [206, 1], "end": [209, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_pow_sub_le_factorial", "code": "theorem factorial_mul_pow_sub_le_factorial {n m : \u2115} (hnm : n \u2264 m) : n ! * n ^ (m - n) \u2264 m !", "start": [212, 1], "end": [219, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial", "code": "def ascFactorial (n : \u2115) : \u2115 \u2192 \u2115\n  | 0 => 1\n  | k + 1 => (n + k + 1) * ascFactorial n k", "start": [229, 1], "end": [234, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_zero", "code": "@[simp]\ntheorem ascFactorial_zero (n : \u2115) : n.ascFactorial 0 = 1", "start": [237, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_ascFactorial", "code": "@[simp]\ntheorem zero_ascFactorial (k : \u2115) : (0 : \u2115).ascFactorial k = k !", "start": [242, 1], "end": [246, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_succ", "code": "theorem ascFactorial_succ {n k : \u2115} : n.ascFactorial k.succ = (n + k + 1) * n.ascFactorial k", "start": [249, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_ascFactorial", "code": "theorem succ_ascFactorial (n : \u2115) :\n    \u2200 k, (n + 1) * n.succ.ascFactorial k = (n + k + 1) * n.ascFactorial k", "start": [254, 1], "end": [259, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_ascFactorial", "code": "theorem factorial_mul_ascFactorial (n : \u2115) : \u2200 k, n ! * n.ascFactorial k = (n + k)!", "start": [262, 1], "end": [270, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_eq_div", "code": "theorem ascFactorial_eq_div (n k : \u2115) : n.ascFactorial k = (n + k)! / n !", "start": [273, 1], "end": [277, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_of_sub", "code": "theorem ascFactorial_of_sub {n k : \u2115} (h : k < n) :\n    (n - k) * (n - k).ascFactorial k = (n - (k + 1)).ascFactorial (k + 1)", "start": [280, 1], "end": [285, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_succ_le_ascFactorial", "code": "theorem pow_succ_le_ascFactorial (n : \u2115) : \u2200 k : \u2115, (n + 1) ^ k \u2264 n.ascFactorial k", "start": [288, 1], "end": [292, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_ascFactorial'", "code": "theorem pow_lt_ascFactorial' (n k : \u2115) : (n + 1) ^ (k + 2) < n.ascFactorial (k + 2)", "start": [295, 1], "end": [299, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_lt_ascFactorial", "code": "theorem pow_lt_ascFactorial (n : \u2115) : \u2200 {k : \u2115}, 2 \u2264 k \u2192 (n + 1) ^ k < n.ascFactorial k", "start": [302, 1], "end": [305, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_le_pow_add", "code": "theorem ascFactorial_le_pow_add (n : \u2115) : \u2200 k : \u2115, n.ascFactorial k \u2264 (n + k) ^ k", "start": [308, 1], "end": [315, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_lt_pow_add", "code": "theorem ascFactorial_lt_pow_add (n : \u2115) : \u2200 {k : \u2115}, 2 \u2264 k \u2192 n.ascFactorial k < (n + k) ^ k", "start": [318, 1], "end": [328, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_pos", "code": "theorem ascFactorial_pos (n k : \u2115) : 0 < n.ascFactorial k", "start": [331, 1], "end": [332, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial", "code": "def descFactorial (n : \u2115) : \u2115 \u2192 \u2115\n  | 0 => 1\n  | k + 1 => (n - k) * descFactorial n k", "start": [339, 1], "end": [344, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_zero", "code": "@[simp]\ntheorem descFactorial_zero (n : \u2115) : n.descFactorial 0 = 1", "start": [347, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_succ", "code": "@[simp]\ntheorem descFactorial_succ (n k : \u2115) : n.descFactorial k.succ = (n - k) * n.descFactorial k", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_descFactorial_succ", "code": "theorem zero_descFactorial_succ (k : \u2115) : (0 : \u2115).descFactorial k.succ = 0", "start": [357, 1], "end": [358, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_one", "code": "theorem descFactorial_one (n : \u2115) : n.descFactorial 1 = n", "start": [365, 1], "end": [366, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_descFactorial_succ", "code": "theorem succ_descFactorial_succ (n : \u2115) :\n    \u2200 k : \u2115, (n + 1).descFactorial (k + 1) = (n + 1) * n.descFactorial k", "start": [379, 1], "end": [384, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_descFactorial", "code": "theorem succ_descFactorial (n : \u2115) :\n    \u2200 k, (n + 1 - k) * (n + 1).descFactorial k = (n + 1) * n.descFactorial k", "start": [387, 1], "end": [391, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_self", "code": "theorem descFactorial_self : \u2200 n : \u2115, n.descFactorial n = n !", "start": [394, 1], "end": [396, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_eq_zero_iff_lt", "code": "@[simp]\ntheorem descFactorial_eq_zero_iff_lt {n : \u2115} : \u2200 {k : \u2115}, n.descFactorial k = 0 \u2194 n < k", "start": [399, 1], "end": [405, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_of_lt", "code": "alias \u27e8_, descFactorial_of_lt\u27e9 := descFactorial_eq_zero_iff_lt", "start": [408, 1], "end": [408, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.add_descFactorial_eq_ascFactorial", "code": "theorem add_descFactorial_eq_ascFactorial (n : \u2115) :\n    \u2200 k : \u2115, (n + k).descFactorial k = n.ascFactorial k", "start": [411, 1], "end": [416, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_descFactorial", "code": "theorem factorial_mul_descFactorial : \u2200 {n k : \u2115}, k \u2264 n \u2192 (n - k)! * n.descFactorial k = n !", "start": [419, 1], "end": [428, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_eq_div", "code": "theorem descFactorial_eq_div {n k : \u2115} (h : k \u2264 n) : n.descFactorial k = n ! / (n - k)!", "start": [431, 1], "end": [435, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_sub_le_descFactorial", "code": "theorem pow_sub_le_descFactorial (n : \u2115) : \u2200 k : \u2115, (n + 1 - k) ^ k \u2264 n.descFactorial k", "start": [438, 1], "end": [444, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_sub_lt_descFactorial'", "code": "theorem pow_sub_lt_descFactorial' {n : \u2115} :\n    \u2200 {k : \u2115}, k + 2 \u2264 n \u2192 (n - (k + 1)) ^ (k + 2) < n.descFactorial (k + 2)", "start": [447, 1], "end": [460, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_sub_lt_descFactorial", "code": "theorem pow_sub_lt_descFactorial {n : \u2115} :\n    \u2200 {k : \u2115}, 2 \u2264 k \u2192 k \u2264 n \u2192 (n + 1 - k) ^ k < n.descFactorial k", "start": [463, 1], "end": [469, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_le_pow", "code": "theorem descFactorial_le_pow (n : \u2115) : \u2200 k : \u2115, n.descFactorial k \u2264 n ^ k", "start": [472, 1], "end": [476, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_lt_pow", "code": "theorem descFactorial_lt_pow {n : \u2115} (hn : 1 \u2264 n) : \u2200 {k : \u2115}, 2 \u2264 k \u2192 n.descFactorial k < n ^ k", "start": [479, 1], "end": [485, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Permutation.lean", "imports": ["Mathlib/Data/List/Join.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.permutationsAux2_fst", "code": "theorem permutationsAux2_fst (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) :\n    \u2200 (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2), (permutationsAux2 t ts r ys f).1 = ys ++ ts", "start": [54, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2_snd_nil", "code": "@[simp]\ntheorem permutationsAux2_snd_nil (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts r [] f).2 = r", "start": [60, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2_snd_cons", "code": "@[simp]\ntheorem permutationsAux2_snd_cons (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (y : \u03b1) (ys : List \u03b1)\n    (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts r (y :: ys) f).2 =\n      f (t :: y :: ys ++ ts) :: (permutationsAux2 t ts r ys fun x : List \u03b1 => f (y :: x)).2", "start": [66, 1], "end": [71, 60], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2_append", "code": "theorem permutationsAux2_append (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts nil ys f).2 ++ r = (permutationsAux2 t ts r ys f).2", "start": [74, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2_comp_append", "code": "theorem permutationsAux2_comp_append {t : \u03b1} {ts ys : List \u03b1} {r : List \u03b2} (f : List \u03b1 \u2192 \u03b2) :\n    ((permutationsAux2 t [] r ys) fun x => f (x ++ ts)).2 = (permutationsAux2 t ts r ys f).2", "start": [80, 1], "end": [85, 43], "kind": "commanddeclaration"}, {"full_name": "List.map_permutationsAux2'", "code": "theorem map_permutationsAux2' {\u03b1 \u03b2 \u03b1' \u03b2'} (g : \u03b1 \u2192 \u03b1') (g' : \u03b2 \u2192 \u03b2') (t : \u03b1) (ts ys : List \u03b1)\n    (r : List \u03b2) (f : List \u03b1 \u2192 \u03b2) (f' : List \u03b1' \u2192 \u03b2') (H : \u2200 a, g' (f a) = f' (map g a)) :\n    map g' (permutationsAux2 t ts r ys f).2 =\n      (permutationsAux2 (g t) (map g ts) (map g' r) (map g ys) f').2", "start": [88, 1], "end": [98, 23], "kind": "commanddeclaration"}, {"full_name": "List.map_permutationsAux2", "code": "theorem map_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts [] ys id).2.map f = (permutationsAux2 t ts [] ys f).2", "start": [101, 1], "end": [105, 7], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2_snd_eq", "code": "theorem permutationsAux2_snd_eq (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    (permutationsAux2 t ts r ys f).2 =\n      ((permutationsAux2 t [] [] ys id).2.map fun x => f (x ++ ts)) ++ r", "start": [108, 1], "end": [121, 88], "kind": "commanddeclaration"}, {"full_name": "List.map_map_permutationsAux2", "code": "theorem map_map_permutationsAux2 {\u03b1 \u03b1'} (g : \u03b1 \u2192 \u03b1') (t : \u03b1) (ts ys : List \u03b1) :\n    map (map g) (permutationsAux2 t ts [] ys id).2 =\n      (permutationsAux2 (g t) (map g ts) [] (map g ys) id).2", "start": [124, 1], "end": [127, 53], "kind": "commanddeclaration"}, {"full_name": "List.map_map_permutations'Aux", "code": "theorem map_map_permutations'Aux (f : \u03b1 \u2192 \u03b2) (t : \u03b1) (ts : List \u03b1) :\n    map (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts)", "start": [130, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "List.permutations'Aux_eq_permutationsAux2", "code": "theorem permutations'Aux_eq_permutationsAux2 (t : \u03b1) (ts : List \u03b1) :\n    permutations'Aux t ts = (permutationsAux2 t [] [ts ++ [t]] ts id).2", "start": [135, 1], "end": [141, 30], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutationsAux2", "code": "theorem mem_permutationsAux2 {t : \u03b1} {ts : List \u03b1} {ys : List \u03b1} {l l' : List \u03b1} :\n    l' \u2208 (permutationsAux2 t ts [] ys (l ++ \u00b7)).2 \u2194\n      \u2203 l\u2081 l\u2082, l\u2082 \u2260 [] \u2227 ys = l\u2081 ++ l\u2082 \u2227 l' = l ++ l\u2081 ++ t :: l\u2082 ++ ts", "start": [144, 1], "end": [159, 41], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutationsAux2'", "code": "theorem mem_permutationsAux2' {t : \u03b1} {ts : List \u03b1} {ys : List \u03b1} {l : List \u03b1} :\n    l \u2208 (permutationsAux2 t ts [] ys id).2 \u2194\n      \u2203 l\u2081 l\u2082, l\u2082 \u2260 [] \u2227 ys = l\u2081 ++ l\u2082 \u2227 l = l\u2081 ++ t :: l\u2082 ++ ts", "start": [162, 1], "end": [165, 85], "kind": "commanddeclaration"}, {"full_name": "List.length_permutationsAux2", "code": "theorem length_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (ys : List \u03b1) (f : List \u03b1 \u2192 \u03b2) :\n    length (permutationsAux2 t ts [] ys f).2 = length ys", "start": [168, 1], "end": [170, 43], "kind": "commanddeclaration"}, {"full_name": "List.foldr_permutationsAux2", "code": "theorem foldr_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (r L : List (List \u03b1)) :\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) r L =\n      (L.bind fun y => (permutationsAux2 t ts [] y id).2) ++ r", "start": [173, 1], "end": [179, 35], "kind": "commanddeclaration"}, {"full_name": "List.mem_foldr_permutationsAux2", "code": "theorem mem_foldr_permutationsAux2 {t : \u03b1} {ts : List \u03b1} {r L : List (List \u03b1)} {l' : List \u03b1} :\n    l' \u2208 foldr (fun y r => (permutationsAux2 t ts r y id).2) r L \u2194\n      l' \u2208 r \u2228 \u2203 l\u2081 l\u2082, l\u2081 ++ l\u2082 \u2208 L \u2227 l\u2082 \u2260 [] \u2227 l' = l\u2081 ++ t :: l\u2082 ++ ts", "start": [182, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "List.length_foldr_permutationsAux2", "code": "theorem length_foldr_permutationsAux2 (t : \u03b1) (ts : List \u03b1) (r L : List (List \u03b1)) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) =\n      sum (map length L) + length r", "start": [196, 1], "end": [199, 69], "kind": "commanddeclaration"}, {"full_name": "List.length_foldr_permutationsAux2'", "code": "theorem length_foldr_permutationsAux2' (t : \u03b1) (ts : List \u03b1) (r L : List (List \u03b1)) (n)\n    (H : \u2200 l \u2208 L, length l = n) :\n    length (foldr (fun y r => (permutationsAux2 t ts r y id).2) r L) = n * length L + length r", "start": [202, 1], "end": [210, 56], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux_nil", "code": "@[simp]\ntheorem permutationsAux_nil (is : List \u03b1) : permutationsAux [] is = []", "start": [213, 1], "end": [215, 44], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux_cons", "code": "@[simp]\ntheorem permutationsAux_cons (t : \u03b1) (ts is : List \u03b1) :\n    permutationsAux (t :: ts) is =\n      foldr (fun y r => (permutationsAux2 t ts r y id).2) (permutationsAux ts (t :: is))\n        (permutations is)", "start": [218, 1], "end": [223, 52], "kind": "commanddeclaration"}, {"full_name": "List.permutations_nil", "code": "@[simp]\ntheorem permutations_nil : permutations ([] : List \u03b1) = [[]]", "start": [226, 1], "end": [228, 41], "kind": "commanddeclaration"}, {"full_name": "List.map_permutationsAux", "code": "theorem map_permutationsAux (f : \u03b1 \u2192 \u03b2) :\n    \u2200 ts is :\n    List \u03b1, map (map f) (permutationsAux ts is) = permutationsAux (map f ts) (map f is)", "start": [231, 1], "end": [237, 83], "kind": "commanddeclaration"}, {"full_name": "List.map_permutations", "code": "theorem map_permutations (f : \u03b1 \u2192 \u03b2) (ts : List \u03b1) :\n    map (map f) (permutations ts) = permutations (map f ts)", "start": [240, 1], "end": [242, 65], "kind": "commanddeclaration"}, {"full_name": "List.map_permutations'", "code": "theorem map_permutations' (f : \u03b1 \u2192 \u03b2) (ts : List \u03b1) :\n    map (map f) (permutations' ts) = permutations' (map f ts)", "start": [245, 1], "end": [247, 100], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux_append", "code": "theorem permutationsAux_append (is is' ts : List \u03b1) :\n    permutationsAux (is ++ ts) is' =\n      (permutationsAux is is').map (\u00b7 ++ ts) ++ permutationsAux ts (is.reverse ++ is')", "start": [250, 1], "end": [260, 31], "kind": "commanddeclaration"}, {"full_name": "List.permutations_append", "code": "theorem permutations_append (is ts : List \u03b1) :\n    permutations (is ++ ts) = (permutations is).map (\u00b7 ++ ts) ++ permutationsAux ts is.reverse", "start": [263, 1], "end": [265, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/List.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Data/Set/Image.lean", "Mathlib/Data/Fin/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.range_list_map", "code": "theorem range_list_map (f : \u03b1 \u2192 \u03b2) : range (map f) = { l | \u2200 x \u2208 l, x \u2208 range f }", "start": [25, 1], "end": [32, 33], "kind": "commanddeclaration"}, {"full_name": "Set.range_list_map_coe", "code": "theorem range_list_map_coe (s : Set \u03b1) : range (map ((\u2191) : s \u2192 \u03b1)) = { l | \u2200 x \u2208 l, x \u2208 s }", "start": [35, 1], "end": [36, 41], "kind": "commanddeclaration"}, {"full_name": "Set.range_list_nthLe", "code": "@[simp]\ntheorem range_list_nthLe : (range fun k : Fin l.length => l.nthLe k k.2) = { x | x \u2208 l }", "start": [39, 1], "end": [43, 81], "kind": "commanddeclaration"}, {"full_name": "Set.range_list_get?", "code": "theorem range_list_get? : range l.get? = insert none (some '' { x | x \u2208 l })", "start": [46, 1], "end": [50, 83], "kind": "commanddeclaration"}, {"full_name": "Set.range_list_getD", "code": "@[simp]\ntheorem range_list_getD (d : \u03b1) : (range fun n => l.getD n d) = insert d { x | x \u2208 l }", "start": [53, 1], "end": [59, 88], "kind": "commanddeclaration"}, {"full_name": "Set.range_list_getI", "code": "@[simp]\ntheorem range_list_getI [Inhabited \u03b1] (l : List \u03b1) : range l.getI = insert default { x | x \u2208 l }", "start": [62, 1], "end": [64, 28], "kind": "commanddeclaration"}, {"full_name": "List.canLift", "code": "instance List.canLift (c) (p) [CanLift \u03b1 \u03b2 c p] :\n    CanLift (List \u03b1) (List \u03b2) (List.map c) fun l => \u2200 x \u2208 l, p x where\n  prf l H := by\n    rw [\u2190 Set.mem_range, Set.range_list_map]\n    exact fun a ha => CanLift.prf a (H a ha)", "start": [69, 1], "end": [75, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Perm.lean", "imports": ["Mathlib/Data/List/Permutation.lean", "Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Data/List/Dedup.lean", "Mathlib/Data/List/Range.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Perm", "code": "inductive Perm : List \u03b1 \u2192 List \u03b1 \u2192 Prop\n  | nil : Perm [] []\n  | cons (x : \u03b1) {l\u2081 l\u2082 : List \u03b1} : Perm l\u2081 l\u2082 \u2192 Perm (x :: l\u2081) (x :: l\u2082)\n  | swap (x y : \u03b1) (l : List \u03b1) : Perm (y :: x :: l) (x :: y :: l)\n  | trans {l\u2081 l\u2082 l\u2083 : List \u03b1} : Perm l\u2081 l\u2082 \u2192 Perm l\u2082 l\u2083 \u2192 Perm l\u2081 l\u2083", "start": [33, 1], "end": [39, 69], "kind": "commanddeclaration"}, {"full_name": "List.Perm.refl", "code": "@[simp, refl]\nprotected theorem Perm.refl : \u2200 l : List \u03b1, l ~ l", "start": [48, 1], "end": [51, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.symm", "code": "@[symm]\nprotected theorem Perm.symm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2082 ~ l\u2081", "start": [55, 1], "end": [61, 36], "kind": "commanddeclaration"}, {"full_name": "List.perm_comm", "code": "theorem perm_comm {l\u2081 l\u2082 : List \u03b1} : l\u2081 ~ l\u2082 \u2194 l\u2082 ~ l\u2081", "start": [64, 1], "end": [65, 25], "kind": "commanddeclaration"}, {"full_name": "List.Perm.swap'", "code": "theorem Perm.swap' (x y : \u03b1) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : y :: x :: l\u2081 ~ x :: y :: l\u2082", "start": [68, 1], "end": [69, 41], "kind": "commanddeclaration"}, {"full_name": "List.Perm.eqv", "code": "theorem Perm.eqv (\u03b1) : Equivalence (@Perm \u03b1)", "start": [74, 1], "end": [75, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.of_eq", "code": "theorem Perm.of_eq (h : l\u2081 = l\u2082) : l\u2081 ~ l\u2082", "start": [79, 1], "end": [80, 19], "kind": "commanddeclaration"}, {"full_name": "List.isSetoid", "code": "instance isSetoid (\u03b1) : Setoid (List \u03b1) :=\n  Setoid.mk (@Perm \u03b1) (Perm.eqv \u03b1)", "start": [82, 1], "end": [83, 35], "kind": "commanddeclaration"}, {"full_name": "List.Perm.mem_iff", "code": "theorem Perm.mem_iff {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : a \u2208 l\u2081 \u2194 a \u2208 l\u2082", "start": [87, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subset", "code": "theorem Perm.subset {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2081 \u2286 l\u2082", "start": [95, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subset_congr_left", "code": "theorem Perm.subset_congr_left {l\u2081 l\u2082 l\u2083 : List \u03b1} (h : l\u2081 ~ l\u2082) : l\u2081 \u2286 l\u2083 \u2194 l\u2082 \u2286 l\u2083", "start": [99, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subset_congr_right", "code": "theorem Perm.subset_congr_right {l\u2081 l\u2082 l\u2083 : List \u03b1} (h : l\u2081 ~ l\u2082) : l\u2083 \u2286 l\u2081 \u2194 l\u2083 \u2286 l\u2082", "start": [103, 1], "end": [104, 66], "kind": "commanddeclaration"}, {"full_name": "List.Perm.append_right", "code": "theorem Perm.append_right {l\u2081 l\u2082 : List \u03b1} (t\u2081 : List \u03b1) (p : l\u2081 ~ l\u2082) : l\u2081 ++ t\u2081 ~ l\u2082 ++ t\u2081", "start": [107, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "List.Perm.append_left", "code": "theorem Perm.append_left {t\u2081 t\u2082 : List \u03b1} : \u2200 l : List \u03b1, t\u2081 ~ t\u2082 \u2192 l ++ t\u2081 ~ l ++ t\u2082", "start": [115, 1], "end": [117, 44], "kind": "commanddeclaration"}, {"full_name": "List.Perm.append", "code": "theorem Perm.append {l\u2081 l\u2082 t\u2081 t\u2082 : List \u03b1} (p\u2081 : l\u2081 ~ l\u2082) (p\u2082 : t\u2081 ~ t\u2082) : l\u2081 ++ t\u2081 ~ l\u2082 ++ t\u2082", "start": [120, 1], "end": [121, 49], "kind": "commanddeclaration"}, {"full_name": "List.Perm.append_cons", "code": "theorem Perm.append_cons (a : \u03b1) {h\u2081 h\u2082 t\u2081 t\u2082 : List \u03b1} (p\u2081 : h\u2081 ~ h\u2082) (p\u2082 : t\u2081 ~ t\u2082) :\n    h\u2081 ++ a :: t\u2081 ~ h\u2082 ++ a :: t\u2082", "start": [124, 1], "end": [126, 24], "kind": "commanddeclaration"}, {"full_name": "List.perm_middle", "code": "@[simp]\ntheorem perm_middle {a : \u03b1} : \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 ++ a :: l\u2082 ~ a :: (l\u2081 ++ l\u2082)", "start": [129, 1], "end": [132, 70], "kind": "commanddeclaration"}, {"full_name": "List.perm_append_singleton", "code": "@[simp]\ntheorem perm_append_singleton (a : \u03b1) (l : List \u03b1) : l ++ [a] ~ a :: l", "start": [135, 1], "end": [137, 42], "kind": "commanddeclaration"}, {"full_name": "List.perm_append_comm", "code": "theorem perm_append_comm : \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 ++ l\u2082 ~ l\u2082 ++ l\u2081", "start": [140, 1], "end": [142, 67], "kind": "commanddeclaration"}, {"full_name": "List.concat_perm", "code": "theorem concat_perm (l : List \u03b1) (a : \u03b1) : concat l a ~ a :: l", "start": [145, 1], "end": [145, 74], "kind": "commanddeclaration"}, {"full_name": "List.Perm.length_eq", "code": "theorem Perm.length_eq {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : length l\u2081 = length l\u2082", "start": [148, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "List.Perm.eq_nil", "code": "theorem Perm.eq_nil {l : List \u03b1} (p : l ~ []) : l = []", "start": [156, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "List.Perm.nil_eq", "code": "theorem Perm.nil_eq {l : List \u03b1} (p : [] ~ l) : [] = l", "start": [160, 1], "end": [161, 21], "kind": "commanddeclaration"}, {"full_name": "List.perm_nil", "code": "@[simp]\ntheorem perm_nil {l\u2081 : List \u03b1} : l\u2081 ~ [] \u2194 l\u2081 = []", "start": [164, 1], "end": [166, 48], "kind": "commanddeclaration"}, {"full_name": "List.nil_perm", "code": "@[simp]\ntheorem nil_perm {l\u2081 : List \u03b1} : [] ~ l\u2081 \u2194 l\u2081 = []", "start": [169, 1], "end": [171, 27], "kind": "commanddeclaration"}, {"full_name": "List.not_perm_nil_cons", "code": "theorem not_perm_nil_cons (x : \u03b1) (l : List \u03b1) : \u00ac[] ~ x :: l", "start": [174, 1], "end": [175, 36], "kind": "commanddeclaration"}, {"full_name": "List.reverse_perm", "code": "@[simp]\ntheorem reverse_perm : \u2200 l : List \u03b1, reverse l ~ l", "start": [178, 1], "end": [183, 70], "kind": "commanddeclaration"}, {"full_name": "List.perm_cons_append_cons", "code": "theorem perm_cons_append_cons {l l\u2081 l\u2082 : List \u03b1} (a : \u03b1) (p : l ~ l\u2081 ++ l\u2082) :\n    a :: l ~ l\u2081 ++ a :: l\u2082", "start": [186, 1], "end": [188, 36], "kind": "commanddeclaration"}, {"full_name": "List.perm_replicate", "code": "@[simp]\ntheorem perm_replicate {n : \u2115} {a : \u03b1} {l : List \u03b1} :\n    l ~ replicate n a \u2194 l = replicate n a", "start": [191, 1], "end": [196, 30], "kind": "commanddeclaration"}, {"full_name": "List.replicate_perm", "code": "@[simp]\ntheorem replicate_perm {n : \u2115} {a : \u03b1} {l : List \u03b1} :\n    replicate n a ~ l \u2194 replicate n a = l", "start": [199, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "List.perm_singleton", "code": "@[simp]\ntheorem perm_singleton {a : \u03b1} {l : List \u03b1} : l ~ [a] \u2194 l = [a]", "start": [205, 1], "end": [207, 26], "kind": "commanddeclaration"}, {"full_name": "List.singleton_perm", "code": "@[simp]\ntheorem singleton_perm {a : \u03b1} {l : List \u03b1} : [a] ~ l \u2194 [a] = l", "start": [210, 1], "end": [212, 26], "kind": "commanddeclaration"}, {"full_name": "List.Perm.eq_singleton", "code": "alias \u27e8Perm.eq_singleton, _\u27e9 := perm_singleton", "start": [215, 1], "end": [215, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.Perm.singleton_eq", "code": "alias \u27e8Perm.singleton_eq, _\u27e9 := singleton_perm", "start": [216, 1], "end": [216, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.singleton_perm_singleton", "code": "theorem singleton_perm_singleton {a b : \u03b1} : [a] ~ [b] \u2194 a = b", "start": [218, 1], "end": [218, 74], "kind": "commanddeclaration"}, {"full_name": "List.perm_cons_erase", "code": "theorem perm_cons_erase [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : l ~ a :: l.erase a", "start": [221, 1], "end": [223, 34], "kind": "commanddeclaration"}, {"full_name": "List.perm_induction_on", "code": "@[elab_as_elim]\ntheorem perm_induction_on {P : List \u03b1 \u2192 List \u03b1 \u2192 Prop} {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) (h\u2081 : P [] [])\n    (h\u2082 : \u2200 x l\u2081 l\u2082, l\u2081 ~ l\u2082 \u2192 P l\u2081 l\u2082 \u2192 P (x :: l\u2081) (x :: l\u2082))\n    (h\u2083 : \u2200 x y l\u2081 l\u2082, l\u2081 ~ l\u2082 \u2192 P l\u2081 l\u2082 \u2192 P (y :: x :: l\u2081) (x :: y :: l\u2082))\n    (h\u2084 : \u2200 l\u2081 l\u2082 l\u2083, l\u2081 ~ l\u2082 \u2192 l\u2082 ~ l\u2083 \u2192 P l\u2081 l\u2082 \u2192 P l\u2082 l\u2083 \u2192 P l\u2081 l\u2083) : P l\u2081 l\u2082", "start": [226, 1], "end": [232, 69], "kind": "commanddeclaration"}, {"full_name": "List.Perm.filterMap", "code": "theorem Perm.filterMap (f : \u03b1 \u2192 Option \u03b2) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) :\n    filterMap f l\u2081 ~ filterMap f l\u2082", "start": [237, 1], "end": [249, 24], "kind": "commanddeclaration"}, {"full_name": "List.Perm.map", "code": "theorem Perm.map (f : \u03b1 \u2192 \u03b2) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : map f l\u2081 ~ map f l\u2082", "start": [254, 1], "end": [255, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.pmap", "code": "theorem Perm.pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) {H\u2081 H\u2082} :\n    pmap f l\u2081 H\u2081 ~ pmap f l\u2082 H\u2082", "start": [258, 1], "end": [266, 40], "kind": "commanddeclaration"}, {"full_name": "List.Perm.filter", "code": "theorem Perm.filter (p : \u03b1 \u2192 Bool) {l\u2081 l\u2082 : List \u03b1} (s : l\u2081 ~ l\u2082) :\n    filter p l\u2081 ~ filter p l\u2082", "start": [269, 1], "end": [270, 84], "kind": "commanddeclaration"}, {"full_name": "List.filter_append_perm", "code": "theorem filter_append_perm (p : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    filter p l ++ filter (fun x => \u00acp x) l ~ l", "start": [273, 1], "end": [282, 61], "kind": "commanddeclaration"}, {"full_name": "List.exists_perm_sublist", "code": "theorem exists_perm_sublist {l\u2081 l\u2082 l\u2082' : List \u03b1} (s : l\u2081 <+ l\u2082) (p : l\u2082 ~ l\u2082') :\n    \u2203 (l\u2081' : _) (_ : l\u2081' ~ l\u2081), l\u2081' <+ l\u2082'", "start": [285, 1], "end": [308, 28], "kind": "commanddeclaration"}, {"full_name": "List.Perm.sizeOf_eq_sizeOf", "code": "theorem Perm.sizeOf_eq_sizeOf [SizeOf \u03b1] {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 ~ l\u2082) :\n    sizeOf l\u2081 = sizeOf l\u2082", "start": [311, 1], "end": [317, 53], "kind": "commanddeclaration"}, {"full_name": "List.perm_comp_perm", "code": "theorem perm_comp_perm : (Perm \u2218r Perm : List \u03b1 \u2192 List \u03b1 \u2192 Prop) = Perm", "start": [329, 1], "end": [333, 39], "kind": "commanddeclaration"}, {"full_name": "List.perm_comp_forall\u2082", "code": "theorem perm_comp_forall\u2082 {l u v} (hlu : Perm l u) (huv : Forall\u2082 r u v) :\n    (Forall\u2082 r \u2218r Perm) l v", "start": [336, 1], "end": [352, 42], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_comp_perm_eq_perm_comp_forall\u2082", "code": "theorem forall\u2082_comp_perm_eq_perm_comp_forall\u2082 : Forall\u2082 r \u2218r Perm = Perm \u2218r Forall\u2082 r", "start": [355, 1], "end": [363, 58], "kind": "commanddeclaration"}, {"full_name": "List.rel_perm_imp", "code": "theorem rel_perm_imp (hr : RightUnique r) : (Forall\u2082 r \u21d2 Forall\u2082 r \u21d2 (\u00b7 \u2192 \u00b7)) Perm Perm", "start": [366, 1], "end": [373, 13], "kind": "commanddeclaration"}, {"full_name": "List.rel_perm", "code": "theorem rel_perm (hr : BiUnique r) : (Forall\u2082 r \u21d2 Forall\u2082 r \u21d2 (\u00b7 \u2194 \u00b7)) Perm Perm", "start": [376, 1], "end": [378, 86], "kind": "commanddeclaration"}, {"full_name": "List.Subperm", "code": "def Subperm (l\u2081 l\u2082 : List \u03b1) : Prop :=\n  \u2203 (l : _) (_ : l ~ l\u2081), l <+ l\u2082", "start": [386, 1], "end": [390, 34], "kind": "commanddeclaration"}, {"full_name": "List.nil_subperm", "code": "theorem nil_subperm {l : List \u03b1} : [] <+~ l", "start": [398, 1], "end": [399, 26], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subperm_left", "code": "theorem Perm.subperm_left {l l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l <+~ l\u2081 \u2194 l <+~ l\u2082", "start": [402, 1], "end": [406, 23], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subperm_right", "code": "theorem Perm.subperm_right {l\u2081 l\u2082 l : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2081 <+~ l \u2194 l\u2082 <+~ l", "start": [409, 1], "end": [410, 88], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.subperm", "code": "theorem Sublist.subperm {l\u2081 l\u2082 : List \u03b1} (s : l\u2081 <+ l\u2082) : l\u2081 <+~ l\u2082", "start": [413, 1], "end": [414, 23], "kind": "commanddeclaration"}, {"full_name": "List.Perm.subperm", "code": "theorem Perm.subperm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2081 <+~ l\u2082", "start": [417, 1], "end": [418, 31], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.refl", "code": "@[refl]\ntheorem Subperm.refl (l : List \u03b1) : l <+~ l", "start": [421, 1], "end": [423, 24], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.trans", "code": "@[trans]\ntheorem Subperm.trans {l\u2081 l\u2082 l\u2083 : List \u03b1} : l\u2081 <+~ l\u2082 \u2192 l\u2082 <+~ l\u2083 \u2192 l\u2081 <+~ l\u2083", "start": [426, 1], "end": [430, 27], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.length_le", "code": "theorem Subperm.length_le {l\u2081 l\u2082 : List \u03b1} : l\u2081 <+~ l\u2082 \u2192 length l\u2081 \u2264 length l\u2082", "start": [433, 1], "end": [434, 44], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.perm_of_length_le", "code": "theorem Subperm.perm_of_length_le {l\u2081 l\u2082 : List \u03b1} : l\u2081 <+~ l\u2082 \u2192 length l\u2082 \u2264 length l\u2081 \u2192 l\u2081 ~ l\u2082", "start": [437, 1], "end": [438, 74], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.antisymm", "code": "theorem Subperm.antisymm {l\u2081 l\u2082 : List \u03b1} (h\u2081 : l\u2081 <+~ l\u2082) (h\u2082 : l\u2082 <+~ l\u2081) : l\u2081 ~ l\u2082", "start": [441, 1], "end": [442, 36], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.subset", "code": "theorem Subperm.subset {l\u2081 l\u2082 : List \u03b1} : l\u2081 <+~ l\u2082 \u2192 l\u2081 \u2286 l\u2082", "start": [445, 1], "end": [446, 54], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.filter", "code": "theorem Subperm.filter (p : \u03b1 \u2192 Bool) \u2983l l' : List \u03b1\u2984 (h : l <+~ l') :\n    filter p l <+~ filter p l'", "start": [449, 1], "end": [452, 37], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.exists_perm_append", "code": "theorem Sublist.exists_perm_append : \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 \u2203 l, l\u2082 ~ l\u2081 ++ l", "start": [457, 1], "end": [464, 18], "kind": "commanddeclaration"}, {"full_name": "List.Perm.countP_eq", "code": "theorem Perm.countP_eq (p : \u03b1 \u2192 Bool) {l\u2081 l\u2082 : List \u03b1} (s : l\u2081 ~ l\u2082) :\n    countP p l\u2081 = countP p l\u2082", "start": [467, 1], "end": [469, 86], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.countP_le", "code": "theorem Subperm.countP_le (p : \u03b1 \u2192 Bool) {l\u2081 l\u2082 : List \u03b1} :\n    l\u2081 <+~ l\u2082 \u2192 countP p l\u2081 \u2264 countP p l\u2082", "start": [472, 1], "end": [474, 50], "kind": "commanddeclaration"}, {"full_name": "List.Perm.countP_congr", "code": "theorem Perm.countP_congr (s : l\u2081 ~ l\u2082) {p p' : \u03b1 \u2192 Bool}\n    (hp : \u2200 x \u2208 l\u2081, p x = p' x) : l\u2081.countP p = l\u2082.countP p'", "start": [477, 1], "end": [484, 43], "kind": "commanddeclaration"}, {"full_name": "List.countP_eq_countP_filter_add", "code": "theorem countP_eq_countP_filter_add (l : List \u03b1) (p q : \u03b1 \u2192 Bool) :\n    l.countP p = (l.filter q).countP p + (l.filter fun a => \u00acq a).countP p", "start": [487, 1], "end": [490, 55], "kind": "commanddeclaration"}, {"full_name": "List.Perm.count_eq", "code": "theorem Perm.count_eq [DecidableEq \u03b1] {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) (a) :\n    count a l\u2081 = count a l\u2082", "start": [493, 1], "end": [495, 16], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.count_le", "code": "theorem Subperm.count_le [DecidableEq \u03b1] {l\u2081 l\u2082 : List \u03b1} (s : l\u2081 <+~ l\u2082) (a) :\n    count a l\u2081 \u2264 count a l\u2082", "start": [498, 1], "end": [500, 16], "kind": "commanddeclaration"}, {"full_name": "List.Perm.foldl_eq'", "code": "theorem Perm.foldl_eq' {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) :\n    (\u2200 x \u2208 l\u2081, \u2200 y \u2208 l\u2081, \u2200 (z), f (f z x) y = f (f z y) x) \u2192 \u2200 b, foldl f b l\u2081 = foldl f b l\u2082", "start": [503, 1], "end": [512, 94], "kind": "commanddeclaration"}, {"full_name": "List.Perm.foldl_eq", "code": "theorem Perm.foldl_eq {f : \u03b2 \u2192 \u03b1 \u2192 \u03b2} {l\u2081 l\u2082 : List \u03b1} (rcomm : RightCommutative f) (p : l\u2081 ~ l\u2082) :\n    \u2200 b, foldl f b l\u2081 = foldl f b l\u2082", "start": [515, 1], "end": [517, 47], "kind": "commanddeclaration"}, {"full_name": "List.Perm.foldr_eq", "code": "theorem Perm.foldr_eq {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {l\u2081 l\u2082 : List \u03b1} (lcomm : LeftCommutative f) (p : l\u2081 ~ l\u2082) :\n    \u2200 b, foldr f b l\u2081 = foldr f b l\u2082", "start": [520, 1], "end": [524, 27], "kind": "commanddeclaration"}, {"full_name": "List.Perm.rec_heq", "code": "theorem Perm.rec_heq {\u03b2 : List \u03b1 \u2192 Sort*} {f : \u2200 a l, \u03b2 l \u2192 \u03b2 (a :: l)} {b : \u03b2 []} {l l' : List \u03b1}\n    (hl : Perm l l') (f_congr : \u2200 {a l l' b b'}, Perm l l' \u2192 HEq b b' \u2192 HEq (f a l b) (f a l' b'))\n    (f_swap : \u2200 {a a' l b}, HEq (f a (a' :: l) (f a' l b)) (f a' (a :: l) (f a l b))) :\n    HEq (@List.rec \u03b1 \u03b2 b f l) (@List.rec \u03b1 \u03b2 b f l')", "start": [527, 1], "end": [535, 65], "kind": "commanddeclaration"}, {"full_name": "List.Perm.fold_op_eq", "code": "theorem Perm.fold_op_eq {l\u2081 l\u2082 : List \u03b1} {a : \u03b1} (h : l\u2081 ~ l\u2082) : (l\u2081 <*> a) = l\u2082 <*> a", "start": [548, 1], "end": [549, 47], "kind": "commanddeclaration"}, {"full_name": "List.Perm.prod_eq'", "code": "@[to_additive\n      \"If elements of a list additively commute with each other, then their sum does not\n      depend on the order of elements.\"]\ntheorem Perm.prod_eq' [M : Monoid \u03b1] {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 ~ l\u2082) (hc : l\u2081.Pairwise Commute) :\n    l\u2081.prod = l\u2082.prod", "start": [556, 1], "end": [570, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.prod_eq", "code": "@[to_additive]\ntheorem Perm.prod_eq {l\u2081 l\u2082 : List \u03b1} (h : Perm l\u2081 l\u2082) : prod l\u2081 = prod l\u2082", "start": [576, 1], "end": [578, 15], "kind": "commanddeclaration"}, {"full_name": "List.prod_reverse", "code": "@[to_additive]\ntheorem prod_reverse (l : List \u03b1) : prod l.reverse = prod l", "start": [582, 1], "end": [584, 27], "kind": "commanddeclaration"}, {"full_name": "List.perm_inv_core", "code": "theorem perm_inv_core {a : \u03b1} {l\u2081 l\u2082 r\u2081 r\u2082 : List \u03b1} :\n    l\u2081 ++ a :: r\u2081 ~ l\u2082 ++ a :: r\u2082 \u2192 l\u2081 ++ r\u2081 ~ l\u2082 ++ r\u2082", "start": [590, 1], "end": [635, 60], "kind": "commanddeclaration"}, {"full_name": "List.Perm.cons_inv", "code": "theorem Perm.cons_inv {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} : a :: l\u2081 ~ a :: l\u2082 \u2192 l\u2081 ~ l\u2082", "start": [638, 1], "end": [639, 31], "kind": "commanddeclaration"}, {"full_name": "List.perm_cons", "code": "@[simp]\ntheorem perm_cons (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} : a :: l\u2081 ~ a :: l\u2082 \u2194 l\u2081 ~ l\u2082", "start": [642, 1], "end": [644, 31], "kind": "commanddeclaration"}, {"full_name": "List.perm_append_left_iff", "code": "theorem perm_append_left_iff {l\u2081 l\u2082 : List \u03b1} : \u2200 l, l ++ l\u2081 ~ l ++ l\u2082 \u2194 l\u2081 ~ l\u2082", "start": [647, 1], "end": [649, 59], "kind": "commanddeclaration"}, {"full_name": "List.perm_append_right_iff", "code": "theorem perm_append_right_iff {l\u2081 l\u2082 : List \u03b1} (l) : l\u2081 ++ l ~ l\u2082 ++ l \u2194 l\u2081 ~ l\u2082", "start": [652, 1], "end": [654, 25], "kind": "commanddeclaration"}, {"full_name": "List.perm_option_to_list", "code": "theorem perm_option_to_list {o\u2081 o\u2082 : Option \u03b1} : o\u2081.toList ~ o\u2082.toList \u2194 o\u2081 = o\u2082", "start": [657, 1], "end": [662, 57], "kind": "commanddeclaration"}, {"full_name": "List.subperm_cons", "code": "theorem subperm_cons (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} : a :: l\u2081 <+~ a :: l\u2082 \u2194 l\u2081 <+~ l\u2082", "start": [665, 1], "end": [669, 81], "kind": "commanddeclaration"}, {"full_name": "List.subperm.of_cons", "code": "alias \u27e8subperm.of_cons, subperm.cons\u27e9 := subperm_cons", "start": [672, 1], "end": [672, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.subperm.cons", "code": "alias \u27e8subperm.of_cons, subperm.cons\u27e9 := subperm_cons", "start": [672, 1], "end": [672, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.cons_subperm_of_mem", "code": "theorem cons_subperm_of_mem {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} (d\u2081 : Nodup l\u2081) (h\u2081 : a \u2209 l\u2081) (h\u2082 : a \u2208 l\u2082)\n    (s : l\u2081 <+~ l\u2082) : a :: l\u2081 <+~ l\u2082", "start": [679, 1], "end": [702, 94], "kind": "commanddeclaration"}, {"full_name": "List.subperm_append_left", "code": "theorem subperm_append_left {l\u2081 l\u2082 : List \u03b1} : \u2200 l, l ++ l\u2081 <+~ l ++ l\u2082 \u2194 l\u2081 <+~ l\u2082", "start": [705, 1], "end": [707, 61], "kind": "commanddeclaration"}, {"full_name": "List.subperm_append_right", "code": "theorem subperm_append_right {l\u2081 l\u2082 : List \u03b1} (l) : l\u2081 ++ l <+~ l\u2082 ++ l \u2194 l\u2081 <+~ l\u2082", "start": [710, 1], "end": [711, 101], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.exists_of_length_lt", "code": "theorem Subperm.exists_of_length_lt {l\u2081 l\u2082 : List \u03b1} :\n    l\u2081 <+~ l\u2082 \u2192 length l\u2081 < length l\u2082 \u2192 \u2203 a, a :: l\u2081 <+~ l\u2082", "start": [714, 1], "end": [726, 63], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.subperm", "code": "protected theorem Nodup.subperm (d : Nodup l\u2081) (H : l\u2081 \u2286 l\u2082) : l\u2081 <+~ l\u2082", "start": [729, 1], "end": [734, 45], "kind": "commanddeclaration"}, {"full_name": "List.perm_ext", "code": "theorem perm_ext {l\u2081 l\u2082 : List \u03b1} (d\u2081 : Nodup l\u2081) (d\u2082 : Nodup l\u2082) :\n    l\u2081 ~ l\u2082 \u2194 \u2200 a, a \u2208 l\u2081 \u2194 a \u2208 l\u2082", "start": [737, 1], "end": [740, 75], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.sublist_ext", "code": "theorem Nodup.sublist_ext {l\u2081 l\u2082 l : List \u03b1} (d : Nodup l) (s\u2081 : l\u2081 <+ l) (s\u2082 : l\u2082 <+ l) :\n    l\u2081 ~ l\u2082 \u2194 l\u2081 = l\u2082", "start": [743, 1], "end": [757, 55], "kind": "commanddeclaration"}, {"full_name": "List.Perm.erase", "code": "theorem Perm.erase (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2081.erase a ~ l\u2082.erase a", "start": [765, 1], "end": [771, 59], "kind": "commanddeclaration"}, {"full_name": "List.subperm_cons_erase", "code": "theorem subperm_cons_erase (a : \u03b1) (l : List \u03b1) : l <+~ a :: l.erase a", "start": [774, 1], "end": [778, 37], "kind": "commanddeclaration"}, {"full_name": "List.erase_subperm", "code": "theorem erase_subperm (a : \u03b1) (l : List \u03b1) : l.erase a <+~ l", "start": [781, 1], "end": [782, 30], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.erase", "code": "theorem Subperm.erase {l\u2081 l\u2082 : List \u03b1} (a : \u03b1) (h : l\u2081 <+~ l\u2082) : l\u2081.erase a <+~ l\u2082.erase a", "start": [785, 1], "end": [787, 38], "kind": "commanddeclaration"}, {"full_name": "List.Perm.diff_right", "code": "theorem Perm.diff_right {l\u2081 l\u2082 : List \u03b1} (t : List \u03b1) (h : l\u2081 ~ l\u2082) : l\u2081.diff t ~ l\u2082.diff t", "start": [790, 1], "end": [791, 60], "kind": "commanddeclaration"}, {"full_name": "List.Perm.diff_left", "code": "theorem Perm.diff_left (l : List \u03b1) {t\u2081 t\u2082 : List \u03b1} (h : t\u2081 ~ t\u2082) : l.diff t\u2081 = l.diff t\u2082", "start": [794, 1], "end": [796, 44], "kind": "commanddeclaration"}, {"full_name": "List.Perm.diff", "code": "theorem Perm.diff {l\u2081 l\u2082 t\u2081 t\u2082 : List \u03b1} (hl : l\u2081 ~ l\u2082) (ht : t\u2081 ~ t\u2082) : l\u2081.diff t\u2081 ~ l\u2082.diff t\u2082", "start": [799, 1], "end": [800, 36], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.diff_right", "code": "theorem Subperm.diff_right {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+~ l\u2082) (t : List \u03b1) :\n    l\u2081.diff t <+~ l\u2082.diff t", "start": [803, 1], "end": [804, 95], "kind": "commanddeclaration"}, {"full_name": "List.erase_cons_subperm_cons_erase", "code": "theorem erase_cons_subperm_cons_erase (a b : \u03b1) (l : List \u03b1) :\n    (a :: l).erase b <+~ a :: l.erase b", "start": [807, 1], "end": [813, 29], "kind": "commanddeclaration"}, {"full_name": "List.subperm_cons_diff", "code": "theorem subperm_cons_diff {a : \u03b1} : \u2200 {l\u2081 l\u2082 : List \u03b1}, (a :: l\u2081).diff l\u2082 <+~ a :: l\u2081.diff l\u2082", "start": [816, 1], "end": [821, 28], "kind": "commanddeclaration"}, {"full_name": "List.subset_cons_diff", "code": "theorem subset_cons_diff {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} : (a :: l\u2081).diff l\u2082 \u2286 a :: l\u2081.diff l\u2082", "start": [824, 1], "end": [825, 27], "kind": "commanddeclaration"}, {"full_name": "List.Perm.bagInter_right", "code": "theorem Perm.bagInter_right {l\u2081 l\u2082 : List \u03b1} (t : List \u03b1) (h : l\u2081 ~ l\u2082) :\n    l\u2081.bagInter t ~ l\u2082.bagInter t", "start": [828, 1], "end": [839, 34], "kind": "commanddeclaration"}, {"full_name": "List.Perm.bagInter_left", "code": "theorem Perm.bagInter_left (l : List \u03b1) {t\u2081 t\u2082 : List \u03b1} (p : t\u2081 ~ t\u2082) :\n    l.bagInter t\u2081 = l.bagInter t\u2082", "start": [842, 1], "end": [847, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.bagInter", "code": "theorem Perm.bagInter {l\u2081 l\u2082 t\u2081 t\u2082 : List \u03b1} (hl : l\u2081 ~ l\u2082) (ht : t\u2081 ~ t\u2082) :\n    l\u2081.bagInter t\u2081 ~ l\u2082.bagInter t\u2082", "start": [850, 1], "end": [852, 44], "kind": "commanddeclaration"}, {"full_name": "List.cons_perm_iff_perm_erase", "code": "theorem cons_perm_iff_perm_erase {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} :\n    a :: l\u2081 ~ l\u2082 \u2194 a \u2208 l\u2082 \u2227 l\u2081 ~ l\u2082.erase a", "start": [855, 1], "end": [860, 61], "kind": "commanddeclaration"}, {"full_name": "List.perm_iff_count", "code": "theorem perm_iff_count {l\u2081 l\u2082 : List \u03b1} : l\u2081 ~ l\u2082 \u2194 \u2200 a, count a l\u2081 = count a l\u2082", "start": [863, 1], "end": [875, 48], "kind": "commanddeclaration"}, {"full_name": "List.perm_replicate_append_replicate", "code": "theorem perm_replicate_append_replicate {l : List \u03b1} {a b : \u03b1} {m n : \u2115} (h : a \u2260 b) :\n    l ~ replicate m a ++ replicate n b \u2194 count a l = m \u2227 count b l = n \u2227 l \u2286 [a, b]", "start": [878, 1], "end": [884, 36], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.cons_right", "code": "theorem Subperm.cons_right {\u03b1 : Type*} {l l' : List \u03b1} (x : \u03b1) (h : l <+~ l') : l <+~ x :: l'", "start": [887, 1], "end": [888, 38], "kind": "commanddeclaration"}, {"full_name": "List.subperm_append_diff_self_of_count_le", "code": "theorem subperm_append_diff_self_of_count_le {l\u2081 l\u2082 : List \u03b1}\n    (h : \u2200 x \u2208 l\u2081, count x l\u2081 \u2264 count x l\u2082) : l\u2081 ++ l\u2082.diff l\u2081 ~ l\u2082", "start": [891, 1], "end": [908, 25], "kind": "commanddeclaration"}, {"full_name": "List.subperm_ext_iff", "code": "theorem subperm_ext_iff {l\u2081 l\u2082 : List \u03b1} : l\u2081 <+~ l\u2082 \u2194 \u2200 x \u2208 l\u2081, count x l\u2081 \u2264 count x l\u2082", "start": [911, 1], "end": [917, 50], "kind": "commanddeclaration"}, {"full_name": "List.decidableSubperm", "code": "instance decidableSubperm : DecidableRel ((\u00b7 <+~ \u00b7) : List \u03b1 \u2192 List \u03b1 \u2192 Prop) := fun _ _ =>\n  decidable_of_iff _ List.subperm_ext_iff.symm", "start": [920, 1], "end": [921, 47], "kind": "commanddeclaration"}, {"full_name": "List.subperm_singleton_iff", "code": "@[simp]\ntheorem subperm_singleton_iff {\u03b1} {l : List \u03b1} {a : \u03b1} : [a] <+~ l \u2194 a \u2208 l", "start": [924, 1], "end": [927, 49], "kind": "commanddeclaration"}, {"full_name": "List.Subperm.cons_left", "code": "theorem Subperm.cons_left {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+~ l\u2082) (x : \u03b1) (hx : count x l\u2081 < count x l\u2082) :\n    x :: l\u2081 <+~ l\u2082", "start": [930, 1], "end": [939, 25], "kind": "commanddeclaration"}, {"full_name": "List.decidablePerm", "code": "instance decidablePerm : \u2200 l\u2081 l\u2082 : List \u03b1, Decidable (l\u2081 ~ l\u2082)\n  | [], [] => isTrue <| Perm.refl _\n  | [], b :: l\u2082 => isFalse fun h => by have := h.nil_eq; contradiction\n  | a :: l\u2081, l\u2082 =>\n    haveI := decidablePerm l\u2081 (l\u2082.erase a)\n    decidable_of_iff' _ cons_perm_iff_perm_erase", "start": [942, 1], "end": [947, 49], "kind": "commanddeclaration"}, {"full_name": "List.Perm.dedup", "code": "theorem Perm.dedup {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : dedup l\u2081 ~ dedup l\u2082", "start": [951, 1], "end": [953, 95], "kind": "commanddeclaration"}, {"full_name": "List.Perm.insert", "code": "protected theorem Perm.insert (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : l\u2081.insert a ~ l\u2082.insert a", "start": [957, 1], "end": [959, 53], "kind": "commanddeclaration"}, {"full_name": "List.perm_insert_swap", "code": "theorem perm_insert_swap (x y : \u03b1) (l : List \u03b1) :\n    List.insert x (List.insert y l) ~ List.insert y (List.insert x l)", "start": [962, 1], "end": [967, 14], "kind": "commanddeclaration"}, {"full_name": "List.perm_insertNth", "code": "theorem perm_insertNth {\u03b1} (x : \u03b1) (l : List \u03b1) {n} (h : n \u2264 l.length) :\n    insertNth n x l ~ x :: l", "start": [970, 1], "end": [981, 22], "kind": "commanddeclaration"}, {"full_name": "List.Perm.union_right", "code": "theorem Perm.union_right {l\u2081 l\u2082 : List \u03b1} (t\u2081 : List \u03b1) (h : l\u2081 ~ l\u2082) :\n    l\u2081 \u222a t\u2081 ~ l\u2082 \u222a t\u2081", "start": [984, 1], "end": [989, 26], "kind": "commanddeclaration"}, {"full_name": "List.Perm.union_left", "code": "theorem Perm.union_left (l : List \u03b1) {t\u2081 t\u2082 : List \u03b1} (h : t\u2081 ~ t\u2082) : l \u222a t\u2081 ~ l \u222a t\u2082", "start": [992, 1], "end": [993, 40], "kind": "commanddeclaration"}, {"full_name": "List.Perm.union", "code": "theorem Perm.union {l\u2081 l\u2082 t\u2081 t\u2082 : List \u03b1} (p\u2081 : l\u2081 ~ l\u2082) (p\u2082 : t\u2081 ~ t\u2082) :\n    l\u2081 \u222a t\u2081 ~ l\u2082 \u222a t\u2082", "start": [997, 1], "end": [999, 47], "kind": "commanddeclaration"}, {"full_name": "List.Perm.inter_right", "code": "theorem Perm.inter_right {l\u2081 l\u2082 : List \u03b1} (t\u2081 : List \u03b1) : l\u2081 ~ l\u2082 \u2192 l\u2081 \u2229 t\u2081 ~ l\u2082 \u2229 t\u2081", "start": [1002, 1], "end": [1003, 16], "kind": "commanddeclaration"}, {"full_name": "List.Perm.inter_left", "code": "theorem Perm.inter_left (l : List \u03b1) {t\u2081 t\u2082 : List \u03b1} (p : t\u2081 ~ t\u2082) : l \u2229 t\u2081 = l \u2229 t\u2082", "start": [1006, 1], "end": [1007, 52], "kind": "commanddeclaration"}, {"full_name": "List.Perm.inter", "code": "theorem Perm.inter {l\u2081 l\u2082 t\u2081 t\u2082 : List \u03b1} (p\u2081 : l\u2081 ~ l\u2082) (p\u2082 : t\u2081 ~ t\u2082) : l\u2081 \u2229 t\u2081 ~ l\u2082 \u2229 t\u2082", "start": [1011, 1], "end": [1012, 39], "kind": "commanddeclaration"}, {"full_name": "List.Perm.inter_append", "code": "theorem Perm.inter_append {l t\u2081 t\u2082 : List \u03b1} (h : Disjoint t\u2081 t\u2082) :\n    l \u2229 (t\u2081 ++ t\u2082) ~ l \u2229 t\u2081 ++ l \u2229 t\u2082", "start": [1015, 1], "end": [1030, 15], "kind": "commanddeclaration"}, {"full_name": "List.Perm.pairwise_iff", "code": "theorem Perm.pairwise_iff {R : \u03b1 \u2192 \u03b1 \u2192 Prop} (S : Symmetric R) :\n    \u2200 {l\u2081 l\u2082 : List \u03b1} (_p : l\u2081 ~ l\u2082), Pairwise R l\u2081 \u2194 Pairwise R l\u2082", "start": [1035, 1], "end": [1047, 33], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.perm", "code": "theorem Pairwise.perm {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l' : List \u03b1} (hR : l.Pairwise R) (hl : l ~ l')\n    (hsymm : Symmetric R) : l'.Pairwise R", "start": [1051, 1], "end": [1053, 32], "kind": "commanddeclaration"}, {"full_name": "List.Perm.pairwise", "code": "theorem Perm.pairwise {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {l l' : List \u03b1} (hl : l ~ l') (hR : l.Pairwise R)\n    (hsymm : Symmetric R) : l'.Pairwise R", "start": [1056, 1], "end": [1058, 19], "kind": "commanddeclaration"}, {"full_name": "List.Perm.nodup_iff", "code": "theorem Perm.nodup_iff {l\u2081 l\u2082 : List \u03b1} : l\u2081 ~ l\u2082 \u2192 (Nodup l\u2081 \u2194 Nodup l\u2082)", "start": [1061, 1], "end": [1062, 34], "kind": "commanddeclaration"}, {"full_name": "List.Perm.join", "code": "theorem Perm.join {l\u2081 l\u2082 : List (List \u03b1)} (h : l\u2081 ~ l\u2082) : l\u2081.join ~ l\u2082.join", "start": [1065, 1], "end": [1068, 39], "kind": "commanddeclaration"}, {"full_name": "List.Perm.bind_right", "code": "theorem Perm.bind_right {l\u2081 l\u2082 : List \u03b1} (f : \u03b1 \u2192 List \u03b2) (p : l\u2081 ~ l\u2082) : l\u2081.bind f ~ l\u2082.bind f", "start": [1071, 1], "end": [1072, 17], "kind": "commanddeclaration"}, {"full_name": "List.Perm.join_congr", "code": "theorem Perm.join_congr :\n    \u2200 {l\u2081 l\u2082 : List (List \u03b1)} (_ : List.Forall\u2082 (\u00b7 ~ \u00b7) l\u2081 l\u2082), l\u2081.join ~ l\u2082.join", "start": [1075, 1], "end": [1078, 73], "kind": "commanddeclaration"}, {"full_name": "List.Perm.bind_left", "code": "theorem Perm.bind_left (l : List \u03b1) {f g : \u03b1 \u2192 List \u03b2} (h : \u2200 a \u2208 l, f a ~ g a) :\n    l.bind f ~ l.bind g", "start": [1081, 1], "end": [1084, 83], "kind": "commanddeclaration"}, {"full_name": "List.bind_append_perm", "code": "theorem bind_append_perm (l : List \u03b1) (f g : \u03b1 \u2192 List \u03b2) :\n    l.bind f ++ l.bind g ~ l.bind fun x => f x ++ g x", "start": [1087, 1], "end": [1092, 40], "kind": "commanddeclaration"}, {"full_name": "List.map_append_bind_perm", "code": "theorem map_append_bind_perm (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 List \u03b2) :\n    l.map f ++ l.bind g ~ l.bind fun x => f x :: g x", "start": [1095, 1], "end": [1097, 68], "kind": "commanddeclaration"}, {"full_name": "List.Perm.product_right", "code": "theorem Perm.product_right {l\u2081 l\u2082 : List \u03b1} (t\u2081 : List \u03b2) (p : l\u2081 ~ l\u2082) :\n    product l\u2081 t\u2081 ~ product l\u2082 t\u2081", "start": [1100, 1], "end": [1102, 17], "kind": "commanddeclaration"}, {"full_name": "List.Perm.product_left", "code": "theorem Perm.product_left (l : List \u03b1) {t\u2081 t\u2082 : List \u03b2} (p : t\u2081 ~ t\u2082) :\n    product l t\u2081 ~ product l t\u2082", "start": [1105, 1], "end": [1107, 40], "kind": "commanddeclaration"}, {"full_name": "List.Perm.product", "code": "theorem Perm.product {l\u2081 l\u2082 : List \u03b1} {t\u2081 t\u2082 : List \u03b2} (p\u2081 : l\u2081 ~ l\u2082) (p\u2082 : t\u2081 ~ t\u2082) :\n    product l\u2081 t\u2081 ~ product l\u2082 t\u2082", "start": [1111, 1], "end": [1113, 51], "kind": "commanddeclaration"}, {"full_name": "List.perm_lookmap", "code": "theorem perm_lookmap (f : \u03b1 \u2192 Option \u03b1) {l\u2081 l\u2082 : List \u03b1}\n    (H : Pairwise (fun a b => \u2200 c \u2208 f a, \u2200 d \u2208 f b, a = b \u2227 c = d) l\u2081) (p : l\u2081 ~ l\u2082) :\n    lookmap f l\u2081 ~ lookmap f l\u2082", "start": [1116, 1], "end": [1135, 67], "kind": "commanddeclaration"}, {"full_name": "List.Perm.erasep", "code": "theorem Perm.erasep (f : \u03b1 \u2192 Prop) [DecidablePred f] {l\u2081 l\u2082 : List \u03b1}\n    (H : Pairwise (fun a b => f a \u2192 f b \u2192 False) l\u2081) (p : l\u2081 ~ l\u2082) : eraseP f l\u2081 ~ eraseP f l\u2082", "start": [1138, 1], "end": [1149, 37], "kind": "commanddeclaration"}, {"full_name": "List.Perm.take_inter", "code": "theorem Perm.take_inter {\u03b1 : Type*} [DecidableEq \u03b1] {xs ys : List \u03b1} (n : \u2115) (h : xs ~ ys)\n    (h' : ys.Nodup) : xs.take n ~ ys.inter (xs.take n)", "start": [1152, 1], "end": [1157, 22], "kind": "commanddeclaration"}, {"full_name": "List.Perm.drop_inter", "code": "theorem Perm.drop_inter {\u03b1} [DecidableEq \u03b1] {xs ys : List \u03b1} (n : \u2115) (h : xs ~ ys) (h' : ys.Nodup) :\n    xs.drop n ~ ys.inter (xs.drop n)", "start": [1160, 1], "end": [1178, 28], "kind": "commanddeclaration"}, {"full_name": "List.Perm.dropSlice_inter", "code": "theorem Perm.dropSlice_inter {\u03b1} [DecidableEq \u03b1] {xs ys : List \u03b1} (n m : \u2115) (h : xs ~ ys)\n    (h' : ys.Nodup) : List.dropSlice n m xs ~ ys \u2229 List.dropSlice n m xs", "start": [1181, 1], "end": [1188, 37], "kind": "commanddeclaration"}, {"full_name": "List.perm_of_mem_permutationsAux", "code": "theorem perm_of_mem_permutationsAux :\n    \u2200 {ts is l : List \u03b1}, l \u2208 permutationsAux ts is \u2192 l ~ ts ++ is", "start": [1194, 1], "end": [1208, 90], "kind": "commanddeclaration"}, {"full_name": "List.perm_of_mem_permutations", "code": "theorem perm_of_mem_permutations {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 \u2208 permutations l\u2082) : l\u2081 ~ l\u2082", "start": [1211, 1], "end": [1213, 50], "kind": "commanddeclaration"}, {"full_name": "List.length_permutationsAux", "code": "theorem length_permutationsAux :\n    \u2200 ts is : List \u03b1, length (permutationsAux ts is) + is.length ! = (length ts + length is)!", "start": [1216, 1], "end": [1225, 87], "kind": "commanddeclaration"}, {"full_name": "List.length_permutations", "code": "theorem length_permutations (l : List \u03b1) : length (permutations l) = (length l)!", "start": [1228, 1], "end": [1229, 30], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutations_of_perm_lemma", "code": "theorem mem_permutations_of_perm_lemma {is l : List \u03b1}\n    (H : l ~ [] ++ is \u2192 (\u2203 (ts' : _) (_ : ts' ~ []), l = ts' ++ is) \u2228 l \u2208 permutationsAux is []) :\n    l ~ is \u2192 l \u2208 permutations is", "start": [1232, 1], "end": [1234, 78], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutationsAux_of_perm", "code": "theorem mem_permutationsAux_of_perm :\n    \u2200 {ts is l : List \u03b1},\n      l ~ is ++ ts \u2192 (\u2203 (is' : _) (_ : is' ~ is), l = is' ++ ts) \u2228 l \u2208 permutationsAux ts is", "start": [1237, 1], "end": [1254, 28], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutations", "code": "@[simp]\ntheorem mem_permutations {s t : List \u03b1} : s \u2208 permutations t \u2194 s ~ t", "start": [1257, 1], "end": [1259, 89], "kind": "commanddeclaration"}, {"full_name": "List.DecEq_eq", "code": "private theorem DecEq_eq {\u03b1 : Type*} [DecidableEq \u03b1] :\n     instBEqList = @instBEq (List \u03b1) instDecidableEqList", "start": [1263, 1], "end": [1268, 72], "kind": "commanddeclaration"}, {"full_name": "List.perm_permutations'Aux_comm", "code": "theorem perm_permutations'Aux_comm (a b : \u03b1) (l : List \u03b1) :\n    (permutations'Aux a l).bind (permutations'Aux b) ~\n      (permutations'Aux b l).bind (permutations'Aux a)", "start": [1270, 1], "end": [1291, 43], "kind": "commanddeclaration"}, {"full_name": "List.Perm.permutations'", "code": "theorem Perm.permutations' {s t : List \u03b1} (p : s ~ t) : permutations' s ~ permutations' t", "start": [1294, 1], "end": [1302, 24], "kind": "commanddeclaration"}, {"full_name": "List.permutations_perm_permutations'", "code": "theorem permutations_perm_permutations' (ts : List \u03b1) : ts.permutations ~ ts.permutations'", "start": [1305, 1], "end": [1321, 69], "kind": "commanddeclaration"}, {"full_name": "List.mem_permutations'", "code": "@[simp]\ntheorem mem_permutations' {s t : List \u03b1} : s \u2208 permutations' t \u2194 s ~ t", "start": [1324, 1], "end": [1326, 74], "kind": "commanddeclaration"}, {"full_name": "List.Perm.permutations", "code": "theorem Perm.permutations {s t : List \u03b1} (h : s ~ t) : permutations s ~ permutations t", "start": [1329, 1], "end": [1331, 67], "kind": "commanddeclaration"}, {"full_name": "List.perm_permutations_iff", "code": "@[simp]\ntheorem perm_permutations_iff {s t : List \u03b1} : permutations s ~ permutations t \u2194 s ~ t", "start": [1334, 1], "end": [1337, 23], "kind": "commanddeclaration"}, {"full_name": "List.perm_permutations'_iff", "code": "@[simp]\ntheorem perm_permutations'_iff {s t : List \u03b1} : permutations' s ~ permutations' t \u2194 s ~ t", "start": [1340, 1], "end": [1343, 24], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_permutations'Aux", "code": "theorem nthLe_permutations'Aux (s : List \u03b1) (x : \u03b1) (n : \u2115)\n    (hn : n < length (permutations'Aux x s)) :\n    (permutations'Aux x s).nthLe n hn = s.insertNth n x", "start": [1347, 1], "end": [1355, 33], "kind": "commanddeclaration"}, {"full_name": "List.count_permutations'Aux_self", "code": "theorem count_permutations'Aux_self [DecidableEq \u03b1] (l : List \u03b1) (x : \u03b1) :\n    count (x :: l) (permutations'Aux x l) = length (takeWhile ((\u00b7 = \u00b7) x) l) + 1", "start": [1358, 1], "end": [1368, 89], "kind": "commanddeclaration"}, {"full_name": "List.length_permutations'Aux", "code": "@[simp]\ntheorem length_permutations'Aux (s : List \u03b1) (x : \u03b1) :\n    length (permutations'Aux x s) = length s + 1", "start": [1371, 1], "end": [1376, 19], "kind": "commanddeclaration"}, {"full_name": "List.permutations'Aux_nthLe_zero", "code": "@[simp]\ntheorem permutations'Aux_nthLe_zero (s : List \u03b1) (x : \u03b1)\n    (hn : 0 < length (permutations'Aux x s) := (by simp)) :\n    (permutations'Aux x s).nthLe 0 hn = x :: s", "start": [1379, 1], "end": [1383, 33], "kind": "commanddeclaration"}, {"full_name": "List.injective_permutations'Aux", "code": "theorem injective_permutations'Aux (x : \u03b1) : Function.Injective (permutations'Aux x)", "start": [1386, 1], "end": [1392, 15], "kind": "commanddeclaration"}, {"full_name": "List.nodup_permutations'Aux_of_not_mem", "code": "theorem nodup_permutations'Aux_of_not_mem (s : List \u03b1) (x : \u03b1) (hx : x \u2209 s) :\n    Nodup (permutations'Aux x s)", "start": [1395, 1], "end": [1404, 11], "kind": "commanddeclaration"}, {"full_name": "List.nodup_permutations'Aux_iff", "code": "theorem nodup_permutations'Aux_iff {s : List \u03b1} {x : \u03b1} : Nodup (permutations'Aux x s) \u2194 x \u2209 s", "start": [1408, 1], "end": [1436, 38], "kind": "commanddeclaration"}, {"full_name": "List.nodup_permutations", "code": "theorem nodup_permutations (s : List \u03b1) (hs : Nodup s) : Nodup s.permutations", "start": [1440, 1], "end": [1476, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Quot.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quot.recOn'", "code": "@[inherit_doc Quot.rec, elab_as_elim] protected abbrev Quot.recOn'\n    (q : Quot r)\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a))\n    (h : (a b : \u03b1) \u2192 (p : r a b) \u2192 Eq.ndrec (f a) (Quot.sound p) = f b) :\n    motive q :=\n q.rec f h", "start": [21, 1], "end": [27, 11], "kind": "commanddeclaration"}, {"full_name": "Quot.recOnSubsingleton'", "code": "@[elab_as_elim] protected abbrev Quot.recOnSubsingleton'\n    [h : (a : \u03b1) \u2192 Subsingleton (motive (Quot.mk r a))]\n    (q : Quot r)\n    (f : (a : \u03b1) \u2192 motive (Quot.mk r a)) :\n    motive q := by\n  induction q using Quot.rec\n  apply f\n  apply Subsingleton.elim", "start": [31, 1], "end": [40, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Basic.lean", "imports": ["Mathlib/Init/Quot.lean", "Mathlib/Data/List/Perm.lean", "Mathlib/Data/Set/List.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset", "code": "def Multiset.{u} (\u03b1 : Type u) : Type u :=\n  Quotient (List.isSetoid \u03b1)", "start": [25, 1], "end": [28, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.ofList", "code": "@[coe]\ndef ofList : List \u03b1 \u2192 Multiset \u03b1 :=\n  Quot.mk _", "start": [34, 1], "end": [37, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.quot_mk_to_coe", "code": "@[simp]\ntheorem quot_mk_to_coe (l : List \u03b1) : @Eq (Multiset \u03b1) \u27e6l\u27e7 l", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.quot_mk_to_coe'", "code": "@[simp]\ntheorem quot_mk_to_coe' (l : List \u03b1) : @Eq (Multiset \u03b1) (Quot.mk (\u00b7 \u2248 \u00b7) l) l", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.quot_mk_to_coe''", "code": "@[simp]\ntheorem quot_mk_to_coe'' (l : List \u03b1) : @Eq (Multiset \u03b1) (Quot.mk Setoid.r l) l", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_eq_coe", "code": "@[simp]\ntheorem coe_eq_coe {l\u2081 l\u2082 : List \u03b1} : (l\u2081 : Multiset \u03b1) = l\u2082 \u2194 l\u2081 ~ l\u2082", "start": [57, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] : DecidableEq (Multiset \u03b1)\n  | s\u2081, s\u2082 => Quotient.recOnSubsingleton\u2082 s\u2081 s\u2082 fun _ _ => decidable_of_iff' _ Quotient.eq", "start": [67, 1], "end": [68, 91], "kind": "commanddeclaration"}, {"full_name": "Multiset.sizeOf", "code": "protected\ndef sizeOf [SizeOf \u03b1] (s : Multiset \u03b1) : \u2115 :=\n  (Quot.liftOn s SizeOf.sizeOf) fun _ _ => Perm.sizeOf_eq_sizeOf", "start": [71, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero", "code": "protected def zero : Multiset \u03b1 :=\n  @nil \u03b1", "start": [83, 1], "end": [85, 9], "kind": "commanddeclaration"}, {"full_name": "Multiset.inhabitedMultiset", "code": "instance inhabitedMultiset : Inhabited (Multiset \u03b1) :=\n  \u27e80\u27e9", "start": [94, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_nil", "code": "@[simp]\ntheorem coe_nil : (@nil \u03b1 : Multiset \u03b1) = 0", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.empty_eq_zero", "code": "@[simp]\ntheorem empty_eq_zero : (\u2205 : Multiset \u03b1) = 0", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_eq_zero", "code": "@[simp]\ntheorem coe_eq_zero (l : List \u03b1) : (l : Multiset \u03b1) = 0 \u2194 l = []", "start": [108, 1], "end": [110, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_eq_zero_iff_isEmpty", "code": "theorem coe_eq_zero_iff_isEmpty (l : List \u03b1) : (l : Multiset \u03b1) = 0 \u2194 l.isEmpty", "start": [113, 1], "end": [114, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons", "code": "def cons (a : \u03b1) (s : Multiset \u03b1) : Multiset \u03b1 :=\n  Quot.liftOn s (fun l => (a :: l : Multiset \u03b1)) fun _ _ p => Quot.sound (p.cons a)", "start": [119, 1], "end": [121, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.insert_eq_cons", "code": "@[simp]\ntheorem insert_eq_cons (a : \u03b1) (s : Multiset \u03b1) : insert a s = a ::\u2098 s", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_coe", "code": "@[simp]\ntheorem cons_coe (a : \u03b1) (l : List \u03b1) : (a ::\u2098 l : Multiset \u03b1) = (a :: l : List \u03b1)", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_inj_left", "code": "@[simp]\ntheorem cons_inj_left {a b : \u03b1} (s : Multiset \u03b1) : a ::\u2098 s = b ::\u2098 s \u2194 a = b", "start": [140, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_inj_right", "code": "@[simp]\ntheorem cons_inj_right (a : \u03b1) : \u2200 {s t : Multiset \u03b1}, a ::\u2098 s = a ::\u2098 t \u2194 s = t", "start": [148, 1], "end": [150, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.induction", "code": "@[recursor 5]\nprotected theorem induction {p : Multiset \u03b1 \u2192 Prop} (empty : p 0)\n    (cons : \u2200 \u2983a : \u03b1\u2984 {s : Multiset \u03b1}, p s \u2192 p (a ::\u2098 s)) : \u2200 s, p s", "start": [153, 1], "end": [156, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {p : Multiset \u03b1 \u2192 Prop} (s : Multiset \u03b1) (empty : p 0)\n    (cons : \u2200 \u2983a : \u03b1\u2984 {s : Multiset \u03b1}, p s \u2192 p (a ::\u2098 s)) : p s", "start": [159, 1], "end": [162, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_swap", "code": "theorem cons_swap (a b : \u03b1) (s : Multiset \u03b1) : a ::\u2098 b ::\u2098 s = b ::\u2098 a ::\u2098 s", "start": [165, 1], "end": [166, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.rec", "code": "protected\ndef rec (C_0 : C 0) (C_cons : \u2200 a m, C m \u2192 C (a ::\u2098 m))\n    (C_cons_heq :\n      \u2200 a a' m b, HEq (C_cons a (a' ::\u2098 m) (C_cons a' m b)) (C_cons a' (a ::\u2098 m) (C_cons a m b)))\n    (m : Multiset \u03b1) : C m :=\n  Quotient.hrecOn m (@List.rec \u03b1 (fun l => C \u27e6l\u27e7) C_0 fun a l b => C_cons a \u27e6l\u27e7 b) fun l l' h =>\n    h.rec_heq\n      (fun hl _ \u21a6 by congr 1; exact Quot.sound hl)\n      (C_cons_heq _ _ \u27e6_\u27e7 _)", "start": [173, 1], "end": [185, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.recOn", "code": "@[elab_as_elim]\nprotected\ndef recOn (m : Multiset \u03b1) (C_0 : C 0) (C_cons : \u2200 a m, C m \u2192 C (a ::\u2098 m))\n    (C_cons_heq :\n      \u2200 a a' m b, HEq (C_cons a (a' ::\u2098 m) (C_cons a' m b)) (C_cons a' (a ::\u2098 m) (C_cons a m b))) :\n    C m :=\n  Multiset.rec C_0 C_cons C_cons_heq m", "start": [188, 1], "end": [195, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.recOn_0", "code": "@[simp]\ntheorem recOn_0 : @Multiset.recOn \u03b1 C (0 : Multiset \u03b1) C_0 C_cons C_cons_heq = C_0", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.recOn_cons", "code": "@[simp]\ntheorem recOn_cons (a : \u03b1) (m : Multiset \u03b1) :\n    (a ::\u2098 m).recOn C_0 C_cons C_cons_heq = C_cons a m (m.recOn C_0 C_cons C_cons_heq)", "start": [207, 1], "end": [210, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.Mem", "code": "def Mem (a : \u03b1) (s : Multiset \u03b1) : Prop :=\n  Quot.liftOn s (fun l => a \u2208 l) fun l\u2081 l\u2082 (e : l\u2081 ~ l\u2082) => propext <| e.mem_iff", "start": [217, 1], "end": [219, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_coe", "code": "@[simp]\ntheorem mem_coe {a : \u03b1} {l : List \u03b1} : a \u2208 (l : Multiset \u03b1) \u2194 a \u2208 l", "start": [225, 1], "end": [227, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableMem", "code": "instance decidableMem [DecidableEq \u03b1] (a : \u03b1) (s : Multiset \u03b1) : Decidable (a \u2208 s) :=\n  Quot.recOnSubsingleton' s <| fun l \u21a6 inferInstanceAs (Decidable (a \u2208 l))", "start": [230, 1], "end": [231, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_cons", "code": "@[simp]\ntheorem mem_cons {a b : \u03b1} {s : Multiset \u03b1} : a \u2208 b ::\u2098 s \u2194 a = b \u2228 a \u2208 s", "start": [234, 1], "end": [236, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_cons_of_mem", "code": "theorem mem_cons_of_mem {a b : \u03b1} {s : Multiset \u03b1} (h : a \u2208 s) : a \u2208 b ::\u2098 s", "start": [239, 1], "end": [240, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_cons_self", "code": "theorem mem_cons_self (a : \u03b1) (s : Multiset \u03b1) : a \u2208 a ::\u2098 s", "start": [244, 1], "end": [245, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.forall_mem_cons", "code": "theorem forall_mem_cons {p : \u03b1 \u2192 Prop} {a : \u03b1} {s : Multiset \u03b1} :\n    (\u2200 x \u2208 a ::\u2098 s, p x) \u2194 p a \u2227 \u2200 x \u2208 s, p x", "start": [248, 1], "end": [250, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_cons_of_mem", "code": "theorem exists_cons_of_mem {s : Multiset \u03b1} {a : \u03b1} : a \u2208 s \u2192 \u2203 t, s = a ::\u2098 t", "start": [253, 1], "end": [256, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.not_mem_zero", "code": "@[simp]\ntheorem not_mem_zero (a : \u03b1) : a \u2209 (0 : Multiset \u03b1)", "start": [259, 1], "end": [261, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_zero_of_forall_not_mem", "code": "theorem eq_zero_of_forall_not_mem {s : Multiset \u03b1} : (\u2200 x, x \u2209 s) \u2192 s = 0", "start": [264, 1], "end": [265, 77], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_zero_iff_forall_not_mem", "code": "theorem eq_zero_iff_forall_not_mem {s : Multiset \u03b1} : s = 0 \u2194 \u2200 a, a \u2209 s", "start": [268, 1], "end": [269, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_mem_of_ne_zero", "code": "theorem exists_mem_of_ne_zero {s : Multiset \u03b1} : s \u2260 0 \u2192 \u2203 a : \u03b1, a \u2208 s", "start": [272, 1], "end": [276, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.empty_or_exists_mem", "code": "theorem empty_or_exists_mem (s : Multiset \u03b1) : s = 0 \u2228 \u2203 a, a \u2208 s", "start": [279, 1], "end": [280, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_ne_cons", "code": "@[simp]\ntheorem zero_ne_cons {a : \u03b1} {m : Multiset \u03b1} : 0 \u2260 a ::\u2098 m", "start": [283, 1], "end": [286, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_ne_zero", "code": "@[simp]\ntheorem cons_ne_zero {a : \u03b1} {m : Multiset \u03b1} : a ::\u2098 m \u2260 0", "start": [289, 1], "end": [291, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_eq_cons", "code": "theorem cons_eq_cons {a b : \u03b1} {as bs : Multiset \u03b1} :\n    a ::\u2098 as = b ::\u2098 bs \u2194 a = b \u2227 as = bs \u2228 a \u2260 b \u2227 \u2203 cs, as = b ::\u2098 cs \u2227 bs = a ::\u2098 cs", "start": [294, 1], "end": [313, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_zero", "code": "@[simp]\ntheorem cons_zero (a : \u03b1) : a ::\u2098 0 = {a}", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_singleton", "code": "@[simp, norm_cast]\ntheorem coe_singleton (a : \u03b1) : ([a] : Multiset \u03b1) = {a}", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_singleton", "code": "@[simp]\ntheorem mem_singleton {a b : \u03b1} : b \u2208 ({a} : Multiset \u03b1) \u2194 b = a", "start": [337, 1], "end": [339, 78], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_singleton_self", "code": "theorem mem_singleton_self (a : \u03b1) : a \u2208 ({a} : Multiset \u03b1)", "start": [342, 1], "end": [344, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_inj", "code": "@[simp]\ntheorem singleton_inj {a b : \u03b1} : ({a} : Multiset \u03b1) = {b} \u2194 a = b", "start": [347, 1], "end": [350, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_eq_singleton", "code": "@[simp, norm_cast]\ntheorem coe_eq_singleton {l : List \u03b1} {a : \u03b1} : (l : Multiset \u03b1) = {a} \u2194 l = [a]", "start": [353, 1], "end": [355, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_eq_cons_iff", "code": "@[simp]\ntheorem singleton_eq_cons_iff {a b : \u03b1} (m : Multiset \u03b1) : {a} = b ::\u2098 m \u2194 a = b \u2227 m = 0", "start": [358, 1], "end": [361, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.pair_comm", "code": "theorem pair_comm (x y : \u03b1) : ({x, y} : Multiset \u03b1) = {y, x}", "start": [364, 1], "end": [365, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.Subset", "code": "protected def Subset (s t : Multiset \u03b1) : Prop :=\n  \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 a \u2208 t", "start": [373, 1], "end": [378, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_subset", "code": "@[simp]\ntheorem coe_subset {l\u2081 l\u2082 : List \u03b1} : (l\u2081 : Multiset \u03b1) \u2286 l\u2082 \u2194 l\u2081 \u2286 l\u2082", "start": [387, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.Subset.refl", "code": "@[simp]\ntheorem Subset.refl (s : Multiset \u03b1) : s \u2286 s", "start": [392, 1], "end": [393, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.Subset.trans", "code": "theorem Subset.trans {s t u : Multiset \u03b1} : s \u2286 t \u2192 t \u2286 u \u2192 s \u2286 u", "start": [396, 1], "end": [396, 96], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_iff", "code": "theorem subset_iff {s t : Multiset \u03b1} : s \u2286 t \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 t", "start": [399, 1], "end": [400, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_of_subset", "code": "theorem mem_of_subset {s t : Multiset \u03b1} {a : \u03b1} (h : s \u2286 t) : a \u2208 s \u2192 a \u2208 t", "start": [403, 1], "end": [404, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_subset", "code": "@[simp]\ntheorem zero_subset (s : Multiset \u03b1) : 0 \u2286 s", "start": [407, 1], "end": [408, 78], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_cons", "code": "theorem subset_cons (s : Multiset \u03b1) (a : \u03b1) : s \u2286 a ::\u2098 s", "start": [411, 1], "end": [411, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.ssubset_cons", "code": "theorem ssubset_cons {s : Multiset \u03b1} {a : \u03b1} (ha : a \u2209 s) : s \u2282 a ::\u2098 s", "start": [414, 1], "end": [415, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_subset", "code": "@[simp]\ntheorem cons_subset {a : \u03b1} {s t : Multiset \u03b1} : a ::\u2098 s \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t", "start": [418, 1], "end": [420, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_subset_cons", "code": "theorem cons_subset_cons {a : \u03b1} {s t : Multiset \u03b1} : s \u2286 t \u2192 a ::\u2098 s \u2286 a ::\u2098 t", "start": [423, 1], "end": [424, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_zero_of_subset_zero", "code": "theorem eq_zero_of_subset_zero {s : Multiset \u03b1} (h : s \u2286 0) : s = 0", "start": [427, 1], "end": [428, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_zero", "code": "theorem subset_zero {s : Multiset \u03b1} : s \u2286 0 \u2194 s = 0", "start": [431, 1], "end": [432, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.induction_on'", "code": "theorem induction_on' {p : Multiset \u03b1 \u2192 Prop} (S : Multiset \u03b1) (h\u2081 : p 0)\n    (h\u2082 : \u2200 {a s}, a \u2208 S \u2192 s \u2286 S \u2192 p s \u2192 p (insert a s)) : p S", "start": [435, 1], "end": [441, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.toList", "code": "noncomputable def toList (s : Multiset \u03b1) :=\n  s.out'", "start": [451, 1], "end": [453, 9], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_toList", "code": "@[simp, norm_cast]\ntheorem coe_toList (s : Multiset \u03b1) : (s.toList : Multiset \u03b1) = s", "start": [456, 1], "end": [458, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.toList_eq_nil", "code": "@[simp]\ntheorem toList_eq_nil {s : Multiset \u03b1} : s.toList = [] \u2194 s = 0", "start": [461, 1], "end": [463, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.empty_toList", "code": "@[simp]\ntheorem empty_toList {s : Multiset \u03b1} : s.toList.isEmpty \u2194 s = 0", "start": [466, 1], "end": [468, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.toList_zero", "code": "@[simp]\ntheorem toList_zero : (Multiset.toList 0 : List \u03b1) = []", "start": [471, 1], "end": [473, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_toList", "code": "@[simp]\ntheorem mem_toList {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s.toList \u2194 a \u2208 s", "start": [476, 1], "end": [478, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.toList_eq_singleton_iff", "code": "@[simp]\ntheorem toList_eq_singleton_iff {a : \u03b1} {m : Multiset \u03b1} : m.toList = [a] \u2194 m = {a}", "start": [481, 1], "end": [483, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.toList_singleton", "code": "@[simp]\ntheorem toList_singleton (a : \u03b1) : ({a} : Multiset \u03b1).toList = [a]", "start": [486, 1], "end": [488, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.Le", "code": "protected def Le (s t : Multiset \u03b1) : Prop :=\n  (Quotient.liftOn\u2082 s t (\u00b7 <+~ \u00b7)) fun _ _ _ _ p\u2081 p\u2082 =>\n    propext (p\u2082.subperm_left.trans p\u2081.subperm_right)", "start": [496, 1], "end": [500, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableLE", "code": "instance decidableLE [DecidableEq \u03b1] : DecidableRel ((\u00b7 \u2264 \u00b7) : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop) :=\n  fun s t => Quotient.recOnSubsingleton\u2082 s t List.decidableSubperm", "start": [509, 1], "end": [510, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_of_le", "code": "theorem subset_of_le : s \u2264 t \u2192 s \u2286 t", "start": [517, 1], "end": [518, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.Le.subset", "code": "alias Le.subset := subset_of_le", "start": [521, 1], "end": [521, 32], "kind": "stdtacticaliasalias"}, {"full_name": "Multiset.mem_of_le", "code": "theorem mem_of_le (h : s \u2264 t) : a \u2208 s \u2192 a \u2208 t", "start": [524, 1], "end": [525, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.not_mem_mono", "code": "theorem not_mem_mono (h : s \u2286 t) : a \u2209 t \u2192 a \u2209 s", "start": [528, 1], "end": [529, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_le", "code": "@[simp]\ntheorem coe_le {l\u2081 l\u2082 : List \u03b1} : (l\u2081 : Multiset \u03b1) \u2264 l\u2082 \u2194 l\u2081 <+~ l\u2082", "start": [532, 1], "end": [534, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.leInductionOn", "code": "@[elab_as_elim]\ntheorem leInductionOn {C : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop} {s t : Multiset \u03b1} (h : s \u2264 t)\n    (H : \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 C l\u2081 l\u2082) : C s t", "start": [537, 1], "end": [540, 96], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_le", "code": "theorem zero_le (s : Multiset \u03b1) : 0 \u2264 s", "start": [543, 1], "end": [544, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.bot_eq_zero", "code": "@[simp]\ntheorem bot_eq_zero : (\u22a5 : Multiset \u03b1) = 0", "start": [551, 1], "end": [554, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_zero", "code": "theorem le_zero : s \u2264 0 \u2194 s = 0", "start": [557, 1], "end": [558, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.lt_cons_self", "code": "theorem lt_cons_self (s : Multiset \u03b1) (a : \u03b1) : s < a ::\u2098 s", "start": [561, 1], "end": [564, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_cons_self", "code": "theorem le_cons_self (s : Multiset \u03b1) (a : \u03b1) : s \u2264 a ::\u2098 s", "start": [567, 1], "end": [568, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_le_cons_iff", "code": "theorem cons_le_cons_iff (a : \u03b1) : a ::\u2098 s \u2264 a ::\u2098 t \u2194 s \u2264 t", "start": [571, 1], "end": [572, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_le_cons", "code": "theorem cons_le_cons (a : \u03b1) : s \u2264 t \u2192 a ::\u2098 s \u2264 a ::\u2098 t", "start": [575, 1], "end": [576, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_cons_of_not_mem", "code": "theorem le_cons_of_not_mem (m : a \u2209 s) : s \u2264 a ::\u2098 t \u2194 s \u2264 t", "start": [579, 1], "end": [590, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_ne_zero", "code": "@[simp]\ntheorem singleton_ne_zero (a : \u03b1) : ({a} : Multiset \u03b1) \u2260 0", "start": [593, 1], "end": [595, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_le", "code": "@[simp]\ntheorem singleton_le {a : \u03b1} {s : Multiset \u03b1} : {a} \u2264 s \u2194 a \u2208 s", "start": [598, 1], "end": [602, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.add", "code": "protected def add (s\u2081 s\u2082 : Multiset \u03b1) : Multiset \u03b1 :=\n  (Quotient.liftOn\u2082 s\u2081 s\u2082 fun l\u2081 l\u2082 => ((l\u2081 ++ l\u2082 : List \u03b1) : Multiset \u03b1)) fun _ _ _ _ p\u2081 p\u2082 =>\n    Quot.sound <| p\u2081.append p\u2082", "start": [610, 1], "end": [615, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_add", "code": "@[simp]\ntheorem coe_add (s t : List \u03b1) : (s + t : Multiset \u03b1) = (s ++ t : List \u03b1)", "start": [621, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_add", "code": "@[simp]\ntheorem singleton_add (a : \u03b1) (s : Multiset \u03b1) : {a} + s = a ::\u2098 s", "start": [626, 1], "end": [628, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_le_add_iff_left'", "code": "private theorem add_le_add_iff_left' {s t u : Multiset \u03b1} : s + t \u2264 s + u \u2194 t \u2264 u", "start": [631, 1], "end": [632, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_add_right", "code": "theorem le_add_right (s t : Multiset \u03b1) : s \u2264 s + t", "start": [651, 1], "end": [651, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_add_left", "code": "theorem le_add_left (s t : Multiset \u03b1) : s \u2264 t + s", "start": [654, 1], "end": [654, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_iff_exists_add", "code": "theorem le_iff_exists_add {s t : Multiset \u03b1} : s \u2264 t \u2194 \u2203 u, t = s + u", "start": [657, 1], "end": [662, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_add", "code": "@[simp]\ntheorem cons_add (a : \u03b1) (s t : Multiset \u03b1) : a ::\u2098 s + t = a ::\u2098 (s + t)", "start": [672, 1], "end": [674, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_cons", "code": "@[simp]\ntheorem add_cons (a : \u03b1) (s t : Multiset \u03b1) : s + a ::\u2098 t = a ::\u2098 (s + t)", "start": [677, 1], "end": [679, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_add", "code": "@[simp]\ntheorem mem_add {a : \u03b1} {s t : Multiset \u03b1} : a \u2208 s + t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [682, 1], "end": [684, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_of_mem_nsmul", "code": "theorem mem_of_mem_nsmul {a : \u03b1} {s : Multiset \u03b1} {n : \u2115} (h : a \u2208 n \u2022 s) : a \u2208 s", "start": [687, 1], "end": [692, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_nsmul", "code": "@[simp]\ntheorem mem_nsmul {a : \u03b1} {s : Multiset \u03b1} {n : \u2115} (h0 : n \u2260 0) : a \u2208 n \u2022 s \u2194 a \u2208 s", "start": [695, 1], "end": [700, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.nsmul_cons", "code": "theorem nsmul_cons {s : Multiset \u03b1} (n : \u2115) (a : \u03b1) :\n    n \u2022 (a ::\u2098 s) = n \u2022 ({a} : Multiset \u03b1) + n \u2022 s", "start": [703, 1], "end": [705, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.card", "code": "def card : Multiset \u03b1 \u2192+ \u2115 where\n  toFun s := (Quot.liftOn s length) fun _l\u2081 _l\u2082 => Perm.length_eq\n  map_zero' := rfl\n  map_add' s t := Quotient.inductionOn\u2082 s t length_append", "start": [711, 1], "end": [716, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_card", "code": "@[simp]\ntheorem coe_card (l : List \u03b1) : card (l : Multiset \u03b1) = length l", "start": [719, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.length_toList", "code": "@[simp]\ntheorem length_toList (s : Multiset \u03b1) : s.toList.length = card s", "start": [724, 1], "end": [726, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_zero", "code": "@[simp, nolint simpNF] theorem card_zero : @card \u03b1 0 = 0", "start": [729, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_add", "code": "theorem card_add (s t : Multiset \u03b1) : card (s + t) = card s + card t", "start": [734, 1], "end": [735, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_nsmul", "code": "theorem card_nsmul (s : Multiset \u03b1) (n : \u2115) : card (n \u2022 s) = n * card s", "start": [738, 1], "end": [739, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_cons", "code": "@[simp]\ntheorem card_cons (a : \u03b1) (s : Multiset \u03b1) : card (a ::\u2098 s) = card s + 1", "start": [742, 1], "end": [744, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_singleton", "code": "@[simp]\ntheorem card_singleton (a : \u03b1) : card ({a} : Multiset \u03b1) = 1", "start": [747, 1], "end": [749, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_pair", "code": "theorem card_pair (a b : \u03b1) : card {a, b} = 2", "start": [752, 1], "end": [753, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_one", "code": "theorem card_eq_one {s : Multiset \u03b1} : card s = 1 \u2194 \u2203 a, s = {a}", "start": [756, 1], "end": [758, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_le_of_le", "code": "theorem card_le_of_le {s t : Multiset \u03b1} (h : s \u2264 t) : card s \u2264 card t", "start": [761, 1], "end": [762, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_mono", "code": "@[mono]\ntheorem card_mono : Monotone (@card \u03b1)", "start": [765, 1], "end": [766, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_of_le_of_card_le", "code": "theorem eq_of_le_of_card_le {s t : Multiset \u03b1} (h : s \u2264 t) : card t \u2264 card s \u2192 s = t", "start": [769, 1], "end": [770, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_lt_of_lt", "code": "theorem card_lt_of_lt {s t : Multiset \u03b1} (h : s < t) : card s < card t", "start": [773, 1], "end": [774, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.lt_iff_cons_le", "code": "theorem lt_iff_cons_le {s t : Multiset \u03b1} : s < t \u2194 \u2203 a, a ::\u2098 s \u2264 t", "start": [777, 1], "end": [780, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_zero", "code": "@[simp]\ntheorem card_eq_zero {s : Multiset \u03b1} : card s = 0 \u2194 s = 0", "start": [783, 1], "end": [785, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_pos", "code": "theorem card_pos {s : Multiset \u03b1} : 0 < card s \u2194 s \u2260 0", "start": [788, 1], "end": [789, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_pos_iff_exists_mem", "code": "theorem card_pos_iff_exists_mem {s : Multiset \u03b1} : 0 < card s \u2194 \u2203 a, a \u2208 s", "start": [792, 1], "end": [793, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_two", "code": "theorem card_eq_two {s : Multiset \u03b1} : card s = 2 \u2194 \u2203 x y, s = {x, y}", "start": [796, 1], "end": [799, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_three", "code": "theorem card_eq_three {s : Multiset \u03b1} : card s = 3 \u2194 \u2203 x y z, s = {x, y, z}", "start": [802, 1], "end": [806, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongInductionOn", "code": "@[elab_as_elim]\ndef strongInductionOn {p : Multiset \u03b1 \u2192 Sort*} (s : Multiset \u03b1) (ih : \u2200 s, (\u2200 t < s, p t) \u2192 p s) :\n    p s :=\n    (ih s) fun t _h =>\n      strongInductionOn t ih\ntermination_by _ => card s\ndecreasing_by exact card_lt_of_lt _h", "start": [811, 1], "end": [818, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongInductionOn_eq", "code": "theorem strongInductionOn_eq {p : Multiset \u03b1 \u2192 Sort*} (s : Multiset \u03b1) (H) :\n    @strongInductionOn _ p s H = H s fun t _h => @strongInductionOn _ p t H", "start": [821, 1], "end": [823, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.case_strongInductionOn", "code": "@[elab_as_elim]\ntheorem case_strongInductionOn {p : Multiset \u03b1 \u2192 Prop} (s : Multiset \u03b1) (h\u2080 : p 0)\n    (h\u2081 : \u2200 a s, (\u2200 t \u2264 s, p t) \u2192 p (a ::\u2098 s)) : p s", "start": [826, 1], "end": [831, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongDownwardInduction", "code": "def strongDownwardInduction {p : Multiset \u03b1 \u2192 Sort*} {n : \u2115}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Multiset \u03b1}, card t\u2082 \u2264 n \u2192 t\u2081 < t\u2082 \u2192 p t\u2082) \u2192 card t\u2081 \u2264 n \u2192 p t\u2081)\n    (s : Multiset \u03b1) :\n    card s \u2264 n \u2192 p s :=\n  H s fun {t} ht _h =>\n    strongDownwardInduction H t ht\ntermination_by _ => n - card s\ndecreasing_by exact (tsub_lt_tsub_iff_left_of_le ht).2 (card_lt_of_lt _h)", "start": [834, 1], "end": [845, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongDownwardInduction_eq", "code": "theorem strongDownwardInduction_eq {p : Multiset \u03b1 \u2192 Sort*} {n : \u2115}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Multiset \u03b1}, card t\u2082 \u2264 n \u2192 t\u2081 < t\u2082 \u2192 p t\u2082) \u2192 card t\u2081 \u2264 n \u2192 p t\u2081)\n    (s : Multiset \u03b1) :\n    strongDownwardInduction H s = H s fun ht _hst => strongDownwardInduction H _ ht", "start": [849, 1], "end": [853, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongDownwardInductionOn", "code": "@[elab_as_elim]\ndef strongDownwardInductionOn {p : Multiset \u03b1 \u2192 Sort*} {n : \u2115} :\n    \u2200 s : Multiset \u03b1,\n      (\u2200 t\u2081, (\u2200 {t\u2082 : Multiset \u03b1}, card t\u2082 \u2264 n \u2192 t\u2081 < t\u2082 \u2192 p t\u2082) \u2192 card t\u2081 \u2264 n \u2192 p t\u2081) \u2192\n        card s \u2264 n \u2192 p s :=\n  fun s H => strongDownwardInduction H s", "start": [856, 1], "end": [862, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.strongDownwardInductionOn_eq", "code": "theorem strongDownwardInductionOn_eq {p : Multiset \u03b1 \u2192 Sort*} (s : Multiset \u03b1) {n : \u2115}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Multiset \u03b1}, card t\u2082 \u2264 n \u2192 t\u2081 < t\u2082 \u2192 p t\u2082) \u2192 card t\u2081 \u2264 n \u2192 p t\u2081) :\n    s.strongDownwardInductionOn H = H s fun {t} ht _h => t.strongDownwardInductionOn H ht", "start": [865, 1], "end": [869, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.wellFounded_lt", "code": "theorem wellFounded_lt : WellFounded ((\u00b7 < \u00b7) : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop)", "start": [872, 1], "end": [874, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.is_wellFounded_lt", "code": "instance is_wellFounded_lt : WellFoundedLT (Multiset \u03b1) :=\n  \u27e8wellFounded_lt\u27e9", "start": [877, 1], "end": [878, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate", "code": "def replicate (n : \u2115) (a : \u03b1) : Multiset \u03b1 :=\n  List.replicate n a", "start": [883, 1], "end": [885, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_replicate", "code": "theorem coe_replicate (n : \u2115) (a : \u03b1) : (List.replicate n a : Multiset \u03b1) = replicate n a", "start": [888, 1], "end": [888, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_zero", "code": "@[simp] theorem replicate_zero (a : \u03b1) : replicate 0 a = 0", "start": [891, 1], "end": [891, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_succ", "code": "@[simp] theorem replicate_succ (a : \u03b1) (n) : replicate (n + 1) a = a ::\u2098 replicate n a", "start": [894, 1], "end": [894, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_add", "code": "theorem replicate_add (m n : \u2115) (a : \u03b1) : replicate (m + n) a = replicate m a + replicate n a", "start": [897, 1], "end": [898, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicateAddMonoidHom", "code": "@[simps]\ndef replicateAddMonoidHom (a : \u03b1) : \u2115 \u2192+ Multiset \u03b1 where\n  toFun := fun n => replicate n a\n  map_zero' := replicate_zero a\n  map_add' := fun _ _ => replicate_add _ _ a", "start": [901, 1], "end": [906, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_one", "code": "theorem replicate_one (a : \u03b1) : replicate 1 a = {a}", "start": [910, 1], "end": [910, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_replicate", "code": "@[simp] theorem card_replicate (n) (a : \u03b1) : card (replicate n a) = n", "start": [913, 1], "end": [914, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_replicate", "code": "theorem mem_replicate {a b : \u03b1} {n : \u2115} : b \u2208 replicate n a \u2194 n \u2260 0 \u2227 b = a", "start": [917, 1], "end": [918, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_of_mem_replicate", "code": "theorem eq_of_mem_replicate {a b : \u03b1} {n} : b \u2208 replicate n a \u2192 b = a", "start": [921, 1], "end": [922, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_replicate_card", "code": "theorem eq_replicate_card {a : \u03b1} {s : Multiset \u03b1} : s = replicate (card s) a \u2194 \u2200 b \u2208 s, b = a", "start": [925, 1], "end": [926, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_replicate_of_mem", "code": "alias \u27e8_, eq_replicate_of_mem\u27e9 := eq_replicate_card", "start": [929, 1], "end": [929, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.eq_replicate", "code": "theorem eq_replicate {a : \u03b1} {n} {s : Multiset \u03b1} :\n    s = replicate n a \u2194 card s = n \u2227 \u2200 b \u2208 s, b = a", "start": [932, 1], "end": [935, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_right_injective", "code": "theorem replicate_right_injective {n : \u2115} (hn : n \u2260 0) : Injective (@replicate \u03b1 n)", "start": [938, 1], "end": [939, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_right_inj", "code": "@[simp] theorem replicate_right_inj {a b : \u03b1} {n : \u2115} (h : n \u2260 0) :\n    replicate n a = replicate n b \u2194 a = b", "start": [942, 1], "end": [944, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_left_injective", "code": "theorem replicate_left_injective (a : \u03b1) : Injective (replicate \u00b7 a)", "start": [947, 1], "end": [949, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_subset_singleton", "code": "theorem replicate_subset_singleton (n : \u2115) (a : \u03b1) : replicate n a \u2286 {a}", "start": [952, 1], "end": [953, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_le_coe", "code": "theorem replicate_le_coe {a : \u03b1} {n} {l : List \u03b1} : replicate n a \u2264 l \u2194 List.replicate n a <+ l", "start": [956, 1], "end": [957, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.nsmul_replicate", "code": "theorem nsmul_replicate {a : \u03b1} (n m : \u2115) : n \u2022 replicate m a = replicate (n * m) a", "start": [960, 1], "end": [961, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.nsmul_singleton", "code": "theorem nsmul_singleton (a : \u03b1) (n) : n \u2022 ({a} : Multiset \u03b1) = replicate n a", "start": [964, 1], "end": [965, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_le_replicate", "code": "theorem replicate_le_replicate (a : \u03b1) {k n : \u2115} : replicate k a \u2264 replicate n a \u2194 k \u2264 n", "start": [968, 1], "end": [969, 96], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_replicate_iff", "code": "theorem le_replicate_iff {m : Multiset \u03b1} {a : \u03b1} {n : \u2115} :\n    m \u2264 replicate n a \u2194 \u2203 k \u2264 n, m = replicate k a", "start": [972, 1], "end": [976, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.lt_replicate_succ", "code": "theorem lt_replicate_succ {m : Multiset \u03b1} {x : \u03b1} {n : \u2115} :\n    m < replicate (n + 1) x \u2194 m \u2264 replicate n x", "start": [979, 1], "end": [988, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase", "code": "def erase (s : Multiset \u03b1) (a : \u03b1) : Multiset \u03b1 :=\n  Quot.liftOn s (fun l => (l.erase a : Multiset \u03b1)) fun _l\u2081 _l\u2082 p => Quot.sound (p.erase a)", "start": [997, 1], "end": [999, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_erase", "code": "@[simp]\ntheorem coe_erase (l : List \u03b1) (a : \u03b1) : erase (l : Multiset \u03b1) a = l.erase a", "start": [1002, 1], "end": [1004, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_zero", "code": "@[simp, nolint simpNF] theorem erase_zero (a : \u03b1) : (0 : Multiset \u03b1).erase a = 0", "start": [1007, 1], "end": [1009, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_cons_head", "code": "@[simp]\ntheorem erase_cons_head (a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).erase a = s", "start": [1012, 1], "end": [1014, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_cons_tail", "code": "@[simp]\ntheorem erase_cons_tail {a b : \u03b1} (s : Multiset \u03b1) (h : b \u2260 a) :\n    (b ::\u2098 s).erase a = b ::\u2098 s.erase a", "start": [1017, 1], "end": [1020, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_singleton", "code": "@[simp]\ntheorem erase_singleton (a : \u03b1) : ({a} : Multiset \u03b1).erase a = 0", "start": [1023, 1], "end": [1025, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_of_not_mem", "code": "@[simp]\ntheorem erase_of_not_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2209 s \u2192 s.erase a = s", "start": [1028, 1], "end": [1030, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_erase", "code": "@[simp]\ntheorem cons_erase {s : Multiset \u03b1} {a : \u03b1} : a \u2208 s \u2192 a ::\u2098 s.erase a = s", "start": [1033, 1], "end": [1035, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_cons_erase", "code": "theorem le_cons_erase (s : Multiset \u03b1) (a : \u03b1) : s \u2264 a ::\u2098 s.erase a", "start": [1038, 1], "end": [1040, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_singleton_eq_iff", "code": "theorem add_singleton_eq_iff {s t : Multiset \u03b1} {a : \u03b1} : s + {a} = t \u2194 a \u2208 t \u2227 s = t.erase a", "start": [1043, 1], "end": [1048, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_add_left_pos", "code": "theorem erase_add_left_pos {a : \u03b1} {s : Multiset \u03b1} (t) : a \u2208 s \u2192 (s + t).erase a = s.erase a + t", "start": [1051, 1], "end": [1052, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_add_right_pos", "code": "theorem erase_add_right_pos {a : \u03b1} (s) {t : Multiset \u03b1} (h : a \u2208 t) :\n    (s + t).erase a = s + t.erase a", "start": [1055, 1], "end": [1056, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_add_right_neg", "code": "theorem erase_add_right_neg {a : \u03b1} {s : Multiset \u03b1} (t) :\n    a \u2209 s \u2192 (s + t).erase a = s + t.erase a", "start": [1059, 1], "end": [1061, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_add_left_neg", "code": "theorem erase_add_left_neg {a : \u03b1} (s) {t : Multiset \u03b1} (h : a \u2209 t) :\n    (s + t).erase a = s.erase a + t", "start": [1064, 1], "end": [1065, 91], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_le", "code": "theorem erase_le (a : \u03b1) (s : Multiset \u03b1) : s.erase a \u2264 s", "start": [1068, 1], "end": [1069, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_lt", "code": "@[simp]\ntheorem erase_lt {a : \u03b1} {s : Multiset \u03b1} : s.erase a < s \u2194 a \u2208 s", "start": [1072, 1], "end": [1075, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_subset", "code": "theorem erase_subset (a : \u03b1) (s : Multiset \u03b1) : s.erase a \u2286 s", "start": [1078, 1], "end": [1079, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_erase_of_ne", "code": "theorem mem_erase_of_ne {a b : \u03b1} {s : Multiset \u03b1} (ab : a \u2260 b) : a \u2208 s.erase b \u2194 a \u2208 s", "start": [1082, 1], "end": [1083, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_of_mem_erase", "code": "theorem mem_of_mem_erase {a b : \u03b1} {s : Multiset \u03b1} : a \u2208 s.erase b \u2192 a \u2208 s", "start": [1086, 1], "end": [1087, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_comm", "code": "theorem erase_comm (s : Multiset \u03b1) (a b : \u03b1) : (s.erase a).erase b = (s.erase b).erase a", "start": [1090, 1], "end": [1091, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_le_erase", "code": "theorem erase_le_erase {s t : Multiset \u03b1} (a : \u03b1) (h : s \u2264 t) : s.erase a \u2264 t.erase a", "start": [1094, 1], "end": [1095, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.erase_le_iff_le_cons", "code": "theorem erase_le_iff_le_cons {s t : Multiset \u03b1} {a : \u03b1} : s.erase a \u2264 t \u2194 s \u2264 a ::\u2098 t", "start": [1098, 1], "end": [1101, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_erase_of_mem", "code": "@[simp]\ntheorem card_erase_of_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 card (s.erase a) = pred (card s)", "start": [1104, 1], "end": [1106, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_erase_add_one", "code": "@[simp]\ntheorem card_erase_add_one {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 card (s.erase a) + 1 = card s", "start": [1109, 1], "end": [1111, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_erase_lt_of_mem", "code": "theorem card_erase_lt_of_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 card (s.erase a) < card s", "start": [1114, 1], "end": [1115, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_erase_le", "code": "theorem card_erase_le {a : \u03b1} {s : Multiset \u03b1} : card (s.erase a) \u2264 card s", "start": [1118, 1], "end": [1119, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_erase_eq_ite", "code": "theorem card_erase_eq_ite {a : \u03b1} {s : Multiset \u03b1} :\n    card (s.erase a) = if a \u2208 s then pred (card s) else card s", "start": [1122, 1], "end": [1126, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_reverse", "code": "@[simp]\ntheorem coe_reverse (l : List \u03b1) : (reverse l : Multiset \u03b1) = l", "start": [1131, 1], "end": [1133, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.map", "code": "def map (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) : Multiset \u03b2 :=\n  Quot.liftOn s (fun l : List \u03b1 => (l.map f : Multiset \u03b2)) fun _l\u2081 _l\u2082 p => Quot.sound (p.map f)", "start": [1139, 1], "end": [1143, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_congr", "code": "@[congr]\ntheorem map_congr {f g : \u03b1 \u2192 \u03b2} {s t : Multiset \u03b1} :\n    s = t \u2192 (\u2200 x \u2208 t, f x = g x) \u2192 map f s = map g t", "start": [1146, 1], "end": [1151, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_hcongr", "code": "theorem map_hcongr {\u03b2' : Type v} {m : Multiset \u03b1} {f : \u03b1 \u2192 \u03b2} {f' : \u03b1 \u2192 \u03b2'} (h : \u03b2 = \u03b2')\n    (hf : \u2200 a \u2208 m, HEq (f a) (f' a)) : HEq (map f m) (map f' m)", "start": [1154, 1], "end": [1157, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.forall_mem_map_iff", "code": "theorem forall_mem_map_iff {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} {s : Multiset \u03b1} :\n    (\u2200 y \u2208 s.map f, p y) \u2194 \u2200 x \u2208 s, p (f x)", "start": [1160, 1], "end": [1162, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_map", "code": "@[simp]\ntheorem coe_map (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map f \u2191l = l.map f", "start": [1165, 1], "end": [1167, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_zero", "code": "@[simp]\ntheorem map_zero (f : \u03b1 \u2192 \u03b2) : map f 0 = 0", "start": [1170, 1], "end": [1172, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_cons", "code": "@[simp]\ntheorem map_cons (f : \u03b1 \u2192 \u03b2) (a s) : map f (a ::\u2098 s) = f a ::\u2098 map f s", "start": [1175, 1], "end": [1177, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_comp_cons", "code": "theorem map_comp_cons (f : \u03b1 \u2192 \u03b2) (t) : map f \u2218 cons t = cons (f t) \u2218 map f", "start": [1180, 1], "end": [1182, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_singleton", "code": "@[simp]\ntheorem map_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : ({a} : Multiset \u03b1).map f = {f a}", "start": [1185, 1], "end": [1187, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_replicate", "code": "@[simp]\ntheorem map_replicate (f : \u03b1 \u2192 \u03b2) (k : \u2115) (a : \u03b1) : (replicate k a).map f = replicate k (f a)", "start": [1190, 1], "end": [1192, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_add", "code": "@[simp]\ntheorem map_add (f : \u03b1 \u2192 \u03b2) (s t) : map f (s + t) = map f s + map f t", "start": [1195, 1], "end": [1197, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.canLift", "code": "instance canLift (c) (p) [CanLift \u03b1 \u03b2 c p] :\n    CanLift (Multiset \u03b1) (Multiset \u03b2) (map c) fun s => \u2200 x \u2208 s, p x where\n  prf := by\n    rintro \u27e8l\u27e9 hl\n    lift l to List \u03b2 using hl\n    exact \u27e8l, coe_map _ _\u27e9", "start": [1200, 1], "end": [1207, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.mapAddMonoidHom", "code": "def mapAddMonoidHom (f : \u03b1 \u2192 \u03b2) : Multiset \u03b1 \u2192+ Multiset \u03b2 where\n  toFun := map f\n  map_zero' := map_zero _\n  map_add' := map_add _", "start": [1210, 1], "end": [1214, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_mapAddMonoidHom", "code": "@[simp]\ntheorem coe_mapAddMonoidHom (f : \u03b1 \u2192 \u03b2) :\n    (mapAddMonoidHom f : Multiset \u03b1 \u2192 Multiset \u03b2) = map f", "start": [1217, 1], "end": [1220, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_nsmul", "code": "theorem map_nsmul (f : \u03b1 \u2192 \u03b2) (n : \u2115) (s) : map f (n \u2022 s) = n \u2022 map f s", "start": [1223, 1], "end": [1224, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_map", "code": "@[simp]\ntheorem mem_map {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Multiset \u03b1} : b \u2208 map f s \u2194 \u2203 a, a \u2208 s \u2227 f a = b", "start": [1227, 1], "end": [1229, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_map", "code": "@[simp]\ntheorem card_map (f : \u03b1 \u2192 \u03b2) (s) : card (map f s) = card s", "start": [1232, 1], "end": [1234, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_eq_zero", "code": "@[simp]\ntheorem map_eq_zero {s : Multiset \u03b1} {f : \u03b1 \u2192 \u03b2} : s.map f = 0 \u2194 s = 0", "start": [1237, 1], "end": [1239, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_map_of_mem", "code": "theorem mem_map_of_mem (f : \u03b1 \u2192 \u03b2) {a : \u03b1} {s : Multiset \u03b1} (h : a \u2208 s) : f a \u2208 map f s", "start": [1242, 1], "end": [1243, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_eq_singleton", "code": "theorem map_eq_singleton {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} {b : \u03b2} :\n    map f s = {b} \u2194 \u2203 a : \u03b1, s = {a} \u2227 f a = b", "start": [1246, 1], "end": [1254, 9], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_eq_cons", "code": "theorem map_eq_cons [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2) (b : \u03b2) :\n    (\u2203 a \u2208 s, f a = b \u2227 (s.erase a).map f = t) \u2194 s.map f = b ::\u2098 t", "start": [1257, 1], "end": [1270, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_map_of_injective", "code": "@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : \u03b1 \u2192 \u03b2} (H : Function.Injective f) {a : \u03b1} {s : Multiset \u03b1} :\n    f a \u2208 map f s \u2194 a \u2208 s", "start": [1276, 1], "end": [1279, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) : map g (map f s) = map (g \u2218 f) s", "start": [1282, 1], "end": [1284, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_id", "code": "theorem map_id (s : Multiset \u03b1) : map id s = s", "start": [1287, 1], "end": [1288, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_id'", "code": "@[simp]\ntheorem map_id' (s : Multiset \u03b1) : map (fun x => x) s = s", "start": [1291, 1], "end": [1293, 11], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_const", "code": "theorem map_const (s : Multiset \u03b1) (b : \u03b2) : map (const \u03b1 b) s = replicate (card s) b", "start": [1297, 1], "end": [1298, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_const'", "code": "@[simp] theorem map_const' (s : Multiset \u03b1) (b : \u03b2) : map (fun _ \u21a6 b) s = replicate (card s) b", "start": [1302, 1], "end": [1303, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_of_mem_map_const", "code": "theorem eq_of_mem_map_const {b\u2081 b\u2082 : \u03b2} {l : List \u03b1} (h : b\u2081 \u2208 map (Function.const \u03b1 b\u2082) l) :\n    b\u2081 = b\u2082", "start": [1306, 1], "end": [1308, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_le_map", "code": "@[simp]\ntheorem map_le_map {f : \u03b1 \u2192 \u03b2} {s t : Multiset \u03b1} (h : s \u2264 t) : map f s \u2264 map f t", "start": [1311, 1], "end": [1313, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_lt_map", "code": "@[simp]\ntheorem map_lt_map {f : \u03b1 \u2192 \u03b2} {s t : Multiset \u03b1} (h : s < t) : s.map f < t.map f", "start": [1316, 1], "end": [1320, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_mono", "code": "theorem map_mono (f : \u03b1 \u2192 \u03b2) : Monotone (map f)", "start": [1323, 1], "end": [1323, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_strictMono", "code": "theorem map_strictMono (f : \u03b1 \u2192 \u03b2) : StrictMono (map f)", "start": [1326, 1], "end": [1326, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_subset_map", "code": "@[simp]\ntheorem map_subset_map {f : \u03b1 \u2192 \u03b2} {s t : Multiset \u03b1} (H : s \u2286 t) : map f s \u2286 map f t", "start": [1329, 1], "end": [1332, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_erase", "code": "theorem map_erase [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) (x : \u03b1)\n    (s : Multiset \u03b1) : (s.erase x).map f = (s.map f).erase (f x)", "start": [1335, 1], "end": [1342, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_surjective_of_surjective", "code": "theorem map_surjective_of_surjective {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) :\n    Function.Surjective (map f)", "start": [1345, 1], "end": [1352, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl", "code": "def foldl (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H : RightCommutative f) (b : \u03b2) (s : Multiset \u03b1) : \u03b2 :=\n  Quot.liftOn s (fun l => List.foldl f b l) fun _l\u2081 _l\u2082 p => p.foldl_eq H b", "start": [1358, 1], "end": [1362, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_zero", "code": "@[simp]\ntheorem foldl_zero (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H b) : foldl f H b 0 = b", "start": [1365, 1], "end": [1367, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_cons", "code": "@[simp]\ntheorem foldl_cons (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H b a s) : foldl f H b (a ::\u2098 s) = foldl f H (f b a) s", "start": [1370, 1], "end": [1372, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_add", "code": "@[simp]\ntheorem foldl_add (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H b s t) : foldl f H b (s + t) = foldl f H (foldl f H b s) t", "start": [1375, 1], "end": [1377, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr", "code": "def foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H : LeftCommutative f) (b : \u03b2) (s : Multiset \u03b1) : \u03b2 :=\n  Quot.liftOn s (fun l => List.foldr f b l) fun _l\u2081 _l\u2082 p => p.foldr_eq H b", "start": [1380, 1], "end": [1384, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_zero", "code": "@[simp]\ntheorem foldr_zero (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b) : foldr f H b 0 = b", "start": [1387, 1], "end": [1389, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_cons", "code": "@[simp]\ntheorem foldr_cons (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b a s) : foldr f H b (a ::\u2098 s) = f a (foldr f H b s)", "start": [1392, 1], "end": [1394, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_singleton", "code": "@[simp]\ntheorem foldr_singleton (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b a) : foldr f H b ({a} : Multiset \u03b1) = f a b", "start": [1397, 1], "end": [1399, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_add", "code": "@[simp]\ntheorem foldr_add (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b s t) : foldr f H b (s + t) = foldr f H (foldr f H b t) s", "start": [1402, 1], "end": [1404, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_foldr", "code": "@[simp]\ntheorem coe_foldr (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H : LeftCommutative f) (b : \u03b2) (l : List \u03b1) :\n    foldr f H b l = l.foldr f b", "start": [1407, 1], "end": [1410, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_foldl", "code": "@[simp]\ntheorem coe_foldl (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H : RightCommutative f) (b : \u03b2) (l : List \u03b1) :\n    foldl f H b l = l.foldl f b", "start": [1413, 1], "end": [1416, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_foldr_swap", "code": "theorem coe_foldr_swap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H : LeftCommutative f) (b : \u03b2) (l : List \u03b1) :\n    foldr f H b l = l.foldl (fun x y => f y x) b", "start": [1419, 1], "end": [1421, 78], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_swap", "code": "theorem foldr_swap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H : LeftCommutative f) (b : \u03b2) (s : Multiset \u03b1) :\n    foldr f H b s = foldl (fun x y => f y x) (fun _x _y _z => (H _ _ _).symm) b s", "start": [1424, 1], "end": [1426, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_swap", "code": "theorem foldl_swap (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H : RightCommutative f) (b : \u03b2) (s : Multiset \u03b1) :\n    foldl f H b s = foldr (fun x y => f y x) (fun _x _y _z => (H _ _ _).symm) b s", "start": [1429, 1], "end": [1431, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_induction'", "code": "theorem foldr_induction' (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H : LeftCommutative f) (x : \u03b2) (q : \u03b1 \u2192 Prop)\n    (p : \u03b2 \u2192 Prop) (s : Multiset \u03b1) (hpqf : \u2200 a b, q a \u2192 p b \u2192 p (f a b)) (px : p x)\n    (q_s : \u2200 a \u2208 s, q a) : p (foldr f H x s)", "start": [1434, 1], "end": [1442, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldr_induction", "code": "theorem foldr_induction (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (H : LeftCommutative f) (x : \u03b1) (p : \u03b1 \u2192 Prop)\n    (s : Multiset \u03b1) (p_f : \u2200 a b, p a \u2192 p b \u2192 p (f a b)) (px : p x) (p_s : \u2200 a \u2208 s, p a) :\n    p (foldr f H x s)", "start": [1445, 1], "end": [1448, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_induction'", "code": "theorem foldl_induction' (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (H : RightCommutative f) (x : \u03b2) (q : \u03b1 \u2192 Prop)\n    (p : \u03b2 \u2192 Prop) (s : Multiset \u03b1) (hpqf : \u2200 a b, q a \u2192 p b \u2192 p (f b a)) (px : p x)\n    (q_s : \u2200 a \u2208 s, q a) : p (foldl f H x s)", "start": [1451, 1], "end": [1455, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.foldl_induction", "code": "theorem foldl_induction (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (H : RightCommutative f) (x : \u03b1) (p : \u03b1 \u2192 Prop)\n    (s : Multiset \u03b1) (p_f : \u2200 a b, p a \u2192 p b \u2192 p (f b a)) (px : p x) (p_s : \u2200 a \u2208 s, p a) :\n    p (foldl f H x s)", "start": [1458, 1], "end": [1461, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap", "code": "nonrec def pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (s : Multiset \u03b1) : (\u2200 a \u2208 s, p a) \u2192 Multiset \u03b2 :=\n  Quot.recOn' s (fun l H => \u2191(pmap f l H)) fun l\u2081 l\u2082 (pp : l\u2081 ~ l\u2082) =>\n    funext fun H\u2082 : \u2200 a \u2208 l\u2082, p a =>\n      have H\u2081 : \u2200 a \u2208 l\u2081, p a := fun a h => H\u2082 a (pp.subset h)\n      have : \u2200 {s\u2082 e H}, @Eq.ndrec (Multiset \u03b1) l\u2081 (fun s => (\u2200 a \u2208 s, p a) \u2192 Multiset \u03b2)\n          (fun _ => \u2191(pmap f l\u2081 H\u2081)) s\u2082 e H = \u2191(pmap f l\u2081 H\u2081) := by\n        intro s\u2082 e _; subst e; rfl\n      this.trans <| Quot.sound <| pp.pmap f", "start": [1467, 1], "end": [1476, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_pmap", "code": "@[simp]\ntheorem coe_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (l : List \u03b1) (H : \u2200 a \u2208 l, p a) :\n    pmap f l H = l.pmap f H", "start": [1479, 1], "end": [1482, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap_zero", "code": "@[simp]\ntheorem pmap_zero {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (h : \u2200 a \u2208 (0 : Multiset \u03b1), p a) :\n    pmap f 0 h = 0", "start": [1485, 1], "end": [1488, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap_cons", "code": "@[simp]\ntheorem pmap_cons {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (a : \u03b1) (m : Multiset \u03b1) :\n    \u2200 h : \u2200 b \u2208 a ::\u2098 m, p b,\n      pmap f (a ::\u2098 m) h =\n        f a (h a (mem_cons_self a m)) ::\u2098 pmap f m fun a ha => h a <| mem_cons_of_mem ha", "start": [1491, 1], "end": [1496, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach", "code": "def attach (s : Multiset \u03b1) : Multiset { x // x \u2208 s } :=\n  pmap Subtype.mk s fun _a => id", "start": [1499, 1], "end": [1502, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_attach", "code": "@[simp]\ntheorem coe_attach (l : List \u03b1) : @Eq (Multiset { x // x \u2208 l }) (@attach \u03b1 l) l.attach", "start": [1505, 1], "end": [1507, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.sizeOf_lt_sizeOf_of_mem", "code": "theorem sizeOf_lt_sizeOf_of_mem [SizeOf \u03b1] {x : \u03b1} {s : Multiset \u03b1} (hx : x \u2208 s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s", "start": [1510, 1], "end": [1513, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap_eq_map", "code": "theorem pmap_eq_map (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) :\n    \u2200 H, @pmap _ _ p (fun a _ => f a) s H = map f s", "start": [1516, 1], "end": [1518, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap_congr", "code": "theorem pmap_congr {p q : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {g : \u2200 a, q a \u2192 \u03b2} (s : Multiset \u03b1) :\n    \u2200 {H\u2081 H\u2082}, (\u2200 a \u2208 s, \u2200 (h\u2081 h\u2082), f a h\u2081 = g a h\u2082) \u2192 pmap f s H\u2081 = pmap g s H\u2082", "start": [1521, 1], "end": [1523, 80], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_pmap", "code": "theorem map_pmap {p : \u03b1 \u2192 Prop} (g : \u03b2 \u2192 \u03b3) (f : \u2200 a, p a \u2192 \u03b2) (s) :\n    \u2200 H, map g (pmap f s H) = pmap (fun a h => g (f a h)) s H", "start": [1527, 1], "end": [1529, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.pmap_eq_map_attach", "code": "theorem pmap_eq_map_attach {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (s) :\n    \u2200 H, pmap f s H = s.attach.map fun x => f x.1 (H _ x.2)", "start": [1532, 1], "end": [1534, 77], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_map_val'", "code": "theorem attach_map_val' (s : Multiset \u03b1) (f : \u03b1 \u2192 \u03b2) : (s.attach.map fun i => f i.val) = s.map f", "start": [1538, 1], "end": [1539, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_map_val", "code": "@[simp]\ntheorem attach_map_val (s : Multiset \u03b1) : s.attach.map Subtype.val = s", "start": [1543, 1], "end": [1545, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_attach", "code": "@[simp]\ntheorem mem_attach (s : Multiset \u03b1) : \u2200 x, x \u2208 s.attach", "start": [1549, 1], "end": [1551, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_pmap", "code": "@[simp]\ntheorem mem_pmap {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {s H b} :\n    b \u2208 pmap f s H \u2194 \u2203 (a : _) (h : a \u2208 s), f a (H a h) = b", "start": [1554, 1], "end": [1557, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_pmap", "code": "@[simp]\ntheorem card_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (s H) : card (pmap f s H) = card s", "start": [1560, 1], "end": [1562, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_attach", "code": "@[simp]\ntheorem card_attach {m : Multiset \u03b1} : card (attach m) = card m", "start": [1565, 1], "end": [1567, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_zero", "code": "@[simp]\ntheorem attach_zero : (0 : Multiset \u03b1).attach = 0", "start": [1570, 1], "end": [1572, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_cons", "code": "theorem attach_cons (a : \u03b1) (m : Multiset \u03b1) :\n    (a ::\u2098 m).attach =\n      \u27e8a, mem_cons_self a m\u27e9 ::\u2098 m.attach.map fun p => \u27e8p.1, mem_cons_of_mem p.2\u27e9", "start": [1575, 1], "end": [1581, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableForallMultiset", "code": "protected def decidableForallMultiset {p : \u03b1 \u2192 Prop} [hp : \u2200 a, Decidable (p a)] :\n    Decidable (\u2200 a \u2208 m, p a) :=\n  Quotient.recOnSubsingleton m fun l => decidable_of_iff (\u2200 a \u2208 l, p a) <| by simp", "start": [1588, 1], "end": [1592, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableDforallMultiset", "code": "instance decidableDforallMultiset {p : \u2200 a \u2208 m, Prop} [_hp : \u2200 (a) (h : a \u2208 m), Decidable (p a h)] :\n    Decidable (\u2200 (a) (h : a \u2208 m), p a h) :=\n  @decidable_of_iff _ _\n    (Iff.intro (fun h a ha => h \u27e8a, ha\u27e9 (mem_attach _ _)) fun h \u27e8_a, _ha\u27e9 _ => h _ _)\n    (@Multiset.decidableForallMultiset _ m.attach (fun a => p a.1 a.2) _)", "start": [1595, 1], "end": [1599, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableEqPiMultiset", "code": "instance decidableEqPiMultiset {\u03b2 : \u03b1 \u2192 Type*} [h : \u2200 a, DecidableEq (\u03b2 a)] :\n    DecidableEq (\u2200 a \u2208 m, \u03b2 a) := fun f g =>\n  decidable_of_iff (\u2200 (a) (h : a \u2208 m), f a h = g a h) (by simp [Function.funext_iff])", "start": [1602, 1], "end": [1605, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableExistsMultiset", "code": "protected def decidableExistsMultiset {p : \u03b1 \u2192 Prop} [DecidablePred p] : Decidable (\u2203 x \u2208 m, p x) :=\n  Quotient.recOnSubsingleton m fun l => decidable_of_iff (\u2203 a \u2208 l, p a) <| by simp", "start": [1608, 1], "end": [1611, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.decidableDexistsMultiset", "code": "instance decidableDexistsMultiset {p : \u2200 a \u2208 m, Prop} [_hp : \u2200 (a) (h : a \u2208 m), Decidable (p a h)] :\n    Decidable (\u2203 (a : _) (h : a \u2208 m), p a h) :=\n  @decidable_of_iff _ _\n    (Iff.intro (fun \u27e8\u27e8a, ha\u2081\u27e9, _, ha\u2082\u27e9 => \u27e8a, ha\u2081, ha\u2082\u27e9) fun \u27e8a, ha\u2081, ha\u2082\u27e9 =>\n      \u27e8\u27e8a, ha\u2081\u27e9, mem_attach _ _, ha\u2082\u27e9)\n    (@Multiset.decidableExistsMultiset { a // a \u2208 m } m.attach (fun a => p a.1 a.2) _)", "start": [1614, 1], "end": [1619, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub", "code": "protected def sub (s t : Multiset \u03b1) : Multiset \u03b1 :=\n  (Quotient.liftOn\u2082 s t fun l\u2081 l\u2082 => (l\u2081.diff l\u2082 : Multiset \u03b1)) fun _v\u2081 _v\u2082 _w\u2081 _w\u2082 p\u2081 p\u2082 =>\n    Quot.sound <| p\u2081.diff p\u2082", "start": [1631, 1], "end": [1635, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_sub", "code": "@[simp]\ntheorem coe_sub (s t : List \u03b1) : (s - t : Multiset \u03b1) = (s.diff t : List \u03b1)", "start": [1641, 1], "end": [1643, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_zero", "code": "protected theorem sub_zero (s : Multiset \u03b1) : s - 0 = s", "start": [1646, 1], "end": [1649, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_cons", "code": "@[simp]\ntheorem sub_cons (a : \u03b1) (s t : Multiset \u03b1) : s - a ::\u2098 t = s.erase a - t", "start": [1652, 1], "end": [1654, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_le_iff_le_add", "code": "protected theorem sub_le_iff_le_add : s - t \u2264 u \u2194 s \u2264 u + t", "start": [1657, 1], "end": [1662, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_sub_of_le", "code": "theorem cons_sub_of_le (a : \u03b1) {s t : Multiset \u03b1} (h : t \u2264 s) : a ::\u2098 s - t = a ::\u2098 (s - t)", "start": [1668, 1], "end": [1669, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_eq_fold_erase", "code": "theorem sub_eq_fold_erase (s t : Multiset \u03b1) : s - t = foldl erase erase_comm s t", "start": [1672, 1], "end": [1677, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_sub", "code": "@[simp]\ntheorem card_sub {s t : Multiset \u03b1} (h : t \u2264 s) : card (s - t) = card s - card t", "start": [1680, 1], "end": [1682, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.union", "code": "def union (s t : Multiset \u03b1) : Multiset \u03b1 :=\n  s - t + t", "start": [1688, 1], "end": [1692, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_def", "code": "theorem union_def (s t : Multiset \u03b1) : s \u222a t = s - t + t", "start": [1698, 1], "end": [1699, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_union_left", "code": "theorem le_union_left (s t : Multiset \u03b1) : s \u2264 s \u222a t", "start": [1702, 1], "end": [1703, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_union_right", "code": "theorem le_union_right (s t : Multiset \u03b1) : t \u2264 s \u222a t", "start": [1706, 1], "end": [1707, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_union_left", "code": "theorem eq_union_left : t \u2264 s \u2192 s \u222a t = s", "start": [1710, 1], "end": [1711, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_le_union_right", "code": "theorem union_le_union_right (h : s \u2264 t) (u) : s \u222a u \u2264 t \u222a u", "start": [1714, 1], "end": [1715, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_le", "code": "theorem union_le (h\u2081 : s \u2264 u) (h\u2082 : t \u2264 u) : s \u222a t \u2264 u", "start": [1718, 1], "end": [1719, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_union", "code": "@[simp]\ntheorem mem_union : a \u2208 s \u222a t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [1722, 1], "end": [1725, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_union", "code": "@[simp]\ntheorem map_union [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (finj : Function.Injective f) {s t : Multiset \u03b1} :\n    map f (s \u222a t) = map f s \u222a map f t", "start": [1728, 1], "end": [1732, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_union", "code": "@[simp] theorem zero_union : 0 \u222a s = s", "start": [1736, 1], "end": [1737, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_zero", "code": "@[simp] theorem union_zero : s \u222a 0 = s", "start": [1740, 1], "end": [1741, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter", "code": "def inter (s t : Multiset \u03b1) : Multiset \u03b1 :=\n  Quotient.liftOn\u2082 s t (fun l\u2081 l\u2082 => (l\u2081.bagInter l\u2082 : Multiset \u03b1)) fun _v\u2081 _v\u2082 _w\u2081 _w\u2082 p\u2081 p\u2082 =>\n    Quot.sound <| p\u2081.bagInter p\u2082", "start": [1745, 1], "end": [1750, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_zero", "code": "@[simp]\ntheorem inter_zero (s : Multiset \u03b1) : s \u2229 0 = 0", "start": [1756, 1], "end": [1758, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_inter", "code": "@[simp]\ntheorem zero_inter (s : Multiset \u03b1) : 0 \u2229 s = 0", "start": [1761, 1], "end": [1763, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_inter_of_pos", "code": "@[simp]\ntheorem cons_inter_of_pos {a} (s : Multiset \u03b1) {t} : a \u2208 t \u2192 (a ::\u2098 s) \u2229 t = a ::\u2098 s \u2229 t.erase a", "start": [1766, 1], "end": [1768, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_inter_of_neg", "code": "@[simp]\ntheorem cons_inter_of_neg {a} (s : Multiset \u03b1) {t} : a \u2209 t \u2192 (a ::\u2098 s) \u2229 t = s \u2229 t", "start": [1771, 1], "end": [1773, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_le_left", "code": "theorem inter_le_left (s t : Multiset \u03b1) : s \u2229 t \u2264 s", "start": [1776, 1], "end": [1777, 79], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_le_right", "code": "theorem inter_le_right (s : Multiset \u03b1) : \u2200 t, s \u2229 t \u2264 t", "start": [1780, 1], "end": [1782, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_inter", "code": "theorem le_inter (h\u2081 : s \u2264 t) (h\u2082 : s \u2264 u) : s \u2264 t \u2229 u", "start": [1785, 1], "end": [1792, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_inter", "code": "@[simp]\ntheorem mem_inter : a \u2208 s \u2229 t \u2194 a \u2208 s \u2227 a \u2208 t", "start": [1795, 1], "end": [1798, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_eq_union", "code": "@[simp]\ntheorem sup_eq_union (s t : Multiset \u03b1) : s \u2294 t = s \u222a t", "start": [1811, 1], "end": [1813, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_eq_inter", "code": "@[simp]\ntheorem inf_eq_inter (s t : Multiset \u03b1) : s \u2293 t = s \u2229 t", "start": [1816, 1], "end": [1818, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_inter_iff", "code": "@[simp]\ntheorem le_inter_iff : s \u2264 t \u2229 u \u2194 s \u2264 t \u2227 s \u2264 u", "start": [1821, 1], "end": [1823, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_le_iff", "code": "@[simp]\ntheorem union_le_iff : s \u222a t \u2264 u \u2194 s \u2264 u \u2227 t \u2264 u", "start": [1826, 1], "end": [1828, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_comm", "code": "theorem union_comm (s t : Multiset \u03b1) : s \u222a t = t \u222a s", "start": [1831, 1], "end": [1832, 11], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_comm", "code": "theorem inter_comm (s t : Multiset \u03b1) : s \u2229 t = t \u2229 s", "start": [1835, 1], "end": [1836, 11], "kind": "commanddeclaration"}, {"full_name": "Multiset.eq_union_right", "code": "theorem eq_union_right (h : s \u2264 t) : s \u222a t = t", "start": [1839, 1], "end": [1839, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_le_union_left", "code": "theorem union_le_union_left (h : s \u2264 t) (u) : u \u222a s \u2264 u \u222a t", "start": [1842, 1], "end": [1843, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_le_add", "code": "theorem union_le_add (s t : Multiset \u03b1) : s \u222a t \u2264 s + t", "start": [1846, 1], "end": [1847, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_add_distrib", "code": "theorem union_add_distrib (s t u : Multiset \u03b1) : s \u222a t + u = s + u \u222a (t + u)", "start": [1850, 1], "end": [1852, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_union_distrib", "code": "theorem add_union_distrib (s t u : Multiset \u03b1) : s + (t \u222a u) = s + t \u222a (s + u)", "start": [1855, 1], "end": [1856, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_union_distrib", "code": "theorem cons_union_distrib (a : \u03b1) (s t : Multiset \u03b1) : a ::\u2098 (s \u222a t) = a ::\u2098 s \u222a a ::\u2098 t", "start": [1859, 1], "end": [1860, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_add_distrib", "code": "theorem inter_add_distrib (s t u : Multiset \u03b1) : s \u2229 t + u = (s + u) \u2229 (t + u)", "start": [1863, 1], "end": [1876, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_inter_distrib", "code": "theorem add_inter_distrib (s t u : Multiset \u03b1) : s + t \u2229 u = (s + t) \u2229 (s + u)", "start": [1879, 1], "end": [1880, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_inter_distrib", "code": "theorem cons_inter_distrib (a : \u03b1) (s t : Multiset \u03b1) : a ::\u2098 s \u2229 t = (a ::\u2098 s) \u2229 (a ::\u2098 t)", "start": [1883, 1], "end": [1884, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.union_add_inter", "code": "theorem union_add_inter (s t : Multiset \u03b1) : s \u222a t + s \u2229 t = s + t", "start": [1887, 1], "end": [1896, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_add_inter", "code": "theorem sub_add_inter (s t : Multiset \u03b1) : s - t + s \u2229 t = s", "start": [1899, 1], "end": [1904, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.sub_inter", "code": "theorem sub_inter (s t : Multiset \u03b1) : s - s \u2229 t = s - t", "start": [1907, 1], "end": [1908, 91], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter", "code": "def filter (s : Multiset \u03b1) : Multiset \u03b1 :=\n  Quot.liftOn s (fun l => (List.filter p l : Multiset \u03b1)) fun _l\u2081 _l\u2082 h => Quot.sound <| h.filter p", "start": [1920, 1], "end": [1923, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_filter", "code": "@[simp]\ntheorem coe_filter (l : List \u03b1) : filter p \u2191l = l.filter p", "start": [1926, 1], "end": [1928, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_zero", "code": "@[simp]\ntheorem filter_zero : filter p 0 = 0", "start": [1931, 1], "end": [1933, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_congr", "code": "theorem filter_congr {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q] {s : Multiset \u03b1} :\n    (\u2200 x \u2208 s, p x \u2194 q x) \u2192 filter p s = filter q s", "start": [1936, 1], "end": [1938, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_add", "code": "@[simp]\ntheorem filter_add (s t : Multiset \u03b1) : filter p (s + t) = filter p s + filter p t", "start": [1941, 1], "end": [1943, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_le", "code": "@[simp]\ntheorem filter_le (s : Multiset \u03b1) : filter p s \u2264 s", "start": [1946, 1], "end": [1948, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_subset", "code": "@[simp]\ntheorem filter_subset (s : Multiset \u03b1) : filter p s \u2286 s", "start": [1951, 1], "end": [1953, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_le_filter", "code": "theorem filter_le_filter {s t} (h : s \u2264 t) : filter p s \u2264 filter p t", "start": [1956, 1], "end": [1957, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.monotone_filter_left", "code": "theorem monotone_filter_left : Monotone (filter p)", "start": [1960, 1], "end": [1960, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.monotone_filter_right", "code": "theorem monotone_filter_right (s : Multiset \u03b1) \u2983p q : \u03b1 \u2192 Prop\u2984 [DecidablePred p] [DecidablePred q]\n    (h : \u2200 b, p b \u2192 q b) :\n    s.filter p \u2264 s.filter q", "start": [1963, 1], "end": [1966, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_cons_of_pos", "code": "@[simp]\ntheorem filter_cons_of_pos {a : \u03b1} (s) : p a \u2192 filter p (a ::\u2098 s) = a ::\u2098 filter p s", "start": [1971, 1], "end": [1973, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_cons_of_neg", "code": "@[simp]\ntheorem filter_cons_of_neg {a : \u03b1} (s) : \u00acp a \u2192 filter p (a ::\u2098 s) = filter p s", "start": [1976, 1], "end": [1978, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_filter", "code": "@[simp]\ntheorem mem_filter {a : \u03b1} {s} : a \u2208 filter p s \u2194 a \u2208 s \u2227 p a", "start": [1981, 1], "end": [1983, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.of_mem_filter", "code": "theorem of_mem_filter {a : \u03b1} {s} (h : a \u2208 filter p s) : p a", "start": [1986, 1], "end": [1987, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_of_mem_filter", "code": "theorem mem_of_mem_filter {a : \u03b1} {s} (h : a \u2208 filter p s) : a \u2208 s", "start": [1990, 1], "end": [1991, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_filter_of_mem", "code": "theorem mem_filter_of_mem {a : \u03b1} {l} (m : a \u2208 l) (h : p a) : a \u2208 filter p l", "start": [1994, 1], "end": [1995, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_eq_self", "code": "theorem filter_eq_self {s} : filter p s = s \u2194 \u2200 a \u2208 s, p a", "start": [1998, 1], "end": [2002, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_eq_nil", "code": "theorem filter_eq_nil {s} : filter p s = 0 \u2194 \u2200 a \u2208 s, \u00acp a", "start": [2005, 1], "end": [2008, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_filter", "code": "theorem le_filter {s t} : s \u2264 filter p t \u2194 s \u2264 t \u2227 \u2200 a \u2208 s, p a", "start": [2011, 1], "end": [2013, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_cons", "code": "theorem filter_cons {a : \u03b1} (s : Multiset \u03b1) :\n    filter p (a ::\u2098 s) = (if p a then {a} else 0) + filter p s", "start": [2016, 1], "end": [2020, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_singleton", "code": "theorem filter_singleton {a : \u03b1} (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    filter p {a} = if p a then {a} else \u2205", "start": [2023, 1], "end": [2025, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_nsmul", "code": "theorem filter_nsmul (s : Multiset \u03b1) (n : \u2115) : filter p (n \u2022 s) = n \u2022 filter p s", "start": [2028, 1], "end": [2037, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_sub", "code": "@[simp]\ntheorem filter_sub [DecidableEq \u03b1] (s t : Multiset \u03b1) :\n    filter p (s - t) = filter p s - filter p t", "start": [2042, 1], "end": [2058, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_union", "code": "@[simp]\ntheorem filter_union [DecidableEq \u03b1] (s t : Multiset \u03b1) :\n    filter p (s \u222a t) = filter p s \u222a filter p t", "start": [2061, 1], "end": [2063, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_inter", "code": "@[simp]\ntheorem filter_inter [DecidableEq \u03b1] (s t : Multiset \u03b1) :\n    filter p (s \u2229 t) = filter p s \u2229 filter p t", "start": [2066, 1], "end": [2074, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_filter", "code": "@[simp]\ntheorem filter_filter (q) [DecidablePred q] (s : Multiset \u03b1) :\n    filter p (filter q s) = filter (fun a => p a \u2227 q a) s", "start": [2077, 1], "end": [2080, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_add_filter", "code": "theorem filter_add_filter (q) [DecidablePred q] (s : Multiset \u03b1) :\n    filter p s + filter q s = filter (fun a => p a \u2228 q a) s + filter (fun a => p a \u2227 q a) s", "start": [2083, 1], "end": [2085, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_add_not", "code": "theorem filter_add_not (s : Multiset \u03b1) : filter p s + filter (fun a => \u00acp a) s = s", "start": [2088, 1], "end": [2093, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_filter", "code": "theorem map_filter (f : \u03b2 \u2192 \u03b1) (s : Multiset \u03b2) : filter p (map f s) = map f (filter (p \u2218 f) s)", "start": [2096, 1], "end": [2097, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap", "code": "def filterMap (f : \u03b1 \u2192 Option \u03b2) (s : Multiset \u03b1) : Multiset \u03b2 :=\n  Quot.liftOn s (fun l => (List.filterMap f l : Multiset \u03b2))\n    fun _l\u2081 _l\u2082 h => Quot.sound <| h.filterMap f", "start": [2103, 1], "end": [2109, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_filterMap", "code": "@[simp]\ntheorem coe_filterMap (f : \u03b1 \u2192 Option \u03b2) (l : List \u03b1) : filterMap f l = l.filterMap f", "start": [2112, 1], "end": [2114, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_zero", "code": "@[simp]\ntheorem filterMap_zero (f : \u03b1 \u2192 Option \u03b2) : filterMap f 0 = 0", "start": [2117, 1], "end": [2119, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_cons_none", "code": "@[simp]\ntheorem filterMap_cons_none {f : \u03b1 \u2192 Option \u03b2} (a : \u03b1) (s : Multiset \u03b1) (h : f a = none) :\n    filterMap f (a ::\u2098 s) = filterMap f s", "start": [2122, 1], "end": [2125, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_cons_some", "code": "@[simp]\ntheorem filterMap_cons_some (f : \u03b1 \u2192 Option \u03b2) (a : \u03b1) (s : Multiset \u03b1) {b : \u03b2}\n    (h : f a = some b) : filterMap f (a ::\u2098 s) = b ::\u2098 filterMap f s", "start": [2128, 1], "end": [2131, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_eq_map", "code": "theorem filterMap_eq_map (f : \u03b1 \u2192 \u03b2) : filterMap (some \u2218 f) = map f", "start": [2134, 1], "end": [2136, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_eq_filter", "code": "theorem filterMap_eq_filter : filterMap (Option.guard p) = filter p", "start": [2139, 1], "end": [2143, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_filterMap", "code": "theorem filterMap_filterMap (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 Option \u03b3) (s : Multiset \u03b1) :\n    filterMap g (filterMap f s) = filterMap (fun x => (f x).bind g) s", "start": [2146, 1], "end": [2148, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_filterMap", "code": "theorem map_filterMap (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 \u03b3) (s : Multiset \u03b1) :\n    map g (filterMap f s) = filterMap (fun x => (f x).map g) s", "start": [2151, 1], "end": [2153, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_map", "code": "theorem filterMap_map (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 Option \u03b3) (s : Multiset \u03b1) :\n    filterMap g (map f s) = filterMap (g \u2218 f) s", "start": [2156, 1], "end": [2158, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_filterMap", "code": "theorem filter_filterMap (f : \u03b1 \u2192 Option \u03b2) (p : \u03b2 \u2192 Prop) [DecidablePred p] (s : Multiset \u03b1) :\n    filter p (filterMap f s) = filterMap (fun x => (f x).filter p) s", "start": [2161, 1], "end": [2163, 78], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_filter", "code": "theorem filterMap_filter (f : \u03b1 \u2192 Option \u03b2) (s : Multiset \u03b1) :\n    filterMap f (filter p s) = filterMap (fun x => if p x then f x else none) s", "start": [2166, 1], "end": [2168, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_some", "code": "@[simp]\ntheorem filterMap_some (s : Multiset \u03b1) : filterMap some s = s", "start": [2171, 1], "end": [2173, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_filterMap", "code": "@[simp]\ntheorem mem_filterMap (f : \u03b1 \u2192 Option \u03b2) (s : Multiset \u03b1) {b : \u03b2} :\n    b \u2208 filterMap f s \u2194 \u2203 a, a \u2208 s \u2227 f a = some b", "start": [2176, 1], "end": [2179, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_filterMap_of_inv", "code": "theorem map_filterMap_of_inv (f : \u03b1 \u2192 Option \u03b2) (g : \u03b2 \u2192 \u03b1) (H : \u2200 x : \u03b1, (f x).map g = some x)\n    (s : Multiset \u03b1) : map g (filterMap f s) = s", "start": [2182, 1], "end": [2184, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.filterMap_le_filterMap", "code": "theorem filterMap_le_filterMap (f : \u03b1 \u2192 Option \u03b2) {s t : Multiset \u03b1} (h : s \u2264 t) :\n    filterMap f s \u2264 filterMap f t", "start": [2187, 1], "end": [2189, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP", "code": "def countP (s : Multiset \u03b1) : \u2115 :=\n  Quot.liftOn s (List.countP p) fun _l\u2081 _l\u2082 => Perm.countP_eq (p \u00b7)", "start": [2195, 1], "end": [2198, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_countP", "code": "@[simp]\ntheorem coe_countP (l : List \u03b1) : countP p l = l.countP p", "start": [2201, 1], "end": [2203, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_zero", "code": "@[simp]\ntheorem countP_zero : countP p 0 = 0", "start": [2206, 1], "end": [2208, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_cons_of_pos", "code": "@[simp]\ntheorem countP_cons_of_pos {a : \u03b1} (s) : p a \u2192 countP p (a ::\u2098 s) = countP p s + 1", "start": [2213, 1], "end": [2215, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_cons_of_neg", "code": "@[simp]\ntheorem countP_cons_of_neg {a : \u03b1} (s) : \u00acp a \u2192 countP p (a ::\u2098 s) = countP p s", "start": [2218, 1], "end": [2220, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_cons", "code": "theorem countP_cons (b : \u03b1) (s) : countP p (b ::\u2098 s) = countP p s + if p b then 1 else 0", "start": [2225, 1], "end": [2226, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_eq_card_filter", "code": "theorem countP_eq_card_filter (s) : countP p s = card (filter p s)", "start": [2229, 1], "end": [2230, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_le_card", "code": "theorem countP_le_card (s) : countP p s \u2264 card s", "start": [2233, 1], "end": [2234, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_add", "code": "@[simp]\ntheorem countP_add (s t) : countP p (s + t) = countP p s + countP p t", "start": [2237, 1], "end": [2239, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_nsmul", "code": "@[simp]\ntheorem countP_nsmul (s) (n : \u2115) : countP p (n \u2022 s) = n * countP p s", "start": [2242, 1], "end": [2244, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_countP_add_countP", "code": "theorem card_eq_countP_add_countP (s) : card s = countP p s + countP (fun x => \u00acp x) s", "start": [2247, 1], "end": [2248, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.countPAddMonoidHom", "code": "def countPAddMonoidHom : Multiset \u03b1 \u2192+ \u2115 where\n  toFun := countP p\n  map_zero' := countP_zero _\n  map_add' := countP_add _", "start": [2251, 1], "end": [2256, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_countPAddMonoidHom", "code": "@[simp]\ntheorem coe_countPAddMonoidHom : (countPAddMonoidHom p : Multiset \u03b1 \u2192 \u2115) = countP p", "start": [2259, 1], "end": [2261, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_sub", "code": "@[simp]\ntheorem countP_sub [DecidableEq \u03b1] {s t : Multiset \u03b1} (h : t \u2264 s) :\n    countP p (s - t) = countP p s - countP p t", "start": [2264, 1], "end": [2267, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_le_of_le", "code": "theorem countP_le_of_le {s t} (h : s \u2264 t) : countP p s \u2264 countP p t", "start": [2270, 1], "end": [2271, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_filter", "code": "@[simp]\ntheorem countP_filter (q) [DecidablePred q] (s : Multiset \u03b1) :\n    countP p (filter q s) = countP (fun a => p a \u2227 q a) s", "start": [2274, 1], "end": [2276, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_eq_countP_filter_add", "code": "theorem countP_eq_countP_filter_add (s) (p q : \u03b1 \u2192 Prop) [DecidablePred p] [DecidablePred q] :\n    countP p s = (filter q s).countP p + (filter (fun a => \u00acq a) s).countP p", "start": [2279, 1], "end": [2283, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_True", "code": "@[simp]\ntheorem countP_True {s : Multiset \u03b1} : countP (fun _ => True) s = card s", "start": [2286, 1], "end": [2288, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_False", "code": "@[simp]\ntheorem countP_False {s : Multiset \u03b1} : countP (fun _ => False) s = 0", "start": [2291, 1], "end": [2293, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_map", "code": "theorem countP_map (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) (p : \u03b2 \u2192 Prop) [DecidablePred p] :\n    countP p (map f s) = card (s.filter fun a => p (f a))", "start": [2296, 1], "end": [2301, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_pos", "code": "theorem countP_pos {s} : 0 < countP p s \u2194 \u2203 a \u2208 s, p a", "start": [2306, 1], "end": [2307, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_eq_zero", "code": "theorem countP_eq_zero {s} : countP p s = 0 \u2194 \u2200 a \u2208 s, \u00acp a", "start": [2310, 1], "end": [2311, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_eq_card", "code": "theorem countP_eq_card {s} : countP p s = card s \u2194 \u2200 a \u2208 s, p a", "start": [2314, 1], "end": [2315, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_pos_of_mem", "code": "theorem countP_pos_of_mem {s a} (h : a \u2208 s) (pa : p a) : 0 < countP p s", "start": [2318, 1], "end": [2319, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.countP_congr", "code": "theorem countP_congr {s s' : Multiset \u03b1} (hs : s = s')\n    {p p' : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred p']\n    (hp : \u2200 x \u2208 s, p x = p' x) : s.countP p = s'.countP p'", "start": [2322, 1], "end": [2330, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.count", "code": "def count (a : \u03b1) : Multiset \u03b1 \u2192 \u2115 :=\n  countP (a = \u00b7)", "start": [2342, 1], "end": [2344, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_count", "code": "@[simp]\ntheorem coe_count (a : \u03b1) (l : List \u03b1) : count a (ofList l) = l.count a", "start": [2347, 1], "end": [2350, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_zero", "code": "@[simp, nolint simpNF] theorem count_zero (a : \u03b1) : count a 0 = 0", "start": [2353, 1], "end": [2355, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_cons_self", "code": "@[simp]\ntheorem count_cons_self (a : \u03b1) (s : Multiset \u03b1) : count a (a ::\u2098 s) = count a s + 1", "start": [2358, 1], "end": [2360, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_cons_of_ne", "code": "@[simp]\ntheorem count_cons_of_ne {a b : \u03b1} (h : a \u2260 b) (s : Multiset \u03b1) : count a (b ::\u2098 s) = count a s", "start": [2363, 1], "end": [2365, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_le_card", "code": "theorem count_le_card (a : \u03b1) (s) : count a s \u2264 card s", "start": [2368, 1], "end": [2369, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_le_of_le", "code": "theorem count_le_of_le (a : \u03b1) {s t} : s \u2264 t \u2192 count a s \u2264 count a t", "start": [2372, 1], "end": [2373, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_le_count_cons", "code": "theorem count_le_count_cons (a b : \u03b1) (s : Multiset \u03b1) : count a s \u2264 count a (b ::\u2098 s)", "start": [2376, 1], "end": [2377, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_cons", "code": "theorem count_cons (a b : \u03b1) (s : Multiset \u03b1) :\n    count a (b ::\u2098 s) = count a s + if a = b then 1 else 0", "start": [2380, 1], "end": [2382, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_singleton_self", "code": "theorem count_singleton_self (a : \u03b1) : count a ({a} : Multiset \u03b1) = 1", "start": [2385, 1], "end": [2386, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_singleton", "code": "theorem count_singleton (a b : \u03b1) : count a ({b} : Multiset \u03b1) = if a = b then 1 else 0", "start": [2389, 1], "end": [2390, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_add", "code": "@[simp]\ntheorem count_add (a : \u03b1) : \u2200 s t, count a (s + t) = count a s + count a t", "start": [2393, 1], "end": [2395, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.countAddMonoidHom", "code": "def countAddMonoidHom (a : \u03b1) : Multiset \u03b1 \u2192+ \u2115 :=\n  countPAddMonoidHom (a = \u00b7)", "start": [2398, 1], "end": [2400, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_countAddMonoidHom", "code": "@[simp]\ntheorem coe_countAddMonoidHom {a : \u03b1} : (countAddMonoidHom a : Multiset \u03b1 \u2192 \u2115) = count a", "start": [2403, 1], "end": [2405, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_nsmul", "code": "@[simp]\ntheorem count_nsmul (a : \u03b1) (n s) : count a (n \u2022 s) = n * count a s", "start": [2408, 1], "end": [2410, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_pos", "code": "theorem count_pos {a : \u03b1} {s : Multiset \u03b1} : 0 < count a s \u2194 a \u2208 s", "start": [2413, 1], "end": [2413, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.one_le_count_iff_mem", "code": "theorem one_le_count_iff_mem {a : \u03b1} {s : Multiset \u03b1} : 1 \u2264 count a s \u2194 a \u2208 s", "start": [2416, 1], "end": [2417, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_zero_of_not_mem", "code": "@[simp]\ntheorem count_eq_zero_of_not_mem {a : \u03b1} {s : Multiset \u03b1} (h : a \u2209 s) : count a s = 0", "start": [2420, 1], "end": [2422, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_zero", "code": "@[simp]\ntheorem count_eq_zero {a : \u03b1} {s : Multiset \u03b1} : count a s = 0 \u2194 a \u2209 s", "start": [2425, 1], "end": [2427, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_ne_zero", "code": "theorem count_ne_zero {a : \u03b1} {s : Multiset \u03b1} : count a s \u2260 0 \u2194 a \u2208 s", "start": [2430, 1], "end": [2431, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_card", "code": "theorem count_eq_card {a : \u03b1} {s} : count a s = card s \u2194 \u2200 x \u2208 s, a = x", "start": [2434, 1], "end": [2435, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_replicate_self", "code": "@[simp]\ntheorem count_replicate_self (a : \u03b1) (n : \u2115) : count a (replicate n a) = n", "start": [2438, 1], "end": [2441, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_replicate", "code": "theorem count_replicate (a b : \u03b1) (n : \u2115) : count a (replicate n b) = if a = b then n else 0", "start": [2444, 1], "end": [2446, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_erase_self", "code": "@[simp]\ntheorem count_erase_self (a : \u03b1) (s : Multiset \u03b1) : count a (erase s a) = count a s - 1", "start": [2449, 1], "end": [2452, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_erase_of_ne", "code": "@[simp]\ntheorem count_erase_of_ne {a b : \u03b1} (ab : a \u2260 b) (s : Multiset \u03b1) :\n    count a (erase s b) = count a s", "start": [2455, 1], "end": [2459, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_sub", "code": "@[simp]\ntheorem count_sub (a : \u03b1) (s t : Multiset \u03b1) : count a (s - t) = count a s - count a t", "start": [2462, 1], "end": [2468, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_union", "code": "@[simp]\ntheorem count_union (a : \u03b1) (s t : Multiset \u03b1) : count a (s \u222a t) = max (count a s) (count a t)", "start": [2471, 1], "end": [2473, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_inter", "code": "@[simp]\ntheorem count_inter (a : \u03b1) (s t : Multiset \u03b1) : count a (s \u2229 t) = min (count a s) (count a t)", "start": [2476, 1], "end": [2479, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_count_iff_replicate_le", "code": "theorem le_count_iff_replicate_le {a : \u03b1} {s : Multiset \u03b1} {n : \u2115} :\n    n \u2264 count a s \u2194 replicate n a \u2264 s", "start": [2482, 1], "end": [2486, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_filter_of_pos", "code": "@[simp]\ntheorem count_filter_of_pos {p} [DecidablePred p] {a} {s : Multiset \u03b1} (h : p a) :\n    count a (filter p s) = count a s", "start": [2489, 1], "end": [2495, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_filter_of_neg", "code": "@[simp]\ntheorem count_filter_of_neg {p} [DecidablePred p] {a} {s : Multiset \u03b1} (h : \u00acp a) :\n    count a (filter p s) = 0", "start": [2498, 1], "end": [2501, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_filter", "code": "theorem count_filter {p} [DecidablePred p] {a} {s : Multiset \u03b1} :\n    count a (filter p s) = if p a then count a s else 0", "start": [2504, 1], "end": [2508, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.ext", "code": "theorem ext {s t : Multiset \u03b1} : s = t \u2194 \u2200 a, count a s = count a t", "start": [2511, 1], "end": [2514, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.ext'", "code": "@[ext]\ntheorem ext' {s t : Multiset \u03b1} : (\u2200 a, count a s = count a t) \u2192 s = t", "start": [2517, 1], "end": [2519, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_inter", "code": "@[simp]\ntheorem coe_inter (s t : List \u03b1) : (s \u2229 t : Multiset \u03b1) = (s.bagInter t : List \u03b1)", "start": [2522, 1], "end": [2523, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_iff_count", "code": "theorem le_iff_count {s t : Multiset \u03b1} : s \u2264 t \u2194 \u2200 a, count a s \u2264 count a t", "start": [2526, 1], "end": [2528, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_map", "code": "theorem count_map {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) [DecidableEq \u03b2] (b : \u03b2) :\n    count b (map f s) = card (s.filter fun a => b = f a)", "start": [2539, 1], "end": [2541, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_map_eq_count", "code": "theorem count_map_eq_count [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1)\n    (hf : Set.InjOn f { x : \u03b1 | x \u2208 s }) (x) (H : x \u2208 s) : (s.map f).count (f x) = s.count x", "start": [2546, 1], "end": [2555, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_map_eq_count'", "code": "theorem count_map_eq_count' [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) (hf : Function.Injective f)\n    (x : \u03b1) : (s.map f).count (f x) = s.count x", "start": [2558, 1], "end": [2566, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_count_eq_count_coe", "code": "@[simp]\ntheorem attach_count_eq_count_coe (m : Multiset \u03b1) (a) : m.attach.count a = m.count (a : \u03b1)", "start": [2569, 1], "end": [2574, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_eq'", "code": "theorem filter_eq' (s : Multiset \u03b1) (b : \u03b1) : s.filter (\u00b7 = b) = replicate (count b s) b", "start": [2577, 1], "end": [2580, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.filter_eq", "code": "theorem filter_eq (s : Multiset \u03b1) (b : \u03b1) : s.filter (Eq b) = replicate (count b s) b", "start": [2583, 1], "end": [2584, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.replicate_inter", "code": "@[simp]\ntheorem replicate_inter (n : \u2115) (x : \u03b1) (s : Multiset \u03b1) :\n    replicate n x \u2229 s = replicate (min n (s.count x)) x", "start": [2587, 1], "end": [2594, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_replicate", "code": "@[simp]\ntheorem inter_replicate (s : Multiset \u03b1) (n : \u2115) (x : \u03b1) :\n    s \u2229 replicate n x = replicate (min (s.count x) n) x", "start": [2597, 1], "end": [2600, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.addHom_ext", "code": "@[ext]\ntheorem addHom_ext [AddZeroClass \u03b2] \u2983f g : Multiset \u03b1 \u2192+ \u03b2\u2984 (h : \u2200 x, f {x} = g {x}) : f = g", "start": [2605, 1], "end": [2610, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_le_map_iff", "code": "@[simp]\ntheorem map_le_map_iff {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) {s t : Multiset \u03b1} :\n    s.map f \u2264 t.map f \u2194 s \u2264 t", "start": [2615, 1], "end": [2620, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.mapEmbedding", "code": "@[simps!]\ndef mapEmbedding (f : \u03b1 \u21aa \u03b2) : Multiset \u03b1 \u21aao Multiset \u03b2 :=\n  OrderEmbedding.ofMapLEIff (map f) fun _ _ => map_le_map_iff f.inj'", "start": [2623, 1], "end": [2627, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_card_filter_eq", "code": "theorem count_eq_card_filter_eq [DecidableEq \u03b1] (s : Multiset \u03b1) (a : \u03b1) :\n    s.count a = card (s.filter (a = \u00b7))", "start": [2633, 1], "end": [2634, 80], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_count_True_eq_filter_card", "code": "@[simp]\ntheorem map_count_True_eq_filter_card (s : Multiset \u03b1) (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    (s.map p).count True = card (s.filter p)", "start": [2637, 1], "end": [2651, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.Rel", "code": "@[mk_iff]\ninductive Rel (r : \u03b1 \u2192 \u03b2 \u2192 Prop) : Multiset \u03b1 \u2192 Multiset \u03b2 \u2192 Prop\n  | zero : Rel r 0 0\n  | cons {a b as bs} : r a b \u2192 Rel r as bs \u2192 Rel r (a ::\u2098 as) (b ::\u2098 bs)", "start": [2659, 1], "end": [2664, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_flip_aux", "code": "private theorem rel_flip_aux {s t} (h : Rel r s t) : Rel (flip r) t s", "start": [2670, 1], "end": [2671, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_flip", "code": "theorem rel_flip {s t} : Rel (flip r) s t \u2194 Rel r t s", "start": [2673, 1], "end": [2674, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_refl_of_refl_on", "code": "theorem rel_refl_of_refl_on {m : Multiset \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : (\u2200 x \u2208 m, r x x) \u2192 Rel r m m", "start": [2677, 1], "end": [2682, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_eq_refl", "code": "theorem rel_eq_refl {s : Multiset \u03b1} : Rel (\u00b7 = \u00b7) s s", "start": [2685, 1], "end": [2686, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_eq", "code": "theorem rel_eq {s t : Multiset \u03b1} : Rel (\u00b7 = \u00b7) s t \u2194 s = t", "start": [2689, 1], "end": [2695, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.Rel.mono", "code": "theorem Rel.mono {r p : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} (hst : Rel r s t)\n    (h : \u2200 a \u2208 s, \u2200 b \u2208 t, r a b \u2192 p a b) : Rel p s t", "start": [2698, 1], "end": [2705, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.Rel.add", "code": "theorem Rel.add {s t u v} (hst : Rel r s t) (huv : Rel r u v) : Rel r (s + u) (t + v)", "start": [2708, 1], "end": [2711, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_flip_eq", "code": "theorem rel_flip_eq {s t : Multiset \u03b1} : Rel (fun a b => b = a) s t \u2194 s = t", "start": [2714, 1], "end": [2715, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_zero_left", "code": "@[simp]\ntheorem rel_zero_left {b : Multiset \u03b2} : Rel r 0 b \u2194 b = 0", "start": [2718, 1], "end": [2719, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_zero_right", "code": "@[simp]\ntheorem rel_zero_right {a : Multiset \u03b1} : Rel r a 0 \u2194 a = 0", "start": [2722, 1], "end": [2723, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_cons_left", "code": "theorem rel_cons_left {a as bs} :\n    Rel r (a ::\u2098 as) bs \u2194 \u2203 b bs', r a b \u2227 Rel r as bs' \u2227 bs = b ::\u2098 bs'", "start": [2726, 1], "end": [2741, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_cons_right", "code": "theorem rel_cons_right {as b bs} :\n    Rel r as (b ::\u2098 bs) \u2194 \u2203 a as', r a b \u2227 Rel r as' bs \u2227 as = a ::\u2098 as'", "start": [2744, 1], "end": [2748, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_add_left", "code": "theorem rel_add_left {as\u2080 as\u2081} :\n    \u2200 {bs}, Rel r (as\u2080 + as\u2081) bs \u2194 \u2203 bs\u2080 bs\u2081, Rel r as\u2080 bs\u2080 \u2227 Rel r as\u2081 bs\u2081 \u2227 bs = bs\u2080 + bs\u2081", "start": [2751, 1], "end": [2763, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_add_right", "code": "theorem rel_add_right {as bs\u2080 bs\u2081} :\n    Rel r as (bs\u2080 + bs\u2081) \u2194 \u2203 as\u2080 as\u2081, Rel r as\u2080 bs\u2080 \u2227 Rel r as\u2081 bs\u2081 \u2227 as = as\u2080 + as\u2081", "start": [2766, 1], "end": [2768, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_map_left", "code": "theorem rel_map_left {s : Multiset \u03b3} {f : \u03b3 \u2192 \u03b1} :\n    \u2200 {t}, Rel r (s.map f) t \u2194 Rel (fun a b => r (f a) b) s t", "start": [2771, 1], "end": [2773, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_map_right", "code": "theorem rel_map_right {s : Multiset \u03b1} {t : Multiset \u03b3} {f : \u03b3 \u2192 \u03b2} :\n    Rel r s (t.map f) \u2194 Rel (fun a b => r a (f b)) s t", "start": [2776, 1], "end": [2778, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_map", "code": "theorem rel_map {s : Multiset \u03b1} {t : Multiset \u03b2} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Rel p (s.map f) (t.map g) \u2194 Rel (fun a b => p (f a) (g b)) s t", "start": [2781, 1], "end": [2783, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_eq_card_of_rel", "code": "theorem card_eq_card_of_rel {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : Multiset \u03b1} {t : Multiset \u03b2} (h : Rel r s t) :\n    card s = card t", "start": [2786, 1], "end": [2787, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_mem_of_rel_of_mem", "code": "theorem exists_mem_of_rel_of_mem {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {s : Multiset \u03b1} {t : Multiset \u03b2}\n    (h : Rel r s t) : \u2200 {a : \u03b1} (_ha : a \u2208 s), \u2203 b \u2208 t, r a b", "start": [2790, 1], "end": [2798, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_of_forall", "code": "theorem rel_of_forall {m1 m2 : Multiset \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : \u2200 a b, a \u2208 m1 \u2192 b \u2208 m2 \u2192 r a b)\n    (hc : card m1 = card m2) : m1.Rel r m2", "start": [2801, 1], "end": [2813, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_replicate_left", "code": "theorem rel_replicate_left {m : Multiset \u03b1} {a : \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {n : \u2115} :\n    (replicate n a).Rel r m \u2194 card m = n \u2227 \u2200 x, x \u2208 m \u2192 r a x", "start": [2816, 1], "end": [2824, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_replicate_right", "code": "theorem rel_replicate_right {m : Multiset \u03b1} {a : \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {n : \u2115} :\n    m.Rel r (replicate n a) \u2194 card m = n \u2227 \u2200 x, x \u2208 m \u2192 r x a", "start": [2827, 1], "end": [2829, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.Rel.trans", "code": "protected nonrec theorem Rel.trans (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] {s t u : Multiset \u03b1} (r1 : Rel r s t)\n    (r2 : Rel r t u) : Rel r s u", "start": [2832, 1], "end": [2839, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.Rel.countP_eq", "code": "theorem Rel.countP_eq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] [IsSymm \u03b1 r] {s t : Multiset \u03b1} (x : \u03b1)\n    [DecidablePred (r x)] (h : Rel r s t) : countP (r x) s = countP (r x) t", "start": [2842, 1], "end": [2849, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_eq_map", "code": "theorem map_eq_map {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) {s t : Multiset \u03b1} :\n    s.map f = t.map f \u2194 s = t", "start": [2856, 1], "end": [2859, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_injective", "code": "theorem map_injective {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) :\n    Function.Injective (Multiset.map f)", "start": [2862, 1], "end": [2863, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_mk_eq_map_mk_of_rel", "code": "theorem map_mk_eq_map_mk_of_rel {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s t : Multiset \u03b1} (hst : s.Rel r t) :\n    s.map (Quot.mk r) = t.map (Quot.mk r)", "start": [2870, 1], "end": [2872, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_multiset_eq_map_quot_mk", "code": "theorem exists_multiset_eq_map_quot_mk {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Multiset (Quot r)) :\n    \u2203 t : Multiset \u03b1, s = t.map (Quot.mk r)", "start": [2875, 1], "end": [2878, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.induction_on_multiset_quot", "code": "theorem induction_on_multiset_quot {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {p : Multiset (Quot r) \u2192 Prop}\n    (s : Multiset (Quot r)) : (\u2200 s : Multiset \u03b1, p (s.map (Quot.mk r))) \u2192 p s", "start": [2881, 1], "end": [2884, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.Disjoint", "code": "def Disjoint (s t : Multiset \u03b1) : Prop :=\n  \u2200 \u2983a\u2984, a \u2208 s \u2192 a \u2208 t \u2192 False", "start": [2892, 1], "end": [2894, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_disjoint", "code": "@[simp]\ntheorem coe_disjoint (l\u2081 l\u2082 : List \u03b1) : @Disjoint \u03b1 l\u2081 l\u2082 \u2194 l\u2081.Disjoint l\u2082", "start": [2897, 1], "end": [2899, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.Disjoint.symm", "code": "@[symm]\ntheorem Disjoint.symm {s t : Multiset \u03b1} (d : Disjoint s t) : Disjoint t s", "start": [2902, 1], "end": [2904, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_comm", "code": "theorem disjoint_comm {s t : Multiset \u03b1} : Disjoint s t \u2194 Disjoint t s", "start": [2907, 1], "end": [2908, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_left", "code": "theorem disjoint_left {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 {a}, a \u2208 s \u2192 a \u2209 t", "start": [2911, 1], "end": [2912, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_right", "code": "theorem disjoint_right {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 {a}, a \u2208 t \u2192 a \u2209 s", "start": [2915, 1], "end": [2916, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_iff_ne", "code": "theorem disjoint_iff_ne {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b", "start": [2919, 1], "end": [2920, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_of_subset_left", "code": "theorem disjoint_of_subset_left {s t u : Multiset \u03b1} (h : s \u2286 u) (d : Disjoint u t) : Disjoint s t", "start": [2923, 1], "end": [2924, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_of_subset_right", "code": "theorem disjoint_of_subset_right {s t u : Multiset \u03b1} (h : t \u2286 u) (d : Disjoint s u) : Disjoint s t", "start": [2927, 1], "end": [2928, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_of_le_left", "code": "theorem disjoint_of_le_left {s t u : Multiset \u03b1} (h : s \u2264 u) : Disjoint u t \u2192 Disjoint s t", "start": [2931, 1], "end": [2932, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_of_le_right", "code": "theorem disjoint_of_le_right {s t u : Multiset \u03b1} (h : t \u2264 u) : Disjoint s u \u2192 Disjoint s t", "start": [2935, 1], "end": [2936, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_disjoint", "code": "@[simp]\ntheorem zero_disjoint (l : Multiset \u03b1) : Disjoint 0 l", "start": [2939, 1], "end": [2941, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_disjoint", "code": "@[simp]\ntheorem singleton_disjoint {l : Multiset \u03b1} {a : \u03b1} : Disjoint {a} l \u2194 a \u2209 l", "start": [2944, 1], "end": [2946, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_singleton", "code": "@[simp]\ntheorem disjoint_singleton {l : Multiset \u03b1} {a : \u03b1} : Disjoint l {a} \u2194 a \u2209 l", "start": [2949, 1], "end": [2951, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_add_left", "code": "@[simp]\ntheorem disjoint_add_left {s t u : Multiset \u03b1} : Disjoint (s + t) u \u2194 Disjoint s u \u2227 Disjoint t u", "start": [2954, 1], "end": [2956, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_add_right", "code": "@[simp]\ntheorem disjoint_add_right {s t u : Multiset \u03b1} :\n    Disjoint s (t + u) \u2194 Disjoint s t \u2227 Disjoint s u", "start": [2959, 1], "end": [2962, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_cons_left", "code": "@[simp]\ntheorem disjoint_cons_left {a : \u03b1} {s t : Multiset \u03b1} :\n    Disjoint (a ::\u2098 s) t \u2194 a \u2209 t \u2227 Disjoint s t", "start": [2965, 1], "end": [2968, 69], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_cons_right", "code": "@[simp]\ntheorem disjoint_cons_right {a : \u03b1} {s t : Multiset \u03b1} :\n    Disjoint s (a ::\u2098 t) \u2194 a \u2209 s \u2227 Disjoint s t", "start": [2971, 1], "end": [2974, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_eq_zero_iff_disjoint", "code": "theorem inter_eq_zero_iff_disjoint [DecidableEq \u03b1] {s t : Multiset \u03b1} : s \u2229 t = 0 \u2194 Disjoint s t", "start": [2977, 1], "end": [2978, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_union_left", "code": "@[simp]\ntheorem disjoint_union_left [DecidableEq \u03b1] {s t u : Multiset \u03b1} :\n    Disjoint (s \u222a t) u \u2194 Disjoint s u \u2227 Disjoint t u", "start": [2981, 1], "end": [2983, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_union_right", "code": "@[simp]\ntheorem disjoint_union_right [DecidableEq \u03b1] {s t u : Multiset \u03b1} :\n    Disjoint s (t \u222a u) \u2194 Disjoint s t \u2227 Disjoint s u", "start": [2986, 1], "end": [2988, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_eq_union_iff_disjoint", "code": "theorem add_eq_union_iff_disjoint [DecidableEq \u03b1] {s t : Multiset \u03b1} :\n    s + t = s \u222a t \u2194 Disjoint s t", "start": [2991, 1], "end": [2994, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_map_map", "code": "theorem disjoint_map_map {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} {s : Multiset \u03b1} {t : Multiset \u03b2} :\n    Disjoint (s.map f) (t.map g) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, f a \u2260 g b", "start": [2997, 1], "end": [2999, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pairwise", "code": "def Pairwise (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (m : Multiset \u03b1) : Prop :=\n  \u2203 l : List \u03b1, m = l \u2227 l.Pairwise r", "start": [3002, 1], "end": [3005, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.pairwise_zero", "code": "@[simp]\ntheorem pairwise_zero (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Multiset.Pairwise r 0", "start": [3008, 1], "end": [3010, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.pairwise_coe_iff", "code": "theorem pairwise_coe_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : List \u03b1} :\n    Multiset.Pairwise r l \u2194 \u2203 l' : List \u03b1, l ~ l' \u2227 l'.Pairwise r", "start": [3013, 1], "end": [3015, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.pairwise_coe_iff_pairwise", "code": "theorem pairwise_coe_iff_pairwise {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Symmetric r) {l : List \u03b1} :\n    Multiset.Pairwise r l \u2194 l.Pairwise r", "start": [3018, 1], "end": [3020, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_set_pairwise", "code": "theorem map_set_pairwise {f : \u03b1 \u2192 \u03b2} {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {m : Multiset \u03b1}\n    (h : { a | a \u2208 m }.Pairwise fun a\u2081 a\u2082 => r (f a\u2081) (f a\u2082)) : { b | b \u2208 m.map f }.Pairwise r", "start": [3023, 1], "end": [3027, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.chooseX", "code": "def chooseX : \u2200 _hp : \u2203! a, a \u2208 l \u2227 p a, { a // a \u2208 l \u2227 p a } :=\n  Quotient.recOn l (fun l' ex_unique => List.chooseX p l' (ExistsUnique.exists ex_unique))\n    (by\n      intros a b _\n      funext hp\n      suffices all_equal : \u2200 x y : { t // t \u2208 b \u2227 p t }, x = y by\n        apply all_equal\n      rintro \u27e8x, px\u27e9 \u27e8y, py\u27e9\n      rcases hp with \u27e8z, \u27e8_z_mem_l, _pz\u27e9, z_unique\u27e9\n      congr\n      calc\n        x = z := z_unique x px\n        _ = y := (z_unique y py).symm\n        )", "start": [3038, 1], "end": [3053, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.choose", "code": "def choose (hp : \u2203! a, a \u2208 l \u2227 p a) : \u03b1 :=\n  chooseX p l hp", "start": [3056, 1], "end": [3059, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.choose_spec", "code": "theorem choose_spec (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l \u2227 p (choose p l hp)", "start": [3062, 1], "end": [3063, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.choose_mem", "code": "theorem choose_mem (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l", "start": [3066, 1], "end": [3067, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.choose_property", "code": "theorem choose_property (hp : \u2203! a, a \u2208 l \u2227 p a) : p (choose p l hp)", "start": [3070, 1], "end": [3071, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.subsingletonEquiv", "code": "def subsingletonEquiv [Subsingleton \u03b1] : List \u03b1 \u2243 Multiset \u03b1 where\n  toFun := ofList\n  invFun :=\n    (Quot.lift id) fun (a b : List \u03b1) (h : a ~ b) =>\n      (List.ext_nthLe h.length_eq) fun _ _ _ => Subsingleton.elim _ _\n  left_inv _ := rfl\n  right_inv m := Quot.inductionOn m fun _ => rfl", "start": [3079, 1], "end": [3086, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_subsingletonEquiv", "code": "@[simp]\ntheorem coe_subsingletonEquiv [Subsingleton \u03b1] :\n    (subsingletonEquiv \u03b1 : List \u03b1 \u2192 Multiset \u03b1) = ofList", "start": [3091, 1], "end": [3094, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/NAry.lean", "imports": ["Mathlib/Data/Set/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.image2", "code": "def image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) : Set \u03b3 :=\n  { c | \u2203 a b, a \u2208 s \u2227 b \u2208 t \u2227 f a b = c }", "start": [33, 1], "end": [36, 43], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image2", "code": "@[simp]\ntheorem mem_image2 : c \u2208 image2 f s t \u2194 \u2203 a b, a \u2208 s \u2227 b \u2208 t \u2227 f a b = c", "start": [39, 1], "end": [41, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image2_of_mem", "code": "theorem mem_image2_of_mem (ha : a \u2208 s) (hb : b \u2208 t) : f a b \u2208 image2 f s t", "start": [44, 1], "end": [45, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image2_iff", "code": "theorem mem_image2_iff (hf : Injective2 f) : f a b \u2208 image2 f s t \u2194 a \u2208 s \u2227 b \u2208 t", "start": [48, 1], "end": [52, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset", "code": "theorem image2_subset (hs : s \u2286 s') (ht : t \u2286 t') : image2 f s t \u2286 image2 f s' t'", "start": [55, 1], "end": [58, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset_left", "code": "theorem image2_subset_left (ht : t \u2286 t') : image2 f s t \u2286 image2 f s t'", "start": [61, 1], "end": [62, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset_right", "code": "theorem image2_subset_right (hs : s \u2286 s') : image2 f s t \u2286 image2 f s' t", "start": [65, 1], "end": [66, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_image2_left", "code": "theorem image_subset_image2_left (hb : b \u2208 t) : (fun a => f a b) '' s \u2286 image2 f s t", "start": [69, 1], "end": [70, 57], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_image2_right", "code": "theorem image_subset_image2_right (ha : a \u2208 s) : f a '' t \u2286 image2 f s t", "start": [73, 1], "end": [74, 51], "kind": "commanddeclaration"}, {"full_name": "Set.forall_image2_iff", "code": "theorem forall_image2_iff {p : \u03b3 \u2192 Prop} :\n    (\u2200 z \u2208 image2 f s t, p z) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, p (f x y)", "start": [77, 1], "end": [79, 95], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset_iff", "code": "@[simp]\ntheorem image2_subset_iff {u : Set \u03b3} : image2 f s t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, f x y \u2208 u", "start": [82, 1], "end": [84, 20], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset_iff_left", "code": "theorem image2_subset_iff_left : image2 f s t \u2286 u \u2194 \u2200 a \u2208 s, (fun b => f a b) '' t \u2286 u", "start": [87, 1], "end": [88, 74], "kind": "commanddeclaration"}, {"full_name": "Set.image2_subset_iff_right", "code": "theorem image2_subset_iff_right : image2 f s t \u2286 u \u2194 \u2200 b \u2208 t, (fun a => f a b) '' s \u2286 u", "start": [91, 1], "end": [92, 91], "kind": "commanddeclaration"}, {"full_name": "Set.image_prod", "code": "lemma image_prod : (fun x : \u03b1 \u00d7 \u03b2 \u21a6 f x.1 x.2) '' s \u00d7\u02e2 t = image2 f s t :=\n  ext $ fun a \u21a6\n  \u27e8 by rintro \u27e8_, _, rfl\u27e9; exact \u27e8_, _, (mem_prod.1 \u2039_\u203a).1, (mem_prod.1 \u2039_\u203a).2, rfl\u27e9,\n    by rintro \u27e8_, _, _, _, rfl\u27e9; exact \u27e8(_, _), \u27e8\u2039_\u203a, \u2039_\u203a\u27e9, rfl\u27e9\u27e9", "start": [98, 1], "end": [101, 66], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image_uncurry_prod", "code": "@[simp] lemma image_uncurry_prod (s : Set \u03b1) (t : Set \u03b2) : uncurry f '' s \u00d7\u02e2 t = image2 f s t :=\n  image_prod _", "start": [104, 1], "end": [105, 15], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_mk_eq_prod", "code": "@[simp] lemma image2_mk_eq_prod : image2 Prod.mk s t = s \u00d7\u02e2 t := ext $ by simp", "start": [108, 1], "end": [108, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_curry", "code": "lemma image2_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) :\n    image2 (fun a b \u21a6 f (a, b)) s t = f '' s \u00d7\u02e2 t := by\n  simp [\u2190image_uncurry_prod, uncurry]", "start": [112, 1], "end": [114, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_swap", "code": "theorem image2_swap (s : Set \u03b1) (t : Set \u03b2) : image2 f s t = image2 (fun a b => f b a) t s", "start": [117, 1], "end": [119, 75], "kind": "commanddeclaration"}, {"full_name": "Set.image2_union_left", "code": "theorem image2_union_left : image2 f (s \u222a s') t = image2 f s t \u222a image2 f s' t", "start": [124, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "Set.image2_union_right", "code": "theorem image2_union_right : image2 f s (t \u222a t') = image2 f s t \u222a image2 f s t'", "start": [132, 1], "end": [133, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image2_inter_left", "code": "lemma image2_inter_left (hf : Injective2 f) :\n    image2 f (s \u2229 s') t = image2 f s t \u2229 image2 f s' t := by\n  simp_rw [\u2190image_uncurry_prod, inter_prod, image_inter hf.uncurry]", "start": [136, 1], "end": [138, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_inter_right", "code": "lemma image2_inter_right (hf : Injective2 f) :\n    image2 f s (t \u2229 t') = image2 f s t \u2229 image2 f s t' := by\n  simp_rw [\u2190image_uncurry_prod, prod_inter, image_inter hf.uncurry]", "start": [141, 1], "end": [143, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_empty_left", "code": "@[simp]\ntheorem image2_empty_left : image2 f \u2205 t = \u2205", "start": [146, 1], "end": [148, 17], "kind": "commanddeclaration"}, {"full_name": "Set.image2_empty_right", "code": "@[simp]\ntheorem image2_empty_right : image2 f s \u2205 = \u2205", "start": [151, 1], "end": [153, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.image2", "code": "theorem Nonempty.image2 : s.Nonempty \u2192 t.Nonempty \u2192 (image2 f s t).Nonempty", "start": [156, 1], "end": [157, 54], "kind": "commanddeclaration"}, {"full_name": "Set.image2_nonempty_iff", "code": "@[simp]\ntheorem image2_nonempty_iff : (image2 f s t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [160, 1], "end": [162, 74], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_image2_left", "code": "theorem Nonempty.of_image2_left (h : (Set.image2 f s t).Nonempty) : s.Nonempty", "start": [165, 1], "end": [166, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_image2_right", "code": "theorem Nonempty.of_image2_right (h : (Set.image2 f s t).Nonempty) : t.Nonempty", "start": [169, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image2_eq_empty_iff", "code": "@[simp]\ntheorem image2_eq_empty_iff : image2 f s t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [173, 1], "end": [176, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.image2", "code": "theorem Subsingleton.image2 (hs : s.Subsingleton) (ht : t.Subsingleton) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    (image2 f s t).Subsingleton", "start": [179, 1], "end": [182, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image2_inter_subset_left", "code": "theorem image2_inter_subset_left : image2 f (s \u2229 s') t \u2286 image2 f s t \u2229 image2 f s' t", "start": [184, 1], "end": [186, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image2_inter_subset_right", "code": "theorem image2_inter_subset_right : image2 f s (t \u2229 t') \u2286 image2 f s t \u2229 image2 f s t'", "start": [189, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image2_singleton_left", "code": "@[simp]\ntheorem image2_singleton_left : image2 f {a} t = f a '' t", "start": [194, 1], "end": [196, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image2_singleton_right", "code": "@[simp]\ntheorem image2_singleton_right : image2 f s {b} = (fun a => f a b) '' s", "start": [199, 1], "end": [201, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image2_singleton", "code": "theorem image2_singleton : image2 f {a} {b} = {f a b}", "start": [204, 1], "end": [204, 65], "kind": "commanddeclaration"}, {"full_name": "Set.image2_insert_left", "code": "@[simp]\ntheorem image2_insert_left : image2 f (insert a s) t = (fun b => f a b) '' t \u222a image2 f s t", "start": [207, 1], "end": [209, 59], "kind": "commanddeclaration"}, {"full_name": "Set.image2_insert_right", "code": "@[simp]\ntheorem image2_insert_right : image2 f s (insert b t) = (fun a => f a b) '' s \u222a image2 f s t", "start": [212, 1], "end": [214, 61], "kind": "commanddeclaration"}, {"full_name": "Set.image2_congr", "code": "@[congr]\ntheorem image2_congr (h : \u2200 a \u2208 s, \u2200 b \u2208 t, f a b = f' a b) : image2 f s t = image2 f' s t", "start": [217, 1], "end": [220, 93], "kind": "commanddeclaration"}, {"full_name": "Set.image2_congr'", "code": "theorem image2_congr' (h : \u2200 a b, f a b = f' a b) : image2 f s t = image2 f' s t", "start": [223, 1], "end": [225, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image3", "code": "def image3 (g : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) (s : Set \u03b1) (t : Set \u03b2) (u : Set \u03b3) : Set \u03b4 :=\n  { d | \u2203 a b c, a \u2208 s \u2227 b \u2208 t \u2227 c \u2208 u \u2227 g a b c = d }", "start": [228, 1], "end": [233, 55], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image3", "code": "@[simp]\ntheorem mem_image3 : d \u2208 image3 g s t u \u2194 \u2203 a b c, a \u2208 s \u2227 b \u2208 t \u2227 c \u2208 u \u2227 g a b c = d", "start": [236, 1], "end": [238, 10], "kind": "commanddeclaration"}, {"full_name": "Set.image3_mono", "code": "theorem image3_mono (hs : s \u2286 s') (ht : t \u2286 t') (hu : u \u2286 u') :\n    image3 g s t u \u2286 image3 g s' t' u'", "start": [241, 1], "end": [243, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image3_congr", "code": "@[congr]\ntheorem image3_congr (h : \u2200 a \u2208 s, \u2200 b \u2208 t, \u2200 c \u2208 u, g a b c = g' a b c) :\n    image3 g s t u = image3 g' s t u", "start": [246, 1], "end": [251, 58], "kind": "commanddeclaration"}, {"full_name": "Set.image3_congr'", "code": "theorem image3_congr' (h : \u2200 a b c, g a b c = g' a b c) : image3 g s t u = image3 g' s t u", "start": [254, 1], "end": [256, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image2_left", "code": "theorem image2_image2_left (f : \u03b4 \u2192 \u03b3 \u2192 \u03b5) (g : \u03b1 \u2192 \u03b2 \u2192 \u03b4) :\n    image2 f (image2 g s t) u = image3 (fun a b c => f (g a b) c) s t u", "start": [259, 1], "end": [265, 49], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image2_right", "code": "theorem image2_image2_right (f : \u03b1 \u2192 \u03b4 \u2192 \u03b5) (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) :\n    image2 f s (image2 g t u) = image3 (fun a b c => f a (g b c)) s t u", "start": [268, 1], "end": [274, 49], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2", "code": "theorem image_image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4) :\n    g '' image2 f s t = image2 (fun a b => g (f a b)) s t", "start": [277, 1], "end": [283, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image_left", "code": "theorem image2_image_left (f : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3) :\n    image2 f (g '' s) t = image2 (fun a b => f (g a) b) s t", "start": [286, 1], "end": [292, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image_right", "code": "theorem image2_image_right (f : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b3) :\n    image2 f s (g '' t) = image2 (fun a b => f a (g b)) s t", "start": [295, 1], "end": [301, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image2_left", "code": "@[simp]\ntheorem image2_left (h : t.Nonempty) : image2 (fun x _ => x) s t = s", "start": [304, 1], "end": [306, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image2_right", "code": "@[simp]\ntheorem image2_right (h : s.Nonempty) : image2 (fun _ y => y) s t = t", "start": [309, 1], "end": [311, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image2_assoc", "code": "theorem image2_assoc {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b5' \u2192 \u03b5} {g' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'}\n    (h_assoc : \u2200 a b c, f (g a b) c = f' a (g' b c)) :\n    image2 f (image2 g s t) u = image2 f' s (image2 g' t u)", "start": [314, 1], "end": [317, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image2_comm", "code": "theorem image2_comm {g : \u03b2 \u2192 \u03b1 \u2192 \u03b3} (h_comm : \u2200 a b, f a b = g b a) : image2 f s t = image2 g t s", "start": [320, 1], "end": [321, 51], "kind": "commanddeclaration"}, {"full_name": "Set.image2_left_comm", "code": "theorem image2_left_comm {f : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {g : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b2 \u2192 \u03b4' \u2192 \u03b5}\n    (h_left_comm : \u2200 a b c, f a (g b c) = g' b (f' a c)) :\n    image2 f s (image2 g t u) = image2 g' t (image2 f' s u)", "start": [324, 1], "end": [328, 52], "kind": "commanddeclaration"}, {"full_name": "Set.image2_right_comm", "code": "theorem image2_right_comm {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b4' \u2192 \u03b2 \u2192 \u03b5}\n    (h_right_comm : \u2200 a b c, f (g a b) c = g' (f' a c) b) :\n    image2 f (image2 g s t) u = image2 g' (image2 f' s u) t", "start": [331, 1], "end": [335, 53], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image2_image2_comm", "code": "theorem image2_image2_image2_comm {f : \u03b5 \u2192 \u03b6 \u2192 \u03bd} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b5} {h : \u03b3 \u2192 \u03b4 \u2192 \u03b6} {f' : \u03b5' \u2192 \u03b6' \u2192 \u03bd}\n    {g' : \u03b1 \u2192 \u03b3 \u2192 \u03b5'} {h' : \u03b2 \u2192 \u03b4 \u2192 \u03b6'}\n    (h_comm : \u2200 a b c d, f (g a b) (h c d) = f' (g' a c) (h' b d)) :\n    image2 f (image2 g s t) (image2 h u v) = image2 f' (image2 g' s u) (image2 h' t v)", "start": [338, 1], "end": [346, 75], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_distrib", "code": "theorem image_image2_distrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2' \u2192 \u03b4} {g\u2081 : \u03b1 \u2192 \u03b1'} {g\u2082 : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g\u2081 a) (g\u2082 b)) :\n    (image2 f s t).image g = image2 f' (s.image g\u2081) (t.image g\u2082)", "start": [349, 1], "end": [352, 75], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_distrib_left", "code": "theorem image_image2_distrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g' a) b) :\n    (image2 f s t).image g = image2 f' (s.image g') t", "start": [355, 1], "end": [359, 62], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_distrib_right", "code": "theorem image_image2_distrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b2' \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' a (g' b)) :\n    (image2 f s t).image g = image2 f' s (t.image g')", "start": [362, 1], "end": [366, 62], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image_left_comm", "code": "theorem image2_image_left_comm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_comm : \u2200 a b, f (g a) b = g' (f' a b)) :\n    image2 f (s.image g) t = (image2 f' s t).image g'", "start": [369, 1], "end": [373, 69], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_right_comm", "code": "theorem image_image2_right_comm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_comm : \u2200 a b, f a (g b) = g' (f' a b)) :\n    image2 f s (t.image g) = (image2 f' s t).image g'", "start": [376, 1], "end": [380, 71], "kind": "commanddeclaration"}, {"full_name": "Set.image2_distrib_subset_left", "code": "theorem image2_distrib_subset_left {f : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {g : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {f\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'}\n    {f\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'} {g' : \u03b2' \u2192 \u03b3' \u2192 \u03b5} (h_distrib : \u2200 a b c, f a (g b c) = g' (f\u2081 a b) (f\u2082 a c)) :\n    image2 f s (image2 g t u) \u2286 image2 g' (image2 f\u2081 s t) (image2 f\u2082 s u)", "start": [383, 1], "end": [389, 78], "kind": "commanddeclaration"}, {"full_name": "Set.image2_distrib_subset_right", "code": "theorem image2_distrib_subset_right {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'}\n    {f\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'} {g' : \u03b1' \u2192 \u03b2' \u2192 \u03b5} (h_distrib : \u2200 a b c, f (g a b) c = g' (f\u2081 a c) (f\u2082 b c)) :\n    image2 f (image2 g s t) u \u2286 image2 g' (image2 f\u2081 s u) (image2 f\u2082 t u)", "start": [392, 1], "end": [398, 78], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_antidistrib", "code": "theorem image_image2_antidistrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {g\u2081 : \u03b2 \u2192 \u03b2'} {g\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g\u2081 b) (g\u2082 a)) :\n    (image2 f s t).image g = image2 f' (t.image g\u2081) (s.image g\u2082)", "start": [401, 1], "end": [405, 58], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_antidistrib_left", "code": "theorem image_image2_antidistrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g' b) a) :\n    (image2 f s t).image g = image2 f' (t.image g') s", "start": [408, 1], "end": [412, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_antidistrib_right", "code": "theorem image_image2_antidistrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' b (g' a)) :\n    (image2 f s t).image g = image2 f' t (s.image g')", "start": [415, 1], "end": [419, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image2_image_left_anticomm", "code": "theorem image2_image_left_anticomm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_anticomm : \u2200 a b, f (g a) b = g' (f' b a)) :\n    image2 f (s.image g) t = (image2 f' t s).image g'", "start": [422, 1], "end": [426, 77], "kind": "commanddeclaration"}, {"full_name": "Set.image_image2_right_anticomm", "code": "theorem image_image2_right_anticomm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_anticomm : \u2200 a b, f a (g b) = g' (f' b a)) :\n    image2 f s (t.image g) = (image2 f' t s).image g'", "start": [429, 1], "end": [433, 79], "kind": "commanddeclaration"}, {"full_name": "Set.image2_left_identity", "code": "lemma image2_left_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {a : \u03b1} (h : \u2200 b, f a b = b) (t : Set \u03b2) :\n    image2 f {a} t = t := by\n  rw [image2_singleton_left, show f a = id from funext h, image_id]", "start": [436, 1], "end": [440, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_right_identity", "code": "lemma image2_right_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {b : \u03b2} (h : \u2200 a, f a b = a) (s : Set \u03b1) :\n    image2 f s {b} = s := by\n  rw [image2_singleton_right, funext h, image_id']", "start": [443, 1], "end": [447, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image2_inter_union_subset_union", "code": "theorem image2_inter_union_subset_union :\n    image2 f (s \u2229 s') (t \u222a t') \u2286 image2 f s t \u222a image2 f s' t'", "start": [450, 1], "end": [455, 54], "kind": "commanddeclaration"}, {"full_name": "Set.image2_union_inter_subset_union", "code": "theorem image2_union_inter_subset_union :\n    image2 f (s \u222a s') (t \u2229 t') \u2286 image2 f s t \u222a image2 f s' t'", "start": [458, 1], "end": [463, 53], "kind": "commanddeclaration"}, {"full_name": "Set.image2_inter_union_subset", "code": "theorem image2_inter_union_subset {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} {s t : Set \u03b1} (hf : \u2200 a b, f a b = f b a) :\n    image2 f (s \u2229 t) (s \u222a t) \u2286 image2 f s t", "start": [466, 1], "end": [469, 96], "kind": "commanddeclaration"}, {"full_name": "Set.image2_union_inter_subset", "code": "theorem image2_union_inter_subset {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} {s t : Set \u03b1} (hf : \u2200 a b, f a b = f b a) :\n    image2 f (s \u222a t) (s \u2229 t) \u2286 image2 f s t", "start": [472, 1], "end": [475, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Directed.lean", "imports": ["Mathlib/Order/Lattice.lean", "Mathlib/Data/Set/Image.lean", "Mathlib/Order/Max.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Directed", "code": "def Directed (f : \u03b9 \u2192 \u03b1) :=\n  \u2200 x y, \u2203 z, f x \u227c f z \u2227 f y \u227c f z", "start": [41, 1], "end": [44, 36], "kind": "commanddeclaration"}, {"full_name": "DirectedOn", "code": "def DirectedOn (s : Set \u03b1) :=\n  \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 z \u2208 s, x \u227c z \u2227 y \u227c z", "start": [47, 1], "end": [50, 43], "kind": "commanddeclaration"}, {"full_name": "directedOn_iff_directed", "code": "theorem directedOn_iff_directed {s} : @DirectedOn \u03b1 r s \u2194 Directed r (Subtype.val : s \u2192 \u03b1)", "start": [55, 1], "end": [56, 91], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.directed_val", "code": "alias \u27e8DirectedOn.directed_val, _\u27e9 := directedOn_iff_directed", "start": [59, 1], "end": [59, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "directedOn_range", "code": "theorem directedOn_range {f : \u03b9 \u2192 \u03b1} : Directed r f \u2194 DirectedOn r (Set.range f)", "start": [62, 1], "end": [63, 77], "kind": "commanddeclaration"}, {"full_name": "Directed.directedOn_range", "code": "alias \u27e8Directed.directedOn_range, _\u27e9 := directedOn_range", "start": [67, 1], "end": [67, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "directedOn_image", "code": "theorem directedOn_image {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    DirectedOn r (f '' s) \u2194 DirectedOn (f \u207b\u00b9'o r) s", "start": [73, 1], "end": [76, 46], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.mono'", "code": "theorem DirectedOn.mono' {s : Set \u03b1} (hs : DirectedOn r s)\n    (h : \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 r a b \u2192 r' a b) : DirectedOn r' s", "start": [79, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.mono", "code": "theorem DirectedOn.mono {s : Set \u03b1} (h : DirectedOn r s) (H : \u2200 {a b}, r a b \u2192 r' a b) :\n    DirectedOn r' s", "start": [85, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "directed_comp", "code": "theorem directed_comp {\u03b9} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} : Directed r (g \u2218 f) \u2194 Directed (g \u207b\u00b9'o r) f", "start": [90, 1], "end": [91, 10], "kind": "commanddeclaration"}, {"full_name": "Directed.mono", "code": "theorem Directed.mono {s : \u03b1 \u2192 \u03b1 \u2192 Prop} {\u03b9} {f : \u03b9 \u2192 \u03b1} (H : \u2200 a b, r a b \u2192 s a b)\n    (h : Directed r f) : Directed s f", "start": [94, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "Directed.mono_comp", "code": "theorem Directed.mono_comp (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {\u03b9} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} {g : \u03b1 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1}\n    (hg : \u2200 \u2983x y\u2984, r x y \u2192 rb (g x) (g y)) (hf : Directed r f) : Directed rb (g \u2218 f)", "start": [101, 1], "end": [103, 32], "kind": "commanddeclaration"}, {"full_name": "directed_of_sup", "code": "theorem directed_of_sup [SemilatticeSup \u03b1] {f : \u03b1 \u2192 \u03b2} {r : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    (H : \u2200 \u2983i j\u2984, i \u2264 j \u2192 r (f i) (f j)) : Directed r f", "start": [106, 1], "end": [109, 41], "kind": "commanddeclaration"}, {"full_name": "Monotone.directed_le", "code": "theorem Monotone.directed_le [SemilatticeSup \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Monotone f \u2192 Directed (\u00b7 \u2264 \u00b7) f", "start": [112, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "Antitone.directed_ge", "code": "theorem Antitone.directed_ge [SemilatticeSup \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Directed (\u00b7 \u2265 \u00b7) f", "start": [117, 1], "end": [119, 21], "kind": "commanddeclaration"}, {"full_name": "directedOn_of_sup_mem", "code": "theorem directedOn_of_sup_mem [SemilatticeSup \u03b1] {S : Set \u03b1}\n    (H : \u2200 \u2983i j\u2984, i \u2208 S \u2192 j \u2208 S \u2192 i \u2294 j \u2208 S) : DirectedOn (\u00b7 \u2264 \u00b7) S", "start": [122, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "Directed.extend_bot", "code": "theorem Directed.extend_bot [Preorder \u03b1] [OrderBot \u03b1] {e : \u03b9 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1}\n    (hf : Directed (\u00b7 \u2264 \u00b7) f) (he : Function.Injective e) :\n    Directed (\u00b7 \u2264 \u00b7) (Function.extend e f \u22a5)", "start": [128, 1], "end": [140, 47], "kind": "commanddeclaration"}, {"full_name": "directed_of_inf", "code": "theorem directed_of_inf [SemilatticeInf \u03b1] {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 a\u2081 a\u2082, a\u2081 \u2264 a\u2082 \u2192 r (f a\u2082) (f a\u2081)) : Directed r f", "start": [143, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "Monotone.directed_ge", "code": "theorem Monotone.directed_ge [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    Directed (\u00b7 \u2265 \u00b7) f", "start": [149, 1], "end": [151, 21], "kind": "commanddeclaration"}, {"full_name": "Antitone.directed_le", "code": "theorem Antitone.directed_le [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    Directed (\u00b7 \u2264 \u00b7) f", "start": [154, 1], "end": [156, 21], "kind": "commanddeclaration"}, {"full_name": "directedOn_of_inf_mem", "code": "theorem directedOn_of_inf_mem [SemilatticeInf \u03b1] {S : Set \u03b1}\n    (H : \u2200 \u2983i j\u2984, i \u2208 S \u2192 j \u2208 S \u2192 i \u2293 j \u2208 S) : DirectedOn (\u00b7 \u2265 \u00b7) S", "start": [159, 1], "end": [162, 46], "kind": "commanddeclaration"}, {"full_name": "IsTotal.directed", "code": "theorem IsTotal.directed [IsTotal \u03b1 r] (f : \u03b9 \u2192 \u03b1) : Directed r f", "start": [165, 1], "end": [166, 88], "kind": "commanddeclaration"}, {"full_name": "IsDirected", "code": "class IsDirected (\u03b1 : Type*) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  \n  directed (a b : \u03b1) : \u2203 c, r a c \u2227 r b c", "start": [169, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "directed_of", "code": "theorem directed_of (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsDirected \u03b1 r] (a b : \u03b1) : \u2203 c, r a c \u2227 r b c", "start": [177, 1], "end": [178, 26], "kind": "commanddeclaration"}, {"full_name": "directed_id", "code": "theorem directed_id [IsDirected \u03b1 r] : Directed r id", "start": [181, 1], "end": [181, 81], "kind": "commanddeclaration"}, {"full_name": "directed_id_iff", "code": "theorem directed_id_iff : Directed r id \u2194 IsDirected \u03b1 r", "start": [184, 1], "end": [185, 35], "kind": "commanddeclaration"}, {"full_name": "directedOn_univ", "code": "theorem directedOn_univ [IsDirected \u03b1 r] : DirectedOn r Set.univ", "start": [188, 1], "end": [190, 19], "kind": "commanddeclaration"}, {"full_name": "directedOn_univ_iff", "code": "theorem directedOn_univ_iff : DirectedOn r Set.univ \u2194 IsDirected \u03b1 r", "start": [193, 1], "end": [198, 26], "kind": "commanddeclaration"}, {"full_name": "IsTotal.to_isDirected", "code": "instance (priority := 100) IsTotal.to_isDirected [IsTotal \u03b1 r] : IsDirected \u03b1 r := by\n  rw [\u2190 directed_id_iff]; exact IsTotal.directed _", "start": [202, 1], "end": [203, 51], "kind": "commanddeclaration"}, {"full_name": "isDirected_mono", "code": "theorem isDirected_mono [IsDirected \u03b1 r] (h : \u2200 \u2983a b\u2984, r a b \u2192 s a b) : IsDirected \u03b1 s", "start": [206, 1], "end": [209, 21], "kind": "commanddeclaration"}, {"full_name": "exists_ge_ge", "code": "theorem exists_ge_ge [LE \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] (a b : \u03b1) : \u2203 c, a \u2264 c \u2227 b \u2264 c", "start": [212, 1], "end": [213, 26], "kind": "commanddeclaration"}, {"full_name": "exists_le_le", "code": "theorem exists_le_le [LE \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] (a b : \u03b1) : \u2203 c, c \u2264 a \u2227 c \u2264 b", "start": [216, 1], "end": [217, 26], "kind": "commanddeclaration"}, {"full_name": "OrderDual.isDirected_ge", "code": "instance OrderDual.isDirected_ge [LE \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] : IsDirected \u03b1\u1d52\u1d48 (\u00b7 \u2265 \u00b7) := by\n  assumption", "start": [220, 1], "end": [221, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.isDirected_le", "code": "instance OrderDual.isDirected_le [LE \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] : IsDirected \u03b1\u1d52\u1d48 (\u00b7 \u2264 \u00b7) := by\n  assumption", "start": [224, 1], "end": [225, 13], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.insert", "code": "protected theorem DirectedOn.insert (h : Reflexive r) (a : \u03b1) {s : Set \u03b1} (hd : DirectedOn r s)\n    (ha : \u2200 b \u2208 s, \u2203 c \u2208 s, a \u227c c \u2227 b \u227c c) : DirectedOn r (insert a s)", "start": [230, 1], "end": [239, 48], "kind": "commanddeclaration"}, {"full_name": "directedOn_singleton", "code": "theorem directedOn_singleton (h : Reflexive r) (a : \u03b1) : DirectedOn r ({a} : Set \u03b1)", "start": [242, 1], "end": [243, 57], "kind": "commanddeclaration"}, {"full_name": "directedOn_pair", "code": "theorem directedOn_pair (h : Reflexive r) {a b : \u03b1} (hab : a \u227c b) : DirectedOn r ({a, b} : Set \u03b1)", "start": [246, 1], "end": [247, 80], "kind": "commanddeclaration"}, {"full_name": "directedOn_pair'", "code": "theorem directedOn_pair' (h : Reflexive r) {a b : \u03b1} (hab : a \u227c b) :\n    DirectedOn r ({b, a} : Set \u03b1)", "start": [250, 1], "end": [253, 30], "kind": "commanddeclaration"}, {"full_name": "IsMin.isBot", "code": "protected theorem IsMin.isBot [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] (h : IsMin a) : IsBot a", "start": [262, 1], "end": [264, 20], "kind": "commanddeclaration"}, {"full_name": "IsMax.isTop", "code": "protected theorem IsMax.isTop [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] (h : IsMax a) : IsTop a", "start": [267, 1], "end": [268, 17], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.is_bot_of_is_min", "code": "lemma DirectedOn.is_bot_of_is_min {s : Set \u03b1} (hd : DirectedOn (\u00b7 \u2265 \u00b7) s)\n    {m} (hm : m \u2208 s) (hmin : \u2200 a \u2208 s, a \u2264 m \u2192 m \u2264 a) : \u2200 a \u2208 s, m \u2264 a := fun a as =>\n  let \u27e8x, xs, xm, xa\u27e9 := hd m hm a as\n  (hmin x xs xm).trans xa", "start": [271, 1], "end": [274, 26], "kind": "mathlibtacticlemma"}, {"full_name": "DirectedOn.is_top_of_is_max", "code": "lemma DirectedOn.is_top_of_is_max {s : Set \u03b1} (hd : DirectedOn (\u00b7 \u2264 \u00b7) s)\n    {m} (hm : m \u2208 s) (hmax : \u2200 a \u2208 s, m \u2264 a \u2192 a \u2264 m) : \u2200 a \u2208 s, a \u2264 m :=\n  @DirectedOn.is_bot_of_is_min \u03b1\u1d52\u1d48 _ s hd m hm hmax", "start": [277, 1], "end": [279, 52], "kind": "mathlibtacticlemma"}, {"full_name": "isTop_or_exists_gt", "code": "theorem isTop_or_exists_gt [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] (a : \u03b1) : IsTop a \u2228 \u2203 b, a < b", "start": [282, 1], "end": [283, 50], "kind": "commanddeclaration"}, {"full_name": "isBot_or_exists_lt", "code": "theorem isBot_or_exists_lt [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] (a : \u03b1) : IsBot a \u2228 \u2203 b, b < a", "start": [286, 1], "end": [287, 32], "kind": "commanddeclaration"}, {"full_name": "isBot_iff_isMin", "code": "theorem isBot_iff_isMin [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] : IsBot a \u2194 IsMin a", "start": [290, 1], "end": [291, 29], "kind": "commanddeclaration"}, {"full_name": "isTop_iff_isMax", "code": "theorem isTop_iff_isMax [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] : IsTop a \u2194 IsMax a", "start": [294, 1], "end": [295, 29], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_directed_ge", "code": "theorem exists_lt_of_directed_ge [IsDirected \u03b2 (\u00b7 \u2265 \u00b7)] [Nontrivial \u03b2] : \u2203 a b : \u03b2, a < b", "start": [300, 1], "end": [303, 51], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_directed_le", "code": "theorem exists_lt_of_directed_le [IsDirected \u03b2 (\u00b7 \u2264 \u00b7)] [Nontrivial \u03b2] : \u2203 a b : \u03b2, a < b", "start": [306, 1], "end": [308, 12], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup.to_isDirected_le", "code": "instance (priority := 100) SemilatticeSup.to_isDirected_le [SemilatticeSup \u03b1] :\n    IsDirected \u03b1 (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b => \u27e8a \u2294 b, le_sup_left, le_sup_right\u27e9\u27e9", "start": [314, 1], "end": [316, 50], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.to_isDirected_ge", "code": "instance (priority := 100) SemilatticeInf.to_isDirected_ge [SemilatticeInf \u03b1] :\n    IsDirected \u03b1 (\u00b7 \u2265 \u00b7) :=\n  \u27e8fun a b => \u27e8a \u2293 b, inf_le_left, inf_le_right\u27e9\u27e9", "start": [320, 1], "end": [322, 50], "kind": "commanddeclaration"}, {"full_name": "OrderTop.to_isDirected_le", "code": "instance (priority := 100) OrderTop.to_isDirected_le [LE \u03b1] [OrderTop \u03b1] : IsDirected \u03b1 (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ => \u27e8\u22a4, le_top _, le_top _\u27e9\u27e9", "start": [326, 1], "end": [327, 39], "kind": "commanddeclaration"}, {"full_name": "OrderBot.to_isDirected_ge", "code": "instance (priority := 100) OrderBot.to_isDirected_ge [LE \u03b1] [OrderBot \u03b1] : IsDirected \u03b1 (\u00b7 \u2265 \u00b7) :=\n  \u27e8fun _ _ => \u27e8\u22a5, bot_le _, bot_le _\u27e9\u27e9", "start": [331, 1], "end": [332, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "imports": ["Mathlib/Data/Multiset/Basic.lean", "Mathlib/Data/List/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.prod", "code": "@[to_additive\n      \"Sum of a multiset given a commutative additive monoid structure on `\u03b1`.\n      `sum {a, b, c} = a + b + c`\"]\ndef prod : Multiset \u03b1 \u2192 \u03b1 :=\n  foldr (\u00b7 * \u00b7) (fun x y z => by simp [mul_left_comm]) 1", "start": [39, 1], "end": [45, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_foldr", "code": "@[to_additive]\ntheorem prod_eq_foldr (s : Multiset \u03b1) :\n    prod s = foldr (\u00b7 * \u00b7) (fun x y z => by simp [mul_left_comm]) 1 s", "start": [49, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_foldl", "code": "@[to_additive]\ntheorem prod_eq_foldl (s : Multiset \u03b1) :\n    prod s = foldl (\u00b7 * \u00b7) (fun x y z => by simp [mul_right_comm]) 1 s", "start": [56, 1], "end": [59, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_prod", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_prod (l : List \u03b1) : prod \u2191l = l.prod", "start": [63, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_toList", "code": "@[to_additive (attr := simp)]\ntheorem prod_toList (s : Multiset \u03b1) : s.toList.prod = s.prod", "start": [69, 1], "end": [72, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_zero", "code": "@[to_additive (attr := simp)]\ntheorem prod_zero : @prod \u03b1 _ 0 = 1", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_cons", "code": "@[to_additive (attr := simp)]\ntheorem prod_cons (a : \u03b1) (s) : prod (a ::\u2098 s) = a * prod s", "start": [82, 1], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_erase", "code": "@[to_additive (attr := simp)]\ntheorem prod_erase [DecidableEq \u03b1] (h : a \u2208 s) : a * (s.erase a).prod = s.prod", "start": [88, 1], "end": [90, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_erase", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_erase [DecidableEq \u03b9] {a : \u03b9} (h : a \u2208 m) :\n    f a * ((m.erase a).map f).prod = (m.map f).prod", "start": [94, 1], "end": [98, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_singleton", "code": "@[to_additive (attr := simp)]\ntheorem prod_singleton (a : \u03b1) : prod {a} = a", "start": [102, 1], "end": [104, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_pair", "code": "@[to_additive]\ntheorem prod_pair (a b : \u03b1) : ({a, b} : Multiset \u03b1).prod = a * b", "start": [108, 1], "end": [110, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_add", "code": "@[to_additive (attr := simp)]\ntheorem prod_add (s t : Multiset \u03b1) : prod (s + t) = prod s * prod t", "start": [114, 1], "end": [116, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_nsmul", "code": "@[to_additive]\ntheorem prod_nsmul (m : Multiset \u03b1) : \u2200 n : \u2115, (n \u2022 m).prod = m.prod ^ n", "start": [120, 1], "end": [125, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_replicate", "code": "@[to_additive (attr := simp)]\ntheorem prod_replicate (n : \u2115) (a : \u03b1) : (replicate n a).prod = a ^ n", "start": [128, 1], "end": [130, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_eq_pow_single", "code": "@[to_additive]\ntheorem prod_map_eq_pow_single [DecidableEq \u03b9] (i : \u03b9)\n    (hf : \u2200 (i') (_ : i' \u2260 i), i' \u2208 m \u2192 f i' = 1) : (m.map f).prod = f i ^ m.count i", "start": [134, 1], "end": [138, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_pow_single", "code": "@[to_additive]\ntheorem prod_eq_pow_single [DecidableEq \u03b1] (a : \u03b1) (h : \u2200 (a') (_ : a' \u2260 a), a' \u2208 s \u2192 a' = 1) :\n    s.prod = a ^ s.count a", "start": [142, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.pow_count", "code": "@[to_additive]\ntheorem pow_count [DecidableEq \u03b1] (a : \u03b1) : a ^ s.count a = (s.filter (Eq a)).prod", "start": [150, 1], "end": [152, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_hom", "code": "@[to_additive]\ntheorem prod_hom [CommMonoid \u03b2] (s : Multiset \u03b1) {F : Type*} [MonoidHomClass F \u03b1 \u03b2] (f : F) :\n    (s.map f).prod = f s.prod", "start": [156, 1], "end": [159, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_hom'", "code": "@[to_additive]\ntheorem prod_hom' [CommMonoid \u03b2] (s : Multiset \u03b9) {F : Type*} [MonoidHomClass F \u03b1 \u03b2] (f : F)\n    (g : \u03b9 \u2192 \u03b1) : (s.map fun i => f <| g i).prod = f (s.map g).prod", "start": [163, 1], "end": [167, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_hom\u2082", "code": "@[to_additive]\ntheorem prod_hom\u2082 [CommMonoid \u03b2] [CommMonoid \u03b3] (s : Multiset \u03b9) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hf : \u2200 a b c d, f (a * b) (c * d) = f a c * f b d) (hf' : f 1 1 = 1) (f\u2081 : \u03b9 \u2192 \u03b1)\n    (f\u2082 : \u03b9 \u2192 \u03b2) : (s.map fun i => f (f\u2081 i) (f\u2082 i)).prod = f (s.map f\u2081).prod (s.map f\u2082).prod", "start": [171, 1], "end": [176, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_hom_rel", "code": "@[to_additive]\ntheorem prod_hom_rel [CommMonoid \u03b2] (s : Multiset \u03b9) {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}\n    (h\u2081 : r 1 1) (h\u2082 : \u2200 \u2983a b c\u2984, r b c \u2192 r (f a * b) (g a * c)) :\n    r (s.map f).prod (s.map g).prod", "start": [180, 1], "end": [185, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_one", "code": "@[to_additive]\ntheorem prod_map_one : prod (m.map fun _ => (1 : \u03b1)) = 1", "start": [189, 1], "end": [191, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_mul", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_mul : (m.map fun i => f i * g i).prod = (m.map f).prod * (m.map g).prod", "start": [195, 1], "end": [197, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_neg", "code": "@[simp]\ntheorem prod_map_neg [HasDistribNeg \u03b1] (s : Multiset \u03b1) :\n    (s.map Neg.neg).prod = (-1) ^ card s * s.prod", "start": [201, 1], "end": [204, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_pow", "code": "@[to_additive]\ntheorem prod_map_pow {n : \u2115} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n", "start": [207, 1], "end": [209, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_prod_map", "code": "@[to_additive]\ntheorem prod_map_prod_map (m : Multiset \u03b2) (n : Multiset \u03b3) {f : \u03b2 \u2192 \u03b3 \u2192 \u03b1} :\n    prod (m.map fun a => prod <| n.map fun b => f a b) =\n      prod (n.map fun b => prod <| m.map fun a => f a b)", "start": [213, 1], "end": [217, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_induction", "code": "@[to_additive]\ntheorem prod_induction (p : \u03b1 \u2192 Prop) (s : Multiset \u03b1) (p_mul : \u2200 a b, p a \u2192 p b \u2192 p (a * b))\n    (p_one : p 1) (p_s : \u2200 a \u2208 s, p a) : p s.prod", "start": [221, 1], "end": [225, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_induction_nonempty", "code": "@[to_additive]\ntheorem prod_induction_nonempty (p : \u03b1 \u2192 Prop) (p_mul : \u2200 a b, p a \u2192 p b \u2192 p (a * b)) (hs : s \u2260 \u2205)\n    (p_s : \u2200 a \u2208 s, p a) : p s.prod", "start": [229, 1], "end": [239, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_dvd_prod_of_le", "code": "theorem prod_dvd_prod_of_le (h : s \u2264 t) : s.prod \u2223 t.prod", "start": [243, 1], "end": [245, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_dvd_prod_of_dvd", "code": "theorem prod_dvd_prod_of_dvd [CommMonoid \u03b2] {S : Multiset \u03b1} (g1 g2 : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a \u2208 S, g1 a \u2223 g2 a) : (Multiset.map g1 S).prod \u2223 (Multiset.map g2 S).prod", "start": [250, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.sumAddMonoidHom", "code": "def sumAddMonoidHom : Multiset \u03b1 \u2192+ \u03b1 where\n  toFun := sum\n  map_zero' := sum_zero\n  map_add' := sum_add", "start": [262, 1], "end": [267, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_sumAddMonoidHom", "code": "@[simp]\ntheorem coe_sumAddMonoidHom : (sumAddMonoidHom : Multiset \u03b1 \u2192 \u03b1) = sum", "start": [270, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_zero", "code": "theorem prod_eq_zero {s : Multiset \u03b1} (h : (0 : \u03b1) \u2208 s) : s.prod = 0", "start": [281, 1], "end": [283, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_zero_iff", "code": "theorem prod_eq_zero_iff : s.prod = 0 \u2194 (0 : \u03b1) \u2208 s", "start": [288, 1], "end": [291, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_ne_zero", "code": "theorem prod_ne_zero (h : (0 : \u03b1) \u2209 s) : s.prod \u2260 0", "start": [294, 1], "end": [295, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_inv'", "code": "@[to_additive]\ntheorem prod_map_inv' (m : Multiset \u03b1) : (m.map Inv.inv).prod = m.prod\u207b\u00b9", "start": [304, 1], "end": [306, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_inv", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_inv : (m.map fun i => (f i)\u207b\u00b9).prod = (m.map f).prod\u207b\u00b9", "start": [310, 1], "end": [313, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_div", "code": "@[to_additive (attr := simp)]\ntheorem prod_map_div : (m.map fun i => f i / g i).prod = (m.map f).prod / (m.map g).prod", "start": [317, 1], "end": [319, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_zpow", "code": "@[to_additive]\ntheorem prod_map_zpow {n : \u2124} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n", "start": [323, 1], "end": [326, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_map_mul_left", "code": "theorem sum_map_mul_left : sum (s.map fun i => a * f i) = a * sum (s.map f)", "start": [336, 1], "end": [337, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_map_mul_right", "code": "theorem sum_map_mul_right : sum (s.map fun i => f i * a) = sum (s.map f) * a", "start": [340, 1], "end": [341, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.dvd_sum", "code": "theorem dvd_sum {a : \u03b1} {s : Multiset \u03b1} : (\u2200 x \u2208 s, a \u2223 x) \u2192 a \u2223 s.sum", "start": [350, 1], "end": [353, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.one_le_prod_of_one_le", "code": "@[to_additive sum_nonneg]\ntheorem one_le_prod_of_one_le : (\u2200 x \u2208 s, (1 : \u03b1) \u2264 x) \u2192 1 \u2264 s.prod", "start": [365, 1], "end": [367, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.single_le_prod", "code": "@[to_additive]\ntheorem single_le_prod : (\u2200 x \u2208 s, (1 : \u03b1) \u2264 x) \u2192 \u2200 x \u2208 s, x \u2264 s.prod", "start": [371, 1], "end": [373, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_le_pow_card", "code": "@[to_additive sum_le_card_nsmul]\ntheorem prod_le_pow_card (s : Multiset \u03b1) (n : \u03b1) (h : \u2200 x \u2208 s, x \u2264 n) : s.prod \u2264 n ^ card s", "start": [377, 1], "end": [380, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.all_one_of_le_one_le_of_prod_eq_one", "code": "@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\ntheorem all_one_of_le_one_le_of_prod_eq_one :\n    (\u2200 x \u2208 s, (1 : \u03b1) \u2264 x) \u2192 s.prod = 1 \u2192 \u2200 x \u2208 s, x = (1 : \u03b1)", "start": [384, 1], "end": [389, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_le_prod_of_rel_le", "code": "@[to_additive]\ntheorem prod_le_prod_of_rel_le (h : s.Rel (\u00b7 \u2264 \u00b7) t) : s.prod \u2264 t.prod", "start": [393, 1], "end": [398, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_le_prod_map", "code": "@[to_additive]\ntheorem prod_map_le_prod_map {s : Multiset \u03b9} (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b1) (h : \u2200 i, i \u2208 s \u2192 f i \u2264 g i) :\n    (s.map f).prod \u2264 (s.map g).prod", "start": [402, 1], "end": [405, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_map_le_prod", "code": "@[to_additive]\ntheorem prod_map_le_prod (f : \u03b1 \u2192 \u03b1) (h : \u2200 x, x \u2208 s \u2192 f x \u2264 x) : (s.map f).prod \u2264 s.prod", "start": [409, 1], "end": [411, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_le_prod_map", "code": "@[to_additive]\ntheorem prod_le_prod_map (f : \u03b1 \u2192 \u03b1) (h : \u2200 x, x \u2208 s \u2192 x \u2264 f x) : s.prod \u2264 (s.map f).prod", "start": [415, 1], "end": [417, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.pow_card_le_prod", "code": "@[to_additive card_nsmul_le_sum]\ntheorem pow_card_le_prod (h : \u2200 x \u2208 s, a \u2264 x) : a ^ card s \u2264 s.prod", "start": [421, 1], "end": [424, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_nonneg", "code": "theorem prod_nonneg [OrderedCommSemiring \u03b1] {m : Multiset \u03b1} (h : \u2200 a \u2208 m, (0 : \u03b1) \u2264 a) :\n    0 \u2264 m.prod", "start": [430, 1], "end": [439, 91], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_one", "code": "@[to_additive\n      \"Slightly more general version of `Multiset.sum_eq_zero_iff` for a non-ordered `AddMonoid`\"]\ntheorem prod_eq_one [CommMonoid \u03b1] {m : Multiset \u03b1} (h : \u2200 x \u2208 m, x = (1 : \u03b1)) : m.prod = 1", "start": [442, 1], "end": [447, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_prod_of_mem", "code": "@[to_additive]\ntheorem le_prod_of_mem [CanonicallyOrderedCommMonoid \u03b1] {m : Multiset \u03b1} {a : \u03b1} (h : a \u2208 m) :\n    a \u2264 m.prod", "start": [451, 1], "end": [456, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_prod_of_submultiplicative_on_pred", "code": "@[to_additive le_sum_of_subadditive_on_pred]\ntheorem le_prod_of_submultiplicative_on_pred [CommMonoid \u03b1] [OrderedCommMonoid \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (p : \u03b1 \u2192 Prop) (h_one : f 1 = 1) (hp_one : p 1)\n    (h_mul : \u2200 a b, p a \u2192 p b \u2192 f (a * b) \u2264 f a * f b) (hp_mul : \u2200 a b, p a \u2192 p b \u2192 p (a * b))\n    (s : Multiset \u03b1) (hps : \u2200 a, a \u2208 s \u2192 p a) : f s.prod \u2264 (s.map f).prod", "start": [460, 1], "end": [472, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_prod_of_submultiplicative", "code": "@[to_additive le_sum_of_subadditive]\ntheorem le_prod_of_submultiplicative [CommMonoid \u03b1] [OrderedCommMonoid \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h_one : f 1 = 1) (h_mul : \u2200 a b, f (a * b) \u2264 f a * f b) (s : Multiset \u03b1) :\n    f s.prod \u2264 (s.map f).prod", "start": [476, 1], "end": [481, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_prod_nonempty_of_submultiplicative_on_pred", "code": "@[to_additive le_sum_nonempty_of_subadditive_on_pred]\ntheorem le_prod_nonempty_of_submultiplicative_on_pred [CommMonoid \u03b1] [OrderedCommMonoid \u03b2]\n    (f : \u03b1 \u2192 \u03b2) (p : \u03b1 \u2192 Prop) (h_mul : \u2200 a b, p a \u2192 p b \u2192 f (a * b) \u2264 f a * f b)\n    (hp_mul : \u2200 a b, p a \u2192 p b \u2192 p (a * b)) (s : Multiset \u03b1) (hs_nonempty : s \u2260 \u2205)\n    (hs : \u2200 a, a \u2208 s \u2192 p a) : f s.prod \u2264 (s.map f).prod", "start": [485, 1], "end": [502, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_prod_nonempty_of_submultiplicative", "code": "@[to_additive le_sum_nonempty_of_subadditive]\ntheorem le_prod_nonempty_of_submultiplicative [CommMonoid \u03b1] [OrderedCommMonoid \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h_mul : \u2200 a b, f (a * b) \u2264 f a * f b) (s : Multiset \u03b1) (hs_nonempty : s \u2260 \u2205) :\n    f s.prod \u2264 (s.map f).prod", "start": [506, 1], "end": [511, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_map_singleton", "code": "@[simp]\ntheorem sum_map_singleton (s : Multiset \u03b1) : (s.map fun a => ({a} : Multiset \u03b1)).sum = s", "start": [515, 1], "end": [517, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.abs_sum_le_sum_abs", "code": "theorem abs_sum_le_sum_abs [LinearOrderedAddCommGroup \u03b1] {s : Multiset \u03b1} :\n    abs s.sum \u2264 (s.map abs).sum", "start": [520, 1], "end": [522, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_nat_mod", "code": "theorem sum_nat_mod (s : Multiset \u2115) (n : \u2115) : s.sum % n = (s.map (\u00b7 % n)).sum % n", "start": [525, 1], "end": [526, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_nat_mod", "code": "theorem prod_nat_mod (s : Multiset \u2115) (n : \u2115) : s.prod % n = (s.map (\u00b7 % n)).prod % n", "start": [529, 1], "end": [530, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_int_mod", "code": "theorem sum_int_mod (s : Multiset \u2124) (n : \u2124) : s.sum % n = (s.map (\u00b7 % n)).sum % n", "start": [533, 1], "end": [534, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_int_mod", "code": "theorem prod_int_mod (s : Multiset \u2124) (n : \u2124) : s.prod % n = (s.map (\u00b7 % n)).prod % n", "start": [537, 1], "end": [538, 66], "kind": "commanddeclaration"}, {"full_name": "map_multiset_prod", "code": "@[to_additive]\ntheorem map_multiset_prod [CommMonoid \u03b1] [CommMonoid \u03b2] {F : Type*} [MonoidHomClass F \u03b1 \u03b2] (f : F)\n    (s : Multiset \u03b1) : f s.prod = (s.map f).prod", "start": [543, 1], "end": [546, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_multiset_prod", "code": "@[to_additive]\nprotected theorem MonoidHom.map_multiset_prod [CommMonoid \u03b1] [CommMonoid \u03b2] (f : \u03b1 \u2192* \u03b2)\n    (s : Multiset \u03b1) : f s.prod = (s.map f).prod", "start": [550, 1], "end": [553, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Mathport/Notation.lean", "imports": ["lake-packages/std/Std/Data/Option/Basic.lean", "Mathlib/Lean/Expr.lean", "Mathlib/Util/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Notation3.MatchState", "code": "structure MatchState where\n  \n  vars : HashMap Name (SubExpr \u00d7 LocalContext \u00d7 LocalInstances)\n  \n  scopeState : Option (Array (TSyntax ``extBinderParenthesized))\n  \n  foldState : HashMap Name (Array Term)", "start": [93, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.Matcher", "code": "def Matcher := MatchState \u2192 DelabM MatchState\n  deriving Inhabited", "start": [106, 1], "end": [108, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.empty", "code": "def MatchState.empty : MatchState where\n  vars := {}\n  scopeState := none\n  foldState := {}", "start": [110, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.withVar", "code": "def MatchState.withVar (s : MatchState) (name : Name)\n    (m : DelabM \u03b1) : DelabM \u03b1 := do\n  let some (se, lctx, linsts) := s.vars.find? name | failure\n  withLCtx lctx linsts <| withTheReader SubExpr (fun _ => se) <| m", "start": [116, 1], "end": [121, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.delabVar", "code": "def MatchState.delabVar (s : MatchState) (name : Name) (checkNot? : Option Expr := none) :\n    DelabM Term :=\n  s.withVar name do\n    if let some checkNot := checkNot? then\n      guard <| checkNot != (\u2190 getExpr)\n    delab", "start": [123, 1], "end": [131, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.captureSubexpr", "code": "def MatchState.captureSubexpr (s : MatchState) (name : Name) : DelabM MatchState := do\n  return {s with vars := s.vars.insert name (\u2190 readThe SubExpr, \u2190 getLCtx, \u2190 getLocalInstances)}", "start": [133, 1], "end": [135, 97], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.getFoldArray", "code": "def MatchState.getFoldArray (s : MatchState) (name : Name) : Array Term :=\n  (s.foldState.find? name).getD #[]", "start": [137, 1], "end": [140, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.getBinders", "code": "def MatchState.getBinders (s : MatchState) : Array (TSyntax ``extBinderParenthesized) :=\n  s.scopeState.getD #[]", "start": [142, 1], "end": [145, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.MatchState.pushFold", "code": "def MatchState.pushFold (s : MatchState) (name : Name) (t : Term) : MatchState :=\n  let ts := (s.getFoldArray name).push t\n  {s with foldState := s.foldState.insert name ts}", "start": [147, 1], "end": [150, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.matchVar", "code": "def matchVar (c : Name) : Matcher := fun s => do\n  if let some (se, _, _) := s.vars.find? c then\n    guard <| se.expr == (\u2190 getExpr)\n    return s\n  else\n    s.captureSubexpr c", "start": [152, 1], "end": [159, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.matchConst", "code": "def matchConst (c : Name) : Matcher := fun s => do\n  guard <| (\u2190 getExpr).isConstOf c\n  return s", "start": [161, 1], "end": [164, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.matchFVar", "code": "def matchFVar (userName : Name) : Matcher := fun s => do\n  let .fvar fvarId \u2190 getExpr | failure\n  guard <| userName == (\u2190 fvarId.getUserName)\n  return s", "start": [166, 1], "end": [171, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.natLitMatcher", "code": "def natLitMatcher (n : Nat) : Matcher := fun s => do\n  let mut e \u2190 getExpr\n  if e.isAppOfArity ``OfNat.ofNat 3 then\n    e := e.getArg! 1\n  guard <| e.natLit? == n\n  return s", "start": [173, 1], "end": [179, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.getExplicitArgIndices", "code": "def getExplicitArgIndices (f : Syntax) :\n    OptionT TermElabM (Option Name \u00d7 Term \u00d7 Nat \u00d7 Array Nat) := do\n  let fe? \u2190 try liftM <| Term.resolveId? f catch _ => pure none\n  match fe? with\n  | some fe@(.const f _) =>\n    return (some f, \u2190 ``(matchConst $(quote f)), \u2190 collectIdxs (\u2190 inferType fe))\n  | some fe@(.fvar fvarId) =>\n    let userName \u2190 fvarId.getUserName\n    return (none, \u2190 ``(matchFVar $(quote userName)), \u2190 collectIdxs (\u2190 inferType fe))\n  | _ =>\n    trace[notation3] \"could not resolve name {f}\"\n    failure\nwhere\n  collectIdxs (ty : Expr) : MetaM (Nat \u00d7 Array Nat) := do\n    let (_, binderInfos, _) \u2190 Meta.forallMetaTelescope ty\n    let mut idxs := #[]\n    for bi in binderInfos, i in [0:binderInfos.size] do\n      if bi.isExplicit then\n        idxs := idxs.push i\n    return (binderInfos.size, idxs)", "start": [181, 1], "end": [205, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.fnArgMatcher", "code": "def fnArgMatcher (arity : Nat) (matchf : Matcher) (matchers : Array (Nat \u00d7 Matcher)) :\n    Matcher := fun s => do\n  let mut s := s\n  let nargs := (\u2190 getExpr).getAppNumArgs\n  guard <| nargs == arity\n  s \u2190 withNaryFn <| matchf s\n  for (i, matcher) in matchers do\n    s \u2190 withNaryArg i <| matcher s\n  return s", "start": [207, 1], "end": [217, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.mkExprMatcher", "code": "partial def mkExprMatcher (stx : Term) (boundNames : HashSet Name) :\n    OptionT TermElabM (List Name \u00d7 Term) := do\n  let stx'? \u2190 liftM <| (liftMacroM <| expandMacro? stx : TermElabM (Option Syntax))\n  match stx'? with\n  | some stx' => mkExprMatcher \u27e8stx'\u27e9 boundNames\n  | none =>\n    match stx with\n    | `(_) => return ([], \u2190 `(pure))\n    | `($n:ident) =>\n      if boundNames.contains n.getId then\n        return ([], \u2190 ``(matchVar $(quote n.getId)))\n      else\n        processFn n #[]\n    | `($f:ident $args*) => processFn f args\n    | `(term| $n:num) => return ([], \u2190 ``(natLitMatcher $n))\n    | `(($stx)) =>\n      if Term.hasCDot stx then\n        failure\n      else\n        mkExprMatcher stx boundNames\n    | _ =>\n      trace[notation3] \"mkExprMatcher can't handle {stx}\"\n      failure\nwhere\n  processFn (f : Term) (args : TSyntaxArray `term) : OptionT TermElabM (List Name \u00d7 Term) := do\n    let (name?, matchf, arity, idxs) \u2190 getExplicitArgIndices f\n    unless args.size \u2264 idxs.size do\n      trace[notation3] \"Function {f} has been given more explicit arguments than expected\"\n      failure\n    let mut matchers := #[]\n    for i in idxs, arg in args do\n      let (_, matcher) \u2190 mkExprMatcher arg boundNames\n      matchers := matchers.push <| \u2190 `(($(quote i), $matcher))\n    let arity' := if _ : args.size < idxs.size then idxs[args.size] else arity\n    let key? := name?.map (`app ++ \u00b7)\n    return (key?.toList, \u2190 ``(fnArgMatcher $(quote arity') $matchf #[$matchers,*]))", "start": [219, 1], "end": [262, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.matchScoped", "code": "partial def matchScoped (lit scopeId : Name) (smatcher : Matcher) : Matcher := go #[] where\n  \n  go (binders : Array (TSyntax ``extBinderParenthesized)) : Matcher := fun s => do\n    s.withVar lit do\n    try\n      let s \u2190 smatcher {s with vars := s.vars.erase scopeId}\n      s.withVar scopeId do\n        guard (\u2190 getExpr).isLambda\n        let prop \u2190 try Meta.isProp (\u2190 getExpr).bindingDomain! catch _ => pure false\n        let isDep := (\u2190 getExpr).bindingBody!.hasLooseBVar 0\n        let ppTypes \u2190 getPPOption getPPPiBinderTypes let dom \u2190 withBindingDomain delab\n        withBindingBodyUnusedName <| fun x => do\n          let x : Ident := \u27e8x\u27e9\n          let binder \u2190\n            if prop && !isDep then\n              `(extBinderParenthesized|(_ : $dom))\n            else if prop || ppTypes then\n              `(extBinderParenthesized|($x:ident : $dom))\n            else\n              `(extBinderParenthesized|($x:ident))\n          let s \u2190 s.captureSubexpr lit\n          let binders := binders.push binder\n          go binders s\n    catch _ =>\n      guard <| !binders.isEmpty\n      if let some binders\u2082 := s.scopeState then\n        guard <| binders == binders\u2082 return s\n      else\n        return {s with scopeState := binders}", "start": [264, 1], "end": [305, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.mkScopedMatcher", "code": "partial def mkScopedMatcher (lit scopeId : Name) (scopedTerm : Term) (boundNames : HashSet Name) :\n    OptionT TermElabM (List Name \u00d7 Term) := do\n  let (keys, smatcher) \u2190 mkExprMatcher scopedTerm (boundNames.insert scopeId)\n  return (keys, \u2190 ``(matchScoped $(quote lit) $(quote scopeId) $smatcher))", "start": [311, 1], "end": [315, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.matchFoldl", "code": "partial def matchFoldl (lit x y : Name) (smatcher : Matcher) (sinit : Matcher) :\n    Matcher := fun s => do\n  s.withVar lit do\n    let expr \u2190 getExpr\n    let s := {s with vars := s.vars |>.erase x |>.erase y}\n    let some s \u2190 try some <$> smatcher s catch _ => pure none\n      | sinit s\n    let s := s.pushFold lit (\u2190 s.delabVar y expr)\n    let some newLit := s.vars.find? x | failure\n    if newLit.1.expr == expr then failure\n    let s := {s with vars := s.vars.insert lit newLit}\n    matchFoldl lit x y smatcher sinit s", "start": [317, 1], "end": [336, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.mkFoldlMatcher", "code": "partial def mkFoldlMatcher (lit x y : Name) (scopedTerm init : Term) (boundNames : HashSet Name) :\n    OptionT TermElabM (List Name \u00d7 Term) := do\n  let boundNames' := boundNames |>.insert x |>.insert y\n  let (keys, smatcher) \u2190 mkExprMatcher scopedTerm boundNames'\n  let (keys', sinit) \u2190 mkExprMatcher init boundNames\n  return (keys ++ keys', \u2190 ``(matchFoldl $(quote lit) $(quote x) $(quote y) $smatcher $sinit))", "start": [338, 1], "end": [346, 95], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.mkFoldrMatcher", "code": "partial def mkFoldrMatcher (lit x y : Name) (scopedTerm init : Term) (boundNames : HashSet Name) :\n    OptionT TermElabM (List Name \u00d7 Term) := do\n  let boundNames' := boundNames |>.insert x |>.insert y\n  let (keys, smatcher) \u2190 mkExprMatcher scopedTerm boundNames'\n  let (keys', sinit) \u2190 mkExprMatcher init boundNames\n  return (keys ++ keys', \u2190 ``(matchFoldl $(quote lit) $(quote y) $(quote x) $smatcher $sinit))", "start": [348, 1], "end": [357, 95], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.mkNameFromSyntax", "code": "def mkNameFromSyntax (name? : Option (TSyntax ``namedName))\n    (syntaxArgs : Array (TSyntax `stx)) (attrKind : TSyntax ``Term.attrKind) :\n    CommandElabM Name := do\n  if let some name := name? then\n    match name with\n    | `(namedName| (name := $n)) => return n.getId\n    | _ => pure ()\n  let name \u2190 liftMacroM <| mkNameFromParserSyntax `term (mkNullNode syntaxArgs)\n  addMacroScopeIfLocal name attrKind", "start": [361, 1], "end": [371, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.BoundValueType", "code": "inductive BoundValueType\n  \n  | normal\n  \n  | foldl\n  \n  | foldr", "start": [373, 1], "end": [381, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Notation3.getPrettyPrintOpt", "code": "def getPrettyPrintOpt (opt? : Option (TSyntax ``prettyPrintOpt)) : Bool :=\n  if let some opt := opt? then\n    match opt with\n    | `(prettyPrintOpt| (prettyPrint := false)) => false\n    | _ => true\n  else\n    true", "start": [385, 1], "end": [392, 9], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bool/Set.lean", "imports": ["Mathlib/Data/Set/Image.lean", "Mathlib/Data/Bool/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bool.univ_eq", "code": "@[simp]\ntheorem univ_eq : (univ : Set Bool) = {false, true}", "start": [22, 1], "end": [24, 42], "kind": "commanddeclaration"}, {"full_name": "Bool.range_eq", "code": "@[simp]\ntheorem range_eq {\u03b1 : Type*} (f : Bool \u2192 \u03b1) : range f = {f false, f true}", "start": [27, 1], "end": [29, 41], "kind": "commanddeclaration"}, {"full_name": "Bool.compl_singleton", "code": "@[simp] theorem compl_singleton (b : Bool) : ({b}\u1d9c : Set Bool) = {!b}", "start": [32, 1], "end": [33, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Set.lean", "imports": ["Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.zero_union_range_succ", "code": "theorem zero_union_range_succ : {0} \u222a range succ = univ", "start": [21, 1], "end": [23, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.range_succ", "code": "@[simp]\nprotected theorem range_succ : range succ = { i | 0 < i }", "start": [26, 1], "end": [28, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.range_of_succ", "code": "theorem range_of_succ (f : \u2115 \u2192 \u03b1) : {f 0} \u222a range (f \u2218 succ) = range f", "start": [33, 1], "end": [34, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.range_rec", "code": "theorem range_rec {\u03b1 : Type*} (x : \u03b1) (f : \u2115 \u2192 \u03b1 \u2192 \u03b1) :\n    (Set.range fun n => Nat.rec x f n : Set \u03b1) =\n      {x} \u222a Set.range fun n => Nat.rec (f 0 x) (f \u2218 succ) n", "start": [37, 1], "end": [46, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.range_casesOn", "code": "theorem range_casesOn {\u03b1 : Type*} (x : \u03b1) (f : \u2115 \u2192 \u03b1) :\n    (Set.range fun n => Nat.casesOn n x f : Set \u03b1) = {x} \u222a Set.range f", "start": [49, 1], "end": [51, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Bounds/Basic.lean", "imports": ["Mathlib/Order/Directed.lean", "Mathlib/Data/Set/NAry.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "upperBounds", "code": "def upperBounds (s : Set \u03b1) : Set \u03b1 :=\n  { x | \u2200 \u2983a\u2984, a \u2208 s \u2192 a \u2264 x }", "start": [45, 1], "end": [47, 31], "kind": "commanddeclaration"}, {"full_name": "lowerBounds", "code": "def lowerBounds (s : Set \u03b1) : Set \u03b1 :=\n  { x | \u2200 \u2983a\u2984, a \u2208 s \u2192 x \u2264 a }", "start": [50, 1], "end": [52, 31], "kind": "commanddeclaration"}, {"full_name": "BddAbove", "code": "def BddAbove (s : Set \u03b1) :=\n  (upperBounds s).Nonempty", "start": [55, 1], "end": [57, 27], "kind": "commanddeclaration"}, {"full_name": "BddBelow", "code": "def BddBelow (s : Set \u03b1) :=\n  (lowerBounds s).Nonempty", "start": [60, 1], "end": [62, 27], "kind": "commanddeclaration"}, {"full_name": "IsLeast", "code": "def IsLeast (s : Set \u03b1) (a : \u03b1) : Prop :=\n  a \u2208 s \u2227 a \u2208 lowerBounds s", "start": [65, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "IsGreatest", "code": "def IsGreatest (s : Set \u03b1) (a : \u03b1) : Prop :=\n  a \u2208 s \u2227 a \u2208 upperBounds s", "start": [70, 1], "end": [72, 28], "kind": "commanddeclaration"}, {"full_name": "IsLUB", "code": "def IsLUB (s : Set \u03b1) : \u03b1 \u2192 Prop :=\n  IsLeast (upperBounds s)", "start": [75, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "IsGLB", "code": "def IsGLB (s : Set \u03b1) : \u03b1 \u2192 Prop :=\n  IsGreatest (lowerBounds s)", "start": [80, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "mem_upperBounds", "code": "theorem mem_upperBounds : a \u2208 upperBounds s \u2194 \u2200 x \u2208 s, x \u2264 a", "start": [85, 1], "end": [86, 10], "kind": "commanddeclaration"}, {"full_name": "mem_lowerBounds", "code": "theorem mem_lowerBounds : a \u2208 lowerBounds s \u2194 \u2200 x \u2208 s, a \u2264 x", "start": [89, 1], "end": [90, 10], "kind": "commanddeclaration"}, {"full_name": "bddAbove_def", "code": "theorem bddAbove_def : BddAbove s \u2194 \u2203 x, \u2200 y \u2208 s, y \u2264 x", "start": [93, 1], "end": [94, 10], "kind": "commanddeclaration"}, {"full_name": "bddBelow_def", "code": "theorem bddBelow_def : BddBelow s \u2194 \u2203 x, \u2200 y \u2208 s, x \u2264 y", "start": [97, 1], "end": [98, 10], "kind": "commanddeclaration"}, {"full_name": "bot_mem_lowerBounds", "code": "theorem bot_mem_lowerBounds [OrderBot \u03b1] (s : Set \u03b1) : \u22a5 \u2208 lowerBounds s", "start": [101, 1], "end": [101, 94], "kind": "commanddeclaration"}, {"full_name": "top_mem_upperBounds", "code": "theorem top_mem_upperBounds [OrderTop \u03b1] (s : Set \u03b1) : \u22a4 \u2208 upperBounds s", "start": [104, 1], "end": [104, 94], "kind": "commanddeclaration"}, {"full_name": "isLeast_bot_iff", "code": "@[simp]\ntheorem isLeast_bot_iff [OrderBot \u03b1] : IsLeast s \u22a5 \u2194 \u22a5 \u2208 s", "start": [107, 1], "end": [109, 40], "kind": "commanddeclaration"}, {"full_name": "isGreatest_top_iff", "code": "@[simp]\ntheorem isGreatest_top_iff [OrderTop \u03b1] : IsGreatest s \u22a4 \u2194 \u22a4 \u2208 s", "start": [112, 1], "end": [114, 40], "kind": "commanddeclaration"}, {"full_name": "not_bddAbove_iff'", "code": "theorem not_bddAbove_iff' : \u00acBddAbove s \u2194 \u2200 x, \u2203 y \u2208 s, \u00acy \u2264 x", "start": [117, 1], "end": [121, 45], "kind": "commanddeclaration"}, {"full_name": "not_bddBelow_iff'", "code": "theorem not_bddBelow_iff' : \u00acBddBelow s \u2194 \u2200 x, \u2203 y \u2208 s, \u00acx \u2264 y", "start": [124, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "not_bddAbove_iff", "code": "theorem not_bddAbove_iff {\u03b1 : Type*} [LinearOrder \u03b1] {s : Set \u03b1} :\n    \u00acBddAbove s \u2194 \u2200 x, \u2203 y \u2208 s, x < y", "start": [131, 1], "end": [135, 40], "kind": "commanddeclaration"}, {"full_name": "not_bddBelow_iff", "code": "theorem not_bddBelow_iff {\u03b1 : Type*} [LinearOrder \u03b1] {s : Set \u03b1} :\n    \u00acBddBelow s \u2194 \u2200 x, \u2203 y \u2208 s, y < x", "start": [138, 1], "end": [142, 28], "kind": "commanddeclaration"}, {"full_name": "BddAbove.dual", "code": "theorem BddAbove.dual (h : BddAbove s) : BddBelow (ofDual \u207b\u00b9' s)", "start": [145, 1], "end": [146, 4], "kind": "commanddeclaration"}, {"full_name": "BddBelow.dual", "code": "theorem BddBelow.dual (h : BddBelow s) : BddAbove (ofDual \u207b\u00b9' s)", "start": [149, 1], "end": [150, 4], "kind": "commanddeclaration"}, {"full_name": "IsLeast.dual", "code": "theorem IsLeast.dual (h : IsLeast s a) : IsGreatest (ofDual \u207b\u00b9' s) (toDual a)", "start": [153, 1], "end": [154, 4], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.dual", "code": "theorem IsGreatest.dual (h : IsGreatest s a) : IsLeast (ofDual \u207b\u00b9' s) (toDual a)", "start": [157, 1], "end": [158, 4], "kind": "commanddeclaration"}, {"full_name": "IsLUB.dual", "code": "theorem IsLUB.dual (h : IsLUB s a) : IsGLB (ofDual \u207b\u00b9' s) (toDual a)", "start": [161, 1], "end": [162, 4], "kind": "commanddeclaration"}, {"full_name": "IsGLB.dual", "code": "theorem IsGLB.dual (h : IsGLB s a) : IsLUB (ofDual \u207b\u00b9' s) (toDual a)", "start": [165, 1], "end": [166, 4], "kind": "commanddeclaration"}, {"full_name": "IsLeast.orderBot", "code": "@[reducible]\ndef IsLeast.orderBot (h : IsLeast s a) :\n    OrderBot s where\n  bot := \u27e8a, h.1\u27e9\n  bot_le := Subtype.forall.2 h.2", "start": [169, 1], "end": [174, 33], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.orderTop", "code": "@[reducible]\ndef IsGreatest.orderTop (h : IsGreatest s a) :\n    OrderTop s where\n  top := \u27e8a, h.1\u27e9\n  le_top := Subtype.forall.2 h.2", "start": [177, 1], "end": [182, 33], "kind": "commanddeclaration"}, {"full_name": "upperBounds_mono_set", "code": "theorem upperBounds_mono_set \u2983s t : Set \u03b1\u2984 (hst : s \u2286 t) : upperBounds t \u2286 upperBounds s", "start": [190, 1], "end": [191, 30], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_mono_set", "code": "theorem lowerBounds_mono_set \u2983s t : Set \u03b1\u2984 (hst : s \u2286 t) : lowerBounds t \u2286 lowerBounds s", "start": [194, 1], "end": [195, 30], "kind": "commanddeclaration"}, {"full_name": "upperBounds_mono_mem", "code": "theorem upperBounds_mono_mem \u2983a b\u2984 (hab : a \u2264 b) : a \u2208 upperBounds s \u2192 b \u2208 upperBounds s", "start": [198, 1], "end": [199, 36], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_mono_mem", "code": "theorem lowerBounds_mono_mem \u2983a b\u2984 (hab : a \u2264 b) : b \u2208 lowerBounds s \u2192 a \u2208 lowerBounds s", "start": [202, 1], "end": [203, 36], "kind": "commanddeclaration"}, {"full_name": "upperBounds_mono", "code": "theorem upperBounds_mono \u2983s t : Set \u03b1\u2984 (hst : s \u2286 t) \u2983a b\u2984 (hab : a \u2264 b) :\n    a \u2208 upperBounds t \u2192 b \u2208 upperBounds s", "start": [206, 1], "end": [208, 58], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_mono", "code": "theorem lowerBounds_mono \u2983s t : Set \u03b1\u2984 (hst : s \u2286 t) \u2983a b\u2984 (hab : a \u2264 b) :\n    b \u2208 lowerBounds t \u2192 a \u2208 lowerBounds s", "start": [211, 1], "end": [213, 58], "kind": "commanddeclaration"}, {"full_name": "BddAbove.mono", "code": "theorem BddAbove.mono \u2983s t : Set \u03b1\u2984 (h : s \u2286 t) : BddAbove t \u2192 BddAbove s", "start": [216, 1], "end": [218, 42], "kind": "commanddeclaration"}, {"full_name": "BddBelow.mono", "code": "theorem BddBelow.mono \u2983s t : Set \u03b1\u2984 (h : s \u2286 t) : BddBelow t \u2192 BddBelow s", "start": [221, 1], "end": [223, 42], "kind": "commanddeclaration"}, {"full_name": "IsLUB.of_subset_of_superset", "code": "theorem IsLUB.of_subset_of_superset {s t p : Set \u03b1} (hs : IsLUB s a) (hp : IsLUB p a) (hst : s \u2286 t)\n    (htp : t \u2286 p) : IsLUB t a", "start": [226, 1], "end": [230, 88], "kind": "commanddeclaration"}, {"full_name": "IsGLB.of_subset_of_superset", "code": "theorem IsGLB.of_subset_of_superset {s t p : Set \u03b1} (hs : IsGLB s a) (hp : IsGLB p a) (hst : s \u2286 t)\n    (htp : t \u2286 p) : IsGLB t a", "start": [233, 1], "end": [237, 43], "kind": "commanddeclaration"}, {"full_name": "IsLeast.mono", "code": "theorem IsLeast.mono (ha : IsLeast s a) (hb : IsLeast t b) (hst : s \u2286 t) : b \u2264 a", "start": [240, 1], "end": [241, 18], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.mono", "code": "theorem IsGreatest.mono (ha : IsGreatest s a) (hb : IsGreatest t b) (hst : s \u2286 t) : a \u2264 b", "start": [244, 1], "end": [245, 18], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mono", "code": "theorem IsLUB.mono (ha : IsLUB s a) (hb : IsLUB t b) (hst : s \u2286 t) : a \u2264 b", "start": [248, 1], "end": [249, 49], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mono", "code": "theorem IsGLB.mono (ha : IsGLB s a) (hb : IsGLB t b) (hst : s \u2286 t) : b \u2264 a", "start": [252, 1], "end": [253, 52], "kind": "commanddeclaration"}, {"full_name": "subset_lowerBounds_upperBounds", "code": "theorem subset_lowerBounds_upperBounds (s : Set \u03b1) : s \u2286 lowerBounds (upperBounds s)", "start": [256, 1], "end": [257, 25], "kind": "commanddeclaration"}, {"full_name": "subset_upperBounds_lowerBounds", "code": "theorem subset_upperBounds_lowerBounds (s : Set \u03b1) : s \u2286 upperBounds (lowerBounds s)", "start": [260, 1], "end": [261, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.bddAbove_lowerBounds", "code": "theorem Set.Nonempty.bddAbove_lowerBounds (hs : s.Nonempty) : BddAbove (lowerBounds s)", "start": [264, 1], "end": [265, 45], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.bddBelow_upperBounds", "code": "theorem Set.Nonempty.bddBelow_upperBounds (hs : s.Nonempty) : BddBelow (upperBounds s)", "start": [268, 1], "end": [269, 45], "kind": "commanddeclaration"}, {"full_name": "IsLeast.isGLB", "code": "theorem IsLeast.isGLB (h : IsLeast s a) : IsGLB s a", "start": [277, 1], "end": [278, 28], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.isLUB", "code": "theorem IsGreatest.isLUB (h : IsGreatest s a) : IsLUB s a", "start": [281, 1], "end": [282, 28], "kind": "commanddeclaration"}, {"full_name": "IsLUB.upperBounds_eq", "code": "theorem IsLUB.upperBounds_eq (h : IsLUB s a) : upperBounds s = Ici a", "start": [285, 1], "end": [286, 77], "kind": "commanddeclaration"}, {"full_name": "IsGLB.lowerBounds_eq", "code": "theorem IsGLB.lowerBounds_eq (h : IsGLB s a) : lowerBounds s = Iic a", "start": [289, 1], "end": [290, 24], "kind": "commanddeclaration"}, {"full_name": "IsLeast.lowerBounds_eq", "code": "theorem IsLeast.lowerBounds_eq (h : IsLeast s a) : lowerBounds s = Iic a", "start": [293, 1], "end": [294, 25], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.upperBounds_eq", "code": "theorem IsGreatest.upperBounds_eq (h : IsGreatest s a) : upperBounds s = Ici a", "start": [297, 1], "end": [298, 25], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.lt_iff", "code": "theorem IsGreatest.lt_iff (h : IsGreatest s a) : a < b \u2194 \u2200 x \u2208 s, x < b", "start": [302, 1], "end": [303, 63], "kind": "commanddeclaration"}, {"full_name": "IsLeast.lt_iff", "code": "theorem IsLeast.lt_iff (h : IsLeast s a) : b < a \u2194 \u2200 x \u2208 s, b < x", "start": [306, 1], "end": [307, 16], "kind": "commanddeclaration"}, {"full_name": "isLUB_le_iff", "code": "theorem isLUB_le_iff (h : IsLUB s a) : a \u2264 b \u2194 b \u2208 upperBounds s", "start": [309, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "le_isGLB_iff", "code": "theorem le_isGLB_iff (h : IsGLB s a) : b \u2264 a \u2194 b \u2208 lowerBounds s", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "isLUB_iff_le_iff", "code": "theorem isLUB_iff_le_iff : IsLUB s a \u2194 \u2200 b, a \u2264 b \u2194 b \u2208 upperBounds s", "start": [319, 1], "end": [320, 81], "kind": "commanddeclaration"}, {"full_name": "isGLB_iff_le_iff", "code": "theorem isGLB_iff_le_iff : IsGLB s a \u2194 \u2200 b, b \u2264 a \u2194 b \u2208 lowerBounds s", "start": [323, 1], "end": [324, 30], "kind": "commanddeclaration"}, {"full_name": "IsLUB.bddAbove", "code": "theorem IsLUB.bddAbove (h : IsLUB s a) : BddAbove s", "start": [327, 1], "end": [329, 11], "kind": "commanddeclaration"}, {"full_name": "IsGLB.bddBelow", "code": "theorem IsGLB.bddBelow (h : IsGLB s a) : BddBelow s", "start": [332, 1], "end": [334, 11], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.bddAbove", "code": "theorem IsGreatest.bddAbove (h : IsGreatest s a) : BddAbove s", "start": [337, 1], "end": [339, 11], "kind": "commanddeclaration"}, {"full_name": "IsLeast.bddBelow", "code": "theorem IsLeast.bddBelow (h : IsLeast s a) : BddBelow s", "start": [342, 1], "end": [344, 11], "kind": "commanddeclaration"}, {"full_name": "IsLeast.nonempty", "code": "theorem IsLeast.nonempty (h : IsLeast s a) : s.Nonempty", "start": [347, 1], "end": [348, 11], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.nonempty", "code": "theorem IsGreatest.nonempty (h : IsGreatest s a) : s.Nonempty", "start": [351, 1], "end": [352, 11], "kind": "commanddeclaration"}, {"full_name": "upperBounds_union", "code": "@[simp]\ntheorem upperBounds_union : upperBounds (s \u222a t) = upperBounds s \u2229 upperBounds t", "start": [359, 1], "end": [362, 67], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_union", "code": "@[simp]\ntheorem lowerBounds_union : lowerBounds (s \u222a t) = lowerBounds s \u2229 lowerBounds t", "start": [365, 1], "end": [367, 31], "kind": "commanddeclaration"}, {"full_name": "union_upperBounds_subset_upperBounds_inter", "code": "theorem union_upperBounds_subset_upperBounds_inter :\n    upperBounds s \u222a upperBounds t \u2286 upperBounds (s \u2229 t)", "start": [370, 1], "end": [373, 53], "kind": "commanddeclaration"}, {"full_name": "union_lowerBounds_subset_lowerBounds_inter", "code": "theorem union_lowerBounds_subset_lowerBounds_inter :\n    lowerBounds s \u222a lowerBounds t \u2286 lowerBounds (s \u2229 t)", "start": [376, 1], "end": [378, 56], "kind": "commanddeclaration"}, {"full_name": "isLeast_union_iff", "code": "theorem isLeast_union_iff {a : \u03b1} {s t : Set \u03b1} :\n    IsLeast (s \u222a t) a \u2194 IsLeast s a \u2227 a \u2208 lowerBounds t \u2228 a \u2208 lowerBounds s \u2227 IsLeast t a", "start": [381, 1], "end": [383, 84], "kind": "commanddeclaration"}, {"full_name": "isGreatest_union_iff", "code": "theorem isGreatest_union_iff :\n    IsGreatest (s \u222a t) a \u2194\n      IsGreatest s a \u2227 a \u2208 upperBounds t \u2228 a \u2208 upperBounds s \u2227 IsGreatest t a", "start": [386, 1], "end": [389, 33], "kind": "commanddeclaration"}, {"full_name": "BddAbove.inter_of_left", "code": "theorem BddAbove.inter_of_left (h : BddAbove s) : BddAbove (s \u2229 t)", "start": [392, 1], "end": [394, 34], "kind": "commanddeclaration"}, {"full_name": "BddAbove.inter_of_right", "code": "theorem BddAbove.inter_of_right (h : BddAbove t) : BddAbove (s \u2229 t)", "start": [397, 1], "end": [399, 35], "kind": "commanddeclaration"}, {"full_name": "BddBelow.inter_of_left", "code": "theorem BddBelow.inter_of_left (h : BddBelow s) : BddBelow (s \u2229 t)", "start": [402, 1], "end": [404, 34], "kind": "commanddeclaration"}, {"full_name": "BddBelow.inter_of_right", "code": "theorem BddBelow.inter_of_right (h : BddBelow t) : BddBelow (s \u2229 t)", "start": [407, 1], "end": [409, 35], "kind": "commanddeclaration"}, {"full_name": "BddAbove.union", "code": "theorem BddAbove.union [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {s t : Set \u03b1} :\n    BddAbove s \u2192 BddAbove t \u2192 BddAbove (s \u222a t)", "start": [412, 1], "end": [418, 70], "kind": "commanddeclaration"}, {"full_name": "bddAbove_union", "code": "theorem bddAbove_union [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {s t : Set \u03b1} :\n    BddAbove (s \u222a t) \u2194 BddAbove s \u2227 BddAbove t", "start": [421, 1], "end": [425, 19], "kind": "commanddeclaration"}, {"full_name": "BddBelow.union", "code": "theorem BddBelow.union [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {s t : Set \u03b1} :\n    BddBelow s \u2192 BddBelow t \u2192 BddBelow (s \u222a t)", "start": [428, 1], "end": [431, 30], "kind": "commanddeclaration"}, {"full_name": "bddBelow_union", "code": "theorem bddBelow_union [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {s t : Set \u03b1} :\n    BddBelow (s \u222a t) \u2194 BddBelow s \u2227 BddBelow t", "start": [434, 1], "end": [437, 30], "kind": "commanddeclaration"}, {"full_name": "IsLUB.union", "code": "theorem IsLUB.union [SemilatticeSup \u03b3] {a b : \u03b3} {s t : Set \u03b3} (hs : IsLUB s a) (ht : IsLUB t b) :\n    IsLUB (s \u222a t) (a \u2294 b)", "start": [440, 1], "end": [447, 90], "kind": "commanddeclaration"}, {"full_name": "IsGLB.union", "code": "theorem IsGLB.union [SemilatticeInf \u03b3] {a\u2081 a\u2082 : \u03b3} {s t : Set \u03b3} (hs : IsGLB s a\u2081)\n    (ht : IsGLB t a\u2082) : IsGLB (s \u222a t) (a\u2081 \u2293 a\u2082)", "start": [450, 1], "end": [454, 19], "kind": "commanddeclaration"}, {"full_name": "IsLeast.union", "code": "theorem IsLeast.union [LinearOrder \u03b3] {a b : \u03b3} {s t : Set \u03b3} (ha : IsLeast s a)\n    (hb : IsLeast t b) : IsLeast (s \u222a t) (min a b)", "start": [457, 1], "end": [461, 90], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.union", "code": "theorem IsGreatest.union [LinearOrder \u03b3] {a b : \u03b3} {s t : Set \u03b3} (ha : IsGreatest s a)\n    (hb : IsGreatest t b) : IsGreatest (s \u222a t) (max a b)", "start": [464, 1], "end": [468, 90], "kind": "commanddeclaration"}, {"full_name": "IsLUB.inter_Ici_of_mem", "code": "theorem IsLUB.inter_Ici_of_mem [LinearOrder \u03b3] {s : Set \u03b3} {a b : \u03b3} (ha : IsLUB s a) (hb : b \u2208 s) :\n    IsLUB (s \u2229 Ici b) a", "start": [471, 1], "end": [475, 93], "kind": "commanddeclaration"}, {"full_name": "IsGLB.inter_Iic_of_mem", "code": "theorem IsGLB.inter_Iic_of_mem [LinearOrder \u03b3] {s : Set \u03b3} {a b : \u03b3} (ha : IsGLB s a) (hb : b \u2208 s) :\n    IsGLB (s \u2229 Iic b) a", "start": [478, 1], "end": [480, 30], "kind": "commanddeclaration"}, {"full_name": "bddAbove_iff_exists_ge", "code": "theorem bddAbove_iff_exists_ge [SemilatticeSup \u03b3] {s : Set \u03b3} (x\u2080 : \u03b3) :\n    BddAbove s \u2194 \u2203 x, x\u2080 \u2264 x \u2227 \u2200 y \u2208 s, y \u2264 x", "start": [483, 1], "end": [486, 45], "kind": "commanddeclaration"}, {"full_name": "bddBelow_iff_exists_le", "code": "theorem bddBelow_iff_exists_le [SemilatticeInf \u03b3] {s : Set \u03b3} (x\u2080 : \u03b3) :\n    BddBelow s \u2194 \u2203 x, x \u2264 x\u2080 \u2227 \u2200 y \u2208 s, x \u2264 y", "start": [489, 1], "end": [491, 37], "kind": "commanddeclaration"}, {"full_name": "BddAbove.exists_ge", "code": "theorem BddAbove.exists_ge [SemilatticeSup \u03b3] {s : Set \u03b3} (hs : BddAbove s) (x\u2080 : \u03b3) :\n    \u2203 x, x\u2080 \u2264 x \u2227 \u2200 y \u2208 s, y \u2264 x", "start": [494, 1], "end": [496, 36], "kind": "commanddeclaration"}, {"full_name": "BddBelow.exists_le", "code": "theorem BddBelow.exists_le [SemilatticeInf \u03b3] {s : Set \u03b3} (hs : BddBelow s) (x\u2080 : \u03b3) :\n    \u2203 x, x \u2264 x\u2080 \u2227 \u2200 y \u2208 s, x \u2264 y", "start": [499, 1], "end": [501, 36], "kind": "commanddeclaration"}, {"full_name": "isLeast_Ici", "code": "theorem isLeast_Ici : IsLeast (Ici a) a", "start": [510, 1], "end": [511, 30], "kind": "commanddeclaration"}, {"full_name": "isGreatest_Iic", "code": "theorem isGreatest_Iic : IsGreatest (Iic a) a", "start": [514, 1], "end": [515, 31], "kind": "commanddeclaration"}, {"full_name": "isLUB_Iic", "code": "theorem isLUB_Iic : IsLUB (Iic a) a", "start": [518, 1], "end": [519, 23], "kind": "commanddeclaration"}, {"full_name": "isGLB_Ici", "code": "theorem isGLB_Ici : IsGLB (Ici a) a", "start": [522, 1], "end": [523, 20], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Iic", "code": "theorem upperBounds_Iic : upperBounds (Iic a) = Ici a", "start": [526, 1], "end": [527, 27], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Ici", "code": "theorem lowerBounds_Ici : lowerBounds (Ici a) = Iic a", "start": [530, 1], "end": [531, 27], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Iic", "code": "theorem bddAbove_Iic : BddAbove (Iic a)", "start": [534, 1], "end": [535, 21], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Ici", "code": "theorem bddBelow_Ici : BddBelow (Ici a)", "start": [538, 1], "end": [539, 21], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Iio", "code": "theorem bddAbove_Iio : BddAbove (Iio a)", "start": [542, 1], "end": [543, 31], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Ioi", "code": "theorem bddBelow_Ioi : BddBelow (Ioi a)", "start": [546, 1], "end": [547, 31], "kind": "commanddeclaration"}, {"full_name": "lub_Iio_le", "code": "theorem lub_Iio_le (a : \u03b1) (hb : IsLUB (Iio a) b) : b \u2264 a", "start": [550, 1], "end": [551, 48], "kind": "commanddeclaration"}, {"full_name": "le_glb_Ioi", "code": "theorem le_glb_Ioi (a : \u03b1) (hb : IsGLB (Ioi a) b) : a \u2264 b", "start": [554, 1], "end": [555, 27], "kind": "commanddeclaration"}, {"full_name": "lub_Iio_eq_self_or_Iio_eq_Iic", "code": "theorem lub_Iio_eq_self_or_Iio_eq_Iic [PartialOrder \u03b3] {j : \u03b3} (i : \u03b3) (hj : IsLUB (Iio i) j) :\n    j = i \u2228 Iio i = Iic j", "start": [558, 1], "end": [563, 100], "kind": "commanddeclaration"}, {"full_name": "glb_Ioi_eq_self_or_Ioi_eq_Ici", "code": "theorem glb_Ioi_eq_self_or_Ioi_eq_Ici [PartialOrder \u03b3] {j : \u03b3} (i : \u03b3) (hj : IsGLB (Ioi i) j) :\n    j = i \u2228 Ioi i = Ici j", "start": [566, 1], "end": [568, 46], "kind": "commanddeclaration"}, {"full_name": "exists_lub_Iio", "code": "theorem exists_lub_Iio (i : \u03b3) : \u2203 j, IsLUB (Iio i) j", "start": [575, 1], "end": [584, 12], "kind": "commanddeclaration"}, {"full_name": "exists_glb_Ioi", "code": "theorem exists_glb_Ioi (i : \u03b3) : \u2203 j, IsGLB (Ioi i) j", "start": [587, 1], "end": [588, 26], "kind": "commanddeclaration"}, {"full_name": "isLUB_Iio", "code": "theorem isLUB_Iio {a : \u03b3} : IsLUB (Iio a) a", "start": [593, 1], "end": [594, 69], "kind": "commanddeclaration"}, {"full_name": "isGLB_Ioi", "code": "theorem isGLB_Ioi {a : \u03b3} : IsGLB (Ioi a) a", "start": [597, 1], "end": [598, 23], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Iio", "code": "theorem upperBounds_Iio {a : \u03b3} : upperBounds (Iio a) = Ici a", "start": [601, 1], "end": [602, 27], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Ioi", "code": "theorem lowerBounds_Ioi {a : \u03b3} : lowerBounds (Ioi a) = Iic a", "start": [605, 1], "end": [606, 27], "kind": "commanddeclaration"}, {"full_name": "isGreatest_singleton", "code": "theorem isGreatest_singleton : IsGreatest {a} a", "start": [616, 1], "end": [617, 68], "kind": "commanddeclaration"}, {"full_name": "isLeast_singleton", "code": "theorem isLeast_singleton : IsLeast {a} a", "start": [620, 1], "end": [621, 32], "kind": "commanddeclaration"}, {"full_name": "isLUB_singleton", "code": "theorem isLUB_singleton : IsLUB {a} a", "start": [624, 1], "end": [625, 29], "kind": "commanddeclaration"}, {"full_name": "isGLB_singleton", "code": "theorem isGLB_singleton : IsGLB {a} a", "start": [628, 1], "end": [629, 26], "kind": "commanddeclaration"}, {"full_name": "bddAbove_singleton", "code": "theorem bddAbove_singleton : BddAbove ({a} : Set \u03b1)", "start": [632, 1], "end": [633, 27], "kind": "commanddeclaration"}, {"full_name": "bddBelow_singleton", "code": "theorem bddBelow_singleton : BddBelow ({a} : Set \u03b1)", "start": [636, 1], "end": [637, 27], "kind": "commanddeclaration"}, {"full_name": "upperBounds_singleton", "code": "@[simp]\ntheorem upperBounds_singleton : upperBounds {a} = Ici a", "start": [640, 1], "end": [642, 33], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_singleton", "code": "@[simp]\ntheorem lowerBounds_singleton : lowerBounds {a} = Iic a", "start": [645, 1], "end": [647, 33], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Icc", "code": "theorem bddAbove_Icc : BddAbove (Icc a b)", "start": [655, 1], "end": [656, 26], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Icc", "code": "theorem bddBelow_Icc : BddBelow (Icc a b)", "start": [659, 1], "end": [660, 25], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Ico", "code": "theorem bddAbove_Ico : BddAbove (Ico a b)", "start": [663, 1], "end": [664, 40], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Ico", "code": "theorem bddBelow_Ico : BddBelow (Ico a b)", "start": [667, 1], "end": [668, 40], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Ioc", "code": "theorem bddAbove_Ioc : BddAbove (Ioc a b)", "start": [671, 1], "end": [672, 40], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Ioc", "code": "theorem bddBelow_Ioc : BddBelow (Ioc a b)", "start": [675, 1], "end": [676, 40], "kind": "commanddeclaration"}, {"full_name": "bddAbove_Ioo", "code": "theorem bddAbove_Ioo : BddAbove (Ioo a b)", "start": [679, 1], "end": [680, 40], "kind": "commanddeclaration"}, {"full_name": "bddBelow_Ioo", "code": "theorem bddBelow_Ioo : BddBelow (Ioo a b)", "start": [683, 1], "end": [684, 40], "kind": "commanddeclaration"}, {"full_name": "isGreatest_Icc", "code": "theorem isGreatest_Icc (h : a \u2264 b) : IsGreatest (Icc a b) b", "start": [687, 1], "end": [688, 42], "kind": "commanddeclaration"}, {"full_name": "isLUB_Icc", "code": "theorem isLUB_Icc (h : a \u2264 b) : IsLUB (Icc a b) b", "start": [691, 1], "end": [692, 27], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Icc", "code": "theorem upperBounds_Icc (h : a \u2264 b) : upperBounds (Icc a b) = Ici b", "start": [695, 1], "end": [696, 31], "kind": "commanddeclaration"}, {"full_name": "isLeast_Icc", "code": "theorem isLeast_Icc (h : a \u2264 b) : IsLeast (Icc a b) a", "start": [699, 1], "end": [700, 40], "kind": "commanddeclaration"}, {"full_name": "isGLB_Icc", "code": "theorem isGLB_Icc (h : a \u2264 b) : IsGLB (Icc a b) a", "start": [703, 1], "end": [704, 24], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Icc", "code": "theorem lowerBounds_Icc (h : a \u2264 b) : lowerBounds (Icc a b) = Iic a", "start": [707, 1], "end": [708, 31], "kind": "commanddeclaration"}, {"full_name": "isGreatest_Ioc", "code": "theorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b", "start": [711, 1], "end": [712, 42], "kind": "commanddeclaration"}, {"full_name": "isLUB_Ioc", "code": "theorem isLUB_Ioc (h : a < b) : IsLUB (Ioc a b) b", "start": [715, 1], "end": [716, 27], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Ioc", "code": "theorem upperBounds_Ioc (h : a < b) : upperBounds (Ioc a b) = Ici b", "start": [719, 1], "end": [720, 31], "kind": "commanddeclaration"}, {"full_name": "isLeast_Ico", "code": "theorem isLeast_Ico (h : a < b) : IsLeast (Ico a b) a", "start": [723, 1], "end": [724, 40], "kind": "commanddeclaration"}, {"full_name": "isGLB_Ico", "code": "theorem isGLB_Ico (h : a < b) : IsGLB (Ico a b) a", "start": [727, 1], "end": [728, 24], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Ico", "code": "theorem lowerBounds_Ico (h : a < b) : lowerBounds (Ico a b) = Iic a", "start": [731, 1], "end": [732, 31], "kind": "commanddeclaration"}, {"full_name": "isGLB_Ioo", "code": "theorem isGLB_Ioo {a b : \u03b3} (h : a < b) : IsGLB (Ioo a b) a", "start": [739, 1], "end": [746, 37], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Ioo", "code": "theorem lowerBounds_Ioo {a b : \u03b3} (hab : a < b) : lowerBounds (Ioo a b) = Iic a", "start": [749, 1], "end": [750, 33], "kind": "commanddeclaration"}, {"full_name": "isGLB_Ioc", "code": "theorem isGLB_Ioc {a b : \u03b3} (hab : a < b) : IsGLB (Ioc a b) a", "start": [753, 1], "end": [754, 99], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_Ioc", "code": "theorem lowerBounds_Ioc {a b : \u03b3} (hab : a < b) : lowerBounds (Ioc a b) = Iic a", "start": [757, 1], "end": [758, 33], "kind": "commanddeclaration"}, {"full_name": "isLUB_Ioo", "code": "theorem isLUB_Ioo {a b : \u03b3} (hab : a < b) : IsLUB (Ioo a b) b", "start": [767, 1], "end": [768, 49], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Ioo", "code": "theorem upperBounds_Ioo {a b : \u03b3} (hab : a < b) : upperBounds (Ioo a b) = Ici b", "start": [771, 1], "end": [772, 33], "kind": "commanddeclaration"}, {"full_name": "isLUB_Ico", "code": "theorem isLUB_Ico {a b : \u03b3} (hab : a < b) : IsLUB (Ico a b) b", "start": [775, 1], "end": [776, 49], "kind": "commanddeclaration"}, {"full_name": "upperBounds_Ico", "code": "theorem upperBounds_Ico {a b : \u03b3} (hab : a < b) : upperBounds (Ico a b) = Ici b", "start": [779, 1], "end": [780, 33], "kind": "commanddeclaration"}, {"full_name": "bddBelow_iff_subset_Ici", "code": "theorem bddBelow_iff_subset_Ici : BddBelow s \u2194 \u2203 a, s \u2286 Ici a", "start": [785, 1], "end": [786, 10], "kind": "commanddeclaration"}, {"full_name": "bddAbove_iff_subset_Iic", "code": "theorem bddAbove_iff_subset_Iic : BddAbove s \u2194 \u2203 a, s \u2286 Iic a", "start": [789, 1], "end": [790, 10], "kind": "commanddeclaration"}, {"full_name": "bddBelow_bddAbove_iff_subset_Icc", "code": "theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 Icc a b", "start": [793, 1], "end": [795, 64], "kind": "commanddeclaration"}, {"full_name": "isGreatest_univ_iff", "code": "@[simp] theorem isGreatest_univ_iff : IsGreatest univ a \u2194 IsTop a", "start": [802, 1], "end": [803, 44], "kind": "commanddeclaration"}, {"full_name": "isGreatest_univ", "code": "theorem isGreatest_univ [OrderTop \u03b1] : IsGreatest (univ : Set \u03b1) \u22a4", "start": [806, 1], "end": [807, 34], "kind": "commanddeclaration"}, {"full_name": "OrderTop.upperBounds_univ", "code": "@[simp]\ntheorem OrderTop.upperBounds_univ [PartialOrder \u03b3] [OrderTop \u03b3] :\n    upperBounds (univ : Set \u03b3) = {\u22a4}", "start": [810, 1], "end": [812, 88], "kind": "commanddeclaration"}, {"full_name": "isLUB_univ", "code": "theorem isLUB_univ [OrderTop \u03b1] : IsLUB (univ : Set \u03b1) \u22a4", "start": [815, 1], "end": [816, 24], "kind": "commanddeclaration"}, {"full_name": "OrderBot.lowerBounds_univ", "code": "@[simp]\ntheorem OrderBot.lowerBounds_univ [PartialOrder \u03b3] [OrderBot \u03b3] :\n    lowerBounds (univ : Set \u03b3) = {\u22a5}", "start": [819, 1], "end": [822, 37], "kind": "commanddeclaration"}, {"full_name": "isLeast_univ_iff", "code": "@[simp] theorem isLeast_univ_iff : IsLeast univ a \u2194 IsBot a", "start": [825, 1], "end": [826, 31], "kind": "commanddeclaration"}, {"full_name": "isLeast_univ", "code": "theorem isLeast_univ [OrderBot \u03b1] : IsLeast (univ : Set \u03b1) \u22a5", "start": [829, 1], "end": [830, 27], "kind": "commanddeclaration"}, {"full_name": "isGLB_univ", "code": "theorem isGLB_univ [OrderBot \u03b1] : IsGLB (univ : Set \u03b1) \u22a5", "start": [833, 1], "end": [834, 21], "kind": "commanddeclaration"}, {"full_name": "NoMaxOrder.upperBounds_univ", "code": "@[simp]\ntheorem NoMaxOrder.upperBounds_univ [NoMaxOrder \u03b1] : upperBounds (univ : Set \u03b1) = \u2205", "start": [837, 1], "end": [841, 33], "kind": "commanddeclaration"}, {"full_name": "NoMinOrder.lowerBounds_univ", "code": "@[simp]\ntheorem NoMinOrder.lowerBounds_univ [NoMinOrder \u03b1] : lowerBounds (univ : Set \u03b1) = \u2205", "start": [844, 1], "end": [846, 39], "kind": "commanddeclaration"}, {"full_name": "not_bddAbove_univ", "code": "@[simp]\ntheorem not_bddAbove_univ [NoMaxOrder \u03b1] : \u00acBddAbove (univ : Set \u03b1)", "start": [849, 1], "end": [850, 90], "kind": "commanddeclaration"}, {"full_name": "not_bddBelow_univ", "code": "@[simp]\ntheorem not_bddBelow_univ [NoMinOrder \u03b1] : \u00acBddBelow (univ : Set \u03b1)", "start": [853, 1], "end": [855, 29], "kind": "commanddeclaration"}, {"full_name": "upperBounds_empty", "code": "@[simp]\ntheorem upperBounds_empty : upperBounds (\u2205 : Set \u03b1) = univ", "start": [863, 1], "end": [865, 93], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_empty", "code": "@[simp]\ntheorem lowerBounds_empty : lowerBounds (\u2205 : Set \u03b1) = univ", "start": [868, 1], "end": [870, 27], "kind": "commanddeclaration"}, {"full_name": "bddAbove_empty", "code": "@[simp]\ntheorem bddAbove_empty [Nonempty \u03b1] : BddAbove (\u2205 : Set \u03b1)", "start": [873, 1], "end": [875, 57], "kind": "commanddeclaration"}, {"full_name": "bddBelow_empty", "code": "@[simp]\ntheorem bddBelow_empty [Nonempty \u03b1] : BddBelow (\u2205 : Set \u03b1)", "start": [878, 1], "end": [880, 57], "kind": "commanddeclaration"}, {"full_name": "isGLB_empty_iff", "code": "@[simp] theorem isGLB_empty_iff : IsGLB \u2205 a \u2194 IsTop a", "start": [883, 1], "end": [884, 15], "kind": "commanddeclaration"}, {"full_name": "isLUB_empty_iff", "code": "@[simp] theorem isLUB_empty_iff : IsLUB \u2205 a \u2194 IsBot a", "start": [887, 1], "end": [888, 27], "kind": "commanddeclaration"}, {"full_name": "isGLB_empty", "code": "theorem isGLB_empty [OrderTop \u03b1] : IsGLB \u2205 (\u22a4 : \u03b1)", "start": [891, 1], "end": [892, 30], "kind": "commanddeclaration"}, {"full_name": "isLUB_empty", "code": "theorem isLUB_empty [OrderBot \u03b1] : IsLUB \u2205 (\u22a5 : \u03b1)", "start": [895, 1], "end": [896, 23], "kind": "commanddeclaration"}, {"full_name": "IsLUB.nonempty", "code": "theorem IsLUB.nonempty [NoMinOrder \u03b1] (hs : IsLUB s a) : s.Nonempty", "start": [899, 1], "end": [902, 83], "kind": "commanddeclaration"}, {"full_name": "IsGLB.nonempty", "code": "theorem IsGLB.nonempty [NoMaxOrder \u03b1] (hs : IsGLB s a) : s.Nonempty", "start": [905, 1], "end": [906, 19], "kind": "commanddeclaration"}, {"full_name": "nonempty_of_not_bddAbove", "code": "theorem nonempty_of_not_bddAbove [ha : Nonempty \u03b1] (h : \u00acBddAbove s) : s.Nonempty", "start": [909, 1], "end": [910, 77], "kind": "commanddeclaration"}, {"full_name": "nonempty_of_not_bddBelow", "code": "theorem nonempty_of_not_bddBelow [Nonempty \u03b1] (h : \u00acBddBelow s) : s.Nonempty", "start": [913, 1], "end": [914, 40], "kind": "commanddeclaration"}, {"full_name": "bddAbove_insert", "code": "@[simp]\ntheorem bddAbove_insert [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {s : Set \u03b1} {a : \u03b1} :\n    BddAbove (insert a s) \u2194 BddAbove s", "start": [922, 1], "end": [926, 74], "kind": "commanddeclaration"}, {"full_name": "BddAbove.insert", "code": "protected theorem BddAbove.insert [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] {s : Set \u03b1} (a : \u03b1) :\n    BddAbove s \u2192 BddAbove (insert a s)", "start": [929, 1], "end": [931, 20], "kind": "commanddeclaration"}, {"full_name": "bddBelow_insert", "code": "@[simp]\ntheorem bddBelow_insert [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {s : Set \u03b1} {a : \u03b1} :\n    BddBelow (insert a s) \u2194 BddBelow s", "start": [934, 1], "end": [938, 74], "kind": "commanddeclaration"}, {"full_name": "BddBelow.insert", "code": "protected theorem BddBelow.insert [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] {s : Set \u03b1} (a : \u03b1) :\n    BddBelow s \u2192 BddBelow (insert a s)", "start": [941, 1], "end": [943, 20], "kind": "commanddeclaration"}, {"full_name": "IsLUB.insert", "code": "protected theorem IsLUB.insert [SemilatticeSup \u03b3] (a) {b} {s : Set \u03b3} (hs : IsLUB s b) :\n    IsLUB (insert a s) (a \u2294 b)", "start": [946, 1], "end": [949, 33], "kind": "commanddeclaration"}, {"full_name": "IsGLB.insert", "code": "protected theorem IsGLB.insert [SemilatticeInf \u03b3] (a) {b} {s : Set \u03b3} (hs : IsGLB s b) :\n    IsGLB (insert a s) (a \u2293 b)", "start": [952, 1], "end": [955, 33], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.insert", "code": "protected theorem IsGreatest.insert [LinearOrder \u03b3] (a) {b} {s : Set \u03b3} (hs : IsGreatest s b) :\n    IsGreatest (insert a s) (max a b)", "start": [958, 1], "end": [961, 38], "kind": "commanddeclaration"}, {"full_name": "IsLeast.insert", "code": "protected theorem IsLeast.insert [LinearOrder \u03b3] (a) {b} {s : Set \u03b3} (hs : IsLeast s b) :\n    IsLeast (insert a s) (min a b)", "start": [964, 1], "end": [967, 35], "kind": "commanddeclaration"}, {"full_name": "upperBounds_insert", "code": "@[simp]\ntheorem upperBounds_insert (a : \u03b1) (s : Set \u03b1) :\n    upperBounds (insert a s) = Ici a \u2229 upperBounds s", "start": [970, 1], "end": [973, 59], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_insert", "code": "@[simp]\ntheorem lowerBounds_insert (a : \u03b1) (s : Set \u03b1) :\n    lowerBounds (insert a s) = Iic a \u2229 lowerBounds s", "start": [976, 1], "end": [979, 59], "kind": "commanddeclaration"}, {"full_name": "OrderTop.bddAbove", "code": "@[simp]\nprotected theorem OrderTop.bddAbove [OrderTop \u03b1] (s : Set \u03b1) : BddAbove s", "start": [982, 1], "end": [985, 36], "kind": "commanddeclaration"}, {"full_name": "OrderBot.bddBelow", "code": "@[simp]\nprotected theorem OrderBot.bddBelow [OrderBot \u03b1] (s : Set \u03b1) : BddBelow s", "start": [988, 1], "end": [991, 36], "kind": "commanddeclaration"}, {"full_name": "isLUB_pair", "code": "theorem isLUB_pair [SemilatticeSup \u03b3] {a b : \u03b3} : IsLUB {a, b} (a \u2294 b)", "start": [1009, 1], "end": [1010, 27], "kind": "commanddeclaration"}, {"full_name": "isGLB_pair", "code": "theorem isGLB_pair [SemilatticeInf \u03b3] {a b : \u03b3} : IsGLB {a, b} (a \u2293 b)", "start": [1013, 1], "end": [1014, 27], "kind": "commanddeclaration"}, {"full_name": "isLeast_pair", "code": "theorem isLeast_pair [LinearOrder \u03b3] {a b : \u03b3} : IsLeast {a, b} (min a b)", "start": [1017, 1], "end": [1018, 29], "kind": "commanddeclaration"}, {"full_name": "isGreatest_pair", "code": "theorem isGreatest_pair [LinearOrder \u03b3] {a b : \u03b3} : IsGreatest {a, b} (max a b)", "start": [1021, 1], "end": [1022, 32], "kind": "commanddeclaration"}, {"full_name": "isLUB_lowerBounds", "code": "@[simp]\ntheorem isLUB_lowerBounds : IsLUB (lowerBounds s) a \u2194 IsGLB s a", "start": [1030, 1], "end": [1032, 93], "kind": "commanddeclaration"}, {"full_name": "isGLB_upperBounds", "code": "@[simp]\ntheorem isGLB_upperBounds : IsGLB (upperBounds s) a \u2194 IsLUB s a", "start": [1035, 1], "end": [1037, 31], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_le_upperBounds", "code": "theorem lowerBounds_le_upperBounds (ha : a \u2208 lowerBounds s) (hb : b \u2208 upperBounds s) :\n    s.Nonempty \u2192 a \u2264 b", "start": [1051, 1], "end": [1053, 40], "kind": "commanddeclaration"}, {"full_name": "isGLB_le_isLUB", "code": "theorem isGLB_le_isLUB (ha : IsGLB s a) (hb : IsLUB s b) (hs : s.Nonempty) : a \u2264 b", "start": [1056, 1], "end": [1057, 42], "kind": "commanddeclaration"}, {"full_name": "isLUB_lt_iff", "code": "theorem isLUB_lt_iff (ha : IsLUB s a) : a < b \u2194 \u2203 c \u2208 upperBounds s, c < b", "start": [1060, 1], "end": [1061, 80], "kind": "commanddeclaration"}, {"full_name": "lt_isGLB_iff", "code": "theorem lt_isGLB_iff (ha : IsGLB s a) : b < a \u2194 \u2203 c \u2208 lowerBounds s, b < c", "start": [1064, 1], "end": [1065, 23], "kind": "commanddeclaration"}, {"full_name": "le_of_isLUB_le_isGLB", "code": "theorem le_of_isLUB_le_isGLB {x y} (ha : IsGLB s a) (hb : IsLUB s b) (hab : b \u2264 a) (hx : x \u2208 s)\n    (hy : y \u2208 s) : x \u2264 y", "start": [1068, 1], "end": [1073, 21], "kind": "commanddeclaration"}, {"full_name": "IsLeast.unique", "code": "theorem IsLeast.unique (Ha : IsLeast s a) (Hb : IsLeast s b) : a = b", "start": [1082, 1], "end": [1083, 52], "kind": "commanddeclaration"}, {"full_name": "IsLeast.isLeast_iff_eq", "code": "theorem IsLeast.isLeast_iff_eq (Ha : IsLeast s a) : IsLeast s b \u2194 a = b", "start": [1086, 1], "end": [1087, 38], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.unique", "code": "theorem IsGreatest.unique (Ha : IsGreatest s a) (Hb : IsGreatest s b) : a = b", "start": [1090, 1], "end": [1091, 52], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.isGreatest_iff_eq", "code": "theorem IsGreatest.isGreatest_iff_eq (Ha : IsGreatest s a) : IsGreatest s b \u2194 a = b", "start": [1094, 1], "end": [1095, 38], "kind": "commanddeclaration"}, {"full_name": "IsLUB.unique", "code": "theorem IsLUB.unique (Ha : IsLUB s a) (Hb : IsLUB s b) : a = b", "start": [1098, 1], "end": [1099, 23], "kind": "commanddeclaration"}, {"full_name": "IsGLB.unique", "code": "theorem IsGLB.unique (Ha : IsGLB s a) (Hb : IsGLB s b) : a = b", "start": [1102, 1], "end": [1103, 26], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_isLUB_le_isGLB", "code": "theorem Set.subsingleton_of_isLUB_le_isGLB (Ha : IsGLB s a) (Hb : IsLUB s b) (hab : b \u2264 a) :\n    s.Subsingleton", "start": [1106, 1], "end": [1108, 92], "kind": "commanddeclaration"}, {"full_name": "isGLB_lt_isLUB_of_ne", "code": "theorem isGLB_lt_isLUB_of_ne (Ha : IsGLB s a) (Hb : IsLUB s b) {x y} (Hx : x \u2208 s) (Hy : y \u2208 s)\n    (Hxy : x \u2260 y) : a < b", "start": [1111, 1], "end": [1115, 65], "kind": "commanddeclaration"}, {"full_name": "lt_isLUB_iff", "code": "theorem lt_isLUB_iff (h : IsLUB s a) : b < a \u2194 \u2203 c \u2208 s, b < c", "start": [1124, 1], "end": [1125, 87], "kind": "commanddeclaration"}, {"full_name": "isGLB_lt_iff", "code": "theorem isGLB_lt_iff (h : IsGLB s a) : a < b \u2194 \u2203 c \u2208 s, c < b", "start": [1128, 1], "end": [1129, 22], "kind": "commanddeclaration"}, {"full_name": "IsLUB.exists_between", "code": "theorem IsLUB.exists_between (h : IsLUB s a) (hb : b < a) : \u2203 c \u2208 s, b < c \u2227 c \u2264 a", "start": [1132, 1], "end": [1134, 25], "kind": "commanddeclaration"}, {"full_name": "IsLUB.exists_between'", "code": "theorem IsLUB.exists_between' (h : IsLUB s a) (h' : a \u2209 s) (hb : b < a) : \u2203 c \u2208 s, b < c \u2227 c < a", "start": [1137, 1], "end": [1139, 57], "kind": "commanddeclaration"}, {"full_name": "IsGLB.exists_between", "code": "theorem IsGLB.exists_between (h : IsGLB s a) (hb : a < b) : \u2203 c \u2208 s, a \u2264 c \u2227 c < b", "start": [1142, 1], "end": [1144, 25], "kind": "commanddeclaration"}, {"full_name": "IsGLB.exists_between'", "code": "theorem IsGLB.exists_between' (h : IsGLB s a) (h' : a \u2209 s) (hb : a < b) : \u2203 c \u2208 s, a < c \u2227 c < b", "start": [1147, 1], "end": [1149, 62], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mem_upperBounds_image", "code": "theorem mem_upperBounds_image (Has : a \u2208 upperBounds s) (Hat : a \u2208 t) :\n    f a \u2208 upperBounds (f '' s)", "start": [1164, 1], "end": [1166, 55], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mem_upperBounds_image_self", "code": "theorem mem_upperBounds_image_self : a \u2208 upperBounds t \u2192 a \u2208 t \u2192 f a \u2208 upperBounds (f '' t)", "start": [1169, 1], "end": [1170, 38], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mem_lowerBounds_image", "code": "theorem mem_lowerBounds_image (Has : a \u2208 lowerBounds s) (Hat : a \u2208 t) :\n    f a \u2208 lowerBounds (f '' s)", "start": [1173, 1], "end": [1175, 55], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mem_lowerBounds_image_self", "code": "theorem mem_lowerBounds_image_self : a \u2208 lowerBounds t \u2192 a \u2208 t \u2192 f a \u2208 lowerBounds (f '' t)", "start": [1178, 1], "end": [1179, 38], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.image_upperBounds_subset_upperBounds_image", "code": "theorem image_upperBounds_subset_upperBounds_image (Hst : s \u2286 t) :\n    f '' (upperBounds s \u2229 t) \u2286 upperBounds (f '' s)", "start": [1182, 1], "end": [1185, 47], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.image_lowerBounds_subset_lowerBounds_image", "code": "theorem image_lowerBounds_subset_lowerBounds_image :\n    f '' (lowerBounds s \u2229 t) \u2286 lowerBounds (f '' s)", "start": [1188, 1], "end": [1190, 57], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_bddAbove", "code": "theorem map_bddAbove : (upperBounds s \u2229 t).Nonempty \u2192 BddAbove (f '' s)", "start": [1193, 1], "end": [1196, 44], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_bddBelow", "code": "theorem map_bddBelow : (lowerBounds s \u2229 t).Nonempty \u2192 BddBelow (f '' s)", "start": [1199, 1], "end": [1202, 44], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_isLeast", "code": "theorem map_isLeast (Ha : IsLeast t a) : IsLeast (f '' t) (f a)", "start": [1205, 1], "end": [1207, 69], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_isGreatest", "code": "theorem map_isGreatest (Ha : IsGreatest t a) : IsGreatest (f '' t) (f a)", "start": [1210, 1], "end": [1212, 69], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mem_upperBounds_image", "code": "theorem mem_upperBounds_image (Has : a \u2208 lowerBounds s) : a \u2208 t \u2192 f a \u2208 upperBounds (f '' s)", "start": [1222, 1], "end": [1223, 46], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mem_upperBounds_image_self", "code": "theorem mem_upperBounds_image_self : a \u2208 lowerBounds t \u2192 a \u2208 t \u2192 f a \u2208 upperBounds (f '' t)", "start": [1226, 1], "end": [1227, 43], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mem_lowerBounds_image", "code": "theorem mem_lowerBounds_image : a \u2208 upperBounds s \u2192 a \u2208 t \u2192 f a \u2208 lowerBounds (f '' s)", "start": [1230, 1], "end": [1231, 42], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mem_lowerBounds_image_self", "code": "theorem mem_lowerBounds_image_self : a \u2208 upperBounds t \u2192 a \u2208 t \u2192 f a \u2208 lowerBounds (f '' t)", "start": [1234, 1], "end": [1235, 43], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.image_lowerBounds_subset_upperBounds_image", "code": "theorem image_lowerBounds_subset_upperBounds_image :\n    f '' (lowerBounds s \u2229 t) \u2286 upperBounds (f '' s)", "start": [1238, 1], "end": [1240, 63], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.image_upperBounds_subset_lowerBounds_image", "code": "theorem image_upperBounds_subset_lowerBounds_image :\n    f '' (upperBounds s \u2229 t) \u2286 lowerBounds (f '' s)", "start": [1243, 1], "end": [1245, 63], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_bddAbove", "code": "theorem map_bddAbove : (upperBounds s \u2229 t).Nonempty \u2192 BddBelow (f '' s)", "start": [1248, 1], "end": [1250, 33], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_bddBelow", "code": "theorem map_bddBelow : (lowerBounds s \u2229 t).Nonempty \u2192 BddAbove (f '' s)", "start": [1253, 1], "end": [1255, 33], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_isGreatest", "code": "theorem map_isGreatest : IsGreatest t a \u2192 IsLeast (f '' t) (f a)", "start": [1258, 1], "end": [1260, 31], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_isLeast", "code": "theorem map_isLeast : IsLeast t a \u2192 IsGreatest (f '' t) (f a)", "start": [1263, 1], "end": [1265, 28], "kind": "commanddeclaration"}, {"full_name": "Monotone.mem_upperBounds_image", "code": "theorem mem_upperBounds_image (Ha : a \u2208 upperBounds s) : f a \u2208 upperBounds (f '' s)", "start": [1274, 1], "end": [1275, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.mem_lowerBounds_image", "code": "theorem mem_lowerBounds_image (Ha : a \u2208 lowerBounds s) : f a \u2208 lowerBounds (f '' s)", "start": [1278, 1], "end": [1279, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.image_upperBounds_subset_upperBounds_image", "code": "theorem image_upperBounds_subset_upperBounds_image : f '' upperBounds s \u2286 upperBounds (f '' s)", "start": [1282, 1], "end": [1284, 36], "kind": "commanddeclaration"}, {"full_name": "Monotone.image_lowerBounds_subset_lowerBounds_image", "code": "theorem image_lowerBounds_subset_lowerBounds_image : f '' lowerBounds s \u2286 lowerBounds (f '' s)", "start": [1287, 1], "end": [1288, 53], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_bddAbove", "code": "theorem map_bddAbove : BddAbove s \u2192 BddAbove (f '' s)", "start": [1291, 1], "end": [1294, 50], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_bddBelow", "code": "theorem map_bddBelow : BddBelow s \u2192 BddBelow (f '' s)", "start": [1297, 1], "end": [1300, 50], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_isLeast", "code": "theorem map_isLeast (Ha : IsLeast s a) : IsLeast (f '' s) (f a)", "start": [1303, 1], "end": [1305, 59], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_isGreatest", "code": "theorem map_isGreatest (Ha : IsGreatest s a) : IsGreatest (f '' s) (f a)", "start": [1308, 1], "end": [1310, 59], "kind": "commanddeclaration"}, {"full_name": "Antitone.mem_upperBounds_image", "code": "theorem mem_upperBounds_image : a \u2208 lowerBounds s \u2192 f a \u2208 upperBounds (f '' s)", "start": [1319, 1], "end": [1320, 38], "kind": "commanddeclaration"}, {"full_name": "Antitone.mem_lowerBounds_image", "code": "theorem mem_lowerBounds_image : a \u2208 upperBounds s \u2192 f a \u2208 lowerBounds (f '' s)", "start": [1323, 1], "end": [1324, 38], "kind": "commanddeclaration"}, {"full_name": "Antitone.image_lowerBounds_subset_upperBounds_image", "code": "theorem image_lowerBounds_subset_upperBounds_image : f '' lowerBounds s \u2286 upperBounds (f '' s)", "start": [1327, 1], "end": [1328, 59], "kind": "commanddeclaration"}, {"full_name": "Antitone.image_upperBounds_subset_lowerBounds_image", "code": "theorem image_upperBounds_subset_lowerBounds_image : f '' upperBounds s \u2286 lowerBounds (f '' s)", "start": [1331, 1], "end": [1332, 59], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_bddAbove", "code": "theorem map_bddAbove : BddAbove s \u2192 BddBelow (f '' s)", "start": [1335, 1], "end": [1337, 29], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_bddBelow", "code": "theorem map_bddBelow : BddBelow s \u2192 BddAbove (f '' s)", "start": [1340, 1], "end": [1342, 29], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_isGreatest", "code": "theorem map_isGreatest : IsGreatest s a \u2192 IsLeast (f '' s) (f a)", "start": [1345, 1], "end": [1347, 31], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_isLeast", "code": "theorem map_isLeast : IsLeast s a \u2192 IsGreatest (f '' s) (f a)", "start": [1350, 1], "end": [1352, 28], "kind": "commanddeclaration"}, {"full_name": "mem_upperBounds_image2", "code": "theorem mem_upperBounds_image2 (ha : a \u2208 upperBounds s) (hb : b \u2208 upperBounds t) :\n    f a b \u2208 upperBounds (image2 f s t)", "start": [1366, 1], "end": [1368, 78], "kind": "commanddeclaration"}, {"full_name": "mem_lowerBounds_image2", "code": "theorem mem_lowerBounds_image2 (ha : a \u2208 lowerBounds s) (hb : b \u2208 lowerBounds t) :\n    f a b \u2208 lowerBounds (image2 f s t)", "start": [1371, 1], "end": [1373, 78], "kind": "commanddeclaration"}, {"full_name": "image2_upperBounds_upperBounds_subset", "code": "theorem image2_upperBounds_upperBounds_subset :\n    image2 f (upperBounds s) (upperBounds t) \u2286 upperBounds (image2 f s t)", "start": [1376, 1], "end": [1379, 43], "kind": "commanddeclaration"}, {"full_name": "image2_lowerBounds_lowerBounds_subset", "code": "theorem image2_lowerBounds_lowerBounds_subset :\n    image2 f (lowerBounds s) (lowerBounds t) \u2286 lowerBounds (image2 f s t)", "start": [1382, 1], "end": [1385, 43], "kind": "commanddeclaration"}, {"full_name": "BddAbove.image2", "code": "theorem BddAbove.image2 : BddAbove s \u2192 BddAbove t \u2192 BddAbove (image2 f s t)", "start": [1388, 1], "end": [1391, 52], "kind": "commanddeclaration"}, {"full_name": "BddBelow.image2", "code": "theorem BddBelow.image2 : BddBelow s \u2192 BddBelow t \u2192 BddBelow (image2 f s t)", "start": [1394, 1], "end": [1397, 52], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.image2", "code": "theorem IsGreatest.image2 (ha : IsGreatest s a) (hb : IsGreatest t b) :\n    IsGreatest (image2 f s t) (f a b)", "start": [1400, 1], "end": [1402, 72], "kind": "commanddeclaration"}, {"full_name": "IsLeast.image2", "code": "theorem IsLeast.image2 (ha : IsLeast s a) (hb : IsLeast t b) : IsLeast (image2 f s t) (f a b)", "start": [1405, 1], "end": [1406, 72], "kind": "commanddeclaration"}, {"full_name": "mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds", "code": "theorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_lowerBounds (ha : a \u2208 upperBounds s)\n    (hb : b \u2208 lowerBounds t) : f a b \u2208 upperBounds (image2 f s t)", "start": [1415, 1], "end": [1417, 78], "kind": "commanddeclaration"}, {"full_name": "mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds", "code": "theorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_upperBounds (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 upperBounds t) : f a b \u2208 lowerBounds (image2 f s t)", "start": [1420, 1], "end": [1422, 78], "kind": "commanddeclaration"}, {"full_name": "image2_upperBounds_lowerBounds_subset_upperBounds_image2", "code": "theorem image2_upperBounds_lowerBounds_subset_upperBounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) \u2286 upperBounds (image2 f s t)", "start": [1425, 1], "end": [1428, 81], "kind": "commanddeclaration"}, {"full_name": "image2_lowerBounds_upperBounds_subset_lowerBounds_image2", "code": "theorem image2_lowerBounds_upperBounds_subset_lowerBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) \u2286 lowerBounds (image2 f s t)", "start": [1431, 1], "end": [1434, 81], "kind": "commanddeclaration"}, {"full_name": "BddAbove.bddAbove_image2_of_bddBelow", "code": "theorem BddAbove.bddAbove_image2_of_bddBelow :\n    BddAbove s \u2192 BddBelow t \u2192 BddAbove (Set.image2 f s t)", "start": [1437, 1], "end": [1440, 90], "kind": "commanddeclaration"}, {"full_name": "BddBelow.bddBelow_image2_of_bddAbove", "code": "theorem BddBelow.bddBelow_image2_of_bddAbove :\n    BddBelow s \u2192 BddAbove t \u2192 BddBelow (Set.image2 f s t)", "start": [1443, 1], "end": [1446, 90], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.isGreatest_image2_of_isLeast", "code": "theorem IsGreatest.isGreatest_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsGreatest (Set.image2 f s t) (f a b)", "start": [1449, 1], "end": [1452, 82], "kind": "commanddeclaration"}, {"full_name": "IsLeast.isLeast_image2_of_isGreatest", "code": "theorem IsLeast.isLeast_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsLeast (Set.image2 f s t) (f a b)", "start": [1455, 1], "end": [1458, 82], "kind": "commanddeclaration"}, {"full_name": "mem_upperBounds_image2_of_mem_lowerBounds", "code": "theorem mem_upperBounds_image2_of_mem_lowerBounds (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 lowerBounds t) : f a b \u2208 upperBounds (image2 f s t)", "start": [1467, 1], "end": [1469, 78], "kind": "commanddeclaration"}, {"full_name": "mem_lowerBounds_image2_of_mem_upperBounds", "code": "theorem mem_lowerBounds_image2_of_mem_upperBounds (ha : a \u2208 upperBounds s)\n    (hb : b \u2208 upperBounds t) : f a b \u2208 lowerBounds (image2 f s t)", "start": [1472, 1], "end": [1474, 78], "kind": "commanddeclaration"}, {"full_name": "image2_upperBounds_upperBounds_subset_upperBounds_image2", "code": "theorem image2_upperBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (lowerBounds t) \u2286 upperBounds (image2 f s t)", "start": [1477, 1], "end": [1480, 62], "kind": "commanddeclaration"}, {"full_name": "image2_lowerBounds_lowerBounds_subset_lowerBounds_image2", "code": "theorem image2_lowerBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (upperBounds t) \u2286 lowerBounds (image2 f s t)", "start": [1483, 1], "end": [1486, 62], "kind": "commanddeclaration"}, {"full_name": "BddBelow.image2_bddAbove", "code": "theorem BddBelow.image2_bddAbove : BddBelow s \u2192 BddBelow t \u2192 BddAbove (Set.image2 f s t)", "start": [1489, 1], "end": [1491, 71], "kind": "commanddeclaration"}, {"full_name": "BddAbove.image2_bddBelow", "code": "theorem BddAbove.image2_bddBelow : BddAbove s \u2192 BddAbove t \u2192 BddBelow (Set.image2 f s t)", "start": [1494, 1], "end": [1496, 71], "kind": "commanddeclaration"}, {"full_name": "IsLeast.isGreatest_image2", "code": "theorem IsLeast.isGreatest_image2 (ha : IsLeast s a) (hb : IsLeast t b) :\n    IsGreatest (Set.image2 f s t) (f a b)", "start": [1499, 1], "end": [1501, 91], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.isLeast_image2", "code": "theorem IsGreatest.isLeast_image2 (ha : IsGreatest s a) (hb : IsGreatest t b) :\n    IsLeast (Set.image2 f s t) (f a b)", "start": [1504, 1], "end": [1506, 91], "kind": "commanddeclaration"}, {"full_name": "mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds", "code": "theorem mem_upperBounds_image2_of_mem_upperBounds_of_mem_upperBounds (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 upperBounds t) : f a b \u2208 upperBounds (image2 f s t)", "start": [1515, 1], "end": [1517, 78], "kind": "commanddeclaration"}, {"full_name": "mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds", "code": "theorem mem_lowerBounds_image2_of_mem_lowerBounds_of_mem_lowerBounds (ha : a \u2208 upperBounds s)\n    (hb : b \u2208 lowerBounds t) : f a b \u2208 lowerBounds (image2 f s t)", "start": [1520, 1], "end": [1522, 78], "kind": "commanddeclaration"}, {"full_name": "image2_lowerBounds_upperBounds_subset_upperBounds_image2", "code": "theorem image2_lowerBounds_upperBounds_subset_upperBounds_image2 :\n    image2 f (lowerBounds s) (upperBounds t) \u2286 upperBounds (image2 f s t)", "start": [1525, 1], "end": [1528, 81], "kind": "commanddeclaration"}, {"full_name": "image2_upperBounds_lowerBounds_subset_lowerBounds_image2", "code": "theorem image2_upperBounds_lowerBounds_subset_lowerBounds_image2 :\n    image2 f (upperBounds s) (lowerBounds t) \u2286 lowerBounds (image2 f s t)", "start": [1531, 1], "end": [1534, 81], "kind": "commanddeclaration"}, {"full_name": "BddBelow.bddAbove_image2_of_bddAbove", "code": "theorem BddBelow.bddAbove_image2_of_bddAbove :\n    BddBelow s \u2192 BddAbove t \u2192 BddAbove (Set.image2 f s t)", "start": [1537, 1], "end": [1540, 90], "kind": "commanddeclaration"}, {"full_name": "BddAbove.bddBelow_image2_of_bddAbove", "code": "theorem BddAbove.bddBelow_image2_of_bddAbove :\n    BddAbove s \u2192 BddBelow t \u2192 BddBelow (Set.image2 f s t)", "start": [1543, 1], "end": [1546, 90], "kind": "commanddeclaration"}, {"full_name": "IsLeast.isGreatest_image2_of_isGreatest", "code": "theorem IsLeast.isGreatest_image2_of_isGreatest (ha : IsLeast s a) (hb : IsGreatest t b) :\n    IsGreatest (Set.image2 f s t) (f a b)", "start": [1549, 1], "end": [1552, 82], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.isLeast_image2_of_isLeast", "code": "theorem IsGreatest.isLeast_image2_of_isLeast (ha : IsGreatest s a) (hb : IsLeast t b) :\n    IsLeast (Set.image2 f s t) (f a b)", "start": [1555, 1], "end": [1558, 82], "kind": "commanddeclaration"}, {"full_name": "bddAbove_pi", "code": "lemma bddAbove_pi {s : Set (\u2200 a, \u03c0 a)} :\n    BddAbove s \u2194 \u2200 a, BddAbove (Function.eval a '' s) :=\n  \u27e8fun \u27e8f, hf\u27e9 a \u21a6 \u27e8f a, ball_image_of_ball fun _ hg \u21a6 hf hg a\u27e9,\n    fun h \u21a6 \u27e8fun a \u21a6 (h a).some, fun _ hg a \u21a6 (h a).some_mem <| mem_image_of_mem _ hg\u27e9\u27e9", "start": [1569, 1], "end": [1572, 88], "kind": "mathlibtacticlemma"}, {"full_name": "bddBelow_pi", "code": "lemma bddBelow_pi {s : Set (\u2200 a, \u03c0 a)} :\n    BddBelow s \u2194 \u2200 a, BddBelow (Function.eval a '' s) :=\n  bddAbove_pi (\u03c0 := fun a \u21a6 (\u03c0 a)\u1d52\u1d48)", "start": [1574, 1], "end": [1576, 37], "kind": "mathlibtacticlemma"}, {"full_name": "bddAbove_range_pi", "code": "lemma bddAbove_range_pi {F : \u03b9 \u2192 \u2200 a, \u03c0 a} :\n    BddAbove (range F) \u2194 \u2200 a, BddAbove (range fun i \u21a6 F i a) := by\n  simp only [bddAbove_pi, \u2190range_comp]\n  rfl", "start": [1578, 1], "end": [1581, 6], "kind": "mathlibtacticlemma"}, {"full_name": "bddBelow_range_pi", "code": "lemma bddBelow_range_pi {F : \u03b9 \u2192 \u2200 a, \u03c0 a} :\n    BddBelow (range F) \u2194 \u2200 a, BddBelow (range fun i \u21a6 F i a) :=\n  bddAbove_range_pi (\u03c0 := fun a \u21a6 (\u03c0 a)\u1d52\u1d48)", "start": [1583, 1], "end": [1585, 43], "kind": "mathlibtacticlemma"}, {"full_name": "isLUB_pi", "code": "theorem isLUB_pi {s : Set (\u2200 a, \u03c0 a)} {f : \u2200 a, \u03c0 a} :\n    IsLUB s f \u2194 \u2200 a, IsLUB (Function.eval a '' s) (f a)", "start": [1587, 1], "end": [1596, 88], "kind": "commanddeclaration"}, {"full_name": "isGLB_pi", "code": "theorem isGLB_pi {s : Set (\u2200 a, \u03c0 a)} {f : \u2200 a, \u03c0 a} :\n    IsGLB s f \u2194 \u2200 a, IsGLB (Function.eval a '' s) (f a)", "start": [1599, 1], "end": [1601, 39], "kind": "commanddeclaration"}, {"full_name": "IsGLB.of_image", "code": "theorem IsGLB.of_image [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : \u2200 {x y}, f x \u2264 f y \u2194 x \u2264 y)\n    {s : Set \u03b1} {x : \u03b1} (hx : IsGLB (f '' s) (f x)) : IsGLB s x", "start": [1606, 1], "end": [1609, 73], "kind": "commanddeclaration"}, {"full_name": "IsLUB.of_image", "code": "theorem IsLUB.of_image [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : \u2200 {x y}, f x \u2264 f y \u2194 x \u2264 y)\n    {s : Set \u03b1} {x : \u03b1} (hx : IsLUB (f '' s) (f x)) : IsLUB s x", "start": [1612, 1], "end": [1615, 73], "kind": "commanddeclaration"}, {"full_name": "isLUB_prod", "code": "theorem isLUB_prod [Preorder \u03b1] [Preorder \u03b2] {s : Set (\u03b1 \u00d7 \u03b2)} (p : \u03b1 \u00d7 \u03b2) :\n    IsLUB s p \u2194 IsLUB (Prod.fst '' s) p.1 \u2227 IsLUB (Prod.snd '' s) p.2", "start": [1618, 1], "end": [1632, 56], "kind": "commanddeclaration"}, {"full_name": "isGLB_prod", "code": "theorem isGLB_prod [Preorder \u03b1] [Preorder \u03b2] {s : Set (\u03b1 \u00d7 \u03b2)} (p : \u03b1 \u00d7 \u03b2) :\n    IsGLB s p \u2194 IsGLB (Prod.fst '' s) p.1 \u2227 IsGLB (Prod.snd '' s) p.2", "start": [1635, 1], "end": [1637, 30], "kind": "commanddeclaration"}, {"full_name": "ScottContinuous", "code": "def ScottContinuous (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983d : Set \u03b1\u2984, d.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) d \u2192 \u2200 \u2983a\u2984, IsLUB d a \u2192 IsLUB (f '' d) (f a)", "start": [1643, 1], "end": [1656, 93], "kind": "commanddeclaration"}, {"full_name": "ScottContinuous.monotone", "code": "protected theorem ScottContinuous.monotone (h : ScottContinuous f) : Monotone f", "start": [1659, 1], "end": [1665, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ULift.lean", "imports": ["Mathlib/Logic/Equiv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PLift.up_injective", "code": "theorem up_injective : Injective (@up \u03b1)", "start": [41, 1], "end": [42, 29], "kind": "commanddeclaration"}, {"full_name": "PLift.up_surjective", "code": "theorem up_surjective : Surjective (@up \u03b1)", "start": [45, 1], "end": [46, 30], "kind": "commanddeclaration"}, {"full_name": "PLift.up_bijective", "code": "theorem up_bijective : Bijective (@up \u03b1)", "start": [49, 1], "end": [50, 29], "kind": "commanddeclaration"}, {"full_name": "PLift.up_inj", "code": "@[simp]\ntheorem up_inj {x y : \u03b1} : up x = up y \u2194 x = y", "start": [53, 1], "end": [55, 22], "kind": "commanddeclaration"}, {"full_name": "PLift.down_surjective", "code": "theorem down_surjective : Surjective (@down \u03b1)", "start": [58, 1], "end": [59, 25], "kind": "commanddeclaration"}, {"full_name": "PLift.down_bijective", "code": "theorem down_bijective : Bijective (@down \u03b1)", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "PLift.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : PLift \u03b1 \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 x : \u03b1, p (PLift.up x)", "start": [66, 1], "end": [68, 23], "kind": "commanddeclaration"}, {"full_name": "PLift.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : PLift \u03b1 \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 x : \u03b1, p (PLift.up x)", "start": [71, 1], "end": [73, 23], "kind": "commanddeclaration"}, {"full_name": "ULift.up_injective", "code": "theorem up_injective : Injective (@up \u03b1)", "start": [97, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "ULift.up_surjective", "code": "theorem up_surjective : Surjective (@up \u03b1)", "start": [101, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "ULift.up_bijective", "code": "theorem up_bijective : Bijective (@up \u03b1)", "start": [105, 1], "end": [106, 29], "kind": "commanddeclaration"}, {"full_name": "ULift.up_inj", "code": "@[simp]\ntheorem up_inj {x y : \u03b1} : up x = up y \u2194 x = y", "start": [109, 1], "end": [111, 22], "kind": "commanddeclaration"}, {"full_name": "ULift.down_surjective", "code": "theorem down_surjective : Surjective (@down \u03b1)", "start": [114, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "ULift.down_bijective", "code": "theorem down_bijective : Bijective (@down \u03b1)", "start": [118, 1], "end": [119, 24], "kind": "commanddeclaration"}, {"full_name": "ULift.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : ULift \u03b1 \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 x : \u03b1, p (ULift.up x)", "start": [122, 1], "end": [124, 23], "kind": "commanddeclaration"}, {"full_name": "ULift.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : ULift \u03b1 \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 x : \u03b1, p (ULift.up x)", "start": [127, 1], "end": [129, 23], "kind": "commanddeclaration"}, {"full_name": "ULift.ext", "code": "@[ext]\ntheorem ext (x y : ULift \u03b1) (h : x.down = y.down) : x = y", "start": [132, 1], "end": [134, 16], "kind": "commanddeclaration"}, {"full_name": "ULift.ext_iff", "code": "theorem ext_iff {\u03b1 : Type*} (x y : ULift \u03b1) : x = y \u2194 x.down = y.down", "start": [137, 1], "end": [138, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Range.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/Multiset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.range", "code": "def range (n : \u2115) : Multiset \u2115 :=\n  List.range n", "start": [19, 1], "end": [22, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_range", "code": "theorem coe_range (n : \u2115) : \u2191(List.range n) = range n", "start": [25, 1], "end": [26, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_zero", "code": "@[simp]\ntheorem range_zero : range 0 = 0", "start": [29, 1], "end": [31, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_succ", "code": "@[simp]\ntheorem range_succ (n : \u2115) : range (succ n) = n ::\u2098 range n", "start": [34, 1], "end": [36, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_range", "code": "@[simp]\ntheorem card_range (n : \u2115) : card (range n) = n", "start": [39, 1], "end": [41, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_subset", "code": "theorem range_subset {m n : \u2115} : range m \u2286 range n \u2194 m \u2264 n", "start": [44, 1], "end": [45, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_range", "code": "@[simp]\ntheorem mem_range {m n : \u2115} : m \u2208 range n \u2194 m < n", "start": [48, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.not_mem_range_self", "code": "theorem not_mem_range_self {n : \u2115} : n \u2209 range n", "start": [54, 1], "end": [55, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.self_mem_range_succ", "code": "theorem self_mem_range_succ (n : \u2115) : n \u2208 range (n + 1)", "start": [58, 1], "end": [59, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_add", "code": "theorem range_add (a b : \u2115) : range (a + b) = range a + (range b).map (a + \u00b7)", "start": [62, 1], "end": [63, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_disjoint_map_add", "code": "theorem range_disjoint_map_add (a : \u2115) (m : Multiset \u2115) :\n    (range a).Disjoint (m.map (a + \u00b7))", "start": [66, 1], "end": [71, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_add_eq_union", "code": "theorem range_add_eq_union (a b : \u2115) : range (a + b) = range a \u222a (range b).map (a + \u00b7)", "start": [74, 1], "end": [76, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Bind.lean", "imports": ["Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.join", "code": "def join : Multiset (Multiset \u03b1) \u2192 Multiset \u03b1 :=\n  sum", "start": [32, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_join", "code": "theorem coe_join :\n    \u2200 L : List (List \u03b1), join (L.map ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) : Multiset (Multiset \u03b1)) = L.join", "start": [39, 1], "end": [44, 91], "kind": "commanddeclaration"}, {"full_name": "Multiset.join_zero", "code": "@[simp]\ntheorem join_zero : @join \u03b1 0 = 0", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.join_cons", "code": "@[simp]\ntheorem join_cons (s S) : @join \u03b1 (s ::\u2098 S) = s + join S", "start": [52, 1], "end": [54, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.join_add", "code": "@[simp]\ntheorem join_add (S T) : @join \u03b1 (S + T) = join S + join T", "start": [57, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_join", "code": "@[simp]\ntheorem singleton_join (a) : join ({a} : Multiset (Multiset \u03b1)) = a", "start": [62, 1], "end": [64, 18], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_join", "code": "@[simp]\ntheorem mem_join {a S} : a \u2208 @join \u03b1 S \u2194 \u2203 s \u2208 S, a \u2208 s", "start": [67, 1], "end": [70, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_join", "code": "@[simp]\ntheorem card_join (S) : card (@join \u03b1 S) = sum (map card S)", "start": [73, 1], "end": [75, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_join", "code": "theorem rel_join {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {s t} (h : Rel (Rel r) s t) : Rel r s.join t.join", "start": [78, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind", "code": "def bind (s : Multiset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) : Multiset \u03b2 :=\n  (s.map f).join", "start": [91, 1], "end": [94, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_bind", "code": "@[simp]\ntheorem coe_bind (l : List \u03b1) (f : \u03b1 \u2192 List \u03b2) : (@bind \u03b1 \u03b2 l fun a => f a) = l.bind f", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_bind", "code": "@[simp]\ntheorem zero_bind : bind 0 f = 0", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_bind", "code": "@[simp]\ntheorem cons_bind : (a ::\u2098 s).bind f = f a + s.bind f", "start": [108, 1], "end": [109, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.singleton_bind", "code": "@[simp]\ntheorem singleton_bind : bind {a} f = f a", "start": [112, 1], "end": [113, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_bind", "code": "@[simp]\ntheorem add_bind : (s + t).bind f = s.bind f + t.bind f", "start": [116, 1], "end": [117, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_zero", "code": "@[simp]\ntheorem bind_zero : s.bind (fun _ => 0 : \u03b1 \u2192 Multiset \u03b2) = 0", "start": [120, 1], "end": [121, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_add", "code": "@[simp]\ntheorem bind_add : (s.bind fun a => f a + g a) = s.bind f + s.bind g", "start": [124, 1], "end": [125, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_cons", "code": "@[simp]\ntheorem bind_cons (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 Multiset \u03b2) :\n    (s.bind fun a => f a ::\u2098 g a) = map f s + s.bind g", "start": [128, 1], "end": [132, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_singleton", "code": "@[simp]\ntheorem bind_singleton (f : \u03b1 \u2192 \u03b2) : (s.bind fun x => ({f x} : Multiset \u03b2)) = map f s", "start": [135, 1], "end": [137, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_bind", "code": "@[simp]\ntheorem mem_bind {b s} {f : \u03b1 \u2192 Multiset \u03b2} : b \u2208 bind s f \u2194 \u2203 a \u2208 s, b \u2208 f a", "start": [140, 1], "end": [142, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_bind", "code": "@[simp]\ntheorem card_bind : card (s.bind f) = (s.map (card \u2218 f)).sum", "start": [145, 1], "end": [146, 79], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_congr", "code": "theorem bind_congr {f g : \u03b1 \u2192 Multiset \u03b2} {m : Multiset \u03b1} :\n    (\u2200 a \u2208 m, f a = g a) \u2192 bind m f = bind m g", "start": [149, 1], "end": [150, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_hcongr", "code": "theorem bind_hcongr {\u03b2' : Type v} {m : Multiset \u03b1} {f : \u03b1 \u2192 Multiset \u03b2} {f' : \u03b1 \u2192 Multiset \u03b2'}\n    (h : \u03b2 = \u03b2') (hf : \u2200 a \u2208 m, HEq (f a) (f' a)) : HEq (bind m f) (bind m f')", "start": [153, 1], "end": [157, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_bind", "code": "theorem map_bind (m : Multiset \u03b1) (n : \u03b1 \u2192 Multiset \u03b2) (f : \u03b2 \u2192 \u03b3) :\n    map f (bind m n) = bind m fun a => map f (n a)", "start": [160, 1], "end": [162, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_map", "code": "theorem bind_map (m : Multiset \u03b1) (n : \u03b2 \u2192 Multiset \u03b3) (f : \u03b1 \u2192 \u03b2) :\n    bind (map f m) n = bind m fun a => n (f a)", "start": [165, 1], "end": [167, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_assoc", "code": "theorem bind_assoc {s : Multiset \u03b1} {f : \u03b1 \u2192 Multiset \u03b2} {g : \u03b2 \u2192 Multiset \u03b3} :\n    (s.bind f).bind g = s.bind fun a => (f a).bind g", "start": [170, 1], "end": [172, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_bind", "code": "theorem bind_bind (m : Multiset \u03b1) (n : Multiset \u03b2) {f : \u03b1 \u2192 \u03b2 \u2192 Multiset \u03b3} :\n    ((bind m) fun a => (bind n) fun b => f a b) = (bind n) fun b => (bind m) fun a => f a b", "start": [175, 1], "end": [177, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_map_comm", "code": "theorem bind_map_comm (m : Multiset \u03b1) (n : Multiset \u03b2) {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} :\n    ((bind m) fun a => n.map fun b => f a b) = (bind n) fun b => m.map fun a => f a b", "start": [180, 1], "end": [182, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_bind", "code": "@[to_additive (attr := simp)]\ntheorem prod_bind [CommMonoid \u03b2] (s : Multiset \u03b1) (t : \u03b1 \u2192 Multiset \u03b2) :\n    (s.bind t).prod = (s.map fun a => (t a).prod).prod", "start": [185, 1], "end": [188, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.rel_bind", "code": "theorem rel_bind {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b3 \u2192 \u03b4 \u2192 Prop} {s t} {f : \u03b1 \u2192 Multiset \u03b3}\n    {g : \u03b2 \u2192 Multiset \u03b4} (h : (r \u21d2 Rel p) f g) (hst : Rel r s t) :\n    Rel p (s.bind f) (t.bind g)", "start": [192, 1], "end": [197, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_sum", "code": "theorem count_sum [DecidableEq \u03b1] {m : Multiset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} {a : \u03b1} :\n    count a (map f m).sum = sum (m.map fun b => count a <| f b)", "start": [200, 1], "end": [202, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_bind", "code": "theorem count_bind [DecidableEq \u03b1] {m : Multiset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} {a : \u03b1} :\n    count a (bind m f) = sum (m.map fun b => count a <| f b)", "start": [205, 1], "end": [207, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_bind", "code": "theorem le_bind {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 Multiset \u03b2} (S : Multiset \u03b1) {x : \u03b1} (hx : x \u2208 S) :\n    f x \u2264 S.bind f", "start": [210, 1], "end": [218, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_bind_coe", "code": "theorem attach_bind_coe (s : Multiset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) :\n    (s.attach.bind fun i => f i) = s.bind f", "start": [222, 1], "end": [224, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.product", "code": "def product (s : Multiset \u03b1) (t : Multiset \u03b2) : Multiset (\u03b1 \u00d7 \u03b2) :=\n  s.bind fun a => t.map <| Prod.mk a", "start": [236, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.instSProd", "code": "instance instSProd : SProd (Multiset \u03b1) (Multiset \u03b2) (Multiset (\u03b1 \u00d7 \u03b2)) where\n  sprod := Multiset.product", "start": [242, 1], "end": [243, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_product", "code": "@[simp]\ntheorem coe_product (l\u2081 : List \u03b1) (l\u2082 : List \u03b2) :\n    (l\u2081 : Multiset \u03b1) \u00d7\u02e2 (l\u2082 : Multiset \u03b2) = (l\u2081 \u00d7\u02e2 l\u2082)", "start": [245, 1], "end": [250, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_product", "code": "@[simp]\ntheorem zero_product : (0 : Multiset \u03b1) \u00d7\u02e2 t = 0", "start": [253, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_product", "code": "@[simp]\ntheorem cons_product : (a ::\u2098 s) \u00d7\u02e2 t = map (Prod.mk a) t + s \u00d7\u02e2 t", "start": [258, 1], "end": [259, 101], "kind": "commanddeclaration"}, {"full_name": "Multiset.product_zero", "code": "@[simp]\ntheorem product_zero : s \u00d7\u02e2 (0 : Multiset \u03b2) = 0", "start": [262, 1], "end": [263, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.product_cons", "code": "@[simp]\ntheorem product_cons : s \u00d7\u02e2 (b ::\u2098 t) = (s.map fun a => (a, b)) + s \u00d7\u02e2 t", "start": [266, 1], "end": [268, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.product_singleton", "code": "@[simp]\ntheorem product_singleton : ({a} : Multiset \u03b1) \u00d7\u02e2 ({b} : Multiset \u03b2) = {(a, b)}", "start": [271, 1], "end": [273, 66], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_product", "code": "@[simp]\ntheorem add_product (s t : Multiset \u03b1) (u : Multiset \u03b2) : (s + t) \u00d7\u02e2 u = s \u00d7\u02e2 u + t \u00d7\u02e2 u", "start": [276, 1], "end": [278, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.product_add", "code": "@[simp]\ntheorem product_add (s : Multiset \u03b1) : \u2200 t u : Multiset \u03b2, s \u00d7\u02e2 (t + u) = s \u00d7\u02e2 t + s \u00d7\u02e2 u", "start": [281, 1], "end": [285, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_product", "code": "@[simp]\ntheorem mem_product {s t} : \u2200 {p : \u03b1 \u00d7 \u03b2}, p \u2208 @product \u03b1 \u03b2 s t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [288, 1], "end": [290, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_product", "code": "@[simp]\ntheorem card_product : card (s \u00d7\u02e2 t) = card s * card t", "start": [293, 1], "end": [294, 89], "kind": "commanddeclaration"}, {"full_name": "Multiset.sigma", "code": "protected def sigma (s : Multiset \u03b1) (t : \u2200 a, Multiset (\u03c3 a)) : Multiset (\u03a3a, \u03c3 a) :=\n  s.bind fun a => (t a).map <| Sigma.mk a", "start": [306, 1], "end": [309, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_sigma", "code": "@[simp]\ntheorem coe_sigma (l\u2081 : List \u03b1) (l\u2082 : \u2200 a, List (\u03c3 a)) :\n    (@Multiset.sigma \u03b1 \u03c3 l\u2081 fun a => l\u2082 a) = l\u2081.sigma l\u2082", "start": [312, 1], "end": [316, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_sigma", "code": "@[simp]\ntheorem zero_sigma : @Multiset.sigma \u03b1 \u03c3 0 t = 0", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_sigma", "code": "@[simp]\ntheorem cons_sigma : (a ::\u2098 s).sigma t = (t a).map (Sigma.mk a) + s.sigma t", "start": [324, 1], "end": [326, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.sigma_singleton", "code": "@[simp]\ntheorem sigma_singleton (b : \u03b1 \u2192 \u03b2) :\n    (({a} : Multiset \u03b1).sigma fun a => ({b a} : Multiset \u03b2)) = {\u27e8a, b a\u27e9}", "start": [329, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_sigma", "code": "@[simp]\ntheorem add_sigma (s t : Multiset \u03b1) (u : \u2200 a, Multiset (\u03c3 a)) :\n    (s + t).sigma u = s.sigma u + t.sigma u", "start": [335, 1], "end": [337, 72], "kind": "commanddeclaration"}, {"full_name": "Multiset.sigma_add", "code": "@[simp]\ntheorem sigma_add :\n    \u2200 t u : \u2200 a, Multiset (\u03c3 a), (s.sigma fun a => t a + u a) = s.sigma t + s.sigma u", "start": [340, 1], "end": [345, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sigma", "code": "@[simp]\ntheorem mem_sigma {s t} : \u2200 {p : \u03a3a, \u03c3 a}, p \u2208 @Multiset.sigma \u03b1 \u03c3 s t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1", "start": [348, 1], "end": [350, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_sigma", "code": "@[simp]\ntheorem card_sigma : card (s.sigma t) = sum (map (fun a => card (t a)) s)", "start": [353, 1], "end": [355, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CompleteLattice.lean", "imports": ["Mathlib/Data/ULift.lean", "Mathlib/Order/Bounds/Basic.lean", "Mathlib/Data/Nat/Set.lean", "Mathlib/Data/Bool/Set.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Mathport/Notation.lean"], "premises": [{"full_name": "SupSet", "code": "class SupSet (\u03b1 : Type*) where\n  sSup : Set \u03b1 \u2192 \u03b1", "start": [53, 1], "end": [55, 19], "kind": "commanddeclaration"}, {"full_name": "InfSet", "code": "class InfSet (\u03b1 : Type*) where\n  sInf : Set \u03b1 \u2192 \u03b1", "start": [60, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "iSup", "code": "def iSup [SupSet \u03b1] {\u03b9} (s : \u03b9 \u2192 \u03b1) : \u03b1 :=\n  sSup (range s)", "start": [77, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "iInf", "code": "def iInf [InfSet \u03b1] {\u03b9} (s : \u03b9 \u2192 \u03b1) : \u03b1 :=\n  sInf (range s)", "start": [82, 1], "end": [84, 17], "kind": "commanddeclaration"}, {"full_name": "infSet_to_nonempty", "code": "instance (priority := 50) infSet_to_nonempty (\u03b1) [InfSet \u03b1] : Nonempty \u03b1 :=\n  \u27e8sInf \u2205\u27e9", "start": [87, 1], "end": [88, 11], "kind": "commanddeclaration"}, {"full_name": "supSet_to_nonempty", "code": "instance (priority := 50) supSet_to_nonempty (\u03b1) [SupSet \u03b1] : Nonempty \u03b1 :=\n  \u27e8sSup \u2205\u27e9", "start": [91, 1], "end": [92, 11], "kind": "commanddeclaration"}, {"full_name": "iSup_delab", "code": "@[delab app.iSup]\ndef iSup_delab : Delab := whenPPOption Lean.getPPNotation do\n  let #[_, _, \u03b9, f] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  unless f.isLambda do failure\n  let prop \u2190 Meta.isProp \u03b9\n  let dep := f.bindingBody!.hasLooseBVar 0\n  let ppTypes \u2190 getPPOption getPPFunBinderTypes\n  let stx \u2190 SubExpr.withAppArg do\n    let dom \u2190 SubExpr.withBindingDomain delab\n    withBindingBodyUnusedName $ fun x => do\n      let x : TSyntax `ident := .mk x\n      let body \u2190 delab\n      if prop && !dep then\n        `(\u2a06 (_ : $dom), $body)\n      else if prop || ppTypes then\n        `(\u2a06 ($x:ident : $dom), $body)\n      else\n        `(\u2a06 $x:ident, $body)\n  let stx : Term \u2190\n    match stx with\n    | `(\u2a06 $x:ident, \u2a06 (_ : $y:ident \u2208 $s), $body)\n    | `(\u2a06 ($x:ident : $_), \u2a06 (_ : $y:ident \u2208 $s), $body) =>\n      if x == y then `(\u2a06 $x:ident \u2208 $s, $body) else pure stx\n    | _ => pure stx\n  return stx", "start": [116, 1], "end": [142, 13], "kind": "commanddeclaration"}, {"full_name": "iInf_delab", "code": "@[delab app.iInf]\ndef iInf_delab : Delab := whenPPOption Lean.getPPNotation do\n  let #[_, _, \u03b9, f] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  unless f.isLambda do failure\n  let prop \u2190 Meta.isProp \u03b9\n  let dep := f.bindingBody!.hasLooseBVar 0\n  let ppTypes \u2190 getPPOption getPPFunBinderTypes\n  let stx \u2190 SubExpr.withAppArg do\n    let dom \u2190 SubExpr.withBindingDomain delab\n    withBindingBodyUnusedName $ fun x => do\n      let x : TSyntax `ident := .mk x\n      let body \u2190 delab\n      if prop && !dep then\n        `(\u2a05 (_ : $dom), $body)\n      else if prop || ppTypes then\n        `(\u2a05 ($x:ident : $dom), $body)\n      else\n        `(\u2a05 $x:ident, $body)\n  let stx : Term \u2190\n    match stx with\n    | `(\u2a05 $x:ident, \u2a05 (_ : $y:ident \u2208 $s), $body)\n    | `(\u2a05 ($x:ident : $_), \u2a05 (_ : $y:ident \u2208 $s), $body) =>\n      if x == y then `(\u2a05 $x:ident \u2208 $s, $body) else pure stx\n    | _ => pure stx\n  return stx", "start": [144, 1], "end": [170, 13], "kind": "commanddeclaration"}, {"full_name": "OrderDual.supSet", "code": "instance OrderDual.supSet (\u03b1) [InfSet \u03b1] : SupSet \u03b1\u1d52\u1d48 :=\n  \u27e8(sInf : Set \u03b1 \u2192 \u03b1)\u27e9", "start": [173, 1], "end": [174, 23], "kind": "commanddeclaration"}, {"full_name": "OrderDual.infSet", "code": "instance OrderDual.infSet (\u03b1) [SupSet \u03b1] : InfSet \u03b1\u1d52\u1d48 :=\n  \u27e8(sSup : Set \u03b1 \u2192 \u03b1)\u27e9", "start": [176, 1], "end": [177, 23], "kind": "commanddeclaration"}, {"full_name": "CompleteSemilatticeSup", "code": "class CompleteSemilatticeSup (\u03b1 : Type*) extends PartialOrder \u03b1, SupSet \u03b1 where\n  \n  le_sSup : \u2200 s, \u2200 a \u2208 s, a \u2264 sSup s\n  \n  sSup_le : \u2200 s a, (\u2200 b \u2208 s, b \u2264 a) \u2192 sSup s \u2264 a", "start": [179, 1], "end": [188, 49], "kind": "commanddeclaration"}, {"full_name": "le_sSup", "code": "theorem le_sSup : a \u2208 s \u2192 a \u2264 sSup s", "start": [196, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "sSup_le", "code": "theorem sSup_le : (\u2200 b \u2208 s, b \u2264 a) \u2192 sSup s \u2264 a", "start": [200, 1], "end": [201, 37], "kind": "commanddeclaration"}, {"full_name": "isLUB_sSup", "code": "theorem isLUB_sSup (s : Set \u03b1) : IsLUB s (sSup s)", "start": [204, 1], "end": [205, 37], "kind": "commanddeclaration"}, {"full_name": "IsLUB.sSup_eq", "code": "theorem IsLUB.sSup_eq (h : IsLUB s a) : sSup s = a", "start": [208, 1], "end": [209, 26], "kind": "commanddeclaration"}, {"full_name": "le_sSup_of_le", "code": "theorem le_sSup_of_le (hb : b \u2208 s) (h : a \u2264 b) : a \u2264 sSup s", "start": [212, 1], "end": [213, 26], "kind": "commanddeclaration"}, {"full_name": "sSup_le_sSup", "code": "@[gcongr]\ntheorem sSup_le_sSup (h : s \u2286 t) : sSup s \u2264 sSup t", "start": [216, 1], "end": [218, 39], "kind": "commanddeclaration"}, {"full_name": "sSup_le_iff", "code": "@[simp]\ntheorem sSup_le_iff : sSup s \u2264 a \u2194 \u2200 b \u2208 s, b \u2264 a", "start": [221, 1], "end": [223, 30], "kind": "commanddeclaration"}, {"full_name": "le_sSup_iff", "code": "theorem le_sSup_iff : a \u2264 sSup s \u2194 \u2200 b \u2208 upperBounds s, a \u2264 b", "start": [226, 1], "end": [227, 75], "kind": "commanddeclaration"}, {"full_name": "le_iSup_iff", "code": "theorem le_iSup_iff {s : \u03b9 \u2192 \u03b1} : a \u2264 iSup s \u2194 \u2200 b, (\u2200 i, s i \u2264 b) \u2192 a \u2264 b", "start": [230, 1], "end": [231, 40], "kind": "commanddeclaration"}, {"full_name": "sSup_le_sSup_of_forall_exists_le", "code": "theorem sSup_le_sSup_of_forall_exists_le (h : \u2200 x \u2208 s, \u2203 y \u2208 t, x \u2264 y) : sSup s \u2264 sSup t", "start": [234, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "sSup_singleton", "code": "theorem sSup_singleton {a : \u03b1} : sSup {a} = a", "start": [242, 1], "end": [243, 26], "kind": "commanddeclaration"}, {"full_name": "CompleteSemilatticeInf", "code": "class CompleteSemilatticeInf (\u03b1 : Type*) extends PartialOrder \u03b1, InfSet \u03b1 where\n  \n  sInf_le : \u2200 s, \u2200 a \u2208 s, sInf s \u2264 a\n  \n  le_sInf : \u2200 s a, (\u2200 b \u2208 s, a \u2264 b) \u2192 a \u2264 sInf s", "start": [248, 1], "end": [257, 49], "kind": "commanddeclaration"}, {"full_name": "sInf_le", "code": "theorem sInf_le : a \u2208 s \u2192 sInf s \u2264 a", "start": [265, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "le_sInf", "code": "theorem le_sInf : (\u2200 b \u2208 s, a \u2264 b) \u2192 a \u2264 sInf s", "start": [269, 1], "end": [270, 37], "kind": "commanddeclaration"}, {"full_name": "isGLB_sInf", "code": "theorem isGLB_sInf (s : Set \u03b1) : IsGLB s (sInf s)", "start": [273, 1], "end": [274, 39], "kind": "commanddeclaration"}, {"full_name": "IsGLB.sInf_eq", "code": "theorem IsGLB.sInf_eq (h : IsGLB s a) : sInf s = a", "start": [277, 1], "end": [278, 26], "kind": "commanddeclaration"}, {"full_name": "sInf_le_of_le", "code": "theorem sInf_le_of_le (hb : b \u2208 s) (h : b \u2264 a) : sInf s \u2264 a", "start": [281, 1], "end": [282, 26], "kind": "commanddeclaration"}, {"full_name": "sInf_le_sInf", "code": "@[gcongr]\ntheorem sInf_le_sInf (h : s \u2286 t) : sInf t \u2264 sInf s", "start": [285, 1], "end": [287, 39], "kind": "commanddeclaration"}, {"full_name": "le_sInf_iff", "code": "@[simp]\ntheorem le_sInf_iff : a \u2264 sInf s \u2194 \u2200 b \u2208 s, a \u2264 b", "start": [290, 1], "end": [292, 30], "kind": "commanddeclaration"}, {"full_name": "sInf_le_iff", "code": "theorem sInf_le_iff : sInf s \u2264 a \u2194 \u2200 b \u2208 lowerBounds s, b \u2264 a", "start": [295, 1], "end": [296, 75], "kind": "commanddeclaration"}, {"full_name": "iInf_le_iff", "code": "theorem iInf_le_iff {s : \u03b9 \u2192 \u03b1} : iInf s \u2264 a \u2194 \u2200 b, (\u2200 i, b \u2264 s i) \u2192 b \u2264 a", "start": [299, 1], "end": [300, 40], "kind": "commanddeclaration"}, {"full_name": "sInf_le_sInf_of_forall_exists_le", "code": "theorem sInf_le_sInf_of_forall_exists_le (h : \u2200 x \u2208 s, \u2203 y \u2208 t, y \u2264 x) : sInf t \u2264 sInf s", "start": [303, 1], "end": [309, 38], "kind": "commanddeclaration"}, {"full_name": "sInf_singleton", "code": "theorem sInf_singleton {a : \u03b1} : sInf {a} = a", "start": [313, 1], "end": [314, 26], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice", "code": "class CompleteLattice (\u03b1 : Type*) extends Lattice \u03b1, CompleteSemilatticeSup \u03b1,\n  CompleteSemilatticeInf \u03b1, Top \u03b1, Bot \u03b1 where\n  \n  protected le_top : \u2200 x : \u03b1, x \u2264 \u22a4\n  \n  protected bot_le : \u2200 x : \u03b1, \u22a5 \u2264 x", "start": [319, 1], "end": [325, 36], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.toBoundedOrder", "code": "instance (priority := 100) CompleteLattice.toBoundedOrder [h : CompleteLattice \u03b1] :\n    BoundedOrder \u03b1 :=\n  { h with }", "start": [329, 1], "end": [331, 13], "kind": "commanddeclaration"}, {"full_name": "completeLatticeOfInf", "code": "def completeLatticeOfInf (\u03b1 : Type*) [H1 : PartialOrder \u03b1] [H2 : InfSet \u03b1]\n    (isGLB_sInf : \u2200 s : Set \u03b1, IsGLB s (sInf s)) : CompleteLattice \u03b1 :=\n  { H1, H2 with\n    bot := sInf univ\n    bot_le := fun x => (isGLB_sInf univ).1 trivial\n    top := sInf \u2205\n    le_top := fun a => (isGLB_sInf \u2205).2 <| by simp\n    sup := fun a b => sInf { x : \u03b1 | a \u2264 x \u2227 b \u2264 x }\n    inf := fun a b => sInf {a, b}\n    le_inf := fun a b c hab hac => by\n      apply (isGLB_sInf _).2\n      simp [*]\n    inf_le_right := fun a b => (isGLB_sInf _).1 <| mem_insert_of_mem _ <| mem_singleton _\n    inf_le_left := fun a b => (isGLB_sInf _).1 <| mem_insert _ _\n    sup_le := fun a b c hac hbc => (isGLB_sInf _).1 <| by simp [*]\n    le_sup_left := fun a b => (isGLB_sInf _).2 fun x => And.left\n    le_sup_right := fun a b => (isGLB_sInf _).2 fun x => And.right\n    le_sInf := fun s a ha => (isGLB_sInf s).2 ha\n    sInf_le := fun s a ha => (isGLB_sInf s).1 ha\n    sSup := fun s => sInf (upperBounds s)\n    le_sSup := fun s a ha => (isGLB_sInf (upperBounds s)).2 fun b hb => hb ha\n    sSup_le := fun s a ha => (isGLB_sInf (upperBounds s)).1 ha }", "start": [334, 1], "end": [370, 65], "kind": "commanddeclaration"}, {"full_name": "completeLatticeOfCompleteSemilatticeInf", "code": "def completeLatticeOfCompleteSemilatticeInf (\u03b1 : Type*) [CompleteSemilatticeInf \u03b1] :\n    CompleteLattice \u03b1 :=\n  completeLatticeOfInf \u03b1 fun s => isGLB_sInf s", "start": [373, 1], "end": [380, 47], "kind": "commanddeclaration"}, {"full_name": "completeLatticeOfSup", "code": "def completeLatticeOfSup (\u03b1 : Type*) [H1 : PartialOrder \u03b1] [H2 : SupSet \u03b1]\n    (isLUB_sSup : \u2200 s : Set \u03b1, IsLUB s (sSup s)) : CompleteLattice \u03b1 :=\n  { H1, H2 with\n    top := sSup univ\n    le_top := fun x => (isLUB_sSup univ).1 trivial\n    bot := sSup \u2205\n    bot_le := fun x => (isLUB_sSup \u2205).2 <| by simp\n    sup := fun a b => sSup {a, b}\n    sup_le := fun a b c hac hbc => (isLUB_sSup _).2 (by simp [*])\n    le_sup_left := fun a b => (isLUB_sSup _).1 <| mem_insert _ _\n    le_sup_right := fun a b => (isLUB_sSup _).1 <| mem_insert_of_mem _ <| mem_singleton _\n    inf := fun a b => sSup { x | x \u2264 a \u2227 x \u2264 b }\n    le_inf := fun a b c hab hac => (isLUB_sSup _).1 <| by simp [*]\n    inf_le_left := fun a b => (isLUB_sSup _).2 fun x => And.left\n    inf_le_right := fun a b => (isLUB_sSup _).2 fun x => And.right\n    sInf := fun s => sSup (lowerBounds s)\n    sSup_le := fun s a ha => (isLUB_sSup s).2 ha\n    le_sSup := fun s a ha => (isLUB_sSup s).1 ha\n    sInf_le := fun s a ha => (isLUB_sSup (lowerBounds s)).2 fun b hb => hb ha\n    le_sInf := fun s a ha => (isLUB_sSup (lowerBounds s)).1 ha }", "start": [383, 1], "end": [417, 65], "kind": "commanddeclaration"}, {"full_name": "completeLatticeOfCompleteSemilatticeSup", "code": "def completeLatticeOfCompleteSemilatticeSup (\u03b1 : Type*) [CompleteSemilatticeSup \u03b1] :\n    CompleteLattice \u03b1 :=\n  completeLatticeOfSup \u03b1 fun s => isLUB_sSup s", "start": [420, 1], "end": [427, 47], "kind": "commanddeclaration"}, {"full_name": "CompleteLinearOrder", "code": "class CompleteLinearOrder (\u03b1 : Type*) extends CompleteLattice \u03b1 where\n  \n  le_total (a b : \u03b1) : a \u2264 b \u2228 b \u2264 a\n  \n  decidableLE : DecidableRel (\u00b7 \u2264 \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop)\n  \n  decidableEq : DecidableEq \u03b1 := @decidableEqOfDecidableLE _ _ decidableLE\n  \n  decidableLT : DecidableRel (\u00b7 < \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE", "start": [434, 1], "end": [444, 46], "kind": "commanddeclaration"}, {"full_name": "CompleteLinearOrder.toLinearOrder", "code": "instance CompleteLinearOrder.toLinearOrder [i : CompleteLinearOrder \u03b1] : LinearOrder \u03b1 :=\n  { i with\n    min := Inf.inf\n    max := Sup.sup\n    min_def := fun a b => by\n      split_ifs with h\n      \u00b7 simp [h]\n      \u00b7 simp [(CompleteLinearOrder.le_total a b).resolve_left h]\n    max_def := fun a b => by\n      split_ifs with h\n      \u00b7 simp [h]\n      \u00b7 simp [(CompleteLinearOrder.le_total a b).resolve_left h] }", "start": [447, 1], "end": [458, 67], "kind": "commanddeclaration"}, {"full_name": "OrderDual.completeLattice", "code": "instance completeLattice [CompleteLattice \u03b1] : CompleteLattice \u03b1\u1d52\u1d48 :=\n  { OrderDual.lattice \u03b1, OrderDual.supSet \u03b1, OrderDual.infSet \u03b1, OrderDual.boundedOrder \u03b1 with\n    le_sSup := @CompleteLattice.sInf_le \u03b1 _\n    sSup_le := @CompleteLattice.le_sInf \u03b1 _\n    sInf_le := @CompleteLattice.le_sSup \u03b1 _\n    le_sInf := @CompleteLattice.sSup_le \u03b1 _ }", "start": [464, 1], "end": [469, 46], "kind": "commanddeclaration"}, {"full_name": "toDual_sSup", "code": "@[simp]\ntheorem toDual_sSup (s : Set \u03b1) : toDual (sSup s) = sInf (ofDual \u207b\u00b9' s)", "start": [482, 1], "end": [484, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_sInf", "code": "@[simp]\ntheorem toDual_sInf (s : Set \u03b1) : toDual (sInf s) = sSup (ofDual \u207b\u00b9' s)", "start": [487, 1], "end": [489, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_sSup", "code": "@[simp]\ntheorem ofDual_sSup (s : Set \u03b1\u1d52\u1d48) : ofDual (sSup s) = sInf (toDual \u207b\u00b9' s)", "start": [492, 1], "end": [494, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_sInf", "code": "@[simp]\ntheorem ofDual_sInf (s : Set \u03b1\u1d52\u1d48) : ofDual (sInf s) = sSup (toDual \u207b\u00b9' s)", "start": [497, 1], "end": [499, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_iSup", "code": "@[simp]\ntheorem toDual_iSup (f : \u03b9 \u2192 \u03b1) : toDual (\u2a06 i, f i) = \u2a05 i, toDual (f i)", "start": [502, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_iInf", "code": "@[simp]\ntheorem toDual_iInf (f : \u03b9 \u2192 \u03b1) : toDual (\u2a05 i, f i) = \u2a06 i, toDual (f i)", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_iSup", "code": "@[simp]\ntheorem ofDual_iSup (f : \u03b9 \u2192 \u03b1\u1d52\u1d48) : ofDual (\u2a06 i, f i) = \u2a05 i, ofDual (f i)", "start": [512, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_iInf", "code": "@[simp]\ntheorem ofDual_iInf (f : \u03b9 \u2192 \u03b1\u1d52\u1d48) : ofDual (\u2a05 i, f i) = \u2a06 i, ofDual (f i)", "start": [517, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "sInf_le_sSup", "code": "theorem sInf_le_sSup (hs : s.Nonempty) : sInf s \u2264 sSup s", "start": [522, 1], "end": [523, 50], "kind": "commanddeclaration"}, {"full_name": "sSup_union", "code": "theorem sSup_union {s t : Set \u03b1} : sSup (s \u222a t) = sSup s \u2294 sSup t", "start": [526, 1], "end": [527, 48], "kind": "commanddeclaration"}, {"full_name": "sInf_union", "code": "theorem sInf_union {s t : Set \u03b1} : sInf (s \u222a t) = sInf s \u2293 sInf t", "start": [530, 1], "end": [531, 48], "kind": "commanddeclaration"}, {"full_name": "sSup_inter_le", "code": "theorem sSup_inter_le {s t : Set \u03b1} : sSup (s \u2229 t) \u2264 sSup s \u2293 sSup t", "start": [534, 1], "end": [535, 59], "kind": "commanddeclaration"}, {"full_name": "le_sInf_inter", "code": "theorem le_sInf_inter {s t : Set \u03b1} : sInf s \u2294 sInf t \u2264 sInf (s \u2229 t)", "start": [538, 1], "end": [539, 27], "kind": "commanddeclaration"}, {"full_name": "sSup_empty", "code": "@[simp]\ntheorem sSup_empty : sSup \u2205 = (\u22a5 : \u03b1)", "start": [542, 1], "end": [544, 31], "kind": "commanddeclaration"}, {"full_name": "sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf \u2205 = (\u22a4 : \u03b1)", "start": [547, 1], "end": [549, 31], "kind": "commanddeclaration"}, {"full_name": "sSup_univ", "code": "@[simp]\ntheorem sSup_univ : sSup univ = (\u22a4 : \u03b1)", "start": [552, 1], "end": [554, 30], "kind": "commanddeclaration"}, {"full_name": "sInf_univ", "code": "@[simp]\ntheorem sInf_univ : sInf univ = (\u22a5 : \u03b1)", "start": [557, 1], "end": [559, 30], "kind": "commanddeclaration"}, {"full_name": "sSup_insert", "code": "@[simp]\ntheorem sSup_insert {a : \u03b1} {s : Set \u03b1} : sSup (insert a s) = a \u2294 sSup s", "start": [563, 1], "end": [565, 36], "kind": "commanddeclaration"}, {"full_name": "sInf_insert", "code": "@[simp]\ntheorem sInf_insert {a : \u03b1} {s : Set \u03b1} : sInf (insert a s) = a \u2293 sInf s", "start": [568, 1], "end": [570, 36], "kind": "commanddeclaration"}, {"full_name": "sSup_le_sSup_of_subset_insert_bot", "code": "theorem sSup_le_sSup_of_subset_insert_bot (h : s \u2286 insert \u22a5 t) : sSup s \u2264 sSup t", "start": [573, 1], "end": [574, 77], "kind": "commanddeclaration"}, {"full_name": "sInf_le_sInf_of_subset_insert_top", "code": "theorem sInf_le_sInf_of_subset_insert_top (h : s \u2286 insert \u22a4 t) : sInf t \u2264 sInf s", "start": [577, 1], "end": [578, 87], "kind": "commanddeclaration"}, {"full_name": "sSup_diff_singleton_bot", "code": "@[simp]\ntheorem sSup_diff_singleton_bot (s : Set \u03b1) : sSup (s \\ {\u22a5}) = sSup s", "start": [581, 1], "end": [584, 74], "kind": "commanddeclaration"}, {"full_name": "sInf_diff_singleton_top", "code": "@[simp]\ntheorem sInf_diff_singleton_top (s : Set \u03b1) : sInf (s \\ {\u22a4}) = sInf s", "start": [587, 1], "end": [589, 35], "kind": "commanddeclaration"}, {"full_name": "sSup_pair", "code": "theorem sSup_pair {a b : \u03b1} : sSup {a, b} = a \u2294 b", "start": [592, 1], "end": [593, 32], "kind": "commanddeclaration"}, {"full_name": "sInf_pair", "code": "theorem sInf_pair {a b : \u03b1} : sInf {a, b} = a \u2293 b", "start": [596, 1], "end": [597, 32], "kind": "commanddeclaration"}, {"full_name": "sSup_eq_bot", "code": "@[simp]\ntheorem sSup_eq_bot : sSup s = \u22a5 \u2194 \u2200 a \u2208 s, a = \u22a5", "start": [600, 1], "end": [603, 62], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_top", "code": "@[simp]\ntheorem sInf_eq_top : sInf s = \u22a4 \u2194 \u2200 a \u2208 s, a = \u22a4", "start": [606, 1], "end": [608, 23], "kind": "commanddeclaration"}, {"full_name": "eq_singleton_bot_of_sSup_eq_bot_of_nonempty", "code": "theorem eq_singleton_bot_of_sSup_eq_bot_of_nonempty {s : Set \u03b1} (h_sup : sSup s = \u22a5)\n    (hne : s.Nonempty) : s = {\u22a5}", "start": [611, 1], "end": [615, 21], "kind": "commanddeclaration"}, {"full_name": "eq_singleton_top_of_sInf_eq_top_of_nonempty", "code": "theorem eq_singleton_top_of_sInf_eq_top_of_nonempty : sInf s = \u22a4 \u2192 s.Nonempty \u2192 s = {\u22a4}", "start": [618, 1], "end": [619, 55], "kind": "commanddeclaration"}, {"full_name": "sSup_eq_of_forall_le_of_forall_lt_exists_gt", "code": "theorem sSup_eq_of_forall_le_of_forall_lt_exists_gt (h\u2081 : \u2200 a \u2208 s, a \u2264 b)\n    (h\u2082 : \u2200 w, w < b \u2192 \u2203 a \u2208 s, w < a) : sSup s = b", "start": [622, 1], "end": [630, 38], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_of_forall_ge_of_forall_gt_exists_lt", "code": "theorem sInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    (\u2200 a \u2208 s, b \u2264 a) \u2192 (\u2200 w, b < w \u2192 \u2203 a \u2208 s, a < w) \u2192 sInf s = b", "start": [633, 1], "end": [639, 57], "kind": "commanddeclaration"}, {"full_name": "lt_sSup_iff", "code": "theorem lt_sSup_iff : b < sSup s \u2194 \u2203 a \u2208 s, b < a", "start": [648, 1], "end": [649, 31], "kind": "commanddeclaration"}, {"full_name": "sInf_lt_iff", "code": "theorem sInf_lt_iff : sInf s < b \u2194 \u2203 a \u2208 s, a < b", "start": [652, 1], "end": [653, 31], "kind": "commanddeclaration"}, {"full_name": "sSup_eq_top", "code": "theorem sSup_eq_top : sSup s = \u22a4 \u2194 \u2200 b < \u22a4, \u2203 a \u2208 s, b < a", "start": [656, 1], "end": [661, 42], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_bot", "code": "theorem sInf_eq_bot : sInf s = \u22a5 \u2194 \u2200 b > \u22a5, \u2203 a \u2208 s, a < b", "start": [664, 1], "end": [665, 23], "kind": "commanddeclaration"}, {"full_name": "lt_iSup_iff", "code": "theorem lt_iSup_iff {f : \u03b9 \u2192 \u03b1} : a < iSup f \u2194 \u2203 i, a < f i", "start": [668, 1], "end": [669, 37], "kind": "commanddeclaration"}, {"full_name": "iInf_lt_iff", "code": "theorem iInf_lt_iff {f : \u03b9 \u2192 \u03b1} : iInf f < a \u2194 \u2203 i, f i < a", "start": [672, 1], "end": [673, 37], "kind": "commanddeclaration"}, {"full_name": "sSup_range", "code": "theorem sSup_range : sSup (range f) = iSup f", "start": [685, 1], "end": [686, 6], "kind": "commanddeclaration"}, {"full_name": "sSup_eq_iSup'", "code": "theorem sSup_eq_iSup' (s : Set \u03b1) : sSup s = \u2a06 a : s, (a : \u03b1)", "start": [689, 1], "end": [689, 97], "kind": "commanddeclaration"}, {"full_name": "iSup_congr", "code": "theorem iSup_congr (h : \u2200 i, f i = g i) : \u2a06 i, f i = \u2a06 i, g i", "start": [692, 1], "end": [693, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iSup_comp", "code": "theorem Function.Surjective.iSup_comp {f : \u03b9 \u2192 \u03b9'} (hf : Surjective f) (g : \u03b9' \u2192 \u03b1) :\n    \u2a06 x, g (f x) = \u2a06 y, g y", "start": [696, 1], "end": [700, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.iSup_comp", "code": "theorem Equiv.iSup_comp {g : \u03b9' \u2192 \u03b1} (e : \u03b9 \u2243 \u03b9') : \u2a06 x, g (e x) = \u2a06 y, g y", "start": [703, 1], "end": [704, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iSup_congr", "code": "protected theorem Function.Surjective.iSup_congr {g : \u03b9' \u2192 \u03b1} (h : \u03b9 \u2192 \u03b9') (h1 : Surjective h)\n    (h2 : \u2200 x, g (h x) = f x) : \u2a06 x, f x = \u2a06 y, g y", "start": [707, 1], "end": [710, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.iSup_congr", "code": "protected theorem Equiv.iSup_congr {g : \u03b9' \u2192 \u03b1} (e : \u03b9 \u2243 \u03b9') (h : \u2200 x, g (e x) = f x) :\n    \u2a06 x, f x = \u2a06 y, g y", "start": [713, 1], "end": [715, 30], "kind": "commanddeclaration"}, {"full_name": "iSup_congr_Prop", "code": "@[congr]\ntheorem iSup_congr_Prop {p q : Prop} {f\u2081 : p \u2192 \u03b1} {f\u2082 : q \u2192 \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iSup f\u2081 = iSup f\u2082", "start": [718, 1], "end": [723, 10], "kind": "commanddeclaration"}, {"full_name": "iSup_plift_up", "code": "theorem iSup_plift_up (f : PLift \u03b9 \u2192 \u03b1) : \u2a06 i, f (PLift.up i) = \u2a06 i, f i", "start": [726, 1], "end": [727, 50], "kind": "commanddeclaration"}, {"full_name": "iSup_plift_down", "code": "theorem iSup_plift_down (f : \u03b9 \u2192 \u03b1) : \u2a06 i, f (PLift.down i) = \u2a06 i, f i", "start": [730, 1], "end": [731, 52], "kind": "commanddeclaration"}, {"full_name": "iSup_range'", "code": "theorem iSup_range' (g : \u03b2 \u2192 \u03b1) (f : \u03b9 \u2192 \u03b2) : \u2a06 b : range f, g b = \u2a06 i, g (f i)", "start": [734, 1], "end": [736, 6], "kind": "commanddeclaration"}, {"full_name": "sSup_image'", "code": "theorem sSup_image' {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : sSup (f '' s) = \u2a06 a : s, f a", "start": [739, 1], "end": [740, 28], "kind": "commanddeclaration"}, {"full_name": "sInf_range", "code": "theorem sInf_range : sInf (range f) = iInf f", "start": [749, 1], "end": [750, 6], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_iInf'", "code": "theorem sInf_eq_iInf' (s : Set \u03b1) : sInf s = \u2a05 a : s, (a : \u03b1)", "start": [753, 1], "end": [754, 25], "kind": "commanddeclaration"}, {"full_name": "iInf_congr", "code": "theorem iInf_congr (h : \u2200 i, f i = g i) : \u2a05 i, f i = \u2a05 i, g i", "start": [757, 1], "end": [758, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iInf_comp", "code": "theorem Function.Surjective.iInf_comp {f : \u03b9 \u2192 \u03b9'} (hf : Surjective f) (g : \u03b9' \u2192 \u03b1) :\n    \u2a05 x, g (f x) = \u2a05 y, g y", "start": [761, 1], "end": [763, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.iInf_comp", "code": "theorem Equiv.iInf_comp {g : \u03b9' \u2192 \u03b1} (e : \u03b9 \u2243 \u03b9') : \u2a05 x, g (e x) = \u2a05 y, g y", "start": [766, 1], "end": [767, 33], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iInf_congr", "code": "protected theorem Function.Surjective.iInf_congr {g : \u03b9' \u2192 \u03b1} (h : \u03b9 \u2192 \u03b9') (h1 : Surjective h)\n    (h2 : \u2200 x, g (h x) = f x) : \u2a05 x, f x = \u2a05 y, g y", "start": [770, 1], "end": [772, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.iInf_congr", "code": "protected theorem Equiv.iInf_congr {g : \u03b9' \u2192 \u03b1} (e : \u03b9 \u2243 \u03b9') (h : \u2200 x, g (e x) = f x) :\n    \u2a05 x, f x = \u2a05 y, g y", "start": [775, 1], "end": [777, 38], "kind": "commanddeclaration"}, {"full_name": "iInf_congr_Prop", "code": "@[congr]\ntheorem iInf_congr_Prop {p q : Prop} {f\u2081 : p \u2192 \u03b1} {f\u2082 : q \u2192 \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iInf f\u2081 = iInf f\u2082", "start": [780, 1], "end": [783, 40], "kind": "commanddeclaration"}, {"full_name": "iInf_plift_up", "code": "theorem iInf_plift_up (f : PLift \u03b9 \u2192 \u03b1) : \u2a05 i, f (PLift.up i) = \u2a05 i, f i", "start": [786, 1], "end": [787, 50], "kind": "commanddeclaration"}, {"full_name": "iInf_plift_down", "code": "theorem iInf_plift_down (f : \u03b9 \u2192 \u03b1) : \u2a05 i, f (PLift.down i) = \u2a05 i, f i", "start": [790, 1], "end": [791, 52], "kind": "commanddeclaration"}, {"full_name": "iInf_range'", "code": "theorem iInf_range' (g : \u03b2 \u2192 \u03b1) (f : \u03b9 \u2192 \u03b2) : \u2a05 b : range f, g b = \u2a05 i, g (f i)", "start": [794, 1], "end": [795, 29], "kind": "commanddeclaration"}, {"full_name": "sInf_image'", "code": "theorem sInf_image' {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : sInf (f '' s) = \u2a05 a : s, f a", "start": [798, 1], "end": [799, 27], "kind": "commanddeclaration"}, {"full_name": "le_iSup", "code": "theorem le_iSup (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : f i \u2264 iSup f", "start": [810, 1], "end": [811, 19], "kind": "commanddeclaration"}, {"full_name": "iInf_le", "code": "theorem iInf_le (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i", "start": [814, 1], "end": [815, 19], "kind": "commanddeclaration"}, {"full_name": "le_iSup'", "code": "theorem le_iSup' (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : f i \u2264 iSup f", "start": [819, 1], "end": [820, 19], "kind": "commanddeclaration"}, {"full_name": "iInf_le'", "code": "theorem iInf_le' (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i", "start": [824, 1], "end": [825, 19], "kind": "commanddeclaration"}, {"full_name": "isLUB_iSup", "code": "theorem isLUB_iSup : IsLUB (range f) (\u2a06 j, f j)", "start": [833, 1], "end": [834, 15], "kind": "commanddeclaration"}, {"full_name": "isGLB_iInf", "code": "theorem isGLB_iInf : IsGLB (range f) (\u2a05 j, f j)", "start": [837, 1], "end": [838, 15], "kind": "commanddeclaration"}, {"full_name": "IsLUB.iSup_eq", "code": "theorem IsLUB.iSup_eq (h : IsLUB (range f) a) : \u2a06 j, f j = a", "start": [841, 1], "end": [842, 12], "kind": "commanddeclaration"}, {"full_name": "IsGLB.iInf_eq", "code": "theorem IsGLB.iInf_eq (h : IsGLB (range f) a) : \u2a05 j, f j = a", "start": [845, 1], "end": [846, 12], "kind": "commanddeclaration"}, {"full_name": "le_iSup_of_le", "code": "theorem le_iSup_of_le (i : \u03b9) (h : a \u2264 f i) : a \u2264 iSup f", "start": [849, 1], "end": [850, 25], "kind": "commanddeclaration"}, {"full_name": "iInf_le_of_le", "code": "theorem iInf_le_of_le (i : \u03b9) (h : f i \u2264 a) : iInf f \u2264 a", "start": [853, 1], "end": [854, 24], "kind": "commanddeclaration"}, {"full_name": "le_iSup\u2082", "code": "theorem le_iSup\u2082 {f : \u2200 i, \u03ba i \u2192 \u03b1} (i : \u03b9) (j : \u03ba i) : f i j \u2264 \u2a06 (i) (j), f i j", "start": [857, 1], "end": [858, 37], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_le", "code": "theorem iInf\u2082_le {f : \u2200 i, \u03ba i \u2192 \u03b1} (i : \u03b9) (j : \u03ba i) : \u2a05 (i) (j), f i j \u2264 f i j", "start": [861, 1], "end": [862, 37], "kind": "commanddeclaration"}, {"full_name": "le_iSup\u2082_of_le", "code": "theorem le_iSup\u2082_of_le {f : \u2200 i, \u03ba i \u2192 \u03b1} (i : \u03b9) (j : \u03ba i) (h : a \u2264 f i j) :\n    a \u2264 \u2a06 (i) (j), f i j", "start": [865, 1], "end": [867, 26], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_le_of_le", "code": "theorem iInf\u2082_le_of_le {f : \u2200 i, \u03ba i \u2192 \u03b1} (i : \u03b9) (j : \u03ba i) (h : f i j \u2264 a) :\n    \u2a05 (i) (j), f i j \u2264 a", "start": [870, 1], "end": [872, 25], "kind": "commanddeclaration"}, {"full_name": "iSup_le", "code": "theorem iSup_le (h : \u2200 i, f i \u2264 a) : iSup f \u2264 a", "start": [875, 1], "end": [876, 36], "kind": "commanddeclaration"}, {"full_name": "le_iInf", "code": "theorem le_iInf (h : \u2200 i, a \u2264 f i) : a \u2264 iInf f", "start": [879, 1], "end": [880, 36], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_le", "code": "theorem iSup\u2082_le {f : \u2200 i, \u03ba i \u2192 \u03b1} (h : \u2200 i j, f i j \u2264 a) : \u2a06 (i) (j), f i j \u2264 a", "start": [883, 1], "end": [884, 34], "kind": "commanddeclaration"}, {"full_name": "le_iInf\u2082", "code": "theorem le_iInf\u2082 {f : \u2200 i, \u03ba i \u2192 \u03b1} (h : \u2200 i j, a \u2264 f i j) : a \u2264 \u2a05 (i) (j), f i j", "start": [887, 1], "end": [888, 34], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_le_iSup", "code": "theorem iSup\u2082_le_iSup (\u03ba : \u03b9 \u2192 Sort*) (f : \u03b9 \u2192 \u03b1) : \u2a06 (i) (_ : \u03ba i), f i \u2264 \u2a06 i, f i", "start": [891, 1], "end": [892, 34], "kind": "commanddeclaration"}, {"full_name": "iInf_le_iInf\u2082", "code": "theorem iInf_le_iInf\u2082 (\u03ba : \u03b9 \u2192 Sort*) (f : \u03b9 \u2192 \u03b1) : \u2a05 i, f i \u2264 \u2a05 (i) (_ : \u03ba i), f i", "start": [895, 1], "end": [896, 34], "kind": "commanddeclaration"}, {"full_name": "iSup_mono", "code": "@[gcongr]\ntheorem iSup_mono (h : \u2200 i, f i \u2264 g i) : iSup f \u2264 iSup g", "start": [899, 1], "end": [901, 42], "kind": "commanddeclaration"}, {"full_name": "iInf_mono", "code": "@[gcongr]\ntheorem iInf_mono (h : \u2200 i, f i \u2264 g i) : iInf f \u2264 iInf g", "start": [904, 1], "end": [906, 42], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_mono", "code": "theorem iSup\u2082_mono {f g : \u2200 i, \u03ba i \u2192 \u03b1} (h : \u2200 i j, f i j \u2264 g i j) :\n    \u2a06 (i) (j), f i j \u2264 \u2a06 (i) (j), g i j", "start": [909, 1], "end": [911, 38], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_mono", "code": "theorem iInf\u2082_mono {f g : \u2200 i, \u03ba i \u2192 \u03b1} (h : \u2200 i j, f i j \u2264 g i j) :\n    \u2a05 (i) (j), f i j \u2264 \u2a05 (i) (j), g i j", "start": [914, 1], "end": [916, 38], "kind": "commanddeclaration"}, {"full_name": "iSup_mono'", "code": "theorem iSup_mono' {g : \u03b9' \u2192 \u03b1} (h : \u2200 i, \u2203 i', f i \u2264 g i') : iSup f \u2264 iSup g", "start": [919, 1], "end": [920, 51], "kind": "commanddeclaration"}, {"full_name": "iInf_mono'", "code": "theorem iInf_mono' {g : \u03b9' \u2192 \u03b1} (h : \u2200 i', \u2203 i, f i \u2264 g i') : iInf f \u2264 iInf g", "start": [923, 1], "end": [924, 53], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_mono'", "code": "theorem iSup\u2082_mono' {f : \u2200 i, \u03ba i \u2192 \u03b1} {g : \u2200 i', \u03ba' i' \u2192 \u03b1} (h : \u2200 i j, \u2203 i' j', f i j \u2264 g i' j') :\n    \u2a06 (i) (j), f i j \u2264 \u2a06 (i) (j), g i j", "start": [927, 1], "end": [931, 27], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_mono'", "code": "theorem iInf\u2082_mono' {f : \u2200 i, \u03ba i \u2192 \u03b1} {g : \u2200 i', \u03ba' i' \u2192 \u03b1} (h : \u2200 i j, \u2203 i' j', f i' j' \u2264 g i j) :\n    \u2a05 (i) (j), f i j \u2264 \u2a05 (i) (j), g i j", "start": [934, 1], "end": [938, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_const_mono", "code": "theorem iSup_const_mono (h : \u03b9 \u2192 \u03b9') : \u2a06 _ : \u03b9, a \u2264 \u2a06 _ : \u03b9', a", "start": [941, 1], "end": [942, 27], "kind": "commanddeclaration"}, {"full_name": "iInf_const_mono", "code": "theorem iInf_const_mono (h : \u03b9' \u2192 \u03b9) : \u2a05 _ : \u03b9, a \u2264 \u2a05 _ : \u03b9', a", "start": [945, 1], "end": [946, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_iInf_le_iInf_iSup", "code": "theorem iSup_iInf_le_iInf_iSup (f : \u03b9 \u2192 \u03b9' \u2192 \u03b1) : \u2a06 i, \u2a05 j, f i j \u2264 \u2a05 j, \u2a06 i, f i j", "start": [949, 1], "end": [950, 65], "kind": "commanddeclaration"}, {"full_name": "biSup_mono", "code": "theorem biSup_mono {p q : \u03b9 \u2192 Prop} (hpq : \u2200 i, p i \u2192 q i) :\n    \u2a06 (i) (_ : p i), f i \u2264 \u2a06 (i) (_ : q i), f i", "start": [953, 1], "end": [955, 45], "kind": "commanddeclaration"}, {"full_name": "biInf_mono", "code": "theorem biInf_mono {p q : \u03b9 \u2192 Prop} (hpq : \u2200 i, p i \u2192 q i) :\n    \u2a05 (i) (_ : q i), f i \u2264 \u2a05 (i) (_ : p i), f i", "start": [958, 1], "end": [960, 45], "kind": "commanddeclaration"}, {"full_name": "iSup_le_iff", "code": "@[simp]\ntheorem iSup_le_iff : iSup f \u2264 a \u2194 \u2200 i, f i \u2264 a", "start": [963, 1], "end": [965, 51], "kind": "commanddeclaration"}, {"full_name": "le_iInf_iff", "code": "@[simp]\ntheorem le_iInf_iff : a \u2264 iInf f \u2194 \u2200 i, a \u2264 f i", "start": [968, 1], "end": [970, 51], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_le_iff", "code": "theorem iSup\u2082_le_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} : \u2a06 (i) (j), f i j \u2264 a \u2194 \u2200 i j, f i j \u2264 a", "start": [973, 1], "end": [974, 24], "kind": "commanddeclaration"}, {"full_name": "le_iInf\u2082_iff", "code": "theorem le_iInf\u2082_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} : (a \u2264 \u2a05 (i) (j), f i j) \u2194 \u2200 i j, a \u2264 f i j", "start": [977, 1], "end": [978, 24], "kind": "commanddeclaration"}, {"full_name": "iSup_lt_iff", "code": "theorem iSup_lt_iff : iSup f < a \u2194 \u2203 b, b < a \u2227 \u2200 i, f i \u2264 b", "start": [981, 1], "end": [982, 79], "kind": "commanddeclaration"}, {"full_name": "lt_iInf_iff", "code": "theorem lt_iInf_iff : a < iInf f \u2194 \u2203 b, a < b \u2227 \u2200 i, b \u2264 f i", "start": [985, 1], "end": [986, 80], "kind": "commanddeclaration"}, {"full_name": "sSup_eq_iSup", "code": "theorem sSup_eq_iSup {s : Set \u03b1} : sSup s = \u2a06 a \u2208 s, a", "start": [989, 1], "end": [990, 61], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_iInf", "code": "theorem sInf_eq_iInf {s : Set \u03b1} : sInf s = \u2a05 a \u2208 s, a", "start": [993, 1], "end": [994, 24], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_map_iSup", "code": "theorem Monotone.le_map_iSup [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    \u2a06 i, f (s i) \u2264 f (iSup s)", "start": [997, 1], "end": [999, 37], "kind": "commanddeclaration"}, {"full_name": "Antitone.le_map_iInf", "code": "theorem Antitone.le_map_iInf [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    \u2a06 i, f (s i) \u2264 f (iInf s)", "start": [1002, 1], "end": [1004, 27], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_map_iSup\u2082", "code": "theorem Monotone.le_map_iSup\u2082 [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (s : \u2200 i, \u03ba i \u2192 \u03b1) :\n    \u2a06 (i) (j), f (s i j) \u2264 f (\u2a06 (i) (j), s i j)", "start": [1007, 1], "end": [1009, 41], "kind": "commanddeclaration"}, {"full_name": "Antitone.le_map_iInf\u2082", "code": "theorem Antitone.le_map_iInf\u2082 [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) (s : \u2200 i, \u03ba i \u2192 \u03b1) :\n    \u2a06 (i) (j), f (s i j) \u2264 f (\u2a05 (i) (j), s i j)", "start": [1012, 1], "end": [1014, 30], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_map_sSup", "code": "theorem Monotone.le_map_sSup [CompleteLattice \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    \u2a06 a \u2208 s, f a \u2264 f (sSup s)", "start": [1017, 1], "end": [1018, 79], "kind": "commanddeclaration"}, {"full_name": "Antitone.le_map_sInf", "code": "theorem Antitone.le_map_sInf [CompleteLattice \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    \u2a06 a \u2208 s, f a \u2264 f (sInf s)", "start": [1021, 1], "end": [1023, 27], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_iSup", "code": "theorem OrderIso.map_iSup [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) (x : \u03b9 \u2192 \u03b1) :\n    f (\u2a06 i, x i) = \u2a06 i, f (x i)", "start": [1026, 1], "end": [1029, 51], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_iInf", "code": "theorem OrderIso.map_iInf [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) (x : \u03b9 \u2192 \u03b1) :\n    f (\u2a05 i, x i) = \u2a05 i, f (x i)", "start": [1032, 1], "end": [1034, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_sSup", "code": "theorem OrderIso.map_sSup [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) (s : Set \u03b1) :\n    f (sSup s) = \u2a06 a \u2208 s, f a", "start": [1037, 1], "end": [1039, 49], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_sInf", "code": "theorem OrderIso.map_sInf [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) (s : Set \u03b1) :\n    f (sInf s) = \u2a05 a \u2208 s, f a", "start": [1042, 1], "end": [1044, 29], "kind": "commanddeclaration"}, {"full_name": "iSup_comp_le", "code": "theorem iSup_comp_le {\u03b9' : Sort*} (f : \u03b9' \u2192 \u03b1) (g : \u03b9 \u2192 \u03b9') : \u2a06 x, f (g x) \u2264 \u2a06 y, f y", "start": [1047, 1], "end": [1048, 34], "kind": "commanddeclaration"}, {"full_name": "le_iInf_comp", "code": "theorem le_iInf_comp {\u03b9' : Sort*} (f : \u03b9' \u2192 \u03b1) (g : \u03b9 \u2192 \u03b9') : \u2a05 y, f y \u2264 \u2a05 x, f (g x)", "start": [1051, 1], "end": [1052, 34], "kind": "commanddeclaration"}, {"full_name": "Monotone.iSup_comp_eq", "code": "theorem Monotone.iSup_comp_eq [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : Monotone f) {s : \u03b9 \u2192 \u03b2}\n    (hs : \u2200 x, \u2203 i, x \u2264 s i) : \u2a06 x, f (s x) = \u2a06 y, f y", "start": [1055, 1], "end": [1057, 84], "kind": "commanddeclaration"}, {"full_name": "Monotone.iInf_comp_eq", "code": "theorem Monotone.iInf_comp_eq [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : Monotone f) {s : \u03b9 \u2192 \u03b2}\n    (hs : \u2200 x, \u2203 i, s i \u2264 x) : \u2a05 x, f (s x) = \u2a05 y, f y", "start": [1060, 1], "end": [1062, 84], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iSup_le", "code": "theorem Antitone.map_iSup_le [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    f (iSup s) \u2264 \u2a05 i, f (s i)", "start": [1065, 1], "end": [1067, 37], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iInf_le", "code": "theorem Monotone.map_iInf_le [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    f (iInf s) \u2264 \u2a05 i, f (s i)", "start": [1070, 1], "end": [1072, 27], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iSup\u2082_le", "code": "theorem Antitone.map_iSup\u2082_le [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) (s : \u2200 i, \u03ba i \u2192 \u03b1) :\n    f (\u2a06 (i) (j), s i j) \u2264 \u2a05 (i) (j), f (s i j)", "start": [1075, 1], "end": [1077, 25], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iInf\u2082_le", "code": "theorem Monotone.map_iInf\u2082_le [CompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (s : \u2200 i, \u03ba i \u2192 \u03b1) :\n    f (\u2a05 (i) (j), s i j) \u2264 \u2a05 (i) (j), f (s i j)", "start": [1080, 1], "end": [1082, 25], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sSup_le", "code": "theorem Antitone.map_sSup_le [CompleteLattice \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) :\n    f (sSup s) \u2264 \u2a05 a \u2208 s, f a", "start": [1085, 1], "end": [1088, 26], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sInf_le", "code": "theorem Monotone.map_sInf_le [CompleteLattice \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    f (sInf s) \u2264 \u2a05 a \u2208 s, f a", "start": [1091, 1], "end": [1093, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_const_le", "code": "theorem iSup_const_le : \u2a06 _ : \u03b9, a \u2264 a", "start": [1096, 1], "end": [1097, 26], "kind": "commanddeclaration"}, {"full_name": "le_iInf_const", "code": "theorem le_iInf_const : a \u2264 \u2a05 _ : \u03b9, a", "start": [1100, 1], "end": [1101, 26], "kind": "commanddeclaration"}, {"full_name": "iSup_const", "code": "theorem iSup_const [Nonempty \u03b9] : \u2a06 _ : \u03b9, a = a", "start": [1105, 1], "end": [1105, 94], "kind": "commanddeclaration"}, {"full_name": "iInf_const", "code": "theorem iInf_const [Nonempty \u03b9] : \u2a05 _ : \u03b9, a = a", "start": [1108, 1], "end": [1109, 26], "kind": "commanddeclaration"}, {"full_name": "iSup_bot", "code": "@[simp]\ntheorem iSup_bot : (\u2a06 _ : \u03b9, \u22a5 : \u03b1) = \u22a5", "start": [1112, 1], "end": [1114, 27], "kind": "commanddeclaration"}, {"full_name": "iInf_top", "code": "@[simp]\ntheorem iInf_top : (\u2a05 _ : \u03b9, \u22a4 : \u03b1) = \u22a4", "start": [1117, 1], "end": [1119, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_bot", "code": "@[simp]\ntheorem iSup_eq_bot : iSup s = \u22a5 \u2194 \u2200 i, s i = \u22a5", "start": [1122, 1], "end": [1124, 37], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_top", "code": "@[simp]\ntheorem iInf_eq_top : iInf s = \u22a4 \u2194 \u2200 i, s i = \u22a4", "start": [1127, 1], "end": [1129, 37], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_eq_bot", "code": "theorem iSup\u2082_eq_bot {f : \u2200 i, \u03ba i \u2192 \u03b1} : \u2a06 (i) (j), f i j = \u22a5 \u2194 \u2200 i j, f i j = \u22a5", "start": [1132, 1], "end": [1133, 7], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_eq_top", "code": "theorem iInf\u2082_eq_top {f : \u2200 i, \u03ba i \u2192 \u03b1} : \u2a05 (i) (j), f i j = \u22a4 \u2194 \u2200 i j, f i j = \u22a4", "start": [1136, 1], "end": [1137, 7], "kind": "commanddeclaration"}, {"full_name": "iSup_pos", "code": "@[simp]\ntheorem iSup_pos {p : Prop} {f : p \u2192 \u03b1} (hp : p) : \u2a06 h : p, f h = f hp", "start": [1140, 1], "end": [1142, 54], "kind": "commanddeclaration"}, {"full_name": "iInf_pos", "code": "@[simp]\ntheorem iInf_pos {p : Prop} {f : p \u2192 \u03b1} (hp : p) : \u2a05 h : p, f h = f hp", "start": [1145, 1], "end": [1147, 54], "kind": "commanddeclaration"}, {"full_name": "iSup_neg", "code": "@[simp]\ntheorem iSup_neg {p : Prop} {f : p \u2192 \u03b1} (hp : \u00acp) : \u2a06 h : p, f h = \u22a5", "start": [1150, 1], "end": [1152, 52], "kind": "commanddeclaration"}, {"full_name": "iInf_neg", "code": "@[simp]\ntheorem iInf_neg {p : Prop} {f : p \u2192 \u03b1} (hp : \u00acp) : \u2a05 h : p, f h = \u22a4", "start": [1155, 1], "end": [1157, 53], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_of_forall_le_of_forall_lt_exists_gt", "code": "theorem iSup_eq_of_forall_le_of_forall_lt_exists_gt {f : \u03b9 \u2192 \u03b1} (h\u2081 : \u2200 i, f i \u2264 b)\n    (h\u2082 : \u2200 w, w < b \u2192 \u2203 i, w < f i) : \u2a06 i : \u03b9, f i = b", "start": [1160, 1], "end": [1167, 36], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_of_forall_ge_of_forall_gt_exists_lt", "code": "theorem iInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    (\u2200 i, b \u2264 f i) \u2192 (\u2200 w, b < w \u2192 \u2203 i, f i < w) \u2192 \u2a05 i, f i = b", "start": [1170, 1], "end": [1176, 59], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_dif", "code": "theorem iSup_eq_dif {p : Prop} [Decidable p] (a : p \u2192 \u03b1) :\n    \u2a06 h : p, a h = if h : p then a h else \u22a5", "start": [1179, 1], "end": [1180, 78], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_if", "code": "theorem iSup_eq_if {p : Prop} [Decidable p] (a : \u03b1) : \u2a06 _ : p, a = if p then a else \u22a5", "start": [1183, 1], "end": [1184, 25], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_dif", "code": "theorem iInf_eq_dif {p : Prop} [Decidable p] (a : p \u2192 \u03b1) :\n    \u2a05 h : p, a h = if h : p then a h else \u22a4", "start": [1187, 1], "end": [1189, 27], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_if", "code": "theorem iInf_eq_if {p : Prop} [Decidable p] (a : \u03b1) : \u2a05 _ : p, a = if p then a else \u22a4", "start": [1192, 1], "end": [1193, 25], "kind": "commanddeclaration"}, {"full_name": "iSup_comm", "code": "theorem iSup_comm {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} : \u2a06 (i) (j), f i j = \u2a06 (j) (i), f i j", "start": [1196, 1], "end": [1198, 54], "kind": "commanddeclaration"}, {"full_name": "iInf_comm", "code": "theorem iInf_comm {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} : \u2a05 (i) (j), f i j = \u2a05 (j) (i), f i j", "start": [1201, 1], "end": [1202, 25], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_comm", "code": "theorem iSup\u2082_comm {\u03b9\u2081 \u03b9\u2082 : Sort*} {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*}\n    (f : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 \u03b1) :\n    \u2a06 (i\u2081) (j\u2081) (i\u2082) (j\u2082), f i\u2081 j\u2081 i\u2082 j\u2082 = \u2a06 (i\u2082) (j\u2082) (i\u2081) (j\u2081), f i\u2081 j\u2081 i\u2082 j\u2082", "start": [1205, 1], "end": [1208, 51], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_comm", "code": "theorem iInf\u2082_comm {\u03b9\u2081 \u03b9\u2082 : Sort*} {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*}\n    (f : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 \u03b1) :\n    \u2a05 (i\u2081) (j\u2081) (i\u2082) (j\u2082), f i\u2081 j\u2081 i\u2082 j\u2082 = \u2a05 (i\u2082) (j\u2082) (i\u2081) (j\u2081), f i\u2081 j\u2081 i\u2082 j\u2082", "start": [1211, 1], "end": [1214, 51], "kind": "commanddeclaration"}, {"full_name": "iSup_iSup_eq_left", "code": "@[simp]\ntheorem iSup_iSup_eq_left {b : \u03b2} {f : \u2200 x : \u03b2, x = b \u2192 \u03b1} : \u2a06 x, \u2a06 h : x = b, f x h = f b rfl", "start": [1228, 1], "end": [1234, 13], "kind": "commanddeclaration"}, {"full_name": "iInf_iInf_eq_left", "code": "@[simp]\ntheorem iInf_iInf_eq_left {b : \u03b2} {f : \u2200 x : \u03b2, x = b \u2192 \u03b1} : \u2a05 x, \u2a05 h : x = b, f x h = f b rfl", "start": [1237, 1], "end": [1239, 33], "kind": "commanddeclaration"}, {"full_name": "iSup_iSup_eq_right", "code": "@[simp]\ntheorem iSup_iSup_eq_right {b : \u03b2} {f : \u2200 x : \u03b2, b = x \u2192 \u03b1} : \u2a06 x, \u2a06 h : b = x, f x h = f b rfl", "start": [1242, 1], "end": [1247, 11], "kind": "commanddeclaration"}, {"full_name": "iInf_iInf_eq_right", "code": "@[simp]\ntheorem iInf_iInf_eq_right {b : \u03b2} {f : \u2200 x : \u03b2, b = x \u2192 \u03b1} : \u2a05 x, \u2a05 h : b = x, f x h = f b rfl", "start": [1250, 1], "end": [1252, 34], "kind": "commanddeclaration"}, {"full_name": "iSup_subtype", "code": "theorem iSup_subtype {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1} : iSup f = \u2a06 (i) (h : p i), f \u27e8i, h\u27e9", "start": [1257, 1], "end": [1259, 38], "kind": "commanddeclaration"}, {"full_name": "iInf_subtype", "code": "theorem iInf_subtype : \u2200 {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1}, iInf f = \u2a05 (i) (h : p i), f \u27e8i, h\u27e9", "start": [1262, 1], "end": [1263, 24], "kind": "commanddeclaration"}, {"full_name": "iSup_subtype'", "code": "theorem iSup_subtype' {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} :\n    \u2a06 (i) (h), f i h = \u2a06 x : Subtype p, f x x.property", "start": [1266, 1], "end": [1268, 59], "kind": "commanddeclaration"}, {"full_name": "iInf_subtype'", "code": "theorem iInf_subtype' {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} :\n    \u2a05 (i) (h : p i), f i h = \u2a05 x : Subtype p, f x x.property", "start": [1271, 1], "end": [1273, 59], "kind": "commanddeclaration"}, {"full_name": "iSup_subtype''", "code": "theorem iSup_subtype'' {\u03b9} (s : Set \u03b9) (f : \u03b9 \u2192 \u03b1) : \u2a06 i : s, f i = \u2a06 (t : \u03b9) (_ : t \u2208 s), f t", "start": [1276, 1], "end": [1277, 15], "kind": "commanddeclaration"}, {"full_name": "iInf_subtype''", "code": "theorem iInf_subtype'' {\u03b9} (s : Set \u03b9) (f : \u03b9 \u2192 \u03b1) : \u2a05 i : s, f i = \u2a05 (t : \u03b9) (_ : t \u2208 s), f t", "start": [1280, 1], "end": [1281, 15], "kind": "commanddeclaration"}, {"full_name": "biSup_const", "code": "theorem biSup_const {\u03b9 : Sort _} {a : \u03b1} {s : Set \u03b9} (hs : s.Nonempty) : \u2a06 i \u2208 s, a = a", "start": [1284, 1], "end": [1286, 36], "kind": "commanddeclaration"}, {"full_name": "biInf_const", "code": "theorem biInf_const {\u03b9 : Sort _} {a : \u03b1} {s : Set \u03b9} (hs : s.Nonempty) : \u2a05 i \u2208 s, a = a", "start": [1289, 1], "end": [1290, 30], "kind": "commanddeclaration"}, {"full_name": "iSup_sup_eq", "code": "theorem iSup_sup_eq : \u2a06 x, f x \u2294 g x = (\u2a06 x, f x) \u2294 \u2a06 x, g x", "start": [1293, 1], "end": [1295, 81], "kind": "commanddeclaration"}, {"full_name": "iInf_inf_eq", "code": "theorem iInf_inf_eq : \u2a05 x, f x \u2293 g x = (\u2a05 x, f x) \u2293 \u2a05 x, g x", "start": [1298, 1], "end": [1299, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_sup", "code": "theorem iSup_sup [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} : (\u2a06 x, f x) \u2294 a = \u2a06 x, f x \u2294 a", "start": [1310, 1], "end": [1311, 31], "kind": "commanddeclaration"}, {"full_name": "iInf_inf", "code": "theorem iInf_inf [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} : (\u2a05 x, f x) \u2293 a = \u2a05 x, f x \u2293 a", "start": [1314, 1], "end": [1315, 31], "kind": "commanddeclaration"}, {"full_name": "sup_iSup", "code": "theorem sup_iSup [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} : (a \u2294 \u2a06 x, f x) = \u2a06 x, a \u2294 f x", "start": [1318, 1], "end": [1319, 31], "kind": "commanddeclaration"}, {"full_name": "inf_iInf", "code": "theorem inf_iInf [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} : (a \u2293 \u2a05 x, f x) = \u2a05 x, a \u2293 f x", "start": [1322, 1], "end": [1323, 31], "kind": "commanddeclaration"}, {"full_name": "biSup_sup", "code": "theorem biSup_sup {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} (h : \u2203 i, p i) :\n    (\u2a06 (i) (h : p i), f i h) \u2294 a = \u2a06 (i) (h : p i), f i h \u2294 a", "start": [1326, 1], "end": [1331, 46], "kind": "commanddeclaration"}, {"full_name": "sup_biSup", "code": "theorem sup_biSup {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} (h : \u2203 i, p i) :\n    (a \u2294 \u2a06 (i) (h : p i), f i h) = \u2a06 (i) (h : p i), a \u2294 f i h", "start": [1334, 1], "end": [1336, 55], "kind": "commanddeclaration"}, {"full_name": "biInf_inf", "code": "theorem biInf_inf {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} (h : \u2203 i, p i) :\n    (\u2a05 (i) (h : p i), f i h) \u2293 a = \u2a05 (i) (h : p i), f i h \u2293 a", "start": [1339, 1], "end": [1341, 29], "kind": "commanddeclaration"}, {"full_name": "inf_biInf", "code": "theorem inf_biInf {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} (h : \u2203 i, p i) :\n    (a \u2293 \u2a05 (i) (h : p i), f i h) = \u2a05 (i) (h : p i), a \u2293 f i h", "start": [1344, 1], "end": [1346, 29], "kind": "commanddeclaration"}, {"full_name": "iSup_false", "code": "theorem iSup_false {s : False \u2192 \u03b1} : iSup s = \u22a5", "start": [1352, 1], "end": [1353, 10], "kind": "commanddeclaration"}, {"full_name": "iInf_false", "code": "theorem iInf_false {s : False \u2192 \u03b1} : iInf s = \u22a4", "start": [1356, 1], "end": [1357, 10], "kind": "commanddeclaration"}, {"full_name": "iSup_true", "code": "theorem iSup_true {s : True \u2192 \u03b1} : iSup s = s trivial", "start": [1360, 1], "end": [1361, 19], "kind": "commanddeclaration"}, {"full_name": "iInf_true", "code": "theorem iInf_true {s : True \u2192 \u03b1} : iInf s = s trivial", "start": [1364, 1], "end": [1365, 19], "kind": "commanddeclaration"}, {"full_name": "iSup_exists", "code": "@[simp]\ntheorem iSup_exists {p : \u03b9 \u2192 Prop} {f : Exists p \u2192 \u03b1} : \u2a06 x, f x = \u2a06 (i) (h), f \u27e8i, h\u27e9", "start": [1368, 1], "end": [1371, 38], "kind": "commanddeclaration"}, {"full_name": "iInf_exists", "code": "@[simp]\ntheorem iInf_exists {p : \u03b9 \u2192 Prop} {f : Exists p \u2192 \u03b1} : \u2a05 x, f x = \u2a05 (i) (h), f \u27e8i, h\u27e9", "start": [1374, 1], "end": [1376, 27], "kind": "commanddeclaration"}, {"full_name": "iSup_and", "code": "theorem iSup_and {p q : Prop} {s : p \u2227 q \u2192 \u03b1} : iSup s = \u2a06 (h\u2081) (h\u2082), s \u27e8h\u2081, h\u2082\u27e9", "start": [1379, 1], "end": [1381, 38], "kind": "commanddeclaration"}, {"full_name": "iInf_and", "code": "theorem iInf_and {p q : Prop} {s : p \u2227 q \u2192 \u03b1} : iInf s = \u2a05 (h\u2081) (h\u2082), s \u27e8h\u2081, h\u2082\u27e9", "start": [1384, 1], "end": [1385, 24], "kind": "commanddeclaration"}, {"full_name": "iSup_and'", "code": "theorem iSup_and' {p q : Prop} {s : p \u2192 q \u2192 \u03b1} :\n    \u2a06 (h\u2081 : p) (h\u2082 : q), s h\u2081 h\u2082 = \u2a06 h : p \u2227 q, s h.1 h.2", "start": [1388, 1], "end": [1391, 19], "kind": "commanddeclaration"}, {"full_name": "iInf_and'", "code": "theorem iInf_and' {p q : Prop} {s : p \u2192 q \u2192 \u03b1} :\n    \u2a05 (h\u2081 : p) (h\u2082 : q), s h\u2081 h\u2082 = \u2a05 h : p \u2227 q, s h.1 h.2", "start": [1394, 1], "end": [1397, 19], "kind": "commanddeclaration"}, {"full_name": "iSup_or", "code": "theorem iSup_or {p q : Prop} {s : p \u2228 q \u2192 \u03b1} :\n    \u2a06 x, s x = (\u2a06 i, s (Or.inl i)) \u2294 \u2a06 j, s (Or.inr j)", "start": [1400, 1], "end": [1407, 51], "kind": "commanddeclaration"}, {"full_name": "iInf_or", "code": "theorem iInf_or {p q : Prop} {s : p \u2228 q \u2192 \u03b1} :\n    \u2a05 x, s x = (\u2a05 i, s (Or.inl i)) \u2293 \u2a05 j, s (Or.inr j)", "start": [1410, 1], "end": [1412, 23], "kind": "commanddeclaration"}, {"full_name": "iSup_dite", "code": "theorem iSup_dite (f : \u2200 i, p i \u2192 \u03b1) (g : \u2200 i, \u00acp i \u2192 \u03b1) :\n    \u2a06 i, (if h : p i then f i h else g i h) = (\u2a06 (i) (h : p i), f i h) \u2294 \u2a06 (i) (h : \u00acp i),\n    g i h", "start": [1419, 1], "end": [1424, 32], "kind": "commanddeclaration"}, {"full_name": "iInf_dite", "code": "theorem iInf_dite (f : \u2200 i, p i \u2192 \u03b1) (g : \u2200 i, \u00acp i \u2192 \u03b1) :\n    \u2a05 i, (if h : p i then f i h else g i h) = (\u2a05 (i) (h : p i), f i h) \u2293 \u2a05 (i) (h : \u00acp i), g i h", "start": [1427, 1], "end": [1429, 45], "kind": "commanddeclaration"}, {"full_name": "iSup_ite", "code": "theorem iSup_ite (f g : \u03b9 \u2192 \u03b1) :\n    \u2a06 i, (if p i then f i else g i) = (\u2a06 (i) (_ : p i), f i) \u2294 \u2a06 (i) (_ : \u00acp i), g i", "start": [1432, 1], "end": [1434, 18], "kind": "commanddeclaration"}, {"full_name": "iInf_ite", "code": "theorem iInf_ite (f g : \u03b9 \u2192 \u03b1) :\n    \u2a05 i, (if p i then f i else g i) = (\u2a05 (i) (_ : p i), f i) \u2293 \u2a05 (i) (_ : \u00acp i), g i", "start": [1437, 1], "end": [1439, 18], "kind": "commanddeclaration"}, {"full_name": "iSup_range", "code": "theorem iSup_range {g : \u03b2 \u2192 \u03b1} {f : \u03b9 \u2192 \u03b2} : \u2a06 b \u2208 range f, g b = \u2a06 i, g (f i)", "start": [1444, 1], "end": [1445, 37], "kind": "commanddeclaration"}, {"full_name": "iInf_range", "code": "theorem iInf_range : \u2200 {g : \u03b2 \u2192 \u03b1} {f : \u03b9 \u2192 \u03b2}, \u2a05 b \u2208 range f, g b = \u2a05 i, g (f i)", "start": [1448, 1], "end": [1449, 24], "kind": "commanddeclaration"}, {"full_name": "sSup_image", "code": "theorem sSup_image {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : sSup (f '' s) = \u2a06 a \u2208 s, f a", "start": [1452, 1], "end": [1453, 37], "kind": "commanddeclaration"}, {"full_name": "sInf_image", "code": "theorem sInf_image {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : sInf (f '' s) = \u2a05 a \u2208 s, f a", "start": [1456, 1], "end": [1457, 26], "kind": "commanddeclaration"}, {"full_name": "iSup_emptyset", "code": "theorem iSup_emptyset {f : \u03b2 \u2192 \u03b1} : \u2a06 x \u2208 (\u2205 : Set \u03b2), f x = \u22a5", "start": [1463, 1], "end": [1463, 74], "kind": "commanddeclaration"}, {"full_name": "iInf_emptyset", "code": "theorem iInf_emptyset {f : \u03b2 \u2192 \u03b1} : \u2a05 x \u2208 (\u2205 : Set \u03b2), f x = \u22a4", "start": [1466, 1], "end": [1466, 74], "kind": "commanddeclaration"}, {"full_name": "iSup_univ", "code": "theorem iSup_univ {f : \u03b2 \u2192 \u03b1} : \u2a06 x \u2208 (univ : Set \u03b2), f x = \u2a06 x, f x", "start": [1469, 1], "end": [1469, 80], "kind": "commanddeclaration"}, {"full_name": "iInf_univ", "code": "theorem iInf_univ {f : \u03b2 \u2192 \u03b1} : \u2a05 x \u2208 (univ : Set \u03b2), f x = \u2a05 x, f x", "start": [1472, 1], "end": [1472, 80], "kind": "commanddeclaration"}, {"full_name": "iSup_union", "code": "theorem iSup_union {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2} : \u2a06 x \u2208 s \u222a t, f x = (\u2a06 x \u2208 s, f x) \u2294 \u2a06 x \u2208 t, f x", "start": [1475, 1], "end": [1476, 47], "kind": "commanddeclaration"}, {"full_name": "iInf_union", "code": "theorem iInf_union {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2} : \u2a05 x \u2208 s \u222a t, f x = (\u2a05 x \u2208 s, f x) \u2293 \u2a05 x \u2208 t, f x", "start": [1479, 1], "end": [1480, 28], "kind": "commanddeclaration"}, {"full_name": "iSup_split", "code": "theorem iSup_split (f : \u03b2 \u2192 \u03b1) (p : \u03b2 \u2192 Prop) :\n    \u2a06 i, f i = (\u2a06 (i) (_ : p i), f i) \u2294 \u2a06 (i) (_ : \u00acp i), f i", "start": [1483, 1], "end": [1485, 74], "kind": "commanddeclaration"}, {"full_name": "iInf_split", "code": "theorem iInf_split :\n    \u2200 (f : \u03b2 \u2192 \u03b1) (p : \u03b2 \u2192 Prop), \u2a05 i, f i = (\u2a05 (i) (_ : p i), f i) \u2293 \u2a05 (i) (_ : \u00acp i), f i", "start": [1488, 1], "end": [1490, 22], "kind": "commanddeclaration"}, {"full_name": "iSup_split_single", "code": "theorem iSup_split_single (f : \u03b2 \u2192 \u03b1) (i\u2080 : \u03b2) : \u2a06 i, f i = f i\u2080 \u2294 \u2a06 (i) (_ : i \u2260 i\u2080), f i", "start": [1493, 1], "end": [1495, 7], "kind": "commanddeclaration"}, {"full_name": "iInf_split_single", "code": "theorem iInf_split_single (f : \u03b2 \u2192 \u03b1) (i\u2080 : \u03b2) : \u2a05 i, f i = f i\u2080 \u2293 \u2a05 (i) (_ : i \u2260 i\u2080), f i", "start": [1498, 1], "end": [1499, 33], "kind": "commanddeclaration"}, {"full_name": "iSup_le_iSup_of_subset", "code": "theorem iSup_le_iSup_of_subset {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2} : s \u2286 t \u2192 \u2a06 x \u2208 s, f x \u2264 \u2a06 x \u2208 t, f x", "start": [1502, 1], "end": [1503, 13], "kind": "commanddeclaration"}, {"full_name": "iInf_le_iInf_of_subset", "code": "theorem iInf_le_iInf_of_subset {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2} : s \u2286 t \u2192 \u2a05 x \u2208 t, f x \u2264 \u2a05 x \u2208 s, f x", "start": [1506, 1], "end": [1507, 13], "kind": "commanddeclaration"}, {"full_name": "iSup_insert", "code": "theorem iSup_insert {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} {b : \u03b2} :\n    \u2a06 x \u2208 insert b s, f x = f b \u2294 \u2a06 x \u2208 s, f x", "start": [1510, 1], "end": [1512, 81], "kind": "commanddeclaration"}, {"full_name": "iInf_insert", "code": "theorem iInf_insert {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} {b : \u03b2} :\n    \u2a05 x \u2208 insert b s, f x = f b \u2293 \u2a05 x \u2208 s, f x", "start": [1515, 1], "end": [1517, 81], "kind": "commanddeclaration"}, {"full_name": "iSup_singleton", "code": "theorem iSup_singleton {f : \u03b2 \u2192 \u03b1} {b : \u03b2} : \u2a06 x \u2208 (singleton b : Set \u03b2), f x = f b", "start": [1520, 1], "end": [1520, 95], "kind": "commanddeclaration"}, {"full_name": "iInf_singleton", "code": "theorem iInf_singleton {f : \u03b2 \u2192 \u03b1} {b : \u03b2} : \u2a05 x \u2208 (singleton b : Set \u03b2), f x = f b", "start": [1523, 1], "end": [1523, 95], "kind": "commanddeclaration"}, {"full_name": "iSup_pair", "code": "theorem iSup_pair {f : \u03b2 \u2192 \u03b1} {a b : \u03b2} : \u2a06 x \u2208 ({a, b} : Set \u03b2), f x = f a \u2294 f b", "start": [1526, 1], "end": [1527, 35], "kind": "commanddeclaration"}, {"full_name": "iInf_pair", "code": "theorem iInf_pair {f : \u03b2 \u2192 \u03b1} {a b : \u03b2} : \u2a05 x \u2208 ({a, b} : Set \u03b2), f x = f a \u2293 f b", "start": [1530, 1], "end": [1531, 35], "kind": "commanddeclaration"}, {"full_name": "iSup_image", "code": "theorem iSup_image {\u03b3} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1} {t : Set \u03b2} :\n    \u2a06 c \u2208 f '' t, g c = \u2a06 b \u2208 t, g (f b)", "start": [1534, 1], "end": [1535, 98], "kind": "commanddeclaration"}, {"full_name": "iInf_image", "code": "theorem iInf_image :\n    \u2200 {\u03b3} {f : \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b1} {t : Set \u03b2}, \u2a05 c \u2208 f '' t, g c = \u2a05 b \u2208 t, g (f b)", "start": [1538, 1], "end": [1540, 22], "kind": "commanddeclaration"}, {"full_name": "iSup_extend_bot", "code": "theorem iSup_extend_bot {e : \u03b9 \u2192 \u03b2} (he : Injective e) (f : \u03b9 \u2192 \u03b1) :\n    \u2a06 j, extend e f \u22a5 j = \u2a06 i, f i", "start": [1543, 1], "end": [1546, 93], "kind": "commanddeclaration"}, {"full_name": "iInf_extend_top", "code": "theorem iInf_extend_top {e : \u03b9 \u2192 \u03b2} (he : Injective e) (f : \u03b9 \u2192 \u03b1) :\n    \u2a05 j, extend e f \u22a4 j = iInf f", "start": [1549, 1], "end": [1551, 36], "kind": "commanddeclaration"}, {"full_name": "iSup_of_empty'", "code": "theorem iSup_of_empty' {\u03b1 \u03b9} [SupSet \u03b1] [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : iSup f = sSup (\u2205 : Set \u03b1)", "start": [1559, 1], "end": [1560, 36], "kind": "commanddeclaration"}, {"full_name": "iInf_of_empty'", "code": "theorem iInf_of_empty' {\u03b1 \u03b9} [InfSet \u03b1] [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : iInf f = sInf (\u2205 : Set \u03b1)", "start": [1563, 1], "end": [1564, 36], "kind": "commanddeclaration"}, {"full_name": "iSup_of_empty", "code": "theorem iSup_of_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : iSup f = \u22a5", "start": [1567, 1], "end": [1568, 38], "kind": "commanddeclaration"}, {"full_name": "iInf_of_empty", "code": "theorem iInf_of_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : iInf f = \u22a4", "start": [1571, 1], "end": [1572, 29], "kind": "commanddeclaration"}, {"full_name": "iSup_bool_eq", "code": "theorem iSup_bool_eq {f : Bool \u2192 \u03b1} : \u2a06 b : Bool, f b = f true \u2294 f false", "start": [1575, 1], "end": [1576, 48], "kind": "commanddeclaration"}, {"full_name": "iInf_bool_eq", "code": "theorem iInf_bool_eq {f : Bool \u2192 \u03b1} : \u2a05 b : Bool, f b = f true \u2293 f false", "start": [1579, 1], "end": [1580, 24], "kind": "commanddeclaration"}, {"full_name": "sup_eq_iSup", "code": "theorem sup_eq_iSup (x y : \u03b1) : x \u2294 y = \u2a06 b : Bool, cond b x y", "start": [1583, 1], "end": [1584, 53], "kind": "commanddeclaration"}, {"full_name": "inf_eq_iInf", "code": "theorem inf_eq_iInf (x y : \u03b1) : x \u2293 y = \u2a05 b : Bool, cond b x y", "start": [1587, 1], "end": [1588, 25], "kind": "commanddeclaration"}, {"full_name": "isGLB_biInf", "code": "theorem isGLB_biInf {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : IsGLB (f '' s) (\u2a05 x \u2208 s, f x)", "start": [1591, 1], "end": [1593, 45], "kind": "commanddeclaration"}, {"full_name": "isLUB_biSup", "code": "theorem isLUB_biSup {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} : IsLUB (f '' s) (\u2a06 x \u2208 s, f x)", "start": [1596, 1], "end": [1598, 45], "kind": "commanddeclaration"}, {"full_name": "iSup_sigma", "code": "theorem iSup_sigma {p : \u03b2 \u2192 Type*} {f : Sigma p \u2192 \u03b1} : \u2a06 x, f x = \u2a06 (i) (j), f \u27e8i, j\u27e9", "start": [1601, 1], "end": [1602, 72], "kind": "commanddeclaration"}, {"full_name": "iInf_sigma", "code": "theorem iInf_sigma {p : \u03b2 \u2192 Type*} {f : Sigma p \u2192 \u03b1} : \u2a05 x, f x = \u2a05 (i) (j), f \u27e8i, j\u27e9", "start": [1605, 1], "end": [1606, 26], "kind": "commanddeclaration"}, {"full_name": "iSup_sigma'", "code": "lemma iSup_sigma' {\u03ba : \u03b2 \u2192 Type*} (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    (\u2a06 i, \u2a06 j, f i j) = \u2a06 x : \u03a3 i, \u03ba i, f x.1 x.2 :=\n(iSup_sigma (f := \u03bb x \u21a6 f x.1 x.2)).symm", "start": [1609, 1], "end": [1611, 41], "kind": "mathlibtacticlemma"}, {"full_name": "iInf_sigma'", "code": "lemma iInf_sigma' {\u03ba : \u03b2 \u2192 Type*} (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    (\u2a05 i, \u2a05 j, f i j) = \u2a05 x : \u03a3 i, \u03ba i, f x.1 x.2 :=\n(iInf_sigma (f := \u03bb x \u21a6 f x.1 x.2)).symm", "start": [1613, 1], "end": [1615, 41], "kind": "mathlibtacticlemma"}, {"full_name": "iSup_prod", "code": "theorem iSup_prod {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} : \u2a06 x, f x = \u2a06 (i) (j), f (i, j)", "start": [1617, 1], "end": [1618, 71], "kind": "commanddeclaration"}, {"full_name": "iInf_prod", "code": "theorem iInf_prod {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} : \u2a05 x, f x = \u2a05 (i) (j), f (i, j)", "start": [1621, 1], "end": [1622, 25], "kind": "commanddeclaration"}, {"full_name": "iSup_prod'", "code": "lemma iSup_prod' (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) : (\u2a06 i, \u2a06 j, f i j) = \u2a06 x : \u03b2 \u00d7 \u03b3, f x.1 x.2 :=\n(iSup_prod (f := \u03bb x \u21a6 f x.1 x.2)).symm", "start": [1625, 1], "end": [1626, 40], "kind": "mathlibtacticlemma"}, {"full_name": "iInf_prod'", "code": "lemma iInf_prod' (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) : (\u2a05 i, \u2a05 j, f i j) = \u2a05 x : \u03b2 \u00d7 \u03b3, f x.1 x.2 :=\n(iInf_prod (f := \u03bb x \u21a6 f x.1 x.2)).symm", "start": [1628, 1], "end": [1629, 40], "kind": "mathlibtacticlemma"}, {"full_name": "biSup_prod", "code": "theorem biSup_prod {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} {s : Set \u03b2} {t : Set \u03b3} :\n    \u2a06 x \u2208 s \u00d7\u02e2 t, f x = \u2a06 (a \u2208 s) (b \u2208 t), f (a, b)", "start": [1631, 1], "end": [1634, 38], "kind": "commanddeclaration"}, {"full_name": "biInf_prod", "code": "theorem biInf_prod {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} {s : Set \u03b2} {t : Set \u03b3} :\n    \u2a05 x \u2208 s \u00d7\u02e2 t, f x = \u2a05 (a \u2208 s) (b \u2208 t), f (a, b)", "start": [1637, 1], "end": [1639, 30], "kind": "commanddeclaration"}, {"full_name": "iSup_sum", "code": "theorem iSup_sum {f : Sum \u03b2 \u03b3 \u2192 \u03b1} : \u2a06 x, f x = (\u2a06 i, f (Sum.inl i)) \u2294 \u2a06 j, f (Sum.inr j)", "start": [1642, 1], "end": [1643, 82], "kind": "commanddeclaration"}, {"full_name": "iInf_sum", "code": "theorem iInf_sum {f : Sum \u03b2 \u03b3 \u2192 \u03b1} : \u2a05 x, f x = (\u2a05 i, f (Sum.inl i)) \u2293 \u2a05 j, f (Sum.inr j)", "start": [1646, 1], "end": [1647, 24], "kind": "commanddeclaration"}, {"full_name": "iSup_option", "code": "theorem iSup_option (f : Option \u03b2 \u2192 \u03b1) : \u2a06 o, f o = f none \u2294 \u2a06 b, f (Option.some b)", "start": [1650, 1], "end": [1651, 85], "kind": "commanddeclaration"}, {"full_name": "iInf_option", "code": "theorem iInf_option (f : Option \u03b2 \u2192 \u03b1) : \u2a05 o, f o = f none \u2293 \u2a05 b, f (Option.some b)", "start": [1654, 1], "end": [1655, 25], "kind": "commanddeclaration"}, {"full_name": "iSup_option_elim", "code": "theorem iSup_option_elim (a : \u03b1) (f : \u03b2 \u2192 \u03b1) : \u2a06 o : Option \u03b2, o.elim a f = a \u2294 \u2a06 b, f b", "start": [1658, 1], "end": [1660, 21], "kind": "commanddeclaration"}, {"full_name": "iInf_option_elim", "code": "theorem iInf_option_elim (a : \u03b1) (f : \u03b2 \u2192 \u03b1) : \u2a05 o : Option \u03b2, o.elim a f = a \u2293 \u2a05 b, f b", "start": [1663, 1], "end": [1665, 32], "kind": "commanddeclaration"}, {"full_name": "iSup_ne_bot_subtype", "code": "theorem iSup_ne_bot_subtype (f : \u03b9 \u2192 \u03b1) : \u2a06 i : { i // f i \u2260 \u22a5 }, f i = \u2a06 i, f i", "start": [1668, 1], "end": [1678, 28], "kind": "commanddeclaration"}, {"full_name": "iInf_ne_top_subtype", "code": "theorem iInf_ne_top_subtype (f : \u03b9 \u2192 \u03b1) : \u2a05 i : { i // f i \u2260 \u22a4 }, f i = \u2a05 i, f i", "start": [1681, 1], "end": [1684, 33], "kind": "commanddeclaration"}, {"full_name": "sSup_image2", "code": "theorem sSup_image2 {f : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b2} {t : Set \u03b3} :\n    sSup (image2 f s t) = \u2a06 (a \u2208 s) (b \u2208 t), f a b", "start": [1687, 1], "end": [1688, 99], "kind": "commanddeclaration"}, {"full_name": "sInf_image2", "code": "theorem sInf_image2 {f : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b2} {t : Set \u03b3} :\n    sInf (image2 f s t) = \u2a05 (a \u2208 s) (b \u2208 t), f a b", "start": [1691, 1], "end": [1692, 99], "kind": "commanddeclaration"}, {"full_name": "iSup_ge_eq_iSup_nat_add", "code": "theorem iSup_ge_eq_iSup_nat_add (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a06 i \u2265 n, u i = \u2a06 i, u (i + n)", "start": [1700, 1], "end": [1705, 67], "kind": "commanddeclaration"}, {"full_name": "iInf_ge_eq_iInf_nat_add", "code": "theorem iInf_ge_eq_iInf_nat_add (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a05 i \u2265 n, u i = \u2a05 i, u (i + n)", "start": [1708, 1], "end": [1709, 37], "kind": "commanddeclaration"}, {"full_name": "Monotone.iSup_nat_add", "code": "theorem Monotone.iSup_nat_add {f : \u2115 \u2192 \u03b1} (hf : Monotone f) (k : \u2115) : \u2a06 n, f (n + k) = \u2a06 n, f n", "start": [1712, 1], "end": [1713, 100], "kind": "commanddeclaration"}, {"full_name": "Antitone.iInf_nat_add", "code": "theorem Antitone.iInf_nat_add {f : \u2115 \u2192 \u03b1} (hf : Antitone f) (k : \u2115) : \u2a05 n, f (n + k) = \u2a05 n, f n", "start": [1716, 1], "end": [1717, 31], "kind": "commanddeclaration"}, {"full_name": "iSup_iInf_ge_nat_add", "code": "theorem iSup_iInf_ge_nat_add (f : \u2115 \u2192 \u03b1) (k : \u2115) :\n    \u2a06 n, \u2a05 i \u2265 n, f (i + k) = \u2a06 n, \u2a05 i \u2265 n, f i", "start": [1726, 1], "end": [1730, 55], "kind": "commanddeclaration"}, {"full_name": "iInf_iSup_ge_nat_add", "code": "theorem iInf_iSup_ge_nat_add :\n    \u2200 (f : \u2115 \u2192 \u03b1) (k : \u2115), \u2a05 n, \u2a06 i \u2265 n, f (i + k) = \u2a05 n, \u2a06 i \u2265 n, f i", "start": [1735, 1], "end": [1737, 30], "kind": "commanddeclaration"}, {"full_name": "sup_iSup_nat_succ", "code": "theorem sup_iSup_nat_succ (u : \u2115 \u2192 \u03b1) : (u 0 \u2294 \u2a06 i, u (i + 1)) = \u2a06 i, u i", "start": [1740, 1], "end": [1744, 65], "kind": "commanddeclaration"}, {"full_name": "inf_iInf_nat_succ", "code": "theorem inf_iInf_nat_succ (u : \u2115 \u2192 \u03b1) : (u 0 \u2293 \u2a05 i, u (i + 1)) = \u2a05 i, u i", "start": [1747, 1], "end": [1748, 29], "kind": "commanddeclaration"}, {"full_name": "iInf_nat_gt_zero_eq", "code": "theorem iInf_nat_gt_zero_eq (f : \u2115 \u2192 \u03b1) : \u2a05 i > 0, f i = \u2a05 i, f (i + 1)", "start": [1751, 1], "end": [1753, 7], "kind": "commanddeclaration"}, {"full_name": "iSup_nat_gt_zero_eq", "code": "theorem iSup_nat_gt_zero_eq (f : \u2115 \u2192 \u03b1) : \u2a06 i > 0, f i = \u2a06 i, f (i + 1)", "start": [1756, 1], "end": [1757, 31], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_top", "code": "theorem iSup_eq_top (f : \u03b9 \u2192 \u03b1) : iSup f = \u22a4 \u2194 \u2200 b < \u22a4, \u2203 i, b < f i", "start": [1766, 1], "end": [1767, 62], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_bot", "code": "theorem iInf_eq_bot (f : \u03b9 \u2192 \u03b1) : iInf f = \u22a5 \u2194 \u2200 b > \u22a5, \u2203 i, f i < b", "start": [1770, 1], "end": [1771, 62], "kind": "commanddeclaration"}, {"full_name": "Prop.completeLattice", "code": "instance Prop.completeLattice : CompleteLattice Prop :=\n  { Prop.boundedOrder, Prop.distribLattice with\n    sSup := fun s => \u2203 a \u2208 s, a\n    le_sSup := fun _ a h p => \u27e8a, h, p\u27e9\n    sSup_le := fun _ _ h \u27e8b, h', p\u27e9 => h b h' p\n    sInf := fun s => \u2200 a, a \u2208 s \u2192 a\n    sInf_le := fun _ a h p => p a h\n    le_sInf := fun _ _ h p b hb => h b hb p }", "start": [1781, 1], "end": [1788, 46], "kind": "commanddeclaration"}, {"full_name": "Prop.completeLinearOrder", "code": "noncomputable instance Prop.completeLinearOrder : CompleteLinearOrder Prop :=\n  { Prop.completeLattice, Prop.linearOrder with }", "start": [1791, 1], "end": [1792, 50], "kind": "commanddeclaration"}, {"full_name": "sSup_Prop_eq", "code": "@[simp]\ntheorem sSup_Prop_eq {s : Set Prop} : sSup s = \u2203 p \u2208 s, p", "start": [1795, 1], "end": [1797, 6], "kind": "commanddeclaration"}, {"full_name": "sInf_Prop_eq", "code": "@[simp]\ntheorem sInf_Prop_eq {s : Set Prop} : sInf s = \u2200 p \u2208 s, p", "start": [1800, 1], "end": [1802, 6], "kind": "commanddeclaration"}, {"full_name": "iSup_Prop_eq", "code": "@[simp]\ntheorem iSup_Prop_eq {p : \u03b9 \u2192 Prop} : \u2a06 i, p i = \u2203 i, p i", "start": [1805, 1], "end": [1808, 24], "kind": "commanddeclaration"}, {"full_name": "iInf_Prop_eq", "code": "@[simp]\ntheorem iInf_Prop_eq {p : \u03b9 \u2192 Prop} : \u2a05 i, p i = \u2200 i, p i", "start": [1811, 1], "end": [1813, 68], "kind": "commanddeclaration"}, {"full_name": "Pi.supSet", "code": "instance Pi.supSet {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 i, SupSet (\u03b2 i)] : SupSet (\u2200 i, \u03b2 i) :=\n  \u27e8fun s i => \u2a06 f : s, (f : \u2200 i, \u03b2 i) i\u27e9", "start": [1816, 1], "end": [1817, 41], "kind": "commanddeclaration"}, {"full_name": "Pi.infSet", "code": "instance Pi.infSet {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 i, InfSet (\u03b2 i)] : InfSet (\u2200 i, \u03b2 i) :=\n  \u27e8fun s i => \u2a05 f : s, (f : \u2200 i, \u03b2 i) i\u27e9", "start": [1820, 1], "end": [1821, 41], "kind": "commanddeclaration"}, {"full_name": "Pi.completeLattice", "code": "instance Pi.completeLattice {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 i, CompleteLattice (\u03b2 i)] :\n    CompleteLattice (\u2200 i, \u03b2 i) :=\n  { Pi.boundedOrder, Pi.lattice with\n    le_sSup := fun s f hf i => le_iSup (fun f : s => (f : \u2200 i, \u03b2 i) i) \u27e8f, hf\u27e9\n    sInf_le := fun s f hf i => iInf_le (fun f : s => (f : \u2200 i, \u03b2 i) i) \u27e8f, hf\u27e9\n    sSup_le := fun _ _ hf i => iSup_le fun g => hf g g.2 i\n    le_sInf := fun _ _ hf i => le_iInf fun g => hf g g.2 i }", "start": [1824, 1], "end": [1830, 61], "kind": "commanddeclaration"}, {"full_name": "sSup_apply", "code": "theorem sSup_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 i, SupSet (\u03b2 i)] {s : Set (\u2200 a, \u03b2 a)} {a : \u03b1} :\n    (sSup s) a = \u2a06 f : s, (f : \u2200 a, \u03b2 a) a", "start": [1833, 1], "end": [1835, 6], "kind": "commanddeclaration"}, {"full_name": "sInf_apply", "code": "theorem sInf_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 i, InfSet (\u03b2 i)] {s : Set (\u2200 a, \u03b2 a)} {a : \u03b1} :\n    sInf s a = \u2a05 f : s, (f : \u2200 a, \u03b2 a) a", "start": [1838, 1], "end": [1840, 6], "kind": "commanddeclaration"}, {"full_name": "iSup_apply", "code": "@[simp]\ntheorem iSup_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b9 : Sort*} [\u2200 i, SupSet (\u03b2 i)] {f : \u03b9 \u2192 \u2200 a, \u03b2 a}\n    {a : \u03b1} : (\u2a06 i, f i) a = \u2a06 i, f i a", "start": [1843, 1], "end": [1847, 21], "kind": "commanddeclaration"}, {"full_name": "iInf_apply", "code": "@[simp]\ntheorem iInf_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b9 : Sort*} [\u2200 i, InfSet (\u03b2 i)] {f : \u03b9 \u2192 \u2200 a, \u03b2 a}\n    {a : \u03b1} : (\u2a05 i, f i) a = \u2a05 i, f i a", "start": [1850, 1], "end": [1853, 43], "kind": "commanddeclaration"}, {"full_name": "unary_relation_sSup_iff", "code": "theorem unary_relation_sSup_iff {\u03b1 : Type*} (s : Set (\u03b1 \u2192 Prop)) {a : \u03b1} :\n    sSup s a \u2194 \u2203 r : \u03b1 \u2192 Prop, r \u2208 s \u2227 r a", "start": [1856, 1], "end": [1859, 22], "kind": "commanddeclaration"}, {"full_name": "unary_relation_sInf_iff", "code": "theorem unary_relation_sInf_iff {\u03b1 : Type*} (s : Set (\u03b1 \u2192 Prop)) {a : \u03b1} :\n    sInf s a \u2194 \u2200 r : \u03b1 \u2192 Prop, r \u2208 s \u2192 r a", "start": [1862, 1], "end": [1865, 22], "kind": "commanddeclaration"}, {"full_name": "binary_relation_sSup_iff", "code": "theorem binary_relation_sSup_iff {\u03b1 \u03b2 : Type*} (s : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)) {a : \u03b1} {b : \u03b2} :\n    sSup s a b \u2194 \u2203 r : \u03b1 \u2192 \u03b2 \u2192 Prop, r \u2208 s \u2227 r a b", "start": [1868, 1], "end": [1871, 22], "kind": "commanddeclaration"}, {"full_name": "binary_relation_sInf_iff", "code": "theorem binary_relation_sInf_iff {\u03b1 \u03b2 : Type*} (s : Set (\u03b1 \u2192 \u03b2 \u2192 Prop)) {a : \u03b1} {b : \u03b2} :\n    sInf s a b \u2194 \u2200 r : \u03b1 \u2192 \u03b2 \u2192 Prop, r \u2208 s \u2192 r a b", "start": [1874, 1], "end": [1877, 22], "kind": "commanddeclaration"}, {"full_name": "monotone_sSup_of_monotone", "code": "theorem monotone_sSup_of_monotone {s : Set (\u03b1 \u2192 \u03b2)} (m_s : \u2200 f \u2208 s, Monotone f) :\n    Monotone (sSup s)", "start": [1884, 1], "end": [1885, 69], "kind": "commanddeclaration"}, {"full_name": "monotone_sInf_of_monotone", "code": "theorem monotone_sInf_of_monotone {s : Set (\u03b1 \u2192 \u03b2)} (m_s : \u2200 f \u2208 s, Monotone f) :\n    Monotone (sInf s)", "start": [1888, 1], "end": [1889, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.supSet", "code": "instance supSet [SupSet \u03b1] [SupSet \u03b2] : SupSet (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun s => (sSup (Prod.fst '' s), sSup (Prod.snd '' s))\u27e9", "start": [1898, 1], "end": [1899, 58], "kind": "commanddeclaration"}, {"full_name": "Prod.infSet", "code": "instance infSet [InfSet \u03b1] [InfSet \u03b2] : InfSet (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun s => (sInf (Prod.fst '' s), sInf (Prod.snd '' s))\u27e9", "start": [1901, 1], "end": [1902, 58], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_sInf", "code": "theorem fst_sInf [InfSet \u03b1] [InfSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sInf s).fst = sInf (Prod.fst '' s)", "start": [1906, 1], "end": [1907, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_sInf", "code": "theorem snd_sInf [InfSet \u03b1] [InfSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sInf s).snd = sInf (Prod.snd '' s)", "start": [1910, 1], "end": [1911, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_sInf", "code": "theorem swap_sInf [InfSet \u03b1] [InfSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sInf s).swap = sInf (Prod.swap '' s)", "start": [1914, 1], "end": [1916, 55], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_sSup", "code": "theorem fst_sSup [SupSet \u03b1] [SupSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sSup s).fst = sSup (Prod.fst '' s)", "start": [1919, 1], "end": [1920, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_sSup", "code": "theorem snd_sSup [SupSet \u03b1] [SupSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sSup s).snd = sSup (Prod.snd '' s)", "start": [1923, 1], "end": [1924, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_sSup", "code": "theorem swap_sSup [SupSet \u03b1] [SupSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sSup s).swap = sSup (Prod.swap '' s)", "start": [1927, 1], "end": [1929, 55], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_iInf", "code": "theorem fst_iInf [InfSet \u03b1] [InfSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iInf f).fst = \u2a05 i, (f i).fst", "start": [1932, 1], "end": [1933, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_iInf", "code": "theorem snd_iInf [InfSet \u03b1] [InfSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iInf f).snd = \u2a05 i, (f i).snd", "start": [1936, 1], "end": [1937, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_iInf", "code": "theorem swap_iInf [InfSet \u03b1] [InfSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iInf f).swap = \u2a05 i, (f i).swap", "start": [1940, 1], "end": [1941, 56], "kind": "commanddeclaration"}, {"full_name": "Prod.iInf_mk", "code": "theorem iInf_mk [InfSet \u03b1] [InfSet \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) :\n    \u2a05 i, (f i, g i) = (\u2a05 i, f i, \u2a05 i, g i)", "start": [1944, 1], "end": [1946, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_iSup", "code": "theorem fst_iSup [SupSet \u03b1] [SupSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iSup f).fst = \u2a06 i, (f i).fst", "start": [1949, 1], "end": [1950, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_iSup", "code": "theorem snd_iSup [SupSet \u03b1] [SupSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iSup f).snd = \u2a06 i, (f i).snd", "start": [1953, 1], "end": [1954, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_iSup", "code": "theorem swap_iSup [SupSet \u03b1] [SupSet \u03b2] (f : \u03b9 \u2192 \u03b1 \u00d7 \u03b2) : (iSup f).swap = \u2a06 i, (f i).swap", "start": [1957, 1], "end": [1958, 56], "kind": "commanddeclaration"}, {"full_name": "Prod.iSup_mk", "code": "theorem iSup_mk [SupSet \u03b1] [SupSet \u03b2] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) :\n    \u2a06 i, (f i, g i) = (\u2a06 i, f i, \u2a06 i, g i)", "start": [1961, 1], "end": [1963, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.completeLattice", "code": "instance completeLattice [CompleteLattice \u03b1] [CompleteLattice \u03b2] : CompleteLattice (\u03b1 \u00d7 \u03b2) :=\n  { Prod.lattice \u03b1 \u03b2, Prod.boundedOrder \u03b1 \u03b2, Prod.supSet \u03b1 \u03b2, Prod.infSet \u03b1 \u03b2 with\n    le_sSup := fun _ _ hab => \u27e8le_sSup <| mem_image_of_mem _ hab, le_sSup <| mem_image_of_mem _ hab\u27e9\n    sSup_le := fun _ _ h =>\n      \u27e8sSup_le <| ball_image_of_ball fun p hp => (h p hp).1,\n        sSup_le <| ball_image_of_ball fun p hp => (h p hp).2\u27e9\n    sInf_le := fun _ _ hab => \u27e8sInf_le <| mem_image_of_mem _ hab, sInf_le <| mem_image_of_mem _ hab\u27e9\n    le_sInf := fun _ _ h =>\n      \u27e8le_sInf <| ball_image_of_ball fun p hp => (h p hp).1,\n        le_sInf <| ball_image_of_ball fun p hp => (h p hp).2\u27e9 }", "start": [1968, 1], "end": [1977, 64], "kind": "commanddeclaration"}, {"full_name": "sInf_prod", "code": "lemma sInf_prod [InfSet \u03b1] [InfSet \u03b2] {s : Set \u03b1} {t : Set \u03b2} (hs : s.Nonempty) (ht : t.Nonempty) :\n    sInf (s \u00d7\u02e2 t) = (sInf s, sInf t) :=\ncongr_arg\u2082 Prod.mk (congr_arg sInf $ fst_image_prod _ ht) (congr_arg sInf $ snd_image_prod hs _)", "start": [1981, 1], "end": [1983, 97], "kind": "mathlibtacticlemma"}, {"full_name": "sSup_prod", "code": "lemma sSup_prod [SupSet \u03b1] [SupSet \u03b2] {s : Set \u03b1} {t : Set \u03b2} (hs : s.Nonempty) (ht : t.Nonempty) :\n    sSup (s \u00d7\u02e2 t) = (sSup s, sSup t) :=\ncongr_arg\u2082 Prod.mk (congr_arg sSup $ fst_image_prod _ ht) (congr_arg sSup $ snd_image_prod hs _)", "start": [1986, 1], "end": [1988, 97], "kind": "mathlibtacticlemma"}, {"full_name": "sup_sInf_le_iInf_sup", "code": "theorem sup_sInf_le_iInf_sup : a \u2294 sInf s \u2264 \u2a05 b \u2208 s, a \u2294 b", "start": [1995, 1], "end": [1997, 52], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_le_inf_sSup", "code": "theorem iSup_inf_le_inf_sSup : \u2a06 b \u2208 s, a \u2293 b \u2264 a \u2293 sSup s", "start": [2000, 1], "end": [2002, 34], "kind": "commanddeclaration"}, {"full_name": "sInf_sup_le_iInf_sup", "code": "theorem sInf_sup_le_iInf_sup : sInf s \u2294 a \u2264 \u2a05 b \u2208 s, b \u2294 a", "start": [2005, 1], "end": [2007, 53], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_le_sSup_inf", "code": "theorem iSup_inf_le_sSup_inf : \u2a06 b \u2208 s, b \u2293 a \u2264 sSup s \u2293 a", "start": [2010, 1], "end": [2012, 34], "kind": "commanddeclaration"}, {"full_name": "le_iSup_inf_iSup", "code": "theorem le_iSup_inf_iSup (f g : \u03b9 \u2192 \u03b1) : \u2a06 i, f i \u2293 g i \u2264 (\u2a06 i, f i) \u2293 \u2a06 i, g i", "start": [2015, 1], "end": [2016, 76], "kind": "commanddeclaration"}, {"full_name": "iInf_sup_iInf_le", "code": "theorem iInf_sup_iInf_le (f g : \u03b9 \u2192 \u03b1) : (\u2a05 i, f i) \u2294 \u2a05 i, g i \u2264 \u2a05 i, f i \u2294 g i", "start": [2019, 1], "end": [2020, 32], "kind": "commanddeclaration"}, {"full_name": "disjoint_sSup_left", "code": "theorem disjoint_sSup_left {a : Set \u03b1} {b : \u03b1} (d : Disjoint (sSup a) b) {i} (hi : i \u2208 a) :\n    Disjoint i b", "start": [2023, 1], "end": [2025, 90], "kind": "commanddeclaration"}, {"full_name": "disjoint_sSup_right", "code": "theorem disjoint_sSup_right {a : Set \u03b1} {b : \u03b1} (d : Disjoint b (sSup a)) {i} (hi : i \u2208 a) :\n    Disjoint b i", "start": [2028, 1], "end": [2030, 91], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.completeLattice", "code": "@[reducible]\nprotected def Function.Injective.completeLattice [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1] [Top \u03b1]\n    [Bot \u03b1] [CompleteLattice \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a) (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) : CompleteLattice \u03b1 :=\n  { hf.lattice f map_sup map_inf with\n    le_sSup := fun _ a h => (le_iSup\u2082 a h).trans (map_sSup _).ge\n    sSup_le := fun _ _ h => (map_sSup _).trans_le <| iSup\u2082_le h\n    sInf_le := fun _ a h => (map_sInf _).trans_le <| iInf\u2082_le a h\n    le_sInf := fun _ _ h => (le_iInf\u2082 h).trans (map_sInf _).ge\n    top := \u22a4\n    le_top := fun _ => (@le_top \u03b2 _ _ _).trans map_top.ge\n    bot := \u22a5\n    bot_le := fun _ => map_bot.le.trans bot_le }", "start": [2036, 1], "end": [2052, 49], "kind": "commanddeclaration"}, {"full_name": "ULift.supSet", "code": "instance supSet [SupSet \u03b1] : SupSet (ULift.{v} \u03b1) where sSup s := ULift.up (sSup <| ULift.up \u207b\u00b9' s)", "start": [2057, 1], "end": [2057, 100], "kind": "commanddeclaration"}, {"full_name": "ULift.down_sSup", "code": "theorem down_sSup [SupSet \u03b1] (s : Set (ULift.{v} \u03b1)) : (sSup s).down = sSup (ULift.up \u207b\u00b9' s)", "start": [2059, 1], "end": [2059, 100], "kind": "commanddeclaration"}, {"full_name": "ULift.up_sSup", "code": "theorem up_sSup [SupSet \u03b1] (s : Set \u03b1) : up (sSup s) = sSup (ULift.down \u207b\u00b9' s)", "start": [2060, 1], "end": [2060, 86], "kind": "commanddeclaration"}, {"full_name": "ULift.infSet", "code": "instance infSet [InfSet \u03b1] : InfSet (ULift.{v} \u03b1) where sInf s := ULift.up (sInf <| ULift.up \u207b\u00b9' s)", "start": [2062, 1], "end": [2062, 100], "kind": "commanddeclaration"}, {"full_name": "ULift.down_sInf", "code": "theorem down_sInf [InfSet \u03b1] (s : Set (ULift.{v} \u03b1)) : (sInf s).down = sInf (ULift.up \u207b\u00b9' s)", "start": [2064, 1], "end": [2064, 100], "kind": "commanddeclaration"}, {"full_name": "ULift.up_sInf", "code": "theorem up_sInf [InfSet \u03b1] (s : Set \u03b1) : up (sInf s) = sInf (ULift.down \u207b\u00b9' s)", "start": [2065, 1], "end": [2065, 86], "kind": "commanddeclaration"}, {"full_name": "ULift.down_iSup", "code": "theorem down_iSup [SupSet \u03b1] (f : \u03b9 \u2192 ULift.{v} \u03b1) : (\u2a06 i, f i).down = \u2a06 i, (f i).down", "start": [2067, 1], "end": [2069, 34], "kind": "commanddeclaration"}, {"full_name": "ULift.up_iSup", "code": "theorem up_iSup [SupSet \u03b1] (f : \u03b9 \u2192 \u03b1) : up (\u2a06 i, f i) = \u2a06 i, up (f i)", "start": [2070, 1], "end": [2071, 43], "kind": "commanddeclaration"}, {"full_name": "ULift.down_iInf", "code": "theorem down_iInf [InfSet \u03b1] (f : \u03b9 \u2192 ULift.{v} \u03b1) : (\u2a05 i, f i).down = \u2a05 i, (f i).down", "start": [2073, 1], "end": [2075, 34], "kind": "commanddeclaration"}, {"full_name": "ULift.up_iInf", "code": "theorem up_iInf [InfSet \u03b1] (f : \u03b9 \u2192 \u03b1) : up (\u2a05 i, f i) = \u2a05 i, up (f i)", "start": [2076, 1], "end": [2077, 43], "kind": "commanddeclaration"}, {"full_name": "ULift.completeLattice", "code": "instance completeLattice [CompleteLattice \u03b1] : CompleteLattice (ULift.{v} \u03b1) :=\n  ULift.down_injective.completeLattice _ down_sup down_inf\n    (fun s => by rw [sSup_eq_iSup', down_iSup, iSup_subtype''])\n    (fun s => by rw [sInf_eq_iInf', down_iInf, iInf_subtype'']) down_top down_bot", "start": [2079, 1], "end": [2082, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Nodup.lean", "imports": ["Mathlib/Data/Multiset/Bind.lean", "Mathlib/Data/Multiset/Range.lean", "Mathlib/Data/List/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.Nodup", "code": "def Nodup (s : Multiset \u03b1) : Prop :=\n  Quot.liftOn s List.Nodup fun _ _ p => propext p.nodup_iff", "start": [24, 1], "end": [27, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_nodup", "code": "@[simp]\ntheorem coe_nodup {l : List \u03b1} : @Nodup \u03b1 l \u2194 l.Nodup", "start": [30, 1], "end": [32, 10], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_zero", "code": "@[simp]\ntheorem nodup_zero : @Nodup \u03b1 0", "start": [35, 1], "end": [37, 15], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_cons", "code": "@[simp]\ntheorem nodup_cons {a : \u03b1} {s : Multiset \u03b1} : Nodup (a ::\u2098 s) \u2194 a \u2209 s \u2227 Nodup s", "start": [40, 1], "end": [42, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.cons", "code": "theorem Nodup.cons (m : a \u2209 s) (n : Nodup s) : Nodup (a ::\u2098 s)", "start": [45, 1], "end": [46, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_singleton", "code": "@[simp]\ntheorem nodup_singleton : \u2200 a : \u03b1, Nodup ({a} : Multiset \u03b1)", "start": [49, 1], "end": [51, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.of_cons", "code": "theorem Nodup.of_cons (h : Nodup (a ::\u2098 s)) : Nodup s", "start": [54, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.not_mem", "code": "theorem Nodup.not_mem (h : Nodup (a ::\u2098 s)) : a \u2209 s", "start": [58, 1], "end": [59, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_of_le", "code": "theorem nodup_of_le {s t : Multiset \u03b1} (h : s \u2264 t) : Nodup t \u2192 Nodup s", "start": [62, 1], "end": [63, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.not_nodup_pair", "code": "theorem not_nodup_pair : \u2200 a : \u03b1, \u00acNodup (a ::\u2098 a ::\u2098 0)", "start": [66, 1], "end": [67, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_iff_le", "code": "theorem nodup_iff_le {s : Multiset \u03b1} : Nodup s \u2194 \u2200 a : \u03b1, \u00aca ::\u2098 a ::\u2098 0 \u2264 s", "start": [70, 1], "end": [72, 97], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_iff_ne_cons_cons", "code": "theorem nodup_iff_ne_cons_cons {s : Multiset \u03b1} : s.Nodup \u2194 \u2200 a t, s \u2260 a ::\u2098 a ::\u2098 t", "start": [75, 1], "end": [79, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_iff_count_le_one", "code": "theorem nodup_iff_count_le_one [DecidableEq \u03b1] {s : Multiset \u03b1} : Nodup s \u2194 \u2200 a, count a s \u2264 1", "start": [82, 1], "end": [85, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_one_of_mem", "code": "@[simp]\ntheorem count_eq_one_of_mem [DecidableEq \u03b1] {a : \u03b1} {s : Multiset \u03b1} (d : Nodup s) (h : a \u2208 s) :\n    count a s = 1", "start": [88, 1], "end": [91, 61], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_eq_of_nodup", "code": "theorem count_eq_of_nodup [DecidableEq \u03b1] {a : \u03b1} {s : Multiset \u03b1} (d : Nodup s) :\n    count a s = if a \u2208 s then 1 else 0", "start": [94, 1], "end": [98, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_iff_pairwise", "code": "theorem nodup_iff_pairwise {\u03b1} {s : Multiset \u03b1} : Nodup s \u2194 Pairwise (\u00b7 \u2260 \u00b7) s", "start": [101, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.pairwise", "code": "protected theorem Nodup.pairwise : (\u2200 a \u2208 s, \u2200 b \u2208 s, a \u2260 b \u2192 r a b) \u2192 Nodup s \u2192 Pairwise r s", "start": [105, 1], "end": [106, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pairwise.forall", "code": "theorem Pairwise.forall (H : Symmetric r) (hs : Pairwise r s) :\n    \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 r a b", "start": [109, 1], "end": [112, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_add", "code": "theorem nodup_add {s t : Multiset \u03b1} : Nodup (s + t) \u2194 Nodup s \u2227 Nodup t \u2227 Disjoint s t", "start": [115, 1], "end": [116, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_of_nodup_add", "code": "theorem disjoint_of_nodup_add {s t : Multiset \u03b1} (d : Nodup (s + t)) : Disjoint s t", "start": [119, 1], "end": [120, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.add_iff", "code": "theorem Nodup.add_iff (d\u2081 : Nodup s) (d\u2082 : Nodup t) : Nodup (s + t) \u2194 Disjoint s t", "start": [123, 1], "end": [124, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.of_map", "code": "theorem Nodup.of_map (f : \u03b1 \u2192 \u03b2) : Nodup (map f s) \u2192 Nodup s", "start": [127, 1], "end": [128, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.map_on", "code": "theorem Nodup.map_on {f : \u03b1 \u2192 \u03b2} :\n    (\u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y \u2192 x = y) \u2192 Nodup s \u2192 Nodup (map f s)", "start": [131, 1], "end": [133, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.map", "code": "theorem Nodup.map {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} (hf : Injective f) : Nodup s \u2192 Nodup (map f s)", "start": [136, 1], "end": [137, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.inj_on_of_nodup_map", "code": "theorem inj_on_of_nodup_map {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} :\n    Nodup (map f s) \u2192 \u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y \u2192 x = y", "start": [140, 1], "end": [142, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_map_iff_inj_on", "code": "theorem nodup_map_iff_inj_on {f : \u03b1 \u2192 \u03b2} {s : Multiset \u03b1} (d : Nodup s) :\n    Nodup (map f s) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y \u2192 x = y", "start": [145, 1], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.filter", "code": "theorem Nodup.filter (p : \u03b1 \u2192 Prop) [DecidablePred p] {s} : Nodup s \u2192 Nodup (filter p s)", "start": [150, 1], "end": [151, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_attach", "code": "@[simp]\ntheorem nodup_attach {s : Multiset \u03b1} : Nodup (attach s) \u2194 Nodup s", "start": [154, 1], "end": [156, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.pmap", "code": "theorem Nodup.pmap {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {s : Multiset \u03b1} {H}\n    (hf : \u2200 a ha b hb, f a ha = f b hb \u2192 a = b) : Nodup s \u2192 Nodup (pmap f s H)", "start": [159, 1], "end": [161, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodupDecidable", "code": "instance nodupDecidable [DecidableEq \u03b1] (s : Multiset \u03b1) : Decidable (Nodup s) :=\n  Quotient.recOnSubsingleton s fun l => l.nodupDecidable", "start": [164, 1], "end": [165, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.erase_eq_filter", "code": "theorem Nodup.erase_eq_filter [DecidableEq \u03b1] (a : \u03b1) {s} :\n    Nodup s \u2192 s.erase a = Multiset.filter (\u00b7 \u2260 a) s", "start": [168, 1], "end": [171, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.erase", "code": "theorem Nodup.erase [DecidableEq \u03b1] (a : \u03b1) {l} : Nodup l \u2192 Nodup (l.erase a)", "start": [174, 1], "end": [175, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.mem_erase_iff", "code": "theorem Nodup.mem_erase_iff [DecidableEq \u03b1] {a b : \u03b1} {l} (d : Nodup l) :\n    a \u2208 l.erase b \u2194 a \u2260 b \u2227 a \u2208 l", "start": [178, 1], "end": [180, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.not_mem_erase", "code": "theorem Nodup.not_mem_erase [DecidableEq \u03b1] {a : \u03b1} {s} (h : Nodup s) : a \u2209 s.erase a", "start": [183, 1], "end": [184, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.product", "code": "protected theorem Nodup.product {t : Multiset \u03b2} : Nodup s \u2192 Nodup t \u2192 Nodup (s \u00d7\u02e2 t)", "start": [187, 1], "end": [188, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.sigma", "code": "protected theorem Nodup.sigma {\u03c3 : \u03b1 \u2192 Type*} {t : \u2200 a, Multiset (\u03c3 a)} :\n    Nodup s \u2192 (\u2200 a, Nodup (t a)) \u2192 Nodup (s.sigma t)", "start": [191, 1], "end": [195, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.filterMap", "code": "protected theorem Nodup.filterMap (f : \u03b1 \u2192 Option \u03b2) (H : \u2200 a a' b, b \u2208 f a \u2192 b \u2208 f a' \u2192 a = a') :\n    Nodup s \u2192 Nodup (filterMap f s)", "start": [198, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_range", "code": "theorem nodup_range (n : \u2115) : Nodup (range n)", "start": [203, 1], "end": [204, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.inter_left", "code": "theorem Nodup.inter_left [DecidableEq \u03b1] (t) : Nodup s \u2192 Nodup (s \u2229 t)", "start": [207, 1], "end": [208, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.inter_right", "code": "theorem Nodup.inter_right [DecidableEq \u03b1] (s) : Nodup t \u2192 Nodup (s \u2229 t)", "start": [211, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_union", "code": "@[simp]\ntheorem nodup_union [DecidableEq \u03b1] {s t : Multiset \u03b1} : Nodup (s \u222a t) \u2194 Nodup s \u2227 Nodup t", "start": [215, 1], "end": [220, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_bind", "code": "@[simp]\ntheorem nodup_bind {s : Multiset \u03b1} {t : \u03b1 \u2192 Multiset \u03b2} :\n    Nodup (bind s t) \u2194 (\u2200 a \u2208 s, Nodup (t a)) \u2227 s.Pairwise fun a b => Disjoint (t a) (t b)", "start": [223, 1], "end": [230, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.ext", "code": "theorem Nodup.ext {s t : Multiset \u03b1} : Nodup s \u2192 Nodup t \u2192 (s = t \u2194 \u2200 a, a \u2208 s \u2194 a \u2208 t)", "start": [233, 1], "end": [234, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_iff_subset", "code": "theorem le_iff_subset {s t : Multiset \u03b1} : Nodup s \u2192 (s \u2264 t \u2194 s \u2286 t)", "start": [237, 1], "end": [238, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.range_le", "code": "theorem range_le {m n : \u2115} : range m \u2264 range n \u2194 m \u2264 n", "start": [241, 1], "end": [242, 53], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sub_of_nodup", "code": "theorem mem_sub_of_nodup [DecidableEq \u03b1] {a : \u03b1} {s t : Multiset \u03b1} (d : Nodup s) :\n    a \u2208 s - t \u2194 a \u2208 s \u2227 a \u2209 t", "start": [245, 1], "end": [252, 81], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_eq_map_of_bij_of_nodup", "code": "theorem map_eq_map_of_bij_of_nodup (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) {s : Multiset \u03b1} {t : Multiset \u03b2}\n    (hs : s.Nodup) (ht : t.Nodup) (i : \u2200 a \u2208 s, \u03b2) (hi : \u2200 a ha, i a ha \u2208 t)\n    (h : \u2200 a ha, f a = g (i a ha)) (i_inj : \u2200 a\u2081 a\u2082 ha\u2081 ha\u2082, i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082)\n    (i_surj : \u2200 b \u2208 t, \u2203 a ha, b = i a ha) : s.map f = t.map g", "start": [255, 1], "end": [270, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/GroupInstances.lean", "imports": ["Mathlib/Algebra/Hom/Group/Basic.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Algebra/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonoidHom.commMonoid", "code": "@[to_additive \"`(M \u2192+ N)` is an `AddCommMonoid` if `N` is commutative.\"]\ninstance MonoidHom.commMonoid [MulOneClass M] [CommMonoid N] :\n    CommMonoid (M \u2192* N) where\n  mul := (\u00b7 * \u00b7)\n  mul_assoc := by intros; ext; apply mul_assoc\n  one := 1\n  one_mul := by intros; ext; apply one_mul\n  mul_one := by intros; ext; apply mul_one\n  mul_comm := by intros; ext; apply mul_comm\n  npow n f :=\n    { toFun := fun x => f x ^ n, map_one' := by simp, map_mul' := fun x y => by simp [mul_pow] }\n  npow_zero f := by\n    ext x\n    simp\n  npow_succ n f := by\n    ext x\n    simp [pow_succ]", "start": [31, 1], "end": [48, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.commGroup", "code": "@[to_additive \"If `G` is an additive commutative group, then `M \u2192+ G` is an additive commutative\n      group too.\"]\ninstance MonoidHom.commGroup {M G} [MulOneClass M] [CommGroup G] : CommGroup (M \u2192* G) :=\n  { MonoidHom.commMonoid with\n    inv := Inv.inv,\n    div := Div.div,\n    div_eq_mul_inv := by\n      intros\n      ext\n      apply div_eq_mul_inv,\n    mul_left_inv := by intros; ext; apply mul_left_inv,\n    zpow := fun n f =>\n      { toFun := fun x => f x ^ n,\n        map_one' := by simp,\n        map_mul' := fun x y => by simp [mul_zpow] },\n    zpow_zero' := fun f => by\n      ext x\n      simp,\n    zpow_succ' := fun n f => by\n      ext x\n      simp [zpow_ofNat, pow_succ],\n    zpow_neg' := fun n f => by\n      ext x\n      simp [Nat.succ_eq_add_one, zpow_ofNat, -Int.natCast_add] }", "start": [50, 1], "end": [74, 65], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.semiring", "code": "instance AddMonoid.End.semiring [AddCommMonoid M] : Semiring (AddMonoid.End M) :=\n  { AddMonoid.End.monoid M, AddMonoidHom.addCommMonoid with\n    zero_mul := fun _ => AddMonoidHom.ext fun _ => rfl,\n    mul_zero := fun _ => AddMonoidHom.ext fun _ => AddMonoidHom.map_zero _,\n    left_distrib := fun _ _ _ => AddMonoidHom.ext fun _ => AddMonoidHom.map_add _ _ _,\n    right_distrib := fun _ _ _ => AddMonoidHom.ext fun _ => rfl,\n    natCast := fun n => n \u2022 (1 : AddMonoid.End M),\n    natCast_zero := AddMonoid.nsmul_zero _,\n    natCast_succ := fun n => (AddMonoid.nsmul_succ n 1).trans (add_comm _ _) }", "start": [79, 1], "end": [87, 79], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.natCast_apply", "code": "@[simp]\ntheorem AddMonoid.End.natCast_apply [AddCommMonoid M] (n : \u2115) (m : M) :\n    (\u2191n : AddMonoid.End M) m = n \u2022 m", "start": [89, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.int_cast_apply", "code": "@[simp]\ntheorem AddMonoid.End.int_cast_apply [AddCommGroup M] (z : \u2124) (m : M) :\n    (\u2191z : AddMonoid.End M) m = z \u2022 m", "start": [105, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext_iff\u2082", "code": "@[to_additive]\ntheorem ext_iff\u2082 {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} {f g : M \u2192* N \u2192* P} :\n    f = g \u2194 \u2200 x y, f x y = g x y", "start": [122, 1], "end": [125, 66], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.flip", "code": "@[to_additive \"`flip` arguments of `f : M \u2192+ N \u2192+ P`\"]\ndef flip {mM : MulOneClass M} {mN : MulOneClass N} {mP : CommMonoid P} (f : M \u2192* N \u2192* P) :\n    N \u2192* M \u2192* P where\n  toFun y :=\n    { toFun := fun x => f x y,\n      map_one' := by simp [f.map_one, one_apply],\n      map_mul' := fun x\u2081 x\u2082 => by simp [f.map_mul, mul_apply] }\n  map_one' := ext fun x => (f x).map_one\n  map_mul' y\u2081 y\u2082 := ext fun x => (f x).map_mul y\u2081 y\u2082", "start": [129, 1], "end": [138, 53], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.flip_apply", "code": "@[to_additive (attr := simp)]\ntheorem flip_apply {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M \u2192* N \u2192* P)\n    (x : M) (y : N) : f.flip y x = f x y", "start": [142, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_one\u2082", "code": "@[to_additive]\ntheorem map_one\u2082 {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M \u2192* N \u2192* P)\n    (n : N) : f 1 n = 1", "start": [149, 1], "end": [152, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mul\u2082", "code": "@[to_additive]\ntheorem map_mul\u2082 {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} (f : M \u2192* N \u2192* P)\n    (m\u2081 m\u2082 : M) (n : N) : f (m\u2081 * m\u2082) n = f m\u2081 n * f m\u2082 n", "start": [156, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_inv\u2082", "code": "@[to_additive]\ntheorem map_inv\u2082 {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M \u2192* N \u2192* P) (m : M)\n    (n : N) : f m\u207b\u00b9 n = (f m n)\u207b\u00b9", "start": [163, 1], "end": [166, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_div\u2082", "code": "@[to_additive]\ntheorem map_div\u2082 {_ : Group M} {_ : MulOneClass N} {_ : CommGroup P} (f : M \u2192* N \u2192* P)\n    (m\u2081 m\u2082 : M) (n : N) : f (m\u2081 / m\u2082) n = f m\u2081 n / f m\u2082 n", "start": [170, 1], "end": [173, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eval", "code": "@[to_additive (attr := simps!)\n      \"Evaluation of an `AddMonoidHom` at a point as an additive monoid homomorphism.\n      See also `AddMonoidHom.apply` for the evaluation of any function at a point.\"]\ndef eval [MulOneClass M] [CommMonoid N] : M \u2192* (M \u2192* N) \u2192* N :=\n  (MonoidHom.id (M \u2192* N)).flip", "start": [177, 1], "end": [183, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compHom'", "code": "@[to_additive (attr := simps!)\n      \"The expression `fun g m \u21a6 g (f m)` as an `AddMonoidHom`.\n      Equivalently, `(fun g \u21a6 AddMonoidHom.comp g f)` as an `AddMonoidHom`.\n\n      This also exists in a `LinearMap` version, `LinearMap.lcomp`.\"]\ndef compHom' [MulOneClass M] [MulOneClass N] [CommMonoid P] (f : M \u2192* N) : (N \u2192* P) \u2192* M \u2192* P :=\n  flip <| eval.comp f", "start": [189, 1], "end": [197, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compHom", "code": "@[to_additive (attr := simps)\n      \"Composition of additive monoid morphisms (`AddMonoidHom.comp`) as an additive\n      monoid morphism.\n\n      Note that unlike `AddMonoidHom.comp_hom'` this requires commutativity of `N`.\n\n      This also exists in a `LinearMap` version, `LinearMap.llcomp`.\"]\ndef compHom [MulOneClass M] [CommMonoid N] [CommMonoid P] :\n    (N \u2192* P) \u2192* (M \u2192* N) \u2192* M \u2192* P where\n  toFun g := { toFun := g.comp, map_one' := comp_one g, map_mul' := comp_mul g }\n  map_one' := by\n    ext1 f\n    exact one_comp f\n  map_mul' g\u2081 g\u2082 := by\n    ext1 f\n    exact mul_comp g\u2081 g\u2082 f", "start": [203, 1], "end": [221, 27], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.flipHom", "code": "@[to_additive (attr := simps)\n      \"Flipping arguments of additive monoid morphisms (`AddMonoidHom.flip`)\n      as an additive monoid morphism.\"]\ndef flipHom {_ : MulOneClass M} {_ : MulOneClass N} {_ : CommMonoid P} :\n    (M \u2192* N \u2192* P) \u2192* N \u2192* M \u2192* P where\n  toFun := MonoidHom.flip\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [227, 1], "end": [235, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compl\u2082", "code": "@[to_additive\n      \"The expression `fun m q \u21a6 f m (g q)` as an `AddMonoidHom`.\n\n      Note that the expression `fun q n \u21a6 f (g q) n` is simply `AddMonoidHom.comp`.\n\n      This also exists as a `LinearMap` version, `LinearMap.compl\u2082`\"]\ndef compl\u2082 [MulOneClass M] [MulOneClass N] [CommMonoid P] [MulOneClass Q] (f : M \u2192* N \u2192* P)\n    (g : Q \u2192* N) : M \u2192* Q \u2192* P :=\n  (compHom' g).comp f", "start": [241, 1], "end": [252, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compl\u2082_apply", "code": "@[to_additive (attr := simp)]\ntheorem compl\u2082_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [MulOneClass Q]\n    (f : M \u2192* N \u2192* P) (g : Q \u2192* N) (m : M) (q : Q) : (compl\u2082 f g) m q = f m (g q)", "start": [256, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compr\u2082", "code": "@[to_additive\n      \"The expression `fun m n \u21a6 g (f m n)` as an `AddMonoidHom`.\n\n      This also exists as a `LinearMap` version, `LinearMap.compr\u2082`\"]\ndef compr\u2082 [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q] (f : M \u2192* N \u2192* P)\n    (g : P \u2192* Q) : M \u2192* N \u2192* Q :=\n  (compHom g).comp f", "start": [263, 1], "end": [270, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compr\u2082_apply", "code": "@[to_additive (attr := simp)]\ntheorem compr\u2082_apply [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q] (f : M \u2192* N \u2192* P)\n    (g : P \u2192* Q) (m : M) (n : N) : (compr\u2082 f g) m n = g (f m n)", "start": [274, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mul", "code": "def AddMonoidHom.mul : R \u2192+ R \u2192+ R where\n  toFun := AddMonoidHom.mulLeft\n  map_zero' := AddMonoidHom.ext <| zero_mul\n  map_add' a b := AddMonoidHom.ext <| add_mul a b", "start": [296, 1], "end": [306, 50], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mul_apply", "code": "theorem AddMonoidHom.mul_apply (x y : R) : AddMonoidHom.mul x y = x * y", "start": [309, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_mul", "code": "@[simp]\ntheorem AddMonoidHom.coe_mul : \u21d1(AddMonoidHom.mul : R \u2192+ R \u2192+ R) = AddMonoidHom.mulLeft", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_flip_mul", "code": "@[simp]\ntheorem AddMonoidHom.coe_flip_mul :\n    \u21d1(AddMonoidHom.mul : R \u2192+ R \u2192+ R).flip = AddMonoidHom.mulRight", "start": [318, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.map_mul_iff", "code": "theorem AddMonoidHom.map_mul_iff (f : R \u2192+ S) :\n    (\u2200 x y, f (x * y) = f x * f y) \u2194\n      (AddMonoidHom.mul : R \u2192+ R \u2192+ R).compr\u2082 f = (AddMonoidHom.mul.comp f).compl\u2082 f", "start": [324, 1], "end": [331, 33], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.mulLeft", "code": "@[simps!]\ndef AddMonoid.End.mulLeft : R \u2192+ AddMonoid.End R :=\n  AddMonoidHom.mul", "start": [334, 1], "end": [337, 19], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.mulRight", "code": "@[simps!]\ndef AddMonoid.End.mulRight : R \u2192+ AddMonoid.End R :=\n  (AddMonoidHom.mul : R \u2192+ AddMonoid.End R).flip", "start": [341, 1], "end": [344, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/CCLemmas.lean", "imports": ["lake-packages/std/Std/Logic.lean", "Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "iff_eq_of_eq_true_left", "code": "theorem iff_eq_of_eq_true_left {a b : Prop} (h : a = True) : (a \u2194 b) = b", "start": [12, 1], "end": [13, 32], "kind": "commanddeclaration"}, {"full_name": "iff_eq_of_eq_true_right", "code": "theorem iff_eq_of_eq_true_right {a b : Prop} (h : b = True) : (a \u2194 b) = a", "start": [15, 1], "end": [16, 32], "kind": "commanddeclaration"}, {"full_name": "iff_eq_true_of_eq", "code": "theorem iff_eq_true_of_eq {a b : Prop} (h : a = b) : (a \u2194 b) = True", "start": [18, 1], "end": [19, 31], "kind": "commanddeclaration"}, {"full_name": "and_eq_of_eq_true_left", "code": "theorem and_eq_of_eq_true_left {a b : Prop} (h : a = True) : (a \u2227 b) = b", "start": [21, 1], "end": [22, 36], "kind": "commanddeclaration"}, {"full_name": "and_eq_of_eq_true_right", "code": "theorem and_eq_of_eq_true_right {a b : Prop} (h : b = True) : (a \u2227 b) = a", "start": [24, 1], "end": [25, 36], "kind": "commanddeclaration"}, {"full_name": "and_eq_of_eq_false_left", "code": "theorem and_eq_of_eq_false_left {a b : Prop} (h : a = False) : (a \u2227 b) = False", "start": [27, 1], "end": [28, 37], "kind": "commanddeclaration"}, {"full_name": "and_eq_of_eq_false_right", "code": "theorem and_eq_of_eq_false_right {a b : Prop} (h : b = False) : (a \u2227 b) = False", "start": [30, 1], "end": [31, 37], "kind": "commanddeclaration"}, {"full_name": "and_eq_of_eq", "code": "theorem and_eq_of_eq {a b : Prop} (h : a = b) : (a \u2227 b) = a", "start": [33, 1], "end": [34, 31], "kind": "commanddeclaration"}, {"full_name": "or_eq_of_eq_true_left", "code": "theorem or_eq_of_eq_true_left {a b : Prop} (h : a = True) : (a \u2228 b) = True", "start": [36, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "or_eq_of_eq_true_right", "code": "theorem or_eq_of_eq_true_right {a b : Prop} (h : b = True) : (a \u2228 b) = True", "start": [39, 1], "end": [40, 35], "kind": "commanddeclaration"}, {"full_name": "or_eq_of_eq_false_left", "code": "theorem or_eq_of_eq_false_left {a b : Prop} (h : a = False) : (a \u2228 b) = b", "start": [42, 1], "end": [43, 36], "kind": "commanddeclaration"}, {"full_name": "or_eq_of_eq_false_right", "code": "theorem or_eq_of_eq_false_right {a b : Prop} (h : b = False) : (a \u2228 b) = a", "start": [45, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "or_eq_of_eq", "code": "theorem or_eq_of_eq {a b : Prop} (h : a = b) : (a \u2228 b) = a", "start": [48, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "imp_eq_of_eq_true_left", "code": "theorem imp_eq_of_eq_true_left {a b : Prop} (h : a = True) : (a \u2192 b) = b", "start": [51, 1], "end": [52, 54], "kind": "commanddeclaration"}, {"full_name": "imp_eq_of_eq_true_right", "code": "theorem imp_eq_of_eq_true_right {a b : Prop} (h : b = True) : (a \u2192 b) = True", "start": [54, 1], "end": [55, 52], "kind": "commanddeclaration"}, {"full_name": "imp_eq_of_eq_false_left", "code": "theorem imp_eq_of_eq_false_left {a b : Prop} (h : a = False) : (a \u2192 b) = True", "start": [57, 1], "end": [58, 63], "kind": "commanddeclaration"}, {"full_name": "imp_eq_of_eq_false_right", "code": "theorem imp_eq_of_eq_false_right {a b : Prop} (h : b = False) : (a \u2192 b) = Not a", "start": [60, 1], "end": [61, 52], "kind": "commanddeclaration"}, {"full_name": "not_imp_eq_of_eq_false_right", "code": "theorem not_imp_eq_of_eq_false_right {a b : Prop} (h : b = False) : (Not a \u2192 b) = a", "start": [65, 1], "end": [67, 78], "kind": "commanddeclaration"}, {"full_name": "imp_eq_true_of_eq", "code": "theorem imp_eq_true_of_eq {a b : Prop} (h : a = b) : (a \u2192 b) = True", "start": [69, 1], "end": [70, 47], "kind": "commanddeclaration"}, {"full_name": "not_eq_of_eq_true", "code": "theorem not_eq_of_eq_true {a : Prop} (h : a = True) : Not a = False", "start": [72, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "not_eq_of_eq_false", "code": "theorem not_eq_of_eq_false {a : Prop} (h : a = False) : Not a = True", "start": [75, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "false_of_a_eq_not_a", "code": "theorem false_of_a_eq_not_a {a : Prop} (h : a = Not a) : False", "start": [78, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "if_eq_of_eq_true", "code": "theorem if_eq_of_eq_true {c : Prop} [d : Decidable c] {\u03b1 : Sort u} (t e : \u03b1) (h : c = True) :\n    @ite \u03b1 c d t e = t", "start": [84, 1], "end": [86, 24], "kind": "commanddeclaration"}, {"full_name": "if_eq_of_eq_false", "code": "theorem if_eq_of_eq_false {c : Prop} [d : Decidable c] {\u03b1 : Sort u} (t e : \u03b1) (h : c = False) :\n    @ite \u03b1 c d t e = e", "start": [88, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "if_eq_of_eq", "code": "theorem if_eq_of_eq (c : Prop) [d : Decidable c] {\u03b1 : Sort u} {t e : \u03b1} (h : t = e) :\n    @ite \u03b1 c d t e = t", "start": [92, 1], "end": [96, 27], "kind": "commanddeclaration"}, {"full_name": "eq_true_of_and_eq_true_left", "code": "theorem eq_true_of_and_eq_true_left {a b : Prop} (h : (a \u2227 b) = True) : a = True", "start": [98, 1], "end": [99, 36], "kind": "commanddeclaration"}, {"full_name": "eq_true_of_and_eq_true_right", "code": "theorem eq_true_of_and_eq_true_right {a b : Prop} (h : (a \u2227 b) = True) : b = True", "start": [101, 1], "end": [102, 37], "kind": "commanddeclaration"}, {"full_name": "eq_false_of_or_eq_false_left", "code": "theorem eq_false_of_or_eq_false_left {a b : Prop} (h : (a \u2228 b) = False) : a = False", "start": [104, 1], "end": [105, 53], "kind": "commanddeclaration"}, {"full_name": "eq_false_of_or_eq_false_right", "code": "theorem eq_false_of_or_eq_false_right {a b : Prop} (h : (a \u2228 b) = False) : b = False", "start": [107, 1], "end": [108, 53], "kind": "commanddeclaration"}, {"full_name": "eq_false_of_not_eq_true", "code": "theorem eq_false_of_not_eq_true {a : Prop} (h : Not a = True) : a = False", "start": [110, 1], "end": [111, 49], "kind": "commanddeclaration"}, {"full_name": "eq_true_of_not_eq_false", "code": "theorem eq_true_of_not_eq_false {a : Prop} (h : Not a = False) : a = True", "start": [115, 1], "end": [116, 60], "kind": "commanddeclaration"}, {"full_name": "ne_of_eq_of_ne", "code": "theorem ne_of_eq_of_ne {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : a = b) (h\u2082 : b \u2260 c) : a \u2260 c", "start": [118, 1], "end": [119, 15], "kind": "commanddeclaration"}, {"full_name": "Eq.trans_ne", "code": "alias Eq.trans_ne := ne_of_eq_of_ne", "start": [121, 1], "end": [121, 36], "kind": "stdtacticaliasalias"}, {"full_name": "ne_of_ne_of_eq", "code": "theorem ne_of_ne_of_eq {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : a \u2260 b) (h\u2082 : b = c) : a \u2260 c", "start": [124, 1], "end": [125, 10], "kind": "commanddeclaration"}, {"full_name": "Ne.trans_eq", "code": "alias Ne.trans_eq := ne_of_ne_of_eq", "start": [127, 1], "end": [127, 36], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/Data/Nat/Cast/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "Nat.castAddMonoidHom", "code": "def castAddMonoidHom (\u03b1 : Type*) [AddMonoidWithOne \u03b1] :\n    \u2115 \u2192+ \u03b1 where\n  toFun := Nat.cast\n  map_add' := cast_add\n  map_zero' := cast_zero", "start": [33, 1], "end": [38, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_castAddMonoidHom", "code": "@[simp]\ntheorem coe_castAddMonoidHom [AddMonoidWithOne \u03b1] : (castAddMonoidHom \u03b1 : \u2115 \u2192 \u03b1) = Nat.cast", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_mul", "code": "@[simp, norm_cast]\ntheorem cast_mul [NonAssocSemiring \u03b1] (m n : \u2115) : ((m * n : \u2115) : \u03b1) = m * n", "start": [46, 1], "end": [48, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.castRingHom", "code": "def castRingHom (\u03b1 : Type*) [NonAssocSemiring \u03b1] : \u2115 \u2192+* \u03b1 :=\n  { castAddMonoidHom \u03b1 with toFun := Nat.cast, map_one' := cast_one, map_mul' := cast_mul }", "start": [51, 1], "end": [53, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_castRingHom", "code": "@[simp]\ntheorem coe_castRingHom [NonAssocSemiring \u03b1] : (castRingHom \u03b1 : \u2115 \u2192 \u03b1) = Nat.cast", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_nat_dvd", "code": "theorem coe_nat_dvd [Semiring \u03b1] {m n : \u2115} (h : m \u2223 n) : (m : \u03b1) \u2223 (n : \u03b1)", "start": [63, 1], "end": [64, 32], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.natCast", "code": "alias _root_.Dvd.dvd.natCast := coe_nat_dvd", "start": [67, 1], "end": [67, 44], "kind": "stdtacticaliasalias"}, {"full_name": "ext_nat'", "code": "theorem ext_nat' [AddMonoid A] [AddMonoidHomClass F \u2115 A] (f g : F) (h : f 1 = g 1) : f = g", "start": [75, 1], "end": [81, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.ext_nat", "code": "@[ext]\ntheorem AddMonoidHom.ext_nat [AddMonoid A] {f g : \u2115 \u2192+ A} : f 1 = g 1 \u2192 f = g", "start": [84, 1], "end": [86, 15], "kind": "commanddeclaration"}, {"full_name": "eq_natCast'", "code": "theorem eq_natCast' [AddMonoidHomClass F \u2115 A] (f : F) (h1 : f 1 = 1) : \u2200 n : \u2115, f n = n", "start": [92, 1], "end": [94, 71], "kind": "commanddeclaration"}, {"full_name": "map_natCast'", "code": "theorem map_natCast' {A} [AddMonoidWithOne A] [AddMonoidHomClass F A B] (f : F) (h : f 1 = 1) :\n    \u2200 n : \u2115, f n = n", "start": [97, 1], "end": [101, 96], "kind": "commanddeclaration"}, {"full_name": "ext_nat''", "code": "theorem ext_nat'' [MonoidWithZeroHomClass F \u2115 A] (f g : F) (h_pos : \u2200 {n : \u2115}, 0 < n \u2192 f n = g n) :\n    f = g", "start": [110, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_nat", "code": "@[ext]\ntheorem MonoidWithZeroHom.ext_nat {f g : \u2115 \u2192*\u2080 A} : (\u2200 {n : \u2115}, 0 < n \u2192 f n = g n) \u2192 f = g", "start": [119, 1], "end": [121, 16], "kind": "commanddeclaration"}, {"full_name": "eq_natCast", "code": "@[simp]\ntheorem eq_natCast [RingHomClass F \u2115 R] (f : F) : \u2200 n, f n = n", "start": [130, 1], "end": [132, 29], "kind": "commanddeclaration"}, {"full_name": "map_natCast", "code": "@[simp]\ntheorem map_natCast [RingHomClass F R S] (f : F) : \u2200 n : \u2115, f (n : R) = n", "start": [135, 1], "end": [137, 30], "kind": "commanddeclaration"}, {"full_name": "map_ofNat", "code": "@[simp]\ntheorem map_ofNat [RingHomClass F R S] (f : F) (n : \u2115) [Nat.AtLeastTwo n] :\n    (f (no_index (OfNat.ofNat n)) : S) = OfNat.ofNat n", "start": [141, 1], "end": [144, 18], "kind": "commanddeclaration"}, {"full_name": "ext_nat", "code": "theorem ext_nat [RingHomClass F \u2115 R] (f g : F) : f = g", "start": [146, 1], "end": [147, 54], "kind": "commanddeclaration"}, {"full_name": "NeZero.nat_of_neZero", "code": "theorem NeZero.nat_of_neZero {R S} [Semiring R] [Semiring S] {F} [RingHomClass F R S] (f : F)\n    {n : \u2115} [hn : NeZero (n : S)] : NeZero (n : R)", "start": [150, 1], "end": [152, 62], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_natCast'", "code": "theorem eq_natCast' {R} [NonAssocSemiring R] (f : \u2115 \u2192+* R) : f = Nat.castRingHom R", "start": [159, 1], "end": [161, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_id", "code": "@[simp, norm_cast]\ntheorem Nat.cast_id (n : \u2115) : n.cast = n", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.castRingHom_nat", "code": "@[simp]\ntheorem Nat.castRingHom_nat : Nat.castRingHom \u2115 = RingHom.id \u2115", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.uniqueRingHom", "code": "instance Nat.uniqueRingHom {R : Type*} [NonAssocSemiring R] : Unique (\u2115 \u2192+* R) where\n  default := Nat.castRingHom R\n  uniq := RingHom.eq_natCast'", "start": [176, 1], "end": [180, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.natCast", "code": "instance natCast : NatCast (\u2200 a, \u03c0 a) := { natCast := fun n _ \u21a6 n }", "start": [188, 1], "end": [188, 68], "kind": "commanddeclaration"}, {"full_name": "Pi.nat_apply", "code": "theorem nat_apply (n : \u2115) (a : \u03b1) : (n : \u2200 a, \u03c0 a) a = n", "start": [190, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.coe_nat", "code": "@[simp]\ntheorem coe_nat (n : \u2115) : (n : \u2200 a, \u03c0 a) = fun _ \u21a6 \u2191n", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.ofNat_apply", "code": "@[simp]\ntheorem ofNat_apply (n : \u2115) [n.AtLeastTwo] (a : \u03b1) : (OfNat.ofNat n : \u2200 a, \u03c0 a) a = n", "start": [199, 1], "end": [200, 93], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_natCast_natCast", "code": "theorem Sum.elim_natCast_natCast {\u03b1 \u03b2 \u03b3 : Type*} [NatCast \u03b3] (n : \u2115) :\n    Sum.elim (n : \u03b1 \u2192 \u03b3) (n : \u03b2 \u2192 \u03b3) = n", "start": [204, 1], "end": [206, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/NeZero.lean", "imports": ["Mathlib/Algebra/NeZero.lean", "Mathlib/Data/Nat/Cast/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NeZero.natCast_ne", "code": "lemma natCast_ne (n : \u2115) (R) [AddMonoidWithOne R] [h : NeZero (n : R)] : (n : R) \u2260 0 := h.out", "start": [15, 1], "end": [15, 94], "kind": "mathlibtacticlemma"}, {"full_name": "NeZero.of_neZero_natCast", "code": "lemma of_neZero_natCast (R) [AddMonoidWithOne R] {n : \u2115} [h : NeZero (n : R)] : NeZero n :=\n  \u27e8by rintro rfl; exact h.out Nat.cast_zero\u27e9", "start": [18, 1], "end": [19, 45], "kind": "mathlibtacticlemma"}, {"full_name": "NeZero.pos_of_neZero_natCast", "code": "lemma pos_of_neZero_natCast (R) [AddMonoidWithOne R] {n : \u2115} [NeZero (n : R)] : 0 < n :=\n  Nat.pos_of_ne_zero (of_neZero_natCast R).out", "start": [22, 1], "end": [23, 47], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Units.lean", "imports": ["Mathlib/Algebra/Group/Units.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Units.smul_def", "code": "@[to_additive]\ntheorem smul_def [Monoid M] [SMul M \u03b1] (m : M\u02e3) (a : \u03b1) : m \u2022 a = (m : M) \u2022 a", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Units.smul_isUnit", "code": "@[simp]\ntheorem smul_isUnit [Monoid M] [SMul M \u03b1] {m : M} (hm : IsUnit m) (a : \u03b1) :\n    hm.unit \u2022 a = m \u2022 a", "start": [41, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_smul", "code": "theorem _root_.IsUnit.inv_smul [Monoid \u03b1] {a : \u03b1} (h : IsUnit a) : h.unit\u207b\u00b9 \u2022 a = 1", "start": [47, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "Units.instDistribSMulUnits", "code": "instance instDistribSMulUnits [Monoid M] [AddZeroClass \u03b1] [DistribSMul M \u03b1] :\n    DistribSMul M\u02e3 \u03b1 where smul_add m := smul_add (m : M)", "start": [66, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "Units.smulCommClass_left", "code": "instance smulCommClass_left [Monoid M] [SMul M \u03b1] [SMul N \u03b1] [SMulCommClass M N \u03b1] :\n    SMulCommClass M\u02e3 N \u03b1 where smul_comm m n := (smul_comm (m : M) n : _)", "start": [79, 1], "end": [80, 74], "kind": "commanddeclaration"}, {"full_name": "Units.smulCommClass_right", "code": "instance smulCommClass_right [Monoid N] [SMul M \u03b1] [SMul N \u03b1] [SMulCommClass M N \u03b1] :\n    SMulCommClass M N\u02e3 \u03b1 where smul_comm m n := (smul_comm m (n : N) : _)", "start": [83, 1], "end": [84, 74], "kind": "commanddeclaration"}, {"full_name": "Units.mulAction'", "code": "instance mulAction' [Group G] [Monoid M] [MulAction G M] [SMulCommClass G M M]\n    [IsScalarTower G M M] :\n    MulAction G M\u02e3 where\n  smul g m :=\n    \u27e8g \u2022 (m : M), (g\u207b\u00b9 \u2022 ((m\u207b\u00b9 : M\u02e3) : M)),\n      by rw [smul_mul_smul, Units.mul_inv, mul_right_inv, one_smul],\n      by rw [smul_mul_smul, Units.inv_mul, mul_left_inv, one_smul]\u27e9\n  one_smul m := Units.ext <| one_smul _ _\n  mul_smul g\u2081 g\u2082 m := Units.ext <| mul_smul _ _ _", "start": [93, 1], "end": [105, 50], "kind": "commanddeclaration"}, {"full_name": "Units.val_smul", "code": "@[simp]\ntheorem val_smul [Group G] [Monoid M] [MulAction G M] [SMulCommClass G M M] [IsScalarTower G M M]\n    (g : G) (m : M\u02e3) : \u2191(g \u2022 m) = g \u2022 (m : M)", "start": [108, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "Units.smul_inv", "code": "@[simp]\ntheorem smul_inv [Group G] [Monoid M] [MulAction G M] [SMulCommClass G M M] [IsScalarTower G M M]\n    (g : G) (m : M\u02e3) : (g \u2022 m)\u207b\u00b9 = g\u207b\u00b9 \u2022 m\u207b\u00b9", "start": [114, 1], "end": [118, 10], "kind": "commanddeclaration"}, {"full_name": "Units.smulCommClass'", "code": "instance smulCommClass' [Group G] [Group H] [Monoid M] [MulAction G M] [SMulCommClass G M M]\n    [MulAction H M] [SMulCommClass H M M] [IsScalarTower G M M] [IsScalarTower H M M]\n    [SMulCommClass G H M] :\n    SMulCommClass G H M\u02e3 where smul_comm g h m := Units.ext <| smul_comm g h (m : M)", "start": [121, 1], "end": [125, 85], "kind": "commanddeclaration"}, {"full_name": "Units.isScalarTower'", "code": "instance isScalarTower' [SMul G H] [Group G] [Group H] [Monoid M] [MulAction G M]\n    [SMulCommClass G M M] [MulAction H M] [SMulCommClass H M M] [IsScalarTower G M M]\n    [IsScalarTower H M M] [IsScalarTower G H M] :\n    IsScalarTower G H M\u02e3 where smul_assoc g h m := Units.ext <| smul_assoc g h (m : M)", "start": [128, 1], "end": [132, 87], "kind": "commanddeclaration"}, {"full_name": "Units.isScalarTower'_left", "code": "instance isScalarTower'_left [Group G] [Monoid M] [MulAction G M] [SMul M \u03b1] [SMul G \u03b1]\n    [SMulCommClass G M M] [IsScalarTower G M M] [IsScalarTower G M \u03b1] :\n    IsScalarTower G M\u02e3 \u03b1 where smul_assoc g m := (smul_assoc g (m : M) : _)", "start": [135, 1], "end": [138, 76], "kind": "commanddeclaration"}, {"full_name": "Units.mulDistribMulAction'", "code": "instance mulDistribMulAction' [Group G] [Monoid M] [MulDistribMulAction G M] [SMulCommClass G M M]\n    [IsScalarTower G M M] : MulDistribMulAction G M\u02e3 :=\n  { Units.mulAction' with\n    smul := (\u00b7 \u2022 \u00b7),\n    smul_one := fun _ => Units.ext <| smul_one _,\n    smul_mul := fun _ _ _ => Units.ext <| smul_mul' _ _ _ }", "start": [146, 1], "end": [152, 60], "kind": "commanddeclaration"}, {"full_name": "IsUnit.smul", "code": "theorem IsUnit.smul [Group G] [Monoid M] [MulAction G M] [SMulCommClass G M M] [IsScalarTower G M M]\n    {m : M} (g : G) (h : IsUnit m) : IsUnit (g \u2022 m)", "start": [157, 1], "end": [160, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Invertible/Defs.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Invertible", "code": "class Invertible [Mul \u03b1] [One \u03b1] (a : \u03b1) : Type u where\n  \n  invOf : \u03b1\n  \n  invOf_mul_self : invOf * a = 1\n  \n  mul_invOf_self : a * invOf = 1", "start": [85, 1], "end": [92, 33], "kind": "commanddeclaration"}, {"full_name": "invOf_mul_self'", "code": "@[simp]\ntheorem invOf_mul_self' [Mul \u03b1] [One \u03b1] (a : \u03b1) {_ : Invertible a} : \u215f a * a = 1", "start": [100, 1], "end": [102, 28], "kind": "commanddeclaration"}, {"full_name": "invOf_mul_self", "code": "theorem invOf_mul_self [Mul \u03b1] [One \u03b1] (a : \u03b1) [Invertible a] : \u215f a * a = 1", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_self'", "code": "@[simp]\ntheorem mul_invOf_self' [Mul \u03b1] [One \u03b1] (a : \u03b1) {_ : Invertible a} : a * \u215f a = 1", "start": [108, 1], "end": [110, 28], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_self", "code": "theorem mul_invOf_self [Mul \u03b1] [One \u03b1] (a : \u03b1) [Invertible a] : a * \u215f a = 1", "start": [112, 1], "end": [113, 28], "kind": "commanddeclaration"}, {"full_name": "invOf_mul_self_assoc'", "code": "@[simp]\ntheorem invOf_mul_self_assoc' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible a} : \u215f a * (a * b) = b", "start": [116, 1], "end": [118, 44], "kind": "commanddeclaration"}, {"full_name": "invOf_mul_self_assoc", "code": "theorem invOf_mul_self_assoc [Monoid \u03b1] (a b : \u03b1) [Invertible a] : \u215f a * (a * b) = b", "start": [120, 1], "end": [121, 44], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_self_assoc'", "code": "@[simp]\ntheorem mul_invOf_self_assoc' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible a} : a * (\u215f a * b) = b", "start": [124, 1], "end": [126, 44], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_self_assoc", "code": "theorem mul_invOf_self_assoc [Monoid \u03b1] (a b : \u03b1) [Invertible a] : a * (\u215f a * b) = b", "start": [128, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_mul_self_cancel'", "code": "@[simp]\ntheorem mul_invOf_mul_self_cancel' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible b} : a * \u215f b * b = a", "start": [132, 1], "end": [134, 19], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_mul_self_cancel", "code": "theorem mul_invOf_mul_self_cancel [Monoid \u03b1] (a b : \u03b1) [Invertible b] : a * \u215f b * b = a", "start": [136, 1], "end": [137, 19], "kind": "commanddeclaration"}, {"full_name": "mul_mul_invOf_self_cancel'", "code": "@[simp]\ntheorem mul_mul_invOf_self_cancel' [Monoid \u03b1] (a b : \u03b1) {_ : Invertible b} : a * b * \u215f b = a", "start": [140, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "mul_mul_invOf_self_cancel", "code": "theorem mul_mul_invOf_self_cancel [Monoid \u03b1] (a b : \u03b1) [Invertible b] : a * b * \u215f b = a", "start": [144, 1], "end": [145, 19], "kind": "commanddeclaration"}, {"full_name": "invOf_eq_right_inv", "code": "theorem invOf_eq_right_inv [Monoid \u03b1] {a b : \u03b1} [Invertible a] (hac : a * b = 1) : \u215f a = b", "start": [148, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "invOf_eq_left_inv", "code": "theorem invOf_eq_left_inv [Monoid \u03b1] {a b : \u03b1} [Invertible a] (hac : b * a = 1) : \u215f a = b", "start": [152, 1], "end": [153, 54], "kind": "commanddeclaration"}, {"full_name": "invertible_unique", "code": "theorem invertible_unique {\u03b1 : Type u} [Monoid \u03b1] (a b : \u03b1) [Invertible a] [Invertible b]\n    (h : a = b) : \u215f a = \u215f b", "start": [156, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "Invertible.subsingleton", "code": "instance Invertible.subsingleton [Monoid \u03b1] (a : \u03b1) : Subsingleton (Invertible a) :=\n  \u27e8fun \u27e8b, hba, hab\u27e9 \u27e8c, _, hac\u27e9 => by\n    congr\n    exact left_inv_eq_right_inv hba hac\u27e9", "start": [162, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "Invertible.congr", "code": "@[congr]\ntheorem Invertible.congr [Monoid \u03b1] (a b : \u03b1) [Invertible a] [Invertible b] (h : a = b) :\n    \u215fa = \u215fb", "start": [168, 1], "end": [171, 59], "kind": "commanddeclaration"}, {"full_name": "Invertible.copy'", "code": "def Invertible.copy' [MulOneClass \u03b1] {r : \u03b1} (hr : Invertible r) (s : \u03b1) (si : \u03b1) (hs : s = r)\n    (hsi : si = \u215f r) : Invertible s where\n  invOf := si\n  invOf_mul_self := by rw [hs, hsi, invOf_mul_self]\n  mul_invOf_self := by rw [hs, hsi, mul_invOf_self]", "start": [173, 1], "end": [178, 52], "kind": "commanddeclaration"}, {"full_name": "Invertible.copy", "code": "@[reducible]\ndef Invertible.copy [MulOneClass \u03b1] {r : \u03b1} (hr : Invertible r) (s : \u03b1) (hs : s = r) :\n    Invertible s :=\n  hr.copy' _ _ hs rfl", "start": [181, 1], "end": [185, 22], "kind": "commanddeclaration"}, {"full_name": "invertibleOfGroup", "code": "def invertibleOfGroup [Group \u03b1] (a : \u03b1) : Invertible a :=\n  \u27e8a\u207b\u00b9, inv_mul_self a, mul_inv_self a\u27e9", "start": [188, 1], "end": [190, 40], "kind": "commanddeclaration"}, {"full_name": "invOf_eq_group_inv", "code": "@[simp]\ntheorem invOf_eq_group_inv [Group \u03b1] (a : \u03b1) [Invertible a] : \u215f a = a\u207b\u00b9", "start": [193, 1], "end": [195, 38], "kind": "commanddeclaration"}, {"full_name": "invertibleOne", "code": "def invertibleOne [Monoid \u03b1] : Invertible (1 : \u03b1) :=\n  \u27e81, mul_one _, one_mul _\u27e9", "start": [198, 1], "end": [200, 28], "kind": "commanddeclaration"}, {"full_name": "invOf_one'", "code": "@[simp]\ntheorem invOf_one' [Monoid \u03b1] {_ : Invertible (1 : \u03b1)} : \u215f (1 : \u03b1) = 1", "start": [203, 1], "end": [205, 33], "kind": "commanddeclaration"}, {"full_name": "invOf_one", "code": "theorem invOf_one [Monoid \u03b1] [Invertible (1 : \u03b1)] : \u215f (1 : \u03b1) = 1", "start": [207, 1], "end": [208, 33], "kind": "commanddeclaration"}, {"full_name": "invertibleInvOf", "code": "instance invertibleInvOf [One \u03b1] [Mul \u03b1] {a : \u03b1} [Invertible a] : Invertible (\u215f a) :=\n  \u27e8a, mul_invOf_self a, invOf_mul_self a\u27e9", "start": [211, 1], "end": [213, 42], "kind": "commanddeclaration"}, {"full_name": "invOf_invOf", "code": "@[simp]\ntheorem invOf_invOf [Monoid \u03b1] (a : \u03b1) [Invertible a] [Invertible (\u215f a)] : \u215f (\u215f a) = a", "start": [216, 1], "end": [218, 40], "kind": "commanddeclaration"}, {"full_name": "invOf_inj", "code": "@[simp]\ntheorem invOf_inj [Monoid \u03b1] {a b : \u03b1} [Invertible a] [Invertible b] : \u215f a = \u215f b \u2194 a = b", "start": [221, 1], "end": [223, 49], "kind": "commanddeclaration"}, {"full_name": "invertibleMul", "code": "def invertibleMul [Monoid \u03b1] (a b : \u03b1) [Invertible a] [Invertible b] : Invertible (a * b) :=\n  \u27e8\u215f b * \u215f a, by simp [\u2190 mul_assoc], by simp [\u2190 mul_assoc]\u27e9", "start": [226, 1], "end": [228, 60], "kind": "commanddeclaration"}, {"full_name": "invOf_mul", "code": "@[simp]\ntheorem invOf_mul [Monoid \u03b1] (a b : \u03b1) [Invertible a] [Invertible b] [Invertible (a * b)] :\n    \u215f (a * b) = \u215f b * \u215f a", "start": [231, 1], "end": [234, 45], "kind": "commanddeclaration"}, {"full_name": "Invertible.mul", "code": "@[reducible]\ndef Invertible.mul [Monoid \u03b1] {a b : \u03b1} (_ : Invertible a) (_ : Invertible b) :\n    Invertible (a * b) :=\n  invertibleMul _ _", "start": [237, 1], "end": [241, 20], "kind": "commanddeclaration"}, {"full_name": "mul_right_inj_of_invertible", "code": "theorem mul_right_inj_of_invertible [Monoid \u03b1] (c : \u03b1) [Invertible c] :\n    a * c = b * c \u2194 a = b", "start": [244, 1], "end": [246, 68], "kind": "commanddeclaration"}, {"full_name": "mul_left_inj_of_invertible", "code": "theorem mul_left_inj_of_invertible [Monoid \u03b1] (c : \u03b1) [Invertible c] :\n    c * a = c * b \u2194 a = b", "start": [248, 1], "end": [250, 68], "kind": "commanddeclaration"}, {"full_name": "invOf_mul_eq_iff_eq_mul_left", "code": "theorem invOf_mul_eq_iff_eq_mul_left [Monoid \u03b1] [Invertible (c : \u03b1)] :\n    \u215fc * a = b \u2194 a = c * b", "start": [252, 1], "end": [254, 67], "kind": "commanddeclaration"}, {"full_name": "mul_left_eq_iff_eq_invOf_mul", "code": "theorem mul_left_eq_iff_eq_invOf_mul [Monoid \u03b1] [Invertible (c : \u03b1)] :\n    c * a = b \u2194 a = \u215fc * b", "start": [256, 1], "end": [258, 68], "kind": "commanddeclaration"}, {"full_name": "mul_invOf_eq_iff_eq_mul_right", "code": "theorem mul_invOf_eq_iff_eq_mul_right [Monoid \u03b1] [Invertible (c : \u03b1)] :\n    a * \u215fc = b \u2194 a = b * c", "start": [260, 1], "end": [262, 73], "kind": "commanddeclaration"}, {"full_name": "mul_right_eq_iff_eq_mul_invOf", "code": "theorem mul_right_eq_iff_eq_mul_invOf [Monoid \u03b1] [Invertible (c : \u03b1)] :\n    a * c = b \u2194 a = b * \u215fc", "start": [264, 1], "end": [266, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Init.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/Rat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Order/GaloisConnection.lean", "imports": ["Mathlib/Order/Bounds/Basic.lean", "Mathlib/Order/Hom/Set.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/CompleteLattice.lean", "Mathlib/Order/Synonym.lean"], "premises": [{"full_name": "GaloisConnection", "code": "def GaloisConnection [Preorder \u03b1] [Preorder \u03b2] (l : \u03b1 \u2192 \u03b2) (u : \u03b2 \u2192 \u03b1) :=\n  \u2200 a b, l a \u2264 b \u2194 a \u2264 u b", "start": [58, 1], "end": [62, 27], "kind": "commanddeclaration"}, {"full_name": "OrderIso.to_galoisConnection", "code": "theorem OrderIso.to_galoisConnection [Preorder \u03b1] [Preorder \u03b2] (oi : \u03b1 \u2243o \u03b2) :\n    GaloisConnection oi oi.symm", "start": [65, 1], "end": [67, 69], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.monotone_intro", "code": "theorem monotone_intro (hu : Monotone u) (hl : Monotone l) (hul : \u2200 a, a \u2264 u (l a))\n    (hlu : \u2200 a, l (u a) \u2264 a) : GaloisConnection l u", "start": [76, 1], "end": [78, 65], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.dual", "code": "protected theorem dual {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) :\n    GaloisConnection (OrderDual.toDual \u2218 u \u2218 OrderDual.ofDual)\n      (OrderDual.toDual \u2218 l \u2218 OrderDual.ofDual)", "start": [81, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.le_iff_le", "code": "theorem le_iff_le {a : \u03b1} {b : \u03b2} : l a \u2264 b \u2194 a \u2264 u b", "start": [87, 1], "end": [88, 9], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_le", "code": "theorem l_le {a : \u03b1} {b : \u03b2} : a \u2264 u b \u2192 l a \u2264 b", "start": [91, 1], "end": [92, 15], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.le_u", "code": "theorem le_u {a : \u03b1} {b : \u03b2} : l a \u2264 b \u2192 a \u2264 u b", "start": [95, 1], "end": [96, 14], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.le_u_l", "code": "theorem le_u_l (a) : a \u2264 u (l a)", "start": [99, 1], "end": [100, 20], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_u_le", "code": "theorem l_u_le (a) : l (u a) \u2264 a", "start": [103, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.monotone_u", "code": "theorem monotone_u : Monotone u", "start": [107, 1], "end": [107, 80], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.monotone_l", "code": "theorem monotone_l : Monotone l", "start": [110, 1], "end": [111, 26], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.upperBounds_l_image", "code": "theorem upperBounds_l_image (s : Set \u03b1) : upperBounds (l '' s) = u \u207b\u00b9' upperBounds s", "start": [114, 1], "end": [115, 49], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.lowerBounds_u_image", "code": "theorem lowerBounds_u_image (s : Set \u03b2) : lowerBounds (u '' s) = l \u207b\u00b9' lowerBounds s", "start": [118, 1], "end": [119, 32], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.bddAbove_l_image", "code": "theorem bddAbove_l_image {s : Set \u03b1} : BddAbove (l '' s) \u2194 BddAbove s", "start": [122, 1], "end": [123, 92], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.bddBelow_u_image", "code": "theorem bddBelow_u_image {s : Set \u03b2} : BddBelow (u '' s) \u2194 BddBelow s", "start": [126, 1], "end": [127, 27], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isLUB_l_image", "code": "theorem isLUB_l_image {s : Set \u03b1} {a : \u03b1} (h : IsLUB s a) : IsLUB (l '' s) (l a)", "start": [130, 1], "end": [132, 65], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isGLB_u_image", "code": "theorem isGLB_u_image {s : Set \u03b2} {b : \u03b2} (h : IsGLB s b) : IsGLB (u '' s) (u b)", "start": [135, 1], "end": [136, 26], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isLeast_l", "code": "theorem isLeast_l {a : \u03b1} : IsLeast { b | a \u2264 u b } (l a)", "start": [139, 1], "end": [140, 40], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isGreatest_u", "code": "theorem isGreatest_u {b : \u03b2} : IsGreatest { a | l a \u2264 b } (u b)", "start": [143, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isGLB_l", "code": "theorem isGLB_l {a : \u03b1} : IsGLB { b | a \u2264 u b } (l a)", "start": [147, 1], "end": [148, 21], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.isLUB_u", "code": "theorem isLUB_u {b : \u03b2} : IsLUB { a | l a \u2264 b } (u b)", "start": [151, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.le_u_l_trans", "code": "theorem le_u_l_trans {x y z : \u03b1} (hxy : x \u2264 u (l y)) (hyz : y \u2264 u (l z)) : x \u2264 u (l z)", "start": [155, 1], "end": [160, 43], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_u_le_trans", "code": "theorem l_u_le_trans {x y z : \u03b2} (hxy : l (u x) \u2264 y) (hyz : l (u y) \u2264 z) : l (u x) \u2264 z", "start": [163, 1], "end": [164, 43], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_l_u_eq_u", "code": "theorem u_l_u_eq_u (b : \u03b2) : u (l (u b)) = u b", "start": [173, 1], "end": [174, 55], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_l_u_eq_u'", "code": "theorem u_l_u_eq_u' : u \u2218 l \u2218 u = u", "start": [177, 1], "end": [178, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_unique", "code": "theorem u_unique {l' : \u03b1 \u2192 \u03b2} {u' : \u03b2 \u2192 \u03b1} (gc' : GaloisConnection l' u') (hl : \u2200 a, l a = l' a)\n    {b : \u03b2} : u b = u' b", "start": [181, 1], "end": [183, 96], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.exists_eq_u", "code": "theorem exists_eq_u (a : \u03b1) : (\u2203 b : \u03b2, a = u b) \u2194 a = u (l a)", "start": [186, 1], "end": [188, 71], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_eq", "code": "theorem u_eq {z : \u03b1} {y : \u03b2} : u y = z \u2194 \u2200 x, x \u2264 z \u2194 l x \u2264 y", "start": [191, 1], "end": [196, 83], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_u_l_eq_l", "code": "theorem l_u_l_eq_l (a : \u03b1) : l (u (l a)) = l a", "start": [205, 1], "end": [206, 55], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_u_l_eq_l'", "code": "theorem l_u_l_eq_l' : l \u2218 u \u2218 l = l", "start": [209, 1], "end": [210, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_unique", "code": "theorem l_unique {l' : \u03b1 \u2192 \u03b2} {u' : \u03b2 \u2192 \u03b1} (gc' : GaloisConnection l' u') (hu : \u2200 b, u b = u' b)\n    {a : \u03b1} : l a = l' a", "start": [213, 1], "end": [215, 96], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.exists_eq_l", "code": "theorem exists_eq_l (b : \u03b2) : (\u2203 a : \u03b1, b = l a) \u2194 b = l (u b)", "start": [218, 1], "end": [220, 71], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_eq", "code": "theorem l_eq {x : \u03b1} {z : \u03b2} : l x = z \u2194 \u2200 y, z \u2264 y \u2194 x \u2264 u y", "start": [223, 1], "end": [228, 84], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_eq_top", "code": "theorem u_eq_top {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) {x} : u x = \u22a4 \u2194 l \u22a4 \u2264 x", "start": [237, 1], "end": [238, 42], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_top", "code": "theorem u_top [OrderTop \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) : u \u22a4 = \u22a4", "start": [241, 1], "end": [242, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_eq_bot", "code": "theorem l_eq_bot {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) {x} : l x = \u22a5 \u2194 x \u2264 u \u22a5", "start": [251, 1], "end": [252, 19], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_bot", "code": "theorem l_bot [OrderBot \u03b1] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) : l \u22a5 = \u22a5", "start": [255, 1], "end": [256, 16], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_sup", "code": "theorem l_sup : l (a\u2081 \u2294 a\u2082) = l a\u2081 \u2294 l a\u2082", "start": [265, 1], "end": [266, 80], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_inf", "code": "theorem u_inf : u (b\u2081 \u2293 b\u2082) = u b\u2081 \u2293 u b\u2082", "start": [275, 1], "end": [276, 16], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_iSup", "code": "theorem l_iSup {f : \u03b9 \u2192 \u03b1} : l (iSup f) = \u2a06 i, l (f i)", "start": [285, 1], "end": [289, 77], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_iSup\u2082", "code": "theorem l_iSup\u2082 {f : \u2200 i, \u03ba i \u2192 \u03b1} : l (\u2a06 (i) (j), f i j) = \u2a06 (i) (j), l (f i j)", "start": [292, 1], "end": [293, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_iInf", "code": "theorem u_iInf {f : \u03b9 \u2192 \u03b2} : u (iInf f) = \u2a05 i, u (f i)", "start": [296, 1], "end": [297, 17], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_iInf\u2082", "code": "theorem u_iInf\u2082 {f : \u2200 i, \u03ba i \u2192 \u03b2} : u (\u2a05 (i) (j), f i j) = \u2a05 (i) (j), u (f i j)", "start": [300, 1], "end": [301, 18], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_sSup", "code": "theorem l_sSup {s : Set \u03b1} : l (sSup s) = \u2a06 a \u2208 s, l a", "start": [304, 1], "end": [304, 97], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_sInf", "code": "theorem u_sInf {s : Set \u03b2} : u (sInf s) = \u2a05 a \u2208 s, u a", "start": [307, 1], "end": [308, 17], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.lt_iff_lt", "code": "theorem lt_iff_lt {a : \u03b1} {b : \u03b2} : b < l a \u2194 u b < a", "start": [317, 1], "end": [318, 34], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.id", "code": "protected theorem id [p\u03b1 : Preorder \u03b1] : @GaloisConnection \u03b1 \u03b1 p\u03b1 p\u03b1 id id", "start": [326, 1], "end": [327, 36], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.compose", "code": "protected theorem compose [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {l1 : \u03b1 \u2192 \u03b2} {u1 : \u03b2 \u2192 \u03b1}\n    {l2 : \u03b2 \u2192 \u03b3} {u2 : \u03b3 \u2192 \u03b2} (gc1 : GaloisConnection l1 u1) (gc2 : GaloisConnection l2 u2) :\n    GaloisConnection (l2 \u2218 l1) (u1 \u2218 u2)", "start": [330, 1], "end": [332, 79], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.dfun", "code": "protected theorem dfun {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} {\u03b2 : \u03b9 \u2192 Type w} [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, Preorder (\u03b2 i)] (l : \u2200 i, \u03b1 i \u2192 \u03b2 i) (u : \u2200 i, \u03b2 i \u2192 \u03b1 i)\n    (gc : \u2200 i, GaloisConnection (l i) (u i)) :\n    GaloisConnection (fun (a : \u2200 i, \u03b1 i) i => l i (a i)) fun b i => u i (b i)", "start": [335, 1], "end": [339, 42], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.compl", "code": "protected theorem compl [BooleanAlgebra \u03b1] [BooleanAlgebra \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gc : GaloisConnection l u) :\n    GaloisConnection (compl \u2218 u \u2218 compl) (compl \u2218 l \u2218 compl)", "start": [342, 1], "end": [347, 56], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_comm_of_u_comm", "code": "theorem l_comm_of_u_comm {X : Type*} [Preorder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X \u2192 Y} {uXY : Y \u2192 X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z \u2192 W} {uZW : W \u2192 Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y \u2192 W} {uYW : W \u2192 Y} (hWY : GaloisConnection lWY uYW) {lZX : X \u2192 Z} {uXZ : Z \u2192 X}\n    (hXZ : GaloisConnection lZX uXZ) (h : \u2200 w, uXZ (uZW w) = uXY (uYW w)) {x : X} :\n    lWZ (lZX x) = lWY (lYX x)", "start": [351, 1], "end": [357, 49], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_comm_of_l_comm", "code": "theorem u_comm_of_l_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [Preorder W] {lYX : X \u2192 Y} {uXY : Y \u2192 X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z \u2192 W} {uZW : W \u2192 Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y \u2192 W} {uYW : W \u2192 Y} (hWY : GaloisConnection lWY uYW) {lZX : X \u2192 Z} {uXZ : Z \u2192 X}\n    (hXZ : GaloisConnection lZX uXZ) (h : \u2200 x, lWZ (lZX x) = lWY (lYX x)) {w : W} :\n    uXZ (uZW w) = uXY (uYW w)", "start": [360, 1], "end": [366, 49], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_comm_iff_u_comm", "code": "theorem l_comm_iff_u_comm {X : Type*} [PartialOrder X] {Y : Type*} [Preorder Y] {Z : Type*}\n    [Preorder Z] {W : Type*} [PartialOrder W] {lYX : X \u2192 Y} {uXY : Y \u2192 X}\n    (hXY : GaloisConnection lYX uXY) {lWZ : Z \u2192 W} {uZW : W \u2192 Z} (hZW : GaloisConnection lWZ uZW)\n    {lWY : Y \u2192 W} {uYW : W \u2192 Y} (hWY : GaloisConnection lWY uYW) {lZX : X \u2192 Z} {uXZ : Z \u2192 X}\n    (hXZ : GaloisConnection lZX uXZ) :\n    (\u2200 w : W, uXZ (uZW w) = uXY (uYW w)) \u2194 \u2200 x : X, lWZ (lZX x) = lWY (lYX x)", "start": [369, 1], "end": [375, 71], "kind": "commanddeclaration"}, {"full_name": "gc_sSup_Iic", "code": "theorem gc_sSup_Iic [CompleteSemilatticeSup \u03b1] :\n    GaloisConnection (sSup : Set \u03b1 \u2192 \u03b1) (Iic : \u03b1 \u2192 Set \u03b1)", "start": [382, 1], "end": [385, 24], "kind": "commanddeclaration"}, {"full_name": "gc_Ici_sInf", "code": "theorem gc_Ici_sInf [CompleteSemilatticeInf \u03b1] :\n    GaloisConnection (toDual \u2218 Ici : \u03b1 \u2192 (Set \u03b1)\u1d52\u1d48) (sInf \u2218 ofDual : (Set \u03b1)\u1d52\u1d48 \u2192 \u03b1)", "start": [387, 1], "end": [390, 29], "kind": "commanddeclaration"}, {"full_name": "sSup_image2_eq_sSup_sSup", "code": "theorem sSup_image2_eq_sSup_sSup (h\u2081 : \u2200 b, GaloisConnection (swap l b) (u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a) (u\u2082 a)) : sSup (image2 l s t) = l (sSup s) (sSup t)", "start": [395, 1], "end": [397, 58], "kind": "commanddeclaration"}, {"full_name": "sSup_image2_eq_sSup_sInf", "code": "theorem sSup_image2_eq_sSup_sInf (h\u2081 : \u2200 b, GaloisConnection (swap l b) (u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a \u2218 ofDual) (toDual \u2218 u\u2082 a)) :\n    sSup (image2 l s t) = l (sSup s) (sInf t)", "start": [400, 1], "end": [403, 58], "kind": "commanddeclaration"}, {"full_name": "sSup_image2_eq_sInf_sSup", "code": "theorem sSup_image2_eq_sInf_sSup (h\u2081 : \u2200 b, GaloisConnection (swap l b \u2218 ofDual) (toDual \u2218 u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a) (u\u2082 a)) : sSup (image2 l s t) = l (sInf s) (sSup t)", "start": [406, 1], "end": [408, 58], "kind": "commanddeclaration"}, {"full_name": "sSup_image2_eq_sInf_sInf", "code": "theorem sSup_image2_eq_sInf_sInf (h\u2081 : \u2200 b, GaloisConnection (swap l b \u2218 ofDual) (toDual \u2218 u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a \u2218 ofDual) (toDual \u2218 u\u2082 a)) :\n    sSup (image2 l s t) = l (sInf s) (sInf t)", "start": [411, 1], "end": [414, 60], "kind": "commanddeclaration"}, {"full_name": "sInf_image2_eq_sInf_sInf", "code": "theorem sInf_image2_eq_sInf_sInf (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) : sInf (image2 u s t) = u (sInf s) (sInf t)", "start": [417, 1], "end": [419, 58], "kind": "commanddeclaration"}, {"full_name": "sInf_image2_eq_sInf_sSup", "code": "theorem sInf_image2_eq_sInf_sSup (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    sInf (image2 u s t) = u (sInf s) (sSup t)", "start": [422, 1], "end": [425, 58], "kind": "commanddeclaration"}, {"full_name": "sInf_image2_eq_sSup_sInf", "code": "theorem sInf_image2_eq_sSup_sInf (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n    (h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) : sInf (image2 u s t) = u (sSup s) (sInf t)", "start": [428, 1], "end": [430, 58], "kind": "commanddeclaration"}, {"full_name": "sInf_image2_eq_sSup_sSup", "code": "theorem sInf_image2_eq_sSup_sSup (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    sInf (image2 u s t) = u (sSup s) (sSup t)", "start": [433, 1], "end": [436, 60], "kind": "commanddeclaration"}, {"full_name": "OrderIso.bddAbove_image", "code": "@[simp]\ntheorem bddAbove_image (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} : BddAbove (e '' s) \u2194 BddAbove s", "start": [445, 1], "end": [447, 41], "kind": "commanddeclaration"}, {"full_name": "OrderIso.bddBelow_image", "code": "@[simp]\ntheorem bddBelow_image (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} : BddBelow (e '' s) \u2194 BddBelow s", "start": [450, 1], "end": [452, 24], "kind": "commanddeclaration"}, {"full_name": "OrderIso.bddAbove_preimage", "code": "@[simp]\ntheorem bddAbove_preimage (e : \u03b1 \u2243o \u03b2) {s : Set \u03b2} : BddAbove (e \u207b\u00b9' s) \u2194 BddAbove s", "start": [455, 1], "end": [457, 44], "kind": "commanddeclaration"}, {"full_name": "OrderIso.bddBelow_preimage", "code": "@[simp]\ntheorem bddBelow_preimage (e : \u03b1 \u2243o \u03b2) {s : Set \u03b2} : BddBelow (e \u207b\u00b9' s) \u2194 BddBelow s", "start": [460, 1], "end": [462, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.galoisConnection_mul_div", "code": "theorem galoisConnection_mul_div {k : \u2115} (h : 0 < k) :\n    GaloisConnection (fun n => n * k) fun n => n / k", "start": [469, 1], "end": [470, 94], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion", "code": "structure GaloisInsertion {\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] (l : \u03b1 \u2192 \u03b2) (u : \u03b2 \u2192 \u03b1) where\n  \n  choice : \u2200 x : \u03b1, u (l x) \u2264 x \u2192 \u03b2\n  \n  gc : GaloisConnection l u\n  \n  le_l_u : \u2200 x, x \u2264 l (u x)\n  \n  choice_eq : \u2200 a h, choice a h = l a", "start": [476, 1], "end": [487, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.monotoneIntro", "code": "def GaloisInsertion.monotoneIntro {\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (hu : Monotone u) (hl : Monotone l) (hul : \u2200 a, a \u2264 u (l a)) (hlu : \u2200 b, l (u b) = b) :\n    GaloisInsertion l u where\n  choice x _ := l x\n  gc := GaloisConnection.monotone_intro hu hl hul fun b => le_of_eq (hlu b)\n  le_l_u b := le_of_eq <| (hlu b).symm\n  choice_eq _ _ := rfl", "start": [490, 1], "end": [497, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toGaloisInsertion", "code": "protected def OrderIso.toGaloisInsertion [Preorder \u03b1] [Preorder \u03b2] (oi : \u03b1 \u2243o \u03b2) :\n    GaloisInsertion oi oi.symm where\n  choice b _ := oi b\n  gc := oi.to_galoisConnection\n  le_l_u g := le_of_eq (oi.right_inv g).symm\n  choice_eq _ _ := rfl", "start": [500, 1], "end": [506, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.toGaloisInsertion", "code": "def GaloisConnection.toGaloisInsertion {\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2}\n    {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) (h : \u2200 b, b \u2264 l (u b)) : GaloisInsertion l u :=\n  { choice := fun x _ => l x\n    gc\n    le_l_u := h\n    choice_eq := fun _ _ => rfl }", "start": [509, 1], "end": [515, 34], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.liftOrderBot", "code": "def GaloisConnection.liftOrderBot {\u03b1 \u03b2 : Type*} [Preorder \u03b1] [OrderBot \u03b1] [PartialOrder \u03b2]\n    {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) :\n    OrderBot \u03b2 where\n  bot := l \u22a5\n  bot_le _ := gc.l_le <| bot_le", "start": [518, 1], "end": [523, 32], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_u_eq", "code": "theorem l_u_eq [Preorder \u03b1] [PartialOrder \u03b2] (gi : GaloisInsertion l u) (b : \u03b2) : l (u b) = b", "start": [530, 1], "end": [531, 42], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.leftInverse_l_u", "code": "theorem leftInverse_l_u [Preorder \u03b1] [PartialOrder \u03b2] (gi : GaloisInsertion l u) :\n    LeftInverse l u", "start": [534, 1], "end": [536, 12], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_top", "code": "theorem l_top [Preorder \u03b1] [PartialOrder \u03b2] [OrderTop \u03b1] [OrderTop \u03b2]\n    (gi : GaloisInsertion l u) : l \u22a4 = \u22a4", "start": [539, 1], "end": [541, 63], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_surjective", "code": "theorem l_surjective [Preorder \u03b1] [PartialOrder \u03b2] (gi : GaloisInsertion l u) : Surjective l", "start": [543, 1], "end": [544, 32], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.u_injective", "code": "theorem u_injective [Preorder \u03b1] [PartialOrder \u03b2] (gi : GaloisInsertion l u) : Injective u", "start": [547, 1], "end": [548, 31], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_sup_u", "code": "theorem l_sup_u [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] (gi : GaloisInsertion l u) (a b : \u03b2) :\n    l (u a \u2294 u b) = a \u2294 b", "start": [551, 1], "end": [555, 42], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_iSup_u", "code": "theorem l_iSup_u [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u) {\u03b9 : Sort x}\n    (f : \u03b9 \u2192 \u03b2) : l (\u2a06 i, u (f i)) = \u2a06 i, f i", "start": [558, 1], "end": [562, 71], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_biSup_u", "code": "theorem l_biSup_u [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u) {\u03b9 : Sort x}\n    {p : \u03b9 \u2192 Prop} (f : \u2200 (i) (_ : p i), \u03b2) : l (\u2a06 (i) (hi), u (f i hi)) = \u2a06 (i) (hi), f i hi", "start": [565, 1], "end": [567, 41], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_sSup_u_image", "code": "theorem l_sSup_u_image [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u)\n    (s : Set \u03b2) : l (sSup (u '' s)) = sSup s", "start": [570, 1], "end": [571, 95], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_inf_u", "code": "theorem l_inf_u [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] (gi : GaloisInsertion l u) (a b : \u03b2) :\n    l (u a \u2293 u b) = a \u2293 b", "start": [574, 1], "end": [578, 42], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_iInf_u", "code": "theorem l_iInf_u [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u) {\u03b9 : Sort x}\n    (f : \u03b9 \u2192 \u03b2) : l (\u2a05 i, u (f i)) = \u2a05 i, f i", "start": [581, 1], "end": [585, 36], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_biInf_u", "code": "theorem l_biInf_u [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u) {\u03b9 : Sort x}\n    {p : \u03b9 \u2192 Prop} (f : \u2200 (i) (_ : p i), \u03b2) : l (\u2a05 (i) (hi), u (f i hi)) = \u2a05 (i) (hi), f i hi", "start": [588, 1], "end": [590, 41], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_sInf_u_image", "code": "theorem l_sInf_u_image [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u)\n    (s : Set \u03b2) : l (sInf (u '' s)) = sInf s", "start": [593, 1], "end": [594, 95], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_iInf_of_ul_eq_self", "code": "theorem l_iInf_of_ul_eq_self [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u)\n    {\u03b9 : Sort x} (f : \u03b9 \u2192 \u03b1) (hf : \u2200 i, u (l (f i)) = f i) : l (\u2a05 i, f i) = \u2a05 i, l (f i)", "start": [597, 1], "end": [601, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.l_biInf_of_ul_eq_self", "code": "theorem l_biInf_of_ul_eq_self [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisInsertion l u)\n    {\u03b9 : Sort x} {p : \u03b9 \u2192 Prop} (f : \u2200 (i) (_ : p i), \u03b1) (hf : \u2200 i hi, u (l (f i hi)) = f i hi) :\n    l (\u2a05 (i) (hi), f i hi) = \u2a05 (i) (hi), l (f i hi)", "start": [604, 1], "end": [608, 50], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.u_le_u_iff", "code": "theorem u_le_u_iff [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisInsertion l u) {a b} : u a \u2264 u b \u2194 a \u2264 b", "start": [611, 1], "end": [612, 77], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.strictMono_u", "code": "theorem strictMono_u [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisInsertion l u) : StrictMono u", "start": [615, 1], "end": [616, 56], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isLUB_of_u_image", "code": "theorem isLUB_of_u_image [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisInsertion l u) {s : Set \u03b2} {a : \u03b1}\n    (hs : IsLUB (u '' s) a) : IsLUB s (l a)", "start": [619, 1], "end": [622, 69], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isGLB_of_u_image", "code": "theorem isGLB_of_u_image [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisInsertion l u) {s : Set \u03b2} {a : \u03b1}\n    (hs : IsGLB (u '' s) a) : IsGLB s (l a)", "start": [625, 1], "end": [628, 98], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftSemilatticeSup", "code": "@[reducible]\ndef liftSemilatticeSup [SemilatticeSup \u03b1] (gi : GaloisInsertion l u) : SemilatticeSup \u03b2 :=\n  { \u2039PartialOrder \u03b2\u203a with\n    sup := fun a b => l (u a \u2294 u b)\n    le_sup_left := fun a _ => (gi.le_l_u a).trans <| gi.gc.monotone_l <| le_sup_left\n    le_sup_right := fun _ b => (gi.le_l_u b).trans <| gi.gc.monotone_l <| le_sup_right\n    sup_le := fun a b c hac hbc =>\n      gi.gc.l_le <| sup_le (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc) }", "start": [636, 1], "end": [644, 75], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftSemilatticeInf", "code": "@[reducible]\ndef liftSemilatticeInf [SemilatticeInf \u03b1] (gi : GaloisInsertion l u) : SemilatticeInf \u03b2 :=\n  { \u2039PartialOrder \u03b2\u203a with\n    inf := fun a b =>\n      gi.choice (u a \u2293 u b) <|\n        le_inf (gi.gc.monotone_u <| gi.gc.l_le <| inf_le_left)\n          (gi.gc.monotone_u <| gi.gc.l_le <| inf_le_right)\n    inf_le_left := by simp only [gi.choice_eq]; exact fun a b => gi.gc.l_le inf_le_left\n    inf_le_right := by simp only [gi.choice_eq]; exact fun a b => gi.gc.l_le inf_le_right\n    le_inf := by\n      simp only [gi.choice_eq]\n      exact fun a b c hac hbc =>\n        (gi.le_l_u a).trans <|\n          gi.gc.monotone_l <| le_inf (gi.gc.monotone_u hac) (gi.gc.monotone_u hbc) }", "start": [648, 1], "end": [662, 85], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftLattice", "code": "@[reducible]\ndef liftLattice [Lattice \u03b1] (gi : GaloisInsertion l u) : Lattice \u03b2 :=\n  { gi.liftSemilatticeSup, gi.liftSemilatticeInf with }", "start": [666, 1], "end": [669, 56], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftOrderTop", "code": "@[reducible]\ndef liftOrderTop [Preorder \u03b1] [OrderTop \u03b1] (gi : GaloisInsertion l u) :\n    OrderTop \u03b2 where\n  top := gi.choice \u22a4 <| le_top\n  le_top := by\n    simp only [gi.choice_eq]; exact fun b => (gi.le_l_u b).trans (gi.gc.monotone_l le_top)", "start": [673, 1], "end": [679, 91], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftBoundedOrder", "code": "@[reducible]\ndef liftBoundedOrder [Preorder \u03b1] [BoundedOrder \u03b1] (gi : GaloisInsertion l u) : BoundedOrder \u03b2 :=\n  { gi.liftOrderTop, gi.gc.liftOrderBot with }", "start": [683, 1], "end": [686, 47], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.liftCompleteLattice", "code": "@[reducible]\ndef liftCompleteLattice [CompleteLattice \u03b1] (gi : GaloisInsertion l u) : CompleteLattice \u03b2 :=\n  { gi.liftBoundedOrder, gi.liftLattice with\n    sSup := fun s => l (sSup (u '' s))\n    sSup_le := fun s => (gi.isLUB_of_u_image (isLUB_sSup _)).2\n    le_sSup := fun s => (gi.isLUB_of_u_image (isLUB_sSup _)).1\n    sInf := fun s =>\n      gi.choice (sInf (u '' s)) <|\n        (isGLB_sInf _).2 <|\n          gi.gc.monotone_u.mem_lowerBounds_image (gi.isGLB_of_u_image <| isGLB_sInf _).1\n    sInf_le := fun s => by dsimp; rw [gi.choice_eq]; exact (gi.isGLB_of_u_image (isGLB_sInf _)).1\n    le_sInf := fun s => by dsimp; rw [gi.choice_eq]; exact (gi.isGLB_of_u_image (isGLB_sInf _)).2 }", "start": [690, 1], "end": [702, 100], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion", "code": "structure GaloisCoinsertion [Preorder \u03b1] [Preorder \u03b2] (l : \u03b1 \u2192 \u03b2) (u : \u03b2 \u2192 \u03b1) where\n  \n  choice : \u2200 x : \u03b2, x \u2264 l (u x) \u2192 \u03b1\n  \n  gc : GaloisConnection l u\n  \n  u_l_le : \u2200 x, u (l x) \u2264 x\n  \n  choice_eq : \u2200 a h, choice a h = u a", "start": [710, 1], "end": [721, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.dual", "code": "def GaloisCoinsertion.dual [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} :\n    GaloisCoinsertion l u \u2192 GaloisInsertion (toDual \u2218 u \u2218 ofDual) (toDual \u2218 l \u2218 ofDual) :=\n  fun x => \u27e8x.1, x.2.dual, x.3, x.4\u27e9", "start": [724, 1], "end": [728, 37], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.dual", "code": "def GaloisInsertion.dual [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} :\n    GaloisInsertion l u \u2192 GaloisCoinsertion (toDual \u2218 u \u2218 ofDual) (toDual \u2218 l \u2218 ofDual) :=\n  fun x => \u27e8x.1, x.2.dual, x.3, x.4\u27e9", "start": [731, 1], "end": [735, 37], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.ofDual", "code": "def GaloisCoinsertion.ofDual [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48} {u : \u03b2\u1d52\u1d48 \u2192 \u03b1\u1d52\u1d48} :\n    GaloisCoinsertion l u \u2192 GaloisInsertion (ofDual \u2218 u \u2218 toDual) (ofDual \u2218 l \u2218 toDual) :=\n  fun x => \u27e8x.1, x.2.dual, x.3, x.4\u27e9", "start": [738, 1], "end": [742, 37], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.ofDual", "code": "def GaloisInsertion.ofDual [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48} {u : \u03b2\u1d52\u1d48 \u2192 \u03b1\u1d52\u1d48} :\n    GaloisInsertion l u \u2192 GaloisCoinsertion (ofDual \u2218 u \u2218 toDual) (ofDual \u2218 l \u2218 toDual) :=\n  fun x => \u27e8x.1, x.2.dual, x.3, x.4\u27e9", "start": [745, 1], "end": [749, 37], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toGaloisCoinsertion", "code": "protected def OrderIso.toGaloisCoinsertion [Preorder \u03b1] [Preorder \u03b2] (oi : \u03b1 \u2243o \u03b2) :\n    GaloisCoinsertion oi oi.symm where\n  choice b _ := oi.symm b\n  gc := oi.to_galoisConnection\n  u_l_le g := le_of_eq (oi.left_inv g)\n  choice_eq _ _ := rfl", "start": [752, 1], "end": [758, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.monotoneIntro", "code": "def GaloisCoinsertion.monotoneIntro [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (hu : Monotone u) (hl : Monotone l) (hlu : \u2200 b, l (u b) \u2264 b) (hul : \u2200 a, u (l a) = a) :\n    GaloisCoinsertion l u :=\n  (GaloisInsertion.monotoneIntro hl.dual hu.dual hlu hul).ofDual", "start": [761, 1], "end": [765, 65], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.toGaloisCoinsertion", "code": "def GaloisConnection.toGaloisCoinsertion {\u03b1 \u03b2 : Type*} [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2}\n    {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) (h : \u2200 a, u (l a) \u2264 a) : GaloisCoinsertion l u :=\n  { choice := fun x _ => u x\n    gc\n    u_l_le := h\n    choice_eq := fun _ _ => rfl }", "start": [768, 1], "end": [774, 34], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.liftOrderTop", "code": "def GaloisConnection.liftOrderTop {\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2] [OrderTop \u03b2]\n    {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} (gc : GaloisConnection l u) :\n    OrderTop \u03b1 where\n  top := u \u22a4\n  le_top _ := gc.le_u <| le_top", "start": [777, 1], "end": [782, 32], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_l_eq", "code": "theorem u_l_eq [PartialOrder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) (a : \u03b1) : u (l a) = a", "start": [789, 1], "end": [790, 19], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_l_leftInverse", "code": "theorem u_l_leftInverse [PartialOrder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) :\n    LeftInverse u l", "start": [793, 1], "end": [795, 12], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_bot", "code": "theorem u_bot [PartialOrder \u03b1] [Preorder \u03b2] [OrderBot \u03b1] [OrderBot \u03b2] (gi : GaloisCoinsertion l u) :\n    u \u22a5 = \u22a5", "start": [798, 1], "end": [800, 16], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_surjective", "code": "theorem u_surjective [PartialOrder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) : Surjective u", "start": [802, 1], "end": [803, 23], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.l_injective", "code": "theorem l_injective [PartialOrder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) : Injective l", "start": [806, 1], "end": [807, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_inf_l", "code": "theorem u_inf_l [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] (gi : GaloisCoinsertion l u) (a b : \u03b1) :\n    u (l a \u2293 l b) = a \u2293 b", "start": [810, 1], "end": [812, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_iInf_l", "code": "theorem u_iInf_l [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u) {\u03b9 : Sort x}\n    (f : \u03b9 \u2192 \u03b1) : u (\u2a05 i, l (f i)) = \u2a05 i, f i", "start": [815, 1], "end": [817, 21], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_sInf_l_image", "code": "theorem u_sInf_l_image [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u)\n    (s : Set \u03b1) : u (sInf (l '' s)) = sInf s", "start": [820, 1], "end": [822, 27], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_sup_l", "code": "theorem u_sup_l [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] (gi : GaloisCoinsertion l u) (a b : \u03b1) :\n    u (l a \u2294 l b) = a \u2294 b", "start": [825, 1], "end": [827, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_iSup_l", "code": "theorem u_iSup_l [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u) {\u03b9 : Sort x}\n    (f : \u03b9 \u2192 \u03b1) : u (\u2a06 i, l (f i)) = \u2a06 i, f i", "start": [830, 1], "end": [832, 21], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_biSup_l", "code": "theorem u_biSup_l [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u) {\u03b9 : Sort x}\n    {p : \u03b9 \u2192 Prop} (f : \u2200 (i) (_ : p i), \u03b1) : u (\u2a06 (i) (hi), l (f i hi)) = \u2a06 (i) (hi), f i hi", "start": [835, 1], "end": [837, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_sSup_l_image", "code": "theorem u_sSup_l_image [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u)\n    (s : Set \u03b1) : u (sSup (l '' s)) = sSup s", "start": [840, 1], "end": [842, 27], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_iSup_of_lu_eq_self", "code": "theorem u_iSup_of_lu_eq_self [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u)\n    {\u03b9 : Sort x} (f : \u03b9 \u2192 \u03b2) (hf : \u2200 i, l (u (f i)) = f i) : u (\u2a06 i, f i) = \u2a06 i, u (f i)", "start": [845, 1], "end": [847, 36], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.u_biSup_of_lu_eq_self", "code": "theorem u_biSup_of_lu_eq_self [CompleteLattice \u03b1] [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u)\n    {\u03b9 : Sort x} {p : \u03b9 \u2192 Prop} (f : \u2200 (i) (_ : p i), \u03b2) (hf : \u2200 i hi, l (u (f i hi)) = f i hi) :\n    u (\u2a06 (i) (hi), f i hi) = \u2a06 (i) (hi), u (f i hi)", "start": [850, 1], "end": [853, 37], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.l_le_l_iff", "code": "theorem l_le_l_iff [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) {a b} :\n    l a \u2264 l b \u2194 a \u2264 b", "start": [856, 1], "end": [858, 21], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.strictMono_l", "code": "theorem strictMono_l [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) : StrictMono l", "start": [861, 1], "end": [862, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isGLB_of_l_image", "code": "theorem isGLB_of_l_image [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) {s : Set \u03b1} {a : \u03b2}\n    (hs : IsGLB (l '' s) a) : IsGLB s (u a)", "start": [865, 1], "end": [867, 30], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isLUB_of_l_image", "code": "theorem isLUB_of_l_image [Preorder \u03b1] [Preorder \u03b2] (gi : GaloisCoinsertion l u) {s : Set \u03b1} {a : \u03b2}\n    (hs : IsLUB (l '' s) a) : IsLUB s (u a)", "start": [870, 1], "end": [872, 30], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftSemilatticeInf", "code": "@[reducible]\ndef liftSemilatticeInf [SemilatticeInf \u03b2] (gi : GaloisCoinsertion l u) : SemilatticeInf \u03b1 :=\n  { \u2039PartialOrder \u03b1\u203a with\n    inf_le_left := fun a b => by\n      exact (@OrderDual.semilatticeInf \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeSup).inf_le_left a b\n    inf_le_right := fun a b => by\n      exact (@OrderDual.semilatticeInf \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeSup).inf_le_right a b\n    le_inf := fun a b c => by\n      exact (@OrderDual.semilatticeInf \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeSup).le_inf a b c\n    inf := fun a b => u (l a \u2293 l b) }", "start": [886, 1], "end": [896, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftSemilatticeSup", "code": "@[reducible]\ndef liftSemilatticeSup [SemilatticeSup \u03b2] (gi : GaloisCoinsertion l u) : SemilatticeSup \u03b1 :=\n  { \u2039PartialOrder \u03b1\u203a with\n    sup := fun a b =>\n      gi.choice (l a \u2294 l b) <|\n        sup_le (gi.gc.monotone_l <| gi.gc.le_u <| le_sup_left)\n          (gi.gc.monotone_l <| gi.gc.le_u <| le_sup_right)\n    le_sup_left := fun a b => by\n      exact (@OrderDual.semilatticeSup \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeInf).le_sup_left a b\n    le_sup_right := fun a b => by\n      exact (@OrderDual.semilatticeSup \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeInf).le_sup_right a b\n    sup_le := fun a b c => by\n      exact (@OrderDual.semilatticeSup \u03b1\u1d52\u1d48 gi.dual.liftSemilatticeInf).sup_le a b c }", "start": [900, 1], "end": [913, 86], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftLattice", "code": "@[reducible]\ndef liftLattice [Lattice \u03b2] (gi : GaloisCoinsertion l u) : Lattice \u03b1 :=\n  { gi.liftSemilatticeSup, gi.liftSemilatticeInf with }", "start": [917, 1], "end": [920, 56], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftOrderBot", "code": "@[reducible]\ndef liftOrderBot [Preorder \u03b2] [OrderBot \u03b2] (gi : GaloisCoinsertion l u) : OrderBot \u03b1 :=\n  { @OrderDual.orderBot _ _ gi.dual.liftOrderTop with bot := gi.choice \u22a5 <| bot_le }", "start": [924, 1], "end": [927, 85], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftBoundedOrder", "code": "@[reducible]\ndef liftBoundedOrder [Preorder \u03b2] [BoundedOrder \u03b2] (gi : GaloisCoinsertion l u) : BoundedOrder \u03b1 :=\n  { gi.liftOrderBot, gi.gc.liftOrderTop with }", "start": [931, 1], "end": [934, 47], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.liftCompleteLattice", "code": "@[reducible]\ndef liftCompleteLattice [CompleteLattice \u03b2] (gi : GaloisCoinsertion l u) : CompleteLattice \u03b1 :=\n  { @OrderDual.completeLattice \u03b1\u1d52\u1d48 gi.dual.liftCompleteLattice with\n    sInf := fun s => u (sInf (l '' s))\n    sSup := fun s => gi.choice (sSup (l '' s)) _ }", "start": [938, 1], "end": [943, 51], "kind": "commanddeclaration"}, {"full_name": "gi_sSup_Iic", "code": "def gi_sSup_Iic [CompleteSemilatticeSup \u03b1] :\n    GaloisInsertion (sSup : Set \u03b1 \u2192 \u03b1) (Iic : \u03b1 \u2192 Set \u03b1) :=\n  gc_sSup_Iic.toGaloisInsertion fun _ \u21a6 le_sSup le_rfl", "start": [950, 1], "end": [953, 55], "kind": "commanddeclaration"}, {"full_name": "gci_Ici_sInf", "code": "def gci_Ici_sInf [CompleteSemilatticeInf \u03b1] :\n    GaloisCoinsertion (toDual \u2218 Ici : \u03b1 \u2192 (Set \u03b1)\u1d52\u1d48) (sInf \u2218 ofDual : (Set \u03b1)\u1d52\u1d48 \u2192 \u03b1) :=\n  gc_Ici_sInf.toGaloisCoinsertion fun _ \u21a6 sInf_le le_rfl", "start": [955, 1], "end": [958, 57], "kind": "commanddeclaration"}, {"full_name": "WithBot.giUnbot'Bot", "code": "def WithBot.giUnbot'Bot [Preorder \u03b1] [OrderBot \u03b1] :\n    GaloisInsertion (WithBot.unbot' \u22a5) (some : \u03b1 \u2192 WithBot \u03b1) where\n  gc _ _ := WithBot.unbot'_le_iff (fun _ \u21a6 bot_le)\n  le_l_u _ := le_rfl\n  choice o _ := o.unbot' \u22a5\n  choice_eq _ _ := rfl", "start": [960, 1], "end": [967, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CompleteBooleanAlgebra.lean", "imports": ["Mathlib/Logic/Equiv/Set.lean", "Mathlib/Order/Directed.lean", "Mathlib/Order/CompleteLattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.Frame", "code": "class Order.Frame (\u03b1 : Type*) extends CompleteLattice \u03b1 where\n  inf_sSup_le_iSup_inf (a : \u03b1) (s : Set \u03b1) : a \u2293 sSup s \u2264 \u2a06 b \u2208 s, a \u2293 b", "start": [62, 1], "end": [64, 73], "kind": "commanddeclaration"}, {"full_name": "Order.Coframe", "code": "class Order.Coframe (\u03b1 : Type*) extends CompleteLattice \u03b1 where\n  iInf_sup_le_sup_sInf (a : \u03b1) (s : Set \u03b1) : \u2a05 b \u2208 s, a \u2294 b \u2264 a \u2294 sInf s", "start": [70, 1], "end": [73, 73], "kind": "commanddeclaration"}, {"full_name": "CompleteDistribLattice", "code": "class CompleteDistribLattice (\u03b1 : Type*) extends Frame \u03b1 where\n  iInf_sup_le_sup_sInf : \u2200 a s, \u2a05 b \u2208 s, a \u2294 b \u2264 a \u2294 sInf s", "start": [81, 1], "end": [84, 60], "kind": "commanddeclaration"}, {"full_name": "CompleteDistribLattice.toCoframe", "code": "instance (priority := 100) CompleteDistribLattice.toCoframe [CompleteDistribLattice \u03b1] :\n    Coframe \u03b1 :=\n  { \u2039CompleteDistribLattice \u03b1\u203a with }", "start": [91, 1], "end": [93, 38], "kind": "commanddeclaration"}, {"full_name": "CompletelyDistribLattice", "code": "class CompletelyDistribLattice (\u03b1 : Type u) extends CompleteLattice \u03b1 where\n  protected iInf_iSup_eq {\u03b9 : Type u} {\u03ba : \u03b9 \u2192 Type u} (f : \u2200 a, \u03ba a \u2192 \u03b1) :\n    (\u2a05 a, \u2a06 b, f a b) = \u2a06 g : \u2200 a, \u03ba a, \u2a05 a, f a (g a)", "start": [96, 1], "end": [100, 55], "kind": "commanddeclaration"}, {"full_name": "le_iInf_iSup", "code": "theorem le_iInf_iSup [CompleteLattice \u03b1] {f : \u2200 a, \u03ba a \u2192 \u03b1} :\n    (\u2a06 g : \u2200 a, \u03ba a, \u2a05 a, f a (g a)) \u2264 \u2a05 a, \u2a06 b, f a b", "start": [102, 1], "end": [104, 73], "kind": "commanddeclaration"}, {"full_name": "iInf_iSup_eq", "code": "theorem iInf_iSup_eq [CompletelyDistribLattice \u03b1] {f : \u2200 a, \u03ba a \u2192 \u03b1} :\n    (\u2a05 a, \u2a06 b, f a b) = \u2a06 g : \u2200 a, \u03ba a, \u2a05 a, f a (g a)", "start": [106, 1], "end": [115, 53], "kind": "commanddeclaration"}, {"full_name": "iSup_iInf_le", "code": "theorem iSup_iInf_le [CompleteLattice \u03b1] {f : \u2200 a, \u03ba a \u2192 \u03b1} :\n    (\u2a06 a, \u2a05 b, f a b) \u2264 \u2a05 g : \u2200 a, \u03ba a, \u2a06 a, f a (g a)", "start": [117, 1], "end": [119, 26], "kind": "commanddeclaration"}, {"full_name": "iSup_iInf_eq", "code": "theorem iSup_iInf_eq [CompletelyDistribLattice \u03b1] {f : \u2200 a, \u03ba a \u2192 \u03b1} :\n    (\u2a06 a, \u2a05 b, f a b) = \u2a05 g : \u2200 a, \u03ba a, \u2a06 a, f a (g a)", "start": [121, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "CompletelyDistribLattice.toCompleteDistribLattice", "code": "instance (priority := 100) CompletelyDistribLattice.toCompleteDistribLattice\n    [CompletelyDistribLattice \u03b1] : CompleteDistribLattice \u03b1 where\n  iInf_sup_le_sup_sInf a s := calc\n    _ = \u2a05 b : s, \u2a06 x : Bool, cond x a b := by simp_rw [iInf_subtype, iSup_bool_eq, cond]\n    _ = _ := iInf_iSup_eq\n    _ \u2264 _ := iSup_le fun f => by\n      by_cases \u2200 i, f i = false\n      case pos => simp [h, iInf_subtype, \u2190 sInf_eq_iInf]\n      case neg =>\n        have \u27e8i, h\u27e9 : \u2203 i, f i = true := by simpa using h\n        refine le_trans (iInf_le _ i) ?_\n        simp [h]\n  inf_sSup_le_iSup_inf a s := calc\n    _ = \u2a05 x : Bool, \u2a06 y : cond x PUnit s, match x with | true => a | false => y.1 := by\n      simp_rw [iInf_bool_eq, cond, iSup_const, iSup_subtype, sSup_eq_iSup]\n    _ = _ := iInf_iSup_eq\n    _ \u2264 _ := by\n      simp_rw [iInf_bool_eq]\n      refine iSup_le fun g => le_trans ?_ (le_iSup _ (g false).1)\n      refine le_trans ?_ (le_iSup _ (g false).2)\n      rfl", "start": [136, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "CompleteLinearOrder.toCompletelyDistribLattice", "code": "instance (priority := 100) CompleteLinearOrder.toCompletelyDistribLattice [CompleteLinearOrder \u03b1] :\n    CompletelyDistribLattice \u03b1 where\n  iInf_iSup_eq {\u03b1 \u03b2} g := by\n    let lhs := \u2a05 a, \u2a06 b, g a b\n    let rhs := \u2a06 h : \u2200 a, \u03b2 a, \u2a05 a, g a (h a)\n    suffices lhs \u2264 rhs from le_antisymm this le_iInf_iSup\n    by_cases \u2203 x, rhs < x \u2227 x < lhs\n    case pos =>\n      rcases h with \u27e8x, hr, hl\u27e9\n      suffices rhs \u2265 x from nomatch not_lt.2 this hr\n      have : \u2200 a, \u2203 b, x < g a b := fun a =>\n        lt_iSup_iff.1 <| lt_of_not_le fun h =>\n            lt_irrefl x (lt_of_lt_of_le hl (le_trans (iInf_le _ a) h))\n      choose f hf using this\n      refine le_trans ?_ (le_iSup _ f)\n      refine le_iInf fun a => le_of_lt (hf a)\n    case neg =>\n      refine le_of_not_lt fun hrl : rhs < lhs => not_le_of_lt hrl ?_\n      replace h : \u2200 x, x \u2264 rhs \u2228 lhs \u2264 x := by\n        simpa only [not_exists, not_and_or, not_or, not_lt] using h\n      have : \u2200 a, \u2203 b, rhs < g a b := fun a =>\n        lt_iSup_iff.1 <| lt_of_lt_of_le hrl (iInf_le _ a)\n      choose f hf using this\n      have : \u2200 a, lhs \u2264 g a (f a) := fun a =>\n        (h (g a (f a))).resolve_left (by simpa using hf a)\n      refine le_trans ?_ (le_iSup _ f)\n      refine le_iInf fun a => this _", "start": [159, 1], "end": [185, 37], "kind": "commanddeclaration"}, {"full_name": "OrderDual.coframe", "code": "instance OrderDual.coframe : Coframe \u03b1\u1d52\u1d48 :=\n  { OrderDual.completeLattice \u03b1 with iInf_sup_le_sup_sInf := @Frame.inf_sSup_le_iSup_inf \u03b1 _ }", "start": [191, 1], "end": [192, 95], "kind": "commanddeclaration"}, {"full_name": "inf_sSup_eq", "code": "theorem inf_sSup_eq : a \u2293 sSup s = \u2a06 b \u2208 s, a \u2293 b", "start": [195, 1], "end": [196, 65], "kind": "commanddeclaration"}, {"full_name": "sSup_inf_eq", "code": "theorem sSup_inf_eq : sSup s \u2293 b = \u2a06 a \u2208 s, a \u2293 b", "start": [199, 1], "end": [200, 51], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_eq", "code": "theorem iSup_inf_eq (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : (\u2a06 i, f i) \u2293 a = \u2a06 i, f i \u2293 a", "start": [203, 1], "end": [204, 37], "kind": "commanddeclaration"}, {"full_name": "inf_iSup_eq", "code": "theorem inf_iSup_eq (a : \u03b1) (f : \u03b9 \u2192 \u03b1) : (a \u2293 \u2a06 i, f i) = \u2a06 i, a \u2293 f i", "start": [207, 1], "end": [208, 46], "kind": "commanddeclaration"}, {"full_name": "Prod.frame", "code": "instance Prod.frame (\u03b1 \u03b2) [Frame \u03b1] [Frame \u03b2] : Frame (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.completeLattice \u03b1 \u03b2\n  inf_sSup_le_iSup_inf a s := by\n    simp [Prod.le_def, sSup_eq_iSup, fst_iSup, snd_iSup, fst_iInf, snd_iInf, inf_iSup_eq]", "start": [211, 1], "end": [214, 90], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_inf_eq", "code": "theorem iSup\u2082_inf_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) : (\u2a06 (i) (j), f i j) \u2293 a = \u2a06 (i) (j), f i j \u2293 a", "start": [216, 1], "end": [217, 29], "kind": "commanddeclaration"}, {"full_name": "inf_iSup\u2082_eq", "code": "theorem inf_iSup\u2082_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) : (a \u2293 \u2a06 (i) (j), f i j) = \u2a06 (i) (j), a \u2293 f i j", "start": [220, 1], "end": [221, 29], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_iSup", "code": "theorem iSup_inf_iSup {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n    ((\u2a06 i, f i) \u2293 \u2a06 j, g j) = \u2a06 i : \u03b9 \u00d7 \u03b9', f i.1 \u2293 g i.2", "start": [224, 1], "end": [226, 48], "kind": "commanddeclaration"}, {"full_name": "biSup_inf_biSup", "code": "theorem biSup_inf_biSup {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} {s : Set \u03b9} {t : Set \u03b9'} :\n    ((\u2a06 i \u2208 s, f i) \u2293 \u2a06 j \u2208 t, g j) = \u2a06 p \u2208 s \u00d7\u02e2 t, f (p : \u03b9 \u00d7 \u03b9').1 \u2293 g p.2", "start": [229, 1], "end": [232, 79], "kind": "commanddeclaration"}, {"full_name": "sSup_inf_sSup", "code": "theorem sSup_inf_sSup : sSup s \u2293 sSup t = \u2a06 p \u2208 s \u00d7\u02e2 t, (p : \u03b1 \u00d7 \u03b1).1 \u2293 p.2", "start": [235, 1], "end": [236, 44], "kind": "commanddeclaration"}, {"full_name": "iSup_disjoint_iff", "code": "theorem iSup_disjoint_iff {f : \u03b9 \u2192 \u03b1} : Disjoint (\u2a06 i, f i) a \u2194 \u2200 i, Disjoint (f i) a", "start": [239, 1], "end": [240, 53], "kind": "commanddeclaration"}, {"full_name": "disjoint_iSup_iff", "code": "theorem disjoint_iSup_iff {f : \u03b9 \u2192 \u03b1} : Disjoint a (\u2a06 i, f i) \u2194 \u2200 i, Disjoint a (f i)", "start": [243, 1], "end": [244, 54], "kind": "commanddeclaration"}, {"full_name": "iSup\u2082_disjoint_iff", "code": "theorem iSup\u2082_disjoint_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} :\n    Disjoint (\u2a06 (i) (j), f i j) a \u2194 \u2200 i j, Disjoint (f i j) a", "start": [247, 1], "end": [249, 30], "kind": "commanddeclaration"}, {"full_name": "disjoint_iSup\u2082_iff", "code": "theorem disjoint_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 \u03b1} :\n    Disjoint a (\u2a06 (i) (j), f i j) \u2194 \u2200 i j, Disjoint a (f i j)", "start": [252, 1], "end": [254, 30], "kind": "commanddeclaration"}, {"full_name": "sSup_disjoint_iff", "code": "theorem sSup_disjoint_iff {s : Set \u03b1} : Disjoint (sSup s) a \u2194 \u2200 b \u2208 s, Disjoint b a", "start": [257, 1], "end": [258, 53], "kind": "commanddeclaration"}, {"full_name": "disjoint_sSup_iff", "code": "theorem disjoint_sSup_iff {s : Set \u03b1} : Disjoint a (sSup s) \u2194 \u2200 b \u2208 s, Disjoint a b", "start": [261, 1], "end": [262, 54], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_of_monotone", "code": "theorem iSup_inf_of_monotone {\u03b9 : Type*} [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] {f g : \u03b9 \u2192 \u03b1}\n    (hf : Monotone f) (hg : Monotone g) : \u2a06 i, f i \u2293 g i = (\u2a06 i, f i) \u2293 \u2a06 i, g i", "start": [265, 1], "end": [271, 40], "kind": "commanddeclaration"}, {"full_name": "iSup_inf_of_antitone", "code": "theorem iSup_inf_of_antitone {\u03b9 : Type*} [Preorder \u03b9] [IsDirected \u03b9 (swap (\u00b7 \u2264 \u00b7))] {f g : \u03b9 \u2192 \u03b1}\n    (hf : Antitone f) (hg : Antitone g) : \u2a06 i, f i \u2293 g i = (\u2a06 i, f i) \u2293 \u2a06 i, g i", "start": [274, 1], "end": [276, 66], "kind": "commanddeclaration"}, {"full_name": "Pi.frame", "code": "instance Pi.frame {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, Frame (\u03c0 i)] : Frame (\u2200 i, \u03c0 i) :=\n  { Pi.completeLattice with\n    inf_sSup_le_iSup_inf := fun a s i => by\n      simp only [sSup_apply, iSup_apply, inf_apply, inf_iSup_eq, \u2190 iSup_subtype'']; rfl }", "start": [279, 1], "end": [282, 90], "kind": "commanddeclaration"}, {"full_name": "Frame.toDistribLattice", "code": "instance (priority := 100) Frame.toDistribLattice : DistribLattice \u03b1 :=\n  DistribLattice.ofInfSupLe fun a b c => by\n    rw [\u2190 sSup_pair, \u2190 sSup_pair, inf_sSup_eq, \u2190 sSup_image, image_pair]", "start": [286, 1], "end": [288, 73], "kind": "commanddeclaration"}, {"full_name": "OrderDual.frame", "code": "instance OrderDual.frame : Frame \u03b1\u1d52\u1d48 :=\n  { OrderDual.completeLattice \u03b1 with inf_sSup_le_iSup_inf := @Coframe.iInf_sup_le_sup_sInf \u03b1 _ }", "start": [297, 1], "end": [298, 97], "kind": "commanddeclaration"}, {"full_name": "sup_sInf_eq", "code": "theorem sup_sInf_eq : a \u2294 sInf s = \u2a05 b \u2208 s, a \u2294 b", "start": [301, 1], "end": [302, 25], "kind": "commanddeclaration"}, {"full_name": "sInf_sup_eq", "code": "theorem sInf_sup_eq : sInf s \u2294 b = \u2a05 a \u2208 s, a \u2294 b", "start": [305, 1], "end": [306, 25], "kind": "commanddeclaration"}, {"full_name": "iInf_sup_eq", "code": "theorem iInf_sup_eq (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : (\u2a05 i, f i) \u2294 a = \u2a05 i, f i \u2294 a", "start": [309, 1], "end": [310, 27], "kind": "commanddeclaration"}, {"full_name": "sup_iInf_eq", "code": "theorem sup_iInf_eq (a : \u03b1) (f : \u03b9 \u2192 \u03b1) : (a \u2294 \u2a05 i, f i) = \u2a05 i, a \u2294 f i", "start": [313, 1], "end": [314, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.coframe", "code": "instance Prod.coframe (\u03b1 \u03b2) [Coframe \u03b1] [Coframe \u03b2] : Coframe (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.completeLattice \u03b1 \u03b2\n  iInf_sup_le_sup_sInf a s := by\n    simp [Prod.le_def, sInf_eq_iInf, fst_iSup, snd_iSup, fst_iInf, snd_iInf, sup_iInf_eq]", "start": [317, 1], "end": [320, 90], "kind": "commanddeclaration"}, {"full_name": "iInf\u2082_sup_eq", "code": "theorem iInf\u2082_sup_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) : (\u2a05 (i) (j), f i j) \u2294 a = \u2a05 (i) (j), f i j \u2294 a", "start": [322, 1], "end": [323, 30], "kind": "commanddeclaration"}, {"full_name": "sup_iInf\u2082_eq", "code": "theorem sup_iInf\u2082_eq {f : \u2200 i, \u03ba i \u2192 \u03b1} (a : \u03b1) : (a \u2294 \u2a05 (i) (j), f i j) = \u2a05 (i) (j), a \u2294 f i j", "start": [326, 1], "end": [327, 30], "kind": "commanddeclaration"}, {"full_name": "iInf_sup_iInf", "code": "theorem iInf_sup_iInf {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n    ((\u2a05 i, f i) \u2294 \u2a05 i, g i) = \u2a05 i : \u03b9 \u00d7 \u03b9', f i.1 \u2294 g i.2", "start": [330, 1], "end": [332, 31], "kind": "commanddeclaration"}, {"full_name": "biInf_sup_biInf", "code": "theorem biInf_sup_biInf {\u03b9 \u03b9' : Type*} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} {s : Set \u03b9} {t : Set \u03b9'} :\n    ((\u2a05 i \u2208 s, f i) \u2294 \u2a05 j \u2208 t, g j) = \u2a05 p \u2208 s \u00d7\u02e2 t, f (p : \u03b9 \u00d7 \u03b9').1 \u2294 g p.2", "start": [335, 1], "end": [337, 37], "kind": "commanddeclaration"}, {"full_name": "sInf_sup_sInf", "code": "theorem sInf_sup_sInf : sInf s \u2294 sInf t = \u2a05 p \u2208 s \u00d7\u02e2 t, (p : \u03b1 \u00d7 \u03b1).1 \u2294 p.2", "start": [340, 1], "end": [341, 27], "kind": "commanddeclaration"}, {"full_name": "iInf_sup_of_monotone", "code": "theorem iInf_sup_of_monotone {\u03b9 : Type*} [Preorder \u03b9] [IsDirected \u03b9 (swap (\u00b7 \u2264 \u00b7))] {f g : \u03b9 \u2192 \u03b1}\n    (hf : Monotone f) (hg : Monotone g) : \u2a05 i, f i \u2294 g i = (\u2a05 i, f i) \u2294 \u2a05 i, g i", "start": [344, 1], "end": [346, 68], "kind": "commanddeclaration"}, {"full_name": "iInf_sup_of_antitone", "code": "theorem iInf_sup_of_antitone {\u03b9 : Type*} [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] {f g : \u03b9 \u2192 \u03b1}\n    (hf : Antitone f) (hg : Antitone g) : \u2a05 i, f i \u2294 g i = (\u2a05 i, f i) \u2294 \u2a05 i, g i", "start": [349, 1], "end": [351, 68], "kind": "commanddeclaration"}, {"full_name": "Pi.coframe", "code": "instance Pi.coframe {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, Coframe (\u03c0 i)] : Coframe (\u2200 i, \u03c0 i) :=\n  { Pi.completeLattice with\n    iInf_sup_le_sup_sInf := fun a s i => by\n      simp only [sInf_apply, iInf_apply, sup_apply, sup_iInf_eq, \u2190 iInf_subtype'']; rfl }", "start": [354, 1], "end": [357, 90], "kind": "commanddeclaration"}, {"full_name": "Coframe.toDistribLattice", "code": "instance (priority := 100) Coframe.toDistribLattice : DistribLattice \u03b1 :=\n  { \u2039Coframe \u03b1\u203a with\n    le_sup_inf := fun a b c => by\n      rw [\u2190 sInf_pair, \u2190 sInf_pair, sup_sInf_eq, \u2190 sInf_image, image_pair] }", "start": [361, 1], "end": [364, 77], "kind": "commanddeclaration"}, {"full_name": "OrderDual.completeDistribLattice", "code": "instance OrderDual.completeDistribLattice (\u03b1) [CompleteDistribLattice \u03b1] :\n    CompleteDistribLattice \u03b1\u1d52\u1d48 :=\n  { OrderDual.frame, OrderDual.coframe with }", "start": [376, 1], "end": [378, 46], "kind": "commanddeclaration"}, {"full_name": "Prod.completeDistribLattice", "code": "instance Prod.completeDistribLattice (\u03b1 \u03b2)\n    [CompleteDistribLattice \u03b1] [CompleteDistribLattice \u03b2] :\n    CompleteDistribLattice (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.completeLattice \u03b1 \u03b2\n  __ := Prod.frame \u03b1 \u03b2\n  __ := Prod.coframe \u03b1 \u03b2", "start": [380, 1], "end": [385, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.completeDistribLattice", "code": "instance Pi.completeDistribLattice {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n    [\u2200 i, CompleteDistribLattice (\u03c0 i)] : CompleteDistribLattice (\u2200 i, \u03c0 i) :=\n  { Pi.frame, Pi.coframe with }", "start": [387, 1], "end": [389, 32], "kind": "commanddeclaration"}, {"full_name": "OrderDual.completelyDistribLattice", "code": "instance OrderDual.completelyDistribLattice (\u03b1) [CompletelyDistribLattice \u03b1] :\n    CompletelyDistribLattice \u03b1\u1d52\u1d48 where\n  __ := OrderDual.completeLattice \u03b1\n  iInf_iSup_eq _ := iSup_iInf_eq (\u03b1 := \u03b1)", "start": [396, 1], "end": [399, 42], "kind": "commanddeclaration"}, {"full_name": "Prod.completelyDistribLattice", "code": "instance Prod.completelyDistribLattice (\u03b1 \u03b2)\n    [CompletelyDistribLattice \u03b1] [CompletelyDistribLattice \u03b2] :\n    CompletelyDistribLattice (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.completeLattice \u03b1 \u03b2\n  iInf_iSup_eq f := by ext <;> simp [fst_iSup, fst_iInf, snd_iSup, snd_iInf, iInf_iSup_eq]", "start": [401, 1], "end": [405, 91], "kind": "commanddeclaration"}, {"full_name": "Pi.completelyDistribLattice", "code": "instance Pi.completelyDistribLattice {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n    [\u2200 i, CompletelyDistribLattice (\u03c0 i)] : CompletelyDistribLattice (\u2200 i, \u03c0 i) where\n  __ := Pi.completeLattice\n  iInf_iSup_eq f := by ext i; simp only [iInf_apply, iSup_apply, iInf_iSup_eq]", "start": [407, 1], "end": [410, 79], "kind": "commanddeclaration"}, {"full_name": "CompleteBooleanAlgebra", "code": "class CompleteBooleanAlgebra (\u03b1) extends BooleanAlgebra \u03b1, CompleteDistribLattice \u03b1", "start": [414, 1], "end": [419, 84], "kind": "commanddeclaration"}, {"full_name": "Prod.completeBooleanAlgebra", "code": "instance Prod.completeBooleanAlgebra (\u03b1 \u03b2)\n    [CompleteBooleanAlgebra \u03b1] [CompleteBooleanAlgebra \u03b2] :\n    CompleteBooleanAlgebra (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.booleanAlgebra \u03b1 \u03b2\n  __ := Prod.completeDistribLattice \u03b1 \u03b2", "start": [422, 1], "end": [426, 40], "kind": "commanddeclaration"}, {"full_name": "Pi.completeBooleanAlgebra", "code": "instance Pi.completeBooleanAlgebra {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n    [\u2200 i, CompleteBooleanAlgebra (\u03c0 i)] : CompleteBooleanAlgebra (\u2200 i, \u03c0 i) :=\n  { Pi.booleanAlgebra, Pi.completeDistribLattice with }", "start": [428, 1], "end": [430, 56], "kind": "commanddeclaration"}, {"full_name": "OrderDual.completeBooleanAlgebra", "code": "instance OrderDual.completeBooleanAlgebra (\u03b1) [CompleteBooleanAlgebra \u03b1] :\n    CompleteBooleanAlgebra \u03b1\u1d52\u1d48 where\n  __ := OrderDual.booleanAlgebra \u03b1\n  __ := OrderDual.completeDistribLattice \u03b1", "start": [433, 1], "end": [436, 43], "kind": "commanddeclaration"}, {"full_name": "compl_iInf", "code": "theorem compl_iInf : (iInf f)\u1d9c = \u2a06 i, (f i)\u1d9c", "start": [442, 1], "end": [446, 53], "kind": "commanddeclaration"}, {"full_name": "compl_iSup", "code": "theorem compl_iSup : (iSup f)\u1d9c = \u2a05 i, (f i)\u1d9c", "start": [449, 1], "end": [450, 41], "kind": "commanddeclaration"}, {"full_name": "compl_sInf", "code": "theorem compl_sInf : (sInf s)\u1d9c = \u2a06 i \u2208 s, i\u1d9c", "start": [453, 1], "end": [453, 88], "kind": "commanddeclaration"}, {"full_name": "compl_sSup", "code": "theorem compl_sSup : (sSup s)\u1d9c = \u2a05 i \u2208 s, i\u1d9c", "start": [456, 1], "end": [456, 88], "kind": "commanddeclaration"}, {"full_name": "compl_sInf'", "code": "theorem compl_sInf' : (sInf s)\u1d9c = sSup (HasCompl.compl '' s)", "start": [459, 1], "end": [460, 35], "kind": "commanddeclaration"}, {"full_name": "compl_sSup'", "code": "theorem compl_sSup' : (sSup s)\u1d9c = sInf (HasCompl.compl '' s)", "start": [463, 1], "end": [464, 35], "kind": "commanddeclaration"}, {"full_name": "CompleteAtomicBooleanAlgebra", "code": "class CompleteAtomicBooleanAlgebra (\u03b1 : Type u) extends\n    CompletelyDistribLattice \u03b1, CompleteBooleanAlgebra \u03b1 where\n  iInf_sup_le_sup_sInf := CompletelyDistribLattice.toCompleteDistribLattice.iInf_sup_le_sup_sInf\n  inf_sSup_le_iSup_inf := CompletelyDistribLattice.toCompleteDistribLattice.inf_sSup_le_iSup_inf", "start": [469, 1], "end": [479, 97], "kind": "commanddeclaration"}, {"full_name": "Prod.completeAtomicBooleanAlgebra", "code": "instance Prod.completeAtomicBooleanAlgebra (\u03b1 \u03b2)\n    [CompleteAtomicBooleanAlgebra \u03b1] [CompleteAtomicBooleanAlgebra \u03b2] :\n    CompleteAtomicBooleanAlgebra (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.booleanAlgebra \u03b1 \u03b2\n  __ := Prod.completelyDistribLattice \u03b1 \u03b2", "start": [481, 1], "end": [485, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.completeAtomicBooleanAlgebra", "code": "instance Pi.completeAtomicBooleanAlgebra {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*}\n    [\u2200 i, CompleteAtomicBooleanAlgebra (\u03c0 i)] : CompleteAtomicBooleanAlgebra (\u2200 i, \u03c0 i) where\n  __ := Pi.completeBooleanAlgebra\n  iInf_iSup_eq f := by ext; rw [iInf_iSup_eq]", "start": [487, 1], "end": [490, 46], "kind": "commanddeclaration"}, {"full_name": "OrderDual.completeAtomicBooleanAlgebra", "code": "instance OrderDual.completeAtomicBooleanAlgebra (\u03b1) [CompleteAtomicBooleanAlgebra \u03b1] :\n    CompleteAtomicBooleanAlgebra \u03b1\u1d52\u1d48 where\n  __ := OrderDual.completeBooleanAlgebra \u03b1\n  __ := OrderDual.completelyDistribLattice \u03b1", "start": [492, 1], "end": [495, 45], "kind": "commanddeclaration"}, {"full_name": "Prop.completeAtomicBooleanAlgebra", "code": "instance Prop.completeAtomicBooleanAlgebra : CompleteAtomicBooleanAlgebra Prop where\n  __ := Prop.completeLattice\n  __ := Prop.booleanAlgebra\n  iInf_iSup_eq f := by simp [Classical.skolem]", "start": [497, 1], "end": [500, 47], "kind": "commanddeclaration"}, {"full_name": "Prop.completeBooleanAlgebra", "code": "instance Prop.completeBooleanAlgebra : CompleteBooleanAlgebra Prop := inferInstance", "start": [502, 1], "end": [502, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.frame", "code": "@[reducible]\nprotected def Function.Injective.frame [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1] [Top \u03b1] [Bot \u03b1]\n    [Frame \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a)\n    (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) :\n    Frame \u03b1 :=\n  { hf.completeLattice f map_sup map_inf map_sSup map_sInf map_top map_bot with\n    inf_sSup_le_iSup_inf := fun a s => by\n      change f (a \u2293 sSup s) \u2264 f _\n      rw [\u2190 sSup_image, map_inf, map_sSup s, inf_iSup\u2082_eq]\n      simp_rw [\u2190 map_inf]\n      exact ((map_sSup _).trans iSup_image).ge }", "start": [508, 1], "end": [520, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.coframe", "code": "@[reducible]\nprotected def Function.Injective.coframe [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1] [Top \u03b1] [Bot \u03b1]\n    [Coframe \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a)\n    (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) :\n    Coframe \u03b1 :=\n  { hf.completeLattice f map_sup map_inf map_sSup map_sInf map_top map_bot with\n    iInf_sup_le_sup_sInf := fun a s => by\n      change f _ \u2264 f (a \u2294 sInf s)\n      rw [\u2190 sInf_image, map_sup, map_sInf s, sup_iInf\u2082_eq]\n      simp_rw [\u2190 map_sup]\n      exact ((map_sInf _).trans iInf_image).le }", "start": [524, 1], "end": [536, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.completeDistribLattice", "code": "@[reducible]\nprotected def Function.Injective.completeDistribLattice [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1]\n    [Top \u03b1] [Bot \u03b1] [CompleteDistribLattice \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a) (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) : CompleteDistribLattice \u03b1 :=\n  { hf.frame f map_sup map_inf map_sSup map_sInf map_top map_bot,\n    hf.coframe f map_sup map_inf map_sSup map_sInf map_top map_bot with }", "start": [540, 1], "end": [548, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.completelyDistribLattice", "code": "@[reducible]\nprotected def Function.Injective.completelyDistribLattice [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1]\n    [Top \u03b1] [Bot \u03b1] [CompletelyDistribLattice \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a) (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) : CompletelyDistribLattice \u03b1 where\n  __ := hf.completeLattice f map_sup map_inf map_sSup map_sInf map_top map_bot\n  iInf_iSup_eq g := hf <| by\n    simp_rw [iInf, map_sInf, iInf_range, iSup, map_sSup, iSup_range, map_sInf, iInf_range,\n      iInf_iSup_eq]", "start": [552, 1], "end": [562, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.completeBooleanAlgebra", "code": "@[reducible]\nprotected def Function.Injective.completeBooleanAlgebra [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1]\n    [Top \u03b1] [Bot \u03b1] [HasCompl \u03b1] [SDiff \u03b1] [CompleteBooleanAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf : Function.Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a)\n    (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5)\n    (map_compl : \u2200 a, f a\u1d9c = (f a)\u1d9c) (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) :\n    CompleteBooleanAlgebra \u03b1 :=\n  { hf.completeDistribLattice f map_sup map_inf map_sSup map_sInf map_top map_bot,\n    hf.booleanAlgebra f map_sup map_inf map_top map_bot map_compl map_sdiff with }", "start": [565, 1], "end": [575, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.completeAtomicBooleanAlgebra", "code": "@[reducible]\nprotected def Function.Injective.completeAtomicBooleanAlgebra [Sup \u03b1] [Inf \u03b1] [SupSet \u03b1] [InfSet \u03b1]\n    [Top \u03b1] [Bot \u03b1] [HasCompl \u03b1] [SDiff \u03b1] [CompleteAtomicBooleanAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf : Function.Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) (map_sSup : \u2200 s, f (sSup s) = \u2a06 a \u2208 s, f a)\n    (map_sInf : \u2200 s, f (sInf s) = \u2a05 a \u2208 s, f a) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5)\n    (map_compl : \u2200 a, f a\u1d9c = (f a)\u1d9c) (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) :\n    CompleteAtomicBooleanAlgebra \u03b1 where\n  __ := hf.completelyDistribLattice f map_sup map_inf map_sSup map_sInf map_top map_bot\n  __ := hf.booleanAlgebra f map_sup map_inf map_top map_bot map_compl map_sdiff", "start": [579, 1], "end": [589, 80], "kind": "commanddeclaration"}, {"full_name": "PUnit.completeAtomicBooleanAlgebra", "code": "instance completeAtomicBooleanAlgebra : CompleteAtomicBooleanAlgebra PUnit := by\n  refine'\n    { PUnit.booleanAlgebra with\n      sSup := fun _ => unit\n      sInf := fun _ => unit\n      .. } <;>\n  (intros; trivial)", "start": [597, 1], "end": [603, 20], "kind": "commanddeclaration"}, {"full_name": "PUnit.completeBooleanAlgebra", "code": "instance completeBooleanAlgebra : CompleteBooleanAlgebra PUnit := inferInstance", "start": [605, 1], "end": [605, 80], "kind": "commanddeclaration"}, {"full_name": "PUnit.completeLinearOrder", "code": "instance completeLinearOrder : CompleteLinearOrder PUnit :=\n  { PUnit.completeBooleanAlgebra, PUnit.linearOrder with }", "start": [607, 1], "end": [608, 59], "kind": "commanddeclaration"}, {"full_name": "PUnit.sSup_eq", "code": "@[simp]\ntheorem sSup_eq : sSup s = unit", "start": [610, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.sInf_eq", "code": "@[simp]\ntheorem sInf_eq : sInf s = unit", "start": [615, 1], "end": [617, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Dedup.lean", "imports": ["Mathlib/Data/Multiset/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.dedup", "code": "def dedup (s : Multiset \u03b1) : Multiset \u03b1 :=\n  Quot.liftOn s (fun l => (l.dedup : Multiset \u03b1)) fun _ _ p => Quot.sound p.dedup", "start": [24, 1], "end": [26, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_dedup", "code": "@[simp]\ntheorem coe_dedup (l : List \u03b1) : @dedup \u03b1 _ l = l.dedup", "start": [29, 1], "end": [31, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_zero", "code": "@[simp]\ntheorem dedup_zero : @dedup \u03b1 _ 0 = 0", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_dedup", "code": "@[simp]\ntheorem mem_dedup {a : \u03b1} {s : Multiset \u03b1} : a \u2208 dedup s \u2194 a \u2208 s", "start": [39, 1], "end": [41, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_cons_of_mem", "code": "@[simp]\ntheorem dedup_cons_of_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 dedup (a ::\u2098 s) = dedup s", "start": [44, 1], "end": [46, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_cons_of_not_mem", "code": "@[simp]\ntheorem dedup_cons_of_not_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2209 s \u2192 dedup (a ::\u2098 s) = a ::\u2098 dedup s", "start": [49, 1], "end": [51, 82], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_le", "code": "theorem dedup_le (s : Multiset \u03b1) : dedup s \u2264 s", "start": [54, 1], "end": [55, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_subset", "code": "theorem dedup_subset (s : Multiset \u03b1) : dedup s \u2286 s", "start": [58, 1], "end": [59, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_dedup", "code": "theorem subset_dedup (s : Multiset \u03b1) : s \u2286 dedup s", "start": [62, 1], "end": [62, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_subset'", "code": "@[simp]\ntheorem dedup_subset' {s t : Multiset \u03b1} : dedup s \u2286 t \u2194 s \u2286 t", "start": [65, 1], "end": [67, 65], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_dedup'", "code": "@[simp]\ntheorem subset_dedup' {s t : Multiset \u03b1} : s \u2286 dedup t \u2194 s \u2286 t", "start": [70, 1], "end": [72, 87], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_dedup", "code": "@[simp]\ntheorem nodup_dedup (s : Multiset \u03b1) : Nodup (dedup s)", "start": [75, 1], "end": [77, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_eq_self", "code": "theorem dedup_eq_self {s : Multiset \u03b1} : dedup s = s \u2194 Nodup s", "start": [80, 1], "end": [81, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.dedup", "code": "alias \u27e8_, Nodup.dedup\u27e9 := dedup_eq_self", "start": [84, 1], "end": [84, 40], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.count_dedup", "code": "theorem count_dedup (m : Multiset \u03b1) (a : \u03b1) : m.dedup.count a = if a \u2208 m then 1 else 0", "start": [87, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_idem", "code": "@[simp]\ntheorem dedup_idem {m : Multiset \u03b1} : m.dedup.dedup = m.dedup", "start": [93, 1], "end": [95, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_bind_dedup", "code": "@[simp]\ntheorem dedup_bind_dedup [DecidableEq \u03b2] (m : Multiset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) :\n    (m.dedup.bind f).dedup = (m.bind f).dedup", "start": [98, 1], "end": [105, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_eq_zero", "code": "theorem dedup_eq_zero {s : Multiset \u03b1} : dedup s = 0 \u2194 s = 0", "start": [108, 1], "end": [109, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_singleton", "code": "@[simp]\ntheorem dedup_singleton {a : \u03b1} : dedup ({a} : Multiset \u03b1) = {a}", "start": [112, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_dedup", "code": "theorem le_dedup {s t : Multiset \u03b1} : s \u2264 dedup t \u2194 s \u2264 t \u2227 Nodup s", "start": [117, 1], "end": [119, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_dedup_self", "code": "theorem le_dedup_self {s : Multiset \u03b1} : s \u2264 dedup s \u2194 Nodup s", "start": [122, 1], "end": [123, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_ext", "code": "theorem dedup_ext {s t : Multiset \u03b1} : dedup s = dedup t \u2194 \u2200 a, a \u2208 s \u2194 a \u2208 t", "start": [126, 1], "end": [127, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_map_dedup_eq", "code": "theorem dedup_map_dedup_eq [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) :\n    dedup (map f (dedup s)) = dedup (map f s)", "start": [130, 1], "end": [132, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_nsmul", "code": "@[simp]\ntheorem dedup_nsmul {s : Multiset \u03b1} {n : \u2115} (h0 : n \u2260 0) : (n \u2022 s).dedup = s.dedup", "start": [135, 1], "end": [138, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.le_dedup_iff_le", "code": "theorem Nodup.le_dedup_iff_le {s t : Multiset \u03b1} (hno : s.Nodup) : s \u2264 t.dedup \u2194 s \u2264 t", "start": [141, 1], "end": [142, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.le_nsmul_iff_le", "code": "theorem Multiset.Nodup.le_nsmul_iff_le {\u03b1 : Type*} {s t : Multiset \u03b1} {n : \u2115} (h : s.Nodup)\n    (hn : n \u2260 0) : s \u2264 n \u2022 t \u2194 s \u2264 t", "start": [147, 1], "end": [151, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Pi.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Logic/Pairwise.lean", "Mathlib/Init/CCLemmas.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Hom/GroupInstances.lean"], "premises": [{"full_name": "Set.preimage_one", "code": "@[to_additive]\ntheorem Set.preimage_one {\u03b1 \u03b2 : Type*} [One \u03b2] (s : Set \u03b2) [Decidable ((1 : \u03b2) \u2208 s)] :\n    (1 : \u03b1 \u2192 \u03b2) \u207b\u00b9' s = if (1 : \u03b2) \u2208 s then Set.univ else \u2205", "start": [45, 1], "end": [48, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.semigroup", "code": "@[to_additive]\ninstance semigroup [\u2200 i, Semigroup <| f i] : Semigroup (\u2200 i : I, f i) :=\n  { mul := (\u00b7 * \u00b7)\n    mul_assoc := by intros; ext; exact mul_assoc _ _ _ }", "start": [54, 1], "end": [58, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup [\u2200 i, CommSemigroup <| f i] : CommSemigroup (\u2200 i : I, f i) :=\n  { semigroup with\n    mul_comm := by intros; ext; exact mul_comm _ _\n  }", "start": [62, 1], "end": [67, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.mulOneClass", "code": "@[to_additive]\ninstance mulOneClass [\u2200 i, MulOneClass <| f i] : MulOneClass (\u2200 i : I, f i) :=\n  { one := (1 : \u2200 i, f i)\n    mul := (\u00b7 * \u00b7)\n    one_mul := by intros; ext; exact one_mul _\n    mul_one := by intros; ext; exact mul_one _\n  }", "start": [71, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.invOneClass", "code": "@[to_additive]\ninstance invOneClass [\u2200 i, InvOneClass <| f i] : InvOneClass (\u2200 i : I, f i) :=\n  { one := (1 : \u2200 i, f i)\n    inv := (\u00b7 \u207b\u00b9)\n    inv_one := by intros; ext; exact inv_one }", "start": [82, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.monoid", "code": "@[to_additive]\ninstance monoid [\u2200 i, Monoid <| f i] : Monoid (\u2200 i : I, f i) :=\n  { semigroup, mulOneClass with\n    npow := fun n x i => x i ^ n\n    npow_zero := by intros; ext; exact Monoid.npow_zero _\n    npow_succ := by intros; ext; exact Monoid.npow_succ _ _\n  }", "start": [88, 1], "end": [95, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.addMonoidWithOne", "code": "instance addMonoidWithOne [\u2200 i, AddMonoidWithOne <| f i] : AddMonoidWithOne (\u2200 i : I, f i) :=\n  { addMonoid with\n    natCast := fun n _ => n\n    natCast_zero := funext fun _ => AddMonoidWithOne.natCast_zero\n    natCast_succ := fun n => funext fun _ => AddMonoidWithOne.natCast_succ n\n  }", "start": [99, 1], "end": [104, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.commMonoid", "code": "@[to_additive]\ninstance commMonoid [\u2200 i, CommMonoid <| f i] : CommMonoid (\u2200 i : I, f i) :=\n  { monoid, commSemigroup with }", "start": [106, 1], "end": [108, 33], "kind": "commanddeclaration"}, {"full_name": "Pi.divInvMonoid", "code": "@[to_additive Pi.subNegMonoid]\ninstance divInvMonoid [\u2200 i, DivInvMonoid <| f i] : DivInvMonoid (\u2200 i : I, f i) :=\n  { monoid with\n    inv := Inv.inv\n    div := Div.div\n    zpow := fun z x i => x i ^ z\n    div_eq_mul_inv := by intros; ext; exact div_eq_mul_inv _ _\n    zpow_zero' := by intros; ext; exact DivInvMonoid.zpow_zero' _\n    zpow_succ' := by intros; ext; exact DivInvMonoid.zpow_succ' _ _\n    zpow_neg' := by intros; ext; exact DivInvMonoid.zpow_neg' _ _\n  }", "start": [112, 1], "end": [123, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.divInvOneMonoid", "code": "@[to_additive Pi.subNegZeroMonoid]\ninstance divInvOneMonoid [\u2200 i, DivInvOneMonoid <| f i] : DivInvOneMonoid (\u2200 i : I, f i) :=\n  { divInvMonoid with\n    inv_one := by ext; exact inv_one }", "start": [125, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "Pi.involutiveInv", "code": "@[to_additive]\ninstance involutiveInv [\u2200 i, InvolutiveInv <| f i] : InvolutiveInv (\u2200 i, f i) :=\n  { inv := Inv.inv\n    inv_inv := by intros; ext; exact inv_inv _\n  }", "start": [130, 1], "end": [135, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.divisionMonoid", "code": "@[to_additive Pi.subtractionMonoid]\ninstance divisionMonoid [\u2200 i, DivisionMonoid <| f i] : DivisionMonoid (\u2200 i, f i) :=\n  { divInvMonoid, involutiveInv with\n    mul_inv_rev := by intros; ext; exact mul_inv_rev _ _\n    inv_eq_of_mul := by\n      intros _ _ h; ext; exact DivisionMonoid.inv_eq_of_mul _ _ (congrFun h _)\n  }", "start": [137, 1], "end": [144, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.group", "code": "@[to_additive]\ninstance group [\u2200 i, Group <| f i] : Group (\u2200 i : I, f i) :=\n  { divInvMonoid with\n    mul_left_inv := by intros; ext; exact mul_left_inv _\n    }", "start": [150, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.addGroupWithOne", "code": "instance addGroupWithOne [\u2200 i, AddGroupWithOne <| f i] : AddGroupWithOne (\u2200 i : I, f i) :=\n  { addGroup, addMonoidWithOne with\n    intCast := fun z _ => z\n    intCast_ofNat := fun n => funext fun _ => AddGroupWithOne.intCast_ofNat n\n    intCast_negSucc := fun n => funext fun _ => AddGroupWithOne.intCast_negSucc n\n  }", "start": [159, 1], "end": [164, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.commGroup", "code": "@[to_additive]\ninstance commGroup [\u2200 i, CommGroup <| f i] : CommGroup (\u2200 i : I, f i) :=\n  { group, commMonoid with }", "start": [166, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.leftCancelSemigroup", "code": "@[to_additive]\ninstance leftCancelSemigroup [\u2200 i, LeftCancelSemigroup <| f i] :\n    LeftCancelSemigroup (\u2200 i : I, f i) :=\n  { semigroup with\n    mul_left_cancel := by\n      intros _ _ _ h; ext; exact LeftCancelSemigroup.mul_left_cancel _ _ _ (congr_fun h _);\n  }", "start": [172, 1], "end": [179, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.rightCancelSemigroup", "code": "@[to_additive]\ninstance rightCancelSemigroup [\u2200 i, RightCancelSemigroup <| f i] :\n    RightCancelSemigroup (\u2200 i : I, f i) :=\n  { semigroup with\n    mul_right_cancel := by\n      intros _ _ _ h; ext; exact RightCancelSemigroup.mul_right_cancel _ _ _ (congr_fun h _)\n  }", "start": [183, 1], "end": [190, 4], "kind": "commanddeclaration"}, {"full_name": "Pi.leftCancelMonoid", "code": "@[to_additive]\ninstance leftCancelMonoid [\u2200 i, LeftCancelMonoid <| f i] : LeftCancelMonoid (\u2200 i : I, f i) :=\n  { leftCancelSemigroup, monoid with }", "start": [194, 1], "end": [196, 39], "kind": "commanddeclaration"}, {"full_name": "Pi.rightCancelMonoid", "code": "@[to_additive]\ninstance rightCancelMonoid [\u2200 i, RightCancelMonoid <| f i] : RightCancelMonoid (\u2200 i : I, f i) :=\n  { rightCancelSemigroup, monoid with }", "start": [200, 1], "end": [202, 40], "kind": "commanddeclaration"}, {"full_name": "Pi.cancelMonoid", "code": "@[to_additive]\ninstance cancelMonoid [\u2200 i, CancelMonoid <| f i] : CancelMonoid (\u2200 i : I, f i) :=\n  { leftCancelMonoid, rightCancelMonoid with }", "start": [206, 1], "end": [208, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.cancelCommMonoid", "code": "@[to_additive]\ninstance cancelCommMonoid [\u2200 i, CancelCommMonoid <| f i] : CancelCommMonoid (\u2200 i : I, f i) :=\n  { leftCancelMonoid, commMonoid with }", "start": [212, 1], "end": [214, 40], "kind": "commanddeclaration"}, {"full_name": "Pi.mulZeroClass", "code": "instance mulZeroClass [\u2200 i, MulZeroClass <| f i] : MulZeroClass (\u2200 i : I, f i) :=\n  { zero := (0 : \u2200 i, f i)\n    mul := (\u00b7 * \u00b7)\n    zero_mul := by intros; ext; exact zero_mul _\n    mul_zero := by intros; ext; exact mul_zero _\n}", "start": [218, 1], "end": [224, 2], "kind": "commanddeclaration"}, {"full_name": "Pi.mulZeroOneClass", "code": "instance mulZeroOneClass [\u2200 i, MulZeroOneClass <| f i] : MulZeroOneClass (\u2200 i : I, f i) :=\n  { mulZeroClass, mulOneClass with }", "start": [227, 1], "end": [228, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.monoidWithZero", "code": "instance monoidWithZero [\u2200 i, MonoidWithZero <| f i] : MonoidWithZero (\u2200 i : I, f i) :=\n  { monoid, mulZeroClass with }", "start": [231, 1], "end": [232, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.commMonoidWithZero", "code": "instance commMonoidWithZero [\u2200 i, CommMonoidWithZero <| f i] : CommMonoidWithZero (\u2200 i : I, f i) :=\n  { monoidWithZero, commMonoid with }", "start": [235, 1], "end": [236, 38], "kind": "commanddeclaration"}, {"full_name": "Pi.semigroupWithZero", "code": "instance semigroupWithZero [\u2200 i, SemigroupWithZero <| f i] : SemigroupWithZero (\u2200 i : I, f i) :=\n  { semigroup, mulZeroClass with }", "start": [239, 1], "end": [240, 35], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_mul", "code": "@[to_additive]\ntheorem coe_mul {M N} {_ : Mul M} {_ : CommSemigroup N} (f g : M \u2192\u2099* N) : (f * g : M \u2192 N) =\n    fun x => f x * g x", "start": [247, 1], "end": [249, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulHom", "code": "@[to_additive (attr := simps)\n  \"A family of AddHom's `f a : \u03b3 \u2192 \u03b2 a` defines an AddHom `Pi.addHom f : \u03b3 \u2192 \u03a0 a, \u03b2 a` given by\n  `Pi.addHom f x b = f b x`.\"]\ndef Pi.mulHom {\u03b3 : Type w} [\u2200 i, Mul (f i)] [Mul \u03b3] (g : \u2200 i, \u03b3 \u2192\u2099* f i) : \u03b3 \u2192\u2099* \u2200 i, f i where\n  toFun x i := g i x\n  map_mul' x y := funext fun i => (g i).map_mul x y", "start": [257, 1], "end": [264, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.mulHom_injective", "code": "@[to_additive]\ntheorem Pi.mulHom_injective {\u03b3 : Type w} [Nonempty I] [\u2200 i, Mul (f i)] [Mul \u03b3] (g : \u2200 i, \u03b3 \u2192\u2099* f i)\n    (hg : \u2200 i, Function.Injective (g i)) : Function.Injective (Pi.mulHom g)", "start": [270, 1], "end": [274, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.monoidHom", "code": "@[to_additive (attr := simps)\n  \"A family of additive monoid homomorphisms `f a : \u03b3 \u2192+ \u03b2 a` defines a monoid homomorphism\n  `Pi.addMonoidHom f : \u03b3 \u2192+ \u03a0 a, \u03b2 a` given by `Pi.addMonoidHom f x b = f b x`.\"]\ndef Pi.monoidHom {\u03b3 : Type w} [\u2200 i, MulOneClass (f i)] [MulOneClass \u03b3] (g : \u2200 i, \u03b3 \u2192* f i) :\n    \u03b3 \u2192* \u2200 i, f i :=\n  { Pi.mulHom fun i => (g i).toMulHom with\n    toFun := fun x i => g i x\n    map_one' := funext fun i => (g i).map_one }", "start": [278, 1], "end": [287, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.monoidHom_injective", "code": "@[to_additive]\ntheorem Pi.monoidHom_injective {\u03b3 : Type w} [Nonempty I] [\u2200 i, MulOneClass (f i)] [MulOneClass \u03b3]\n    (g : \u2200 i, \u03b3 \u2192* f i) (hg : \u2200 i, Function.Injective (g i)) :\n    Function.Injective (Pi.monoidHom g)", "start": [293, 1], "end": [297, 51], "kind": "commanddeclaration"}, {"full_name": "Pi.evalMulHom", "code": "@[to_additive (attr := simps)\n  \"Evaluation of functions into an indexed collection of additive semigroups at a point is an\n  additive semigroup homomorphism. This is `Function.eval i` as an `AddHom`.\"]\ndef Pi.evalMulHom (i : I) : (\u2200 i, f i) \u2192\u2099* f i where\n  toFun g := g i\n  map_mul' _ _ := Pi.mul_apply _ _ i", "start": [303, 1], "end": [311, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.constMulHom", "code": "@[to_additive (attr := simps) \"`Function.const` as an `AddHom`.\"]\ndef Pi.constMulHom (\u03b1 \u03b2 : Type*) [Mul \u03b2] :\n    \u03b2 \u2192\u2099* \u03b1 \u2192 \u03b2 where\n  toFun := Function.const \u03b1\n  map_mul' _ _ := rfl", "start": [317, 1], "end": [322, 22], "kind": "commanddeclaration"}, {"full_name": "MulHom.coeFn", "code": "@[to_additive (attr := simps) \"Coercion of an `AddHom` into a function is itself an `AddHom`.\n\nSee also `AddHom.eval`.\"]\ndef MulHom.coeFn (\u03b1 \u03b2 : Type*) [Mul \u03b1] [CommSemigroup \u03b2] :\n    (\u03b1 \u2192\u2099* \u03b2) \u2192\u2099* \u03b1 \u2192 \u03b2 where\n  toFun g := g\n  map_mul' _ _ := rfl", "start": [328, 1], "end": [337, 22], "kind": "commanddeclaration"}, {"full_name": "MulHom.compLeft", "code": "@[to_additive (attr := simps) \"Additive semigroup homomorphism between the function spaces `I \u2192 \u03b1`\nand `I \u2192 \u03b2`, induced by an additive semigroup homomorphism `f` between `\u03b1` and `\u03b2`\"]\nprotected def MulHom.compLeft {\u03b1 \u03b2 : Type*} [Mul \u03b1] [Mul \u03b2] (f : \u03b1 \u2192\u2099* \u03b2) (I : Type*) :\n    (I \u2192 \u03b1) \u2192\u2099* I \u2192 \u03b2 where\n  toFun h := f \u2218 h\n  map_mul' _ _ := by ext; simp", "start": [343, 1], "end": [350, 31], "kind": "commanddeclaration"}, {"full_name": "Pi.evalMonoidHom", "code": "@[to_additive (attr := simps) \"Evaluation of functions into an indexed collection of additive\nmonoids at a point is an additive monoid homomorphism. This is `Function.eval i` as an\n`AddMonoidHom`.\"]\ndef Pi.evalMonoidHom (i : I) : (\u2200 i, f i) \u2192* f i where\n  toFun g := g i\n  map_one' := Pi.one_apply i\n  map_mul' _ _ := Pi.mul_apply _ _ i", "start": [362, 1], "end": [371, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.constMonoidHom", "code": "@[to_additive (attr := simps) \"`Function.const` as an `AddMonoidHom`.\"]\ndef Pi.constMonoidHom (\u03b1 \u03b2 : Type*) [MulOneClass \u03b2] : \u03b2 \u2192* \u03b1 \u2192 \u03b2 where\n  toFun := Function.const \u03b1\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [377, 1], "end": [382, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coeFn", "code": "@[to_additive (attr := simps) \"Coercion of an `AddMonoidHom` into a function is itself\nan `AddMonoidHom`.\n\nSee also `AddMonoidHom.eval`.\"]\ndef MonoidHom.coeFn (\u03b1 \u03b2 : Type*) [MulOneClass \u03b1] [CommMonoid \u03b2] : (\u03b1 \u2192* \u03b2) \u2192* \u03b1 \u2192 \u03b2 where\n  toFun g := g\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [388, 1], "end": [398, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.compLeft", "code": "@[to_additive (attr := simps)\n  \"Additive monoid homomorphism between the function spaces `I \u2192 \u03b1` and `I \u2192 \u03b2`, induced by an\n  additive monoid homomorphism `f` between `\u03b1` and `\u03b2`\"]\nprotected def MonoidHom.compLeft {\u03b1 \u03b2 : Type*} [MulOneClass \u03b1] [MulOneClass \u03b2] (f : \u03b1 \u2192* \u03b2)\n    (I : Type*) : (I \u2192 \u03b1) \u2192* I \u2192 \u03b2 where\n  toFun h := f \u2218 h\n  map_one' := by ext; dsimp; simp\n  map_mul' _ _ := by ext; simp", "start": [404, 1], "end": [413, 31], "kind": "commanddeclaration"}, {"full_name": "OneHom.single", "code": "@[to_additive\n      \"The zero-preserving homomorphism including a single value into a dependent family of values,\n      as functions supported at a point.\n\n      This is the `ZeroHom` version of `Pi.single`.\"]\ndef OneHom.single [\u2200 i, One <| f i] (i : I) : OneHom (f i) (\u2200 i, f i) where\n  toFun := mulSingle i\n  map_one' := mulSingle_one i", "start": [429, 1], "end": [440, 30], "kind": "commanddeclaration"}, {"full_name": "OneHom.single_apply", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.single_apply [\u2200 i, One <| f i] (i : I) (x : f i) :\n    OneHom.single f i x = mulSingle i x", "start": [444, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.single", "code": "@[to_additive\n      \"The additive monoid homomorphism including a single additive monoid into a dependent family\n      of additive monoids, as functions supported at a point.\n\n      This is the `AddMonoidHom` version of `Pi.single`.\"]\ndef MonoidHom.single [\u2200 i, MulOneClass <| f i] (i : I) : f i \u2192* \u2200 i, f i :=\n  { OneHom.single f i with map_mul' := mulSingle_op\u2082 (fun _ => (\u00b7 * \u00b7)) (fun _ => one_mul _) _ }", "start": [451, 1], "end": [461, 97], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.single_apply", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.single_apply [\u2200 i, MulOneClass <| f i] (i : I) (x : f i) :\n    MonoidHom.single f i x = mulSingle i x", "start": [465, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.single", "code": "@[simps]\ndef MulHom.single [\u2200 i, MulZeroClass <| f i] (i : I) : f i \u2192\u2099* \u2200 i, f i where\n  toFun := Pi.single i\n  map_mul' := Pi.single_op\u2082 (fun _ => (\u00b7 * \u00b7)) (fun _ => zero_mul _) _", "start": [472, 1], "end": [479, 71], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_sup", "code": "@[to_additive]\ntheorem Pi.mulSingle_sup [\u2200 i, SemilatticeSup (f i)] [\u2200 i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x \u2294 y) = Pi.mulSingle i x \u2294 Pi.mulSingle i y", "start": [485, 1], "end": [488, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_inf", "code": "@[to_additive]\ntheorem Pi.mulSingle_inf [\u2200 i, SemilatticeInf (f i)] [\u2200 i, One (f i)] (i : I) (x y : f i) :\n    Pi.mulSingle i (x \u2293 y) = Pi.mulSingle i x \u2293 Pi.mulSingle i y", "start": [492, 1], "end": [495, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_mul", "code": "@[to_additive]\ntheorem Pi.mulSingle_mul [\u2200 i, MulOneClass <| f i] (i : I) (x y : f i) :\n    mulSingle i (x * y) = mulSingle i x * mulSingle i y", "start": [499, 1], "end": [502, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_inv", "code": "@[to_additive]\ntheorem Pi.mulSingle_inv [\u2200 i, Group <| f i] (i : I) (x : f i) :\n    mulSingle i x\u207b\u00b9 = (mulSingle i x)\u207b\u00b9", "start": [506, 1], "end": [509, 35], "kind": "commanddeclaration"}, {"full_name": "Pi.single_div", "code": "@[to_additive]\ntheorem Pi.single_div [\u2200 i, Group <| f i] (i : I) (x y : f i) :\n    mulSingle i (x / y) = mulSingle i x / mulSingle i y", "start": [513, 1], "end": [516, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.single_mul", "code": "theorem Pi.single_mul [\u2200 i, MulZeroClass <| f i] (i : I) (x y : f i) :\n    single i (x * y) = single i x * single i y", "start": [520, 1], "end": [522, 34], "kind": "commanddeclaration"}, {"full_name": "Pi.single_mul_left_apply", "code": "theorem Pi.single_mul_left_apply [\u2200 i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (a * x i) j = Pi.single i a j * x j", "start": [525, 1], "end": [527, 74], "kind": "commanddeclaration"}, {"full_name": "Pi.single_mul_right_apply", "code": "theorem Pi.single_mul_right_apply [\u2200 i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (x i * a) j = x j * Pi.single i a j", "start": [530, 1], "end": [532, 78], "kind": "commanddeclaration"}, {"full_name": "Pi.single_mul_left", "code": "theorem Pi.single_mul_left [\u2200 i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (a * x i) = Pi.single i a * x", "start": [535, 1], "end": [537, 51], "kind": "commanddeclaration"}, {"full_name": "Pi.single_mul_right", "code": "theorem Pi.single_mul_right [\u2200 i, MulZeroClass <| f i] (a : f i) :\n    Pi.single i (x i * a) = x * Pi.single i a", "start": [540, 1], "end": [542, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_commute", "code": "@[to_additive\n      \"The injection into an additive pi group at different indices commutes.\n\n      For injections of commuting elements at the same index, see `AddCommute.map`\"]\ntheorem Pi.mulSingle_commute [\u2200 i, MulOneClass <| f i] :\n    Pairwise fun i j => \u2200 (x : f i) (y : f j), Commute (mulSingle i x) (mulSingle j y)", "start": [545, 1], "end": [561, 16], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_apply_commute", "code": "@[to_additive \"The injection into an additive pi group with the same values commutes.\"]\ntheorem Pi.mulSingle_apply_commute [\u2200 i, MulOneClass <| f i] (x : \u2200 i, f i) (i j : I) :\n    Commute (mulSingle i (x i)) (mulSingle j (x j))", "start": [565, 1], "end": [571, 39], "kind": "commanddeclaration"}, {"full_name": "Pi.update_eq_div_mul_mulSingle", "code": "@[to_additive]\ntheorem Pi.update_eq_div_mul_mulSingle [\u2200 i, Group <| f i] (g : \u2200 i : I, f i) (x : f i) :\n    Function.update g i x = g / mulSingle i (g i) * mulSingle i x", "start": [575, 1], "end": [581, 43], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle", "code": "@[to_additive]\ntheorem Pi.mulSingle_mul_mulSingle_eq_mulSingle_mul_mulSingle {M : Type*} [CommMonoid M]\n    {k l m n : I} {u v : M} (hu : u \u2260 1) (hv : v \u2260 1) :\n    (mulSingle k u : I \u2192 M) * mulSingle l v = mulSingle m u * mulSingle n v \u2194\n      k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u * v = 1 \u2227 k = l \u2227 m = n", "start": [585, 1], "end": [616, 53], "kind": "commanddeclaration"}, {"full_name": "Function.update_one", "code": "@[to_additive (attr := simp)]\ntheorem update_one [\u2200 i, One (f i)] [DecidableEq I] (i : I) : update (1 : \u2200 i, f i) i 1 = 1", "start": [624, 1], "end": [626, 39], "kind": "commanddeclaration"}, {"full_name": "Function.update_mul", "code": "@[to_additive]\ntheorem update_mul [\u2200 i, Mul (f i)] [DecidableEq I] (f\u2081 f\u2082 : \u2200 i, f i) (i : I) (x\u2081 : f i)\n    (x\u2082 : f i) : update (f\u2081 * f\u2082) i (x\u2081 * x\u2082) = update f\u2081 i x\u2081 * update f\u2082 i x\u2082", "start": [630, 1], "end": [633, 74], "kind": "commanddeclaration"}, {"full_name": "Function.update_inv", "code": "@[to_additive]\ntheorem update_inv [\u2200 i, Inv (f i)] [DecidableEq I] (f\u2081 : \u2200 i, f i) (i : I) (x\u2081 : f i) :\n    update f\u2081\u207b\u00b9 i x\u2081\u207b\u00b9 = (update f\u2081 i x\u2081)\u207b\u00b9", "start": [637, 1], "end": [640, 67], "kind": "commanddeclaration"}, {"full_name": "Function.update_div", "code": "@[to_additive]\ntheorem update_div [\u2200 i, Div (f i)] [DecidableEq I] (f\u2081 f\u2082 : \u2200 i, f i) (i : I) (x\u2081 : f i)\n    (x\u2082 : f i) : update (f\u2081 / f\u2082) i (x\u2081 / x\u2082) = update f\u2081 i x\u2081 / update f\u2082 i x\u2082", "start": [644, 1], "end": [647, 74], "kind": "commanddeclaration"}, {"full_name": "Function.const_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem const_eq_one : const \u03b9 a = 1 \u2194 a = 1", "start": [653, 1], "end": [655, 23], "kind": "commanddeclaration"}, {"full_name": "Function.const_ne_one", "code": "@[to_additive]\ntheorem const_ne_one : const \u03b9 a \u2260 1 \u2194 a \u2260 1", "start": [659, 1], "end": [661, 23], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_mul", "code": "@[to_additive]\ntheorem Set.piecewise_mul [\u2200 i, Mul (f i)] (s : Set I) [\u2200 i, Decidable (i \u2208 s)]\n    (f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, f i) :\n    s.piecewise (f\u2081 * f\u2082) (g\u2081 * g\u2082) = s.piecewise f\u2081 g\u2081 * s.piecewise f\u2082 g\u2082", "start": [669, 1], "end": [673, 44], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_inv", "code": "@[to_additive]\ntheorem Set.piecewise_inv [\u2200 i, Inv (f i)] (s : Set I) [\u2200 i, Decidable (i \u2208 s)] (f\u2081 g\u2081 : \u2200 i, f i) :\n    s.piecewise f\u2081\u207b\u00b9 g\u2081\u207b\u00b9 = (s.piecewise f\u2081 g\u2081)\u207b\u00b9", "start": [677, 1], "end": [680, 38], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_div", "code": "@[to_additive]\ntheorem Set.piecewise_div [\u2200 i, Div (f i)] (s : Set I) [\u2200 i, Decidable (i \u2208 s)]\n    (f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, f i) :\n    s.piecewise (f\u2081 / f\u2082) (g\u2081 / g\u2082) = s.piecewise f\u2081 g\u2081 / s.piecewise f\u2082 g\u2082", "start": [684, 1], "end": [688, 44], "kind": "commanddeclaration"}, {"full_name": "Function.ExtendByOne.hom", "code": "@[to_additive (attr := simps) Function.ExtendByZero.hom \"`Function.extend s f 0` as a bundled hom.\"]\nnoncomputable def Function.ExtendByOne.hom [MulOneClass R] :\n    (\u03b9 \u2192 R) \u2192* \u03b7 \u2192 R where\n  toFun f := Function.extend s f 1\n  map_one' := Function.extend_one s\n  map_mul' f g := by simpa using Function.extend_mul s f g 1 1", "start": [698, 1], "end": [704, 63], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_mono", "code": "@[to_additive]\ntheorem mulSingle_mono : Monotone (Pi.mulSingle i : f i \u2192 \u2200 i, f i)", "start": [716, 1], "end": [718, 23], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_strictMono", "code": "@[to_additive]\ntheorem mulSingle_strictMono : StrictMono (Pi.mulSingle i : f i \u2192 \u2200 i, f i)", "start": [722, 1], "end": [724, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/WellFounded.lean", "imports": ["Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WellFounded.isAsymm", "code": "protected theorem isAsymm (h : WellFounded r) : IsAsymm \u03b1 r", "start": [31, 1], "end": [31, 78], "kind": "commanddeclaration"}, {"full_name": "WellFounded.isIrrefl", "code": "protected theorem isIrrefl (h : WellFounded r) : IsIrrefl \u03b1 r", "start": [34, 1], "end": [34, 97], "kind": "commanddeclaration"}, {"full_name": "WellFounded.mono", "code": "theorem mono (hr : WellFounded r) (h : \u2200 a b, r' a b \u2192 r a b) : WellFounded r'", "start": [42, 1], "end": [43, 28], "kind": "commanddeclaration"}, {"full_name": "WellFounded.onFun", "code": "theorem onFun {\u03b1 \u03b2 : Sort*} {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} :\n    WellFounded r \u2192 WellFounded (r on f)", "start": [46, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "WellFounded.has_min", "code": "theorem has_min {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : WellFounded r) (s : Set \u03b1) :\n    s.Nonempty \u2192 \u2203 a \u2208 s, \u2200 x \u2208 s, \u00acr x a", "start": [51, 1], "end": [58, 9], "kind": "commanddeclaration"}, {"full_name": "WellFounded.min", "code": "noncomputable def min {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : WellFounded r) (s : Set \u03b1) (h : s.Nonempty) : \u03b1 :=\n  Classical.choose (H.has_min s h)", "start": [61, 1], "end": [67, 35], "kind": "commanddeclaration"}, {"full_name": "WellFounded.min_mem", "code": "theorem min_mem {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : WellFounded r) (s : Set \u03b1) (h : s.Nonempty) :\n    H.min s h \u2208 s", "start": [70, 1], "end": [73, 4], "kind": "commanddeclaration"}, {"full_name": "WellFounded.not_lt_min", "code": "theorem not_lt_min {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : WellFounded r) (s : Set \u03b1) (h : s.Nonempty) {x}\n    (hx : x \u2208 s) : \u00acr x (H.min s h)", "start": [76, 1], "end": [79, 10], "kind": "commanddeclaration"}, {"full_name": "WellFounded.wellFounded_iff_has_min", "code": "theorem wellFounded_iff_has_min {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    WellFounded r \u2194 \u2200 s : Set \u03b1, s.Nonempty \u2192 \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acr x m", "start": [82, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "WellFounded.sup", "code": "protected noncomputable def sup {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : WellFounded r) (s : Set \u03b1)\n    (h : Bounded r s) : \u03b1 :=\n  wf.min { x | \u2200 a \u2208 s, r a x } h", "start": [94, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "WellFounded.lt_sup", "code": "protected theorem lt_sup {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : WellFounded r) {s : Set \u03b1} (h : Bounded r s) {x}\n    (hx : x \u2208 s) : r x (wf.sup s h)", "start": [100, 1], "end": [102, 43], "kind": "commanddeclaration"}, {"full_name": "WellFounded.succ", "code": "protected noncomputable def succ {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : WellFounded r) (x : \u03b1) : \u03b1 :=\n  if h : \u2203 y, r x y then wf.min { y | r x y } h else x", "start": [109, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "WellFounded.lt_succ", "code": "protected theorem lt_succ {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (wf : WellFounded r) {x : \u03b1} (h : \u2203 y, r x y) :\n    r x (wf.succ x)", "start": [115, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "WellFounded.lt_succ_iff", "code": "protected theorem lt_succ_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [wo : IsWellOrder \u03b1 r] {x : \u03b1} (h : \u2203 y, r x y)\n    (y : \u03b1) : r y (wo.wf.succ x) \u2194 r y x \u2228 y = x", "start": [123, 1], "end": [138, 84], "kind": "commanddeclaration"}, {"full_name": "WellFounded.min_le", "code": "theorem min_le {x : \u03b2} {s : Set \u03b2} (hx : x \u2208 s) (hne : s.Nonempty := \u27e8x, hx\u27e9) : h.min s hne \u2264 x", "start": [145, 1], "end": [146, 34], "kind": "commanddeclaration"}, {"full_name": "WellFounded.eq_strictMono_iff_eq_range_aux", "code": "private theorem eq_strictMono_iff_eq_range_aux {f g : \u03b2 \u2192 \u03b3} (hf : StrictMono f)\n    (hg : StrictMono g) (hfg : Set.range f = Set.range g) {b : \u03b2} (H : \u2200 a < b, f a = g a) :\n    f b \u2264 g b", "start": [149, 1], "end": [160, 26], "kind": "commanddeclaration"}, {"full_name": "WellFounded.eq_strictMono_iff_eq_range", "code": "theorem eq_strictMono_iff_eq_range {f g : \u03b2 \u2192 \u03b3} (hf : StrictMono f) (hg : StrictMono g) :\n    Set.range f = Set.range g \u2194 f = g", "start": [162, 1], "end": [170, 17], "kind": "commanddeclaration"}, {"full_name": "WellFounded.self_le_of_strictMono", "code": "theorem self_le_of_strictMono {f : \u03b2 \u2192 \u03b2} (hf : StrictMono f) : \u2200 n, n \u2264 f n", "start": [173, 1], "end": [176, 37], "kind": "commanddeclaration"}, {"full_name": "Function.argmin", "code": "noncomputable def argmin [Nonempty \u03b1] : \u03b1 :=\n  WellFounded.min (InvImage.wf f h) Set.univ Set.univ_nonempty", "start": [191, 1], "end": [194, 63], "kind": "commanddeclaration"}, {"full_name": "Function.not_lt_argmin", "code": "theorem not_lt_argmin [Nonempty \u03b1] (a : \u03b1) : \u00acf a < f (argmin f h)", "start": [197, 1], "end": [198, 64], "kind": "commanddeclaration"}, {"full_name": "Function.argminOn", "code": "noncomputable def argminOn (s : Set \u03b1) (hs : s.Nonempty) : \u03b1 :=\n  WellFounded.min (InvImage.wf f h) s hs", "start": [201, 1], "end": [205, 41], "kind": "commanddeclaration"}, {"full_name": "Function.argminOn_mem", "code": "@[simp]\ntheorem argminOn_mem (s : Set \u03b1) (hs : s.Nonempty) : argminOn f h s hs \u2208 s", "start": [208, 1], "end": [210, 28], "kind": "commanddeclaration"}, {"full_name": "Function.not_lt_argminOn", "code": "theorem not_lt_argminOn (s : Set \u03b1) {a : \u03b1} (ha : a \u2208 s)\n    (hs : s.Nonempty := Set.nonempty_of_mem ha) : \u00acf a < f (argminOn f h s hs)", "start": [214, 1], "end": [216, 51], "kind": "commanddeclaration"}, {"full_name": "Function.argmin_le", "code": "theorem argmin_le (a : \u03b1) [Nonempty \u03b1] : f (argmin f h) \u2264 f a", "start": [226, 1], "end": [227, 35], "kind": "commanddeclaration"}, {"full_name": "Function.argminOn_le", "code": "theorem argminOn_le (s : Set \u03b1) {a : \u03b1} (ha : a \u2208 s) (hs : s.Nonempty := Set.nonempty_of_mem ha) :\n    f (argminOn f h s hs) \u2264 f a", "start": [231, 1], "end": [233, 43], "kind": "commanddeclaration"}, {"full_name": "Acc.induction_bot'", "code": "theorem Acc.induction_bot' {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a bot : \u03b1} (ha : Acc r a) {C : \u03b2 \u2192 Prop}\n    {f : \u03b1 \u2192 \u03b2} (ih : \u2200 b, f b \u2260 f bot \u2192 C (f b) \u2192 \u2203 c, r c b \u2227 C (f c)) : C (f a) \u2192 C (f bot)", "start": [242, 1], "end": [252, 21], "kind": "commanddeclaration"}, {"full_name": "Acc.induction_bot", "code": "theorem Acc.induction_bot {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a bot : \u03b1} (ha : Acc r a) {C : \u03b1 \u2192 Prop}\n    (ih : \u2200 b, b \u2260 bot \u2192 C b \u2192 \u2203 c, r c b \u2227 C c) : C a \u2192 C bot", "start": [255, 1], "end": [261, 23], "kind": "commanddeclaration"}, {"full_name": "WellFounded.induction_bot'", "code": "theorem WellFounded.induction_bot' {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hwf : WellFounded r) {a bot : \u03b1}\n    {C : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (ih : \u2200 b, f b \u2260 f bot \u2192 C (f b) \u2192 \u2203 c, r c b \u2227 C (f c)) :\n    C (f a) \u2192 C (f bot)", "start": [264, 1], "end": [273, 34], "kind": "commanddeclaration"}, {"full_name": "WellFounded.induction_bot", "code": "theorem WellFounded.induction_bot {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hwf : WellFounded r) {a bot : \u03b1}\n    {C : \u03b1 \u2192 Prop} (ih : \u2200 b, b \u2260 bot \u2192 C b \u2192 \u2203 c, r c b \u2227 C c) : C a \u2192 C bot", "start": [276, 1], "end": [285, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Ring/Basic.lean", "imports": ["Mathlib/Data/Set/Image.lean", "Mathlib/Algebra/GroupWithZero/InjSurj.lean", "Mathlib/Algebra/Hom/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "RingHom.codomain_trivial_iff_range_eq_singleton_zero", "code": "theorem codomain_trivial_iff_range_eq_singleton_zero : (0 : \u03b2) = 1 \u2194 Set.range f = {0}", "start": [34, 1], "end": [39, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.isUnit_map", "code": "theorem isUnit_map (f : \u03b1 \u2192+* \u03b2) {a : \u03b1} : IsUnit a \u2192 IsUnit (f a)", "start": [48, 1], "end": [49, 15], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_dvd", "code": "protected theorem map_dvd (f : \u03b1 \u2192+* \u03b2) {a b : \u03b1} : a \u2223 b \u2192 f a \u2223 f b", "start": [52, 1], "end": [53, 12], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.isDomain", "code": "protected theorem Function.Injective.isDomain [Ring \u03b1] [IsDomain \u03b1] [Ring \u03b2] (f : \u03b2 \u2192+* \u03b1)\n    (hf : Injective f) : IsDomain \u03b2", "start": [60, 1], "end": [66, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Order.lean", "imports": ["Mathlib/Data/Nat/Cast/NeZero.lean", "Mathlib/Algebra/CharZero/Defs.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "Nat.mono_cast", "code": "@[mono]\ntheorem mono_cast : Monotone (Nat.cast : \u2115 \u2192 \u03b1)", "start": [31, 1], "end": [34, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_nonneg'", "code": "@[simp low]\ntheorem cast_nonneg' (n : \u2115) : 0 \u2264 (n : \u03b1)", "start": [38, 1], "end": [40, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_nonneg", "code": "@[simp]\ntheorem cast_nonneg {\u03b1} [OrderedSemiring \u03b1] (n : \u2115) : 0 \u2264 (n : \u03b1)", "start": [43, 1], "end": [45, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_min", "code": "@[simp, norm_cast]\ntheorem cast_min {\u03b1} [LinearOrderedSemiring \u03b1] {a b : \u2115} : ((min a b : \u2115) : \u03b1) = min (a : \u03b1) b", "start": [48, 1], "end": [50, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_max", "code": "@[simp, norm_cast]\ntheorem cast_max {\u03b1} [LinearOrderedSemiring \u03b1] {a b : \u2115} : ((max a b : \u2115) : \u03b1) = max (a : \u03b1) b", "start": [53, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_add_one_pos", "code": "theorem cast_add_one_pos (n : \u2115) : 0 < (n : \u03b1) + 1", "start": [62, 1], "end": [63, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_pos'", "code": "@[simp low]\ntheorem cast_pos' {n : \u2115} : (0 : \u03b1) < n \u2194 0 < n", "start": [67, 1], "end": [68, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_pos", "code": "@[simp]\ntheorem cast_pos {\u03b1} [OrderedSemiring \u03b1] [Nontrivial \u03b1] {n : \u2115} : (0 : \u03b1) < n \u2194 0 < n", "start": [71, 1], "end": [72, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.strictMono_cast", "code": "theorem strictMono_cast : StrictMono (Nat.cast : \u2115 \u2192 \u03b1)", "start": [79, 1], "end": [80, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.castOrderEmbedding", "code": "@[simps! (config := { fullyApplied := false })]\ndef castOrderEmbedding : \u2115 \u21aao \u03b1 :=\n  OrderEmbedding.ofStrictMono Nat.cast Nat.strictMono_cast", "start": [83, 1], "end": [86, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_le", "code": "@[simp, norm_cast]\ntheorem cast_le : (m : \u03b1) \u2264 n \u2194 m \u2264 n", "start": [90, 1], "end": [92, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_lt", "code": "@[simp, norm_cast, mono]\ntheorem cast_lt : (m : \u03b1) < n \u2194 m < n", "start": [95, 1], "end": [97, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_cast", "code": "@[simp, norm_cast]\ntheorem one_lt_cast : 1 < (n : \u03b1) \u2194 1 < n", "start": [100, 1], "end": [101, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_cast", "code": "@[simp, norm_cast]\ntheorem one_le_cast : 1 \u2264 (n : \u03b1) \u2194 1 \u2264 n", "start": [104, 1], "end": [105, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_lt_one", "code": "@[simp, norm_cast]\ntheorem cast_lt_one : (n : \u03b1) < 1 \u2194 n = 0", "start": [108, 1], "end": [110, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_le_one", "code": "@[simp, norm_cast]\ntheorem cast_le_one : (n : \u03b1) \u2264 1 \u2194 n \u2264 1", "start": [113, 1], "end": [114, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_tsub", "code": "@[simp, norm_cast]\ntheorem cast_tsub [CanonicallyOrderedCommSemiring \u03b1] [Sub \u03b1] [OrderedSub \u03b1]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (m n : \u2115) : \u2191(m - n) = (m - n : \u03b1)", "start": [119, 1], "end": [128, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.abs_cast", "code": "@[simp, norm_cast]\ntheorem abs_cast [LinearOrderedRing \u03b1] (a : \u2115) : |(a : \u03b1)| = a", "start": [131, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "NeZero.nat_of_injective", "code": "theorem NeZero.nat_of_injective {n : \u2115} [h : NeZero (n : R)] [RingHomClass F R S] {f : F}\n    (hf : Function.Injective f) : NeZero (n : S)", "start": [145, 1], "end": [147, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Commute.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Commute.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Algebra/Ring/Commute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.cast_commute", "code": "theorem cast_commute [NonAssocSemiring \u03b1] (n : \u2115) (x : \u03b1) : Commute (n : \u03b1) x", "start": [23, 1], "end": [26, 78], "kind": "commanddeclaration"}, {"full_name": "Commute.ofNat_left", "code": "theorem _root_.Commute.ofNat_left [NonAssocSemiring \u03b1] (n : \u2115) [n.AtLeastTwo] (x : \u03b1) :\n    Commute (OfNat.ofNat n) x", "start": [29, 1], "end": [31, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_comm", "code": "theorem cast_comm [NonAssocSemiring \u03b1] (n : \u2115) (x : \u03b1) : (n : \u03b1) * x = x * n", "start": [33, 1], "end": [34, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.commute_cast", "code": "theorem commute_cast [NonAssocSemiring \u03b1] (x : \u03b1) (n : \u2115) : Commute x n", "start": [37, 1], "end": [38, 26], "kind": "commanddeclaration"}, {"full_name": "Commute.ofNat_right", "code": "theorem _root_.Commute.ofNat_right [NonAssocSemiring \u03b1] (x : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    Commute x (OfNat.ofNat n)", "start": [41, 1], "end": [43, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "imports": ["Mathlib/Algebra/Hom/Group/Basic.lean", "Mathlib/Algebra/Hom/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupWithZero/Commute.lean", "Mathlib/GroupTheory/GroupAction/Units.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean"], "premises": [{"full_name": "div_self", "code": "@[simp]\ntheorem div_self (h : a \u2260 0) : a / a = 1", "start": [28, 1], "end": [30, 27], "kind": "commanddeclaration"}, {"full_name": "eq_mul_inv_iff_mul_eq\u2080", "code": "theorem eq_mul_inv_iff_mul_eq\u2080 (hc : c \u2260 0) : a = b * c\u207b\u00b9 \u2194 a * c = b", "start": [33, 1], "end": [34, 41], "kind": "commanddeclaration"}, {"full_name": "eq_inv_mul_iff_mul_eq\u2080", "code": "theorem eq_inv_mul_iff_mul_eq\u2080 (hb : b \u2260 0) : a = b\u207b\u00b9 * c \u2194 b * a = c", "start": [37, 1], "end": [38, 41], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_iff_eq_mul\u2080", "code": "theorem inv_mul_eq_iff_eq_mul\u2080 (ha : a \u2260 0) : a\u207b\u00b9 * b = c \u2194 b = a * c", "start": [41, 1], "end": [42, 41], "kind": "commanddeclaration"}, {"full_name": "mul_inv_eq_iff_eq_mul\u2080", "code": "theorem mul_inv_eq_iff_eq_mul\u2080 (hb : b \u2260 0) : a * b\u207b\u00b9 = c \u2194 a = c * b", "start": [45, 1], "end": [46, 41], "kind": "commanddeclaration"}, {"full_name": "mul_inv_eq_one\u2080", "code": "theorem mul_inv_eq_one\u2080 (hb : b \u2260 0) : a * b\u207b\u00b9 = 1 \u2194 a = b", "start": [49, 1], "end": [50, 34], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_one\u2080", "code": "theorem inv_mul_eq_one\u2080 (ha : a \u2260 0) : a\u207b\u00b9 * b = 1 \u2194 a = b", "start": [53, 1], "end": [54, 34], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff_eq_inv\u2080", "code": "theorem mul_eq_one_iff_eq_inv\u2080 (hb : b \u2260 0) : a * b = 1 \u2194 a = b\u207b\u00b9", "start": [57, 1], "end": [58, 41], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff_inv_eq\u2080", "code": "theorem mul_eq_one_iff_inv_eq\u2080 (ha : a \u2260 0) : a * b = 1 \u2194 a\u207b\u00b9 = b", "start": [61, 1], "end": [62, 41], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel", "code": "@[simp]\ntheorem div_mul_cancel (a : G\u2080) (h : b \u2260 0) : a / b * b = a", "start": [65, 1], "end": [67, 35], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel", "code": "@[simp]\ntheorem mul_div_cancel (a : G\u2080) (h : b \u2260 0) : a * b / b = a", "start": [70, 1], "end": [72, 35], "kind": "commanddeclaration"}, {"full_name": "mul_one_div_cancel", "code": "theorem mul_one_div_cancel (h : a \u2260 0) : a * (1 / a) = 1", "start": [75, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "one_div_mul_cancel", "code": "theorem one_div_mul_cancel (h : a \u2260 0) : 1 / a * a = 1", "start": [79, 1], "end": [80, 37], "kind": "commanddeclaration"}, {"full_name": "div_left_inj'", "code": "theorem div_left_inj' (hc : c \u2260 0) : a / c = b / c \u2194 a = b", "start": [83, 1], "end": [84, 32], "kind": "commanddeclaration"}, {"full_name": "div_eq_iff", "code": "@[field_simps]\ntheorem div_eq_iff (hb : b \u2260 0) : a / b = c \u2194 a = c * b", "start": [87, 1], "end": [89, 30], "kind": "commanddeclaration"}, {"full_name": "eq_div_iff", "code": "@[field_simps]\ntheorem eq_div_iff (hb : b \u2260 0) : c = a / b \u2194 c * b = a", "start": [92, 1], "end": [94, 30], "kind": "commanddeclaration"}, {"full_name": "div_eq_iff_mul_eq", "code": "theorem div_eq_iff_mul_eq (hb : b \u2260 0) : a / b = c \u2194 c * b = a", "start": [97, 1], "end": [98, 46], "kind": "commanddeclaration"}, {"full_name": "eq_div_iff_mul_eq", "code": "theorem eq_div_iff_mul_eq (hc : c \u2260 0) : a = b / c \u2194 a * c = b", "start": [101, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "div_eq_of_eq_mul", "code": "theorem div_eq_of_eq_mul (hb : b \u2260 0) : a = c * b \u2192 a / b = c", "start": [105, 1], "end": [106, 36], "kind": "commanddeclaration"}, {"full_name": "eq_div_of_mul_eq", "code": "theorem eq_div_of_mul_eq (hc : c \u2260 0) : a * c = b \u2192 a = b / c", "start": [109, 1], "end": [110, 36], "kind": "commanddeclaration"}, {"full_name": "div_eq_one_iff_eq", "code": "theorem div_eq_one_iff_eq (hb : b \u2260 0) : a / b = 1 \u2194 a = b", "start": [113, 1], "end": [114, 37], "kind": "commanddeclaration"}, {"full_name": "div_mul_left", "code": "theorem div_mul_left (hb : b \u2260 0) : b / (a * b) = 1 / a", "start": [117, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "mul_div_mul_right", "code": "theorem mul_div_mul_right (a b : G\u2080) (hc : c \u2260 0) : a * c / (b * c) = a / b", "start": [121, 1], "end": [122, 41], "kind": "commanddeclaration"}, {"full_name": "mul_mul_div", "code": "theorem mul_mul_div (a : G\u2080) (hb : b \u2260 0) : a = a * b * (1 / b)", "start": [125, 1], "end": [126, 40], "kind": "commanddeclaration"}, {"full_name": "div_div_div_cancel_right", "code": "theorem div_div_div_cancel_right (a : G\u2080) (hc : c \u2260 0) : a / c / (b / c) = a / b", "start": [129, 1], "end": [130, 47], "kind": "commanddeclaration"}, {"full_name": "div_mul_div_cancel", "code": "theorem div_mul_div_cancel (a : G\u2080) (hc : c \u2260 0) : a / c * (c / b) = a / b", "start": [133, 1], "end": [134, 44], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel_of_imp", "code": "theorem div_mul_cancel_of_imp {a b : G\u2080} (h : b = 0 \u2192 a = 0) : a / b * b = a", "start": [137, 1], "end": [138, 72], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel_of_imp", "code": "theorem mul_div_cancel_of_imp {a b : G\u2080} (h : b = 0 \u2192 a = 0) : a * b / b = a", "start": [141, 1], "end": [142, 72], "kind": "commanddeclaration"}, {"full_name": "divp_mk0", "code": "@[simp]\ntheorem divp_mk0 (a : G\u2080) {b : G\u2080} (hb : b \u2260 0) : a /\u209a Units.mk0 b hb = a / b", "start": [145, 1], "end": [147, 18], "kind": "commanddeclaration"}, {"full_name": "div_mul_right", "code": "theorem div_mul_right (b : G\u2080) (ha : a \u2260 0) : a / (a * b) = 1 / b", "start": [157, 1], "end": [158, 35], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel_left_of_imp", "code": "theorem mul_div_cancel_left_of_imp {a b : G\u2080} (h : a = 0 \u2192 b = 0) : a * b / a = b", "start": [161, 1], "end": [162, 41], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel_left", "code": "theorem mul_div_cancel_left (b : G\u2080) (ha : a \u2260 0) : a * b / a = b", "start": [165, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel_of_imp'", "code": "theorem mul_div_cancel_of_imp' {a b : G\u2080} (h : b = 0 \u2192 a = 0) : b * (a / b) = a", "start": [169, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel'", "code": "theorem mul_div_cancel' (a : G\u2080) (hb : b \u2260 0) : b * (a / b) = a", "start": [173, 1], "end": [174, 37], "kind": "commanddeclaration"}, {"full_name": "mul_div_mul_left", "code": "theorem mul_div_mul_left (a b : G\u2080) (hc : c \u2260 0) : c * a / (c * b) = a / b", "start": [177, 1], "end": [178, 40], "kind": "commanddeclaration"}, {"full_name": "mul_eq_mul_of_div_eq_div", "code": "theorem mul_eq_mul_of_div_eq_div (a : G\u2080) {b : G\u2080} (c : G\u2080) {d : G\u2080} (hb : b \u2260 0) (hd : d \u2260 0)\n    (h : a / b = c / d) : a * d = c * b", "start": [181, 1], "end": [183, 94], "kind": "commanddeclaration"}, {"full_name": "div_eq_div_iff", "code": "@[field_simps]\ntheorem div_eq_div_iff (hb : b \u2260 0) (hd : d \u2260 0) : a / b = c / d \u2194 a * d = c * b", "start": [186, 1], "end": [188, 44], "kind": "commanddeclaration"}, {"full_name": "div_div_cancel'", "code": "theorem div_div_cancel' (ha : a \u2260 0) : a / (a / b) = b", "start": [191, 1], "end": [192, 34], "kind": "commanddeclaration"}, {"full_name": "div_div_cancel_left'", "code": "theorem div_div_cancel_left' (ha : a \u2260 0) : a / b / a = b\u207b\u00b9", "start": [195, 1], "end": [196, 32], "kind": "commanddeclaration"}, {"full_name": "div_helper", "code": "theorem div_helper (b : G\u2080) (h : a \u2260 0) : 1 / (a * b) * a = 1 / b", "start": [199, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "div_div_div_cancel_left'", "code": "theorem div_div_div_cancel_left' (a b : G\u2080) (hc : c \u2260 0) : c / a / (c / b) = b / a", "start": [203, 1], "end": [204, 58], "kind": "commanddeclaration"}, {"full_name": "map_ne_zero", "code": "theorem map_ne_zero : f a \u2260 0 \u2194 a \u2260 0", "start": [214, 1], "end": [215, 91], "kind": "commanddeclaration"}, {"full_name": "map_eq_zero", "code": "@[simp]\ntheorem map_eq_zero : f a = 0 \u2194 a = 0", "start": [218, 1], "end": [220, 32], "kind": "commanddeclaration"}, {"full_name": "eq_on_inv\u2080", "code": "theorem eq_on_inv\u2080 (f g : F') (h : f a = g a) : f a\u207b\u00b9 = g a\u207b\u00b9", "start": [224, 1], "end": [227, 44], "kind": "commanddeclaration"}, {"full_name": "map_inv\u2080", "code": "@[simp]\ntheorem map_inv\u2080 : f a\u207b\u00b9 = (f a)\u207b\u00b9", "start": [236, 1], "end": [242, 46], "kind": "commanddeclaration"}, {"full_name": "map_div\u2080", "code": "@[simp]\ntheorem map_div\u2080 : f (a / b) = f a / f b", "start": [245, 1], "end": [247, 30], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero.inverse", "code": "noncomputable def MonoidWithZero.inverse {M : Type*} [CommMonoidWithZero M] :\n    M \u2192*\u2080 M where\n  toFun := Ring.inverse\n  map_zero' := Ring.inverse_zero _\n  map_one' := Ring.inverse_one _\n  map_mul' x y := (Ring.mul_inverse_rev x y).trans (mul_comm _ _)", "start": [252, 1], "end": [259, 66], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero.coe_inverse", "code": "@[simp]\ntheorem MonoidWithZero.coe_inverse {M : Type*} [CommMonoidWithZero M] :\n    (MonoidWithZero.inverse : M \u2192 M) = Ring.inverse", "start": [262, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero.inverse_apply", "code": "@[simp]\ntheorem MonoidWithZero.inverse_apply {M : Type*} [CommMonoidWithZero M] (a : M) :\n    MonoidWithZero.inverse a = Ring.inverse a", "start": [268, 1], "end": [271, 6], "kind": "commanddeclaration"}, {"full_name": "invMonoidWithZeroHom", "code": "def invMonoidWithZeroHom {G\u2080 : Type*} [CommGroupWithZero G\u2080] : G\u2080 \u2192*\u2080 G\u2080 :=\n  { invMonoidHom with map_zero' := inv_zero }", "start": [274, 1], "end": [276, 46], "kind": "commanddeclaration"}, {"full_name": "Units.smul_mk0", "code": "@[simp]\ntheorem smul_mk0 {\u03b1 : Type*} [SMul G\u2080 \u03b1] {g : G\u2080} (hg : g \u2260 0) (a : \u03b1) : mk0 g hg \u2022 a = g \u2022 a", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "map_zpow\u2080", "code": "@[simp]\ntheorem map_zpow\u2080 {F G\u2080 G\u2080' : Type*} [GroupWithZero G\u2080] [GroupWithZero G\u2080']\n    [MonoidWithZeroHomClass F G\u2080 G\u2080'] (f : F) (x : G\u2080) (n : \u2124) : f (x ^ n) = f x ^ n", "start": [292, 1], "end": [297, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Invertible/GroupWithZero.lean", "imports": ["Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Invertible/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nonzero_of_invertible", "code": "theorem nonzero_of_invertible [MulZeroOneClass \u03b1] (a : \u03b1) [Nontrivial \u03b1] [Invertible a] : a \u2260 0", "start": [22, 1], "end": [27, 32], "kind": "commanddeclaration"}, {"full_name": "Invertible.ne_zero", "code": "instance (priority := 100) Invertible.ne_zero [MulZeroOneClass \u03b1] [Nontrivial \u03b1] (a : \u03b1)\n    [Invertible a] : NeZero a :=\n  \u27e8nonzero_of_invertible a\u27e9", "start": [30, 1], "end": [32, 28], "kind": "commanddeclaration"}, {"full_name": "invertibleOfNonzero", "code": "def invertibleOfNonzero {a : \u03b1} (h : a \u2260 0) : Invertible a :=\n  \u27e8a\u207b\u00b9, inv_mul_cancel h, mul_inv_cancel h\u27e9", "start": [39, 1], "end": [41, 44], "kind": "commanddeclaration"}, {"full_name": "invOf_eq_inv", "code": "@[simp]\ntheorem invOf_eq_inv (a : \u03b1) [Invertible a] : \u215f a = a\u207b\u00b9", "start": [44, 1], "end": [46, 64], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_of_invertible", "code": "@[simp]\ntheorem inv_mul_cancel_of_invertible (a : \u03b1) [Invertible a] : a\u207b\u00b9 * a = 1", "start": [49, 1], "end": [51, 43], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_of_invertible", "code": "@[simp]\ntheorem mul_inv_cancel_of_invertible (a : \u03b1) [Invertible a] : a * a\u207b\u00b9 = 1", "start": [54, 1], "end": [56, 43], "kind": "commanddeclaration"}, {"full_name": "invertibleInv", "code": "def invertibleInv {a : \u03b1} [Invertible a] : Invertible a\u207b\u00b9 :=\n  \u27e8a, by simp, by simp\u27e9", "start": [59, 1], "end": [61, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/Defs.lean", "imports": ["Mathlib/Data/Rat/Init.lean", "lake-packages/std/Std/Data/Rat.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.castRec", "code": "def Rat.castRec [NatCast K] [IntCast K] [Mul K] [Inv K] : \u211a \u2192 K\n  | \u27e8a, b, _, _\u27e9 => \u2191a * (\u2191b)\u207b\u00b9", "start": [57, 1], "end": [62, 32], "kind": "commanddeclaration"}, {"full_name": "qsmulRec", "code": "def qsmulRec (coe : \u211a \u2192 K) [Mul K] (a : \u211a) (x : K) : K :=\n  coe a * x", "start": [65, 1], "end": [70, 12], "kind": "commanddeclaration"}, {"full_name": "DivisionSemiring", "code": "class DivisionSemiring (\u03b1 : Type*) extends Semiring \u03b1, GroupWithZero \u03b1", "start": [73, 1], "end": [74, 71], "kind": "commanddeclaration"}, {"full_name": "DivisionRing", "code": "class DivisionRing (K : Type u) extends Ring K, DivInvMonoid K, Nontrivial K, RatCast K where\n  \n  protected mul_inv_cancel : \u2200 (a : K), a \u2260 0 \u2192 a * a\u207b\u00b9 = 1\n  \n  protected inv_zero : (0 : K)\u207b\u00b9 = 0\n  protected ratCast := Rat.castRec\n  \n  protected ratCast_mk : \u2200 (a : \u2124) (b : \u2115) (h1 h2), Rat.cast \u27e8a, b, h1, h2\u27e9 = a * (b : K)\u207b\u00b9 := by\n    intros\n    rfl\n  \n  protected qsmul : \u211a \u2192 K \u2192 K := qsmulRec Rat.cast\n  \n  protected qsmul_eq_mul' : \u2200 (a : \u211a) (x : K), qsmul a x = Rat.cast a * x := by\n    intros\n    rfl", "start": [77, 1], "end": [103, 8], "kind": "commanddeclaration"}, {"full_name": "DivisionRing.toDivisionSemiring", "code": "instance (priority := 100) DivisionRing.toDivisionSemiring [DivisionRing \u03b1] : DivisionSemiring \u03b1 :=\n  { \u2039DivisionRing \u03b1\u203a with }", "start": [108, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "Semifield", "code": "class Semifield (\u03b1 : Type*) extends CommSemiring \u03b1, DivisionSemiring \u03b1, CommGroupWithZero \u03b1", "start": [112, 1], "end": [113, 92], "kind": "commanddeclaration"}, {"full_name": "Field", "code": "class Field (K : Type u) extends CommRing K, DivisionRing K", "start": [116, 1], "end": [126, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mk'", "code": "theorem cast_mk' (a b h1 h2) : ((\u27e8a, b, h1, h2\u27e9 : \u211a) : K) = a * (b : K)\u207b\u00b9", "start": [135, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_def", "code": "theorem cast_def : \u2200 r : \u211a, (r : K) = r.num / r.den", "start": [139, 1], "end": [140, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.smulDivisionRing", "code": "instance (priority := 100) smulDivisionRing : SMul \u211a K :=\n  \u27e8DivisionRing.qsmul\u27e9", "start": [143, 1], "end": [144, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.smul_def", "code": "theorem smul_def (a : \u211a) (x : K) : a \u2022 x = \u2191a * x", "start": [147, 1], "end": [148, 33], "kind": "commanddeclaration"}, {"full_name": "Rat.smul_one_eq_coe", "code": "@[simp]\ntheorem smul_one_eq_coe (A : Type*) [DivisionRing A] (m : \u211a) : m \u2022 (1 : A) = \u2191m", "start": [151, 1], "end": [153, 29], "kind": "commanddeclaration"}, {"full_name": "DivisionRing.toOfScientific", "code": "instance DivisionRing.toOfScientific [DivisionRing K] : OfScientific K where\n  ofScientific (m : \u2115) (b : Bool) (d : \u2115) := Rat.ofScientific m b d", "start": [162, 1], "end": [163, 68], "kind": "commanddeclaration"}, {"full_name": "Field.toSemifield", "code": "instance (priority := 100) Field.toSemifield : Semifield K :=\n  { \u2039Field K\u203a with }", "start": [172, 1], "end": [173, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Lattice.lean", "imports": ["Mathlib/Order/CompleteBooleanAlgebra.lean", "Mathlib/Order/Directed.lean", "Mathlib/Order/GaloisConnection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.sInter", "code": "def sInter (S : Set (Set \u03b1)) : Set \u03b1 :=\n  sInf S", "start": [76, 1], "end": [78, 9], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion", "code": "def sUnion (S : Set (Set \u03b1)) : Set \u03b1 :=\n  sSup S", "start": [84, 1], "end": [86, 9], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sInter", "code": "@[simp]\ntheorem mem_sInter {x : \u03b1} {S : Set (Set \u03b1)} : x \u2208 \u22c2\u2080 S \u2194 \u2200 t \u2208 S, x \u2208 t", "start": [92, 1], "end": [94, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sUnion", "code": "@[simp]\ntheorem mem_sUnion {x : \u03b1} {S : Set (Set \u03b1)} : x \u2208 \u22c3\u2080 S \u2194 \u2203 t \u2208 S, x \u2208 t", "start": [97, 1], "end": [99, 10], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion", "code": "def iUnion (s : \u03b9 \u2192 Set \u03b2) : Set \u03b2 :=\n  iSup s", "start": [102, 1], "end": [104, 9], "kind": "commanddeclaration"}, {"full_name": "Set.iInter", "code": "def iInter (s : \u03b9 \u2192 Set \u03b2) : Set \u03b2 :=\n  iInf s", "start": [107, 1], "end": [109, 9], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_delab", "code": "@[delab app.Set.iUnion]\ndef iUnion_delab : Delab := whenPPOption Lean.getPPNotation do\n  let #[_, \u03b9, f] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  unless f.isLambda do failure\n  let prop \u2190 Meta.isProp \u03b9\n  let dep := f.bindingBody!.hasLooseBVar 0\n  let ppTypes \u2190 getPPOption getPPFunBinderTypes\n  let stx \u2190 SubExpr.withAppArg do\n    let dom \u2190 SubExpr.withBindingDomain delab\n    withBindingBodyUnusedName $ fun x => do\n      let x : TSyntax `ident := .mk x\n      let body \u2190 delab\n      if prop && !dep then\n        `(\u22c3 (_ : $dom), $body)\n      else if prop || ppTypes then\n        `(\u22c3 ($x:ident : $dom), $body)\n      else\n        `(\u22c3 $x:ident, $body)\n  let stx : Term \u2190\n    match stx with\n    | `(\u22c3 $x:ident, \u22c3 (_ : $y:ident \u2208 $s), $body)\n    | `(\u22c3 ($x:ident : $_), \u22c3 (_ : $y:ident \u2208 $s), $body) =>\n      if x == y then `(\u22c3 $x:ident \u2208 $s, $body) else pure stx\n    | _ => pure stx\n  return stx", "start": [122, 1], "end": [148, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_delab", "code": "@[delab app.Set.iInter]\ndef sInter_delab : Delab := whenPPOption Lean.getPPNotation do\n  let #[_, \u03b9, f] := (\u2190 SubExpr.getExpr).getAppArgs | failure\n  unless f.isLambda do failure\n  let prop \u2190 Meta.isProp \u03b9\n  let dep := f.bindingBody!.hasLooseBVar 0\n  let ppTypes \u2190 getPPOption getPPFunBinderTypes\n  let stx \u2190 SubExpr.withAppArg do\n    let dom \u2190 SubExpr.withBindingDomain delab\n    withBindingBodyUnusedName $ fun x => do\n      let x : TSyntax `ident := .mk x\n      let body \u2190 delab\n      if prop && !dep then\n        `(\u22c2 (_ : $dom), $body)\n      else if prop || ppTypes then\n        `(\u22c2 ($x:ident : $dom), $body)\n      else\n        `(\u22c2 $x:ident, $body)\n  let stx : Term \u2190\n    match stx with\n    | `(\u22c2 $x:ident, \u22c2 (_ : $y:ident \u2208 $s), $body)\n    | `(\u22c2 ($x:ident : $_), \u22c2 (_ : $y:ident \u2208 $s), $body) =>\n      if x == y then `(\u22c2 $x:ident \u2208 $s, $body) else pure stx\n    | _ => pure stx\n  return stx", "start": [150, 1], "end": [176, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sSup_eq_sUnion", "code": "@[simp]\ntheorem sSup_eq_sUnion (S : Set (Set \u03b1)) : sSup S = \u22c3\u2080S", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Set.sInf_eq_sInter", "code": "@[simp]\ntheorem sInf_eq_sInter (S : Set (Set \u03b1)) : sInf S = \u22c2\u2080 S", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "Set.iSup_eq_iUnion", "code": "@[simp]\ntheorem iSup_eq_iUnion (s : \u03b9 \u2192 Set \u03b1) : iSup s = iUnion s", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Set.iInf_eq_iInter", "code": "@[simp]\ntheorem iInf_eq_iInter (s : \u03b9 \u2192 Set \u03b1) : iInf s = iInter s", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iUnion", "code": "@[simp]\ntheorem mem_iUnion {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c3 i, s i) \u2194 \u2203 i, x \u2208 s i", "start": [200, 1], "end": [203, 26], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iInter", "code": "@[simp]\ntheorem mem_iInter {x : \u03b1} {s : \u03b9 \u2192 Set \u03b1} : (x \u2208 \u22c2 i, s i) \u2194 \u2200 i, x \u2208 s i", "start": [206, 1], "end": [209, 45], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iUnion\u2082", "code": "theorem mem_iUnion\u2082 {x : \u03b3} {s : \u2200 i, \u03ba i \u2192 Set \u03b3} : (x \u2208 \u22c3 (i) (j), s i j) \u2194 \u2203 i j, x \u2208 s i j", "start": [212, 1], "end": [213, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iInter\u2082", "code": "theorem mem_iInter\u2082 {x : \u03b3} {s : \u2200 i, \u03ba i \u2192 Set \u03b3} : (x \u2208 \u22c2 (i) (j), s i j) \u2194 \u2200 i j, x \u2208 s i j", "start": [217, 1], "end": [218, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iUnion_of_mem", "code": "theorem mem_iUnion_of_mem {s : \u03b9 \u2192 Set \u03b1} {a : \u03b1} (i : \u03b9) (ha : a \u2208 s i) : a \u2208 \u22c3 i, s i", "start": [221, 1], "end": [222, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iUnion\u2082_of_mem", "code": "theorem mem_iUnion\u2082_of_mem {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {a : \u03b1} {i : \u03b9} (j : \u03ba i) (ha : a \u2208 s i j) :\n    a \u2208 \u22c3 (i) (j), s i j", "start": [226, 1], "end": [228, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iInter_of_mem", "code": "theorem mem_iInter_of_mem {s : \u03b9 \u2192 Set \u03b1} {a : \u03b1} (h : \u2200 i, a \u2208 s i) : a \u2208 \u22c2 i, s i", "start": [231, 1], "end": [232, 17], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iInter\u2082_of_mem", "code": "theorem mem_iInter\u2082_of_mem {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {a : \u03b1} (h : \u2200 i j, a \u2208 s i j) :\n    a \u2208 \u22c2 (i) (j), s i j", "start": [236, 1], "end": [238, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Set.completeAtomicBooleanAlgebra", "code": "instance Set.completeAtomicBooleanAlgebra : CompleteAtomicBooleanAlgebra (Set \u03b1) :=\n  { instBooleanAlgebraSet with\n    le_sSup := fun s t t_in a a_in => \u27e8t, t_in, a_in\u27e9\n    sSup_le := fun s t h a \u27e8t', \u27e8t'_in, a_in\u27e9\u27e9 => h t' t'_in a_in\n    le_sInf := fun s t h a a_in t' t'_in => h t' t'_in a_in\n    sInf_le := fun s t t_in a h => h _ t_in\n    iInf_iSup_eq := by intros; ext; simp [Classical.skolem] }", "start": [241, 1], "end": [247, 62], "kind": "commanddeclaration"}, {"full_name": "Set.kernImage", "code": "def kernImage (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Set \u03b2 :=\n  { y | \u2200 \u2983x\u2984, f x = y \u2192 x \u2208 s }", "start": [249, 1], "end": [251, 33], "kind": "commanddeclaration"}, {"full_name": "Set.subset_kernImage_iff", "code": "lemma subset_kernImage_iff {f : \u03b1 \u2192 \u03b2} : s \u2286 kernImage f t \u2194 f \u207b\u00b9' s \u2286 t :=\n  \u27e8fun h _ hx \u21a6 h hx rfl,\n    fun h _ hx y hy \u21a6 h (show f y \u2208 s from hy.symm \u25b8 hx)\u27e9", "start": [254, 1], "end": [256, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image_preimage", "code": "protected theorem image_preimage : GaloisConnection (image f) (preimage f)", "start": [261, 1], "end": [262, 19], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_kernImage", "code": "protected theorem preimage_kernImage : GaloisConnection (preimage f) (kernImage f)", "start": [265, 1], "end": [266, 28], "kind": "commanddeclaration"}, {"full_name": "Set.kernImage_mono", "code": "lemma kernImage_mono : Monotone (kernImage f) :=\n  Set.preimage_kernImage.monotone_u", "start": [275, 1], "end": [276, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_eq_compl", "code": "lemma kernImage_eq_compl {s : Set \u03b1} : kernImage f s = (f '' s\u1d9c)\u1d9c :=\n  Set.preimage_kernImage.u_unique (Set.image_preimage.compl)\n    (fun t \u21a6 compl_compl (f \u207b\u00b9' t) \u25b8 Set.preimage_compl)", "start": [278, 1], "end": [280, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_compl", "code": "lemma kernImage_compl {s : Set \u03b1} : kernImage f (s\u1d9c) = (f '' s)\u1d9c := by\n  rw [kernImage_eq_compl, compl_compl]", "start": [282, 1], "end": [283, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_empty", "code": "lemma kernImage_empty : kernImage f \u2205 = (range f)\u1d9c := by\n  rw [kernImage_eq_compl, compl_empty, image_univ]", "start": [285, 1], "end": [286, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_preimage_eq_iff", "code": "lemma kernImage_preimage_eq_iff {s : Set \u03b2} : kernImage f (f \u207b\u00b9' s) = s \u2194 (range f)\u1d9c \u2286 s := by\n  rw [kernImage_eq_compl, \u2190 preimage_compl, compl_eq_comm, eq_comm, image_preimage_eq_iff,\n      compl_subset_comm]", "start": [288, 1], "end": [290, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Set.compl_range_subset_kernImage", "code": "lemma compl_range_subset_kernImage {s : Set \u03b1} : (range f)\u1d9c \u2286 kernImage f s := by\n  rw [\u2190 kernImage_empty]\n  exact kernImage_mono (empty_subset _)", "start": [292, 1], "end": [294, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_union_preimage", "code": "lemma kernImage_union_preimage {s : Set \u03b1} {t : Set \u03b2} :\n    kernImage f (s \u222a f \u207b\u00b9' t) = kernImage f s \u222a t := by\n  rw [kernImage_eq_compl, kernImage_eq_compl, compl_union, \u2190 preimage_compl, image_inter_preimage,\n      compl_inter, compl_compl]", "start": [296, 1], "end": [299, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Set.kernImage_preimage_union", "code": "lemma kernImage_preimage_union {s : Set \u03b1} {t : Set \u03b2} :\n    kernImage f (f \u207b\u00b9' t \u222a s) = t \u222a kernImage f s := by\n  rw [union_comm, kernImage_union_preimage, union_comm]", "start": [301, 1], "end": [303, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_congr_Prop", "code": "@[congr]\ntheorem iUnion_congr_Prop {p q : Prop} {f\u2081 : p \u2192 Set \u03b1} {f\u2082 : q \u2192 Set \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iUnion f\u2081 = iUnion f\u2082", "start": [314, 1], "end": [317, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_congr_Prop", "code": "@[congr]\ntheorem iInter_congr_Prop {p q : Prop} {f\u2081 : p \u2192 Set \u03b1} {f\u2082 : q \u2192 Set \u03b1} (pq : p \u2194 q)\n    (f : \u2200 x, f\u2081 (pq.mpr x) = f\u2082 x) : iInter f\u2081 = iInter f\u2082", "start": [320, 1], "end": [323, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_plift_up", "code": "theorem iUnion_plift_up (f : PLift \u03b9 \u2192 Set \u03b1) : \u22c3 i, f (PLift.up i) = \u22c3 i, f i", "start": [326, 1], "end": [327, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_plift_down", "code": "theorem iUnion_plift_down (f : \u03b9 \u2192 Set \u03b1) : \u22c3 i, f (PLift.down i) = \u22c3 i, f i", "start": [330, 1], "end": [331, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_plift_up", "code": "theorem iInter_plift_up (f : PLift \u03b9 \u2192 Set \u03b1) : \u22c2 i, f (PLift.up i) = \u22c2 i, f i", "start": [334, 1], "end": [335, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_plift_down", "code": "theorem iInter_plift_down (f : \u03b9 \u2192 Set \u03b1) : \u22c2 i, f (PLift.down i) = \u22c2 i, f i", "start": [338, 1], "end": [339, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_if", "code": "theorem iUnion_eq_if {p : Prop} [Decidable p] (s : Set \u03b1) : \u22c3 _ : p, s = if p then s else \u2205", "start": [342, 1], "end": [343, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_dif", "code": "theorem iUnion_eq_dif {p : Prop} [Decidable p] (s : p \u2192 Set \u03b1) :\n    \u22c3 h : p, s h = if h : p then s h else \u2205", "start": [346, 1], "end": [348, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_if", "code": "theorem iInter_eq_if {p : Prop} [Decidable p] (s : Set \u03b1) : \u22c2 _ : p, s = if p then s else univ", "start": [351, 1], "end": [352, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iInf_eq_dif", "code": "theorem iInf_eq_dif {p : Prop} [Decidable p] (s : p \u2192 Set \u03b1) :\n    \u22c2 h : p, s h = if h : p then s h else univ", "start": [355, 1], "end": [357, 23], "kind": "commanddeclaration"}, {"full_name": "Set.exists_set_mem_of_union_eq_top", "code": "theorem exists_set_mem_of_union_eq_top {\u03b9 : Type*} (t : Set \u03b9) (s : \u03b9 \u2192 Set \u03b2)\n    (w : \u22c3 i \u2208 t, s i = \u22a4) (x : \u03b2) : \u2203 i \u2208 t, x \u2208 s i", "start": [360, 1], "end": [364, 16], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_union_eq_top_of_nonempty", "code": "theorem nonempty_of_union_eq_top_of_nonempty {\u03b9 : Type*} (t : Set \u03b9) (s : \u03b9 \u2192 Set \u03b1)\n    (H : Nonempty \u03b1) (w : \u22c3 i \u2208 t, s i = \u22a4) : t.Nonempty", "start": [367, 1], "end": [370, 15], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_nonempty_iUnion", "code": "theorem nonempty_of_nonempty_iUnion\n    {s : \u03b9 \u2192 Set \u03b1} (h_Union : (\u22c3 i, s i).Nonempty) : Nonempty \u03b9", "start": [373, 1], "end": [376, 46], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_nonempty_iUnion_eq_univ", "code": "theorem nonempty_of_nonempty_iUnion_eq_univ\n    {s : \u03b9 \u2192 Set \u03b1} [Nonempty \u03b1] (h_Union : \u22c3 i, s i = univ) : Nonempty \u03b9", "start": [378, 1], "end": [380, 85], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_exists", "code": "theorem setOf_exists (p : \u03b9 \u2192 \u03b2 \u2192 Prop) : { x | \u2203 i, p i x } = \u22c3 i, { x | p i x }", "start": [382, 1], "end": [383, 31], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_forall", "code": "theorem setOf_forall (p : \u03b9 \u2192 \u03b2 \u2192 Prop) : { x | \u2200 i, p i x } = \u22c2 i, { x | p i x }", "start": [386, 1], "end": [387, 31], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_subset", "code": "theorem iUnion_subset {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} (h : \u2200 i, s i \u2286 t) : \u22c3 i, s i \u2286 t", "start": [390, 1], "end": [391, 12], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_subset", "code": "theorem iUnion\u2082_subset {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b1} (h : \u2200 i j, s i j \u2286 t) :\n    \u22c3 (i) (j), s i j \u2286 t", "start": [395, 1], "end": [397, 45], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iInter", "code": "theorem subset_iInter {t : Set \u03b2} {s : \u03b9 \u2192 Set \u03b2} (h : \u2200 i, t \u2286 s i) : t \u2286 \u22c2 i, s i", "start": [400, 1], "end": [401, 12], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iInter\u2082", "code": "theorem subset_iInter\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s \u2286 t i j) :\n    s \u2286 \u22c2 (i) (j), t i j", "start": [405, 1], "end": [407, 46], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_subset_iff", "code": "@[simp]\ntheorem iUnion_subset_iff {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} : \u22c3 i, s i \u2286 t \u2194 \u2200 i, s i \u2286 t", "start": [410, 1], "end": [412, 59], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_subset_iff", "code": "theorem iUnion\u2082_subset_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b1} :\n    \u22c3 (i) (j), s i j \u2286 t \u2194 \u2200 i j, s i j \u2286 t", "start": [416, 1], "end": [417, 78], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iInter_iff", "code": "@[simp]\ntheorem subset_iInter_iff {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b1} : (s \u2286 \u22c2 i, t i) \u2194 \u2200 i, s \u2286 t i", "start": [420, 1], "end": [422, 14], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iInter\u2082_iff", "code": "theorem subset_iInter\u2082_iff {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    (s \u2286 \u22c2 (i) (j), t i j) \u2194 \u2200 i j, s \u2286 t i j", "start": [427, 1], "end": [428, 80], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iUnion", "code": "theorem subset_iUnion : \u2200 (s : \u03b9 \u2192 Set \u03b2) (i : \u03b9), s i \u2286 \u22c3 i, s i", "start": [431, 1], "end": [432, 10], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_subset", "code": "theorem iInter_subset : \u2200 (s : \u03b9 \u2192 Set \u03b2) (i : \u03b9), \u22c2 i, s i \u2286 s i", "start": [435, 1], "end": [436, 10], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iUnion\u2082", "code": "theorem subset_iUnion\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} (i : \u03b9) (j : \u03ba i) : s i j \u2286 \u22c3 (i') (j'), s i' j'", "start": [440, 1], "end": [441, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_subset", "code": "theorem iInter\u2082_subset {s : \u2200 i, \u03ba i \u2192 Set \u03b1} (i : \u03b9) (j : \u03ba i) : \u22c2 (i) (j), s i j \u2286 s i j", "start": [445, 1], "end": [446, 15], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iUnion_of_subset", "code": "theorem subset_iUnion_of_subset {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b1} (i : \u03b9) (h : s \u2286 t i) : s \u2286 \u22c3 i, t i", "start": [449, 1], "end": [452, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_subset_of_subset", "code": "theorem iInter_subset_of_subset {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} (i : \u03b9) (h : s i \u2286 t) :\n    \u22c2 i, s i \u2286 t", "start": [455, 1], "end": [459, 20], "kind": "commanddeclaration"}, {"full_name": "Set.subset_iUnion\u2082_of_subset", "code": "theorem subset_iUnion\u2082_of_subset {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} (i : \u03b9) (j : \u03ba i)\n    (h : s \u2286 t i j) : s \u2286 \u22c3 (i) (j), t i j", "start": [463, 1], "end": [467, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_subset_of_subset", "code": "theorem iInter\u2082_subset_of_subset {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b1} (i : \u03b9) (j : \u03ba i)\n    (h : s i j \u2286 t) : \u22c2 (i) (j), s i j \u2286 t", "start": [471, 1], "end": [475, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mono", "code": "theorem iUnion_mono {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2286 t i) : \u22c3 i, s i \u2286 \u22c3 i, t i", "start": [478, 1], "end": [479, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mono''", "code": "@[gcongr]\ntheorem iUnion_mono'' {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2286 t i) : iUnion s \u2286 iUnion t", "start": [482, 1], "end": [484, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_mono", "code": "theorem iUnion\u2082_mono {s t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s i j \u2286 t i j) :\n    \u22c3 (i) (j), s i j \u2286 \u22c3 (i) (j), t i j", "start": [488, 1], "end": [490, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_mono", "code": "theorem iInter_mono {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2286 t i) : \u22c2 i, s i \u2286 \u22c2 i, t i", "start": [493, 1], "end": [494, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_mono''", "code": "@[gcongr]\ntheorem iInter_mono'' {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i \u2286 t i) : iInter s \u2286 iInter t", "start": [497, 1], "end": [499, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_mono", "code": "theorem iInter\u2082_mono {s t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s i j \u2286 t i j) :\n    \u22c2 (i) (j), s i j \u2286 \u22c2 (i) (j), t i j", "start": [503, 1], "end": [505, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mono'", "code": "theorem iUnion_mono' {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9\u2082 \u2192 Set \u03b1} (h : \u2200 i, \u2203 j, s i \u2286 t j) :\n    \u22c3 i, s i \u2286 \u22c3 i, t i", "start": [508, 1], "end": [510, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_mono'", "code": "theorem iUnion\u2082_mono' {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : \u2200 i', \u03ba' i' \u2192 Set \u03b1}\n    (h : \u2200 i j, \u2203 i' j', s i j \u2286 t i' j') : \u22c3 (i) (j), s i j \u2286 \u22c3 (i') (j'), t i' j'", "start": [515, 1], "end": [517, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_mono'", "code": "theorem iInter_mono' {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9' \u2192 Set \u03b1} (h : \u2200 j, \u2203 i, s i \u2286 t j) :\n    \u22c2 i, s i \u2286 \u22c2 j, t j", "start": [520, 1], "end": [524, 33], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_mono'", "code": "theorem iInter\u2082_mono' {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : \u2200 i', \u03ba' i' \u2192 Set \u03b1}\n    (h : \u2200 i' j', \u2203 i j, s i j \u2286 t i' j') : \u22c2 (i) (j), s i j \u2286 \u22c2 (i') (j'), t i' j'", "start": [529, 1], "end": [533, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_subset_iUnion", "code": "theorem iUnion\u2082_subset_iUnion (\u03ba : \u03b9 \u2192 Sort*) (s : \u03b9 \u2192 Set \u03b1) :\n    \u22c3 (i) (_ : \u03ba i), s i \u2286 \u22c3 i, s i", "start": [536, 1], "end": [538, 57], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_subset_iInter\u2082", "code": "theorem iInter_subset_iInter\u2082 (\u03ba : \u03b9 \u2192 Sort*) (s : \u03b9 \u2192 Set \u03b1) :\n    \u22c2 i, s i \u2286 \u22c2 (i) (_ : \u03ba i), s i", "start": [541, 1], "end": [543, 57], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_setOf", "code": "theorem iUnion_setOf (P : \u03b9 \u2192 \u03b1 \u2192 Prop) : \u22c3 i, { x : \u03b1 | P i x } = { x : \u03b1 | \u2203 i, P i x }", "start": [546, 1], "end": [548, 19], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_setOf", "code": "theorem iInter_setOf (P : \u03b9 \u2192 \u03b1 \u2192 Prop) : \u22c2 i, { x : \u03b1 | P i x } = { x : \u03b1 | \u2200 i, P i x }", "start": [551, 1], "end": [553, 19], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_congr_of_surjective", "code": "theorem iUnion_congr_of_surjective {f : \u03b9 \u2192 Set \u03b1} {g : \u03b9\u2082 \u2192 Set \u03b1} (h : \u03b9 \u2192 \u03b9\u2082) (h1 : Surjective h)\n    (h2 : \u2200 x, g (h x) = f x) : \u22c3 x, f x = \u22c3 y, g y", "start": [556, 1], "end": [558, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_congr_of_surjective", "code": "theorem iInter_congr_of_surjective {f : \u03b9 \u2192 Set \u03b1} {g : \u03b9\u2082 \u2192 Set \u03b1} (h : \u03b9 \u2192 \u03b9\u2082) (h1 : Surjective h)\n    (h2 : \u2200 x, g (h x) = f x) : \u22c2 x, f x = \u22c2 y, g y", "start": [561, 1], "end": [563, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_congr", "code": "lemma iUnion_congr {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i = t i) : \u22c3 i, s i = \u22c3 i, t i := iSup_congr h", "start": [566, 1], "end": [566, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iInter_congr", "code": "lemma iInter_congr {s t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, s i = t i) : \u22c2 i, s i = \u22c2 i, t i := iInf_congr h", "start": [568, 1], "end": [568, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion\u2082_congr", "code": "lemma iUnion\u2082_congr {s t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s i j = t i j) :\n    \u22c3 (i) (j), s i j = \u22c3 (i) (j), t i j :=\n  iUnion_congr fun i => iUnion_congr <| h i", "start": [573, 1], "end": [575, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iInter\u2082_congr", "code": "lemma iInter\u2082_congr {s t : \u2200 i, \u03ba i \u2192 Set \u03b1} (h : \u2200 i j, s i j = t i j) :\n    \u22c2 (i) (j), s i j = \u22c2 (i) (j), t i j :=\n  iInter_congr fun i => iInter_congr <| h i", "start": [580, 1], "end": [582, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_const", "code": "lemma iUnion_const (s : Set \u03b2) : \u22c3 _ : \u03b9, s = s := iSup_const", "start": [588, 1], "end": [588, 62], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iInter_const", "code": "lemma iInter_const (s : Set \u03b2) : \u22c2 _ : \u03b9, s = s := iInf_const", "start": [590, 1], "end": [590, 62], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_eq_const", "code": "lemma iUnion_eq_const (hf : \u2200 i, f i = s) : \u22c3 i, f i = s :=\n  (iUnion_congr hf).trans $ iUnion_const _", "start": [593, 1], "end": [594, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iInter_eq_const", "code": "lemma iInter_eq_const (hf : \u2200 i, f i = s) : \u22c2 i, f i = s :=\n  (iInter_congr hf).trans $ iInter_const _", "start": [597, 1], "end": [598, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Set.compl_iUnion", "code": "@[simp]\ntheorem compl_iUnion (s : \u03b9 \u2192 Set \u03b2) : (\u22c3 i, s i)\u1d9c = \u22c2 i, (s i)\u1d9c", "start": [603, 1], "end": [605, 13], "kind": "commanddeclaration"}, {"full_name": "Set.compl_iUnion\u2082", "code": "theorem compl_iUnion\u2082 (s : \u2200 i, \u03ba i \u2192 Set \u03b1) : (\u22c3 (i) (j), s i j)\u1d9c = \u22c2 (i) (j), (s i j)\u1d9c", "start": [610, 1], "end": [611, 25], "kind": "commanddeclaration"}, {"full_name": "Set.compl_iInter", "code": "@[simp]\ntheorem compl_iInter (s : \u03b9 \u2192 Set \u03b2) : (\u22c2 i, s i)\u1d9c = \u22c3 i, (s i)\u1d9c", "start": [614, 1], "end": [616, 13], "kind": "commanddeclaration"}, {"full_name": "Set.compl_iInter\u2082", "code": "theorem compl_iInter\u2082 (s : \u2200 i, \u03ba i \u2192 Set \u03b1) : (\u22c2 (i) (j), s i j)\u1d9c = \u22c3 (i) (j), (s i j)\u1d9c", "start": [621, 1], "end": [622, 25], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_compl_iInter_compl", "code": "theorem iUnion_eq_compl_iInter_compl (s : \u03b9 \u2192 Set \u03b2) : \u22c3 i, s i = (\u22c2 i, (s i)\u1d9c)\u1d9c", "start": [626, 1], "end": [627, 40], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_compl_iUnion_compl", "code": "theorem iInter_eq_compl_iUnion_compl (s : \u03b9 \u2192 Set \u03b2) : \u22c2 i, s i = (\u22c3 i, (s i)\u1d9c)\u1d9c", "start": [631, 1], "end": [632, 40], "kind": "commanddeclaration"}, {"full_name": "Set.inter_iUnion", "code": "theorem inter_iUnion (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u2229 \u22c3 i, t i) = \u22c3 i, s \u2229 t i", "start": [635, 1], "end": [636, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inter", "code": "theorem iUnion_inter (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (\u22c3 i, t i) \u2229 s = \u22c3 i, t i \u2229 s", "start": [639, 1], "end": [640, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_union_distrib", "code": "theorem iUnion_union_distrib (s : \u03b9 \u2192 Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) :\n    \u22c3 i, s i \u222a t i = (\u22c3 i, s i) \u222a \u22c3 i, t i", "start": [643, 1], "end": [645, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_inter_distrib", "code": "theorem iInter_inter_distrib (s : \u03b9 \u2192 Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) :\n    \u22c2 i, s i \u2229 t i = (\u22c2 i, s i) \u2229 \u22c2 i, t i", "start": [648, 1], "end": [650, 14], "kind": "commanddeclaration"}, {"full_name": "Set.union_iUnion", "code": "theorem union_iUnion [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u222a \u22c3 i, t i) = \u22c3 i, s \u222a t i", "start": [653, 1], "end": [654, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_union", "code": "theorem iUnion_union [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (\u22c3 i, t i) \u222a s = \u22c3 i, t i \u222a s", "start": [657, 1], "end": [658, 11], "kind": "commanddeclaration"}, {"full_name": "Set.inter_iInter", "code": "theorem inter_iInter [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u2229 \u22c2 i, t i) = \u22c2 i, s \u2229 t i", "start": [661, 1], "end": [662, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_inter", "code": "theorem iInter_inter [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (\u22c2 i, t i) \u2229 s = \u22c2 i, t i \u2229 s", "start": [665, 1], "end": [666, 11], "kind": "commanddeclaration"}, {"full_name": "Set.union_iInter", "code": "theorem union_iInter (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u222a \u22c2 i, t i) = \u22c2 i, s \u222a t i", "start": [670, 1], "end": [671, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_union", "code": "theorem iInter_union (s : \u03b9 \u2192 Set \u03b2) (t : Set \u03b2) : (\u22c2 i, s i) \u222a t = \u22c2 i, s i \u222a t", "start": [674, 1], "end": [675, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_diff", "code": "theorem iUnion_diff (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (\u22c3 i, t i) \\ s = \u22c3 i, t i \\ s", "start": [678, 1], "end": [679, 19], "kind": "commanddeclaration"}, {"full_name": "Set.diff_iUnion", "code": "theorem diff_iUnion [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \\ \u22c3 i, t i) = \u22c2 i, s \\ t i", "start": [682, 1], "end": [683, 48], "kind": "commanddeclaration"}, {"full_name": "Set.diff_iInter", "code": "theorem diff_iInter (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \\ \u22c2 i, t i) = \u22c3 i, s \\ t i", "start": [686, 1], "end": [687, 48], "kind": "commanddeclaration"}, {"full_name": "Set.directed_on_iUnion", "code": "theorem directed_on_iUnion {r} {f : \u03b9 \u2192 Set \u03b1} (hd : Directed (\u00b7 \u2286 \u00b7) f)\n    (h : \u2200 x, DirectedOn r (f x)) : DirectedOn r (\u22c3 x, f x)", "start": [690, 1], "end": [696, 27], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inter_subset", "code": "theorem iUnion_inter_subset {\u03b9 \u03b1} {s t : \u03b9 \u2192 Set \u03b1} : \u22c3 i, s i \u2229 t i \u2286 (\u22c3 i, s i) \u2229 \u22c3 i, t i", "start": [699, 1], "end": [700, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inter_of_monotone", "code": "theorem iUnion_inter_of_monotone {\u03b9 \u03b1} [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] {s t : \u03b9 \u2192 Set \u03b1}\n    (hs : Monotone s) (ht : Monotone t) : \u22c3 i, s i \u2229 t i = (\u22c3 i, s i) \u2229 \u22c3 i, t i", "start": [703, 1], "end": [705, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inter_of_antitone", "code": "theorem iUnion_inter_of_antitone {\u03b9 \u03b1} [Preorder \u03b9] [IsDirected \u03b9 (swap (\u00b7 \u2264 \u00b7))] {s t : \u03b9 \u2192 Set \u03b1}\n    (hs : Antitone s) (ht : Antitone t) : \u22c3 i, s i \u2229 t i = (\u22c3 i, s i) \u2229 \u22c3 i, t i", "start": [708, 1], "end": [710, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_union_of_monotone", "code": "theorem iInter_union_of_monotone {\u03b9 \u03b1} [Preorder \u03b9] [IsDirected \u03b9 (swap (\u00b7 \u2264 \u00b7))] {s t : \u03b9 \u2192 Set \u03b1}\n    (hs : Monotone s) (ht : Monotone t) : \u22c2 i, s i \u222a t i = (\u22c2 i, s i) \u222a \u22c2 i, t i", "start": [713, 1], "end": [715, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_union_of_antitone", "code": "theorem iInter_union_of_antitone {\u03b9 \u03b1} [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] {s t : \u03b9 \u2192 Set \u03b1}\n    (hs : Antitone s) (ht : Antitone t) : \u22c2 i, s i \u222a t i = (\u22c2 i, s i) \u222a \u22c2 i, t i", "start": [718, 1], "end": [720, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iInter_subset", "code": "theorem iUnion_iInter_subset {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} : (\u22c3 j, \u22c2 i, s i j) \u2286 \u22c2 i, \u22c3 j, s i j", "start": [723, 1], "end": [725, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_option", "code": "theorem iUnion_option {\u03b9} (s : Option \u03b9 \u2192 Set \u03b1) : \u22c3 o, s o = s none \u222a \u22c3 i, s (some i)", "start": [728, 1], "end": [729, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_option", "code": "theorem iInter_option {\u03b9} (s : Option \u03b9 \u2192 Set \u03b1) : \u22c2 o, s o = s none \u2229 \u22c2 i, s (some i)", "start": [732, 1], "end": [733, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_dite", "code": "theorem iUnion_dite (f : \u2200 i, p i \u2192 Set \u03b1) (g : \u2200 i, \u00acp i \u2192 Set \u03b1) :\n    \u22c3 i, (if h : p i then f i h else g i h) = (\u22c3 (i) (h : p i), f i h) \u222a \u22c3 (i) (h : \u00acp i), g i h", "start": [740, 1], "end": [742, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_ite", "code": "theorem iUnion_ite (f g : \u03b9 \u2192 Set \u03b1) :\n    \u22c3 i, (if p i then f i else g i) = (\u22c3 (i) (_ : p i), f i) \u222a \u22c3 (i) (_ : \u00acp i), g i", "start": [745, 1], "end": [747, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_dite", "code": "theorem iInter_dite (f : \u2200 i, p i \u2192 Set \u03b1) (g : \u2200 i, \u00acp i \u2192 Set \u03b1) :\n    \u22c2 i, (if h : p i then f i h else g i h) = (\u22c2 (i) (h : p i), f i h) \u2229 \u22c2 (i) (h : \u00acp i), g i h", "start": [750, 1], "end": [752, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_ite", "code": "theorem iInter_ite (f g : \u03b9 \u2192 Set \u03b1) :\n    \u22c2 i, (if p i then f i else g i) = (\u22c2 (i) (_ : p i), f i) \u2229 \u22c2 (i) (_ : \u00acp i), g i", "start": [755, 1], "end": [757, 20], "kind": "commanddeclaration"}, {"full_name": "Set.image_projection_prod", "code": "theorem image_projection_prod {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {v : \u2200 i : \u03b9, Set (\u03b1 i)}\n    (hv : (pi univ v).Nonempty) (i : \u03b9) :\n    ((fun x : \u2200 i : \u03b9, \u03b1 i => x i) '' \u22c2 k, (fun x : \u2200 j : \u03b9, \u03b1 j => x k) \u207b\u00b9' v k) = v i", "start": [762, 1], "end": [773, 51], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_false", "code": "theorem iInter_false {s : False \u2192 Set \u03b1} : iInter s = univ", "start": [779, 1], "end": [780, 13], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_false", "code": "theorem iUnion_false {s : False \u2192 Set \u03b1} : iUnion s = \u2205", "start": [783, 1], "end": [784, 13], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_true", "code": "@[simp]\ntheorem iInter_true {s : True \u2192 Set \u03b1} : iInter s = s trivial", "start": [787, 1], "end": [789, 12], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_true", "code": "@[simp]\ntheorem iUnion_true {s : True \u2192 Set \u03b1} : iUnion s = s trivial", "start": [792, 1], "end": [794, 12], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_exists", "code": "@[simp]\ntheorem iInter_exists {p : \u03b9 \u2192 Prop} {f : Exists p \u2192 Set \u03b1} :\n    \u22c2 x, f x = \u22c2 (i) (h : p i), f \u27e8i, h\u27e9", "start": [797, 1], "end": [800, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_exists", "code": "@[simp]\ntheorem iUnion_exists {p : \u03b9 \u2192 Prop} {f : Exists p \u2192 Set \u03b1} :\n    \u22c3 x, f x = \u22c3 (i) (h : p i), f \u27e8i, h\u27e9", "start": [803, 1], "end": [806, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_empty", "code": "@[simp]\ntheorem iUnion_empty : (\u22c3 _ : \u03b9, \u2205 : Set \u03b1) = \u2205", "start": [809, 1], "end": [811, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_univ", "code": "@[simp]\ntheorem iInter_univ : (\u22c2 _ : \u03b9, univ : Set \u03b1) = univ", "start": [814, 1], "end": [816, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_empty", "code": "@[simp]\ntheorem iUnion_eq_empty : \u22c3 i, s i = \u2205 \u2194 \u2200 i, s i = \u2205", "start": [823, 1], "end": [825, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_univ", "code": "@[simp]\ntheorem iInter_eq_univ : \u22c2 i, s i = univ \u2194 \u2200 i, s i = univ", "start": [828, 1], "end": [830, 14], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iUnion", "code": "@[simp]\ntheorem nonempty_iUnion : (\u22c3 i, s i).Nonempty \u2194 \u2203 i, (s i).Nonempty", "start": [833, 1], "end": [835, 31], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_biUnion", "code": "theorem nonempty_biUnion {t : Set \u03b1} {s : \u03b1 \u2192 Set \u03b2} :\n    (\u22c3 i \u2208 t, s i).Nonempty \u2194 \u2203 i \u2208 t, (s i).Nonempty", "start": [839, 1], "end": [840, 65], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_nonempty_index", "code": "theorem iUnion_nonempty_index (s : Set \u03b1) (t : s.Nonempty \u2192 Set \u03b2) :\n    \u22c3 h, t h = \u22c3 x \u2208 s, t \u27e8x, \u2039_\u203a\u27e9", "start": [843, 1], "end": [845, 14], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iInter_eq_left", "code": "@[simp]\ntheorem iInter_iInter_eq_left {b : \u03b2} {s : \u2200 x : \u03b2, x = b \u2192 Set \u03b1} :\n    \u22c2 (x) (h : x = b), s x h = s b rfl", "start": [850, 1], "end": [853, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iInter_eq_right", "code": "@[simp]\ntheorem iInter_iInter_eq_right {b : \u03b2} {s : \u2200 x : \u03b2, b = x \u2192 Set \u03b1} :\n    \u22c2 (x) (h : b = x), s x h = s b rfl", "start": [856, 1], "end": [859, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iUnion_eq_left", "code": "@[simp]\ntheorem iUnion_iUnion_eq_left {b : \u03b2} {s : \u2200 x : \u03b2, x = b \u2192 Set \u03b1} :\n    \u22c3 (x) (h : x = b), s x h = s b rfl", "start": [862, 1], "end": [865, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iUnion_eq_right", "code": "@[simp]\ntheorem iUnion_iUnion_eq_right {b : \u03b2} {s : \u2200 x : \u03b2, b = x \u2192 Set \u03b1} :\n    \u22c3 (x) (h : b = x), s x h = s b rfl", "start": [868, 1], "end": [871, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_or", "code": "theorem iInter_or {p q : Prop} (s : p \u2228 q \u2192 Set \u03b1) :\n    \u22c2 h, s h = (\u22c2 h : p, s (Or.inl h)) \u2229 \u22c2 h : q, s (Or.inr h)", "start": [874, 1], "end": [876, 10], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_or", "code": "theorem iUnion_or {p q : Prop} (s : p \u2228 q \u2192 Set \u03b1) :\n    \u22c3 h, s h = (\u22c3 i, s (Or.inl i)) \u222a \u22c3 j, s (Or.inr j)", "start": [879, 1], "end": [881, 10], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_and", "code": "theorem iUnion_and {p q : Prop} (s : p \u2227 q \u2192 Set \u03b1) : \u22c3 h, s h = \u22c3 (hp) (hq), s \u27e8hp, hq\u27e9", "start": [885, 1], "end": [886, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_and", "code": "theorem iInter_and {p q : Prop} (s : p \u2227 q \u2192 Set \u03b1) : \u22c2 h, s h = \u22c2 (hp) (hq), s \u27e8hp, hq\u27e9", "start": [890, 1], "end": [891, 11], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_comm", "code": "theorem iUnion_comm (s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1) : \u22c3 (i) (i'), s i i' = \u22c3 (i') (i), s i i'", "start": [896, 1], "end": [897, 12], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_comm", "code": "theorem iInter_comm (s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1) : \u22c2 (i) (i'), s i i' = \u22c2 (i') (i), s i i'", "start": [902, 1], "end": [903, 12], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_comm", "code": "theorem iUnion\u2082_comm (s : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Set \u03b1) :\n    \u22c3 (i\u2081) (j\u2081) (i\u2082) (j\u2082), s i\u2081 j\u2081 i\u2082 j\u2082 = \u22c3 (i\u2082) (j\u2082) (i\u2081) (j\u2081), s i\u2081 j\u2081 i\u2082 j\u2082", "start": [908, 1], "end": [910, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_comm", "code": "theorem iInter\u2082_comm (s : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Set \u03b1) :\n    \u22c2 (i\u2081) (j\u2081) (i\u2082) (j\u2082), s i\u2081 j\u2081 i\u2082 j\u2082 = \u22c2 (i\u2082) (j\u2082) (i\u2081) (j\u2081), s i\u2081 j\u2081 i\u2082 j\u2082", "start": [915, 1], "end": [917, 15], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_and", "code": "@[simp]\ntheorem biUnion_and (p : \u03b9 \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p x \u2227 q x y \u2192 Set \u03b1) :\n    \u22c3 (x : \u03b9) (y : \u03b9') (h : p x \u2227 q x y), s x y h =\n      \u22c3 (x : \u03b9) (hx : p x) (y : \u03b9') (hy : q x y), s x y \u27e8hx, hy\u27e9", "start": [920, 1], "end": [924, 47], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_and'", "code": "@[simp]\ntheorem biUnion_and' (p : \u03b9' \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p y \u2227 q x y \u2192 Set \u03b1) :\n    \u22c3 (x : \u03b9) (y : \u03b9') (h : p y \u2227 q x y), s x y h =\n      \u22c3 (y : \u03b9') (hy : p y) (x : \u03b9) (hx : q x y), s x y \u27e8hy, hx\u27e9", "start": [927, 1], "end": [931, 46], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_and", "code": "@[simp]\ntheorem biInter_and (p : \u03b9 \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p x \u2227 q x y \u2192 Set \u03b1) :\n    \u22c2 (x : \u03b9) (y : \u03b9') (h : p x \u2227 q x y), s x y h =\n      \u22c2 (x : \u03b9) (hx : p x) (y : \u03b9') (hy : q x y), s x y \u27e8hx, hy\u27e9", "start": [934, 1], "end": [938, 47], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_and'", "code": "@[simp]\ntheorem biInter_and' (p : \u03b9' \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p y \u2227 q x y \u2192 Set \u03b1) :\n    \u22c2 (x : \u03b9) (y : \u03b9') (h : p y \u2227 q x y), s x y h =\n      \u22c2 (y : \u03b9') (hy : p y) (x : \u03b9) (hx : q x y), s x y \u27e8hy, hx\u27e9", "start": [941, 1], "end": [945, 46], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iUnion_eq_or_left", "code": "@[simp]\ntheorem iUnion_iUnion_eq_or_left {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u2200 x : \u03b2, x = b \u2228 p x \u2192 Set \u03b1} :\n    \u22c3 (x) (h), s x h = s b (Or.inl rfl) \u222a \u22c3 (x) (h : p x), s x (Or.inr h)", "start": [949, 1], "end": [952, 69], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iInter_eq_or_left", "code": "@[simp]\ntheorem iInter_iInter_eq_or_left {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u2200 x : \u03b2, x = b \u2228 p x \u2192 Set \u03b1} :\n    \u22c2 (x) (h), s x h = s b (Or.inl rfl) \u2229 \u22c2 (x) (h : p x), s x (Or.inr h)", "start": [956, 1], "end": [959, 69], "kind": "commanddeclaration"}, {"full_name": "Set.mem_biUnion", "code": "theorem mem_biUnion {s : Set \u03b1} {t : \u03b1 \u2192 Set \u03b2} {x : \u03b1} {y : \u03b2} (xs : x \u2208 s) (ytx : y \u2208 t x) :\n    y \u2208 \u22c3 x \u2208 s, t x", "start": [965, 1], "end": [968, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mem_biInter", "code": "theorem mem_biInter {s : Set \u03b1} {t : \u03b1 \u2192 Set \u03b2} {y : \u03b2} (h : \u2200 x \u2208 s, y \u2208 t x) :\n    y \u2208 \u22c2 x \u2208 s, t x", "start": [971, 1], "end": [974, 23], "kind": "commanddeclaration"}, {"full_name": "Set.subset_biUnion_of_mem", "code": "theorem subset_biUnion_of_mem {s : Set \u03b1} {u : \u03b1 \u2192 Set \u03b2} {x : \u03b1} (xs : x \u2208 s) :\n    u x \u2286 \u22c3 x \u2208 s, u x", "start": [977, 1], "end": [981, 52], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_subset_of_mem", "code": "theorem biInter_subset_of_mem {s : Set \u03b1} {t : \u03b1 \u2192 Set \u03b2} {x : \u03b1} (xs : x \u2208 s) :\n    \u22c2 x \u2208 s, t x \u2286 t x", "start": [984, 1], "end": [987, 22], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_subset_biUnion_left", "code": "theorem biUnion_subset_biUnion_left {s s' : Set \u03b1} {t : \u03b1 \u2192 Set \u03b2} (h : s \u2286 s') :\n    \u22c3 x \u2208 s, t x \u2286 \u22c3 x \u2208 s', t x", "start": [990, 1], "end": [992, 59], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_subset_biInter_left", "code": "theorem biInter_subset_biInter_left {s s' : Set \u03b1} {t : \u03b1 \u2192 Set \u03b2} (h : s' \u2286 s) :\n    \u22c2 x \u2208 s, t x \u2286 \u22c2 x \u2208 s', t x", "start": [995, 1], "end": [997, 59], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_mono", "code": "theorem biUnion_mono {s s' : Set \u03b1} {t t' : \u03b1 \u2192 Set \u03b2} (hs : s' \u2286 s) (h : \u2200 x \u2208 s, t x \u2286 t' x) :\n    \u22c3 x \u2208 s', t x \u2286 \u22c3 x \u2208 s, t' x", "start": [1000, 1], "end": [1002, 59], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_mono", "code": "theorem biInter_mono {s s' : Set \u03b1} {t t' : \u03b1 \u2192 Set \u03b2} (hs : s \u2286 s') (h : \u2200 x \u2208 s, t x \u2286 t' x) :\n    \u22c2 x \u2208 s', t x \u2286 \u22c2 x \u2208 s, t' x", "start": [1005, 1], "end": [1007, 59], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_eq_iUnion", "code": "theorem biUnion_eq_iUnion (s : Set \u03b1) (t : \u2200 x \u2208 s, Set \u03b2) :\n    \u22c3 x \u2208 s, t x \u2039_\u203a = \u22c3 x : s, t x x.2", "start": [1010, 1], "end": [1012, 16], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_eq_iInter", "code": "theorem biInter_eq_iInter (s : Set \u03b1) (t : \u2200 x \u2208 s, Set \u03b2) :\n    \u22c2 x \u2208 s, t x \u2039_\u203a = \u22c2 x : s, t x x.2", "start": [1015, 1], "end": [1017, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_subtype", "code": "theorem iUnion_subtype (p : \u03b1 \u2192 Prop) (s : { x // p x } \u2192 Set \u03b2) :\n    \u22c3 x : { x // p x }, s x = \u22c3 (x) (hx : p x), s \u27e8x, hx\u27e9", "start": [1020, 1], "end": [1022, 15], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_subtype", "code": "theorem iInter_subtype (p : \u03b1 \u2192 Prop) (s : { x // p x } \u2192 Set \u03b2) :\n    \u22c2 x : { x // p x }, s x = \u22c2 (x) (hx : p x), s \u27e8x, hx\u27e9", "start": [1025, 1], "end": [1027, 15], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_empty", "code": "theorem biInter_empty (u : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 (\u2205 : Set \u03b1), u x = univ", "start": [1030, 1], "end": [1031, 16], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_univ", "code": "theorem biInter_univ (u : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 @univ \u03b1, u x = \u22c2 x, u x", "start": [1034, 1], "end": [1035, 12], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_self", "code": "@[simp]\ntheorem biUnion_self (s : Set \u03b1) : \u22c3 x \u2208 s, s = s", "start": [1038, 1], "end": [1040, 90], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_nonempty_self", "code": "@[simp]\ntheorem iUnion_nonempty_self (s : Set \u03b1) : \u22c3 _ : s.Nonempty, s = s", "start": [1043, 1], "end": [1045, 43], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_singleton", "code": "theorem biInter_singleton (a : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 ({a} : Set \u03b1), s x = s a", "start": [1048, 1], "end": [1049, 17], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_union", "code": "theorem biInter_union (s t : Set \u03b1) (u : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 s \u222a t, u x = (\u22c2 x \u2208 s, u x) \u2229 \u22c2 x \u2208 t, u x", "start": [1052, 1], "end": [1054, 13], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_insert", "code": "theorem biInter_insert (a : \u03b1) (s : Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 insert a s, t x = t a \u2229 \u22c2 x \u2208 s, t x", "start": [1057, 1], "end": [1058, 58], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_pair", "code": "theorem biInter_pair (a b : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 ({a, b} : Set \u03b1), s x = s a \u2229 s b", "start": [1061, 1], "end": [1062, 41], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_inter", "code": "theorem biInter_inter {\u03b9 \u03b1 : Type*} {s : Set \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) :\n    \u22c2 i \u2208 s, f i \u2229 t = (\u22c2 i \u2208 s, f i) \u2229 t", "start": [1065, 1], "end": [1068, 43], "kind": "commanddeclaration"}, {"full_name": "Set.inter_biInter", "code": "theorem inter_biInter {\u03b9 \u03b1 : Type*} {s : Set \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) :\n    \u22c2 i \u2208 s, t \u2229 f i = t \u2229 \u22c2 i \u2208 s, f i", "start": [1071, 1], "end": [1074, 20], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_empty", "code": "theorem biUnion_empty (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 (\u2205 : Set \u03b1), s x = \u2205", "start": [1077, 1], "end": [1078, 16], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_univ", "code": "theorem biUnion_univ (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 @univ \u03b1, s x = \u22c3 x, s x", "start": [1081, 1], "end": [1082, 12], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_singleton", "code": "theorem biUnion_singleton (a : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 ({a} : Set \u03b1), s x = s a", "start": [1085, 1], "end": [1086, 17], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_of_singleton", "code": "@[simp]\ntheorem biUnion_of_singleton (s : Set \u03b1) : \u22c3 x \u2208 s, {x} = s", "start": [1089, 1], "end": [1091, 17], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_union", "code": "theorem biUnion_union (s t : Set \u03b1) (u : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 s \u222a t, u x = (\u22c3 x \u2208 s, u x) \u222a \u22c3 x \u2208 t, u x", "start": [1094, 1], "end": [1096, 13], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_coe_set", "code": "@[simp]\ntheorem iUnion_coe_set {\u03b1 \u03b2 : Type*} (s : Set \u03b1) (f : s \u2192 Set \u03b2) :\n    \u22c3 i, f i = \u22c3 i \u2208 s, f \u27e8i, \u2039i \u2208 s\u203a\u27e9", "start": [1099, 1], "end": [1102, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_coe_set", "code": "@[simp]\ntheorem iInter_coe_set {\u03b1 \u03b2 : Type*} (s : Set \u03b1) (f : s \u2192 Set \u03b2) :\n    \u22c2 i, f i = \u22c2 i \u2208 s, f \u27e8i, \u2039i \u2208 s\u203a\u27e9", "start": [1105, 1], "end": [1108, 21], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_insert", "code": "theorem biUnion_insert (a : \u03b1) (s : Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 insert a s, t x = t a \u222a \u22c3 x \u2208 s, t x", "start": [1111, 1], "end": [1112, 58], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_pair", "code": "theorem biUnion_pair (a b : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 ({a, b} : Set \u03b1), s x = s a \u222a s b", "start": [1115, 1], "end": [1116, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inter_iUnion\u2082", "code": "theorem inter_iUnion\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u2229 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s \u2229 t i j", "start": [1121, 1], "end": [1122, 81], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_inter", "code": "theorem iUnion\u2082_inter (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c3 (i) (j), s i j) \u2229 t = \u22c3 (i) (j), s i j \u2229 t", "start": [1127, 1], "end": [1128, 79], "kind": "commanddeclaration"}, {"full_name": "Set.union_iInter\u2082", "code": "theorem union_iInter\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u222a \u22c2 (i) (j), t i j) = \u22c2 (i) (j), s \u222a t i j", "start": [1133, 1], "end": [1134, 79], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_union", "code": "theorem iInter\u2082_union (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) \u222a t = \u22c2 (i) (j), s i j \u222a t", "start": [1139, 1], "end": [1140, 79], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sUnion_of_mem", "code": "theorem mem_sUnion_of_mem {x : \u03b1} {t : Set \u03b1} {S : Set (Set \u03b1)} (hx : x \u2208 t) (ht : t \u2208 S) :\n    x \u2208 \u22c3\u2080S", "start": [1143, 1], "end": [1145, 14], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_of_not_mem_sUnion", "code": "theorem not_mem_of_not_mem_sUnion {x : \u03b1} {t : Set \u03b1} {S : Set (Set \u03b1)} (hx : x \u2209 \u22c3\u2080S)\n    (ht : t \u2208 S) : x \u2209 t", "start": [1149, 1], "end": [1150, 51], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_subset_of_mem", "code": "theorem sInter_subset_of_mem {S : Set (Set \u03b1)} {t : Set \u03b1} (tS : t \u2208 S) : \u22c2\u2080 S \u2286 t", "start": [1153, 1], "end": [1154, 13], "kind": "commanddeclaration"}, {"full_name": "Set.subset_sUnion_of_mem", "code": "theorem subset_sUnion_of_mem {S : Set (Set \u03b1)} {t : Set \u03b1} (tS : t \u2208 S) : t \u2286 \u22c3\u2080S", "start": [1157, 1], "end": [1158, 13], "kind": "commanddeclaration"}, {"full_name": "Set.subset_sUnion_of_subset", "code": "theorem subset_sUnion_of_subset {s : Set \u03b1} (t : Set (Set \u03b1)) (u : Set \u03b1) (h\u2081 : s \u2286 u)\n    (h\u2082 : u \u2208 t) : s \u2286 \u22c3\u2080t", "start": [1161, 1], "end": [1163, 44], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_subset", "code": "theorem sUnion_subset {S : Set (Set \u03b1)} {t : Set \u03b1} (h : \u2200 t' \u2208 S, t' \u2286 t) : \u22c3\u2080S \u2286 t", "start": [1166, 1], "end": [1167, 12], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_subset_iff", "code": "@[simp]\ntheorem sUnion_subset_iff {s : Set (Set \u03b1)} {t : Set \u03b1} : \u22c3\u2080s \u2286 t \u2194 \u2200 t' \u2208 s, t' \u2286 t", "start": [1170, 1], "end": [1172, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_mono_subsets", "code": "lemma sUnion_mono_subsets {s : Set (Set \u03b1)} {f : Set \u03b1 \u2192 Set \u03b1} (hf : \u2200 t : Set \u03b1, t \u2286 f t) :\n    \u22c3\u2080 s \u2286 \u22c3\u2080 (f '' s) :=\n  fun _ \u27e8t, htx, hxt\u27e9 \u21a6 \u27e8f t, mem_image_of_mem f htx, hf t hxt\u27e9", "start": [1175, 1], "end": [1178, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Set.sUnion_mono_supsets", "code": "lemma sUnion_mono_supsets {s : Set (Set \u03b1)} {f : Set \u03b1 \u2192 Set \u03b1} (hf : \u2200 t : Set \u03b1, f t \u2286 t) :\n    \u22c3\u2080 (f '' s) \u2286 \u22c3\u2080 s :=\n  fun _ \u27e8_, \u27e8u, hus, hut\u27e9, hxt\u27e9 \u21a6 \u27e8u, hus, (hut \u25b8 hf u) hxt\u27e9", "start": [1180, 1], "end": [1184, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Set.subset_sInter", "code": "theorem subset_sInter {S : Set (Set \u03b1)} {t : Set \u03b1} (h : \u2200 t' \u2208 S, t \u2286 t') : t \u2286 \u22c2\u2080 S", "start": [1186, 1], "end": [1187, 12], "kind": "commanddeclaration"}, {"full_name": "Set.subset_sInter_iff", "code": "@[simp]\ntheorem subset_sInter_iff {S : Set (Set \u03b1)} {t : Set \u03b1} : t \u2286 \u22c2\u2080 S \u2194 \u2200 t' \u2208 S, t \u2286 t'", "start": [1190, 1], "end": [1192, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_subset_sUnion", "code": "@[gcongr]\ntheorem sUnion_subset_sUnion {S T : Set (Set \u03b1)} (h : S \u2286 T) : \u22c3\u2080S \u2286 \u22c3\u2080T", "start": [1195, 1], "end": [1197, 56], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_subset_sInter", "code": "@[gcongr]\ntheorem sInter_subset_sInter {S T : Set (Set \u03b1)} (h : S \u2286 T) : \u22c2\u2080 T \u2286 \u22c2\u2080 S", "start": [1200, 1], "end": [1202, 56], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_empty", "code": "@[simp]\ntheorem sUnion_empty : \u22c3\u2080\u2205 = (\u2205 : Set \u03b1)", "start": [1205, 1], "end": [1207, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_empty", "code": "@[simp]\ntheorem sInter_empty : \u22c2\u2080 \u2205 = (univ : Set \u03b1)", "start": [1210, 1], "end": [1212, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_singleton", "code": "@[simp]\ntheorem sUnion_singleton (s : Set \u03b1) : \u22c3\u2080{s} = s", "start": [1215, 1], "end": [1217, 17], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_singleton", "code": "@[simp]\ntheorem sInter_singleton (s : Set \u03b1) : \u22c2\u2080 {s} = s", "start": [1220, 1], "end": [1222, 17], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_eq_empty", "code": "@[simp]\ntheorem sUnion_eq_empty {S : Set (Set \u03b1)} : \u22c3\u2080S = \u2205 \u2194 \u2200 s \u2208 S, s = \u2205", "start": [1225, 1], "end": [1227, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_eq_univ", "code": "@[simp]\ntheorem sInter_eq_univ {S : Set (Set \u03b1)} : \u22c2\u2080 S = univ \u2194 \u2200 s \u2208 S, s = univ", "start": [1230, 1], "end": [1232, 14], "kind": "commanddeclaration"}, {"full_name": "Set.subset_powerset_iff", "code": "theorem subset_powerset_iff {s : Set (Set \u03b1)} {t : Set \u03b1} : s \u2286 \ud835\udcab t \u2194 \u22c3\u2080 s \u2286 t", "start": [1235, 1], "end": [1236, 25], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_powerset_gc", "code": "theorem sUnion_powerset_gc :\n    GaloisConnection (\u22c3\u2080 \u00b7 : Set (Set \u03b1) \u2192 Set \u03b1) (\ud835\udcab \u00b7 : Set \u03b1 \u2192 Set (Set \u03b1))", "start": [1238, 1], "end": [1241, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_powerset_gi", "code": "def sUnion_powerset_gi :\n    GaloisInsertion (\u22c3\u2080 \u00b7 : Set (Set \u03b1) \u2192 Set \u03b1) (\ud835\udcab \u00b7 : Set \u03b1 \u2192 Set (Set \u03b1)) :=\n  gi_sSup_Iic", "start": [1243, 1], "end": [1246, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_mem_empty_univ", "code": "theorem sUnion_mem_empty_univ {S : Set (Set \u03b1)} (h : S \u2286 {\u2205, univ}) :\n    \u22c3\u2080 S \u2208 ({\u2205, univ} : Set (Set \u03b1))", "start": [1248, 1], "end": [1254, 53], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_sUnion", "code": "@[simp]\ntheorem nonempty_sUnion {S : Set (Set \u03b1)} : (\u22c3\u2080S).Nonempty \u2194 \u2203 s \u2208 S, Set.Nonempty s", "start": [1256, 1], "end": [1258, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_sUnion", "code": "theorem Nonempty.of_sUnion {s : Set (Set \u03b1)} (h : (\u22c3\u2080s).Nonempty) : s.Nonempty", "start": [1261, 1], "end": [1263, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_sUnion_eq_univ", "code": "theorem Nonempty.of_sUnion_eq_univ [Nonempty \u03b1] {s : Set (Set \u03b1)} (h : \u22c3\u2080s = univ) : s.Nonempty", "start": [1266, 1], "end": [1267, 47], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_union", "code": "theorem sUnion_union (S T : Set (Set \u03b1)) : \u22c3\u2080(S \u222a T) = \u22c3\u2080S \u222a \u22c3\u2080T", "start": [1270, 1], "end": [1271, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_union", "code": "theorem sInter_union (S T : Set (Set \u03b1)) : \u22c2\u2080 (S \u222a T) = \u22c2\u2080 S \u2229 \u22c2\u2080 T", "start": [1274, 1], "end": [1275, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_insert", "code": "@[simp]\ntheorem sUnion_insert (s : Set \u03b1) (T : Set (Set \u03b1)) : \u22c3\u2080insert s T = s \u222a \u22c3\u2080T", "start": [1278, 1], "end": [1280, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_insert", "code": "@[simp]\ntheorem sInter_insert (s : Set \u03b1) (T : Set (Set \u03b1)) : \u22c2\u2080 insert s T = s \u2229 \u22c2\u2080 T", "start": [1283, 1], "end": [1285, 14], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_diff_singleton_empty", "code": "@[simp]\ntheorem sUnion_diff_singleton_empty (s : Set (Set \u03b1)) : \u22c3\u2080(s \\ {\u2205}) = \u22c3\u2080s", "start": [1288, 1], "end": [1290, 28], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_diff_singleton_univ", "code": "@[simp]\ntheorem sInter_diff_singleton_univ (s : Set (Set \u03b1)) : \u22c2\u2080 (s \\ {univ}) = \u22c2\u2080 s", "start": [1293, 1], "end": [1295, 28], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_pair", "code": "theorem sUnion_pair (s t : Set \u03b1) : \u22c3\u2080{s, t} = s \u222a t", "start": [1298, 1], "end": [1299, 12], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_pair", "code": "theorem sInter_pair (s t : Set \u03b1) : \u22c2\u2080 {s, t} = s \u2229 t", "start": [1302, 1], "end": [1303, 12], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_image", "code": "@[simp]\ntheorem sUnion_image (f : \u03b1 \u2192 Set \u03b2) (s : Set \u03b1) : \u22c3\u2080(f '' s) = \u22c3 x \u2208 s, f x", "start": [1306, 1], "end": [1308, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_image", "code": "@[simp]\ntheorem sInter_image (f : \u03b1 \u2192 Set \u03b2) (s : Set \u03b1) : \u22c2\u2080 (f '' s) = \u22c2 x \u2208 s, f x", "start": [1311, 1], "end": [1313, 13], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_range", "code": "@[simp]\ntheorem sUnion_range (f : \u03b9 \u2192 Set \u03b2) : \u22c3\u2080range f = \u22c3 x, f x", "start": [1316, 1], "end": [1318, 6], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_range", "code": "@[simp]\ntheorem sInter_range (f : \u03b9 \u2192 Set \u03b2) : \u22c2\u2080 range f = \u22c2 x, f x", "start": [1321, 1], "end": [1323, 6], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_univ_iff", "code": "theorem iUnion_eq_univ_iff {f : \u03b9 \u2192 Set \u03b1} : \u22c3 i, f i = univ \u2194 \u2200 x, \u2203 i, x \u2208 f i", "start": [1326, 1], "end": [1327, 45], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_eq_univ_iff", "code": "theorem iUnion\u2082_eq_univ_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    \u22c3 (i) (j), s i j = univ \u2194 \u2200 a, \u2203 i j, a \u2208 s i j", "start": [1331, 1], "end": [1333, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_eq_univ_iff", "code": "theorem sUnion_eq_univ_iff {c : Set (Set \u03b1)} : \u22c3\u2080c = univ \u2194 \u2200 a, \u2203 b \u2208 c, a \u2208 b", "start": [1336, 1], "end": [1337, 45], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_empty_iff", "code": "theorem iInter_eq_empty_iff {f : \u03b9 \u2192 Set \u03b1} : \u22c2 i, f i = \u2205 \u2194 \u2200 x, \u2203 i, x \u2209 f i", "start": [1341, 1], "end": [1342, 41], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_eq_empty_iff", "code": "theorem iInter\u2082_eq_empty_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    \u22c2 (i) (j), s i j = \u2205 \u2194 \u2200 a, \u2203 i j, a \u2209 s i j", "start": [1347, 1], "end": [1349, 66], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_eq_empty_iff", "code": "theorem sInter_eq_empty_iff {c : Set (Set \u03b1)} : \u22c2\u2080 c = \u2205 \u2194 \u2200 a, \u2203 b \u2208 c, a \u2209 b", "start": [1353, 1], "end": [1354, 41], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iInter", "code": "@[simp]\ntheorem nonempty_iInter {f : \u03b9 \u2192 Set \u03b1} : (\u22c2 i, f i).Nonempty \u2194 \u2203 x, \u2200 i, x \u2208 f i", "start": [1358, 1], "end": [1360, 52], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iInter\u2082", "code": "theorem nonempty_iInter\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    (\u22c2 (i) (j), s i j).Nonempty \u2194 \u2203 a, \u2200 i j, a \u2208 s i j", "start": [1366, 1], "end": [1368, 7], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_sInter", "code": "@[simp]\ntheorem nonempty_sInter {c : Set (Set \u03b1)} : (\u22c2\u2080 c).Nonempty \u2194 \u2203 a, \u2200 b \u2208 c, a \u2208 b", "start": [1372, 1], "end": [1374, 52], "kind": "commanddeclaration"}, {"full_name": "Set.compl_sUnion", "code": "theorem compl_sUnion (S : Set (Set \u03b1)) : (\u22c3\u2080S)\u1d9c = \u22c2\u2080 (compl '' S)", "start": [1378, 1], "end": [1379, 23], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_eq_compl_sInter_compl", "code": "theorem sUnion_eq_compl_sInter_compl (S : Set (Set \u03b1)) : \u22c3\u2080S = (\u22c2\u2080 (compl '' S))\u1d9c", "start": [1383, 1], "end": [1384, 41], "kind": "commanddeclaration"}, {"full_name": "Set.compl_sInter", "code": "theorem compl_sInter (S : Set (Set \u03b1)) : (\u22c2\u2080 S)\u1d9c = \u22c3\u2080(compl '' S)", "start": [1388, 1], "end": [1389, 55], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_eq_compl_sUnion_compl", "code": "theorem sInter_eq_compl_sUnion_compl (S : Set (Set \u03b1)) : \u22c2\u2080 S = (\u22c3\u2080(compl '' S))\u1d9c", "start": [1393, 1], "end": [1394, 42], "kind": "commanddeclaration"}, {"full_name": "Set.inter_empty_of_inter_sUnion_empty", "code": "theorem inter_empty_of_inter_sUnion_empty {s t : Set \u03b1} {S : Set (Set \u03b1)} (hs : t \u2208 S)\n    (h : s \u2229 \u22c3\u2080S = \u2205) : s \u2229 t = \u2205", "start": [1397, 1], "end": [1400, 73], "kind": "commanddeclaration"}, {"full_name": "Set.range_sigma_eq_iUnion_range", "code": "theorem range_sigma_eq_iUnion_range {\u03b3 : \u03b1 \u2192 Type*} (f : Sigma \u03b3 \u2192 \u03b2) :\n    range f = \u22c3 a, range fun b => f \u27e8a, b\u27e9", "start": [1403, 1], "end": [1405, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_range_sigma", "code": "theorem iUnion_eq_range_sigma (s : \u03b1 \u2192 Set \u03b2) : \u22c3 i, s i = range fun a : \u03a3i, s i => a.2", "start": [1408, 1], "end": [1409, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_range_psigma", "code": "theorem iUnion_eq_range_psigma (s : \u03b9 \u2192 Set \u03b2) : \u22c3 i, s i = range fun a : \u03a3'i, s i => a.2", "start": [1412, 1], "end": [1413, 21], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_image_preimage_sigma_mk_eq_self", "code": "theorem iUnion_image_preimage_sigma_mk_eq_self {\u03b9 : Type*} {\u03c3 : \u03b9 \u2192 Type*} (s : Set (Sigma \u03c3)) :\n    \u22c3 i, Sigma.mk i '' (Sigma.mk i \u207b\u00b9' s) = s", "start": [1416, 1], "end": [1425, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Sigma.univ", "code": "theorem Sigma.univ (X : \u03b1 \u2192 Type*) : (Set.univ : Set (\u03a3a, X a)) = \u22c3 a, range (Sigma.mk a)", "start": [1428, 1], "end": [1430, 87], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_mono", "code": "alias sUnion_mono := sUnion_subset_sUnion", "start": [1433, 1], "end": [1433, 42], "kind": "stdtacticaliasalias"}, {"full_name": "Set.iUnion_subset_iUnion_const", "code": "theorem iUnion_subset_iUnion_const {s : Set \u03b1} (h : \u03b9 \u2192 \u03b9\u2082) : \u22c3 _ : \u03b9, s \u2286 \u22c3 _ : \u03b9\u2082, s", "start": [1436, 1], "end": [1437, 38], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_singleton_eq_range", "code": "@[simp]\ntheorem iUnion_singleton_eq_range {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) : \u22c3 x : \u03b1, {f x} = range f", "start": [1440, 1], "end": [1443, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_of_singleton", "code": "theorem iUnion_of_singleton (\u03b1 : Type*) : (\u22c3 x, {x} : Set \u03b1) = univ", "start": [1446, 1], "end": [1446, 93], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_of_singleton_coe", "code": "theorem iUnion_of_singleton_coe (s : Set \u03b1) : \u22c3 i : s, ({(i : \u03b1)} : Set \u03b1) = s", "start": [1449, 1], "end": [1449, 90], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_eq_biUnion", "code": "theorem sUnion_eq_biUnion {s : Set (Set \u03b1)} : \u22c3\u2080s = \u22c3 (i : Set \u03b1) (_ : i \u2208 s), i", "start": [1452, 1], "end": [1453, 33], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_eq_biInter", "code": "theorem sInter_eq_biInter {s : Set (Set \u03b1)} : \u22c2\u2080 s = \u22c2 (i : Set \u03b1) (_ : i \u2208 s), i", "start": [1456, 1], "end": [1457, 33], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_eq_iUnion", "code": "theorem sUnion_eq_iUnion {s : Set (Set \u03b1)} : \u22c3\u2080s = \u22c3 i : s, i", "start": [1460, 1], "end": [1461, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_eq_iInter", "code": "theorem sInter_eq_iInter {s : Set (Set \u03b1)} : \u22c2\u2080 s = \u22c2 i : s, i", "start": [1464, 1], "end": [1465, 48], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_of_empty", "code": "@[simp]\ntheorem iUnion_of_empty [IsEmpty \u03b9] (s : \u03b9 \u2192 Set \u03b1) : \u22c3 i, s i = \u2205", "start": [1468, 1], "end": [1470, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_of_empty", "code": "@[simp]\ntheorem iInter_of_empty [IsEmpty \u03b9] (s : \u03b9 \u2192 Set \u03b1) : \u22c2 i, s i = univ", "start": [1473, 1], "end": [1475, 18], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_iUnion", "code": "theorem union_eq_iUnion {s\u2081 s\u2082 : Set \u03b1} : s\u2081 \u222a s\u2082 = \u22c3 b : Bool, cond b s\u2081 s\u2082", "start": [1478, 1], "end": [1479, 20], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_iInter", "code": "theorem inter_eq_iInter {s\u2081 s\u2082 : Set \u03b1} : s\u2081 \u2229 s\u2082 = \u22c2 b : Bool, cond b s\u2081 s\u2082", "start": [1482, 1], "end": [1483, 20], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_union_sInter", "code": "theorem sInter_union_sInter {S T : Set (Set \u03b1)} :\n    \u22c2\u2080 S \u222a \u22c2\u2080 T = \u22c2 p \u2208 S \u00d7\u02e2 T, (p : Set \u03b1 \u00d7 Set \u03b1).1 \u222a p.2", "start": [1487, 1], "end": [1489, 16], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_inter_sUnion", "code": "theorem sUnion_inter_sUnion {s t : Set (Set \u03b1)} :\n    \u22c3\u2080s \u2229 \u22c3\u2080t = \u22c3 p \u2208 s \u00d7\u02e2 t, (p : Set \u03b1 \u00d7 Set \u03b1).1 \u2229 p.2", "start": [1493, 1], "end": [1495, 16], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_iUnion", "code": "theorem biUnion_iUnion (s : \u03b9 \u2192 Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 \u22c3 i, s i, t x = \u22c3 (i) (x \u2208 s i), t x", "start": [1498, 1], "end": [1499, 77], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_iUnion", "code": "theorem biInter_iUnion (s : \u03b9 \u2192 Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 \u22c3 i, s i, t x = \u22c2 (i) (x \u2208 s i), t x", "start": [1502, 1], "end": [1503, 77], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_iUnion", "code": "theorem sUnion_iUnion (s : \u03b9 \u2192 Set (Set \u03b1)) : \u22c3\u2080\u22c3 i, s i = \u22c3 i, \u22c3\u2080s i", "start": [1506, 1], "end": [1507, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_iUnion", "code": "theorem sInter_iUnion (s : \u03b9 \u2192 Set (Set \u03b1)) : \u22c2\u2080 \u22c3 i, s i = \u22c2 i, \u22c2\u2080 s i", "start": [1510, 1], "end": [1511, 48], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_range_eq_sUnion", "code": "theorem iUnion_range_eq_sUnion {\u03b1 \u03b2 : Type*} (C : Set (Set \u03b1)) {f : \u2200 s : C, \u03b2 \u2192 (s : Type _)}\n    (hf : \u2200 s : C, Surjective (f s)) : \u22c3 y : \u03b2, range (fun s : C => (f s y).val) = \u22c3\u2080C", "start": [1514, 1], "end": [1523, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_range_eq_iUnion", "code": "theorem iUnion_range_eq_iUnion (C : \u03b9 \u2192 Set \u03b1) {f : \u2200 x : \u03b9, \u03b2 \u2192 C x}\n    (hf : \u2200 x : \u03b9, Surjective (f x)) : \u22c3 y : \u03b2, range (fun x : \u03b9 => (f x y).val) = \u22c3 x, C x", "start": [1526, 1], "end": [1533, 43], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_iInter_left", "code": "theorem union_distrib_iInter_left (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (t \u222a \u22c2 i, s i) = \u22c2 i, t \u222a s i", "start": [1536, 1], "end": [1537, 18], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_iInter\u2082_left", "code": "theorem union_distrib_iInter\u2082_left (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u222a \u22c2 (i) (j), t i j) = \u22c2 (i) (j), s \u222a t i j", "start": [1542, 1], "end": [1543, 92], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_iInter_right", "code": "theorem union_distrib_iInter_right (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (\u22c2 i, s i) \u222a t = \u22c2 i, s i \u222a t", "start": [1546, 1], "end": [1547, 18], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_iInter\u2082_right", "code": "theorem union_distrib_iInter\u2082_right (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) \u222a t = \u22c2 (i) (j), s i j \u222a t", "start": [1552, 1], "end": [1553, 93], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_sUnion", "code": "theorem mapsTo_sUnion {S : Set (Set \u03b1)} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 s \u2208 S, MapsTo f s t) :\n    MapsTo f (\u22c3\u2080S) t", "start": [1561, 1], "end": [1562, 55], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iUnion", "code": "theorem mapsTo_iUnion {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, MapsTo f (s i) t) :\n    MapsTo f (\u22c3 i, s i) t", "start": [1565, 1], "end": [1567, 40], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iUnion\u2082", "code": "theorem mapsTo_iUnion\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, MapsTo f (s i j) t) : MapsTo f (\u22c3 (i) (j), s i j) t", "start": [1571, 1], "end": [1573, 45], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iUnion_iUnion", "code": "theorem mapsTo_iUnion_iUnion {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, MapsTo f (s i) (t i)) : MapsTo f (\u22c3 i, s i) (\u22c3 i, t i)", "start": [1576, 1], "end": [1578, 72], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iUnion\u2082_iUnion\u2082", "code": "theorem mapsTo_iUnion\u2082_iUnion\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, MapsTo f (s i j) (t i j)) : MapsTo f (\u22c3 (i) (j), s i j) (\u22c3 (i) (j), t i j)", "start": [1583, 1], "end": [1585, 59], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_sInter", "code": "theorem mapsTo_sInter {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} (H : \u2200 t \u2208 T, MapsTo f s t) :\n    MapsTo f s (\u22c2\u2080 T)", "start": [1588, 1], "end": [1589, 52], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iInter", "code": "theorem mapsTo_iInter {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, MapsTo f s (t i)) :\n    MapsTo f s (\u22c2 i, t i)", "start": [1592, 1], "end": [1593, 70], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iInter\u2082", "code": "theorem mapsTo_iInter\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, MapsTo f s (t i j)) : MapsTo f s (\u22c2 (i) (j), t i j)", "start": [1597, 1], "end": [1599, 45], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iInter_iInter", "code": "theorem mapsTo_iInter_iInter {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, MapsTo f (s i) (t i)) : MapsTo f (\u22c2 i, s i) (\u22c2 i, t i)", "start": [1602, 1], "end": [1604, 72], "kind": "commanddeclaration"}, {"full_name": "Set.mapsTo_iInter\u2082_iInter\u2082", "code": "theorem mapsTo_iInter\u2082_iInter\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, MapsTo f (s i j) (t i j)) : MapsTo f (\u22c2 (i) (j), s i j) (\u22c2 (i) (j), t i j)", "start": [1609, 1], "end": [1611, 59], "kind": "commanddeclaration"}, {"full_name": "Set.image_iInter_subset", "code": "theorem image_iInter_subset (s : \u03b9 \u2192 Set \u03b1) (f : \u03b1 \u2192 \u03b2) : (f '' \u22c2 i, s i) \u2286 \u22c2 i, f '' s i", "start": [1614, 1], "end": [1615, 68], "kind": "commanddeclaration"}, {"full_name": "Set.image_iInter\u2082_subset", "code": "theorem image_iInter\u2082_subset (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (f '' \u22c2 (i) (j), s i j) \u2286 \u22c2 (i) (j), f '' s i j", "start": [1620, 1], "end": [1622, 76], "kind": "commanddeclaration"}, {"full_name": "Set.image_sInter_subset", "code": "theorem image_sInter_subset (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) : f '' \u22c2\u2080 S \u2286 \u22c2 s \u2208 S, f '' s", "start": [1625, 1], "end": [1627, 29], "kind": "commanddeclaration"}, {"full_name": "Set.injective_iff_injective_of_iUnion_eq_univ", "code": "theorem injective_iff_injective_of_iUnion_eq_univ :\n    Injective f \u2194 \u2200 i, Injective ((U i).restrictPreimage f)", "start": [1639, 1], "end": [1644, 73], "kind": "commanddeclaration"}, {"full_name": "Set.surjective_iff_surjective_of_iUnion_eq_univ", "code": "theorem surjective_iff_surjective_of_iUnion_eq_univ :\n    Surjective f \u2194 \u2200 i, Surjective ((U i).restrictPreimage f)", "start": [1647, 1], "end": [1653, 61], "kind": "commanddeclaration"}, {"full_name": "Set.bijective_iff_bijective_of_iUnion_eq_univ", "code": "theorem bijective_iff_bijective_of_iUnion_eq_univ :\n    Bijective f \u2194 \u2200 i, Bijective ((U i).restrictPreimage f)", "start": [1656, 1], "end": [1660, 31], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.image_iInter_eq", "code": "theorem InjOn.image_iInter_eq [Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1} {f : \u03b1 \u2192 \u03b2} (h : InjOn f (\u22c3 i, s i)) :\n    (f '' \u22c2 i, s i) = \u22c2 i, f '' s i", "start": [1668, 1], "end": [1680, 17], "kind": "commanddeclaration"}, {"full_name": "Set.InjOn.image_biInter_eq", "code": "theorem InjOn.image_biInter_eq {p : \u03b9 \u2192 Prop} {s : \u2200 (i) (_ : p i), Set \u03b1} (hp : \u2203 i, p i)\n    {f : \u03b1 \u2192 \u03b2} (h : InjOn f (\u22c3 (i) (hi), s i hi)) :\n    (f '' \u22c2 (i) (hi), s i hi) = \u22c2 (i) (hi), f '' s i hi", "start": [1686, 1], "end": [1692, 45], "kind": "commanddeclaration"}, {"full_name": "Set.image_iInter", "code": "theorem image_iInter {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (s : \u03b9 \u2192 Set \u03b1) :\n    (f '' \u22c2 i, s i) = \u22c2 i, f '' s i", "start": [1695, 1], "end": [1699, 49], "kind": "commanddeclaration"}, {"full_name": "Set.image_iInter\u2082", "code": "theorem image_iInter\u2082 {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (s : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (f '' \u22c2 (i) (j), s i j) = \u22c2 (i) (j), f '' s i j", "start": [1704, 1], "end": [1705, 84], "kind": "commanddeclaration"}, {"full_name": "Set.inj_on_iUnion_of_directed", "code": "theorem inj_on_iUnion_of_directed {s : \u03b9 \u2192 Set \u03b1} (hs : Directed (\u00b7 \u2286 \u00b7) s) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, InjOn f (s i)) : InjOn f (\u22c3 i, s i)", "start": [1708, 1], "end": [1714, 33], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_sUnion", "code": "theorem surjOn_sUnion {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} (H : \u2200 t \u2208 T, SurjOn f s t) :\n    SurjOn f s (\u22c3\u2080T)", "start": [1720, 1], "end": [1721, 55], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iUnion", "code": "theorem surjOn_iUnion {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, SurjOn f s (t i)) :\n    SurjOn f s (\u22c3 i, t i)", "start": [1724, 1], "end": [1726, 40], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iUnion_iUnion", "code": "theorem surjOn_iUnion_iUnion {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, SurjOn f (s i) (t i)) : SurjOn f (\u22c3 i, s i) (\u22c3 i, t i)", "start": [1729, 1], "end": [1731, 72], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iUnion\u2082", "code": "theorem surjOn_iUnion\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, SurjOn f s (t i j)) : SurjOn f s (\u22c3 (i) (j), t i j)", "start": [1735, 1], "end": [1737, 45], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iUnion\u2082_iUnion\u2082", "code": "theorem surjOn_iUnion\u2082_iUnion\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i j, SurjOn f (s i j) (t i j)) : SurjOn f (\u22c3 (i) (j), s i j) (\u22c3 (i) (j), t i j)", "start": [1742, 1], "end": [1744, 59], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iInter", "code": "theorem surjOn_iInter [Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, SurjOn f (s i) t) (Hinj : InjOn f (\u22c3 i, s i)) : SurjOn f (\u22c2 i, s i) t", "start": [1747, 1], "end": [1751, 24], "kind": "commanddeclaration"}, {"full_name": "Set.surjOn_iInter_iInter", "code": "theorem surjOn_iInter_iInter [Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, SurjOn f (s i) (t i)) (Hinj : InjOn f (\u22c3 i, s i)) : SurjOn f (\u22c2 i, s i) (\u22c2 i, t i)", "start": [1754, 1], "end": [1756, 79], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_iUnion", "code": "theorem bijOn_iUnion {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, BijOn f (s i) (t i))\n    (Hinj : InjOn f (\u22c3 i, s i)) : BijOn f (\u22c3 i, s i) (\u22c3 i, t i)", "start": [1762, 1], "end": [1764, 97], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_iInter", "code": "theorem bijOn_iInter [hi : Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (H : \u2200 i, BijOn f (s i) (t i)) (Hinj : InjOn f (\u22c3 i, s i)) : BijOn f (\u22c2 i, s i) (\u22c2 i, t i)", "start": [1767, 1], "end": [1771, 55], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_iUnion_of_directed", "code": "theorem bijOn_iUnion_of_directed {s : \u03b9 \u2192 Set \u03b1} (hs : Directed (\u00b7 \u2286 \u00b7) s) {t : \u03b9 \u2192 Set \u03b2}\n    {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, BijOn f (s i) (t i)) : BijOn f (\u22c3 i, s i) (\u22c3 i, t i)", "start": [1774, 1], "end": [1776, 70], "kind": "commanddeclaration"}, {"full_name": "Set.bijOn_iInter_of_directed", "code": "theorem bijOn_iInter_of_directed [Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hs : Directed (\u00b7 \u2286 \u00b7) s)\n    {t : \u03b9 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (H : \u2200 i, BijOn f (s i) (t i)) : BijOn f (\u22c2 i, s i) (\u22c2 i, t i)", "start": [1779, 1], "end": [1781, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_iUnion", "code": "theorem image_iUnion {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b1} : (f '' \u22c3 i, s i) = \u22c3 i, f '' s i", "start": [1791, 1], "end": [1795, 19], "kind": "commanddeclaration"}, {"full_name": "Set.image_iUnion\u2082", "code": "theorem image_iUnion\u2082 (f : \u03b1 \u2192 \u03b2) (s : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (f '' \u22c3 (i) (j), s i j) = \u22c3 (i) (j), f '' s i j", "start": [1800, 1], "end": [1801, 81], "kind": "commanddeclaration"}, {"full_name": "Set.univ_subtype", "code": "theorem univ_subtype {p : \u03b1 \u2192 Prop} : (univ : Set (Subtype p)) = \u22c3 (x) (h : p x), {\u27e8x, h\u27e9}", "start": [1804, 1], "end": [1805, 36], "kind": "commanddeclaration"}, {"full_name": "Set.range_eq_iUnion", "code": "theorem range_eq_iUnion {\u03b9} (f : \u03b9 \u2192 \u03b1) : range f = \u22c3 i, {f i}", "start": [1808, 1], "end": [1809, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_iUnion", "code": "theorem image_eq_iUnion (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : f '' s = \u22c3 i \u2208 s, {f i}", "start": [1812, 1], "end": [1813, 42], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_range", "code": "theorem biUnion_range {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} : \u22c3 x \u2208 range f, g x = \u22c3 y, g (f y)", "start": [1816, 1], "end": [1817, 13], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iUnion_eq'", "code": "@[simp]\ntheorem iUnion_iUnion_eq' {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} :\n    \u22c3 (x) (y) (_ : f y = x), g x = \u22c3 y, g (f y)", "start": [1821, 1], "end": [1823, 80], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_range", "code": "theorem biInter_range {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} : \u22c2 x \u2208 range f, g x = \u22c2 y, g (f y)", "start": [1826, 1], "end": [1827, 13], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iInter_eq'", "code": "@[simp]\ntheorem iInter_iInter_eq' {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} :\n    \u22c2 (x) (y) (_ : f y = x), g x = \u22c2 y, g (f y)", "start": [1831, 1], "end": [1833, 80], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_image", "code": "theorem biUnion_image : \u22c3 x \u2208 f '' s, g x = \u22c3 y \u2208 s, g (f y)", "start": [1838, 1], "end": [1839, 13], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_image", "code": "theorem biInter_image : \u22c2 x \u2208 f '' s, g x = \u22c2 y \u2208 s, g (f y)", "start": [1842, 1], "end": [1843, 13], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_preimage", "code": "theorem monotone_preimage {f : \u03b1 \u2192 \u03b2} : Monotone (preimage f)", "start": [1850, 1], "end": [1850, 94], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iUnion", "code": "@[simp]\ntheorem preimage_iUnion {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b2} : (f \u207b\u00b9' \u22c3 i, s i) = \u22c3 i, f \u207b\u00b9' s i", "start": [1853, 1], "end": [1855, 32], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iUnion\u2082", "code": "theorem preimage_iUnion\u2082 {f : \u03b1 \u2192 \u03b2} {s : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (f \u207b\u00b9' \u22c3 (i) (j), s i j) = \u22c3 (i) (j), f \u207b\u00b9' s i j", "start": [1860, 1], "end": [1861, 86], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sUnion", "code": "@[simp]\ntheorem preimage_sUnion {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} : f \u207b\u00b9' \u22c3\u2080s = \u22c3 t \u2208 s, f \u207b\u00b9' t", "start": [1864, 1], "end": [1866, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iInter", "code": "theorem preimage_iInter {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b2} : (f \u207b\u00b9' \u22c2 i, s i) = \u22c2 i, f \u207b\u00b9' s i", "start": [1869, 1], "end": [1870, 12], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iInter\u2082", "code": "theorem preimage_iInter\u2082 {f : \u03b1 \u2192 \u03b2} {s : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (f \u207b\u00b9' \u22c2 (i) (j), s i j) = \u22c2 (i) (j), f \u207b\u00b9' s i j", "start": [1875, 1], "end": [1876, 86], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sInter", "code": "@[simp]\ntheorem preimage_sInter {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} : f \u207b\u00b9' \u22c2\u2080 s = \u22c2 t \u2208 s, f \u207b\u00b9' t", "start": [1879, 1], "end": [1881, 43], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_preimage_singleton", "code": "@[simp]\ntheorem biUnion_preimage_singleton (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : \u22c3 y \u2208 s, f \u207b\u00b9' {y} = f \u207b\u00b9' s", "start": [1884, 1], "end": [1886, 48], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_range_preimage_singleton", "code": "theorem biUnion_range_preimage_singleton (f : \u03b1 \u2192 \u03b2) : \u22c3 y \u2208 range f, f \u207b\u00b9' {y} = univ", "start": [1889, 1], "end": [1890, 50], "kind": "commanddeclaration"}, {"full_name": "Set.prod_iUnion", "code": "theorem prod_iUnion {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} : (s \u00d7\u02e2 \u22c3 i, t i) = \u22c3 i, s \u00d7\u02e2 t i", "start": [1899, 1], "end": [1901, 7], "kind": "commanddeclaration"}, {"full_name": "Set.prod_iUnion\u2082", "code": "theorem prod_iUnion\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (s \u00d7\u02e2 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s \u00d7\u02e2 t i j", "start": [1908, 1], "end": [1909, 80], "kind": "commanddeclaration"}, {"full_name": "Set.prod_sUnion", "code": "theorem prod_sUnion {s : Set \u03b1} {C : Set (Set \u03b2)} : s \u00d7\u02e2 \u22c3\u2080C = \u22c3\u2080((fun t => s \u00d7\u02e2 t) '' C)", "start": [1914, 1], "end": [1915, 59], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_prod_const", "code": "theorem iUnion_prod_const {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b2} : (\u22c3 i, s i) \u00d7\u02e2 t = \u22c3 i, s i \u00d7\u02e2 t", "start": [1920, 1], "end": [1922, 7], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_prod_const", "code": "theorem iUnion\u2082_prod_const {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b2} :\n    (\u22c3 (i) (j), s i j) \u00d7\u02e2 t = \u22c3 (i) (j), s i j \u00d7\u02e2 t", "start": [1929, 1], "end": [1930, 86], "kind": "commanddeclaration"}, {"full_name": "Set.sUnion_prod_const", "code": "theorem sUnion_prod_const {C : Set (Set \u03b1)} {t : Set \u03b2} :\n    \u22c3\u2080C \u00d7\u02e2 t = \u22c3\u2080((fun s : Set \u03b1 => s \u00d7\u02e2 t) '' C)", "start": [1935, 1], "end": [1937, 67], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_prod", "code": "theorem iUnion_prod {\u03b9 \u03b9' \u03b1 \u03b2} (s : \u03b9 \u2192 Set \u03b1) (t : \u03b9' \u2192 Set \u03b2) :\n    \u22c3 x : \u03b9 \u00d7 \u03b9', s x.1 \u00d7\u02e2 t x.2 = (\u22c3 i : \u03b9, s i) \u00d7\u02e2 \u22c3 i : \u03b9', t i", "start": [1942, 1], "end": [1945, 7], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_prod'", "code": "lemma iUnion_prod' (f : \u03b2 \u00d7 \u03b3 \u2192 Set \u03b1) : \u22c3 x : \u03b2 \u00d7 \u03b3, f x = \u22c3 (i : \u03b2) (j : \u03b3), f (i, j) :=\n  iSup_prod", "start": [1948, 1], "end": [1950, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Set.iUnion_prod_of_monotone", "code": "theorem iUnion_prod_of_monotone [SemilatticeSup \u03b1] {s : \u03b1 \u2192 Set \u03b2} {t : \u03b1 \u2192 Set \u03b3} (hs : Monotone s)\n    (ht : Monotone t) : \u22c3 x, s x \u00d7\u02e2 t x = (\u22c3 x, s x) \u00d7\u02e2 \u22c3 x, t x", "start": [1954, 1], "end": [1960, 58], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_prod_sInter_subset", "code": "theorem sInter_prod_sInter_subset (S : Set (Set \u03b1)) (T : Set (Set \u03b2)) :\n    \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T \u2286 \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2", "start": [1966, 1], "end": [1968, 65], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_prod_sInter", "code": "theorem sInter_prod_sInter {S : Set (Set \u03b1)} {T : Set (Set \u03b2)} (hS : S.Nonempty) (hT : T.Nonempty) :\n    \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T = \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2", "start": [1974, 1], "end": [1980, 87], "kind": "commanddeclaration"}, {"full_name": "Set.sInter_prod", "code": "theorem sInter_prod {S : Set (Set \u03b1)} (hS : S.Nonempty) (t : Set \u03b2) :\n    \u22c2\u2080 S \u00d7\u02e2 t = \u22c2 s \u2208 S, s \u00d7\u02e2 t", "start": [1985, 1], "end": [1988, 91], "kind": "commanddeclaration"}, {"full_name": "Set.prod_sInter", "code": "theorem prod_sInter {T : Set (Set \u03b2)} (hT : T.Nonempty) (s : Set \u03b1) :\n    s \u00d7\u02e2 \u22c2\u2080 T = \u22c2 t \u2208 T, s \u00d7\u02e2 t", "start": [1993, 1], "end": [1996, 91], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_image_left", "code": "theorem iUnion_image_left : \u22c3 a \u2208 s, f a '' t = image2 f s t", "start": [2005, 1], "end": [2007, 100], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_image_right", "code": "theorem iUnion_image_right : \u22c3 b \u2208 t, (fun a => f a b) '' s = image2 f s t", "start": [2010, 1], "end": [2014, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iUnion_left", "code": "theorem image2_iUnion_left (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c3 i, s i) t = \u22c3 i, image2 f (s i) t", "start": [2017, 1], "end": [2019, 60], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iUnion_right", "code": "theorem image2_iUnion_right (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) :\n    image2 f s (\u22c3 i, t i) = \u22c3 i, image2 f s (t i)", "start": [2022, 1], "end": [2024, 54], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iUnion\u2082_left", "code": "theorem image2_iUnion\u2082_left (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c3 (i) (j), s i j) t = \u22c3 (i) (j), image2 f (s i j) t", "start": [2029, 1], "end": [2030, 101], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iUnion\u2082_right", "code": "theorem image2_iUnion\u2082_right (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    image2 f s (\u22c3 (i) (j), t i j) = \u22c3 (i) (j), image2 f s (t i j)", "start": [2035, 1], "end": [2037, 35], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iInter_subset_left", "code": "theorem image2_iInter_subset_left (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c2 i, s i) t \u2286 \u22c2 i, image2 f (s i) t", "start": [2040, 1], "end": [2043, 55], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iInter_subset_right", "code": "theorem image2_iInter_subset_right (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) :\n    image2 f s (\u22c2 i, t i) \u2286 \u22c2 i, image2 f s (t i)", "start": [2046, 1], "end": [2049, 55], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iInter\u2082_subset_left", "code": "theorem image2_iInter\u2082_subset_left (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c2 (i) (j), s i j) t \u2286 \u22c2 (i) (j), image2 f (s i j) t", "start": [2054, 1], "end": [2057, 59], "kind": "commanddeclaration"}, {"full_name": "Set.image2_iInter\u2082_subset_right", "code": "theorem image2_iInter\u2082_subset_right (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    image2 f s (\u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), image2 f s (t i j)", "start": [2062, 1], "end": [2065, 59], "kind": "commanddeclaration"}, {"full_name": "Set.image2_eq_iUnion", "code": "theorem image2_eq_iUnion (s : Set \u03b1) (t : Set \u03b2) : image2 f s t = \u22c3 (i \u2208 s) (j \u2208 t), {f i j}", "start": [2068, 1], "end": [2070, 49], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_biUnion_left", "code": "theorem prod_eq_biUnion_left : s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t", "start": [2074, 1], "end": [2075, 44], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_biUnion_right", "code": "theorem prod_eq_biUnion_right : s \u00d7\u02e2 t = \u22c3 b \u2208 t, (fun a => (a, b)) '' s", "start": [2079, 1], "end": [2080, 45], "kind": "commanddeclaration"}, {"full_name": "Set.seq", "code": "def seq (s : Set (\u03b1 \u2192 \u03b2)) (t : Set \u03b1) : Set \u03b2 :=\n  { b | \u2203 f \u2208 s, \u2203 a \u2208 t, (f : \u03b1 \u2192 \u03b2) a = b }", "start": [2087, 1], "end": [2090, 46], "kind": "commanddeclaration"}, {"full_name": "Set.seq_def", "code": "theorem seq_def {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} : seq s t = \u22c3 f \u2208 s, f '' t", "start": [2093, 1], "end": [2094, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mem_seq_iff", "code": "@[simp]\ntheorem mem_seq_iff {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} {b : \u03b2} :\n    b \u2208 seq s t \u2194 \u2203 f \u2208 s, \u2203 a \u2208 t, (f : \u03b1 \u2192 \u03b2) a = b", "start": [2097, 1], "end": [2100, 10], "kind": "commanddeclaration"}, {"full_name": "Set.seq_subset", "code": "theorem seq_subset {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} {u : Set \u03b2} :\n    seq s t \u2286 u \u2194 \u2200 f \u2208 s, \u2200 a \u2208 t, (f : \u03b1 \u2192 \u03b2) a \u2208 u", "start": [2103, 1], "end": [2106, 21], "kind": "commanddeclaration"}, {"full_name": "Set.seq_mono", "code": "@[gcongr]\ntheorem seq_mono {s\u2080 s\u2081 : Set (\u03b1 \u2192 \u03b2)} {t\u2080 t\u2081 : Set \u03b1} (hs : s\u2080 \u2286 s\u2081) (ht : t\u2080 \u2286 t\u2081) :\n    seq s\u2080 t\u2080 \u2286 seq s\u2081 t\u2081", "start": [2109, 1], "end": [2111, 82], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_seq", "code": "theorem singleton_seq {f : \u03b1 \u2192 \u03b2} {t : Set \u03b1} : Set.seq ({f} : Set (\u03b1 \u2192 \u03b2)) t = f '' t", "start": [2114, 1], "end": [2115, 21], "kind": "commanddeclaration"}, {"full_name": "Set.seq_singleton", "code": "theorem seq_singleton {s : Set (\u03b1 \u2192 \u03b2)} {a : \u03b1} : Set.seq s {a} = (fun f : \u03b1 \u2192 \u03b2 => f a) '' s", "start": [2118, 1], "end": [2119, 21], "kind": "commanddeclaration"}, {"full_name": "Set.seq_seq", "code": "theorem seq_seq {s : Set (\u03b2 \u2192 \u03b3)} {t : Set (\u03b1 \u2192 \u03b2)} {u : Set \u03b1} :\n    seq s (seq t u) = seq (seq ((\u00b7 \u2218 \u00b7) '' s) t) u", "start": [2122, 1], "end": [2128, 51], "kind": "commanddeclaration"}, {"full_name": "Set.image_seq", "code": "theorem image_seq {f : \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} :\n    f '' seq s t = seq ((\u00b7 \u2218 \u00b7) f '' s) t", "start": [2131, 1], "end": [2133, 66], "kind": "commanddeclaration"}, {"full_name": "Set.prod_eq_seq", "code": "theorem prod_eq_seq {s : Set \u03b1} {t : Set \u03b2} : s \u00d7\u02e2 t = (Prod.mk '' s).seq t", "start": [2137, 1], "end": [2144, 19], "kind": "commanddeclaration"}, {"full_name": "Set.prod_image_seq_comm", "code": "theorem prod_image_seq_comm (s : Set \u03b1) (t : Set \u03b2) :\n    (Prod.mk '' s).seq t = seq ((fun b a => (a, b)) '' t) s", "start": [2147, 1], "end": [2149, 83], "kind": "commanddeclaration"}, {"full_name": "Set.image2_eq_seq", "code": "theorem image2_eq_seq (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) : image2 f s t = seq (f '' s) t", "start": [2152, 1], "end": [2154, 7], "kind": "commanddeclaration"}, {"full_name": "Set.pi_def", "code": "theorem pi_def (i : Set \u03b1) (s : \u2200 a, Set (\u03c0 a)) : pi i s = \u22c2 a \u2208 i, eval a \u207b\u00b9' s a", "start": [2163, 1], "end": [2165, 7], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pi_eq_iInter", "code": "theorem univ_pi_eq_iInter (t : \u2200 i, Set (\u03c0 i)) : pi univ t = \u22c2 i, eval i \u207b\u00b9' t i", "start": [2168, 1], "end": [2169, 44], "kind": "commanddeclaration"}, {"full_name": "Set.pi_diff_pi_subset", "code": "theorem pi_diff_pi_subset (i : Set \u03b1) (s t : \u2200 a, Set (\u03c0 a)) :\n    pi i s \\ pi i t \u2286 \u22c3 a \u2208 i, eval a \u207b\u00b9' (s a \\ t a)", "start": [2172, 1], "end": [2177, 30], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_univ_pi", "code": "theorem iUnion_univ_pi (t : \u2200 i, \u03b9 \u2192 Set (\u03c0 i)) :\n    \u22c3 x : \u03b1 \u2192 \u03b9, pi univ (fun i => t i (x i)) = pi univ fun i => \u22c3 j : \u03b9, t i j", "start": [2180, 1], "end": [2183, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iUnion_comp", "code": "theorem iUnion_comp {f : \u03b9 \u2192 \u03b9\u2082} (hf : Surjective f) (g : \u03b9\u2082 \u2192 Set \u03b1) : \u22c3 x, g (f x) = \u22c3 y, g y", "start": [2194, 1], "end": [2195, 17], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iInter_comp", "code": "theorem iInter_comp {f : \u03b9 \u2192 \u03b9\u2082} (hf : Surjective f) (g : \u03b9\u2082 \u2192 Set \u03b1) : \u22c2 x, g (f x) = \u22c2 y, g y", "start": [2198, 1], "end": [2199, 17], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iUnion_left", "code": "@[simp]\ntheorem disjoint_iUnion_left {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} :\n    Disjoint (\u22c3 i, s i) t \u2194 \u2200 i, Disjoint (s i) t", "start": [2217, 1], "end": [2220, 20], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iUnion_right", "code": "@[simp]\ntheorem disjoint_iUnion_right {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} :\n    Disjoint t (\u22c3 i, s i) \u2194 \u2200 i, Disjoint t (s i)", "start": [2223, 1], "end": [2226, 20], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iUnion\u2082_left", "code": "theorem disjoint_iUnion\u2082_left {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b1} :\n    Disjoint (\u22c3 (i) (j), s i j) t \u2194 \u2200 i j, Disjoint (s i j) t", "start": [2231, 1], "end": [2233, 21], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iUnion\u2082_right", "code": "theorem disjoint_iUnion\u2082_right {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    Disjoint s (\u22c3 (i) (j), t i j) \u2194 \u2200 i j, Disjoint s (t i j)", "start": [2238, 1], "end": [2240, 21], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_sUnion_left", "code": "@[simp]\ntheorem disjoint_sUnion_left {S : Set (Set \u03b1)} {t : Set \u03b1} :\n    Disjoint (\u22c3\u2080S) t \u2194 \u2200 s \u2208 S, Disjoint s t", "start": [2243, 1], "end": [2246, 20], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_sUnion_right", "code": "@[simp]\ntheorem disjoint_sUnion_right {s : Set \u03b1} {S : Set (Set \u03b1)} :\n    Disjoint s (\u22c3\u2080S) \u2194 \u2200 t \u2208 S, Disjoint s t", "start": [2249, 1], "end": [2252, 20], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iInter_Iic_iff", "code": "lemma nonempty_iInter_Iic_iff [Preorder \u03b1] {f : \u03b9 \u2192 \u03b1} :\n    (\u22c2 i, Iic (f i)).Nonempty \u2194 BddBelow (range f) := by\n  have : (\u22c2 (i : \u03b9), Iic (f i)) = lowerBounds (range f) := by\n    ext c; simp [lowerBounds]\n  simp [this, BddBelow]", "start": [2263, 1], "end": [2267, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Set.nonempty_iInter_Ici_iff", "code": "lemma nonempty_iInter_Ici_iff [Preorder \u03b1] {f : \u03b9 \u2192 \u03b1} :\n    (\u22c2 i, Ici (f i)).Nonempty \u2194 BddAbove (range f) :=\n  nonempty_iInter_Iic_iff (\u03b1 := \u03b1\u1d52\u1d48)", "start": [2269, 1], "end": [2271, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Ici_iSup", "code": "theorem Ici_iSup (f : \u03b9 \u2192 \u03b1) : Ici (\u2a06 i, f i) = \u22c2 i, Ici (f i)", "start": [2275, 1], "end": [2276, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_iInf", "code": "theorem Iic_iInf (f : \u03b9 \u2192 \u03b1) : Iic (\u2a05 i, f i) = \u22c2 i, Iic (f i)", "start": [2279, 1], "end": [2280, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_iSup\u2082", "code": "theorem Ici_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Ici (\u2a06 (i) (j), f i j) = \u22c2 (i) (j), Ici (f i j)", "start": [2285, 1], "end": [2286, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_iInf\u2082", "code": "theorem Iic_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Iic (\u2a05 (i) (j), f i j) = \u22c2 (i) (j), Iic (f i j)", "start": [2291, 1], "end": [2292, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_sSup", "code": "theorem Ici_sSup (s : Set \u03b1) : Ici (sSup s) = \u22c2 a \u2208 s, Ici a", "start": [2295, 1], "end": [2295, 96], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_sInf", "code": "theorem Iic_sInf (s : Set \u03b1) : Iic (sInf s) = \u22c2 a \u2208 s, Iic a", "start": [2298, 1], "end": [2298, 96], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_diff_biUnion_subset", "code": "theorem biUnion_diff_biUnion_subset (s\u2081 s\u2082 : Set \u03b1) :\n    ((\u22c3 x \u2208 s\u2081, t x) \\ \u22c3 x \u2208 s\u2082, t x) \u2286 \u22c3 x \u2208 s\u2081 \\ s\u2082, t x", "start": [2307, 1], "end": [2312, 27], "kind": "commanddeclaration"}, {"full_name": "Set.sigmaToiUnion", "code": "def sigmaToiUnion (x : \u03a3i, t i) : \u22c3 i, t i :=\n  \u27e8x.2, mem_iUnion.2 \u27e8x.1, x.2.2\u27e9\u27e9", "start": [2315, 1], "end": [2318, 35], "kind": "commanddeclaration"}, {"full_name": "Set.sigmaToiUnion_surjective", "code": "theorem sigmaToiUnion_surjective : Surjective (sigmaToiUnion t)", "start": [2321, 1], "end": [2325, 22], "kind": "commanddeclaration"}, {"full_name": "Set.sigmaToiUnion_injective", "code": "theorem sigmaToiUnion_injective (h : \u2200 i j, i \u2260 j \u2192 Disjoint (t i) (t j)) :\n    Injective (sigmaToiUnion t)", "start": [2328, 1], "end": [2336, 66], "kind": "commanddeclaration"}, {"full_name": "Set.sigmaToiUnion_bijective", "code": "theorem sigmaToiUnion_bijective (h : \u2200 i j, i \u2260 j \u2192 Disjoint (t i) (t j)) :\n    Bijective (sigmaToiUnion t)", "start": [2339, 1], "end": [2341, 60], "kind": "commanddeclaration"}, {"full_name": "Set.unionEqSigmaOfDisjoint", "code": "noncomputable def unionEqSigmaOfDisjoint {t : \u03b1 \u2192 Set \u03b2} (h : \u2200 i j, i \u2260 j \u2192 Disjoint (t i) (t j)) :\n    (\u22c3 i, t i) \u2243 \u03a3i, t i :=\n  (Equiv.ofBijective _ <| sigmaToiUnion_bijective t h).symm", "start": [2344, 1], "end": [2347, 60], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_ge_eq_iUnion_nat_add", "code": "theorem iUnion_ge_eq_iUnion_nat_add (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c3 i \u2265 n, u i = \u22c3 i, u (i + n)", "start": [2350, 1], "end": [2351, 30], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_ge_eq_iInter_nat_add", "code": "theorem iInter_ge_eq_iInter_nat_add (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c2 i \u2265 n, u i = \u22c2 i, u (i + n)", "start": [2354, 1], "end": [2355, 30], "kind": "commanddeclaration"}, {"full_name": "Monotone.iUnion_nat_add", "code": "theorem _root_.Monotone.iUnion_nat_add {f : \u2115 \u2192 Set \u03b1} (hf : Monotone f) (k : \u2115) :\n    \u22c3 n, f (n + k) = \u22c3 n, f n", "start": [2358, 1], "end": [2360, 20], "kind": "commanddeclaration"}, {"full_name": "Antitone.iInter_nat_add", "code": "theorem _root_.Antitone.iInter_nat_add {f : \u2115 \u2192 Set \u03b1} (hf : Antitone f) (k : \u2115) :\n    \u22c2 n, f (n + k) = \u22c2 n, f n", "start": [2363, 1], "end": [2365, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iInter_ge_nat_add", "code": "theorem iUnion_iInter_ge_nat_add (f : \u2115 \u2192 Set \u03b1) (k : \u2115) :\n    \u22c3 n, \u22c2 i \u2265 n, f (i + k) = \u22c3 n, \u22c2 i \u2265 n, f i", "start": [2371, 1], "end": [2373, 27], "kind": "commanddeclaration"}, {"full_name": "Set.union_iUnion_nat_succ", "code": "theorem union_iUnion_nat_succ (u : \u2115 \u2192 Set \u03b1) : (u 0 \u222a \u22c3 i, u (i + 1)) = \u22c3 i, u i", "start": [2376, 1], "end": [2377, 22], "kind": "commanddeclaration"}, {"full_name": "Set.inter_iInter_nat_succ", "code": "theorem inter_iInter_nat_succ (u : \u2115 \u2192 Set \u03b1) : (u 0 \u2229 \u22c2 i, u (i + 1)) = \u22c2 i, u i", "start": [2380, 1], "end": [2381, 22], "kind": "commanddeclaration"}, {"full_name": "iSup_iUnion", "code": "theorem iSup_iUnion (s : \u03b9 \u2192 Set \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2a06 a \u2208 \u22c3 i, s i, f a = \u2a06 (i) (a \u2208 s i), f a", "start": [2390, 1], "end": [2392, 36], "kind": "commanddeclaration"}, {"full_name": "iInf_iUnion", "code": "theorem iInf_iUnion (s : \u03b9 \u2192 Set \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2a05 a \u2208 \u22c3 i, s i, f a = \u2a05 (i) (a \u2208 s i), f a", "start": [2395, 1], "end": [2396, 29], "kind": "commanddeclaration"}, {"full_name": "sSup_sUnion", "code": "theorem sSup_sUnion (s : Set (Set \u03b2)) : sSup (\u22c3\u2080 s) = \u2a06 t \u2208 s, sSup t", "start": [2399, 1], "end": [2400, 59], "kind": "commanddeclaration"}, {"full_name": "sInf_sUnion", "code": "theorem sInf_sUnion (s : Set (Set \u03b2)) : sInf (\u22c3\u2080 s) = \u2a05 t \u2208 s, sInf t", "start": [2403, 1], "end": [2404, 23], "kind": "commanddeclaration"}, {"full_name": "iSup_sUnion", "code": "lemma iSup_sUnion (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) :\n    (\u2a06 x \u2208 \u22c3\u2080 S, f x) = \u2a06 (s \u2208 S) (x \u2208 s), f x := by\n  rw [sUnion_eq_iUnion, iSup_iUnion, \u2190 iSup_subtype'']", "start": [2407, 1], "end": [2409, 55], "kind": "mathlibtacticlemma"}, {"full_name": "iInf_sUnion", "code": "lemma iInf_sUnion (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) :\n    (\u2a05 x \u2208 \u22c3\u2080 S, f x) = \u2a05 (s \u2208 S) (x \u2208 s), f x := by\n  rw [sUnion_eq_iUnion, iInf_iUnion, \u2190 iInf_subtype'']", "start": [2411, 1], "end": [2413, 55], "kind": "mathlibtacticlemma"}, {"full_name": "forall_sUnion", "code": "lemma forall_sUnion {p : \u03b1 \u2192 Prop} :\n    (\u2200 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2200 s \u2208 S, \u2200 x \u2208 s, p x := by\n  simp_rw [\u2190 iInf_Prop_eq, iInf_sUnion]", "start": [2415, 1], "end": [2417, 40], "kind": "mathlibtacticlemma"}, {"full_name": "exists_sUnion", "code": "lemma exists_sUnion {p : \u03b1 \u2192 Prop} :\n    (\u2203 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2203 s \u2208 S, \u2203 x \u2208 s, p x := by\n  simp_rw [\u2190 exists_prop, \u2190 iSup_Prop_eq, iSup_sUnion]", "start": [2419, 1], "end": [2421, 55], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Multiset/FinsetOps.lean", "imports": ["Mathlib/Data/Multiset/Dedup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.ndinsert", "code": "def ndinsert (a : \u03b1) (s : Multiset \u03b1) : Multiset \u03b1 :=\n  Quot.liftOn s (fun l => (l.insert a : Multiset \u03b1)) fun _ _ p => Quot.sound (p.insert a)", "start": [27, 1], "end": [31, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_ndinsert", "code": "@[simp]\ntheorem coe_ndinsert (a : \u03b1) (l : List \u03b1) : ndinsert a l = (insert a l : List \u03b1)", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinsert_zero", "code": "@[simp, nolint simpNF] theorem ndinsert_zero (a : \u03b1) : ndinsert a 0 = {a}", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinsert_of_mem", "code": "@[simp]\ntheorem ndinsert_of_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 ndinsert a s = s", "start": [44, 1], "end": [46, 89], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinsert_of_not_mem", "code": "@[simp]\ntheorem ndinsert_of_not_mem {a : \u03b1} {s : Multiset \u03b1} : a \u2209 s \u2192 ndinsert a s = a ::\u2098 s", "start": [49, 1], "end": [51, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_ndinsert", "code": "@[simp]\ntheorem mem_ndinsert {a b : \u03b1} {s : Multiset \u03b1} : a \u2208 ndinsert b s \u2194 a = b \u2228 a \u2208 s", "start": [54, 1], "end": [56, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_ndinsert_self", "code": "@[simp]\ntheorem le_ndinsert_self (a : \u03b1) (s : Multiset \u03b1) : s \u2264 ndinsert a s", "start": [59, 1], "end": [61, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_ndinsert_self", "code": "theorem mem_ndinsert_self (a : \u03b1) (s : Multiset \u03b1) : a \u2208 ndinsert a s", "start": [65, 1], "end": [66, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_ndinsert_of_mem", "code": "theorem mem_ndinsert_of_mem {a b : \u03b1} {s : Multiset \u03b1} (h : a \u2208 s) : a \u2208 ndinsert b s", "start": [69, 1], "end": [70, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.length_ndinsert_of_mem", "code": "@[simp]\ntheorem length_ndinsert_of_mem {a : \u03b1} {s : Multiset \u03b1} (h : a \u2208 s) :\n    card (ndinsert a s) = card s", "start": [73, 1], "end": [75, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.length_ndinsert_of_not_mem", "code": "@[simp]\ntheorem length_ndinsert_of_not_mem {a : \u03b1} {s : Multiset \u03b1} (h : a \u2209 s) :\n    card (ndinsert a s) = card s + 1", "start": [78, 1], "end": [80, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_cons", "code": "theorem dedup_cons {a : \u03b1} {s : Multiset \u03b1} : dedup (a ::\u2098 s) = ndinsert a (dedup s)", "start": [83, 1], "end": [84, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.ndinsert", "code": "theorem Nodup.ndinsert (a : \u03b1) : Nodup s \u2192 Nodup (ndinsert a s)", "start": [87, 1], "end": [88, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinsert_le", "code": "theorem ndinsert_le {a : \u03b1} {s t : Multiset \u03b1} : ndinsert a s \u2264 t \u2194 s \u2264 t \u2227 a \u2208 t", "start": [91, 1], "end": [97, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.attach_ndinsert", "code": "theorem attach_ndinsert (a : \u03b1) (s : Multiset \u03b1) :\n    (s.ndinsert a).attach =\n      ndinsert \u27e8a, mem_ndinsert_self a s\u27e9 (s.attach.map fun p => \u27e8p.1, mem_ndinsert_of_mem p.2\u27e9)", "start": [100, 1], "end": [117, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_ndinsert_left", "code": "@[simp]\ntheorem disjoint_ndinsert_left {a : \u03b1} {s t : Multiset \u03b1} :\n    Disjoint (ndinsert a s) t \u2194 a \u2209 t \u2227 Disjoint s t", "start": [120, 1], "end": [123, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_ndinsert_right", "code": "@[simp]\ntheorem disjoint_ndinsert_right {a : \u03b1} {s t : Multiset \u03b1} :\n    Disjoint s (ndinsert a t) \u2194 a \u2209 s \u2227 Disjoint s t", "start": [126, 1], "end": [129, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndunion", "code": "def ndunion (s t : Multiset \u03b1) : Multiset \u03b1 :=\n  (Quotient.liftOn\u2082 s t fun l\u2081 l\u2082 => (l\u2081.union l\u2082 : Multiset \u03b1)) fun _ _ _ _ p\u2081 p\u2082 =>\n    Quot.sound <| p\u2081.union p\u2082", "start": [135, 1], "end": [141, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_ndunion", "code": "@[simp]\ntheorem coe_ndunion (l\u2081 l\u2082 : List \u03b1) : @ndunion \u03b1 _ l\u2081 l\u2082 = (l\u2081 \u222a l\u2082 : List \u03b1)", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_ndunion", "code": "theorem zero_ndunion (s : Multiset \u03b1) : ndunion 0 s = s", "start": [150, 1], "end": [151, 34], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_ndunion", "code": "@[simp]\ntheorem cons_ndunion (s t : Multiset \u03b1) (a : \u03b1) : ndunion (a ::\u2098 s) t = ndinsert a (ndunion s t)", "start": [154, 1], "end": [156, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_ndunion", "code": "@[simp]\ntheorem mem_ndunion {s t : Multiset \u03b1} {a : \u03b1} : a \u2208 ndunion s t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [159, 1], "end": [161, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_ndunion_right", "code": "theorem le_ndunion_right (s t : Multiset \u03b1) : t \u2264 ndunion s t", "start": [164, 1], "end": [165, 77], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_ndunion_right", "code": "theorem subset_ndunion_right (s t : Multiset \u03b1) : t \u2286 ndunion s t", "start": [168, 1], "end": [169, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndunion_le_add", "code": "theorem ndunion_le_add (s t : Multiset \u03b1) : ndunion s t \u2264 s + t", "start": [172, 1], "end": [173, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndunion_le", "code": "theorem ndunion_le {s t u : Multiset \u03b1} : ndunion s t \u2264 u \u2194 s \u2286 u \u2227 t \u2264 u", "start": [176, 1], "end": [180, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.subset_ndunion_left", "code": "theorem subset_ndunion_left (s t : Multiset \u03b1) : s \u2286 ndunion s t", "start": [183, 1], "end": [184, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_ndunion_left", "code": "theorem le_ndunion_left {s} (t : Multiset \u03b1) (d : Nodup s) : s \u2264 ndunion s t", "start": [187, 1], "end": [188, 49], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndunion_le_union", "code": "theorem ndunion_le_union (s t : Multiset \u03b1) : ndunion s t \u2264 s \u222a t", "start": [191, 1], "end": [192, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.ndunion", "code": "theorem Nodup.ndunion (s : Multiset \u03b1) {t : Multiset \u03b1} : Nodup t \u2192 Nodup (ndunion s t)", "start": [195, 1], "end": [196, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndunion_eq_union", "code": "@[simp]\ntheorem ndunion_eq_union {s t : Multiset \u03b1} (d : Nodup s) : ndunion s t = s \u222a t", "start": [199, 1], "end": [201, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.dedup_add", "code": "theorem dedup_add (s t : Multiset \u03b1) : dedup (s + t) = ndunion s (dedup t)", "start": [204, 1], "end": [205, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter", "code": "def ndinter (s t : Multiset \u03b1) : Multiset \u03b1 :=\n  filter (\u00b7 \u2208 t) s", "start": [211, 1], "end": [216, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_ndinter", "code": "@[simp]\ntheorem coe_ndinter (l\u2081 l\u2082 : List \u03b1) : @ndinter \u03b1 _ l\u2081 l\u2082 = (l\u2081 \u2229 l\u2082 : List \u03b1)", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_ndinter", "code": "@[simp, nolint simpNF] theorem zero_ndinter (s : Multiset \u03b1) : ndinter 0 s = 0", "start": [224, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.cons_ndinter_of_mem", "code": "@[simp]\ntheorem cons_ndinter_of_mem {a : \u03b1} (s : Multiset \u03b1) {t : Multiset \u03b1} (h : a \u2208 t) :\n    ndinter (a ::\u2098 s) t = a ::\u2098 ndinter s t", "start": [229, 1], "end": [231, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_cons_of_not_mem", "code": "@[simp]\ntheorem ndinter_cons_of_not_mem {a : \u03b1} (s : Multiset \u03b1) {t : Multiset \u03b1} (h : a \u2209 t) :\n    ndinter (a ::\u2098 s) t = ndinter s t", "start": [234, 1], "end": [236, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_ndinter", "code": "@[simp]\ntheorem mem_ndinter {s t : Multiset \u03b1} {a : \u03b1} : a \u2208 ndinter s t \u2194 a \u2208 s \u2227 a \u2208 t", "start": [239, 1], "end": [241, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.ndinter", "code": "@[simp]\ntheorem Nodup.ndinter {s : Multiset \u03b1} (t : Multiset \u03b1) : Nodup s \u2192 Nodup (ndinter s t)", "start": [244, 1], "end": [246, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_ndinter", "code": "theorem le_ndinter {s t u : Multiset \u03b1} : s \u2264 ndinter t u \u2194 s \u2264 t \u2227 s \u2286 u", "start": [249, 1], "end": [250, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_le_left", "code": "theorem ndinter_le_left (s t : Multiset \u03b1) : ndinter s t \u2264 s", "start": [253, 1], "end": [254, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_subset_left", "code": "theorem ndinter_subset_left (s t : Multiset \u03b1) : ndinter s t \u2286 s", "start": [257, 1], "end": [258, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_subset_right", "code": "theorem ndinter_subset_right (s t : Multiset \u03b1) : ndinter s t \u2286 t", "start": [261, 1], "end": [262, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_le_right", "code": "theorem ndinter_le_right {s} (t : Multiset \u03b1) (d : Nodup s) : ndinter s t \u2264 t", "start": [265, 1], "end": [266, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.inter_le_ndinter", "code": "theorem inter_le_ndinter (s t : Multiset \u03b1) : s \u2229 t \u2264 ndinter s t", "start": [269, 1], "end": [270, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_eq_inter", "code": "@[simp]\ntheorem ndinter_eq_inter {s t : Multiset \u03b1} (d : Nodup s) : ndinter s t = s \u2229 t", "start": [273, 1], "end": [275, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.ndinter_eq_zero_iff_disjoint", "code": "theorem ndinter_eq_zero_iff_disjoint {s t : Multiset \u03b1} : ndinter s t = 0 \u2194 Disjoint s t", "start": [278, 1], "end": [279, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Pi/Lex.lean", "imports": ["Mathlib/Algebra/Order/Group/Defs.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/OrderSynonym.lean", "Mathlib/Mathport/Notation.lean", "Mathlib/Order/WellFounded.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "Pi.Lex", "code": "protected def Lex (x y : \u2200 i, \u03b2 i) : Prop :=\n  \u2203 i, (\u2200 j, r j i \u2192 x j = y j) \u2227 s (x i) (y i)", "start": [40, 1], "end": [43, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.toLex_apply", "code": "@[simp]\ntheorem toLex_apply (x : \u2200 i, \u03b2 i) (i : \u03b9) : toLex x i = x i", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.ofLex_apply", "code": "@[simp]\ntheorem ofLex_apply (x : Lex (\u2200 i, \u03b2 i)) (i : \u03b9) : ofLex x i = x i", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.lex_lt_of_lt_of_preorder", "code": "theorem lex_lt_of_lt_of_preorder [\u2200 i, Preorder (\u03b2 i)] {r} (hwf : WellFounded r) {x y : \u2200 i, \u03b2 i}\n    (hlt : x < y) : \u2203 i, (\u2200 j, r j i \u2192 x j \u2264 y j \u2227 y j \u2264 x j) \u2227 x i < y i", "start": [61, 1], "end": [65, 89], "kind": "commanddeclaration"}, {"full_name": "Pi.lex_lt_of_lt", "code": "theorem lex_lt_of_lt [\u2200 i, PartialOrder (\u03b2 i)] {r} (hwf : WellFounded r) {x y : \u2200 i, \u03b2 i}\n    (hlt : x < y) : Pi.Lex r (@fun i => (\u00b7 < \u00b7)) x y", "start": [68, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "Pi.isTrichotomous_lex", "code": "theorem isTrichotomous_lex [\u2200 i, IsTrichotomous (\u03b2 i) s] (wf : WellFounded r) :\n    IsTrichotomous (\u2200 i, \u03b2 i) (Pi.Lex r @s)", "start": [74, 1], "end": [88, 87], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.isStrictOrder", "code": "instance Lex.isStrictOrder [LinearOrder \u03b9] [\u2200 a, PartialOrder (\u03b2 a)] :\n    IsStrictOrder (Lex (\u2200 i, \u03b2 i)) (\u00b7 < \u00b7) where\n  irrefl := fun a \u27e8k, _, hk\u2082\u27e9 => lt_irrefl (a k) hk\u2082\n  trans := by\n    rintro a b c \u27e8N\u2081, lt_N\u2081, a_lt_b\u27e9 \u27e8N\u2082, lt_N\u2082, b_lt_c\u27e9\n    rcases lt_trichotomy N\u2081 N\u2082 with (H | rfl | H)\n    exacts [\u27e8N\u2081, fun j hj => (lt_N\u2081 _ hj).trans (lt_N\u2082 _ <| hj.trans H), lt_N\u2082 _ H \u25b8 a_lt_b\u27e9,\n      \u27e8N\u2081, fun j hj => (lt_N\u2081 _ hj).trans (lt_N\u2082 _ hj), a_lt_b.trans b_lt_c\u27e9,\n      \u27e8N\u2082, fun j hj => (lt_N\u2081 _ (hj.trans H)).trans (lt_N\u2082 _ hj), (lt_N\u2081 _ H).symm \u25b8 b_lt_c\u27e9]", "start": [94, 1], "end": [102, 94], "kind": "commanddeclaration"}, {"full_name": "Pi.toLex_monotone", "code": "theorem toLex_monotone : Monotone (@toLex (\u2200 i, \u03b2 i))", "start": [121, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.toLex_strictMono", "code": "theorem toLex_strictMono : StrictMono (@toLex (\u2200 i, \u03b2 i))", "start": [130, 1], "end": [135, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.lt_toLex_update_self_iff", "code": "@[simp]\ntheorem lt_toLex_update_self_iff : toLex x < toLex (update x i a) \u2194 x i < a", "start": [138, 1], "end": [147, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.toLex_update_lt_self_iff", "code": "@[simp]\ntheorem toLex_update_lt_self_iff : toLex (update x i a) < toLex x \u2194 a < x i", "start": [150, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.le_toLex_update_self_iff", "code": "@[simp]\ntheorem le_toLex_update_self_iff : toLex x \u2264 toLex (update x i a) \u2194 x i \u2264 a", "start": [162, 1], "end": [164, 85], "kind": "commanddeclaration"}, {"full_name": "Pi.toLex_update_le_self_iff", "code": "@[simp]\ntheorem toLex_update_le_self_iff : toLex (update x i a) \u2264 toLex x \u2194 a \u2264 x i", "start": [167, 1], "end": [169, 85], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.noMaxOrder'", "code": "theorem Lex.noMaxOrder' [Preorder \u03b9] [\u2200 i, LT (\u03b2 i)] (i : \u03b9) [NoMaxOrder (\u03b2 i)] :\n    NoMaxOrder (Lex (\u2200 i, \u03b2 i))", "start": [202, 1], "end": [208, 82], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance Lex.orderedCancelCommMonoid [\u2200 i, OrderedCancelCommMonoid (\u03b2 i)] :\n    OrderedCancelCommMonoid (Lex (\u2200 i, \u03b2 i)) where\n  mul_le_mul_left _ _ hxy z :=\n    hxy.elim (fun hxyz => hxyz \u25b8 le_rfl) fun \u27e8i, hi\u27e9 =>\n      Or.inr \u27e8i, fun j hji => congr_arg (z j * \u00b7) (hi.1 j hji), mul_lt_mul_left' hi.2 _\u27e9\n  le_of_mul_le_mul_left _ _ _ hxyz :=\n    hxyz.elim (fun h => (mul_left_cancel h).le) fun \u27e8i, hi\u27e9 =>\n      Or.inr \u27e8i, fun j hj => (mul_left_cancel <| hi.1 j hj), lt_of_mul_lt_mul_left' hi.2\u27e9", "start": [227, 1], "end": [235, 90], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.orderedCommGroup", "code": "@[to_additive]\ninstance Lex.orderedCommGroup [\u2200 i, OrderedCommGroup (\u03b2 i)] :\n    OrderedCommGroup (Lex (\u2200 i, \u03b2 i)) where\n  mul_le_mul_left _ _ := mul_le_mul_left'", "start": [237, 1], "end": [240, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.linearOrderedCancelCommMonoid", "code": "@[to_additive]\nnoncomputable instance Lex.linearOrderedCancelCommMonoid [IsWellOrder \u03b9 (\u00b7 < \u00b7)]\n    [\u2200 i, LinearOrderedCancelCommMonoid (\u03b2 i)] :\n    LinearOrderedCancelCommMonoid (Lex (\u2200 i, \u03b2 i)) where\n  __ : LinearOrder (Lex (\u2200 i, \u03b2 i)) := inferInstance\n  __ : OrderedCancelCommMonoid (Lex (\u2200 i, \u03b2 i)) := inferInstance", "start": [244, 1], "end": [249, 65], "kind": "commanddeclaration"}, {"full_name": "Pi.Lex.linearOrderedCommGroup", "code": "@[to_additive]\nnoncomputable instance Lex.linearOrderedCommGroup [IsWellOrder \u03b9 (\u00b7 < \u00b7)]\n    [\u2200 i, LinearOrderedCommGroup (\u03b2 i)] :\n    LinearOrderedCommGroup (Lex (\u2200 i, \u03b2 i)) where\n  __ : LinearOrder (Lex (\u2200 i, \u03b2 i)) := inferInstance\n  mul_le_mul_left _ _ := mul_le_mul_left'", "start": [251, 1], "end": [256, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.lex_desc", "code": "theorem lex_desc {\u03b1} [Preorder \u03b9] [DecidableEq \u03b9] [Preorder \u03b1] {f : \u03b9 \u2192 \u03b1} {i j : \u03b9} (h\u2081 : i \u2264 j)\n    (h\u2082 : f j < f i) : toLex (f \u2218 Equiv.swap i j) < toLex f", "start": [260, 1], "end": [265, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Cast/Lemmas.lean", "imports": ["Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Nat/Cast/Commute.lean", "Mathlib/Data/Nat/Cast/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Hom/Ring/Basic.lean"], "premises": [{"full_name": "Int.ofNatHom", "code": "def ofNatHom : \u2115 \u2192+* \u2124 :=\n  Nat.castRingHom \u2124", "start": [34, 1], "end": [36, 20], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_pos", "code": "theorem coe_nat_pos {n : \u2115} : (0 : \u2124) < n \u2194 0 < n", "start": [41, 1], "end": [42, 15], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_succ_pos", "code": "theorem coe_nat_succ_pos (n : \u2115) : 0 < (n.succ : \u2124)", "start": [45, 1], "end": [46, 33], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_lt'", "code": "lemma toNat_lt' {a : \u2124} {b : \u2115} (hb : b \u2260 0) : a.toNat < b \u2194 a < b := by\n  rw [\u2190toNat_lt_toNat, toNat_coe_nat]; exact coe_nat_pos.2 hb.bot_lt", "start": [49, 1], "end": [50, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Int.natMod_lt", "code": "lemma natMod_lt {a : \u2124} {b : \u2115} (hb : b \u2260 0) : a.natMod b < b :=\n  (toNat_lt' hb).2 $ emod_lt_of_pos _ $ coe_nat_pos.2 hb.bot_lt", "start": [53, 1], "end": [54, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Int.cast_ite", "code": "@[simp, norm_cast]\ntheorem cast_ite [AddGroupWithOne \u03b1] (P : Prop) [Decidable P] (m n : \u2124) :\n    ((ite P m n : \u2124) : \u03b1) = ite P (m : \u03b1) (n : \u03b1)", "start": [59, 1], "end": [62, 20], "kind": "commanddeclaration"}, {"full_name": "Int.castAddHom", "code": "def castAddHom (\u03b1 : Type*) [AddGroupWithOne \u03b1] : \u2124 \u2192+ \u03b1 where\n  toFun := Int.cast\n  map_zero' := cast_zero\n  map_add' := cast_add", "start": [65, 1], "end": [69, 23], "kind": "commanddeclaration"}, {"full_name": "Int.coe_castAddHom", "code": "@[simp]\ntheorem coe_castAddHom [AddGroupWithOne \u03b1] : \u21d1(castAddHom \u03b1) = fun x : \u2124 => (x : \u03b1)", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Int.castRingHom", "code": "def castRingHom (\u03b1 : Type*) [NonAssocRing \u03b1] : \u2124 \u2192+* \u03b1 where\n  toFun := Int.cast\n  map_zero' := cast_zero\n  map_add' := cast_add\n  map_one' := cast_one\n  map_mul' := cast_mul", "start": [77, 1], "end": [83, 23], "kind": "commanddeclaration"}, {"full_name": "Int.coe_castRingHom", "code": "@[simp]\ntheorem coe_castRingHom [NonAssocRing \u03b1] : \u21d1(castRingHom \u03b1) = fun x : \u2124 => (x : \u03b1)", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Int.cast_commute", "code": "theorem cast_commute [NonAssocRing \u03b1] : \u2200 (m : \u2124) (x : \u03b1), Commute (\u2191m) x", "start": [91, 1], "end": [95, 32], "kind": "commanddeclaration"}, {"full_name": "Int.cast_comm", "code": "theorem cast_comm [NonAssocRing \u03b1] (m : \u2124) (x : \u03b1) : (m : \u03b1) * x = x * m", "start": [98, 1], "end": [99, 24], "kind": "commanddeclaration"}, {"full_name": "Int.commute_cast", "code": "theorem commute_cast [NonAssocRing \u03b1] (x : \u03b1) (m : \u2124) : Commute x m", "start": [102, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "Int.cast_mono", "code": "theorem cast_mono [OrderedRing \u03b1] : Monotone (fun x : \u2124 => (x : \u03b1))", "start": [106, 1], "end": [111, 22], "kind": "commanddeclaration"}, {"full_name": "Int.cast_nonneg", "code": "@[simp]\ntheorem cast_nonneg [OrderedRing \u03b1] [Nontrivial \u03b1] : \u2200 {n : \u2124}, (0 : \u03b1) \u2264 n \u2194 0 \u2264 n", "start": [114, 1], "end": [119, 83], "kind": "commanddeclaration"}, {"full_name": "Int.cast_le", "code": "@[simp, norm_cast]\ntheorem cast_le [OrderedRing \u03b1] [Nontrivial \u03b1] {m n : \u2124} : (m : \u03b1) \u2264 n \u2194 m \u2264 n", "start": [122, 1], "end": [124, 57], "kind": "commanddeclaration"}, {"full_name": "Int.cast_strictMono", "code": "theorem cast_strictMono [OrderedRing \u03b1] [Nontrivial \u03b1] : StrictMono (fun x : \u2124 => (x : \u03b1))", "start": [127, 1], "end": [128, 50], "kind": "commanddeclaration"}, {"full_name": "Int.cast_lt", "code": "@[simp, norm_cast]\ntheorem cast_lt [OrderedRing \u03b1] [Nontrivial \u03b1] {m n : \u2124} : (m : \u03b1) < n \u2194 m < n", "start": [131, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "Int.cast_nonpos", "code": "@[simp]\ntheorem cast_nonpos [OrderedRing \u03b1] [Nontrivial \u03b1] {n : \u2124} : (n : \u03b1) \u2264 0 \u2194 n \u2264 0", "start": [136, 1], "end": [138, 28], "kind": "commanddeclaration"}, {"full_name": "Int.cast_pos", "code": "@[simp]\ntheorem cast_pos [OrderedRing \u03b1] [Nontrivial \u03b1] {n : \u2124} : (0 : \u03b1) < n \u2194 0 < n", "start": [141, 1], "end": [143, 28], "kind": "commanddeclaration"}, {"full_name": "Int.cast_lt_zero", "code": "@[simp]\ntheorem cast_lt_zero [OrderedRing \u03b1] [Nontrivial \u03b1] {n : \u2124} : (n : \u03b1) < 0 \u2194 n < 0", "start": [146, 1], "end": [148, 28], "kind": "commanddeclaration"}, {"full_name": "Int.cast_min", "code": "@[simp, norm_cast]\ntheorem cast_min : (\u2191(min a b) : \u03b1) = min (a : \u03b1) (b : \u03b1)", "start": [155, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "Int.cast_max", "code": "@[simp, norm_cast]\ntheorem cast_max : (\u2191(max a b) : \u03b1) = max (a : \u03b1) (b : \u03b1)", "start": [160, 1], "end": [162, 29], "kind": "commanddeclaration"}, {"full_name": "Int.cast_abs", "code": "@[simp, norm_cast]\ntheorem cast_abs : ((|a| : \u2124) : \u03b1) = |(a : \u03b1)|", "start": [165, 1], "end": [166, 75], "kind": "commanddeclaration"}, {"full_name": "Int.cast_one_le_of_pos", "code": "theorem cast_one_le_of_pos (h : 0 < a) : (1 : \u03b1) \u2264 a", "start": [169, 1], "end": [169, 97], "kind": "commanddeclaration"}, {"full_name": "Int.cast_le_neg_one_of_neg", "code": "theorem cast_le_neg_one_of_neg (h : a < 0) : (a : \u03b1) \u2264 -1", "start": [172, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "Int.cast_le_neg_one_or_one_le_cast_of_ne_zero", "code": "theorem cast_le_neg_one_or_one_le_cast_of_ne_zero (hn : n \u2260 0) : (n : \u03b1) \u2264 -1 \u2228 1 \u2264 (n : \u03b1)", "start": [179, 1], "end": [180, 60], "kind": "commanddeclaration"}, {"full_name": "Int.nneg_mul_add_sq_of_abs_le_one", "code": "theorem nneg_mul_add_sq_of_abs_le_one {x : \u03b1} (hx : |x| \u2264 1) : (0 : \u03b1) \u2264 n * x + n * n", "start": [185, 1], "end": [196, 49], "kind": "commanddeclaration"}, {"full_name": "Int.cast_natAbs", "code": "theorem cast_natAbs : (n.natAbs : \u03b1) = |n|", "start": [199, 1], "end": [202, 73], "kind": "commanddeclaration"}, {"full_name": "Int.coe_int_dvd", "code": "theorem coe_int_dvd [CommRing \u03b1] (m n : \u2124) (h : m \u2223 n) : (m : \u03b1) \u2223 (n : \u03b1)", "start": [207, 1], "end": [208, 40], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.ext_int", "code": "@[ext high]\ntheorem ext_int [AddMonoid A] {f g : \u2124 \u2192+ A} (h1 : f 1 = g 1) : f = g", "start": [221, 1], "end": [229, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.eq_int_castAddHom", "code": "theorem eq_int_castAddHom (f : \u2124 \u2192+ A) (h1 : f 1 = 1) : f = Int.castAddHom A", "start": [234, 1], "end": [235, 26], "kind": "commanddeclaration"}, {"full_name": "eq_intCast'", "code": "theorem eq_intCast' [AddGroupWithOne \u03b1] [AddMonoidHomClass F \u2124 \u03b1] (f : F) (h\u2081 : f 1 = 1) :\n    \u2200 n : \u2124, f n = n", "start": [240, 1], "end": [242, 57], "kind": "commanddeclaration"}, {"full_name": "Int.castAddHom_int", "code": "@[simp]\ntheorem Int.castAddHom_int : Int.castAddHom \u2124 = AddMonoidHom.id \u2124", "start": [245, 1], "end": [247, 51], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext_mint", "code": "@[ext]\ntheorem ext_mint {f g : Multiplicative \u2124 \u2192* M} (h1 : f (ofAdd 1) = g (ofAdd 1)) : f = g", "start": [256, 1], "end": [258, 90], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext_int", "code": "@[ext]\ntheorem ext_int {f g : \u2124 \u2192* M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidHom = g.comp Int.ofNatHom.toMonoidHom) : f = g", "start": [261, 1], "end": [269, 57], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_int", "code": "@[ext]\ntheorem ext_int {f g : \u2124 \u2192*\u2080 M} (h_neg_one : f (-1) = g (-1))\n    (h_nat : f.comp Int.ofNatHom.toMonoidWithZeroHom = g.comp Int.ofNatHom.toMonoidWithZeroHom) :\n    f = g", "start": [278, 1], "end": [284, 48], "kind": "commanddeclaration"}, {"full_name": "ext_int'", "code": "theorem ext_int' [MonoidWithZero \u03b1] [MonoidWithZeroHomClass F \u2124 \u03b1] {f g : F}\n    (h_neg_one : f (-1) = g (-1)) (h_pos : \u2200 n : \u2115, 0 < n \u2192 f n = g n) : f = g", "start": [289, 1], "end": [298, 9], "kind": "commanddeclaration"}, {"full_name": "eq_intCast", "code": "@[simp]\ntheorem eq_intCast [RingHomClass F \u2124 \u03b1] (f : F) (n : \u2124) : f n = n", "start": [305, 1], "end": [307, 30], "kind": "commanddeclaration"}, {"full_name": "map_intCast", "code": "@[simp]\ntheorem map_intCast [RingHomClass F \u03b1 \u03b2] (f : F) (n : \u2124) : f n = n", "start": [310, 1], "end": [312, 56], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_intCast'", "code": "theorem eq_intCast' (f : \u2124 \u2192+* \u03b1) : f = Int.castRingHom \u03b1", "start": [317, 1], "end": [318, 30], "kind": "commanddeclaration"}, {"full_name": "RingHom.ext_int", "code": "theorem ext_int {R : Type*} [NonAssocSemiring R] (f g : \u2124 \u2192+* R) : f = g", "start": [321, 1], "end": [322, 87], "kind": "commanddeclaration"}, {"full_name": "RingHom.Int.subsingleton_ringHom", "code": "instance Int.subsingleton_ringHom {R : Type*} [NonAssocSemiring R] : Subsingleton (\u2124 \u2192+* R) :=\n  \u27e8RingHom.ext_int\u27e9", "start": [325, 1], "end": [326, 20], "kind": "commanddeclaration"}, {"full_name": "Int.castRingHom_int", "code": "@[simp]\ntheorem Int.castRingHom_int : Int.castRingHom \u2124 = RingHom.id \u2124", "start": [335, 1], "end": [337, 34], "kind": "commanddeclaration"}, {"full_name": "Pi.intCast", "code": "instance intCast : IntCast (\u2200 i, \u03c0 i) :=\n  { intCast := fun n _ \u21a6 n }", "start": [344, 1], "end": [345, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.int_apply", "code": "theorem int_apply (n : \u2124) (i : \u03b9) : (n : \u2200 i, \u03c0 i) i = n", "start": [347, 1], "end": [348, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.coe_int", "code": "@[simp]\ntheorem coe_int (n : \u2124) : (n : \u2200 i, \u03c0 i) = fun _ => \u2191n", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_intCast_intCast", "code": "theorem Sum.elim_intCast_intCast {\u03b1 \u03b2 \u03b3 : Type*} [IntCast \u03b3] (n : \u2124) :\n    Sum.elim (n : \u03b1 \u2192 \u03b3) (n : \u03b2 \u2192 \u03b3) = n", "start": [358, 1], "end": [360, 42], "kind": "commanddeclaration"}, {"full_name": "toDual_intCast", "code": "@[simp]\ntheorem toDual_intCast [IntCast \u03b1] (n : \u2124) : toDual (n : \u03b1) = n", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_intCast", "code": "@[simp]\ntheorem ofDual_intCast [IntCast \u03b1] (n : \u2124) : (ofDual n : \u03b1) = n", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "toLex_intCast", "code": "@[simp]\ntheorem toLex_intCast [IntCast \u03b1] (n : \u2124) : toLex (n : \u03b1) = n", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "ofLex_intCast", "code": "@[simp]\ntheorem ofLex_intCast [IntCast \u03b1] (n : \u2124) : (ofLex n : \u03b1) = n", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Invertible/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Invertible/GroupWithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean"], "premises": [{"full_name": "unitOfInvertible", "code": "@[simps]\ndef unitOfInvertible [Monoid \u03b1] (a : \u03b1) [Invertible a] : \u03b1\u02e3 where\n  val := a\n  inv := \u215f a\n  val_inv := by simp\n  inv_val := by simp", "start": [24, 1], "end": [30, 21], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_invertible", "code": "theorem isUnit_of_invertible [Monoid \u03b1] (a : \u03b1) [Invertible a] : IsUnit a", "start": [35, 1], "end": [36, 28], "kind": "commanddeclaration"}, {"full_name": "Units.invertible", "code": "def Units.invertible [Monoid \u03b1] (u : \u03b1\u02e3) :\n    Invertible (u : \u03b1) where\n  invOf := \u2191u\u207b\u00b9\n  invOf_mul_self := u.inv_mul\n  mul_invOf_self := u.mul_inv", "start": [39, 1], "end": [44, 30], "kind": "commanddeclaration"}, {"full_name": "invOf_units", "code": "@[simp]\ntheorem invOf_units [Monoid \u03b1] (u : \u03b1\u02e3) [Invertible (u : \u03b1)] : \u215f (u : \u03b1) = \u2191u\u207b\u00b9", "start": [47, 1], "end": [49, 31], "kind": "commanddeclaration"}, {"full_name": "IsUnit.nonempty_invertible", "code": "theorem IsUnit.nonempty_invertible [Monoid \u03b1] {a : \u03b1} (h : IsUnit a) : Nonempty (Invertible a)", "start": [52, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.invertible", "code": "noncomputable def IsUnit.invertible [Monoid \u03b1] {a : \u03b1} (h : IsUnit a) : Invertible a :=\n  Classical.choice h.nonempty_invertible", "start": [57, 1], "end": [61, 41], "kind": "commanddeclaration"}, {"full_name": "nonempty_invertible_iff_isUnit", "code": "@[simp]\ntheorem nonempty_invertible_iff_isUnit [Monoid \u03b1] (a : \u03b1) : Nonempty (Invertible a) \u2194 IsUnit a", "start": [64, 1], "end": [66, 76], "kind": "commanddeclaration"}, {"full_name": "invertibleNeg", "code": "def invertibleNeg [Mul \u03b1] [One \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] : Invertible (-a) :=\n  \u27e8-\u215f a, by simp, by simp\u27e9", "start": [69, 1], "end": [71, 27], "kind": "commanddeclaration"}, {"full_name": "invOf_neg", "code": "@[simp]\ntheorem invOf_neg [Monoid \u03b1] [HasDistribNeg \u03b1] (a : \u03b1) [Invertible a] [Invertible (-a)] :\n    \u215f (-a) = -\u215f a", "start": [74, 1], "end": [77, 31], "kind": "commanddeclaration"}, {"full_name": "one_sub_invOf_two", "code": "@[simp]\ntheorem one_sub_invOf_two [Ring \u03b1] [Invertible (2 : \u03b1)] : 1 - (\u215f 2 : \u03b1) = \u215f 2", "start": [80, 1], "end": [83, 80], "kind": "commanddeclaration"}, {"full_name": "invOf_two_add_invOf_two", "code": "@[simp]\ntheorem invOf_two_add_invOf_two [NonAssocSemiring \u03b1] [Invertible (2 : \u03b1)] :\n    (\u215f 2 : \u03b1) + (\u215f 2 : \u03b1) = 1", "start": [86, 1], "end": [88, 67], "kind": "commanddeclaration"}, {"full_name": "Commute.invOf_right", "code": "theorem Commute.invOf_right [Monoid \u03b1] {a b : \u03b1} [Invertible b] (h : Commute a b) :\n    Commute a (\u215f b)", "start": [91, 1], "end": [96, 39], "kind": "commanddeclaration"}, {"full_name": "Commute.invOf_left", "code": "theorem Commute.invOf_left [Monoid \u03b1] {a b : \u03b1} [Invertible b] (h : Commute b a) :\n    Commute (\u215f b) a", "start": [99, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "commute_invOf", "code": "theorem commute_invOf {M : Type*} [One M] [Mul M] (m : M) [Invertible m] : Commute m (\u215f m)", "start": [107, 1], "end": [110, 43], "kind": "commanddeclaration"}, {"full_name": "pos_of_invertible_cast", "code": "theorem pos_of_invertible_cast [Semiring \u03b1] [Nontrivial \u03b1] (n : \u2115) [Invertible (n : \u03b1)] : 0 < n", "start": [113, 1], "end": [114, 84], "kind": "commanddeclaration"}, {"full_name": "invertibleOfInvertibleMul", "code": "@[reducible]\ndef invertibleOfInvertibleMul (a b : \u03b1) [Invertible a] [Invertible (a * b)] : Invertible b where\n  invOf := \u215f (a * b) * a\n  invOf_mul_self := by rw [mul_assoc, invOf_mul_self]\n  mul_invOf_self := by\n    rw [\u2190 (isUnit_of_invertible a).mul_right_inj, \u2190 mul_assoc, \u2190 mul_assoc, mul_invOf_self, mul_one,\n      one_mul]", "start": [120, 1], "end": [127, 15], "kind": "commanddeclaration"}, {"full_name": "invertibleOfMulInvertible", "code": "@[reducible]\ndef invertibleOfMulInvertible (a b : \u03b1) [Invertible (a * b)] [Invertible b] : Invertible a where\n  invOf := b * \u215f (a * b)\n  invOf_mul_self := by\n    rw [\u2190 (isUnit_of_invertible b).mul_left_inj, mul_assoc, mul_assoc, invOf_mul_self, mul_one,\n      one_mul]\n  mul_invOf_self := by rw [\u2190 mul_assoc, mul_invOf_self]", "start": [130, 1], "end": [137, 56], "kind": "commanddeclaration"}, {"full_name": "Invertible.mulLeft", "code": "@[simps apply symm_apply]\ndef Invertible.mulLeft {a : \u03b1} (_ : Invertible a) (b : \u03b1) : Invertible b \u2243 Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfInvertibleMul a _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [140, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "Invertible.mulRight", "code": "@[simps apply symm_apply]\ndef Invertible.mulRight (a : \u03b1) {b : \u03b1} (_ : Invertible b) : Invertible a \u2243 Invertible (a * b) where\n  toFun _ := invertibleMul a b\n  invFun _ := invertibleOfMulInvertible _ b\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [151, 1], "end": [157, 39], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_invertible", "code": "@[simp]\ntheorem Ring.inverse_invertible (x : \u03b1) [Invertible x] : Ring.inverse x = \u215f x", "start": [168, 1], "end": [171, 41], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel_of_invertible", "code": "@[simp]\ntheorem div_mul_cancel_of_invertible (a b : \u03b1) [Invertible b] : a / b * b = a", "start": [180, 1], "end": [182, 45], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel_of_invertible", "code": "@[simp]\ntheorem mul_div_cancel_of_invertible (a b : \u03b1) [Invertible b] : a * b / b = a", "start": [185, 1], "end": [187, 45], "kind": "commanddeclaration"}, {"full_name": "div_self_of_invertible", "code": "@[simp]\ntheorem div_self_of_invertible (a : \u03b1) [Invertible a] : a / a = 1", "start": [190, 1], "end": [192, 37], "kind": "commanddeclaration"}, {"full_name": "invertibleDiv", "code": "def invertibleDiv (a b : \u03b1) [Invertible a] [Invertible b] : Invertible (a / b) :=\n  \u27e8b / a, by simp [\u2190 mul_div_assoc], by simp [\u2190 mul_div_assoc]\u27e9", "start": [195, 1], "end": [197, 64], "kind": "commanddeclaration"}, {"full_name": "invOf_div", "code": "theorem invOf_div (a b : \u03b1) [Invertible a] [Invertible b] [Invertible (a / b)] :\n    \u215f (a / b) = b / a", "start": [201, 1], "end": [203, 49], "kind": "commanddeclaration"}, {"full_name": "Invertible.map", "code": "def Invertible.map {R : Type*} {S : Type*} {F : Type*} [MulOneClass R] [MulOneClass S]\n    [MonoidHomClass F R S] (f : F) (r : R) [Invertible r] :\n    Invertible (f r) where\n  invOf := f (\u215f r)\n  invOf_mul_self := by rw [\u2190 map_mul, invOf_mul_self, map_one]\n  mul_invOf_self := by rw [\u2190 map_mul, mul_invOf_self, map_one]", "start": [208, 1], "end": [214, 63], "kind": "commanddeclaration"}, {"full_name": "map_invOf", "code": "theorem map_invOf {R : Type*} {S : Type*} {F : Type*} [MulOneClass R] [Monoid S]\n    [MonoidHomClass F R S] (f : F) (r : R) [Invertible r] [ifr : Invertible (f r)] :\n    f (\u215f r) = \u215f (f r)", "start": [217, 1], "end": [223, 18], "kind": "commanddeclaration"}, {"full_name": "Invertible.ofLeftInverse", "code": "@[simps! (config := .lemmasOnly)]\ndef Invertible.ofLeftInverse {R : Type*} {S : Type*} {G : Type*} [MulOneClass R] [MulOneClass S]\n    [MonoidHomClass G S R] (f : R \u2192 S) (g : G) (r : R) (h : Function.LeftInverse g f)\n    [Invertible (f r)] : Invertible r :=\n  (Invertible.map g (f r)).copy _ (h r).symm", "start": [226, 1], "end": [234, 45], "kind": "commanddeclaration"}, {"full_name": "invertibleEquivOfLeftInverse", "code": "@[simps]\ndef invertibleEquivOfLeftInverse {R : Type*} {S : Type*} {F G : Type*} [Monoid R] [Monoid S]\n    [MonoidHomClass F R S] [MonoidHomClass G S R] (f : F) (g : G) (r : R)\n    (h : Function.LeftInverse g f) :\n    Invertible (f r) \u2243\n      Invertible r where\n  toFun _ := Invertible.ofLeftInverse f _ _ h\n  invFun _ := Invertible.map f _\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [238, 1], "end": [248, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Qq.lean", "imports": ["lake-packages/Qq/Qq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.inferTypeQ'", "code": "def inferTypeQ' (e : Expr) : MetaM ((u : Level) \u00d7 (\u03b1 : Q(Type $u)) \u00d7 Q($\u03b1)) := do\n  let \u03b1 \u2190 inferType e\n  let .sort u \u2190 whnf (\u2190 inferType \u03b1) | throwError \"not a type{indentExpr \u03b1}\"\n  let some v := (\u2190 instantiateLevelMVars u).dec | throwError \"not a Type{indentExpr e}\"\n  pure \u27e8v, \u03b1, e\u27e9", "start": [19, 1], "end": [27, 17], "kind": "commanddeclaration"}, {"full_name": "Qq.QuotedDefEq.rfl", "code": "theorem QuotedDefEq.rfl : @QuotedDefEq u \u03b1 a a", "start": [29, 1], "end": [29, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Result.lean", "imports": ["Mathlib/Data/Sigma/Basic.lean", "Mathlib/Algebra/Invertible/GroupWithZero.lean", "Mathlib/Data/Int/Cast/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Algebra/Field/Defs.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.instAddMonoidWithOneNat", "code": "def instAddMonoidWithOneNat : AddMonoidWithOne \u2115 := inferInstance", "start": [34, 1], "end": [35, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.instAddMonoidWithOne", "code": "def instAddMonoidWithOne [Ring \u03b1] : AddMonoidWithOne \u03b1 := inferInstance", "start": [37, 1], "end": [38, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferAddMonoidWithOne", "code": "def inferAddMonoidWithOne (\u03b1 : Q(Type u)) : MetaM Q(AddMonoidWithOne $\u03b1) :=\n  return \u2190 synthInstanceQ (q(AddMonoidWithOne $\u03b1) : Q(Type u)) <|>\n    throwError \"not an AddMonoidWithOne\"", "start": [40, 1], "end": [43, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferSemiring", "code": "def inferSemiring (\u03b1 : Q(Type u)) : MetaM Q(Semiring $\u03b1) :=\n  return \u2190 synthInstanceQ (q(Semiring $\u03b1) : Q(Type u)) <|> throwError \"not a semiring\"", "start": [45, 1], "end": [47, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferRing", "code": "def inferRing (\u03b1 : Q(Type u)) : MetaM Q(Ring $\u03b1) :=\n  return \u2190 synthInstanceQ (q(Ring $\u03b1) : Q(Type u)) <|> throwError \"not a ring\"", "start": [49, 1], "end": [51, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.mkRawIntLit", "code": "def mkRawIntLit (n : \u2124) : Q(\u2124) :=\n  let lit : Q(\u2115) := mkRawNatLit n.natAbs\n  if 0 \u2264 n then q(.ofNat $lit) else q(.negOfNat $lit)", "start": [53, 1], "end": [64, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.mkRawRatLit", "code": "def mkRawRatLit (q : \u211a) : Q(\u211a) :=\n  let nlit : Q(\u2124) := mkRawIntLit q.num\n  let dlit : Q(\u2115) := mkRawNatLit q.den\n  q(mkRat $nlit $dlit)", "start": [66, 1], "end": [76, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.rawIntLitNatAbs", "code": "def rawIntLitNatAbs (n : Q(\u2124)) : (m : Q(\u2115)) \u00d7 Q(Int.natAbs $n = $m) :=\n  if n.isAppOfArity ``Int.ofNat 1 then\n    have m : Q(\u2115) := n.appArg!\n    \u27e8m, show Q(Int.natAbs (Int.ofNat $m) = $m) from q(Int.natAbs_ofNat $m)\u27e9\n  else if n.isAppOfArity ``Int.negOfNat 1 then\n    have m : Q(\u2115) := n.appArg!\n    \u27e8m, show Q(Int.natAbs (Int.negOfNat $m) = $m) from q(Int.natAbs_neg $m)\u27e9\n  else\n    panic! \"not a raw integer literal\"", "start": [78, 1], "end": [88, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.mkOfNat", "code": "def mkOfNat (\u03b1 : Q(Type u)) (_s\u03b1 : Q(AddMonoidWithOne $\u03b1)) (lit : Q(\u2115)) :\n    MetaM ((a' : Q($\u03b1)) \u00d7 Q($lit = $a')) := do\n  if \u03b1.isConstOf ``Nat then\n    let a' : Q(\u2115) := q(OfNat.ofNat $lit : \u2115)\n    pure \u27e8a', (q(Eq.refl $a') : Expr)\u27e9\n  else if \u03b1.isConstOf ``Int then\n    let a' : Q(\u2124) := q(OfNat.ofNat $lit : \u2124)\n    pure \u27e8a', (q(Eq.refl $a') : Expr)\u27e9\n  else if \u03b1.isConstOf ``Rat then\n    let a' : Q(\u211a) := q(OfNat.ofNat $lit : \u211a)\n    pure \u27e8a', (q(Eq.refl $a') : Expr)\u27e9\n  else\n    let some n := lit.natLit? | failure\n    match n with\n    | 0 => pure \u27e8q(0 : $\u03b1), (q(Nat.cast_zero (R := $\u03b1)) : Expr)\u27e9\n    | 1 => pure \u27e8q(1 : $\u03b1), (q(Nat.cast_one (R := $\u03b1)) : Expr)\u27e9\n    | k+2 =>\n      let k : Q(\u2115) := mkRawNatLit k\n      let _x : Q(Nat.AtLeastTwo $lit) :=\n        (q(instNatAtLeastTwo (n := $k)) : Expr)\n      let a' : Q($\u03b1) := q(OfNat.ofNat $lit)\n      pure \u27e8a', (q(Eq.refl $a') : Expr)\u27e9", "start": [90, 1], "end": [119, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat", "code": "structure IsNat [AddMonoidWithOne \u03b1] (a : \u03b1) (n : \u2115) : Prop where\n  \n  out : a = n", "start": [121, 1], "end": [124, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.raw_refl", "code": "theorem IsNat.raw_refl (n : \u2115) : IsNat n n", "start": [126, 1], "end": [126, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.rawCast", "code": "@[simp] def _root_.Nat.rawCast [AddMonoidWithOne \u03b1] (n : \u2115) : \u03b1 := n", "start": [128, 1], "end": [133, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.to_eq", "code": "theorem IsNat.to_eq [AddMonoidWithOne \u03b1] {n} : {a a' : \u03b1} \u2192 IsNat a n \u2192 n = a' \u2192 a = a'", "start": [135, 1], "end": [136, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq", "code": "theorem IsNat.to_raw_eq [AddMonoidWithOne \u03b1] : IsNat (a : \u03b1) n \u2192 a = n.rawCast", "start": [138, 1], "end": [139, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.of_raw", "code": "theorem IsNat.of_raw (\u03b1) [AddMonoidWithOne \u03b1] (n : \u2115) : IsNat (n.rawCast : \u03b1) n", "start": [141, 1], "end": [141, 89], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat.natElim", "code": "@[elab_as_elim]\ntheorem isNat.natElim {p : \u2115 \u2192 Prop} : {n : \u2115} \u2192 {n' : \u2115} \u2192 IsNat n n' \u2192 p n' \u2192 p n", "start": [143, 1], "end": [145, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt", "code": "structure IsInt [Ring \u03b1] (a : \u03b1) (n : \u2124) : Prop where\n  \n  out : a = n", "start": [147, 1], "end": [150, 14], "kind": "commanddeclaration"}, {"full_name": "Int.rawCast", "code": "@[simp] def _root_.Int.rawCast [Ring \u03b1] (n : \u2124) : \u03b1 := n", "start": [152, 1], "end": [162, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.to_isNat", "code": "theorem IsInt.to_isNat {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsInt a (.ofNat n) \u2192 IsNat a n", "start": [164, 1], "end": [165, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.to_isInt", "code": "theorem IsNat.to_isInt {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsNat a n \u2192 IsInt a (.ofNat n)", "start": [167, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq", "code": "theorem IsInt.to_raw_eq [Ring \u03b1] : IsInt (a : \u03b1) n \u2192 a = n.rawCast", "start": [170, 1], "end": [171, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.of_raw", "code": "theorem IsInt.of_raw (\u03b1) [Ring \u03b1] (n : \u2124) : IsInt (n.rawCast : \u03b1) n", "start": [173, 1], "end": [173, 77], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.neg_to_eq", "code": "theorem IsInt.neg_to_eq {\u03b1} [Ring \u03b1] {n} :\n    {a a' : \u03b1} \u2192 IsInt a (.negOfNat n) \u2192 n = a' \u2192 a = -a'", "start": [175, 1], "end": [177, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.nonneg_to_eq", "code": "theorem IsInt.nonneg_to_eq {\u03b1} [Ring \u03b1] {n}\n    {a a' : \u03b1} (h : IsInt a (.ofNat n)) (e : n = a') : a = a'", "start": [179, 1], "end": [180, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat", "code": "inductive IsRat [Ring \u03b1] (a : \u03b1) (num : \u2124) (denom : \u2115) : Prop\n  | mk (inv : Invertible (denom : \u03b1)) (eq : a = num * \u215f(denom : \u03b1))", "start": [182, 1], "end": [189, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.rawCast", "code": "@[simp]\ndef _root_.Rat.rawCast [DivisionRing \u03b1] (n : \u2124) (d : \u2115) : \u03b1 := n / d", "start": [191, 1], "end": [202, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.to_isNat", "code": "theorem IsRat.to_isNat {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsRat a (.ofNat n) (nat_lit 1) \u2192 IsNat a n", "start": [204, 1], "end": [205, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNat.to_isRat", "code": "theorem IsNat.to_isRat {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsNat a n \u2192 IsRat a (.ofNat n) (nat_lit 1)", "start": [207, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.to_isInt", "code": "theorem IsRat.to_isInt {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsRat a n (nat_lit 1) \u2192 IsInt a n", "start": [210, 1], "end": [211, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsInt.to_isRat", "code": "theorem IsInt.to_isRat {\u03b1} [Ring \u03b1] : \u2200 {a : \u03b1} {n}, IsInt a n \u2192 IsRat a n (nat_lit 1)", "start": [213, 1], "end": [214, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.to_raw_eq", "code": "theorem IsRat.to_raw_eq [DivisionRing \u03b1] : \u2200 {a}, IsRat (a : \u03b1) n d \u2192 a = Rat.rawCast n d", "start": [216, 1], "end": [217, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.neg_to_eq", "code": "theorem IsRat.neg_to_eq {\u03b1} [DivisionRing \u03b1] {n d} :\n    {a n' d' : \u03b1} \u2192 IsRat a (.negOfNat n) d \u2192 n = n' \u2192 d = d' \u2192 a = -(n' / d')", "start": [219, 1], "end": [221, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.nonneg_to_eq", "code": "theorem IsRat.nonneg_to_eq {\u03b1} [DivisionRing \u03b1] {n d} :\n    {a n' d' : \u03b1} \u2192 IsRat a (.ofNat n) d \u2192 n = n' \u2192 d = d' \u2192 a = n' / d'", "start": [223, 1], "end": [225, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.of_raw", "code": "theorem IsRat.of_raw (\u03b1) [DivisionRing \u03b1] (n : \u2124) (d : \u2115)\n    (h : (d : \u03b1) \u2260 0) : IsRat (Rat.rawCast n d : \u03b1) n d", "start": [227, 1], "end": [230, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsRat.den_nz", "code": "theorem IsRat.den_nz {\u03b1} [DivisionRing \u03b1] {a n d} : IsRat (a : \u03b1) n d \u2192 (d : \u03b1) \u2260 0", "start": [232, 1], "end": [233, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result'", "code": "inductive Result' where\n  \n  | isBool (val : Bool) (proof : Expr)\n  \n  | isNat (inst lit proof : Expr)\n  \n  | isNegNat (inst lit proof : Expr)\n  \n  | isRat (inst : Expr) (q : Rat) (n d proof : Expr)\n  deriving Inhabited", "start": [235, 1], "end": [246, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result", "code": "@[nolint unusedArguments] def Result {\u03b1 : Q(Type u)} (x : Q($\u03b1)) := Result'", "start": [251, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isTrue", "code": "@[match_pattern, inline] def Result.isTrue {x : Q(Prop)} :\n    \u2200 (proof : Q($x)), @Result _ (q(Prop) : Q(Type)) x := Result'.isBool true", "start": [256, 1], "end": [258, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isFalse", "code": "@[match_pattern, inline] def Result.isFalse {x : Q(Prop)} :\n    \u2200 (proof : Q(\u00ac$x)), @Result _ (q(Prop) : Q(Type)) x := Result'.isBool false", "start": [260, 1], "end": [262, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isNat", "code": "@[match_pattern, inline] def Result.isNat {\u03b1 : Q(Type u)} {x : Q($\u03b1)} :\n    \u2200 (inst : Q(AddMonoidWithOne $\u03b1) := by assumption) (lit : Q(\u2115)) (proof : Q(IsNat $x $lit)),\n      Result x := Result'.isNat", "start": [264, 1], "end": [267, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isNegNat", "code": "@[match_pattern, inline] def Result.isNegNat {\u03b1 : Q(Type u)} {x : Q($\u03b1)} :\n    \u2200 (inst : Q(Ring $\u03b1) := by assumption) (lit : Q(\u2115)) (proof : Q(IsInt $x (.negOfNat $lit))),\n      Result x := Result'.isNegNat", "start": [269, 1], "end": [273, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isRat", "code": "@[match_pattern, inline] def Result.isRat {\u03b1 : Q(Type u)} {x : Q($\u03b1)} :\n    \u2200 (inst : Q(DivisionRing $\u03b1) := by assumption) (q : Rat) (n : Q(\u2124)) (d : Q(\u2115))\n      (proof : Q(IsRat $x $n $d)), Result x := Result'.isRat", "start": [275, 1], "end": [280, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isInt", "code": "def Result.isInt {\u03b1 : Q(Type u)} {x : Q($\u03b1)} (inst : Q(Ring $\u03b1) := by assumption)\n    (z : Q(\u2124)) (n : \u2124) (proof : Q(IsInt $x $z)) : Result x :=\n  have lit : Q(\u2115) := z.appArg!\n  if 0 \u2264 n then\n    let proof : Q(IsInt $x (.ofNat $lit)) := proof\n    .isNat q(instAddMonoidWithOne) lit q(IsInt.to_isNat $proof)\n  else\n    .isNegNat inst lit proof", "start": [284, 1], "end": [294, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.isRat'", "code": "def Result.isRat' {\u03b1 : Q(Type u)} {x : Q($\u03b1)} (inst : Q(DivisionRing $\u03b1) := by assumption)\n    (q : Rat) (n : Q(\u2124)) (d : Q(\u2115)) (proof : Q(IsRat $x $n $d)) : Result x :=\n  if q.den = 1 then\n    have proof : Q(IsRat $x $n (nat_lit 1)) := proof\n    .isInt q(DivisionRing.toRing) n q.num q(IsRat.to_isInt $proof)\n  else\n    .isRat inst q n d proof", "start": [296, 1], "end": [304, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toRat", "code": "def Result.toRat : Result e \u2192 Option Rat\n  | .isBool .. => none\n  | .isNat _ lit _ => some lit.natLit!\n  | .isNegNat _ lit _ => some (-lit.natLit!)\n  | .isRat _ q .. => some q", "start": [314, 1], "end": [319, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toRatNZ", "code": "def Result.toRatNZ : Result e \u2192 Option (Rat \u00d7 Option Expr)\n  | .isBool .. => none\n  | .isNat _ lit _ => some (lit.natLit!, none)\n  | .isNegNat _ lit _ => some (-lit.natLit!, none)\n  | .isRat _ q _ _ p => some (q, q(IsRat.den_nz $p))", "start": [321, 1], "end": [327, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toInt", "code": "def Result.toInt {\u03b1 : Q(Type u)} {e : Q($\u03b1)} (_i : Q(Ring $\u03b1) := by with_reducible assumption) :\n    Result e \u2192 Option (\u2124 \u00d7 (lit : Q(\u2124)) \u00d7 Q(IsInt $e $lit))\n  | .isNat _ lit proof => do\n    have proof : Q(@IsNat _ instAddMonoidWithOne $e $lit) := proof\n    pure \u27e8lit.natLit!, q(.ofNat $lit), q(($proof).to_isInt)\u27e9\n  | .isNegNat _ lit proof => pure \u27e8-lit.natLit!, q(.negOfNat $lit), proof\u27e9\n  | _ => failure", "start": [329, 1], "end": [339, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toRat'", "code": "def Result.toRat' {\u03b1 : Q(Type u)} {e : Q($\u03b1)}\n    (_i : Q(DivisionRing $\u03b1) := by with_reducible assumption) :\n    Result e \u2192 Option (\u211a \u00d7 (n : Q(\u2124)) \u00d7 (d : Q(\u2115)) \u00d7 Q(IsRat $e $n $d))\n  | .isBool .. => none\n  | .isNat _ lit proof =>\n    have proof : Q(@IsNat _ instAddMonoidWithOne $e $lit) := proof\n    some \u27e8lit.natLit!, q(.ofNat $lit), q(nat_lit 1), q(($proof).to_isRat)\u27e9\n  | .isNegNat _ lit proof =>\n    have proof : Q(@IsInt _ DivisionRing.toRing $e (.negOfNat $lit)) := proof\n    some \u27e8-lit.natLit!, q(.negOfNat $lit), q(nat_lit 1),\n      (q(@IsInt.to_isRat _ DivisionRing.toRing _ _ $proof) : Expr)\u27e9\n  | .isRat _ q n d proof => some \u27e8q, n, d, proof\u27e9", "start": [341, 1], "end": [356, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toRawEq", "code": "def Result.toRawEq {\u03b1 : Q(Type u)} {e : Q($\u03b1)} : Result e \u2192 (e' : Q($\u03b1)) \u00d7 Q($e = $e')\n  | .isBool false p =>\n    have e : Q(Prop) := e; have p : Q(\u00ac$e) := p\n    \u27e8(q(False) : Expr), (q(eq_false $p) : Expr)\u27e9\n  | .isBool true p =>\n    have e : Q(Prop) := e; have p : Q($e) := p\n    \u27e8(q(True) : Expr), (q(eq_true $p) : Expr)\u27e9\n  | .isNat _ lit p => \u27e8q(Nat.rawCast $lit), q(IsNat.to_raw_eq $p)\u27e9\n  | .isNegNat _ lit p => \u27e8q(Int.rawCast (.negOfNat $lit)), q(IsInt.to_raw_eq $p)\u27e9\n  | .isRat _ _ n d p => \u27e8q(Rat.rawCast $n $d), q(IsRat.to_raw_eq $p)\u27e9", "start": [358, 1], "end": [372, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toRawIntEq", "code": "def Result.toRawIntEq {\u03b1 : Q(Type u)} {e : Q($\u03b1)} : Result e \u2192\n    Option (\u2124 \u00d7 (e' : Q($\u03b1)) \u00d7 Q($e = $e'))\n  | .isNat _ lit p => some \u27e8lit.natLit!, q(Nat.rawCast $lit), q(IsNat.to_raw_eq $p)\u27e9\n  | .isNegNat _ lit p => some \u27e8-lit.natLit!, q(Int.rawCast (.negOfNat $lit)), q(IsInt.to_raw_eq $p)\u27e9\n  | .isRat _ .. | .isBool .. => none", "start": [374, 1], "end": [384, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.ofRawNat", "code": "def Result.ofRawNat {\u03b1 : Q(Type u)} (e : Q($\u03b1)) : Result e := Id.run do\n  let .app (.app _ (s\u03b1 : Q(AddMonoidWithOne $\u03b1))) (lit : Q(\u2115)) := e | panic! \"not a raw nat cast\"\n  .isNat s\u03b1 lit (q(IsNat.of_raw $\u03b1 $lit) : Expr)", "start": [386, 1], "end": [389, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.ofRawInt", "code": "def Result.ofRawInt {\u03b1 : Q(Type u)} (n : \u2124) (e : Q($\u03b1)) : Result e :=\n  if 0 \u2264 n then\n    Result.ofRawNat e\n  else Id.run do\n    let .app (.app _ (r\u03b1 : Q(Ring $\u03b1))) (.app _ (lit : Q(\u2115))) := e | panic! \"not a raw int cast\"\n    .isNegNat r\u03b1 lit (q(IsInt.of_raw $\u03b1 (.negOfNat $lit)) : Expr)", "start": [391, 1], "end": [398, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.ofRawRat", "code": "def Result.ofRawRat {\u03b1 : Q(Type u)} (q : \u211a) (e : Q($\u03b1)) (hyp : Option Expr := none) : Result e :=\n  if q.den = 1 then\n    Result.ofRawInt q.num e\n  else Id.run do\n    let .app (.app (.app _ (d\u03b1 : Q(DivisionRing $\u03b1))) (n : Q(\u2124))) (d : Q(\u2115)) := e\n      | panic! \"not a raw rat cast\"\n    let hyp : Q(($d : $\u03b1) \u2260 0) := hyp.get!\n    .isRat d\u03b1 q n d (q(IsRat.of_raw $\u03b1 $n $d $hyp) : Expr)", "start": [400, 1], "end": [409, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.toSimpResult", "code": "def Result.toSimpResult {\u03b1 : Q(Type u)} {e : Q($\u03b1)} : Result e \u2192 MetaM Simp.Result\n  | r@(.isBool ..) => let \u27e8expr, proof?\u27e9 := r.toRawEq; pure { expr, proof? }\n  | .isNat s\u03b1 lit p => do\n    let \u27e8a', pa'\u27e9 \u2190 mkOfNat \u03b1 s\u03b1 lit\n    return { expr := a', proof? := q(IsNat.to_eq $p $pa') }\n  | .isNegNat _r\u03b1 lit p => do\n    let \u27e8a', pa'\u27e9 \u2190 mkOfNat \u03b1 q(AddCommMonoidWithOne.toAddMonoidWithOne) lit\n    return { expr := q(-$a'), proof? := q(IsInt.neg_to_eq $p $pa') }\n  | .isRat _ q n d p => do\n    have lit : Q(\u2115) := n.appArg!\n    if q < 0 then\n      let p : Q(IsRat $e (.negOfNat $lit) $d) := p\n      let \u27e8n', pn'\u27e9 \u2190 mkOfNat \u03b1 q(AddCommMonoidWithOne.toAddMonoidWithOne) lit\n      let \u27e8d', pd'\u27e9 \u2190 mkOfNat \u03b1 q(AddCommMonoidWithOne.toAddMonoidWithOne) d\n      return { expr := q(-($n' / $d')), proof? := q(IsRat.neg_to_eq $p $pn' $pd') }\n    else\n      let p : Q(IsRat $e (.ofNat $lit) $d) := p\n      let \u27e8n', pn'\u27e9 \u2190 mkOfNat \u03b1 q(AddCommMonoidWithOne.toAddMonoidWithOne) lit\n      let \u27e8d', pd'\u27e9 \u2190 mkOfNat \u03b1 q(AddCommMonoidWithOne.toAddMonoidWithOne) d\n      return { expr := q($n' / $d'), proof? := q(IsRat.nonneg_to_eq $p $pn' $pd') }", "start": [411, 1], "end": [431, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.BoolResult", "code": "@[reducible]\ndef BoolResult (p : Q(Prop)) (b : Bool) : Type :=\n  Q(Bool.rec (\u00ac $p) ($p) $b)", "start": [433, 1], "end": [439, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Result.ofBoolResult", "code": "def Result.ofBoolResult {p : Q(Prop)} {b : Bool} (prf : BoolResult p b) : Result q(Prop) :=\n  Result'.isBool b prf", "start": [441, 1], "end": [443, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Embedding.lean", "imports": ["Mathlib/Logic/Embedding/Basic.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mulLeftEmbedding", "code": "@[to_additive (attr := simps)\n      \"The embedding of a left cancellative additive semigroup into itself\n         by left translation by a fixed element.\" ]\ndef mulLeftEmbedding {G : Type*} [LeftCancelSemigroup G] (g : G) : G \u21aa G where\n  toFun h := g * h\n  inj' := mul_right_injective g", "start": [20, 1], "end": [28, 32], "kind": "commanddeclaration"}, {"full_name": "mulRightEmbedding", "code": "@[to_additive (attr := simps)\n      \"The embedding of a right cancellative additive semigroup into itself\n         by right translation by a fixed element.\"]\ndef mulRightEmbedding {G : Type*} [RightCancelSemigroup G] (g : G) : G \u21aa G where\n  toFun h := h * g\n  inj' := mul_left_injective g", "start": [34, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "mulLeftEmbedding_eq_mulRightEmbedding", "code": "@[to_additive]\ntheorem mulLeftEmbedding_eq_mulRightEmbedding {G : Type*} [CancelCommMonoid G] (g : G) :\n    mulLeftEmbedding g = mulRightEmbedding g", "start": [48, 1], "end": [52, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Basic.lean", "imports": ["Mathlib/Data/Multiset/FinsetOps.lean", "Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset", "code": "structure Finset (\u03b1 : Type*) where\n  \n  val : Multiset \u03b1\n  \n  nodup : Nodup val", "start": [136, 1], "end": [142, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.canLiftFinset", "code": "instance Multiset.canLiftFinset {\u03b1} : CanLift (Multiset \u03b1) (Finset \u03b1) Finset.val Multiset.Nodup :=\n  \u27e8fun m hm => \u27e8\u27e8m, hm\u27e9, rfl\u27e9\u27e9", "start": [145, 1], "end": [146, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_veq", "code": "theorem eq_of_veq : \u2200 {s t : Finset \u03b1}, s.1 = t.1 \u2192 s = t", "start": [151, 1], "end": [152, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.val_injective", "code": "theorem val_injective : Injective (val : Finset \u03b1 \u2192 Multiset \u03b1)", "start": [155, 1], "end": [155, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.val_inj", "code": "@[simp]\ntheorem val_inj {s t : Finset \u03b1} : s.1 = t.1 \u2194 s = t", "start": [158, 1], "end": [160, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.dedup_eq_self", "code": "@[simp]\ntheorem dedup_eq_self [DecidableEq \u03b1] (s : Finset \u03b1) : dedup s.1 = s.1", "start": [163, 1], "end": [165, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] : DecidableEq (Finset \u03b1)\n  | _, _ => decidable_of_iff _ val_inj", "start": [168, 1], "end": [169, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_def", "code": "theorem mem_def {a : \u03b1} {s : Finset \u03b1} : a \u2208 s \u2194 a \u2208 s.1", "start": [178, 1], "end": [179, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_val", "code": "@[simp]\ntheorem mem_val {a : \u03b1} {s : Finset \u03b1} : a \u2208 s.1 \u2194 a \u2208 s", "start": [182, 1], "end": [184, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_mk", "code": "@[simp]\ntheorem mem_mk {a : \u03b1} {s nd} : a \u2208 @Finset.mk \u03b1 s nd \u2194 a \u2208 s", "start": [187, 1], "end": [189, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableMem", "code": "instance decidableMem [_h : DecidableEq \u03b1] (a : \u03b1) (s : Finset \u03b1) : Decidable (a \u2208 s) :=\n  Multiset.decidableMem _ _", "start": [192, 1], "end": [193, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.toSet", "code": "@[coe] def toSet (s : Finset \u03b1) : Set \u03b1 :=\n  { a | a \u2208 s }", "start": [199, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_coe", "code": "@[simp, norm_cast]\ntheorem mem_coe {a : \u03b1} {s : Finset \u03b1} : a \u2208 (s : Set \u03b1) \u2194 a \u2208 (s : Finset \u03b1)", "start": [207, 1], "end": [209, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.setOf_mem", "code": "@[simp]\ntheorem setOf_mem {\u03b1} {s : Finset \u03b1} : { a | a \u2208 s } = s", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_mem", "code": "@[simp]\ntheorem coe_mem {s : Finset \u03b1} (x : (s : Set \u03b1)) : \u2191x \u2208 s", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mk_coe", "code": "theorem mk_coe {s : Finset \u03b1} (x : (s : Set \u03b1)) {h} : (\u27e8x, h\u27e9 : (s : Set \u03b1)) = x", "start": [223, 1], "end": [224, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableMem'", "code": "instance decidableMem' [DecidableEq \u03b1] (a : \u03b1) (s : Finset \u03b1) : Decidable (a \u2208 (s : Set \u03b1)) :=\n  s.decidableMem _", "start": [227, 1], "end": [228, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.ext_iff", "code": "theorem ext_iff {s\u2081 s\u2082 : Finset \u03b1} : s\u2081 = s\u2082 \u2194 \u2200 a, a \u2208 s\u2081 \u2194 a \u2208 s\u2082", "start": [234, 1], "end": [235, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.ext", "code": "@[ext]\ntheorem ext {s\u2081 s\u2082 : Finset \u03b1} : (\u2200 a, a \u2208 s\u2081 \u2194 a \u2208 s\u2082) \u2192 s\u2081 = s\u2082", "start": [238, 1], "end": [240, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {s\u2081 s\u2082 : Finset \u03b1} : (s\u2081 : Set \u03b1) = s\u2082 \u2194 s\u2081 = s\u2082", "start": [243, 1], "end": [245, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_injective", "code": "theorem coe_injective {\u03b1} : Injective ((\u2191) : Finset \u03b1 \u2192 Set \u03b1)", "start": [248, 1], "end": [248, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_coe", "code": "protected theorem forall_coe {\u03b1 : Type*} (s : Finset \u03b1) (p : s \u2192 Prop) :\n    (\u2200 x : s, p x) \u2194 \u2200 (x : \u03b1) (h : x \u2208 s), p \u27e8x, h\u27e9", "start": [259, 1], "end": [261, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_coe", "code": "protected theorem exists_coe {\u03b1 : Type*} (s : Finset \u03b1) (p : s \u2192 Prop) :\n    (\u2203 x : s, p x) \u2194 \u2203 (x : \u03b1) (h : x \u2208 s), p \u27e8x, h\u27e9", "start": [265, 1], "end": [267, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.PiFinsetCoe.canLift", "code": "instance PiFinsetCoe.canLift (\u03b9 : Type*) (\u03b1 : \u2200 _i : \u03b9, Type*) [_ne : \u2200 i, Nonempty (\u03b1 i)]\n    (s : Finset \u03b9) : CanLift (\u2200 i : s, \u03b1 i) (\u2200 i, \u03b1 i) (fun f i => f i) fun _ => True :=\n  PiSubtype.canLift \u03b9 \u03b1 (\u00b7 \u2208 s)", "start": [270, 1], "end": [272, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.PiFinsetCoe.canLift'", "code": "instance PiFinsetCoe.canLift' (\u03b9 \u03b1 : Type*) [_ne : Nonempty \u03b1] (s : Finset \u03b9) :\n    CanLift (s \u2192 \u03b1) (\u03b9 \u2192 \u03b1) (fun f i => f i) fun _ => True :=\n  PiFinsetCoe.canLift \u03b9 (fun _ => \u03b1) s", "start": [275, 1], "end": [277, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.FinsetCoe.canLift", "code": "instance FinsetCoe.canLift (s : Finset \u03b1) : CanLift \u03b1 s (\u2191) fun a => a \u2208 s where\n  prf a ha := \u27e8\u27e8a, ha\u27e9, rfl\u27e9", "start": [280, 1], "end": [281, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sort_coe", "code": "@[simp, norm_cast]\ntheorem coe_sort_coe (s : Finset \u03b1) : ((s : Set \u03b1) : Sort _) = s", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.partialOrder", "code": "instance partialOrder : PartialOrder (Finset \u03b1) where\n  le := (\u00b7 \u2286 \u00b7)\n  lt := (\u00b7 \u2282 \u00b7)\n  le_refl s a := id\n  le_trans s t u hst htu a ha := htu <| hst ha\n  le_antisymm s t hst hts := ext fun a => \u27e8@hst _, @hts _\u27e9", "start": [302, 1], "end": [307, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_def", "code": "theorem subset_def : s \u2286 t \u2194 s.1 \u2286 t.1", "start": [330, 1], "end": [331, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_def", "code": "theorem ssubset_def : s \u2282 t \u2194 s \u2286 t \u2227 \u00act \u2286 s", "start": [334, 1], "end": [335, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.Subset.refl", "code": "@[simp]\ntheorem Subset.refl (s : Finset \u03b1) : s \u2286 s", "start": [338, 1], "end": [340, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.Subset.rfl", "code": "protected theorem Subset.rfl {s : Finset \u03b1} : s \u2286 s", "start": [343, 1], "end": [344, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_of_eq", "code": "protected theorem subset_of_eq {s t : Finset \u03b1} (h : s = t) : s \u2286 t", "start": [347, 1], "end": [348, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.Subset.trans", "code": "theorem Subset.trans {s\u2081 s\u2082 s\u2083 : Finset \u03b1} : s\u2081 \u2286 s\u2082 \u2192 s\u2082 \u2286 s\u2083 \u2192 s\u2081 \u2286 s\u2083", "start": [351, 1], "end": [352, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Superset.trans", "code": "theorem Superset.trans {s\u2081 s\u2082 s\u2083 : Finset \u03b1} : s\u2081 \u2287 s\u2082 \u2192 s\u2082 \u2287 s\u2083 \u2192 s\u2081 \u2287 s\u2083", "start": [355, 1], "end": [356, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_subset", "code": "theorem mem_of_subset {s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} : s\u2081 \u2286 s\u2082 \u2192 a \u2208 s\u2081 \u2192 a \u2208 s\u2082", "start": [359, 1], "end": [360, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_mono", "code": "theorem not_mem_mono {s t : Finset \u03b1} (h : s \u2286 t) {a : \u03b1} : a \u2209 t \u2192 a \u2209 s", "start": [363, 1], "end": [364, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.Subset.antisymm", "code": "theorem Subset.antisymm {s\u2081 s\u2082 : Finset \u03b1} (H\u2081 : s\u2081 \u2286 s\u2082) (H\u2082 : s\u2082 \u2286 s\u2081) : s\u2081 = s\u2082", "start": [367, 1], "end": [368, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_iff", "code": "theorem subset_iff {s\u2081 s\u2082 : Finset \u03b1} : s\u2081 \u2286 s\u2082 \u2194 \u2200 \u2983x\u2984, x \u2208 s\u2081 \u2192 x \u2208 s\u2082", "start": [371, 1], "end": [372, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_subset", "code": "@[simp, norm_cast]\ntheorem coe_subset {s\u2081 s\u2082 : Finset \u03b1} : (s\u2081 : Set \u03b1) \u2286 s\u2082 \u2194 s\u2081 \u2286 s\u2082", "start": [375, 1], "end": [377, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.val_le_iff", "code": "@[simp]\ntheorem val_le_iff {s\u2081 s\u2082 : Finset \u03b1} : s\u2081.1 \u2264 s\u2082.1 \u2194 s\u2081 \u2286 s\u2082", "start": [380, 1], "end": [382, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.Subset.antisymm_iff", "code": "theorem Subset.antisymm_iff {s\u2081 s\u2082 : Finset \u03b1} : s\u2081 = s\u2082 \u2194 s\u2081 \u2286 s\u2082 \u2227 s\u2082 \u2286 s\u2081", "start": [385, 1], "end": [386, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.not_subset", "code": "theorem not_subset : \u00acs \u2286 t \u2194 \u2203 x \u2208 s, x \u2209 t", "start": [389, 1], "end": [389, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.le_eq_subset", "code": "@[simp]\ntheorem le_eq_subset : ((\u00b7 \u2264 \u00b7) : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Prop) = (\u00b7 \u2286 \u00b7)", "start": [392, 1], "end": [394, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_eq_subset", "code": "@[simp]\ntheorem lt_eq_subset : ((\u00b7 < \u00b7) : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Prop) = (\u00b7 \u2282 \u00b7)", "start": [397, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.le_iff_subset", "code": "theorem le_iff_subset {s\u2081 s\u2082 : Finset \u03b1} : s\u2081 \u2264 s\u2082 \u2194 s\u2081 \u2286 s\u2082", "start": [402, 1], "end": [403, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_iff_ssubset", "code": "theorem lt_iff_ssubset {s\u2081 s\u2082 : Finset \u03b1} : s\u2081 < s\u2082 \u2194 s\u2081 \u2282 s\u2082", "start": [406, 1], "end": [407, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_ssubset", "code": "@[simp, norm_cast]\ntheorem coe_ssubset {s\u2081 s\u2082 : Finset \u03b1} : (s\u2081 : Set \u03b1) \u2282 s\u2082 \u2194 s\u2081 \u2282 s\u2082", "start": [410, 1], "end": [412, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.val_lt_iff", "code": "@[simp]\ntheorem val_lt_iff {s\u2081 s\u2082 : Finset \u03b1} : s\u2081.1 < s\u2082.1 \u2194 s\u2081 \u2282 s\u2082", "start": [415, 1], "end": [417, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_iff_subset_ne", "code": "theorem ssubset_iff_subset_ne {s t : Finset \u03b1} : s \u2282 t \u2194 s \u2286 t \u2227 s \u2260 t", "start": [420, 1], "end": [421, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_iff_of_subset", "code": "theorem ssubset_iff_of_subset {s\u2081 s\u2082 : Finset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081 \u2282 s\u2082 \u2194 \u2203 x \u2208 s\u2082, x \u2209 s\u2081", "start": [424, 1], "end": [425, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_of_ssubset_of_subset", "code": "theorem ssubset_of_ssubset_of_subset {s\u2081 s\u2082 s\u2083 : Finset \u03b1} (hs\u2081s\u2082 : s\u2081 \u2282 s\u2082) (hs\u2082s\u2083 : s\u2082 \u2286 s\u2083) :\n    s\u2081 \u2282 s\u2083", "start": [428, 1], "end": [430, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_of_subset_of_ssubset", "code": "theorem ssubset_of_subset_of_ssubset {s\u2081 s\u2082 s\u2083 : Finset \u03b1} (hs\u2081s\u2082 : s\u2081 \u2286 s\u2082) (hs\u2082s\u2083 : s\u2082 \u2282 s\u2083) :\n    s\u2081 \u2282 s\u2083", "start": [433, 1], "end": [435, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_of_ssubset", "code": "theorem exists_of_ssubset {s\u2081 s\u2082 : Finset \u03b1} (h : s\u2081 \u2282 s\u2082) : \u2203 x \u2208 s\u2082, x \u2209 s\u2081", "start": [438, 1], "end": [439, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.isWellFounded_ssubset", "code": "instance isWellFounded_ssubset : IsWellFounded (Finset \u03b1) (\u00b7 \u2282 \u00b7) :=\n  Subrelation.isWellFounded (InvImage _ _) val_lt_iff.2", "start": [442, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.wellFoundedLT", "code": "instance wellFoundedLT : WellFoundedLT (Finset \u03b1) :=\n  Finset.isWellFounded_ssubset", "start": [446, 1], "end": [447, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.coeEmb", "code": "def coeEmb : Finset \u03b1 \u21aao Set \u03b1 :=\n  \u27e8\u27e8(\u2191), coe_injective\u27e9, coe_subset\u27e9", "start": [458, 1], "end": [460, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_coeEmb", "code": "@[simp]\ntheorem coe_coeEmb : \u21d1(coeEmb : Finset \u03b1 \u21aao Set \u03b1) = ((\u2191) : Finset \u03b1 \u2192 Set \u03b1)", "start": [463, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty", "code": "protected def Nonempty (s : Finset \u03b1) : Prop :=\n  \u2203 x : \u03b1, x \u2208 s", "start": [471, 1], "end": [475, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableNonempty", "code": "instance decidableNonempty {s : Finset \u03b1} : Decidable s.Nonempty :=\n  Quotient.recOnSubsingleton (motive := fun s : Multiset \u03b1 => Decidable (\u2203 a, a \u2208 s)) s.1\n    (fun l : List \u03b1 =>\n      match l with\n      | [] => isFalse <| by simp\n      | a::l => isTrue \u27e8a, by simp\u27e9)", "start": [479, 1], "end": [484, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_nonempty", "code": "@[simp, norm_cast]\ntheorem coe_nonempty {s : Finset \u03b1} : (s : Set \u03b1).Nonempty \u2194 s.Nonempty", "start": [487, 1], "end": [489, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_coe_sort", "code": "theorem nonempty_coe_sort {s : Finset \u03b1} : Nonempty (s : Type _) \u2194 s.Nonempty", "start": [493, 1], "end": [494, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.to_set", "code": "alias \u27e8_, Nonempty.to_set\u27e9 := coe_nonempty", "start": [497, 1], "end": [497, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Nonempty.coe_sort", "code": "alias \u27e8_, Nonempty.coe_sort\u27e9 := nonempty_coe_sort", "start": [500, 1], "end": [500, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Nonempty.bex", "code": "theorem Nonempty.bex {s : Finset \u03b1} (h : s.Nonempty) : \u2203 x : \u03b1, x \u2208 s", "start": [503, 1], "end": [504, 4], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.mono", "code": "theorem Nonempty.mono {s t : Finset \u03b1} (hst : s \u2286 t) (hs : s.Nonempty) : t.Nonempty", "start": [507, 1], "end": [508, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.forall_const", "code": "theorem Nonempty.forall_const {s : Finset \u03b1} (h : s.Nonempty) {p : Prop} : (\u2200 x \u2208 s, p) \u2194 p", "start": [511, 1], "end": [513, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.to_subtype", "code": "theorem Nonempty.to_subtype {s : Finset \u03b1} : s.Nonempty \u2192 Nonempty s", "start": [516, 1], "end": [517, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.to_type", "code": "theorem Nonempty.to_type {s : Finset \u03b1} : s.Nonempty \u2192 Nonempty \u03b1", "start": [520, 1], "end": [520, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.empty", "code": "protected def empty : Finset \u03b1 :=\n  \u27e80, nodup_zero\u27e9", "start": [530, 1], "end": [532, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.inhabitedFinset", "code": "instance inhabitedFinset : Inhabited (Finset \u03b1) :=\n  \u27e8\u2205\u27e9", "start": [538, 1], "end": [539, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_val", "code": "@[simp]\ntheorem empty_val : (\u2205 : Finset \u03b1).1 = 0", "start": [542, 1], "end": [544, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_empty", "code": "@[simp]\ntheorem not_mem_empty (a : \u03b1) : a \u2209 (\u2205 : Finset \u03b1)", "start": [547, 1], "end": [550, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.not_nonempty_empty", "code": "@[simp]\ntheorem not_nonempty_empty : \u00ac(\u2205 : Finset \u03b1).Nonempty", "start": [553, 1], "end": [554, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.mk_zero", "code": "@[simp]\ntheorem mk_zero : (\u27e80, nodup_zero\u27e9 : Finset \u03b1) = \u2205", "start": [557, 1], "end": [559, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ne_empty_of_mem", "code": "theorem ne_empty_of_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2208 s) : s \u2260 \u2205", "start": [562, 1], "end": [563, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.ne_empty", "code": "theorem Nonempty.ne_empty {s : Finset \u03b1} (h : s.Nonempty) : s \u2260 \u2205", "start": [566, 1], "end": [567, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_subset", "code": "@[simp]\ntheorem empty_subset (s : Finset \u03b1) : \u2205 \u2286 s", "start": [570, 1], "end": [572, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_of_forall_not_mem", "code": "theorem eq_empty_of_forall_not_mem {s : Finset \u03b1} (H : \u2200 x, x \u2209 s) : s = \u2205", "start": [575, 1], "end": [576, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_iff_forall_not_mem", "code": "theorem eq_empty_iff_forall_not_mem {s : Finset \u03b1} : s = \u2205 \u2194 \u2200 x, x \u2209 s", "start": [579, 1], "end": [581, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.val_eq_zero", "code": "@[simp]\ntheorem val_eq_zero {s : Finset \u03b1} : s.1 = 0 \u2194 s = \u2205", "start": [584, 1], "end": [586, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_empty", "code": "theorem subset_empty {s : Finset \u03b1} : s \u2286 \u2205 \u2194 s = \u2205", "start": [589, 1], "end": [590, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.not_ssubset_empty", "code": "@[simp]\ntheorem not_ssubset_empty (s : Finset \u03b1) : \u00acs \u2282 \u2205", "start": [593, 1], "end": [597, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_of_ne_empty", "code": "theorem nonempty_of_ne_empty {s : Finset \u03b1} (h : s \u2260 \u2205) : s.Nonempty", "start": [600, 1], "end": [601, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_iff_ne_empty", "code": "theorem nonempty_iff_ne_empty {s : Finset \u03b1} : s.Nonempty \u2194 s \u2260 \u2205", "start": [604, 1], "end": [605, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.not_nonempty_iff_eq_empty", "code": "@[simp]\ntheorem not_nonempty_iff_eq_empty {s : Finset \u03b1} : \u00acs.Nonempty \u2194 s = \u2205", "start": [608, 1], "end": [610, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_or_nonempty", "code": "theorem eq_empty_or_nonempty (s : Finset \u03b1) : s = \u2205 \u2228 s.Nonempty", "start": [613, 1], "end": [614, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_empty", "code": "@[simp, norm_cast]\ntheorem coe_empty : ((\u2205 : Finset \u03b1) : Set \u03b1) = \u2205", "start": [617, 1], "end": [619, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_eq_empty", "code": "@[simp, norm_cast]\ntheorem coe_eq_empty {s : Finset \u03b1} : (s : Set \u03b1) = \u2205 \u2194 s = \u2205", "start": [622, 1], "end": [623, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.isEmpty_coe_sort", "code": "theorem isEmpty_coe_sort {s : Finset \u03b1} : IsEmpty (s : Type _) \u2194 s = \u2205", "start": [627, 1], "end": [628, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.instIsEmpty", "code": "instance instIsEmpty : IsEmpty (\u2205 : Finset \u03b1) :=\n  isEmpty_coe_sort.2 rfl", "start": [631, 1], "end": [632, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_of_isEmpty", "code": "theorem eq_empty_of_isEmpty [IsEmpty \u03b1] (s : Finset \u03b1) : s = \u2205", "start": [634, 1], "end": [636, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.bot_eq_empty", "code": "@[simp]\ntheorem bot_eq_empty : (\u22a5 : Finset \u03b1) = \u2205", "start": [643, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_ssubset", "code": "@[simp]\ntheorem empty_ssubset : \u2205 \u2282 s \u2194 s.Nonempty", "start": [648, 1], "end": [650, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.empty_ssubset", "code": "alias \u27e8_, Nonempty.empty_ssubset\u27e9 := empty_ssubset", "start": [653, 1], "end": [653, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.singleton_val", "code": "@[simp]\ntheorem singleton_val (a : \u03b1) : ({a} : Finset \u03b1).1 = {a}", "start": [672, 1], "end": [674, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_singleton", "code": "@[simp]\ntheorem mem_singleton {a b : \u03b1} : b \u2208 ({a} : Finset \u03b1) \u2194 b = a", "start": [677, 1], "end": [679, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_mem_singleton", "code": "theorem eq_of_mem_singleton {x y : \u03b1} (h : x \u2208 ({y} : Finset \u03b1)) : x = y", "start": [682, 1], "end": [683, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_singleton", "code": "theorem not_mem_singleton {a b : \u03b1} : a \u2209 ({b} : Finset \u03b1) \u2194 a \u2260 b", "start": [686, 1], "end": [687, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_singleton_self", "code": "theorem mem_singleton_self (a : \u03b1) : a \u2208 ({a} : Finset \u03b1)", "start": [690, 1], "end": [692, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.val_eq_singleton_iff", "code": "@[simp]\ntheorem val_eq_singleton_iff {a : \u03b1} {s : Finset \u03b1} : s.val = {a} \u2194 s = {a}", "start": [695, 1], "end": [698, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_injective", "code": "theorem singleton_injective : Injective (singleton : \u03b1 \u2192 Finset \u03b1)", "start": [701, 1], "end": [702, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_inj", "code": "@[simp]\ntheorem singleton_inj : ({a} : Finset \u03b1) = {b} \u2194 a = b", "start": [705, 1], "end": [707, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_nonempty", "code": "@[simp]\ntheorem singleton_nonempty (a : \u03b1) : ({a} : Finset \u03b1).Nonempty", "start": [710, 1], "end": [712, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_ne_empty", "code": "@[simp]\ntheorem singleton_ne_empty (a : \u03b1) : ({a} : Finset \u03b1) \u2260 \u2205", "start": [715, 1], "end": [717, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_ssubset_singleton", "code": "theorem empty_ssubset_singleton : (\u2205 : Finset \u03b1) \u2282 {a}", "start": [720, 1], "end": [721, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_singleton", "code": "@[simp, norm_cast]\ntheorem coe_singleton (a : \u03b1) : (({a} : Finset \u03b1) : Set \u03b1) = {a}", "start": [724, 1], "end": [727, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_eq_singleton", "code": "@[simp, norm_cast]\ntheorem coe_eq_singleton {s : Finset \u03b1} {a : \u03b1} : (s : Set \u03b1) = {a} \u2194 s = {a}", "start": [730, 1], "end": [732, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_singleton_iff_unique_mem", "code": "theorem eq_singleton_iff_unique_mem {s : Finset \u03b1} {a : \u03b1} : s = {a} \u2194 a \u2208 s \u2227 \u2200 x \u2208 s, x = a", "start": [735, 1], "end": [741, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_singleton_iff_nonempty_unique_mem", "code": "theorem eq_singleton_iff_nonempty_unique_mem {s : Finset \u03b1} {a : \u03b1} :\n    s = {a} \u2194 s.Nonempty \u2227 \u2200 x \u2208 s, x = a", "start": [744, 1], "end": [753, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_iff_eq_singleton_default", "code": "theorem nonempty_iff_eq_singleton_default [Unique \u03b1] {s : Finset \u03b1} : s.Nonempty \u2194 s = {default}", "start": [756, 1], "end": [757, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.eq_singleton_default", "code": "alias \u27e8Nonempty.eq_singleton_default, _\u27e9 := nonempty_iff_eq_singleton_default", "start": [760, 1], "end": [760, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.singleton_iff_unique_mem", "code": "theorem singleton_iff_unique_mem (s : Finset \u03b1) : (\u2203 a, s = {a}) \u2194 \u2203! a, a \u2208 s", "start": [763, 1], "end": [764, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_subset_set_iff", "code": "theorem singleton_subset_set_iff {s : Set \u03b1} {a : \u03b1} : \u2191({a} : Finset \u03b1) \u2286 s \u2194 a \u2208 s", "start": [767, 1], "end": [768, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_subset_iff", "code": "@[simp]\ntheorem singleton_subset_iff {s : Finset \u03b1} {a : \u03b1} : {a} \u2286 s \u2194 a \u2208 s", "start": [771, 1], "end": [773, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_singleton_iff", "code": "@[simp]\ntheorem subset_singleton_iff {s : Finset \u03b1} {a : \u03b1} : s \u2286 {a} \u2194 s = \u2205 \u2228 s = {a}", "start": [776, 1], "end": [778, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_subset_singleton", "code": "theorem singleton_subset_singleton : ({a} : Finset \u03b1) \u2286 {b} \u2194 a = b", "start": [781, 1], "end": [781, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.subset_singleton_iff", "code": "protected theorem Nonempty.subset_singleton_iff {s : Finset \u03b1} {a : \u03b1} (h : s.Nonempty) :\n    s \u2286 {a} \u2194 s = {a}", "start": [784, 1], "end": [786, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_singleton_iff'", "code": "theorem subset_singleton_iff' {s : Finset \u03b1} {a : \u03b1} : s \u2286 {a} \u2194 \u2200 b \u2208 s, b = a", "start": [789, 1], "end": [790, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_singleton_iff", "code": "@[simp]\ntheorem ssubset_singleton_iff {s : Finset \u03b1} {a : \u03b1} : s \u2282 {a} \u2194 s = \u2205", "start": [793, 1], "end": [795, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_empty_of_ssubset_singleton", "code": "theorem eq_empty_of_ssubset_singleton {s : Finset \u03b1} {x : \u03b1} (hs : s \u2282 {x}) : s = \u2205", "start": [798, 1], "end": [799, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.Nontrivial", "code": "@[reducible]\nprotected def Nontrivial (s : Finset \u03b1) : Prop := (s : Set \u03b1).Nontrivial", "start": [802, 1], "end": [804, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.not_nontrivial_empty", "code": "@[simp]\ntheorem not_nontrivial_empty : \u00ac (\u2205 : Finset \u03b1).Nontrivial", "start": [807, 1], "end": [808, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.not_nontrivial_singleton", "code": "@[simp]\ntheorem not_nontrivial_singleton : \u00ac ({a} : Finset \u03b1).Nontrivial", "start": [811, 1], "end": [812, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.Nontrivial.ne_singleton", "code": "theorem Nontrivial.ne_singleton (hs : s.Nontrivial) : s \u2260 {a}", "start": [815, 1], "end": [816, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_singleton_or_nontrivial", "code": "theorem eq_singleton_or_nontrivial (ha : a \u2208 s) : s = {a} \u2228 s.Nontrivial", "start": [819, 1], "end": [820, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.nontrivial_iff_ne_singleton", "code": "theorem nontrivial_iff_ne_singleton (ha : a \u2208 s) : s.Nontrivial \u2194 s \u2260 {a}", "start": [823, 1], "end": [824, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.exists_eq_singleton_or_nontrivial", "code": "theorem Nonempty.exists_eq_singleton_or_nontrivial : s.Nonempty \u2192 (\u2203 a, s = {a}) \u2228 s.Nontrivial", "start": [827, 1], "end": [828, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.instNontrivial", "code": "instance instNontrivial [Nonempty \u03b1] : Nontrivial (Finset \u03b1) :=\n  \u2039Nonempty \u03b1\u203a.elim fun a => \u27e8\u27e8{a}, \u2205, singleton_ne_empty _\u27e9\u27e9", "start": [831, 1], "end": [832, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.cons", "code": "def cons (a : \u03b1) (s : Finset \u03b1) (h : a \u2209 s) : Finset \u03b1 :=\n  \u27e8a ::\u2098 s.1, nodup_cons.2 \u27e8h, s.2\u27e9\u27e9", "start": [848, 1], "end": [852, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_cons", "code": "@[simp]\ntheorem mem_cons {h} : b \u2208 s.cons a h \u2194 b = a \u2228 b \u2208 s", "start": [855, 1], "end": [857, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_cons_self", "code": "theorem mem_cons_self (a : \u03b1) (s : Finset \u03b1) {h} : a \u2208 cons a s h", "start": [861, 1], "end": [862, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_val", "code": "@[simp]\ntheorem cons_val (h : a \u2209 s) : (cons a s h).1 = a ::\u2098 s.1", "start": [865, 1], "end": [867, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_mem_cons", "code": "theorem forall_mem_cons (h : a \u2209 s) (p : \u03b1 \u2192 Prop) :\n    (\u2200 x, x \u2208 cons a s h \u2192 p x) \u2194 p a \u2227 \u2200 x, x \u2208 s \u2192 p x", "start": [870, 1], "end": [872, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_of_forall_cons", "code": "theorem forall_of_forall_cons {p : \u03b1 \u2192 Prop} {h : a \u2209 s} (H : \u2200 x, x \u2208 cons a s h \u2192 p x) (x)\n    (h : x \u2208 s) : p x", "start": [875, 1], "end": [878, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.mk_cons", "code": "@[simp]\ntheorem mk_cons {s : Multiset \u03b1} (h : (a ::\u2098 s).Nodup) :\n    (\u27e8a ::\u2098 s, h\u27e9 : Finset \u03b1) = cons a \u27e8s, (nodup_cons.1 h).2\u27e9 (nodup_cons.1 h).1", "start": [881, 1], "end": [884, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_empty", "code": "@[simp]\ntheorem cons_empty (a : \u03b1) : cons a \u2205 (not_mem_empty _) = {a}", "start": [887, 1], "end": [888, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_cons", "code": "@[simp]\ntheorem nonempty_cons (h : a \u2209 s) : (cons a s h).Nonempty", "start": [891, 1], "end": [893, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_mk", "code": "@[simp]\ntheorem nonempty_mk {m : Multiset \u03b1} {hm} : (\u27e8m, hm\u27e9 : Finset \u03b1).Nonempty \u2194 m \u2260 0", "start": [896, 1], "end": [898, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_cons", "code": "@[simp]\ntheorem coe_cons {a s h} : (@cons \u03b1 a s h : Set \u03b1) = insert a (s : Set \u03b1)", "start": [901, 1], "end": [904, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_cons", "code": "theorem subset_cons (h : a \u2209 s) : s \u2286 s.cons a h", "start": [907, 1], "end": [908, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_cons", "code": "theorem ssubset_cons (h : a \u2209 s) : s \u2282 s.cons a h", "start": [911, 1], "end": [912, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_subset", "code": "theorem cons_subset {h : a \u2209 s} : s.cons a h \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t", "start": [915, 1], "end": [916, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_subset_cons", "code": "@[simp]\ntheorem cons_subset_cons {hs ht} : s.cons a hs \u2286 t.cons a ht \u2194 s \u2286 t", "start": [919, 1], "end": [921, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_iff_exists_cons_subset", "code": "theorem ssubset_iff_exists_cons_subset : s \u2282 t \u2194 \u2203 (a : _) (h : a \u2209 s), s.cons a h \u2286 t", "start": [924, 1], "end": [927, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_left", "code": "theorem disjoint_left : Disjoint s t \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 a \u2209 t", "start": [939, 1], "end": [942, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_right", "code": "theorem disjoint_right : Disjoint s t \u2194 \u2200 \u2983a\u2984, a \u2208 t \u2192 a \u2209 s", "start": [945, 1], "end": [946, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_iff_ne", "code": "theorem disjoint_iff_ne : Disjoint s t \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b", "start": [949, 1], "end": [950, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_val", "code": "@[simp]\ntheorem disjoint_val : s.1.Disjoint t.1 \u2194 Disjoint s t", "start": [953, 1], "end": [955, 21], "kind": "commanddeclaration"}, {"full_name": "Disjoint.forall_ne_finset", "code": "theorem _root_.Disjoint.forall_ne_finset (h : Disjoint s t) (ha : a \u2208 s) (hb : b \u2208 t) : a \u2260 b", "start": [958, 1], "end": [959, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.not_disjoint_iff", "code": "theorem not_disjoint_iff : \u00acDisjoint s t \u2194 \u2203 a, a \u2208 s \u2227 a \u2208 t", "start": [962, 1], "end": [963, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_of_subset_left", "code": "theorem disjoint_of_subset_left (h : s \u2286 u) (d : Disjoint u t) : Disjoint s t", "start": [966, 1], "end": [967, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_of_subset_right", "code": "theorem disjoint_of_subset_right (h : t \u2286 u) (d : Disjoint s u) : Disjoint s t", "start": [970, 1], "end": [971, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_empty_left", "code": "@[simp]\ntheorem disjoint_empty_left (s : Finset \u03b1) : Disjoint \u2205 s", "start": [974, 1], "end": [976, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_empty_right", "code": "@[simp]\ntheorem disjoint_empty_right (s : Finset \u03b1) : Disjoint s \u2205", "start": [979, 1], "end": [981, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_singleton_left", "code": "@[simp]\ntheorem disjoint_singleton_left : Disjoint (singleton a) s \u2194 a \u2209 s", "start": [984, 1], "end": [986, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_singleton_right", "code": "@[simp]\ntheorem disjoint_singleton_right : Disjoint s (singleton a) \u2194 a \u2209 s", "start": [989, 1], "end": [991, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_singleton", "code": "theorem disjoint_singleton : Disjoint ({a} : Finset \u03b1) {b} \u2194 a \u2260 b", "start": [995, 1], "end": [996, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_self_iff_empty", "code": "theorem disjoint_self_iff_empty (s : Finset \u03b1) : Disjoint s s \u2194 s = \u2205", "start": [999, 1], "end": [1000, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_coe", "code": "@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (s : Set \u03b1) t \u2194 Disjoint s t", "start": [1003, 1], "end": [1005, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwiseDisjoint_coe", "code": "@[simp, norm_cast]\ntheorem pairwiseDisjoint_coe {\u03b9 : Type*} {s : Set \u03b9} {f : \u03b9 \u2192 Finset \u03b1} :\n    s.PairwiseDisjoint (fun i => f i : \u03b9 \u2192 Set \u03b1) \u2194 s.PairwiseDisjoint f", "start": [1008, 1], "end": [1011, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion", "code": "def disjUnion (s t : Finset \u03b1) (h : Disjoint s t) : Finset \u03b1 :=\n  \u27e8s.1 + t.1, Multiset.nodup_add.2 \u27e8s.2, t.2, disjoint_val.2 h\u27e9\u27e9", "start": [1019, 1], "end": [1023, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_disjUnion", "code": "@[simp]\ntheorem mem_disjUnion {\u03b1 s t h a} : a \u2208 @disjUnion \u03b1 s t h \u2194 a \u2208 s \u2228 a \u2208 t", "start": [1026, 1], "end": [1028, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion_comm", "code": "theorem disjUnion_comm (s t : Finset \u03b1) (h : Disjoint s t) :\n    disjUnion s t h = disjUnion t s h.symm", "start": [1031, 1], "end": [1033, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_disjUnion", "code": "@[simp]\ntheorem empty_disjUnion (t : Finset \u03b1) (h : Disjoint \u2205 t := disjoint_bot_left) :\n    disjUnion \u2205 t h = t", "start": [1036, 1], "end": [1039, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion_empty", "code": "@[simp]\ntheorem disjUnion_empty (s : Finset \u03b1) (h : Disjoint s \u2205 := disjoint_bot_right) :\n    disjUnion s \u2205 h = s", "start": [1042, 1], "end": [1045, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_disjUnion", "code": "theorem singleton_disjUnion (a : \u03b1) (t : Finset \u03b1) (h : Disjoint {a} t) :\n    disjUnion {a} t h = cons a t (disjoint_singleton_left.mp h)", "start": [1048, 1], "end": [1050, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion_singleton", "code": "theorem disjUnion_singleton (s : Finset \u03b1) (a : \u03b1) (h : Disjoint s {a}) :\n    disjUnion s {a} h = cons a s (disjoint_singleton_right.mp h)", "start": [1053, 1], "end": [1055, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_def", "code": "theorem insert_def (a : \u03b1) (s : Finset \u03b1) : insert a s = \u27e8_, s.2.ndinsert a\u27e9", "start": [1069, 1], "end": [1070, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_val", "code": "@[simp]\ntheorem insert_val (a : \u03b1) (s : Finset \u03b1) : (insert a s).1 = ndinsert a s.1", "start": [1073, 1], "end": [1075, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_val'", "code": "theorem insert_val' (a : \u03b1) (s : Finset \u03b1) : (insert a s).1 = dedup (a ::\u2098 s.1)", "start": [1078, 1], "end": [1079, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_val_of_not_mem", "code": "theorem insert_val_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : (insert a s).1 = a ::\u2098 s.1", "start": [1082, 1], "end": [1083, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_insert", "code": "@[simp]\ntheorem mem_insert : a \u2208 insert b s \u2194 a = b \u2228 a \u2208 s", "start": [1086, 1], "end": [1088, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_insert_self", "code": "theorem mem_insert_self (a : \u03b1) (s : Finset \u03b1) : a \u2208 insert a s", "start": [1091, 1], "end": [1092, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_insert_of_mem", "code": "theorem mem_insert_of_mem (h : a \u2208 s) : a \u2208 insert b s", "start": [1095, 1], "end": [1096, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_mem_insert_of_ne", "code": "theorem mem_of_mem_insert_of_ne (h : b \u2208 insert a s) : b \u2260 a \u2192 b \u2208 s", "start": [1099, 1], "end": [1100, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_not_mem_of_mem_insert", "code": "theorem eq_of_not_mem_of_mem_insert (ha : b \u2208 insert a s) (hb : b \u2209 s) : b = a", "start": [1103, 1], "end": [1104, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_eq_insert", "code": "@[simp]\ntheorem cons_eq_insert (a s h) : @cons \u03b1 a s h = insert a s", "start": [1107, 1], "end": [1109, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_insert", "code": "@[simp, norm_cast]\ntheorem coe_insert (a : \u03b1) (s : Finset \u03b1) : \u2191(insert a s) = (insert a s : Set \u03b1)", "start": [1112, 1], "end": [1114, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_insert_coe", "code": "theorem mem_insert_coe {s : Finset \u03b1} {x y : \u03b1} : x \u2208 insert y s \u2194 x \u2208 insert y (s : Set \u03b1)", "start": [1117, 1], "end": [1118, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_eq_of_mem", "code": "@[simp]\ntheorem insert_eq_of_mem (h : a \u2208 s) : insert a s = s", "start": [1124, 1], "end": [1126, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_eq_self", "code": "@[simp]\ntheorem insert_eq_self : insert a s = s \u2194 a \u2208 s", "start": [1129, 1], "end": [1131, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_ne_self", "code": "theorem insert_ne_self : insert a s \u2260 s \u2194 a \u2209 s", "start": [1134, 1], "end": [1135, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.pair_eq_singleton", "code": "theorem pair_eq_singleton (a : \u03b1) : ({a, a} : Finset \u03b1) = {a}", "start": [1139, 1], "end": [1140, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.Insert.comm", "code": "theorem Insert.comm (a b : \u03b1) (s : Finset \u03b1) : insert a (insert b s) = insert b (insert a s)", "start": [1143, 1], "end": [1144, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_pair", "code": "@[norm_cast]\ntheorem coe_pair {a b : \u03b1} : (({a, b} : Finset \u03b1) : Set \u03b1) = {a, b}", "start": [1148, 1], "end": [1151, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_eq_pair", "code": "@[simp, norm_cast]\ntheorem coe_eq_pair {s : Finset \u03b1} {a b : \u03b1} : (s : Set \u03b1) = {a, b} \u2194 s = {a, b}", "start": [1154, 1], "end": [1156, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.pair_comm", "code": "theorem pair_comm (a b : \u03b1) : ({a, b} : Finset \u03b1) = {b, a}", "start": [1159, 1], "end": [1160, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_idem", "code": "theorem insert_idem (a : \u03b1) (s : Finset \u03b1) : insert a (insert a s) = insert a s", "start": [1164, 1], "end": [1165, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_nonempty", "code": "@[simp]\ntheorem insert_nonempty (a : \u03b1) (s : Finset \u03b1) : (insert a s).Nonempty", "start": [1168, 1], "end": [1170, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_ne_empty", "code": "@[simp]\ntheorem insert_ne_empty (a : \u03b1) (s : Finset \u03b1) : insert a s \u2260 \u2205", "start": [1173, 1], "end": [1175, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.ne_insert_of_not_mem", "code": "theorem ne_insert_of_not_mem (s t : Finset \u03b1) {a : \u03b1} (h : a \u2209 s) : s \u2260 insert a t", "start": [1182, 1], "end": [1184, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_subset_iff", "code": "theorem insert_subset_iff : insert a s \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t", "start": [1187, 1], "end": [1188, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_subset", "code": "theorem insert_subset (ha : a \u2208 t) (hs : s \u2286 t) : insert a s \u2286 t", "start": [1191, 1], "end": [1192, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_insert", "code": "theorem subset_insert (a : \u03b1) (s : Finset \u03b1) : s \u2286 insert a s", "start": [1194, 1], "end": [1194, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_subset_insert", "code": "theorem insert_subset_insert (a : \u03b1) {s t : Finset \u03b1} (h : s \u2286 t) : insert a s \u2286 insert a t", "start": [1197, 1], "end": [1198, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_subset_insert_iff", "code": "@[simp] lemma insert_subset_insert_iff (ha : a \u2209 s) : insert a s \u2286 insert a t \u2194 s \u2286 t := by\n  simp_rw [\u2190coe_subset]; simp [-coe_subset, ha]", "start": [1201, 1], "end": [1202, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.insert_inj", "code": "theorem insert_inj (ha : a \u2209 s) : insert a s = insert b s \u2194 a = b", "start": [1204, 1], "end": [1205, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_inj_on", "code": "theorem insert_inj_on (s : Finset \u03b1) : Set.InjOn (fun a => insert a s) s\u1d9c", "start": [1208, 1], "end": [1209, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_iff", "code": "theorem ssubset_iff : s \u2282 t \u2194 \u2203 (a : \u03b1) (_ : a \u2209 s), insert a s \u2286 t", "start": [1212, 1], "end": [1213, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_insert", "code": "theorem ssubset_insert (h : a \u2209 s) : s \u2282 insert a s", "start": [1216, 1], "end": [1217, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_induction", "code": "@[elab_as_elim]\ntheorem cons_induction {\u03b1 : Type*} {p : Finset \u03b1 \u2192 Prop} (empty : p \u2205)\n    (cons : \u2200 \u2983a : \u03b1\u2984 {s : Finset \u03b1} (h : a \u2209 s), p s \u2192 p (cons a s h)) : \u2200 s, p s", "start": [1220, 1], "end": [1230, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.cons_induction_on", "code": "@[elab_as_elim]\ntheorem cons_induction_on {\u03b1 : Type*} {p : Finset \u03b1 \u2192 Prop} (s : Finset \u03b1) (h\u2081 : p \u2205)\n    (h\u2082 : \u2200 \u2983a : \u03b1\u2984 {s : Finset \u03b1} (h : a \u2209 s), p s \u2192 p (cons a s h)) : p s", "start": [1233, 1], "end": [1236, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.induction", "code": "@[elab_as_elim]\nprotected theorem induction {\u03b1 : Type*} {p : Finset \u03b1 \u2192 Prop} [DecidableEq \u03b1] (empty : p \u2205)\n    (insert : \u2200 \u2983a : \u03b1\u2984 {s : Finset \u03b1}, a \u2209 s \u2192 p s \u2192 p (insert a s)) : \u2200 s, p s", "start": [1239, 1], "end": [1242, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {\u03b1 : Type*} {p : Finset \u03b1 \u2192 Prop} [DecidableEq \u03b1] (s : Finset \u03b1)\n    (empty : p \u2205) (insert : \u2200 \u2983a : \u03b1\u2984 {s : Finset \u03b1}, a \u2209 s \u2192 p s \u2192 p (insert a s)) : p s", "start": [1245, 1], "end": [1253, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on'", "code": "@[elab_as_elim]\ntheorem induction_on' {\u03b1 : Type*} {p : Finset \u03b1 \u2192 Prop} [DecidableEq \u03b1] (S : Finset \u03b1) (h\u2081 : p \u2205)\n    (h\u2082 : \u2200 {a s}, a \u2208 S \u2192 s \u2286 S \u2192 a \u2209 s \u2192 p s \u2192 p (insert a s)) : p S", "start": [1256, 1], "end": [1268, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.cons_induction", "code": "@[elab_as_elim]\ntheorem Nonempty.cons_induction {\u03b1 : Type*} {p : \u2200 s : Finset \u03b1, s.Nonempty \u2192 Prop}\n    (h\u2080 : \u2200 a, p {a} (singleton_nonempty _))\n    (h\u2081 : \u2200 \u2983a\u2984 (s) (h : a \u2209 s) (hs), p s hs \u2192 p (Finset.cons a s h) (nonempty_cons h))\n    {s : Finset \u03b1} (hs : s.Nonempty) : p s hs", "start": [1271, 1], "end": [1283, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.subtypeInsertEquivOption", "code": "def subtypeInsertEquivOption {t : Finset \u03b1} {x : \u03b1} (h : x \u2209 t) :\n    { i // i \u2208 insert x t } \u2243 Option { i // i \u2208 t } := by\n  refine'\n    { toFun := fun y => if h : \u2191y = x then none else some \u27e8y, (mem_insert.mp y.2).resolve_left h\u27e9\n      invFun := fun y => (y.elim \u27e8x, mem_insert_self _ _\u27e9) fun z => \u27e8z, mem_insert_of_mem z.2\u27e9.. }\n  \u00b7 intro y\n    by_cases h : \u2191y = x\n    \u00b7 simp only [Subtype.ext_iff, h, Option.elim, dif_pos, Subtype.coe_mk]\n    \u00b7 simp only [h, Option.elim, dif_neg, not_false_iff, Subtype.coe_eta, Subtype.coe_mk]\n  \u00b7 rintro (_ | y)\n    \u00b7 simp only [Option.elim, dif_pos]\n    \u00b7 have : \u2191y \u2260 x := by\n        rintro \u27e8\u27e9\n        exact h y.2\n      simp only [this, Option.elim, Subtype.eta, dif_neg, not_false_iff, Subtype.coe_mk]", "start": [1286, 1], "end": [1301, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_insert_left", "code": "@[simp]\ntheorem disjoint_insert_left : Disjoint (insert a s) t \u2194 a \u2209 t \u2227 Disjoint s t", "start": [1304, 1], "end": [1306, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_insert_right", "code": "@[simp]\ntheorem disjoint_insert_right : Disjoint s (insert a t) \u2194 a \u2209 s \u2227 Disjoint s t", "start": [1309, 1], "end": [1311, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_eq_union", "code": "@[simp]\ntheorem sup_eq_union : (Sup.sup : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Finset \u03b1) = Union.union", "start": [1342, 1], "end": [1344, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_eq_inter", "code": "@[simp]\ntheorem inf_eq_inter : (Inf.inf : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Finset \u03b1) = Inter.inter", "start": [1347, 1], "end": [1349, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_iff_inter_eq_empty", "code": "theorem disjoint_iff_inter_eq_empty : Disjoint s t \u2194 s \u2229 t = \u2205", "start": [1352, 1], "end": [1353, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableDisjoint", "code": "instance decidableDisjoint (U V : Finset \u03b1) : Decidable (Disjoint U V) :=\n  decidable_of_iff _ disjoint_left.symm", "start": [1356, 1], "end": [1357, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.union_val_nd", "code": "theorem union_val_nd (s t : Finset \u03b1) : (s \u222a t).1 = ndunion s.1 t.1", "start": [1363, 1], "end": [1364, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.union_val", "code": "@[simp]\ntheorem union_val (s t : Finset \u03b1) : (s \u222a t).1 = s.1 \u222a t.1", "start": [1367, 1], "end": [1369, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_union", "code": "@[simp]\ntheorem mem_union : a \u2208 s \u222a t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [1372, 1], "end": [1374, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion_eq_union", "code": "@[simp]\ntheorem disjUnion_eq_union (s t h) : @disjUnion \u03b1 s t h = s \u222a t", "start": [1377, 1], "end": [1379, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_union_left", "code": "theorem mem_union_left (t : Finset \u03b1) (h : a \u2208 s) : a \u2208 s \u222a t", "start": [1382, 1], "end": [1383, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_union_right", "code": "theorem mem_union_right (s : Finset \u03b1) (h : a \u2208 t) : a \u2208 s \u222a t", "start": [1386, 1], "end": [1387, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_mem_union", "code": "theorem forall_mem_union {p : \u03b1 \u2192 Prop} : (\u2200 a \u2208 s \u222a t, p a) \u2194 (\u2200 a \u2208 s, p a) \u2227 \u2200 a \u2208 t, p a", "start": [1390, 1], "end": [1392, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_union", "code": "theorem not_mem_union : a \u2209 s \u222a t \u2194 a \u2209 s \u2227 a \u2209 t", "start": [1395, 1], "end": [1395, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_union", "code": "@[simp, norm_cast]\ntheorem coe_union (s\u2081 s\u2082 : Finset \u03b1) : \u2191(s\u2081 \u222a s\u2082) = (s\u2081 \u222a s\u2082 : Set \u03b1)", "start": [1398, 1], "end": [1400, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset", "code": "theorem union_subset (hs : s \u2286 u) : t \u2286 u \u2192 s \u222a t \u2286 u", "start": [1403, 1], "end": [1404, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_union_left", "code": "theorem subset_union_left (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u2286 s\u2081 \u222a s\u2082", "start": [1407, 1], "end": [1407, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_union_right", "code": "theorem subset_union_right (s\u2081 s\u2082 : Finset \u03b1) : s\u2082 \u2286 s\u2081 \u222a s\u2082", "start": [1410, 1], "end": [1410, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset_union", "code": "theorem union_subset_union (hsu : s \u2286 u) (htv : t \u2286 v) : s \u222a t \u2286 u \u222a v", "start": [1413, 1], "end": [1414, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset_union_left", "code": "theorem union_subset_union_left (h : s\u2081 \u2286 s\u2082) : s\u2081 \u222a t \u2286 s\u2082 \u222a t", "start": [1417, 1], "end": [1418, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset_union_right", "code": "theorem union_subset_union_right (h : t\u2081 \u2286 t\u2082) : s \u222a t\u2081 \u2286 s \u222a t\u2082", "start": [1421, 1], "end": [1422, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_comm", "code": "theorem union_comm (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u222a s\u2082 = s\u2082 \u222a s\u2081", "start": [1425, 1], "end": [1426, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.union_assoc", "code": "@[simp]\ntheorem union_assoc (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u222a s\u2082 \u222a s\u2083 = s\u2081 \u222a (s\u2082 \u222a s\u2083)", "start": [1432, 1], "end": [1434, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.union_idempotent", "code": "@[simp]\ntheorem union_idempotent (s : Finset \u03b1) : s \u222a s = s", "start": [1440, 1], "end": [1442, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset_left", "code": "theorem union_subset_left (h : s \u222a t \u2286 u) : s \u2286 u", "start": [1448, 1], "end": [1449, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_subset_right", "code": "theorem union_subset_right {s t u : Finset \u03b1} (h : s \u222a t \u2286 u) : t \u2286 u", "start": [1452, 1], "end": [1453, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.union_left_comm", "code": "theorem union_left_comm (s t u : Finset \u03b1) : s \u222a (t \u222a u) = t \u222a (s \u222a u)", "start": [1456, 1], "end": [1457, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.union_right_comm", "code": "theorem union_right_comm (s t u : Finset \u03b1) : s \u222a t \u222a u = s \u222a u \u222a t", "start": [1460, 1], "end": [1461, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.union_self", "code": "theorem union_self (s : Finset \u03b1) : s \u222a s = s", "start": [1464, 1], "end": [1465, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.union_empty", "code": "@[simp]\ntheorem union_empty (s : Finset \u03b1) : s \u222a \u2205 = s", "start": [1468, 1], "end": [1470, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_union", "code": "@[simp]\ntheorem empty_union (s : Finset \u03b1) : \u2205 \u222a s = s", "start": [1473, 1], "end": [1475, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.inl", "code": "theorem Nonempty.inl {s t : Finset \u03b1} (h : s.Nonempty) : (s \u222a t).Nonempty", "start": [1478, 1], "end": [1479, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.inr", "code": "theorem Nonempty.inr {s t : Finset \u03b1} (h : t.Nonempty) : (s \u222a t).Nonempty", "start": [1481, 1], "end": [1482, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_eq", "code": "theorem insert_eq (a : \u03b1) (s : Finset \u03b1) : insert a s = {a} \u222a s", "start": [1484, 1], "end": [1485, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_union", "code": "@[simp]\ntheorem insert_union (a : \u03b1) (s t : Finset \u03b1) : insert a s \u222a t = insert a (s \u222a t)", "start": [1488, 1], "end": [1490, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.union_insert", "code": "@[simp]\ntheorem union_insert (a : \u03b1) (s t : Finset \u03b1) : s \u222a insert a t = insert a (s \u222a t)", "start": [1493, 1], "end": [1495, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_union_distrib", "code": "theorem insert_union_distrib (a : \u03b1) (s t : Finset \u03b1) :\n    insert a (s \u222a t) = insert a s \u222a insert a t", "start": [1498, 1], "end": [1500, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.union_eq_left", "code": "@[simp] lemma union_eq_left : s \u222a t = s \u2194 t \u2286 s := sup_eq_left", "start": [1503, 1], "end": [1503, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.left_eq_union", "code": "@[simp] lemma left_eq_union : s = s \u222a t \u2194 t \u2286 s := by rw [eq_comm, union_eq_left]", "start": [1506, 1], "end": [1506, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.union_eq_right", "code": "@[simp] lemma union_eq_right : s \u222a t = t \u2194 s \u2286 t := sup_eq_right", "start": [1509, 1], "end": [1509, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.right_eq_union", "code": "@[simp] lemma right_eq_union : s = t \u222a s \u2194 t \u2286 s := by rw [eq_comm, union_eq_right]", "start": [1512, 1], "end": [1512, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.union_congr_left", "code": "theorem union_congr_left (ht : t \u2286 s \u222a u) (hu : u \u2286 s \u222a t) : s \u222a t = s \u222a u", "start": [1516, 1], "end": [1517, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.union_congr_right", "code": "theorem union_congr_right (hs : s \u2286 t \u222a u) (ht : t \u2286 s \u222a u) : s \u222a u = t \u222a u", "start": [1520, 1], "end": [1521, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.union_eq_union_iff_left", "code": "theorem union_eq_union_iff_left : s \u222a t = s \u222a u \u2194 t \u2286 s \u222a u \u2227 u \u2286 s \u222a t", "start": [1524, 1], "end": [1525, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.union_eq_union_iff_right", "code": "theorem union_eq_union_iff_right : s \u222a u = t \u222a u \u2194 s \u2286 t \u222a u \u2227 t \u2286 s \u222a u", "start": [1528, 1], "end": [1529, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_union_left", "code": "@[simp]\ntheorem disjoint_union_left : Disjoint (s \u222a t) u \u2194 Disjoint s u \u2227 Disjoint t u", "start": [1532, 1], "end": [1534, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_union_right", "code": "@[simp]\ntheorem disjoint_union_right : Disjoint s (t \u222a u) \u2194 Disjoint s t \u2227 Disjoint s u", "start": [1537, 1], "end": [1539, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_union", "code": "theorem induction_on_union (P : Finset \u03b1 \u2192 Finset \u03b1 \u2192 Prop) (symm : \u2200 {a b}, P a b \u2192 P b a)\n    (empty_right : \u2200 {a}, P a \u2205) (singletons : \u2200 {a b}, P {a} {b})\n    (union_of : \u2200 {a b c}, P a c \u2192 P b c \u2192 P (a \u222a b) c) : \u2200 a b, P a b", "start": [1542, 1], "end": [1557, 38], "kind": "commanddeclaration"}, {"full_name": "Directed.exists_mem_subset_of_finset_subset_biUnion", "code": "theorem _root_.Directed.exists_mem_subset_of_finset_subset_biUnion {\u03b1 \u03b9 : Type*} [hn : Nonempty \u03b9]\n    {f : \u03b9 \u2192 Set \u03b1} (h : Directed (\u00b7 \u2286 \u00b7) f) {s : Finset \u03b1} (hs : (s : Set \u03b1) \u2286 \u22c3 i, f i) :\n    \u2203 i, (s : Set \u03b1) \u2286 f i", "start": [1560, 1], "end": [1574, 43], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.exists_mem_subset_of_finset_subset_biUnion", "code": "theorem _root_.DirectedOn.exists_mem_subset_of_finset_subset_biUnion {\u03b1 \u03b9 : Type*} {f : \u03b9 \u2192 Set \u03b1}\n    {c : Set \u03b9} (hn : c.Nonempty) (hc : DirectedOn (fun i j => f i \u2286 f j) c) {s : Finset \u03b1}\n    (hs : (s : Set \u03b1) \u2286 \u22c3 i \u2208 c, f i) : \u2203 i \u2208 c, (s : Set \u03b1) \u2286 f i", "start": [1577, 1], "end": [1584, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_val_nd", "code": "theorem inter_val_nd (s\u2081 s\u2082 : Finset \u03b1) : (s\u2081 \u2229 s\u2082).1 = ndinter s\u2081.1 s\u2082.1", "start": [1591, 1], "end": [1592, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_val", "code": "@[simp]\ntheorem inter_val (s\u2081 s\u2082 : Finset \u03b1) : (s\u2081 \u2229 s\u2082).1 = s\u2081.1 \u2229 s\u2082.1", "start": [1595, 1], "end": [1597, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_inter", "code": "@[simp]\ntheorem mem_inter {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} : a \u2208 s\u2081 \u2229 s\u2082 \u2194 a \u2208 s\u2081 \u2227 a \u2208 s\u2082", "start": [1600, 1], "end": [1602, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_mem_inter_left", "code": "theorem mem_of_mem_inter_left {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} (h : a \u2208 s\u2081 \u2229 s\u2082) : a \u2208 s\u2081", "start": [1605, 1], "end": [1606, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_mem_inter_right", "code": "theorem mem_of_mem_inter_right {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} (h : a \u2208 s\u2081 \u2229 s\u2082) : a \u2208 s\u2082", "start": [1609, 1], "end": [1610, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_inter_of_mem", "code": "theorem mem_inter_of_mem {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} : a \u2208 s\u2081 \u2192 a \u2208 s\u2082 \u2192 a \u2208 s\u2081 \u2229 s\u2082", "start": [1613, 1], "end": [1614, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_left", "code": "theorem inter_subset_left (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u2229 s\u2082 \u2286 s\u2081", "start": [1617, 1], "end": [1617, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_right", "code": "theorem inter_subset_right (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u2229 s\u2082 \u2286 s\u2082", "start": [1620, 1], "end": [1620, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_inter", "code": "theorem subset_inter {s\u2081 s\u2082 u : Finset \u03b1} : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u2286 u \u2192 s\u2081 \u2286 s\u2082 \u2229 u", "start": [1623, 1], "end": [1624, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_inter", "code": "@[simp, norm_cast]\ntheorem coe_inter (s\u2081 s\u2082 : Finset \u03b1) : \u2191(s\u2081 \u2229 s\u2082) = (s\u2081 \u2229 s\u2082 : Set \u03b1)", "start": [1627, 1], "end": [1629, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.union_inter_cancel_left", "code": "@[simp]\ntheorem union_inter_cancel_left {s t : Finset \u03b1} : (s \u222a t) \u2229 s = s", "start": [1632, 1], "end": [1634, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.union_inter_cancel_right", "code": "@[simp]\ntheorem union_inter_cancel_right {s t : Finset \u03b1} : (s \u222a t) \u2229 t = t", "start": [1637, 1], "end": [1639, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_comm", "code": "theorem inter_comm (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u2229 s\u2082 = s\u2082 \u2229 s\u2081", "start": [1642, 1], "end": [1643, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_assoc", "code": "@[simp]\ntheorem inter_assoc (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u2229 s\u2082 \u2229 s\u2083 = s\u2081 \u2229 (s\u2082 \u2229 s\u2083)", "start": [1646, 1], "end": [1648, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_left_comm", "code": "theorem inter_left_comm (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u2229 (s\u2082 \u2229 s\u2083) = s\u2082 \u2229 (s\u2081 \u2229 s\u2083)", "start": [1651, 1], "end": [1652, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_right_comm", "code": "theorem inter_right_comm (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u2229 s\u2082 \u2229 s\u2083 = s\u2081 \u2229 s\u2083 \u2229 s\u2082", "start": [1655, 1], "end": [1656, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_self", "code": "@[simp]\ntheorem inter_self (s : Finset \u03b1) : s \u2229 s = s", "start": [1659, 1], "end": [1661, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_empty", "code": "@[simp]\ntheorem inter_empty (s : Finset \u03b1) : s \u2229 \u2205 = \u2205", "start": [1664, 1], "end": [1666, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_inter", "code": "@[simp]\ntheorem empty_inter (s : Finset \u03b1) : \u2205 \u2229 s = \u2205", "start": [1669, 1], "end": [1671, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_union_self", "code": "@[simp]\ntheorem inter_union_self (s t : Finset \u03b1) : s \u2229 (t \u222a s) = s", "start": [1674, 1], "end": [1676, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_inter_of_mem", "code": "@[simp]\ntheorem insert_inter_of_mem {s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} (h : a \u2208 s\u2082) :\n    insert a s\u2081 \u2229 s\u2082 = insert a (s\u2081 \u2229 s\u2082)", "start": [1679, 1], "end": [1684, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_insert_of_mem", "code": "@[simp]\ntheorem inter_insert_of_mem {s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} (h : a \u2208 s\u2081) :\n    s\u2081 \u2229 insert a s\u2082 = insert a (s\u2081 \u2229 s\u2082)", "start": [1687, 1], "end": [1689, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_inter_of_not_mem", "code": "@[simp]\ntheorem insert_inter_of_not_mem {s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} (h : a \u2209 s\u2082) :\n    insert a s\u2081 \u2229 s\u2082 = s\u2081 \u2229 s\u2082", "start": [1692, 1], "end": [1697, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_insert_of_not_mem", "code": "@[simp]\ntheorem inter_insert_of_not_mem {s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} (h : a \u2209 s\u2081) :\n    s\u2081 \u2229 insert a s\u2082 = s\u2081 \u2229 s\u2082", "start": [1700, 1], "end": [1702, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_inter_of_mem", "code": "@[simp]\ntheorem singleton_inter_of_mem {a : \u03b1} {s : Finset \u03b1} (H : a \u2208 s) : {a} \u2229 s = {a}", "start": [1705, 1], "end": [1707, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_inter_of_not_mem", "code": "@[simp]\ntheorem singleton_inter_of_not_mem {a : \u03b1} {s : Finset \u03b1} (H : a \u2209 s) : {a} \u2229 s = \u2205", "start": [1710, 1], "end": [1713, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_singleton_of_mem", "code": "@[simp]\ntheorem inter_singleton_of_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2208 s) : s \u2229 {a} = {a}", "start": [1716, 1], "end": [1718, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_singleton_of_not_mem", "code": "@[simp]\ntheorem inter_singleton_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : s \u2229 {a} = \u2205", "start": [1721, 1], "end": [1723, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_inter", "code": "@[mono]\ntheorem inter_subset_inter {x y s t : Finset \u03b1} (h : x \u2286 y) (h' : s \u2286 t) : x \u2229 s \u2286 y \u2229 t", "start": [1726, 1], "end": [1730, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_inter_left", "code": "theorem inter_subset_inter_left (h : t \u2286 u) : s \u2229 t \u2286 s \u2229 u", "start": [1733, 1], "end": [1734, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_inter_right", "code": "theorem inter_subset_inter_right (h : s \u2286 t) : s \u2229 u \u2286 t \u2229 u", "start": [1737, 1], "end": [1738, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_union", "code": "theorem inter_subset_union : s \u2229 t \u2286 s \u222a t", "start": [1741, 1], "end": [1742, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.union_left_idem", "code": "@[simp]\ntheorem union_left_idem (s t : Finset \u03b1) : s \u222a (s \u222a t) = s \u222a t", "start": [1751, 1], "end": [1753, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.union_right_idem", "code": "theorem union_right_idem (s t : Finset \u03b1) : s \u222a t \u222a t = s \u222a t", "start": [1757, 1], "end": [1758, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_left_idem", "code": "@[simp]\ntheorem inter_left_idem (s t : Finset \u03b1) : s \u2229 (s \u2229 t) = s \u2229 t", "start": [1761, 1], "end": [1763, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_right_idem", "code": "theorem inter_right_idem (s t : Finset \u03b1) : s \u2229 t \u2229 t = s \u2229 t", "start": [1767, 1], "end": [1768, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_distrib_left", "code": "theorem inter_distrib_left (s t u : Finset \u03b1) : s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u", "start": [1771, 1], "end": [1772, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_distrib_right", "code": "theorem inter_distrib_right (s t u : Finset \u03b1) : (s \u222a t) \u2229 u = s \u2229 u \u222a t \u2229 u", "start": [1775, 1], "end": [1776, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.union_distrib_left", "code": "theorem union_distrib_left (s t u : Finset \u03b1) : s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "start": [1779, 1], "end": [1780, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.union_distrib_right", "code": "theorem union_distrib_right (s t u : Finset \u03b1) : s \u2229 t \u222a u = (s \u222a u) \u2229 (t \u222a u)", "start": [1783, 1], "end": [1784, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.union_union_distrib_left", "code": "theorem union_union_distrib_left (s t u : Finset \u03b1) : s \u222a (t \u222a u) = s \u222a t \u222a (s \u222a u)", "start": [1787, 1], "end": [1788, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.union_union_distrib_right", "code": "theorem union_union_distrib_right (s t u : Finset \u03b1) : s \u222a t \u222a u = s \u222a u \u222a (t \u222a u)", "start": [1791, 1], "end": [1792, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_inter_distrib_left", "code": "theorem inter_inter_distrib_left (s t u : Finset \u03b1) : s \u2229 (t \u2229 u) = s \u2229 t \u2229 (s \u2229 u)", "start": [1795, 1], "end": [1796, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_inter_distrib_right", "code": "theorem inter_inter_distrib_right (s t u : Finset \u03b1) : s \u2229 t \u2229 u = s \u2229 u \u2229 (t \u2229 u)", "start": [1799, 1], "end": [1800, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.union_union_union_comm", "code": "theorem union_union_union_comm (s t u v : Finset \u03b1) : s \u222a t \u222a (u \u222a v) = s \u222a u \u222a (t \u222a v)", "start": [1803, 1], "end": [1804, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_inter_inter_comm", "code": "theorem inter_inter_inter_comm (s t u v : Finset \u03b1) : s \u2229 t \u2229 (u \u2229 v) = s \u2229 u \u2229 (t \u2229 v)", "start": [1807, 1], "end": [1808, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.union_eq_empty", "code": "lemma union_eq_empty : s \u222a t = \u2205 \u2194 s = \u2205 \u2227 t = \u2205 := sup_eq_bot_iff", "start": [1811, 1], "end": [1811, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.union_subset_iff", "code": "theorem union_subset_iff : s \u222a t \u2286 u \u2194 s \u2286 u \u2227 t \u2286 u", "start": [1814, 1], "end": [1815, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_inter_iff", "code": "theorem subset_inter_iff : s \u2286 t \u2229 u \u2194 s \u2286 t \u2227 s \u2286 u", "start": [1818, 1], "end": [1819, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_eq_left", "code": "@[simp] lemma inter_eq_left : s \u2229 t = s \u2194 s \u2286 t := inf_eq_left", "start": [1822, 1], "end": [1822, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inter_eq_right", "code": "@[simp] lemma inter_eq_right : t \u2229 s = s \u2194 s \u2286 t := inf_eq_right", "start": [1825, 1], "end": [1825, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inter_congr_left", "code": "theorem inter_congr_left (ht : s \u2229 u \u2286 t) (hu : s \u2229 t \u2286 u) : s \u2229 t = s \u2229 u", "start": [1828, 1], "end": [1829, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_congr_right", "code": "theorem inter_congr_right (hs : t \u2229 u \u2286 s) (ht : s \u2229 u \u2286 t) : s \u2229 u = t \u2229 u", "start": [1832, 1], "end": [1833, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_eq_inter_iff_left", "code": "theorem inter_eq_inter_iff_left : s \u2229 t = s \u2229 u \u2194 s \u2229 u \u2286 t \u2227 s \u2229 t \u2286 u", "start": [1836, 1], "end": [1837, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_eq_inter_iff_right", "code": "theorem inter_eq_inter_iff_right : s \u2229 u = t \u2229 u \u2194 t \u2229 u \u2286 s \u2227 s \u2229 u \u2286 t", "start": [1840, 1], "end": [1841, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.ite_subset_union", "code": "theorem ite_subset_union (s s' : Finset \u03b1) (P : Prop) [Decidable P] : ite P s s' \u2286 s \u222a s'", "start": [1844, 1], "end": [1845, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_subset_ite", "code": "theorem inter_subset_ite (s s' : Finset \u03b1) (P : Prop) [Decidable P] : s \u2229 s' \u2286 ite P s s'", "start": [1848, 1], "end": [1849, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.not_disjoint_iff_nonempty_inter", "code": "theorem not_disjoint_iff_nonempty_inter : \u00acDisjoint s t \u2194 (s \u2229 t).Nonempty", "start": [1852, 1], "end": [1853, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.not_disjoint", "code": "alias \u27e8_, Nonempty.not_disjoint\u27e9 := not_disjoint_iff_nonempty_inter", "start": [1856, 1], "end": [1856, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.disjoint_or_nonempty_inter", "code": "theorem disjoint_or_nonempty_inter (s t : Finset \u03b1) : Disjoint s t \u2228 (s \u2229 t).Nonempty", "start": [1859, 1], "end": [1861, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.isDirected_le", "code": "instance isDirected_le : IsDirected (Finset \u03b1) (\u00b7 \u2264 \u00b7) := by classical infer_instance", "start": [1866, 1], "end": [1866, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.isDirected_subset", "code": "instance isDirected_subset : IsDirected (Finset \u03b1) (\u00b7 \u2286 \u00b7) := isDirected_le", "start": [1867, 1], "end": [1867, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.erase", "code": "def erase (s : Finset \u03b1) (a : \u03b1) : Finset \u03b1 :=\n  \u27e8_, s.2.erase a\u27e9", "start": [1875, 1], "end": [1878, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_val", "code": "@[simp]\ntheorem erase_val (s : Finset \u03b1) (a : \u03b1) : (erase s a).1 = s.1.erase a", "start": [1881, 1], "end": [1883, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_erase", "code": "@[simp]\ntheorem mem_erase {a b : \u03b1} {s : Finset \u03b1} : a \u2208 erase s b \u2194 a \u2260 b \u2227 a \u2208 s", "start": [1886, 1], "end": [1888, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_erase", "code": "theorem not_mem_erase (a : \u03b1) (s : Finset \u03b1) : a \u2209 erase s a", "start": [1891, 1], "end": [1892, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_empty", "code": "@[nolint simpNF, simp]\ntheorem erase_empty (a : \u03b1) : erase \u2205 a = \u2205", "start": [1896, 1], "end": [1898, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_singleton", "code": "@[simp]\ntheorem erase_singleton (a : \u03b1) : ({a} : Finset \u03b1).erase a = \u2205", "start": [1901, 1], "end": [1904, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.ne_of_mem_erase", "code": "theorem ne_of_mem_erase : b \u2208 erase s a \u2192 b \u2260 a", "start": [1907, 1], "end": [1907, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_mem_erase", "code": "theorem mem_of_mem_erase : b \u2208 erase s a \u2192 b \u2208 s", "start": [1910, 1], "end": [1911, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_erase_of_ne_of_mem", "code": "theorem mem_erase_of_ne_of_mem : a \u2260 b \u2192 a \u2208 s \u2192 a \u2208 erase s b", "start": [1914, 1], "end": [1915, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_mem_of_not_mem_erase", "code": "theorem eq_of_mem_of_not_mem_erase (hs : b \u2208 s) (hsa : b \u2209 s.erase a) : b = a", "start": [1918, 1], "end": [1921, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_eq_of_not_mem", "code": "@[simp]\ntheorem erase_eq_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : erase s a = s", "start": [1924, 1], "end": [1926, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_eq_self", "code": "@[simp]\ntheorem erase_eq_self : s.erase a = s \u2194 a \u2209 s", "start": [1929, 1], "end": [1931, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_insert_eq_erase", "code": "@[simp]\ntheorem erase_insert_eq_erase (s : Finset \u03b1) (a : \u03b1) : (insert a s).erase a = s.erase a", "start": [1934, 1], "end": [1938, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_insert", "code": "theorem erase_insert {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : erase (insert a s) a = s", "start": [1941, 1], "end": [1942, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_insert_of_ne", "code": "theorem erase_insert_of_ne {a b : \u03b1} {s : Finset \u03b1} (h : a \u2260 b) :\n    erase (insert a s) b = insert a (erase s b)", "start": [1945, 1], "end": [1949, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_cons_of_ne", "code": "theorem erase_cons_of_ne {a b : \u03b1} {s : Finset \u03b1} (ha : a \u2209 s) (hb : a \u2260 b) :\n    erase (cons a s ha) b = cons a (erase s b) fun h => ha <| erase_subset _ _ h", "start": [1952, 1], "end": [1954, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_erase", "code": "theorem insert_erase {a : \u03b1} {s : Finset \u03b1} (h : a \u2208 s) : insert a (erase s a) = s", "start": [1957, 1], "end": [1962, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_eq_iff_eq_insert", "code": "lemma erase_eq_iff_eq_insert (hs : a \u2208 s) (ht : a \u2209 t) : erase s a = t \u2194 s = insert a t := by\n  have := insert_erase hs; aesop", "start": [1965, 1], "end": [1966, 33], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.insert_erase_invOn", "code": "lemma insert_erase_invOn :\n    Set.InvOn (insert a) (\u03bb s \u21a6 erase s a) {s : Finset \u03b1 | a \u2208 s} {s : Finset \u03b1 | a \u2209 s} :=\n  \u27e8\u03bb _s \u21a6 insert_erase, \u03bb _s \u21a6 erase_insert\u27e9", "start": [1968, 1], "end": [1970, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.erase_subset_erase", "code": "theorem erase_subset_erase (a : \u03b1) {s t : Finset \u03b1} (h : s \u2286 t) : erase s a \u2286 erase t a", "start": [1972, 1], "end": [1973, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_subset", "code": "theorem erase_subset (a : \u03b1) (s : Finset \u03b1) : erase s a \u2286 s", "start": [1976, 1], "end": [1977, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_erase", "code": "theorem subset_erase {a : \u03b1} {s t : Finset \u03b1} : s \u2286 t.erase a \u2194 s \u2286 t \u2227 a \u2209 s", "start": [1980, 1], "end": [1982, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_erase", "code": "@[simp, norm_cast]\ntheorem coe_erase (a : \u03b1) (s : Finset \u03b1) : \u2191(erase s a) = (s \\ {a} : Set \u03b1)", "start": [1985, 1], "end": [1987, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_ssubset", "code": "theorem erase_ssubset {a : \u03b1} {s : Finset \u03b1} (h : a \u2208 s) : s.erase a \u2282 s", "start": [1990, 1], "end": [1993, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_iff_exists_subset_erase", "code": "theorem ssubset_iff_exists_subset_erase {s t : Finset \u03b1} : s \u2282 t \u2194 \u2203 a \u2208 t, s \u2286 t.erase a", "start": [1996, 1], "end": [1999, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_ssubset_insert", "code": "theorem erase_ssubset_insert (s : Finset \u03b1) (a : \u03b1) : s.erase a \u2282 insert a s", "start": [2002, 1], "end": [2004, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_ne_self", "code": "theorem erase_ne_self : s.erase a \u2260 s \u2194 a \u2208 s", "start": [2007, 1], "end": [2008, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_cons", "code": "theorem erase_cons {s : Finset \u03b1} {a : \u03b1} (h : a \u2209 s) : (s.cons a h).erase a = s", "start": [2011, 1], "end": [2012, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_idem", "code": "theorem erase_idem {a : \u03b1} {s : Finset \u03b1} : erase (erase s a) a = erase s a", "start": [2015, 1], "end": [2015, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_right_comm", "code": "theorem erase_right_comm {a b : \u03b1} {s : Finset \u03b1} : erase (erase s a) b = erase (erase s b) a", "start": [2018, 1], "end": [2021, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_insert_iff", "code": "theorem subset_insert_iff {a : \u03b1} {s t : Finset \u03b1} : s \u2286 insert a t \u2194 erase s a \u2286 t", "start": [2024, 1], "end": [2026, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_insert_subset", "code": "theorem erase_insert_subset (a : \u03b1) (s : Finset \u03b1) : erase (insert a s) a \u2286 s", "start": [2029, 1], "end": [2030, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_erase_subset", "code": "theorem insert_erase_subset (a : \u03b1) (s : Finset \u03b1) : s \u2286 insert a (erase s a)", "start": [2033, 1], "end": [2034, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_insert_iff_of_not_mem", "code": "theorem subset_insert_iff_of_not_mem (h : a \u2209 s) : s \u2286 insert a t \u2194 s \u2286 t", "start": [2037, 1], "end": [2038, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_subset_iff_of_mem", "code": "theorem erase_subset_iff_of_mem (h : a \u2208 t) : s.erase a \u2286 t \u2194 s \u2286 t", "start": [2041, 1], "end": [2042, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_inj", "code": "theorem erase_inj {x y : \u03b1} (s : Finset \u03b1) (hx : x \u2208 s) : s.erase x = s.erase y \u2194 x = y", "start": [2045, 1], "end": [2048, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_injOn", "code": "theorem erase_injOn (s : Finset \u03b1) : Set.InjOn s.erase s", "start": [2051, 1], "end": [2051, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_injOn'", "code": "theorem erase_injOn' (a : \u03b1) : { s : Finset \u03b1 | a \u2208 s }.InjOn fun s => erase s a", "start": [2054, 1], "end": [2055, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_val", "code": "@[simp]\ntheorem sdiff_val (s\u2081 s\u2082 : Finset \u03b1) : (s\u2081 \\ s\u2082).val = s\u2081.val - s\u2082.val", "start": [2071, 1], "end": [2073, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sdiff", "code": "@[simp]\ntheorem mem_sdiff : a \u2208 s \\ t \u2194 a \u2208 s \u2227 a \u2209 t", "start": [2076, 1], "end": [2078, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_sdiff_self", "code": "@[simp]\ntheorem inter_sdiff_self (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \u2229 (s\u2082 \\ s\u2081) = \u2205", "start": [2081, 1], "end": [2084, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_sdiff_of_mem_right", "code": "theorem not_mem_sdiff_of_mem_right (h : a \u2208 t) : a \u2209 s \\ t", "start": [2095, 1], "end": [2096, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_sdiff_of_not_mem_left", "code": "theorem not_mem_sdiff_of_not_mem_left (h : a \u2209 s) : a \u2209 s \\ t", "start": [2099, 1], "end": [2099, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_of_subset", "code": "theorem union_sdiff_of_subset (h : s \u2286 t) : s \u222a t \\ s = t", "start": [2102, 1], "end": [2103, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_of_subset", "code": "theorem sdiff_union_of_subset {s\u2081 s\u2082 : Finset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2082 \\ s\u2081 \u222a s\u2081 = s\u2082", "start": [2106, 1], "end": [2107, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_sdiff", "code": "theorem inter_sdiff (s t u : Finset \u03b1) : s \u2229 (t \\ u) = (s \u2229 t) \\ u", "start": [2110, 1], "end": [2112, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_inter_self", "code": "@[simp]\ntheorem sdiff_inter_self (s\u2081 s\u2082 : Finset \u03b1) : s\u2082 \\ s\u2081 \u2229 s\u2081 = \u2205", "start": [2115, 1], "end": [2117, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_self", "code": "protected theorem sdiff_self (s\u2081 : Finset \u03b1) : s\u2081 \\ s\u2081 = \u2205", "start": [2121, 1], "end": [2122, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_inter_distrib_right", "code": "theorem sdiff_inter_distrib_right (s t u : Finset \u03b1) : s \\ (t \u2229 u) = s \\ t \u222a s \\ u", "start": [2125, 1], "end": [2126, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_inter_self_left", "code": "@[simp]\ntheorem sdiff_inter_self_left (s t : Finset \u03b1) : s \\ (s \u2229 t) = s \\ t", "start": [2129, 1], "end": [2131, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_inter_self_right", "code": "@[simp]\ntheorem sdiff_inter_self_right (s t : Finset \u03b1) : s \\ (t \u2229 s) = s \\ t", "start": [2134, 1], "end": [2136, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_empty", "code": "@[simp]\ntheorem sdiff_empty : s \\ \u2205 = s", "start": [2139, 1], "end": [2141, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_subset_sdiff", "code": "@[mono]\ntheorem sdiff_subset_sdiff (hst : s \u2286 t) (hvu : v \u2286 u) : s \\ u \u2286 t \\ v", "start": [2144, 1], "end": [2146, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sdiff", "code": "@[simp, norm_cast]\ntheorem coe_sdiff (s\u2081 s\u2082 : Finset \u03b1) : \u2191(s\u2081 \\ s\u2082) = (s\u2081 \\ s\u2082 : Set \u03b1)", "start": [2149, 1], "end": [2151, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_self_eq_union", "code": "@[simp]\ntheorem union_sdiff_self_eq_union : s \u222a t \\ s = s \u222a t", "start": [2154, 1], "end": [2156, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_self_eq_union", "code": "@[simp]\ntheorem sdiff_union_self_eq_union : s \\ t \u222a t = s \u222a t", "start": [2159, 1], "end": [2161, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_left", "code": "theorem union_sdiff_left (s t : Finset \u03b1) : (s \u222a t) \\ s = t \\ s", "start": [2164, 1], "end": [2165, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_right", "code": "theorem union_sdiff_right (s t : Finset \u03b1) : (s \u222a t) \\ t = s \\ t", "start": [2168, 1], "end": [2169, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_cancel_left", "code": "theorem union_sdiff_cancel_left (h : Disjoint s t) : (s \u222a t) \\ s = t", "start": [2172, 1], "end": [2173, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_cancel_right", "code": "theorem union_sdiff_cancel_right (h : Disjoint s t) : (s \u222a t) \\ t = s", "start": [2176, 1], "end": [2177, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_symm", "code": "theorem union_sdiff_symm : s \u222a t \\ s = t \u222a s \\ t", "start": [2180, 1], "end": [2180, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_inter", "code": "theorem sdiff_union_inter (s t : Finset \u03b1) : s \\ t \u222a s \u2229 t = s", "start": [2183, 1], "end": [2184, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_idem", "code": "theorem sdiff_idem (s t : Finset \u03b1) : (s \\ t) \\ t = s \\ t", "start": [2188, 1], "end": [2189, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_sdiff", "code": "theorem subset_sdiff : s \u2286 t \\ u \u2194 s \u2286 t \u2227 Disjoint s u", "start": [2192, 1], "end": [2193, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_empty_iff_subset", "code": "@[simp]\ntheorem sdiff_eq_empty_iff_subset : s \\ t = \u2205 \u2194 s \u2286 t", "start": [2196, 1], "end": [2198, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_nonempty", "code": "theorem sdiff_nonempty : (s \\ t).Nonempty \u2194 \u00acs \u2286 t", "start": [2201, 1], "end": [2202, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_sdiff", "code": "@[simp]\ntheorem empty_sdiff (s : Finset \u03b1) : \u2205 \\ s = \u2205", "start": [2205, 1], "end": [2207, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_sdiff_of_not_mem", "code": "theorem insert_sdiff_of_not_mem (s : Finset \u03b1) {t : Finset \u03b1} {x : \u03b1} (h : x \u2209 t) :\n    insert x s \\ t = insert x (s \\ t)", "start": [2210, 1], "end": [2213, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_sdiff_of_mem", "code": "theorem insert_sdiff_of_mem (s : Finset \u03b1) {x : \u03b1} (h : x \u2208 t) : insert x s \\ t = s \\ t", "start": [2216, 1], "end": [2218, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_sdiff_cancel", "code": "lemma insert_sdiff_cancel (ha : a \u2209 s) : insert a s \\ s = {a} := by\n  rw [insert_sdiff_of_not_mem _ ha, Finset.sdiff_self, insert_emptyc_eq]", "start": [2221, 1], "end": [2222, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.insert_sdiff_insert", "code": "@[simp]\ntheorem insert_sdiff_insert (s t : Finset \u03b1) (x : \u03b1) : insert x s \\ insert x t = s \\ insert x t", "start": [2224, 1], "end": [2226, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_insert_of_not_mem", "code": "theorem sdiff_insert_of_not_mem {x : \u03b1} (h : x \u2209 s) (t : Finset \u03b1) : s \\ insert x t = s \\ t", "start": [2229, 1], "end": [2232, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_subset", "code": "@[simp]\ntheorem sdiff_subset (s t : Finset \u03b1) : s \\ t \u2286 s", "start": [2235, 1], "end": [2237, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_ssubset", "code": "theorem sdiff_ssubset (h : t \u2286 s) (ht : t.Nonempty) : s \\ t \u2282 s", "start": [2240, 1], "end": [2241, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_distrib", "code": "theorem union_sdiff_distrib (s\u2081 s\u2082 t : Finset \u03b1) : (s\u2081 \u222a s\u2082) \\ t = s\u2081 \\ t \u222a s\u2082 \\ t", "start": [2244, 1], "end": [2245, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_distrib", "code": "theorem sdiff_union_distrib (s t\u2081 t\u2082 : Finset \u03b1) : s \\ (t\u2081 \u222a t\u2082) = s \\ t\u2081 \u2229 (s \\ t\u2082)", "start": [2248, 1], "end": [2249, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.union_sdiff_self", "code": "theorem union_sdiff_self (s t : Finset \u03b1) : (s \u222a t) \\ t = s \\ t", "start": [2252, 1], "end": [2253, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_singleton_eq_erase", "code": "theorem sdiff_singleton_eq_erase (a : \u03b1) (s : Finset \u03b1) : s \\ singleton a = erase s a", "start": [2258, 1], "end": [2260, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_eq", "code": "theorem erase_eq (s : Finset \u03b1) (a : \u03b1) : s.erase a = s \\ {a}", "start": [2264, 1], "end": [2265, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_erase_comm", "code": "theorem disjoint_erase_comm : Disjoint (s.erase a) t \u2194 Disjoint s (t.erase a)", "start": [2268, 1], "end": [2269, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_of_erase_left", "code": "theorem disjoint_of_erase_left (ha : a \u2209 t) (hst : Disjoint (s.erase a) t) : Disjoint s t", "start": [2272, 1], "end": [2274, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_of_erase_right", "code": "theorem disjoint_of_erase_right (ha : a \u2209 s) (hst : Disjoint s (t.erase a)) : Disjoint s t", "start": [2277, 1], "end": [2279, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_erase", "code": "theorem inter_erase (a : \u03b1) (s t : Finset \u03b1) : s \u2229 t.erase a = (s \u2229 t).erase a", "start": [2282, 1], "end": [2283, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_inter", "code": "@[simp]\ntheorem erase_inter (a : \u03b1) (s t : Finset \u03b1) : s.erase a \u2229 t = (s \u2229 t).erase a", "start": [2286, 1], "end": [2288, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_sdiff_comm", "code": "theorem erase_sdiff_comm (s t : Finset \u03b1) (a : \u03b1) : s.erase a \\ t = (s \\ t).erase a", "start": [2291, 1], "end": [2292, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_union_comm", "code": "theorem insert_union_comm (s t : Finset \u03b1) (a : \u03b1) : insert a s \u222a t = s \u222a insert a t", "start": [2295, 1], "end": [2296, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_inter_comm", "code": "theorem erase_inter_comm (s t : Finset \u03b1) (a : \u03b1) : s.erase a \u2229 t = s \u2229 t.erase a", "start": [2299, 1], "end": [2300, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_union_distrib", "code": "theorem erase_union_distrib (s t : Finset \u03b1) (a : \u03b1) : (s \u222a t).erase a = s.erase a \u222a t.erase a", "start": [2303, 1], "end": [2304, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_inter_distrib", "code": "theorem insert_inter_distrib (s t : Finset \u03b1) (a : \u03b1) :\n    insert a (s \u2229 t) = insert a s \u2229 insert a t", "start": [2307, 1], "end": [2308, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_sdiff_distrib", "code": "theorem erase_sdiff_distrib (s t : Finset \u03b1) (a : \u03b1) : (s \\ t).erase a = s.erase a \\ t.erase a", "start": [2311, 1], "end": [2312, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_union_of_mem", "code": "theorem erase_union_of_mem (ha : a \u2208 t) (s : Finset \u03b1) : s.erase a \u222a t = s \u222a t", "start": [2315, 1], "end": [2316, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.union_erase_of_mem", "code": "theorem union_erase_of_mem (ha : a \u2208 s) (t : Finset \u03b1) : s \u222a t.erase a = s \u222a t", "start": [2319, 1], "end": [2320, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_singleton_eq_self", "code": "@[simp]\ntheorem sdiff_singleton_eq_self (ha : a \u2209 s) : s \\ {a} = s", "start": [2323, 1], "end": [2325, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.Nontrivial.sdiff_singleton_nonempty", "code": "theorem Nontrivial.sdiff_singleton_nonempty {c : \u03b1} {s : Finset \u03b1} (hS : s.Nontrivial) :\n    (s \\ {c}).Nonempty", "start": [2328, 1], "end": [2332, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_sdiff_left'", "code": "theorem sdiff_sdiff_left' (s t u : Finset \u03b1) : (s \\ t) \\ u = s \\ t \u2229 (s \\ u)", "start": [2334, 1], "end": [2335, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_sdiff_cancel", "code": "theorem sdiff_union_sdiff_cancel (hts : t \u2286 s) (hut : u \u2286 t) : s \\ t \u222a t \\ u = s \\ u", "start": [2338, 1], "end": [2339, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_union_erase_cancel", "code": "theorem sdiff_union_erase_cancel (hts : t \u2286 s) (ha : a \u2208 t) : s \\ t \u222a t.erase a = s.erase a", "start": [2342, 1], "end": [2343, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_sdiff_eq_sdiff_union", "code": "theorem sdiff_sdiff_eq_sdiff_union (h : u \u2286 s) : s \\ (t \\ u) = s \\ t \u222a u", "start": [2346, 1], "end": [2347, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_insert", "code": "theorem sdiff_insert (s t : Finset \u03b1) (x : \u03b1) : s \\ insert x t = (s \\ t).erase x", "start": [2350, 1], "end": [2352, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_insert_insert_of_mem_of_not_mem", "code": "theorem sdiff_insert_insert_of_mem_of_not_mem {s t : Finset \u03b1} {x : \u03b1} (hxs : x \u2208 s) (hxt : x \u2209 t) :\n    insert x (s \\ insert x t) = s \\ t", "start": [2355, 1], "end": [2357, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_erase", "code": "theorem sdiff_erase (h : a \u2208 s) : s \\ t.erase a = insert a (s \\ t)", "start": [2360, 1], "end": [2362, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_erase_self", "code": "theorem sdiff_erase_self (ha : a \u2208 s) : s \\ s.erase a = {a}", "start": [2365, 1], "end": [2366, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_sdiff_self_left", "code": "theorem sdiff_sdiff_self_left (s t : Finset \u03b1) : s \\ (s \\ t) = s \u2229 t", "start": [2369, 1], "end": [2370, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_sdiff_eq_self", "code": "theorem sdiff_sdiff_eq_self (h : t \u2286 s) : s \\ (s \\ t) = t", "start": [2373, 1], "end": [2374, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_sdiff_iff_inter_eq_inter", "code": "theorem sdiff_eq_sdiff_iff_inter_eq_inter {s t\u2081 t\u2082 : Finset \u03b1} :\n    s \\ t\u2081 = s \\ t\u2082 \u2194 s \u2229 t\u2081 = s \u2229 t\u2082", "start": [2377, 1], "end": [2379, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.union_eq_sdiff_union_sdiff_union_inter", "code": "theorem union_eq_sdiff_union_sdiff_union_inter (s t : Finset \u03b1) : s \u222a t = s \\ t \u222a t \\ s \u222a s \u2229 t", "start": [2382, 1], "end": [2383, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_eq_empty_iff", "code": "theorem erase_eq_empty_iff (s : Finset \u03b1) (a : \u03b1) : s.erase a = \u2205 \u2194 s = \u2205 \u2228 s = {a}", "start": [2386, 1], "end": [2387, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_disjoint", "code": "theorem sdiff_disjoint : Disjoint (t \\ s) s", "start": [2391, 1], "end": [2392, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_sdiff", "code": "theorem disjoint_sdiff : Disjoint s (t \\ s)", "start": [2395, 1], "end": [2396, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_sdiff_inter", "code": "theorem disjoint_sdiff_inter (s t : Finset \u03b1) : Disjoint (s \\ t) (s \u2229 t)", "start": [2399, 1], "end": [2400, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_self_iff_disjoint", "code": "theorem sdiff_eq_self_iff_disjoint : s \\ t = s \u2194 Disjoint s t", "start": [2403, 1], "end": [2404, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_self_of_disjoint", "code": "theorem sdiff_eq_self_of_disjoint (h : Disjoint s t) : s \\ t = s", "start": [2407, 1], "end": [2408, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_symmDiff", "code": "theorem mem_symmDiff : a \u2208 s \u2206 t \u2194 a \u2208 s \u2227 a \u2209 t \u2228 a \u2208 t \u2227 a \u2209 s", "start": [2420, 1], "end": [2421, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_symmDiff", "code": "@[simp, norm_cast]\ntheorem coe_symmDiff : (\u2191(s \u2206 t) : Set \u03b1) = (s : Set \u03b1) \u2206 t", "start": [2424, 1], "end": [2426, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.symmDiff_eq_empty", "code": "@[simp] lemma symmDiff_eq_empty : s \u2206 t = \u2205 \u2194 s = t := symmDiff_eq_bot", "start": [2429, 1], "end": [2429, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.symmDiff_nonempty", "code": "@[simp] lemma symmDiff_nonempty : (s \u2206 t).Nonempty \u2194 s \u2260 t :=\n  nonempty_iff_ne_empty.trans symmDiff_eq_empty.not", "start": [2430, 1], "end": [2431, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.attach", "code": "def attach (s : Finset \u03b1) : Finset { x // x \u2208 s } :=\n  \u27e8Multiset.attach s.1, nodup_attach.2 s.2\u27e9", "start": [2438, 1], "end": [2441, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.sizeOf_lt_sizeOf_of_mem", "code": "theorem sizeOf_lt_sizeOf_of_mem [SizeOf \u03b1] {x : \u03b1} {s : Finset \u03b1} (hx : x \u2208 s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s", "start": [2444, 1], "end": [2450, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_val", "code": "@[simp]\ntheorem attach_val (s : Finset \u03b1) : s.attach.1 = s.1.attach", "start": [2453, 1], "end": [2455, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_attach", "code": "@[simp]\ntheorem mem_attach (s : Finset \u03b1) : \u2200 x, x \u2208 s.attach", "start": [2458, 1], "end": [2460, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_empty", "code": "@[simp]\ntheorem attach_empty : attach (\u2205 : Finset \u03b1) = \u2205", "start": [2463, 1], "end": [2465, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_nonempty_iff", "code": "@[simp]\ntheorem attach_nonempty_iff {s : Finset \u03b1} : s.attach.Nonempty \u2194 s.Nonempty", "start": [2468, 1], "end": [2470, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_eq_empty_iff", "code": "@[simp]\ntheorem attach_eq_empty_iff {s : Finset \u03b1} : s.attach = \u2205 \u2194 s = \u2205", "start": [2473, 1], "end": [2475, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise", "code": "def piecewise {\u03b1 : Type*} {\u03b4 : \u03b1 \u2192 Sort*} (s : Finset \u03b1) (f g : \u2200 i, \u03b4 i)\n    [\u2200 j, Decidable (j \u2208 s)] : \u2200 i, \u03b4 i := fun i => if i \u2208 s then f i else g i", "start": [2483, 1], "end": [2486, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_insert_self", "code": "theorem piecewise_insert_self [DecidableEq \u03b1] {j : \u03b1} [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g j = f j", "start": [2492, 1], "end": [2493, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_empty", "code": "@[simp]\ntheorem piecewise_empty [\u2200 i : \u03b1, Decidable (i \u2208 (\u2205 : Finset \u03b1))] : piecewise \u2205 f g = g", "start": [2496, 1], "end": [2499, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_coe", "code": "@[norm_cast move]\ntheorem piecewise_coe [\u2200 j, Decidable (j \u2208 (s : Set \u03b1))] :\n    (s : Set \u03b1).piecewise f g = s.piecewise f g", "start": [2505, 1], "end": [2509, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_eq_of_mem", "code": "@[simp]\ntheorem piecewise_eq_of_mem {i : \u03b1} (hi : i \u2208 s) : s.piecewise f g i = f i", "start": [2512, 1], "end": [2514, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_eq_of_not_mem", "code": "@[simp]\ntheorem piecewise_eq_of_not_mem {i : \u03b1} (hi : i \u2209 s) : s.piecewise f g i = g i", "start": [2517, 1], "end": [2519, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_congr", "code": "theorem piecewise_congr {f f' g g' : \u2200 i, \u03b4 i} (hf : \u2200 i \u2208 s, f i = f' i)\n    (hg : \u2200 (i) (_ : i \u2209 s), g i = g' i) : s.piecewise f g = s.piecewise f' g'", "start": [2522, 1], "end": [2524, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_insert_of_ne", "code": "@[simp]\ntheorem piecewise_insert_of_ne [DecidableEq \u03b1] {i j : \u03b1} [\u2200 i, Decidable (i \u2208 insert j s)]\n    (h : i \u2260 j) : (insert j s).piecewise f g i = s.piecewise f g i", "start": [2527, 1], "end": [2529, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_insert", "code": "theorem piecewise_insert [DecidableEq \u03b1] (j : \u03b1) [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g = update (s.piecewise f g) j (f j)", "start": [2532, 1], "end": [2537, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_cases", "code": "theorem piecewise_cases {i} (p : \u03b4 i \u2192 Prop) (hf : p (f i)) (hg : p (g i)) :\n    p (s.piecewise f g i)", "start": [2540, 1], "end": [2542, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_mem_set_pi", "code": "theorem piecewise_mem_set_pi {\u03b4 : \u03b1 \u2192 Type*} {t : Set \u03b1} {t' : \u2200 i, Set (\u03b4 i)} {f g}\n    (hf : f \u2208 Set.pi t t') (hg : g \u2208 Set.pi t t') : s.piecewise f g \u2208 Set.pi t t'", "start": [2545, 1], "end": [2549, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_singleton", "code": "theorem piecewise_singleton [DecidableEq \u03b1] (i : \u03b1) : piecewise {i} f g = update g i (f i)", "start": [2552, 1], "end": [2553, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_piecewise_of_subset_left", "code": "theorem piecewise_piecewise_of_subset_left {s t : Finset \u03b1} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : s \u2286 t) (f\u2081 f\u2082 g : \u2200 a, \u03b4 a) :\n    s.piecewise (t.piecewise f\u2081 f\u2082) g = s.piecewise f\u2081 g", "start": [2556, 1], "end": [2559, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_idem_left", "code": "@[simp]\ntheorem piecewise_idem_left (f\u2081 f\u2082 g : \u2200 a, \u03b4 a) :\n    s.piecewise (s.piecewise f\u2081 f\u2082) g = s.piecewise f\u2081 g", "start": [2562, 1], "end": [2565, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_piecewise_of_subset_right", "code": "theorem piecewise_piecewise_of_subset_right {s t : Finset \u03b1} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : t \u2286 s) (f g\u2081 g\u2082 : \u2200 a, \u03b4 a) :\n    s.piecewise f (t.piecewise g\u2081 g\u2082) = s.piecewise f g\u2082", "start": [2568, 1], "end": [2571, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_idem_right", "code": "@[simp]\ntheorem piecewise_idem_right (f g\u2081 g\u2082 : \u2200 a, \u03b4 a) :\n    s.piecewise f (s.piecewise g\u2081 g\u2082) = s.piecewise f g\u2082", "start": [2574, 1], "end": [2577, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.update_eq_piecewise", "code": "theorem update_eq_piecewise {\u03b2 : Type*} [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (i : \u03b1) (v : \u03b2) :\n    update f i v = piecewise (singleton i) (fun _ => v) f", "start": [2580, 1], "end": [2582, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.update_piecewise", "code": "theorem update_piecewise [DecidableEq \u03b1] (i : \u03b1) (v : \u03b4 i) :\n    update (s.piecewise f g) i v = s.piecewise (update f i v) (update g i v)", "start": [2585, 1], "end": [2588, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.update_piecewise_of_mem", "code": "theorem update_piecewise_of_mem [DecidableEq \u03b1] {i : \u03b1} (hi : i \u2208 s) (v : \u03b4 i) :\n    update (s.piecewise f g) i v = s.piecewise (update f i v) g", "start": [2591, 1], "end": [2595, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.update_piecewise_of_not_mem", "code": "theorem update_piecewise_of_not_mem [DecidableEq \u03b1] {i : \u03b1} (hi : i \u2209 s) (v : \u03b4 i) :\n    update (s.piecewise f g) i v = s.piecewise f (update g i v)", "start": [2598, 1], "end": [2602, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_le_of_le_of_le", "code": "theorem piecewise_le_of_le_of_le {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g h : \u2200 i, \u03b4 i}\n    (Hf : f \u2264 h) (Hg : g \u2264 h) : s.piecewise f g \u2264 h", "start": [2605, 1], "end": [2607, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.le_piecewise_of_le_of_le", "code": "theorem le_piecewise_of_le_of_le {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g h : \u2200 i, \u03b4 i}\n    (Hf : h \u2264 f) (Hg : h \u2264 g) : h \u2264 s.piecewise f g", "start": [2610, 1], "end": [2612, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_le_piecewise'", "code": "theorem piecewise_le_piecewise' {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g f' g' : \u2200 i, \u03b4 i}\n    (Hf : \u2200 x \u2208 s, f x \u2264 f' x) (Hg : \u2200 (x) (_ : x \u2209 s), g x \u2264 g' x) :\n    s.piecewise f g \u2264 s.piecewise f' g'", "start": [2615, 1], "end": [2617, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_le_piecewise", "code": "theorem piecewise_le_piecewise {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g f' g' : \u2200 i, \u03b4 i}\n    (Hf : f \u2264 f') (Hg : g \u2264 g') : s.piecewise f g \u2264 s.piecewise f' g'", "start": [2620, 1], "end": [2622, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_mem_Icc_of_mem_of_mem", "code": "theorem piecewise_mem_Icc_of_mem_of_mem {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)]\n    {f f\u2081 g g\u2081 : \u2200 i, \u03b4 i} (hf : f \u2208 Set.Icc f\u2081 g\u2081) (hg : g \u2208 Set.Icc f\u2081 g\u2081) :\n    s.piecewise f g \u2208 Set.Icc f\u2081 g\u2081", "start": [2625, 1], "end": [2628, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_mem_Icc", "code": "theorem piecewise_mem_Icc {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g : \u2200 i, \u03b4 i} (h : f \u2264 g) :\n    s.piecewise f g \u2208 Set.Icc f g", "start": [2631, 1], "end": [2633, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_mem_Icc'", "code": "theorem piecewise_mem_Icc' {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {f g : \u2200 i, \u03b4 i} (h : g \u2264 f) :\n    s.piecewise f g \u2208 Set.Icc g f", "start": [2636, 1], "end": [2638, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableDforallFinset", "code": "instance decidableDforallFinset {p : \u2200 a \u2208 s, Prop} [_hp : \u2200 (a) (h : a \u2208 s), Decidable (p a h)] :\n    Decidable (\u2200 (a) (h : a \u2208 s), p a h) :=\n  Multiset.decidableDforallMultiset", "start": [2647, 1], "end": [2649, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.instDecidableRelSubset", "code": "instance instDecidableRelSubset [DecidableEq \u03b1] : @DecidableRel (Finset \u03b1) (\u00b7 \u2286 \u00b7) :=\n  \u03bb _ _ \u21a6 decidableDforallFinset", "start": [2654, 1], "end": [2655, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.instDecidableRelSSubset", "code": "instance instDecidableRelSSubset [DecidableEq \u03b1] : @DecidableRel (Finset \u03b1) (\u00b7 \u2282 \u00b7) :=\n  \u03bb _ _ \u21a6 instDecidableAnd", "start": [2657, 1], "end": [2658, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.instDecidableLE", "code": "instance instDecidableLE [DecidableEq \u03b1] : @DecidableRel (Finset \u03b1) (\u00b7 \u2264 \u00b7) :=\n  instDecidableRelSubset", "start": [2660, 1], "end": [2661, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.instDecidableLT", "code": "instance instDecidableLT [DecidableEq \u03b1] : @DecidableRel (Finset \u03b1) (\u00b7 < \u00b7) :=\n  instDecidableRelSSubset", "start": [2663, 1], "end": [2664, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableDExistsFinset", "code": "instance decidableDExistsFinset {p : \u2200 a \u2208 s, Prop} [_hp : \u2200 (a) (h : a \u2208 s), Decidable (p a h)] :\n    Decidable (\u2203 (a : _) (h : a \u2208 s), p a h) :=\n  Multiset.decidableDexistsMultiset", "start": [2666, 1], "end": [2668, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableExistsAndFinset", "code": "instance decidableExistsAndFinset {p : \u03b1 \u2192 Prop} [_hp : \u2200 (a), Decidable (p a)] :\n    Decidable (\u2203 a \u2208 s, p a) :=\n  decidable_of_iff (\u2203 (a : _) (_ : a \u2208 s), p a) (by simp)", "start": [2671, 1], "end": [2673, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableEqPiFinset", "code": "instance decidableEqPiFinset {\u03b2 : \u03b1 \u2192 Type*} [_h : \u2200 a, DecidableEq (\u03b2 a)] :\n    DecidableEq (\u2200 a \u2208 s, \u03b2 a) :=\n  Multiset.decidableEqPiMultiset", "start": [2675, 1], "end": [2678, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.filter", "code": "def filter (s : Finset \u03b1) : Finset \u03b1 :=\n  \u27e8_, s.2.filter p\u27e9", "start": [2690, 1], "end": [2692, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_val", "code": "@[simp]\ntheorem filter_val (s : Finset \u03b1) : (filter p s).1 = s.1.filter p", "start": [2695, 1], "end": [2697, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_subset", "code": "@[simp]\ntheorem filter_subset (s : Finset \u03b1) : s.filter p \u2286 s", "start": [2700, 1], "end": [2702, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_filter", "code": "@[simp]\ntheorem mem_filter {s : Finset \u03b1} {a : \u03b1} : a \u2208 s.filter p \u2194 a \u2208 s \u2227 p a", "start": [2707, 1], "end": [2709, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_mem_filter", "code": "theorem mem_of_mem_filter {s : Finset \u03b1} (x : \u03b1) (h : x \u2208 s.filter p) : x \u2208 s", "start": [2712, 1], "end": [2713, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_ssubset", "code": "theorem filter_ssubset {s : Finset \u03b1} : s.filter p \u2282 s \u2194 \u2203 x \u2208 s, \u00acp x", "start": [2716, 1], "end": [2720, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_filter", "code": "theorem filter_filter (s : Finset \u03b1) : (s.filter p).filter q = s.filter fun a => p a \u2227 q a", "start": [2725, 1], "end": [2727, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_comm", "code": "theorem filter_comm (s : Finset \u03b1) : (s.filter p).filter q = (s.filter q).filter p", "start": [2730, 1], "end": [2731, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_congr_decidable", "code": "@[simp]\ntheorem filter_congr_decidable (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) (h : DecidablePred p)\n    [DecidablePred p] : @filter \u03b1 p h s = s.filter p", "start": [2735, 1], "end": [2737, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_True", "code": "theorem filter_True {h} (s : Finset \u03b1) : @filter _ (fun _ => True) h s = s", "start": [2740, 1], "end": [2740, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_False", "code": "theorem filter_False {h} (s : Finset \u03b1) : @filter _ (fun _ => False) h s = \u2205", "start": [2743, 1], "end": [2743, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_eq_self", "code": "theorem filter_eq_self : s.filter p = s \u2194 \u2200 x \u2208 s, p x", "start": [2748, 1], "end": [2748, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_eq_empty_iff", "code": "theorem filter_eq_empty_iff : s.filter p = \u2205 \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u00acp x", "start": [2751, 1], "end": [2751, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_nonempty_iff", "code": "theorem filter_nonempty_iff : (s.filter p).Nonempty \u2194 \u2203 a \u2208 s, p a", "start": [2754, 1], "end": [2756, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_true_of_mem", "code": "@[simp]\ntheorem filter_true_of_mem (h : \u2200 x \u2208 s, p x) : s.filter p = s", "start": [2759, 1], "end": [2761, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_false_of_mem", "code": "@[simp]\ntheorem filter_false_of_mem (h : \u2200 x \u2208 s, \u00acp x) : s.filter p = \u2205", "start": [2764, 1], "end": [2766, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_const", "code": "@[simp]\ntheorem filter_const (p : Prop) [Decidable p] (s : Finset \u03b1) :\n    (s.filter fun _a => p) = if p then s else \u2205", "start": [2769, 1], "end": [2771, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_congr", "code": "theorem filter_congr {s : Finset \u03b1} (H : \u2200 x \u2208 s, p x \u2194 q x) : filter p s = filter q s", "start": [2774, 1], "end": [2775, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_empty", "code": "theorem filter_empty : filter p \u2205 = \u2205", "start": [2780, 1], "end": [2781, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_subset_filter", "code": "theorem filter_subset_filter {s t : Finset \u03b1} (h : s \u2286 t) : s.filter p \u2286 t.filter p", "start": [2784, 1], "end": [2785, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.monotone_filter_left", "code": "theorem monotone_filter_left : Monotone (filter p)", "start": [2788, 1], "end": [2788, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.monotone_filter_right", "code": "theorem monotone_filter_right (s : Finset \u03b1) \u2983p q : \u03b1 \u2192 Prop\u2984 [DecidablePred p] [DecidablePred q]\n    (h : p \u2264 q) : s.filter p \u2264 s.filter q", "start": [2791, 1], "end": [2793, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_filter", "code": "@[simp, norm_cast]\ntheorem coe_filter (s : Finset \u03b1) : \u2191(s.filter p) = ({ x \u2208 \u2191s | p x } : Set \u03b1)", "start": [2796, 1], "end": [2798, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_coe_filter_of_subset_forall", "code": "theorem subset_coe_filter_of_subset_forall (s : Finset \u03b1) {t : Set \u03b1} (h\u2081 : t \u2286 s)\n    (h\u2082 : \u2200 x \u2208 t, p x) : t \u2286 s.filter p", "start": [2801, 1], "end": [2802, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_singleton", "code": "theorem filter_singleton (a : \u03b1) : filter p (singleton a) = if p a then singleton a else \u2205", "start": [2805, 1], "end": [2809, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_cons_of_pos", "code": "theorem filter_cons_of_pos (a : \u03b1) (s : Finset \u03b1) (ha : a \u2209 s) (hp : p a) :\n    filter p (cons a s ha) = cons a (filter p s) (mem_filter.not.mpr <| mt And.left ha)", "start": [2812, 1], "end": [2814, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_cons_of_neg", "code": "theorem filter_cons_of_neg (a : \u03b1) (s : Finset \u03b1) (ha : a \u2209 s) (hp : \u00acp a) :\n    filter p (cons a s ha) = filter p s", "start": [2817, 1], "end": [2819, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_filter", "code": "theorem disjoint_filter {s : Finset \u03b1} {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q] :\n    Disjoint (s.filter p) (s.filter q) \u2194 \u2200 x \u2208 s, p x \u2192 \u00acq x", "start": [2822, 1], "end": [2824, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_filter_filter", "code": "theorem disjoint_filter_filter {s t : Finset \u03b1}\n    {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q] :\n    Disjoint s t \u2192 Disjoint (s.filter p) (t.filter q)", "start": [2827, 1], "end": [2830, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_filter_filter'", "code": "theorem disjoint_filter_filter' (s t : Finset \u03b1)\n    {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : Disjoint p q) :\n    Disjoint (s.filter p) (t.filter q)", "start": [2833, 1], "end": [2839, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_filter_filter_neg", "code": "theorem disjoint_filter_filter_neg (s t : Finset \u03b1) (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] [\u2200 x, Decidable (\u00acp x)] :\n    Disjoint (s.filter p) (t.filter fun a => \u00acp a)", "start": [2842, 1], "end": [2845, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_disj_union", "code": "theorem filter_disj_union (s : Finset \u03b1) (t : Finset \u03b1) (h : Disjoint s t) :\n    filter p (disjUnion s t h) = (filter p s).disjUnion (filter p t) (disjoint_filter_filter h)", "start": [2848, 1], "end": [2850, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_cons", "code": "theorem filter_cons {a : \u03b1} (s : Finset \u03b1) (ha : a \u2209 s) :\n    filter p (cons a s ha) =\n      (if p a then {a} else \u2205 : Finset \u03b1).disjUnion (filter p s)\n        (by\n          split_ifs\n          \u00b7 rw [disjoint_singleton_left]\n            exact mem_filter.not.mpr <| mt And.left ha\n          \u00b7 exact disjoint_empty_left _)", "start": [2853, 1], "end": [2863, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_union", "code": "theorem filter_union (s\u2081 s\u2082 : Finset \u03b1) : (s\u2081 \u222a s\u2082).filter p = s\u2081.filter p \u222a s\u2082.filter p", "start": [2868, 1], "end": [2869, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_union_right", "code": "theorem filter_union_right (s : Finset \u03b1) : s.filter p \u222a s.filter q = s.filter fun x => p x \u2228 q x", "start": [2872, 1], "end": [2873, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_mem_eq_inter", "code": "theorem filter_mem_eq_inter {s t : Finset \u03b1} [\u2200 i, Decidable (i \u2208 t)] :\n    (s.filter fun i => i \u2208 t) = s \u2229 t", "start": [2876, 1], "end": [2878, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_inter_distrib", "code": "theorem filter_inter_distrib (s t : Finset \u03b1) : (s \u2229 t).filter p = s.filter p \u2229 t.filter p", "start": [2881, 1], "end": [2883, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_inter", "code": "theorem filter_inter (s t : Finset \u03b1) : filter p s \u2229 t = filter p (s \u2229 t)", "start": [2886, 1], "end": [2888, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_filter", "code": "theorem inter_filter (s t : Finset \u03b1) : s \u2229 filter p t = filter p (s \u2229 t)", "start": [2891, 1], "end": [2892, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_insert", "code": "theorem filter_insert (a : \u03b1) (s : Finset \u03b1) :\n    filter p (insert a s) = if p a then insert a (filter p s) else filter p s", "start": [2895, 1], "end": [2898, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_erase", "code": "theorem filter_erase (a : \u03b1) (s : Finset \u03b1) : filter p (erase s a) = erase (filter p s) a", "start": [2901, 1], "end": [2903, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_or", "code": "theorem filter_or (s : Finset \u03b1) : (s.filter fun a => p a \u2228 q a) = s.filter p \u222a s.filter q", "start": [2906, 1], "end": [2907, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_and", "code": "theorem filter_and (s : Finset \u03b1) : (s.filter fun a => p a \u2227 q a) = s.filter p \u2229 s.filter q", "start": [2910, 1], "end": [2911, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_not", "code": "theorem filter_not (s : Finset \u03b1) : (s.filter fun a => \u00acp a) = s \\ s.filter p", "start": [2914, 1], "end": [2917, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_filter", "code": "theorem sdiff_eq_filter (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \\ s\u2082 = filter (\u00b7 \u2209 s\u2082) s\u2081", "start": [2920, 1], "end": [2921, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_self", "code": "theorem sdiff_eq_self (s\u2081 s\u2082 : Finset \u03b1) : s\u2081 \\ s\u2082 = s\u2081 \u2194 s\u2081 \u2229 s\u2082 \u2286 \u2205", "start": [2924, 1], "end": [2925, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_union_elim", "code": "theorem subset_union_elim {s : Finset \u03b1} {t\u2081 t\u2082 : Set \u03b1} (h : \u2191s \u2286 t\u2081 \u222a t\u2082) :\n    \u2203 s\u2081 s\u2082 : Finset \u03b1, s\u2081 \u222a s\u2082 = s \u2227 \u2191s\u2081 \u2286 t\u2081 \u2227 \u2191s\u2082 \u2286 t\u2082 \\ t\u2081", "start": [2928, 1], "end": [2938, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_eq", "code": "theorem filter_eq [DecidableEq \u03b2] (s : Finset \u03b2) (b : \u03b2) :\n    s.filter (Eq b) = ite (b \u2208 s) {b} \u2205", "start": [2964, 1], "end": [2979, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_eq'", "code": "theorem filter_eq' [DecidableEq \u03b2] (s : Finset \u03b2) (b : \u03b2) :\n    (s.filter fun a => a = b) = ite (b \u2208 s) {b} \u2205", "start": [2982, 1], "end": [2988, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_ne", "code": "theorem filter_ne [DecidableEq \u03b2] (s : Finset \u03b2) (b : \u03b2) :\n    (s.filter fun a => b \u2260 a) = s.erase b", "start": [2991, 1], "end": [2995, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_ne'", "code": "theorem filter_ne' [DecidableEq \u03b2] (s : Finset \u03b2) (b : \u03b2) : (s.filter fun a => a \u2260 b) = s.erase b", "start": [2998, 1], "end": [2999, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_inter_filter_neg_eq", "code": "theorem filter_inter_filter_neg_eq (s t : Finset \u03b1) :\n    (s.filter p \u2229 t.filter fun a => \u00acp a) = \u2205", "start": [3002, 1], "end": [3004, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_union_filter_of_codisjoint", "code": "theorem filter_union_filter_of_codisjoint (s : Finset \u03b1) (h : Codisjoint p q) :\n    s.filter p \u222a s.filter q = s", "start": [3007, 1], "end": [3009, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_union_filter_neg_eq", "code": "theorem filter_union_filter_neg_eq [\u2200 x, Decidable (\u00acp x)] (s : Finset \u03b1) :\n    (s.filter p \u222a s.filter fun a => \u00acp a) = s", "start": [3012, 1], "end": [3014, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.range", "code": "def range (n : \u2115) : Finset \u2115 :=\n  \u27e8_, nodup_range n\u27e9", "start": [3026, 1], "end": [3028, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.range_val", "code": "@[simp]\ntheorem range_val (n : \u2115) : (range n).1 = Multiset.range n", "start": [3031, 1], "end": [3033, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range", "code": "@[simp]\ntheorem mem_range : m \u2208 range n \u2194 m < n", "start": [3036, 1], "end": [3038, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_range", "code": "@[simp, norm_cast]\ntheorem coe_range (n : \u2115) : (range n : Set \u2115) = Set.Iio n", "start": [3041, 1], "end": [3043, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.range_zero", "code": "@[simp]\ntheorem range_zero : range 0 = \u2205", "start": [3046, 1], "end": [3048, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.range_one", "code": "@[simp]\ntheorem range_one : range 1 = {0}", "start": [3051, 1], "end": [3053, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.range_succ", "code": "theorem range_succ : range (succ n) = insert n (range n)", "start": [3056, 1], "end": [3057, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.range_add_one", "code": "theorem range_add_one : range (n + 1) = insert n (range n)", "start": [3060, 1], "end": [3061, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_range_self", "code": "theorem not_mem_range_self : n \u2209 range n", "start": [3065, 1], "end": [3066, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.self_mem_range_succ", "code": "theorem self_mem_range_succ (n : \u2115) : n \u2208 range (n + 1)", "start": [3070, 1], "end": [3071, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.range_subset", "code": "@[simp]\ntheorem range_subset {n m} : range n \u2286 range m \u2194 n \u2264 m", "start": [3074, 1], "end": [3076, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.range_mono", "code": "theorem range_mono : Monotone range", "start": [3079, 1], "end": [3079, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range_succ_iff", "code": "theorem mem_range_succ_iff {a b : \u2115} : a \u2208 Finset.range b.succ \u2194 a \u2264 b", "start": [3082, 1], "end": [3083, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range_le", "code": "theorem mem_range_le {n x : \u2115} (hx : x \u2208 range n) : x \u2264 n", "start": [3086, 1], "end": [3087, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range_sub_ne_zero", "code": "theorem mem_range_sub_ne_zero {n x : \u2115} (hx : x \u2208 range n) : n - x \u2260 0", "start": [3090, 1], "end": [3091, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_range_iff", "code": "@[simp]\ntheorem nonempty_range_iff : (range n).Nonempty \u2194 n \u2260 0", "start": [3094, 1], "end": [3097, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.range_eq_empty_iff", "code": "@[simp]\ntheorem range_eq_empty_iff : range n = \u2205 \u2194 n = 0", "start": [3100, 1], "end": [3102, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_range_succ", "code": "theorem nonempty_range_succ : (range <| n + 1).Nonempty", "start": [3105, 1], "end": [3106, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.range_filter_eq", "code": "@[simp]\ntheorem range_filter_eq {n m : \u2115} : (range n).filter (\u00b7 = m) = if m < n then {m} else \u2205", "start": [3109, 1], "end": [3114, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.range_nontrivial", "code": "lemma range_nontrivial {n : \u2115} (hn : 1 < n) : (Finset.range n).Nontrivial := by\n  rw [Finset.Nontrivial, Finset.coe_range]\n  exact \u27e80, zero_lt_one.trans hn, 1, hn, zero_ne_one\u27e9", "start": [3117, 1], "end": [3119, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.exists_mem_empty_iff", "code": "theorem exists_mem_empty_iff (p : \u03b1 \u2192 Prop) : (\u2203 x, x \u2208 (\u2205 : Finset \u03b1) \u2227 p x) \u2194 False", "start": [3124, 1], "end": [3125, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_mem_insert", "code": "theorem exists_mem_insert [DecidableEq \u03b1] (a : \u03b1) (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) :\n    (\u2203 x, x \u2208 insert a s \u2227 p x) \u2194 p a \u2228 \u2203 x, x \u2208 s \u2227 p x", "start": [3128, 1], "end": [3130, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_mem_empty_iff", "code": "theorem forall_mem_empty_iff (p : \u03b1 \u2192 Prop) : (\u2200 x, x \u2208 (\u2205 : Finset \u03b1) \u2192 p x) \u2194 True", "start": [3133, 1], "end": [3134, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_mem_insert", "code": "theorem forall_mem_insert [DecidableEq \u03b1] (a : \u03b1) (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) :\n    (\u2200 x, x \u2208 insert a s \u2192 p x) \u2194 p a \u2227 \u2200 x, x \u2208 s \u2192 p x", "start": [3137, 1], "end": [3139, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_of_forall_insert", "code": "theorem forall_of_forall_insert [DecidableEq \u03b1] {p : \u03b1 \u2192 Prop} {a : \u03b1} {s : Finset \u03b1}\n    (H : \u2200 x, x \u2208 insert a s \u2192 p x) (x) (h : x \u2208 s) : p x", "start": [3142, 1], "end": [3145, 29], "kind": "commanddeclaration"}, {"full_name": "notMemRangeEquiv", "code": "def notMemRangeEquiv (k : \u2115) : { n // n \u2209 range k } \u2243 \u2115 where\n  toFun i := i.1 - k\n  invFun j := \u27e8j + k, by simp\u27e9\n  left_inv j := by\n    rw [Subtype.ext_iff_val]\n    apply tsub_add_cancel_of_le\n    simpa using j.2\n  right_inv j := add_tsub_cancel_right _ _", "start": [3150, 1], "end": [3158, 43], "kind": "commanddeclaration"}, {"full_name": "coe_notMemRangeEquiv", "code": "@[simp]\ntheorem coe_notMemRangeEquiv (k : \u2115) :\n    (notMemRangeEquiv k : { n // n \u2209 range k } \u2192 \u2115) = fun (i : { n // n \u2209 range k }) => i - k", "start": [3161, 1], "end": [3164, 6], "kind": "commanddeclaration"}, {"full_name": "coe_notMemRangeEquiv_symm", "code": "@[simp]\ntheorem coe_notMemRangeEquiv_symm (k : \u2115) :\n    ((notMemRangeEquiv k).symm : \u2115 \u2192 { n // n \u2209 range k }) = fun j => \u27e8j + k, by simp\u27e9", "start": [3167, 1], "end": [3170, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset", "code": "def toFinset (s : Multiset \u03b1) : Finset \u03b1 :=\n  \u27e8_, nodup_dedup s\u27e9", "start": [3180, 1], "end": [3182, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_val", "code": "@[simp]\ntheorem toFinset_val (s : Multiset \u03b1) : s.toFinset.1 = s.dedup", "start": [3185, 1], "end": [3187, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_eq", "code": "theorem toFinset_eq {s : Multiset \u03b1} (n : Nodup s) : Finset.mk s n = s.toFinset", "start": [3190, 1], "end": [3191, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.toFinset_inj", "code": "theorem Nodup.toFinset_inj {l l' : Multiset \u03b1} (hl : Nodup l) (hl' : Nodup l')\n    (h : l.toFinset = l'.toFinset) : l = l'", "start": [3194, 1], "end": [3196, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_toFinset", "code": "@[simp]\ntheorem mem_toFinset {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s.toFinset \u2194 a \u2208 s", "start": [3199, 1], "end": [3201, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_zero", "code": "@[simp]\ntheorem toFinset_zero : toFinset (0 : Multiset \u03b1) = \u2205", "start": [3204, 1], "end": [3206, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_cons", "code": "@[simp]\ntheorem toFinset_cons (a : \u03b1) (s : Multiset \u03b1) : toFinset (a ::\u2098 s) = insert a (toFinset s)", "start": [3209, 1], "end": [3211, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_singleton", "code": "@[simp]\ntheorem toFinset_singleton (a : \u03b1) : toFinset ({a} : Multiset \u03b1) = {a}", "start": [3214, 1], "end": [3216, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_add", "code": "@[simp]\ntheorem toFinset_add (s t : Multiset \u03b1) : toFinset (s + t) = toFinset s \u222a toFinset t", "start": [3219, 1], "end": [3221, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_nsmul", "code": "@[simp]\ntheorem toFinset_nsmul (s : Multiset \u03b1) : \u2200 (n : \u2115) (_ : n \u2260 0), (n \u2022 s).toFinset = s.toFinset", "start": [3224, 1], "end": [3230, 93], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_inter", "code": "@[simp]\ntheorem toFinset_inter (s t : Multiset \u03b1) : toFinset (s \u2229 t) = toFinset s \u2229 toFinset t", "start": [3233, 1], "end": [3235, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_union", "code": "@[simp]\ntheorem toFinset_union (s t : Multiset \u03b1) : (s \u222a t).toFinset = s.toFinset \u222a t.toFinset", "start": [3238, 1], "end": [3240, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_eq_empty", "code": "@[simp]\ntheorem toFinset_eq_empty {m : Multiset \u03b1} : m.toFinset = \u2205 \u2194 m = 0", "start": [3243, 1], "end": [3245, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_nonempty", "code": "@[simp]\ntheorem toFinset_nonempty : s.toFinset.Nonempty \u2194 s \u2260 0", "start": [3248, 1], "end": [3250, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_subset", "code": "@[simp]\ntheorem toFinset_subset : s.toFinset \u2286 t.toFinset \u2194 s \u2286 t", "start": [3253, 1], "end": [3255, 76], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_ssubset", "code": "@[simp]\ntheorem toFinset_ssubset : s.toFinset \u2282 t.toFinset \u2194 s \u2282 t", "start": [3258, 1], "end": [3261, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_dedup", "code": "@[simp]\ntheorem toFinset_dedup (m : Multiset \u03b1) : m.dedup.toFinset = m.toFinset", "start": [3264, 1], "end": [3266, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_bind_dedup", "code": "@[simp]\ntheorem toFinset_bind_dedup [DecidableEq \u03b2] (m : Multiset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) :\n    (m.dedup.bind f).toFinset = (m.bind f).toFinset", "start": [3269, 1], "end": [3271, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.isWellFounded_ssubset", "code": "instance isWellFounded_ssubset : IsWellFounded (Multiset \u03b2) (\u00b7 \u2282 \u00b7) := by\n  classical\n  exact Subrelation.isWellFounded (InvImage _ toFinset) toFinset_ssubset.2", "start": [3274, 1], "end": [3276, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.val_toFinset", "code": "@[simp]\ntheorem val_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : s.val.toFinset = s", "start": [3283, 1], "end": [3286, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.val_le_iff_val_subset", "code": "theorem val_le_iff_val_subset {a : Finset \u03b1} {b : Multiset \u03b1} : a.val \u2264 b \u2194 a.val \u2286 b", "start": [3289, 1], "end": [3290, 33], "kind": "commanddeclaration"}, {"full_name": "List.toFinset", "code": "def toFinset (l : List \u03b1) : Finset \u03b1 :=\n  Multiset.toFinset l", "start": [3299, 1], "end": [3301, 22], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_val", "code": "@[simp]\ntheorem toFinset_val (l : List \u03b1) : l.toFinset.1 = (l.dedup : Multiset \u03b1)", "start": [3304, 1], "end": [3306, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_coe", "code": "@[simp]\ntheorem toFinset_coe (l : List \u03b1) : (l : Multiset \u03b1).toFinset = l.toFinset", "start": [3309, 1], "end": [3311, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_eq", "code": "theorem toFinset_eq (n : Nodup l) : @Finset.mk \u03b1 l n = l.toFinset", "start": [3314, 1], "end": [3315, 54], "kind": "commanddeclaration"}, {"full_name": "List.mem_toFinset", "code": "@[simp]\ntheorem mem_toFinset : a \u2208 l.toFinset \u2194 a \u2208 l", "start": [3318, 1], "end": [3320, 12], "kind": "commanddeclaration"}, {"full_name": "List.coe_toFinset", "code": "@[simp, norm_cast]\ntheorem coe_toFinset (l : List \u03b1) : (l.toFinset : Set \u03b1) = { a | a \u2208 l }", "start": [3323, 1], "end": [3325, 37], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_nil", "code": "@[simp]\ntheorem toFinset_nil : toFinset (@nil \u03b1) = \u2205", "start": [3328, 1], "end": [3330, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_cons", "code": "@[simp]\ntheorem toFinset_cons : toFinset (a :: l) = insert a (toFinset l)", "start": [3333, 1], "end": [3335, 98], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_surj_on", "code": "theorem toFinset_surj_on : Set.SurjOn toFinset { l : List \u03b1 | l.Nodup } Set.univ", "start": [3338, 1], "end": [3340, 39], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_surjective", "code": "theorem toFinset_surjective : Surjective (toFinset : List \u03b1 \u2192 Finset \u03b1)", "start": [3343, 1], "end": [3345, 11], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_eq_iff_perm_dedup", "code": "theorem toFinset_eq_iff_perm_dedup : l.toFinset = l'.toFinset \u2194 l.dedup ~ l'.dedup", "start": [3348, 1], "end": [3349, 66], "kind": "commanddeclaration"}, {"full_name": "List.toFinset.ext_iff", "code": "theorem toFinset.ext_iff {a b : List \u03b1} : a.toFinset = b.toFinset \u2194 \u2200 x, x \u2208 a \u2194 x \u2208 b", "start": [3352, 1], "end": [3353, 43], "kind": "commanddeclaration"}, {"full_name": "List.toFinset.ext", "code": "theorem toFinset.ext : (\u2200 x, x \u2208 l \u2194 x \u2208 l') \u2192 l.toFinset = l'.toFinset", "start": [3356, 1], "end": [3357, 23], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_eq_of_perm", "code": "theorem toFinset_eq_of_perm (l l' : List \u03b1) (h : l ~ l') : l.toFinset = l'.toFinset", "start": [3360, 1], "end": [3361, 41], "kind": "commanddeclaration"}, {"full_name": "List.perm_of_nodup_nodup_toFinset_eq", "code": "theorem perm_of_nodup_nodup_toFinset_eq (hl : Nodup l) (hl' : Nodup l')\n    (h : l.toFinset = l'.toFinset) : l ~ l'", "start": [3364, 1], "end": [3367, 45], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_append", "code": "@[simp]\ntheorem toFinset_append : toFinset (l ++ l') = l.toFinset \u222a l'.toFinset", "start": [3370, 1], "end": [3374, 14], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_reverse", "code": "@[simp]\ntheorem toFinset_reverse {l : List \u03b1} : toFinset l.reverse = l.toFinset", "start": [3377, 1], "end": [3379, 43], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_replicate_of_ne_zero", "code": "theorem toFinset_replicate_of_ne_zero {n : \u2115} (hn : n \u2260 0) :\n    (List.replicate n a).toFinset = {a}", "start": [3382, 1], "end": [3385, 32], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_union", "code": "@[simp]\ntheorem toFinset_union (l l' : List \u03b1) : (l \u222a l').toFinset = l.toFinset \u222a l'.toFinset", "start": [3388, 1], "end": [3391, 7], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_inter", "code": "@[simp]\ntheorem toFinset_inter (l l' : List \u03b1) : (l \u2229 l').toFinset = l.toFinset \u2229 l'.toFinset", "start": [3394, 1], "end": [3397, 7], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_eq_empty_iff", "code": "@[simp]\ntheorem toFinset_eq_empty_iff (l : List \u03b1) : l.toFinset = \u2205 \u2194 l = nil", "start": [3400, 1], "end": [3402, 19], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_nonempty_iff", "code": "@[simp]\ntheorem toFinset_nonempty_iff (l : List \u03b1) : l.toFinset.Nonempty \u2194 l \u2260 []", "start": [3405, 1], "end": [3407, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.toList", "code": "noncomputable def toList (s : Finset \u03b1) : List \u03b1 :=\n  s.1.toList", "start": [3416, 1], "end": [3418, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.nodup_toList", "code": "theorem nodup_toList (s : Finset \u03b1) : s.toList.Nodup", "start": [3421, 1], "end": [3423, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_toList", "code": "@[simp]\ntheorem mem_toList {a : \u03b1} {s : Finset \u03b1} : a \u2208 s.toList \u2194 a \u2208 s", "start": [3426, 1], "end": [3428, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_eq_nil", "code": "@[simp]\ntheorem toList_eq_nil {s : Finset \u03b1} : s.toList = [] \u2194 s = \u2205", "start": [3431, 1], "end": [3433, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_toList", "code": "@[simp]\ntheorem empty_toList {s : Finset \u03b1} : s.toList.isEmpty \u2194 s = \u2205", "start": [3436, 1], "end": [3438, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_empty", "code": "@[simp]\ntheorem toList_empty : (\u2205 : Finset \u03b1).toList = []", "start": [3441, 1], "end": [3443, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.toList_ne_nil", "code": "theorem Nonempty.toList_ne_nil {s : Finset \u03b1} (hs : s.Nonempty) : s.toList \u2260 []", "start": [3446, 1], "end": [3447, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.not_empty_toList", "code": "theorem Nonempty.not_empty_toList {s : Finset \u03b1} (hs : s.Nonempty) : \u00acs.toList.isEmpty", "start": [3450, 1], "end": [3451, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_toList", "code": "@[simp, norm_cast]\ntheorem coe_toList (s : Finset \u03b1) : (s.toList : Multiset \u03b1) = s.val", "start": [3454, 1], "end": [3456, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_toFinset", "code": "@[simp]\ntheorem toList_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : s.toList.toFinset = s", "start": [3459, 1], "end": [3462, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_eq_singleton_iff", "code": "@[simp]\ntheorem toList_eq_singleton_iff {a : \u03b1} {s : Finset \u03b1} : s.toList = [a] \u2194 s = {a}", "start": [3465, 1], "end": [3467, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_singleton", "code": "@[simp]\ntheorem toList_singleton : \u2200 a, ({a} : Finset \u03b1).toList = [a]", "start": [3470, 1], "end": [3472, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_list_nodup_eq", "code": "theorem exists_list_nodup_eq [DecidableEq \u03b1] (s : Finset \u03b1) :\n    \u2203 l : List \u03b1, l.Nodup \u2227 l.toFinset = s", "start": [3475, 1], "end": [3477, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_cons", "code": "theorem toList_cons {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : (cons a s h).toList ~ a :: s.toList", "start": [3480, 1], "end": [3482, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.toList_insert", "code": "theorem toList_insert [DecidableEq \u03b1] {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) :\n    (insert a s).toList ~ a :: s.toList", "start": [3485, 1], "end": [3487, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion", "code": "def disjiUnion (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) (hf : (s : Set \u03b1).PairwiseDisjoint t) : Finset \u03b2 :=\n  \u27e8s.val.bind (Finset.val \u2218 t),\n    Multiset.nodup_bind.mpr\n      \u27e8fun a _ => (t a).nodup,\n        s.nodup.pairwise fun _ ha _ hb hab => disjoint_val.2 <| hf ha hb hab\u27e9\u27e9", "start": [3504, 1], "end": [3511, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_val", "code": "@[simp]\ntheorem disjiUnion_val (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) (h) :\n    (s.disjiUnion t h).1 = s.1.bind fun a => (t a).1", "start": [3514, 1], "end": [3517, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_empty", "code": "@[simp]\ntheorem disjiUnion_empty (t : \u03b1 \u2192 Finset \u03b2) : disjiUnion \u2205 t (by simp) = \u2205", "start": [3520, 1], "end": [3522, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_disjiUnion", "code": "@[simp]\ntheorem mem_disjiUnion {b : \u03b2} {h} : b \u2208 s.disjiUnion t h \u2194 \u2203 a \u2208 s, b \u2208 t a", "start": [3525, 1], "end": [3527, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_disjiUnion", "code": "@[simp, norm_cast]\ntheorem coe_disjiUnion {h} : (s.disjiUnion t h : Set \u03b2) = \u22c3 x \u2208 (s : Set \u03b1), t x", "start": [3530, 1], "end": [3532, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_cons", "code": "@[simp]\ntheorem disjiUnion_cons (a : \u03b1) (s : Finset \u03b1) (ha : a \u2209 s) (f : \u03b1 \u2192 Finset \u03b2) (H) :\n    disjiUnion (cons a s ha) f H =\n    (f a).disjUnion ((s.disjiUnion f) fun _ hb _ hc => H (mem_cons_of_mem hb) (mem_cons_of_mem hc))\n      (disjoint_left.mpr fun _ hb h =>\n        let \u27e8_, hc, h\u27e9 := mem_disjiUnion.mp h\n        disjoint_left.mp\n          (H (mem_cons_self a s) (mem_cons_of_mem hc) (ne_of_mem_of_not_mem hc ha).symm) hb h)", "start": [3535, 1], "end": [3543, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_disjiUnion", "code": "@[simp]\ntheorem singleton_disjiUnion (a : \u03b1) {h} : Finset.disjiUnion {a} t h = t a", "start": [3546, 1], "end": [3548, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_disjiUnion", "code": "theorem disjiUnion_disjiUnion (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (g : \u03b2 \u2192 Finset \u03b3) (h1 h2) :\n    (s.disjiUnion f h1).disjiUnion g h2 =\n      s.attach.disjiUnion\n        (fun a =>\n          ((f a).disjiUnion g) fun b hb c hc =>\n            h2 (mem_disjiUnion.mpr \u27e8_, a.prop, hb\u27e9) (mem_disjiUnion.mpr \u27e8_, a.prop, hc\u27e9))\n        fun a _ b _ hab =>\n        disjoint_left.mpr fun x hxa hxb => by\n          obtain \u27e8xa, hfa, hga\u27e9 := mem_disjiUnion.mp hxa\n          obtain \u27e8xb, hfb, hgb\u27e9 := mem_disjiUnion.mp hxb\n          refine'\n            disjoint_left.mp\n              (h2 (mem_disjiUnion.mpr \u27e8_, a.prop, hfa\u27e9) (mem_disjiUnion.mpr \u27e8_, b.prop, hfb\u27e9) _) hga\n              hgb\n          rintro rfl\n          exact disjoint_left.mp (h1 a.prop b.prop <| Subtype.coe_injective.ne hab) hfa hfb", "start": [3551, 1], "end": [3567, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_filter_eq_of_maps_to", "code": "theorem disjiUnion_filter_eq_of_maps_to [DecidableEq \u03b2] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x \u2208 s, f x \u2208 t) :\n    t.disjiUnion (fun a => s.filter (fun c => f c = a))\n      (fun x' hx y' hy hne => by\n        simp_rw [disjoint_left, mem_filter]\n        rintro i \u27e8_, rfl\u27e9 \u27e8_, rfl\u27e9\n        exact hne rfl) = s", "start": [3570, 1], "end": [3577, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion", "code": "protected def biUnion (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) : Finset \u03b2 :=\n  (s.1.bind fun a => (t a).1).toFinset", "start": [3595, 1], "end": [3598, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_val", "code": "@[simp]\ntheorem biUnion_val (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) :\n    (s.biUnion t).1 = (s.1.bind fun a => (t a).1).dedup", "start": [3601, 1], "end": [3604, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_empty", "code": "@[simp]\ntheorem biUnion_empty : Finset.biUnion \u2205 t = \u2205", "start": [3607, 1], "end": [3609, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_biUnion", "code": "@[simp]\ntheorem mem_biUnion {b : \u03b2} : b \u2208 s.biUnion t \u2194 \u2203 a \u2208 s, b \u2208 t a", "start": [3612, 1], "end": [3614, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_biUnion", "code": "@[simp, norm_cast]\ntheorem coe_biUnion : (s.biUnion t : Set \u03b2) = \u22c3 x \u2208 (s : Set \u03b1), t x", "start": [3617, 1], "end": [3619, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_insert", "code": "@[simp]\ntheorem biUnion_insert [DecidableEq \u03b1] {a : \u03b1} : (insert a s).biUnion t = t a \u222a s.biUnion t", "start": [3622, 1], "end": [3626, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_congr", "code": "theorem biUnion_congr (hs : s\u2081 = s\u2082) (ht : \u2200 a \u2208 s\u2081, t\u2081 a = t\u2082 a) : s\u2081.biUnion t\u2081 = s\u2082.biUnion t\u2082", "start": [3630, 1], "end": [3634, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_eq_biUnion", "code": "@[simp]\ntheorem disjiUnion_eq_biUnion (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (hf) :\n    s.disjiUnion f hf = s.biUnion f", "start": [3637, 1], "end": [3640, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_subset", "code": "theorem biUnion_subset {s' : Finset \u03b2} : s.biUnion t \u2286 s' \u2194 \u2200 x \u2208 s, t x \u2286 s'", "start": [3643, 1], "end": [3645, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_biUnion", "code": "@[simp]\ntheorem singleton_biUnion {a : \u03b1} : Finset.biUnion {a} t = t a", "start": [3648, 1], "end": [3650, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_inter", "code": "theorem biUnion_inter (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (t : Finset \u03b2) :\n    s.biUnion f \u2229 t = s.biUnion fun x => f x \u2229 t", "start": [3653, 1], "end": [3657, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_biUnion", "code": "theorem inter_biUnion (t : Finset \u03b2) (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) :\n    t \u2229 s.biUnion f = s.biUnion fun x => t \u2229 f x", "start": [3660, 1], "end": [3663, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_biUnion", "code": "theorem biUnion_biUnion [DecidableEq \u03b3] (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (g : \u03b2 \u2192 Finset \u03b3) :\n    (s.biUnion f).biUnion g = s.biUnion fun a => (f a).biUnion g", "start": [3666, 1], "end": [3671, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.bind_toFinset", "code": "theorem bind_toFinset [DecidableEq \u03b1] (s : Multiset \u03b1) (t : \u03b1 \u2192 Multiset \u03b2) :\n    (s.bind t).toFinset = s.toFinset.biUnion fun a => (t a).toFinset", "start": [3674, 1], "end": [3676, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_mono", "code": "theorem biUnion_mono (h : \u2200 a \u2208 s, t\u2081 a \u2286 t\u2082 a) : s.biUnion t\u2081 \u2286 s.biUnion t\u2082", "start": [3679, 1], "end": [3682, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_subset_biUnion_of_subset_left", "code": "theorem biUnion_subset_biUnion_of_subset_left (t : \u03b1 \u2192 Finset \u03b2) (h : s\u2081 \u2286 s\u2082) :\n    s\u2081.biUnion t \u2286 s\u2082.biUnion t", "start": [3685, 1], "end": [3689, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_biUnion_of_mem", "code": "theorem subset_biUnion_of_mem (u : \u03b1 \u2192 Finset \u03b2) {x : \u03b1} (xs : x \u2208 s) : u x \u2286 s.biUnion u", "start": [3692, 1], "end": [3694, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_subset_iff_forall_subset", "code": "@[simp]\ntheorem biUnion_subset_iff_forall_subset {\u03b1 \u03b2 : Type*} [DecidableEq \u03b2] {s : Finset \u03b1}\n    {t : Finset \u03b2} {f : \u03b1 \u2192 Finset \u03b2} : s.biUnion f \u2286 t \u2194 \u2200 x \u2208 s, f x \u2286 t", "start": [3697, 1], "end": [3702, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_singleton_eq_self", "code": "@[simp]\ntheorem biUnion_singleton_eq_self [DecidableEq \u03b1] : s.biUnion (singleton : \u03b1 \u2192 Finset \u03b1) = s", "start": [3705, 1], "end": [3707, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_biUnion", "code": "theorem filter_biUnion (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (p : \u03b2 \u2192 Prop) [DecidablePred p] :\n    (s.biUnion f).filter p = s.biUnion fun a => (f a).filter p", "start": [3710, 1], "end": [3718, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_filter_eq_of_maps_to", "code": "theorem biUnion_filter_eq_of_maps_to [DecidableEq \u03b1] {s : Finset \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x \u2208 s, f x \u2208 t) : (t.biUnion fun a => s.filter fun c => f c = a) = s", "start": [3721, 1], "end": [3723, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_biUnion", "code": "theorem erase_biUnion (f : \u03b1 \u2192 Finset \u03b2) (s : Finset \u03b1) (b : \u03b2) :\n    (s.biUnion f).erase b = s.biUnion fun x => (f x).erase b", "start": [3726, 1], "end": [3730, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_nonempty", "code": "@[simp]\ntheorem biUnion_nonempty : (s.biUnion t).Nonempty \u2194 \u2203 x \u2208 s, (t x).Nonempty", "start": [3733, 1], "end": [3737, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.biUnion", "code": "theorem Nonempty.biUnion (hs : s.Nonempty) (ht : \u2200 x \u2208 s, (t x).Nonempty) :\n    (s.biUnion t).Nonempty", "start": [3740, 1], "end": [3742, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_biUnion_left", "code": "theorem disjoint_biUnion_left (s : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) (t : Finset \u03b2) :\n    Disjoint (s.biUnion f) t \u2194 \u2200 i \u2208 s, Disjoint (f i) t", "start": [3745, 1], "end": [3751, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_biUnion_right", "code": "theorem disjoint_biUnion_right (s : Finset \u03b2) (t : Finset \u03b1) (f : \u03b1 \u2192 Finset \u03b2) :\n    Disjoint s (t.biUnion f) \u2194 \u2200 i \u2208 t, Disjoint s (f i)", "start": [3754, 1], "end": [3756, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.chooseX", "code": "def chooseX (hp : \u2203! a, a \u2208 l \u2227 p a) : { a // a \u2208 l \u2227 p a } :=\n  Multiset.chooseX p l.val hp", "start": [3768, 1], "end": [3771, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.choose", "code": "def choose (hp : \u2203! a, a \u2208 l \u2227 p a) : \u03b1 :=\n  chooseX p l hp", "start": [3774, 1], "end": [3777, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.choose_spec", "code": "theorem choose_spec (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l \u2227 p (choose p l hp)", "start": [3780, 1], "end": [3781, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.choose_mem", "code": "theorem choose_mem (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l", "start": [3784, 1], "end": [3785, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.choose_property", "code": "theorem choose_property (hp : \u2203! a, a \u2208 l \u2227 p a) : p (choose p l hp)", "start": [3788, 1], "end": [3789, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwise_subtype_iff_pairwise_finset'", "code": "theorem pairwise_subtype_iff_pairwise_finset' (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) :\n    Pairwise (r on fun x : s => f x) \u2194 (s : Set \u03b1).Pairwise (r on f)", "start": [3798, 1], "end": [3800, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwise_subtype_iff_pairwise_finset", "code": "theorem pairwise_subtype_iff_pairwise_finset (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    Pairwise (r on fun x : s => x) \u2194 (s : Set \u03b1).Pairwise r", "start": [3803, 1], "end": [3805, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwise_cons'", "code": "theorem pairwise_cons' {a : \u03b1} (ha : a \u2209 s) (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) :\n    Pairwise (r on fun a : s.cons a ha => f a) \u2194\n    Pairwise (r on fun a : s => f a) \u2227 \u2200 b \u2208 s, r (f a) (f b) \u2227 r (f b) (f a)", "start": [3808, 1], "end": [3818, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwise_cons", "code": "theorem pairwise_cons {a : \u03b1} (ha : a \u2209 s) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    Pairwise (r on fun a : s.cons a ha => a) \u2194\n      Pairwise (r on fun a : s => a) \u2227 \u2200 b \u2208 s, r a b \u2227 r b a", "start": [3821, 1], "end": [3824, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaEquivOptionOfInhabited", "code": "def sigmaEquivOptionOfInhabited (\u03b1 : Type u) [Inhabited \u03b1] [DecidableEq \u03b1] :\n    \u03a3\u03b2 : Type u, \u03b1 \u2243 Option \u03b2 :=\n  \u27e8{ x : \u03b1 // x \u2260 default },\n    { toFun := fun x : \u03b1 => if h : x = default then none else some \u27e8x, h\u27e9\n      invFun := Option.elim' default (\u2191)\n      left_inv := fun x => by\n        dsimp only\n        split_ifs <;> simp [*]\n      right_inv := by\n        rintro (_ | \u27e8x, h\u27e9)\n        \u00b7 simp\n        \u00b7 dsimp only\n          split_ifs with hi\n          \u00b7 simp [h] at hi\n          \u00b7 simp }\u27e9", "start": [3833, 1], "end": [3850, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_toFinset", "code": "theorem disjoint_toFinset {m1 m2 : Multiset \u03b1} :\n    _root_.Disjoint m1.toFinset m2.toFinset \u2194 m1.Disjoint m2", "start": [3859, 1], "end": [3867, 18], "kind": "commanddeclaration"}, {"full_name": "List.disjoint_toFinset_iff_disjoint", "code": "theorem disjoint_toFinset_iff_disjoint : _root_.Disjoint l.toFinset l'.toFinset \u2194 l.Disjoint l'", "start": [3876, 1], "end": [3877, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Tuple/Basic.lean", "imports": ["Mathlib/Data/Pi/Lex.lean", "Mathlib/Data/Fin/Basic.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.tuple0_le", "code": "theorem tuple0_le {\u03b1 : \u2200 _ : Fin 0, Type*} [\u2200 i, Preorder (\u03b1 i)] (f g : \u2200 i, \u03b1 i) : f \u2264 g", "start": [49, 1], "end": [50, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.tail", "code": "def tail (q : \u2200 i, \u03b1 i) : \u2200 i : Fin n, \u03b1 i.succ := fun i \u21a6 q i.succ", "start": [56, 1], "end": [57, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.tail_def", "code": "theorem tail_def {n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {q : \u2200 i, \u03b1 i} :\n    (tail fun k : Fin (n + 1) \u21a6 q k) = fun k : Fin n \u21a6 q k.succ", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.cons", "code": "def cons (x : \u03b1 0) (p : \u2200 i : Fin n, \u03b1 i.succ) : \u2200 i, \u03b1 i := fun j \u21a6 Fin.cases x p j", "start": [65, 1], "end": [66, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.tail_cons", "code": "@[simp]\ntheorem tail_cons : tail (cons x p) = p", "start": [69, 1], "end": [70, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_succ", "code": "@[simp]\ntheorem cons_succ : cons x p i.succ = p i", "start": [73, 1], "end": [74, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_zero", "code": "@[simp]\ntheorem cons_zero : cons x p 0 = x", "start": [77, 1], "end": [78, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_one", "code": "@[simp]\ntheorem cons_one {\u03b1 : Fin (n + 2) \u2192 Type*} (x : \u03b1 0) (p : \u2200 i : Fin n.succ, \u03b1 i.succ) :\n    cons x p 1 = p 0", "start": [81, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_update", "code": "@[simp]\ntheorem cons_update : cons x (update p i y) = update (cons x p) i.succ y", "start": [86, 1], "end": [100, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_injective2", "code": "theorem cons_injective2 : Function.Injective2 (@cons n \u03b1)", "start": [103, 1], "end": [105, 74], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_eq_cons", "code": "@[simp]\ntheorem cons_eq_cons {x\u2080 y\u2080 : \u03b1 0} {x y : \u2200 i : Fin n, \u03b1 i.succ} :\n    cons x\u2080 x = cons y\u2080 y \u2194 x\u2080 = y\u2080 \u2227 x = y", "start": [108, 1], "end": [111, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_left_injective", "code": "theorem cons_left_injective (x : \u2200 i : Fin n, \u03b1 i.succ) : Function.Injective fun x\u2080 \u21a6 cons x\u2080 x", "start": [114, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_right_injective", "code": "theorem cons_right_injective (x\u2080 : \u03b1 0) : Function.Injective (cons x\u2080)", "start": [118, 1], "end": [119, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.update_cons_zero", "code": "theorem update_cons_zero : update (cons x p) 0 z = cons z p", "start": [122, 1], "end": [132, 38], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_self_tail", "code": "@[simp, nolint simpNF] theorem cons_self_tail : cons (q 0) (tail q) = q", "start": [135, 1], "end": [146, 19], "kind": "commanddeclaration"}, {"full_name": "Fin.consCases", "code": "@[elab_as_elim]\ndef consCases {P : (\u2200 i : Fin n.succ, \u03b1 i) \u2192 Sort v} (h : \u2200 x\u2080 x, P (Fin.cons x\u2080 x))\n    (x : \u2200 i : Fin n.succ, \u03b1 i) : P x :=\n  _root_.cast (by rw [cons_self_tail]) <| h (x 0) (tail x)", "start": [150, 1], "end": [154, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.consCases_cons", "code": "@[simp]\ntheorem consCases_cons {P : (\u2200 i : Fin n.succ, \u03b1 i) \u2192 Sort v} (h : \u2200 x\u2080 x, P (Fin.cons x\u2080 x))\n    (x\u2080 : \u03b1 0) (x : \u2200 i : Fin n, \u03b1 i.succ) : @consCases _ _ _ h (cons x\u2080 x) = h x\u2080 x", "start": [157, 1], "end": [161, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.consInduction", "code": "@[elab_as_elim]\ndef consInduction {\u03b1 : Type*} {P : \u2200 {n : \u2115}, (Fin n \u2192 \u03b1) \u2192 Sort v} (h0 : P Fin.elim0)\n    (h : \u2200 {n} (x\u2080) (x : Fin n \u2192 \u03b1), P x \u2192 P (Fin.cons x\u2080 x)) : \u2200 {n : \u2115} (x : Fin n \u2192 \u03b1), P x\n  | 0, x => by convert h0\n  | n + 1, x => consCases (fun x\u2080 x \u21a6 h _ _ <| consInduction h0 h _) x", "start": [164, 1], "end": [169, 71], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_injective_of_injective", "code": "theorem cons_injective_of_injective {\u03b1} {x\u2080 : \u03b1} {x : Fin n \u2192 \u03b1} (hx\u2080 : x\u2080 \u2209 Set.range x)\n    (hx : Function.Injective x) : Function.Injective (cons x\u2080 x : Fin n.succ \u2192 \u03b1)", "start": [172, 1], "end": [188, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_injective_iff", "code": "theorem cons_injective_iff {\u03b1} {x\u2080 : \u03b1} {x : Fin n \u2192 \u03b1} :\n    Function.Injective (cons x\u2080 x : Fin n.succ \u2192 \u03b1) \u2194 x\u2080 \u2209 Set.range x \u2227 Function.Injective x", "start": [191, 1], "end": [197, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_fin_zero_pi", "code": "@[simp]\ntheorem forall_fin_zero_pi {\u03b1 : Fin 0 \u2192 Sort*} {P : (\u2200 i, \u03b1 i) \u2192 Prop} :\n    (\u2200 x, P x) \u2194 P finZeroElim", "start": [200, 1], "end": [203, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_fin_zero_pi", "code": "@[simp]\ntheorem exists_fin_zero_pi {\u03b1 : Fin 0 \u2192 Sort*} {P : (\u2200 i, \u03b1 i) \u2192 Prop} :\n    (\u2203 x, P x) \u2194 P finZeroElim", "start": [206, 1], "end": [209, 69], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_fin_succ_pi", "code": "theorem forall_fin_succ_pi {P : (\u2200 i, \u03b1 i) \u2192 Prop} : (\u2200 x, P x) \u2194 \u2200 a v, P (Fin.cons a v)", "start": [212, 1], "end": [213, 44], "kind": "commanddeclaration"}, {"full_name": "Fin.exists_fin_succ_pi", "code": "theorem exists_fin_succ_pi {P : (\u2200 i, \u03b1 i) \u2192 Prop} : (\u2203 x, P x) \u2194 \u2203 a v, P (Fin.cons a v)", "start": [216, 1], "end": [217, 84], "kind": "commanddeclaration"}, {"full_name": "Fin.tail_update_zero", "code": "@[simp]\ntheorem tail_update_zero : tail (update q 0 z) = tail q", "start": [220, 1], "end": [224, 32], "kind": "commanddeclaration"}, {"full_name": "Fin.tail_update_succ", "code": "@[simp]\ntheorem tail_update_succ : tail (update q i.succ y) = update (tail q) i y", "start": [227, 1], "end": [234, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.comp_cons", "code": "theorem comp_cons {\u03b1 : Type*} {\u03b2 : Type*} (g : \u03b1 \u2192 \u03b2) (y : \u03b1) (q : Fin n \u2192 \u03b1) :\n    g \u2218 cons y q = cons (g y) (g \u2218 q)", "start": [237, 1], "end": [245, 50], "kind": "commanddeclaration"}, {"full_name": "Fin.comp_tail", "code": "theorem comp_tail {\u03b1 : Type*} {\u03b2 : Type*} (g : \u03b1 \u2192 \u03b2) (q : Fin n.succ \u2192 \u03b1) :\n    g \u2218 tail q = tail (g \u2218 q)", "start": [248, 1], "end": [251, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.le_cons", "code": "theorem le_cons [\u2200 i, Preorder (\u03b1 i)] {x : \u03b1 0} {q : \u2200 i, \u03b1 i} {p : \u2200 i : Fin n, \u03b1 i.succ} :\n    q \u2264 cons x p \u2194 q 0 \u2264 x \u2227 tail q \u2264 p", "start": [254, 1], "end": [256, 85], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_le", "code": "theorem cons_le [\u2200 i, Preorder (\u03b1 i)] {x : \u03b1 0} {q : \u2200 i, \u03b1 i} {p : \u2200 i : Fin n, \u03b1 i.succ} :\n    cons x p \u2264 q \u2194 x \u2264 q 0 \u2227 p \u2264 tail q", "start": [259, 1], "end": [261, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_le_cons", "code": "theorem cons_le_cons [\u2200 i, Preorder (\u03b1 i)] {x\u2080 y\u2080 : \u03b1 0} {x y : \u2200 i : Fin n, \u03b1 i.succ} :\n    cons x\u2080 x \u2264 cons y\u2080 y \u2194 x\u2080 \u2264 y\u2080 \u2227 x \u2264 y", "start": [264, 1], "end": [266, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.pi_lex_lt_cons_cons", "code": "theorem pi_lex_lt_cons_cons {x\u2080 y\u2080 : \u03b1 0} {x y : \u2200 i : Fin n, \u03b1 i.succ}\n    (s : \u2200 {i : Fin n.succ}, \u03b1 i \u2192 \u03b1 i \u2192 Prop) :\n    Pi.Lex (\u00b7 < \u00b7) (@s) (Fin.cons x\u2080 x) (Fin.cons y\u2080 y) \u2194\n      s x\u2080 y\u2080 \u2228 x\u2080 = y\u2080 \u2227 Pi.Lex (\u00b7 < \u00b7) (@fun i : Fin n \u21a6 @s i.succ) x y", "start": [269, 1], "end": [274, 36], "kind": "commanddeclaration"}, {"full_name": "Fin.range_fin_succ", "code": "theorem range_fin_succ {\u03b1} (f : Fin (n + 1) \u2192 \u03b1) :\n    Set.range f = insert (f 0) (Set.range (Fin.tail f))", "start": [277, 1], "end": [279, 62], "kind": "commanddeclaration"}, {"full_name": "Fin.range_cons", "code": "@[simp]\ntheorem range_cons {\u03b1 : Type*} {n : \u2115} (x : \u03b1) (b : Fin n \u2192 \u03b1) :\n    Set.range (Fin.cons x b : Fin n.succ \u2192 \u03b1) = insert x (Set.range b)", "start": [282, 1], "end": [285, 44], "kind": "commanddeclaration"}, {"full_name": "Fin.append", "code": "def append {\u03b1 : Type*} (a : Fin m \u2192 \u03b1) (b : Fin n \u2192 \u03b1) : Fin (m + n) \u2192 \u03b1 :=\n  @Fin.addCases _ _ (fun _ => \u03b1) a b", "start": [290, 1], "end": [293, 37], "kind": "commanddeclaration"}, {"full_name": "Fin.append_left", "code": "@[simp]\ntheorem append_left {\u03b1 : Type*} (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) (i : Fin m) :\n    append u v (Fin.castAdd n i) = u i", "start": [296, 1], "end": [299, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.append_right", "code": "@[simp]\ntheorem append_right {\u03b1 : Type*} (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) (i : Fin n) :\n    append u v (natAdd m i) = v i", "start": [302, 1], "end": [305, 19], "kind": "commanddeclaration"}, {"full_name": "Fin.append_right_nil", "code": "theorem append_right_nil {\u03b1 : Type*} (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) (hv : n = 0) :\n    append u v = u \u2218 Fin.cast (by rw [hv, add_zero])", "start": [308, 1], "end": [314, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.append_elim0'", "code": "@[simp]\ntheorem append_elim0' {\u03b1 : Type*} (u : Fin m \u2192 \u03b1) :\n    append u Fin.elim0' = u \u2218 Fin.cast (add_zero _)", "start": [317, 1], "end": [320, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.append_left_nil", "code": "theorem append_left_nil {\u03b1 : Type*} (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) (hu : m = 0) :\n    append u v = v \u2218 Fin.cast (by rw [hu, zero_add])", "start": [323, 1], "end": [329, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.elim0'_append", "code": "@[simp]\ntheorem elim0'_append {\u03b1 : Type*} (v : Fin n \u2192 \u03b1) :\n    append Fin.elim0' v = v \u2218 Fin.cast (zero_add _)", "start": [332, 1], "end": [335, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.append_assoc", "code": "theorem append_assoc {p : \u2115} {\u03b1 : Type*} (a : Fin m \u2192 \u03b1) (b : Fin n \u2192 \u03b1) (c : Fin p \u2192 \u03b1) :\n    append (append a b) c = append a (append b c) \u2218 Fin.cast (add_assoc _ _ _)", "start": [338, 1], "end": [350, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.append_left_eq_cons", "code": "theorem append_left_eq_cons {\u03b1 : Type*} {n : \u2115} (x\u2080 : Fin 1 \u2192 \u03b1) (x : Fin n \u2192 \u03b1) :\n    Fin.append x\u2080 x = Fin.cons (x\u2080 0) x \u2218 Fin.cast (add_comm _ _)", "start": [353, 1], "end": [363, 30], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat", "code": "def \u00abrepeat\u00bb {\u03b1 : Type*} (m : \u2115) (a : Fin n \u2192 \u03b1) : Fin (m * n) \u2192 \u03b1\n  | i => a i.modNat", "start": [370, 1], "end": [373, 20], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat_apply", "code": "@[simp]\ntheorem repeat_apply {\u03b1 : Type*} (a : Fin n \u2192 \u03b1) (i : Fin (m * n)) :\n    Fin.repeat m a i = a i.modNat", "start": [377, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat_zero", "code": "@[simp]\ntheorem repeat_zero {\u03b1 : Type*} (a : Fin n \u2192 \u03b1) :\n    Fin.repeat 0 a = Fin.elim0' \u2218 cast (zero_mul _)", "start": [382, 1], "end": [385, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat_one", "code": "@[simp]\ntheorem repeat_one {\u03b1 : Type*} (a : Fin n \u2192 \u03b1) : Fin.repeat 1 a = a \u2218 cast (one_mul _)", "start": [388, 1], "end": [394, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat_succ", "code": "theorem repeat_succ {\u03b1 : Type*} (a : Fin n \u2192 \u03b1) (m : \u2115) :\n    Fin.repeat m.succ a =\n      append a (Fin.repeat m a) \u2218 cast ((Nat.succ_mul _ _).trans (add_comm _ _))", "start": [397, 1], "end": [405, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.repeat_add", "code": "@[simp]\ntheorem repeat_add {\u03b1 : Type*} (a : Fin n \u2192 \u03b1) (m\u2081 m\u2082 : \u2115) : Fin.repeat (m\u2081 + m\u2082) a =\n    append (Fin.repeat m\u2081 a) (Fin.repeat m\u2082 a) \u2218 cast (add_mul _ _ _)", "start": [408, 1], "end": [416, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.init", "code": "def init (q : \u2200 i, \u03b1 i) (i : Fin n) : \u03b1 (castSucc i) :=\n  q (castSucc i)", "start": [436, 1], "end": [438, 17], "kind": "commanddeclaration"}, {"full_name": "Fin.init_def", "code": "theorem init_def {n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*} {q : \u2200 i, \u03b1 i} :\n    (init fun k : Fin (n + 1) \u21a6 q k) = fun k : Fin n \u21a6 q (castSucc k)", "start": [441, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc", "code": "def snoc (p : \u2200 i : Fin n, \u03b1 (castSucc i)) (x : \u03b1 (last n)) (i : Fin (n + 1)) : \u03b1 i :=\n  if h : i.val < n then _root_.cast (by rw [Fin.castSucc_castLT i h]) (p (castLT i h))\n  else _root_.cast (by rw [eq_last_of_not_lt h]) x", "start": [446, 1], "end": [450, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.init_snoc", "code": "@[simp]\ntheorem init_snoc : init (snoc p x) = p", "start": [453, 1], "end": [457, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_castSucc", "code": "@[simp]\ntheorem snoc_castSucc : snoc p x (castSucc i) = p i", "start": [460, 1], "end": [463, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_comp_castSucc", "code": "@[simp]\ntheorem snoc_comp_castSucc {n : \u2115} {\u03b1 : Sort _} {a : \u03b1} {f : Fin n \u2192 \u03b1} :\n    (snoc f a : Fin (n + 1) \u2192 \u03b1) \u2218 castSucc = f", "start": [466, 1], "end": [469, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_last", "code": "@[simp]\ntheorem snoc_last : snoc p x (last n) = x", "start": [472, 1], "end": [473, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_comp_nat_add", "code": "@[simp]\ntheorem snoc_comp_nat_add {n m : \u2115} {\u03b1 : Sort _} (f : Fin (m + n) \u2192 \u03b1) (a : \u03b1) :\n    (snoc f a : Fin _ \u2192 \u03b1) \u2218 (natAdd m : Fin (n + 1) \u2192 Fin (m + n + 1)) =\n      snoc (f \u2218 natAdd m) a", "start": [476, 1], "end": [485, 40], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_cast_add", "code": "@[simp]\ntheorem snoc_cast_add {\u03b1 : Fin (n + m + 1) \u2192 Type*} (f : \u2200 i : Fin (n + m), \u03b1 (castSucc i))\n    (a : \u03b1 (last (n + m))) (i : Fin n) : (snoc f a) (castAdd (m + 1) i) = f (castAdd m i)", "start": [488, 1], "end": [491, 12], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_comp_cast_add", "code": "@[simp]\ntheorem snoc_comp_cast_add {n m : \u2115} {\u03b1 : Sort _} (f : Fin (n + m) \u2192 \u03b1) (a : \u03b1) :\n    (snoc f a : Fin _ \u2192 \u03b1) \u2218 castAdd (m + 1) = f \u2218 castAdd m", "start": [495, 1], "end": [498, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_update", "code": "@[simp]\ntheorem snoc_update : snoc (update p i y) x = update (snoc p x) (castSucc i) y", "start": [501, 1], "end": [530, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.update_snoc_last", "code": "theorem update_snoc_last : update (snoc p x) (last n) z = snoc p z", "start": [533, 1], "end": [541, 9], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_init_self", "code": "@[simp]\ntheorem snoc_init_self : snoc (init q) (q (last n)) = q", "start": [544, 1], "end": [554, 9], "kind": "commanddeclaration"}, {"full_name": "Fin.init_update_last", "code": "@[simp]\ntheorem init_update_last : init (update q (last n) z) = init q", "start": [557, 1], "end": [561, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.init_update_castSucc", "code": "@[simp]\ntheorem init_update_castSucc : init (update q (castSucc i) y) = update (init q) i y", "start": [564, 1], "end": [571, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.tail_init_eq_init_tail", "code": "theorem tail_init_eq_init_tail {\u03b2 : Type*} (q : Fin (n + 2) \u2192 \u03b2) :\n    tail (init q) = init (tail q)", "start": [574, 1], "end": [579, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.cons_snoc_eq_snoc_cons", "code": "theorem cons_snoc_eq_snoc_cons {\u03b2 : Type*} (a : \u03b2) (q : Fin n \u2192 \u03b2) (b : \u03b2) :\n    @cons n.succ (fun _ \u21a6 \u03b2) a (snoc q b) = snoc (cons a q) b", "start": [582, 1], "end": [601, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.comp_snoc", "code": "theorem comp_snoc {\u03b1 : Type*} {\u03b2 : Type*} (g : \u03b1 \u2192 \u03b2) (q : Fin n \u2192 \u03b1) (y : \u03b1) :\n    g \u2218 snoc q y = snoc (g \u2218 q) (g y)", "start": [604, 1], "end": [610, 9], "kind": "commanddeclaration"}, {"full_name": "Fin.append_right_eq_snoc", "code": "theorem append_right_eq_snoc {\u03b1 : Type*} {n : \u2115} (x : Fin n \u2192 \u03b1) (x\u2080 : Fin 1 \u2192 \u03b1) :\n    Fin.append x x\u2080 = Fin.snoc x (x\u2080 0)", "start": [613, 1], "end": [623, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.comp_init", "code": "theorem comp_init {\u03b1 : Type*} {\u03b2 : Type*} (g : \u03b1 \u2192 \u03b2) (q : Fin n.succ \u2192 \u03b1) :\n    g \u2218 init q = init (g \u2218 q)", "start": [626, 1], "end": [629, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.succAboveCases", "code": "@[elab_as_elim]\ndef succAboveCases {\u03b1 : Fin (n + 1) \u2192 Sort u} (i : Fin (n + 1)) (x : \u03b1 i)\n    (p : \u2200 j : Fin n, \u03b1 (i.succAbove j)) (j : Fin (n + 1)) : \u03b1 j :=\n  if hj : j = i then Eq.rec x hj.symm\n  else\n    if hlt : j < i then @Eq.recOn _ _ (fun x _ \u21a6 \u03b1 x) _ (succAbove_castLT hlt) (p _)\n    else @Eq.recOn _ _ (fun x _ \u21a6 \u03b1 x) _ (succAbove_pred <| (Ne.lt_or_lt hj).resolve_left hlt) (p _)", "start": [640, 1], "end": [650, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.forall_iff_succAbove", "code": "theorem forall_iff_succAbove {p : Fin (n + 1) \u2192 Prop} (i : Fin (n + 1)) :\n    (\u2200 j, p j) \u2194 p i \u2227 \u2200 j, p (i.succAbove j)", "start": [653, 1], "end": [655, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth", "code": "def insertNth (i : Fin (n + 1)) (x : \u03b1 i) (p : \u2200 j : Fin n, \u03b1 (i.succAbove j)) (j : Fin (n + 1)) :\n    \u03b1 j :=\n  succAboveCases i x p j", "start": [658, 1], "end": [663, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_apply_same", "code": "@[simp]\ntheorem insertNth_apply_same (i : Fin (n + 1)) (x : \u03b1 i) (p : \u2200 j, \u03b1 (i.succAbove j)) :\n    insertNth i x p i = x", "start": [666, 1], "end": [668, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_apply_succAbove", "code": "@[simp]\ntheorem insertNth_apply_succAbove (i : Fin (n + 1)) (x : \u03b1 i) (p : \u2200 j, \u03b1 (i.succAbove j))\n    (j : Fin n) : insertNth i x p (i.succAbove j) = p j", "start": [671, 1], "end": [683, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.succAbove_cases_eq_insertNth", "code": "@[simp]\ntheorem succAbove_cases_eq_insertNth : @succAboveCases.{u + 1} = @insertNth.{u}", "start": [686, 1], "end": [688, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_comp_succAbove", "code": "@[simp]\ntheorem insertNth_comp_succAbove (i : Fin (n + 1)) (x : \u03b2) (p : Fin n \u2192 \u03b2) :\n    insertNth i x p \u2218 i.succAbove = p", "start": [693, 1], "end": [696, 65], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_eq_iff", "code": "theorem insertNth_eq_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    i.insertNth x p = q \u2194 q i = x \u2227 p = fun j \u21a6 q (i.succAbove j)", "start": [699, 1], "end": [701, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_insertNth_iff", "code": "theorem eq_insertNth_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    q = i.insertNth x p \u2194 q i = x \u2227 p = fun j \u21a6 q (i.succAbove j)", "start": [704, 1], "end": [706, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_apply_below", "code": "theorem insertNth_apply_below {i j : Fin (n + 1)} (h : j < i) (x : \u03b1 i)\n    (p : \u2200 k, \u03b1 (i.succAbove k)) :\n    i.insertNth x p j = @Eq.recOn _ _ (fun x _ \u21a6 \u03b1 x) _ (succAbove_castLT h) (p <| j.castLT _)", "start": [711, 1], "end": [714, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_apply_above", "code": "theorem insertNth_apply_above {i j : Fin (n + 1)} (h : i < j) (x : \u03b1 i)\n    (p : \u2200 k, \u03b1 (i.succAbove k)) :\n    i.insertNth x p j = @Eq.recOn _ _ (fun x _ \u21a6 \u03b1 x) _ (succAbove_pred h) (p <| j.pred _)", "start": [719, 1], "end": [722, 66], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_zero", "code": "theorem insertNth_zero (x : \u03b1 0) (p : \u2200 j : Fin n, \u03b1 (succAbove 0 j)) :\n    insertNth 0 x p =\n      cons x fun j \u21a6 _root_.cast (congr_arg \u03b1 (congr_fun succAbove_zero j)) (p j)", "start": [725, 1], "end": [730, 33], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_zero'", "code": "@[simp]\ntheorem insertNth_zero' (x : \u03b2) (p : Fin n \u2192 \u03b2) : @insertNth _ (fun _ \u21a6 \u03b2) 0 x p = cons x p", "start": [733, 1], "end": [735, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_last", "code": "theorem insertNth_last (x : \u03b1 (last n)) (p : \u2200 j : Fin n, \u03b1 ((last n).succAbove j)) :\n    insertNth (last n) x p =\n      snoc (fun j \u21a6 _root_.cast (congr_arg \u03b1 (succAbove_last_apply j)) (p j)) x", "start": [738, 1], "end": [748, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_last'", "code": "@[simp]\ntheorem insertNth_last' (x : \u03b2) (p : Fin n \u2192 \u03b2) :\n    @insertNth _ (fun _ \u21a6 \u03b2) (last n) x p = snoc p x", "start": [751, 1], "end": [753, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_zero_right", "code": "@[simp]\ntheorem insertNth_zero_right [\u2200 j, Zero (\u03b1 j)] (i : Fin (n + 1)) (x : \u03b1 i) :\n    i.insertNth x 0 = Pi.single i x", "start": [756, 1], "end": [759, 60], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_binop", "code": "theorem insertNth_binop (op : \u2200 j, \u03b1 j \u2192 \u03b1 j \u2192 \u03b1 j) (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p q : \u2200 j, \u03b1 (i.succAbove j)) :\n    (i.insertNth (op i x y) fun j \u21a6 op _ (p j) (q j)) = fun j \u21a6\n      op j (i.insertNth x p j) (i.insertNth y q j)", "start": [762, 1], "end": [766, 32], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_mul", "code": "@[simp]\ntheorem insertNth_mul [\u2200 j, Mul (\u03b1 j)] (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p q : \u2200 j, \u03b1 (i.succAbove j)) :\n    i.insertNth (x * y) (p * q) = i.insertNth x p * i.insertNth y q", "start": [769, 1], "end": [773, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_add", "code": "@[simp]\ntheorem insertNth_add [\u2200 j, Add (\u03b1 j)] (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p q : \u2200 j, \u03b1 (i.succAbove j)) :\n    i.insertNth (x + y) (p + q) = i.insertNth x p + i.insertNth y q", "start": [776, 1], "end": [780, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_div", "code": "@[simp]\ntheorem insertNth_div [\u2200 j, Div (\u03b1 j)] (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p q : \u2200 j, \u03b1 (i.succAbove j)) :\n    i.insertNth (x / y) (p / q) = i.insertNth x p / i.insertNth y q", "start": [783, 1], "end": [787, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_sub", "code": "@[simp]\ntheorem insertNth_sub [\u2200 j, Sub (\u03b1 j)] (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p q : \u2200 j, \u03b1 (i.succAbove j)) :\n    i.insertNth (x - y) (p - q) = i.insertNth x p - i.insertNth y q", "start": [790, 1], "end": [794, 46], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_sub_same", "code": "@[simp]\ntheorem insertNth_sub_same [\u2200 j, AddGroup (\u03b1 j)] (i : Fin (n + 1)) (x y : \u03b1 i)\n    (p : \u2200 j, \u03b1 (i.succAbove j)) : i.insertNth x p - i.insertNth y p = Pi.single i (x - y)", "start": [797, 1], "end": [800, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_le_iff", "code": "theorem insertNth_le_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    i.insertNth x p \u2264 q \u2194 x \u2264 q i \u2227 p \u2264 fun j \u21a6 q (i.succAbove j)", "start": [805, 1], "end": [807, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.le_insertNth_iff", "code": "theorem le_insertNth_iff {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)} {q : \u2200 j, \u03b1 j} :\n    q \u2264 i.insertNth x p \u2194 q i \u2264 x \u2227 (fun j \u21a6 q (i.succAbove j)) \u2264 p", "start": [810, 1], "end": [812, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.insertNth_mem_Icc", "code": "theorem insertNth_mem_Icc {i : Fin (n + 1)} {x : \u03b1 i} {p : \u2200 j, \u03b1 (i.succAbove j)}\n    {q\u2081 q\u2082 : \u2200 j, \u03b1 j} :\n    i.insertNth x p \u2208 Icc q\u2081 q\u2082 \u2194\n      x \u2208 Icc (q\u2081 i) (q\u2082 i) \u2227 p \u2208 Icc (fun j \u21a6 q\u2081 (i.succAbove j)) fun j \u21a6 q\u2082 (i.succAbove j)", "start": [817, 1], "end": [821, 96], "kind": "commanddeclaration"}, {"full_name": "Fin.preimage_insertNth_Icc_of_mem", "code": "theorem preimage_insertNth_Icc_of_mem {i : Fin (n + 1)} {x : \u03b1 i} {q\u2081 q\u2082 : \u2200 j, \u03b1 j}\n    (hx : x \u2208 Icc (q\u2081 i) (q\u2082 i)) :\n    i.insertNth x \u207b\u00b9' Icc q\u2081 q\u2082 = Icc (fun j \u21a6 q\u2081 (i.succAbove j)) fun j \u21a6 q\u2082 (i.succAbove j)", "start": [824, 1], "end": [827, 83], "kind": "commanddeclaration"}, {"full_name": "Fin.preimage_insertNth_Icc_of_not_mem", "code": "theorem preimage_insertNth_Icc_of_not_mem {i : Fin (n + 1)} {x : \u03b1 i} {q\u2081 q\u2082 : \u2200 j, \u03b1 j}\n    (hx : x \u2209 Icc (q\u2081 i) (q\u2082 i)) : i.insertNth x \u207b\u00b9' Icc q\u2081 q\u2082 = \u2205", "start": [830, 1], "end": [833, 88], "kind": "commanddeclaration"}, {"full_name": "Fin.find", "code": "def find : \u2200 {n : \u2115} (p : Fin n \u2192 Prop) [DecidablePred p], Option (Fin n)\n  | 0, _p, _ => none\n  | n + 1, p, _ => by\n    exact\n      Option.casesOn (@find n (fun i \u21a6 p (i.castLT (Nat.lt_succ_of_lt i.2))) _)\n        (if _ : p (Fin.last n) then some (Fin.last n) else none) fun i \u21a6\n        some (i.castLT (Nat.lt_succ_of_lt i.2))", "start": [840, 1], "end": [848, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.find_spec", "code": "theorem find_spec :\n    \u2200 {n : \u2115} (p : Fin n \u2192 Prop) [DecidablePred p] {i : Fin n} (_ : i \u2208 Fin.find p), p i", "start": [851, 1], "end": [867, 79], "kind": "commanddeclaration"}, {"full_name": "Fin.isSome_find_iff", "code": "theorem isSome_find_iff :\n    \u2200 {n : \u2115} {p : Fin n \u2192 Prop} [DecidablePred p], (find p).isSome \u2194 \u2203 i, p i", "start": [870, 1], "end": [887, 14], "kind": "commanddeclaration"}, {"full_name": "Fin.find_eq_none_iff", "code": "theorem find_eq_none_iff {n : \u2115} {p : Fin n \u2192 Prop} [DecidablePred p] :\n    find p = none \u2194 \u2200 i, \u00acp i", "start": [890, 1], "end": [892, 96], "kind": "commanddeclaration"}, {"full_name": "Fin.find_min", "code": "theorem find_min :\n    \u2200 {n : \u2115} {p : Fin n \u2192 Prop} [DecidablePred p] {i : Fin n} (_ : i \u2208 Fin.find p) {j : Fin n}\n      (_ : j < i), \u00acp j", "start": [895, 1], "end": [913, 77], "kind": "commanddeclaration"}, {"full_name": "Fin.find_min'", "code": "theorem find_min' {p : Fin n \u2192 Prop} [DecidablePred p] {i : Fin n} (h : i \u2208 Fin.find p) {j : Fin n}\n    (hj : p j) : i \u2264 j", "start": [916, 1], "end": [918, 43], "kind": "commanddeclaration"}, {"full_name": "Fin.nat_find_mem_find", "code": "theorem nat_find_mem_find {p : Fin n \u2192 Prop} [DecidablePred p]\n    (h : \u2203 i, \u2203 hin : i < n, p \u27e8i, hin\u27e9) :\n    (\u27e8Nat.find h, (Nat.find_spec h).fst\u27e9 : Fin n) \u2208 find p", "start": [921, 1], "end": [930, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.mem_find_iff", "code": "theorem mem_find_iff {p : Fin n \u2192 Prop} [DecidablePred p] {i : Fin n} :\n    i \u2208 Fin.find p \u2194 p i \u2227 \u2200 j, p j \u2192 i \u2264 j", "start": [933, 1], "end": [940, 90], "kind": "commanddeclaration"}, {"full_name": "Fin.find_eq_some_iff", "code": "theorem find_eq_some_iff {p : Fin n \u2192 Prop} [DecidablePred p] {i : Fin n} :\n    Fin.find p = some i \u2194 p i \u2227 \u2200 j, p j \u2192 i \u2264 j", "start": [943, 1], "end": [945, 15], "kind": "commanddeclaration"}, {"full_name": "Fin.mem_find_of_unique", "code": "theorem mem_find_of_unique {p : Fin n \u2192 Prop} [DecidablePred p] (h : \u2200 i j, p i \u2192 p j \u2192 i = j)\n    {i : Fin n} (hi : p i) : i \u2208 Fin.find p", "start": [948, 1], "end": [950, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.contractNth", "code": "def contractNth (j : Fin (n + 1)) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (g : Fin (n + 1) \u2192 \u03b1) (k : Fin n) : \u03b1 :=\n  if (k : \u2115) < j then g (Fin.castSucc k)\n  else if (k : \u2115) = j then op (g (Fin.castSucc k)) (g k.succ) else g k.succ", "start": [959, 1], "end": [962, 76], "kind": "commanddeclaration"}, {"full_name": "Fin.contractNth_apply_of_lt", "code": "theorem contractNth_apply_of_lt (j : Fin (n + 1)) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (g : Fin (n + 1) \u2192 \u03b1) (k : Fin n)\n    (h : (k : \u2115) < j) : contractNth j op g k = g (Fin.castSucc k)", "start": [965, 1], "end": [967, 11], "kind": "commanddeclaration"}, {"full_name": "Fin.contractNth_apply_of_eq", "code": "theorem contractNth_apply_of_eq (j : Fin (n + 1)) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (g : Fin (n + 1) \u2192 \u03b1) (k : Fin n)\n    (h : (k : \u2115) = j) : contractNth j op g k = op (g (Fin.castSucc k)) (g k.succ)", "start": [970, 1], "end": [973, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.contractNth_apply_of_gt", "code": "theorem contractNth_apply_of_gt (j : Fin (n + 1)) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (g : Fin (n + 1) \u2192 \u03b1) (k : Fin n)\n    (h : (j : \u2115) < k) : contractNth j op g k = g k.succ", "start": [976, 1], "end": [978, 76], "kind": "commanddeclaration"}, {"full_name": "Fin.contractNth_apply_of_ne", "code": "theorem contractNth_apply_of_ne (j : Fin (n + 1)) (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (g : Fin (n + 1) \u2192 \u03b1) (k : Fin n)\n    (hjk : (j : \u2115) \u2260 k) : contractNth j op g k = g (j.succAbove k)", "start": [981, 1], "end": [988, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.sigma_eq_of_eq_comp_cast", "code": "theorem sigma_eq_of_eq_comp_cast {\u03b1 : Type*} :\n    \u2200 {a b : \u03a3ii, Fin ii \u2192 \u03b1} (h : a.fst = b.fst), a.snd = b.snd \u2218 Fin.cast h \u2192 a = b", "start": [993, 1], "end": [1000, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.sigma_eq_iff_eq_comp_cast", "code": "theorem sigma_eq_iff_eq_comp_cast {\u03b1 : Type*} {a b : \u03a3ii, Fin ii \u2192 \u03b1} :\n    a = b \u2194 \u2203 h : a.fst = b.fst, a.snd = b.snd \u2218 Fin.cast h", "start": [1003, 1], "end": [1007, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Cast/Field.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Algebra/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.cast_neg_natCast", "code": "@[norm_cast]\ntheorem cast_neg_natCast {R} [DivisionRing R] (n : \u2115) : ((-n : \u2124) : R) = -n", "start": [29, 1], "end": [35, 87], "kind": "commanddeclaration"}, {"full_name": "Int.cast_div", "code": "@[simp]\ntheorem cast_div [DivisionRing \u03b1] {m n : \u2124} (n_dvd : n \u2223 m) (n_nonzero : (n : \u03b1) \u2260 0) :\n    ((m / n : \u2124) : \u03b1) = m / n", "start": [38, 1], "end": [45, 95], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Invertible.lean", "imports": ["Mathlib/Algebra/Invertible/Basic.lean", "Mathlib/Data/Nat/Cast/Order.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "invOf_pos", "code": "@[simp]\ntheorem invOf_pos [Invertible a] : 0 < \u215f a \u2194 0 < a", "start": [20, 1], "end": [23, 84], "kind": "commanddeclaration"}, {"full_name": "invOf_nonpos", "code": "@[simp]\ntheorem invOf_nonpos [Invertible a] : \u215f a \u2264 0 \u2194 a \u2264 0", "start": [26, 1], "end": [27, 92], "kind": "commanddeclaration"}, {"full_name": "invOf_nonneg", "code": "@[simp]\ntheorem invOf_nonneg [Invertible a] : 0 \u2264 \u215f a \u2194 0 \u2264 a", "start": [30, 1], "end": [33, 88], "kind": "commanddeclaration"}, {"full_name": "invOf_lt_zero", "code": "@[simp]\ntheorem invOf_lt_zero [Invertible a] : \u215f a < 0 \u2194 a < 0", "start": [36, 1], "end": [37, 96], "kind": "commanddeclaration"}, {"full_name": "invOf_le_one", "code": "@[simp]\ntheorem invOf_le_one [Invertible a] (h : 1 \u2264 a) : \u215f a \u2264 1", "start": [40, 1], "end": [42, 85], "kind": "commanddeclaration"}, {"full_name": "pos_invOf_of_invertible_cast", "code": "theorem pos_invOf_of_invertible_cast [Nontrivial \u03b1] (n : \u2115)\n    [Invertible (n : \u03b1)] : 0 < \u215f(n : \u03b1)", "start": [45, 1], "end": [47, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Core.lean", "imports": ["lake-packages/std/Std/Lean/Parser.lean", "Mathlib/Tactic/NormNum/Result.lean", "lake-packages/std/Std/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Util/Qq.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.NormNumExt", "code": "structure NormNumExt where\n  \n  pre := true\n  \n  post := true\n  \n  eval {\u03b1 : Q(Type u)} (e : Q($\u03b1)) : MetaM (Result e)\n  \n  name : Name := by exact decl_name%", "start": [34, 1], "end": [45, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.mkNormNumExt", "code": "def mkNormNumExt (n : Name) : ImportM NormNumExt := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck NormNumExt opts ``NormNumExt n", "start": [47, 1], "end": [50, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Entry", "code": "abbrev Entry := Array (Array (DiscrTree.Key true)) \u00d7 Name", "start": [52, 1], "end": [54, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.NormNums", "code": "structure NormNums where\n  \n  tree   : DiscrTree NormNumExt true := {}\n  \n  erased  : PHashSet Name := {}\n  deriving Inhabited", "start": [56, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.derive", "code": "def derive {\u03b1 : Q(Type u)} (e : Q($\u03b1)) (post := false) : MetaM (Result e) := do\n  if e.isNatLit then\n    let lit : Q(\u2115) := e\n    return .isNat (q(instAddMonoidWithOneNat) : Q(AddMonoidWithOne \u2115))\n      lit (q(IsNat.raw_refl $lit) : Expr)\n  profileitM Exception \"norm_num\" (\u2190 getOptions) do\n    let s \u2190 saveState\n    let normNums := normNumExt.getState (\u2190 getEnv)\n    let arr \u2190 normNums.tree.getMatch e\n    for ext in arr do\n      if (bif post then ext.post else ext.pre) && ! normNums.erased.contains ext.name then\n        try\n          let new \u2190 withReducibleAndInstances <| ext.eval e\n          trace[Tactic.norm_num] \"{ext.name}:\\n{e} ==> {new}\"\n          return new\n        catch err =>\n          trace[Tactic.norm_num] \"{e} failed: {err.toMessageData}\"\n          s.restore\n    throwError \"{e}: no norm_nums apply\"", "start": [78, 1], "end": [97, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveNat", "code": "def deriveNat {\u03b1 : Q(Type u)} (e : Q($\u03b1))\n    (_inst : Q(AddMonoidWithOne $\u03b1) := by with_reducible assumption) :\n    MetaM ((lit : Q(\u2115)) \u00d7 Q(IsNat $e $lit)) := do\n  let .isNat _ lit proof \u2190 derive e | failure\n  pure \u27e8lit, proof\u27e9", "start": [99, 1], "end": [105, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveInt", "code": "def deriveInt {\u03b1 : Q(Type u)} (e : Q($\u03b1))\n    (_inst : Q(Ring $\u03b1) := by with_reducible assumption) :\n    MetaM ((lit : Q(\u2124)) \u00d7 Q(IsInt $e $lit)) := do\n  let some \u27e8_, lit, proof\u27e9 := (\u2190 derive e).toInt | failure\n  pure \u27e8lit, proof\u27e9", "start": [107, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveRat", "code": "def deriveRat {\u03b1 : Q(Type u)} (e : Q($\u03b1))\n    (_inst : Q(DivisionRing $\u03b1) := by with_reducible assumption) :\n    MetaM (\u211a \u00d7 (n : Q(\u2124)) \u00d7 (d : Q(\u2115)) \u00d7 Q(IsRat $e $n $d)) := do\n  let some res := (\u2190 derive e).toRat' | failure\n  pure res", "start": [115, 1], "end": [122, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveBool", "code": "def deriveBool (p : Q(Prop)) : MetaM ((b : Bool) \u00d7 BoolResult p b) := do\n  let .isBool b prf \u2190 derive (\u03b1 := (q(Prop) : Q(Type))) p | failure\n  pure \u27e8b, prf\u27e9", "start": [124, 1], "end": [128, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveBoolOfIff", "code": "def deriveBoolOfIff (p p' : Q(Prop)) (hp : Q($p \u2194 $p')) :\n    MetaM ((b : Bool) \u00d7 BoolResult p' b) := do\n  let \u27e8b, pb\u27e9 \u2190 deriveBool p\n  match b with\n  | true  => return \u27e8true, q(Iff.mp $hp $pb)\u27e9\n  | false => return \u27e8false, q((Iff.not $hp).mp $pb)\u27e9", "start": [130, 1], "end": [137, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.eval", "code": "def eval (e : Expr) (post := false) : MetaM Simp.Result := do\n  if e.isExplicitNumber then return { expr := e }\n  let \u27e8_, _, e\u27e9 \u2190 inferTypeQ' e\n  (\u2190 derive e post).toSimpResult", "start": [139, 1], "end": [144, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.NormNums.eraseCore", "code": "def NormNums.eraseCore (d : NormNums) (declName : Name) : NormNums :=\n { d with erased := d.erased.insert declName }", "start": [146, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.NormNums.erase", "code": "def NormNums.erase [Monad m] [MonadError m] (d : NormNums) (declName : Name) : m NormNums := do\n  unless d.tree.values.any (\u00b7.name == declName) && ! d.erased.contains declName\n  do\n    throwError \"'{declName}' does not have [norm_num] attribute\"\n  return d.eraseCore declName", "start": [151, 1], "end": [161, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.tryNormNum?", "code": "def tryNormNum? (post := false) (e : Expr) : SimpM (Option Simp.Step) := do\n  try return some (.done (\u2190 eval e post))\n  catch _ => return none", "start": [189, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.discharge", "code": "partial def discharge (e : Expr) : SimpM (Option Expr) := do (\u2190 deriveSimp e).ofTrue", "start": [196, 3], "end": [197, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.methods", "code": "partial def methods : Simp.Methods :=\n    if useSimp then {\n      pre := fun e \u21a6 do\n        Simp.andThen (\u2190 Simp.preDefault e discharge) tryNormNum?\n      post := fun e \u21a6 do\n        Simp.andThen (\u2190 Simp.postDefault e discharge) (tryNormNum? (post := true))\n      discharge? := discharge\n    } else {\n      pre := fun e \u21a6 Simp.andThen (.visit { expr := e }) tryNormNum?\n      post := fun e \u21a6 Simp.andThen (.visit { expr := e }) (tryNormNum? (post := true))\n      discharge? := discharge\n    }", "start": [199, 3], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.deriveSimp", "code": "partial def deriveSimp (e : Expr) : MetaM Simp.Result :=\n    (\u00b7.1) <$> Simp.main e ctx (methods := methods)", "start": [213, 3], "end": [215, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.normNumAt", "code": "def normNumAt (g : MVarId) (ctx : Simp.Context) (fvarIdsToSimp : Array FVarId)\n    (simplifyTarget := true) (useSimp := true) :\n    MetaM (Option (Array FVarId \u00d7 MVarId)) := g.withContext do\n  g.checkNotAssigned `norm_num\n  let mut g := g\n  let mut toAssert := #[]\n  let mut replaced := #[]\n  for fvarId in fvarIdsToSimp do\n    let localDecl \u2190 fvarId.getDecl\n    let type \u2190 instantiateMVars localDecl.type\n    let ctx := { ctx with simpTheorems := ctx.simpTheorems.eraseTheorem (.fvar localDecl.fvarId) }\n    let r \u2190 deriveSimp ctx useSimp type\n    match r.proof? with\n    | some _ =>\n      let some (value, type) \u2190 applySimpResultToProp g (mkFVar fvarId) type r\n        | return none\n      toAssert := toAssert.push { userName := localDecl.userName, type, value }\n    | none =>\n      if r.expr.isConstOf ``False then\n        g.assign (\u2190 mkFalseElim (\u2190 g.getType) (mkFVar fvarId))\n        return none\n      g \u2190 g.replaceLocalDeclDefEq fvarId r.expr\n      replaced := replaced.push fvarId\n  if simplifyTarget then\n    let res \u2190 g.withContext do\n      let target \u2190 instantiateMVars (\u2190 g.getType)\n      let r \u2190 deriveSimp ctx useSimp target\n      let some proof \u2190 r.ofTrue\n        | some <$> applySimpResultToTarget g target r\n      g.assign proof\n      pure none\n    let some gNew := res | return none\n    g := gNew\n  let (fvarIdsNew, gNew) \u2190 g.assertHypotheses toAssert\n  let toClear := fvarIdsToSimp.filter fun fvarId \u21a6 !replaced.contains fvarId\n  let gNew \u2190 gNew.tryClearMany toClear\n  return some (fvarIdsNew, gNew)", "start": [219, 1], "end": [265, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.getSimpContext", "code": "def getSimpContext (args : Syntax) (simpOnly := false) :\n    TacticM Simp.Context := do\n  let simpTheorems \u2190\n    if simpOnly then simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) {} else getSimpTheorems\n  let mut { ctx, starArg } \u2190 elabSimpArgs args[0] (eraseLocal := false) (kind := .simp)\n    { simpTheorems := #[simpTheorems], congrTheorems := \u2190 getSimpCongrTheorems }\n  unless starArg do return ctx\n  let mut simpTheorems := ctx.simpTheorems\n  for h in \u2190 getPropHyps do\n    unless simpTheorems.isErased (.fvar h) do\n      simpTheorems \u2190 simpTheorems.addTheorem (.fvar h) (\u2190 h.getDecl).toExpr\n  pure { ctx with simpTheorems }", "start": [268, 1], "end": [280, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.elabNormNum", "code": "def elabNormNum (args : Syntax) (loc : Syntax)\n    (simpOnly := false) (useSimp := true) : TacticM Unit := do\n  let ctx \u2190 getSimpContext args (!useSimp || simpOnly)\n  let g \u2190 getMainGoal\n  let res \u2190 match expandOptLocation loc with\n  | .targets hyps simplifyTarget => normNumAt g ctx (\u2190 getFVarIds hyps) simplifyTarget useSimp\n  | .wildcard => normNumAt g ctx (\u2190 g.getNondepPropHyps) (simplifyTarget := true) useSimp\n  match res with\n  | none => replaceMainGoal []\n  | some (_, g) => replaceMainGoal [g]", "start": [283, 1], "end": [301, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.elabNormNum1Conv", "code": "@[tactic normNum1Conv] def elabNormNum1Conv : Tactic := fun _ \u21a6 withMainContext do\n  let ctx \u2190 getSimpContext mkNullNode true\n  Conv.applySimpResult (\u2190 deriveSimp ctx (\u2190 instantiateMVars (\u2190 Conv.getLhs)) (useSimp := false))", "start": [325, 1], "end": [328, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.elabNormNumConv", "code": "@[tactic normNumConv] def elabNormNumConv : Tactic := fun stx \u21a6 withMainContext do\n  let ctx \u2190 getSimpContext stx[2] !stx[1].isNone\n  Conv.applySimpResult (\u2190 deriveSimp ctx (\u2190 instantiateMVars (\u2190 Conv.getLhs)) (useSimp := true))", "start": [332, 1], "end": [335, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/HaveI.lean", "imports": ["lake-packages/std/Std/Tactic/HaveI.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Order/Field/Defs.lean", "imports": ["Mathlib/Algebra/Field/Defs.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearOrderedSemifield", "code": "class LinearOrderedSemifield (\u03b1 : Type*) extends LinearOrderedCommSemiring \u03b1, Semifield \u03b1", "start": [34, 1], "end": [35, 90], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField", "code": "class LinearOrderedField (\u03b1 : Type*) extends LinearOrderedCommRing \u03b1, Field \u03b1", "start": [38, 1], "end": [39, 78], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.toLinearOrderedSemifield", "code": "instance (priority := 100) LinearOrderedField.toLinearOrderedSemifield [LinearOrderedField \u03b1] :\n    LinearOrderedSemifield \u03b1 :=\n  { LinearOrderedRing.toLinearOrderedSemiring, \u2039LinearOrderedField \u03b1\u203a with }", "start": [43, 1], "end": [45, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Bounds/OrderIso.lean", "imports": ["Mathlib/Order/Hom/Set.lean", "Mathlib/Order/Bounds/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderIso.upperBounds_image", "code": "theorem upperBounds_image {s : Set \u03b1} : upperBounds (f '' s) = f '' upperBounds s", "start": [23, 1], "end": [27, 58], "kind": "commanddeclaration"}, {"full_name": "OrderIso.lowerBounds_image", "code": "theorem lowerBounds_image {s : Set \u03b1} : lowerBounds (f '' s) = f '' lowerBounds s", "start": [30, 1], "end": [31, 42], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isLUB_image", "code": "@[simp]\ntheorem isLUB_image {s : Set \u03b1} {x : \u03b2} : IsLUB (f '' s) x \u2194 IsLUB s (f.symm x)", "start": [35, 1], "end": [38, 67], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isLUB_image'", "code": "theorem isLUB_image' {s : Set \u03b1} {x : \u03b1} : IsLUB (f '' s) (f x) \u2194 IsLUB s x", "start": [41, 1], "end": [42, 39], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isGLB_image", "code": "@[simp]\ntheorem isGLB_image {s : Set \u03b1} {x : \u03b2} : IsGLB (f '' s) x \u2194 IsGLB s (f.symm x)", "start": [45, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isGLB_image'", "code": "theorem isGLB_image' {s : Set \u03b1} {x : \u03b1} : IsGLB (f '' s) (f x) \u2194 IsGLB s x", "start": [50, 1], "end": [51, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isLUB_preimage", "code": "@[simp]\ntheorem isLUB_preimage {s : Set \u03b2} {x : \u03b1} : IsLUB (f \u207b\u00b9' s) x \u2194 IsLUB s (f x)", "start": [54, 1], "end": [56, 55], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isLUB_preimage'", "code": "theorem isLUB_preimage' {s : Set \u03b2} {x : \u03b2} : IsLUB (f \u207b\u00b9' s) (f.symm x) \u2194 IsLUB s x", "start": [59, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isGLB_preimage", "code": "@[simp]\ntheorem isGLB_preimage {s : Set \u03b2} {x : \u03b1} : IsGLB (f \u207b\u00b9' s) x \u2194 IsGLB s (f x)", "start": [63, 1], "end": [65, 24], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isGLB_preimage'", "code": "theorem isGLB_preimage' {s : Set \u03b2} {x : \u03b2} : IsGLB (f \u207b\u00b9' s) (f.symm x) \u2194 IsGLB s x", "start": [68, 1], "end": [69, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Commute.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean"], "premises": [{"full_name": "add_div", "code": "theorem add_div (a b c : \u03b1) : (a + b) / c = a / c + b / c", "start": [29, 1], "end": [29, 98], "kind": "commanddeclaration"}, {"full_name": "div_add_div_same", "code": "@[field_simps]\ntheorem div_add_div_same (a b c : \u03b1) : a / c + b / c = (a + b) / c", "start": [32, 1], "end": [34, 23], "kind": "commanddeclaration"}, {"full_name": "same_add_div", "code": "theorem same_add_div (h : b \u2260 0) : (b + a) / b = 1 + a / b", "start": [37, 1], "end": [37, 92], "kind": "commanddeclaration"}, {"full_name": "div_add_same", "code": "theorem div_add_same (h : b \u2260 0) : (a + b) / b = a / b + 1", "start": [40, 1], "end": [40, 92], "kind": "commanddeclaration"}, {"full_name": "one_add_div", "code": "theorem one_add_div (h : b \u2260 0) : 1 + a / b = (b + a) / b", "start": [43, 1], "end": [44, 24], "kind": "commanddeclaration"}, {"full_name": "div_add_one", "code": "theorem div_add_one (h : b \u2260 0) : a / b + 1 = (a + b) / b", "start": [47, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "one_div_mul_add_mul_one_div_eq_one_div_add_one_div", "code": "theorem one_div_mul_add_mul_one_div_eq_one_div_add_one_div (ha : a \u2260 0) (hb : b \u2260 0) :\n    1 / a * (a + b) * (1 / b) = 1 / a + 1 / b", "start": [51, 1], "end": [54, 14], "kind": "commanddeclaration"}, {"full_name": "add_div_eq_mul_add_div", "code": "theorem add_div_eq_mul_add_div (a b : \u03b1) (hc : c \u2260 0) : a + b / c = (a * c + b) / c", "start": [57, 1], "end": [58, 73], "kind": "commanddeclaration"}, {"full_name": "add_div'", "code": "@[field_simps]\ntheorem add_div' (a b c : \u03b1) (hc : c \u2260 0) : b + a / c = (b * c + a) / c", "start": [61, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "div_add'", "code": "@[field_simps]\ntheorem div_add' (a b c : \u03b1) (hc : c \u2260 0) : a / c + b = (a + b * c) / c", "start": [66, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.div_add_div", "code": "protected theorem Commute.div_add_div (hbc : Commute b c) (hbd : Commute b d) (hb : b \u2260 0)\n    (hd : d \u2260 0) : a / b + c / d = (a * d + b * c) / (b * d)", "start": [71, 1], "end": [73, 83], "kind": "commanddeclaration"}, {"full_name": "Commute.one_div_add_one_div", "code": "protected theorem Commute.one_div_add_one_div (hab : Commute a b) (ha : a \u2260 0) (hb : b \u2260 0) :\n    1 / a + 1 / b = (a + b) / (a * b)", "start": [76, 1], "end": [78, 79], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_add_inv", "code": "protected theorem Commute.inv_add_inv (hab : Commute a b) (ha : a \u2260 0) (hb : b \u2260 0) :\n    a\u207b\u00b9 + b\u207b\u00b9 = (a + b) / (a * b)", "start": [81, 1], "end": [83, 69], "kind": "commanddeclaration"}, {"full_name": "one_div_neg_one_eq_neg_one", "code": "theorem one_div_neg_one_eq_neg_one : (1 : K) / -1 = -1", "start": [92, 1], "end": [94, 48], "kind": "commanddeclaration"}, {"full_name": "one_div_neg_eq_neg_one_div", "code": "theorem one_div_neg_eq_neg_one_div (a : K) : 1 / -a = -(1 / a)", "start": [97, 1], "end": [102, 45], "kind": "commanddeclaration"}, {"full_name": "div_neg_eq_neg_div", "code": "theorem div_neg_eq_neg_div (a b : K) : b / -a = -(b / a)", "start": [105, 1], "end": [110, 40], "kind": "commanddeclaration"}, {"full_name": "neg_div", "code": "theorem neg_div (a b : K) : -b / a = -(b / a)", "start": [113, 1], "end": [114, 63], "kind": "commanddeclaration"}, {"full_name": "neg_div'", "code": "@[field_simps]\ntheorem neg_div' (a b : K) : -(b / a) = -b / a", "start": [117, 1], "end": [118, 68], "kind": "commanddeclaration"}, {"full_name": "neg_div_neg_eq", "code": "theorem neg_div_neg_eq (a b : K) : -a / -b = a / b", "start": [121, 1], "end": [121, 99], "kind": "commanddeclaration"}, {"full_name": "neg_inv", "code": "theorem neg_inv : -a\u207b\u00b9 = (-a)\u207b\u00b9", "start": [124, 1], "end": [124, 94], "kind": "commanddeclaration"}, {"full_name": "div_neg", "code": "theorem div_neg (a : K) : a / -b = -(a / b)", "start": [127, 1], "end": [127, 76], "kind": "commanddeclaration"}, {"full_name": "inv_neg", "code": "theorem inv_neg : (-a)\u207b\u00b9 = -a\u207b\u00b9", "start": [130, 1], "end": [130, 51], "kind": "commanddeclaration"}, {"full_name": "inv_neg_one", "code": "theorem inv_neg_one : (-1 : K)\u207b\u00b9 = -1", "start": [133, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "div_neg_self", "code": "@[simp]\ntheorem div_neg_self {a : K} (h : a \u2260 0) : a / -a = -1", "start": [141, 1], "end": [142, 97], "kind": "commanddeclaration"}, {"full_name": "neg_div_self", "code": "@[simp]\ntheorem neg_div_self {a : K} (h : a \u2260 0) : -a / a = -1", "start": [145, 1], "end": [146, 86], "kind": "commanddeclaration"}, {"full_name": "div_sub_div_same", "code": "theorem div_sub_div_same (a b c : K) : a / c - b / c = (a - b) / c", "start": [149, 1], "end": [150, 67], "kind": "commanddeclaration"}, {"full_name": "same_sub_div", "code": "theorem same_sub_div {a b : K} (h : b \u2260 0) : (b - a) / b = 1 - a / b", "start": [153, 1], "end": [154, 71], "kind": "commanddeclaration"}, {"full_name": "one_sub_div", "code": "theorem one_sub_div {a b : K} (h : b \u2260 0) : 1 - a / b = (b - a) / b", "start": [157, 1], "end": [158, 24], "kind": "commanddeclaration"}, {"full_name": "div_sub_same", "code": "theorem div_sub_same {a b : K} (h : b \u2260 0) : (a - b) / b = a / b - 1", "start": [161, 1], "end": [162, 71], "kind": "commanddeclaration"}, {"full_name": "div_sub_one", "code": "theorem div_sub_one {a b : K} (h : b \u2260 0) : a / b - 1 = (a - b) / b", "start": [165, 1], "end": [166, 24], "kind": "commanddeclaration"}, {"full_name": "sub_div", "code": "theorem sub_div (a b c : K) : (a - b) / c = a / c - b / c", "start": [169, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "inv_sub_inv'", "code": "theorem inv_sub_inv' {a b : K} (ha : a \u2260 0) (hb : b \u2260 0) : a\u207b\u00b9 - b\u207b\u00b9 = a\u207b\u00b9 * (b - a) * b\u207b\u00b9", "start": [173, 1], "end": [175, 78], "kind": "commanddeclaration"}, {"full_name": "one_div_mul_sub_mul_one_div_eq_one_div_add_one_div", "code": "theorem one_div_mul_sub_mul_one_div_eq_one_div_add_one_div (ha : a \u2260 0) (hb : b \u2260 0) :\n    1 / a * (b - a) * (1 / b) = 1 / a - 1 / b", "start": [178, 1], "end": [181, 47], "kind": "commanddeclaration"}, {"full_name": "DivisionRing.isDomain", "code": "instance (priority := 100) DivisionRing.isDomain : IsDomain K :=\n  NoZeroDivisors.to_isDomain _", "start": [185, 1], "end": [186, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.div_sub_div", "code": "protected theorem Commute.div_sub_div (hbc : Commute b c) (hbd : Commute b d) (hb : b \u2260 0)\n    (hd : d \u2260 0) : a / b - c / d = (a * d - b * c) / (b * d)", "start": [189, 1], "end": [191, 92], "kind": "commanddeclaration"}, {"full_name": "Commute.inv_sub_inv", "code": "protected theorem Commute.inv_sub_inv (hab : Commute a b) (ha : a \u2260 0) (hb : b \u2260 0) :\n    a\u207b\u00b9 - b\u207b\u00b9 = (b - a) / (a * b)", "start": [194, 1], "end": [196, 92], "kind": "commanddeclaration"}, {"full_name": "div_add_div", "code": "theorem div_add_div (a : \u03b1) (c : \u03b1) (hb : b \u2260 0) (hd : d \u2260 0) :\n    a / b + c / d = (a * d + b * c) / (b * d)", "start": [205, 1], "end": [207, 56], "kind": "commanddeclaration"}, {"full_name": "one_div_add_one_div", "code": "theorem one_div_add_one_div (ha : a \u2260 0) (hb : b \u2260 0) : 1 / a + 1 / b = (a + b) / (a * b)", "start": [210, 1], "end": [211, 46], "kind": "commanddeclaration"}, {"full_name": "inv_add_inv", "code": "theorem inv_add_inv (ha : a \u2260 0) (hb : b \u2260 0) : a\u207b\u00b9 + b\u207b\u00b9 = (a + b) / (a * b)", "start": [214, 1], "end": [215, 38], "kind": "commanddeclaration"}, {"full_name": "div_sub_div", "code": "@[field_simps]\ntheorem div_sub_div (a : K) {b : K} (c : K) {d : K} (hb : b \u2260 0) (hd : d \u2260 0) :\n    a / b - c / d = (a * d - b * c) / (b * d)", "start": [226, 1], "end": [229, 56], "kind": "commanddeclaration"}, {"full_name": "inv_sub_inv", "code": "theorem inv_sub_inv {a b : K} (ha : a \u2260 0) (hb : b \u2260 0) : a\u207b\u00b9 - b\u207b\u00b9 = (b - a) / (a * b)", "start": [232, 1], "end": [233, 79], "kind": "commanddeclaration"}, {"full_name": "sub_div'", "code": "@[field_simps]\ntheorem sub_div' (a b c : K) (hc : c \u2260 0) : b - a / c = (b * c - a) / c", "start": [236, 1], "end": [238, 45], "kind": "commanddeclaration"}, {"full_name": "div_sub'", "code": "@[field_simps]\ntheorem div_sub' (a b c : K) (hc : c \u2260 0) : a / c - b = (a - c * b) / c", "start": [241, 1], "end": [243, 45], "kind": "commanddeclaration"}, {"full_name": "Field.isDomain", "code": "instance (priority := 100) Field.isDomain : IsDomain K :=\n  { DivisionRing.isDomain with }", "start": [247, 1], "end": [248, 33], "kind": "commanddeclaration"}, {"full_name": "RingHom.injective", "code": "protected theorem injective [DivisionRing \u03b1] [Semiring \u03b2] [Nontrivial \u03b2] (f : \u03b1 \u2192+* \u03b2) :\n    Injective f", "start": [255, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "divisionRingOfIsUnitOrEqZero", "code": "noncomputable def divisionRingOfIsUnitOrEqZero [hR : Ring R] (h : \u2200 a : R, IsUnit a \u2228 a = 0) :\n    DivisionRing R :=\n  { groupWithZeroOfIsUnitOrEqZero h, hR with }", "start": [266, 1], "end": [269, 47], "kind": "commanddeclaration"}, {"full_name": "fieldOfIsUnitOrEqZero", "code": "@[reducible]\nnoncomputable def fieldOfIsUnitOrEqZero [hR : CommRing R] (h : \u2200 a : R, IsUnit a \u2228 a = 0) :\n    Field R :=\n  { groupWithZeroOfIsUnitOrEqZero h, hR with }", "start": [272, 1], "end": [277, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divisionSemiring", "code": "@[reducible]\nprotected def Function.Injective.divisionSemiring [DivisionSemiring \u03b2] [Zero \u03b1] [Mul \u03b1] [Add \u03b1]\n    [One \u03b1] [Inv \u03b1] [Div \u03b1] [SMul \u2115 \u03b1] [Pow \u03b1 \u2115] [Pow \u03b1 \u2124] [NatCast \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : DivisionSemiring \u03b1 :=\n  { hf.groupWithZero f zero one mul inv div npow zpow,\n    hf.semiring f zero one add mul nsmul npow nat_cast with }", "start": [283, 1], "end": [293, 62], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divisionRing", "code": "@[reducible]\nprotected def Function.Injective.divisionRing [DivisionRing K] {K'} [Zero K'] [One K'] [Add K']\n    [Mul K'] [Neg K'] [Sub K'] [Inv K'] [Div K'] [SMul \u2115 K'] [SMul \u2124 K'] [SMul \u211a K']\n    [Pow K' \u2115] [Pow K' \u2124] [NatCast K'] [IntCast K'] [RatCast K'] (f : K' \u2192 K) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (qsmul : \u2200 (x) (n : \u211a), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) (rat_cast : \u2200 n : \u211a, f n = n) :\n    DivisionRing K' :=\n  { hf.groupWithZero f zero one mul inv div npow zpow,\n    hf.ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with\n    ratCast := Rat.cast,\n    ratCast_mk := fun a b h1 h2 \u21a6\n      hf\n        (by\n          erw [rat_cast, mul, inv, int_cast, nat_cast]\n          exact DivisionRing.ratCast_mk a b h1 h2),\n    qsmul := (\u00b7 \u2022 \u00b7), qsmul_eq_mul' := fun a x \u21a6 hf (by erw [qsmul, mul, Rat.smul_def, rat_cast]) }", "start": [296, 1], "end": [318, 100], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.semifield", "code": "@[reducible]\nprotected def Function.Injective.semifield [Semifield \u03b2] [Zero \u03b1] [Mul \u03b1] [Add \u03b1] [One \u03b1] [Inv \u03b1]\n    [Div \u03b1] [SMul \u2115 \u03b1] [Pow \u03b1 \u2115] [Pow \u03b1 \u2124] [NatCast \u03b1] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : Semifield \u03b1 :=\n  { hf.commGroupWithZero f zero one mul inv div npow zpow,\n    hf.commSemiring f zero one add mul nsmul npow nat_cast with }", "start": [322, 1], "end": [332, 66], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.field", "code": "@[reducible]\nprotected def Function.Injective.field [Field K] {K'} [Zero K'] [Mul K'] [Add K'] [Neg K'] [Sub K']\n    [One K'] [Inv K'] [Div K'] [SMul \u2115 K'] [SMul \u2124 K'] [SMul \u211a K'] [Pow K' \u2115] [Pow K' \u2124]\n    [NatCast K'] [IntCast K'] [RatCast K'] (f : K' \u2192 K) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (qsmul : \u2200 (x) (n : \u211a), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) (rat_cast : \u2200 n : \u211a, f n = n) :\n    Field K' :=\n  { hf.commGroupWithZero f zero one mul inv div npow zpow,\n    hf.commRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with\n    ratCast := Rat.cast,\n    ratCast_mk := fun a b h1 h2 \u21a6\n      hf\n        (by\n          erw [rat_cast, mul, inv, int_cast, nat_cast]\n          exact DivisionRing.ratCast_mk a b h1 h2),\n    qsmul := (\u00b7 \u2022 \u00b7), qsmul_eq_mul' := fun a x \u21a6 hf (by erw [qsmul, mul, Rat.smul_def, rat_cast]) }", "start": [335, 1], "end": [356, 100], "kind": "commanddeclaration"}, {"full_name": "toDual_rat_cast", "code": "@[simp]\ntheorem toDual_rat_cast [RatCast \u03b1] (n : \u211a) : toDual (n : \u03b1) = n", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_rat_cast", "code": "@[simp]\ntheorem ofDual_rat_cast [RatCast \u03b1] (n : \u211a) : (ofDual n : \u03b1) = n", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "toLex_rat_cast", "code": "@[simp]\ntheorem toLex_rat_cast [RatCast \u03b1] (n : \u211a) : toLex (n : \u03b1) = n", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "ofLex_rat_cast", "code": "@[simp]\ntheorem ofLex_rat_cast [RatCast \u03b1] (n : \u211a) : (ofLex n : \u03b1) = n", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/MinMax.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.argAux", "code": "def argAux (a : Option \u03b1) (b : \u03b1) : Option \u03b1 :=\n  Option.casesOn a (some b) fun c => if r b c then some b else some c", "start": [36, 1], "end": [38, 70], "kind": "commanddeclaration"}, {"full_name": "List.foldl_argAux_eq_none", "code": "@[simp]\ntheorem foldl_argAux_eq_none : l.foldl (argAux r) o = none \u2194 l = [] \u2227 o = none", "start": [41, 1], "end": [44, 80], "kind": "commanddeclaration"}, {"full_name": "List.foldl_argAux_mem", "code": "private theorem foldl_argAux_mem (l) : \u2200 a m : \u03b1, m \u2208 foldl (argAux r) (some a) l \u2192 m \u2208 a :: l", "start": [47, 1], "end": [62, 73], "kind": "commanddeclaration"}, {"full_name": "List.argAux_self", "code": "@[simp]\ntheorem argAux_self (hr\u2080 : Irreflexive r) (a : \u03b1) : argAux r (some a) a = a", "start": [64, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "List.not_of_mem_foldl_argAux", "code": "theorem not_of_mem_foldl_argAux (hr\u2080 : Irreflexive r) (hr\u2081 : Transitive r) :\n    \u2200 {a m : \u03b1} {o : Option \u03b1}, a \u2208 l \u2192 m \u2208 foldl (argAux r) o l \u2192 \u00acr a m", "start": [69, 1], "end": [86, 13], "kind": "commanddeclaration"}, {"full_name": "List.argmax", "code": "def argmax (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : Option \u03b1 :=\n  l.foldl (argAux fun b c => f c < f b) none", "start": [95, 1], "end": [99, 45], "kind": "commanddeclaration"}, {"full_name": "List.argmin", "code": "def argmin (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) :=\n  l.foldl (argAux fun b c => f b < f c) none", "start": [102, 1], "end": [106, 45], "kind": "commanddeclaration"}, {"full_name": "List.argmax_nil", "code": "@[simp]\ntheorem argmax_nil (f : \u03b1 \u2192 \u03b2) : argmax f [] = none", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "List.argmin_nil", "code": "@[simp]\ntheorem argmin_nil (f : \u03b1 \u2192 \u03b2) : argmin f [] = none", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "List.argmax_singleton", "code": "@[simp]\ntheorem argmax_singleton {f : \u03b1 \u2192 \u03b2} {a : \u03b1} : argmax f [a] = a", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "List.argmin_singleton", "code": "@[simp]\ntheorem argmin_singleton {f : \u03b1 \u2192 \u03b2} {a : \u03b1} : argmin f [a] = a", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "List.not_lt_of_mem_argmax", "code": "theorem not_lt_of_mem_argmax : a \u2208 l \u2192 m \u2208 argmax f l \u2192 \u00acf m < f a", "start": [129, 1], "end": [131, 55], "kind": "commanddeclaration"}, {"full_name": "List.not_lt_of_mem_argmin", "code": "theorem not_lt_of_mem_argmin : a \u2208 l \u2192 m \u2208 argmin f l \u2192 \u00acf a < f m", "start": [134, 1], "end": [136, 55], "kind": "commanddeclaration"}, {"full_name": "List.argmax_concat", "code": "theorem argmax_concat (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1) :\n    argmax f (l ++ [a]) =\n      Option.casesOn (argmax f l) (some a) fun c => if f c < f a then some a else some c", "start": [139, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "List.argmin_concat", "code": "theorem argmin_concat (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1) :\n    argmin f (l ++ [a]) =\n      Option.casesOn (argmin f l) (some a) fun c => if f a < f c then some a else some c", "start": [145, 1], "end": [148, 33], "kind": "commanddeclaration"}, {"full_name": "List.argmax_mem", "code": "theorem argmax_mem : \u2200 {l : List \u03b1} {m : \u03b1}, m \u2208 argmax f l \u2192 m \u2208 l", "start": [151, 1], "end": [153, 78], "kind": "commanddeclaration"}, {"full_name": "List.argmin_mem", "code": "theorem argmin_mem : \u2200 {l : List \u03b1} {m : \u03b1}, m \u2208 argmin f l \u2192 m \u2208 l", "start": [156, 1], "end": [157, 26], "kind": "commanddeclaration"}, {"full_name": "List.argmax_eq_none", "code": "@[simp]\ntheorem argmax_eq_none : l.argmax f = none \u2194 l = []", "start": [160, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "List.argmin_eq_none", "code": "@[simp]\ntheorem argmin_eq_none : l.argmin f = none \u2194 l = []", "start": [164, 1], "end": [166, 32], "kind": "commanddeclaration"}, {"full_name": "List.le_of_mem_argmax", "code": "theorem le_of_mem_argmax : a \u2208 l \u2192 m \u2208 argmax f l \u2192 f a \u2264 f m", "start": [175, 1], "end": [176, 45], "kind": "commanddeclaration"}, {"full_name": "List.le_of_mem_argmin", "code": "theorem le_of_mem_argmin : a \u2208 l \u2192 m \u2208 argmin f l \u2192 f m \u2264 f a", "start": [179, 1], "end": [180, 36], "kind": "commanddeclaration"}, {"full_name": "List.argmax_cons", "code": "theorem argmax_cons (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1) :\n    argmax f (a :: l) =\n      Option.casesOn (argmax f l) (some a) fun c => if f a < f c then some c else some a", "start": [183, 1], "end": [195, 51], "kind": "commanddeclaration"}, {"full_name": "List.argmin_cons", "code": "theorem argmin_cons (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1) :\n    argmin f (a :: l) =\n      Option.casesOn (argmin f l) (some a) fun c => if f c < f a then some c else some a", "start": [198, 1], "end": [201, 29], "kind": "commanddeclaration"}, {"full_name": "List.index_of_argmax", "code": "theorem index_of_argmax :\n    \u2200 {l : List \u03b1} {m : \u03b1}, m \u2208 argmax f l \u2192 \u2200 {a}, a \u2208 l \u2192 f m \u2264 f a \u2192 l.indexOf m \u2264 l.indexOf a", "start": [206, 1], "end": [224, 26], "kind": "commanddeclaration"}, {"full_name": "List.index_of_argmin", "code": "theorem index_of_argmin :\n    \u2200 {l : List \u03b1} {m : \u03b1}, m \u2208 argmin f l \u2192 \u2200 {a}, a \u2208 l \u2192 f a \u2264 f m \u2192 l.indexOf m \u2264 l.indexOf a", "start": [227, 1], "end": [229, 31], "kind": "commanddeclaration"}, {"full_name": "List.mem_argmax_iff", "code": "theorem mem_argmax_iff :\n    m \u2208 argmax f l \u2194\n      m \u2208 l \u2227 (\u2200 a \u2208 l, f a \u2264 f m) \u2227 \u2200 a \u2208 l, f m \u2264 f a \u2192 l.indexOf m \u2264 l.indexOf a", "start": [232, 1], "end": [243, 73], "kind": "commanddeclaration"}, {"full_name": "List.argmax_eq_some_iff", "code": "theorem argmax_eq_some_iff :\n    argmax f l = some m \u2194\n      m \u2208 l \u2227 (\u2200 a \u2208 l, f a \u2264 f m) \u2227 \u2200 a \u2208 l, f m \u2264 f a \u2192 l.indexOf m \u2264 l.indexOf a", "start": [246, 1], "end": [249, 17], "kind": "commanddeclaration"}, {"full_name": "List.mem_argmin_iff", "code": "theorem mem_argmin_iff :\n    m \u2208 argmin f l \u2194\n      m \u2208 l \u2227 (\u2200 a \u2208 l, f m \u2264 f a) \u2227 \u2200 a \u2208 l, f a \u2264 f m \u2192 l.indexOf m \u2264 l.indexOf a", "start": [252, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "List.argmin_eq_some_iff", "code": "theorem argmin_eq_some_iff :\n    argmin f l = some m \u2194\n      m \u2208 l \u2227 (\u2200 a \u2208 l, f m \u2264 f a) \u2227 \u2200 a \u2208 l, f a \u2264 f m \u2192 l.indexOf m \u2264 l.indexOf a", "start": [258, 1], "end": [261, 17], "kind": "commanddeclaration"}, {"full_name": "List.maximum", "code": "def maximum (l : List \u03b1) : WithBot \u03b1 :=\n  argmax id l", "start": [272, 1], "end": [275, 14], "kind": "commanddeclaration"}, {"full_name": "List.minimum", "code": "def minimum (l : List \u03b1) : WithTop \u03b1 :=\n  argmin id l", "start": [278, 1], "end": [281, 14], "kind": "commanddeclaration"}, {"full_name": "List.maximum_nil", "code": "@[simp]\ntheorem maximum_nil : maximum ([] : List \u03b1) = \u22a5", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "List.minimum_nil", "code": "@[simp]\ntheorem minimum_nil : minimum ([] : List \u03b1) = \u22a4", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "List.maximum_singleton", "code": "@[simp]\ntheorem maximum_singleton (a : \u03b1) : maximum [a] = a", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "List.minimum_singleton", "code": "@[simp]\ntheorem minimum_singleton (a : \u03b1) : minimum [a] = a", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "List.maximum_mem", "code": "theorem maximum_mem {l : List \u03b1} {m : \u03b1} : (maximum l : WithTop \u03b1) = m \u2192 m \u2208 l", "start": [304, 1], "end": [305, 13], "kind": "commanddeclaration"}, {"full_name": "List.minimum_mem", "code": "theorem minimum_mem {l : List \u03b1} {m : \u03b1} : (minimum l : WithBot \u03b1) = m \u2192 m \u2208 l", "start": [308, 1], "end": [309, 13], "kind": "commanddeclaration"}, {"full_name": "List.maximum_eq_none", "code": "@[simp]\ntheorem maximum_eq_none {l : List \u03b1} : l.maximum = none \u2194 l = []", "start": [312, 1], "end": [314, 17], "kind": "commanddeclaration"}, {"full_name": "List.minimum_eq_none", "code": "@[simp]\ntheorem minimum_eq_none {l : List \u03b1} : l.minimum = none \u2194 l = []", "start": [317, 1], "end": [319, 17], "kind": "commanddeclaration"}, {"full_name": "List.not_lt_maximum_of_mem", "code": "theorem not_lt_maximum_of_mem : a \u2208 l \u2192 (maximum l : WithBot \u03b1) = m \u2192 \u00acm < a", "start": [322, 1], "end": [323, 23], "kind": "commanddeclaration"}, {"full_name": "List.minimum_not_lt_of_mem", "code": "theorem minimum_not_lt_of_mem : a \u2208 l \u2192 (minimum l : WithTop \u03b1) = m \u2192 \u00aca < m", "start": [326, 1], "end": [327, 23], "kind": "commanddeclaration"}, {"full_name": "List.not_lt_maximum_of_mem'", "code": "theorem not_lt_maximum_of_mem' (ha : a \u2208 l) : \u00acmaximum l < (a : WithBot \u03b1)", "start": [330, 1], "end": [333, 94], "kind": "commanddeclaration"}, {"full_name": "List.not_lt_minimum_of_mem'", "code": "theorem not_lt_minimum_of_mem' (ha : a \u2208 l) : \u00ac(a : WithTop \u03b1) < minimum l", "start": [336, 1], "end": [337, 41], "kind": "commanddeclaration"}, {"full_name": "List.maximum_concat", "code": "theorem maximum_concat (a : \u03b1) (l : List \u03b1) : maximum (l ++ [a]) = max (maximum l) a", "start": [346, 1], "end": [350, 63], "kind": "commanddeclaration"}, {"full_name": "List.le_maximum_of_mem", "code": "theorem le_maximum_of_mem : a \u2208 l \u2192 (maximum l : WithBot \u03b1) = m \u2192 a \u2264 m", "start": [353, 1], "end": [354, 19], "kind": "commanddeclaration"}, {"full_name": "List.minimum_le_of_mem", "code": "theorem minimum_le_of_mem : a \u2208 l \u2192 (minimum l : WithTop \u03b1) = m \u2192 m \u2264 a", "start": [357, 1], "end": [358, 19], "kind": "commanddeclaration"}, {"full_name": "List.le_maximum_of_mem'", "code": "theorem le_maximum_of_mem' (ha : a \u2208 l) : (a : WithBot \u03b1) \u2264 maximum l", "start": [361, 1], "end": [362, 44], "kind": "commanddeclaration"}, {"full_name": "List.minimum_le_of_mem'", "code": "theorem minimum_le_of_mem' (ha : a \u2208 l) : minimum l \u2264 (a : WithTop \u03b1)", "start": [365, 1], "end": [366, 35], "kind": "commanddeclaration"}, {"full_name": "List.minimum_concat", "code": "theorem minimum_concat (a : \u03b1) (l : List \u03b1) : minimum (l ++ [a]) = min (minimum l) a", "start": [369, 1], "end": [370, 28], "kind": "commanddeclaration"}, {"full_name": "List.maximum_cons", "code": "theorem maximum_cons (a : \u03b1) (l : List \u03b1) : maximum (a :: l) = max \u2191a (maximum l)", "start": [373, 1], "end": [375, 70], "kind": "commanddeclaration"}, {"full_name": "List.minimum_cons", "code": "theorem minimum_cons (a : \u03b1) (l : List \u03b1) : minimum (a :: l) = min \u2191a (minimum l)", "start": [378, 1], "end": [379, 26], "kind": "commanddeclaration"}, {"full_name": "List.maximum_le_of_forall_le", "code": "theorem maximum_le_of_forall_le {b : WithBot \u03b1} (h : \u2200 a \u2208 l, a \u2264 b) : l.maximum \u2264 b", "start": [382, 1], "end": [387, 71], "kind": "commanddeclaration"}, {"full_name": "List.le_minimum_of_forall_le", "code": "theorem le_minimum_of_forall_le {b : WithTop \u03b1} (h : \u2200 a \u2208 l, b \u2264 a) : b \u2264 l.minimum", "start": [389, 1], "end": [390, 38], "kind": "commanddeclaration"}, {"full_name": "List.maximum_eq_coe_iff", "code": "theorem maximum_eq_coe_iff : maximum l = m \u2194 m \u2208 l \u2227 \u2200 a \u2208 l, a \u2264 m", "start": [392, 1], "end": [396, 40], "kind": "commanddeclaration"}, {"full_name": "List.minimum_eq_coe_iff", "code": "theorem minimum_eq_coe_iff : minimum l = m \u2194 m \u2208 l \u2227 \u2200 a \u2208 l, m \u2264 a", "start": [399, 1], "end": [400, 32], "kind": "commanddeclaration"}, {"full_name": "List.coe_le_maximum_iff", "code": "theorem coe_le_maximum_iff : a \u2264 l.maximum \u2194 \u2203 b, b \u2208 l \u2227 a \u2264 b", "start": [403, 1], "end": [407, 28], "kind": "commanddeclaration"}, {"full_name": "List.minimum_le_coe_iff", "code": "theorem minimum_le_coe_iff : l.minimum \u2264 a \u2194 \u2203 b, b \u2208 l \u2227 b \u2264 a", "start": [409, 1], "end": [410, 32], "kind": "commanddeclaration"}, {"full_name": "List.maximum_ne_bot_of_ne_nil", "code": "theorem maximum_ne_bot_of_ne_nil (h : l \u2260 []) : l.maximum \u2260 \u22a5", "start": [412, 1], "end": [413, 56], "kind": "commanddeclaration"}, {"full_name": "List.minimum_ne_top_of_ne_nil", "code": "theorem minimum_ne_top_of_ne_nil (h : l \u2260 []) : l.minimum \u2260 \u22a4", "start": [415, 1], "end": [416, 38], "kind": "commanddeclaration"}, {"full_name": "List.maximum_ne_bot_of_length_pos", "code": "theorem maximum_ne_bot_of_length_pos (h : 0 < l.length) : l.maximum \u2260 \u22a5", "start": [418, 1], "end": [419, 56], "kind": "commanddeclaration"}, {"full_name": "List.minimum_ne_top_of_length_pos", "code": "theorem minimum_ne_top_of_length_pos (h : 0 < l.length) : l.minimum \u2260 \u22a4", "start": [421, 1], "end": [422, 44], "kind": "commanddeclaration"}, {"full_name": "List.maximum_of_length_pos", "code": "def maximum_of_length_pos (h : 0 < l.length) : \u03b1 :=\n  WithBot.unbot l.maximum (maximum_ne_bot_of_length_pos h)", "start": [424, 1], "end": [426, 59], "kind": "commanddeclaration"}, {"full_name": "List.minimum_of_length_pos", "code": "def minimum_of_length_pos (h : 0 < l.length) : \u03b1 :=\n  maximum_of_length_pos (\u03b1 := \u03b1\u1d52\u1d48) h", "start": [428, 1], "end": [430, 37], "kind": "commanddeclaration"}, {"full_name": "List.coe_maximum_of_length_pos", "code": "@[simp]\nlemma coe_maximum_of_length_pos (h : 0 < l.length) :\n    (l.maximum_of_length_pos h : \u03b1) = l.maximum :=\n  WithBot.coe_unbot _ _", "start": [432, 1], "end": [435, 24], "kind": "mathlibtacticlemma"}, {"full_name": "List.coe_minimum_of_length_pos", "code": "@[simp]\nlemma coe_minimum_of_length_pos (h : 0 < l.length) :\n    (l.minimum_of_length_pos h : \u03b1) = l.minimum :=\n  WithTop.coe_untop _ _", "start": [437, 1], "end": [440, 24], "kind": "mathlibtacticlemma"}, {"full_name": "List.le_maximum_of_length_pos_iff", "code": "@[simp]\ntheorem le_maximum_of_length_pos_iff (h : 0 < l.length) :\n    b \u2264 maximum_of_length_pos h \u2194 b \u2264 l.maximum", "start": [442, 1], "end": [445, 25], "kind": "commanddeclaration"}, {"full_name": "List.minimum_of_length_pos_le_iff", "code": "@[simp]\ntheorem minimum_of_length_pos_le_iff (h : 0 < l.length) :\n    minimum_of_length_pos h \u2264 b \u2194 l.minimum \u2264 b", "start": [447, 1], "end": [450, 44], "kind": "commanddeclaration"}, {"full_name": "List.le_maximum_of_length_pos_of_mem", "code": "theorem le_maximum_of_length_pos_of_mem (h : a \u2208 l) (w : 0 < l.length) :\n    a \u2264 l.maximum_of_length_pos w", "start": [452, 1], "end": [455, 29], "kind": "commanddeclaration"}, {"full_name": "List.minimum_of_length_pos_le_of_mem", "code": "theorem minimum_of_length_pos_le_of_mem (h : a \u2208 l) (w : 0 < l.length) :\n    l.minimum_of_length_pos w \u2264 a", "start": [457, 1], "end": [459, 49], "kind": "commanddeclaration"}, {"full_name": "List.getElem_le_maximum_of_length_pos", "code": "theorem getElem_le_maximum_of_length_pos (w : i < l.length) (h := (Nat.zero_lt_of_lt w)) :\n    l[i] \u2264 l.maximum_of_length_pos h", "start": [461, 1], "end": [464, 22], "kind": "commanddeclaration"}, {"full_name": "List.minimum_of_length_pos_le_getElem", "code": "theorem minimum_of_length_pos_le_getElem (w : i < l.length) (h := (Nat.zero_lt_of_lt w)) :\n    l.minimum_of_length_pos h \u2264 l[i]", "start": [466, 1], "end": [468, 48], "kind": "commanddeclaration"}, {"full_name": "List.foldr_max_of_ne_nil", "code": "@[simp]\ntheorem foldr_max_of_ne_nil (h : l \u2260 []) : \u2191(l.foldr max \u22a5) = l.maximum", "start": [482, 1], "end": [489, 18], "kind": "commanddeclaration"}, {"full_name": "List.max_le_of_forall_le", "code": "theorem max_le_of_forall_le (l : List \u03b1) (a : \u03b1) (h : \u2200 x \u2208 l, x \u2264 a) : l.foldr max \u22a5 \u2264 a", "start": [492, 1], "end": [495, 85], "kind": "commanddeclaration"}, {"full_name": "List.le_max_of_le", "code": "theorem le_max_of_le {l : List \u03b1} {a x : \u03b1} (hx : x \u2208 l) (h : a \u2264 x) : a \u2264 l.foldr max \u22a5", "start": [498, 1], "end": [504, 52], "kind": "commanddeclaration"}, {"full_name": "List.foldr_min_of_ne_nil", "code": "@[simp]\ntheorem foldr_min_of_ne_nil (h : l \u2260 []) : \u2191(l.foldr min \u22a4) = l.minimum", "start": [513, 1], "end": [515, 35], "kind": "commanddeclaration"}, {"full_name": "List.le_min_of_forall_le", "code": "theorem le_min_of_forall_le (l : List \u03b1) (a : \u03b1) (h : \u2200 x \u2208 l, a \u2264 x) : a \u2264 l.foldr min \u22a4", "start": [518, 1], "end": [519, 37], "kind": "commanddeclaration"}, {"full_name": "List.min_le_of_le", "code": "theorem min_le_of_le (l : List \u03b1) (a : \u03b1) {x : \u03b1} (hx : x \u2208 l) (h : x \u2264 a) : l.foldr min \u22a4 \u2264 a", "start": [522, 1], "end": [523, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Image.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Finset/Basic.lean", "Mathlib/Algebra/Hom/Embedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.map", "code": "def map (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) : Finset \u03b2 :=\n  \u27e8s.1.map f, s.2.map f.2\u27e9", "start": [49, 1], "end": [52, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.map_val", "code": "@[simp]\ntheorem map_val (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) : (map f s).1 = s.1.map f", "start": [55, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.map_empty", "code": "@[simp]\ntheorem map_empty (f : \u03b1 \u21aa \u03b2) : (\u2205 : Finset \u03b1).map f = \u2205", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_map", "code": "@[simp]\ntheorem mem_map {b : \u03b2} : b \u2208 s.map f \u2194 \u2203 a \u2208 s, f a = b", "start": [67, 1], "end": [69, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_map_equiv", "code": "@[simp 1100]\ntheorem mem_map_equiv {f : \u03b1 \u2243 \u03b2} {b : \u03b2} : b \u2208 s.map f.toEmbedding \u2194 f.symm b \u2208 s", "start": [73, 1], "end": [79, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_map'", "code": "@[simp 1100, nolint simpNF]\ntheorem mem_map' (f : \u03b1 \u21aa \u03b2) {a} {s : Finset \u03b1} : f a \u2208 s.map f \u2194 a \u2208 s", "start": [85, 1], "end": [87, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_map_of_mem", "code": "theorem mem_map_of_mem (f : \u03b1 \u21aa \u03b2) {a} {s : Finset \u03b1} : a \u2208 s \u2192 f a \u2208 s.map f", "start": [90, 1], "end": [91, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_mem_map", "code": "theorem forall_mem_map {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1} {p : \u2200 a, a \u2208 s.map f \u2192 Prop} :\n    (\u2200 y (H : y \u2208 s.map f), p y H) \u2194 \u2200 x (H : x \u2208 s), p (f x) (mem_map_of_mem _ H)", "start": [94, 1], "end": [99, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.apply_coe_mem_map", "code": "theorem apply_coe_mem_map (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) (x : s) : f x \u2208 s.map f", "start": [102, 1], "end": [103, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) : (s.map f : Set \u03b2) = f '' s", "start": [106, 1], "end": [108, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_map_subset_range", "code": "theorem coe_map_subset_range (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) : (s.map f : Set \u03b2) \u2286 Set.range f", "start": [111, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.map_perm", "code": "theorem map_perm {\u03c3 : Equiv.Perm \u03b1} (hs : { a | \u03c3 a \u2260 a } \u2286 s) : s.map (\u03c3 : \u03b1 \u21aa \u03b1) = s", "start": [117, 1], "end": [120, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.map_toFinset", "code": "theorem map_toFinset [DecidableEq \u03b1] [DecidableEq \u03b2] {s : Multiset \u03b1} :\n    s.toFinset.map f = (s.map f).toFinset", "start": [123, 1], "end": [125, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.map_refl", "code": "@[simp]\ntheorem map_refl : s.map (Embedding.refl _) = s", "start": [128, 1], "end": [130, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.map_cast_heq", "code": "@[simp]\ntheorem map_cast_heq {\u03b1 \u03b2} (h : \u03b1 = \u03b2) (s : Finset \u03b1) :\n    HEq (s.map (Equiv.cast h).toEmbedding) s", "start": [133, 1], "end": [137, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.map_map", "code": "theorem map_map (f : \u03b1 \u21aa \u03b2) (g : \u03b2 \u21aa \u03b3) (s : Finset \u03b1) : (s.map f).map g = s.map (f.trans g)", "start": [140, 1], "end": [141, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.map_comm", "code": "theorem map_comm {\u03b2'} {f : \u03b2 \u21aa \u03b3} {g : \u03b1 \u21aa \u03b2} {f' : \u03b1 \u21aa \u03b2'} {g' : \u03b2' \u21aa \u03b3}\n    (h_comm : \u2200 a, f (g a) = g' (f' a)) : (s.map g).map f = (s.map f').map g'", "start": [144, 1], "end": [146, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.finset_map", "code": "theorem _root_.Function.Semiconj.finset_map {f : \u03b1 \u21aa \u03b2} {ga : \u03b1 \u21aa \u03b1} {gb : \u03b2 \u21aa \u03b2}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (map f) (map ga) (map gb)", "start": [149, 1], "end": [151, 13], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.finset_map", "code": "theorem _root_.Function.Commute.finset_map {f g : \u03b1 \u21aa \u03b1} (h : Function.Commute f g) :\n    Function.Commute (map f) (map g)", "start": [154, 1], "end": [156, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subset_map", "code": "@[simp]\ntheorem map_subset_map {s\u2081 s\u2082 : Finset \u03b1} : s\u2081.map f \u2286 s\u2082.map f \u2194 s\u2081 \u2286 s\u2082", "start": [159, 1], "end": [162, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.mapEmbedding", "code": "def mapEmbedding (f : \u03b1 \u21aa \u03b2) : Finset \u03b1 \u21aao Finset \u03b2 :=\n  OrderEmbedding.ofMapLEIff (map f) fun _ _ => map_subset_map", "start": [165, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.map_inj", "code": "@[simp]\ntheorem map_inj {s\u2081 s\u2082 : Finset \u03b1} : s\u2081.map f = s\u2082.map f \u2194 s\u2081 = s\u2082", "start": [171, 1], "end": [173, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.map_injective", "code": "theorem map_injective (f : \u03b1 \u21aa \u03b2) : Injective (map f)", "start": [176, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.mapEmbedding_apply", "code": "@[simp]\ntheorem mapEmbedding_apply : mapEmbedding f s = map f s", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_map", "code": "theorem filter_map {p : \u03b2 \u2192 Prop} [DecidablePred p] :\n    (s.map f).filter p = (s.filter (p \u2218 f)).map f", "start": [185, 1], "end": [187, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.map_filter", "code": "theorem map_filter {f : \u03b1 \u2243 \u03b2} {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    (s.filter p).map f.toEmbedding = (s.map f.toEmbedding).filter (p \u2218 f.symm)", "start": [190, 1], "end": [192, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_map", "code": "@[simp]\ntheorem disjoint_map {s t : Finset \u03b1} (f : \u03b1 \u21aa \u03b2) :\n    Disjoint (s.map f) (t.map f) \u2194 Disjoint s t", "start": [195, 1], "end": [201, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.map_disjUnion", "code": "theorem map_disjUnion {f : \u03b1 \u21aa \u03b2} (s\u2081 s\u2082 : Finset \u03b1) (h) (h' := (disjoint_map _).mpr h) :\n    (s\u2081.disjUnion s\u2082 h).map f = (s\u2081.map f).disjUnion (s\u2082.map f) h'", "start": [204, 1], "end": [206, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_disjUnion'", "code": "theorem map_disjUnion' {f : \u03b1 \u21aa \u03b2} (s\u2081 s\u2082 : Finset \u03b1) (h') (h := (disjoint_map _).mp h') :\n    (s\u2081.disjUnion s\u2082 h).map f = (s\u2081.map f).disjUnion (s\u2082.map f) h'", "start": [209, 1], "end": [212, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.map_union", "code": "theorem map_union [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u21aa \u03b2} (s\u2081 s\u2082 : Finset \u03b1) :\n    (s\u2081 \u222a s\u2082).map f = s\u2081.map f \u222a s\u2082.map f", "start": [215, 1], "end": [217, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.map_inter", "code": "theorem map_inter [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u21aa \u03b2} (s\u2081 s\u2082 : Finset \u03b1) :\n    (s\u2081 \u2229 s\u2082).map f = s\u2081.map f \u2229 s\u2082.map f", "start": [220, 1], "end": [222, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.map_singleton", "code": "@[simp]\ntheorem map_singleton (f : \u03b1 \u21aa \u03b2) (a : \u03b1) : map f {a} = {f a}", "start": [225, 1], "end": [227, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.map_insert", "code": "@[simp]\ntheorem map_insert [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (s : Finset \u03b1) :\n    (insert a s).map f = insert (f a) (s.map f)", "start": [230, 1], "end": [233, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.map_cons", "code": "@[simp]\ntheorem map_cons (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (s : Finset \u03b1) (ha : a \u2209 s) :\n    (cons a s ha).map f = cons (f a) (s.map f) (by simpa using ha)", "start": [236, 1], "end": [239, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.map_eq_empty", "code": "@[simp]\ntheorem map_eq_empty : s.map f = \u2205 \u2194 s = \u2205", "start": [242, 1], "end": [245, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.map_nonempty", "code": "@[simp]\ntheorem map_nonempty : (s.map f).Nonempty \u2194 s.Nonempty", "start": [248, 1], "end": [250, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.map", "code": "alias \u27e8_, Nonempty.map\u27e9 := map_nonempty", "start": [253, 1], "end": [253, 40], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.attach_map_val", "code": "theorem attach_map_val {s : Finset \u03b1} : s.attach.map (Embedding.subtype _) = s", "start": [256, 1], "end": [257, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_range_addLeftEmbedding", "code": "theorem disjoint_range_addLeftEmbedding (a b : \u2115) :\n    Disjoint (range a) (map (addLeftEmbedding a) (range b))", "start": [260, 1], "end": [267, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_range_addRightEmbedding", "code": "theorem disjoint_range_addRightEmbedding (a b : \u2115) :\n    Disjoint (range a) (map (addRightEmbedding a) (range b))", "start": [270, 1], "end": [277, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.map_disjiUnion", "code": "theorem map_disjiUnion {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1} {t : \u03b2 \u2192 Finset \u03b3} {h} :\n    (s.map f).disjiUnion t h =\n      s.disjiUnion (fun a => t (f a)) fun _ ha _ hb hab =>\n        h (mem_map_of_mem _ ha) (mem_map_of_mem _ hb) (f.injective.ne hab)", "start": [280, 1], "end": [284, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_map", "code": "theorem disjiUnion_map {s : Finset \u03b1} {t : \u03b1 \u2192 Finset \u03b2} {f : \u03b2 \u21aa \u03b3} {h} :\n    (s.disjiUnion t h).map f =\n      s.disjiUnion (fun a => (t a).map f) fun a ha b hb hab =>\n        disjoint_left.mpr fun x hxa hxb => by\n          obtain \u27e8xa, hfa, rfl\u27e9 := mem_map.mp hxa\n          obtain \u27e8xb, hfb, hfab\u27e9 := mem_map.mp hxb\n          obtain rfl := f.injective hfab\n          exact disjoint_left.mp (h ha hb hab) hfa hfb", "start": [287, 1], "end": [295, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.range_add_one'", "code": "theorem range_add_one' (n : \u2115) :\n    range (n + 1) = insert 0 ((range n).map \u27e8fun i => i + 1, fun i j => by simp\u27e9)", "start": [300, 1], "end": [302, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.image", "code": "def image (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : Finset \u03b2 :=\n  (s.1.map f).toFinset", "start": [312, 1], "end": [314, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.image_val", "code": "@[simp]\ntheorem image_val (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : (image f s).1 = (s.1.map f).dedup", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_empty", "code": "@[simp]\ntheorem image_empty (f : \u03b1 \u2192 \u03b2) : (\u2205 : Finset \u03b1).image f = \u2205", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image", "code": "@[simp]\ntheorem mem_image : b \u2208 s.image f \u2194 \u2203 a \u2208 s, f a = b", "start": [329, 1], "end": [331, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image_of_mem", "code": "theorem mem_image_of_mem (f : \u03b1 \u2192 \u03b2) {a} (h : a \u2208 s) : f a \u2208 s.image f", "start": [334, 1], "end": [335, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_image", "code": "theorem forall_image {p : \u03b2 \u2192 Prop} : (\u2200 b \u2208 s.image f, p b) \u2194 \u2200 a \u2208 s, p (f a)", "start": [338, 1], "end": [339, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.map_eq_image", "code": "theorem map_eq_image (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) : s.map f = s.image f", "start": [342, 1], "end": [343, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image_const", "code": "theorem mem_image_const : c \u2208 s.image (const \u03b1 b) \u2194 s.Nonempty \u2227 b = c", "start": [347, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image_const_self", "code": "theorem mem_image_const_self : b \u2208 s.image (const \u03b1 b) \u2194 s.Nonempty", "start": [353, 1], "end": [354, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.canLift", "code": "instance canLift (c) (p) [CanLift \u03b2 \u03b1 c p] :\n    CanLift (Finset \u03b2) (Finset \u03b1) (image c) fun s => \u2200 x \u2208 s, p x where\n  prf := by\n    rintro \u27e8\u27e8l\u27e9, hd : l.Nodup\u27e9 hl\n    lift l to List \u03b1 using hl\n    exact \u27e8\u27e8l, hd.of_map _\u27e9, ext fun a => by simp\u27e9", "start": [357, 1], "end": [362, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.image_congr", "code": "theorem image_congr (h : (s : Set \u03b1).EqOn f g) : Finset.image f s = Finset.image g s", "start": [365, 1], "end": [368, 43], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mem_finset_image", "code": "theorem _root_.Function.Injective.mem_finset_image (hf : Injective f) :\n    f a \u2208 s.image f \u2194 a \u2208 s", "start": [371, 1], "end": [375, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_mem_image_eq_image", "code": "theorem filter_mem_image_eq_image (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) (t : Finset \u03b2) (h : \u2200 x \u2208 s, f x \u2208 t) :\n    (t.filter fun y => y \u2208 s.image f) = s.image f", "start": [378, 1], "end": [384, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.fiber_nonempty_iff_mem_image", "code": "theorem fiber_nonempty_iff_mem_image (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) (y : \u03b2) :\n    (s.filter fun x => f x = y).Nonempty \u2194 y \u2208 s.image f", "start": [387, 1], "end": [388, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_image", "code": "@[simp, norm_cast]\ntheorem coe_image {f : \u03b1 \u2192 \u03b2} : \u2191(s.image f) = f '' \u2191s", "start": [391, 1], "end": [393, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.image", "code": "protected theorem Nonempty.image (h : s.Nonempty) (f : \u03b1 \u2192 \u03b2) : (s.image f).Nonempty", "start": [396, 1], "end": [398, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.image_iff", "code": "@[simp]\ntheorem Nonempty.image_iff (f : \u03b1 \u2192 \u03b2) : (s.image f).Nonempty \u2194 s.Nonempty", "start": [401, 1], "end": [406, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.image_toFinset", "code": "theorem image_toFinset [DecidableEq \u03b1] {s : Multiset \u03b1} :\n    s.toFinset.image f = (s.map f).toFinset", "start": [409, 1], "end": [411, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.image_val_of_injOn", "code": "theorem image_val_of_injOn (H : Set.InjOn f s) : (image f s).1 = s.1.map f", "start": [414, 1], "end": [415, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.image_id", "code": "@[simp]\ntheorem image_id [DecidableEq \u03b1] : s.image id = s", "start": [418, 1], "end": [420, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.image_id'", "code": "@[simp]\ntheorem image_id' [DecidableEq \u03b1] : (s.image fun x => x) = s", "start": [423, 1], "end": [425, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image", "code": "theorem image_image [DecidableEq \u03b3] {g : \u03b2 \u2192 \u03b3} : (s.image f).image g = s.image (g \u2218 f)", "start": [428, 1], "end": [429, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.image_comm", "code": "theorem image_comm {\u03b2'} [DecidableEq \u03b2'] [DecidableEq \u03b3] {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {f' : \u03b1 \u2192 \u03b2'}\n    {g' : \u03b2' \u2192 \u03b3} (h_comm : \u2200 a, f (g a) = g' (f' a)) :\n    (s.image g).image f = (s.image f').image g'", "start": [432, 1], "end": [434, 90], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.finset_image", "code": "theorem _root_.Function.Semiconj.finset_image [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (image f) (image ga) (image gb)", "start": [437, 1], "end": [439, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.finset_image", "code": "theorem _root_.Function.Commute.finset_image [DecidableEq \u03b1] {f g : \u03b1 \u2192 \u03b1}\n    (h : Function.Commute f g) : Function.Commute (image f) (image g)", "start": [442, 1], "end": [444, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_image", "code": "theorem image_subset_image {s\u2081 s\u2082 : Finset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081.image f \u2286 s\u2082.image f", "start": [447, 1], "end": [448, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_iff", "code": "theorem image_subset_iff : s.image f \u2286 t \u2194 \u2200 x \u2208 s, f x \u2208 t", "start": [451, 1], "end": [454, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mono", "code": "theorem image_mono (f : \u03b1 \u2192 \u03b2) : Monotone (Finset.image f)", "start": [457, 1], "end": [457, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.image_injective", "code": "lemma image_injective (hf : Injective f) : Injective (image f) := by\n  simpa only [funext (map_eq_image _)] using map_injective \u27e8f, hf\u27e9", "start": [460, 1], "end": [461, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.image_inj", "code": "lemma image_inj {t : Finset \u03b1} (hf : Injective f) : s.image f = t.image f \u2194 s = t :=\n  (image_injective hf).eq_iff", "start": [463, 1], "end": [464, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.image_subset_image_iff", "code": "theorem image_subset_image_iff {t : Finset \u03b1} (hf : Injective f) :\n    s.image f \u2286 t.image f \u2194 s \u2286 t", "start": [466, 1], "end": [470, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.image_ssubset_image", "code": "lemma image_ssubset_image {t : Finset \u03b1} (hf : Injective f) : s.image f \u2282 t.image f \u2194 s \u2282 t := by\n  simp_rw [\u2190lt_iff_ssubset]\n  exact lt_iff_lt_of_le_iff_le' (image_subset_image_iff hf) (image_subset_image_iff hf)", "start": [473, 1], "end": [475, 88], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.coe_image_subset_range", "code": "theorem coe_image_subset_range : \u2191(s.image f) \u2286 Set.range f", "start": [477, 1], "end": [480, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.image_filter", "code": "theorem image_filter {p : \u03b2 \u2192 Prop} [DecidablePred p] :\n    (s.image f).filter p = (s.filter \u03bb a \u21a6 p (f a)).image f", "start": [483, 1], "end": [489, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.image_union", "code": "theorem image_union [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} (s\u2081 s\u2082 : Finset \u03b1) :\n    (s\u2081 \u222a s\u2082).image f = s\u2081.image f \u222a s\u2082.image f", "start": [492, 1], "end": [494, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.image_inter_subset", "code": "theorem image_inter_subset [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (s t : Finset \u03b1) :\n    (s \u2229 t).image f \u2286 s.image f \u2229 t.image f", "start": [497, 1], "end": [500, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.image_inter_of_injOn", "code": "theorem image_inter_of_injOn [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} (s t : Finset \u03b1)\n    (hf : Set.InjOn f (s \u222a t)) : (s \u2229 t).image f = s.image f \u2229 t.image f", "start": [503, 1], "end": [507, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.image_inter", "code": "theorem image_inter [DecidableEq \u03b1] (s\u2081 s\u2082 : Finset \u03b1) (hf : Injective f) :\n    (s\u2081 \u2229 s\u2082).image f = s\u2081.image f \u2229 s\u2082.image f", "start": [510, 1], "end": [512, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.image_singleton", "code": "@[simp]\ntheorem image_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : image f {a} = {f a}", "start": [515, 1], "end": [517, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.image_insert", "code": "@[simp]\ntheorem image_insert [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Finset \u03b1) :\n    (insert a s).image f = insert (f a) (s.image f)", "start": [520, 1], "end": [523, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.erase_image_subset_image_erase", "code": "theorem erase_image_subset_image_erase [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) (a : \u03b1) :\n    (s.image f).erase (f a) \u2286 (s.erase a).image f", "start": [526, 1], "end": [530, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.image_erase", "code": "@[simp]\ntheorem image_erase [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (s : Finset \u03b1) (a : \u03b1) :\n    (s.erase a).image f = (s.image f).erase (f a)", "start": [533, 1], "end": [539, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.image_eq_empty", "code": "@[simp]\ntheorem image_eq_empty : s.image f = \u2205 \u2194 s = \u2205", "start": [542, 1], "end": [545, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.image_sdiff", "code": "theorem image_sdiff [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} (s t : Finset \u03b1) (hf : Injective f) :\n    (s \\ t).image f = s.image f \\ t.image f", "start": [548, 1], "end": [552, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.image_symmDiff", "code": "theorem image_symmDiff [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} (s t : Finset \u03b1) (hf : Injective f) :\n    (s \u2206 t).image f = s.image f \u2206 t.image f", "start": [555, 1], "end": [559, 36], "kind": "commanddeclaration"}, {"full_name": "Disjoint.of_image_finset", "code": "@[simp]\ntheorem _root_.Disjoint.of_image_finset {s t : Finset \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (h : Disjoint (s.image f) (t.image f)) : Disjoint s t", "start": [562, 1], "end": [566, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range_iff_mem_finset_range_of_mod_eq'", "code": "theorem mem_range_iff_mem_finset_range_of_mod_eq' [DecidableEq \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1} {n : \u2115}\n    (hn : 0 < n) (h : \u2200 i, f (i % n) = f i) :\n    a \u2208 Set.range f \u2194 a \u2208 (Finset.range n).image fun i => f i", "start": [569, 1], "end": [579, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_range_iff_mem_finset_range_of_mod_eq", "code": "theorem mem_range_iff_mem_finset_range_of_mod_eq [DecidableEq \u03b1] {f : \u2124 \u2192 \u03b1} {a : \u03b1} {n : \u2115}\n    (hn : 0 < n) (h : \u2200 i, f (i % n) = f i) :\n    a \u2208 Set.range f \u2194 a \u2208 (Finset.range n).image (fun (i : \u2115) => f i)", "start": [582, 1], "end": [593, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.range_add", "code": "theorem range_add (a b : \u2115) : range (a + b) = range a \u222a (range b).map (addLeftEmbedding a)", "start": [596, 1], "end": [598, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_image_val", "code": "@[simp]\ntheorem attach_image_val [DecidableEq \u03b1] {s : Finset \u03b1} : s.attach.image Subtype.val = s", "start": [601, 1], "end": [603, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_insert", "code": "@[simp]\ntheorem attach_insert [DecidableEq \u03b1] {a : \u03b1} {s : Finset \u03b1} :\n    attach (insert a s) =\n      insert (\u27e8a, mem_insert_self a s\u27e9 : { x // x \u2208 insert a s })\n        ((attach s).image fun x => \u27e8x.1, mem_insert_of_mem x.2\u27e9)", "start": [607, 1], "end": [616, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_image", "code": "@[simp]\ntheorem disjoint_image {s t : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Disjoint (s.image f) (t.image f) \u2194 Disjoint s t", "start": [619, 1], "end": [623, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.image_const", "code": "theorem image_const {s : Finset \u03b1} (h : s.Nonempty) (b : \u03b2) : (s.image fun _ => b) = singleton b", "start": [626, 1], "end": [629, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.map_erase", "code": "@[simp]\ntheorem map_erase [DecidableEq \u03b1] (f : \u03b1 \u21aa \u03b2) (s : Finset \u03b1) (a : \u03b1) :\n    (s.erase a).map f = (s.map f).erase (f a)", "start": [632, 1], "end": [636, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.image_biUnion", "code": "theorem image_biUnion [DecidableEq \u03b3] {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : \u03b2 \u2192 Finset \u03b3} :\n    (s.image f).biUnion t = s.biUnion fun a => t (f a)", "start": [639, 1], "end": [642, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_image", "code": "theorem biUnion_image [DecidableEq \u03b3] {s : Finset \u03b1} {t : \u03b1 \u2192 Finset \u03b2} {f : \u03b2 \u2192 \u03b3} :\n    (s.biUnion t).image f = s.biUnion fun a => (t a).image f", "start": [645, 1], "end": [648, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.image_biUnion_filter_eq", "code": "theorem image_biUnion_filter_eq [DecidableEq \u03b1] (s : Finset \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    ((s.image g).biUnion fun a => s.filter fun c => g c = a) = s", "start": [651, 1], "end": [653, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_singleton", "code": "theorem biUnion_singleton {f : \u03b1 \u2192 \u03b2} : (s.biUnion fun a => {f a}) = s.image f", "start": [656, 1], "end": [657, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.filterMap", "code": "def filterMap (f : \u03b1 \u2192 Option \u03b2) (s : Finset \u03b1)\n    (f_inj : \u2200 a a' b, b \u2208 f a \u2192 b \u2208 f a' \u2192 a = a') : Finset \u03b2 :=\n  \u27e8s.val.filterMap f, s.nodup.filterMap f f_inj\u27e9", "start": [666, 1], "end": [675, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.filterMap_val", "code": "@[simp]\ntheorem filterMap_val : (filterMap f s' f_inj).1 = s'.1.filterMap f", "start": [680, 1], "end": [681, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.filterMap_empty", "code": "@[simp]\ntheorem filterMap_empty : (\u2205 : Finset \u03b1).filterMap f f_inj = \u2205", "start": [683, 1], "end": [684, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_filterMap", "code": "@[simp]\ntheorem mem_filterMap {b : \u03b2} : b \u2208 s.filterMap f f_inj \u2194 \u2203 a \u2208 s, f a = some b", "start": [686, 1], "end": [688, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_filterMap", "code": "@[simp, norm_cast]\ntheorem coe_filterMap : (s.filterMap f f_inj : Set \u03b2) = {b | \u2203 a \u2208 s, f a = some b}", "start": [690, 1], "end": [692, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.filterMap_some", "code": "@[simp]\ntheorem filterMap_some : s.filterMap some (by simp) = s", "start": [694, 1], "end": [696, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.filterMap_mono", "code": "theorem filterMap_mono (h : s \u2286 t) :\n    filterMap f s f_inj \u2286 filterMap f t f_inj", "start": [698, 1], "end": [701, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype", "code": "protected def subtype {\u03b1} (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : Finset \u03b1) : Finset (Subtype p) :=\n  (s.filter p).attach.map\n    \u27e8fun x => \u27e8x.1, by simpa using (Finset.mem_filter.1 x.2).2\u27e9,\n     fun x y H => Subtype.eq <| Subtype.mk.inj H\u27e9", "start": [710, 1], "end": [715, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_subtype", "code": "@[simp]\ntheorem mem_subtype {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} :\n    \u2200 {a : Subtype p}, a \u2208 s.subtype p \u2194 (a : \u03b1) \u2208 s", "start": [718, 1], "end": [721, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_eq_empty", "code": "theorem subtype_eq_empty {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} :\n    s.subtype p = \u2205 \u2194 \u2200 x, p x \u2192 x \u2209 s", "start": [724, 1], "end": [725, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_mono", "code": "@[mono]\ntheorem subtype_mono {p : \u03b1 \u2192 Prop} [DecidablePred p] : Monotone (Finset.subtype p)", "start": [728, 1], "end": [730, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_map", "code": "@[simp]\ntheorem subtype_map (p : \u03b1 \u2192 Prop) [DecidablePred p] {s : Finset \u03b1} :\n    (s.subtype p).map (Embedding.subtype _) = s.filter p", "start": [733, 1], "end": [739, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_map_of_mem", "code": "theorem subtype_map_of_mem {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} (h : \u2200 x \u2208 s, p x) :\n    (s.subtype p).map (Embedding.subtype _) = s", "start": [742, 1], "end": [745, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.property_of_mem_map_subtype", "code": "theorem property_of_mem_map_subtype {p : \u03b1 \u2192 Prop} (s : Finset { x // p x }) {a : \u03b1}\n    (h : a \u2208 s.map (Embedding.subtype _)) : p a", "start": [748, 1], "end": [754, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_map_subtype_of_not_property", "code": "theorem not_mem_map_subtype_of_not_property {p : \u03b1 \u2192 Prop} (s : Finset { x // p x }) {a : \u03b1}\n    (h : \u00acp a) : a \u2209 s.map (Embedding.subtype _)", "start": [757, 1], "end": [762, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_subset", "code": "theorem map_subtype_subset {t : Set \u03b1} (s : Finset t) : \u2191(s.map (Embedding.subtype _)) \u2286 t", "start": [765, 1], "end": [771, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.fin", "code": "protected def fin (n : \u2115) (s : Finset \u2115) : Finset (Fin n) :=\n  (s.subtype _).map Fin.equivSubtype.symm.toEmbedding", "start": [779, 1], "end": [783, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_fin", "code": "@[simp]\ntheorem mem_fin {n} {s : Finset \u2115} : \u2200 a : Fin n, a \u2208 s.fin n \u2194 (a : \u2115) \u2208 s", "start": [786, 1], "end": [788, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.fin_mono", "code": "@[mono]\ntheorem fin_mono {n} : Monotone (Finset.fin n)", "start": [791, 1], "end": [792, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.fin_map", "code": "@[simp]\ntheorem fin_map {n} {s : Finset \u2115} : (s.fin n).map Fin.valEmbedding = s.filter (\u00b7 < n)", "start": [795, 1], "end": [797, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_image_iff", "code": "theorem subset_image_iff [DecidableEq \u03b2] {s : Set \u03b1} {t : Finset \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    \u2191t \u2286 f '' s \u2194 \u2203 s' : Finset \u03b1, \u2191s' \u2286 s \u2227 s'.image f = t", "start": [800, 1], "end": [810, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.range_sdiff_zero", "code": "theorem range_sdiff_zero {n : \u2115} : range (n + 1) \\ {0} = (range n).image Nat.succ", "start": [813, 1], "end": [818, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_map", "code": "theorem Multiset.toFinset_map [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (m : Multiset \u03b1) :\n    (m.map f).toFinset = m.toFinset.image f", "start": [823, 1], "end": [825, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr", "code": "protected def finsetCongr (e : \u03b1 \u2243 \u03b2) : Finset \u03b1 \u2243 Finset \u03b2 where\n  toFun s := s.map e.toEmbedding\n  invFun s := s.map e.symm.toEmbedding\n  left_inv s := by simp [Finset.map_map]\n  right_inv s := by simp [Finset.map_map]", "start": [830, 1], "end": [835, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr_apply", "code": "@[simp]\ntheorem finsetCongr_apply (e : \u03b1 \u2243 \u03b2) (s : Finset \u03b1) : e.finsetCongr s = s.map e.toEmbedding", "start": [838, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr_refl", "code": "@[simp]\ntheorem finsetCongr_refl : (Equiv.refl \u03b1).finsetCongr = Equiv.refl _", "start": [843, 1], "end": [846, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr_symm", "code": "@[simp]\ntheorem finsetCongr_symm (e : \u03b1 \u2243 \u03b2) : e.finsetCongr.symm = e.symm.finsetCongr", "start": [849, 1], "end": [851, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr_trans", "code": "@[simp]\ntheorem finsetCongr_trans (e : \u03b1 \u2243 \u03b2) (e' : \u03b2 \u2243 \u03b3) :\n    e.finsetCongr.trans e'.finsetCongr = (e.trans e').finsetCongr", "start": [854, 1], "end": [858, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsetCongr_toEmbedding", "code": "theorem finsetCongr_toEmbedding (e : \u03b1 \u2243 \u03b2) :\n    e.finsetCongr.toEmbedding = (Finset.mapEmbedding e.toEmbedding).toEmbedding", "start": [861, 1], "end": [863, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/WithZero/Basic.lean", "imports": ["Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithZero.contravariantClass_mul_lt", "code": "instance contravariantClass_mul_lt [Mul \u03b1] [PartialOrder \u03b1]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass (WithZero \u03b1) (WithZero \u03b1) (\u00b7 * \u00b7) (\u00b7 < \u00b7) := by\n  refine \u27e8fun a b c h => ?_\u27e9\n  have := ((zero_le _).trans_lt h).ne'\n  induction a using WithZero.recZeroCoe\n  \u00b7 exfalso; exact left_ne_zero_of_mul this rfl\n  induction c using WithZero.recZeroCoe\n  \u00b7 exfalso; exact right_ne_zero_of_mul this rfl\n  induction b using WithZero.recZeroCoe\n  exacts [zero_lt_coe _, coe_lt_coe.mpr (lt_of_mul_lt_mul_left' <| coe_lt_coe.mp h)]", "start": [27, 1], "end": [37, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Units.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.units_eq_one", "code": "theorem units_eq_one (u : \u2115\u02e3) : u = 1", "start": [16, 1], "end": [17, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.addUnits_eq_zero", "code": "theorem addUnits_eq_zero (u : AddUnits \u2115) : u = 0", "start": [20, 1], "end": [21, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.isUnit_iff", "code": "@[simp]\nprotected theorem isUnit_iff {n : \u2115} : IsUnit n \u2194 n = 1", "start": [24, 1], "end": [30, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.unique_units", "code": "instance unique_units : Unique \u2115\u02e3 where\n  default := 1\n  uniq := Nat.units_eq_one", "start": [33, 1], "end": [35, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.unique_addUnits", "code": "instance unique_addUnits : Unique (AddUnits \u2115) where\n  default := 0\n  uniq := Nat.addUnits_eq_zero", "start": [38, 1], "end": [40, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Regular/Basic.lean", "imports": ["Mathlib/Tactic/NthRewrite.lean", "Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean"], "premises": [{"full_name": "IsLeftRegular", "code": "@[to_additive \"An add-left-regular element is an element `c` such that addition\n    on the left by `c` is injective.\"]\ndef IsLeftRegular (c : R) :=\n  (c * \u00b7).Injective", "start": [39, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular", "code": "@[to_additive \"An add-right-regular element is an element `c` such that addition\n    on the right by `c` is injective.\"]\ndef IsRightRegular (c : R) :=\n  (\u00b7 * c).Injective", "start": [48, 1], "end": [53, 20], "kind": "commanddeclaration"}, {"full_name": "IsAddRegular", "code": "structure IsAddRegular {R : Type*} [Add R] (c : R) : Prop where\n  \n  left : IsAddLeftRegular c \n  right : IsAddRightRegular c", "start": [57, 1], "end": [63, 30], "kind": "commanddeclaration"}, {"full_name": "IsRegular", "code": "structure IsRegular (c : R) : Prop where\n  \n  left : IsLeftRegular c\n  \n  right : IsRightRegular c", "start": [66, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.isLeftRegular", "code": "@[to_additive]\nprotected theorem MulLECancellable.isLeftRegular [PartialOrder R] {a : R}\n    (ha : MulLECancellable a) : IsLeftRegular a", "start": [79, 1], "end": [82, 15], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.right_of_commute", "code": "theorem IsLeftRegular.right_of_commute {a : R}\n    (ca : \u2200 b, Commute a b) (h : IsLeftRegular a) : IsRightRegular a", "start": [86, 1], "end": [88, 61], "kind": "commanddeclaration"}, {"full_name": "Commute.isRegular_iff", "code": "theorem Commute.isRegular_iff {a : R} (ca : \u2200 b, Commute a b) : IsRegular a \u2194 IsLeftRegular a", "start": [91, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.mul", "code": "@[to_additive \"In an additive semigroup, the sum of add-left-regular elements is add-left.regular.\"]\ntheorem IsLeftRegular.mul (lra : IsLeftRegular a) (lrb : IsLeftRegular b) : IsLeftRegular (a * b)", "start": [101, 1], "end": [104, 80], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.mul", "code": "@[to_additive \"In an additive semigroup, the sum of add-right-regular elements is\nadd-right-regular.\"]\ntheorem IsRightRegular.mul (rra : IsRightRegular a) (rrb : IsRightRegular b) :\n    IsRightRegular (a * b)", "start": [108, 1], "end": [113, 79], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.of_mul", "code": "@[to_additive \"If an element `b` becomes add-left-regular after adding to it on the left\nan add-left-regular element, then `b` is add-left-regular.\"]\ntheorem IsLeftRegular.of_mul (ab : IsLeftRegular (a * b)) : IsLeftRegular b", "start": [117, 1], "end": [122, 58], "kind": "commanddeclaration"}, {"full_name": "mul_isLeftRegular_iff", "code": "@[to_additive (attr := simp) \"An element is add-left-regular if and only if adding to it on the left\nan add-left-regular element is add-left-regular.\"]\ntheorem mul_isLeftRegular_iff (b : R) (ha : IsLeftRegular a) :\n    IsLeftRegular (a * b) \u2194 IsLeftRegular b", "start": [126, 1], "end": [132, 73], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.of_mul", "code": "@[to_additive \"If an element `b` becomes add-right-regular after adding to it on the right\nan add-right-regular element, then `b` is add-right-regular.\"]\ntheorem IsRightRegular.of_mul (ab : IsRightRegular (b * a)) : IsRightRegular b", "start": [136, 1], "end": [143, 43], "kind": "commanddeclaration"}, {"full_name": "mul_isRightRegular_iff", "code": "@[to_additive (attr := simp)\n\"An element is add-right-regular if and only if adding it on the right to\nan add-right-regular element is add-right-regular.\"]\ntheorem mul_isRightRegular_iff (b : R) (ha : IsRightRegular a) :\n    IsRightRegular (b * a) \u2194 IsRightRegular b", "start": [147, 1], "end": [154, 75], "kind": "commanddeclaration"}, {"full_name": "isRegular_mul_and_mul_iff", "code": "@[to_additive \"Two elements `a` and `b` are add-regular if and only if both sums `a + b` and\n`b + a` are add-regular.\"]\ntheorem isRegular_mul_and_mul_iff :\n    IsRegular (a * b) \u2227 IsRegular (b * a) \u2194 IsRegular a \u2227 IsRegular b", "start": [158, 1], "end": [174, 61], "kind": "commanddeclaration"}, {"full_name": "IsRegular.and_of_mul_of_mul", "code": "@[to_additive \"The \\\"most used\\\" implication of `add_and_add_iff`, with split\nhypotheses, instead of `\u2227`.\"]\ntheorem IsRegular.and_of_mul_of_mul (ab : IsRegular (a * b)) (ba : IsRegular (b * a)) :\n    IsRegular a \u2227 IsRegular b", "start": [178, 1], "end": [183, 40], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.subsingleton", "code": "theorem IsLeftRegular.subsingleton (h : IsLeftRegular (0 : R)) : Subsingleton R", "start": [193, 1], "end": [195, 60], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.subsingleton", "code": "theorem IsRightRegular.subsingleton (h : IsRightRegular (0 : R)) : Subsingleton R", "start": [198, 1], "end": [200, 60], "kind": "commanddeclaration"}, {"full_name": "IsRegular.subsingleton", "code": "theorem IsRegular.subsingleton (h : IsRegular (0 : R)) : Subsingleton R", "start": [203, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "isLeftRegular_zero_iff_subsingleton", "code": "theorem isLeftRegular_zero_iff_subsingleton : IsLeftRegular (0 : R) \u2194 Subsingleton R", "start": [208, 1], "end": [210, 71], "kind": "commanddeclaration"}, {"full_name": "not_isLeftRegular_zero_iff", "code": "theorem not_isLeftRegular_zero_iff : \u00acIsLeftRegular (0 : R) \u2194 Nontrivial R", "start": [213, 1], "end": [217, 16], "kind": "commanddeclaration"}, {"full_name": "isRightRegular_zero_iff_subsingleton", "code": "theorem isRightRegular_zero_iff_subsingleton : IsRightRegular (0 : R) \u2194 Subsingleton R", "start": [220, 1], "end": [222, 71], "kind": "commanddeclaration"}, {"full_name": "not_isRightRegular_zero_iff", "code": "theorem not_isRightRegular_zero_iff : \u00acIsRightRegular (0 : R) \u2194 Nontrivial R", "start": [225, 1], "end": [229, 16], "kind": "commanddeclaration"}, {"full_name": "isRegular_iff_subsingleton", "code": "theorem isRegular_iff_subsingleton : IsRegular (0 : R) \u2194 Subsingleton R", "start": [232, 1], "end": [235, 93], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.ne_zero", "code": "theorem IsLeftRegular.ne_zero [Nontrivial R] (la : IsLeftRegular a) : a \u2260 0", "start": [238, 1], "end": [243, 26], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.ne_zero", "code": "theorem IsRightRegular.ne_zero [Nontrivial R] (ra : IsRightRegular a) : a \u2260 0", "start": [246, 1], "end": [251, 26], "kind": "commanddeclaration"}, {"full_name": "IsRegular.ne_zero", "code": "theorem IsRegular.ne_zero [Nontrivial R] (la : IsRegular a) : a \u2260 0", "start": [254, 1], "end": [256, 18], "kind": "commanddeclaration"}, {"full_name": "not_isLeftRegular_zero", "code": "theorem not_isLeftRegular_zero [nR : Nontrivial R] : \u00acIsLeftRegular (0 : R)", "start": [259, 1], "end": [261, 36], "kind": "commanddeclaration"}, {"full_name": "not_isRightRegular_zero", "code": "theorem not_isRightRegular_zero [nR : Nontrivial R] : \u00acIsRightRegular (0 : R)", "start": [264, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "not_isRegular_zero", "code": "theorem not_isRegular_zero [Nontrivial R] : \u00acIsRegular (0 : R)", "start": [269, 1], "end": [270, 99], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.mul_left_eq_zero_iff", "code": "@[simp] lemma IsLeftRegular.mul_left_eq_zero_iff (hb : IsLeftRegular b) : b * a = 0 \u2194 a = 0 := by\n  nth_rw 1 [\u2190 mul_zero b]\n  exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha, mul_zero]\u27e9", "start": [273, 1], "end": [275, 54], "kind": "mathlibtacticlemma"}, {"full_name": "IsRightRegular.mul_right_eq_zero_iff", "code": "@[simp] lemma IsRightRegular.mul_right_eq_zero_iff (hb : IsRightRegular b) : a * b = 0 \u2194 a = 0 := by\n  nth_rw 1 [\u2190 zero_mul b]\n  exact \u27e8fun h \u21a6 hb h, fun ha \u21a6 by rw [ha, zero_mul]\u27e9", "start": [277, 1], "end": [279, 54], "kind": "mathlibtacticlemma"}, {"full_name": "isRegular_one", "code": "@[to_additive \"If adding `0` on either side is the identity, `0` is regular.\"]\ntheorem isRegular_one : IsRegular (1 : R)", "start": [287, 1], "end": [291, 54], "kind": "commanddeclaration"}, {"full_name": "isRegular_mul_iff", "code": "@[to_additive \"A sum is add-regular if and only if the summands are.\"]\ntheorem isRegular_mul_iff : IsRegular (a * b) \u2194 IsRegular a \u2227 IsRegular b", "start": [301, 1], "end": [305, 64], "kind": "commanddeclaration"}, {"full_name": "isLeftRegular_of_mul_eq_one", "code": "@[to_additive \"An element admitting a left additive opposite is add-left-regular.\"]\ntheorem isLeftRegular_of_mul_eq_one (h : b * a = 1) : IsLeftRegular a", "start": [315, 1], "end": [318, 70], "kind": "commanddeclaration"}, {"full_name": "isRightRegular_of_mul_eq_one", "code": "@[to_additive \"An element admitting a right additive opposite is add-right-regular.\"]\ntheorem isRightRegular_of_mul_eq_one (h : a * b = 1) : IsRightRegular a", "start": [322, 1], "end": [325, 63], "kind": "commanddeclaration"}, {"full_name": "Units.isRegular", "code": "@[to_additive \"If `R` is an additive monoid, an element in `add_units R` is add-regular.\"]\ntheorem Units.isRegular (a : R\u02e3) : IsRegular (a : R)", "start": [329, 1], "end": [332, 82], "kind": "commanddeclaration"}, {"full_name": "IsUnit.isRegular", "code": "@[to_additive \"An additive unit in an additive monoid is add-regular.\"]\ntheorem IsUnit.isRegular (ua : IsUnit a) : IsRegular a", "start": [336, 1], "end": [340, 26], "kind": "commanddeclaration"}, {"full_name": "isLeftRegular_of_leftCancelSemigroup", "code": "@[to_additive \"Elements of an add left cancel semigroup are add-left-regular.\"]\ntheorem isLeftRegular_of_leftCancelSemigroup [LeftCancelSemigroup R]\n    (g : R) : IsLeftRegular g", "start": [346, 1], "end": [350, 24], "kind": "commanddeclaration"}, {"full_name": "isRightRegular_of_rightCancelSemigroup", "code": "@[to_additive \"Elements of an add right cancel semigroup are add-right-regular\"]\ntheorem isRightRegular_of_rightCancelSemigroup [RightCancelSemigroup R]\n    (g : R) : IsRightRegular g", "start": [354, 1], "end": [358, 23], "kind": "commanddeclaration"}, {"full_name": "isRegular_of_cancelMonoid", "code": "@[to_additive \"Elements of an add cancel monoid are regular.\nAdd cancel semigroups do not appear to exist.\"]\ntheorem isRegular_of_cancelMonoid (g : R) : IsRegular g", "start": [366, 1], "end": [370, 48], "kind": "commanddeclaration"}, {"full_name": "isRegular_of_ne_zero", "code": "theorem isRegular_of_ne_zero (a0 : a \u2260 0) : IsRegular a", "start": [380, 1], "end": [382, 72], "kind": "commanddeclaration"}, {"full_name": "isRegular_iff_ne_zero", "code": "theorem isRegular_iff_ne_zero [Nontrivial R] : IsRegular a \u2194 a \u2260 0", "start": [385, 1], "end": [387, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/OfFn.lean", "imports": ["Mathlib/Data/List/Join.lean", "Mathlib/Data/List/Pairwise.lean", "Mathlib/Data/Fin/Tuple/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.length_ofFn", "code": "@[simp]\ntheorem length_ofFn {n} (f : Fin n \u2192 \u03b1) : length (ofFn f) = n", "start": [39, 1], "end": [42, 14], "kind": "commanddeclaration"}, {"full_name": "List.get_ofFn", "code": "@[simp]\ntheorem get_ofFn {n} (f : Fin n \u2192 \u03b1) (i) : get (ofFn f) i = f (Fin.cast (by simp) i)", "start": [48, 1], "end": [55, 24], "kind": "commanddeclaration"}, {"full_name": "List.get?_ofFn", "code": "@[simp]\ntheorem get?_ofFn {n} (f : Fin n \u2192 \u03b1) (i) : get? (ofFn f) i = ofFnNthVal f i", "start": [57, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_ofFn", "code": "@[deprecated get_ofFn]\ntheorem nthLe_ofFn {n} (f : Fin n \u2192 \u03b1) (i : Fin n) :\n    nthLe (ofFn f) i ((length_ofFn f).symm \u25b8 i.2) = f i", "start": [70, 1], "end": [73, 15], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_ofFn'", "code": "@[simp, deprecated get_ofFn]\ntheorem nthLe_ofFn' {n} (f : Fin n \u2192 \u03b1) {i : \u2115} (h : i < (ofFn f).length) :\n    nthLe (ofFn f) i h = f \u27e8i, length_ofFn f \u25b8 h\u27e9", "start": [77, 1], "end": [80, 38], "kind": "commanddeclaration"}, {"full_name": "List.map_ofFn", "code": "@[simp]\ntheorem map_ofFn {\u03b2 : Type*} {n : \u2115} (f : Fin n \u2192 \u03b1) (g : \u03b1 \u2192 \u03b2) :\n    map g (ofFn f) = ofFn (g \u2218 f)", "start": [83, 1], "end": [86, 42], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_congr", "code": "@[congr]\ntheorem ofFn_congr {m n : \u2115} (h : m = n) (f : Fin m \u2192 \u03b1) :\n    ofFn f = ofFn fun i : Fin n => f (Fin.cast h.symm i)", "start": [100, 1], "end": [104, 30], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_zero", "code": "@[simp]\ntheorem ofFn_zero (f : Fin 0 \u2192 \u03b1) : ofFn f = []", "start": [107, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_succ", "code": "@[simp]\ntheorem ofFn_succ {n} (f : Fin (succ n) \u2192 \u03b1) : ofFn f = f 0 :: ofFn fun i => f i.succ", "start": [113, 1], "end": [118, 12], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_succ'", "code": "theorem ofFn_succ' {n} (f : Fin (succ n) \u2192 \u03b1) :\n    ofFn f = (ofFn fun i => f (Fin.castSucc i)).concat (f (Fin.last _))", "start": [121, 1], "end": [127, 10], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_eq_nil_iff", "code": "@[simp]\ntheorem ofFn_eq_nil_iff {n : \u2115} {f : Fin n \u2192 \u03b1} : ofFn f = [] \u2194 n = 0", "start": [130, 1], "end": [132, 83], "kind": "commanddeclaration"}, {"full_name": "List.last_ofFn", "code": "theorem last_ofFn {n : \u2115} (f : Fin n \u2192 \u03b1) (h : ofFn f \u2260 [])\n    (hn : n - 1 < n := Nat.pred_lt <| ofFn_eq_nil_iff.not.mp h) :\n    getLast (ofFn f) h = f \u27e8n - 1, hn\u27e9", "start": [135, 1], "end": [137, 67], "kind": "commanddeclaration"}, {"full_name": "List.last_ofFn_succ", "code": "theorem last_ofFn_succ {n : \u2115} (f : Fin n.succ \u2192 \u03b1)\n    (h : ofFn f \u2260 [] := mt ofFn_eq_nil_iff.mp (Nat.succ_ne_zero _)) :\n    getLast (ofFn f) h = f (Fin.last _)", "start": [140, 1], "end": [143, 16], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_add", "code": "theorem ofFn_add {m n} (f : Fin (m + n) \u2192 \u03b1) :\n    List.ofFn f =\n      (List.ofFn fun i => f (Fin.castAdd n i)) ++ List.ofFn fun j => f (Fin.natAdd m j)", "start": [146, 1], "end": [154, 8], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_fin_append", "code": "@[simp]\ntheorem ofFn_fin_append {m n} (a : Fin m \u2192 \u03b1) (b : Fin n \u2192 \u03b1) :\n    List.ofFn (Fin.append a b) = List.ofFn a ++ List.ofFn b", "start": [157, 1], "end": [160, 56], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_mul", "code": "theorem ofFn_mul {m n} (f : Fin (m * n) \u2192 \u03b1) :\n    List.ofFn f = List.join (List.ofFn fun i : Fin m => List.ofFn fun j : Fin n => f \u27e8i * n + j,\n    calc\n      \u2191i * n + j < (i + 1) * n := (add_lt_add_left j.prop _).trans_eq (add_one_mul (_ : \u2115) _).symm\n      _ \u2264 _ := Nat.mul_le_mul_right _ i.prop\u27e9)", "start": [163, 1], "end": [172, 8], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_mul'", "code": "theorem ofFn_mul' {m n} (f : Fin (m * n) \u2192 \u03b1) :\n    List.ofFn f = List.join (List.ofFn fun i : Fin n => List.ofFn fun j : Fin m => f \u27e8m * i + j,\n    calc\n      m * i + j < m * (i + 1) := (add_lt_add_left j.prop _).trans_eq (mul_add_one (_ : \u2115) _).symm\n      _ \u2264 _ := Nat.mul_le_mul_left _ i.prop\u27e9)", "start": [175, 1], "end": [181, 60], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_get", "code": "theorem ofFn_get : \u2200 l : List \u03b1, (ofFn (get l)) = l", "start": [184, 1], "end": [189, 21], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_nthLe", "code": "@[deprecated ofFn_get]\ntheorem ofFn_nthLe : \u2200 l : List \u03b1, (ofFn fun i => nthLe l i i.2) = l", "start": [192, 1], "end": [194, 11], "kind": "commanddeclaration"}, {"full_name": "List.mem_ofFn", "code": "theorem mem_ofFn {n} (f : Fin n \u2192 \u03b1) (a : \u03b1) : a \u2208 ofFn f \u2194 a \u2208 Set.range f", "start": [199, 1], "end": [201, 95], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_ofFn_iff", "code": "@[simp]\ntheorem forall_mem_ofFn_iff {n : \u2115} {f : Fin n \u2192 \u03b1} {P : \u03b1 \u2192 Prop} :\n    (\u2200 i \u2208 ofFn f, P i) \u2194 \u2200 j : Fin n, P (f j)", "start": [204, 1], "end": [206, 96], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_const", "code": "@[simp]\ntheorem ofFn_const : \u2200 (n : \u2115) (c : \u03b1), (ofFn fun _ : Fin n => c) = replicate n c", "start": [209, 1], "end": [212, 54], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_fin_repeat", "code": "@[simp]\ntheorem ofFn_fin_repeat {m} (a : Fin m \u2192 \u03b1) (n : \u2115) :\n    List.ofFn (Fin.repeat n a) = (List.replicate n (List.ofFn a)).join", "start": [215, 1], "end": [219, 64], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_ofFn", "code": "@[simp]\ntheorem pairwise_ofFn {R : \u03b1 \u2192 \u03b1 \u2192 Prop} {n} {f : Fin n \u2192 \u03b1} :\n    (ofFn f).Pairwise R \u2194 \u2200 \u2983i j\u2984, i < j \u2192 R (f i) (f j)", "start": [222, 1], "end": [226, 37], "kind": "commanddeclaration"}, {"full_name": "List.equivSigmaTuple", "code": "@[simps]\ndef equivSigmaTuple : List \u03b1 \u2243 \u03a3n, Fin n \u2192 \u03b1 where\n  toFun l := \u27e8l.length, l.get\u27e9\n  invFun f := List.ofFn f.2\n  left_inv := List.ofFn_get\n  right_inv := fun \u27e8_, f\u27e9 =>\n    Fin.sigma_eq_of_eq_comp_cast (length_ofFn _) <| funext fun i => get_ofFn f i", "start": [229, 1], "end": [236, 81], "kind": "commanddeclaration"}, {"full_name": "List.ofFnRec", "code": "@[elab_as_elim]\ndef ofFnRec {C : List \u03b1 \u2192 Sort*} (h : \u2200 (n) (f : Fin n \u2192 \u03b1), C (List.ofFn f)) (l : List \u03b1) : C l :=\n  cast (congr_arg C l.ofFn_get) <|\n    h l.length l.get", "start": [242, 1], "end": [248, 21], "kind": "commanddeclaration"}, {"full_name": "List.ofFnRec_ofFn", "code": "@[simp]\ntheorem ofFnRec_ofFn {C : List \u03b1 \u2192 Sort*} (h : \u2200 (n) (f : Fin n \u2192 \u03b1), C (List.ofFn f)) {n : \u2115}\n    (f : Fin n \u2192 \u03b1) : @ofFnRec _ C h (List.ofFn f) = h _ f", "start": [251, 1], "end": [260, 23], "kind": "commanddeclaration"}, {"full_name": "List.exists_iff_exists_tuple", "code": "theorem exists_iff_exists_tuple {P : List \u03b1 \u2192 Prop} :\n    (\u2203 l : List \u03b1, P l) \u2194 \u2203 (n : _) (f : Fin n \u2192 \u03b1), P (List.ofFn f)", "start": [263, 1], "end": [265, 60], "kind": "commanddeclaration"}, {"full_name": "List.forall_iff_forall_tuple", "code": "theorem forall_iff_forall_tuple {P : List \u03b1 \u2192 Prop} :\n    (\u2200 l : List \u03b1, P l) \u2194 \u2200 (n) (f : Fin n \u2192 \u03b1), P (List.ofFn f)", "start": [268, 1], "end": [270, 60], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_inj'", "code": "theorem ofFn_inj' {m n : \u2115} {f : Fin m \u2192 \u03b1} {g : Fin n \u2192 \u03b1} :\n    ofFn f = ofFn g \u2194 (\u27e8m, f\u27e9 : \u03a3n, Fin n \u2192 \u03b1) = \u27e8n, g\u27e9", "start": [273, 1], "end": [276, 57], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_injective", "code": "theorem ofFn_injective {n : \u2115} : Function.Injective (ofFn : (Fin n \u2192 \u03b1) \u2192 List \u03b1)", "start": [279, 1], "end": [281, 51], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_inj", "code": "@[simp]\ntheorem ofFn_inj {n : \u2115} {f g : Fin n \u2192 \u03b1} : ofFn f = ofFn g \u2194 f = g", "start": [284, 1], "end": [287, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/CharZero.lean", "imports": ["Mathlib/Data/Int/Cast/Field.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.cast_eq_zero", "code": "@[simp]\ntheorem cast_eq_zero [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) = 0 \u2194 n = 0", "start": [22, 1], "end": [30, 35], "kind": "commanddeclaration"}, {"full_name": "Int.cast_inj", "code": "@[simp, norm_cast]\ntheorem cast_inj [AddGroupWithOne \u03b1] [CharZero \u03b1] {m n : \u2124} : (m : \u03b1) = n \u2194 m = n", "start": [33, 1], "end": [35, 60], "kind": "commanddeclaration"}, {"full_name": "Int.cast_injective", "code": "theorem cast_injective [AddGroupWithOne \u03b1] [CharZero \u03b1] : Function.Injective (Int.cast : \u2124 \u2192 \u03b1)", "start": [38, 1], "end": [39, 23], "kind": "commanddeclaration"}, {"full_name": "Int.cast_ne_zero", "code": "theorem cast_ne_zero [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) \u2260 0 \u2194 n \u2260 0", "start": [42, 1], "end": [43, 25], "kind": "commanddeclaration"}, {"full_name": "Int.cast_eq_one", "code": "@[simp]\ntheorem cast_eq_one [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) = 1 \u2194 n = 1", "start": [46, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "Int.cast_ne_one", "code": "theorem cast_ne_one [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) \u2260 1 \u2194 n \u2260 1", "start": [51, 1], "end": [52, 18], "kind": "commanddeclaration"}, {"full_name": "Int.cast_div_charZero", "code": "@[simp, norm_cast]\ntheorem cast_div_charZero {k : Type*} [DivisionRing k] [CharZero k] {m n : \u2124} (n_dvd : n \u2223 m) :\n    ((m / n : \u2124) : k) = m / n", "start": [55, 1], "end": [60, 47], "kind": "commanddeclaration"}, {"full_name": "Int.cast_div_ofNat_charZero", "code": "@[simp, norm_cast]\ntheorem cast_div_ofNat_charZero {k : Type*} [DivisionRing k] [CharZero k] {m n : \u2115}\n    (n_dvd : n \u2223 m) : (((m : \u2124) / (n : \u2124) : \u2124) : k) = m / n", "start": [64, 1], "end": [67, 75], "kind": "commanddeclaration"}, {"full_name": "RingHom.injective_int", "code": "theorem RingHom.injective_int {\u03b1 : Type*} [NonAssocRing \u03b1] (f : \u2124 \u2192+* \u03b1) [CharZero \u03b1] :\n    Function.Injective f", "start": [71, 1], "end": [73, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Positivity/Core.lean", "imports": ["Mathlib/Order/Basic.lean", "lake-packages/std/Std/Lean/Parser.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/HaveI.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Tactic/NormNum/Core.lean", "Mathlib/Algebra/Order/Invertible.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": [{"full_name": "ne_of_ne_of_eq'", "code": "lemma ne_of_ne_of_eq' (hab : (a : \u03b1) \u2260 c) (hbc : a = b) : b \u2260 c := hbc \u25b8 hab", "start": [33, 1], "end": [33, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.Strictness", "code": "inductive Strictness (e : Q($\u03b1)) where\n  | positive (pf : Q(0 < $e))\n  | nonnegative (pf : Q(0 \u2264 $e))\n  | nonzero (pf : Q($e \u2260 0))\n  | none\n  deriving Repr", "start": [39, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.Strictness.toString", "code": "def Strictness.toString : Strictness z\u03b1 p\u03b1 e \u2192 String\n  | positive _ => \"positive\"\n  | nonnegative _ => \"nonnegative\"\n  | nonzero _ => \"nonzero\"\n  | none => \"none\"", "start": [47, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.PositivityExt", "code": "structure PositivityExt where\n  \n  eval {u} {\u03b1 : Q(Type u)} (z\u03b1 : Q(Zero $\u03b1)) (p\u03b1 : Q(PartialOrder $\u03b1)) (e : Q($\u03b1)) :\n    MetaM (Strictness z\u03b1 p\u03b1 e)", "start": [54, 1], "end": [58, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.mkPositivityExt", "code": "def mkPositivityExt (n : Name) : ImportM PositivityExt := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck PositivityExt opts ``PositivityExt n", "start": [60, 1], "end": [63, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.Entry", "code": "abbrev Entry := Array (Array (DiscrTree.Key true)) \u00d7 Name", "start": [65, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.lt_of_le_of_ne'", "code": "lemma lt_of_le_of_ne' [PartialOrder A] :\n    (a : A) \u2264 b \u2192 b \u2260 a \u2192 a < b := fun h\u2081 h\u2082 => lt_of_le_of_ne h\u2081 h\u2082.symm", "start": [109, 1], "end": [110, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.pos_of_isNat", "code": "lemma pos_of_isNat [StrictOrderedSemiring A]\n    (h : NormNum.IsNat e n) (w : Nat.ble 1 n = true) : 0 < (e : A) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  apply Nat.cast_pos.2\n  simpa using w", "start": [112, 1], "end": [116, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.nonneg_of_isNat", "code": "lemma nonneg_of_isNat [OrderedSemiring A]\n    (h : NormNum.IsNat e n) : 0 \u2264 (e : A) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  exact Nat.cast_nonneg n", "start": [118, 1], "end": [121, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.nz_of_isNegNat", "code": "lemma nz_of_isNegNat [StrictOrderedRing A]\n    (h : NormNum.IsInt e (.negOfNat n)) (w : Nat.ble 1 n = true) : (e : A) \u2260 0 := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  simp only [ne_eq, neg_eq_zero]\n  apply ne_of_gt\n  simpa using w", "start": [123, 1], "end": [128, 16], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.pos_of_isRat", "code": "lemma pos_of_isRat [LinearOrderedRing A] :\n    (NormNum.IsRat e n d) \u2192 (decide (0 < n)) \u2192 ((0 : A) < (e : A))\n  | \u27e8inv, eq\u27e9, h => by\n    have pos_invOf_d : (0 < \u215f (d : A)) := pos_invOf_of_invertible_cast d\n    have pos_n : (0 < (n : A)) := Int.cast_pos (n := n) |>.2 (of_decide_eq_true h)\n    rw [eq]\n    exact mul_pos pos_n pos_invOf_d", "start": [130, 1], "end": [136, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.nonneg_of_isRat", "code": "lemma nonneg_of_isRat [LinearOrderedRing A] :\n    (NormNum.IsRat e n d) \u2192 (decide (n = 0)) \u2192 (0 \u2264 (e : A))\n  | \u27e8inv, eq\u27e9, h => by rw [eq, of_decide_eq_true h]; simp", "start": [138, 1], "end": [140, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.nz_of_isRat", "code": "lemma nz_of_isRat [LinearOrderedRing A] :\n    (NormNum.IsRat e n d) \u2192 (decide (n < 0)) \u2192 ((e : A) \u2260 0)\n  | \u27e8inv, eq\u27e9, h => by\n    have pos_invOf_d : (0 < \u215f (d : A)) := pos_invOf_of_invertible_cast d\n    have neg_n : ((n : A) < 0) := Int.cast_lt_zero (n := n) |>.2 (of_decide_eq_true h)\n    have neg := mul_neg_of_neg_of_pos neg_n pos_invOf_d\n    rw [eq]\n    exact ne_iff_lt_or_gt.2 (Or.inl neg)", "start": [142, 1], "end": [149, 41], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.catchNone", "code": "def catchNone (t : MetaM (Strictness z\u03b1 p\u03b1 e)) : MetaM (Strictness z\u03b1 p\u03b1 e) :=\n  try t catch e =>\n    trace[Tactic.positivity.failure] \"{e.toMessageData}\"\n    pure .none", "start": [152, 1], "end": [157, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.throwNone", "code": "def throwNone [Monad m] [Alternative m]\n    (t : m (Strictness z\u03b1 p\u03b1 e)) : m (Strictness z\u03b1 p\u03b1 e) := do\n  match \u2190 t with\n  | .none => failure\n  | r => pure r", "start": [160, 1], "end": [166, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.normNumPositivity", "code": "def normNumPositivity (e : Q($\u03b1)) : MetaM (Strictness z\u03b1 p\u03b1 e) := catchNone do\n  match \u2190 NormNum.derive e with\n  | .isBool .. => failure\n  | .isNat _ lit p =>\n    if 0 < lit.natLit! then\n      let _a \u2190 synthInstanceQ q(StrictOrderedSemiring $\u03b1)\n      assumeInstancesCommute\n      have p : Q(NormNum.IsNat $e $lit) := p\n      haveI' p' : Nat.ble 1 $lit =Q true := \u27e8\u27e9\n      pure (.positive q(@pos_of_isNat $\u03b1 _ _ _ $p $p'))\n    else\n      let _a \u2190 synthInstanceQ q(OrderedSemiring $\u03b1)\n      assumeInstancesCommute\n      have p : Q(NormNum.IsNat $e $lit) := p\n      pure (.nonnegative q(nonneg_of_isNat $p))\n  | .isNegNat _ lit p =>\n    let _a \u2190 synthInstanceQ q(StrictOrderedRing $\u03b1)\n    assumeInstancesCommute\n    have p : Q(NormNum.IsInt $e (Int.negOfNat $lit)) := p\n    haveI' p' : Nat.ble 1 $lit =Q true := \u27e8\u27e9\n    pure (.nonzero q(nz_of_isNegNat $p $p'))\n  | .isRat _i q n d p =>\n    let _a \u2190 synthInstanceQ q(LinearOrderedRing $\u03b1)\n    assumeInstancesCommute\n    have p : Q(NormNum.IsRat $e $n $d) := p\n    if 0 < q then\n      haveI' w : decide (0 < $n) =Q true := \u27e8\u27e9\n      pure (.positive q(pos_of_isRat $p $w))\n    else if q = 0 then haveI' w : decide ($n = 0) =Q true := \u27e8\u27e9\n      pure (.nonnegative q(nonneg_of_isRat $p $w))\n    else\n      haveI' w : decide ($n < 0) =Q true := \u27e8\u27e9\n      pure (.nonzero q(nz_of_isRat $p $w))", "start": [168, 1], "end": [202, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.positivityCanon", "code": "def positivityCanon (e : Q($\u03b1)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  let _i \u2190 synthInstanceQ (q(CanonicallyOrderedAddCommMonoid $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  pure (.nonnegative q(zero_le $e))", "start": [204, 1], "end": [208, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.compareHypLE", "code": "def compareHypLE (lo e : Q($\u03b1)) (p\u2082 : Q($lo \u2264 $e)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  match \u2190 normNumPositivity z\u03b1 p\u03b1 lo with\n  | .positive p\u2081 => pure (.positive q(lt_of_lt_of_le $p\u2081 $p\u2082))\n  | .nonnegative p\u2081 => pure (.nonnegative q(le_trans $p\u2081 $p\u2082))\n  | _ => pure .none", "start": [210, 1], "end": [215, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.compareHypLT", "code": "def compareHypLT (lo e : Q($\u03b1)) (p\u2082 : Q($lo < $e)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  match \u2190 normNumPositivity z\u03b1 p\u03b1 lo with\n  | .positive p\u2081 => pure (.positive q(lt_trans $p\u2081 $p\u2082))\n  | .nonnegative p\u2081 => pure (.positive q(lt_of_le_of_lt $p\u2081 $p\u2082))\n  | _ => pure .none", "start": [217, 1], "end": [222, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.compareHypEq", "code": "def compareHypEq (e a b : Q($\u03b1)) (p\u2082 : Q($a = $b)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  let .defEq _ \u2190 isDefEqQ e b | return .none\n  match \u2190 normNumPositivity z\u03b1 p\u03b1 a with\n  | .positive p\u2081 => pure (.positive q(lt_of_lt_of_eq $p\u2081 $p\u2082))\n  | .nonnegative p\u2081 => pure (.nonnegative q(le_of_le_of_eq $p\u2081 $p\u2082))\n  | .nonzero p\u2081 => pure (.nonzero q(ne_of_ne_of_eq' $p\u2081 $p\u2082))\n  | .none => pure .none", "start": [224, 1], "end": [231, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.compareHyp", "code": "def compareHyp (e : Q($\u03b1)) (ldecl : LocalDecl) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  have e' : Q(Prop) := ldecl.type\n  match e' with\n  | ~q(@LE.le _ $_a $lo $hi) =>\n    guard <| \u2190 isDefEq e hi\n    compareHypLE z\u03b1 p\u03b1 lo e (.fvar ldecl.fvarId)\n  | ~q(@LT.lt _ $_a $lo $hi) =>\n    guard <| \u2190 isDefEq e hi\n    compareHypLT z\u03b1 p\u03b1 lo e (.fvar ldecl.fvarId)\n  | ~q(($lo : $\u03b1') = $hi) =>\n    let .true \u2190 isDefEq \u03b1 \u03b1' | return .none\n    let p : Q($lo = $hi) := .fvar ldecl.fvarId\n    match \u2190 compareHypEq z\u03b1 p\u03b1 e lo hi p with\n    | .none => compareHypEq z\u03b1 p\u03b1 e hi lo (q(Eq.symm $p) : Expr)\n    | result => pure result\n  | ~q(($a : $\u03b1') \u2260 $b) =>\n    let .true \u2190 isDefEq \u03b1 \u03b1' | return .none\n    if \u2190 isDefEq q((0 : $\u03b1)) a then\n      let .true \u2190 isDefEq e b | return .none\n      let p : Q(0 \u2260 $e) := .fvar ldecl.fvarId\n      pure (.nonzero q(Ne.symm $p))\n    else\n      let .true \u2190 isDefEq q((0 : $\u03b1)) b | return .none\n      let .true \u2190 isDefEq e a | return .none\n      pure (.nonzero (.fvar ldecl.fvarId))\n  | _ => pure .none", "start": [236, 1], "end": [263, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.orElse", "code": "def orElse (t\u2081 : Strictness z\u03b1 p\u03b1 e) (t\u2082 : MetaM (Strictness z\u03b1 p\u03b1 e)) :\n    MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  match t\u2081 with\n  | .none => catchNone t\u2082\n  | p@(.positive _) => pure p\n  | .nonnegative p\u2081 =>\n    match \u2190 catchNone t\u2082 with\n    | p@(.positive _) => pure p\n    | .nonzero p\u2082 => pure (.positive q(lt_of_le_of_ne' $p\u2081 $p\u2082))\n    | _ => pure (.nonnegative p\u2081)\n  | .nonzero p\u2081 =>\n    match \u2190 catchNone t\u2082 with\n    | p@(.positive _) => pure p\n    | .nonnegative p\u2082 => pure (.positive q(lt_of_le_of_ne' $p\u2082 $p\u2081))\n    | _ => pure (.nonzero p\u2081)", "start": [266, 1], "end": [284, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.core", "code": "def core (e : Q($\u03b1)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n  let mut result := .none\n  trace[Tactic.positivity] \"trying to prove positivity of {e}\"\n  for ext in \u2190 (positivityExt.getState (\u2190 getEnv)).2.getMatch e do\n    try\n      result \u2190 orElse result <| ext.eval z\u03b1 p\u03b1 e\n    catch err =>\n      trace[Tactic.positivity] \"{e} failed: {err.toMessageData}\"\n  result \u2190 orElse result <| normNumPositivity z\u03b1 p\u03b1 e\n  result \u2190 orElse result <| positivityCanon z\u03b1 p\u03b1 e\n  if let .positive _ := result then\n    trace[Tactic.positivity] \"{e} => {result.toString}\"\n    return result\n  for ldecl in \u2190 getLCtx do\n    if !ldecl.isImplementationDetail then\n      result \u2190 orElse result <| compareHyp z\u03b1 p\u03b1 e ldecl\n  trace[Tactic.positivity] \"{e} => {result.toString}\"\n  throwNone (pure result)", "start": [286, 1], "end": [304, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.OrderRel", "code": "private inductive OrderRel : Type\n| le : OrderRel | lt : OrderRel | ne : OrderRel | ne' : OrderRel", "start": [306, 1], "end": [310, 17], "kind": "commanddeclaration"}, {"full_name": "Meta.Positivity.solve", "code": "def solve (t : Q(Prop)) : MetaM Expr := do\n  let rest {u : Level} (\u03b1 : Q(Type u)) z e (relDesired : OrderRel) : MetaM Expr := do\n    let z\u03b1 \u2190 synthInstanceQ q(Zero $\u03b1)\n    assumeInstancesCommute\n    let .true \u2190 isDefEq z q(0 : $\u03b1) | throwError \"not a positivity goal\"\n    let p\u03b1 \u2190 synthInstanceQ q(PartialOrder $\u03b1)\n    assumeInstancesCommute\n    let r \u2190 catchNone <| Meta.Positivity.core z\u03b1 p\u03b1 e\n    let throw (a b : String) : MetaM Expr := throwError\n      \"failed to prove {a}, but it would be possible to prove {b} if desired\"\n    let p \u2190 show MetaM Expr from match relDesired, r with\n    | .lt, .positive p\n    | .le, .nonnegative p\n    | .ne, .nonzero p => pure p\n    | .le, .positive p => pure q(le_of_lt $p)\n    | .ne, .positive p => pure q(ne_of_gt $p)\n    | .ne', .positive p => pure q(ne_of_lt $p)\n    | .ne', .nonzero p => pure q(Ne.symm $p)\n    | .lt, .nonnegative _ => throw \"strict positivity\" \"nonnegativity\"\n    | .lt, .nonzero _ => throw \"strict positivity\" \"nonzeroness\"\n    | .le, .nonzero _ => throw \"nonnegativity\" \"nonzeroness\"\n    | .ne, .nonnegative _\n    | .ne', .nonnegative _ => throw \"nonzeroness\" \"nonnegativity\"\n    | _, .none => throwError \"failed to prove positivity/nonnegativity/nonzeroness\"\n    pure p\n  match t with\n  | ~q(@LE.le $\u03b1 $_a $z $e) => rest \u03b1 z e .le\n  | ~q(@LT.lt $\u03b1 $_a $z $e) => rest \u03b1 z e .lt\n  | ~q($a \u2260 ($b : ($\u03b1 : Type _))) =>\n    let _z\u03b1 \u2190 synthInstanceQ (q(Zero $\u03b1) : Q(Type u_1))\n    if \u2190 isDefEq b q((0 : $\u03b1)) then\n      rest \u03b1 b a .ne\n    else\n      let .true \u2190 isDefEq a q((0 : $\u03b1)) | throwError \"not a positivity goal\"\n      rest \u03b1 a b .ne'\n  | _ => throwError \"not a positivity goal\"", "start": [315, 1], "end": [353, 44], "kind": "commanddeclaration"}, {"full_name": "Meta.Positivity.positivity", "code": "def positivity (goal : MVarId) : MetaM Unit := do\n  let t : Q(Prop) \u2190 withReducible goal.getType'\n  let p \u2190 solve t\n  goal.assign p", "start": [355, 1], "end": [361, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/Basic.lean", "imports": ["Mathlib/Algebra/Field/Basic.lean", "Mathlib/Data/Int/Cast/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Bounds/OrderIso.lean", "Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Algebra/Order/Field/Defs.lean"], "premises": [{"full_name": "OrderIso.mulLeft\u2080", "code": "@[simps! (config := { simpRhs := true })]\ndef OrderIso.mulLeft\u2080 (a : \u03b1) (ha : 0 < a) : \u03b1 \u2243o \u03b1 :=\n  { Equiv.mulLeft\u2080 a ha.ne' with map_rel_iff' := @fun _ _ => mul_le_mul_left ha }", "start": [27, 1], "end": [30, 82], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulRight\u2080", "code": "@[simps! (config := { simpRhs := true })]\ndef OrderIso.mulRight\u2080 (a : \u03b1) (ha : 0 < a) : \u03b1 \u2243o \u03b1 :=\n  { Equiv.mulRight\u2080 a ha.ne' with map_rel_iff' := @fun _ _ => mul_le_mul_right ha }", "start": [35, 1], "end": [38, 84], "kind": "commanddeclaration"}, {"full_name": "inv_pos", "code": "@[simp]\ntheorem inv_pos : 0 < a\u207b\u00b9 \u2194 0 < a", "start": [48, 1], "end": [51, 85], "kind": "commanddeclaration"}, {"full_name": "inv_pos_of_pos", "code": "alias \u27e8_, inv_pos_of_pos\u27e9 := inv_pos", "start": [54, 1], "end": [54, 37], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_nonneg", "code": "@[simp]\ntheorem inv_nonneg : 0 \u2264 a\u207b\u00b9 \u2194 0 \u2264 a", "start": [57, 1], "end": [59, 52], "kind": "commanddeclaration"}, {"full_name": "inv_nonneg_of_nonneg", "code": "alias \u27e8_, inv_nonneg_of_nonneg\u27e9 := inv_nonneg", "start": [62, 1], "end": [62, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_lt_zero", "code": "@[simp]\ntheorem inv_lt_zero : a\u207b\u00b9 < 0 \u2194 a < 0", "start": [65, 1], "end": [66, 77], "kind": "commanddeclaration"}, {"full_name": "inv_nonpos", "code": "@[simp]\ntheorem inv_nonpos : a\u207b\u00b9 \u2264 0 \u2194 a \u2264 0", "start": [69, 1], "end": [70, 73], "kind": "commanddeclaration"}, {"full_name": "one_div_pos", "code": "theorem one_div_pos : 0 < 1 / a \u2194 0 < a", "start": [73, 1], "end": [74, 29], "kind": "commanddeclaration"}, {"full_name": "one_div_neg", "code": "theorem one_div_neg : 1 / a < 0 \u2194 a < 0", "start": [77, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "one_div_nonneg", "code": "theorem one_div_nonneg : 0 \u2264 1 / a \u2194 0 \u2264 a", "start": [81, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "one_div_nonpos", "code": "theorem one_div_nonpos : 1 / a \u2264 0 \u2194 a \u2264 0", "start": [85, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "div_pos", "code": "theorem div_pos (ha : 0 < a) (hb : 0 < b) : 0 < a / b", "start": [89, 1], "end": [91, 34], "kind": "commanddeclaration"}, {"full_name": "div_nonneg", "code": "theorem div_nonneg (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a / b", "start": [94, 1], "end": [96, 40], "kind": "commanddeclaration"}, {"full_name": "div_nonpos_of_nonpos_of_nonneg", "code": "theorem div_nonpos_of_nonpos_of_nonneg (ha : a \u2264 0) (hb : 0 \u2264 b) : a / b \u2264 0", "start": [99, 1], "end": [101, 60], "kind": "commanddeclaration"}, {"full_name": "div_nonpos_of_nonneg_of_nonpos", "code": "theorem div_nonpos_of_nonneg_of_nonpos (ha : 0 \u2264 a) (hb : b \u2264 0) : a / b \u2264 0", "start": [104, 1], "end": [106, 60], "kind": "commanddeclaration"}, {"full_name": "zpow_nonneg", "code": "theorem zpow_nonneg (ha : 0 \u2264 a) : \u2200 n : \u2124, 0 \u2264 a ^ n", "start": [109, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "zpow_pos_of_pos", "code": "theorem zpow_pos_of_pos (ha : 0 < a) : \u2200 n : \u2124, 0 < a ^ n", "start": [118, 1], "end": [124, 23], "kind": "commanddeclaration"}, {"full_name": "le_div_iff", "code": "theorem le_div_iff (hc : 0 < c) : a \u2264 b / c \u2194 a * c \u2264 b", "start": [132, 1], "end": [138, 8], "kind": "commanddeclaration"}, {"full_name": "le_div_iff'", "code": "theorem le_div_iff' (hc : 0 < c) : a \u2264 b / c \u2194 c * a \u2264 b", "start": [141, 1], "end": [141, 92], "kind": "commanddeclaration"}, {"full_name": "div_le_iff", "code": "theorem div_le_iff (hb : 0 < b) : a / b \u2264 c \u2194 a \u2264 c * b", "start": [144, 1], "end": [156, 8], "kind": "commanddeclaration"}, {"full_name": "div_le_iff'", "code": "theorem div_le_iff' (hb : 0 < b) : a / b \u2264 c \u2194 a \u2264 b * c", "start": [159, 1], "end": [159, 92], "kind": "commanddeclaration"}, {"full_name": "lt_div_iff", "code": "theorem lt_div_iff (hc : 0 < c) : a < b / c \u2194 a * c < b", "start": [162, 1], "end": [163, 42], "kind": "commanddeclaration"}, {"full_name": "lt_div_iff'", "code": "theorem lt_div_iff' (hc : 0 < c) : a < b / c \u2194 c * a < b", "start": [166, 1], "end": [166, 92], "kind": "commanddeclaration"}, {"full_name": "div_lt_iff", "code": "theorem div_lt_iff (hc : 0 < c) : b / c < a \u2194 b < a * c", "start": [169, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "div_lt_iff'", "code": "theorem div_lt_iff' (hc : 0 < c) : b / c < a \u2194 b < c * a", "start": [173, 1], "end": [173, 92], "kind": "commanddeclaration"}, {"full_name": "inv_mul_le_iff", "code": "theorem inv_mul_le_iff (h : 0 < b) : b\u207b\u00b9 * a \u2264 c \u2194 a \u2264 b * c", "start": [176, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "inv_mul_le_iff'", "code": "theorem inv_mul_le_iff' (h : 0 < b) : b\u207b\u00b9 * a \u2264 c \u2194 a \u2264 c * b", "start": [181, 1], "end": [181, 100], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_iff", "code": "theorem mul_inv_le_iff (h : 0 < b) : a * b\u207b\u00b9 \u2264 c \u2194 a \u2264 b * c", "start": [184, 1], "end": [184, 99], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_iff'", "code": "theorem mul_inv_le_iff' (h : 0 < b) : a * b\u207b\u00b9 \u2264 c \u2194 a \u2264 c * b", "start": [187, 1], "end": [187, 101], "kind": "commanddeclaration"}, {"full_name": "div_self_le_one", "code": "theorem div_self_le_one (a : \u03b1) : a / a \u2264 1", "start": [190, 1], "end": [191, 49], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_iff", "code": "theorem inv_mul_lt_iff (h : 0 < b) : b\u207b\u00b9 * a < c \u2194 a < b * c", "start": [194, 1], "end": [196, 22], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_iff'", "code": "theorem inv_mul_lt_iff' (h : 0 < b) : b\u207b\u00b9 * a < c \u2194 a < c * b", "start": [199, 1], "end": [199, 100], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_iff", "code": "theorem mul_inv_lt_iff (h : 0 < b) : a * b\u207b\u00b9 < c \u2194 a < b * c", "start": [202, 1], "end": [202, 99], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_iff'", "code": "theorem mul_inv_lt_iff' (h : 0 < b) : a * b\u207b\u00b9 < c \u2194 a < c * b", "start": [205, 1], "end": [205, 101], "kind": "commanddeclaration"}, {"full_name": "inv_pos_le_iff_one_le_mul", "code": "theorem inv_pos_le_iff_one_le_mul (ha : 0 < a) : a\u207b\u00b9 \u2264 b \u2194 1 \u2264 b * a", "start": [208, 1], "end": [210, 22], "kind": "commanddeclaration"}, {"full_name": "inv_pos_le_iff_one_le_mul'", "code": "theorem inv_pos_le_iff_one_le_mul' (ha : 0 < a) : a\u207b\u00b9 \u2264 b \u2194 1 \u2264 a * b", "start": [213, 1], "end": [215, 23], "kind": "commanddeclaration"}, {"full_name": "inv_pos_lt_iff_one_lt_mul", "code": "theorem inv_pos_lt_iff_one_lt_mul (ha : 0 < a) : a\u207b\u00b9 < b \u2194 1 < b * a", "start": [218, 1], "end": [220, 22], "kind": "commanddeclaration"}, {"full_name": "inv_pos_lt_iff_one_lt_mul'", "code": "theorem inv_pos_lt_iff_one_lt_mul' (ha : 0 < a) : a\u207b\u00b9 < b \u2194 1 < a * b", "start": [223, 1], "end": [225, 23], "kind": "commanddeclaration"}, {"full_name": "div_le_of_nonneg_of_le_mul", "code": "theorem div_le_of_nonneg_of_le_mul (hb : 0 \u2264 b) (hc : 0 \u2264 c) (h : a \u2264 c * b) : a / b \u2264 c", "start": [228, 1], "end": [232, 23], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_nonneg_of_le_div", "code": "lemma mul_le_of_nonneg_of_le_div (hb : 0 \u2264 b) (hc : 0 \u2264 c) (h : a \u2264 b / c) : a * c \u2264 b := by\n  obtain rfl | hc := hc.eq_or_lt\n  \u00b7 simpa using hb\n  \u00b7 rwa [le_div_iff hc] at h", "start": [235, 1], "end": [239, 29], "kind": "mathlibtacticlemma"}, {"full_name": "div_le_one_of_le", "code": "theorem div_le_one_of_le (h : a \u2264 b) (hb : 0 \u2264 b) : a / b \u2264 1", "start": [242, 1], "end": [243, 64], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv_of_le", "code": "theorem inv_le_inv_of_le (ha : 0 < a) (h : a \u2264 b) : b\u207b\u00b9 \u2264 a\u207b\u00b9", "start": [251, 1], "end": [252, 91], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv", "code": "theorem inv_le_inv (ha : 0 < a) (hb : 0 < b) : a\u207b\u00b9 \u2264 b\u207b\u00b9 \u2194 b \u2264 a", "start": [255, 1], "end": [257, 74], "kind": "commanddeclaration"}, {"full_name": "inv_le", "code": "theorem inv_le (ha : 0 < a) (hb : 0 < b) : a\u207b\u00b9 \u2264 b \u2194 b\u207b\u00b9 \u2264 a", "start": [260, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "inv_le_of_inv_le", "code": "theorem inv_le_of_inv_le (ha : 0 < a) (h : a\u207b\u00b9 \u2264 b) : b\u207b\u00b9 \u2264 a", "start": [266, 1], "end": [267, 46], "kind": "commanddeclaration"}, {"full_name": "le_inv", "code": "theorem le_inv (ha : 0 < a) (hb : 0 < b) : a \u2264 b\u207b\u00b9 \u2194 b \u2264 a\u207b\u00b9", "start": [270, 1], "end": [271, 47], "kind": "commanddeclaration"}, {"full_name": "inv_lt_inv", "code": "theorem inv_lt_inv (ha : 0 < a) (hb : 0 < b) : a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a", "start": [274, 1], "end": [276, 44], "kind": "commanddeclaration"}, {"full_name": "inv_lt_inv_of_lt", "code": "theorem inv_lt_inv_of_lt (hb : 0 < b) (h : b < a) : a\u207b\u00b9 < b\u207b\u00b9", "start": [279, 1], "end": [280, 35], "kind": "commanddeclaration"}, {"full_name": "inv_lt", "code": "theorem inv_lt (ha : 0 < a) (hb : 0 < b) : a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a", "start": [283, 1], "end": [286, 40], "kind": "commanddeclaration"}, {"full_name": "inv_lt_of_inv_lt", "code": "theorem inv_lt_of_inv_lt (ha : 0 < a) (h : a\u207b\u00b9 < b) : b\u207b\u00b9 < a", "start": [289, 1], "end": [290, 43], "kind": "commanddeclaration"}, {"full_name": "lt_inv", "code": "theorem lt_inv (ha : 0 < a) (hb : 0 < b) : a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9", "start": [293, 1], "end": [294, 40], "kind": "commanddeclaration"}, {"full_name": "inv_lt_one", "code": "theorem inv_lt_one (ha : 1 < a) : a\u207b\u00b9 < 1", "start": [297, 1], "end": [298, 59], "kind": "commanddeclaration"}, {"full_name": "one_lt_inv", "code": "theorem one_lt_inv (h\u2081 : 0 < a) (h\u2082 : a < 1) : 1 < a\u207b\u00b9", "start": [301, 1], "end": [302, 54], "kind": "commanddeclaration"}, {"full_name": "inv_le_one", "code": "theorem inv_le_one (ha : 1 \u2264 a) : a\u207b\u00b9 \u2264 1", "start": [305, 1], "end": [306, 62], "kind": "commanddeclaration"}, {"full_name": "one_le_inv", "code": "theorem one_le_inv (h\u2081 : 0 < a) (h\u2082 : a \u2264 1) : 1 \u2264 a\u207b\u00b9", "start": [309, 1], "end": [310, 54], "kind": "commanddeclaration"}, {"full_name": "inv_lt_one_iff_of_pos", "code": "theorem inv_lt_one_iff_of_pos (h\u2080 : 0 < a) : a\u207b\u00b9 < 1 \u2194 1 < a", "start": [313, 1], "end": [314, 67], "kind": "commanddeclaration"}, {"full_name": "inv_lt_one_iff", "code": "theorem inv_lt_one_iff : a\u207b\u00b9 < 1 \u2194 a \u2264 0 \u2228 1 < a", "start": [317, 1], "end": [320, 66], "kind": "commanddeclaration"}, {"full_name": "one_lt_inv_iff", "code": "theorem one_lt_inv_iff : 1 < a\u207b\u00b9 \u2194 0 < a \u2227 a < 1", "start": [323, 1], "end": [324, 95], "kind": "commanddeclaration"}, {"full_name": "inv_le_one_iff", "code": "theorem inv_le_one_iff : a\u207b\u00b9 \u2264 1 \u2194 a \u2264 0 \u2228 1 \u2264 a", "start": [327, 1], "end": [330, 93], "kind": "commanddeclaration"}, {"full_name": "one_le_inv_iff", "code": "theorem one_le_inv_iff : 1 \u2264 a\u207b\u00b9 \u2194 0 < a \u2227 a \u2264 1", "start": [333, 1], "end": [334, 98], "kind": "commanddeclaration"}, {"full_name": "div_le_div_of_le", "code": "@[mono]\ntheorem div_le_div_of_le (hc : 0 \u2264 c) (h : a \u2264 b) : a / c \u2264 b / c", "start": [342, 1], "end": [345, 59], "kind": "commanddeclaration"}, {"full_name": "div_le_div_of_le_left", "code": "theorem div_le_div_of_le_left (ha : 0 \u2264 a) (hc : 0 < c) (h : c \u2264 b) : a / b \u2264 a / c", "start": [349, 1], "end": [351, 77], "kind": "commanddeclaration"}, {"full_name": "div_le_div_of_le_of_nonneg", "code": "theorem div_le_div_of_le_of_nonneg (hab : a \u2264 b) (hc : 0 \u2264 c) : a / c \u2264 b / c", "start": [354, 1], "end": [355, 26], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_of_lt", "code": "theorem div_lt_div_of_lt (hc : 0 < c) (h : a < b) : a / c < b / c", "start": [358, 1], "end": [360, 53], "kind": "commanddeclaration"}, {"full_name": "div_le_div_right", "code": "theorem div_le_div_right (hc : 0 < c) : a / c \u2264 b / c \u2194 a \u2264 b", "start": [363, 1], "end": [364, 77], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_right", "code": "theorem div_lt_div_right (hc : 0 < c) : a / c < b / c \u2194 a < b", "start": [367, 1], "end": [368, 48], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_left", "code": "theorem div_lt_div_left (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : a / b < a / c \u2194 c < b", "start": [371, 1], "end": [372, 67], "kind": "commanddeclaration"}, {"full_name": "div_le_div_left", "code": "theorem div_le_div_left (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) : a / b \u2264 a / c \u2194 c \u2264 b", "start": [375, 1], "end": [376, 55], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_iff", "code": "theorem div_lt_div_iff (b0 : 0 < b) (d0 : 0 < d) : a / b < c / d \u2194 a * d < c * b", "start": [379, 1], "end": [380, 56], "kind": "commanddeclaration"}, {"full_name": "div_le_div_iff", "code": "theorem div_le_div_iff (b0 : 0 < b) (d0 : 0 < d) : a / b \u2264 c / d \u2194 a * d \u2264 c * b", "start": [383, 1], "end": [384, 56], "kind": "commanddeclaration"}, {"full_name": "div_le_div", "code": "@[mono]\ntheorem div_le_div (hc : 0 \u2264 c) (hac : a \u2264 c) (hd : 0 < d) (hbd : d \u2264 b) : a / b \u2264 c / d", "start": [387, 1], "end": [390, 36], "kind": "commanddeclaration"}, {"full_name": "div_lt_div", "code": "theorem div_lt_div (hac : a < c) (hbd : d \u2264 b) (c0 : 0 \u2264 c) (d0 : 0 < d) : a / b < c / d", "start": [393, 1], "end": [394, 69], "kind": "commanddeclaration"}, {"full_name": "div_lt_div'", "code": "theorem div_lt_div' (hac : a \u2264 c) (hbd : d < b) (c0 : 0 < c) (d0 : 0 < d) : a / b < c / d", "start": [397, 1], "end": [398, 70], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_of_lt_left", "code": "theorem div_lt_div_of_lt_left (hc : 0 < c) (hb : 0 < b) (h : b < a) : c / a < c / b", "start": [401, 1], "end": [402, 45], "kind": "commanddeclaration"}, {"full_name": "div_le_self", "code": "theorem div_le_self (ha : 0 \u2264 a) (hb : 1 \u2264 b) : a / b \u2264 a", "start": [410, 1], "end": [411, 69], "kind": "commanddeclaration"}, {"full_name": "div_lt_self", "code": "theorem div_lt_self (ha : 0 < a) (hb : 1 < b) : a / b < a", "start": [414, 1], "end": [415, 69], "kind": "commanddeclaration"}, {"full_name": "le_div_self", "code": "theorem le_div_self (ha : 0 \u2264 a) (hb\u2080 : 0 < b) (hb\u2081 : b \u2264 1) : a \u2264 a / b", "start": [418, 1], "end": [419, 62], "kind": "commanddeclaration"}, {"full_name": "one_le_div", "code": "theorem one_le_div (hb : 0 < b) : 1 \u2264 a / b \u2194 b \u2264 a", "start": [422, 1], "end": [422, 86], "kind": "commanddeclaration"}, {"full_name": "div_le_one", "code": "theorem div_le_one (hb : 0 < b) : a / b \u2264 1 \u2194 a \u2264 b", "start": [425, 1], "end": [425, 86], "kind": "commanddeclaration"}, {"full_name": "one_lt_div", "code": "theorem one_lt_div (hb : 0 < b) : 1 < a / b \u2194 b < a", "start": [428, 1], "end": [428, 86], "kind": "commanddeclaration"}, {"full_name": "div_lt_one", "code": "theorem div_lt_one (hb : 0 < b) : a / b < 1 \u2194 a < b", "start": [431, 1], "end": [431, 86], "kind": "commanddeclaration"}, {"full_name": "one_div_le", "code": "theorem one_div_le (ha : 0 < a) (hb : 0 < b) : 1 / a \u2264 b \u2194 1 / b \u2264 a", "start": [434, 1], "end": [434, 100], "kind": "commanddeclaration"}, {"full_name": "one_div_lt", "code": "theorem one_div_lt (ha : 0 < a) (hb : 0 < b) : 1 / a < b \u2194 1 / b < a", "start": [437, 1], "end": [437, 100], "kind": "commanddeclaration"}, {"full_name": "le_one_div", "code": "theorem le_one_div (ha : 0 < a) (hb : 0 < b) : a \u2264 1 / b \u2194 b \u2264 1 / a", "start": [440, 1], "end": [440, 100], "kind": "commanddeclaration"}, {"full_name": "lt_one_div", "code": "theorem lt_one_div (ha : 0 < a) (hb : 0 < b) : a < 1 / b \u2194 b < 1 / a", "start": [443, 1], "end": [443, 100], "kind": "commanddeclaration"}, {"full_name": "one_div_le_one_div_of_le", "code": "theorem one_div_le_one_div_of_le (ha : 0 < a) (h : a \u2264 b) : 1 / b \u2264 1 / a", "start": [451, 1], "end": [452, 36], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_one_div_of_lt", "code": "theorem one_div_lt_one_div_of_lt (ha : 0 < a) (h : a < b) : 1 / b < 1 / a", "start": [455, 1], "end": [456, 70], "kind": "commanddeclaration"}, {"full_name": "le_of_one_div_le_one_div", "code": "theorem le_of_one_div_le_one_div (ha : 0 < a) (h : 1 / a \u2264 1 / b) : b \u2264 a", "start": [459, 1], "end": [460, 57], "kind": "commanddeclaration"}, {"full_name": "lt_of_one_div_lt_one_div", "code": "theorem lt_of_one_div_lt_one_div (ha : 0 < a) (h : 1 / a < 1 / b) : b < a", "start": [463, 1], "end": [464, 57], "kind": "commanddeclaration"}, {"full_name": "one_div_le_one_div", "code": "theorem one_div_le_one_div (ha : 0 < a) (hb : 0 < b) : 1 / a \u2264 1 / b \u2194 b \u2264 a", "start": [467, 1], "end": [470, 36], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_one_div", "code": "theorem one_div_lt_one_div (ha : 0 < a) (hb : 0 < b) : 1 / a < 1 / b \u2194 b < a", "start": [473, 1], "end": [476, 36], "kind": "commanddeclaration"}, {"full_name": "one_lt_one_div", "code": "theorem one_lt_one_div (h1 : 0 < a) (h2 : a < 1) : 1 < 1 / a", "start": [479, 1], "end": [480, 62], "kind": "commanddeclaration"}, {"full_name": "one_le_one_div", "code": "theorem one_le_one_div (h1 : 0 < a) (h2 : a \u2264 1) : 1 \u2264 1 / a", "start": [483, 1], "end": [484, 62], "kind": "commanddeclaration"}, {"full_name": "add_halves", "code": "theorem add_halves (a : \u03b1) : a / 2 + a / 2 = a", "start": [495, 1], "end": [496, 70], "kind": "commanddeclaration"}, {"full_name": "add_self_div_two", "code": "theorem add_self_div_two (a : \u03b1) : (a + a) / 2 = a", "start": [500, 1], "end": [501, 47], "kind": "commanddeclaration"}, {"full_name": "half_pos", "code": "theorem half_pos (h : 0 < a) : 0 < a / 2", "start": [504, 1], "end": [505, 24], "kind": "commanddeclaration"}, {"full_name": "one_half_pos", "code": "theorem one_half_pos : (0 : \u03b1) < 1 / 2", "start": [508, 1], "end": [509, 23], "kind": "commanddeclaration"}, {"full_name": "half_le_self_iff", "code": "@[simp]\ntheorem half_le_self_iff : a / 2 \u2264 a \u2194 0 \u2264 a", "start": [512, 1], "end": [514, 68], "kind": "commanddeclaration"}, {"full_name": "half_lt_self_iff", "code": "@[simp]\ntheorem half_lt_self_iff : a / 2 < a \u2194 0 < a", "start": [517, 1], "end": [519, 65], "kind": "commanddeclaration"}, {"full_name": "half_le_self", "code": "alias \u27e8_, half_le_self\u27e9 := half_le_self_iff", "start": [522, 1], "end": [522, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "half_lt_self", "code": "alias \u27e8_, half_lt_self\u27e9 := half_lt_self_iff", "start": [525, 1], "end": [525, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_two_lt_of_pos", "code": "alias div_two_lt_of_pos := half_lt_self", "start": [528, 1], "end": [528, 40], "kind": "stdtacticaliasalias"}, {"full_name": "one_half_lt_one", "code": "theorem one_half_lt_one : (1 / 2 : \u03b1) < 1", "start": [531, 1], "end": [532, 27], "kind": "commanddeclaration"}, {"full_name": "two_inv_lt_one", "code": "theorem two_inv_lt_one : (2\u207b\u00b9 : \u03b1) < 1", "start": [535, 1], "end": [536, 44], "kind": "commanddeclaration"}, {"full_name": "left_lt_add_div_two", "code": "theorem left_lt_add_div_two : a < (a + b) / 2 \u2194 a < b", "start": [539, 1], "end": [539, 87], "kind": "commanddeclaration"}, {"full_name": "add_div_two_lt_right", "code": "theorem add_div_two_lt_right : (a + b) / 2 < b \u2194 a < b", "start": [542, 1], "end": [542, 88], "kind": "commanddeclaration"}, {"full_name": "add_thirds", "code": "theorem add_thirds (a : \u03b1) : a / 3 + a / 3 + a / 3 = a", "start": [545, 1], "end": [547, 41], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_mul_div_le", "code": "theorem mul_le_mul_of_mul_div_le (h : a * (b / c) \u2264 d) (hc : 0 < c) : b * a \u2264 d * c", "start": [554, 1], "end": [556, 36], "kind": "commanddeclaration"}, {"full_name": "div_mul_le_div_mul_of_div_le_div", "code": "theorem div_mul_le_div_mul_of_div_le_div (h : a / b \u2264 c / d) (he : 0 \u2264 e) :\n    a / (b * e) \u2264 c / (d * e)", "start": [559, 1], "end": [562, 59], "kind": "commanddeclaration"}, {"full_name": "exists_pos_mul_lt", "code": "theorem exists_pos_mul_lt {a : \u03b1} (h : 0 < a) (b : \u03b1) : \u2203 c : \u03b1, 0 < c \u2227 b * c < a", "start": [565, 1], "end": [569, 46], "kind": "commanddeclaration"}, {"full_name": "exists_pos_lt_mul", "code": "theorem exists_pos_lt_mul {a : \u03b1} (h : 0 < a) (b : \u03b1) : \u2203 c : \u03b1, 0 < c \u2227 b < c * a", "start": [572, 1], "end": [574, 66], "kind": "commanddeclaration"}, {"full_name": "Monotone.div_const", "code": "theorem Monotone.div_const {\u03b2 : Type*} [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : Monotone f) {c : \u03b1}\n    (hc : 0 \u2264 c) : Monotone fun x => f x / c", "start": [577, 1], "end": [580, 93], "kind": "commanddeclaration"}, {"full_name": "StrictMono.div_const", "code": "theorem StrictMono.div_const {\u03b2 : Type*} [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : StrictMono f) {c : \u03b1}\n    (hc : 0 < c) : StrictMono fun x => f x / c", "start": [583, 1], "end": [585, 64], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemiField.toDenselyOrdered", "code": "instance (priority := 100) LinearOrderedSemiField.toDenselyOrdered : DenselyOrdered \u03b1 where\n  dense a\u2081 a\u2082 h :=\n    \u27e8(a\u2081 + a\u2082) / 2,\n      calc\n        a\u2081 = (a\u2081 + a\u2081) / 2 := (add_self_div_two a\u2081).symm\n        _ < (a\u2081 + a\u2082) / 2 := div_lt_div_of_lt zero_lt_two (add_lt_add_left h _)\n        ,\n      calc\n        (a\u2081 + a\u2082) / 2 < (a\u2082 + a\u2082) / 2 := div_lt_div_of_lt zero_lt_two (add_lt_add_right h _)\n        _ = a\u2082 := add_self_div_two a\u2082\n        \u27e9", "start": [589, 1], "end": [599, 10], "kind": "commanddeclaration"}, {"full_name": "min_div_div_right", "code": "theorem min_div_div_right {c : \u03b1} (hc : 0 \u2264 c) (a b : \u03b1) : min (a / c) (b / c) = min a b / c", "start": [602, 1], "end": [603, 61], "kind": "commanddeclaration"}, {"full_name": "max_div_div_right", "code": "theorem max_div_div_right {c : \u03b1} (hc : 0 \u2264 c) (a b : \u03b1) : max (a / c) (b / c) = max a b / c", "start": [606, 1], "end": [607, 61], "kind": "commanddeclaration"}, {"full_name": "one_div_strictAntiOn", "code": "theorem one_div_strictAntiOn : StrictAntiOn (fun x : \u03b1 => 1 / x) (Set.Ioi 0)", "start": [610, 1], "end": [611, 90], "kind": "commanddeclaration"}, {"full_name": "one_div_pow_le_one_div_pow_of_le", "code": "theorem one_div_pow_le_one_div_pow_of_le (a1 : 1 \u2264 a) {m n : \u2115} (mn : m \u2264 n) :\n    1 / a ^ n \u2264 1 / a ^ m", "start": [614, 1], "end": [617, 46], "kind": "commanddeclaration"}, {"full_name": "one_div_pow_lt_one_div_pow_of_lt", "code": "theorem one_div_pow_lt_one_div_pow_of_lt (a1 : 1 < a) {m n : \u2115} (mn : m < n) :\n    1 / a ^ n < 1 / a ^ m", "start": [620, 1], "end": [622, 101], "kind": "commanddeclaration"}, {"full_name": "one_div_pow_anti", "code": "theorem one_div_pow_anti (a1 : 1 \u2264 a) : Antitone fun n : \u2115 => 1 / a ^ n", "start": [625, 1], "end": [626, 38], "kind": "commanddeclaration"}, {"full_name": "one_div_pow_strictAnti", "code": "theorem one_div_pow_strictAnti (a1 : 1 < a) : StrictAnti fun n : \u2115 => 1 / a ^ n", "start": [629, 1], "end": [630, 38], "kind": "commanddeclaration"}, {"full_name": "inv_strictAntiOn", "code": "theorem inv_strictAntiOn : StrictAntiOn (fun x : \u03b1 => x\u207b\u00b9) (Set.Ioi 0)", "start": [633, 1], "end": [634, 26], "kind": "commanddeclaration"}, {"full_name": "inv_pow_le_inv_pow_of_le", "code": "theorem inv_pow_le_inv_pow_of_le (a1 : 1 \u2264 a) {m n : \u2115} (mn : m \u2264 n) : (a ^ n)\u207b\u00b9 \u2264 (a ^ m)\u207b\u00b9", "start": [637, 1], "end": [638, 66], "kind": "commanddeclaration"}, {"full_name": "inv_pow_lt_inv_pow_of_lt", "code": "theorem inv_pow_lt_inv_pow_of_lt (a1 : 1 < a) {m n : \u2115} (mn : m < n) : (a ^ n)\u207b\u00b9 < (a ^ m)\u207b\u00b9", "start": [641, 1], "end": [642, 66], "kind": "commanddeclaration"}, {"full_name": "inv_pow_anti", "code": "theorem inv_pow_anti (a1 : 1 \u2264 a) : Antitone fun n : \u2115 => (a ^ n)\u207b\u00b9", "start": [645, 1], "end": [646, 30], "kind": "commanddeclaration"}, {"full_name": "inv_pow_strictAnti", "code": "theorem inv_pow_strictAnti (a1 : 1 < a) : StrictAnti fun n : \u2115 => (a ^ n)\u207b\u00b9", "start": [649, 1], "end": [650, 30], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mul_left", "code": "theorem IsGLB.mul_left {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsGLB s b) :\n    IsGLB ((fun b => a * b) '' s) (a * b)", "start": [656, 1], "end": [662, 26], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mul_right", "code": "theorem IsGLB.mul_right {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsGLB s b) :\n    IsGLB ((fun b => b * a) '' s) (b * a)", "start": [665, 1], "end": [666, 86], "kind": "commanddeclaration"}, {"full_name": "div_pos_iff", "code": "theorem div_pos_iff : 0 < a / b \u2194 0 < a \u2227 0 < b \u2228 a < 0 \u2227 b < 0", "start": [678, 1], "end": [679, 62], "kind": "commanddeclaration"}, {"full_name": "div_neg_iff", "code": "theorem div_neg_iff : a / b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b", "start": [682, 1], "end": [683, 35], "kind": "commanddeclaration"}, {"full_name": "div_nonneg_iff", "code": "theorem div_nonneg_iff : 0 \u2264 a / b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "start": [686, 1], "end": [687, 38], "kind": "commanddeclaration"}, {"full_name": "div_nonpos_iff", "code": "theorem div_nonpos_iff : a / b \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b", "start": [690, 1], "end": [691, 38], "kind": "commanddeclaration"}, {"full_name": "div_nonneg_of_nonpos", "code": "theorem div_nonneg_of_nonpos (ha : a \u2264 0) (hb : b \u2264 0) : 0 \u2264 a / b", "start": [694, 1], "end": [695, 38], "kind": "commanddeclaration"}, {"full_name": "div_pos_of_neg_of_neg", "code": "theorem div_pos_of_neg_of_neg (ha : a < 0) (hb : b < 0) : 0 < a / b", "start": [698, 1], "end": [699, 35], "kind": "commanddeclaration"}, {"full_name": "div_neg_of_neg_of_pos", "code": "theorem div_neg_of_neg_of_pos (ha : a < 0) (hb : 0 < b) : a / b < 0", "start": [702, 1], "end": [703, 35], "kind": "commanddeclaration"}, {"full_name": "div_neg_of_pos_of_neg", "code": "theorem div_neg_of_pos_of_neg (ha : 0 < a) (hb : b < 0) : a / b < 0", "start": [706, 1], "end": [707, 35], "kind": "commanddeclaration"}, {"full_name": "div_le_iff_of_neg", "code": "theorem div_le_iff_of_neg (hc : c < 0) : b / c \u2264 a \u2194 a * c \u2264 b", "start": [713, 1], "end": [719, 8], "kind": "commanddeclaration"}, {"full_name": "div_le_iff_of_neg'", "code": "theorem div_le_iff_of_neg' (hc : c < 0) : b / c \u2264 a \u2194 c * a \u2264 b", "start": [722, 1], "end": [723, 38], "kind": "commanddeclaration"}, {"full_name": "le_div_iff_of_neg", "code": "theorem le_div_iff_of_neg (hc : c < 0) : a \u2264 b / c \u2194 b \u2264 a * c", "start": [726, 1], "end": [727, 81], "kind": "commanddeclaration"}, {"full_name": "le_div_iff_of_neg'", "code": "theorem le_div_iff_of_neg' (hc : c < 0) : a \u2264 b / c \u2194 b \u2264 c * a", "start": [730, 1], "end": [731, 38], "kind": "commanddeclaration"}, {"full_name": "div_lt_iff_of_neg", "code": "theorem div_lt_iff_of_neg (hc : c < 0) : b / c < a \u2194 a * c < b", "start": [734, 1], "end": [735, 49], "kind": "commanddeclaration"}, {"full_name": "div_lt_iff_of_neg'", "code": "theorem div_lt_iff_of_neg' (hc : c < 0) : b / c < a \u2194 c * a < b", "start": [738, 1], "end": [739, 38], "kind": "commanddeclaration"}, {"full_name": "lt_div_iff_of_neg", "code": "theorem lt_div_iff_of_neg (hc : c < 0) : a < b / c \u2194 b < a * c", "start": [742, 1], "end": [743, 49], "kind": "commanddeclaration"}, {"full_name": "lt_div_iff_of_neg'", "code": "theorem lt_div_iff_of_neg' (hc : c < 0) : a < b / c \u2194 b < c * a", "start": [746, 1], "end": [747, 38], "kind": "commanddeclaration"}, {"full_name": "div_le_one_of_ge", "code": "theorem div_le_one_of_ge (h : b \u2264 a) (hb : b \u2264 0) : a / b \u2264 1", "start": [750, 1], "end": [751, 94], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv_of_neg", "code": "theorem inv_le_inv_of_neg (ha : a < 0) (hb : b < 0) : a\u207b\u00b9 \u2264 b\u207b\u00b9 \u2194 b \u2264 a", "start": [757, 1], "end": [758, 88], "kind": "commanddeclaration"}, {"full_name": "inv_le_of_neg", "code": "theorem inv_le_of_neg (ha : a < 0) (hb : b < 0) : a\u207b\u00b9 \u2264 b \u2194 b\u207b\u00b9 \u2264 a", "start": [761, 1], "end": [762, 58], "kind": "commanddeclaration"}, {"full_name": "le_inv_of_neg", "code": "theorem le_inv_of_neg (ha : a < 0) (hb : b < 0) : a \u2264 b\u207b\u00b9 \u2194 b \u2264 a\u207b\u00b9", "start": [765, 1], "end": [766, 58], "kind": "commanddeclaration"}, {"full_name": "inv_lt_inv_of_neg", "code": "theorem inv_lt_inv_of_neg (ha : a < 0) (hb : b < 0) : a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a", "start": [769, 1], "end": [770, 51], "kind": "commanddeclaration"}, {"full_name": "inv_lt_of_neg", "code": "theorem inv_lt_of_neg (ha : a < 0) (hb : b < 0) : a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a", "start": [773, 1], "end": [774, 47], "kind": "commanddeclaration"}, {"full_name": "lt_inv_of_neg", "code": "theorem lt_inv_of_neg (ha : a < 0) (hb : b < 0) : a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9", "start": [777, 1], "end": [778, 47], "kind": "commanddeclaration"}, {"full_name": "div_le_div_of_nonpos_of_le", "code": "theorem div_le_div_of_nonpos_of_le (hc : c \u2264 0) (h : b \u2264 a) : a / c \u2264 b / c", "start": [784, 1], "end": [786, 59], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_of_neg_of_lt", "code": "theorem div_lt_div_of_neg_of_lt (hc : c < 0) (h : b < a) : a / c < b / c", "start": [789, 1], "end": [791, 53], "kind": "commanddeclaration"}, {"full_name": "div_le_div_right_of_neg", "code": "theorem div_le_div_right_of_neg (hc : c < 0) : a / c \u2264 b / c \u2194 b \u2264 a", "start": [794, 1], "end": [795, 94], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_right_of_neg", "code": "theorem div_lt_div_right_of_neg (hc : c < 0) : a / c < b / c \u2194 b < a", "start": [798, 1], "end": [799, 55], "kind": "commanddeclaration"}, {"full_name": "one_le_div_of_neg", "code": "theorem one_le_div_of_neg (hb : b < 0) : 1 \u2264 a / b \u2194 a \u2264 b", "start": [805, 1], "end": [805, 100], "kind": "commanddeclaration"}, {"full_name": "div_le_one_of_neg", "code": "theorem div_le_one_of_neg (hb : b < 0) : a / b \u2264 1 \u2194 b \u2264 a", "start": [808, 1], "end": [808, 100], "kind": "commanddeclaration"}, {"full_name": "one_lt_div_of_neg", "code": "theorem one_lt_div_of_neg (hb : b < 0) : 1 < a / b \u2194 a < b", "start": [811, 1], "end": [811, 100], "kind": "commanddeclaration"}, {"full_name": "div_lt_one_of_neg", "code": "theorem div_lt_one_of_neg (hb : b < 0) : a / b < 1 \u2194 b < a", "start": [814, 1], "end": [814, 100], "kind": "commanddeclaration"}, {"full_name": "one_div_le_of_neg", "code": "theorem one_div_le_of_neg (ha : a < 0) (hb : b < 0) : 1 / a \u2264 b \u2194 1 / b \u2264 a", "start": [817, 1], "end": [818, 34], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_of_neg", "code": "theorem one_div_lt_of_neg (ha : a < 0) (hb : b < 0) : 1 / a < b \u2194 1 / b < a", "start": [821, 1], "end": [822, 34], "kind": "commanddeclaration"}, {"full_name": "le_one_div_of_neg", "code": "theorem le_one_div_of_neg (ha : a < 0) (hb : b < 0) : a \u2264 1 / b \u2194 b \u2264 1 / a", "start": [825, 1], "end": [826, 34], "kind": "commanddeclaration"}, {"full_name": "lt_one_div_of_neg", "code": "theorem lt_one_div_of_neg (ha : a < 0) (hb : b < 0) : a < 1 / b \u2194 b < 1 / a", "start": [829, 1], "end": [830, 34], "kind": "commanddeclaration"}, {"full_name": "one_lt_div_iff", "code": "theorem one_lt_div_iff : 1 < a / b \u2194 0 < b \u2227 b < a \u2228 b < 0 \u2227 a < b", "start": [833, 1], "end": [837, 37], "kind": "commanddeclaration"}, {"full_name": "one_le_div_iff", "code": "theorem one_le_div_iff : 1 \u2264 a / b \u2194 0 < b \u2227 b \u2264 a \u2228 b < 0 \u2227 a \u2264 b", "start": [840, 1], "end": [844, 37], "kind": "commanddeclaration"}, {"full_name": "div_lt_one_iff", "code": "theorem div_lt_one_iff : a / b < 1 \u2194 0 < b \u2227 a < b \u2228 b = 0 \u2228 b < 0 \u2227 b < a", "start": [847, 1], "end": [851, 49], "kind": "commanddeclaration"}, {"full_name": "div_le_one_iff", "code": "theorem div_le_one_iff : a / b \u2264 1 \u2194 0 < b \u2227 a \u2264 b \u2228 b = 0 \u2228 b < 0 \u2227 b \u2264 a", "start": [854, 1], "end": [858, 49], "kind": "commanddeclaration"}, {"full_name": "one_div_le_one_div_of_neg_of_le", "code": "theorem one_div_le_one_div_of_neg_of_le (hb : b < 0) (h : a \u2264 b) : 1 / b \u2264 1 / a", "start": [864, 1], "end": [865, 87], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_one_div_of_neg_of_lt", "code": "theorem one_div_lt_one_div_of_neg_of_lt (hb : b < 0) (h : a < b) : 1 / b < 1 / a", "start": [868, 1], "end": [869, 84], "kind": "commanddeclaration"}, {"full_name": "le_of_neg_of_one_div_le_one_div", "code": "theorem le_of_neg_of_one_div_le_one_div (hb : b < 0) (h : 1 / a \u2264 1 / b) : b \u2264 a", "start": [872, 1], "end": [873, 64], "kind": "commanddeclaration"}, {"full_name": "lt_of_neg_of_one_div_lt_one_div", "code": "theorem lt_of_neg_of_one_div_lt_one_div (hb : b < 0) (h : 1 / a < 1 / b) : b < a", "start": [876, 1], "end": [877, 64], "kind": "commanddeclaration"}, {"full_name": "one_div_le_one_div_of_neg", "code": "theorem one_div_le_one_div_of_neg (ha : a < 0) (hb : b < 0) : 1 / a \u2264 1 / b \u2194 b \u2264 a", "start": [880, 1], "end": [883, 48], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_one_div_of_neg", "code": "theorem one_div_lt_one_div_of_neg (ha : a < 0) (hb : b < 0) : 1 / a < 1 / b \u2194 b < a", "start": [886, 1], "end": [889, 59], "kind": "commanddeclaration"}, {"full_name": "one_div_lt_neg_one", "code": "theorem one_div_lt_neg_one (h1 : a < 0) (h2 : -1 < a) : 1 / a < -1", "start": [892, 1], "end": [894, 40], "kind": "commanddeclaration"}, {"full_name": "one_div_le_neg_one", "code": "theorem one_div_le_neg_one (h1 : a < 0) (h2 : -1 \u2264 a) : 1 / a \u2264 -1", "start": [897, 1], "end": [899, 40], "kind": "commanddeclaration"}, {"full_name": "sub_self_div_two", "code": "theorem sub_self_div_two (a : \u03b1) : a - a / 2 = a / 2", "start": [905, 1], "end": [907, 22], "kind": "commanddeclaration"}, {"full_name": "div_two_sub_self", "code": "theorem div_two_sub_self (a : \u03b1) : a / 2 - a = -(a / 2)", "start": [910, 1], "end": [912, 46], "kind": "commanddeclaration"}, {"full_name": "add_sub_div_two_lt", "code": "theorem add_sub_div_two_lt (h : a < b) : a + (b - a) / 2 < b", "start": [915, 1], "end": [917, 94], "kind": "commanddeclaration"}, {"full_name": "sub_one_div_inv_le_two", "code": "theorem sub_one_div_inv_le_two (a2 : 2 \u2264 a) : (1 - 1 / a)\u207b\u00b9 \u2264 2", "start": [920, 1], "end": [929, 63], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mul_left", "code": "theorem IsLUB.mul_left {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsLUB s b) :\n    IsLUB ((fun b => a * b) '' s) (a * b)", "start": [936, 1], "end": [942, 26], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mul_right", "code": "theorem IsLUB.mul_right {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsLUB s b) :\n    IsLUB ((fun b => b * a) '' s) (b * a)", "start": [946, 1], "end": [947, 86], "kind": "commanddeclaration"}, {"full_name": "mul_sub_mul_div_mul_neg_iff", "code": "theorem mul_sub_mul_div_mul_neg_iff (hc : c \u2260 0) (hd : d \u2260 0) :\n    (a * d - b * c) / (c * d) < 0 \u2194 a / c < b / d", "start": [953, 1], "end": [955, 58], "kind": "commanddeclaration"}, {"full_name": "mul_sub_mul_div_mul_nonpos_iff", "code": "theorem mul_sub_mul_div_mul_nonpos_iff (hc : c \u2260 0) (hd : d \u2260 0) :\n    (a * d - b * c) / (c * d) \u2264 0 \u2194 a / c \u2264 b / d", "start": [958, 1], "end": [960, 57], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_of_mul_sub_mul_div_neg", "code": "alias \u27e8div_lt_div_of_mul_sub_mul_div_neg, mul_sub_mul_div_mul_neg\u27e9 := mul_sub_mul_div_mul_neg_iff", "start": [963, 1], "end": [963, 98], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_sub_mul_div_mul_neg", "code": "alias \u27e8div_lt_div_of_mul_sub_mul_div_neg, mul_sub_mul_div_mul_neg\u27e9 := mul_sub_mul_div_mul_neg_iff", "start": [963, 1], "end": [963, 98], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_le_div_of_mul_sub_mul_div_nonpos", "code": "alias \u27e8div_le_div_of_mul_sub_mul_div_nonpos, mul_sub_mul_div_mul_nonpos\u27e9 :=\n  mul_sub_mul_div_mul_nonpos_iff", "start": [967, 1], "end": [968, 33], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_sub_mul_div_mul_nonpos", "code": "alias \u27e8div_le_div_of_mul_sub_mul_div_nonpos, mul_sub_mul_div_mul_nonpos\u27e9 :=\n  mul_sub_mul_div_mul_nonpos_iff", "start": [967, 1], "end": [968, 33], "kind": "stdtacticaliasaliaslr"}, {"full_name": "exists_add_lt_and_pos_of_lt", "code": "theorem exists_add_lt_and_pos_of_lt (h : b < a) : \u2203 c, b + c < a \u2227 0 < c", "start": [972, 1], "end": [973, 77], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_sub_le", "code": "theorem le_of_forall_sub_le (h : \u2200 \u03b5 > 0, b - \u03b5 \u2264 a) : b \u2264 a", "start": [976, 1], "end": [979, 34], "kind": "commanddeclaration"}, {"full_name": "mul_self_inj_of_nonneg", "code": "theorem mul_self_inj_of_nonneg (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : a * a = b * b \u2194 a = b", "start": [982, 1], "end": [987, 26], "kind": "commanddeclaration"}, {"full_name": "min_div_div_right_of_nonpos", "code": "theorem min_div_div_right_of_nonpos (hc : c \u2264 0) (a b : \u03b1) : min (a / c) (b / c) = max a b / c", "start": [990, 1], "end": [991, 71], "kind": "commanddeclaration"}, {"full_name": "max_div_div_right_of_nonpos", "code": "theorem max_div_div_right_of_nonpos (hc : c \u2264 0) (a b : \u03b1) : max (a / c) (b / c) = min a b / c", "start": [994, 1], "end": [995, 71], "kind": "commanddeclaration"}, {"full_name": "abs_inv", "code": "theorem abs_inv (a : \u03b1) : |a\u207b\u00b9| = |a|\u207b\u00b9", "start": [998, 1], "end": [999, 32], "kind": "commanddeclaration"}, {"full_name": "abs_div", "code": "theorem abs_div (a b : \u03b1) : |a / b| = |a| / |b|", "start": [1002, 1], "end": [1003, 34], "kind": "commanddeclaration"}, {"full_name": "abs_one_div", "code": "theorem abs_one_div (a : \u03b1) : |1 / a| = 1 / |a|", "start": [1006, 1], "end": [1006, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Basic.lean", "imports": ["Mathlib/Data/Nat/Factorial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.choose", "code": "def choose : \u2115 \u2192 \u2115 \u2192 \u2115\n  | _, 0 => 1\n  | 0, _ + 1 => 0\n  | n + 1, k + 1 => choose n k + choose n (k + 1)", "start": [44, 1], "end": [49, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_zero_right", "code": "@[simp]\ntheorem choose_zero_right (n : \u2115) : choose n 0 = 1", "start": [52, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_zero_succ", "code": "@[simp]\ntheorem choose_zero_succ (k : \u2115) : choose 0 (succ k) = 0", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_succ_succ", "code": "theorem choose_succ_succ (n k : \u2115) : choose (succ n) (succ k) = choose n k + choose n (succ k)", "start": [61, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_succ_succ'", "code": "theorem choose_succ_succ' (n k : \u2115) : choose (n + 1) (k + 1) = choose n k + choose n (k + 1)", "start": [65, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_zero_of_lt", "code": "theorem choose_eq_zero_of_lt : \u2200 {n k}, n < k \u2192 choose n k = 0", "start": [68, 1], "end": [74, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_self", "code": "@[simp]\ntheorem choose_self (n : \u2115) : choose n n = 1", "start": [77, 1], "end": [79, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_succ_self", "code": "@[simp]\ntheorem choose_succ_self (n : \u2115) : choose n (succ n) = 0", "start": [82, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_one_right", "code": "@[simp]\ntheorem choose_one_right (n : \u2115) : choose n 1 = n", "start": [87, 1], "end": [88, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.triangle_succ", "code": "theorem triangle_succ (n : \u2115) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n", "start": [92, 1], "end": [94, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_two_right", "code": "theorem choose_two_right (n : \u2115) : choose n 2 = n * (n - 1) / 2", "start": [97, 1], "end": [102, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_pos", "code": "theorem choose_pos : \u2200 {n k}, k \u2264 n \u2192 0 < choose n k", "start": [105, 1], "end": [110, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_zero_iff", "code": "theorem choose_eq_zero_iff {n k : \u2115} : n.choose k = 0 \u2194 n < k", "start": [113, 1], "end": [114, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul_choose_eq", "code": "theorem succ_mul_choose_eq : \u2200 n k, succ n * choose n k = choose (succ n) (succ k) * succ k", "start": [117, 1], "end": [123, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_mul_factorial_mul_factorial", "code": "theorem choose_mul_factorial_mul_factorial : \u2200 {n k}, k \u2264 n \u2192 choose n k * k ! * (n - k)! = n !", "start": [126, 1], "end": [143, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_mul", "code": "theorem choose_mul {n k s : \u2115} (hkn : k \u2264 n) (hsk : s \u2264 k) :\n    n.choose k * k.choose s = n.choose s * (n - s).choose (k - s)", "start": [146, 1], "end": [162, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_factorial_div_factorial", "code": "theorem choose_eq_factorial_div_factorial {n k : \u2115} (hk : k \u2264 n) :\n    choose n k = n ! / (k ! * (n - k)!)", "start": [165, 1], "end": [168, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.add_choose", "code": "theorem add_choose (i j : \u2115) : (i + j).choose j = (i + j)! / (i ! * j !)", "start": [171, 1], "end": [172, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.add_choose_mul_factorial_mul_factorial", "code": "theorem add_choose_mul_factorial_mul_factorial (i j : \u2115) :\n    (i + j).choose j * i ! * j ! = (i + j)!", "start": [175, 1], "end": [178, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_factorial_dvd_factorial", "code": "theorem factorial_mul_factorial_dvd_factorial {n k : \u2115} (hk : k \u2264 n) : k ! * (n - k)! \u2223 n !", "start": [181, 1], "end": [182, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_mul_factorial_dvd_factorial_add", "code": "theorem factorial_mul_factorial_dvd_factorial_add (i j : \u2115) : i ! * j ! \u2223 (i + j)!", "start": [185, 1], "end": [188, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_symm", "code": "@[simp]\ntheorem choose_symm {n k : \u2115} (hk : k \u2264 n) : choose n (n - k) = choose n k", "start": [191, 1], "end": [194, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_symm_of_eq_add", "code": "theorem choose_symm_of_eq_add {n a b : \u2115} (h : n = a + b) : Nat.choose n a = Nat.choose n b", "start": [197, 1], "end": [200, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_symm_add", "code": "theorem choose_symm_add {a b : \u2115} : choose (a + b) a = choose (a + b) b", "start": [203, 1], "end": [204, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_symm_half", "code": "theorem choose_symm_half (m : \u2115) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m", "start": [207, 1], "end": [209, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_succ_right_eq", "code": "theorem choose_succ_right_eq (n k : \u2115) : choose n (k + 1) * (k + 1) = choose n k * (n - k)", "start": [212, 1], "end": [215, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_succ_self_right", "code": "@[simp]\ntheorem choose_succ_self_right : \u2200 n : \u2115, (n + 1).choose n = n + 1", "start": [218, 1], "end": [221, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_mul_succ_eq", "code": "theorem choose_mul_succ_eq (n k : \u2115) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k)", "start": [224, 1], "end": [232, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.ascFactorial_eq_factorial_mul_choose", "code": "theorem ascFactorial_eq_factorial_mul_choose (n k : \u2115) :\n    n.ascFactorial k = k ! * (n + k).choose k", "start": [235, 1], "end": [241, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_dvd_ascFactorial", "code": "theorem factorial_dvd_ascFactorial (n k : \u2115) : k ! \u2223 n.ascFactorial k", "start": [244, 1], "end": [245, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_asc_factorial_div_factorial", "code": "theorem choose_eq_asc_factorial_div_factorial (n k : \u2115) :\n    (n + k).choose k = n.ascFactorial k / k !", "start": [248, 1], "end": [252, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.descFactorial_eq_factorial_mul_choose", "code": "theorem descFactorial_eq_factorial_mul_choose (n k : \u2115) : n.descFactorial k = k ! * n.choose k", "start": [255, 1], "end": [260, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.factorial_dvd_descFactorial", "code": "theorem factorial_dvd_descFactorial (n k : \u2115) : k ! \u2223 n.descFactorial k", "start": [263, 1], "end": [264, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_descFactorial_div_factorial", "code": "theorem choose_eq_descFactorial_div_factorial (n k : \u2115) : n.choose k = n.descFactorial k / k !", "start": [267, 1], "end": [270, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.fast_choose", "code": "def fast_choose n k := Nat.descFactorial n k / Nat.factorial k", "start": [273, 1], "end": [275, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_eq_fast_choose", "code": "@[csimp] lemma choose_eq_fast_choose : Nat.choose = fast_choose :=\n  funext (fun _ => funext (Nat.choose_eq_descFactorial_div_factorial _))", "start": [277, 1], "end": [278, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.choose_le_succ_of_lt_half_left", "code": "theorem choose_le_succ_of_lt_half_left {r n : \u2115} (h : r < n / 2) :\n    choose n r \u2264 choose n (r + 1)", "start": [284, 1], "end": [291, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_middle_of_le_half_left", "code": "private theorem choose_le_middle_of_le_half_left {n r : \u2115} (hr : r \u2264 n / 2) :\n    choose n r \u2264 choose n (n / 2)", "start": [294, 1], "end": [301, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_middle", "code": "theorem choose_le_middle (r n : \u2115) : choose n r \u2264 choose n (n / 2)", "start": [303, 1], "end": [315, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_succ", "code": "theorem choose_le_succ (a c : \u2115) : choose a c \u2264 choose a.succ c", "start": [321, 1], "end": [322, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_add", "code": "theorem choose_le_add (a b c : \u2115) : choose a c \u2264 choose (a + b) c", "start": [325, 1], "end": [328, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_le_choose", "code": "theorem choose_le_choose {a b : \u2115} (c : \u2115) (h : a \u2264 b) : choose a c \u2264 choose b c", "start": [331, 1], "end": [332, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_mono", "code": "theorem choose_mono (b : \u2115) : Monotone fun a => choose a b", "start": [335, 1], "end": [335, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose", "code": "def multichoose : \u2115 \u2192 \u2115 \u2192 \u2115\n  | _, 0 => 1\n  | 0, _ + 1 => 0\n  | n + 1, k + 1 =>\n    multichoose n (k + 1) + multichoose (n + 1) k\n  termination_by multichoose a b => (a, b)", "start": [358, 1], "end": [365, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_zero_right", "code": "@[simp]\ntheorem multichoose_zero_right (n : \u2115) : multichoose n 0 = 1", "start": [368, 1], "end": [369, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_zero_succ", "code": "@[simp]\ntheorem multichoose_zero_succ (k : \u2115) : multichoose 0 (k + 1) = 0", "start": [372, 1], "end": [373, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_succ_succ", "code": "theorem multichoose_succ_succ (n k : \u2115) :\n    multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k", "start": [376, 1], "end": [378, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_one", "code": "@[simp]\ntheorem multichoose_one (k : \u2115) : multichoose 1 k = 1", "start": [381, 1], "end": [384, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_two", "code": "@[simp]\ntheorem multichoose_two (k : \u2115) : multichoose 2 k = k + 1", "start": [387, 1], "end": [391, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_one_right", "code": "@[simp]\ntheorem multichoose_one_right (n : \u2115) : multichoose n 1 = n", "start": [394, 1], "end": [397, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.multichoose_eq", "code": "theorem multichoose_eq : \u2200 n k : \u2115, multichoose n k = (n + k - 1).choose k", "start": [400, 1], "end": [409, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Fold.lean", "imports": ["Mathlib/Data/List/MinMax.lean", "Mathlib/Data/Multiset/Dedup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.fold", "code": "def fold : \u03b1 \u2192 Multiset \u03b1 \u2192 \u03b1 :=\n  foldr op (left_comm _ hc.comm ha.assoc)", "start": [29, 1], "end": [32, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_eq_foldr", "code": "theorem fold_eq_foldr (b : \u03b1) (s : Multiset \u03b1) :\n    fold op b s = foldr op (left_comm _ hc.comm ha.assoc) b s", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_fold_r", "code": "@[simp]\ntheorem coe_fold_r (b : \u03b1) (l : List \u03b1) : fold op b l = l.foldr op b", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_fold_l", "code": "theorem coe_fold_l (b : \u03b1) (l : List \u03b1) : fold op b l = l.foldl op b", "start": [45, 1], "end": [46, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_eq_foldl", "code": "theorem fold_eq_foldl (b : \u03b1) (s : Multiset \u03b1) :\n    fold op b s = foldl op (right_comm _ hc.comm ha.assoc) b s", "start": [49, 1], "end": [51, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_zero", "code": "@[simp]\ntheorem fold_zero (b : \u03b1) : (0 : Multiset \u03b1).fold op b = b", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_cons_left", "code": "@[simp]\ntheorem fold_cons_left : \u2200 (b a : \u03b1) (s : Multiset \u03b1), (a ::\u2098 s).fold op b = a * s.fold op b", "start": [59, 1], "end": [61, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_cons_right", "code": "theorem fold_cons_right (b a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).fold op b = s.fold op b * a", "start": [64, 1], "end": [65, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_cons'_right", "code": "theorem fold_cons'_right (b a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).fold op b = s.fold op (b * a)", "start": [68, 1], "end": [69, 50], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_cons'_left", "code": "theorem fold_cons'_left (b a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).fold op b = s.fold op (a * b)", "start": [72, 1], "end": [73, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_add", "code": "theorem fold_add (b\u2081 b\u2082 : \u03b1) (s\u2081 s\u2082 : Multiset \u03b1) :\n    (s\u2081 + s\u2082).fold op (b\u2081 * b\u2082) = s\u2081.fold op b\u2081 * s\u2082.fold op b\u2082", "start": [76, 1], "end": [80, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_bind", "code": "theorem fold_bind {\u03b9 : Type*} (s : Multiset \u03b9) (t : \u03b9 \u2192 Multiset \u03b1) (b : \u03b9 \u2192 \u03b1) (b\u2080 : \u03b1) :\n    (s.bind t).fold op ((s.map b).fold op b\u2080) =\n    (s.map fun i => (t i).fold op (b i)).fold op b\u2080", "start": [83, 1], "end": [88, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_singleton", "code": "theorem fold_singleton (b a : \u03b1) : ({a} : Multiset \u03b1).fold op b = a * b", "start": [91, 1], "end": [92, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_distrib", "code": "theorem fold_distrib {f g : \u03b2 \u2192 \u03b1} (u\u2081 u\u2082 : \u03b1) (s : Multiset \u03b2) :\n    (s.map fun x => f x * g x).fold op (u\u2081 * u\u2082) = (s.map f).fold op u\u2081 * (s.map g).fold op u\u2082", "start": [95, 1], "end": [100, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_hom", "code": "theorem fold_hom {op' : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [IsCommutative \u03b2 op'] [IsAssociative \u03b2 op'] {m : \u03b1 \u2192 \u03b2}\n    (hm : \u2200 x y, m (op x y) = op' (m x) (m y)) (b : \u03b1) (s : Multiset \u03b1) :\n    (s.map m).fold op' (m b) = m (s.fold op b)", "start": [103, 1], "end": [106, 86], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_union_inter", "code": "theorem fold_union_inter [DecidableEq \u03b1] (s\u2081 s\u2082 : Multiset \u03b1) (b\u2081 b\u2082 : \u03b1) :\n    ((s\u2081 \u222a s\u2082).fold op b\u2081 * (s\u2081 \u2229 s\u2082).fold op b\u2082) = s\u2081.fold op b\u2081 * s\u2082.fold op b\u2082", "start": [109, 1], "end": [111, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.fold_dedup_idem", "code": "@[simp]\ntheorem fold_dedup_idem [DecidableEq \u03b1] [hi : IsIdempotent \u03b1 op] (s : Multiset \u03b1) (b : \u03b1) :\n    (dedup s).fold op b = s.fold op b", "start": [114, 1], "end": [120, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.max_le_of_forall_le", "code": "theorem max_le_of_forall_le {\u03b1 : Type*} [CanonicallyLinearOrderedAddCommMonoid \u03b1] (l : Multiset \u03b1)\n    (n : \u03b1) (h : \u2200 x \u2208 l, x \u2264 n) : l.fold max \u22a5 \u2264 n", "start": [127, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.max_nat_le_of_forall_le", "code": "theorem max_nat_le_of_forall_le (l : Multiset \u2115) (n : \u2115) (h : \u2200 x \u2208 l, x \u2264 n) : l.fold max 0 \u2264 n", "start": [133, 1], "end": [134, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_smul_dedup", "code": "theorem le_smul_dedup [DecidableEq \u03b1] (s : Multiset \u03b1) : \u2203 n : \u2115, s \u2264 n \u2022 dedup s", "start": [141, 1], "end": [150, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/Bounded.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopHom", "code": "structure TopHom (\u03b1 \u03b2 : Type*) [Top \u03b1] [Top \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_top' : toFun \u22a4 = \u22a4", "start": [37, 1], "end": [42, 25], "kind": "commanddeclaration"}, {"full_name": "BotHom", "code": "structure BotHom (\u03b1 \u03b2 : Type*) [Bot \u03b1] [Bot \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_bot' : toFun \u22a5 = \u22a5", "start": [45, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom", "code": "structure BoundedOrderHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] [BoundedOrder \u03b1]\n  [BoundedOrder \u03b2] extends OrderHom \u03b1 \u03b2 where\n  \n  map_top' : toFun \u22a4 = \u22a4\n  \n  map_bot' : toFun \u22a5 = \u22a5", "start": [53, 1], "end": [59, 25], "kind": "commanddeclaration"}, {"full_name": "TopHomClass", "code": "class TopHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Top \u03b1] [Top \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_top (f : F) : f \u22a4 = \u22a4", "start": [64, 1], "end": [70, 28], "kind": "commanddeclaration"}, {"full_name": "BotHomClass", "code": "class BotHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Bot \u03b1] [Bot \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_bot (f : F) : f \u22a5 = \u22a5", "start": [73, 1], "end": [79, 28], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHomClass", "code": "class BoundedOrderHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [LE \u03b1] [LE \u03b2] [BoundedOrder \u03b1]\n  [BoundedOrder \u03b2] extends RelHomClass F ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) ((\u00b7 \u2264 \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) where\n  \n  map_top (f : F) : f \u22a4 = \u22a4\n  \n  map_bot (f : F) : f \u22a5 = \u22a5", "start": [82, 1], "end": [90, 28], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHomClass.toTopHomClass", "code": "instance (priority := 100) BoundedOrderHomClass.toTopHomClass [LE \u03b1] [LE \u03b2]\n    [BoundedOrder \u03b1] [BoundedOrder \u03b2] [BoundedOrderHomClass F \u03b1 \u03b2] : TopHomClass F \u03b1 \u03b2 :=\n  { \u2039BoundedOrderHomClass F \u03b1 \u03b2\u203a with }", "start": [102, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHomClass.toBotHomClass", "code": "instance (priority := 100) BoundedOrderHomClass.toBotHomClass [LE \u03b1] [LE \u03b2]\n    [BoundedOrder \u03b1] [BoundedOrder \u03b2] [BoundedOrderHomClass F \u03b1 \u03b2] : BotHomClass F \u03b1 \u03b2 :=\n  { \u2039BoundedOrderHomClass F \u03b1 \u03b2\u203a with }", "start": [108, 1], "end": [110, 40], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toTopHomClass", "code": "instance (priority := 100) OrderIsoClass.toTopHomClass [LE \u03b1] [OrderTop \u03b1]\n    [PartialOrder \u03b2] [OrderTop \u03b2] [OrderIsoClass F \u03b1 \u03b2] : TopHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_top := fun f => top_le_iff.1 <| (map_inv_le_iff f).1 le_top }", "start": [114, 1], "end": [117, 70], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toBotHomClass", "code": "instance (priority := 100) OrderIsoClass.toBotHomClass [LE \u03b1] [OrderBot \u03b1]\n    [PartialOrder \u03b2] [OrderBot \u03b2] [OrderIsoClass F \u03b1 \u03b2] : BotHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_bot := fun f => le_bot_iff.1 <| (le_map_inv_iff f).1 bot_le }", "start": [121, 1], "end": [125, 70], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toBoundedOrderHomClass", "code": "instance (priority := 100) OrderIsoClass.toBoundedOrderHomClass [LE \u03b1] [BoundedOrder \u03b1]\n    [PartialOrder \u03b2] [BoundedOrder \u03b2] [OrderIsoClass F \u03b1 \u03b2] : BoundedOrderHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance, OrderIsoClass.toTopHomClass,\n    OrderIsoClass.toBotHomClass with }", "start": [129, 1], "end": [132, 39], "kind": "commanddeclaration"}, {"full_name": "map_eq_top_iff", "code": "@[simp]\ntheorem map_eq_top_iff [LE \u03b1] [OrderTop \u03b1] [PartialOrder \u03b2] [OrderTop \u03b2] [OrderIsoClass F \u03b1 \u03b2]\n    (f : F) {a : \u03b1} : f a = \u22a4 \u2194 a = \u22a4", "start": [138, 1], "end": [142, 51], "kind": "commanddeclaration"}, {"full_name": "map_eq_bot_iff", "code": "@[simp]\ntheorem map_eq_bot_iff [LE \u03b1] [OrderBot \u03b1] [PartialOrder \u03b2] [OrderBot \u03b2] [OrderIsoClass F \u03b1 \u03b2]\n    (f : F) {a : \u03b1} : f a = \u22a5 \u2194 a = \u22a5", "start": [148, 1], "end": [152, 51], "kind": "commanddeclaration"}, {"full_name": "TopHomClass.toTopHom", "code": "@[coe]\ndef TopHomClass.toTopHom [Top \u03b1] [Top \u03b2] [TopHomClass F \u03b1 \u03b2] (f : F) : TopHom \u03b1 \u03b2 :=\n  \u27e8f, map_top f\u27e9", "start": [155, 1], "end": [159, 17], "kind": "commanddeclaration"}, {"full_name": "BotHomClass.toBotHom", "code": "@[coe]\ndef BotHomClass.toBotHom [Bot \u03b1] [Bot \u03b2] [BotHomClass F \u03b1 \u03b2] (f : F) : BotHom \u03b1 \u03b2 :=\n  \u27e8f, map_bot f\u27e9", "start": [164, 1], "end": [168, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHomClass.toBoundedOrderHom", "code": "@[coe]\ndef BoundedOrderHomClass.toBoundedOrderHom [Preorder \u03b1] [Preorder \u03b2] [BoundedOrder \u03b1]\n    [BoundedOrder \u03b2] [BoundedOrderHomClass F \u03b1 \u03b2] (f : F) : BoundedOrderHom \u03b1 \u03b2 :=\n  { (f : \u03b1 \u2192o \u03b2) with toFun := f, map_top' := map_top f, map_bot' := map_bot f }", "start": [173, 1], "end": [178, 81], "kind": "commanddeclaration"}, {"full_name": "TopHom.ext", "code": "@[ext]\ntheorem ext {f g : TopHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [206, 1], "end": [208, 20], "kind": "commanddeclaration"}, {"full_name": "TopHom.copy", "code": "protected def copy (f : TopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) :\n    TopHom \u03b1 \u03b2 where\n  toFun := f'\n  map_top' := h.symm \u25b8 f.map_top'", "start": [211, 1], "end": [216, 34], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : TopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.copy_eq", "code": "theorem copy_eq (f : TopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [224, 1], "end": [225, 17], "kind": "commanddeclaration"}, {"full_name": "TopHom.id", "code": "protected def id : TopHom \u03b1 \u03b1 :=\n  \u27e8id, rfl\u27e9", "start": [233, 1], "end": [235, 12], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(TopHom.id \u03b1) = id", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : TopHom.id \u03b1 a = a", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.comp", "code": "def comp (f : TopHom \u03b2 \u03b3) (g : TopHom \u03b1 \u03b2) :\n    TopHom \u03b1 \u03b3 where\n  toFun := f \u2218 g\n  map_top' := by rw [comp_apply, map_top, map_top]", "start": [250, 1], "end": [254, 51], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : TopHom \u03b2 \u03b3) (g : TopHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [257, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : TopHom \u03b2 \u03b3) (g : TopHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : TopHom \u03b3 \u03b4) (g : TopHom \u03b2 \u03b3) (h : TopHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [267, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : TopHom \u03b1 \u03b2) : f.comp (TopHom.id \u03b1) = f", "start": [273, 1], "end": [275, 26], "kind": "commanddeclaration"}, {"full_name": "TopHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : TopHom \u03b1 \u03b2) : (TopHom.id \u03b2).comp f = f", "start": [278, 1], "end": [280, 26], "kind": "commanddeclaration"}, {"full_name": "TopHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : TopHom \u03b2 \u03b3} {f : TopHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [283, 1], "end": [286, 93], "kind": "commanddeclaration"}, {"full_name": "TopHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : TopHom \u03b2 \u03b3} {f\u2081 f\u2082 : TopHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [289, 1], "end": [293, 17], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_top", "code": "@[simp]\ntheorem coe_top : \u21d1(\u22a4 : TopHom \u03b1 \u03b2) = \u22a4", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.top_apply", "code": "@[simp]\ntheorem top_apply (a : \u03b1) : (\u22a4 : TopHom \u03b1 \u03b2) a = \u22a4", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_inf", "code": "@[simp]\ntheorem coe_inf : \u21d1(f \u2293 g) = \u21d1f \u2293 \u21d1g", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.inf_apply", "code": "@[simp]\ntheorem inf_apply (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a", "start": [339, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.coe_sup", "code": "@[simp]\ntheorem coe_sup : \u21d1(f \u2294 g) = \u21d1f \u2294 \u21d1g", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.sup_apply", "code": "@[simp]\ntheorem sup_apply (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.ext", "code": "@[ext]\ntheorem ext {f g : BotHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [398, 1], "end": [400, 20], "kind": "commanddeclaration"}, {"full_name": "BotHom.copy", "code": "protected def copy (f : BotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) :\n    BotHom \u03b1 \u03b2 where\n  toFun := f'\n  map_bot' := h.symm \u25b8 f.map_bot'", "start": [403, 1], "end": [408, 34], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : BotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [411, 1], "end": [413, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.copy_eq", "code": "theorem copy_eq (f : BotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [416, 1], "end": [417, 17], "kind": "commanddeclaration"}, {"full_name": "BotHom.id", "code": "protected def id : BotHom \u03b1 \u03b1 :=\n  \u27e8id, rfl\u27e9", "start": [425, 1], "end": [427, 12], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(BotHom.id \u03b1) = id", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : BotHom.id \u03b1 a = a", "start": [437, 1], "end": [439, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.comp", "code": "def comp (f : BotHom \u03b2 \u03b3) (g : BotHom \u03b1 \u03b2) :\n    BotHom \u03b1 \u03b3 where\n  toFun := f \u2218 g\n  map_bot' := by rw [comp_apply, map_bot, map_bot]", "start": [442, 1], "end": [446, 51], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : BotHom \u03b2 \u03b3) (g : BotHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [449, 1], "end": [451, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : BotHom \u03b2 \u03b3) (g : BotHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [454, 1], "end": [456, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : BotHom \u03b3 \u03b4) (g : BotHom \u03b2 \u03b3) (h : BotHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [459, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : BotHom \u03b1 \u03b2) : f.comp (BotHom.id \u03b1) = f", "start": [465, 1], "end": [467, 26], "kind": "commanddeclaration"}, {"full_name": "BotHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : BotHom \u03b1 \u03b2) : (BotHom.id \u03b2).comp f = f", "start": [470, 1], "end": [472, 26], "kind": "commanddeclaration"}, {"full_name": "BotHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : BotHom \u03b2 \u03b3} {f : BotHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [475, 1], "end": [478, 84], "kind": "commanddeclaration"}, {"full_name": "BotHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : BotHom \u03b2 \u03b3} {f\u2081 f\u2082 : BotHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [481, 1], "end": [485, 17], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_bot", "code": "@[simp]\ntheorem coe_bot : \u21d1(\u22a5 : BotHom \u03b1 \u03b2) = \u22a5", "start": [504, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.bot_apply", "code": "@[simp]\ntheorem bot_apply (a : \u03b1) : (\u22a5 : BotHom \u03b1 \u03b2) a = \u22a5", "start": [509, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_inf", "code": "@[simp]\ntheorem coe_inf : \u21d1(f \u2293 g) = \u21d1f \u2293 \u21d1g", "start": [526, 1], "end": [528, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.inf_apply", "code": "@[simp]\ntheorem inf_apply (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a", "start": [531, 1], "end": [533, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.coe_sup", "code": "@[simp]\ntheorem coe_sup : \u21d1(f \u2294 g) = \u21d1f \u2294 \u21d1g", "start": [548, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.sup_apply", "code": "@[simp]\ntheorem sup_apply (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a", "start": [553, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.toTopHom", "code": "def toTopHom (f : BoundedOrderHom \u03b1 \u03b2) : TopHom \u03b1 \u03b2 :=\n  { f with }", "start": [579, 1], "end": [581, 13], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.toBotHom", "code": "def toBotHom (f : BoundedOrderHom \u03b1 \u03b2) : BotHom \u03b1 \u03b2 :=\n  { f with }", "start": [584, 1], "end": [586, 13], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.ext", "code": "@[ext]\ntheorem ext {f g : BoundedOrderHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [599, 1], "end": [601, 20], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.copy", "code": "protected def copy (f : BoundedOrderHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : BoundedOrderHom \u03b1 \u03b2 :=\n  { f.toOrderHom.copy f' h, f.toTopHom.copy f' h, f.toBotHom.copy f' h with }", "start": [604, 1], "end": [607, 78], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : BoundedOrderHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [610, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.copy_eq", "code": "theorem copy_eq (f : BoundedOrderHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [615, 1], "end": [616, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.id", "code": "protected def id : BoundedOrderHom \u03b1 \u03b1 :=\n  { OrderHom.id, TopHom.id \u03b1, BotHom.id \u03b1 with }", "start": [621, 1], "end": [623, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(BoundedOrderHom.id \u03b1) = id", "start": [629, 1], "end": [631, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : BoundedOrderHom.id \u03b1 a = a", "start": [636, 1], "end": [638, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.comp", "code": "def comp (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) : BoundedOrderHom \u03b1 \u03b3 :=\n  { f.toOrderHom.comp g.toOrderHom, f.toTopHom.comp g.toTopHom, f.toBotHom.comp g.toBotHom with }", "start": [641, 1], "end": [643, 98], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [646, 1], "end": [648, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) (a : \u03b1) :\n    (f.comp g) a = f (g a)", "start": [651, 1], "end": [654, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_comp_orderHom", "code": "@[simp]\ntheorem coe_comp_orderHom (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) :\n    (f.comp g : OrderHom \u03b1 \u03b3) = (f : OrderHom \u03b2 \u03b3).comp g", "start": [657, 1], "end": [660, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_comp_topHom", "code": "@[simp]\ntheorem coe_comp_topHom (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) :\n    (f.comp g : TopHom \u03b1 \u03b3) = (f : TopHom \u03b2 \u03b3).comp g", "start": [663, 1], "end": [666, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.coe_comp_botHom", "code": "@[simp]\ntheorem coe_comp_botHom (f : BoundedOrderHom \u03b2 \u03b3) (g : BoundedOrderHom \u03b1 \u03b2) :\n    (f.comp g : BotHom \u03b1 \u03b3) = (f : BotHom \u03b2 \u03b3).comp g", "start": [669, 1], "end": [672, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : BoundedOrderHom \u03b3 \u03b4) (g : BoundedOrderHom \u03b2 \u03b3) (h : BoundedOrderHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [675, 1], "end": [678, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : BoundedOrderHom \u03b1 \u03b2) : f.comp (BoundedOrderHom.id \u03b1) = f", "start": [681, 1], "end": [683, 35], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : BoundedOrderHom \u03b1 \u03b2) : (BoundedOrderHom.id \u03b2).comp f = f", "start": [686, 1], "end": [688, 35], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : BoundedOrderHom \u03b2 \u03b3} {f : BoundedOrderHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [691, 1], "end": [695, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : BoundedOrderHom \u03b2 \u03b3} {f\u2081 f\u2082 : BoundedOrderHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [698, 1], "end": [704, 17], "kind": "commanddeclaration"}, {"full_name": "TopHom.dual", "code": "@[simps]\nprotected def dual :\n    TopHom \u03b1 \u03b2 \u2243 BotHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8f, f.map_top'\u27e9\n  invFun f := \u27e8f, f.map_bot'\u27e9\n  left_inv _ := TopHom.ext fun _ => rfl\n  right_inv _ := BotHom.ext fun _ => rfl", "start": [716, 1], "end": [723, 41], "kind": "commanddeclaration"}, {"full_name": "TopHom.dual_id", "code": "@[simp]\ntheorem dual_id : TopHom.dual (TopHom.id \u03b1) = BotHom.id _", "start": [728, 1], "end": [730, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : TopHom \u03b2 \u03b3) (f : TopHom \u03b1 \u03b2) :\n    TopHom.dual (g.comp f) = g.dual.comp (TopHom.dual f)", "start": [733, 1], "end": [736, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : TopHom.dual.symm (BotHom.id _) = TopHom.id \u03b1", "start": [739, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "TopHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : BotHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : BotHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    TopHom.dual.symm (g.comp f) = (TopHom.dual.symm g).comp (TopHom.dual.symm f)", "start": [744, 1], "end": [747, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.dual", "code": "@[simps]\nprotected def dual :\n    BotHom \u03b1 \u03b2 \u2243 TopHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8f, f.map_bot'\u27e9\n  invFun f := \u27e8f, f.map_top'\u27e9\n  left_inv _ := BotHom.ext fun _ => rfl\n  right_inv _ := TopHom.ext fun _ => rfl", "start": [756, 1], "end": [763, 41], "kind": "commanddeclaration"}, {"full_name": "BotHom.dual_id", "code": "@[simp]\ntheorem dual_id : BotHom.dual (BotHom.id \u03b1) = TopHom.id _", "start": [768, 1], "end": [770, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : BotHom \u03b2 \u03b3) (f : BotHom \u03b1 \u03b2) :\n    BotHom.dual (g.comp f) = g.dual.comp (BotHom.dual f)", "start": [773, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : BotHom.dual.symm (TopHom.id _) = BotHom.id \u03b1", "start": [779, 1], "end": [781, 6], "kind": "commanddeclaration"}, {"full_name": "BotHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : TopHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : TopHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    BotHom.dual.symm (g.comp f) = (BotHom.dual.symm g).comp (BotHom.dual.symm f)", "start": [784, 1], "end": [787, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.dual", "code": "@[simps]\nprotected def dual :\n    BoundedOrderHom \u03b1 \u03b2 \u2243\n      BoundedOrderHom \u03b1\u1d52\u1d48\n        \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8OrderHom.dual f.toOrderHom, f.map_bot', f.map_top'\u27e9\n  invFun f := \u27e8OrderHom.dual.symm f.toOrderHom, f.map_bot', f.map_top'\u27e9\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := ext fun _ => rfl", "start": [796, 1], "end": [806, 34], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.dual_id", "code": "@[simp]\ntheorem dual_id : BoundedOrderHom.dual (BoundedOrderHom.id \u03b1) = BoundedOrderHom.id _", "start": [811, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : BoundedOrderHom \u03b2 \u03b3) (f : BoundedOrderHom \u03b1 \u03b2) :\n    BoundedOrderHom.dual (g.comp f) = g.dual.comp (BoundedOrderHom.dual f)", "start": [816, 1], "end": [819, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : BoundedOrderHom.dual.symm (BoundedOrderHom.id _) = BoundedOrderHom.id \u03b1", "start": [822, 1], "end": [824, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedOrderHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : BoundedOrderHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : BoundedOrderHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    BoundedOrderHom.dual.symm (g.comp f) =\n      (BoundedOrderHom.dual.symm g).comp (BoundedOrderHom.dual.symm f)", "start": [827, 1], "end": [831, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Pi.lean", "imports": ["Mathlib/Data/Multiset/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.Pi.empty", "code": "def Pi.empty (\u03b4 : \u03b1 \u2192 Sort*) : \u2200 a \u2208 (0 : Multiset \u03b1), \u03b4 a :=\n  fun.", "start": [23, 1], "end": [26, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pi.cons", "code": "def Pi.cons (m : Multiset \u03b1) (a : \u03b1) (b : \u03b4 a) (f : \u2200 a \u2208 m, \u03b4 a) : \u2200 a' \u2208 a ::\u2098 m, \u03b4 a' :=\n  fun a' ha' => if h : a' = a then Eq.ndrec b h.symm else f a' <| (mem_cons.1 ha').resolve_left h", "start": [32, 1], "end": [36, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pi.cons_same", "code": "theorem Pi.cons_same {m : Multiset \u03b1} {a : \u03b1} {b : \u03b4 a} {f : \u2200 a \u2208 m, \u03b4 a} (h : a \u2208 a ::\u2098 m) :\n    Pi.cons m a b f a h = b", "start": [39, 1], "end": [41, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pi.cons_ne", "code": "theorem Pi.cons_ne {m : Multiset \u03b1} {a a' : \u03b1} {b : \u03b4 a} {f : \u2200 a \u2208 m, \u03b4 a} (h' : a' \u2208 a ::\u2098 m)\n    (h : a' \u2260 a) : Pi.cons m a b f a' h' = f a' ((mem_cons.1 h').resolve_left h)", "start": [44, 1], "end": [46, 12], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pi.cons_swap", "code": "theorem Pi.cons_swap {a a' : \u03b1} {b : \u03b4 a} {b' : \u03b4 a'} {m : Multiset \u03b1} {f : \u2200 a \u2208 m, \u03b4 a}\n    (h : a \u2260 a') : HEq (Pi.cons (a' ::\u2098 m) a b (Pi.cons m a' b' f))\n      (Pi.cons (a ::\u2098 m) a' b' (Pi.cons m a b f))", "start": [49, 1], "end": [58, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.pi.cons_eta", "code": "@[simp, nolint simpNF] theorem pi.cons_eta {m : Multiset \u03b1} {a : \u03b1} (f : \u2200 a' \u2208 a ::\u2098 m, \u03b4 a') :\n    (Pi.cons m a (f _ (mem_cons_self _ _)) fun a' ha' => f a' (mem_cons_of_mem ha')) = f", "start": [61, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.Pi.cons_injective", "code": "theorem Pi.cons_injective {a : \u03b1} {b : \u03b4 a} {s : Multiset \u03b1} (hs : a \u2209 s) :\n    Function.Injective (Pi.cons s a b)", "start": [71, 1], "end": [80, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.pi", "code": "def pi (m : Multiset \u03b1) (t : \u2200 a, Multiset (\u03b2 a)) : Multiset (\u2200 a \u2208 m, \u03b2 a) :=\n  m.recOn {Pi.empty \u03b2}\n    (fun a m (p : Multiset (\u2200 a \u2208 m, \u03b2 a)) => (t a).bind fun b => p.map <| Pi.cons m a b)\n    (by\n      intro a a' m n\n      by_cases eq : a = a'\n      \u00b7 subst eq; rfl\n      \u00b7 simp [map_bind, bind_bind (t a') (t a)]\n        apply bind_hcongr\n        \u00b7 rw [cons_swap a a']\n        intro b _\n        apply bind_hcongr\n        \u00b7 rw [cons_swap a a']\n        intro b' _\n        apply map_hcongr\n        \u00b7 rw [cons_swap a a']\n        intro f _\n        exact Pi.cons_swap eq)", "start": [83, 1], "end": [101, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.pi_zero", "code": "@[simp]\ntheorem pi_zero (t : \u2200 a, Multiset (\u03b2 a)) : pi 0 t = {Pi.empty \u03b2}", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.pi_cons", "code": "@[simp]\ntheorem pi_cons (m : Multiset \u03b1) (t : \u2200 a, Multiset (\u03b2 a)) (a : \u03b1) :\n    pi (a ::\u2098 m) t = (t a).bind fun b => (pi m t).map <| Pi.cons m a b", "start": [109, 1], "end": [112, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_pi", "code": "theorem card_pi (m : Multiset \u03b1) (t : \u2200 a, Multiset (\u03b2 a)) :\n    card (pi m t) = prod (m.map fun a => card (t a))", "start": [115, 1], "end": [117, 92], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.pi", "code": "protected theorem Nodup.pi {s : Multiset \u03b1} {t : \u2200 a, Multiset (\u03b2 a)} :\n    Nodup s \u2192 (\u2200 a \u2208 s, Nodup (t a)) \u2192 Nodup (pi s t)", "start": [120, 1], "end": [136, 75], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_pi", "code": "theorem mem_pi (m : Multiset \u03b1) (t : \u2200 a, Multiset (\u03b2 a)) :\n    \u2200 f : \u2200 a \u2208 m, \u03b2 a, f \u2208 pi m t \u2194 \u2200 (a) (h : a \u2208 m), f a h \u2208 t a", "start": [139, 1], "end": [156, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Card.lean", "imports": ["Mathlib/Data/Finset/Image.lean", "Mathlib/Init/CCLemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.card", "code": "def card (s : Finset \u03b1) : \u2115 :=\n  Multiset.card s.1", "start": [42, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.card_def", "code": "theorem card_def (s : Finset \u03b1) : s.card = Multiset.card s.1", "start": [47, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mk", "code": "@[simp]\ntheorem card_mk {m nodup} : (\u27e8m, nodup\u27e9 : Finset \u03b1).card = Multiset.card m", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.card_empty", "code": "@[simp]\ntheorem card_empty : card (\u2205 : Finset \u03b1) = 0", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_of_subset", "code": "theorem card_le_of_subset : s \u2286 t \u2192 s.card \u2264 t.card", "start": [61, 1], "end": [62, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mono", "code": "@[mono]\ntheorem card_mono : Monotone (@card \u03b1)", "start": [65, 1], "end": [66, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_zero", "code": "@[simp]\ntheorem card_eq_zero : s.card = 0 \u2194 s = \u2205", "start": [69, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pos", "code": "theorem card_pos : 0 < s.card \u2194 s.Nonempty", "start": [74, 1], "end": [75, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.card_pos", "code": "alias \u27e8_, Nonempty.card_pos\u27e9 := card_pos", "start": [78, 1], "end": [78, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.card_ne_zero_of_mem", "code": "theorem card_ne_zero_of_mem (h : a \u2208 s) : s.card \u2260 0", "start": [81, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.card_singleton", "code": "@[simp]\ntheorem card_singleton (a : \u03b1) : card ({a} : Finset \u03b1) = 1", "start": [85, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.card_singleton_inter", "code": "theorem card_singleton_inter [DecidableEq \u03b1] : ({a} \u2229 s).card \u2264 1", "start": [90, 1], "end": [93, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.card_cons", "code": "@[simp]\ntheorem card_cons (h : a \u2209 s) : (s.cons a h).card = s.card + 1", "start": [96, 1], "end": [98, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.card_insert_of_not_mem", "code": "@[simp]\ntheorem card_insert_of_not_mem (h : a \u2209 s) : (insert a s).card = s.card + 1", "start": [105, 1], "end": [107, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.card_insert_of_mem", "code": "theorem card_insert_of_mem (h : a \u2208 s) : card (insert a s) = s.card", "start": [110, 1], "end": [110, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.card_insert_le", "code": "theorem card_insert_le (a : \u03b1) (s : Finset \u03b1) : card (insert a s) \u2264 s.card + 1", "start": [113, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.card_insert_eq_ite", "code": "theorem card_insert_eq_ite : card (insert a s) = if a \u2208 s then s.card else s.card + 1", "start": [120, 1], "end": [125, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_doubleton", "code": "@[simp]\ntheorem card_doubleton (h : a \u2260 b) : ({a, b} : Finset \u03b1).card = 2", "start": [128, 1], "end": [130, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.card_erase_of_mem", "code": "@[simp]\ntheorem card_erase_of_mem : a \u2208 s \u2192 (s.erase a).card = s.card - 1", "start": [133, 1], "end": [136, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.cast_card_erase_of_mem", "code": "@[simp]\ntheorem cast_card_erase_of_mem {R} [AddGroupWithOne R] {s : Finset \u03b1} (hs : a \u2208 s) :\n    ((s.erase a).card : R) = s.card - 1", "start": [139, 1], "end": [147, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.card_erase_add_one", "code": "@[simp]\ntheorem card_erase_add_one : a \u2208 s \u2192 (s.erase a).card + 1 = s.card", "start": [149, 1], "end": [151, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.card_erase_lt_of_mem", "code": "theorem card_erase_lt_of_mem : a \u2208 s \u2192 (s.erase a).card < s.card", "start": [154, 1], "end": [155, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.card_erase_le", "code": "theorem card_erase_le : (s.erase a).card \u2264 s.card", "start": [158, 1], "end": [159, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.pred_card_le_card_erase", "code": "theorem pred_card_le_card_erase : s.card - 1 \u2264 (s.erase a).card", "start": [162, 1], "end": [166, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.card_erase_eq_ite", "code": "theorem card_erase_eq_ite : (s.erase a).card = if a \u2208 s then s.card - 1 else s.card", "start": [169, 1], "end": [171, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.card_range", "code": "@[simp]\ntheorem card_range (n : \u2115) : (range n).card = n", "start": [176, 1], "end": [178, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.card_attach", "code": "@[simp]\ntheorem card_attach : s.attach.card = s.card", "start": [181, 1], "end": [183, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_toFinset", "code": "theorem Multiset.card_toFinset : m.toFinset.card = Multiset.card m.dedup", "start": [192, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_card_le", "code": "theorem Multiset.toFinset_card_le : m.toFinset.card \u2264 Multiset.card m", "start": [196, 1], "end": [197, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_card_of_nodup", "code": "theorem Multiset.toFinset_card_of_nodup {m : Multiset \u03b1} (h : m.Nodup) :\n    m.toFinset.card = Multiset.card m", "start": [200, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "List.card_toFinset", "code": "theorem List.card_toFinset : l.toFinset.card = l.dedup.length", "start": [205, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_card_le", "code": "theorem List.toFinset_card_le : l.toFinset.card \u2264 l.length", "start": [209, 1], "end": [210, 32], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_card_of_nodup", "code": "theorem List.toFinset_card_of_nodup {l : List \u03b1} (h : l.Nodup) : l.toFinset.card = l.length", "start": [213, 1], "end": [214, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.length_toList", "code": "@[simp]\ntheorem length_toList (s : Finset \u03b1) : s.toList.length = s.card", "start": [223, 1], "end": [225, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image_le", "code": "theorem card_image_le [DecidableEq \u03b2] : (s.image f).card \u2264 s.card", "start": [228, 1], "end": [229, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image_of_injOn", "code": "theorem card_image_of_injOn [DecidableEq \u03b2] (H : Set.InjOn f s) : (s.image f).card = s.card", "start": [232, 1], "end": [233, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.injOn_of_card_image_eq", "code": "theorem injOn_of_card_image_eq [DecidableEq \u03b2] (H : (s.image f).card = s.card) : Set.InjOn f s", "start": [236, 1], "end": [243, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image_iff", "code": "theorem card_image_iff [DecidableEq \u03b2] : (s.image f).card = s.card \u2194 Set.InjOn f s", "start": [246, 1], "end": [247, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image_of_injective", "code": "theorem card_image_of_injective [DecidableEq \u03b2] (s : Finset \u03b1) (H : Injective f) :\n    (s.image f).card = s.card", "start": [250, 1], "end": [252, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.fiber_card_ne_zero_iff_mem_image", "code": "theorem fiber_card_ne_zero_iff_mem_image (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) [DecidableEq \u03b2] (y : \u03b2) :\n    (s.filter fun x => f x = y).card \u2260 0 \u2194 y \u2208 s.image f", "start": [255, 1], "end": [257, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.card_map", "code": "@[simp]\ntheorem card_map (f : \u03b1 \u21aa \u03b2) : (s.map f).card = s.card", "start": [260, 1], "end": [262, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.card_subtype", "code": "@[simp]\ntheorem card_subtype (p : \u03b1 \u2192 Prop) [DecidablePred p] (s : Finset \u03b1) :\n    (s.subtype p).card = (s.filter p).card", "start": [265, 1], "end": [267, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.card_filter_le", "code": "theorem card_filter_le (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    (s.filter p).card \u2264 s.card", "start": [270, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_subset_of_card_le", "code": "theorem eq_of_subset_of_card_le {s t : Finset \u03b1} (h : s \u2286 t) (h\u2082 : t.card \u2264 s.card) : s = t", "start": [275, 1], "end": [276, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_superset_of_card_ge", "code": "theorem eq_of_superset_of_card_ge (hst : s \u2286 t) (hts : t.card \u2264 s.card) : t = s", "start": [279, 1], "end": [280, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_iff_eq_of_card_le", "code": "theorem subset_iff_eq_of_card_le (h : t.card \u2264 s.card) : s \u2286 t \u2194 s = t", "start": [283, 1], "end": [284, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.map_eq_of_subset", "code": "theorem map_eq_of_subset {f : \u03b1 \u21aa \u03b1} (hs : s.map f \u2286 s) : s.map f = s", "start": [287, 1], "end": [288, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_card_eq", "code": "theorem filter_card_eq {p : \u03b1 \u2192 Prop} [DecidablePred p] (h : (s.filter p).card = s.card) (x : \u03b1)\n    (hx : x \u2208 s) : p x", "start": [291, 1], "end": [294, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.card_lt_card", "code": "theorem card_lt_card (h : s \u2282 t) : s.card < t.card", "start": [297, 1], "end": [298, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_of_bijective", "code": "theorem card_eq_of_bijective (f : \u2200 i, i < n \u2192 \u03b1) (hf : \u2200 a \u2208 s, \u2203 i, \u2203 h : i < n, f i h = a)\n    (hf' : \u2200 (i) (h : i < n), f i h \u2208 s)\n    (f_inj : \u2200 (i j) (hi : i < n) (hj : j < n), f i hi = f j hj \u2192 i = j) : s.card = n", "start": [301, 1], "end": [318, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.card_congr", "code": "theorem card_congr {t : Finset \u03b2} (f : \u2200 a \u2208 s, \u03b2) (h\u2081 : \u2200 a ha, f a ha \u2208 t)\n    (h\u2082 : \u2200 a b ha hb, f a ha = f b hb \u2192 a = b) (h\u2083 : \u2200 b \u2208 t, \u2203 a ha, f a ha = b) :\n    s.card = t.card", "start": [321, 1], "end": [336, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_of_inj_on", "code": "theorem card_le_card_of_inj_on {t : Finset \u03b2} (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a \u2208 s, f a \u2208 t)\n    (f_inj : \u2200 a\u2081 \u2208 s, \u2200 a\u2082 \u2208 s, f a\u2081 = f a\u2082 \u2192 a\u2081 = a\u2082) : s.card \u2264 t.card", "start": [339, 1], "end": [343, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_ne_map_eq_of_card_lt_of_maps_to", "code": "theorem exists_ne_map_eq_of_card_lt_of_maps_to {t : Finset \u03b2} (hc : t.card < s.card) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 a \u2208 s, f a \u2208 t) : \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y", "start": [346, 1], "end": [355, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.le_card_of_inj_on_range", "code": "theorem le_card_of_inj_on_range (f : \u2115 \u2192 \u03b1) (hf : \u2200 i < n, f i \u2208 s)\n    (f_inj : \u2200 i < n, \u2200 j < n, f i = f j \u2192 i = j) : n \u2264 s.card", "start": [358, 1], "end": [362, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.surj_on_of_inj_on_of_card_le", "code": "theorem surj_on_of_inj_on_of_card_le {t : Finset \u03b2} (f : \u2200 a \u2208 s, \u03b2) (hf : \u2200 a ha, f a ha \u2208 t)\n    (hinj : \u2200 a\u2081 a\u2082 ha\u2081 ha\u2082, f a\u2081 ha\u2081 = f a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082) (hst : t.card \u2264 s.card) :\n    \u2200 b \u2208 t, \u2203 a ha, b = f a ha", "start": [365, 1], "end": [381, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.inj_on_of_surj_on_of_card_le", "code": "theorem inj_on_of_surj_on_of_card_le {t : Finset \u03b2} (f : \u2200 a \u2208 s, \u03b2) (hf : \u2200 a ha, f a ha \u2208 t)\n    (hsurj : \u2200 b \u2208 t, \u2203 a ha, b = f a ha) (hst : s.card \u2264 t.card) \u2983a\u2081 a\u2082\u2984 (ha\u2081 : a\u2081 \u2208 s)\n    (ha\u2082 : a\u2082 \u2208 s) (ha\u2081a\u2082 : f a\u2081 ha\u2081 = f a\u2082 ha\u2082) : a\u2081 = a\u2082", "start": [384, 1], "end": [402, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.card_disjUnion", "code": "@[simp]\ntheorem card_disjUnion (s t : Finset \u03b1) (h) : (s.disjUnion t h).card = s.card + t.card", "start": [405, 1], "end": [407, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.card_union_add_card_inter", "code": "theorem card_union_add_card_inter (s t : Finset \u03b1) :\n    (s \u222a t).card + (s \u2229 t).card = s.card + t.card", "start": [417, 1], "end": [420, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.card_inter_add_card_union", "code": "theorem card_inter_add_card_union (s t : Finset \u03b1) :\n    (s \u2229 t).card + (s \u222a t).card = s.card + t.card", "start": [423, 1], "end": [424, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.card_union_le", "code": "theorem card_union_le (s t : Finset \u03b1) : (s \u222a t).card \u2264 s.card + t.card", "start": [427, 1], "end": [428, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_union_eq", "code": "theorem card_union_eq (h : Disjoint s t) : (s \u222a t).card = s.card + t.card", "start": [431, 1], "end": [432, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.card_disjoint_union", "code": "@[simp]\ntheorem card_disjoint_union (h : Disjoint s t) : card (s \u222a t) = s.card + t.card", "start": [435, 1], "end": [437, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sdiff", "code": "theorem card_sdiff (h : s \u2286 t) : card (t \\ s) = t.card - s.card", "start": [440, 1], "end": [442, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sdiff_add_card_eq_card", "code": "theorem card_sdiff_add_card_eq_card {s t : Finset \u03b1} (h : s \u2286 t) : card (t \\ s) + card s = card t", "start": [445, 1], "end": [446, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.le_card_sdiff", "code": "theorem le_card_sdiff (s t : Finset \u03b1) : t.card - s.card \u2264 card (t \\ s)", "start": [449, 1], "end": [454, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_sdiff_add_card", "code": "theorem card_le_card_sdiff_add_card : s.card \u2264 (s \\ t).card + t.card", "start": [457, 1], "end": [458, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sdiff_add_card", "code": "theorem card_sdiff_add_card : (s \\ t).card + t.card = (s \u222a t).card", "start": [461, 1], "end": [462, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sdiff_comm", "code": "lemma card_sdiff_comm (h : s.card = t.card) : (s \\ t).card = (t \\ s).card :=\n  add_left_injective t.card $ by simp_rw [card_sdiff_add_card, \u2190h, card_sdiff_add_card, union_comm]", "start": [465, 1], "end": [466, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.filter_card_add_filter_neg_card_eq_card", "code": "theorem filter_card_add_filter_neg_card_eq_card\n    (p : \u03b1 \u2192 Prop) [DecidablePred p] [\u2200 x, Decidable (\u00acp x)] :\n    (s.filter p).card + (s.filter (fun a => \u00ac p a)).card = s.card", "start": [470, 1], "end": [473, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_intermediate_set", "code": "theorem exists_intermediate_set {A B : Finset \u03b1} (i : \u2115) (h\u2081 : i + card B \u2264 card A) (h\u2082 : B \u2286 A) :\n    \u2203 C : Finset \u03b1, B \u2286 C \u2227 C \u2286 A \u2227 card C = i + card B", "start": [476, 1], "end": [498, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_smaller_set", "code": "theorem exists_smaller_set (A : Finset \u03b1) (i : \u2115) (h\u2081 : i \u2264 card A) :\n    \u2203 B : Finset \u03b1, B \u2286 A \u2227 card B = i", "start": [501, 1], "end": [505, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_subset_or_subset_of_two_mul_lt_card", "code": "theorem exists_subset_or_subset_of_two_mul_lt_card [DecidableEq \u03b1] {X Y : Finset \u03b1} {n : \u2115}\n    (hXY : 2 * n < (X \u222a Y).card) : \u2203 C : Finset \u03b1, n < C.card \u2227 (C \u2286 X \u2228 C \u2286 Y)", "start": [508, 1], "end": [516, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_one", "code": "theorem card_eq_one : s.card = 1 \u2194 \u2203 a, s = {a}", "start": [522, 1], "end": [524, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_eq_insert_iff", "code": "theorem exists_eq_insert_iff [DecidableEq \u03b1] {s t : Finset \u03b1} :\n    (\u2203 (a : _) (_ : a \u2209 s), insert a s = t) \u2194 s \u2286 t \u2227 s.card + 1 = t.card", "start": [527, 1], "end": [539, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_one", "code": "theorem card_le_one : s.card \u2264 1 \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, a = b", "start": [542, 1], "end": [548, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_one_iff", "code": "theorem card_le_one_iff : s.card \u2264 1 \u2194 \u2200 {a b}, a \u2208 s \u2192 b \u2208 s \u2192 a = b", "start": [551, 1], "end": [553, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_one_iff_subsingleton_coe", "code": "theorem card_le_one_iff_subsingleton_coe : s.card \u2264 1 \u2194 Subsingleton (s : Type _)", "start": [556, 1], "end": [557, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_one_iff_subset_singleton", "code": "theorem card_le_one_iff_subset_singleton [Nonempty \u03b1] : s.card \u2264 1 \u2194 \u2203 x : \u03b1, s \u2286 {x}", "start": [559, 1], "end": [566, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_one_of_subsingleton", "code": "theorem card_le_one_of_subsingleton [Subsingleton \u03b1] (s : Finset \u03b1) : s.card \u2264 1", "start": [569, 1], "end": [571, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.one_lt_card", "code": "theorem one_lt_card : 1 < s.card \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, a \u2260 b", "start": [574, 1], "end": [577, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.one_lt_card_iff", "code": "theorem one_lt_card_iff : 1 < s.card \u2194 \u2203 a b, a \u2208 s \u2227 b \u2208 s \u2227 a \u2260 b", "start": [580, 1], "end": [582, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.one_lt_card_iff_nontrivial_coe", "code": "theorem one_lt_card_iff_nontrivial_coe : 1 < s.card \u2194 Nontrivial (s : Type _)", "start": [585, 1], "end": [586, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.two_lt_card_iff", "code": "theorem two_lt_card_iff : 2 < s.card \u2194 \u2203 a b c, a \u2208 s \u2227 b \u2208 s \u2227 c \u2208 s \u2227 a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "start": [588, 1], "end": [600, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.two_lt_card", "code": "theorem two_lt_card : 2 < s.card \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, \u2203 c \u2208 s, a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "start": [603, 1], "end": [604, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_ne_of_one_lt_card", "code": "theorem exists_ne_of_one_lt_card (hs : 1 < s.card) (a : \u03b1) : \u2203 b, b \u2208 s \u2227 b \u2260 a", "start": [607, 1], "end": [611, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_of_one_lt_card_pi", "code": "lemma exists_of_one_lt_card_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b1 i)]\n    {s : Finset (\u2200 i, \u03b1 i)} (h : 1 < s.card) :\n    \u2203 i, 1 < (s.image (\u00b7 i)).card \u2227 \u2200 ai, s.filter (\u00b7 i = ai) \u2282 s := by\n  simp_rw [one_lt_card_iff, Function.ne_iff] at h \u22a2\n  obtain \u27e8a1, a2, h1, h2, i, hne\u27e9 := h\n  refine \u27e8i, \u27e8_, _, mem_image_of_mem _ h1, mem_image_of_mem _ h2, hne\u27e9, fun ai => ?_\u27e9\n  rw [filter_ssubset]\n  obtain rfl | hne := eq_or_ne (a2 i) ai\n  exacts [\u27e8a1, h1, hne\u27e9, \u27e8a2, h2, hne\u27e9]", "start": [614, 1], "end": [625, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.card_eq_succ", "code": "theorem card_eq_succ [DecidableEq \u03b1] :\n    s.card = n + 1 \u2194 \u2203 a t, a \u2209 t \u2227 insert a t = s \u2227 t.card = n", "start": [627, 1], "end": [633, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_two", "code": "theorem card_eq_two [DecidableEq \u03b1] : s.card = 2 \u2194 \u2203 x y, x \u2260 y \u2227 s = {x, y}", "start": [636, 1], "end": [643, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_three", "code": "theorem card_eq_three [DecidableEq \u03b1] :\n    s.card = 3 \u2194 \u2203 x y z, x \u2260 y \u2227 x \u2260 z \u2227 y \u2260 z \u2227 s = {x, y, z}", "start": [646, 1], "end": [656, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.strongInduction", "code": "def strongInduction {p : Finset \u03b1 \u2192 Sort*} (H : \u2200 s, (\u2200 (t) (_ : t \u2282 s), p t) \u2192 p s) :\n    \u2200 s : Finset \u03b1, p s\n  | s =>\n    H s fun t h =>\n      have : t.card < s.card := card_lt_card h\n      strongInduction H t\n  termination_by strongInduction s => Finset.card s", "start": [662, 1], "end": [671, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.strongInduction_eq", "code": "@[nolint unusedHavesSuffices] theorem strongInduction_eq {p : Finset \u03b1 \u2192 Sort*} (H : \u2200 s, (\u2200 (t) (_ : t \u2282 s), p t) \u2192 p s)\n    (s : Finset \u03b1) : strongInduction H s = H s fun t _ => strongInduction H t", "start": [674, 1], "end": [677, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.strongInductionOn", "code": "@[elab_as_elim]\ndef strongInductionOn {p : Finset \u03b1 \u2192 Sort*} (s : Finset \u03b1) :\n    (\u2200 s, (\u2200 (t) (_ : t \u2282 s), p t) \u2192 p s) \u2192 p s := fun H => strongInduction H s", "start": [680, 1], "end": [683, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.strongInductionOn_eq", "code": "@[nolint unusedHavesSuffices] theorem strongInductionOn_eq {p : Finset \u03b1 \u2192 Sort*} (s : Finset \u03b1)\n    (H : \u2200 s, (\u2200 (t) (_ : t \u2282 s), p t) \u2192 p s) :\n    s.strongInductionOn H = H s fun t _ => t.strongInductionOn H", "start": [686, 1], "end": [691, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.case_strong_induction_on", "code": "@[elab_as_elim]\ntheorem case_strong_induction_on [DecidableEq \u03b1] {p : Finset \u03b1 \u2192 Prop} (s : Finset \u03b1) (h\u2080 : p \u2205)\n    (h\u2081 : \u2200 a s, a \u2209 s \u2192 (\u2200 (t) (_ : t \u2286 s), p t) \u2192 p (insert a s)) : p s", "start": [694, 1], "end": [699, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.strongDownwardInduction", "code": "def strongDownwardInduction {p : Finset \u03b1 \u2192 Sort*} {n : \u2115}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Finset \u03b1}, t\u2082.card \u2264 n \u2192 t\u2081 \u2282 t\u2082 \u2192 p t\u2082) \u2192 t\u2081.card \u2264 n \u2192 p t\u2081) :\n    \u2200 s : Finset \u03b1, s.card \u2264 n \u2192 p s\n  | s =>\n    H s fun {t} ht h =>\n      have : n - t.card < n - s.card := (tsub_lt_tsub_iff_left_of_le ht).2 (Finset.card_lt_card h)\n      strongDownwardInduction H t ht\n  termination_by strongDownwardInduction s => n - s.card", "start": [702, 1], "end": [713, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.strongDownwardInduction_eq", "code": "@[nolint unusedHavesSuffices] theorem strongDownwardInduction_eq {p : Finset \u03b1 \u2192 Sort*}\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Finset \u03b1}, t\u2082.card \u2264 n \u2192 t\u2081 \u2282 t\u2082 \u2192 p t\u2082) \u2192 t\u2081.card \u2264 n \u2192 p t\u2081)\n    (s : Finset \u03b1) :\n    strongDownwardInduction H s = H s fun {t} ht _ => strongDownwardInduction H t ht", "start": [716, 1], "end": [721, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.strongDownwardInductionOn", "code": "@[elab_as_elim]\ndef strongDownwardInductionOn {p : Finset \u03b1 \u2192 Sort*} (s : Finset \u03b1)\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Finset \u03b1}, t\u2082.card \u2264 n \u2192 t\u2081 \u2282 t\u2082 \u2192 p t\u2082) \u2192 t\u2081.card \u2264 n \u2192 p t\u2081) :\n    s.card \u2264 n \u2192 p s :=\n  strongDownwardInduction H s", "start": [724, 1], "end": [729, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.strongDownwardInductionOn_eq", "code": "@[nolint unusedHavesSuffices] theorem strongDownwardInductionOn_eq {p : Finset \u03b1 \u2192 Sort*} (s : Finset \u03b1)\n    (H : \u2200 t\u2081, (\u2200 {t\u2082 : Finset \u03b1}, t\u2082.card \u2264 n \u2192 t\u2081 \u2282 t\u2082 \u2192 p t\u2082) \u2192 t\u2081.card \u2264 n \u2192 p t\u2081) :\n    s.strongDownwardInductionOn H = H s fun {t} ht _ => t.strongDownwardInductionOn H ht", "start": [732, 1], "end": [737, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_wf", "code": "theorem lt_wf {\u03b1} : WellFounded (@LT.lt (Finset \u03b1) _)", "start": [740, 1], "end": [743, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/WithTop.lean", "imports": ["Mathlib/Data/Nat/Cast/Defs.lean", "Mathlib/Algebra/CharZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/ZeroLEOne.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Basic.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/Order/Monoid/OrderDual.lean"], "premises": [{"full_name": "WithTop.one", "code": "@[to_additive]\ninstance one : One (WithTop \u03b1) :=\n  \u27e8(1 : \u03b1)\u27e9", "start": [30, 1], "end": [32, 12], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : \u03b1) : WithTop \u03b1) = 1", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_eq_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_one {a : \u03b1} : (a : WithTop \u03b1) = 1 \u2194 a = 1", "start": [42, 1], "end": [44, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop_one", "code": "@[to_additive (attr := simp)]\ntheorem untop_one : (1 : WithTop \u03b1).untop coe_ne_top = 1", "start": [48, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop_one'", "code": "@[to_additive (attr := simp)]\ntheorem untop_one' (d : \u03b1) : (1 : WithTop \u03b1).untop' d = 1", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.one_le_coe", "code": "@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [LE \u03b1] {a : \u03b1} : 1 \u2264 (a : WithTop \u03b1) \u2194 1 \u2264 a", "start": [60, 1], "end": [62, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_le_one", "code": "@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [LE \u03b1] {a : \u03b1} : (a : WithTop \u03b1) \u2264 1 \u2194 a \u2264 1", "start": [66, 1], "end": [68, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.one_lt_coe", "code": "@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [LT \u03b1] {a : \u03b1} : 1 < (a : WithTop \u03b1) \u2194 1 < a", "start": [72, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_lt_one", "code": "@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [LT \u03b1] {a : \u03b1} : (a : WithTop \u03b1) < 1 \u2194 a < 1", "start": [78, 1], "end": [80, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_one", "code": "@[to_additive (attr := simp)]\nprotected theorem map_one {\u03b2} (f : \u03b1 \u2192 \u03b2) : (1 : WithTop \u03b1).map f = (f 1 : WithTop \u03b2)", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.one_eq_coe", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem one_eq_coe {a : \u03b1} : 1 = (a : WithTop \u03b1) \u2194 a = 1", "start": [90, 1], "end": [92, 33], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_ne_one", "code": "@[to_additive (attr := simp)]\ntheorem top_ne_one : \u22a4 \u2260 (1 : WithTop \u03b1)", "start": [96, 1], "end": [98, 7], "kind": "commanddeclaration"}, {"full_name": "WithTop.one_ne_top", "code": "@[to_additive (attr := simp)]\ntheorem one_ne_top : (1 : WithTop \u03b1) \u2260 \u22a4", "start": [102, 1], "end": [104, 7], "kind": "commanddeclaration"}, {"full_name": "WithTop.zeroLEOneClass", "code": "instance zeroLEOneClass [Zero \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1] : ZeroLEOneClass (WithTop \u03b1) :=\n  \u27e8some_le_some.2 zero_le_one\u27e9", "start": [108, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "WithTop.add", "code": "instance add : Add (WithTop \u03b1) :=\n  \u27e8Option.map\u2082 (\u00b7 + \u00b7)\u27e9", "start": [117, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_add", "code": "@[norm_cast]\ntheorem coe_add : ((x + y : \u03b1) : WithTop \u03b1) = x + y", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_bit0", "code": "@[norm_cast, deprecated]\ntheorem coe_bit0 : ((bit0 x : \u03b1) : WithTop \u03b1) = (bit0 x : WithTop \u03b1)", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_bit1", "code": "@[norm_cast, deprecated]\ntheorem coe_bit1 [One \u03b1] {a : \u03b1} : ((bit1 a : \u03b1) : WithTop \u03b1) = (bit1 a : WithTop \u03b1)", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_add", "code": "@[simp]\ntheorem top_add (a : WithTop \u03b1) : \u22a4 + a = \u22a4", "start": [141, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_top", "code": "@[simp]\ntheorem add_top (a : WithTop \u03b1) : a + \u22a4 = \u22a4", "start": [146, 1], "end": [147, 66], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_eq_top", "code": "@[simp]\ntheorem add_eq_top : a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "start": [150, 1], "end": [152, 77], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_ne_top", "code": "theorem add_ne_top : a + b \u2260 \u22a4 \u2194 a \u2260 \u22a4 \u2227 b \u2260 \u22a4", "start": [155, 1], "end": [156, 30], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_top", "code": "theorem add_lt_top [LT \u03b1] {a b : WithTop \u03b1} : a + b < \u22a4 \u2194 a < \u22a4 \u2227 b < \u22a4", "start": [159, 1], "end": [160, 50], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_eq_coe", "code": "theorem add_eq_coe :\n    \u2200 {a b : WithTop \u03b1} {c : \u03b1}, a + b = c \u2194 \u2203 a' b' : \u03b1, \u2191a' = a \u2227 \u2191b' = b \u2227 a' + b' = c", "start": [163, 1], "end": [168, 85], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_coe_eq_top_iff", "code": "theorem add_coe_eq_top_iff {x : WithTop \u03b1} {y : \u03b1} : x + y = \u22a4 \u2194 x = \u22a4", "start": [173, 1], "end": [174, 59], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_add_eq_top_iff", "code": "theorem coe_add_eq_top_iff {y : WithTop \u03b1} : \u2191x + y = \u22a4 \u2194 y = \u22a4", "start": [179, 1], "end": [180, 59], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_right_cancel_iff", "code": "theorem add_right_cancel_iff [IsRightCancelAdd \u03b1] (ha : a \u2260 \u22a4) : b + a = c + a \u2194 b = c", "start": [183, 1], "end": [189, 60], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_right_cancel", "code": "theorem add_right_cancel [IsRightCancelAdd \u03b1] (ha : a \u2260 \u22a4) (h : b + a = c + a) : b = c", "start": [191, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_left_cancel_iff", "code": "theorem add_left_cancel_iff [IsLeftCancelAdd \u03b1] (ha : a \u2260 \u22a4) : a + b = a + c \u2194 b = c", "start": [194, 1], "end": [200, 71], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_left_cancel", "code": "theorem add_left_cancel [IsLeftCancelAdd \u03b1] (ha : a \u2260 \u22a4) (h : a + b = a + c) : b = c", "start": [202, 1], "end": [203, 39], "kind": "commanddeclaration"}, {"full_name": "WithTop.covariantClass_add_le", "code": "instance covariantClass_add_le [LE \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (WithTop \u03b1) (WithTop \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b c h => by\n    cases a <;> cases c <;> try exact le_top\n    rcases le_coe_iff.1 h with \u27e8b, rfl, _\u27e9\n    exact coe_le_coe.2 (add_le_add_left (coe_le_coe.1 h) _)\u27e9", "start": [205, 1], "end": [210, 61], "kind": "commanddeclaration"}, {"full_name": "WithTop.covariantClass_swap_add_le", "code": "instance covariantClass_swap_add_le [LE \u03b1] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (WithTop \u03b1) (WithTop \u03b1) (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b c h => by\n    cases a <;> cases c <;> try exact le_top\n    rcases le_coe_iff.1 h with \u27e8b, rfl, _\u27e9\n    exact coe_le_coe.2 (add_le_add_right (coe_le_coe.1 h) _)\u27e9", "start": [213, 1], "end": [218, 62], "kind": "commanddeclaration"}, {"full_name": "WithTop.contravariantClass_add_lt", "code": "instance contravariantClass_add_lt [LT \u03b1] [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass (WithTop \u03b1) (WithTop \u03b1) (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun a b c h => by\n    induction a using WithTop.recTopCoe; \u00b7 exact (not_none_lt _ h).elim\n    induction b using WithTop.recTopCoe; \u00b7 exact (not_none_lt _ h).elim\n    induction c using WithTop.recTopCoe\n    \u00b7 exact coe_lt_top _\n    \u00b7 exact coe_lt_coe.2 (lt_of_add_lt_add_left <| coe_lt_coe.1 h)\u27e9", "start": [221, 1], "end": [228, 68], "kind": "commanddeclaration"}, {"full_name": "WithTop.contravariantClass_swap_add_lt", "code": "instance contravariantClass_swap_add_lt [LT \u03b1] [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    ContravariantClass (WithTop \u03b1) (WithTop \u03b1) (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun a b c h => by\n    cases a <;> cases b <;> try exact (not_none_lt _ h).elim\n    cases c\n    \u00b7 exact coe_lt_top _\n    \u00b7 exact coe_lt_coe.2 (lt_of_add_lt_add_right <| coe_lt_coe.1 h)\u27e9", "start": [231, 1], "end": [237, 69], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_of_add_le_add_left", "code": "protected theorem le_of_add_le_add_left [LE \u03b1] [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a4)\n    (h : a + b \u2264 a + c) : b \u2264 c", "start": [240, 1], "end": [248, 36], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_of_add_le_add_right", "code": "protected theorem le_of_add_le_add_right [LE \u03b1] [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (ha : a \u2260 \u22a4) (h : b + a \u2264 c + a) : b \u2264 c", "start": [251, 1], "end": [258, 68], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_left", "code": "protected theorem add_lt_add_left [LT \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a4)\n    (h : b < c) : a + b < a + c", "start": [261, 1], "end": [267, 60], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_right", "code": "protected theorem add_lt_add_right [LT \u03b1] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a4)\n    (h : b < c) : b + a < c + a", "start": [270, 1], "end": [276, 61], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_le_add_iff_left", "code": "protected theorem add_le_add_iff_left [LE \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a4) : a + b \u2264 a + c \u2194 b \u2264 c", "start": [279, 1], "end": [281, 67], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_le_add_iff_right", "code": "protected theorem add_le_add_iff_right [LE \u03b1] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a4) : b + a \u2264 c + a \u2194 b \u2264 c", "start": [284, 1], "end": [286, 69], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left [LT \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a4) : a + b < a + c \u2194 b < c", "start": [289, 1], "end": [291, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right [LT \u03b1] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a4) : b + a < c + a \u2194 b < c", "start": [294, 1], "end": [296, 56], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_of_le_of_lt", "code": "protected theorem add_lt_add_of_le_of_lt [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a4) (hab : a \u2264 b) (hcd : c < d) :\n    a + c < b + d", "start": [299, 1], "end": [302, 70], "kind": "commanddeclaration"}, {"full_name": "WithTop.add_lt_add_of_lt_of_le", "code": "protected theorem add_lt_add_of_lt_of_le [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (hc : c \u2260 \u22a4) (hab : a < b) (hcd : c \u2264 d) :\n    a + c < b + d", "start": [305, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_add", "code": "@[simp]\nprotected theorem map_add {F} [Add \u03b2] [AddHomClass F \u03b1 \u03b2] (f : F) (a b : WithTop \u03b1) :\n    (a + b).map f = a.map f + b.map f", "start": [312, 1], "end": [320, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.addSemigroup", "code": "instance addSemigroup [AddSemigroup \u03b1] : AddSemigroup (WithTop \u03b1) :=\n  { WithTop.add with\n    add_assoc := fun _ _ _ => Option.map\u2082_assoc add_assoc }", "start": [325, 1], "end": [327, 60], "kind": "commanddeclaration"}, {"full_name": "WithTop.addCommSemigroup", "code": "instance addCommSemigroup [AddCommSemigroup \u03b1] : AddCommSemigroup (WithTop \u03b1) :=\n  { WithTop.addSemigroup with\n    add_comm := fun _ _ => Option.map\u2082_comm add_comm }", "start": [329, 1], "end": [331, 55], "kind": "commanddeclaration"}, {"full_name": "WithTop.addZeroClass", "code": "instance addZeroClass [AddZeroClass \u03b1] : AddZeroClass (WithTop \u03b1) :=\n  { WithTop.zero, WithTop.add with\n    zero_add := Option.map\u2082_left_identity zero_add\n    add_zero := Option.map\u2082_right_identity add_zero }", "start": [333, 1], "end": [336, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.addMonoid", "code": "instance addMonoid [AddMonoid \u03b1] : AddMonoid (WithTop \u03b1) :=\n  { WithTop.addSemigroup, WithTop.addZeroClass with }", "start": [338, 1], "end": [339, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid \u03b1] : AddCommMonoid (WithTop \u03b1) :=\n  { WithTop.addMonoid, WithTop.addCommSemigroup with }", "start": [341, 1], "end": [342, 55], "kind": "commanddeclaration"}, {"full_name": "WithTop.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne \u03b1] : AddMonoidWithOne (WithTop \u03b1) :=\n  { WithTop.one, WithTop.addMonoid with\n    natCast := fun n => \u2191(n : \u03b1),\n    natCast_zero := by\n      simp only rw [Nat.cast_zero, WithTop.coe_zero],\n    natCast_succ := fun n => by\n      simp only rw [Nat.cast_add_one, WithTop.coe_add, WithTop.coe_one]\n  }", "start": [344, 1], "end": [353, 4], "kind": "commanddeclaration"}, {"full_name": "WithTop.charZero", "code": "instance charZero [AddMonoidWithOne \u03b1] [CharZero \u03b1] : CharZero (WithTop \u03b1) :=\n  { cast_injective := Function.Injective.comp (f := Nat.cast (R := \u03b1))\n      (fun _ _ => WithTop.coe_eq_coe.1) Nat.cast_injective}", "start": [355, 1], "end": [357, 60], "kind": "commanddeclaration"}, {"full_name": "WithTop.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne \u03b1] : AddCommMonoidWithOne (WithTop \u03b1) :=\n  { WithTop.addMonoidWithOne, WithTop.addCommMonoid with }", "start": [359, 1], "end": [360, 59], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderedAddCommMonoid", "code": "instance orderedAddCommMonoid [OrderedAddCommMonoid \u03b1] : OrderedAddCommMonoid (WithTop \u03b1) :=\n  { WithTop.partialOrder, WithTop.addCommMonoid with\n    add_le_add_left := by\n      rintro a b h (_ | c); \u00b7 simp [none_eq_top]\n      rcases b with (_ | b); \u00b7 simp [none_eq_top]\n      rcases le_coe_iff.1 h with \u27e8a, rfl, _\u27e9\n      simp only [some_eq_coe, \u2190 coe_add, coe_le_coe] at h \u22a2\n      exact add_le_add_left h c }", "start": [362, 1], "end": [369, 34], "kind": "commanddeclaration"}, {"full_name": "WithTop.linearOrderedAddCommMonoidWithTop", "code": "instance linearOrderedAddCommMonoidWithTop [LinearOrderedAddCommMonoid \u03b1] :\n    LinearOrderedAddCommMonoidWithTop (WithTop \u03b1) :=\n  { WithTop.orderTop, WithTop.linearOrder, WithTop.orderedAddCommMonoid with\n    top_add' := WithTop.top_add }", "start": [371, 1], "end": [374, 34], "kind": "commanddeclaration"}, {"full_name": "WithTop.existsAddOfLE", "code": "instance existsAddOfLE [LE \u03b1] [Add \u03b1] [ExistsAddOfLE \u03b1] : ExistsAddOfLE (WithTop \u03b1) :=\n  \u27e8fun {a} {b} =>\n    match a, b with\n    | \u22a4, \u22a4 => by simp\n    | (a : \u03b1), \u22a4 => fun _ => \u27e8\u22a4, rfl\u27e9\n    | (a : \u03b1), (b : \u03b1) => fun h => by\n      obtain \u27e8c, rfl\u27e9 := exists_add_of_le (WithTop.coe_le_coe.1 h)\n      exact \u27e8c, rfl\u27e9\n    | \u22a4, (b : \u03b1) => fun h => (not_top_le_coe _ h).elim\u27e9", "start": [376, 1], "end": [384, 56], "kind": "commanddeclaration"}, {"full_name": "WithTop.canonicallyOrderedAddCommMonoid", "code": "instance canonicallyOrderedAddCommMonoid [CanonicallyOrderedAddCommMonoid \u03b1] :\n    CanonicallyOrderedAddCommMonoid (WithTop \u03b1) :=\n  { WithTop.orderBot, WithTop.orderedAddCommMonoid, WithTop.existsAddOfLE with\n    le_self_add := fun a b =>\n      match a, b with\n      | \u22a4, \u22a4 => le_rfl\n      | (a : \u03b1), \u22a4 => le_top\n      | (a : \u03b1), (b : \u03b1) => WithTop.coe_le_coe.2 le_self_add\n      | \u22a4, (b : \u03b1) => le_rfl }", "start": [386, 1], "end": [394, 31], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_nat", "code": "@[simp, norm_cast]\ntheorem coe_nat [AddMonoidWithOne \u03b1] (n : \u2115) : ((n : \u03b1) : WithTop \u03b1) = n", "start": [400, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.nat_ne_top", "code": "@[simp]\ntheorem nat_ne_top [AddMonoidWithOne \u03b1] (n : \u2115) : (n : WithTop \u03b1) \u2260 \u22a4", "start": [405, 1], "end": [407, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_ne_nat", "code": "@[simp]\ntheorem top_ne_nat [AddMonoidWithOne \u03b1] (n : \u2115) : (\u22a4 : WithTop \u03b1) \u2260 n", "start": [410, 1], "end": [412, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.addHom", "code": "def addHom [AddMonoid \u03b1] : \u03b1 \u2192+ WithTop \u03b1 :=\n  { toFun := WithTop.some,\n    map_zero' := rfl,\n    map_add' := fun _ _ => rfl }", "start": [415, 1], "end": [421, 33], "kind": "commanddeclaration"}, {"full_name": "WithTop.zero_lt_top", "code": "@[simp]\ntheorem zero_lt_top [OrderedAddCommMonoid \u03b1] : (0 : WithTop \u03b1) < \u22a4", "start": [430, 1], "end": [432, 15], "kind": "commanddeclaration"}, {"full_name": "WithTop.zero_lt_coe", "code": "@[norm_cast]\ntheorem zero_lt_coe [OrderedAddCommMonoid \u03b1] (a : \u03b1) : (0 : WithTop \u03b1) < a \u2194 0 < a", "start": [437, 1], "end": [439, 13], "kind": "commanddeclaration"}, {"full_name": "OneHom.withTopMap", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n  \"A version of `WithTop.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withTopMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithTop M) (WithTop N) where\n  toFun := WithTop.map f\n  map_one' := by rw [WithTop.map_one, map_one, coe_one]", "start": [442, 1], "end": [448, 56], "kind": "commanddeclaration"}, {"full_name": "AddHom.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.AddHom.withTopMap {M N : Type*} [Add M] [Add N] (f : AddHom M N) :\n    AddHom (WithTop M) (WithTop N) where\n  toFun := WithTop.map f\n  map_add' := WithTop.map_add f", "start": [453, 1], "end": [458, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.AddMonoidHom.withTopMap {M N : Type*} [AddZeroClass M] [AddZeroClass N]\n    (f : M \u2192+ N) : WithTop M \u2192+ WithTop N :=\n  { ZeroHom.withTopMap f.toZeroHom, AddHom.withTopMap f.toAddHom with toFun := WithTop.map f }", "start": [462, 1], "end": [466, 95], "kind": "commanddeclaration"}, {"full_name": "WithBot.one", "code": "@[to_additive]\ninstance one [One \u03b1] : One (WithBot \u03b1) :=\n  WithTop.one", "start": [474, 1], "end": [476, 14], "kind": "commanddeclaration"}, {"full_name": "WithBot.add", "code": "instance add [Add \u03b1] : Add (WithBot \u03b1) :=\n  WithTop.add", "start": [478, 1], "end": [479, 14], "kind": "commanddeclaration"}, {"full_name": "WithBot.AddSemigroup", "code": "instance AddSemigroup [AddSemigroup \u03b1] : AddSemigroup (WithBot \u03b1) :=\n  WithTop.addSemigroup", "start": [481, 1], "end": [482, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.addCommSemigroup", "code": "instance addCommSemigroup [AddCommSemigroup \u03b1] : AddCommSemigroup (WithBot \u03b1) :=\n  WithTop.addCommSemigroup", "start": [484, 1], "end": [485, 27], "kind": "commanddeclaration"}, {"full_name": "WithBot.addZeroClass", "code": "instance addZeroClass [AddZeroClass \u03b1] : AddZeroClass (WithBot \u03b1) :=\n  WithTop.addZeroClass", "start": [487, 1], "end": [488, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.addMonoid", "code": "instance addMonoid [AddMonoid \u03b1] : AddMonoid (WithBot \u03b1) :=\n  WithTop.addMonoid", "start": [490, 1], "end": [491, 20], "kind": "commanddeclaration"}, {"full_name": "WithBot.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid \u03b1] : AddCommMonoid (WithBot \u03b1) :=\n  WithTop.addCommMonoid", "start": [493, 1], "end": [494, 24], "kind": "commanddeclaration"}, {"full_name": "WithBot.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne \u03b1] : AddMonoidWithOne (WithBot \u03b1) :=\n  WithTop.addMonoidWithOne", "start": [496, 1], "end": [497, 27], "kind": "commanddeclaration"}, {"full_name": "WithBot.charZero", "code": "instance charZero [AddMonoidWithOne \u03b1] [CharZero \u03b1] : CharZero (WithBot \u03b1) :=\n  WithTop.charZero", "start": [499, 1], "end": [500, 19], "kind": "commanddeclaration"}, {"full_name": "WithBot.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne \u03b1] : AddCommMonoidWithOne (WithBot \u03b1) :=\n  WithTop.addCommMonoidWithOne", "start": [502, 1], "end": [503, 31], "kind": "commanddeclaration"}, {"full_name": "WithBot.zeroLEOneClass", "code": "instance zeroLEOneClass [Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1] : ZeroLEOneClass (WithBot \u03b1) :=\n  \u27e8some_le_some.2 zero_le_one\u27e9", "start": [505, 1], "end": [506, 31], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_one", "code": "@[to_additive]\ntheorem coe_one [One \u03b1] : ((1 : \u03b1) : WithBot \u03b1) = 1", "start": [509, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_eq_one", "code": "@[to_additive]\ntheorem coe_eq_one [One \u03b1] {a : \u03b1} : (a : WithBot \u03b1) = 1 \u2194 a = 1", "start": [516, 1], "end": [518, 21], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot_one", "code": "@[to_additive (attr := simp)]\ntheorem unbot_one [One \u03b1] : (1 : WithBot \u03b1).unbot coe_ne_bot = 1", "start": [522, 1], "end": [524, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot_one'", "code": "@[to_additive (attr := simp)]\ntheorem unbot_one' [One \u03b1] (d : \u03b1) : (1 : WithBot \u03b1).unbot' d = 1", "start": [528, 1], "end": [530, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.one_le_coe", "code": "@[to_additive (attr := simp, norm_cast) coe_nonneg]\ntheorem one_le_coe [One \u03b1] [LE \u03b1] {a : \u03b1} : 1 \u2264 (a : WithBot \u03b1) \u2194 1 \u2264 a", "start": [534, 1], "end": [536, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_le_one", "code": "@[to_additive (attr := simp, norm_cast) coe_le_zero]\ntheorem coe_le_one [One \u03b1] [LE \u03b1] {a : \u03b1} : (a : WithBot \u03b1) \u2264 1 \u2194 a \u2264 1", "start": [540, 1], "end": [542, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.one_lt_coe", "code": "@[to_additive (attr := simp, norm_cast) coe_pos]\ntheorem one_lt_coe [One \u03b1] [LT \u03b1] {a : \u03b1} : 1 < (a : WithBot \u03b1) \u2194 1 < a", "start": [546, 1], "end": [548, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_lt_one", "code": "@[to_additive (attr := simp, norm_cast) coe_lt_zero]\ntheorem coe_lt_one [One \u03b1] [LT \u03b1] {a : \u03b1} : (a : WithBot \u03b1) < 1 \u2194 a < 1", "start": [552, 1], "end": [554, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_one", "code": "@[to_additive (attr := simp)]\nprotected theorem map_one {\u03b2} [One \u03b1] (f : \u03b1 \u2192 \u03b2) : (1 : WithBot \u03b1).map f = (f 1 : WithBot \u03b2)", "start": [558, 1], "end": [560, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_nat", "code": "@[norm_cast]\ntheorem coe_nat [AddMonoidWithOne \u03b1] (n : \u2115) : ((n : \u03b1) : WithBot \u03b1) = n", "start": [564, 1], "end": [566, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.nat_ne_bot", "code": "@[simp]\ntheorem nat_ne_bot [AddMonoidWithOne \u03b1] (n : \u2115) : (n : WithBot \u03b1) \u2260 \u22a5", "start": [569, 1], "end": [571, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_ne_nat", "code": "@[simp]\ntheorem bot_ne_nat [AddMonoidWithOne \u03b1] (n : \u2115) : (\u22a5 : WithBot \u03b1) \u2260 n", "start": [574, 1], "end": [576, 13], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_add", "code": "theorem coe_add (a b : \u03b1) : ((a + b : \u03b1) : WithBot \u03b1) = a + b", "start": [584, 1], "end": [585, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_bit0", "code": "@[norm_cast, deprecated]\ntheorem coe_bit0 : ((bit0 x : \u03b1) : WithBot \u03b1) = (bit0 x : WithBot \u03b1)", "start": [592, 1], "end": [594, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_bit1", "code": "@[norm_cast, deprecated]\ntheorem coe_bit1 [One \u03b1] {a : \u03b1} : ((bit1 a : \u03b1) : WithBot \u03b1) = (bit1 a : WithBot \u03b1)", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_add", "code": "@[simp]\ntheorem bot_add (a : WithBot \u03b1) : \u22a5 + a = \u22a5", "start": [605, 1], "end": [607, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_bot", "code": "@[simp]\ntheorem add_bot (a : WithBot \u03b1) : a + \u22a5 = \u22a5", "start": [610, 1], "end": [611, 66], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_eq_bot", "code": "@[simp]\ntheorem add_eq_bot : a + b = \u22a5 \u2194 a = \u22a5 \u2228 b = \u22a5", "start": [614, 1], "end": [616, 21], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_ne_bot", "code": "theorem add_ne_bot : a + b \u2260 \u22a5 \u2194 a \u2260 \u22a5 \u2227 b \u2260 \u22a5", "start": [619, 1], "end": [620, 21], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_lt_add", "code": "theorem bot_lt_add [LT \u03b1] {a b : WithBot \u03b1} : \u22a5 < a + b \u2194 \u22a5 < a \u2227 \u22a5 < b", "start": [623, 1], "end": [624, 34], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_eq_coe", "code": "theorem add_eq_coe : a + b = x \u2194 \u2203 a' b' : \u03b1, \u2191a' = a \u2227 \u2191b' = b \u2227 a' + b' = x", "start": [627, 1], "end": [628, 21], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_coe_eq_bot_iff", "code": "theorem add_coe_eq_bot_iff : a + y = \u22a5 \u2194 a = \u22a5", "start": [633, 1], "end": [634, 29], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_add_eq_bot_iff", "code": "theorem coe_add_eq_bot_iff : \u2191x + b = \u22a5 \u2194 b = \u22a5", "start": [639, 1], "end": [640, 29], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_right_cancel_iff", "code": "theorem add_right_cancel_iff [IsRightCancelAdd \u03b1] (ha : a \u2260 \u22a5) : b + a = c + a \u2194 b = c", "start": [643, 1], "end": [644, 34], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_right_cancel", "code": "theorem add_right_cancel [IsRightCancelAdd \u03b1] (ha : a \u2260 \u22a5) (h : b + a = c + a) : b = c", "start": [646, 1], "end": [647, 32], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_left_cancel_iff", "code": "theorem add_left_cancel_iff [IsLeftCancelAdd \u03b1] (ha : a \u2260 \u22a5) : a + b = a + c \u2194 b = c", "start": [649, 1], "end": [650, 33], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_left_cancel", "code": "theorem add_left_cancel [IsLeftCancelAdd \u03b1] (ha : a \u2260 \u22a5) (h : a + b = a + c) : b = c", "start": [652, 1], "end": [653, 31], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_add", "code": "@[simp]\nprotected theorem map_add {F} [Add \u03b2] [AddHomClass F \u03b1 \u03b2] (f : F) (a b : WithBot \u03b1) :\n    (a + b).map f = a.map f + b.map f", "start": [656, 1], "end": [659, 24], "kind": "commanddeclaration"}, {"full_name": "OneHom.withBotMap", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n  \"A version of `WithBot.map` for `ZeroHom`s\"]\nprotected def _root_.OneHom.withBotMap {M N : Type*} [One M] [One N] (f : OneHom M N) :\n    OneHom (WithBot M) (WithBot N) where\n  toFun := WithBot.map f\n  map_one' := by rw [WithBot.map_one, map_one, coe_one]", "start": [662, 1], "end": [668, 56], "kind": "commanddeclaration"}, {"full_name": "AddHom.withBotMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.AddHom.withBotMap {M N : Type*} [Add M] [Add N] (f : AddHom M N) :\n    AddHom (WithBot M) (WithBot N) where\n  toFun := WithBot.map f\n  map_add' := WithBot.map_add f", "start": [674, 1], "end": [679, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.withBotMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.AddMonoidHom.withBotMap {M N : Type*} [AddZeroClass M] [AddZeroClass N]\n    (f : M \u2192+ N) : WithBot M \u2192+ WithBot N :=\n  { ZeroHom.withBotMap f.toZeroHom, AddHom.withBotMap f.toAddHom with toFun := WithBot.map f }", "start": [683, 1], "end": [687, 95], "kind": "commanddeclaration"}, {"full_name": "WithBot.covariantClass_add_le", "code": "instance covariantClass_add_le [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (WithBot \u03b1) (WithBot \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  @OrderDual.covariantClass_add_le (WithTop \u03b1\u1d52\u1d48) _ _ _", "start": [693, 1], "end": [695, 55], "kind": "commanddeclaration"}, {"full_name": "WithBot.covariantClass_swap_add_le", "code": "instance covariantClass_swap_add_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (WithBot \u03b1) (WithBot \u03b1) (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  @OrderDual.covariantClass_swap_add_le (WithTop \u03b1\u1d52\u1d48) _ _ _", "start": [698, 1], "end": [700, 60], "kind": "commanddeclaration"}, {"full_name": "WithBot.contravariantClass_add_lt", "code": "instance contravariantClass_add_lt [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass (WithBot \u03b1) (WithBot \u03b1) (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  @OrderDual.contravariantClass_add_lt (WithTop \u03b1\u1d52\u1d48) _ _ _", "start": [703, 1], "end": [705, 59], "kind": "commanddeclaration"}, {"full_name": "WithBot.contravariantClass_swap_add_lt", "code": "instance contravariantClass_swap_add_lt [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    ContravariantClass (WithBot \u03b1) (WithBot \u03b1) (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  @OrderDual.contravariantClass_swap_add_lt (WithTop \u03b1\u1d52\u1d48) _ _ _", "start": [708, 1], "end": [710, 64], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_of_add_le_add_left", "code": "protected theorem le_of_add_le_add_left [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a5)\n    (h : a + b \u2264 a + c) : b \u2264 c", "start": [713, 1], "end": [715, 54], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_of_add_le_add_right", "code": "protected theorem le_of_add_le_add_right [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (ha : a \u2260 \u22a5) (h : b + a \u2264 c + a) : b \u2264 c", "start": [718, 1], "end": [720, 55], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_left", "code": "protected theorem add_lt_add_left [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a5) (h : b < c) :\n    a + b < a + c", "start": [723, 1], "end": [725, 48], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_right", "code": "protected theorem add_lt_add_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a5)\n    (h : b < c) : b + a < c + a", "start": [728, 1], "end": [730, 49], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_le_add_iff_left", "code": "protected theorem add_le_add_iff_left [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a5) : a + b \u2264 a + c \u2194 b \u2264 c", "start": [733, 1], "end": [735, 67], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_le_add_iff_right", "code": "protected theorem add_le_add_iff_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a5) : b + a \u2264 c + a \u2194 b \u2264 c", "start": [738, 1], "end": [740, 69], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a5) : a + b < a + c \u2194 b < c", "start": [743, 1], "end": [745, 54], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (ha : a \u2260 \u22a5) : b + a < c + a \u2194 b < c", "start": [748, 1], "end": [750, 56], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_of_le_of_lt", "code": "protected theorem add_lt_add_of_le_of_lt [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (hb : b \u2260 \u22a5) (hab : a \u2264 b) (hcd : c < d) :\n    a + c < b + d", "start": [753, 1], "end": [756, 65], "kind": "commanddeclaration"}, {"full_name": "WithBot.add_lt_add_of_lt_of_le", "code": "protected theorem add_lt_add_of_lt_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (hd : d \u2260 \u22a5) (hab : a < b) (hcd : c \u2264 d) :\n    a + c < b + d", "start": [759, 1], "end": [762, 65], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderedAddCommMonoid", "code": "instance orderedAddCommMonoid [OrderedAddCommMonoid \u03b1] : OrderedAddCommMonoid (WithBot \u03b1) :=\n  { WithBot.partialOrder, WithBot.addCommMonoid with\n    add_le_add_left := fun _ _ h c => add_le_add_left h c }", "start": [767, 1], "end": [769, 60], "kind": "commanddeclaration"}, {"full_name": "WithBot.linearOrderedAddCommMonoid", "code": "instance linearOrderedAddCommMonoid [LinearOrderedAddCommMonoid \u03b1] :\n    LinearOrderedAddCommMonoid (WithBot \u03b1) :=\n  { WithBot.linearOrder, WithBot.orderedAddCommMonoid with }", "start": [771, 1], "end": [773, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Size.lean", "imports": ["Mathlib/Data/Nat/Bits.lean", "Mathlib/Data/Nat/Pow.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.shiftLeft_eq_mul_pow", "code": "theorem shiftLeft_eq_mul_pow (m) : \u2200 n, m <<< n = m * 2 ^ n", "start": [20, 1], "end": [20, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_tt_eq_mul_pow", "code": "theorem shiftLeft'_tt_eq_mul_pow (m) : \u2200 n, shiftLeft' true m n + 1 = (m + 1) * 2 ^ n", "start": [23, 1], "end": [29, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_shiftLeft", "code": "theorem zero_shiftLeft (n) : 0 <<< n = 0", "start": [36, 1], "end": [36, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_ne_zero_left", "code": "theorem shiftLeft'_ne_zero_left (b) {m} (h : m \u2260 0) (n) : shiftLeft' b m n \u2260 0", "start": [41, 1], "end": [42, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_tt_ne_zero", "code": "theorem shiftLeft'_tt_ne_zero (m) : \u2200 {n}, (n \u2260 0) \u2192 shiftLeft' true m n \u2260 0", "start": [45, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.size_zero", "code": "@[simp]\ntheorem size_zero : size 0 = 0", "start": [53, 1], "end": [54, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.size_bit", "code": "@[simp]\ntheorem size_bit {b n} (h : bit b n \u2260 0) : size (bit b n) = succ (size n)", "start": [57, 1], "end": [64, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.size_bit0", "code": "@[simp]\ntheorem size_bit0 {n} (h : n \u2260 0) : size (bit0 n) = succ (size n)", "start": [70, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.size_bit1", "code": "@[simp]\ntheorem size_bit1 (n) : size (bit1 n) = succ (size n)", "start": [75, 1], "end": [77, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.size_one", "code": "@[simp]\ntheorem size_one : size 1 = 1", "start": [80, 1], "end": [82, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.size_shiftLeft'", "code": "@[simp]\ntheorem size_shiftLeft' {b m n} (h : shiftLeft' b m n \u2260 0) :\n    size (shiftLeft' b m n) = size m + n", "start": [87, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.size_shiftLeft", "code": "@[simp, nolint simpNF]\ntheorem size_shiftLeft {m} (h : m \u2260 0) (n) : size (m <<< n) = size m + n", "start": [107, 1], "end": [109, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_size_self", "code": "theorem lt_size_self (n : \u2115) : n < 2 ^ size n", "start": [112, 1], "end": [121, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.size_le", "code": "theorem size_le {m n : \u2115} : size m \u2264 n \u2194 m < 2 ^ n", "start": [124, 1], "end": [139, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_size", "code": "theorem lt_size {m n : \u2115} : m < size n \u2194 2 ^ m \u2264 n", "start": [142, 1], "end": [143, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.size_pos", "code": "theorem size_pos {n : \u2115} : 0 < size n \u2194 0 < n", "start": [146, 1], "end": [146, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.size_eq_zero", "code": "theorem size_eq_zero {n : \u2115} : size n = 0 \u2194 n = 0", "start": [149, 1], "end": [150, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.size_pow", "code": "theorem size_pow {n : \u2115} : size (2 ^ n) = n + 1", "start": [153, 1], "end": [155, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.size_le_size", "code": "theorem size_le_size {m n : \u2115} (h : m \u2264 n) : size m \u2264 size n", "start": [158, 1], "end": [159, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.size_eq_bits_len", "code": "theorem size_eq_bits_len (n : \u2115) : n.bits.length = n.size", "start": [162, 1], "end": [166, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Dvd/Basic.lean", "imports": ["Mathlib/Data/Nat/Cast/Order.lean", "Mathlib/Data/Int/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.coe_nat_dvd", "code": "@[norm_cast]\ntheorem coe_nat_dvd {m n : \u2115} : (\u2191m : \u2124) \u2223 \u2191n \u2194 m \u2223 n", "start": [20, 1], "end": [30, 59], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_dvd_left", "code": "theorem coe_nat_dvd_left {n : \u2115} {z : \u2124} : (\u2191n : \u2124) \u2223 z \u2194 n \u2223 z.natAbs", "start": [33, 1], "end": [34, 72], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_dvd_right", "code": "theorem coe_nat_dvd_right {n : \u2115} {z : \u2124} : z \u2223 (\u2191n : \u2124) \u2194 z.natAbs \u2223 n", "start": [37, 1], "end": [38, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Order/Lemmas.lean", "imports": ["Mathlib/Data/Nat/Units.lean", "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "Nat.Subtype.orderBot", "code": "instance Subtype.orderBot (s : Set \u2115) [DecidablePred (\u00b7 \u2208 s)] [h : Nonempty s] : OrderBot s where\n  bot := \u27e8Nat.find (nonempty_subtype.1 h), Nat.find_spec (nonempty_subtype.1 h)\u27e9\n  bot_le x := Nat.find_min' _ x.2", "start": [33, 1], "end": [35, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.semilatticeSup", "code": "instance Subtype.semilatticeSup (s : Set \u2115) : SemilatticeSup s :=\n  { Subtype.linearOrder s, LinearOrder.toLattice with }", "start": [38, 1], "end": [39, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.coe_bot", "code": "theorem Subtype.coe_bot {s : Set \u2115} [DecidablePred (\u00b7 \u2208 s)] [h : Nonempty s] :\n    ((\u22a5 : s) : \u2115) = Nat.find (nonempty_subtype.1 h)", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.set_eq_univ", "code": "theorem set_eq_univ {S : Set \u2115} : S = Set.univ \u2194 0 \u2208 S \u2227 \u2200 k : \u2115, k \u2208 S \u2192 k + 1 \u2208 S", "start": [47, 1], "end": [48, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_div_iff_mul_lt", "code": "protected theorem lt_div_iff_mul_lt {n d : \u2115} (hnd : d \u2223 n) (a : \u2115) : a < n / d \u2194 d * a < n", "start": [53, 1], "end": [55, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_eq_iff_dvd", "code": "theorem mul_div_eq_iff_dvd {n d : \u2115} : d * (n / d) = n \u2194 d \u2223 n", "start": [59, 1], "end": [62, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_lt_iff_not_dvd", "code": "theorem mul_div_lt_iff_not_dvd {n d : \u2115} : d * (n / d) < n \u2194 \u00ac(d \u2223 n)", "start": [65, 1], "end": [66, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_iff_eq_of_dvd_dvd", "code": "theorem div_eq_iff_eq_of_dvd_dvd {n x y : \u2115} (hn : n \u2260 0) (hx : x \u2223 n) (hy : y \u2223 n) :\n    n / x = n / y \u2194 x = y", "start": [68, 1], "end": [77, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_zero_iff", "code": "protected theorem div_eq_zero_iff {a b : \u2115} (hb : 0 < b) : a / b = 0 \u2194 a < b", "start": [80, 1], "end": [83, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_one", "code": "@[simp]\nprotected theorem dvd_one {n : \u2115} : n \u2223 1 \u2194 n = 1", "start": [91, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.not_two_dvd_bit1", "code": "@[simp]\nprotected theorem not_two_dvd_bit1 (n : \u2115) : \u00ac2 \u2223 bit1 n", "start": [97, 1], "end": [101, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_self_left", "code": "@[simp]\nprotected theorem dvd_add_self_left {m n : \u2115} : m \u2223 m + n \u2194 m \u2223 n", "start": [104, 1], "end": [107, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_self_right", "code": "@[simp]\nprotected theorem dvd_add_self_right {m n : \u2115} : m \u2223 n + m \u2194 m \u2223 n", "start": [110, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_sub'", "code": "theorem dvd_sub' {k m n : \u2115} (h\u2081 : k \u2223 m) (h\u2082 : k \u2223 n) : k \u2223 m - n", "start": [117, 1], "end": [121, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_div", "code": "theorem succ_div : \u2200 a b : \u2115, (a + 1) / b = a / b + if b \u2223 a + 1 then 1 else 0", "start": [124, 1], "end": [151, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_div_of_dvd", "code": "theorem succ_div_of_dvd {a b : \u2115} (hba : b \u2223 a + 1) : (a + 1) / b = a / b + 1", "start": [154, 1], "end": [155, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_div_of_not_dvd", "code": "theorem succ_div_of_not_dvd {a b : \u2115} (hba : \u00acb \u2223 a + 1) : (a + 1) / b = a / b", "start": [158, 1], "end": [159, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_div_mul_eq", "code": "theorem dvd_iff_div_mul_eq (n d : \u2115) : d \u2223 n \u2194 n / d * d = n", "start": [162, 1], "end": [163, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_le_div_mul", "code": "theorem dvd_iff_le_div_mul (n d : \u2115) : d \u2223 n \u2194 n \u2264 n / d * d", "start": [166, 1], "end": [167, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_iff_dvd_dvd", "code": "theorem dvd_iff_dvd_dvd (n d : \u2115) : d \u2223 n \u2194 \u2200 k : \u2115, k \u2223 d \u2192 k \u2223 n", "start": [170, 1], "end": [171, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_div_of_mul_dvd", "code": "theorem dvd_div_of_mul_dvd {a b c : \u2115} (h : a * b \u2223 c) : b \u2223 c / a", "start": [174, 1], "end": [181, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_div_iff", "code": "@[simp]\ntheorem dvd_div_iff {a b c : \u2115} (hbc : c \u2223 b) : a \u2223 b / c \u2194 c * a \u2223 b", "start": [184, 1], "end": [186, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.div_div_div_eq_div", "code": "@[simp]\ntheorem div_div_div_eq_div {a b c : \u2115} (dvd : b \u2223 a) (dvd2 : a \u2223 c) : c / (a / b) / b = c / a", "start": [189, 1], "end": [203, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_dvd_of_lt", "code": "theorem eq_zero_of_dvd_of_lt {a b : \u2115} (w : a \u2223 b) (h : b < a) : b = 0", "start": [206, 1], "end": [210, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_lt_add_of_dvd", "code": "theorem le_of_lt_add_of_dvd (h : a < b + n) : n \u2223 a \u2192 n \u2223 b \u2192 a \u2264 b", "start": [213, 1], "end": [217, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_div_self", "code": "@[simp]\ntheorem mod_div_self (m n : \u2115) : m % n / n = 0", "start": [220, 1], "end": [224, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.not_dvd_iff_between_consec_multiples", "code": "theorem not_dvd_iff_between_consec_multiples (n : \u2115) {a : \u2115} (ha : 0 < a) :\n    (\u2203 k : \u2115, a * k < n \u2227 n < a * (k + 1)) \u2194 \u00aca \u2223 n", "start": [227, 1], "end": [233, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_right_iff_eq", "code": "theorem dvd_right_iff_eq {m n : \u2115} : (\u2200 a : \u2115, m \u2223 a \u2194 n \u2223 a) \u2194 m = n", "start": [236, 1], "end": [238, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_left_iff_eq", "code": "theorem dvd_left_iff_eq {m n : \u2115} : (\u2200 a : \u2115, a \u2223 m \u2194 a \u2223 n) \u2194 m = n", "start": [241, 1], "end": [243, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_left_injective", "code": "theorem dvd_left_injective : Function.Injective ((\u00b7 \u2223 \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop)", "start": [246, 1], "end": [248, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_div_of_lt_of_dvd", "code": "theorem div_lt_div_of_lt_of_dvd {a b d : \u2115} (hdb : d \u2223 b) (h : a < b) : a / d < b / d", "start": [251, 1], "end": [253, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Regular.lean", "imports": ["Mathlib/Algebra/Regular/Basic.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "isLeftRegular_of_non_zero_divisor", "code": "theorem isLeftRegular_of_non_zero_divisor [NonUnitalNonAssocRing \u03b1] (k : \u03b1)\n    (h : \u2200 x : \u03b1, k * x = 0 \u2192 x = 0) : IsLeftRegular k", "start": [18, 1], "end": [23, 32], "kind": "commanddeclaration"}, {"full_name": "isRightRegular_of_non_zero_divisor", "code": "theorem isRightRegular_of_non_zero_divisor [NonUnitalNonAssocRing \u03b1] (k : \u03b1)\n    (h : \u2200 x : \u03b1, x * k = 0 \u2192 x = 0) : IsRightRegular k", "start": [26, 1], "end": [31, 32], "kind": "commanddeclaration"}, {"full_name": "isRegular_of_ne_zero'", "code": "theorem isRegular_of_ne_zero' [NonUnitalNonAssocRing \u03b1] [NoZeroDivisors \u03b1] {k : \u03b1} (hk : k \u2260 0) :\n    IsRegular k", "start": [34, 1], "end": [39, 77], "kind": "commanddeclaration"}, {"full_name": "isRegular_iff_ne_zero'", "code": "theorem isRegular_iff_ne_zero' [Nontrivial \u03b1] [NonUnitalNonAssocRing \u03b1] [NoZeroDivisors \u03b1]\n    {k : \u03b1} : IsRegular k \u2194 k \u2260 0", "start": [42, 1], "end": [46, 76], "kind": "commanddeclaration"}, {"full_name": "NoZeroDivisors.toCancelMonoidWithZero", "code": "@[reducible]\ndef NoZeroDivisors.toCancelMonoidWithZero [Ring \u03b1] [NoZeroDivisors \u03b1] : CancelMonoidWithZero \u03b1 :=\n  { (by infer_instance : MonoidWithZero \u03b1) with\n    mul_left_cancel_of_ne_zero := fun ha =>\n      @IsRegular.left _ _ _ (isRegular_of_ne_zero' ha) _ _,\n    mul_right_cancel_of_ne_zero := fun hb =>\n      @IsRegular.right _ _ _ (isRegular_of_ne_zero' hb) _ _ }", "start": [49, 1], "end": [58, 62], "kind": "commanddeclaration"}, {"full_name": "NoZeroDivisors.toCancelCommMonoidWithZero", "code": "@[reducible]\ndef NoZeroDivisors.toCancelCommMonoidWithZero [CommRing \u03b1] [NoZeroDivisors \u03b1] :\n    CancelCommMonoidWithZero \u03b1 :=\n  { NoZeroDivisors.toCancelMonoidWithZero, \u2039CommRing \u03b1\u203a with }", "start": [61, 1], "end": [67, 63], "kind": "commanddeclaration"}, {"full_name": "IsDomain.toCancelMonoidWithZero", "code": "instance (priority := 100) IsDomain.toCancelMonoidWithZero [Semiring \u03b1] [IsDomain \u03b1] :\n    CancelMonoidWithZero \u03b1 :=\n  { }", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "IsDomain.toCancelCommMonoidWithZero", "code": "instance (priority := 100) IsDomain.toCancelCommMonoidWithZero : CancelCommMonoidWithZero \u03b1 :=\n  { mul_left_cancel_of_ne_zero := IsLeftCancelMulZero.mul_left_cancel_of_ne_zero }", "start": [81, 1], "end": [82, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Sort.lean", "imports": ["Mathlib/Data/List/OfFn.lean", "Mathlib/Data/List/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Sorted", "code": "def Sorted :=\n  @Pairwise", "start": [35, 1], "end": [38, 12], "kind": "commanddeclaration"}, {"full_name": "List.decidableSorted", "code": "instance decidableSorted [DecidableRel r] (l : List \u03b1) : Decidable (Sorted r l) :=\n  List.instDecidablePairwise _", "start": [41, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.le_of_lt", "code": "protected theorem Sorted.le_of_lt [Preorder \u03b1] {l : List \u03b1} (h : l.Sorted (\u00b7 < \u00b7)) :\n    l.Sorted (\u00b7 \u2264 \u00b7)", "start": [45, 1], "end": [47, 17], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.lt_of_le", "code": "protected theorem Sorted.lt_of_le [PartialOrder \u03b1] {l : List \u03b1} (h\u2081 : l.Sorted (\u00b7 \u2264 \u00b7))\n    (h\u2082 : l.Nodup) : l.Sorted (\u00b7 < \u00b7)", "start": [49, 1], "end": [51, 41], "kind": "commanddeclaration"}, {"full_name": "List.sorted_nil", "code": "@[simp]\ntheorem sorted_nil : Sorted r []", "start": [53, 1], "end": [55, 15], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.of_cons", "code": "theorem Sorted.of_cons : Sorted r (a :: l) \u2192 Sorted r l", "start": [58, 1], "end": [59, 19], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.tail", "code": "theorem Sorted.tail {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {l : List \u03b1} (h : Sorted r l) : Sorted r l.tail", "start": [62, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "List.rel_of_sorted_cons", "code": "theorem rel_of_sorted_cons {a : \u03b1} {l : List \u03b1} : Sorted r (a :: l) \u2192 \u2200 b \u2208 l, r a b", "start": [66, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "List.sorted_cons", "code": "@[simp]\ntheorem sorted_cons {a : \u03b1} {l : List \u03b1} : Sorted r (a :: l) \u2194 (\u2200 b \u2208 l, r a b) \u2227 Sorted r l", "start": [70, 1], "end": [72, 16], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.nodup", "code": "protected theorem Sorted.nodup {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsIrrefl \u03b1 r] {l : List \u03b1} (h : Sorted r l) :\n    Nodup l", "start": [75, 1], "end": [77, 19], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_perm_of_sorted", "code": "theorem eq_of_perm_of_sorted [IsAntisymm \u03b1 r] {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) (s\u2081 : Sorted r l\u2081)\n    (s\u2082 : Sorted r l\u2082) : l\u2081 = l\u2082", "start": [80, 1], "end": [96, 42], "kind": "commanddeclaration"}, {"full_name": "List.sublist_of_subperm_of_sorted", "code": "theorem sublist_of_subperm_of_sorted [IsAntisymm \u03b1 r] {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 <+~ l\u2082)\n    (s\u2081 : l\u2081.Sorted r) (s\u2082 : l\u2082.Sorted r) : l\u2081 <+ l\u2082", "start": [99, 1], "end": [102, 52], "kind": "commanddeclaration"}, {"full_name": "List.sorted_singleton", "code": "@[simp 1100] theorem sorted_singleton (a : \u03b1) : Sorted r [a]", "start": [105, 1], "end": [107, 25], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.rel_get_of_lt", "code": "theorem Sorted.rel_get_of_lt {l : List \u03b1} (h : l.Sorted r) {a b : Fin l.length} (hab : a < b) :\n    r (l.get a) (l.get b)", "start": [110, 1], "end": [112, 36], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.rel_nthLe_of_lt", "code": "theorem Sorted.rel_nthLe_of_lt {l : List \u03b1} (h : l.Sorted r) {a b : \u2115} (ha : a < l.length)\n    (hb : b < l.length) (hab : a < b) : r (l.nthLe a ha) (l.nthLe b hb)", "start": [114, 1], "end": [116, 48], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.rel_get_of_le", "code": "theorem Sorted.rel_get_of_le [IsRefl \u03b1 r] {l : List \u03b1} (h : l.Sorted r) {a b : Fin l.length}\n    (hab : a \u2264 b) : r (l.get a) (l.get b)", "start": [119, 1], "end": [122, 39], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.rel_nthLe_of_le", "code": "theorem Sorted.rel_nthLe_of_le [IsRefl \u03b1 r] {l : List \u03b1} (h : l.Sorted r) {a b : \u2115}\n    (ha : a < l.length) (hb : b < l.length) (hab : a \u2264 b) : r (l.nthLe a ha) (l.nthLe b hb)", "start": [124, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.rel_of_mem_take_of_mem_drop", "code": "theorem Sorted.rel_of_mem_take_of_mem_drop {l : List \u03b1} (h : List.Sorted r l) {k : \u2115} {x y : \u03b1}\n    (hx : x \u2208 List.take k l) (hy : y \u2208 List.drop k l) : r x y", "start": [129, 1], "end": [135, 77], "kind": "commanddeclaration"}, {"full_name": "List.sorted_ofFn_iff", "code": "theorem sorted_ofFn_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : (ofFn f).Sorted r \u2194 ((\u00b7 < \u00b7) \u21d2 r) f f", "start": [144, 1], "end": [146, 62], "kind": "commanddeclaration"}, {"full_name": "List.sorted_lt_ofFn_iff", "code": "@[simp] theorem sorted_lt_ofFn_iff : (ofFn f).Sorted (\u00b7 < \u00b7) \u2194 StrictMono f", "start": [148, 1], "end": [150, 95], "kind": "commanddeclaration"}, {"full_name": "List.sorted_le_ofFn_iff", "code": "@[simp] theorem sorted_le_ofFn_iff : (ofFn f).Sorted (\u00b7 \u2264 \u00b7) \u2194 Monotone f", "start": [152, 1], "end": [154, 52], "kind": "commanddeclaration"}, {"full_name": "List.monotone_iff_ofFn_sorted", "code": "@[deprecated sorted_le_ofFn_iff]\ntheorem monotone_iff_ofFn_sorted : Monotone f \u2194 (ofFn f).Sorted (\u00b7 \u2264 \u00b7)", "start": [156, 1], "end": [158, 99], "kind": "commanddeclaration"}, {"full_name": "Monotone.ofFn_sorted", "code": "alias \u27e8_, _root_.Monotone.ofFn_sorted\u27e9 := sorted_le_ofFn_iff", "start": [161, 1], "end": [162, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.orderedInsert", "code": "@[simp]\ndef orderedInsert (a : \u03b1) : List \u03b1 \u2192 List \u03b1\n  | [] => [a]\n  | b :: l => if a \u227c b then a :: b :: l else b :: orderedInsert a l", "start": [178, 1], "end": [183, 68], "kind": "commanddeclaration"}, {"full_name": "List.insertionSort", "code": "@[simp]\ndef insertionSort : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | b :: l => orderedInsert r b (insertionSort l)", "start": [186, 1], "end": [190, 50], "kind": "commanddeclaration"}, {"full_name": "List.orderedInsert_nil", "code": "@[simp]\ntheorem orderedInsert_nil (a : \u03b1) : [].orderedInsert r a = [a]", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "List.orderedInsert_length", "code": "theorem orderedInsert_length : \u2200 (L : List \u03b1) (a : \u03b1), (L.orderedInsert r a).length = L.length + 1", "start": [198, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "List.orderedInsert_eq_take_drop", "code": "theorem orderedInsert_eq_take_drop (a : \u03b1) :\n    \u2200 l : List \u03b1,\n      l.orderedInsert r a = (l.takeWhile fun b => \u00aca \u227c b) ++ a :: l.dropWhile fun b => \u00aca \u227c b", "start": [205, 1], "end": [212, 88], "kind": "commanddeclaration"}, {"full_name": "List.insertionSort_cons_eq_take_drop", "code": "theorem insertionSort_cons_eq_take_drop (a : \u03b1) (l : List \u03b1) :\n    insertionSort r (a :: l) =\n      ((insertionSort r l).takeWhile fun b => \u00aca \u227c b) ++\n        a :: (insertionSort r l).dropWhile fun b => \u00aca \u227c b", "start": [215, 1], "end": [219, 35], "kind": "commanddeclaration"}, {"full_name": "List.perm_orderedInsert", "code": "theorem perm_orderedInsert (a) : \u2200 l : List \u03b1, orderedInsert r a l ~ a :: l", "start": [226, 1], "end": [231, 95], "kind": "commanddeclaration"}, {"full_name": "List.orderedInsert_count", "code": "theorem orderedInsert_count [DecidableEq \u03b1] (L : List \u03b1) (a b : \u03b1) :\n    count a (L.orderedInsert r b) = count a L + if a = b then 1 else 0", "start": [234, 1], "end": [236, 55], "kind": "commanddeclaration"}, {"full_name": "List.perm_insertionSort", "code": "theorem perm_insertionSort : \u2200 l : List \u03b1, insertionSort r l ~ l", "start": [239, 1], "end": [242, 97], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.insertionSort_eq", "code": "theorem Sorted.insertionSort_eq : \u2200 {l : List \u03b1} (_ : Sorted r l), insertionSort r l = l", "start": [247, 1], "end": [254, 64], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.orderedInsert", "code": "theorem Sorted.orderedInsert (a : \u03b1) : \u2200 l, Sorted r l \u2192 Sorted r (orderedInsert r a l)", "start": [261, 1], "end": [275, 40], "kind": "commanddeclaration"}, {"full_name": "List.sorted_insertionSort", "code": "theorem sorted_insertionSort : \u2200 l, Sorted r (insertionSort r l)", "start": [280, 1], "end": [283, 57], "kind": "commanddeclaration"}, {"full_name": "List.split", "code": "@[simp]\ndef split : List \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n  | [] => ([], [])\n  | a :: l =>\n    let (l\u2081, l\u2082) := split l\n    (a :: l\u2082, l\u2081)", "start": [299, 1], "end": [307, 18], "kind": "commanddeclaration"}, {"full_name": "List.split_cons_of_eq", "code": "theorem split_cons_of_eq (a : \u03b1) {l l\u2081 l\u2082 : List \u03b1} (h : split l = (l\u2081, l\u2082)) :\n    split (a :: l) = (a :: l\u2082, l\u2081)", "start": [310, 1], "end": [311, 55], "kind": "commanddeclaration"}, {"full_name": "List.length_split_le", "code": "theorem length_split_le :\n    \u2200 {l l\u2081 l\u2082 : List \u03b1}, split l = (l\u2081, l\u2082) \u2192 length l\u2081 \u2264 length l \u2227 length l\u2082 \u2264 length l", "start": [314, 1], "end": [321, 54], "kind": "commanddeclaration"}, {"full_name": "List.length_split_lt", "code": "theorem length_split_lt {a b} {l l\u2081 l\u2082 : List \u03b1} (h : split (a :: b :: l) = (l\u2081, l\u2082)) :\n    length l\u2081 < length (a :: b :: l) \u2227 length l\u2082 < length (a :: b :: l)", "start": [324, 1], "end": [329, 89], "kind": "commanddeclaration"}, {"full_name": "List.perm_split", "code": "theorem perm_split : \u2200 {l l\u2081 l\u2082 : List \u03b1}, split l = (l\u2081, l\u2082) \u2192 l ~ l\u2081 ++ l\u2082", "start": [332, 1], "end": [337, 57], "kind": "commanddeclaration"}, {"full_name": "List.merge", "code": "def merge : List \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | [], l' => l'\n  | l, [] => l\n  | a :: l, b :: l' => if a \u227c b then a :: merge l (b :: l') else b :: merge (a :: l) l'\n  termination_by merge l\u2081 l\u2082 => length l\u2081 + length l\u2082", "start": [340, 1], "end": [347, 54], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort", "code": "def mergeSort : List \u03b1 \u2192 List \u03b1\n  | [] => []\n  | [a] => [a]\n  | a :: b :: l => by\n    let ls := (split (a :: b :: l))\n    have e : split (a :: b :: l) = \u27e8ls.1, ls.2\u27e9 := rfl\n    have h := length_split_lt e\n    have := h.1\n    have := h.2\n    exact merge r (mergeSort ls.1) (mergeSort ls.2)\n  termination_by mergeSort l => length l", "start": [350, 1], "end": [362, 41], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort_cons_cons", "code": "@[nolint unusedHavesSuffices] theorem mergeSort_cons_cons {a b} {l l\u2081 l\u2082 : List \u03b1} (h : split (a :: b :: l) = (l\u2081, l\u2082)) :\n    mergeSort r (a :: b :: l) = merge r (mergeSort r l\u2081) (mergeSort r l\u2082)", "start": [365, 1], "end": [368, 27], "kind": "commanddeclaration"}, {"full_name": "List.perm_merge", "code": "theorem perm_merge : \u2200 l l' : List \u03b1, merge r l l' ~ l ++ l'", "start": [373, 1], "end": [382, 59], "kind": "commanddeclaration"}, {"full_name": "List.perm_mergeSort", "code": "theorem perm_mergeSort : \u2200 l : List \u03b1, mergeSort r l ~ l", "start": [385, 1], "end": [395, 46], "kind": "commanddeclaration"}, {"full_name": "List.length_mergeSort", "code": "@[simp]\ntheorem length_mergeSort (l : List \u03b1) : (mergeSort r l).length = l.length", "start": [398, 1], "end": [400, 33], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.merge", "code": "theorem Sorted.merge : \u2200 {l l' : List \u03b1}, Sorted r l \u2192 Sorted r l' \u2192 Sorted r (merge r l l')", "start": [407, 1], "end": [433, 65], "kind": "commanddeclaration"}, {"full_name": "List.sorted_mergeSort", "code": "theorem sorted_mergeSort : \u2200 l : List \u03b1, Sorted r (mergeSort r l)", "start": [438, 1], "end": [446, 48], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort_eq_self", "code": "theorem mergeSort_eq_self [IsAntisymm \u03b1 r] {l : List \u03b1} : Sorted r l \u2192 mergeSort r l = l", "start": [449, 1], "end": [450, 67], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort_eq_insertionSort", "code": "theorem mergeSort_eq_insertionSort [IsAntisymm \u03b1 r] (l : List \u03b1) :\n    mergeSort r l = insertionSort r l", "start": [453, 1], "end": [456, 54], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort_nil", "code": "@[simp]\ntheorem mergeSort_nil : [].mergeSort r = []", "start": [463, 1], "end": [464, 70], "kind": "commanddeclaration"}, {"full_name": "List.mergeSort_singleton", "code": "@[simp]\ntheorem mergeSort_singleton (a : \u03b1) : [a].mergeSort r = [a]", "start": [467, 1], "end": [468, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Duplicate.lean", "imports": ["Mathlib/Data/List/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Duplicate", "code": "inductive Duplicate (x : \u03b1) : List \u03b1 \u2192 Prop\n  | cons_mem {l : List \u03b1} : x \u2208 l \u2192 Duplicate x (x :: l)\n  | cons_duplicate {y : \u03b1} {l : List \u03b1} : Duplicate x l \u2192 Duplicate x (y :: l)", "start": [28, 1], "end": [31, 79], "kind": "commanddeclaration"}, {"full_name": "List.Mem.duplicate_cons_self", "code": "theorem Mem.duplicate_cons_self (h : x \u2208 l) : x \u2208+ x :: l", "start": [39, 1], "end": [40, 23], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.duplicate_cons", "code": "theorem Duplicate.duplicate_cons (h : x \u2208+ l) (y : \u03b1) : x \u2208+ y :: l", "start": [43, 1], "end": [44, 29], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.mem", "code": "theorem Duplicate.mem (h : x \u2208+ l) : x \u2208 l", "start": [47, 1], "end": [50, 31], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.mem_cons_self", "code": "theorem Duplicate.mem_cons_self (h : x \u2208+ x :: l) : x \u2208 l", "start": [53, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_cons_self_iff", "code": "@[simp]\ntheorem duplicate_cons_self_iff : x \u2208+ x :: l \u2194 x \u2208 l", "start": [59, 1], "end": [61, 53], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.ne_nil", "code": "theorem Duplicate.ne_nil (h : x \u2208+ l) : l \u2260 []", "start": [64, 1], "end": [64, 90], "kind": "commanddeclaration"}, {"full_name": "List.not_duplicate_nil", "code": "@[simp]\ntheorem not_duplicate_nil (x : \u03b1) : \u00acx \u2208+ []", "start": [67, 1], "end": [68, 70], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.ne_singleton", "code": "theorem Duplicate.ne_singleton (h : x \u2208+ l) (y : \u03b1) : l \u2260 [y]", "start": [71, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "List.not_duplicate_singleton", "code": "@[simp]\ntheorem not_duplicate_singleton (x y : \u03b1) : \u00acx \u2208+ [y]", "start": [77, 1], "end": [78, 87], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.elim_nil", "code": "theorem Duplicate.elim_nil (h : x \u2208+ []) : False", "start": [81, 1], "end": [82, 24], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.elim_singleton", "code": "theorem Duplicate.elim_singleton {y : \u03b1} (h : x \u2208+ [y]) : False", "start": [85, 1], "end": [86, 32], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_cons_iff", "code": "theorem duplicate_cons_iff {y : \u03b1} : x \u2208+ y :: l \u2194 y = x \u2227 x \u2208 l \u2228 x \u2208+ l", "start": [89, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.of_duplicate_cons", "code": "theorem Duplicate.of_duplicate_cons {y : \u03b1} (h : x \u2208+ y :: l) (hx : x \u2260 y) : x \u2208+ l", "start": [99, 1], "end": [100, 46], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_cons_iff_of_ne", "code": "theorem duplicate_cons_iff_of_ne {y : \u03b1} (hne : x \u2260 y) : x \u2208+ y :: l \u2194 x \u2208+ l", "start": [103, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.mono_sublist", "code": "theorem Duplicate.mono_sublist {l' : List \u03b1} (hx : x \u2208+ l) (h : l <+ l') : x \u2208+ l'", "start": [107, 1], "end": [114, 19], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_iff_sublist", "code": "theorem duplicate_iff_sublist : x \u2208+ l \u2194 [x, x] <+ l", "start": [117, 1], "end": [127, 22], "kind": "commanddeclaration"}, {"full_name": "List.nodup_iff_forall_not_duplicate", "code": "theorem nodup_iff_forall_not_duplicate : Nodup l \u2194 \u2200 x : \u03b1, \u00acx \u2208+ l", "start": [130, 1], "end": [131, 53], "kind": "commanddeclaration"}, {"full_name": "List.exists_duplicate_iff_not_nodup", "code": "theorem exists_duplicate_iff_not_nodup : (\u2203 x : \u03b1, x \u2208+ l) \u2194 \u00acNodup l", "start": [134, 1], "end": [135, 40], "kind": "commanddeclaration"}, {"full_name": "List.Duplicate.not_nodup", "code": "theorem Duplicate.not_nodup (h : x \u2208+ l) : \u00acNodup l", "start": [138, 1], "end": [139, 42], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_iff_two_le_count", "code": "theorem duplicate_iff_two_le_count [DecidableEq \u03b1] : x \u2208+ l \u2194 2 \u2264 count x l", "start": [142, 1], "end": [143, 63], "kind": "commanddeclaration"}, {"full_name": "List.decidableDuplicate", "code": "instance decidableDuplicate [DecidableEq \u03b1] (x : \u03b1) : \u2200 l : List \u03b1, Decidable (x \u2208+ l)\n  | [] => isFalse (not_duplicate_nil x)\n  | y :: l =>\n    match decidableDuplicate x l with\n    | isTrue h => isTrue (h.duplicate_cons y)\n    | isFalse h =>\n      if hx : y = x \u2227 x \u2208 l then isTrue (hx.left.symm \u25b8 List.Mem.duplicate_cons_self hx.right)\n      else isFalse (by simpa [duplicate_cons_iff, h] using hx)", "start": [146, 1], "end": [153, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Positivity/Basic.lean", "imports": ["Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Data/Int/Order/Basic.lean", "lake-packages/std/Std/Lean/Parser.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Positivity/Core.lean", "Mathlib/Tactic/HaveI.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Data/Int/CharZero.lean"], "premises": [{"full_name": "Mathlib.Meta.Positivity.ite_pos", "code": "private lemma ite_pos [LT \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < ite p a b :=\nby by_cases p <;> simp [*]", "start": [30, 1], "end": [31, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_nonneg", "code": "private lemma ite_nonneg [LE \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 ite p a b :=\nby by_cases p <;> simp [*]", "start": [33, 1], "end": [34, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_nonneg_of_pos_of_nonneg", "code": "private lemma ite_nonneg_of_pos_of_nonneg [Preorder \u03b1] (ha : 0 < a) (hb : 0 \u2264 b) : 0 \u2264 ite p a b :=\nite_nonneg _ ha.le hb", "start": [36, 1], "end": [37, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_nonneg_of_nonneg_of_pos", "code": "private lemma ite_nonneg_of_nonneg_of_pos [Preorder \u03b1] (ha : 0 \u2264 a) (hb : 0 < b) : 0 \u2264 ite p a b :=\nite_nonneg _ ha hb.le", "start": [39, 1], "end": [40, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_ne_zero", "code": "private lemma ite_ne_zero (ha : a \u2260 0) (hb : b \u2260 0) : ite p a b \u2260 0 := by by_cases p <;> simp [*]", "start": [42, 1], "end": [42, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_ne_zero_of_pos_of_ne_zero", "code": "private lemma ite_ne_zero_of_pos_of_ne_zero [Preorder \u03b1] (ha : 0 < a) (hb : b \u2260 0) :\n  ite p a b \u2260 0 :=\nite_ne_zero _ ha.ne' hb", "start": [44, 1], "end": [46, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.ite_ne_zero_of_ne_zero_of_pos", "code": "private lemma ite_ne_zero_of_ne_zero_of_pos [Preorder \u03b1] (ha : a \u2260 0) (hb : 0 < b) :\n  ite p a b \u2260 0 :=\nite_ne_zero _ ha hb.ne'", "start": [48, 1], "end": [50, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalIte", "code": "@[positivity ite _ _ _] def evalIte : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (.app (.app f (p : Q(Prop))) (_ : Q(Decidable $p))) (a : Q($\u03b1))) (b : Q($\u03b1))\n    \u2190 withReducible (whnf e) | throwError \"not ite\"\n  haveI' : $e =Q ite $p $a $b := \u27e8\u27e9\n  let ra \u2190 core z\u03b1 p\u03b1 a; let rb \u2190 core z\u03b1 p\u03b1 b\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(ite (\u03b1 := $\u03b1))\n  match ra, rb with\n  | .positive pa, .positive pb =>\n    pure (.positive q(ite_pos $p $pa $pb))\n  | .positive pa, .nonnegative pb =>\n    let _b \u2190 synthInstanceQ q(Preorder $\u03b1)\n    assumeInstancesCommute\n    pure (.nonnegative q(ite_nonneg_of_pos_of_nonneg $p $pa $pb))\n  | .nonnegative pa, .positive pb =>\n    let _b \u2190 synthInstanceQ q(Preorder $\u03b1)\n    assumeInstancesCommute\n    pure (.nonnegative q(ite_nonneg_of_nonneg_of_pos $p $pa $pb))\n  | .nonnegative pa, .nonnegative pb =>\n    pure (.nonnegative q(ite_nonneg $p $pa $pb))\n  | .positive pa, .nonzero pb =>\n    let _b \u2190 synthInstanceQ q(Preorder $\u03b1)\n    assumeInstancesCommute\n    pure (.nonzero q(ite_ne_zero_of_pos_of_ne_zero $p $pa $pb))\n  | .nonzero pa, .positive pb =>\n    let _b \u2190 synthInstanceQ q(Preorder $\u03b1)\n    assumeInstancesCommute\n    pure (.nonzero q(ite_ne_zero_of_ne_zero_of_pos $p $pa $pb))\n  | .nonzero pa, .nonzero pb =>\n    pure (.nonzero q(ite_ne_zero $p $pa $pb))\n  | _, _ => pure .none", "start": [54, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.le_min_of_lt_of_le", "code": "private lemma le_min_of_lt_of_le (ha : a < b) (hb : a \u2264 c) : a \u2264 min b c := le_min ha.le hb", "start": [90, 1], "end": [90, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.le_min_of_le_of_lt", "code": "private lemma le_min_of_le_of_lt (ha : a \u2264 b) (hb : a < c) : a \u2264 min b c := le_min ha hb.le", "start": [91, 1], "end": [91, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.min_ne", "code": "private lemma min_ne (ha : a \u2260 c) (hb : b \u2260 c) : min a b \u2260 c :=\nby rw [min_def]; split_ifs <;> assumption", "start": [92, 1], "end": [93, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.min_ne_of_ne_of_lt", "code": "private lemma min_ne_of_ne_of_lt (ha : a \u2260 c) (hb : c < b) : min a b \u2260 c := min_ne ha hb.ne'", "start": [95, 1], "end": [95, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.min_ne_of_lt_of_ne", "code": "private lemma min_ne_of_lt_of_ne (ha : c < a) (hb : b \u2260 c) : min a b \u2260 c := min_ne ha.ne' hb", "start": [96, 1], "end": [96, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.max_ne", "code": "private lemma max_ne (ha : a \u2260 c) (hb : b \u2260 c) : max a b \u2260 c :=\nby rw [max_def]; split_ifs <;> assumption", "start": [98, 1], "end": [99, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalMin", "code": "@[positivity min _ _] def evalMin : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 withReducible (whnf e)\n    | throwError \"not min\"\n  let _e_eq : $e =Q $f $a $b := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ (q(LinearOrder $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(min)\n  match \u2190 core z\u03b1 p\u03b1 a, \u2190 core z\u03b1 p\u03b1 b with\n  | .positive pa, .positive pb => pure (.positive q(lt_min $pa $pb))\n  | .positive pa, .nonnegative pb => pure (.nonnegative q(le_min_of_lt_of_le $pa $pb))\n  | .nonnegative pa, .positive pb => pure (.nonnegative q(le_min_of_le_of_lt $pa $pb))\n  | .nonnegative pa, .nonnegative pb => pure (.nonnegative q(le_min $pa $pb))\n  | .positive pa, .nonzero pb => pure (.nonzero q(min_ne_of_lt_of_ne $pa $pb))\n  | .nonzero pa, .positive pb => pure (.nonzero q(min_ne_of_ne_of_lt $pa $pb))\n  | .nonzero pa, .nonzero pb => pure (.nonzero q(min_ne $pa $pb))\n  | _, _ => pure .none", "start": [103, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalMax", "code": "@[positivity max _ _] def evalMax : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 withReducible (whnf e)\n    | throwError \"not max\"\n  let _e_eq : $e =Q $f $a $b := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ (q(LinearOrder $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(max)\n  let result : Strictness z\u03b1 p\u03b1 e \u2190 catchNone do\n    let ra \u2190 core z\u03b1 p\u03b1 a\n    match ra with\n    | .positive pa => pure (.positive q(lt_max_of_lt_left $pa))\n    | .nonnegative pa => pure (.nonnegative q(le_max_of_le_left $pa))\n    | _ => pure .none\n  orElse result do\n    let rb \u2190 core z\u03b1 p\u03b1 b\n    match rb with\n    | .positive pb => pure (.positive q(lt_max_of_lt_right $pb))\n    | .nonnegative pb => pure (.nonnegative q(le_max_of_le_right $pb))\n    | .nonzero pb => do\n      match \u2190 core z\u03b1 p\u03b1 a with\n      | .nonzero pa => pure (.nonzero q(max_ne $pa $pb))\n      | _ => pure .none\n    | _ => pure .none", "start": [122, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalAdd", "code": "@[positivity _ + _, Add.add _ _] def evalAdd : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 withReducible (whnf e)\n    | throwError \"not +\"\n  let _e_eq : $e =Q $f $a $b := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ (q(AddZeroClass $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(HAdd.hAdd)\n  let ra \u2190 core z\u03b1 p\u03b1 a; let rb \u2190 core z\u03b1 p\u03b1 b\n  match ra, rb with\n  | .positive pa, .positive pb =>\n    let _a \u2190 synthInstanceQ (q(CovariantClass $\u03b1 $\u03b1 (\u00b7+\u00b7) (\u00b7<\u00b7)) : Q(Prop))\n    pure (.positive q(add_pos $pa $pb))\n  | .positive pa, .nonnegative pb =>\n    let _a \u2190 synthInstanceQ (q(CovariantClass $\u03b1 $\u03b1 (swap (\u00b7+\u00b7)) (\u00b7<\u00b7)) : Q(Prop))\n    pure (.positive q(lt_add_of_pos_of_le $pa $pb))\n  | .nonnegative pa, .positive pb =>\n    let _a \u2190 synthInstanceQ (q(CovariantClass $\u03b1 $\u03b1 (\u00b7+\u00b7) (\u00b7<\u00b7)) : Q(Prop))\n    pure (.positive q(lt_add_of_le_of_pos $pa $pb))\n  | .nonnegative pa, .nonnegative pb =>\n    let _a \u2190 synthInstanceQ (q(CovariantClass $\u03b1 $\u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)) : Q(Prop))\n    pure (.nonnegative q(add_nonneg $pa $pb))\n  | _, _ => failure", "start": [151, 1], "end": [174, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.mul_nonneg_of_pos_of_nonneg", "code": "private theorem mul_nonneg_of_pos_of_nonneg [OrderedSemiring \u03b1] {a b : \u03b1}\n    (ha : 0 < a) (hb : 0 \u2264 b) : 0 \u2264 a * b", "start": [176, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.mul_nonneg_of_nonneg_of_pos", "code": "private theorem mul_nonneg_of_nonneg_of_pos [OrderedSemiring \u03b1] {a b : \u03b1}\n    (ha : 0 \u2264 a) (hb : 0 < b) : 0 \u2264 a * b", "start": [180, 1], "end": [182, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.mul_ne_zero_of_ne_zero_of_pos", "code": "private theorem mul_ne_zero_of_ne_zero_of_pos [OrderedSemiring \u03b1] [NoZeroDivisors \u03b1]\n    {a b : \u03b1} (ha : a \u2260 0) (hb : 0 < b) : a * b \u2260 0", "start": [184, 1], "end": [186, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.mul_ne_zero_of_pos_of_ne_zero", "code": "private theorem mul_ne_zero_of_pos_of_ne_zero [OrderedSemiring \u03b1] [NoZeroDivisors \u03b1]\n    {a b : \u03b1} (ha : 0 < a) (hb : b \u2260 0) : a * b \u2260 0", "start": [188, 1], "end": [190, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalMul", "code": "@[positivity _ * _, Mul.mul _ _] def evalMul : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 withReducible (whnf e)\n    | throwError \"not *\"\n  let _e_eq : $e =Q $f $a $b := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ q(StrictOrderedSemiring $\u03b1)\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(HMul.hMul)\n  let ra \u2190 core z\u03b1 p\u03b1 a; let rb \u2190 core z\u03b1 p\u03b1 b\n  match ra, rb with\n  | .positive pa, .positive pb => pure (.positive q(mul_pos $pa $pb))\n  | .positive pa, .nonnegative pb => pure (.nonnegative q(mul_nonneg_of_pos_of_nonneg $pa $pb))\n  | .nonnegative pa, .positive pb => pure (.nonnegative q(mul_nonneg_of_nonneg_of_pos $pa $pb))\n  | .nonnegative pa, .nonnegative pb => pure (.nonnegative q(mul_nonneg $pa $pb))\n  | .positive pa, .nonzero pb =>\n    let _a \u2190 synthInstanceQ (q(NoZeroDivisors $\u03b1) : Q(Prop))\n    pure (.nonzero q(mul_ne_zero_of_pos_of_ne_zero $pa $pb))\n  | .nonzero pa, .positive pb =>\n    let _a \u2190 synthInstanceQ (q(NoZeroDivisors $\u03b1) : Q(Prop))\n    pure (.nonzero q(mul_ne_zero_of_ne_zero_of_pos $pa $pb))\n  | .nonzero pa, .nonzero pb =>\n    let _a \u2190 synthInstanceQ (q(NoZeroDivisors $\u03b1) : Q(Prop))\n    pure (.nonzero (q(mul_ne_zero $pa $pb)))\n  | _, _ => pure .none", "start": [192, 1], "end": [216, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.int_div_self_pos", "code": "private lemma int_div_self_pos {a : \u2124} (ha : 0 < a) : 0 < a / a :=\nby { rw [Int.ediv_self ha.ne']; exact zero_lt_one }", "start": [219, 1], "end": [220, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.int_div_nonneg_of_pos_of_nonneg", "code": "private lemma int_div_nonneg_of_pos_of_nonneg {a b : \u2124} (ha : 0 < a) (hb : 0 \u2264 b) : 0 \u2264 a / b :=\nInt.ediv_nonneg ha.le hb", "start": [222, 1], "end": [223, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.int_div_nonneg_of_nonneg_of_pos", "code": "private lemma int_div_nonneg_of_nonneg_of_pos {a b : \u2124} (ha : 0 \u2264 a) (hb : 0 < b) : 0 \u2264 a / b :=\nInt.ediv_nonneg ha hb.le", "start": [225, 1], "end": [226, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.int_div_nonneg_of_pos_of_pos", "code": "private lemma int_div_nonneg_of_pos_of_pos {a b : \u2124} (ha : 0 < a) (hb : 0 < b) : 0 \u2264 a / b :=\nInt.ediv_nonneg ha.le hb.le", "start": [228, 1], "end": [229, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalIntDiv", "code": "@[positivity (_ : \u2124) / (_ : \u2124)] def evalIntDiv : PositivityExt where eval {_u _\u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app f (a : Q(\u2124))) (b : Q(\u2124)) \u2190 withReducible (whnf e) | throwError \"not /\"\n  let ra \u2190 core z\u03b1 p\u03b1 a; let rb \u2190 core z\u03b1 p\u03b1 b\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(HDiv.hDiv (\u03b1 := \u2124) (\u03b2 := \u2124))\n  match ra, rb with\n  | .positive pa, .positive pb =>\n    have pa' : Q(0 < $a) := pa\n    have pb' : Q(0 < $b) := pb\n    if pa == pb then  pure (.positive (q(int_div_self_pos $pa') : Expr))\n    else\n      pure (.nonnegative (q(int_div_nonneg_of_pos_of_pos $pa' $pb') : Expr))\n  | .positive pa, .nonnegative pb =>\n    have pa' : Q(0 < $a) := pa\n    have pb' : Q(0 \u2264 $b) := pb\n    pure (.nonnegative (q(int_div_nonneg_of_pos_of_nonneg $pa' $pb') : Expr))\n  | .nonnegative pa, .positive pb =>\n    have pa' : Q(0 \u2264 $a) := pa\n    have pb' : Q(0 < $b) := pb\n    pure (.nonnegative (q(int_div_nonneg_of_nonneg_of_pos $pa' $pb') : Expr))\n  | .nonnegative pa, .nonnegative pb =>\n    have pa' : Q(0 \u2264 $a) := pa\n    have pb' : Q(0 \u2264 $b) := pb\n    pure (.nonnegative (q(Int.ediv_nonneg $pa' $pb') : Expr))\n  | _, _ => pure .none", "start": [231, 1], "end": [257, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.div_nonneg_of_pos_of_nonneg", "code": "private lemma div_nonneg_of_pos_of_nonneg (ha : 0 < a) (hb : 0 \u2264 b) : 0 \u2264 a / b :=\ndiv_nonneg ha.le hb", "start": [262, 1], "end": [263, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos", "code": "private lemma div_nonneg_of_nonneg_of_pos (ha : 0 \u2264 a) (hb : 0 < b) : 0 \u2264 a / b :=\ndiv_nonneg ha hb.le", "start": [265, 1], "end": [266, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.div_ne_zero_of_pos_of_ne_zero", "code": "private lemma div_ne_zero_of_pos_of_ne_zero (ha : 0 < a) (hb : b \u2260 0) : a / b \u2260 0 :=\ndiv_ne_zero ha.ne' hb", "start": [268, 1], "end": [269, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.div_ne_zero_of_ne_zero_of_pos", "code": "private lemma div_ne_zero_of_ne_zero_of_pos (ha : a \u2260 0) (hb : 0 < b) : a / b \u2260 0 :=\ndiv_ne_zero ha hb.ne'", "start": [271, 1], "end": [272, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalDiv", "code": "@[positivity _ / _] def evalDiv : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 withReducible (whnf e)\n    | throwError \"not /\"\n  let _e_eq : $e =Q $f $a $b := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ (q(LinearOrderedSemifield $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(HDiv.hDiv)\n  let ra \u2190 core z\u03b1 p\u03b1 a; let rb \u2190 core z\u03b1 p\u03b1 b\n  match ra, rb with\n  | .positive pa, .positive pb => pure (.positive q(div_pos $pa $pb))\n  | .positive pa, .nonnegative pb => pure (.nonnegative q(div_nonneg_of_pos_of_nonneg $pa $pb))\n  | .nonnegative pa, .positive pb => pure (.nonnegative q(div_nonneg_of_nonneg_of_pos $pa $pb))\n  | .nonnegative pa, .nonnegative pb => pure (.nonnegative q(div_nonneg $pa $pb))\n  | .positive pa, .nonzero pb => pure (.nonzero q(div_ne_zero_of_pos_of_ne_zero $pa $pb))\n  | .nonzero pa, .positive pb => pure (.nonzero q(div_ne_zero_of_ne_zero_of_pos $pa $pb))\n  | .nonzero pa, .nonzero pb => pure (.nonzero q(div_ne_zero $pa $pb))\n  | _, _ => pure .none", "start": [276, 1], "end": [294, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalInv", "code": "@[positivity (_ : \u03b1)\u207b\u00b9]\ndef evalInv : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (f : Q($\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1)) \u2190 withReducible (whnf e) | throwError \"not \u207b\u00b9\"\n  let _e_eq : $e =Q $f $a := \u27e8\u27e9\n  let _a \u2190 synthInstanceQ (q(LinearOrderedSemifield $\u03b1) : Q(Type u))\n  assumeInstancesCommute\n  let \u27e8_f_eq\u27e9 \u2190 withDefault <| withNewMCtxDepth <| assertDefEqQ (u := u.succ) f q(Inv.inv)\n  let ra \u2190 core z\u03b1 p\u03b1 a\n  match ra with\n  | .positive pa => pure (.positive q(inv_pos_of_pos $pa))\n  | .nonnegative pa => pure (.nonnegative q(inv_nonneg_of_nonneg $pa))\n  | .nonzero pa => pure (.nonzero q(inv_ne_zero $pa))\n  | .none => pure .none", "start": [296, 1], "end": [310, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.pow_zero_pos", "code": "private theorem pow_zero_pos [OrderedSemiring \u03b1] [Nontrivial \u03b1] (a : \u03b1) : 0 < a ^ 0", "start": [312, 1], "end": [313, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.zpow_zero_pos", "code": "private lemma zpow_zero_pos [LinearOrderedSemifield R] (a : R) : 0 < a ^ (0 : \u2124) :=\nzero_lt_one.trans_le (zpow_zero a).ge", "start": [315, 1], "end": [316, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Meta.Positivity.evalPowZeroNat", "code": "@[positivity (_ : \u03b1) ^ (0:\u2115), Pow.pow _ (0:\u2115)]\ndef evalPowZeroNat : PositivityExt where eval {u \u03b1} _z\u03b1 _p\u03b1 e := do\n  let .app (.app _ (a : Q($\u03b1))) _ \u2190 withReducible (whnf e) | throwError \"not ^\"\n  _ \u2190 synthInstanceQ (q(OrderedSemiring $\u03b1) : Q(Type u))\n  _ \u2190 synthInstanceQ (q(Nontrivial $\u03b1) : Q(Prop))\n  pure (.positive (q(pow_zero_pos $a) : Expr))", "start": [318, 1], "end": [325, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalPowZeroInt", "code": "@[positivity (_ : \u03b1) ^ (0:\u2124), Pow.pow _ (0:\u2124)]\ndef evalPowZeroInt : PositivityExt where eval {u \u03b1} _z\u03b1 _p\u03b1 e := do\n  let .app (.app _ (a : Q($\u03b1))) _ \u2190 withReducible (whnf e) | throwError \"not ^\"\n  _ \u2190 synthInstanceQ (q(LinearOrderedSemifield $\u03b1) : Q(Type u))\n  pure (.positive (q(zpow_zero_pos $a) : Expr))", "start": [327, 1], "end": [332, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalPow", "code": "@[positivity (_ : \u03b1) ^ (_ : \u2115), Pow.pow _ (_ : \u2115)]\ndef evalPow : PositivityExt where eval {u \u03b1} z\u03b1 p\u03b1 e := do\n  let .app (.app _ (a : Q($\u03b1))) (b : Q(\u2115)) \u2190 withReducible (whnf e) | throwError \"not ^\"\n  let result \u2190 catchNone do\n    let .true := b.isAppOfArity ``OfNat.ofNat 3 | throwError \"not a ^ n where n is a literal\"\n    let some n := (b.getRevArg! 1).natLit? | throwError \"not a ^ n where n is a literal\"\n    guard (n % 2 = 0)\n    have m : Q(\u2115) := mkRawNatLit (n / 2)\n    haveI' : $b =Q bit0 $m := \u27e8\u27e9\n    let _a \u2190 synthInstanceQ q(LinearOrderedRing $\u03b1)\n    haveI' : $e =Q $a ^ $b := \u27e8\u27e9\n    assumeInstancesCommute\n    pure (by exact .nonnegative q(pow_bit0_nonneg $a $m))\n  orElse result do\n    let ra \u2190 core z\u03b1 p\u03b1 a\n    let ofNonneg (pa : Q(0 \u2264 $a)) (_o\u03b1 : Q(OrderedSemiring $\u03b1)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n      haveI' : $e =Q $a ^ $b := \u27e8\u27e9\n      assumeInstancesCommute\n      pure (by exact .nonnegative (q(pow_nonneg $pa $b)))\n    let ofNonzero (pa : Q($a \u2260 0)) (_o\u03b1 : Q(OrderedSemiring $\u03b1)) : MetaM (Strictness z\u03b1 p\u03b1 e) := do\n      haveI' : $e =Q $a ^ $b := \u27e8\u27e9\n      assumeInstancesCommute\n      let _a \u2190 synthInstanceQ q(NoZeroDivisors $\u03b1)\n      pure (.nonzero (by exact q(pow_ne_zero $b $pa)))\n    match ra with\n    | .positive pa =>\n      try\n        let _a \u2190 synthInstanceQ (q(StrictOrderedSemiring $\u03b1) : Q(Type u))\n        haveI' : $e =Q $a ^ $b := \u27e8\u27e9\n        assumeInstancesCommute\n        pure (by exact .positive (q(pow_pos $pa $b)))\n      catch e : Exception =>\n        trace[Tactic.positivity.failure] \"{e.toMessageData}\"\n        let o\u03b1 \u2190 synthInstanceQ q(OrderedSemiring $\u03b1)\n        orElse (\u2190 catchNone (ofNonneg q(le_of_lt $pa) o\u03b1)) (ofNonzero q(ne_of_gt $pa) o\u03b1)\n    | .nonnegative pa => ofNonneg pa (\u2190 synthInstanceQ (_ : Q(Type u)))\n    | .nonzero pa => ofNonzero pa (\u2190 synthInstanceQ (_ : Q(Type u)))\n    | .none => pure .none", "start": [335, 1], "end": [374, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.abs_pos_of_ne_zero", "code": "private theorem abs_pos_of_ne_zero {\u03b1 : Type*} [AddGroup \u03b1] [LinearOrder \u03b1]\n [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)] {a : \u03b1} : a \u2260 0 \u2192 0 < |a|", "start": [376, 1], "end": [377, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalAbs", "code": "@[positivity |(_ : \u03b1)|]\ndef evalAbs : PositivityExt where eval {_ _\u03b1} z\u03b1 p\u03b1 e := do\n  let (.app _ (a : Q($_\u03b1))) \u2190 withReducible (whnf e) | throwError \"not |\u00b7|\"\n  try\n    match \u2190 core z\u03b1 p\u03b1 a with\n    | .positive pa =>\n      let pa' \u2190 mkAppM ``abs_pos_of_pos #[pa]\n      pure (.positive pa')\n    | .nonzero pa =>\n      let pa' \u2190 mkAppM ``abs_pos_of_ne_zero #[pa]\n      pure (.positive pa')\n    | _ => pure .none\n  catch _ => do\n    let pa' \u2190 mkAppM ``abs_nonneg #[a]\n    pure (.nonnegative pa')", "start": [379, 1], "end": [394, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.int_natAbs_pos", "code": "private theorem int_natAbs_pos {n : \u2124} (hn : 0 < n) : 0 < n.natAbs", "start": [396, 1], "end": [397, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNatAbs", "code": "@[positivity Int.natAbs _]\ndef evalNatAbs : PositivityExt where eval {_u _\u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(Int))) \u2190 withReducible (whnf e) | throwError \"not Int.natAbs\"\n  let z\u03b1' : Q(Zero Int) := q(inferInstance)\n  let p\u03b1' : Q(PartialOrder Int) := q(inferInstance)\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  match ra with\n  | .positive pa =>\n    pure (.positive (q(int_natAbs_pos $pa) : Expr))\n  | .nonzero pa =>\n    pure (.positive (q(Int.natAbs_pos.mpr $pa) : Expr))\n  | .nonnegative _pa =>\n    pure .none\n  | .none =>\n    pure .none", "start": [399, 1], "end": [417, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNatCast", "code": "@[positivity Nat.cast _]\ndef evalNatCast : PositivityExt where eval {u \u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(Nat))) \u2190 withReducible (whnf e) | throwError \"not Nat.cast\"\n  let z\u03b1' : Q(Zero Nat) := q(inferInstance)\n  let p\u03b1' : Q(PartialOrder Nat) := q(inferInstance)\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  let _o\u03b1 \u2190 synthInstanceQ q(OrderedSemiring $\u03b1)\n  haveI' : $e =Q Nat.cast $a := \u27e8\u27e9\n  assumeInstancesCommute\n  match ra with\n  | .positive pa =>\n    let _nt \u2190 synthInstanceQ q(Nontrivial $\u03b1)\n    pure (.positive q(Nat.cast_pos.mpr $pa))\n  | _ =>\n    pure (.nonnegative q(Nat.cast_nonneg _))", "start": [419, 1], "end": [433, 45], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalIntCast", "code": "@[positivity Int.cast _]\ndef evalIntCast : PositivityExt where eval {u \u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(Int))) \u2190 withReducible (whnf e) | throwError \"not Int.cast\"\n  let z\u03b1' : Q(Zero Int) := q(inferInstance)\n  let p\u03b1' : Q(PartialOrder Int) := q(inferInstance)\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  match ra with\n  | .positive pa =>\n    let _o\u03b1 \u2190 synthInstanceQ (q(OrderedRing $\u03b1) : Q(Type u))\n    let _nt \u2190 synthInstanceQ (q(Nontrivial $\u03b1))\n    assumeInstancesCommute\n    haveI' : $e =Q Int.cast $a := \u27e8\u27e9\n    pure (.positive q(Int.cast_pos.mpr $pa))\n  | .nonnegative pa =>\n    let _o\u03b1 \u2190 synthInstanceQ (q(OrderedRing $\u03b1))\n    let _nt \u2190 synthInstanceQ (q(Nontrivial $\u03b1))\n    assumeInstancesCommute\n    haveI' : $e =Q Int.cast $a := \u27e8\u27e9\n    pure (.nonnegative q(Int.cast_nonneg.mpr $pa))\n  | .nonzero pa =>\n    let _o\u03b1 \u2190 synthInstanceQ (q(AddGroupWithOne $\u03b1) : Q(Type $u))\n    haveI' : $e =Q Int.cast $a := \u27e8\u27e9\n    let _nt \u2190 synthInstanceQ (q(CharZero $\u03b1) : Q(Prop))\n    assumeInstancesCommute\n    pure (.nonzero q(Int.cast_ne_zero.mpr $pa))\n  | .none =>\n    pure .none", "start": [435, 1], "end": [461, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNatSucc", "code": "@[positivity Nat.succ _]\ndef evalNatSucc : PositivityExt where eval {_u _\u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(Nat))) \u2190 withReducible (whnf e) | throwError \"not Nat.succ\"\n  pure (.positive (q(Nat.succ_pos $a) : Expr))", "start": [463, 1], "end": [467, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalFactorial", "code": "@[positivity Nat.factorial _]\ndef evalFactorial : PositivityExt where eval {_ _} _ _ e := do\n  let .app _ (a : Q(Nat)) \u2190 whnfR e | throwError \"not Nat.factorial\"\n  pure (.positive (q(Nat.factorial_pos $a) : Expr))", "start": [469, 1], "end": [473, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Basic.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Tactic/Clear!.lean", "Mathlib/Data/Nat/Cast/Commute.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/HaveI.lean", "Mathlib/Tactic/NormNum/Core.lean", "Mathlib/Algebra/Invertible/Basic.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.isNat_zero", "code": "theorem isNat_zero (\u03b1) [AddMonoidWithOne \u03b1] : IsNat (Zero.zero : \u03b1) (nat_lit 0)", "start": [36, 1], "end": [37, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalZero", "code": "@[norm_num Zero.zero] def evalZero : NormNumExt where eval {u \u03b1} e := do\n  let s\u03b1 \u2190 inferAddMonoidWithOne \u03b1\n  match e with\n  | ~q(Zero.zero) => return .isNat s\u03b1 (mkRawNatLit 0) q(isNat_zero $\u03b1)", "start": [39, 1], "end": [43, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_one", "code": "theorem isNat_one (\u03b1) [AddMonoidWithOne \u03b1] : IsNat (One.one : \u03b1) (nat_lit 1)", "start": [45, 1], "end": [45, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalOne", "code": "@[norm_num One.one] def evalOne : NormNumExt where eval {u \u03b1} e := do\n  let s\u03b1 \u2190 inferAddMonoidWithOne \u03b1\n  match e with\n  | ~q(One.one) => return .isNat s\u03b1 (mkRawNatLit 1) q(isNat_one $\u03b1)", "start": [47, 1], "end": [51, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_ofNat", "code": "theorem isNat_ofNat (\u03b1 : Type u_1) [AddMonoidWithOne \u03b1] {a : \u03b1} {n : \u2115}\n    (h : n = a) : IsNat a n", "start": [53, 1], "end": [54, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalOfNat", "code": "@[norm_num OfNat.ofNat _] def evalOfNat : NormNumExt where eval {u \u03b1} e := do\n  let s\u03b1 \u2190 inferAddMonoidWithOne \u03b1\n  match e with\n  | ~q(@OfNat.ofNat _ $n $o\u03b1) =>\n    let n : Q(\u2115) \u2190 whnf n\n    guard n.isNatLit\n    let \u27e8a, (pa : Q($n = $e))\u27e9 \u2190 mkOfNat \u03b1 s\u03b1 n\n    guard <|\u2190 isDefEq a e\n    return .isNat s\u03b1 n q(isNat_ofNat $\u03b1 $pa)", "start": [56, 1], "end": [65, 45], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_intOfNat", "code": "theorem isNat_intOfNat : {n n' : \u2115} \u2192 IsNat n n' \u2192 IsNat (Int.ofNat n) n'", "start": [67, 1], "end": [68, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalIntOfNat", "code": "@[norm_num Int.ofNat _] def evalIntOfNat : NormNumExt where eval {u \u03b1} e := do\n  let .app (.const ``Int.ofNat _) (n : Q(\u2115)) \u2190 whnfR e | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q Int := \u27e8\u27e9\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(AddCommMonoidWithOne.toAddMonoidWithOne)\n  let s\u2124 : Q(AddMonoidWithOne \u2124) := q(AddGroupWithOne.toAddMonoidWithOne)\n  let \u27e8n', p\u27e9 \u2190 deriveNat n s\u2115\n  haveI' x : $e =Q Int.ofNat $n := \u27e8\u27e9\n  return .isNat s\u2124 n' q(isNat_intOfNat $p)", "start": [70, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_cast", "code": "theorem isNat_cast {R} [AddMonoidWithOne R] (n m : \u2115) :\n    IsNat n m \u2192 IsNat (n : R) m", "start": [83, 1], "end": [84, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatCast", "code": "@[norm_num Nat.cast _, NatCast.natCast _] def evalNatCast : NormNumExt where eval {u \u03b1} e := do\n  let s\u03b1 \u2190 inferAddMonoidWithOne \u03b1\n  let .app n (a : Q(\u2115)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq n q(Nat.cast (R := $\u03b1))\n  let \u27e8na, pa\u27e9 \u2190 deriveNat a q(instAddMonoidWithOneNat)\n  haveI' : $e =Q $a := \u27e8\u27e9\n  return .isNat s\u03b1 na q(isNat_cast $a $na $pa)", "start": [86, 1], "end": [93, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_int_cast", "code": "theorem isNat_int_cast {R} [Ring R] (n : \u2124) (m : \u2115) :\n    IsNat n m \u2192 IsNat (n : R) m", "start": [95, 1], "end": [96, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_cast", "code": "theorem isInt_cast {R} [Ring R] (n m : \u2124) :\n    IsInt n m \u2192 IsInt (n : R) m", "start": [98, 1], "end": [99, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalIntCast", "code": "@[norm_num Int.cast _, IntCast.intCast _] def evalIntCast : NormNumExt where eval {u \u03b1} e := do\n  let r\u03b1 \u2190 inferRing \u03b1\n  let .app i (a : Q(\u2124)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq i q(Int.cast (R := $\u03b1))\n  match \u2190 derive (\u03b1 := q(\u2124)) a with\n  | .isNat _ na pa =>\n    assumeInstancesCommute\n    haveI' : $e =Q Int.cast $a := \u27e8\u27e9\n    return .isNat _ na q(isNat_int_cast $a $na $pa)\n  | .isNegNat _ na pa =>\n    assumeInstancesCommute\n    haveI' : $e =Q Int.cast $a := \u27e8\u27e9\n    return .isNegNat _ na q(isInt_cast $a (.negOfNat $na) $pa)\n  | _ => failure", "start": [101, 1], "end": [115, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_add", "code": "theorem isNat_add {\u03b1} [AddMonoidWithOne \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {a' b' c : \u2115},\n    f = HAdd.hAdd \u2192 IsNat a a' \u2192 IsNat b b' \u2192 Nat.add a' b' = c \u2192 IsNat (f a b) c", "start": [134, 1], "end": [136, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_add", "code": "theorem isInt_add {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {a' b' c : \u2124},\n    f = HAdd.hAdd \u2192 IsInt a a' \u2192 IsInt b b' \u2192 Int.add a' b' = c \u2192 IsInt (f a b) c", "start": [139, 1], "end": [141, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.invertibleOfMul", "code": "def invertibleOfMul {\u03b1} [Semiring \u03b1] (k : \u2115) (b : \u03b1) :\n    \u2200 (a : \u03b1) [Invertible a], a = k * b \u2192 Invertible b\n  | _, \u27e8c, hc1, hc2\u27e9, rfl => by\n    rw [\u2190 mul_assoc] at hc1\n    rw [Nat.cast_commute k, mul_assoc, Nat.cast_commute k] at hc2\n    exact \u27e8_, hc1, hc2\u27e9", "start": [143, 1], "end": [149, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.invertibleOfMul'", "code": "def invertibleOfMul' {\u03b1} [Semiring \u03b1] {a k b : \u2115} [Invertible (a : \u03b1)]\n    (h : a = k * b) : Invertible (b : \u03b1) := invertibleOfMul k (b:\u03b1) \u2191a (by simp [h])", "start": [151, 1], "end": [153, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_add", "code": "theorem isRat_add {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {na nb nc : \u2124} {da db dc k : \u2115} :\n    f = HAdd.hAdd \u2192 IsRat a na da \u2192 IsRat b nb db \u2192\n    Int.add (Int.mul na db) (Int.mul nb da) = Int.mul k nc \u2192\n    Nat.mul da db = Nat.mul k dc \u2192\n    IsRat (f a b) nc dc", "start": [157, 1], "end": [175, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalAdd", "code": "@[norm_num _ + _, Add.add _ _] def evalAdd : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 whnfR e | failure\n  let ra \u2190 derive a; let rb \u2190 derive b\n  match ra, rb with\n  | .isBool .., _ | _, .isBool .. => failure\n  | .isNat _ .., .isNat _ .. | .isNat _ .., .isNegNat _ .. | .isNat _ .., .isRat _ ..\n  | .isNegNat _ .., .isNat _ .. | .isNegNat _ .., .isNegNat _ .. | .isNegNat _ .., .isRat _ ..\n  | .isRat _ .., .isNat _ .. | .isRat _ .., .isNegNat _ .. | .isRat _ .., .isRat _ .. =>\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HAdd.hAdd (\u03b1 := $\u03b1))\n  let rec\n  \n  core : Option (Result e) := do\n    let rec intArm (r\u03b1 : Q(Ring $\u03b1)) := do\n      haveI' : $e =Q $a + $b := \u27e8\u27e9\n      let \u27e8za, na, pa\u27e9 \u2190 ra.toInt _; let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt _\n      haveI' : $f =Q HAdd.hAdd := \u27e8\u27e9\n      let zc := za + zb\n      have c := mkRawIntLit zc\n      haveI' : Int.add $na $nb =Q $c := \u27e8\u27e9\n      return .isInt r\u03b1 c zc q(isInt_add (f := $f) (.refl $f) $pa $pb (.refl $c))\n    let rec ratArm (d\u03b1 : Q(DivisionRing $\u03b1)) : Option (Result _) := do\n      haveI' : $e =Q $a + $b := \u27e8\u27e9\n      haveI' : $f =Q HAdd.hAdd := \u27e8\u27e9\n      let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1; let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' d\u03b1\n      let qc := qa + qb\n      let dd := qa.den * qb.den\n      let k := dd / qc.den\n      have t1 : Q(\u2124) := mkRawIntLit (k * qc.num)\n      have t2 : Q(\u2115) := mkRawNatLit dd\n      have nc : Q(\u2124) := mkRawIntLit qc.num\n      have dc : Q(\u2115) := mkRawNatLit qc.den\n      have k : Q(\u2115) := mkRawNatLit k\n      let r1 : Q(Int.add (Int.mul $na $db) (Int.mul $nb $da) = Int.mul $k $nc) :=\n        (q(Eq.refl $t1) : Expr)\n      let r2 : Q(Nat.mul $da $db = Nat.mul $k $dc) := (q(Eq.refl $t2) : Expr)\n      return .isRat' d\u03b1 qc nc dc q(isRat_add (f := $f) (.refl $f) $pa $pb $r1 $r2)\n    match ra, rb with\n    | .isBool .., _ | _, .isBool .. => failure\n    | .isRat d\u03b1 .., _ | _, .isRat d\u03b1 .. => ratArm d\u03b1\n    | .isNegNat r\u03b1 .., _ | _, .isNegNat r\u03b1 .. => intArm r\u03b1\n    | .isNat _ na pa, .isNat s\u03b1 nb pb =>\n      haveI' : $e =Q $a + $b := \u27e8\u27e9\n      haveI' : $f =Q HAdd.hAdd := \u27e8\u27e9\n      assumeInstancesCommute\n      have c : Q(\u2115) := mkRawNatLit (na.natLit! + nb.natLit!)\n      haveI' : Nat.add $na $nb =Q $c := \u27e8\u27e9\n      return .isNat s\u03b1 c q(isNat_add (f := $f) (.refl $f) $pa $pb (.refl $c))\n  core", "start": [182, 1], "end": [231, 7], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_neg", "code": "theorem isInt_neg {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1} {a : \u03b1} {a' b : \u2124},\n    f = Neg.neg \u2192 IsInt a a' \u2192 Int.neg a' = b \u2192 IsInt (-a) b", "start": [234, 1], "end": [236, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_neg", "code": "theorem isRat_neg {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1} {a : \u03b1} {n n' : \u2124} {d : \u2115},\n    f = Neg.neg \u2192 IsRat a n d \u2192 Int.neg n = n' \u2192 IsRat (-a) n' d", "start": [239, 1], "end": [241, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNeg", "code": "@[norm_num -_] def evalNeg : NormNumExt where eval {u \u03b1} e := do\n  let .app (f : Q($\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1)) \u2190 whnfR e | failure\n  let ra \u2190 derive a\n  let r\u03b1 \u2190 inferRing \u03b1\n  let \u27e8(_f_eq : $f =Q Neg.neg)\u27e9 \u2190 withNewMCtxDepth <| assertDefEqQ _ _\n  haveI' _e_eq : $e =Q -$a := \u27e8\u27e9\n  let rec\n  \n  core : Option (Result e) := do\n    let intArm (r\u03b1 : Q(Ring $\u03b1)) := do\n      assumeInstancesCommute\n      let \u27e8za, na, pa\u27e9 \u2190 ra.toInt r\u03b1\n      let zb := -za\n      have b := mkRawIntLit zb\n      haveI' : Int.neg $na =Q $b := \u27e8\u27e9\n      return .isInt r\u03b1 b zb q(isInt_neg (f := $f) (.refl $f) $pa (.refl $b))\n    let ratArm (d\u03b1 : Q(DivisionRing $\u03b1)) : Option (Result _) := do\n      assumeInstancesCommute\n      let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1\n      let qb := -qa\n      have nb := mkRawIntLit qb.num\n      haveI' : Int.neg $na =Q $nb := \u27e8\u27e9\n      return .isRat' d\u03b1 qb nb da q(isRat_neg (f := $f) (.refl $f) $pa (.refl $nb))\n    match ra with\n    | .isBool _ .. => failure\n    | .isNat _ .. => intArm r\u03b1\n    | .isNegNat r\u03b1 .. => intArm r\u03b1\n    | .isRat d\u03b1 .. => ratArm d\u03b1\n  core", "start": [243, 1], "end": [273, 7], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_sub", "code": "theorem isInt_sub {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {a' b' c : \u2124},\n    f = HSub.hSub \u2192 IsInt a a' \u2192 IsInt b b' \u2192 Int.sub a' b' = c \u2192 IsInt (f a b) c", "start": [276, 1], "end": [278, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_sub", "code": "theorem isRat_sub {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {na nb nc : \u2124} {da db dc k : \u2115}\n    (hf : f = HSub.hSub) (ra : IsRat a na da) (rb : IsRat b nb db)\n    (h\u2081 : Int.sub (Int.mul na db) (Int.mul nb da) = Int.mul k nc)\n    (h\u2082 : Nat.mul da db = Nat.mul k dc) :\n    IsRat (f a b) nc dc", "start": [281, 1], "end": [288, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalSub", "code": "@[norm_num _ - _, Sub.sub _ _] def evalSub : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 whnfR e | failure\n  let r\u03b1 \u2190 inferRing \u03b1\n  let \u27e8(_f_eq : $f =Q HSub.hSub)\u27e9 \u2190 withNewMCtxDepth <| assertDefEqQ _ _\n  let ra \u2190 derive a; let rb \u2190 derive b\n  haveI' _e_eq : $e =Q $a - $b := \u27e8\u27e9\n  let rec\n  \n  core : Option (Result e) := do\n    let intArm (r\u03b1 : Q(Ring $\u03b1)) := do\n      assumeInstancesCommute\n      let \u27e8za, na, pa\u27e9 \u2190 ra.toInt r\u03b1; let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt r\u03b1\n      let zc := za - zb\n      have c := mkRawIntLit zc\n      haveI' : Int.sub $na $nb =Q $c := \u27e8\u27e9\n      return Result.isInt r\u03b1 c zc q(isInt_sub (f := $f) (.refl $f) $pa $pb (.refl $c))\n    let ratArm (d\u03b1 : Q(DivisionRing $\u03b1)) : Option (Result _) := do\n      assumeInstancesCommute\n      let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1; let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' d\u03b1\n      let qc := qa - qb\n      let dd := qa.den * qb.den\n      let k := dd / qc.den\n      have t1 : Q(\u2124) := mkRawIntLit (k * qc.num)\n      have t2 : Q(\u2115) := mkRawNatLit dd\n      have nc : Q(\u2124) := mkRawIntLit qc.num\n      have dc : Q(\u2115) := mkRawNatLit qc.den\n      have k : Q(\u2115) := mkRawNatLit k\n      let r1 : Q(Int.sub (Int.mul $na $db) (Int.mul $nb $da) = Int.mul $k $nc) :=\n        (q(Eq.refl $t1) : Expr)\n      let r2 : Q(Nat.mul $da $db = Nat.mul $k $dc) := (q(Eq.refl $t2) : Expr)\n      return .isRat' d\u03b1 qc nc dc q(isRat_sub (f := $f) (.refl $f) $pa $pb $r1 $r2)\n    match ra, rb with\n    | .isBool .., _ | _, .isBool .. => failure\n    | .isRat d\u03b1 .., _ | _, .isRat d\u03b1 .. => ratArm d\u03b1\n    | .isNegNat r\u03b1 .., _ | _, .isNegNat r\u03b1 ..\n    | .isNat _ .., .isNat _ .. => intArm r\u03b1\n  core", "start": [290, 1], "end": [328, 7], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_mul", "code": "theorem isNat_mul {\u03b1} [Semiring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {a' b' c : \u2115},\n    f = HMul.hMul \u2192 IsNat a a' \u2192 IsNat b b' \u2192 Nat.mul a' b' = c \u2192 IsNat (a * b) c", "start": [331, 1], "end": [333, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_mul", "code": "theorem isInt_mul {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {a' b' c : \u2124},\n    f = HMul.hMul \u2192 IsInt a a' \u2192 IsInt b b' \u2192 Int.mul a' b' = c \u2192 IsInt (a * b) c", "start": [336, 1], "end": [338, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_mul", "code": "theorem isRat_mul {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {na nb nc : \u2124} {da db dc k : \u2115} :\n    f = HMul.hMul \u2192 IsRat a na da \u2192 IsRat b nb db \u2192\n    Int.mul na nb = Int.mul k nc \u2192\n    Nat.mul da db = Nat.mul k dc \u2192\n    IsRat (f a b) nc dc", "start": [340, 1], "end": [358, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalMul", "code": "@[norm_num _ * _, Mul.mul _ _] def evalMul : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app (f : Q($\u03b1 \u2192 $\u03b1 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 whnfR e | failure\n  let s\u03b1 \u2190 inferSemiring \u03b1\n  let ra \u2190 derive a; let rb \u2190 derive b\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HMul.hMul (\u03b1 := $\u03b1))\n  haveI' : $f =Q HMul.hMul := \u27e8\u27e9\n  haveI' : $e =Q $a * $b := \u27e8\u27e9\n  let rec\n  \n  core : Option (Result e) := do\n    let rec intArm (r\u03b1 : Q(Ring $\u03b1)) := do\n      assumeInstancesCommute\n      let \u27e8za, na, pa\u27e9 \u2190 ra.toInt r\u03b1; let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt r\u03b1\n      let zc := za * zb\n      have c := mkRawIntLit zc\n      haveI' : Int.mul $na $nb =Q $c := \u27e8\u27e9\n      return .isInt r\u03b1 c zc q(isInt_mul (f := $f) (.refl $f) $pa $pb (.refl $c))\n    let rec ratArm (d\u03b1 : Q(DivisionRing $\u03b1)) : Option (Result _) := do\n      assumeInstancesCommute\n      let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1; let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' d\u03b1\n      let qc := qa * qb\n      let dd := qa.den * qb.den\n      let k := dd / qc.den\n      have nc : Q(\u2124) := mkRawIntLit qc.num\n      have dc : Q(\u2115) := mkRawNatLit qc.den\n      have k : Q(\u2115) := mkRawNatLit k\n      let r1 : Q(Int.mul $na $nb = Int.mul $k $nc) :=\n        (q(Eq.refl (Int.mul $na $nb)) : Expr)\n      have t2 : Q(\u2115) := mkRawNatLit dd\n      let r2 : Q(Nat.mul $da $db = Nat.mul $k $dc) := (q(Eq.refl $t2) : Expr)\n      return .isRat' d\u03b1 qc nc dc q(isRat_mul (f := $f) (.refl $f) $pa $pb $r1 $r2)\n    match ra, rb with\n    | .isBool .., _ | _, .isBool .. => failure\n    | .isRat d\u03b1 .., _ | _, .isRat d\u03b1 .. => ratArm d\u03b1\n    | .isNegNat r\u03b1 .., _ | _, .isNegNat r\u03b1 .. => intArm r\u03b1\n    | .isNat m\u03b1' na pa, .isNat m\u03b1 nb pb =>\n      haveI' : $m\u03b1 =Q by clear! $m\u03b1 $m\u03b1'; apply AddCommMonoidWithOne.toAddMonoidWithOne := \u27e8\u27e9\n      assumeInstancesCommute\n      have c : Q(\u2115) := mkRawNatLit (na.natLit! * nb.natLit!)\n      haveI' : Nat.mul $na $nb =Q $c := \u27e8\u27e9\n      return .isNat m\u03b1 c q(isNat_mul (f := $f) (.refl $f) $pa $pb (.refl $c))\n  core", "start": [360, 1], "end": [403, 7], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_div", "code": "theorem isRat_div [DivisionRing \u03b1] : {a b : \u03b1} \u2192 {cn : \u2124} \u2192 {cd : \u2115} \u2192 IsRat (a * b\u207b\u00b9) cn cd \u2192\n    IsRat (a / b) cn cd", "start": [405, 1], "end": [407, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferDivisionRing", "code": "def inferDivisionRing (\u03b1 : Q(Type u)) : MetaM Q(DivisionRing $\u03b1) :=\n  return \u2190 synthInstanceQ (q(DivisionRing $\u03b1) : Q(Type u)) <|> throwError \"not a division ring\"", "start": [409, 1], "end": [411, 96], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalDiv", "code": "@[norm_num _ / _, Div.div _ _] def evalDiv : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app f (a : Q($\u03b1))) (b : Q($\u03b1)) \u2190 whnfR e | failure\n  let d\u03b1 \u2190 inferDivisionRing \u03b1\n  haveI' : $e =Q $a / $b := \u27e8\u27e9\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HDiv.hDiv (\u03b1 := $\u03b1))\n  let rab \u2190 derive (q($a * $b\u207b\u00b9) : Q($\u03b1))\n  let \u27e8qa, na, da, pa\u27e9 \u2190 rab.toRat' d\u03b1\n  assumeInstancesCommute\n  return .isRat' d\u03b1 qa na da q(isRat_div $pa)", "start": [413, 1], "end": [423, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalTrue", "code": "@[norm_num True] def evalTrue : NormNumExt where eval {u \u03b1} e :=\n  return (.isTrue q(True.intro) : Result q(True))", "start": [427, 1], "end": [429, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalFalse", "code": "@[norm_num False] def evalFalse : NormNumExt where eval {u \u03b1} e :=\n  return (.isFalse q(not_false) : Result q(False))", "start": [431, 1], "end": [433, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNot", "code": "@[norm_num \u00ac_] def evalNot : NormNumExt where eval {u \u03b1} e := do\n  let .app (.const ``Not _) (a : Q(Prop)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq \u03b1 q(Prop)\n  let .isBool b p \u2190 derive q($a) | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q Prop := \u27e8\u27e9\n  haveI' : $e =Q \u00ac $a := \u27e8\u27e9\n  if b then\n    have p : Q($a) := p\n    return .isFalse q(not_not_intro $p)\n  else\n    have p : Q(\u00ac $a) := p\n    return .isTrue q($p)", "start": [435, 1], "end": [448, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_eq_true", "code": "theorem isNat_eq_true [AddMonoidWithOne \u03b1] : {a b : \u03b1} \u2192 {c : \u2115} \u2192\n    IsNat a c \u2192 IsNat b c \u2192 a = b", "start": [452, 1], "end": [454, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.ble_eq_false", "code": "theorem ble_eq_false {x y : \u2115} : x.ble y = false \u2194 y < x", "start": [456, 1], "end": [457, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_eq_true", "code": "theorem isInt_eq_true [Ring \u03b1] : {a b : \u03b1} \u2192 {z : \u2124} \u2192 IsInt a z \u2192 IsInt b z \u2192 a = b", "start": [459, 1], "end": [460, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_eq_true", "code": "theorem isRat_eq_true [Ring \u03b1] : {a b : \u03b1} \u2192 {n : \u2124} \u2192 {d : \u2115} \u2192\n    IsRat a n d \u2192 IsRat b n d \u2192 a = b", "start": [462, 1], "end": [464, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.eq_of_true", "code": "theorem eq_of_true {a b : Prop} (ha : a) (hb : b) : a = b", "start": [466, 1], "end": [466, 89], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.ne_of_false_of_true", "code": "theorem ne_of_false_of_true (ha : \u00aca) (hb : b) : a \u2260 b", "start": [467, 1], "end": [467, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.ne_of_true_of_false", "code": "theorem ne_of_true_of_false (ha : a) (hb : \u00acb) : a \u2260 b", "start": [468, 1], "end": [468, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.eq_of_false", "code": "theorem eq_of_false (ha : \u00aca) (hb : \u00acb) : a = b", "start": [469, 1], "end": [469, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_natSucc", "code": "theorem isNat_natSucc : {a : \u2115} \u2192 {a' c : \u2115} \u2192\n    IsNat a a' \u2192 Nat.succ a' = c \u2192 IsNat (a.succ) c", "start": [473, 1], "end": [475, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatSucc", "code": "@[norm_num Nat.succ _] def evalNatSucc : NormNumExt where eval {u \u03b1} e := do\n  let .app f (a : Q(\u2115)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(Nat.succ)\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q Nat.succ $a := \u27e8\u27e9\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8na, pa\u27e9 \u2190 deriveNat a s\u2115\n  have nc : Q(\u2115) := mkRawNatLit (na.natLit!.succ)\n  haveI' : $nc =Q ($na).succ := \u27e8\u27e9\n  return .isNat s\u2115 nc q(isNat_natSucc $pa (.refl $nc))", "start": [477, 1], "end": [488, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_natSub", "code": "theorem isNat_natSub : {a b : \u2115} \u2192 {a' b' c : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.sub a' b' = c \u2192 IsNat (a - b) c", "start": [490, 1], "end": [492, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatSub", "code": "@[norm_num (_ : \u2115) - _, Sub.sub (_ : \u2115) _, Nat.sub _ _] def evalNatSub :\n    NormNumExt where eval {u \u03b1} e := do\n  let .app (.app f (a : Q(\u2115))) (b : Q(\u2115)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HSub.hSub (\u03b1 := \u2115))\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q $a - $b := \u27e8\u27e9\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8na, pa\u27e9 \u2190 deriveNat a s\u2115; let \u27e8nb, pb\u27e9 \u2190 deriveNat b s\u2115\n  have nc : Q(\u2115) := mkRawNatLit (na.natLit! - nb.natLit!)\n  haveI' : Nat.sub $na $nb =Q $nc := \u27e8\u27e9\n  return .isNat s\u2115 nc q(isNat_natSub $pa $pb (.refl $nc))", "start": [494, 1], "end": [507, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_natMod", "code": "theorem isNat_natMod : {a b : \u2115} \u2192 {a' b' c : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.mod a' b' = c \u2192 IsNat (a % b) c", "start": [509, 1], "end": [511, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatMod", "code": "@[norm_num (_ : \u2115) % _, Mod.mod (_ : \u2115) _, Nat.mod _ _] def evalNatMod :\n    NormNumExt where eval {u \u03b1} e := do\n  let .app (.app f (a : Q(\u2115))) (b : Q(\u2115)) \u2190 whnfR e | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q $a % $b := \u27e8\u27e9\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HMod.hMod (\u03b1 := \u2115))\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8na, pa\u27e9 \u2190 deriveNat a s\u2115; let \u27e8nb, pb\u27e9 \u2190 deriveNat b s\u2115\n  have nc : Q(\u2115) := mkRawNatLit (na.natLit! % nb.natLit!)\n  haveI' : Nat.mod $na $nb =Q $nc := \u27e8\u27e9\n  return .isNat s\u2115 nc q(isNat_natMod $pa $pb (.refl $nc))", "start": [513, 1], "end": [526, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_natDiv", "code": "theorem isNat_natDiv : {a b : \u2115} \u2192 {a' b' c : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.div a' b' = c \u2192 IsNat (a / b) c", "start": [528, 1], "end": [530, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatDiv", "code": "@[norm_num (_ : \u2115) / _, Div.div (_ : \u2115) _, Nat.div _ _] def evalNatDiv :\n    NormNumExt where eval {u \u03b1} e := do\n  let .app (.app f (a : Q(\u2115))) (b : Q(\u2115)) \u2190 whnfR e | failure\n  haveI' : u =QL 0 := \u27e8\u27e9; haveI' : $\u03b1 =Q \u2115 := \u27e8\u27e9\n  haveI' : $e =Q $a / $b := \u27e8\u27e9\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(HDiv.hDiv (\u03b1 := \u2115))\n  let s\u2115 : Q(AddMonoidWithOne \u2115) := q(instAddMonoidWithOneNat)\n  let \u27e8na, pa\u27e9 \u2190 deriveNat a s\u2115; let \u27e8nb, pb\u27e9 \u2190 deriveNat b s\u2115\n  have nc : Q(\u2115) := mkRawNatLit (na.natLit! / nb.natLit!)\n  haveI' : Nat.div $na $nb =Q $nc := \u27e8\u27e9\n  return .isNat s\u2115 nc q(isNat_natDiv $pa $pb (.refl $nc))", "start": [532, 1], "end": [545, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Sublists.lean", "imports": ["Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Data/List/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.sublists'_nil", "code": "@[simp]\ntheorem sublists'_nil : sublists' (@nil \u03b1) = [[]]", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_singleton", "code": "@[simp]\ntheorem sublists'_singleton (a : \u03b1) : sublists' [a] = [[], [a]]", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublists'Aux", "code": "def sublists'Aux (a : \u03b1) (r\u2081 r\u2082 : List (List \u03b1)) : List (List \u03b1) :=\n  r\u2081.foldl (init := r\u2082) fun r l => r ++ [a :: l]", "start": [46, 1], "end": [48, 49], "kind": "commanddeclaration"}, {"full_name": "List.sublists'Aux_eq_array_foldl", "code": "theorem sublists'Aux_eq_array_foldl (a : \u03b1) : \u2200 (r\u2081 r\u2082 : List (List \u03b1)),\n    sublists'Aux a r\u2081 r\u2082 = ((r\u2081.toArray).foldl (init := r\u2082.toArray)\n      (fun r l => r.push (a :: l))).toList", "start": [51, 1], "end": [58, 19], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_eq_sublists'Aux", "code": "theorem sublists'_eq_sublists'Aux (l : List \u03b1) :\n    sublists' l = l.foldr (fun a r => sublists'Aux a r r) [[]]", "start": [60, 1], "end": [65, 31], "kind": "commanddeclaration"}, {"full_name": "List.sublists'Aux_eq_map", "code": "theorem sublists'Aux_eq_map (a : \u03b1) (r\u2081 : List (List \u03b1)) : \u2200 (r\u2082 : List (List \u03b1)),\n    sublists'Aux a r\u2081 r\u2082 = r\u2082 ++ map (cons a) r\u2081", "start": [67, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_cons", "code": "@[simp 900]\ntheorem sublists'_cons (a : \u03b1) (l : List \u03b1) :\n    sublists' (a :: l) = sublists' l ++ map (cons a) (sublists' l)", "start": [74, 1], "end": [77, 68], "kind": "commanddeclaration"}, {"full_name": "List.mem_sublists'", "code": "@[simp]\ntheorem mem_sublists' {s t : List \u03b1} : s \u2208 sublists' t \u2194 s <+ t", "start": [80, 1], "end": [91, 31], "kind": "commanddeclaration"}, {"full_name": "List.length_sublists'", "code": "@[simp]\ntheorem length_sublists' : \u2200 l : List \u03b1, length (sublists' l) = 2 ^ length l", "start": [94, 1], "end": [99, 71], "kind": "commanddeclaration"}, {"full_name": "List.sublists_nil", "code": "@[simp]\ntheorem sublists_nil : sublists (@nil \u03b1) = [[]]", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublists_singleton", "code": "@[simp]\ntheorem sublists_singleton (a : \u03b1) : sublists [a] = [[], [a]]", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublistsAux", "code": "def sublistsAux (a : \u03b1) (r : List (List \u03b1)) : List (List \u03b1) :=\n  r.foldl (init := []) fun r l => r ++ [l, a :: l]", "start": [113, 1], "end": [115, 51], "kind": "commanddeclaration"}, {"full_name": "List.sublistsAux_eq_array_foldl", "code": "theorem sublistsAux_eq_array_foldl :\n    sublistsAux = fun (a : \u03b1) (r : List (List \u03b1)) =>\n      (r.toArray.foldl (init := #[])\n        fun r l => (r.push l).push (a :: l)).toList", "start": [118, 1], "end": [127, 19], "kind": "commanddeclaration"}, {"full_name": "List.sublistsAux_eq_bind", "code": "theorem sublistsAux_eq_bind :\n    sublistsAux = fun (a : \u03b1) (r : List (List \u03b1)) => r.bind fun l => [l, a :: l]", "start": [129, 1], "end": [136, 26], "kind": "commanddeclaration"}, {"full_name": "List.sublists_eq_sublistsAux", "code": "theorem sublists_eq_sublistsAux (l : List \u03b1) :\n    sublists l = l.foldr sublistsAux [[]]", "start": [138, 1], "end": [143, 31], "kind": "commanddeclaration"}, {"full_name": "List.sublists_append", "code": "theorem sublists_append (l\u2081 l\u2082 : List \u03b1) :\n    sublists (l\u2081 ++ l\u2082) = (sublists l\u2082) >>= (fun x => (sublists l\u2081).map (\u00b7 ++ x))", "start": [155, 1], "end": [162, 49], "kind": "commanddeclaration"}, {"full_name": "List.sublists_cons", "code": "theorem sublists_cons (a : \u03b1) (l : List \u03b1) :\n    sublists (a :: l) = sublists l >>= (fun x => [x, a :: x])", "start": [166, 1], "end": [170, 91], "kind": "commanddeclaration"}, {"full_name": "List.sublists_concat", "code": "@[simp]\ntheorem sublists_concat (l : List \u03b1) (a : \u03b1) :\n    sublists (l ++ [a]) = sublists l ++ map (fun x => x ++ [a]) (sublists l)", "start": [172, 1], "end": [176, 37], "kind": "commanddeclaration"}, {"full_name": "List.sublists_reverse", "code": "theorem sublists_reverse (l : List \u03b1) : sublists (reverse l) = map reverse (sublists' l)", "start": [179, 1], "end": [182, 84], "kind": "commanddeclaration"}, {"full_name": "List.sublists_eq_sublists'", "code": "theorem sublists_eq_sublists' (l : List \u03b1) : sublists l = map reverse (sublists' (reverse l))", "start": [185, 1], "end": [186, 43], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_reverse", "code": "theorem sublists'_reverse (l : List \u03b1) : sublists' (reverse l) = map reverse (sublists l)", "start": [189, 1], "end": [190, 85], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_eq_sublists", "code": "theorem sublists'_eq_sublists (l : List \u03b1) : sublists' l = map reverse (sublists (reverse l))", "start": [193, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "List.mem_sublists", "code": "@[simp]\ntheorem mem_sublists {s t : List \u03b1} : s \u2208 sublists t \u2194 s <+ t", "start": [199, 1], "end": [202, 44], "kind": "commanddeclaration"}, {"full_name": "List.length_sublists", "code": "@[simp]\ntheorem length_sublists (l : List \u03b1) : length (sublists l) = 2 ^ length l", "start": [205, 1], "end": [207, 82], "kind": "commanddeclaration"}, {"full_name": "List.map_ret_sublist_sublists", "code": "theorem map_ret_sublist_sublists (l : List \u03b1) : map List.ret l <+ sublists l", "start": [210, 1], "end": [216, 49], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLenAux", "code": "def sublistsLenAux {\u03b1 \u03b2 : Type*} : \u2115 \u2192 List \u03b1 \u2192 (List \u03b1 \u2192 \u03b2) \u2192 List \u03b2 \u2192 List \u03b2\n  | 0, _, f, r => f [] :: r\n  | _ + 1, [], _, r => r\n  | n + 1, a :: l, f, r => sublistsLenAux (n + 1) l f (sublistsLenAux n l (f \u2218 List.cons a) r)", "start": [222, 1], "end": [228, 95], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen", "code": "def sublistsLen {\u03b1 : Type*} (n : \u2115) (l : List \u03b1) : List (List \u03b1) :=\n  sublistsLenAux n l id []", "start": [231, 1], "end": [235, 27], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLenAux_append", "code": "theorem sublistsLenAux_append {\u03b1 \u03b2 \u03b3 : Type*} :\n    \u2200 (n : \u2115) (l : List \u03b1) (f : List \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (r : List \u03b2) (s : List \u03b3),\n      sublistsLenAux n l (g \u2218 f) (r.map g ++ s) = (sublistsLenAux n l f r).map g ++ s", "start": [238, 1], "end": [246, 29], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLenAux_eq", "code": "theorem sublistsLenAux_eq {\u03b1 \u03b2 : Type*} (l : List \u03b1) (n) (f : List \u03b1 \u2192 \u03b2) (r) :\n    sublistsLenAux n l f r = (sublistsLen n l).map f ++ r", "start": [249, 1], "end": [251, 49], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLenAux_zero", "code": "theorem sublistsLenAux_zero {\u03b1 : Type*} (l : List \u03b1) (f : List \u03b1 \u2192 \u03b2) (r) :\n    sublistsLenAux 0 l f r = f [] :: r", "start": [254, 1], "end": [255, 61], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_zero", "code": "@[simp]\ntheorem sublistsLen_zero {\u03b1 : Type*} (l : List \u03b1) : sublistsLen 0 l = [[]]", "start": [258, 1], "end": [260, 28], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_succ_nil", "code": "@[simp]\ntheorem sublistsLen_succ_nil {\u03b1 : Type*} (n) : sublistsLen (n + 1) (@nil \u03b1) = []", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_succ_cons", "code": "@[simp]\ntheorem sublistsLen_succ_cons {\u03b1 : Type*} (n) (a : \u03b1) (l) :\n    sublistsLen (n + 1) (a :: l) = sublistsLen (n + 1) l ++ (sublistsLen n l).map (cons a)", "start": [268, 1], "end": [272, 23], "kind": "commanddeclaration"}, {"full_name": "List.length_sublistsLen", "code": "@[simp]\ntheorem length_sublistsLen {\u03b1 : Type*} :\n    \u2200 (n) (l : List \u03b1), length (sublistsLen n l) = Nat.choose (length l) n", "start": [275, 1], "end": [282, 87], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_sublist_sublists'", "code": "theorem sublistsLen_sublist_sublists' {\u03b1 : Type*} :\n    \u2200 (n) (l : List \u03b1), sublistsLen n l <+ sublists' l", "start": [285, 1], "end": [291, 97], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_sublist_of_sublist", "code": "theorem sublistsLen_sublist_of_sublist {\u03b1 : Type*} (n) {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+ l\u2082) :\n    sublistsLen n l\u2081 <+ sublistsLen n l\u2082", "start": [294, 1], "end": [302, 36], "kind": "commanddeclaration"}, {"full_name": "List.length_of_sublistsLen", "code": "theorem length_of_sublistsLen {\u03b1 : Type*} :\n    \u2200 {n} {l l' : List \u03b1}, l' \u2208 sublistsLen n l \u2192 length l' = n", "start": [305, 1], "end": [312, 56], "kind": "commanddeclaration"}, {"full_name": "List.mem_sublistsLen_self", "code": "theorem mem_sublistsLen_self {\u03b1 : Type*} {l l' : List \u03b1} (h : l' <+ l) :\n    l' \u2208 sublistsLen (length l') l", "start": [315, 1], "end": [324, 54], "kind": "commanddeclaration"}, {"full_name": "List.mem_sublistsLen", "code": "@[simp]\ntheorem mem_sublistsLen {\u03b1 : Type*} {n} {l l' : List \u03b1} :\n    l' \u2208 sublistsLen n l \u2194 l' <+ l \u2227 length l' = n", "start": [327, 1], "end": [332, 50], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_of_length_lt", "code": "theorem sublistsLen_of_length_lt {n} {l : List \u03b1} (h : l.length < n) : sublistsLen n l = []", "start": [335, 1], "end": [337, 95], "kind": "commanddeclaration"}, {"full_name": "List.sublistsLen_length", "code": "@[simp]\ntheorem sublistsLen_length : \u2200 l : List \u03b1, sublistsLen l.length l = [l]", "start": [340, 1], "end": [345, 61], "kind": "commanddeclaration"}, {"full_name": "List.Pairwise.sublists'", "code": "theorem Pairwise.sublists' {R} :\n    \u2200 {l : List \u03b1}, Pairwise R l \u2192 Pairwise (Lex (swap R)) (sublists' l)", "start": [350, 1], "end": [359, 60], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_sublists", "code": "theorem pairwise_sublists {R} {l : List \u03b1} (H : Pairwise R l) :\n    Pairwise (fun l\u2081 l\u2082 => Lex R (reverse l\u2081) (reverse l\u2082)) (sublists l)", "start": [362, 1], "end": [365, 48], "kind": "commanddeclaration"}, {"full_name": "List.nodup_sublists", "code": "@[simp]\ntheorem nodup_sublists {l : List \u03b1} : Nodup (sublists l) \u2194 Nodup l", "start": [368, 1], "end": [371, 70], "kind": "commanddeclaration"}, {"full_name": "List.nodup_sublists'", "code": "@[simp]\ntheorem nodup_sublists' {l : List \u03b1} : Nodup (sublists' l) \u2194 Nodup l", "start": [374, 1], "end": [376, 93], "kind": "commanddeclaration"}, {"full_name": "List.nodup.of_sublists", "code": "alias \u27e8nodup.of_sublists, nodup.sublists\u27e9 := nodup_sublists", "start": [379, 1], "end": [379, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.nodup.sublists", "code": "alias \u27e8nodup.of_sublists, nodup.sublists\u27e9 := nodup_sublists", "start": [379, 1], "end": [379, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.nodup.of_sublists'", "code": "alias \u27e8nodup.of_sublists', nodup.sublists'\u27e9 := nodup_sublists'", "start": [383, 1], "end": [383, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.nodup.sublists'", "code": "alias \u27e8nodup.of_sublists', nodup.sublists'\u27e9 := nodup_sublists'", "start": [383, 1], "end": [383, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.nodup_sublistsLen", "code": "theorem nodup_sublistsLen (n : \u2115) {l : List \u03b1} (h : Nodup l) : (sublistsLen n l).Nodup", "start": [390, 1], "end": [393, 57], "kind": "commanddeclaration"}, {"full_name": "List.sublists_map", "code": "theorem sublists_map (f : \u03b1 \u2192 \u03b2) : \u2200 (l : List \u03b1),\n    sublists (map f l) = map (map f) (sublists l)", "start": [397, 1], "end": [403, 38], "kind": "commanddeclaration"}, {"full_name": "List.sublists'_map", "code": "theorem sublists'_map (f : \u03b1 \u2192 \u03b2) : \u2200 (l : List \u03b1),\n    sublists' (map f l) = map (map f) (sublists' l)", "start": [406, 1], "end": [409, 81], "kind": "commanddeclaration"}, {"full_name": "List.sublists_perm_sublists'", "code": "theorem sublists_perm_sublists' (l : List \u03b1) : sublists l ~ sublists' l", "start": [412, 1], "end": [416, 14], "kind": "commanddeclaration"}, {"full_name": "List.sublists_cons_perm_append", "code": "theorem sublists_cons_perm_append (a : \u03b1) (l : List \u03b1) :\n    sublists (a :: l) ~ sublists l ++ map (cons a) (sublists l)", "start": [419, 1], "end": [423, 99], "kind": "commanddeclaration"}, {"full_name": "List.revzip_sublists", "code": "theorem revzip_sublists (l : List \u03b1) : \u2200 l\u2081 l\u2082, (l\u2081, l\u2082) \u2208 revzip l.sublists \u2192 l\u2081 ++ l\u2082 ~ l", "start": [426, 1], "end": [442, 38], "kind": "commanddeclaration"}, {"full_name": "List.revzip_sublists'", "code": "theorem revzip_sublists' (l : List \u03b1) : \u2200 l\u2081 l\u2082, (l\u2081, l\u2082) \u2208 revzip l.sublists' \u2192 l\u2081 ++ l\u2082 ~ l", "start": [445, 1], "end": [454, 30], "kind": "commanddeclaration"}, {"full_name": "List.range_bind_sublistsLen_perm", "code": "theorem range_bind_sublistsLen_perm {\u03b1 : Type*} (l : List \u03b1) :\n    ((List.range (l.length + 1)).bind fun n => sublistsLen n l) ~ sublists' l", "start": [457, 1], "end": [471, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Lattice.lean", "imports": ["Mathlib/Data/Multiset/FinsetOps.lean", "Mathlib/Data/Multiset/Fold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.sup", "code": "def sup (s : Multiset \u03b1) : \u03b1 :=\n  s.fold (\u00b7 \u2294 \u00b7) \u22a5", "start": [28, 1], "end": [30, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_coe", "code": "@[simp]\ntheorem sup_coe (l : List \u03b1) : sup (l : Multiset \u03b1) = l.foldr (\u00b7 \u2294 \u00b7) \u22a5", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_zero", "code": "@[simp]\ntheorem sup_zero : (0 : Multiset \u03b1).sup = \u22a5", "start": [38, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_cons", "code": "@[simp]\ntheorem sup_cons (a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).sup = a \u2294 s.sup", "start": [43, 1], "end": [45, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_singleton", "code": "@[simp]\ntheorem sup_singleton {a : \u03b1} : ({a} : Multiset \u03b1).sup = a", "start": [48, 1], "end": [50, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_add", "code": "@[simp]\ntheorem sup_add (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 + s\u2082).sup = s\u2081.sup \u2294 s\u2082.sup", "start": [53, 1], "end": [55, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_le", "code": "theorem sup_le {s : Multiset \u03b1} {a : \u03b1} : s.sup \u2264 a \u2194 \u2200 b \u2208 s, b \u2264 a", "start": [58, 1], "end": [60, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_sup", "code": "theorem le_sup {s : Multiset \u03b1} {a : \u03b1} (h : a \u2208 s) : a \u2264 s.sup", "start": [63, 1], "end": [64, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_mono", "code": "theorem sup_mono {s\u2081 s\u2082 : Multiset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081.sup \u2264 s\u2082.sup", "start": [67, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_dedup", "code": "@[simp]\ntheorem sup_dedup (s : Multiset \u03b1) : (dedup s).sup = s.sup", "start": [73, 1], "end": [75, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_ndunion", "code": "@[simp]\ntheorem sup_ndunion (s\u2081 s\u2082 : Multiset \u03b1) : (ndunion s\u2081 s\u2082).sup = s\u2081.sup \u2294 s\u2082.sup", "start": [78, 1], "end": [80, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_union", "code": "@[simp]\ntheorem sup_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).sup = s\u2081.sup \u2294 s\u2082.sup", "start": [83, 1], "end": [85, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_ndinsert", "code": "@[simp]\ntheorem sup_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).sup = a \u2294 s.sup", "start": [88, 1], "end": [90, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_sup_iff", "code": "theorem nodup_sup_iff {\u03b1 : Type*} [DecidableEq \u03b1] {m : Multiset (Multiset \u03b1)} :\n    m.sup.Nodup \u2194 \u2200 a : Multiset \u03b1, a \u2208 m \u2192 a.Nodup", "start": [93, 1], "end": [99, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf", "code": "def inf (s : Multiset \u03b1) : \u03b1 :=\n  s.fold (\u00b7 \u2293 \u00b7) \u22a4", "start": [112, 1], "end": [114, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_coe", "code": "@[simp]\ntheorem inf_coe (l : List \u03b1) : inf (l : Multiset \u03b1) = l.foldr (\u00b7 \u2293 \u00b7) \u22a4", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_zero", "code": "@[simp]\ntheorem inf_zero : (0 : Multiset \u03b1).inf = \u22a4", "start": [122, 1], "end": [124, 16], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_cons", "code": "@[simp]\ntheorem inf_cons (a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).inf = a \u2293 s.inf", "start": [127, 1], "end": [129, 25], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_singleton", "code": "@[simp]\ntheorem inf_singleton {a : \u03b1} : ({a} : Multiset \u03b1).inf = a", "start": [132, 1], "end": [134, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_add", "code": "@[simp]\ntheorem inf_add (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 + s\u2082).inf = s\u2081.inf \u2293 s\u2082.inf", "start": [137, 1], "end": [139, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.le_inf", "code": "theorem le_inf {s : Multiset \u03b1} {a : \u03b1} : a \u2264 s.inf \u2194 \u2200 b \u2208 s, a \u2264 b", "start": [142, 1], "end": [144, 70], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_le", "code": "theorem inf_le {s : Multiset \u03b1} {a : \u03b1} (h : a \u2208 s) : s.inf \u2264 a", "start": [147, 1], "end": [148, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_mono", "code": "theorem inf_mono {s\u2081 s\u2082 : Multiset \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2082.inf \u2264 s\u2081.inf", "start": [151, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_dedup", "code": "@[simp]\ntheorem inf_dedup (s : Multiset \u03b1) : (dedup s).inf = s.inf", "start": [157, 1], "end": [159, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_ndunion", "code": "@[simp]\ntheorem inf_ndunion (s\u2081 s\u2082 : Multiset \u03b1) : (ndunion s\u2081 s\u2082).inf = s\u2081.inf \u2293 s\u2082.inf", "start": [162, 1], "end": [164, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_union", "code": "@[simp]\ntheorem inf_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).inf = s\u2081.inf \u2293 s\u2082.inf", "start": [167, 1], "end": [169, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.inf_ndinsert", "code": "@[simp]\ntheorem inf_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).inf = a \u2293 s.inf", "start": [172, 1], "end": [174, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/Lattice.lean", "imports": ["Mathlib/Order/Hom/Bounded.lean", "Mathlib/Order/SymmDiff.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SupHom", "code": "structure SupHom (\u03b1 \u03b2 : Type*) [Sup \u03b1] [Sup \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_sup' (a b : \u03b1) : toFun (a \u2294 b) = toFun a \u2294 toFun b", "start": [47, 1], "end": [52, 57], "kind": "commanddeclaration"}, {"full_name": "InfHom", "code": "structure InfHom (\u03b1 \u03b2 : Type*) [Inf \u03b1] [Inf \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_inf' (a b : \u03b1) : toFun (a \u2293 b) = toFun a \u2293 toFun b", "start": [55, 1], "end": [60, 57], "kind": "commanddeclaration"}, {"full_name": "SupBotHom", "code": "structure SupBotHom (\u03b1 \u03b2 : Type*) [Sup \u03b1] [Sup \u03b2] [Bot \u03b1] [Bot \u03b2] extends SupHom \u03b1 \u03b2 where\n  \n  map_bot' : toFun \u22a5 = \u22a5", "start": [63, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "InfTopHom", "code": "structure InfTopHom (\u03b1 \u03b2 : Type*) [Inf \u03b1] [Inf \u03b2] [Top \u03b1] [Top \u03b2] extends InfHom \u03b1 \u03b2 where\n  \n  map_top' : toFun \u22a4 = \u22a4", "start": [69, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "LatticeHom", "code": "structure LatticeHom (\u03b1 \u03b2 : Type*) [Lattice \u03b1] [Lattice \u03b2] extends SupHom \u03b1 \u03b2 where\n  \n  map_inf' (a b : \u03b1) : toFun (a \u2293 b) = toFun a \u2293 toFun b", "start": [75, 1], "end": [78, 57], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom", "code": "structure BoundedLatticeHom (\u03b1 \u03b2 : Type*) [Lattice \u03b1] [Lattice \u03b2] [BoundedOrder \u03b1]\n  [BoundedOrder \u03b2] extends LatticeHom \u03b1 \u03b2 where\n  \n  map_top' : toFun \u22a4 = \u22a4\n  \n  map_bot' : toFun \u22a5 = \u22a5", "start": [81, 1], "end": [87, 25], "kind": "commanddeclaration"}, {"full_name": "SupHomClass", "code": "class SupHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Sup \u03b1] [Sup \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_sup (f : F) (a b : \u03b1) : f (a \u2294 b) = f a \u2294 f b", "start": [99, 1], "end": [105, 52], "kind": "commanddeclaration"}, {"full_name": "InfHomClass", "code": "class InfHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Inf \u03b1] [Inf \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_inf (f : F) (a b : \u03b1) : f (a \u2293 b) = f a \u2293 f b", "start": [108, 1], "end": [114, 52], "kind": "commanddeclaration"}, {"full_name": "SupBotHomClass", "code": "class SupBotHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Sup \u03b1] [Sup \u03b2] [Bot \u03b1]\n  [Bot \u03b2] extends SupHomClass F \u03b1 \u03b2 where\n  \n  map_bot (f : F) : f \u22a5 = \u22a5", "start": [117, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "InfTopHomClass", "code": "class InfTopHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Inf \u03b1] [Inf \u03b2] [Top \u03b1]\n  [Top \u03b2] extends InfHomClass F \u03b1 \u03b2 where\n  \n  map_top (f : F) : f \u22a4 = \u22a4", "start": [126, 1], "end": [132, 28], "kind": "commanddeclaration"}, {"full_name": "LatticeHomClass", "code": "class LatticeHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Lattice \u03b1] [Lattice \u03b2] extends\n  SupHomClass F \u03b1 \u03b2 where\n  \n  map_inf (f : F) (a b : \u03b1) : f (a \u2293 b) = f a \u2293 f b", "start": [135, 1], "end": [141, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHomClass", "code": "class BoundedLatticeHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Lattice \u03b1] [Lattice \u03b2]\n  [BoundedOrder \u03b1] [BoundedOrder \u03b2] extends LatticeHomClass F \u03b1 \u03b2 where\n  \n  map_top (f : F) : f \u22a4 = \u22a4\n  \n  map_bot (f : F) : f \u22a5 = \u22a5", "start": [144, 1], "end": [152, 28], "kind": "commanddeclaration"}, {"full_name": "SupHomClass.toOrderHomClass", "code": "instance (priority := 100) SupHomClass.toOrderHomClass [SemilatticeSup \u03b1] [SemilatticeSup \u03b2]\n    [SupHomClass F \u03b1 \u03b2] : OrderHomClass F \u03b1 \u03b2 :=\n  { \u2039SupHomClass F \u03b1 \u03b2\u203a with\n    map_rel := fun f a b h => by rw [\u2190 sup_eq_right, \u2190 map_sup, sup_eq_right.2 h] }", "start": [167, 1], "end": [170, 84], "kind": "commanddeclaration"}, {"full_name": "InfHomClass.toOrderHomClass", "code": "instance (priority := 100) InfHomClass.toOrderHomClass [SemilatticeInf \u03b1] [SemilatticeInf \u03b2]\n    [InfHomClass F \u03b1 \u03b2] : OrderHomClass F \u03b1 \u03b2 :=\n  { \u2039InfHomClass F \u03b1 \u03b2\u203a with\n    map_rel := fun f a b h => by rw [\u2190 inf_eq_left, \u2190 map_inf, inf_eq_left.2 h] }", "start": [174, 1], "end": [177, 82], "kind": "commanddeclaration"}, {"full_name": "SupBotHomClass.toBotHomClass", "code": "instance (priority := 100) SupBotHomClass.toBotHomClass [Sup \u03b1] [Sup \u03b2] [Bot \u03b1]\n    [Bot \u03b2] [SupBotHomClass F \u03b1 \u03b2] : BotHomClass F \u03b1 \u03b2 :=\n  { \u2039SupBotHomClass F \u03b1 \u03b2\u203a with }", "start": [181, 1], "end": [183, 34], "kind": "commanddeclaration"}, {"full_name": "InfTopHomClass.toTopHomClass", "code": "instance (priority := 100) InfTopHomClass.toTopHomClass [Inf \u03b1] [Inf \u03b2] [Top \u03b1]\n    [Top \u03b2] [InfTopHomClass F \u03b1 \u03b2] : TopHomClass F \u03b1 \u03b2 :=\n  { \u2039InfTopHomClass F \u03b1 \u03b2\u203a with }", "start": [187, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "LatticeHomClass.toInfHomClass", "code": "instance (priority := 100) LatticeHomClass.toInfHomClass [Lattice \u03b1] [Lattice \u03b2]\n    [LatticeHomClass F \u03b1 \u03b2] : InfHomClass F \u03b1 \u03b2 :=\n  { \u2039LatticeHomClass F \u03b1 \u03b2\u203a with }", "start": [193, 1], "end": [195, 35], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHomClass.toSupBotHomClass", "code": "instance (priority := 100) BoundedLatticeHomClass.toSupBotHomClass [Lattice \u03b1] [Lattice \u03b2]\n    [BoundedOrder \u03b1] [BoundedOrder \u03b2] [BoundedLatticeHomClass F \u03b1 \u03b2] :\n    SupBotHomClass F \u03b1 \u03b2 :=\n  { \u2039BoundedLatticeHomClass F \u03b1 \u03b2\u203a with }", "start": [199, 1], "end": [202, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHomClass.toInfTopHomClass", "code": "instance (priority := 100) BoundedLatticeHomClass.toInfTopHomClass [Lattice \u03b1] [Lattice \u03b2]\n    [BoundedOrder \u03b1] [BoundedOrder \u03b2] [BoundedLatticeHomClass F \u03b1 \u03b2] :\n    InfTopHomClass F \u03b1 \u03b2 :=\n  { \u2039BoundedLatticeHomClass F \u03b1 \u03b2\u203a with }", "start": [206, 1], "end": [209, 42], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHomClass.toBoundedOrderHomClass", "code": "instance (priority := 100) BoundedLatticeHomClass.toBoundedOrderHomClass [Lattice \u03b1]\n    [Lattice \u03b2] [BoundedOrder \u03b1] [BoundedOrder \u03b2] [BoundedLatticeHomClass F \u03b1 \u03b2] :\n    BoundedOrderHomClass F \u03b1 \u03b2 :=\n{ show OrderHomClass F \u03b1 \u03b2 from inferInstance, \u2039BoundedLatticeHomClass F \u03b1 \u03b2\u203a with }", "start": [213, 1], "end": [216, 85], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toSupHomClass", "code": "instance (priority := 100) OrderIsoClass.toSupHomClass [SemilatticeSup \u03b1] [SemilatticeSup \u03b2]\n    [OrderIsoClass F \u03b1 \u03b2] : SupHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_sup := fun f a b =>\n      eq_of_forall_ge_iff fun c => by simp only [\u2190 le_map_inv_iff, sup_le_iff] }", "start": [220, 1], "end": [224, 81], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toInfHomClass", "code": "instance (priority := 100) OrderIsoClass.toInfHomClass [SemilatticeInf \u03b1] [SemilatticeInf \u03b2]\n    [OrderIsoClass F \u03b1 \u03b2] : InfHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_inf := fun f a b =>\n      eq_of_forall_le_iff fun c => by simp only [\u2190 map_inv_le_iff, le_inf_iff] }", "start": [229, 1], "end": [233, 81], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toSupBotHomClass", "code": "instance (priority := 100) OrderIsoClass.toSupBotHomClass [SemilatticeSup \u03b1] [OrderBot \u03b1]\n    [SemilatticeSup \u03b2] [OrderBot \u03b2] [OrderIsoClass F \u03b1 \u03b2] : SupBotHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toSupHomClass, OrderIsoClass.toBotHomClass with }", "start": [237, 1], "end": [239, 68], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toInfTopHomClass", "code": "instance (priority := 100) OrderIsoClass.toInfTopHomClass [SemilatticeInf \u03b1] [OrderTop \u03b1]\n    [SemilatticeInf \u03b2] [OrderTop \u03b2] [OrderIsoClass F \u03b1 \u03b2] : InfTopHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toInfHomClass, OrderIsoClass.toTopHomClass with }", "start": [243, 1], "end": [245, 68], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toLatticeHomClass", "code": "instance (priority := 100) OrderIsoClass.toLatticeHomClass [Lattice \u03b1] [Lattice \u03b2]\n    [OrderIsoClass F \u03b1 \u03b2] : LatticeHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toSupHomClass, OrderIsoClass.toInfHomClass with }", "start": [249, 1], "end": [251, 68], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toBoundedLatticeHomClass", "code": "instance (priority := 100) OrderIsoClass.toBoundedLatticeHomClass [Lattice \u03b1] [Lattice \u03b2]\n    [BoundedOrder \u03b1] [BoundedOrder \u03b2] [OrderIsoClass F \u03b1 \u03b2] :\n    BoundedLatticeHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.toLatticeHomClass, OrderIsoClass.toBoundedOrderHomClass with }", "start": [255, 1], "end": [258, 81], "kind": "commanddeclaration"}, {"full_name": "Disjoint.map", "code": "theorem Disjoint.map (h : Disjoint a b) : Disjoint (f a) (f b)", "start": [266, 1], "end": [267, 50], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.map", "code": "theorem Codisjoint.map (h : Codisjoint a b) : Codisjoint (f a) (f b)", "start": [270, 1], "end": [271, 52], "kind": "commanddeclaration"}, {"full_name": "IsCompl.map", "code": "theorem IsCompl.map (h : IsCompl a b) : IsCompl (f a) (f b)", "start": [274, 1], "end": [275, 25], "kind": "commanddeclaration"}, {"full_name": "map_compl'", "code": "theorem map_compl' (a : \u03b1) : f a\u1d9c = (f a)\u1d9c", "start": [284, 1], "end": [286, 38], "kind": "commanddeclaration"}, {"full_name": "map_sdiff'", "code": "theorem map_sdiff' (a b : \u03b1) : f (a \\ b) = f a \\ f b", "start": [289, 1], "end": [291, 47], "kind": "commanddeclaration"}, {"full_name": "map_symmDiff'", "code": "theorem map_symmDiff' (a b : \u03b1) : f (a \u2206 b) = f a \u2206 f b", "start": [294, 1], "end": [296, 59], "kind": "commanddeclaration"}, {"full_name": "SupHom.toFun_eq_coe", "code": "@[simp] lemma toFun_eq_coe (f : SupHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [348, 1], "end": [348, 65], "kind": "mathlibtacticlemma"}, {"full_name": "SupHom.coe_mk", "code": "@[simp, norm_cast] lemma coe_mk (f : \u03b1 \u2192 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [351, 1], "end": [351, 73], "kind": "mathlibtacticlemma"}, {"full_name": "SupHom.ext", "code": "@[ext]\ntheorem ext {f g : SupHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [353, 1], "end": [355, 20], "kind": "commanddeclaration"}, {"full_name": "SupHom.copy", "code": "protected def copy (f : SupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : SupHom \u03b1 \u03b2 where\n  toFun := f'\n  map_sup' := h.symm \u25b8 f.map_sup'", "start": [358, 1], "end": [362, 34], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : SupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.copy_eq", "code": "theorem copy_eq (f : SupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [370, 1], "end": [371, 17], "kind": "commanddeclaration"}, {"full_name": "SupHom.id", "code": "protected def id : SupHom \u03b1 \u03b1 :=\n  \u27e8id, fun _ _ => rfl\u27e9", "start": [376, 1], "end": [378, 23], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(SupHom.id \u03b1) = id", "start": [384, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : SupHom.id \u03b1 a = a", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.comp", "code": "def comp (f : SupHom \u03b2 \u03b3) (g : SupHom \u03b1 \u03b2) : SupHom \u03b1 \u03b3 where\n  toFun := f \u2218 g\n  map_sup' a b := by rw [comp_apply, map_sup, map_sup]; rfl", "start": [396, 1], "end": [399, 60], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : SupHom \u03b2 \u03b3) (g : SupHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [402, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : SupHom \u03b2 \u03b3) (g : SupHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [407, 1], "end": [409, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : SupHom \u03b3 \u03b4) (g : SupHom \u03b2 \u03b3) (h : SupHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [412, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.comp_id", "code": "@[simp] theorem comp_id (f : SupHom \u03b1 \u03b2) : f.comp (SupHom.id \u03b1) = f", "start": [418, 1], "end": [418, 75], "kind": "commanddeclaration"}, {"full_name": "SupHom.id_comp", "code": "@[simp] theorem id_comp (f : SupHom \u03b1 \u03b2) : (SupHom.id \u03b2).comp f = f", "start": [421, 1], "end": [421, 75], "kind": "commanddeclaration"}, {"full_name": "SupHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : SupHom \u03b2 \u03b3} {f : SupHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [424, 1], "end": [427, 91], "kind": "commanddeclaration"}, {"full_name": "SupHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : SupHom \u03b2 \u03b3} {f\u2081 f\u2082 : SupHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [430, 1], "end": [434, 17], "kind": "commanddeclaration"}, {"full_name": "SupHom.const", "code": "def const (b : \u03b2) : SupHom \u03b1 \u03b2 :=\n  \u27e8fun _ => b, fun _ _ => sup_idem.symm\u27e9", "start": [441, 1], "end": [443, 41], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_const", "code": "@[simp]\ntheorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b", "start": [446, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.const_apply", "code": "@[simp]\ntheorem const_apply (b : \u03b2) (a : \u03b1) : const \u03b1 b a = b", "start": [451, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_sup", "code": "@[simp]\ntheorem coe_sup (f g : SupHom \u03b1 \u03b2) : FunLike.coe (f \u2294 g) = f \u2294 g", "start": [482, 1], "end": [484, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_bot", "code": "@[simp]\ntheorem coe_bot [Bot \u03b2] : \u21d1(\u22a5 : SupHom \u03b1 \u03b2) = \u22a5", "start": [487, 1], "end": [489, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.coe_top", "code": "@[simp]\ntheorem coe_top [Top \u03b2] : \u21d1(\u22a4 : SupHom \u03b1 \u03b2) = \u22a4", "start": [492, 1], "end": [494, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.sup_apply", "code": "@[simp]\ntheorem sup_apply (f g : SupHom \u03b1 \u03b2) (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a", "start": [497, 1], "end": [499, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.bot_apply", "code": "@[simp]\ntheorem bot_apply [Bot \u03b2] (a : \u03b1) : (\u22a5 : SupHom \u03b1 \u03b2) a = \u22a5", "start": [502, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.top_apply", "code": "@[simp]\ntheorem top_apply [Top \u03b2] (a : \u03b1) : (\u22a4 : SupHom \u03b1 \u03b2) a = \u22a4", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.toFun_eq_coe", "code": "@[simp] lemma toFun_eq_coe (f : InfHom \u03b1 \u03b2) : f.toFun = (f : \u03b1 \u2192 \u03b2) := rfl", "start": [535, 1], "end": [535, 75], "kind": "mathlibtacticlemma"}, {"full_name": "InfHom.coe_mk", "code": "@[simp, norm_cast] lemma coe_mk (f : \u03b1 \u2192 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [538, 1], "end": [538, 73], "kind": "mathlibtacticlemma"}, {"full_name": "InfHom.ext", "code": "@[ext]\ntheorem ext {f g : InfHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [540, 1], "end": [542, 20], "kind": "commanddeclaration"}, {"full_name": "InfHom.copy", "code": "protected def copy (f : InfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : InfHom \u03b1 \u03b2\n    where\n  toFun := f'\n  map_inf' := h.symm \u25b8 f.map_inf'", "start": [545, 1], "end": [550, 34], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : InfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [553, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.copy_eq", "code": "theorem copy_eq (f : InfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [558, 1], "end": [559, 17], "kind": "commanddeclaration"}, {"full_name": "InfHom.id", "code": "protected def id : InfHom \u03b1 \u03b1 :=\n  \u27e8id, fun _ _ => rfl\u27e9", "start": [564, 1], "end": [566, 23], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(InfHom.id \u03b1) = id", "start": [572, 1], "end": [574, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : InfHom.id \u03b1 a = a", "start": [579, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.comp", "code": "def comp (f : InfHom \u03b2 \u03b3) (g : InfHom \u03b1 \u03b2) : InfHom \u03b1 \u03b3 where\n  toFun := f \u2218 g\n  map_inf' a b := by rw [comp_apply, map_inf, map_inf]; rfl", "start": [584, 1], "end": [587, 60], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : InfHom \u03b2 \u03b3) (g : InfHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [590, 1], "end": [592, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : InfHom \u03b2 \u03b3) (g : InfHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [595, 1], "end": [597, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : InfHom \u03b3 \u03b4) (g : InfHom \u03b2 \u03b3) (h : InfHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [600, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.comp_id", "code": "@[simp] theorem comp_id (f : InfHom \u03b1 \u03b2) : f.comp (InfHom.id \u03b1) = f", "start": [606, 1], "end": [606, 75], "kind": "commanddeclaration"}, {"full_name": "InfHom.id_comp", "code": "@[simp] theorem id_comp (f : InfHom \u03b1 \u03b2) : (InfHom.id \u03b2).comp f = f", "start": [609, 1], "end": [609, 75], "kind": "commanddeclaration"}, {"full_name": "InfHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : InfHom \u03b2 \u03b3} {f : InfHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [612, 1], "end": [615, 91], "kind": "commanddeclaration"}, {"full_name": "InfHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : InfHom \u03b2 \u03b3} {f\u2081 f\u2082 : InfHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [618, 1], "end": [622, 17], "kind": "commanddeclaration"}, {"full_name": "InfHom.const", "code": "def const (b : \u03b2) : InfHom \u03b1 \u03b2 :=\n  \u27e8fun _ => b, fun _ _ => inf_idem.symm\u27e9", "start": [629, 1], "end": [631, 41], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_const", "code": "@[simp]\ntheorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b", "start": [634, 1], "end": [636, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.const_apply", "code": "@[simp]\ntheorem const_apply (b : \u03b2) (a : \u03b1) : const \u03b1 b a = b", "start": [639, 1], "end": [641, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_inf", "code": "@[simp]\ntheorem coe_inf (f g : InfHom \u03b1 \u03b2) : FunLike.coe (f \u2293 g) = f \u2293 g", "start": [670, 1], "end": [672, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_bot", "code": "@[simp]\ntheorem coe_bot [Bot \u03b2] : \u21d1(\u22a5 : InfHom \u03b1 \u03b2) = \u22a5", "start": [675, 1], "end": [677, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.coe_top", "code": "@[simp]\ntheorem coe_top [Top \u03b2] : \u21d1(\u22a4 : InfHom \u03b1 \u03b2) = \u22a4", "start": [680, 1], "end": [682, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.inf_apply", "code": "@[simp]\ntheorem inf_apply (f g : InfHom \u03b1 \u03b2) (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a", "start": [685, 1], "end": [687, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.bot_apply", "code": "@[simp]\ntheorem bot_apply [Bot \u03b2] (a : \u03b1) : (\u22a5 : InfHom \u03b1 \u03b2) a = \u22a5", "start": [690, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.top_apply", "code": "@[simp]\ntheorem top_apply [Top \u03b2] (a : \u03b1) : (\u22a4 : InfHom \u03b1 \u03b2) a = \u22a4", "start": [695, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.toBotHom", "code": "def toBotHom (f : SupBotHom \u03b1 \u03b2) : BotHom \u03b1 \u03b2 :=\n  { f with }", "start": [712, 1], "end": [714, 13], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.toFun_eq_coe", "code": "lemma toFun_eq_coe (f : SupBotHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [731, 1], "end": [731, 60], "kind": "mathlibtacticlemma"}, {"full_name": "SupBotHom.coe_toSupHom", "code": "@[simp] lemma coe_toSupHom (f : SupBotHom \u03b1 \u03b2) : \u21d1f.toSupHom = f := rfl", "start": [734, 1], "end": [734, 72], "kind": "mathlibtacticlemma"}, {"full_name": "SupBotHom.coe_toBotHom", "code": "@[simp] lemma coe_toBotHom (f : SupBotHom \u03b1 \u03b2) : \u21d1f.toBotHom = f := rfl", "start": [735, 1], "end": [735, 72], "kind": "mathlibtacticlemma"}, {"full_name": "SupBotHom.coe_mk", "code": "@[simp] lemma coe_mk (f : SupHom \u03b1 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [736, 1], "end": [736, 67], "kind": "mathlibtacticlemma"}, {"full_name": "SupBotHom.ext", "code": "@[ext]\ntheorem ext {f g : SupBotHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [738, 1], "end": [740, 20], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.copy", "code": "protected def copy (f : SupBotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : SupBotHom \u03b1 \u03b2 :=\n  { f.toBotHom.copy f' h with toSupHom := f.toSupHom.copy f' h }", "start": [743, 1], "end": [746, 65], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : SupBotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [749, 1], "end": [751, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.copy_eq", "code": "theorem copy_eq (f : SupBotHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [754, 1], "end": [755, 17], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.id", "code": "@[simps]\nprotected def id : SupBotHom \u03b1 \u03b1 :=\n  \u27e8SupHom.id \u03b1, rfl\u27e9", "start": [760, 1], "end": [763, 21], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(SupBotHom.id \u03b1) = id", "start": [769, 1], "end": [771, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : SupBotHom.id \u03b1 a = a", "start": [776, 1], "end": [778, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.comp", "code": "def comp (f : SupBotHom \u03b2 \u03b3) (g : SupBotHom \u03b1 \u03b2) : SupBotHom \u03b1 \u03b3 :=\n  { f.toSupHom.comp g.toSupHom, f.toBotHom.comp g.toBotHom with }", "start": [781, 1], "end": [783, 66], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : SupBotHom \u03b2 \u03b3) (g : SupBotHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [786, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : SupBotHom \u03b2 \u03b3) (g : SupBotHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [791, 1], "end": [793, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : SupBotHom \u03b3 \u03b4) (g : SupBotHom \u03b2 \u03b3) (h : SupBotHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [796, 1], "end": [799, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.comp_id", "code": "@[simp] theorem comp_id (f : SupBotHom \u03b1 \u03b2) : f.comp (SupBotHom.id \u03b1) = f", "start": [802, 1], "end": [802, 81], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.id_comp", "code": "@[simp] theorem id_comp (f : SupBotHom \u03b1 \u03b2) : (SupBotHom.id \u03b2).comp f = f", "start": [805, 1], "end": [805, 81], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : SupBotHom \u03b2 \u03b3} {f : SupBotHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [808, 1], "end": [811, 84], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : SupBotHom \u03b2 \u03b3} {f\u2081 f\u2082 : SupBotHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [814, 1], "end": [817, 91], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.coe_sup", "code": "@[simp]\ntheorem coe_sup (f g : SupBotHom \u03b1 \u03b2) : FunLike.coe (f \u2294 g) = f \u2294 g", "start": [834, 1], "end": [836, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.coe_bot", "code": "@[simp]\ntheorem coe_bot : \u21d1(\u22a5 : SupBotHom \u03b1 \u03b2) = \u22a5", "start": [839, 1], "end": [841, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.sup_apply", "code": "@[simp]\ntheorem sup_apply (f g : SupBotHom \u03b1 \u03b2) (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a", "start": [844, 1], "end": [846, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.bot_apply", "code": "@[simp]\ntheorem bot_apply (a : \u03b1) : (\u22a5 : SupBotHom \u03b1 \u03b2) a = \u22a5", "start": [849, 1], "end": [851, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.toTopHom", "code": "def toTopHom (f : InfTopHom \u03b1 \u03b2) : TopHom \u03b1 \u03b2 :=\n  { f with }", "start": [867, 1], "end": [869, 13], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.toFun_eq_coe", "code": "theorem toFun_eq_coe (f : InfTopHom \u03b1 \u03b2) : f.toFun = f", "start": [887, 1], "end": [887, 62], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_toInfHom", "code": "@[simp] lemma coe_toInfHom (f : InfTopHom \u03b1 \u03b2) : \u21d1f.toInfHom = f := rfl", "start": [890, 1], "end": [890, 72], "kind": "mathlibtacticlemma"}, {"full_name": "InfTopHom.coe_toTopHom", "code": "@[simp] lemma coe_toTopHom (f : InfTopHom \u03b1 \u03b2) : \u21d1f.toTopHom = f := rfl", "start": [891, 1], "end": [891, 72], "kind": "mathlibtacticlemma"}, {"full_name": "InfTopHom.coe_mk", "code": "@[simp] lemma coe_mk (f : InfHom \u03b1 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [892, 1], "end": [892, 67], "kind": "mathlibtacticlemma"}, {"full_name": "InfTopHom.ext", "code": "@[ext]\ntheorem ext {f g : InfTopHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [894, 1], "end": [896, 20], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.copy", "code": "protected def copy (f : InfTopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : InfTopHom \u03b1 \u03b2 :=\n  { f.toTopHom.copy f' h with toInfHom := f.toInfHom.copy f' h }", "start": [899, 1], "end": [902, 65], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : InfTopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [905, 1], "end": [907, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.copy_eq", "code": "theorem copy_eq (f : InfTopHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [910, 1], "end": [911, 17], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.id", "code": "@[simps]\nprotected def id : InfTopHom \u03b1 \u03b1 :=\n  \u27e8InfHom.id \u03b1, rfl\u27e9", "start": [916, 1], "end": [919, 21], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(InfTopHom.id \u03b1) = id", "start": [925, 1], "end": [927, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : InfTopHom.id \u03b1 a = a", "start": [932, 1], "end": [934, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.comp", "code": "def comp (f : InfTopHom \u03b2 \u03b3) (g : InfTopHom \u03b1 \u03b2) : InfTopHom \u03b1 \u03b3 :=\n  { f.toInfHom.comp g.toInfHom, f.toTopHom.comp g.toTopHom with }", "start": [937, 1], "end": [939, 66], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : InfTopHom \u03b2 \u03b3) (g : InfTopHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [942, 1], "end": [944, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : InfTopHom \u03b2 \u03b3) (g : InfTopHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [947, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : InfTopHom \u03b3 \u03b4) (g : InfTopHom \u03b2 \u03b3) (h : InfTopHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [952, 1], "end": [955, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.comp_id", "code": "@[simp] theorem comp_id (f : InfTopHom \u03b1 \u03b2) : f.comp (InfTopHom.id \u03b1) = f", "start": [958, 1], "end": [958, 81], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.id_comp", "code": "@[simp] theorem id_comp (f : InfTopHom \u03b1 \u03b2) : (InfTopHom.id \u03b2).comp f = f", "start": [961, 1], "end": [961, 81], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : InfTopHom \u03b2 \u03b3} {f : InfTopHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [964, 1], "end": [967, 84], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : InfTopHom \u03b2 \u03b3} {f\u2081 f\u2082 : InfTopHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [970, 1], "end": [973, 91], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_inf", "code": "@[simp]\ntheorem coe_inf (f g : InfTopHom \u03b1 \u03b2) : FunLike.coe (f \u2293 g) = f \u2293 g", "start": [990, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.coe_top", "code": "@[simp]\ntheorem coe_top : \u21d1(\u22a4 : InfTopHom \u03b1 \u03b2) = \u22a4", "start": [995, 1], "end": [997, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.inf_apply", "code": "@[simp]\ntheorem inf_apply (f g : InfTopHom \u03b1 \u03b2) (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a", "start": [1000, 1], "end": [1002, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.top_apply", "code": "@[simp]\ntheorem top_apply (a : \u03b1) : (\u22a4 : InfTopHom \u03b1 \u03b2) a = \u22a4", "start": [1005, 1], "end": [1007, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.toInfHom", "code": "def toInfHom (f : LatticeHom \u03b1 \u03b2) : InfHom \u03b1 \u03b2 :=\n  { f with }", "start": [1019, 1], "end": [1021, 13], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.toFun_eq_coe", "code": "lemma toFun_eq_coe (f : LatticeHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [1036, 1], "end": [1036, 61], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.coe_toSupHom", "code": "@[simp] lemma coe_toSupHom (f : LatticeHom \u03b1 \u03b2) : \u21d1f.toSupHom = f := rfl", "start": [1039, 1], "end": [1039, 73], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.coe_toInfHom", "code": "@[simp] lemma coe_toInfHom (f : LatticeHom \u03b1 \u03b2) : \u21d1f.toInfHom = f := rfl", "start": [1040, 1], "end": [1040, 73], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.coe_mk", "code": "@[simp] lemma coe_mk (f : SupHom \u03b1 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [1041, 1], "end": [1041, 67], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.ext", "code": "@[ext]\ntheorem ext {f g : LatticeHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [1043, 1], "end": [1045, 20], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.copy", "code": "protected def copy (f : LatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : LatticeHom \u03b1 \u03b2 :=\n  { f.toSupHom.copy f' h, f.toInfHom.copy f' h with }", "start": [1048, 1], "end": [1051, 54], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : LatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [1054, 1], "end": [1056, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.copy_eq", "code": "theorem copy_eq (f : LatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [1059, 1], "end": [1060, 17], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.id", "code": "protected def id : LatticeHom \u03b1 \u03b1 where\n  toFun := id\n  map_sup' _ _ := rfl\n  map_inf' _ _ := rfl", "start": [1065, 1], "end": [1069, 22], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(LatticeHom.id \u03b1) = id", "start": [1075, 1], "end": [1077, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : LatticeHom.id \u03b1 a = a", "start": [1082, 1], "end": [1084, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.comp", "code": "def comp (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) : LatticeHom \u03b1 \u03b3 :=\n  { f.toSupHom.comp g.toSupHom, f.toInfHom.comp g.toInfHom with }", "start": [1087, 1], "end": [1089, 66], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) : (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [1092, 1], "end": [1094, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [1097, 1], "end": [1099, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_comp_sup_hom'", "code": "@[simp]\ntheorem coe_comp_sup_hom' (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    \u27e8f \u2218 g, map_sup (f.comp g)\u27e9 = (f : SupHom \u03b2 \u03b3).comp g", "start": [1102, 1], "end": [1106, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_comp_sup_hom", "code": "theorem coe_comp_sup_hom (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    (f.comp g : SupHom \u03b1 \u03b3) = (f : SupHom \u03b2 \u03b3).comp g", "start": [1108, 1], "end": [1110, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_comp_inf_hom'", "code": "@[simp]\ntheorem coe_comp_inf_hom' (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    \u27e8f \u2218 g, map_inf (f.comp g)\u27e9 = (f : InfHom \u03b2 \u03b3).comp g", "start": [1113, 1], "end": [1117, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_comp_inf_hom", "code": "theorem coe_comp_inf_hom (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    (f.comp g : InfHom \u03b1 \u03b3) = (f : InfHom \u03b2 \u03b3).comp g", "start": [1119, 1], "end": [1121, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : LatticeHom \u03b3 \u03b4) (g : LatticeHom \u03b2 \u03b3) (h : LatticeHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [1124, 1], "end": [1127, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : LatticeHom \u03b1 \u03b2) : f.comp (LatticeHom.id \u03b1) = f", "start": [1130, 1], "end": [1132, 30], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : LatticeHom \u03b1 \u03b2) : (LatticeHom.id \u03b2).comp f = f", "start": [1135, 1], "end": [1137, 30], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : LatticeHom \u03b2 \u03b3} {f : LatticeHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1140, 1], "end": [1143, 95], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : LatticeHom \u03b2 \u03b3} {f\u2081 f\u2082 : LatticeHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1146, 1], "end": [1150, 17], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.toLatticeHomClass", "code": "instance (priority := 100) toLatticeHomClass : LatticeHomClass F \u03b1 \u03b2 :=\n  { \u2039OrderHomClass F \u03b1 \u03b2\u203a with\n    map_sup := fun f a b => by\n      obtain h | h := le_total a b\n      \u00b7 rw [sup_eq_right.2 h, sup_eq_right.2 (OrderHomClass.mono f h : f a \u2264 f b)]\n      \u00b7 rw [sup_eq_left.2 h, sup_eq_left.2 (OrderHomClass.mono f h : f b \u2264 f a)]\n    map_inf := fun f a b => by\n      obtain h | h := le_total a b\n      \u00b7 rw [inf_eq_left.2 h, inf_eq_left.2 (OrderHomClass.mono f h : f a \u2264 f b)]\n      \u00b7 rw [inf_eq_right.2 h, inf_eq_right.2 (OrderHomClass.mono f h : f b \u2264 f a)] }", "start": [1159, 1], "end": [1170, 85], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.toLatticeHom", "code": "def toLatticeHom (f : F) : LatticeHom \u03b1 \u03b2 := f", "start": [1173, 1], "end": [1174, 47], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.coe_to_lattice_hom", "code": "@[simp]\ntheorem coe_to_lattice_hom (f : F) : \u21d1(toLatticeHom \u03b1 \u03b2 f) = f", "start": [1177, 1], "end": [1179, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.to_lattice_hom_apply", "code": "@[simp]\ntheorem to_lattice_hom_apply (f : F) (a : \u03b1) : toLatticeHom \u03b1 \u03b2 f a = f a", "start": [1182, 1], "end": [1184, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.toSupBotHom", "code": "def toSupBotHom (f : BoundedLatticeHom \u03b1 \u03b2) : SupBotHom \u03b1 \u03b2 :=\n  { f with }", "start": [1197, 1], "end": [1199, 13], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.toInfTopHom", "code": "def toInfTopHom (f : BoundedLatticeHom \u03b1 \u03b2) : InfTopHom \u03b1 \u03b2 :=\n  { f with }", "start": [1202, 1], "end": [1204, 13], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.toBoundedOrderHom", "code": "def toBoundedOrderHom (f : BoundedLatticeHom \u03b1 \u03b2) : BoundedOrderHom \u03b1 \u03b2 :=\n  { f, (f.toLatticeHom : \u03b1 \u2192o \u03b2) with }", "start": [1207, 1], "end": [1209, 40], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.instBoundedLatticeHomClass", "code": "instance instBoundedLatticeHomClass : BoundedLatticeHomClass (BoundedLatticeHom \u03b1 \u03b2) \u03b1 \u03b2\n    where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9 := f; obtain \u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _\u27e9 := g; congr\n  map_sup f := f.map_sup'\n  map_inf f := f.map_inf'\n  map_top f := f.map_top'\n  map_bot f := f.map_bot'", "start": [1212, 1], "end": [1219, 26], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.toFun_eq_coe", "code": "@[simp] lemma toFun_eq_coe (f : BoundedLatticeHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [1221, 1], "end": [1221, 76], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.coe_toLatticeHom", "code": "@[simp] lemma coe_toLatticeHom (f : BoundedLatticeHom \u03b1 \u03b2) : \u21d1f.toLatticeHom = f := rfl", "start": [1224, 1], "end": [1224, 88], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.coe_toSupBotHom", "code": "@[simp] lemma coe_toSupBotHom (f : BoundedLatticeHom \u03b1 \u03b2) : \u21d1f.toSupBotHom = f := rfl", "start": [1225, 1], "end": [1225, 86], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.coe_toInfTopHom", "code": "@[simp] lemma coe_toInfTopHom (f : BoundedLatticeHom \u03b1 \u03b2) : \u21d1f.toInfTopHom = f := rfl", "start": [1226, 1], "end": [1226, 86], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.coe_toBoundedOrderHom", "code": "@[simp] lemma coe_toBoundedOrderHom (f : BoundedLatticeHom \u03b1 \u03b2) : \u21d1f.toBoundedOrderHom = f := rfl", "start": [1227, 1], "end": [1227, 98], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.coe_mk", "code": "@[simp] lemma coe_mk (f : LatticeHom \u03b1 \u03b2) (hf hf') : \u21d1(mk f hf hf') = f := rfl", "start": [1228, 1], "end": [1228, 79], "kind": "mathlibtacticlemma"}, {"full_name": "BoundedLatticeHom.ext", "code": "@[ext]\ntheorem ext {f g : BoundedLatticeHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [1230, 1], "end": [1232, 20], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.copy", "code": "protected def copy (f : BoundedLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : BoundedLatticeHom \u03b1 \u03b2 :=\n  { f.toLatticeHom.copy f' h, f.toBoundedOrderHom.copy f' h with }", "start": [1235, 1], "end": [1238, 67], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : BoundedLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [1241, 1], "end": [1243, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.copy_eq", "code": "theorem copy_eq (f : BoundedLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [1246, 1], "end": [1247, 17], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.id", "code": "protected def id : BoundedLatticeHom \u03b1 \u03b1 :=\n  { LatticeHom.id \u03b1, BoundedOrderHom.id \u03b1 with }", "start": [1252, 1], "end": [1254, 49], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(BoundedLatticeHom.id \u03b1) = id", "start": [1260, 1], "end": [1262, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : BoundedLatticeHom.id \u03b1 a = a", "start": [1267, 1], "end": [1269, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.comp", "code": "def comp (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) : BoundedLatticeHom \u03b1 \u03b3 :=\n  { f.toLatticeHom.comp g.toLatticeHom, f.toBoundedOrderHom.comp g.toBoundedOrderHom with }", "start": [1272, 1], "end": [1274, 92], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    (f.comp g : \u03b1 \u2192 \u03b3) = f \u2218 g", "start": [1277, 1], "end": [1280, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) (a : \u03b1) :\n    (f.comp g) a = f (g a)", "start": [1283, 1], "end": [1286, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_lattice_hom'", "code": "@[simp]\ntheorem coe_comp_lattice_hom' (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    (\u27e8(f : SupHom \u03b2 \u03b3).comp g, map_inf (f.comp g)\u27e9 : LatticeHom \u03b1 \u03b3) =\n      (f : LatticeHom \u03b2 \u03b3).comp g", "start": [1289, 1], "end": [1294, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_lattice_hom", "code": "theorem coe_comp_lattice_hom (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    (f.comp g : LatticeHom \u03b1 \u03b3) = (f : LatticeHom \u03b2 \u03b3).comp g", "start": [1296, 1], "end": [1298, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_sup_hom'", "code": "@[simp]\ntheorem coe_comp_sup_hom' (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    \u27e8f \u2218 g, map_sup (f.comp g)\u27e9 = (f : SupHom \u03b2 \u03b3).comp g", "start": [1301, 1], "end": [1305, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_sup_hom", "code": "theorem coe_comp_sup_hom (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    (f.comp g : SupHom \u03b1 \u03b3) = (f : SupHom \u03b2 \u03b3).comp g", "start": [1307, 1], "end": [1309, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_inf_hom'", "code": "@[simp]\ntheorem coe_comp_inf_hom' (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    \u27e8f \u2218 g, map_inf (f.comp g)\u27e9 = (f : InfHom \u03b2 \u03b3).comp g", "start": [1312, 1], "end": [1316, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.coe_comp_inf_hom", "code": "theorem coe_comp_inf_hom (f : BoundedLatticeHom \u03b2 \u03b3) (g : BoundedLatticeHom \u03b1 \u03b2) :\n    (f.comp g : InfHom \u03b1 \u03b3) = (f : InfHom \u03b2 \u03b3).comp g", "start": [1318, 1], "end": [1320, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : BoundedLatticeHom \u03b3 \u03b4) (g : BoundedLatticeHom \u03b2 \u03b3)\n    (h : BoundedLatticeHom \u03b1 \u03b2) : (f.comp g).comp h = f.comp (g.comp h)", "start": [1323, 1], "end": [1326, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.comp_id", "code": "@[simp] theorem comp_id (f : BoundedLatticeHom \u03b1 \u03b2) : f.comp (BoundedLatticeHom.id \u03b1) = f", "start": [1329, 1], "end": [1329, 97], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.id_comp", "code": "@[simp] theorem id_comp (f : BoundedLatticeHom \u03b1 \u03b2) : (BoundedLatticeHom.id \u03b2).comp f = f", "start": [1332, 1], "end": [1332, 97], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : BoundedLatticeHom \u03b2 \u03b3} {f : BoundedLatticeHom \u03b1 \u03b2}\n    (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1335, 1], "end": [1339, 33], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : BoundedLatticeHom \u03b2 \u03b3} {f\u2081 f\u2082 : BoundedLatticeHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1342, 1], "end": [1345, 81], "kind": "commanddeclaration"}, {"full_name": "SupHom.dual", "code": "@[simps]\nprotected def dual : SupHom \u03b1 \u03b2 \u2243 InfHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8f, f.map_sup'\u27e9\n  invFun f := \u27e8f, f.map_inf'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1356, 1], "end": [1362, 21], "kind": "commanddeclaration"}, {"full_name": "SupHom.dual_id", "code": "@[simp]\ntheorem dual_id : SupHom.dual (SupHom.id \u03b1) = InfHom.id _", "start": [1365, 1], "end": [1367, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : SupHom \u03b2 \u03b3) (f : SupHom \u03b1 \u03b2) :\n    SupHom.dual (g.comp f) = (SupHom.dual g).comp (SupHom.dual f)", "start": [1370, 1], "end": [1373, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : SupHom.dual.symm (InfHom.id _) = SupHom.id \u03b1", "start": [1376, 1], "end": [1378, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : InfHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : InfHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    SupHom.dual.symm (g.comp f) =\n      (SupHom.dual.symm g).comp (SupHom.dual.symm f)", "start": [1381, 1], "end": [1385, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.dual", "code": "@[simps]\nprotected def dual : InfHom \u03b1 \u03b2 \u2243 SupHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8f, f.map_inf'\u27e9\n  invFun f := \u27e8f, f.map_sup'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1394, 1], "end": [1400, 21], "kind": "commanddeclaration"}, {"full_name": "InfHom.dual_id", "code": "@[simp]\ntheorem dual_id : InfHom.dual (InfHom.id \u03b1) = SupHom.id _", "start": [1403, 1], "end": [1405, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : InfHom \u03b2 \u03b3) (f : InfHom \u03b1 \u03b2) :\n    InfHom.dual (g.comp f) = (InfHom.dual g).comp (InfHom.dual f)", "start": [1408, 1], "end": [1411, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : InfHom.dual.symm (SupHom.id _) = InfHom.id \u03b1", "start": [1414, 1], "end": [1416, 6], "kind": "commanddeclaration"}, {"full_name": "InfHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : SupHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : SupHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    InfHom.dual.symm (g.comp f) =\n      (InfHom.dual.symm g).comp (InfHom.dual.symm f)", "start": [1419, 1], "end": [1423, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.dual", "code": "def dual : SupBotHom \u03b1 \u03b2 \u2243 InfTopHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8SupHom.dual f.toSupHom, f.map_bot'\u27e9\n  invFun f := \u27e8SupHom.dual.symm f.toInfHom, f.map_top'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1432, 1], "end": [1438, 21], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.dual_id", "code": "@[simp] theorem dual_id : SupBotHom.dual (SupBotHom.id \u03b1) = InfTopHom.id _", "start": [1441, 1], "end": [1441, 82], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : SupBotHom \u03b2 \u03b3) (f : SupBotHom \u03b1 \u03b2) :\n    SupBotHom.dual (g.comp f) = (SupBotHom.dual g).comp (SupBotHom.dual f)", "start": [1444, 1], "end": [1447, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : SupBotHom.dual.symm (InfTopHom.id _) = SupBotHom.id \u03b1", "start": [1450, 1], "end": [1452, 6], "kind": "commanddeclaration"}, {"full_name": "SupBotHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : InfTopHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : InfTopHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    SupBotHom.dual.symm (g.comp f) =\n      (SupBotHom.dual.symm g).comp (SupBotHom.dual.symm f)", "start": [1455, 1], "end": [1459, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.dual", "code": "@[simps]\nprotected def dual : InfTopHom \u03b1 \u03b2 \u2243 SupBotHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48\n    where\n  toFun f := \u27e8InfHom.dual f.toInfHom, f.map_top'\u27e9\n  invFun f := \u27e8InfHom.dual.symm f.toSupHom, f.map_bot'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1468, 1], "end": [1476, 21], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.dual_id", "code": "@[simp]\ntheorem dual_id : InfTopHom.dual (InfTopHom.id \u03b1) = SupBotHom.id _", "start": [1479, 1], "end": [1481, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : InfTopHom \u03b2 \u03b3) (f : InfTopHom \u03b1 \u03b2) :\n    InfTopHom.dual (g.comp f) = (InfTopHom.dual g).comp (InfTopHom.dual f)", "start": [1484, 1], "end": [1487, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : InfTopHom.dual.symm (SupBotHom.id _) = InfTopHom.id \u03b1", "start": [1490, 1], "end": [1492, 6], "kind": "commanddeclaration"}, {"full_name": "InfTopHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : SupBotHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : SupBotHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    InfTopHom.dual.symm (g.comp f) =\n      (InfTopHom.dual.symm g).comp (InfTopHom.dual.symm f)", "start": [1495, 1], "end": [1499, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.dual", "code": "@[simps]\nprotected def dual : LatticeHom \u03b1 \u03b2 \u2243 LatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8InfHom.dual f.toInfHom, f.map_sup'\u27e9\n  invFun f := \u27e8SupHom.dual.symm f.toInfHom, f.map_sup'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1508, 1], "end": [1514, 21], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.dual_id", "code": "@[simp] theorem dual_id : LatticeHom.dual (LatticeHom.id \u03b1) = LatticeHom.id _", "start": [1517, 1], "end": [1517, 85], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : LatticeHom \u03b2 \u03b3) (f : LatticeHom \u03b1 \u03b2) :\n    LatticeHom.dual (g.comp f) = (LatticeHom.dual g).comp (LatticeHom.dual f)", "start": [1520, 1], "end": [1523, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : LatticeHom.dual.symm (LatticeHom.id _) = LatticeHom.id \u03b1", "start": [1526, 1], "end": [1528, 6], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : LatticeHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : LatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    LatticeHom.dual.symm (g.comp f) =\n      (LatticeHom.dual.symm g).comp (LatticeHom.dual.symm f)", "start": [1531, 1], "end": [1535, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.dual", "code": "@[simps]\nprotected def dual : BoundedLatticeHom \u03b1 \u03b2 \u2243 BoundedLatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 where\n  toFun f := \u27e8LatticeHom.dual f.toLatticeHom, f.map_bot', f.map_top'\u27e9\n  invFun f := \u27e8LatticeHom.dual.symm f.toLatticeHom, f.map_bot', f.map_top'\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [1544, 1], "end": [1551, 21], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.dual_id", "code": "@[simp]\ntheorem dual_id : BoundedLatticeHom.dual (BoundedLatticeHom.id \u03b1) = BoundedLatticeHom.id _", "start": [1554, 1], "end": [1556, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : BoundedLatticeHom \u03b2 \u03b3) (f : BoundedLatticeHom \u03b1 \u03b2) :\n    BoundedLatticeHom.dual (g.comp f) =\n      (BoundedLatticeHom.dual g).comp (BoundedLatticeHom.dual f)", "start": [1559, 1], "end": [1563, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id :\n    BoundedLatticeHom.dual.symm (BoundedLatticeHom.id _) = BoundedLatticeHom.id \u03b1", "start": [1566, 1], "end": [1569, 6], "kind": "commanddeclaration"}, {"full_name": "BoundedLatticeHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : BoundedLatticeHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : BoundedLatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    BoundedLatticeHom.dual.symm (g.comp f) =\n      (BoundedLatticeHom.dual.symm g).comp (BoundedLatticeHom.dual.symm f)", "start": [1572, 1], "end": [1576, 6], "kind": "commanddeclaration"}, {"full_name": "SupHom.withTop", "code": "@[simps]\nprotected def withTop (f : SupHom \u03b1 \u03b2) : SupHom (WithTop \u03b1) (WithTop \u03b2) where\n  toFun := WithTop.map f\n  map_sup' a b :=\n    match a, b with\n    | \u22a4, \u22a4 => rfl\n    | \u22a4, (b : \u03b1) => rfl\n    | (a : \u03b1), \u22a4 => rfl\n    | (a : \u03b1), (b : \u03b1) => congr_arg _ (f.map_sup' _ _)", "start": [1586, 1], "end": [1596, 55], "kind": "commanddeclaration"}, {"full_name": "SupHom.withTop_id", "code": "@[simp]\ntheorem withTop_id : (SupHom.id \u03b1).withTop = SupHom.id _", "start": [1599, 1], "end": [1600, 96], "kind": "commanddeclaration"}, {"full_name": "SupHom.withTop_comp", "code": "@[simp]\ntheorem withTop_comp (f : SupHom \u03b2 \u03b3) (g : SupHom \u03b1 \u03b2) :\n    (f.comp g).withTop = f.withTop.comp g.withTop", "start": [1603, 1], "end": [1607, 62], "kind": "commanddeclaration"}, {"full_name": "SupHom.withBot", "code": "@[simps]\nprotected def withBot (f : SupHom \u03b1 \u03b2) : SupBotHom (WithBot \u03b1) (WithBot \u03b2) where\n  toFun := Option.map f\n  map_sup' a b :=\n    match a, b with\n    | \u22a5, \u22a5 => rfl\n    | \u22a5, (b : \u03b1) => rfl\n    | (a : \u03b1), \u22a5 => rfl\n    | (a : \u03b1), (b : \u03b1) => congr_arg _ (f.map_sup' _ _)\n  map_bot' := rfl", "start": [1610, 1], "end": [1620, 18], "kind": "commanddeclaration"}, {"full_name": "SupHom.withBot_id", "code": "@[simp]\ntheorem withBot_id : (SupHom.id \u03b1).withBot = SupBotHom.id _", "start": [1623, 1], "end": [1624, 99], "kind": "commanddeclaration"}, {"full_name": "SupHom.withBot_comp", "code": "@[simp]\ntheorem withBot_comp (f : SupHom \u03b2 \u03b3) (g : SupHom \u03b1 \u03b2) :\n    (f.comp g).withBot = f.withBot.comp g.withBot", "start": [1627, 1], "end": [1631, 62], "kind": "commanddeclaration"}, {"full_name": "SupHom.withTop'", "code": "@[simps]\ndef withTop' [OrderTop \u03b2] (f : SupHom \u03b1 \u03b2) : SupHom (WithTop \u03b1) \u03b2 where\n  toFun a := a.elim \u22a4 f\n  map_sup' a b :=\n    match a, b with\n    | \u22a4, \u22a4 => top_sup_eq.symm\n    | \u22a4, (b : \u03b1) => top_sup_eq.symm\n    | (a : \u03b1), \u22a4 => sup_top_eq.symm\n    | (a : \u03b1), (b : \u03b1) => f.map_sup' _ _", "start": [1634, 1], "end": [1643, 41], "kind": "commanddeclaration"}, {"full_name": "SupHom.withBot'", "code": "@[simps]\ndef withBot' [OrderBot \u03b2] (f : SupHom \u03b1 \u03b2) : SupBotHom (WithBot \u03b1) \u03b2 where\n  toFun a := a.elim \u22a5 f\n  map_sup' a b :=\n    match a, b with\n    | \u22a5, \u22a5 => bot_sup_eq.symm\n    | \u22a5, (b : \u03b1) => bot_sup_eq.symm\n    | (a : \u03b1), \u22a5 => sup_bot_eq.symm\n    | (a : \u03b1), (b : \u03b1) => f.map_sup' _ _\n  map_bot' := rfl", "start": [1646, 1], "end": [1656, 18], "kind": "commanddeclaration"}, {"full_name": "InfHom.withTop", "code": "@[simps]\nprotected def withTop (f : InfHom \u03b1 \u03b2) : InfTopHom (WithTop \u03b1) (WithTop \u03b2) where\n  toFun := Option.map f\n  map_inf' a b :=\n    match a, b with\n    | \u22a4, \u22a4 => rfl\n    | \u22a4, (b : \u03b1) => rfl\n    | (a : \u03b1), \u22a4 => rfl\n    | (a : \u03b1), (b : \u03b1) => congr_arg _ (f.map_inf' _ _)\n  map_top' := rfl", "start": [1665, 1], "end": [1675, 18], "kind": "commanddeclaration"}, {"full_name": "InfHom.withTop_id", "code": "@[simp]\ntheorem withTop_id : (InfHom.id \u03b1).withTop = InfTopHom.id _", "start": [1678, 1], "end": [1679, 99], "kind": "commanddeclaration"}, {"full_name": "InfHom.withTop_comp", "code": "@[simp]\ntheorem withTop_comp (f : InfHom \u03b2 \u03b3) (g : InfHom \u03b1 \u03b2) :\n    (f.comp g).withTop = f.withTop.comp g.withTop", "start": [1682, 1], "end": [1686, 62], "kind": "commanddeclaration"}, {"full_name": "InfHom.withBot", "code": "@[simps]\nprotected def withBot (f : InfHom \u03b1 \u03b2) : InfHom (WithBot \u03b1) (WithBot \u03b2) where\n  toFun := Option.map f\n  map_inf' a b :=\n    match a, b with\n    | \u22a5, \u22a5 => rfl\n    | \u22a5, (b : \u03b1) => rfl\n    | (a : \u03b1), \u22a5 => rfl\n    | (a : \u03b1), (b : \u03b1) => congr_arg _ (f.map_inf' _ _)", "start": [1689, 1], "end": [1698, 55], "kind": "commanddeclaration"}, {"full_name": "InfHom.withBot_id", "code": "@[simp]\ntheorem withBot_id : (InfHom.id \u03b1).withBot = InfHom.id _", "start": [1701, 1], "end": [1702, 96], "kind": "commanddeclaration"}, {"full_name": "InfHom.withBot_comp", "code": "@[simp]\ntheorem withBot_comp (f : InfHom \u03b2 \u03b3) (g : InfHom \u03b1 \u03b2) :\n    (f.comp g).withBot = f.withBot.comp g.withBot", "start": [1705, 1], "end": [1709, 62], "kind": "commanddeclaration"}, {"full_name": "InfHom.withTop'", "code": "@[simps]\ndef withTop' [OrderTop \u03b2] (f : InfHom \u03b1 \u03b2) : InfTopHom (WithTop \u03b1) \u03b2 where\n  toFun a := a.elim \u22a4 f\n  map_inf' a b :=\n    match a, b with\n    | \u22a4, \u22a4 => top_inf_eq.symm\n    | \u22a4, (b : \u03b1) => top_inf_eq.symm\n    | (a : \u03b1), \u22a4 => inf_top_eq.symm\n    | (a : \u03b1), (b : \u03b1) => f.map_inf' _ _\n  map_top' := rfl", "start": [1712, 1], "end": [1722, 18], "kind": "commanddeclaration"}, {"full_name": "InfHom.withBot'", "code": "@[simps]\ndef withBot' [OrderBot \u03b2] (f : InfHom \u03b1 \u03b2) : InfHom (WithBot \u03b1) \u03b2 where\n  toFun a := a.elim \u22a5 f\n  map_inf' a b :=\n    match a, b with\n    | \u22a5, \u22a5 => bot_inf_eq.symm\n    | \u22a5, (b : \u03b1) => bot_inf_eq.symm\n    | (a : \u03b1), \u22a5 => inf_bot_eq.symm\n    | (a : \u03b1), (b : \u03b1) => f.map_inf' _ _", "start": [1725, 1], "end": [1734, 41], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTop", "code": "@[simps]\nprotected def withTop (f : LatticeHom \u03b1 \u03b2) : LatticeHom (WithTop \u03b1) (WithTop \u03b2) :=\n  { f.toInfHom.withTop with toSupHom := f.toSupHom.withTop }", "start": [1743, 1], "end": [1746, 61], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_withTop", "code": "@[simp, norm_cast]\nlemma coe_withTop (f : LatticeHom \u03b1 \u03b2) : \u21d1f.withTop = WithTop.map f := rfl", "start": [1750, 1], "end": [1751, 75], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withTop_apply", "code": "lemma withTop_apply (f : LatticeHom \u03b1 \u03b2) (a : WithTop \u03b1) : f.withTop a = a.map f := rfl", "start": [1753, 1], "end": [1753, 88], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withTop_id", "code": "@[simp]\ntheorem withTop_id : (LatticeHom.id \u03b1).withTop = LatticeHom.id _", "start": [1755, 1], "end": [1757, 38], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTop_comp", "code": "@[simp]\ntheorem withTop_comp (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    (f.comp g).withTop = f.withTop.comp g.withTop", "start": [1760, 1], "end": [1764, 62], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withBot", "code": "@[simps]\nprotected def withBot (f : LatticeHom \u03b1 \u03b2) : LatticeHom (WithBot \u03b1) (WithBot \u03b2) :=\n  { f.toInfHom.withBot with toSupHom := f.toSupHom.withBot }", "start": [1767, 1], "end": [1770, 61], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_withBot", "code": "@[simp, norm_cast]\nlemma coe_withBot (f : LatticeHom \u03b1 \u03b2) : \u21d1f.withBot = Option.map f := rfl", "start": [1774, 1], "end": [1775, 74], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withBot_apply", "code": "lemma withBot_apply (f : LatticeHom \u03b1 \u03b2) (a : WithBot \u03b1) : f.withBot a = a.map f := rfl", "start": [1777, 1], "end": [1777, 88], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withBot_id", "code": "@[simp]\ntheorem withBot_id : (LatticeHom.id \u03b1).withBot = LatticeHom.id _", "start": [1779, 1], "end": [1781, 38], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withBot_comp", "code": "@[simp]\ntheorem withBot_comp (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    (f.comp g).withBot = f.withBot.comp g.withBot", "start": [1784, 1], "end": [1788, 62], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTopWithBot", "code": "@[simps]\ndef withTopWithBot (f : LatticeHom \u03b1 \u03b2) :\n    BoundedLatticeHom (WithTop <| WithBot \u03b1) (WithTop <| WithBot \u03b2) :=\n  \u27e8f.withBot.withTop, rfl, rfl\u27e9", "start": [1791, 1], "end": [1795, 32], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.coe_withTopWithBot", "code": "@[simp, norm_cast]\nlemma coe_withTopWithBot (f : LatticeHom \u03b1 \u03b2) : \u21d1f.withTopWithBot = Option.map (Option.map f) := rfl", "start": [1799, 1], "end": [1800, 101], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withTopWithBot_apply", "code": "lemma withTopWithBot_apply (f : LatticeHom \u03b1 \u03b2) (a : WithTop <| WithBot \u03b1) :\n    f.withTopWithBot a = a.map (Option.map f) := rfl", "start": [1802, 1], "end": [1803, 53], "kind": "mathlibtacticlemma"}, {"full_name": "LatticeHom.withTopWithBot_id", "code": "@[simp]\ntheorem withTopWithBot_id : (LatticeHom.id \u03b1).withTopWithBot = BoundedLatticeHom.id _", "start": [1805, 1], "end": [1810, 8], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTopWithBot_comp", "code": "@[simp]\ntheorem withTopWithBot_comp (f : LatticeHom \u03b2 \u03b3) (g : LatticeHom \u03b1 \u03b2) :\n    (f.comp g).withTopWithBot = f.withTopWithBot.comp g.withTopWithBot", "start": [1813, 1], "end": [1816, 12], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTop'", "code": "@[simps]\ndef withTop' [OrderTop \u03b2] (f : LatticeHom \u03b1 \u03b2) : LatticeHom (WithTop \u03b1) \u03b2 :=\n  { f.toSupHom.withTop', f.toInfHom.withTop' with }", "start": [1819, 1], "end": [1822, 52], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withBot'", "code": "@[simps]\ndef withBot' [OrderBot \u03b2] (f : LatticeHom \u03b1 \u03b2) : LatticeHom (WithBot \u03b1) \u03b2 :=\n  { f.toSupHom.withBot', f.toInfHom.withBot' with }", "start": [1825, 1], "end": [1828, 52], "kind": "commanddeclaration"}, {"full_name": "LatticeHom.withTopWithBot'", "code": "@[simps]\ndef withTopWithBot' [BoundedOrder \u03b2] (f : LatticeHom \u03b1 \u03b2) :\n    BoundedLatticeHom (WithTop $ WithBot \u03b1) \u03b2 where\n  toLatticeHom := f.withBot'.withTop'\n  map_top' := rfl\n  map_bot' := rfl", "start": [1831, 1], "end": [1837, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Pi.lean", "imports": ["Mathlib/Data/Finset/Image.lean", "Mathlib/Data/Multiset/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Pi.empty", "code": "def Pi.empty (\u03b2 : \u03b1 \u2192 Sort*) (a : \u03b1) (h : a \u2208 (\u2205 : Finset \u03b1)) : \u03b2 a :=\n  Multiset.Pi.empty \u03b2 a h", "start": [27, 1], "end": [30, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.pi", "code": "def pi (s : Finset \u03b1) (t : \u2200 a, Finset (\u03b2 a)) : Finset (\u2200 a \u2208 s, \u03b2 a) :=\n  \u27e8s.1.pi fun a => (t a).1, s.nodup.pi fun a _ => (t a).nodup\u27e9", "start": [36, 1], "end": [40, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_val", "code": "@[simp]\ntheorem pi_val (s : Finset \u03b1) (t : \u2200 a, Finset (\u03b2 a)) : (s.pi t).1 = s.1.pi fun a => (t a).1", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_pi", "code": "@[simp]\ntheorem mem_pi {s : Finset \u03b1} {t : \u2200 a, Finset (\u03b2 a)} {f : \u2200 a \u2208 s, \u03b2 a} :\n    f \u2208 s.pi t \u2194 \u2200 (a) (h : a \u2208 s), f a h \u2208 t a", "start": [48, 1], "end": [51, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Pi.cons", "code": "def Pi.cons (s : Finset \u03b1) (a : \u03b1) (b : \u03b4 a) (f : \u2200 a, a \u2208 s \u2192 \u03b4 a) (a' : \u03b1) (h : a' \u2208 insert a s) :\n    \u03b4 a' :=\n  Multiset.Pi.cons s.1 a b f _ (Multiset.mem_cons.2 <| mem_insert.symm.2 h)", "start": [54, 1], "end": [60, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.Pi.cons_same", "code": "@[simp]\ntheorem Pi.cons_same (s : Finset \u03b1) (a : \u03b1) (b : \u03b4 a) (f : \u2200 a, a \u2208 s \u2192 \u03b4 a) (h : a \u2208 insert a s) :\n    Pi.cons s a b f a h = b", "start": [63, 1], "end": [66, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Pi.cons_ne", "code": "theorem Pi.cons_ne {s : Finset \u03b1} {a a' : \u03b1} {b : \u03b4 a} {f : \u2200 a, a \u2208 s \u2192 \u03b4 a} {h : a' \u2208 insert a s}\n    (ha : a \u2260 a') : Pi.cons s a b f a' h = f a' ((mem_insert.1 h).resolve_left ha.symm)", "start": [69, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.Pi.cons_injective", "code": "theorem Pi.cons_injective {a : \u03b1} {b : \u03b4 a} {s : Finset \u03b1} (hs : a \u2209 s) :\n    Function.Injective (Pi.cons s a b)", "start": [74, 1], "end": [83, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_empty", "code": "@[simp]\ntheorem pi_empty {t : \u2200 a : \u03b1, Finset (\u03b2 a)} : pi (\u2205 : Finset \u03b1) t = singleton (Pi.empty \u03b2)", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_insert", "code": "@[simp]\ntheorem pi_insert [\u2200 a, DecidableEq (\u03b2 a)] {s : Finset \u03b1} {t : \u2200 a : \u03b1, Finset (\u03b2 a)} {a : \u03b1}\n    (ha : a \u2209 s) : pi (insert a s) t = (t a).biUnion fun b => (pi s t).image (Pi.cons s a b)", "start": [91, 1], "end": [108, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_singletons", "code": "theorem pi_singletons {\u03b2 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (s.pi fun a => ({f a} : Finset \u03b2)) = {fun a _ => f a}", "start": [111, 1], "end": [119, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_const_singleton", "code": "theorem pi_const_singleton {\u03b2 : Type*} (s : Finset \u03b1) (i : \u03b2) :\n    (s.pi fun _ => ({i} : Finset \u03b2)) = {fun _ _ => i}", "start": [122, 1], "end": [124, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_subset", "code": "theorem pi_subset {s : Finset \u03b1} (t\u2081 t\u2082 : \u2200 a, Finset (\u03b2 a)) (h : \u2200 a \u2208 s, t\u2081 a \u2286 t\u2082 a) :\n    s.pi t\u2081 \u2286 s.pi t\u2082", "start": [127, 1], "end": [128, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.pi_disjoint_of_disjoint", "code": "theorem pi_disjoint_of_disjoint {\u03b4 : \u03b1 \u2192 Type*} {s : Finset \u03b1} (t\u2081 t\u2082 : \u2200 a, Finset (\u03b4 a)) {a : \u03b1}\n    (ha : a \u2208 s) (h : Disjoint (t\u2081 a) (t\u2082 a)) : Disjoint (s.pi t\u2081) (s.pi t\u2082)", "start": [131, 1], "end": [135, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Prod.lean", "imports": ["Mathlib/Data/Finset/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.product", "code": "protected def product (s : Finset \u03b1) (t : Finset \u03b2) : Finset (\u03b1 \u00d7 \u03b2) :=\n  \u27e8_, s.nodup.product t.nodup\u27e9", "start": [39, 1], "end": [41, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.instSProd", "code": "instance instSProd : SProd (Finset \u03b1) (Finset \u03b2) (Finset (\u03b1 \u00d7 \u03b2)) where\n  sprod := Finset.product", "start": [44, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.product_val", "code": "@[simp]\ntheorem product_val : (s \u00d7\u02e2 t).1 = s.1 \u00d7\u02e2 t.1", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_product", "code": "@[simp]\ntheorem mem_product {p : \u03b1 \u00d7 \u03b2} : p \u2208 s \u00d7\u02e2 t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [52, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.mk_mem_product", "code": "theorem mk_mem_product (ha : a \u2208 s) (hb : b \u2208 t) : (a, b) \u2208 s \u00d7\u02e2 t", "start": [57, 1], "end": [58, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_product", "code": "@[simp, norm_cast]\ntheorem coe_product (s : Finset \u03b1) (t : Finset \u03b2) :\n    (\u2191(s \u00d7\u02e2 t) : Set (\u03b1 \u00d7 \u03b2)) = (s : Set \u03b1) \u00d7\u02e2 t", "start": [61, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_product_image_fst", "code": "theorem subset_product_image_fst [DecidableEq \u03b1] : (s \u00d7\u02e2 t).image Prod.fst \u2286 s", "start": [67, 1], "end": [68, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_product_image_snd", "code": "theorem subset_product_image_snd [DecidableEq \u03b2] : (s \u00d7\u02e2 t).image Prod.snd \u2286 t", "start": [71, 1], "end": [72, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.product_image_fst", "code": "theorem product_image_fst [DecidableEq \u03b1] (ht : t.Nonempty) : (s \u00d7\u02e2 t).image Prod.fst = s", "start": [75, 1], "end": [77, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.product_image_snd", "code": "theorem product_image_snd [DecidableEq \u03b2] (ht : s.Nonempty) : (s \u00d7\u02e2 t).image Prod.snd = t", "start": [80, 1], "end": [82, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_product", "code": "theorem subset_product [DecidableEq \u03b1] [DecidableEq \u03b2] {s : Finset (\u03b1 \u00d7 \u03b2)} :\n    s \u2286 s.image Prod.fst \u00d7\u02e2 s.image Prod.snd", "start": [85, 1], "end": [87, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.product_subset_product", "code": "theorem product_subset_product (hs : s \u2286 s') (ht : t \u2286 t') : s \u00d7\u02e2 t \u2286 s' \u00d7\u02e2 t'", "start": [90, 1], "end": [91, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.product_subset_product_left", "code": "theorem product_subset_product_left (hs : s \u2286 s') : s \u00d7\u02e2 t \u2286 s' \u00d7\u02e2 t", "start": [94, 1], "end": [95, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.product_subset_product_right", "code": "theorem product_subset_product_right (ht : t \u2286 t') : s \u00d7\u02e2 t \u2286 s \u00d7\u02e2 t'", "start": [98, 1], "end": [99, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.map_swap_product", "code": "theorem map_swap_product (s : Finset \u03b1) (t : Finset \u03b2) :\n    (t \u00d7\u02e2 s).map \u27e8Prod.swap, Prod.swap_injective\u27e9 = s \u00d7\u02e2 t", "start": [102, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.image_swap_product", "code": "@[simp]\ntheorem image_swap_product [DecidableEq (\u03b1 \u00d7 \u03b2)] (s : Finset \u03b1) (t : Finset \u03b2) :\n    (t \u00d7\u02e2 s).image Prod.swap = s \u00d7\u02e2 t", "start": [109, 1], "end": [114, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.product_eq_biUnion", "code": "theorem product_eq_biUnion [DecidableEq (\u03b1 \u00d7 \u03b2)] (s : Finset \u03b1) (t : Finset \u03b2) :\n    s \u00d7\u02e2 t = s.biUnion fun a => t.image fun b => (a, b)", "start": [117, 1], "end": [121, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.product_eq_biUnion_right", "code": "theorem product_eq_biUnion_right [DecidableEq (\u03b1 \u00d7 \u03b2)] (s : Finset \u03b1) (t : Finset \u03b2) :\n    s \u00d7\u02e2 t = t.biUnion fun b => s.image fun a => (a, b)", "start": [124, 1], "end": [128, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.product_biUnion", "code": "@[simp]\ntheorem product_biUnion [DecidableEq \u03b3] (s : Finset \u03b1) (t : Finset \u03b2) (f : \u03b1 \u00d7 \u03b2 \u2192 Finset \u03b3) :\n    (s \u00d7\u02e2 t).biUnion f = s.biUnion fun a => t.biUnion fun b => f (a, b)", "start": [131, 1], "end": [135, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.card_product", "code": "@[simp]\ntheorem card_product (s : Finset \u03b1) (t : Finset \u03b2) : card (s \u00d7\u02e2 t) = card s * card t", "start": [138, 1], "end": [140, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.nontrivial_prod_iff", "code": "lemma nontrivial_prod_iff : Nontrivial (s \u00d7\u02e2 t) \u2194\n    s.Nonempty \u2227 t.Nonempty \u2227 (Nontrivial s \u2228 Nontrivial t) := by\n  simp_rw [\u2190 card_pos, \u2190 one_lt_card_iff_nontrivial_coe, card_product]; apply Nat.one_lt_mul_iff", "start": [143, 1], "end": [147, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.filter_product", "code": "theorem filter_product (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop) [DecidablePred p] [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => p x.1 \u2227 q x.2) = s.filter p \u00d7\u02e2 t.filter q", "start": [149, 1], "end": [152, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_product_left", "code": "theorem filter_product_left (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => p x.1) = s.filter p \u00d7\u02e2 t", "start": [155, 1], "end": [157, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_product_right", "code": "theorem filter_product_right (q : \u03b2 \u2192 Prop) [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => q x.2) = s \u00d7\u02e2 t.filter q", "start": [160, 1], "end": [162, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_product_card", "code": "theorem filter_product_card (s : Finset \u03b1) (t : Finset \u03b2) (p : \u03b1 \u2192 Prop) (q : \u03b2 \u2192 Prop)\n    [DecidablePred p] [DecidablePred q] :\n    ((s \u00d7\u02e2 t).filter fun x : \u03b1 \u00d7 \u03b2 => (p x.1) = (q x.2)).card =\n      (s.filter p).card * (t.filter q).card +\n        (s.filter (\u00ac p \u00b7)).card * (t.filter (\u00ac q \u00b7)).card", "start": [165, 1], "end": [181, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_product", "code": "theorem empty_product (t : Finset \u03b2) : (\u2205 : Finset \u03b1) \u00d7\u02e2 t = \u2205", "start": [184, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.product_empty", "code": "theorem product_empty (s : Finset \u03b1) : s \u00d7\u02e2 (\u2205 : Finset \u03b2) = \u2205", "start": [188, 1], "end": [189, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.product", "code": "theorem Nonempty.product (hs : s.Nonempty) (ht : t.Nonempty) : (s \u00d7\u02e2 t).Nonempty", "start": [192, 1], "end": [195, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.fst", "code": "theorem Nonempty.fst (h : (s \u00d7\u02e2 t).Nonempty) : s.Nonempty", "start": [198, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.snd", "code": "theorem Nonempty.snd (h : (s \u00d7\u02e2 t).Nonempty) : t.Nonempty", "start": [203, 1], "end": [205, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_product", "code": "@[simp]\ntheorem nonempty_product : (s \u00d7\u02e2 t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [208, 1], "end": [210, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.product_eq_empty", "code": "@[simp]\ntheorem product_eq_empty {s : Finset \u03b1} {t : Finset \u03b2} : s \u00d7\u02e2 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [213, 1], "end": [216, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_product", "code": "@[simp]\ntheorem singleton_product {a : \u03b1} :\n    ({a} : Finset \u03b1) \u00d7\u02e2 t = t.map \u27e8Prod.mk a, Prod.mk.inj_left _\u27e9", "start": [219, 1], "end": [223, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.product_singleton", "code": "@[simp]\ntheorem product_singleton {b : \u03b2} : s \u00d7\u02e2 {b} = s.map \u27e8fun i => (i, b), Prod.mk.inj_right _\u27e9", "start": [226, 1], "end": [229, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_product_singleton", "code": "theorem singleton_product_singleton {a : \u03b1} {b : \u03b2} :\n    ({a} \u00d7\u02e2 {b} : Finset _) = {(a, b)}", "start": [232, 1], "end": [234, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.union_product", "code": "@[simp]\ntheorem union_product [DecidableEq \u03b1] [DecidableEq \u03b2] : (s \u222a s') \u00d7\u02e2 t = s \u00d7\u02e2 t \u222a s' \u00d7\u02e2 t", "start": [237, 1], "end": [240, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.product_union", "code": "@[simp]\ntheorem product_union [DecidableEq \u03b1] [DecidableEq \u03b2] : s \u00d7\u02e2 (t \u222a t') = s \u00d7\u02e2 t \u222a s \u00d7\u02e2 t'", "start": [243, 1], "end": [246, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_product", "code": "theorem inter_product [DecidableEq \u03b1] [DecidableEq \u03b2] : (s \u2229 s') \u00d7\u02e2 t = s \u00d7\u02e2 t \u2229 s' \u00d7\u02e2 t", "start": [249, 1], "end": [251, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.product_inter", "code": "theorem product_inter [DecidableEq \u03b1] [DecidableEq \u03b2] : s \u00d7\u02e2 (t \u2229 t') = s \u00d7\u02e2 t \u2229 s \u00d7\u02e2 t'", "start": [254, 1], "end": [256, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.product_inter_product", "code": "theorem product_inter_product [DecidableEq \u03b1] [DecidableEq \u03b2] :\n    s \u00d7\u02e2 t \u2229 s' \u00d7\u02e2 t' = (s \u2229 s') \u00d7\u02e2 (t \u2229 t')", "start": [259, 1], "end": [262, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_product", "code": "theorem disjoint_product : Disjoint (s \u00d7\u02e2 t) (s' \u00d7\u02e2 t') \u2194 Disjoint s s' \u2228 Disjoint t t'", "start": [265, 1], "end": [266, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.disjUnion_product", "code": "@[simp]\ntheorem disjUnion_product (hs : Disjoint s s') :\n    s.disjUnion s' hs \u00d7\u02e2 t = (s \u00d7\u02e2 t).disjUnion (s' \u00d7\u02e2 t) (disjoint_product.mpr <| Or.inl hs)", "start": [269, 1], "end": [272, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.product_disjUnion", "code": "@[simp]\ntheorem product_disjUnion (ht : Disjoint t t') :\n    s \u00d7\u02e2 t.disjUnion t' ht = (s \u00d7\u02e2 t).disjUnion (s \u00d7\u02e2 t') (disjoint_product.mpr <| Or.inr ht)", "start": [275, 1], "end": [278, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.diag", "code": "def diag :=\n  (s \u00d7\u02e2 s).filter fun a : \u03b1 \u00d7 \u03b1 => a.fst = a.snd", "start": [287, 1], "end": [290, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag", "code": "def offDiag :=\n  (s \u00d7\u02e2 s).filter fun a : \u03b1 \u00d7 \u03b1 => a.fst \u2260 a.snd", "start": [293, 1], "end": [296, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_diag", "code": "@[simp]\ntheorem mem_diag : x \u2208 s.diag \u2194 x.1 \u2208 s \u2227 x.1 = x.2", "start": [301, 1], "end": [303, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_offDiag", "code": "@[simp]\ntheorem mem_offDiag : x \u2208 s.offDiag \u2194 x.1 \u2208 s \u2227 x.2 \u2208 s \u2227 x.1 \u2260 x.2", "start": [306, 1], "end": [308, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_offDiag", "code": "@[simp, norm_cast]\ntheorem coe_offDiag : (s.offDiag : Set (\u03b1 \u00d7 \u03b1)) = (s : Set \u03b1).offDiag", "start": [313, 1], "end": [315, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_card", "code": "@[simp]\ntheorem diag_card : (diag s).card = s.card", "start": [318, 1], "end": [332, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_card", "code": "@[simp]\ntheorem offDiag_card : (offDiag s).card = s.card * s.card - s.card", "start": [335, 1], "end": [343, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_mono", "code": "@[mono]\ntheorem diag_mono : Monotone (diag : Finset \u03b1 \u2192 Finset (\u03b1 \u00d7 \u03b1))", "start": [346, 1], "end": [348, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_mono", "code": "@[mono]\ntheorem offDiag_mono : Monotone (offDiag : Finset \u03b1 \u2192 Finset (\u03b1 \u00d7 \u03b1))", "start": [351, 1], "end": [353, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_empty", "code": "@[simp]\ntheorem diag_empty : (\u2205 : Finset \u03b1).diag = \u2205", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_empty", "code": "@[simp]\ntheorem offDiag_empty : (\u2205 : Finset \u03b1).offDiag = \u2205", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_union_offDiag", "code": "@[simp]\ntheorem diag_union_offDiag : s.diag \u222a s.offDiag = s \u00d7\u02e2 s", "start": [366, 1], "end": [368, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_diag_offDiag", "code": "@[simp]\ntheorem disjoint_diag_offDiag : Disjoint s.diag s.offDiag", "start": [371, 1], "end": [373, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.product_sdiff_diag", "code": "theorem product_sdiff_diag : s \u00d7\u02e2 s \\ s.diag = s.offDiag", "start": [376, 1], "end": [378, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.product_sdiff_offDiag", "code": "theorem product_sdiff_offDiag : s \u00d7\u02e2 s \\ s.offDiag = s.diag", "start": [381, 1], "end": [382, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_inter", "code": "theorem diag_inter : (s \u2229 t).diag = s.diag \u2229 t.diag", "start": [385, 1], "end": [386, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_inter", "code": "theorem offDiag_inter : (s \u2229 t).offDiag = s.offDiag \u2229 t.offDiag", "start": [389, 1], "end": [392, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_union", "code": "theorem diag_union : (s \u222a t).diag = s.diag \u222a t.diag", "start": [395, 1], "end": [397, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_union", "code": "theorem offDiag_union (h : Disjoint s t) :\n    (s \u222a t).offDiag = s.offDiag \u222a t.offDiag \u222a s \u00d7\u02e2 t \u222a t \u00d7\u02e2 s", "start": [402, 1], "end": [406, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_singleton", "code": "@[simp]\ntheorem offDiag_singleton : ({a} : Finset \u03b1).offDiag = \u2205", "start": [411, 1], "end": [412, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_singleton", "code": "theorem diag_singleton : ({a} : Finset \u03b1).diag = {(a, a)}", "start": [415, 1], "end": [416, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.diag_insert", "code": "theorem diag_insert : (insert a s).diag = insert (a, a) s.diag", "start": [419, 1], "end": [420, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.offDiag_insert", "code": "theorem offDiag_insert (has : a \u2209 s) : (insert a s).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}", "start": [423, 1], "end": [425, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Option.lean", "imports": ["Mathlib/Data/Finset/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.toFinset", "code": "def toFinset (o : Option \u03b1) : Finset \u03b1 :=\n  o.elim \u2205 singleton", "start": [35, 1], "end": [37, 21], "kind": "commanddeclaration"}, {"full_name": "Option.toFinset_none", "code": "@[simp]\ntheorem toFinset_none : none.toFinset = (\u2205 : Finset \u03b1)", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Option.toFinset_some", "code": "@[simp]\ntheorem toFinset_some {a : \u03b1} : (some a).toFinset = {a}", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Option.mem_toFinset", "code": "@[simp]\ntheorem mem_toFinset {a : \u03b1} {o : Option \u03b1} : a \u2208 o.toFinset \u2194 a \u2208 o", "start": [50, 1], "end": [52, 29], "kind": "commanddeclaration"}, {"full_name": "Option.card_toFinset", "code": "theorem card_toFinset (o : Option \u03b1) : o.toFinset.card = o.elim 0 1", "start": [55, 1], "end": [55, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.insertNone", "code": "def insertNone : Finset \u03b1 \u21aao Finset (Option \u03b1) :=\n  (OrderEmbedding.ofMapLEIff fun s => cons none (s.map Embedding.some) <| by simp) fun s t => by\n    rw [le_iff_subset, cons_subset_cons, map_subset_map, le_iff_subset]", "start": [62, 1], "end": [66, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_insertNone", "code": "@[simp]\ntheorem mem_insertNone {s : Finset \u03b1} : \u2200 {o : Option \u03b1}, o \u2208 insertNone s \u2194 \u2200 a \u2208 o, a \u2208 s", "start": [69, 1], "end": [72, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.some_mem_insertNone", "code": "theorem some_mem_insertNone {s : Finset \u03b1} {a : \u03b1} : some a \u2208 insertNone s \u2194 a \u2208 s", "start": [75, 1], "end": [75, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.card_insertNone", "code": "@[simp]\ntheorem card_insertNone (s : Finset \u03b1) : s.insertNone.card = s.card + 1", "start": [78, 1], "end": [79, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone", "code": "def eraseNone : Finset (Option \u03b1) \u2192o Finset \u03b1 :=\n  (Finset.mapEmbedding (Equiv.optionIsSomeEquiv \u03b1).toEmbedding).toOrderHom.comp\n    \u27e8Finset.subtype _, subtype_mono\u27e9", "start": [82, 1], "end": [86, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_eraseNone", "code": "@[simp]\ntheorem mem_eraseNone {s : Finset (Option \u03b1)} {x : \u03b1} : x \u2208 eraseNone s \u2194 some x \u2208 s", "start": [89, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_eq_biUnion", "code": "theorem eraseNone_eq_biUnion [DecidableEq \u03b1] (s : Finset (Option \u03b1)) :\n    eraseNone s = s.biUnion Option.toFinset", "start": [94, 1], "end": [97, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_map_some", "code": "@[simp]\ntheorem eraseNone_map_some (s : Finset \u03b1) : eraseNone (s.map Embedding.some) = s", "start": [100, 1], "end": [103, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_image_some", "code": "@[simp]\ntheorem eraseNone_image_some [DecidableEq (Option \u03b1)] (s : Finset \u03b1) :\n    eraseNone (s.image some) = s", "start": [106, 1], "end": [108, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_eraseNone", "code": "@[simp]\ntheorem coe_eraseNone (s : Finset (Option \u03b1)) : (eraseNone s : Set \u03b1) = some \u207b\u00b9' s", "start": [111, 1], "end": [113, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_union", "code": "@[simp]\ntheorem eraseNone_union [DecidableEq (Option \u03b1)] [DecidableEq \u03b1] (s t : Finset (Option \u03b1)) :\n    eraseNone (s \u222a t) = eraseNone s \u222a eraseNone t", "start": [116, 1], "end": [120, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_inter", "code": "@[simp]\ntheorem eraseNone_inter [DecidableEq (Option \u03b1)] [DecidableEq \u03b1] (s t : Finset (Option \u03b1)) :\n    eraseNone (s \u2229 t) = eraseNone s \u2229 eraseNone t", "start": [123, 1], "end": [127, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_empty", "code": "@[simp]\ntheorem eraseNone_empty : eraseNone (\u2205 : Finset (Option \u03b1)) = \u2205", "start": [130, 1], "end": [133, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_none", "code": "@[simp]\ntheorem eraseNone_none : eraseNone ({none} : Finset (Option \u03b1)) = \u2205", "start": [136, 1], "end": [139, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.image_some_eraseNone", "code": "@[simp]\ntheorem image_some_eraseNone [DecidableEq (Option \u03b1)] (s : Finset (Option \u03b1)) :\n    (eraseNone s).image some = s.erase none", "start": [142, 1], "end": [144, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.map_some_eraseNone", "code": "@[simp]\ntheorem map_some_eraseNone [DecidableEq (Option \u03b1)] (s : Finset (Option \u03b1)) :\n    (eraseNone s).map Embedding.some = s.erase none", "start": [147, 1], "end": [150, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.insertNone_eraseNone", "code": "@[simp]\ntheorem insertNone_eraseNone [DecidableEq (Option \u03b1)] (s : Finset (Option \u03b1)) :\n    insertNone (eraseNone s) = insert none s", "start": [153, 1], "end": [155, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.eraseNone_insertNone", "code": "@[simp]\ntheorem eraseNone_insertNone (s : Finset \u03b1) : eraseNone (insertNone s) = s", "start": [158, 1], "end": [161, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Fold.lean", "imports": ["Mathlib/Data/Finset/Image.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Data/Multiset/Fold.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.fold", "code": "def fold (b : \u03b2) (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : \u03b2 :=\n  (s.1.map f).fold op b", "start": [32, 1], "end": [35, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_empty", "code": "@[simp]\ntheorem fold_empty : (\u2205 : Finset \u03b1).fold op b f = b", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_cons", "code": "@[simp]\ntheorem fold_cons (h : a \u2209 s) : (cons a s h).fold op b f = f a * s.fold op b f", "start": [45, 1], "end": [48, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_insert", "code": "@[simp]\ntheorem fold_insert [DecidableEq \u03b1] (h : a \u2209 s) :\n    (insert a s).fold op b f = f a * s.fold op b f", "start": [51, 1], "end": [55, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_singleton", "code": "@[simp]\ntheorem fold_singleton : ({a} : Finset \u03b1).fold op b f = f a * b", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_map", "code": "@[simp]\ntheorem fold_map {g : \u03b3 \u21aa \u03b1} {s : Finset \u03b3} : (s.map g).fold op b f = s.fold op b (f \u2218 g)", "start": [63, 1], "end": [65, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_image", "code": "@[simp]\ntheorem fold_image [DecidableEq \u03b1] {g : \u03b3 \u2192 \u03b1} {s : Finset \u03b3}\n    (H : \u2200 x \u2208 s, \u2200 y \u2208 s, g x = g y \u2192 x = y) : (s.image g).fold op b f = s.fold op b (f \u2218 g)", "start": [68, 1], "end": [71, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_congr", "code": "@[congr]\ntheorem fold_congr {g : \u03b1 \u2192 \u03b2} (H : \u2200 x \u2208 s, f x = g x) : s.fold op b f = s.fold op b g", "start": [74, 1], "end": [76, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_op_distrib", "code": "theorem fold_op_distrib {f g : \u03b1 \u2192 \u03b2} {b\u2081 b\u2082 : \u03b2} :\n    (s.fold op (b\u2081 * b\u2082) fun x => f x * g x) = s.fold op b\u2081 f * s.fold op b\u2082 g", "start": [79, 1], "end": [81, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_const", "code": "theorem fold_const [hd : Decidable (s = \u2205)] (c : \u03b2) (h : op c (op b c) = op b c) :\n    Finset.fold op b (fun _ => c) s = if s = \u2205 then b else op b c", "start": [84, 1], "end": [92, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_hom", "code": "theorem fold_hom {op' : \u03b3 \u2192 \u03b3 \u2192 \u03b3} [IsCommutative \u03b3 op'] [IsAssociative \u03b3 op'] {m : \u03b2 \u2192 \u03b3}\n    (hm : \u2200 x y, m (op x y) = op' (m x) (m y)) :\n    (s.fold op' (m b) fun x => m (f x)) = m (s.fold op b f)", "start": [95, 1], "end": [99, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_disjUnion", "code": "theorem fold_disjUnion {s\u2081 s\u2082 : Finset \u03b1} {b\u2081 b\u2082 : \u03b2} (h) :\n    (s\u2081.disjUnion s\u2082 h).fold op (b\u2081 * b\u2082) f = s\u2081.fold op b\u2081 f * s\u2082.fold op b\u2082 f", "start": [102, 1], "end": [104, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_disjiUnion", "code": "theorem fold_disjiUnion {\u03b9 : Type*} {s : Finset \u03b9} {t : \u03b9 \u2192 Finset \u03b1} {b : \u03b9 \u2192 \u03b2} {b\u2080 : \u03b2} (h) :\n    (s.disjiUnion t h).fold op (s.fold op b\u2080 b) f = s.fold op b\u2080 fun i => (t i).fold op (b i) f", "start": [107, 1], "end": [109, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_union_inter", "code": "theorem fold_union_inter [DecidableEq \u03b1] {s\u2081 s\u2082 : Finset \u03b1} {b\u2081 b\u2082 : \u03b2} :\n    ((s\u2081 \u222a s\u2082).fold op b\u2081 f * (s\u2081 \u2229 s\u2082).fold op b\u2082 f) = s\u2081.fold op b\u2082 f * s\u2082.fold op b\u2081 f", "start": [112, 1], "end": [116, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_insert_idem", "code": "@[simp]\ntheorem fold_insert_idem [DecidableEq \u03b1] [hi : IsIdempotent \u03b2 op] :\n    (insert a s).fold op b f = f a * s.fold op b f", "start": [119, 1], "end": [125, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_image_idem", "code": "theorem fold_image_idem [DecidableEq \u03b1] {g : \u03b3 \u2192 \u03b1} {s : Finset \u03b3} [hi : IsIdempotent \u03b2 op] :\n    (image g s).fold op b f = s.fold op b (f \u2218 g)", "start": [128, 1], "end": [134, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_ite'", "code": "theorem fold_ite' {g : \u03b1 \u2192 \u03b2} (hb : op b b = b) (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =\n      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => \u00acp i))", "start": [137, 1], "end": [151, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_ite", "code": "theorem fold_ite [IsIdempotent \u03b2 op] {g : \u03b1 \u2192 \u03b2} (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =\n      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => \u00acp i))", "start": [154, 1], "end": [161, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_op_rel_iff_and", "code": "theorem fold_op_rel_iff_and {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (hr : \u2200 {x y z}, r x (op y z) \u2194 r x y \u2227 r x z)\n    {c : \u03b2} : r c (s.fold op b f) \u2194 r c b \u2227 \u2200 x \u2208 s, r c (f x)", "start": [164, 1], "end": [179, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_op_rel_iff_or", "code": "theorem fold_op_rel_iff_or {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (hr : \u2200 {x y z}, r x (op y z) \u2194 r x y \u2228 r x z)\n    {c : \u03b2} : r c (s.fold op b f) \u2194 r c b \u2228 \u2203 x \u2208 s, r c (f x)", "start": [182, 1], "end": [195, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_union_empty_singleton", "code": "@[simp]\ntheorem fold_union_empty_singleton [DecidableEq \u03b1] (s : Finset \u03b1) :\n    Finset.fold (\u00b7 \u222a \u00b7) \u2205 singleton s = s", "start": [198, 1], "end": [203, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_sup_bot_singleton", "code": "theorem fold_sup_bot_singleton [DecidableEq \u03b1] (s : Finset \u03b1) :\n    Finset.fold (\u00b7 \u2294 \u00b7) \u22a5 singleton s = s", "start": [206, 1], "end": [208, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.le_fold_min", "code": "theorem le_fold_min : c \u2264 s.fold min b f \u2194 c \u2264 b \u2227 \u2200 x \u2208 s, c \u2264 f x", "start": [215, 1], "end": [216, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_min_le", "code": "theorem fold_min_le : s.fold min b f \u2264 c \u2194 b \u2264 c \u2228 \u2203 x \u2208 s, f x \u2264 c", "start": [219, 1], "end": [224, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_fold_min", "code": "theorem lt_fold_min : c < s.fold min b f \u2194 c < b \u2227 \u2200 x \u2208 s, c < f x", "start": [227, 1], "end": [228, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_min_lt", "code": "theorem fold_min_lt : s.fold min b f < c \u2194 b < c \u2228 \u2203 x \u2208 s, f x < c", "start": [231, 1], "end": [236, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_max_le", "code": "theorem fold_max_le : s.fold max b f \u2264 c \u2194 b \u2264 c \u2227 \u2200 x \u2208 s, f x \u2264 c", "start": [239, 1], "end": [244, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.le_fold_max", "code": "theorem le_fold_max : c \u2264 s.fold max b f \u2194 c \u2264 b \u2228 \u2203 x \u2208 s, c \u2264 f x", "start": [247, 1], "end": [248, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_max_lt", "code": "theorem fold_max_lt : s.fold max b f < c \u2194 b < c \u2227 \u2200 x \u2208 s, f x < c", "start": [251, 1], "end": [256, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_fold_max", "code": "theorem lt_fold_max : c < s.fold max b f \u2194 c < b \u2228 \u2203 x \u2208 s, c < f x", "start": [259, 1], "end": [260, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_max_add", "code": "theorem fold_max_add [Add \u03b2] [CovariantClass \u03b2 \u03b2 (Function.swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] (n : WithBot \u03b2)\n    (s : Finset \u03b1) : (s.fold max \u22a5 fun x : \u03b1 => \u2191(f x) + n) = s.fold max \u22a5 ((\u2191) \u2218 f) + n", "start": [263, 1], "end": [266, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/List/Lemmas.lean", "Mathlib/Init/Data/List/Basic.lean", "lake-packages/std/Std/Data/List/Lemmas.lean", "Mathlib/Algebra/Order/Monoid/OrderDual.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "Vector", "code": "def Vector (\u03b1 : Type u) (n : \u2115) :=\n  { l : List \u03b1 // l.length = n }", "start": [21, 1], "end": [23, 33], "kind": "commanddeclaration"}, {"full_name": "Vector.nil", "code": "@[match_pattern]\ndef nil : Vector \u03b1 0 :=\n  \u27e8[], rfl\u27e9", "start": [35, 1], "end": [38, 12], "kind": "commanddeclaration"}, {"full_name": "Vector.cons", "code": "@[match_pattern]\ndef cons : \u03b1 \u2192 Vector \u03b1 n \u2192 Vector \u03b1 (Nat.succ n)\n  | a, \u27e8v, h\u27e9 => \u27e8a :: v, congrArg Nat.succ h\u27e9", "start": [41, 1], "end": [45, 47], "kind": "commanddeclaration"}, {"full_name": "Vector.length", "code": "@[reducible, nolint unusedArguments]\ndef length (_ : Vector \u03b1 n) : \u2115 :=\n  n", "start": [49, 1], "end": [52, 4], "kind": "commanddeclaration"}, {"full_name": "Vector.head", "code": "def head : Vector \u03b1 (Nat.succ n) \u2192 \u03b1\n  | \u27e8[], h\u27e9 => by contradiction\n  | \u27e8a :: _, _\u27e9 => a", "start": [57, 1], "end": [60, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.head_cons", "code": "theorem head_cons (a : \u03b1) : \u2200 v : Vector \u03b1 n, head (cons a v) = a", "start": [63, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.tail", "code": "def tail : Vector \u03b1 n \u2192 Vector \u03b1 (n - 1)\n  | \u27e8[], h\u27e9 => \u27e8[], congrArg pred h\u27e9\n  | \u27e8_ :: v, h\u27e9 => \u27e8v, congrArg pred h\u27e9", "start": [68, 1], "end": [71, 40], "kind": "commanddeclaration"}, {"full_name": "Vector.tail_cons", "code": "theorem tail_cons (a : \u03b1) : \u2200 v : Vector \u03b1 n, tail (cons a v) = v", "start": [74, 1], "end": [76, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.cons_head_tail", "code": "@[simp]\ntheorem cons_head_tail : \u2200 v : Vector \u03b1 (succ n), cons (head v) (tail v) = v", "start": [79, 1], "end": [83, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.toList", "code": "def toList (v : Vector \u03b1 n) : List \u03b1 :=\n  v.1", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.get", "code": "def get : \u2200 _ : Vector \u03b1 n, Fin n \u2192 \u03b1\n  | \u27e8l, h\u27e9, i => l.nthLe i.1 (by rw [h]; exact i.2)", "start": [92, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "Vector.append", "code": "def append {n m : Nat} : Vector \u03b1 n \u2192 Vector \u03b1 m \u2192 Vector \u03b1 (n + m)\n  | \u27e8l\u2081, h\u2081\u27e9, \u27e8l\u2082, h\u2082\u27e9 => \u27e8l\u2081 ++ l\u2082, by simp [*]\u27e9", "start": [97, 1], "end": [99, 50], "kind": "commanddeclaration"}, {"full_name": "Vector.elim", "code": "@[elab_as_elim]\ndef elim {\u03b1} {C : \u2200 {n}, Vector \u03b1 n \u2192 Sort u}\n    (H : \u2200 l : List \u03b1, C \u27e8l, rfl\u27e9) {n : \u2115} : \u2200 v : Vector \u03b1 n, C v\n  | \u27e8l, h\u27e9 =>\n    match n, h with\n    | _, rfl => H l", "start": [118, 1], "end": [124, 20], "kind": "commanddeclaration"}, {"full_name": "Vector.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : Vector \u03b1 n \u2192 Vector \u03b2 n\n  | \u27e8l, h\u27e9 => \u27e8List.map f l, by simp [*]\u27e9", "start": [127, 1], "end": [129, 42], "kind": "commanddeclaration"}, {"full_name": "Vector.map_nil", "code": "@[simp]\ntheorem map_nil (f : \u03b1 \u2192 \u03b2) : map f nil = nil", "start": [132, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.map_cons", "code": "@[simp]\ntheorem map_cons (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u2200 v : Vector \u03b1 n, map f (cons a v) = cons (f a) (map f v)", "start": [138, 1], "end": [141, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082", "code": "def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03c6) : Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03c6 n\n  | \u27e8x, _\u27e9, \u27e8y, _\u27e9 => \u27e8List.zipWith f x y, by simp [*]\u27e9", "start": [144, 1], "end": [146, 56], "kind": "commanddeclaration"}, {"full_name": "Vector.replicate", "code": "def replicate (n : \u2115) (a : \u03b1) : Vector \u03b1 n :=\n  \u27e8List.replicate n a, List.length_replicate n a\u27e9", "start": [149, 1], "end": [151, 50], "kind": "commanddeclaration"}, {"full_name": "Vector.drop", "code": "def drop (i : \u2115) : Vector \u03b1 n \u2192 Vector \u03b1 (n - i)\n  | \u27e8l, p\u27e9 => \u27e8List.drop i l, by simp [*]\u27e9", "start": [154, 1], "end": [156, 43], "kind": "commanddeclaration"}, {"full_name": "Vector.take", "code": "def take (i : \u2115) : Vector \u03b1 n \u2192 Vector \u03b1 (min i n)\n  | \u27e8l, p\u27e9 => \u27e8List.take i l, by simp [*]\u27e9", "start": [159, 1], "end": [161, 43], "kind": "commanddeclaration"}, {"full_name": "Vector.removeNth", "code": "def removeNth (i : Fin n) : Vector \u03b1 n \u2192 Vector \u03b1 (n - 1)\n  | \u27e8l, p\u27e9 => \u27e8List.removeNth l i.1, by rw [l.length_removeNth] <;> rw [p]; exact i.2\u27e9", "start": [164, 1], "end": [166, 87], "kind": "commanddeclaration"}, {"full_name": "Vector.ofFn", "code": "def ofFn : \u2200 {n}, (Fin n \u2192 \u03b1) \u2192 Vector \u03b1 n\n  | 0, _ => nil\n  | _ + 1, f => cons (f 0) (ofFn fun i \u21a6 f i.succ)", "start": [169, 1], "end": [172, 51], "kind": "commanddeclaration"}, {"full_name": "Vector.congr", "code": "protected def congr {n m : \u2115} (h : n = m) : Vector \u03b1 n \u2192 Vector \u03b1 m\n  | \u27e8x, p\u27e9 => \u27e8x, h \u25b8 p\u27e9", "start": [174, 1], "end": [176, 25], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr", "code": "def mapAccumr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) : Vector \u03b1 n \u2192 \u03c3 \u2192 \u03c3 \u00d7 Vector \u03b2 n\n  | \u27e8x, px\u27e9, c =>\n    let res := List.mapAccumr f x c\n    \u27e8res.1, res.2, by simp [*]\u27e9", "start": [186, 1], "end": [192, 32], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082", "code": "def mapAccumr\u2082 {\u03b1 \u03b2 \u03c3 \u03c6 : Type} (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03c6) :\n    Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 \u03c3 \u2192 \u03c3 \u00d7 Vector \u03c6 n\n  | \u27e8x, px\u27e9, \u27e8y, py\u27e9, c =>\n    let res := List.mapAccumr\u2082 f x y c\n    \u27e8res.1, res.2, by simp [*]\u27e9", "start": [195, 1], "end": [202, 32], "kind": "commanddeclaration"}, {"full_name": "Vector.shiftLeftFill", "code": "def shiftLeftFill (v : Vector \u03b1 n) (i : \u2115) (fill : \u03b1) : Vector \u03b1 n :=\n  Vector.congr (by simp) <|\n    append (drop i v) (replicate (min n i) fill)", "start": [210, 1], "end": [214, 49], "kind": "commanddeclaration"}, {"full_name": "Vector.shiftRightFill", "code": "def shiftRightFill (v : Vector \u03b1 n) (i : \u2115) (fill : \u03b1) : Vector \u03b1 n :=\n  Vector.congr (by\n        by_cases h : i \u2264 n\n        \u00b7 have h\u2081 := Nat.sub_le n i\n          rw [min_eq_right h]\n          rw [min_eq_left h\u2081, \u2190 add_tsub_assoc_of_le h, Nat.add_comm, add_tsub_cancel_right]\n        \u00b7 have h\u2081 := le_of_not_ge h\n          rw [min_eq_left h\u2081, tsub_eq_zero_iff_le.mpr h\u2081, zero_min, Nat.add_zero]) <|\n    append (replicate (min n i) fill) (take (n - i) v)", "start": [216, 1], "end": [226, 55], "kind": "commanddeclaration"}, {"full_name": "Vector.eq", "code": "protected theorem eq {n : \u2115} : \u2200 a1 a2 : Vector \u03b1 n, toList a1 = toList a2 \u2192 a1 = a2", "start": [232, 1], "end": [234, 31], "kind": "commanddeclaration"}, {"full_name": "Vector.eq_nil", "code": "protected theorem eq_nil (v : Vector \u03b1 0) : v = nil", "start": [237, 1], "end": [239, 47], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_mk", "code": "@[simp]\ntheorem toList_mk (v : List \u03b1) (P : List.length v = n) : toList (Subtype.mk v P) = v", "start": [242, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_nil", "code": "@[simp, nolint simpNF] theorem toList_nil : toList nil = @List.nil \u03b1", "start": [249, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_length", "code": "@[simp]\ntheorem toList_length (v : Vector \u03b1 n) : (toList v).length = n", "start": [255, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_cons", "code": "@[simp]\ntheorem toList_cons (a : \u03b1) (v : Vector \u03b1 n) : toList (cons a v) = a :: toList v", "start": [261, 1], "end": [265, 15], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_append", "code": "@[simp]\ntheorem toList_append {n m : \u2115} (v : Vector \u03b1 n) (w : Vector \u03b1 m) :\n    toList (append v w) = toList v ++ toList w", "start": [268, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_drop", "code": "@[simp]\ntheorem toList_drop {n m : \u2115} (v : Vector \u03b1 m) : toList (drop n v) = List.drop n (toList v)", "start": [277, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_take", "code": "@[simp]\ntheorem toList_take {n m : \u2115} (v : Vector \u03b1 m) : toList (take n v) = List.take n (toList v)", "start": [284, 1], "end": [288, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Traversable/Basic.lean", "imports": ["Mathlib/Data/List/Defs.lean", "Mathlib/Data/Option/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ApplicativeTransformation", "code": "structure ApplicativeTransformation : Type max (u + 1) v w where\n  \n  app : \u2200 \u03b1 : Type u, F \u03b1 \u2192 G \u03b1\n  \n  preserves_pure' : \u2200 {\u03b1 : Type u} (x : \u03b1), app _ (pure x) = pure x\n  \n  preserves_seq' : \u2200 {\u03b1 \u03b2 : Type u} (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), app _ (x <*> y) = app _ x <*> app _ y", "start": [68, 1], "end": [78, 101], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.app_eq_coe", "code": "@[simp]\ntheorem app_eq_coe (\u03b7 : ApplicativeTransformation F G) : \u03b7.app = \u03b7", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u2200 \u03b1 : Type u, F \u03b1 \u2192 G \u03b1) (pp ps) :\n    (ApplicativeTransformation.mk f @pp @ps) = f", "start": [99, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.congr_fun", "code": "protected theorem congr_fun (\u03b7 \u03b7' : ApplicativeTransformation F G) (h : \u03b7 = \u03b7') {\u03b1 : Type u}\n    (x : F \u03b1) : \u03b7 x = \u03b7' x", "start": [105, 1], "end": [107, 64], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.congr_arg", "code": "protected theorem congr_arg (\u03b7 : ApplicativeTransformation F G) {\u03b1 : Type u} {x y : F \u03b1}\n    (h : x = y) : \u03b7 x = \u03b7 y", "start": [110, 1], "end": [112, 34], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.coe_inj", "code": "theorem coe_inj \u2983\u03b7 \u03b7' : ApplicativeTransformation F G\u2984 (h : (\u03b7 : \u2200 \u03b1, F \u03b1 \u2192 G \u03b1) = \u03b7') :\n    \u03b7 = \u03b7'", "start": [115, 1], "end": [119, 8], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.ext", "code": "@[ext]\ntheorem ext \u2983\u03b7 \u03b7' : ApplicativeTransformation F G\u2984 (h : \u2200 (\u03b1 : Type u) (x : F \u03b1), \u03b7 x = \u03b7' x) :\n    \u03b7 = \u03b7'", "start": [122, 1], "end": [127, 21], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.ext_iff", "code": "theorem ext_iff {\u03b7 \u03b7' : ApplicativeTransformation F G} :\n    \u03b7 = \u03b7' \u2194 \u2200 (\u03b1 : Type u) (x : F \u03b1), \u03b7 x = \u03b7' x", "start": [130, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.preserves_pure", "code": "@[functor_norm]\ntheorem preserves_pure {\u03b1} : \u2200 x : \u03b1, \u03b7 (pure x) = pure x", "start": [139, 1], "end": [141, 20], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.preserves_seq", "code": "@[functor_norm]\ntheorem preserves_seq {\u03b1 \u03b2 : Type u} : \u2200 (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1), \u03b7 (x <*> y) = \u03b7 x <*> \u03b7 y", "start": [144, 1], "end": [146, 19], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.preserves_map", "code": "@[functor_norm]\ntheorem preserves_map {\u03b1 \u03b2} (x : \u03b1 \u2192 \u03b2) (y : F \u03b1) : \u03b7 (x <$> y) = x <$> \u03b7 y", "start": [149, 1], "end": [151, 61], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.preserves_map'", "code": "theorem preserves_map' {\u03b1 \u03b2} (x : \u03b1 \u2192 \u03b2) : @\u03b7 _ \u2218 Functor.map x = Functor.map x \u2218 @\u03b7 _", "start": [154, 1], "end": [156, 28], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.idTransformation", "code": "def idTransformation : ApplicativeTransformation F F where\n  app \u03b1 := id\n  preserves_pure' := by simp\n  preserves_seq' x y := by simp", "start": [161, 1], "end": [165, 32], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.comp", "code": "def comp (\u03b7' : ApplicativeTransformation G H) (\u03b7 : ApplicativeTransformation F G) :\n    ApplicativeTransformation F H where\n  app \u03b1 x := \u03b7' (\u03b7 x)\n  preserves_pure' x := by simp only [preserves_pure]\n  preserves_seq' x y := by simp only [preserves_seq]", "start": [175, 1], "end": [182, 53], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.comp_apply", "code": "@[simp]\ntheorem comp_apply (\u03b7' : ApplicativeTransformation G H) (\u03b7 : ApplicativeTransformation F G)\n    {\u03b1 : Type u} (x : F \u03b1) : \u03b7'.comp \u03b7 x = \u03b7' (\u03b7 x)", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.comp_assoc", "code": "theorem comp_assoc {I : Type u \u2192 Type t} [Applicative I]\n    (\u03b7'' : ApplicativeTransformation H I) (\u03b7' : ApplicativeTransformation G H)\n    (\u03b7 : ApplicativeTransformation F G) : (\u03b7''.comp \u03b7').comp \u03b7 = \u03b7''.comp (\u03b7'.comp \u03b7)", "start": [193, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.comp_id", "code": "@[simp]\ntheorem comp_id (\u03b7 : ApplicativeTransformation F G) : \u03b7.comp idTransformation = \u03b7", "start": [199, 1], "end": [201, 21], "kind": "commanddeclaration"}, {"full_name": "ApplicativeTransformation.id_comp", "code": "@[simp]\ntheorem id_comp (\u03b7 : ApplicativeTransformation F G) : idTransformation.comp \u03b7 = \u03b7", "start": [204, 1], "end": [206, 21], "kind": "commanddeclaration"}, {"full_name": "Traversable", "code": "class Traversable (t : Type u \u2192 Type u) extends Functor t where\n  \n  traverse : \u2200 {m : Type u \u2192 Type u} [Applicative m] {\u03b1 \u03b2}, (\u03b1 \u2192 m \u03b2) \u2192 t \u03b1 \u2192 m (t \u03b2)", "start": [213, 1], "end": [220, 86], "kind": "commanddeclaration"}, {"full_name": "sequence", "code": "def sequence [Traversable t] : t (f \u03b1) \u2192 f (t \u03b1) :=\n  traverse id", "start": [237, 1], "end": [239, 14], "kind": "commanddeclaration"}, {"full_name": "LawfulTraversable", "code": "class LawfulTraversable (t : Type u \u2192 Type u) [Traversable t] extends LawfulFunctor t :\n    Prop where\n  \n  id_traverse : \u2200 {\u03b1} (x : t \u03b1), traverse (pure : \u03b1 \u2192 Id \u03b1) x = x\n  \n  comp_traverse :\n    \u2200 {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G] {\u03b1 \u03b2 \u03b3}\n      (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : t \u03b1),\n      traverse (Functor.Comp.mk \u2218 map f \u2218 g) x = Comp.mk (map (traverse f) (traverse g x))\n  \n  traverse_eq_map_id : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : t \u03b1),\n    traverse ((pure : \u03b2 \u2192 Id \u03b2) \u2218 f) x = id.mk (f <$> x)\n  \n  naturality :\n    \u2200 {F G} [Applicative F] [Applicative G] [LawfulApplicative F] [LawfulApplicative G]\n      (\u03b7 : ApplicativeTransformation F G) {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) (x : t \u03b1),\n      \u03b7 (traverse f x) = traverse (@\u03b7 _ \u2218 f) x", "start": [244, 1], "end": [267, 47], "kind": "commanddeclaration"}, {"full_name": "Sum.traverse", "code": "protected def traverse {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) : Sum \u03c3 \u03b1 \u2192 F (Sum \u03c3 \u03b2)\n  | Sum.inl x => pure (Sum.inl x)\n  | Sum.inr x => Sum.inr <$> f x", "start": [311, 1], "end": [315, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Applicative.lean", "imports": ["Mathlib/Control/Functor.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Applicative.map_seq_map", "code": "theorem Applicative.map_seq_map (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03c3 \u2192 \u03b2) (x : F \u03b1) (y : F \u03c3) :\n    f <$> x <*> g <$> y = (flip (\u00b7 \u2218 \u00b7) g \u2218 f) <$> x <*> y", "start": [33, 1], "end": [34, 91], "kind": "commanddeclaration"}, {"full_name": "Applicative.pure_seq_eq_map'", "code": "theorem Applicative.pure_seq_eq_map' (f : \u03b1 \u2192 \u03b2) : (\u00b7 <*> \u00b7) (pure f : F (\u03b1 \u2192 \u03b2)) = (\u00b7 <$> \u00b7) f", "start": [37, 1], "end": [38, 30], "kind": "commanddeclaration"}, {"full_name": "Applicative.ext", "code": "theorem Applicative.ext {F} :\n    \u2200 {A1 : Applicative F} {A2 : Applicative F} [@LawfulApplicative F A1] [@LawfulApplicative F A2],\n      (\u2200 {\u03b1 : Type u} (x : \u03b1), @Pure.pure _ A1.toPure _ x = @Pure.pure _ A2.toPure _ x) \u2192\n      (\u2200 {\u03b1 \u03b2 : Type u} (f : F (\u03b1 \u2192 \u03b2)) (x : F \u03b1),\n          @Seq.seq _ A1.toSeq _ _ f (fun _ => x) = @Seq.seq _ A2.toSeq _ _ f (fun _ => x)) \u2192\n      A1 = A2", "start": [41, 1], "end": [64, 85], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.map_pure", "code": "theorem map_pure (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : (f <$> pure x : Comp F G \u03b2) = pure (f x)", "start": [93, 1], "end": [94, 22], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.seq_pure", "code": "theorem seq_pure (f : Comp F G (\u03b1 \u2192 \u03b2)) (x : \u03b1) : f <*> pure x = (fun g : \u03b1 \u2192 \u03b2 => g x) <$> f", "start": [97, 1], "end": [98, 46], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.seq_assoc", "code": "theorem seq_assoc (x : Comp F G \u03b1) (f : Comp F G (\u03b1 \u2192 \u03b2)) (g : Comp F G (\u03b2 \u2192 \u03b3)) :\n    g <*> (f <*> x) = @Function.comp \u03b1 \u03b2 \u03b3 <$> g <*> f <*> x", "start": [101, 1], "end": [103, 46], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.pure_seq_eq_map", "code": "theorem pure_seq_eq_map (f : \u03b1 \u2192 \u03b2) (x : Comp F G \u03b1) : pure f <*> x = f <$> x", "start": [106, 1], "end": [107, 67], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.instLawfulApplicativeComp", "code": "instance instLawfulApplicativeComp : LawfulApplicative (Comp F G) where\n  seqLeft_eq := by intros; rfl\n  seqRight_eq := by intros; rfl\n  pure_seq := @Comp.pure_seq_eq_map F G _ _ _ _\n  map_pure := @Comp.map_pure F G _ _ _ _\n  seq_pure := @Comp.seq_pure F G _ _ _ _\n  seq_assoc := @Comp.seq_assoc F G _ _ _ _", "start": [111, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.applicative_id_comp", "code": "theorem applicative_id_comp {F} [AF : Applicative F] [LawfulApplicative F] :\n    @instApplicativeComp Id F _ _ = AF", "start": [121, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.applicative_comp_id", "code": "theorem applicative_comp_id {F} [AF : Applicative F] [LawfulApplicative F] :\n    @Comp.instApplicativeComp F Id _ _ = AF", "start": [127, 1], "end": [130, 77], "kind": "commanddeclaration"}, {"full_name": "Comp.seq_mk", "code": "@[functor_norm]\ntheorem Comp.seq_mk {\u03b1 \u03b2 : Type w} {f : Type u \u2192 Type v} {g : Type w \u2192 Type u} [Applicative f]\n    [Applicative g] (h : f (g (\u03b1 \u2192 \u03b2))) (x : f (g \u03b1)) :\n    Comp.mk h <*> Comp.mk x = Comp.mk ((\u00b7 <*> \u00b7) <$> h <*> x)", "start": [153, 1], "end": [157, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Opposite.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Group/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Int/Cast/Defs.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Algebra/Opposites.lean"], "premises": [{"full_name": "MulOpposite.natCast", "code": "@[to_additive]\ninstance natCast [NatCast \u03b1] : NatCast \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun n => op n\u27e9", "start": [31, 1], "end": [33, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.intCast", "code": "@[to_additive]\ninstance intCast [IntCast \u03b1] : IntCast \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun n => op n\u27e9", "start": [35, 1], "end": [37, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addSemigroup", "code": "instance addSemigroup [AddSemigroup \u03b1] : AddSemigroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addSemigroup _ fun _ _ => rfl", "start": [39, 1], "end": [40, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addLeftCancelSemigroup", "code": "instance addLeftCancelSemigroup [AddLeftCancelSemigroup \u03b1] : AddLeftCancelSemigroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addLeftCancelSemigroup _ fun _ _ => rfl", "start": [42, 1], "end": [43, 57], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addRightCancelSemigroup", "code": "instance addRightCancelSemigroup [AddRightCancelSemigroup \u03b1] : AddRightCancelSemigroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addRightCancelSemigroup _ fun _ _ => rfl", "start": [45, 1], "end": [46, 58], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addCommSemigroup", "code": "instance addCommSemigroup [AddCommSemigroup \u03b1] : AddCommSemigroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addCommSemigroup _ fun _ _ => rfl", "start": [48, 1], "end": [49, 51], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addZeroClass", "code": "instance addZeroClass [AddZeroClass \u03b1] : AddZeroClass \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addZeroClass _ (by exact rfl) fun _ _ => rfl", "start": [51, 1], "end": [52, 62], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addMonoid", "code": "instance addMonoid [AddMonoid \u03b1] : AddMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addMonoid _ (by exact rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [54, 1], "end": [55, 76], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid \u03b1] : AddCommMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [57, 1], "end": [58, 69], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne \u03b1] : AddMonoidWithOne \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addMonoid \u03b1, MulOpposite.one \u03b1, MulOpposite.natCast _ with\n    natCast_zero := show op ((0 : \u2115) : \u03b1) = 0 by rw [Nat.cast_zero, op_zero]\n    natCast_succ := show \u2200 n, op ((n + 1 : \u2115) : \u03b1) = op \u2191(n : \u2115) + 1 by simp }", "start": [60, 1], "end": [63, 79], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne \u03b1] : AddCommMonoidWithOne \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addMonoidWithOne \u03b1, MulOpposite.addCommMonoid \u03b1 with }", "start": [65, 1], "end": [66, 71], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.subNegMonoid", "code": "instance subNegMonoid [SubNegMonoid \u03b1] : SubNegMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.subNegMonoid _ (by exact rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [68, 1], "end": [70, 36], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addGroup", "code": "instance addGroup [AddGroup \u03b1] : AddGroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addGroup _ (by exact rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n  (fun _ _ => rfl) fun _ _ => rfl", "start": [72, 1], "end": [74, 34], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addCommGroup", "code": "instance addCommGroup [AddCommGroup \u03b1] : AddCommGroup \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.addCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [76, 1], "end": [78, 36], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addGroupWithOne", "code": "instance addGroupWithOne [AddGroupWithOne \u03b1] : AddGroupWithOne \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addMonoidWithOne \u03b1, MulOpposite.addGroup \u03b1 with\n    intCast := fun n => op n,\n    intCast_ofNat := fun n => show op ((n : \u2124) : \u03b1) = op (n : \u03b1) by rw [Int.cast_ofNat],\n    intCast_negSucc := fun n =>\n      show op _ = op (-unop (op ((n + 1 : \u2115) : \u03b1))) by simp }", "start": [80, 1], "end": [85, 62], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.addCommGroupWithOne", "code": "instance addCommGroupWithOne [AddCommGroupWithOne \u03b1] : AddCommGroupWithOne \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addGroupWithOne \u03b1, MulOpposite.addCommGroup \u03b1 with }", "start": [87, 1], "end": [88, 69], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isRightCancelMul", "code": "@[to_additive]\ninstance isRightCancelMul [Mul \u03b1] [IsLeftCancelMul \u03b1] : IsRightCancelMul \u03b1\u1d50\u1d52\u1d56 where\n  mul_right_cancel _ _ _ h := unop_injective <| mul_left_cancel <| op_injective h", "start": [97, 1], "end": [99, 82], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isLeftCancelMul", "code": "@[to_additive]\ninstance isLeftCancelMul [Mul \u03b1] [IsRightCancelMul \u03b1] : IsLeftCancelMul \u03b1\u1d50\u1d52\u1d56 where\n  mul_left_cancel _ _ _ h := unop_injective <| mul_right_cancel <| op_injective h", "start": [101, 1], "end": [103, 82], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semigroup", "code": "@[to_additive]\ninstance semigroup [Semigroup \u03b1] : Semigroup \u03b1\u1d50\u1d52\u1d56 where\n  mul_assoc x y z := unop_injective <| Eq.symm <| mul_assoc (unop z) (unop y) (unop x)", "start": [105, 1], "end": [107, 87], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.leftCancelSemigroup", "code": "@[to_additive]\ninstance leftCancelSemigroup [RightCancelSemigroup \u03b1] : LeftCancelSemigroup \u03b1\u1d50\u1d52\u1d56 where\n  mul_left_cancel _ _ _ := mul_left_cancel", "start": [109, 1], "end": [111, 43], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.rightCancelSemigroup", "code": "@[to_additive]\ninstance rightCancelSemigroup [LeftCancelSemigroup \u03b1] : RightCancelSemigroup \u03b1\u1d50\u1d52\u1d56 where\n  mul_right_cancel _ _ _ := mul_right_cancel", "start": [113, 1], "end": [115, 45], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup [CommSemigroup \u03b1] : CommSemigroup \u03b1\u1d50\u1d52\u1d56 where\n  mul_comm x y := unop_injective <| mul_comm (unop y) (unop x)", "start": [117, 1], "end": [119, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.mulOneClass", "code": "@[to_additive]\ninstance mulOneClass [MulOneClass \u03b1] : MulOneClass \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.mul \u03b1, MulOpposite.one \u03b1 with\n    one_mul := fun x => unop_injective <| mul_one <| unop x,\n    mul_one := fun x => unop_injective <| one_mul <| unop x }", "start": [121, 1], "end": [125, 62], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.monoid", "code": "@[to_additive]\ninstance monoid [Monoid \u03b1] : Monoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.semigroup \u03b1, MulOpposite.mulOneClass \u03b1 with\n    npow := fun n x => op <| x.unop ^ n,\n    npow_zero := fun x => unop_injective <| Monoid.npow_zero x.unop,\n    npow_succ := fun n x => unop_injective <| pow_succ' x.unop n }", "start": [127, 1], "end": [132, 67], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.leftCancelMonoid", "code": "@[to_additive]\ninstance leftCancelMonoid [RightCancelMonoid \u03b1] : LeftCancelMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.leftCancelSemigroup \u03b1, MulOpposite.monoid \u03b1 with }", "start": [134, 1], "end": [136, 67], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.rightCancelMonoid", "code": "@[to_additive]\ninstance rightCancelMonoid [LeftCancelMonoid \u03b1] : RightCancelMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.rightCancelSemigroup \u03b1, MulOpposite.monoid \u03b1 with }", "start": [138, 1], "end": [140, 68], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.cancelMonoid", "code": "@[to_additive]\ninstance cancelMonoid [CancelMonoid \u03b1] : CancelMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.rightCancelMonoid \u03b1, MulOpposite.leftCancelMonoid \u03b1 with }", "start": [142, 1], "end": [144, 75], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commMonoid", "code": "@[to_additive]\ninstance commMonoid [CommMonoid \u03b1] : CommMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.monoid \u03b1, MulOpposite.commSemigroup \u03b1 with }", "start": [146, 1], "end": [148, 61], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.cancelCommMonoid", "code": "@[to_additive]\ninstance cancelCommMonoid [CancelCommMonoid \u03b1] : CancelCommMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.cancelMonoid \u03b1, MulOpposite.commMonoid \u03b1 with }", "start": [150, 1], "end": [152, 64], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.divInvMonoid", "code": "@[to_additive AddOpposite.subNegMonoid]\ninstance divInvMonoid [DivInvMonoid \u03b1] : DivInvMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.monoid \u03b1, MulOpposite.inv \u03b1 with\n    zpow := fun n x => op <| x.unop ^ n,\n    zpow_zero' := fun x => unop_injective <| DivInvMonoid.zpow_zero' x.unop,\n    zpow_succ' := fun n x => unop_injective <| by\n      simp only [Int.ofNat_eq_coe]\n      rw [unop_op, zpow_ofNat, pow_succ', unop_mul, unop_op, zpow_ofNat],\n    zpow_neg' := fun z x => unop_injective <| DivInvMonoid.zpow_neg' z x.unop }", "start": [154, 1], "end": [162, 80], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.divisionMonoid", "code": "@[to_additive AddOpposite.subtractionMonoid]\ninstance divisionMonoid [DivisionMonoid \u03b1] : DivisionMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divInvMonoid \u03b1, MulOpposite.involutiveInv \u03b1 with\n    mul_inv_rev := fun _ _ => unop_injective <| mul_inv_rev _ _,\n    inv_eq_of_mul := fun _ _ h => unop_injective <| inv_eq_of_mul_eq_one_left <| congr_arg unop h }", "start": [164, 1], "end": [168, 100], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.divisionCommMonoid", "code": "@[to_additive AddOpposite.subtractionCommMonoid]\ninstance divisionCommMonoid [DivisionCommMonoid \u03b1] : DivisionCommMonoid \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divisionMonoid \u03b1, MulOpposite.commSemigroup \u03b1 with }", "start": [170, 1], "end": [172, 69], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.group", "code": "@[to_additive]\ninstance group [Group \u03b1] : Group \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divInvMonoid \u03b1 with\n    mul_left_inv := fun x => unop_injective <| mul_inv_self <| unop x }", "start": [174, 1], "end": [177, 72], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commGroup", "code": "@[to_additive]\ninstance commGroup [CommGroup \u03b1] : CommGroup \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.group \u03b1, MulOpposite.commMonoid \u03b1 with }", "start": [179, 1], "end": [181, 57], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_natCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem op_natCast [NatCast \u03b1] (n : \u2115) : op (n : \u03b1) = n", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_intCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem op_intCast [IntCast \u03b1] (n : \u2124) : op (n : \u03b1) = n", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_natCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem unop_natCast [NatCast \u03b1] (n : \u2115) : unop (n : \u03b1\u1d50\u1d52\u1d56) = n", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_intCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem unop_intCast [IntCast \u03b1] (n : \u2124) : unop (n : \u03b1\u1d50\u1d52\u1d56) = n", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_div", "code": "@[to_additive (attr := simp)]\ntheorem unop_div [DivInvMonoid \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) : unop (x / y) = (unop y)\u207b\u00b9 * unop x", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_div", "code": "@[to_additive (attr := simp)]\ntheorem op_div [DivInvMonoid \u03b1] (x y : \u03b1) : op (x / y) = (op y)\u207b\u00b9 * op x", "start": [214, 1], "end": [215, 101], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semiconjBy_op", "code": "@[to_additive (attr := simp)]\ntheorem semiconjBy_op [Mul \u03b1] {a x y : \u03b1} : SemiconjBy (op a) (op y) (op x) \u2194 SemiconjBy a x y", "start": [219, 1], "end": [221, 55], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semiconjBy_unop", "code": "@[to_additive (attr := simp, nolint simpComm)]\ntheorem semiconjBy_unop [Mul \u03b1] {a x y : \u03b1\u1d50\u1d52\u1d56} :\n    SemiconjBy (unop a) (unop y) (unop x) \u2194 SemiconjBy a x y", "start": [225, 1], "end": [228, 72], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.op", "code": "@[to_additive]\ntheorem _root_.SemiconjBy.op [Mul \u03b1] {a x y : \u03b1} (h : SemiconjBy a x y) :\n    SemiconjBy (op a) (op y) (op x)", "start": [234, 1], "end": [237, 20], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.unop", "code": "@[to_additive]\ntheorem _root_.SemiconjBy.unop [Mul \u03b1] {a x y : \u03b1\u1d50\u1d52\u1d56} (h : SemiconjBy a x y) :\n    SemiconjBy (unop a) (unop y) (unop x)", "start": [241, 1], "end": [244, 22], "kind": "commanddeclaration"}, {"full_name": "Commute.op", "code": "@[to_additive]\ntheorem _root_.Commute.op [Mul \u03b1] {x y : \u03b1} (h : Commute x y) : Commute (op x) (op y)", "start": [248, 1], "end": [250, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.Commute.unop", "code": "@[to_additive]\ntheorem Commute.unop [Mul \u03b1] {x y : \u03b1\u1d50\u1d52\u1d56} (h : Commute x y) : Commute (unop x) (unop y)", "start": [254, 1], "end": [256, 9], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commute_op", "code": "@[to_additive (attr := simp)]\ntheorem commute_op [Mul \u03b1] {x y : \u03b1} : Commute (op x) (op y) \u2194 Commute x y", "start": [260, 1], "end": [262, 16], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commute_unop", "code": "@[to_additive (attr := simp, nolint simpComm)]\ntheorem commute_unop [Mul \u03b1] {x y : \u03b1\u1d50\u1d52\u1d56} : Commute (unop x) (unop y) \u2194 Commute x y", "start": [266, 1], "end": [268, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opAddEquiv", "code": "@[simps! (config := { fullyApplied := false, simpRhs := true }) apply symm_apply]\ndef opAddEquiv [Add \u03b1] : \u03b1 \u2243+ \u03b1\u1d50\u1d52\u1d56 :=\n  { opEquiv with map_add' := fun _ _ => rfl }", "start": [274, 1], "end": [277, 46], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opAddEquiv_toEquiv", "code": "@[simp]\ntheorem opAddEquiv_toEquiv [Add \u03b1] : ((opAddEquiv : \u03b1 \u2243+ \u03b1\u1d50\u1d52\u1d56) : \u03b1 \u2243 \u03b1\u1d50\u1d52\u1d56) = opEquiv", "start": [282, 1], "end": [283, 92], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.semigroup", "code": "instance semigroup [Semigroup \u03b1] : Semigroup \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.semigroup _ fun _ _ => rfl", "start": [295, 1], "end": [296, 44], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.leftCancelSemigroup", "code": "instance leftCancelSemigroup [LeftCancelSemigroup \u03b1] : LeftCancelSemigroup \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.leftCancelSemigroup _ fun _ _ => rfl", "start": [298, 1], "end": [299, 54], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.rightCancelSemigroup", "code": "instance rightCancelSemigroup [RightCancelSemigroup \u03b1] : RightCancelSemigroup \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.rightCancelSemigroup _ fun _ _ => rfl", "start": [301, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.commSemigroup", "code": "instance commSemigroup [CommSemigroup \u03b1] : CommSemigroup \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.commSemigroup _ fun _ _ => rfl", "start": [304, 1], "end": [305, 48], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.mulOneClass", "code": "instance mulOneClass [MulOneClass \u03b1] : MulOneClass \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.mulOneClass _ (by exact rfl) fun _ _ => rfl", "start": [307, 1], "end": [308, 61], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.pow", "code": "instance pow {\u03b2} [Pow \u03b1 \u03b2] : Pow \u03b1\u1d43\u1d52\u1d56 \u03b2 where pow a b := op (unop a ^ b)", "start": [310, 1], "end": [310, 73], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_pow", "code": "@[simp]\ntheorem op_pow {\u03b2} [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : op (a ^ b) = op a ^ b", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_pow", "code": "@[simp]\ntheorem unop_pow {\u03b2} [Pow \u03b1 \u03b2] (a : \u03b1\u1d43\u1d52\u1d56) (b : \u03b2) : unop (a ^ b) = unop a ^ b", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.monoid", "code": "instance monoid [Monoid \u03b1] : Monoid \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.monoid _ (by exact rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [322, 1], "end": [323, 73], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.commMonoid", "code": "instance commMonoid [CommMonoid \u03b1] : CommMonoid \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.commMonoid _ (by exact rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [325, 1], "end": [326, 77], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.divInvMonoid", "code": "instance divInvMonoid [DivInvMonoid \u03b1] : DivInvMonoid \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.divInvMonoid _ (by exact rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [328, 1], "end": [330, 36], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.group", "code": "instance group [Group \u03b1] : Group \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.group _ (by exact rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [332, 1], "end": [334, 36], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.commGroup", "code": "instance commGroup [CommGroup \u03b1] : CommGroup \u03b1\u1d43\u1d52\u1d56 :=\n  unop_injective.commGroup _ (by exact rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [336, 1], "end": [338, 36], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne \u03b1] : AddCommMonoidWithOne \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommMonoid \u03b1, AddOpposite.one, AddOpposite.natCast \u03b1 with\n    natCast_zero := show op ((0 : \u2115) : \u03b1) = 0 by rw [Nat.cast_zero, op_zero]\n    natCast_succ := show \u2200 n, op ((n + 1 : \u2115) : \u03b1) = op \u2191(n : \u2115) + 1 by simp [add_comm] }", "start": [341, 1], "end": [344, 90], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.addCommGroupWithOne", "code": "instance addCommGroupWithOne [AddCommGroupWithOne \u03b1] : AddCommGroupWithOne \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommMonoidWithOne \u03b1, AddOpposite.addCommGroup \u03b1, AddOpposite.intCast \u03b1 with\n    intCast_ofNat := \u03bb _ \u21a6 congr_arg op $ Int.cast_ofNat _\n    intCast_negSucc := \u03bb _ \u21a6 congr_arg op $ Int.cast_negSucc _ }", "start": [346, 1], "end": [349, 65], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.opMulEquiv", "code": "@[simps! (config := { fullyApplied := false, simpRhs := true })]\ndef opMulEquiv [Mul \u03b1] : \u03b1 \u2243* \u03b1\u1d43\u1d52\u1d56 :=\n  { opEquiv with map_mul' := fun _ _ => rfl }", "start": [353, 1], "end": [356, 46], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.opMulEquiv_toEquiv", "code": "@[simp]\ntheorem opMulEquiv_toEquiv [Mul \u03b1] : ((opMulEquiv : \u03b1 \u2243* \u03b1\u1d43\u1d52\u1d56) : \u03b1 \u2243 \u03b1\u1d43\u1d52\u1d56) = opEquiv", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.inv'", "code": "@[to_additive (attr := simps! (config := { fullyApplied := false, simpRhs := true }))\n      \"Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\n      is commutative, there is `AddEquiv.inv`.\"]\ndef MulEquiv.inv' (G : Type*) [DivisionMonoid G] : G \u2243* G\u1d50\u1d52\u1d56 :=\n  { (Equiv.inv G).trans opEquiv with map_mul' := fun x y => unop_injective <| mul_inv_rev x y }", "start": [369, 1], "end": [375, 96], "kind": "commanddeclaration"}, {"full_name": "MulHom.toOpposite", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `S\u1d43\u1d52\u1d56`.\"]\ndef MulHom.toOpposite {M N : Type*} [Mul M] [Mul N] (f : M \u2192\u2099* N)\n    (hf : \u2200 x y, Commute (f x) (f y)) : M \u2192\u2099* N\u1d50\u1d52\u1d56 where\n  toFun := op \u2218 f\n  map_mul' x y := by simp [(hf x y).eq]", "start": [381, 1], "end": [389, 40], "kind": "commanddeclaration"}, {"full_name": "MulHom.fromOpposite", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x`, `y` defines an additive semigroup homomorphism from `M\u1d43\u1d52\u1d56`.\"]\ndef MulHom.fromOpposite {M N : Type*} [Mul M] [Mul N] (f : M \u2192\u2099* N)\n    (hf : \u2200 x y, Commute (f x) (f y)) : M\u1d50\u1d52\u1d56 \u2192\u2099* N where\n  toFun := f \u2218 MulOpposite.unop\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq", "start": [395, 1], "end": [403, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toOpposite", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n      \"An additive monoid homomorphism `f : M \u2192+ N` such that `f x` additively commutes\n      with `f y` for all `x, y` defines an additive monoid homomorphism to `S\u1d43\u1d52\u1d56`.\"]\ndef MonoidHom.toOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M \u2192* N)\n    (hf : \u2200 x y, Commute (f x) (f y)) : M \u2192* N\u1d50\u1d52\u1d56 where\n  toFun := op \u2218 f\n  map_one' := congrArg op f.map_one\n  map_mul' x y := by simp [(hf x y).eq]", "start": [409, 1], "end": [418, 40], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fromOpposite", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n      \"An additive monoid homomorphism `f : M \u2192+ N` such that `f x` additively commutes\n      with `f y` for all `x`, `y` defines an additive monoid homomorphism from `M\u1d43\u1d52\u1d56`.\"]\ndef MonoidHom.fromOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M \u2192* N)\n    (hf : \u2200 x y, Commute (f x) (f y)) : M\u1d50\u1d52\u1d56 \u2192* N where\n  toFun := f \u2218 MulOpposite.unop\n  map_one' := f.map_one\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq", "start": [424, 1], "end": [433, 52], "kind": "commanddeclaration"}, {"full_name": "Units.opEquiv", "code": "@[to_additive\n      \"The additive units of the additive opposites are equivalent to the additive opposites\n      of the additive units.\"]\ndef Units.opEquiv {M} [Monoid M] : M\u1d50\u1d52\u1d56\u02e3 \u2243* M\u02e3\u1d50\u1d52\u1d56 where\n  toFun u := op \u27e8unop u, unop \u2191u\u207b\u00b9, op_injective u.4, op_injective u.3\u27e9\n  invFun := MulOpposite.rec' fun u => \u27e8op \u2191u, op \u2191u\u207b\u00b9, unop_injective <| u.4, unop_injective u.3\u27e9\n  map_mul' x y := unop_injective <| Units.ext <| rfl\n  left_inv x := Units.ext <| by simp\n  right_inv x := unop_injective <| Units.ext <| by rfl", "start": [439, 1], "end": [448, 55], "kind": "commanddeclaration"}, {"full_name": "Units.coe_unop_opEquiv", "code": "@[to_additive (attr := simp)]\ntheorem Units.coe_unop_opEquiv {M} [Monoid M] (u : M\u1d50\u1d52\u1d56\u02e3) :\n    ((Units.opEquiv u).unop : M) = unop (u : M\u1d50\u1d52\u1d56)", "start": [452, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "Units.coe_opEquiv_symm", "code": "@[to_additive (attr := simp)]\ntheorem Units.coe_opEquiv_symm {M} [Monoid M] (u : M\u02e3\u1d50\u1d52\u1d56) :\n    (Units.opEquiv.symm u : M\u1d50\u1d52\u1d56) = op (u.unop : M)", "start": [459, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "IsUnit.op", "code": "@[to_additive]\nnonrec theorem IsUnit.op {M} [Monoid M] {m : M} (h : IsUnit m) : IsUnit (op m)", "start": [466, 1], "end": [469, 40], "kind": "commanddeclaration"}, {"full_name": "IsUnit.unop", "code": "@[to_additive]\nnonrec theorem IsUnit.unop {M} [Monoid M] {m : M\u1d50\u1d52\u1d56} (h : IsUnit m) : IsUnit (unop m)", "start": [473, 1], "end": [476, 37], "kind": "commanddeclaration"}, {"full_name": "isUnit_op", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_op {M} [Monoid M] {m : M} : IsUnit (op m) \u2194 IsUnit m", "start": [480, 1], "end": [482, 27], "kind": "commanddeclaration"}, {"full_name": "isUnit_unop", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_unop {M} [Monoid M] {m : M\u1d50\u1d52\u1d56} : IsUnit (unop m) \u2194 IsUnit m", "start": [486, 1], "end": [488, 27], "kind": "commanddeclaration"}, {"full_name": "MulHom.op", "code": "@[to_additive (attr := simps)\n      \"An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\n      additive semigroup homomorphism `AddHom M\u1d43\u1d52\u1d56 N\u1d43\u1d52\u1d56`. This is the action of the\n      (fully faithful)`\u1d43\u1d52\u1d56`-functor on morphisms.\"]\ndef MulHom.op {M N} [Mul M] [Mul N] : (M \u2192\u2099* N) \u2243 (M\u1d50\u1d52\u1d56 \u2192\u2099* N\u1d50\u1d52\u1d56) where\n  toFun f :=\n    { toFun := MulOpposite.op \u2218 f \u2218 unop,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop \u2218 f \u2218 MulOpposite.op,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [492, 1], "end": [506, 21], "kind": "commanddeclaration"}, {"full_name": "MulHom.unop", "code": "@[to_additive (attr := simp)\n      \"The 'unopposite' of an additive semigroup homomorphism `M\u1d43\u1d52\u1d56 \u2192\u2099+ N\u1d43\u1d52\u1d56`. Inverse\n      to `AddHom.op`.\"]\ndef MulHom.unop {M N} [Mul M] [Mul N] : (M\u1d50\u1d52\u1d56 \u2192\u2099* N\u1d50\u1d52\u1d56) \u2243 (M \u2192\u2099* N) :=\n  MulHom.op.symm", "start": [514, 1], "end": [519, 17], "kind": "commanddeclaration"}, {"full_name": "AddHom.mulOp", "code": "@[simps]\ndef AddHom.mulOp {M N} [Add M] [Add N] : AddHom M N \u2243 AddHom M\u1d50\u1d52\u1d56 N\u1d50\u1d52\u1d56 where\n  toFun f :=\n    { toFun := MulOpposite.op \u2218 f \u2218 MulOpposite.unop,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop \u2218 f \u2218 MulOpposite.op,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [523, 1], "end": [536, 21], "kind": "commanddeclaration"}, {"full_name": "AddHom.mulUnop", "code": "@[simp]\ndef AddHom.mulUnop {\u03b1 \u03b2} [Add \u03b1] [Add \u03b2] : AddHom \u03b1\u1d50\u1d52\u1d56 \u03b2\u1d50\u1d52\u1d56 \u2243 AddHom \u03b1 \u03b2 :=\n  AddHom.mulOp.symm", "start": [541, 1], "end": [545, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.op", "code": "@[to_additive (attr := simps)\n      \"An additive monoid homomorphism `M \u2192+ N` can equivalently be viewed as an\n      additive monoid homomorphism `M\u1d43\u1d52\u1d56 \u2192+ N\u1d43\u1d52\u1d56`. This is the action of the (fully faithful)\n      `\u1d43\u1d52\u1d56`-functor on morphisms.\"]\ndef MonoidHom.op {M N} [MulOneClass M] [MulOneClass N] : (M \u2192* N) \u2243 (M\u1d50\u1d52\u1d56 \u2192* N\u1d50\u1d52\u1d56) where\n  toFun f :=\n    { toFun := MulOpposite.op \u2218 f \u2218 unop, map_one' := congrArg MulOpposite.op f.map_one,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop \u2218 f \u2218 MulOpposite.op, map_one' := congrArg unop f.map_one,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [548, 1], "end": [562, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.unop", "code": "@[to_additive (attr := simp)\n      \"The 'unopposite' of an additive monoid homomorphism `M\u1d43\u1d52\u1d56 \u2192+ N\u1d43\u1d52\u1d56`. Inverse to\n      `AddMonoidHom.op`.\"]\ndef MonoidHom.unop {M N} [MulOneClass M] [MulOneClass N] : (M\u1d50\u1d52\u1d56 \u2192* N\u1d50\u1d52\u1d56) \u2243 (M \u2192* N) :=\n  MonoidHom.op.symm", "start": [570, 1], "end": [575, 20], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.opOp", "code": "@[to_additive (attr := simps!)\n      \"A additive monoid is isomorphic to the opposite of its opposite.\"]\ndef MulEquiv.opOp (M : Type*) [Mul M] : M \u2243* M\u1d50\u1d52\u1d56\u1d50\u1d52\u1d56 where\n  __ := MulOpposite.opEquiv.trans MulOpposite.opEquiv\n  map_mul' _ _ := rfl", "start": [579, 1], "end": [584, 22], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mulOp", "code": "@[simps]\ndef AddMonoidHom.mulOp {M N} [AddZeroClass M] [AddZeroClass N] : (M \u2192+ N) \u2243 (M\u1d50\u1d52\u1d56 \u2192+ N\u1d50\u1d52\u1d56) where\n  toFun f :=\n    { toFun := MulOpposite.op \u2218 f \u2218 MulOpposite.unop, map_zero' := unop_injective f.map_zero,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop \u2218 f \u2218 MulOpposite.op,\n      map_zero' := congrArg MulOpposite.unop f.map_zero,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [586, 1], "end": [599, 21], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mulUnop", "code": "@[simp]\ndef AddMonoidHom.mulUnop {\u03b1 \u03b2} [AddZeroClass \u03b1] [AddZeroClass \u03b2] : (\u03b1\u1d50\u1d52\u1d56 \u2192+ \u03b2\u1d50\u1d52\u1d56) \u2243 (\u03b1 \u2192+ \u03b2) :=\n  AddMonoidHom.mulOp.symm", "start": [604, 1], "end": [608, 26], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mulOp", "code": "@[simps]\ndef AddEquiv.mulOp {\u03b1 \u03b2} [Add \u03b1] [Add \u03b2] : \u03b1 \u2243+ \u03b2 \u2243 (\u03b1\u1d50\u1d52\u1d56 \u2243+ \u03b2\u1d50\u1d52\u1d56) where\n  toFun f := opAddEquiv.symm.trans (f.trans opAddEquiv)\n  invFun f := opAddEquiv.trans (f.trans opAddEquiv.symm)\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [611, 1], "end": [617, 21], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mulUnop", "code": "@[simp]\ndef AddEquiv.mulUnop {\u03b1 \u03b2} [Add \u03b1] [Add \u03b2] : \u03b1\u1d50\u1d52\u1d56 \u2243+ \u03b2\u1d50\u1d52\u1d56 \u2243 (\u03b1 \u2243+ \u03b2) :=\n  AddEquiv.mulOp.symm", "start": [622, 1], "end": [625, 22], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.op", "code": "@[to_additive (attr := simps)\n  \"An iso `\u03b1 \u2243+ \u03b2` can equivalently be viewed as an iso `\u03b1\u1d43\u1d52\u1d56 \u2243+ \u03b2\u1d43\u1d52\u1d56`.\"]\ndef MulEquiv.op {\u03b1 \u03b2} [Mul \u03b1] [Mul \u03b2] : \u03b1 \u2243* \u03b2 \u2243 (\u03b1\u1d50\u1d52\u1d56 \u2243* \u03b2\u1d50\u1d52\u1d56) where\n  toFun f :=\n    { toFun := MulOpposite.op \u2218 f \u2218 unop, invFun := MulOpposite.op \u2218 f.symm \u2218 unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop \u2218 f \u2218 MulOpposite.op, invFun := unop \u2218 f.symm \u2218 MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [628, 1], "end": [643, 21], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.unop", "code": "@[to_additive (attr := simp)\n  \"The 'unopposite' of an iso `\u03b1\u1d43\u1d52\u1d56 \u2243+ \u03b2\u1d43\u1d52\u1d56`. Inverse to `AddEquiv.op`.\"]\ndef MulEquiv.unop {\u03b1 \u03b2} [Mul \u03b1] [Mul \u03b2] : \u03b1\u1d50\u1d52\u1d56 \u2243* \u03b2\u1d50\u1d52\u1d56 \u2243 (\u03b1 \u2243* \u03b2) :=\n  MulEquiv.op.symm", "start": [655, 1], "end": [659, 19], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mul_op_ext", "code": "@[ext]\ntheorem AddMonoidHom.mul_op_ext {\u03b1 \u03b2} [AddZeroClass \u03b1] [AddZeroClass \u03b2] (f g : \u03b1\u1d50\u1d52\u1d56 \u2192+ \u03b2)\n    (h :\n      f.comp (opAddEquiv : \u03b1 \u2243+ \u03b1\u1d50\u1d52\u1d56).toAddMonoidHom =\n        g.comp (opAddEquiv : \u03b1 \u2243+ \u03b1\u1d50\u1d52\u1d56).toAddMonoidHom) :\n    f = g", "start": [665, 1], "end": [674, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/ForSqrt.lean", "imports": ["Mathlib/Data/Nat/Size.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.mul_le_of_le_div", "code": "protected lemma mul_le_of_le_div (k x y : \u2115) (h : x \u2264 y / k) : x * k \u2264 y := by\n  by_cases hk : k = 0\n  case pos => rw [hk, mul_zero]; exact zero_le _\n  case neg => rwa [\u2190 le_div_iff_mul_le (pos_iff_ne_zero.2 hk)]", "start": [22, 1], "end": [25, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.div_mul_div_le", "code": "protected lemma div_mul_div_le (a b c d : \u2115) :\n    (a / b) * (c / d) \u2264 (a * c) / (b * d) := by\n  by_cases hb : b = 0\n  case pos => simp [hb]\n  by_cases hd : d = 0\n  case pos => simp [hd]\n  have hbd : b * d \u2260 0 := mul_ne_zero hb hd\n  rw [le_div_iff_mul_le (Nat.pos_of_ne_zero hbd)]\n  transitivity ((a / b) * b) * ((c / d) * d)\n  \u00b7 apply le_of_eq; simp only [mul_assoc, mul_left_comm]\n  \u00b7 apply Nat.mul_le_mul <;> apply div_mul_le_self", "start": [27, 1], "end": [37, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.iter_fp_bound", "code": "private lemma iter_fp_bound (n k : \u2115) :\n    let iter_next (n guess : \u2115) := (guess + n / guess) / 2;\n    sqrt.iter n k \u2264 iter_next n (sqrt.iter n k) := by\n  intro iter_next\n  unfold sqrt.iter\n  by_cases h : (k + n / k) / 2 < k\n  case pos => simp [if_pos h]; exact iter_fp_bound _ _\n  case neg => simp [if_neg h]; exact Nat.le_of_not_lt h", "start": [39, 1], "end": [46, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.AM_GM", "code": "private lemma AM_GM : {a b : \u2115} \u2192 (4 * a * b \u2264 (a + b) * (a + b))\n  | 0, _ => by rw [mul_zero, zero_mul]; exact zero_le _\n  | _, 0 => by rw [mul_zero]; exact zero_le _\n  | a + 1, b + 1 => by\n    have ih := add_le_add_right (@AM_GM a b) 4\n    simp only [mul_add, add_mul, show (4 : \u2115) = 1 + 1 + 1 + 1 from rfl, one_mul, mul_one] at ih \u22a2\n    simp only [add_assoc, add_left_comm, add_le_add_iff_left] at ih \u22a2\n    exact ih", "start": [48, 1], "end": [55, 13], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.sqrt.iter_sq_le", "code": "lemma sqrt.iter_sq_le (n guess : \u2115) : sqrt.iter n guess * sqrt.iter n guess \u2264 n := by\n  unfold sqrt.iter\n  let next := (guess + n / guess) / 2\n  by_cases h : next < guess\n  case pos => simpa only [dif_pos h] using sqrt.iter_sq_le n next\n  case neg =>\n    simp only [dif_neg h]\n    apply Nat.mul_le_of_le_div\n    apply le_of_add_le_add_left (a := guess)\n    rw [\u2190 mul_two, \u2190 le_div_iff_mul_le]\n    \u00b7 exact le_of_not_lt h\n    \u00b7 exact zero_lt_two", "start": [63, 1], "end": [74, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.sqrt.lt_iter_succ_sq", "code": "lemma sqrt.lt_iter_succ_sq (n guess : \u2115) (hn : n < (guess + 1) * (guess + 1)) :\n    n < (sqrt.iter n guess + 1) * (sqrt.iter n guess + 1) := by\n  unfold sqrt.iter\n  let m := (guess + n / guess) / 2\n  by_cases h : m < guess\n  case pos =>\n    suffices n < (m + 1) * (m + 1) by\n      simpa only [dif_pos h] using sqrt.lt_iter_succ_sq n m this\n    refine lt_of_mul_lt_mul_left ?_ (4 * (guess * guess)).zero_le\n    apply lt_of_le_of_lt AM_GM\n    rw [show (4 : \u2115) = 2 * 2 from rfl]\n    rw [mul_mul_mul_comm 2, mul_mul_mul_comm (2 * guess)]\n    refine mul_self_lt_mul_self (?_ : _ < _ * succ (_ / 2))\n    rw [\u2190 add_div_right _ (by decide), mul_comm 2, mul_assoc,\n      show guess + n / guess + 2 = (guess + n / guess + 1) + 1 from rfl]\n    have aux_lemma {a : \u2115} : a \u2264 2 * ((a + 1) / 2) := by\n      rw [mul_comm]\n      exact (add_le_add_iff_right 2).1 $ succ_le_of_lt $ @lt_div_mul_add (a + 1) 2 zero_lt_two\n    refine lt_of_lt_of_le ?_ (act_rel_act_of_rel _ aux_lemma)\n    rw [add_assoc, mul_add]\n    exact add_lt_add_left (lt_mul_div_succ _ (lt_of_le_of_lt (Nat.zero_le m) h)) _\n  case neg =>\n    simpa only [dif_neg h] using hn", "start": [76, 1], "end": [99, 36], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/PNat/Defs.lean", "imports": ["Mathlib/Tactic/Coe.lean", "Mathlib/Data/Nat/Cast/Defs.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Tactic/Lift.lean"], "premises": [{"full_name": "PNat", "code": "def PNat := { n : \u2115 // 0 < n }\n  deriving DecidableEq, LinearOrder", "start": [23, 1], "end": [27, 36], "kind": "commanddeclaration"}, {"full_name": "PNat.val", "code": "@[coe]\ndef PNat.val : \u2115+ \u2192 \u2115 := Subtype.val", "start": [36, 1], "end": [38, 37], "kind": "commanddeclaration"}, {"full_name": "coePNatNat", "code": "instance coePNatNat : Coe \u2115+ \u2115 :=\n  \u27e8PNat.val\u27e9", "start": [40, 1], "end": [41, 13], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_coe", "code": "@[simp]\ntheorem mk_coe (n h) : (PNat.val (\u27e8n, h\u27e9 : \u2115+) : \u2115) = n", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred", "code": "def natPred (i : \u2115+) : \u2115 :=\n  i - 1", "start": [59, 1], "end": [61, 8], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_eq_pred", "code": "@[simp]\ntheorem natPred_eq_pred {n : \u2115} (h : 0 < n) : natPred (\u27e8n, h\u27e9 : \u2115+) = n.pred", "start": [64, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.toPNat", "code": "def toPNat (n : \u2115) (h : 0 < n := by decide) : \u2115+ :=\n  \u27e8n, h\u27e9", "start": [73, 1], "end": [76, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat", "code": "def succPNat (n : \u2115) : \u2115+ :=\n  \u27e8succ n, succ_pos n\u27e9", "start": [79, 1], "end": [81, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_coe", "code": "@[simp]\ntheorem succPNat_coe (n : \u2115) : (succPNat n : \u2115) = succ n", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.natPred_succPNat", "code": "@[simp]\ntheorem natPred_succPNat (n : \u2115) : n.succPNat.natPred = n", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.succPNat_natPred", "code": "@[simp]\ntheorem _root_.PNat.succPNat_natPred (n : \u2115+) : n.natPred.succPNat = n", "start": [94, 1], "end": [96, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.toPNat'", "code": "def toPNat' (n : \u2115) : \u2115+ :=\n  succPNat (pred n)", "start": [99, 1], "end": [102, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.toPNat'_coe", "code": "@[simp]\ntheorem toPNat'_coe : \u2200 n : \u2115, (toPNat' n : \u2115) = ite (0 < n) n 1", "start": [105, 1], "end": [110, 8], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_le_mk", "code": "theorem mk_le_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) : (\u27e8n, hn\u27e9 : \u2115+) \u2264 \u27e8k, hk\u27e9 \u2194 n \u2264 k", "start": [119, 1], "end": [126, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_lt_mk", "code": "theorem mk_lt_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) : (\u27e8n, hn\u27e9 : \u2115+) < \u27e8k, hk\u27e9 \u2194 n < k", "start": [130, 1], "end": [131, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe (n k : \u2115+) : (n : \u2115) \u2264 k \u2194 n \u2264 k", "start": [134, 1], "end": [136, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe (n k : \u2115+) : (n : \u2115) < k \u2194 n < k", "start": [139, 1], "end": [141, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.pos", "code": "@[simp]\ntheorem pos (n : \u2115+) : 0 < (n : \u2115)", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.eq", "code": "theorem eq {m n : \u2115+} : (m : \u2115) = n \u2192 m = n", "start": [149, 1], "end": [150, 13], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_injective", "code": "theorem coe_injective : Function.Injective (fun (a : \u2115+) => (a : \u2115))", "start": [153, 1], "end": [154, 24], "kind": "commanddeclaration"}, {"full_name": "PNat.ne_zero", "code": "@[simp]\ntheorem ne_zero (n : \u2115+) : (n : \u2115) \u2260 0", "start": [157, 1], "end": [159, 10], "kind": "commanddeclaration"}, {"full_name": "NeZero.pnat", "code": "instance _root_.NeZero.pnat {a : \u2115+} : NeZero (a : \u2115) :=\n  \u27e8a.ne_zero\u27e9", "start": [162, 1], "end": [163, 14], "kind": "commanddeclaration"}, {"full_name": "PNat.toPNat'_coe", "code": "theorem toPNat'_coe {n : \u2115} : 0 < n \u2192 (n.toPNat' : \u2115) = n", "start": [166, 1], "end": [167, 22], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_toPNat'", "code": "@[simp]\ntheorem coe_toPNat' (n : \u2115+) : (n : \u2115).toPNat' = n", "start": [170, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "PNat.one_le", "code": "@[simp]\ntheorem one_le (n : \u2115+) : (1 : \u2115+) \u2264 n", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.not_lt_one", "code": "@[simp]\ntheorem not_lt_one (n : \u2115+) : \u00acn < 1", "start": [180, 1], "end": [182, 24], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_one", "code": "@[simp]\ntheorem mk_one {h} : (\u27e81, h\u27e9 : \u2115+) = (1 : \u2115+)", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.one_coe", "code": "@[simp, norm_cast]\ntheorem one_coe : ((1 : \u2115+) : \u2115) = 1", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_eq_one_iff", "code": "@[simp, norm_cast]\ntheorem coe_eq_one_iff {m : \u2115+} : (m : \u2115) = 1 \u2194 m = 1", "start": [199, 1], "end": [201, 40], "kind": "commanddeclaration"}, {"full_name": "PNat.strongInductionOn", "code": "def strongInductionOn {p : \u2115+ \u2192 Sort*} (n : \u2115+) : (\u2200 k, (\u2200 m, m < k \u2192 p m) \u2192 p k) \u2192 p n\n  | IH => IH _ fun a _ => strongInductionOn a IH\ntermination_by _ => n.1", "start": [207, 1], "end": [210, 24], "kind": "commanddeclaration"}, {"full_name": "PNat.modDivAux", "code": "def modDivAux : \u2115+ \u2192 \u2115 \u2192 \u2115 \u2192 \u2115+ \u00d7 \u2115\n  | k, 0, q => \u27e8k, q.pred\u27e9\n  | _, r + 1, q => \u27e8\u27e8r + 1, Nat.succ_pos r\u27e9, q\u27e9", "start": [213, 1], "end": [222, 48], "kind": "commanddeclaration"}, {"full_name": "PNat.modDiv", "code": "def modDiv (m k : \u2115+) : \u2115+ \u00d7 \u2115 :=\n  modDivAux k ((m : \u2115) % (k : \u2115)) ((m : \u2115) / (k : \u2115))", "start": [225, 1], "end": [234, 54], "kind": "commanddeclaration"}, {"full_name": "PNat.mod", "code": "def mod (m k : \u2115+) : \u2115+ :=\n  (modDiv m k).1", "start": [237, 1], "end": [241, 17], "kind": "commanddeclaration"}, {"full_name": "PNat.div", "code": "def div (m k : \u2115+) : \u2115 :=\n  (modDiv m k).2", "start": [244, 1], "end": [249, 17], "kind": "commanddeclaration"}, {"full_name": "PNat.mod_coe", "code": "theorem mod_coe (m k : \u2115+) :\n    (mod m k : \u2115) = ite ((m : \u2115) % (k : \u2115) = 0) (k : \u2115) ((m : \u2115) % (k : \u2115))", "start": [252, 1], "end": [261, 8], "kind": "commanddeclaration"}, {"full_name": "PNat.div_coe", "code": "theorem div_coe (m k : \u2115+) :\n    (div m k : \u2115) = ite ((m : \u2115) % (k : \u2115) = 0) ((m : \u2115) / (k : \u2115)).pred ((m : \u2115) / (k : \u2115))", "start": [264, 1], "end": [273, 8], "kind": "commanddeclaration"}, {"full_name": "PNat.divExact", "code": "def divExact (m k : \u2115+) : \u2115+ :=\n  \u27e8(div m k).succ, Nat.succ_pos _\u27e9", "start": [276, 1], "end": [278, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.canLiftPNat", "code": "instance Nat.canLiftPNat : CanLift \u2115 \u2115+ (\u2191) (fun n => 0 < n) :=\n  \u27e8fun n hn => \u27e8Nat.toPNat' n, PNat.toPNat'_coe hn\u27e9\u27e9", "start": [285, 1], "end": [286, 53], "kind": "commanddeclaration"}, {"full_name": "Int.canLiftPNat", "code": "instance Int.canLiftPNat : CanLift \u2124 \u2115+ (\u2191) ((0 < \u00b7)) :=\n  \u27e8fun n hn =>\n    \u27e8Nat.toPNat' (Int.natAbs n), by\n      rw [Nat.toPNat'_coe, if_pos (Int.natAbs_pos.2 hn.ne'),\n        Int.natAbs_of_nonneg hn.le]\u27e9\u27e9", "start": [289, 1], "end": [293, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Div.lean", "imports": ["Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Data/Nat/Order/Lemmas.lean", "Mathlib/Data/Int/Dvd/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.eq_mul_div_of_mul_eq_mul_of_dvd_left", "code": "theorem eq_mul_div_of_mul_eq_mul_of_dvd_left {a b c d : \u2124} (hb : b \u2260 0) (hbc : b \u2223 c)\n    (h : b * a = c * d) : a = c / b * d", "start": [21, 1], "end": [27, 30], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_dvd_of_natAbs_lt_natAbs", "code": "theorem eq_zero_of_dvd_of_natAbs_lt_natAbs {a b : \u2124} (w : a \u2223 b) (h : natAbs b < natAbs a) :\n    b = 0", "start": [30, 1], "end": [36, 33], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_dvd_of_nonneg_of_lt", "code": "theorem eq_zero_of_dvd_of_nonneg_of_lt {a b : \u2124} (w\u2081 : 0 \u2264 a) (w\u2082 : a < b) (h : b \u2223 a) : a = 0", "start": [39, 1], "end": [40, 80], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_mod_eq_of_natAbs_sub_lt_natAbs", "code": "theorem eq_of_mod_eq_of_natAbs_sub_lt_natAbs {a b c : \u2124} (h1 : a % b = c)\n    (h2 : natAbs (a - c) < natAbs b) : a = c", "start": [43, 1], "end": [47, 84], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_negSucc_of_ge", "code": "theorem ofNat_add_negSucc_of_ge {m n : \u2115} (h : n.succ \u2264 m) :\n    ofNat m + -[n+1] = ofNat (m - n.succ)", "start": [50, 1], "end": [53, 40], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_le_of_dvd_ne_zero", "code": "theorem natAbs_le_of_dvd_ne_zero {s t : \u2124} (hst : s \u2223 t) (ht : t \u2260 0) : natAbs s \u2264 natAbs t", "start": [56, 1], "end": [57, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Defs.lean", "imports": ["Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Rat/Init.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Data/Int/Cast/Defs.lean"], "premises": [{"full_name": "Rat.pos", "code": "theorem pos (a : \u211a) : 0 < a.den", "start": [37, 1], "end": [37, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.ofInt_eq_cast", "code": "@[simp]\ntheorem ofInt_eq_cast (n : \u2124) : ofInt n = Int.cast n", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_num", "code": "@[simp, norm_cast]\ntheorem coe_int_num (n : \u2124) : (n : \u211a).num = n", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_den", "code": "@[simp, norm_cast]\ntheorem coe_int_den (n : \u2124) : (n : \u211a).den = 1", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_eq", "code": "theorem mkRat_eq (n d) : mkRat n d = n /. d", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_mk", "code": "@[simp]\ntheorem zero_mk (d) (h : d \u2260 0) (w) : mk' 0 d h w = 0", "start": [70, 1], "end": [71, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.num_eq_zero", "code": "@[simp]\nlemma num_eq_zero {q : \u211a} : q.num = 0 \u2194 q = 0 := by\n  induction q\n  constructor\n  \u00b7 rintro rfl\n    exact zero_mk _ _ _\n  \u00b7 exact congr_arg num", "start": [78, 1], "end": [84, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Rat.num_ne_zero", "code": "lemma num_ne_zero {q : \u211a} : q.num \u2260 0 \u2194 q \u2260 0 := num_eq_zero.not", "start": [86, 1], "end": [86, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Rat.divInt_eq_zero", "code": "@[simp]\ntheorem divInt_eq_zero {a b : \u2124} (b0 : b \u2260 0) : a /. b = 0 \u2194 a = 0", "start": [88, 1], "end": [90, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_ne_zero", "code": "theorem divInt_ne_zero {a b : \u2124} (b0 : b \u2260 0) : a /. b \u2260 0 \u2194 a \u2260 0", "start": [93, 1], "end": [94, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.normalize_eq_mk'", "code": "theorem normalize_eq_mk' (n : Int) (d : Nat) (h : d \u2260 0) (c : Nat.gcd (Int.natAbs n) d = 1) :\n    normalize n d h = mk' n d h c", "start": [101, 1], "end": [102, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.num_den", "code": "theorem num_den : \u2200 {a : \u211a}, a.num /. a.den = a", "start": [108, 1], "end": [108, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.num_den'", "code": "theorem num_den' {n d h c} : (\u27e8n, d, h, c\u27e9 : \u211a) = n /. d", "start": [111, 1], "end": [111, 73], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_eq_divInt", "code": "theorem coe_int_eq_divInt (z : \u2124) : (z : \u211a) = z /. 1", "start": [114, 1], "end": [114, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.numDenCasesOn", "code": "@[elab_as_elim]\ndef numDenCasesOn.{u} {C : \u211a \u2192 Sort u} :\n    \u2200 (a : \u211a) (_ : \u2200 n d, 0 < d \u2192 (Int.natAbs n).Coprime d \u2192 C (n /. d)), C a\n  | \u27e8n, d, h, c\u27e9, H => by rw [num_den']; exact H n d (Nat.pos_of_ne_zero h) c", "start": [117, 1], "end": [122, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.numDenCasesOn'", "code": "@[elab_as_elim]\ndef numDenCasesOn'.{u} {C : \u211a \u2192 Sort u} (a : \u211a) (H : \u2200 (n : \u2124) (d : \u2115), d \u2260 0 \u2192 C (n /. d)) :\n    C a :=\n  numDenCasesOn a fun n d h _ => H n d h.ne'", "start": [125, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "Rat.lift_binop_eq", "code": "theorem lift_binop_eq (f : \u211a \u2192 \u211a \u2192 \u211a) (f\u2081 : \u2124 \u2192 \u2124 \u2192 \u2124 \u2192 \u2124 \u2192 \u2124) (f\u2082 : \u2124 \u2192 \u2124 \u2192 \u2124 \u2192 \u2124 \u2192 \u2124)\n    (fv :\n      \u2200 {n\u2081 d\u2081 h\u2081 c\u2081 n\u2082 d\u2082 h\u2082 c\u2082},\n        f \u27e8n\u2081, d\u2081, h\u2081, c\u2081\u27e9 \u27e8n\u2082, d\u2082, h\u2082, c\u2082\u27e9 = f\u2081 n\u2081 d\u2081 n\u2082 d\u2082 /. f\u2082 n\u2081 d\u2081 n\u2082 d\u2082)\n    (f0 : \u2200 {n\u2081 d\u2081 n\u2082 d\u2082}, d\u2081 \u2260 0 \u2192 d\u2082 \u2260 0 \u2192 f\u2082 n\u2081 d\u2081 n\u2082 d\u2082 \u2260 0) (a b c d : \u2124)\n    (b0 : b \u2260 0) (d0 : d \u2260 0)\n    (H :\n      \u2200 {n\u2081 d\u2081 n\u2082 d\u2082}, a * d\u2081 = n\u2081 * b \u2192 c * d\u2082 = n\u2082 * d \u2192\n        f\u2081 n\u2081 d\u2081 n\u2082 d\u2082 * f\u2082 a b c d = f\u2081 a b c d * f\u2082 n\u2081 d\u2081 n\u2082 d\u2082) :\n    f (a /. b) (c /. d) = f\u2081 a b c d /. f\u2082 a b c d", "start": [137, 1], "end": [153, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.add_def''", "code": "@[simp]\ntheorem add_def'' {a b c d : \u2124} (b0 : b \u2260 0) (d0 : d \u2260 0) :\n    a /. b + c /. d = (a * d + c * b) /. (b * d)", "start": [156, 1], "end": [158, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.neg_def", "code": "@[simp]\ntheorem neg_def {a b : \u2124} : -(a /. b) = -a /. b", "start": [166, 1], "end": [167, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_neg_den", "code": "@[simp]\ntheorem divInt_neg_den (n d : \u2124) : n /. -d = -n /. d", "start": [170, 1], "end": [171, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.sub_def''", "code": "@[simp]\ntheorem sub_def'' {a b c d : \u2124} (b0 : b \u2260 0) (d0 : d \u2260 0) :\n    a /. b - c /. d = (a * d - c * b) /. (b * d)", "start": [174, 1], "end": [176, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_def'", "code": "@[simp]\ntheorem mul_def' {a b c d : \u2124} (b0 : b \u2260 0) (d0 : d \u2260 0) : a /. b * (c /. d) = a * c /. (b * d)", "start": [182, 1], "end": [184, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_def'", "code": "@[simp]\ntheorem inv_def' {a b : \u2124} : (a /. b)\u207b\u00b9 = b /. a", "start": [194, 1], "end": [195, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.add_zero", "code": "protected theorem add_zero : a + 0 = a", "start": [203, 1], "end": [205, 87], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_add", "code": "protected theorem zero_add : 0 + a = a", "start": [208, 1], "end": [210, 87], "kind": "commanddeclaration"}, {"full_name": "Rat.add_comm", "code": "protected theorem add_comm : a + b = b + a", "start": [213, 1], "end": [215, 38], "kind": "commanddeclaration"}, {"full_name": "Rat.add_assoc", "code": "protected theorem add_assoc : a + b + c = a + (b + c)", "start": [218, 1], "end": [226, 15], "kind": "commanddeclaration"}, {"full_name": "Rat.add_left_neg", "code": "protected theorem add_left_neg : -a + a = 0", "start": [229, 1], "end": [230, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_zero_one", "code": "theorem divInt_zero_one : 0 /. 1 = 0", "start": [233, 1], "end": [236, 9], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_one_one", "code": "@[simp]\ntheorem divInt_one_one : 1 /. 1 = 1", "start": [239, 1], "end": [243, 9], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_neg_one_one", "code": "@[simp]\ntheorem divInt_neg_one_one : -1 /. 1 = -1", "start": [246, 1], "end": [250, 9], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_one", "code": "theorem divInt_one (n : \u2124) : n /. 1 = n", "start": [253, 1], "end": [257, 8], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_one", "code": "theorem mkRat_one {n : \u2124} : mkRat n 1 = n", "start": [259, 1], "end": [260, 38], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_assoc", "code": "protected theorem mul_assoc : a * b * c = a * (b * c)", "start": [266, 1], "end": [270, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.add_mul", "code": "protected theorem add_mul : (a + b) * c = a * c + b * c", "start": [273, 1], "end": [280, 15], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_add", "code": "protected theorem mul_add : a * (b + c) = a * b + a * c", "start": [283, 1], "end": [284, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_ne_one", "code": "protected theorem zero_ne_one : 0 \u2260 (1 : \u211a)", "start": [287, 1], "end": [289, 20], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_inv_cancel", "code": "protected theorem mul_inv_cancel : a \u2260 0 \u2192 a * a\u207b\u00b9 = 1", "start": [292, 1], "end": [295, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_mul_cancel", "code": "protected theorem inv_mul_cancel (h : a \u2260 0) : a\u207b\u00b9 * a = 1", "start": [298, 1], "end": [299, 55], "kind": "commanddeclaration"}, {"full_name": "Rat.commRing", "code": "instance commRing : CommRing \u211a where\n  zero := 0\n  add := (\u00b7 + \u00b7)\n  neg := Neg.neg\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  zero_add := Rat.zero_add\n  add_zero := Rat.add_zero\n  add_comm := Rat.add_comm\n  add_assoc := Rat.add_assoc\n  add_left_neg := Rat.add_left_neg\n  mul_one := Rat.mul_one\n  one_mul := Rat.one_mul\n  mul_comm := Rat.mul_comm\n  mul_assoc := Rat.mul_assoc\n  zero_mul := Rat.zero_mul\n  mul_zero := Rat.mul_zero\n  left_distrib := Rat.mul_add\n  right_distrib := Rat.add_mul\n  sub_eq_add_neg := Rat.sub_eq_add_neg\n  intCast := fun n => n\n  natCast n := Int.cast n\n  natCast_zero := rfl\n  natCast_succ n := by\n    simp only [coe_int_eq_divInt, add_def'' one_ne_zero one_ne_zero,\n      \u2190 divInt_one_one, Nat.cast_add, Nat.cast_one, mul_one]", "start": [309, 1], "end": [334, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.commGroupWithZero", "code": "instance commGroupWithZero : CommGroupWithZero \u211a :=\n  { exists_pair_ne := \u27e80, 1, Rat.zero_ne_one\u27e9\n    inv_zero := by\n      change Rat.inv 0 = 0\n      rw [Rat.inv_def]\n      rfl\n    mul_inv_cancel := Rat.mul_inv_cancel\n    mul_zero := mul_zero\n    zero_mul := zero_mul }", "start": [336, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "Rat.isDomain", "code": "instance isDomain : IsDomain \u211a :=\n  NoZeroDivisors.to_isDomain _", "start": [346, 1], "end": [347, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.nontrivial", "code": "instance nontrivial : Nontrivial \u211a := by infer_instance", "start": [351, 1], "end": [351, 56], "kind": "commanddeclaration"}, {"full_name": "Rat.commSemiring", "code": "instance commSemiring : CommSemiring \u211a := by infer_instance", "start": [353, 1], "end": [353, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.semiring", "code": "instance semiring : Semiring \u211a := by infer_instance", "start": [355, 1], "end": [355, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.addCommGroup", "code": "instance addCommGroup : AddCommGroup \u211a := by infer_instance", "start": [357, 1], "end": [357, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.addGroup", "code": "instance addGroup : AddGroup \u211a := by infer_instance", "start": [359, 1], "end": [359, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid \u211a := by infer_instance", "start": [361, 1], "end": [361, 62], "kind": "commanddeclaration"}, {"full_name": "Rat.addMonoid", "code": "instance addMonoid : AddMonoid \u211a := by infer_instance", "start": [363, 1], "end": [363, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.addLeftCancelSemigroup", "code": "instance addLeftCancelSemigroup : AddLeftCancelSemigroup \u211a := by infer_instance", "start": [365, 1], "end": [365, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.addRightCancelSemigroup", "code": "instance addRightCancelSemigroup : AddRightCancelSemigroup \u211a := by infer_instance", "start": [367, 1], "end": [367, 82], "kind": "commanddeclaration"}, {"full_name": "Rat.addCommSemigroup", "code": "instance addCommSemigroup : AddCommSemigroup \u211a := by infer_instance", "start": [369, 1], "end": [369, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.addSemigroup", "code": "instance addSemigroup : AddSemigroup \u211a := by infer_instance", "start": [371, 1], "end": [371, 60], "kind": "commanddeclaration"}, {"full_name": "Rat.commMonoid", "code": "instance commMonoid : CommMonoid \u211a := by infer_instance", "start": [373, 1], "end": [373, 56], "kind": "commanddeclaration"}, {"full_name": "Rat.monoid", "code": "instance monoid : Monoid \u211a := by infer_instance", "start": [375, 1], "end": [375, 48], "kind": "commanddeclaration"}, {"full_name": "Rat.commSemigroup", "code": "instance commSemigroup : CommSemigroup \u211a := by infer_instance", "start": [377, 1], "end": [377, 62], "kind": "commanddeclaration"}, {"full_name": "Rat.semigroup", "code": "instance semigroup : Semigroup \u211a := by infer_instance", "start": [379, 1], "end": [379, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.eq_iff_mul_eq_mul", "code": "theorem eq_iff_mul_eq_mul {p q : \u211a} : p = q \u2194 p.num * q.den = q.num * p.den", "start": [383, 1], "end": [389, 19], "kind": "commanddeclaration"}, {"full_name": "Rat.den_neg_eq_den", "code": "@[simp]\ntheorem den_neg_eq_den (q : \u211a) : (-q).den = q.den", "start": [392, 1], "end": [394, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.num_neg_eq_neg_num", "code": "@[simp]\ntheorem num_neg_eq_neg_num (q : \u211a) : (-q).num = -q.num", "start": [397, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.num_zero", "code": "@[simp]\ntheorem num_zero : Rat.num 0 = 0", "start": [402, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.den_zero", "code": "@[simp]\ntheorem den_zero : Rat.den 0 = 1", "start": [407, 1], "end": [409, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_of_num_zero", "code": "theorem zero_of_num_zero {q : \u211a} (hq : q.num = 0) : q = 0", "start": [412, 1], "end": [414, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.zero_iff_num_zero", "code": "theorem zero_iff_num_zero {q : \u211a} : q = 0 \u2194 q.num = 0", "start": [417, 1], "end": [418, 43], "kind": "commanddeclaration"}, {"full_name": "Rat.num_ne_zero_of_ne_zero", "code": "theorem num_ne_zero_of_ne_zero {q : \u211a} (h : q \u2260 0) : q.num \u2260 0", "start": [421, 1], "end": [422, 28], "kind": "commanddeclaration"}, {"full_name": "Rat.num_one", "code": "@[simp]\ntheorem num_one : (1 : \u211a).num = 1", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.den_one", "code": "@[simp]\ntheorem den_one : (1 : \u211a).den = 1", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.mk_num_ne_zero_of_ne_zero", "code": "theorem mk_num_ne_zero_of_ne_zero {q : \u211a} {n d : \u2124} (hq : q \u2260 0) (hqnd : q = n /. d) : n \u2260 0", "start": [435, 1], "end": [436, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.mk_denom_ne_zero_of_ne_zero", "code": "theorem mk_denom_ne_zero_of_ne_zero {q : \u211a} {n d : \u2124} (hq : q \u2260 0) (hqnd : q = n /. d) : d \u2260 0", "start": [439, 1], "end": [440, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_ne_zero_of_ne_zero", "code": "theorem divInt_ne_zero_of_ne_zero {n d : \u2124} (h : n \u2260 0) (hd : d \u2260 0) : n /. d \u2260 0", "start": [443, 1], "end": [444, 28], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_num_den", "code": "theorem mul_num_den (q r : \u211a) : q * r = q.num * r.num /. \u2191(q.den * r.den)", "start": [447, 1], "end": [452, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.div_num_den", "code": "theorem div_num_den (q r : \u211a) : q / r = q.num * r.den /. (q.den * r.num)", "start": [455, 1], "end": [464, 84], "kind": "commanddeclaration"}, {"full_name": "Rat.add_divInt", "code": "protected theorem add_divInt (a b c : \u2124) : (a + b) /. c = a /. c + b /. c", "start": [469, 1], "end": [473, 30], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_eq_div", "code": "theorem divInt_eq_div (n d : \u2124) : n /. d = (n : \u211a) / d", "start": [476, 1], "end": [479, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_mul_divInt_cancel", "code": "theorem divInt_mul_divInt_cancel {x : \u2124} (hx : x \u2260 0) (n d : \u2124) : n /. x * (x /. d) = n /. d", "start": [482, 1], "end": [486, 55], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_div_divInt_cancel_left", "code": "theorem divInt_div_divInt_cancel_left {x : \u2124} (hx : x \u2260 0) (n d : \u2124) :\n    n /. x / (d /. x) = n /. d", "start": [489, 1], "end": [491, 61], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_div_divInt_cancel_right", "code": "theorem divInt_div_divInt_cancel_right {x : \u2124} (hx : x \u2260 0) (n d : \u2124) :\n    x /. n / (x /. d) = d /. n", "start": [494, 1], "end": [496, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_div_eq_divInt", "code": "theorem coe_int_div_eq_divInt {n d : \u2124} : (n : \u211a) / (d) = n /. d", "start": [499, 1], "end": [501, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.num_div_den", "code": "theorem num_div_den (r : \u211a) : (r.num : \u211a) / (r.den : \u211a) = r", "start": [505, 1], "end": [507, 33], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_num_of_den_eq_one", "code": "theorem coe_int_num_of_den_eq_one {q : \u211a} (hq : q.den = 1) : (q.num : \u211a) = q", "start": [510, 1], "end": [513, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.eq_num_of_isInt", "code": "lemma eq_num_of_isInt {q : \u211a} (h : q.isInt) : q = q.num := by\n  rw [Rat.isInt, Nat.beq_eq_true_eq] at h\n  exact (Rat.coe_int_num_of_den_eq_one h).symm", "start": [516, 1], "end": [518, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Rat.den_eq_one_iff", "code": "theorem den_eq_one_iff (r : \u211a) : r.den = 1 \u2194 \u2191r.num = r", "start": [520, 1], "end": [521, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.canLift", "code": "instance canLift : CanLift \u211a \u2124 (\u2191) fun q => q.den = 1 :=\n  \u27e8fun q hq => \u27e8q.num, coe_int_num_of_den_eq_one hq\u27e9\u27e9", "start": [524, 1], "end": [525, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nat_eq_divInt", "code": "theorem coe_nat_eq_divInt (n : \u2115) : \u2191n = n /. 1", "start": [528, 1], "end": [529, 43], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nat_num", "code": "@[simp, norm_cast]\ntheorem coe_nat_num (n : \u2115) : (n : \u211a).num = n", "start": [532, 1], "end": [534, 37], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nat_den", "code": "@[simp, norm_cast]\ntheorem coe_nat_den (n : \u2115) : (n : \u211a).den = 1", "start": [537, 1], "end": [539, 37], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_inj", "code": "theorem coe_int_inj (m n : \u2124) : (m : \u211a) = n \u2194 m = n", "start": [544, 1], "end": [545, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.mkRat_eq_div", "code": "theorem mkRat_eq_div {n : \u2124} {d : \u2115} : mkRat n d = n / d", "start": [550, 1], "end": [559, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Sum.lean", "imports": ["Mathlib/Data/Multiset/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.disjSum", "code": "def disjSum : Multiset (Sum \u03b1 \u03b2) :=\n  s.map inl + t.map inr", "start": [28, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.zero_disjSum", "code": "@[simp]\ntheorem zero_disjSum : (0 : Multiset \u03b1).disjSum t = t.map inr", "start": [33, 1], "end": [35, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_zero", "code": "@[simp]\ntheorem disjSum_zero : s.disjSum (0 : Multiset \u03b2) = s.map inl", "start": [38, 1], "end": [40, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_disjSum", "code": "@[simp]\ntheorem card_disjSum : Multiset.card (s.disjSum t) = Multiset.card s + Multiset.card t", "start": [43, 1], "end": [45, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_disjSum", "code": "theorem mem_disjSum : x \u2208 s.disjSum t \u2194 (\u2203 a, a \u2208 s \u2227 inl a = x) \u2228 \u2203 b, b \u2208 t \u2227 inr b = x", "start": [50, 1], "end": [51, 38], "kind": "commanddeclaration"}, {"full_name": "Multiset.inl_mem_disjSum", "code": "@[simp]\ntheorem inl_mem_disjSum : inl a \u2208 s.disjSum t \u2194 a \u2208 s", "start": [54, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.inr_mem_disjSum", "code": "@[simp]\ntheorem inr_mem_disjSum : inr b \u2208 s.disjSum t \u2194 b \u2208 t", "start": [63, 1], "end": [69, 22], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_mono", "code": "theorem disjSum_mono (hs : s\u2081 \u2264 s\u2082) (ht : t\u2081 \u2264 t\u2082) : s\u2081.disjSum t\u2081 \u2264 s\u2082.disjSum t\u2082", "start": [72, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_mono_left", "code": "theorem disjSum_mono_left (t : Multiset \u03b2) : Monotone fun s : Multiset \u03b1 => s.disjSum t", "start": [76, 1], "end": [77, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_mono_right", "code": "theorem disjSum_mono_right (s : Multiset \u03b1) :\n    Monotone (s.disjSum : Multiset \u03b2 \u2192 Multiset (Sum \u03b1 \u03b2))", "start": [80, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_lt_disjSum_of_lt_of_le", "code": "theorem disjSum_lt_disjSum_of_lt_of_le (hs : s\u2081 < s\u2082) (ht : t\u2081 \u2264 t\u2082) :\n    s\u2081.disjSum t\u2081 < s\u2082.disjSum t\u2082", "start": [85, 1], "end": [87, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_lt_disjSum_of_le_of_lt", "code": "theorem disjSum_lt_disjSum_of_le_of_lt (hs : s\u2081 \u2264 s\u2082) (ht : t\u2081 < t\u2082) :\n    s\u2081.disjSum t\u2081 < s\u2082.disjSum t\u2082", "start": [90, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_strictMono_left", "code": "theorem disjSum_strictMono_left (t : Multiset \u03b2) : StrictMono fun s : Multiset \u03b1 => s.disjSum t", "start": [95, 1], "end": [96, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjSum_strictMono_right", "code": "theorem disjSum_strictMono_right (s : Multiset \u03b1) :\n    StrictMono (s.disjSum : Multiset \u03b2 \u2192 Multiset (Sum \u03b1 \u03b2))", "start": [99, 1], "end": [101, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.disjSum", "code": "protected theorem Nodup.disjSum (hs : s.Nodup) (ht : t.Nodup) : (s.disjSum t).Nodup", "start": [104, 1], "end": [109, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Basic.lean", "imports": ["Mathlib/Data/Finset/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fintype", "code": "class Fintype (\u03b1 : Type*) where\n  \n  elems : Finset \u03b1\n  \n  complete : \u2200 x : \u03b1, x \u2208 elems", "start": [50, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.univ", "code": "def univ : Finset \u03b1 :=\n  @Fintype.elems \u03b1 _", "start": [65, 1], "end": [68, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_univ", "code": "@[simp]\ntheorem mem_univ (x : \u03b1) : x \u2208 (univ : Finset \u03b1)", "start": [71, 1], "end": [73, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_univ_val", "code": "theorem mem_univ_val : \u2200 x, x \u2208 (univ : Finset \u03b1).1", "start": [77, 1], "end": [78, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_univ_iff_forall", "code": "theorem eq_univ_iff_forall : s = univ \u2194 \u2200 x, x \u2208 s", "start": [81, 1], "end": [81, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_univ_of_forall", "code": "theorem eq_univ_of_forall : (\u2200 x, x \u2208 s) \u2192 s = univ", "start": [84, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_univ", "code": "@[simp, norm_cast]\ntheorem coe_univ : \u2191(univ : Finset \u03b1) = (Set.univ : Set \u03b1)", "start": [88, 1], "end": [89, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_eq_univ", "code": "@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set \u03b1) = Set.univ \u2194 s = univ", "start": [92, 1], "end": [93, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.eq_univ", "code": "theorem Nonempty.eq_univ [Subsingleton \u03b1] : s.Nonempty \u2192 s = univ", "start": [96, 1], "end": [98, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_nonempty_iff", "code": "theorem univ_nonempty_iff : (univ : Finset \u03b1).Nonempty \u2194 Nonempty \u03b1", "start": [101, 1], "end": [102, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_nonempty", "code": "theorem univ_nonempty [Nonempty \u03b1] : (univ : Finset \u03b1).Nonempty", "start": [105, 1], "end": [106, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_eq_empty_iff", "code": "theorem univ_eq_empty_iff : (univ : Finset \u03b1) = \u2205 \u2194 IsEmpty \u03b1", "start": [109, 1], "end": [110, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_eq_empty", "code": "@[simp]\ntheorem univ_eq_empty [IsEmpty \u03b1] : (univ : Finset \u03b1) = \u2205", "start": [113, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_unique", "code": "@[simp]\ntheorem univ_unique [Unique \u03b1] : (univ : Finset \u03b1) = {default}", "start": [118, 1], "end": [120, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_univ", "code": "@[simp]\ntheorem subset_univ (s : Finset \u03b1) : s \u2286 univ", "start": [123, 1], "end": [124, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.boundedOrder", "code": "instance boundedOrder : BoundedOrder (Finset \u03b1) :=\n  { inferInstanceAs (OrderBot (Finset \u03b1)) with\n    top := univ\n    le_top := subset_univ }", "start": [127, 1], "end": [130, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.top_eq_univ", "code": "@[simp]\ntheorem top_eq_univ : (\u22a4 : Finset \u03b1) = univ", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubset_univ_iff", "code": "theorem ssubset_univ_iff {s : Finset \u03b1} : s \u2282 univ \u2194 s \u2260 univ", "start": [138, 1], "end": [139, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.codisjoint_left", "code": "theorem codisjoint_left : Codisjoint s t \u2194 \u2200 \u2983a\u2984, a \u2209 s \u2192 a \u2208 t", "start": [142, 1], "end": [143, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.codisjoint_right", "code": "theorem codisjoint_right : Codisjoint s t \u2194 \u2200 \u2983a\u2984, a \u2209 t \u2192 a \u2208 s", "start": [146, 1], "end": [147, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.booleanAlgebra", "code": "instance booleanAlgebra : BooleanAlgebra (Finset \u03b1) :=\n  GeneralizedBooleanAlgebra.toBooleanAlgebra", "start": [154, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sdiff_eq_inter_compl", "code": "theorem sdiff_eq_inter_compl (s t : Finset \u03b1) : s \\ t = s \u2229 t\u1d9c", "start": [158, 1], "end": [159, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_eq_univ_sdiff", "code": "theorem compl_eq_univ_sdiff (s : Finset \u03b1) : s\u1d9c = univ \\ s", "start": [162, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_compl", "code": "@[simp]\ntheorem mem_compl : a \u2208 s\u1d9c \u2194 a \u2209 s", "start": [166, 1], "end": [167, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_compl", "code": "theorem not_mem_compl : a \u2209 s\u1d9c \u2194 a \u2208 s", "start": [170, 1], "end": [170, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_compl", "code": "@[simp, norm_cast]\ntheorem coe_compl (s : Finset \u03b1) : \u2191s\u1d9c = (\u2191s : Set \u03b1)\u1d9c", "start": [173, 1], "end": [175, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_subset_compl", "code": "@[simp] lemma compl_subset_compl : s\u1d9c \u2286 t\u1d9c \u2194 t \u2286 s := @compl_le_compl_iff_le (Finset \u03b1) _ _ _", "start": [178, 1], "end": [178, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.compl_ssubset_compl", "code": "@[simp] lemma compl_ssubset_compl : s\u1d9c \u2282 t\u1d9c \u2194 t \u2282 s := @compl_lt_compl_iff_lt (Finset \u03b1) _ _ _", "start": [179, 1], "end": [179, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.compl_empty", "code": "@[simp]\ntheorem compl_empty : (\u2205 : Finset \u03b1)\u1d9c = univ", "start": [181, 1], "end": [183, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_univ", "code": "@[simp]\ntheorem compl_univ : (univ : Finset \u03b1)\u1d9c = \u2205", "start": [186, 1], "end": [188, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_eq_empty_iff", "code": "@[simp]\ntheorem compl_eq_empty_iff (s : Finset \u03b1) : s\u1d9c = \u2205 \u2194 s = univ", "start": [191, 1], "end": [193, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_eq_univ_iff", "code": "@[simp]\ntheorem compl_eq_univ_iff (s : Finset \u03b1) : s\u1d9c = univ \u2194 s = \u2205", "start": [196, 1], "end": [198, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.union_compl", "code": "@[simp]\ntheorem union_compl (s : Finset \u03b1) : s \u222a s\u1d9c = univ", "start": [201, 1], "end": [203, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_compl", "code": "@[simp]\ntheorem inter_compl (s : Finset \u03b1) : s \u2229 s\u1d9c = \u2205", "start": [206, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_union", "code": "@[simp]\ntheorem compl_union (s t : Finset \u03b1) : (s \u222a t)\u1d9c = s\u1d9c \u2229 t\u1d9c", "start": [211, 1], "end": [213, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_inter", "code": "@[simp]\ntheorem compl_inter (s t : Finset \u03b1) : (s \u2229 t)\u1d9c = s\u1d9c \u222a t\u1d9c", "start": [216, 1], "end": [218, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_erase", "code": "@[simp]\ntheorem compl_erase : (s.erase a)\u1d9c = insert a s\u1d9c", "start": [221, 1], "end": [224, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_insert", "code": "@[simp]\ntheorem compl_insert : (insert a s)\u1d9c = s\u1d9c.erase a", "start": [227, 1], "end": [230, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_compl_insert", "code": "theorem insert_compl_insert (ha : a \u2209 s) : insert a (insert a s)\u1d9c = s\u1d9c", "start": [233, 1], "end": [234, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_compl_self", "code": "@[simp]\ntheorem insert_compl_self (x : \u03b1) : insert x ({x}\u1d9c : Finset \u03b1) = univ", "start": [236, 1], "end": [238, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_filter", "code": "@[simp]\ntheorem compl_filter (p : \u03b1 \u2192 Prop) [DecidablePred p] [\u2200 x, Decidable \u00acp x] :\n    (univ.filter p)\u1d9c = univ.filter fun x => \u00acp x", "start": [241, 1], "end": [244, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_ne_univ_iff_nonempty", "code": "theorem compl_ne_univ_iff_nonempty (s : Finset \u03b1) : s\u1d9c \u2260 univ \u2194 s.Nonempty", "start": [247, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_singleton", "code": "theorem compl_singleton (a : \u03b1) : ({a} : Finset \u03b1)\u1d9c = univ.erase a", "start": [251, 1], "end": [252, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.insert_inj_on'", "code": "theorem insert_inj_on' (s : Finset \u03b1) : Set.InjOn (fun a => insert a s) (s\u1d9c : Finset \u03b1)", "start": [255, 1], "end": [257, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.image_univ_of_surjective", "code": "theorem image_univ_of_surjective [Fintype \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : Surjective f) :\n    univ.image f = univ", "start": [260, 1], "end": [262, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.image_univ_equiv", "code": "@[simp]\ntheorem image_univ_equiv [Fintype \u03b2] (f : \u03b2 \u2243 \u03b1) : univ.image f = univ", "start": [265, 1], "end": [267, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_inter", "code": "@[simp] lemma univ_inter (s : Finset \u03b1) : univ \u2229 s = s := by ext a; simp", "start": [269, 1], "end": [269, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inter_univ", "code": "@[simp] lemma inter_univ (s : Finset \u03b1) : s \u2229 univ = s := by rw [inter_comm, univ_inter]", "start": [272, 1], "end": [272, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inter_eq_univ", "code": "@[simp] lemma inter_eq_univ : s \u2229 t = univ \u2194 s = univ \u2227 t = univ := inf_eq_top_iff", "start": [275, 1], "end": [275, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.map_univ_of_surjective", "code": "theorem map_univ_of_surjective [Fintype \u03b2] {f : \u03b2 \u21aa \u03b1} (hf : Surjective f) : univ.map f = univ", "start": [279, 1], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.map_univ_equiv", "code": "@[simp]\ntheorem map_univ_equiv [Fintype \u03b2] (f : \u03b2 \u2243 \u03b1) : univ.map f.toEmbedding = univ", "start": [283, 1], "end": [285, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_univ", "code": "@[simp]\ntheorem piecewise_univ [\u2200 i : \u03b1, Decidable (i \u2208 (univ : Finset \u03b1))] {\u03b4 : \u03b1 \u2192 Sort*}\n    (f g : \u2200 i, \u03b4 i) : univ.piecewise f g = f", "start": [288, 1], "end": [292, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_compl", "code": "theorem piecewise_compl [DecidableEq \u03b1] (s : Finset \u03b1) [\u2200 i : \u03b1, Decidable (i \u2208 s)]\n    [\u2200 i : \u03b1, Decidable (i \u2208 s\u1d9c)] {\u03b4 : \u03b1 \u2192 Sort*} (f g : \u2200 i, \u03b4 i) :\n    s\u1d9c.piecewise f g = s.piecewise g f", "start": [295, 1], "end": [299, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.piecewise_erase_univ", "code": "@[simp]\ntheorem piecewise_erase_univ {\u03b4 : \u03b1 \u2192 Sort*} [DecidableEq \u03b1] (a : \u03b1) (f g : \u2200 a, \u03b4 a) :\n    (Finset.univ.erase a).piecewise f g = Function.update f a (g a)", "start": [302, 1], "end": [305, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_map_equiv_to_embedding", "code": "theorem univ_map_equiv_to_embedding {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] (e : \u03b1 \u2243 \u03b2) :\n    univ.map e.toEmbedding = univ", "start": [308, 1], "end": [310, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_filter_exists", "code": "@[simp]\ntheorem univ_filter_exists (f : \u03b1 \u2192 \u03b2) [Fintype \u03b2] [DecidablePred fun y => \u2203 x, f x = y]\n    [DecidableEq \u03b2] : (Finset.univ.filter fun y => \u2203 x, f x = y) = Finset.univ.image f", "start": [313, 1], "end": [317, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_filter_mem_range", "code": "theorem univ_filter_mem_range (f : \u03b1 \u2192 \u03b2) [Fintype \u03b2] [DecidablePred fun y => y \u2208 Set.range f]\n    [DecidableEq \u03b2] : (Finset.univ.filter fun y => y \u2208 Set.range f) = Finset.univ.image f", "start": [320, 1], "end": [324, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_filter_univ", "code": "theorem coe_filter_univ (p : \u03b1 \u2192 Prop) [DecidablePred p] : (univ.filter p : Set \u03b1) = { x | p x }", "start": [327, 1], "end": [328, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_eq_univ", "code": "@[simp] lemma subtype_eq_univ {p : \u03b1 \u2192 Prop} [DecidablePred p] [Fintype {a // p a}] :\n    s.subtype p = univ \u2194 \u2200 \u2983a\u2984, p a \u2192 a \u2208 s := by simp [ext_iff]", "start": [331, 1], "end": [332, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.subtype_univ", "code": "@[simp] lemma subtype_univ [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] [Fintype {a // p a}] :\n    univ.subtype p = univ := by simp", "start": [334, 1], "end": [335, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.decidablePiFintype", "code": "instance decidablePiFintype {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, DecidableEq (\u03b2 a)] [Fintype \u03b1] :\n    DecidableEq (\u2200 a, \u03b2 a) := fun f g =>\n  decidable_of_iff (\u2200 a \u2208 @Fintype.elems \u03b1 _, f a = g a)\n    (by simp [Function.funext_iff, Fintype.complete])", "start": [343, 1], "end": [346, 54], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableForallFintype", "code": "instance decidableForallFintype {p : \u03b1 \u2192 Prop} [DecidablePred p] [Fintype \u03b1] :\n    Decidable (\u2200 a, p a) :=\n  decidable_of_iff (\u2200 a \u2208 @univ \u03b1 _, p a) (by simp)", "start": [349, 1], "end": [351, 52], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableExistsFintype", "code": "instance decidableExistsFintype {p : \u03b1 \u2192 Prop} [DecidablePred p] [Fintype \u03b1] :\n    Decidable (\u2203 a, p a) :=\n  decidable_of_iff (\u2203 a \u2208 @univ \u03b1 _, p a) (by simp)", "start": [354, 1], "end": [356, 52], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableMemRangeFintype", "code": "instance decidableMemRangeFintype [Fintype \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    DecidablePred (\u00b7 \u2208 Set.range f) := fun _ => Fintype.decidableExistsFintype", "start": [359, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqEquivFintype", "code": "instance decidableEqEquivFintype [DecidableEq \u03b2] [Fintype \u03b1] : DecidableEq (\u03b1 \u2243 \u03b2) := fun a b =>\n  decidable_of_iff (a.1 = b.1) Equiv.coe_fn_injective.eq_iff", "start": [365, 1], "end": [366, 61], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqEmbeddingFintype", "code": "instance decidableEqEmbeddingFintype [DecidableEq \u03b2] [Fintype \u03b1] : DecidableEq (\u03b1 \u21aa \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) Function.Embedding.coe_injective.eq_iff", "start": [369, 1], "end": [370, 77], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqOneHomFintype", "code": "@[to_additive]\ninstance decidableEqOneHomFintype [DecidableEq \u03b2] [Fintype \u03b1] [One \u03b1] [One \u03b2] :\n    DecidableEq (OneHom \u03b1 \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) (Injective.eq_iff FunLike.coe_injective)", "start": [373, 1], "end": [376, 78], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqMulHomFintype", "code": "@[to_additive]\ninstance decidableEqMulHomFintype [DecidableEq \u03b2] [Fintype \u03b1] [Mul \u03b1] [Mul \u03b2] :\n    DecidableEq (\u03b1 \u2192\u2099* \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) (Injective.eq_iff FunLike.coe_injective)", "start": [380, 1], "end": [383, 78], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqMonoidHomFintype", "code": "@[to_additive]\ninstance decidableEqMonoidHomFintype [DecidableEq \u03b2] [Fintype \u03b1] [MulOneClass \u03b1] [MulOneClass \u03b2] :\n    DecidableEq (\u03b1 \u2192* \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) (Injective.eq_iff FunLike.coe_injective)", "start": [387, 1], "end": [390, 78], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqMonoidWithZeroHomFintype", "code": "instance decidableEqMonoidWithZeroHomFintype [DecidableEq \u03b2] [Fintype \u03b1] [MulZeroOneClass \u03b1]\n    [MulZeroOneClass \u03b2] : DecidableEq (\u03b1 \u2192*\u2080 \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) (Injective.eq_iff FunLike.coe_injective)", "start": [394, 1], "end": [396, 78], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableEqRingHomFintype", "code": "instance decidableEqRingHomFintype [DecidableEq \u03b2] [Fintype \u03b1] [Semiring \u03b1] [Semiring \u03b2] :\n    DecidableEq (\u03b1 \u2192+* \u03b2) := fun a b =>\n  decidable_of_iff ((a : \u03b1 \u2192 \u03b2) = b) (Injective.eq_iff RingHom.coe_inj)", "start": [399, 1], "end": [401, 72], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableInjectiveFintype", "code": "instance decidableInjectiveFintype [DecidableEq \u03b1] [DecidableEq \u03b2] [Fintype \u03b1] :\n    DecidablePred (Injective : (\u03b1 \u2192 \u03b2) \u2192 Prop) := fun x => by unfold Injective; infer_instance", "start": [406, 1], "end": [407, 95], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableSurjectiveFintype", "code": "instance decidableSurjectiveFintype [DecidableEq \u03b2] [Fintype \u03b1] [Fintype \u03b2] :\n    DecidablePred (Surjective : (\u03b1 \u2192 \u03b2) \u2192 Prop) := fun x => by unfold Surjective; infer_instance", "start": [410, 1], "end": [411, 97], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableBijectiveFintype", "code": "instance decidableBijectiveFintype [DecidableEq \u03b1] [DecidableEq \u03b2] [Fintype \u03b1] [Fintype \u03b2] :\n    DecidablePred (Bijective : (\u03b1 \u2192 \u03b2) \u2192 Prop) := fun x => by unfold Bijective; infer_instance", "start": [414, 1], "end": [415, 95], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableRightInverseFintype", "code": "instance decidableRightInverseFintype [DecidableEq \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    Decidable (Function.RightInverse f g) :=\n  show Decidable (\u2200 x, g (f x) = x) by infer_instance", "start": [418, 1], "end": [420, 54], "kind": "commanddeclaration"}, {"full_name": "Fintype.decidableLeftInverseFintype", "code": "instance decidableLeftInverseFintype [DecidableEq \u03b2] [Fintype \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    Decidable (Function.LeftInverse f g) :=\n  show Decidable (\u2200 x, f (g x) = x) by infer_instance", "start": [423, 1], "end": [425, 54], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofMultiset", "code": "def ofMultiset [DecidableEq \u03b1] (s : Multiset \u03b1) (H : \u2200 x : \u03b1, x \u2208 s) : Fintype \u03b1 :=\n  \u27e8s.toFinset, by simpa using H\u27e9", "start": [428, 1], "end": [430, 33], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofList", "code": "def ofList [DecidableEq \u03b1] (l : List \u03b1) (H : \u2200 x : \u03b1, x \u2208 l) : Fintype \u03b1 :=\n  \u27e8l.toFinset, by simpa using H\u27e9", "start": [433, 1], "end": [435, 33], "kind": "commanddeclaration"}, {"full_name": "Fintype.subsingleton", "code": "instance subsingleton (\u03b1 : Type*) : Subsingleton (Fintype \u03b1) :=\n  \u27e8fun \u27e8s\u2081, h\u2081\u27e9 \u27e8s\u2082, h\u2082\u27e9 => by congr; simp [Finset.ext_iff, h\u2081, h\u2082]\u27e9", "start": [438, 1], "end": [439, 69], "kind": "commanddeclaration"}, {"full_name": "Fintype.subtype", "code": "protected def subtype {p : \u03b1 \u2192 Prop} (s : Finset \u03b1) (H : \u2200 x : \u03b1, x \u2208 s \u2194 p x) :\n    Fintype { x // p x } :=\n  \u27e8\u27e8s.1.pmap Subtype.mk fun x => (H x).1, s.nodup.pmap fun _ _ _ _ => congr_arg Subtype.val\u27e9,\n    fun \u27e8x, px\u27e9 => Multiset.mem_pmap.2 \u27e8x, (H x).2 px, rfl\u27e9\u27e9", "start": [442, 1], "end": [447, 61], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofFinset", "code": "def ofFinset {p : Set \u03b1} (s : Finset \u03b1) (H : \u2200 x, x \u2208 s \u2194 x \u2208 p) : Fintype p :=\n  Fintype.subtype s H", "start": [450, 1], "end": [452, 22], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofBijective", "code": "def ofBijective [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2) (H : Function.Bijective f) : Fintype \u03b2 :=\n  \u27e8univ.map \u27e8f, H.1\u27e9, fun b =>\n    let \u27e8_, e\u27e9 := H.2 b\n    e \u25b8 mem_map_of_mem _ (mem_univ _)\u27e9", "start": [455, 1], "end": [459, 39], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofSurjective", "code": "def ofSurjective [DecidableEq \u03b2] [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2) (H : Function.Surjective f) : Fintype \u03b2 :=\n  \u27e8univ.image f, fun b =>\n    let \u27e8_, e\u27e9 := H b\n    e \u25b8 mem_image_of_mem _ (mem_univ _)\u27e9", "start": [462, 1], "end": [466, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableCodisjoint", "code": "instance decidableCodisjoint : Decidable (Codisjoint s t) :=\n  decidable_of_iff _ codisjoint_left.symm", "start": [475, 1], "end": [476, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableIsCompl", "code": "instance decidableIsCompl : Decidable (IsCompl s t) :=\n  decidable_of_iff' _ isCompl_iff", "start": [479, 1], "end": [480, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.invOfMemRange", "code": "def invOfMemRange : Set.range f \u2192 \u03b1 := fun b =>\n  Finset.choose (fun a => f a = b) Finset.univ\n    ((exists_unique_congr (by simp)).mp (hf.exists_unique_of_mem_range b.property))", "start": [495, 1], "end": [505, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.left_inv_of_invOfMemRange", "code": "theorem left_inv_of_invOfMemRange (b : Set.range f) : f (hf.invOfMemRange b) = b", "start": [508, 1], "end": [509, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.right_inv_of_invOfMemRange", "code": "@[simp]\ntheorem right_inv_of_invOfMemRange (a : \u03b1) : hf.invOfMemRange \u27e8f a, Set.mem_range_self a\u27e9 = a", "start": [512, 1], "end": [514, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.invFun_restrict", "code": "theorem invFun_restrict [Nonempty \u03b1] : (Set.range f).restrict (invFun f) = hf.invOfMemRange", "start": [517, 1], "end": [520, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.invOfMemRange_surjective", "code": "theorem invOfMemRange_surjective : Function.Surjective hf.invOfMemRange", "start": [523, 1], "end": [524, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.invOfMemRange", "code": "def invOfMemRange : \u03b1 :=\n  f.injective.invOfMemRange b", "start": [533, 1], "end": [542, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.left_inv_of_invOfMemRange", "code": "@[simp]\ntheorem left_inv_of_invOfMemRange : f (f.invOfMemRange b) = b", "start": [545, 1], "end": [547, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.right_inv_of_invOfMemRange", "code": "@[simp]\ntheorem right_inv_of_invOfMemRange (a : \u03b1) : f.invOfMemRange \u27e8f a, Set.mem_range_self a\u27e9 = a", "start": [550, 1], "end": [552, 43], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.invFun_restrict", "code": "theorem invFun_restrict [Nonempty \u03b1] : (Set.range f).restrict (invFun f) = f.invOfMemRange", "start": [555, 1], "end": [558, 80], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.invOfMemRange_surjective", "code": "theorem invOfMemRange_surjective : Function.Surjective f.invOfMemRange", "start": [561, 1], "end": [562, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofInjective", "code": "noncomputable def ofInjective [Fintype \u03b2] (f : \u03b1 \u2192 \u03b2) (H : Function.Injective f) : Fintype \u03b1 :=\n  letI := Classical.dec\n  if h\u03b1 : Nonempty \u03b1 then\n    letI := Classical.inhabited_of_nonempty h\u03b1\n    ofSurjective (invFun f) (invFun_surjective H)\n  else \u27e8\u2205, fun x => (h\u03b1 \u27e8x\u27e9).elim\u27e9", "start": [573, 1], "end": [581, 35], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofEquiv", "code": "def ofEquiv (\u03b1 : Type*) [Fintype \u03b1] (f : \u03b1 \u2243 \u03b2) : Fintype \u03b2 :=\n  ofBijective _ f.bijective", "start": [584, 1], "end": [586, 28], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofSubsingleton", "code": "def ofSubsingleton (a : \u03b1) [Subsingleton \u03b1] : Fintype \u03b1 :=\n  \u27e8{a}, fun _ => Finset.mem_singleton.2 (Subsingleton.elim _ _)\u27e9", "start": [589, 1], "end": [591, 65], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_ofSubsingleton", "code": "@[simp]\ntheorem univ_ofSubsingleton (a : \u03b1) [Subsingleton \u03b1] : @univ _ (ofSubsingleton a) = {a}", "start": [594, 1], "end": [596, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofIsEmpty", "code": "instance (priority := 100) ofIsEmpty [IsEmpty \u03b1] : Fintype \u03b1 :=\n  \u27e8\u2205, isEmptyElim\u27e9", "start": [600, 1], "end": [601, 19], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_of_isEmpty", "code": "@[simp, nolint simpNF]\ntheorem univ_of_isEmpty [IsEmpty \u03b1] : @univ \u03b1 _ = \u2205", "start": [605, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset", "code": "def toFinset (s : Set \u03b1) [Fintype s] : Finset \u03b1 :=\n  (@Finset.univ s _).map <| Function.Embedding.subtype _", "start": [618, 1], "end": [620, 57], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_congr", "code": "@[congr]\ntheorem toFinset_congr {s t : Set \u03b1} [Fintype s] [Fintype t] (h : s = t) :\n    toFinset s = toFinset t", "start": [623, 1], "end": [625, 78], "kind": "commanddeclaration"}, {"full_name": "Set.mem_toFinset", "code": "@[simp]\ntheorem mem_toFinset {s : Set \u03b1} [Fintype s] {a : \u03b1} : a \u2208 s.toFinset \u2194 a \u2208 s", "start": [628, 1], "end": [630, 18], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_ofFinset", "code": "theorem toFinset_ofFinset {p : Set \u03b1} (s : Finset \u03b1) (H : \u2200 x, x \u2208 s \u2194 x \u2208 p) :\n    @Set.toFinset _ p (Fintype.ofFinset s H) = s", "start": [633, 1], "end": [637, 58], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemOfFintype", "code": "def decidableMemOfFintype [DecidableEq \u03b1] (s : Set \u03b1) [Fintype s] (a) : Decidable (a \u2208 s) :=\n  decidable_of_iff _ mem_toFinset", "start": [640, 1], "end": [645, 34], "kind": "commanddeclaration"}, {"full_name": "Set.coe_toFinset", "code": "@[simp]\ntheorem coe_toFinset (s : Set \u03b1) [Fintype s] : (\u2191s.toFinset : Set \u03b1) = s", "start": [648, 1], "end": [650, 32], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_nonempty", "code": "@[simp]\ntheorem toFinset_nonempty {s : Set \u03b1} [Fintype s] : s.toFinset.Nonempty \u2194 s.Nonempty", "start": [653, 1], "end": [655, 43], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_inj", "code": "@[simp]\ntheorem toFinset_inj {s t : Set \u03b1} [Fintype s] [Fintype t] : s.toFinset = t.toFinset \u2194 s = t", "start": [658, 1], "end": [660, 80], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_subset_toFinset", "code": "@[mono]\ntheorem toFinset_subset_toFinset [Fintype s] [Fintype t] : s.toFinset \u2286 t.toFinset \u2194 s \u2286 t", "start": [663, 1], "end": [665, 43], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_ssubset", "code": "@[simp]\ntheorem toFinset_ssubset [Fintype s] {t : Finset \u03b1} : s.toFinset \u2282 t \u2194 s \u2282 t", "start": [668, 1], "end": [670, 42], "kind": "commanddeclaration"}, {"full_name": "Set.subset_toFinset", "code": "@[simp]\ntheorem subset_toFinset {s : Finset \u03b1} [Fintype t] : s \u2286 t.toFinset \u2194 \u2191s \u2286 t", "start": [673, 1], "end": [675, 41], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_toFinset", "code": "@[simp]\ntheorem ssubset_toFinset {s : Finset \u03b1} [Fintype t] : s \u2282 t.toFinset \u2194 \u2191s \u2282 t", "start": [678, 1], "end": [680, 42], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_ssubset_toFinset", "code": "@[mono]\ntheorem toFinset_ssubset_toFinset [Fintype s] [Fintype t] : s.toFinset \u2282 t.toFinset \u2194 s \u2282 t", "start": [683, 1], "end": [685, 72], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_subset", "code": "@[simp]\ntheorem toFinset_subset [Fintype s] {t : Finset \u03b1} : s.toFinset \u2286 t \u2194 s \u2286 t", "start": [688, 1], "end": [690, 41], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_mono", "code": "alias \u27e8_, toFinset_mono\u27e9 := toFinset_subset_toFinset", "start": [693, 1], "end": [693, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.toFinset_strict_mono", "code": "alias \u27e8_, toFinset_strict_mono\u27e9 := toFinset_ssubset_toFinset", "start": [696, 1], "end": [696, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.disjoint_toFinset", "code": "@[simp]\ntheorem disjoint_toFinset [Fintype s] [Fintype t] :\n    Disjoint s.toFinset t.toFinset \u2194 Disjoint s t", "start": [699, 1], "end": [701, 97], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_inter", "code": "@[simp]\ntheorem toFinset_inter [Fintype (s \u2229 t : Set _)] : (s \u2229 t).toFinset = s.toFinset \u2229 t.toFinset", "start": [708, 1], "end": [711, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_union", "code": "@[simp]\ntheorem toFinset_union [Fintype (s \u222a t : Set _)] : (s \u222a t).toFinset = s.toFinset \u222a t.toFinset", "start": [714, 1], "end": [717, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_diff", "code": "@[simp]\ntheorem toFinset_diff [Fintype (s \\ t : Set _)] : (s \\ t).toFinset = s.toFinset \\ t.toFinset", "start": [720, 1], "end": [723, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_symmDiff", "code": "@[simp]\ntheorem toFinset_symmDiff [Fintype (s \u2206 t : Set _)] :\n    (s \u2206 t).toFinset = s.toFinset \u2206 t.toFinset", "start": [726, 1], "end": [730, 43], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_compl", "code": "@[simp]\ntheorem toFinset_compl [Fintype \u03b1] [Fintype (s\u1d9c : Set _)] : s\u1d9c.toFinset = s.toFinset\u1d9c", "start": [733, 1], "end": [736, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_empty", "code": "@[simp]\ntheorem toFinset_empty [Fintype (\u2205 : Set \u03b1)] : (\u2205 : Set \u03b1).toFinset = \u2205", "start": [742, 1], "end": [745, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_univ", "code": "@[simp]\ntheorem toFinset_univ [Fintype \u03b1] [Fintype (Set.univ : Set \u03b1)] :\n    (Set.univ : Set \u03b1).toFinset = Finset.univ", "start": [751, 1], "end": [755, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_eq_empty", "code": "@[simp]\ntheorem toFinset_eq_empty [Fintype s] : s.toFinset = \u2205 \u2194 s = \u2205", "start": [758, 1], "end": [760, 38], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_eq_univ", "code": "@[simp]\ntheorem toFinset_eq_univ [Fintype \u03b1] [Fintype s] : s.toFinset = Finset.univ \u2194 s = univ", "start": [763, 1], "end": [765, 41], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_setOf", "code": "@[simp]\ntheorem toFinset_setOf [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] [Fintype { x | p x }] :\n    { x | p x }.toFinset = Finset.univ.filter p", "start": [768, 1], "end": [772, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_ssubset_univ", "code": "theorem toFinset_ssubset_univ [Fintype \u03b1] {s : Set \u03b1} [Fintype s] :\n    s.toFinset \u2282 Finset.univ \u2194 s \u2282 univ", "start": [776, 1], "end": [777, 89], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_image", "code": "@[simp]\ntheorem toFinset_image [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) [Fintype s] [Fintype (f '' s)] :\n    (f '' s).toFinset = s.toFinset.image f", "start": [780, 1], "end": [783, 34], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_range", "code": "@[simp]\ntheorem toFinset_range [DecidableEq \u03b1] [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) [Fintype (Set.range f)] :\n    (Set.range f).toFinset = Finset.univ.image f", "start": [786, 1], "end": [790, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_singleton", "code": "@[simp] theorem toFinset_singleton (a : \u03b1) [Fintype ({a} : Set \u03b1)] : ({a} : Set \u03b1).toFinset = {a}", "start": [793, 1], "end": [796, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_insert", "code": "@[simp]\ntheorem toFinset_insert [DecidableEq \u03b1] {a : \u03b1} {s : Set \u03b1} [Fintype (insert a s : Set \u03b1)]\n    [Fintype s] : (insert a s).toFinset = insert a s.toFinset", "start": [799, 1], "end": [803, 7], "kind": "commanddeclaration"}, {"full_name": "Set.filter_mem_univ_eq_toFinset", "code": "theorem filter_mem_univ_eq_toFinset [Fintype \u03b1] (s : Set \u03b1) [Fintype s] [DecidablePred (\u00b7 \u2208 s)] :\n    Finset.univ.filter (\u00b7 \u2208 s) = s.toFinset", "start": [806, 1], "end": [810, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.toFinset_coe", "code": "@[simp]\ntheorem Finset.toFinset_coe (s : Finset \u03b1) [Fintype (s : Set \u03b1)] : (s : Set \u03b1).toFinset = s", "start": [815, 1], "end": [817, 32], "kind": "commanddeclaration"}, {"full_name": "Fin.fintype", "code": "instance Fin.fintype (n : \u2115) : Fintype (Fin n) :=\n  \u27e8\u27e8List.finRange n, List.nodup_finRange n\u27e9, List.mem_finRange\u27e9", "start": [820, 1], "end": [821, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.univ_def", "code": "theorem Fin.univ_def (n : \u2115) : (univ : Finset (Fin n)) = \u27e8List.finRange n, List.nodup_finRange n\u27e9", "start": [823, 1], "end": [824, 6], "kind": "commanddeclaration"}, {"full_name": "List.toFinset_finRange", "code": "@[simp] theorem List.toFinset_finRange (n : \u2115) : (List.finRange n).toFinset = Finset.univ", "start": [827, 1], "end": [828, 12], "kind": "commanddeclaration"}, {"full_name": "Fin.image_succAbove_univ", "code": "@[simp]\ntheorem Fin.image_succAbove_univ {n : \u2115} (i : Fin (n + 1)) : univ.image i.succAbove = {i}\u1d9c", "start": [830, 1], "end": [833, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.image_succ_univ", "code": "@[simp]\ntheorem Fin.image_succ_univ (n : \u2115) : (univ : Finset (Fin n)).image Fin.succ = {0}\u1d9c", "start": [836, 1], "end": [838, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.image_castSucc", "code": "@[simp]\ntheorem Fin.image_castSucc (n : \u2115) :\n    (univ : Finset (Fin n)).image Fin.castSucc = {Fin.last n}\u1d9c", "start": [841, 1], "end": [844, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.univ_succ", "code": "theorem Fin.univ_succ (n : \u2115) :\n    (univ : Finset (Fin (n + 1))) =\n      cons 0 (univ.map \u27e8Fin.succ, Fin.succ_injective _\u27e9) (by simp [map_eq_image])", "start": [849, 1], "end": [853, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.univ_castSuccEmb", "code": "theorem Fin.univ_castSuccEmb (n : \u2115) :\n    (univ : Finset (Fin (n + 1))) =\n      cons (Fin.last n) (univ.map Fin.castSuccEmb.toEmbedding) (by simp [map_eq_image])", "start": [856, 1], "end": [860, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.univ_succAbove", "code": "theorem Fin.univ_succAbove (n : \u2115) (p : Fin (n + 1)) :\n    (univ : Finset (Fin (n + 1))) =\n      cons p (univ.map <| (Fin.succAboveEmb p).toEmbedding) (by simp)", "start": [863, 1], "end": [868, 25], "kind": "commanddeclaration"}, {"full_name": "Unique.fintype", "code": "@[instance]\ndef Unique.fintype {\u03b1 : Type*} [Unique \u03b1] : Fintype \u03b1 :=\n  Fintype.ofSubsingleton default", "start": [871, 1], "end": [873, 33], "kind": "commanddeclaration"}, {"full_name": "Fintype.subtypeEq", "code": "instance Fintype.subtypeEq (y : \u03b1) : Fintype { x // x = y } :=\n  Fintype.subtype {y} (by simp)", "start": [876, 1], "end": [879, 32], "kind": "commanddeclaration"}, {"full_name": "Fintype.subtypeEq'", "code": "instance Fintype.subtypeEq' (y : \u03b1) : Fintype { x // y = x } :=\n  Fintype.subtype {y} (by simp [eq_comm])", "start": [882, 1], "end": [885, 42], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_empty", "code": "theorem Fintype.univ_empty : @univ Empty _ = \u2205", "start": [889, 1], "end": [890, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_pempty", "code": "theorem Fintype.univ_pempty : @univ PEmpty _ = \u2205", "start": [894, 1], "end": [895, 6], "kind": "commanddeclaration"}, {"full_name": "Unit.fintype", "code": "instance Unit.fintype : Fintype Unit :=\n  Fintype.ofSubsingleton ()", "start": [898, 1], "end": [899, 28], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_unit", "code": "theorem Fintype.univ_unit : @univ Unit _ = {()}", "start": [902, 1], "end": [903, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.fintype", "code": "instance PUnit.fintype : Fintype PUnit :=\n  Fintype.ofSubsingleton PUnit.unit", "start": [906, 1], "end": [907, 36], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_punit", "code": "theorem Fintype.univ_punit : @univ PUnit _ = {PUnit.unit}", "start": [911, 1], "end": [912, 6], "kind": "commanddeclaration"}, {"full_name": "Bool.fintype", "code": "instance Bool.fintype : Fintype Bool :=\n  \u27e8\u27e8{true, false}, by simp\u27e9, fun x => by cases x <;> simp\u27e9", "start": [915, 1], "end": [916, 59], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_bool", "code": "@[simp]\ntheorem Fintype.univ_bool : @univ Bool _ = {true, false}", "start": [919, 1], "end": [921, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.fintype", "code": "instance Additive.fintype : \u2200 [Fintype \u03b1], Fintype (Additive \u03b1) :=\n  Fintype.ofEquiv \u03b1 Additive.ofMul", "start": [924, 1], "end": [925, 35], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.fintype", "code": "instance Multiplicative.fintype : \u2200 [Fintype \u03b1], Fintype (Multiplicative \u03b1) :=\n  Fintype.ofEquiv \u03b1 Multiplicative.ofAdd", "start": [928, 1], "end": [929, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.prodLeft", "code": "def Fintype.prodLeft {\u03b1 \u03b2} [DecidableEq \u03b1] [Fintype (\u03b1 \u00d7 \u03b2)] [Nonempty \u03b2] : Fintype \u03b1 :=\n  \u27e8(@univ (\u03b1 \u00d7 \u03b2) _).image Prod.fst, fun a => by simp\u27e9", "start": [932, 1], "end": [934, 55], "kind": "commanddeclaration"}, {"full_name": "Fintype.prodRight", "code": "def Fintype.prodRight {\u03b1 \u03b2} [DecidableEq \u03b2] [Fintype (\u03b1 \u00d7 \u03b2)] [Nonempty \u03b1] : Fintype \u03b2 :=\n  \u27e8(@univ (\u03b1 \u00d7 \u03b2) _).image Prod.snd, fun b => by simp\u27e9", "start": [937, 1], "end": [939, 55], "kind": "commanddeclaration"}, {"full_name": "ULift.fintype", "code": "instance ULift.fintype (\u03b1 : Type*) [Fintype \u03b1] : Fintype (ULift \u03b1) :=\n  Fintype.ofEquiv _ Equiv.ulift.symm", "start": [942, 1], "end": [943, 37], "kind": "commanddeclaration"}, {"full_name": "PLift.fintype", "code": "instance PLift.fintype (\u03b1 : Type*) [Fintype \u03b1] : Fintype (PLift \u03b1) :=\n  Fintype.ofEquiv _ Equiv.plift.symm", "start": [946, 1], "end": [947, 37], "kind": "commanddeclaration"}, {"full_name": "OrderDual.fintype", "code": "instance OrderDual.fintype (\u03b1 : Type*) [Fintype \u03b1] : Fintype \u03b1\u1d52\u1d48 :=\n  \u2039Fintype \u03b1\u203a", "start": [950, 1], "end": [951, 14], "kind": "commanddeclaration"}, {"full_name": "OrderDual.finite", "code": "instance OrderDual.finite (\u03b1 : Type*) [Finite \u03b1] : Finite \u03b1\u1d52\u1d48 :=\n  \u2039Finite \u03b1\u203a", "start": [954, 1], "end": [955, 13], "kind": "commanddeclaration"}, {"full_name": "Lex.fintype", "code": "instance Lex.fintype (\u03b1 : Type*) [Fintype \u03b1] : Fintype (Lex \u03b1) :=\n  \u2039Fintype \u03b1\u203a", "start": [958, 1], "end": [959, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.fintypeCoeSort", "code": "instance Finset.fintypeCoeSort {\u03b1 : Type u} (s : Finset \u03b1) : Fintype s :=\n  \u27e8s.attach, s.mem_attach\u27e9", "start": [967, 1], "end": [968, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_eq_attach", "code": "@[simp]\ntheorem Finset.univ_eq_attach {\u03b1 : Type u} (s : Finset \u03b1) : (univ : Finset s) = s.attach", "start": [971, 1], "end": [973, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.coe_image_univ", "code": "theorem Fintype.coe_image_univ [Fintype \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    \u2191(Finset.image f Finset.univ) = Set.range f", "start": [978, 1], "end": [981, 7], "kind": "commanddeclaration"}, {"full_name": "List.Subtype.fintype", "code": "instance List.Subtype.fintype [DecidableEq \u03b1] (l : List \u03b1) : Fintype { x // x \u2208 l } :=\n  Fintype.ofList l.attach l.mem_attach", "start": [984, 1], "end": [985, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.Subtype.fintype", "code": "instance Multiset.Subtype.fintype [DecidableEq \u03b1] (s : Multiset \u03b1) : Fintype { x // x \u2208 s } :=\n  Fintype.ofMultiset s.attach s.mem_attach", "start": [988, 1], "end": [989, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.Subtype.fintype", "code": "instance Finset.Subtype.fintype (s : Finset \u03b1) : Fintype { x // x \u2208 s } :=\n  \u27e8s.attach, s.mem_attach\u27e9", "start": [992, 1], "end": [993, 27], "kind": "commanddeclaration"}, {"full_name": "FinsetCoe.fintype", "code": "instance FinsetCoe.fintype (s : Finset \u03b1) : Fintype (\u2191s : Set \u03b1) :=\n  Finset.Subtype.fintype s", "start": [996, 1], "end": [997, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.attach_eq_univ", "code": "theorem Finset.attach_eq_univ {s : Finset \u03b1} : s.attach = Finset.univ", "start": [1000, 1], "end": [1001, 6], "kind": "commanddeclaration"}, {"full_name": "PLift.fintypeProp", "code": "instance PLift.fintypeProp (p : Prop) [Decidable p] : Fintype (PLift p) :=\n  \u27e8if h : p then {\u27e8h\u27e9} else \u2205, fun \u27e8h\u27e9 => by simp [h]\u27e9", "start": [1004, 1], "end": [1005, 55], "kind": "commanddeclaration"}, {"full_name": "Prop.fintype", "code": "instance Prop.fintype : Fintype Prop :=\n  \u27e8\u27e8{True, False}, by simp [true_ne_false]\u27e9, Classical.cases (by simp) (by simp)\u27e9", "start": [1008, 1], "end": [1009, 82], "kind": "commanddeclaration"}, {"full_name": "Fintype.univ_Prop", "code": "@[simp]\ntheorem Fintype.univ_Prop : (Finset.univ : Finset Prop) = {True, False}", "start": [1012, 1], "end": [1014, 35], "kind": "commanddeclaration"}, {"full_name": "Subtype.fintype", "code": "instance Subtype.fintype (p : \u03b1 \u2192 Prop) [DecidablePred p] [Fintype \u03b1] : Fintype { x // p x } :=\n  Fintype.subtype (univ.filter p) (by simp)", "start": [1017, 1], "end": [1018, 44], "kind": "commanddeclaration"}, {"full_name": "setFintype", "code": "def setFintype [Fintype \u03b1] (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)] : Fintype s :=\n  Subtype.fintype fun x => x \u2208 s", "start": [1021, 1], "end": [1023, 33], "kind": "commanddeclaration"}, {"full_name": "unitsEquivProdSubtype", "code": "@[simps]\ndef unitsEquivProdSubtype [Monoid \u03b1] : \u03b1\u02e3 \u2243 { p : \u03b1 \u00d7 \u03b1 // p.1 * p.2 = 1 \u2227 p.2 * p.1 = 1 }\n    where\n  toFun u := \u27e8(u, \u2191u\u207b\u00b9), u.val_inv, u.inv_val\u27e9\n  invFun p := Units.mk (p : \u03b1 \u00d7 \u03b1).1 (p : \u03b1 \u00d7 \u03b1).2 p.prop.1 p.prop.2\n  left_inv _ := Units.ext rfl\n  right_inv _ := Subtype.ext <| Prod.ext rfl rfl", "start": [1030, 1], "end": [1037, 49], "kind": "commanddeclaration"}, {"full_name": "unitsEquivNeZero", "code": "@[simps]\ndef unitsEquivNeZero [GroupWithZero \u03b1] : \u03b1\u02e3 \u2243 { a : \u03b1 // a \u2260 0 } :=\n  \u27e8fun a => \u27e8a, a.ne_zero\u27e9, fun a => Units.mk0 _ a.prop, fun _ => Units.ext rfl, fun _ =>\n    Subtype.ext rfl\u27e9", "start": [1041, 1], "end": [1046, 21], "kind": "commanddeclaration"}, {"full_name": "Fintype.finsetEquivSet", "code": "noncomputable def finsetEquivSet : Finset \u03b1 \u2243 Set \u03b1 where\n  toFun := (\u2191)\n  invFun := by classical exact fun s => s.toFinset\n  left_inv s := by convert Finset.toFinset_coe s\n  right_inv s := by classical exact s.coe_toFinset", "start": [1056, 1], "end": [1062, 51], "kind": "commanddeclaration"}, {"full_name": "Fintype.coe_finsetEquivSet", "code": "@[simp, norm_cast] lemma coe_finsetEquivSet : \u21d1finsetEquivSet = ((\u2191) : Finset \u03b1 \u2192 Set \u03b1) := rfl", "start": [1065, 1], "end": [1065, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.finsetEquivSet_apply", "code": "@[simp] lemma finsetEquivSet_apply (s : Finset \u03b1) : finsetEquivSet s = s := rfl", "start": [1067, 1], "end": [1067, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.finsetEquivSet_symm_apply", "code": "@[simp] lemma finsetEquivSet_symm_apply (s : Set \u03b1) [Fintype s] :\n    finsetEquivSet.symm s = s.toFinset := by\n  simp [finsetEquivSet]; congr; exact Subsingleton.elim _ _", "start": [1070, 1], "end": [1072, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.finsetOrderIsoSet", "code": "@[simps toEquiv]\nnoncomputable def finsetOrderIsoSet : Finset \u03b1 \u2243o Set \u03b1 where\n  toEquiv := finsetEquivSet\n  map_rel_iff' := Finset.coe_subset", "start": [1075, 1], "end": [1080, 36], "kind": "commanddeclaration"}, {"full_name": "Fintype.coe_finsetOrderIsoSet", "code": "@[simp, norm_cast]\nlemma coe_finsetOrderIsoSet : \u21d1finsetOrderIsoSet = ((\u2191) : Finset \u03b1 \u2192 Set \u03b1) := rfl", "start": [1082, 1], "end": [1083, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.coe_finsetOrderIsoSet_symm", "code": "@[simp] lemma coe_finsetOrderIsoSet_symm :\n    \u21d1(finsetOrderIsoSet : Finset \u03b1 \u2243o Set \u03b1).symm = \u21d1finsetEquivSet.symm := rfl", "start": [1085, 1], "end": [1086, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Quotient.fintype", "code": "instance Quotient.fintype [Fintype \u03b1] (s : Setoid \u03b1) [DecidableRel ((\u00b7 \u2248 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] :\n    Fintype (Quotient s) :=\n  Fintype.ofSurjective Quotient.mk'' fun x => Quotient.inductionOn x fun x => \u27e8x, rfl\u27e9", "start": [1090, 1], "end": [1092, 87], "kind": "commanddeclaration"}, {"full_name": "PSigma.fintypePropLeft", "code": "instance PSigma.fintypePropLeft {\u03b1 : Prop} {\u03b2 : \u03b1 \u2192 Type*} [Decidable \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    Fintype (\u03a3'a, \u03b2 a) :=\n  if h : \u03b1 then Fintype.ofEquiv (\u03b2 h) \u27e8fun x => \u27e8h, x\u27e9, PSigma.snd, fun _ => rfl, fun \u27e8_, _\u27e9 => rfl\u27e9\n  else \u27e8\u2205, fun x => (h x.1).elim\u27e9", "start": [1095, 1], "end": [1098, 34], "kind": "commanddeclaration"}, {"full_name": "PSigma.fintypePropRight", "code": "instance PSigma.fintypePropRight {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Prop} [\u2200 a, Decidable (\u03b2 a)] [Fintype \u03b1] :\n    Fintype (\u03a3'a, \u03b2 a) :=\n  Fintype.ofEquiv { a // \u03b2 a }\n    \u27e8fun \u27e8x, y\u27e9 => \u27e8x, y\u27e9, fun \u27e8x, y\u27e9 => \u27e8x, y\u27e9, fun \u27e8_, _\u27e9 => rfl, fun \u27e8_, _\u27e9 => rfl\u27e9", "start": [1101, 1], "end": [1104, 87], "kind": "commanddeclaration"}, {"full_name": "PSigma.fintypePropProp", "code": "instance PSigma.fintypePropProp {\u03b1 : Prop} {\u03b2 : \u03b1 \u2192 Prop} [Decidable \u03b1] [\u2200 a, Decidable (\u03b2 a)] :\n    Fintype (\u03a3'a, \u03b2 a) :=\n  if h : \u2203 a, \u03b2 a then \u27e8{\u27e8h.fst, h.snd\u27e9}, fun \u27e8_, _\u27e9 => by simp\u27e9 else \u27e8\u2205, fun \u27e8x, y\u27e9 =>\n    (h \u27e8x, y\u27e9).elim\u27e9", "start": [1107, 1], "end": [1110, 21], "kind": "commanddeclaration"}, {"full_name": "pfunFintype", "code": "instance pfunFintype (p : Prop) [Decidable p] (\u03b1 : p \u2192 Type*) [\u2200 hp, Fintype (\u03b1 hp)] :\n    Fintype (\u2200 hp : p, \u03b1 hp) :=\n  if hp : p then Fintype.ofEquiv (\u03b1 hp) \u27e8fun a _ => a, fun f => f hp, fun _ => rfl, fun _ => rfl\u27e9\n  else \u27e8singleton fun h => (hp h).elim, fun h => mem_singleton.2\n    (funext $ fun x => by contradiction)\u27e9", "start": [1113, 1], "end": [1117, 42], "kind": "commanddeclaration"}, {"full_name": "mem_image_univ_iff_mem_range", "code": "theorem mem_image_univ_iff_mem_range {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {b : \u03b2} : b \u2208 univ.image f \u2194 b \u2208 Set.range f", "start": [1120, 1], "end": [1121, 60], "kind": "commanddeclaration"}, {"full_name": "Fintype.chooseX", "code": "def chooseX (hp : \u2203! a : \u03b1, p a) : { a // p a } :=\n  \u27e8Finset.choose p univ (by simp; exact hp), Finset.choose_property _ _ _\u27e9", "start": [1132, 1], "end": [1135, 75], "kind": "commanddeclaration"}, {"full_name": "Fintype.choose", "code": "def choose (hp : \u2203! a, p a) : \u03b1 :=\n  chooseX p hp", "start": [1138, 1], "end": [1141, 15], "kind": "commanddeclaration"}, {"full_name": "Fintype.choose_spec", "code": "theorem choose_spec (hp : \u2203! a, p a) : p (choose p hp)", "start": [1144, 1], "end": [1145, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.choose_subtype_eq", "code": "theorem choose_subtype_eq {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [Fintype { a : \u03b1 // p a }] [DecidableEq \u03b1]\n    (x : { a : \u03b1 // p a })\n    (h : \u2203! a : { a // p a }, (a : \u03b1) = x :=\n      \u27e8x, rfl, fun y hy => by simpa [Subtype.ext_iff] using hy\u27e9) :\n    Fintype.choose (fun y : { a : \u03b1 // p a } => (y : \u03b1) = x) h = x", "start": [1149, 1], "end": [1154, 88], "kind": "commanddeclaration"}, {"full_name": "Fintype.bijInv", "code": "def bijInv (f_bij : Bijective f) (b : \u03b2) : \u03b1 :=\n  Fintype.choose (fun a => f a = b)\n    (by\n      rcases f_bij.right b with \u27e8a', fa_eq_b\u27e9\n      rw [\u2190 fa_eq_b]\n      exact \u27e8a', \u27e8rfl, fun a h => f_bij.left h\u27e9\u27e9)", "start": [1165, 1], "end": [1172, 50], "kind": "commanddeclaration"}, {"full_name": "Fintype.leftInverse_bijInv", "code": "theorem leftInverse_bijInv (f_bij : Bijective f) : LeftInverse (bijInv f_bij) f", "start": [1175, 1], "end": [1176, 52], "kind": "commanddeclaration"}, {"full_name": "Fintype.rightInverse_bijInv", "code": "theorem rightInverse_bijInv (f_bij : Bijective f) : RightInverse (bijInv f_bij) f", "start": [1179, 1], "end": [1180, 37], "kind": "commanddeclaration"}, {"full_name": "Fintype.bijective_bijInv", "code": "theorem bijective_bijInv (f_bij : Bijective f) : Bijective (bijInv f_bij)", "start": [1183, 1], "end": [1184, 73], "kind": "commanddeclaration"}, {"full_name": "truncOfMultisetExistsMem", "code": "def truncOfMultisetExistsMem {\u03b1} (s : Multiset \u03b1) : (\u2203 x, x \u2208 s) \u2192 Trunc \u03b1 :=\n  Quotient.recOnSubsingleton s fun l h =>\n    match l, h with\n    | [], _ => False.elim (by tauto)\n    | a :: _, _ => Trunc.mk a", "start": [1193, 1], "end": [1199, 30], "kind": "commanddeclaration"}, {"full_name": "truncOfNonemptyFintype", "code": "def truncOfNonemptyFintype (\u03b1) [Nonempty \u03b1] [Fintype \u03b1] : Trunc \u03b1 :=\n  truncOfMultisetExistsMem Finset.univ.val (by simp)", "start": [1202, 1], "end": [1205, 53], "kind": "commanddeclaration"}, {"full_name": "truncSigmaOfExists", "code": "def truncSigmaOfExists {\u03b1} [Fintype \u03b1] {P : \u03b1 \u2192 Prop} [DecidablePred P] (h : \u2203 a, P a) :\n    Trunc (\u03a3'a, P a) :=\n  @truncOfNonemptyFintype (\u03a3'a, P a) ((Exists.elim h) fun a ha => \u27e8\u27e8a, ha\u27e9\u27e9) _", "start": [1208, 1], "end": [1213, 79], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_univ", "code": "@[simp]\ntheorem count_univ (a : \u03b1) : count a Finset.univ.val = 1", "start": [1222, 1], "end": [1224, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_univ_val_equiv", "code": "@[simp]\ntheorem map_univ_val_equiv (e : \u03b1 \u2243 \u03b2) :\n    map e univ.val = univ.val", "start": [1227, 1], "end": [1230, 94], "kind": "commanddeclaration"}, {"full_name": "seqOfForallFinsetExistsAux", "code": "noncomputable def seqOfForallFinsetExistsAux {\u03b1 : Type*} [DecidableEq \u03b1] (P : \u03b1 \u2192 Prop)\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 s : Finset \u03b1, \u2203 y, (\u2200 x \u2208 s, P x) \u2192 P y \u2227 \u2200 x \u2208 s, r x y) : \u2115 \u2192 \u03b1\n  | n =>\n    Classical.choose\n      (h\n        (Finset.image (fun i : Fin n => seqOfForallFinsetExistsAux P r h i)\n          (Finset.univ : Finset (Fin n))))\n  decreasing_by exact i.2", "start": [1234, 1], "end": [1242, 26], "kind": "commanddeclaration"}, {"full_name": "exists_seq_of_forall_finset_exists", "code": "theorem exists_seq_of_forall_finset_exists {\u03b1 : Type*} (P : \u03b1 \u2192 Prop) (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 s : Finset \u03b1, (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y) :\n    \u2203 f : \u2115 \u2192 \u03b1, (\u2200 n, P (f n)) \u2227 \u2200 m n, m < n \u2192 r (f m) (f n)", "start": [1245, 1], "end": [1277, 64], "kind": "commanddeclaration"}, {"full_name": "exists_seq_of_forall_finset_exists'", "code": "theorem exists_seq_of_forall_finset_exists' {\u03b1 : Type*} (P : \u03b1 \u2192 Prop) (r : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    [IsSymm \u03b1 r] (h : \u2200 s : Finset \u03b1, (\u2200 x \u2208 s, P x) \u2192 \u2203 y, P y \u2227 \u2200 x \u2208 s, r x y) :\n    \u2203 f : \u2115 \u2192 \u03b1, (\u2200 n, P (f n)) \u2227 \u2200 m n, m \u2260 n \u2192 r (f m) (f n)", "start": [1280, 1], "end": [1296, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/NodupEquivFin.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Data/List/Duplicate.lean", "Mathlib/Data/List/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Nodup.getBijectionOfForallMemList", "code": "@[simps]\ndef getBijectionOfForallMemList (l : List \u03b1) (nd : l.Nodup) (h : \u2200 x : \u03b1, x \u2208 l) :\n    { f : Fin l.length \u2192 \u03b1 // Function.Bijective f } :=\n  \u27e8fun i => l.get i, fun _ _ h => Fin.ext <| (nd.nthLe_inj_iff _ _).1 h,\n   fun x =>\n    let \u27e8i, hl\u27e9 := List.mem_iff_get.1 (h x)\n    \u27e8i, hl\u27e9\u27e9", "start": [38, 1], "end": [47, 13], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.getEquiv", "code": "@[simps]\ndef getEquiv (l : List \u03b1) (H : Nodup l) : Fin (length l) \u2243 { x // x \u2208 l } where\n  toFun i := \u27e8get l i, get_mem l i i.2\u27e9\n  invFun x := \u27e8indexOf (\u2191x) l, indexOf_lt_length.2 x.2\u27e9\n  left_inv i := by simp only [List.get_indexOf, eq_self_iff_true, Fin.eta, Subtype.coe_mk, H]\n  right_inv x := by simp", "start": [52, 1], "end": [59, 25], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.getEquivOfForallMemList", "code": "@[simps]\ndef getEquivOfForallMemList (l : List \u03b1) (nd : l.Nodup) (h : \u2200 x : \u03b1, x \u2208 l) : Fin l.length \u2243 \u03b1\n    where\n  toFun i := l.get i\n  invFun a := \u27e8_, indexOf_lt_length.2 (h a)\u27e9\n  left_inv i := by simp [List.get_indexOf, nd]\n  right_inv a := by simp", "start": [62, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.get_mono", "code": "theorem get_mono (h : l.Sorted (\u00b7 \u2264 \u00b7)) : Monotone l.get", "start": [82, 1], "end": [82, 87], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.get_strictMono", "code": "theorem get_strictMono (h : l.Sorted (\u00b7 < \u00b7)) : StrictMono l.get", "start": [85, 1], "end": [85, 95], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.getIso", "code": "def getIso (l : List \u03b1) (H : Sorted (\u00b7 < \u00b7) l) : Fin (length l) \u2243o { x // x \u2208 l } where\n  toEquiv := H.nodup.getEquiv l\n  map_rel_iff' := H.get_strictMono.le_iff_le", "start": [90, 1], "end": [94, 45], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.coe_getIso_apply", "code": "@[simp]\ntheorem coe_getIso_apply : (H.getIso l i : \u03b1) = get l i", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "List.Sorted.coe_getIso_symm_apply", "code": "@[simp]\ntheorem coe_getIso_symm_apply : ((H.getIso l).symm x : \u2115) = indexOf (\u2191x) l", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "List.sublist_of_orderEmbedding_get?_eq", "code": "theorem sublist_of_orderEmbedding_get?_eq {l l' : List \u03b1} (f : \u2115 \u21aao \u2115)\n    (hf : \u2200 ix : \u2115, l.get? ix = l'.get? (f ix)) : l <+ l'", "start": [113, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "List.sublist_iff_exists_orderEmbedding_get?_eq", "code": "theorem sublist_iff_exists_orderEmbedding_get?_eq {l l' : List \u03b1} :\n    l <+ l' \u2194 \u2203 f : \u2115 \u21aao \u2115, \u2200 ix : \u2115, l.get? ix = l'.get? (f ix)", "start": [141, 1], "end": [162, 49], "kind": "commanddeclaration"}, {"full_name": "List.sublist_iff_exists_fin_orderEmbedding_get_eq", "code": "theorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List \u03b1} :\n    l <+ l' \u2194\n      \u2203 f : Fin l.length \u21aao Fin l'.length,\n        \u2200 ix : Fin l.length, l.get ix = l'.get (f ix)", "start": [165, 1], "end": [206, 25], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_iff_exists_distinct_get", "code": "theorem duplicate_iff_exists_distinct_get {l : List \u03b1} {x : \u03b1} :\n    l.Duplicate x \u2194\n      \u2203 (n m : Fin l.length) (_ : n < m),\n        x = l.get n \u2227 x = l.get m", "start": [209, 1], "end": [235, 25], "kind": "commanddeclaration"}, {"full_name": "List.duplicate_iff_exists_distinct_nthLe", "code": "@[deprecated duplicate_iff_exists_distinct_get]\ntheorem duplicate_iff_exists_distinct_nthLe {l : List \u03b1} {x : \u03b1} :\n    l.Duplicate x \u2194\n      \u2203 (n : \u2115) (hn : n < l.length) (m : \u2115) (hm : m < l.length) (_ : n < m),\n        x = l.nthLe n hn \u2227 x = l.nthLe m hm", "start": [237, 1], "end": [247, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Positivity.lean", "imports": ["Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Init/Data/Int/Order.lean", "Mathlib/Tactic/Positivity/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Multiset/Powerset.lean", "imports": ["Mathlib/Data/List/Sublists.lean", "Mathlib/Data/Multiset/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.powersetAux", "code": "def powersetAux (l : List \u03b1) : List (Multiset \u03b1) :=\n  (sublists l).map (\u2191)", "start": [27, 1], "end": [30, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux_eq_map_coe", "code": "theorem powersetAux_eq_map_coe {l : List \u03b1} : powersetAux l = (sublists l).map (\u2191)", "start": [33, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_powersetAux", "code": "@[simp]\ntheorem mem_powersetAux {l : List \u03b1} {s} : s \u2208 powersetAux l \u2194 s \u2264 \u2191l", "start": [37, 1], "end": [39, 80], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux'", "code": "def powersetAux' (l : List \u03b1) : List (Multiset \u03b1) :=\n  (sublists' l).map (\u2191)", "start": [42, 1], "end": [45, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux_perm_powersetAux'", "code": "theorem powersetAux_perm_powersetAux' {l : List \u03b1} : powersetAux l ~ powersetAux' l", "start": [48, 1], "end": [49, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux'_nil", "code": "@[simp]\ntheorem powersetAux'_nil : powersetAux' (@nil \u03b1) = [0]", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux'_cons", "code": "@[simp]\ntheorem powersetAux'_cons (a : \u03b1) (l : List \u03b1) :\n    powersetAux' (a :: l) = powersetAux' l ++ List.map (cons a) (powersetAux' l)", "start": [57, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset_aux'_perm", "code": "theorem powerset_aux'_perm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : powersetAux' l\u2081 ~ powersetAux' l\u2082", "start": [63, 1], "end": [73, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetAux_perm", "code": "theorem powersetAux_perm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) : powersetAux l\u2081 ~ powersetAux l\u2082", "start": [76, 1], "end": [78, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset", "code": "def powerset (s : Multiset \u03b1) : Multiset (Multiset \u03b1) :=\n  Quot.liftOn s\n    (fun l => (powersetAux l : Multiset (Multiset \u03b1)))\n    (fun _ _ h => Quot.sound (powersetAux_perm h))", "start": [82, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset_coe", "code": "theorem powerset_coe (l : List \u03b1) : @powerset \u03b1 l = ((sublists l).map (\u2191) : List (Multiset \u03b1))", "start": [89, 1], "end": [90, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset_coe'", "code": "@[simp]\ntheorem powerset_coe' (l : List \u03b1) : @powerset \u03b1 l = ((sublists' l).map (\u2191) : List (Multiset \u03b1))", "start": [93, 1], "end": [95, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset_zero", "code": "@[simp]\ntheorem powerset_zero : @powerset \u03b1 0 = {0}", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.powerset_cons", "code": "@[simp]\ntheorem powerset_cons (a : \u03b1) (s) : powerset (a ::\u2098 s) = powerset s + map (cons a) (powerset s)", "start": [103, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_powerset", "code": "@[simp]\ntheorem mem_powerset {s t : Multiset \u03b1} : s \u2208 powerset t \u2194 s \u2264 t", "start": [108, 1], "end": [110, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_single_le_powerset", "code": "theorem map_single_le_powerset (s : Multiset \u03b1) : s.map singleton \u2264 powerset s", "start": [113, 1], "end": [118, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_powerset", "code": "@[simp]\ntheorem card_powerset (s : Multiset \u03b1) : card (powerset s) = 2 ^ card s", "start": [121, 1], "end": [123, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.revzip_powersetAux", "code": "theorem revzip_powersetAux {l : List \u03b1} \u2983x\u2984 (h : x \u2208 revzip (powersetAux l)) : x.1 + x.2 = \u2191l", "start": [126, 1], "end": [130, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.revzip_powersetAux'", "code": "theorem revzip_powersetAux' {l : List \u03b1} \u2983x\u2984 (h : x \u2208 revzip (powersetAux' l)) :\n    x.1 + x.2 = \u2191l", "start": [133, 1], "end": [138, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.revzip_powersetAux_lemma", "code": "theorem revzip_powersetAux_lemma {\u03b1 : Type u} [DecidableEq \u03b1] (l : List \u03b1) {l' : List (Multiset \u03b1)}\n    (H : \u2200 \u2983x : _ \u00d7 _\u2984, x \u2208 revzip l' \u2192 x.1 + x.2 = \u2191l) :\n    revzip l' = l'.map fun x => (x, (l : Multiset \u03b1) - x)", "start": [142, 1], "end": [153, 19], "kind": "commanddeclaration"}, {"full_name": "Multiset.revzip_powersetAux_perm_aux'", "code": "theorem revzip_powersetAux_perm_aux' {l : List \u03b1} :\n    revzip (powersetAux l) ~ revzip (powersetAux' l)", "start": [156, 1], "end": [160, 44], "kind": "commanddeclaration"}, {"full_name": "Multiset.revzip_powersetAux_perm", "code": "theorem revzip_powersetAux_perm {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) :\n    revzip (powersetAux l\u2081) ~ revzip (powersetAux l\u2082)", "start": [163, 1], "end": [168, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux", "code": "def powersetCardAux (n : \u2115) (l : List \u03b1) : List (Multiset \u03b1) :=\n  sublistsLenAux n l (\u2191) []", "start": [174, 1], "end": [177, 28], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux_eq_map_coe", "code": "theorem powersetCardAux_eq_map_coe {n} {l : List \u03b1} :\n    powersetCardAux n l = (sublistsLen n l).map (\u2191)", "start": [180, 1], "end": [182, 54], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_powersetCardAux", "code": "@[simp]\ntheorem mem_powersetCardAux {n} {l : List \u03b1} {s} : s \u2208 powersetCardAux n l \u2194 s \u2264 \u2191l \u2227 card s = n", "start": [185, 1], "end": [192, 64], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux_zero", "code": "@[simp]\ntheorem powersetCardAux_zero (l : List \u03b1) : powersetCardAux 0 l = [0]", "start": [195, 1], "end": [197, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux_nil", "code": "@[simp]\ntheorem powersetCardAux_nil (n : \u2115) : powersetCardAux (n + 1) (@nil \u03b1) = []", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux_cons", "code": "@[simp]\ntheorem powersetCardAux_cons (n : \u2115) (a : \u03b1) (l : List \u03b1) :\n    powersetCardAux (n + 1) (a :: l) =\n      powersetCardAux (n + 1) l ++ List.map (cons a) (powersetCardAux n l)", "start": [205, 1], "end": [209, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCardAux_perm", "code": "theorem powersetCardAux_perm {n} {l\u2081 l\u2082 : List \u03b1} (p : l\u2081 ~ l\u2082) :\n    powersetCardAux n l\u2081 ~ powersetCardAux n l\u2082", "start": [212, 1], "end": [228, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard", "code": "def powersetCard (n : \u2115) (s : Multiset \u03b1) : Multiset (Multiset \u03b1) :=\n  Quot.liftOn s (fun l => (powersetCardAux n l : Multiset (Multiset \u03b1))) fun _ _ h =>\n    Quot.sound (powersetCardAux_perm h)", "start": [231, 1], "end": [234, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_coe'", "code": "theorem powersetCard_coe' (n) (l : List \u03b1) : @powersetCard \u03b1 n l = powersetCardAux n l", "start": [237, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_coe", "code": "theorem powersetCard_coe (n) (l : List \u03b1) :\n    @powersetCard \u03b1 n l = ((sublistsLen n l).map (\u2191) : List (Multiset \u03b1))", "start": [241, 1], "end": [243, 89], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_zero_left", "code": "@[simp]\ntheorem powersetCard_zero_left (s : Multiset \u03b1) : powersetCard 0 s = {0}", "start": [246, 1], "end": [248, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_zero_right", "code": "theorem powersetCard_zero_right (n : \u2115) : @powersetCard \u03b1 (n + 1) 0 = 0", "start": [251, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_cons", "code": "@[simp]\ntheorem powersetCard_cons (n : \u2115) (a : \u03b1) (s) :\n    powersetCard (n + 1) (a ::\u2098 s) = powersetCard (n + 1) s + map (cons a) (powersetCard n s)", "start": [255, 1], "end": [258, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_powersetCard", "code": "@[simp]\ntheorem mem_powersetCard {n : \u2115} {s t : Multiset \u03b1} : s \u2208 powersetCard n t \u2194 s \u2264 t \u2227 card s = n", "start": [261, 1], "end": [263, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.card_powersetCard", "code": "@[simp]\ntheorem card_powersetCard (n : \u2115) (s : Multiset \u03b1) :\n    card (powersetCard n s) = Nat.choose (card s) n", "start": [266, 1], "end": [269, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_le_powerset", "code": "theorem powersetCard_le_powerset (n : \u2115) (s : Multiset \u03b1) : powersetCard n s \u2264 powerset s", "start": [272, 1], "end": [275, 62], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_mono", "code": "theorem powersetCard_mono (n : \u2115) {s t : Multiset \u03b1} (h : s \u2264 t) :\n    powersetCard n s \u2264 powersetCard n t", "start": [278, 1], "end": [282, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_empty", "code": "@[simp]\ntheorem powersetCard_empty {\u03b1 : Type*} (n : \u2115) {s : Multiset \u03b1} (h : card s < n) :\n    powersetCard n s = 0", "start": [285, 1], "end": [288, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_card_add", "code": "@[simp]\ntheorem powersetCard_card_add (s : Multiset \u03b1) {i : \u2115} (hi : 0 < i) :\n    s.powersetCard (card s + i) = 0", "start": [291, 1], "end": [294, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.powersetCard_map", "code": "theorem powersetCard_map {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (n : \u2115) (s : Multiset \u03b1) :\n    powersetCard n (s.map f) = (powersetCard n s).map (map f)", "start": [297, 1], "end": [301, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.pairwise_disjoint_powersetCard", "code": "theorem pairwise_disjoint_powersetCard (s : Multiset \u03b1) :\n    _root_.Pairwise fun i j => Multiset.Disjoint (s.powersetCard i) (s.powersetCard j)", "start": [304, 1], "end": [307, 100], "kind": "commanddeclaration"}, {"full_name": "Multiset.bind_powerset_len", "code": "theorem bind_powerset_len {\u03b1 : Type*} (S : Multiset \u03b1) :\n    (bind (Multiset.range (card S + 1)) fun k => S.powersetCard k) = S.powerset", "start": [310, 1], "end": [315, 68], "kind": "commanddeclaration"}, {"full_name": "Multiset.nodup_powerset", "code": "@[simp]\ntheorem nodup_powerset {s : Multiset \u03b1} : Nodup (powerset s) \u2194 Nodup s", "start": [318, 1], "end": [325, 88], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nodup.ofPowerset", "code": "alias \u27e8Nodup.ofPowerset, Nodup.powerset\u27e9 := nodup_powerset", "start": [328, 1], "end": [328, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.Nodup.powerset", "code": "alias \u27e8Nodup.ofPowerset, Nodup.powerset\u27e9 := nodup_powerset", "start": [328, 1], "end": [328, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Multiset.Nodup.powersetCard", "code": "protected theorem Nodup.powersetCard {n : \u2115} {s : Multiset \u03b1} (h : Nodup s) :\n    Nodup (powersetCard n s)", "start": [332, 1], "end": [334, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Lattice.lean", "imports": ["Mathlib/Data/Finset/Fold.lean", "Mathlib/Data/Finset/Option.lean", "Mathlib/Data/Finset/Prod.lean", "Mathlib/Data/Finset/Pi.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Lattice.lean", "Mathlib/Order/CompleteLattice.lean", "Mathlib/Data/Multiset/Lattice.lean"], "premises": [{"full_name": "Finset.sup", "code": "def sup (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  s.fold (\u00b7 \u2294 \u00b7) \u22a5 f", "start": [37, 1], "end": [39, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_def", "code": "theorem sup_def : s.sup f = (s.1.map f).sup", "start": [44, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_empty", "code": "@[simp]\ntheorem sup_empty : (\u2205 : Finset \u03b2).sup f = \u22a5", "start": [48, 1], "end": [50, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_cons", "code": "@[simp]\ntheorem sup_cons {b : \u03b2} (h : b \u2209 s) : (cons b s h).sup f = f b \u2294 s.sup f", "start": [53, 1], "end": [55, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_insert", "code": "@[simp]\ntheorem sup_insert [DecidableEq \u03b2] {b : \u03b2} : (insert b s : Finset \u03b2).sup f = f b \u2294 s.sup f", "start": [58, 1], "end": [60, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_image", "code": "theorem sup_image [DecidableEq \u03b2] (s : Finset \u03b3) (f : \u03b3 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    (s.image f).sup g = s.sup (g \u2218 f)", "start": [63, 1], "end": [65, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_map", "code": "@[simp]\ntheorem sup_map (s : Finset \u03b3) (f : \u03b3 \u21aa \u03b2) (g : \u03b2 \u2192 \u03b1) : (s.map f).sup g = s.sup (g \u2218 f)", "start": [68, 1], "end": [70, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_singleton", "code": "@[simp]\ntheorem sup_singleton {b : \u03b2} : ({b} : Finset \u03b2).sup f = f b", "start": [73, 1], "end": [75, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_sup", "code": "theorem sup_sup : s.sup (f \u2294 g) = s.sup f \u2294 s.sup g", "start": [78, 1], "end": [82, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_congr", "code": "theorem sup_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.sup f = s\u2082.sup g", "start": [85, 1], "end": [88, 30], "kind": "commanddeclaration"}, {"full_name": "map_finset_sup", "code": "@[simp]\ntheorem _root_.map_finset_sup [SemilatticeSup \u03b2] [OrderBot \u03b2] [SupBotHomClass F \u03b1 \u03b2] (f : F)\n    (s : Finset \u03b9) (g : \u03b9 \u2192 \u03b1) : f (s.sup g) = s.sup (f \u2218 g)", "start": [91, 1], "end": [95, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_le_iff", "code": "@[simp]\nprotected theorem sup_le_iff {a : \u03b1} : s.sup f \u2264 a \u2194 \u2200 b \u2208 s, f b \u2264 a", "start": [98, 1], "end": [102, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_le", "code": "alias \u27e8_, sup_le\u27e9 := Finset.sup_le_iff", "start": [105, 1], "end": [105, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.sup_const_le", "code": "theorem sup_const_le : (s.sup fun _ => a) \u2264 a", "start": [110, 1], "end": [111, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup", "code": "theorem le_sup {b : \u03b2} (hb : b \u2208 s) : f b \u2264 s.sup f", "start": [114, 1], "end": [115, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup_of_le", "code": "theorem le_sup_of_le {b : \u03b2} (hb : b \u2208 s) (h : a \u2264 f b) : a \u2264 s.sup f", "start": [118, 1], "end": [118, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_union", "code": "theorem sup_union [DecidableEq \u03b2] : (s\u2081 \u222a s\u2082).sup f = s\u2081.sup f \u2294 s\u2082.sup f", "start": [121, 1], "end": [122, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_biUnion", "code": "@[simp]\ntheorem sup_biUnion [DecidableEq \u03b2] (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b2) :\n    (s.biUnion t).sup f = s.sup fun x => (t x).sup f", "start": [125, 1], "end": [128, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_const", "code": "theorem sup_const {s : Finset \u03b2} (h : s.Nonempty) (c : \u03b1) : (s.sup fun _ => c) = c", "start": [131, 1], "end": [132, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_bot", "code": "@[simp]\ntheorem sup_bot (s : Finset \u03b2) : (s.sup fun _ => \u22a5) = (\u22a5 : \u03b1)", "start": [135, 1], "end": [139, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_ite", "code": "theorem sup_ite (p : \u03b2 \u2192 Prop) [DecidablePred p] :\n    (s.sup fun i => ite (p i) (f i) (g i)) = (s.filter p).sup f \u2294 (s.filter fun i => \u00acp i).sup g", "start": [142, 1], "end": [144, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_mono_fun", "code": "theorem sup_mono_fun {g : \u03b2 \u2192 \u03b1} (h : \u2200 b \u2208 s, f b \u2264 g b) : s.sup f \u2264 s.sup g", "start": [147, 1], "end": [148, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_mono", "code": "theorem sup_mono (h : s\u2081 \u2286 s\u2082) : s\u2081.sup f \u2264 s\u2082.sup f", "start": [151, 1], "end": [152, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_comm", "code": "protected theorem sup_comm (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) :\n    (s.sup fun b => t.sup (f b)) = t.sup fun c => s.sup fun b => f b c", "start": [155, 1], "end": [157, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_attach", "code": "@[simp, nolint simpNF] theorem sup_attach (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : (s.attach.sup fun x => f x) = s.sup f", "start": [160, 1], "end": [162, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_product_left", "code": "theorem sup_product_left (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).sup f = s.sup fun i => t.sup fun i' => f \u27e8i, i'\u27e9", "start": [165, 1], "end": [168, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_product_right", "code": "theorem sup_product_right (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).sup f = t.sup fun i' => s.sup fun i => f \u27e8i, i'\u27e9", "start": [171, 1], "end": [173, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_erase_bot", "code": "@[simp]\ntheorem sup_erase_bot [DecidableEq \u03b1] (s : Finset \u03b1) : (s.erase \u22a5).sup id = s.sup id", "start": [176, 1], "end": [181, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_sdiff_right", "code": "theorem sup_sdiff_right {\u03b1 \u03b2 : Type*} [GeneralizedBooleanAlgebra \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1)\n    (a : \u03b1) : (s.sup fun b => f b \\ a) = s.sup f \\ a", "start": [184, 1], "end": [188, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_sup_eq_sup_comp", "code": "theorem comp_sup_eq_sup_comp [SemilatticeSup \u03b3] [OrderBot \u03b3] {s : Finset \u03b2} {f : \u03b2 \u2192 \u03b1} (g : \u03b1 \u2192 \u03b3)\n    (g_sup : \u2200 x y, g (x \u2294 y) = g x \u2294 g y) (bot : g \u22a5 = \u22a5) : g (s.sup f) = s.sup (g \u2218 f)", "start": [191, 1], "end": [194, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_coe", "code": "theorem sup_coe {P : \u03b1 \u2192 Prop} {Pbot : P \u22a5} {Psup : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2294 y)} (t : Finset \u03b2)\n    (f : \u03b2 \u2192 { x : \u03b1 // P x }) :\n    (@sup { x // P x } _ (Subtype.semilatticeSup Psup) (Subtype.orderBot Pbot) t f : \u03b1) =\n      t.sup fun x => \u2191(f x)", "start": [197, 1], "end": [204, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_toFinset", "code": "@[simp]\ntheorem sup_toFinset {\u03b1 \u03b2} [DecidableEq \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) :\n    (s.sup f).toFinset = s.sup fun x => (f x).toFinset", "start": [207, 1], "end": [210, 60], "kind": "commanddeclaration"}, {"full_name": "List.foldr_sup_eq_sup_toFinset", "code": "theorem _root_.List.foldr_sup_eq_sup_toFinset [DecidableEq \u03b1] (l : List \u03b1) :\n    l.foldr (\u00b7 \u2294 \u00b7) \u22a5 = l.toFinset.sup id", "start": [213, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_range_sup_succ", "code": "theorem subset_range_sup_succ (s : Finset \u2115) : s \u2286 range (s.sup id).succ", "start": [220, 1], "end": [221, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_nat_subset_range", "code": "theorem exists_nat_subset_range (s : Finset \u2115) : \u2203 n : \u2115, s \u2286 range n", "start": [224, 1], "end": [225, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_induction", "code": "theorem sup_induction {p : \u03b1 \u2192 Prop} (hb : p \u22a5) (hp : \u2200 a\u2081, p a\u2081 \u2192 \u2200 a\u2082, p a\u2082 \u2192 p (a\u2081 \u2294 a\u2082))\n    (hs : \u2200 b \u2208 s, p (f b)) : p (s.sup f)", "start": [228, 1], "end": [235, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_le_of_le_directed", "code": "theorem sup_le_of_le_directed {\u03b1 : Type*} [SemilatticeSup \u03b1] [OrderBot \u03b1] (s : Set \u03b1)\n    (hs : s.Nonempty) (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) (t : Finset \u03b1) :\n    (\u2200 x \u2208 t, \u2203 y \u2208 s, x \u2264 y) \u2192 \u2203 x, x \u2208 s \u2227 t.sup id \u2264 x", "start": [238, 1], "end": [257, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_mem", "code": "theorem sup_mem (s : Set \u03b1) (w\u2081 : \u22a5 \u2208 s) (w\u2082 : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x \u2294 y \u2208 s)\n    {\u03b9 : Type*} (t : Finset \u03b9) (p : \u03b9 \u2192 \u03b1) (h : \u2200 i \u2208 t, p i \u2208 s) : t.sup p \u2208 s", "start": [262, 1], "end": [264, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_eq_bot_iff", "code": "@[simp]\nprotected theorem sup_eq_bot_iff (f : \u03b2 \u2192 \u03b1) (S : Finset \u03b2) : S.sup f = \u22a5 \u2194 \u2200 s \u2208 S, f s = \u22a5", "start": [267, 1], "end": [269, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_eq_iSup", "code": "theorem sup_eq_iSup [CompleteLattice \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : s.sup f = \u2a06 a \u2208 s, f a", "start": [274, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_id_eq_sSup", "code": "theorem sup_id_eq_sSup [CompleteLattice \u03b1] (s : Finset \u03b1) : s.sup id = sSup s", "start": [280, 1], "end": [281, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_id_set_eq_sUnion", "code": "theorem sup_id_set_eq_sUnion (s : Finset (Set \u03b1)) : s.sup id = \u22c3\u2080 \u2191s", "start": [284, 1], "end": [285, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_set_eq_biUnion", "code": "@[simp]\ntheorem sup_set_eq_biUnion (s : Finset \u03b1) (f : \u03b1 \u2192 Set \u03b2) : s.sup f = \u22c3 x \u2208 s, f x", "start": [288, 1], "end": [290, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_eq_sSup_image", "code": "theorem sup_eq_sSup_image [CompleteLattice \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    s.sup f = sSup (f '' s)", "start": [293, 1], "end": [295, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.inf", "code": "def inf (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  s.fold (\u00b7 \u2293 \u00b7) \u22a4 f", "start": [306, 1], "end": [308, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_def", "code": "theorem inf_def : s.inf f = (s.1.map f).inf", "start": [313, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_empty", "code": "@[simp]\ntheorem inf_empty : (\u2205 : Finset \u03b2).inf f = \u22a4", "start": [317, 1], "end": [319, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_cons", "code": "@[simp]\ntheorem inf_cons {b : \u03b2} (h : b \u2209 s) : (cons b s h).inf f = f b \u2293 s.inf f", "start": [322, 1], "end": [324, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_insert", "code": "@[simp]\ntheorem inf_insert [DecidableEq \u03b2] {b : \u03b2} : (insert b s : Finset \u03b2).inf f = f b \u2293 s.inf f", "start": [327, 1], "end": [329, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_image", "code": "theorem inf_image [DecidableEq \u03b2] (s : Finset \u03b3) (f : \u03b3 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    (s.image f).inf g = s.inf (g \u2218 f)", "start": [332, 1], "end": [334, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_map", "code": "@[simp]\ntheorem inf_map (s : Finset \u03b3) (f : \u03b3 \u21aa \u03b2) (g : \u03b2 \u2192 \u03b1) : (s.map f).inf g = s.inf (g \u2218 f)", "start": [337, 1], "end": [339, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_singleton", "code": "@[simp]\ntheorem inf_singleton {b : \u03b2} : ({b} : Finset \u03b2).inf f = f b", "start": [342, 1], "end": [344, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_inf", "code": "theorem inf_inf : s.inf (f \u2293 g) = s.inf f \u2293 s.inf g", "start": [347, 1], "end": [348, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_congr", "code": "theorem inf_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.inf f = s\u2082.inf g", "start": [351, 1], "end": [354, 30], "kind": "commanddeclaration"}, {"full_name": "map_finset_inf", "code": "@[simp]\ntheorem _root_.map_finset_inf [SemilatticeInf \u03b2] [OrderTop \u03b2] [InfTopHomClass F \u03b1 \u03b2] (f : F)\n    (s : Finset \u03b9) (g : \u03b9 \u2192 \u03b1) : f (s.inf g) = s.inf (f \u2218 g)", "start": [357, 1], "end": [361, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.le_inf_iff", "code": "@[simp] protected theorem le_inf_iff {a : \u03b1} : a \u2264 s.inf f \u2194 \u2200 b \u2208 s, a \u2264 f b", "start": [364, 1], "end": [365, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.le_inf", "code": "alias \u27e8_, le_inf\u27e9 := Finset.le_inf_iff", "start": [368, 1], "end": [368, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.le_inf_const_le", "code": "theorem le_inf_const_le : a \u2264 s.inf fun _ => a", "start": [373, 1], "end": [374, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_le", "code": "theorem inf_le {b : \u03b2} (hb : b \u2208 s) : s.inf f \u2264 f b", "start": [377, 1], "end": [378, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_le_of_le", "code": "theorem inf_le_of_le {b : \u03b2} (hb : b \u2208 s) (h : f b \u2264 a) : s.inf f \u2264 a", "start": [381, 1], "end": [381, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_union", "code": "theorem inf_union [DecidableEq \u03b2] : (s\u2081 \u222a s\u2082).inf f = s\u2081.inf f \u2293 s\u2082.inf f", "start": [384, 1], "end": [385, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_biUnion", "code": "@[simp] theorem inf_biUnion [DecidableEq \u03b2] (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b2) :\n    (s.biUnion t).inf f = s.inf fun x => (t x).inf f", "start": [388, 1], "end": [390, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_const", "code": "theorem inf_const (h : s.Nonempty) (c : \u03b1) : (s.inf fun _ => c) = c", "start": [393, 1], "end": [393, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_top", "code": "@[simp] theorem inf_top (s : Finset \u03b2) : (s.inf fun _ => \u22a4) = (\u22a4 : \u03b1)", "start": [396, 1], "end": [396, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_ite", "code": "theorem inf_ite (p : \u03b2 \u2192 Prop) [DecidablePred p] :\n    (s.inf fun i \u21a6 ite (p i) (f i) (g i)) = (s.filter p).inf f \u2293 (s.filter fun i \u21a6 \u00ac p i).inf g", "start": [399, 1], "end": [401, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_mono_fun", "code": "theorem inf_mono_fun {g : \u03b2 \u2192 \u03b1} (h : \u2200 b \u2208 s, f b \u2264 g b) : s.inf f \u2264 s.inf g", "start": [403, 1], "end": [404, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_mono", "code": "theorem inf_mono (h : s\u2081 \u2286 s\u2082) : s\u2082.inf f \u2264 s\u2081.inf f", "start": [407, 1], "end": [408, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_comm", "code": "protected theorem inf_comm (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) :\n    (s.inf fun b => t.inf (f b)) = t.inf fun c => s.inf fun b => f b c", "start": [411, 1], "end": [413, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_attach", "code": "theorem inf_attach (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) : (s.attach.inf fun x => f x) = s.inf f", "start": [416, 1], "end": [417, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_product_left", "code": "theorem inf_product_left (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).inf f = s.inf fun i => t.inf fun i' => f \u27e8i, i'\u27e9", "start": [420, 1], "end": [422, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_product_right", "code": "theorem inf_product_right (s : Finset \u03b2) (t : Finset \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).inf f = t.inf fun i' => s.inf fun i => f \u27e8i, i'\u27e9", "start": [425, 1], "end": [427, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_erase_top", "code": "@[simp]\ntheorem inf_erase_top [DecidableEq \u03b1] (s : Finset \u03b1) : (s.erase \u22a4).inf id = s.inf id", "start": [430, 1], "end": [432, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_inf_eq_inf_comp", "code": "theorem comp_inf_eq_inf_comp [SemilatticeInf \u03b3] [OrderTop \u03b3] {s : Finset \u03b2} {f : \u03b2 \u2192 \u03b1} (g : \u03b1 \u2192 \u03b3)\n    (g_inf : \u2200 x y, g (x \u2293 y) = g x \u2293 g y) (top : g \u22a4 = \u22a4) : g (s.inf f) = s.inf (g \u2218 f)", "start": [435, 1], "end": [437, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_coe", "code": "theorem inf_coe {P : \u03b1 \u2192 Prop} {Ptop : P \u22a4} {Pinf : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2293 y)} (t : Finset \u03b2)\n    (f : \u03b2 \u2192 { x : \u03b1 // P x }) :\n    (@inf { x // P x } _ (Subtype.semilatticeInf Pinf) (Subtype.orderTop Ptop) t f : \u03b1) =\n      t.inf fun x => \u2191(f x)", "start": [440, 1], "end": [445, 37], "kind": "commanddeclaration"}, {"full_name": "List.foldr_inf_eq_inf_toFinset", "code": "theorem _root_.List.foldr_inf_eq_inf_toFinset [DecidableEq \u03b1] (l : List \u03b1) :\n    l.foldr (\u00b7 \u2293 \u00b7) \u22a4 = l.toFinset.inf id", "start": [448, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_induction", "code": "theorem inf_induction {p : \u03b1 \u2192 Prop} (ht : p \u22a4) (hp : \u2200 a\u2081, p a\u2081 \u2192 \u2200 a\u2082, p a\u2082 \u2192 p (a\u2081 \u2293 a\u2082))\n    (hs : \u2200 b \u2208 s, p (f b)) : p (s.inf f)", "start": [455, 1], "end": [457, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_mem", "code": "theorem inf_mem (s : Set \u03b1) (w\u2081 : \u22a4 \u2208 s) (w\u2082 : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x \u2293 y \u2208 s)\n    {\u03b9 : Type*} (t : Finset \u03b9) (p : \u03b9 \u2192 \u03b1) (h : \u2200 i \u2208 t, p i \u2208 s) : t.inf p \u2208 s", "start": [460, 1], "end": [462, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_eq_top_iff", "code": "@[simp]\nprotected theorem inf_eq_top_iff (f : \u03b2 \u2192 \u03b1) (S : Finset \u03b2) : S.inf f = \u22a4 \u2194 \u2200 s \u2208 S, f s = \u22a4", "start": [465, 1], "end": [467, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_sup", "code": "@[simp]\ntheorem toDual_sup [SemilatticeSup \u03b1] [OrderBot \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    toDual (s.sup f) = s.inf (toDual \u2218 f)", "start": [472, 1], "end": [475, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_inf", "code": "@[simp]\ntheorem toDual_inf [SemilatticeInf \u03b1] [OrderTop \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    toDual (s.inf f) = s.sup (toDual \u2218 f)", "start": [478, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_sup", "code": "@[simp]\ntheorem ofDual_sup [SemilatticeInf \u03b1] [OrderTop \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1\u1d52\u1d48) :\n    ofDual (s.sup f) = s.inf (ofDual \u2218 f)", "start": [484, 1], "end": [487, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_inf", "code": "@[simp]\ntheorem ofDual_inf [SemilatticeSup \u03b1] [OrderBot \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1\u1d52\u1d48) :\n    ofDual (s.inf f) = s.sup (ofDual \u2218 f)", "start": [490, 1], "end": [493, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_inf_distrib_left", "code": "theorem sup_inf_distrib_left (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    a \u2293 s.sup f = s.sup fun i => a \u2293 f i", "start": [504, 1], "end": [508, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_inf_distrib_right", "code": "theorem sup_inf_distrib_right (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    s.sup f \u2293 a = s.sup fun i => f i \u2293 a", "start": [511, 1], "end": [514, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_sup_right", "code": "protected theorem disjoint_sup_right : Disjoint a (s.sup f) \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 Disjoint a (f i)", "start": [517, 1], "end": [518, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_sup_left", "code": "protected theorem disjoint_sup_left : Disjoint (s.sup f) a \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 Disjoint (f i) a", "start": [521, 1], "end": [522, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_inf_sup", "code": "theorem sup_inf_sup (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    s.sup f \u2293 t.sup g = (s \u00d7\u02e2 t).sup fun i => f i.1 \u2293 g i.2", "start": [525, 1], "end": [527, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sup_distrib_left", "code": "theorem inf_sup_distrib_left (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    a \u2294 s.inf f = s.inf fun i => a \u2294 f i", "start": [536, 1], "end": [538, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sup_distrib_right", "code": "theorem inf_sup_distrib_right (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    s.inf f \u2294 a = s.inf fun i => f i \u2294 a", "start": [541, 1], "end": [543, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.codisjoint_inf_right", "code": "protected theorem codisjoint_inf_right :\n    Codisjoint a (s.inf f) \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 Codisjoint a (f i)", "start": [546, 1], "end": [548, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.codisjoint_inf_left", "code": "protected theorem codisjoint_inf_left :\n    Codisjoint (s.inf f) a \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 Codisjoint (f i) a", "start": [551, 1], "end": [553, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sup_inf", "code": "theorem inf_sup_inf (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    s.inf f \u2294 t.inf g = (s \u00d7\u02e2 t).inf fun i => f i.1 \u2294 g i.2", "start": [556, 1], "end": [558, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sup", "code": "theorem inf_sup {\u03ba : \u03b9 \u2192 Type*} (s : Finset \u03b9) (t : \u2200 i, Finset (\u03ba i)) (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    (s.inf fun i => (t i).sup (f i)) =\n      (s.pi t).sup fun g => s.attach.inf fun i => f _ <| g _ i.2", "start": [568, 1], "end": [591, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_inf", "code": "theorem sup_inf {\u03ba : \u03b9 \u2192 Type*} (s : Finset \u03b9) (t : \u2200 i, Finset (\u03ba i)) (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    (s.sup fun i => (t i).inf (f i)) = (s.pi t).inf fun g => s.attach.sup fun i => f _ <| g _ i.2", "start": [594, 1], "end": [596, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_sdiff_left", "code": "theorem sup_sdiff_left (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.sup fun b => a \\ f b) = a \\ s.inf f", "start": [607, 1], "end": [611, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sdiff_left", "code": "theorem inf_sdiff_left (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.inf fun b => a \\ f b) = a \\ s.sup f", "start": [614, 1], "end": [618, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sdiff_right", "code": "theorem inf_sdiff_right (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.inf fun b => f b \\ a) = s.inf f \\ a", "start": [621, 1], "end": [625, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_himp_right", "code": "theorem inf_himp_right (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.inf fun b => f b \u21e8 a) = s.sup f \u21e8 a", "start": [628, 1], "end": [630, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_himp_right", "code": "theorem sup_himp_right (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.sup fun b => f b \u21e8 a) = s.inf f \u21e8 a", "start": [633, 1], "end": [635, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_himp_left", "code": "theorem sup_himp_left (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) (a : \u03b1) :\n    (s.sup fun b => a \u21e8 f b) = a \u21e8 s.sup f", "start": [638, 1], "end": [640, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_sup", "code": "@[simp]\nprotected theorem compl_sup (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : (s.sup f)\u1d9c = s.inf fun i => (f i)\u1d9c", "start": [643, 1], "end": [645, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.compl_inf", "code": "@[simp]\nprotected theorem compl_inf (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : (s.inf f)\u1d9c = s.sup fun i => (f i)\u1d9c", "start": [648, 1], "end": [650, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_sup_eq_sup_comp_of_is_total", "code": "theorem comp_sup_eq_sup_comp_of_is_total [SemilatticeSup \u03b2] [OrderBot \u03b2] (g : \u03b1 \u2192 \u03b2)\n    (mono_g : Monotone g) (bot : g \u22a5 = \u22a5) : g (s.sup f) = s.sup (g \u2218 f)", "start": [663, 1], "end": [665, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup_iff", "code": "@[simp]\nprotected theorem le_sup_iff (ha : \u22a5 < a) : a \u2264 s.sup f \u2194 \u2203 b \u2208 s, a \u2264 f b", "start": [668, 1], "end": [678, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_sup_iff", "code": "@[simp]\nprotected theorem lt_sup_iff : a < s.sup f \u2194 \u2203 b \u2208 s, a < f b", "start": [681, 1], "end": [691, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_lt_iff", "code": "@[simp]\nprotected theorem sup_lt_iff (ha : \u22a5 < a) : s.sup f < a \u2194 \u2200 b \u2208 s, f b < a", "start": [694, 1], "end": [698, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_inf_eq_inf_comp_of_is_total", "code": "theorem comp_inf_eq_inf_comp_of_is_total [SemilatticeInf \u03b2] [OrderTop \u03b2] (g : \u03b1 \u2192 \u03b2)\n    (mono_g : Monotone g) (top : g \u22a4 = \u22a4) : g (s.inf f) = s.inf (g \u2218 f)", "start": [707, 1], "end": [709, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_le_iff", "code": "@[simp]\nprotected theorem inf_le_iff (ha : a < \u22a4) : s.inf f \u2264 a \u2194 \u2203 b \u2208 s, f b \u2264 a", "start": [712, 1], "end": [714, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_lt_iff", "code": "@[simp]\nprotected theorem inf_lt_iff : s.inf f < a \u2194 \u2203 b \u2208 s, f b < a", "start": [717, 1], "end": [719, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_inf_iff", "code": "@[simp]\nprotected theorem lt_inf_iff (ha : a < \u22a4) : a < s.inf f \u2194 \u2200 b \u2208 s, a < f b", "start": [722, 1], "end": [724, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_eq_iInf", "code": "theorem inf_eq_iInf [CompleteLattice \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : s.inf f = \u2a05 a \u2208 s, f a", "start": [731, 1], "end": [732, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_id_eq_sInf", "code": "theorem inf_id_eq_sInf [CompleteLattice \u03b1] (s : Finset \u03b1) : s.inf id = sInf s", "start": [735, 1], "end": [736, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_id_set_eq_sInter", "code": "theorem inf_id_set_eq_sInter (s : Finset (Set \u03b1)) : s.inf id = \u22c2\u2080 \u2191s", "start": [739, 1], "end": [740, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_set_eq_iInter", "code": "@[simp]\ntheorem inf_set_eq_iInter (s : Finset \u03b1) (f : \u03b1 \u2192 Set \u03b2) : s.inf f = \u22c2 x \u2208 s, f x", "start": [743, 1], "end": [745, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_eq_sInf_image", "code": "theorem inf_eq_sInf_image [CompleteLattice \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    s.inf f = sInf (f '' s)", "start": [748, 1], "end": [750, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_of_mem", "code": "theorem sup_of_mem {s : Finset \u03b2} (f : \u03b2 \u2192 \u03b1) {b : \u03b2} (h : b \u2208 s) :\n    \u2203 a : \u03b1, s.sup ((\u2191) \u2218 f : \u03b2 \u2192 WithBot \u03b1) = \u2191a", "start": [757, 1], "end": [759, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'", "code": "def sup' (s : Finset \u03b2) (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  WithBot.unbot (s.sup ((\u2191) \u2218 f)) (by simpa using H)", "start": [762, 1], "end": [766, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sup'", "code": "@[simp]\ntheorem coe_sup' : ((s.sup' H f : \u03b1) : WithBot \u03b1) = s.sup ((\u2191) \u2218 f)", "start": [771, 1], "end": [773, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_cons", "code": "@[simp]\ntheorem sup'_cons {b : \u03b2} {hb : b \u2209 s} {h : (cons b s hb).Nonempty} :\n    (cons b s hb).sup' h f = f b \u2294 s.sup' H f", "start": [776, 1], "end": [780, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_insert", "code": "@[simp]\ntheorem sup'_insert [DecidableEq \u03b2] {b : \u03b2} {h : (insert b s).Nonempty} :\n    (insert b s).sup' h f = f b \u2294 s.sup' H f", "start": [783, 1], "end": [787, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_singleton", "code": "@[simp]\ntheorem sup'_singleton {b : \u03b2} {h : ({b} : Finset \u03b2).Nonempty} : ({b} : Finset \u03b2).sup' h f = f b", "start": [790, 1], "end": [792, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_le", "code": "theorem sup'_le {a : \u03b1} (hs : \u2200 b \u2208 s, f b \u2264 a) : s.sup' H f \u2264 a", "start": [795, 1], "end": [797, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup'", "code": "theorem le_sup' {b : \u03b2} (h : b \u2208 s) : f b \u2264 s.sup' \u27e8b, h\u27e9 f", "start": [800, 1], "end": [802, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup'_of_le", "code": "theorem le_sup'_of_le {a : \u03b1} {b : \u03b2} (hb : b \u2208 s) (h : a \u2264 f b) : a \u2264 s.sup' \u27e8b, hb\u27e9 f", "start": [805, 1], "end": [806, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_const", "code": "@[simp]\ntheorem sup'_const (a : \u03b1) : s.sup' H (fun _ => a) = a", "start": [809, 1], "end": [815, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_le_iff", "code": "@[simp]\ntheorem sup'_le_iff {a : \u03b1} : s.sup' H f \u2264 a \u2194 \u2200 b \u2208 s, f b \u2264 a", "start": [818, 1], "end": [820, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_union", "code": "theorem sup'_union [DecidableEq \u03b2] {s\u2081 s\u2082 : Finset \u03b2} (h\u2081 : s\u2081.Nonempty) (h\u2082 : s\u2082.Nonempty)\n    (f : \u03b2 \u2192 \u03b1) :\n    (s\u2081 \u222a s\u2082).sup' (h\u2081.mono <| subset_union_left _ _) f = s\u2081.sup' h\u2081 f \u2294 s\u2082.sup' h\u2082 f", "start": [823, 1], "end": [826, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_biUnion", "code": "theorem sup'_biUnion [DecidableEq \u03b2] {s : Finset \u03b3} (Hs : s.Nonempty) {t : \u03b3 \u2192 Finset \u03b2}\n    (Ht : \u2200 b, (t b).Nonempty) :\n    (s.biUnion t).sup' (Hs.biUnion fun b _ => Ht b) f = s.sup' Hs (fun b => (t b).sup' (Ht b) f)", "start": [829, 1], "end": [832, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_comm", "code": "protected theorem sup'_comm {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) :\n    (s.sup' hs fun b => t.sup' ht (f b)) = t.sup' ht fun c => s.sup' hs fun b => f b c", "start": [835, 1], "end": [837, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_product_left", "code": "theorem sup'_product_left {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).sup' (hs.product ht) f = s.sup' hs fun i => t.sup' ht fun i' => f \u27e8i, i'\u27e9", "start": [840, 1], "end": [842, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_product_right", "code": "theorem sup'_product_right {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).sup' (hs.product ht) f = t.sup' ht fun i' => s.sup' hs fun i => f \u27e8i, i'\u27e9", "start": [845, 1], "end": [847, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_sup'_eq_sup'_comp", "code": "theorem comp_sup'_eq_sup'_comp [SemilatticeSup \u03b3] {s : Finset \u03b2} (H : s.Nonempty) {f : \u03b2 \u2192 \u03b1}\n    (g : \u03b1 \u2192 \u03b3) (g_sup : \u2200 x y, g (x \u2294 y) = g x \u2294 g y) : g (s.sup' H f) = s.sup' H (g \u2218 f)", "start": [850, 1], "end": [865, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_induction", "code": "theorem sup'_induction {p : \u03b1 \u2192 Prop} (hp : \u2200 a\u2081, p a\u2081 \u2192 \u2200 a\u2082, p a\u2082 \u2192 p (a\u2081 \u2294 a\u2082))\n    (hs : \u2200 b \u2208 s, p (f b)) : p (s.sup' H f)", "start": [868, 1], "end": [878, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_mem", "code": "theorem sup'_mem (s : Set \u03b1) (w : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x \u2294 y \u2208 s) {\u03b9 : Type*}\n    (t : Finset \u03b9) (H : t.Nonempty) (p : \u03b9 \u2192 \u03b1) (h : \u2200 i \u2208 t, p i \u2208 s) : t.sup' H p \u2208 s", "start": [881, 1], "end": [883, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_congr", "code": "@[congr]\ntheorem sup'_congr {t : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} (h\u2081 : s = t) (h\u2082 : \u2200 x \u2208 s, f x = g x) :\n    s.sup' H f = t.sup' (h\u2081 \u25b8 H) g", "start": [886, 1], "end": [891, 65], "kind": "commanddeclaration"}, {"full_name": "map_finset_sup'", "code": "@[simp]\ntheorem _root_.map_finset_sup' [SemilatticeSup \u03b2] [SupHomClass F \u03b1 \u03b2] (f : F) {s : Finset \u03b9} (hs)\n    (g : \u03b9 \u2192 \u03b1) : f (s.sup' hs g) = s.sup' hs (f \u2218 g)", "start": [894, 1], "end": [897, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_image", "code": "@[simp]\ntheorem sup'_image [DecidableEq \u03b2] {s : Finset \u03b3} {f : \u03b3 \u2192 \u03b2} (hs : (s.image f).Nonempty)\n    (g : \u03b2 \u2192 \u03b1) (hs' : s.Nonempty := (Nonempty.image_iff _).1 hs) :\n    (s.image f).sup' hs g = s.sup' hs' (g \u2218 f)", "start": [900, 1], "end": [904, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_map", "code": "@[simp]\ntheorem sup'_map {s : Finset \u03b3} {f : \u03b3 \u21aa \u03b2} (g : \u03b2 \u2192 \u03b1) (hs : (s.map f).Nonempty)\n    (hs' : s.Nonempty := Finset.map_nonempty.mp hs) : (s.map f).sup' hs g = s.sup' hs' (g \u2218 f)", "start": [907, 1], "end": [911, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_mono", "code": "theorem sup'_mono {s\u2081 s\u2082 : Finset \u03b2} (h : s\u2081 \u2286 s\u2082) (h\u2081 : s\u2081.Nonempty):\n    s\u2081.sup' h\u2081 f \u2264 s\u2082.sup' (h\u2081.mono h) f", "start": [914, 1], "end": [916, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_of_mem", "code": "theorem inf_of_mem {s : Finset \u03b2} (f : \u03b2 \u2192 \u03b1) {b : \u03b2} (h : b \u2208 s) :\n    \u2203 a : \u03b1, s.inf ((\u2191) \u2218 f : \u03b2 \u2192 WithTop \u03b1) = \u2191a", "start": [924, 1], "end": [926, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'", "code": "def inf' (s : Finset \u03b2) (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  WithTop.untop (s.inf ((\u2191) \u2218 f)) (by simpa using H)", "start": [929, 1], "end": [933, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_inf'", "code": "@[simp]\ntheorem coe_inf' : ((s.inf' H f : \u03b1) : WithTop \u03b1) = s.inf ((\u2191) \u2218 f)", "start": [938, 1], "end": [940, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_cons", "code": "@[simp]\ntheorem inf'_cons {b : \u03b2} {hb : b \u2209 s} {h : (cons b s hb).Nonempty} :\n    (cons b s hb).inf' h f = f b \u2293 s.inf' H f", "start": [943, 1], "end": [946, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_insert", "code": "@[simp]\ntheorem inf'_insert [DecidableEq \u03b2] {b : \u03b2} {h : (insert b s).Nonempty} :\n    (insert b s).inf' h f = f b \u2293 s.inf' H f", "start": [949, 1], "end": [952, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_singleton", "code": "@[simp]\ntheorem inf'_singleton {b : \u03b2} {h : ({b} : Finset \u03b2).Nonempty} : ({b} : Finset \u03b2).inf' h f = f b", "start": [955, 1], "end": [957, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.le_inf'", "code": "theorem le_inf' {a : \u03b1} (hs : \u2200 b \u2208 s, a \u2264 f b) : a \u2264 s.inf' H f", "start": [960, 1], "end": [961, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_le", "code": "theorem inf'_le {b : \u03b2} (h : b \u2208 s) : s.inf' \u27e8b, h\u27e9 f \u2264 f b", "start": [964, 1], "end": [965, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_le_of_le", "code": "theorem inf'_le_of_le (hb : b \u2208 s) (h : f b \u2264 a) : s.inf' \u27e8b, hb\u27e9 f \u2264 a", "start": [968, 1], "end": [968, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_const", "code": "@[simp]\ntheorem inf'_const (a : \u03b1) : (s.inf' H fun _ => a) = a", "start": [971, 1], "end": [973, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.le_inf'_iff", "code": "@[simp]\ntheorem le_inf'_iff {a : \u03b1} : a \u2264 s.inf' H f \u2194 \u2200 b \u2208 s, a \u2264 f b", "start": [976, 1], "end": [978, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_union", "code": "theorem inf'_union [DecidableEq \u03b2] {s\u2081 s\u2082 : Finset \u03b2} (h\u2081 : s\u2081.Nonempty) (h\u2082 : s\u2082.Nonempty)\n    (f : \u03b2 \u2192 \u03b1) :\n    (s\u2081 \u222a s\u2082).inf' (h\u2081.mono <| subset_union_left _ _) f = s\u2081.inf' h\u2081 f \u2293 s\u2082.inf' h\u2082 f", "start": [981, 1], "end": [984, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_biUnion", "code": "theorem inf'_biUnion [DecidableEq \u03b2] {s : Finset \u03b3} (Hs : s.Nonempty) {t : \u03b3 \u2192 Finset \u03b2}\n    (Ht : \u2200 b, (t b).Nonempty) :\n    (s.biUnion t).inf' (Hs.biUnion fun b _ => Ht b) f = s.inf' Hs (fun b => (t b).inf' (Ht b) f)", "start": [987, 1], "end": [990, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_comm", "code": "protected theorem inf'_comm {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) :\n    (s.inf' hs fun b => t.inf' ht (f b)) = t.inf' ht fun c => s.inf' hs fun b => f b c", "start": [993, 1], "end": [995, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_product_left", "code": "theorem inf'_product_left {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).inf' (hs.product ht) f = s.inf' hs fun i => t.inf' ht fun i' => f \u27e8i, i'\u27e9", "start": [998, 1], "end": [1000, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_product_right", "code": "theorem inf'_product_right {t : Finset \u03b3} (hs : s.Nonempty) (ht : t.Nonempty) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (s \u00d7\u02e2 t).inf' (hs.product ht) f = t.inf' ht fun i' => s.inf' hs fun i => f \u27e8i, i'\u27e9", "start": [1003, 1], "end": [1005, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.comp_inf'_eq_inf'_comp", "code": "theorem comp_inf'_eq_inf'_comp [SemilatticeInf \u03b3] {s : Finset \u03b2} (H : s.Nonempty) {f : \u03b2 \u2192 \u03b1}\n    (g : \u03b1 \u2192 \u03b3) (g_inf : \u2200 x y, g (x \u2293 y) = g x \u2293 g y) : g (s.inf' H f) = s.inf' H (g \u2218 f)", "start": [1008, 1], "end": [1010, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_induction", "code": "theorem inf'_induction {p : \u03b1 \u2192 Prop} (hp : \u2200 a\u2081, p a\u2081 \u2192 \u2200 a\u2082, p a\u2082 \u2192 p (a\u2081 \u2293 a\u2082))\n    (hs : \u2200 b \u2208 s, p (f b)) : p (s.inf' H f)", "start": [1013, 1], "end": [1015, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_mem", "code": "theorem inf'_mem (s : Set \u03b1) (w : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x \u2293 y \u2208 s) {\u03b9 : Type*}\n    (t : Finset \u03b9) (H : t.Nonempty) (p : \u03b9 \u2192 \u03b1) (h : \u2200 i \u2208 t, p i \u2208 s) : t.inf' H p \u2208 s", "start": [1018, 1], "end": [1020, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_congr", "code": "@[congr]\ntheorem inf'_congr {t : Finset \u03b2} {f g : \u03b2 \u2192 \u03b1} (h\u2081 : s = t) (h\u2082 : \u2200 x \u2208 s, f x = g x) :\n    s.inf' H f = t.inf' (h\u2081 \u25b8 H) g", "start": [1023, 1], "end": [1026, 32], "kind": "commanddeclaration"}, {"full_name": "map_finset_inf'", "code": "@[simp]\ntheorem _root_.map_finset_inf' [SemilatticeInf \u03b2] [InfHomClass F \u03b1 \u03b2] (f : F) {s : Finset \u03b9} (hs)\n    (g : \u03b9 \u2192 \u03b1) : f (s.inf' hs g) = s.inf' hs (f \u2218 g)", "start": [1029, 1], "end": [1032, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_image", "code": "@[simp]\ntheorem inf'_image [DecidableEq \u03b2] {s : Finset \u03b3} {f : \u03b3 \u2192 \u03b2} (hs : (s.image f).Nonempty)\n    (g : \u03b2 \u2192 \u03b1) (hs' : s.Nonempty := (Nonempty.image_iff _).1 hs) :\n    (s.image f).inf' hs g = s.inf' hs' (g \u2218 f)", "start": [1035, 1], "end": [1039, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_map", "code": "@[simp]\ntheorem inf'_map {s : Finset \u03b3} {f : \u03b3 \u21aa \u03b2} (g : \u03b2 \u2192 \u03b1) (hs : (s.map f).Nonempty)\n    (hs' : s.Nonempty := Finset.map_nonempty.mp hs) : (s.map f).inf' hs g = s.inf' hs' (g \u2218 f)", "start": [1042, 1], "end": [1045, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_mono", "code": "theorem inf'_mono {s\u2081 s\u2082 : Finset \u03b2} (h : s\u2081 \u2286 s\u2082) (h\u2081 : s\u2081.Nonempty) :\n    s\u2082.inf' (h\u2081.mono h) f \u2264 s\u2081.inf' h\u2081 f", "start": [1048, 1], "end": [1050, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_eq_sup", "code": "theorem sup'_eq_sup {s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1) : s.sup' H f = s.sup f", "start": [1058, 1], "end": [1059, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sup_of_nonempty", "code": "theorem coe_sup_of_nonempty {s : Finset \u03b2} (h : s.Nonempty) (f : \u03b2 \u2192 \u03b1) :\n    (\u2191(s.sup f) : WithBot \u03b1) = s.sup ((\u2191) \u2218 f)", "start": [1062, 1], "end": [1063, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_eq_inf", "code": "theorem inf'_eq_inf {s : Finset \u03b2} (H : s.Nonempty) (f : \u03b2 \u2192 \u03b1) : s.inf' H f = s.inf f", "start": [1072, 1], "end": [1073, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_inf_of_nonempty", "code": "theorem coe_inf_of_nonempty {s : Finset \u03b2} (h : s.Nonempty) (f : \u03b2 \u2192 \u03b1) :\n    (\u2191(s.inf f) : WithTop \u03b1) = s.inf ((\u2191) \u2218 f)", "start": [1076, 1], "end": [1078, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_apply", "code": "@[simp]\nprotected theorem sup_apply {C : \u03b2 \u2192 Type*} [\u2200 b : \u03b2, SemilatticeSup (C b)]\n    [\u2200 b : \u03b2, OrderBot (C b)] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2200 b : \u03b2, C b) (b : \u03b2) :\n    s.sup f b = s.sup fun a => f a b", "start": [1083, 1], "end": [1087, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_apply", "code": "@[simp]\nprotected theorem inf_apply {C : \u03b2 \u2192 Type*} [\u2200 b : \u03b2, SemilatticeInf (C b)]\n    [\u2200 b : \u03b2, OrderTop (C b)] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2200 b : \u03b2, C b) (b : \u03b2) :\n    s.inf f b = s.inf fun a => f a b", "start": [1090, 1], "end": [1094, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_apply", "code": "@[simp]\nprotected theorem sup'_apply {C : \u03b2 \u2192 Type*} [\u2200 b : \u03b2, SemilatticeSup (C b)]\n    {s : Finset \u03b1} (H : s.Nonempty) (f : \u03b1 \u2192 \u2200 b : \u03b2, C b) (b : \u03b2) :\n    s.sup' H f b = s.sup' H fun a => f a b", "start": [1097, 1], "end": [1101, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_apply", "code": "@[simp]\nprotected theorem inf'_apply {C : \u03b2 \u2192 Type*} [\u2200 b : \u03b2, SemilatticeInf (C b)]\n    {s : Finset \u03b1} (H : s.Nonempty) (f : \u03b1 \u2192 \u2200 b : \u03b2, C b) (b : \u03b2) :\n    s.inf' H f b = s.inf' H fun a => f a b", "start": [1104, 1], "end": [1108, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_sup'", "code": "@[simp]\ntheorem toDual_sup' [SemilatticeSup \u03b1] {s : Finset \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    toDual (s.sup' hs f) = s.inf' hs (toDual \u2218 f)", "start": [1111, 1], "end": [1114, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_inf'", "code": "@[simp]\ntheorem toDual_inf' [SemilatticeInf \u03b1] {s : Finset \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    toDual (s.inf' hs f) = s.sup' hs (toDual \u2218 f)", "start": [1117, 1], "end": [1120, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_sup'", "code": "@[simp]\ntheorem ofDual_sup' [SemilatticeInf \u03b1] {s : Finset \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1\u1d52\u1d48) :\n    ofDual (s.sup' hs f) = s.inf' hs (ofDual \u2218 f)", "start": [1123, 1], "end": [1126, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_inf'", "code": "@[simp]\ntheorem ofDual_inf' [SemilatticeSup \u03b1] {s : Finset \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 \u03b1\u1d52\u1d48) :\n    ofDual (s.inf' hs f) = s.sup' hs (ofDual \u2218 f)", "start": [1129, 1], "end": [1132, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_inf_distrib_left", "code": "theorem sup'_inf_distrib_left (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : a \u2293 s.sup' hs f = s.sup' hs \u03bb i => a \u2293 f i", "start": [1139, 1], "end": [1143, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_inf_distrib_right", "code": "theorem sup'_inf_distrib_right (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : s.sup' hs f \u2293 a = s.sup' hs fun i => f i \u2293 a", "start": [1146, 1], "end": [1147, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_inf_sup'", "code": "theorem sup'_inf_sup' (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    s.sup' hs f \u2293 t.sup' ht g = (s \u00d7\u02e2 t).sup' (hs.product ht) fun i => f i.1 \u2293 g i.2", "start": [1150, 1], "end": [1152, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_sup_distrib_left", "code": "theorem inf'_sup_distrib_left (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : a \u2294 s.inf' hs f = s.inf' hs fun i => a \u2294 f i", "start": [1155, 1], "end": [1156, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_sup_distrib_right", "code": "theorem inf'_sup_distrib_right (f : \u03b9 \u2192 \u03b1) (a : \u03b1) : s.inf' hs f \u2294 a = s.inf' hs fun i => f i \u2294 a", "start": [1159, 1], "end": [1160, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_sup_inf'", "code": "theorem inf'_sup_inf' (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\n    s.inf' hs f \u2294 t.inf' ht g = (s \u00d7\u02e2 t).inf' (hs.product ht) fun i => f i.1 \u2294 g i.2", "start": [1163, 1], "end": [1165, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sup'_iff", "code": "@[simp]\ntheorem le_sup'_iff : a \u2264 s.sup' H f \u2194 \u2203 b \u2208 s, a \u2264 f b", "start": [1174, 1], "end": [1177, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_sup'_iff", "code": "@[simp]\ntheorem lt_sup'_iff : a < s.sup' H f \u2194 \u2203 b \u2208 s, a < f b", "start": [1180, 1], "end": [1183, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_lt_iff", "code": "@[simp]\ntheorem sup'_lt_iff : s.sup' H f < a \u2194 \u2200 i \u2208 s, f i < a", "start": [1186, 1], "end": [1189, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_le_iff", "code": "@[simp]\ntheorem inf'_le_iff : s.inf' H f \u2264 a \u2194 \u2203 i \u2208 s, f i \u2264 a", "start": [1192, 1], "end": [1194, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_lt_iff", "code": "@[simp]\ntheorem inf'_lt_iff : s.inf' H f < a \u2194 \u2203 i \u2208 s, f i < a", "start": [1197, 1], "end": [1199, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_inf'_iff", "code": "@[simp]\ntheorem lt_inf'_iff : a < s.inf' H f \u2194 \u2200 i \u2208 s, a < f i", "start": [1202, 1], "end": [1204, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_mem_eq_sup'", "code": "theorem exists_mem_eq_sup' (f : \u03b9 \u2192 \u03b1) : \u2203 i, i \u2208 s \u2227 s.sup' H f = f i", "start": [1207, 1], "end": [1214, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_mem_eq_inf'", "code": "theorem exists_mem_eq_inf' (f : \u03b9 \u2192 \u03b1) : \u2203 i, i \u2208 s \u2227 s.inf' H f = f i", "start": [1217, 1], "end": [1218, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_mem_eq_sup", "code": "theorem exists_mem_eq_sup [OrderBot \u03b1] (s : Finset \u03b9) (h : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i, i \u2208 s \u2227 s.sup f = f i", "start": [1221, 1], "end": [1223, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_mem_eq_inf", "code": "theorem exists_mem_eq_inf [OrderTop \u03b1] (s : Finset \u03b9) (h : s.Nonempty) (f : \u03b9 \u2192 \u03b1) :\n    \u2203 i, i \u2208 s \u2227 s.inf f = f i", "start": [1226, 1], "end": [1228, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.max", "code": "protected def max (s : Finset \u03b1) : WithBot \u03b1 :=\n  sup s (\u2191)", "start": [1240, 1], "end": [1244, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.max_eq_sup_coe", "code": "theorem max_eq_sup_coe {s : Finset \u03b1} : s.max = s.sup (\u2191)", "start": [1247, 1], "end": [1248, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.max_eq_sup_withBot", "code": "theorem max_eq_sup_withBot (s : Finset \u03b1) : s.max = sup s (\u2191)", "start": [1251, 1], "end": [1252, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.max_empty", "code": "@[simp]\ntheorem max_empty : (\u2205 : Finset \u03b1).max = \u22a5", "start": [1255, 1], "end": [1257, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.max_insert", "code": "@[simp]\ntheorem max_insert {a : \u03b1} {s : Finset \u03b1} : (insert a s).max = max \u2191a s.max", "start": [1260, 1], "end": [1262, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.max_singleton", "code": "@[simp]\ntheorem max_singleton {a : \u03b1} : Finset.max {a} = (a : WithBot \u03b1)", "start": [1265, 1], "end": [1268, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.max_of_mem", "code": "theorem max_of_mem {s : Finset \u03b1} {a : \u03b1} (h : a \u2208 s) : \u2203 b : \u03b1, s.max = b", "start": [1271, 1], "end": [1273, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.max_of_nonempty", "code": "theorem max_of_nonempty {s : Finset \u03b1} (h : s.Nonempty) : \u2203 a : \u03b1, s.max = a", "start": [1276, 1], "end": [1278, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.max_eq_bot", "code": "theorem max_eq_bot {s : Finset \u03b1} : s.max = \u22a5 \u2194 s = \u2205", "start": [1281, 1], "end": [1285, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_max", "code": "theorem mem_of_max {s : Finset \u03b1} : \u2200 {a : \u03b1}, s.max = a \u2192 a \u2208 s", "start": [1288, 1], "end": [1298, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.le_max", "code": "theorem le_max {a : \u03b1} {s : Finset \u03b1} (as : a \u2208 s) : \u2191a \u2264 s.max", "start": [1301, 1], "end": [1302, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_of_max_lt_coe", "code": "theorem not_mem_of_max_lt_coe {a : \u03b1} {s : Finset \u03b1} (h : s.max < a) : a \u2209 s", "start": [1305, 1], "end": [1306, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.le_max_of_eq", "code": "theorem le_max_of_eq {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : a \u2208 s) (h\u2082 : s.max = b) : a \u2264 b", "start": [1309, 1], "end": [1310, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_of_max_lt", "code": "theorem not_mem_of_max_lt {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : b < a) (h\u2082 : s.max = \u2191b) : a \u2209 s", "start": [1313, 1], "end": [1314, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.max_mono", "code": "theorem max_mono {s t : Finset \u03b1} (st : s \u2286 t) : s.max \u2264 t.max", "start": [1317, 1], "end": [1318, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.max_le", "code": "protected theorem max_le {M : WithBot \u03b1} {s : Finset \u03b1} (st : \u2200 a \u2208 s, (a : WithBot \u03b1) \u2264 M) :\n    s.max \u2264 M", "start": [1321, 1], "end": [1323, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.min", "code": "protected def min (s : Finset \u03b1) : WithTop \u03b1 :=\n  inf s (\u2191)", "start": [1326, 1], "end": [1330, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.min_eq_inf_withTop", "code": "theorem min_eq_inf_withTop (s : Finset \u03b1) : s.min = inf s (\u2191)", "start": [1333, 1], "end": [1334, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.min_empty", "code": "@[simp]\ntheorem min_empty : (\u2205 : Finset \u03b1).min = \u22a4", "start": [1337, 1], "end": [1339, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.min_insert", "code": "@[simp]\ntheorem min_insert {a : \u03b1} {s : Finset \u03b1} : (insert a s).min = min (\u2191a) s.min", "start": [1342, 1], "end": [1344, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.min_singleton", "code": "@[simp]\ntheorem min_singleton {a : \u03b1} : Finset.min {a} = (a : WithTop \u03b1)", "start": [1347, 1], "end": [1350, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.min_of_mem", "code": "theorem min_of_mem {s : Finset \u03b1} {a : \u03b1} (h : a \u2208 s) : \u2203 b : \u03b1, s.min = b", "start": [1353, 1], "end": [1355, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.min_of_nonempty", "code": "theorem min_of_nonempty {s : Finset \u03b1} (h : s.Nonempty) : \u2203 a : \u03b1, s.min = a", "start": [1358, 1], "end": [1360, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.min_eq_top", "code": "theorem min_eq_top {s : Finset \u03b1} : s.min = \u22a4 \u2194 s = \u2205", "start": [1363, 1], "end": [1368, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_of_min", "code": "theorem mem_of_min {s : Finset \u03b1} : \u2200 {a : \u03b1}, s.min = a \u2192 a \u2208 s", "start": [1371, 1], "end": [1372, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.min_le", "code": "theorem min_le {a : \u03b1} {s : Finset \u03b1} (as : a \u2208 s) : s.min \u2264 a", "start": [1375, 1], "end": [1376, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_of_coe_lt_min", "code": "theorem not_mem_of_coe_lt_min {a : \u03b1} {s : Finset \u03b1} (h : \u2191a < s.min) : a \u2209 s", "start": [1379, 1], "end": [1380, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.min_le_of_eq", "code": "theorem min_le_of_eq {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : b \u2208 s) (h\u2082 : s.min = a) : a \u2264 b", "start": [1383, 1], "end": [1384, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_of_lt_min", "code": "theorem not_mem_of_lt_min {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : a < b) (h\u2082 : s.min = \u2191b) : a \u2209 s", "start": [1387, 1], "end": [1388, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.min_mono", "code": "theorem min_mono {s t : Finset \u03b1} (st : s \u2286 t) : t.min \u2264 s.min", "start": [1391, 1], "end": [1392, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.le_min", "code": "protected theorem le_min {m : WithTop \u03b1} {s : Finset \u03b1} (st : \u2200 a : \u03b1, a \u2208 s \u2192 m \u2264 a) : m \u2264 s.min", "start": [1395, 1], "end": [1396, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.min'", "code": "def min' (s : Finset \u03b1) (H : s.Nonempty) : \u03b1 :=\n  inf' s H id", "start": [1399, 1], "end": [1403, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.max'", "code": "def max' (s : Finset \u03b1) (H : s.Nonempty) : \u03b1 :=\n  sup' s H id", "start": [1406, 1], "end": [1410, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_mem", "code": "theorem min'_mem : s.min' H \u2208 s", "start": [1415, 1], "end": [1416, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_le", "code": "theorem min'_le (x) (H2 : x \u2208 s) : s.min' \u27e8x, H2\u27e9 \u2264 x", "start": [1419, 1], "end": [1420, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.le_min'", "code": "theorem le_min' (x) (H2 : \u2200 y \u2208 s, x \u2264 y) : x \u2264 s.min' H", "start": [1423, 1], "end": [1424, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.isLeast_min'", "code": "theorem isLeast_min' : IsLeast (\u2191s) (s.min' H)", "start": [1427, 1], "end": [1428, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.le_min'_iff", "code": "@[simp]\ntheorem le_min'_iff {x} : x \u2264 s.min' H \u2194 \u2200 y \u2208 s, x \u2264 y", "start": [1431, 1], "end": [1433, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_singleton", "code": "@[simp]\ntheorem min'_singleton (a : \u03b1) : ({a} : Finset \u03b1).min' (singleton_nonempty _) = a", "start": [1436, 1], "end": [1438, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_mem", "code": "theorem max'_mem : s.max' H \u2208 s", "start": [1441, 1], "end": [1442, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.le_max'", "code": "theorem le_max' (x) (H2 : x \u2208 s) : x \u2264 s.max' \u27e8x, H2\u27e9", "start": [1445, 1], "end": [1446, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_le", "code": "theorem max'_le (x) (H2 : \u2200 y \u2208 s, y \u2264 x) : s.max' H \u2264 x", "start": [1449, 1], "end": [1450, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.isGreatest_max'", "code": "theorem isGreatest_max' : IsGreatest (\u2191s) (s.max' H)", "start": [1453, 1], "end": [1454, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_le_iff", "code": "@[simp]\ntheorem max'_le_iff {x} : s.max' H \u2264 x \u2194 \u2200 y \u2208 s, y \u2264 x", "start": [1457, 1], "end": [1459, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_lt_iff", "code": "@[simp]\ntheorem max'_lt_iff {x} : s.max' H < x \u2194 \u2200 y \u2208 s, y < x", "start": [1462, 1], "end": [1464, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_min'_iff", "code": "@[simp]\ntheorem lt_min'_iff : x < s.min' H \u2194 \u2200 y \u2208 s, x < y", "start": [1467, 1], "end": [1469, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_eq_sup'", "code": "theorem max'_eq_sup' : s.max' H = s.sup' H id", "start": [1472, 1], "end": [1473, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_eq_inf'", "code": "theorem min'_eq_inf' : s.min' H = s.inf' H id", "start": [1476, 1], "end": [1477, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_singleton", "code": "@[simp]\ntheorem max'_singleton (a : \u03b1) : ({a} : Finset \u03b1).max' (singleton_nonempty _) = a", "start": [1480, 1], "end": [1482, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_lt_max'", "code": "theorem min'_lt_max' {i j} (H1 : i \u2208 s) (H2 : j \u2208 s) (H3 : i \u2260 j) :\n    s.min' \u27e8i, H1\u27e9 < s.max' \u27e8i, H1\u27e9", "start": [1485, 1], "end": [1487, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_lt_max'_of_card", "code": "theorem min'_lt_max'_of_card (h\u2082 : 1 < card s) :\n    s.min' (Finset.card_pos.mp <| lt_trans zero_lt_one h\u2082) <\n      s.max' (Finset.card_pos.mp <| lt_trans zero_lt_one h\u2082)", "start": [1490, 1], "end": [1497, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.map_ofDual_min", "code": "theorem map_ofDual_min (s : Finset \u03b1\u1d52\u1d48) : s.min.map ofDual = (s.image ofDual).max", "start": [1500, 1], "end": [1502, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.map_ofDual_max", "code": "theorem map_ofDual_max (s : Finset \u03b1\u1d52\u1d48) : s.max.map ofDual = (s.image ofDual).min", "start": [1505, 1], "end": [1507, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.map_toDual_min", "code": "theorem map_toDual_min (s : Finset \u03b1) : s.min.map toDual = (s.image toDual).max", "start": [1510, 1], "end": [1512, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.map_toDual_max", "code": "theorem map_toDual_max (s : Finset \u03b1) : s.max.map toDual = (s.image toDual).min", "start": [1515, 1], "end": [1517, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_min'", "code": "theorem ofDual_min' {s : Finset \u03b1\u1d52\u1d48} (hs : s.Nonempty) :\n    ofDual (min' s hs) = max' (s.image ofDual) (hs.image _)", "start": [1522, 1], "end": [1527, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.ofDual_max'", "code": "theorem ofDual_max' {s : Finset \u03b1\u1d52\u1d48} (hs : s.Nonempty) :\n    ofDual (max' s hs) = min' (s.image ofDual) (hs.image _)", "start": [1530, 1], "end": [1535, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_min'", "code": "theorem toDual_min' {s : Finset \u03b1} (hs : s.Nonempty) :\n    toDual (min' s hs) = max' (s.image toDual) (hs.image _)", "start": [1538, 1], "end": [1543, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.toDual_max'", "code": "theorem toDual_max' {s : Finset \u03b1} (hs : s.Nonempty) :\n    toDual (max' s hs) = min' (s.image toDual) (hs.image _)", "start": [1546, 1], "end": [1551, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_subset", "code": "theorem max'_subset {s t : Finset \u03b1} (H : s.Nonempty) (hst : s \u2286 t) :\n    s.max' H \u2264 t.max' (H.mono hst)", "start": [1554, 1], "end": [1556, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_subset", "code": "theorem min'_subset {s t : Finset \u03b1} (H : s.Nonempty) (hst : s \u2286 t) :\n    t.min' (H.mono hst) \u2264 s.min' H", "start": [1559, 1], "end": [1561, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_insert", "code": "theorem max'_insert (a : \u03b1) (s : Finset \u03b1) (H : s.Nonempty) :\n    (insert a s).max' (s.insert_nonempty a) = max (s.max' H) a", "start": [1564, 1], "end": [1568, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_insert", "code": "theorem min'_insert (a : \u03b1) (s : Finset \u03b1) (H : s.Nonempty) :\n    (insert a s).min' (s.insert_nonempty a) = min (s.min' H) a", "start": [1571, 1], "end": [1575, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.lt_max'_of_mem_erase_max'", "code": "theorem lt_max'_of_mem_erase_max' [DecidableEq \u03b1] {a : \u03b1} (ha : a \u2208 s.erase (s.max' H)) :\n    a < s.max' H", "start": [1578, 1], "end": [1580, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_lt_of_mem_erase_min'", "code": "theorem min'_lt_of_mem_erase_min' [DecidableEq \u03b1] {a : \u03b1} (ha : a \u2208 s.erase (s.min' H)) :\n    s.min' H < a", "start": [1583, 1], "end": [1585, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_image", "code": "@[simp]\ntheorem max'_image [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (s : Finset \u03b1)\n    (h : (s.image f).Nonempty) : (s.image f).max' h = f (s.max' ((Nonempty.image_iff f).mp h))", "start": [1588, 1], "end": [1594, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_image", "code": "@[simp]\ntheorem min'_image [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (s : Finset \u03b1)\n    (h : (s.image f).Nonempty) : (s.image f).min' h = f (s.min' ((Nonempty.image_iff f).mp h))", "start": [1597, 1], "end": [1603, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_max'", "code": "theorem coe_max' {s : Finset \u03b1} (hs : s.Nonempty) : \u2191(s.max' hs) = s.max", "start": [1606, 1], "end": [1607, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_min'", "code": "theorem coe_min' {s : Finset \u03b1} (hs : s.Nonempty) : \u2191(s.min' hs) = s.min", "start": [1610, 1], "end": [1611, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.max_mem_image_coe", "code": "theorem max_mem_image_coe {s : Finset \u03b1} (hs : s.Nonempty) :\n    s.max \u2208 (s.image (\u2191) : Finset (WithBot \u03b1))", "start": [1614, 1], "end": [1616, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.min_mem_image_coe", "code": "theorem min_mem_image_coe {s : Finset \u03b1} (hs : s.Nonempty) :\n    s.min \u2208 (s.image (\u2191) : Finset (WithTop \u03b1))", "start": [1619, 1], "end": [1621, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.max_mem_insert_bot_image_coe", "code": "theorem max_mem_insert_bot_image_coe (s : Finset \u03b1) :\n    s.max \u2208 (insert \u22a5 (s.image (\u2191)) : Finset (WithBot \u03b1))", "start": [1624, 1], "end": [1626, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.min_mem_insert_top_image_coe", "code": "theorem min_mem_insert_top_image_coe (s : Finset \u03b1) :\n    s.min \u2208 (insert \u22a4 (s.image (\u2191)) : Finset (WithTop \u03b1))", "start": [1629, 1], "end": [1631, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_erase_ne_self", "code": "theorem max'_erase_ne_self {s : Finset \u03b1} (s0 : (s.erase x).Nonempty) : (s.erase x).max' s0 \u2260 x", "start": [1634, 1], "end": [1635, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_erase_ne_self", "code": "theorem min'_erase_ne_self {s : Finset \u03b1} (s0 : (s.erase x).Nonempty) : (s.erase x).min' s0 \u2260 x", "start": [1638, 1], "end": [1639, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.max_erase_ne_self", "code": "theorem max_erase_ne_self {s : Finset \u03b1} : (s.erase x).max \u2260 x", "start": [1642, 1], "end": [1647, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.min_erase_ne_self", "code": "theorem min_erase_ne_self {s : Finset \u03b1} : (s.erase x).min \u2260 x", "start": [1650, 1], "end": [1655, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_next_right", "code": "theorem exists_next_right {x : \u03b1} {s : Finset \u03b1} (h : \u2203 y \u2208 s, x < y) :\n    \u2203 y \u2208 s, x < y \u2227 \u2200 z \u2208 s, x < z \u2192 y \u2264 z", "start": [1658, 1], "end": [1662, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_next_left", "code": "theorem exists_next_left {x : \u03b1} {s : Finset \u03b1} (h : \u2203 y \u2208 s, y < x) :\n    \u2203 y \u2208 s, y < x \u2227 \u2200 z \u2208 s, z < x \u2192 z \u2264 y", "start": [1665, 1], "end": [1667, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_of_interleaved", "code": "theorem card_le_of_interleaved {s t : Finset \u03b1}\n    (h : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s),\n        x < y \u2192 (\u2200 z \u2208 s, z \u2209 Set.Ioo x y) \u2192 \u2203 z \u2208 t, x < z \u2227 z < y) :\n    s.card \u2264 t.card + 1", "start": [1670, 1], "end": [1696, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_diff_of_interleaved", "code": "theorem card_le_diff_of_interleaved {s t : Finset \u03b1}\n    (h :\n      \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s),\n        x < y \u2192 (\u2200 z \u2208 s, z \u2209 Set.Ioo x y) \u2192 \u2203 z \u2208 t, x < z \u2227 z < y) :\n    s.card \u2264 (t \\ s).card + 1", "start": [1699, 1], "end": [1707, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_max", "code": "@[elab_as_elim]\ntheorem induction_on_max [DecidableEq \u03b1] {p : Finset \u03b1 \u2192 Prop} (s : Finset \u03b1) (h0 : p \u2205)\n    (step : \u2200 a s, (\u2200 x \u2208 s, x < a) \u2192 p s \u2192 p (insert a s)) : p s", "start": [1710, 1], "end": [1724, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_min", "code": "@[elab_as_elim]\ntheorem induction_on_min [DecidableEq \u03b1] {p : Finset \u03b1 \u2192 Prop} (s : Finset \u03b1) (h0 : p \u2205)\n    (step : \u2200 a s, (\u2200 x \u2208 s, a < x) \u2192 p s \u2192 p (insert a s)) : p s", "start": [1727, 1], "end": [1736, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_max_value", "code": "@[elab_as_elim]\ntheorem induction_on_max_value [DecidableEq \u03b9] (f : \u03b9 \u2192 \u03b1) {p : Finset \u03b9 \u2192 Prop} (s : Finset \u03b9)\n    (h0 : p \u2205) (step : \u2200 a s, a \u2209 s \u2192 (\u2200 x \u2208 s, f x \u2264 f a) \u2192 p s \u2192 p (insert a s)) : p s", "start": [1745, 1], "end": [1764, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.induction_on_min_value", "code": "@[elab_as_elim]\ntheorem induction_on_min_value [DecidableEq \u03b9] (f : \u03b9 \u2192 \u03b1) {p : Finset \u03b9 \u2192 Prop} (s : Finset \u03b9)\n    (h0 : p \u2205) (step : \u2200 a s, a \u2209 s \u2192 (\u2200 x \u2208 s, f a \u2264 f x) \u2192 p s \u2192 p (insert a s)) : p s", "start": [1767, 1], "end": [1776, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_max_image", "code": "theorem exists_max_image (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) (h : s.Nonempty) :\n    \u2203 x \u2208 s, \u2200 x' \u2208 s, f x' \u2264 f x", "start": [1785, 1], "end": [1789, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_min_image", "code": "theorem exists_min_image (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) (h : s.Nonempty) :\n    \u2203 x \u2208 s, \u2200 x' \u2208 s, f x \u2264 f x'", "start": [1792, 1], "end": [1794, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.isGLB_iff_isLeast", "code": "theorem isGLB_iff_isLeast [LinearOrder \u03b1] (i : \u03b1) (s : Finset \u03b1) (hs : s.Nonempty) :\n    IsGLB (s : Set \u03b1) i \u2194 IsLeast (\u2191s) i", "start": [1799, 1], "end": [1806, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.isLUB_iff_isGreatest", "code": "theorem isLUB_iff_isGreatest [LinearOrder \u03b1] (i : \u03b1) (s : Finset \u03b1) (hs : s.Nonempty) :\n    IsLUB (s : Set \u03b1) i \u2194 IsGreatest (\u2191s) i", "start": [1809, 1], "end": [1811, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.isGLB_mem", "code": "theorem isGLB_mem [LinearOrder \u03b1] {i : \u03b1} (s : Finset \u03b1) (his : IsGLB (s : Set \u03b1) i)\n    (hs : s.Nonempty) : i \u2208 s", "start": [1814, 1], "end": [1817, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.isLUB_mem", "code": "theorem isLUB_mem [LinearOrder \u03b1] {i : \u03b1} (s : Finset \u03b1) (his : IsLUB (s : Set \u03b1) i)\n    (hs : s.Nonempty) : i \u2208 s", "start": [1820, 1], "end": [1822, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.map_finset_sup", "code": "theorem map_finset_sup [DecidableEq \u03b1] [DecidableEq \u03b2] (s : Finset \u03b3) (f : \u03b3 \u2192 Multiset \u03b2)\n    (g : \u03b2 \u2192 \u03b1) (hg : Function.Injective g) : map g (s.sup f) = s.sup (map g \u2218 f)", "start": [1829, 1], "end": [1831, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_finset_sup", "code": "theorem count_finset_sup [DecidableEq \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 Multiset \u03b2) (b : \u03b2) :\n    count b (s.sup f) = s.sup fun a => count b (f a)", "start": [1834, 1], "end": [1841, 8], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sup", "code": "theorem mem_sup {\u03b1 \u03b2} [DecidableEq \u03b2] {s : Finset \u03b1} {f : \u03b1 \u2192 Multiset \u03b2} {x : \u03b2} :\n    x \u2208 s.sup f \u2194 \u2203 v \u2208 s, x \u2208 f v", "start": [1844, 1], "end": [1862, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sup", "code": "theorem mem_sup {\u03b1 \u03b2} [DecidableEq \u03b2] {s : Finset \u03b1} {f : \u03b1 \u2192 Finset \u03b2} {x : \u03b2} :\n    x \u2208 s.sup f \u2194 \u2203 v \u2208 s, x \u2208 f v", "start": [1869, 1], "end": [1873, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_eq_biUnion", "code": "theorem sup_eq_biUnion {\u03b1 \u03b2} [DecidableEq \u03b2] (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) :\n    s.sup t = s.biUnion t", "start": [1876, 1], "end": [1879, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_singleton''", "code": "@[simp]\ntheorem sup_singleton'' [DecidableEq \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    (s.sup fun b => {f b}) = s.image f", "start": [1882, 1], "end": [1887, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_singleton'", "code": "@[simp]\ntheorem sup_singleton' [DecidableEq \u03b1] (s : Finset \u03b1) : s.sup singleton = s", "start": [1890, 1], "end": [1892, 39], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_iSup_finset", "code": "theorem iSup_eq_iSup_finset (s : \u03b9 \u2192 \u03b1) : \u2a06 i, s i = \u2a06 t : Finset \u03b9, \u2a06 i \u2208 t, s i", "start": [1901, 1], "end": [1908, 73], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_iSup_finset'", "code": "theorem iSup_eq_iSup_finset' (s : \u03b9' \u2192 \u03b1) :\n    \u2a06 i, s i = \u2a06 t : Finset (PLift \u03b9'), \u2a06 i \u2208 t, s (PLift.down i)", "start": [1911, 1], "end": [1916, 70], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_iInf_finset", "code": "theorem iInf_eq_iInf_finset (s : \u03b9 \u2192 \u03b1) : \u2a05 i, s i = \u2a05 (t : Finset \u03b9) (i \u2208 t), s i", "start": [1919, 1], "end": [1923, 33], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_iInf_finset'", "code": "theorem iInf_eq_iInf_finset' (s : \u03b9' \u2192 \u03b1) :\n    \u2a05 i, s i = \u2a05 t : Finset (PLift \u03b9'), \u2a05 i \u2208 t, s (PLift.down i)", "start": [1926, 1], "end": [1931, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_iUnion_finset", "code": "theorem iUnion_eq_iUnion_finset (s : \u03b9 \u2192 Set \u03b1) : \u22c3 i, s i = \u22c3 t : Finset \u03b9, \u22c3 i \u2208 t, s i", "start": [1940, 1], "end": [1944, 24], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_eq_iUnion_finset'", "code": "theorem iUnion_eq_iUnion_finset' (s : \u03b9' \u2192 Set \u03b1) :\n    \u22c3 i, s i = \u22c3 t : Finset (PLift \u03b9'), \u22c3 i \u2208 t, s (PLift.down i)", "start": [1947, 1], "end": [1952, 25], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_iInter_finset", "code": "theorem iInter_eq_iInter_finset (s : \u03b9 \u2192 Set \u03b1) : \u22c2 i, s i = \u22c2 t : Finset \u03b9, \u22c2 i \u2208 t, s i", "start": [1955, 1], "end": [1959, 24], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_eq_iInter_finset'", "code": "theorem iInter_eq_iInter_finset' (s : \u03b9' \u2192 Set \u03b1) :\n    \u22c2 i, s i = \u22c2 t : Finset (PLift \u03b9'), \u22c2 i \u2208 t, s (PLift.down i)", "start": [1962, 1], "end": [1968, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_mul_le_mul_sup_of_nonneg", "code": "theorem sup_mul_le_mul_sup_of_nonneg [LinearOrderedSemiring \u03b1] [OrderBot \u03b1] {a b : \u03b9 \u2192 \u03b1}\n    (s : Finset \u03b9) (ha : \u2200 i \u2208 s, 0 \u2264 a i) (hb : \u2200 i \u2208 s, 0 \u2264 b i) :\n    s.sup (a * b) \u2264 s.sup a * s.sup b", "start": [1978, 1], "end": [1982, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_inf_le_inf_mul_of_nonneg", "code": "theorem mul_inf_le_inf_mul_of_nonneg [LinearOrderedSemiring \u03b1] [OrderTop \u03b1] {a b : \u03b9 \u2192 \u03b1}\n    (s : Finset \u03b9) (ha : \u2200 i \u2208 s, 0 \u2264 a i) (hb : \u2200 i \u2208 s, 0 \u2264 b i) :\n    s.inf a * s.inf b \u2264 s.inf (a * b)", "start": [1985, 1], "end": [1988, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_mul_le_mul_sup'_of_nonneg", "code": "theorem sup'_mul_le_mul_sup'_of_nonneg [LinearOrderedSemiring \u03b1] {a b : \u03b9 \u2192 \u03b1} (s : Finset \u03b9)\n    (H : s.Nonempty) (ha : \u2200 i \u2208 s, 0 \u2264 a i) (hb : \u2200 i \u2208 s, 0 \u2264 b i) :\n    s.sup' H (a * b) \u2264 s.sup' H a * s.sup' H b", "start": [1991, 1], "end": [1995, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_mul_le_mul_inf'_of_nonneg", "code": "theorem inf'_mul_le_mul_inf'_of_nonneg [LinearOrderedSemiring \u03b1] {a b : \u03b9 \u2192 \u03b1} (s : Finset \u03b9)\n    (H : s.Nonempty) (ha : \u2200 i \u2208 s, 0 \u2264 a i) (hb : \u2200 i \u2208 s, 0 \u2264 b i) :\n    s.inf' H a * s.inf' H b \u2264 s.inf' H (a * b)", "start": [1998, 1], "end": [2001, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_coe", "code": "theorem iSup_coe [SupSet \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : \u2a06 x \u2208 (\u2191s : Set \u03b1), f x = \u2a06 x \u2208 s, f x", "start": [2011, 1], "end": [2012, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_coe", "code": "theorem iInf_coe [InfSet \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : \u2a05 x \u2208 (\u2191s : Set \u03b1), f x = \u2a05 x \u2208 s, f x", "start": [2015, 1], "end": [2016, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_singleton", "code": "theorem iSup_singleton (a : \u03b1) (s : \u03b1 \u2192 \u03b2) : \u2a06 x \u2208 ({a} : Finset \u03b1), s x = s a", "start": [2021, 1], "end": [2021, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_singleton", "code": "theorem iInf_singleton (a : \u03b1) (s : \u03b1 \u2192 \u03b2) : \u2a05 x \u2208 ({a} : Finset \u03b1), s x = s a", "start": [2024, 1], "end": [2024, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_option_toFinset", "code": "theorem iSup_option_toFinset (o : Option \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2a06 x \u2208 o.toFinset, f x = \u2a06 x \u2208 o, f x", "start": [2027, 1], "end": [2028, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_option_toFinset", "code": "theorem iInf_option_toFinset (o : Option \u03b1) (f : \u03b1 \u2192 \u03b2) : \u2a05 x \u2208 o.toFinset, f x = \u2a05 x \u2208 o, f x", "start": [2031, 1], "end": [2032, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_union", "code": "theorem iSup_union {f : \u03b1 \u2192 \u03b2} {s t : Finset \u03b1} :\n    \u2a06 x \u2208 s \u222a t, f x = (\u2a06 x \u2208 s, f x) \u2294 \u2a06 x \u2208 t, f x", "start": [2037, 1], "end": [2038, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_union", "code": "theorem iInf_union {f : \u03b1 \u2192 \u03b2} {s t : Finset \u03b1} :\n    \u2a05 x \u2208 s \u222a t, f x = (\u2a05 x \u2208 s, f x) \u2293 \u2a05 x \u2208 t, f x", "start": [2041, 1], "end": [2043, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_insert", "code": "theorem iSup_insert (a : \u03b1) (s : Finset \u03b1) (t : \u03b1 \u2192 \u03b2) :\n    \u2a06 x \u2208 insert a s, t x = t a \u2294 \u2a06 x \u2208 s, t x", "start": [2046, 1], "end": [2049, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_insert", "code": "theorem iInf_insert (a : \u03b1) (s : Finset \u03b1) (t : \u03b1 \u2192 \u03b2) :\n    \u2a05 x \u2208 insert a s, t x = t a \u2293 \u2a05 x \u2208 s, t x", "start": [2052, 1], "end": [2054, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_finset_image", "code": "theorem iSup_finset_image {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b2} {s : Finset \u03b3} :\n    \u2a06 x \u2208 s.image f, g x = \u2a06 y \u2208 s, g (f y)", "start": [2057, 1], "end": [2058, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_finset_image", "code": "theorem iInf_finset_image {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 \u03b2} {s : Finset \u03b3} :\n    \u2a05 x \u2208 s.image f, g x = \u2a05 y \u2208 s, g (f y)", "start": [2061, 1], "end": [2062, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_insert_update", "code": "theorem iSup_insert_update {x : \u03b1} {t : Finset \u03b1} (f : \u03b1 \u2192 \u03b2) {s : \u03b2} (hx : x \u2209 t) :\n    \u2a06 i \u2208 insert x t, Function.update f x s i = s \u2294 \u2a06 i \u2208 t, f i", "start": [2065, 1], "end": [2068, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_insert_update", "code": "theorem iInf_insert_update {x : \u03b1} {t : Finset \u03b1} (f : \u03b1 \u2192 \u03b2) {s : \u03b2} (hx : x \u2209 t) :\n    \u2a05 i \u2208 insert x t, update f x s i = s \u2293 \u2a05 i \u2208 t, f i", "start": [2071, 1], "end": [2073, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.iSup_biUnion", "code": "theorem iSup_biUnion (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u2a06 y \u2208 s.biUnion t, f y = \u2a06 (x \u2208 s) (y \u2208 t x), f y", "start": [2076, 1], "end": [2077, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.iInf_biUnion", "code": "theorem iInf_biUnion (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u2a05 y \u2208 s.biUnion t, f y = \u2a05 (x \u2208 s) (y \u2208 t x), f y", "start": [2080, 1], "end": [2082, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_coe", "code": "theorem set_biUnion_coe (s : Finset \u03b1) (t : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 (\u2191s : Set \u03b1), t x = \u22c3 x \u2208 s, t x", "start": [2087, 1], "end": [2088, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_coe", "code": "theorem set_biInter_coe (s : Finset \u03b1) (t : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 (\u2191s : Set \u03b1), t x = \u22c2 x \u2208 s, t x", "start": [2091, 1], "end": [2092, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_singleton", "code": "theorem set_biUnion_singleton (a : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 ({a} : Finset \u03b1), s x = s a", "start": [2095, 1], "end": [2096, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_singleton", "code": "theorem set_biInter_singleton (a : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 ({a} : Finset \u03b1), s x = s a", "start": [2099, 1], "end": [2100, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_preimage_singleton", "code": "@[simp]\ntheorem set_biUnion_preimage_singleton (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b2) :\n    \u22c3 y \u2208 s, f \u207b\u00b9' {y} = f \u207b\u00b9' s", "start": [2103, 1], "end": [2106, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_option_toFinset", "code": "theorem set_biUnion_option_toFinset (o : Option \u03b1) (f : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 o.toFinset, f x = \u22c3 x \u2208 o, f x", "start": [2109, 1], "end": [2111, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_option_toFinset", "code": "theorem set_biInter_option_toFinset (o : Option \u03b1) (f : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 o.toFinset, f x = \u22c2 x \u2208 o, f x", "start": [2114, 1], "end": [2116, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_set_biUnion_of_mem", "code": "theorem subset_set_biUnion_of_mem {s : Finset \u03b1} {f : \u03b1 \u2192 Set \u03b2} {x : \u03b1} (h : x \u2208 s) :\n    f x \u2286 \u22c3 y \u2208 s, f y", "start": [2119, 1], "end": [2121, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_union", "code": "theorem set_biUnion_union (s t : Finset \u03b1) (u : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 s \u222a t, u x = (\u22c3 x \u2208 s, u x) \u222a \u22c3 x \u2208 t, u x", "start": [2126, 1], "end": [2128, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_inter", "code": "theorem set_biInter_inter (s t : Finset \u03b1) (u : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 s \u222a t, u x = (\u22c2 x \u2208 s, u x) \u2229 \u22c2 x \u2208 t, u x", "start": [2131, 1], "end": [2133, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_insert", "code": "theorem set_biUnion_insert (a : \u03b1) (s : Finset \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 insert a s, t x = t a \u222a \u22c3 x \u2208 s, t x", "start": [2136, 1], "end": [2138, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_insert", "code": "theorem set_biInter_insert (a : \u03b1) (s : Finset \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 insert a s, t x = t a \u2229 \u22c2 x \u2208 s, t x", "start": [2141, 1], "end": [2143, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_finset_image", "code": "theorem set_biUnion_finset_image {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} {s : Finset \u03b3} :\n    \u22c3 x \u2208 s.image f, g x = \u22c3 y \u2208 s, g (f y)", "start": [2146, 1], "end": [2148, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_finset_image", "code": "theorem set_biInter_finset_image {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} {s : Finset \u03b3} :\n    \u22c2 x \u2208 s.image f, g x = \u22c2 y \u2208 s, g (f y)", "start": [2151, 1], "end": [2153, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_insert_update", "code": "theorem set_biUnion_insert_update {x : \u03b1} {t : Finset \u03b1} (f : \u03b1 \u2192 Set \u03b2) {s : Set \u03b2} (hx : x \u2209 t) :\n    \u22c3 i \u2208 insert x t, @update _ _ _ f x s i = s \u222a \u22c3 i \u2208 t, f i", "start": [2156, 1], "end": [2158, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_insert_update", "code": "theorem set_biInter_insert_update {x : \u03b1} {t : Finset \u03b1} (f : \u03b1 \u2192 Set \u03b2) {s : Set \u03b2} (hx : x \u2209 t) :\n    \u22c2 i \u2208 insert x t, @update _ _ _ f x s i = s \u2229 \u22c2 i \u2208 t, f i", "start": [2161, 1], "end": [2163, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biUnion_biUnion", "code": "theorem set_biUnion_biUnion (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1) (f : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 y \u2208 s.biUnion t, f y = \u22c3 (x \u2208 s) (y \u2208 t x), f y", "start": [2166, 1], "end": [2168, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.set_biInter_biUnion", "code": "theorem set_biInter_biUnion (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1) (f : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 y \u2208 s.biUnion t, f y = \u22c2 (x \u2208 s) (y \u2208 t x), f y", "start": [2171, 1], "end": [2173, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Vector/Basic.lean", "imports": ["Mathlib/Control/Applicative.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/OfFn.lean", "Mathlib/Data/List/Nodup.lean", "Mathlib/Control/Traversable/Basic.lean", "Mathlib/Data/Vector.lean"], "premises": [{"full_name": "Vector.toList_injective", "code": "theorem toList_injective : Function.Injective (@toList \u03b1 n)", "start": [39, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "Vector.ext", "code": "@[ext]\ntheorem ext : \u2200 {v w : Vector \u03b1 n} (_ : \u2200 m : Fin n, Vector.get v m = Vector.get w m), v = w", "start": [43, 1], "end": [47, 76], "kind": "commanddeclaration"}, {"full_name": "Vector.zero_subsingleton", "code": "instance zero_subsingleton : Subsingleton (Vector \u03b1 0) :=\n  \u27e8fun _ _ => Vector.ext fun m => Fin.elim0 m\u27e9", "start": [50, 1], "end": [52, 47], "kind": "commanddeclaration"}, {"full_name": "Vector.cons_val", "code": "@[simp]\ntheorem cons_val (a : \u03b1) : \u2200 v : Vector \u03b1 n, (a ::\u1d65 v).val = a :: v.val", "start": [55, 1], "end": [57, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.eq_cons_iff", "code": "theorem eq_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v = a ::\u1d65 v' \u2194 v.head = a \u2227 v.tail = v'", "start": [63, 1], "end": [66, 61], "kind": "commanddeclaration"}, {"full_name": "Vector.ne_cons_iff", "code": "theorem ne_cons_iff (a : \u03b1) (v : Vector \u03b1 n.succ) (v' : Vector \u03b1 n) :\n    v \u2260 a ::\u1d65 v' \u2194 v.head \u2260 a \u2228 v.tail \u2260 v'", "start": [69, 1], "end": [70, 94], "kind": "commanddeclaration"}, {"full_name": "Vector.exists_eq_cons", "code": "theorem exists_eq_cons (v : Vector \u03b1 n.succ) : \u2203 (a : \u03b1) (as : Vector \u03b1 n), v = a ::\u1d65 as", "start": [73, 1], "end": [74, 63], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_ofFn", "code": "@[simp]\ntheorem toList_ofFn : \u2200 {n} (f : Fin n \u2192 \u03b1), toList (ofFn f) = List.ofFn f", "start": [77, 1], "end": [80, 71], "kind": "commanddeclaration"}, {"full_name": "Vector.mk_toList", "code": "@[simp]\ntheorem mk_toList : \u2200 (v : Vector \u03b1 n) (h), (\u27e8toList v, h\u27e9 : Vector \u03b1 n) = v", "start": [83, 1], "end": [85, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.length_val", "code": "@[simp] theorem length_val (v : Vector \u03b1 n) : v.val.length = n", "start": [89, 1], "end": [89, 70], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_map", "code": "@[simp]\ntheorem toList_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) : (v.map f).toList = v.toList.map f", "start": [98, 1], "end": [100, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.head_map", "code": "@[simp]\ntheorem head_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) : (v.map f).head = f v.head", "start": [103, 1], "end": [106, 41], "kind": "commanddeclaration"}, {"full_name": "Vector.tail_map", "code": "@[simp]\ntheorem tail_map {\u03b2 : Type*} (v : Vector \u03b1 (n + 1)) (f : \u03b1 \u2192 \u03b2) :\n    (v.map f).tail = v.tail.map f", "start": [109, 1], "end": [113, 41], "kind": "commanddeclaration"}, {"full_name": "Vector.get_eq_get", "code": "theorem get_eq_get (v : Vector \u03b1 n) (i : Fin n) :\n    v.get i = v.toList.get (Fin.cast v.toList_length.symm i)", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.nth_eq_nthLe", "code": "@[deprecated get_eq_get]\ntheorem nth_eq_nthLe :\n    \u2200 (v : Vector \u03b1 n) (i), get v i = v.toList.nthLe i.1 (by rw [toList_length]; exact i.2)", "start": [122, 1], "end": [125, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.get_replicate", "code": "@[simp]\ntheorem get_replicate (a : \u03b1) (i : Fin n) : (Vector.replicate n a).get i = a", "start": [127, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Vector.get_map", "code": "@[simp]\ntheorem get_map {\u03b2 : Type*} (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) (i : Fin n) :\n    (v.map f).get i = f (v.get i)", "start": [132, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_nil", "code": "@[simp]\ntheorem map\u2082_nil (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Vector.map\u2082 f nil nil = nil", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.map\u2082_cons", "code": "@[simp]\ntheorem map\u2082_cons (hd\u2081 : \u03b1) (tl\u2081 : Vector \u03b1 n) (hd\u2082 : \u03b2) (tl\u2082 : Vector \u03b2 n) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    Vector.map\u2082 f (hd\u2081 ::\u1d65 tl\u2081) (hd\u2082 ::\u1d65 tl\u2082) = f hd\u2081 hd\u2082 ::\u1d65 (Vector.map\u2082 f tl\u2081 tl\u2082)", "start": [142, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.get_ofFn", "code": "@[simp]\ntheorem get_ofFn {n} (f : Fin n \u2192 \u03b1) (i) : get (ofFn f) i = f i", "start": [147, 1], "end": [151, 35], "kind": "commanddeclaration"}, {"full_name": "Vector.ofFn_get", "code": "@[simp]\ntheorem ofFn_get (v : Vector \u03b1 n) : ofFn (get v) = v", "start": [154, 1], "end": [159, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.vectorEquivFin", "code": "def _root_.Equiv.vectorEquivFin (\u03b1 : Type*) (n : \u2115) : Vector \u03b1 n \u2243 (Fin n \u2192 \u03b1) :=\n  \u27e8Vector.get, Vector.ofFn, Vector.ofFn_get, fun f => funext <| Vector.get_ofFn f\u27e9", "start": [162, 1], "end": [164, 83], "kind": "commanddeclaration"}, {"full_name": "Vector.get_tail", "code": "theorem get_tail (x : Vector \u03b1 n) (i) :\n    x.tail.get i = x.get \u27e8i.1 + 1, lt_tsub_iff_right.mp i.2\u27e9", "start": [167, 1], "end": [173, 16], "kind": "commanddeclaration"}, {"full_name": "Vector.get_tail_succ", "code": "@[simp]\ntheorem get_tail_succ : \u2200 (v : Vector \u03b1 n.succ) (i : Fin n), get (tail v) i = get v i.succ", "start": [176, 1], "end": [178, 53], "kind": "commanddeclaration"}, {"full_name": "Vector.tail_val", "code": "@[simp]\ntheorem tail_val : \u2200 v : Vector \u03b1 n.succ, v.tail.val = v.val.tail", "start": [181, 1], "end": [183, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.tail_nil", "code": "@[simp]\ntheorem tail_nil : (@nil \u03b1).tail = nil", "start": [186, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.singleton_tail", "code": "@[simp]\ntheorem singleton_tail : \u2200 (v : Vector \u03b1 1), v.tail = Vector.nil", "start": [192, 1], "end": [195, 20], "kind": "commanddeclaration"}, {"full_name": "Vector.tail_ofFn", "code": "@[simp]\ntheorem tail_ofFn {n : \u2115} (f : Fin n.succ \u2192 \u03b1) : tail (ofFn f) = ofFn fun i => f i.succ", "start": [198, 1], "end": [204, 8], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_empty", "code": "@[simp]\ntheorem toList_empty (v : Vector \u03b1 0) : v.toList = []", "start": [207, 1], "end": [209, 29], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_singleton", "code": "@[simp]\ntheorem toList_singleton (v : Vector \u03b1 1) : v.toList = [v.head]", "start": [212, 1], "end": [217, 97], "kind": "commanddeclaration"}, {"full_name": "Vector.empty_toList_eq_ff", "code": "@[simp]\ntheorem empty_toList_eq_ff (v : Vector \u03b1 (n + 1)) : v.toList.isEmpty = false", "start": [220, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.not_empty_toList", "code": "theorem not_empty_toList (v : Vector \u03b1 (n + 1)) : \u00acv.toList.isEmpty", "start": [226, 1], "end": [227, 69], "kind": "commanddeclaration"}, {"full_name": "Vector.map_id", "code": "@[simp]\ntheorem map_id {n : \u2115} (v : Vector \u03b1 n) : Vector.map id v = v", "start": [230, 1], "end": [233, 64], "kind": "commanddeclaration"}, {"full_name": "Vector.nodup_iff_injective_get", "code": "theorem nodup_iff_injective_get {v : Vector \u03b1 n} : v.toList.Nodup \u2194 Function.Injective v.get", "start": [236, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "Vector.head?_toList", "code": "theorem head?_toList : \u2200 v : Vector \u03b1 n.succ, (toList v).head? = some (head v)", "start": [242, 1], "end": [243, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.reverse", "code": "def reverse (v : Vector \u03b1 n) : Vector \u03b1 n :=\n  \u27e8v.toList.reverse, by simp\u27e9", "start": [246, 1], "end": [248, 30], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_reverse", "code": "theorem toList_reverse {v : Vector \u03b1 n} : v.reverse.toList = v.toList.reverse", "start": [251, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.reverse_reverse", "code": "@[simp]\ntheorem reverse_reverse {v : Vector \u03b1 n} : v.reverse.reverse = v", "start": [257, 1], "end": [260, 24], "kind": "commanddeclaration"}, {"full_name": "Vector.get_zero", "code": "@[simp]\ntheorem get_zero : \u2200 v : Vector \u03b1 n.succ, get v 0 = head v", "start": [263, 1], "end": [265, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.head_ofFn", "code": "@[simp]\ntheorem head_ofFn {n : \u2115} (f : Fin n.succ \u2192 \u03b1) : head (ofFn f) = f 0", "start": [268, 1], "end": [270, 28], "kind": "commanddeclaration"}, {"full_name": "Vector.get_cons_zero", "code": "theorem get_cons_zero (a : \u03b1) (v : Vector \u03b1 n) : get (a ::\u1d65 v) 0 = a", "start": [274, 1], "end": [274, 91], "kind": "commanddeclaration"}, {"full_name": "Vector.get_cons_nil", "code": "@[simp]\ntheorem get_cons_nil : \u2200 {ix : Fin 1} (x : \u03b1), get (x ::\u1d65 nil) ix = x", "start": [277, 1], "end": [281, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.get_cons_succ", "code": "@[simp]\ntheorem get_cons_succ (a : \u03b1) (v : Vector \u03b1 n) (i : Fin n) : get (a ::\u1d65 v) i.succ = get v i", "start": [284, 1], "end": [286, 34], "kind": "commanddeclaration"}, {"full_name": "Vector.last", "code": "def last (v : Vector \u03b1 (n + 1)) : \u03b1 :=\n  v.get (Fin.last n)", "start": [289, 1], "end": [291, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.last_def", "code": "theorem last_def {v : Vector \u03b1 (n + 1)} : v.last = v.get (Fin.last n)", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.reverse_get_zero", "code": "theorem reverse_get_zero {v : Vector \u03b1 (n + 1)} : v.reverse.head = v.last", "start": [299, 1], "end": [307, 9], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl", "code": "def scanl : Vector \u03b2 (n + 1) :=\n  \u27e8List.scanl f b v.toList, by rw [List.length_scanl, toList_length]\u27e9", "start": [318, 1], "end": [322, 70], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_nil", "code": "@[simp]\ntheorem scanl_nil : scanl f b nil = b ::\u1d65 nil", "start": [325, 1], "end": [328, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_cons", "code": "@[simp]\ntheorem scanl_cons (x : \u03b1) : scanl f b (x ::\u1d65 v) = b ::\u1d65 scanl f (f b x) v", "start": [331, 1], "end": [340, 24], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_val", "code": "@[simp]\ntheorem scanl_val : \u2200 {v : Vector \u03b1 n}, (scanl f b v).val = List.scanl f b v.val", "start": [343, 1], "end": [348, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_scanl", "code": "@[simp]\ntheorem toList_scanl : (scanl f b v).toList = List.scanl f b v.toList", "start": [351, 1], "end": [356, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_singleton", "code": "@[simp]\ntheorem scanl_singleton (v : Vector \u03b1 1) : scanl f b v = b ::\u1d65 f b v.head ::\u1d65 nil", "start": [359, 1], "end": [366, 63], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_head", "code": "@[simp]\ntheorem scanl_head : (scanl f b v).head = b", "start": [369, 1], "end": [379, 16], "kind": "commanddeclaration"}, {"full_name": "Vector.scanl_get", "code": "@[simp]\ntheorem scanl_get (i : Fin n) :\n    (scanl f b v).get i.succ = f ((scanl f b v).get (Fin.castSucc i)) (v.get i)", "start": [382, 1], "end": [401, 59], "kind": "commanddeclaration"}, {"full_name": "Vector.mOfFn", "code": "def mOfFn {m} [Monad m] {\u03b1 : Type u} : \u2200 {n}, (Fin n \u2192 m \u03b1) \u2192 m (Vector \u03b1 n)\n  | 0, _ => pure nil\n  | _ + 1, f => do\n    let a \u2190 f 0\n    let v \u2190 mOfFn fun i => f i.succ\n    pure (a ::\u1d65 v)", "start": [406, 1], "end": [413, 19], "kind": "commanddeclaration"}, {"full_name": "Vector.mOfFn_pure", "code": "theorem mOfFn_pure {m} [Monad m] [LawfulMonad m] {\u03b1} :\n    \u2200 {n} (f : Fin n \u2192 \u03b1), (@mOfFn m _ _ _ fun i => pure (f i)) = pure (ofFn f)", "start": [416, 1], "end": [421, 9], "kind": "commanddeclaration"}, {"full_name": "Vector.mmap", "code": "def mmap {m} [Monad m] {\u03b1} {\u03b2 : Type u} (f : \u03b1 \u2192 m \u03b2) : \u2200 {n}, Vector \u03b1 n \u2192 m (Vector \u03b2 n)\n  | 0, _ => pure nil\n  | _ + 1, xs => do\n    let h' \u2190 f xs.head\n    let t' \u2190 mmap f xs.tail\n    pure (h' ::\u1d65 t')", "start": [424, 1], "end": [431, 21], "kind": "commanddeclaration"}, {"full_name": "Vector.mmap_nil", "code": "@[simp]\ntheorem mmap_nil {m} [Monad m] {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : mmap f nil = pure nil", "start": [434, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.mmap_cons", "code": "@[simp]\ntheorem mmap_cons {m} [Monad m] {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) (a) :\n    \u2200 {n} (v : Vector \u03b1 n),\n      mmap f (a ::\u1d65 v) = do\n        let h' \u2190 f a\n        let t' \u2190 mmap f v\n        pure (h' ::\u1d65 t')", "start": [439, 1], "end": [446, 23], "kind": "commanddeclaration"}, {"full_name": "Vector.inductionOn", "code": "@[elab_as_elim]\ndef inductionOn {C : \u2200 {n : \u2115}, Vector \u03b1 n \u2192 Sort*} {n : \u2115} (v : Vector \u03b1 n)\n    (h_nil : C nil) (h_cons : \u2200 {n : \u2115} {x : \u03b1} {w : Vector \u03b1 n}, C w \u2192 C (x ::\u1d65 w)) : C v := by\n  induction' n with n ih\n  \u00b7 rcases v with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    exact h_nil\n  \u00b7 rcases v with \u27e8_ | \u27e8a, v\u27e9, v_property\u27e9\n    cases v_property\n    apply @h_cons n _ \u27e8v, (add_left_inj 1).mp v_property\u27e9\n    apply ih", "start": [449, 1], "end": [465, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.inductionOn\u2082", "code": "@[elab_as_elim]\ndef inductionOn\u2082 {C : \u2200 {n}, Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Sort*}\n    (v : Vector \u03b1 n) (w : Vector \u03b2 n)\n    (nil : C nil nil) (cons : \u2200 {n a b} {x : Vector \u03b1 n} {y}, C x y \u2192 C (a ::\u1d65 x) (b ::\u1d65 y)) :\n    C v w := by\n  induction' n with n ih\n  \u00b7 rcases v with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    rcases w with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    exact nil\n  \u00b7 rcases v with \u27e8_ | \u27e8a, v\u27e9, v_property\u27e9\n    cases v_property\n    rcases w with \u27e8_ | \u27e8b, w\u27e9, w_property\u27e9\n    cases w_property\n    apply @cons n _ _ \u27e8v, (add_left_inj 1).mp v_property\u27e9 \u27e8w, (add_left_inj 1).mp w_property\u27e9\n    apply ih", "start": [473, 1], "end": [489, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.inductionOn\u2083", "code": "@[elab_as_elim]\ndef inductionOn\u2083 {C : \u2200 {n}, Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n \u2192 Sort*}\n    (u : Vector \u03b1 n) (v : Vector \u03b2 n) (w : Vector \u03b3 n) (nil : C nil nil nil)\n    (cons : \u2200 {n a b c} {x : Vector \u03b1 n} {y z}, C x y z \u2192 C (a ::\u1d65 x) (b ::\u1d65 y) (c ::\u1d65 z)) :\n    C u v w := by\n  induction' n with n ih\n  \u00b7 rcases u with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    rcases v with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    rcases w with \u27e8_ | \u27e8-, -\u27e9, - | -\u27e9\n    exact nil\n  \u00b7 rcases u with \u27e8_ | \u27e8a, u\u27e9, u_property\u27e9\n    cases u_property\n    rcases v with \u27e8_ | \u27e8b, v\u27e9, v_property\u27e9\n    cases v_property\n    rcases w with \u27e8_ | \u27e8c, w\u27e9, w_property\u27e9\n    cases w_property\n    apply\n      @cons n _ _ _ \u27e8u, (add_left_inj 1).mp u_property\u27e9 \u27e8v, (add_left_inj 1).mp v_property\u27e9\n        \u27e8w, (add_left_inj 1).mp w_property\u27e9\n    apply ih", "start": [492, 1], "end": [514, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.casesOn", "code": "def casesOn {motive : \u2200 {n}, Vector \u03b1 n \u2192 Sort*} (v : Vector \u03b1 m)\n    (nil : motive nil)\n    (cons : \u2200 {n}, (hd : \u03b1) \u2192 (tl : Vector \u03b1 n) \u2192 motive (Vector.cons hd tl)) :\n    motive v :=\n  inductionOn (C := motive) v nil @fun _ hd tl _ => cons hd tl", "start": [517, 1], "end": [522, 63], "kind": "commanddeclaration"}, {"full_name": "Vector.casesOn\u2082", "code": "def casesOn\u2082  {motive : \u2200{n}, Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Sort*} (v\u2081 : Vector \u03b1 m) (v\u2082 : Vector \u03b2 m)\n    (nil : motive nil nil)\n    (cons : \u2200{n}, (x : \u03b1) \u2192 (y : \u03b2) \u2192 (xs : Vector \u03b1 n) \u2192 (ys : Vector \u03b2 n)\n      \u2192 motive (x ::\u1d65 xs) (y ::\u1d65 ys)) :\n    motive v\u2081 v\u2082 :=\n  inductionOn\u2082 (C := motive) v\u2081 v\u2082 nil @fun _ x y xs ys _ => cons x y xs ys", "start": [524, 1], "end": [530, 76], "kind": "commanddeclaration"}, {"full_name": "Vector.casesOn\u2083", "code": "def casesOn\u2083  {motive : \u2200{n}, Vector \u03b1 n \u2192 Vector \u03b2 n \u2192 Vector \u03b3 n \u2192 Sort*} (v\u2081 : Vector \u03b1 m)\n    (v\u2082 : Vector \u03b2 m) (v\u2083 : Vector \u03b3 m) (nil : motive nil nil nil)\n    (cons : \u2200{n}, (x : \u03b1) \u2192 (y : \u03b2) \u2192 (z : \u03b3) \u2192 (xs : Vector \u03b1 n) \u2192 (ys : Vector \u03b2 n)\n      \u2192 (zs : Vector \u03b3 n) \u2192 motive (x ::\u1d65 xs) (y ::\u1d65 ys) (z ::\u1d65 zs)) :\n    motive v\u2081 v\u2082 v\u2083 :=\n  inductionOn\u2083 (C := motive) v\u2081 v\u2082 v\u2083 nil @fun _ x y z xs ys zs _ => cons x y z xs ys zs", "start": [532, 1], "end": [539, 89], "kind": "commanddeclaration"}, {"full_name": "Vector.toArray", "code": "def toArray : Vector \u03b1 n \u2192 Array \u03b1\n  | \u27e8xs, _\u27e9 => cast (by rfl) xs.toArray", "start": [541, 1], "end": [543, 40], "kind": "commanddeclaration"}, {"full_name": "Vector.insertNth", "code": "def insertNth (a : \u03b1) (i : Fin (n + 1)) (v : Vector \u03b1 n) : Vector \u03b1 (n + 1) :=\n  \u27e8v.1.insertNth i a, by\n    rw [List.length_insertNth, v.2]\n    rw [v.2, \u2190 Nat.succ_le_succ_iff]\n    exact i.2\u27e9", "start": [550, 1], "end": [556, 15], "kind": "commanddeclaration"}, {"full_name": "Vector.insertNth_val", "code": "theorem insertNth_val {i : Fin (n + 1)} {v : Vector \u03b1 n} :\n    (v.insertNth a i).val = v.val.insertNth i.1 a", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.removeNth_val", "code": "@[simp]\ntheorem removeNth_val {i : Fin n} : \u2200 {v : Vector \u03b1 n}, (removeNth i v).val = v.val.removeNth i", "start": [564, 1], "end": [566, 13], "kind": "commanddeclaration"}, {"full_name": "Vector.removeNth_insertNth", "code": "theorem removeNth_insertNth {v : Vector \u03b1 n} {i : Fin (n + 1)} :\n    removeNth i (insertNth a i v) = v", "start": [569, 1], "end": [571, 49], "kind": "commanddeclaration"}, {"full_name": "Vector.removeNth_insertNth'", "code": "theorem removeNth_insertNth' {v : Vector \u03b1 (n + 1)} :\n    \u2200 {i : Fin (n + 1)} {j : Fin (n + 2)},\n      removeNth (j.succAbove i) (insertNth a j v) = insertNth a (i.predAbove j) (removeNth i v)", "start": [574, 1], "end": [592, 33], "kind": "commanddeclaration"}, {"full_name": "Vector.insertNth_comm", "code": "theorem insertNth_comm (a b : \u03b1) (i j : Fin (n + 1)) (h : i \u2264 j) :\n    \u2200 v : Vector \u03b1 n,\n      (v.insertNth a i).insertNth b j.succ = (v.insertNth b j).insertNth a (Fin.castSucc i)", "start": [595, 1], "end": [604, 39], "kind": "commanddeclaration"}, {"full_name": "Vector.set", "code": "def set (v : Vector \u03b1 n) (i : Fin n) (a : \u03b1) : Vector \u03b1 n :=\n  \u27e8v.1.set i.1 a, by simp\u27e9", "start": [612, 1], "end": [614, 27], "kind": "commanddeclaration"}, {"full_name": "Vector.toList_set", "code": "@[simp]\ntheorem toList_set (v : Vector \u03b1 n) (i : Fin n) (a : \u03b1) :\n    (v.set i a).toList = v.toList.set i a", "start": [617, 1], "end": [620, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.get_set_same", "code": "@[simp]\ntheorem get_set_same (v : Vector \u03b1 n) (i : Fin n) (a : \u03b1) : (v.set i a).get i = a", "start": [623, 1], "end": [625, 50], "kind": "commanddeclaration"}, {"full_name": "Vector.get_set_of_ne", "code": "theorem get_set_of_ne {v : Vector \u03b1 n} {i j : Fin n} (h : i \u2260 j) (a : \u03b1) :\n    (v.set i a).get j = v.get j", "start": [628, 1], "end": [633, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.get_set_eq_if", "code": "theorem get_set_eq_if {v : Vector \u03b1 n} {i j : Fin n} (a : \u03b1) :\n    (v.set i a).get j = if i = j then a else v.get j", "start": [636, 1], "end": [638, 52], "kind": "commanddeclaration"}, {"full_name": "Vector.prod_set", "code": "@[to_additive]\ntheorem prod_set [Monoid \u03b1] (v : Vector \u03b1 n) (i : Fin n) (a : \u03b1) :\n    (v.set i a).toList.prod = (v.take i).toList.prod * a * (v.drop (i + 1)).toList.prod", "start": [641, 1], "end": [645, 11], "kind": "commanddeclaration"}, {"full_name": "Vector.prod_set'", "code": "@[to_additive]\ntheorem prod_set' [CommGroup \u03b1] (v : Vector \u03b1 n) (i : Fin n) (a : \u03b1) :\n    (v.set i a).toList.prod = v.toList.prod * (v.get i)\u207b\u00b9 * a", "start": [648, 1], "end": [652, 36], "kind": "commanddeclaration"}, {"full_name": "Vector.traverseAux", "code": "private def traverseAux {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 F \u03b2) : \u2200 x : List \u03b1, F (Vector \u03b2 x.length)\n  | [] => pure Vector.nil\n  | x :: xs => Vector.cons <$> f x <*> traverseAux f xs", "start": [673, 1], "end": [675, 56], "kind": "commanddeclaration"}, {"full_name": "Vector.traverse", "code": "protected def traverse {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 F \u03b2) : Vector \u03b1 n \u2192 F (Vector \u03b2 n)\n  | \u27e8v, Hv\u27e9 => cast (by rw [Hv]) <| traverseAux f v", "start": [677, 1], "end": [679, 52], "kind": "commanddeclaration"}, {"full_name": "Vector.traverse_def", "code": "@[simp]\nprotected theorem traverse_def (f : \u03b1 \u2192 F \u03b2) (x : \u03b1) :\n    \u2200 xs : Vector \u03b1 n, (x ::\u1d65 xs).traverse f = cons <$> f x <*> xs.traverse f", "start": [686, 1], "end": [689, 24], "kind": "commanddeclaration"}, {"full_name": "Vector.id_traverse", "code": "protected theorem id_traverse : \u2200 x : Vector \u03b1 n, x.traverse (pure : _ \u2192 Id _) = x", "start": [692, 1], "end": [695, 18], "kind": "commanddeclaration"}, {"full_name": "Vector.comp_traverse", "code": "@[nolint unusedArguments]\nprotected theorem comp_traverse (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : Vector \u03b1 n) :\n    Vector.traverse (Comp.mk \u2218 Functor.map f \u2218 g) x =\n      Comp.mk (Vector.traverse f <$> Vector.traverse g x)", "start": [708, 1], "end": [716, 33], "kind": "commanddeclaration"}, {"full_name": "Vector.traverse_eq_map_id", "code": "protected theorem traverse_eq_map_id {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) :\n    \u2200 x : Vector \u03b1 n, x.traverse ((pure: _ \u2192 Id _) \u2218 f) = (pure: _ \u2192 Id _) (map f x)", "start": [719, 1], "end": [721, 74], "kind": "commanddeclaration"}, {"full_name": "Vector.naturality", "code": "protected theorem naturality {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 F \u03b2) (x : Vector \u03b1 n) :\n    \u03b7 (x.traverse f) = x.traverse (@\u03b7 _ \u2218 f)", "start": [726, 1], "end": [731, 8], "kind": "commanddeclaration"}, {"full_name": "Vector.replicate_succ", "code": "@[simp]\ntheorem replicate_succ (val : \u03b1) :\n    replicate (n+1) val = val ::\u1d65 (replicate n val)", "start": [773, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.get_append_cons_zero", "code": "@[simp]\ntheorem get_append_cons_zero : get (append (x ::\u1d65 xs) ys) \u27e80, by simp\u27e9 = x", "start": [781, 1], "end": [783, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.get_append_cons_succ", "code": "@[simp]\ntheorem get_append_cons_succ {i : Fin (n + m)} {h} :\n    get (append (x ::\u1d65 xs) ys) \u27e8i+1, h\u27e9 = get (append xs ys) i", "start": [785, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.append_nil", "code": "@[simp]\ntheorem append_nil : append xs nil = xs", "start": [790, 1], "end": [792, 26], "kind": "commanddeclaration"}, {"full_name": "Vector.get_map\u2082", "code": "@[simp]\ntheorem get_map\u2082 (v\u2081 : Vector \u03b1 n) (v\u2082 : Vector \u03b2 n) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (i : Fin n) :\n    get (map\u2082 f v\u2081 v\u2082) i = f (get v\u2081 i) (get v\u2082 i)", "start": [798, 1], "end": [809, 36], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr_cons", "code": "@[simp]\ntheorem mapAccumr_cons :\n    mapAccumr f (x ::\u1d65 xs) s\n    = let r := mapAccumr f xs s\n      let q := f x r.1\n      (q.1, q.2 ::\u1d65 r.2)", "start": [811, 1], "end": [817, 6], "kind": "commanddeclaration"}, {"full_name": "Vector.mapAccumr\u2082_cons", "code": "@[simp]\ntheorem mapAccumr\u2082_cons :\n    mapAccumr\u2082 f (x ::\u1d65 xs) (y ::\u1d65 ys) s\n    = let r := mapAccumr\u2082 f xs ys s\n      let q := f x y r.1\n      (q.1, q.2 ::\u1d65 r.2)", "start": [819, 1], "end": [825, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ApplyFun.lean", "imports": ["Mathlib/Order/Monotone/Basic.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.applyFunHyp", "code": "def applyFunHyp (f : Term) (using? : Option Term) (h : FVarId) (g : MVarId) :\n    TacticM (List MVarId) := do\n  let using? \u2190 using?.mapM (elabTerm \u00b7 none)\n  let d \u2190 h.getDecl\n  let (prf, newGoals) \u2190 match (\u2190 whnfR (\u2190 instantiateMVars d.type)).getAppFnArgs with\n    | (``Eq, #[_, lhs, rhs]) => do\n      let (eq', gs) \u2190 withCollectingNewGoalsFrom (tagSuffix := `apply_fun) <|\n        withoutRecover <| runTermElab <| do\n          let f \u2190 Term.elabTerm f none\n          let lhs' \u2190 Term.elabAppArgs f #[] #[.expr lhs] none false false\n          let rhs' \u2190 Term.elabAppArgs f #[] #[.expr rhs] none false false\n          unless \u2190 isDefEq (\u2190 inferType lhs') (\u2190 inferType rhs') do\n            let msg \u2190 mkHasTypeButIsExpectedMsg (\u2190 inferType rhs') (\u2190 inferType lhs')\n            throwError \"In generated equality, right-hand side {msg}\"\n          let eq \u2190 mkEq lhs'.headBeta rhs'.headBeta\n          Term.synthesizeSyntheticMVarsUsingDefault\n          instantiateMVars eq\n      let mvar \u2190 mkFreshExprMVar eq'\n      let [] \u2190 mvar.mvarId!.congrN! | throwError \"`apply_fun` could not construct congruence\"\n      pure (mvar, gs)\n    | (``Not, #[P]) =>\n      match (\u2190 whnfR P).getAppFnArgs with\n      | (``Eq, _) =>\n        let (injective_f, newGoals) \u2190 match using? with\n          | some r => pure (r, [])\n          | none => do\n            let f \u2190 elabTermForApply f\n            let ng \u2190 mkFreshExprMVar (\u2190 mkAppM ``Function.Injective #[f])\n            pure (ng, [ng.mvarId!])\n        pure (\u2190 mkAppM' (\u2190 mkAppM ``Function.Injective.ne #[injective_f]) #[d.toExpr], newGoals)\n      | _ => throwError\n        \"apply_fun can only handle negations of equality.\"\n    | (``LT.lt, _) =>\n      let (strict_monotone_f, newGoals) \u2190 match using? with\n        | some r => pure (r, [])\n        | none => do\n          let f \u2190 elabTermForApply f\n          let ng \u2190 mkFreshExprMVar (\u2190 mkAppM ``StrictMono #[f])\n          pure (ng, [ng.mvarId!])\n      pure (\u2190 mkAppM' strict_monotone_f #[d.toExpr], newGoals)\n    | (``LE.le, _) =>\n      let (monotone_f, newGoals) \u2190 match using? with\n        | some r => pure (r, [])\n        | none => do\n          let f \u2190 elabTermForApply f\n          let ng \u2190 mkFreshExprMVar (\u2190 mkAppM ``Monotone #[f])\n          pure (ng, [ng.mvarId!])\n      pure (\u2190 mkAppM' monotone_f #[d.toExpr], newGoals)\n    | _ => throwError\n      \"apply_fun can only handle hypotheses of the form `a = b`, `a \u2260 b`, `a \u2264 b`, `a < b`.\"\n\n  let g \u2190 g.clear h\n  let (_, g) \u2190 g.note d.userName prf\n  return g :: newGoals", "start": [24, 1], "end": [90, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.applyFunTargetFailure", "code": "def applyFunTargetFailure (f : Term) : MetaM (List MVarId) := do\n  throwError \"`apply_fun` could not apply `{f}` to the main goal.\"", "start": [92, 1], "end": [94, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.maybeProveInjective", "code": "def maybeProveInjective (ginj : Expr) (using? : Option Expr) : MetaM Bool := do\n  if let some u := using? then\n    if \u2190 isDefEq ginj u then\n      ginj.mvarId!.assign u\n      return true\n    else\n      let err \u2190 mkHasTypeButIsExpectedMsg (\u2190 inferType u) (\u2190 inferType ginj)\n      throwError \"Using clause {err}\"\n  try ginj.mvarId!.assumption; return true catch _ => pure ()\n  let ok \u2190 observing? do\n    let [] \u2190 ginj.mvarId!.apply (\u2190 mkConstWithFreshMVarLevels ``Equiv.injective) | failure\n  if ok.isSome then return true\n  return false", "start": [96, 1], "end": [116, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ApplyFun.le_of_le", "code": "alias \u27e8ApplyFun.le_of_le, _\u27e9 := OrderIso.le_iff_le", "start": [120, 1], "end": [120, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Mathlib.Tactic.ApplyFun.lt_of_lt", "code": "alias \u27e8ApplyFun.lt_of_lt, _\u27e9 := OrderIso.lt_iff_lt", "start": [121, 1], "end": [121, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Mathlib.Tactic.applyFunTarget", "code": "def applyFunTarget (f : Term) (using? : Option Term) (g : MVarId) : TacticM (List MVarId) := do\n  let handle (thm : Name) : TacticM (List MVarId) := do\n    let ng \u2190 mkFreshExprMVar none\n    let (pf, gs) \u2190 withCollectingNewGoalsFrom (tagSuffix := `apply_fun) <|\n      withoutRecover <| runTermElab do\n        let pf \u2190 Term.elabTermEnsuringType (\u2190 `($(mkIdent thm) $f $(\u2190 Term.exprToSyntax ng)))\n                    (\u2190 g.getType)\n        Term.synthesizeSyntheticMVarsUsingDefault\n        return pf\n    g.assign pf\n    return ng.mvarId! :: gs\n  let gty \u2190 whnfR (\u2190 instantiateMVars (\u2190 g.getType))\n  match gty.getAppFnArgs with\n  | (``Not, #[p]) => match p.getAppFnArgs with\n    | (``Eq, #[_, _, _]) => handle ``ne_of_apply_ne\n    | _ => applyFunTargetFailure f\n  | (``LE.le, _)\n  | (``GE.ge, _) => handle ``ApplyFun.le_of_le\n  | (``LT.lt, _)\n  | (``GT.gt, _) => handle ``ApplyFun.lt_of_lt\n  | (``Eq, #[_, _, _]) => do\n    let g' \u2190 mkFreshExprSyntheticOpaqueMVar (\u2190 mkFreshTypeMVar) (\u2190 g.getTag)\n    let ginj \u2190 mkFreshExprSyntheticOpaqueMVar (\u2190 mkFreshTypeMVar) (appendTag (\u2190 g.getTag) `inj)\n    let gDefer \u2190 mkFreshExprMVar (\u2190 g.getType)\n    let (_, gs) \u2190 withCollectingNewGoalsFrom (tagSuffix := `apply_fun) <|\n      withoutRecover <| runTermElab do\n        let inj \u2190 Term.elabTerm (\u2190 ``(Function.Injective $f)) none\n        _ \u2190 isDefEq (\u2190 inferType ginj) inj\n        let pf \u2190 Term.elabAppArgs ginj #[] #[.expr g'] (\u2190 g.getType) false false\n        let pf \u2190 Term.ensureHasType (\u2190 g.getType) pf\n        let using? \u2190 using?.mapM (Term.elabTerm \u00b7 (some inj))\n        _ \u2190 withAssignableSyntheticOpaque <| maybeProveInjective ginj using?\n        Term.synthesizeSyntheticMVarsUsingDefault\n        gDefer.mvarId!.assign pf\n        return inj\n    g.assign gDefer\n    return [g'.mvarId!, ginj.mvarId!] ++ gs\n  | _ => applyFunTargetFailure f", "start": [123, 1], "end": [169, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Setoid/Basic.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Order/GaloisConnection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Setoid.Rel", "code": "def Setoid.Rel (r : Setoid \u03b1) : \u03b1 \u2192 \u03b1 \u2192 Prop :=\n  @Setoid.r _ r", "start": [39, 1], "end": [41, 16], "kind": "commanddeclaration"}, {"full_name": "Setoid.decidableRel", "code": "instance Setoid.decidableRel (r : Setoid \u03b1) [h : DecidableRel r.r] : DecidableRel r.Rel :=\n  h", "start": [44, 1], "end": [45, 4], "kind": "commanddeclaration"}, {"full_name": "Quotient.eq_rel", "code": "theorem Quotient.eq_rel {r : Setoid \u03b1} {x y} :\n    (Quotient.mk' x : Quotient r) = Quotient.mk' y \u2194 r.Rel x y", "start": [48, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "Setoid.ext'", "code": "@[ext]\ntheorem ext' {r s : Setoid \u03b1} (H : \u2200 a b, r.Rel a b \u2194 s.Rel a b) : r = s", "start": [56, 1], "end": [58, 8], "kind": "commanddeclaration"}, {"full_name": "Setoid.ext_iff", "code": "theorem ext_iff {r s : Setoid \u03b1} : r = s \u2194 \u2200 a b, r.Rel a b \u2194 s.Rel a b", "start": [61, 1], "end": [62, 35], "kind": "commanddeclaration"}, {"full_name": "Setoid.eq_iff_rel_eq", "code": "theorem eq_iff_rel_eq {r\u2081 r\u2082 : Setoid \u03b1} : r\u2081 = r\u2082 \u2194 r\u2081.Rel = r\u2082.Rel", "start": [65, 1], "end": [67, 66], "kind": "commanddeclaration"}, {"full_name": "Setoid.le_def", "code": "theorem le_def {r s : Setoid \u03b1} : r \u2264 s \u2194 \u2200 {x y}, r.Rel x y \u2192 s.Rel x y", "start": [74, 1], "end": [75, 10], "kind": "commanddeclaration"}, {"full_name": "Setoid.refl'", "code": "@[refl]\ntheorem refl' (r : Setoid \u03b1) (x) : r.Rel x x", "start": [78, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "Setoid.symm'", "code": "@[symm]\ntheorem symm' (r : Setoid \u03b1) : \u2200 {x y}, r.Rel x y \u2192 r.Rel y x", "start": [82, 1], "end": [83, 78], "kind": "commanddeclaration"}, {"full_name": "Setoid.trans'", "code": "@[trans]\ntheorem trans' (r : Setoid \u03b1) : \u2200 {x y z}, r.Rel x y \u2192 r.Rel y z \u2192 r.Rel x z", "start": [86, 1], "end": [87, 94], "kind": "commanddeclaration"}, {"full_name": "Setoid.comm'", "code": "theorem comm' (s : Setoid \u03b1) {x y} : s.Rel x y \u2194 s.Rel y x", "start": [90, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker", "code": "def ker (f : \u03b1 \u2192 \u03b2) : Setoid \u03b1 :=\n  \u27e8(\u00b7 = \u00b7) on f, eq_equivalence.comap f\u27e9", "start": [94, 1], "end": [96, 41], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_mk_eq", "code": "@[simp]\ntheorem ker_mk_eq (r : Setoid \u03b1) : ker (@Quotient.mk'' _ r) = r", "start": [99, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_apply_mk_out", "code": "theorem ker_apply_mk_out {f : \u03b1 \u2192 \u03b2} (a : \u03b1) : f (haveI := Setoid.ker f; \u27e6a\u27e7.out) = f a", "start": [105, 1], "end": [106, 38], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_apply_mk_out'", "code": "theorem ker_apply_mk_out' {f : \u03b1 \u2192 \u03b2} (a : \u03b1) :\n    f (Quotient.mk _ a : Quotient <| Setoid.ker f).out' = f a", "start": [109, 1], "end": [111, 39], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_def", "code": "theorem ker_def {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} : (ker f).Rel x y \u2194 f x = f y", "start": [114, 1], "end": [115, 10], "kind": "commanddeclaration"}, {"full_name": "Setoid.prod", "code": "protected def prod (r : Setoid \u03b1) (s : Setoid \u03b2) :\n    Setoid (\u03b1 \u00d7 \u03b2) where\n  r x y := r.Rel x.1 y.1 \u2227 s.Rel x.2 y.2\n  iseqv :=\n    \u27e8fun x => \u27e8r.refl' x.1, s.refl' x.2\u27e9, fun h => \u27e8r.symm' h.1, s.symm' h.2\u27e9,\n      fun h\u2081 h\u2082 => \u27e8r.trans' h\u2081.1 h\u2082.1, s.trans' h\u2081.2 h\u2082.2\u27e9\u27e9", "start": [118, 1], "end": [126, 61], "kind": "commanddeclaration"}, {"full_name": "Setoid.inf_def", "code": "theorem inf_def {r s : Setoid \u03b1} : (r \u2293 s).Rel = r.Rel \u2293 s.Rel", "start": [136, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.inf_iff_and", "code": "theorem inf_iff_and {r s : Setoid \u03b1} {x y} : (r \u2293 s).Rel x y \u2194 r.Rel x y \u2227 s.Rel x y", "start": [142, 1], "end": [143, 10], "kind": "commanddeclaration"}, {"full_name": "Setoid.sInf_def", "code": "theorem sInf_def {s : Set (Setoid \u03b1)} : (sInf s).Rel = sInf (Rel '' s)", "start": [153, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.completeLattice", "code": "instance completeLattice : CompleteLattice (Setoid \u03b1) :=\n  { (completeLatticeOfInf (Setoid \u03b1)) fun _ =>\n      \u27e8fun _ hr _ _ h => h _ hr, fun _ hr _ _ h _ hr' => hr hr' h\u27e9 with\n    inf := Inf.inf\n    inf_le_left := fun _ _ _ _ h => h.1\n    inf_le_right := fun _ _ _ _ h => h.2\n    le_inf := fun _ _ _ h1 h2 _ _ h => \u27e8h1 h, h2 h\u27e9\n    top := \u27e8fun _ _ => True, \u27e8fun _ => trivial, fun h => h, fun h1 _ => h1\u27e9\u27e9\n    le_top := fun _ _ _ _ => trivial\n    bot := \u27e8(\u00b7 = \u00b7), \u27e8fun _ => rfl, fun h => h.symm, fun h1 h2 => h1.trans h2\u27e9\u27e9\n    bot_le := fun r x _ h => h \u25b8 r.2.1 x }", "start": [169, 1], "end": [181, 43], "kind": "commanddeclaration"}, {"full_name": "Setoid.top_def", "code": "@[simp]\ntheorem top_def : (\u22a4 : Setoid \u03b1).Rel = \u22a4", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.bot_def", "code": "@[simp]\ntheorem bot_def : (\u22a5 : Setoid \u03b1).Rel = (\u00b7 = \u00b7)", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.eq_top_iff", "code": "theorem eq_top_iff {s : Setoid \u03b1} : s = (\u22a4 : Setoid \u03b1) \u2194 \u2200 x y : \u03b1, s.Rel x y", "start": [194, 1], "end": [196, 63], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqvGen_eq", "code": "theorem eqvGen_eq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    EqvGen.Setoid r = sInf { s : Setoid \u03b1 | \u2200 \u2983x y\u2984, r x y \u2192 s.Rel x y }", "start": [199, 1], "end": [207, 44], "kind": "commanddeclaration"}, {"full_name": "Setoid.sup_eq_eqvGen", "code": "theorem sup_eq_eqvGen (r s : Setoid \u03b1) :\n    r \u2294 s = EqvGen.Setoid fun x y => r.Rel x y \u2228 s.Rel x y", "start": [210, 1], "end": [216, 43], "kind": "commanddeclaration"}, {"full_name": "Setoid.sup_def", "code": "theorem sup_def {r s : Setoid \u03b1} : r \u2294 s = EqvGen.Setoid (r.Rel \u2294 s.Rel)", "start": [219, 1], "end": [222, 26], "kind": "commanddeclaration"}, {"full_name": "Setoid.sSup_eq_eqvGen", "code": "theorem sSup_eq_eqvGen (S : Set (Setoid \u03b1)) :\n    sSup S = EqvGen.Setoid fun x y => \u2203 r : Setoid \u03b1, r \u2208 S \u2227 r.Rel x y", "start": [225, 1], "end": [233, 59], "kind": "commanddeclaration"}, {"full_name": "Setoid.sSup_def", "code": "theorem sSup_def {s : Set (Setoid \u03b1)} : sSup s = EqvGen.Setoid (sSup (Rel '' s))", "start": [236, 1], "end": [241, 52], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqvGen_of_setoid", "code": "@[simp]\ntheorem eqvGen_of_setoid (r : Setoid \u03b1) : EqvGen.Setoid r.r = r", "start": [244, 1], "end": [247, 74], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqvGen_idem", "code": "@[simp]\ntheorem eqvGen_idem (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : EqvGen.Setoid (EqvGen.Setoid r).Rel = EqvGen.Setoid r", "start": [250, 1], "end": [253, 21], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqvGen_le", "code": "theorem eqvGen_le {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Setoid \u03b1} (h : \u2200 x y, r x y \u2192 s.Rel x y) :\n    EqvGen.Setoid r \u2264 s", "start": [256, 1], "end": [259, 62], "kind": "commanddeclaration"}, {"full_name": "Setoid.eqvGen_mono", "code": "theorem eqvGen_mono {r s : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : \u2200 x y, r x y \u2192 s x y) :\n    EqvGen.Setoid r \u2264 EqvGen.Setoid s", "start": [262, 1], "end": [265, 53], "kind": "commanddeclaration"}, {"full_name": "Setoid.gi", "code": "def gi : @GaloisInsertion (\u03b1 \u2192 \u03b1 \u2192 Prop) (Setoid \u03b1) _ _ EqvGen.Setoid Rel where\n  choice r _ := EqvGen.Setoid r\n  gc _ s := \u27e8fun H _ _ h => H <| EqvGen.rel _ _ h, fun H => eqvGen_of_setoid s \u25b8 eqvGen_mono H\u27e9\n  le_l_u x := (eqvGen_of_setoid x).symm \u25b8 le_refl x\n  choice_eq _ _ := rfl", "start": [268, 1], "end": [274, 23], "kind": "commanddeclaration"}, {"full_name": "Setoid.injective_iff_ker_bot", "code": "theorem injective_iff_ker_bot (f : \u03b1 \u2192 \u03b2) : Injective f \u2194 ker f = \u22a5", "start": [279, 1], "end": [282, 44], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_iff_mem_preimage", "code": "theorem ker_iff_mem_preimage {f : \u03b1 \u2192 \u03b2} {x y} : (ker f).Rel x y \u2194 x \u2208 f \u207b\u00b9' {f y}", "start": [285, 1], "end": [287, 10], "kind": "commanddeclaration"}, {"full_name": "Setoid.liftEquiv", "code": "def liftEquiv (r : Setoid \u03b1) : { f : \u03b1 \u2192 \u03b2 // r \u2264 ker f } \u2243 (Quotient r \u2192 \u03b2) where\n  toFun f := Quotient.lift (f : \u03b1 \u2192 \u03b2) f.2\n  invFun f := \u27e8f \u2218 Quotient.mk'', fun x y h => by simp [ker_def, Quotient.sound' h]\u27e9\n  left_inv := fun \u27e8f, hf\u27e9 => Subtype.eq <| funext fun x => rfl\n  right_inv f := funext fun x => Quotient.inductionOn' x fun x => rfl", "start": [290, 1], "end": [296, 70], "kind": "commanddeclaration"}, {"full_name": "Setoid.lift_unique", "code": "theorem lift_unique {r : Setoid \u03b1} {f : \u03b1 \u2192 \u03b2} (H : r \u2264 ker f) (g : Quotient r \u2192 \u03b2)\n    (Hg : f = g \u2218 Quotient.mk'') : Quotient.lift f H = g", "start": [299, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_lift_injective", "code": "theorem ker_lift_injective (f : \u03b1 \u2192 \u03b2) : Injective (@Quotient.lift _ _ (ker f) f fun _ _ h => h)", "start": [307, 1], "end": [310, 71], "kind": "commanddeclaration"}, {"full_name": "Setoid.ker_eq_lift_of_injective", "code": "theorem ker_eq_lift_of_injective {r : Setoid \u03b1} (f : \u03b1 \u2192 \u03b2) (H : \u2200 x y, r.Rel x y \u2192 f x = f y)\n    (h : Injective (Quotient.lift f H)) : ker f = r", "start": [313, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Setoid.quotientKerEquivRange", "code": "noncomputable def quotientKerEquivRange : Quotient (ker f) \u2243 Set.range f :=\n  Equiv.ofBijective\n    ((@Quotient.lift _ (Set.range f) (ker f) fun x => \u27e8f x, Set.mem_range_self x\u27e9) fun _ _ h =>\n      Subtype.ext_val h)\n    \u27e8fun x y h => ker_lift_injective f <| by rcases x with \u27e8\u27e9; rcases y with \u27e8\u27e9; injections,\n      fun \u27e8w, z, hz\u27e9 =>\n      \u27e8@Quotient.mk'' _ (ker f) z, Subtype.ext_iff_val.2 hz\u27e9\u27e9", "start": [325, 1], "end": [333, 62], "kind": "commanddeclaration"}, {"full_name": "Setoid.quotientKerEquivOfRightInverse", "code": "@[simps]\ndef quotientKerEquivOfRightInverse (g : \u03b2 \u2192 \u03b1) (hf : Function.RightInverse g f) :\n    Quotient (ker f) \u2243 \u03b2 where\n  toFun a := (Quotient.liftOn' a f) fun _ _ => id\n  invFun b := Quotient.mk'' (g b)\n  left_inv a := Quotient.inductionOn' a fun a => Quotient.sound' <| hf (f a)\n  right_inv := hf", "start": [336, 1], "end": [344, 18], "kind": "commanddeclaration"}, {"full_name": "Setoid.quotientKerEquivOfSurjective", "code": "noncomputable def quotientKerEquivOfSurjective (hf : Surjective f) : Quotient (ker f) \u2243 \u03b2 :=\n  quotientKerEquivOfRightInverse _ (Function.surjInv hf) (rightInverse_surjInv hf)", "start": [349, 1], "end": [354, 83], "kind": "commanddeclaration"}, {"full_name": "Setoid.map", "code": "def map (r : Setoid \u03b1) (f : \u03b1 \u2192 \u03b2) : Setoid \u03b2 :=\n  EqvGen.Setoid fun x y => \u2203 a b, f a = x \u2227 f b = y \u2227 r.Rel a b", "start": [359, 1], "end": [363, 64], "kind": "commanddeclaration"}, {"full_name": "Setoid.mapOfSurjective", "code": "def mapOfSurjective (r) (f : \u03b1 \u2192 \u03b2) (h : ker f \u2264 r) (hf : Surjective f) : Setoid \u03b2 :=\n  \u27e8fun x y => \u2203 a b, f a = x \u2227 f b = y \u2227 r.Rel a b,\n    \u27e8fun x =>\n      let \u27e8y, hy\u27e9 := hf x\n      \u27e8y, y, hy, hy, r.refl' y\u27e9,\n      fun \u27e8x, y, hx, hy, h\u27e9 => \u27e8y, x, hy, hx, r.symm' h\u27e9,\n      fun \u27e8x, y, hx, hy, h\u2081\u27e9 \u27e8y', z, hy', hz, h\u2082\u27e9 =>\n      \u27e8x, z, hx, hz, r.trans' h\u2081 <| r.trans' (h <| by rwa [\u2190 hy'] at hy) h\u2082\u27e9\u27e9\u27e9", "start": [366, 1], "end": [376, 79], "kind": "commanddeclaration"}, {"full_name": "Setoid.mapOfSurjective_eq_map", "code": "theorem mapOfSurjective_eq_map (h : ker f \u2264 r) (hf : Surjective f) :\n    map r f = mapOfSurjective r f h hf", "start": [379, 1], "end": [382, 58], "kind": "commanddeclaration"}, {"full_name": "Setoid.comap", "code": "@[reducible]\ndef comap (f : \u03b1 \u2192 \u03b2) (r : Setoid \u03b2) : Setoid \u03b1 :=\n  \u27e8r.Rel on f, r.iseqv.comap _\u27e9", "start": [385, 1], "end": [391, 32], "kind": "commanddeclaration"}, {"full_name": "Setoid.comap_rel", "code": "theorem comap_rel (f : \u03b1 \u2192 \u03b2) (r : Setoid \u03b2) (x y : \u03b1) : (comap f r).Rel x y \u2194 r.Rel (f x) (f y)", "start": [394, 1], "end": [395, 10], "kind": "commanddeclaration"}, {"full_name": "Setoid.comap_eq", "code": "theorem comap_eq {f : \u03b1 \u2192 \u03b2} {r : Setoid \u03b2} : comap f r = ker (@Quotient.mk'' _ r \u2218 f)", "start": [398, 1], "end": [401, 61], "kind": "commanddeclaration"}, {"full_name": "Setoid.comapQuotientEquiv", "code": "noncomputable def comapQuotientEquiv (f : \u03b1 \u2192 \u03b2) (r : Setoid \u03b2) :\n    Quotient (comap f r) \u2243 Set.range (@Quotient.mk'' _ r \u2218 f) :=\n  (Quotient.congrRight <| ext_iff.1 comap_eq).trans <| quotientKerEquivRange <| Quotient.mk'' \u2218 f", "start": [404, 1], "end": [407, 98], "kind": "commanddeclaration"}, {"full_name": "Setoid.quotientQuotientEquivQuotient", "code": "def quotientQuotientEquivQuotient (s : Setoid \u03b1) (h : r \u2264 s) :\n    Quotient (ker (Quot.mapRight h)) \u2243 Quotient s where\n  toFun x :=\n    (Quotient.liftOn' x fun w =>\n        (Quotient.liftOn' w (@Quotient.mk'' _ s)) fun x y H => Quotient.sound <| h H)\n      fun x y => Quotient.inductionOn\u2082' x y fun w z H => show @Quot.mk _ _ _ = @Quot.mk _ _ _ from H\n  invFun x :=\n    (Quotient.liftOn' x fun w => @Quotient.mk'' _ (ker <| Quot.mapRight h) <| @Quotient.mk'' _ r w)\n      fun x y H => Quotient.sound' <| show @Quot.mk _ _ _ = @Quot.mk _ _ _ from Quotient.sound H\n  left_inv x :=\n    Quotient.inductionOn' x fun y => Quotient.inductionOn' y fun w => by show \u27e6_\u27e7 = _; rfl\n  right_inv x := Quotient.inductionOn' x fun y => by show \u27e6_\u27e7 = _; rfl", "start": [412, 1], "end": [424, 71], "kind": "commanddeclaration"}, {"full_name": "Setoid.correspondence", "code": "def correspondence (r : Setoid \u03b1) : { s // r \u2264 s } \u2243o Setoid (Quotient r) where\n  toFun s := \u27e8Quotient.lift\u2082 s.1.1 fun _ _ _ _ h\u2081 h\u2082 \u21a6 Eq.propIntro\n      (fun h \u21a6 s.1.trans' (s.1.trans' (s.1.symm' (s.2 h\u2081)) h) (s.2 h\u2082))\n      (fun h \u21a6 s.1.trans' (s.1.trans' (s.2 h\u2081) h) (s.1.symm' (s.2 h\u2082))),\n    \u27e8Quotient.ind s.1.2.1, @fun x y \u21a6 Quotient.inductionOn\u2082 x y fun _ _ \u21a6 s.1.2.2,\n      @fun x y z \u21a6 Quotient.inductionOn\u2083 x y z fun _ _ _ \u21a6 s.1.2.3\u27e9\u27e9\n  invFun s := \u27e8comap Quotient.mk' s, fun x y h => by rw [comap_rel, eq_rel.2 h]\u27e9\n  left_inv s := rfl\n  right_inv s := ext fun x y \u21a6 Quotient.inductionOn\u2082 x y fun _ _ \u21a6 Iff.rfl\n  map_rel_iff' :=\n    \u27e8fun h x y hs \u21a6 @h \u27e6x\u27e7 \u27e6y\u27e7 hs, fun h x y \u21a6 Quotient.inductionOn\u2082 x y fun _ _ hs \u21a6 h hs\u27e9", "start": [431, 1], "end": [443, 92], "kind": "commanddeclaration"}, {"full_name": "Quotient.subsingleton_iff", "code": "@[simp]\ntheorem Quotient.subsingleton_iff {s : Setoid \u03b1} : Subsingleton (Quotient s) \u2194 s = \u22a4", "start": [448, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.subsingleton_iff", "code": "theorem Quot.subsingleton_iff (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Subsingleton (Quot r) \u2194 EqvGen r = \u22a4", "start": [458, 1], "end": [464, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Sigma.lean", "imports": ["Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.range_sigmaMk", "code": "@[simp]\ntheorem range_sigmaMk (i : \u03b9) : range (Sigma.mk i : \u03b1 i \u2192 Sigma \u03b1) = Sigma.fst \u207b\u00b9' {i}", "start": [21, 1], "end": [27, 27], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_image_sigmaMk_of_ne", "code": "theorem preimage_image_sigmaMk_of_ne (h : i \u2260 j) (s : Set (\u03b1 j)) :\n    Sigma.mk i \u207b\u00b9' (Sigma.mk j '' s) = \u2205", "start": [30, 1], "end": [33, 16], "kind": "commanddeclaration"}, {"full_name": "Set.image_sigmaMk_preimage_sigmaMap_subset", "code": "theorem image_sigmaMk_preimage_sigmaMap_subset {\u03b2 : \u03b9' \u2192 Type*} (f : \u03b9 \u2192 \u03b9')\n    (g : \u2200 i, \u03b1 i \u2192 \u03b2 (f i)) (i : \u03b9) (s : Set (\u03b2 (f i))) :\n    Sigma.mk i '' (g i \u207b\u00b9' s) \u2286 Sigma.map f g \u207b\u00b9' (Sigma.mk (f i) '' s)", "start": [36, 1], "end": [39, 49], "kind": "commanddeclaration"}, {"full_name": "Set.image_sigmaMk_preimage_sigmaMap", "code": "theorem image_sigmaMk_preimage_sigmaMap {\u03b2 : \u03b9' \u2192 Type*} {f : \u03b9 \u2192 \u03b9'} (hf : Function.Injective f)\n    (g : \u2200 i, \u03b1 i \u2192 \u03b2 (f i)) (i : \u03b9) (s : Set (\u03b2 (f i))) :\n    Sigma.mk i '' (g i \u207b\u00b9' s) = Sigma.map f g \u207b\u00b9' (Sigma.mk (f i) '' s)", "start": [42, 1], "end": [49, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Sigma", "code": "protected def Sigma (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) : Set (\u03a3i, \u03b1 i) :=\n  { x | x.1 \u2208 s \u2227 x.2 \u2208 t x.1 }", "start": [52, 1], "end": [55, 32], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sigma_iff", "code": "@[simp]\ntheorem mem_sigma_iff : x \u2208 s.Sigma t \u2194 x.1 \u2208 s \u2227 x.2 \u2208 t x.1", "start": [58, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mk_sigma_iff", "code": "theorem mk_sigma_iff : (\u27e8i, a\u27e9 : \u03a3 i, \u03b1 i) \u2208 s.Sigma t \u2194 i \u2208 s \u2227 a \u2208 t i", "start": [63, 1], "end": [64, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mk_mem_sigma", "code": "theorem mk_mem_sigma (hi : i \u2208 s) (ha : a \u2208 t i) : (\u27e8i, a\u27e9 : \u03a3i, \u03b1 i) \u2208 s.Sigma t", "start": [67, 1], "end": [68, 11], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_mono", "code": "theorem sigma_mono (hs : s\u2081 \u2286 s\u2082) (ht : \u2200 i, t\u2081 i \u2286 t\u2082 i) : s\u2081.Sigma t\u2081 \u2286 s\u2082.Sigma t\u2082", "start": [71, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_subset_iff", "code": "theorem sigma_subset_iff : s.Sigma t \u2286 u \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983a\u2984, a \u2208 t i \u2192 (\u27e8i, a\u27e9 : \u03a3i, \u03b1 i) \u2208 u", "start": [75, 1], "end": [76, 72], "kind": "commanddeclaration"}, {"full_name": "Set.forall_sigma_iff", "code": "theorem forall_sigma_iff {p : (\u03a3i, \u03b1 i) \u2192 Prop} :\n    (\u2200 x \u2208 s.Sigma t, p x) \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983a\u2984, a \u2208 t i \u2192 p \u27e8i, a\u27e9", "start": [79, 1], "end": [81, 19], "kind": "commanddeclaration"}, {"full_name": "Set.exists_sigma_iff", "code": "theorem exists_sigma_iff {p : (\u03a3i, \u03b1 i) \u2192 Prop} :\n    (\u2203 x \u2208 s.Sigma t, p x) \u2194 \u2203 i \u2208 s, \u2203 a \u2208 t i, p \u27e8i, a\u27e9", "start": [84, 1], "end": [86, 95], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_empty", "code": "@[simp]\ntheorem sigma_empty : (s.Sigma fun i \u21a6 (\u2205 : Set (\u03b1 i))) = \u2205", "start": [89, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "Set.empty_sigma", "code": "@[simp]\ntheorem empty_sigma : (\u2205 : Set \u03b9).Sigma t = \u2205", "start": [94, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "Set.univ_sigma_univ", "code": "theorem univ_sigma_univ : ((@univ \u03b9).Sigma fun _ \u21a6 @univ (\u03b1 i)) = univ", "start": [99, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_univ", "code": "@[simp]\ntheorem sigma_univ : s.Sigma (fun _ \u21a6 univ : \u2200 i, Set (\u03b1 i)) = Sigma.fst \u207b\u00b9' s", "start": [103, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_sigma", "code": "@[simp]\ntheorem singleton_sigma : ({i} : Set \u03b9).Sigma t = Sigma.mk i '' t i", "start": [108, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_singleton", "code": "@[simp]\ntheorem sigma_singleton {a : \u2200 i, \u03b1 i} :\n    (s.Sigma fun i \u21a6 ({a i} : Set (\u03b1 i))) = (fun i \u21a6 Sigma.mk i <| a i) '' s", "start": [119, 1], "end": [123, 32], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_sigma_singleton", "code": "theorem singleton_sigma_singleton {a : \u2200 i, \u03b1 i} :\n    (({i} : Set \u03b9).Sigma fun i \u21a6 ({a i} : Set (\u03b1 i))) = {\u27e8i, a i\u27e9}", "start": [126, 1], "end": [128, 40], "kind": "commanddeclaration"}, {"full_name": "Set.union_sigma", "code": "@[simp]\ntheorem union_sigma : (s\u2081 \u222a s\u2082).Sigma t = s\u2081.Sigma t \u222a s\u2082.Sigma t", "start": [131, 1], "end": [133, 27], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_union", "code": "@[simp]\ntheorem sigma_union : (s.Sigma fun i \u21a6 t\u2081 i \u222a t\u2082 i) = s.Sigma t\u2081 \u222a s.Sigma t\u2082", "start": [136, 1], "end": [138, 26], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_inter_sigma", "code": "theorem sigma_inter_sigma : s\u2081.Sigma t\u2081 \u2229 s\u2082.Sigma t\u2082 = (s\u2081 \u2229 s\u2082).Sigma fun i \u21a6 t\u2081 i \u2229 t\u2082 i", "start": [141, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Set.insert_sigma", "code": "theorem insert_sigma : (insert i s).Sigma t = Sigma.mk i '' t i \u222a s.Sigma t", "start": [146, 1], "end": [148, 10], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_insert", "code": "theorem sigma_insert {a : \u2200 i, \u03b1 i} :\n    (s.Sigma fun i \u21a6 insert (a i) (t i)) = (fun i \u21a6 \u27e8i, a i\u27e9) '' s \u222a s.Sigma t", "start": [151, 1], "end": [153, 52], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_preimage_eq", "code": "theorem sigma_preimage_eq {f : \u03b9' \u2192 \u03b9} {g : \u2200 i, \u03b2 i \u2192 \u03b1 i} :\n    ((f \u207b\u00b9' s).Sigma fun i \u21a6 g (f i) \u207b\u00b9' t (f i)) =\n      (fun p : \u03a3i, \u03b2 (f i) \u21a6 Sigma.mk _ (g _ p.2)) \u207b\u00b9' s.Sigma t", "start": [156, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_preimage_left", "code": "theorem sigma_preimage_left {f : \u03b9' \u2192 \u03b9} :\n    ((f \u207b\u00b9' s).Sigma fun i \u21a6 t (f i)) = (fun p : \u03a3i, \u03b1 (f i) \u21a6 Sigma.mk _ p.2) \u207b\u00b9' s.Sigma t", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_preimage_right", "code": "theorem sigma_preimage_right {g : \u2200 i, \u03b2 i \u2192 \u03b1 i} :\n    (s.Sigma fun i \u21a6 g i \u207b\u00b9' t i) = (fun p : \u03a3i, \u03b2 i \u21a6 Sigma.mk p.1 (g _ p.2)) \u207b\u00b9' s.Sigma t", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sigmaMap_sigma", "code": "theorem preimage_sigmaMap_sigma {\u03b1' : \u03b9' \u2192 Type*} (f : \u03b9 \u2192 \u03b9') (g : \u2200 i, \u03b1 i \u2192 \u03b1' (f i))\n    (s : Set \u03b9') (t : \u2200 i, Set (\u03b1' i)) :\n    Sigma.map f g \u207b\u00b9' s.Sigma t = (f \u207b\u00b9' s).Sigma fun i \u21a6 g i \u207b\u00b9' t (f i)", "start": [172, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_sigma", "code": "@[simp]\ntheorem mk_preimage_sigma (hi : i \u2208 s) : Sigma.mk i \u207b\u00b9' s.Sigma t = t i", "start": [178, 1], "end": [180, 31], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_sigma_eq_empty", "code": "@[simp]\ntheorem mk_preimage_sigma_eq_empty (hi : i \u2209 s) : Sigma.mk i \u207b\u00b9' s.Sigma t = \u2205", "start": [183, 1], "end": [185, 46], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_sigma_eq_if", "code": "theorem mk_preimage_sigma_eq_if [DecidablePred (\u00b7 \u2208 s)] :\n    Sigma.mk i \u207b\u00b9' s.Sigma t = if i \u2208 s then t i else \u2205", "start": [188, 1], "end": [189, 85], "kind": "commanddeclaration"}, {"full_name": "Set.mk_preimage_sigma_fn_eq_if", "code": "theorem mk_preimage_sigma_fn_eq_if {\u03b2 : Type*} [DecidablePred (\u00b7 \u2208 s)] (g : \u03b2 \u2192 \u03b1 i) :\n    (fun b \u21a6 Sigma.mk i (g b)) \u207b\u00b9' s.Sigma t = if i \u2208 s then g \u207b\u00b9' t i else \u2205", "start": [192, 1], "end": [194, 40], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_univ_range_eq", "code": "theorem sigma_univ_range_eq {f : \u2200 i, \u03b1 i \u2192 \u03b2 i} :\n    ((univ : Set \u03b9).Sigma fun i \u21a6 range (f i)) = range fun x : \u03a3i, \u03b1 i \u21a6 \u27e8x.1, f _ x.2\u27e9", "start": [197, 1], "end": [199, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.sigma", "code": "protected theorem Nonempty.sigma :\n    s.Nonempty \u2192 (\u2200 i, (t i).Nonempty) \u2192 (s.Sigma t : Set _).Nonempty", "start": [202, 1], "end": [205, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.sigma_fst", "code": "theorem Nonempty.sigma_fst : (s.Sigma t : Set _).Nonempty \u2192 s.Nonempty", "start": [208, 1], "end": [208, 100], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.sigma_snd", "code": "theorem Nonempty.sigma_snd : (s.Sigma t : Set _).Nonempty \u2192 \u2203 i \u2208 s, (t i).Nonempty", "start": [211, 1], "end": [212, 39], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_nonempty_iff", "code": "theorem sigma_nonempty_iff : (s.Sigma t : Set _).Nonempty \u2194 \u2203 i \u2208 s, (t i).Nonempty", "start": [215, 1], "end": [216, 62], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_eq_empty_iff", "code": "theorem sigma_eq_empty_iff : s.Sigma t = \u2205 \u2194 \u2200 i \u2208 s, t i = \u2205", "start": [219, 1], "end": [222, 65], "kind": "commanddeclaration"}, {"full_name": "Set.image_sigmaMk_subset_sigma_left", "code": "theorem image_sigmaMk_subset_sigma_left {a : \u2200 i, \u03b1 i} (ha : \u2200 i, a i \u2208 t i) :\n    (fun i \u21a6 Sigma.mk i (a i)) '' s \u2286 s.Sigma t", "start": [225, 1], "end": [227, 43], "kind": "commanddeclaration"}, {"full_name": "Set.image_sigmaMk_subset_sigma_right", "code": "theorem image_sigmaMk_subset_sigma_right (hi : i \u2208 s) : Sigma.mk i '' t i \u2286 s.Sigma t", "start": [230, 1], "end": [231, 42], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_subset_preimage_fst", "code": "theorem sigma_subset_preimage_fst (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) : s.Sigma t \u2286 Sigma.fst \u207b\u00b9' s", "start": [234, 1], "end": [235, 19], "kind": "commanddeclaration"}, {"full_name": "Set.fst_image_sigma_subset", "code": "theorem fst_image_sigma_subset (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) : Sigma.fst '' s.Sigma t \u2286 s", "start": [238, 1], "end": [239, 38], "kind": "commanddeclaration"}, {"full_name": "Set.fst_image_sigma", "code": "theorem fst_image_sigma (s : Set \u03b9) (ht : \u2200 i, (t i).Nonempty) : Sigma.fst '' s.Sigma t = s", "start": [242, 1], "end": [245, 28], "kind": "commanddeclaration"}, {"full_name": "Set.sigma_diff_sigma", "code": "theorem sigma_diff_sigma : s\u2081.Sigma t\u2081 \\ s\u2082.Sigma t\u2082 = s\u2081.Sigma (t\u2081 \\ t\u2082) \u222a (s\u2081 \\ s\u2082).Sigma t\u2081", "start": [248, 1], "end": [250, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Prod.lean", "imports": ["Mathlib/Algebra/Hom/Units.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.instMul", "code": "@[to_additive]\ninstance instMul [Mul M] [Mul N] : Mul (M \u00d7 N) :=\n  \u27e8fun p q => \u27e8p.1 * q.1, p.2 * q.2\u27e9\u27e9", "start": [40, 1], "end": [42, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_mul", "code": "@[to_additive (attr := simp)]\ntheorem fst_mul [Mul M] [Mul N] (p q : M \u00d7 N) : (p * q).1 = p.1 * q.1", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_mul", "code": "@[to_additive (attr := simp)]\ntheorem snd_mul [Mul M] [Mul N] (p q : M \u00d7 N) : (p * q).2 = p.2 * q.2", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_mul_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul_mk [Mul M] [Mul N] (a\u2081 a\u2082 : M) (b\u2081 b\u2082 : N) :\n    (a\u2081, b\u2081) * (a\u2082, b\u2082) = (a\u2081 * a\u2082, b\u2081 * b\u2082)", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_mul", "code": "@[to_additive (attr := simp)]\ntheorem swap_mul [Mul M] [Mul N] (p q : M \u00d7 N) : (p * q).swap = p.swap * q.swap", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mul_def", "code": "@[to_additive]\ntheorem mul_def [Mul M] [Mul N] (p q : M \u00d7 N) : p * q = (p.1 * q.1, p.2 * q.2)", "start": [69, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.one_mk_mul_one_mk", "code": "@[to_additive]\ntheorem one_mk_mul_one_mk [Monoid M] [Mul N] (b\u2081 b\u2082 : N) :\n    ((1 : M), b\u2081) * (1, b\u2082) = (1, b\u2081 * b\u2082)", "start": [75, 1], "end": [78, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_one_mul_mk_one", "code": "@[to_additive]\ntheorem mk_one_mul_mk_one [Mul M] [Monoid N] (a\u2081 a\u2082 : M) :\n    (a\u2081, (1 : N)) * (a\u2082, 1) = (a\u2081 * a\u2082, 1)", "start": [82, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.instOne", "code": "@[to_additive]\ninstance instOne [One M] [One N] : One (M \u00d7 N) :=\n  \u27e8(1, 1)\u27e9", "start": [89, 1], "end": [91, 11], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_one", "code": "@[to_additive (attr := simp)]\ntheorem fst_one [One M] [One N] : (1 : M \u00d7 N).1 = 1", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_one", "code": "@[to_additive (attr := simp)]\ntheorem snd_one [One M] [One N] : (1 : M \u00d7 N).2 = 1", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.one_eq_mk", "code": "@[to_additive]\ntheorem one_eq_mk [One M] [One N] : (1 : M \u00d7 N) = (1, 1)", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem mk_eq_one [One M] [One N] {x : M} {y : N} : (x, y) = 1 \u2194 x = 1 \u2227 y = 1", "start": [111, 1], "end": [113, 13], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_one", "code": "@[to_additive (attr := simp)]\ntheorem swap_one [One M] [One N] : (1 : M \u00d7 N).swap = 1", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_mul_snd", "code": "@[to_additive]\ntheorem fst_mul_snd [MulOneClass M] [MulOneClass N] (p : M \u00d7 N) : (p.fst, 1) * (1, p.snd) = p", "start": [123, 1], "end": [125, 34], "kind": "commanddeclaration"}, {"full_name": "Prod.instInv", "code": "@[to_additive]\ninstance instInv [Inv M] [Inv N] : Inv (M \u00d7 N) :=\n  \u27e8fun p => (p.1\u207b\u00b9, p.2\u207b\u00b9)\u27e9", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_inv", "code": "@[to_additive (attr := simp)]\ntheorem fst_inv [Inv G] [Inv H] (p : G \u00d7 H) : p\u207b\u00b9.1 = p.1\u207b\u00b9", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_inv", "code": "@[to_additive (attr := simp)]\ntheorem snd_inv [Inv G] [Inv H] (p : G \u00d7 H) : p\u207b\u00b9.2 = p.2\u207b\u00b9", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.inv_mk", "code": "@[to_additive (attr := simp)]\ntheorem inv_mk [Inv G] [Inv H] (a : G) (b : H) : (a, b)\u207b\u00b9 = (a\u207b\u00b9, b\u207b\u00b9)", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_inv", "code": "@[to_additive (attr := simp)]\ntheorem swap_inv [Inv G] [Inv H] (p : G \u00d7 H) : p\u207b\u00b9.swap = p.swap\u207b\u00b9", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.instDiv", "code": "@[to_additive]\ninstance instDiv [Div M] [Div N] : Div (M \u00d7 N) :=\n  \u27e8fun p q => \u27e8p.1 / q.1, p.2 / q.2\u27e9\u27e9", "start": [161, 1], "end": [163, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_div", "code": "@[to_additive (attr := simp)]\ntheorem fst_div [Div G] [Div H] (a b : G \u00d7 H) : (a / b).1 = a.1 / b.1", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_div", "code": "@[to_additive (attr := simp)]\ntheorem snd_div [Div G] [Div H] (a b : G \u00d7 H) : (a / b).2 = a.2 / b.2", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_div_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_div_mk [Div G] [Div H] (x\u2081 x\u2082 : G) (y\u2081 y\u2082 : H) :\n    (x\u2081, y\u2081) / (x\u2082, y\u2082) = (x\u2081 / x\u2082, y\u2081 / y\u2082)", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_div", "code": "@[to_additive (attr := simp)]\ntheorem swap_div [Div G] [Div H] (a b : G \u00d7 H) : (a / b).swap = a.swap / b.swap", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.instSemigroup", "code": "@[to_additive]\ninstance instSemigroup [Semigroup M] [Semigroup N] : Semigroup (M \u00d7 N) :=\n  { mul_assoc := fun _ _ _ => mk.inj_iff.mpr \u27e8mul_assoc _ _ _, mul_assoc _ _ _\u27e9 }", "start": [194, 1], "end": [196, 82], "kind": "commanddeclaration"}, {"full_name": "Prod.instCommSemigroup", "code": "@[to_additive]\ninstance instCommSemigroup [CommSemigroup G] [CommSemigroup H] : CommSemigroup (G \u00d7 H) :=\n  { mul_comm := fun _ _ => mk.inj_iff.mpr \u27e8mul_comm _ _, mul_comm _ _\u27e9 }", "start": [198, 1], "end": [200, 73], "kind": "commanddeclaration"}, {"full_name": "Prod.instMulOneClass", "code": "@[to_additive]\ninstance instMulOneClass [MulOneClass M] [MulOneClass N] : MulOneClass (M \u00d7 N) :=\n  { one_mul := fun a => Prod.recOn a fun _ _ => mk.inj_iff.mpr \u27e8one_mul _, one_mul _\u27e9,\n    mul_one := fun a => Prod.recOn a fun _ _ => mk.inj_iff.mpr \u27e8mul_one _, mul_one _\u27e9 }", "start": [206, 1], "end": [209, 88], "kind": "commanddeclaration"}, {"full_name": "Prod.instMonoid", "code": "@[to_additive]\ninstance instMonoid [Monoid M] [Monoid N] : Monoid (M \u00d7 N) :=\n  { npow := fun z a => \u27e8Monoid.npow z a.1, Monoid.npow z a.2\u27e9,\n    npow_zero := fun z => ext (Monoid.npow_zero _) (Monoid.npow_zero _),\n    npow_succ := fun z a => ext (Monoid.npow_succ _ _) (Monoid.npow_succ _ _),\n    one_mul := by simp,\n    mul_one := by simp }", "start": [211, 1], "end": [217, 25], "kind": "commanddeclaration"}, {"full_name": "Prod.instGroup", "code": "@[to_additive]\ninstance instGroup [Group G] [Group H] : Group (G \u00d7 H) :=\n  { mul_left_inv := fun _ => mk.inj_iff.mpr \u27e8mul_left_inv _, mul_left_inv _\u27e9 }", "start": [239, 1], "end": [241, 79], "kind": "commanddeclaration"}, {"full_name": "Prod.instCommMonoid", "code": "@[to_additive]\ninstance instCommMonoid [CommMonoid M] [CommMonoid N] : CommMonoid (M \u00d7 N) :=\n  { mul_comm := fun \u27e8m\u2081, n\u2081\u27e9 \u27e8_, _\u27e9 => by rw [mk_mul_mk, mk_mul_mk, mul_comm m\u2081, mul_comm n\u2081] }", "start": [267, 1], "end": [269, 96], "kind": "commanddeclaration"}, {"full_name": "Prod.instCommGroup", "code": "@[to_additive]\ninstance instCommGroup [CommGroup G] [CommGroup H] : CommGroup (G \u00d7 H) :=\n  { mul_comm := fun \u27e8g\u2081, h\u2081\u27e9 \u27e8_, _\u27e9 => by rw [mk_mul_mk, mk_mul_mk, mul_comm g\u2081, mul_comm h\u2081] }", "start": [287, 1], "end": [289, 96], "kind": "commanddeclaration"}, {"full_name": "MulHom.fst", "code": "@[to_additive\n      \"Given additive magmas `A`, `B`, the natural projection homomorphism\n      from `A \u00d7 B` to `A`\"]\ndef fst : M \u00d7 N \u2192\u2099* M :=\n  \u27e8Prod.fst, fun _ _ => rfl\u27e9", "start": [299, 1], "end": [304, 29], "kind": "commanddeclaration"}, {"full_name": "MulHom.snd", "code": "@[to_additive\n      \"Given additive magmas `A`, `B`, the natural projection homomorphism\n      from `A \u00d7 B` to `B`\"]\ndef snd : M \u00d7 N \u2192\u2099* N :=\n  \u27e8Prod.snd, fun _ _ => rfl\u27e9", "start": [308, 1], "end": [313, 29], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_fst", "code": "@[to_additive (attr := simp)]\ntheorem coe_fst : \u21d1(fst M N) = Prod.fst", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_snd", "code": "@[to_additive (attr := simp)]\ntheorem coe_snd : \u21d1(snd M N) = Prod.snd", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.prod", "code": "@[to_additive prod\n      \"Combine two `AddMonoidHom`s `f : AddHom M N`, `g : AddHom M P` into\n      `f.prod g : AddHom M (N \u00d7 P)` given by `(f.prod g) x = (f x, g x)`\"]\nprotected def prod (f : M \u2192\u2099* N) (g : M \u2192\u2099* P) :\n    M \u2192\u2099* N \u00d7 P where\n  toFun := Pi.prod f g\n  map_mul' x y := Prod.ext (f.map_mul x y) (g.map_mul x y)", "start": [331, 1], "end": [339, 59], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_prod", "code": "@[to_additive coe_prod]\ntheorem coe_prod (f : M \u2192\u2099* N) (g : M \u2192\u2099* P) : \u21d1(f.prod g) = Pi.prod f g", "start": [343, 1], "end": [345, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.prod_apply", "code": "@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M \u2192\u2099* N) (g : M \u2192\u2099* P) (x) : f.prod g x = (f x, g x)", "start": [349, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.fst_comp_prod", "code": "@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M \u2192\u2099* N) (g : M \u2192\u2099* P) : (fst N P).comp (f.prod g) = f", "start": [355, 1], "end": [357, 19], "kind": "commanddeclaration"}, {"full_name": "MulHom.snd_comp_prod", "code": "@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M \u2192\u2099* N) (g : M \u2192\u2099* P) : (snd N P).comp (f.prod g) = g", "start": [361, 1], "end": [363, 19], "kind": "commanddeclaration"}, {"full_name": "MulHom.prod_unique", "code": "@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M \u2192\u2099* N \u00d7 P) : ((fst N P).comp f).prod ((snd N P).comp f) = f", "start": [367, 1], "end": [369, 71], "kind": "commanddeclaration"}, {"full_name": "MulHom.prodMap", "code": "@[to_additive prodMap \"`prod.map` as an `AddMonoidHom`\"]\ndef prodMap : M \u00d7 N \u2192\u2099* M' \u00d7 N' :=\n  (f.comp (fst M N)).prod (g.comp (snd M N))", "start": [380, 1], "end": [383, 45], "kind": "commanddeclaration"}, {"full_name": "MulHom.prodMap_def", "code": "@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N))", "start": [387, 1], "end": [389, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_prodMap", "code": "@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : \u21d1(prodMap f g) = Prod.map f g", "start": [393, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.prod_comp_prodMap", "code": "@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P \u2192\u2099* M) (g : P \u2192\u2099* N) (f' : M \u2192\u2099* M') (g' : N \u2192\u2099* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g)", "start": [399, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.coprod", "code": "@[to_additive\n      \"Coproduct of two `AddHom`s with the same codomain:\n      `f.coprod g (p : M \u00d7 N) = f p.1 + g p.2`.\"]\ndef coprod : M \u00d7 N \u2192\u2099* P :=\n  f.comp (fst M N) * g.comp (snd M N)", "start": [412, 1], "end": [418, 38], "kind": "commanddeclaration"}, {"full_name": "MulHom.coprod_apply", "code": "@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M \u00d7 N) : f.coprod g p = f p.1 * g p.2", "start": [422, 1], "end": [424, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp_coprod", "code": "@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommSemigroup Q] (h : P \u2192\u2099* Q) (f : M \u2192\u2099* P) (g : N \u2192\u2099* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g)", "start": [428, 1], "end": [431, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fst", "code": "@[to_additive\n      \"Given additive monoids `A`, `B`, the natural projection homomorphism\n      from `A \u00d7 B` to `A`\"]\ndef fst : M \u00d7 N \u2192* M :=\n  { toFun := Prod.fst,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl }", "start": [443, 1], "end": [450, 33], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.snd", "code": "@[to_additive\n      \"Given additive monoids `A`, `B`, the natural projection homomorphism\n      from `A \u00d7 B` to `B`\"]\ndef snd : M \u00d7 N \u2192* N :=\n  { toFun := Prod.snd,\n    map_one' := rfl,\n    map_mul' := fun _ _ => rfl }", "start": [454, 1], "end": [461, 33], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inl", "code": "@[to_additive\n      \"Given additive monoids `A`, `B`, the natural inclusion homomorphism\n      from `A` to `A \u00d7 B`.\"]\ndef inl : M \u2192* M \u00d7 N :=\n  { toFun := fun x => (x, 1),\n    map_one' := rfl,\n    map_mul' := fun _ _ => Prod.ext rfl (one_mul 1).symm }", "start": [465, 1], "end": [472, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inr", "code": "@[to_additive\n      \"Given additive monoids `A`, `B`, the natural inclusion homomorphism\n      from `B` to `A \u00d7 B`.\"]\ndef inr : N \u2192* M \u00d7 N :=\n  { toFun := fun y => (1, y),\n    map_one' := rfl,\n    map_mul' := fun _ _ => Prod.ext (one_mul 1).symm rfl }", "start": [476, 1], "end": [483, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_fst", "code": "@[to_additive (attr := simp)]\ntheorem coe_fst : \u21d1(fst M N) = Prod.fst", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_snd", "code": "@[to_additive (attr := simp)]\ntheorem coe_snd : \u21d1(snd M N) = Prod.snd", "start": [495, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inl_apply", "code": "@[to_additive (attr := simp)]\ntheorem inl_apply (x) : inl M N x = (x, 1)", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inr_apply", "code": "@[to_additive (attr := simp)]\ntheorem inr_apply (y) : inr M N y = (1, y)", "start": [507, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fst_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem fst_comp_inl : (fst M N).comp (inl M N) = id M", "start": [513, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.snd_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem snd_comp_inl : (snd M N).comp (inl M N) = 1", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fst_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem fst_comp_inr : (fst M N).comp (inr M N) = 1", "start": [525, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.snd_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem snd_comp_inr : (snd M N).comp (inr M N) = id N", "start": [531, 1], "end": [533, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prod", "code": "@[to_additive prod\n      \"Combine two `AddMonoidHom`s `f : M \u2192+ N`, `g : M \u2192+ P` into\n      `f.prod g : M \u2192+ N \u00d7 P` given by `(f.prod g) x = (f x, g x)`\"]\nprotected def prod (f : M \u2192* N) (g : M \u2192* P) :\n    M \u2192* N \u00d7 P where\n  toFun := Pi.prod f g\n  map_one' := Prod.ext f.map_one g.map_one\n  map_mul' x y := Prod.ext (f.map_mul x y) (g.map_mul x y)", "start": [541, 1], "end": [550, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_prod", "code": "@[to_additive coe_prod]\ntheorem coe_prod (f : M \u2192* N) (g : M \u2192* P) : \u21d1(f.prod g) = Pi.prod f g", "start": [554, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prod_apply", "code": "@[to_additive (attr := simp) prod_apply]\ntheorem prod_apply (f : M \u2192* N) (g : M \u2192* P) (x) : f.prod g x = (f x, g x)", "start": [560, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fst_comp_prod", "code": "@[to_additive (attr := simp) fst_comp_prod]\ntheorem fst_comp_prod (f : M \u2192* N) (g : M \u2192* P) : (fst N P).comp (f.prod g) = f", "start": [566, 1], "end": [568, 19], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.snd_comp_prod", "code": "@[to_additive (attr := simp) snd_comp_prod]\ntheorem snd_comp_prod (f : M \u2192* N) (g : M \u2192* P) : (snd N P).comp (f.prod g) = g", "start": [572, 1], "end": [574, 19], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prod_unique", "code": "@[to_additive (attr := simp) prod_unique]\ntheorem prod_unique (f : M \u2192* N \u00d7 P) : ((fst N P).comp f).prod ((snd N P).comp f) = f", "start": [578, 1], "end": [580, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prodMap", "code": "@[to_additive prodMap \"`prod.map` as an `AddMonoidHom`.\"]\ndef prodMap : M \u00d7 N \u2192* M' \u00d7 N' :=\n  (f.comp (fst M N)).prod (g.comp (snd M N))", "start": [591, 1], "end": [594, 45], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prodMap_def", "code": "@[to_additive prodMap_def]\ntheorem prodMap_def : prodMap f g = (f.comp (fst M N)).prod (g.comp (snd M N))", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_prodMap", "code": "@[to_additive (attr := simp) coe_prodMap]\ntheorem coe_prodMap : \u21d1(prodMap f g) = Prod.map f g", "start": [604, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prod_comp_prodMap", "code": "@[to_additive prod_comp_prodMap]\ntheorem prod_comp_prodMap (f : P \u2192* M) (g : P \u2192* N) (f' : M \u2192* M') (g' : N \u2192* N') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g)", "start": [610, 1], "end": [613, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod", "code": "@[to_additive\n      \"Coproduct of two `AddMonoidHom`s with the same codomain:\n      `f.coprod g (p : M \u00d7 N) = f p.1 + g p.2`.\"]\ndef coprod : M \u00d7 N \u2192* P :=\n  f.comp (fst M N) * g.comp (snd M N)", "start": [623, 1], "end": [629, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod_apply", "code": "@[to_additive (attr := simp)]\ntheorem coprod_apply (p : M \u00d7 N) : f.coprod g p = f p.1 * g p.2", "start": [633, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod_comp_inl", "code": "@[to_additive (attr := simp)]\ntheorem coprod_comp_inl : (f.coprod g).comp (inl M N) = f", "start": [639, 1], "end": [641, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod_comp_inr", "code": "@[to_additive (attr := simp)]\ntheorem coprod_comp_inr : (f.coprod g).comp (inr M N) = g", "start": [645, 1], "end": [647, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod_unique", "code": "@[to_additive (attr := simp)]\ntheorem coprod_unique (f : M \u00d7 N \u2192* P) : (f.comp (inl M N)).coprod (f.comp (inr M N)) = f", "start": [651, 1], "end": [653, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coprod_inl_inr", "code": "@[to_additive (attr := simp)]\ntheorem coprod_inl_inr {M N : Type*} [CommMonoid M] [CommMonoid N] :\n    (inl M N).coprod (inr M N) = id (M \u00d7 N)", "start": [657, 1], "end": [660, 30], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_coprod", "code": "@[to_additive]\ntheorem comp_coprod {Q : Type*} [CommMonoid Q] (h : P \u2192* Q) (f : M \u2192* P) (g : N \u2192* P) :\n    h.comp (f.coprod g) = (h.comp f).coprod (h.comp g)", "start": [664, 1], "end": [667, 23], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodComm", "code": "@[to_additive prodComm\n      \"The equivalence between `M \u00d7 N` and `N \u00d7 M` given by swapping the\n      components is additive.\"]\ndef prodComm : M \u00d7 N \u2243* N \u00d7 M :=\n  { Equiv.prodComm M N with map_mul' := fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 => rfl }", "start": [681, 1], "end": [687, 67], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_prodComm", "code": "@[to_additive (attr := simp) coe_prodComm]\ntheorem coe_prodComm : \u21d1(prodComm : M \u00d7 N \u2243* N \u00d7 M) = Prod.swap", "start": [691, 1], "end": [693, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_prodComm_symm", "code": "@[to_additive (attr := simp) coe_prodComm_symm]\ntheorem coe_prodComm_symm : \u21d1(prodComm : M \u00d7 N \u2243* N \u00d7 M).symm = Prod.swap", "start": [697, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodProdProdComm", "code": "@[to_additive (attr := simps apply) prodProdProdComm\n    \"Four-way commutativity of `prod`.\\nThe name matches `mul_mul_mul_comm`\"]\ndef prodProdProdComm : (M \u00d7 N) \u00d7 M' \u00d7 N' \u2243* (M \u00d7 M') \u00d7 N \u00d7 N' :=\n  { Equiv.prodProdProdComm M N M' N' with\n    toFun := fun mnmn => ((mnmn.1.1, mnmn.2.1), (mnmn.1.2, mnmn.2.2))\n    invFun := fun mmnn => ((mmnn.1.1, mmnn.2.1), (mmnn.1.2, mmnn.2.2))\n    map_mul' := fun _mnmn _mnmn' => rfl }", "start": [709, 1], "end": [716, 42], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodProdProdComm_toEquiv", "code": "@[to_additive (attr := simp) prodProdProdComm_toEquiv]\ntheorem prodProdProdComm_toEquiv :\n    (prodProdProdComm M N M' N' : _ \u2243 _) = Equiv.prodProdProdComm M N M' N'", "start": [720, 1], "end": [723, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodProdProdComm_symm", "code": "@[simp]\ntheorem prodProdProdComm_symm : (prodProdProdComm M N M' N').symm = prodProdProdComm M M' N N'", "start": [727, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodCongr", "code": "@[to_additive prodCongr \"Product of additive isomorphisms; the maps come from `Equiv.prodCongr`.\"]\ndef prodCongr (f : M \u2243* M') (g : N \u2243* N') : M \u00d7 N \u2243* M' \u00d7 N' :=\n  { f.toEquiv.prodCongr g.toEquiv with\n    map_mul' := fun _ _ => Prod.ext (f.map_mul _ _) (g.map_mul _ _) }", "start": [734, 1], "end": [738, 70], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.uniqueProd", "code": "@[to_additive uniqueProd \"Multiplying by the trivial monoid doesn't change the structure.\"]\ndef uniqueProd [Unique N] : N \u00d7 M \u2243* M :=\n  { Equiv.uniqueProd M N with map_mul' := fun _ _ => rfl }", "start": [742, 1], "end": [745, 59], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodUnique", "code": "@[to_additive prodUnique \"Multiplying by the trivial monoid doesn't change the structure.\"]\ndef prodUnique [Unique N] : M \u00d7 N \u2243* M :=\n  { Equiv.prodUnique M N with map_mul' := fun _ _ => rfl }", "start": [749, 1], "end": [752, 59], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prodUnits", "code": "@[to_additive prodAddUnits\n      \"The additive monoid equivalence between additive units of a product\n      of two additive monoids, and the product of the additive units of each additive monoid.\"]\ndef prodUnits : (M \u00d7 N)\u02e3 \u2243* M\u02e3 \u00d7 N\u02e3 where\n  toFun := (Units.map (MonoidHom.fst M N)).prod (Units.map (MonoidHom.snd M N))\n  invFun u := \u27e8(u.1, u.2), (\u2191u.1\u207b\u00b9, \u2191u.2\u207b\u00b9), by simp, by simp\u27e9\n  left_inv u := by\n    simp only [MonoidHom.prod_apply, Units.coe_map, MonoidHom.coe_fst, MonoidHom.coe_snd,\n      Prod.mk.eta, Units.coe_map_inv, Units.mk_val]\n  right_inv := fun \u27e8u\u2081, u\u2082\u27e9 => by\n    simp only [Units.map, MonoidHom.coe_fst, Units.inv_eq_val_inv,\n      MonoidHom.coe_snd, MonoidHom.prod_apply, Prod.mk.injEq]\n    exact \u27e8rfl, rfl\u27e9\n  map_mul' := MonoidHom.map_mul _", "start": [762, 1], "end": [777, 34], "kind": "commanddeclaration"}, {"full_name": "Units.embedProduct", "code": "@[to_additive (attr := simps)\n      \"Canonical homomorphism of additive monoids from `AddUnits \u03b1` into `\u03b1 \u00d7 \u03b1\u1d43\u1d52\u1d56`.\n      Used mainly to define the natural topology of `AddUnits \u03b1`.\"]\ndef embedProduct (\u03b1 : Type*) [Monoid \u03b1] : \u03b1\u02e3 \u2192* \u03b1 \u00d7 \u03b1\u1d50\u1d52\u1d56 where\n  toFun x := \u27e8x, op \u2191x\u207b\u00b9\u27e9\n  map_one' := by\n    simp only [inv_one, eq_self_iff_true, Units.val_one, op_one, Prod.mk_eq_one, and_self_iff]\n  map_mul' x y := by simp only [mul_inv_rev, op_mul, Units.val_mul, Prod.mk_mul_mk]", "start": [789, 1], "end": [798, 84], "kind": "commanddeclaration"}, {"full_name": "Units.embedProduct_injective", "code": "@[to_additive]\ntheorem embedProduct_injective (\u03b1 : Type*) [Monoid \u03b1] : Function.Injective (embedProduct \u03b1)", "start": [804, 1], "end": [806, 55], "kind": "commanddeclaration"}, {"full_name": "mulMulHom", "code": "@[to_additive (attr := simps) \"Addition as an additive homomorphism.\"]\ndef mulMulHom [CommSemigroup \u03b1] :\n    \u03b1 \u00d7 \u03b1 \u2192\u2099* \u03b1 where\n  toFun a := a.1 * a.2\n  map_mul' _ _ := mul_mul_mul_comm _ _ _ _", "start": [819, 1], "end": [824, 43], "kind": "commanddeclaration"}, {"full_name": "mulMonoidHom", "code": "@[to_additive (attr := simps) \"Addition as an additive monoid homomorphism.\"]\ndef mulMonoidHom [CommMonoid \u03b1] : \u03b1 \u00d7 \u03b1 \u2192* \u03b1 :=\n  { mulMulHom with map_one' := mul_one _ }", "start": [830, 1], "end": [833, 43], "kind": "commanddeclaration"}, {"full_name": "mulMonoidWithZeroHom", "code": "@[simps]\ndef mulMonoidWithZeroHom [CommMonoidWithZero \u03b1] : \u03b1 \u00d7 \u03b1 \u2192*\u2080 \u03b1 :=\n  { mulMonoidHom with map_zero' := mul_zero _ }", "start": [839, 1], "end": [842, 48], "kind": "commanddeclaration"}, {"full_name": "divMonoidHom", "code": "@[to_additive (attr := simps) \"Subtraction as an additive monoid homomorphism.\"]\ndef divMonoidHom [DivisionCommMonoid \u03b1] : \u03b1 \u00d7 \u03b1 \u2192* \u03b1 where\n  toFun a := a.1 / a.2\n  map_one' := div_one _\n  map_mul' _ _ := mul_div_mul_comm _ _ _ _", "start": [846, 1], "end": [851, 43], "kind": "commanddeclaration"}, {"full_name": "divMonoidWithZeroHom", "code": "@[simps]\ndef divMonoidWithZeroHom [CommGroupWithZero \u03b1] : \u03b1 \u00d7 \u03b1 \u2192*\u2080 \u03b1 where\n  toFun a := a.1 / a.2\n  map_zero' := zero_div _\n  map_one' := div_one _\n  map_mul' _ _ := mul_div_mul_comm _ _ _ _", "start": [857, 1], "end": [863, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Sqrt.lean", "imports": ["Mathlib/Data/Nat/Size.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Nat/ForSqrt.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.IsSqrt", "code": "private def IsSqrt (n q : \u2115) : Prop :=\n  q * q \u2264 n \u2227 n < (q + 1) * (q + 1)", "start": [34, 1], "end": [35, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_isSqrt", "code": "private theorem sqrt_isSqrt (n : \u2115) : IsSqrt n (sqrt n)", "start": [47, 1], "end": [62, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_le", "code": "theorem sqrt_le (n : \u2115) : sqrt n * sqrt n \u2264 n", "start": [64, 1], "end": [65, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_le'", "code": "theorem sqrt_le' (n : \u2115) : sqrt n ^ 2 \u2264 n", "start": [68, 1], "end": [69, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_sqrt", "code": "theorem lt_succ_sqrt (n : \u2115) : n < succ (sqrt n) * succ (sqrt n)", "start": [72, 1], "end": [73, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_sqrt'", "code": "theorem lt_succ_sqrt' (n : \u2115) : n < succ (sqrt n) ^ 2", "start": [76, 1], "end": [77, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_le_add", "code": "theorem sqrt_le_add (n : \u2115) : n \u2264 sqrt n * sqrt n + sqrt n + sqrt n", "start": [80, 1], "end": [81, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.le_sqrt", "code": "theorem le_sqrt {m n : \u2115} : m \u2264 sqrt n \u2194 m * m \u2264 n", "start": [84, 1], "end": [86, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.le_sqrt'", "code": "theorem le_sqrt' {m n : \u2115} : m \u2264 sqrt n \u2194 m ^ 2 \u2264 n", "start": [89, 1], "end": [89, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_lt", "code": "theorem sqrt_lt {m n : \u2115} : sqrt m < n \u2194 m < n * n", "start": [92, 1], "end": [93, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_lt'", "code": "theorem sqrt_lt' {m n : \u2115} : sqrt m < n \u2194 m < n ^ 2", "start": [96, 1], "end": [97, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_le_self", "code": "theorem sqrt_le_self (n : \u2115) : sqrt n \u2264 n", "start": [100, 1], "end": [101, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_le_sqrt", "code": "theorem sqrt_le_sqrt {m n : \u2115} (h : m \u2264 n) : sqrt m \u2264 sqrt n", "start": [104, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_zero", "code": "@[simp]\ntheorem sqrt_zero : sqrt 0 = 0", "start": [108, 1], "end": [109, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_eq_zero", "code": "theorem sqrt_eq_zero {n : \u2115} : sqrt n = 0 \u2194 n = 0", "start": [112, 1], "end": [115, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_sqrt", "code": "theorem eq_sqrt {n q} : q = sqrt n \u2194 q * q \u2264 n \u2227 n < (q + 1) * (q + 1)", "start": [118, 1], "end": [120, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_sqrt'", "code": "theorem eq_sqrt' {n q} : q = sqrt n \u2194 q ^ 2 \u2264 n \u2227 n < (q + 1) ^ 2", "start": [123, 1], "end": [124, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.le_three_of_sqrt_eq_one", "code": "theorem le_three_of_sqrt_eq_one {n : \u2115} (h : sqrt n = 1) : n \u2264 3", "start": [127, 1], "end": [128, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_lt_self", "code": "theorem sqrt_lt_self {n : \u2115} (h : 1 < n) : sqrt n < n", "start": [131, 1], "end": [132, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_pos", "code": "theorem sqrt_pos {n : \u2115} : 0 < sqrt n \u2194 0 < n", "start": [135, 1], "end": [136, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_add_eq", "code": "theorem sqrt_add_eq (n : \u2115) {a : \u2115} (h : a \u2264 n + n) : sqrt (n * n + a) = n", "start": [139, 1], "end": [145, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_add_eq'", "code": "theorem sqrt_add_eq' (n : \u2115) {a : \u2115} (h : a \u2264 n + n) : sqrt (n ^ 2 + a) = n", "start": [148, 1], "end": [149, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_eq", "code": "theorem sqrt_eq (n : \u2115) : sqrt (n * n) = n", "start": [152, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_eq'", "code": "theorem sqrt_eq' (n : \u2115) : sqrt (n ^ 2) = n", "start": [156, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_one", "code": "@[simp]\ntheorem sqrt_one : sqrt 1 = 1", "start": [160, 1], "end": [162, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_succ_le_succ_sqrt", "code": "theorem sqrt_succ_le_succ_sqrt (n : \u2115) : sqrt n.succ \u2264 n.sqrt.succ", "start": [165, 1], "end": [168, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_mul_self", "code": "theorem exists_mul_self (x : \u2115) : (\u2203 n, n * n = x) \u2194 sqrt x * sqrt x = x", "start": [171, 1], "end": [172, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_mul_self'", "code": "theorem exists_mul_self' (x : \u2115) : (\u2203 n, n ^ 2 = x) \u2194 sqrt x ^ 2 = x", "start": [175, 1], "end": [176, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_mul_sqrt_lt_succ", "code": "theorem sqrt_mul_sqrt_lt_succ (n : \u2115) : sqrt n * sqrt n < n + 1", "start": [179, 1], "end": [180, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.sqrt_mul_sqrt_lt_succ'", "code": "theorem sqrt_mul_sqrt_lt_succ' (n : \u2115) : sqrt n ^ 2 < n + 1", "start": [183, 1], "end": [184, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_succ_sqrt", "code": "theorem succ_le_succ_sqrt (n : \u2115) : n + 1 \u2264 (sqrt n + 1) * (sqrt n + 1)", "start": [187, 1], "end": [188, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_succ_sqrt'", "code": "theorem succ_le_succ_sqrt' (n : \u2115) : n + 1 \u2264 (sqrt n + 1) ^ 2", "start": [191, 1], "end": [192, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.not_exists_sq", "code": "theorem not_exists_sq {n m : \u2115} (hl : m * m < n) (hr : n < (m + 1) * (m + 1)) :\n    \u00ac\u2203 t, t * t = n", "start": [195, 1], "end": [201, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.not_exists_sq'", "code": "theorem not_exists_sq' {n m : \u2115} (hl : m ^ 2 < n) (hr : n < (m + 1) ^ 2) : \u00ac\u2203 t, t ^ 2 = n", "start": [204, 1], "end": [206, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Lemmas.lean", "imports": ["Mathlib/Data/Rat/Defs.lean", "Mathlib/Data/Int/Div.lean", "Mathlib/Data/PNat/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Replace.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean"], "premises": [{"full_name": "Rat.num_dvd", "code": "theorem num_dvd (a) {b : \u2124} (b0 : b \u2260 0) : (a /. b).num \u2223 a", "start": [25, 1], "end": [30, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.den_dvd", "code": "theorem den_dvd (a b : \u2124) : ((a /. b).den : \u2124) \u2223 b", "start": [33, 1], "end": [38, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.num_den_mk", "code": "theorem num_den_mk {q : \u211a} {n d : \u2124} (hd : d \u2260 0) (qdf : q = n /. d) :\n    \u2203 c : \u2124, n = c * q.num \u2227 d = c * q.den", "start": [41, 1], "end": [56, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.num_mk", "code": "theorem num_mk (n d : \u2124) : (n /. d).num = d.sign * n / n.gcd d", "start": [62, 1], "end": [66, 57], "kind": "commanddeclaration"}, {"full_name": "Rat.den_mk", "code": "theorem den_mk (n d : \u2124) : (n /. d).den = if d = 0 then 1 else d.natAbs / n.gcd d", "start": [69, 1], "end": [71, 89], "kind": "commanddeclaration"}, {"full_name": "Rat.add_den_dvd", "code": "theorem add_den_dvd (q\u2081 q\u2082 : \u211a) : (q\u2081 + q\u2082).den \u2223 q\u2081.den * q\u2082.den", "start": [76, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_den_dvd", "code": "theorem mul_den_dvd (q\u2081 q\u2082 : \u211a) : (q\u2081 * q\u2082).den \u2223 q\u2081.den * q\u2082.den", "start": [82, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_num", "code": "theorem mul_num (q\u2081 q\u2082 : \u211a) :\n    (q\u2081 * q\u2082).num = q\u2081.num * q\u2082.num / Nat.gcd (q\u2081.num * q\u2082.num).natAbs (q\u2081.den * q\u2082.den)", "start": [88, 1], "end": [90, 29], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_den", "code": "theorem mul_den (q\u2081 q\u2082 : \u211a) :\n    (q\u2081 * q\u2082).den =\n      q\u2081.den * q\u2082.den / Nat.gcd (q\u2081.num * q\u2082.num).natAbs (q\u2081.den * q\u2082.den)", "start": [93, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_self_num", "code": "theorem mul_self_num (q : \u211a) : (q * q).num = q.num * q.num", "start": [99, 1], "end": [101, 76], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_self_den", "code": "theorem mul_self_den (q : \u211a) : (q * q).den = q.den * q.den", "start": [104, 1], "end": [106, 76], "kind": "commanddeclaration"}, {"full_name": "Rat.add_num_den", "code": "theorem add_num_den (q r : \u211a) :\n    q + r = (q.num * r.den + q.den * r.num : \u2124) /. (\u2191q.den * \u2191r.den : \u2124)", "start": [109, 1], "end": [114, 28], "kind": "commanddeclaration"}, {"full_name": "Rat.exists_eq_mul_div_num_and_eq_mul_div_den", "code": "theorem exists_eq_mul_div_num_and_eq_mul_div_den (n : \u2124) {d : \u2124} (d_ne_zero : d \u2260 0) :\n    \u2203 c : \u2124, n = c * ((n : \u211a) / d).num \u2227 (d : \u2124) = c * ((n : \u211a) / d).den", "start": [119, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_num_den'", "code": "theorem mul_num_den' (q r : \u211a) :\n    (q * r).num * q.den * r.den = q.num * r.num * (q * r).den", "start": [125, 1], "end": [144, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.add_num_den'", "code": "theorem add_num_den' (q r : \u211a) :\n    (q + r).num * q.den * r.den = (q.num * r.den + r.num * q.den) * (q + r).den", "start": [147, 1], "end": [166, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.substr_num_den'", "code": "theorem substr_num_den' (q r : \u211a) :\n    (q - r).num * q.den * r.den = (q.num * r.den - r.num * q.den) * (q - r).den", "start": [169, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_def''", "code": "theorem inv_def'' {q : \u211a} : q\u207b\u00b9 = (q.den : \u211a) / q.num", "start": [177, 1], "end": [179, 36], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_neg", "code": "protected theorem inv_neg (q : \u211a) : (-q)\u207b\u00b9 = -q\u207b\u00b9", "start": [182, 1], "end": [184, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_den_eq_num", "code": "@[simp]\ntheorem mul_den_eq_num {q : \u211a} : q * q.den = q.num", "start": [187, 1], "end": [193, 84], "kind": "commanddeclaration"}, {"full_name": "Rat.den_div_cast_eq_one_iff", "code": "theorem den_div_cast_eq_one_iff (m n : \u2124) (hn : n \u2260 0) : ((m : \u211a) / n).den = 1 \u2194 n \u2223 m", "start": [196, 1], "end": [207, 70], "kind": "commanddeclaration"}, {"full_name": "Rat.num_div_eq_of_coprime", "code": "theorem num_div_eq_of_coprime {a b : \u2124} (hb0 : 0 < b) (h : Nat.Coprime a.natAbs b.natAbs) :\n    (a / b : \u211a).num = a", "start": [210, 1], "end": [214, 58], "kind": "commanddeclaration"}, {"full_name": "Rat.den_div_eq_of_coprime", "code": "theorem den_div_eq_of_coprime {a b : \u2124} (hb0 : 0 < b) (h : Nat.Coprime a.natAbs b.natAbs) :\n    ((a / b : \u211a).den : \u2124) = b", "start": [217, 1], "end": [221, 58], "kind": "commanddeclaration"}, {"full_name": "Rat.div_int_inj", "code": "theorem div_int_inj {a b c d : \u2124} (hb0 : 0 < b) (hd0 : 0 < d) (h1 : Nat.Coprime a.natAbs b.natAbs)\n    (h2 : Nat.Coprime c.natAbs d.natAbs) (h : (a : \u211a) / b = (c : \u211a) / d) : a = c \u2227 b = d", "start": [224, 1], "end": [228, 73], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_div_self", "code": "@[norm_cast]\ntheorem coe_int_div_self (n : \u2124) : ((n / n : \u2124) : \u211a) = n / n", "start": [231, 1], "end": [237, 85], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nat_div_self", "code": "@[norm_cast]\ntheorem coe_nat_div_self (n : \u2115) : ((n / n : \u2115) : \u211a) = n / n", "start": [240, 1], "end": [242, 21], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_int_div", "code": "theorem coe_int_div (a b : \u2124) (h : b \u2223 a) : ((a / b : \u2124) : \u211a) = a / b", "start": [245, 1], "end": [248, 51], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_nat_div", "code": "theorem coe_nat_div (a b : \u2115) (h : b \u2223 a) : ((a / b : \u2115) : \u211a) = a / b", "start": [251, 1], "end": [254, 22], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_int_num_of_pos", "code": "theorem inv_coe_int_num_of_pos {a : \u2124} (ha0 : 0 < a) : (a : \u211a)\u207b\u00b9.num = 1", "start": [257, 1], "end": [261, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_nat_num_of_pos", "code": "theorem inv_coe_nat_num_of_pos {a : \u2115} (ha0 : 0 < a) : (a : \u211a)\u207b\u00b9.num = 1", "start": [264, 1], "end": [265, 63], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_int_den_of_pos", "code": "theorem inv_coe_int_den_of_pos {a : \u2124} (ha0 : 0 < a) : ((a : \u211a)\u207b\u00b9.den : \u2124) = a", "start": [268, 1], "end": [272, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_nat_den_of_pos", "code": "theorem inv_coe_nat_den_of_pos {a : \u2115} (ha0 : 0 < a) : (a : \u211a)\u207b\u00b9.den = a", "start": [275, 1], "end": [277, 21], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_int_num", "code": "@[simp]\ntheorem inv_coe_int_num (a : \u2124) : (a : \u211a)\u207b\u00b9.num = Int.sign a", "start": [280, 1], "end": [285, 45], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_nat_num", "code": "@[simp]\ntheorem inv_coe_nat_num (a : \u2115) : (a : \u211a)\u207b\u00b9.num = Int.sign a", "start": [288, 1], "end": [290, 20], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_int_den", "code": "@[simp]\ntheorem inv_coe_int_den (a : \u2124) : (a : \u211a)\u207b\u00b9.den = if a = 0 then 1 else a.natAbs", "start": [293, 1], "end": [297, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.inv_coe_nat_den", "code": "@[simp]\ntheorem inv_coe_nat_den (a : \u2115) : (a : \u211a)\u207b\u00b9.den = if a = 0 then 1 else a", "start": [300, 1], "end": [302, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.forall", "code": "protected theorem \u00abforall\u00bb {p : \u211a \u2192 Prop} : (\u2200 r, p r) \u2194 \u2200 a b : \u2124, p (a / b)", "start": [305, 1], "end": [309, 49], "kind": "commanddeclaration"}, {"full_name": "Rat.exists", "code": "protected theorem \u00abexists\u00bb {p : \u211a \u2192 Prop} : (\u2203 r, p r) \u2194 \u2203 a b : \u2124, p (a / b)", "start": [312, 1], "end": [313, 97], "kind": "commanddeclaration"}, {"full_name": "Rat.pnatDen", "code": "def pnatDen (x : \u211a) : \u2115+ :=\n  \u27e8x.den, x.pos\u27e9", "start": [323, 1], "end": [325, 17], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_pnatDen", "code": "@[simp]\ntheorem coe_pnatDen (x : \u211a) : (x.pnatDen : \u2115) = x.den", "start": [328, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.pnatDen_eq_iff_den_eq", "code": "theorem pnatDen_eq_iff_den_eq {x : \u211a} {n : \u2115+} : x.pnatDen = n \u2194 x.den = \u2191n", "start": [335, 1], "end": [336, 18], "kind": "commanddeclaration"}, {"full_name": "Rat.pnatDen_one", "code": "@[simp]\ntheorem pnatDen_one : (1 : \u211a).pnatDen = 1", "start": [339, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.pnatDen_zero", "code": "@[simp]\ntheorem pnatDen_zero : (0 : \u211a).pnatDen = 1", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Basic.lean", "imports": ["Mathlib/Data/Rat/Defs.lean", "Mathlib/Algebra/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.field", "code": "instance field : Field \u211a :=\n  { mul_inv_cancel := Rat.commGroupWithZero.mul_inv_cancel\n    inv_zero := Rat.commGroupWithZero.inv_zero\n    ratCast := Rat.cast\n    ratCast_mk := fun a b h1 h2 => (num_div_den _).symm\n    qsmul := (\u00b7 * \u00b7) }", "start": [38, 1], "end": [43, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.divisionRing", "code": "instance divisionRing : DivisionRing \u211a := by infer_instance", "start": [46, 1], "end": [46, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Sum.lean", "imports": ["Mathlib/Data/Finset/Card.lean", "Mathlib/Data/Multiset/Sum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.disjSum", "code": "def disjSum : Finset (Sum \u03b1 \u03b2) :=\n  \u27e8s.1.disjSum t.1, s.2.disjSum t.2\u27e9", "start": [29, 1], "end": [31, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.val_disjSum", "code": "@[simp]\ntheorem val_disjSum : (s.disjSum t).1 = s.1.disjSum t.1", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_disjSum", "code": "@[simp]\ntheorem empty_disjSum : (\u2205 : Finset \u03b1).disjSum t = t.map Embedding.inr", "start": [39, 1], "end": [41, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_empty", "code": "@[simp]\ntheorem disjSum_empty : s.disjSum (\u2205 : Finset \u03b2) = s.map Embedding.inl", "start": [44, 1], "end": [46, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.card_disjSum", "code": "@[simp]\ntheorem card_disjSum : (s.disjSum t).card = s.card + t.card", "start": [49, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_map_inl_map_inr", "code": "theorem disjoint_map_inl_map_inr : Disjoint (s.map Embedding.inl) (t.map Embedding.inr)", "start": [54, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.map_inl_disjUnion_map_inr", "code": "@[simp]\ntheorem map_inl_disjUnion_map_inr :\n    (s.map Embedding.inl).disjUnion (t.map Embedding.inr) (disjoint_map_inl_map_inr _ _) =\n      s.disjSum t", "start": [59, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_disjSum", "code": "theorem mem_disjSum : x \u2208 s.disjSum t \u2194 (\u2203 a, a \u2208 s \u2227 inl a = x) \u2228 \u2203 b, b \u2208 t \u2227 inr b = x", "start": [68, 1], "end": [69, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.inl_mem_disjSum", "code": "@[simp]\ntheorem inl_mem_disjSum : inl a \u2208 s.disjSum t \u2194 a \u2208 s", "start": [72, 1], "end": [74, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.inr_mem_disjSum", "code": "@[simp]\ntheorem inr_mem_disjSum : inr b \u2208 s.disjSum t \u2194 b \u2208 t", "start": [77, 1], "end": [79, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_mono", "code": "theorem disjSum_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : s\u2081.disjSum t\u2081 \u2286 s\u2082.disjSum t\u2082", "start": [82, 1], "end": [83, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_mono_left", "code": "theorem disjSum_mono_left (t : Finset \u03b2) : Monotone fun s : Finset \u03b1 => s.disjSum t", "start": [86, 1], "end": [87, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_mono_right", "code": "theorem disjSum_mono_right (s : Finset \u03b1) : Monotone (s.disjSum : Finset \u03b2 \u2192 Finset (Sum \u03b1 \u03b2))", "start": [90, 1], "end": [91, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_ssubset_disjSum_of_ssubset_of_subset", "code": "theorem disjSum_ssubset_disjSum_of_ssubset_of_subset (hs : s\u2081 \u2282 s\u2082) (ht : t\u2081 \u2286 t\u2082) :\n    s\u2081.disjSum t\u2081 \u2282 s\u2082.disjSum t\u2082", "start": [94, 1], "end": [96, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_ssubset_disjSum_of_subset_of_ssubset", "code": "theorem disjSum_ssubset_disjSum_of_subset_of_ssubset (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2282 t\u2082) :\n    s\u2081.disjSum t\u2081 \u2282 s\u2082.disjSum t\u2082", "start": [99, 1], "end": [101, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.disjSum_strictMono_left", "code": "theorem disjSum_strictMono_left (t : Finset \u03b2) : StrictMono fun s : Finset \u03b1 => s.disjSum t", "start": [104, 1], "end": [105, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.disj_sum_strictMono_right", "code": "theorem disj_sum_strictMono_right (s : Finset \u03b1) :\n    StrictMono (s.disjSum : Finset \u03b2 \u2192 Finset (Sum \u03b1 \u03b2))", "start": [108, 1], "end": [110, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Embedding/Set.lean", "imports": ["Mathlib/Logic/Embedding/Basic.lean", "Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.asEmbedding_range", "code": "@[simp]\ntheorem Equiv.asEmbedding_range {\u03b1 \u03b2 : Sort _} {p : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 Subtype p) :\n    Set.range e.asEmbedding = setOf p", "start": [23, 1], "end": [26, 96], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coeWithTop", "code": "@[simps]\ndef coeWithTop {\u03b1} : \u03b1 \u21aa WithTop \u03b1 :=\n  { Embedding.some with toFun := WithTop.some }", "start": [35, 1], "end": [38, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.optionElim", "code": "@[simps]\ndef optionElim {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (x : \u03b2) (h : x \u2209 Set.range f) : Option \u03b1 \u21aa \u03b2 :=\n  \u27e8Option.elim' x f, Option.injective_iff.2 \u27e8f.2, h\u27e9\u27e9", "start": [42, 1], "end": [46, 54], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.optionEmbeddingEquiv", "code": "@[simps]\ndef optionEmbeddingEquiv (\u03b1 \u03b2) : (Option \u03b1 \u21aa \u03b2) \u2243 \u03a3 f : \u03b1 \u21aa \u03b2, \u21a5(Set.range f)\u1d9c where\n  toFun f := \u27e8coeWithTop.trans f, f none, fun \u27e8x, hx\u27e9 \u21a6 Option.some_ne_none x <| f.injective hx\u27e9\n  invFun f := f.1.optionElim f.2 f.2.2\n  left_inv f := ext <| by rintro (_ | _) <;> simp [Option.coe_def]; rfl\n  right_inv := fun \u27e8f, y, hy\u27e9 \u21a6 by ext <;> simp [Option.coe_def]; rfl", "start": [50, 1], "end": [56, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.codRestrict", "code": "def codRestrict {\u03b1 \u03b2} (p : Set \u03b2) (f : \u03b1 \u21aa \u03b2) (H : \u2200 a, f a \u2208 p) : \u03b1 \u21aa p :=\n  \u27e8fun a \u21a6 \u27e8f a, H a\u27e9, fun _ _ h \u21a6 f.injective (congr_arg Subtype.val h)\u27e9", "start": [62, 1], "end": [64, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.codRestrict_apply", "code": "@[simp]\ntheorem codRestrict_apply {\u03b1 \u03b2} (p) (f : \u03b1 \u21aa \u03b2) (H a) : codRestrict p f H a = \u27e8f a, H a\u27e9", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.image", "code": "@[simps apply]\nprotected def image {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) : Set \u03b1 \u21aa Set \u03b2 :=\n  \u27e8image f, f.2.image_injective\u27e9", "start": [74, 1], "end": [77, 33], "kind": "commanddeclaration"}, {"full_name": "Set.embeddingOfSubset", "code": "@[simps apply]\ndef embeddingOfSubset {\u03b1} (s t : Set \u03b1) (h : s \u2286 t) : s \u21aa t :=\n  \u27e8fun x \u21a6 \u27e8x.1, h x.2\u27e9, fun \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 h \u21a6 by\n    congr\n    injection h\u27e9", "start": [87, 1], "end": [92, 17], "kind": "commanddeclaration"}, {"full_name": "subtypeOrEquiv", "code": "@[simps apply]\ndef subtypeOrEquiv (p q : \u03b1 \u2192 Prop) [DecidablePred p] (h : Disjoint p q) :\n    { x // p x \u2228 q x } \u2243 { x // p x } \u2295 { x // q x } where\n  toFun := subtypeOrLeftEmbedding p q\n  invFun :=\n    Sum.elim (Subtype.impEmbedding _ _ fun x hx \u21a6 (Or.inl hx : p x \u2228 q x))\n      (Subtype.impEmbedding _ _ fun x hx \u21a6 (Or.inr hx : p x \u2228 q x))\n  left_inv x := by\n    by_cases hx : p x\n    \u00b7 rw [subtypeOrLeftEmbedding_apply_left _ hx]\n      simp [Subtype.ext_iff]\n    \u00b7 rw [subtypeOrLeftEmbedding_apply_right _ hx]\n      simp [Subtype.ext_iff]\n  right_inv x := by\n    cases x with\n    | inl x =>\n        simp only [Sum.elim_inl]\n        rw [subtypeOrLeftEmbedding_apply_left]\n        \u00b7 simp\n        \u00b7 simpa using x.prop\n    | inr x =>\n        simp only [Sum.elim_inr]\n        rw [subtypeOrLeftEmbedding_apply_right]\n        \u00b7 simp\n        \u00b7 suffices \u00acp x by simpa\n          intro hp\n          simpa using h.le_bot x \u27e8hp, x.prop\u27e9", "start": [102, 1], "end": [133, 46], "kind": "commanddeclaration"}, {"full_name": "subtypeOrEquiv_symm_inl", "code": "@[simp]\ntheorem subtypeOrEquiv_symm_inl (p q : \u03b1 \u2192 Prop) [DecidablePred p] (h : Disjoint p q)\n    (x : { x // p x }) : (subtypeOrEquiv p q h).symm (Sum.inl x) = \u27e8x, Or.inl x.prop\u27e9", "start": [137, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "subtypeOrEquiv_symm_inr", "code": "@[simp]\ntheorem subtypeOrEquiv_symm_inr (p q : \u03b1 \u2192 Prop) [DecidablePred p] (h : Disjoint p q)\n    (x : { x // q x }) : (subtypeOrEquiv p q h).symm (Sum.inr x) = \u27e8x, Or.inr x.prop\u27e9", "start": [143, 1], "end": [146, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Card.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Data/Finset/Card.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/NodupEquivFin.lean", "Mathlib/Data/Fintype/Basic.lean"], "premises": [{"full_name": "Fintype.card", "code": "def card (\u03b1) [Fintype \u03b1] : \u2115 :=\n  (@univ \u03b1 _).card", "start": [60, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncEquivFin", "code": "def truncEquivFin (\u03b1) [DecidableEq \u03b1] [Fintype \u03b1] : Trunc (\u03b1 \u2243 Fin (card \u03b1)) := by\n  unfold card Finset.card\n  exact\n    Quot.recOnSubsingleton'\n      (motive := fun s : Multiset \u03b1 =>\n        (\u2200 x : \u03b1, x \u2208 s) \u2192 s.Nodup \u2192 Trunc (\u03b1 \u2243 Fin (Multiset.card s)))\n      univ.val\n      (fun l (h : \u2200 x : \u03b1, x \u2208 l) (nd : l.Nodup) => Trunc.mk (nd.getEquivOfForallMemList _ h).symm)\n      mem_univ_val univ.2", "start": [65, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.equivFin", "code": "noncomputable def equivFin (\u03b1) [Fintype \u03b1] : \u03b1 \u2243 Fin (card \u03b1) :=\n  letI := Classical.decEq \u03b1\n  (truncEquivFin \u03b1).out", "start": [88, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncFinBijection", "code": "def truncFinBijection (\u03b1) [Fintype \u03b1] : Trunc { f : Fin (card \u03b1) \u2192 \u03b1 // Bijective f } := by\n  unfold card Finset.card\n  refine\n    Quot.recOnSubsingleton'\n      (motive := fun s : Multiset \u03b1 =>\n        (\u2200 x : \u03b1, x \u2208 s) \u2192 s.Nodup \u2192 Trunc {f : Fin (Multiset.card s) \u2192 \u03b1 // Bijective f})\n      univ.val\n      (fun l (h : \u2200 x : \u03b1, x \u2208 l) (nd : l.Nodup) => Trunc.mk (nd.getBijectionOfForallMemList _ h))\n      mem_univ_val univ.2", "start": [99, 1], "end": [116, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.subtype_card", "code": "theorem subtype_card {p : \u03b1 \u2192 Prop} (s : Finset \u03b1) (H : \u2200 x : \u03b1, x \u2208 s \u2194 p x) :\n    @card { x // p x } (Fintype.subtype s H) = s.card", "start": [119, 1], "end": [121, 27], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_of_subtype", "code": "theorem card_of_subtype {p : \u03b1 \u2192 Prop} (s : Finset \u03b1) (H : \u2200 x : \u03b1, x \u2208 s \u2194 p x)\n    [Fintype { x // p x }] : card { x // p x } = s.card", "start": [124, 1], "end": [128, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_ofFinset", "code": "@[simp]\ntheorem card_ofFinset {p : Set \u03b1} (s : Finset \u03b1) (H : \u2200 x, x \u2208 s \u2194 x \u2208 p) :\n    @Fintype.card p (ofFinset s H) = s.card", "start": [131, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_of_finset'", "code": "theorem card_of_finset' {p : Set \u03b1} (s : Finset \u03b1) (H : \u2200 x, x \u2208 s \u2194 x \u2208 p) [Fintype p] :\n    Fintype.card p = s.card", "start": [137, 1], "end": [138, 91], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofEquiv_card", "code": "theorem ofEquiv_card [Fintype \u03b1] (f : \u03b1 \u2243 \u03b2) : @card \u03b2 (ofEquiv \u03b1 f) = card \u03b1", "start": [145, 1], "end": [146, 24], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_congr", "code": "theorem card_congr {\u03b1 \u03b2} [Fintype \u03b1] [Fintype \u03b2] (f : \u03b1 \u2243 \u03b2) : card \u03b1 = card \u03b2", "start": [149, 1], "end": [150, 56], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_congr'", "code": "@[congr]\ntheorem card_congr' {\u03b1 \u03b2} [Fintype \u03b1] [Fintype \u03b2] (h : \u03b1 = \u03b2) : card \u03b1 = card \u03b2", "start": [153, 1], "end": [155, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncEquivFinOfCardEq", "code": "def truncEquivFinOfCardEq [DecidableEq \u03b1] {n : \u2115} (h : Fintype.card \u03b1 = n) : Trunc (\u03b1 \u2243 Fin n) :=\n  (truncEquivFin \u03b1).map fun e => e.trans (Fin.castIso h).toEquiv", "start": [162, 1], "end": [168, 65], "kind": "commanddeclaration"}, {"full_name": "Fintype.equivFinOfCardEq", "code": "noncomputable def equivFinOfCardEq {n : \u2115} (h : Fintype.card \u03b1 = n) : \u03b1 \u2243 Fin n :=\n  letI := Classical.decEq \u03b1\n  (truncEquivFinOfCardEq h).out", "start": [171, 1], "end": [178, 32], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncEquivOfCardEq", "code": "def truncEquivOfCardEq [DecidableEq \u03b1] [DecidableEq \u03b2] (h : card \u03b1 = card \u03b2) : Trunc (\u03b1 \u2243 \u03b2) :=\n  (truncEquivFinOfCardEq h).bind fun e => (truncEquivFin \u03b2).map fun e' => e.trans e'.symm", "start": [181, 1], "end": [188, 90], "kind": "commanddeclaration"}, {"full_name": "Fintype.equivOfCardEq", "code": "noncomputable def equivOfCardEq (h : card \u03b1 = card \u03b2) : \u03b1 \u2243 \u03b2 := by\n  letI := Classical.decEq \u03b1\n  letI := Classical.decEq \u03b2\n  exact (truncEquivOfCardEq h).out", "start": [191, 1], "end": [200, 35], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq", "code": "theorem card_eq {\u03b1 \u03b2} [_F : Fintype \u03b1] [_G : Fintype \u03b2] : card \u03b1 = card \u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "start": [205, 1], "end": [209, 29], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_ofSubsingleton", "code": "@[simp]\ntheorem card_ofSubsingleton (a : \u03b1) [Subsingleton \u03b1] : @Fintype.card _ (ofSubsingleton a) = 1", "start": [212, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_unique", "code": "@[simp]\ntheorem card_unique [Unique \u03b1] [h : Fintype \u03b1] : Fintype.card \u03b1 = 1", "start": [220, 1], "end": [222, 71], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_of_isEmpty", "code": "@[simp]\ntheorem card_of_isEmpty [IsEmpty \u03b1] : Fintype.card \u03b1 = 0", "start": [225, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_card", "code": "@[simp]\ntheorem toFinset_card {\u03b1 : Type*} (s : Set \u03b1) [Fintype s] : s.toFinset.card = Fintype.card s", "start": [240, 1], "end": [242, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.card_univ", "code": "theorem Finset.card_univ [Fintype \u03b1] : (Finset.univ : Finset \u03b1).card = Fintype.card \u03b1", "start": [247, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_univ_of_card", "code": "theorem Finset.eq_univ_of_card [Fintype \u03b1] (s : Finset \u03b1) (hs : s.card = Fintype.card \u03b1) :\n    s = univ", "start": [251, 1], "end": [253, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_iff_eq_univ", "code": "theorem Finset.card_eq_iff_eq_univ [Fintype \u03b1] (s : Finset \u03b1) :\n    s.card = Fintype.card \u03b1 \u2194 s = Finset.univ", "start": [256, 1], "end": [260, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_univ", "code": "theorem Finset.card_le_univ [Fintype \u03b1] (s : Finset \u03b1) : s.card \u2264 Fintype.card \u03b1", "start": [263, 1], "end": [264, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.card_lt_univ_of_not_mem", "code": "theorem Finset.card_lt_univ_of_not_mem [Fintype \u03b1] {s : Finset \u03b1} {x : \u03b1} (hx : x \u2209 s) :\n    s.card < Fintype.card \u03b1", "start": [267, 1], "end": [269, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.card_lt_iff_ne_univ", "code": "theorem Finset.card_lt_iff_ne_univ [Fintype \u03b1] (s : Finset \u03b1) :\n    s.card < Fintype.card \u03b1 \u2194 s \u2260 Finset.univ", "start": [272, 1], "end": [274, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.card_compl_lt_iff_nonempty", "code": "theorem Finset.card_compl_lt_iff_nonempty [Fintype \u03b1] [DecidableEq \u03b1] (s : Finset \u03b1) :\n    s\u1d9c.card < Fintype.card \u03b1 \u2194 s.Nonempty", "start": [277, 1], "end": [279, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.card_univ_diff", "code": "theorem Finset.card_univ_diff [DecidableEq \u03b1] [Fintype \u03b1] (s : Finset \u03b1) :\n    (Finset.univ \\ s).card = Fintype.card \u03b1 - s.card", "start": [282, 1], "end": [284, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.card_compl", "code": "theorem Finset.card_compl [DecidableEq \u03b1] [Fintype \u03b1] (s : Finset \u03b1) :\n    s\u1d9c.card = Fintype.card \u03b1 - s.card", "start": [287, 1], "end": [289, 26], "kind": "commanddeclaration"}, {"full_name": "card_add_card_compl", "code": "@[simp]\ntheorem card_add_card_compl [DecidableEq \u03b1] [Fintype \u03b1] (s : Finset \u03b1) :\n    s.card + s\u1d9c.card = Fintype.card \u03b1", "start": [292, 1], "end": [295, 88], "kind": "commanddeclaration"}, {"full_name": "card_compl_add_card", "code": "@[simp]\ntheorem card_compl_add_card [DecidableEq \u03b1] [Fintype \u03b1] (s : Finset \u03b1) :\n    s\u1d9c.card + s.card = Fintype.card \u03b1", "start": [297, 1], "end": [300, 37], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_compl_set", "code": "theorem Fintype.card_compl_set [Fintype \u03b1] (s : Set \u03b1) [Fintype s] [Fintype (\u21a5s\u1d9c : Sort _)] :\n    Fintype.card (\u21a5s\u1d9c : Sort _) = Fintype.card \u03b1 - Fintype.card s", "start": [302, 1], "end": [304, 99], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_fin", "code": "@[simp]\ntheorem Fintype.card_fin (n : \u2115) : Fintype.card (Fin n) = n", "start": [307, 1], "end": [309, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_fin_lt_of_le", "code": "theorem Fintype.card_fin_lt_of_le {m n : \u2115} (h : m \u2264 n) :\n    Fintype.card {i : Fin n // i < m} = m", "start": [312, 1], "end": [319, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.card_fin", "code": "@[simp]\ntheorem Finset.card_fin (n : \u2115) : Finset.card (Finset.univ : Finset (Fin n)) = n", "start": [321, 1], "end": [323, 42], "kind": "commanddeclaration"}, {"full_name": "fin_injective", "code": "theorem fin_injective : Function.Injective Fin", "start": [326, 1], "end": [329, 101], "kind": "commanddeclaration"}, {"full_name": "Fin.cast_eq_cast'", "code": "theorem Fin.cast_eq_cast' {n m : \u2115} (h : Fin n = Fin m) :\n    _root_.cast h = Fin.cast (fin_injective h)", "start": [332, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "card_finset_fin_le", "code": "theorem card_finset_fin_le {n : \u2115} (s : Finset (Fin n)) : s.card \u2264 n", "start": [339, 1], "end": [340, 53], "kind": "commanddeclaration"}, {"full_name": "Fin.equiv_iff_eq", "code": "theorem Fin.equiv_iff_eq {m n : \u2115} : Nonempty (Fin m \u2243 Fin n) \u2194 m = n", "start": [343, 1], "end": [344, 85], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_eq", "code": "theorem Fintype.card_subtype_eq (y : \u03b1) [Fintype { x // x = y }] :\n    Fintype.card { x // x = y } = 1", "start": [348, 1], "end": [350, 22], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_eq'", "code": "theorem Fintype.card_subtype_eq' (y : \u03b1) [Fintype { x // y = x }] :\n    Fintype.card { x // y = x } = 1", "start": [354, 1], "end": [356, 22], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_empty", "code": "@[simp]\ntheorem Fintype.card_empty : Fintype.card Empty = 0", "start": [359, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_pempty", "code": "@[simp]\ntheorem Fintype.card_pempty : Fintype.card PEmpty = 0", "start": [364, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_unit", "code": "theorem Fintype.card_unit : Fintype.card Unit = 1", "start": [369, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_punit", "code": "@[simp]\ntheorem Fintype.card_punit : Fintype.card PUnit = 1", "start": [373, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_bool", "code": "@[simp]\ntheorem Fintype.card_bool : Fintype.card Bool = 2", "start": [378, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_ulift", "code": "@[simp]\ntheorem Fintype.card_ulift (\u03b1 : Type*) [Fintype \u03b1] : Fintype.card (ULift \u03b1) = Fintype.card \u03b1", "start": [383, 1], "end": [385, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_plift", "code": "@[simp]\ntheorem Fintype.card_plift (\u03b1 : Type*) [Fintype \u03b1] : Fintype.card (PLift \u03b1) = Fintype.card \u03b1", "start": [388, 1], "end": [390, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_orderDual", "code": "@[simp]\ntheorem Fintype.card_orderDual (\u03b1 : Type*) [Fintype \u03b1] : Fintype.card \u03b1\u1d52\u1d48 = Fintype.card \u03b1", "start": [393, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_lex", "code": "@[simp]\ntheorem Fintype.card_lex (\u03b1 : Type*) [Fintype \u03b1] : Fintype.card (Lex \u03b1) = Fintype.card \u03b1", "start": [398, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.sumLeft", "code": "noncomputable def Fintype.sumLeft {\u03b1 \u03b2} [Fintype (Sum \u03b1 \u03b2)] : Fintype \u03b1 :=\n  Fintype.ofInjective (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2) Sum.inl_injective", "start": [403, 1], "end": [406, 64], "kind": "commanddeclaration"}, {"full_name": "Fintype.sumRight", "code": "noncomputable def Fintype.sumRight {\u03b1 \u03b2} [Fintype (Sum \u03b1 \u03b2)] : Fintype \u03b2 :=\n  Fintype.ofInjective (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2) Sum.inr_injective", "start": [409, 1], "end": [412, 64], "kind": "commanddeclaration"}, {"full_name": "Fintype.finite", "code": "protected theorem Fintype.finite {\u03b1 : Type*} (_inst : Fintype \u03b1) : Finite \u03b1", "start": [423, 1], "end": [424, 23], "kind": "commanddeclaration"}, {"full_name": "Finite.of_fintype", "code": "instance (priority := 900) Finite.of_fintype (\u03b1 : Type*) [Fintype \u03b1] : Finite \u03b1 :=\n  Fintype.finite \u2039_\u203a", "start": [427, 1], "end": [431, 21], "kind": "commanddeclaration"}, {"full_name": "finite_iff_nonempty_fintype", "code": "theorem finite_iff_nonempty_fintype (\u03b1 : Type*) : Finite \u03b1 \u2194 Nonempty (Fintype \u03b1)", "start": [434, 1], "end": [438, 30], "kind": "commanddeclaration"}, {"full_name": "nonempty_fintype", "code": "theorem nonempty_fintype (\u03b1 : Type*) [Finite \u03b1] : Nonempty (Fintype \u03b1)", "start": [441, 1], "end": [443, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.ofFinite", "code": "noncomputable def Fintype.ofFinite (\u03b1 : Type*) [Finite \u03b1] : Fintype \u03b1 :=\n  (nonempty_fintype \u03b1).some", "start": [446, 1], "end": [449, 28], "kind": "commanddeclaration"}, {"full_name": "Finite.of_injective", "code": "theorem Finite.of_injective {\u03b1 \u03b2 : Sort*} [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) (H : Injective f) : Finite \u03b1", "start": [452, 1], "end": [456, 38], "kind": "commanddeclaration"}, {"full_name": "Finite.of_surjective", "code": "theorem Finite.of_surjective {\u03b1 \u03b2 : Sort*} [Finite \u03b1] (f : \u03b1 \u2192 \u03b2) (H : Surjective f) : Finite \u03b2", "start": [459, 1], "end": [460, 47], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_univ_list", "code": "theorem Finite.exists_univ_list (\u03b1) [Finite \u03b1] : \u2203 l : List \u03b1, l.Nodup \u2227 \u2200 x : \u03b1, x \u2208 l", "start": [463, 1], "end": [467, 34], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.length_le_card", "code": "theorem List.Nodup.length_le_card {\u03b1 : Type*} [Fintype \u03b1] {l : List \u03b1} (h : l.Nodup) :\n    l.length \u2264 Fintype.card \u03b1", "start": [470, 1], "end": [472, 74], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_of_injective", "code": "theorem card_le_of_injective (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) : card \u03b1 \u2264 card \u03b2", "start": [479, 1], "end": [480, 87], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_of_embedding", "code": "theorem card_le_of_embedding (f : \u03b1 \u21aa \u03b2) : card \u03b1 \u2264 card \u03b2", "start": [483, 1], "end": [484, 29], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_lt_of_injective_of_not_mem", "code": "theorem card_lt_of_injective_of_not_mem (f : \u03b1 \u2192 \u03b2) (h : Function.Injective f) {b : \u03b2}\n    (w : b \u2209 Set.range f) : card \u03b1 < card \u03b2", "start": [487, 1], "end": [492, 94], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_lt_of_injective_not_surjective", "code": "theorem card_lt_of_injective_not_surjective (f : \u03b1 \u2192 \u03b2) (h : Function.Injective f)\n    (h' : \u00acFunction.Surjective f) : card \u03b1 < card \u03b2", "start": [495, 1], "end": [498, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_of_surjective", "code": "theorem card_le_of_surjective (f : \u03b1 \u2192 \u03b2) (h : Function.Surjective f) : card \u03b2 \u2264 card \u03b1", "start": [501, 1], "end": [502, 56], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_range_le", "code": "theorem card_range_le {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) [Fintype \u03b1] [Fintype (Set.range f)] :\n    Fintype.card (Set.range f) \u2264 Fintype.card \u03b1", "start": [505, 1], "end": [507, 99], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_range", "code": "theorem card_range {\u03b1 \u03b2 F : Type*} [EmbeddingLike F \u03b1 \u03b2] (f : F) [Fintype \u03b1]\n    [Fintype (Set.range f)] : Fintype.card (Set.range f) = Fintype.card \u03b1", "start": [510, 1], "end": [512, 84], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_ne_map_eq_of_card_lt", "code": "theorem exists_ne_map_eq_of_card_lt (f : \u03b1 \u2192 \u03b2) (h : Fintype.card \u03b2 < Fintype.card \u03b1) :\n    \u2203 x y, x \u2260 y \u2227 f x = f y", "start": [515, 1], "end": [521, 12], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_one_iff", "code": "theorem card_eq_one_iff : card \u03b1 = 1 \u2194 \u2203 x : \u03b1, \u2200 y, y = x", "start": [524, 1], "end": [530, 35], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_zero_iff", "code": "theorem card_eq_zero_iff : card \u03b1 = 0 \u2194 IsEmpty \u03b1", "start": [533, 1], "end": [534, 52], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_zero", "code": "theorem card_eq_zero [IsEmpty \u03b1] : card \u03b1 = 0", "start": [537, 1], "end": [538, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_one_iff_nonempty_unique", "code": "theorem card_eq_one_iff_nonempty_unique : card \u03b1 = 1 \u2194 Nonempty (Unique \u03b1)", "start": [541, 1], "end": [546, 37], "kind": "commanddeclaration"}, {"full_name": "Fintype.cardEqZeroEquivEquivEmpty", "code": "def cardEqZeroEquivEquivEmpty : card \u03b1 = 0 \u2243 (\u03b1 \u2243 Empty) :=\n  (Equiv.ofIff card_eq_zero_iff).trans (Equiv.equivEmptyEquiv \u03b1).symm", "start": [549, 1], "end": [551, 70], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_pos_iff", "code": "theorem card_pos_iff : 0 < card \u03b1 \u2194 Nonempty \u03b1", "start": [554, 1], "end": [555, 91], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_pos", "code": "theorem card_pos [h : Nonempty \u03b1] : 0 < card \u03b1", "start": [558, 1], "end": [559, 21], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_ne_zero", "code": "@[simp]\ntheorem card_ne_zero [Nonempty \u03b1] : card \u03b1 \u2260 0", "start": [562, 1], "end": [564, 27], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_one_iff", "code": "theorem card_le_one_iff : card \u03b1 \u2264 1 \u2194 \u2200 a b : \u03b1, a = b", "start": [569, 1], "end": [581, 73], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_le_one_iff_subsingleton", "code": "theorem card_le_one_iff_subsingleton : card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "start": [584, 1], "end": [585, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.one_lt_card_iff_nontrivial", "code": "theorem one_lt_card_iff_nontrivial : 1 < card \u03b1 \u2194 Nontrivial \u03b1", "start": [588, 1], "end": [589, 92], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_ne_of_one_lt_card", "code": "theorem exists_ne_of_one_lt_card (h : 1 < card \u03b1) (a : \u03b1) : \u2203 b : \u03b1, b \u2260 a", "start": [592, 1], "end": [594, 14], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_pair_of_one_lt_card", "code": "theorem exists_pair_of_one_lt_card (h : 1 < card \u03b1) : \u2203 a b : \u03b1, a \u2260 b", "start": [597, 1], "end": [599, 19], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_one_of_forall_eq", "code": "theorem card_eq_one_of_forall_eq {i : \u03b1} (h : \u2200 j, j = i) : card \u03b1 = 1", "start": [602, 1], "end": [603, 35], "kind": "commanddeclaration"}, {"full_name": "Fintype.exists_unique_iff_card_one", "code": "theorem exists_unique_iff_card_one {\u03b1} [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    (\u2203! a : \u03b1, p a) \u2194 (Finset.univ.filter p).card = 1", "start": [606, 1], "end": [611, 48], "kind": "commanddeclaration"}, {"full_name": "Fintype.one_lt_card", "code": "theorem one_lt_card [h : Nontrivial \u03b1] : 1 < Fintype.card \u03b1", "start": [613, 1], "end": [614, 43], "kind": "commanddeclaration"}, {"full_name": "Fintype.one_lt_card_iff", "code": "theorem one_lt_card_iff : 1 < card \u03b1 \u2194 \u2203 a b : \u03b1, a \u2260 b", "start": [617, 1], "end": [618, 50], "kind": "commanddeclaration"}, {"full_name": "Fintype.two_lt_card_iff", "code": "nonrec theorem two_lt_card_iff : 2 < card \u03b1 \u2194 \u2203 a b c : \u03b1, a \u2260 b \u2227 a \u2260 c \u2227 b \u2260 c", "start": [621, 1], "end": [622, 72], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_of_bijective", "code": "theorem card_of_bijective {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) : card \u03b1 = card \u03b2", "start": [625, 1], "end": [626, 38], "kind": "commanddeclaration"}, {"full_name": "Finite.surjective_of_injective", "code": "theorem surjective_of_injective {f : \u03b1 \u2192 \u03b1} (hinj : Injective f) : Surjective f", "start": [636, 1], "end": [645, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.injective_iff_surjective", "code": "theorem injective_iff_surjective {f : \u03b1 \u2192 \u03b1} : Injective f \u2194 Surjective f", "start": [647, 1], "end": [651, 33], "kind": "commanddeclaration"}, {"full_name": "Finite.injective_iff_bijective", "code": "theorem injective_iff_bijective {f : \u03b1 \u2192 \u03b1} : Injective f \u2194 Bijective f", "start": [654, 1], "end": [655, 45], "kind": "commanddeclaration"}, {"full_name": "Finite.surjective_iff_bijective", "code": "theorem surjective_iff_bijective {f : \u03b1 \u2192 \u03b1} : Surjective f \u2194 Bijective f", "start": [658, 1], "end": [659, 45], "kind": "commanddeclaration"}, {"full_name": "Finite.injective_iff_surjective_of_equiv", "code": "theorem injective_iff_surjective_of_equiv {f : \u03b1 \u2192 \u03b2} (e : \u03b1 \u2243 \u03b2) : Injective f \u2194 Surjective f", "start": [662, 1], "end": [667, 90], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.bijective_of_finite", "code": "alias \u27e8_root_.Function.Injective.bijective_of_finite, _\u27e9 := injective_iff_bijective", "start": [670, 1], "end": [670, 84], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Function.Surjective.bijective_of_finite", "code": "alias \u27e8_root_.Function.Surjective.bijective_of_finite, _\u27e9 := surjective_iff_bijective", "start": [673, 1], "end": [673, 86], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Function.Injective.surjective_of_fintype", "code": "alias \u27e8_root_.Function.Injective.surjective_of_fintype,\n    _root_.Function.Surjective.injective_of_fintype\u27e9 :=\n  injective_iff_surjective_of_equiv", "start": [676, 1], "end": [678, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Function.Surjective.injective_of_fintype", "code": "alias \u27e8_root_.Function.Injective.surjective_of_fintype,\n    _root_.Function.Surjective.injective_of_fintype\u27e9 :=\n  injective_iff_surjective_of_equiv", "start": [676, 1], "end": [678, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Fintype.bijective_iff_injective_and_card", "code": "theorem bijective_iff_injective_and_card (f : \u03b1 \u2192 \u03b2) :\n    Bijective f \u2194 Injective f \u2227 card \u03b1 = card \u03b2", "start": [688, 1], "end": [691, 59], "kind": "commanddeclaration"}, {"full_name": "Fintype.bijective_iff_surjective_and_card", "code": "theorem bijective_iff_surjective_and_card (f : \u03b1 \u2192 \u03b2) :\n    Bijective f \u2194 Surjective f \u2227 card \u03b1 = card \u03b2", "start": [694, 1], "end": [697, 58], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.rightInverse_of_card_le", "code": "theorem _root_.Function.LeftInverse.rightInverse_of_card_le {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (hfg : LeftInverse f g) (hcard : card \u03b1 \u2264 card \u03b2) : RightInverse f g", "start": [700, 1], "end": [706, 8], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.leftInverse_of_card_le", "code": "theorem _root_.Function.RightInverse.leftInverse_of_card_le {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (hfg : RightInverse f g) (hcard : card \u03b2 \u2264 card \u03b1) : LeftInverse f g", "start": [709, 1], "end": [711, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofLeftInverseOfCardLE", "code": "@[simps]\ndef ofLeftInverseOfCardLE (h\u03b2\u03b1 : card \u03b2 \u2264 card \u03b1) (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) (h : LeftInverse g f) :\n    \u03b1 \u2243 \u03b2 where\n  toFun := f\n  invFun := g\n  left_inv := h\n  right_inv := h.rightInverse_of_card_le h\u03b2\u03b1", "start": [722, 1], "end": [729, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofRightInverseOfCardLE", "code": "@[simps]\ndef ofRightInverseOfCardLE (h\u03b1\u03b2 : card \u03b1 \u2264 card \u03b2) (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) (h : RightInverse g f) :\n    \u03b1 \u2243 \u03b2 where\n  toFun := f\n  invFun := g\n  left_inv := h.leftInverse_of_card_le h\u03b1\u03b2\n  right_inv := h", "start": [734, 1], "end": [741, 17], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_coe", "code": "@[simp]\ntheorem Fintype.card_coe (s : Finset \u03b1) [Fintype s] : Fintype.card s = s.card", "start": [748, 1], "end": [750, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.equivFin", "code": "noncomputable def Finset.equivFin (s : Finset \u03b1) : s \u2243 Fin s.card :=\n  Fintype.equivFinOfCardEq (Fintype.card_coe _)", "start": [753, 1], "end": [755, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.equivFinOfCardEq", "code": "noncomputable def Finset.equivFinOfCardEq {s : Finset \u03b1} {n : \u2115} (h : s.card = n) : s \u2243 Fin n :=\n  Fintype.equivFinOfCardEq ((Fintype.card_coe _).trans h)", "start": [758, 1], "end": [761, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.equivOfCardEq", "code": "noncomputable def Finset.equivOfCardEq {s t : Finset \u03b1} (h : s.card = t.card) : s \u2243 t :=\n  Fintype.equivOfCardEq ((Fintype.card_coe _).trans (h.trans (Fintype.card_coe _).symm))", "start": [764, 1], "end": [767, 89], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_prop", "code": "@[simp]\ntheorem Fintype.card_prop : Fintype.card Prop = 2", "start": [770, 1], "end": [772, 6], "kind": "commanddeclaration"}, {"full_name": "set_fintype_card_le_univ", "code": "theorem set_fintype_card_le_univ [Fintype \u03b1] (s : Set \u03b1) [Fintype s] :\n    Fintype.card s \u2264 Fintype.card \u03b1", "start": [775, 1], "end": [777, 62], "kind": "commanddeclaration"}, {"full_name": "set_fintype_card_eq_univ_iff", "code": "theorem set_fintype_card_eq_univ_iff [Fintype \u03b1] (s : Set \u03b1) [Fintype s] :\n    Fintype.card s = Fintype.card \u03b1 \u2194 s = Set.univ", "start": [780, 1], "end": [782, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.equivOfFintypeSelfEmbedding", "code": "noncomputable def equivOfFintypeSelfEmbedding [Finite \u03b1] (e : \u03b1 \u21aa \u03b1) : \u03b1 \u2243 \u03b1 :=\n  Equiv.ofBijective e e.2.bijective_of_finite", "start": [787, 1], "end": [789, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.equiv_of_fintype_self_embedding_to_embedding", "code": "@[simp]\ntheorem equiv_of_fintype_self_embedding_to_embedding [Finite \u03b1] (e : \u03b1 \u21aa \u03b1) :\n    e.equivOfFintypeSelfEmbedding.toEmbedding = e", "start": [792, 1], "end": [796, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.isEmpty_of_card_lt", "code": "@[simp]\ntheorem isEmpty_of_card_lt [Fintype \u03b1] [Fintype \u03b2] (h : Fintype.card \u03b2 < Fintype.card \u03b1) :\n    IsEmpty (\u03b1 \u21aa \u03b2)", "start": [799, 1], "end": [808, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.truncOfCardLE", "code": "def truncOfCardLE [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b1] [DecidableEq \u03b2]\n    (h : Fintype.card \u03b1 \u2264 Fintype.card \u03b2) : Trunc (\u03b1 \u21aa \u03b2) :=\n  (Fintype.truncEquivFin \u03b1).bind fun ea =>\n    (Fintype.truncEquivFin \u03b2).map fun eb =>\n      ea.toEmbedding.trans ((Fin.castLEEmb h).toEmbedding.trans eb.symm.toEmbedding)", "start": [811, 1], "end": [816, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.nonempty_of_card_le", "code": "theorem nonempty_of_card_le [Fintype \u03b1] [Fintype \u03b2] (h : Fintype.card \u03b1 \u2264 Fintype.card \u03b2) :\n    Nonempty (\u03b1 \u21aa \u03b2)", "start": [819, 1], "end": [820, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.nonempty_iff_card_le", "code": "theorem nonempty_iff_card_le [Fintype \u03b1] [Fintype \u03b2] :\n    Nonempty (\u03b1 \u21aa \u03b2) \u2194 Fintype.card \u03b1 \u2264 Fintype.card \u03b2", "start": [823, 1], "end": [825, 67], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.exists_of_card_le_finset", "code": "theorem exists_of_card_le_finset [Fintype \u03b1] {s : Finset \u03b2} (h : Fintype.card \u03b1 \u2264 s.card) :\n    \u2203 f : \u03b1 \u21aa \u03b2, Set.range f \u2286 s", "start": [828, 1], "end": [832, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_map_embedding", "code": "@[simp]\ntheorem Finset.univ_map_embedding {\u03b1 : Type*} [Fintype \u03b1] (e : \u03b1 \u21aa \u03b1) : univ.map e = univ", "start": [837, 1], "end": [839, 85], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_lt_of_surjective_not_injective", "code": "theorem card_lt_of_surjective_not_injective [Fintype \u03b1] [Fintype \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : Function.Surjective f) (h' : \u00acFunction.Injective f) : card \u03b2 < card \u03b1", "start": [844, 1], "end": [848, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_le", "code": "theorem Fintype.card_subtype_le [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Fintype.card { x // p x } \u2264 Fintype.card \u03b1", "start": [853, 1], "end": [855, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_lt", "code": "theorem Fintype.card_subtype_lt [Fintype \u03b1] {p : \u03b1 \u2192 Prop} [DecidablePred p] {x : \u03b1} (hx : \u00acp x) :\n    Fintype.card { x // p x } < Fintype.card \u03b1", "start": [858, 1], "end": [861, 36], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype", "code": "theorem Fintype.card_subtype [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Fintype.card { x // p x } = ((Finset.univ : Finset \u03b1).filter p).card", "start": [864, 1], "end": [867, 7], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_compl", "code": "@[simp]\ntheorem Fintype.card_subtype_compl [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [Fintype { x // p x }]\n    [Fintype { x // \u00acp x }] :\n    Fintype.card { x // \u00acp x } = Fintype.card \u03b1 - Fintype.card { x // p x }", "start": [870, 1], "end": [878, 69], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_mono", "code": "theorem Fintype.card_subtype_mono (p q : \u03b1 \u2192 Prop) (h : p \u2264 q) [Fintype { x // p x }]\n    [Fintype { x // q x }] : Fintype.card { x // p x } \u2264 Fintype.card { x // q x }", "start": [881, 1], "end": [883, 60], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_compl_eq_card_compl", "code": "theorem Fintype.card_compl_eq_card_compl [Finite \u03b1] (p q : \u03b1 \u2192 Prop) [Fintype { x // p x }]\n    [Fintype { x // \u00acp x }] [Fintype { x // q x }] [Fintype { x // \u00acq x }]\n    (h : Fintype.card { x // p x } = Fintype.card { x // q x }) :\n    Fintype.card { x // \u00acp x } = Fintype.card { x // \u00acq x }", "start": [886, 1], "end": [892, 44], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_quotient_le", "code": "theorem Fintype.card_quotient_le [Fintype \u03b1] (s : Setoid \u03b1)\n    [DecidableRel ((\u00b7 \u2248 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] : Fintype.card (Quotient s) \u2264 Fintype.card \u03b1", "start": [895, 1], "end": [897, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_quotient_lt", "code": "theorem Fintype.card_quotient_lt [Fintype \u03b1] {s : Setoid \u03b1} [DecidableRel ((\u00b7 \u2248 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    {x y : \u03b1} (h1 : x \u2260 y) (h2 : x \u2248 y) : Fintype.card (Quotient s) < Fintype.card \u03b1", "start": [900, 1], "end": [903, 33], "kind": "commanddeclaration"}, {"full_name": "univ_eq_singleton_of_card_one", "code": "theorem univ_eq_singleton_of_card_one {\u03b1} [Fintype \u03b1] (x : \u03b1) (h : Fintype.card \u03b1 = 1) :\n    (univ : Finset \u03b1) = {x}", "start": [906, 1], "end": [911, 29], "kind": "commanddeclaration"}, {"full_name": "Finite.wellFounded_of_trans_of_irrefl", "code": "theorem wellFounded_of_trans_of_irrefl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] [IsIrrefl \u03b1 r] :\n    WellFounded r", "start": [918, 1], "end": [931, 49], "kind": "commanddeclaration"}, {"full_name": "Finite.to_wellFoundedLT", "code": "instance (priority := 100) to_wellFoundedLT [Preorder \u03b1] : WellFoundedLT \u03b1 :=\n  \u27e8wellFounded_of_trans_of_irrefl _\u27e9", "start": [935, 1], "end": [936, 37], "kind": "commanddeclaration"}, {"full_name": "Finite.to_wellFoundedGT", "code": "instance (priority := 100) to_wellFoundedGT [Preorder \u03b1] : WellFoundedGT \u03b1 :=\n  \u27e8wellFounded_of_trans_of_irrefl _\u27e9", "start": [940, 1], "end": [941, 37], "kind": "commanddeclaration"}, {"full_name": "Finite.LinearOrder.isWellOrder_lt", "code": "instance (priority := 10) LinearOrder.isWellOrder_lt [LinearOrder \u03b1] : IsWellOrder \u03b1 (\u00b7 < \u00b7) := {}", "start": [944, 1], "end": [944, 99], "kind": "commanddeclaration"}, {"full_name": "Finite.LinearOrder.isWellOrder_gt", "code": "instance (priority := 10) LinearOrder.isWellOrder_gt [LinearOrder \u03b1] : IsWellOrder \u03b1 (\u00b7 > \u00b7) := {}", "start": [947, 1], "end": [947, 99], "kind": "commanddeclaration"}, {"full_name": "Fintype.false", "code": "protected theorem Fintype.false [Infinite \u03b1] (_h : Fintype \u03b1) : False", "start": [953, 1], "end": [954, 15], "kind": "commanddeclaration"}, {"full_name": "isEmpty_fintype", "code": "@[simp]\ntheorem isEmpty_fintype {\u03b1 : Type*} : IsEmpty (Fintype \u03b1) \u2194 Infinite \u03b1", "start": [957, 1], "end": [959, 95], "kind": "commanddeclaration"}, {"full_name": "fintypeOfNotInfinite", "code": "noncomputable def fintypeOfNotInfinite {\u03b1 : Type*} (h : \u00acInfinite \u03b1) : Fintype \u03b1 :=\n  @Fintype.ofFinite _ (not_infinite_iff_finite.mp h)", "start": [962, 1], "end": [964, 53], "kind": "commanddeclaration"}, {"full_name": "fintypeOrInfinite", "code": "noncomputable def fintypeOrInfinite (\u03b1 : Type*) : PSum (Fintype \u03b1) (Infinite \u03b1) :=\n  if h : Infinite \u03b1 then PSum.inr h else PSum.inl (fintypeOfNotInfinite h)", "start": [971, 1], "end": [976, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_minimal", "code": "theorem Finset.exists_minimal {\u03b1 : Type*} [Preorder \u03b1] (s : Finset \u03b1) (h : s.Nonempty) :\n    \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acx < m", "start": [981, 1], "end": [986, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_maximal", "code": "theorem Finset.exists_maximal {\u03b1 : Type*} [Preorder \u03b1] (s : Finset \u03b1) (h : s.Nonempty) :\n    \u2203 m \u2208 s, \u2200 x \u2208 s, \u00acm < x", "start": [989, 1], "end": [991, 35], "kind": "commanddeclaration"}, {"full_name": "Infinite.of_not_fintype", "code": "theorem of_not_fintype (h : Fintype \u03b1 \u2192 False) : Infinite \u03b1", "start": [996, 1], "end": [997, 25], "kind": "commanddeclaration"}, {"full_name": "Infinite.of_injective_to_set", "code": "theorem of_injective_to_set {s : Set \u03b1} (hs : s \u2260 Set.univ) {f : \u03b1 \u2192 s} (hf : Injective f) :\n    Infinite \u03b1", "start": [1000, 1], "end": [1010, 90], "kind": "commanddeclaration"}, {"full_name": "Infinite.of_surjective_from_set", "code": "theorem of_surjective_from_set {s : Set \u03b1} (hs : s \u2260 Set.univ) {f : s \u2192 \u03b1} (hf : Surjective f) :\n    Infinite \u03b1", "start": [1013, 1], "end": [1016, 48], "kind": "commanddeclaration"}, {"full_name": "Infinite.exists_not_mem_finset", "code": "theorem exists_not_mem_finset [Infinite \u03b1] (s : Finset \u03b1) : \u2203 x, x \u2209 s", "start": [1019, 1], "end": [1020, 45], "kind": "commanddeclaration"}, {"full_name": "Infinite.nonempty", "code": "protected theorem nonempty (\u03b1 : Type*) [Infinite \u03b1] : Nonempty \u03b1", "start": [1029, 1], "end": [1029, 86], "kind": "commanddeclaration"}, {"full_name": "Infinite.of_injective", "code": "theorem of_injective {\u03b1 \u03b2} [Infinite \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) : Infinite \u03b1", "start": [1032, 1], "end": [1033, 47], "kind": "commanddeclaration"}, {"full_name": "Infinite.of_surjective", "code": "theorem of_surjective {\u03b1 \u03b2} [Infinite \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) : Infinite \u03b1", "start": [1036, 1], "end": [1037, 48], "kind": "commanddeclaration"}, {"full_name": "Int.infinite", "code": "instance Int.infinite : Infinite \u2124 :=\n  Infinite.of_injective Int.ofNat fun _ _ => Int.ofNat.inj", "start": [1047, 1], "end": [1048, 59], "kind": "commanddeclaration"}, {"full_name": "String.infinite", "code": "instance String.infinite : Infinite String :=\n  Infinite.of_injective (String.mk) <| by\n    intro _ _ h\n    cases h with\n    | refl => rfl", "start": [1057, 1], "end": [1061, 18], "kind": "commanddeclaration"}, {"full_name": "Infinite.set", "code": "instance Infinite.set [Infinite \u03b1] : Infinite (Set \u03b1) :=\n  Infinite.of_injective singleton Set.singleton_injective", "start": [1063, 1], "end": [1064, 58], "kind": "commanddeclaration"}, {"full_name": "Sum.infinite_of_left", "code": "instance Sum.infinite_of_left [Infinite \u03b1] : Infinite (Sum \u03b1 \u03b2) :=\n  Infinite.of_injective Sum.inl Sum.inl_injective", "start": [1073, 1], "end": [1074, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.infinite_of_right", "code": "instance Sum.infinite_of_right [Infinite \u03b2] : Infinite (Sum \u03b1 \u03b2) :=\n  Infinite.of_injective Sum.inr Sum.inr_injective", "start": [1077, 1], "end": [1078, 50], "kind": "commanddeclaration"}, {"full_name": "Prod.infinite_of_right", "code": "instance Prod.infinite_of_right [Nonempty \u03b1] [Infinite \u03b2] : Infinite (\u03b1 \u00d7 \u03b2) :=\n  Infinite.of_surjective Prod.snd Prod.snd_surjective", "start": [1081, 1], "end": [1082, 54], "kind": "commanddeclaration"}, {"full_name": "Prod.infinite_of_left", "code": "instance Prod.infinite_of_left [Infinite \u03b1] [Nonempty \u03b2] : Infinite (\u03b1 \u00d7 \u03b2) :=\n  Infinite.of_surjective Prod.fst Prod.fst_surjective", "start": [1085, 1], "end": [1086, 54], "kind": "commanddeclaration"}, {"full_name": "instInfiniteProdSubtypeCommute", "code": "instance instInfiniteProdSubtypeCommute [Mul \u03b1] [Infinite \u03b1] :\n    Infinite { p : \u03b1 \u00d7 \u03b1 // Commute p.1 p.2 } :=\n  Infinite.of_injective (fun a => \u27e8\u27e8a, a\u27e9, rfl\u27e9) (by intro; simp)", "start": [1089, 1], "end": [1091, 66], "kind": "commanddeclaration"}, {"full_name": "Infinite.natEmbeddingAux", "code": "private noncomputable def natEmbeddingAux (\u03b1 : Type*) [Infinite \u03b1] : \u2115 \u2192 \u03b1\n  | n =>\n    letI := Classical.decEq \u03b1\n    Classical.choose\n      (exists_not_mem_finset\n        ((Multiset.range n).pmap (fun m (hm : m < n) => natEmbeddingAux _ m) fun _ =>\n            Multiset.mem_range.1).toFinset)", "start": [1095, 1], "end": [1101, 44], "kind": "commanddeclaration"}, {"full_name": "Infinite.natEmbeddingAux_injective_aux", "code": "private theorem natEmbeddingAux_injective_aux (\u03b1 : Type*) [Infinite \u03b1] (m n : \u2115)\n  (h : Infinite.natEmbeddingAux \u03b1 m = Infinite.natEmbeddingAux \u03b1 n) (hmn : m < n) : m = n", "start": [1104, 1], "end": [1115, 26], "kind": "commanddeclaration"}, {"full_name": "Infinite.natEmbeddingAux_injective", "code": "private theorem natEmbeddingAux_injective (\u03b1 : Type*) [Infinite \u03b1] :\n    Function.Injective (natEmbeddingAux \u03b1)", "start": [1117, 1], "end": [1124, 64], "kind": "commanddeclaration"}, {"full_name": "Infinite.natEmbedding", "code": "noncomputable def natEmbedding (\u03b1 : Type*) [Infinite \u03b1] : \u2115 \u21aa \u03b1 :=\n  \u27e8_, natEmbeddingAux_injective \u03b1\u27e9", "start": [1126, 1], "end": [1128, 35], "kind": "commanddeclaration"}, {"full_name": "Infinite.exists_subset_card_eq", "code": "theorem exists_subset_card_eq (\u03b1 : Type*) [Infinite \u03b1] (n : \u2115) : \u2203 s : Finset \u03b1, s.card = n", "start": [1131, 1], "end": [1134, 65], "kind": "commanddeclaration"}, {"full_name": "Infinite.exists_superset_card_eq", "code": "theorem exists_superset_card_eq [Infinite \u03b1] (s : Finset \u03b1) (n : \u2115) (hn : s.card \u2264 n) :\n    \u2203 t : Finset \u03b1, s \u2286 t \u2227 t.card = n", "start": [1137, 1], "end": [1148, 18], "kind": "commanddeclaration"}, {"full_name": "fintypeOfFinsetCardLe", "code": "noncomputable def fintypeOfFinsetCardLe {\u03b9 : Type*} (n : \u2115) (w : \u2200 s : Finset \u03b9, s.card \u2264 n) :\n    Fintype \u03b9 := by\n  apply fintypeOfNotInfinite\n  intro i\n  obtain \u27e8s, c\u27e9 := Infinite.exists_subset_card_eq \u03b9 (n + 1)\n  specialize w s\n  rw [c] at w\n  exact Nat.not_succ_le_self n w", "start": [1153, 1], "end": [1161, 33], "kind": "commanddeclaration"}, {"full_name": "not_injective_infinite_finite", "code": "theorem not_injective_infinite_finite {\u03b1 \u03b2} [Infinite \u03b1] [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) : \u00acInjective f", "start": [1164, 1], "end": [1165, 45], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_ne_map_eq_of_infinite", "code": "theorem Finite.exists_ne_map_eq_of_infinite {\u03b1 \u03b2} [Infinite \u03b1] [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    \u2203 x y : \u03b1, x \u2260 y \u2227 f x = f y", "start": [1168, 1], "end": [1176, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.is_empty", "code": "instance Function.Embedding.is_empty {\u03b1 \u03b2} [Infinite \u03b1] [Finite \u03b2] : IsEmpty (\u03b1 \u21aa \u03b2) :=\n  \u27e8fun f => not_injective_infinite_finite f f.2\u27e9", "start": [1179, 1], "end": [1180, 49], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_infinite_fiber", "code": "theorem Finite.exists_infinite_fiber [Infinite \u03b1] [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    \u2203 y : \u03b2, Infinite (f \u207b\u00b9' {y})", "start": [1183, 1], "end": [1199, 20], "kind": "commanddeclaration"}, {"full_name": "not_surjective_finite_infinite", "code": "theorem not_surjective_finite_infinite {\u03b1 \u03b2} [Finite \u03b1] [Infinite \u03b2] (f : \u03b1 \u2192 \u03b2) : \u00acSurjective f", "start": [1202, 1], "end": [1203, 57], "kind": "commanddeclaration"}, {"full_name": "truncOfCardPos", "code": "def truncOfCardPos {\u03b1} [Fintype \u03b1] (h : 0 < Fintype.card \u03b1) : Trunc \u03b1 :=\n  letI := Fintype.card_pos_iff.mp h\n  truncOfNonemptyFintype \u03b1", "start": [1208, 1], "end": [1212, 27], "kind": "commanddeclaration"}, {"full_name": "Fintype.induction_subsingleton_or_nontrivial", "code": "@[elab_as_elim]\ntheorem Fintype.induction_subsingleton_or_nontrivial {P : \u2200 (\u03b1) [Fintype \u03b1], Prop} (\u03b1 : Type*)\n    [Fintype \u03b1] (hbase : \u2200 (\u03b1) [Fintype \u03b1] [Subsingleton \u03b1], P \u03b1)\n    (hstep :\n      \u2200 (\u03b1) [Fintype \u03b1] [Nontrivial \u03b1],\n        \u2200 _ih : \u2200 (\u03b2) [Fintype \u03b2], \u2200 _h : Fintype.card \u03b2 < Fintype.card \u03b1, P \u03b2, P \u03b1) :\n    P \u03b1", "start": [1217, 1], "end": [1238, 40], "kind": "commanddeclaration"}, {"full_name": "Tactic.card_univ_pos", "code": "private theorem card_univ_pos (\u03b1 : Type*) [Fintype \u03b1] [Nonempty \u03b1] :\n    0 < (Finset.univ : Finset \u03b1).card", "start": [1245, 1], "end": [1247, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Powerset.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Multiset/Powerset.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.powerset", "code": "def powerset (s : Finset \u03b1) : Finset (Finset \u03b1) :=\n  \u27e8(s.1.powerset.pmap Finset.mk) fun _t h => nodup_of_le (mem_powerset.1 h) s.nodup,\n    s.nodup.powerset.pmap fun _a _ha _b _hb => congr_arg Finset.val\u27e9", "start": [27, 1], "end": [30, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_powerset", "code": "@[simp]\ntheorem mem_powerset {s t : Finset \u03b1} : s \u2208 powerset t \u2194 s \u2286 t", "start": [33, 1], "end": [37, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_powerset", "code": "@[simp, norm_cast]\ntheorem coe_powerset (s : Finset \u03b1) :\n    (s.powerset : Set (Finset \u03b1)) = ((\u2191) : Finset \u03b1 \u2192 Set \u03b1) \u207b\u00b9' (s : Set \u03b1).powerset", "start": [40, 1], "end": [44, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_mem_powerset", "code": "theorem empty_mem_powerset (s : Finset \u03b1) : \u2205 \u2208 powerset s", "start": [48, 1], "end": [49, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_powerset_self", "code": "theorem mem_powerset_self (s : Finset \u03b1) : s \u2208 powerset s", "start": [53, 1], "end": [54, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_nonempty", "code": "theorem powerset_nonempty (s : Finset \u03b1) : s.powerset.Nonempty", "start": [57, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_mono", "code": "@[simp]\ntheorem powerset_mono {s t : Finset \u03b1} : powerset s \u2286 powerset t \u2194 s \u2286 t", "start": [61, 1], "end": [64, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_injective", "code": "theorem powerset_injective : Injective (powerset : Finset \u03b1 \u2192 Finset (Finset \u03b1))", "start": [67, 1], "end": [68, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_inj", "code": "@[simp]\ntheorem powerset_inj : powerset s = powerset t \u2194 s = t", "start": [71, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_empty", "code": "@[simp]\ntheorem powerset_empty : (\u2205 : Finset \u03b1).powerset = {\u2205}", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_eq_singleton_empty", "code": "@[simp]\ntheorem powerset_eq_singleton_empty : s.powerset = {\u2205} \u2194 s = \u2205", "start": [81, 1], "end": [83, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.card_powerset", "code": "@[simp]\ntheorem card_powerset (s : Finset \u03b1) : card (powerset s) = 2 ^ card s", "start": [86, 1], "end": [89, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_of_mem_powerset_of_not_mem", "code": "theorem not_mem_of_mem_powerset_of_not_mem {s t : Finset \u03b1} {a : \u03b1} (ht : t \u2208 s.powerset)\n    (h : a \u2209 s) : a \u2209 t", "start": [92, 1], "end": [95, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_insert", "code": "theorem powerset_insert [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) :\n    powerset (insert a s) = s.powerset \u222a s.powerset.image (insert a)", "start": [98, 1], "end": [112, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableExistsOfDecidableSubsets", "code": "instance decidableExistsOfDecidableSubsets {s : Finset \u03b1} {p : \u2200 (t) (_ : t \u2286 s), Prop}\n    [\u2200 (t) (h : t \u2286 s), Decidable (p t h)] : Decidable (\u2203 (t : _) (h : t \u2286 s), p t h) :=\n  decidable_of_iff (\u2203 (t : _) (hs : t \u2208 s.powerset), p t (mem_powerset.1 hs))\n    \u27e8fun \u27e8t, _, hp\u27e9 => \u27e8t, _, hp\u27e9, fun \u27e8t, hs, hp\u27e9 => \u27e8t, mem_powerset.2 hs, hp\u27e9\u27e9", "start": [115, 1], "end": [119, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableForallOfDecidableSubsets", "code": "instance decidableForallOfDecidableSubsets {s : Finset \u03b1} {p : \u2200 (t) (_ : t \u2286 s), Prop}\n    [\u2200 (t) (h : t \u2286 s), Decidable (p t h)] : Decidable (\u2200 (t) (h : t \u2286 s), p t h) :=\n  decidable_of_iff (\u2200 (t) (h : t \u2208 s.powerset), p t (mem_powerset.1 h))\n    \u27e8fun h t hs => h t (mem_powerset.2 hs), fun h _ _ => h _ _\u27e9", "start": [122, 1], "end": [126, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableExistsOfDecidableSubsets'", "code": "def decidableExistsOfDecidableSubsets' {s : Finset \u03b1} {p : Finset \u03b1 \u2192 Prop}\n    (hu : \u2200 (t) (_h : t \u2286 s), Decidable (p t)) : Decidable (\u2203 (t : _) (_h : t \u2286 s), p t) :=\n  @Finset.decidableExistsOfDecidableSubsets _ _ _ hu", "start": [129, 1], "end": [133, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableForallOfDecidableSubsets'", "code": "def decidableForallOfDecidableSubsets' {s : Finset \u03b1} {p : Finset \u03b1 \u2192 Prop}\n    (hu : \u2200 (t) (_h : t \u2286 s), Decidable (p t)) : Decidable (\u2200 (t) (_h : t \u2286 s), p t) :=\n  @Finset.decidableForallOfDecidableSubsets _ _ _ hu", "start": [136, 1], "end": [140, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.ssubsets", "code": "def ssubsets (s : Finset \u03b1) : Finset (Finset \u03b1) :=\n  erase (powerset s) s", "start": [149, 1], "end": [151, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_ssubsets", "code": "@[simp]\ntheorem mem_ssubsets {s t : Finset \u03b1} : t \u2208 s.ssubsets \u2194 t \u2282 s", "start": [154, 1], "end": [156, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_mem_ssubsets", "code": "theorem empty_mem_ssubsets {s : Finset \u03b1} (h : s.Nonempty) : \u2205 \u2208 s.ssubsets", "start": [159, 1], "end": [161, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableExistsOfDecidableSSubsets", "code": "instance decidableExistsOfDecidableSSubsets {s : Finset \u03b1} {p : \u2200 (t) (_ : t \u2282 s), Prop}\n    [\u2200 (t) (h : t \u2282 s), Decidable (p t h)] : Decidable (\u2203 t h, p t h) :=\n  decidable_of_iff (\u2203 (t : _) (hs : t \u2208 s.ssubsets), p t (mem_ssubsets.1 hs))\n    \u27e8fun \u27e8t, _, hp\u27e9 => \u27e8t, _, hp\u27e9, fun \u27e8t, hs, hp\u27e9 => \u27e8t, mem_ssubsets.2 hs, hp\u27e9\u27e9", "start": [163, 1], "end": [167, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableForallOfDecidableSSubsets", "code": "instance decidableForallOfDecidableSSubsets {s : Finset \u03b1} {p : \u2200 (t) (_ : t \u2282 s), Prop}\n    [\u2200 (t) (h : t \u2282 s), Decidable (p t h)] : Decidable (\u2200 t h, p t h) :=\n  decidable_of_iff (\u2200 (t) (h : t \u2208 s.ssubsets), p t (mem_ssubsets.1 h))\n    \u27e8fun h t hs => h t (mem_ssubsets.2 hs), fun h _ _ => h _ _\u27e9", "start": [170, 1], "end": [174, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableExistsOfDecidableSSubsets'", "code": "def decidableExistsOfDecidableSSubsets' {s : Finset \u03b1} {p : Finset \u03b1 \u2192 Prop}\n    (hu : \u2200 (t) (_h : t \u2282 s), Decidable (p t)) : Decidable (\u2203 (t : _) (_h : t \u2282 s), p t) :=\n  @Finset.decidableExistsOfDecidableSSubsets _ _ _ _ hu", "start": [177, 1], "end": [181, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.decidableForallOfDecidableSSubsets'", "code": "def decidableForallOfDecidableSSubsets' {s : Finset \u03b1} {p : Finset \u03b1 \u2192 Prop}\n    (hu : \u2200 (t) (_h : t \u2282 s), Decidable (p t)) : Decidable (\u2200 (t) (_h : t \u2282 s), p t) :=\n  @Finset.decidableForallOfDecidableSSubsets _ _ _ _ hu", "start": [184, 1], "end": [188, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard", "code": "def powersetCard (n : \u2115) (s : Finset \u03b1) : Finset (Finset \u03b1) :=\n  \u27e8((s.1.powersetCard n).pmap Finset.mk) fun _t h => nodup_of_le (mem_powersetCard.1 h).1 s.2,\n    s.2.powersetCard.pmap fun _a _ha _b _hb => congr_arg Finset.val\u27e9", "start": [195, 1], "end": [199, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_powersetCard", "code": "theorem mem_powersetCard {n} {s t : Finset \u03b1} : s \u2208 powersetCard n t \u2194 s \u2286 t \u2227 card s = n", "start": [202, 1], "end": [204, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_mono", "code": "@[simp]\ntheorem powersetCard_mono {n} {s t : Finset \u03b1} (h : s \u2286 t) : powersetCard n s \u2286 powersetCard n t", "start": [207, 1], "end": [210, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.card_powersetCard", "code": "@[simp]\ntheorem card_powersetCard (n : \u2115) (s : Finset \u03b1) :\n    card (powersetCard n s) = Nat.choose (card s) n", "start": [213, 1], "end": [217, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_zero", "code": "@[simp]\ntheorem powersetCard_zero (s : Finset \u03b1) : Finset.powersetCard 0 s = {\u2205}", "start": [220, 1], "end": [226, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_empty", "code": "@[simp]\ntheorem powersetCard_empty (n : \u2115) {s : Finset \u03b1} (h : s.card < n) : powersetCard n s = \u2205", "start": [229, 1], "end": [231, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_eq_filter", "code": "theorem powersetCard_eq_filter {n} {s : Finset \u03b1} :\n    powersetCard n s = (powerset s).filter fun x => x.card = n", "start": [234, 1], "end": [237, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_succ_insert", "code": "theorem powersetCard_succ_insert [DecidableEq \u03b1] {x : \u03b1} {s : Finset \u03b1} (h : x \u2209 s) (n : \u2115) :\n    powersetCard n.succ (insert x s) =\n    powersetCard n.succ s \u222a (powersetCard n s).image (insert x)", "start": [240, 1], "end": [251, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_nonempty", "code": "theorem powersetCard_nonempty {n : \u2115} {s : Finset \u03b1} (h : n \u2264 s.card) :\n    (powersetCard n s).Nonempty", "start": [254, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_self", "code": "@[simp]\ntheorem powersetCard_self (s : Finset \u03b1) : powersetCard s.card s = {s}", "start": [269, 1], "end": [276, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwise_disjoint_powersetCard", "code": "theorem pairwise_disjoint_powersetCard (s : Finset \u03b1) :\n    Pairwise fun i j => Disjoint (s.powersetCard i) (s.powersetCard j)", "start": [279, 1], "end": [282, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_card_disjiUnion", "code": "theorem powerset_card_disjiUnion (s : Finset \u03b1) :\n    Finset.powerset s =\n      (range (s.card + 1)).disjiUnion (fun i => powersetCard i s)\n        (s.pairwise_disjoint_powersetCard.set_pairwise _)", "start": [285, 1], "end": [295, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_card_biUnion", "code": "theorem powerset_card_biUnion [DecidableEq (Finset \u03b1)] (s : Finset \u03b1) :\n    Finset.powerset s = (range (s.card + 1)).biUnion fun i => powersetCard i s", "start": [298, 1], "end": [300, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_sup", "code": "theorem powersetCard_sup [DecidableEq \u03b1] (u : Finset \u03b1) (n : \u2115) (hn : n < u.card) :\n    (powersetCard n.succ u).sup id = u", "start": [303, 1], "end": [318, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_card_add", "code": "@[simp]\ntheorem powersetCard_card_add (s : Finset \u03b1) {i : \u2115} (hi : 0 < i) :\n    s.powersetCard (s.card + i) = \u2205", "start": [321, 1], "end": [324, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.map_val_val_powersetCard", "code": "@[simp]\ntheorem map_val_val_powersetCard (s : Finset \u03b1) (i : \u2115) :\n    (s.powersetCard i).val.map Finset.val = s.1.powersetCard i", "start": [327, 1], "end": [330, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.powersetCard_map", "code": "theorem powersetCard_map {\u03b2 : Type*} (f : \u03b1 \u21aa \u03b2) (n : \u2115) (s : Finset \u03b1) :\n    powersetCard n (s.map f) = (powersetCard n s).map (mapEmbedding f).toEmbedding", "start": [333, 1], "end": [351, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sym/Basic.lean", "imports": ["Mathlib/Data/Setoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Data/Multiset/Basic.lean", "Mathlib/Data/Vector/Basic.lean"], "premises": [{"full_name": "Sym", "code": "def Sym (\u03b1 : Type*) (n : \u2115) :=\n  { s : Multiset \u03b1 // Multiset.card s = n }", "start": [37, 1], "end": [43, 44], "kind": "commanddeclaration"}, {"full_name": "Sym.toMultiset", "code": "@[coe] def Sym.toMultiset {\u03b1 : Type*} {n : \u2115} (s : Sym \u03b1 n) : Multiset \u03b1 :=\n  s.1", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.hasCoe", "code": "instance Sym.hasCoe (\u03b1 : Type*) (n : \u2115) : CoeOut (Sym \u03b1 n) (Multiset \u03b1) :=\n  \u27e8Sym.toMultiset\u27e9", "start": [51, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "Vector.Perm.isSetoid", "code": "@[reducible]\ndef Vector.Perm.isSetoid (\u03b1 : Type*) (n : \u2115) : Setoid (Vector \u03b1 n) :=\n  (List.isSetoid \u03b1).comap Subtype.val", "start": [58, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : Sym \u03b1 n \u2192 Multiset \u03b1)", "start": [73, 1], "end": [74, 24], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {s\u2081 s\u2082 : Sym \u03b1 n} : (s\u2081 : Multiset \u03b1) = s\u2082 \u2194 s\u2081 = s\u2082", "start": [77, 1], "end": [79, 23], "kind": "commanddeclaration"}, {"full_name": "Sym.ext", "code": "@[ext] theorem ext {s\u2081 s\u2082 : Sym \u03b1 n} (h : (s\u2081 : Multiset \u03b1) = \u2191s\u2082) : s\u2081 = s\u2082", "start": [83, 1], "end": [84, 18], "kind": "commanddeclaration"}, {"full_name": "Sym.val_eq_coe", "code": "@[simp]\ntheorem val_eq_coe (s : Sym \u03b1 n) : s.1 = \u2191s", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.mk", "code": "@[match_pattern] abbrev mk (m : Multiset \u03b1) (h : Multiset.card m = n) : Sym \u03b1 n :=\n  \u27e8m, h\u27e9", "start": [91, 1], "end": [95, 9], "kind": "commanddeclaration"}, {"full_name": "Sym.nil", "code": "@[match_pattern]\ndef nil : Sym \u03b1 0 :=\n  \u27e80, Multiset.card_zero\u27e9", "start": [98, 1], "end": [101, 26], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_nil", "code": "@[simp]\ntheorem coe_nil : \u2191(@Sym.nil \u03b1) = (0 : Multiset \u03b1)", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.cons", "code": "@[match_pattern]\ndef cons (a : \u03b1) (s : Sym \u03b1 n) : Sym \u03b1 n.succ :=\n  \u27e8a ::\u2098 s.1, by rw [Multiset.card_cons, s.2]\u27e9", "start": [109, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_inj_right", "code": "@[simp]\ntheorem cons_inj_right (a : \u03b1) (s s' : Sym \u03b1 n) : a ::\u209b s = a ::\u209b s' \u2194 s = s'", "start": [119, 1], "end": [121, 82], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_inj_left", "code": "@[simp]\ntheorem cons_inj_left (a a' : \u03b1) (s : Sym \u03b1 n) : a ::\u209b s = a' ::\u209b s \u2194 a = a'", "start": [124, 1], "end": [126, 52], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_swap", "code": "theorem cons_swap (a b : \u03b1) (s : Sym \u03b1 n) : a ::\u209b b ::\u209b s = b ::\u209b a ::\u209b s", "start": [129, 1], "end": [130, 44], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_cons", "code": "theorem coe_cons (s : Sym \u03b1 n) (a : \u03b1) : (a ::\u209b s : Multiset \u03b1) = a ::\u2098 s", "start": [133, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.ofVector", "code": "def ofVector : Vector \u03b1 n \u2192 Sym \u03b1 n :=\n  fun x => \u27e8\u2191x.val, (Multiset.coe_card _).trans x.2\u27e9", "start": [137, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "Sym.ofVector_nil", "code": "@[simp]\ntheorem ofVector_nil : \u2191(Vector.nil : Vector \u03b1 0) = (Sym.nil : Sym \u03b1 0)", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.ofVector_cons", "code": "@[simp]\ntheorem ofVector_cons (a : \u03b1) (v : Vector \u03b1 n) : \u2191(Vector.cons a v) = a ::\u209b (\u2191v : Sym \u03b1 n)", "start": [153, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.decidableMem", "code": "instance decidableMem [DecidableEq \u03b1] (a : \u03b1) (s : Sym \u03b1 n) : Decidable (a \u2208 s) :=\n  s.1.decidableMem _", "start": [164, 1], "end": [165, 21], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_mk", "code": "@[simp]\ntheorem mem_mk (a : \u03b1) (s : Multiset \u03b1) (h : Multiset.card s = n) : a \u2208 mk s h \u2194 a \u2208 s", "start": [168, 1], "end": [170, 10], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_cons", "code": "@[simp]\ntheorem mem_cons : a \u2208 b ::\u209b s \u2194 a = b \u2228 a \u2208 s", "start": [173, 1], "end": [175, 20], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_coe", "code": "@[simp]\ntheorem mem_coe : a \u2208 (s : Multiset \u03b1) \u2194 a \u2208 s", "start": [178, 1], "end": [180, 10], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_cons_of_mem", "code": "theorem mem_cons_of_mem (h : a \u2208 s) : a \u2208 b ::\u209b s", "start": [183, 1], "end": [184, 29], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_cons_self", "code": "theorem mem_cons_self (a : \u03b1) (s : Sym \u03b1 n) : a \u2208 a ::\u209b s", "start": [188, 1], "end": [189, 31], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_of_coe_eq", "code": "theorem cons_of_coe_eq (a : \u03b1) (v : Vector \u03b1 n) : a ::\u209b (\u2191v : Sym \u03b1 n) = \u2191(a ::\u1d65 v)", "start": [192, 1], "end": [195, 8], "kind": "commanddeclaration"}, {"full_name": "Sym.sound", "code": "theorem sound {a b : Vector \u03b1 n} (h : a.val ~ b.val) : (\u2191a : Sym \u03b1 n) = \u2191b", "start": [198, 1], "end": [199, 34], "kind": "commanddeclaration"}, {"full_name": "Sym.erase", "code": "def erase [DecidableEq \u03b1] (s : Sym \u03b1 (n + 1)) (a : \u03b1) (h : a \u2208 s) : Sym \u03b1 n :=\n  \u27e8s.val.erase a, (Multiset.card_erase_of_mem h).trans <| s.property.symm \u25b8 n.pred_succ\u27e9", "start": [202, 1], "end": [205, 89], "kind": "commanddeclaration"}, {"full_name": "Sym.erase_mk", "code": "@[simp]\ntheorem erase_mk [DecidableEq \u03b1] (m : Multiset \u03b1)\n    (hc : Multiset.card m = n + 1) (a : \u03b1) (h : a \u2208 m) :\n    (mk m hc).erase a h =mk (m.erase a)\n        (by rw [Multiset.card_erase_of_mem h, hc]; rfl)", "start": [208, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_erase", "code": "@[simp]\ntheorem coe_erase [DecidableEq \u03b1] {s : Sym \u03b1 n.succ} {a : \u03b1} (h : a \u2208 s) :\n    (s.erase a h : Multiset \u03b1) = Multiset.erase s a", "start": [216, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_erase", "code": "@[simp]\ntheorem cons_erase [DecidableEq \u03b1] {s : Sym \u03b1 n.succ} {a : \u03b1} (h : a \u2208 s) : a ::\u209b s.erase a h = s", "start": [222, 1], "end": [224, 41], "kind": "commanddeclaration"}, {"full_name": "Sym.erase_cons_head", "code": "@[simp]\ntheorem erase_cons_head [DecidableEq \u03b1] (s : Sym \u03b1 n) (a : \u03b1)\n    (h : a \u2208 a ::\u209b s := mem_cons_self a s) : (a ::\u209b s).erase a h = s", "start": [227, 1], "end": [230, 50], "kind": "commanddeclaration"}, {"full_name": "Sym.Sym'", "code": "def Sym' (\u03b1 : Type*) (n : \u2115) :=\n  Quotient (Vector.Perm.isSetoid \u03b1 n)", "start": [233, 1], "end": [236, 38], "kind": "commanddeclaration"}, {"full_name": "Sym.cons'", "code": "def cons' {\u03b1 : Type*} {n : \u2115} : \u03b1 \u2192 Sym' \u03b1 n \u2192 Sym' \u03b1 (Nat.succ n) := fun a =>\n  Quotient.map (Vector.cons a) fun \u27e8_, _\u27e9 \u27e8_, _\u27e9 h => List.Perm.cons _ h", "start": [239, 1], "end": [242, 73], "kind": "commanddeclaration"}, {"full_name": "Sym.symEquivSym'", "code": "def symEquivSym' {\u03b1 : Type*} {n : \u2115} : Sym \u03b1 n \u2243 Sym' \u03b1 n :=\n  Equiv.subtypeQuotientEquivQuotientSubtype _ _ (fun _ => by rfl) fun _ _ => by rfl", "start": [248, 1], "end": [251, 84], "kind": "commanddeclaration"}, {"full_name": "Sym.cons_equiv_eq_equiv_cons", "code": "theorem cons_equiv_eq_equiv_cons (\u03b1 : Type*) (n : \u2115) (a : \u03b1) (s : Sym \u03b1 n) :\n    (a::symEquivSym' s) = symEquivSym' (a ::\u209b s)", "start": [254, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.instZeroSym", "code": "instance instZeroSym : Zero (Sym \u03b1 0) :=\n  \u27e8\u27e80, rfl\u27e9\u27e9", "start": [260, 1], "end": [261, 13], "kind": "commanddeclaration"}, {"full_name": "Sym.eq_nil_of_card_zero", "code": "theorem eq_nil_of_card_zero (s : Sym \u03b1 0) : s = nil", "start": [266, 1], "end": [267, 45], "kind": "commanddeclaration"}, {"full_name": "Sym.uniqueZero", "code": "instance uniqueZero : Unique (Sym \u03b1 0) :=\n  \u27e8\u27e8nil\u27e9, eq_nil_of_card_zero\u27e9", "start": [270, 1], "end": [271, 31], "kind": "commanddeclaration"}, {"full_name": "Sym.replicate", "code": "def replicate (n : \u2115) (a : \u03b1) : Sym \u03b1 n :=\n  \u27e8Multiset.replicate n a, Multiset.card_replicate _ _\u27e9", "start": [274, 1], "end": [276, 56], "kind": "commanddeclaration"}, {"full_name": "Sym.replicate_succ", "code": "theorem replicate_succ {a : \u03b1} {n : \u2115} : replicate n.succ a = a ::\u209b replicate n a", "start": [279, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_replicate", "code": "theorem coe_replicate : (replicate n a : Multiset \u03b1) = Multiset.replicate n a", "start": [283, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_replicate", "code": "@[simp]\ntheorem mem_replicate : b \u2208 replicate n a \u2194 n \u2260 0 \u2227 b = a", "start": [287, 1], "end": [289, 25], "kind": "commanddeclaration"}, {"full_name": "Sym.eq_replicate_iff", "code": "theorem eq_replicate_iff : s = replicate n a \u2194 \u2200 b \u2208 s, b = a", "start": [292, 1], "end": [294, 26], "kind": "commanddeclaration"}, {"full_name": "Sym.exists_mem", "code": "theorem exists_mem (s : Sym \u03b1 n.succ) : \u2203 a, a \u2208 s", "start": [297, 1], "end": [298, 62], "kind": "commanddeclaration"}, {"full_name": "Sym.exists_eq_cons_of_succ", "code": "theorem exists_eq_cons_of_succ (s : Sym \u03b1 n.succ) : \u2203 (a : \u03b1) (s' : Sym \u03b1 n), s = a ::\u209b s'", "start": [301, 1], "end": [303, 58], "kind": "commanddeclaration"}, {"full_name": "Sym.eq_replicate", "code": "theorem eq_replicate {a : \u03b1} {n : \u2115} {s : Sym \u03b1 n} : s = replicate n a \u2194 \u2200 b \u2208 s, b = a", "start": [306, 1], "end": [307, 79], "kind": "commanddeclaration"}, {"full_name": "Sym.eq_replicate_of_subsingleton", "code": "theorem eq_replicate_of_subsingleton [Subsingleton \u03b1] (a : \u03b1) {n : \u2115} (s : Sym \u03b1 n) :\n    s = replicate n a", "start": [310, 1], "end": [312, 50], "kind": "commanddeclaration"}, {"full_name": "Sym.inhabitedSym", "code": "instance inhabitedSym [Inhabited \u03b1] (n : \u2115) : Inhabited (Sym \u03b1 n) :=\n  \u27e8replicate n default\u27e9", "start": [323, 1], "end": [324, 24], "kind": "commanddeclaration"}, {"full_name": "Sym.inhabitedSym'", "code": "instance inhabitedSym' [Inhabited \u03b1] (n : \u2115) : Inhabited (Sym' \u03b1 n) :=\n  \u27e8Quotient.mk' (Vector.replicate n default)\u27e9", "start": [327, 1], "end": [328, 46], "kind": "commanddeclaration"}, {"full_name": "Sym.replicate_right_inj", "code": "theorem replicate_right_inj {a b : \u03b1} {n : \u2115} (h : n \u2260 0) : replicate n a = replicate n b \u2194 a = b", "start": [339, 1], "end": [340, 57], "kind": "commanddeclaration"}, {"full_name": "Sym.replicate_right_injective", "code": "theorem replicate_right_injective {n : \u2115} (h : n \u2260 0) :\n    Function.Injective (replicate n : \u03b1 \u2192 Sym \u03b1 n)", "start": [343, 1], "end": [344, 91], "kind": "commanddeclaration"}, {"full_name": "Sym.map", "code": "def map {n : \u2115} (f : \u03b1 \u2192 \u03b2) (x : Sym \u03b1 n) : Sym \u03b2 n :=\n  \u27e8x.val.map f, by simpa [Multiset.card_map] using x.property\u27e9", "start": [350, 1], "end": [353, 63], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_map", "code": "@[simp]\ntheorem mem_map {n : \u2115} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {l : Sym \u03b1 n} :\n    b \u2208 Sym.map f l \u2194 \u2203 a, a \u2208 l \u2227 f a = b", "start": [356, 1], "end": [359, 19], "kind": "commanddeclaration"}, {"full_name": "Sym.map_id'", "code": "@[simp]\ntheorem map_id' {\u03b1 : Type*} {n : \u2115} (s : Sym \u03b1 n) : Sym.map (fun x : \u03b1 => x) s = s", "start": [362, 1], "end": [365, 27], "kind": "commanddeclaration"}, {"full_name": "Sym.map_id", "code": "theorem map_id {\u03b1 : Type*} {n : \u2115} (s : Sym \u03b1 n) : Sym.map id s = s", "start": [368, 1], "end": [369, 27], "kind": "commanddeclaration"}, {"full_name": "Sym.map_map", "code": "@[simp]\ntheorem map_map {\u03b1 \u03b2 \u03b3 : Type*} {n : \u2115} (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (s : Sym \u03b1 n) :\n    Sym.map g (Sym.map f s) = Sym.map (g \u2218 f) s", "start": [372, 1], "end": [375, 47], "kind": "commanddeclaration"}, {"full_name": "Sym.map_zero", "code": "@[simp]\ntheorem map_zero (f : \u03b1 \u2192 \u03b2) : Sym.map f (0 : Sym \u03b1 0) = (0 : Sym \u03b2 0)", "start": [378, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.map_cons", "code": "@[simp]\ntheorem map_cons {n : \u2115} (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Sym \u03b1 n) : (a ::\u209b s).map f = f a ::\u209b s.map f", "start": [383, 1], "end": [385, 33], "kind": "commanddeclaration"}, {"full_name": "Sym.map_congr", "code": "@[congr]\ntheorem map_congr {f g : \u03b1 \u2192 \u03b2} {s : Sym \u03b1 n} (h : \u2200 x \u2208 s, f x = g x) : map f s = map g s", "start": [388, 1], "end": [390, 42], "kind": "commanddeclaration"}, {"full_name": "Sym.map_mk", "code": "@[simp]\ntheorem map_mk {f : \u03b1 \u2192 \u03b2} {m : Multiset \u03b1} {hc : Multiset.card m = n} :\n    map f (mk m hc) = mk (m.map f) (by simp [hc])", "start": [393, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_map", "code": "@[simp]\ntheorem coe_map (s : Sym \u03b1 n) (f : \u03b1 \u2192 \u03b2) : \u2191(s.map f) = Multiset.map f s", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.map_injective", "code": "theorem map_injective {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (n : \u2115) :\n    Injective (map f : Sym \u03b1 n \u2192 Sym \u03b2 n)", "start": [404, 1], "end": [406, 60], "kind": "commanddeclaration"}, {"full_name": "Sym.equivCongr", "code": "@[simps]\ndef equivCongr (e : \u03b1 \u2243 \u03b2) : Sym \u03b1 n \u2243 Sym \u03b2 n where\n  toFun := map e\n  invFun := map e.symm\n  left_inv x := by rw [map_map, Equiv.symm_comp_self, map_id]\n  right_inv x := by rw [map_map, Equiv.self_comp_symm, map_id]", "start": [409, 1], "end": [416, 63], "kind": "commanddeclaration"}, {"full_name": "Sym.attach", "code": "def attach (s : Sym \u03b1 n) : Sym { x // x \u2208 s } n :=\n  \u27e8s.val.attach, by conv_rhs => rw [\u2190 s.2, \u2190 Multiset.card_attach]\u27e9", "start": [421, 1], "end": [424, 68], "kind": "commanddeclaration"}, {"full_name": "Sym.attach_mk", "code": "@[simp]\ntheorem attach_mk {m : Multiset \u03b1} {hc : Multiset.card m = n} :\n    attach (mk m hc) = mk m.attach (Multiset.card_attach.trans hc)", "start": [427, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_attach", "code": "@[simp]\ntheorem coe_attach (s : Sym \u03b1 n) : (s.attach : Multiset { a // a \u2208 s }) =\n    Multiset.attach (s : Multiset \u03b1)", "start": [433, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.attach_map_coe", "code": "theorem attach_map_coe (s : Sym \u03b1 n) : s.attach.map (\u2191) = s", "start": [439, 1], "end": [440, 45], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_attach", "code": "@[simp]\ntheorem mem_attach (s : Sym \u03b1 n) (x : { x // x \u2208 s }) : x \u2208 s.attach", "start": [443, 1], "end": [445, 26], "kind": "commanddeclaration"}, {"full_name": "Sym.attach_nil", "code": "@[simp]\ntheorem attach_nil : (nil : Sym \u03b1 0).attach = nil", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.attach_cons", "code": "@[simp]\ntheorem attach_cons (x : \u03b1) (s : Sym \u03b1 n) :\n    (cons x s).attach =\n      cons \u27e8x, mem_cons_self _ _\u27e9 (s.attach.map fun x => \u27e8x, mem_cons_of_mem x.prop\u27e9)", "start": [453, 1], "end": [457, 44], "kind": "commanddeclaration"}, {"full_name": "Sym.cast", "code": "protected def cast {n m : \u2115} (h : n = m) : Sym \u03b1 n \u2243 Sym \u03b1 m where\n  toFun s := \u27e8s.val, s.2.trans h\u27e9\n  invFun s := \u27e8s.val, s.2.trans h.symm\u27e9\n  left_inv _ := Subtype.ext rfl\n  right_inv _ := Subtype.ext rfl", "start": [460, 1], "end": [466, 33], "kind": "commanddeclaration"}, {"full_name": "Sym.cast_rfl", "code": "@[simp]\ntheorem cast_rfl : Sym.cast rfl s = s", "start": [469, 1], "end": [471, 18], "kind": "commanddeclaration"}, {"full_name": "Sym.cast_cast", "code": "@[simp]\ntheorem cast_cast {n'' : \u2115} (h : n = n') (h' : n' = n'') :\n    Sym.cast h' (Sym.cast h s) = Sym.cast (h.trans h') s", "start": [474, 1], "end": [477, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_cast", "code": "@[simp]\ntheorem coe_cast (h : n = m) : (Sym.cast h s : Multiset \u03b1) = s", "start": [480, 1], "end": [482, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_cast", "code": "@[simp]\ntheorem mem_cast (h : n = m) : a \u2208 Sym.cast h s \u2194 a \u2208 s", "start": [485, 1], "end": [487, 10], "kind": "commanddeclaration"}, {"full_name": "Sym.append", "code": "def append (s : Sym \u03b1 n) (s' : Sym \u03b1 n') : Sym \u03b1 (n + n') :=\n  \u27e8s.1 + s'.1, by rw [map_add, s.2, s'.2]\u27e9", "start": [490, 1], "end": [492, 43], "kind": "commanddeclaration"}, {"full_name": "Sym.append_inj_right", "code": "@[simp]\ntheorem append_inj_right (s : Sym \u03b1 n) {t t' : Sym \u03b1 n'} : s.append t = s.append t' \u2194 t = t'", "start": [495, 1], "end": [497, 72], "kind": "commanddeclaration"}, {"full_name": "Sym.append_inj_left", "code": "@[simp]\ntheorem append_inj_left {s s' : Sym \u03b1 n} (t : Sym \u03b1 n') : s.append t = s'.append t \u2194 s = s'", "start": [500, 1], "end": [502, 71], "kind": "commanddeclaration"}, {"full_name": "Sym.append_comm", "code": "theorem append_comm (s : Sym \u03b1 n') (s' : Sym \u03b1 n') :\n    s.append s' = Sym.cast (add_comm _ _) (s'.append s)", "start": [505, 1], "end": [508, 26], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_append", "code": "@[simp, norm_cast]\ntheorem coe_append (s : Sym \u03b1 n) (s' : Sym \u03b1 n') : (s.append s' : Multiset \u03b1) = s + s'", "start": [511, 1], "end": [513, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_append_iff", "code": "theorem mem_append_iff {s' : Sym \u03b1 m} : a \u2208 s.append s' \u2194 a \u2208 s \u2228 a \u2208 s'", "start": [516, 1], "end": [517, 19], "kind": "commanddeclaration"}, {"full_name": "Sym.fill", "code": "def fill (a : \u03b1) (i : Fin (n + 1)) (m : Sym \u03b1 (n - i)) : Sym \u03b1 n :=\n  Sym.cast (Nat.sub_add_cancel i.is_le) (m.append (replicate i a))", "start": [520, 1], "end": [524, 67], "kind": "commanddeclaration"}, {"full_name": "Sym.coe_fill", "code": "theorem coe_fill {a : \u03b1} {i : Fin (n + 1)} {m : Sym \u03b1 (n - i)} :\n    (fill a i m : Multiset \u03b1) = m + replicate i a", "start": [527, 1], "end": [529, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.mem_fill_iff", "code": "theorem mem_fill_iff {a b : \u03b1} {i : Fin (n + 1)} {s : Sym \u03b1 (n - i)} :\n    a \u2208 Sym.fill b i s \u2194 (i : \u2115) \u2260 0 \u2227 a = b \u2228 a \u2208 s", "start": [532, 1], "end": [534, 62], "kind": "commanddeclaration"}, {"full_name": "Sym.filterNe", "code": "def filterNe [DecidableEq \u03b1] (a : \u03b1) (m : Sym \u03b1 n) : \u03a3i : Fin (n + 1), Sym \u03b1 (n - i) :=\n  \u27e8\u27e8m.1.count a, (count_le_card _ _).trans_lt <| by rw [m.2, Nat.lt_succ_iff]\u27e9,\n    m.1.filter ((\u00b7 \u2260 \u00b7) a),\n    eq_tsub_of_add_eq <|\n      Eq.trans\n        (by\n          rw [\u2190 countP_eq_card_filter, add_comm]\n          simp only [eq_comm, Ne.def, count]\n          rw [\u2190 card_eq_countP_add_countP _ _])\n        m.2\u27e9", "start": [539, 1], "end": [550, 13], "kind": "commanddeclaration"}, {"full_name": "Sym.sigma_sub_ext", "code": "theorem sigma_sub_ext {m\u2081 m\u2082 : \u03a3i : Fin (n + 1), Sym \u03b1 (n - i)} (h : (m\u2081.2 : Multiset \u03b1) = m\u2082.2) :\n    m\u2081 = m\u2082", "start": [553, 1], "end": [559, 6], "kind": "commanddeclaration"}, {"full_name": "Sym.fill_filterNe", "code": "theorem fill_filterNe [DecidableEq \u03b1] (a : \u03b1) (m : Sym \u03b1 n) :\n    (m.filterNe a).2.fill a (m.filterNe a).1 = m", "start": [562, 1], "end": [571, 48], "kind": "commanddeclaration"}, {"full_name": "Sym.filter_ne_fill", "code": "theorem filter_ne_fill [DecidableEq \u03b1] (a : \u03b1) (m : \u03a3i : Fin (n + 1), Sym \u03b1 (n - i)) (h : a \u2209 m.2) :\n    (m.2.fill a m.1).filterNe a = m", "start": [574, 1], "end": [583, 50], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.encode", "code": "def encode [DecidableEq \u03b1] (s : Sym (Option \u03b1) n.succ) : Sum (Sym (Option \u03b1) n) (Sym \u03b1 n.succ) :=\n  if h : none \u2208 s then Sum.inl (s.erase none h)\n  else\n    Sum.inr\n      (s.attach.map fun o =>\n        o.1.get <| Option.ne_none_iff_isSome.1 <| ne_of_mem_of_not_mem o.2 h)", "start": [599, 1], "end": [606, 78], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.encode_of_none_mem", "code": "@[simp]\ntheorem encode_of_none_mem [DecidableEq \u03b1] (s : Sym (Option \u03b1) n.succ) (h : none \u2208 s) :\n    encode s = Sum.inl (s.erase none h)", "start": [609, 1], "end": [612, 12], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.encode_of_not_none_mem", "code": "@[simp]\ntheorem encode_of_not_none_mem [DecidableEq \u03b1] (s : Sym (Option \u03b1) n.succ) (h : \u00acnone \u2208 s) :\n    encode s =\n      Sum.inr\n        (s.attach.map fun o =>\n          o.1.get <| Option.ne_none_iff_isSome.1 <| ne_of_mem_of_not_mem o.2 h)", "start": [615, 1], "end": [621, 12], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.decode", "code": "def decode : Sum (Sym (Option \u03b1) n) (Sym \u03b1 n.succ) \u2192 Sym (Option \u03b1) n.succ\n  | Sum.inl s => none ::\u209b s\n  | Sum.inr s => s.map Embedding.some", "start": [624, 1], "end": [628, 38], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.decode_inl", "code": "@[simp]\ntheorem decode_inl (s : Sym (Option \u03b1) n) : decode (Sum.inl s) = none ::\u209b s", "start": [632, 1], "end": [634, 6], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.decode_inr", "code": "@[simp]\ntheorem decode_inr (s : Sym \u03b1 n.succ) : decode (Sum.inr s) = s.map Embedding.some", "start": [637, 1], "end": [639, 6], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.decode_encode", "code": "@[simp]\ntheorem decode_encode [DecidableEq \u03b1] (s : Sym (Option \u03b1) n.succ) : decode (encode s) = s", "start": [641, 1], "end": [647, 29], "kind": "commanddeclaration"}, {"full_name": "SymOptionSuccEquiv.encode_decode", "code": "@[simp]\ntheorem encode_decode [DecidableEq \u03b1] (s : Sum (Sym (Option \u03b1) n) (Sym \u03b1 n.succ)) :\n    encode (decode s) = s", "start": [650, 1], "end": [662, 17], "kind": "commanddeclaration"}, {"full_name": "symOptionSuccEquiv", "code": "def symOptionSuccEquiv [DecidableEq \u03b1] :\n    Sym (Option \u03b1) n.succ \u2243 Sum (Sym (Option \u03b1) n) (Sym \u03b1 n.succ) where\n  toFun := SymOptionSuccEquiv.encode\n  invFun := SymOptionSuccEquiv.decode\n  left_inv := SymOptionSuccEquiv.decode_encode\n  right_inv := SymOptionSuccEquiv.encode_decode", "start": [667, 1], "end": [674, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Pi.lean", "imports": ["Mathlib/Data/Finset/Pi.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fintype.piFinset", "code": "def piFinset (t : \u2200 a, Finset (\u03b4 a)) : Finset (\u2200 a, \u03b4 a) :=\n  (Finset.univ.pi t).map \u27e8fun f a => f a (mem_univ a), fun _ _ =>\n    by simp (config := {contextual := true}) [Function.funext_iff]\u27e9", "start": [24, 1], "end": [30, 68], "kind": "commanddeclaration"}, {"full_name": "Fintype.mem_piFinset", "code": "@[simp]\ntheorem mem_piFinset {t : \u2200 a, Finset (\u03b4 a)} {f : \u2200 a, \u03b4 a} : f \u2208 piFinset t \u2194 \u2200 a, f a \u2208 t a", "start": [33, 1], "end": [42, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.coe_piFinset", "code": "@[simp]\ntheorem coe_piFinset (t : \u2200 a, Finset (\u03b4 a)) :\n    (piFinset t : Set (\u2200 a, \u03b4 a)) = Set.pi Set.univ fun a => t a", "start": [45, 1], "end": [50, 31], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_subset", "code": "theorem piFinset_subset (t\u2081 t\u2082 : \u2200 a, Finset (\u03b4 a)) (h : \u2200 a, t\u2081 a \u2286 t\u2082 a) :\n    piFinset t\u2081 \u2286 piFinset t\u2082", "start": [53, 1], "end": [54, 96], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_empty", "code": "@[simp]\ntheorem piFinset_empty [Nonempty \u03b1] : piFinset (fun _ => \u2205 : \u2200 i, Finset (\u03b4 i)) = \u2205", "start": [57, 1], "end": [59, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_singleton", "code": "@[simp]\ntheorem piFinset_singleton (f : \u2200 i, \u03b4 i) : piFinset (fun i => {f i} : \u2200 i, Finset (\u03b4 i)) = {f}", "start": [62, 1], "end": [64, 87], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_subsingleton", "code": "theorem piFinset_subsingleton {f : \u2200 i, Finset (\u03b4 i)} (hf : \u2200 i, (f i : Set (\u03b4 i)).Subsingleton) :\n    (Fintype.piFinset f : Set (\u2200 i, \u03b4 i)).Subsingleton", "start": [67, 1], "end": [69, 67], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_disjoint_of_disjoint", "code": "theorem piFinset_disjoint_of_disjoint (t\u2081 t\u2082 : \u2200 a, Finset (\u03b4 a)) {a : \u03b1}\n    (h : Disjoint (t\u2081 a) (t\u2082 a)) : Disjoint (piFinset t\u2081) (piFinset t\u2082)", "start": [72, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.fintype", "code": "instance Pi.fintype {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [Fintype \u03b1]\n    [\u2200 a, Fintype (\u03b2 a)] : Fintype (\u2200 a, \u03b2 a) :=\n  \u27e8Fintype.piFinset fun _ => univ, by simp\u27e9", "start": [83, 1], "end": [86, 44], "kind": "commanddeclaration"}, {"full_name": "Fintype.piFinset_univ", "code": "@[simp]\ntheorem Fintype.piFinset_univ {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [Fintype \u03b1]\n    [\u2200 a, Fintype (\u03b2 a)] :\n    (Fintype.piFinset fun a : \u03b1 => (Finset.univ : Finset (\u03b2 a))) =\n      (Finset.univ : Finset (\u2200 a, \u03b2 a))", "start": [89, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.fintype", "code": "noncomputable instance _root_.Function.Embedding.fintype {\u03b1 \u03b2} [Fintype \u03b1] [Fintype \u03b2] :\n  Fintype (\u03b1 \u21aa \u03b2) :=\n  by classical. exact Fintype.ofEquiv _ (Equiv.subtypeInjectiveEquivEmbedding \u03b1 \u03b2)", "start": [101, 1], "end": [103, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_pi_univ", "code": "@[simp]\ntheorem Finset.univ_pi_univ {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [Fintype \u03b1]\n    [\u2200 a, Fintype (\u03b2 a)] :\n    (Finset.univ.pi fun a : \u03b1 => (Finset.univ : Finset (\u03b2 a))) = Finset.univ", "start": [106, 1], "end": [110, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Sigma.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Data/Set/Sigma.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.sigma", "code": "protected def sigma : Finset (\u03a3i, \u03b1 i) :=\n  \u27e8_, s.nodup.sigma fun i => (t i).nodup\u27e9", "start": [41, 1], "end": [43, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sigma", "code": "@[simp]\ntheorem mem_sigma {a : \u03a3i, \u03b1 i} : a \u2208 s.sigma t \u2194 a.1 \u2208 s \u2227 a.2 \u2208 t a.1", "start": [48, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_sigma", "code": "@[simp, norm_cast]\ntheorem coe_sigma (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i)) :\n    (s.sigma t : Set (\u03a3i, \u03b1 i)) = (s : Set \u03b9).Sigma fun i => (t i : Set (\u03b1 i))", "start": [53, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_nonempty", "code": "@[simp]\ntheorem sigma_nonempty : (s.sigma t).Nonempty \u2194 \u2203 i \u2208 s, (t i).Nonempty", "start": [59, 1], "end": [60, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_eq_empty", "code": "@[simp]\ntheorem sigma_eq_empty : s.sigma t = \u2205 \u2194 \u2200 i \u2208 s, t i = \u2205", "start": [63, 1], "end": [65, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_mono", "code": "@[mono]\ntheorem sigma_mono (hs : s\u2081 \u2286 s\u2082) (ht : \u2200 i, t\u2081 i \u2286 t\u2082 i) : s\u2081.sigma t\u2081 \u2286 s\u2082.sigma t\u2082", "start": [68, 1], "end": [72, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwiseDisjoint_map_sigmaMk", "code": "theorem pairwiseDisjoint_map_sigmaMk :\n    (s : Set \u03b9).PairwiseDisjoint fun i => (t i).map (Embedding.sigmaMk i)", "start": [75, 1], "end": [81, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.disjiUnion_map_sigma_mk", "code": "@[simp]\ntheorem disjiUnion_map_sigma_mk :\n    s.disjiUnion (fun i => (t i).map (Embedding.sigmaMk i)) pairwiseDisjoint_map_sigmaMk =\n      s.sigma t", "start": [84, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_eq_biUnion", "code": "theorem sigma_eq_biUnion [DecidableEq (\u03a3i, \u03b1 i)] (s : Finset \u03b9) (t : \u2200 i, Finset (\u03b1 i)) :\n    s.sigma t = s.biUnion fun i => (t i).map <| Embedding.sigmaMk i", "start": [91, 1], "end": [94, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_sigma", "code": "theorem sup_sigma [SemilatticeSup \u03b2] [OrderBot \u03b2] :\n    (s.sigma t).sup f = s.sup fun i => (t i).sup fun b => f \u27e8i, b\u27e9", "start": [99, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_sigma", "code": "theorem inf_sigma [SemilatticeInf \u03b2] [OrderTop \u03b2] :\n    (s.sigma t).inf f = s.inf fun i => (t i).inf fun b => f \u27e8i, b\u27e9", "start": [107, 1], "end": [109, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.sigmaLift", "code": "def sigmaLift (f : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b2 i \u2192 Finset (\u03b3 i)) (a : Sigma \u03b1) (b : Sigma \u03b2) :\n    Finset (Sigma \u03b3) :=\n  dite (a.1 = b.1) (fun h => (f (h \u25b8 a.2) b.2).map <| Embedding.sigmaMk _) fun _ => \u2205", "start": [118, 1], "end": [121, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sigmaLift", "code": "theorem mem_sigmaLift (f : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b2 i \u2192 Finset (\u03b3 i)) (a : Sigma \u03b1) (b : Sigma \u03b2)\n    (x : Sigma \u03b3) :\n    x \u2208 sigmaLift f a b \u2194 \u2203 (ha : a.1 = x.1) (hb : b.1 = x.1), x.2 \u2208 f (ha \u25b8 a.2) (hb \u25b8 b.2)", "start": [124, 1], "end": [141, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.mk_mem_sigmaLift", "code": "theorem mk_mem_sigmaLift (f : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b2 i \u2192 Finset (\u03b3 i)) (i : \u03b9) (a : \u03b1 i) (b : \u03b2 i)\n    (x : \u03b3 i) : (\u27e8i, x\u27e9 : Sigma \u03b3) \u2208 sigmaLift f \u27e8i, a\u27e9 \u27e8i, b\u27e9 \u2194 x \u2208 f a b", "start": [144, 1], "end": [149, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_sigmaLift_of_ne_left", "code": "theorem not_mem_sigmaLift_of_ne_left (f : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b2 i \u2192 Finset (\u03b3 i)) (a : Sigma \u03b1)\n    (b : Sigma \u03b2) (x : Sigma \u03b3) (h : a.1 \u2260 x.1) : x \u2209 sigmaLift f a b", "start": [152, 1], "end": [155, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_sigmaLift_of_ne_right", "code": "theorem not_mem_sigmaLift_of_ne_right (f : \u2200 \u2983i\u2984, \u03b1 i \u2192 \u03b2 i \u2192 Finset (\u03b3 i)) {a : Sigma \u03b1}\n    (b : Sigma \u03b2) {x : Sigma \u03b3} (h : b.1 \u2260 x.1) : x \u2209 sigmaLift f a b", "start": [158, 1], "end": [161, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.sigmaLift_nonempty", "code": "theorem sigmaLift_nonempty :\n    (sigmaLift f a b).Nonempty \u2194 \u2203 h : a.1 = b.1, (f (h \u25b8 a.2) b.2).Nonempty", "start": [166, 1], "end": [169, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.sigmaLift_eq_empty", "code": "theorem sigmaLift_eq_empty : sigmaLift f a b = \u2205 \u2194 \u2200 h : a.1 = b.1, f (h \u25b8 a.2) b.2 = \u2205", "start": [172, 1], "end": [176, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sigmaLift_mono", "code": "theorem sigmaLift_mono (h : \u2200 \u2983i\u2984 \u2983a : \u03b1 i\u2984 \u2983b : \u03b2 i\u2984, f a b \u2286 g a b) (a : \u03a3i, \u03b1 i) (b : \u03a3i, \u03b2 i) :\n    sigmaLift f a b \u2286 sigmaLift g a b", "start": [179, 1], "end": [184, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sigmaLift", "code": "theorem card_sigmaLift :\n    (sigmaLift f a b).card = dite (a.1 = b.1) (fun h => (f (h \u25b8 a.2) b.2).card) fun _ => 0", "start": [189, 1], "end": [192, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Pairing.lean", "imports": ["Mathlib/Data/Nat/Sqrt.lean", "Mathlib/Data/Set/Lattice.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/MinMax.lean"], "premises": [{"full_name": "Nat.pair", "code": "def pair (a b : \u2115) : \u2115 :=\n  if a < b then b * b + a else a * a + a + b", "start": [34, 1], "end": [38, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair", "code": "def unpair (n : \u2115) : \u2115 \u00d7 \u2115 :=\n  let s := sqrt n\n  if n - s * s < s then (n - s * s, s) else (s, n - s * s - s)", "start": [41, 1], "end": [46, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_unpair", "code": "@[simp]\ntheorem pair_unpair (n : \u2115) : pair (unpair n).1 (unpair n).2 = n", "start": [49, 1], "end": [57, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_unpair'", "code": "theorem pair_unpair' {n a b} (H : unpair n = (a, b)) : pair a b = n", "start": [60, 1], "end": [61, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_pair", "code": "@[simp]\ntheorem unpair_pair (a b : \u2115) : unpair (pair a b) = (a, b)", "start": [64, 1], "end": [74, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.pairEquiv", "code": "@[simps (config := { fullyApplied := false })]\ndef pairEquiv : \u2115 \u00d7 \u2115 \u2243 \u2115 :=\n  \u27e8uncurry pair, unpair, fun \u27e8a, b\u27e9 => unpair_pair a b, pair_unpair\u27e9", "start": [77, 1], "end": [80, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.surjective_unpair", "code": "theorem surjective_unpair : Surjective unpair", "start": [85, 1], "end": [86, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_eq_pair", "code": "@[simp]\ntheorem pair_eq_pair {a b c d : \u2115} : pair a b = pair c d \u2194 a = c \u2227 b = d", "start": [89, 1], "end": [91, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_lt", "code": "theorem unpair_lt {n : \u2115} (n1 : 1 \u2264 n) : (unpair n).1 < n", "start": [94, 1], "end": [101, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_zero", "code": "@[simp]\ntheorem unpair_zero : unpair 0 = 0", "start": [104, 1], "end": [107, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_left_le", "code": "theorem unpair_left_le : \u2200 n : \u2115, (unpair n).1 \u2264 n", "start": [110, 1], "end": [112, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.left_le_pair", "code": "theorem left_le_pair (a b : \u2115) : a \u2264 pair a b", "start": [115, 1], "end": [115, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.right_le_pair", "code": "theorem right_le_pair (a b : \u2115) : b \u2264 pair a b", "start": [118, 1], "end": [120, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_right_le", "code": "theorem unpair_right_le (n : \u2115) : (unpair n).2 \u2264 n", "start": [123, 1], "end": [124, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_lt_pair_left", "code": "theorem pair_lt_pair_left {a\u2081 a\u2082} (b) (h : a\u2081 < a\u2082) : pair a\u2081 b < pair a\u2082 b", "start": [127, 1], "end": [138, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_lt_pair_right", "code": "theorem pair_lt_pair_right (a) {b\u2081 b\u2082} (h : b\u2081 < b\u2082) : pair a b\u2081 < pair a b\u2082", "start": [141, 1], "end": [149, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.pair_lt_max_add_one_sq", "code": "theorem pair_lt_max_add_one_sq (m n : \u2115) : pair m n < (max m n + 1) ^ 2", "start": [152, 1], "end": [158, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.max_sq_add_min_le_pair", "code": "theorem max_sq_add_min_le_pair (m n : \u2115) : max m n ^ 2 + min m n \u2264 pair m n", "start": [161, 1], "end": [166, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.add_le_pair", "code": "theorem add_le_pair (m n : \u2115) : m + n \u2264 pair m n", "start": [169, 1], "end": [172, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.unpair_add_le", "code": "theorem unpair_add_le (n : \u2115) : (unpair n).1 + (unpair n).2 \u2264 n", "start": [175, 1], "end": [176, 45], "kind": "commanddeclaration"}, {"full_name": "iSup_unpair", "code": "theorem iSup_unpair {\u03b1} [CompleteLattice \u03b1] (f : \u2115 \u2192 \u2115 \u2192 \u03b1) :\n    \u2a06 n : \u2115, f n.unpair.1 n.unpair.2 = \u2a06 (i : \u2115) (j : \u2115), f i j", "start": [186, 1], "end": [188, 85], "kind": "commanddeclaration"}, {"full_name": "iInf_unpair", "code": "theorem iInf_unpair {\u03b1} [CompleteLattice \u03b1] (f : \u2115 \u2192 \u2115 \u2192 \u03b1) :\n    \u2a05 n : \u2115, f n.unpair.1 n.unpair.2 = \u2a05 (i : \u2115) (j : \u2115), f i j", "start": [192, 1], "end": [194, 40], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_unpair_prod", "code": "theorem iUnion_unpair_prod {\u03b1 \u03b2} {s : \u2115 \u2192 Set \u03b1} {t : \u2115 \u2192 Set \u03b2} :\n    \u22c3 n : \u2115, s n.unpair.fst \u00d7\u02e2 t n.unpair.snd = (\u22c3 n, s n) \u00d7\u02e2 \u22c3 n, t n", "start": [203, 1], "end": [206, 68], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_unpair", "code": "theorem iUnion_unpair {\u03b1} (f : \u2115 \u2192 \u2115 \u2192 Set \u03b1) :\n    \u22c3 n : \u2115, f n.unpair.1 n.unpair.2 = \u22c3 (i : \u2115) (j : \u2115), f i j", "start": [210, 1], "end": [212, 16], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_unpair", "code": "theorem iInter_unpair {\u03b1} (f : \u2115 \u2192 \u2115 \u2192 Set \u03b1) :\n    \u22c2 n : \u2115, f n.unpair.1 n.unpair.2 = \u22c2 (i : \u2115) (j : \u2115), f i j", "start": [216, 1], "end": [218, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Positive/Ring.lean", "imports": ["Mathlib/Algebra/Ring/InjSurj.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Positive.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : { x : M // 0 < x }) : \u2191(x + y) = (x + y : M)", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Positive.addSemigroup", "code": "instance addSemigroup : AddSemigroup { x : M // 0 < x } :=\n  Subtype.coe_injective.addSemigroup _ coe_add", "start": [38, 1], "end": [39, 47], "kind": "commanddeclaration"}, {"full_name": "Positive.addCommSemigroup", "code": "instance addCommSemigroup {M : Type*} [AddCommMonoid M] [Preorder M]\n    [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] : AddCommSemigroup { x : M // 0 < x } :=\n  Subtype.coe_injective.addCommSemigroup _ coe_add", "start": [42, 1], "end": [44, 51], "kind": "commanddeclaration"}, {"full_name": "Positive.addLeftCancelSemigroup", "code": "instance addLeftCancelSemigroup {M : Type*} [AddLeftCancelMonoid M] [Preorder M]\n    [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] : AddLeftCancelSemigroup { x : M // 0 < x } :=\n  Subtype.coe_injective.addLeftCancelSemigroup _ coe_add", "start": [47, 1], "end": [49, 57], "kind": "commanddeclaration"}, {"full_name": "Positive.addRightCancelSemigroup", "code": "instance addRightCancelSemigroup {M : Type*} [AddRightCancelMonoid M] [Preorder M]\n    [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] : AddRightCancelSemigroup { x : M // 0 < x } :=\n  Subtype.coe_injective.addRightCancelSemigroup _ coe_add", "start": [52, 1], "end": [54, 58], "kind": "commanddeclaration"}, {"full_name": "Positive.covariantClass_add_lt", "code": "instance covariantClass_add_lt :\n    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun _ y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_left (show (y : M) < z from hyz) _\u27e9", "start": [57, 1], "end": [59, 91], "kind": "commanddeclaration"}, {"full_name": "Positive.covariantClass_swap_add_lt", "code": "instance covariantClass_swap_add_lt [CovariantClass M M (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun _ y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_right (show (y : M) < z from hyz) _\u27e9", "start": [62, 1], "end": [64, 92], "kind": "commanddeclaration"}, {"full_name": "Positive.contravariantClass_add_lt", "code": "instance contravariantClass_add_lt [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun _ _ _ h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_left h\u27e9", "start": [67, 1], "end": [69, 67], "kind": "commanddeclaration"}, {"full_name": "Positive.contravariantClass_swap_add_lt", "code": "instance contravariantClass_swap_add_lt [ContravariantClass M M (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun _ _ _ h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_right h\u27e9", "start": [72, 1], "end": [74, 68], "kind": "commanddeclaration"}, {"full_name": "Positive.contravariantClass_add_le", "code": "instance contravariantClass_add_le [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ h => Subtype.coe_le_coe.1 <| le_of_add_le_add_left h\u27e9", "start": [77, 1], "end": [79, 67], "kind": "commanddeclaration"}, {"full_name": "Positive.contravariantClass_swap_add_le", "code": "instance contravariantClass_swap_add_le [ContravariantClass M M (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    ContravariantClass { x : M // 0 < x } { x : M // 0 < x } (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ h => Subtype.coe_le_coe.1 <| le_of_add_le_add_right h\u27e9", "start": [82, 1], "end": [84, 68], "kind": "commanddeclaration"}, {"full_name": "Positive.covariantClass_add_le", "code": "instance covariantClass_add_le [AddMonoid M] [PartialOrder M]\n    [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] :\n    CovariantClass { x : M // 0 < x } { x : M // 0 < x } (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8@fun _ _ _ h\u2081 => StrictMono.monotone (fun _ _ h => add_lt_add_left h _) h\u2081\u27e9", "start": [89, 1], "end": [92, 79], "kind": "commanddeclaration"}, {"full_name": "Positive.val_mul", "code": "@[simp]\ntheorem val_mul (x y : { x : R // 0 < x }) : \u2191(x * y) = (x * y : R)", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "Positive.val_pow", "code": "@[simp]\ntheorem val_pow (x : { x : R // 0 < x }) (n : \u2115) :\n    (x ^ n : R) = (x : R) ^ n", "start": [110, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "Positive.val_one", "code": "@[simp]\ntheorem val_one [Nontrivial R] : ((1 : { x : R // 0 < x }) : R) = 1", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "Positive.orderedCommMonoid", "code": "instance orderedCommMonoid [StrictOrderedCommSemiring R] [Nontrivial R] :\n    OrderedCommMonoid { x : R // 0 < x } :=\n  { Subtype.partialOrder _,\n    Subtype.coe_injective.commMonoid (M\u2082 := R) (Subtype.val) val_one val_mul val_pow with\n    mul_le_mul_left := fun _ _ hxy c =>\n      Subtype.coe_le_coe.1 <| mul_le_mul_of_nonneg_left hxy c.2.le }", "start": [137, 1], "end": [142, 69], "kind": "commanddeclaration"}, {"full_name": "Positive.linearOrderedCancelCommMonoid", "code": "instance linearOrderedCancelCommMonoid [LinearOrderedCommSemiring R] :\n    LinearOrderedCancelCommMonoid { x : R // 0 < x } :=\n  { Subtype.linearOrder _, Positive.orderedCommMonoid with\n    le_of_mul_le_mul_left := fun a _ _ h => Subtype.coe_le_coe.1 <| (mul_le_mul_left a.2).1 h }", "start": [145, 1], "end": [150, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Cast/Defs.lean", "imports": ["Mathlib/Data/Rat/Basic.lean", "Mathlib/Data/Rat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.cast_coe_int", "code": "@[simp, norm_cast]\ntheorem cast_coe_int (n : \u2124) : ((n : \u211a) : \u03b1) = n", "start": [40, 1], "end": [42, 81], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_coe_nat", "code": "@[simp, norm_cast]\ntheorem cast_coe_nat (n : \u2115) : ((n : \u211a) : \u03b1) = n", "start": [45, 1], "end": [47, 54], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_zero", "code": "@[simp, norm_cast]\ntheorem cast_zero : ((0 : \u211a) : \u03b1) = 0", "start": [51, 1], "end": [53, 39], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_one", "code": "@[simp, norm_cast]\ntheorem cast_one : ((1 : \u211a) : \u03b1) = 1", "start": [56, 1], "end": [58, 38], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_commute", "code": "theorem cast_commute (r : \u211a) (a : \u03b1) : Commute (\u2191r) a", "start": [61, 1], "end": [62, 81], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_comm", "code": "theorem cast_comm (r : \u211a) (a : \u03b1) : (r : \u03b1) * a = a * r", "start": [65, 1], "end": [66, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.commute_cast", "code": "theorem commute_cast (a : \u03b1) (r : \u211a) : Commute a r", "start": [69, 1], "end": [70, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mk_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_mk_of_ne_zero (a b : \u2124) (b0 : (b : \u03b1) \u2260 0) : (a /. b : \u03b1) = a / b", "start": [73, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_add_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_add_of_ne_zero :\n    \u2200 {m n : \u211a}, (m.den : \u03b1) \u2260 0 \u2192 (n.den : \u03b1) \u2260 0 \u2192 ((m + n : \u211a) : \u03b1) = m + n", "start": [96, 1], "end": [111, 26], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_neg", "code": "@[simp, norm_cast]\ntheorem cast_neg : \u2200 n, ((-n : \u211a) : \u03b1) = -n", "start": [114, 1], "end": [119, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_sub_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_sub_of_ne_zero {m n : \u211a} (m0 : (m.den : \u03b1) \u2260 0) (n0 : (n.den : \u03b1) \u2260 0) :\n    ((m - n : \u211a) : \u03b1) = m - n", "start": [122, 1], "end": [126, 53], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mul_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_mul_of_ne_zero :\n    \u2200 {m n : \u211a}, (m.den : \u03b1) \u2260 0 \u2192 (n.den : \u03b1) \u2260 0 \u2192 ((m * n : \u211a) : \u03b1) = m * n", "start": [129, 1], "end": [142, 49], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_inv_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_inv_of_ne_zero :\n    \u2200 {n : \u211a}, (n.num : \u03b1) \u2260 0 \u2192 (n.den : \u03b1) \u2260 0 \u2192 ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9", "start": [145, 1], "end": [153, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_div_of_ne_zero", "code": "@[norm_cast]\ntheorem cast_div_of_ne_zero {m n : \u211a} (md : (m.den : \u03b1) \u2260 0) (nn : (n.num : \u03b1) \u2260 0)\n    (nd : (n.den : \u03b1) \u2260 0) : ((m / n : \u211a) : \u03b1) = m / n", "start": [156, 1], "end": [165, 98], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_id", "code": "@[norm_cast]\ntheorem cast_id (n : \u211a) : Rat.cast n = n", "start": [171, 1], "end": [172, 48], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_eq_id", "code": "@[simp]\ntheorem cast_eq_id : ((\u2191) : \u211a \u2192 \u211a) = id", "start": [175, 1], "end": [177, 22], "kind": "commanddeclaration"}, {"full_name": "map_ratCast", "code": "@[simp]\ntheorem map_ratCast [DivisionRing \u03b1] [DivisionRing \u03b2] [RingHomClass F \u03b1 \u03b2] (f : F) (q : \u211a) :\n    f q = q", "start": [184, 1], "end": [186, 78], "kind": "commanddeclaration"}, {"full_name": "eq_ratCast", "code": "@[simp]\ntheorem eq_ratCast {k} [DivisionRing k] [RingHomClass F \u211a k] (f : F) (r : \u211a) : f r = r", "start": [189, 1], "end": [191, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_rat'", "code": "theorem ext_rat' (h : \u2200 m : \u2124, f m = g m) : f = g", "start": [199, 1], "end": [204, 12], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_rat", "code": "@[ext]\ntheorem ext_rat {f g : \u211a \u2192*\u2080 M\u2080}\n    (h : f.comp (Int.castRingHom \u211a : \u2124 \u2192*\u2080 \u211a) = g.comp (Int.castRingHom \u211a)) : f = g", "start": [207, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_rat_on_pnat", "code": "theorem ext_rat_on_pnat (same_on_neg_one : f (-1) = g (-1))\n    (same_on_pnat : \u2200 n : \u2115, 0 < n \u2192 f n = g n) : f = g", "start": [216, 1], "end": [224, 44], "kind": "commanddeclaration"}, {"full_name": "RingHom.ext_rat", "code": "theorem RingHom.ext_rat {R : Type*} [Semiring R] [RingHomClass F \u211a R] (f g : F) : f = g", "start": [229, 1], "end": [234, 96], "kind": "commanddeclaration"}, {"full_name": "Rat.subsingleton_ringHom", "code": "instance Rat.subsingleton_ringHom {R : Type*} [Semiring R] : Subsingleton (\u211a \u2192+* R) :=\n  \u27e8RingHom.ext_rat\u27e9", "start": [237, 1], "end": [238, 20], "kind": "commanddeclaration"}, {"full_name": "Rat.distribSMul", "code": "instance (priority := 100) distribSMul : DistribSMul \u211a K where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_zero a := by rw [smul_def, mul_zero]\n  smul_add a x y := by rw [smul_def, smul_def, smul_def, mul_add]", "start": [247, 1], "end": [250, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.isScalarTower_right", "code": "instance isScalarTower_right : IsScalarTower \u211a K K :=\n  \u27e8fun a x y => by simp only [smul_def, smul_eq_mul, mul_assoc]\u27e9", "start": [253, 1], "end": [254, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Sum.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Logic/Embedding/Set.lean", "Mathlib/Data/Finset/Sum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.univ_disjSum_univ", "code": "@[simp]\ntheorem Finset.univ_disjSum_univ {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] :\n    univ.disjSum univ = (univ : Finset (Sum \u03b1 \u03b2))", "start": [29, 1], "end": [32, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_sum", "code": "@[simp]\ntheorem Fintype.card_sum [Fintype \u03b1] [Fintype \u03b2] :\n    Fintype.card (Sum \u03b1 \u03b2) = Fintype.card \u03b1 + Fintype.card \u03b2", "start": [35, 1], "end": [38, 19], "kind": "commanddeclaration"}, {"full_name": "fintypeOfFintypeNe", "code": "def fintypeOfFintypeNe (a : \u03b1) (h : Fintype { b // b \u2260 a }) : Fintype \u03b1 :=\n  Fintype.ofBijective (Sum.elim ((\u2191) : { b // b = a } \u2192 \u03b1) ((\u2191) : { b // b \u2260 a } \u2192 \u03b1)) <| by\n    classical exact (Equiv.sumCompl (\u00b7 = a)).bijective", "start": [41, 1], "end": [44, 55], "kind": "commanddeclaration"}, {"full_name": "image_subtype_ne_univ_eq_image_erase", "code": "theorem image_subtype_ne_univ_eq_image_erase [Fintype \u03b1] [DecidableEq \u03b2] (k : \u03b2) (b : \u03b1 \u2192 \u03b2) :\n    image (fun i : { a // b a \u2260 k } => b \u2191i) univ = (image b univ).erase k", "start": [47, 1], "end": [57, 53], "kind": "commanddeclaration"}, {"full_name": "image_subtype_univ_ssubset_image_univ", "code": "theorem image_subtype_univ_ssubset_image_univ [Fintype \u03b1] [DecidableEq \u03b2] (k : \u03b2) (b : \u03b1 \u2192 \u03b2)\n    (hk : k \u2208 Finset.image b univ) (p : \u03b2 \u2192 Prop) [DecidablePred p] (hp : \u00acp k) :\n    image (fun i : { a // p (b a) } => b \u2191i) univ \u2282 image b univ", "start": [60, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_equiv_extend_of_card_eq", "code": "theorem Finset.exists_equiv_extend_of_card_eq [Fintype \u03b1] [DecidableEq \u03b2] {t : Finset \u03b2}\n    (h\u03b1t : Fintype.card \u03b1 = t.card) {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (hfst : Finset.image f s \u2286 t)\n    (hfs : Set.InjOn f s) : \u2203 g : \u03b1 \u2243 t, \u2200 i \u2208 s, (g i : \u03b2) = f i", "start": [77, 1], "end": [100, 58], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.exists_equiv_extend_of_card_eq", "code": "theorem Set.MapsTo.exists_equiv_extend_of_card_eq [Fintype \u03b1] {t : Finset \u03b2}\n    (h\u03b1t : Fintype.card \u03b1 = t.card) {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hfst : s.MapsTo f t)\n    (hfs : Set.InjOn f s) : \u2203 g : \u03b1 \u2243 t, \u2200 i \u2208 s, (g i : \u03b2) = f i", "start": [103, 1], "end": [115, 19], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_or", "code": "theorem Fintype.card_subtype_or (p q : \u03b1 \u2192 Prop) [Fintype { x // p x }] [Fintype { x // q x }]\n    [Fintype { x // p x \u2228 q x }] :\n    Fintype.card { x // p x \u2228 q x } \u2264 Fintype.card { x // p x } + Fintype.card { x // q x }", "start": [118, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_subtype_or_disjoint", "code": "theorem Fintype.card_subtype_or_disjoint (p q : \u03b1 \u2192 Prop) (h : Disjoint p q) [Fintype { x // p x }]\n    [Fintype { x // q x }] [Fintype { x // p x \u2228 q x }] :\n    Fintype.card { x // p x \u2228 q x } = Fintype.card { x // p x } + Fintype.card { x // q x }", "start": [126, 1], "end": [131, 9], "kind": "commanddeclaration"}, {"full_name": "infinite_sum", "code": "@[simp]\ntheorem infinite_sum : Infinite (Sum \u03b1 \u03b2) \u2194 Infinite \u03b1 \u2228 Infinite \u03b2", "start": [138, 1], "end": [142, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Prod.lean", "imports": ["Mathlib/Data/Finset/Prod.lean", "Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.toFinset_prod", "code": "theorem toFinset_prod (s : Set \u03b1) (t : Set \u03b2) [Fintype s] [Fintype t] [Fintype (s \u00d7\u02e2 t)] :\n    (s \u00d7\u02e2 t).toFinset = s.toFinset \u00d7\u02e2 t.toFinset", "start": [31, 1], "end": [34, 7], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_off_diag", "code": "theorem toFinset_off_diag {s : Set \u03b1} [DecidableEq \u03b1] [Fintype s] [Fintype s.offDiag] :\n    s.offDiag.toFinset = s.toFinset.offDiag", "start": [37, 1], "end": [39, 24], "kind": "commanddeclaration"}, {"full_name": "instFintypeProd", "code": "instance instFintypeProd (\u03b1 \u03b2 : Type*) [Fintype \u03b1] [Fintype \u03b2] : Fintype (\u03b1 \u00d7 \u03b2) :=\n  \u27e8univ \u00d7\u02e2 univ, fun \u27e8a, b\u27e9 => by simp\u27e9", "start": [44, 1], "end": [45, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_product_univ", "code": "@[simp]\ntheorem Finset.univ_product_univ {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] :\n    (univ : Finset \u03b1) \u00d7\u02e2 (univ : Finset \u03b2) = univ", "start": [47, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_prod", "code": "@[simp]\ntheorem Fintype.card_prod (\u03b1 \u03b2 : Type*) [Fintype \u03b1] [Fintype \u03b2] :\n    Fintype.card (\u03b1 \u00d7 \u03b2) = Fintype.card \u03b1 * Fintype.card \u03b2", "start": [53, 1], "end": [56, 19], "kind": "commanddeclaration"}, {"full_name": "infinite_prod", "code": "@[simp]\ntheorem infinite_prod : Infinite (\u03b1 \u00d7 \u03b2) \u2194 Infinite \u03b1 \u2227 Nonempty \u03b2 \u2228 Nonempty \u03b1 \u2227 Infinite \u03b2", "start": [63, 1], "end": [71, 17], "kind": "commanddeclaration"}, {"full_name": "Pi.infinite_of_left", "code": "instance Pi.infinite_of_left {\u03b9 : Sort*} {\u03c0 : \u03b9 \u2192 Sort _} [\u2200 i, Nontrivial <| \u03c0 i] [Infinite \u03b9] :\n    Infinite (\u2200 i : \u03b9, \u03c0 i) := by\n  choose m n hm using fun i => exists_pair_ne (\u03c0 i)\n  refine' Infinite.of_injective (fun i => update m i (n i)) fun x y h => of_not_not fun hne => _\n  simp_rw [update_eq_iff, update_noteq hne] at h\n  exact (hm x h.1.symm).elim", "start": [74, 1], "end": [79, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.infinite_of_exists_right", "code": "theorem Pi.infinite_of_exists_right {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} (i : \u03b9) [Infinite <| \u03c0 i]\n    [\u2200 i, Nonempty <| \u03c0 i] : Infinite (\u2200 i : \u03b9, \u03c0 i)", "start": [82, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "Pi.infinite_of_right", "code": "instance Pi.infinite_of_right {\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} [\u2200 i, Infinite <| \u03c0 i] [Nonempty \u03b9] :\n    Infinite (\u2200 i : \u03b9, \u03c0 i) :=\n  Pi.infinite_of_exists_right (Classical.arbitrary \u03b9)", "start": [89, 1], "end": [92, 54], "kind": "commanddeclaration"}, {"full_name": "Function.infinite_of_left", "code": "instance Function.infinite_of_left {\u03b9 \u03c0 : Sort _} [Nontrivial \u03c0] [Infinite \u03b9] : Infinite (\u03b9 \u2192 \u03c0) :=\n  Pi.infinite_of_left", "start": [95, 1], "end": [97, 22], "kind": "commanddeclaration"}, {"full_name": "Function.infinite_of_right", "code": "instance Function.infinite_of_right {\u03b9 \u03c0 : Sort _} [Infinite \u03c0] [Nonempty \u03b9] : Infinite (\u03b9 \u2192 \u03c0) :=\n  Pi.infinite_of_right", "start": [100, 1], "end": [102, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Powerset.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Data/Finset/Powerset.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.fintype", "code": "instance Finset.fintype [Fintype \u03b1] : Fintype (Finset \u03b1) :=\n  \u27e8univ.powerset, fun _ => Finset.mem_powerset.2 (Finset.subset_univ _)\u27e9", "start": [20, 1], "end": [21, 73], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_finset", "code": "@[simp]\ntheorem Fintype.card_finset [Fintype \u03b1] : Fintype.card (Finset \u03b1) = 2 ^ Fintype.card \u03b1", "start": [24, 1], "end": [26, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.powerset_univ", "code": "@[simp] lemma powerset_univ : (univ : Finset \u03b1).powerset = univ :=\n  coe_injective <| by simp [-coe_eq_univ]", "start": [32, 1], "end": [33, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.filter_subset_univ", "code": "lemma filter_subset_univ [DecidableEq \u03b1] (s : Finset \u03b1) :\n    filter (fun t \u21a6 t \u2286 s) univ = powerset s := by ext; simp", "start": [36, 1], "end": [37, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.powerset_eq_univ", "code": "@[simp] lemma powerset_eq_univ : s.powerset = univ \u2194 s = univ := by\n  rw [\u2190 Finset.powerset_univ, powerset_inj]", "start": [39, 1], "end": [40, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.mem_powersetCard_univ", "code": "@[simp] lemma mem_powersetCard_univ : s \u2208 powersetCard k (univ : Finset \u03b1) \u2194 card s = k :=\n  mem_powersetCard.trans <| and_iff_right <| subset_univ _", "start": [43, 1], "end": [44, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.univ_filter_card_eq", "code": "@[simp] lemma univ_filter_card_eq (k : \u2115) :\n    (univ : Finset (Finset \u03b1)).filter (fun s \u21a6 s.card = k) = univ.powersetCard k := by ext; simp", "start": [49, 1], "end": [50, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.card_finset_len", "code": "@[simp]\ntheorem Fintype.card_finset_len [Fintype \u03b1] (k : \u2115) :\n    Fintype.card { s : Finset \u03b1 // s.card = k } = Nat.choose (Fintype.card \u03b1) k", "start": [55, 1], "end": [58, 48], "kind": "commanddeclaration"}, {"full_name": "Set.fintype", "code": "instance Set.fintype [Fintype \u03b1] : Fintype (Set \u03b1) :=\n  \u27e8(@Finset.univ \u03b1 _).powerset.map \u27e8(\u2191), coe_injective\u27e9, fun s => by\n    classical\n      refine' mem_map.2 \u27e8Finset.univ.filter s, Finset.mem_powerset.2 (Finset.subset_univ _), _\u27e9\n      apply (coe_filter _ _).trans\n      simp\n      rfl\u27e9", "start": [61, 1], "end": [67, 11], "kind": "commanddeclaration"}, {"full_name": "Set.finite'", "code": "instance Set.finite' [Finite \u03b1] : Finite (Set \u03b1) := by\n  cases nonempty_fintype \u03b1\n  infer_instance", "start": [71, 1], "end": [73, 17], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_set", "code": "@[simp]\ntheorem Fintype.card_set [Fintype \u03b1] : Fintype.card (Set \u03b1) = 2 ^ Fintype.card \u03b1", "start": [76, 1], "end": [78, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Vector.lean", "imports": ["Mathlib/Data/Fintype/Pi.lean", "Mathlib/Data/Sym/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Vector.fintype", "code": "instance Vector.fintype [Fintype \u03b1] {n : \u2115} : Fintype (Vector \u03b1 n) :=\n  Fintype.ofEquiv _ (Equiv.vectorEquivFin _ _).symm", "start": [17, 1], "end": [18, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Sigma.lean", "imports": ["Mathlib/Data/Finset/Sigma.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.univ_sigma_univ", "code": "@[simp]\ntheorem Finset.univ_sigma_univ {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [Fintype \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    ((univ : Finset \u03b1).sigma fun a => (univ : Finset (\u03b2 a))) = univ", "start": [29, 1], "end": [32, 6], "kind": "commanddeclaration"}, {"full_name": "PSigma.fintype", "code": "instance PSigma.fintype {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [Fintype \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    Fintype (\u03a3'a, \u03b2 a) :=\n  Fintype.ofEquiv _ (Equiv.psigmaEquivSigma _).symm", "start": [35, 1], "end": [37, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Nat.lean", "imports": ["Mathlib/Data/Nat/Pairing.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.boolProdNatEquivNat", "code": "@[simps]\ndef boolProdNatEquivNat : Bool \u00d7 \u2115 \u2243 \u2115 where\n  toFun := uncurry bit\n  invFun := boddDiv2\n  left_inv := fun \u27e8b, n\u27e9 => by simp only [bodd_bit, div2_bit, uncurry_apply_pair, boddDiv2_eq]\n  right_inv n := by simp only [bit_decomp, boddDiv2_eq, uncurry_apply_pair]", "start": [24, 1], "end": [31, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.natSumNatEquivNat", "code": "@[simps! symm_apply]\ndef natSumNatEquivNat : \u2115 \u2295 \u2115 \u2243 \u2115 :=\n  (boolProdEquivSum \u2115).symm.trans boolProdNatEquivNat", "start": [36, 1], "end": [41, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.natSumNatEquivNat_apply", "code": "@[simp]\ntheorem natSumNatEquivNat_apply : \u21d1natSumNatEquivNat = Sum.elim bit0 bit1", "start": [46, 1], "end": [48, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.intEquivNat", "code": "def intEquivNat : \u2124 \u2243 \u2115 :=\n  intEquivNatSumNat.trans natSumNatEquivNat", "start": [51, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodEquivOfEquivNat", "code": "def prodEquivOfEquivNat (e : \u03b1 \u2243 \u2115) : \u03b1 \u00d7 \u03b1 \u2243 \u03b1 :=\n  calc\n    \u03b1 \u00d7 \u03b1 \u2243 \u2115 \u00d7 \u2115 := prodCongr e e\n    _ \u2243 \u2115 := pairEquiv\n    _ \u2243 \u03b1 := e.symm", "start": [57, 1], "end": [63, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/PNat/Basic.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Data/PNat/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Data/Nat/Bits.lean", "Mathlib/Algebra/Order/Positive/Ring.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "PNat.one_add_natPred", "code": "@[simp]\ntheorem one_add_natPred (n : \u2115+) : 1 + n.natPred = n", "start": [34, 1], "end": [36, 72], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_add_one", "code": "@[simp]\ntheorem natPred_add_one (n : \u2115+) : n.natPred + 1 = n", "start": [39, 1], "end": [41, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_strictMono", "code": "@[mono]\ntheorem natPred_strictMono : StrictMono natPred", "start": [44, 1], "end": [45, 91], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_monotone", "code": "@[mono]\ntheorem natPred_monotone : Monotone natPred", "start": [48, 1], "end": [50, 30], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_injective", "code": "theorem natPred_injective : Function.Injective natPred", "start": [53, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_lt_natPred", "code": "@[simp]\ntheorem natPred_lt_natPred {m n : \u2115+} : m.natPred < n.natPred \u2194 m < n", "start": [57, 1], "end": [59, 31], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_le_natPred", "code": "@[simp]\ntheorem natPred_le_natPred {m n : \u2115+} : m.natPred \u2264 n.natPred \u2194 m \u2264 n", "start": [62, 1], "end": [64, 31], "kind": "commanddeclaration"}, {"full_name": "PNat.natPred_inj", "code": "@[simp]\ntheorem natPred_inj {m n : \u2115+} : m.natPred = n.natPred \u2194 m = n", "start": [67, 1], "end": [69, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_strictMono", "code": "@[mono]\ntheorem succPNat_strictMono : StrictMono succPNat", "start": [76, 1], "end": [77, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_mono", "code": "@[mono]\ntheorem succPNat_mono : Monotone succPNat", "start": [80, 1], "end": [82, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_lt_succPNat", "code": "@[simp]\ntheorem succPNat_lt_succPNat {m n : \u2115} : m.succPNat < n.succPNat \u2194 m < n", "start": [85, 1], "end": [87, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_le_succPNat", "code": "@[simp]\ntheorem succPNat_le_succPNat {m n : \u2115} : m.succPNat \u2264 n.succPNat \u2194 m \u2264 n", "start": [90, 1], "end": [92, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_injective", "code": "theorem succPNat_injective : Function.Injective succPNat", "start": [95, 1], "end": [96, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.succPNat_inj", "code": "@[simp]\ntheorem succPNat_inj {n m : \u2115} : succPNat n = succPNat m \u2194 n = m", "start": [99, 1], "end": [101, 28], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj {m n : \u2115+} : (m : \u2115) = n \u2194 m = n", "start": [110, 1], "end": [117, 17], "kind": "commanddeclaration"}, {"full_name": "PNat.add_coe", "code": "@[simp, norm_cast]\ntheorem add_coe (m n : \u2115+) : ((m + n : \u2115+) : \u2115) = m + n", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.coeAddHom", "code": "def coeAddHom : AddHom \u2115+ \u2115 where\n  toFun := Coe.coe\n  map_add' := add_coe", "start": [125, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "PNat.covariantClass_add_le", "code": "instance covariantClass_add_le : CovariantClass \u2115+ \u2115+ (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  Positive.covariantClass_add_le", "start": [131, 1], "end": [132, 33], "kind": "commanddeclaration"}, {"full_name": "PNat.covariantClass_add_lt", "code": "instance covariantClass_add_lt : CovariantClass \u2115+ \u2115+ (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  Positive.covariantClass_add_lt", "start": [134, 1], "end": [135, 33], "kind": "commanddeclaration"}, {"full_name": "PNat.contravariantClass_add_le", "code": "instance contravariantClass_add_le : ContravariantClass \u2115+ \u2115+ (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  Positive.contravariantClass_add_le", "start": [137, 1], "end": [138, 37], "kind": "commanddeclaration"}, {"full_name": "PNat.contravariantClass_add_lt", "code": "instance contravariantClass_add_lt : ContravariantClass \u2115+ \u2115+ (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  Positive.contravariantClass_add_lt", "start": [140, 1], "end": [141, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.pnatEquivNat", "code": "@[simps (config := { fullyApplied := false })]\ndef _root_.Equiv.pnatEquivNat : \u2115+ \u2243 \u2115 where\n  toFun := PNat.natPred\n  invFun := Nat.succPNat\n  left_inv := succPNat_natPred\n  right_inv := Nat.natPred_succPNat", "start": [143, 1], "end": [149, 36], "kind": "commanddeclaration"}, {"full_name": "OrderIso.pnatIsoNat", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef _root_.OrderIso.pnatIsoNat : \u2115+ \u2243o \u2115 where\n  toEquiv := Equiv.pnatEquivNat\n  map_rel_iff' := natPred_le_natPred", "start": [154, 1], "end": [158, 37], "kind": "commanddeclaration"}, {"full_name": "OrderIso.pnatIsoNat_symm_apply", "code": "@[simp]\ntheorem _root_.OrderIso.pnatIsoNat_symm_apply : OrderIso.pnatIsoNat.symm = Nat.succPNat", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.lt_add_one_iff", "code": "theorem lt_add_one_iff : \u2200 {a b : \u2115+}, a < b + 1 \u2194 a \u2264 b", "start": [167, 1], "end": [167, 79], "kind": "commanddeclaration"}, {"full_name": "PNat.add_one_le_iff", "code": "theorem add_one_le_iff : \u2200 {a b : \u2115+}, a + 1 \u2264 b \u2194 a < b", "start": [170, 1], "end": [170, 79], "kind": "commanddeclaration"}, {"full_name": "PNat.bot_eq_one", "code": "@[simp]\ntheorem bot_eq_one : (\u22a5 : \u2115+) = 1", "start": [177, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_bit0", "code": "@[simp, deprecated]\ntheorem mk_bit0 (n) {h} : (\u27e8bit0 n, h\u27e9 : \u2115+) = (bit0 \u27e8n, pos_of_bit0_pos h\u27e9 : \u2115+)", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.mk_bit1", "code": "@[simp, deprecated]\ntheorem mk_bit1 (n) {h} {k} : (\u27e8bit1 n, h\u27e9 : \u2115+) = (bit1 \u27e8n, k\u27e9 : \u2115+)", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.bit0_le_bit0", "code": "@[simp, deprecated]\ntheorem bit0_le_bit0 (n m : \u2115+) : bit0 n \u2264 bit0 m \u2194 bit0 (n : \u2115) \u2264 bit0 (m : \u2115)", "start": [205, 1], "end": [207, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.bit0_le_bit1", "code": "@[simp, deprecated]\ntheorem bit0_le_bit1 (n m : \u2115+) : bit0 n \u2264 bit1 m \u2194 bit0 (n : \u2115) \u2264 bit1 (m : \u2115)", "start": [210, 1], "end": [212, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.bit1_le_bit0", "code": "@[simp, deprecated]\ntheorem bit1_le_bit0 (n m : \u2115+) : bit1 n \u2264 bit0 m \u2194 bit1 (n : \u2115) \u2264 bit0 (m : \u2115)", "start": [215, 1], "end": [217, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.bit1_le_bit1", "code": "@[simp, deprecated]\ntheorem bit1_le_bit1 (n m : \u2115+) : bit1 n \u2264 bit1 m \u2194 bit1 (n : \u2115) \u2264 bit1 (m : \u2115)", "start": [220, 1], "end": [222, 10], "kind": "commanddeclaration"}, {"full_name": "PNat.mul_coe", "code": "@[simp, norm_cast]\ntheorem mul_coe (m n : \u2115+) : ((m * n : \u2115+) : \u2115) = m * n", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.coeMonoidHom", "code": "def coeMonoidHom : \u2115+ \u2192* \u2115 where\n  toFun := Coe.coe\n  map_one' := one_coe\n  map_mul' := mul_coe", "start": [232, 1], "end": [236, 22], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_coeMonoidHom", "code": "@[simp]\ntheorem coe_coeMonoidHom : (coeMonoidHom : \u2115+ \u2192 \u2115) = Coe.coe", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.le_one_iff", "code": "@[simp]\ntheorem le_one_iff {n : \u2115+} : n \u2264 1 \u2194 n = 1", "start": [244, 1], "end": [246, 13], "kind": "commanddeclaration"}, {"full_name": "PNat.lt_add_left", "code": "theorem lt_add_left (n m : \u2115+) : n < m + n", "start": [249, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "PNat.lt_add_right", "code": "theorem lt_add_right (n m : \u2115+) : n < n + m", "start": [253, 1], "end": [254, 44], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_bit0", "code": "@[simp, norm_cast, deprecated]\ntheorem coe_bit0 (a : \u2115+) : ((bit0 a : \u2115+) : \u2115) = bit0 (a : \u2115)", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.coe_bit1", "code": "@[simp, norm_cast, deprecated]\ntheorem coe_bit1 (a : \u2115+) : ((bit1 a : \u2115+) : \u2115) = bit1 (a : \u2115)", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.pow_coe", "code": "@[simp, norm_cast]\ntheorem pow_coe (m : \u2115+) (n : \u2115) : (m ^ n : \u2115) = (m : \u2115) ^ n", "start": [274, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.sub_coe", "code": "theorem sub_coe (a b : \u2115+) : ((a - b : \u2115+) : \u2115) = ite (b < a) (a - b : \u2115) 1", "start": [285, 1], "end": [290, 8], "kind": "commanddeclaration"}, {"full_name": "PNat.add_sub_of_lt", "code": "theorem add_sub_of_lt {a b : \u2115+} : a < b \u2192 a + (b - a) = b", "start": [293, 1], "end": [297, 39], "kind": "commanddeclaration"}, {"full_name": "PNat.exists_eq_succ_of_ne_one", "code": "theorem exists_eq_succ_of_ne_one : \u2200 {n : \u2115+} (_ : n \u2260 1), \u2203 k : \u2115+, n = k + 1", "start": [300, 1], "end": [303, 45], "kind": "commanddeclaration"}, {"full_name": "PNat.caseStrongInductionOn", "code": "def caseStrongInductionOn {p : \u2115+ \u2192 Sort*} (a : \u2115+) (hz : p 1)\n    (hi : \u2200 n, (\u2200 m, m \u2264 n \u2192 p m) \u2192 p (n + 1)) : p a := by\n  apply strongInductionOn a\n  rintro \u27e8k, kprop\u27e9 hk\n  cases' k with k\n  \u00b7 exact (lt_irrefl 0 kprop).elim\n  cases' k with k\n  \u00b7 exact hz\n  exact hi \u27e8k.succ, Nat.succ_pos _\u27e9 fun m hm => hk _ (lt_succ_iff.2 hm)", "start": [306, 1], "end": [315, 72], "kind": "commanddeclaration"}, {"full_name": "PNat.recOn", "code": "@[elab_as_elim]\ndef recOn (n : \u2115+) {p : \u2115+ \u2192 Sort*} (p1 : p 1) (hp : \u2200 n, p n \u2192 p (n + 1)) : p n := by\n  rcases n with \u27e8n, h\u27e9\n  induction' n with n IH\n  \u00b7 exact absurd h (by decide)\n  \u00b7 cases' n with n\n    \u00b7 exact p1\n    \u00b7 exact hp _ (IH n.succ_pos)", "start": [318, 1], "end": [327, 33], "kind": "commanddeclaration"}, {"full_name": "PNat.recOn_one", "code": "@[simp]\ntheorem recOn_one {p} (p1 hp) : @PNat.recOn 1 p p1 hp = p1", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "PNat.recOn_succ", "code": "@[simp]\ntheorem recOn_succ (n : \u2115+) {p : \u2115+ \u2192 Sort*} (p1 hp) :\n    @PNat.recOn (n + 1) p p1 hp = hp n (@PNat.recOn n p p1 hp)", "start": [335, 1], "end": [339, 48], "kind": "commanddeclaration"}, {"full_name": "PNat.modDivAux_spec", "code": "theorem modDivAux_spec :\n    \u2200 (k : \u2115+) (r q : \u2115) (_ : \u00ac(r = 0 \u2227 q = 0)),\n      ((modDivAux k r q).1 : \u2115) + k * (modDivAux k r q).2 = r + k * q", "start": [342, 1], "end": [349, 26], "kind": "commanddeclaration"}, {"full_name": "PNat.mod_add_div", "code": "theorem mod_add_div (m k : \u2115+) : (mod m k + k * div m k : \u2115) = m", "start": [352, 1], "end": [359, 22], "kind": "commanddeclaration"}, {"full_name": "PNat.div_add_mod", "code": "theorem div_add_mod (m k : \u2115+) : (k * div m k + mod m k : \u2115) = m", "start": [362, 1], "end": [363, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.mod_add_div'", "code": "theorem mod_add_div' (m k : \u2115+) : (mod m k + div m k * k : \u2115) = m", "start": [366, 1], "end": [368, 24], "kind": "commanddeclaration"}, {"full_name": "PNat.div_add_mod'", "code": "theorem div_add_mod' (m k : \u2115+) : (div m k * k + mod m k : \u2115) = m", "start": [371, 1], "end": [373, 24], "kind": "commanddeclaration"}, {"full_name": "PNat.mod_le", "code": "theorem mod_le (m k : \u2115+) : mod m k \u2264 m \u2227 mod m k \u2264 k", "start": [376, 1], "end": [391, 70], "kind": "commanddeclaration"}, {"full_name": "PNat.dvd_iff", "code": "theorem dvd_iff {k m : \u2115+} : k \u2223 m \u2194 (k : \u2115) \u2223 (m : \u2115)", "start": [394, 1], "end": [405, 41], "kind": "commanddeclaration"}, {"full_name": "PNat.dvd_iff'", "code": "theorem dvd_iff' {k m : \u2115+} : k \u2223 m \u2194 mod m k = k", "start": [408, 1], "end": [419, 51], "kind": "commanddeclaration"}, {"full_name": "PNat.le_of_dvd", "code": "theorem le_of_dvd {m n : \u2115+} : m \u2223 n \u2192 m \u2264 n", "start": [422, 1], "end": [426, 26], "kind": "commanddeclaration"}, {"full_name": "PNat.mul_div_exact", "code": "theorem mul_div_exact {m k : \u2115+} (h : k \u2223 m) : k * divExact m k = m", "start": [429, 1], "end": [432, 54], "kind": "commanddeclaration"}, {"full_name": "PNat.dvd_antisymm", "code": "theorem dvd_antisymm {m n : \u2115+} : m \u2223 n \u2192 n \u2223 m \u2192 m = n", "start": [435, 1], "end": [436, 43], "kind": "commanddeclaration"}, {"full_name": "PNat.dvd_one_iff", "code": "theorem dvd_one_iff (n : \u2115+) : n \u2223 1 \u2194 n = 1", "start": [439, 1], "end": [440, 70], "kind": "commanddeclaration"}, {"full_name": "PNat.pos_of_div_pos", "code": "theorem pos_of_div_pos {n : \u2115+} {a : \u2115} (h : a \u2223 n) : 0 < a", "start": [443, 1], "end": [447, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Countable/Defs.lean", "imports": ["Mathlib/Data/Finite/Defs.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Countable", "code": "@[mk_iff countable_iff_exists_injective]\nclass Countable (\u03b1 : Sort u) : Prop where\n  \n  exists_injective_nat' : \u2203 f : \u03b1 \u2192 \u2115, Injective f", "start": [32, 1], "end": [36, 51], "kind": "commanddeclaration"}, {"full_name": "Countable.exists_injective_nat", "code": "lemma Countable.exists_injective_nat (\u03b1 : Sort u) [Countable \u03b1] : \u2203 f : \u03b1 \u2192 \u2115, Injective f :=\n  Countable.exists_injective_nat'", "start": [40, 1], "end": [41, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.countable", "code": "protected theorem Function.Injective.countable [Countable \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Countable \u03b1", "start": [48, 1], "end": [51, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.countable", "code": "protected theorem Function.Surjective.countable [Countable \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) :\n    Countable \u03b2", "start": [54, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "exists_surjective_nat", "code": "theorem exists_surjective_nat (\u03b1 : Sort u) [Nonempty \u03b1] [Countable \u03b1] : \u2203 f : \u2115 \u2192 \u03b1, Surjective f", "start": [59, 1], "end": [61, 35], "kind": "commanddeclaration"}, {"full_name": "countable_iff_exists_surjective", "code": "theorem countable_iff_exists_surjective [Nonempty \u03b1] : Countable \u03b1 \u2194 \u2203 f : \u2115 \u2192 \u03b1, Surjective f", "start": [64, 1], "end": [65, 59], "kind": "commanddeclaration"}, {"full_name": "Countable.of_equiv", "code": "theorem Countable.of_equiv (\u03b1 : Sort*) [Countable \u03b1] (e : \u03b1 \u2243 \u03b2) : Countable \u03b2", "start": [68, 1], "end": [69, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.countable_iff", "code": "theorem Equiv.countable_iff (e : \u03b1 \u2243 \u03b2) : Countable \u03b1 \u2194 Countable \u03b2", "start": [72, 1], "end": [73, 84], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.to_countable", "code": "instance (priority := 100) Subsingleton.to_countable [Subsingleton \u03b1] : Countable \u03b1 :=\n  \u27e8\u27e8fun _ => 0, fun x y _ => Subsingleton.elim x y\u27e9\u27e9", "start": [87, 1], "end": [88, 53], "kind": "commanddeclaration"}, {"full_name": "Subtype.countable", "code": "instance (priority := 500) Subtype.countable [Countable \u03b1] {p : \u03b1 \u2192 Prop} :\n    Countable { x // p x } :=\n  Subtype.val_injective.countable", "start": [90, 1], "end": [92, 34], "kind": "commanddeclaration"}, {"full_name": "Finite.to_countable", "code": "instance (priority := 100) Finite.to_countable [Finite \u03b1] : Countable \u03b1 :=\n  let \u27e8_, \u27e8e\u27e9\u27e9 := Finite.exists_equiv_fin \u03b1\n  Countable.of_equiv _ e.symm", "start": [97, 1], "end": [99, 30], "kind": "commanddeclaration"}, {"full_name": "Prop.countable", "code": "instance (priority := 100) Prop.countable (p : Prop) : Countable p :=\n  Subsingleton.to_countable", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "Bool.countable", "code": "instance Bool.countable : Countable Bool :=\n  \u27e8\u27e8fun b => cond b 0 1, Bool.injective_iff.2 Nat.one_ne_zero\u27e9\u27e9", "start": [107, 1], "end": [108, 64], "kind": "commanddeclaration"}, {"full_name": "Prop.countable'", "code": "instance Prop.countable' : Countable Prop :=\n  Countable.of_equiv Bool Equiv.propEquivBool.symm", "start": [110, 1], "end": [111, 51], "kind": "commanddeclaration"}, {"full_name": "Quotient.countable", "code": "instance (priority := 500) Quotient.countable [Countable \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    Countable (Quot r) :=\n  (surjective_quot_mk r).countable", "start": [113, 1], "end": [115, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Pi.lean", "imports": ["Mathlib/Algebra/Group/Pi.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.smul'", "code": "@[to_additive]\ninstance smul' {g : I \u2192 Type*} [\u2200 i, SMul (f i) (g i)] : SMul (\u2200 i, f i) (\u2200 i : I, g i) :=\n  \u27e8fun s x => fun i => s i \u2022 x i\u27e9", "start": [37, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "Pi.smul_apply'", "code": "@[to_additive (attr := simp)]\ntheorem smul_apply' {g : I \u2192 Type*} [\u2200 i, SMul (f i) (g i)] (s : \u2200 i, f i) (x : \u2200 i, g i) :\n    (s \u2022 x) i = s i \u2022 x i", "start": [43, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.isScalarTower", "code": "@[to_additive Pi.vaddAssocClass]\ninstance isScalarTower {\u03b1 \u03b2 : Type*} [SMul \u03b1 \u03b2] [\u2200 i, SMul \u03b2 <| f i]\n    [\u2200 i, SMul \u03b1 <| f i] [\u2200 i, IsScalarTower \u03b1 \u03b2 (f i)] : IsScalarTower \u03b1 \u03b2 (\u2200 i : I, f i) :=\n  \u27e8fun x y z => funext fun i => smul_assoc x y (z i)\u27e9", "start": [51, 1], "end": [54, 54], "kind": "commanddeclaration"}, {"full_name": "Pi.isScalarTower'", "code": "@[to_additive Pi.vaddAssocClass']\ninstance isScalarTower' {g : I \u2192 Type*} {\u03b1 : Type*} [\u2200 i, SMul \u03b1 <| f i]\n    [\u2200 i, SMul (f i) (g i)] [\u2200 i, SMul \u03b1 <| g i] [\u2200 i, IsScalarTower \u03b1 (f i) (g i)] :\n    IsScalarTower \u03b1 (\u2200 i : I, f i) (\u2200 i : I, g i) :=\n  \u27e8fun x y z => funext fun i => smul_assoc x (y i) (z i)\u27e9", "start": [58, 1], "end": [62, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.isScalarTower''", "code": "@[to_additive Pi.vaddAssocClass'']\ninstance isScalarTower'' {g : I \u2192 Type*} {h : I \u2192 Type*} [\u2200 i, SMul (f i) (g i)]\n    [\u2200 i, SMul (g i) (h i)] [\u2200 i, SMul (f i) (h i)] [\u2200 i, IsScalarTower (f i) (g i) (h i)] :\n    IsScalarTower (\u2200 i, f i) (\u2200 i, g i) (\u2200 i, h i) :=\n  \u27e8fun x y z => funext fun i => smul_assoc (x i) (y i) (z i)\u27e9", "start": [66, 1], "end": [70, 62], "kind": "commanddeclaration"}, {"full_name": "Pi.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass {\u03b1 \u03b2 : Type*} [\u2200 i, SMul \u03b1 <| f i] [\u2200 i, SMul \u03b2 <| f i]\n    [\u2200 i, SMulCommClass \u03b1 \u03b2 (f i)] : SMulCommClass \u03b1 \u03b2 (\u2200 i : I, f i) :=\n  \u27e8fun x y z => funext fun i => smul_comm x y (z i)\u27e9", "start": [74, 1], "end": [77, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.smulCommClass'", "code": "@[to_additive]\ninstance smulCommClass' {g : I \u2192 Type*} {\u03b1 : Type*} [\u2200 i, SMul \u03b1 <| g i]\n    [\u2200 i, SMul (f i) (g i)] [\u2200 i, SMulCommClass \u03b1 (f i) (g i)] :\n    SMulCommClass \u03b1 (\u2200 i : I, f i) (\u2200 i : I, g i) :=\n  \u27e8fun x y z => funext fun i => smul_comm x (y i) (z i)\u27e9", "start": [81, 1], "end": [85, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.smulCommClass''", "code": "@[to_additive]\ninstance smulCommClass'' {g : I \u2192 Type*} {h : I \u2192 Type*} [\u2200 i, SMul (g i) (h i)]\n    [\u2200 i, SMul (f i) (h i)] [\u2200 i, SMulCommClass (f i) (g i) (h i)] :\n    SMulCommClass (\u2200 i, f i) (\u2200 i, g i) (\u2200 i, h i) :=\n  \u27e8fun x y z => funext fun i => smul_comm (x i) (y i) (z i)\u27e9", "start": [89, 1], "end": [93, 61], "kind": "commanddeclaration"}, {"full_name": "Pi.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar {\u03b1 : Type*} [\u2200 i, SMul \u03b1 <| f i] [\u2200 i, SMul \u03b1\u1d50\u1d52\u1d56 <| f i]\n    [\u2200 i, IsCentralScalar \u03b1 (f i)] : IsCentralScalar \u03b1 (\u2200 i, f i) :=\n  \u27e8fun _ _ => funext fun _ => op_smul_eq_smul _ _\u27e9", "start": [97, 1], "end": [100, 51], "kind": "commanddeclaration"}, {"full_name": "Pi.faithfulSMul_at", "code": "@[to_additive\n  \"If `f i` has a faithful additive action for a given `i`, then\n  so does `\u03a0 i, f i`. This is not an instance as `i` cannot be inferred\"]\ntheorem faithfulSMul_at {\u03b1 : Type*} [\u2200 i, SMul \u03b1 <| f i] [\u2200 i, Nonempty (f i)] (i : I)\n    [FaithfulSMul \u03b1 (f i)] : FaithfulSMul \u03b1 (\u2200 i, f i)", "start": [102, 1], "end": [115, 26], "kind": "commanddeclaration"}, {"full_name": "Pi.faithfulSMul", "code": "@[to_additive]\ninstance faithfulSMul {\u03b1 : Type*} [Nonempty I] [\u2200 i, SMul \u03b1 <| f i] [\u2200 i, Nonempty (f i)]\n    [\u2200 i, FaithfulSMul \u03b1 (f i)] : FaithfulSMul \u03b1 (\u2200 i, f i) :=\n  let \u27e8i\u27e9 := \u2039Nonempty I\u203a\n  faithfulSMul_at i", "start": [119, 1], "end": [123, 20], "kind": "commanddeclaration"}, {"full_name": "Pi.mulAction", "code": "@[to_additive]\ninstance mulAction (\u03b1) {m : Monoid \u03b1} [\u2200 i, MulAction \u03b1 <| f i] :\n    @MulAction \u03b1 (\u2200 i : I, f i) m where\n  smul := (\u00b7 \u2022 \u00b7)\n  mul_smul _ _ _ := funext fun _ => mul_smul _ _ _\n  one_smul _ := funext fun _ => one_smul \u03b1 _", "start": [127, 1], "end": [132, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.mulAction'", "code": "@[to_additive]\ninstance mulAction' {g : I \u2192 Type*} {m : \u2200 i, Monoid (f i)} [\u2200 i, MulAction (f i) (g i)] :\n    @MulAction (\u2200 i, f i) (\u2200 i : I, g i)\n      (@Pi.monoid I f m) where\n  smul := (\u00b7 \u2022 \u00b7)\n  mul_smul _ _ _ := funext fun _ => mul_smul _ _ _\n  one_smul _ := funext fun _ => one_smul _ _", "start": [136, 1], "end": [142, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.smulZeroClass", "code": "instance smulZeroClass (\u03b1) {n : \u2200 i, Zero <| f i} [\u2200 i, SMulZeroClass \u03b1 <| f i] :\n  @SMulZeroClass \u03b1 (\u2200 i : I, f i) (@Pi.instZero I f n) where\n  smul_zero _ := funext fun _ => smul_zero _", "start": [146, 1], "end": [148, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.smulZeroClass'", "code": "instance smulZeroClass' {g : I \u2192 Type*} {n : \u2200 i, Zero <| g i} [\u2200 i, SMulZeroClass (f i) (g i)] :\n  @SMulZeroClass (\u2200 i, f i) (\u2200 i : I, g i) (@Pi.instZero I g n) where\n  smul_zero := by intros; ext x; exact smul_zero _", "start": [151, 1], "end": [153, 51], "kind": "commanddeclaration"}, {"full_name": "Pi.distribSMul", "code": "instance distribSMul (\u03b1) {n : \u2200 i, AddZeroClass <| f i} [\u2200 i, DistribSMul \u03b1 <| f i] :\n  @DistribSMul \u03b1 (\u2200 i : I, f i) (@Pi.addZeroClass I f n) where\n  smul_zero _ := funext fun _ => smul_zero _\n  smul_add _ _ _ := funext fun _ => smul_add _ _ _", "start": [156, 1], "end": [159, 51], "kind": "commanddeclaration"}, {"full_name": "Pi.distribSMul'", "code": "instance distribSMul' {g : I \u2192 Type*} {n : \u2200 i, AddZeroClass <| g i}\n  [\u2200 i, DistribSMul (f i) (g i)] :\n  @DistribSMul (\u2200 i, f i) (\u2200 i : I, g i) (@Pi.addZeroClass I g n) where\n  smul_zero := by intros; ext x; exact smul_zero _\n  smul_add := by intros; ext x; exact smul_add _ _ _", "start": [162, 1], "end": [166, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.distribMulAction", "code": "instance distribMulAction (\u03b1) {m : Monoid \u03b1} {n : \u2200 i, AddMonoid <| f i}\n    [\u2200 i, DistribMulAction \u03b1 <| f i] : @DistribMulAction \u03b1 (\u2200 i : I, f i) m (@Pi.addMonoid I f n) :=\n  { Pi.mulAction _, Pi.distribSMul _ with }", "start": [169, 1], "end": [171, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.distribMulAction'", "code": "instance distribMulAction' {g : I \u2192 Type*} {m : \u2200 i, Monoid (f i)} {n : \u2200 i, AddMonoid <| g i}\n    [\u2200 i, DistribMulAction (f i) (g i)] :\n    @DistribMulAction (\u2200 i, f i) (\u2200 i : I, g i) (@Pi.monoid I f m) (@Pi.addMonoid I g n) :=\n  { Pi.mulAction', Pi.distribSMul' with }", "start": [174, 1], "end": [177, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.single_smul", "code": "theorem single_smul {\u03b1} [Monoid \u03b1] [\u2200 i, AddMonoid <| f i] [\u2200 i, DistribMulAction \u03b1 <| f i]\n    [DecidableEq I] (i : I) (r : \u03b1) (x : f i) : single i (r \u2022 x) = r \u2022 single i x", "start": [180, 1], "end": [182, 78], "kind": "commanddeclaration"}, {"full_name": "Pi.single_smul'", "code": "theorem single_smul' {\u03b1 \u03b2} [Monoid \u03b1] [AddMonoid \u03b2] [DistribMulAction \u03b1 \u03b2] [DecidableEq I] (i : I)\n    (r : \u03b1) (x : \u03b2) : single (f := fun _ => \u03b2) i (r \u2022 x) = r \u2022 single (f := fun _ => \u03b2) i x", "start": [186, 1], "end": [190, 38], "kind": "commanddeclaration"}, {"full_name": "Pi.single_smul\u2080", "code": "theorem single_smul\u2080 {g : I \u2192 Type*} [\u2200 i, MonoidWithZero (f i)] [\u2200 i, AddMonoid (g i)]\n    [\u2200 i, DistribMulAction (f i) (g i)] [DecidableEq I] (i : I) (r : f i) (x : g i) :\n    single i (r \u2022 x) = single i r \u2022 single i x", "start": [193, 1], "end": [196, 85], "kind": "commanddeclaration"}, {"full_name": "Pi.mulDistribMulAction", "code": "instance mulDistribMulAction (\u03b1) {m : Monoid \u03b1} {n : \u2200 i, Monoid <| f i}\n    [\u2200 i, MulDistribMulAction \u03b1 <| f i] :\n    @MulDistribMulAction \u03b1 (\u2200 i : I, f i) m (@Pi.monoid I f n) :=\n  { Pi.mulAction _ with\n    smul_one := fun _ => funext fun _ => smul_one _\n    smul_mul := fun _ _ _ => funext fun _ => smul_mul' _ _ _ }", "start": [199, 1], "end": [204, 63], "kind": "commanddeclaration"}, {"full_name": "Pi.mulDistribMulAction'", "code": "instance mulDistribMulAction' {g : I \u2192 Type*} {m : \u2200 i, Monoid (f i)} {n : \u2200 i, Monoid <| g i}\n    [\u2200 i, MulDistribMulAction (f i) (g i)] :\n    @MulDistribMulAction (\u2200 i, f i) (\u2200 i : I, g i) (@Pi.monoid I f m) (@Pi.monoid I g n) where\n  smul_mul := by\n    intros\n    ext x\n    apply smul_mul'\n  smul_one := by\n    intros\n    ext x\n    apply smul_one", "start": [207, 1], "end": [217, 19], "kind": "commanddeclaration"}, {"full_name": "Function.hasSMul", "code": "@[to_additive\n  \"Non-dependent version of `Pi.vadd`. Lean gets confused by the dependent instance\n  if this is not present.\"]\ninstance hasSMul {\u03b9 R M : Type*} [SMul R M] : SMul R (\u03b9 \u2192 M) :=\n  Pi.instSMul", "start": [224, 1], "end": [230, 14], "kind": "commanddeclaration"}, {"full_name": "Function.smulCommClass", "code": "@[to_additive\n  \"Non-dependent version of `Pi.vaddCommClass`. Lean gets confused by the dependent\n  instance if this is not present.\"]\ninstance smulCommClass {\u03b9 \u03b1 \u03b2 M : Type*} [SMul \u03b1 M] [SMul \u03b2 M] [SMulCommClass \u03b1 \u03b2 M] :\n    SMulCommClass \u03b1 \u03b2 (\u03b9 \u2192 M) :=\n  Pi.smulCommClass", "start": [234, 1], "end": [241, 19], "kind": "commanddeclaration"}, {"full_name": "Function.update_smul", "code": "@[to_additive]\ntheorem update_smul {\u03b1 : Type*} [\u2200 i, SMul \u03b1 (f i)] [DecidableEq I] (c : \u03b1) (f\u2081 : \u2200 i, f i)\n    (i : I) (x\u2081 : f i) : update (c \u2022 f\u2081) i (c \u2022 x\u2081) = c \u2022 update f\u2081 i x\u2081", "start": [245, 1], "end": [248, 78], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_smul", "code": "@[to_additive]\ntheorem piecewise_smul {\u03b1 : Type*} [\u2200 i, SMul \u03b1 (f i)] (s : Set I) [\u2200 i, Decidable (i \u2208 s)]\n    (c : \u03b1) (f\u2081 g\u2081 : \u2200 i, f i) : s.piecewise (c \u2022 f\u2081) (c \u2022 g\u2081) = c \u2022 s.piecewise f\u2081 g\u2081", "start": [256, 1], "end": [259, 51], "kind": "commanddeclaration"}, {"full_name": "Function.extend_smul", "code": "@[to_additive]\ntheorem Function.extend_smul {R \u03b1 \u03b2 \u03b3 : Type*} [SMul R \u03b3] (r : R) (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3)\n    (e : \u03b2 \u2192 \u03b3) : Function.extend f (r \u2022 g) (r \u2022 e) = r \u2022 Function.extend f g e", "start": [267, 1], "end": [275, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Cast/CharZero.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "Mathlib/Data/Rat/Cast/Defs.lean", "Mathlib/Data/Int/CharZero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.cast_inj", "code": "@[simp, norm_cast]\ntheorem cast_inj [CharZero \u03b1] : \u2200 {m n : \u211a}, (m : \u03b1) = n \u2194 m = n", "start": [28, 1], "end": [38, 100], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_injective", "code": "theorem cast_injective [CharZero \u03b1] : Function.Injective ((\u2191) : \u211a \u2192 \u03b1)", "start": [41, 1], "end": [42, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_eq_zero", "code": "@[simp]\ntheorem cast_eq_zero [CharZero \u03b1] {n : \u211a} : (n : \u03b1) = 0 \u2194 n = 0", "start": [45, 1], "end": [46, 97], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_ne_zero", "code": "theorem cast_ne_zero [CharZero \u03b1] {n : \u211a} : (n : \u03b1) \u2260 0 \u2194 n \u2260 0", "start": [49, 1], "end": [50, 25], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_add", "code": "@[simp, norm_cast]\ntheorem cast_add [CharZero \u03b1] (m n) : ((m + n : \u211a) : \u03b1) = m + n", "start": [53, 1], "end": [55, 100], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_sub", "code": "@[simp, norm_cast]\ntheorem cast_sub [CharZero \u03b1] (m n) : ((m - n : \u211a) : \u03b1) = m - n", "start": [58, 1], "end": [60, 100], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mul", "code": "@[simp, norm_cast]\ntheorem cast_mul [CharZero \u03b1] (m n) : ((m * n : \u211a) : \u03b1) = m * n", "start": [63, 1], "end": [65, 100], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_bit0", "code": "@[simp, norm_cast]\ntheorem cast_bit0 [CharZero \u03b1] (n : \u211a) : ((bit0 n : \u211a) : \u03b1) = (bit0 n : \u03b1)", "start": [72, 1], "end": [74, 15], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_bit1", "code": "@[simp, norm_cast]\ntheorem cast_bit1 [CharZero \u03b1] (n : \u211a) : ((bit1 n : \u211a) : \u03b1) = (bit1 n : \u03b1)", "start": [77, 1], "end": [79, 48], "kind": "commanddeclaration"}, {"full_name": "Rat.castHom", "code": "def castHom : \u211a \u2192+* \u03b1 where\n  toFun := (\u2191)\n  map_one' := cast_one\n  map_mul' := cast_mul\n  map_zero' := cast_zero\n  map_add' := cast_add", "start": [87, 1], "end": [93, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.coe_cast_hom", "code": "@[simp]\ntheorem coe_cast_hom : \u21d1(castHom \u03b1) = ((\u2191) : \u211a \u2192 \u03b1)", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_inv", "code": "@[simp, norm_cast]\ntheorem cast_inv (n) : ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9", "start": [103, 1], "end": [105, 25], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_div", "code": "@[simp, norm_cast]\ntheorem cast_div (m n) : ((m / n : \u211a) : \u03b1) = m / n", "start": [108, 1], "end": [110, 27], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_zpow", "code": "@[simp, norm_cast]\ntheorem cast_zpow (q : \u211a) (n : \u2124) : ((q ^ n : \u211a) : \u03b1) = (q : \u03b1) ^ n", "start": [113, 1], "end": [115, 28], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mk", "code": "@[norm_cast]\ntheorem cast_mk (a b : \u2124) : (a /. b : \u03b1) = a / b", "start": [118, 1], "end": [120, 52], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_pow", "code": "@[simp, norm_cast]\ntheorem cast_pow (q) (k : \u2115) : ((q : \u211a) ^ k : \u03b1) = (q : \u03b1) ^ k", "start": [123, 1], "end": [125, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Functor.lean", "imports": ["Mathlib/Control/Basic.lean", "Mathlib/Data/Set/Lattice.lean", "Mathlib/Init/Set.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.monad", "code": "instance monad : Monad.{u} Set where\n  pure a := {a}\n  bind s f := \u22c3 i \u2208 s, f i\n  seq s t := Set.seq s (t ())\n  map := Set.image", "start": [28, 1], "end": [32, 19], "kind": "commanddeclaration"}, {"full_name": "Set.bind_def", "code": "@[simp]\ntheorem bind_def : s >>= f = \u22c3 i \u2208 s, f i", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Set.fmap_eq_image", "code": "@[simp]\ntheorem fmap_eq_image (f : \u03b1 \u2192 \u03b2) : f <$> s = f '' s", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Set.seq_eq_set_seq", "code": "@[simp]\ntheorem seq_eq_set_seq (s : Set (\u03b1 \u2192 \u03b2)) (t : Set \u03b1) : s <*> t = s.seq t", "start": [44, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Set.pure_def", "code": "@[simp]\ntheorem pure_def (a : \u03b1) : (pure a : Set \u03b1) = {a}", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Set.image2_def", "code": "theorem image2_def {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) :\n    image2 f s t = f <$> s <*> t", "start": [54, 1], "end": [59, 7], "kind": "commanddeclaration"}, {"full_name": "Set.mem_coe_of_mem", "code": "theorem mem_coe_of_mem (ha : a \u2208 \u03b2) (ha' : \u27e8a, ha\u27e9 \u2208 \u03b3) : a \u2208 (\u03b3 : Set \u03b1)", "start": [81, 1], "end": [82, 38], "kind": "commanddeclaration"}, {"full_name": "Set.coe_subset", "code": "theorem coe_subset : (\u03b3 : Set \u03b1) \u2286 \u03b2", "start": [84, 1], "end": [85, 60], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_coe", "code": "theorem mem_of_mem_coe (ha : a \u2208 (\u03b3 : Set \u03b1)) : \u27e8a, coe_subset ha\u27e9 \u2208 \u03b3", "start": [87, 1], "end": [88, 60], "kind": "commanddeclaration"}, {"full_name": "Set.eq_univ_of_coe_eq", "code": "theorem eq_univ_of_coe_eq (h\u03b3 : (\u03b3 : Set \u03b1) = \u03b2) : \u03b3 = univ", "start": [90, 1], "end": [91, 66], "kind": "commanddeclaration"}, {"full_name": "Set.image_coe_eq_restrict_image", "code": "theorem image_coe_eq_restrict_image {f : \u03b1 \u2192 \u03b4} : f '' \u03b3 = \u03b2.restrict f '' \u03b3", "start": [93, 1], "end": [95, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finite/Basic.lean", "imports": ["Mathlib/Data/Fintype/Sigma.lean", "Mathlib/Data/Fintype/Vector.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Powerset.lean", "Mathlib/Data/Fintype/Prod.lean", "Mathlib/Data/Fintype/Sum.lean"], "premises": [{"full_name": "Finite.of_subsingleton", "code": "instance (priority := 100) of_subsingleton {\u03b1 : Sort*} [Subsingleton \u03b1] : Finite \u03b1 :=\n  of_injective (Function.const \u03b1 ()) <| Function.injective_of_subsingleton _", "start": [55, 1], "end": [56, 77], "kind": "commanddeclaration"}, {"full_name": "Finite.prop", "code": "instance prop (p : Prop) : Finite p :=\n  Finite.of_subsingleton", "start": [61, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "Finite.prod_left", "code": "theorem prod_left (\u03b2) [Finite (\u03b1 \u00d7 \u03b2)] [Nonempty \u03b2] : Finite \u03b1", "start": [73, 1], "end": [74, 59], "kind": "commanddeclaration"}, {"full_name": "Finite.prod_right", "code": "theorem prod_right (\u03b1) [Finite (\u03b1 \u00d7 \u03b2)] [Nonempty \u03b1] : Finite \u03b2", "start": [77, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "Finite.sum_left", "code": "theorem sum_left (\u03b2) [Finite (Sum \u03b1 \u03b2)] : Finite \u03b1", "start": [86, 1], "end": [87, 57], "kind": "commanddeclaration"}, {"full_name": "Finite.sum_right", "code": "theorem sum_right (\u03b1) [Finite (Sum \u03b1 \u03b2)] : Finite \u03b2", "start": [90, 1], "end": [91, 57], "kind": "commanddeclaration"}, {"full_name": "Subtype.finite", "code": "instance Subtype.finite {\u03b1 : Sort*} [Finite \u03b1] {p : \u03b1 \u2192 Prop} : Finite { x // p x } :=\n  Finite.of_injective (\u2191) Subtype.coe_injective", "start": [108, 1], "end": [110, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.finite", "code": "instance Pi.finite {\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} [Finite \u03b1] [\u2200 a, Finite (\u03b2 a)] :\n    Finite (\u2200 a, \u03b2 a) := by\n  haveI := Fintype.ofFinite (PLift \u03b1)\n  haveI := fun a => Fintype.ofFinite (PLift (\u03b2 a))\n  exact\n    Finite.of_equiv (\u2200 a : PLift \u03b1, PLift (\u03b2 (Equiv.plift a)))\n      (Equiv.piCongr Equiv.plift fun _ => Equiv.plift)", "start": [113, 1], "end": [119, 55], "kind": "commanddeclaration"}, {"full_name": "Vector.finite", "code": "instance Vector.finite {\u03b1 : Type*} [Finite \u03b1] {n : \u2115} : Finite (Vector \u03b1 n) := by\n  haveI := Fintype.ofFinite \u03b1\n  infer_instance", "start": [122, 1], "end": [124, 17], "kind": "commanddeclaration"}, {"full_name": "Quot.finite", "code": "instance Quot.finite {\u03b1 : Sort*} [Finite \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Finite (Quot r) :=\n  Finite.of_surjective _ (surjective_quot_mk r)", "start": [127, 1], "end": [128, 48], "kind": "commanddeclaration"}, {"full_name": "Quotient.finite", "code": "instance Quotient.finite {\u03b1 : Sort*} [Finite \u03b1] (s : Setoid \u03b1) : Finite (Quotient s) :=\n  Quot.finite _", "start": [131, 1], "end": [132, 16], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.finite", "code": "instance Function.Embedding.finite {\u03b1 \u03b2 : Sort*} [Finite \u03b2] : Finite (\u03b1 \u21aa \u03b2) := by\n  cases' isEmpty_or_nonempty (\u03b1 \u21aa \u03b2) with _ h\n  \u00b7 apply Finite.of_subsingleton\n\n  \u00b7 refine' h.elim fun f => _\n    haveI : Finite \u03b1 := Finite.of_injective _ f.injective\n    exact Finite.of_injective _ FunLike.coe_injective", "start": [135, 1], "end": [143, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.finite_right", "code": "instance Equiv.finite_right {\u03b1 \u03b2 : Sort*} [Finite \u03b2] : Finite (\u03b1 \u2243 \u03b2) :=\n  Finite.of_injective Equiv.toEmbedding fun e\u2081 e\u2082 h => Equiv.ext <| by\n    convert FunLike.congr_fun h using 0", "start": [146, 1], "end": [148, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.finite_left", "code": "instance Equiv.finite_left {\u03b1 \u03b2 : Sort*} [Finite \u03b1] : Finite (\u03b1 \u2243 \u03b2) :=\n  Finite.of_equiv _ \u27e8Equiv.symm, Equiv.symm, Equiv.symm_symm, Equiv.symm_symm\u27e9", "start": [151, 1], "end": [152, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/Sort.lean", "imports": ["Mathlib/Data/Multiset/Basic.lean", "Mathlib/Data/List/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.sort", "code": "def sort (s : Multiset \u03b1) : List \u03b1 :=\n  Quot.liftOn s (mergeSort r) fun _ _ h =>\n    eq_of_perm_of_sorted ((perm_mergeSort _ _).trans <| h.trans (perm_mergeSort _ _).symm)\n      (sorted_mergeSort r _) (sorted_mergeSort r _)", "start": [26, 1], "end": [31, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.coe_sort", "code": "@[simp]\ntheorem coe_sort (l : List \u03b1) : sort r l = mergeSort r l", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.sort_sorted", "code": "@[simp]\ntheorem sort_sorted (s : Multiset \u03b1) : Sorted r (sort r s)", "start": [39, 1], "end": [41, 52], "kind": "commanddeclaration"}, {"full_name": "Multiset.sort_eq", "code": "@[simp]\ntheorem sort_eq (s : Multiset \u03b1) : \u2191(sort r s) = s", "start": [44, 1], "end": [46, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_sort", "code": "@[simp]\ntheorem mem_sort {s : Multiset \u03b1} {a : \u03b1} : a \u2208 sort r s \u2194 a \u2208 s", "start": [49, 1], "end": [50, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.length_sort", "code": "@[simp]\ntheorem length_sort {s : Multiset \u03b1} : (sort r s).length = card s", "start": [53, 1], "end": [55, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.sort_zero", "code": "@[simp]\ntheorem sort_zero : sort r 0 = []", "start": [58, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.sort_singleton", "code": "@[simp]\ntheorem sort_singleton (a : \u03b1) : sort r {a} = [a]", "start": [63, 1], "end": [65, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Lattice.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Data/Finset/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.sup_univ_eq_iSup", "code": "theorem sup_univ_eq_iSup [CompleteLattice \u03b2] (f : \u03b1 \u2192 \u03b2) : Finset.univ.sup f = iSup f", "start": [28, 1], "end": [30, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.inf_univ_eq_iInf", "code": "theorem inf_univ_eq_iInf [CompleteLattice \u03b2] (f : \u03b1 \u2192 \u03b2) : Finset.univ.inf f = iInf f", "start": [33, 1], "end": [35, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_inf_univ", "code": "@[simp]\ntheorem fold_inf_univ [SemilatticeInf \u03b1] [OrderBot \u03b1] (a : \u03b1) :\n    haveI : IsCommutative \u03b1 (\u00b7 \u2293 \u00b7) := inferInstance\n    (Finset.univ.fold (\u00b7 \u2293 \u00b7) a fun x => x) = \u22a5", "start": [38, 1], "end": [44, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.fold_sup_univ", "code": "@[simp]\ntheorem fold_sup_univ [SemilatticeSup \u03b1] [OrderTop \u03b1] (a : \u03b1) :\n    haveI : IsCommutative \u03b1 (\u00b7 \u2294 \u00b7) := inferInstance\n    (Finset.univ.fold (\u00b7 \u2294 \u00b7) a fun x => x) = \u22a4", "start": [47, 1], "end": [52, 29], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_max", "code": "theorem Finite.exists_max [Finite \u03b1] [Nonempty \u03b1] [LinearOrder \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    \u2203 x\u2080 : \u03b1, \u2200 x, f x \u2264 f x\u2080", "start": [59, 1], "end": [62, 52], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_min", "code": "theorem Finite.exists_min [Finite \u03b1] [Nonempty \u03b1] [LinearOrder \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    \u2203 x\u2080 : \u03b1, \u2200 x, f x\u2080 \u2264 f x", "start": [65, 1], "end": [68, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/RelIso/Set.lean", "imports": ["Mathlib/Order/RelIso/Basic.lean", "Mathlib/Logic/Embedding/Set.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RelHomClass.map_inf", "code": "theorem map_inf [SemilatticeInf \u03b1] [LinearOrder \u03b2]\n    [RelHomClass F ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a : F) (m n : \u03b2) :\n    a (m \u2293 n) = a m \u2293 a n", "start": [30, 1], "end": [33, 57], "kind": "commanddeclaration"}, {"full_name": "RelHomClass.map_sup", "code": "theorem map_sup [SemilatticeSup \u03b1] [LinearOrder \u03b2]\n    [RelHomClass F ((\u00b7 > \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a : F) (m n : \u03b2) :\n    a (m \u2294 n) = a m \u2294 a n", "start": [36, 1], "end": [39, 33], "kind": "commanddeclaration"}, {"full_name": "RelIso.range_eq", "code": "@[simp]\ntheorem range_eq (e : r \u2243r s) : Set.range e = Set.univ", "start": [46, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "Subrel", "code": "def Subrel (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (p : Set \u03b1) : p \u2192 p \u2192 Prop :=\n  (Subtype.val : p \u2192 \u03b1) \u207b\u00b9'o r", "start": [53, 1], "end": [55, 31], "kind": "commanddeclaration"}, {"full_name": "subrel_val", "code": "@[simp]\ntheorem subrel_val (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (p : Set \u03b1) {a b} : Subrel r p a b \u2194 r a.1 b.1", "start": [58, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "Subrel.relEmbedding", "code": "protected def relEmbedding (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (p : Set \u03b1) : Subrel r p \u21aar r :=\n  \u27e8Embedding.subtype _, Iff.rfl\u27e9", "start": [65, 1], "end": [67, 33], "kind": "commanddeclaration"}, {"full_name": "Subrel.relEmbedding_apply", "code": "@[simp]\ntheorem relEmbedding_apply (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (p a) : Subrel.relEmbedding r p a = a.1", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.codRestrict", "code": "def RelEmbedding.codRestrict (p : Set \u03b2) (f : r \u21aar s) (H : \u2200 a, f a \u2208 p) : r \u21aar Subrel s p :=\n  \u27e8f.toEmbedding.codRestrict p H, f.map_rel_iff'\u27e9", "start": [92, 1], "end": [94, 50], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.codRestrict_apply", "code": "@[simp]\ntheorem RelEmbedding.codRestrict_apply (p) (f : r \u21aar s) (H a) :\n    RelEmbedding.codRestrict p f H a = \u27e8f a, H a\u27e9", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Encodable/Basic.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Order/RelIso/Basic.lean", "Mathlib/Data/Countable/Defs.lean", "Mathlib/Order/Directed.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/PNat/Basic.lean", "Mathlib/Logic/Equiv/Nat.lean"], "premises": [{"full_name": "Encodable", "code": "class Encodable (\u03b1 : Type*) where\n  \n  encode : \u03b1 \u2192 \u2115\n  \n  decode : \u2115 \u2192 Option \u03b1\n  \n  encodek : \u2200 a, decode (encode a) = some a", "start": [42, 1], "end": [53, 44], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_injective", "code": "theorem encode_injective [Encodable \u03b1] : Function.Injective (@encode \u03b1 _)", "start": [64, 1], "end": [65, 64], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_inj", "code": "@[simp]\ntheorem encode_inj [Encodable \u03b1] {a b : \u03b1} : encode a = encode b \u2194 a = b", "start": [68, 1], "end": [70, 26], "kind": "commanddeclaration"}, {"full_name": "Encodable.countable", "code": "instance (priority := 400) countable [Encodable \u03b1] : Countable \u03b1 where\n  exists_injective_nat' := \u27e8_,encode_injective\u27e9", "start": [75, 1], "end": [76, 48], "kind": "commanddeclaration"}, {"full_name": "Encodable.surjective_decode_iget", "code": "theorem surjective_decode_iget (\u03b1 : Type*) [Encodable \u03b1] [Inhabited \u03b1] :\n    Surjective fun n => ((Encodable.decode n).iget : \u03b1)", "start": [78, 1], "end": [80, 55], "kind": "commanddeclaration"}, {"full_name": "Encodable.decidableEqOfEncodable", "code": "def decidableEqOfEncodable (\u03b1) [Encodable \u03b1] : DecidableEq \u03b1\n  | _, _ => decidable_of_iff _ encode_inj", "start": [83, 1], "end": [86, 42], "kind": "commanddeclaration"}, {"full_name": "Encodable.ofLeftInjection", "code": "def ofLeftInjection [Encodable \u03b1] (f : \u03b2 \u2192 \u03b1) (finv : \u03b1 \u2192 Option \u03b2)\n    (linv : \u2200 b, finv (f b) = some b) : Encodable \u03b2 :=\n  \u27e8fun b => encode (f b), fun n => (decode n).bind finv, fun b => by\n    simp [Encodable.encodek, linv]\u27e9", "start": [89, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "Encodable.ofLeftInverse", "code": "def ofLeftInverse [Encodable \u03b1] (f : \u03b2 \u2192 \u03b1) (finv : \u03b1 \u2192 \u03b2) (linv : \u2200 b, finv (f b) = b) :\n    Encodable \u03b2 :=\n  ofLeftInjection f (some \u2218 finv) fun b => congr_arg some (linv b)", "start": [96, 1], "end": [99, 67], "kind": "commanddeclaration"}, {"full_name": "Encodable.ofEquiv", "code": "def ofEquiv (\u03b1) [Encodable \u03b1] (e : \u03b2 \u2243 \u03b1) : Encodable \u03b2 :=\n  ofLeftInverse e e.symm e.left_inv", "start": [102, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_ofEquiv", "code": "theorem encode_ofEquiv {\u03b1 \u03b2} [Encodable \u03b1] (e : \u03b2 \u2243 \u03b1) (b : \u03b2) :\n    @encode _ (ofEquiv _ e) b = encode (e b)", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_ofEquiv", "code": "theorem decode_ofEquiv {\u03b1 \u03b2} [Encodable \u03b1] (e : \u03b2 \u2243 \u03b1) (n : \u2115) :\n    @decode _ (ofEquiv _ e) n = (decode n).map e.symm", "start": [114, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.encodable", "code": "instance _root_.Nat.encodable : Encodable \u2115 :=\n  \u27e8id, some, fun _ => rfl\u27e9", "start": [120, 1], "end": [121, 27], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_nat", "code": "@[simp]\ntheorem encode_nat (n : \u2115) : encode n = n", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_nat", "code": "@[simp 1100]\ntheorem decode_nat (n : \u2115) : decode n = some n", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toEncodable", "code": "instance (priority := 100) _root_.IsEmpty.toEncodable [IsEmpty \u03b1] : Encodable \u03b1 :=\n  \u27e8isEmptyElim, fun _ => none, isEmptyElim\u27e9", "start": [134, 1], "end": [135, 44], "kind": "commanddeclaration"}, {"full_name": "PUnit.encodable", "code": "instance _root_.PUnit.encodable : Encodable PUnit :=\n  \u27e8fun _ => 0, fun n => Nat.casesOn n (some PUnit.unit) fun _ => none, fun _ => by simp\u27e9", "start": [138, 1], "end": [139, 89], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_star", "code": "@[simp]\ntheorem encode_star : encode PUnit.unit = 0", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_unit_zero", "code": "@[simp]\ntheorem decode_unit_zero : decode 0 = some PUnit.unit", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_unit_succ", "code": "@[simp]\ntheorem decode_unit_succ (n) : decode (succ n) = (none : Option PUnit)", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Option.encodable", "code": "instance _root_.Option.encodable {\u03b1 : Type*} [h : Encodable \u03b1] : Encodable (Option \u03b1) :=\n  \u27e8fun o => Option.casesOn o Nat.zero fun a => succ (encode a), fun n =>\n    Nat.casesOn n (some none) fun m => (decode m).map some, fun o => by\n    cases o <;> dsimp; simp [encodek, Nat.succ_ne_zero]\u27e9", "start": [157, 1], "end": [161, 57], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_none", "code": "@[simp]\ntheorem encode_none [Encodable \u03b1] : encode (@none \u03b1) = 0", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_some", "code": "@[simp]\ntheorem encode_some [Encodable \u03b1] (a : \u03b1) : encode (some a) = succ (encode a)", "start": [169, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_option_zero", "code": "@[simp]\ntheorem decode_option_zero [Encodable \u03b1] : (decode 0 : Option (Option \u03b1))= some none", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_option_succ", "code": "@[simp]\ntheorem decode_option_succ [Encodable \u03b1] (n) :\n    (decode (succ n) : Option (Option \u03b1)) = (decode n).map some", "start": [179, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082", "code": "def decode\u2082 (\u03b1) [Encodable \u03b1] (n : \u2115) : Option \u03b1 :=\n  (decode n).bind (Option.guard fun a => encode a = n)", "start": [185, 1], "end": [189, 55], "kind": "commanddeclaration"}, {"full_name": "Encodable.mem_decode\u2082'", "code": "theorem mem_decode\u2082' [Encodable \u03b1] {n : \u2115} {a : \u03b1} :\n    a \u2208 decode\u2082 \u03b1 n \u2194 a \u2208 decode n \u2227 encode a = n", "start": [192, 1], "end": [194, 93], "kind": "commanddeclaration"}, {"full_name": "Encodable.mem_decode\u2082", "code": "theorem mem_decode\u2082 [Encodable \u03b1] {n : \u2115} {a : \u03b1} : a \u2208 decode\u2082 \u03b1 n \u2194 encode a = n", "start": [197, 1], "end": [198, 67], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082_eq_some", "code": "theorem decode\u2082_eq_some [Encodable \u03b1] {n : \u2115} {a : \u03b1} : decode\u2082 \u03b1 n = some a \u2194 encode a = n", "start": [201, 1], "end": [202, 14], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082_encode", "code": "@[simp]\ntheorem decode\u2082_encode [Encodable \u03b1] (a : \u03b1) : decode\u2082 \u03b1 (encode a) = some a", "start": [205, 1], "end": [208, 47], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082_ne_none_iff", "code": "theorem decode\u2082_ne_none_iff [Encodable \u03b1] {n : \u2115} :\n    decode\u2082 \u03b1 n \u2260 none \u2194 n \u2208 Set.range (encode : \u03b1 \u2192 \u2115)", "start": [211, 1], "end": [214, 48], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082_is_partial_inv", "code": "theorem decode\u2082_is_partial_inv [Encodable \u03b1] : IsPartialInv encode (decode\u2082 \u03b1)", "start": [217, 1], "end": [218, 14], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode\u2082_inj", "code": "theorem decode\u2082_inj [Encodable \u03b1] {n : \u2115} {a\u2081 a\u2082 : \u03b1} (h\u2081 : a\u2081 \u2208 decode\u2082 \u03b1 n)\n    (h\u2082 : a\u2082 \u2208 decode\u2082 \u03b1 n) : a\u2081 = a\u2082", "start": [221, 1], "end": [223, 71], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodek\u2082", "code": "theorem encodek\u2082 [Encodable \u03b1] (a : \u03b1) : decode\u2082 \u03b1 (encode a) = some a", "start": [226, 1], "end": [227, 20], "kind": "commanddeclaration"}, {"full_name": "Encodable.decidableRangeEncode", "code": "def decidableRangeEncode (\u03b1 : Type*) [Encodable \u03b1] : DecidablePred (\u00b7 \u2208 Set.range (@encode \u03b1 _)) :=\n  fun x =>\n  decidable_of_iff (Option.isSome (decode\u2082 \u03b1 x))\n    \u27e8fun h => \u27e8Option.get _ h, by rw [\u2190 decode\u2082_is_partial_inv (Option.get _ h), Option.some_get]\u27e9,\n      fun \u27e8n, hn\u27e9 => by rw [\u2190 hn, encodek\u2082]; exact rfl\u27e9", "start": [230, 1], "end": [235, 56], "kind": "commanddeclaration"}, {"full_name": "Encodable.equivRangeEncode", "code": "def equivRangeEncode (\u03b1 : Type*) [Encodable \u03b1] : \u03b1 \u2243 Set.range (@encode \u03b1 _)\n    where\n  toFun := fun a : \u03b1 => \u27e8encode a, Set.mem_range_self _\u27e9\n  invFun n :=\n    Option.get _\n      (show isSome (decode\u2082 \u03b1 n.1) by cases' n.2 with x hx; rw [\u2190 hx, encodek\u2082]; exact rfl)\n  left_inv a := by dsimp; rw [\u2190 Option.some_inj, Option.some_get, encodek\u2082]\n  right_inv := fun \u27e8n, x, hx\u27e9 => by\n    apply Subtype.eq\n    dsimp\n    conv =>\n      rhs\n      rw [\u2190 hx]\n    rw [encode_injective.eq_iff, \u2190 Option.some_inj, Option.some_get, \u2190 hx, encodek\u2082]", "start": [238, 1], "end": [252, 85], "kind": "commanddeclaration"}, {"full_name": "Unique.encodable", "code": "def _root_.Unique.encodable [Unique \u03b1] : Encodable \u03b1 :=\n  \u27e8fun _ => 0, fun _ => some default, Unique.forall_iff.2 rfl\u27e9", "start": [255, 1], "end": [257, 63], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodeSum", "code": "def encodeSum : Sum \u03b1 \u03b2 \u2192 \u2115\n  | Sum.inl a => 2 * encode a\n  | Sum.inr b => 2 * encode b + 1", "start": [265, 1], "end": [268, 34], "kind": "commanddeclaration"}, {"full_name": "Encodable.decodeSum", "code": "def decodeSum (n : \u2115) : Option (Sum \u03b1 \u03b2) :=\n  match boddDiv2 n with\n  | (false, m) => (decode m : Option \u03b1).map Sum.inl\n  | (_, m) => (decode m : Option \u03b2).map Sum.inr", "start": [271, 1], "end": [275, 48], "kind": "commanddeclaration"}, {"full_name": "Sum.encodable", "code": "instance _root_.Sum.encodable : Encodable (Sum \u03b1 \u03b2) :=\n  \u27e8encodeSum, decodeSum, fun s => by cases s <;> simp [encodeSum, div2_val, decodeSum, encodek]\u27e9", "start": [278, 1], "end": [280, 97], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_inl", "code": "@[simp]\ntheorem encode_inl (a : \u03b1) : @encode (Sum \u03b1 \u03b2) _ (Sum.inl a) = 2 * (encode a)", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_inr", "code": "@[simp]\ntheorem encode_inr (b : \u03b2) : @encode (Sum \u03b1 \u03b2) _ (Sum.inr b) = 2 * (encode b) + 1", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_sum_val", "code": "@[simp]\ntheorem decode_sum_val (n : \u2115) : (decode n : Option (Sum \u03b1 \u03b2)) = decodeSum n", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "Bool.encodable", "code": "instance _root_.Bool.encodable : Encodable Bool :=\n  ofEquiv (Sum Unit Unit) Equiv.boolEquivPUnitSumPUnit", "start": [302, 1], "end": [303, 55], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_true", "code": "@[simp]\ntheorem encode_true : encode true = 1", "start": [306, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_false", "code": "@[simp]\ntheorem encode_false : encode false = 0", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_zero", "code": "@[simp]\ntheorem decode_zero : (decode 0 : Option Bool) = some false", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_one", "code": "@[simp]\ntheorem decode_one : (decode 1 : Option Bool) = some true", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_ge_two", "code": "theorem decode_ge_two (n) (h : 2 \u2264 n) : (decode n : Option Bool) = none", "start": [326, 1], "end": [335, 56], "kind": "commanddeclaration"}, {"full_name": "Prop.encodable", "code": "noncomputable instance _root_.Prop.encodable : Encodable Prop :=\n  ofEquiv Bool Equiv.propEquivBool", "start": [338, 1], "end": [339, 35], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodeSigma", "code": "def encodeSigma : Sigma \u03b3 \u2192 \u2115\n  | \u27e8a, b\u27e9 => pair (encode a) (encode b)", "start": [346, 1], "end": [348, 41], "kind": "commanddeclaration"}, {"full_name": "Encodable.decodeSigma", "code": "def decodeSigma (n : \u2115) : Option (Sigma \u03b3) :=\n  let (n\u2081, n\u2082) := unpair n\n  (decode n\u2081).bind fun a => (decode n\u2082).map <| Sigma.mk a", "start": [351, 1], "end": [354, 58], "kind": "commanddeclaration"}, {"full_name": "Sigma.encodable", "code": "instance _root_.Sigma.encodable : Encodable (Sigma \u03b3) :=\n  \u27e8encodeSigma, decodeSigma, fun \u27e8a, b\u27e9 => by\n    simp [encodeSigma, decodeSigma, unpair_pair, encodek]\u27e9", "start": [357, 1], "end": [359, 59], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_sigma_val", "code": "@[simp]\ntheorem decode_sigma_val (n : \u2115) :\n    (decode n : Option (Sigma \u03b3)) =\n      (decode n.unpair.1).bind fun a => (decode n.unpair.2).map <| Sigma.mk a", "start": [362, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_sigma_val", "code": "@[simp]\ntheorem encode_sigma_val (a b) : @encode (Sigma \u03b3) _ \u27e8a, b\u27e9 = pair (encode a) (encode b)", "start": [369, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.Prod.encodable", "code": "instance Prod.encodable : Encodable (\u03b1 \u00d7 \u03b2) :=\n  ofEquiv _ (Equiv.sigmaEquivProd \u03b1 \u03b2).symm", "start": [380, 1], "end": [382, 44], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_prod_val", "code": "@[simp]\ntheorem decode_prod_val [i : Encodable \u03b1] (n : \u2115) :\n    (@decode (\u03b1 \u00d7 \u03b2) _ n : Option (\u03b1 \u00d7 \u03b2))\n      = (decode n.unpair.1).bind fun a => (decode n.unpair.2).map <| Prod.mk a", "start": [384, 1], "end": [390, 10], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_prod_val", "code": "@[simp]\ntheorem encode_prod_val (a b) : @encode (\u03b1 \u00d7 \u03b2) _ (a, b) = pair (encode a) (encode b)", "start": [393, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodeSubtype", "code": "def encodeSubtype : { a : \u03b1 // P a } \u2192 \u2115\n  | \u27e8v,_\u27e9 => encode v", "start": [408, 1], "end": [410, 22], "kind": "commanddeclaration"}, {"full_name": "Encodable.decodeSubtype", "code": "def decodeSubtype (v : \u2115) : Option { a : \u03b1 // P a } :=\n  (decode v).bind fun a => if h : P a then some \u27e8a, h\u27e9 else none", "start": [415, 1], "end": [417, 65], "kind": "commanddeclaration"}, {"full_name": "Subtype.encodable", "code": "instance _root_.Subtype.encodable : Encodable { a : \u03b1 // P a } :=\n  \u27e8encodeSubtype, decodeSubtype, fun \u27e8v, h\u27e9 => by simp [encodeSubtype, decodeSubtype, encodek, h]\u27e9", "start": [420, 1], "end": [422, 99], "kind": "commanddeclaration"}, {"full_name": "Encodable.Subtype.encode_eq", "code": "theorem Subtype.encode_eq (a : Subtype P) : encode a = encode a.val", "start": [425, 1], "end": [425, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.encodable", "code": "instance _root_.Fin.encodable (n) : Encodable (Fin n) :=\n  ofEquiv _ Fin.equivSubtype", "start": [430, 1], "end": [431, 29], "kind": "commanddeclaration"}, {"full_name": "Int.encodable", "code": "instance _root_.Int.encodable : Encodable \u2124 :=\n  ofEquiv _ Equiv.intEquivNat", "start": [434, 1], "end": [435, 30], "kind": "commanddeclaration"}, {"full_name": "PNat.encodable", "code": "instance _root_.PNat.encodable : Encodable \u2115+ :=\n  ofEquiv _ Equiv.pnatEquivNat", "start": [438, 1], "end": [439, 31], "kind": "commanddeclaration"}, {"full_name": "ULift.encodable", "code": "instance _root_.ULift.encodable [Encodable \u03b1] : Encodable (ULift \u03b1) :=\n  ofEquiv _ Equiv.ulift", "start": [442, 1], "end": [444, 24], "kind": "commanddeclaration"}, {"full_name": "PLift.encodable", "code": "instance _root_.PLift.encodable [Encodable \u03b1] : Encodable (PLift \u03b1) :=\n  ofEquiv _ Equiv.plift", "start": [447, 1], "end": [449, 24], "kind": "commanddeclaration"}, {"full_name": "Encodable.ofInj", "code": "noncomputable def ofInj [Encodable \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f) : Encodable \u03b1 :=\n  ofLeftInjection f (partialInv f) fun _ => (partialInv_of_injective hf _ _).2 rfl", "start": [452, 1], "end": [454, 83], "kind": "commanddeclaration"}, {"full_name": "Encodable.ofCountable", "code": "noncomputable def ofCountable (\u03b1 : Type*) [Countable \u03b1] : Encodable \u03b1 :=\n  Nonempty.some <|\n    let \u27e8f, hf\u27e9 := exists_injective_nat \u03b1\n    \u27e8ofInj f hf\u27e9", "start": [457, 1], "end": [461, 17], "kind": "commanddeclaration"}, {"full_name": "Encodable.nonempty_encodable", "code": "@[simp]\ntheorem nonempty_encodable : Nonempty (Encodable \u03b1) \u2194 Countable \u03b1", "start": [464, 1], "end": [466, 69], "kind": "commanddeclaration"}, {"full_name": "nonempty_encodable", "code": "theorem nonempty_encodable (\u03b1 : Type*) [Countable \u03b1] : Nonempty (Encodable \u03b1)", "start": [471, 1], "end": [473, 28], "kind": "commanddeclaration"}, {"full_name": "ULower", "code": "def ULower (\u03b1 : Type*) [Encodable \u03b1] : Type :=\n  Set.range (Encodable.encode : \u03b1 \u2192 \u2115)", "start": [483, 1], "end": [485, 39], "kind": "commanddeclaration"}, {"full_name": "ULower.equiv", "code": "def equiv : \u03b1 \u2243 ULower \u03b1 :=\n  Encodable.equivRangeEncode \u03b1", "start": [500, 1], "end": [502, 31], "kind": "commanddeclaration"}, {"full_name": "ULower.down", "code": "def down (a : \u03b1) : ULower \u03b1 :=\n  equiv \u03b1 a", "start": [507, 1], "end": [509, 12], "kind": "commanddeclaration"}, {"full_name": "ULower.up", "code": "def up (a : ULower \u03b1) : \u03b1 :=\n  (equiv \u03b1).symm a", "start": [515, 1], "end": [517, 19], "kind": "commanddeclaration"}, {"full_name": "ULower.down_up", "code": "@[simp]\ntheorem down_up {a : ULower \u03b1} : down a.up = a", "start": [520, 1], "end": [522, 22], "kind": "commanddeclaration"}, {"full_name": "ULower.up_down", "code": "@[simp]\ntheorem up_down {a : \u03b1} : (down a).up = a", "start": [525, 1], "end": [527, 61], "kind": "commanddeclaration"}, {"full_name": "ULower.up_eq_up", "code": "@[simp]\ntheorem up_eq_up {a b : ULower \u03b1} : a.up = b.up \u2194 a = b", "start": [530, 1], "end": [532, 26], "kind": "commanddeclaration"}, {"full_name": "ULower.down_eq_down", "code": "@[simp]\ntheorem down_eq_down {a b : \u03b1} : down a = down b \u2194 a = b", "start": [535, 1], "end": [537, 26], "kind": "commanddeclaration"}, {"full_name": "ULower.ext", "code": "@[ext]\nprotected theorem ext {a b : ULower \u03b1} : a.up = b.up \u2192 a = b", "start": [540, 1], "end": [542, 13], "kind": "commanddeclaration"}, {"full_name": "Encodable.good", "code": "private def good : Option \u03b1 \u2192 Prop\n  | some a => p a\n  | none => False", "start": [561, 1], "end": [563, 18], "kind": "commanddeclaration"}, {"full_name": "Encodable.decidable_good", "code": "private def decidable_good : DecidablePred (good p) :=\n  fun n => by\n    cases n <;> unfold good <;> dsimp <;> infer_instance", "start": [565, 1], "end": [567, 57], "kind": "commanddeclaration"}, {"full_name": "Encodable.chooseX", "code": "def chooseX (h : \u2203 x, p x) : { a : \u03b1 // p a } :=\n  have : \u2203 n, good p (decode n) :=\n    let \u27e8w, pw\u27e9 := h\n    \u27e8encode w, by simp [good, encodek, pw]\u27e9\n  match (motive := \u2200 o, good p o \u2192 { a // p a }) _, Nat.find_spec this with\n  | some a, h => \u27e8a, h\u27e9", "start": [574, 1], "end": [580, 24], "kind": "commanddeclaration"}, {"full_name": "Encodable.choose", "code": "def choose (h : \u2203 x, p x) : \u03b1 :=\n  (chooseX h).1", "start": [583, 1], "end": [585, 16], "kind": "commanddeclaration"}, {"full_name": "Encodable.choose_spec", "code": "theorem choose_spec (h : \u2203 x, p x) : p (choose h)", "start": [588, 1], "end": [589, 16], "kind": "commanddeclaration"}, {"full_name": "Encodable.axiom_of_choice", "code": "theorem axiom_of_choice {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {R : \u2200 x, \u03b2 x \u2192 Prop} [\u2200 a, Encodable (\u03b2 a)]\n    [\u2200 x y, Decidable (R x y)] (H : \u2200 x, \u2203 y, R x y) : \u2203 f : \u2200 a, \u03b2 a, \u2200 x, R x (f x)", "start": [594, 1], "end": [597, 54], "kind": "commanddeclaration"}, {"full_name": "Encodable.skolem", "code": "theorem skolem {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {P : \u2200 x, \u03b2 x \u2192 Prop} [\u2200 a, Encodable (\u03b2 a)]\n    [\u2200 x y, Decidable (P x y)] : (\u2200 x, \u2203 y, P x y) \u2194 \u2203 f : \u2200 a, \u03b2 a, \u2200 x, P x (f x)", "start": [600, 1], "end": [603, 46], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode'", "code": "def encode' (\u03b1) [Encodable \u03b1] : \u03b1 \u21aa \u2115 :=\n  \u27e8Encodable.encode, Encodable.encode_injective\u27e9", "start": [609, 1], "end": [611, 49], "kind": "commanddeclaration"}, {"full_name": "Directed.sequence", "code": "protected noncomputable def sequence {r : \u03b2 \u2192 \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (hf : Directed r f) : \u2115 \u2192 \u03b1\n  | 0 => default\n  | n + 1 =>\n    let p := Directed.sequence f hf n\n    match (decode n: Option \u03b1) with\n    | none => Classical.choose (hf p p)\n    | some a => Classical.choose (hf p a)", "start": [631, 1], "end": [640, 42], "kind": "commanddeclaration"}, {"full_name": "Directed.sequence_mono_nat", "code": "theorem sequence_mono_nat {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Directed r f) (n : \u2115) :\n    r (f (hf.sequence f n)) (f (hf.sequence f (n + 1)))", "start": [643, 1], "end": [649, 45], "kind": "commanddeclaration"}, {"full_name": "Directed.rel_sequence", "code": "theorem rel_sequence {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Directed r f) (a : \u03b1) :\n    r (f a) (f (hf.sequence f (encode a + 1)))", "start": [652, 1], "end": [655, 43], "kind": "commanddeclaration"}, {"full_name": "Directed.sequence_mono", "code": "theorem sequence_mono : Monotone (f \u2218 hf.sequence f)", "start": [660, 1], "end": [661, 50], "kind": "commanddeclaration"}, {"full_name": "Directed.le_sequence", "code": "theorem le_sequence (a : \u03b1) : f a \u2264 f (hf.sequence f (encode a + 1))", "start": [664, 1], "end": [665, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.rep", "code": "def Quotient.rep (q : Quotient s) : \u03b1 :=\n  choose (exists_rep q)", "start": [676, 1], "end": [679, 24], "kind": "commanddeclaration"}, {"full_name": "Quotient.rep_spec", "code": "theorem Quotient.rep_spec (q : Quotient s) : \u27e6q.rep\u27e7 = q", "start": [682, 1], "end": [683, 29], "kind": "commanddeclaration"}, {"full_name": "encodableQuotient", "code": "def encodableQuotient : Encodable (Quotient s) :=\n  \u27e8fun q => encode q.rep, fun n => Quotient.mk'' <$> decode n, by\n    rintro \u27e8l\u27e9; dsimp; rw [encodek]; exact congr_arg some \u27e6l\u27e7.rep_spec\u27e9", "start": [686, 1], "end": [689, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/VecNotation.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/Fin/Tuple/Basic.lean", "Mathlib/GroupTheory/GroupAction/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.vecEmpty", "code": "def vecEmpty : Fin 0 \u2192 \u03b1 :=\n  Fin.elim0'", "start": [50, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecCons", "code": "def vecCons {n : \u2115} (h : \u03b1) (t : Fin n \u2192 \u03b1) : Fin n.succ \u2192 \u03b1 :=\n  Fin.cons h t", "start": [55, 1], "end": [61, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecConsUnexpander", "code": "@[app_unexpander vecCons]\ndef vecConsUnexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $term ![$term2, $terms,*]) => `(![$term, $term2, $terms,*])\n  | `($_ $term ![$term2]) => `(![$term, $term2])\n  | `($_ $term ![]) => `(![$term])\n  | _ => throw ()", "start": [79, 1], "end": [85, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecEmptyUnexpander", "code": "@[app_unexpander vecEmpty]\ndef vecEmptyUnexpander : Lean.PrettyPrinter.Unexpander\n  | _ => `(![])", "start": [87, 1], "end": [90, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecHead", "code": "def vecHead {n : \u2115} (v : Fin n.succ \u2192 \u03b1) : \u03b1 :=\n  v 0", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecTail", "code": "def vecTail {n : \u2115} (v : Fin n.succ \u2192 \u03b1) : Fin n \u2192 \u03b1 :=\n  v \u2218 Fin.succ", "start": [97, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "PiFin.hasRepr", "code": "instance _root_.PiFin.hasRepr [Repr \u03b1] : Repr (Fin n \u2192 \u03b1) where\n  reprPrec f _ :=\n    Std.Format.bracket \"![\" (Std.Format.joinSep\n      ((List.finRange n).map fun n => repr (f n)) (\",\" ++ Std.Format.line)) \"]\"", "start": [104, 1], "end": [113, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_eq", "code": "theorem empty_eq (v : Fin 0 \u2192 \u03b1) : v = ![]", "start": [120, 1], "end": [121, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_fin_const", "code": "@[simp]\ntheorem head_fin_const (a : \u03b1) : (vecHead fun _ : Fin (n + 1) => a) = a", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_zero", "code": "@[simp]\ntheorem cons_val_zero (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecCons x u 0 = x", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_zero'", "code": "theorem cons_val_zero' (h : 0 < m.succ) (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecCons x u \u27e80, h\u27e9 = x", "start": [136, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_succ", "code": "@[simp]\ntheorem cons_val_succ (x : \u03b1) (u : Fin m \u2192 \u03b1) (i : Fin m) : vecCons x u i.succ = u i", "start": [140, 1], "end": [142, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_succ'", "code": "@[simp]\ntheorem cons_val_succ' {i : \u2115} (h : i.succ < m.succ) (x : \u03b1) (u : Fin m \u2192 \u03b1) :\n    vecCons x u \u27e8i.succ, h\u27e9 = u \u27e8i, Nat.lt_of_succ_lt_succ h\u27e9", "start": [145, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_cons", "code": "@[simp]\ntheorem head_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecHead (vecCons x u) = x", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_cons", "code": "@[simp]\ntheorem tail_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecTail (vecCons x u) = u", "start": [156, 1], "end": [159, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_val'", "code": "@[simp]\ntheorem empty_val' {n' : Type*} (j : n') : (fun i => (![] : Fin 0 \u2192 n' \u2192 \u03b1) i j) = ![]", "start": [162, 1], "end": [164, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_head_tail", "code": "@[simp]\ntheorem cons_head_tail (u : Fin m.succ \u2192 \u03b1) : vecCons (vecHead u) (vecTail u) = u", "start": [167, 1], "end": [169, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_cons", "code": "@[simp]\ntheorem range_cons (x : \u03b1) (u : Fin n \u2192 \u03b1) : Set.range (vecCons x u) = {x} \u222a Set.range u", "start": [172, 1], "end": [174, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_empty", "code": "@[simp]\ntheorem range_empty (u : Fin 0 \u2192 \u03b1) : Set.range u = \u2205", "start": [177, 1], "end": [179, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_cons_empty", "code": "theorem range_cons_empty (x : \u03b1) (u : Fin 0 \u2192 \u03b1) : Set.range (Matrix.vecCons x u) = {x}", "start": [183, 1], "end": [184, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_cons_cons_empty", "code": "theorem range_cons_cons_empty (x y : \u03b1) (u : Fin 0 \u2192 \u03b1) :\n    Set.range (vecCons x <| vecCons y u) = {x, y}", "start": [188, 1], "end": [190, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecCons_const", "code": "@[simp]\ntheorem vecCons_const (a : \u03b1) : (vecCons a fun _ : Fin n => a) = fun _ => a", "start": [193, 1], "end": [195, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec_single_eq_const", "code": "theorem vec_single_eq_const (a : \u03b1) : ![a] = fun _ => a", "start": [198, 1], "end": [200, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_one", "code": "@[simp]\ntheorem cons_val_one (x : \u03b1) (u : Fin m.succ \u2192 \u03b1) : vecCons x u 1 = vecHead u", "start": [203, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_two", "code": "@[simp]\ntheorem cons_val_two (x : \u03b1) (u : Fin m.succ.succ \u2192 \u03b1) : vecCons x u 2 = vecHead (vecTail u)", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val_fin_one", "code": "@[simp]\ntheorem cons_val_fin_one (x : \u03b1) (u : Fin 0 \u2192 \u03b1) : \u2200 (i : Fin 1), vecCons x u i = x", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_fin_one", "code": "theorem cons_fin_one (x : \u03b1) (u : Fin 0 \u2192 \u03b1) : vecCons x u = fun _ => x", "start": [223, 1], "end": [224, 32], "kind": "commanddeclaration"}, {"full_name": "PiFin.toExpr", "code": "protected instance _root_.PiFin.toExpr [ToLevel.{u}] [ToExpr \u03b1] (n : \u2115) : ToExpr (Fin n \u2192 \u03b1) :=\n  have lu := toLevel.{u}\n  have e\u03b1 : Q(Type $lu) := toTypeExpr \u03b1\n  have toTypeExpr := q(Fin $n \u2192 $e\u03b1)\n  match n with\n  | 0 => { toTypeExpr, toExpr := fun _ => q(@vecEmpty $e\u03b1) }\n  | n + 1 =>\n    { toTypeExpr, toExpr := fun v =>\n      have := PiFin.toExpr n\n      have eh : Q($e\u03b1) := toExpr (vecHead v)\n      have et : Q(Fin $n \u2192 $e\u03b1) := toExpr (vecTail v)\n      q(vecCons $eh $et) }", "start": [229, 1], "end": [240, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAppend", "code": "def vecAppend {\u03b1 : Type*} {o : \u2115} (ho : o = m + n) (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) : Fin o \u2192 \u03b1 :=\n  Fin.append u v \u2218 Fin.cast ho", "start": [261, 1], "end": [269, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAppend_eq_ite", "code": "theorem vecAppend_eq_ite {\u03b1 : Type*} {o : \u2115} (ho : o = m + n) (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) :\n    vecAppend ho u v = fun i : Fin o =>\n      if h : (i : \u2115) < m then u \u27e8i, h\u27e9\n      else v \u27e8(i : \u2115) - m, (tsub_lt_iff_left (le_of_not_lt h)).2 (ho \u25b8 i.2)\u27e9", "start": [272, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAppend_apply_zero", "code": "@[simp]\ntheorem vecAppend_apply_zero {\u03b1 : Type*} {o : \u2115} (ho : o + 1 = m + 1 + n) (u : Fin (m + 1) \u2192 \u03b1)\n    (v : Fin n \u2192 \u03b1) : vecAppend ho u v 0 = u 0", "start": [286, 1], "end": [289, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_vecAppend", "code": "@[simp]\ntheorem empty_vecAppend (v : Fin n \u2192 \u03b1) : vecAppend (zero_add _).symm ![] v = v", "start": [292, 1], "end": [295, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecAppend", "code": "@[simp]\ntheorem cons_vecAppend (ho : o + 1 = m + 1 + n) (x : \u03b1) (u : Fin m \u2192 \u03b1) (v : Fin n \u2192 \u03b1) :\n    vecAppend ho (vecCons x u) v = vecCons x (vecAppend (by\n      rwa [add_assoc, add_comm 1, \u2190 add_assoc, add_right_cancel_iff] at ho) u v)", "start": [298, 1], "end": [312, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAlt0", "code": "def vecAlt0 (hm : m = n + n) (v : Fin m \u2192 \u03b1) (k : Fin n) : \u03b1 :=\n  v \u27e8(k : \u2115) + k, hm.symm \u25b8 add_lt_add k.2 k.2\u27e9", "start": [315, 1], "end": [318, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAlt1", "code": "def vecAlt1 (hm : m = n + n) (v : Fin m \u2192 \u03b1) (k : Fin n) : \u03b1 :=\n  v \u27e8(k : \u2115) + k + 1, hm.symm \u25b8 Nat.add_succ_lt_add k.2 k.2\u27e9", "start": [321, 1], "end": [324, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAlt0_vecAppend", "code": "theorem vecAlt0_vecAppend (v : Fin n \u2192 \u03b1) : vecAlt0 rfl (vecAppend rfl v v) = v \u2218 bit0", "start": [331, 1], "end": [341, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecAlt1_vecAppend", "code": "theorem vecAlt1_vecAppend (v : Fin (n + 1) \u2192 \u03b1) : vecAlt1 rfl (vecAppend rfl v v) = v \u2218 bit1", "start": [344, 1], "end": [361, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecHead_vecAlt0", "code": "@[simp]\ntheorem vecHead_vecAlt0 (hm : m + 2 = n + 1 + (n + 1)) (v : Fin (m + 2) \u2192 \u03b1) :\n    vecHead (vecAlt0 hm v) = v 0", "start": [364, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecHead_vecAlt1", "code": "@[simp]\ntheorem vecHead_vecAlt1 (hm : m + 2 = n + 1 + (n + 1)) (v : Fin (m + 2) \u2192 \u03b1) :\n    vecHead (vecAlt1 hm v) = v 1", "start": [370, 1], "end": [372, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vec_bit0_eq_alt0", "code": "@[simp]\ntheorem cons_vec_bit0_eq_alt0 (x : \u03b1) (u : Fin n \u2192 \u03b1) (i : Fin (n + 1)) :\n    vecCons x u (bit0 i) = vecAlt0 rfl (vecAppend rfl (vecCons x u) (vecCons x u)) i", "start": [375, 1], "end": [378, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vec_bit1_eq_alt1", "code": "@[simp]\ntheorem cons_vec_bit1_eq_alt1 (x : \u03b1) (u : Fin n \u2192 \u03b1) (i : Fin (n + 1)) :\n    vecCons x u (bit1 i) = vecAlt1 rfl (vecAppend rfl (vecCons x u) (vecCons x u)) i", "start": [381, 1], "end": [384, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecAlt0", "code": "@[simp]\ntheorem cons_vecAlt0 (h : m + 1 + 1 = n + 1 + (n + 1)) (x y : \u03b1) (u : Fin m \u2192 \u03b1) :\n    vecAlt0 h (vecCons x (vecCons y u)) =\n      vecCons x\n        (vecAlt0\n          (by\n            rwa [add_assoc n, add_comm 1, \u2190 add_assoc, \u2190 add_assoc, add_right_cancel_iff,\n              add_right_cancel_iff] at h)\n          u)", "start": [389, 1], "end": [402, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_vecAlt0", "code": "@[simp]\ntheorem empty_vecAlt0 (\u03b1) {h} : vecAlt0 h (![] : Fin 0 \u2192 \u03b1) = ![]", "start": [407, 1], "end": [408, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecAlt1", "code": "@[simp]\ntheorem cons_vecAlt1 (h : m + 1 + 1 = n + 1 + (n + 1)) (x y : \u03b1) (u : Fin m \u2192 \u03b1) :\n    vecAlt1 h (vecCons x (vecCons y u)) =\n      vecCons y\n        (vecAlt1\n          (by\n            rwa [add_assoc n, add_comm 1, \u2190 add_assoc, \u2190 add_assoc, add_right_cancel_iff,\n              add_right_cancel_iff] at h)\n          u)", "start": [411, 1], "end": [424, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_vecAlt1", "code": "@[simp]\ntheorem empty_vecAlt1 (\u03b1) {h} : vecAlt1 h (![] : Fin 0 \u2192 \u03b1) = ![]", "start": [429, 1], "end": [430, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_empty", "code": "@[simp]\ntheorem smul_empty (x : M) (v : Fin 0 \u2192 \u03b1) : x \u2022 v = ![]", "start": [439, 1], "end": [441, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_cons", "code": "@[simp]\ntheorem smul_cons (x : M) (y : \u03b1) (v : Fin n \u2192 \u03b1) : x \u2022 vecCons y v = vecCons (x \u2022 y) (x \u2022 v)", "start": [444, 1], "end": [447, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_add_empty", "code": "@[simp]\ntheorem empty_add_empty (v w : Fin 0 \u2192 \u03b1) : v + w = ![]", "start": [456, 1], "end": [458, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_add", "code": "@[simp]\ntheorem cons_add (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : Fin n.succ \u2192 \u03b1) :\n    vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w)", "start": [461, 1], "end": [465, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_cons", "code": "@[simp]\ntheorem add_cons (v : Fin n.succ \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    v + vecCons y w = vecCons (vecHead v + y) (vecTail v + w)", "start": [468, 1], "end": [472, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_add_cons", "code": "theorem cons_add_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    vecCons x v + vecCons y w = vecCons (x + y) (v + w)", "start": [476, 1], "end": [477, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_add", "code": "@[simp]\ntheorem head_add (a b : Fin n.succ \u2192 \u03b1) : vecHead (a + b) = vecHead a + vecHead b", "start": [480, 1], "end": [482, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_add", "code": "@[simp]\ntheorem tail_add (a b : Fin n.succ \u2192 \u03b1) : vecTail (a + b) = vecTail a + vecTail b", "start": [485, 1], "end": [487, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_sub_empty", "code": "@[simp]\ntheorem empty_sub_empty (v w : Fin 0 \u2192 \u03b1) : v - w = ![]", "start": [496, 1], "end": [498, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_sub", "code": "@[simp]\ntheorem cons_sub (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : Fin n.succ \u2192 \u03b1) :\n    vecCons x v - w = vecCons (x - vecHead w) (v - vecTail w)", "start": [501, 1], "end": [505, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub_cons", "code": "@[simp]\ntheorem sub_cons (v : Fin n.succ \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    v - vecCons y w = vecCons (vecHead v - y) (vecTail v - w)", "start": [508, 1], "end": [512, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_sub_cons", "code": "theorem cons_sub_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    vecCons x v - vecCons y w = vecCons (x - y) (v - w)", "start": [516, 1], "end": [517, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_sub", "code": "@[simp]\ntheorem head_sub (a b : Fin n.succ \u2192 \u03b1) : vecHead (a - b) = vecHead a - vecHead b", "start": [520, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_sub", "code": "@[simp]\ntheorem tail_sub (a b : Fin n.succ \u2192 \u03b1) : vecTail (a - b) = vecTail a - vecTail b", "start": [525, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_empty", "code": "@[simp]\ntheorem zero_empty : (0 : Fin 0 \u2192 \u03b1) = ![]", "start": [536, 1], "end": [538, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_zero_zero", "code": "@[simp]\ntheorem cons_zero_zero : vecCons (0 : \u03b1) (0 : Fin n \u2192 \u03b1) = 0", "start": [541, 1], "end": [546, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_zero", "code": "@[simp]\ntheorem head_zero : vecHead (0 : Fin n.succ \u2192 \u03b1) = 0", "start": [549, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_zero", "code": "@[simp]\ntheorem tail_zero : vecTail (0 : Fin n.succ \u2192 \u03b1) = 0", "start": [554, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_eq_zero_iff", "code": "@[simp]\ntheorem cons_eq_zero_iff {v : Fin n \u2192 \u03b1} {x : \u03b1} : vecCons x v = 0 \u2194 x = 0 \u2227 v = 0", "start": [559, 1], "end": [564, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_nonzero_iff", "code": "theorem cons_nonzero_iff {v : Fin n \u2192 \u03b1} {x : \u03b1} : vecCons x v \u2260 0 \u2194 x \u2260 0 \u2228 v \u2260 0", "start": [569, 1], "end": [571, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_empty", "code": "@[simp]\ntheorem neg_empty (v : Fin 0 \u2192 \u03b1) : -v = ![]", "start": [580, 1], "end": [582, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_cons", "code": "@[simp]\ntheorem neg_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) : -vecCons x v = vecCons (-x) (-v)", "start": [585, 1], "end": [588, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_neg", "code": "@[simp]\ntheorem head_neg (a : Fin n.succ \u2192 \u03b1) : vecHead (-a) = -vecHead a", "start": [591, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_neg", "code": "@[simp]\ntheorem tail_neg (a : Fin n.succ \u2192 \u03b1) : vecTail (-a) = -vecTail a", "start": [596, 1], "end": [598, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Units.lean", "imports": ["Mathlib/Data/Nat/Units.lean", "Mathlib/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Algebra/Ring/Units.lean"], "premises": [{"full_name": "Int.units_natAbs", "code": "@[simp]\ntheorem units_natAbs (u : \u2124\u02e3) : natAbs u = 1", "start": [22, 1], "end": [27, 47], "kind": "commanddeclaration"}, {"full_name": "Int.units_eq_one_or", "code": "theorem units_eq_one_or (u : \u2124\u02e3) : u = 1 \u2228 u = -1", "start": [30, 1], "end": [31, 61], "kind": "commanddeclaration"}, {"full_name": "Int.units_ne_neg_self", "code": "@[simp]\ntheorem units_ne_neg_self (u : \u2124\u02e3) : u \u2260 -u", "start": [34, 1], "end": [36, 53], "kind": "commanddeclaration"}, {"full_name": "Int.neg_units_ne_self", "code": "@[simp]\ntheorem neg_units_ne_self (u : \u2124\u02e3) : -u \u2260 u", "start": [38, 1], "end": [39, 74], "kind": "commanddeclaration"}, {"full_name": "Int.units_ne_iff_eq_neg", "code": "theorem units_ne_iff_eq_neg {u u' : \u2124\u02e3} : u \u2260 u' \u2194 u = -u'", "start": [41, 1], "end": [44, 9], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_ne_iff_eq_neg", "code": "theorem isUnit_ne_iff_eq_neg {u u' : \u2124} (hu : IsUnit u) (hu' : IsUnit u') : u \u2260 u' \u2194 u = -u'", "start": [46, 1], "end": [47, 91], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_eq_one_or", "code": "theorem isUnit_eq_one_or {a : \u2124} : IsUnit a \u2192 a = 1 \u2228 a = -1", "start": [49, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_iff", "code": "theorem isUnit_iff {a : \u2124} : IsUnit a \u2194 a = 1 \u2228 a = -1", "start": [53, 1], "end": [57, 25], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_eq_or_eq_neg", "code": "theorem isUnit_eq_or_eq_neg {a b : \u2124} (ha : IsUnit a) (hb : IsUnit b) : a = b \u2228 a = -b", "start": [60, 1], "end": [61, 58], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_or_neg_one_of_mul_eq_one", "code": "theorem eq_one_or_neg_one_of_mul_eq_one {z w : \u2124} (h : z * w = 1) : z = 1 \u2228 z = -1", "start": [64, 1], "end": [65, 45], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_or_neg_one_of_mul_eq_one'", "code": "theorem eq_one_or_neg_one_of_mul_eq_one' {z w : \u2124} (h : z * w = 1) :\n    z = 1 \u2227 w = 1 \u2228 z = -1 \u2227 w = -1", "start": [68, 1], "end": [72, 75], "kind": "commanddeclaration"}, {"full_name": "Int.eq_of_mul_eq_one", "code": "theorem eq_of_mul_eq_one {z w : \u2124} (h : z * w = 1) : z = w", "start": [75, 1], "end": [77, 62], "kind": "commanddeclaration"}, {"full_name": "Int.mul_eq_one_iff_eq_one_or_neg_one", "code": "theorem mul_eq_one_iff_eq_one_or_neg_one {z w : \u2124} :\n    z * w = 1 \u2194 z = 1 \u2227 w = 1 \u2228 z = -1 \u2227 w = -1", "start": [80, 1], "end": [84, 8], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_or_neg_one_of_mul_eq_neg_one'", "code": "theorem eq_one_or_neg_one_of_mul_eq_neg_one' {z w : \u2124} (h : z * w = -1) :\n    z = 1 \u2227 w = -1 \u2228 z = -1 \u2227 w = 1", "start": [87, 1], "end": [91, 55], "kind": "commanddeclaration"}, {"full_name": "Int.mul_eq_neg_one_iff_eq_one_or_neg_one", "code": "theorem mul_eq_neg_one_iff_eq_one_or_neg_one {z w : \u2124} :\n    z * w = -1 \u2194 z = 1 \u2227 w = -1 \u2228 z = -1 \u2227 w = 1", "start": [94, 1], "end": [98, 8], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_iff_natAbs_eq", "code": "theorem isUnit_iff_natAbs_eq {n : \u2124} : IsUnit n \u2194 n.natAbs = 1", "start": [101, 1], "end": [102, 50], "kind": "commanddeclaration"}, {"full_name": "Int.IsUnit.natAbs_eq", "code": "alias \u27e8IsUnit.natAbs_eq, _\u27e9 := isUnit_iff_natAbs_eq", "start": [105, 1], "end": [105, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.ofNat_isUnit", "code": "@[norm_cast]\ntheorem ofNat_isUnit {n : \u2115} : IsUnit (n : \u2124) \u2194 IsUnit n", "start": [110, 1], "end": [112, 30], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_mul_self", "code": "theorem isUnit_mul_self {a : \u2124} (ha : IsUnit a) : a * a = 1", "start": [115, 1], "end": [116, 75], "kind": "commanddeclaration"}, {"full_name": "Int.isUnit_add_isUnit_eq_isUnit_add_isUnit", "code": "theorem isUnit_add_isUnit_eq_isUnit_add_isUnit {a b c d : \u2124} (ha : IsUnit a) (hb : IsUnit b)\n    (hc : IsUnit c) (hd : IsUnit d) : a + b = c + d \u2194 a = c \u2227 b = d \u2228 a = d \u2227 b = c", "start": [120, 1], "end": [125, 9], "kind": "commanddeclaration"}, {"full_name": "Int.eq_one_or_neg_one_of_mul_eq_neg_one", "code": "theorem eq_one_or_neg_one_of_mul_eq_neg_one {z w : \u2124} (h : z * w = -1) : z = 1 \u2228 z = -1", "start": [128, 1], "end": [129, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Image.lean", "imports": ["Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonotoneOn.mapsTo_Ici", "code": "lemma MonotoneOn.mapsTo_Ici (h : MonotoneOn f (Ici a)) : MapsTo f (Ici a) (Ici (f a)) :=\n  fun _ _ \u21a6 by aesop", "start": [25, 1], "end": [26, 21], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.mapsTo_Iic", "code": "lemma MonotoneOn.mapsTo_Iic (h : MonotoneOn f (Iic b)) : MapsTo f (Iic b) (Iic (f b)) :=\n  fun _ _ \u21a6 by aesop", "start": [28, 1], "end": [29, 21], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.mapsTo_Icc", "code": "lemma MonotoneOn.mapsTo_Icc (h : MonotoneOn f (Icc a b)) : MapsTo f (Icc a b) (Icc (f a) (f b)) :=\n  fun _c hc \u21a6\n    \u27e8h (left_mem_Icc.2 <| hc.1.trans hc.2) hc hc.1, h hc (right_mem_Icc.2 <| hc.1.trans hc.2) hc.2\u27e9", "start": [31, 1], "end": [33, 100], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.mapsTo_Ici", "code": "lemma AntitoneOn.mapsTo_Ici (h : AntitoneOn f (Ici a)) : MapsTo f (Ici a) (Iic (f a)) :=\n  fun _ _ \u21a6 by aesop", "start": [35, 1], "end": [36, 21], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.mapsTo_Iic", "code": "lemma AntitoneOn.mapsTo_Iic (h : AntitoneOn f (Iic b)) : MapsTo f (Iic b) (Ici (f b)) :=\n  fun _ _ \u21a6 by aesop", "start": [38, 1], "end": [39, 21], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.mapsTo_Icc", "code": "lemma AntitoneOn.mapsTo_Icc (h : AntitoneOn f (Icc a b)) : MapsTo f (Icc a b) (Icc (f b) (f a)) :=\n  fun _c hc \u21a6\n    \u27e8h hc (right_mem_Icc.2 <| hc.1.trans hc.2) hc.2, h (left_mem_Icc.2 <| hc.1.trans hc.2) hc hc.1\u27e9", "start": [41, 1], "end": [43, 100], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.mapsTo_Ioi", "code": "lemma StrictMonoOn.mapsTo_Ioi (h : StrictMonoOn f (Ici a)) : MapsTo f (Ioi a) (Ioi (f a)) :=\n  fun _c hc \u21a6 h le_rfl hc.le hc", "start": [45, 1], "end": [46, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.mapsTo_Iio", "code": "lemma StrictMonoOn.mapsTo_Iio (h : StrictMonoOn f (Iic b)) : MapsTo f (Iio b) (Iio (f b)) :=\n  fun _c hc \u21a6 h hc.le le_rfl hc", "start": [48, 1], "end": [49, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.mapsTo_Ioo", "code": "lemma StrictMonoOn.mapsTo_Ioo (h : StrictMonoOn f (Icc a b)) :\n    MapsTo f (Ioo a b) (Ioo (f a) (f b)) :=\n  fun _c hc \u21a6\n    \u27e8h (left_mem_Icc.2 (hc.1.trans hc.2).le) (Ioo_subset_Icc_self hc) hc.1,\n     h (Ioo_subset_Icc_self hc) (right_mem_Icc.2 (hc.1.trans hc.2).le) hc.2\u27e9", "start": [51, 1], "end": [55, 77], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.mapsTo_Ioi", "code": "lemma StrictAntiOn.mapsTo_Ioi (h : StrictAntiOn f (Ici a)) : MapsTo f (Ioi a) (Iio (f a)) :=\n  fun _c hc \u21a6 h le_rfl hc.le hc", "start": [57, 1], "end": [58, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.mapsTo_Iio", "code": "lemma StrictAntiOn.mapsTo_Iio (h : StrictAntiOn f (Iic b)) : MapsTo f (Iio b) (Ioi (f b)) :=\n  fun _c hc \u21a6 h hc.le le_rfl hc", "start": [60, 1], "end": [61, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.mapsTo_Ioo", "code": "lemma StrictAntiOn.mapsTo_Ioo (h : StrictAntiOn f (Icc a b)) :\n    MapsTo f (Ioo a b) (Ioo (f b) (f a)) :=\n  fun _c hc \u21a6\n    \u27e8h (Ioo_subset_Icc_self hc) (right_mem_Icc.2 (hc.1.trans hc.2).le) hc.2,\n     h (left_mem_Icc.2 (hc.1.trans hc.2).le) (Ioo_subset_Icc_self hc) hc.1\u27e9", "start": [63, 1], "end": [67, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.mapsTo_Ici", "code": "lemma Monotone.mapsTo_Ici (h : Monotone f) : MapsTo f (Ici a) (Ici (f a)) :=\n  (h.monotoneOn _).mapsTo_Ici", "start": [69, 1], "end": [70, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.mapsTo_Iic", "code": "lemma Monotone.mapsTo_Iic (h : Monotone f) : MapsTo f (Iic b) (Iic (f b)) :=\n  (h.monotoneOn _).mapsTo_Iic", "start": [72, 1], "end": [73, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.mapsTo_Icc", "code": "lemma Monotone.mapsTo_Icc (h : Monotone f) : MapsTo f (Icc a b) (Icc (f a) (f b)) :=\n  (h.monotoneOn _).mapsTo_Icc", "start": [75, 1], "end": [76, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.mapsTo_Ici", "code": "lemma Antitone.mapsTo_Ici (h : Antitone f) : MapsTo f (Ici a) (Iic (f a)) :=\n  (h.antitoneOn _).mapsTo_Ici", "start": [78, 1], "end": [79, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.mapsTo_Iic", "code": "lemma Antitone.mapsTo_Iic (h : Antitone f) : MapsTo f (Iic b) (Ici (f b)) :=\n  (h.antitoneOn _).mapsTo_Iic", "start": [81, 1], "end": [82, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.mapsTo_Icc", "code": "lemma Antitone.mapsTo_Icc (h : Antitone f) : MapsTo f (Icc a b) (Icc (f b) (f a)) :=\n  (h.antitoneOn _).mapsTo_Icc", "start": [84, 1], "end": [85, 30], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.mapsTo_Ioi", "code": "lemma StrictMono.mapsTo_Ioi (h : StrictMono f) : MapsTo f (Ioi a) (Ioi (f a)) :=\n  (h.strictMonoOn _).mapsTo_Ioi", "start": [87, 1], "end": [88, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.mapsTo_Iio", "code": "lemma StrictMono.mapsTo_Iio (h : StrictMono f) : MapsTo f (Iio b) (Iio (f b)) :=\n  (h.strictMonoOn _).mapsTo_Iio", "start": [90, 1], "end": [91, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.mapsTo_Ioo", "code": "lemma StrictMono.mapsTo_Ioo (h : StrictMono f) : MapsTo f (Ioo a b) (Ioo (f a) (f b)) :=\n  (h.strictMonoOn _).mapsTo_Ioo", "start": [93, 1], "end": [94, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.mapsTo_Ioi", "code": "lemma StrictAnti.mapsTo_Ioi (h : StrictAnti f) : MapsTo f (Ioi a) (Iio (f a)) :=\n  (h.strictAntiOn _).mapsTo_Ioi", "start": [96, 1], "end": [97, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.mapsTo_Iio", "code": "lemma StrictAnti.mapsTo_Iio (h : StrictAnti f) : MapsTo f (Iio b) (Ioi (f b)) :=\n  (h.strictAntiOn _).mapsTo_Iio", "start": [99, 1], "end": [100, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.mapsTo_Ioo", "code": "lemma StrictAnti.mapsTo_Ioo (h : StrictAnti f) : MapsTo f (Ioo a b) (Ioo (f b) (f a)) :=\n  (h.strictAntiOn _).mapsTo_Ioo", "start": [102, 1], "end": [103, 32], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.image_Ici_subset", "code": "lemma MonotoneOn.image_Ici_subset (h : MonotoneOn f (Ici a)) : f '' Ici a \u2286 Ici (f a) :=\n  h.mapsTo_Ici.image_subset", "start": [105, 1], "end": [106, 28], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.image_Iic_subset", "code": "lemma MonotoneOn.image_Iic_subset (h : MonotoneOn f (Iic b)) : f '' Iic b \u2286 Iic (f b) :=\n  h.mapsTo_Iic.image_subset", "start": [108, 1], "end": [109, 28], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.image_Icc_subset", "code": "lemma MonotoneOn.image_Icc_subset (h : MonotoneOn f (Icc a b)) : f '' Icc a b \u2286 Icc (f a) (f b) :=\n  h.mapsTo_Icc.image_subset", "start": [111, 1], "end": [112, 28], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.image_Ici_subset", "code": "lemma AntitoneOn.image_Ici_subset (h : AntitoneOn f (Ici a)) : f '' Ici a \u2286 Iic (f a) :=\n  h.mapsTo_Ici.image_subset", "start": [115, 1], "end": [116, 28], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.image_Iic_subset", "code": "lemma AntitoneOn.image_Iic_subset (h : AntitoneOn f (Iic b)) : f '' Iic b \u2286 Ici (f b) :=\n  h.mapsTo_Iic.image_subset", "start": [118, 1], "end": [119, 28], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.image_Icc_subset", "code": "lemma AntitoneOn.image_Icc_subset (h : AntitoneOn f (Icc a b)) : f '' Icc a b \u2286 Icc (f b) (f a) :=\n  h.mapsTo_Icc.image_subset", "start": [121, 1], "end": [122, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.image_Ioi_subset", "code": "lemma StrictMonoOn.image_Ioi_subset (h : StrictMonoOn f (Ici a)) : f '' Ioi a \u2286 Ioi (f a) :=\n  h.mapsTo_Ioi.image_subset", "start": [125, 1], "end": [126, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.image_Iio_subset", "code": "lemma StrictMonoOn.image_Iio_subset (h : StrictMonoOn f (Iic b)) : f '' Iio b \u2286 Iio (f b) :=\n  h.mapsTo_Iio.image_subset", "start": [128, 1], "end": [129, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.image_Ioo_subset", "code": "lemma StrictMonoOn.image_Ioo_subset (h : StrictMonoOn f (Icc a b)) :\n    f '' Ioo a b \u2286 Ioo (f a) (f b) := h.mapsTo_Ioo.image_subset", "start": [131, 1], "end": [132, 64], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.image_Ioi_subset", "code": "lemma StrictAntiOn.image_Ioi_subset (h : StrictAntiOn f (Ici a)) : f '' Ioi a \u2286 Iio (f a) :=\n  h.mapsTo_Ioi.image_subset", "start": [134, 1], "end": [135, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.image_Iio_subset", "code": "lemma StrictAntiOn.image_Iio_subset (h : StrictAntiOn f (Iic b)) : f '' Iio b \u2286 Ioi (f b) :=\n  h.mapsTo_Iio.image_subset", "start": [137, 1], "end": [138, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.image_Ioo_subset", "code": "lemma StrictAntiOn.image_Ioo_subset (h : StrictAntiOn f (Icc a b)) :\n    f '' Ioo a b \u2286 Ioo (f b) (f a) := h.mapsTo_Ioo.image_subset", "start": [140, 1], "end": [141, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.image_Ici_subset", "code": "lemma Monotone.image_Ici_subset (h : Monotone f) : f '' Ici a \u2286 Ici (f a) :=\n  (h.monotoneOn _).image_Ici_subset", "start": [143, 1], "end": [144, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.image_Iic_subset", "code": "lemma Monotone.image_Iic_subset (h : Monotone f) : f '' Iic b \u2286 Iic (f b) :=\n  (h.monotoneOn _).image_Iic_subset", "start": [146, 1], "end": [147, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.image_Icc_subset", "code": "lemma Monotone.image_Icc_subset (h : Monotone f) : f '' Icc a b \u2286 Icc (f a) (f b) :=\n  (h.monotoneOn _).image_Icc_subset", "start": [149, 1], "end": [150, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.image_Ici_subset", "code": "lemma Antitone.image_Ici_subset (h : Antitone f) : f '' Ici a \u2286 Iic (f a) :=\n  (h.antitoneOn _).image_Ici_subset", "start": [153, 1], "end": [154, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.image_Iic_subset", "code": "lemma Antitone.image_Iic_subset (h : Antitone f) : f '' Iic b \u2286 Ici (f b) :=\n  (h.antitoneOn _).image_Iic_subset", "start": [156, 1], "end": [157, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.image_Icc_subset", "code": "lemma Antitone.image_Icc_subset (h : Antitone f) : f '' Icc a b \u2286 Icc (f b) (f a) :=\n  (h.antitoneOn _).image_Icc_subset", "start": [159, 1], "end": [160, 36], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.image_Ioi_subset", "code": "lemma StrictMono.image_Ioi_subset (h : StrictMono f) : f '' Ioi a \u2286 Ioi (f a) :=\n  (h.strictMonoOn _).image_Ioi_subset", "start": [163, 1], "end": [164, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.image_Iio_subset", "code": "lemma StrictMono.image_Iio_subset (h : StrictMono f) : f '' Iio b \u2286 Iio (f b) :=\n  (h.strictMonoOn _).image_Iio_subset", "start": [166, 1], "end": [167, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.image_Ioo_subset", "code": "lemma StrictMono.image_Ioo_subset (h : StrictMono f) : f '' Ioo a b \u2286 Ioo (f a) (f b) :=\n  (h.strictMonoOn _).image_Ioo_subset", "start": [169, 1], "end": [170, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.image_Ioi_subset", "code": "lemma StrictAnti.image_Ioi_subset (h : StrictAnti f) : f '' Ioi a \u2286 Iio (f a) :=\n  (h.strictAntiOn _).image_Ioi_subset", "start": [172, 1], "end": [173, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.image_Iio_subset", "code": "lemma StrictAnti.image_Iio_subset (h : StrictAnti f) : f '' Iio b \u2286 Ioi (f b) :=\n  (h.strictAntiOn _).image_Iio_subset", "start": [175, 1], "end": [176, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.image_Ioo_subset", "code": "lemma StrictAnti.image_Ioo_subset (h : StrictAnti f) : f '' Ioo a b \u2286 Ioo (f b) (f a) :=\n  (h.strictAntiOn _).image_Ioo_subset", "start": [178, 1], "end": [179, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.mapsTo_Ico", "code": "lemma StrictMonoOn.mapsTo_Ico (h : StrictMonoOn f (Icc a b)) :\n    MapsTo f (Ico a b) (Ico (f a) (f b)) :=\n  fun _c hc \u21a6 \u27e8h.monotoneOn (left_mem_Icc.2 <| hc.1.trans hc.2.le) (Ico_subset_Icc_self hc) hc.1,\n    h (Ico_subset_Icc_self hc) (right_mem_Icc.2 <| hc.1.trans hc.2.le) hc.2\u27e9", "start": [186, 1], "end": [189, 77], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.mapsTo_Ioc", "code": "lemma StrictMonoOn.mapsTo_Ioc (h : StrictMonoOn f (Icc a b)) :\n    MapsTo f (Ioc a b) (Ioc (f a) (f b)) :=\n  fun _c hc \u21a6 \u27e8h (left_mem_Icc.2 <| hc.1.le.trans hc.2) (Ioc_subset_Icc_self hc) hc.1,\n    h.monotoneOn (Ioc_subset_Icc_self hc) (right_mem_Icc.2 <| hc.1.le.trans hc.2) hc.2\u27e9", "start": [191, 1], "end": [194, 88], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.mapsTo_Ico", "code": "lemma StrictAntiOn.mapsTo_Ico (h : StrictAntiOn f (Icc a b)) :\n    MapsTo f (Ico a b) (Ioc (f b) (f a)) :=\n  fun _c hc \u21a6 \u27e8h (Ico_subset_Icc_self hc) (right_mem_Icc.2 <| hc.1.trans hc.2.le) hc.2,\n    h.antitoneOn (left_mem_Icc.2 <| hc.1.trans hc.2.le) (Ico_subset_Icc_self hc) hc.1\u27e9", "start": [196, 1], "end": [199, 87], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.mapsTo_Ioc", "code": "lemma StrictAntiOn.mapsTo_Ioc (h : StrictAntiOn f (Icc a b)) :\n    MapsTo f (Ioc a b) (Ico (f b) (f a)) :=\n  fun _c hc \u21a6 \u27e8h.antitoneOn (Ioc_subset_Icc_self hc) (right_mem_Icc.2 <| hc.1.le.trans hc.2) hc.2,\n    h (left_mem_Icc.2 <| hc.1.le.trans hc.2) (Ioc_subset_Icc_self hc) hc.1\u27e9", "start": [201, 1], "end": [204, 76], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.mapsTo_Ico", "code": "lemma StrictMono.mapsTo_Ico (h : StrictMono f) : MapsTo f (Ico a b) (Ico (f a) (f b)) :=\n  (h.strictMonoOn _).mapsTo_Ico", "start": [206, 1], "end": [207, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.mapsTo_Ioc", "code": "lemma StrictMono.mapsTo_Ioc (h : StrictMono f) : MapsTo f (Ioc a b) (Ioc (f a) (f b)) :=\n  (h.strictMonoOn _).mapsTo_Ioc", "start": [209, 1], "end": [210, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.mapsTo_Ico", "code": "lemma StrictAnti.mapsTo_Ico (h : StrictAnti f) : MapsTo f (Ico a b) (Ioc (f b) (f a)) :=\n  (h.strictAntiOn _).mapsTo_Ico", "start": [212, 1], "end": [213, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.mapsTo_Ioc", "code": "lemma StrictAnti.mapsTo_Ioc (h : StrictAnti f) : MapsTo f (Ioc a b) (Ico (f b) (f a)) :=\n  (h.strictAntiOn _).mapsTo_Ioc", "start": [215, 1], "end": [216, 32], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.image_Ico_subset", "code": "lemma StrictMonoOn.image_Ico_subset (h : StrictMonoOn f (Icc a b)) :\n    f '' Ico a b \u2286 Ico (f a) (f b) := h.mapsTo_Ico.image_subset", "start": [218, 1], "end": [219, 64], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.image_Ioc_subset", "code": "lemma StrictMonoOn.image_Ioc_subset (h : StrictMonoOn f (Icc a b)) :\n    f '' Ioc a b \u2286 Ioc (f a) (f b) :=\n  h.mapsTo_Ioc.image_subset", "start": [221, 1], "end": [223, 28], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.image_Ico_subset", "code": "lemma StrictAntiOn.image_Ico_subset (h : StrictAntiOn f (Icc a b)) :\n    f '' Ico a b \u2286 Ioc (f b) (f a) := h.mapsTo_Ico.image_subset", "start": [225, 1], "end": [226, 64], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAntiOn.image_Ioc_subset", "code": "lemma StrictAntiOn.image_Ioc_subset (h : StrictAntiOn f (Icc a b)) :\n    f '' Ioc a b \u2286 Ico (f b) (f a) := h.mapsTo_Ioc.image_subset", "start": [228, 1], "end": [229, 64], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.image_Ico_subset", "code": "lemma StrictMono.image_Ico_subset (h : StrictMono f) : f '' Ico a b \u2286 Ico (f a) (f b) :=\n  (h.strictMonoOn _).image_Ico_subset", "start": [231, 1], "end": [232, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.image_Ioc_subset", "code": "lemma StrictMono.image_Ioc_subset (h : StrictMono f) : f '' Ioc a b \u2286 Ioc (f a) (f b) :=\n  (h.strictMonoOn _).image_Ioc_subset", "start": [234, 1], "end": [235, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.image_Ico_subset", "code": "lemma StrictAnti.image_Ico_subset (h : StrictAnti f) : f '' Ico a b \u2286 Ioc (f b) (f a) :=\n  (h.strictAntiOn _).image_Ico_subset", "start": [237, 1], "end": [238, 38], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.image_Ioc_subset", "code": "lemma StrictAnti.image_Ioc_subset (h : StrictAnti f) : f '' Ioc a b \u2286 Ico (f b) (f a) :=\n  (h.strictAntiOn _).image_Ioc_subset", "start": [240, 1], "end": [241, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image_subtype_val_Icc_subset", "code": "theorem image_subtype_val_Icc_subset (a b : {x // p x}) :\n    Subtype.val '' Icc a b \u2286 Icc a.val b.val", "start": [249, 1], "end": [251, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Ico_subset", "code": "theorem image_subtype_val_Ico_subset (a b : {x // p x}) :\n    Subtype.val '' Ico a b \u2286 Ico a.val b.val", "start": [253, 1], "end": [255, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Ioc_subset", "code": "theorem image_subtype_val_Ioc_subset (a b : {x // p x}) :\n    Subtype.val '' Ioc a b \u2286 Ioc a.val b.val", "start": [257, 1], "end": [259, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Ioo_subset", "code": "theorem image_subtype_val_Ioo_subset (a b : {x // p x}) :\n    Subtype.val '' Ioo a b \u2286 Ioo a.val b.val", "start": [261, 1], "end": [263, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Iic_subset", "code": "theorem image_subtype_val_Iic_subset (a : {x // p x}) :\n    Subtype.val '' Iic a \u2286 Iic a.val", "start": [265, 1], "end": [267, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Iio_subset", "code": "theorem image_subtype_val_Iio_subset (a : {x // p x}) :\n    Subtype.val '' Iio a \u2286 Iio a.val", "start": [269, 1], "end": [271, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Ici_subset", "code": "theorem image_subtype_val_Ici_subset (a : {x // p x}) :\n    Subtype.val '' Ici a \u2286 Ici a.val", "start": [273, 1], "end": [275, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_subtype_val_Ioi_subset", "code": "theorem image_subtype_val_Ioi_subset (a : {x // p x}) :\n    Subtype.val '' Ioi a \u2286 Ioi a.val", "start": [277, 1], "end": [279, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Opposite.lean", "imports": ["Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.mulAction", "code": "@[to_additive]\ninstance mulAction (R : Type*) [Monoid R] [MulAction R \u03b1] : MulAction R \u03b1\u1d50\u1d52\u1d56 :=\n  { one_smul := fun x => unop_injective <| one_smul R (unop x)\n    mul_smul := fun r\u2081 r\u2082 x => unop_injective <| mul_smul r\u2081 r\u2082 (unop x) }", "start": [33, 1], "end": [36, 75], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.distribMulAction", "code": "instance distribMulAction (R : Type*) [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] :\n    DistribMulAction R \u03b1\u1d50\u1d52\u1d56 :=\n  { smul_add := fun r x\u2081 x\u2082 => unop_injective <| smul_add r (unop x\u2081) (unop x\u2082)\n    smul_zero := fun r => unop_injective <| smul_zero r }", "start": [38, 1], "end": [41, 58], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.mulDistribMulAction", "code": "instance mulDistribMulAction (R : Type*) [Monoid R] [Monoid \u03b1] [MulDistribMulAction R \u03b1] :\n    MulDistribMulAction R \u03b1\u1d50\u1d52\u1d56 :=\n  { smul_mul := fun r x\u2081 x\u2082 => unop_injective <| smul_mul' r (unop x\u2082) (unop x\u2081)\n    smul_one := fun r => unop_injective <| smul_one r }", "start": [43, 1], "end": [46, 56], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isScalarTower", "code": "@[to_additive]\ninstance isScalarTower {M N} [SMul M N] [SMul M \u03b1] [SMul N \u03b1] [IsScalarTower M N \u03b1] :\n    IsScalarTower M N \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun _ _ _ => unop_injective <| smul_assoc _ _ _\u27e9", "start": [48, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass {M N} [SMul M \u03b1] [SMul N \u03b1] [SMulCommClass M N \u03b1] : SMulCommClass M N \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun _ _ _ => unop_injective <| smul_comm _ _ _\u27e9", "start": [53, 1], "end": [55, 51], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar (R : Type*) [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar R \u03b1] :\n    IsCentralScalar R \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun _ _ => unop_injective <| op_smul_eq_smul _ _\u27e9", "start": [57, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_smul_eq_op_smul_op", "code": "theorem op_smul_eq_op_smul_op {R : Type*} [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar R \u03b1]\n    (r : R) (a : \u03b1) : op (r \u2022 a) = op r \u2022 op a", "start": [62, 1], "end": [64, 34], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_smul_eq_unop_smul_unop", "code": "theorem unop_smul_eq_unop_smul_unop {R : Type*} [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1]\n    [IsCentralScalar R \u03b1] (r : R\u1d50\u1d52\u1d56) (a : \u03b1\u1d50\u1d52\u1d56) : unop (r \u2022 a) = unop r \u2022 unop a", "start": [67, 1], "end": [69, 38], "kind": "commanddeclaration"}, {"full_name": "Mul.toHasOppositeSMul", "code": "@[to_additive \"Like `Add.toVAdd`, but adds on the right.\n\n  See also `AddMonoid.to_OppositeAddAction`.\"]\ninstance Mul.toHasOppositeSMul [Mul \u03b1] : SMul \u03b1\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8fun c x => x * c.unop\u27e9", "start": [84, 1], "end": [91, 26], "kind": "commanddeclaration"}, {"full_name": "op_smul_eq_mul", "code": "@[to_additive]\ntheorem op_smul_eq_mul [Mul \u03b1] {a a' : \u03b1} : op a \u2022 a' = a' * a", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.smul_eq_mul_unop", "code": "@[to_additive (attr := simp)]\ntheorem MulOpposite.smul_eq_mul_unop [Mul \u03b1] {a : \u03b1\u1d50\u1d52\u1d56} {a' : \u03b1} : a \u2022 a' = a' * a.unop", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.OppositeRegular.isPretransitive", "code": "@[to_additive \"The right regular action of an additive group on itself is transitive.\"]\ninstance MulAction.OppositeRegular.isPretransitive {G : Type*} [Group G] :\n    MulAction.IsPretransitive G\u1d50\u1d52\u1d56 G :=\n  \u27e8fun x y => \u27e8op (x\u207b\u00b9 * y), mul_inv_cancel_left _ _\u27e9\u27e9", "start": [107, 1], "end": [111, 55], "kind": "commanddeclaration"}, {"full_name": "Semigroup.opposite_smulCommClass", "code": "@[to_additive]\ninstance Semigroup.opposite_smulCommClass [Semigroup \u03b1] :\n    SMulCommClass \u03b1\u1d50\u1d52\u1d56 \u03b1 \u03b1 where smul_comm _ _ _ := mul_assoc _ _ _", "start": [115, 1], "end": [117, 68], "kind": "commanddeclaration"}, {"full_name": "Semigroup.opposite_smulCommClass'", "code": "@[to_additive]\ninstance Semigroup.opposite_smulCommClass' [Semigroup \u03b1] : SMulCommClass \u03b1 \u03b1\u1d50\u1d52\u1d56 \u03b1 :=\n  SMulCommClass.symm _ _ _", "start": [121, 1], "end": [123, 27], "kind": "commanddeclaration"}, {"full_name": "CommSemigroup.isCentralScalar", "code": "@[to_additive]\ninstance CommSemigroup.isCentralScalar [CommSemigroup \u03b1] : IsCentralScalar \u03b1 \u03b1 :=\n  \u27e8fun _ _ => mul_comm _ _\u27e9", "start": [127, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "Monoid.toOppositeMulAction", "code": "@[to_additive \"Like `AddMonoid.toAddAction`, but adds on the right.\"]\ninstance Monoid.toOppositeMulAction [Monoid \u03b1] :\n    MulAction \u03b1\u1d50\u1d52\u1d56 \u03b1 where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul := mul_one\n  mul_smul _ _ _ := (mul_assoc _ _ _).symm", "start": [133, 1], "end": [139, 43], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.opposite_mid", "code": "@[to_additive]\ninstance IsScalarTower.opposite_mid {M N} [Mul N] [SMul M N] [SMulCommClass M N N] :\n    IsScalarTower M N\u1d50\u1d52\u1d56 N :=\n  \u27e8fun _ _ _ => mul_smul_comm _ _ _\u27e9", "start": [143, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.opposite_mid", "code": "@[to_additive]\ninstance SMulCommClass.opposite_mid {M N} [Mul N] [SMul M N] [IsScalarTower M N N] :\n    SMulCommClass M N\u1d50\u1d52\u1d56 N :=\n  \u27e8fun x y z => by\n    induction y using MulOpposite.rec'\n    simp only [smul_mul_assoc, MulOpposite.smul_eq_mul_unop]\u27e9", "start": [150, 1], "end": [155, 62], "kind": "commanddeclaration"}, {"full_name": "LeftCancelMonoid.toFaithfulSMul_opposite", "code": "@[to_additive \"`AddMonoid.toOppositeAddAction` is faithful on cancellative monoids.\"]\ninstance LeftCancelMonoid.toFaithfulSMul_opposite [LeftCancelMonoid \u03b1] :\n    FaithfulSMul \u03b1\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8fun h => unop_injective <| mul_left_cancel (h 1)\u27e9", "start": [164, 1], "end": [168, 53], "kind": "commanddeclaration"}, {"full_name": "CancelMonoidWithZero.toFaithfulSMul_opposite", "code": "instance CancelMonoidWithZero.toFaithfulSMul_opposite [CancelMonoidWithZero \u03b1]\n    [Nontrivial \u03b1] : FaithfulSMul \u03b1\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8fun h => unop_injective <| mul_left_cancel\u2080 one_ne_zero (h 1)\u27e9", "start": [172, 1], "end": [175, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupPower/Lemmas.lean", "imports": ["Mathlib/Algebra/GroupPower/Ring.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Algebra/Group/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Data/Nat/Pow.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Algebra/Invertible/Basic.lean"], "premises": [{"full_name": "nsmul_one", "code": "@[simp]\ntheorem nsmul_one [AddMonoidWithOne A] : \u2200 n : \u2115, n \u2022 (1 : A) = n", "start": [36, 1], "end": [43, 7], "kind": "commanddeclaration"}, {"full_name": "invertiblePow", "code": "instance invertiblePow (m : M) [Invertible m] (n : \u2115) :\n    Invertible (m ^ n) where\n  invOf := \u215f m ^ n\n  invOf_mul_self := by rw [\u2190 (commute_invOf m).symm.mul_pow, invOf_mul_self, one_pow]\n  mul_invOf_self := by rw [\u2190 (commute_invOf m).mul_pow, mul_invOf_self, one_pow]", "start": [48, 1], "end": [52, 81], "kind": "commanddeclaration"}, {"full_name": "invOf_pow", "code": "theorem invOf_pow (m : M) [Invertible m] (n : \u2115) [Invertible (m ^ n)] : \u215f (m ^ n) = \u215f m ^ n", "start": [55, 1], "end": [56, 67], "kind": "commanddeclaration"}, {"full_name": "IsUnit.pow", "code": "@[to_additive]\ntheorem IsUnit.pow {m : M} (n : \u2115) : IsUnit m \u2192 IsUnit (m ^ n)", "start": [59, 1], "end": [61, 39], "kind": "commanddeclaration"}, {"full_name": "Units.ofPow", "code": "@[to_additive \"If a natural multiple of `x` is an additive unit, then `x` is an additive unit.\"]\ndef Units.ofPow (u : M\u02e3) (x : M) {n : \u2115} (hn : n \u2260 0) (hu : x ^ n = u) : M\u02e3 :=\n  u.leftOfMul x (x ^ (n - 1))\n    (by rwa [\u2190 _root_.pow_succ, Nat.sub_add_cancel (Nat.succ_le_of_lt <| Nat.pos_of_ne_zero hn)])\n    (Commute.self_pow _ _)", "start": [65, 1], "end": [70, 27], "kind": "commanddeclaration"}, {"full_name": "isUnit_pow_iff", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_pow_iff {a : M} {n : \u2115} (hn : n \u2260 0) : IsUnit (a ^ n) \u2194 IsUnit a", "start": [74, 1], "end": [76, 67], "kind": "commanddeclaration"}, {"full_name": "isUnit_pow_succ_iff", "code": "@[to_additive]\ntheorem isUnit_pow_succ_iff {m : M} {n : \u2115} : IsUnit (m ^ (n + 1)) \u2194 IsUnit m", "start": [80, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "Units.ofPowEqOne", "code": "@[to_additive (attr := simps!) \"If `n \u2022 x = 0`, `n \u2260 0`, then `x` is an additive unit.\"]\ndef Units.ofPowEqOne (x : M) (n : \u2115) (hx : x ^ n = 1) (hn : n \u2260 0) : M\u02e3 :=\n  Units.ofPow 1 x hn hx", "start": [86, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "Units.pow_ofPowEqOne", "code": "@[to_additive (attr := simp)]\ntheorem Units.pow_ofPowEqOne {x : M} {n : \u2115} (hx : x ^ n = 1) (hn : n \u2260 0) :\n    Units.ofPowEqOne x n hx hn ^ n = 1", "start": [93, 1], "end": [96, 28], "kind": "commanddeclaration"}, {"full_name": "isUnit_ofPowEqOne", "code": "@[to_additive]\ntheorem isUnit_ofPowEqOne {x : M} {n : \u2115} (hx : x ^ n = 1) (hn : n \u2260 0) : IsUnit x", "start": [100, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "invertibleOfPowEqOne", "code": "def invertibleOfPowEqOne (x : M) (n : \u2115) (hx : x ^ n = 1) (hn : n \u2260 0) : Invertible x :=\n  (Units.ofPowEqOne x n hx hn).invertible", "start": [106, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "smul_pow", "code": "theorem smul_pow [MulAction M N] [IsScalarTower M N N] [SMulCommClass M N N] (k : M) (x : N)\n    (p : \u2115) : (k \u2022 x) ^ p = k ^ p \u2022 x ^ p", "start": [111, 1], "end": [115, 64], "kind": "commanddeclaration"}, {"full_name": "smul_pow'", "code": "@[simp]\ntheorem smul_pow' [MulDistribMulAction M N] (x : M) (m : N) (n : \u2115) : x \u2022 m ^ n = (x \u2022 m) ^ n", "start": [118, 1], "end": [124, 57], "kind": "commanddeclaration"}, {"full_name": "zsmul_one", "code": "@[simp]\ntheorem zsmul_one [AddGroupWithOne A] (n : \u2124) : n \u2022 (1 : A) = n", "start": [129, 1], "end": [130, 87], "kind": "commanddeclaration"}, {"full_name": "zpow_mul", "code": "@[to_additive mul_zsmul']\ntheorem zpow_mul (a : \u03b1) : \u2200 m n : \u2124, a ^ (m * n) = (a ^ m) ^ n", "start": [140, 1], "end": [153, 8], "kind": "commanddeclaration"}, {"full_name": "zpow_mul'", "code": "@[to_additive mul_zsmul]\ntheorem zpow_mul' (a : \u03b1) (m n : \u2124) : a ^ (m * n) = (a ^ n) ^ m", "start": [157, 1], "end": [158, 94], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0", "code": "@[to_additive bit0_zsmul]\ntheorem zpow_bit0 (a : \u03b1) : \u2200 n : \u2124, a ^ bit0 n = a ^ n * a ^ n", "start": [166, 1], "end": [172, 14], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0'", "code": "@[to_additive bit0_zsmul']\ntheorem zpow_bit0' (a : \u03b1) (n : \u2124) : a ^ bit0 n = (a * a) ^ n", "start": [176, 1], "end": [178, 59], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0_neg", "code": "@[simp]\ntheorem zpow_bit0_neg [HasDistribNeg \u03b1] (x : \u03b1) (n : \u2124) : (-x) ^ bit0 n = x ^ bit0 n", "start": [182, 1], "end": [184, 43], "kind": "commanddeclaration"}, {"full_name": "zpow_add_one", "code": "@[to_additive add_one_zsmul]\ntheorem zpow_add_one (a : G) : \u2200 n : \u2124, a ^ (n + 1) = a ^ n * a", "start": [195, 1], "end": [202, 27], "kind": "commanddeclaration"}, {"full_name": "zpow_sub_one", "code": "@[to_additive sub_one_zsmul]\ntheorem zpow_sub_one (a : G) (n : \u2124) : a ^ (n - 1) = a ^ n * a\u207b\u00b9", "start": [206, 1], "end": [210, 62], "kind": "commanddeclaration"}, {"full_name": "zpow_add", "code": "@[to_additive add_zsmul]\ntheorem zpow_add (a : G) (m n : \u2124) : a ^ (m + n) = a ^ m * a ^ n", "start": [214, 1], "end": [219, 73], "kind": "commanddeclaration"}, {"full_name": "mul_self_zpow", "code": "@[to_additive add_zsmul_self]\ntheorem mul_self_zpow (b : G) (m : \u2124) : b * b ^ m = b ^ (m + 1)", "start": [223, 1], "end": [228, 28], "kind": "commanddeclaration"}, {"full_name": "mul_zpow_self", "code": "@[to_additive add_self_zsmul]\ntheorem mul_zpow_self (b : G) (m : \u2124) : b ^ m * b = b ^ (m + 1)", "start": [232, 1], "end": [238, 28], "kind": "commanddeclaration"}, {"full_name": "zpow_sub", "code": "@[to_additive sub_zsmul]\ntheorem zpow_sub (a : G) (m n : \u2124) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9", "start": [242, 1], "end": [244, 42], "kind": "commanddeclaration"}, {"full_name": "zpow_one_add", "code": "@[to_additive one_add_zsmul]\ntheorem zpow_one_add (a : G) (i : \u2124) : a ^ (1 + i) = a * a ^ i", "start": [248, 1], "end": [249, 93], "kind": "commanddeclaration"}, {"full_name": "zpow_mul_comm", "code": "@[to_additive]\ntheorem zpow_mul_comm (a : G) (i j : \u2124) : a ^ i * a ^ j = a ^ j * a ^ i", "start": [253, 1], "end": [255, 33], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1", "code": "@[to_additive bit1_zsmul]\ntheorem zpow_bit1 (a : G) (n : \u2124) : a ^ bit1 n = a ^ n * a ^ n * a", "start": [263, 1], "end": [265, 43], "kind": "commanddeclaration"}, {"full_name": "zpow_induction_left", "code": "@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the left. For additive subgroups generated by more than one element, see\n`AddSubgroup.closure_induction_left`.\"]\ntheorem zpow_induction_left {g : G} {P : G \u2192 Prop} (h_one : P (1 : G))\n    (h_mul : \u2200 a, P a \u2192 P (g * a)) (h_inv : \u2200 a, P a \u2192 P (g\u207b\u00b9 * a)) (n : \u2124) : P (g ^ n)", "start": [271, 1], "end": [284, 21], "kind": "commanddeclaration"}, {"full_name": "zpow_induction_right", "code": "@[to_additive \"To show a property of all multiples of `g` it suffices to show it is closed under\naddition by `g` and `-g` on the right. For additive subgroups generated by more than one element,\nsee `AddSubgroup.closure_induction_right`.\"]\ntheorem zpow_induction_right {g : G} {P : G \u2192 Prop} (h_one : P (1 : G))\n    (h_mul : \u2200 a, P a \u2192 P (a * g)) (h_inv : \u2200 a, P a \u2192 P (a * g\u207b\u00b9)) (n : \u2124) : P (g ^ n)", "start": [288, 1], "end": [301, 21], "kind": "commanddeclaration"}, {"full_name": "one_lt_zpow'", "code": "@[to_additive zsmul_pos]\ntheorem one_lt_zpow' (ha : 1 < a) {k : \u2124} (hk : (0 : \u2124) < k) : 1 < a ^ k", "start": [319, 1], "end": [324, 13], "kind": "commanddeclaration"}, {"full_name": "zpow_strictMono_right", "code": "@[to_additive zsmul_strictMono_left]\ntheorem zpow_strictMono_right (ha : 1 < a) : StrictMono fun n : \u2124 => a ^ n", "start": [328, 1], "end": [333, 42], "kind": "commanddeclaration"}, {"full_name": "zpow_mono_right", "code": "@[to_additive zsmul_mono_left]\ntheorem zpow_mono_right (ha : 1 \u2264 a) : Monotone fun n : \u2124 => a ^ n", "start": [337, 1], "end": [342, 42], "kind": "commanddeclaration"}, {"full_name": "zpow_le_zpow", "code": "@[to_additive]\ntheorem zpow_le_zpow (ha : 1 \u2264 a) (h : m \u2264 n) : a ^ m \u2264 a ^ n", "start": [346, 1], "end": [348, 23], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_zpow", "code": "@[to_additive]\ntheorem zpow_lt_zpow (ha : 1 < a) (h : m < n) : a ^ m < a ^ n", "start": [352, 1], "end": [354, 29], "kind": "commanddeclaration"}, {"full_name": "zpow_le_zpow_iff", "code": "@[to_additive]\ntheorem zpow_le_zpow_iff (ha : 1 < a) : a ^ m \u2264 a ^ n \u2194 m \u2264 n", "start": [358, 1], "end": [360, 39], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_zpow_iff", "code": "@[to_additive]\ntheorem zpow_lt_zpow_iff (ha : 1 < a) : a ^ m < a ^ n \u2194 m < n", "start": [364, 1], "end": [366, 39], "kind": "commanddeclaration"}, {"full_name": "zpow_strictMono_left", "code": "@[to_additive zsmul_strictMono_right]\ntheorem zpow_strictMono_left (hn : 0 < n) : StrictMono ((\u00b7 ^ n) : \u03b1 \u2192 \u03b1)", "start": [372, 1], "end": [375, 44], "kind": "commanddeclaration"}, {"full_name": "zpow_mono_left", "code": "@[to_additive zsmul_mono_right]\ntheorem zpow_mono_left (hn : 0 \u2264 n) : Monotone ((\u00b7 ^ n) : \u03b1 \u2192 \u03b1)", "start": [379, 1], "end": [382, 43], "kind": "commanddeclaration"}, {"full_name": "zpow_le_zpow'", "code": "@[to_additive]\ntheorem zpow_le_zpow' (hn : 0 \u2264 n) (h : a \u2264 b) : a ^ n \u2264 b ^ n", "start": [388, 1], "end": [390, 24], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_zpow'", "code": "@[to_additive]\ntheorem zpow_lt_zpow' (hn : 0 < n) (h : a < b) : a ^ n < b ^ n", "start": [394, 1], "end": [396, 30], "kind": "commanddeclaration"}, {"full_name": "zpow_le_zpow_iff'", "code": "@[to_additive]\ntheorem zpow_le_zpow_iff' (hn : 0 < n) {a b : \u03b1} : a ^ n \u2264 b ^ n \u2194 a \u2264 b", "start": [406, 1], "end": [408, 40], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_zpow_iff'", "code": "@[to_additive]\ntheorem zpow_lt_zpow_iff' (hn : 0 < n) {a b : \u03b1} : a ^ n < b ^ n \u2194 a < b", "start": [412, 1], "end": [414, 40], "kind": "commanddeclaration"}, {"full_name": "zpow_left_injective", "code": "@[to_additive zsmul_right_injective\n      \"See also `smul_right_injective`. TODO: provide a `NoZeroSMulDivisors` instance. We can't do\n      that here because importing that definition would create import cycles.\"]\ntheorem zpow_left_injective (hn : n \u2260 0) : Function.Injective ((\u00b7 ^ n) : \u03b1 \u2192 \u03b1)", "start": [418, 1], "end": [425, 33], "kind": "commanddeclaration"}, {"full_name": "zpow_left_inj", "code": "@[to_additive zsmul_right_inj]\ntheorem zpow_left_inj (hn : n \u2260 0) : a ^ n = b ^ n \u2194 a = b", "start": [429, 1], "end": [431, 34], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_zpow_iff'", "code": "@[to_additive\n      \"Alias of `zsmul_right_inj`, for ease of discovery alongside\n      `zsmul_le_zsmul_iff'` and `zsmul_lt_zsmul_iff'`.\"]\ntheorem zpow_eq_zpow_iff' (hn : n \u2260 0) : a ^ n = b ^ n \u2194 a = b", "start": [435, 1], "end": [441, 19], "kind": "commanddeclaration"}, {"full_name": "abs_nsmul", "code": "theorem abs_nsmul (n : \u2115) (a : \u03b1) : |n \u2022 a| = n \u2022 |a|", "start": [451, 1], "end": [456, 30], "kind": "commanddeclaration"}, {"full_name": "abs_zsmul", "code": "theorem abs_zsmul (n : \u2124) (a : \u03b1) : |n \u2022 a| = |n| \u2022 |a|", "start": [459, 1], "end": [465, 24], "kind": "commanddeclaration"}, {"full_name": "abs_add_eq_add_abs_le", "code": "theorem abs_add_eq_add_abs_le (hle : a \u2264 b) :\n    |a + b| = |a| + |b| \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "start": [468, 1], "end": [482, 41], "kind": "commanddeclaration"}, {"full_name": "abs_add_eq_add_abs_iff", "code": "theorem abs_add_eq_add_abs_iff (a b : \u03b1) : |a + b| = |a| + |b| \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "start": [485, 1], "end": [488, 93], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_nsmul", "code": "@[simp]\ntheorem WithBot.coe_nsmul [AddMonoid A] (a : A) (n : \u2115) : \u2191(n \u2022 a) = n \u2022 (a : WithBot A)", "start": [493, 1], "end": [499, 8], "kind": "commanddeclaration"}, {"full_name": "nsmul_eq_mul'", "code": "theorem nsmul_eq_mul' [NonAssocSemiring R] (a : R) (n : \u2115) : n \u2022 a = a * n", "start": [502, 1], "end": [504, 59], "kind": "commanddeclaration"}, {"full_name": "nsmul_eq_mul", "code": "@[simp]\ntheorem nsmul_eq_mul [NonAssocSemiring R] (n : \u2115) (a : R) : n \u2022 a = n * a", "start": [508, 1], "end": [510, 44], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocSemiring.nat_smulCommClass", "code": "instance NonUnitalNonAssocSemiring.nat_smulCommClass [NonUnitalNonAssocSemiring R] :\n    SMulCommClass \u2115 R R :=\n  \u27e8fun n x y => by\n    induction' n with n ih\n    \u00b7 simp [zero_nsmul]\n    \u00b7 simp_rw [succ_nsmul, smul_eq_mul, mul_add, \u2190 smul_eq_mul, ih]\u27e9", "start": [514, 1], "end": [520, 69], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocSemiring.nat_isScalarTower", "code": "instance NonUnitalNonAssocSemiring.nat_isScalarTower [NonUnitalNonAssocSemiring R] :\n    IsScalarTower \u2115 R R :=\n  \u27e8fun n x y => by\n    induction' n with n ih\n    \u00b7 simp [zero_nsmul]\n    \u00b7 simp_rw [succ_nsmul, \u2190 ih, smul_eq_mul, add_mul]\u27e9", "start": [523, 1], "end": [529, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_pow", "code": "@[simp, norm_cast]\ntheorem Nat.cast_pow [Semiring R] (n m : \u2115) : (\u2191(n ^ m) : R) = (\u2191n : R) ^ m", "start": [532, 1], "end": [536, 62], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_pow", "code": "theorem Int.coe_nat_pow (n m : \u2115) : ((n ^ m : \u2115) : \u2124) = (n : \u2124) ^ m", "start": [545, 1], "end": [546, 33], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_pow", "code": "theorem Int.natAbs_pow (n : \u2124) (k : \u2115) : Int.natAbs (n ^ k) = Int.natAbs n ^ k", "start": [549, 1], "end": [550, 82], "kind": "commanddeclaration"}, {"full_name": "bit0_mul", "code": "theorem bit0_mul [NonUnitalNonAssocRing R] {n r : R} : bit0 n * r = (2 : \u2124) \u2022 (n * r)", "start": [559, 1], "end": [561, 59], "kind": "commanddeclaration"}, {"full_name": "mul_bit0", "code": "theorem mul_bit0 [NonUnitalNonAssocRing R] {n r : R} : r * bit0 n = (2 : \u2124) \u2022 (r * n)", "start": [564, 1], "end": [566, 59], "kind": "commanddeclaration"}, {"full_name": "bit1_mul", "code": "theorem bit1_mul [NonAssocRing R] {n r : R} : bit1 n * r = (2 : \u2124) \u2022 (n * r) + r", "start": [569, 1], "end": [571, 34], "kind": "commanddeclaration"}, {"full_name": "mul_bit1", "code": "theorem mul_bit1 [NonAssocRing R] {n r : R} : r * bit1 n = (2 : \u2124) \u2022 (r * n) + r", "start": [574, 1], "end": [576, 34], "kind": "commanddeclaration"}, {"full_name": "Int.cast_mul_eq_zsmul_cast", "code": "theorem Int.cast_mul_eq_zsmul_cast [AddCommGroupWithOne \u03b1] :\n    \u2200 m n, ((m * n : \u2124) : \u03b1) = m \u2022 (n : \u03b1)", "start": [581, 1], "end": [586, 55], "kind": "commanddeclaration"}, {"full_name": "zsmul_eq_mul", "code": "@[simp]\ntheorem zsmul_eq_mul [Ring R] (a : R) : \u2200 n : \u2124, n \u2022 a = n * a", "start": [589, 1], "end": [592, 78], "kind": "commanddeclaration"}, {"full_name": "zsmul_eq_mul'", "code": "theorem zsmul_eq_mul' [Ring R] (a : R) (n : \u2124) : n \u2022 a = a * n", "start": [595, 1], "end": [596, 43], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocRing.int_smulCommClass", "code": "instance NonUnitalNonAssocRing.int_smulCommClass [NonUnitalNonAssocRing R] :\n    SMulCommClass \u2124 R R :=\n  \u27e8fun n x y =>\n    match n with\n    | (n : \u2115) => by simp_rw [coe_nat_zsmul, smul_comm]\n    | -[n+1] => by simp_rw [negSucc_zsmul, smul_eq_mul, mul_neg, mul_smul_comm]\u27e9", "start": [599, 1], "end": [605, 81], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocRing.int_isScalarTower", "code": "instance NonUnitalNonAssocRing.int_isScalarTower [NonUnitalNonAssocRing R] :\n    IsScalarTower \u2124 R R :=\n  \u27e8fun n x y =>\n    match n with\n    | (n : \u2115) => by simp_rw [coe_nat_zsmul, smul_assoc]\n    | -[n+1] => by simp_rw [negSucc_zsmul, smul_eq_mul, neg_mul, smul_mul_assoc]\u27e9", "start": [608, 1], "end": [614, 82], "kind": "commanddeclaration"}, {"full_name": "zsmul_int_int", "code": "theorem zsmul_int_int (a b : \u2124) : a \u2022 b = a * b", "start": [617, 1], "end": [617, 59], "kind": "commanddeclaration"}, {"full_name": "zsmul_int_one", "code": "theorem zsmul_int_one (n : \u2124) : n \u2022 (1 : \u2124) = n", "start": [620, 1], "end": [620, 59], "kind": "commanddeclaration"}, {"full_name": "Int.cast_pow", "code": "@[simp, norm_cast]\ntheorem Int.cast_pow [Ring R] (n : \u2124) (m : \u2115) : (\u2191(n ^ m) : R) = (\u2191n : R) ^ m", "start": [623, 1], "end": [627, 46], "kind": "commanddeclaration"}, {"full_name": "neg_one_pow_eq_pow_mod_two", "code": "theorem neg_one_pow_eq_pow_mod_two [Ring R] {n : \u2115} : (-1 : R) ^ n = (-1) ^ (n % 2)", "start": [631, 1], "end": [632, 58], "kind": "commanddeclaration"}, {"full_name": "one_add_mul_le_pow'", "code": "theorem one_add_mul_le_pow' (Hsq : 0 \u2264 a * a) (Hsq' : 0 \u2264 (1 + a) * (1 + a)) (H : 0 \u2264 2 + a) :\n    \u2200 n : \u2115, 1 + (n : R) * a \u2264 (1 + a) ^ n", "start": [639, 1], "end": [659, 66], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_of_le_one_aux", "code": "theorem pow_le_pow_of_le_one_aux (h : 0 \u2264 a) (ha : a \u2264 1) (i : \u2115) :\n    \u2200 k : \u2115, a ^ (i + k) \u2264 a ^ i", "start": [662, 1], "end": [667, 89], "kind": "commanddeclaration"}, {"full_name": "pow_le_pow_of_le_one", "code": "theorem pow_le_pow_of_le_one (h : 0 \u2264 a) (ha : a \u2264 1) {i j : \u2115} (hij : i \u2264 j) : a ^ j \u2264 a ^ i", "start": [670, 1], "end": [672, 51], "kind": "commanddeclaration"}, {"full_name": "pow_le_of_le_one", "code": "theorem pow_le_of_le_one (h\u2080 : 0 \u2264 a) (h\u2081 : a \u2264 1) {n : \u2115} (hn : n \u2260 0) : a ^ n \u2264 a", "start": [675, 1], "end": [676, 73], "kind": "commanddeclaration"}, {"full_name": "sq_le", "code": "theorem sq_le (h\u2080 : 0 \u2264 a) (h\u2081 : a \u2264 1) : a ^ 2 \u2264 a", "start": [679, 1], "end": [680, 37], "kind": "commanddeclaration"}, {"full_name": "sign_cases_of_C_mul_pow_nonneg", "code": "theorem sign_cases_of_C_mul_pow_nonneg {C r : R} (h : \u2200 n : \u2115, 0 \u2264 C * r ^ n) :\n    C = 0 \u2228 0 < C \u2227 0 \u2264 r", "start": [689, 1], "end": [694, 33], "kind": "commanddeclaration"}, {"full_name": "abs_pow", "code": "@[simp]\ntheorem abs_pow (a : R) (n : \u2115) : |a ^ n| = |a| ^ n", "start": [704, 1], "end": [706, 21], "kind": "commanddeclaration"}, {"full_name": "pow_bit1_neg_iff", "code": "@[simp]\ntheorem pow_bit1_neg_iff : a ^ bit1 n < 0 \u2194 a < 0", "start": [713, 1], "end": [715, 91], "kind": "commanddeclaration"}, {"full_name": "pow_bit1_nonneg_iff", "code": "@[simp]\ntheorem pow_bit1_nonneg_iff : 0 \u2264 a ^ bit1 n \u2194 0 \u2264 a", "start": [718, 1], "end": [720, 45], "kind": "commanddeclaration"}, {"full_name": "pow_bit1_nonpos_iff", "code": "@[simp]\ntheorem pow_bit1_nonpos_iff : a ^ bit1 n \u2264 0 \u2194 a \u2264 0", "start": [723, 1], "end": [736, 22], "kind": "commanddeclaration"}, {"full_name": "pow_bit1_pos_iff", "code": "@[simp]\ntheorem pow_bit1_pos_iff : 0 < a ^ bit1 n \u2194 0 < a", "start": [739, 1], "end": [741, 45], "kind": "commanddeclaration"}, {"full_name": "strictMono_pow_bit1", "code": "theorem strictMono_pow_bit1 (n : \u2115) : StrictMono fun a : R => a ^ bit1 n", "start": [744, 1], "end": [751, 62], "kind": "commanddeclaration"}, {"full_name": "one_add_mul_le_pow", "code": "theorem one_add_mul_le_pow (H : -2 \u2264 a) (n : \u2115) : 1 + (n : R) * a \u2264 (1 + a) ^ n", "start": [756, 1], "end": [758, 93], "kind": "commanddeclaration"}, {"full_name": "one_add_mul_sub_le_pow", "code": "theorem one_add_mul_sub_le_pow (H : -1 \u2264 a) (n : \u2115) : 1 + (n : R) * (a - 1) \u2264 a ^ n", "start": [761, 1], "end": [765, 69], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_sq", "code": "lemma natAbs_sq (x : \u2124) : (x.natAbs : \u2124) ^ 2 = x ^ 2 := by rw [sq, Int.natAbs_mul_self', sq]", "start": [772, 1], "end": [772, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Int.natAbs_pow_two", "code": "alias natAbs_pow_two := natAbs_sq", "start": [775, 1], "end": [775, 34], "kind": "stdtacticaliasalias"}, {"full_name": "Int.natAbs_le_self_sq", "code": "theorem natAbs_le_self_sq (a : \u2124) : (Int.natAbs a : \u2124) \u2264 a ^ 2", "start": [778, 1], "end": [781, 24], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_le_self_pow_two", "code": "alias natAbs_le_self_pow_two := natAbs_le_self_sq", "start": [784, 1], "end": [784, 50], "kind": "stdtacticaliasalias"}, {"full_name": "Int.le_self_sq", "code": "theorem le_self_sq (b : \u2124) : b \u2264 b ^ 2", "start": [786, 1], "end": [787, 43], "kind": "commanddeclaration"}, {"full_name": "Int.le_self_pow_two", "code": "alias le_self_pow_two := le_self_sq", "start": [790, 1], "end": [790, 36], "kind": "stdtacticaliasalias"}, {"full_name": "Int.pow_right_injective", "code": "theorem pow_right_injective {x : \u2124} (h : 1 < x.natAbs) :\n    Function.Injective ((\u00b7 ^ \u00b7) x : \u2115 \u2192 \u2124)", "start": [793, 1], "end": [798, 39], "kind": "commanddeclaration"}, {"full_name": "multiplesHom", "code": "def multiplesHom [AddMonoid A] : A \u2243 (\u2115 \u2192+ A) where\n  toFun : A \u2192 \u2115 \u2192+ A := fun x =>\n  { toFun := fun n => n \u2022 x\n    map_zero' := zero_nsmul x\n    map_add' := fun _ _ => add_nsmul _ _ _ }\n  invFun f := f 1\n  left_inv := one_nsmul\n  right_inv f := AddMonoidHom.ext_nat <| one_nsmul (f 1)", "start": [805, 1], "end": [813, 57], "kind": "commanddeclaration"}, {"full_name": "zmultiplesHom", "code": "def zmultiplesHom [AddGroup A] :\n    A \u2243 (\u2124 \u2192+ A) where\n  toFun x :=\n  { toFun := fun n => n \u2022 x\n    map_zero' := zero_zsmul x\n    map_add' := fun _ _ => add_zsmul _ _ _ }\n  invFun f := f 1\n  left_inv := one_zsmul\n  right_inv f := AddMonoidHom.ext_int <| one_zsmul (f 1)", "start": [816, 1], "end": [825, 57], "kind": "commanddeclaration"}, {"full_name": "powersHom", "code": "def powersHom [Monoid M] : M \u2243 (Multiplicative \u2115 \u2192* M) :=\n  Additive.ofMul.trans <| (multiplesHom _).trans <| AddMonoidHom.toMultiplicative''", "start": [828, 1], "end": [831, 84], "kind": "commanddeclaration"}, {"full_name": "zpowersHom", "code": "def zpowersHom [Group G] : G \u2243 (Multiplicative \u2124 \u2192* G) :=\n  Additive.ofMul.trans <| (zmultiplesHom _).trans <| AddMonoidHom.toMultiplicative''", "start": [834, 1], "end": [837, 85], "kind": "commanddeclaration"}, {"full_name": "powersHom_apply", "code": "theorem powersHom_apply [Monoid M] (x : M) (n : Multiplicative \u2115) :\n    powersHom M x n = x ^ (Multiplicative.toAdd n)", "start": [846, 1], "end": [848, 6], "kind": "commanddeclaration"}, {"full_name": "powersHom_symm_apply", "code": "theorem powersHom_symm_apply [Monoid M] (f : Multiplicative \u2115 \u2192* M) :\n    (powersHom M).symm f = f (Multiplicative.ofAdd 1)", "start": [851, 1], "end": [853, 6], "kind": "commanddeclaration"}, {"full_name": "zpowersHom_apply", "code": "theorem zpowersHom_apply [Group G] (x : G) (n : Multiplicative \u2124) :\n    zpowersHom G x n = x ^ (Multiplicative.toAdd n)", "start": [856, 1], "end": [858, 6], "kind": "commanddeclaration"}, {"full_name": "zpowersHom_symm_apply", "code": "theorem zpowersHom_symm_apply [Group G] (f : Multiplicative \u2124 \u2192* G) :\n    (zpowersHom G).symm f = f (Multiplicative.ofAdd 1)", "start": [861, 1], "end": [863, 6], "kind": "commanddeclaration"}, {"full_name": "multiplesHom_apply", "code": "theorem multiplesHom_apply [AddMonoid A] (x : A) (n : \u2115) : multiplesHom A x n = n \u2022 x", "start": [868, 1], "end": [869, 6], "kind": "commanddeclaration"}, {"full_name": "multiplesHom_symm_apply", "code": "theorem multiplesHom_symm_apply [AddMonoid A] (f : \u2115 \u2192+ A) : (multiplesHom A).symm f = f 1", "start": [874, 1], "end": [875, 6], "kind": "commanddeclaration"}, {"full_name": "zmultiplesHom_apply", "code": "theorem zmultiplesHom_apply [AddGroup A] (x : A) (n : \u2124) : zmultiplesHom A x n = n \u2022 x", "start": [880, 1], "end": [881, 6], "kind": "commanddeclaration"}, {"full_name": "zmultiplesHom_symm_apply", "code": "theorem zmultiplesHom_symm_apply [AddGroup A] (f : \u2124 \u2192+ A) : (zmultiplesHom A).symm f = f 1", "start": [886, 1], "end": [887, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.apply_mnat", "code": "theorem MonoidHom.apply_mnat [Monoid M] (f : Multiplicative \u2115 \u2192* M) (n : Multiplicative \u2115) :\n    f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)", "start": [893, 1], "end": [895, 73], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext_mnat", "code": "@[ext]\ntheorem MonoidHom.ext_mnat [Monoid M] \u2983f g : Multiplicative \u2115 \u2192* M\u2984\n    (h : f (Multiplicative.ofAdd 1) = g (Multiplicative.ofAdd 1)) : f = g", "start": [898, 1], "end": [901, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.apply_mint", "code": "theorem MonoidHom.apply_mint [Group M] (f : Multiplicative \u2124 \u2192* M) (n : Multiplicative \u2124) :\n    f n = f (Multiplicative.ofAdd 1) ^ (Multiplicative.toAdd n)", "start": [904, 1], "end": [906, 75], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.apply_nat", "code": "theorem AddMonoidHom.apply_nat [AddMonoid M] (f : \u2115 \u2192+ M) (n : \u2115) : f n = n \u2022 f 1", "start": [911, 1], "end": [912, 79], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.apply_int", "code": "theorem AddMonoidHom.apply_int [AddGroup M] (f : \u2124 \u2192+ M) (n : \u2124) : f n = n \u2022 f 1", "start": [917, 1], "end": [918, 81], "kind": "commanddeclaration"}, {"full_name": "powersMulHom", "code": "def powersMulHom [CommMonoid M] : M \u2243* (Multiplicative \u2115 \u2192* M) :=\n  { powersHom M with map_mul' := fun a b => MonoidHom.ext fun n => by simp [mul_pow] }", "start": [924, 1], "end": [926, 87], "kind": "commanddeclaration"}, {"full_name": "zpowersMulHom", "code": "def zpowersMulHom [CommGroup G] : G \u2243* (Multiplicative \u2124 \u2192* G) :=\n  { zpowersHom G with map_mul' := fun a b => MonoidHom.ext fun n => by simp [mul_zpow] }", "start": [929, 1], "end": [931, 89], "kind": "commanddeclaration"}, {"full_name": "multiplesAddHom", "code": "def multiplesAddHom [AddCommMonoid A] : A \u2243+ (\u2115 \u2192+ A) :=\n  { multiplesHom A with map_add' := fun a b => AddMonoidHom.ext fun n => by simp [nsmul_add] }", "start": [934, 1], "end": [936, 95], "kind": "commanddeclaration"}, {"full_name": "zmultiplesAddHom", "code": "def zmultiplesAddHom [AddCommGroup A] : A \u2243+ (\u2124 \u2192+ A) :=\n  { zmultiplesHom A with map_add' := fun a b => AddMonoidHom.ext fun n => by simp [zsmul_add] }", "start": [939, 1], "end": [941, 96], "kind": "commanddeclaration"}, {"full_name": "powersMulHom_apply", "code": "@[simp]\ntheorem powersMulHom_apply [CommMonoid M] (x : M) (n : Multiplicative \u2115) :\n    powersMulHom M x n = x ^ (Multiplicative.toAdd n)", "start": [946, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "powersMulHom_symm_apply", "code": "@[simp]\ntheorem powersMulHom_symm_apply [CommMonoid M] (f : Multiplicative \u2115 \u2192* M) :\n    (powersMulHom M).symm f = f (Multiplicative.ofAdd 1)", "start": [952, 1], "end": [955, 6], "kind": "commanddeclaration"}, {"full_name": "zpowersMulHom_apply", "code": "@[simp]\ntheorem zpowersMulHom_apply [CommGroup G] (x : G) (n : Multiplicative \u2124) :\n    zpowersMulHom G x n = x ^ (Multiplicative.toAdd n)", "start": [958, 1], "end": [961, 6], "kind": "commanddeclaration"}, {"full_name": "zpowersMulHom_symm_apply", "code": "@[simp]\ntheorem zpowersMulHom_symm_apply [CommGroup G] (f : Multiplicative \u2124 \u2192* G) :\n    (zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1)", "start": [964, 1], "end": [967, 6], "kind": "commanddeclaration"}, {"full_name": "multiplesAddHom_apply", "code": "@[simp]\ntheorem multiplesAddHom_apply [AddCommMonoid A] (x : A) (n : \u2115) : multiplesAddHom A x n = n \u2022 x", "start": [970, 1], "end": [972, 6], "kind": "commanddeclaration"}, {"full_name": "multiplesAddHom_symm_apply", "code": "@[simp]\ntheorem multiplesAddHom_symm_apply [AddCommMonoid A] (f : \u2115 \u2192+ A) :\n    (multiplesAddHom A).symm f = f 1", "start": [975, 1], "end": [978, 6], "kind": "commanddeclaration"}, {"full_name": "zmultiplesAddHom_apply", "code": "@[simp]\ntheorem zmultiplesAddHom_apply [AddCommGroup A] (x : A) (n : \u2124) :\n    zmultiplesAddHom A x n = n \u2022 x", "start": [981, 1], "end": [984, 6], "kind": "commanddeclaration"}, {"full_name": "zmultiplesAddHom_symm_apply", "code": "@[simp]\ntheorem zmultiplesAddHom_symm_apply [AddCommGroup A] (f : \u2124 \u2192+ A) :\n    (zmultiplesAddHom A).symm f = f 1", "start": [987, 1], "end": [990, 6], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_nat_mul_right", "code": "@[simp]\ntheorem cast_nat_mul_right (h : SemiconjBy a x y) (n : \u2115) : SemiconjBy a ((n : R) * x) (n * y)", "start": [1007, 1], "end": [1009, 48], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_nat_mul_left", "code": "@[simp]\ntheorem cast_nat_mul_left (h : SemiconjBy a x y) (n : \u2115) : SemiconjBy ((n : R) * a) x y", "start": [1012, 1], "end": [1014, 47], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_nat_mul_cast_nat_mul", "code": "@[simp]\ntheorem cast_nat_mul_cast_nat_mul (h : SemiconjBy a x y) (m n : \u2115) :\n    SemiconjBy ((m : R) * a) (n * x) (n * y)", "start": [1017, 1], "end": [1020, 47], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_zpow_right", "code": "@[to_additive (attr := simp)]\ntheorem units_zpow_right {a : M} {x y : M\u02e3} (h : SemiconjBy a x y) :\n    \u2200 m : \u2124, SemiconjBy a \u2191(x ^ m) \u2191(y ^ m)", "start": [1027, 1], "end": [1031, 99], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_int_mul_right", "code": "@[simp]\ntheorem cast_int_mul_right (h : SemiconjBy a x y) (m : \u2124) : SemiconjBy a ((m : \u2124) * x) (m * y)", "start": [1037, 1], "end": [1039, 48], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_int_mul_left", "code": "@[simp]\ntheorem cast_int_mul_left (h : SemiconjBy a x y) (m : \u2124) : SemiconjBy ((m : R) * a) x y", "start": [1042, 1], "end": [1044, 47], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.cast_int_mul_cast_int_mul", "code": "@[simp]\ntheorem cast_int_mul_cast_int_mul (h : SemiconjBy a x y) (m n : \u2124) :\n    SemiconjBy ((m : R) * a) (n * x) (n * y)", "start": [1047, 1], "end": [1050, 47], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_nat_mul_right", "code": "@[simp]\ntheorem cast_nat_mul_right (h : Commute a b) (n : \u2115) : Commute a ((n : R) * b)", "start": [1061, 1], "end": [1063, 36], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_nat_mul_left", "code": "@[simp]\ntheorem cast_nat_mul_left (h : Commute a b) (n : \u2115) : Commute ((n : R) * a) b", "start": [1066, 1], "end": [1068, 35], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_nat_mul_cast_nat_mul", "code": "@[simp]\ntheorem cast_nat_mul_cast_nat_mul (h : Commute a b)\n    (m n : \u2115) : Commute (m * a : R) (n * b : R)", "start": [1071, 1], "end": [1074, 45], "kind": "commanddeclaration"}, {"full_name": "Commute.self_cast_nat_mul", "code": "theorem self_cast_nat_mul : Commute a (n * a : R)", "start": [1084, 1], "end": [1085, 40], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_nat_mul_self", "code": "theorem cast_nat_mul_self : Commute ((n : R) * a) a", "start": [1093, 1], "end": [1094, 39], "kind": "commanddeclaration"}, {"full_name": "Commute.self_cast_nat_mul_cast_nat_mul", "code": "theorem self_cast_nat_mul_cast_nat_mul : Commute (m * a : R) (n * a : R)", "start": [1102, 1], "end": [1103, 49], "kind": "commanddeclaration"}, {"full_name": "Commute.units_zpow_right", "code": "@[to_additive (attr := simp)]\ntheorem units_zpow_right {a : M} {u : M\u02e3} (h : Commute a u)\n    (m : \u2124) : Commute a \u2191(u ^ m)", "start": [1110, 1], "end": [1113, 34], "kind": "commanddeclaration"}, {"full_name": "Commute.units_zpow_left", "code": "@[to_additive (attr := simp)]\ntheorem units_zpow_left {u : M\u02e3} {a : M} (h : Commute (\u2191u) a)\n    (m : \u2124) : Commute (\u2191(u ^ m)) a", "start": [1117, 1], "end": [1120, 35], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_mul_right", "code": "@[simp]\ntheorem cast_int_mul_right (h : Commute a b) (m : \u2124) : Commute a (m * b : R)", "start": [1126, 1], "end": [1128, 36], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_mul_left", "code": "@[simp]\ntheorem cast_int_mul_left (h : Commute a b) (m : \u2124) :\n    Commute ((m : R) * a) b", "start": [1131, 1], "end": [1134, 35], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_mul_cast_int_mul", "code": "theorem cast_int_mul_cast_int_mul (h : Commute a b)\n    (m n : \u2124) : Commute (m * a : R) (n * b : R)", "start": [1137, 1], "end": [1139, 45], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_left", "code": "@[simp]\ntheorem cast_int_left : Commute (m : R) a", "start": [1144, 1], "end": [1145, 66], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_right", "code": "@[simp]\ntheorem cast_int_right : Commute a m", "start": [1148, 1], "end": [1149, 61], "kind": "commanddeclaration"}, {"full_name": "Commute.self_cast_int_mul", "code": "theorem self_cast_int_mul : Commute a (n * a : R)", "start": [1157, 1], "end": [1158, 40], "kind": "commanddeclaration"}, {"full_name": "Commute.cast_int_mul_self", "code": "theorem cast_int_mul_self : Commute ((n : R) * a) a", "start": [1166, 1], "end": [1167, 39], "kind": "commanddeclaration"}, {"full_name": "Commute.self_cast_int_mul_cast_int_mul", "code": "theorem self_cast_int_mul_cast_int_mul : Commute (m * a : R) (n * a : R)", "start": [1170, 1], "end": [1171, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.toAdd_pow", "code": "@[simp]\ntheorem Nat.toAdd_pow (a : Multiplicative \u2115) (b : \u2115) : toAdd (a ^ b) = toAdd a * b", "start": [1180, 1], "end": [1182, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.ofAdd_mul", "code": "@[simp]\ntheorem Nat.ofAdd_mul (a b : \u2115) : ofAdd (a * b) = ofAdd a ^ b", "start": [1185, 1], "end": [1187, 27], "kind": "commanddeclaration"}, {"full_name": "Int.toAdd_pow", "code": "@[simp]\ntheorem Int.toAdd_pow (a : Multiplicative \u2124) (b : \u2115) : toAdd (a ^ b) = toAdd a * b", "start": [1190, 1], "end": [1192, 15], "kind": "commanddeclaration"}, {"full_name": "Int.toAdd_zpow", "code": "@[simp]\ntheorem Int.toAdd_zpow (a : Multiplicative \u2124) (b : \u2124) : toAdd (a ^ b) = toAdd a * b", "start": [1195, 1], "end": [1197, 15], "kind": "commanddeclaration"}, {"full_name": "Int.ofAdd_mul", "code": "@[simp]\ntheorem Int.ofAdd_mul (a b : \u2124) : ofAdd (a * b) = ofAdd a ^ b", "start": [1200, 1], "end": [1202, 28], "kind": "commanddeclaration"}, {"full_name": "Units.conj_pow", "code": "theorem conj_pow (u : M\u02e3) (x : M) (n : \u2115) :\n    ((\u2191u : M) * x * (\u2191u\u207b\u00b9 : M)) ^ n = (u : M) * x ^ n * (\u2191u\u207b\u00b9 : M)", "start": [1211, 1], "end": [1214, 50], "kind": "commanddeclaration"}, {"full_name": "Units.conj_pow'", "code": "theorem conj_pow' (u : M\u02e3) (x : M) (n : \u2115) :\n    ((\u2191u\u207b\u00b9 : M) * x * (u : M)) ^ n = (\u2191u\u207b\u00b9 : M) * x ^ n * (u : M)", "start": [1217, 1], "end": [1219, 19], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_pow", "code": "@[simp]\ntheorem op_pow [Monoid M] (x : M) (n : \u2115) : op (x ^ n) = op x ^ n", "start": [1226, 1], "end": [1229, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_pow", "code": "@[simp]\ntheorem unop_pow [Monoid M] (x : M\u1d50\u1d52\u1d56) (n : \u2115) : unop (x ^ n) = unop x ^ n", "start": [1232, 1], "end": [1234, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_zpow", "code": "@[simp]\ntheorem op_zpow [DivInvMonoid M] (x : M) (z : \u2124) : op (x ^ z) = op x ^ z", "start": [1237, 1], "end": [1240, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_zpow", "code": "@[simp]\ntheorem unop_zpow [DivInvMonoid M] (x : M\u1d50\u1d52\u1d56) (z : \u2124) : unop (x ^ z) = unop x ^ z", "start": [1243, 1], "end": [1245, 6], "kind": "commanddeclaration"}, {"full_name": "pow_eq", "code": "@[simp] theorem pow_eq {m : \u2124} {n : \u2115} : m.pow n = m ^ n", "start": [1252, 1], "end": [1252, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Inv.lean", "imports": ["Mathlib/Data/Rat/Cast/CharZero.lean", "Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Algebra/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfRing", "code": "def inferCharZeroOfRing {\u03b1 : Q(Type u)} (_i : Q(Ring $\u03b1) := by with_reducible assumption) :\n    MetaM Q(CharZero $\u03b1) :=\n  return \u2190 synthInstanceQ (q(CharZero $\u03b1) : Q(Prop)) <|>\n    throwError \"not a characteristic zero ring\"", "start": [20, 1], "end": [24, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfRing?", "code": "def inferCharZeroOfRing? {\u03b1 : Q(Type u)} (_i : Q(Ring $\u03b1) := by with_reducible assumption) :\n    MetaM (Option Q(CharZero $\u03b1)) :=\n  return (\u2190 trySynthInstanceQ (q(CharZero $\u03b1) : Q(Prop))).toOption", "start": [26, 1], "end": [29, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne", "code": "def inferCharZeroOfAddMonoidWithOne {\u03b1 : Q(Type u)}\n    (_i : Q(AddMonoidWithOne $\u03b1) := by with_reducible assumption) : MetaM Q(CharZero $\u03b1) :=\n  return \u2190 synthInstanceQ (q(CharZero $\u03b1) : Q(Prop)) <|>\n    throwError \"not a characteristic zero AddMonoidWithOne\"", "start": [31, 1], "end": [35, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfAddMonoidWithOne?", "code": "def inferCharZeroOfAddMonoidWithOne? {\u03b1 : Q(Type u)}\n    (_i : Q(AddMonoidWithOne $\u03b1) := by with_reducible assumption) :\n      MetaM (Option Q(CharZero $\u03b1)) :=\n  return (\u2190 trySynthInstanceQ (q(CharZero $\u03b1) : Q(Prop))).toOption", "start": [37, 1], "end": [42, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing", "code": "def inferCharZeroOfDivisionRing {\u03b1 : Q(Type u)}\n    (_i : Q(DivisionRing $\u03b1) := by with_reducible assumption) : MetaM Q(CharZero $\u03b1) :=\n  return \u2190 synthInstanceQ (q(CharZero $\u03b1) : Q(Prop)) <|>\n    throwError \"not a characteristic zero division ring\"", "start": [44, 1], "end": [48, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferCharZeroOfDivisionRing?", "code": "def inferCharZeroOfDivisionRing? {\u03b1 : Q(Type u)}\n    (_i : Q(DivisionRing $\u03b1) := by with_reducible assumption) : MetaM (Option Q(CharZero $\u03b1)) :=\n  return (\u2190 trySynthInstanceQ (q(CharZero $\u03b1) : Q(Prop))).toOption", "start": [50, 1], "end": [54, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_mkRat", "code": "theorem isRat_mkRat : {a na n : \u2124} \u2192 {b nb d : \u2115} \u2192 IsInt a na \u2192 IsNat b nb \u2192\n    IsRat (na / nb : \u211a) n d \u2192 IsRat (mkRat a b) n d", "start": [56, 1], "end": [58, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalMkRat", "code": "@[norm_num mkRat _ _]\ndef evalMkRat : NormNumExt where eval {u \u03b1} (e : Q(\u211a)) : MetaM (Result e) := do\n  let .app (.app (.const ``mkRat _) (a : Q(\u2124))) (b : Q(\u2115)) \u2190 whnfR e | failure\n  haveI' : $e =Q mkRat $a $b := \u27e8\u27e9\n  let ra \u2190 derive a\n  let some \u27e8_, na, pa\u27e9 := ra.toInt (q(Int.instRingInt) : Q(Ring Int)) | failure\n  let \u27e8nb, pb\u27e9 \u2190 deriveNat q($b) q(AddCommMonoidWithOne.toAddMonoidWithOne)\n  let rab \u2190 derive q($na / $nb : Rat)\n  let \u27e8q, n, d, p\u27e9 \u2190 rab.toRat' q(Rat.divisionRing)\n  return .isRat' _ q n d q(isRat_mkRat $pa $pb $p)", "start": [60, 1], "end": [71, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_ratCast", "code": "theorem isNat_ratCast [DivisionRing R] : {q : \u211a} \u2192 {n : \u2115} \u2192\n    IsNat q n \u2192 IsNat (q : R) n", "start": [73, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_ratCast", "code": "theorem isInt_ratCast [DivisionRing R] : {q : \u211a} \u2192 {n : \u2124} \u2192\n    IsInt q n \u2192 IsInt (q : R) n", "start": [77, 1], "end": [79, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_ratCast", "code": "theorem isRat_ratCast [DivisionRing R] [CharZero R] : {q : \u211a} \u2192 {n : \u2124} \u2192 {d : \u2115} \u2192\n    IsRat q n d \u2192 IsRat (q : R) n d", "start": [81, 1], "end": [83, 95], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalRatCast", "code": "@[norm_num Rat.cast _, RatCast.ratCast _] def evalRatCast : NormNumExt where eval {u \u03b1} e := do\n  let d\u03b1 \u2190 inferDivisionRing \u03b1\n  let .app r (a : Q(\u211a)) \u2190 whnfR e | failure\n  guard <|\u2190 withNewMCtxDepth <| isDefEq r q(Rat.cast (K := $\u03b1))\n  let r \u2190 derive q($a)\n  haveI' : $e =Q Rat.cast $a := \u27e8\u27e9\n  match r with\n  | .isNat _ na pa =>\n    assumeInstancesCommute\n    return .isNat _ na q(isNat_ratCast $pa)\n  | .isNegNat _ na pa =>\n    assumeInstancesCommute\n    return .isNegNat _ na q(isInt_ratCast $pa)\n  | .isRat _ qa na da pa =>\n    assumeInstancesCommute\n    let i \u2190 inferCharZeroOfDivisionRing d\u03b1\n    return .isRat d\u03b1 qa na da q(isRat_ratCast $pa)\n  | _ => failure", "start": [85, 1], "end": [104, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_inv_pos", "code": "theorem isRat_inv_pos {\u03b1} [DivisionRing \u03b1] [CharZero \u03b1] {a : \u03b1} {n d : \u2115} :\n    IsRat a (.ofNat (Nat.succ n)) d \u2192 IsRat a\u207b\u00b9 (.ofNat d) (Nat.succ n)", "start": [106, 1], "end": [110, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_inv_one", "code": "theorem isRat_inv_one {\u03b1} [DivisionRing \u03b1] : {a : \u03b1} \u2192\n    IsNat a (nat_lit 1) \u2192 IsNat a\u207b\u00b9 (nat_lit 1)", "start": [112, 1], "end": [114, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_inv_zero", "code": "theorem isRat_inv_zero {\u03b1} [DivisionRing \u03b1] : {a : \u03b1} \u2192\n    IsNat a (nat_lit 0) \u2192 IsNat a\u207b\u00b9 (nat_lit 0)", "start": [116, 1], "end": [118, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_inv_neg_one", "code": "theorem isRat_inv_neg_one {\u03b1} [DivisionRing \u03b1] : {a : \u03b1} \u2192\n    IsInt a (.negOfNat (nat_lit 1)) \u2192 IsInt a\u207b\u00b9 (.negOfNat (nat_lit 1))", "start": [120, 1], "end": [122, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_inv_neg", "code": "theorem isRat_inv_neg {\u03b1} [DivisionRing \u03b1] [CharZero \u03b1] {a : \u03b1} {n d : \u2115} :\n    IsRat a (.negOfNat (Nat.succ n)) d \u2192 IsRat a\u207b\u00b9 (.negOfNat d) (Nat.succ n)", "start": [124, 1], "end": [131, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalInv", "code": "@[norm_num _\u207b\u00b9] def evalInv : NormNumExt where eval {u \u03b1} e := do\n  let .app f (a : Q($\u03b1)) \u2190 whnfR e | failure\n  let ra \u2190 derive a\n  let d\u03b1 \u2190 inferDivisionRing \u03b1\n  let i \u2190 inferCharZeroOfDivisionRing? d\u03b1\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(Inv.inv (\u03b1 := $\u03b1))\n  haveI' : $e =Q $a\u207b\u00b9 := \u27e8\u27e9\n  assumeInstancesCommute\n  let rec\n  \n  core : Option (Result e) := do\n    let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1\n    let qb := qa\u207b\u00b9\n    if qa > 0 then\n      if let some i := i then\n        have lit : Q(\u2115) := na.appArg!\n        haveI : $na =Q Int.ofNat $lit := \u27e8\u27e9\n        have lit2 : Q(\u2115) := mkRawNatLit (lit.natLit! - 1)\n        haveI : $lit =Q ($lit2).succ := \u27e8\u27e9\n        return .isRat' d\u03b1 qb q(.ofNat $da) lit q(isRat_inv_pos $pa)\n      else\n        guard (qa = 1)\n        let .isNat inst n pa := ra | failure\n        haveI' : $n =Q nat_lit 1 := \u27e8\u27e9\n        assumeInstancesCommute\n        return .isNat inst n (q(isRat_inv_one $pa))\n    else if qa < 0 then\n      if let some i := i then\n        have lit : Q(\u2115) := na.appArg!\n        haveI : $na =Q Int.negOfNat $lit := \u27e8\u27e9\n        have lit2 : Q(\u2115) := mkRawNatLit (lit.natLit! - 1)\n        haveI : $lit =Q ($lit2).succ := \u27e8\u27e9\n        return .isRat' d\u03b1 qb q(.negOfNat $da) lit q(isRat_inv_neg $pa)\n      else\n        guard (qa = -1)\n        let .isNegNat inst n pa := ra | failure\n        haveI' : $n =Q nat_lit 1 := \u27e8\u27e9\n        assumeInstancesCommute\n        return .isNegNat inst n q(isRat_inv_neg_one $pa)\n    else\n      let .isNat inst n pa := ra | failure\n      haveI' : $n =Q nat_lit 0 := \u27e8\u27e9\n      assumeInstancesCommute\n      return .isNat inst n q(isRat_inv_zero $pa)\n  core", "start": [135, 1], "end": [181, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Traversable/Instances.lean", "imports": ["Mathlib/Data/List/Forall2.lean", "Mathlib/Control/Applicative.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Control/Traversable/Basic.lean", "Mathlib/Data/Set/Functor.lean"], "premises": [{"full_name": "Option.id_traverse", "code": "theorem Option.id_traverse {\u03b1} (x : Option \u03b1) : Option.traverse (pure : \u03b1 \u2192 Id \u03b1) x = x", "start": [33, 1], "end": [34, 18], "kind": "commanddeclaration"}, {"full_name": "Option.comp_traverse", "code": "theorem Option.comp_traverse {\u03b1 \u03b2 \u03b3} (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : Option \u03b1) :\n    Option.traverse (Comp.mk \u2218 (\u00b7 <$> \u00b7) f \u2218 g) x =\n      Comp.mk (Option.traverse f <$> Option.traverse g x)", "start": [37, 1], "end": [40, 46], "kind": "commanddeclaration"}, {"full_name": "Option.traverse_eq_map_id", "code": "theorem Option.traverse_eq_map_id {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : Option \u03b1) :\n    Option.traverse ((pure : _ \u2192 Id _) \u2218 f) x = (pure : _ \u2192 Id _) (f <$> x)", "start": [43, 1], "end": [44, 98], "kind": "commanddeclaration"}, {"full_name": "Option.naturality", "code": "theorem Option.naturality {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) (x : Option \u03b1) :\n    \u03b7 (Option.traverse f x) = Option.traverse (@\u03b7 _ \u2218 f) x", "start": [49, 1], "end": [53, 87], "kind": "commanddeclaration"}, {"full_name": "List.id_traverse", "code": "protected theorem id_traverse {\u03b1} (xs : List \u03b1) : List.traverse (pure : \u03b1 \u2192 Id \u03b1) xs = xs", "start": [77, 1], "end": [78, 63], "kind": "commanddeclaration"}, {"full_name": "List.comp_traverse", "code": "protected theorem comp_traverse {\u03b1 \u03b2 \u03b3} (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : List \u03b1) :\n    List.traverse (Comp.mk \u2218 (\u00b7 <$> \u00b7) f \u2218 g) x = Comp.mk (List.traverse f <$> List.traverse g x)", "start": [81, 1], "end": [83, 53], "kind": "commanddeclaration"}, {"full_name": "List.traverse_eq_map_id", "code": "protected theorem traverse_eq_map_id {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : List \u03b1) :\n    List.traverse ((pure : _ \u2192 Id _) \u2218 f) x = (pure : _ \u2192 Id _) (f <$> x)", "start": [86, 1], "end": [88, 47], "kind": "commanddeclaration"}, {"full_name": "List.naturality", "code": "protected theorem naturality {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) (x : List \u03b1) :\n    \u03b7 (List.traverse f x) = List.traverse (@\u03b7 _ \u2218 f) x", "start": [93, 1], "end": [97, 87], "kind": "commanddeclaration"}, {"full_name": "List.traverse_nil", "code": "@[simp]\ntheorem traverse_nil : traverse f ([] : List \u03b1') = (pure [] : F (List \u03b2'))", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "List.traverse_cons", "code": "@[simp]\ntheorem traverse_cons (a : \u03b1') (l : List \u03b1') :\n    traverse f (a :: l) = (\u00b7 :: \u00b7) <$> f a <*> traverse f l", "start": [118, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "List.traverse_append", "code": "@[simp]\ntheorem traverse_append :\n    \u2200 as bs : List \u03b1', traverse f (as ++ bs) = (\u00b7 ++ \u00b7) <$> traverse f as <*> traverse f bs", "start": [126, 1], "end": [130, 72], "kind": "commanddeclaration"}, {"full_name": "List.mem_traverse", "code": "theorem mem_traverse {f : \u03b1' \u2192 Set \u03b2'} :\n    \u2200 (l : List \u03b1') (n : List \u03b2'), n \u2208 traverse f l \u2194 Forall\u2082 (fun b a => b \u2208 f a) n l", "start": [133, 1], "end": [138, 53], "kind": "commanddeclaration"}, {"full_name": "Sum.traverse_map", "code": "protected theorem traverse_map {\u03b1 \u03b2 \u03b3 : Type u} (g : \u03b1 \u2192 \u03b2) (f : \u03b2 \u2192 G \u03b3) (x : \u03c3 \u2295 \u03b1) :\n    Sum.traverse f (g <$> x) = Sum.traverse (f \u2218 g) x", "start": [157, 1], "end": [159, 64], "kind": "commanddeclaration"}, {"full_name": "Sum.id_traverse", "code": "protected theorem id_traverse {\u03c3 \u03b1} (x : \u03c3 \u2295 \u03b1) :\n    Sum.traverse (pure : \u03b1 \u2192 Id \u03b1) x = x", "start": [164, 1], "end": [165, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.comp_traverse", "code": "protected theorem comp_traverse {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b2 \u2192 F \u03b3) (g : \u03b1 \u2192 G \u03b2) (x : \u03c3 \u2295 \u03b1) :\n    Sum.traverse (Comp.mk \u2218 (\u00b7 <$> \u00b7) f \u2218 g) x =\n    Comp.mk.{u} (Sum.traverse f <$> Sum.traverse g x)", "start": [168, 1], "end": [171, 65], "kind": "commanddeclaration"}, {"full_name": "Sum.traverse_eq_map_id", "code": "protected theorem traverse_eq_map_id {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : \u03c3 \u2295 \u03b1) :\n    Sum.traverse ((pure : _ \u2192 Id _) \u2218 f) x = (pure : _ \u2192 Id _) (f <$> x)", "start": [174, 1], "end": [176, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.map_traverse", "code": "protected theorem map_traverse {\u03b1 \u03b2 \u03b3} (g : \u03b1 \u2192 G \u03b2) (f : \u03b2 \u2192 \u03b3) (x : \u03c3 \u2295 \u03b1) :\n    (\u00b7 <$> \u00b7) f <$> Sum.traverse g x = Sum.traverse ((\u00b7 <$> \u00b7) f \u2218 g) x", "start": [179, 1], "end": [181, 66], "kind": "commanddeclaration"}, {"full_name": "Sum.naturality", "code": "protected theorem naturality {\u03b1 \u03b2} (f : \u03b1 \u2192 F \u03b2) (x : \u03c3 \u2295 \u03b1) :\n    \u03b7 (Sum.traverse f x) = Sum.traverse (@\u03b7 _ \u2218 f) x", "start": [186, 1], "end": [190, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Finite.lean", "imports": ["Mathlib/Data/Finite/Basic.lean", "Mathlib/Data/Set/Functor.lean", "Mathlib/Data/Finset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Finite", "code": "protected\ninductive Finite (s : Set \u03b1) : Prop\n  | intro : Fintype s \u2192 s.Finite", "start": [54, 1], "end": [62, 33], "kind": "commanddeclaration"}, {"full_name": "Set.finite_def", "code": "theorem finite_def {s : Set \u03b1} : s.Finite \u2194 Nonempty (Fintype s)", "start": [70, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nonempty_fintype", "code": "alias \u27e8Finite.nonempty_fintype, _\u27e9 := finite_def", "start": [74, 1], "end": [74, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.finite_coe_iff", "code": "theorem finite_coe_iff {s : Set \u03b1} : Finite s \u2194 s.Finite", "start": [77, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "Set.toFinite", "code": "theorem toFinite (s : Set \u03b1) [Finite s] : s.Finite", "start": [81, 1], "end": [83, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.ofFinset", "code": "protected theorem Finite.ofFinset {p : Set \u03b1} (s : Finset \u03b1) (H : \u2200 x, x \u2208 s \u2194 x \u2208 p) : p.Finite", "start": [86, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.to_subtype", "code": "protected theorem Finite.to_subtype {s : Set \u03b1} (h : s.Finite) : Finite s", "start": [91, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.fintype", "code": "protected noncomputable def Finite.fintype {s : Set \u03b1} (h : s.Finite) : Fintype s :=\n  h.nonempty_fintype.some", "start": [98, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset", "code": "protected noncomputable def Finite.toFinset {s : Set \u03b1} (h : s.Finite) : Finset \u03b1 :=\n  @Set.toFinset _ _ h.fintype", "start": [107, 1], "end": [109, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_eq_toFinset", "code": "theorem Finite.toFinset_eq_toFinset {s : Set \u03b1} [Fintype s] (h : s.Finite) :\n    h.toFinset = s.toFinset", "start": [112, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Set.toFinite_toFinset", "code": "@[simp]\ntheorem toFinite_toFinset (s : Set \u03b1) [Fintype s] : s.toFinite.toFinset = s.toFinset", "start": [120, 1], "end": [122, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_finset", "code": "theorem Finite.exists_finset {s : Set \u03b1} (h : s.Finite) :\n    \u2203 s' : Finset \u03b1, \u2200 a : \u03b1, a \u2208 s' \u2194 a \u2208 s", "start": [125, 1], "end": [128, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_finset_coe", "code": "theorem Finite.exists_finset_coe {s : Set \u03b1} (h : s.Finite) : \u2203 s' : Finset \u03b1, \u2191s' = s", "start": [131, 1], "end": [133, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite", "code": "protected def Infinite (s : Set \u03b1) : Prop :=\n  \u00acs.Finite", "start": [139, 1], "end": [143, 12], "kind": "commanddeclaration"}, {"full_name": "Set.not_infinite", "code": "@[simp]\ntheorem not_infinite {s : Set \u03b1} : \u00acs.Infinite \u2194 s.Finite", "start": [146, 1], "end": [148, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.not_infinite", "code": "alias \u27e8_, Finite.not_infinite\u27e9 := not_infinite", "start": [151, 1], "end": [151, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.finite_or_infinite", "code": "protected theorem finite_or_infinite (s : Set \u03b1) : s.Finite \u2228 s.Infinite", "start": [156, 1], "end": [158, 7], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_or_finite", "code": "protected theorem infinite_or_finite (s : Set \u03b1) : s.Infinite \u2228 s.Finite", "start": [161, 1], "end": [162, 8], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.mem_toFinset", "code": "@[simp]\nprotected theorem mem_toFinset (h : s.Finite) : a \u2208 h.toFinset \u2194 a \u2208 s", "start": [172, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.coe_toFinset", "code": "@[simp]\nprotected theorem coe_toFinset (h : s.Finite) : (h.toFinset : Set \u03b1) = s", "start": [177, 1], "end": [179, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_nonempty", "code": "@[simp]\nprotected theorem toFinset_nonempty (h : s.Finite) : h.toFinset.Nonempty \u2194 s.Nonempty", "start": [182, 1], "end": [184, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.coeSort_toFinset", "code": "theorem coeSort_toFinset (h : s.Finite) : \u21a5h.toFinset = \u21a5s", "start": [187, 1], "end": [189, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_inj", "code": "@[simp]\nprotected theorem toFinset_inj : hs.toFinset = ht.toFinset \u2194 s = t", "start": [192, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_subset", "code": "@[simp]\ntheorem toFinset_subset {t : Finset \u03b1} : hs.toFinset \u2286 t \u2194 s \u2286 t", "start": [197, 1], "end": [199, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_ssubset", "code": "@[simp]\ntheorem toFinset_ssubset {t : Finset \u03b1} : hs.toFinset \u2282 t \u2194 s \u2282 t", "start": [202, 1], "end": [204, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.subset_toFinset", "code": "@[simp]\ntheorem subset_toFinset {s : Finset \u03b1} : s \u2286 ht.toFinset \u2194 \u2191s \u2286 t", "start": [207, 1], "end": [209, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.ssubset_toFinset", "code": "@[simp]\ntheorem ssubset_toFinset {s : Finset \u03b1} : s \u2282 ht.toFinset \u2194 \u2191s \u2282 t", "start": [212, 1], "end": [214, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_subset_toFinset", "code": "@[mono]\nprotected theorem toFinset_subset_toFinset : hs.toFinset \u2286 ht.toFinset \u2194 s \u2286 t", "start": [217, 1], "end": [219, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_ssubset_toFinset", "code": "@[mono]\nprotected theorem toFinset_ssubset_toFinset : hs.toFinset \u2282 ht.toFinset \u2194 s \u2282 t", "start": [222, 1], "end": [224, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_mono", "code": "alias \u27e8_, toFinset_mono\u27e9 := Finite.toFinset_subset_toFinset", "start": [227, 1], "end": [227, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Finite.toFinset_strictMono", "code": "alias \u27e8_, toFinset_strictMono\u27e9 := Finite.toFinset_ssubset_toFinset", "start": [230, 1], "end": [230, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Finite.toFinset_setOf", "code": "@[simp high]\nprotected theorem toFinset_setOf [Fintype \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p]\n    (h : { x | p x }.Finite) : h.toFinset = Finset.univ.filter p", "start": [238, 1], "end": [243, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.disjoint_toFinset", "code": "@[simp]\nnonrec theorem disjoint_toFinset {hs : s.Finite} {ht : t.Finite} :\n    Disjoint hs.toFinset ht.toFinset \u2194 Disjoint s t", "start": [246, 1], "end": [249, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_inter", "code": "protected theorem toFinset_inter [DecidableEq \u03b1] (hs : s.Finite) (ht : t.Finite)\n    (h : (s \u2229 t).Finite) : h.toFinset = hs.toFinset \u2229 ht.toFinset", "start": [252, 1], "end": [255, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_union", "code": "protected theorem toFinset_union [DecidableEq \u03b1] (hs : s.Finite) (ht : t.Finite)\n    (h : (s \u222a t).Finite) : h.toFinset = hs.toFinset \u222a ht.toFinset", "start": [258, 1], "end": [261, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_diff", "code": "protected theorem toFinset_diff [DecidableEq \u03b1] (hs : s.Finite) (ht : t.Finite)\n    (h : (s \\ t).Finite) : h.toFinset = hs.toFinset \\ ht.toFinset", "start": [264, 1], "end": [267, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_symmDiff", "code": "protected theorem toFinset_symmDiff [DecidableEq \u03b1] (hs : s.Finite) (ht : t.Finite)\n    (h : (s \u2206 t).Finite) : h.toFinset = hs.toFinset \u2206 ht.toFinset", "start": [270, 1], "end": [273, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_compl", "code": "protected theorem toFinset_compl [DecidableEq \u03b1] [Fintype \u03b1] (hs : s.Finite) (h : s\u1d9c.Finite) :\n    h.toFinset = hs.toFinset\u1d9c", "start": [276, 1], "end": [279, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_empty", "code": "protected theorem toFinset_empty (h : (\u2205 : Set \u03b1).Finite) : h.toFinset = \u2205", "start": [283, 1], "end": [284, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_univ", "code": "protected theorem toFinset_univ [Fintype \u03b1] (h : (Set.univ : Set \u03b1).Finite) :\n    h.toFinset = Finset.univ", "start": [287, 1], "end": [289, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_eq_empty", "code": "@[simp]\nprotected theorem toFinset_eq_empty {h : s.Finite} : h.toFinset = \u2205 \u2194 s = \u2205", "start": [292, 1], "end": [294, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_eq_univ", "code": "@[simp]\nprotected theorem toFinset_eq_univ [Fintype \u03b1] {h : s.Finite} :\n    h.toFinset = Finset.univ \u2194 s = univ", "start": [297, 1], "end": [300, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_image", "code": "protected theorem toFinset_image [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (hs : s.Finite) (h : (f '' s).Finite) :\n    h.toFinset = hs.toFinset.image f", "start": [303, 1], "end": [306, 7], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_range", "code": "protected theorem toFinset_range [DecidableEq \u03b1] [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) (h : (range f).Finite) :\n    h.toFinset = Finset.univ.image f", "start": [311, 1], "end": [314, 7], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeUniv", "code": "instance fintypeUniv [Fintype \u03b1] : Fintype (@univ \u03b1) :=\n  Fintype.ofEquiv \u03b1 (Equiv.Set.univ \u03b1).symm", "start": [326, 1], "end": [327, 44], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeOfFiniteUniv", "code": "noncomputable def fintypeOfFiniteUniv (H : (univ (\u03b1 := \u03b1)).Finite) : Fintype \u03b1 :=\n  @Fintype.ofEquiv _ (univ : Set \u03b1) H.fintype (Equiv.Set.univ _)", "start": [330, 1], "end": [332, 65], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeUnion", "code": "instance fintypeUnion [DecidableEq \u03b1] (s t : Set \u03b1) [Fintype s] [Fintype t] :\n    Fintype (s \u222a t : Set \u03b1) :=\n  Fintype.ofFinset (s.toFinset \u222a t.toFinset) <| by simp", "start": [335, 1], "end": [337, 56], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeSep", "code": "instance fintypeSep (s : Set \u03b1) (p : \u03b1 \u2192 Prop) [Fintype s] [DecidablePred p] :\n    Fintype ({ a \u2208 s | p a } : Set \u03b1) :=\n  Fintype.ofFinset (s.toFinset.filter p) <| by simp", "start": [340, 1], "end": [342, 52], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInter", "code": "instance fintypeInter (s t : Set \u03b1) [DecidableEq \u03b1] [Fintype s] [Fintype t] :\n    Fintype (s \u2229 t : Set \u03b1) :=\n  Fintype.ofFinset (s.toFinset \u2229 t.toFinset) <| by simp", "start": [345, 1], "end": [347, 56], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInterOfLeft", "code": "instance fintypeInterOfLeft (s t : Set \u03b1) [Fintype s] [DecidablePred (\u00b7 \u2208 t)] :\n    Fintype (s \u2229 t : Set \u03b1) :=\n  Fintype.ofFinset (s.toFinset.filter (\u00b7 \u2208 t)) <| by simp", "start": [350, 1], "end": [353, 58], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInterOfRight", "code": "instance fintypeInterOfRight (s t : Set \u03b1) [Fintype t] [DecidablePred (\u00b7 \u2208 s)] :\n    Fintype (s \u2229 t : Set \u03b1) :=\n  Fintype.ofFinset (t.toFinset.filter (\u00b7 \u2208 s)) <| by simp [and_comm]", "start": [356, 1], "end": [359, 69], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeSubset", "code": "def fintypeSubset (s : Set \u03b1) {t : Set \u03b1} [Fintype s] [DecidablePred (\u00b7 \u2208 t)] (h : t \u2286 s) :\n    Fintype t := by\n  rw [\u2190 inter_eq_self_of_subset_right h]\n  apply Set.fintypeInterOfLeft", "start": [362, 1], "end": [366, 31], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeDiff", "code": "instance fintypeDiff [DecidableEq \u03b1] (s t : Set \u03b1) [Fintype s] [Fintype t] :\n    Fintype (s \\ t : Set \u03b1) :=\n  Fintype.ofFinset (s.toFinset \\ t.toFinset) <| by simp", "start": [369, 1], "end": [371, 56], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeDiffLeft", "code": "instance fintypeDiffLeft (s t : Set \u03b1) [Fintype s] [DecidablePred (\u00b7 \u2208 t)] :\n    Fintype (s \\ t : Set \u03b1) :=\n  Set.fintypeSep s (\u00b7 \u2208 t\u1d9c)", "start": [374, 1], "end": [376, 28], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeiUnion", "code": "instance fintypeiUnion [DecidableEq \u03b1] [Fintype (PLift \u03b9)] (f : \u03b9 \u2192 Set \u03b1) [\u2200 i, Fintype (f i)] :\n    Fintype (\u22c3 i, f i) :=\n  Fintype.ofFinset (Finset.univ.biUnion fun i : PLift \u03b9 => (f i.down).toFinset) <| by simp", "start": [379, 1], "end": [381, 91], "kind": "commanddeclaration"}, {"full_name": "Set.fintypesUnion", "code": "instance fintypesUnion [DecidableEq \u03b1] {s : Set (Set \u03b1)} [Fintype s]\n    [H : \u2200 t : s, Fintype (t : Set \u03b1)] : Fintype (\u22c3\u2080 s) := by\n  rw [sUnion_eq_iUnion]\n  exact @Set.fintypeiUnion _ _ _ _ _ H", "start": [384, 1], "end": [387, 39], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeBiUnion", "code": "def fintypeBiUnion [DecidableEq \u03b1] {\u03b9 : Type*} (s : Set \u03b9) [Fintype s] (t : \u03b9 \u2192 Set \u03b1)\n    (H : \u2200 i \u2208 s, Fintype (t i)) : Fintype (\u22c3 x \u2208 s, t x) :=\n  haveI : \u2200 i : toFinset s, Fintype (t i) := fun i => H i (mem_toFinset.1 i.2)\n  Fintype.ofFinset (s.toFinset.attach.biUnion fun x => (t x).toFinset) fun x => by simp", "start": [390, 1], "end": [395, 88], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeBiUnion'", "code": "instance fintypeBiUnion' [DecidableEq \u03b1] {\u03b9 : Type*} (s : Set \u03b9) [Fintype s] (t : \u03b9 \u2192 Set \u03b1)\n    [\u2200 i, Fintype (t i)] : Fintype (\u22c3 x \u2208 s, t x) :=\n  Fintype.ofFinset (s.toFinset.biUnion fun x => (t x).toFinset) <| by simp", "start": [398, 1], "end": [400, 75], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeBind", "code": "def fintypeBind {\u03b1 \u03b2} [DecidableEq \u03b2] (s : Set \u03b1) [Fintype s] (f : \u03b1 \u2192 Set \u03b2)\n    (H : \u2200 a \u2208 s, Fintype (f a)) : Fintype (s >>= f) :=\n  Set.fintypeBiUnion s f H", "start": [403, 1], "end": [407, 27], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeBind'", "code": "instance fintypeBind' {\u03b1 \u03b2} [DecidableEq \u03b2] (s : Set \u03b1) [Fintype s] (f : \u03b1 \u2192 Set \u03b2)\n    [\u2200 a, Fintype (f a)] : Fintype (s >>= f) :=\n  Set.fintypeBiUnion' s f", "start": [410, 1], "end": [412, 26], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeEmpty", "code": "instance fintypeEmpty : Fintype (\u2205 : Set \u03b1) :=\n  Fintype.ofFinset \u2205 <| by simp", "start": [415, 1], "end": [416, 32], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeSingleton", "code": "instance fintypeSingleton (a : \u03b1) : Fintype ({a} : Set \u03b1) :=\n  Fintype.ofFinset {a} <| by simp", "start": [419, 1], "end": [420, 34], "kind": "commanddeclaration"}, {"full_name": "Set.fintypePure", "code": "instance fintypePure : \u2200 a : \u03b1, Fintype (pure a : Set \u03b1) :=\n  Set.fintypeSingleton", "start": [423, 1], "end": [424, 23], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInsert", "code": "instance fintypeInsert (a : \u03b1) (s : Set \u03b1) [DecidableEq \u03b1] [Fintype s] :\n    Fintype (insert a s : Set \u03b1) :=\n  Fintype.ofFinset (insert a s.toFinset) <| by simp", "start": [427, 1], "end": [432, 52], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInsertOfNotMem", "code": "def fintypeInsertOfNotMem {a : \u03b1} (s : Set \u03b1) [Fintype s] (h : a \u2209 s) :\n    Fintype (insert a s : Set \u03b1) :=\n  Fintype.ofFinset \u27e8a ::\u2098 s.toFinset.1, s.toFinset.nodup.cons (by simp [h])\u27e9 <| by simp", "start": [435, 1], "end": [438, 88], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInsertOfMem", "code": "def fintypeInsertOfMem {a : \u03b1} (s : Set \u03b1) [Fintype s] (h : a \u2208 s) : Fintype (insert a s : Set \u03b1) :=\n  Fintype.ofFinset s.toFinset <| by simp [h]", "start": [441, 1], "end": [443, 45], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeInsert'", "code": "instance (priority := 100) fintypeInsert' (a : \u03b1) (s : Set \u03b1) [Decidable <| a \u2208 s] [Fintype s] :\n    Fintype (insert a s : Set \u03b1) :=\n  if h : a \u2208 s then fintypeInsertOfMem s h else fintypeInsertOfNotMem s h", "start": [446, 1], "end": [456, 74], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeImage", "code": "instance fintypeImage [DecidableEq \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) [Fintype s] : Fintype (f '' s) :=\n  Fintype.ofFinset (s.toFinset.image f) <| by simp", "start": [459, 1], "end": [460, 51], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeOfFintypeImage", "code": "def fintypeOfFintypeImage (s : Set \u03b1) {f : \u03b1 \u2192 \u03b2} {g} (I : IsPartialInv f g) [Fintype (f '' s)] :\n    Fintype s :=\n  Fintype.ofFinset \u27e8_, (f '' s).toFinset.2.filterMap g <| injective_of_isPartialInv_right I\u27e9\n    fun a => by\n    suffices (\u2203 b x, f x = b \u2227 g b = some a \u2227 x \u2208 s) \u2194 a \u2208 s by\n      simpa [exists_and_left.symm, and_comm, and_left_comm, and_assoc]\n    rw [exists_swap]\n    suffices (\u2203 x, x \u2208 s \u2227 g (f x) = some a) \u2194 a \u2208 s by simpa [and_comm, and_left_comm, and_assoc]\n    simp [I _, (injective_of_isPartialInv I).eq_iff]", "start": [463, 1], "end": [473, 53], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeRange", "code": "instance fintypeRange [DecidableEq \u03b1] (f : \u03b9 \u2192 \u03b1) [Fintype (PLift \u03b9)] : Fintype (range f) :=\n  Fintype.ofFinset (Finset.univ.image <| f \u2218 PLift.down) <| by simp [Equiv.plift.exists_congr_left]", "start": [476, 1], "end": [477, 100], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeMap", "code": "instance fintypeMap {\u03b1 \u03b2} [DecidableEq \u03b2] :\n    \u2200 (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) [Fintype s], Fintype (f <$> s) :=\n  Set.fintypeImage", "start": [480, 1], "end": [482, 19], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeLTNat", "code": "instance fintypeLTNat (n : \u2115) : Fintype { i | i < n } :=\n  Fintype.ofFinset (Finset.range n) <| by simp", "start": [485, 1], "end": [486, 47], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeLENat", "code": "instance fintypeLENat (n : \u2115) : Fintype { i | i \u2264 n } := by\n  simpa [Nat.lt_succ_iff] using Set.fintypeLTNat (n + 1)", "start": [489, 1], "end": [490, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Nat.fintypeIio", "code": "def Nat.fintypeIio (n : \u2115) : Fintype (Iio n) :=\n  Set.fintypeLTNat n", "start": [493, 1], "end": [496, 21], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeProd", "code": "instance fintypeProd (s : Set \u03b1) (t : Set \u03b2) [Fintype s] [Fintype t] :\n    Fintype (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)) :=\n  Fintype.ofFinset (s.toFinset \u00d7\u02e2 t.toFinset) <| by simp", "start": [499, 1], "end": [501, 57], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeOffDiag", "code": "instance fintypeOffDiag [DecidableEq \u03b1] (s : Set \u03b1) [Fintype s] : Fintype s.offDiag :=\n  Fintype.ofFinset s.toFinset.offDiag <| by simp", "start": [504, 1], "end": [505, 49], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeImage2", "code": "instance fintypeImage2 [DecidableEq \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) [hs : Fintype s]\n    [ht : Fintype t] : Fintype (image2 f s t : Set \u03b3) := by\n  rw [\u2190 image_prod]\n  apply Set.fintypeImage", "start": [508, 1], "end": [512, 25], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeSeq", "code": "instance fintypeSeq [DecidableEq \u03b2] (f : Set (\u03b1 \u2192 \u03b2)) (s : Set \u03b1) [Fintype f] [Fintype s] :\n    Fintype (f.seq s) := by\n  rw [seq_def]\n  apply Set.fintypeBiUnion'", "start": [515, 1], "end": [518, 28], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeSeq'", "code": "instance fintypeSeq' {\u03b1 \u03b2 : Type u} [DecidableEq \u03b2] (f : Set (\u03b1 \u2192 \u03b2)) (s : Set \u03b1) [Fintype f]\n    [Fintype s] : Fintype (f <*> s) :=\n  Set.fintypeSeq f s", "start": [521, 1], "end": [523, 21], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeMemFinset", "code": "instance fintypeMemFinset (s : Finset \u03b1) : Fintype { a | a \u2208 s } :=\n  Finset.fintypeCoeSort s", "start": [526, 1], "end": [527, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.set_finite_iff", "code": "theorem Equiv.set_finite_iff {s : Set \u03b1} {t : Set \u03b2} (hst : s \u2243 t) : s.Finite \u2194 t.Finite", "start": [534, 1], "end": [535, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.finite_toSet", "code": "@[simp]\ntheorem finite_toSet (s : Finset \u03b1) : (s : Set \u03b1).Finite", "start": [542, 1], "end": [546, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.finite_toSet_toFinset", "code": "theorem finite_toSet_toFinset (s : Finset \u03b1) : s.finite_toSet.toFinset = s", "start": [550, 1], "end": [551, 39], "kind": "commanddeclaration"}, {"full_name": "Multiset.finite_toSet", "code": "@[simp]\ntheorem finite_toSet (s : Multiset \u03b1) : { x | x \u2208 s }.Finite", "start": [558, 1], "end": [560, 79], "kind": "commanddeclaration"}, {"full_name": "Multiset.finite_toSet_toFinset", "code": "@[simp]\ntheorem finite_toSet_toFinset [DecidableEq \u03b1] (s : Multiset \u03b1) :\n    s.finite_toSet.toFinset = s.toFinset", "start": [563, 1], "end": [567, 7], "kind": "commanddeclaration"}, {"full_name": "List.finite_toSet", "code": "@[simp]\ntheorem List.finite_toSet (l : List \u03b1) : { x | x \u2208 l }.Finite", "start": [572, 1], "end": [574, 42], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_union", "code": "instance finite_union (s t : Set \u03b1) [Finite s] [Finite t] : Finite (s \u222a t : Set \u03b1) := by\n  cases nonempty_fintype s\n  cases nonempty_fintype t\n  infer_instance", "start": [602, 1], "end": [605, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_sep", "code": "instance finite_sep (s : Set \u03b1) (p : \u03b1 \u2192 Prop) [Finite s] : Finite ({ a \u2208 s | p a } : Set \u03b1) := by\n  cases nonempty_fintype s\n  infer_instance", "start": [608, 1], "end": [610, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.subset", "code": "protected theorem subset (s : Set \u03b1) {t : Set \u03b1} [Finite s] (h : t \u2286 s) : Finite t", "start": [613, 1], "end": [615, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_inter_of_right", "code": "instance finite_inter_of_right (s t : Set \u03b1) [Finite t] : Finite (s \u2229 t : Set \u03b1) :=\n  Finite.Set.subset t (inter_subset_right s t)", "start": [618, 1], "end": [619, 47], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_inter_of_left", "code": "instance finite_inter_of_left (s t : Set \u03b1) [Finite s] : Finite (s \u2229 t : Set \u03b1) :=\n  Finite.Set.subset s (inter_subset_left s t)", "start": [622, 1], "end": [623, 46], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_diff", "code": "instance finite_diff (s t : Set \u03b1) [Finite s] : Finite (s \\ t : Set \u03b1) :=\n  Finite.Set.subset s (diff_subset s t)", "start": [626, 1], "end": [627, 40], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_range", "code": "instance finite_range (f : \u03b9 \u2192 \u03b1) [Finite \u03b9] : Finite (range f) := by\n  haveI := Fintype.ofFinite (PLift \u03b9)\n  infer_instance", "start": [630, 1], "end": [632, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_iUnion", "code": "instance finite_iUnion [Finite \u03b9] (f : \u03b9 \u2192 Set \u03b1) [\u2200 i, Finite (f i)] : Finite (\u22c3 i, f i) := by\n  rw [iUnion_eq_range_psigma]\n  apply Set.finite_range", "start": [635, 1], "end": [637, 25], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_sUnion", "code": "instance finite_sUnion {s : Set (Set \u03b1)} [Finite s] [H : \u2200 t : s, Finite (t : Set \u03b1)] :\n    Finite (\u22c3\u2080 s) := by\n  rw [sUnion_eq_iUnion]\n  exact @Finite.Set.finite_iUnion _ _ _ _ H", "start": [640, 1], "end": [643, 44], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_biUnion", "code": "theorem finite_biUnion {\u03b9 : Type*} (s : Set \u03b9) [Finite s] (t : \u03b9 \u2192 Set \u03b1)\n    (H : \u2200 i \u2208 s, Finite (t i)) : Finite (\u22c3 x \u2208 s, t x)", "start": [646, 1], "end": [650, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_biUnion'", "code": "instance finite_biUnion' {\u03b9 : Type*} (s : Set \u03b9) [Finite s] (t : \u03b9 \u2192 Set \u03b1) [\u2200 i, Finite (t i)] :\n    Finite (\u22c3 x \u2208 s, t x) :=\n  finite_biUnion s t fun _ _ => inferInstance", "start": [653, 1], "end": [655, 46], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_biUnion''", "code": "instance finite_biUnion'' {\u03b9 : Type*} (p : \u03b9 \u2192 Prop) [h : Finite { x | p x }] (t : \u03b9 \u2192 Set \u03b1)\n    [\u2200 i, Finite (t i)] : Finite (\u22c3 (x) (_ : p x), t x) :=\n  @Finite.Set.finite_biUnion' _ _ (setOf p) h t _", "start": [658, 1], "end": [663, 50], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_iInter", "code": "instance finite_iInter {\u03b9 : Sort*} [Nonempty \u03b9] (t : \u03b9 \u2192 Set \u03b1) [\u2200 i, Finite (t i)] :\n    Finite (\u22c2 i, t i) :=\n  Finite.Set.subset (t <| Classical.arbitrary \u03b9) (iInter_subset _ _)", "start": [666, 1], "end": [668, 69], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_insert", "code": "instance finite_insert (a : \u03b1) (s : Set \u03b1) [Finite s] : Finite (insert a s : Set \u03b1) :=\n  Finite.Set.finite_union {a} s", "start": [671, 1], "end": [672, 32], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_image", "code": "instance finite_image (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) [Finite s] : Finite (f '' s) := by\n  cases nonempty_fintype s\n  infer_instance", "start": [675, 1], "end": [677, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_replacement", "code": "instance finite_replacement [Finite \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    Finite {f x | x : \u03b1} :=\n  Finite.Set.finite_range f", "start": [680, 1], "end": [682, 28], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_prod", "code": "instance finite_prod (s : Set \u03b1) (t : Set \u03b2) [Finite s] [Finite t] :\n    Finite (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)) :=\n  Finite.of_equiv _ (Equiv.Set.prod s t).symm", "start": [685, 1], "end": [687, 46], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_image2", "code": "instance finite_image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) [Finite s] [Finite t] :\n    Finite (image2 f s t : Set \u03b3) := by\n  rw [\u2190 image_prod]\n  infer_instance", "start": [690, 1], "end": [693, 17], "kind": "commanddeclaration"}, {"full_name": "Finite.Set.finite_seq", "code": "instance finite_seq (f : Set (\u03b1 \u2192 \u03b2)) (s : Set \u03b1) [Finite f] [Finite s] : Finite (f.seq s) := by\n  rw [seq_def]\n  infer_instance", "start": [696, 1], "end": [698, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_subsingleton", "code": "@[nontriviality]\ntheorem Finite.of_subsingleton [Subsingleton \u03b1] (s : Set \u03b1) : s.Finite", "start": [717, 1], "end": [719, 13], "kind": "commanddeclaration"}, {"full_name": "Set.finite_univ", "code": "theorem finite_univ [Finite \u03b1] : (@univ \u03b1).Finite", "start": [722, 1], "end": [723, 17], "kind": "commanddeclaration"}, {"full_name": "Set.finite_univ_iff", "code": "theorem finite_univ_iff : (@univ \u03b1).Finite \u2194 Finite \u03b1", "start": [726, 1], "end": [727, 58], "kind": "commanddeclaration"}, {"full_name": "Finite.of_finite_univ", "code": "alias \u27e8_root_.Finite.of_finite_univ, _\u27e9 := finite_univ_iff", "start": [730, 1], "end": [730, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Finite.union", "code": "theorem Finite.union {s t : Set \u03b1} (hs : s.Finite) (ht : t.Finite) : (s \u222a t).Finite", "start": [733, 1], "end": [736, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.finite_of_compl", "code": "theorem Finite.finite_of_compl {s : Set \u03b1} (hs : s.Finite) (hsc : s\u1d9c.Finite) : Finite \u03b1", "start": [739, 1], "end": [741, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.sup", "code": "theorem Finite.sup {s t : Set \u03b1} : s.Finite \u2192 t.Finite \u2192 (s \u2294 t).Finite", "start": [744, 1], "end": [745, 15], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.sep", "code": "theorem Finite.sep {s : Set \u03b1} (hs : s.Finite) (p : \u03b1 \u2192 Prop) : { a \u2208 s | p a }.Finite", "start": [748, 1], "end": [750, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inter_of_left", "code": "theorem Finite.inter_of_left {s : Set \u03b1} (hs : s.Finite) (t : Set \u03b1) : (s \u2229 t).Finite", "start": [753, 1], "end": [755, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inter_of_right", "code": "theorem Finite.inter_of_right {s : Set \u03b1} (hs : s.Finite) (t : Set \u03b1) : (t \u2229 s).Finite", "start": [758, 1], "end": [760, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inf_of_left", "code": "theorem Finite.inf_of_left {s : Set \u03b1} (h : s.Finite) (t : Set \u03b1) : (s \u2293 t).Finite", "start": [763, 1], "end": [764, 20], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inf_of_right", "code": "theorem Finite.inf_of_right {s : Set \u03b1} (h : s.Finite) (t : Set \u03b1) : (t \u2293 s).Finite", "start": [767, 1], "end": [768, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.subset", "code": "theorem Finite.subset {s : Set \u03b1} (hs : s.Finite) {t : Set \u03b1} (ht : t \u2286 s) : t.Finite", "start": [771, 1], "end": [774, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.diff", "code": "theorem Finite.diff {s : Set \u03b1} (hs : s.Finite) (t : Set \u03b1) : (s \\ t).Finite", "start": [777, 1], "end": [779, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_diff", "code": "theorem Finite.of_diff {s t : Set \u03b1} (hd : (s \\ t).Finite) (ht : t.Finite) : s.Finite", "start": [782, 1], "end": [783, 48], "kind": "commanddeclaration"}, {"full_name": "Set.finite_iUnion", "code": "theorem finite_iUnion [Finite \u03b9] {f : \u03b9 \u2192 Set \u03b1} (H : \u2200 i, (f i).Finite) : (\u22c3 i, f i).Finite", "start": [786, 1], "end": [788, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.sUnion", "code": "theorem Finite.sUnion {s : Set (Set \u03b1)} (hs : s.Finite) (H : \u2200 t \u2208 s, Set.Finite t) :\n    (\u22c3\u2080 s).Finite", "start": [791, 1], "end": [795, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.biUnion", "code": "theorem Finite.biUnion {\u03b9} {s : Set \u03b9} (hs : s.Finite) {t : \u03b9 \u2192 Set \u03b1}\n    (ht : \u2200 i \u2208 s, (t i).Finite) : (\u22c3 i \u2208 s, t i).Finite", "start": [798, 1], "end": [803, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.biUnion'", "code": "theorem Finite.biUnion' {\u03b9} {s : Set \u03b9} (hs : s.Finite) {t : \u2200 i \u2208 s, Set \u03b1}\n    (ht : \u2200 i (hi : i \u2208 s), (t i hi).Finite) : (\u22c3 i \u2208 s, t i \u2039_\u203a).Finite", "start": [806, 1], "end": [811, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.sInter", "code": "theorem Finite.sInter {\u03b1 : Type*} {s : Set (Set \u03b1)} {t : Set \u03b1} (ht : t \u2208 s) (hf : t.Finite) :\n    (\u22c2\u2080 s).Finite", "start": [814, 1], "end": [816, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.iUnion", "code": "theorem Finite.iUnion {\u03b9 : Type*} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b9} (ht : t.Finite)\n    (hs : \u2200 i \u2208 t, (s i).Finite) (he : \u2200 i, i \u2209 t \u2192 s i = \u2205) : (\u22c3 i, s i).Finite", "start": [819, 1], "end": [828, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.bind", "code": "theorem Finite.bind {\u03b1 \u03b2} {s : Set \u03b1} {f : \u03b1 \u2192 Set \u03b2} (h : s.Finite) (hf : \u2200 a \u2208 s, (f a).Finite) :\n    (s >>= f).Finite", "start": [831, 1], "end": [833, 15], "kind": "commanddeclaration"}, {"full_name": "Set.finite_empty", "code": "@[simp]\ntheorem finite_empty : (\u2205 : Set \u03b1).Finite", "start": [836, 1], "end": [838, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.nonempty", "code": "protected theorem Infinite.nonempty {s : Set \u03b1} (h : s.Infinite) : s.Nonempty", "start": [841, 1], "end": [844, 25], "kind": "commanddeclaration"}, {"full_name": "Set.finite_singleton", "code": "@[simp]\ntheorem finite_singleton (a : \u03b1) : ({a} : Set \u03b1).Finite", "start": [847, 1], "end": [849, 13], "kind": "commanddeclaration"}, {"full_name": "Set.finite_pure", "code": "theorem finite_pure (a : \u03b1) : (pure a : Set \u03b1).Finite", "start": [852, 1], "end": [853, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.insert", "code": "@[simp]\nprotected theorem Finite.insert (a : \u03b1) {s : Set \u03b1} (hs : s.Finite) : (insert a s).Finite", "start": [856, 1], "end": [859, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.image", "code": "theorem Finite.image {s : Set \u03b1} (f : \u03b1 \u2192 \u03b2) (hs : s.Finite) : (f '' s).Finite", "start": [862, 1], "end": [864, 17], "kind": "commanddeclaration"}, {"full_name": "Set.finite_range", "code": "theorem finite_range (f : \u03b9 \u2192 \u03b1) [Finite \u03b9] : (range f).Finite", "start": [867, 1], "end": [868, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.dependent_image", "code": "theorem Finite.dependent_image {s : Set \u03b1} (hs : s.Finite) (F : \u2200 i \u2208 s, \u03b2) :\n    { y : \u03b2 | \u2203 (x : _) (hx : x \u2208 s), y = F x hx }.Finite", "start": [871, 1], "end": [874, 65], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.map", "code": "theorem Finite.map {\u03b1 \u03b2} {s : Set \u03b1} : \u2200 f : \u03b1 \u2192 \u03b2, s.Finite \u2192 (f <$> s).Finite", "start": [877, 1], "end": [878, 15], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_finite_image", "code": "theorem Finite.of_finite_image {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (h : (f '' s).Finite) (hi : Set.InjOn f s) :\n    s.Finite", "start": [881, 1], "end": [886, 62], "kind": "commanddeclaration"}, {"full_name": "Set.finite_of_finite_preimage", "code": "theorem finite_of_finite_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : (f \u207b\u00b9' s).Finite)\n    (hs : s \u2286 range f) : s.Finite", "start": [889, 1], "end": [892, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_preimage", "code": "theorem Finite.of_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : (f \u207b\u00b9' s).Finite) (hf : Surjective f) :\n    s.Finite", "start": [895, 1], "end": [897, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.preimage", "code": "theorem Finite.preimage {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (I : Set.InjOn f (f \u207b\u00b9' s)) (h : s.Finite) :\n    (f \u207b\u00b9' s).Finite", "start": [900, 1], "end": [902, 59], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.preimage_embedding", "code": "theorem Finite.preimage_embedding {s : Set \u03b2} (f : \u03b1 \u21aa \u03b2) (h : s.Finite) : (f \u207b\u00b9' s).Finite", "start": [905, 1], "end": [906, 46], "kind": "commanddeclaration"}, {"full_name": "Set.finite_lt_nat", "code": "theorem finite_lt_nat (n : \u2115) : Set.Finite { i | i < n }", "start": [909, 1], "end": [910, 13], "kind": "commanddeclaration"}, {"full_name": "Set.finite_le_nat", "code": "theorem finite_le_nat (n : \u2115) : Set.Finite { i | i \u2264 n }", "start": [913, 1], "end": [914, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.prod", "code": "protected theorem Finite.prod (hs : s.Finite) (ht : t.Finite) : (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)).Finite", "start": [921, 1], "end": [924, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_prod_left", "code": "theorem Finite.of_prod_left (h : (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)).Finite) : t.Nonempty \u2192 s.Finite", "start": [927, 1], "end": [928, 79], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_prod_right", "code": "theorem Finite.of_prod_right (h : (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)).Finite) : s.Nonempty \u2192 t.Finite", "start": [931, 1], "end": [932, 79], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.prod_left", "code": "protected theorem Infinite.prod_left (hs : s.Infinite) (ht : t.Nonempty) : (s \u00d7\u02e2 t).Infinite", "start": [935, 1], "end": [936, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.prod_right", "code": "protected theorem Infinite.prod_right (ht : t.Infinite) (hs : s.Nonempty) : (s \u00d7\u02e2 t).Infinite", "start": [939, 1], "end": [940, 36], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_prod", "code": "protected theorem infinite_prod :\n    (s \u00d7\u02e2 t).Infinite \u2194 s.Infinite \u2227 t.Nonempty \u2228 t.Infinite \u2227 s.Nonempty", "start": [943, 1], "end": [951, 31], "kind": "commanddeclaration"}, {"full_name": "Set.finite_prod", "code": "theorem finite_prod : (s \u00d7\u02e2 t).Finite \u2194 (s.Finite \u2228 t = \u2205) \u2227 (t.Finite \u2228 s = \u2205)", "start": [954, 1], "end": [955, 95], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.offDiag", "code": "protected theorem Finite.offDiag {s : Set \u03b1} (hs : s.Finite) : s.offDiag.Finite", "start": [958, 1], "end": [961, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.image2", "code": "protected theorem Finite.image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hs : s.Finite) (ht : t.Finite) :\n    (image2 f s t).Finite", "start": [964, 1], "end": [968, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.seq", "code": "theorem Finite.seq {f : Set (\u03b1 \u2192 \u03b2)} {s : Set \u03b1} (hf : f.Finite) (hs : s.Finite) :\n    (f.seq s).Finite", "start": [973, 1], "end": [978, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.seq'", "code": "theorem Finite.seq' {\u03b1 \u03b2 : Type u} {f : Set (\u03b1 \u2192 \u03b2)} {s : Set \u03b1} (hf : f.Finite) (hs : s.Finite) :\n    (f <*> s).Finite", "start": [981, 1], "end": [983, 12], "kind": "commanddeclaration"}, {"full_name": "Set.finite_mem_finset", "code": "theorem finite_mem_finset (s : Finset \u03b1) : { a | a \u2208 s }.Finite", "start": [986, 1], "end": [987, 13], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.finite", "code": "theorem Subsingleton.finite {s : Set \u03b1} (h : s.Subsingleton) : s.Finite", "start": [990, 1], "end": [991, 47], "kind": "commanddeclaration"}, {"full_name": "Set.finite_preimage_inl_and_inr", "code": "theorem finite_preimage_inl_and_inr {s : Set (Sum \u03b1 \u03b2)} :\n    (Sum.inl \u207b\u00b9' s).Finite \u2227 (Sum.inr \u207b\u00b9' s).Finite \u2194 s.Finite", "start": [994, 1], "end": [997, 95], "kind": "commanddeclaration"}, {"full_name": "Set.exists_finite_iff_finset", "code": "theorem exists_finite_iff_finset {p : Set \u03b1 \u2192 Prop} :\n    (\u2203 s : Set \u03b1, s.Finite \u2227 p s) \u2194 \u2203 s : Finset \u03b1, p \u2191s", "start": [1000, 1], "end": [1003, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.finite_subsets", "code": "theorem Finite.finite_subsets {\u03b1 : Type u} {a : Set \u03b1} (h : a.Finite) : { b | b \u2286 a }.Finite", "start": [1006, 1], "end": [1010, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.pi", "code": "theorem Finite.pi {\u03b4 : Type*} [Finite \u03b4] {\u03ba : \u03b4 \u2192 Type*} {t : \u2200 d, Set (\u03ba d)}\n    (ht : \u2200 d, (t d).Finite) : (pi univ t).Finite", "start": [1013, 1], "end": [1020, 30], "kind": "commanddeclaration"}, {"full_name": "Set.union_finset_finite_of_range_finite", "code": "theorem union_finset_finite_of_range_finite (f : \u03b1 \u2192 Finset \u03b2) (h : (range f).Finite) :\n    (\u22c3 a, (f a : Set \u03b2)).Finite", "start": [1023, 1], "end": [1027, 44], "kind": "commanddeclaration"}, {"full_name": "Set.finite_range_ite", "code": "theorem finite_range_ite {p : \u03b1 \u2192 Prop} [DecidablePred p] {f g : \u03b1 \u2192 \u03b2} (hf : (range f).Finite)\n    (hg : (range g).Finite) : (range fun x => if p x then f x else g x).Finite", "start": [1030, 1], "end": [1032, 40], "kind": "commanddeclaration"}, {"full_name": "Set.finite_range_const", "code": "theorem finite_range_const {c : \u03b2} : (range fun _ : \u03b1 => c).Finite", "start": [1035, 1], "end": [1036, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inhabited", "code": "instance Finite.inhabited : Inhabited { s : Set \u03b1 // s.Finite } :=\n  \u27e8\u27e8\u2205, finite_empty\u27e9\u27e9", "start": [1044, 1], "end": [1045, 22], "kind": "commanddeclaration"}, {"full_name": "Set.finite_union", "code": "@[simp]\ntheorem finite_union {s t : Set \u03b1} : (s \u222a t).Finite \u2194 s.Finite \u2227 t.Finite", "start": [1048, 1], "end": [1051, 17], "kind": "commanddeclaration"}, {"full_name": "Set.finite_image_iff", "code": "theorem finite_image_iff {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hi : InjOn f s) : (f '' s).Finite \u2194 s.Finite", "start": [1054, 1], "end": [1055, 50], "kind": "commanddeclaration"}, {"full_name": "Set.univ_finite_iff_nonempty_fintype", "code": "theorem univ_finite_iff_nonempty_fintype : (univ : Set \u03b1).Finite \u2194 Nonempty (Fintype \u03b1)", "start": [1058, 1], "end": [1059, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_singleton", "code": "theorem Finite.toFinset_singleton {a : \u03b1} (ha : ({a} : Set \u03b1).Finite := finite_singleton _) :\n    ha.toFinset = {a}", "start": [1063, 1], "end": [1065, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_insert", "code": "@[simp]\ntheorem Finite.toFinset_insert [DecidableEq \u03b1] {s : Set \u03b1} {a : \u03b1} (hs : (insert a s).Finite) :\n    hs.toFinset = insert a (hs.subset <| subset_insert _ _).toFinset", "start": [1068, 1], "end": [1071, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_insert'", "code": "theorem Finite.toFinset_insert' [DecidableEq \u03b1] {a : \u03b1} {s : Set \u03b1} (hs : s.Finite) :\n    (hs.insert a).toFinset = insert a hs.toFinset", "start": [1074, 1], "end": [1076, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_prod", "code": "theorem Finite.toFinset_prod {s : Set \u03b1} {t : Set \u03b2} (hs : s.Finite) (ht : t.Finite) :\n    hs.toFinset \u00d7\u02e2 ht.toFinset = (hs.prod ht).toFinset", "start": [1079, 1], "end": [1081, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_offDiag", "code": "theorem Finite.toFinset_offDiag {s : Set \u03b1} [DecidableEq \u03b1] (hs : s.Finite) :\n    hs.offDiag.toFinset = hs.toFinset.offDiag", "start": [1084, 1], "end": [1086, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.fin_embedding", "code": "theorem Finite.fin_embedding {s : Set \u03b1} (h : s.Finite) :\n    \u2203 (n : \u2115) (f : Fin n \u21aa \u03b1), range f = s", "start": [1089, 1], "end": [1092, 97], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.fin_param", "code": "theorem Finite.fin_param {s : Set \u03b1} (h : s.Finite) :\n    \u2203 (n : \u2115) (f : Fin n \u2192 \u03b1), Injective f \u2227 range f = s", "start": [1095, 1], "end": [1098, 26], "kind": "commanddeclaration"}, {"full_name": "Set.finite_option", "code": "theorem finite_option {s : Set (Option \u03b1)} : s.Finite \u2194 { x : \u03b1 | some x \u2208 s }.Finite", "start": [1101, 1], "end": [1104, 83], "kind": "commanddeclaration"}, {"full_name": "Set.finite_image_fst_and_snd_iff", "code": "theorem finite_image_fst_and_snd_iff {s : Set (\u03b1 \u00d7 \u03b2)} :\n    (Prod.fst '' s).Finite \u2227 (Prod.snd '' s).Finite \u2194 s.Finite", "start": [1107, 1], "end": [1110, 37], "kind": "commanddeclaration"}, {"full_name": "Set.forall_finite_image_eval_iff", "code": "theorem forall_finite_image_eval_iff {\u03b4 : Type*} [Finite \u03b4] {\u03ba : \u03b4 \u2192 Type*} {s : Set (\u2200 d, \u03ba d)} :\n    (\u2200 d, (eval d '' s).Finite) \u2194 s.Finite", "start": [1113, 1], "end": [1115, 84], "kind": "commanddeclaration"}, {"full_name": "Set.finite_subset_iUnion", "code": "theorem finite_subset_iUnion {s : Set \u03b1} (hs : s.Finite) {\u03b9} {t : \u03b9 \u2192 Set \u03b1} (h : s \u2286 \u22c3 i, t i) :\n    \u2203 I : Set \u03b9, I.Finite \u2227 s \u2286 \u22c3 i \u2208 I, t i", "start": [1118, 1], "end": [1124, 24], "kind": "commanddeclaration"}, {"full_name": "Set.eq_finite_iUnion_of_finite_subset_iUnion", "code": "theorem eq_finite_iUnion_of_finite_subset_iUnion {\u03b9} {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b1} (tfin : t.Finite)\n    (h : t \u2286 \u22c3 i, s i) :\n    \u2203 I : Set \u03b9,\n      I.Finite \u2227\n        \u2203 \u03c3 : { i | i \u2208 I } \u2192 Set \u03b1, (\u2200 i, (\u03c3 i).Finite) \u2227 (\u2200 i, \u03c3 i \u2286 s i) \u2227 t = \u22c3 i, \u03c3 i", "start": [1127, 1], "end": [1142, 15], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.induction_on", "code": "@[elab_as_elim]\ntheorem Finite.induction_on {C : Set \u03b1 \u2192 Prop} {s : Set \u03b1} (h : s.Finite) (H0 : C \u2205)\n    (H1 : \u2200 {a s}, a \u2209 s \u2192 Set.Finite s \u2192 C s \u2192 C (insert a s)) : C s", "start": [1145, 1], "end": [1152, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.induction_on'", "code": "@[elab_as_elim]\ntheorem Finite.induction_on' {C : Set \u03b1 \u2192 Prop} {S : Set \u03b1} (h : S.Finite) (H0 : C \u2205)\n    (H1 : \u2200 {a s}, a \u2208 S \u2192 s \u2286 S \u2192 a \u2209 s \u2192 C s \u2192 C (insert a s)) : C S", "start": [1155, 1], "end": [1162, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.dinduction_on", "code": "@[elab_as_elim]\ntheorem Finite.dinduction_on {C : \u2200 s : Set \u03b1, s.Finite \u2192 Prop} (s : Set \u03b1) (h : s.Finite)\n    (H0 : C \u2205 finite_empty)\n    (H1 : \u2200 {a s}, a \u2209 s \u2192 \u2200 h : Set.Finite s, C s h \u2192 C (insert a s) (h.insert a)) : C s h", "start": [1165, 1], "end": [1171, 9], "kind": "commanddeclaration"}, {"full_name": "Set.seq_of_forall_finite_exists", "code": "theorem seq_of_forall_finite_exists {\u03b3 : Type*} {P : \u03b3 \u2192 Set \u03b3 \u2192 Prop}\n    (h : \u2200 t : Set \u03b3, t.Finite \u2192 \u2203 c, P c t) : \u2203 u : \u2115 \u2192 \u03b3, \u2200 n, P (u n) (u '' Iio n)", "start": [1178, 1], "end": [1193, 30], "kind": "commanddeclaration"}, {"full_name": "Set.empty_card", "code": "theorem empty_card : Fintype.card (\u2205 : Set \u03b1) = 0", "start": [1200, 1], "end": [1201, 6], "kind": "commanddeclaration"}, {"full_name": "Set.empty_card'", "code": "@[simp]\ntheorem empty_card' {h : Fintype.{u} (\u2205 : Set \u03b1)} : @Fintype.card (\u2205 : Set \u03b1) h = 0", "start": [1204, 1], "end": [1206, 62], "kind": "commanddeclaration"}, {"full_name": "Set.card_fintypeInsertOfNotMem", "code": "theorem card_fintypeInsertOfNotMem {a : \u03b1} (s : Set \u03b1) [Fintype s] (h : a \u2209 s) :\n    @Fintype.card _ (fintypeInsertOfNotMem s h) = Fintype.card s + 1", "start": [1209, 1], "end": [1214, 6], "kind": "commanddeclaration"}, {"full_name": "Set.card_insert", "code": "@[simp]\ntheorem card_insert {a : \u03b1} (s : Set \u03b1) [Fintype s] (h : a \u2209 s)\n    {d : Fintype.{u} (insert a s : Set \u03b1)} : @Fintype.card _ d = Fintype.card s + 1", "start": [1217, 1], "end": [1220, 76], "kind": "commanddeclaration"}, {"full_name": "Set.card_image_of_inj_on", "code": "theorem card_image_of_inj_on {s : Set \u03b1} [Fintype s] {f : \u03b1 \u2192 \u03b2} [Fintype (f '' s)]\n    (H : \u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y \u2192 x = y) : Fintype.card (f '' s) = Fintype.card s", "start": [1223, 1], "end": [1231, 81], "kind": "commanddeclaration"}, {"full_name": "Set.card_image_of_injective", "code": "theorem card_image_of_injective (s : Set \u03b1) [Fintype s] {f : \u03b1 \u2192 \u03b2} [Fintype (f '' s)]\n    (H : Function.Injective f) : Fintype.card (f '' s) = Fintype.card s", "start": [1234, 1], "end": [1236, 44], "kind": "commanddeclaration"}, {"full_name": "Set.card_singleton", "code": "@[simp]\ntheorem card_singleton (a : \u03b1) : Fintype.card ({a} : Set \u03b1) = 1", "start": [1239, 1], "end": [1241, 32], "kind": "commanddeclaration"}, {"full_name": "Set.card_lt_card", "code": "theorem card_lt_card {s t : Set \u03b1} [Fintype s] [Fintype t] (h : s \u2282 t) :\n    Fintype.card s < Fintype.card t", "start": [1244, 1], "end": [1247, 78], "kind": "commanddeclaration"}, {"full_name": "Set.card_le_of_subset", "code": "theorem card_le_of_subset {s t : Set \u03b1} [Fintype s] [Fintype t] (hsub : s \u2286 t) :\n    Fintype.card s \u2264 Fintype.card t", "start": [1250, 1], "end": [1252, 83], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_subset_of_card_le", "code": "theorem eq_of_subset_of_card_le {s t : Set \u03b1} [Fintype s] [Fintype t] (hsub : s \u2286 t)\n    (hcard : Fintype.card t \u2264 Fintype.card s) : s = t", "start": [1255, 1], "end": [1257, 97], "kind": "commanddeclaration"}, {"full_name": "Set.card_range_of_injective", "code": "theorem card_range_of_injective [Fintype \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Injective f) [Fintype (range f)] :\n    Fintype.card (range f) = Fintype.card \u03b1", "start": [1260, 1], "end": [1262, 58], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.card_toFinset", "code": "theorem Finite.card_toFinset {s : Set \u03b1} [Fintype s] (h : s.Finite) :\n    h.toFinset.card = Fintype.card s", "start": [1265, 1], "end": [1267, 62], "kind": "commanddeclaration"}, {"full_name": "Set.card_ne_eq", "code": "theorem card_ne_eq [Fintype \u03b1] (a : \u03b1) [Fintype { x : \u03b1 | x \u2260 a }] :\n    Fintype.card { x : \u03b1 | x \u2260 a } = Fintype.card \u03b1 - 1", "start": [1270, 1], "end": [1274, 68], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_univ_iff", "code": "theorem infinite_univ_iff : (@univ \u03b1).Infinite \u2194 Infinite \u03b1", "start": [1279, 1], "end": [1280, 62], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_univ", "code": "theorem infinite_univ [h : Infinite \u03b1] : (@univ \u03b1).Infinite", "start": [1283, 1], "end": [1284, 24], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_coe_iff", "code": "theorem infinite_coe_iff {s : Set \u03b1} : Infinite s \u2194 s.Infinite", "start": [1287, 1], "end": [1288, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.to_subtype", "code": "alias \u27e8_, Infinite.to_subtype\u27e9 := infinite_coe_iff", "start": [1292, 1], "end": [1292, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Infinite.natEmbedding", "code": "noncomputable def Infinite.natEmbedding (s : Set \u03b1) (h : s.Infinite) : \u2115 \u21aa s :=\n  h.to_subtype.natEmbedding", "start": [1295, 1], "end": [1297, 28], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_subset_card_eq", "code": "theorem Infinite.exists_subset_card_eq {s : Set \u03b1} (hs : s.Infinite) (n : \u2115) :\n    \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 t.card = n", "start": [1300, 1], "end": [1302, 82], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_finite_compl", "code": "theorem infinite_of_finite_compl [Infinite \u03b1] {s : Set \u03b1} (hs : s\u1d9c.Finite) : s.Infinite", "start": [1305, 1], "end": [1306, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.infinite_compl", "code": "theorem Finite.infinite_compl [Infinite \u03b1] {s : Set \u03b1} (hs : s.Finite) : s\u1d9c.Infinite", "start": [1309, 1], "end": [1310, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.mono", "code": "protected theorem Infinite.mono {s t : Set \u03b1} (h : s \u2286 t) : s.Infinite \u2192 t.Infinite", "start": [1313, 1], "end": [1314, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.diff", "code": "theorem Infinite.diff {s t : Set \u03b1} (hs : s.Infinite) (ht : t.Finite) : (s \\ t).Infinite", "start": [1317, 1], "end": [1318, 21], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_union", "code": "@[simp]\ntheorem infinite_union {s t : Set \u03b1} : (s \u222a t).Infinite \u2194 s.Infinite \u2228 t.Infinite", "start": [1321, 1], "end": [1323, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.of_image", "code": "theorem Infinite.of_image (f : \u03b1 \u2192 \u03b2) {s : Set \u03b1} (hs : (f '' s).Infinite) : s.Infinite", "start": [1326, 1], "end": [1327, 25], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_image_iff", "code": "theorem infinite_image_iff {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hi : InjOn f s) :\n    (f '' s).Infinite \u2194 s.Infinite", "start": [1330, 1], "end": [1332, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.image", "code": "alias \u27e8_, Infinite.image\u27e9 := infinite_image_iff", "start": [1335, 1], "end": [1335, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Infinite.image2_left", "code": "protected theorem Infinite.image2_left (hs : s.Infinite) (hb : b \u2208 t)\n    (hf : InjOn (fun a => f a b) s) : (image2 f s t).Infinite", "start": [1345, 1], "end": [1347, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.image2_right", "code": "protected theorem Infinite.image2_right (ht : t.Infinite) (ha : a \u2208 s) (hf : InjOn (f a) t) :\n    (image2 f s t).Infinite", "start": [1350, 1], "end": [1352, 53], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_image2", "code": "theorem infinite_image2 (hfs : \u2200 b \u2208 t, InjOn (fun a => f a b) s) (hft : \u2200 a \u2208 s, InjOn (f a) t) :\n    (image2 f s t).Infinite \u2194 s.Infinite \u2227 t.Nonempty \u2228 t.Infinite \u2227 s.Nonempty", "start": [1355, 1], "end": [1362, 42], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_injOn_mapsTo", "code": "theorem infinite_of_injOn_mapsTo {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hi : InjOn f s)\n    (hm : MapsTo f s t) (hs : s.Infinite) : t.Infinite", "start": [1367, 1], "end": [1369, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_ne_map_eq_of_mapsTo", "code": "theorem Infinite.exists_ne_map_eq_of_mapsTo {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hs : s.Infinite)\n    (hf : MapsTo f s t) (ht : t.Finite) : \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y", "start": [1372, 1], "end": [1375, 87], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_range_of_injective", "code": "theorem infinite_range_of_injective [Infinite \u03b1] {f : \u03b1 \u2192 \u03b2} (hi : Injective f) :\n    (range f).Infinite", "start": [1378, 1], "end": [1381, 22], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_injective_forall_mem", "code": "theorem infinite_of_injective_forall_mem [Infinite \u03b1] {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hi : Injective f)\n    (hf : \u2200 x : \u03b1, f x \u2208 s) : s.Infinite", "start": [1384, 1], "end": [1387, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_not_mem_finset", "code": "theorem Infinite.exists_not_mem_finset {s : Set \u03b1} (hs : s.Infinite) (f : Finset \u03b1) :\n    \u2203 a \u2208 s, a \u2209 f", "start": [1390, 1], "end": [1393, 47], "kind": "commanddeclaration"}, {"full_name": "Set.not_injOn_infinite_finite_image", "code": "theorem not_injOn_infinite_finite_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h_inf : s.Infinite)\n    (h_fin : (f '' s).Finite) : \u00acInjOn f s", "start": [1396, 1], "end": [1403, 53], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_forall_exists_gt", "code": "theorem infinite_of_forall_exists_gt (h : \u2200 a, \u2203 b \u2208 s, a < b) : s.Infinite", "start": [1412, 1], "end": [1417, 74], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_forall_exists_lt", "code": "theorem infinite_of_forall_exists_lt (h : \u2200 a, \u2203 b \u2208 s, b < a) : s.Infinite", "start": [1420, 1], "end": [1421, 44], "kind": "commanddeclaration"}, {"full_name": "Set.finite_isTop", "code": "theorem finite_isTop (\u03b1 : Type*) [PartialOrder \u03b1] : { x : \u03b1 | IsTop x }.Finite", "start": [1426, 1], "end": [1427, 32], "kind": "commanddeclaration"}, {"full_name": "Set.finite_isBot", "code": "theorem finite_isBot (\u03b1 : Type*) [PartialOrder \u03b1] : { x : \u03b1 | IsBot x }.Finite", "start": [1430, 1], "end": [1431, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_lt_map_eq_of_mapsTo", "code": "theorem Infinite.exists_lt_map_eq_of_mapsTo [LinearOrder \u03b1] {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hs : s.Infinite) (hf : MapsTo f s t) (ht : t.Finite) : \u2203 x \u2208 s, \u2203 y \u2208 s, x < y \u2227 f x = f y", "start": [1434, 1], "end": [1437, 97], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_lt_map_eq_of_forall_mem", "code": "theorem Finite.exists_lt_map_eq_of_forall_mem [LinearOrder \u03b1] [Infinite \u03b1] {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 a, f a \u2208 t) (ht : t.Finite) : \u2203 a b, a < b \u2227 f a = f b", "start": [1440, 1], "end": [1444, 18], "kind": "commanddeclaration"}, {"full_name": "Set.exists_min_image", "code": "theorem exists_min_image [LinearOrder \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (h1 : s.Finite) :\n    s.Nonempty \u2192 \u2203 a \u2208 s, \u2200 b \u2208 s, f a \u2264 f b", "start": [1447, 1], "end": [1451, 63], "kind": "commanddeclaration"}, {"full_name": "Set.exists_max_image", "code": "theorem exists_max_image [LinearOrder \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (h1 : s.Finite) :\n    s.Nonempty \u2192 \u2203 a \u2208 s, \u2200 b \u2208 s, f b \u2264 f a", "start": [1454, 1], "end": [1458, 63], "kind": "commanddeclaration"}, {"full_name": "Set.exists_lower_bound_image", "code": "theorem exists_lower_bound_image [Nonempty \u03b1] [LinearOrder \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (h : s.Finite) : \u2203 a : \u03b1, \u2200 b \u2208 s, f a \u2264 f b", "start": [1461, 1], "end": [1466, 37], "kind": "commanddeclaration"}, {"full_name": "Set.exists_upper_bound_image", "code": "theorem exists_upper_bound_image [Nonempty \u03b1] [LinearOrder \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (h : s.Finite) : \u2203 a : \u03b1, \u2200 b \u2208 s, f b \u2264 f a", "start": [1469, 1], "end": [1471, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.iSup_biInf_of_monotone", "code": "theorem Finite.iSup_biInf_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)] [Order.Frame \u03b1] {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1}\n    (hf : \u2200 i \u2208 s, Monotone (f i)) : \u2a06 j, \u2a05 i \u2208 s, f i j = \u2a05 i \u2208 s, \u2a06 j, f i j", "start": [1474, 1], "end": [1481, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.iSup_biInf_of_antitone", "code": "theorem Finite.iSup_biInf_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Order.Frame \u03b1] {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1}\n    (hf : \u2200 i \u2208 s, Antitone (f i)) : \u2a06 j, \u2a05 i \u2208 s, f i j = \u2a05 i \u2208 s, \u2a06 j, f i j", "start": [1484, 1], "end": [1487, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.iInf_biSup_of_monotone", "code": "theorem Finite.iInf_biSup_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Order.Coframe \u03b1] {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1}\n    (hf : \u2200 i \u2208 s, Monotone (f i)) : \u2a05 j, \u2a06 i \u2208 s, f i j = \u2a06 i \u2208 s, \u2a05 j, f i j", "start": [1490, 1], "end": [1493, 72], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.iInf_biSup_of_antitone", "code": "theorem Finite.iInf_biSup_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)] [Order.Coframe \u03b1] {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1}\n    (hf : \u2200 i \u2208 s, Antitone (f i)) : \u2a05 j, \u2a06 i \u2208 s, f i j = \u2a06 i \u2208 s, \u2a05 j, f i j", "start": [1496, 1], "end": [1499, 72], "kind": "commanddeclaration"}, {"full_name": "Set.iSup_iInf_of_monotone", "code": "theorem iSup_iInf_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)] [Order.Frame \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 i, Monotone (f i)) :\n    \u2a06 j, \u2a05 i, f i j = \u2a05 i, \u2a06 j, f i j", "start": [1502, 1], "end": [1505, 82], "kind": "commanddeclaration"}, {"full_name": "Set.iSup_iInf_of_antitone", "code": "theorem iSup_iInf_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Order.Frame \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 i, Antitone (f i)) :\n    \u2a06 j, \u2a05 i, f i j = \u2a05 i, \u2a06 j, f i j", "start": [1508, 1], "end": [1511, 72], "kind": "commanddeclaration"}, {"full_name": "Set.iInf_iSup_of_monotone", "code": "theorem iInf_iSup_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Order.Coframe \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 i, Monotone (f i)) :\n    \u2a05 j, \u2a06 i, f i j = \u2a06 i, \u2a05 j, f i j", "start": [1514, 1], "end": [1517, 62], "kind": "commanddeclaration"}, {"full_name": "Set.iInf_iSup_of_antitone", "code": "theorem iInf_iSup_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)] [Order.Coframe \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 i, Antitone (f i)) :\n    \u2a05 j, \u2a06 i, f i j = \u2a06 i, \u2a05 j, f i j", "start": [1520, 1], "end": [1523, 62], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iInter_of_monotone", "code": "theorem iUnion_iInter_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)]\n    [Nonempty \u03b9'] {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} (hs : \u2200 i, Monotone (s i)) :\n    \u22c3 j : \u03b9', \u22c2 i : \u03b9, s i j = \u22c2 i : \u03b9, \u22c3 j : \u03b9', s i j", "start": [1526, 1], "end": [1530, 27], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_iInter_of_antitone", "code": "theorem iUnion_iInter_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Nonempty \u03b9'] {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} (hs : \u2200 i, Antitone (s i)) :\n    \u22c3 j : \u03b9', \u22c2 i : \u03b9, s i j = \u22c2 i : \u03b9, \u22c3 j : \u03b9', s i j", "start": [1533, 1], "end": [1537, 27], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iUnion_of_monotone", "code": "theorem iInter_iUnion_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9']\n    [IsDirected \u03b9' (swap (\u00b7 \u2264 \u00b7))] [Nonempty \u03b9'] {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} (hs : \u2200 i, Monotone (s i)) :\n    \u22c2 j : \u03b9', \u22c3 i : \u03b9, s i j = \u22c3 i : \u03b9, \u22c2 j : \u03b9', s i j", "start": [1540, 1], "end": [1544, 27], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_iUnion_of_antitone", "code": "theorem iInter_iUnion_of_antitone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)]\n    [Nonempty \u03b9'] {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} (hs : \u2200 i, Antitone (s i)) :\n    \u22c2 j : \u03b9', \u22c3 i : \u03b9, s i j = \u22c3 i : \u03b9, \u22c2 j : \u03b9', s i j", "start": [1547, 1], "end": [1551, 27], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_pi_of_monotone", "code": "theorem iUnion_pi_of_monotone {\u03b9 \u03b9' : Type*} [LinearOrder \u03b9'] [Nonempty \u03b9'] {\u03b1 : \u03b9 \u2192 Type*}\n    {I : Set \u03b9} {s : \u2200 i, \u03b9' \u2192 Set (\u03b1 i)} (hI : I.Finite) (hs : \u2200 i \u2208 I, Monotone (s i)) :\n    \u22c3 j : \u03b9', I.pi (fun i => s i j) = I.pi fun i => \u22c3 j, s i j", "start": [1554, 1], "end": [1560, 36], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_univ_pi_of_monotone", "code": "theorem iUnion_univ_pi_of_monotone {\u03b9 \u03b9' : Type*} [LinearOrder \u03b9'] [Nonempty \u03b9'] [Finite \u03b9]\n    {\u03b1 : \u03b9 \u2192 Type*} {s : \u2200 i, \u03b9' \u2192 Set (\u03b1 i)} (hs : \u2200 i, Monotone (s i)) :\n    \u22c3 j : \u03b9', pi univ (fun i => s i j) = pi univ fun i => \u22c3 j, s i j", "start": [1563, 1], "end": [1566, 52], "kind": "commanddeclaration"}, {"full_name": "Set.finite_range_findGreatest", "code": "theorem finite_range_findGreatest {P : \u03b1 \u2192 \u2115 \u2192 Prop} [\u2200 x, DecidablePred (P x)] {b : \u2115} :\n    (range fun x => Nat.findGreatest (P x) b).Finite", "start": [1569, 1], "end": [1571, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_maximal_wrt", "code": "theorem Finite.exists_maximal_wrt [PartialOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : s.Finite)\n    (hs : s.Nonempty) : \u2203 a \u2208 s, \u2200 a' \u2208 s, f a \u2264 f a' \u2192 f a = f a'", "start": [1574, 1], "end": [1591, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_maximal_wrt'", "code": "theorem Finite.exists_maximal_wrt' [PartialOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : (f '' s).Finite)\n    (hs : s.Nonempty) : (\u2203 a \u2208 s, \u2200 (a' : \u03b1), a' \u2208 s \u2192 f a \u2264 f a' \u2192 f a = f a')", "start": [1594, 1], "end": [1599, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_minimal_wrt", "code": "theorem Finite.exists_minimal_wrt [PartialOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : s.Finite)\n    (hs : s.Nonempty) : \u2203 a \u2208 s, \u2200 a' \u2208 s, f a' \u2264 f a \u2192 f a = f a'", "start": [1601, 1], "end": [1603, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.exists_minimal_wrt'", "code": "lemma Finite.exists_minimal_wrt' [PartialOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : (f '' s).Finite)\n    (hs : s.Nonempty) : (\u2203 a \u2208 s, \u2200 (a' : \u03b1), a' \u2208 s \u2192 f a' \u2264 f a \u2192 f a = f a') :=\n  Set.Finite.exists_maximal_wrt' (\u03b2 := \u03b2\u1d52\u1d48) f s h hs", "start": [1605, 1], "end": [1609, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Finite.bddAbove", "code": "protected theorem Finite.bddAbove (hs : s.Finite) : BddAbove s", "start": [1615, 1], "end": [1617, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.bddAbove_biUnion", "code": "theorem Finite.bddAbove_biUnion {I : Set \u03b2} {S : \u03b2 \u2192 Set \u03b1} (H : I.Finite) :\n    BddAbove (\u22c3 i \u2208 I, S i) \u2194 \u2200 i \u2208 I, BddAbove (S i)", "start": [1620, 1], "end": [1624, 85], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_not_bddAbove", "code": "theorem infinite_of_not_bddAbove : \u00acBddAbove s \u2192 s.Infinite", "start": [1627, 1], "end": [1628, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.bddBelow", "code": "protected theorem Finite.bddBelow (hs : s.Finite) : BddBelow s", "start": [1637, 1], "end": [1639, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.bddBelow_biUnion", "code": "theorem Finite.bddBelow_biUnion {I : Set \u03b2} {S : \u03b2 \u2192 Set \u03b1} (H : I.Finite) :\n    BddBelow (\u22c3 i \u2208 I, S i) \u2194 \u2200 i \u2208 I, BddBelow (S i)", "start": [1642, 1], "end": [1645, 45], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_of_not_bddBelow", "code": "theorem infinite_of_not_bddBelow : \u00acBddBelow s \u2192 s.Infinite", "start": [1648, 1], "end": [1648, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.bddAbove", "code": "protected theorem bddAbove [SemilatticeSup \u03b1] [Nonempty \u03b1] (s : Finset \u03b1) : BddAbove (\u2191s : Set \u03b1)", "start": [1657, 1], "end": [1659, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.bddBelow", "code": "protected theorem bddBelow [SemilatticeInf \u03b1] [Nonempty \u03b1] (s : Finset \u03b1) : BddBelow (\u2191s : Set \u03b1)", "start": [1662, 1], "end": [1664, 26], "kind": "commanddeclaration"}, {"full_name": "Finite.of_forall_not_lt_lt", "code": "lemma Finite.of_forall_not_lt_lt (h : \u2200 \u2983x y z : \u03b1\u2984, x < y \u2192 y < z \u2192 False) : Finite \u03b1 := by\n  nontriviality \u03b1\n  rcases exists_pair_ne \u03b1 with \u27e8x, y, hne\u27e9\n  refine' @Finite.of_fintype \u03b1 \u27e8{x, y}, fun z => _\u27e9\n  simpa [hne] using eq_or_eq_or_eq_of_forall_not_lt_lt h z x y", "start": [1671, 1], "end": [1677, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Set.finite_of_forall_not_lt_lt", "code": "lemma Set.finite_of_forall_not_lt_lt (h : \u2200 x \u2208 s, \u2200 y \u2208 s, \u2200 z \u2208 s, x < y \u2192 y < z \u2192 False) :\n    Set.Finite s :=\n  @Set.toFinite _ s <| Finite.of_forall_not_lt_lt $ by simpa only [SetCoe.forall'] using h", "start": [1680, 1], "end": [1683, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Set.finite_diff_iUnion_Ioo", "code": "lemma Set.finite_diff_iUnion_Ioo (s : Set \u03b1) : (s \\ \u22c3 (x \u2208 s) (y \u2208 s), Ioo x y).Finite :=\n  Set.finite_of_forall_not_lt_lt fun _x hx _y hy _z hz hxy hyz => hy.2 <| mem_iUnion\u2082_of_mem hx.1 <|\n    mem_iUnion\u2082_of_mem hz.1 \u27e8hxy, hyz\u27e9", "start": [1686, 1], "end": [1688, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Set.finite_diff_iUnion_Ioo'", "code": "lemma Set.finite_diff_iUnion_Ioo' (s : Set \u03b1) : (s \\ \u22c3 x : s \u00d7 s, Ioo x.1 x.2).Finite := by\n  simpa only [iUnion, iSup_prod, iSup_subtype] using s.finite_diff_iUnion_Ioo", "start": [1691, 1], "end": [1692, 78], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Finset/Sort.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/List/NodupEquivFin.lean", "Mathlib/Order/RelIso/Set.lean", "Mathlib/Data/Fintype/Lattice.lean", "Mathlib/Data/Multiset/Sort.lean"], "premises": [{"full_name": "Finset.sort", "code": "def sort (s : Finset \u03b1) : List \u03b1 :=\n  Multiset.sort r s.1", "start": [31, 1], "end": [34, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_sorted", "code": "@[simp]\ntheorem sort_sorted (s : Finset \u03b1) : List.Sorted r (sort r s)", "start": [37, 1], "end": [39, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_eq", "code": "@[simp]\ntheorem sort_eq (s : Finset \u03b1) : \u2191(sort r s) = s.1", "start": [42, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_nodup", "code": "@[simp]\ntheorem sort_nodup (s : Finset \u03b1) : (sort r s).Nodup", "start": [47, 1], "end": [49, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_toFinset", "code": "@[simp]\ntheorem sort_toFinset [DecidableEq \u03b1] (s : Finset \u03b1) : (sort r s).toFinset = s", "start": [52, 1], "end": [54, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sort", "code": "@[simp]\ntheorem mem_sort {s : Finset \u03b1} {a : \u03b1} : a \u2208 sort r s \u2194 a \u2208 s", "start": [57, 1], "end": [59, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.length_sort", "code": "@[simp]\ntheorem length_sort {s : Finset \u03b1} : (sort r s).length = s.card", "start": [62, 1], "end": [64, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_empty", "code": "@[simp]\ntheorem sort_empty : sort r \u2205 = []", "start": [67, 1], "end": [69, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_singleton", "code": "@[simp]\ntheorem sort_singleton (a : \u03b1) : sort r {a} = [a]", "start": [72, 1], "end": [74, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_perm_toList", "code": "theorem sort_perm_toList (s : Finset \u03b1) : sort r s ~ s.toList", "start": [77, 1], "end": [79, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.sort_sorted_lt", "code": "theorem sort_sorted_lt (s : Finset \u03b1) : List.Sorted (\u00b7 < \u00b7) (sort (\u00b7 \u2264 \u00b7) s)", "start": [88, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.sorted_zero_eq_min'_aux", "code": "theorem sorted_zero_eq_min'_aux (s : Finset \u03b1) (h : 0 < (s.sort (\u00b7 \u2264 \u00b7)).length) (H : s.Nonempty) :\n    (s.sort (\u00b7 \u2264 \u00b7)).nthLe 0 h = s.min' H", "start": [92, 1], "end": [101, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.sorted_zero_eq_min'", "code": "theorem sorted_zero_eq_min' {s : Finset \u03b1} {h : 0 < (s.sort (\u00b7 \u2264 \u00b7)).length} :\n    (s.sort (\u00b7 \u2264 \u00b7)).nthLe 0 h = s.min' (card_pos.1 <| by rwa [length_sort] at h)", "start": [104, 1], "end": [106, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.min'_eq_sorted_zero", "code": "theorem min'_eq_sorted_zero {s : Finset \u03b1} {h : s.Nonempty} :\n    s.min' h = (s.sort (\u00b7 \u2264 \u00b7)).nthLe 0 (by rw [length_sort]; exact card_pos.2 h)", "start": [109, 1], "end": [111, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.sorted_last_eq_max'_aux", "code": "theorem sorted_last_eq_max'_aux (s : Finset \u03b1)\n    (h : (s.sort (\u00b7 \u2264 \u00b7)).length - 1 < (s.sort (\u00b7 \u2264 \u00b7)).length) (H : s.Nonempty) :\n    (s.sort (\u00b7 \u2264 \u00b7)).nthLe ((s.sort (\u00b7 \u2264 \u00b7)).length - 1) h = s.max' H", "start": [114, 1], "end": [125, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.sorted_last_eq_max'", "code": "theorem sorted_last_eq_max' {s : Finset \u03b1}\n    {h : (s.sort (\u00b7 \u2264 \u00b7)).length - 1 < (s.sort (\u00b7 \u2264 \u00b7)).length} :\n    (s.sort (\u00b7 \u2264 \u00b7)).nthLe ((s.sort (\u00b7 \u2264 \u00b7)).length - 1) h =\n      s.max' (by rw [length_sort] at h; exact card_pos.1 (lt_of_le_of_lt bot_le h))", "start": [128, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.max'_eq_sorted_last", "code": "theorem max'_eq_sorted_last {s : Finset \u03b1} {h : s.Nonempty} :\n    s.max' h =\n      (s.sort (\u00b7 \u2264 \u00b7)).nthLe ((s.sort (\u00b7 \u2264 \u00b7)).length - 1)\n        (by simpa using Nat.sub_lt (card_pos.mpr h) zero_lt_one)", "start": [135, 1], "end": [139, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.orderIsoOfFin", "code": "def orderIsoOfFin (s : Finset \u03b1) {k : \u2115} (h : s.card = k) : Fin k \u2243o s :=\n  OrderIso.trans (Fin.castIso ((length_sort (\u03b1 := \u03b1) (\u00b7 \u2264 \u00b7)).trans h).symm) <|\n    (s.sort_sorted_lt.getIso _).trans <| OrderIso.setCongr _ _ <| Set.ext fun _ => mem_sort _", "start": [142, 1], "end": [148, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin", "code": "def orderEmbOfFin (s : Finset \u03b1) {k : \u2115} (h : s.card = k) : Fin k \u21aao \u03b1 :=\n  (orderIsoOfFin s h).toOrderEmbedding.trans (OrderEmbedding.subtype _)", "start": [151, 1], "end": [156, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_orderIsoOfFin_apply", "code": "@[simp]\ntheorem coe_orderIsoOfFin_apply (s : Finset \u03b1) {k : \u2115} (h : s.card = k) (i : Fin k) :\n    \u2191(orderIsoOfFin s h i) = orderEmbOfFin s h i", "start": [159, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.orderIsoOfFin_symm_apply", "code": "theorem orderIsoOfFin_symm_apply (s : Finset \u03b1) {k : \u2115} (h : s.card = k) (x : s) :\n    \u2191((s.orderIsoOfFin h).symm x) = (s.sort (\u00b7 \u2264 \u00b7)).indexOf \u2191x", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_apply", "code": "theorem orderEmbOfFin_apply (s : Finset \u03b1) {k : \u2115} (h : s.card = k) (i : Fin k) :\n    s.orderEmbOfFin h i =\n      (s.sort (\u00b7 \u2264 \u00b7)).nthLe i (by rw [length_sort, h]; exact i.2)", "start": [170, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_mem", "code": "@[simp]\ntheorem orderEmbOfFin_mem (s : Finset \u03b1) {k : \u2115} (h : s.card = k) (i : Fin k) :\n    s.orderEmbOfFin h i \u2208 s", "start": [176, 1], "end": [179, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.range_orderEmbOfFin", "code": "@[simp]\ntheorem range_orderEmbOfFin (s : Finset \u03b1) {k : \u2115} (h : s.card = k) :\n    Set.range (s.orderEmbOfFin h) = s", "start": [182, 1], "end": [188, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_zero", "code": "theorem orderEmbOfFin_zero {s : Finset \u03b1} {k : \u2115} (h : s.card = k) (hz : 0 < k) :\n    orderEmbOfFin s h \u27e80, hz\u27e9 = s.min' (card_pos.mp (h.symm \u25b8 hz))", "start": [191, 1], "end": [194, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_last", "code": "theorem orderEmbOfFin_last {s : Finset \u03b1} {k : \u2115} (h : s.card = k) (hz : 0 < k) :\n    orderEmbOfFin s h \u27e8k - 1, Nat.sub_lt hz (Nat.succ_pos 0)\u27e9 =\n      s.max' (card_pos.mp (h.symm \u25b8 hz))", "start": [197, 1], "end": [201, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_singleton", "code": "@[simp]\ntheorem orderEmbOfFin_singleton (a : \u03b1) (i : Fin 1) :\n    orderEmbOfFin {a} (card_singleton a) i = a", "start": [204, 1], "end": [208, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_unique", "code": "theorem orderEmbOfFin_unique {s : Finset \u03b1} {k : \u2115} (h : s.card = k) {f : Fin k \u2192 \u03b1}\n    (hfs : \u2200 x, f x \u2208 s) (hmono : StrictMono f) : f = s.orderEmbOfFin h", "start": [211, 1], "end": [220, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_unique'", "code": "theorem orderEmbOfFin_unique' {s : Finset \u03b1} {k : \u2115} (h : s.card = k) {f : Fin k \u21aao \u03b1}\n    (hfs : \u2200 x, f x \u2208 s) : f = s.orderEmbOfFin h", "start": [223, 1], "end": [227, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfFin_eq_orderEmbOfFin_iff", "code": "@[simp]\ntheorem orderEmbOfFin_eq_orderEmbOfFin_iff {k l : \u2115} {s : Finset \u03b1} {i : Fin k} {j : Fin l}\n    {h : s.card = k} {h' : s.card = l} :\n    s.orderEmbOfFin h i = s.orderEmbOfFin h' j \u2194 (i : \u2115) = (j : \u2115)", "start": [230, 1], "end": [238, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfCardLe", "code": "def orderEmbOfCardLe (s : Finset \u03b1) {k : \u2115} (h : k \u2264 s.card) : Fin k \u21aao \u03b1 :=\n  (Fin.castLEEmb h).trans (s.orderEmbOfFin rfl)", "start": [241, 1], "end": [245, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.orderEmbOfCardLe_mem", "code": "theorem orderEmbOfCardLe_mem (s : Finset \u03b1) {k : \u2115} (h : k \u2264 s.card) (a) :\n    orderEmbOfCardLe s h a \u2208 s", "start": [248, 1], "end": [251, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.sort_univ", "code": "theorem sort_univ (n : \u2115) : Finset.univ.sort (fun x y : Fin n => x \u2264 y) = List.finRange n", "start": [265, 1], "end": [270, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Denumerable.lean", "imports": ["Mathlib/Data/List/MinMax.lean", "Mathlib/Data/Nat/Order/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Lattice.lean", "Mathlib/Logic/Encodable/Basic.lean"], "premises": [{"full_name": "Denumerable", "code": "class Denumerable (\u03b1 : Type*) extends Encodable \u03b1 where\n  \n  decode_inv : \u2200 n, \u2203 a \u2208 decode n, encode a = n", "start": [29, 1], "end": [32, 49], "kind": "commanddeclaration"}, {"full_name": "Denumerable.decode_isSome", "code": "theorem decode_isSome (\u03b1) [Denumerable \u03b1] (n : \u2115) : (decode (\u03b1 := \u03b1) n).isSome", "start": [45, 1], "end": [46, 69], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofNat", "code": "def ofNat (\u03b1) [Denumerable \u03b1] (n : \u2115) : \u03b1 :=\n  Option.get _ (decode_isSome \u03b1 n)", "start": [49, 1], "end": [51, 35], "kind": "commanddeclaration"}, {"full_name": "Denumerable.decode_eq_ofNat", "code": "@[simp]\ntheorem decode_eq_ofNat (\u03b1) [Denumerable \u03b1] (n : \u2115) : decode (\u03b1 := \u03b1) n = some (ofNat \u03b1 n)", "start": [54, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofNat_of_decode", "code": "@[simp]\ntheorem ofNat_of_decode {n b} (h : decode (\u03b1 := \u03b1) n = some b) : ofNat (\u03b1 := \u03b1) n = b", "start": [59, 1], "end": [61, 56], "kind": "commanddeclaration"}, {"full_name": "Denumerable.encode_ofNat", "code": "@[simp]\ntheorem encode_ofNat (n) : encode (ofNat \u03b1 n) = n", "start": [64, 1], "end": [67, 26], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofNat_encode", "code": "@[simp]\ntheorem ofNat_encode (a) : ofNat \u03b1 (encode a) = a", "start": [70, 1], "end": [72, 30], "kind": "commanddeclaration"}, {"full_name": "Denumerable.eqv", "code": "def eqv (\u03b1) [Denumerable \u03b1] : \u03b1 \u2243 \u2115 :=\n  \u27e8encode, ofNat \u03b1, ofNat_encode, encode_ofNat\u27e9", "start": [75, 1], "end": [77, 48], "kind": "commanddeclaration"}, {"full_name": "Denumerable.mk'", "code": "def mk' {\u03b1} (e : \u03b1 \u2243 \u2115) : Denumerable \u03b1 where\n  encode := e\n  decode := some \u2218 e.symm\n  encodek _ := congr_arg some (e.symm_apply_apply _)\n  decode_inv _ := \u27e8_, rfl, e.apply_symm_apply _\u27e9", "start": [84, 1], "end": [89, 49], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofEquiv", "code": "def ofEquiv (\u03b1) {\u03b2} [Denumerable \u03b1] (e : \u03b2 \u2243 \u03b1) : Denumerable \u03b2 :=\n  { Encodable.ofEquiv _ e with\n    decode_inv := fun n => by\n      simp_rw [Option.mem_def, decode_ofEquiv e, encode_ofEquiv e, decode_eq_ofNat,\n        Option.map_some', Option.some_inj, exists_eq_left', Equiv.apply_symm_apply,\n        Denumerable.encode_ofNat] }", "start": [92, 1], "end": [100, 36], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofEquiv_ofNat", "code": "@[simp]\ntheorem ofEquiv_ofNat (\u03b1) {\u03b2} [Denumerable \u03b1] (e : \u03b2 \u2243 \u03b1) (n) :\n    @ofNat \u03b2 (ofEquiv _ e) n = e.symm (ofNat \u03b1 n)", "start": [103, 1], "end": [110, 7], "kind": "commanddeclaration"}, {"full_name": "Denumerable.equiv\u2082", "code": "def equiv\u2082 (\u03b1 \u03b2) [Denumerable \u03b1] [Denumerable \u03b2] : \u03b1 \u2243 \u03b2 :=\n  (eqv \u03b1).trans (eqv \u03b2).symm", "start": [113, 1], "end": [115, 29], "kind": "commanddeclaration"}, {"full_name": "Denumerable.nat", "code": "instance nat : Denumerable \u2115 :=\n  \u27e8fun _ => \u27e8_, rfl, rfl\u27e9\u27e9", "start": [118, 1], "end": [119, 27], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofNat_nat", "code": "@[simp]\ntheorem ofNat_nat (n) : ofNat \u2115 n = n", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Denumerable.option", "code": "instance option : Denumerable (Option \u03b1) :=\n  \u27e8fun n => by\n    cases n\n    case zero =>\n      refine' \u27e8none, _, encode_none\u27e9\n      rw [decode_option_zero, Option.mem_def]\n    case succ n =>\n      refine' \u27e8some (ofNat \u03b1 n), _, _\u27e9\n      \u00b7 rw [decode_option_succ, decode_eq_ofNat, Option.map_some', Option.mem_def]\n      rw [encode_some, encode_ofNat]\u27e9", "start": [127, 1], "end": [137, 38], "kind": "commanddeclaration"}, {"full_name": "Denumerable.sum", "code": "instance sum : Denumerable (Sum \u03b1 \u03b2) :=\n  \u27e8fun n => by\n    suffices \u2203 a \u2208 @decodeSum \u03b1 \u03b2 _ _ n, encodeSum a = bit (bodd n) (div2 n) by simpa [bit_decomp]\n    simp only [decodeSum, boddDiv2_eq, decode_eq_ofNat, Option.some.injEq, Option.map_some',\n      Option.mem_def, Sum.exists]\n    cases bodd n <;> simp [decodeSum, bit, encodeSum, bit0_eq_two_mul, bit1]\u27e9", "start": [141, 1], "end": [147, 78], "kind": "commanddeclaration"}, {"full_name": "Denumerable.sigma", "code": "instance sigma : Denumerable (Sigma \u03b3) :=\n  \u27e8fun n => by simp [decodeSigma]\u27e9", "start": [154, 1], "end": [156, 35], "kind": "commanddeclaration"}, {"full_name": "Denumerable.sigma_ofNat_val", "code": "@[simp]\ntheorem sigma_ofNat_val (n : \u2115) :\n    ofNat (Sigma \u03b3) n = \u27e8ofNat \u03b1 (unpair n).1, ofNat (\u03b3 _) (unpair n).2\u27e9", "start": [159, 1], "end": [162, 71], "kind": "commanddeclaration"}, {"full_name": "Denumerable.prod", "code": "instance prod : Denumerable (\u03b1 \u00d7 \u03b2) :=\n  ofEquiv _ (Equiv.sigmaEquivProd \u03b1 \u03b2).symm", "start": [167, 1], "end": [169, 44], "kind": "commanddeclaration"}, {"full_name": "Denumerable.prod_ofNat_val", "code": "theorem prod_ofNat_val (n : \u2115) : ofNat (\u03b1 \u00d7 \u03b2) n = (ofNat \u03b1 (unpair n).1, ofNat \u03b2 (unpair n).2)", "start": [173, 1], "end": [174, 10], "kind": "commanddeclaration"}, {"full_name": "Denumerable.prod_nat_ofNat", "code": "@[simp]\ntheorem prod_nat_ofNat : ofNat (\u2115 \u00d7 \u2115) = unpair", "start": [177, 1], "end": [178, 67], "kind": "commanddeclaration"}, {"full_name": "Denumerable.int", "code": "instance int : Denumerable \u2124 :=\n  Denumerable.mk' Equiv.intEquivNat", "start": [181, 1], "end": [182, 36], "kind": "commanddeclaration"}, {"full_name": "Denumerable.pnat", "code": "instance pnat : Denumerable \u2115+ :=\n  Denumerable.mk' Equiv.pnatEquivNat", "start": [185, 1], "end": [186, 37], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ulift", "code": "instance ulift : Denumerable (ULift \u03b1) :=\n  ofEquiv _ Equiv.ulift", "start": [189, 1], "end": [191, 24], "kind": "commanddeclaration"}, {"full_name": "Denumerable.plift", "code": "instance plift : Denumerable (PLift \u03b1) :=\n  ofEquiv _ Equiv.plift", "start": [194, 1], "end": [196, 24], "kind": "commanddeclaration"}, {"full_name": "Denumerable.pair", "code": "def pair : \u03b1 \u00d7 \u03b1 \u2243 \u03b1 :=\n  equiv\u2082 _ _", "start": [199, 1], "end": [201, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.exists_succ", "code": "theorem exists_succ (x : s) : \u2203 n, (x : \u2115) + n + 1 \u2208 s", "start": [221, 1], "end": [229, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.succ", "code": "def succ (x : s) : s :=\n  have h : \u2203 m, (x : \u2115) + m + 1 \u2208 s := exists_succ x\n  \u27e8\u2191x + Nat.find h + 1, Nat.find_spec h\u27e9", "start": [236, 1], "end": [239, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.succ_le_of_lt", "code": "theorem succ_le_of_lt {x y : s} (h : y < x) : succ y \u2264 x", "start": [242, 1], "end": [248, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.le_succ_of_forall_lt_le", "code": "theorem le_succ_of_forall_lt_le {x y : s} (h : \u2200 z < x, z \u2264 y) : x \u2264 succ y", "start": [251, 1], "end": [258, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.lt_succ_self", "code": "theorem lt_succ_self (x : s) : x < succ x", "start": [261, 1], "end": [265, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.lt_succ_iff_le", "code": "theorem lt_succ_iff_le {x y : s} : x < succ y \u2194 x \u2264 y", "start": [268, 1], "end": [270, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.ofNat", "code": "def ofNat (s : Set \u2115) [DecidablePred (\u00b7 \u2208 s)] [Infinite s] : \u2115 \u2192 s\n  | 0 => \u22a5\n  | n + 1 => succ (ofNat s n)", "start": [273, 1], "end": [276, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.ofNat_surjective_aux", "code": "theorem ofNat_surjective_aux : \u2200 {x : \u2115} (hx : x \u2208 s), \u2203 n, ofNat s n = \u27e8x, hx\u27e9", "start": [279, 1], "end": [302, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.ofNat_surjective", "code": "theorem ofNat_surjective : Surjective (ofNat s)", "start": [305, 1], "end": [305, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.ofNat_range", "code": "@[simp]\ntheorem ofNat_range : Set.range (ofNat s) = Set.univ", "start": [308, 1], "end": [310, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.coe_comp_ofNat_range", "code": "@[simp]\ntheorem coe_comp_ofNat_range : Set.range ((\u2191) \u2218 ofNat s : \u2115 \u2192 \u2115) = s", "start": [313, 1], "end": [315, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.toFunAux", "code": "private def toFunAux (x : s) : \u2115 :=\n  (List.range x).countP (\u00b7 \u2208 s)", "start": [318, 1], "end": [319, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.toFunAux_eq", "code": "private theorem toFunAux_eq (x : s) : toFunAux x = ((Finset.range x).filter (\u00b7 \u2208 s)).card", "start": [321, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.right_inverse_aux", "code": "private theorem right_inverse_aux : \u2200 n, toFunAux (ofNat s n) = n", "start": [327, 1], "end": [349, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.denumerable", "code": "def denumerable (s : Set \u2115) [DecidablePred (\u00b7 \u2208 s)] [Infinite s] : Denumerable s :=\n  Denumerable.ofEquiv \u2115\n    { toFun := toFunAux\n      invFun := ofNat s\n      left_inv := leftInverse_of_surjective_of_rightInverse ofNat_surjective right_inverse_aux\n      right_inv := right_inverse_aux }", "start": [351, 1], "end": [357, 39], "kind": "commanddeclaration"}, {"full_name": "Denumerable.ofEncodableOfInfinite", "code": "def ofEncodableOfInfinite (\u03b1 : Type*) [Encodable \u03b1] [Infinite \u03b1] : Denumerable \u03b1 := by\n  letI := @decidableRangeEncode \u03b1 _\n  letI : Infinite (Set.range (@encode \u03b1 _)) :=\n    Infinite.of_injective _ (Equiv.ofInjective _ encode_injective).injective\n  letI := Nat.Subtype.denumerable (Set.range (@encode \u03b1 _))\n  exact Denumerable.ofEquiv (Set.range (@encode \u03b1 _)) (equivRangeEncode \u03b1)", "start": [366, 1], "end": [372, 75], "kind": "commanddeclaration"}, {"full_name": "nonempty_denumerable", "code": "theorem nonempty_denumerable (\u03b1 : Type*) [Countable \u03b1] [Infinite \u03b1] : Nonempty (Denumerable \u03b1)", "start": [377, 1], "end": [379, 79], "kind": "commanddeclaration"}, {"full_name": "nonempty_denumerable_iff", "code": "theorem nonempty_denumerable_iff {\u03b1 : Type*} :\n    Nonempty (Denumerable \u03b1) \u2194 Countable \u03b1 \u2227 Infinite \u03b1", "start": [382, 1], "end": [384, 82], "kind": "commanddeclaration"}, {"full_name": "nonempty_equiv_of_countable", "code": "instance nonempty_equiv_of_countable [Countable \u03b1] [Infinite \u03b1] [Countable \u03b2] [Infinite \u03b2] :\n    Nonempty (\u03b1 \u2243 \u03b2) := by\n  cases nonempty_denumerable \u03b1\n  cases nonempty_denumerable \u03b2\n  exact \u27e8(Denumerable.eqv _).trans (Denumerable.eqv _).symm\u27e9", "start": [386, 1], "end": [390, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Fin.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Data/Fin/VecNotation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "finZeroEquiv", "code": "def finZeroEquiv : Fin 0 \u2243 Empty :=\n  Equiv.equivEmpty _", "start": [20, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "finZeroEquiv'", "code": "def finZeroEquiv' : Fin 0 \u2243 PEmpty.{u} :=\n  Equiv.equivPEmpty _", "start": [25, 1], "end": [27, 22], "kind": "commanddeclaration"}, {"full_name": "finOneEquiv", "code": "def finOneEquiv : Fin 1 \u2243 Unit :=\n  Equiv.equivPUnit _", "start": [30, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "finTwoEquiv", "code": "def finTwoEquiv : Fin 2 \u2243 Bool where\n  toFun := ![false, true]\n  invFun b := b.casesOn 0 1\n  left_inv := Fin.forall_fin_two.2 <| by simp\n  right_inv := Bool.forall_bool.2 <| by simp", "start": [35, 1], "end": [40, 45], "kind": "commanddeclaration"}, {"full_name": "piFinTwoEquiv", "code": "@[simps (config := { fullyApplied := false })]\ndef piFinTwoEquiv (\u03b1 : Fin 2 \u2192 Type u) : (\u2200 i, \u03b1 i) \u2243 \u03b1 0 \u00d7 \u03b1 1\n    where\n  toFun f := (f 0, f 1)\n  invFun p := Fin.cons p.1 <| Fin.cons p.2 finZeroElim\n  left_inv _ := funext <| Fin.forall_fin_two.2 \u27e8rfl, rfl\u27e9\n  right_inv := fun _ => rfl", "start": [43, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.preimage_apply_01_prod", "code": "theorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim)", "start": [57, 1], "end": [61, 28], "kind": "commanddeclaration"}, {"full_name": "Fin.preimage_apply_01_prod'", "code": "theorem Fin.preimage_apply_01_prod' {\u03b1 : Type u} (s t : Set \u03b1) :\n    (fun f : Fin 2 \u2192 \u03b1 => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t = Set.pi Set.univ ![s, t]", "start": [65, 1], "end": [67, 47], "kind": "commanddeclaration"}, {"full_name": "prodEquivPiFinTwo", "code": "@[simps! (config := { fullyApplied := false })]\ndef prodEquivPiFinTwo (\u03b1 \u03b2 : Type u) : \u03b1 \u00d7 \u03b2 \u2243 \u2200 i : Fin 2, ![\u03b1, \u03b2] i :=\n  (piFinTwoEquiv (Fin.cons \u03b1 (Fin.cons \u03b2 finZeroElim))).symm", "start": [70, 1], "end": [75, 61], "kind": "commanddeclaration"}, {"full_name": "finTwoArrowEquiv", "code": "@[simps (config := { fullyApplied := false })]\ndef finTwoArrowEquiv (\u03b1 : Type*) : (Fin 2 \u2192 \u03b1) \u2243 \u03b1 \u00d7 \u03b1 :=\n  { piFinTwoEquiv fun _ => \u03b1 with invFun := fun x => ![x.1, x.2] }", "start": [80, 1], "end": [84, 67], "kind": "commanddeclaration"}, {"full_name": "OrderIso.piFinTwoIso", "code": "def OrderIso.piFinTwoIso (\u03b1 : Fin 2 \u2192 Type u) [\u2200 i, Preorder (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243o \u03b1 0 \u00d7 \u03b1 1\n    where\n  toEquiv := piFinTwoEquiv \u03b1\n  map_rel_iff' := Iff.symm Fin.forall_fin_two", "start": [89, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "OrderIso.finTwoArrowIso", "code": "def OrderIso.finTwoArrowIso (\u03b1 : Type*) [Preorder \u03b1] : (Fin 2 \u2192 \u03b1) \u2243o \u03b1 \u00d7 \u03b1 :=\n  { OrderIso.piFinTwoIso fun _ => \u03b1 with toEquiv := finTwoArrowEquiv \u03b1 }", "start": [97, 1], "end": [100, 73], "kind": "commanddeclaration"}, {"full_name": "finCongr", "code": "def finCongr (h : m = n) : Fin m \u2243 Fin n :=\n  (Fin.castIso h).toEquiv", "start": [103, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "finCongr_apply_mk", "code": "@[simp] theorem finCongr_apply_mk (h : m = n) (k : \u2115) (w : k < m) :\n    finCongr h \u27e8k, w\u27e9 = \u27e8k, h \u25b8 w\u27e9", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "finCongr_symm", "code": "@[simp] theorem finCongr_symm (h : m = n) : (finCongr h).symm = finCongr h.symm", "start": [113, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "finCongr_apply_coe", "code": "@[simp] theorem finCongr_apply_coe (h : m = n) (k : Fin m) : (finCongr h k : \u2115) = k", "start": [117, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "finCongr_symm_apply_coe", "code": "theorem finCongr_symm_apply_coe (h : m = n) (k : Fin n) : ((finCongr h).symm k : \u2115) = k", "start": [121, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'", "code": "def finSuccEquiv' (i : Fin (n + 1)) : Fin (n + 1) \u2243 Option (Fin n)\n    where\n  toFun := i.insertNth none some\n  invFun x := x.casesOn' i (Fin.succAbove i)\n  left_inv x := Fin.succAboveCases i (by simp) (fun j => by simp) x\n  right_inv x := by cases x <;> dsimp <;> simp", "start": [125, 1], "end": [133, 47], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_at", "code": "@[simp]\ntheorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none", "start": [136, 1], "end": [138, 23], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_succAbove", "code": "@[simp]\ntheorem finSuccEquiv'_succAbove (i : Fin (n + 1)) (j : Fin n) :\n    finSuccEquiv' i (i.succAbove j) = some j", "start": [141, 1], "end": [144, 69], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_below", "code": "theorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m", "start": [147, 1], "end": [149, 60], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_above", "code": "theorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m", "start": [152, 1], "end": [154, 60], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_none", "code": "@[simp]\ntheorem finSuccEquiv'_symm_none (i : Fin (n + 1)) : (finSuccEquiv' i).symm none = i", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_some", "code": "@[simp]\ntheorem finSuccEquiv'_symm_some (i : Fin (n + 1)) (j : Fin n) :\n    (finSuccEquiv' i).symm (some j) = i.succAbove j", "start": [162, 1], "end": [165, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_some_below", "code": "theorem finSuccEquiv'_symm_some_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm (some m) = Fin.castSucc m", "start": [168, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_some_above", "code": "theorem finSuccEquiv'_symm_some_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm (some m) = m.succ", "start": [173, 1], "end": [175, 28], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_coe_below", "code": "theorem finSuccEquiv'_symm_coe_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm m = Fin.castSucc m", "start": [178, 1], "end": [180, 34], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_symm_coe_above", "code": "theorem finSuccEquiv'_symm_coe_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i).symm m = m.succ", "start": [183, 1], "end": [185, 34], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv", "code": "def finSuccEquiv (n : \u2115) : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' 0", "start": [188, 1], "end": [192, 18], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv_zero", "code": "@[simp]\ntheorem finSuccEquiv_zero : (finSuccEquiv n) 0 = none", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv_succ", "code": "@[simp]\ntheorem finSuccEquiv_succ (m : Fin n) : (finSuccEquiv n) m.succ = some m", "start": [200, 1], "end": [202, 38], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv_symm_none", "code": "@[simp]\ntheorem finSuccEquiv_symm_none : (finSuccEquiv n).symm none = 0", "start": [205, 1], "end": [207, 28], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv_symm_some", "code": "@[simp]\ntheorem finSuccEquiv_symm_some (m : Fin n) : (finSuccEquiv n).symm (some m) = m.succ", "start": [210, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_zero", "code": "theorem finSuccEquiv'_zero : finSuccEquiv' (0 : Fin (n + 1)) = finSuccEquiv n", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_last_apply_castSucc", "code": "theorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i", "start": [221, 1], "end": [223, 53], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_last_apply", "code": "theorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i \u2260 Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h)", "start": [225, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccEquiv'_ne_last_apply", "code": "theorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i \u2260 Fin.last n) (hj : j \u2260 i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j", "start": [232, 1], "end": [236, 7], "kind": "commanddeclaration"}, {"full_name": "finSuccAboveEquiv", "code": "def finSuccAboveEquiv (p : Fin (n + 1)) : Fin n \u2243o { x : Fin (n + 1) // x \u2260 p } :=\n  { Equiv.optionSubtype p \u27e8(finSuccEquiv' p).symm, rfl\u27e9 with\n    map_rel_iff' := p.succAboveEmb.map_rel_iff' }", "start": [239, 1], "end": [242, 50], "kind": "commanddeclaration"}, {"full_name": "finSuccAboveEquiv_apply", "code": "theorem finSuccAboveEquiv_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveEquiv p i = \u27e8p.succAbove i, p.succAbove_ne i\u27e9", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "finSuccAboveEquiv_symm_apply_last", "code": "theorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2)", "start": [250, 1], "end": [253, 85], "kind": "commanddeclaration"}, {"full_name": "finSuccAboveEquiv_symm_apply_ne_last", "code": "theorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x", "start": [256, 1], "end": [260, 90], "kind": "commanddeclaration"}, {"full_name": "finSuccEquivLast", "code": "def finSuccEquivLast : Fin (n + 1) \u2243 Option (Fin n) :=\n  finSuccEquiv' (Fin.last n)", "start": [263, 1], "end": [265, 29], "kind": "commanddeclaration"}, {"full_name": "finSuccEquivLast_castSucc", "code": "@[simp]\ntheorem finSuccEquivLast_castSucc (i : Fin n) : finSuccEquivLast (Fin.castSucc i) = some i", "start": [268, 1], "end": [270, 26], "kind": "commanddeclaration"}, {"full_name": "finSuccEquivLast_last", "code": "@[simp]\ntheorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none", "start": [273, 1], "end": [275, 26], "kind": "commanddeclaration"}, {"full_name": "finSuccEquivLast_symm_some", "code": "@[simp]\ntheorem finSuccEquivLast_symm_some (i : Fin n) :\n    finSuccEquivLast.symm (some i) = Fin.castSucc i", "start": [278, 1], "end": [281, 36], "kind": "commanddeclaration"}, {"full_name": "finSuccEquivLast_symm_none", "code": "@[simp] theorem finSuccEquivLast_symm_none : finSuccEquivLast.symm none = Fin.last n", "start": [285, 1], "end": [286, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.piFinSuccAboveEquiv", "code": "@[simps (config := { fullyApplied := false })]\ndef Equiv.piFinSuccAboveEquiv (\u03b1 : Fin (n + 1) \u2192 Type u) (i : Fin (n + 1)) :\n    (\u2200 j, \u03b1 j) \u2243 \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toFun f := (f i, fun j => f (i.succAbove j))\n  invFun f := i.insertNth f.1 f.2\n  left_inv f := by simp [Fin.insertNth_eq_iff]\n  right_inv f := by simp", "start": [289, 1], "end": [296, 25], "kind": "commanddeclaration"}, {"full_name": "OrderIso.piFinSuccAboveIso", "code": "def OrderIso.piFinSuccAboveIso (\u03b1 : Fin (n + 1) \u2192 Type u) [\u2200 i, LE (\u03b1 i)]\n    (i : Fin (n + 1)) : (\u2200 j, \u03b1 j) \u2243o \u03b1 i \u00d7 \u2200 j, \u03b1 (i.succAbove j) where\n  toEquiv := Equiv.piFinSuccAboveEquiv \u03b1 i\n  map_rel_iff' := Iff.symm i.forall_iff_succAbove", "start": [301, 1], "end": [306, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.piFinSucc", "code": "@[simps! (config := { fullyApplied := false })]\ndef Equiv.piFinSucc (n : \u2115) (\u03b2 : Type u) : (Fin (n + 1) \u2192 \u03b2) \u2243 \u03b2 \u00d7 (Fin n \u2192 \u03b2) :=\n  Equiv.piFinSuccAboveEquiv (fun _ => \u03b2) 0", "start": [309, 1], "end": [312, 43], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv", "code": "def finSumFinEquiv : Sum (Fin m) (Fin n) \u2243 Fin (m + n)\n    where\n  toFun := Sum.elim (Fin.castAdd n) (Fin.natAdd m)\n  invFun i := @Fin.addCases m n (fun _ => Sum (Fin m) (Fin n)) Sum.inl Sum.inr i\n  left_inv x := by cases' x with y y <;> dsimp <;> simp\n  right_inv x := by refine' Fin.addCases (fun i => _) (fun i => _) x <;> simp", "start": [317, 1], "end": [323, 78], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv_apply_left", "code": "@[simp]\ntheorem finSumFinEquiv_apply_left (i : Fin m) :\n    (finSumFinEquiv (Sum.inl i) : Fin (m + n)) = Fin.castAdd n i", "start": [326, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv_apply_right", "code": "@[simp]\ntheorem finSumFinEquiv_apply_right (i : Fin n) :\n    (finSumFinEquiv (Sum.inr i) : Fin (m + n)) = Fin.natAdd m i", "start": [332, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv_symm_apply_castAdd", "code": "@[simp]\ntheorem finSumFinEquiv_symm_apply_castAdd (x : Fin m) :\n    finSumFinEquiv.symm (Fin.castAdd n x) = Sum.inl x", "start": [338, 1], "end": [341, 46], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv_symm_apply_natAdd", "code": "@[simp]\ntheorem finSumFinEquiv_symm_apply_natAdd (x : Fin n) :\n    finSumFinEquiv.symm (Fin.natAdd m x) = Sum.inr x", "start": [344, 1], "end": [347, 46], "kind": "commanddeclaration"}, {"full_name": "finSumFinEquiv_symm_last", "code": "@[simp]\ntheorem finSumFinEquiv_symm_last : finSumFinEquiv.symm (Fin.last n) = Sum.inr 0", "start": [350, 1], "end": [352, 37], "kind": "commanddeclaration"}, {"full_name": "finAddFlip", "code": "def finAddFlip : Fin (m + n) \u2243 Fin (n + m) :=\n  (finSumFinEquiv.symm.trans (Equiv.sumComm _ _)).trans finSumFinEquiv", "start": [355, 1], "end": [357, 71], "kind": "commanddeclaration"}, {"full_name": "finAddFlip_apply_castAdd", "code": "@[simp]\ntheorem finAddFlip_apply_castAdd (k : Fin m) (n : \u2115) :\n    finAddFlip (Fin.castAdd n k) = Fin.natAdd n k", "start": [360, 1], "end": [362, 74], "kind": "commanddeclaration"}, {"full_name": "finAddFlip_apply_natAdd", "code": "@[simp]\ntheorem finAddFlip_apply_natAdd (k : Fin n) (m : \u2115) :\n    finAddFlip (Fin.natAdd m k) = Fin.castAdd m k", "start": [365, 1], "end": [367, 74], "kind": "commanddeclaration"}, {"full_name": "finAddFlip_apply_mk_left", "code": "@[simp]\ntheorem finAddFlip_apply_mk_left {k : \u2115} (h : k < m) (hk : k < m + n := Nat.lt_add_right k m n h)\n    (hnk : n + k < n + m := add_lt_add_left h n) :\n    finAddFlip (\u27e8k, hk\u27e9 : Fin (m + n)) = \u27e8n + k, hnk\u27e9", "start": [370, 1], "end": [374, 44], "kind": "commanddeclaration"}, {"full_name": "finAddFlip_apply_mk_right", "code": "@[simp]\ntheorem finAddFlip_apply_mk_right {k : \u2115} (h\u2081 : m \u2264 k) (h\u2082 : k < m + n) :\n    finAddFlip (\u27e8k, h\u2082\u27e9 : Fin (m + n)) = \u27e8k - m, tsub_le_self.trans_lt <| add_comm m n \u25b8 h\u2082\u27e9", "start": [377, 1], "end": [382, 19], "kind": "commanddeclaration"}, {"full_name": "finRotate", "code": "def finRotate : \u2200 n, Equiv.Perm (Fin n)\n  | 0 => Equiv.refl _\n  | n + 1 => finAddFlip.trans (finCongr (add_comm 1 n))", "start": [385, 1], "end": [388, 56], "kind": "commanddeclaration"}, {"full_name": "finRotate_zero", "code": "@[simp] lemma finRotate_zero : finRotate 0 = Equiv.refl _ := rfl", "start": [391, 1], "end": [391, 65], "kind": "mathlibtacticlemma"}, {"full_name": "finRotate_succ", "code": "lemma finRotate_succ (n : \u2115) : finRotate (n + 1) = finAddFlip.trans (finCongr (add_comm 1 n)) := rfl", "start": [394, 1], "end": [394, 101], "kind": "mathlibtacticlemma"}, {"full_name": "finRotate_of_lt", "code": "theorem finRotate_of_lt {k : \u2115} (h : k < n) :\n    finRotate (n + 1) \u27e8k, h.trans_le n.le_succ\u27e9 = \u27e8k + 1, Nat.succ_lt_succ h\u27e9", "start": [396, 1], "end": [400, 46], "kind": "commanddeclaration"}, {"full_name": "finRotate_last'", "code": "theorem finRotate_last' : finRotate (n + 1) \u27e8n, lt_add_one _\u27e9 = \u27e80, Nat.zero_lt_succ _\u27e9", "start": [403, 1], "end": [406, 7], "kind": "commanddeclaration"}, {"full_name": "finRotate_last", "code": "theorem finRotate_last : finRotate (n + 1) (Fin.last _) = 0", "start": [409, 1], "end": [410, 18], "kind": "commanddeclaration"}, {"full_name": "Fin.snoc_eq_cons_rotate", "code": "theorem Fin.snoc_eq_cons_rotate {\u03b1 : Type*} (v : Fin n \u2192 \u03b1) (a : \u03b1) :\n    @Fin.snoc _ (fun _ => \u03b1) v a = fun i => @Fin.cons _ (fun _ => \u03b1) a v (finRotate _ i)", "start": [413, 1], "end": [424, 8], "kind": "commanddeclaration"}, {"full_name": "finRotate_one", "code": "@[simp]\ntheorem finRotate_one : finRotate 1 = Equiv.refl _", "start": [427, 1], "end": [429, 24], "kind": "commanddeclaration"}, {"full_name": "finRotate_succ_apply", "code": "@[simp] theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1", "start": [432, 1], "end": [439, 97], "kind": "commanddeclaration"}, {"full_name": "finRotate_apply_zero", "code": "theorem finRotate_apply_zero : finRotate n.succ 0 = 1", "start": [443, 1], "end": [444, 38], "kind": "commanddeclaration"}, {"full_name": "coe_finRotate_of_ne_last", "code": "theorem coe_finRotate_of_ne_last {i : Fin n.succ} (h : i \u2260 Fin.last n) :\n    (finRotate (n + 1) i : \u2115) = i + 1", "start": [447, 1], "end": [451, 35], "kind": "commanddeclaration"}, {"full_name": "coe_finRotate", "code": "theorem coe_finRotate (i : Fin n.succ) :\n    (finRotate n.succ i : \u2115) = if i = Fin.last n then (0 : \u2115) else i + 1", "start": [454, 1], "end": [456, 47], "kind": "commanddeclaration"}, {"full_name": "finProdFinEquiv", "code": "@[simps]\ndef finProdFinEquiv : Fin m \u00d7 Fin n \u2243 Fin (m * n)\n    where\n  toFun x :=\n    \u27e8x.2 + n * x.1,\n      calc\n        x.2.1 + n * x.1.1 + 1 = x.1.1 * n + x.2.1 + 1 := by ac_rfl\n        _ \u2264 x.1.1 * n + n := Nat.add_le_add_left x.2.2 _\n        _ = (x.1.1 + 1) * n := Eq.symm <| Nat.succ_mul _ _\n        _ \u2264 m * n := Nat.mul_le_mul_right _ x.1.2\n        \u27e9\n  invFun x := (x.divNat, x.modNat)\n  left_inv := fun \u27e8x, y\u27e9 =>\n    have H : 0 < n := Nat.pos_of_ne_zero fun H => Nat.not_lt_zero y.1 <| H \u25b8 y.2\n    Prod.ext\n      (Fin.eq_of_veq <|\n        calc\n          (y.1 + n * x.1) / n = y.1 / n + x.1 := Nat.add_mul_div_left _ _ H\n          _ = 0 + x.1 := by rw [Nat.div_eq_of_lt y.2]\n          _ = x.1 := Nat.zero_add x.1\n          )\n      (Fin.eq_of_veq <|\n        calc\n          (y.1 + n * x.1) % n = y.1 % n := Nat.add_mul_mod_self_left _ _ _\n          _ = y.1 := Nat.mod_eq_of_lt y.2\n          )\n  right_inv x := Fin.eq_of_veq <| Nat.mod_add_div _ _", "start": [459, 1], "end": [486, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.divModEquiv", "code": "@[simps]\ndef Nat.divModEquiv (n : \u2115) [NeZero n] : \u2115 \u2243 \u2115 \u00d7 Fin n where\n  toFun a := (a / n, \u2191a)\n  invFun p := p.1 * n + \u2191p.2\n  left_inv a := Nat.div_add_mod' _ _\n  right_inv p := by\n    refine' Prod.ext _ (Fin.ext <| Nat.mul_add_mod_of_lt p.2.is_lt)\n    dsimp only\n    rw [add_comm, Nat.add_mul_div_right _ _ (NeZero.pos n), Nat.div_eq_of_lt p.2.is_lt, zero_add]", "start": [491, 1], "end": [503, 98], "kind": "commanddeclaration"}, {"full_name": "Int.divModEquiv", "code": "@[simps]\ndef Int.divModEquiv (n : \u2115) [NeZero n] : \u2124 \u2243 \u2124 \u00d7 Fin n where\n  toFun a := (a / n, \u2191(a.natMod n))\n  invFun p := p.1 * n + \u2191p.2\n  left_inv a := by\n    simp_rw [Fin.coe_ofNat_eq_mod, Int.coe_nat_mod, Int.natMod,\n      Int.toNat_of_nonneg (Int.emod_nonneg _ <| NeZero.ne \u2191n), Int.emod_emod,\n      Int.ediv_add_emod']\n  right_inv := fun \u27e8q, r, hrn\u27e9 => by\n    simp only [Fin.val_mk, Prod.mk.inj_iff, Fin.ext_iff]\n    obtain \u27e8h1, h2\u27e9 := Int.coe_nat_nonneg r, Int.ofNat_lt.2 hrn\n    rw [add_comm, Int.add_mul_ediv_right _ _ (NeZero.ne \u2191n), Int.ediv_eq_zero_of_lt h1 h2,\n      Int.natMod, Int.add_mul_emod_self, Int.emod_eq_of_lt h1 h2, Int.toNat_coe_nat]\n    exact \u27e8zero_add q, Fin.val_cast_of_lt hrn\u27e9", "start": [506, 1], "end": [523, 47], "kind": "commanddeclaration"}, {"full_name": "Fin.castLEOrderIso", "code": "@[simps apply symm_apply]\ndef Fin.castLEOrderIso {n m : \u2115} (h : n \u2264 m) : Fin n \u2243o { i : Fin m // (i : \u2115) < n }\n    where\n  toFun i := \u27e8Fin.castLE h i, by simp\u27e9\n  invFun i := \u27e8i, i.prop\u27e9\n  left_inv _ := by simp\n  right_inv _ := by simp\n  map_rel_iff' := by simp [(strictMono_castLE h).le_iff_le]", "start": [526, 1], "end": [535, 60], "kind": "commanddeclaration"}, {"full_name": "subsingleton_fin_zero", "code": "instance subsingleton_fin_zero : Subsingleton (Fin 0) :=\n  finZeroEquiv.subsingleton", "start": [540, 1], "end": [542, 28], "kind": "commanddeclaration"}, {"full_name": "subsingleton_fin_one", "code": "instance subsingleton_fin_one : Subsingleton (Fin 1) :=\n  finOneEquiv.subsingleton", "start": [545, 1], "end": [547, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/BigOperators/Lemmas.lean", "imports": ["Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Init/CCLemmas.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/Algebra/Ring/Commute.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Data/List/BigOperators/Basic.lean", "Mathlib/Algebra/GroupWithZero/Commute.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/Data/Int/Units.lean"], "premises": [{"full_name": "Commute.list_sum_right", "code": "theorem list_sum_right [NonUnitalNonAssocSemiring R] (a : R) (l : List R)\n    (h : \u2200 b \u2208 l, Commute a b) : Commute a l.sum", "start": [30, 1], "end": [35, 92], "kind": "commanddeclaration"}, {"full_name": "Commute.list_sum_left", "code": "theorem list_sum_left [NonUnitalNonAssocSemiring R] (b : R) (l : List R)\n    (h : \u2200 a \u2208 l, Commute a b) : Commute l.sum b", "start": [38, 1], "end": [40, 65], "kind": "commanddeclaration"}, {"full_name": "List.pow_card_le_prod", "code": "@[to_additive card_nsmul_le_sum]\ntheorem pow_card_le_prod [Monoid M] [Preorder M]\n    [CovariantClass M M (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] [CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    (l : List M) (n : M) (h : \u2200 x \u2208 l, n \u2264 x) : n ^ l.length \u2264 l.prod", "start": [47, 1], "end": [51, 38], "kind": "commanddeclaration"}, {"full_name": "List.prod_eq_one_iff", "code": "@[to_additive]\ntheorem prod_eq_one_iff [CanonicallyOrderedCommMonoid M] (l : List M) :\n    l.prod = 1 \u2194 \u2200 x \u2208 l, x = (1 : M)", "start": [55, 1], "end": [59, 85], "kind": "commanddeclaration"}, {"full_name": "List.neg_one_mem_of_prod_eq_neg_one", "code": "theorem neg_one_mem_of_prod_eq_neg_one {l : List \u2124} (h : l.prod = -1) : (-1 : \u2124) \u2208 l", "start": [63, 1], "end": [71, 9], "kind": "commanddeclaration"}, {"full_name": "List.length_le_sum_of_one_le", "code": "theorem length_le_sum_of_one_le (L : List \u2115) (h : \u2200 i \u2208 L, 1 \u2264 i) : L.length \u2264 L.sum", "start": [74, 1], "end": [79, 91], "kind": "commanddeclaration"}, {"full_name": "List.dvd_prod", "code": "theorem dvd_prod [CommMonoid M] {a} {l : List M} (ha : a \u2208 l) : a \u2223 l.prod", "start": [82, 1], "end": [85, 26], "kind": "commanddeclaration"}, {"full_name": "List.dvd_sum", "code": "theorem dvd_sum [NonUnitalSemiring R] {a} {l : List R} (h : \u2200 x \u2208 l, a \u2223 x) : a \u2223 l.sum", "start": [88, 1], "end": [92, 88], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_append", "code": "@[to_additive]\ntheorem alternatingProd_append :\n    \u2200 l\u2081 l\u2082 : List \u03b1,\n      alternatingProd (l\u2081 ++ l\u2082) = alternatingProd l\u2081 * alternatingProd l\u2082 ^ (-1 : \u2124) ^ length l\u2081", "start": [99, 1], "end": [106, 61], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_reverse", "code": "@[to_additive]\ntheorem alternatingProd_reverse :\n    \u2200 l : List \u03b1, alternatingProd (reverse l) = alternatingProd l ^ (-1 : \u2124) ^ (length l + 1)", "start": [110, 1], "end": [118, 46], "kind": "commanddeclaration"}, {"full_name": "List.sum_map_mul_left", "code": "theorem sum_map_mul_left [NonUnitalNonAssocSemiring R] (L : List \u03b9) (f : \u03b9 \u2192 R) (r : R) :\n    (L.map fun b => r * f b).sum = r * (L.map f).sum", "start": [124, 1], "end": [126, 44], "kind": "commanddeclaration"}, {"full_name": "List.sum_map_mul_right", "code": "theorem sum_map_mul_right [NonUnitalNonAssocSemiring R] (L : List \u03b9) (f : \u03b9 \u2192 R) (r : R) :\n    (L.map fun b => f b * r).sum = (L.map f).sum * r", "start": [129, 1], "end": [131, 45], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_list_prod", "code": "theorem op_list_prod : \u2200 l : List M, op l.prod = (l.map op).reverse.prod", "start": [142, 1], "end": [146, 89], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_list_prod", "code": "theorem unop_list_prod (l : List M\u1d50\u1d52\u1d56) : l.prod.unop = (l.map unop).reverse.prod", "start": [149, 1], "end": [151, 26], "kind": "commanddeclaration"}, {"full_name": "unop_map_list_prod", "code": "theorem unop_map_list_prod {F : Type*} [MonoidHomClass F M N\u1d50\u1d52\u1d56] (f : F) (l : List M) :\n    (f l.prod).unop = (l.map (MulOpposite.unop \u2218 f)).reverse.prod", "start": [160, 1], "end": [163, 67], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.unop_map_list_prod", "code": "@[deprecated _root_.unop_map_list_prod]\nprotected theorem unop_map_list_prod (f : M \u2192* N\u1d50\u1d52\u1d56) (l : List M) :\n    (f l.prod).unop = (l.map (MulOpposite.unop \u2218 f)).reverse.prod", "start": [168, 1], "end": [172, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "imports": ["Mathlib/Data/Set/Intervals/Image.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Order/Bounds/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.uIcc", "code": "def uIcc (a b : \u03b1) : Set \u03b1 := Icc (a \u2293 b) (a \u2294 b)", "start": [51, 1], "end": [54, 50], "kind": "commanddeclaration"}, {"full_name": "Set.dual_uIcc", "code": "@[simp] lemma dual_uIcc (a b : \u03b1) : [[toDual a, toDual b]] = ofDual \u207b\u00b9' [[a, b]] := dual_Icc", "start": [65, 1], "end": [65, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_of_le", "code": "@[simp]\nlemma uIcc_of_le (h : a \u2264 b) : [[a, b]] = Icc a b := by rw [uIcc, inf_eq_left.2 h, sup_eq_right.2 h]", "start": [68, 1], "end": [69, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_of_ge", "code": "@[simp]\nlemma uIcc_of_ge (h : b \u2264 a) : [[a, b]] = Icc b a := by rw [uIcc, inf_eq_right.2 h, sup_eq_left.2 h]", "start": [72, 1], "end": [73, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_comm", "code": "lemma uIcc_comm (a b : \u03b1) : [[a, b]] = [[b, a]] := by simp_rw [uIcc, inf_comm, sup_comm]", "start": [76, 1], "end": [76, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_of_lt", "code": "lemma uIcc_of_lt (h : a < b) : [[a, b]] = Icc a b := uIcc_of_le h.le", "start": [79, 1], "end": [79, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_of_gt", "code": "lemma uIcc_of_gt (h : b < a) : [[a, b]] = Icc b a := uIcc_of_ge h.le", "start": [81, 1], "end": [81, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_self", "code": "lemma uIcc_self : [[a, a]] = {a} := by simp [uIcc]", "start": [86, 1], "end": [86, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Set.nonempty_uIcc", "code": "@[simp] lemma nonempty_uIcc : [[a, b]].Nonempty := nonempty_Icc.2 inf_le_sup", "start": [89, 1], "end": [89, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc_subset_uIcc", "code": "lemma Icc_subset_uIcc : Icc a b \u2286 [[a, b]] := Icc_subset_Icc inf_le_left le_sup_right", "start": [92, 1], "end": [92, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc_subset_uIcc'", "code": "lemma Icc_subset_uIcc' : Icc b a \u2286 [[a, b]] := Icc_subset_Icc inf_le_right le_sup_left", "start": [94, 1], "end": [94, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Set.left_mem_uIcc", "code": "@[simp] lemma left_mem_uIcc : a \u2208 [[a, b]] := \u27e8inf_le_left, le_sup_left\u27e9", "start": [97, 1], "end": [97, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Set.right_mem_uIcc", "code": "@[simp] lemma right_mem_uIcc : b \u2208 [[a, b]] := \u27e8inf_le_right, le_sup_right\u27e9", "start": [99, 1], "end": [99, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mem_uIcc_of_le", "code": "lemma mem_uIcc_of_le (ha : a \u2264 x) (hb : x \u2264 b) : x \u2208 [[a, b]] := Icc_subset_uIcc \u27e8ha, hb\u27e9", "start": [102, 1], "end": [102, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mem_uIcc_of_ge", "code": "lemma mem_uIcc_of_ge (hb : b \u2264 x) (ha : x \u2264 a) : x \u2208 [[a, b]] := Icc_subset_uIcc' \u27e8hb, ha\u27e9", "start": [104, 1], "end": [104, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc", "code": "lemma uIcc_subset_uIcc (h\u2081 : a\u2081 \u2208 [[a\u2082, b\u2082]]) (h\u2082 : b\u2081 \u2208 [[a\u2082, b\u2082]]) :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] :=\n  Icc_subset_Icc (le_inf h\u2081.1 h\u2082.1) (sup_le h\u2081.2 h\u2082.2)", "start": [107, 1], "end": [109, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_Icc", "code": "lemma uIcc_subset_Icc (ha : a\u2081 \u2208 Icc a\u2082 b\u2082) (hb : b\u2081 \u2208 Icc a\u2082 b\u2082) :\n    [[a\u2081, b\u2081]] \u2286 Icc a\u2082 b\u2082 :=\n  Icc_subset_Icc (le_inf ha.1 hb.1) (sup_le ha.2 hb.2)", "start": [112, 1], "end": [114, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_iff_mem", "code": "lemma uIcc_subset_uIcc_iff_mem :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 a\u2081 \u2208 [[a\u2082, b\u2082]] \u2227 b\u2081 \u2208 [[a\u2082, b\u2082]] :=\n  Iff.intro (fun h => \u27e8h left_mem_uIcc, h right_mem_uIcc\u27e9) fun h =>\n    uIcc_subset_uIcc h.1 h.2", "start": [117, 1], "end": [120, 29], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_iff_le'", "code": "lemma uIcc_subset_uIcc_iff_le' :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 a\u2082 \u2293 b\u2082 \u2264 a\u2081 \u2293 b\u2081 \u2227 a\u2081 \u2294 b\u2081 \u2264 a\u2082 \u2294 b\u2082 :=\n  Icc_subset_Icc_iff inf_le_sup", "start": [123, 1], "end": [125, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_right", "code": "lemma uIcc_subset_uIcc_right (h : x \u2208 [[a, b]]) : [[x, b]] \u2286 [[a, b]] :=\n  uIcc_subset_uIcc h right_mem_uIcc", "start": [128, 1], "end": [129, 36], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_left", "code": "lemma uIcc_subset_uIcc_left (h : x \u2208 [[a, b]]) : [[a, x]] \u2286 [[a, b]] :=\n  uIcc_subset_uIcc left_mem_uIcc h", "start": [132, 1], "end": [133, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Set.bdd_below_bdd_above_iff_subset_uIcc", "code": "lemma bdd_below_bdd_above_iff_subset_uIcc (s : Set \u03b1) :\n    BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 [[a, b]] :=\n  bddBelow_bddAbove_iff_subset_Icc.trans\n    \u27e8fun \u27e8a, b, h\u27e9 => \u27e8a, b, fun _ hx => Icc_subset_uIcc (h hx)\u27e9, fun \u27e8_, _, h\u27e9 => \u27e8_, _, h\u27e9\u27e9", "start": [136, 1], "end": [139, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_prod_uIcc", "code": "@[simp]\ntheorem uIcc_prod_uIcc (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) :\n    [[a\u2081, a\u2082]] \u00d7\u02e2 [[b\u2081, b\u2082]] = [[(a\u2081, b\u2081), (a\u2082, b\u2082)]]", "start": [144, 1], "end": [147, 23], "kind": "commanddeclaration"}, {"full_name": "Set.uIcc_prod_eq", "code": "theorem uIcc_prod_eq (a b : \u03b1 \u00d7 \u03b2) : [[a, b]] = [[a.1, b.1]] \u00d7\u02e2 [[a.2, b.2]]", "start": [150, 1], "end": [150, 88], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_mem_uIcc_of_mem_uIcc", "code": "lemma eq_of_mem_uIcc_of_mem_uIcc (ha : a \u2208 [[b, c]]) (hb : b \u2208 [[a, c]]) : a = b :=\n  eq_of_inf_eq_sup_eq (inf_congr_right ha.1 hb.1) <| sup_congr_right ha.2 hb.2", "start": [163, 1], "end": [164, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Set.eq_of_mem_uIcc_of_mem_uIcc'", "code": "lemma eq_of_mem_uIcc_of_mem_uIcc' : b \u2208 [[a, c]] \u2192 c \u2208 [[a, b]] \u2192 b = c := by\n  simpa only [uIcc_comm a] using eq_of_mem_uIcc_of_mem_uIcc", "start": [167, 1], "end": [168, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_injective_right", "code": "lemma uIcc_injective_right (a : \u03b1) : Injective fun b => uIcc b a := fun b c h => by\n  rw [ext_iff] at h\n  exact eq_of_mem_uIcc_of_mem_uIcc ((h _).1 left_mem_uIcc) ((h _).2 left_mem_uIcc)", "start": [171, 1], "end": [173, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_injective_left", "code": "lemma uIcc_injective_left (a : \u03b1) : Injective (uIcc a) := by\n  simpa only [uIcc_comm] using uIcc_injective_right a", "start": [176, 1], "end": [177, 54], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.mapsTo_uIcc", "code": "lemma _root_.MonotoneOn.mapsTo_uIcc (hf : MonotoneOn f (uIcc a b)) :\n    MapsTo f (uIcc a b) (uIcc (f a) (f b)) := by\n  rw [uIcc, uIcc, \u2190hf.map_sup, \u2190hf.map_inf] <;>\n    apply_rules [left_mem_uIcc, right_mem_uIcc, hf.mapsTo_Icc]", "start": [188, 1], "end": [191, 63], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.mapsTo_uIcc", "code": "lemma _root_.AntitoneOn.mapsTo_uIcc (hf : AntitoneOn f (uIcc a b)) :\n    MapsTo f (uIcc a b) (uIcc (f a) (f b)) := by\n  rw [uIcc, uIcc, \u2190hf.map_sup, \u2190hf.map_inf] <;>\n    apply_rules [left_mem_uIcc, right_mem_uIcc, hf.mapsTo_Icc]", "start": [193, 1], "end": [196, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.mapsTo_uIcc", "code": "lemma _root_.Monotone.mapsTo_uIcc (hf : Monotone f) : MapsTo f (uIcc a b) (uIcc (f a) (f b)) :=\n  (hf.monotoneOn _).mapsTo_uIcc", "start": [198, 1], "end": [199, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.mapsTo_uIcc", "code": "lemma _root_.Antitone.mapsTo_uIcc (hf : Antitone f) : MapsTo f (uIcc a b) (uIcc (f a) (f b)) :=\n  (hf.antitoneOn _).mapsTo_uIcc", "start": [201, 1], "end": [202, 32], "kind": "mathlibtacticlemma"}, {"full_name": "MonotoneOn.image_uIcc_subset", "code": "lemma _root_.MonotoneOn.image_uIcc_subset (hf : MonotoneOn f (uIcc a b)) :\n    f '' uIcc a b \u2286 uIcc (f a) (f b) := hf.mapsTo_uIcc.image_subset", "start": [204, 1], "end": [205, 68], "kind": "mathlibtacticlemma"}, {"full_name": "AntitoneOn.image_uIcc_subset", "code": "lemma _root_.AntitoneOn.image_uIcc_subset (hf : AntitoneOn f (uIcc a b)) :\n    f '' uIcc a b \u2286 uIcc (f a) (f b) := hf.mapsTo_uIcc.image_subset", "start": [207, 1], "end": [208, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Monotone.image_uIcc_subset", "code": "lemma _root_.Monotone.image_uIcc_subset (hf : Monotone f) : f '' uIcc a b \u2286 uIcc (f a) (f b) :=\n  (hf.monotoneOn _).image_uIcc_subset", "start": [210, 1], "end": [211, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Antitone.image_uIcc_subset", "code": "lemma _root_.Antitone.image_uIcc_subset (hf : Antitone f) : f '' uIcc a b \u2286 uIcc (f a) (f b) :=\n  (hf.antitoneOn _).image_uIcc_subset", "start": [213, 1], "end": [214, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc_min_max", "code": "theorem Icc_min_max : Icc (min a b) (max a b) = [[a, b]]", "start": [220, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "Set.uIcc_of_not_le", "code": "lemma uIcc_of_not_le (h : \u00aca \u2264 b) : [[a, b]] = Icc b a := uIcc_of_gt $ lt_of_not_ge h", "start": [224, 1], "end": [224, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_of_not_ge", "code": "lemma uIcc_of_not_ge (h : \u00acb \u2264 a) : [[a, b]] = Icc a b := uIcc_of_lt $ lt_of_not_ge h", "start": [226, 1], "end": [226, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_eq_union", "code": "lemma uIcc_eq_union : [[a, b]] = Icc a b \u222a Icc b a := by rw [Icc_union_Icc', max_comm] <;> rfl", "start": [229, 1], "end": [229, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mem_uIcc", "code": "lemma mem_uIcc : a \u2208 [[b, c]] \u2194 b \u2264 a \u2227 a \u2264 c \u2228 c \u2264 a \u2227 a \u2264 b := by simp [uIcc_eq_union]", "start": [232, 1], "end": [232, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Set.not_mem_uIcc_of_lt", "code": "lemma not_mem_uIcc_of_lt (ha : c < a) (hb : c < b) : c \u2209 [[a, b]] :=\n  not_mem_Icc_of_lt <| lt_min_iff.mpr \u27e8ha, hb\u27e9", "start": [235, 1], "end": [236, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Set.not_mem_uIcc_of_gt", "code": "lemma not_mem_uIcc_of_gt (ha : a < c) (hb : b < c) : c \u2209 [[a, b]] :=\n  not_mem_Icc_of_gt <| max_lt_iff.mpr \u27e8ha, hb\u27e9", "start": [239, 1], "end": [240, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_iff_le", "code": "lemma uIcc_subset_uIcc_iff_le :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 min a\u2082 b\u2082 \u2264 min a\u2081 b\u2081 \u2227 max a\u2081 b\u2081 \u2264 max a\u2082 b\u2082 :=\n  uIcc_subset_uIcc_iff_le'", "start": [243, 1], "end": [245, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIcc_subset_uIcc_union_uIcc", "code": "lemma uIcc_subset_uIcc_union_uIcc : [[a, c]] \u2286 [[a, b]] \u222a [[b, c]] := fun x => by\n  simp only [mem_uIcc, mem_union]\n  cases' le_total a c with h1 h1 <;>\n  cases' le_total x b with h2 h2 <;>\n  tauto", "start": [248, 1], "end": [253, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Set.monotone_or_antitone_iff_uIcc", "code": "lemma monotone_or_antitone_iff_uIcc :\n    Monotone f \u2228 Antitone f \u2194 \u2200 a b c, c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]] := by\n  constructor\n  \u00b7 rintro (hf | hf) a b c <;> simp_rw [\u2190 Icc_min_max, \u2190 hf.map_min, \u2190 hf.map_max]\n    exacts [fun hc => \u27e8hf hc.1, hf hc.2\u27e9, fun hc => \u27e8hf hc.2, hf hc.1\u27e9]\n  contrapose!\n  rw [not_monotone_not_antitone_iff_exists_le_le]\n  rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9\n  \u00b7 exact \u27e8a, c, b, Icc_subset_uIcc \u27e8hab, hbc\u27e9, fun h => h.2.not_lt <| max_lt hfab hfcb\u27e9\n  \u00b7 exact \u27e8a, c, b, Icc_subset_uIcc \u27e8hab, hbc\u27e9, fun h => h.1.not_lt <| lt_min hfba hfbc\u27e9", "start": [256, 1], "end": [265, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Set.monotoneOn_or_antitoneOn_iff_uIcc", "code": "lemma monotoneOn_or_antitoneOn_iff_uIcc :\n    MonotoneOn f s \u2228 AntitoneOn f s \u2194\n      \u2200 (a) (_ : a \u2208 s) (b) (_ : b \u2208 s) (c) (_ : c \u2208 s), c \u2208 [[a, b]] \u2192 f c \u2208 [[f a, f b]] :=\n  by simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, monotone_or_antitone_iff_uIcc,\n    mem_uIcc]", "start": [269, 1], "end": [273, 14], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc", "code": "def uIoc : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1 := fun a b => Ioc (min a b) (max a b)", "start": [278, 1], "end": [279, 63], "kind": "commanddeclaration"}, {"full_name": "Set.uIoc_of_le", "code": "@[simp] lemma uIoc_of_le (h : a \u2264 b) : \u0399 a b = Ioc a b := by simp [uIoc, h]", "start": [288, 1], "end": [288, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_of_lt", "code": "@[simp] lemma uIoc_of_lt (h : b < a) : \u0399 a b = Ioc b a := by simp [uIoc, le_of_lt h]", "start": [290, 1], "end": [290, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_eq_union", "code": "lemma uIoc_eq_union : \u0399 a b = Ioc a b \u222a Ioc b a := by\n  cases le_total a b <;> simp [uIoc, *]", "start": [293, 1], "end": [294, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mem_uIoc", "code": "lemma mem_uIoc : a \u2208 \u0399 b c \u2194 b < a \u2227 a \u2264 c \u2228 c < a \u2227 a \u2264 b := by\n  rw [uIoc_eq_union, mem_union, mem_Ioc, mem_Ioc]", "start": [297, 1], "end": [298, 50], "kind": "mathlibtacticlemma"}, {"full_name": "Set.not_mem_uIoc", "code": "lemma not_mem_uIoc : a \u2209 \u0399 b c \u2194 a \u2264 b \u2227 a \u2264 c \u2228 c < a \u2227 b < a := by\n  simp only [uIoc_eq_union, mem_union, mem_Ioc, not_lt, \u2190 not_le]\n  tauto", "start": [301, 1], "end": [303, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Set.left_mem_uIoc", "code": "@[simp] lemma left_mem_uIoc : a \u2208 \u0399 a b \u2194 b < a := by simp [mem_uIoc]", "start": [306, 1], "end": [306, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Set.right_mem_uIoc", "code": "@[simp] lemma right_mem_uIoc : b \u2208 \u0399 a b \u2194 a < b := by simp [mem_uIoc]", "start": [308, 1], "end": [308, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Set.forall_uIoc_iff", "code": "lemma forall_uIoc_iff {P : \u03b1 \u2192 Prop} :\n    (\u2200 x \u2208 \u0399 a b, P x) \u2194 (\u2200 x \u2208 Ioc a b, P x) \u2227 \u2200 x \u2208 Ioc b a, P x := by\n  simp only [uIoc_eq_union, mem_union, or_imp, forall_and]", "start": [311, 1], "end": [313, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_subset_uIoc_of_uIcc_subset_uIcc", "code": "lemma uIoc_subset_uIoc_of_uIcc_subset_uIcc {a b c d : \u03b1}\n    (h : [[a, b]] \u2286 [[c, d]]) : \u0399 a b \u2286 \u0399 c d :=\n  Ioc_subset_Ioc (uIcc_subset_uIcc_iff_le.1 h).1 (uIcc_subset_uIcc_iff_le.1 h).2", "start": [316, 1], "end": [318, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_comm", "code": "lemma uIoc_comm (a b : \u03b1) : \u0399 a b = \u0399 b a := by simp only [uIoc, min_comm a b, max_comm a b]", "start": [321, 1], "end": [321, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Ioc_subset_uIoc", "code": "lemma Ioc_subset_uIoc : Ioc a b \u2286 \u0399 a b := Ioc_subset_Ioc (min_le_left _ _) (le_max_right _ _)", "start": [324, 1], "end": [324, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Ioc_subset_uIoc'", "code": "lemma Ioc_subset_uIoc' : Ioc a b \u2286 \u0399 b a := Ioc_subset_Ioc (min_le_right _ _) (le_max_left _ _)", "start": [326, 1], "end": [326, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Set.eq_of_mem_uIoc_of_mem_uIoc", "code": "lemma eq_of_mem_uIoc_of_mem_uIoc : a \u2208 \u0399 b c \u2192 b \u2208 \u0399 a c \u2192 a = b := by\n  simp_rw [mem_uIoc]; rintro (\u27e8_, _\u27e9 | \u27e8_, _\u27e9) (\u27e8_, _\u27e9 | \u27e8_, _\u27e9) <;> apply le_antisymm <;>\n    first |assumption|exact le_of_lt \u2039_\u203a|exact le_trans \u2039_\u203a (le_of_lt \u2039_\u203a)", "start": [329, 1], "end": [331, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Set.eq_of_mem_uIoc_of_mem_uIoc'", "code": "lemma eq_of_mem_uIoc_of_mem_uIoc' : b \u2208 \u0399 a c \u2192 c \u2208 \u0399 a b \u2192 b = c := by\n  simpa only [uIoc_comm a] using eq_of_mem_uIoc_of_mem_uIoc", "start": [334, 1], "end": [335, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Set.eq_of_not_mem_uIoc_of_not_mem_uIoc", "code": "lemma eq_of_not_mem_uIoc_of_not_mem_uIoc (ha : a \u2264 c) (hb : b \u2264 c) :\n    a \u2209 \u0399 b c \u2192 b \u2209 \u0399 a c \u2192 a = b := by\n  simp_rw [not_mem_uIoc]\n  rintro (\u27e8_, _\u27e9 | \u27e8_, _\u27e9) (\u27e8_, _\u27e9 | \u27e8_, _\u27e9) <;>\n      apply le_antisymm <;>\n    first |assumption|exact le_of_lt \u2039_\u203a|\n    exact absurd hb (not_le_of_lt \u2039c < b\u203a)|exact absurd ha (not_le_of_lt \u2039c < a\u203a)", "start": [338, 1], "end": [344, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_injective_right", "code": "lemma uIoc_injective_right (a : \u03b1) : Injective fun b => \u0399 b a := by\n  rintro b c h\n  rw [ext_iff] at h\n  obtain ha | ha := le_or_lt b a\n  \u00b7 have hb := (h b).not\n    simp only [ha, left_mem_uIoc, not_lt, true_iff_iff, not_mem_uIoc, \u2190 not_le,\n      and_true_iff, not_true, false_and_iff, not_false_iff, true_iff_iff, or_false_iff] at hb\n    refine' hb.eq_of_not_lt fun hc => _\n    simpa [ha, and_iff_right hc, \u2190 @not_le _ _ _ a, iff_not_self, -not_le] using h c\n  \u00b7 refine'\n      eq_of_mem_uIoc_of_mem_uIoc ((h _).1 <| left_mem_uIoc.2 ha)\n        ((h _).2 <| left_mem_uIoc.2 <| ha.trans_le _)\n    simpa [ha, ha.not_le, mem_uIoc] using h b", "start": [347, 1], "end": [359, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Set.uIoc_injective_left", "code": "lemma uIoc_injective_left (a : \u03b1) : Injective (\u0399 a) := by\n  simpa only [uIoc_comm] using uIoc_injective_right a", "start": [362, 1], "end": [363, 54], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Order/Antichain.lean", "imports": ["Mathlib/Order/Bounds/Basic.lean", "Mathlib/Order/Directed.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "Mathlib/Order/Hom/Set.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Symmetric.compl", "code": "protected theorem Symmetric.compl (h : Symmetric r) : Symmetric r\u1d9c", "start": [35, 1], "end": [36, 14], "kind": "commanddeclaration"}, {"full_name": "IsAntichain", "code": "def IsAntichain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop :=\n  s.Pairwise r\u1d9c", "start": [39, 1], "end": [41, 16], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.subset", "code": "protected theorem subset (hs : IsAntichain r s) (h : t \u2286 s) : IsAntichain r t", "start": [46, 1], "end": [47, 12], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.mono", "code": "theorem mono (hs : IsAntichain r\u2081 s) (h : r\u2082 \u2264 r\u2081) : IsAntichain r\u2082 s", "start": [50, 1], "end": [51, 31], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.mono_on", "code": "theorem mono_on (hs : IsAntichain r\u2081 s) (h : s.Pairwise fun \u2983a b\u2984 => r\u2082 a b \u2192 r\u2081 a b) :\n    IsAntichain r\u2082 s", "start": [54, 1], "end": [56, 51], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.eq", "code": "protected theorem eq (hs : IsAntichain r s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (h : r a b) :\n    a = b", "start": [59, 1], "end": [61, 46], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.eq'", "code": "protected theorem eq' (hs : IsAntichain r s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (h : r b a) :\n    a = b", "start": [64, 1], "end": [66, 23], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.isAntisymm", "code": "protected theorem isAntisymm (h : IsAntichain r univ) : IsAntisymm \u03b1 r", "start": [69, 1], "end": [70, 44], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.subsingleton", "code": "protected theorem subsingleton [IsTrichotomous \u03b1 r] (h : IsAntichain r s) : s.Subsingleton", "start": [73, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.flip", "code": "protected theorem flip (hs : IsAntichain r s) : IsAntichain (flip r) s", "start": [81, 1], "end": [82, 18], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.swap", "code": "theorem swap (hs : IsAntichain r s) : IsAntichain (swap r) s", "start": [85, 1], "end": [86, 10], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image", "code": "theorem image (hs : IsAntichain r s) (f : \u03b1 \u2192 \u03b2) (h : \u2200 \u2983a b\u2984, r' (f a) (f b) \u2192 r a b) :\n    IsAntichain r' (f '' s)", "start": [89, 1], "end": [92, 47], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage", "code": "theorem preimage (hs : IsAntichain r s) {f : \u03b2 \u2192 \u03b1} (hf : Injective f)\n    (h : \u2200 \u2983a b\u2984, r' a b \u2192 r (f a) (f b)) : IsAntichain r' (f \u207b\u00b9' s)", "start": [95, 1], "end": [97, 31], "kind": "commanddeclaration"}, {"full_name": "isAntichain_insert", "code": "theorem _root_.isAntichain_insert :\n    IsAntichain r (insert a s) \u2194 IsAntichain r s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b \u2227 \u00acr b a", "start": [100, 1], "end": [102, 22], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.insert", "code": "protected theorem insert (hs : IsAntichain r s) (hl : \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr b a)\n    (hr : \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b) : IsAntichain r (insert a s)", "start": [105, 1], "end": [107, 68], "kind": "commanddeclaration"}, {"full_name": "isAntichain_insert_of_symmetric", "code": "theorem _root_.isAntichain_insert_of_symmetric (hr : Symmetric r) :\n    IsAntichain r (insert a s) \u2194 IsAntichain r s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b", "start": [110, 1], "end": [112, 40], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.insert_of_symmetric", "code": "theorem insert_of_symmetric (hs : IsAntichain r s) (hr : Symmetric r)\n    (h : \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b) : IsAntichain r (insert a s)", "start": [115, 1], "end": [117, 49], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_relEmbedding", "code": "theorem image_relEmbedding (hs : IsAntichain r s) (\u03c6 : r \u21aar r') : IsAntichain r' (\u03c6 '' s)", "start": [120, 1], "end": [124, 74], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_relEmbedding", "code": "theorem preimage_relEmbedding {t : Set \u03b2} (ht : IsAntichain r' t) (\u03c6 : r \u21aar r') :\n    IsAntichain r (\u03c6 \u207b\u00b9' t)", "start": [127, 1], "end": [129, 67], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_relIso", "code": "theorem image_relIso (hs : IsAntichain r s) (\u03c6 : r \u2243r r') : IsAntichain r' (\u03c6 '' s)", "start": [132, 1], "end": [133, 26], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_relIso", "code": "theorem preimage_relIso {t : Set \u03b2} (hs : IsAntichain r' t) (\u03c6 : r \u2243r r') :\n    IsAntichain r (\u03c6 \u207b\u00b9' t)", "start": [136, 1], "end": [138, 29], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_relEmbedding_iff", "code": "theorem image_relEmbedding_iff {\u03c6 : r \u21aar r'} : IsAntichain r' (\u03c6 '' s) \u2194 IsAntichain r s", "start": [141, 1], "end": [143, 28], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_relIso_iff", "code": "theorem image_relIso_iff {\u03c6 : r \u2243r r'} : IsAntichain r' (\u03c6 '' s) \u2194 IsAntichain r s", "start": [146, 1], "end": [147, 50], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_embedding", "code": "theorem image_embedding [LE \u03b1] [LE \u03b2] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) (\u03c6 : \u03b1 \u21aao \u03b2) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s)", "start": [150, 1], "end": [152, 26], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_embedding", "code": "theorem preimage_embedding [LE \u03b1] [LE \u03b2] {t : Set \u03b2} (ht : IsAntichain (\u00b7 \u2264 \u00b7) t) (\u03c6 : \u03b1 \u21aao \u03b2) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 \u207b\u00b9' t)", "start": [155, 1], "end": [157, 29], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_embedding_iff", "code": "theorem image_embedding_iff [LE \u03b1] [LE \u03b2] {\u03c6 : \u03b1 \u21aao \u03b2} :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s) \u2194 IsAntichain (\u00b7 \u2264 \u00b7) s", "start": [160, 1], "end": [162, 25], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_iso", "code": "theorem image_iso [LE \u03b1] [LE \u03b2] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) (\u03c6 : \u03b1 \u2243o \u03b2) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s)", "start": [165, 1], "end": [167, 26], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_iso_iff", "code": "theorem image_iso_iff [LE \u03b1] [LE \u03b2] {\u03c6 : \u03b1 \u2243o \u03b2} :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s) \u2194 IsAntichain (\u00b7 \u2264 \u00b7) s", "start": [170, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_iso", "code": "theorem preimage_iso [LE \u03b1] [LE \u03b2] {t : Set \u03b2} (ht : IsAntichain (\u00b7 \u2264 \u00b7) t) (\u03c6 : \u03b1 \u2243o \u03b2) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 \u207b\u00b9' t)", "start": [175, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_iso_iff", "code": "theorem preimage_iso_iff [LE \u03b1] [LE \u03b2] {t : Set \u03b2} {\u03c6 : \u03b1 \u2243o \u03b2} :\n    IsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 \u207b\u00b9' t) \u2194 IsAntichain (\u00b7 \u2264 \u00b7) t", "start": [180, 1], "end": [182, 83], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.to_dual", "code": "theorem to_dual [LE \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : @IsAntichain \u03b1\u1d52\u1d48 (\u00b7 \u2264 \u00b7) s", "start": [185, 1], "end": [186, 41], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.to_dual_iff", "code": "theorem to_dual_iff [LE \u03b1] : IsAntichain (\u00b7 \u2264 \u00b7) s \u2194 @IsAntichain \u03b1\u1d52\u1d48 (\u00b7 \u2264 \u00b7) s", "start": [189, 1], "end": [190, 21], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.image_compl", "code": "theorem image_compl [BooleanAlgebra \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (compl '' s)", "start": [193, 1], "end": [195, 64], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.preimage_compl", "code": "theorem preimage_compl [BooleanAlgebra \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\n    IsAntichain (\u00b7 \u2264 \u00b7) (compl \u207b\u00b9' s)", "start": [198, 1], "end": [200, 74], "kind": "commanddeclaration"}, {"full_name": "isAntichain_singleton", "code": "theorem isAntichain_singleton (a : \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : IsAntichain r {a}", "start": [205, 1], "end": [206, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isAntichain", "code": "theorem Set.Subsingleton.isAntichain (hs : s.Subsingleton) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : IsAntichain r s", "start": [209, 1], "end": [210, 16], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.not_lt", "code": "theorem IsAntichain.not_lt (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) (ha : a \u2208 s) (hb : b \u2208 s) : \u00aca < b", "start": [217, 1], "end": [218, 30], "kind": "commanddeclaration"}, {"full_name": "isAntichain_and_least_iff", "code": "theorem isAntichain_and_least_iff : IsAntichain (\u00b7 \u2264 \u00b7) s \u2227 IsLeast s a \u2194 s = {a}", "start": [221, 1], "end": [224, 58], "kind": "commanddeclaration"}, {"full_name": "isAntichain_and_greatest_iff", "code": "theorem isAntichain_and_greatest_iff : IsAntichain (\u00b7 \u2264 \u00b7) s \u2227 IsGreatest s a \u2194 s = {a}", "start": [227, 1], "end": [230, 61], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.least_iff", "code": "theorem IsAntichain.least_iff (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : IsLeast s a \u2194 s = {a}", "start": [233, 1], "end": [234, 58], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.greatest_iff", "code": "theorem IsAntichain.greatest_iff (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : IsGreatest s a \u2194 s = {a}", "start": [237, 1], "end": [238, 61], "kind": "commanddeclaration"}, {"full_name": "IsLeast.antichain_iff", "code": "theorem IsLeast.antichain_iff (hs : IsLeast s a) : IsAntichain (\u00b7 \u2264 \u00b7) s \u2194 s = {a}", "start": [241, 1], "end": [242, 57], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.antichain_iff", "code": "theorem IsGreatest.antichain_iff (hs : IsGreatest s a) : IsAntichain (\u00b7 \u2264 \u00b7) s \u2194 s = {a}", "start": [245, 1], "end": [246, 60], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.bot_mem_iff", "code": "theorem IsAntichain.bot_mem_iff [OrderBot \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : \u22a5 \u2208 s \u2194 s = {\u22a5}", "start": [249, 1], "end": [250, 42], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.top_mem_iff", "code": "theorem IsAntichain.top_mem_iff [OrderTop \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : \u22a4 \u2208 s \u2194 s = {\u22a4}", "start": [253, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "isAntichain_iff_forall_not_lt", "code": "theorem isAntichain_iff_forall_not_lt :\n    IsAntichain (\u00b7 \u2264 \u00b7) s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 \u00aca < b", "start": [263, 1], "end": [265, 86], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain", "code": "def IsStrongAntichain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop :=\n  s.Pairwise fun a b => \u2200 c, \u00acr a c \u2228 \u00acr b c", "start": [273, 1], "end": [276, 45], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.subset", "code": "protected theorem subset (hs : IsStrongAntichain r s) (h : t \u2286 s) : IsStrongAntichain r t", "start": [281, 1], "end": [282, 12], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.mono", "code": "theorem mono (hs : IsStrongAntichain r\u2081 s) (h : r\u2082 \u2264 r\u2081) : IsStrongAntichain r\u2082 s", "start": [285, 1], "end": [286, 86], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.eq", "code": "theorem eq (hs : IsStrongAntichain r s) {a b c : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) (hac : r a c)\n    (hbc : r b c) : a = b", "start": [289, 1], "end": [292, 69], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.isAntichain", "code": "protected theorem isAntichain [IsRefl \u03b1 r] (h : IsStrongAntichain r s) : IsAntichain r s", "start": [295, 1], "end": [296, 71], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.subsingleton", "code": "protected theorem subsingleton [IsDirected \u03b1 r] (h : IsStrongAntichain r s) : s.Subsingleton", "start": [299, 1], "end": [302, 21], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.flip", "code": "protected theorem flip [IsSymm \u03b1 r] (hs : IsStrongAntichain r s) : IsStrongAntichain (flip r) s", "start": [305, 1], "end": [306, 78], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.swap", "code": "theorem swap [IsSymm \u03b1 r] (hs : IsStrongAntichain r s) : IsStrongAntichain (swap r) s", "start": [309, 1], "end": [310, 10], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.image", "code": "theorem image (hs : IsStrongAntichain r s) {f : \u03b1 \u2192 \u03b2} (hf : Surjective f)\n    (h : \u2200 a b, r' (f a) (f b) \u2192 r a b) : IsStrongAntichain r' (f '' s)", "start": [313, 1], "end": [317, 76], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.preimage", "code": "theorem preimage (hs : IsStrongAntichain r s) {f : \u03b2 \u2192 \u03b1} (hf : Injective f)\n    (h : \u2200 a b, r' a b \u2192 r (f a) (f b)) : IsStrongAntichain r' (f \u207b\u00b9' s)", "start": [320, 1], "end": [322, 59], "kind": "commanddeclaration"}, {"full_name": "isStrongAntichain_insert", "code": "theorem _root_.isStrongAntichain_insert :\n    IsStrongAntichain r (insert a s) \u2194\n      IsStrongAntichain r s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u2200 c, \u00acr a c \u2228 \u00acr b c", "start": [325, 1], "end": [328, 61], "kind": "commanddeclaration"}, {"full_name": "IsStrongAntichain.insert", "code": "protected theorem insert (hs : IsStrongAntichain r s)\n    (h : \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u2200 c, \u00acr a c \u2228 \u00acr b c) : IsStrongAntichain r (insert a s)", "start": [331, 1], "end": [333, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isStrongAntichain", "code": "theorem Set.Subsingleton.isStrongAntichain (hs : s.Subsingleton) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    IsStrongAntichain r s", "start": [338, 1], "end": [340, 16], "kind": "commanddeclaration"}, {"full_name": "IsWeakAntichain", "code": "def IsWeakAntichain (s : Set (\u2200 i, \u03b1 i)) : Prop :=\n  IsAntichain (\u00b7 \u227a \u00b7) s", "start": [357, 1], "end": [360, 24], "kind": "commanddeclaration"}, {"full_name": "IsWeakAntichain.subset", "code": "protected theorem subset (hs : IsWeakAntichain s) : t \u2286 s \u2192 IsWeakAntichain t", "start": [365, 1], "end": [366, 24], "kind": "commanddeclaration"}, {"full_name": "IsWeakAntichain.eq", "code": "protected theorem eq (hs : IsWeakAntichain s) : a \u2208 s \u2192 b \u2208 s \u2192 a \u227a b \u2192 a = b", "start": [369, 1], "end": [370, 20], "kind": "commanddeclaration"}, {"full_name": "IsWeakAntichain.insert", "code": "protected theorem insert (hs : IsWeakAntichain s) :\n    (\u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acb \u227a a) \u2192\n      (\u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00aca \u227a b) \u2192 IsWeakAntichain (insert a s)", "start": [373, 1], "end": [376, 24], "kind": "commanddeclaration"}, {"full_name": "isWeakAntichain_insert", "code": "theorem _root_.isWeakAntichain_insert :\n    IsWeakAntichain (insert a s) \u2194 IsWeakAntichain s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00aca \u227a b \u2227 \u00acb \u227a a", "start": [381, 1], "end": [383, 21], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.isWeakAntichain", "code": "protected theorem IsAntichain.isWeakAntichain (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : IsWeakAntichain s", "start": [386, 1], "end": [387, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isWeakAntichain", "code": "theorem Set.Subsingleton.isWeakAntichain (hs : s.Subsingleton) : IsWeakAntichain s", "start": [390, 1], "end": [391, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/SetLike.lean", "imports": ["lake-packages/aesop/Aesop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Hom/Iterate.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/GroupTheory/GroupAction/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "hom_coe_pow", "code": "theorem hom_coe_pow {F : Type*} [Monoid F] (c : F \u2192 M \u2192 M) (h1 : c 1 = id)\n    (hmul : \u2200 f g, c (f * g) = c f \u2218 c g) (f : F) : \u2200 n, c (f ^ n) = (c f)^[n]", "start": [33, 1], "end": [39, 78], "kind": "commanddeclaration"}, {"full_name": "iterate_map_mul", "code": "@[to_additive (attr := simp)]\ntheorem iterate_map_mul {M F : Type*} [MulOneClass M]\n    (f : F) (n : \u2115) (x y : M) [MulHomClass F M M] :\n    f^[n] (x * y) = f^[n] x * f^[n] y", "start": [42, 1], "end": [46, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_one", "code": "@[to_additive (attr := simp)]\ntheorem iterate_map_one (f : M \u2192* M) (n : \u2115) : f^[n] 1 = 1", "start": [54, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_inv", "code": "@[to_additive (attr := simp)]\ntheorem iterate_map_inv (f : G \u2192* G) (n : \u2115) (x) : f^[n] x\u207b\u00b9 = (f^[n] x)\u207b\u00b9", "start": [64, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_div", "code": "@[to_additive (attr := simp)]\ntheorem iterate_map_div (f : G \u2192* G) (n : \u2115) (x y) : f^[n] (x / y) = f^[n] x / f^[n] y", "start": [70, 1], "end": [72, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_pow", "code": "theorem iterate_map_pow (f : M \u2192* M) (n : \u2115) (a) (m : \u2115) : f^[n] (a ^ m) = f^[n] a ^ m", "start": [76, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.iterate_map_zpow", "code": "theorem iterate_map_zpow (f : G \u2192* G) (n : \u2115) (a) (m : \u2124) : f^[n] (a ^ m) = f^[n] a ^ m", "start": [80, 1], "end": [81, 53], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_pow", "code": "theorem coe_pow {M} [CommMonoid M] (f : Monoid.End M) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [84, 1], "end": [85, 41], "kind": "commanddeclaration"}, {"full_name": "Monoid.End.coe_pow", "code": "theorem Monoid.End.coe_pow {M} [Monoid M] (f : Monoid.End M) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [90, 1], "end": [91, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.iterate_map_smul", "code": "theorem iterate_map_smul (f : M \u2192+ M) (n m : \u2115) (x : M) : f^[n] (m \u2022 x) = m \u2022 f^[n] x", "start": [99, 1], "end": [100, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.iterate_map_zsmul", "code": "theorem iterate_map_zsmul (f : G \u2192+ G) (n : \u2115) (m : \u2124) (x : G) : f^[n] (m \u2022 x) = m \u2022 f^[n] x", "start": [106, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.coe_pow", "code": "theorem AddMonoid.End.coe_pow {A} [AddMonoid A] (f : AddMonoid.End A) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [114, 1], "end": [115, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_pow", "code": "theorem coe_pow (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [124, 1], "end": [125, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_one", "code": "theorem iterate_map_one : f^[n] 1 = 1", "start": [128, 1], "end": [129, 34], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_zero", "code": "theorem iterate_map_zero : f^[n] 0 = 0", "start": [132, 1], "end": [133, 38], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_pow", "code": "theorem iterate_map_pow (a) (n m : \u2115) : f^[n] (a ^ m) = f^[n] a ^ m", "start": [136, 1], "end": [137, 38], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_smul", "code": "theorem iterate_map_smul (n m : \u2115) (x : R) : f^[n] (m \u2022 x) = m \u2022 f^[n] x", "start": [140, 1], "end": [141, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_sub", "code": "theorem iterate_map_sub : f^[n] (x - y) = f^[n] x - f^[n] y", "start": [148, 1], "end": [149, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_neg", "code": "theorem iterate_map_neg : f^[n] (-x) = -f^[n] x", "start": [152, 1], "end": [153, 39], "kind": "commanddeclaration"}, {"full_name": "RingHom.iterate_map_zsmul", "code": "theorem iterate_map_zsmul (n : \u2115) (m : \u2124) (x : R) : f^[n] (m \u2022 x) = m \u2022 f^[n] x", "start": [156, 1], "end": [157, 43], "kind": "commanddeclaration"}, {"full_name": "smul_iterate", "code": "@[to_additive (attr := simp)]\ntheorem smul_iterate [MulAction G H] : (a \u2022 \u00b7 : H \u2192 H)^[n] = (a ^ n \u2022 \u00b7)", "start": [167, 1], "end": [171, 74], "kind": "commanddeclaration"}, {"full_name": "mul_left_iterate", "code": "@[to_additive (attr := simp)]\ntheorem mul_left_iterate : (a * \u00b7)^[n] = (a ^ n * \u00b7)", "start": [175, 1], "end": [177, 19], "kind": "commanddeclaration"}, {"full_name": "mul_right_iterate", "code": "@[to_additive (attr := simp)]\ntheorem mul_right_iterate : (\u00b7 * a)^[n] = (\u00b7 * a ^ n)", "start": [181, 1], "end": [183, 36], "kind": "commanddeclaration"}, {"full_name": "mul_right_iterate_apply_one", "code": "@[to_additive]\ntheorem mul_right_iterate_apply_one : (\u00b7 * a)^[n] 1 = a ^ n", "start": [187, 1], "end": [188, 91], "kind": "commanddeclaration"}, {"full_name": "pow_iterate", "code": "@[to_additive (attr := simp)]\ntheorem pow_iterate (n : \u2115) (j : \u2115) : (fun x : G => x ^ n)^[j] = fun x : G => x ^ n ^ j", "start": [192, 1], "end": [198, 19], "kind": "commanddeclaration"}, {"full_name": "zpow_iterate", "code": "@[to_additive (attr := simp)]\ntheorem zpow_iterate (n : \u2124) (j : \u2115) : (fun x : G => x ^ n)^[j] = fun x => x ^ n ^ j", "start": [208, 1], "end": [214, 19], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.function_semiconj_mul_left", "code": "@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_left (h : SemiconjBy a b c) :\n    Function.Semiconj (a * \u00b7) (b * \u00b7) (c * \u00b7)", "start": [226, 1], "end": [229, 48], "kind": "commanddeclaration"}, {"full_name": "Commute.function_commute_mul_left", "code": "@[to_additive]\ntheorem Commute.function_commute_mul_left (h : Commute a b) :\n    Function.Commute (a * \u00b7) (b * \u00b7)", "start": [233, 1], "end": [236, 42], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.function_semiconj_mul_right_swap", "code": "@[to_additive]\ntheorem SemiconjBy.function_semiconj_mul_right_swap (h : SemiconjBy a b c) :\n    Function.Semiconj (\u00b7 * a) (\u00b7 * c) (\u00b7 * b)", "start": [240, 1], "end": [242, 89], "kind": "commanddeclaration"}, {"full_name": "Commute.function_commute_mul_right", "code": "@[to_additive]\ntheorem Commute.function_commute_mul_right (h : Commute a b) :\n    Function.Commute (\u00b7 * a) (\u00b7 * b)", "start": [246, 1], "end": [249, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Eq.lean", "imports": ["Mathlib/Tactic/NormNum/Inv.lean", "Mathlib/Algebra/Order/Invertible.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.isNat_eq_false", "code": "theorem isNat_eq_false [AddMonoidWithOne \u03b1] [CharZero \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.beq a' b' = false \u2192 \u00aca = b", "start": [19, 1], "end": [21, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_eq_false", "code": "theorem isInt_eq_false [Ring \u03b1] [CharZero \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2124} \u2192\n    IsInt a a' \u2192 IsInt b b' \u2192 decide (a' = b') = false \u2192 \u00aca = b", "start": [23, 1], "end": [25, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.Rat.invOf_denom_swap", "code": "theorem Rat.invOf_denom_swap [Ring \u03b1] (n\u2081 n\u2082 : \u2124) (a\u2081 a\u2082 : \u03b1)\n    [Invertible a\u2081] [Invertible a\u2082] : n\u2081 * \u215fa\u2081 = n\u2082 * \u215fa\u2082 \u2194 n\u2081 * a\u2082 = n\u2082 * a\u2081", "start": [27, 1], "end": [30, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_eq_false", "code": "theorem isRat_eq_false [Ring \u03b1] [CharZero \u03b1] : {a b : \u03b1} \u2192 {na nb : \u2124} \u2192 {da db : \u2115} \u2192\n    IsRat a na da \u2192 IsRat b nb db \u2192\n    decide (Int.mul na (.ofNat db) = Int.mul nb (.ofNat da)) = false \u2192 \u00aca = b", "start": [32, 1], "end": [36, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalEq", "code": "@[norm_num _ = _, Eq _ _] def evalEq : NormNumExt where eval {v \u03b2} e := do\n  haveI' : v =QL 0 := \u27e8\u27e9; haveI' : $\u03b2 =Q Prop := \u27e8\u27e9\n  let .app (.app f a) b \u2190 whnfR e | failure\n  let \u27e8u, \u03b1, a\u27e9 \u2190 inferTypeQ' a\n  have b : Q($\u03b1) := b\n  haveI' : $e =Q ($a = $b) := \u27e8\u27e9\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(Eq (\u03b1 := $\u03b1))\n  let ra \u2190 derive a; let rb \u2190 derive b\n  let rec intArm (r\u03b1 : Q(Ring $\u03b1)) := do\n    let \u27e8za, na, pa\u27e9 \u2190 ra.toInt r\u03b1; let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt r\u03b1\n    if za = zb then\n      haveI' : $na =Q $nb := \u27e8\u27e9\n      return .isTrue q(isInt_eq_true $pa $pb)\n    else if let some _i \u2190 inferCharZeroOfRing? r\u03b1 then\n      let r : Q(decide ($na = $nb) = false) := (q(Eq.refl false) : Expr)\n      return .isFalse q(isInt_eq_false $pa $pb $r)\n    else\n      failure let rec ratArm (d\u03b1 : Q(DivisionRing $\u03b1)) := do\n    let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' d\u03b1; let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' d\u03b1\n    if qa = qb then\n      haveI' : $na =Q $nb := \u27e8\u27e9\n      haveI' : $da =Q $db := \u27e8\u27e9\n      return .isTrue q(isRat_eq_true $pa $pb)\n    else if let some _i \u2190 inferCharZeroOfDivisionRing? d\u03b1 then\n      let r : Q(decide (Int.mul $na (.ofNat $db) = Int.mul $nb (.ofNat $da)) = false) :=\n        (q(Eq.refl false) : Expr)\n      return .isFalse q(isRat_eq_false $pa $pb $r)\n    else\n      failure match ra, rb with\n  | .isBool b\u2081 p\u2081, .isBool b\u2082 p\u2082 =>\n    have a : Q(Prop) := a; have b : Q(Prop) := b\n    match b\u2081, p\u2081, b\u2082, p\u2082 with\n    | true, (p\u2081 : Q($a)), true, (p\u2082 : Q($b)) =>\n      return .isTrue q(eq_of_true $p\u2081 $p\u2082)\n    | false, (p\u2081 : Q(\u00ac$a)), false, (p\u2082 : Q(\u00ac$b)) =>\n      return .isTrue q(eq_of_false $p\u2081 $p\u2082)\n    | false, (p\u2081 : Q(\u00ac$a)), true, (p\u2082 : Q($b)) =>\n      return .isFalse q(ne_of_false_of_true $p\u2081 $p\u2082)\n    | true, (p\u2081 : Q($a)), false, (p\u2082 : Q(\u00ac$b)) =>\n      return .isFalse q(ne_of_true_of_false $p\u2081 $p\u2082)\n  | .isBool .., _ | _, .isBool .. => failure\n  | .isRat d\u03b1 .., _ | _, .isRat d\u03b1 .. => ratArm d\u03b1\n  | .isNegNat r\u03b1 .., _ | _, .isNegNat r\u03b1 .. => intArm r\u03b1\n  | .isNat _ na pa, .isNat m\u03b1 nb pb =>\n    assumeInstancesCommute\n    if na.natLit! = nb.natLit! then\n      haveI' : $na =Q $nb := \u27e8\u27e9\n      return .isTrue q(isNat_eq_true $pa $pb)\n    else if let some _i \u2190 inferCharZeroOfAddMonoidWithOne? m\u03b1 then\n      let r : Q(Nat.beq $na $nb = false) := (q(Eq.refl false) : Expr)\n      return .isFalse q(isNat_eq_false $pa $pb $r)\n    else\n      failure", "start": [38, 1], "end": [94, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Order.lean", "imports": ["Mathlib/Data/Rat/Basic.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.Nonneg", "code": "protected def Nonneg (r : \u211a) : Prop :=\n  0 \u2264 r.num", "start": [33, 1], "end": [35, 12], "kind": "commanddeclaration"}, {"full_name": "Rat.divInt_nonneg", "code": "@[simp]\ntheorem divInt_nonneg (a : \u2124) {b : \u2124} (h : 0 < b) : (a /. b).Nonneg \u2194 0 \u2264 a", "start": [38, 1], "end": [50, 46], "kind": "commanddeclaration"}, {"full_name": "Rat.nonneg_add", "code": "protected theorem nonneg_add {a b} : Rat.Nonneg a \u2192 Rat.Nonneg b \u2192 Rat.Nonneg (a + b)", "start": [53, 1], "end": [61, 92], "kind": "commanddeclaration"}, {"full_name": "Rat.nonneg_mul", "code": "protected theorem nonneg_mul {a b} : Rat.Nonneg a \u2192 Rat.Nonneg b \u2192 Rat.Nonneg (a * b)", "start": [64, 1], "end": [71, 23], "kind": "commanddeclaration"}, {"full_name": "Rat.nonneg_antisymm", "code": "protected theorem nonneg_antisymm {a} : Rat.Nonneg a \u2192 Rat.Nonneg (-a) \u2192 a = 0", "start": [74, 1], "end": [79, 41], "kind": "commanddeclaration"}, {"full_name": "Rat.nonneg_total", "code": "protected theorem nonneg_total : Rat.Nonneg a \u2228 Rat.Nonneg (-a)", "start": [82, 1], "end": [83, 74], "kind": "commanddeclaration"}, {"full_name": "Rat.decidableNonneg", "code": "instance decidableNonneg : Decidable (Rat.Nonneg a) := by\n  cases a; unfold Rat.Nonneg; infer_instance", "start": [86, 1], "end": [87, 45], "kind": "commanddeclaration"}, {"full_name": "Rat.le'", "code": "protected def le' (a b : \u211a) := Rat.Nonneg (b - a)", "start": [92, 1], "end": [94, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.numDenCasesOn''", "code": "@[elab_as_elim]\ndef numDenCasesOn''.{u} {C : \u211a \u2192 Sort u} (a : \u211a)\n    (H : \u2200 (n : \u2124) (d : \u2115) (nz red), C (mk' n d nz red)) :\n    C a :=\n  numDenCasesOn a fun n d h h' => by\n    rw [\u2190mk_eq_divInt _ _ h.ne' h']\n    exact H n d h.ne' _", "start": [97, 1], "end": [106, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.le_iff_Nonneg", "code": "protected theorem le_iff_Nonneg (a b : \u211a) : a \u2264 b \u2194 Rat.Nonneg (b - a)", "start": [109, 1], "end": [149, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.le_def", "code": "protected theorem le_def {a b c d : \u2124} (b0 : 0 < b) (d0 : 0 < d) :\n    a /. b \u2264 c /. d \u2194 a * d \u2264 c * b", "start": [151, 1], "end": [156, 65], "kind": "commanddeclaration"}, {"full_name": "Rat.le_refl", "code": "protected theorem le_refl : a \u2264 a", "start": [159, 1], "end": [163, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.le_total", "code": "protected theorem le_total : a \u2264 b \u2228 b \u2264 a", "start": [166, 1], "end": [169, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.le_antisymm", "code": "protected theorem le_antisymm {a b : \u211a} (hab : a \u2264 b) (hba : b \u2264 a) : a = b", "start": [172, 1], "end": [177, 24], "kind": "commanddeclaration"}, {"full_name": "Rat.le_trans", "code": "protected theorem le_trans {a b c : \u211a} (hab : a \u2264 b) (hbc : b \u2264 c) : a \u2264 c", "start": [180, 1], "end": [187, 13], "kind": "commanddeclaration"}, {"full_name": "Rat.not_le", "code": "protected theorem not_le {a b : \u211a} : \u00aca \u2264 b \u2194 b < a", "start": [190, 1], "end": [190, 84], "kind": "commanddeclaration"}, {"full_name": "Rat.linearOrder", "code": "instance linearOrder : LinearOrder \u211a where\n  le_refl := Rat.le_refl\n  le_trans := @Rat.le_trans\n  le_antisymm := @Rat.le_antisymm\n  le_total := Rat.le_total\n  decidableLE _ _ := by infer_instance\n  lt_iff_le_not_le _ _ := by\n    rw [\u2190 Rat.not_le, and_iff_right_of_imp (Rat.le_total _ _).resolve_left]", "start": [192, 1], "end": [199, 76], "kind": "commanddeclaration"}, {"full_name": "Rat.le_def'", "code": "protected theorem le_def' {p q : \u211a} : p \u2264 q \u2194 p.num * q.den \u2264 q.num * p.den", "start": [220, 1], "end": [223, 71], "kind": "commanddeclaration"}, {"full_name": "Rat.lt_def", "code": "protected theorem lt_def {p q : \u211a} : p < q \u2194 p.num * q.den < q.num * p.den", "start": [226, 1], "end": [233, 42], "kind": "commanddeclaration"}, {"full_name": "Rat.nonneg_iff_zero_le", "code": "theorem nonneg_iff_zero_le {a} : Rat.Nonneg a \u2194 0 \u2264 a", "start": [236, 1], "end": [239, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.num_nonneg_iff_zero_le", "code": "theorem num_nonneg_iff_zero_le : \u2200 {a : \u211a}, 0 \u2264 a.num \u2194 0 \u2264 a", "start": [242, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "Rat.add_le_add_left", "code": "protected theorem add_le_add_left {a b c : \u211a} : c + a \u2264 c + b \u2194 a \u2264 b", "start": [246, 1], "end": [247, 69], "kind": "commanddeclaration"}, {"full_name": "Rat.mul_nonneg", "code": "protected theorem mul_nonneg {a b : \u211a} (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b", "start": [250, 1], "end": [251, 67], "kind": "commanddeclaration"}, {"full_name": "Rat.num_pos_iff_pos", "code": "theorem num_pos_iff_pos {a : \u211a} : 0 < a.num \u2194 0 < a", "start": [281, 1], "end": [283, 85], "kind": "commanddeclaration"}, {"full_name": "Rat.div_lt_div_iff_mul_lt_mul", "code": "theorem div_lt_div_iff_mul_lt_mul {a b c d : \u2124} (b_pos : 0 < b) (d_pos : 0 < d) :\n    (a : \u211a) / b < c / d \u2194 a * d < c * b", "start": [286, 1], "end": [292, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.lt_one_iff_num_lt_denom", "code": "theorem lt_one_iff_num_lt_denom {q : \u211a} : q < 1 \u2194 q.num < q.den", "start": [295, 1], "end": [295, 88], "kind": "commanddeclaration"}, {"full_name": "Rat.abs_def", "code": "theorem abs_def (q : \u211a) : |q| = q.num.natAbs /. q.den", "start": [298, 1], "end": [307, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Basic.lean", "imports": ["Mathlib/Data/Set/Finite.lean", "Mathlib/Control/Traversable/Instances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter", "code": "structure Filter (\u03b1 : Type*) where\n  \n  sets : Set (Set \u03b1)\n  \n  univ_sets : Set.univ \u2208 sets\n  \n  sets_of_superset {x y} : x \u2208 sets \u2192 x \u2286 y \u2192 y \u2208 sets\n  \n  inter_sets {x y} : x \u2208 sets \u2192 y \u2208 sets \u2192 x \u2229 y \u2208 sets", "start": [88, 1], "end": [99, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_mk", "code": "@[simp]\nprotected theorem mem_mk {t : Set (Set \u03b1)} {h\u2081 h\u2082 h\u2083} : s \u2208 mk t h\u2081 h\u2082 h\u2083 \u2194 s \u2208 t", "start": [110, 1], "end": [112, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_sets", "code": "@[simp]\nprotected theorem mem_sets : s \u2208 f.sets \u2194 s \u2208 f", "start": [115, 1], "end": [117, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.inhabitedMem", "code": "instance inhabitedMem : Inhabited { s : Set \u03b1 // s \u2208 f } :=\n  \u27e8\u27e8univ, f.univ_sets\u27e9\u27e9", "start": [120, 1], "end": [121, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.filter_eq", "code": "theorem filter_eq : \u2200 {f g : Filter \u03b1}, f.sets = g.sets \u2192 f = g", "start": [124, 1], "end": [125, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.filter_eq_iff", "code": "theorem filter_eq_iff : f = g \u2194 f.sets = g.sets", "start": [128, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.ext_iff", "code": "protected theorem ext_iff : f = g \u2194 \u2200 s, s \u2208 f \u2194 s \u2208 g", "start": [132, 1], "end": [133, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.ext", "code": "@[ext]\nprotected theorem ext : (\u2200 s, s \u2208 f \u2194 s \u2208 g) \u2192 f = g", "start": [136, 1], "end": [138, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.coext", "code": "protected theorem coext (h : \u2200 s, s\u1d9c \u2208 f \u2194 s\u1d9c \u2208 g) : f = g", "start": [141, 1], "end": [144, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.univ_mem", "code": "@[simp]\ntheorem univ_mem : univ \u2208 f", "start": [147, 1], "end": [149, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_of_superset", "code": "theorem mem_of_superset {x y : Set \u03b1} (hx : x \u2208 f) (hxy : x \u2286 y) : y \u2208 f", "start": [152, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.inter_mem", "code": "theorem inter_mem {s t : Set \u03b1} (hs : s \u2208 f) (ht : t \u2208 f) : s \u2229 t \u2208 f", "start": [156, 1], "end": [157, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.inter_mem_iff", "code": "@[simp]\ntheorem inter_mem_iff {s t : Set \u03b1} : s \u2229 t \u2208 f \u2194 s \u2208 f \u2227 t \u2208 f", "start": [160, 1], "end": [163, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.diff_mem", "code": "theorem diff_mem {s t : Set \u03b1} (hs : s \u2208 f) (ht : t\u1d9c \u2208 f) : s \\ t \u2208 f", "start": [166, 1], "end": [167, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.univ_mem'", "code": "theorem univ_mem' (h : \u2200 a, a \u2208 s) : s \u2208 f", "start": [170, 1], "end": [171, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.mp_mem", "code": "theorem mp_mem (hs : s \u2208 f) (h : { x | x \u2208 s \u2192 x \u2208 t } \u2208 f) : t \u2208 f", "start": [174, 1], "end": [175, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.congr_sets", "code": "theorem congr_sets (h : { x | x \u2208 s \u2194 x \u2208 t } \u2208 f) : s \u2208 f \u2194 t \u2208 f", "start": [178, 1], "end": [180, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.biInter_mem", "code": "@[simp]\ntheorem biInter_mem {\u03b2 : Type v} {s : \u03b2 \u2192 Set \u03b1} {is : Set \u03b2} (hf : is.Finite) :\n    (\u22c2 i \u2208 is, s i) \u2208 f \u2194 \u2200 i \u2208 is, s i \u2208 f", "start": [183, 1], "end": [186, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.biInter_finset_mem", "code": "@[simp]\ntheorem biInter_finset_mem {\u03b2 : Type v} {s : \u03b2 \u2192 Set \u03b1} (is : Finset \u03b2) :\n    (\u22c2 i \u2208 is, s i) \u2208 f \u2194 \u2200 i \u2208 is, s i \u2208 f", "start": [189, 1], "end": [192, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.iInter_mem_sets", "code": "alias _root_.Finset.iInter_mem_sets := biInter_finset_mem", "start": [195, 1], "end": [195, 58], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.sInter_mem", "code": "@[simp]\ntheorem sInter_mem {s : Set (Set \u03b1)} (hfin : s.Finite) : \u22c2\u2080 s \u2208 f \u2194 \u2200 U \u2208 s, U \u2208 f", "start": [200, 1], "end": [202, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.iInter_mem", "code": "@[simp]\ntheorem iInter_mem {\u03b2 : Sort v} {s : \u03b2 \u2192 Set \u03b1} [Finite \u03b2] : (\u22c2 i, s i) \u2208 f \u2194 \u2200 i, s i \u2208 f", "start": [205, 1], "end": [207, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_mem_subset_iff", "code": "theorem exists_mem_subset_iff : (\u2203 t \u2208 f, t \u2286 s) \u2194 s \u2208 f", "start": [210, 1], "end": [211, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_mem", "code": "theorem monotone_mem {f : Filter \u03b1} : Monotone fun s => s \u2208 f", "start": [214, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_mem_and_iff", "code": "theorem exists_mem_and_iff {P : Set \u03b1 \u2192 Prop} {Q : Set \u03b1 \u2192 Prop} (hP : Antitone P)\n    (hQ : Antitone Q) : ((\u2203 u \u2208 f, P u) \u2227 \u2203 u \u2208 f, Q u) \u2194 \u2203 u \u2208 f, P u \u2227 Q u", "start": [218, 1], "end": [225, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.forall_in_swap", "code": "theorem forall_in_swap {\u03b2 : Type*} {p : Set \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    (\u2200 a \u2208 f, \u2200 (b), p a b) \u2194 \u2200 (b), \u2200 a \u2208 f, p a b", "start": [228, 1], "end": [230, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.principal", "code": "def principal (s : Set \u03b1) : Filter \u03b1 where\n  sets := { t | s \u2286 t }\n  univ_sets := subset_univ s\n  sets_of_superset hx := Subset.trans hx\n  inter_sets := subset_inter", "start": [283, 1], "end": [288, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_principal", "code": "@[simp] theorem mem_principal {s t : Set \u03b1} : s \u2208 \ud835\udcdf t \u2194 t \u2286 s", "start": [294, 1], "end": [294, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_principal_self", "code": "theorem mem_principal_self (s : Set \u03b1) : s \u2208 \ud835\udcdf s", "start": [297, 1], "end": [297, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.join", "code": "def join (f : Filter (Filter \u03b1)) : Filter \u03b1 where\n  sets := { s | { t : Filter \u03b1 | s \u2208 t } \u2208 f }\n  univ_sets := by simp only [mem_setOf_eq, univ_sets, \u2190 Filter.mem_sets, setOf_true]\n  sets_of_superset hx xy := mem_of_superset hx fun f h => mem_of_superset h xy\n  inter_sets hx hy := mem_of_superset (inter_mem hx hy) fun f \u27e8h\u2081, h\u2082\u27e9 => inter_mem h\u2081 h\u2082", "start": [306, 1], "end": [311, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_join", "code": "@[simp]\ntheorem mem_join {s : Set \u03b1} {f : Filter (Filter \u03b1)} : s \u2208 join f \u2194 { t | s \u2208 t } \u2208 f", "start": [314, 1], "end": [316, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.le_def", "code": "theorem le_def : f \u2264 g \u2194 \u2200 x \u2208 g, x \u2208 f", "start": [331, 1], "end": [332, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.not_le", "code": "protected theorem not_le : \u00acf \u2264 g \u2194 \u2203 s \u2208 g, s \u2209 f", "start": [335, 1], "end": [335, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.GenerateSets", "code": "inductive GenerateSets (g : Set (Set \u03b1)) : Set \u03b1 \u2192 Prop\n  | basic {s : Set \u03b1} : s \u2208 g \u2192 GenerateSets g s\n  | univ : GenerateSets g univ\n  | superset {s t : Set \u03b1} : GenerateSets g s \u2192 s \u2286 t \u2192 GenerateSets g t\n  | inter {s t : Set \u03b1} : GenerateSets g s \u2192 GenerateSets g t \u2192 GenerateSets g (s \u2229 t)", "start": [338, 1], "end": [343, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.generate", "code": "def generate (g : Set (Set \u03b1)) : Filter \u03b1 where\n  sets := {s | GenerateSets g s}\n  univ_sets := GenerateSets.univ\n  sets_of_superset := GenerateSets.superset\n  inter_sets := GenerateSets.inter", "start": [346, 1], "end": [351, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_generate_of_mem", "code": "lemma mem_generate_of_mem {s : Set <| Set \u03b1} {U : Set \u03b1} (h : U \u2208 s) :\n    U \u2208 generate s := GenerateSets.basic h", "start": [354, 1], "end": [355, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.le_generate_iff", "code": "theorem le_generate_iff {s : Set (Set \u03b1)} {f : Filter \u03b1} : f \u2264 generate s \u2194 s \u2286 f.sets", "start": [357, 1], "end": [360, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_generate_iff", "code": "theorem mem_generate_iff {s : Set <| Set \u03b1} {U : Set \u03b1} :\n    U \u2208 generate s \u2194 \u2203 (t : _) (_ : t \u2286 s), Set.Finite t \u2227 \u22c2\u2080 t \u2286 U", "start": [363, 1], "end": [379, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_singleton", "code": "@[simp] lemma generate_singleton (s : Set \u03b1) : generate {s} = \ud835\udcdf s :=\nle_antisymm (\u03bb _t ht \u21a6 mem_of_superset (mem_generate_of_mem $ mem_singleton _) ht) $\n  le_generate_iff.2 $ singleton_subset_iff.2 Subset.rfl", "start": [382, 1], "end": [384, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.mkOfClosure", "code": "protected def mkOfClosure (s : Set (Set \u03b1)) (hs : (generate s).sets = s) : Filter \u03b1 where\n  sets := s\n  univ_sets := hs \u25b8 univ_mem\n  sets_of_superset := hs \u25b8 mem_of_superset\n  inter_sets := hs \u25b8 inter_mem", "start": [386, 1], "end": [392, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.mkOfClosure_sets", "code": "theorem mkOfClosure_sets {s : Set (Set \u03b1)} {hs : (generate s).sets = s} :\n    Filter.mkOfClosure s hs = generate s", "start": [395, 1], "end": [398, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.giGenerate", "code": "def giGenerate (\u03b1 : Type*) :\n    @GaloisInsertion (Set (Set \u03b1)) (Filter \u03b1)\u1d52\u1d48 _ _ Filter.generate Filter.sets where\n  gc _ _ := le_generate_iff\n  le_l_u _ _ h := GenerateSets.basic h\n  choice s hs := Filter.mkOfClosure s (le_antisymm hs <| le_generate_iff.1 <| le_rfl)\n  choice_eq _ _ := mkOfClosure_sets", "start": [401, 1], "end": [407, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_iff", "code": "theorem mem_inf_iff {f g : Filter \u03b1} {s : Set \u03b1} : s \u2208 f \u2293 g \u2194 \u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, s = t\u2081 \u2229 t\u2082", "start": [427, 1], "end": [428, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_of_left", "code": "theorem mem_inf_of_left {f g : Filter \u03b1} {s : Set \u03b1} (h : s \u2208 f) : s \u2208 f \u2293 g", "start": [431, 1], "end": [432, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_of_right", "code": "theorem mem_inf_of_right {f g : Filter \u03b1} {s : Set \u03b1} (h : s \u2208 g) : s \u2208 f \u2293 g", "start": [435, 1], "end": [436, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.inter_mem_inf", "code": "theorem inter_mem_inf {\u03b1 : Type u} {f g : Filter \u03b1} {s t : Set \u03b1} (hs : s \u2208 f) (ht : t \u2208 g) :\n    s \u2229 t \u2208 f \u2293 g", "start": [439, 1], "end": [441, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_of_inter", "code": "theorem mem_inf_of_inter {f g : Filter \u03b1} {s t u : Set \u03b1} (hs : s \u2208 f) (ht : t \u2208 g)\n    (h : s \u2229 t \u2286 u) : u \u2208 f \u2293 g", "start": [444, 1], "end": [446, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_iff_superset", "code": "theorem mem_inf_iff_superset {f g : Filter \u03b1} {s : Set \u03b1} :\n    s \u2208 f \u2293 g \u2194 \u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, t\u2081 \u2229 t\u2082 \u2286 s", "start": [449, 1], "end": [452, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_top_iff_forall", "code": "theorem mem_top_iff_forall {s : Set \u03b1} : s \u2208 (\u22a4 : Filter \u03b1) \u2194 \u2200 x, x \u2208 s", "start": [461, 1], "end": [462, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_top", "code": "@[simp]\ntheorem mem_top {s : Set \u03b1} : s \u2208 (\u22a4 : Filter \u03b1) \u2194 s = univ", "start": [465, 1], "end": [467, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.instCompleteLatticeFilter", "code": "instance instCompleteLatticeFilter : CompleteLattice (Filter \u03b1) :=\n  { @OrderDual.completeLattice _ (giGenerate \u03b1).liftCompleteLattice with\n    le := (\u00b7 \u2264 \u00b7)\n    top := \u22a4\n    le_top := fun _ _s hs => (mem_top.1 hs).symm \u25b8 univ_mem\n    inf := (\u00b7 \u2293 \u00b7)\n    inf_le_left := fun _ _ _ => mem_inf_of_left\n    inf_le_right := fun _ _ _ => mem_inf_of_right\n    le_inf := fun _ _ _ h\u2081 h\u2082 _s \u27e8_a, ha, _b, hb, hs\u27e9 => hs.symm \u25b8 inter_mem (h\u2081 ha) (h\u2082 hb)\n    sSup := join \u2218 \ud835\udcdf\n    le_sSup := fun _ _f hf _s hs => hs hf\n    sSup_le := fun _ _f hf _s hs _g hg => hf _ hg hs }", "start": [475, 1], "end": [486, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot", "code": "class NeBot (f : Filter \u03b1) : Prop where\n  \n  ne' : f \u2260 \u22a5", "start": [492, 1], "end": [497, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.neBot_iff", "code": "theorem neBot_iff {f : Filter \u03b1} : NeBot f \u2194 f \u2260 \u22a5", "start": [500, 1], "end": [501, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.ne", "code": "theorem NeBot.ne {f : Filter \u03b1} (hf : NeBot f) : f \u2260 \u22a5", "start": [504, 1], "end": [504, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.not_neBot", "code": "@[simp] theorem not_neBot {f : Filter \u03b1} : \u00acf.NeBot \u2194 f = \u22a5", "start": [507, 1], "end": [507, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.mono", "code": "theorem NeBot.mono {f g : Filter \u03b1} (hf : NeBot f) (hg : f \u2264 g) : NeBot g", "start": [510, 1], "end": [511, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.neBot_of_le", "code": "theorem neBot_of_le {f g : Filter \u03b1} [hf : NeBot f] (hg : f \u2264 g) : NeBot g", "start": [514, 1], "end": [515, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_neBot", "code": "@[simp] theorem sup_neBot {f g : Filter \u03b1} : NeBot (f \u2294 g) \u2194 NeBot f \u2228 NeBot g", "start": [518, 1], "end": [519, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.not_disjoint_self_iff", "code": "theorem not_disjoint_self_iff : \u00acDisjoint f f \u2194 f.NeBot", "start": [522, 1], "end": [522, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_sets_eq", "code": "theorem bot_sets_eq : (\u22a5 : Filter \u03b1).sets = univ", "start": [525, 1], "end": [525, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.eq_or_neBot", "code": "theorem eq_or_neBot (f : Filter \u03b1) : f = \u22a5 \u2228 NeBot f", "start": [528, 1], "end": [530, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_sets_eq", "code": "theorem sup_sets_eq {f g : Filter \u03b1} : (f \u2294 g).sets = f.sets \u2229 g.sets", "start": [532, 1], "end": [533, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.sSup_sets_eq", "code": "theorem sSup_sets_eq {s : Set (Filter \u03b1)} : (sSup s).sets = \u22c2 f \u2208 s, (f : Filter \u03b1).sets", "start": [536, 1], "end": [537, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.iSup_sets_eq", "code": "theorem iSup_sets_eq {f : \u03b9 \u2192 Filter \u03b1} : (iSup f).sets = \u22c2 i, (f i).sets", "start": [540, 1], "end": [541, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_empty", "code": "theorem generate_empty : Filter.generate \u2205 = (\u22a4 : Filter \u03b1)", "start": [544, 1], "end": [545, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_univ", "code": "theorem generate_univ : Filter.generate univ = (\u22a5 : Filter \u03b1)", "start": [548, 1], "end": [549, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_union", "code": "theorem generate_union {s t : Set (Set \u03b1)} :\n    Filter.generate (s \u222a t) = Filter.generate s \u2293 Filter.generate t", "start": [552, 1], "end": [554, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_iUnion", "code": "theorem generate_iUnion {s : \u03b9 \u2192 Set (Set \u03b1)} :\n    Filter.generate (\u22c3 i, s i) = \u2a05 i, Filter.generate (s i)", "start": [557, 1], "end": [559, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_bot", "code": "@[simp]\ntheorem mem_bot {s : Set \u03b1} : s \u2208 (\u22a5 : Filter \u03b1)", "start": [562, 1], "end": [564, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_sup", "code": "@[simp]\ntheorem mem_sup {f g : Filter \u03b1} {s : Set \u03b1} : s \u2208 f \u2294 g \u2194 s \u2208 f \u2227 s \u2208 g", "start": [567, 1], "end": [569, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.union_mem_sup", "code": "theorem union_mem_sup {f g : Filter \u03b1} {s t : Set \u03b1} (hs : s \u2208 f) (ht : t \u2208 g) : s \u222a t \u2208 f \u2294 g", "start": [572, 1], "end": [573, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_sSup", "code": "@[simp]\ntheorem mem_sSup {x : Set \u03b1} {s : Set (Filter \u03b1)} : x \u2208 sSup s \u2194 \u2200 f \u2208 s, x \u2208 (f : Filter \u03b1)", "start": [576, 1], "end": [578, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iSup", "code": "@[simp]\ntheorem mem_iSup {x : Set \u03b1} {f : \u03b9 \u2192 Filter \u03b1} : x \u2208 iSup f \u2194 \u2200 i, x \u2208 f i", "start": [581, 1], "end": [583, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.iSup_neBot", "code": "@[simp]\ntheorem iSup_neBot {f : \u03b9 \u2192 Filter \u03b1} : (\u2a06 i, f i).NeBot \u2194 \u2203 i, (f i).NeBot", "start": [586, 1], "end": [588, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_eq_generate", "code": "theorem iInf_eq_generate (s : \u03b9 \u2192 Filter \u03b1) : iInf s = generate (\u22c3 i, (s i).sets)", "start": [591, 1], "end": [592, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_of_mem", "code": "theorem mem_iInf_of_mem {f : \u03b9 \u2192 Filter \u03b1} (i : \u03b9) {s} (hs : s \u2208 f i) : s \u2208 \u2a05 i, f i", "start": [595, 1], "end": [596, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_of_iInter", "code": "theorem mem_iInf_of_iInter {\u03b9} {s : \u03b9 \u2192 Filter \u03b1} {U : Set \u03b1} {I : Set \u03b9} (I_fin : I.Finite)\n    {V : I \u2192 Set \u03b1} (hV : \u2200 i, V i \u2208 s i) (hU : \u22c2 i, V i \u2286 U) : U \u2208 \u2a05 i, s i", "start": [599, 1], "end": [603, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf", "code": "theorem mem_iInf {\u03b9} {s : \u03b9 \u2192 Filter \u03b1} {U : Set \u03b1} :\n    (U \u2208 \u2a05 i, s i) \u2194 \u2203 I : Set \u03b9, I.Finite \u2227 \u2203 V : I \u2192 Set \u03b1, (\u2200 i, V i \u2208 s i) \u2227 U = \u22c2 i, V i", "start": [606, 1], "end": [623, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf'", "code": "theorem mem_iInf' {\u03b9} {s : \u03b9 \u2192 Filter \u03b1} {U : Set \u03b1} :\n    (U \u2208 \u2a05 i, s i) \u2194\n      \u2203 I : Set \u03b9, I.Finite \u2227 \u2203 V : \u03b9 \u2192 Set \u03b1, (\u2200 i, V i \u2208 s i) \u2227\n        (\u2200 (i) (_hi : i \u2209 I), V i = univ) \u2227 (U = \u22c2 i \u2208 I, V i) \u2227 U = \u22c2 i, V i", "start": [626, 1], "end": [639, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_iInter_of_mem_iInf", "code": "theorem exists_iInter_of_mem_iInf {\u03b9 : Type*} {\u03b1 : Type*} {f : \u03b9 \u2192 Filter \u03b1} {s}\n    (hs : s \u2208 \u2a05 i, f i) : \u2203 t : \u03b9 \u2192 Set \u03b1, (\u2200 i, t i \u2208 f i) \u2227 s = \u22c2 i, t i", "start": [642, 1], "end": [644, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_of_finite", "code": "theorem mem_iInf_of_finite {\u03b9 : Type*} [Finite \u03b9] {\u03b1 : Type*} {f : \u03b9 \u2192 Filter \u03b1} (s) :\n    (s \u2208 \u2a05 i, f i) \u2194 \u2203 t : \u03b9 \u2192 Set \u03b1, (\u2200 i, t i \u2208 f i) \u2227 s = \u22c2 i, t i", "start": [647, 1], "end": [651, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.le_principal_iff", "code": "@[simp]\ntheorem le_principal_iff {s : Set \u03b1} {f : Filter \u03b1} : f \u2264 \ud835\udcdf s \u2194 s \u2208 f", "start": [654, 1], "end": [656, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.Iic_principal", "code": "theorem Iic_principal (s : Set \u03b1) : Iic (\ud835\udcdf s) = { l | s \u2208 l }", "start": [659, 1], "end": [660, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_mono", "code": "theorem principal_mono {s t : Set \u03b1} : \ud835\udcdf s \u2264 \ud835\udcdf t \u2194 s \u2286 t", "start": [663, 1], "end": [664, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_principal", "code": "@[mono]\ntheorem monotone_principal : Monotone (\ud835\udcdf : Set \u03b1 \u2192 Filter \u03b1)", "start": [667, 1], "end": [668, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_eq_iff_eq", "code": "@[simp] theorem principal_eq_iff_eq {s t : Set \u03b1} : \ud835\udcdf s = \ud835\udcdf t \u2194 s = t", "start": [671, 1], "end": [672, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.join_principal_eq_sSup", "code": "@[simp] theorem join_principal_eq_sSup {s : Set (Filter \u03b1)} : join (\ud835\udcdf s) = sSup s", "start": [675, 1], "end": [675, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_univ", "code": "@[simp] theorem principal_univ : \ud835\udcdf (univ : Set \u03b1) = \u22a4", "start": [678, 1], "end": [679, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_empty", "code": "@[simp]\ntheorem principal_empty : \ud835\udcdf (\u2205 : Set \u03b1) = \u22a5", "start": [682, 1], "end": [684, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_eq_biInf", "code": "theorem generate_eq_biInf (S : Set (Set \u03b1)) : generate S = \u2a05 s \u2208 S, \ud835\udcdf s", "start": [687, 1], "end": [688, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.empty_mem_iff_bot", "code": "theorem empty_mem_iff_bot {f : Filter \u03b1} : \u2205 \u2208 f \u2194 f = \u22a5", "start": [693, 1], "end": [694, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.nonempty_of_mem", "code": "theorem nonempty_of_mem {f : Filter \u03b1} [hf : NeBot f] {s : Set \u03b1} (hs : s \u2208 f) : s.Nonempty", "start": [697, 1], "end": [698, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.nonempty_of_mem", "code": "theorem NeBot.nonempty_of_mem {f : Filter \u03b1} (hf : NeBot f) {s : Set \u03b1} (hs : s \u2208 f) : s.Nonempty", "start": [701, 1], "end": [702, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.empty_not_mem", "code": "@[simp]\ntheorem empty_not_mem (f : Filter \u03b1) [NeBot f] : \u00ac\u2205 \u2208 f", "start": [705, 1], "end": [706, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.nonempty_of_neBot", "code": "theorem nonempty_of_neBot (f : Filter \u03b1) [NeBot f] : Nonempty \u03b1", "start": [709, 1], "end": [710, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_not_mem", "code": "theorem compl_not_mem {f : Filter \u03b1} {s : Set \u03b1} [NeBot f] (h : s \u2208 f) : s\u1d9c \u2209 f", "start": [713, 1], "end": [714, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.filter_eq_bot_of_isEmpty", "code": "theorem filter_eq_bot_of_isEmpty [IsEmpty \u03b1] (f : Filter \u03b1) : f = \u22a5", "start": [717, 1], "end": [718, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_iff", "code": "protected lemma disjoint_iff {f g : Filter \u03b1} : Disjoint f g \u2194 \u2203 s \u2208 f, \u2203 t \u2208 g, Disjoint s t := by\n  simp only [disjoint_iff, \u2190 empty_mem_iff_bot, mem_inf_iff, inf_eq_inter, bot_eq_empty,\n    @eq_comm _ \u2205]", "start": [721, 1], "end": [723, 18], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.disjoint_of_disjoint_of_mem", "code": "theorem disjoint_of_disjoint_of_mem {f g : Filter \u03b1} {s t : Set \u03b1} (h : Disjoint s t) (hs : s \u2208 f)\n    (ht : t \u2208 g) : Disjoint f g", "start": [726, 1], "end": [728, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.not_disjoint", "code": "theorem NeBot.not_disjoint (hf : f.NeBot) (hs : s \u2208 f) (ht : t \u2208 f) : \u00acDisjoint s t", "start": [731, 1], "end": [732, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_eq_bot_iff", "code": "theorem inf_eq_bot_iff {f g : Filter \u03b1} : f \u2293 g = \u22a5 \u2194 \u2203 U \u2208 f, \u2203 V \u2208 g, U \u2229 V = \u2205", "start": [735, 1], "end": [736, 83], "kind": "commanddeclaration"}, {"full_name": "Pairwise.exists_mem_filter_of_disjoint", "code": "theorem _root_.Pairwise.exists_mem_filter_of_disjoint {\u03b9 : Type*} [Finite \u03b9] {l : \u03b9 \u2192 Filter \u03b1}\n    (hd : Pairwise (Disjoint on l)) :\n    \u2203 s : \u03b9 \u2192 Set \u03b1, (\u2200 i, s i \u2208 l i) \u2227 Pairwise (Disjoint on s)", "start": [739, 1], "end": [748, 60], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.exists_mem_filter", "code": "theorem _root_.Set.PairwiseDisjoint.exists_mem_filter {\u03b9 : Type*} {l : \u03b9 \u2192 Filter \u03b1} {t : Set \u03b9}\n    (hd : t.PairwiseDisjoint l) (ht : t.Finite) :\n    \u2203 s : \u03b9 \u2192 Set \u03b1, (\u2200 i, s i \u2208 l i) \u2227 t.PairwiseDisjoint s", "start": [751, 1], "end": [759, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.unique", "code": "instance unique [IsEmpty \u03b1] : Unique (Filter \u03b1) where\n  default := \u22a5\n  uniq := filter_eq_bot_of_isEmpty", "start": [762, 1], "end": [765, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.eq_top_of_neBot", "code": "theorem eq_top_of_neBot [Subsingleton \u03b1] (l : Filter \u03b1) [NeBot l] : l = \u22a4", "start": [768, 1], "end": [773, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.forall_mem_nonempty_iff_neBot", "code": "theorem forall_mem_nonempty_iff_neBot {f : Filter \u03b1} :\n    (\u2200 s : Set \u03b1, s \u2208 f \u2192 s.Nonempty) \u2194 NeBot f", "start": [776, 1], "end": [778, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.instNontrivialFilter", "code": "instance instNontrivialFilter [Nonempty \u03b1] : Nontrivial (Filter \u03b1) :=\n  \u27e8\u27e8\u22a4, \u22a5, NeBot.ne <| forall_mem_nonempty_iff_neBot.1\n    fun s hs => by rwa [mem_top.1 hs, \u2190 nonempty_iff_univ_nonempty]\u27e9\u27e9", "start": [781, 1], "end": [783, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.nontrivial_iff_nonempty", "code": "theorem nontrivial_iff_nonempty : Nontrivial (Filter \u03b1) \u2194 Nonempty \u03b1", "start": [785, 1], "end": [790, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.eq_sInf_of_mem_iff_exists_mem", "code": "theorem eq_sInf_of_mem_iff_exists_mem {S : Set (Filter \u03b1)} {l : Filter \u03b1}\n    (h : \u2200 {s}, s \u2208 l \u2194 \u2203 f \u2208 S, s \u2208 f) : l = sInf S", "start": [793, 1], "end": [796, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.eq_iInf_of_mem_iff_exists_mem", "code": "theorem eq_iInf_of_mem_iff_exists_mem {f : \u03b9 \u2192 Filter \u03b1} {l : Filter \u03b1}\n    (h : \u2200 {s}, s \u2208 l \u2194 \u2203 i, s \u2208 f i) : l = iInf f", "start": [799, 1], "end": [801, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.eq_biInf_of_mem_iff_exists_mem", "code": "theorem eq_biInf_of_mem_iff_exists_mem {f : \u03b9 \u2192 Filter \u03b1} {p : \u03b9 \u2192 Prop} {l : Filter \u03b1}\n    (h : \u2200 {s}, s \u2208 l \u2194 \u2203 i, p i \u2227 s \u2208 f i) : l = \u2a05 (i) (_ : p i), f i", "start": [805, 1], "end": [808, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_sets_eq", "code": "theorem iInf_sets_eq {f : \u03b9 \u2192 Filter \u03b1} (h : Directed (\u00b7 \u2265 \u00b7) f) [ne : Nonempty \u03b9] :\n    (iInf f).sets = \u22c3 i, (f i).sets", "start": [811, 1], "end": [827, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_of_directed", "code": "theorem mem_iInf_of_directed {f : \u03b9 \u2192 Filter \u03b1} (h : Directed (\u00b7 \u2265 \u00b7) f) [Nonempty \u03b9] (s) :\n    s \u2208 iInf f \u2194 \u2203 i, s \u2208 f i", "start": [830, 1], "end": [832, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_biInf_of_directed", "code": "theorem mem_biInf_of_directed {f : \u03b2 \u2192 Filter \u03b1} {s : Set \u03b2} (h : DirectedOn (f \u207b\u00b9'o (\u00b7 \u2265 \u00b7)) s)\n    (ne : s.Nonempty) {t : Set \u03b1} : (t \u2208 \u2a05 i \u2208 s, f i) \u2194 \u2203 i \u2208 s, t \u2208 f i", "start": [835, 1], "end": [838, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.biInf_sets_eq", "code": "theorem biInf_sets_eq {f : \u03b2 \u2192 Filter \u03b1} {s : Set \u03b2} (h : DirectedOn (f \u207b\u00b9'o (\u00b7 \u2265 \u00b7)) s)\n    (ne : s.Nonempty) : (\u2a05 i \u2208 s, f i).sets = \u22c3 i \u2208 s, (f i).sets", "start": [841, 1], "end": [843, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_sets_eq_finite", "code": "theorem iInf_sets_eq_finite {\u03b9 : Type*} (f : \u03b9 \u2192 Filter \u03b1) :\n    (\u2a05 i, f i).sets = \u22c3 t : Finset \u03b9, (\u2a05 i \u2208 t, f i).sets", "start": [846, 1], "end": [849, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_sets_eq_finite'", "code": "theorem iInf_sets_eq_finite' (f : \u03b9 \u2192 Filter \u03b1) :\n    (\u2a05 i, f i).sets = \u22c3 t : Finset (PLift \u03b9), (\u2a05 i \u2208 t, f (PLift.down i)).sets", "start": [852, 1], "end": [855, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_finite", "code": "theorem mem_iInf_finite {\u03b9 : Type*} {f : \u03b9 \u2192 Filter \u03b1} (s) :\n    s \u2208 iInf f \u2194 \u2203 t : Finset \u03b9, s \u2208 \u2a05 i \u2208 t, f i", "start": [858, 1], "end": [860, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_finite'", "code": "theorem mem_iInf_finite' {f : \u03b9 \u2192 Filter \u03b1} (s) :\n    s \u2208 iInf f \u2194 \u2203 t : Finset (PLift \u03b9), s \u2208 \u2a05 i \u2208 t, f (PLift.down i)", "start": [863, 1], "end": [865, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_join", "code": "@[simp]\ntheorem sup_join {f\u2081 f\u2082 : Filter (Filter \u03b1)} : join f\u2081 \u2294 join f\u2082 = join (f\u2081 \u2294 f\u2082)", "start": [868, 1], "end": [870, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.iSup_join", "code": "@[simp]\ntheorem iSup_join {\u03b9 : Sort w} {f : \u03b9 \u2192 Filter (Filter \u03b1)} : \u2a06 x, join (f x) = join (\u2a06 x, f x)", "start": [873, 1], "end": [875, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iInf_finset", "code": "theorem mem_iInf_finset {s : Finset \u03b1} {f : \u03b1 \u2192 Filter \u03b2} {t : Set \u03b2} :\n    (t \u2208 \u2a05 a \u2208 s, f a) \u2194 \u2203 p : \u03b1 \u2192 Set \u03b2, (\u2200 a \u2208 s, p a \u2208 f a) \u2227 t = \u22c2 a \u2208 s, p a", "start": [902, 1], "end": [913, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_neBot_of_directed'", "code": "theorem iInf_neBot_of_directed' {f : \u03b9 \u2192 Filter \u03b1} [Nonempty \u03b9] (hd : Directed (\u00b7 \u2265 \u00b7) f) :\n    (\u2200 i, NeBot (f i)) \u2192 NeBot (iInf f)", "start": [916, 1], "end": [921, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_neBot_of_directed", "code": "theorem iInf_neBot_of_directed {f : \u03b9 \u2192 Filter \u03b1} [hn : Nonempty \u03b1] (hd : Directed (\u00b7 \u2265 \u00b7) f)\n    (hb : \u2200 i, NeBot (f i)) : NeBot (iInf f)", "start": [924, 1], "end": [931, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.sInf_neBot_of_directed'", "code": "theorem sInf_neBot_of_directed' {s : Set (Filter \u03b1)} (hne : s.Nonempty) (hd : DirectedOn (\u00b7 \u2265 \u00b7) s)\n    (hbot : \u22a5 \u2209 s) : NeBot (sInf s)", "start": [934, 1], "end": [938, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.sInf_neBot_of_directed", "code": "theorem sInf_neBot_of_directed [Nonempty \u03b1] {s : Set (Filter \u03b1)} (hd : DirectedOn (\u00b7 \u2265 \u00b7) s)\n    (hbot : \u22a5 \u2209 s) : NeBot (sInf s)", "start": [941, 1], "end": [944, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_neBot_iff_of_directed'", "code": "theorem iInf_neBot_iff_of_directed' {f : \u03b9 \u2192 Filter \u03b1} [Nonempty \u03b9] (hd : Directed (\u00b7 \u2265 \u00b7) f) :\n    NeBot (iInf f) \u2194 \u2200 i, NeBot (f i)", "start": [947, 1], "end": [949, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_neBot_iff_of_directed", "code": "theorem iInf_neBot_iff_of_directed {f : \u03b9 \u2192 Filter \u03b1} [Nonempty \u03b1] (hd : Directed (\u00b7 \u2265 \u00b7) f) :\n    NeBot (iInf f) \u2194 \u2200 i, NeBot (f i)", "start": [952, 1], "end": [954, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_sets_induct", "code": "@[elab_as_elim]\ntheorem iInf_sets_induct {f : \u03b9 \u2192 Filter \u03b1} {s : Set \u03b1} (hs : s \u2208 iInf f) {p : Set \u03b1 \u2192 Prop}\n    (uni : p univ) (ins : \u2200 {i s\u2081 s\u2082}, s\u2081 \u2208 f i \u2192 p s\u2082 \u2192 p (s\u2081 \u2229 s\u2082)) : p s", "start": [957, 1], "end": [968, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_principal", "code": "@[simp]\ntheorem inf_principal {s t : Set \u03b1} : \ud835\udcdf s \u2293 \ud835\udcdf t = \ud835\udcdf (s \u2229 t)", "start": [973, 1], "end": [977, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_principal", "code": "@[simp]\ntheorem sup_principal {s t : Set \u03b1} : \ud835\udcdf s \u2294 \ud835\udcdf t = \ud835\udcdf (s \u222a t)", "start": [980, 1], "end": [982, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.iSup_principal", "code": "@[simp]\ntheorem iSup_principal {\u03b9 : Sort w} {s : \u03b9 \u2192 Set \u03b1} : \u2a06 x, \ud835\udcdf (s x) = \ud835\udcdf (\u22c3 i, s i)", "start": [985, 1], "end": [987, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_eq_bot_iff", "code": "@[simp]\ntheorem principal_eq_bot_iff {s : Set \u03b1} : \ud835\udcdf s = \u22a5 \u2194 s = \u2205", "start": [990, 1], "end": [992, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_neBot_iff", "code": "@[simp]\ntheorem principal_neBot_iff {s : Set \u03b1} : NeBot (\ud835\udcdf s) \u2194 s.Nonempty", "start": [995, 1], "end": [997, 87], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.principal_neBot", "code": "alias \u27e8_, _root_.Set.Nonempty.principal_neBot\u27e9 := principal_neBot_iff", "start": [1000, 1], "end": [1000, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.isCompl_principal", "code": "theorem isCompl_principal (s : Set \u03b1) : IsCompl (\ud835\udcdf s) (\ud835\udcdf s\u1d9c)", "start": [1003, 1], "end": [1005, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_principal'", "code": "theorem mem_inf_principal' {f : Filter \u03b1} {s t : Set \u03b1} : s \u2208 f \u2293 \ud835\udcdf t \u2194 t\u1d9c \u222a s \u2208 f", "start": [1008, 1], "end": [1010, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inf_principal", "code": "lemma mem_inf_principal {f : Filter \u03b1} {s t : Set \u03b1} : s \u2208 f \u2293 \ud835\udcdf t \u2194 { x | x \u2208 t \u2192 x \u2208 s } \u2208 f := by\n  simp only [mem_inf_principal', imp_iff_not_or]\n  rfl", "start": [1013, 1], "end": [1015, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.iSup_inf_principal", "code": "lemma iSup_inf_principal (f : \u03b9 \u2192 Filter \u03b1) (s : Set \u03b1) : \u2a06 i, f i \u2293 \ud835\udcdf s = (\u2a06 i, f i) \u2293 \ud835\udcdf s := by\n  ext\n  simp only [mem_iSup, mem_inf_principal]", "start": [1018, 1], "end": [1020, 42], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.inf_principal_eq_bot", "code": "theorem inf_principal_eq_bot {f : Filter \u03b1} {s : Set \u03b1} : f \u2293 \ud835\udcdf s = \u22a5 \u2194 s\u1d9c \u2208 f", "start": [1023, 1], "end": [1025, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_of_eq_bot", "code": "theorem mem_of_eq_bot {f : Filter \u03b1} {s : Set \u03b1} (h : f \u2293 \ud835\udcdf s\u1d9c = \u22a5) : s \u2208 f", "start": [1028, 1], "end": [1029, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.diff_mem_inf_principal_compl", "code": "theorem diff_mem_inf_principal_compl {f : Filter \u03b1} {s : Set \u03b1} (hs : s \u2208 f) (t : Set \u03b1) :\n    s \\ t \u2208 f \u2293 \ud835\udcdf t\u1d9c", "start": [1032, 1], "end": [1034, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_le_iff", "code": "theorem principal_le_iff {s : Set \u03b1} {f : Filter \u03b1} : \ud835\udcdf s \u2264 f \u2194 \u2200 V \u2208 f, s \u2286 V", "start": [1037, 1], "end": [1039, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_principal_finset", "code": "@[simp]\ntheorem iInf_principal_finset {\u03b9 : Type w} (s : Finset \u03b9) (f : \u03b9 \u2192 Set \u03b1) :\n    \u2a05 i \u2208 s, \ud835\udcdf (f i) = \ud835\udcdf (\u22c2 i \u2208 s, f i)", "start": [1042, 1], "end": [1047, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_principal", "code": "@[simp]\ntheorem iInf_principal {\u03b9 : Type w} [Finite \u03b9] (f : \u03b9 \u2192 Set \u03b1) : \u2a05 i, \ud835\udcdf (f i) = \ud835\udcdf (\u22c2 i, f i)", "start": [1050, 1], "end": [1053, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf_principal_finite", "code": "theorem iInf_principal_finite {\u03b9 : Type w} {s : Set \u03b9} (hs : s.Finite) (f : \u03b9 \u2192 Set \u03b1) :\n    \u2a05 i \u2208 s, \ud835\udcdf (f i) = \ud835\udcdf (\u22c2 i \u2208 s, f i)", "start": [1056, 1], "end": [1059, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.join_mono", "code": "@[mono]\ntheorem join_mono {f\u2081 f\u2082 : Filter (Filter \u03b1)} (h : f\u2081 \u2264 f\u2082) : join f\u2081 \u2264 join f\u2082", "start": [1064, 1], "end": [1065, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually", "code": "protected def Eventually (p : \u03b1 \u2192 Prop) (f : Filter \u03b1) : Prop :=\n  { x | p x } \u2208 f", "start": [1070, 1], "end": [1073, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_iff", "code": "theorem eventually_iff {f : Filter \u03b1} {P : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in f, P x) \u2194 { x | P x } \u2208 f", "start": [1079, 1], "end": [1080, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_mem_set", "code": "@[simp]\ntheorem eventually_mem_set {s : Set \u03b1} {l : Filter \u03b1} : (\u2200\u1da0 x in l, x \u2208 s) \u2194 s \u2208 l", "start": [1083, 1], "end": [1085, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.ext'", "code": "protected theorem ext' {f\u2081 f\u2082 : Filter \u03b1}\n    (h : \u2200 p : \u03b1 \u2192 Prop, (\u2200\u1da0 x in f\u2081, p x) \u2194 \u2200\u1da0 x in f\u2082, p x) : f\u2081 = f\u2082", "start": [1088, 1], "end": [1090, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.filter_mono", "code": "theorem Eventually.filter_mono {f\u2081 f\u2082 : Filter \u03b1} (h : f\u2081 \u2264 f\u2082) {p : \u03b1 \u2192 Prop}\n    (hp : \u2200\u1da0 x in f\u2082, p x) : \u2200\u1da0 x in f\u2081, p x", "start": [1093, 1], "end": [1095, 7], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_of_mem", "code": "theorem eventually_of_mem {f : Filter \u03b1} {P : \u03b1 \u2192 Prop} {U : Set \u03b1} (hU : U \u2208 f)\n    (h : \u2200 x \u2208 U, P x) : \u2200\u1da0 x in f, P x", "start": [1098, 1], "end": [1100, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.and", "code": "protected theorem Eventually.and {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} :\n    f.Eventually p \u2192 f.Eventually q \u2192 \u2200\u1da0 x in f, p x \u2227 q x", "start": [1103, 1], "end": [1105, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_true", "code": "@[simp] theorem eventually_true (f : Filter \u03b1) : \u2200\u1da0 _ in f, True", "start": [1108, 1], "end": [1108, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_of_forall", "code": "theorem eventually_of_forall {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200 x, p x) : \u2200\u1da0 x in f, p x", "start": [1111, 1], "end": [1112, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_false_iff_eq_bot", "code": "@[simp]\ntheorem eventually_false_iff_eq_bot {f : Filter \u03b1} : (\u2200\u1da0 _ in f, False) \u2194 f = \u22a5", "start": [1115, 1], "end": [1117, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_const", "code": "@[simp]\ntheorem eventually_const {f : Filter \u03b1} [t : NeBot f] {p : Prop} : (\u2200\u1da0 _ in f, p) \u2194 p", "start": [1120, 1], "end": [1122, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_iff_exists_mem", "code": "theorem eventually_iff_exists_mem {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} :\n    (\u2200\u1da0 x in f, p x) \u2194 \u2203 v \u2208 f, \u2200 y \u2208 v, p y", "start": [1125, 1], "end": [1127, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_mem", "code": "theorem Eventually.exists_mem {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200\u1da0 x in f, p x) :\n    \u2203 v \u2208 f, \u2200 y \u2208 v, p y", "start": [1130, 1], "end": [1132, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.mp", "code": "theorem Eventually.mp {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200\u1da0 x in f, p x)\n    (hq : \u2200\u1da0 x in f, p x \u2192 q x) : \u2200\u1da0 x in f, q x", "start": [1135, 1], "end": [1137, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.mono", "code": "theorem Eventually.mono {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200\u1da0 x in f, p x)\n    (hq : \u2200 x, p x \u2192 q x) : \u2200\u1da0 x in f, q x", "start": [1140, 1], "end": [1142, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.forall_eventually_of_eventually_forall", "code": "theorem forall_eventually_of_eventually_forall {f : Filter \u03b1} {p : \u03b1 \u2192 \u03b2 \u2192 Prop}\n    (h : \u2200\u1da0 x in f, \u2200 y, p x y) : \u2200 y, \u2200\u1da0 x in f, p x y", "start": [1145, 1], "end": [1147, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_and", "code": "@[simp]\ntheorem eventually_and {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} :\n    (\u2200\u1da0 x in f, p x \u2227 q x) \u2194 (\u2200\u1da0 x in f, p x) \u2227 \u2200\u1da0 x in f, q x", "start": [1150, 1], "end": [1153, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.congr", "code": "theorem Eventually.congr {f : Filter \u03b1} {p q : \u03b1 \u2192 Prop} (h' : \u2200\u1da0 x in f, p x)\n    (h : \u2200\u1da0 x in f, p x \u2194 q x) : \u2200\u1da0 x in f, q x", "start": [1156, 1], "end": [1158, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_congr", "code": "theorem eventually_congr {f : Filter \u03b1} {p q : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in f, p x \u2194 q x) :\n    (\u2200\u1da0 x in f, p x) \u2194 \u2200\u1da0 x in f, q x", "start": [1161, 1], "end": [1163, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_all", "code": "@[simp]\ntheorem eventually_all {\u03b9 : Type*} [Finite \u03b9] {l} {p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i, p i x) \u2194 \u2200 i, \u2200\u1da0 x in l, p i x", "start": [1166, 1], "end": [1170, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_all_finite", "code": "@[simp]\ntheorem eventually_all_finite {\u03b9} {I : Set \u03b9} (hI : I.Finite) {l} {p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i \u2208 I, p i x) \u2194 \u2200 i \u2208 I, \u2200\u1da0 x in l, p i x", "start": [1173, 1], "end": [1176, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.eventually_all", "code": "alias _root_.Set.Finite.eventually_all := eventually_all_finite", "start": [1179, 1], "end": [1179, 64], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.eventually_all_finset", "code": "@[simp] theorem eventually_all_finset {\u03b9} (I : Finset \u03b9) {l} {p : \u03b9 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, \u2200 i \u2208 I, p i x) \u2194 \u2200 i \u2208 I, \u2200\u1da0 x in l, p i x", "start": [1184, 1], "end": [1186, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.eventually_all", "code": "alias _root_.Finset.eventually_all := eventually_all_finset", "start": [1189, 1], "end": [1189, 60], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.eventually_or_distrib_left", "code": "@[simp]\ntheorem eventually_or_distrib_left {f : Filter \u03b1} {p : Prop} {q : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in f, p \u2228 q x) \u2194 p \u2228 \u2200\u1da0 x in f, q x", "start": [1194, 1], "end": [1197, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_or_distrib_right", "code": "@[simp]\ntheorem eventually_or_distrib_right {f : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2200\u1da0 x in f, p x \u2228 q) \u2194 (\u2200\u1da0 x in f, p x) \u2228 q", "start": [1200, 1], "end": [1203, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_imp_distrib_left", "code": "@[simp]\ntheorem eventually_imp_distrib_left {f : Filter \u03b1} {p : Prop} {q : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in f, p \u2192 q x) \u2194 p \u2192 \u2200\u1da0 x in f, q x", "start": [1206, 1], "end": [1209, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_bot", "code": "@[simp]\ntheorem eventually_bot {p : \u03b1 \u2192 Prop} : \u2200\u1da0 x in \u22a5, p x", "start": [1212, 1], "end": [1214, 5], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_top", "code": "@[simp]\ntheorem eventually_top {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in \u22a4, p x) \u2194 \u2200 x, p x", "start": [1217, 1], "end": [1219, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_sup", "code": "@[simp]\ntheorem eventually_sup {p : \u03b1 \u2192 Prop} {f g : Filter \u03b1} :\n    (\u2200\u1da0 x in f \u2294 g, p x) \u2194 (\u2200\u1da0 x in f, p x) \u2227 \u2200\u1da0 x in g, p x", "start": [1222, 1], "end": [1225, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_sSup", "code": "@[simp]\ntheorem eventually_sSup {p : \u03b1 \u2192 Prop} {fs : Set (Filter \u03b1)} :\n    (\u2200\u1da0 x in sSup fs, p x) \u2194 \u2200 f \u2208 fs, \u2200\u1da0 x in f, p x", "start": [1228, 1], "end": [1231, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_iSup", "code": "@[simp]\ntheorem eventually_iSup {p : \u03b1 \u2192 Prop} {fs : \u03b9 \u2192 Filter \u03b1} :\n    (\u2200\u1da0 x in \u2a06 b, fs b, p x) \u2194 \u2200 b, \u2200\u1da0 x in fs b, p x", "start": [1234, 1], "end": [1237, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_principal", "code": "@[simp]\ntheorem eventually_principal {a : Set \u03b1} {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in \ud835\udcdf a, p x) \u2194 \u2200 x \u2208 a, p x", "start": [1240, 1], "end": [1242, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_inf", "code": "theorem eventually_inf {f g : Filter \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u2293 g, p x) \u2194 \u2203 s \u2208 f, \u2203 t \u2208 g, \u2200 x \u2208 s \u2229 t, p x", "start": [1245, 1], "end": [1247, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_inf_principal", "code": "theorem eventually_inf_principal {f : Filter \u03b1} {p : \u03b1 \u2192 Prop} {s : Set \u03b1} :\n    (\u2200\u1da0 x in f \u2293 \ud835\udcdf s, p x) \u2194 \u2200\u1da0 x in f, x \u2208 s \u2192 p x", "start": [1250, 1], "end": [1252, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently", "code": "protected def Frequently (p : \u03b1 \u2192 Prop) (f : Filter \u03b1) : Prop :=\n  \u00ac\u2200\u1da0 x in f, \u00acp x", "start": [1257, 1], "end": [1260, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.frequently", "code": "theorem Eventually.frequently {f : Filter \u03b1} [NeBot f] {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in f, p x) :\n    \u2203\u1da0 x in f, p x", "start": [1266, 1], "end": [1268, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_of_forall", "code": "theorem frequently_of_forall {f : Filter \u03b1} [NeBot f] {p : \u03b1 \u2192 Prop} (h : \u2200 x, p x) :\n    \u2203\u1da0 x in f, p x", "start": [1271, 1], "end": [1273, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.mp", "code": "theorem Frequently.mp {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (h : \u2203\u1da0 x in f, p x)\n    (hpq : \u2200\u1da0 x in f, p x \u2192 q x) : \u2203\u1da0 x in f, q x", "start": [1276, 1], "end": [1278, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.filter_mono", "code": "theorem Frequently.filter_mono {p : \u03b1 \u2192 Prop} {f g : Filter \u03b1} (h : \u2203\u1da0 x in f, p x) (hle : f \u2264 g) :\n    \u2203\u1da0 x in g, p x", "start": [1281, 1], "end": [1283, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.mono", "code": "theorem Frequently.mono {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (h : \u2203\u1da0 x in f, p x)\n    (hpq : \u2200 x, p x \u2192 q x) : \u2203\u1da0 x in f, q x", "start": [1286, 1], "end": [1288, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.and_eventually", "code": "theorem Frequently.and_eventually {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2203\u1da0 x in f, p x)\n    (hq : \u2200\u1da0 x in f, q x) : \u2203\u1da0 x in f, p x \u2227 q x", "start": [1291, 1], "end": [1294, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.and_frequently", "code": "theorem Eventually.and_frequently {p q : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2200\u1da0 x in f, p x)\n    (hq : \u2203\u1da0 x in f, q x) : \u2203\u1da0 x in f, p x \u2227 q x", "start": [1297, 1], "end": [1299, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.exists", "code": "theorem Frequently.exists {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} (hp : \u2203\u1da0 x in f, p x) : \u2203 x, p x", "start": [1302, 1], "end": [1305, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists", "code": "theorem Eventually.exists {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} [NeBot f] (hp : \u2200\u1da0 x in f, p x) :\n    \u2203 x, p x", "start": [1308, 1], "end": [1310, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_iff_forall_eventually_exists_and", "code": "theorem frequently_iff_forall_eventually_exists_and {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} :\n    (\u2203\u1da0 x in f, p x) \u2194 \u2200 {q : \u03b1 \u2192 Prop}, (\u2200\u1da0 x in f, q x) \u2192 \u2203 x, p x \u2227 q x", "start": [1313, 1], "end": [1316, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_iff", "code": "theorem frequently_iff {f : Filter \u03b1} {P : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, P x) \u2194 \u2200 {U}, U \u2208 f \u2192 \u2203 x \u2208 U, P x", "start": [1319, 1], "end": [1322, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.not_eventually", "code": "@[simp]\ntheorem not_eventually {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} : (\u00ac\u2200\u1da0 x in f, p x) \u2194 \u2203\u1da0 x in f, \u00acp x", "start": [1325, 1], "end": [1327, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.not_frequently", "code": "@[simp]\ntheorem not_frequently {p : \u03b1 \u2192 Prop} {f : Filter \u03b1} : (\u00ac\u2203\u1da0 x in f, p x) \u2194 \u2200\u1da0 x in f, \u00acp x", "start": [1330, 1], "end": [1332, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_true_iff_neBot", "code": "@[simp]\ntheorem frequently_true_iff_neBot (f : Filter \u03b1) : (\u2203\u1da0 _ in f, True) \u2194 NeBot f", "start": [1335, 1], "end": [1337, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_false", "code": "@[simp]\ntheorem frequently_false (f : Filter \u03b1) : \u00ac\u2203\u1da0 _ in f, False", "start": [1340, 1], "end": [1341, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_const", "code": "@[simp]\ntheorem frequently_const {f : Filter \u03b1} [NeBot f] {p : Prop} : (\u2203\u1da0 _ in f, p) \u2194 p", "start": [1344, 1], "end": [1346, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_or_distrib", "code": "@[simp]\ntheorem frequently_or_distrib {f : Filter \u03b1} {p q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p x \u2228 q x) \u2194 (\u2203\u1da0 x in f, p x) \u2228 \u2203\u1da0 x in f, q x", "start": [1349, 1], "end": [1352, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_or_distrib_left", "code": "theorem frequently_or_distrib_left {f : Filter \u03b1} [NeBot f] {p : Prop} {q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p \u2228 q x) \u2194 p \u2228 \u2203\u1da0 x in f, q x", "start": [1355, 1], "end": [1356, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_or_distrib_right", "code": "theorem frequently_or_distrib_right {f : Filter \u03b1} [NeBot f] {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2203\u1da0 x in f, p x \u2228 q) \u2194 (\u2203\u1da0 x in f, p x) \u2228 q", "start": [1359, 1], "end": [1360, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_imp_distrib", "code": "@[simp]\ntheorem frequently_imp_distrib {f : Filter \u03b1} {p q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p x \u2192 q x) \u2194 (\u2200\u1da0 x in f, p x) \u2192 \u2203\u1da0 x in f, q x", "start": [1363, 1], "end": [1366, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_imp_distrib_left", "code": "theorem frequently_imp_distrib_left {f : Filter \u03b1} [NeBot f] {p : Prop} {q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p \u2192 q x) \u2194 p \u2192 \u2203\u1da0 x in f, q x", "start": [1369, 1], "end": [1370, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_imp_distrib_right", "code": "theorem frequently_imp_distrib_right {f : Filter \u03b1} [NeBot f] {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2203\u1da0 x in f, p x \u2192 q) \u2194 (\u2200\u1da0 x in f, p x) \u2192 q", "start": [1373, 1], "end": [1374, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_imp_distrib_right", "code": "@[simp]\ntheorem eventually_imp_distrib_right {f : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2200\u1da0 x in f, p x \u2192 q) \u2194 (\u2203\u1da0 x in f, p x) \u2192 q", "start": [1377, 1], "end": [1380, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_and_distrib_left", "code": "@[simp]\ntheorem frequently_and_distrib_left {f : Filter \u03b1} {p : Prop} {q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in f, p \u2227 q x) \u2194 p \u2227 \u2203\u1da0 x in f, q x", "start": [1383, 1], "end": [1386, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_and_distrib_right", "code": "@[simp]\ntheorem frequently_and_distrib_right {f : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    (\u2203\u1da0 x in f, p x \u2227 q) \u2194 (\u2203\u1da0 x in f, p x) \u2227 q", "start": [1389, 1], "end": [1392, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_bot", "code": "@[simp]\ntheorem frequently_bot {p : \u03b1 \u2192 Prop} : \u00ac\u2203\u1da0 x in \u22a5, p x", "start": [1395, 1], "end": [1396, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_top", "code": "@[simp]\ntheorem frequently_top {p : \u03b1 \u2192 Prop} : (\u2203\u1da0 x in \u22a4, p x) \u2194 \u2203 x, p x", "start": [1399, 1], "end": [1400, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_principal", "code": "@[simp]\ntheorem frequently_principal {a : Set \u03b1} {p : \u03b1 \u2192 Prop} : (\u2203\u1da0 x in \ud835\udcdf a, p x) \u2194 \u2203 x \u2208 a, p x", "start": [1403, 1], "end": [1405, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_sup", "code": "theorem frequently_sup {p : \u03b1 \u2192 Prop} {f g : Filter \u03b1} :\n    (\u2203\u1da0 x in f \u2294 g, p x) \u2194 (\u2203\u1da0 x in f, p x) \u2228 \u2203\u1da0 x in g, p x", "start": [1408, 1], "end": [1410, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_sSup", "code": "@[simp]\ntheorem frequently_sSup {p : \u03b1 \u2192 Prop} {fs : Set (Filter \u03b1)} :\n    (\u2203\u1da0 x in sSup fs, p x) \u2194 \u2203 f \u2208 fs, \u2203\u1da0 x in f, p x", "start": [1413, 1], "end": [1416, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_iSup", "code": "@[simp]\ntheorem frequently_iSup {p : \u03b1 \u2192 Prop} {fs : \u03b2 \u2192 Filter \u03b1} :\n    (\u2203\u1da0 x in \u2a06 b, fs b, p x) \u2194 \u2203 b, \u2203\u1da0 x in fs b, p x", "start": [1419, 1], "end": [1422, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.choice", "code": "theorem Eventually.choice {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {l : Filter \u03b1} [l.NeBot] (h : \u2200\u1da0 x in l, \u2203 y, r x y) :\n    \u2203 f : \u03b1 \u2192 \u03b2, \u2200\u1da0 x in l, r x (f x)", "start": [1425, 1], "end": [1429, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq", "code": "def EventuallyEq (l : Filter \u03b1) (f g : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200\u1da0 x in l, f x = g x", "start": [1436, 1], "end": [1439, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.eventually", "code": "theorem EventuallyEq.eventually {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) :\n    \u2200\u1da0 x in l, f x = g x", "start": [1445, 1], "end": [1447, 4], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.rw", "code": "theorem EventuallyEq.rw {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) (p : \u03b1 \u2192 \u03b2 \u2192 Prop)\n    (hf : \u2200\u1da0 x in l, p x (f x)) : \u2200\u1da0 x in l, p x (g x)", "start": [1450, 1], "end": [1452, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_set", "code": "theorem eventuallyEq_set {s t : Set \u03b1} {l : Filter \u03b1} : s =\u1da0[l] t \u2194 \u2200\u1da0 x in l, x \u2208 s \u2194 x \u2208 t", "start": [1455, 1], "end": [1456, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.mem_iff", "code": "alias \u27e8EventuallyEq.mem_iff, Eventually.set_eq\u27e9 := eventuallyEq_set", "start": [1459, 1], "end": [1459, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Eventually.set_eq", "code": "alias \u27e8EventuallyEq.mem_iff, Eventually.set_eq\u27e9 := eventuallyEq_set", "start": [1459, 1], "end": [1459, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.eventuallyEq_univ", "code": "@[simp]\ntheorem eventuallyEq_univ {s : Set \u03b1} {l : Filter \u03b1} : s =\u1da0[l] univ \u2194 s \u2208 l", "start": [1463, 1], "end": [1465, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.exists_mem", "code": "theorem EventuallyEq.exists_mem {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) :\n    \u2203 s \u2208 l, EqOn f g s", "start": [1468, 1], "end": [1470, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_of_mem", "code": "theorem eventuallyEq_of_mem {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : s \u2208 l) (h : EqOn f g s) :\n    f =\u1da0[l] g", "start": [1473, 1], "end": [1475, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_iff_exists_mem", "code": "theorem eventuallyEq_iff_exists_mem {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} :\n    f =\u1da0[l] g \u2194 \u2203 s \u2208 l, EqOn f g s", "start": [1478, 1], "end": [1480, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.filter_mono", "code": "theorem EventuallyEq.filter_mono {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h\u2081 : f =\u1da0[l] g) (h\u2082 : l' \u2264 l) :\n    f =\u1da0[l'] g", "start": [1483, 1], "end": [1485, 8], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.refl", "code": "@[refl]\ntheorem EventuallyEq.refl (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) : f =\u1da0[l] f", "start": [1488, 1], "end": [1490, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.rfl", "code": "theorem EventuallyEq.rfl {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2} : f =\u1da0[l] f", "start": [1493, 1], "end": [1494, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.symm", "code": "@[symm]\ntheorem EventuallyEq.symm {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (H : f =\u1da0[l] g) : g =\u1da0[l] f", "start": [1497, 1], "end": [1499, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans", "code": "@[trans]\ntheorem EventuallyEq.trans {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2} (H\u2081 : f =\u1da0[l] g) (H\u2082 : g =\u1da0[l] h) :\n    f =\u1da0[l] h", "start": [1502, 1], "end": [1505, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.prod_mk", "code": "theorem EventuallyEq.prod_mk {l} {f f' : \u03b1 \u2192 \u03b2} (hf : f =\u1da0[l] f') {g g' : \u03b1 \u2192 \u03b3} (hg : g =\u1da0[l] g') :\n    (fun x => (f x, g x)) =\u1da0[l] fun x => (f' x, g' x)", "start": [1512, 1], "end": [1517, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.fun_comp", "code": "theorem EventuallyEq.fun_comp {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (H : f =\u1da0[l] g) (h : \u03b2 \u2192 \u03b3) :\n    h \u2218 f =\u1da0[l] h \u2218 g", "start": [1520, 1], "end": [1522, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.comp\u2082", "code": "theorem EventuallyEq.comp\u2082 {\u03b4} {f f' : \u03b1 \u2192 \u03b2} {g g' : \u03b1 \u2192 \u03b3} {l} (Hf : f =\u1da0[l] f') (h : \u03b2 \u2192 \u03b3 \u2192 \u03b4)\n    (Hg : g =\u1da0[l] g') : (fun x => h (f x) (g x)) =\u1da0[l] fun x => h (f' x) (g' x)", "start": [1525, 1], "end": [1527, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.mul", "code": "@[to_additive]\ntheorem EventuallyEq.mul [Mul \u03b2] {f f' g g' : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (h : f =\u1da0[l] g)\n    (h' : f' =\u1da0[l] g') : (fun x => f x * f' x) =\u1da0[l] fun x => g x * g' x", "start": [1530, 1], "end": [1533, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.inv", "code": "@[to_additive]\ntheorem EventuallyEq.inv [Inv \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (h : f =\u1da0[l] g) :\n    (fun x => (f x)\u207b\u00b9) =\u1da0[l] fun x => (g x)\u207b\u00b9", "start": [1537, 1], "end": [1540, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.div", "code": "@[to_additive]\ntheorem EventuallyEq.div [Div \u03b2] {f f' g g' : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (h : f =\u1da0[l] g)\n    (h' : f' =\u1da0[l] g') : (fun x => f x / f' x) =\u1da0[l] fun x => g x / g' x", "start": [1544, 1], "end": [1547, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.const_smul", "code": "@[to_additive]\ntheorem EventuallyEq.const_smul {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g)\n    (c : \ud835\udd5c) : (fun x => c \u2022 f x) =\u1da0[l] fun x => c \u2022 g x", "start": [1551, 1], "end": [1554, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.smul", "code": "@[to_additive]\ntheorem EventuallyEq.smul {\ud835\udd5c} [SMul \ud835\udd5c \u03b2] {l : Filter \u03b1} {f f' : \u03b1 \u2192 \ud835\udd5c} {g g' : \u03b1 \u2192 \u03b2}\n    (hf : f =\u1da0[l] f') (hg : g =\u1da0[l] g') : (fun x => f x \u2022 g x) =\u1da0[l] fun x => f' x \u2022 g' x", "start": [1558, 1], "end": [1561, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.sup", "code": "theorem EventuallyEq.sup [Sup \u03b2] {l : Filter \u03b1} {f f' g g' : \u03b1 \u2192 \u03b2} (hf : f =\u1da0[l] f')\n    (hg : g =\u1da0[l] g') : (fun x => f x \u2294 g x) =\u1da0[l] fun x => f' x \u2294 g' x", "start": [1565, 1], "end": [1567, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.inf", "code": "theorem EventuallyEq.inf [Inf \u03b2] {l : Filter \u03b1} {f f' g g' : \u03b1 \u2192 \u03b2} (hf : f =\u1da0[l] f')\n    (hg : g =\u1da0[l] g') : (fun x => f x \u2293 g x) =\u1da0[l] fun x => f' x \u2293 g' x", "start": [1570, 1], "end": [1572, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.preimage", "code": "theorem EventuallyEq.preimage {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) (s : Set \u03b2) :\n    f \u207b\u00b9' s =\u1da0[l] g \u207b\u00b9' s", "start": [1575, 1], "end": [1577, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.inter", "code": "theorem EventuallyEq.inter {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s =\u1da0[l] t) (h' : s' =\u1da0[l] t') :\n    (s \u2229 s' : Set \u03b1) =\u1da0[l] (t \u2229 t' : Set \u03b1)", "start": [1580, 1], "end": [1582, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.union", "code": "theorem EventuallyEq.union {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s =\u1da0[l] t) (h' : s' =\u1da0[l] t') :\n    (s \u222a s' : Set \u03b1) =\u1da0[l] (t \u222a t' : Set \u03b1)", "start": [1585, 1], "end": [1587, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.compl", "code": "theorem EventuallyEq.compl {s t : Set \u03b1} {l : Filter \u03b1} (h : s =\u1da0[l] t) :\n    (s\u1d9c : Set \u03b1) =\u1da0[l] (t\u1d9c : Set \u03b1)", "start": [1590, 1], "end": [1592, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.diff", "code": "theorem EventuallyEq.diff {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s =\u1da0[l] t) (h' : s' =\u1da0[l] t') :\n    (s \\ s' : Set \u03b1) =\u1da0[l] (t \\ t' : Set \u03b1)", "start": [1595, 1], "end": [1597, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_empty", "code": "theorem eventuallyEq_empty {s : Set \u03b1} {l : Filter \u03b1} : s =\u1da0[l] (\u2205 : Set \u03b1) \u2194 \u2200\u1da0 x in l, x \u2209 s", "start": [1600, 1], "end": [1601, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.inter_eventuallyEq_left", "code": "theorem inter_eventuallyEq_left {s t : Set \u03b1} {l : Filter \u03b1} :\n    (s \u2229 t : Set \u03b1) =\u1da0[l] s \u2194 \u2200\u1da0 x in l, x \u2208 s \u2192 x \u2208 t", "start": [1604, 1], "end": [1606, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.inter_eventuallyEq_right", "code": "theorem inter_eventuallyEq_right {s t : Set \u03b1} {l : Filter \u03b1} :\n    (s \u2229 t : Set \u03b1) =\u1da0[l] t \u2194 \u2200\u1da0 x in l, x \u2208 t \u2192 x \u2208 s", "start": [1609, 1], "end": [1611, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_principal", "code": "@[simp]\ntheorem eventuallyEq_principal {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} : f =\u1da0[\ud835\udcdf s] g \u2194 EqOn f g s", "start": [1614, 1], "end": [1616, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_inf_principal_iff", "code": "theorem eventuallyEq_inf_principal_iff {F : Filter \u03b1} {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} :\n    f =\u1da0[F \u2293 \ud835\udcdf s] g \u2194 \u2200\u1da0 x in F, x \u2208 s \u2192 f x = g x", "start": [1619, 1], "end": [1621, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.sub_eq", "code": "theorem EventuallyEq.sub_eq [AddGroup \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} (h : f =\u1da0[l] g) :\n    f - g =\u1da0[l] 0", "start": [1624, 1], "end": [1625, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_iff_sub", "code": "theorem eventuallyEq_iff_sub [AddGroup \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} :\n    f =\u1da0[l] g \u2194 f - g =\u1da0[l] 0", "start": [1628, 1], "end": [1630, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE", "code": "def EventuallyLE (l : Filter \u03b1) (f g : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200\u1da0 x in l, f x \u2264 g x", "start": [1637, 1], "end": [1639, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.congr", "code": "theorem EventuallyLE.congr {f f' g g' : \u03b1 \u2192 \u03b2} (H : f \u2264\u1da0[l] g) (hf : f =\u1da0[l] f') (hg : g =\u1da0[l] g') :\n    f' \u2264\u1da0[l] g'", "start": [1645, 1], "end": [1647, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyLE_congr", "code": "theorem eventuallyLE_congr {f f' g g' : \u03b1 \u2192 \u03b2} (hf : f =\u1da0[l] f') (hg : g =\u1da0[l] g') :\n    f \u2264\u1da0[l] g \u2194 f' \u2264\u1da0[l] g'", "start": [1650, 1], "end": [1652, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.le", "code": "theorem EventuallyEq.le (h : f =\u1da0[l] g) : f \u2264\u1da0[l] g", "start": [1661, 1], "end": [1662, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.refl", "code": "@[refl]\ntheorem EventuallyLE.refl (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) : f \u2264\u1da0[l] f", "start": [1665, 1], "end": [1667, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.rfl", "code": "theorem EventuallyLE.rfl : f \u2264\u1da0[l] f", "start": [1670, 1], "end": [1671, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.trans", "code": "@[trans]\ntheorem EventuallyLE.trans (H\u2081 : f \u2264\u1da0[l] g) (H\u2082 : g \u2264\u1da0[l] h) : f \u2264\u1da0[l] h", "start": [1674, 1], "end": [1676, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.trans_le", "code": "@[trans]\ntheorem EventuallyEq.trans_le (H\u2081 : f =\u1da0[l] g) (H\u2082 : g \u2264\u1da0[l] h) : f \u2264\u1da0[l] h", "start": [1683, 1], "end": [1685, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.trans_eq", "code": "@[trans]\ntheorem EventuallyLE.trans_eq (H\u2081 : f \u2264\u1da0[l] g) (H\u2082 : g =\u1da0[l] h) : f \u2264\u1da0[l] h", "start": [1692, 1], "end": [1694, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.antisymm", "code": "theorem EventuallyLE.antisymm [PartialOrder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h\u2081 : f \u2264\u1da0[l] g)\n    (h\u2082 : g \u2264\u1da0[l] f) : f =\u1da0[l] g", "start": [1703, 1], "end": [1705, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyLE_antisymm_iff", "code": "theorem eventuallyLE_antisymm_iff [PartialOrder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} :\n    f =\u1da0[l] g \u2194 f \u2264\u1da0[l] g \u2227 g \u2264\u1da0[l] f", "start": [1708, 1], "end": [1710, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.le_iff_eq", "code": "theorem EventuallyLE.le_iff_eq [PartialOrder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : f \u2264\u1da0[l] g) :\n    g \u2264\u1da0[l] f \u2194 g =\u1da0[l] f", "start": [1713, 1], "end": [1715, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.ne_of_lt", "code": "theorem Eventually.ne_of_lt [Preorder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : \u2200\u1da0 x in l, f x < g x) :\n    \u2200\u1da0 x in l, f x \u2260 g x", "start": [1718, 1], "end": [1720, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.ne_top_of_lt", "code": "theorem Eventually.ne_top_of_lt [PartialOrder \u03b2] [OrderTop \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 x in l, f x < g x) : \u2200\u1da0 x in l, f x \u2260 \u22a4", "start": [1723, 1], "end": [1725, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.lt_top_of_ne", "code": "theorem Eventually.lt_top_of_ne [PartialOrder \u03b2] [OrderTop \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200\u1da0 x in l, f x \u2260 \u22a4) : \u2200\u1da0 x in l, f x < \u22a4", "start": [1728, 1], "end": [1730, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.lt_top_iff_ne_top", "code": "theorem Eventually.lt_top_iff_ne_top [PartialOrder \u03b2] [OrderTop \u03b2] {l : Filter \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    (\u2200\u1da0 x in l, f x < \u22a4) \u2194 \u2200\u1da0 x in l, f x \u2260 \u22a4", "start": [1733, 1], "end": [1735, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.inter", "code": "@[mono]\ntheorem EventuallyLE.inter {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s \u2264\u1da0[l] t) (h' : s' \u2264\u1da0[l] t') :\n    (s \u2229 s' : Set \u03b1) \u2264\u1da0[l] (t \u2229 t' : Set \u03b1)", "start": [1738, 1], "end": [1741, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.union", "code": "@[mono]\ntheorem EventuallyLE.union {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s \u2264\u1da0[l] t) (h' : s' \u2264\u1da0[l] t') :\n    (s \u222a s' : Set \u03b1) \u2264\u1da0[l] (t \u222a t' : Set \u03b1)", "start": [1744, 1], "end": [1747, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.compl", "code": "@[mono]\ntheorem EventuallyLE.compl {s t : Set \u03b1} {l : Filter \u03b1} (h : s \u2264\u1da0[l] t) :\n    (t\u1d9c : Set \u03b1) \u2264\u1da0[l] (s\u1d9c : Set \u03b1)", "start": [1750, 1], "end": [1753, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.diff", "code": "@[mono]\ntheorem EventuallyLE.diff {s t s' t' : Set \u03b1} {l : Filter \u03b1} (h : s \u2264\u1da0[l] t) (h' : t' \u2264\u1da0[l] s') :\n    (s \\ s' : Set \u03b1) \u2264\u1da0[l] (t \\ t' : Set \u03b1)", "start": [1756, 1], "end": [1759, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.set_eventuallyLE_iff_mem_inf_principal", "code": "theorem set_eventuallyLE_iff_mem_inf_principal {s t : Set \u03b1} {l : Filter \u03b1} :\n    s \u2264\u1da0[l] t \u2194 t \u2208 l \u2293 \ud835\udcdf s", "start": [1762, 1], "end": [1764, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.set_eventuallyLE_iff_inf_principal_le", "code": "theorem set_eventuallyLE_iff_inf_principal_le {s t : Set \u03b1} {l : Filter \u03b1} :\n    s \u2264\u1da0[l] t \u2194 l \u2293 \ud835\udcdf s \u2264 l \u2293 \ud835\udcdf t", "start": [1767, 1], "end": [1770, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.set_eventuallyEq_iff_inf_principal", "code": "theorem set_eventuallyEq_iff_inf_principal {s t : Set \u03b1} {l : Filter \u03b1} :\n    s =\u1da0[l] t \u2194 l \u2293 \ud835\udcdf s = l \u2293 \ud835\udcdf t", "start": [1773, 1], "end": [1775, 96], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.mul_le_mul", "code": "theorem EventuallyLE.mul_le_mul [MulZeroClass \u03b2] [PartialOrder \u03b2] [PosMulMono \u03b2] [MulPosMono \u03b2]\n    {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (hf : f\u2081 \u2264\u1da0[l] f\u2082) (hg : g\u2081 \u2264\u1da0[l] g\u2082) (hg\u2080 : 0 \u2264\u1da0[l] g\u2081)\n    (hf\u2080 : 0 \u2264\u1da0[l] f\u2082) : f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082", "start": [1778, 1], "end": [1781, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.mul_le_mul'", "code": "@[to_additive EventuallyLE.add_le_add]\ntheorem EventuallyLE.mul_le_mul' [Mul \u03b2] [Preorder \u03b2] [CovariantClass \u03b2 \u03b2 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b2 \u03b2 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2}\n    (hf : f\u2081 \u2264\u1da0[l] f\u2082) (hg : g\u2081 \u2264\u1da0[l] g\u2082) : f\u2081 * g\u2081 \u2264\u1da0[l] f\u2082 * g\u2082", "start": [1784, 1], "end": [1788, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.mul_nonneg", "code": "theorem EventuallyLE.mul_nonneg [OrderedSemiring \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : 0 \u2264\u1da0[l] f)\n    (hg : 0 \u2264\u1da0[l] g) : 0 \u2264\u1da0[l] f * g", "start": [1792, 1], "end": [1793, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_sub_nonneg", "code": "theorem eventually_sub_nonneg [OrderedRing \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} :\n    0 \u2264\u1da0[l] g - f \u2194 f \u2264\u1da0[l] g", "start": [1796, 1], "end": [1798, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.sup", "code": "theorem EventuallyLE.sup [SemilatticeSup \u03b2] {l : Filter \u03b1} {f\u2081 f\u2082 g\u2081 g\u2082 : \u03b1 \u2192 \u03b2} (hf : f\u2081 \u2264\u1da0[l] f\u2082)\n    (hg : g\u2081 \u2264\u1da0[l] g\u2082) : f\u2081 \u2294 g\u2081 \u2264\u1da0[l] f\u2082 \u2294 g\u2082", "start": [1801, 1], "end": [1803, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.sup_le", "code": "theorem EventuallyLE.sup_le [SemilatticeSup \u03b2] {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2} (hf : f \u2264\u1da0[l] h)\n    (hg : g \u2264\u1da0[l] h) : f \u2294 g \u2264\u1da0[l] h", "start": [1806, 1], "end": [1808, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.le_sup_of_le_left", "code": "theorem EventuallyLE.le_sup_of_le_left [SemilatticeSup \u03b2] {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2}\n    (hf : h \u2264\u1da0[l] f) : h \u2264\u1da0[l] f \u2294 g", "start": [1811, 1], "end": [1813, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.le_sup_of_le_right", "code": "theorem EventuallyLE.le_sup_of_le_right [SemilatticeSup \u03b2] {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2}\n    (hg : h \u2264\u1da0[l] g) : h \u2264\u1da0[l] f \u2294 g", "start": [1816, 1], "end": [1818, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.join_le", "code": "theorem join_le {f : Filter (Filter \u03b1)} {l : Filter \u03b1} (h : \u2200\u1da0 m in f, m \u2264 l) : join f \u2264 l", "start": [1821, 1], "end": [1822, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.map", "code": "def map (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) : Filter \u03b2 where\n  sets := preimage m \u207b\u00b9' f.sets\n  univ_sets := univ_mem\n  sets_of_superset hs st := mem_of_superset hs <| preimage_mono st\n  inter_sets hs ht := inter_mem hs ht", "start": [1829, 1], "end": [1834, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.map_principal", "code": "@[simp]\ntheorem map_principal {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} : map f (\ud835\udcdf s) = \ud835\udcdf (Set.image f s)", "start": [1837, 1], "end": [1839, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_map", "code": "@[simp]\ntheorem eventually_map {P : \u03b2 \u2192 Prop} : (\u2200\u1da0 b in map m f, P b) \u2194 \u2200\u1da0 a in f, P (m a)", "start": [1844, 1], "end": [1846, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_map", "code": "@[simp]\ntheorem frequently_map {P : \u03b2 \u2192 Prop} : (\u2203\u1da0 b in map m f, P b) \u2194 \u2203\u1da0 a in f, P (m a)", "start": [1849, 1], "end": [1851, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_map", "code": "@[simp]\ntheorem mem_map : t \u2208 map m f \u2194 m \u207b\u00b9' t \u2208 f", "start": [1854, 1], "end": [1856, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_map'", "code": "theorem mem_map' : t \u2208 map m f \u2194 { x | m x \u2208 t } \u2208 f", "start": [1859, 1], "end": [1860, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.image_mem_map", "code": "theorem image_mem_map (hs : s \u2208 f) : m '' s \u2208 map m f", "start": [1863, 1], "end": [1864, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.image_mem_map_iff", "code": "@[simp 1100, nolint simpNF]\ntheorem image_mem_map_iff (hf : Injective m) : m '' s \u2208 map m f \u2194 s \u2208 f", "start": [1870, 1], "end": [1872, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.range_mem_map", "code": "theorem range_mem_map : range m \u2208 map m f", "start": [1875, 1], "end": [1877, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_map_iff_exists_image", "code": "theorem mem_map_iff_exists_image : t \u2208 map m f \u2194 \u2203 s \u2208 f, m '' s \u2286 t", "start": [1880, 1], "end": [1882, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.map_id", "code": "@[simp]\ntheorem map_id : Filter.map id f = f", "start": [1885, 1], "end": [1887, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.map_id'", "code": "@[simp]\ntheorem map_id' : Filter.map (fun x => x) f = f", "start": [1890, 1], "end": [1892, 9], "kind": "commanddeclaration"}, {"full_name": "Filter.map_compose", "code": "@[simp]\ntheorem map_compose : Filter.map m' \u2218 Filter.map m = Filter.map (m' \u2218 m)", "start": [1895, 1], "end": [1897, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map", "code": "@[simp]\ntheorem map_map : Filter.map m' (Filter.map m f) = Filter.map (m' \u2218 m) f", "start": [1900, 1], "end": [1902, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map_congr", "code": "theorem map_congr {m\u2081 m\u2082 : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} (h : m\u2081 =\u1da0[f] m\u2082) : map m\u2081 f = map m\u2082 f", "start": [1905, 1], "end": [1908, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.comap", "code": "def comap (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b2) : Filter \u03b1\n    where\n  sets := { s | \u2203 t \u2208 f, m \u207b\u00b9' t \u2286 s }\n  univ_sets := \u27e8univ, univ_mem, by simp only [subset_univ, preimage_univ]\u27e9\n  sets_of_superset := fun \u27e8a', ha', ma'a\u27e9 ab => \u27e8a', ha', ma'a.trans ab\u27e9\n  inter_sets := fun \u27e8a', ha\u2081, ha\u2082\u27e9 \u27e8b', hb\u2081, hb\u2082\u27e9 =>\n    \u27e8a' \u2229 b', inter_mem ha\u2081 hb\u2081, inter_subset_inter ha\u2082 hb\u2082\u27e9", "start": [1915, 1], "end": [1928, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap'", "code": "theorem mem_comap' : s \u2208 comap f l \u2194 { y | \u2200 \u2983x\u2984, f x = y \u2192 x \u2208 s } \u2208 l", "start": [1933, 1], "end": [1935, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap''", "code": "theorem mem_comap'' : s \u2208 comap f l \u2194 kernImage f s \u2208 l", "start": [1940, 1], "end": [1941, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap_prod_mk", "code": "lemma mem_comap_prod_mk {x : \u03b1} {s : Set \u03b2} {F : Filter (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 comap (Prod.mk x) F \u2194 {p : \u03b1 \u00d7 \u03b2 | p.fst = x \u2192 p.snd \u2208 s} \u2208 F :=\nby simp_rw [mem_comap', Prod.ext_iff, and_imp, @forall_swap \u03b2 (_ = _), forall_eq, eq_comm]", "start": [1943, 1], "end": [1946, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.eventually_comap", "code": "@[simp]\ntheorem eventually_comap : (\u2200\u1da0 a in comap f l, p a) \u2194 \u2200\u1da0 b in l, \u2200 a, f a = b \u2192 p a", "start": [1949, 1], "end": [1951, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_comap", "code": "@[simp]\ntheorem frequently_comap : (\u2203\u1da0 a in comap f l, p a) \u2194 \u2203\u1da0 b in l, \u2203 a, f a = b \u2227 p a", "start": [1954, 1], "end": [1956, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap_iff_compl", "code": "theorem mem_comap_iff_compl : s \u2208 comap f l \u2194 (f '' s\u1d9c)\u1d9c \u2208 l", "start": [1959, 1], "end": [1960, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_mem_comap", "code": "theorem compl_mem_comap : s\u1d9c \u2208 comap f l \u2194 (f '' s)\u1d9c \u2208 l", "start": [1963, 1], "end": [1963, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.kernMap", "code": "def kernMap (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) : Filter \u03b2 where\n  sets := (kernImage m) '' f.sets\n  univ_sets := \u27e8univ, f.univ_sets, by simp [kernImage_eq_compl]\u27e9\n  sets_of_superset := by\n    rintro _ t \u27e8s, hs, rfl\u27e9 hst\n    refine \u27e8s \u222a m \u207b\u00b9' t, mem_of_superset hs (subset_union_left s _), ?_\u27e9\n    rw [kernImage_union_preimage, union_eq_right.mpr hst]\n  inter_sets := by\n    rintro _ _ \u27e8s\u2081, h\u2081, rfl\u27e9 \u27e8s\u2082, h\u2082, rfl\u27e9\n    exact \u27e8s\u2081 \u2229 s\u2082, f.inter_sets h\u2081 h\u2082, Set.preimage_kernImage.u_inf\u27e9", "start": [1970, 1], "end": [1990, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_kernMap", "code": "theorem mem_kernMap {s : Set \u03b2} : s \u2208 kernMap m f \u2194 \u2203 t \u2208 f, kernImage m t = s", "start": [1994, 1], "end": [1995, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_kernMap_iff_compl", "code": "theorem mem_kernMap_iff_compl {s : Set \u03b2} : s \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s\u1d9c", "start": [1997, 1], "end": [2000, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_mem_kernMap", "code": "theorem compl_mem_kernMap {s : Set \u03b2} : s\u1d9c \u2208 kernMap m f \u2194 \u2203 t, t\u1d9c \u2208 f \u2227 m '' t = s", "start": [2002, 1], "end": [2003, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.bind", "code": "def bind (f : Filter \u03b1) (m : \u03b1 \u2192 Filter \u03b2) : Filter \u03b2 :=\n  join (map m f)", "start": [2007, 1], "end": [2012, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.seq", "code": "def seq (f : Filter (\u03b1 \u2192 \u03b2)) (g : Filter \u03b1) : Filter \u03b2 where\n  sets := { s | \u2203 u \u2208 f, \u2203 t \u2208 g, \u2200 m \u2208 u, \u2200 x \u2208 t, (m : \u03b1 \u2192 \u03b2) x \u2208 s }\n  univ_sets := \u27e8univ, univ_mem, univ, univ_mem, fun _ _ _ _ => trivial\u27e9\n  sets_of_superset := fun \u27e8t\u2080, t\u2081, h\u2080, h\u2081, h\u27e9 hst =>\n    \u27e8t\u2080, t\u2081, h\u2080, h\u2081, fun _ hx _ hy => hst <| h _ hx _ hy\u27e9\n  inter_sets := fun \u27e8t\u2080, ht\u2080, t\u2081, ht\u2081, ht\u27e9 \u27e8u\u2080, hu\u2080, u\u2081, hu\u2081, hu\u27e9 =>\n    \u27e8t\u2080 \u2229 u\u2080, inter_mem ht\u2080 hu\u2080, t\u2081 \u2229 u\u2081, inter_mem ht\u2081 hu\u2081, fun _ \u27e8hx\u2080, hx\u2081\u27e9 _ \u27e8hy\u2080, hy\u2081\u27e9 =>\n      \u27e8ht _ hx\u2080 _ hy\u2080, hu _ hx\u2081 _ hy\u2081\u27e9\u27e9", "start": [2015, 1], "end": [2023, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_sets", "code": "theorem pure_sets (a : \u03b1) : (pure a : Filter \u03b1).sets = { s | a \u2208 s }", "start": [2045, 1], "end": [2046, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_pure", "code": "@[simp]\ntheorem mem_pure {a : \u03b1} {s : Set \u03b1} : s \u2208 (pure a : Filter \u03b1) \u2194 a \u2208 s", "start": [2049, 1], "end": [2051, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_pure", "code": "@[simp]\ntheorem eventually_pure {a : \u03b1} {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in pure a, p x) \u2194 p a", "start": [2054, 1], "end": [2056, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_singleton", "code": "@[simp]\ntheorem principal_singleton (a : \u03b1) : \ud835\udcdf {a} = pure a", "start": [2059, 1], "end": [2061, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.map_pure", "code": "@[simp]\ntheorem map_pure (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : map f (pure a) = pure (f a)", "start": [2064, 1], "end": [2066, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.join_pure", "code": "@[simp] theorem join_pure (f : Filter \u03b1) : join (pure f) = f", "start": [2069, 1], "end": [2069, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_bind", "code": "@[simp]\ntheorem pure_bind (a : \u03b1) (m : \u03b1 \u2192 Filter \u03b2) : bind (pure a) m = m a", "start": [2072, 1], "end": [2074, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.monad", "code": "protected def monad : Monad Filter where map := @Filter.map", "start": [2087, 1], "end": [2088, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.lawfulMonad", "code": "protected theorem lawfulMonad : LawfulMonad Filter where", "start": [2093, 1], "end": [2102, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.map_def", "code": "@[simp]\ntheorem map_def {\u03b1 \u03b2} (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) : m <$> f = map m f", "start": [2112, 1], "end": [2114, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.bind_def", "code": "@[simp]\ntheorem bind_def {\u03b1 \u03b2} (f : Filter \u03b1) (m : \u03b1 \u2192 Filter \u03b2) : f >>= m = bind f m", "start": [2117, 1], "end": [2119, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap", "code": "@[simp] theorem mem_comap : s \u2208 comap m g \u2194 \u2203 t \u2208 g, m \u207b\u00b9' t \u2286 s", "start": [2128, 1], "end": [2128, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.preimage_mem_comap", "code": "theorem preimage_mem_comap (ht : t \u2208 g) : m \u207b\u00b9' t \u2208 comap m g", "start": [2131, 1], "end": [2132, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.comap", "code": "theorem Eventually.comap {p : \u03b2 \u2192 Prop} (hf : \u2200\u1da0 b in g, p b) (f : \u03b1 \u2192 \u03b2) :\n    \u2200\u1da0 a in comap f g, p (f a)", "start": [2135, 1], "end": [2137, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_id", "code": "theorem comap_id : comap id f = f", "start": [2140, 1], "end": [2141, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_id'", "code": "theorem comap_id' : comap (fun x => x) f = f", "start": [2144, 1], "end": [2144, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_const_of_not_mem", "code": "theorem comap_const_of_not_mem {x : \u03b2} (ht : t \u2208 g) (hx : x \u2209 t) : comap (fun _ : \u03b1 => x) g = \u22a5", "start": [2147, 1], "end": [2148, 96], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_const_of_mem", "code": "theorem comap_const_of_mem {x : \u03b2} (h : \u2200 t \u2208 g, x \u2208 t) : comap (fun _ : \u03b1 => x) g = \u22a4", "start": [2151, 1], "end": [2152, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.map_const", "code": "theorem map_const [NeBot f] {c : \u03b2} : (f.map fun _ => c) = pure c", "start": [2155, 1], "end": [2157, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_comap", "code": "theorem comap_comap {m : \u03b3 \u2192 \u03b2} {n : \u03b2 \u2192 \u03b1} : comap m (comap n f) = comap (n \u2218 m) f", "start": [2160, 1], "end": [2161, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comm", "code": "theorem map_comm (F : Filter \u03b1) : map \u03c8 (map \u03c6 F) = map \u03c1 (map \u03b8 F)", "start": [2180, 1], "end": [2181, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_comm", "code": "theorem comap_comm (G : Filter \u03b4) : comap \u03c6 (comap \u03c8 G) = comap \u03b8 (comap \u03c1 G)", "start": [2184, 1], "end": [2185, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.filter_map", "code": "theorem _root_.Function.Semiconj.filter_map {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (map f) (map ga) (map gb)", "start": [2190, 1], "end": [2192, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.filter_map", "code": "theorem _root_.Function.Commute.filter_map {f g : \u03b1 \u2192 \u03b1} (h : Function.Commute f g) :\n    Function.Commute (map f) (map g)", "start": [2195, 1], "end": [2197, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.filter_comap", "code": "theorem _root_.Function.Semiconj.filter_comap {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (comap f) (comap gb) (comap ga)", "start": [2200, 1], "end": [2202, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.filter_comap", "code": "theorem _root_.Function.Commute.filter_comap {f g : \u03b1 \u2192 \u03b1} (h : Function.Commute f g) :\n    Function.Commute (comap f) (comap g)", "start": [2205, 1], "end": [2207, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_principal", "code": "@[simp]\ntheorem comap_principal {t : Set \u03b2} : comap m (\ud835\udcdf t) = \ud835\udcdf (m \u207b\u00b9' t)", "start": [2210, 1], "end": [2213, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_pure", "code": "@[simp]\ntheorem comap_pure {b : \u03b2} : comap m (pure b) = \ud835\udcdf (m \u207b\u00b9' {b})", "start": [2216, 1], "end": [2218, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap : map m f \u2264 g \u2194 f \u2264 comap m g", "start": [2221, 1], "end": [2222, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.gc_map_comap", "code": "theorem gc_map_comap (m : \u03b1 \u2192 \u03b2) : GaloisConnection (map m) (comap m)", "start": [2225, 1], "end": [2226, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_le_iff_le_kernMap", "code": "theorem comap_le_iff_le_kernMap : comap m g \u2264 f \u2194 g \u2264 kernMap m f", "start": [2229, 1], "end": [2230, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.gc_comap_kernMap", "code": "theorem gc_comap_kernMap (m : \u03b1 \u2192 \u03b2) : GaloisConnection (comap m) (kernMap m)", "start": [2232, 1], "end": [2233, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.kernMap_principal", "code": "theorem kernMap_principal {s : Set \u03b1} : kernMap m (\ud835\udcdf s) = \ud835\udcdf (kernImage m s)", "start": [2235, 1], "end": [2237, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.map_mono", "code": "@[mono]\ntheorem map_mono : Monotone (map m)", "start": [2239, 1], "end": [2241, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_mono", "code": "@[mono]\ntheorem comap_mono : Monotone (comap m)", "start": [2244, 1], "end": [2246, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.map_bot", "code": "@[simp] theorem map_bot : map m \u22a5 = \u22a5", "start": [2249, 1], "end": [2249, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.map_sup", "code": "@[simp] theorem map_sup : map m (f\u2081 \u2294 f\u2082) = map m f\u2081 \u2294 map m f\u2082", "start": [2252, 1], "end": [2252, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.map_iSup", "code": "@[simp]\ntheorem map_iSup {f : \u03b9 \u2192 Filter \u03b1} : map m (\u2a06 i, f i) = \u2a06 i, map m (f i)", "start": [2255, 1], "end": [2257, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.map_top", "code": "@[simp]\ntheorem map_top (f : \u03b1 \u2192 \u03b2) : map f \u22a4 = \ud835\udcdf (range f)", "start": [2260, 1], "end": [2262, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_top", "code": "@[simp] theorem comap_top : comap m \u22a4 = \u22a4", "start": [2265, 1], "end": [2265, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_inf", "code": "@[simp] theorem comap_inf : comap m (g\u2081 \u2293 g\u2082) = comap m g\u2081 \u2293 comap m g\u2082", "start": [2268, 1], "end": [2268, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_iInf", "code": "@[simp]\ntheorem comap_iInf {f : \u03b9 \u2192 Filter \u03b2} : comap m (\u2a05 i, f i) = \u2a05 i, comap m (f i)", "start": [2271, 1], "end": [2273, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.le_comap_top", "code": "theorem le_comap_top (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b1) : l \u2264 comap f \u22a4", "start": [2276, 1], "end": [2278, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comap_le", "code": "theorem map_comap_le : map m (comap m g) \u2264 g", "start": [2281, 1], "end": [2282, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.le_comap_map", "code": "theorem le_comap_map : f \u2264 comap m (map m f)", "start": [2285, 1], "end": [2286, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_bot", "code": "@[simp]\ntheorem comap_bot : comap m \u22a5 = \u22a5", "start": [2289, 1], "end": [2291, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.neBot_of_comap", "code": "theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot", "start": [2294, 1], "end": [2298, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_inf_principal_range", "code": "theorem comap_inf_principal_range : comap m (g \u2293 \ud835\udcdf (range m)) = comap m g", "start": [2302, 1], "end": [2304, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_comap", "code": "theorem disjoint_comap (h : Disjoint g\u2081 g\u2082) : Disjoint (comap m g\u2081) (comap m g\u2082)", "start": [2307, 1], "end": [2308, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_iSup", "code": "theorem comap_iSup {\u03b9} {f : \u03b9 \u2192 Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : comap m (iSup f) = \u2a06 i, comap m (f i)", "start": [2311, 1], "end": [2312, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_sSup", "code": "theorem comap_sSup {s : Set (Filter \u03b2)} {m : \u03b1 \u2192 \u03b2} : comap m (sSup s) = \u2a06 f \u2208 s, comap m f", "start": [2315, 1], "end": [2316, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_sup", "code": "theorem comap_sup : comap m (g\u2081 \u2294 g\u2082) = comap m g\u2081 \u2294 comap m g\u2082", "start": [2319, 1], "end": [2320, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comap", "code": "theorem map_comap (f : Filter \u03b2) (m : \u03b1 \u2192 \u03b2) : (f.comap m).map m = f \u2293 \ud835\udcdf (range m)", "start": [2323, 1], "end": [2328, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comap_setCoe_val", "code": "theorem map_comap_setCoe_val (f : Filter \u03b2) (s : Set \u03b2) :\n    (f.comap ((\u2191) : s \u2192 \u03b2)).map (\u2191) = f \u2293 \ud835\udcdf s", "start": [2331, 1], "end": [2333, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comap_of_mem", "code": "theorem map_comap_of_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : range m \u2208 f) : (f.comap m).map m = f", "start": [2335, 1], "end": [2336, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.canLift", "code": "instance canLift (c) (p) [CanLift \u03b1 \u03b2 c p] :\n    CanLift (Filter \u03b1) (Filter \u03b2) (map c) fun f => \u2200\u1da0 x : \u03b1 in f, p x where\n  prf f hf := \u27e8comap c f, map_comap_of_mem <| hf.mono CanLift.prf\u27e9", "start": [2339, 1], "end": [2341, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_le_comap_iff", "code": "theorem comap_le_comap_iff {f g : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : range m \u2208 f) :\n    comap m f \u2264 comap m g \u2194 f \u2264 g", "start": [2344, 1], "end": [2346, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.map_comap_of_surjective", "code": "theorem map_comap_of_surjective {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) (l : Filter \u03b2) :\n    map f (comap f l) = l", "start": [2349, 1], "end": [2351, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.filter_map_top", "code": "theorem _root_.Function.Surjective.filter_map_top {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) : map f \u22a4 = \u22a4", "start": [2354, 1], "end": [2355, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.subtype_coe_map_comap", "code": "theorem subtype_coe_map_comap (s : Set \u03b1) (f : Filter \u03b1) :\n    map ((\u2191) : s \u2192 \u03b1) (comap ((\u2191) : s \u2192 \u03b1) f) = f \u2293 \ud835\udcdf s", "start": [2358, 1], "end": [2359, 96], "kind": "commanddeclaration"}, {"full_name": "Filter.image_mem_of_mem_comap", "code": "theorem image_mem_of_mem_comap {f : Filter \u03b1} {c : \u03b2 \u2192 \u03b1} (h : range c \u2208 f) {W : Set \u03b2}\n    (W_in : W \u2208 comap c f) : c '' W \u2208 f", "start": [2362, 1], "end": [2365, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.image_coe_mem_of_mem_comap", "code": "theorem image_coe_mem_of_mem_comap {f : Filter \u03b1} {U : Set \u03b1} (h : U \u2208 f) {W : Set U}\n    (W_in : W \u2208 comap ((\u2191) : U \u2192 \u03b1) f) : (\u2191) '' W \u2208 f", "start": [2368, 1], "end": [2370, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_map", "code": "theorem comap_map {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (h : Injective m) : comap m (map m f) = f", "start": [2373, 1], "end": [2378, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_comap_iff", "code": "theorem mem_comap_iff {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (inj : Injective m) (large : Set.range m \u2208 f)\n    {S : Set \u03b1} : S \u2208 comap m f \u2194 m '' S \u2208 f", "start": [2381, 1], "end": [2383, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.map_le_map_iff_of_injOn", "code": "theorem map_le_map_iff_of_injOn {l\u2081 l\u2082 : Filter \u03b1} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h\u2081 : s \u2208 l\u2081)\n    (h\u2082 : s \u2208 l\u2082) (hinj : InjOn f s) : map f l\u2081 \u2264 map f l\u2082 \u2194 l\u2081 \u2264 l\u2082", "start": [2386, 1], "end": [2392, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.map_le_map_iff", "code": "theorem map_le_map_iff {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (hm : Injective m) :\n    map m f \u2264 map m g \u2194 f \u2264 g", "start": [2395, 1], "end": [2396, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.map_eq_map_iff_of_injOn", "code": "theorem map_eq_map_iff_of_injOn {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hsf : s \u2208 f) (hsg : s \u2208 g)\n    (hm : InjOn m s) : map m f = map m g \u2194 f = g", "start": [2399, 1], "end": [2402, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inj", "code": "theorem map_inj {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (hm : Injective m) : map m f = map m g \u2194 f = g", "start": [2405, 1], "end": [2406, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.map_injective", "code": "theorem map_injective {m : \u03b1 \u2192 \u03b2} (hm : Injective m) : Injective (map m)", "start": [2409, 1], "end": [2410, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neBot_iff", "code": "theorem comap_neBot_iff {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : NeBot (comap m f) \u2194 \u2200 t \u2208 f, \u2203 a, m a \u2208 t", "start": [2413, 1], "end": [2415, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neBot", "code": "theorem comap_neBot {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hm : \u2200 t \u2208 f, \u2203 a, m a \u2208 t) : NeBot (comap m f)", "start": [2418, 1], "end": [2419, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neBot_iff_frequently", "code": "theorem comap_neBot_iff_frequently {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} :\n    NeBot (comap m f) \u2194 \u2203\u1da0 y in f, y \u2208 range m", "start": [2422, 1], "end": [2424, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neBot_iff_compl_range", "code": "theorem comap_neBot_iff_compl_range {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} :\n    NeBot (comap m f) \u2194 (range m)\u1d9c \u2209 f", "start": [2427, 1], "end": [2429, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eq_bot_iff_compl_range", "code": "theorem comap_eq_bot_iff_compl_range {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : comap m f = \u22a5 \u2194 (range m)\u1d9c \u2208 f", "start": [2432, 1], "end": [2433, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_surjective_eq_bot", "code": "theorem comap_surjective_eq_bot {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hm : Surjective m) :\n    comap m f = \u22a5 \u2194 f = \u22a5", "start": [2436, 1], "end": [2438, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_comap_iff", "code": "theorem disjoint_comap_iff (h : Surjective m) :\n    Disjoint (comap m g\u2081) (comap m g\u2082) \u2194 Disjoint g\u2081 g\u2082", "start": [2441, 1], "end": [2443, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.comap_of_range_mem", "code": "theorem NeBot.comap_of_range_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (_ : NeBot f) (hm : range m \u2208 f) :\n    NeBot (comap m f)", "start": [2446, 1], "end": [2448, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_fst_neBot_iff", "code": "@[simp]\ntheorem comap_fst_neBot_iff {f : Filter \u03b1} :\n    (f.comap (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1)).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2", "start": [2451, 1], "end": [2456, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_fst_neBot", "code": "@[instance]\ntheorem comap_fst_neBot [Nonempty \u03b2] {f : Filter \u03b1} [NeBot f] :\n    (f.comap (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1)).NeBot", "start": [2459, 1], "end": [2462, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_snd_neBot_iff", "code": "@[simp]\ntheorem comap_snd_neBot_iff {f : Filter \u03b2} :\n    (f.comap (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2)).NeBot \u2194 Nonempty \u03b1 \u2227 f.NeBot", "start": [2465, 1], "end": [2470, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_snd_neBot", "code": "@[instance]\ntheorem comap_snd_neBot [Nonempty \u03b1] {f : Filter \u03b2} [NeBot f] :\n    (f.comap (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2)).NeBot", "start": [2473, 1], "end": [2476, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eval_neBot_iff'", "code": "theorem comap_eval_neBot_iff' {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {i : \u03b9} {f : Filter (\u03b1 i)} :\n    (comap (eval i) f).NeBot \u2194 (\u2200 j, Nonempty (\u03b1 j)) \u2227 NeBot f", "start": [2479, 1], "end": [2485, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eval_neBot_iff", "code": "@[simp]\ntheorem comap_eval_neBot_iff {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 j, Nonempty (\u03b1 j)] {i : \u03b9}\n    {f : Filter (\u03b1 i)} : (comap (eval i) f).NeBot \u2194 NeBot f", "start": [2488, 1], "end": [2490, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eval_neBot", "code": "@[instance]\ntheorem comap_eval_neBot {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 j, Nonempty (\u03b1 j)] (i : \u03b9)\n    (f : Filter (\u03b1 i)) [NeBot f] : (comap (eval i) f).NeBot", "start": [2493, 1], "end": [2496, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_inf_principal_neBot_of_image_mem", "code": "theorem comap_inf_principal_neBot_of_image_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : NeBot f) {s : Set \u03b1}\n    (hs : m '' s \u2208 f) : NeBot (comap m f \u2293 \ud835\udcdf s)", "start": [2499, 1], "end": [2504, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_coe_neBot_of_le_principal", "code": "theorem comap_coe_neBot_of_le_principal {s : Set \u03b3} {l : Filter \u03b3} [h : NeBot l] (h' : l \u2264 \ud835\udcdf s) :\n    NeBot (comap ((\u2191) : s \u2192 \u03b3) l)", "start": [2507, 1], "end": [2509, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.comap_of_surj", "code": "theorem NeBot.comap_of_surj {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : NeBot f) (hm : Surjective m) :\n    NeBot (comap m f)", "start": [2512, 1], "end": [2514, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.comap_of_image_mem", "code": "theorem NeBot.comap_of_image_mem {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : NeBot f) {s : Set \u03b1}\n    (hs : m '' s \u2208 f) : NeBot (comap m f)", "start": [2517, 1], "end": [2519, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.map_eq_bot_iff", "code": "@[simp]\ntheorem map_eq_bot_iff : map m f = \u22a5 \u2194 f = \u22a5", "start": [2522, 1], "end": [2526, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.map_neBot_iff", "code": "theorem map_neBot_iff (f : \u03b1 \u2192 \u03b2) {F : Filter \u03b1} : NeBot (map f F) \u2194 NeBot F", "start": [2529, 1], "end": [2530, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.map", "code": "theorem NeBot.map (hf : NeBot f) (m : \u03b1 \u2192 \u03b2) : NeBot (map m f)", "start": [2533, 1], "end": [2534, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_map", "code": "theorem NeBot.of_map : NeBot (f.map m) \u2192 NeBot f", "start": [2537, 1], "end": [2538, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.map_neBot", "code": "instance map_neBot [hf : NeBot f] : NeBot (f.map m) :=\n  hf.map m", "start": [2541, 1], "end": [2542, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.sInter_comap_sets", "code": "theorem sInter_comap_sets (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b2) : \u22c2\u2080 (comap f F).sets = \u22c2 U \u2208 F, f \u207b\u00b9' U", "start": [2545, 1], "end": [2555, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.map_iInf_le", "code": "theorem map_iInf_le {f : \u03b9 \u2192 Filter \u03b1} {m : \u03b1 \u2192 \u03b2} : map m (iInf f) \u2264 \u2a05 i, map m (f i)", "start": [2561, 1], "end": [2562, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.map_iInf_eq", "code": "theorem map_iInf_eq {f : \u03b9 \u2192 Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (hf : Directed (\u00b7 \u2265 \u00b7) f) [Nonempty \u03b9] :\n    map m (iInf f) = \u2a05 i, map m (f i)", "start": [2565, 1], "end": [2573, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.map_biInf_eq", "code": "theorem map_biInf_eq {\u03b9 : Type w} {f : \u03b9 \u2192 Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {p : \u03b9 \u2192 Prop}\n    (h : DirectedOn (f \u207b\u00b9'o (\u00b7 \u2265 \u00b7)) { x | p x }) (ne : \u2203 i, p i) :\n    map m (\u2a05 (i) (_ : p i), f i) = \u2a05 (i) (_ : p i), map m (f i)", "start": [2576, 1], "end": [2581, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inf_le", "code": "theorem map_inf_le {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} : map m (f \u2293 g) \u2264 map m f \u2293 map m g", "start": [2584, 1], "end": [2585, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inf", "code": "theorem map_inf {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (h : Injective m) :\n    map m (f \u2293 g) = map m f \u2293 map m g", "start": [2588, 1], "end": [2593, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inf'", "code": "theorem map_inf' {f g : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {t : Set \u03b1} (htf : t \u2208 f) (htg : t \u2208 g)\n    (h : InjOn m t) : map m (f \u2293 g) = map m f \u2293 map m g", "start": [2596, 1], "end": [2600, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_map", "code": "theorem disjoint_map {m : \u03b1 \u2192 \u03b2} (hm : Injective m) {f\u2081 f\u2082 : Filter \u03b1} :\n    Disjoint (map m f\u2081) (map m f\u2082) \u2194 Disjoint f\u2081 f\u2082", "start": [2603, 1], "end": [2605, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.map_equiv_symm", "code": "theorem map_equiv_symm (e : \u03b1 \u2243 \u03b2) (f : Filter \u03b2) : map e.symm f = comap e f", "start": [2608, 1], "end": [2610, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.map_eq_comap_of_inverse", "code": "theorem map_eq_comap_of_inverse {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {n : \u03b2 \u2192 \u03b1} (h\u2081 : m \u2218 n = id)\n    (h\u2082 : n \u2218 m = id) : map m f = comap n f", "start": [2613, 1], "end": [2615, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_equiv_symm", "code": "theorem comap_equiv_symm (e : \u03b1 \u2243 \u03b2) (f : Filter \u03b1) : comap e.symm f = map e f", "start": [2618, 1], "end": [2619, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.map_swap_eq_comap_swap", "code": "theorem map_swap_eq_comap_swap {f : Filter (\u03b1 \u00d7 \u03b2)} : Prod.swap <$> f = comap Prod.swap f", "start": [2622, 1], "end": [2623, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.map_swap4_eq_comap", "code": "theorem map_swap4_eq_comap {f : Filter ((\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4)} :\n    map (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f =\n      comap (fun p : (\u03b1 \u00d7 \u03b3) \u00d7 \u03b2 \u00d7 \u03b4 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) f", "start": [2626, 1], "end": [2630, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.le_map", "code": "theorem le_map {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {g : Filter \u03b2} (h : \u2200 s \u2208 f, m '' s \u2208 g) : g \u2264 f.map m", "start": [2633, 1], "end": [2634, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.le_map_iff", "code": "theorem le_map_iff {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} {g : Filter \u03b2} : g \u2264 f.map m \u2194 \u2200 s \u2208 f, m '' s \u2208 g", "start": [2637, 1], "end": [2638, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.push_pull", "code": "protected theorem push_pull (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b1) (G : Filter \u03b2) :\n    map f (F \u2293 comap f G) = map f F \u2293 G", "start": [2641, 1], "end": [2654, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.push_pull'", "code": "protected theorem push_pull' (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b1) (G : Filter \u03b2) :\n    map f (comap f G \u2293 F) = G \u2293 map f F", "start": [2657, 1], "end": [2658, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_eq_map_coe_top", "code": "theorem principal_eq_map_coe_top (s : Set \u03b1) : \ud835\udcdf s = map ((\u2191) : s \u2192 \u03b1) \u22a4", "start": [2661, 1], "end": [2661, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_principal_eq_bot_iff_comap", "code": "theorem inf_principal_eq_bot_iff_comap {F : Filter \u03b1} {s : Set \u03b1} :\n    F \u2293 \ud835\udcdf s = \u22a5 \u2194 comap ((\u2191) : s \u2192 \u03b1) F = \u22a5", "start": [2664, 1], "end": [2666, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.singleton_mem_pure", "code": "theorem singleton_mem_pure {a : \u03b1} : {a} \u2208 (pure a : Filter \u03b1)", "start": [2671, 1], "end": [2672, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_injective", "code": "theorem pure_injective : Injective (pure : \u03b1 \u2192 Filter \u03b1)", "start": [2675, 1], "end": [2676, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_neBot", "code": "instance pure_neBot {\u03b1 : Type u} {a : \u03b1} : NeBot (pure a) :=\n  \u27e8mt empty_mem_iff_bot.2 <| not_mem_empty a\u27e9", "start": [2679, 1], "end": [2680, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.le_pure_iff", "code": "@[simp]\ntheorem le_pure_iff {f : Filter \u03b1} {a : \u03b1} : f \u2264 pure a \u2194 {a} \u2208 f", "start": [2683, 1], "end": [2685, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_seq_def", "code": "theorem mem_seq_def {f : Filter (\u03b1 \u2192 \u03b2)} {g : Filter \u03b1} {s : Set \u03b2} :\n    s \u2208 f.seq g \u2194 \u2203 u \u2208 f, \u2203 t \u2208 g, \u2200 x \u2208 u, \u2200 y \u2208 t, (x : \u03b1 \u2192 \u03b2) y \u2208 s", "start": [2688, 1], "end": [2690, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_seq_iff", "code": "theorem mem_seq_iff {f : Filter (\u03b1 \u2192 \u03b2)} {g : Filter \u03b1} {s : Set \u03b2} :\n    s \u2208 f.seq g \u2194 \u2203 u \u2208 f, \u2203 t \u2208 g, Set.seq u t \u2286 s", "start": [2693, 1], "end": [2695, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_map_seq_iff", "code": "theorem mem_map_seq_iff {f : Filter \u03b1} {g : Filter \u03b2} {m : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : Set \u03b3} :\n    s \u2208 (f.map m).seq g \u2194 \u2203 t u, t \u2208 g \u2227 u \u2208 f \u2227 \u2200 x \u2208 u, \u2200 y \u2208 t, m x y \u2208 s", "start": [2698, 1], "end": [2702, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.seq_mem_seq", "code": "theorem seq_mem_seq {f : Filter (\u03b1 \u2192 \u03b2)} {g : Filter \u03b1} {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} (hs : s \u2208 f)\n    (ht : t \u2208 g) : s.seq t \u2208 f.seq g", "start": [2705, 1], "end": [2707, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.le_seq", "code": "theorem le_seq {f : Filter (\u03b1 \u2192 \u03b2)} {g : Filter \u03b1} {h : Filter \u03b2}\n    (hh : \u2200 t \u2208 f, \u2200 u \u2208 g, Set.seq t u \u2208 h) : h \u2264 seq f g", "start": [2710, 1], "end": [2712, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.seq_mono", "code": "@[mono]\ntheorem seq_mono {f\u2081 f\u2082 : Filter (\u03b1 \u2192 \u03b2)} {g\u2081 g\u2082 : Filter \u03b1} (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264 g\u2082) :\n    f\u2081.seq g\u2081 \u2264 f\u2082.seq g\u2082", "start": [2715, 1], "end": [2718, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_seq_eq_map", "code": "@[simp]\ntheorem pure_seq_eq_map (g : \u03b1 \u2192 \u03b2) (f : Filter \u03b1) : seq (pure g) f = f.map g", "start": [2721, 1], "end": [2729, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.seq_pure", "code": "@[simp]\ntheorem seq_pure (f : Filter (\u03b1 \u2192 \u03b2)) (a : \u03b1) : seq f (pure a) = map (fun g : \u03b1 \u2192 \u03b2 => g a) f", "start": [2732, 1], "end": [2739, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.seq_assoc", "code": "@[simp]\ntheorem seq_assoc (x : Filter \u03b1) (g : Filter (\u03b1 \u2192 \u03b2)) (h : Filter (\u03b2 \u2192 \u03b3)) :\n    seq h (seq g x) = seq (seq (map (\u00b7 \u2218 \u00b7) h) g) x", "start": [2742, 1], "end": [2754, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_seq_comm", "code": "theorem prod_map_seq_comm (f : Filter \u03b1) (g : Filter \u03b2) :\n    (map Prod.mk f).seq g = seq (map (fun b a => (a, b)) g) f", "start": [2757, 1], "end": [2767, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.seq_eq_filter_seq", "code": "theorem seq_eq_filter_seq {\u03b1 \u03b2 : Type u} (f : Filter (\u03b1 \u2192 \u03b2)) (g : Filter \u03b1) :\n    f <*> g = seq f g", "start": [2770, 1], "end": [2772, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_bind", "code": "@[simp]\ntheorem eventually_bind {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200\u1da0 y in bind f m, p y) \u2194 \u2200\u1da0 x in f, \u2200\u1da0 y in m x, p y", "start": [2793, 1], "end": [2796, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_bind", "code": "@[simp]\ntheorem eventuallyEq_bind {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b3} :\n    g\u2081 =\u1da0[bind f m] g\u2082 \u2194 \u2200\u1da0 x in f, g\u2081 =\u1da0[m x] g\u2082", "start": [2799, 1], "end": [2802, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyLE_bind", "code": "@[simp]\ntheorem eventuallyLE_bind [LE \u03b3] {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b3} :\n    g\u2081 \u2264\u1da0[bind f m] g\u2082 \u2194 \u2200\u1da0 x in f, g\u2081 \u2264\u1da0[m x] g\u2082", "start": [2805, 1], "end": [2808, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_bind'", "code": "theorem mem_bind' {s : Set \u03b2} {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} :\n    s \u2208 bind f m \u2194 { a | s \u2208 m a } \u2208 f", "start": [2811, 1], "end": [2813, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_bind", "code": "@[simp]\ntheorem mem_bind {s : Set \u03b2} {f : Filter \u03b1} {m : \u03b1 \u2192 Filter \u03b2} :\n    s \u2208 bind f m \u2194 \u2203 t \u2208 f, \u2200 x \u2208 t, s \u2208 m x", "start": [2816, 1], "end": [2822, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.bind_le", "code": "theorem bind_le {f : Filter \u03b1} {g : \u03b1 \u2192 Filter \u03b2} {l : Filter \u03b2} (h : \u2200\u1da0 x in f, g x \u2264 l) :\n    f.bind g \u2264 l", "start": [2825, 1], "end": [2827, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.bind_mono", "code": "@[mono]\ntheorem bind_mono {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : \u03b1 \u2192 Filter \u03b2} (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264\u1da0[f\u2081] g\u2082) :\n    bind f\u2081 g\u2081 \u2264 bind f\u2082 g\u2082", "start": [2830, 1], "end": [2835, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.bind_inf_principal", "code": "theorem bind_inf_principal {f : Filter \u03b1} {g : \u03b1 \u2192 Filter \u03b2} {s : Set \u03b2} :\n    (f.bind fun x => g x \u2293 \ud835\udcdf s) = f.bind g \u2293 \ud835\udcdf s", "start": [2838, 1], "end": [2840, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_bind", "code": "theorem sup_bind {f g : Filter \u03b1} {h : \u03b1 \u2192 Filter \u03b2} : bind (f \u2294 g) h = bind f h \u2294 bind g h", "start": [2843, 1], "end": [2843, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_bind", "code": "theorem principal_bind {s : Set \u03b1} {f : \u03b1 \u2192 Filter \u03b2} : bind (\ud835\udcdf s) f = \u2a06 x \u2208 s, f x", "start": [2846, 1], "end": [2848, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.sequence_mono", "code": "theorem sequence_mono : \u2200 as bs : List (Filter \u03b1), Forall\u2082 (\u00b7 \u2264 \u00b7) as bs \u2192 sequence as \u2264 sequence bs", "start": [2861, 1], "end": [2863, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_traverse", "code": "theorem mem_traverse :\n    \u2200 (fs : List \u03b2') (us : List \u03b3'),\n      Forall\u2082 (fun b c => s c \u2208 f b) fs us \u2192 traverse s us \u2208 traverse f fs", "start": [2868, 1], "end": [2872, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_traverse_iff", "code": "theorem mem_traverse_iff (fs : List \u03b2') (t : Set (List \u03b1')) :\n    t \u2208 traverse f fs \u2194\n      \u2203 us : List (Set \u03b1'), Forall\u2082 (fun b (s : Set \u03b1') => s \u2208 f b) fs us \u2227 sequence us \u2286 t", "start": [2875, 1], "end": [2890, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.ker", "code": "def ker (f : Filter \u03b1) : Set \u03b1 := \u22c2\u2080 f.sets", "start": [2899, 1], "end": [2900, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.ker_def", "code": "lemma ker_def (f : Filter \u03b1) : f.ker = \u22c2 s \u2208 f, s := sInter_eq_biInter", "start": [2902, 1], "end": [2902, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.mem_ker", "code": "@[simp] lemma mem_ker : a \u2208 f.ker \u2194 \u2200 s \u2208 f, a \u2208 s := mem_sInter", "start": [2904, 1], "end": [2904, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.subset_ker", "code": "@[simp] lemma subset_ker : s \u2286 f.ker \u2194 \u2200 t \u2208 f, s \u2286 t := subset_sInter_iff", "start": [2905, 1], "end": [2905, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.gi_principal_ker", "code": "def gi_principal_ker : GaloisCoinsertion (\ud835\udcdf : Set \u03b1 \u2192 Filter \u03b1) ker :=\nGaloisConnection.toGaloisCoinsertion (\u03bb s f \u21a6 by simp [principal_le_iff]) $ by\n  simp only [le_iff_subset, subset_def, mem_ker, mem_principal]; aesop", "start": [2907, 1], "end": [2910, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.ker_mono", "code": "lemma ker_mono : Monotone (ker : Filter \u03b1 \u2192 Set \u03b1) := gi_principal_ker.gc.monotone_u", "start": [2912, 1], "end": [2912, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_surjective", "code": "lemma ker_surjective : Surjective (ker : Filter \u03b1 \u2192 Set \u03b1) := gi_principal_ker.u_surjective", "start": [2913, 1], "end": [2913, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_bot", "code": "@[simp] lemma ker_bot : ker (\u22a5 : Filter \u03b1) = \u2205 := sInter_eq_empty_iff.2 \u03bb _ \u21a6 \u27e8\u2205, trivial, id\u27e9", "start": [2915, 1], "end": [2915, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_top", "code": "@[simp] lemma ker_top : ker (\u22a4 : Filter \u03b1) = univ := gi_principal_ker.gc.u_top", "start": [2916, 1], "end": [2916, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_eq_univ", "code": "@[simp] lemma ker_eq_univ : ker f = univ \u2194 f = \u22a4 := gi_principal_ker.gc.u_eq_top.trans $ by simp", "start": [2917, 1], "end": [2917, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_inf", "code": "@[simp] lemma ker_inf (f g : Filter \u03b1) : ker (f \u2293 g) = ker f \u2229 ker g := gi_principal_ker.gc.u_inf", "start": [2918, 1], "end": [2918, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_iInf", "code": "@[simp] lemma ker_iInf (f : \u03b9 \u2192 Filter \u03b1) : ker (\u2a05 i, f i) = \u2a05 i, ker (f i) :=\ngi_principal_ker.gc.u_iInf", "start": [2919, 1], "end": [2920, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_sInf", "code": "@[simp] lemma ker_sInf (S : Set (Filter \u03b1)) : ker (sInf S) = \u2a05 f \u2208 S, ker f :=\ngi_principal_ker.gc.u_sInf", "start": [2921, 1], "end": [2922, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_principal", "code": "@[simp] lemma ker_principal (s : Set \u03b1) : ker (\ud835\udcdf s) = s := gi_principal_ker.u_l_eq _", "start": [2923, 1], "end": [2923, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_pure", "code": "@[simp] lemma ker_pure (a : \u03b1) : ker (pure a) = {a} := by rw [\u2190principal_singleton, ker_principal]", "start": [2925, 1], "end": [2925, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.ker_comap", "code": "@[simp] lemma ker_comap (m : \u03b1 \u2192 \u03b2) (f : Filter \u03b2) : ker (comap m f) = m \u207b\u00b9' ker f := by\n  ext a\n  simp only [mem_ker, mem_comap, forall_exists_index, and_imp, @forall_swap (Set \u03b1), mem_preimage]\n  exact forall\u2082_congr \u03bb s _ \u21a6 \u27e8\u03bb h \u21a6 h _ Subset.rfl, \u03bb ha t ht \u21a6 ht ha\u27e9", "start": [2927, 1], "end": [2930, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.Tendsto", "code": "def Tendsto (f : \u03b1 \u2192 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :=\n  l\u2081.map f \u2264 l\u2082", "start": [2936, 1], "end": [2940, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_def", "code": "theorem tendsto_def {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    Tendsto f l\u2081 l\u2082 \u2194 \u2200 s \u2208 l\u2082, f \u207b\u00b9' s \u2208 l\u2081", "start": [2943, 1], "end": [2945, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_eventually", "code": "theorem tendsto_iff_eventually {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    Tendsto f l\u2081 l\u2082 \u2194 \u2200 \u2983p : \u03b2 \u2192 Prop\u2984, (\u2200\u1da0 y in l\u2082, p y) \u2192 \u2200\u1da0 x in l\u2081, p (f x)", "start": [2948, 1], "end": [2950, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually", "code": "theorem Tendsto.eventually {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {p : \u03b2 \u2192 Prop}\n    (hf : Tendsto f l\u2081 l\u2082) (h : \u2200\u1da0 y in l\u2082, p y) : \u2200\u1da0 x in l\u2081, p (f x)", "start": [2953, 1], "end": [2955, 7], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.frequently", "code": "theorem Tendsto.frequently {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {p : \u03b2 \u2192 Prop}\n    (hf : Tendsto f l\u2081 l\u2082) (h : \u2203\u1da0 x in l\u2081, p (f x)) : \u2203\u1da0 y in l\u2082, p y", "start": [2958, 1], "end": [2960, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.frequently_map", "code": "theorem Tendsto.frequently_map {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop}\n    (f : \u03b1 \u2192 \u03b2) (c : Filter.Tendsto f l\u2081 l\u2082) (w : \u2200 x, p x \u2192 q (f x)) (h : \u2203\u1da0 x in l\u2081, p x) :\n    \u2203\u1da0 y in l\u2082, q y", "start": [2963, 1], "end": [2966, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_bot", "code": "@[simp]\ntheorem tendsto_bot {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} : Tendsto f \u22a5 l", "start": [2969, 1], "end": [2970, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_top", "code": "@[simp] theorem tendsto_top {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} : Tendsto f l \u22a4", "start": [2973, 1], "end": [2973, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.le_map_of_right_inverse", "code": "theorem le_map_of_right_inverse {mab : \u03b1 \u2192 \u03b2} {mba : \u03b2 \u2192 \u03b1} {f : Filter \u03b1} {g : Filter \u03b2}\n    (h\u2081 : mab \u2218 mba =\u1da0[g] id) (h\u2082 : Tendsto mba g f) : g \u2264 map mab f", "start": [2976, 1], "end": [2979, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_of_isEmpty", "code": "theorem tendsto_of_isEmpty [IsEmpty \u03b1] {f : \u03b1 \u2192 \u03b2} {la : Filter \u03b1} {lb : Filter \u03b2} :\n    Tendsto f la lb", "start": [2982, 1], "end": [2983, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyEq_of_left_inv_of_right_inv", "code": "theorem eventuallyEq_of_left_inv_of_right_inv {f : \u03b1 \u2192 \u03b2} {g\u2081 g\u2082 : \u03b2 \u2192 \u03b1} {fa : Filter \u03b1}\n    {fb : Filter \u03b2} (hleft : \u2200\u1da0 x in fa, g\u2081 (f x) = x) (hright : \u2200\u1da0 y in fb, f (g\u2082 y) = y)\n    (htendsto : Tendsto g\u2082 fb fa) : g\u2081 =\u1da0[fb] g\u2082", "start": [2986, 1], "end": [2989, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_comap", "code": "theorem tendsto_iff_comap {f : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} :\n    Tendsto f l\u2081 l\u2082 \u2194 l\u2081 \u2264 l\u2082.comap f", "start": [2992, 1], "end": [2994, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.le_comap", "code": "alias \u27e8Tendsto.le_comap, _\u27e9 := tendsto_iff_comap", "start": [2997, 1], "end": [2997, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Tendsto.disjoint", "code": "protected theorem Tendsto.disjoint {f : \u03b1 \u2192 \u03b2} {la\u2081 la\u2082 : Filter \u03b1} {lb\u2081 lb\u2082 : Filter \u03b2}\n    (h\u2081 : Tendsto f la\u2081 lb\u2081) (hd : Disjoint lb\u2081 lb\u2082) (h\u2082 : Tendsto f la\u2082 lb\u2082) : Disjoint la\u2081 la\u2082", "start": [3000, 1], "end": [3002, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_congr'", "code": "theorem tendsto_congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082) :\n    Tendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082", "start": [3005, 1], "end": [3006, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.congr'", "code": "theorem Tendsto.congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082)\n    (h : Tendsto f\u2081 l\u2081 l\u2082) : Tendsto f\u2082 l\u2081 l\u2082", "start": [3009, 1], "end": [3011, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_congr", "code": "theorem tendsto_congr {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (h : \u2200 x, f\u2081 x = f\u2082 x) :\n    Tendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082", "start": [3014, 1], "end": [3016, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.congr", "code": "theorem Tendsto.congr {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (h : \u2200 x, f\u2081 x = f\u2082 x) :\n    Tendsto f\u2081 l\u2081 l\u2082 \u2192 Tendsto f\u2082 l\u2081 l\u2082", "start": [3019, 1], "end": [3021, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_id'", "code": "theorem tendsto_id' {x y : Filter \u03b1} : Tendsto id x y \u2194 x \u2264 y", "start": [3024, 1], "end": [3025, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_id", "code": "theorem tendsto_id {x : Filter \u03b1} : Tendsto id x x", "start": [3028, 1], "end": [3029, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.comp", "code": "theorem Tendsto.comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {x : Filter \u03b1} {y : Filter \u03b2} {z : Filter \u03b3}\n    (hg : Tendsto g y z) (hf : Tendsto f x y) : Tendsto (g \u2218 f) x z", "start": [3032, 1], "end": [3033, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mono_left", "code": "theorem Tendsto.mono_left {f : \u03b1 \u2192 \u03b2} {x y : Filter \u03b1} {z : Filter \u03b2} (hx : Tendsto f x z)\n    (h : y \u2264 x) : Tendsto f y z", "start": [3036, 1], "end": [3038, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mono_right", "code": "theorem Tendsto.mono_right {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y z : Filter \u03b2} (hy : Tendsto f x y)\n    (hz : y \u2264 z) : Tendsto f x z", "start": [3041, 1], "end": [3043, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.neBot", "code": "theorem Tendsto.neBot {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : Filter \u03b2} (h : Tendsto f x y) [hx : NeBot x] :\n    NeBot y", "start": [3046, 1], "end": [3048, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_map", "code": "theorem tendsto_map {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} : Tendsto f x (map f x)", "start": [3051, 1], "end": [3052, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_map'_iff", "code": "@[simp]\ntheorem tendsto_map'_iff {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : Filter \u03b3} :\n    Tendsto f (map g x) y \u2194 Tendsto (f \u2218 g) x y", "start": [3055, 1], "end": [3058, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_map'", "code": "alias \u27e8_, tendsto_map'\u27e9 := tendsto_map'_iff", "start": [3061, 1], "end": [3061, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.tendsto_comap", "code": "theorem tendsto_comap {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b2} : Tendsto f (comap f x) x", "start": [3064, 1], "end": [3065, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comap_iff", "code": "@[simp]\ntheorem tendsto_comap_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b1} {c : Filter \u03b3} :\n    Tendsto f a (c.comap g) \u2194 Tendsto (g \u2218 f) a c", "start": [3068, 1], "end": [3071, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comap'_iff", "code": "theorem tendsto_comap'_iff {m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} {g : Filter \u03b2} {i : \u03b3 \u2192 \u03b1} (h : range i \u2208 f) :\n    Tendsto (m \u2218 i) (comap i f) g \u2194 Tendsto m f g", "start": [3074, 1], "end": [3077, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.of_tendsto_comp", "code": "theorem Tendsto.of_tendsto_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b1} {b : Filter \u03b2} {c : Filter \u03b3}\n    (hfg : Tendsto (g \u2218 f) a c) (hg : comap g c \u2264 b) : Tendsto f a b", "start": [3080, 1], "end": [3085, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eq_of_inverse", "code": "theorem comap_eq_of_inverse {f : Filter \u03b1} {g : Filter \u03b2} {\u03c6 : \u03b1 \u2192 \u03b2} (\u03c8 : \u03b2 \u2192 \u03b1) (eq : \u03c8 \u2218 \u03c6 = id)\n    (h\u03c6 : Tendsto \u03c6 f g) (h\u03c8 : Tendsto \u03c8 g f) : comap \u03c6 g = f", "start": [3088, 1], "end": [3091, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map_eq_of_inverse", "code": "theorem map_eq_of_inverse {f : Filter \u03b1} {g : Filter \u03b2} {\u03c6 : \u03b1 \u2192 \u03b2} (\u03c8 : \u03b2 \u2192 \u03b1) (eq : \u03c6 \u2218 \u03c8 = id)\n    (h\u03c6 : Tendsto \u03c6 f g) (h\u03c8 : Tendsto \u03c8 g f) : map \u03c6 f = g", "start": [3094, 1], "end": [3097, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_inf", "code": "theorem tendsto_inf {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y\u2081 y\u2082 : Filter \u03b2} :\n    Tendsto f x (y\u2081 \u2293 y\u2082) \u2194 Tendsto f x y\u2081 \u2227 Tendsto f x y\u2082", "start": [3100, 1], "end": [3102, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_inf_left", "code": "theorem tendsto_inf_left {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y : Filter \u03b2} (h : Tendsto f x\u2081 y) :\n    Tendsto f (x\u2081 \u2293 x\u2082) y", "start": [3105, 1], "end": [3107, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_inf_right", "code": "theorem tendsto_inf_right {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y : Filter \u03b2} (h : Tendsto f x\u2082 y) :\n    Tendsto f (x\u2081 \u2293 x\u2082) y", "start": [3110, 1], "end": [3112, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inf", "code": "theorem Tendsto.inf {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y\u2081 y\u2082 : Filter \u03b2} (h\u2081 : Tendsto f x\u2081 y\u2081)\n    (h\u2082 : Tendsto f x\u2082 y\u2082) : Tendsto f (x\u2081 \u2293 x\u2082) (y\u2081 \u2293 y\u2082)", "start": [3115, 1], "end": [3117, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iInf", "code": "@[simp]\ntheorem tendsto_iInf {f : \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : \u03b9 \u2192 Filter \u03b2} :\n    Tendsto f x (\u2a05 i, y i) \u2194 \u2200 i, Tendsto f x (y i)", "start": [3120, 1], "end": [3123, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iInf'", "code": "theorem tendsto_iInf' {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : Filter \u03b2} (i : \u03b9)\n    (hi : Tendsto f (x i) y) : Tendsto f (\u2a05 i, x i) y", "start": [3126, 1], "end": [3128, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iInf_iInf", "code": "theorem tendsto_iInf_iInf {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : \u03b9 \u2192 Filter \u03b2}\n    (h : \u2200 i, Tendsto f (x i) (y i)) : Tendsto f (iInf x) (iInf y)", "start": [3131, 1], "end": [3133, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_sup", "code": "@[simp]\ntheorem tendsto_sup {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f (x\u2081 \u2294 x\u2082) y \u2194 Tendsto f x\u2081 y \u2227 Tendsto f x\u2082 y", "start": [3136, 1], "end": [3139, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.sup", "code": "theorem Tendsto.sup {f : \u03b1 \u2192 \u03b2} {x\u2081 x\u2082 : Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f x\u2081 y \u2192 Tendsto f x\u2082 y \u2192 Tendsto f (x\u2081 \u2294 x\u2082) y", "start": [3142, 1], "end": [3143, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iSup", "code": "@[simp]\ntheorem tendsto_iSup {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : Filter \u03b2} :\n    Tendsto f (\u2a06 i, x i) y \u2194 \u2200 i, Tendsto f (x i) y", "start": [3146, 1], "end": [3148, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iSup_iSup", "code": "theorem tendsto_iSup_iSup {f : \u03b1 \u2192 \u03b2} {x : \u03b9 \u2192 Filter \u03b1} {y : \u03b9 \u2192 Filter \u03b2}\n    (h : \u2200 i, Tendsto f (x i) (y i)) : Tendsto f (iSup x) (iSup y)", "start": [3151, 1], "end": [3153, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_principal", "code": "@[simp] theorem tendsto_principal {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} {s : Set \u03b2} :\n    Tendsto f l (\ud835\udcdf s) \u2194 \u2200\u1da0 a in l, f a \u2208 s", "start": [3156, 1], "end": [3158, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_principal_principal", "code": "theorem tendsto_principal_principal {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} :\n    Tendsto f (\ud835\udcdf s) (\ud835\udcdf t) \u2194 \u2200 a \u2208 s, f a \u2208 t", "start": [3162, 1], "end": [3164, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pure", "code": "@[simp] theorem tendsto_pure {f : \u03b1 \u2192 \u03b2} {a : Filter \u03b1} {b : \u03b2} :\n    Tendsto f a (pure b) \u2194 \u2200\u1da0 x in a, f x = b", "start": [3167, 1], "end": [3169, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pure_pure", "code": "theorem tendsto_pure_pure (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : Tendsto f (pure a) (pure (f a))", "start": [3172, 1], "end": [3173, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_pure", "code": "theorem tendsto_const_pure {a : Filter \u03b1} {b : \u03b2} : Tendsto (fun _ => b) a (pure b)", "start": [3176, 1], "end": [3177, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_le_iff", "code": "theorem pure_le_iff {a : \u03b1} {l : Filter \u03b1} : pure a \u2264 l \u2194 \u2200 s \u2208 l, a \u2208 s", "start": [3180, 1], "end": [3181, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pure_left", "code": "theorem tendsto_pure_left {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b2} :\n    Tendsto f (pure a) l \u2194 \u2200 s \u2208 l, f a \u2208 s", "start": [3184, 1], "end": [3186, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inf_principal_preimage", "code": "@[simp]\ntheorem map_inf_principal_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {l : Filter \u03b1} :\n    map f (l \u2293 \ud835\udcdf (f \u207b\u00b9' s)) = map f l \u2293 \ud835\udcdf s", "start": [3189, 1], "end": [3192, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.not_tendsto", "code": "theorem Tendsto.not_tendsto {f : \u03b1 \u2192 \u03b2} {a : Filter \u03b1} {b\u2081 b\u2082 : Filter \u03b2} (hf : Tendsto f a b\u2081)\n    [NeBot a] (hb : Disjoint b\u2081 b\u2082) : \u00acTendsto f a b\u2082", "start": [3195, 1], "end": [3199, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.if", "code": "protected theorem Tendsto.if {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {f g : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop}\n    [\u2200 x, Decidable (p x)] (h\u2080 : Tendsto f (l\u2081 \u2293 \ud835\udcdf { x | p x }) l\u2082)\n    (h\u2081 : Tendsto g (l\u2081 \u2293 \ud835\udcdf { x | \u00acp x }) l\u2082) :\n    Tendsto (fun x => if p x then f x else g x) l\u2081 l\u2082", "start": [3202, 1], "end": [3211, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.if'", "code": "protected theorem Tendsto.if' {\u03b1 \u03b2 : Type*} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {f g : \u03b1 \u2192 \u03b2}\n    {p : \u03b1 \u2192 Prop} [DecidablePred p] (hf : Tendsto f l\u2081 l\u2082) (hg : Tendsto g l\u2081 l\u2082) :\n    Tendsto (fun a => if p a then f a else g a) l\u2081 l\u2082", "start": [3214, 1], "end": [3217, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.piecewise", "code": "protected theorem Tendsto.piecewise {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    [\u2200 x, Decidable (x \u2208 s)] (h\u2080 : Tendsto f (l\u2081 \u2293 \ud835\udcdf s) l\u2082) (h\u2081 : Tendsto g (l\u2081 \u2293 \ud835\udcdf s\u1d9c) l\u2082) :\n    Tendsto (piecewise s f g) l\u2081 l\u2082", "start": [3220, 1], "end": [3223, 19], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.eventuallyEq", "code": "theorem Set.EqOn.eventuallyEq {\u03b1 \u03b2} {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : EqOn f g s) : f =\u1da0[\ud835\udcdf s] g", "start": [3230, 1], "end": [3231, 4], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.eventuallyEq_of_mem", "code": "theorem Set.EqOn.eventuallyEq_of_mem {\u03b1 \u03b2} {s : Set \u03b1} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : EqOn f g s)\n    (hl : s \u2208 l) : f =\u1da0[l] g", "start": [3234, 1], "end": [3236, 61], "kind": "commanddeclaration"}, {"full_name": "HasSubset.Subset.eventuallyLE", "code": "theorem HasSubset.Subset.eventuallyLE {\u03b1} {l : Filter \u03b1} {s t : Set \u03b1} (h : s \u2286 t) : s \u2264\u1da0[l] t", "start": [3239, 1], "end": [3240, 32], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.tendsto", "code": "theorem Set.MapsTo.tendsto {\u03b1 \u03b2} {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (h : MapsTo f s t) :\n    Filter.Tendsto f (\ud835\udcdf s) (\ud835\udcdf t)", "start": [3243, 1], "end": [3245, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/List.lean", "imports": ["Mathlib/Logic/Denumerable.lean", "Mathlib/Data/Vector/Basic.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Encodable.encodeList", "code": "def encodeList : List \u03b1 \u2192 \u2115\n  | [] => 0\n  | a :: l => succ (pair (encode a) (encodeList l))", "start": [30, 1], "end": [33, 52], "kind": "commanddeclaration"}, {"full_name": "Encodable.decodeList", "code": "def decodeList : \u2115 \u2192 Option (List \u03b1)\n  | 0 => some []\n  | succ v =>\n    match unpair v, unpair_right_le v with\n    | (v\u2081, v\u2082), h =>\n      have : v\u2082 < succ v := lt_succ_of_le h\n      (\u00b7 :: \u00b7) <$> decode (\u03b1 := \u03b1) v\u2081 <*> decodeList v\u2082", "start": [36, 1], "end": [43, 56], "kind": "commanddeclaration"}, {"full_name": "List.encodable", "code": "instance _root_.List.encodable : Encodable (List \u03b1) :=\n  \u27e8encodeList, decodeList, fun l => by\n    induction' l with a l IH <;> simp [encodeList, decodeList, unpair_pair, encodek, *]\u27e9", "start": [46, 1], "end": [50, 89], "kind": "commanddeclaration"}, {"full_name": "List.countable", "code": "instance _root_.List.countable {\u03b1 : Type*} [Countable \u03b1] : Countable (List \u03b1) := by\n  haveI := Encodable.ofCountable \u03b1\n  infer_instance", "start": [53, 1], "end": [55, 17], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_list_nil", "code": "@[simp]\ntheorem encode_list_nil : encode (@nil \u03b1) = 0", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.encode_list_cons", "code": "@[simp]\ntheorem encode_list_cons (a : \u03b1) (l : List \u03b1) :\n    encode (a :: l) = succ (pair (encode a) (encode l))", "start": [63, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_list_zero", "code": "@[simp]\ntheorem decode_list_zero : decode (\u03b1 := List \u03b1) 0 = some []", "start": [69, 1], "end": [71, 49], "kind": "commanddeclaration"}, {"full_name": "Encodable.decode_list_succ", "code": "@[simp, nolint unusedHavesSuffices] theorem decode_list_succ (v : \u2115) :\n    decode (\u03b1 := List \u03b1) (succ v) =\n      (\u00b7 :: \u00b7) <$> decode (\u03b1 := \u03b1) v.unpair.1 <*> decode (\u03b1 := List \u03b1) v.unpair.2", "start": [74, 1], "end": [80, 30], "kind": "commanddeclaration"}, {"full_name": "Encodable.length_le_encode", "code": "theorem length_le_encode : \u2200 l : List \u03b1, length l \u2264 encode l", "start": [83, 1], "end": [85, 77], "kind": "commanddeclaration"}, {"full_name": "Encodable.enle", "code": "private def enle : \u03b1 \u2192 \u03b1 \u2192 Prop :=\n  encode \u207b\u00b9'o (\u00b7 \u2264 \u00b7)", "start": [94, 1], "end": [95, 22], "kind": "commanddeclaration"}, {"full_name": "Encodable.enle.isLinearOrder", "code": "private theorem enle.isLinearOrder : IsLinearOrder \u03b1 enle", "start": [97, 1], "end": [98, 75], "kind": "commanddeclaration"}, {"full_name": "Encodable.decidable_enle", "code": "private def decidable_enle (a b : \u03b1) : Decidable (enle a b) := by\n  unfold enle Order.Preimage\n  infer_instance", "start": [100, 1], "end": [102, 17], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodeMultiset", "code": "def encodeMultiset (s : Multiset \u03b1) : \u2115 :=\n  encode (s.sort enle)", "start": [106, 1], "end": [108, 23], "kind": "commanddeclaration"}, {"full_name": "Encodable.decodeMultiset", "code": "def decodeMultiset (n : \u2115) : Option (Multiset \u03b1) :=\n  ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) <$> decode (\u03b1 := List \u03b1) n", "start": [111, 1], "end": [113, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.encodable", "code": "instance _root_.Multiset.encodable : Encodable (Multiset \u03b1) :=\n  \u27e8encodeMultiset, decodeMultiset, fun s => by simp [encodeMultiset, decodeMultiset, encodek]\u27e9", "start": [116, 1], "end": [118, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.countable", "code": "instance _root_.Multiset.countable {\u03b1 : Type*} [Countable \u03b1] : Countable (Multiset \u03b1) :=\n  Quotient.countable", "start": [121, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Encodable.encodableOfList", "code": "def encodableOfList [DecidableEq \u03b1] (l : List \u03b1) (H : \u2200 x, x \u2208 l) : Encodable \u03b1 :=\n  \u27e8fun a => indexOf a l, l.get?, fun _ => indexOf_get? (H _)\u27e9", "start": [128, 1], "end": [130, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncEncodable", "code": "def _root_.Fintype.truncEncodable (\u03b1 : Type*) [DecidableEq \u03b1] [Fintype \u03b1] : Trunc (Encodable \u03b1) :=\n  @Quot.recOnSubsingleton' _ _ (fun s : Multiset \u03b1 => (\u2200 x : \u03b1, x \u2208 s) \u2192 Trunc (Encodable \u03b1)) _\n    Finset.univ.1 (fun l H => Trunc.mk <| encodableOfList l H) Finset.mem_univ", "start": [133, 1], "end": [137, 79], "kind": "commanddeclaration"}, {"full_name": "Fintype.toEncodable", "code": "noncomputable def _root_.Fintype.toEncodable (\u03b1 : Type*) [Fintype \u03b1] : Encodable \u03b1 := by\n  classical exact (Fintype.truncEncodable \u03b1).out", "start": [140, 1], "end": [144, 49], "kind": "commanddeclaration"}, {"full_name": "Vector.encodable", "code": "instance _root_.Vector.encodable [Encodable \u03b1] {n} : Encodable (Vector \u03b1 n) :=\n  Subtype.encodable", "start": [147, 1], "end": [149, 20], "kind": "commanddeclaration"}, {"full_name": "Vector.countable", "code": "instance _root_.Vector.countable [Countable \u03b1] {n} : Countable (Vector \u03b1 n) :=\n  Subtype.countable", "start": [152, 1], "end": [154, 20], "kind": "commanddeclaration"}, {"full_name": "Encodable.finArrow", "code": "instance finArrow [Encodable \u03b1] {n} : Encodable (Fin n \u2192 \u03b1) :=\n  ofEquiv _ (Equiv.vectorEquivFin _ _).symm", "start": [157, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Encodable.finPi", "code": "instance finPi (n) (\u03c0 : Fin n \u2192 Type*) [\u2200 i, Encodable (\u03c0 i)] : Encodable (\u2200 i, \u03c0 i) :=\n  ofEquiv _ (Equiv.piEquivSubtypeSigma (Fin n) \u03c0)", "start": [162, 1], "end": [163, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.encodable", "code": "instance _root_.Finset.encodable [Encodable \u03b1] : Encodable (Finset \u03b1) :=\n  haveI := decidableEqOfEncodable \u03b1\n  ofEquiv { s : Multiset \u03b1 // s.Nodup }\n    \u27e8fun \u27e8a, b\u27e9 => \u27e8a, b\u27e9, fun \u27e8a, b\u27e9 => \u27e8a, b\u27e9, fun \u27e8_, _\u27e9 => rfl, fun \u27e8_, _\u27e9 => rfl\u27e9", "start": [166, 1], "end": [170, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.countable", "code": "instance _root_.Finset.countable [Countable \u03b1] : Countable (Finset \u03b1) :=\n  Finset.val_injective.countable", "start": [173, 1], "end": [175, 33], "kind": "commanddeclaration"}, {"full_name": "Encodable.fintypeArrow", "code": "def fintypeArrow (\u03b1 : Type*) (\u03b2 : Type*) [DecidableEq \u03b1] [Fintype \u03b1] [Encodable \u03b2] :\n    Trunc (Encodable (\u03b1 \u2192 \u03b2)) :=\n  (Fintype.truncEquivFin \u03b1).map fun f =>\n    Encodable.ofEquiv (Fin (Fintype.card \u03b1) \u2192 \u03b2) <| Equiv.arrowCongr f (Equiv.refl _)", "start": [179, 1], "end": [184, 86], "kind": "commanddeclaration"}, {"full_name": "Encodable.fintypePi", "code": "def fintypePi (\u03b1 : Type*) (\u03c0 : \u03b1 \u2192 Type*) [DecidableEq \u03b1] [Fintype \u03b1] [\u2200 a, Encodable (\u03c0 a)] :\n    Trunc (Encodable (\u2200 a, \u03c0 a)) :=\n  (Fintype.truncEncodable \u03b1).bind fun a =>\n    (@fintypeArrow \u03b1 (\u03a3a, \u03c0 a) _ _ (@Sigma.encodable _ _ a _)).bind fun f =>\n      Trunc.mk <|\n        @Encodable.ofEquiv _ _ (@Subtype.encodable _ _ f _)\n          (Equiv.piEquivSubtypeSigma \u03b1 \u03c0)", "start": [187, 1], "end": [195, 42], "kind": "commanddeclaration"}, {"full_name": "Encodable.sortedUniv", "code": "def sortedUniv (\u03b1) [Fintype \u03b1] [Encodable \u03b1] : List \u03b1 :=\n  Finset.univ.sort (Encodable.encode' \u03b1 \u207b\u00b9'o (\u00b7 \u2264 \u00b7))", "start": [198, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "Encodable.mem_sortedUniv", "code": "@[simp]\ntheorem mem_sortedUniv {\u03b1} [Fintype \u03b1] [Encodable \u03b1] (x : \u03b1) : x \u2208 sortedUniv \u03b1", "start": [203, 1], "end": [205, 44], "kind": "commanddeclaration"}, {"full_name": "Encodable.length_sortedUniv", "code": "@[simp]\ntheorem length_sortedUniv (\u03b1) [Fintype \u03b1] [Encodable \u03b1] : (sortedUniv \u03b1).length = Fintype.card \u03b1", "start": [208, 1], "end": [210, 23], "kind": "commanddeclaration"}, {"full_name": "Encodable.sortedUniv_nodup", "code": "@[simp]\ntheorem sortedUniv_nodup (\u03b1) [Fintype \u03b1] [Encodable \u03b1] : (sortedUniv \u03b1).Nodup", "start": [213, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "Encodable.sortedUniv_toFinset", "code": "@[simp]\ntheorem sortedUniv_toFinset (\u03b1) [Fintype \u03b1] [Encodable \u03b1] [DecidableEq \u03b1] :\n    (sortedUniv \u03b1).toFinset = Finset.univ", "start": [218, 1], "end": [221, 27], "kind": "commanddeclaration"}, {"full_name": "Encodable.fintypeEquivFin", "code": "def fintypeEquivFin {\u03b1} [Fintype \u03b1] [Encodable \u03b1] : \u03b1 \u2243 Fin (Fintype.card \u03b1) :=\n  haveI : DecidableEq \u03b1 := Encodable.decidableEqOfEncodable _\n  ((sortedUniv_nodup \u03b1).getEquivOfForallMemList _ mem_sortedUniv).symm.trans <|\n    Equiv.cast (congr_arg _ (length_sortedUniv \u03b1))", "start": [224, 1], "end": [229, 51], "kind": "commanddeclaration"}, {"full_name": "Encodable.fintypeArrowOfEncodable", "code": "instance fintypeArrowOfEncodable {\u03b1 \u03b2 : Type*} [Encodable \u03b1] [Fintype \u03b1] [Encodable \u03b2] :\n    Encodable (\u03b1 \u2192 \u03b2) :=\n  ofEquiv (Fin (Fintype.card \u03b1) \u2192 \u03b2) <| Equiv.arrowCongr fintypeEquivFin (Equiv.refl _)", "start": [232, 1], "end": [235, 88], "kind": "commanddeclaration"}, {"full_name": "Denumerable.denumerable_list_aux", "code": "@[nolint unusedHavesSuffices] theorem denumerable_list_aux : \u2200 n : \u2115, \u2203 a \u2208 @decodeList \u03b1 _ n, encodeList a = n", "start": [248, 1], "end": [260, 61], "kind": "commanddeclaration"}, {"full_name": "Denumerable.denumerableList", "code": "instance denumerableList : Denumerable (List \u03b1) :=\n  \u27e8denumerable_list_aux\u27e9", "start": [263, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "Denumerable.list_ofNat_zero", "code": "@[simp]\ntheorem list_ofNat_zero : ofNat (List \u03b1) 0 = []", "start": [268, 1], "end": [269, 94], "kind": "commanddeclaration"}, {"full_name": "Denumerable.list_ofNat_succ", "code": "@[simp, nolint unusedHavesSuffices] theorem list_ofNat_succ (v : \u2115) :\n    ofNat (List \u03b1) (succ v) = ofNat \u03b1 v.unpair.1 :: ofNat (List \u03b1) v.unpair.2", "start": [272, 1], "end": [280, 27], "kind": "commanddeclaration"}, {"full_name": "Denumerable.lower", "code": "def lower : List \u2115 \u2192 \u2115 \u2192 List \u2115\n  | [], _ => []\n  | m :: l, n => (m - n) :: lower l m", "start": [287, 1], "end": [291, 38], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise", "code": "def raise : List \u2115 \u2192 \u2115 \u2192 List \u2115\n  | [], _ => []\n  | m :: l, n => (m + n) :: raise l (m + n)", "start": [294, 1], "end": [298, 44], "kind": "commanddeclaration"}, {"full_name": "Denumerable.lower_raise", "code": "theorem lower_raise : \u2200 l n, lower (raise l n) n = l", "start": [301, 1], "end": [303, 76], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise_lower", "code": "theorem raise_lower : \u2200 {l n}, List.Sorted (\u00b7 \u2264 \u00b7) (n :: l) \u2192 raise (lower l n) n = l", "start": [306, 1], "end": [310, 75], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise_chain", "code": "theorem raise_chain : \u2200 l n, List.Chain (\u00b7 \u2264 \u00b7) n (raise l n)", "start": [313, 1], "end": [315, 73], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise_sorted", "code": "theorem raise_sorted : \u2200 l n, List.Sorted (\u00b7 \u2264 \u00b7) (raise l n)", "start": [318, 1], "end": [321, 61], "kind": "commanddeclaration"}, {"full_name": "Denumerable.multiset", "code": "instance multiset : Denumerable (Multiset \u03b1) :=\n  mk'\n    \u27e8fun s : Multiset \u03b1 => encode <| lower ((s.map encode).sort (\u00b7 \u2264 \u00b7)) 0,\n     fun n =>\n      Multiset.map (ofNat \u03b1) (raise (ofNat (List \u2115) n) 0),\n     fun s => by\n      have :=\n        raise_lower (List.sorted_cons.2 \u27e8fun n _ => Nat.zero_le n, (s.map encode).sort_sorted _\u27e9)\n      simp [-Multiset.coe_map, this],\n     fun n => by\n      simp [-Multiset.coe_map, List.mergeSort_eq_self _ (raise_sorted _ _), lower_raise]\u27e9", "start": [324, 1], "end": [336, 90], "kind": "commanddeclaration"}, {"full_name": "Denumerable.lower'", "code": "def lower' : List \u2115 \u2192 \u2115 \u2192 List \u2115\n  | [], _ => []\n  | m :: l, n => (m - n) :: lower' l (m + 1)", "start": [343, 1], "end": [347, 45], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise'", "code": "def raise' : List \u2115 \u2192 \u2115 \u2192 List \u2115\n  | [], _ => []\n  | m :: l, n => (m + n) :: raise' l (m + n + 1)", "start": [350, 1], "end": [355, 49], "kind": "commanddeclaration"}, {"full_name": "Denumerable.lower_raise'", "code": "theorem lower_raise' : \u2200 l n, lower' (raise' l n) n = l", "start": [358, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise_lower'", "code": "theorem raise_lower' : \u2200 {l n}, (\u2200 m \u2208 l, n \u2264 m) \u2192 List.Sorted (\u00b7 < \u00b7) l \u2192 raise' (lower' l n) n = l", "start": [363, 1], "end": [368, 77], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise'_chain", "code": "theorem raise'_chain : \u2200 (l) {m n}, m < n \u2192 List.Chain (\u00b7 < \u00b7) m (raise' l n)", "start": [371, 1], "end": [374, 95], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise'_sorted", "code": "theorem raise'_sorted : \u2200 l n, List.Sorted (\u00b7 < \u00b7) (raise' l n)", "start": [377, 1], "end": [380, 77], "kind": "commanddeclaration"}, {"full_name": "Denumerable.raise'Finset", "code": "def raise'Finset (l : List \u2115) (n : \u2115) : Finset \u2115 :=\n  \u27e8raise' l n, (raise'_sorted _ _).imp (@ne_of_lt _ _)\u27e9", "start": [383, 1], "end": [385, 56], "kind": "commanddeclaration"}, {"full_name": "Denumerable.finset", "code": "instance finset : Denumerable (Finset \u03b1) :=\n  mk'\n    \u27e8fun s : Finset \u03b1 => encode <| lower' ((s.map (eqv \u03b1).toEmbedding).sort (\u00b7 \u2264 \u00b7)) 0, fun n =>\n      Finset.map (eqv \u03b1).symm.toEmbedding (raise'Finset (ofNat (List \u2115) n) 0), fun s =>\n      Finset.eq_of_veq <| by\n        simp [-Multiset.coe_map, raise'Finset,\n          raise_lower' (fun n _ => Nat.zero_le n) (Finset.sort_sorted_lt _)],\n      fun n => by\n      simp [-Multiset.coe_map, Finset.map, raise'Finset, Finset.sort,\n        List.mergeSort_eq_self (\u00b7 \u2264 \u00b7) ((raise'_sorted _ _).imp (@le_of_lt _ _)), lower_raise']\u27e9", "start": [388, 1], "end": [399, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.listUnitEquiv", "code": "def listUnitEquiv : List Unit \u2243 \u2115 where\n  toFun := List.length\n  invFun n := List.replicate n ()\n  left_inv u := List.length_injective (by simp)\n  right_inv n := List.length_replicate n ()", "start": [408, 1], "end": [413, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.listNatEquivNat", "code": "def listNatEquivNat : List \u2115 \u2243 \u2115 :=\n  Denumerable.eqv _", "start": [416, 1], "end": [418, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.listEquivSelfOfEquivNat", "code": "def listEquivSelfOfEquivNat {\u03b1 : Type*} (e : \u03b1 \u2243 \u2115) : List \u03b1 \u2243 \u03b1 :=\n  calc\n    List \u03b1 \u2243 List \u2115 := listEquivOfEquiv e\n    _ \u2243 \u2115 := listNatEquivNat\n    _ \u2243 \u03b1 := e.symm", "start": [421, 1], "end": [426, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Countable/Basic.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Data/Countable/Defs.lean", "Mathlib/Logic/Equiv/Nat.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "countable_iff_nonempty_embedding", "code": "theorem countable_iff_nonempty_embedding : Countable \u03b1 \u2194 Nonempty (\u03b1 \u21aa \u2115)", "start": [34, 1], "end": [35, 54], "kind": "commanddeclaration"}, {"full_name": "nonempty_embedding_nat", "code": "theorem nonempty_embedding_nat (\u03b1) [Countable \u03b1] : Nonempty (\u03b1 \u21aa \u2115)", "start": [38, 1], "end": [39, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.countable", "code": "protected theorem Function.Embedding.countable [Countable \u03b2] (f : \u03b1 \u21aa \u03b2) : Countable \u03b1", "start": [42, 1], "end": [43, 24], "kind": "commanddeclaration"}, {"full_name": "SetCoe.countable", "code": "instance (priority := 500) SetCoe.countable {\u03b1} [Countable \u03b1] (s : Set \u03b1) : Countable s :=\n  Subtype.countable", "start": [84, 1], "end": [85, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Multiset/Lemmas.lean", "imports": ["Mathlib/Data/List/BigOperators/Lemmas.lean", "Mathlib/Algebra/BigOperators/Multiset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.dvd_prod", "code": "theorem dvd_prod [CommMonoid \u03b1] {s : Multiset \u03b1} {a : \u03b1} : a \u2208 s \u2192 a \u2223 s.prod", "start": [18, 1], "end": [19, 73], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_eq_one_iff", "code": "@[to_additive]\ntheorem prod_eq_one_iff [CanonicallyOrderedCommMonoid \u03b1] {m : Multiset \u03b1} :\n    m.prod = 1 \u2194 \u2200 x \u2208 m, x = (1 : \u03b1)", "start": [22, 1], "end": [25, 72], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.multiset_prod_pos", "code": "@[simp]\nlemma CanonicallyOrderedCommSemiring.multiset_prod_pos {R} [CanonicallyOrderedCommSemiring R]\n    [Nontrivial R] {m : Multiset R} : 0 < m.prod \u2194 (\u2200 x \u2208 m, (0 : R) < x) := by\n  rcases m with \u27e8l\u27e9\n  rw [Multiset.quot_mk_to_coe'', Multiset.coe_prod]\n  exact CanonicallyOrderedCommSemiring.list_prod_pos", "start": [31, 1], "end": [36, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.multiset_sum_right", "code": "theorem multiset_sum_right (a : \u03b1) (h : \u2200 b \u2208 s, Commute a b) : Commute a s.sum", "start": [44, 1], "end": [47, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.multiset_sum_left", "code": "theorem multiset_sum_left (b : \u03b1) (h : \u2200 a \u2208 s, Commute a b) : Commute s.sum b", "start": [50, 1], "end": [51, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Opposite.lean", "imports": ["Mathlib/Algebra/Group/Opposite.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.distrib", "code": "instance distrib [Distrib \u03b1] : Distrib \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.add \u03b1, MulOpposite.mul \u03b1 with\n    left_distrib := fun x y z => unop_injective <| add_mul (unop y) (unop z) (unop x),\n    right_distrib := fun x y z => unop_injective <| mul_add (unop z) (unop x) (unop y) }", "start": [23, 1], "end": [26, 89], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.mulZeroClass", "code": "instance mulZeroClass [MulZeroClass \u03b1] : MulZeroClass \u03b1\u1d50\u1d52\u1d56 where\n  zero := 0\n  mul := (\u00b7 * \u00b7)\n  zero_mul x := unop_injective <| mul_zero <| unop x\n  mul_zero x := unop_injective <| zero_mul <| unop x", "start": [28, 1], "end": [32, 53], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.mulZeroOneClass", "code": "instance mulZeroOneClass [MulZeroOneClass \u03b1] : MulZeroOneClass \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.mulZeroClass \u03b1, MulOpposite.mulOneClass \u03b1 with }", "start": [34, 1], "end": [35, 65], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semigroupWithZero", "code": "instance semigroupWithZero [SemigroupWithZero \u03b1] : SemigroupWithZero \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.semigroup \u03b1, MulOpposite.mulZeroClass \u03b1 with }", "start": [37, 1], "end": [38, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.monoidWithZero", "code": "instance monoidWithZero [MonoidWithZero \u03b1] : MonoidWithZero \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.monoid \u03b1, MulOpposite.mulZeroOneClass \u03b1 with }", "start": [40, 1], "end": [41, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring \u03b1] : NonUnitalNonAssocSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addCommMonoid \u03b1, MulOpposite.mulZeroClass \u03b1, MulOpposite.distrib \u03b1 with }", "start": [43, 1], "end": [44, 90], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalSemiring", "code": "instance nonUnitalSemiring [NonUnitalSemiring \u03b1] : NonUnitalSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.semigroupWithZero \u03b1, MulOpposite.nonUnitalNonAssocSemiring \u03b1 with }", "start": [46, 1], "end": [47, 84], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonAssocSemiring", "code": "instance nonAssocSemiring [NonAssocSemiring \u03b1] : NonAssocSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addMonoidWithOne \u03b1, MulOpposite.mulZeroOneClass \u03b1,\n    MulOpposite.nonUnitalNonAssocSemiring \u03b1 with }", "start": [49, 1], "end": [51, 51], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semiring", "code": "instance semiring [Semiring \u03b1] : Semiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.nonUnitalSemiring \u03b1, MulOpposite.nonAssocSemiring \u03b1,\n    MulOpposite.monoidWithZero \u03b1 with }", "start": [53, 1], "end": [55, 40], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [NonUnitalCommSemiring \u03b1] : NonUnitalCommSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.nonUnitalSemiring \u03b1, MulOpposite.commSemigroup \u03b1 with }", "start": [57, 1], "end": [58, 72], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commSemiring", "code": "instance commSemiring [CommSemiring \u03b1] : CommSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.semiring \u03b1, MulOpposite.commSemigroup \u03b1 with }", "start": [60, 1], "end": [61, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [NonUnitalNonAssocRing \u03b1] : NonUnitalNonAssocRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addCommGroup \u03b1, MulOpposite.mulZeroClass \u03b1,\n    MulOpposite.distrib \u03b1 with }", "start": [63, 1], "end": [65, 33], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalRing", "code": "instance nonUnitalRing [NonUnitalRing \u03b1] : NonUnitalRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addCommGroup \u03b1, MulOpposite.semigroupWithZero \u03b1,\n    MulOpposite.distrib \u03b1 with }", "start": [67, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonAssocRing", "code": "instance nonAssocRing [NonAssocRing \u03b1] : NonAssocRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.addCommGroup \u03b1, MulOpposite.mulZeroOneClass \u03b1,\n    MulOpposite.distrib \u03b1, MulOpposite.addGroupWithOne \u03b1 with }", "start": [71, 1], "end": [73, 64], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.ring", "code": "instance ring [Ring \u03b1] : Ring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.monoid \u03b1, MulOpposite.nonAssocRing \u03b1 with }", "start": [75, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nonUnitalCommRing", "code": "instance nonUnitalCommRing [NonUnitalCommRing \u03b1] : NonUnitalCommRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.nonUnitalRing \u03b1,\n    MulOpposite.nonUnitalCommSemiring \u03b1 with }", "start": [78, 1], "end": [80, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.commRing", "code": "instance commRing [CommRing \u03b1] : CommRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.ring \u03b1, MulOpposite.commSemiring \u03b1 with }", "start": [82, 1], "end": [83, 58], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.noZeroDivisors", "code": "instance noZeroDivisors [Zero \u03b1] [Mul \u03b1] [NoZeroDivisors \u03b1] : NoZeroDivisors \u03b1\u1d50\u1d52\u1d56 where\n  eq_zero_or_eq_zero_of_mul_eq_zero (H : op (_ * _) = op (0 : \u03b1)) :=\n      Or.casesOn (eq_zero_or_eq_zero_of_mul_eq_zero <| op_injective H)\n        (fun hy => Or.inr <| unop_injective <| hy) fun hx => Or.inl <| unop_injective <| hx", "start": [85, 1], "end": [88, 92], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isDomain", "code": "instance isDomain [Ring \u03b1] [IsDomain \u03b1] : IsDomain \u03b1\u1d50\u1d52\u1d56 :=\n  NoZeroDivisors.to_isDomain _", "start": [90, 1], "end": [91, 31], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.groupWithZero", "code": "instance groupWithZero [GroupWithZero \u03b1] : GroupWithZero \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.monoidWithZero \u03b1, MulOpposite.divInvMonoid \u03b1,\n    MulOpposite.nontrivial \u03b1 with\n    mul_inv_cancel := fun _ hx => unop_injective <| inv_mul_cancel <| unop_injective.ne hx,\n    inv_zero := unop_injective inv_zero }", "start": [93, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.distrib", "code": "instance distrib [Distrib \u03b1] : Distrib \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.add \u03b1, @AddOpposite.mul \u03b1 _ with\n    left_distrib := fun x y z => unop_injective <| mul_add (unop x) (unop z) (unop y),\n    right_distrib := fun x y z => unop_injective <| add_mul (unop y) (unop x) (unop z) }", "start": [103, 1], "end": [106, 89], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.mulZeroClass", "code": "instance mulZeroClass [MulZeroClass \u03b1] : MulZeroClass \u03b1\u1d43\u1d52\u1d56 where\n  zero := 0\n  mul := (\u00b7 * \u00b7)\n  zero_mul x := unop_injective <| zero_mul <| unop x\n  mul_zero x := unop_injective <| mul_zero <| unop x", "start": [108, 1], "end": [112, 53], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.mulZeroOneClass", "code": "instance mulZeroOneClass [MulZeroOneClass \u03b1] : MulZeroOneClass \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.mulZeroClass \u03b1, AddOpposite.mulOneClass \u03b1 with }", "start": [114, 1], "end": [115, 65], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.semigroupWithZero", "code": "instance semigroupWithZero [SemigroupWithZero \u03b1] : SemigroupWithZero \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.semigroup \u03b1, AddOpposite.mulZeroClass \u03b1 with }", "start": [117, 1], "end": [118, 63], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.monoidWithZero", "code": "instance monoidWithZero [MonoidWithZero \u03b1] : MonoidWithZero \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.monoid \u03b1, AddOpposite.mulZeroOneClass \u03b1 with }", "start": [120, 1], "end": [121, 63], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring \u03b1] : NonUnitalNonAssocSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommMonoid \u03b1, AddOpposite.mulZeroClass \u03b1, AddOpposite.distrib \u03b1 with }", "start": [123, 1], "end": [124, 90], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalSemiring", "code": "instance nonUnitalSemiring [NonUnitalSemiring \u03b1] : NonUnitalSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.semigroupWithZero \u03b1, AddOpposite.nonUnitalNonAssocSemiring \u03b1 with }", "start": [126, 1], "end": [127, 84], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonAssocSemiring", "code": "instance nonAssocSemiring [NonAssocSemiring \u03b1] : NonAssocSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.mulZeroOneClass \u03b1, AddOpposite.nonUnitalNonAssocSemiring \u03b1,\n    AddOpposite.addCommMonoidWithOne _ with }", "start": [129, 1], "end": [131, 46], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.semiring", "code": "instance semiring [Semiring \u03b1] : Semiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.nonUnitalSemiring \u03b1, AddOpposite.nonAssocSemiring \u03b1,\n    AddOpposite.monoidWithZero \u03b1 with }", "start": [133, 1], "end": [135, 40], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [NonUnitalCommSemiring \u03b1] : NonUnitalCommSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.nonUnitalSemiring \u03b1, AddOpposite.commSemigroup \u03b1 with }", "start": [137, 1], "end": [138, 72], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.commSemiring", "code": "instance commSemiring [CommSemiring \u03b1] : CommSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.semiring \u03b1, AddOpposite.commSemigroup \u03b1 with }", "start": [140, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [NonUnitalNonAssocRing \u03b1] : NonUnitalNonAssocRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommGroup \u03b1, AddOpposite.mulZeroClass \u03b1, AddOpposite.distrib \u03b1 with }", "start": [143, 1], "end": [144, 89], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalRing", "code": "instance nonUnitalRing [NonUnitalRing \u03b1] : NonUnitalRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommGroup \u03b1, AddOpposite.semigroupWithZero \u03b1, AddOpposite.distrib \u03b1 with }", "start": [146, 1], "end": [147, 94], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonAssocRing", "code": "instance nonAssocRing [NonAssocRing \u03b1] : NonAssocRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.addCommGroupWithOne \u03b1, AddOpposite.mulZeroOneClass \u03b1, AddOpposite.distrib \u03b1 with }", "start": [149, 1], "end": [150, 99], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.ring", "code": "instance ring [Ring \u03b1] : Ring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.nonAssocRing \u03b1, AddOpposite.semiring \u03b1 with }", "start": [152, 1], "end": [153, 62], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.nonUnitalCommRing", "code": "instance nonUnitalCommRing [NonUnitalCommRing \u03b1] : NonUnitalCommRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.nonUnitalRing \u03b1, AddOpposite.nonUnitalCommSemiring \u03b1 with }", "start": [155, 1], "end": [156, 76], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.commRing", "code": "instance commRing [CommRing \u03b1] : CommRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.ring \u03b1, AddOpposite.commSemiring \u03b1 with }", "start": [158, 1], "end": [159, 58], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.noZeroDivisors", "code": "instance noZeroDivisors [Zero \u03b1] [Mul \u03b1] [NoZeroDivisors \u03b1] : NoZeroDivisors \u03b1\u1d43\u1d52\u1d56 where\n  eq_zero_or_eq_zero_of_mul_eq_zero (H : op (_ * _) = op (0 : \u03b1)) :=\n    Or.imp (fun hx => unop_injective hx) (fun hy => unop_injective hy)\n    (@eq_zero_or_eq_zero_of_mul_eq_zero \u03b1 _ _ _ _ _ <| op_injective H)", "start": [161, 1], "end": [164, 71], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.isDomain", "code": "instance isDomain [Ring \u03b1] [IsDomain \u03b1] : IsDomain \u03b1\u1d43\u1d52\u1d56 :=\n  NoZeroDivisors.to_isDomain _", "start": [166, 1], "end": [167, 31], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.groupWithZero", "code": "instance groupWithZero [GroupWithZero \u03b1] : GroupWithZero \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.monoidWithZero \u03b1, AddOpposite.divInvMonoid \u03b1,\n    AddOpposite.nontrivial \u03b1 with\n    mul_inv_cancel := fun _ hx => unop_injective <| mul_inv_cancel <| unop_injective.ne hx,\n    inv_zero := unop_injective inv_zero }", "start": [169, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.toOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef NonUnitalRingHom.toOpposite {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f : R \u2192\u2099+* S) (hf : \u2200 x y, Commute (f x) (f y)) : R \u2192\u2099+* S\u1d50\u1d52\u1d56 :=\n  { ((opAddEquiv : S \u2243+ S\u1d50\u1d52\u1d56).toAddMonoidHom.comp \u2191f : R \u2192+ S\u1d50\u1d52\u1d56), f.toMulHom.toOpposite hf with\n    toFun := MulOpposite.op \u2218 f }", "start": [179, 1], "end": [185, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.fromOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef NonUnitalRingHom.fromOpposite {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f : R \u2192\u2099+* S) (hf : \u2200 x y, Commute (f x) (f y)) : R\u1d50\u1d52\u1d56 \u2192\u2099+* S :=\n  { (f.toAddMonoidHom.comp (opAddEquiv : R \u2243+ R\u1d50\u1d52\u1d56).symm.toAddMonoidHom : R\u1d50\u1d52\u1d56 \u2192+ S),\n    f.toMulHom.fromOpposite hf with toFun := f \u2218 MulOpposite.unop }", "start": [188, 1], "end": [194, 68], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.op", "code": "@[simps]\ndef NonUnitalRingHom.op {\u03b1 \u03b2} [NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2] :\n    (\u03b1 \u2192\u2099+* \u03b2) \u2243 (\u03b1\u1d50\u1d52\u1d56 \u2192\u2099+* \u03b2\u1d50\u1d52\u1d56) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MulHom.op f.toMulHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MulHom.unop f.toMulHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [197, 1], "end": [205, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.unop", "code": "@[simp]\ndef NonUnitalRingHom.unop {\u03b1 \u03b2} [NonUnitalNonAssocSemiring \u03b1] [NonUnitalNonAssocSemiring \u03b2] :\n    (\u03b1\u1d50\u1d52\u1d56 \u2192\u2099+* \u03b2\u1d50\u1d52\u1d56) \u2243 (\u03b1 \u2192\u2099+* \u03b2) :=\n  NonUnitalRingHom.op.symm", "start": [208, 1], "end": [213, 27], "kind": "commanddeclaration"}, {"full_name": "RingHom.toOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef RingHom.toOpposite {R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)\n    (hf : \u2200 x y, Commute (f x) (f y)) : R \u2192+* S\u1d50\u1d52\u1d56 :=\n  { ((opAddEquiv : S \u2243+ S\u1d50\u1d52\u1d56).toAddMonoidHom.comp \u2191f : R \u2192+ S\u1d50\u1d52\u1d56), f.toMonoidHom.toOpposite hf with\n    toFun := MulOpposite.op \u2218 f }", "start": [216, 1], "end": [222, 34], "kind": "commanddeclaration"}, {"full_name": "RingHom.fromOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef RingHom.fromOpposite {R S : Type*} [Semiring R] [Semiring S] (f : R \u2192+* S)\n    (hf : \u2200 x y, Commute (f x) (f y)) : R\u1d50\u1d52\u1d56 \u2192+* S :=\n  { (f.toAddMonoidHom.comp (opAddEquiv : R \u2243+ R\u1d50\u1d52\u1d56).symm.toAddMonoidHom : R\u1d50\u1d52\u1d56 \u2192+ S),\n    f.toMonoidHom.fromOpposite hf with toFun := f \u2218 MulOpposite.unop }", "start": [226, 1], "end": [232, 71], "kind": "commanddeclaration"}, {"full_name": "RingHom.op", "code": "@[simps!]\ndef RingHom.op {\u03b1 \u03b2} [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2] :\n    (\u03b1 \u2192+* \u03b2) \u2243 (\u03b1\u1d50\u1d52\u1d56 \u2192+* \u03b2\u1d50\u1d52\u1d56) where\n  toFun f := { AddMonoidHom.mulOp f.toAddMonoidHom, MonoidHom.op f.toMonoidHom with }\n  invFun f := { AddMonoidHom.mulUnop f.toAddMonoidHom, MonoidHom.unop f.toMonoidHom with }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [236, 1], "end": [244, 21], "kind": "commanddeclaration"}, {"full_name": "RingHom.unop", "code": "@[simp]\ndef RingHom.unop {\u03b1 \u03b2} [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2] : (\u03b1\u1d50\u1d52\u1d56 \u2192+* \u03b2\u1d50\u1d52\u1d56) \u2243 (\u03b1 \u2192+* \u03b2) :=\n  RingHom.op.symm", "start": [248, 1], "end": [251, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Antisymmetrization.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AntisymmRel", "code": "def AntisymmRel (a b : \u03b1) : Prop :=\n  r a b \u2227 r b a", "start": [38, 1], "end": [40, 16], "kind": "commanddeclaration"}, {"full_name": "antisymmRel_swap", "code": "theorem antisymmRel_swap : AntisymmRel (swap r) = AntisymmRel r", "start": [43, 1], "end": [44, 51], "kind": "commanddeclaration"}, {"full_name": "antisymmRel_refl", "code": "@[refl]\ntheorem antisymmRel_refl [IsRefl \u03b1 r] (a : \u03b1) : AntisymmRel r a a", "start": [47, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.symm", "code": "@[symm]\ntheorem AntisymmRel.symm {a b : \u03b1} : AntisymmRel r a b \u2192 AntisymmRel r b a", "start": [54, 1], "end": [56, 11], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.trans", "code": "@[trans]\ntheorem AntisymmRel.trans [IsTrans \u03b1 r] {a b c : \u03b1} (hab : AntisymmRel r a b)\n    (hbc : AntisymmRel r b c) : AntisymmRel r a c", "start": [59, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.decidableRel", "code": "instance AntisymmRel.decidableRel [DecidableRel r] : DecidableRel (AntisymmRel r) := fun _ _ =>\n  instDecidableAnd", "start": [65, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "antisymmRel_iff_eq", "code": "@[simp]\ntheorem antisymmRel_iff_eq [IsRefl \u03b1 r] [IsAntisymm \u03b1 r] {a b : \u03b1} : AntisymmRel r a b \u2194 a = b", "start": [69, 1], "end": [71, 15], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.eq", "code": "alias \u27e8AntisymmRel.eq, _\u27e9 := antisymmRel_iff_eq", "start": [74, 1], "end": [74, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntisymmRel.setoid", "code": "@[simps]\ndef AntisymmRel.setoid : Setoid \u03b1 :=\n  \u27e8AntisymmRel r, antisymmRel_refl _, AntisymmRel.symm, AntisymmRel.trans\u27e9", "start": [83, 1], "end": [86, 75], "kind": "commanddeclaration"}, {"full_name": "Antisymmetrization", "code": "def Antisymmetrization : Type _ :=\n  Quotient <| AntisymmRel.setoid \u03b1 r", "start": [90, 1], "end": [93, 37], "kind": "commanddeclaration"}, {"full_name": "toAntisymmetrization", "code": "def toAntisymmetrization : \u03b1 \u2192 Antisymmetrization \u03b1 r :=\n  Quotient.mk _", "start": [98, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "ofAntisymmetrization", "code": "noncomputable def ofAntisymmetrization : Antisymmetrization \u03b1 r \u2192 \u03b1 :=\n  Quotient.out'", "start": [103, 1], "end": [105, 16], "kind": "commanddeclaration"}, {"full_name": "Antisymmetrization.ind", "code": "@[elab_as_elim]\nprotected theorem Antisymmetrization.ind {p : Antisymmetrization \u03b1 r \u2192 Prop} :\n    (\u2200 a, p <| toAntisymmetrization r a) \u2192 \u2200 q, p q", "start": [111, 1], "end": [114, 11], "kind": "commanddeclaration"}, {"full_name": "Antisymmetrization.induction_on", "code": "@[elab_as_elim]\nprotected theorem Antisymmetrization.induction_on {p : Antisymmetrization \u03b1 r \u2192 Prop}\n    (a : Antisymmetrization \u03b1 r) (h : \u2200 a, p <| toAntisymmetrization r a) : p a", "start": [117, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "toAntisymmetrization_ofAntisymmetrization", "code": "@[simp]\ntheorem toAntisymmetrization_ofAntisymmetrization (a : Antisymmetrization \u03b1 r) :\n    toAntisymmetrization r (ofAntisymmetrization r a) = a", "start": [123, 1], "end": [126, 21], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.image", "code": "theorem AntisymmRel.image {a b : \u03b1} (h : AntisymmRel (\u00b7 \u2264 \u00b7) a b) {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    AntisymmRel (\u00b7 \u2264 \u00b7) (f a) (f b)", "start": [135, 1], "end": [137, 19], "kind": "commanddeclaration"}, {"full_name": "instPartialOrderAntisymmetrization", "code": "instance instPartialOrderAntisymmetrization : PartialOrder (Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7)) where\n  le a b :=\n    (Quotient.liftOn\u2082' a b (\u00b7 \u2264 \u00b7)) fun (_ _ _ _ : \u03b1) h\u2081 h\u2082 =>\n      propext \u27e8fun h => h\u2081.2.trans <| h.trans h\u2082.1, fun h => h\u2081.1.trans <| h.trans h\u2082.2\u27e9\n  lt a b :=\n    (Quotient.liftOn\u2082' a b (\u00b7 < \u00b7)) fun (_ _ _ _ : \u03b1) h\u2081 h\u2082 =>\n      propext \u27e8fun h => h\u2081.2.trans_lt <| h.trans_le h\u2082.1, fun h =>\n                h\u2081.1.trans_lt <| h.trans_le h\u2082.2\u27e9\n  le_refl a := Quotient.inductionOn' a <| le_refl\n  le_trans a b c := Quotient.inductionOn\u2083' a b c fun _ _ _ => le_trans\n  lt_iff_le_not_le a b := Quotient.inductionOn\u2082' a b fun _ _ => lt_iff_le_not_le\n  le_antisymm a b := Quotient.inductionOn\u2082' a b fun _ _ hab hba => Quotient.sound' \u27e8hab, hba\u27e9", "start": [140, 1], "end": [151, 94], "kind": "commanddeclaration"}, {"full_name": "antisymmetrization_fibration", "code": "theorem antisymmetrization_fibration :\n    Relation.Fibration (\u00b7 < \u00b7) (\u00b7 < \u00b7) (@toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _)", "start": [153, 1], "end": [156, 20], "kind": "commanddeclaration"}, {"full_name": "acc_antisymmetrization_iff", "code": "theorem acc_antisymmetrization_iff : Acc (\u00b7 < \u00b7)\n    (@toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _ a) \u2194 Acc (\u00b7 < \u00b7) a", "start": [159, 1], "end": [161, 19], "kind": "commanddeclaration"}, {"full_name": "wellFounded_antisymmetrization_iff", "code": "theorem wellFounded_antisymmetrization_iff :\n    WellFounded (@LT.lt (Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7)) _) \u2194 WellFounded (@LT.lt \u03b1 _)", "start": [164, 1], "end": [166, 27], "kind": "commanddeclaration"}, {"full_name": "toAntisymmetrization_le_toAntisymmetrization_iff", "code": "@[simp]\ntheorem toAntisymmetrization_le_toAntisymmetrization_iff :\n    @toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _ a \u2264 @toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _ b \u2194 a \u2264 b", "start": [179, 1], "end": [182, 10], "kind": "commanddeclaration"}, {"full_name": "toAntisymmetrization_lt_toAntisymmetrization_iff", "code": "@[simp]\ntheorem toAntisymmetrization_lt_toAntisymmetrization_iff :\n    @toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _ a < @toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _ b \u2194 a < b", "start": [185, 1], "end": [188, 10], "kind": "commanddeclaration"}, {"full_name": "ofAntisymmetrization_le_ofAntisymmetrization_iff", "code": "@[simp]\ntheorem ofAntisymmetrization_le_ofAntisymmetrization_iff {a b : Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7)} :\n    ofAntisymmetrization (\u00b7 \u2264 \u00b7) a \u2264 ofAntisymmetrization (\u00b7 \u2264 \u00b7) b \u2194 a \u2264 b", "start": [191, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "ofAntisymmetrization_lt_ofAntisymmetrization_iff", "code": "@[simp]\ntheorem ofAntisymmetrization_lt_ofAntisymmetrization_iff {a b : Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7)} :\n    ofAntisymmetrization (\u00b7 \u2264 \u00b7) a < ofAntisymmetrization (\u00b7 \u2264 \u00b7) b \u2194 a < b", "start": [197, 1], "end": [200, 44], "kind": "commanddeclaration"}, {"full_name": "toAntisymmetrization_mono", "code": "@[mono]\ntheorem toAntisymmetrization_mono : Monotone (@toAntisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) _)", "start": [203, 1], "end": [204, 98], "kind": "commanddeclaration"}, {"full_name": "liftFun_antisymmRel", "code": "private theorem liftFun_antisymmRel (f : \u03b1 \u2192o \u03b2) :\n    ((AntisymmRel.setoid \u03b1 (\u00b7 \u2264 \u00b7)).r \u21d2 (AntisymmRel.setoid \u03b2 (\u00b7 \u2264 \u00b7)).r) f f", "start": [207, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "OrderHom.antisymmetrization", "code": "protected def OrderHom.antisymmetrization (f : \u03b1 \u2192o \u03b2) :\n    Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) \u2192o Antisymmetrization \u03b2 (\u00b7 \u2264 \u00b7) :=\n  \u27e8Quotient.map' f <| liftFun_antisymmRel f, fun a b => Quotient.inductionOn\u2082' a b <| f.mono\u27e9", "start": [211, 1], "end": [216, 94], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_antisymmetrization", "code": "@[simp]\ntheorem OrderHom.coe_antisymmetrization (f : \u03b1 \u2192o \u03b2) :\n    \u21d1f.antisymmetrization = Quotient.map' f (liftFun_antisymmRel f)", "start": [219, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.antisymmetrization_apply", "code": "theorem OrderHom.antisymmetrization_apply (f : \u03b1 \u2192o \u03b2) (a : Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7)) :\n    f.antisymmetrization a = Quotient.map' f (liftFun_antisymmRel f) a", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.antisymmetrization_apply_mk", "code": "@[simp]\ntheorem OrderHom.antisymmetrization_apply_mk (f : \u03b1 \u2192o \u03b2) (a : \u03b1) :\n    f.antisymmetrization (toAntisymmetrization _ a) = toAntisymmetrization _ (f a)", "start": [232, 1], "end": [235, 79], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.ofAntisymmetrization", "code": "@[simps]\nnoncomputable def OrderEmbedding.ofAntisymmetrization : Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7) \u21aao \u03b1 :=\n  { Quotient.out'RelEmbedding _ with toFun := _root_.ofAntisymmetrization _ }", "start": [240, 1], "end": [243, 78], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualAntisymmetrization", "code": "def OrderIso.dualAntisymmetrization :\n    (Antisymmetrization \u03b1 (\u00b7 \u2264 \u00b7))\u1d52\u1d48 \u2243o Antisymmetrization \u03b1\u1d52\u1d48 (\u00b7 \u2264 \u00b7) where\n  toFun := (Quotient.map' id) fun _ _ => And.symm\n  invFun := (Quotient.map' id) fun _ _ => And.symm\n  left_inv a := Quotient.inductionOn' a fun a => by simp_rw [Quotient.map'_mk'', id]\n  right_inv a := Quotient.inductionOn' a fun a => by simp_rw [Quotient.map'_mk'', id]\n  map_rel_iff' := @fun a b => Quotient.inductionOn\u2082' a b fun a b => Iff.rfl", "start": [247, 1], "end": [254, 76], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualAntisymmetrization_apply", "code": "@[simp]\ntheorem OrderIso.dualAntisymmetrization_apply (a : \u03b1) :\n    OrderIso.dualAntisymmetrization _ (toDual <| toAntisymmetrization _ a) =\n      toAntisymmetrization _ (toDual a)", "start": [257, 1], "end": [261, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualAntisymmetrization_symm_apply", "code": "@[simp]\ntheorem OrderIso.dualAntisymmetrization_symm_apply (a : \u03b1) :\n    (OrderIso.dualAntisymmetrization _).symm (toAntisymmetrization _ <| toDual a) =\n      toDual (toAntisymmetrization _ a)", "start": [264, 1], "end": [268, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/OrdConnected.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Order/Antichain.lean", "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.OrdConnected", "code": "class OrdConnected (s : Set \u03b1) : Prop where\n  \n  out' \u2983x\u2984 (hx : x \u2208 s) \u2983y\u2984 (hy : y \u2208 s) : Icc x y \u2286 s", "start": [34, 1], "end": [40, 55], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.out", "code": "theorem OrdConnected.out (h : OrdConnected s) : \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), Icc x y \u2286 s", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_def", "code": "theorem ordConnected_def : OrdConnected s \u2194 \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), Icc x y \u2286 s", "start": [47, 1], "end": [48, 31], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iff", "code": "theorem ordConnected_iff : OrdConnected s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2264 y \u2192 Icc x y \u2286 s", "start": [51, 1], "end": [54, 98], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_of_Ioo", "code": "theorem ordConnected_of_Ioo {\u03b1 : Type*} [PartialOrder \u03b1] {s : Set \u03b1}\n    (hs : \u2200 x \u2208 s, \u2200 y \u2208 s, x < y \u2192 Ioo x y \u2286 s) : OrdConnected s", "start": [57, 1], "end": [63, 78], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_mono", "code": "theorem OrdConnected.preimage_mono {f : \u03b2 \u2192 \u03b1} (hs : OrdConnected s) (hf : Monotone f) :\n    OrdConnected (f \u207b\u00b9' s)", "start": [66, 1], "end": [68, 58], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_anti", "code": "theorem OrdConnected.preimage_anti {f : \u03b2 \u2192 \u03b1} (hs : OrdConnected s) (hf : Antitone f) :\n    OrdConnected (f \u207b\u00b9' s)", "start": [71, 1], "end": [73, 58], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_subset", "code": "protected theorem Icc_subset (s : Set \u03b1) [hs : OrdConnected s] {x y} (hx : x \u2208 s) (hy : y \u2208 s) :\n    Icc x y \u2286 s", "start": [76, 1], "end": [78, 15], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.inter", "code": "theorem OrdConnected.inter {s t : Set \u03b1} (hs : OrdConnected s) (ht : OrdConnected t) :\n    OrdConnected (s \u2229 t)", "start": [81, 1], "end": [83, 72], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.inter'", "code": "instance OrdConnected.inter' {s t : Set \u03b1} [OrdConnected s] [OrdConnected t] :\n    OrdConnected (s \u2229 t) :=\n  OrdConnected.inter \u2039_\u203a \u2039_\u203a", "start": [86, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.dual", "code": "theorem OrdConnected.dual {s : Set \u03b1} (hs : OrdConnected s) :\n    OrdConnected (OrderDual.ofDual \u207b\u00b9' s)", "start": [91, 1], "end": [93, 52], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_dual", "code": "theorem ordConnected_dual {s : Set \u03b1} : OrdConnected (OrderDual.ofDual \u207b\u00b9' s) \u2194 OrdConnected s", "start": [96, 1], "end": [97, 76], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_sInter", "code": "theorem ordConnected_sInter {S : Set (Set \u03b1)} (hS : \u2200 s \u2208 S, OrdConnected s) :\n    OrdConnected (\u22c2\u2080 S)", "start": [100, 1], "end": [102, 81], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iInter", "code": "theorem ordConnected_iInter {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, OrdConnected (s i)) :\n    OrdConnected (\u22c2 i, s i)", "start": [105, 1], "end": [107, 47], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iInter'", "code": "instance ordConnected_iInter' {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} [\u2200 i, OrdConnected (s i)] :\n    OrdConnected (\u22c2 i, s i) :=\n  ordConnected_iInter \u2039_\u203a", "start": [110, 1], "end": [112, 26], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_biInter", "code": "theorem ordConnected_biInter {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u2200 (i : \u03b9) (_ : p i), Set \u03b1}\n    (hs : \u2200 i hi, OrdConnected (s i hi)) : OrdConnected (\u22c2 (i) (hi), s i hi)", "start": [116, 1], "end": [118, 59], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_pi", "code": "theorem ordConnected_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)] {s : Set \u03b9}\n    {t : \u2200 i, Set (\u03b1 i)} (h : \u2200 i \u2208 s, OrdConnected (t i)) : OrdConnected (s.pi t)", "start": [121, 1], "end": [123, 81], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_pi'", "code": "instance ordConnected_pi' {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)] {s : Set \u03b9}\n    {t : \u2200 i, Set (\u03b1 i)} [h : \u2200 i, OrdConnected (t i)] : OrdConnected (s.pi t) :=\n  ordConnected_pi fun i _ => h i", "start": [126, 1], "end": [128, 33], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Ici", "code": "@[instance]\ntheorem ordConnected_Ici {a : \u03b1} : OrdConnected (Ici a)", "start": [131, 1], "end": [133, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Iic", "code": "@[instance]\ntheorem ordConnected_Iic {a : \u03b1} : OrdConnected (Iic a)", "start": [136, 1], "end": [138, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Ioi", "code": "@[instance]\ntheorem ordConnected_Ioi {a : \u03b1} : OrdConnected (Ioi a)", "start": [141, 1], "end": [143, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Iio", "code": "@[instance]\ntheorem ordConnected_Iio {a : \u03b1} : OrdConnected (Iio a)", "start": [146, 1], "end": [148, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Icc", "code": "@[instance]\ntheorem ordConnected_Icc {a b : \u03b1} : OrdConnected (Icc a b)", "start": [151, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Ico", "code": "@[instance]\ntheorem ordConnected_Ico {a b : \u03b1} : OrdConnected (Ico a b)", "start": [156, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Ioc", "code": "@[instance]\ntheorem ordConnected_Ioc {a b : \u03b1} : OrdConnected (Ioc a b)", "start": [161, 1], "end": [163, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_Ioo", "code": "@[instance]\ntheorem ordConnected_Ioo {a b : \u03b1} : OrdConnected (Ioo a b)", "start": [166, 1], "end": [168, 42], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_singleton", "code": "@[instance]\ntheorem ordConnected_singleton {\u03b1 : Type*} [PartialOrder \u03b1] {a : \u03b1} :\n    OrdConnected ({a} : Set \u03b1)", "start": [171, 1], "end": [175, 25], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_empty", "code": "@[instance]\ntheorem ordConnected_empty : OrdConnected (\u2205 : Set \u03b1)", "start": [178, 1], "end": [180, 24], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_univ", "code": "@[instance]\ntheorem ordConnected_univ : OrdConnected (univ : Set \u03b1)", "start": [183, 1], "end": [185, 33], "kind": "commanddeclaration"}, {"full_name": "Set.instDenselyOrdered", "code": "instance instDenselyOrdered [DenselyOrdered \u03b1] {s : Set \u03b1} [hs : OrdConnected s] :\n    DenselyOrdered s :=\n  \u27e8fun a b (h : (a : \u03b1) < b) =>\n    let \u27e8x, H\u27e9 := exists_between h\n    \u27e8\u27e8x, (hs.out a.2 b.2) (Ioo_subset_Icc_self H)\u27e9, H\u27e9\u27e9", "start": [188, 1], "end": [193, 56], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_preimage", "code": "@[instance]\ntheorem ordConnected_preimage {F : Type*} [OrderHomClass F \u03b1 \u03b2] (f : F) {s : Set \u03b2}\n    [hs : OrdConnected s] : OrdConnected (f \u207b\u00b9' s)", "start": [195, 1], "end": [198, 94], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_image", "code": "@[instance]\ntheorem ordConnected_image {E : Type*} [OrderIsoClass E \u03b1 \u03b2] (e : E) {s : Set \u03b1}\n    [hs : OrdConnected s] : OrdConnected (e '' s)", "start": [201, 1], "end": [205, 48], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_range", "code": "@[instance]\ntheorem ordConnected_range {E : Type*} [OrderIsoClass E \u03b1 \u03b2] (e : E) : OrdConnected (range e)", "start": [209, 1], "end": [212, 40], "kind": "commanddeclaration"}, {"full_name": "Set.dual_ordConnected_iff", "code": "@[simp]\ntheorem dual_ordConnected_iff {s : Set \u03b1} : OrdConnected (ofDual \u207b\u00b9' s) \u2194 OrdConnected s", "start": [215, 1], "end": [218, 20], "kind": "commanddeclaration"}, {"full_name": "Set.dual_ordConnected", "code": "@[instance]\ntheorem dual_ordConnected {s : Set \u03b1} [OrdConnected s] : OrdConnected (ofDual \u207b\u00b9' s)", "start": [221, 1], "end": [223, 30], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.ordConnected", "code": "protected theorem _root_.IsAntichain.ordConnected (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) : s.OrdConnected", "start": [232, 1], "end": [236, 14], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_uIcc", "code": "@[instance]\ntheorem ordConnected_uIcc {a b : \u03b1} : OrdConnected [[a, b]]", "start": [245, 1], "end": [247, 19], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_uIoc", "code": "@[instance]\ntheorem ordConnected_uIoc {a b : \u03b1} : OrdConnected (\u0399 a b)", "start": [250, 1], "end": [252, 19], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.uIcc_subset", "code": "theorem OrdConnected.uIcc_subset (hs : OrdConnected s) \u2983x\u2984 (hx : x \u2208 s) \u2983y\u2984 (hy : y \u2208 s) :\n    [[x, y]] \u2286 s", "start": [255, 1], "end": [257, 59], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.uIoc_subset", "code": "theorem OrdConnected.uIoc_subset (hs : OrdConnected s) \u2983x\u2984 (hx : x \u2208 s) \u2983y\u2984 (hy : y \u2208 s) :\n    \u0399 x y \u2286 s", "start": [260, 1], "end": [262, 52], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iff_uIcc_subset", "code": "theorem ordConnected_iff_uIcc_subset :\n    OrdConnected s \u2194 \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), [[x, y]] \u2286 s", "start": [265, 1], "end": [267, 89], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_of_uIcc_subset_left", "code": "theorem ordConnected_of_uIcc_subset_left (h : \u2200 y \u2208 s, [[x, y]] \u2286 s) : OrdConnected s", "start": [270, 1], "end": [275, 46], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iff_uIcc_subset_left", "code": "theorem ordConnected_iff_uIcc_subset_left (hx : x \u2208 s) :\n    OrdConnected s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192 [[x, y]] \u2286 s", "start": [278, 1], "end": [280, 66], "kind": "commanddeclaration"}, {"full_name": "Set.ordConnected_iff_uIcc_subset_right", "code": "theorem ordConnected_iff_uIcc_subset_right (hx : x \u2208 s) :\n    OrdConnected s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192 [[y, x]] \u2286 s", "start": [283, 1], "end": [285, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/SetLike/Basic.lean", "imports": ["Mathlib/Tactic/Monotonicity/Attr.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Tactic/SetLike.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetLike", "code": "@[notation_class * carrier Simps.findCoercionArgs]\nclass SetLike (A : Type*) (B : outParam <| Type*) where\n  \n  protected coe : A \u2192 Set B\n  \n  protected coe_injective' : Function.Injective coe", "start": [76, 1], "end": [101, 52], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_sort_coe", "code": "@[simp, norm_cast]\ntheorem coe_sort_coe : ((p : Set B) : Type _) = p", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.exists", "code": "protected theorem \u00abexists\u00bb {q : p \u2192 Prop} : (\u2203 x, q x) \u2194 \u2203 (x : B) (h : x \u2208 p), q \u27e8x, \u2039_\u203a\u27e9", "start": [126, 1], "end": [127, 16], "kind": "commanddeclaration"}, {"full_name": "SetLike.forall", "code": "protected theorem \u00abforall\u00bb {q : p \u2192 Prop} : (\u2200 x, q x) \u2194 \u2200 (x : B) (h : x \u2208 p), q \u27e8x, \u2039_\u203a\u27e9", "start": [130, 1], "end": [131, 16], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_injective", "code": "theorem coe_injective : Function.Injective (SetLike.coe : A \u2192 Set B)", "start": [134, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_set_eq", "code": "@[simp, norm_cast]\ntheorem coe_set_eq : (p : Set B) = q \u2194 p = q", "start": [138, 1], "end": [140, 23], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_ne_coe", "code": "@[norm_cast] lemma coe_ne_coe : (p : Set B) \u2260 q \u2194 p \u2260 q := coe_injective.ne_iff", "start": [143, 1], "end": [143, 80], "kind": "mathlibtacticlemma"}, {"full_name": "SetLike.ext'", "code": "theorem ext' (h : (p : Set B) = q) : p = q", "start": [145, 1], "end": [146, 18], "kind": "commanddeclaration"}, {"full_name": "SetLike.ext'_iff", "code": "theorem ext'_iff : p = q \u2194 (p : Set B) = q", "start": [149, 1], "end": [150, 18], "kind": "commanddeclaration"}, {"full_name": "SetLike.ext", "code": "theorem ext (h : \u2200 x, x \u2208 p \u2194 x \u2208 q) : p = q", "start": [153, 1], "end": [155, 29], "kind": "commanddeclaration"}, {"full_name": "SetLike.ext_iff", "code": "theorem ext_iff : p = q \u2194 \u2200 x, x \u2208 p \u2194 x \u2208 q", "start": [158, 1], "end": [159, 46], "kind": "commanddeclaration"}, {"full_name": "SetLike.mem_coe", "code": "@[simp]\ntheorem mem_coe {x : B} : x \u2208 (p : Set B) \u2194 x \u2208 p", "start": [162, 1], "end": [164, 10], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_eq_coe", "code": "@[simp, norm_cast]\ntheorem coe_eq_coe {x y : p} : (x : B) = y \u2194 x = y", "start": [167, 1], "end": [169, 27], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_mem", "code": "@[simp]\ntheorem coe_mem (x : p) : (x : B) \u2208 p", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.mem_of_subset", "code": "@[aesop 5% apply (rule_sets [SetLike])]\nlemma mem_of_subset {s : Set B} (hp : s \u2286 p) {x : B} (hx : x \u2208 s) : x \u2208 p := hp hx", "start": [180, 1], "end": [181, 83], "kind": "mathlibtacticlemma"}, {"full_name": "SetLike.eta", "code": "protected theorem eta (x : p) (hx : (x : B) \u2208 p) : (\u27e8x, hx\u27e9 : p) = x", "start": [184, 1], "end": [184, 76], "kind": "commanddeclaration"}, {"full_name": "SetLike.instPartialOrder", "code": "instance (priority := 100) instPartialOrder : PartialOrder A :=\n  { PartialOrder.lift (SetLike.coe : A \u2192 Set B) coe_injective with\n    le := fun H K => \u2200 \u2983x\u2984, x \u2208 H \u2192 x \u2208 K }", "start": [187, 1], "end": [189, 44], "kind": "commanddeclaration"}, {"full_name": "SetLike.le_def", "code": "theorem le_def {S T : A} : S \u2264 T \u2194 \u2200 \u2983x : B\u2984, x \u2208 S \u2192 x \u2208 T", "start": [191, 1], "end": [192, 10], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_subset_coe", "code": "@[simp, norm_cast]\ntheorem coe_subset_coe {S T : A} : (S : Set B) \u2286 T \u2194 S \u2264 T", "start": [195, 1], "end": [197, 10], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_mono", "code": "@[mono]\ntheorem coe_mono : Monotone (SetLike.coe : A \u2192 Set B)", "start": [200, 1], "end": [201, 87], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_ssubset_coe", "code": "@[simp, norm_cast]\ntheorem coe_ssubset_coe {S T : A} : (S : Set B) \u2282 T \u2194 S < T", "start": [204, 1], "end": [206, 10], "kind": "commanddeclaration"}, {"full_name": "SetLike.coe_strictMono", "code": "@[mono]\ntheorem coe_strictMono : StrictMono (SetLike.coe : A \u2192 Set B)", "start": [209, 1], "end": [210, 96], "kind": "commanddeclaration"}, {"full_name": "SetLike.not_le_iff_exists", "code": "theorem not_le_iff_exists : \u00acp \u2264 q \u2194 \u2203 x \u2208 p, x \u2209 q", "start": [213, 1], "end": [214, 17], "kind": "commanddeclaration"}, {"full_name": "SetLike.exists_of_lt", "code": "theorem exists_of_lt : p < q \u2192 \u2203 x \u2208 q, x \u2209 p", "start": [217, 1], "end": [218, 24], "kind": "commanddeclaration"}, {"full_name": "SetLike.lt_iff_le_and_exists", "code": "theorem lt_iff_le_and_exists : p < q \u2194 p \u2264 q \u2227 \u2203 x \u2208 q, x \u2209 p", "start": [221, 1], "end": [222, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Perm/Basic.lean", "imports": ["Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Equiv/Set.lean", "Mathlib/Algebra/Hom/Iterate.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "Equiv.Perm.permGroup", "code": "instance permGroup : Group (Perm \u03b1) where\n  mul f g := Equiv.trans g f\n  one := Equiv.refl \u03b1\n  inv := Equiv.symm\n  mul_assoc f g h := (trans_assoc _ _ _).symm\n  one_mul := trans_refl\n  mul_one := refl_trans\n  mul_left_inv := self_trans_symm", "start": [28, 1], "end": [35, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.default_eq", "code": "@[simp]\ntheorem default_eq : (default : Perm \u03b1) = 1", "start": [38, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.equivUnitsEnd", "code": "@[simps]\ndef equivUnitsEnd : Perm \u03b1 \u2243* Units (Function.End \u03b1) where\n  toFun e := \u27e8e.toFun, e.symm.toFun, e.self_comp_symm, e.symm_comp_self\u27e9\n  invFun u :=\n    \u27e8(u : Function.End \u03b1), (\u2191u\u207b\u00b9 : Function.End \u03b1), congr_fun u.inv_val, congr_fun u.val_inv\u27e9\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := rfl", "start": [43, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toHomPerm", "code": "@[simps!]\ndef _root_.MonoidHom.toHomPerm {G : Type*} [Group G] (f : G \u2192* Function.End \u03b1) : G \u2192* Perm \u03b1 :=\n  equivUnitsEnd.symm.toMonoidHom.comp f.toHomUnits", "start": [58, 1], "end": [62, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mul_apply", "code": "theorem mul_apply (f g : Perm \u03b1) (x) : (f * g) x = f (g x)", "start": [67, 1], "end": [68, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_apply", "code": "theorem one_apply (x) : (1 : Perm \u03b1) x = x", "start": [71, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_apply_self", "code": "@[simp]\ntheorem inv_apply_self (f : Perm \u03b1) (x) : f\u207b\u00b9 (f x) = x", "start": [75, 1], "end": [77, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.apply_inv_self", "code": "@[simp]\ntheorem apply_inv_self (f : Perm \u03b1) (x) : f (f\u207b\u00b9 x) = x", "start": [80, 1], "end": [82, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_def", "code": "theorem one_def : (1 : Perm \u03b1) = Equiv.refl \u03b1", "start": [85, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mul_def", "code": "theorem mul_def (f g : Perm \u03b1) : f * g = g.trans f", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_def", "code": "theorem inv_def (f : Perm \u03b1) : f\u207b\u00b9 = f.symm", "start": [93, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.coe_one", "code": "@[simp, norm_cast] lemma coe_one : \u21d1(1 : Perm \u03b1) = id := rfl", "start": [97, 1], "end": [97, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.coe_mul", "code": "@[simp, norm_cast] lemma coe_mul (f g : Perm \u03b1) : \u21d1(f * g) = f \u2218 g := rfl", "start": [100, 1], "end": [100, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.coe_pow", "code": "@[norm_cast] lemma coe_pow (f : Perm \u03b1) (n : \u2115) : \u21d1(f ^ n) = f^[n] :=\n  hom_coe_pow _ rfl (fun _ _ \u21a6 rfl) _ _", "start": [103, 1], "end": [104, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.iterate_eq_pow", "code": "@[simp] lemma iterate_eq_pow (f : Perm \u03b1) (n : \u2115) : f^[n] = \u21d1(f ^ n) := (coe_pow _ _).symm", "start": [107, 1], "end": [107, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.eq_inv_iff_eq", "code": "theorem eq_inv_iff_eq {f : Perm \u03b1} {x y : \u03b1} : x = f\u207b\u00b9 y \u2194 f x = y", "start": [110, 1], "end": [111, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_eq_iff_eq", "code": "theorem inv_eq_iff_eq {f : Perm \u03b1} {x y : \u03b1} : f\u207b\u00b9 x = y \u2194 x = f y", "start": [114, 1], "end": [115, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.zpow_apply_comm", "code": "theorem zpow_apply_comm {\u03b1 : Type*} (\u03c3 : Perm \u03b1) (m n : \u2124) {x : \u03b1} :\n    (\u03c3 ^ m) ((\u03c3 ^ n) x) = (\u03c3 ^ n) ((\u03c3 ^ m) x)", "start": [118, 1], "end": [120, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.image_inv", "code": "@[simp] lemma image_inv (f : Perm \u03b1) (s : Set \u03b1) : \u2191f\u207b\u00b9 '' s = f \u207b\u00b9' s := f\u207b\u00b9.image_eq_preimage _", "start": [123, 1], "end": [123, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.preimage_inv", "code": "@[simp] lemma preimage_inv (f : Perm \u03b1) (s : Set \u03b1) : \u2191f\u207b\u00b9 \u207b\u00b9' s = f '' s :=\n  (f.image_eq_preimage _).symm", "start": [126, 1], "end": [127, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.trans_one", "code": "@[simp]\ntheorem trans_one {\u03b1 : Sort*} {\u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) : e.trans (1 : Perm \u03b2) = e", "start": [136, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mul_refl", "code": "@[simp]\ntheorem mul_refl (e : Perm \u03b1) : e * Equiv.refl \u03b1 = e", "start": [141, 1], "end": [143, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_symm", "code": "@[simp]\ntheorem one_symm : (1 : Perm \u03b1).symm = 1", "start": [146, 1], "end": [148, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.refl_inv", "code": "@[simp]\ntheorem refl_inv : (Equiv.refl \u03b1 : Perm \u03b1)\u207b\u00b9 = 1", "start": [151, 1], "end": [153, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.one_trans", "code": "@[simp]\ntheorem one_trans {\u03b1 : Type*} {\u03b2 : Sort*} (e : \u03b1 \u2243 \u03b2) : (1 : Perm \u03b1).trans e = e", "start": [156, 1], "end": [158, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.refl_mul", "code": "@[simp]\ntheorem refl_mul (e : Perm \u03b1) : Equiv.refl \u03b1 * e = e", "start": [161, 1], "end": [163, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_trans_self", "code": "@[simp]\ntheorem inv_trans_self (e : Perm \u03b1) : e\u207b\u00b9.trans e = 1", "start": [166, 1], "end": [168, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mul_symm", "code": "@[simp]\ntheorem mul_symm (e : Perm \u03b1) : e * e.symm = 1", "start": [171, 1], "end": [173, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.self_trans_inv", "code": "@[simp]\ntheorem self_trans_inv (e : Perm \u03b1) : e.trans e\u207b\u00b9 = 1", "start": [176, 1], "end": [178, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.symm_mul", "code": "@[simp]\ntheorem symm_mul (e : Perm \u03b1) : e.symm * e = 1", "start": [181, 1], "end": [183, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_mul", "code": "@[simp]\ntheorem sumCongr_mul {\u03b1 \u03b2 : Type*} (e : Perm \u03b1) (f : Perm \u03b2) (g : Perm \u03b1) (h : Perm \u03b2) :\n    sumCongr e f * sumCongr g h = sumCongr (e * g) (f * h)", "start": [189, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_inv", "code": "@[simp]\ntheorem sumCongr_inv {\u03b1 \u03b2 : Type*} (e : Perm \u03b1) (f : Perm \u03b2) :\n    (sumCongr e f)\u207b\u00b9 = sumCongr e\u207b\u00b9 f\u207b\u00b9", "start": [195, 1], "end": [198, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_one", "code": "@[simp]\ntheorem sumCongr_one {\u03b1 \u03b2 : Type*} : sumCongr (1 : Perm \u03b1) (1 : Perm \u03b2) = 1", "start": [201, 1], "end": [203, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongrHom", "code": "@[simps]\ndef sumCongrHom (\u03b1 \u03b2 : Type*) : Perm \u03b1 \u00d7 Perm \u03b2 \u2192* Perm (Sum \u03b1 \u03b2) where\n  toFun a := sumCongr a.1 a.2\n  map_one' := sumCongr_one\n  map_mul' _ _ := (sumCongr_mul _ _ _ _).symm", "start": [206, 1], "end": [214, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongrHom_injective", "code": "theorem sumCongrHom_injective {\u03b1 \u03b2 : Type*} : Function.Injective (sumCongrHom \u03b1 \u03b2)", "start": [218, 1], "end": [223, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_swap_one", "code": "@[simp]\ntheorem sumCongr_swap_one {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] (i j : \u03b1) :\n    sumCongr (Equiv.swap i j) (1 : Perm \u03b2) = Equiv.swap (Sum.inl i) (Sum.inl j)", "start": [226, 1], "end": [229, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_one_swap", "code": "@[simp]\ntheorem sumCongr_one_swap {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] (i j : \u03b2) :\n    sumCongr (1 : Perm \u03b1) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)", "start": [232, 1], "end": [235, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_mul", "code": "@[simp]\ntheorem sigmaCongrRight_mul {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (F : \u2200 a, Perm (\u03b2 a))\n    (G : \u2200 a, Perm (\u03b2 a)) : sigmaCongrRight F * sigmaCongrRight G = sigmaCongrRight (F * G)", "start": [241, 1], "end": [244, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_inv", "code": "@[simp]\ntheorem sigmaCongrRight_inv {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (F : \u2200 a, Perm (\u03b2 a)) :\n    (sigmaCongrRight F)\u207b\u00b9 = sigmaCongrRight fun a => (F a)\u207b\u00b9", "start": [247, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_one", "code": "@[simp]\ntheorem sigmaCongrRight_one {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} :\n    sigmaCongrRight (1 : \u2200 a, Equiv.Perm <| \u03b2 a) = 1", "start": [253, 1], "end": [256, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRightHom", "code": "@[simps]\ndef sigmaCongrRightHom {\u03b1 : Type*} (\u03b2 : \u03b1 \u2192 Type*) : (\u2200 a, Perm (\u03b2 a)) \u2192* Perm (\u03a3a, \u03b2 a) where\n  toFun := sigmaCongrRight\n  map_one' := sigmaCongrRight_one\n  map_mul' _ _ := (sigmaCongrRight_mul _ _).symm", "start": [259, 1], "end": [267, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRightHom_injective", "code": "theorem sigmaCongrRightHom_injective {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} :\n    Function.Injective (sigmaCongrRightHom \u03b2)", "start": [271, 1], "end": [275, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongrHom", "code": "@[simps]\ndef subtypeCongrHom (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Perm { a // p a } \u00d7 Perm { a // \u00acp a } \u2192* Perm \u03b1 where\n  toFun pair := Perm.subtypeCongr pair.fst pair.snd\n  map_one' := Perm.subtypeCongr.refl\n  map_mul' _ _ := (Perm.subtypeCongr.trans _ _ _ _).symm", "start": [278, 1], "end": [284, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongrHom_injective", "code": "theorem subtypeCongrHom_injective (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Function.Injective (subtypeCongrHom p)", "start": [288, 1], "end": [292, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.permCongr_eq_mul", "code": "@[simp]\ntheorem permCongr_eq_mul (e p : Perm \u03b1) : e.permCongr p = e * p * e\u207b\u00b9", "start": [295, 1], "end": [299, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_one", "code": "@[simp]\ntheorem extendDomain_one : extendDomain 1 f = 1", "start": [309, 1], "end": [311, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_inv", "code": "@[simp]\ntheorem extendDomain_inv : (e.extendDomain f)\u207b\u00b9 = e\u207b\u00b9.extendDomain f", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_mul", "code": "@[simp]\ntheorem extendDomain_mul (e e' : Perm \u03b1) :\n    e.extendDomain f * e'.extendDomain f = (e * e').extendDomain f", "start": [319, 1], "end": [322, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomainHom", "code": "@[simps]\ndef extendDomainHom : Perm \u03b1 \u2192* Perm \u03b2 where\n  toFun e := extendDomain e f\n  map_one' := extendDomain_one f\n  map_mul' e e' := (extendDomain_mul f e e').symm", "start": [325, 1], "end": [330, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomainHom_injective", "code": "theorem extendDomainHom_injective : Function.Injective (extendDomainHom f)", "start": [334, 1], "end": [337, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_eq_one_iff", "code": "@[simp]\ntheorem extendDomain_eq_one_iff {e : Perm \u03b1} {f : \u03b1 \u2243 Subtype p} : e.extendDomain f = 1 \u2194 e = 1", "start": [340, 1], "end": [342, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_pow", "code": "@[simp]\nlemma extendDomain_pow (n : \u2115) : (e ^ n).extendDomain f = e.extendDomain f ^ n :=\n  map_pow (extendDomainHom f) _ _", "start": [345, 1], "end": [347, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.extendDomain_zpow", "code": "@[simp]\nlemma extendDomain_zpow (n : \u2124) : (e ^ n).extendDomain f = e.extendDomain f ^ n :=\n  map_zpow (extendDomainHom f) _ _", "start": [349, 1], "end": [351, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.Perm.subtypePerm", "code": "def subtypePerm (f : Perm \u03b1) (h : \u2200 x, p x \u2194 p (f x)) : Perm { x // p x } where\n  toFun := fun x => \u27e8f x, (h _).1 x.2\u27e9\n  invFun := fun x => \u27e8f\u207b\u00b9 x, (h (f\u207b\u00b9 x)).2 <| by simpa using x.2\u27e9\n  left_inv _ := by simp only [Perm.inv_apply_self, Subtype.coe_eta, Subtype.coe_mk]\n  right_inv _ := by simp only [Perm.apply_inv_self, Subtype.coe_eta, Subtype.coe_mk]", "start": [359, 1], "end": [365, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_apply", "code": "@[simp]\ntheorem subtypePerm_apply (f : Perm \u03b1) (h : \u2200 x, p x \u2194 p (f x)) (x : { x // p x }) :\n    subtypePerm f h x = \u27e8f x, (h _).1 x.2\u27e9", "start": [368, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_one", "code": "@[simp]\ntheorem subtypePerm_one (p : \u03b1 \u2192 Prop) (h := fun _ => Iff.rfl) : @subtypePerm \u03b1 p 1 h = 1", "start": [374, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_mul", "code": "@[simp]\ntheorem subtypePerm_mul (f g : Perm \u03b1) (hf hg) :\n    (f.subtypePerm hf * g.subtypePerm hg : Perm { x // p x }) =\n      (f * g).subtypePerm fun _ => (hg _).trans <| hf _", "start": [379, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_aux", "code": "private theorem inv_aux : (\u2200 x, p x \u2194 p (f x)) \u2194 \u2200 x, p x \u2194 p (f\u207b\u00b9 x)", "start": [386, 1], "end": [387, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_inv", "code": "theorem subtypePerm_inv (f : Perm \u03b1) (hf) :\n    f\u207b\u00b9.subtypePerm hf = (f.subtypePerm <| inv_aux.2 hf : Perm { x // p x })\u207b\u00b9", "start": [389, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.inv_subtypePerm", "code": "@[simp]\ntheorem inv_subtypePerm (f : Perm \u03b1) (hf) :\n    (f.subtypePerm hf : Perm { x // p x })\u207b\u00b9 = f\u207b\u00b9.subtypePerm (inv_aux.1 hf)", "start": [395, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.pow_aux", "code": "private theorem pow_aux (hf : \u2200 x, p x \u2194 p (f x)) : \u2200 {n : \u2115} (x), p x \u2194 p ((f ^ n) x)", "start": [402, 1], "end": [404, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_pow", "code": "@[simp]\ntheorem subtypePerm_pow (f : Perm \u03b1) (n : \u2115) (hf) :\n    (f.subtypePerm hf : Perm { x // p x }) ^ n = (f ^ n).subtypePerm (pow_aux hf)", "start": [406, 1], "end": [411, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.zpow_aux", "code": "private theorem zpow_aux (hf : \u2200 x, p x \u2194 p (f x)) : \u2200 {n : \u2124} (x), p x \u2194 p ((f ^ n) x)", "start": [414, 1], "end": [418, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_zpow", "code": "@[simp]\ntheorem subtypePerm_zpow (f : Perm \u03b1) (n : \u2124) (hf) :\n    (f.subtypePerm hf ^ n : Perm { x // p x }) = (f ^ n).subtypePerm (zpow_aux hf)", "start": [420, 1], "end": [425, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype", "code": "def ofSubtype : Perm (Subtype p) \u2192* Perm \u03b1 where\n  toFun f := extendDomain f (Equiv.refl (Subtype p))\n  map_one' := Equiv.Perm.extendDomain_one _\n  map_mul' f g := (Equiv.Perm.extendDomain_mul _ f g).symm", "start": [430, 1], "end": [435, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype_subtypePerm", "code": "theorem ofSubtype_subtypePerm {f : Perm \u03b1} (h\u2081 : \u2200 x, p x \u2194 p (f x)) (h\u2082 : \u2200 x, f x \u2260 x \u2192 p x) :\n    ofSubtype (subtypePerm f h\u2081) = f", "start": [438, 1], "end": [447, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype_apply_of_mem", "code": "theorem ofSubtype_apply_of_mem (f : Perm (Subtype p)) (ha : p a) : ofSubtype f a = f \u27e8a, ha\u27e9", "start": [450, 1], "end": [451, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype_apply_coe", "code": "@[simp]\ntheorem ofSubtype_apply_coe (f : Perm (Subtype p)) (x : Subtype p) : ofSubtype f x = f x", "start": [454, 1], "end": [456, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofSubtype_apply_of_not_mem", "code": "theorem ofSubtype_apply_of_not_mem (f : Perm (Subtype p)) (ha : \u00acp a) : ofSubtype f a = a", "start": [459, 1], "end": [460, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.mem_iff_ofSubtype_apply_mem", "code": "theorem mem_iff_ofSubtype_apply_mem (f : Perm (Subtype p)) (x : \u03b1) :\n    p x \u2194 p ((ofSubtype f : \u03b1 \u2192 \u03b1) x)", "start": [463, 1], "end": [467, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypePerm_ofSubtype", "code": "@[simp]\ntheorem subtypePerm_ofSubtype (f : Perm (Subtype p)) :\n    subtypePerm (ofSubtype f) (mem_iff_ofSubtype_apply_mem f) = f", "start": [470, 1], "end": [473, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeEquivSubtypePerm", "code": "@[simps]\nprotected def subtypeEquivSubtypePerm (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Perm (Subtype p) \u2243 { f : Perm \u03b1 // \u2200 a, \u00acp a \u2192 f a = a } where\n  toFun f := \u27e8ofSubtype f, fun _ => f.ofSubtype_apply_of_not_mem\u27e9\n  invFun f :=\n    (f : Perm \u03b1).subtypePerm fun a =>\n      \u27e8Decidable.not_imp_not.1 fun hfa => f.val.injective (f.prop _ hfa) \u25b8 hfa,\n        Decidable.not_imp_not.1 fun ha hfa => ha <| f.prop a ha \u25b8 hfa\u27e9\n  left_inv := Equiv.Perm.subtypePerm_ofSubtype\n  right_inv f :=\n    Subtype.ext ((Equiv.Perm.ofSubtype_subtypePerm _) fun a => Not.decidable_imp_symm <| f.prop a)", "start": [476, 1], "end": [488, 99], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeEquivSubtypePerm_apply_of_mem", "code": "theorem subtypeEquivSubtypePerm_apply_of_mem (f : Perm (Subtype p)) (h : p a) :\n    ((Perm.subtypeEquivSubtypePerm p).toFun f).1 a = f \u27e8a, h\u27e9", "start": [493, 1], "end": [496, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeEquivSubtypePerm_apply_of_not_mem", "code": "theorem subtypeEquivSubtypePerm_apply_of_not_mem (f : Perm (Subtype p)) (h : \u00acp a) :\n    ((Perm.subtypeEquivSubtypePerm p).toFun f).1 a = a", "start": [499, 1], "end": [502, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_inv", "code": "@[simp]\ntheorem swap_inv (x y : \u03b1) : (swap x y)\u207b\u00b9 = swap x y", "start": [513, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_self", "code": "@[simp]\ntheorem swap_mul_self (i j : \u03b1) : swap i j * swap i j = 1", "start": [518, 1], "end": [520, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_eq_mul_swap", "code": "theorem swap_mul_eq_mul_swap (f : Perm \u03b1) (x y : \u03b1) : swap x y * f = f * swap (f\u207b\u00b9 x) (f\u207b\u00b9 y)", "start": [523, 1], "end": [527, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul_swap_eq_swap_mul", "code": "theorem mul_swap_eq_swap_mul (f : Perm \u03b1) (x y : \u03b1) : f * swap x y = swap (f x) (f y) * f", "start": [530, 1], "end": [531, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_apply", "code": "theorem swap_apply_apply (f : Perm \u03b1) (x y : \u03b1) : swap (f x) (f y) = f * swap x y * f\u207b\u00b9", "start": [534, 1], "end": [535, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_self_mul", "code": "@[simp]\ntheorem swap_mul_self_mul (i j : \u03b1) (\u03c3 : Perm \u03b1) : Equiv.swap i j * (Equiv.swap i j * \u03c3) = \u03c3", "start": [538, 1], "end": [544, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul_swap_mul_self", "code": "@[simp]\ntheorem mul_swap_mul_self (i j : \u03b1) (\u03c3 : Perm \u03b1) : \u03c3 * Equiv.swap i j * Equiv.swap i j = \u03c3", "start": [547, 1], "end": [553, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_involutive", "code": "@[simp]\ntheorem swap_mul_involutive (i j : \u03b1) : Function.Involutive ((\u00b7 * \u00b7) (Equiv.swap i j))", "start": [556, 1], "end": [559, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul_swap_involutive", "code": "@[simp]\ntheorem mul_swap_involutive (i j : \u03b1) : Function.Involutive (\u00b7 * Equiv.swap i j)", "start": [562, 1], "end": [565, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_eq_one_iff", "code": "@[simp]\ntheorem swap_eq_one_iff {i j : \u03b1} : swap i j = (1 : Perm \u03b1) \u2194 i = j", "start": [568, 1], "end": [570, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_eq_iff", "code": "theorem swap_mul_eq_iff {i j : \u03b1} {\u03c3 : Perm \u03b1} : swap i j * \u03c3 = \u03c3 \u2194 i = j", "start": [573, 1], "end": [579, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.mul_swap_eq_iff", "code": "theorem mul_swap_eq_iff {i j : \u03b1} {\u03c3 : Perm \u03b1} : \u03c3 * swap i j = \u03c3 \u2194 i = j", "start": [582, 1], "end": [588, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_mul_swap_mul_swap", "code": "theorem swap_mul_swap_mul_swap {x y z : \u03b1} (hwz : x \u2260 y) (hxz : x \u2260 z) :\n    swap y z * swap x y * swap y z = swap z x", "start": [591, 1], "end": [596, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.addLeft_zero", "code": "@[simp] lemma addLeft_zero : Equiv.addLeft (0 : \u03b1) = 1 := ext zero_add", "start": [604, 1], "end": [604, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.addRight_zero", "code": "@[simp] lemma addRight_zero : Equiv.addRight (0 : \u03b1) = 1 := ext add_zero", "start": [607, 1], "end": [607, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.addLeft_add", "code": "@[simp] lemma addLeft_add : Equiv.addLeft (a + b) = Equiv.addLeft a * Equiv.addLeft b :=\n  ext $ add_assoc _ _", "start": [610, 1], "end": [611, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.addRight_add", "code": "@[simp] lemma addRight_add : Equiv.addRight (a + b) = Equiv.addRight b * Equiv.addRight a :=\n  ext $ fun _ \u21a6 (add_assoc _ _ _).symm", "start": [614, 1], "end": [615, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.inv_addLeft", "code": "@[simp] lemma inv_addLeft : (Equiv.addLeft a)\u207b\u00b9 = Equiv.addLeft (-a) := Equiv.coe_inj.1 rfl", "start": [618, 1], "end": [618, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.inv_addRight", "code": "@[simp] lemma inv_addRight : (Equiv.addRight a)\u207b\u00b9 = Equiv.addRight (-a) := Equiv.coe_inj.1 rfl", "start": [621, 1], "end": [621, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.pow_addLeft", "code": "@[simp] lemma pow_addLeft (n : \u2115) : Equiv.addLeft a ^ n = Equiv.addLeft (n \u2022 a) := by\n  ext; simp [Perm.coe_pow]", "start": [624, 1], "end": [625, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.pow_addRight", "code": "@[simp] lemma pow_addRight (n : \u2115) : Equiv.addRight a ^ n = Equiv.addRight (n \u2022 a) := by\n  ext; simp [Perm.coe_pow]", "start": [628, 1], "end": [629, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.zpow_addLeft", "code": "@[simp] lemma zpow_addLeft (n : \u2124) : Equiv.addLeft a ^ n = Equiv.addLeft (n \u2022 a) :=\n  (map_zsmul ({ toFun := Equiv.addLeft, map_zero' := addLeft_zero, map_add' := addLeft_add } :\n    \u03b1 \u2192+ Additive (Perm \u03b1)) _ _).symm", "start": [632, 1], "end": [634, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.zpow_addRight", "code": "@[simp] lemma zpow_addRight : \u2200 (n : \u2124), Equiv.addRight a ^ n = Equiv.addRight (n \u2022 a)\n  | (Int.ofNat n) => by simp\n  | (Int.negSucc n) => by simp", "start": [637, 1], "end": [639, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.mulLeft_one", "code": "@[to_additive existing (attr := simp)]\nlemma mulLeft_one : Equiv.mulLeft (1 : \u03b1) = 1 := ext one_mul", "start": [647, 1], "end": [648, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.mulRight_one", "code": "@[to_additive existing (attr := simp)]\nlemma mulRight_one : Equiv.mulRight (1 : \u03b1) = 1 := ext mul_one", "start": [651, 1], "end": [652, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.mulLeft_mul", "code": "@[to_additive existing (attr := simp)]\nlemma mulLeft_mul : Equiv.mulLeft (a * b) = Equiv.mulLeft a * Equiv.mulLeft b :=\n  ext $ mul_assoc _ _", "start": [655, 1], "end": [657, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.mulRight_mul", "code": "@[to_additive existing (attr := simp)]\nlemma mulRight_mul : Equiv.mulRight (a * b) = Equiv.mulRight b * Equiv.mulRight a :=\n  ext $ fun _ \u21a6 (mul_assoc _ _ _).symm", "start": [660, 1], "end": [662, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.inv_mulLeft", "code": "@[to_additive existing (attr := simp) inv_addLeft]\nlemma inv_mulLeft : (Equiv.mulLeft a)\u207b\u00b9 = Equiv.mulLeft a\u207b\u00b9 := Equiv.coe_inj.1 rfl", "start": [665, 1], "end": [666, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.inv_mulRight", "code": "@[to_additive existing (attr := simp) inv_addRight]\nlemma inv_mulRight : (Equiv.mulRight a)\u207b\u00b9 = Equiv.mulRight a\u207b\u00b9 := Equiv.coe_inj.1 rfl", "start": [669, 1], "end": [670, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.pow_mulLeft", "code": "@[to_additive existing (attr := simp) pow_addLeft]\nlemma pow_mulLeft (n : \u2115) : Equiv.mulLeft a ^ n = Equiv.mulLeft (a ^ n) := by\n  ext; simp [Perm.coe_pow]", "start": [673, 1], "end": [675, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.pow_mulRight", "code": "@[to_additive existing (attr := simp) pow_addRight]\nlemma pow_mulRight (n : \u2115) : Equiv.mulRight a ^ n = Equiv.mulRight (a ^ n) := by\n  ext; simp [Perm.coe_pow]", "start": [678, 1], "end": [680, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.zpow_mulLeft", "code": "@[to_additive existing (attr := simp) zpow_addLeft]\nlemma zpow_mulLeft (n : \u2124) : Equiv.mulLeft a ^ n = Equiv.mulLeft (a ^ n) :=\n  (map_zpow ({ toFun := Equiv.mulLeft, map_one' := mulLeft_one, map_mul' := mulLeft_mul } :\n              \u03b1 \u2192* Perm \u03b1) _ _).symm", "start": [683, 1], "end": [686, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.zpow_mulRight", "code": "@[to_additive existing (attr := simp) zpow_addRight]\nlemma zpow_mulRight : \u2200 n : \u2124, Equiv.mulRight a ^ n = Equiv.mulRight (a ^ n)\n  | (Int.ofNat n) => by simp\n  | (Int.negSucc n) => by simp", "start": [689, 1], "end": [692, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.perm_inv", "code": "lemma BijOn.perm_inv (hf : BijOn f s s) : BijOn \u2191(f\u207b\u00b9) s s := hf.symm f.invOn", "start": [703, 1], "end": [703, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Set.MapsTo.perm_pow", "code": "lemma MapsTo.perm_pow : MapsTo f s s \u2192 \u2200 n : \u2115, MapsTo (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact MapsTo.iterate", "start": [706, 1], "end": [707, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Set.SurjOn.perm_pow", "code": "lemma SurjOn.perm_pow : SurjOn f s s \u2192 \u2200 n : \u2115, SurjOn (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact SurjOn.iterate", "start": [709, 1], "end": [710, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.perm_pow", "code": "lemma BijOn.perm_pow : BijOn f s s \u2192 \u2200 n : \u2115, BijOn (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact BijOn.iterate", "start": [712, 1], "end": [713, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Set.BijOn.perm_zpow", "code": "lemma BijOn.perm_zpow (hf : BijOn f s s) : \u2200 n : \u2124, BijOn (f ^ n) s s\n  | (Int.ofNat _) => hf.perm_pow _\n  | (Int.negSucc _) => (hf.perm_pow _).perm_inv", "start": [716, 1], "end": [718, 48], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Tactic/NormNum/Ineq.lean", "imports": ["Mathlib/Tactic/NormNum/Eq.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.inferOrderedSemiring", "code": "def inferOrderedSemiring (\u03b1 : Q(Type u)) : MetaM Q(OrderedSemiring $\u03b1) :=\n  return \u2190 synthInstanceQ (q(OrderedSemiring $\u03b1) : Q(Type u)) <|>\n    throwError \"not an ordered semiring\"", "start": [20, 1], "end": [23, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferOrderedRing", "code": "def inferOrderedRing (\u03b1 : Q(Type u)) : MetaM Q(OrderedRing $\u03b1) :=\n  return \u2190 synthInstanceQ (q(OrderedRing $\u03b1) : Q(Type u)) <|> throwError \"not an ordered ring\"", "start": [25, 1], "end": [27, 95], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.inferLinearOrderedField", "code": "def inferLinearOrderedField (\u03b1 : Q(Type u)) : MetaM Q(LinearOrderedField $\u03b1) :=\n  return \u2190 synthInstanceQ (q(LinearOrderedField $\u03b1) : Q(Type u)) <|>\n    throwError \"not a linear ordered field\"", "start": [29, 1], "end": [32, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_le_true", "code": "theorem isNat_le_true [OrderedSemiring \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.ble a' b' = true \u2192 a \u2264 b", "start": [34, 1], "end": [36, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_lt_false", "code": "theorem isNat_lt_false [OrderedSemiring \u03b1] {a b : \u03b1} {a' b' : \u2115}\n    (ha : IsNat a a') (hb : IsNat b b') (h : Nat.ble b' a' = true) : \u00aca < b", "start": [38, 1], "end": [40, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_le_true", "code": "theorem isRat_le_true [LinearOrderedRing \u03b1] : {a b : \u03b1} \u2192 {na nb : \u2124} \u2192 {da db : \u2115} \u2192\n    IsRat a na da \u2192 IsRat b nb db \u2192\n    decide (Int.mul na (.ofNat db) \u2264 Int.mul nb (.ofNat da)) \u2192 a \u2264 b", "start": [42, 1], "end": [51, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_lt_true", "code": "theorem isRat_lt_true [LinearOrderedRing \u03b1] [Nontrivial \u03b1] : {a b : \u03b1} \u2192 {na nb : \u2124} \u2192 {da db : \u2115} \u2192\n    IsRat a na da \u2192 IsRat b nb db \u2192 decide (na * db < nb * da) \u2192 a < b", "start": [53, 1], "end": [62, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_le_false", "code": "theorem isRat_le_false [LinearOrderedRing \u03b1] [Nontrivial \u03b1] {a b : \u03b1} {na nb : \u2124} {da db : \u2115}\n    (ha : IsRat a na da) (hb : IsRat b nb db) (h : decide (nb * da < na * db)) : \u00aca \u2264 b", "start": [64, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_lt_false", "code": "theorem isRat_lt_false [LinearOrderedRing \u03b1] {a b : \u03b1} {na nb : \u2124} {da db : \u2115}\n    (ha : IsRat a na da) (hb : IsRat b nb db) (h : decide (nb * da \u2264 na * db)) : \u00aca < b", "start": [68, 1], "end": [70, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_lt_true", "code": "theorem isNat_lt_true [OrderedSemiring \u03b1] [CharZero \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2115} \u2192\n    IsNat a a' \u2192 IsNat b b' \u2192 Nat.ble b' a' = false \u2192 a < b", "start": [74, 1], "end": [77, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_le_false", "code": "theorem isNat_le_false [OrderedSemiring \u03b1] [CharZero \u03b1] {a b : \u03b1} {a' b' : \u2115}\n    (ha : IsNat a a') (hb : IsNat b b') (h : Nat.ble a' b' = false) : \u00aca \u2264 b", "start": [79, 1], "end": [81, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_le_true", "code": "theorem isInt_le_true [OrderedRing \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2124} \u2192\n    IsInt a a' \u2192 IsInt b b' \u2192 decide (a' \u2264 b') \u2192 a \u2264 b", "start": [83, 1], "end": [85, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_lt_true", "code": "theorem isInt_lt_true [OrderedRing \u03b1] [Nontrivial \u03b1] : {a b : \u03b1} \u2192 {a' b' : \u2124} \u2192\n    IsInt a a' \u2192 IsInt b b' \u2192 decide (a' < b') \u2192 a < b", "start": [87, 1], "end": [89, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_le_false", "code": "theorem isInt_le_false [OrderedRing \u03b1] [Nontrivial \u03b1] {a b : \u03b1} {a' b' : \u2124}\n    (ha : IsInt a a') (hb : IsInt b b') (h : decide (b' < a')) : \u00aca \u2264 b", "start": [91, 1], "end": [93, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_lt_false", "code": "theorem isInt_lt_false [OrderedRing \u03b1] {a b : \u03b1} {a' b' : \u2124}\n    (ha : IsInt a a') (hb : IsInt b b') (h : decide (b' \u2264 a')) : \u00aca < b", "start": [95, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalLE", "code": "@[norm_num _ \u2264 _] def evalLE : NormNumExt where eval {v \u03b2} e := do\n  haveI' : v =QL 0 := \u27e8\u27e9; haveI' : $\u03b2 =Q Prop := \u27e8\u27e9\n  let .app (.app f a) b \u2190 whnfR e | failure\n  let \u27e8u, \u03b1, a\u27e9 \u2190 inferTypeQ' a\n  have b : Q($\u03b1) := b\n  let ra \u2190 derive a; let rb \u2190 derive b\n  let rec intArm : MetaM (Result e) := do\n    let _i \u2190 inferOrderedRing \u03b1\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LE.le (\u03b1 := $\u03b1))\n    haveI' : $e =Q ($a \u2264 $b) := \u27e8\u27e9\n    let \u27e8za, na, pa\u27e9 \u2190 ra.toInt q(OrderedRing.toRing)\n    let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt q(OrderedRing.toRing)\n    if decide (za \u2264 zb) then\n      let r : Q(decide ($na \u2264 $nb) = true) := (q(Eq.refl true) : Expr)\n      return .isTrue q(isInt_le_true $pa $pb $r)\n    else if let .some _i \u2190 trySynthInstanceQ (q(@Nontrivial $\u03b1) : Q(Prop)) then\n      let r : Q(decide ($nb < $na) = true) := (q(Eq.refl true) : Expr)\n      return .isFalse q(isInt_le_false $pa $pb $r)\n    else\n      failure\n  let rec ratArm : MetaM (Result e) := do\n    let _i \u2190 inferLinearOrderedField \u03b1\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LE.le (\u03b1 := $\u03b1))\n    haveI' : $e =Q ($a \u2264 $b) := \u27e8\u27e9\n    let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' q(Field.toDivisionRing)\n    let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' q(Field.toDivisionRing)\n    if decide (qa \u2264 qb) then\n      let r : Q(decide ($na * $db \u2264 $nb * $da) = true) := (q(Eq.refl true) : Expr)\n      return (.isTrue q(isRat_le_true $pa $pb $r))\n    else\n      let _i : Q(Nontrivial $\u03b1) := q(StrictOrderedRing.toNontrivial)\n      let r : Q(decide ($nb * $da < $na * $db) = true) := (q(Eq.refl true) : Expr)\n      return .isFalse q(isRat_le_false $pa $pb $r)\n  match ra, rb with\n  | .isBool .., _ | _, .isBool .. => failure\n  | .isRat _ .., _ | _, .isRat _ .. => ratArm\n  | .isNegNat _ .., _ | _, .isNegNat _ .. => intArm\n  | .isNat ra na pa, .isNat rb nb pb =>\n    let _i \u2190 inferOrderedSemiring \u03b1\n    haveI' : $ra =Q by clear! $ra $rb; infer_instance := \u27e8\u27e9\n    haveI' : $rb =Q by clear! $ra $rb; infer_instance := \u27e8\u27e9\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LE.le (\u03b1 := $\u03b1))\n    haveI' : $e =Q ($a \u2264 $b) := \u27e8\u27e9\n    if na.natLit! \u2264 nb.natLit! then\n      let r : Q(Nat.ble $na $nb = true) := (q(Eq.refl true) : Expr)\n      return .isTrue q(isNat_le_true $pa $pb $r)\n    else if let .some _i \u2190 trySynthInstanceQ (q(CharZero $\u03b1) : Q(Prop)) then\n      let r : Q(Nat.ble $na $nb = false) := (q(Eq.refl false) : Expr)\n      return .isFalse q(isNat_le_false $pa $pb $r)\n    else intArm", "start": [99, 1], "end": [152, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalLT", "code": "@[norm_num _ < _] def evalLT : NormNumExt where eval {v \u03b2} e := do\n  haveI' : v =QL 0 := \u27e8\u27e9; haveI' : $\u03b2 =Q Prop := \u27e8\u27e9\n  let .app (.app f a) b \u2190 whnfR e | failure\n  let \u27e8u, \u03b1, a\u27e9 \u2190 inferTypeQ' a\n  have b : Q($\u03b1) := b\n  let ra \u2190 derive a; let rb \u2190 derive b\n  let rec intArm : MetaM (Result e) := do\n    let _i \u2190 inferOrderedRing \u03b1\n    assumeInstancesCommute\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LT.lt (\u03b1 := $\u03b1))\n    haveI' : $e =Q ($a < $b) := \u27e8\u27e9\n    let \u27e8za, na, pa\u27e9 \u2190 ra.toInt q(OrderedRing.toRing)\n    let \u27e8zb, nb, pb\u27e9 \u2190 rb.toInt q(OrderedRing.toRing)\n    if za < zb then\n      if let .some _i \u2190 trySynthInstanceQ (q(@Nontrivial $\u03b1) : Q(Prop)) then\n        let r : Q(decide ($na < $nb) = true) := (q(Eq.refl true) : Expr)\n        return .isTrue q(isInt_lt_true $pa $pb $r)\n      else\n        failure\n    else\n      let r : Q(decide ($nb \u2264 $na) = true) := (q(Eq.refl true) : Expr)\n      return .isFalse q(isInt_lt_false $pa $pb $r)\n  let rec ratArm : MetaM (Result e) := do\n    let _i \u2190 inferLinearOrderedField \u03b1\n    assumeInstancesCommute\n    haveI' : $e =Q ($a < $b) := \u27e8\u27e9\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LT.lt (\u03b1 := $\u03b1))\n    let \u27e8qa, na, da, pa\u27e9 \u2190 ra.toRat' q(Field.toDivisionRing)\n    let \u27e8qb, nb, db, pb\u27e9 \u2190 rb.toRat' q(Field.toDivisionRing)\n    if qa < qb then\n      let r : Q(decide ($na * $db < $nb * $da) = true) := (q(Eq.refl true) : Expr)\n      return .isTrue q(isRat_lt_true $pa $pb $r)\n    else\n      let r : Q(decide ($nb * $da \u2264 $na * $db) = true) := (q(Eq.refl true) : Expr)\n      return .isFalse q(isRat_lt_false $pa $pb $r)\n  match ra, rb with\n  | .isBool .., _ | _, .isBool .. => failure\n  | .isRat _ .., _ | _, .isRat _ .. => ratArm\n  | .isNegNat _ .., _ | _, .isNegNat _ .. => intArm\n  | .isNat ra na pa, .isNat rb nb pb =>\n    let _i \u2190 inferOrderedSemiring \u03b1\n    haveI' : $ra =Q by clear! $ra $rb; infer_instance := \u27e8\u27e9\n    haveI' : $rb =Q by clear! $ra $rb; infer_instance := \u27e8\u27e9\n    haveI' : $e =Q ($a < $b) := \u27e8\u27e9\n    guard <|\u2190 withNewMCtxDepth <| isDefEq f q(LT.lt (\u03b1 := $\u03b1))\n    if na.natLit! < nb.natLit! then\n      if let .some _i \u2190 trySynthInstanceQ q(CharZero $\u03b1) then\n        let r : Q(Nat.ble $nb $na = false) := (q(Eq.refl false) : Expr)\n        return .isTrue q(isNat_lt_true $pa $pb $r)\n      else intArm\n    else\n      let r : Q(Nat.ble $nb $na = true) := (q(Eq.refl true) : Expr)\n      return .isFalse q(isNat_lt_false $pa $pb $r)", "start": [154, 1], "end": [210, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/OfScientific.lean", "imports": ["Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Data/Rat/Cast/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.inferOfScientific", "code": "def inferOfScientific (\u03b1 : Q(Type u)) : MetaM Q(OfScientific $\u03b1) :=\n  return \u2190 synthInstanceQ (q(OfScientific $\u03b1) : Q(Type u)) <|>\n    throwError \"does not support scientific notation\"", "start": [22, 1], "end": [25, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_ofScientific_of_true", "code": "theorem isRat_ofScientific_of_true [DivisionRing \u03b1] (\u03c3\u03b1 : OfScientific \u03b1) :\n    {m e : \u2115} \u2192 {n : \u2124} \u2192 {d : \u2115} \u2192\n    @OfScientific.ofScientific \u03b1 \u03c3\u03b1 = (fun m s e \u21a6 (Rat.ofScientific m s e : \u03b1)) \u2192\n    IsRat (mkRat m (10 ^ e) : \u03b1) n d \u2192 IsRat (@OfScientific.ofScientific \u03b1 \u03c3\u03b1 m true e) n d", "start": [28, 1], "end": [32, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_ofScientific_of_false", "code": "theorem isNat_ofScientific_of_false [DivisionRing \u03b1] (\u03c3\u03b1 : OfScientific \u03b1) : {m e nm ne n : \u2115} \u2192\n    @OfScientific.ofScientific \u03b1 \u03c3\u03b1 = (fun m s e \u21a6 (Rat.ofScientific m s e : \u03b1)) \u2192\n    IsNat m nm \u2192 IsNat e ne \u2192 n = Nat.mul nm ((10 : \u2115) ^ ne) \u2192\n    IsNat (@OfScientific.ofScientific \u03b1 \u03c3\u03b1 m false e : \u03b1) n", "start": [35, 1], "end": [39, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalOfScientific", "code": "@[norm_num OfScientific.ofScientific _ _ _] def evalOfScientific :\n    NormNumExt where eval {u \u03b1} e := do\n  let .app (.app (.app f (m : Q(\u2115))) (b : Q(Bool))) (exp : Q(\u2115)) \u2190 whnfR e | failure\n  let d\u03b1 \u2190 inferDivisionRing \u03b1\n  guard <|\u2190 withNewMCtxDepth <| isDefEq f q(OfScientific.ofScientific (\u03b1 := $\u03b1))\n  let \u03c3\u03b1 \u2190 inferOfScientific \u03b1\n  assumeInstancesCommute\n  haveI' : $e =Q OfScientific.ofScientific $m $b $exp := \u27e8\u27e9\n  haveI' lh : @OfScientific.ofScientific $\u03b1 $\u03c3\u03b1 =Q (fun m s e \u21a6 (Rat.ofScientific m s e : $\u03b1)) := \u27e8\u27e9\n  match b with\n  | ~q(true)  =>\n    let rme \u2190 derive (q(mkRat $m (10 ^ $exp)) : Q($\u03b1))\n    let some \u27e8q, n, d, p\u27e9 := rme.toRat' d\u03b1 | failure\n    return .isRat' d\u03b1 q n d q(isRat_ofScientific_of_true $\u03c3\u03b1 $lh $p)\n  | ~q(false) =>\n    let \u27e8nm, pm\u27e9 \u2190 deriveNat m q(AddCommMonoidWithOne.toAddMonoidWithOne)\n    let \u27e8ne, pe\u27e9 \u2190 deriveNat exp q(AddCommMonoidWithOne.toAddMonoidWithOne)\n    have pm : Q(IsNat $m $nm) := pm\n    have pe : Q(IsNat $exp $ne) := pe\n    let m' := nm.natLit!\n    let exp' := ne.natLit!\n    let n' := Nat.mul m' (Nat.pow (10 : \u2115) exp')\n    have n : Q(\u2115) := mkRawNatLit n'\n    haveI : $n =Q Nat.mul $nm ((10 : \u2115) ^ $ne) := \u27e8\u27e9\n    return .isNat _ n q(isNat_ofScientific_of_false $\u03c3\u03b1 $lh $pm $pe (.refl $n))", "start": [41, 1], "end": [67, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum/Pow.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Tactic/NormNum/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Meta.NormNum.natPow_zero", "code": "theorem natPow_zero : Nat.pow a (nat_lit 0) = nat_lit 1", "start": [22, 1], "end": [22, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.natPow_one", "code": "theorem natPow_one : Nat.pow a (nat_lit 1) = a", "start": [23, 1], "end": [23, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.zero_natPow", "code": "theorem zero_natPow : Nat.pow (nat_lit 0) (Nat.succ b) = nat_lit 0", "start": [24, 1], "end": [24, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.one_natPow", "code": "theorem one_natPow : Nat.pow (nat_lit 1) b = nat_lit 1", "start": [25, 1], "end": [25, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNatPowT", "code": "structure IsNatPowT (p : Prop) (a b c : Nat) : Prop where\n  \n  run' : p \u2192 Nat.pow a b = c", "start": [27, 1], "end": [33, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNatPowT.run", "code": "theorem IsNatPowT.run\n    (p : IsNatPowT (Nat.pow a (nat_lit 1) = a) a b c) : Nat.pow a b = c", "start": [35, 1], "end": [36, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNatPowT.trans", "code": "theorem IsNatPowT.trans (h1 : IsNatPowT p a b c) (h2 : IsNatPowT (Nat.pow a b = c) a b' c') :\n    IsNatPowT p a b' c'", "start": [38, 1], "end": [41, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNatPowT.bit0", "code": "theorem IsNatPowT.bit0 : IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b) (Nat.mul c c)", "start": [43, 1], "end": [44, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.IsNatPowT.bit1", "code": "theorem IsNatPowT.bit1 :\n    IsNatPowT (Nat.pow a b = c) a (nat_lit 2 * b + nat_lit 1) (Nat.mul c (Nat.mul c a))", "start": [45, 1], "end": [47, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalNatPow", "code": "partial def evalNatPow (a b : Q(\u2115)) : (c : Q(\u2115)) \u00d7 Q(Nat.pow $a $b = $c) :=\n  if b.natLit! = 0 then\n    haveI : $b =Q 0 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(natPow_zero)\u27e9\n  else if a.natLit! = 0 then\n    haveI : $a =Q 0 := \u27e8\u27e9\n    have b' : Q(\u2115) := mkRawNatLit (b.natLit! - 1)\n    haveI : $b =Q Nat.succ $b' := \u27e8\u27e9\n    \u27e8q(nat_lit 0), q(zero_natPow)\u27e9\n  else if a.natLit! = 1 then\n    haveI : $a =Q 1 := \u27e8\u27e9\n    \u27e8q(nat_lit 1), q(one_natPow)\u27e9\n  else if b.natLit! = 1 then\n    haveI : $b =Q 1 := \u27e8\u27e9\n    \u27e8a, q(natPow_one)\u27e9\n  else\n    let \u27e8c, p\u27e9 := go b.natLit!.log2 a (mkRawNatLit 1) a b _ .rfl\n    \u27e8c, q(($p).run)\u27e9\nwhere\n  \n  go (depth : Nat) (a b\u2080 c\u2080 b : Q(\u2115)) (p : Q(Prop)) (hp : $p =Q (Nat.pow $a $b\u2080 = $c\u2080)) :\n      (c : Q(\u2115)) \u00d7 Q(IsNatPowT $p $a $b $c) :=\n    let b' := b.natLit!\n    if depth \u2264 1 then\n      let a' := a.natLit!\n      let c\u2080' := c\u2080.natLit!\n      if b' &&& 1 == 0 then\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * c\u2080')\n        haveI : $c =Q Nat.mul $c\u2080 $c\u2080 := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit0)\u27e9\n      else\n        have c : Q(\u2115) := mkRawNatLit (c\u2080' * (c\u2080' * a'))\n        haveI : $c =Q Nat.mul $c\u2080 (Nat.mul $c\u2080 $a) := \u27e8\u27e9\n        haveI : $b =Q 2 * $b\u2080 + 1 := \u27e8\u27e9\n        \u27e8c, q(IsNatPowT.bit1)\u27e9\n    else\n      let d := depth >>> 1\n      have hi : Q(\u2115) := mkRawNatLit (b' >>> d)\n      let \u27e8c1, p1\u27e9 := go (depth - d) a b\u2080 c\u2080 hi p (by exact hp)\n      let \u27e8c2, p2\u27e9 := go d a hi c1 b q(Nat.pow $a $hi = $c1) \u27e8\u27e9\n      \u27e8c2, q(($p1).trans $p2)\u27e9", "start": [49, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.intPow_ofNat", "code": "theorem intPow_ofNat (h1 : Nat.pow a b = c) :\n    Int.pow (Int.ofNat a) b = Int.ofNat c", "start": [102, 1], "end": [103, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.intPow_negOfNat_bit0", "code": "theorem intPow_negOfNat_bit0 (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' = b) (hc : c' * c' = c) :\n    Int.pow (Int.negOfNat a) b = Int.ofNat c", "start": [105, 1], "end": [109, 7], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.intPow_negOfNat_bit1", "code": "theorem intPow_negOfNat_bit1 (h1 : Nat.pow a b' = c')\n    (hb : nat_lit 2 * b' + nat_lit 1 = b) (hc : c' * (c' * a) = c) :\n    Int.pow (Int.negOfNat a) b = Int.negOfNat c", "start": [111, 1], "end": [116, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalIntPow", "code": "partial def evalIntPow (za : \u2124) (a : Q(\u2124)) (b : Q(\u2115)) : \u2124 \u00d7 (c : Q(\u2124)) \u00d7 Q(Int.pow $a $b = $c) :=\n  have a' : Q(\u2115) := a.appArg!\n  if 0 \u2264 za then\n    haveI : $a =Q .ofNat $a' := \u27e8\u27e9\n    let \u27e8c, p\u27e9 := evalNatPow a' b\n    \u27e8c.natLit!, q(.ofNat $c), q(intPow_ofNat $p)\u27e9\n  else\n    haveI : $a =Q .negOfNat $a' := \u27e8\u27e9\n    let b' := b.natLit!\n    have b\u2080 : Q(\u2115) := mkRawNatLit (b' >>> 1)\n    let \u27e8c\u2080, p\u27e9 := evalNatPow a' b\u2080\n    let c' := c\u2080.natLit!\n    if b' &&& 1 == 0 then\n      have c : Q(\u2115) := mkRawNatLit (c' * c')\n      have pc : Q($c\u2080 * $c\u2080 = $c) := (q(Eq.refl $c) : Expr)\n      have pb : Q(2 * $b\u2080 = $b) := (q(Eq.refl $b) : Expr)\n      \u27e8c.natLit!, q(.ofNat $c), q(intPow_negOfNat_bit0 $p $pb $pc)\u27e9\n    else\n      have c : Q(\u2115) := mkRawNatLit (c' * (c' * a'.natLit!))\n      have pc : Q($c\u2080 * ($c\u2080 * $a') = $c) := (q(Eq.refl $c) : Expr)\n      have pb : Q(2 * $b\u2080 + 1 = $b) := (q(Eq.refl $b) : Expr)\n      \u27e8-c.natLit!, q(.negOfNat $c), q(intPow_negOfNat_bit1 $p $pb $pc)\u27e9", "start": [118, 1], "end": [140, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isNat_pow", "code": "theorem isNat_pow {\u03b1} [Semiring \u03b1] : \u2200 {f : \u03b1 \u2192 \u2115 \u2192 \u03b1} {a : \u03b1} {b a' b' c : \u2115},\n    f = HPow.hPow \u2192 IsNat a a' \u2192 IsNat b b' \u2192 Nat.pow a' b' = c \u2192 IsNat (f a b) c", "start": [143, 1], "end": [145, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isInt_pow", "code": "theorem isInt_pow {\u03b1} [Ring \u03b1] : \u2200 {f : \u03b1 \u2192 \u2115 \u2192 \u03b1} {a : \u03b1} {b : \u2115} {a' : \u2124} {b' : \u2115} {c : \u2124},\n    f = HPow.hPow \u2192 IsInt a a' \u2192 IsNat b b' \u2192 Int.pow a' b' = c \u2192 IsInt (f a b) c", "start": [148, 1], "end": [150, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.isRat_pow", "code": "theorem isRat_pow {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u2115 \u2192 \u03b1} {a : \u03b1} {an cn : \u2124} {ad b b' cd : \u2115} :\n    f = HPow.hPow \u2192 IsRat a an ad \u2192 IsNat b b' \u2192\n    Int.pow an b' = cn \u2192 Nat.pow ad b' = cd \u2192\n    IsRat (f a b) cn cd", "start": [153, 1], "end": [160, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.NormNum.evalPow", "code": "@[norm_num (_ : \u03b1) ^ (_ : \u2115), Pow.pow _ (_ : \u2115)]\ndef evalPow : NormNumExt where eval {u \u03b1} e := do\n  let .app (.app (f : Q($\u03b1 \u2192 \u2115 \u2192 $\u03b1)) (a : Q($\u03b1))) (b : Q(\u2115)) \u2190 whnfR e | failure\n  let \u27e8nb, pb\u27e9 \u2190 deriveNat b q(instAddMonoidWithOneNat)\n  let s\u03b1 \u2190 inferSemiring \u03b1\n  let ra \u2190 derive a\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(HPow.hPow (\u03b1 := $\u03b1))\n  haveI' : $e =Q $a ^ $b := \u27e8\u27e9\n  haveI' : $f =Q HPow.hPow := \u27e8\u27e9\n  let rec\n  \n  core : Option (Result e) := do\n    match ra with\n    | .isBool .. => failure\n    | .isNat s\u03b1 na pa =>\n      assumeInstancesCommute\n      have \u27e8c, r\u27e9 := evalNatPow na nb\n      return .isNat s\u03b1 c q(isNat_pow (f := $f) (.refl $f) $pa $pb $r)\n    | .isNegNat r\u03b1 .. =>\n      assumeInstancesCommute\n      let \u27e8za, na, pa\u27e9 \u2190 ra.toInt r\u03b1\n      have \u27e8zc, c, r\u27e9 := evalIntPow za na nb\n      return .isInt r\u03b1 c zc q(isInt_pow (f := $f) (.refl $f) $pa $pb $r)\n    | .isRat d\u03b1 qa na da pa =>\n      assumeInstancesCommute\n      have \u27e8zc, nc, r1\u27e9 := evalIntPow qa.num na nb\n      have \u27e8dc, r2\u27e9 := evalNatPow da nb\n      let qc := mkRat zc dc.natLit!\n      return .isRat' d\u03b1 qc nc dc q(isRat_pow (f := $f) (.refl $f) $pa $pb $r1 $r2)\n  core", "start": [162, 1], "end": [193, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/Cast/Order.lean", "imports": ["Mathlib/Data/Rat/Cast/CharZero.lean", "Mathlib/Data/Rat/Order.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.castHom_rat", "code": "@[simp]\ntheorem castHom_rat : castHom \u211a = RingHom.id \u211a", "start": [22, 1], "end": [24, 22], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_pos_of_pos", "code": "theorem cast_pos_of_pos {r : \u211a} (hr : 0 < r) : (0 : K) < r", "start": [31, 1], "end": [33, 80], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_strictMono", "code": "@[mono]\ntheorem cast_strictMono : StrictMono ((\u2191) : \u211a \u2192 K)", "start": [36, 1], "end": [38, 68], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_mono", "code": "@[mono]\ntheorem cast_mono : Monotone ((\u2191) : \u211a \u2192 K)", "start": [41, 1], "end": [43, 27], "kind": "commanddeclaration"}, {"full_name": "Rat.castOrderEmbedding", "code": "@[simps!]\ndef castOrderEmbedding : \u211a \u21aao K :=\n  OrderEmbedding.ofStrictMono (\u2191) cast_strictMono", "start": [46, 1], "end": [49, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_le", "code": "@[simp, norm_cast]\ntheorem cast_le {m n : \u211a} : (m : K) \u2264 n \u2194 m \u2264 n", "start": [53, 1], "end": [55, 31], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_lt", "code": "@[simp, norm_cast]\ntheorem cast_lt {m n : \u211a} : (m : K) < n \u2194 m < n", "start": [58, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_nonneg", "code": "@[simp]\ntheorem cast_nonneg {n : \u211a} : 0 \u2264 (n : K) \u2194 0 \u2264 n", "start": [63, 1], "end": [65, 12], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_nonpos", "code": "@[simp]\ntheorem cast_nonpos {n : \u211a} : (n : K) \u2264 0 \u2194 n \u2264 0", "start": [68, 1], "end": [70, 12], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_pos", "code": "@[simp]\ntheorem cast_pos {n : \u211a} : (0 : K) < n \u2194 0 < n", "start": [73, 1], "end": [75, 12], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_lt_zero", "code": "@[simp]\ntheorem cast_lt_zero {n : \u211a} : (n : K) < 0 \u2194 n < 0", "start": [78, 1], "end": [80, 12], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_min", "code": "@[simp, norm_cast]\ntheorem cast_min {a b : \u211a} : (\u2191(min a b) : K) = min (a : K) (b : K)", "start": [83, 1], "end": [85, 27], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_max", "code": "@[simp, norm_cast]\ntheorem cast_max {a b : \u211a} : (\u2191(max a b) : K) = max (a : K) (b : K)", "start": [88, 1], "end": [90, 27], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_abs", "code": "@[simp, norm_cast]\ntheorem cast_abs {q : \u211a} : ((|q| : \u211a) : K) = |(q : K)|", "start": [94, 1], "end": [95, 83], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Icc", "code": "@[simp]\ntheorem preimage_cast_Icc (a b : \u211a) : (\u2191) \u207b\u00b9' Icc (a : K) b = Icc a b", "start": [100, 1], "end": [103, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Ico", "code": "@[simp]\ntheorem preimage_cast_Ico (a b : \u211a) : (\u2191) \u207b\u00b9' Ico (a : K) b = Ico a b", "start": [106, 1], "end": [109, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Ioc", "code": "@[simp]\ntheorem preimage_cast_Ioc (a b : \u211a) : (\u2191) \u207b\u00b9' Ioc (a : K) b = Ioc a b", "start": [112, 1], "end": [115, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Ioo", "code": "@[simp]\ntheorem preimage_cast_Ioo (a b : \u211a) : (\u2191) \u207b\u00b9' Ioo (a : K) b = Ioo a b", "start": [118, 1], "end": [121, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Ici", "code": "@[simp]\ntheorem preimage_cast_Ici (a : \u211a) : (\u2191) \u207b\u00b9' Ici (a : K) = Ici a", "start": [124, 1], "end": [127, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Iic", "code": "@[simp]\ntheorem preimage_cast_Iic (a : \u211a) : (\u2191) \u207b\u00b9' Iic (a : K) = Iic a", "start": [130, 1], "end": [133, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Ioi", "code": "@[simp]\ntheorem preimage_cast_Ioi (a : \u211a) : (\u2191) \u207b\u00b9' Ioi (a : K) = Ioi a", "start": [136, 1], "end": [139, 7], "kind": "commanddeclaration"}, {"full_name": "Rat.preimage_cast_Iio", "code": "@[simp]\ntheorem preimage_cast_Iio (a : \u211a) : (\u2191) \u207b\u00b9' Iio (a : K) = Iio a", "start": [142, 1], "end": [145, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Prod.lean", "imports": ["Mathlib/Order/Filter/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.prod", "code": "protected def prod (f : Filter \u03b1) (g : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2) :=\n  f.comap Prod.fst \u2293 g.comap Prod.snd", "start": [51, 1], "end": [54, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.instSProd", "code": "instance instSProd : SProd (Filter \u03b1) (Filter \u03b2) (Filter (\u03b1 \u00d7 \u03b2)) where\n  sprod := Filter.prod", "start": [57, 1], "end": [58, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_mem_prod", "code": "theorem prod_mem_prod {s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2} (hs : s \u2208 f)\n    (ht : t \u2208 g) : s \u00d7\u02e2 t \u2208 f \u00d7\u02e2 g", "start": [60, 1], "end": [62, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_iff", "code": "theorem mem_prod_iff {s : Set (\u03b1 \u00d7 \u03b2)} {f : Filter \u03b1} {g : Filter \u03b2} :\n    s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t\u2081 \u2208 f, \u2203 t\u2082 \u2208 g, t\u2081 \u00d7\u02e2 t\u2082 \u2286 s", "start": [65, 1], "end": [72, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_mem_prod_iff", "code": "@[simp]\ntheorem prod_mem_prod_iff {s : Set \u03b1} {t : Set \u03b2} {f : Filter \u03b1} {g : Filter \u03b2} [f.NeBot]\n    [g.NeBot] : s \u00d7\u02e2 t \u2208 f \u00d7\u02e2 g \u2194 s \u2208 f \u2227 t \u2208 g", "start": [75, 1], "end": [84, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_principal", "code": "theorem mem_prod_principal {f : Filter \u03b1} {s : Set (\u03b1 \u00d7 \u03b2)} {t : Set \u03b2} :\n    s \u2208 f \u00d7\u02e2 \ud835\udcdf t \u2194 { a | \u2200 b \u2208 t, (a, b) \u2208 s } \u2208 f", "start": [87, 1], "end": [94, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_top", "code": "theorem mem_prod_top {f : Filter \u03b1} {s : Set (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 f \u00d7\u02e2 (\u22a4 : Filter \u03b2) \u2194 { a | \u2200 b, (a, b) \u2208 s } \u2208 f", "start": [97, 1], "end": [100, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_prod_principal_iff", "code": "theorem eventually_prod_principal_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} {s : Set \u03b2} :\n    (\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 \ud835\udcdf s, p x) \u2194 \u2200\u1da0 x : \u03b1 in f, \u2200 y : \u03b2, y \u2208 s \u2192 p (x, y)", "start": [103, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_prod", "code": "theorem comap_prod (f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3) (b : Filter \u03b2) (c : Filter \u03b3) :\n    comap f (b \u00d7\u02e2 c) = comap (Prod.fst \u2218 f) b \u2293 comap (Prod.snd \u2218 f) c", "start": [109, 1], "end": [111, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_top", "code": "theorem prod_top {f : Filter \u03b1} : f \u00d7\u02e2 (\u22a4 : Filter \u03b2) = f.comap Prod.fst", "start": [114, 1], "end": [116, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.sup_prod", "code": "theorem sup_prod (f\u2081 f\u2082 : Filter \u03b1) (g : Filter \u03b2) : (f\u2081 \u2294 f\u2082) \u00d7\u02e2 g = (f\u2081 \u00d7\u02e2 g) \u2294 (f\u2082 \u00d7\u02e2 g)", "start": [119, 1], "end": [121, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_sup", "code": "theorem prod_sup (f : Filter \u03b1) (g\u2081 g\u2082 : Filter \u03b2) : f \u00d7\u02e2 (g\u2081 \u2294 g\u2082) = (f \u00d7\u02e2 g\u2081) \u2294 (f \u00d7\u02e2 g\u2082)", "start": [124, 1], "end": [126, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_prod_iff", "code": "theorem eventually_prod_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} {f : Filter \u03b1} {g : Filter \u03b2} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 g, p x) \u2194\n      \u2203 pa : \u03b1 \u2192 Prop, (\u2200\u1da0 x in f, pa x) \u2227 \u2203 pb : \u03b2 \u2192 Prop, (\u2200\u1da0 y in g, pb y) \u2227\n        \u2200 {x}, pa x \u2192 \u2200 {y}, pb y \u2192 p (x, y)", "start": [129, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_fst", "code": "theorem tendsto_fst {f : Filter \u03b1} {g : Filter \u03b2} : Tendsto Prod.fst (f \u00d7\u02e2 g) f", "start": [136, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_snd", "code": "theorem tendsto_snd {f : Filter \u03b1} {g : Filter \u03b2} : Tendsto Prod.snd (f \u00d7\u02e2 g) g", "start": [140, 1], "end": [141, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_mk", "code": "theorem Tendsto.prod_mk {f : Filter \u03b1} {g : Filter \u03b2} {h : Filter \u03b3} {m\u2081 : \u03b1 \u2192 \u03b2} {m\u2082 : \u03b1 \u2192 \u03b3}\n    (h\u2081 : Tendsto m\u2081 f g) (h\u2082 : Tendsto m\u2082 f h) : Tendsto (fun x => (m\u2081 x, m\u2082 x)) f (g \u00d7\u02e2 h)", "start": [144, 1], "end": [146, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prod_swap", "code": "theorem tendsto_prod_swap {\u03b11 \u03b12 : Type*} {a1 : Filter \u03b11} {a2 : Filter \u03b12} :\n    Tendsto (Prod.swap : \u03b11 \u00d7 \u03b12 \u2192 \u03b12 \u00d7 \u03b11) (a1 \u00d7\u02e2 a2) (a2 \u00d7\u02e2 a1)", "start": [149, 1], "end": [151, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_inl", "code": "theorem Eventually.prod_inl {la : Filter \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in la, p x) (lb : Filter \u03b2) :\n    \u2200\u1da0 x in la \u00d7\u02e2 lb, p (x : \u03b1 \u00d7 \u03b2).1", "start": [154, 1], "end": [156, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_inr", "code": "theorem Eventually.prod_inr {lb : Filter \u03b2} {p : \u03b2 \u2192 Prop} (h : \u2200\u1da0 x in lb, p x) (la : Filter \u03b1) :\n    \u2200\u1da0 x in la \u00d7\u02e2 lb, p (x : \u03b1 \u00d7 \u03b2).2", "start": [159, 1], "end": [161, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_mk", "code": "theorem Eventually.prod_mk {la : Filter \u03b1} {pa : \u03b1 \u2192 Prop} (ha : \u2200\u1da0 x in la, pa x) {lb : Filter \u03b2}\n    {pb : \u03b2 \u2192 Prop} (hb : \u2200\u1da0 y in lb, pb y) : \u2200\u1da0 p in la \u00d7\u02e2 lb, pa (p : \u03b1 \u00d7 \u03b2).1 \u2227 pb p.2", "start": [164, 1], "end": [166, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.prod_map", "code": "theorem EventuallyEq.prod_map {\u03b4} {la : Filter \u03b1} {fa ga : \u03b1 \u2192 \u03b3} (ha : fa =\u1da0[la] ga)\n    {lb : Filter \u03b2} {fb gb : \u03b2 \u2192 \u03b4} (hb : fb =\u1da0[lb] gb) :\n    Prod.map fa fb =\u1da0[la \u00d7\u02e2 lb] Prod.map ga gb", "start": [169, 1], "end": [172, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.prod_map", "code": "theorem EventuallyLE.prod_map {\u03b4} [LE \u03b3] [LE \u03b4] {la : Filter \u03b1} {fa ga : \u03b1 \u2192 \u03b3} (ha : fa \u2264\u1da0[la] ga)\n    {lb : Filter \u03b2} {fb gb : \u03b2 \u2192 \u03b4} (hb : fb \u2264\u1da0[lb] gb) :\n    Prod.map fa fb \u2264\u1da0[la \u00d7\u02e2 lb] Prod.map ga gb", "start": [175, 1], "end": [178, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.curry", "code": "theorem Eventually.curry {la : Filter \u03b1} {lb : Filter \u03b2} {p : \u03b1 \u00d7 \u03b2 \u2192 Prop}\n    (h : \u2200\u1da0 x in la \u00d7\u02e2 lb, p x) : \u2200\u1da0 x in la, \u2200\u1da0 y in lb, p (x, y)", "start": [181, 1], "end": [184, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.diag_of_prod", "code": "theorem Eventually.diag_of_prod {f : Filter \u03b1} {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} (h : \u2200\u1da0 i in f \u00d7\u02e2 f, p i) :\n    \u2200\u1da0 i in f, p (i, i)", "start": [187, 1], "end": [192, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.diag_of_prod_left", "code": "theorem Eventually.diag_of_prod_left {f : Filter \u03b1} {g : Filter \u03b3} {p : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b3 \u2192 Prop} :\n    (\u2200\u1da0 x in (f \u00d7\u02e2 f) \u00d7\u02e2 g, p x) \u2192 \u2200\u1da0 x : \u03b1 \u00d7 \u03b3 in f \u00d7\u02e2 g, p ((x.1, x.1), x.2)", "start": [195, 1], "end": [199, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.diag_of_prod_right", "code": "theorem Eventually.diag_of_prod_right {f : Filter \u03b1} {g : Filter \u03b3} {p : \u03b1 \u00d7 \u03b3 \u00d7 \u03b3 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 (g \u00d7\u02e2 g), p x) \u2192 \u2200\u1da0 x : \u03b1 \u00d7 \u03b3 in f \u00d7\u02e2 g, p (x.1, x.2, x.2)", "start": [202, 1], "end": [206, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_diag", "code": "theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f \u00d7\u02e2 f)", "start": [209, 1], "end": [210, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_iInf_left", "code": "theorem prod_iInf_left [Nonempty \u03b9] {f : \u03b9 \u2192 Filter \u03b1} {g : Filter \u03b2} :\n    (\u2a05 i, f i) \u00d7\u02e2 g = \u2a05 i, f i \u00d7\u02e2 g", "start": [213, 1], "end": [217, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_iInf_right", "code": "theorem prod_iInf_right [Nonempty \u03b9] {f : Filter \u03b1} {g : \u03b9 \u2192 Filter \u03b2} :\n    (f \u00d7\u02e2 \u2a05 i, g i) = \u2a05 i, f \u00d7\u02e2 g i", "start": [220, 1], "end": [224, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_mono", "code": "@[mono]\ntheorem prod_mono {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264 g\u2082) :\n    f\u2081 \u00d7\u02e2 g\u2081 \u2264 f\u2082 \u00d7\u02e2 g\u2082", "start": [227, 1], "end": [230, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_mono_left", "code": "theorem prod_mono_left (g : Filter \u03b2) {f\u2081 f\u2082 : Filter \u03b1} (hf : f\u2081 \u2264 f\u2082) : f\u2081 \u00d7\u02e2 g \u2264 f\u2082 \u00d7\u02e2 g", "start": [233, 1], "end": [234, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_mono_right", "code": "theorem prod_mono_right (f : Filter \u03b1) {g\u2081 g\u2082 : Filter \u03b2} (hf : g\u2081 \u2264 g\u2082) : f \u00d7\u02e2 g\u2081 \u2264 f \u00d7\u02e2 g\u2082", "start": [237, 1], "end": [238, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_comap_comap_eq", "code": "theorem prod_comap_comap_eq.{u, v, w, x} {\u03b1\u2081 : Type u} {\u03b1\u2082 : Type v} {\u03b2\u2081 : Type w} {\u03b2\u2082 : Type x}\n    {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {m\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081} {m\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082} :\n    comap m\u2081 f\u2081 \u00d7\u02e2 comap m\u2082 f\u2082 = comap (fun p : \u03b2\u2081 \u00d7 \u03b2\u2082 => (m\u2081 p.1, m\u2082 p.2)) (f\u2081 \u00d7\u02e2 f\u2082)", "start": [241, 1], "end": [244, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_comm'", "code": "theorem prod_comm' : f \u00d7\u02e2 g = comap Prod.swap (g \u00d7\u02e2 f)", "start": [247, 1], "end": [248, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_comm", "code": "theorem prod_comm : f \u00d7\u02e2 g = map (fun p : \u03b2 \u00d7 \u03b1 => (p.2, p.1)) (g \u00d7\u02e2 f)", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_iff_left", "code": "theorem mem_prod_iff_left {s : Set (\u03b1 \u00d7 \u03b2)} {f : Filter \u03b1} {g : Filter \u03b2} :\n    s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t \u2208 f, \u2200\u1da0 y in g, \u2200 x \u2208 t, (x, y) \u2208 s", "start": [256, 1], "end": [260, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_iff_right", "code": "theorem mem_prod_iff_right {s : Set (\u03b1 \u00d7 \u03b2)} {f : Filter \u03b1} {g : Filter \u03b2} :\n    s \u2208 f \u00d7\u02e2 g \u2194 \u2203 t \u2208 g, \u2200\u1da0 x in f, \u2200 y \u2208 t, (x, y) \u2208 s", "start": [262, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.map_fst_prod", "code": "@[simp]\ntheorem map_fst_prod (f : Filter \u03b1) (g : Filter \u03b2) [NeBot g] : map Prod.fst (f \u00d7\u02e2 g) = f", "start": [266, 1], "end": [270, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.map_snd_prod", "code": "@[simp]\ntheorem map_snd_prod (f : Filter \u03b1) (g : Filter \u03b2) [NeBot f] : map Prod.snd (f \u00d7\u02e2 g) = g", "start": [273, 1], "end": [275, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_le_prod", "code": "@[simp]\ntheorem prod_le_prod {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} [NeBot f\u2081] [NeBot g\u2081] :\n    f\u2081 \u00d7\u02e2 g\u2081 \u2264 f\u2082 \u00d7\u02e2 g\u2082 \u2194 f\u2081 \u2264 f\u2082 \u2227 g\u2081 \u2264 g\u2082", "start": [278, 1], "end": [283, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_inj", "code": "@[simp]\ntheorem prod_inj {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} [NeBot f\u2081] [NeBot g\u2081] :\n    f\u2081 \u00d7\u02e2 g\u2081 = f\u2082 \u00d7\u02e2 g\u2082 \u2194 f\u2081 = f\u2082 \u2227 g\u2081 = g\u2082", "start": [286, 1], "end": [292, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_swap_iff", "code": "theorem eventually_swap_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} :\n    (\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 g, p x) \u2194 \u2200\u1da0 y : \u03b2 \u00d7 \u03b1 in g \u00d7\u02e2 f, p y.swap", "start": [295, 1], "end": [297, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_assoc", "code": "theorem prod_assoc (f : Filter \u03b1) (g : Filter \u03b2) (h : Filter \u03b3) :\n    map (Equiv.prodAssoc \u03b1 \u03b2 \u03b3) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) = f \u00d7\u02e2 (g \u00d7\u02e2 h)", "start": [300, 1], "end": [303, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_assoc_symm", "code": "theorem prod_assoc_symm (f : Filter \u03b1) (g : Filter \u03b2) (h : Filter \u03b3) :\n    map (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) = (f \u00d7\u02e2 g) \u00d7\u02e2 h", "start": [306, 1], "end": [309, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prodAssoc", "code": "theorem tendsto_prodAssoc {f : Filter \u03b1} {g : Filter \u03b2} {h : Filter \u03b3} :\n    Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3) ((f \u00d7\u02e2 g) \u00d7\u02e2 h) (f \u00d7\u02e2 (g \u00d7\u02e2 h))", "start": [312, 1], "end": [314, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prodAssoc_symm", "code": "theorem tendsto_prodAssoc_symm {f : Filter \u03b1} {g : Filter \u03b2} {h : Filter \u03b3} :\n    Tendsto (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm (f \u00d7\u02e2 (g \u00d7\u02e2 h)) ((f \u00d7\u02e2 g) \u00d7\u02e2 h)", "start": [317, 1], "end": [319, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map_swap4_prod", "code": "theorem map_swap4_prod {f : Filter \u03b1} {g : Filter \u03b2} {h : Filter \u03b3} {k : Filter \u03b4} :\n    map (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f \u00d7\u02e2 g) \u00d7\u02e2 (h \u00d7\u02e2 k)) =\n      (f \u00d7\u02e2 h) \u00d7\u02e2 (g \u00d7\u02e2 k)", "start": [322, 1], "end": [326, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_swap4_prod", "code": "theorem tendsto_swap4_prod {f : Filter \u03b1} {g : Filter \u03b2} {h : Filter \u03b3} {k : Filter \u03b4} :\n    Tendsto (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f \u00d7\u02e2 g) \u00d7\u02e2 (h \u00d7\u02e2 k))\n      ((f \u00d7\u02e2 h) \u00d7\u02e2 (g \u00d7\u02e2 k))", "start": [329, 1], "end": [332, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_map_eq", "code": "theorem prod_map_map_eq.{u, v, w, x} {\u03b1\u2081 : Type u} {\u03b1\u2082 : Type v} {\u03b2\u2081 : Type w} {\u03b2\u2082 : Type x}\n    {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {m\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081} {m\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082} :\n    map m\u2081 f\u2081 \u00d7\u02e2 map m\u2082 f\u2082 = map (fun p : \u03b1\u2081 \u00d7 \u03b1\u2082 => (m\u2081 p.1, m\u2082 p.2)) (f\u2081 \u00d7\u02e2 f\u2082)", "start": [335, 1], "end": [343, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_map_eq'", "code": "theorem prod_map_map_eq' {\u03b1\u2081 : Type*} {\u03b1\u2082 : Type*} {\u03b2\u2081 : Type*} {\u03b2\u2082 : Type*} (f : \u03b1\u2081 \u2192 \u03b1\u2082)\n    (g : \u03b2\u2081 \u2192 \u03b2\u2082) (F : Filter \u03b1\u2081) (G : Filter \u03b2\u2081) :\n    map f F \u00d7\u02e2 map g G = map (Prod.map f g) (F \u00d7\u02e2 G)", "start": [346, 1], "end": [349, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_left", "code": "theorem prod_map_left (f : \u03b1 \u2192 \u03b2) (F : Filter \u03b1) (G : Filter \u03b3) :\n    map f F \u00d7\u02e2 G = map (Prod.map f id) (F \u00d7\u02e2 G)", "start": [352, 1], "end": [354, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_right", "code": "theorem prod_map_right (f : \u03b2 \u2192 \u03b3) (F : Filter \u03b1) (G : Filter \u03b2) :\n    F \u00d7\u02e2 map f G = map (Prod.map id f) (F \u00d7\u02e2 G)", "start": [356, 1], "end": [358, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.le_prod_map_fst_snd", "code": "theorem le_prod_map_fst_snd {f : Filter (\u03b1 \u00d7 \u03b2)} : f \u2264 map Prod.fst f \u00d7\u02e2 map Prod.snd f", "start": [360, 1], "end": [361, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_map", "code": "theorem Tendsto.prod_map {\u03b4 : Type*} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {a : Filter \u03b1} {b : Filter \u03b2}\n    {c : Filter \u03b3} {d : Filter \u03b4} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a \u00d7\u02e2 b) (c \u00d7\u02e2 d)", "start": [364, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.map_prod", "code": "protected theorem map_prod (m : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    map m (f \u00d7\u02e2 g) = (f.map fun a b => m (a, b)).seq g", "start": [371, 1], "end": [377, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_eq", "code": "theorem prod_eq {f : Filter \u03b1} {g : Filter \u03b2} : f \u00d7\u02e2 g = (f.map Prod.mk).seq g", "start": [380, 1], "end": [382, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_inf_prod", "code": "theorem prod_inf_prod {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} :\n    (f\u2081 \u00d7\u02e2 g\u2081) \u2293 (f\u2082 \u00d7\u02e2 g\u2082) = (f\u2081 \u2293 f\u2082) \u00d7\u02e2 (g\u2081 \u2293 g\u2082)", "start": [385, 1], "end": [387, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_prod", "code": "theorem inf_prod {f\u2081 f\u2082 : Filter \u03b1} {g : Filter \u03b2} : (f\u2081 \u2293 f\u2082) \u00d7\u02e2 g = (f\u2081 \u00d7\u02e2 g) \u2293 (f\u2082 \u00d7\u02e2 g)", "start": [390, 1], "end": [391, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_inf", "code": "theorem prod_inf {f : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} : f \u00d7\u02e2 (g\u2081 \u2293 g\u2082) = (f \u00d7\u02e2 g\u2081) \u2293 (f \u00d7\u02e2 g\u2082)", "start": [393, 1], "end": [394, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_principal_principal", "code": "@[simp]\ntheorem prod_principal_principal {s : Set \u03b1} {t : Set \u03b2} : \ud835\udcdf s \u00d7\u02e2 \ud835\udcdf t = \ud835\udcdf (s \u00d7\u02e2 t)", "start": [396, 1], "end": [399, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_prod", "code": "@[simp]\ntheorem pure_prod {a : \u03b1} {f : Filter \u03b2} : pure a \u00d7\u02e2 f = map (Prod.mk a) f", "start": [402, 1], "end": [404, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.map_pure_prod", "code": "theorem map_pure_prod (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : \u03b1) (B : Filter \u03b2) :\n    map (Function.uncurry f) (pure a \u00d7\u02e2 B) = map (f a) B", "start": [407, 1], "end": [409, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_pure", "code": "@[simp]\ntheorem prod_pure {f : Filter \u03b1} {b : \u03b2} : f \u00d7\u02e2 pure b = map (fun a => (a, b)) f", "start": [412, 1], "end": [414, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_pure_pure", "code": "theorem prod_pure_pure {a : \u03b1} {b : \u03b2} :\n    (pure a : Filter \u03b1) \u00d7\u02e2 (pure b : Filter \u03b2) = pure (a, b)", "start": [417, 1], "end": [418, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_eq_bot", "code": "theorem prod_eq_bot {f : Filter \u03b1} {g : Filter \u03b2} : f \u00d7\u02e2 g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [421, 1], "end": [423, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_bot", "code": "@[simp] theorem prod_bot {f : Filter \u03b1} : f \u00d7\u02e2 (\u22a5 : Filter \u03b2) = \u22a5", "start": [426, 1], "end": [426, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_prod", "code": "@[simp] theorem bot_prod {g : Filter \u03b2} : (\u22a5 : Filter \u03b1) \u00d7\u02e2 g = \u22a5", "start": [429, 1], "end": [429, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_neBot", "code": "theorem prod_neBot {f : Filter \u03b1} {g : Filter \u03b2} : NeBot (f \u00d7\u02e2 g) \u2194 NeBot f \u2227 NeBot g", "start": [432, 1], "end": [433, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.prod", "code": "theorem NeBot.prod {f : Filter \u03b1} {g : Filter \u03b2} (hf : NeBot f) (hg : NeBot g) : NeBot (f \u00d7\u02e2 g)", "start": [436, 1], "end": [437, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_neBot'", "code": "instance prod_neBot' {f : Filter \u03b1} {g : Filter \u03b2} [hf : NeBot f] [hg : NeBot g] :\n    NeBot (f \u00d7\u02e2 g) :=\n  hf.prod hg", "start": [440, 1], "end": [442, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prod_iff", "code": "theorem tendsto_prod_iff {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {x : Filter \u03b1} {y : Filter \u03b2} {z : Filter \u03b3} :\n    Tendsto f (x \u00d7\u02e2 y) z \u2194 \u2200 W \u2208 z, \u2203 U \u2208 x, \u2203 V \u2208 y, \u2200 x y, x \u2208 U \u2192 y \u2208 V \u2192 f (x, y) \u2208 W", "start": [445, 1], "end": [447, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.le_prod", "code": "theorem le_prod {f : Filter (\u03b1 \u00d7 \u03b2)} {g : Filter \u03b1} {g' : Filter \u03b2} :\n    (f \u2264 g \u00d7\u02e2 g') \u2194 Tendsto Prod.fst f g \u2227 Tendsto Prod.snd f g'", "start": [450, 1], "end": [454, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prod_iff'", "code": "theorem tendsto_prod_iff' {f : Filter \u03b1} {g : Filter \u03b2} {g' : Filter \u03b3} {s : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} :\n    Tendsto s f (g \u00d7\u02e2 g') \u2194 Tendsto (fun n => (s n).1) f g \u2227 Tendsto (fun n => (s n).2) f g'", "start": [456, 1], "end": [460, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod", "code": "protected def coprod (f : Filter \u03b1) (g : Filter \u03b2) : Filter (\u03b1 \u00d7 \u03b2) :=\n  f.comap Prod.fst \u2294 g.comap Prod.snd", "start": [472, 1], "end": [474, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_coprod_iff", "code": "theorem mem_coprod_iff {s : Set (\u03b1 \u00d7 \u03b2)} {f : Filter \u03b1} {g : Filter \u03b2} :\n    s \u2208 f.coprod g \u2194 (\u2203 t\u2081 \u2208 f, Prod.fst \u207b\u00b9' t\u2081 \u2286 s) \u2227 \u2203 t\u2082 \u2208 g, Prod.snd \u207b\u00b9' t\u2082 \u2286 s", "start": [477, 1], "end": [479, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_coprod", "code": "@[simp]\ntheorem bot_coprod (l : Filter \u03b2) : (\u22a5 : Filter \u03b1).coprod l = comap Prod.snd l", "start": [482, 1], "end": [484, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_bot", "code": "@[simp]\ntheorem coprod_bot (l : Filter \u03b1) : l.coprod (\u22a5 : Filter \u03b2) = comap Prod.fst l", "start": [487, 1], "end": [489, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_coprod_bot", "code": "theorem bot_coprod_bot : (\u22a5 : Filter \u03b1).coprod (\u22a5 : Filter \u03b2) = \u22a5", "start": [492, 1], "end": [492, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_mem_coprod", "code": "theorem compl_mem_coprod {s : Set (\u03b1 \u00d7 \u03b2)} {la : Filter \u03b1} {lb : Filter \u03b2} :\n    s\u1d9c \u2208 la.coprod lb \u2194 (Prod.fst '' s)\u1d9c \u2208 la \u2227 (Prod.snd '' s)\u1d9c \u2208 lb", "start": [495, 1], "end": [497, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_mono", "code": "@[mono]\ntheorem coprod_mono {f\u2081 f\u2082 : Filter \u03b1} {g\u2081 g\u2082 : Filter \u03b2} (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264 g\u2082) :\n    f\u2081.coprod g\u2081 \u2264 f\u2082.coprod g\u2082", "start": [500, 1], "end": [503, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_neBot_iff", "code": "theorem coprod_neBot_iff : (f.coprod g).NeBot \u2194 f.NeBot \u2227 Nonempty \u03b2 \u2228 Nonempty \u03b1 \u2227 g.NeBot", "start": [506, 1], "end": [507, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_neBot_left", "code": "@[instance]\ntheorem coprod_neBot_left [NeBot f] [Nonempty \u03b2] : (f.coprod g).NeBot", "start": [510, 1], "end": [512, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_neBot_right", "code": "@[instance]\ntheorem coprod_neBot_right [NeBot g] [Nonempty \u03b1] : (f.coprod g).NeBot", "start": [515, 1], "end": [517, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_coprod_principal", "code": "theorem principal_coprod_principal (s : Set \u03b1) (t : Set \u03b2) :\n    (\ud835\udcdf s).coprod (\ud835\udcdf t) = \ud835\udcdf (s\u1d9c \u00d7\u02e2 t\u1d9c)\u1d9c", "start": [520, 1], "end": [523, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.map_prod_map_coprod_le", "code": "theorem map_prod_map_coprod_le.{u, v, w, x} {\u03b1\u2081 : Type u} {\u03b1\u2082 : Type v} {\u03b2\u2081 : Type w} {\u03b2\u2082 : Type x}\n    {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {m\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081} {m\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082} :\n    map (Prod.map m\u2081 m\u2082) (f\u2081.coprod f\u2082) \u2264 (map m\u2081 f\u2081).coprod (map m\u2082 f\u2082)", "start": [528, 1], "end": [534, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.map_const_principal_coprod_map_id_principal", "code": "theorem map_const_principal_coprod_map_id_principal {\u03b1 \u03b2 \u03b9 : Type*} (a : \u03b1) (b : \u03b2) (i : \u03b9) :\n    (map (fun _ => b) (\ud835\udcdf {a})).coprod (map id (\ud835\udcdf {i})) =\n      \ud835\udcdf ((({b} : Set \u03b2) \u00d7\u02e2 univ) \u222a (univ \u00d7\u02e2 ({i} : Set \u03b9)))", "start": [537, 1], "end": [546, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.map_prod_map_const_id_principal_coprod_principal", "code": "theorem map_prod_map_const_id_principal_coprod_principal {\u03b1 \u03b2 \u03b9 : Type*} (a : \u03b1) (b : \u03b2) (i : \u03b9) :\n    map (Prod.map (fun _ : \u03b1 => b) id) ((\ud835\udcdf {a}).coprod (\ud835\udcdf {i})) =\n      \ud835\udcdf (({b} : Set \u03b2) \u00d7\u02e2 (univ : Set \u03b9))", "start": [549, 1], "end": [565, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_map_coprod", "code": "theorem Tendsto.prod_map_coprod {\u03b4 : Type*} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {a : Filter \u03b1} {b : Filter \u03b2}\n    {c : Filter \u03b3} {d : Filter \u03b4} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a.coprod b) (c.coprod d)", "start": [568, 1], "end": [571, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Countable.lean", "imports": ["Mathlib/Data/Countable/Basic.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/Logic/Equiv/List.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Countable", "code": "protected def Countable (s : Set \u03b1) : Prop :=\n  Nonempty (Encodable s)", "start": [26, 1], "end": [32, 25], "kind": "commanddeclaration"}, {"full_name": "Set.countable_coe_iff", "code": "@[simp]\ntheorem countable_coe_iff {s : Set \u03b1} : Countable s \u2194 s.Countable", "start": [35, 1], "end": [37, 36], "kind": "commanddeclaration"}, {"full_name": "Set.to_countable", "code": "theorem to_countable (s : Set \u03b1) [Countable s] : s.Countable", "start": [40, 1], "end": [42, 27], "kind": "commanddeclaration"}, {"full_name": "Countable.to_set", "code": "alias \u27e8_root_.Countable.to_set, Countable.to_subtype\u27e9 := countable_coe_iff", "start": [45, 1], "end": [46, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Countable.to_subtype", "code": "alias \u27e8_root_.Countable.to_set, Countable.to_subtype\u27e9 := countable_coe_iff", "start": [45, 1], "end": [46, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.countable_iff_exists_injective", "code": "protected theorem countable_iff_exists_injective {s : Set \u03b1} :\n    s.Countable \u2194 \u2203 f : s \u2192 \u2115, Injective f", "start": [50, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "Set.countable_iff_exists_injOn", "code": "theorem countable_iff_exists_injOn {s : Set \u03b1} : s.Countable \u2194 \u2203 f : \u03b1 \u2192 \u2115, InjOn f s", "start": [55, 1], "end": [58, 75], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.toEncodable", "code": "protected def Countable.toEncodable {s : Set \u03b1} : s.Countable \u2192 Encodable s :=\n  Classical.choice", "start": [61, 1], "end": [63, 19], "kind": "commanddeclaration"}, {"full_name": "Set.enumerateCountable", "code": "def enumerateCountable {s : Set \u03b1} (h : s.Countable) (default : \u03b1) : \u2115 \u2192 \u03b1 := fun n =>\n  match @Encodable.decode s h.toEncodable n with\n  | some y => y\n  | none => default", "start": [68, 1], "end": [73, 20], "kind": "commanddeclaration"}, {"full_name": "Set.subset_range_enumerate", "code": "theorem subset_range_enumerate {s : Set \u03b1} (h : s.Countable) (default : \u03b1) :\n    s \u2286 range (enumerateCountable h default)", "start": [76, 1], "end": [80, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.mono", "code": "theorem Countable.mono {s\u2081 s\u2082 : Set \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2082.Countable \u2192 s\u2081.Countable", "start": [85, 1], "end": [86, 56], "kind": "commanddeclaration"}, {"full_name": "Set.countable_range", "code": "theorem countable_range [Countable \u03b9] (f : \u03b9 \u2192 \u03b2) : (range f).Countable", "start": [89, 1], "end": [90, 41], "kind": "commanddeclaration"}, {"full_name": "Set.countable_iff_exists_subset_range", "code": "theorem countable_iff_exists_subset_range [Nonempty \u03b1] {s : Set \u03b1} :\n    s.Countable \u2194 \u2203 f : \u2115 \u2192 \u03b1, s \u2286 range f", "start": [93, 1], "end": [98, 34], "kind": "commanddeclaration"}, {"full_name": "Set.countable_iff_exists_surjective", "code": "protected theorem countable_iff_exists_surjective {s : Set \u03b1} (hs : s.Nonempty) :\n    s.Countable \u2194 \u2203 f : \u2115 \u2192 s, Surjective f", "start": [101, 1], "end": [106, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.exists_surjective", "code": "alias \u27e8Countable.exists_surjective, _\u27e9 := Set.countable_iff_exists_surjective", "start": [109, 1], "end": [109, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.countable_univ", "code": "theorem countable_univ [Countable \u03b1] : (univ : Set \u03b1).Countable", "start": [112, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "Set.countable_univ_iff", "code": "theorem countable_univ_iff : (univ : Set \u03b1).Countable \u2194 Countable \u03b1", "start": [116, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.exists_eq_range", "code": "theorem Countable.exists_eq_range {s : Set \u03b1} (hc : s.Countable) (hs : s.Nonempty) :\n    \u2203 f : \u2115 \u2192 \u03b1, s = range f", "start": [119, 1], "end": [125, 40], "kind": "commanddeclaration"}, {"full_name": "Set.countable_empty", "code": "@[simp] theorem countable_empty : (\u2205 : Set \u03b1).Countable", "start": [128, 1], "end": [128, 74], "kind": "commanddeclaration"}, {"full_name": "Set.countable_singleton", "code": "@[simp] theorem countable_singleton (a : \u03b1) : ({a} : Set \u03b1).Countable", "start": [131, 1], "end": [131, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.image", "code": "theorem Countable.image {s : Set \u03b1} (hs : s.Countable) (f : \u03b1 \u2192 \u03b2) : (f '' s).Countable", "start": [134, 1], "end": [137, 24], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.countable_of_injOn", "code": "theorem MapsTo.countable_of_injOn {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : MapsTo f s t)\n    (hf' : InjOn f s) (ht : t.Countable) : s.Countable", "start": [140, 1], "end": [143, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.preimage_of_injOn", "code": "theorem Countable.preimage_of_injOn {s : Set \u03b2} (hs : s.Countable) {f : \u03b1 \u2192 \u03b2}\n    (hf : InjOn f (f \u207b\u00b9' s)) : (f \u207b\u00b9' s).Countable", "start": [146, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.preimage", "code": "protected theorem Countable.preimage {s : Set \u03b2} (hs : s.Countable) {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    (f \u207b\u00b9' s).Countable", "start": [151, 1], "end": [153, 36], "kind": "commanddeclaration"}, {"full_name": "Set.exists_seq_iSup_eq_top_iff_countable", "code": "theorem exists_seq_iSup_eq_top_iff_countable [CompleteLattice \u03b1] {p : \u03b1 \u2192 Prop} (h : \u2203 x, p x) :\n    (\u2203 s : \u2115 \u2192 \u03b1, (\u2200 n, p (s n)) \u2227 \u2a06 n, s n = \u22a4) \u2194\n      \u2203 S : Set \u03b1, S.Countable \u2227 (\u2200 s \u2208 S, p s) \u2227 sSup S = \u22a4", "start": [156, 1], "end": [171, 42], "kind": "commanddeclaration"}, {"full_name": "Set.exists_seq_cover_iff_countable", "code": "theorem exists_seq_cover_iff_countable {p : Set \u03b1 \u2192 Prop} (h : \u2203 s, p s) :\n    (\u2203 s : \u2115 \u2192 Set \u03b1, (\u2200 n, p (s n)) \u2227 \u22c3 n, s n = univ) \u2194\n      \u2203 S : Set (Set \u03b1), S.Countable \u2227 (\u2200 s \u2208 S, p s) \u2227 \u22c3\u2080 S = univ", "start": [174, 1], "end": [177, 41], "kind": "commanddeclaration"}, {"full_name": "Set.countable_of_injective_of_countable_image", "code": "theorem countable_of_injective_of_countable_image {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : InjOn f s)\n    (hs : (f '' s).Countable) : s.Countable", "start": [180, 1], "end": [182, 46], "kind": "commanddeclaration"}, {"full_name": "Set.countable_iUnion", "code": "theorem countable_iUnion {t : \u03b9 \u2192 Set \u03b1} [Countable \u03b9] (ht : \u2200 i, (t i).Countable) :\n    (\u22c3 i, t i).Countable", "start": [185, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "Set.countable_iUnion_iff", "code": "@[simp]\ntheorem countable_iUnion_iff [Countable \u03b9] {t : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i, t i).Countable \u2194 \u2200 i, (t i).Countable", "start": [192, 1], "end": [195, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.biUnion_iff", "code": "theorem Countable.biUnion_iff {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2} (hs : s.Countable) :\n    (\u22c3 a \u2208 s, t a \u2039_\u203a).Countable \u2194 \u2200 a (ha : a \u2208 s), (t a ha).Countable", "start": [198, 1], "end": [201, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.sUnion_iff", "code": "theorem Countable.sUnion_iff {s : Set (Set \u03b1)} (hs : s.Countable) :\n    (\u22c3\u2080 s).Countable \u2194 \u2200 a \u2208 s, (a : _).Countable", "start": [204, 1], "end": [205, 95], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.biUnion", "code": "alias \u27e8_, Countable.biUnion\u27e9 := Countable.biUnion_iff", "start": [208, 1], "end": [208, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Countable.sUnion", "code": "alias \u27e8_, Countable.sUnion\u27e9 := Countable.sUnion_iff", "start": [211, 1], "end": [211, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.countable_union", "code": "@[simp]\ntheorem countable_union {s t : Set \u03b1} : (s \u222a t).Countable \u2194 s.Countable \u2227 t.Countable", "start": [214, 1], "end": [216, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.union", "code": "theorem Countable.union {s t : Set \u03b1} (hs : s.Countable) (ht : t.Countable) : (s \u222a t).Countable", "start": [219, 1], "end": [220, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.of_diff", "code": "theorem Countable.of_diff {s t : Set \u03b1} (h : (s \\ t).Countable) (ht : t.Countable) : s.Countable", "start": [223, 1], "end": [224, 44], "kind": "commanddeclaration"}, {"full_name": "Set.countable_insert", "code": "@[simp]\ntheorem countable_insert {s : Set \u03b1} {a : \u03b1} : (insert a s).Countable \u2194 s.Countable", "start": [226, 1], "end": [228, 76], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.insert", "code": "protected theorem Countable.insert {s : Set \u03b1} (a : \u03b1) (h : s.Countable) : (insert a s).Countable", "start": [231, 1], "end": [232, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.countable", "code": "theorem Finite.countable {s : Set \u03b1} : s.Finite \u2192 s.Countable", "start": [235, 1], "end": [236, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.of_subsingleton", "code": "@[nontriviality]\ntheorem Countable.of_subsingleton [Subsingleton \u03b1] (s : Set \u03b1) : s.Countable", "start": [239, 1], "end": [241, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.countable", "code": "theorem Subsingleton.countable {s : Set \u03b1} (hs : s.Subsingleton) : s.Countable", "start": [244, 1], "end": [245, 22], "kind": "commanddeclaration"}, {"full_name": "Set.countable_isTop", "code": "theorem countable_isTop (\u03b1 : Type*) [PartialOrder \u03b1] : { x : \u03b1 | IsTop x }.Countable", "start": [248, 1], "end": [249, 29], "kind": "commanddeclaration"}, {"full_name": "Set.countable_isBot", "code": "theorem countable_isBot (\u03b1 : Type*) [PartialOrder \u03b1] : { x : \u03b1 | IsBot x }.Countable", "start": [252, 1], "end": [253, 29], "kind": "commanddeclaration"}, {"full_name": "Set.countable_setOf_finite_subset", "code": "theorem countable_setOf_finite_subset {s : Set \u03b1} (hs : s.Countable) :\n    { t | Set.Finite t \u2227 t \u2286 s }.Countable", "start": [256, 1], "end": [264, 25], "kind": "commanddeclaration"}, {"full_name": "Set.countable_univ_pi", "code": "theorem countable_univ_pi {\u03c0 : \u03b1 \u2192 Type*} [Finite \u03b1] {s : \u2200 a, Set (\u03c0 a)}\n    (hs : \u2200 a, (s a).Countable) : (pi univ s).Countable", "start": [267, 1], "end": [270, 58], "kind": "commanddeclaration"}, {"full_name": "Set.countable_pi", "code": "theorem countable_pi {\u03c0 : \u03b1 \u2192 Type*} [Finite \u03b1] {s : \u2200 a, Set (\u03c0 a)} (hs : \u2200 a, (s a).Countable) :\n    { f : \u2200 a, \u03c0 a | \u2200 a, f a \u2208 s a }.Countable", "start": [273, 1], "end": [275, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.prod", "code": "protected theorem Countable.prod {s : Set \u03b1} {t : Set \u03b2} (hs : s.Countable) (ht : t.Countable) :\n    Set.Countable (s \u00d7\u02e2 t)", "start": [278, 1], "end": [282, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.image2", "code": "theorem Countable.image2 {s : Set \u03b1} {t : Set \u03b2} (hs : s.Countable) (ht : t.Countable)\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : (image2 f s t).Countable", "start": [285, 1], "end": [288, 29], "kind": "commanddeclaration"}, {"full_name": "Set.countable_setOf_nonempty_of_disjoint", "code": "theorem countable_setOf_nonempty_of_disjoint {f : \u03b2 \u2192 Set \u03b1}\n    (hf : Pairwise (Disjoint on f)) {s : Set \u03b1} (h'f : \u2200 t, f t \u2286 s) (hs : s.Countable) :\n    Set.Countable {t | (f t).Nonempty}", "start": [291, 1], "end": [310, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.countable_toSet", "code": "theorem Finset.countable_toSet (s : Finset \u03b1) : Set.Countable (\u2191s : Set \u03b1)", "start": [314, 1], "end": [315, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Basic.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "Mathlib/Data/Finset/Powerset.lean", "Mathlib/Data/Finset/Sum.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finset/Sigma.lean", "Mathlib/Data/Fintype/Basic.lean", "Mathlib/Algebra/Ring/Opposite.lean", "Mathlib/Data/Multiset/Powerset.lean", "Mathlib/Algebra/BigOperators/Multiset/Lemmas.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "Finset.prod", "code": "@[to_additive \"`\u2211 x in s, f x` is the sum of `f x` as `x` ranges over the elements\nof the finite set `s`.\"]\nprotected def prod [CommMonoid \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : \u03b2 :=\n  (s.1.map f).prod", "start": [56, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mk", "code": "@[to_additive (attr := simp)]\ntheorem prod_mk [CommMonoid \u03b2] (s : Multiset \u03b1) (hs : s.Nodup) (f : \u03b1 \u2192 \u03b2) :\n    (\u27e8s, hs\u27e9 : Finset \u03b1).prod f = (s.map f).prod", "start": [66, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_val", "code": "@[to_additive (attr := simp)]\ntheorem prod_val [CommMonoid \u03b1] (s : Finset \u03b1) : s.1.prod = s.prod id", "start": [73, 1], "end": [75, 36], "kind": "commanddeclaration"}, {"full_name": "BigOperators.delabFinsetProd", "code": "@[scoped delab app.Finset.prod] def delabFinsetProd : Delab := whenPPOption getPPNotation do\n  let #[_, _, _, s, f] := (\u2190 getExpr).getAppArgs | failure\n  guard <| f.isLambda\n  let ppDomain \u2190 getPPOption getPPPiBinderTypes\n  let (i, body) \u2190 withAppArg <| withBindingBodyUnusedName fun i => do\n    return (i, \u2190 delab)\n  if s.isAppOfArity ``Finset.univ 2 then\n    let binder \u2190\n      if ppDomain then\n        let ty \u2190 withNaryArg 1 delab\n        `(extBinder| $(.mk i):ident : $ty)\n      else\n        `(extBinder| $(.mk i):ident)\n    `(\u220f $binder, $body)\n  else\n    let ss \u2190 withNaryArg 3 <| delab\n    `(\u220f $(.mk i):ident in $ss, $body)", "start": [135, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "BigOperators.delabFinsetSum", "code": "@[scoped delab app.Finset.sum] def delabFinsetSum : Delab := whenPPOption getPPNotation do\n  let #[_, _, _, s, f] := (\u2190 getExpr).getAppArgs | failure\n  guard <| f.isLambda\n  let ppDomain \u2190 getPPOption getPPPiBinderTypes\n  let (i, body) \u2190 withAppArg <| withBindingBodyUnusedName fun i => do\n    return (i, \u2190 delab)\n  if s.isAppOfArity ``Finset.univ 2 then\n    let binder \u2190\n      if ppDomain then\n        let ty \u2190 withNaryArg 1 delab\n        `(extBinder| $(.mk i):ident : $ty)\n      else\n        `(extBinder| $(.mk i):ident)\n    `(\u2211 $binder, $body)\n  else\n    let ss \u2190 withNaryArg 3 <| delab\n    `(\u2211 $(.mk i):ident in $ss, $body)", "start": [155, 1], "end": [173, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_multiset_prod", "code": "@[to_additive]\ntheorem prod_eq_multiset_prod [CommMonoid \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f x in s, f x = (s.1.map f).prod", "start": [183, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_fold", "code": "@[to_additive]\ntheorem prod_eq_fold [CommMonoid \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f x in s, f x = s.fold ((\u00b7 * \u00b7) : \u03b2 \u2192 \u03b2 \u2192 \u03b2) 1 f", "start": [190, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_multiset_singleton", "code": "@[simp]\ntheorem sum_multiset_singleton (s : Finset \u03b1) : (s.sum fun x => {x}) = s.val", "start": [197, 1], "end": [199, 62], "kind": "commanddeclaration"}, {"full_name": "map_prod", "code": "@[to_additive (attr := simp)]\ntheorem map_prod [CommMonoid \u03b2] [CommMonoid \u03b3] {G : Type*} [MonoidHomClass G \u03b2 \u03b3] (g : G)\n    (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : g (\u220f x in s, f x) = \u220f x in s, g (f x)", "start": [204, 1], "end": [207, 85], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_prod", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `_root_.map_sum` instead.\"]\nprotected theorem MonoidHom.map_prod [CommMonoid \u03b2] [CommMonoid \u03b3] (g : \u03b2 \u2192* \u03b3) (f : \u03b1 \u2192 \u03b2)\n    (s : Finset \u03b1) : g (\u220f x in s, f x) = \u220f x in s, g (f x)", "start": [213, 1], "end": [217, 17], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_prod", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `_root_.map_sum` instead.\"]\nprotected theorem MulEquiv.map_prod [CommMonoid \u03b2] [CommMonoid \u03b3] (g : \u03b2 \u2243* \u03b3) (f : \u03b1 \u2192 \u03b2)\n    (s : Finset \u03b1) : g (\u220f x in s, f x) = \u220f x in s, g (f x)", "start": [221, 1], "end": [225, 17], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_list_prod", "code": "@[deprecated _root_.map_list_prod]\nprotected theorem RingHom.map_list_prod [Semiring \u03b2] [Semiring \u03b3] (f : \u03b2 \u2192+* \u03b3) (l : List \u03b2) :\n    f l.prod = (l.map f).prod", "start": [229, 1], "end": [232, 20], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_list_sum", "code": "@[deprecated _root_.map_list_sum]\nprotected theorem RingHom.map_list_sum [NonAssocSemiring \u03b2] [NonAssocSemiring \u03b3] (f : \u03b2 \u2192+* \u03b3)\n    (l : List \u03b2) : f l.sum = (l.map f).sum", "start": [235, 1], "end": [238, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.unop_map_list_prod", "code": "@[deprecated _root_.unop_map_list_prod]\nprotected theorem RingHom.unop_map_list_prod [Semiring \u03b2] [Semiring \u03b3] (f : \u03b2 \u2192+* \u03b3\u1d50\u1d52\u1d56)\n    (l : List \u03b2) : MulOpposite.unop (f l.prod) = (l.map (MulOpposite.unop \u2218 f)).reverse.prod", "start": [241, 1], "end": [245, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_multiset_prod", "code": "@[deprecated _root_.map_multiset_prod]\nprotected theorem RingHom.map_multiset_prod [CommSemiring \u03b2] [CommSemiring \u03b3] (f : \u03b2 \u2192+* \u03b3)\n    (s : Multiset \u03b2) : f s.prod = (s.map f).prod", "start": [248, 1], "end": [251, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_multiset_sum", "code": "@[deprecated _root_.map_multiset_sum]\nprotected theorem RingHom.map_multiset_sum [NonAssocSemiring \u03b2] [NonAssocSemiring \u03b3] (f : \u03b2 \u2192+* \u03b3)\n    (s : Multiset \u03b2) : f s.sum = (s.map f).sum", "start": [254, 1], "end": [257, 23], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_prod", "code": "@[deprecated _root_.map_prod]\nprotected theorem RingHom.map_prod [CommSemiring \u03b2] [CommSemiring \u03b3] (g : \u03b2 \u2192+* \u03b3) (f : \u03b1 \u2192 \u03b2)\n    (s : Finset \u03b1) : g (\u220f x in s, f x) = \u220f x in s, g (f x)", "start": [260, 1], "end": [263, 17], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_sum", "code": "@[deprecated _root_.map_sum]\nprotected theorem RingHom.map_sum [NonAssocSemiring \u03b2] [NonAssocSemiring \u03b3] (g : \u03b2 \u2192+* \u03b3)\n    (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : g (\u2211 x in s, f x) = \u2211 x in s, g (f x)", "start": [266, 1], "end": [269, 16], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_finset_prod", "code": "@[to_additive]\ntheorem MonoidHom.coe_finset_prod [MulOneClass \u03b2] [CommMonoid \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192* \u03b3) (s : Finset \u03b1) :\n    \u21d1(\u220f x in s, f x) = \u220f x in s, \u21d1f x", "start": [274, 1], "end": [277, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.finset_prod_apply", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.finset_prod_apply [MulOneClass \u03b2] [CommMonoid \u03b3] (f : \u03b1 \u2192 \u03b2 \u2192* \u03b3) (s : Finset \u03b1)\n    (b : \u03b2) : (\u220f x in s, f x) b = \u220f x in s, f x b", "start": [283, 1], "end": [286, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_empty", "code": "@[to_additive (attr := simp)]\ntheorem prod_empty : \u220f x in \u2205, f x = 1", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_of_empty", "code": "@[to_additive]\ntheorem prod_of_empty [IsEmpty \u03b1] (s : Finset \u03b1) : \u220f i in s, f i = 1", "start": [304, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_cons", "code": "@[to_additive (attr := simp)]\ntheorem prod_cons (h : a \u2209 s) : \u220f x in cons a s h, f x = f a * \u220f x in s, f x", "start": [310, 1], "end": [312, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_insert", "code": "@[to_additive (attr := simp)]\ntheorem prod_insert [DecidableEq \u03b1] : a \u2209 s \u2192 \u220f x in insert a s, f x = f a * \u220f x in s, f x", "start": [316, 1], "end": [318, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_insert_of_eq_one_if_not_mem", "code": "@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `a` is in `s` or `f a = 0`.\"]\ntheorem prod_insert_of_eq_one_if_not_mem [DecidableEq \u03b1] (h : a \u2209 s \u2192 f a = 1) :\n    \u220f x in insert a s, f x = \u220f x in s, f x", "start": [322, 1], "end": [330, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_insert_one", "code": "@[to_additive (attr := simp) \"The sum of `f` over `insert a s` is the same as\nthe sum over `s`, as long as `f a = 0`.\"]\ntheorem prod_insert_one [DecidableEq \u03b1] (h : f a = 1) : \u220f x in insert a s, f x = \u220f x in s, f x", "start": [334, 1], "end": [339, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_singleton", "code": "@[to_additive (attr := simp)]\ntheorem prod_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : \u220f x in singleton a, f x = f a", "start": [343, 1], "end": [345, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pair", "code": "@[to_additive]\ntheorem prod_pair [DecidableEq \u03b1] {a b : \u03b1} (h : a \u2260 b) :\n    (\u220f x in ({a, b} : Finset \u03b1), f x) = f a * f b", "start": [349, 1], "end": [352, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_const_one", "code": "@[to_additive (attr := simp)]\ntheorem prod_const_one : (\u220f _x in s, (1 : \u03b2)) = 1", "start": [356, 1], "end": [358, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_image", "code": "@[to_additive (attr := simp)]\ntheorem prod_image [DecidableEq \u03b1] {s : Finset \u03b3} {g : \u03b3 \u2192 \u03b1} :\n    (\u2200 x \u2208 s, \u2200 y \u2208 s, g x = g y \u2192 x = y) \u2192 \u220f x in s.image g, f x = \u220f x in s, f (g x)", "start": [362, 1], "end": [365, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_map", "code": "@[to_additive (attr := simp)]\ntheorem prod_map (s : Finset \u03b1) (e : \u03b1 \u21aa \u03b3) (f : \u03b3 \u2192 \u03b2) :\n    \u220f x in s.map e, f x = \u220f x in s, f (e x)", "start": [369, 1], "end": [372, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_congr", "code": "@[to_additive (attr := congr)]\ntheorem prod_congr (h : s\u2081 = s\u2082) : (\u2200 x \u2208 s\u2082, f x = g x) \u2192 s\u2081.prod f = s\u2082.prod g", "start": [376, 1], "end": [378, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_disjUnion", "code": "@[to_additive]\ntheorem prod_disjUnion (h) :\n    \u220f x in s\u2081.disjUnion s\u2082 h, f x = (\u220f x in s\u2081, f x) * \u220f x in s\u2082, f x", "start": [382, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_disjiUnion", "code": "@[to_additive]\ntheorem prod_disjiUnion (s : Finset \u03b9) (t : \u03b9 \u2192 Finset \u03b1) (h) :\n    \u220f x in s.disjiUnion t h, f x = \u220f i in s, \u220f x in t i, f x", "start": [391, 1], "end": [397, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_union_inter", "code": "@[to_additive]\ntheorem prod_union_inter [DecidableEq \u03b1] :\n    (\u220f x in s\u2081 \u222a s\u2082, f x) * \u220f x in s\u2081 \u2229 s\u2082, f x = (\u220f x in s\u2081, f x) * \u220f x in s\u2082, f x", "start": [401, 1], "end": [404, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_union", "code": "@[to_additive]\ntheorem prod_union [DecidableEq \u03b1] (h : Disjoint s\u2081 s\u2082) :\n    \u220f x in s\u2081 \u222a s\u2082, f x = (\u220f x in s\u2081, f x) * \u220f x in s\u2082, f x", "start": [408, 1], "end": [411, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_filter_mul_prod_filter_not", "code": "@[to_additive]\ntheorem prod_filter_mul_prod_filter_not\n    (s : Finset \u03b1) (p : \u03b1 \u2192 Prop) [DecidablePred p] [\u2200 x, Decidable (\u00acp x)] (f : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s.filter p, f x) * \u220f x in s.filter fun x => \u00acp x, f x = \u220f x in s, f x", "start": [415, 1], "end": [420, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_to_list", "code": "@[to_additive (attr := simp)]\ntheorem prod_to_list (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : (s.toList.map f).prod = s.prod f", "start": [426, 1], "end": [428, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prod_comp", "code": "@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp (\u03c3 : Equiv.Perm \u03b1) (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (hs : { a | \u03c3 a \u2260 a } \u2286 s) : (\u220f x in s, f (\u03c3 x)) = \u220f x in s, f x", "start": [434, 1], "end": [438, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prod_comp'", "code": "@[to_additive]\ntheorem _root_.Equiv.Perm.prod_comp' (\u03c3 : Equiv.Perm \u03b1) (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2)\n    (hs : { a | \u03c3 a \u2260 a } \u2286 s) : (\u220f x in s, f (\u03c3 x) x) = \u220f x in s, f x (\u03c3.symm x)", "start": [442, 1], "end": [446, 30], "kind": "commanddeclaration"}, {"full_name": "IsCompl.prod_mul_prod", "code": "@[to_additive]\ntheorem IsCompl.prod_mul_prod {s t : Finset \u03b1} (h : IsCompl s t) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f i in s, f i) * \u220f i in t, f i = \u220f i, f i", "start": [460, 1], "end": [464, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mul_prod_compl", "code": "@[to_additive \"Adding the sums of a function over `s` and over `s\u1d9c` gives the whole sum.\nFor a version expressed with subtypes, see `Fintype.sum_subtype_add_sum_subtype`. \"]\ntheorem prod_mul_prod_compl [Fintype \u03b1] [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f i in s, f i) * \u220f i in s\u1d9c, f i = \u220f i, f i", "start": [476, 1], "end": [482, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_compl_mul_prod", "code": "@[to_additive]\ntheorem prod_compl_mul_prod [Fintype \u03b1] [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f i in s\u1d9c, f i) * \u220f i in s, f i = \u220f i, f i", "start": [486, 1], "end": [489, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sdiff", "code": "@[to_additive]\ntheorem prod_sdiff [DecidableEq \u03b1] (h : s\u2081 \u2286 s\u2082) :\n    (\u220f x in s\u2082 \\ s\u2081, f x) * \u220f x in s\u2081, f x = \u220f x in s\u2082, f x", "start": [493, 1], "end": [496, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_disj_sum", "code": "@[to_additive (attr := simp)]\ntheorem prod_disj_sum (s : Finset \u03b1) (t : Finset \u03b3) (f : Sum \u03b1 \u03b3 \u2192 \u03b2) :\n    \u220f x in s.disjSum t, f x = (\u220f x in s, f (Sum.inl x)) * \u220f x in t, f (Sum.inr x)", "start": [500, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sum_elim", "code": "@[to_additive]\ntheorem prod_sum_elim (s : Finset \u03b1) (t : Finset \u03b3) (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b2) :\n    \u220f x in s.disjSum t, Sum.elim f g x = (\u220f x in s, f x) * \u220f x in t, g x", "start": [508, 1], "end": [510, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_biUnion", "code": "@[to_additive]\ntheorem prod_biUnion [DecidableEq \u03b1] {s : Finset \u03b3} {t : \u03b3 \u2192 Finset \u03b1}\n    (hs : Set.PairwiseDisjoint (\u2191s) t) : \u220f x in s.biUnion t, f x = \u220f x in s, \u220f i in t x, f i", "start": [514, 1], "end": [517, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sigma", "code": "@[to_additive \"Sum over a sigma type equals the sum of fiberwise sums. For rewriting\nin the reverse direction, use `Finset.sum_sigma'`\"]\ntheorem prod_sigma {\u03c3 : \u03b1 \u2192 Type*} (s : Finset \u03b1) (t : \u2200 a, Finset (\u03c3 a)) (f : Sigma \u03c3 \u2192 \u03b2) :\n    \u220f x in s.sigma t, f x = \u220f a in s, \u220f s in t a, f \u27e8a, s\u27e9", "start": [521, 1], "end": [527, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sigma'", "code": "@[to_additive]\ntheorem prod_sigma' {\u03c3 : \u03b1 \u2192 Type*} (s : Finset \u03b1) (t : \u2200 a, Finset (\u03c3 a)) (f : \u2200 a, \u03c3 a \u2192 \u03b2) :\n    (\u220f a in s, \u220f s in t a, f a s) = \u220f x in s.sigma t, f x.1 x.2", "start": [531, 1], "end": [534, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_bij", "code": "@[to_additive \"Reorder a sum.\n\n  The difference with `sum_bij'` is that the bijection is specified as a surjective injection,\n  rather than by an inverse function.\"]\ntheorem prod_bij {s : Finset \u03b1} {t : Finset \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b2} (i : \u2200 a \u2208 s, \u03b3)\n    (hi : \u2200 a ha, i a ha \u2208 t) (h : \u2200 a ha, f a = g (i a ha))\n    (i_inj : \u2200 a\u2081 a\u2082 ha\u2081 ha\u2082, i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082)\n    (i_surj : \u2200 b \u2208 t, \u2203 a ha, b = i a ha) : \u220f x in s, f x = \u220f x in t, g x", "start": [538, 1], "end": [551, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_bij'", "code": "@[to_additive \"Reorder a sum.\n\n  The difference with `sum_bij` is that the bijection is specified with an inverse, rather than\n  as a surjective injection.\"]\ntheorem prod_bij' {s : Finset \u03b1} {t : Finset \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b2} (i : \u2200 a \u2208 s, \u03b3)\n    (hi : \u2200 a ha, i a ha \u2208 t) (h : \u2200 a ha, f a = g (i a ha)) (j : \u2200 a \u2208 t, \u03b1)\n    (hj : \u2200 a ha, j a ha \u2208 s) (left_inv : \u2200 a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : \u2200 a ha, i (j a ha) (hj a ha) = a) : \u220f x in s, f x = \u220f x in t, g x", "start": [555, 1], "end": [575, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Equiv.prod_comp_finset", "code": "@[to_additive \" Reindexing a sum over a finset along an equivalence.\nSee `Equiv.sum_comp` for the version where `s` and `s'` are `univ`. \"]\ntheorem Equiv.prod_comp_finset {\u03b9'} [DecidableEq \u03b9] (e : \u03b9 \u2243 \u03b9') (f : \u03b9' \u2192 \u03b2) {s' : Finset \u03b9'}\n    {s : Finset \u03b9} (h : s = s'.image e.symm) : \u220f i' in s', f i' = \u220f i in s, f (e i)", "start": [579, 1], "end": [592, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_finset_product", "code": "@[to_additive]\ntheorem prod_finset_product (r : Finset (\u03b3 \u00d7 \u03b1)) (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1)\n    (h : \u2200 p : \u03b3 \u00d7 \u03b1, p \u2208 r \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1) {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2} :\n    \u220f p in r, f p = \u220f c in s, \u220f a in t c, f (c, a)", "start": [596, 1], "end": [604, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_finset_product'", "code": "@[to_additive]\ntheorem prod_finset_product' (r : Finset (\u03b3 \u00d7 \u03b1)) (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1)\n    (h : \u2200 p : \u03b3 \u00d7 \u03b1, p \u2208 r \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t p.1) {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    \u220f p in r, f p.1 p.2 = \u220f c in s, \u220f a in t c, f c a", "start": [608, 1], "end": [612, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_finset_product_right", "code": "@[to_additive]\ntheorem prod_finset_product_right (r : Finset (\u03b1 \u00d7 \u03b3)) (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1)\n    (h : \u2200 p : \u03b1 \u00d7 \u03b3, p \u2208 r \u2194 p.2 \u2208 s \u2227 p.1 \u2208 t p.2) {f : \u03b1 \u00d7 \u03b3 \u2192 \u03b2} :\n    \u220f p in r, f p = \u220f c in s, \u220f a in t c, f (a, c)", "start": [616, 1], "end": [624, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_finset_product_right'", "code": "@[to_additive]\ntheorem prod_finset_product_right' (r : Finset (\u03b1 \u00d7 \u03b3)) (s : Finset \u03b3) (t : \u03b3 \u2192 Finset \u03b1)\n    (h : \u2200 p : \u03b1 \u00d7 \u03b3, p \u2208 r \u2194 p.2 \u2208 s \u2227 p.1 \u2208 t p.2) {f : \u03b1 \u2192 \u03b3 \u2192 \u03b2} :\n    \u220f p in r, f p.1 p.2 = \u220f c in s, \u220f a in t c, f a c", "start": [628, 1], "end": [632, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_fiberwise_of_maps_to", "code": "@[to_additive]\ntheorem prod_fiberwise_of_maps_to [DecidableEq \u03b3] {s : Finset \u03b1} {t : Finset \u03b3} {g : \u03b1 \u2192 \u03b3}\n    (h : \u2200 x \u2208 s, g x \u2208 t) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f y in t, \u220f x in s.filter fun x => g x = y, f x) = \u220f x in s, f x", "start": [636, 1], "end": [640, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_image'", "code": "@[to_additive]\ntheorem prod_image' [DecidableEq \u03b1] {s : Finset \u03b3} {g : \u03b3 \u2192 \u03b1} (h : \u03b3 \u2192 \u03b2)\n    (eq : \u2200 c \u2208 s, f (g c) = \u220f x in s.filter fun c' => g c' = g c, h x) :\n    \u220f x in s.image g, f x = \u220f x in s, h x", "start": [644, 1], "end": [653, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mul_distrib", "code": "@[to_additive]\ntheorem prod_mul_distrib : \u220f x in s, f x * g x = (\u220f x in s, f x) * \u220f x in s, g x", "start": [657, 1], "end": [659, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_product", "code": "@[to_additive]\ntheorem prod_product {s : Finset \u03b3} {t : Finset \u03b1} {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2} :\n    \u220f x in s \u00d7\u02e2 t, f x = \u220f x in s, \u220f y in t, f (x, y)", "start": [663, 1], "end": [666, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_product'", "code": "@[to_additive \"An uncurried version of `Finset.sum_product`\"]\ntheorem prod_product' {s : Finset \u03b3} {t : Finset \u03b1} {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    \u220f x in s \u00d7\u02e2 t, f x.1 x.2 = \u220f x in s, \u220f y in t, f x y", "start": [670, 1], "end": [674, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_product_right", "code": "@[to_additive]\ntheorem prod_product_right {s : Finset \u03b3} {t : Finset \u03b1} {f : \u03b3 \u00d7 \u03b1 \u2192 \u03b2} :\n    \u220f x in s \u00d7\u02e2 t, f x = \u220f y in t, \u220f x in s, f (x, y)", "start": [678, 1], "end": [681, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_product_right'", "code": "@[to_additive \"An uncurried version of `Finset.prod_product_right`\"]\ntheorem prod_product_right' {s : Finset \u03b3} {t : Finset \u03b1} {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    \u220f x in s \u00d7\u02e2 t, f x.1 x.2 = \u220f y in t, \u220f x in s, f x y", "start": [685, 1], "end": [689, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_comm'", "code": "@[to_additive \"Generalization of `Finset.sum_comm` to the case when the inner `Finset`s depend on\nthe outer variable.\"]\ntheorem prod_comm' {s : Finset \u03b3} {t : \u03b3 \u2192 Finset \u03b1} {t' : Finset \u03b1} {s' : \u03b1 \u2192 Finset \u03b3}\n    (h : \u2200 x y, x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t') {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    (\u220f x in s, \u220f y in t x, f x y) = \u220f y in t', \u220f x in s' y, f x y", "start": [693, 1], "end": [708, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_comm", "code": "@[to_additive]\ntheorem prod_comm {s : Finset \u03b3} {t : Finset \u03b1} {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    (\u220f x in s, \u220f y in t, f x y) = \u220f y in t, \u220f x in s, f x y", "start": [712, 1], "end": [715, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_hom_rel", "code": "@[to_additive]\ntheorem prod_hom_rel [CommMonoid \u03b3] {r : \u03b2 \u2192 \u03b3 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {s : Finset \u03b1}\n    (h\u2081 : r 1 1) (h\u2082 : \u2200 a b c, r b c \u2192 r (f a * b) (g a * c)) :\n    r (\u220f x in s, f x) (\u220f x in s, g x)", "start": [719, 1], "end": [724, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_one", "code": "@[to_additive]\ntheorem prod_eq_one {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} (h : \u2200 x \u2208 s, f x = 1) : \u220f x in s, f x = 1", "start": [728, 1], "end": [732, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subset_one_on_sdiff", "code": "@[to_additive]\ntheorem prod_subset_one_on_sdiff [DecidableEq \u03b1] (h : s\u2081 \u2286 s\u2082) (hg : \u2200 x \u2208 s\u2082 \\ s\u2081, g x = 1)\n    (hfg : \u2200 x \u2208 s\u2081, f x = g x) : \u220f i in s\u2081, f i = \u220f i in s\u2082, g i", "start": [736, 1], "end": [740, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subset", "code": "@[to_additive]\ntheorem prod_subset (h : s\u2081 \u2286 s\u2082) (hf : \u2200 x \u2208 s\u2082, x \u2209 s\u2081 \u2192 f x = 1) :\n    \u220f x in s\u2081, f x = \u220f x in s\u2082, f x", "start": [744, 1], "end": [748, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_filter_of_ne", "code": "@[to_additive]\ntheorem prod_filter_of_ne {p : \u03b1 \u2192 Prop} [DecidablePred p] (hp : \u2200 x \u2208 s, f x \u2260 1 \u2192 p x) :\n    \u220f x in s.filter p, f x = \u220f x in s, f x", "start": [752, 1], "end": [758, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_filter_ne_one", "code": "@[to_additive]\ntheorem prod_filter_ne_one [\u2200 x, Decidable (f x \u2260 1)] :\n    \u220f x in s.filter fun x => f x \u2260 1, f x = \u220f x in s, f x", "start": [764, 1], "end": [767, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_filter", "code": "@[to_additive]\ntheorem prod_filter (p : \u03b1 \u2192 Prop) [DecidablePred p] (f : \u03b1 \u2192 \u03b2) :\n    \u220f a in s.filter p, f a = \u220f a in s, if p a then f a else 1", "start": [771, 1], "end": [780, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_single_of_mem", "code": "@[to_additive]\ntheorem prod_eq_single_of_mem {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (a : \u03b1) (h : a \u2208 s)\n    (h\u2080 : \u2200 b \u2208 s, b \u2260 a \u2192 f b = 1) : \u220f x in s, f x = f a", "start": [784, 1], "end": [794, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_single", "code": "@[to_additive]\ntheorem prod_eq_single {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (a : \u03b1) (h\u2080 : \u2200 b \u2208 s, b \u2260 a \u2192 f b = 1)\n    (h\u2081 : a \u2209 s \u2192 f a = 1) : \u220f x in s, f x = f a", "start": [798, 1], "end": [804, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_mul_of_mem", "code": "@[to_additive]\ntheorem prod_eq_mul_of_mem {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (a b : \u03b1) (ha : a \u2208 s) (hb : b \u2208 s)\n    (hn : a \u2260 b) (h\u2080 : \u2200 c \u2208 s, c \u2260 a \u2227 c \u2260 b \u2192 f c = 1) : \u220f x in s, f x = f a * f b", "start": [808, 1], "end": [826, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_mul", "code": "@[to_additive]\ntheorem prod_eq_mul {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (a b : \u03b1) (hn : a \u2260 b)\n    (h\u2080 : \u2200 c \u2208 s, c \u2260 a \u2227 c \u2260 b \u2192 f c = 1) (ha : a \u2209 s \u2192 f a = 1) (hb : b \u2209 s \u2192 f b = 1) :\n    \u220f x in s, f x = f a * f b", "start": [830, 1], "end": [847, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_attach", "code": "@[to_additive]\ntheorem prod_attach {f : \u03b1 \u2192 \u03b2} : \u220f x in s.attach, f x = \u220f x in s, f x", "start": [851, 1], "end": [857, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subtype_eq_prod_filter", "code": "@[to_additive (attr := simp, nolint simpNF)\n  \"A sum over `s.subtype p` equals one over `s.filter p`.\"]\ntheorem prod_subtype_eq_prod_filter (f : \u03b1 \u2192 \u03b2) {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    \u220f x in s.subtype p, f x = \u220f x in s.filter p, f x", "start": [862, 1], "end": [868, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subtype_of_mem", "code": "@[to_additive \"If all elements of a `Finset` satisfy the predicate `p`, a sum\nover `s.subtype p` equals that sum over `s`.\"]\ntheorem prod_subtype_of_mem (f : \u03b1 \u2192 \u03b2) {p : \u03b1 \u2192 Prop} [DecidablePred p] (h : \u2200 x \u2208 s, p x) :\n    \u220f x in s.subtype p, f x = \u220f x in s, f x", "start": [872, 1], "end": [879, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subtype_map_embedding", "code": "@[to_additive \"A sum of a function over a `Finset` in a subtype equals a\nsum in the main type of a function that agrees with the first\nfunction on that `Finset`.\"]\ntheorem prod_subtype_map_embedding {p : \u03b1 \u2192 Prop} {s : Finset { x // p x }} {f : { x // p x } \u2192 \u03b2}\n    {g : \u03b1 \u2192 \u03b2} (h : \u2200 x : { x // p x }, x \u2208 s \u2192 g x = f x) :\n    (\u220f x in s.map (Function.Embedding.subtype _), g x) = \u220f x in s, f x", "start": [883, 1], "end": [893, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_coe_sort_eq_attach", "code": "@[to_additive]\ntheorem prod_coe_sort_eq_attach (f : s \u2192 \u03b2) : \u220f i : s, f i = \u220f i in s.attach, f i", "start": [899, 1], "end": [901, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_coe_sort", "code": "@[to_additive]\ntheorem prod_coe_sort : \u220f i : s, f i = \u220f i in s, f i", "start": [905, 1], "end": [907, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_finset_coe", "code": "@[to_additive]\ntheorem prod_finset_coe (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) : (\u220f i : (s : Set \u03b1), f i) = \u220f i in s, f i", "start": [911, 1], "end": [913, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_subtype", "code": "@[to_additive]\ntheorem prod_subtype {p : \u03b1 \u2192 Prop} {F : Fintype (Subtype p)} (s : Finset \u03b1) (h : \u2200 x, x \u2208 s \u2194 p x)\n    (f : \u03b1 \u2192 \u03b2) : \u220f a in s, f a = \u220f a : Subtype p, f a", "start": [919, 1], "end": [925, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_set_coe", "code": "@[to_additive]\ntheorem prod_set_coe (s : Set \u03b1) [Fintype s] : (\u220f i : s, f i) = \u220f i in s.toFinset, f i", "start": [929, 1], "end": [931, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_congr_set", "code": "@[to_additive \"The sum of a function `g` defined only on a set `s` is equal to\nthe sum of a function `f` defined everywhere,\nas long as `f` and `g` agree on `s`, and `f = 0` off `s`.\"]\ntheorem prod_congr_set {\u03b1 : Type*} [CommMonoid \u03b1] {\u03b2 : Type*} [Fintype \u03b2] (s : Set \u03b2)\n    [DecidablePred (\u00b7 \u2208 s)] (f : \u03b2 \u2192 \u03b1) (g : s \u2192 \u03b1) (w : \u2200 (x : \u03b2) (h : x \u2208 s), f x = g \u27e8x, h\u27e9)\n    (w' : \u2200 x : \u03b2, x \u2209 s \u2192 f x = 1) : Finset.univ.prod f = Finset.univ.prod g", "start": [933, 1], "end": [948, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_apply_dite", "code": "@[to_additive]\ntheorem prod_apply_dite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p}\n    [DecidablePred fun x => \u00acp x] (f : \u2200 x : \u03b1, p x \u2192 \u03b3) (g : \u2200 x : \u03b1, \u00acp x \u2192 \u03b3) (h : \u03b3 \u2192 \u03b2) :\n    (\u220f x in s, h (if hx : p x then f x hx else g x hx)) =\n      (\u220f x in (s.filter p).attach, h (f x.1 $ by simpa using (mem_filter.mp x.2).2)) *\n        \u220f x in (s.filter fun x => \u00acp x).attach, h (g x.1 $ by simpa using (mem_filter.mp x.2).2)", "start": [952, 1], "end": [970, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_apply_ite", "code": "@[to_additive]\ntheorem prod_apply_ite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {_hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b3)\n    (h : \u03b3 \u2192 \u03b2) :\n    (\u220f x in s, h (if p x then f x else g x)) =\n      (\u220f x in s.filter p, h (f x)) * \u220f x in s.filter fun x => \u00acp x, h (g x)", "start": [974, 1], "end": [980, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite", "code": "@[to_additive]\ntheorem prod_dite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f : \u2200 x : \u03b1, p x \u2192 \u03b2)\n    (g : \u2200 x : \u03b1, \u00acp x \u2192 \u03b2) :\n    \u220f x in s, (if hx : p x then f x hx else g x hx) =\n      (\u220f x in (s.filter p).attach, f x.1 (by simpa using (mem_filter.mp x.2).2)) *\n        \u220f x in (s.filter fun x => \u00acp x).attach, g x.1 (by simpa using (mem_filter.mp x.2).2)", "start": [984, 1], "end": [990, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite", "code": "@[to_additive]\ntheorem prod_ite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b2) :\n    \u220f x in s, (if p x then f x else g x) =\n      (\u220f x in s.filter p, f x) * \u220f x in s.filter fun x => \u00acp x, g x", "start": [994, 1], "end": [998, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_of_false", "code": "@[to_additive]\ntheorem prod_ite_of_false {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b2) (h : \u2200 x \u2208 s, \u00acp x) :\n    \u220f x in s, (if p x then f x else g x) = \u220f x in s, g x", "start": [1002, 1], "end": [1007, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_of_true", "code": "@[to_additive]\ntheorem prod_ite_of_true {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b2) (h : \u2200 x \u2208 s, p x) :\n    \u220f x in s, (if p x then f x else g x) = \u220f x in s, f x", "start": [1011, 1], "end": [1016, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_apply_ite_of_false", "code": "@[to_additive]\ntheorem prod_apply_ite_of_false {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b3) (k : \u03b3 \u2192 \u03b2)\n    (h : \u2200 x \u2208 s, \u00acp x) : (\u220f x in s, k (if p x then f x else g x)) = \u220f x in s, k (g x)", "start": [1020, 1], "end": [1024, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_apply_ite_of_true", "code": "@[to_additive]\ntheorem prod_apply_ite_of_true {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b3) (k : \u03b3 \u2192 \u03b2)\n    (h : \u2200 x \u2208 s, p x) : (\u220f x in s, k (if p x then f x else g x)) = \u220f x in s, k (f x)", "start": [1028, 1], "end": [1032, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_extend_by_one", "code": "@[to_additive]\ntheorem prod_extend_by_one [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f i in s, (if i \u2208 s then f i else 1) = \u220f i in s, f i", "start": [1036, 1], "end": [1039, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_mem", "code": "@[to_additive (attr := simp)]\ntheorem prod_ite_mem [DecidableEq \u03b1] (s t : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f i in s, (if i \u2208 t then f i else 1) = \u220f i in s \u2229 t, f i", "start": [1043, 1], "end": [1046, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite_eq", "code": "@[to_additive (attr := simp)]\ntheorem prod_dite_eq [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (b : \u2200 x : \u03b1, a = x \u2192 \u03b2) :\n    \u220f x in s, (if h : a = x then b x h else 1) = ite (a \u2208 s) (b a rfl) 1", "start": [1050, 1], "end": [1063, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite_eq'", "code": "@[to_additive (attr := simp)]\ntheorem prod_dite_eq' [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (b : \u2200 x : \u03b1, x = a \u2192 \u03b2) :\n    \u220f x in s, (if h : x = a then b x h else 1) = ite (a \u2208 s) (b a rfl) 1", "start": [1067, 1], "end": [1080, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_eq", "code": "@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (b : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s, ite (a = x) (b x) 1) = ite (a \u2208 s) (b a) 1", "start": [1084, 1], "end": [1087, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_eq'", "code": "@[to_additive (attr := simp) \"A sum taken over a conditional whose condition is an equality\ntest on the index and whose alternative is `0` has value either the term at that index or `0`.\n\nThe difference with `Finset.sum_ite_eq` is that the arguments to `eq` are swapped.\"]\ntheorem prod_ite_eq' [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (b : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s, ite (x = a) (b x) 1) = ite (a \u2208 s) (b a) 1", "start": [1091, 1], "end": [1101, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_index", "code": "@[to_additive]\ntheorem prod_ite_index (p : Prop) [Decidable p] (s t : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f x in if p then s else t, f x = if p then \u220f x in s, f x else \u220f x in t, f x", "start": [1105, 1], "end": [1108, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_irrel", "code": "@[to_additive (attr := simp)]\ntheorem prod_ite_irrel (p : Prop) [Decidable p] (s : Finset \u03b1) (f g : \u03b1 \u2192 \u03b2) :\n    \u220f x in s, (if p then f x else g x) = if p then \u220f x in s, f x else \u220f x in s, g x", "start": [1112, 1], "end": [1115, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite_irrel", "code": "@[to_additive (attr := simp)]\ntheorem prod_dite_irrel (p : Prop) [Decidable p] (s : Finset \u03b1) (f : p \u2192 \u03b1 \u2192 \u03b2) (g : \u00acp \u2192 \u03b1 \u2192 \u03b2) :\n    \u220f x in s, (if h : p then f h x else g h x) =\n      if h : p then \u220f x in s, f h x else \u220f x in s, g h x", "start": [1119, 1], "end": [1123, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pi_mulSingle'", "code": "@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle' [DecidableEq \u03b1] (a : \u03b1) (x : \u03b2) (s : Finset \u03b1) :\n    \u220f a' in s, Pi.mulSingle a x a' = if a \u2208 s then x else 1", "start": [1127, 1], "end": [1130, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pi_mulSingle", "code": "@[to_additive (attr := simp)]\ntheorem prod_pi_mulSingle {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [\u2200 a, CommMonoid (\u03b2 a)] (a : \u03b1)\n    (f : \u2200 a, \u03b2 a) (s : Finset \u03b1) :\n    (\u220f a' in s, Pi.mulSingle a' (f a') a) = if a \u2208 s then f a else 1", "start": [1134, 1], "end": [1138, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_bij_ne_one", "code": "@[to_additive]\ntheorem prod_bij_ne_one {s : Finset \u03b1} {t : Finset \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b2}\n    (i : \u2200 a \u2208 s, f a \u2260 1 \u2192 \u03b3) (hi : \u2200 a h\u2081 h\u2082, i a h\u2081 h\u2082 \u2208 t)\n    (i_inj : \u2200 a\u2081 a\u2082 h\u2081\u2081 h\u2081\u2082 h\u2082\u2081 h\u2082\u2082, i a\u2081 h\u2081\u2081 h\u2081\u2082 = i a\u2082 h\u2082\u2081 h\u2082\u2082 \u2192 a\u2081 = a\u2082)\n    (i_surj : \u2200 b \u2208 t, g b \u2260 1 \u2192 \u2203 a h\u2081 h\u2082, b = i a h\u2081 h\u2082) (h : \u2200 a h\u2081 h\u2082, f a = g (i a h\u2081 h\u2082)) :\n    \u220f x in s, f x = \u220f x in t, g x", "start": [1141, 1], "end": [1169, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite_of_false", "code": "@[to_additive]\ntheorem prod_dite_of_false {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (h : \u2200 x \u2208 s, \u00acp x)\n    (f : \u2200 x : \u03b1, p x \u2192 \u03b2) (g : \u2200 x : \u03b1, \u00acp x \u2192 \u03b2) :\n    \u220f x in s, (if hx : p x then f x hx else g x hx) = \u220f x : s, g x.val (h x.val x.property)", "start": [1173, 1], "end": [1181, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dite_of_true", "code": "@[to_additive]\ntheorem prod_dite_of_true {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (h : \u2200 x \u2208 s, p x)\n    (f : \u2200 x : \u03b1, p x \u2192 \u03b2) (g : \u2200 x : \u03b1, \u00acp x \u2192 \u03b2) :\n    \u220f x in s, (if hx : p x then f x hx else g x hx) = \u220f x : s, f x.val (h x.val x.property)", "start": [1185, 1], "end": [1193, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_of_prod_ne_one", "code": "@[to_additive]\ntheorem nonempty_of_prod_ne_one (h : \u220f x in s, f x \u2260 1) : s.Nonempty", "start": [1197, 1], "end": [1199, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_ne_one_of_prod_ne_one", "code": "@[to_additive]\ntheorem exists_ne_one_of_prod_ne_one (h : \u220f x in s, f x \u2260 1) : \u2203 a \u2208 s, f a \u2260 1", "start": [1203, 1], "end": [1208, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_succ_comm", "code": "@[to_additive]\ntheorem prod_range_succ_comm (f : \u2115 \u2192 \u03b2) (n : \u2115) :\n    (\u220f x in range (n + 1), f x) = f n * \u220f x in range n, f x", "start": [1212, 1], "end": [1215, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_succ", "code": "@[to_additive]\ntheorem prod_range_succ (f : \u2115 \u2192 \u03b2) (n : \u2115) :\n    (\u220f x in range (n + 1), f x) = (\u220f x in range n, f x) * f n", "start": [1219, 1], "end": [1222, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_succ'", "code": "@[to_additive]\ntheorem prod_range_succ' (f : \u2115 \u2192 \u03b2) :\n    \u2200 n : \u2115, (\u220f k in range (n + 1), f k) = (\u220f k in range n, f (k + 1)) * f 0", "start": [1226, 1], "end": [1230, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.eventually_constant_prod", "code": "@[to_additive]\ntheorem eventually_constant_prod {u : \u2115 \u2192 \u03b2} {N : \u2115} (hu : \u2200 n \u2265 N, u n = 1) {n : \u2115} (hn : N \u2264 n) :\n    (\u220f k in range n, u k) = \u220f k in range N, u k", "start": [1234, 1], "end": [1242, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_add", "code": "@[to_additive]\ntheorem prod_range_add (f : \u2115 \u2192 \u03b2) (n m : \u2115) :\n    (\u220f x in range (n + m), f x) = (\u220f x in range n, f x) * \u220f x in range m, f (n + x)", "start": [1246, 1], "end": [1251, 72], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_add_div_prod_range", "code": "@[to_additive]\ntheorem prod_range_add_div_prod_range {\u03b1 : Type*} [CommGroup \u03b1] (f : \u2115 \u2192 \u03b1) (n m : \u2115) :\n    (\u220f k in range (n + m), f k) / \u220f k in range n, f k = \u220f k in Finset.range m, f (n + k)", "start": [1255, 1], "end": [1258, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_zero", "code": "@[to_additive]\ntheorem prod_range_zero (f : \u2115 \u2192 \u03b2) : \u220f k in range 0, f k = 1", "start": [1262, 1], "end": [1263, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_one", "code": "@[to_additive sum_range_one]\ntheorem prod_range_one (f : \u2115 \u2192 \u03b2) : \u220f k in range 1, f k = f 0", "start": [1267, 1], "end": [1269, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_list_map_count", "code": "@[to_additive]\ntheorem prod_list_map_count [DecidableEq \u03b1] (l : List \u03b1) {M : Type*} [CommMonoid M] (f : \u03b1 \u2192 M) :\n    (l.map f).prod = \u220f m in l.toFinset, f m ^ l.count m", "start": [1275, 1], "end": [1291, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_list_count", "code": "@[to_additive]\ntheorem prod_list_count [DecidableEq \u03b1] [CommMonoid \u03b1] (s : List \u03b1) :\n    s.prod = \u220f m in s.toFinset, m ^ s.count m", "start": [1295, 1], "end": [1297, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_list_count_of_subset", "code": "@[to_additive]\ntheorem prod_list_count_of_subset [DecidableEq \u03b1] [CommMonoid \u03b1] (m : List \u03b1) (s : Finset \u03b1)\n    (hs : m.toFinset \u2286 s) : m.prod = \u220f i in s, i ^ m.count i", "start": [1301, 1], "end": [1307, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_filter_count_eq_countP", "code": "theorem sum_filter_count_eq_countP [DecidableEq \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] (l : List \u03b1) :\n    \u2211 x in l.toFinset.filter p, l.count x = l.countP p", "start": [1311, 1], "end": [1313, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_multiset_map_count", "code": "@[to_additive]\ntheorem prod_multiset_map_count [DecidableEq \u03b1] (s : Multiset \u03b1) {M : Type*} [CommMonoid M]\n    (f : \u03b1 \u2192 M) : (s.map f).prod = \u220f m in s.toFinset, f m ^ s.count m", "start": [1318, 1], "end": [1322, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_multiset_count", "code": "@[to_additive]\ntheorem prod_multiset_count [DecidableEq \u03b1] [CommMonoid \u03b1] (s : Multiset \u03b1) :\n    s.prod = \u220f m in s.toFinset, m ^ s.count m", "start": [1326, 1], "end": [1330, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_multiset_count_of_subset", "code": "@[to_additive]\ntheorem prod_multiset_count_of_subset [DecidableEq \u03b1] [CommMonoid \u03b1] (m : Multiset \u03b1) (s : Finset \u03b1)\n    (hs : m.toFinset \u2286 s) : m.prod = \u220f i in s, i ^ m.count i", "start": [1334, 1], "end": [1340, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mem_multiset", "code": "@[to_additive]\ntheorem prod_mem_multiset [DecidableEq \u03b1] (m : Multiset \u03b1) (f : { x // x \u2208 m } \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2)\n    (hfg : \u2200 x, f x = g x) : \u220f x : { x // x \u2208 m }, f x = \u220f x in m.toFinset, g x", "start": [1344, 1], "end": [1351, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_induction", "code": "@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction {M : Type*} [CommMonoid M] (f : \u03b1 \u2192 M) (p : M \u2192 Prop)\n    (hom : \u2200 a b, p a \u2192 p b \u2192 p (a * b)) (unit : p 1) (base : \u2200 x \u2208 s, p <| f x) :\n    p <| \u220f x in s, f x", "start": [1355, 1], "end": [1362, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_induction_nonempty", "code": "@[to_additive \"To prove a property of a sum, it suffices to prove that\nthe property is additive and holds on summands.\"]\ntheorem prod_induction_nonempty {M : Type*} [CommMonoid M] (f : \u03b1 \u2192 M) (p : M \u2192 Prop)\n    (hom : \u2200 a b, p a \u2192 p b \u2192 p (a * b)) (nonempty : s.Nonempty) (base : \u2200 x \u2208 s, p <| f x) :\n    p <| \u220f x in s, f x", "start": [1366, 1], "end": [1374, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_induction", "code": "@[to_additive \"For any sum along `{0, ..., n - 1}` of a commutative-monoid-valued function, we can\nverify that it's equal to a different function just by checking differences of adjacent terms.\n\nThis is a discrete analogue of the fundamental theorem of calculus.\"]\ntheorem prod_range_induction (f s : \u2115 \u2192 \u03b2) (base : s 0 = 1)\n    (step : \u2200 n, s (n + 1) = s n * f n) (n : \u2115) :\n    \u220f k in Finset.range n, f k = s n", "start": [1378, 1], "end": [1391, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_div", "code": "@[to_additive \"A telescoping sum along `{0, ..., n - 1}` of an additive commutative group valued\nfunction reduces to the difference of the last and first terms.\"]\ntheorem prod_range_div {M : Type*} [CommGroup M] (f : \u2115 \u2192 M) (n : \u2115) :\n    (\u220f i in range n, f (i + 1) / f i) = f n / f 0", "start": [1395, 1], "end": [1400, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_div'", "code": "@[to_additive]\ntheorem prod_range_div' {M : Type*} [CommGroup M] (f : \u2115 \u2192 M) (n : \u2115) :\n    (\u220f i in range n, f i / f (i + 1)) = f 0 / f n", "start": [1404, 1], "end": [1406, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_prod_range_div", "code": "@[to_additive]\ntheorem eq_prod_range_div {M : Type*} [CommGroup M] (f : \u2115 \u2192 M) (n : \u2115) :\n    f n = f 0 * \u220f i in range n, f (i + 1) / f i", "start": [1410, 1], "end": [1412, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_prod_range_div'", "code": "@[to_additive]\ntheorem eq_prod_range_div' {M : Type*} [CommGroup M] (f : \u2115 \u2192 M) (n : \u2115) :\n    f n = \u220f i in range (n + 1), if i = 0 then f 0 else f i / f (i - 1)", "start": [1416, 1], "end": [1420, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_tsub", "code": "theorem sum_range_tsub [CanonicallyOrderedAddCommMonoid \u03b1] [Sub \u03b1] [OrderedSub \u03b1]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {f : \u2115 \u2192 \u03b1} (h : Monotone f) (n : \u2115) :\n    \u2211 i in range n, (f (i + 1) - f i) = f n - f 0", "start": [1424, 1], "end": [1437, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_const", "code": "@[to_additive (attr := simp)]\ntheorem prod_const (b : \u03b2) : \u220f _x in s, b = b ^ s.card", "start": [1440, 1], "end": [1442, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_pow_card", "code": "@[to_additive sum_eq_card_nsmul]\ntheorem prod_eq_pow_card {b : \u03b2} (hf : \u2200 a \u2208 s, f a = b) : \u220f a in s, f a = b ^ s.card", "start": [1446, 1], "end": [1448, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.pow_eq_prod_const", "code": "@[to_additive]\ntheorem pow_eq_prod_const (b : \u03b2) : \u2200 n, b ^ n = \u220f _k in range n, b", "start": [1452, 1], "end": [1453, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pow", "code": "@[to_additive]\ntheorem prod_pow (s : Finset \u03b1) (n : \u2115) (f : \u03b1 \u2192 \u03b2) : \u220f x in s, f x ^ n = (\u220f x in s, f x) ^ n", "start": [1457, 1], "end": [1459, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_powersetCard", "code": "@[to_additive\n\"A sum over `Finset.powersetCard` which only depends on the size of the sets is constant.\"]\nlemma prod_powersetCard (n : \u2115) (s : Finset \u03b1) (f : \u2115 \u2192 \u03b2) :\n    \u220f t in powersetCard n s, f t.card = f n ^ s.card.choose n := by\n  rw [prod_eq_pow_card, card_powersetCard]; rintro a ha; rw [(mem_powersetCard.1 ha).2]", "start": [1463, 1], "end": [1468, 88], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.prod_flip", "code": "@[to_additive]\ntheorem prod_flip {n : \u2115} (f : \u2115 \u2192 \u03b2) :\n    (\u220f r in range (n + 1), f (n - r)) = \u220f k in range (n + 1), f k", "start": [1470, 1], "end": [1476, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_involution", "code": "@[to_additive]\ntheorem prod_involution {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    \u2200 (g : \u2200 a \u2208 s, \u03b1) (_ : \u2200 a ha, f a * f (g a ha) = 1) (_ : \u2200 a ha, f a \u2260 1 \u2192 g a ha \u2260 a)\n      (g_mem : \u2200 a ha, g a ha \u2208 s) (_ : \u2200 a ha, g (g a ha) (g_mem a ha) = a),\n      \u220f x in s, f x = 1", "start": [1480, 1], "end": [1518, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_comp", "code": "@[to_additive \"The sum of the composition of functions `f` and `g`, is the sum over `b \u2208 s.image g`\nof `f b` times of the cardinality of the fibre of `b`. See also `Finset.sum_image`.\"]\ntheorem prod_comp [DecidableEq \u03b3] (f : \u03b3 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) :\n    (\u220f a in s, f (g a)) = \u220f b in s.image g, f b ^ (s.filter fun a => g a = b).card", "start": [1522, 1], "end": [1540, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_piecewise", "code": "@[to_additive]\ntheorem prod_piecewise [DecidableEq \u03b1] (s t : Finset \u03b1) (f g : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s, (t.piecewise f g) x) = (\u220f x in s \u2229 t, f x) * \u220f x in s \\ t, g x", "start": [1544, 1], "end": [1547, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_inter_mul_prod_diff", "code": "@[to_additive]\ntheorem prod_inter_mul_prod_diff [DecidableEq \u03b1] (s t : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f x in s \u2229 t, f x) * \u220f x in s \\ t, f x = \u220f x in s, f x", "start": [1551, 1], "end": [1555, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_mul_prod_diff_singleton", "code": "@[to_additive]\ntheorem prod_eq_mul_prod_diff_singleton [DecidableEq \u03b1] {s : Finset \u03b1} {i : \u03b1} (h : i \u2208 s)\n    (f : \u03b1 \u2192 \u03b2) : \u220f x in s, f x = f i * \u220f x in s \\ {i}, f x", "start": [1559, 1], "end": [1563, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_prod_diff_singleton_mul", "code": "@[to_additive]\ntheorem prod_eq_prod_diff_singleton_mul [DecidableEq \u03b1] {s : Finset \u03b1} {i : \u03b1} (h : i \u2208 s)\n    (f : \u03b1 \u2192 \u03b2) : \u220f x in s, f x = (\u220f x in s \\ {i}, f x) * f i", "start": [1567, 1], "end": [1570, 51], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_eq_mul_prod_compl", "code": "@[to_additive]\ntheorem _root_.Fintype.prod_eq_mul_prod_compl [DecidableEq \u03b1] [Fintype \u03b1] (a : \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f i, f i = f a * \u220f i in {a}\u1d9c, f i", "start": [1574, 1], "end": [1577, 49], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_eq_prod_compl_mul", "code": "@[to_additive]\ntheorem _root_.Fintype.prod_eq_prod_compl_mul [DecidableEq \u03b1] [Fintype \u03b1] (a : \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f i, f i = (\u220f i in {a}\u1d9c, f i) * f a", "start": [1581, 1], "end": [1584, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.dvd_prod_of_mem", "code": "theorem dvd_prod_of_mem (f : \u03b1 \u2192 \u03b2) {a : \u03b1} {s : Finset \u03b1} (ha : a \u2208 s) : f a \u2223 \u220f i in s, f i", "start": [1588, 1], "end": [1591, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_partition", "code": "@[to_additive \"A sum can be partitioned into a sum of sums, each equivalent under a setoid.\"]\ntheorem prod_partition (R : Setoid \u03b1) [DecidableRel R.r] :\n    \u220f x in s, f x = \u220f xbar in s.image Quotient.mk'', \u220f y in s.filter (\u27e6\u00b7\u27e7 = xbar), f y", "start": [1594, 1], "end": [1599, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_cancels_of_partition_cancels", "code": "@[to_additive \"If we can partition a sum into subsets that cancel out, then the whole sum cancels.\"]\ntheorem prod_cancels_of_partition_cancels (R : Setoid \u03b1) [DecidableRel R.r]\n    (h : \u2200 x \u2208 s, \u220f a in s.filter fun y => y \u2248 x, f a = 1) : \u220f x in s, f x = 1", "start": [1603, 1], "end": [1611, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_update_of_not_mem", "code": "@[to_additive]\ntheorem prod_update_of_not_mem [DecidableEq \u03b1] {s : Finset \u03b1} {i : \u03b1} (h : i \u2209 s) (f : \u03b1 \u2192 \u03b2)\n    (b : \u03b2) : \u220f x in s, Function.update f i b x = \u220f x in s, f x", "start": [1615, 1], "end": [1623, 14], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_update_of_mem", "code": "@[to_additive]\ntheorem prod_update_of_mem [DecidableEq \u03b1] {s : Finset \u03b1} {i : \u03b1} (h : i \u2208 s) (f : \u03b1 \u2192 \u03b2) (b : \u03b2) :\n    \u220f x in s, Function.update f i b x = b * \u220f x in s \\ singleton i, f x", "start": [1627, 1], "end": [1631, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_card_le_one_of_prod_eq", "code": "@[to_additive eq_of_card_le_one_of_sum_eq \"If a sum of a `Finset` of size at most 1 has a given\nvalue, so do the terms in that sum.\"]\ntheorem eq_of_card_le_one_of_prod_eq {s : Finset \u03b1} (hc : s.card \u2264 1) {f : \u03b1 \u2192 \u03b2} {b : \u03b2}\n    (h : \u220f x in s, f x = b) : \u2200 x \u2208 s, f x = b", "start": [1635, 1], "end": [1651, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_prod_erase", "code": "@[to_additive \"Taking a sum over `s : Finset \u03b1` is the same as adding the value on a single element\n`f a` to the sum over `s.erase a`.\n\nSee `Multiset.sum_map_erase` for the `Multiset` version.\"]\ntheorem mul_prod_erase [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) {a : \u03b1} (h : a \u2208 s) :\n    (f a * \u220f x in s.erase a, f x) = \u220f x in s, f x", "start": [1655, 1], "end": [1665, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_erase_mul", "code": "@[to_additive \"A variant of `Finset.add_sum_erase` with the addition swapped.\"]\ntheorem prod_erase_mul [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) {a : \u03b1} (h : a \u2208 s) :\n    (\u220f x in s.erase a, f x) * f a = \u220f x in s, f x", "start": [1669, 1], "end": [1672, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_erase", "code": "@[to_additive \"If a function applied at a point is 0, a sum is unchanged by\nremoving that point, if present, from a `Finset`.\"]\ntheorem prod_erase [DecidableEq \u03b1] (s : Finset \u03b1) {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f a = 1) :\n    \u220f x in s.erase a, f x = \u220f x in s, f x", "start": [1676, 1], "end": [1685, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ite_one", "code": "@[to_additive \"See also `Finset.sum_boole`.\"]\ntheorem prod_ite_one {f : \u03b1 \u2192 Prop} [DecidablePred f] (hf : (s : Set \u03b1).PairwiseDisjoint f)\n    (a : \u03b2) : (\u220f i in s, ite (f i) a 1) = ite (\u2203 i \u2208 s, f i) a 1", "start": [1689, 1], "end": [1699, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_erase_lt_of_one_lt", "code": "@[to_additive]\ntheorem prod_erase_lt_of_one_lt {\u03b3 : Type*} [DecidableEq \u03b1] [OrderedCommMonoid \u03b3]\n    [CovariantClass \u03b3 \u03b3 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {s : Finset \u03b1} {d : \u03b1} (hd : d \u2208 s) {f : \u03b1 \u2192 \u03b3}\n    (hdf : 1 < f d) : \u220f m : \u03b1 in s.erase d, f m < \u220f m : \u03b1 in s, f m", "start": [1703, 1], "end": [1709, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_one_of_prod_eq_one", "code": "@[to_additive \"If a sum is 0 and the function is 0 except possibly at one\npoint, it is 0 everywhere on the `Finset`.\"]\ntheorem eq_one_of_prod_eq_one {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (hp : \u220f x in s, f x = 1)\n    (h1 : \u2200 x \u2208 s, x \u2260 a \u2192 f x = 1) : \u2200 x \u2208 s, f x = 1", "start": [1713, 1], "end": [1727, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pow_boole", "code": "@[to_additive sum_boole_nsmul]\ntheorem prod_pow_boole [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (\u220f x in s, f x ^ ite (a = x) 1 0) = ite (a \u2208 s) (f a) 1", "start": [1731, 1], "end": [1733, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dvd_prod_of_dvd", "code": "theorem prod_dvd_prod_of_dvd {S : Finset \u03b1} (g1 g2 : \u03b1 \u2192 \u03b2) (h : \u2200 a \u2208 S, g1 a \u2223 g2 a) :\n    S.prod g1 \u2223 S.prod g2", "start": [1736, 1], "end": [1742, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dvd_prod_of_subset", "code": "theorem prod_dvd_prod_of_subset {\u03b9 M : Type*} [CommMonoid M] (s t : Finset \u03b9) (f : \u03b9 \u2192 M)\n    (h : s \u2286 t) : (\u220f i in s, f i) \u2223 \u220f i in t, f i", "start": [1745, 1], "end": [1747, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_add_prod_eq", "code": "theorem prod_add_prod_eq [CommSemiring \u03b2] {s : Finset \u03b1} {i : \u03b1} {f g h : \u03b1 \u2192 \u03b2} (hi : i \u2208 s)\n    (h1 : g i + h i = f i) (h2 : \u2200 j \u2208 s, j \u2260 i \u2192 g j = f j) (h3 : \u2200 j \u2208 s, j \u2260 i \u2192 h j = f j) :\n    (\u220f i in s, g i) + \u220f i in s, h i = \u220f i in s, f i", "start": [1752, 1], "end": [1759, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_sum_ones", "code": "theorem card_eq_sum_ones (s : Finset \u03b1) : s.card = \u2211 x in s, 1", "start": [1762, 1], "end": [1763, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_const_nat", "code": "theorem sum_const_nat {m : \u2115} {f : \u03b1 \u2192 \u2115} (h\u2081 : \u2200 x \u2208 s, f x = m) :\n    \u2211 x in s, f x = card s * m", "start": [1766, 1], "end": [1769, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_boole", "code": "@[simp]\ntheorem sum_boole {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} [NonAssocSemiring \u03b2] {hp : DecidablePred p} :\n    (\u2211 x in s, if p x then (1 : \u03b2) else (0 : \u03b2)) = (s.filter p).card", "start": [1772, 1], "end": [1776, 53], "kind": "commanddeclaration"}, {"full_name": "Commute.sum_right", "code": "theorem _root_.Commute.sum_right [NonUnitalNonAssocSemiring \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (b : \u03b2)\n    (h : \u2200 i \u2208 s, Commute b (f i)) : Commute b (\u2211 i in s, f i)", "start": [1779, 1], "end": [1783, 17], "kind": "commanddeclaration"}, {"full_name": "Commute.sum_left", "code": "theorem _root_.Commute.sum_left [NonUnitalNonAssocSemiring \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (b : \u03b2)\n    (h : \u2200 i \u2208 s, Commute (f i) b) : Commute (\u2211 i in s, f i) b", "start": [1786, 1], "end": [1788, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.op_sum", "code": "@[simp]\ntheorem op_sum [AddCommMonoid \u03b2] {s : Finset \u03b1} (f : \u03b1 \u2192 \u03b2) :\n    op (\u2211 x in s, f x) = \u2211 x in s, op (f x)", "start": [1795, 1], "end": [1799, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.unop_sum", "code": "@[simp]\ntheorem unop_sum [AddCommMonoid \u03b2] {s : Finset \u03b1} (f : \u03b1 \u2192 \u03b2\u1d50\u1d52\u1d56) :\n    unop (\u2211 x in s, f x) = \u2211 x in s, unop (f x)", "start": [1802, 1], "end": [1805, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_inv_distrib", "code": "@[to_additive (attr := simp)]\ntheorem prod_inv_distrib : (\u220f x in s, (f x)\u207b\u00b9) = (\u220f x in s, f x)\u207b\u00b9", "start": [1814, 1], "end": [1816, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_div_distrib", "code": "@[to_additive (attr := simp)]\ntheorem prod_div_distrib : \u220f x in s, f x / g x = (\u220f x in s, f x) / \u220f x in s, g x", "start": [1820, 1], "end": [1822, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_zpow", "code": "@[to_additive]\ntheorem prod_zpow (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) (n : \u2124) : \u220f a in s, f a ^ n = (\u220f a in s, f a) ^ n", "start": [1826, 1], "end": [1828, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sdiff_eq_div", "code": "@[to_additive (attr := simp)]\ntheorem prod_sdiff_eq_div (h : s\u2081 \u2286 s\u2082) :\n    \u220f x in s\u2082 \\ s\u2081, f x = (\u220f x in s\u2082, f x) / \u220f x in s\u2081, f x", "start": [1838, 1], "end": [1841, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sdiff_div_prod_sdiff", "code": "@[to_additive]\ntheorem prod_sdiff_div_prod_sdiff :\n    (\u220f x in s\u2082 \\ s\u2081, f x) / \u220f x in s\u2081 \\ s\u2082, f x = (\u220f x in s\u2082, f x) / \u220f x in s\u2081, f x", "start": [1845, 1], "end": [1848, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_erase_eq_div", "code": "@[to_additive (attr := simp)]\ntheorem prod_erase_eq_div {a : \u03b1} (h : a \u2208 s) :\n    \u220f x in s.erase a, f x = (\u220f x in s, f x) / f a", "start": [1852, 1], "end": [1855, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.card_sigma", "code": "@[simp]\ntheorem card_sigma {\u03c3 : \u03b1 \u2192 Type*} (s : Finset \u03b1) (t : \u2200 a, Finset (\u03c3 a)) :\n    card (s.sigma t) = \u2211 a in s, card (t a)", "start": [1861, 1], "end": [1864, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.card_disjiUnion", "code": "@[simp]\ntheorem card_disjiUnion (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) (h) :\n    (s.disjiUnion t h).card = s.sum fun i => (t i).card", "start": [1867, 1], "end": [1870, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.card_biUnion", "code": "theorem card_biUnion [DecidableEq \u03b2] {s : Finset \u03b1} {t : \u03b1 \u2192 Finset \u03b2}\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2260 y \u2192 Disjoint (t x) (t y)) :\n    (s.biUnion t).card = \u2211 u in s, card (t u)", "start": [1873, 1], "end": [1879, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.card_biUnion_le", "code": "theorem card_biUnion_le [DecidableEq \u03b2] {s : Finset \u03b1} {t : \u03b1 \u2192 Finset \u03b2} :\n    (s.biUnion t).card \u2264 \u2211 a in s, (t a).card", "start": [1882, 1], "end": [1889, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_sum_card_fiberwise", "code": "theorem card_eq_sum_card_fiberwise [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2}\n    (H : \u2200 x \u2208 s, f x \u2208 t) : s.card = \u2211 a in t, (s.filter fun x => f x = a).card", "start": [1892, 1], "end": [1894, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.card_eq_sum_card_image", "code": "theorem card_eq_sum_card_image [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) :\n    s.card = \u2211 a in s.image f, (s.filter fun x => f x = a).card", "start": [1897, 1], "end": [1899, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_sum", "code": "theorem mem_sum {f : \u03b1 \u2192 Multiset \u03b2} (s : Finset \u03b1) (b : \u03b2) :\n    (b \u2208 \u2211 x in s, f x) \u2194 \u2203 a \u2208 s, b \u2208 f a", "start": [1902, 1], "end": [1907, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_zero", "code": "theorem prod_eq_zero (ha : a \u2208 s) (h : f a = 0) : \u220f x in s, f x = 0", "start": [1914, 1], "end": [1916, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_boole", "code": "theorem prod_boole {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    (\u220f i in s, ite (p i) (1 : \u03b2) (0 : \u03b2)) = ite (\u2200 i \u2208 s, p i) 1 0", "start": [1919, 1], "end": [1928, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_zero_iff", "code": "theorem prod_eq_zero_iff : \u220f x in s, f x = 0 \u2194 \u2203 a \u2208 s, f a = 0", "start": [1933, 1], "end": [1937, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_ne_zero_iff", "code": "theorem prod_ne_zero_iff : \u220f x in s, f x \u2260 0 \u2194 \u2200 a \u2208 s, f a \u2260 0", "start": [1940, 1], "end": [1942, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_unique_nonempty", "code": "@[to_additive]\ntheorem prod_unique_nonempty {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] [Unique \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (h : s.Nonempty) : \u220f x in s, f x = f default", "start": [1947, 1], "end": [1950, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_nat_mod", "code": "theorem sum_nat_mod (s : Finset \u03b1) (n : \u2115) (f : \u03b1 \u2192 \u2115) :\n    (\u2211 i in s, f i) % n = (\u2211 i in s, f i % n) % n", "start": [1954, 1], "end": [1956, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_nat_mod", "code": "theorem prod_nat_mod (s : Finset \u03b1) (n : \u2115) (f : \u03b1 \u2192 \u2115) :\n    (\u220f i in s, f i) % n = (\u220f i in s, f i % n) % n", "start": [1959, 1], "end": [1961, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_int_mod", "code": "theorem sum_int_mod (s : Finset \u03b1) (n : \u2124) (f : \u03b1 \u2192 \u2124) :\n    (\u2211 i in s, f i) % n = (\u2211 i in s, f i % n) % n", "start": [1964, 1], "end": [1966, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_int_mod", "code": "theorem prod_int_mod (s : Finset \u03b1) (n : \u2124) (f : \u03b1 \u2192 \u2124) :\n    (\u220f i in s, f i) % n = (\u220f i in s, f i % n) % n", "start": [1969, 1], "end": [1971, 82], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_bijective", "code": "@[to_additive \"`Fintype.sum_equiv` is a variant of `Finset.sum_bij` that accepts\n`Function.bijective`.\n\nSee `Function.bijective.sum_comp` for a version without `h`. \"]\ntheorem prod_bijective {\u03b1 \u03b2 M : Type*} [Fintype \u03b1] [Fintype \u03b2] [CommMonoid M] (e : \u03b1 \u2192 \u03b2)\n    (he : Function.Bijective e) (f : \u03b1 \u2192 M) (g : \u03b2 \u2192 M) (h : \u2200 x, f x = g (e x)) :\n    \u220f x : \u03b1, f x = \u220f x : \u03b2, g x", "start": [1980, 1], "end": [1992, 59], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_equiv", "code": "@[to_additive \"`Fintype.sum_equiv` is a specialization of `Finset.sum_bij` that\nautomatically fills in most arguments.\n\nSee `Equiv.sum_comp` for a version without `h`.\"]\ntheorem prod_equiv {\u03b1 \u03b2 M : Type*} [Fintype \u03b1] [Fintype \u03b2] [CommMonoid M] (e : \u03b1 \u2243 \u03b2) (f : \u03b1 \u2192 M)\n    (g : \u03b2 \u2192 M) (h : \u2200 x, f x = g (e x)) : \u220f x : \u03b1, f x = \u220f x : \u03b2, g x", "start": [1996, 1], "end": [2007, 37], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_unique", "code": "@[to_additive]\ntheorem prod_unique {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] [Unique \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    \u220f x : \u03b1, f x = f default", "start": [2011, 1], "end": [2013, 68], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_empty", "code": "@[to_additive]\ntheorem prod_empty {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] [IsEmpty \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    \u220f x : \u03b1, f x = 1", "start": [2017, 1], "end": [2020, 25], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_subsingleton", "code": "@[to_additive]\ntheorem prod_subsingleton {\u03b1 \u03b2 : Type*} [CommMonoid \u03b2] [Subsingleton \u03b1] [Fintype \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (a : \u03b1) : \u220f x : \u03b1, f x = f a", "start": [2024, 1], "end": [2028, 50], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_subtype_mul_prod_subtype", "code": "@[to_additive]\ntheorem prod_subtype_mul_prod_subtype {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [CommMonoid \u03b2] (p : \u03b1 \u2192 Prop)\n    (f : \u03b1 \u2192 \u03b2) [DecidablePred p] :\n    (\u220f i : { x // p x }, f i) * \u220f i : { x // \u00acp x }, f i = \u220f i, f i", "start": [2032, 1], "end": [2041, 11], "kind": "commanddeclaration"}, {"full_name": "List.prod_toFinset", "code": "@[to_additive]\ntheorem prod_toFinset {M : Type*} [DecidableEq \u03b1] [CommMonoid M] (f : \u03b1 \u2192 M) :\n    \u2200 {l : List \u03b1} (_hl : l.Nodup), l.toFinset.prod f = (l.map f).prod", "start": [2049, 1], "end": [2055, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_list_sum_left", "code": "theorem disjoint_list_sum_left {a : Multiset \u03b1} {l : List (Multiset \u03b1)} :\n    Multiset.Disjoint l.sum a \u2194 \u2200 b \u2208 l, Multiset.Disjoint b a", "start": [2063, 1], "end": [2068, 48], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_list_sum_right", "code": "theorem disjoint_list_sum_right {a : Multiset \u03b1} {l : List (Multiset \u03b1)} :\n    Multiset.Disjoint a l.sum \u2194 \u2200 b \u2208 l, Multiset.Disjoint a b", "start": [2071, 1], "end": [2073, 63], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_sum_left", "code": "theorem disjoint_sum_left {a : Multiset \u03b1} {i : Multiset (Multiset \u03b1)} :\n    Multiset.Disjoint i.sum a \u2194 \u2200 b \u2208 i, Multiset.Disjoint b a", "start": [2076, 1], "end": [2080, 33], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_sum_right", "code": "theorem disjoint_sum_right {a : Multiset \u03b1} {i : Multiset (Multiset \u03b1)} :\n    Multiset.Disjoint a i.sum \u2194 \u2200 b \u2208 i, Multiset.Disjoint a b", "start": [2083, 1], "end": [2085, 58], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_finset_sum_left", "code": "theorem disjoint_finset_sum_left {\u03b2 : Type*} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} {a : Multiset \u03b1} :\n    Multiset.Disjoint (i.sum f) a \u2194 \u2200 b \u2208 i, Multiset.Disjoint (f b) a", "start": [2088, 1], "end": [2091, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.disjoint_finset_sum_right", "code": "theorem disjoint_finset_sum_right {\u03b2 : Type*} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1}\n    {a : Multiset \u03b1} : Multiset.Disjoint a (i.sum f) \u2194 \u2200 b \u2208 i, Multiset.Disjoint a (f b)", "start": [2094, 1], "end": [2096, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_eq_union_left_of_le", "code": "theorem add_eq_union_left_of_le {x y z : Multiset \u03b1} (h : y \u2264 x) :\n    z + x = z \u222a y \u2194 z.Disjoint x \u2227 x = y", "start": [2101, 1], "end": [2111, 13], "kind": "commanddeclaration"}, {"full_name": "Multiset.add_eq_union_right_of_le", "code": "theorem add_eq_union_right_of_le {x y z : Multiset \u03b1} (h : z \u2264 y) :\n    x + y = x \u222a z \u2194 y = z \u2227 x.Disjoint y", "start": [2114, 1], "end": [2116, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.finset_sum_eq_sup_iff_disjoint", "code": "theorem finset_sum_eq_sup_iff_disjoint {\u03b2 : Type*} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} :\n    i.sum f = i.sup f \u2194\n      \u2200 (x) (_ : x \u2208 i) (y) (_ : y \u2208 i), x \u2260 y \u2192 Multiset.Disjoint (f x) (f y)", "start": [2119, 1], "end": [2132, 98], "kind": "commanddeclaration"}, {"full_name": "Multiset.sup_powerset_len", "code": "theorem sup_powerset_len {\u03b1 : Type*} [DecidableEq \u03b1] (x : Multiset \u03b1) :\n    (Finset.sup (Finset.range (card x + 1)) fun k => x.powersetCard k) = x.powerset", "start": [2135, 1], "end": [2140, 101], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_sum_count_eq", "code": "@[simp]\ntheorem toFinset_sum_count_eq (s : Multiset \u03b1) : \u2211 a in s.toFinset, s.count a = card s", "start": [2143, 1], "end": [2149, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.count_sum'", "code": "theorem count_sum' {s : Finset \u03b2} {a : \u03b1} {f : \u03b2 \u2192 Multiset \u03b1} :\n    count a (\u2211 x in s, f x) = \u2211 x in s, count a (f x)", "start": [2152, 1], "end": [2155, 17], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_sum_count_nsmul_eq", "code": "@[simp]\ntheorem toFinset_sum_count_nsmul_eq (s : Multiset \u03b1) :\n    \u2211 a in s.toFinset, s.count a \u2022 {a} = s", "start": [2158, 1], "end": [2161, 67], "kind": "commanddeclaration"}, {"full_name": "Multiset.exists_smul_of_dvd_count", "code": "theorem exists_smul_of_dvd_count (s : Multiset \u03b1) {k : \u2115}\n    (h : \u2200 a : \u03b1, a \u2208 s \u2192 k \u2223 Multiset.count a s) : \u2203 u : Multiset \u03b1, s = k \u2022 u", "start": [2164, 1], "end": [2173, 59], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinset_prod_dvd_prod", "code": "theorem toFinset_prod_dvd_prod [CommMonoid \u03b1] (S : Multiset \u03b1) : S.toFinset.prod id \u2223 S.prod", "start": [2176, 1], "end": [2179, 29], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_sum", "code": "@[to_additive]\ntheorem prod_sum {\u03b1 : Type*} {\u03b9 : Type*} [CommMonoid \u03b1] (f : \u03b9 \u2192 Multiset \u03b1) (s : Finset \u03b9) :\n    (\u2211 x in s, f x).prod = \u220f x in s, (f x).prod", "start": [2182, 1], "end": [2188, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_list_sum", "code": "@[simp, norm_cast]\ntheorem cast_list_sum [AddMonoidWithOne \u03b2] (s : List \u2115) : (\u2191s.sum : \u03b2) = (s.map (\u2191)).sum", "start": [2196, 1], "end": [2198, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_list_prod", "code": "@[simp, norm_cast]\ntheorem cast_list_prod [Semiring \u03b2] (s : List \u2115) : (\u2191s.prod : \u03b2) = (s.map (\u2191)).prod", "start": [2201, 1], "end": [2203, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_multiset_sum", "code": "@[simp, norm_cast]\ntheorem cast_multiset_sum [AddCommMonoidWithOne \u03b2] (s : Multiset \u2115) :\n    (\u2191s.sum : \u03b2) = (s.map (\u2191)).sum", "start": [2206, 1], "end": [2209, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_multiset_prod", "code": "@[simp, norm_cast]\ntheorem cast_multiset_prod [CommSemiring \u03b2] (s : Multiset \u2115) : (\u2191s.prod : \u03b2) = (s.map (\u2191)).prod", "start": [2212, 1], "end": [2214, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_sum", "code": "@[simp, norm_cast]\ntheorem cast_sum [AddCommMonoidWithOne \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) :\n    \u2191(\u2211 x in s, f x : \u2115) = \u2211 x in s, (f x : \u03b2)", "start": [2217, 1], "end": [2220, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_prod", "code": "@[simp, norm_cast]\ntheorem cast_prod [CommSemiring \u03b2] (f : \u03b1 \u2192 \u2115) (s : Finset \u03b1) :\n    (\u2191(\u220f i in s, f i) : \u03b2) = \u220f i in s, (f i : \u03b2)", "start": [2223, 1], "end": [2226, 31], "kind": "commanddeclaration"}, {"full_name": "Int.cast_list_sum", "code": "@[simp, norm_cast]\ntheorem cast_list_sum [AddGroupWithOne \u03b2] (s : List \u2124) : (\u2191s.sum : \u03b2) = (s.map (\u2191)).sum", "start": [2233, 1], "end": [2235, 32], "kind": "commanddeclaration"}, {"full_name": "Int.cast_list_prod", "code": "@[simp, norm_cast]\ntheorem cast_list_prod [Ring \u03b2] (s : List \u2124) : (\u2191s.prod : \u03b2) = (s.map (\u2191)).prod", "start": [2238, 1], "end": [2240, 34], "kind": "commanddeclaration"}, {"full_name": "Int.cast_multiset_sum", "code": "@[simp, norm_cast]\ntheorem cast_multiset_sum [AddCommGroupWithOne \u03b2] (s : Multiset \u2124) :\n    (\u2191s.sum : \u03b2) = (s.map (\u2191)).sum", "start": [2243, 1], "end": [2246, 36], "kind": "commanddeclaration"}, {"full_name": "Int.cast_multiset_prod", "code": "@[simp, norm_cast]\ntheorem cast_multiset_prod {R : Type*} [CommRing R] (s : Multiset \u2124) :\n    (\u2191s.prod : R) = (s.map (\u2191)).prod", "start": [2249, 1], "end": [2252, 38], "kind": "commanddeclaration"}, {"full_name": "Int.cast_sum", "code": "@[simp, norm_cast]\ntheorem cast_sum [AddCommGroupWithOne \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u2124) :\n    \u2191(\u2211 x in s, f x : \u2124) = \u2211 x in s, (f x : \u03b2)", "start": [2255, 1], "end": [2258, 29], "kind": "commanddeclaration"}, {"full_name": "Int.cast_prod", "code": "@[simp, norm_cast]\ntheorem cast_prod {R : Type*} [CommRing R] (f : \u03b1 \u2192 \u2124) (s : Finset \u03b1) :\n    (\u2191(\u220f i in s, f i) : R) = \u220f i in s, (f i : R)", "start": [2261, 1], "end": [2264, 35], "kind": "commanddeclaration"}, {"full_name": "Units.coe_prod", "code": "@[simp, norm_cast]\ntheorem Units.coe_prod {M : Type*} [CommMonoid M] (f : \u03b1 \u2192 M\u02e3) (s : Finset \u03b1) :\n    (\u2191(\u220f i in s, f i) : M) = \u220f i in s, (f i : M)", "start": [2269, 1], "end": [2272, 32], "kind": "commanddeclaration"}, {"full_name": "Units.mk0_prod", "code": "theorem Units.mk0_prod [CommGroupWithZero \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (h) :\n    Units.mk0 (\u220f b in s, f b) h =\n      \u220f b in s.attach, Units.mk0 (f b) fun hh => h (Finset.prod_eq_zero b.2 hh)", "start": [2275, 1], "end": [2278, 63], "kind": "commanddeclaration"}, {"full_name": "nat_abs_sum_le", "code": "theorem nat_abs_sum_le {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 \u2124) :\n    (\u2211 i in s, f i).natAbs \u2264 \u2211 i in s, (f i).natAbs", "start": [2281, 1], "end": [2287, 65], "kind": "commanddeclaration"}, {"full_name": "ofMul_list_prod", "code": "@[simp]\ntheorem ofMul_list_prod (s : List \u03b1) : ofMul s.prod = (s.map ofMul).sum", "start": [2299, 1], "end": [2300, 96], "kind": "commanddeclaration"}, {"full_name": "toMul_list_sum", "code": "@[simp]\ntheorem toMul_list_sum (s : List (Additive \u03b1)) : toMul s.sum = (s.map toMul).prod", "start": [2303, 1], "end": [2305, 27], "kind": "commanddeclaration"}, {"full_name": "ofAdd_list_prod", "code": "@[simp]\ntheorem ofAdd_list_prod (s : List \u03b1) : ofAdd s.sum = (s.map ofAdd).prod", "start": [2314, 1], "end": [2315, 96], "kind": "commanddeclaration"}, {"full_name": "toAdd_list_sum", "code": "@[simp]\ntheorem toAdd_list_sum (s : List (Multiplicative \u03b1)) : toAdd s.prod = (s.map toAdd).sum", "start": [2318, 1], "end": [2320, 27], "kind": "commanddeclaration"}, {"full_name": "ofMul_multiset_prod", "code": "@[simp]\ntheorem ofMul_multiset_prod (s : Multiset \u03b1) : ofMul s.prod = (s.map ofMul).sum", "start": [2329, 1], "end": [2331, 20], "kind": "commanddeclaration"}, {"full_name": "toMul_multiset_sum", "code": "@[simp]\ntheorem toMul_multiset_sum (s : Multiset (Additive \u03b1)) : toMul s.sum = (s.map toMul).prod", "start": [2334, 1], "end": [2336, 27], "kind": "commanddeclaration"}, {"full_name": "ofMul_prod", "code": "@[simp]\ntheorem ofMul_prod (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : ofMul (\u220f i in s, f i) = \u2211 i in s, ofMul (f i)", "start": [2339, 1], "end": [2341, 6], "kind": "commanddeclaration"}, {"full_name": "toMul_sum", "code": "@[simp]\ntheorem toMul_sum (s : Finset \u03b9) (f : \u03b9 \u2192 Additive \u03b1) :\n    toMul (\u2211 i in s, f i) = \u220f i in s, toMul (f i)", "start": [2344, 1], "end": [2347, 6], "kind": "commanddeclaration"}, {"full_name": "ofAdd_multiset_prod", "code": "@[simp]\ntheorem ofAdd_multiset_prod (s : Multiset \u03b1) : ofAdd s.sum = (s.map ofAdd).prod", "start": [2356, 1], "end": [2358, 20], "kind": "commanddeclaration"}, {"full_name": "toAdd_multiset_sum", "code": "@[simp]\ntheorem toAdd_multiset_sum (s : Multiset (Multiplicative \u03b1)) :\n    toAdd s.prod = (s.map toAdd).sum", "start": [2361, 1], "end": [2364, 27], "kind": "commanddeclaration"}, {"full_name": "ofAdd_sum", "code": "@[simp]\ntheorem ofAdd_sum (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : ofAdd (\u2211 i in s, f i) = \u220f i in s, ofAdd (f i)", "start": [2367, 1], "end": [2369, 6], "kind": "commanddeclaration"}, {"full_name": "toAdd_prod", "code": "@[simp]\ntheorem toAdd_prod (s : Finset \u03b9) (f : \u03b9 \u2192 Multiplicative \u03b1) :\n    toAdd (\u220f i in s, f i) = \u2211 i in s, toAdd (f i)", "start": [2372, 1], "end": [2375, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/LatticeIntervals.lean", "imports": ["Mathlib/Order/Bounds/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Ico.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a b : \u03b1} : SemilatticeInf (Ico a b) :=\n  Subtype.semilatticeInf fun _ _ hx hy => \u27e8le_inf hx.1 hy.1, lt_of_le_of_lt inf_le_left hx.2\u27e9", "start": [37, 1], "end": [38, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Ico.orderBot", "code": "@[reducible]\nprotected def orderBot [PartialOrder \u03b1] {a b : \u03b1} (h : a < b) : OrderBot (Ico a b) :=\n  (isLeast_Ico h).orderBot", "start": [40, 1], "end": [43, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Iio.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a : \u03b1} : SemilatticeInf (Iio a) :=\n  Subtype.semilatticeInf fun _ _ hx _ => lt_of_le_of_lt inf_le_left hx", "start": [50, 1], "end": [51, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a b : \u03b1} : SemilatticeSup (Ioc a b) :=\n  Subtype.semilatticeSup fun _ _ hx hy => \u27e8lt_of_lt_of_le hx.1 le_sup_left, sup_le hx.2 hy.2\u27e9", "start": [57, 1], "end": [58, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc.orderTop", "code": "@[reducible]\nprotected def orderTop [PartialOrder \u03b1] {a b : \u03b1} (h : a < b) : OrderTop (Ioc a b) :=\n  (isGreatest_Ioc h).orderTop", "start": [60, 1], "end": [63, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a : \u03b1} : SemilatticeSup (Ioi a) :=\n  Subtype.semilatticeSup fun _ _ hx _ => lt_of_lt_of_le hx le_sup_left", "start": [70, 1], "end": [71, 71], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a : \u03b1} : SemilatticeInf (Iic a) :=\n  Subtype.semilatticeInf fun _ _ hx _ => le_trans inf_le_left hx", "start": [77, 1], "end": [78, 65], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a : \u03b1} : SemilatticeSup (Iic a) :=\n  Subtype.semilatticeSup fun _ _ hx hy => sup_le hx hy", "start": [80, 1], "end": [81, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.orderTop", "code": "instance orderTop [Preorder \u03b1] {a : \u03b1} :\n    OrderTop (Iic a) where\n  top := \u27e8a, le_refl a\u27e9\n  le_top x := x.prop", "start": [86, 1], "end": [89, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.coe_top", "code": "@[simp]\ntheorem coe_top [Preorder \u03b1] {a : \u03b1} : (\u22a4 : Iic a) = a", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.orderBot", "code": "instance orderBot [Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1} :\n    OrderBot (Iic a) where\n  bot := \u27e8\u22a5, bot_le\u27e9\n  bot_le := fun \u27e8_, _\u27e9 => Subtype.mk_le_mk.2 bot_le", "start": [96, 1], "end": [99, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.coe_bot", "code": "@[simp]\ntheorem coe_bot [Preorder \u03b1] [OrderBot \u03b1] {a : \u03b1} : (\u22a5 : Iic a) = (\u22a5 : \u03b1)", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a : \u03b1} : SemilatticeInf (Ici a) :=\n  Subtype.semilatticeInf fun _ _ hx hy => le_inf hx hy", "start": [113, 1], "end": [114, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a : \u03b1} : SemilatticeSup (Ici a) :=\n  Subtype.semilatticeSup fun _ _ hx _ => le_trans hx le_sup_left", "start": [116, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.lattice", "code": "instance lattice [Lattice \u03b1] {a : \u03b1} : Lattice (Ici a) :=\n  { Ici.semilatticeInf, Ici.semilatticeSup with }", "start": [119, 1], "end": [120, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.distribLattice", "code": "instance distribLattice [DistribLattice \u03b1] {a : \u03b1} : DistribLattice (Ici a) :=\n  { Ici.lattice with le_sup_inf := fun _ _ _ => le_sup_inf }", "start": [122, 1], "end": [123, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.orderBot", "code": "instance orderBot [Preorder \u03b1] {a : \u03b1} :\n    OrderBot (Ici a) where\n  bot := \u27e8a, le_refl a\u27e9\n  bot_le x := x.prop", "start": [125, 1], "end": [128, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.coe_bot", "code": "@[simp]\ntheorem coe_bot [Preorder \u03b1] {a : \u03b1} : \u2191(\u22a5 : Ici a) = a", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.orderTop", "code": "instance orderTop [Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1} :\n    OrderTop (Ici a) where\n  top := \u27e8\u22a4, le_top\u27e9\n  le_top := fun \u27e8_, _\u27e9 => Subtype.mk_le_mk.2 le_top", "start": [135, 1], "end": [138, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.coe_top", "code": "@[simp]\ntheorem coe_top [Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1} : \u2191(\u22a4 : Ici a) = (\u22a4 : \u03b1)", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.boundedOrder", "code": "instance boundedOrder [Preorder \u03b1] [OrderTop \u03b1] {a : \u03b1} : BoundedOrder (Ici a) :=\n  { Ici.orderTop, Ici.orderBot with }", "start": [145, 1], "end": [146, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a b : \u03b1} : SemilatticeInf (Icc a b) :=\n  Subtype.semilatticeInf fun _ _ hx hy => \u27e8le_inf hx.1 hy.1, le_trans inf_le_left hx.2\u27e9", "start": [152, 1], "end": [153, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a b : \u03b1} : SemilatticeSup (Icc a b) :=\n  Subtype.semilatticeSup fun _ _ hx hy => \u27e8le_trans hx.1 le_sup_left, sup_le hx.2 hy.2\u27e9", "start": [155, 1], "end": [156, 88], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.lattice", "code": "instance lattice [Lattice \u03b1] {a b : \u03b1} : Lattice (Icc a b) :=\n  { Icc.semilatticeInf, Icc.semilatticeSup with }", "start": [158, 1], "end": [159, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.orderBot", "code": "@[reducible]\nprotected def orderBot [Preorder \u03b1] {a b : \u03b1} (h : a \u2264 b) : OrderBot (Icc a b) :=\n  (isLeast_Icc h).orderBot", "start": [161, 1], "end": [164, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.orderTop", "code": "@[reducible]\nprotected def orderTop [Preorder \u03b1] {a b : \u03b1} (h : a \u2264 b) : OrderTop (Icc a b) :=\n  (isGreatest_Icc h).orderTop", "start": [167, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.boundedOrder", "code": "@[reducible]\nprotected def boundedOrder [Preorder \u03b1] {a b : \u03b1} (h : a \u2264 b) : BoundedOrder (Icc a b) :=\n  { Icc.orderTop h, Icc.orderBot h with }", "start": [173, 1], "end": [176, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Cover.lean", "imports": ["Mathlib/Data/Set/Intervals/OrdConnected.lean", "Mathlib/Order/Antisymmetrization.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Wcovby", "code": "def Wcovby (a b : \u03b1) : Prop :=\n  a \u2264 b \u2227 \u2200 \u2983c\u2984, a < c \u2192 \u00acc < b", "start": [36, 1], "end": [40, 32], "kind": "commanddeclaration"}, {"full_name": "Wcovby.le", "code": "theorem Wcovby.le (h : a \u2a7f b) : a \u2264 b", "start": [46, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Wcovby.refl", "code": "theorem Wcovby.refl (a : \u03b1) : a \u2a7f a", "start": [50, 1], "end": [51, 34], "kind": "commanddeclaration"}, {"full_name": "Wcovby.rfl", "code": "theorem Wcovby.rfl : a \u2a7f a", "start": [54, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "Eq.wcovby", "code": "protected theorem Eq.wcovby (h : a = b) : a \u2a7f b", "start": [58, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "wcovby_of_le_of_le", "code": "theorem wcovby_of_le_of_le (h1 : a \u2264 b) (h2 : b \u2264 a) : a \u2a7f b", "start": [62, 1], "end": [63, 51], "kind": "commanddeclaration"}, {"full_name": "LE.le.wcovby_of_le", "code": "alias LE.le.wcovby_of_le := wcovby_of_le_of_le", "start": [66, 1], "end": [66, 47], "kind": "stdtacticaliasalias"}, {"full_name": "AntisymmRel.wcovby", "code": "theorem AntisymmRel.wcovby (h : AntisymmRel (\u00b7 \u2264 \u00b7) a b) : a \u2a7f b", "start": [68, 1], "end": [69, 29], "kind": "commanddeclaration"}, {"full_name": "Wcovby.wcovby_iff_le", "code": "theorem Wcovby.wcovby_iff_le (hab : a \u2a7f b) : b \u2a7f a \u2194 b \u2264 a", "start": [72, 1], "end": [73, 50], "kind": "commanddeclaration"}, {"full_name": "wcovby_of_eq_or_eq", "code": "theorem wcovby_of_eq_or_eq (hab : a \u2264 b) (h : \u2200 c, a \u2264 c \u2192 c \u2264 b \u2192 c = a \u2228 c = b) : a \u2a7f b", "start": [76, 1], "end": [77, 60], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.trans_wcovby", "code": "theorem AntisymmRel.trans_wcovby (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) (hbc : b \u2a7f c) : a \u2a7f c", "start": [80, 1], "end": [81, 72], "kind": "commanddeclaration"}, {"full_name": "wcovby_congr_left", "code": "theorem wcovby_congr_left (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) : a \u2a7f c \u2194 b \u2a7f c", "start": [84, 1], "end": [85, 44], "kind": "commanddeclaration"}, {"full_name": "Wcovby.trans_antisymm_rel", "code": "theorem Wcovby.trans_antisymm_rel (hab : a \u2a7f b) (hbc : AntisymmRel (\u00b7 \u2264 \u00b7) b c) : a \u2a7f c", "start": [88, 1], "end": [89, 73], "kind": "commanddeclaration"}, {"full_name": "wcovby_congr_right", "code": "theorem wcovby_congr_right (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) : c \u2a7f a \u2194 c \u2a7f b", "start": [92, 1], "end": [93, 78], "kind": "commanddeclaration"}, {"full_name": "not_wcovby_iff", "code": "theorem not_wcovby_iff (h : a \u2264 b) : \u00aca \u2a7f b \u2194 \u2203 c, a < c \u2227 c < b", "start": [96, 1], "end": [98, 70], "kind": "commanddeclaration"}, {"full_name": "Wcovby.isRefl", "code": "instance Wcovby.isRefl : IsRefl \u03b1 (\u00b7 \u2a7f \u00b7) :=\n  \u27e8Wcovby.refl\u27e9", "start": [101, 1], "end": [102, 16], "kind": "commanddeclaration"}, {"full_name": "Wcovby.Ioo_eq", "code": "theorem Wcovby.Ioo_eq (h : a \u2a7f b) : Ioo a b = \u2205", "start": [105, 1], "end": [106, 58], "kind": "commanddeclaration"}, {"full_name": "wcovby_iff_Ioo_eq", "code": "theorem wcovby_iff_Ioo_eq : a \u2a7f b \u2194 a \u2264 b \u2227 Ioo a b = \u2205", "start": [109, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "Wcovby.of_le_of_le", "code": "lemma Wcovby.of_le_of_le (hac : a \u2a7f c) (hab : a \u2264 b) (hbc : b \u2264 c) : b \u2a7f c :=\n  \u27e8hbc, fun _x hbx hxc \u21a6 hac.2 (hab.trans_lt hbx) hxc\u27e9", "start": [113, 1], "end": [114, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Wcovby.of_le_of_le'", "code": "lemma Wcovby.of_le_of_le' (hac : a \u2a7f c) (hab : a \u2264 b) (hbc : b \u2264 c) : a \u2a7f b :=\n  \u27e8hab, fun _x hax hxb \u21a6 hac.2 hax <| hxb.trans_le hbc\u27e9", "start": [116, 1], "end": [117, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Wcovby.of_image", "code": "theorem Wcovby.of_image (f : \u03b1 \u21aao \u03b2) (h : f a \u2a7f f b) : a \u2a7f b", "start": [119, 1], "end": [120, 90], "kind": "commanddeclaration"}, {"full_name": "Wcovby.image", "code": "theorem Wcovby.image (f : \u03b1 \u21aao \u03b2) (hab : a \u2a7f b) (h : (range f).OrdConnected) : f a \u2a7f f b", "start": [123, 1], "end": [127, 20], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.apply_wcovby_apply_iff", "code": "theorem Set.OrdConnected.apply_wcovby_apply_iff (f : \u03b1 \u21aao \u03b2) (h : (range f).OrdConnected) :\n    f a \u2a7f f b \u2194 a \u2a7f b", "start": [130, 1], "end": [132, 54], "kind": "commanddeclaration"}, {"full_name": "apply_wcovby_apply_iff", "code": "@[simp]\ntheorem apply_wcovby_apply_iff {E : Type*} [OrderIsoClass E \u03b1 \u03b2] (e : E) : e a \u2a7f e b \u2194 a \u2a7f b", "start": [135, 1], "end": [137, 83], "kind": "commanddeclaration"}, {"full_name": "toDual_wcovby_toDual_iff", "code": "@[simp]\ntheorem toDual_wcovby_toDual_iff : toDual b \u2a7f toDual a \u2194 a \u2a7f b", "start": [140, 1], "end": [142, 57], "kind": "commanddeclaration"}, {"full_name": "ofDual_wcovby_ofDual_iff", "code": "@[simp]\ntheorem ofDual_wcovby_ofDual_iff {a b : \u03b1\u1d52\u1d48} : ofDual a \u2a7f ofDual b \u2194 b \u2a7f a", "start": [145, 1], "end": [147, 57], "kind": "commanddeclaration"}, {"full_name": "Wcovby.toDual", "code": "alias \u27e8_, Wcovby.toDual\u27e9 := toDual_wcovby_toDual_iff", "start": [150, 1], "end": [150, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Wcovby.ofDual", "code": "alias \u27e8_, Wcovby.ofDual\u27e9 := ofDual_wcovby_ofDual_iff", "start": [153, 1], "end": [153, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Wcovby.eq_or_eq", "code": "theorem Wcovby.eq_or_eq (h : a \u2a7f b) (h2 : a \u2264 c) (h3 : c \u2264 b) : c = a \u2228 c = b", "start": [162, 1], "end": [165, 25], "kind": "commanddeclaration"}, {"full_name": "wcovby_iff_le_and_eq_or_eq", "code": "theorem wcovby_iff_le_and_eq_or_eq : a \u2a7f b \u2194 a \u2264 b \u2227 \u2200 c, a \u2264 c \u2192 c \u2264 b \u2192 c = a \u2228 c = b", "start": [168, 1], "end": [170, 69], "kind": "commanddeclaration"}, {"full_name": "Wcovby.le_and_le_iff", "code": "theorem Wcovby.le_and_le_iff (h : a \u2a7f b) : a \u2264 c \u2227 c \u2264 b \u2194 c = a \u2228 c = b", "start": [173, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "Wcovby.Icc_eq", "code": "theorem Wcovby.Icc_eq (h : a \u2a7f b) : Icc a b = {a, b}", "start": [178, 1], "end": [180, 24], "kind": "commanddeclaration"}, {"full_name": "Wcovby.Ico_subset", "code": "theorem Wcovby.Ico_subset (h : a \u2a7f b) : Ico a b \u2286 {a}", "start": [183, 1], "end": [184, 72], "kind": "commanddeclaration"}, {"full_name": "Wcovby.Ioc_subset", "code": "theorem Wcovby.Ioc_subset (h : a \u2a7f b) : Ioc a b \u2286 {b}", "start": [187, 1], "end": [188, 60], "kind": "commanddeclaration"}, {"full_name": "Wcovby.sup_eq", "code": "theorem Wcovby.sup_eq (hac : a \u2a7f c) (hbc : b \u2a7f c) (hab : a \u2260 b) : a \u2294 b = c", "start": [197, 1], "end": [199, 74], "kind": "commanddeclaration"}, {"full_name": "Wcovby.inf_eq", "code": "theorem Wcovby.inf_eq (hca : c \u2a7f a) (hcb : c \u2a7f b) (hab : a \u2260 b) : a \u2293 b = c", "start": [208, 1], "end": [209, 93], "kind": "commanddeclaration"}, {"full_name": "Covby", "code": "def Covby (a b : \u03b1) : Prop :=\n  a < b \u2227 \u2200 \u2983c\u2984, a < c \u2192 \u00acc < b", "start": [220, 1], "end": [222, 32], "kind": "commanddeclaration"}, {"full_name": "Covby.lt", "code": "theorem Covby.lt (h : a \u22d6 b) : a < b", "start": [228, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "not_covby_iff", "code": "theorem not_covby_iff (h : a < b) : \u00aca \u22d6 b \u2194 \u2203 c, a < c \u2227 c < b", "start": [232, 1], "end": [234, 69], "kind": "commanddeclaration"}, {"full_name": "exists_lt_lt_of_not_covby", "code": "alias \u27e8exists_lt_lt_of_not_covby, _\u27e9 := not_covby_iff", "start": [237, 1], "end": [237, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LT.lt.exists_lt_lt", "code": "alias LT.lt.exists_lt_lt := exists_lt_lt_of_not_covby", "start": [240, 1], "end": [240, 54], "kind": "stdtacticaliasalias"}, {"full_name": "not_covby", "code": "theorem not_covby [DenselyOrdered \u03b1] : \u00aca \u22d6 b", "start": [242, 1], "end": [245, 16], "kind": "commanddeclaration"}, {"full_name": "densely_ordered_iff_forall_not_covby", "code": "theorem densely_ordered_iff_forall_not_covby : DenselyOrdered \u03b1 \u2194 \u2200 a b : \u03b1, \u00aca \u22d6 b", "start": [248, 1], "end": [250, 61], "kind": "commanddeclaration"}, {"full_name": "toDual_covby_toDual_iff", "code": "@[simp]\ntheorem toDual_covby_toDual_iff : toDual b \u22d6 toDual a \u2194 a \u22d6 b", "start": [253, 1], "end": [255, 57], "kind": "commanddeclaration"}, {"full_name": "ofDual_covby_ofDual_iff", "code": "@[simp]\ntheorem ofDual_covby_ofDual_iff {a b : \u03b1\u1d52\u1d48} : ofDual a \u22d6 ofDual b \u2194 b \u22d6 a", "start": [258, 1], "end": [260, 57], "kind": "commanddeclaration"}, {"full_name": "Covby.toDual", "code": "alias \u27e8_, Covby.toDual\u27e9 := toDual_covby_toDual_iff", "start": [263, 1], "end": [263, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Covby.ofDual", "code": "alias \u27e8_, Covby.ofDual\u27e9 := ofDual_covby_ofDual_iff", "start": [266, 1], "end": [266, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Covby.le", "code": "theorem Covby.le (h : a \u22d6 b) : a \u2264 b", "start": [275, 1], "end": [276, 9], "kind": "commanddeclaration"}, {"full_name": "Covby.ne", "code": "protected theorem Covby.ne (h : a \u22d6 b) : a \u2260 b", "start": [279, 1], "end": [280, 10], "kind": "commanddeclaration"}, {"full_name": "Covby.ne'", "code": "theorem Covby.ne' (h : a \u22d6 b) : b \u2260 a", "start": [283, 1], "end": [284, 11], "kind": "commanddeclaration"}, {"full_name": "Covby.wcovby", "code": "protected theorem Covby.wcovby (h : a \u22d6 b) : a \u2a7f b", "start": [287, 1], "end": [288, 14], "kind": "commanddeclaration"}, {"full_name": "Wcovby.covby_of_not_le", "code": "theorem Wcovby.covby_of_not_le (h : a \u2a7f b) (h2 : \u00acb \u2264 a) : a \u22d6 b", "start": [291, 1], "end": [292, 30], "kind": "commanddeclaration"}, {"full_name": "Wcovby.covby_of_lt", "code": "theorem Wcovby.covby_of_lt (h : a \u2a7f b) (h2 : a < b) : a \u22d6 b", "start": [295, 1], "end": [296, 12], "kind": "commanddeclaration"}, {"full_name": "Covby.of_le_of_lt", "code": "lemma Covby.of_le_of_lt (hac : a \u22d6 c) (hab : a \u2264 b) (hbc : b < c) : b \u22d6 c :=\n  \u27e8hbc, fun _x hbx hxc \u21a6 hac.2 (hab.trans_lt hbx) hxc\u27e9", "start": [299, 1], "end": [300, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Covby.of_lt_of_le", "code": "lemma Covby.of_lt_of_le (hac : a \u22d6 c) (hab : a < b) (hbc : b \u2264 c) : a \u22d6 b :=\n  \u27e8hab, fun _x hax hxb \u21a6 hac.2 hax <| hxb.trans_le hbc\u27e9", "start": [302, 1], "end": [303, 56], "kind": "mathlibtacticlemma"}, {"full_name": "not_covby_of_lt_of_lt", "code": "theorem not_covby_of_lt_of_lt (h\u2081 : a < b) (h\u2082 : b < c) : \u00aca \u22d6 c", "start": [305, 1], "end": [306, 46], "kind": "commanddeclaration"}, {"full_name": "covby_iff_wcovby_and_lt", "code": "theorem covby_iff_wcovby_and_lt : a \u22d6 b \u2194 a \u2a7f b \u2227 a < b", "start": [309, 1], "end": [310, 60], "kind": "commanddeclaration"}, {"full_name": "covby_iff_wcovby_and_not_le", "code": "theorem covby_iff_wcovby_and_not_le : a \u22d6 b \u2194 a \u2a7f b \u2227 \u00acb \u2264 a", "start": [313, 1], "end": [314, 71], "kind": "commanddeclaration"}, {"full_name": "wcovby_iff_covby_or_le_and_le", "code": "theorem wcovby_iff_covby_or_le_and_le : a \u2a7f b \u2194 a \u22d6 b \u2228 a \u2264 b \u2227 b \u2264 a", "start": [317, 1], "end": [319, 73], "kind": "commanddeclaration"}, {"full_name": "AntisymmRel.trans_covby", "code": "theorem AntisymmRel.trans_covby (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) (hbc : b \u22d6 c) : a \u22d6 c", "start": [322, 1], "end": [323, 75], "kind": "commanddeclaration"}, {"full_name": "covby_congr_left", "code": "theorem covby_congr_left (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) : a \u22d6 c \u2194 b \u22d6 c", "start": [326, 1], "end": [327, 42], "kind": "commanddeclaration"}, {"full_name": "Covby.trans_antisymmRel", "code": "theorem Covby.trans_antisymmRel (hab : a \u22d6 b) (hbc : AntisymmRel (\u00b7 \u2264 \u00b7) b c) : a \u22d6 c", "start": [330, 1], "end": [331, 76], "kind": "commanddeclaration"}, {"full_name": "covby_congr_right", "code": "theorem covby_congr_right (hab : AntisymmRel (\u00b7 \u2264 \u00b7) a b) : c \u22d6 a \u2194 c \u22d6 b", "start": [334, 1], "end": [335, 76], "kind": "commanddeclaration"}, {"full_name": "Covby.isIrrefl", "code": "instance Covby.isIrrefl : IsIrrefl \u03b1 (\u00b7 \u22d6 \u00b7) :=\n  \u27e8fun _ ha => ha.ne rfl\u27e9", "start": [342, 1], "end": [343, 26], "kind": "commanddeclaration"}, {"full_name": "Covby.Ioo_eq", "code": "theorem Covby.Ioo_eq (h : a \u22d6 b) : Ioo a b = \u2205", "start": [346, 1], "end": [347, 18], "kind": "commanddeclaration"}, {"full_name": "covby_iff_Ioo_eq", "code": "theorem covby_iff_Ioo_eq : a \u22d6 b \u2194 a < b \u2227 Ioo a b = \u2205", "start": [350, 1], "end": [351, 60], "kind": "commanddeclaration"}, {"full_name": "Covby.of_image", "code": "theorem Covby.of_image (f : \u03b1 \u21aao \u03b2) (h : f a \u22d6 f b) : a \u22d6 b", "start": [354, 1], "end": [355, 90], "kind": "commanddeclaration"}, {"full_name": "Covby.image", "code": "theorem Covby.image (f : \u03b1 \u21aao \u03b2) (hab : a \u22d6 b) (h : (range f).OrdConnected) : f a \u22d6 f b", "start": [358, 1], "end": [359, 60], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.apply_covby_apply_iff", "code": "theorem Set.OrdConnected.apply_covby_apply_iff (f : \u03b1 \u21aao \u03b2) (h : (range f).OrdConnected) :\n    f a \u22d6 f b \u2194 a \u22d6 b", "start": [362, 1], "end": [364, 47], "kind": "commanddeclaration"}, {"full_name": "apply_covby_apply_iff", "code": "@[simp]\ntheorem apply_covby_apply_iff {E : Type*} [OrderIsoClass E \u03b1 \u03b2] (e : E) : e a \u22d6 e b \u2194 a \u22d6 b", "start": [367, 1], "end": [369, 82], "kind": "commanddeclaration"}, {"full_name": "covby_of_eq_or_eq", "code": "theorem covby_of_eq_or_eq (hab : a < b) (h : \u2200 c, a \u2264 c \u2192 c \u2264 b \u2192 c = a \u2228 c = b) : a \u22d6 b", "start": [372, 1], "end": [373, 60], "kind": "commanddeclaration"}, {"full_name": "Wcovby.covby_of_ne", "code": "theorem Wcovby.covby_of_ne (h : a \u2a7f b) (h2 : a \u2260 b) : a \u22d6 b", "start": [382, 1], "end": [383, 26], "kind": "commanddeclaration"}, {"full_name": "covby_iff_wcovby_and_ne", "code": "theorem covby_iff_wcovby_and_ne : a \u22d6 b \u2194 a \u2a7f b \u2227 a \u2260 b", "start": [386, 1], "end": [387, 60], "kind": "commanddeclaration"}, {"full_name": "wcovby_iff_covby_or_eq", "code": "theorem wcovby_iff_covby_or_eq : a \u2a7f b \u2194 a \u22d6 b \u2228 a = b", "start": [390, 1], "end": [391, 54], "kind": "commanddeclaration"}, {"full_name": "wcovby_iff_eq_or_covby", "code": "theorem wcovby_iff_eq_or_covby : a \u2a7f b \u2194 a = b \u2228 a \u22d6 b", "start": [394, 1], "end": [395, 39], "kind": "commanddeclaration"}, {"full_name": "Wcovby.covby_or_eq", "code": "alias \u27e8Wcovby.covby_or_eq, _\u27e9 := wcovby_iff_covby_or_eq", "start": [398, 1], "end": [398, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Wcovby.eq_or_covby", "code": "alias \u27e8Wcovby.eq_or_covby, _\u27e9 := wcovby_iff_eq_or_covby", "start": [401, 1], "end": [401, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Covby.eq_or_eq", "code": "theorem Covby.eq_or_eq (h : a \u22d6 b) (h2 : a \u2264 c) (h3 : c \u2264 b) : c = a \u2228 c = b", "start": [404, 1], "end": [405, 26], "kind": "commanddeclaration"}, {"full_name": "covby_iff_lt_and_eq_or_eq", "code": "theorem covby_iff_lt_and_eq_or_eq : a \u22d6 b \u2194 a < b \u2227 \u2200 c, a \u2264 c \u2192 c \u2264 b \u2192 c = a \u2228 c = b", "start": [408, 1], "end": [410, 68], "kind": "commanddeclaration"}, {"full_name": "Covby.Ico_eq", "code": "theorem Covby.Ico_eq (h : a \u22d6 b) : Ico a b = {a}", "start": [413, 1], "end": [414, 52], "kind": "commanddeclaration"}, {"full_name": "Covby.Ioc_eq", "code": "theorem Covby.Ioc_eq (h : a \u22d6 b) : Ioc a b = {b}", "start": [417, 1], "end": [418, 53], "kind": "commanddeclaration"}, {"full_name": "Covby.Icc_eq", "code": "theorem Covby.Icc_eq (h : a \u22d6 b) : Icc a b = {a, b}", "start": [421, 1], "end": [422, 18], "kind": "commanddeclaration"}, {"full_name": "Covby.Ioi_eq", "code": "theorem Covby.Ioi_eq (h : a \u22d6 b) : Ioi a = Ici b", "start": [431, 1], "end": [432, 58], "kind": "commanddeclaration"}, {"full_name": "Covby.Iio_eq", "code": "theorem Covby.Iio_eq (h : a \u22d6 b) : Iio b = Iic a", "start": [435, 1], "end": [436, 58], "kind": "commanddeclaration"}, {"full_name": "Wcovby.le_of_lt", "code": "theorem Wcovby.le_of_lt (hab : a \u2a7f b) (hcb : c < b) : c \u2264 a", "start": [439, 1], "end": [440, 36], "kind": "commanddeclaration"}, {"full_name": "Wcovby.ge_of_gt", "code": "theorem Wcovby.ge_of_gt (hab : a \u2a7f b) (hac : a < c) : b \u2264 c", "start": [443, 1], "end": [444, 24], "kind": "commanddeclaration"}, {"full_name": "Covby.le_of_lt", "code": "theorem Covby.le_of_lt (hab : a \u22d6 b) : c < b \u2192 c \u2264 a", "start": [447, 1], "end": [448, 22], "kind": "commanddeclaration"}, {"full_name": "Covby.ge_of_gt", "code": "theorem Covby.ge_of_gt (hab : a \u22d6 b) : a < c \u2192 b \u2264 c", "start": [451, 1], "end": [452, 22], "kind": "commanddeclaration"}, {"full_name": "Covby.unique_left", "code": "theorem Covby.unique_left (ha : a \u22d6 c) (hb : b \u22d6 c) : a = b", "start": [455, 1], "end": [456, 52], "kind": "commanddeclaration"}, {"full_name": "Covby.unique_right", "code": "theorem Covby.unique_right (hb : a \u22d6 b) (hc : a \u22d6 c) : b = c", "start": [459, 1], "end": [460, 52], "kind": "commanddeclaration"}, {"full_name": "Covby.eq_of_between", "code": "theorem Covby.eq_of_between {x : \u03b1} (hab : a \u22d6 b) (hbc : b \u22d6 c) (hax : a < x) (hxc : x < c) :\n    x = b", "start": [463, 1], "end": [466, 78], "kind": "commanddeclaration"}, {"full_name": "LT.lt.exists_disjoint_Iio_Ioi", "code": "lemma LT.lt.exists_disjoint_Iio_Ioi (h : a < b) :\n    \u2203 a' > a, \u2203 b' < b, \u2200 x < a', \u2200 y > b', x < y := by\n  by_cases h' : a \u22d6 b\n  \u00b7 exact \u27e8b, h, a, h, fun x hx y hy => hx.trans_le <| h'.ge_of_gt hy\u27e9\n  \u00b7 rcases h.exists_lt_lt h' with \u27e8c, ha, hb\u27e9\n    exact \u27e8c, ha, c, hb, fun _ h\u2081 _ => lt_trans h\u2081\u27e9", "start": [469, 1], "end": [476, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Set.wcovby_insert", "code": "theorem wcovby_insert (x : \u03b1) (s : Set \u03b1) : s \u2a7f insert x s", "start": [482, 1], "end": [487, 64], "kind": "commanddeclaration"}, {"full_name": "Set.covby_insert", "code": "theorem covby_insert {x : \u03b1} {s : Set \u03b1} (hx : x \u2209 s) : s \u22d6 insert x s", "start": [490, 1], "end": [491, 55], "kind": "commanddeclaration"}, {"full_name": "wcovby_eq_reflGen_covby", "code": "lemma wcovby_eq_reflGen_covby [PartialOrder \u03b1] : ((\u00b7 : \u03b1) \u2a7f \u00b7) = ReflGen (\u00b7 \u22d6 \u00b7) := by\n  ext x y; simp_rw [wcovby_iff_eq_or_covby, @eq_comm _ x, reflGen_iff]", "start": [500, 1], "end": [501, 71], "kind": "mathlibtacticlemma"}, {"full_name": "transGen_wcovby_eq_reflTransGen_covby", "code": "lemma transGen_wcovby_eq_reflTransGen_covby [PartialOrder \u03b1] :\n    TransGen ((\u00b7 : \u03b1) \u2a7f \u00b7) = ReflTransGen (\u00b7 \u22d6 \u00b7) := by\n  rw [wcovby_eq_reflGen_covby, transGen_reflGen]", "start": [503, 1], "end": [505, 49], "kind": "mathlibtacticlemma"}, {"full_name": "reflTransGen_wcovby_eq_reflTransGen_covby", "code": "lemma reflTransGen_wcovby_eq_reflTransGen_covby [PartialOrder \u03b1] :\n    ReflTransGen ((\u00b7 : \u03b1) \u2a7f \u00b7) = ReflTransGen (\u00b7 \u22d6 \u00b7) := by\n  rw [wcovby_eq_reflGen_covby, reflTransGen_reflGen]", "start": [507, 1], "end": [509, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Prod.swap_wcovby_swap", "code": "@[simp]\ntheorem swap_wcovby_swap : x.swap \u2a7f y.swap \u2194 x \u2a7f y", "start": [517, 1], "end": [519, 62], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_covby_swap", "code": "@[simp]\ntheorem swap_covby_swap : x.swap \u22d6 y.swap \u2194 x \u22d6 y", "start": [522, 1], "end": [524, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_eq_or_snd_eq_of_wcovby", "code": "theorem fst_eq_or_snd_eq_of_wcovby : x \u2a7f y \u2192 x.1 = y.1 \u2228 x.2 = y.2", "start": [527, 1], "end": [532, 60], "kind": "commanddeclaration"}, {"full_name": "Wcovby.fst", "code": "theorem _root_.Wcovby.fst (h : x \u2a7f y) : x.1 \u2a7f y.1", "start": [535, 1], "end": [536, 98], "kind": "commanddeclaration"}, {"full_name": "Wcovby.snd", "code": "theorem _root_.Wcovby.snd (h : x \u2a7f y) : x.2 \u2a7f y.2", "start": [539, 1], "end": [540, 99], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_wcovby_mk_iff_left", "code": "theorem mk_wcovby_mk_iff_left : (a\u2081, b) \u2a7f (a\u2082, b) \u2194 a\u2081 \u2a7f a\u2082", "start": [543, 1], "end": [547, 16], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_wcovby_mk_iff_right", "code": "theorem mk_wcovby_mk_iff_right : (a, b\u2081) \u2a7f (a, b\u2082) \u2194 b\u2081 \u2a7f b\u2082", "start": [550, 1], "end": [551, 47], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_covby_mk_iff_left", "code": "theorem mk_covby_mk_iff_left : (a\u2081, b) \u22d6 (a\u2082, b) \u2194 a\u2081 \u22d6 a\u2082", "start": [554, 1], "end": [555, 78], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_covby_mk_iff_right", "code": "theorem mk_covby_mk_iff_right : (a, b\u2081) \u22d6 (a, b\u2082) \u2194 b\u2081 \u22d6 b\u2082", "start": [558, 1], "end": [559, 80], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_wcovby_mk_iff", "code": "theorem mk_wcovby_mk_iff : (a\u2081, b\u2081) \u2a7f (a\u2082, b\u2082) \u2194 a\u2081 \u2a7f a\u2082 \u2227 b\u2081 = b\u2082 \u2228 b\u2081 \u2a7f b\u2082 \u2227 a\u2081 = a\u2082", "start": [562, 1], "end": [569, 39], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_covby_mk_iff", "code": "theorem mk_covby_mk_iff : (a\u2081, b\u2081) \u22d6 (a\u2082, b\u2082) \u2194 a\u2081 \u22d6 a\u2082 \u2227 b\u2081 = b\u2082 \u2228 b\u2081 \u22d6 b\u2082 \u2227 a\u2081 = a\u2082", "start": [572, 1], "end": [579, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.wcovby_iff", "code": "theorem wcovby_iff : x \u2a7f y \u2194 x.1 \u2a7f y.1 \u2227 x.2 = y.2 \u2228 x.2 \u2a7f y.2 \u2227 x.1 = y.1", "start": [582, 1], "end": [585, 25], "kind": "commanddeclaration"}, {"full_name": "Prod.covby_iff", "code": "theorem covby_iff : x \u22d6 y \u2194 x.1 \u22d6 y.1 \u2227 x.2 = y.2 \u2228 x.2 \u22d6 y.2 \u2227 x.1 = y.1", "start": [588, 1], "end": [591, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subsemigroup/Basic.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Data/SetLike/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulMemClass", "code": "class MulMemClass (S : Type*) (M : Type*) [Mul M] [SetLike S M] : Prop where\n  \n  mul_mem : \u2200 {s : S} {a b : M}, a \u2208 s \u2192 b \u2208 s \u2192 a * b \u2208 s", "start": [61, 1], "end": [64, 59], "kind": "commanddeclaration"}, {"full_name": "AddMemClass", "code": "class AddMemClass (S : Type*) (M : Type*) [Add M] [SetLike S M] : Prop where\n  \n  add_mem : \u2200 {s : S} {a b : M}, a \u2208 s \u2192 b \u2208 s \u2192 a + b \u2208 s", "start": [69, 1], "end": [72, 59], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup", "code": "structure Subsemigroup (M : Type*) [Mul M] where\n  \n  carrier : Set M\n  \n  mul_mem' {a b} : a \u2208 carrier \u2192 b \u2208 carrier \u2192 a * b \u2208 carrier", "start": [81, 1], "end": [86, 63], "kind": "commanddeclaration"}, {"full_name": "AddSubsemigroup", "code": "structure AddSubsemigroup (M : Type*) [Add M] where\n  \n  carrier : Set M\n  \n  add_mem' {a b} : a \u2208 carrier \u2192 b \u2208 carrier \u2192 a + b \u2208 carrier", "start": [89, 1], "end": [94, 63], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_carrier", "code": "@[to_additive (attr := simp)]\ntheorem mem_carrier {s : Subsemigroup M} {x : M} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [111, 1], "end": [113, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_mk", "code": "@[to_additive (attr := simp)]\ntheorem mem_mk {s : Set M} {x : M} (h_mul) : x \u2208 mk s h_mul \u2194 x \u2208 s", "start": [117, 1], "end": [119, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_set_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_set_mk {s : Set M} (h_mul) : (mk s h_mul : Set M) = s", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mk_le_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Set M} (h_mul) (h_mul') : mk s h_mul \u2264 mk t h_mul' \u2194 s \u2286 t", "start": [129, 1], "end": [131, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.ext", "code": "@[to_additive (attr := ext) \"Two `AddSubsemigroup`s are equal if they have the same elements.\"]\ntheorem ext {S T : Subsemigroup M} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [135, 1], "end": [138, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.copy", "code": "@[to_additive \"Copy an additive subsemigroup replacing `carrier` with a set that is equal to it.\"]\nprotected def copy (S : Subsemigroup M) (s : Set M) (hs : s = S) :\n    Subsemigroup M where\n  carrier := s\n  mul_mem' := hs.symm \u25b8 S.mul_mem'", "start": [142, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.copy_eq", "code": "@[to_additive]\ntheorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S", "start": [159, 1], "end": [161, 27], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mul_mem", "code": "@[to_additive \"An `AddSubsemigroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x \u2208 S \u2192 y \u2208 S \u2192 x * y \u2208 S", "start": [167, 1], "end": [170, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.not_mem_bot", "code": "@[to_additive]\ntheorem not_mem_bot {x : M} : x \u2209 (\u22a5 : Subsemigroup M)", "start": [190, 1], "end": [192, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_top", "code": "@[to_additive (attr := simp)]\ntheorem mem_top (x : M) : x \u2208 (\u22a4 : Subsemigroup M)", "start": [196, 1], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_top", "code": "@[to_additive (attr := simp)]\ntheorem coe_top : ((\u22a4 : Subsemigroup M) : Set M) = Set.univ", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_bot", "code": "@[to_additive (attr := simp)]\ntheorem coe_bot : ((\u22a5 : Subsemigroup M) : Set M) = \u2205", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_inf", "code": "@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Subsemigroup M) : ((p \u2293 p' : Subsemigroup M) : Set M) = (p : Set M) \u2229 p'", "start": [221, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_inf", "code": "@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Subsemigroup M} {x : M} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [227, 1], "end": [229, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_sInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Subsemigroup M)) : ((sInf S : Subsemigroup M) : Set M) = \u22c2 s \u2208 S, \u2191s", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_sInf", "code": "@[to_additive]\ntheorem mem_sInf {S : Set (Subsemigroup M)} {x : M} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [247, 1], "end": [249, 18], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_iInf", "code": "@[to_additive]\ntheorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subsemigroup M} {x : M} : (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [253, 1], "end": [255, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_iInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subsemigroup M} : (\u2191(\u2a05 i, S i) : Set M) = \u22c2 i, S i", "start": [259, 1], "end": [261, 48], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.subsingleton_of_subsingleton", "code": "@[to_additive (attr := simp)]\ntheorem subsingleton_of_subsingleton [Subsingleton (Subsemigroup M)] : Subsingleton M", "start": [282, 1], "end": [286, 36], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure", "code": "@[to_additive \"The `AddSubsemigroup` generated by a set\"]\ndef closure (s : Set M) : Subsemigroup M :=\n  sInf { S | s \u2286 S }", "start": [297, 1], "end": [300, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_closure", "code": "@[to_additive]\ntheorem mem_closure {x : M} : x \u2208 closure s \u2194 \u2200 S : Subsemigroup M, s \u2286 S \u2192 x \u2208 S", "start": [304, 1], "end": [306, 11], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.subset_closure", "code": "@[to_additive (attr := simp, aesop safe 20 apply (rule_sets [SetLike]))\n  \"The `AddSubsemigroup` generated by a set includes the set.\"]\ntheorem subset_closure : s \u2286 closure s", "start": [310, 1], "end": [313, 86], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.not_mem_of_not_mem_closure", "code": "@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P \u2209 closure s) : P \u2209 s", "start": [317, 1], "end": [319, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_le", "code": "@[to_additive (attr := simp)\n  \"An additive subsemigroup `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s \u2264 S \u2194 s \u2286 S", "start": [327, 1], "end": [331, 52], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_mono", "code": "@[to_additive \"Additive subsemigroup closure of a set is monotone in its argument: if `s \u2286 t`,\n  then `closure s \u2264 closure t`\"]\ntheorem closure_mono \u2983s t : Set M\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [335, 1], "end": [340, 48], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_eq_of_le", "code": "@[to_additive]\ntheorem closure_eq_of_le (h\u2081 : s \u2286 S) (h\u2082 : S \u2264 closure s) : closure s = S", "start": [344, 1], "end": [346, 35], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_induction", "code": "@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership. If `p`\n  holds for all elements of `s`, and is preserved under addition, then `p` holds for all\n  elements of the additive closure of `s`.\"]\ntheorem closure_induction {p : M \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [352, 1], "end": [359, 43], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_induction'", "code": "@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubsemigroup.closure_induction`. \"]\ntheorem closure_induction' (s : Set M) {p : \u2200 x, x \u2208 closure s \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 s), p x (subset_closure h))\n    (Hmul : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x * y) (mul_mem hx hy)) {x} (hx : x \u2208 closure s) :\n    p x hx", "start": [363, 1], "end": [372, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_induction\u2082", "code": "@[to_additive (attr := elab_as_elim) \"An induction principle for additive closure membership for\n  predicates with two arguments.\"]\ntheorem closure_induction\u2082 {p : M \u2192 M \u2192 Prop} {x} {y : M} (hx : x \u2208 closure s) (hy : y \u2208 closure s)\n    (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (Hmul_left : \u2200 x y z, p x z \u2192 p y z \u2192 p (x * y) z)\n    (Hmul_right : \u2200 x y z, p z x \u2192 p z y \u2192 p z (x * y)) : p x y", "start": [376, 1], "end": [384, 43], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.dense_induction", "code": "@[to_additive (attr := elab_as_elim) \"If `s` is a dense set in an additive monoid `M`,\n  `AddSubsemigroup.closure s = \u22a4`, then in order to prove that some predicate `p` holds\n  for all `x : M` it suffices to verify `p x` for `x \u2208 s`, and verify that `p x` and `p y` imply\n  `p (x + y)`.\"]\ntheorem dense_induction {p : M \u2192 Prop} (x : M) {s : Set M} (hs : closure s = \u22a4) (Hs : \u2200 x \u2208 s, p x)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [388, 1], "end": [398, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.gi", "code": "@[to_additive \"`closure` forms a Galois insertion with the coercion to set.\"]\nprotected def gi : GaloisInsertion (@closure M _) SetLike.coe :=\n  GaloisConnection.toGaloisInsertion (fun _ _ => closure_le) fun _ => subset_closure", "start": [404, 1], "end": [407, 85], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_eq", "code": "@[to_additive (attr := simp) \"Additive closure of an additive subsemigroup `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S", "start": [413, 1], "end": [416, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_empty", "code": "@[to_additive (attr := simp)]\ntheorem closure_empty : closure (\u2205 : Set M) = \u22a5", "start": [420, 1], "end": [422, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_univ", "code": "@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = \u22a4", "start": [426, 1], "end": [428, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_union", "code": "@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s \u222a t) = closure s \u2294 closure t", "start": [432, 1], "end": [434, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_iUnion", "code": "@[to_additive]\ntheorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set M) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [438, 1], "end": [440, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_singleton_le_iff_mem", "code": "@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Subsemigroup M) : closure {m} \u2264 p \u2194 m \u2208 p", "start": [444, 1], "end": [446, 57], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_iSup", "code": "@[to_additive]\ntheorem mem_iSup {\u03b9 : Sort*} (p : \u03b9 \u2192 Subsemigroup M) {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2200 N, (\u2200 i, p i \u2264 N) \u2192 m \u2208 N", "start": [450, 1], "end": [454, 43], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.iSup_eq_closure", "code": "@[to_additive]\ntheorem iSup_eq_closure {\u03b9 : Sort*} (p : \u03b9 \u2192 Subsemigroup M) :\n    \u2a06 i, p i = Subsemigroup.closure (\u22c3 i, (p i : Set M))", "start": [458, 1], "end": [461, 65], "kind": "commanddeclaration"}, {"full_name": "MulHom.eqLocus", "code": "@[to_additive \"The additive subsemigroup of elements `x : M` such that `f x = g x`\"]\ndef eqLocus (f g : M \u2192\u2099* N) : Subsemigroup M where\n  carrier := { x | f x = g x }\n  mul_mem' (hx : _ = _) (hy : _ = _) := by simp [*]", "start": [473, 1], "end": [477, 52], "kind": "commanddeclaration"}, {"full_name": "MulHom.eqOn_closure", "code": "@[to_additive \"If two add homomorphisms are equal on a set,\n  then they are equal on its additive subsemigroup closure.\"]\ntheorem eqOn_closure {f g : M \u2192\u2099* N} {s : Set M} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s)", "start": [481, 1], "end": [486, 51], "kind": "commanddeclaration"}, {"full_name": "MulHom.eq_of_eqOn_top", "code": "@[to_additive]\ntheorem eq_of_eqOn_top {f g : M \u2192\u2099* N} (h : Set.EqOn f g (\u22a4 : Subsemigroup M)) : f = g", "start": [490, 1], "end": [492, 25], "kind": "commanddeclaration"}, {"full_name": "MulHom.eq_of_eqOn_dense", "code": "@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set M} (hs : closure s = \u22a4) {f g : M \u2192\u2099* N} (h : s.EqOn f g) :\n    f = g", "start": [496, 1], "end": [499, 40], "kind": "commanddeclaration"}, {"full_name": "MulHom.ofDense", "code": "@[to_additive]\ndef ofDense {M N} [Semigroup M] [Semigroup N] {s : Set M} (f : M \u2192 N) (hs : closure s = \u22a4)\n    (hmul : \u2200 (x), \u2200 y \u2208 s, f (x * y) = f x * f y) :\n    M \u2192\u2099* N where\n  toFun := f\n  map_mul' x y :=\n    dense_induction y hs (fun y hy x => hmul x y hy)\n      (fun y\u2081 y\u2082 h\u2081 h\u2082 x => by simp only [\u2190 mul_assoc, h\u2081, h\u2082]) x", "start": [513, 1], "end": [523, 66], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_ofDense", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofDense [Semigroup M] [Semigroup N] {s : Set M} (f : M \u2192 N) (hs : closure s = \u22a4)\n    (hmul) : (ofDense f hs hmul : M \u2192 N) = f", "start": [532, 1], "end": [535, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Aut.lean", "imports": ["Mathlib/GroupTheory/Perm/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulAut", "code": "@[to_additive (attr := reducible) \"The group of additive automorphisms.\"]\ndef MulAut (M : Type*) [Mul M] :=\n  M \u2243* M", "start": [33, 1], "end": [36, 9], "kind": "commanddeclaration"}, {"full_name": "MulAut.coe_mul", "code": "@[simp]\ntheorem coe_mul (e\u2081 e\u2082 : MulAut M) : \u21d1(e\u2081 * e\u2082) = e\u2081 \u2218 e\u2082", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : MulAut M) = id", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.mul_def", "code": "theorem mul_def (e\u2081 e\u2082 : MulAut M) : e\u2081 * e\u2082 = e\u2082.trans e\u2081", "start": [76, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.one_def", "code": "theorem one_def : (1 : MulAut M) = MulEquiv.refl _", "start": [80, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.inv_def", "code": "theorem inv_def (e\u2081 : MulAut M) : e\u2081\u207b\u00b9 = e\u2081.symm", "start": [84, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.mul_apply", "code": "@[simp]\ntheorem mul_apply (e\u2081 e\u2082 : MulAut M) (m : M) : (e\u2081 * e\u2082) m = e\u2081 (e\u2082 m)", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.one_apply", "code": "@[simp]\ntheorem one_apply (m : M) : (1 : MulAut M) m = m", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.apply_inv_self", "code": "@[simp]\ntheorem apply_inv_self (e : MulAut M) (m : M) : e (e\u207b\u00b9 m) = m", "start": [98, 1], "end": [100, 32], "kind": "commanddeclaration"}, {"full_name": "MulAut.inv_apply_self", "code": "@[simp]\ntheorem inv_apply_self (e : MulAut M) (m : M) : e\u207b\u00b9 (e m) = m", "start": [103, 1], "end": [105, 32], "kind": "commanddeclaration"}, {"full_name": "MulAut.toPerm", "code": "def toPerm : MulAut M \u2192* Equiv.Perm M := by\n  refine' { toFun := MulEquiv.toEquiv, ..} <;> intros <;> rfl", "start": [108, 1], "end": [110, 62], "kind": "commanddeclaration"}, {"full_name": "MulAut.applyMulDistribMulAction", "code": "instance applyMulDistribMulAction {M} [Monoid M] : MulDistribMulAction (MulAut M) M where\n  smul := (\u00b7 <| \u00b7)\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl\n  smul_one := MulEquiv.map_one\n  smul_mul := MulEquiv.map_mul", "start": [113, 1], "end": [121, 31], "kind": "commanddeclaration"}, {"full_name": "MulAut.smul_def", "code": "@[simp]\nprotected theorem smul_def {M} [Monoid M] (f : MulAut M) (a : M) : f \u2022 a = f a", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.apply_faithfulSMul", "code": "instance apply_faithfulSMul {M} [Monoid M] : FaithfulSMul (MulAut M) M :=\n  \u27e8 fun h => MulEquiv.ext h \u27e9", "start": [129, 1], "end": [131, 30], "kind": "commanddeclaration"}, {"full_name": "MulAut.conj", "code": "def conj [Group G] : G \u2192* MulAut G where\n  toFun g :=\n    { toFun := fun h => g * h * g\u207b\u00b9\n      invFun := fun h => g\u207b\u00b9 * h * g\n      left_inv := fun _ => by simp only [mul_assoc, inv_mul_cancel_left, mul_left_inv, mul_one]\n      right_inv := fun _ => by simp only [mul_assoc, mul_inv_cancel_left, mul_right_inv, mul_one]\n      map_mul' := by simp only [mul_assoc, inv_mul_cancel_left, forall_const] }\n  map_mul' g\u2081 g\u2082 := by\n    ext h\n    show g\u2081 * g\u2082 * h * (g\u2081 * g\u2082)\u207b\u00b9 = g\u2081 * (g\u2082 * h * g\u2082\u207b\u00b9) * g\u2081\u207b\u00b9\n    simp only [mul_assoc, mul_inv_rev]\n  map_one' := by ext; simp only [one_mul, inv_one, mul_one, one_apply]; rfl", "start": [134, 1], "end": [149, 76], "kind": "commanddeclaration"}, {"full_name": "MulAut.conj_apply", "code": "@[simp]\ntheorem conj_apply [Group G] (g h : G) : conj g h = g * h * g\u207b\u00b9", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.conj_symm_apply", "code": "@[simp]\ntheorem conj_symm_apply [Group G] (g h : G) : (conj g).symm h = g\u207b\u00b9 * h * g", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.conj_inv_apply", "code": "@[simp]\ntheorem conj_inv_apply [Group G] (g h : G) : (conj g)\u207b\u00b9 h = g\u207b\u00b9 * h * g", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.group", "code": "instance group : Group (AddAut A) := by\n  refine'\n  { mul := fun g h => AddEquiv.trans h g\n    one := AddEquiv.refl A\n    inv := AddEquiv.symm\n    div := fun g h => AddEquiv.trans h.symm g\n    npow := @npowRec _ \u27e8AddEquiv.refl A\u27e9 \u27e8fun g h => AddEquiv.trans h g\u27e9\n    zpow := @zpowRec _ \u27e8AddEquiv.refl A\u27e9 \u27e8fun g h => AddEquiv.trans h g\u27e9 \u27e8AddEquiv.symm\u27e9\n    .. } <;>\n  intros <;>\n  ext <;>\n  try rfl\n  apply Equiv.left_inv", "start": [173, 1], "end": [188, 23], "kind": "commanddeclaration"}, {"full_name": "AddAut.coe_mul", "code": "@[simp]\ntheorem coe_mul (e\u2081 e\u2082 : AddAut A) : \u21d1(e\u2081 * e\u2082) = e\u2081 \u2218 e\u2082", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : AddAut A) = id", "start": [199, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.mul_def", "code": "theorem mul_def (e\u2081 e\u2082 : AddAut A) : e\u2081 * e\u2082 = e\u2082.trans e\u2081", "start": [204, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.one_def", "code": "theorem one_def : (1 : AddAut A) = AddEquiv.refl _", "start": [208, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.inv_def", "code": "theorem inv_def (e\u2081 : AddAut A) : e\u2081\u207b\u00b9 = e\u2081.symm", "start": [212, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.mul_apply", "code": "@[simp]\ntheorem mul_apply (e\u2081 e\u2082 : AddAut A) (a : A) : (e\u2081 * e\u2082) a = e\u2081 (e\u2082 a)", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.one_apply", "code": "@[simp]\ntheorem one_apply (a : A) : (1 : AddAut A) a = a", "start": [221, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.apply_inv_self", "code": "@[simp]\ntheorem apply_inv_self (e : AddAut A) (a : A) : e\u207b\u00b9 (e a) = a", "start": [226, 1], "end": [228, 32], "kind": "commanddeclaration"}, {"full_name": "AddAut.inv_apply_self", "code": "@[simp]\ntheorem inv_apply_self (e : AddAut A) (a : A) : e (e\u207b\u00b9 a) = a", "start": [231, 1], "end": [233, 32], "kind": "commanddeclaration"}, {"full_name": "AddAut.toPerm", "code": "def toPerm : AddAut A \u2192* Equiv.Perm A := by\n  refine' { toFun := AddEquiv.toEquiv, .. } <;> intros <;> rfl", "start": [236, 1], "end": [238, 63], "kind": "commanddeclaration"}, {"full_name": "AddAut.applyDistribMulAction", "code": "instance applyDistribMulAction {A} [AddMonoid A] : DistribMulAction (AddAut A) A where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := AddEquiv.map_zero\n  smul_add := AddEquiv.map_add\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [241, 1], "end": [249, 24], "kind": "commanddeclaration"}, {"full_name": "AddAut.smul_def", "code": "@[simp]\nprotected theorem smul_def {A} [AddMonoid A] (f : AddAut A) (a : A) : f \u2022 a = f a", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.apply_faithfulSMul", "code": "instance apply_faithfulSMul {A} [AddMonoid A] : FaithfulSMul (AddAut A) A :=\n  \u27e8fun h => AddEquiv.ext h \u27e9", "start": [257, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "AddAut.conj", "code": "def conj [AddGroup G] : G \u2192+ Additive (AddAut G) where\n  toFun g :=\n    @Additive.ofMul (AddAut G)\n      { toFun := fun h => g + h + -g\n        invFun := fun h => -g + h + g\n        left_inv := fun _ => by simp only [add_assoc, neg_add_cancel_left, add_left_neg, add_zero]\n        right_inv := fun _ => by simp only [add_assoc, add_neg_cancel_left, add_right_neg, add_zero]\n        map_add' := by simp only [add_assoc, neg_add_cancel_left, forall_const] }\n  map_add' g\u2081 g\u2082 := by\n    apply Additive.toMul.injective; ext h\n    show g\u2081 + g\u2082 + h + -(g\u2081 + g\u2082) = g\u2081 + (g\u2082 + h + -g\u2082) + -g\u2081\n    simp only [add_assoc, neg_add_rev]\n  map_zero' := by\n    apply Additive.toMul.injective; ext\n    simp only [zero_add, neg_zero, add_zero, toMul_ofMul, toMul_zero, one_apply]\n    rfl", "start": [262, 1], "end": [281, 8], "kind": "commanddeclaration"}, {"full_name": "AddAut.conj_apply", "code": "@[simp]\ntheorem conj_apply [AddGroup G] (g h : G) : conj g h = g + h + -g", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.conj_symm_apply", "code": "@[simp]\ntheorem conj_symm_apply [AddGroup G] (g h : G) : (conj g).symm h = -g + h + g", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "AddAut.conj_inv_apply", "code": "@[simp]\ntheorem conj_inv_apply [AddGroup G] (g h : G) : (Additive.toMul (conj g))\u207b\u00b9 h = -g + h + g", "start": [297, 1], "end": [299, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Prod.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Defs.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.smul", "code": "@[to_additive]\ninstance smul : SMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a p => (a \u2022 p.1, a \u2022 p.2)\u27e9", "start": [43, 1], "end": [45, 34], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_fst", "code": "@[to_additive (attr := simp)]\ntheorem smul_fst : (a \u2022 x).1 = a \u2022 x.1", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_snd", "code": "@[to_additive (attr := simp)]\ntheorem smul_snd : (a \u2022 x).2 = a \u2022 x.2", "start": [53, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_mk", "code": "@[to_additive (attr := simp)]\ntheorem smul_mk (a : M) (b : \u03b1) (c : \u03b2) : a \u2022 (b, c) = (a \u2022 b, a \u2022 c)", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_def", "code": "@[to_additive]\ntheorem smul_def (a : M) (x : \u03b1 \u00d7 \u03b2) : a \u2022 x = (a \u2022 x.1, a \u2022 x.2)", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_swap", "code": "@[to_additive (attr := simp)]\ntheorem smul_swap : (a \u2022 x).swap = a \u2022 x.swap", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_zero_mk", "code": "theorem smul_zero_mk {\u03b1 : Type*} [Monoid M] [AddMonoid \u03b1] [DistribMulAction M \u03b1] (a : M) (c : \u03b2) :\n    a \u2022 ((0 : \u03b1), c) = (0, a \u2022 c)", "start": [77, 1], "end": [78, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.smul_mk_zero", "code": "theorem smul_mk_zero {\u03b2 : Type*} [Monoid M] [AddMonoid \u03b2] [DistribMulAction M \u03b2] (a : M) (b : \u03b1) :\n    a \u2022 (b, (0 : \u03b2)) = (a \u2022 b, 0)", "start": [81, 1], "end": [82, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.pow", "code": "@[to_additive existing smul]\ninstance pow : Pow (\u03b1 \u00d7 \u03b2) E where pow p c := (p.1 ^ c, p.2 ^ c)", "start": [87, 1], "end": [88, 65], "kind": "commanddeclaration"}, {"full_name": "Prod.pow_fst", "code": "@[to_additive existing (attr := simp) (reorder := 6 7) smul_fst]\ntheorem pow_fst (p : \u03b1 \u00d7 \u03b2) (c : E) : (p ^ c).fst = p.fst ^ c", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.pow_snd", "code": "@[to_additive existing (attr := simp) (reorder := 6 7) smul_snd]\ntheorem pow_snd (p : \u03b1 \u00d7 \u03b2) (c : E) : (p ^ c).snd = p.snd ^ c", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.pow_mk", "code": "@[to_additive existing (attr := simp) (reorder := 6 7) smul_mk]\ntheorem pow_mk (c : E) (a : \u03b1) (b : \u03b2) : Prod.mk a b ^ c = Prod.mk (a ^ c) (b ^ c)", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.pow_def", "code": "@[to_additive existing (reorder := 6 7) smul_def]\ntheorem pow_def (p : \u03b1 \u00d7 \u03b2) (c : E) : p ^ c = (p.1 ^ c, p.2 ^ c)", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.pow_swap", "code": "@[to_additive existing (attr := simp) (reorder := 6 7) smul_swap]\ntheorem pow_swap (p : \u03b1 \u00d7 \u03b2) (c : E) : (p ^ c).swap = p.swap ^ c", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.isScalarTower", "code": "@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul M N] [IsScalarTower M N \u03b1] [IsScalarTower M N \u03b2] :\n    IsScalarTower M N (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun _ _ _ => mk.inj_iff.mpr \u27e8smul_assoc _ _ _, smul_assoc _ _ _\u27e9\u27e9", "start": [120, 1], "end": [123, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass [SMulCommClass M N \u03b1] [SMulCommClass M N \u03b2] :\n    SMulCommClass M N (\u03b1 \u00d7 \u03b2) where\n  smul_comm _ _ _ := mk.inj_iff.mpr \u27e8smul_comm _ _ _, smul_comm _ _ _\u27e9", "start": [125, 1], "end": [128, 71], "kind": "commanddeclaration"}, {"full_name": "Prod.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar [SMul M\u1d50\u1d52\u1d56 \u03b1] [SMul M\u1d50\u1d52\u1d56 \u03b2] [IsCentralScalar M \u03b1] [IsCentralScalar M \u03b2] :\n    IsCentralScalar M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun _ _ => Prod.ext (op_smul_eq_smul _ _) (op_smul_eq_smul _ _)\u27e9", "start": [130, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.faithfulSMulLeft", "code": "@[to_additive]\ninstance faithfulSMulLeft [FaithfulSMul M \u03b1] [Nonempty \u03b2] : FaithfulSMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun h =>\n    let \u27e8b\u27e9 := \u2039Nonempty \u03b2\u203a\n    eq_of_smul_eq_smul fun a : \u03b1 => by injection h (a, b)\u27e9", "start": [137, 1], "end": [141, 59], "kind": "commanddeclaration"}, {"full_name": "Prod.faithfulSMulRight", "code": "@[to_additive]\ninstance faithfulSMulRight [Nonempty \u03b1] [FaithfulSMul M \u03b2] : FaithfulSMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun h =>\n    let \u27e8a\u27e9 := \u2039Nonempty \u03b1\u203a\n    eq_of_smul_eq_smul fun b : \u03b2 => by injection h (a, b)\u27e9", "start": [145, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "Prod.smulCommClassBoth", "code": "@[to_additive]\ninstance smulCommClassBoth [Mul N] [Mul P] [SMul M N] [SMul M P] [SMulCommClass M N N]\n    [SMulCommClass M P P] : SMulCommClass M (N \u00d7 P) (N \u00d7 P) :=\n  \u27e8fun c x y => by simp [smul_def, mul_def, mul_smul_comm]\u27e9", "start": [155, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "Prod.isScalarTowerBoth", "code": "instance isScalarTowerBoth [Mul N] [Mul P] [SMul M N] [SMul M P] [IsScalarTower M N N]\n    [IsScalarTower M P P] : IsScalarTower M (N \u00d7 P) (N \u00d7 P) :=\n  \u27e8fun c x y => by simp [smul_def, mul_def, smul_mul_assoc]\u27e9", "start": [162, 1], "end": [164, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.mulAction", "code": "@[to_additive]\ninstance mulAction [Monoid M] [MulAction M \u03b1] [MulAction M \u03b2] : MulAction M (\u03b1 \u00d7 \u03b2) where\n  mul_smul _ _ _ := mk.inj_iff.mpr \u27e8mul_smul _ _ _, mul_smul _ _ _\u27e9\n  one_smul := fun \u27e8_, _\u27e9 => mk.inj_iff.mpr \u27e8one_smul _ _, one_smul _ _\u27e9", "start": [167, 1], "end": [170, 72], "kind": "commanddeclaration"}, {"full_name": "Prod.smulZeroClass", "code": "instance smulZeroClass {R M N : Type*} [Zero M] [Zero N] [SMulZeroClass R M] [SMulZeroClass R N] :\n    SMulZeroClass R (M \u00d7 N) where smul_zero _ := mk.inj_iff.mpr \u27e8smul_zero _, smul_zero _\u27e9", "start": [172, 1], "end": [173, 91], "kind": "commanddeclaration"}, {"full_name": "Prod.distribSMul", "code": "instance distribSMul {R M N : Type*} [AddZeroClass M] [AddZeroClass N] [DistribSMul R M]\n    [DistribSMul R N] : DistribSMul R (M \u00d7 N) where\n  smul_add _ _ _ := mk.inj_iff.mpr \u27e8smul_add _ _ _, smul_add _ _ _\u27e9", "start": [175, 1], "end": [177, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.distribMulAction", "code": "instance distribMulAction [Monoid R] [AddMonoid M] [AddMonoid N]\n    [DistribMulAction R M] [DistribMulAction R N] : DistribMulAction R (M \u00d7 N) :=\n  { Prod.mulAction, Prod.distribSMul with }", "start": [179, 1], "end": [181, 44], "kind": "commanddeclaration"}, {"full_name": "Prod.mulDistribMulAction", "code": "instance mulDistribMulAction [Monoid R] [Monoid M] [Monoid N]\n    [MulDistribMulAction R M] [MulDistribMulAction R N] : MulDistribMulAction R (M \u00d7 N) where\n  smul_mul _ _ _ := mk.inj_iff.mpr \u27e8smul_mul' _ _ _, smul_mul' _ _ _\u27e9\n  smul_one _ := mk.inj_iff.mpr \u27e8smul_one _, smul_one _\u27e9", "start": [183, 1], "end": [186, 56], "kind": "commanddeclaration"}, {"full_name": "smulMulHom", "code": "@[simps]\ndef smulMulHom [Monoid \u03b1] [Mul \u03b2] [MulAction \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] :\n    \u03b1 \u00d7 \u03b2 \u2192\u2099* \u03b2 where\n  toFun a := a.1 \u2022 a.2\n  map_mul' _ _ := (smul_mul_smul _ _ _ _).symm", "start": [194, 1], "end": [199, 47], "kind": "commanddeclaration"}, {"full_name": "smulMonoidHom", "code": "@[simps]\ndef smulMonoidHom [Monoid \u03b1] [MulOneClass \u03b2] [MulAction \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2]\n    [SMulCommClass \u03b1 \u03b2 \u03b2] : \u03b1 \u00d7 \u03b2 \u2192* \u03b2 :=\n  { smulMulHom with map_one' := one_smul _ _ }", "start": [203, 1], "end": [207, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NormNum.lean", "imports": ["Mathlib/Tactic/NormNum/Inv.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Rat/Cast/Order.lean", "Mathlib/Tactic/NormNum/Eq.lean", "Mathlib/Tactic/NormNum/Pow.lean", "Mathlib/Tactic/NormNum/OfScientific.lean", "Mathlib/Tactic/NormNum/Basic.lean", "Mathlib/Tactic/NormNum/Ineq.lean"], "premises": []}
{"path": "Mathlib/Util/AtomM.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Types.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.AtomM.Context", "code": "structure AtomM.Context :=\n  \n  red : TransparencyMode\n  \n  evalAtom : Expr \u2192 MetaM Simp.Result := fun e \u21a6 pure { expr := e }\n  deriving Inhabited", "start": [20, 1], "end": [27, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.AtomM.State", "code": "structure AtomM.State :=\n  \n  atoms : Array Expr := #[]", "start": [29, 1], "end": [32, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.AtomM", "code": "abbrev AtomM := ReaderT AtomM.Context <| StateRefT AtomM.State MetaM", "start": [34, 1], "end": [35, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.AtomM.run", "code": "def AtomM.run (red : TransparencyMode) (m : AtomM \u03b1)\n    (evalAtom : Expr \u2192 MetaM Simp.Result := fun e \u21a6 pure { expr := e }) :\n    MetaM \u03b1 :=\n  (m { red, evalAtom }).run' {}", "start": [37, 1], "end": [41, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.AtomM.addAtom", "code": "def AtomM.addAtom (e : Expr) : AtomM Nat := do\n  let c \u2190 get\n  for h : i in [:c.atoms.size] do\n    have : i < c.atoms.size := h.2\n    if \u2190 withTransparency (\u2190 read).red <| isDefEq e c.atoms[i] then\n      return i\n  modifyGet fun c \u21a6 (c.atoms.size, { c with atoms := c.atoms.push e })", "start": [43, 1], "end": [51, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Bases.lean", "imports": ["Mathlib/Data/Set/Countable.lean", "Mathlib/Order/Filter/Prod.lean", "Mathlib/Data/Prod/PProd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FilterBasis", "code": "structure FilterBasis (\u03b1 : Type*) where\n  \n  sets : Set (Set \u03b1)\n  \n  nonempty : sets.Nonempty\n  \n  inter_sets {x y} : x \u2208 sets \u2192 y \u2208 sets \u2192 \u2203 z \u2208 sets, z \u2286 x \u2229 y", "start": [91, 1], "end": [100, 65], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.nonempty_sets", "code": "instance FilterBasis.nonempty_sets (B : FilterBasis \u03b1) : Nonempty B.sets :=\n  B.nonempty.to_subtype", "start": [103, 1], "end": [104, 24], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.mem_sets", "code": "@[simp] theorem FilterBasis.mem_sets {s : Set \u03b1} {B : FilterBasis \u03b1} : s \u2208 B.sets \u2194 s \u2208 B", "start": [113, 1], "end": [113, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.asBasis", "code": "def Filter.asBasis (f : Filter \u03b1) : FilterBasis \u03b1 :=\n  \u27e8f.sets, \u27e8univ, univ_mem\u27e9, fun {x y} hx hy => \u27e8x \u2229 y, inter_mem hx hy, subset_rfl\u27e9\u27e9", "start": [123, 1], "end": [125, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis", "code": "structure Filter.IsBasis (p : \u03b9 \u2192 Prop) (s : \u03b9 \u2192 Set \u03b1) : Prop where\n  \n  nonempty : \u2203 i, p i\n  \n  inter : \u2200 {i j}, p i \u2192 p j \u2192 \u2203 k, p k \u2227 s k \u2286 s i \u2229 s j", "start": [129, 1], "end": [134, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.filterBasis", "code": "protected def filterBasis {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : IsBasis p s) : FilterBasis \u03b1 where\n  sets := { t | \u2203 i, p i \u2227 s i = t }\n  nonempty :=\n    let \u27e8i, hi\u27e9 := h.nonempty\n    \u27e8s i, \u27e8i, hi, rfl\u27e9\u27e9\n  inter_sets := by\n    rintro _ _ \u27e8i, hi, rfl\u27e9 \u27e8j, hj, rfl\u27e9\n    rcases h.inter hi hj with \u27e8k, hk, hk'\u27e9\n    exact \u27e8_, \u27e8k, hk, rfl\u27e9, hk'\u27e9", "start": [141, 1], "end": [150, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.mem_filterBasis_iff", "code": "theorem mem_filterBasis_iff {U : Set \u03b1} : U \u2208 h.filterBasis \u2194 \u2203 i, p i \u2227 s i = U", "start": [155, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.filter", "code": "protected def filter (B : FilterBasis \u03b1) : Filter \u03b1 where\n  sets := { s | \u2203 t \u2208 B, t \u2286 s }\n  univ_sets := B.nonempty.imp <| fun s s_in => \u27e8s_in, s.subset_univ\u27e9\n  sets_of_superset := fun \u27e8s, s_in, h\u27e9 hxy => \u27e8s, s_in, Set.Subset.trans h hxy\u27e9\n  inter_sets := fun \u27e8_s, s_in, hs\u27e9 \u27e8_t, t_in, ht\u27e9 =>\n    let \u27e8u, u_in, u_sub\u27e9 := B.inter_sets s_in t_in\n    \u27e8u, u_in, u_sub.trans (inter_subset_inter hs ht)\u27e9", "start": [165, 1], "end": [172, 54], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.mem_filter_iff", "code": "theorem mem_filter_iff (B : FilterBasis \u03b1) {U : Set \u03b1} : U \u2208 B.filter \u2194 \u2203 s \u2208 B, s \u2286 U", "start": [175, 1], "end": [176, 10], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.mem_filter_of_mem", "code": "theorem mem_filter_of_mem (B : FilterBasis \u03b1) {U : Set \u03b1} : U \u2208 B \u2192 U \u2208 B.filter", "start": [179, 1], "end": [180, 27], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.eq_iInf_principal", "code": "theorem eq_iInf_principal (B : FilterBasis \u03b1) : B.filter = \u2a05 s : B.sets, \ud835\udcdf s", "start": [183, 1], "end": [191, 51], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.generate", "code": "protected theorem generate (B : FilterBasis \u03b1) : generate B.sets = B.filter", "start": [194, 1], "end": [200, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.filter", "code": "protected def filter (h : IsBasis p s) : Filter \u03b1 :=\n  h.filterBasis.filter", "start": [211, 1], "end": [213, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.mem_filter_iff", "code": "protected theorem mem_filter_iff (h : IsBasis p s) {U : Set \u03b1} :\n    U \u2208 h.filter \u2194 \u2203 i, p i \u2227 s i \u2286 U", "start": [216, 1], "end": [219, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.filter_eq_generate", "code": "theorem filter_eq_generate (h : IsBasis p s) : h.filter = generate { U | \u2203 i, p i \u2227 s i = U }", "start": [222, 1], "end": [223, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis", "code": "structure HasBasis (l : Filter \u03b1) (p : \u03b9 \u2192 Prop) (s : \u03b9 \u2192 Set \u03b1) : Prop where\n  \n  mem_iff' : \u2200 t : Set \u03b1, t \u2208 l \u2194 \u2203 i, p i \u2227 s i \u2286 t", "start": [229, 1], "end": [233, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_generate", "code": "theorem hasBasis_generate (s : Set (Set \u03b1)) :\n    (generate s).HasBasis (fun t => Set.Finite t \u2227 t \u2286 s) fun t => \u22c2\u2080 t", "start": [241, 1], "end": [243, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.FilterBasis.ofSets", "code": "def FilterBasis.ofSets (s : Set (Set \u03b1)) : FilterBasis \u03b1 where\n  sets := sInter '' { t | Set.Finite t \u2227 t \u2286 s }\n  nonempty := \u27e8univ, \u2205, \u27e8\u27e8finite_empty, empty_subset s\u27e9, sInter_empty\u27e9\u27e9\n  inter_sets := by\n    rintro _ _ \u27e8a, \u27e8fina, suba\u27e9, rfl\u27e9 \u27e8b, \u27e8finb, subb\u27e9, rfl\u27e9\n    exact \u27e8\u22c2\u2080 (a \u222a b), mem_image_of_mem _ \u27e8fina.union finb, union_subset suba subb\u27e9,\n        (sInter_union _ _).subset\u27e9", "start": [246, 1], "end": [253, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.FilterBasis.ofSets_sets", "code": "lemma FilterBasis.ofSets_sets (s : Set (Set \u03b1)) :\n    (FilterBasis.ofSets s).sets = sInter '' { t | Set.Finite t \u2227 t \u2286 s } :=\n  rfl", "start": [256, 1], "end": [258, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.HasBasis.mem_iff", "code": "theorem HasBasis.mem_iff (hl : l.HasBasis p s) : t \u2208 l \u2194 \u2203 i, p i \u2227 s i \u2286 t", "start": [261, 1], "end": [263, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eq_of_same_basis", "code": "theorem HasBasis.eq_of_same_basis (hl : l.HasBasis p s) (hl' : l'.HasBasis p s) : l = l'", "start": [266, 1], "end": [268, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iff", "code": "theorem hasBasis_iff : l.HasBasis p s \u2194 \u2200 t, t \u2208 l \u2194 \u2203 i, p i \u2227 s i \u2286 t", "start": [272, 1], "end": [273, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.ex_mem", "code": "theorem HasBasis.ex_mem (h : l.HasBasis p s) : \u2203 i, p i", "start": [276, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.nonempty", "code": "protected theorem HasBasis.nonempty (h : l.HasBasis p s) : Nonempty \u03b9", "start": [280, 1], "end": [281, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.IsBasis.hasBasis", "code": "protected theorem IsBasis.hasBasis (h : IsBasis p s) : HasBasis h.filter p s", "start": [284, 1], "end": [285, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.mem_of_superset", "code": "protected theorem HasBasis.mem_of_superset (hl : l.HasBasis p s) (hi : p i) (ht : s i \u2286 t) :\n    t \u2208 l", "start": [288, 1], "end": [290, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.mem_of_mem", "code": "theorem HasBasis.mem_of_mem (hl : l.HasBasis p s) (hi : p i) : s i \u2208 l", "start": [293, 1], "end": [294, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.index", "code": "noncomputable def HasBasis.index (h : l.HasBasis p s) (t : Set \u03b1) (ht : t \u2208 l) : { i : \u03b9 // p i } :=\n  \u27e8(h.mem_iff.1 ht).choose, (h.mem_iff.1 ht).choose_spec.1\u27e9", "start": [297, 1], "end": [299, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.property_index", "code": "theorem HasBasis.property_index (h : l.HasBasis p s) (ht : t \u2208 l) : p (h.index t ht)", "start": [302, 1], "end": [303, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.set_index_mem", "code": "theorem HasBasis.set_index_mem (h : l.HasBasis p s) (ht : t \u2208 l) : s (h.index t ht) \u2208 l", "start": [306, 1], "end": [307, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.set_index_subset", "code": "theorem HasBasis.set_index_subset (h : l.HasBasis p s) (ht : t \u2208 l) : s (h.index t ht) \u2286 t", "start": [310, 1], "end": [311, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.isBasis", "code": "theorem HasBasis.isBasis (h : l.HasBasis p s) : IsBasis p s where", "start": [314, 1], "end": [317, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.filter_eq", "code": "theorem HasBasis.filter_eq (h : l.HasBasis p s) : h.isBasis.filter = l", "start": [320, 1], "end": [322, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eq_generate", "code": "theorem HasBasis.eq_generate (h : l.HasBasis p s) : l = generate { U | \u2203 i, p i \u2227 s i = U }", "start": [325, 1], "end": [326, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_eq_generate_inter", "code": "theorem generate_eq_generate_inter (s : Set (Set \u03b1)) :\n    generate s = generate (sInter '' { t | Set.Finite t \u2227 t \u2286 s })", "start": [329, 1], "end": [331, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.ofSets_filter_eq_generate", "code": "theorem ofSets_filter_eq_generate (s : Set (Set \u03b1)) :\n    (FilterBasis.ofSets s).filter = generate s", "start": [334, 1], "end": [336, 96], "kind": "commanddeclaration"}, {"full_name": "FilterBasis.hasBasis", "code": "protected theorem _root_.FilterBasis.hasBasis (B : FilterBasis \u03b1) :\n    HasBasis B.filter (fun s : Set \u03b1 => s \u2208 B) id", "start": [339, 1], "end": [341, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.to_hasBasis'", "code": "theorem HasBasis.to_hasBasis' (hl : l.HasBasis p s) (h : \u2200 i, p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i)\n    (h' : \u2200 i', p' i' \u2192 s' i' \u2208 l) : l.HasBasis p' s'", "start": [344, 1], "end": [349, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.to_hasBasis", "code": "theorem HasBasis.to_hasBasis (hl : l.HasBasis p s) (h : \u2200 i, p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i)\n    (h' : \u2200 i', p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i') : l.HasBasis p' s'", "start": [352, 1], "end": [356, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.to_subset", "code": "theorem HasBasis.to_subset (hl : l.HasBasis p s) {t : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, p i \u2192 t i \u2286 s i)\n    (ht : \u2200 i, p i \u2192 t i \u2208 l) : l.HasBasis p t", "start": [359, 1], "end": [361, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eventually_iff", "code": "theorem HasBasis.eventually_iff (hl : l.HasBasis p s) {q : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in l, q x) \u2194 \u2203 i, p i \u2227 \u2200 \u2983x\u2984, x \u2208 s i \u2192 q x", "start": [364, 1], "end": [365, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.frequently_iff", "code": "theorem HasBasis.frequently_iff (hl : l.HasBasis p s) {q : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in l, q x) \u2194 \u2200 i, p i \u2192 \u2203 x \u2208 s i, q x", "start": [368, 1], "end": [370, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.exists_iff", "code": "theorem HasBasis.exists_iff (hl : l.HasBasis p s) {P : Set \u03b1 \u2192 Prop}\n    (mono : \u2200 \u2983s t\u2984, s \u2286 t \u2192 P t \u2192 P s) : (\u2203 s \u2208 l, P s) \u2194 \u2203 i, p i \u2227 P (s i)", "start": [374, 1], "end": [379, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.forall_iff", "code": "theorem HasBasis.forall_iff (hl : l.HasBasis p s) {P : Set \u03b1 \u2192 Prop}\n    (mono : \u2200 \u2983s t\u2984, s \u2286 t \u2192 P s \u2192 P t) : (\u2200 s \u2208 l, P s) \u2194 \u2200 i, p i \u2192 P (s i)", "start": [382, 1], "end": [386, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.neBot_iff", "code": "protected theorem HasBasis.neBot_iff (hl : l.HasBasis p s) :\n    NeBot l \u2194 \u2200 {i}, p i \u2192 (s i).Nonempty", "start": [389, 1], "end": [391, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eq_bot_iff", "code": "theorem HasBasis.eq_bot_iff (hl : l.HasBasis p s) : l = \u22a5 \u2194 \u2203 i, p i \u2227 s i = \u2205", "start": [394, 1], "end": [396, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.generate_neBot_iff", "code": "theorem generate_neBot_iff {s : Set (Set \u03b1)} :\n    NeBot (generate s) \u2194 \u2200 t, t \u2286 s \u2192 t.Finite \u2192 (\u22c2\u2080 t).Nonempty", "start": [399, 1], "end": [401, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.basis_sets", "code": "theorem basis_sets (l : Filter \u03b1) : l.HasBasis (fun s : Set \u03b1 => s \u2208 l) id", "start": [404, 1], "end": [405, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.asBasis_filter", "code": "theorem asBasis_filter (f : Filter \u03b1) : f.asBasis.filter = f", "start": [408, 1], "end": [409, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_self", "code": "theorem hasBasis_self {l : Filter \u03b1} {P : Set \u03b1 \u2192 Prop} :\n    HasBasis l (fun s => s \u2208 l \u2227 P s) id \u2194 \u2200 t \u2208 l, \u2203 r \u2208 l, P r \u2227 r \u2286 t", "start": [412, 1], "end": [416, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.comp_surjective", "code": "theorem HasBasis.comp_surjective (h : l.HasBasis p s) {g : \u03b9' \u2192 \u03b9} (hg : Function.Surjective g) :\n    l.HasBasis (p \u2218 g) (s \u2218 g)", "start": [419, 1], "end": [421, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.comp_equiv", "code": "theorem HasBasis.comp_equiv (h : l.HasBasis p s) (e : \u03b9' \u2243 \u03b9) : l.HasBasis (p \u2218 e) (s \u2218 e)", "start": [424, 1], "end": [425, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.restrict", "code": "theorem HasBasis.restrict (h : l.HasBasis p s) {q : \u03b9 \u2192 Prop}\n    (hq : \u2200 i, p i \u2192 \u2203 j, p j \u2227 q j \u2227 s j \u2286 s i) : l.HasBasis (fun i => p i \u2227 q i) s", "start": [428, 1], "end": [435, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.restrict_subset", "code": "theorem HasBasis.restrict_subset (h : l.HasBasis p s) {V : Set \u03b1} (hV : V \u2208 l) :\n    l.HasBasis (fun i => p i \u2227 s i \u2286 V) s", "start": [438, 1], "end": [443, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.hasBasis_self_subset", "code": "theorem HasBasis.hasBasis_self_subset {p : Set \u03b1 \u2192 Prop} (h : l.HasBasis (fun s => s \u2208 l \u2227 p s) id)\n    {V : Set \u03b1} (hV : V \u2208 l) : l.HasBasis (fun s => s \u2208 l \u2227 p s \u2227 s \u2286 V) id", "start": [446, 1], "end": [448, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.ge_iff", "code": "theorem HasBasis.ge_iff (hl' : l'.HasBasis p' s') : l \u2264 l' \u2194 \u2200 i', p' i' \u2192 s' i' \u2208 l", "start": [451, 1], "end": [454, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.le_iff", "code": "theorem HasBasis.le_iff (hl : l.HasBasis p s) : l \u2264 l' \u2194 \u2200 t \u2208 l', \u2203 i, p i \u2227 s i \u2286 t", "start": [458, 1], "end": [459, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.le_basis_iff", "code": "theorem HasBasis.le_basis_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    l \u2264 l' \u2194 \u2200 i', p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i'", "start": [463, 1], "end": [465, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.ext", "code": "theorem HasBasis.ext (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s')\n    (h : \u2200 i, p i \u2192 \u2203 i', p' i' \u2227 s' i' \u2286 s i) (h' : \u2200 i', p' i' \u2192 \u2203 i, p i \u2227 s i \u2286 s' i') :\n    l = l'", "start": [469, 1], "end": [476, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf'", "code": "theorem HasBasis.inf' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l \u2293 l').HasBasis (fun i : PProd \u03b9 \u03b9' => p i.1 \u2227 p' i.2) fun i => s i.1 \u2229 s' i.2", "start": [479, 1], "end": [488, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf", "code": "theorem HasBasis.inf {\u03b9 \u03b9' : Type*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {p' : \u03b9' \u2192 Prop}\n    {s' : \u03b9' \u2192 Set \u03b1} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l \u2293 l').HasBasis (fun i : \u03b9 \u00d7 \u03b9' => p i.1 \u2227 p' i.2) fun i => s i.1 \u2229 s' i.2", "start": [491, 1], "end": [494, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf'", "code": "theorem hasBasis_iInf' {\u03b9 : Type*} {\u03b9' : \u03b9 \u2192 Type*} {l : \u03b9 \u2192 Filter \u03b1} {p : \u2200 i, \u03b9' i \u2192 Prop}\n    {s : \u2200 i, \u03b9' i \u2192 Set \u03b1} (hl : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    (\u2a05 i, l i).HasBasis (fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => If.1.Finite \u2227 \u2200 i \u2208 If.1, p i (If.2 i))\n      fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => \u22c2 i \u2208 If.1, s i (If.2 i)", "start": [497, 1], "end": [510, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf", "code": "theorem hasBasis_iInf {\u03b9 : Type*} {\u03b9' : \u03b9 \u2192 Type*} {l : \u03b9 \u2192 Filter \u03b1} {p : \u2200 i, \u03b9' i \u2192 Prop}\n    {s : \u2200 i, \u03b9' i \u2192 Set \u03b1} (hl : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    (\u2a05 i, l i).HasBasis\n      (fun If : \u03a3 I : Set \u03b9, \u2200 i : I, \u03b9' i => If.1.Finite \u2227 \u2200 i : If.1, p i (If.2 i)) fun If =>\n      \u22c2 i : If.1, s i (If.2 i)", "start": [513, 1], "end": [524, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf_of_directed'", "code": "theorem hasBasis_iInf_of_directed' {\u03b9 : Type*} {\u03b9' : \u03b9 \u2192 Sort _} [Nonempty \u03b9] {l : \u03b9 \u2192 Filter \u03b1}\n    (s : \u2200 i, \u03b9' i \u2192 Set \u03b1) (p : \u2200 i, \u03b9' i \u2192 Prop) (hl : \u2200 i, (l i).HasBasis (p i) (s i))\n    (h : Directed (\u00b7 \u2265 \u00b7) l) :\n    (\u2a05 i, l i).HasBasis (fun ii' : \u03a3i, \u03b9' i => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2", "start": [527, 1], "end": [533, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf_of_directed", "code": "theorem hasBasis_iInf_of_directed {\u03b9 : Type*} {\u03b9' : Sort _} [Nonempty \u03b9] {l : \u03b9 \u2192 Filter \u03b1}\n    (s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1) (p : \u03b9 \u2192 \u03b9' \u2192 Prop) (hl : \u2200 i, (l i).HasBasis (p i) (s i))\n    (h : Directed (\u00b7 \u2265 \u00b7) l) :\n    (\u2a05 i, l i).HasBasis (fun ii' : \u03b9 \u00d7 \u03b9' => p ii'.1 ii'.2) fun ii' => s ii'.1 ii'.2", "start": [536, 1], "end": [542, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_biInf_of_directed'", "code": "theorem hasBasis_biInf_of_directed' {\u03b9 : Type*} {\u03b9' : \u03b9 \u2192 Sort _} {dom : Set \u03b9}\n    (hdom : dom.Nonempty) {l : \u03b9 \u2192 Filter \u03b1} (s : \u2200 i, \u03b9' i \u2192 Set \u03b1) (p : \u2200 i, \u03b9' i \u2192 Prop)\n    (hl : \u2200 i \u2208 dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l \u207b\u00b9'o GE.ge) dom) :\n    (\u2a05 i \u2208 dom, l i).HasBasis (fun ii' : \u03a3i, \u03b9' i => ii'.1 \u2208 dom \u2227 p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2", "start": [545, 1], "end": [557, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_biInf_of_directed", "code": "theorem hasBasis_biInf_of_directed {\u03b9 : Type*} {\u03b9' : Sort _} {dom : Set \u03b9} (hdom : dom.Nonempty)\n    {l : \u03b9 \u2192 Filter \u03b1} (s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1) (p : \u03b9 \u2192 \u03b9' \u2192 Prop)\n    (hl : \u2200 i \u2208 dom, (l i).HasBasis (p i) (s i)) (h : DirectedOn (l \u207b\u00b9'o GE.ge) dom) :\n    (\u2a05 i \u2208 dom, l i).HasBasis (fun ii' : \u03b9 \u00d7 \u03b9' => ii'.1 \u2208 dom \u2227 p ii'.1 ii'.2) fun ii' =>\n      s ii'.1 ii'.2", "start": [560, 1], "end": [572, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_principal", "code": "theorem hasBasis_principal (t : Set \u03b1) : (\ud835\udcdf t).HasBasis (fun _ : Unit => True) fun _ => t", "start": [575, 1], "end": [576, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_pure", "code": "theorem hasBasis_pure (x : \u03b1) : (pure x : Filter \u03b1).HasBasis (fun _ : Unit => True) fun _ => {x}", "start": [579, 1], "end": [580, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.sup'", "code": "theorem HasBasis.sup' (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l \u2294 l').HasBasis (fun i : PProd \u03b9 \u03b9' => p i.1 \u2227 p' i.2) fun i => s i.1 \u222a s' i.2", "start": [583, 1], "end": [589, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.sup", "code": "theorem HasBasis.sup {\u03b9 \u03b9' : Type*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {p' : \u03b9' \u2192 Prop}\n    {s' : \u03b9' \u2192 Set \u03b1} (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    (l \u2294 l').HasBasis (fun i : \u03b9 \u00d7 \u03b9' => p i.1 \u2227 p' i.2) fun i => s i.1 \u222a s' i.2", "start": [592, 1], "end": [595, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iSup", "code": "theorem hasBasis_iSup {\u03b9 : Sort*} {\u03b9' : \u03b9 \u2192 Type*} {l : \u03b9 \u2192 Filter \u03b1} {p : \u2200 i, \u03b9' i \u2192 Prop}\n    {s : \u2200 i, \u03b9' i \u2192 Set \u03b1} (hl : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    (\u2a06 i, l i).HasBasis (fun f : \u2200 i, \u03b9' i => \u2200 i, p i (f i)) fun f : \u2200 i, \u03b9' i => \u22c3 i, s i (f i)", "start": [598, 1], "end": [603, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.sup_principal", "code": "theorem HasBasis.sup_principal (hl : l.HasBasis p s) (t : Set \u03b1) :\n    (l \u2294 \ud835\udcdf t).HasBasis p fun i => s i \u222a t", "start": [606, 1], "end": [610, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.sup_pure", "code": "theorem HasBasis.sup_pure (hl : l.HasBasis p s) (x : \u03b1) :\n    (l \u2294 pure x).HasBasis p fun i => s i \u222a {x}", "start": [613, 1], "end": [615, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf_principal", "code": "theorem HasBasis.inf_principal (hl : l.HasBasis p s) (s' : Set \u03b1) :\n    (l \u2293 \ud835\udcdf s').HasBasis p fun i => s i \u2229 s'", "start": [618, 1], "end": [621, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.principal_inf", "code": "theorem HasBasis.principal_inf (hl : l.HasBasis p s) (s' : Set \u03b1) :\n    (\ud835\udcdf s' \u2293 l).HasBasis p fun i => s' \u2229 s i", "start": [624, 1], "end": [626, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf_basis_neBot_iff", "code": "theorem HasBasis.inf_basis_neBot_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    NeBot (l \u2293 l') \u2194 \u2200 \u2983i\u2984, p i \u2192 \u2200 \u2983i'\u2984, p' i' \u2192 (s i \u2229 s' i').Nonempty", "start": [629, 1], "end": [631, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf_neBot_iff", "code": "theorem HasBasis.inf_neBot_iff (hl : l.HasBasis p s) :\n    NeBot (l \u2293 l') \u2194 \u2200 \u2983i\u2984, p i \u2192 \u2200 \u2983s'\u2984, s' \u2208 l' \u2192 (s i \u2229 s').Nonempty", "start": [634, 1], "end": [636, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.inf_principal_neBot_iff", "code": "theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set \u03b1} :\n    NeBot (l \u2293 \ud835\udcdf t) \u2194 \u2200 \u2983i\u2984, p i \u2192 (s i \u2229 t).Nonempty", "start": [639, 1], "end": [641, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.disjoint_iff", "code": "theorem HasBasis.disjoint_iff (hl : l.HasBasis p s) (hl' : l'.HasBasis p' s') :\n    Disjoint l l' \u2194 \u2203 i, p i \u2227 \u2203 i', p' i' \u2227 Disjoint (s i) (s' i')", "start": [645, 1], "end": [648, 92], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_mem_filter_basis", "code": "theorem _root_.Disjoint.exists_mem_filter_basis (h : Disjoint l l') (hl : l.HasBasis p s)\n    (hl' : l'.HasBasis p' s') : \u2203 i, p i \u2227 \u2203 i', p' i' \u2227 Disjoint (s i) (s' i')", "start": [652, 1], "end": [654, 28], "kind": "commanddeclaration"}, {"full_name": "Pairwise.exists_mem_filter_basis_of_disjoint", "code": "theorem _root_.Pairwise.exists_mem_filter_basis_of_disjoint {I} [Finite I] {l : I \u2192 Filter \u03b1}\n    {\u03b9 : I \u2192 Sort*} {p : \u2200 i, \u03b9 i \u2192 Prop} {s : \u2200 i, \u03b9 i \u2192 Set \u03b1} (hd : Pairwise (Disjoint on l))\n    (h : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    \u2203 ind : \u2200 i, \u03b9 i, (\u2200 i, p i (ind i)) \u2227 Pairwise (Disjoint on fun i => s i (ind i))", "start": [657, 1], "end": [663, 65], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.exists_mem_filter_basis", "code": "theorem _root_.Set.PairwiseDisjoint.exists_mem_filter_basis {I : Type*} {l : I \u2192 Filter \u03b1}\n    {\u03b9 : I \u2192 Sort*} {p : \u2200 i, \u03b9 i \u2192 Prop} {s : \u2200 i, \u03b9 i \u2192 Set \u03b1} {S : Set I}\n    (hd : S.PairwiseDisjoint l) (hS : S.Finite) (h : \u2200 i, (l i).HasBasis (p i) (s i)) :\n    \u2203 ind : \u2200 i, \u03b9 i, (\u2200 i, p i (ind i)) \u2227 S.PairwiseDisjoint fun i => s i (ind i)", "start": [666, 1], "end": [672, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_neBot_iff", "code": "theorem inf_neBot_iff :\n    NeBot (l \u2293 l') \u2194 \u2200 \u2983s : Set \u03b1\u2984, s \u2208 l \u2192 \u2200 \u2983s'\u2984, s' \u2208 l' \u2192 (s \u2229 s').Nonempty", "start": [675, 1], "end": [677, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_principal_neBot_iff", "code": "theorem inf_principal_neBot_iff {s : Set \u03b1} : NeBot (l \u2293 \ud835\udcdf s) \u2194 \u2200 U \u2208 l, (U \u2229 s).Nonempty", "start": [680, 1], "end": [681, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iff_inf_principal_compl", "code": "theorem mem_iff_inf_principal_compl {f : Filter \u03b1} {s : Set \u03b1} : s \u2208 f \u2194 f \u2293 \ud835\udcdf s\u1d9c = \u22a5", "start": [684, 1], "end": [688, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.not_mem_iff_inf_principal_compl", "code": "theorem not_mem_iff_inf_principal_compl {f : Filter \u03b1} {s : Set \u03b1} : s \u2209 f \u2194 NeBot (f \u2293 \ud835\udcdf s\u1d9c)", "start": [691, 1], "end": [692, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_principal_right", "code": "@[simp]\ntheorem disjoint_principal_right {f : Filter \u03b1} {s : Set \u03b1} : Disjoint f (\ud835\udcdf s) \u2194 s\u1d9c \u2208 f", "start": [695, 1], "end": [697, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_principal_left", "code": "@[simp]\ntheorem disjoint_principal_left {f : Filter \u03b1} {s : Set \u03b1} : Disjoint (\ud835\udcdf s) f \u2194 s\u1d9c \u2208 f", "start": [700, 1], "end": [702, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_principal_principal", "code": "@[simp 1100] theorem disjoint_principal_principal {s t : Set \u03b1} : Disjoint (\ud835\udcdf s) (\ud835\udcdf t) \u2194 Disjoint s t", "start": [705, 1], "end": [707, 80], "kind": "commanddeclaration"}, {"full_name": "Disjoint.filter_principal", "code": "alias \u27e8_, _root_.Disjoint.filter_principal\u27e9 := disjoint_principal_principal", "start": [710, 1], "end": [710, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.disjoint_pure_pure", "code": "@[simp]\ntheorem disjoint_pure_pure {x y : \u03b1} : Disjoint (pure x : Filter \u03b1) (pure y) \u2194 x \u2260 y", "start": [713, 1], "end": [715, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_diagonal_mem_prod", "code": "@[simp]\ntheorem compl_diagonal_mem_prod {l\u2081 l\u2082 : Filter \u03b1} : (diagonal \u03b1)\u1d9c \u2208 l\u2081 \u00d7\u02e2 l\u2082 \u2194 Disjoint l\u2081 l\u2082", "start": [718, 1], "end": [720, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.disjoint_iff_left", "code": "theorem HasBasis.disjoint_iff_left (h : l.HasBasis p s) :\n    Disjoint l l' \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l'", "start": [724, 1], "end": [727, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.disjoint_iff_right", "code": "theorem HasBasis.disjoint_iff_right (h : l.HasBasis p s) :\n    Disjoint l' l \u2194 \u2203 i, p i \u2227 (s i)\u1d9c \u2208 l'", "start": [731, 1], "end": [733, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.le_iff_forall_inf_principal_compl", "code": "theorem le_iff_forall_inf_principal_compl {f g : Filter \u03b1} : f \u2264 g \u2194 \u2200 V \u2208 g, f \u2293 \ud835\udcdf V\u1d9c = \u22a5", "start": [736, 1], "end": [737, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_neBot_iff_frequently_left", "code": "theorem inf_neBot_iff_frequently_left {f g : Filter \u03b1} :\n    NeBot (f \u2293 g) \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 x in f, p x) \u2192 \u2203\u1da0 x in g, p x", "start": [740, 1], "end": [742, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_neBot_iff_frequently_right", "code": "theorem inf_neBot_iff_frequently_right {f g : Filter \u03b1} :\n    NeBot (f \u2293 g) \u2194 \u2200 {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 x in g, p x) \u2192 \u2203\u1da0 x in f, p x", "start": [745, 1], "end": [748, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eq_biInf", "code": "theorem HasBasis.eq_biInf (h : l.HasBasis p s) : l = \u2a05 (i) (_ : p i), \ud835\udcdf (s i)", "start": [751, 1], "end": [752, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eq_iInf", "code": "theorem HasBasis.eq_iInf (h : l.HasBasis (fun _ => True) s) : l = \u2a05 i, \ud835\udcdf (s i)", "start": [755, 1], "end": [756, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf_principal", "code": "theorem hasBasis_iInf_principal {s : \u03b9 \u2192 Set \u03b1} (h : Directed (\u00b7 \u2265 \u00b7) s) [Nonempty \u03b9] :\n    (\u2a05 i, \ud835\udcdf (s i)).HasBasis (fun _ => True) s", "start": [759, 1], "end": [762, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_iInf_principal_finite", "code": "theorem hasBasis_iInf_principal_finite {\u03b9 : Type*} (s : \u03b9 \u2192 Set \u03b1) :\n    (\u2a05 i, \ud835\udcdf (s i)).HasBasis (fun t : Set \u03b9 => t.Finite) fun t => \u22c2 i \u2208 t, s i", "start": [765, 1], "end": [771, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_biInf_principal", "code": "theorem hasBasis_biInf_principal {s : \u03b2 \u2192 Set \u03b1} {S : Set \u03b2} (h : DirectedOn (s \u207b\u00b9'o (\u00b7 \u2265 \u00b7)) S)\n    (ne : S.Nonempty) : (\u2a05 i \u2208 S, \ud835\udcdf (s i)).HasBasis (fun i => i \u2208 S) s", "start": [774, 1], "end": [780, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_biInf_principal'", "code": "theorem hasBasis_biInf_principal' {\u03b9 : Type*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i, p i \u2192 \u2200 j, p j \u2192 \u2203 k, p k \u2227 s k \u2286 s i \u2227 s k \u2286 s j) (ne : \u2203 i, p i) :\n    (\u2a05 (i) (_ : p i), \ud835\udcdf (s i)).HasBasis p s", "start": [783, 1], "end": [786, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.map", "code": "theorem HasBasis.map (f : \u03b1 \u2192 \u03b2) (hl : l.HasBasis p s) : (l.map f).HasBasis p fun i => f '' s i", "start": [789, 1], "end": [790, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.comap", "code": "theorem HasBasis.comap (f : \u03b2 \u2192 \u03b1) (hl : l.HasBasis p s) :\n    (l.comap f).HasBasis p fun i => f \u207b\u00b9' s i", "start": [793, 1], "end": [798, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_hasBasis", "code": "theorem comap_hasBasis (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b2) :\n    HasBasis (comap f l) (fun s : Set \u03b2 => s \u2208 l) fun s => f \u207b\u00b9' s", "start": [801, 1], "end": [803, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.forall_mem_mem", "code": "theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : \u03b1} :\n    (\u2200 t \u2208 l, x \u2208 t) \u2194 \u2200 i, p i \u2192 x \u2208 s i", "start": [806, 1], "end": [809, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.biInf_mem", "code": "protected theorem HasBasis.biInf_mem [CompleteLattice \u03b2] {f : Set \u03b1 \u2192 \u03b2} (h : HasBasis l p s)\n    (hf : Monotone f) : \u2a05 t \u2208 l, f t = \u2a05 (i) (_ : p i), f (s i)", "start": [812, 1], "end": [817, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.biInter_mem", "code": "protected theorem HasBasis.biInter_mem {f : Set \u03b1 \u2192 Set \u03b2} (h : HasBasis l p s) (hf : Monotone f) :\n    \u22c2 t \u2208 l, f t = \u22c2 (i) (_ : p i), f (s i)", "start": [820, 1], "end": [822, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.ker", "code": "protected theorem HasBasis.ker (h : HasBasis l p s) : l.ker = \u22c2 (i) (_ : p i), s i", "start": [825, 1], "end": [826, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.IsAntitoneBasis", "code": "structure IsAntitoneBasis extends IsBasis (fun _ => True) s'' : Prop where\n  \n  protected antitone : Antitone s''", "start": [831, 1], "end": [834, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis", "code": "structure HasAntitoneBasis (l : Filter \u03b1) (s : \u03b9'' \u2192 Set \u03b1)\n    extends HasBasis l (fun _ => True) s : Prop where\n  \n  protected antitone : Antitone s", "start": [837, 1], "end": [842, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.map", "code": "theorem HasAntitoneBasis.map {l : Filter \u03b1} {s : \u03b9'' \u2192 Set \u03b1} {m : \u03b1 \u2192 \u03b2}\n    (hf : HasAntitoneBasis l s) : HasAntitoneBasis (map m l) fun n => m '' s n", "start": [845, 1], "end": [847, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.tendsto_left_iff", "code": "theorem HasBasis.tendsto_left_iff (hla : la.HasBasis pa sa) :\n    Tendsto f la lb \u2194 \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t", "start": [858, 1], "end": [861, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.tendsto_right_iff", "code": "theorem HasBasis.tendsto_right_iff (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb \u2194 \u2200 i, pb i \u2192 \u2200\u1da0 x in la, f x \u2208 sb i", "start": [864, 1], "end": [866, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.tendsto_iff", "code": "theorem HasBasis.tendsto_iff (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    Tendsto f la lb \u2194 \u2200 ib, pb ib \u2192 \u2203 ia, pa ia \u2227 \u2200 x \u2208 sa ia, f x \u2208 sb ib", "start": [870, 1], "end": [872, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.basis_left", "code": "theorem Tendsto.basis_left (H : Tendsto f la lb) (hla : la.HasBasis pa sa) :\n    \u2200 t \u2208 lb, \u2203 i, pa i \u2227 MapsTo f (sa i) t", "start": [876, 1], "end": [878, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.basis_right", "code": "theorem Tendsto.basis_right (H : Tendsto f la lb) (hlb : lb.HasBasis pb sb) :\n    \u2200 i, pb i \u2192 \u2200\u1da0 x in la, f x \u2208 sb i", "start": [881, 1], "end": [883, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.basis_both", "code": "theorem Tendsto.basis_both (H : Tendsto f la lb) (hla : la.HasBasis pa sa)\n    (hlb : lb.HasBasis pb sb) :\n    \u2200 ib, pb ib \u2192 \u2203 ia, pa ia \u2227 MapsTo f (sa ia) (sb ib)", "start": [887, 1], "end": [890, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_pprod", "code": "theorem HasBasis.prod_pprod (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la \u00d7\u02e2 lb).HasBasis (fun i : PProd \u03b9 \u03b9' => pa i.1 \u2227 pb i.2) fun i => sa i.1 \u00d7\u02e2 sb i.2", "start": [893, 1], "end": [895, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod", "code": "theorem HasBasis.prod {\u03b9 \u03b9' : Type*} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {pb : \u03b9' \u2192 Prop}\n    {sb : \u03b9' \u2192 Set \u03b2} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la \u00d7\u02e2 lb).HasBasis (fun i : \u03b9 \u00d7 \u03b9' => pa i.1 \u2227 pb i.2) fun i => sa i.1 \u00d7\u02e2 sb i.2", "start": [898, 1], "end": [901, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_same_index", "code": "theorem HasBasis.prod_same_index {p : \u03b9 \u2192 Prop} {sb : \u03b9 \u2192 Set \u03b2} (hla : la.HasBasis p sa)\n    (hlb : lb.HasBasis p sb) (h_dir : \u2200 {i j}, p i \u2192 p j \u2192 \u2203 k, p k \u2227 sa k \u2286 sa i \u2227 sb k \u2286 sb j) :\n    (la \u00d7\u02e2 lb).HasBasis p fun i => sa i \u00d7\u02e2 sb i", "start": [904, 1], "end": [913, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_same_index_mono", "code": "theorem HasBasis.prod_same_index_mono {\u03b9 : Type*} [LinearOrder \u03b9] {p : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1}\n    {sb : \u03b9 \u2192 Set \u03b2} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : MonotoneOn sa { i | p i }) (hsb : MonotoneOn sb { i | p i }) :\n    (la \u00d7\u02e2 lb).HasBasis p fun i => sa i \u00d7\u02e2 sb i", "start": [916, 1], "end": [922, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_same_index_anti", "code": "theorem HasBasis.prod_same_index_anti {\u03b9 : Type*} [LinearOrder \u03b9] {p : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1}\n    {sb : \u03b9 \u2192 Set \u03b2} (hla : la.HasBasis p sa) (hlb : lb.HasBasis p sb)\n    (hsa : AntitoneOn sa { i | p i }) (hsb : AntitoneOn sb { i | p i }) :\n    (la \u00d7\u02e2 lb).HasBasis p fun i => sa i \u00d7\u02e2 sb i", "start": [925, 1], "end": [929, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_self", "code": "theorem HasBasis.prod_self (hl : la.HasBasis pa sa) :\n    (la \u00d7\u02e2 la).HasBasis pa fun i => sa i \u00d7\u02e2 sa i", "start": [932, 1], "end": [936, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_self_iff", "code": "theorem mem_prod_self_iff {s} : s \u2208 la \u00d7\u02e2 la \u2194 \u2203 t \u2208 la, t \u00d7\u02e2 t \u2286 s", "start": [939, 1], "end": [940, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.prod", "code": "theorem HasAntitoneBasis.prod {\u03b9 : Type*} [LinearOrder \u03b9] {f : Filter \u03b1} {g : Filter \u03b2}\n    {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\n    HasAntitoneBasis (f \u00d7\u02e2 g) fun n => s n \u00d7\u02e2 t n", "start": [943, 1], "end": [946, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.coprod", "code": "theorem HasBasis.coprod {\u03b9 \u03b9' : Type*} {pa : \u03b9 \u2192 Prop} {sa : \u03b9 \u2192 Set \u03b1} {pb : \u03b9' \u2192 Prop}\n    {sb : \u03b9' \u2192 Set \u03b2} (hla : la.HasBasis pa sa) (hlb : lb.HasBasis pb sb) :\n    (la.coprod lb).HasBasis (fun i : \u03b9 \u00d7 \u03b9' => pa i.1 \u2227 pb i.2) fun i =>\n      Prod.fst \u207b\u00b9' sa i.1 \u222a Prod.snd \u207b\u00b9' sb i.2", "start": [949, 1], "end": [953, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.map_sigma_mk_comap", "code": "theorem map_sigma_mk_comap {\u03c0 : \u03b1 \u2192 Type*} {\u03c0' : \u03b2 \u2192 Type*} {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (g : \u2200 a, \u03c0 a \u2192 \u03c0' (f a)) (a : \u03b1) (l : Filter (\u03c0' (f a))) :\n    map (Sigma.mk a) (comap (g a) l) = comap (Sigma.map f g) (map (Sigma.mk (f a)) l)", "start": [958, 1], "end": [963, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCountablyGenerated", "code": "class IsCountablyGenerated (f : Filter \u03b1) : Prop where\n  \n  out : \u2203 s : Set (Set \u03b1), s.Countable \u2227 f = generate s", "start": [974, 1], "end": [977, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.IsCountableBasis", "code": "structure IsCountableBasis (p : \u03b9 \u2192 Prop) (s : \u03b9 \u2192 Set \u03b1) extends IsBasis p s : Prop where\n  \n  countable : (setOf p).Countable", "start": [980, 1], "end": [983, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.HasCountableBasis", "code": "structure HasCountableBasis (l : Filter \u03b1) (p : \u03b9 \u2192 Prop) (s : \u03b9 \u2192 Set \u03b1)\n    extends HasBasis l p s : Prop where\n  \n  countable : (setOf p).Countable", "start": [986, 1], "end": [992, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.CountableFilterBasis", "code": "structure CountableFilterBasis (\u03b1 : Type*) extends FilterBasis \u03b1 where\n  \n  countable : sets.Countable", "start": [995, 1], "end": [1000, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Nat.inhabitedCountableFilterBasis", "code": "instance Nat.inhabitedCountableFilterBasis : Inhabited (CountableFilterBasis \u2115) :=\n  \u27e8\u27e8default, countable_range fun n => Ici n\u27e9\u27e9", "start": [1004, 1], "end": [1005, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.HasCountableBasis.isCountablyGenerated", "code": "theorem HasCountableBasis.isCountablyGenerated {f : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : f.HasCountableBasis p s) : f.IsCountablyGenerated", "start": [1008, 1], "end": [1010, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.antitone_seq_of_seq", "code": "theorem antitone_seq_of_seq (s : \u2115 \u2192 Set \u03b1) :\n    \u2203 t : \u2115 \u2192 Set \u03b1, Antitone t \u2227 \u2a05 i, \ud835\udcdf (s i) = \u2a05 i, \ud835\udcdf (t i)", "start": [1013, 1], "end": [1022, 8], "kind": "commanddeclaration"}, {"full_name": "Filter.countable_biInf_eq_iInf_seq", "code": "theorem countable_biInf_eq_iInf_seq [CompleteLattice \u03b1] {B : Set \u03b9} (Bcbl : B.Countable)\n    (Bne : B.Nonempty) (f : \u03b9 \u2192 \u03b1) : \u2203 x : \u2115 \u2192 \u03b9, \u2a05 t \u2208 B, f t = \u2a05 i, f (x i)", "start": [1025, 1], "end": [1028, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.countable_biInf_eq_iInf_seq'", "code": "theorem countable_biInf_eq_iInf_seq' [CompleteLattice \u03b1] {B : Set \u03b9} (Bcbl : B.Countable)\n    (f : \u03b9 \u2192 \u03b1) {i\u2080 : \u03b9} (h : f i\u2080 = \u22a4) : \u2203 x : \u2115 \u2192 \u03b9, \u2a05 t \u2208 B, f t = \u2a05 i, f (x i)", "start": [1031, 1], "end": [1037, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.countable_biInf_principal_eq_seq_iInf", "code": "theorem countable_biInf_principal_eq_seq_iInf {B : Set (Set \u03b1)} (Bcbl : B.Countable) :\n    \u2203 x : \u2115 \u2192 Set \u03b1, \u2a05 t \u2208 B, \ud835\udcdf t = \u2a05 i, \ud835\udcdf (x i)", "start": [1040, 1], "end": [1042, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.mem_iff", "code": "protected theorem HasAntitoneBasis.mem_iff [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n    (hs : l.HasAntitoneBasis s) {t : Set \u03b1} : t \u2208 l \u2194 \u2203 i, s i \u2286 t", "start": [1047, 1], "end": [1049, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.mem", "code": "protected theorem HasAntitoneBasis.mem [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n    (hs : l.HasAntitoneBasis s) (i : \u03b9) : s i \u2208 l", "start": [1052, 1], "end": [1054, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.hasBasis_ge", "code": "theorem HasAntitoneBasis.hasBasis_ge [Preorder \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] {l : Filter \u03b1}\n    {s : \u03b9 \u2192 Set \u03b1} (hs : l.HasAntitoneBasis s) (i : \u03b9) : l.HasBasis (fun j => i \u2264 j) s", "start": [1057, 1], "end": [1060, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.exists_antitone_subbasis", "code": "theorem HasBasis.exists_antitone_subbasis {f : Filter \u03b1} [h : f.IsCountablyGenerated]\n    {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set \u03b1} (hs : f.HasBasis p s) :\n    \u2203 x : \u2115 \u2192 \u03b9', (\u2200 i, p (x i)) \u2227 f.HasAntitoneBasis fun i => s (x i)", "start": [1063, 1], "end": [1090, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_antitone_basis", "code": "theorem exists_antitone_basis (f : Filter \u03b1) [f.IsCountablyGenerated] :\n    \u2203 x : \u2115 \u2192 Set \u03b1, f.HasAntitoneBasis x", "start": [1093, 1], "end": [1097, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_antitone_seq", "code": "theorem exists_antitone_seq (f : Filter \u03b1) [f.IsCountablyGenerated] :\n    \u2203 x : \u2115 \u2192 Set \u03b1, Antitone x \u2227 \u2200 {s}, s \u2208 f \u2194 \u2203 i, x i \u2286 s", "start": [1100, 1], "end": [1103, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Inf.isCountablyGenerated", "code": "instance Inf.isCountablyGenerated (f g : Filter \u03b1) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f \u2293 g) := by\n  rcases f.exists_antitone_basis with \u27e8s, hs\u27e9\n  rcases g.exists_antitone_basis with \u27e8t, ht\u27e9\n  exact HasCountableBasis.isCountablyGenerated \u27e8hs.1.inf ht.1, Set.to_countable _\u27e9", "start": [1106, 1], "end": [1110, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.map.isCountablyGenerated", "code": "instance map.isCountablyGenerated (l : Filter \u03b1) [l.IsCountablyGenerated] (f : \u03b1 \u2192 \u03b2) :\n    (map f l).IsCountablyGenerated :=\n  let \u27e8_x, hxl\u27e9 := l.exists_antitone_basis\n  HasCountableBasis.isCountablyGenerated \u27e8hxl.map.1, to_countable _\u27e9", "start": [1113, 1], "end": [1116, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.comap.isCountablyGenerated", "code": "instance comap.isCountablyGenerated (l : Filter \u03b2) [l.IsCountablyGenerated] (f : \u03b1 \u2192 \u03b2) :\n    (comap f l).IsCountablyGenerated :=\n  let \u27e8_x, hxl\u27e9 := l.exists_antitone_basis\n  HasCountableBasis.isCountablyGenerated \u27e8hxl.1.comap _, to_countable _\u27e9", "start": [1119, 1], "end": [1122, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.Sup.isCountablyGenerated", "code": "instance Sup.isCountablyGenerated (f g : Filter \u03b1) [IsCountablyGenerated f]\n    [IsCountablyGenerated g] : IsCountablyGenerated (f \u2294 g) := by\n  rcases f.exists_antitone_basis with \u27e8s, hs\u27e9\n  rcases g.exists_antitone_basis with \u27e8t, ht\u27e9\n  exact\n    HasCountableBasis.isCountablyGenerated \u27e8hs.1.sup ht.1, Set.to_countable _\u27e9", "start": [1125, 1], "end": [1130, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.prod.isCountablyGenerated", "code": "instance prod.isCountablyGenerated (la : Filter \u03b1) (lb : Filter \u03b2) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la \u00d7\u02e2 lb) :=\n  Filter.Inf.isCountablyGenerated _ _", "start": [1133, 1], "end": [1135, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod.isCountablyGenerated", "code": "instance coprod.isCountablyGenerated (la : Filter \u03b1) (lb : Filter \u03b2) [IsCountablyGenerated la]\n    [IsCountablyGenerated lb] : IsCountablyGenerated (la.coprod lb) :=\n  Filter.Sup.isCountablyGenerated _ _", "start": [1138, 1], "end": [1140, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_seq", "code": "theorem isCountablyGenerated_seq [Countable \u03b2] (x : \u03b2 \u2192 Set \u03b1) :\n    IsCountablyGenerated (\u2a05 i, \ud835\udcdf (x i))", "start": [1145, 1], "end": [1148, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_of_seq", "code": "theorem isCountablyGenerated_of_seq {f : Filter \u03b1} (h : \u2203 x : \u2115 \u2192 Set \u03b1, f = \u2a05 i, \ud835\udcdf (x i)) :\n    f.IsCountablyGenerated", "start": [1151, 1], "end": [1154, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_biInf_principal", "code": "theorem isCountablyGenerated_biInf_principal {B : Set (Set \u03b1)} (h : B.Countable) :\n    IsCountablyGenerated (\u2a05 s \u2208 B, \ud835\udcdf s)", "start": [1157, 1], "end": [1159, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_iff_exists_antitone_basis", "code": "theorem isCountablyGenerated_iff_exists_antitone_basis {f : Filter \u03b1} :\n    IsCountablyGenerated f \u2194 \u2203 x : \u2115 \u2192 Set \u03b1, f.HasAntitoneBasis x", "start": [1162, 1], "end": [1169, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_principal", "code": "@[instance]\ntheorem isCountablyGenerated_principal (s : Set \u03b1) : IsCountablyGenerated (\ud835\udcdf s)", "start": [1172, 1], "end": [1174, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_pure", "code": "@[instance]\ntheorem isCountablyGenerated_pure (a : \u03b1) : IsCountablyGenerated (pure a)", "start": [1177, 1], "end": [1180, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_bot", "code": "@[instance]\ntheorem isCountablyGenerated_bot : IsCountablyGenerated (\u22a5 : Filter \u03b1)", "start": [1183, 1], "end": [1185, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.isCountablyGenerated_top", "code": "@[instance]\ntheorem isCountablyGenerated_top : IsCountablyGenerated (\u22a4 : Filter \u03b1)", "start": [1188, 1], "end": [1190, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.iInf.isCountablyGenerated", "code": "instance iInf.isCountablyGenerated {\u03b9 : Sort u} {\u03b1 : Type v} [Countable \u03b9] (f : \u03b9 \u2192 Filter \u03b1)\n    [\u2200 i, IsCountablyGenerated (f i)] : IsCountablyGenerated (\u2a05 i, f i) := by\n  choose s hs using fun i => exists_antitone_basis (f i)\n  rw [\u2190 PLift.down_surjective.iInf_comp]\n  refine' HasCountableBasis.isCountablyGenerated \u27e8hasBasis_iInf fun n => (hs _).1, _\u27e9\n  refine' (countable_range <| Sigma.map ((\u2191) : Finset (PLift \u03b9) \u2192 Set (PLift \u03b9)) fun _ => id).mono _\n  rintro \u27e8I, f\u27e9 \u27e8hI, -\u27e9\n  lift I to Finset (PLift \u03b9) using hI\n  exact \u27e8\u27e8I, f\u27e9, rfl\u27e9", "start": [1196, 1], "end": [1204, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Disjoint.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Iic_disjoint_Ioi", "code": "@[simp]\ntheorem Iic_disjoint_Ioi (h : a \u2264 b) : Disjoint (Iic a) (Ioi b)", "start": [33, 1], "end": [35, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_disjoint_Ioc", "code": "@[simp]\ntheorem Iic_disjoint_Ioc (h : a \u2264 b) : Disjoint (Iic a) (Ioc b c)", "start": [38, 1], "end": [40, 53], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_disjoint_Ioc_same", "code": "@[simp]\ntheorem Ioc_disjoint_Ioc_same : Disjoint (Ioc a b) (Ioc b c)", "start": [43, 1], "end": [45, 66], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_disjoint_Ico_same", "code": "@[simp]\ntheorem Ico_disjoint_Ico_same : Disjoint (Ico a b) (Ico b c)", "start": [48, 1], "end": [50, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Ici_disjoint_Iic", "code": "@[simp]\ntheorem Ici_disjoint_Iic : Disjoint (Ici a) (Iic b) \u2194 \u00aca \u2264 b", "start": [53, 1], "end": [55, 72], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_disjoint_Ici", "code": "@[simp]\ntheorem Iic_disjoint_Ici : Disjoint (Iic a) (Ici b) \u2194 \u00acb \u2264 a", "start": [58, 1], "end": [60, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_disjoint_Ioi", "code": "@[simp]\ntheorem Ioc_disjoint_Ioi (h : b \u2264 c) : Disjoint (Ioc a b) (Ioi c)", "start": [63, 1], "end": [65, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_disjoint_Ioi_same", "code": "theorem Ioc_disjoint_Ioi_same : Disjoint (Ioc a b) (Ioi b)", "start": [67, 1], "end": [68, 26], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Iic", "code": "@[simp]\ntheorem iUnion_Iic : \u22c3 a : \u03b1, Iic a = univ", "start": [70, 1], "end": [72, 51], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ici", "code": "@[simp]\ntheorem iUnion_Ici : \u22c3 a : \u03b1, Ici a = univ", "start": [75, 1], "end": [77, 50], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Icc_right", "code": "@[simp]\ntheorem iUnion_Icc_right (a : \u03b1) : \u22c3 b, Icc a b = Ici a", "start": [80, 1], "end": [82, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioc_right", "code": "@[simp]\ntheorem iUnion_Ioc_right (a : \u03b1) : \u22c3 b, Ioc a b = Ioi a", "start": [85, 1], "end": [87, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Icc_left", "code": "@[simp]\ntheorem iUnion_Icc_left (b : \u03b1) : \u22c3 a, Icc a b = Iic b", "start": [90, 1], "end": [92, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ico_left", "code": "@[simp]\ntheorem iUnion_Ico_left (b : \u03b1) : \u22c3 a, Ico a b = Iio b", "start": [95, 1], "end": [97, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Iio", "code": "@[simp]\ntheorem iUnion_Iio [NoMaxOrder \u03b1] : \u22c3 a : \u03b1, Iio a = univ", "start": [100, 1], "end": [102, 33], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioi", "code": "@[simp]\ntheorem iUnion_Ioi [NoMinOrder \u03b1] : \u22c3 a : \u03b1, Ioi a = univ", "start": [105, 1], "end": [107, 33], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ico_right", "code": "@[simp]\ntheorem iUnion_Ico_right [NoMaxOrder \u03b1] (a : \u03b1) : \u22c3 b, Ico a b = Ici a", "start": [110, 1], "end": [112, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioo_right", "code": "@[simp]\ntheorem iUnion_Ioo_right [NoMaxOrder \u03b1] (a : \u03b1) : \u22c3 b, Ioo a b = Ioi a", "start": [115, 1], "end": [117, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioc_left", "code": "@[simp]\ntheorem iUnion_Ioc_left [NoMinOrder \u03b1] (b : \u03b1) : \u22c3 a, Ioc a b = Iic b", "start": [120, 1], "end": [122, 70], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioo_left", "code": "@[simp]\ntheorem iUnion_Ioo_left [NoMinOrder \u03b1] (b : \u03b1) : \u22c3 a, Ioo a b = Iio b", "start": [125, 1], "end": [127, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_disjoint_Ico", "code": "@[simp]\ntheorem Ico_disjoint_Ico : Disjoint (Ico a\u2081 a\u2082) (Ico b\u2081 b\u2082) \u2194 min a\u2082 b\u2082 \u2264 max a\u2081 b\u2081", "start": [136, 1], "end": [139, 12], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_disjoint_Ioc", "code": "@[simp]\ntheorem Ioc_disjoint_Ioc : Disjoint (Ioc a\u2081 a\u2082) (Ioc b\u2081 b\u2082) \u2194 min a\u2082 b\u2082 \u2264 max a\u2081 b\u2081", "start": [142, 1], "end": [145, 32], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_Ico_disjoint", "code": "theorem eq_of_Ico_disjoint {x\u2081 x\u2082 y\u2081 y\u2082 : \u03b1} (h : Disjoint (Ico x\u2081 x\u2082) (Ico y\u2081 y\u2082)) (hx : x\u2081 < x\u2082)\n    (h2 : x\u2082 \u2208 Ico y\u2081 y\u2082) : y\u2081 = x\u2082", "start": [148, 1], "end": [154, 56], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ico_eq_Iio_self_iff", "code": "@[simp]\ntheorem iUnion_Ico_eq_Iio_self_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 i, Ico (f i) a = Iio a \u2194 \u2200 x < a, \u2203 i, f i \u2264 x", "start": [157, 1], "end": [160, 53], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_Ioc_eq_Ioi_self_iff", "code": "@[simp]\ntheorem iUnion_Ioc_eq_Ioi_self_iff {f : \u03b9 \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 i, Ioc a (f i) = Ioi a \u2194 \u2200 x, a < x \u2192 \u2203 i, x \u2264 f i", "start": [163, 1], "end": [166, 53], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_Ico_eq_Iio_self_iff", "code": "@[simp]\ntheorem biUnion_Ico_eq_Iio_self_iff {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 (i) (hi : p i), Ico (f i hi) a = Iio a \u2194 \u2200 x < a, \u2203 i hi, f i hi \u2264 x", "start": [169, 1], "end": [172, 53], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_Ioc_eq_Ioi_self_iff", "code": "@[simp]\ntheorem biUnion_Ioc_eq_Ioi_self_iff {p : \u03b9 \u2192 Prop} {f : \u2200 i, p i \u2192 \u03b1} {a : \u03b1} :\n    \u22c3 (i) (hi : p i), Ioc a (f i hi) = Ioi a \u2194 \u2200 x, a < x \u2192 \u2203 i hi, x \u2264 f i hi", "start": [175, 1], "end": [178, 53], "kind": "commanddeclaration"}, {"full_name": "IsGLB.biUnion_Ioi_eq", "code": "theorem IsGLB.biUnion_Ioi_eq (h : IsGLB s a) : \u22c3 x \u2208 s, Ioi x = Ioi a", "start": [189, 1], "end": [193, 30], "kind": "commanddeclaration"}, {"full_name": "IsGLB.iUnion_Ioi_eq", "code": "theorem IsGLB.iUnion_Ioi_eq (h : IsGLB (range f) a) : \u22c3 x, Ioi (f x) = Ioi a", "start": [196, 1], "end": [197, 44], "kind": "commanddeclaration"}, {"full_name": "IsLUB.biUnion_Iio_eq", "code": "theorem IsLUB.biUnion_Iio_eq (h : IsLUB s a) : \u22c3 x \u2208 s, Iio x = Iio a", "start": [200, 1], "end": [201, 24], "kind": "commanddeclaration"}, {"full_name": "IsLUB.iUnion_Iio_eq", "code": "theorem IsLUB.iUnion_Iio_eq (h : IsLUB (range f) a) : \u22c3 x, Iio (f x) = Iio a", "start": [204, 1], "end": [205, 23], "kind": "commanddeclaration"}, {"full_name": "IsGLB.biUnion_Ici_eq_Ioi", "code": "theorem IsGLB.biUnion_Ici_eq_Ioi (a_glb : IsGLB s a) (a_not_mem : a \u2209 s) :\n    \u22c3 x \u2208 s, Ici x = Ioi a", "start": [208, 1], "end": [214, 29], "kind": "commanddeclaration"}, {"full_name": "IsGLB.biUnion_Ici_eq_Ici", "code": "theorem IsGLB.biUnion_Ici_eq_Ici (a_glb : IsGLB s a) (a_mem : a \u2208 s) :\n    \u22c3 x \u2208 s, Ici x = Ici a", "start": [217, 1], "end": [222, 27], "kind": "commanddeclaration"}, {"full_name": "IsLUB.biUnion_Iic_eq_Iio", "code": "theorem IsLUB.biUnion_Iic_eq_Iio (a_lub : IsLUB s a) (a_not_mem : a \u2209 s) :\n    \u22c3 x \u2208 s, Iic x = Iio a", "start": [225, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "IsLUB.biUnion_Iic_eq_Iic", "code": "theorem IsLUB.biUnion_Iic_eq_Iic (a_lub : IsLUB s a) (a_mem : a \u2208 s) : \u22c3 x \u2208 s, Iic x = Iic a", "start": [230, 1], "end": [231, 38], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ici_eq_Ioi_iInf", "code": "theorem iUnion_Ici_eq_Ioi_iInf {R : Type*} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n    (no_least_elem : \u2a05 i, f i \u2209 range f) : \u22c3 i : \u03b9, Ici (f i) = Ioi (\u2a05 i, f i)", "start": [234, 1], "end": [237, 38], "kind": "commanddeclaration"}, {"full_name": "iUnion_Iic_eq_Iio_iSup", "code": "theorem iUnion_Iic_eq_Iio_iSup {R : Type*} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n    (no_greatest_elem : (\u2a06 i, f i) \u2209 range f) : \u22c3 i : \u03b9, Iic (f i) = Iio (\u2a06 i, f i)", "start": [240, 1], "end": [242, 63], "kind": "commanddeclaration"}, {"full_name": "iUnion_Ici_eq_Ici_iInf", "code": "theorem iUnion_Ici_eq_Ici_iInf {R : Type*} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n    (has_least_elem : (\u2a05 i, f i) \u2208 range f) : \u22c3 i : \u03b9, Ici (f i) = Ici (\u2a05 i, f i)", "start": [245, 1], "end": [248, 38], "kind": "commanddeclaration"}, {"full_name": "iUnion_Iic_eq_Iic_iSup", "code": "theorem iUnion_Iic_eq_Iic_iSup {R : Type*} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n    (has_greatest_elem : (\u2a06 i, f i) \u2208 range f) : \u22c3 i : \u03b9, Iic (f i) = Iic (\u2a06 i, f i)", "start": [251, 1], "end": [253, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Preimage.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Set/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.preimage", "code": "noncomputable def preimage (s : Finset \u03b2) (f : \u03b1 \u2192 \u03b2) (hf : Set.InjOn f (f \u207b\u00b9' \u2191s)) : Finset \u03b1 :=\n  (s.finite_toSet.preimage hf).toFinset", "start": [28, 1], "end": [30, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_preimage", "code": "@[simp]\ntheorem mem_preimage {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b2} {hf : Set.InjOn f (f \u207b\u00b9' \u2191s)} {x : \u03b1} :\n    x \u2208 preimage s f hf \u2194 f x \u2208 s", "start": [33, 1], "end": [36, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_preimage", "code": "@[simp, norm_cast]\ntheorem coe_preimage {f : \u03b1 \u2192 \u03b2} (s : Finset \u03b2) (hf : Set.InjOn f (f \u207b\u00b9' \u2191s)) :\n    (\u2191(preimage s f hf) : Set \u03b1) = f \u207b\u00b9' \u2191s", "start": [39, 1], "end": [42, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_empty", "code": "@[simp]\ntheorem preimage_empty {f : \u03b1 \u2192 \u03b2} : preimage \u2205 f (by simp [InjOn]) = \u2205", "start": [45, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_univ", "code": "@[simp]\ntheorem preimage_univ {f : \u03b1 \u2192 \u03b2} [Fintype \u03b1] [Fintype \u03b2] (hf) : preimage univ f hf = univ", "start": [50, 1], "end": [52, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_inter", "code": "@[simp]\ntheorem preimage_inter [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Finset \u03b2}\n    (hs : Set.InjOn f (f \u207b\u00b9' \u2191s)) (ht : Set.InjOn f (f \u207b\u00b9' \u2191t)) :\n    (preimage (s \u2229 t) f fun x\u2081 hx\u2081 x\u2082 hx\u2082 =>\n        hs (mem_of_mem_inter_left hx\u2081) (mem_of_mem_inter_left hx\u2082)) =\n      preimage s f hs \u2229 preimage t f ht", "start": [55, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_union", "code": "@[simp]\ntheorem preimage_union [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Finset \u03b2} (hst) :\n    preimage (s \u222a t) f hst =\n      (preimage s f fun x\u2081 hx\u2081 x\u2082 hx\u2082 => hst (mem_union_left _ hx\u2081) (mem_union_left _ hx\u2082)) \u222a\n        preimage t f fun x\u2081 hx\u2081 x\u2082 hx\u2082 => hst (mem_union_right _ hx\u2081) (mem_union_right _ hx\u2082)", "start": [64, 1], "end": [69, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_compl", "code": "@[simp, nolint simpNF] theorem preimage_compl [DecidableEq \u03b1] [DecidableEq \u03b2] [Fintype \u03b1] [Fintype \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (s : Finset \u03b2) (hf : Function.Injective f) :\n    preimage s\u1d9c f (hf.injOn _) = (preimage s f (hf.injOn _))\u1d9c", "start": [72, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.monotone_preimage", "code": "theorem monotone_preimage {f : \u03b1 \u2192 \u03b2} (h : Injective f) :\n    Monotone fun s => preimage s f (h.injOn _)", "start": [79, 1], "end": [81, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_iff_subset_preimage", "code": "theorem image_subset_iff_subset_preimage [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2}\n    (hf : Set.InjOn f (f \u207b\u00b9' \u2191t)) : s.image f \u2286 t \u2194 s \u2286 t.preimage f hf", "start": [84, 1], "end": [86, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subset_iff_subset_preimage", "code": "theorem map_subset_iff_subset_preimage {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b1} {t : Finset \u03b2} :\n    s.map f \u2286 t \u2194 s \u2286 t.preimage f (f.injective.injOn _)", "start": [89, 1], "end": [91, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.image_preimage", "code": "theorem image_preimage [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b2) [\u2200 x, Decidable (x \u2208 Set.range f)]\n    (hf : Set.InjOn f (f \u207b\u00b9' \u2191s)) : image f (preimage s f hf) = s.filter fun x => x \u2208 Set.range f", "start": [94, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.image_preimage_of_bij", "code": "theorem image_preimage_of_bij [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Finset \u03b2)\n    (hf : Set.BijOn f (f \u207b\u00b9' \u2191s) \u2191s) : image f (preimage s f hf.injOn) = s", "start": [101, 1], "end": [103, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_subset", "code": "theorem preimage_subset {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b2} {t : Finset \u03b1} (hs : s \u2286 t.map f) :\n    s.preimage f (f.injective.injOn _) \u2286 t", "start": [106, 1], "end": [107, 96], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_map_iff", "code": "theorem subset_map_iff {f : \u03b1 \u21aa \u03b2} {s : Finset \u03b2} {t : Finset \u03b1} :\n    s \u2286 t.map f \u2194 \u2203 (u : _) (_ : u \u2286 t), s = u.map f", "start": [110, 1], "end": [117, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_preimage_mk", "code": "theorem sigma_preimage_mk {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] (s : Finset (\u03a3a, \u03b2 a)) (t : Finset \u03b1) :\n    (t.sigma fun a => s.preimage (Sigma.mk a) <| sigma_mk_injective.injOn _) =\n      s.filter fun a => a.1 \u2208 t", "start": [120, 1], "end": [124, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_preimage_mk_of_subset", "code": "theorem sigma_preimage_mk_of_subset {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] (s : Finset (\u03a3a, \u03b2 a))\n    {t : Finset \u03b1} (ht : s.image Sigma.fst \u2286 t) :\n    (t.sigma fun a => s.preimage (Sigma.mk a) <| sigma_mk_injective.injOn _) = s", "start": [127, 1], "end": [130, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.sigma_image_fst_preimage_mk", "code": "theorem sigma_image_fst_preimage_mk {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] (s : Finset (\u03a3a, \u03b2 a)) :\n    ((s.image Sigma.fst).sigma fun a => s.preimage (Sigma.mk a) <| sigma_mk_injective.injOn _) =\n      s", "start": [133, 1], "end": [136, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_preimage'", "code": "@[to_additive]\ntheorem prod_preimage' [CommMonoid \u03b2] (f : \u03b1 \u2192 \u03b3) [DecidablePred fun x => x \u2208 Set.range f]\n    (s : Finset \u03b3) (hf : Set.InjOn f (f \u207b\u00b9' \u2191s)) (g : \u03b3 \u2192 \u03b2) :\n    (\u220f x in s.preimage f hf, g (f x)) = \u220f x in s.filter fun x => x \u2208 Set.range f, g x", "start": [141, 1], "end": [149, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_preimage", "code": "@[to_additive]\ntheorem prod_preimage [CommMonoid \u03b2] (f : \u03b1 \u2192 \u03b3) (s : Finset \u03b3) (hf : Set.InjOn f (f \u207b\u00b9' \u2191s))\n    (g : \u03b3 \u2192 \u03b2) (hg : \u2200 x \u2208 s, x \u2209 Set.range f \u2192 g x = 1) :\n    (\u220f x in s.preimage f hf, g (f x)) = \u220f x in s, g x", "start": [153, 1], "end": [159, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_preimage_of_bij", "code": "@[to_additive]\ntheorem prod_preimage_of_bij [CommMonoid \u03b2] (f : \u03b1 \u2192 \u03b3) (s : Finset \u03b3)\n    (hf : Set.BijOn f (f \u207b\u00b9' \u2191s) \u2191s) (g : \u03b3 \u2192 \u03b2) :\n    (\u220f x in s.preimage f hf.injOn, g (f x)) = \u220f x in s, g x", "start": [163, 1], "end": [167, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "imports": ["Mathlib/Order/Bounds/Basic.lean", "Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Order/WellFounded.lean"], "premises": [{"full_name": "WithTop.instSupSet", "code": "noncomputable instance WithTop.instSupSet {\u03b1 : Type*} [Preorder \u03b1] [SupSet \u03b1] :\n    SupSet (WithTop \u03b1) :=\n  \u27e8fun S =>\n    if \u22a4 \u2208 S then \u22a4 else if BddAbove ((fun (a : \u03b1) \u21a6 \u2191a) \u207b\u00b9' S : Set \u03b1) then\n      \u2191(sSup ((fun (a : \u03b1) \u21a6 (a : WithTop \u03b1)) \u207b\u00b9' S : Set \u03b1)) else \u22a4\u27e9", "start": [47, 1], "end": [51, 70], "kind": "commanddeclaration"}, {"full_name": "WithTop.instInfSet", "code": "noncomputable instance WithTop.instInfSet {\u03b1 : Type*} [InfSet \u03b1] : InfSet (WithTop \u03b1) :=\n  \u27e8fun S => if S \u2286 {\u22a4} then \u22a4 else \u2191(sInf ((fun (a : \u03b1) \u21a6 \u2191a) \u207b\u00b9' S : Set \u03b1))\u27e9", "start": [53, 1], "end": [54, 79], "kind": "commanddeclaration"}, {"full_name": "WithBot.instSupSet", "code": "noncomputable instance WithBot.instSupSet {\u03b1 : Type*} [SupSet \u03b1] : SupSet (WithBot \u03b1) :=\n  \u27e8(@WithTop.instInfSet \u03b1\u1d52\u1d48 _).sInf\u27e9", "start": [56, 1], "end": [57, 37], "kind": "commanddeclaration"}, {"full_name": "WithBot.instInfSet", "code": "noncomputable instance WithBot.instInfSet {\u03b1 : Type*} [Preorder \u03b1] [InfSet \u03b1] :\n    InfSet (WithBot \u03b1) :=\n  \u27e8(@WithTop.instSupSet \u03b1\u1d52\u1d48 _).sSup\u27e9", "start": [59, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "WithTop.sSup_eq", "code": "theorem WithTop.sSup_eq [Preorder \u03b1] [SupSet \u03b1] {s : Set (WithTop \u03b1)} (hs : \u22a4 \u2209 s)\n    (hs' : BddAbove ((\u2191) \u207b\u00b9' s : Set \u03b1)) : sSup s = \u2191(sSup ((\u2191) \u207b\u00b9' s) : \u03b1)", "start": [63, 1], "end": [65, 33], "kind": "commanddeclaration"}, {"full_name": "WithTop.sInf_eq", "code": "theorem WithTop.sInf_eq [InfSet \u03b1] {s : Set (WithTop \u03b1)} (hs : \u00acs \u2286 {\u22a4}) :\n    sInf s = \u2191(sInf ((\u2191) \u207b\u00b9' s) : \u03b1)", "start": [68, 1], "end": [70, 12], "kind": "commanddeclaration"}, {"full_name": "WithBot.sInf_eq", "code": "theorem WithBot.sInf_eq [Preorder \u03b1] [InfSet \u03b1] {s : Set (WithBot \u03b1)} (hs : \u22a5 \u2209 s)\n    (hs' : BddBelow ((\u2191) \u207b\u00b9' s : Set \u03b1)) : sInf s = \u2191(sInf ((\u2191) \u207b\u00b9' s) : \u03b1)", "start": [73, 1], "end": [75, 33], "kind": "commanddeclaration"}, {"full_name": "WithBot.sSup_eq", "code": "theorem WithBot.sSup_eq [SupSet \u03b1] {s : Set (WithBot \u03b1)} (hs : \u00acs \u2286 {\u22a5}) :\n    sSup s = \u2191(sSup ((\u2191) \u207b\u00b9' s) : \u03b1)", "start": [78, 1], "end": [80, 12], "kind": "commanddeclaration"}, {"full_name": "WithTop.sInf_empty", "code": "@[simp]\ntheorem WithTop.sInf_empty {\u03b1 : Type*} [InfSet \u03b1] : sInf (\u2205 : Set (WithTop \u03b1)) = \u22a4", "start": [83, 1], "end": [85, 31], "kind": "commanddeclaration"}, {"full_name": "WithTop.iInf_empty", "code": "@[simp]\ntheorem WithTop.iInf_empty {\u03b1 : Type*} [IsEmpty \u03b9] [InfSet \u03b1] (f : \u03b9 \u2192 WithTop \u03b1) :\n    \u2a05 i, f i = \u22a4", "start": [88, 1], "end": [90, 69], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sInf'", "code": "theorem WithTop.coe_sInf' [InfSet \u03b1] {s : Set \u03b1} (hs : s.Nonempty) :\n    \u2191(sInf s) = (sInf ((fun (a : \u03b1) \u21a6 \u2191a) '' s) : WithTop \u03b1)", "start": [93, 1], "end": [100, 34], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_iInf", "code": "@[norm_cast]\ntheorem WithTop.coe_iInf [Nonempty \u03b9] [InfSet \u03b1] (f : \u03b9 \u2192 \u03b1) :\n    \u2191(\u2a05 i, f i) = (\u2a05 i, f i : WithTop \u03b1)", "start": [105, 1], "end": [108, 75], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sSup'", "code": "theorem WithTop.coe_sSup' [Preorder \u03b1] [SupSet \u03b1] {s : Set \u03b1} (hs : BddAbove s) :\n    \u2191(sSup s) = (sSup ((fun (a : \u03b1) \u21a6 \u2191a) '' s) : WithTop \u03b1)", "start": [111, 1], "end": [116, 22], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_iSup", "code": "@[norm_cast]\ntheorem WithTop.coe_iSup [Preorder \u03b1] [SupSet \u03b1] (f : \u03b9 \u2192 \u03b1) (h : BddAbove (Set.range f)) :\n    \u2191(\u2a06 i, f i) = (\u2a06 i, f i : WithTop \u03b1)", "start": [121, 1], "end": [124, 60], "kind": "commanddeclaration"}, {"full_name": "WithBot.csSup_empty", "code": "@[simp]\ntheorem WithBot.csSup_empty {\u03b1 : Type*} [SupSet \u03b1] : sSup (\u2205 : Set (WithBot \u03b1)) = \u22a5", "start": [127, 1], "end": [129, 31], "kind": "commanddeclaration"}, {"full_name": "WithBot.ciSup_empty", "code": "@[simp]\ntheorem WithBot.ciSup_empty {\u03b1 : Type*} [IsEmpty \u03b9] [SupSet \u03b1] (f : \u03b9 \u2192 WithBot \u03b1) :\n    \u2a06 i, f i = \u22a5", "start": [132, 1], "end": [135, 34], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_sSup'", "code": "@[norm_cast]\ntheorem WithBot.coe_sSup' [SupSet \u03b1] {s : Set \u03b1} (hs : s.Nonempty) :\n    \u2191(sSup s) = (sSup ((fun (a : \u03b1) \u21a6 \u2191a) '' s) : WithBot \u03b1)", "start": [138, 1], "end": [141, 32], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_iSup", "code": "@[norm_cast]\ntheorem WithBot.coe_iSup [Nonempty \u03b9] [SupSet \u03b1] (f : \u03b9 \u2192 \u03b1) :\n    \u2191(\u2a06 i, f i) = (\u2a06 i, f i : WithBot \u03b1)", "start": [144, 1], "end": [147, 32], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_sInf'", "code": "@[norm_cast]\ntheorem WithBot.coe_sInf' [Preorder \u03b1] [InfSet \u03b1] {s : Set \u03b1} (hs : BddBelow s) :\n    \u2191(sInf s) = (sInf ((fun (a : \u03b1) \u21a6 \u2191a) '' s) : WithBot \u03b1)", "start": [150, 1], "end": [153, 34], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_iInf", "code": "@[norm_cast]\ntheorem WithBot.coe_iInf [Preorder \u03b1] [InfSet \u03b1] (f : \u03b9 \u2192 \u03b1) (h : BddBelow (Set.range f)) :\n    \u2191(\u2a05 i, f i) = (\u2a05 i, f i : WithBot \u03b1)", "start": [156, 1], "end": [159, 34], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLattice", "code": "class ConditionallyCompleteLattice (\u03b1 : Type*) extends Lattice \u03b1, SupSet \u03b1, InfSet \u03b1 where\n  \n  le_csSup : \u2200 s a, BddAbove s \u2192 a \u2208 s \u2192 a \u2264 sSup s\n  \n  csSup_le : \u2200 s a, Set.Nonempty s \u2192 a \u2208 upperBounds s \u2192 sSup s \u2264 a\n  \n  csInf_le : \u2200 s a, BddBelow s \u2192 a \u2208 s \u2192 sInf s \u2264 a\n  \n  le_csInf : \u2200 s a, Set.Nonempty s \u2192 a \u2208 lowerBounds s \u2192 a \u2264 sInf s", "start": [164, 1], "end": [181, 68], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLinearOrder", "code": "class ConditionallyCompleteLinearOrder (\u03b1 : Type*) extends ConditionallyCompleteLattice \u03b1 where\n  \n  le_total (a b : \u03b1) : a \u2264 b \u2228 b \u2264 a\n  \n  decidableLE : DecidableRel (\u00b7 \u2264 \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop)\n  \n  decidableEq : DecidableEq \u03b1 := @decidableEqOfDecidableLE _ _ decidableLE\n  \n  decidableLT : DecidableRel (\u00b7 < \u00b7 : \u03b1 \u2192 \u03b1 \u2192 Prop) :=\n    @decidableLTOfDecidableLE _ _ decidableLE\n  \n  csSup_of_not_bddAbove : \u2200 s, \u00acBddAbove s \u2192 sSup s = sSup (\u2205 : Set \u03b1)\n  \n  csInf_of_not_bddBelow : \u2200 s, \u00acBddBelow s \u2192 sInf s = sInf (\u2205 : Set \u03b1)", "start": [185, 1], "end": [207, 71], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLinearOrderBot", "code": "class ConditionallyCompleteLinearOrderBot (\u03b1 : Type*) extends ConditionallyCompleteLinearOrder \u03b1,\n  Bot \u03b1 where\n  \n  bot_le : \u2200 x : \u03b1, \u22a5 \u2264 x\n  \n  csSup_empty : sSup \u2205 = \u22a5", "start": [226, 1], "end": [239, 27], "kind": "commanddeclaration"}, {"full_name": "ConditionallyCompleteLinearOrderBot.toOrderBot", "code": "instance (priority := 100) ConditionallyCompleteLinearOrderBot.toOrderBot\n    [h : ConditionallyCompleteLinearOrderBot \u03b1] : OrderBot \u03b1 :=\n  { h with }", "start": [243, 1], "end": [245, 13], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.toConditionallyCompleteLattice", "code": "instance (priority := 100) CompleteLattice.toConditionallyCompleteLattice [CompleteLattice \u03b1] :\n    ConditionallyCompleteLattice \u03b1 :=\n  { \u2039CompleteLattice \u03b1\u203a with\n    le_csSup := by intros; apply le_sSup; assumption\n    csSup_le := by intros; apply sSup_le; assumption\n    csInf_le := by intros; apply sInf_le; assumption\n    le_csInf := by intros; apply le_sInf; assumption }", "start": [249, 1], "end": [257, 55], "kind": "commanddeclaration"}, {"full_name": "CompleteLinearOrder.toConditionallyCompleteLinearOrderBot", "code": "instance (priority := 100) CompleteLinearOrder.toConditionallyCompleteLinearOrderBot {\u03b1 : Type*}\n    [h : CompleteLinearOrder \u03b1] : ConditionallyCompleteLinearOrderBot \u03b1 :=\n  { CompleteLattice.toConditionallyCompleteLattice, h with\n    csSup_empty := sSup_empty\n    csSup_of_not_bddAbove := fun s H \u21a6 (H (OrderTop.bddAbove s)).elim\n    csInf_of_not_bddBelow := fun s H \u21a6 (H (OrderBot.bddBelow s)).elim }", "start": [261, 1], "end": [266, 72], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder.conditionallyCompleteLinearOrderBot", "code": "@[reducible]\nnoncomputable def IsWellOrder.conditionallyCompleteLinearOrderBot (\u03b1 : Type*)\n  [i\u2081 : _root_.LinearOrder \u03b1] [i\u2082 : OrderBot \u03b1] [h : IsWellOrder \u03b1 (\u00b7 < \u00b7)] :\n    ConditionallyCompleteLinearOrderBot \u03b1 :=\n  { i\u2081, i\u2082, LinearOrder.toLattice with\n    sInf := fun s => if hs : s.Nonempty then h.wf.min s hs else \u22a5\n    csInf_le := fun s a _ has => by\n      have s_ne : s.Nonempty := \u27e8a, has\u27e9\n      simpa [s_ne] using not_lt.1 (h.wf.not_lt_min s s_ne has)\n    le_csInf := fun s a hs has => by\n      simp only [hs, dif_pos]\n      exact has (h.wf.min_mem s hs)\n    sSup := fun s => if hs : (upperBounds s).Nonempty then h.wf.min _ hs else \u22a5\n    le_csSup := fun s a hs has => by\n      have h's : (upperBounds s).Nonempty := hs\n      simp only [h's, dif_pos]\n      exact h.wf.min_mem _ h's has\n    csSup_le := fun s a _ has => by\n      have h's : (upperBounds s).Nonempty := \u27e8a, has\u27e9\n      simp only [h's, dif_pos]\n      simpa using h.wf.not_lt_min _ h's has\n    csSup_empty := by simpa using eq_bot_iff.2 (not_lt.1 <| h.wf.not_lt_min _ _ <| mem_univ \u22a5)\n    csSup_of_not_bddAbove := by\n      intro s H\n      have B : \u00ac((upperBounds s).Nonempty) := H\n      simp only [B, dite_false, upperBounds_empty, univ_nonempty, dite_true]\n      exact le_antisymm bot_le (WellFounded.min_le _ (mem_univ _))\n    csInf_of_not_bddBelow := fun s H \u21a6 (H (OrderBot.bddBelow s)).elim }", "start": [273, 1], "end": [301, 72], "kind": "commanddeclaration"}, {"full_name": "instConditionallyCompleteLatticeOrderDual", "code": "instance instConditionallyCompleteLatticeOrderDual (\u03b1 : Type*) [ConditionallyCompleteLattice \u03b1] :\n    ConditionallyCompleteLattice \u03b1\u1d52\u1d48 :=\n  { instInfOrderDual \u03b1, instSupOrderDual \u03b1, OrderDual.lattice \u03b1 with\n    le_csSup := @ConditionallyCompleteLattice.csInf_le \u03b1 _\n    csSup_le := @ConditionallyCompleteLattice.le_csInf \u03b1 _\n    le_csInf := @ConditionallyCompleteLattice.csSup_le \u03b1 _\n    csInf_le := @ConditionallyCompleteLattice.le_csSup \u03b1 _ }", "start": [308, 1], "end": [314, 61], "kind": "commanddeclaration"}, {"full_name": "conditionallyCompleteLatticeOfsSup", "code": "def conditionallyCompleteLatticeOfsSup (\u03b1 : Type*) [H1 : PartialOrder \u03b1] [H2 : SupSet \u03b1]\n    (bddAbove_pair : \u2200 a b : \u03b1, BddAbove ({a, b} : Set \u03b1))\n    (bddBelow_pair : \u2200 a b : \u03b1, BddBelow ({a, b} : Set \u03b1))\n    (isLUB_sSup : \u2200 s : Set \u03b1, BddAbove s \u2192 s.Nonempty \u2192 IsLUB s (sSup s)) :\n    ConditionallyCompleteLattice \u03b1 :=\n  { H1, H2 with\n    sup := fun a b => sSup {a, b}\n    le_sup_left := fun a b =>\n      (isLUB_sSup {a, b} (bddAbove_pair a b) (insert_nonempty _ _)).1 (mem_insert _ _)\n    le_sup_right := fun a b =>\n      (isLUB_sSup {a, b} (bddAbove_pair a b) (insert_nonempty _ _)).1\n        (mem_insert_of_mem _ (mem_singleton _))\n    sup_le := fun a b _ hac hbc =>\n      (isLUB_sSup {a, b} (bddAbove_pair a b) (insert_nonempty _ _)).2\n        (forall_insert_of_forall (forall_eq.mpr hbc) hac)\n    inf := fun a b => sSup (lowerBounds {a, b})\n    inf_le_left := fun a b =>\n      (isLUB_sSup (lowerBounds {a, b}) (Nonempty.bddAbove_lowerBounds \u27e8a, mem_insert _ _\u27e9)\n            (bddBelow_pair a b)).2\n        fun _ hc => hc <| mem_insert _ _\n    inf_le_right := fun a b =>\n      (isLUB_sSup (lowerBounds {a, b}) (Nonempty.bddAbove_lowerBounds \u27e8a, mem_insert _ _\u27e9)\n            (bddBelow_pair a b)).2\n        fun _ hc => hc <| mem_insert_of_mem _ (mem_singleton _)\n    le_inf := fun c a b hca hcb =>\n      (isLUB_sSup (lowerBounds {a, b}) (Nonempty.bddAbove_lowerBounds \u27e8a, mem_insert _ _\u27e9)\n            \u27e8c, forall_insert_of_forall (forall_eq.mpr hcb) hca\u27e9).1\n        (forall_insert_of_forall (forall_eq.mpr hcb) hca)\n    sInf := fun s => sSup (lowerBounds s)\n    csSup_le := fun s a hs ha => (isLUB_sSup s \u27e8a, ha\u27e9 hs).2 ha\n    le_csSup := fun s a hs ha => (isLUB_sSup s hs \u27e8a, ha\u27e9).1 ha\n    csInf_le := fun s a hs ha =>\n      (isLUB_sSup (lowerBounds s) (Nonempty.bddAbove_lowerBounds \u27e8a, ha\u27e9) hs).2 fun _ hb => hb ha\n    le_csInf := fun s a hs ha =>\n      (isLUB_sSup (lowerBounds s) hs.bddAbove_lowerBounds \u27e8a, ha\u27e9).1 ha }", "start": [323, 1], "end": [372, 74], "kind": "commanddeclaration"}, {"full_name": "conditionallyCompleteLatticeOfsInf", "code": "def conditionallyCompleteLatticeOfsInf (\u03b1 : Type*) [H1 : PartialOrder \u03b1] [H2 : InfSet \u03b1]\n    (bddAbove_pair : \u2200 a b : \u03b1, BddAbove ({a, b} : Set \u03b1))\n    (bddBelow_pair : \u2200 a b : \u03b1, BddBelow ({a, b} : Set \u03b1))\n    (isGLB_sInf : \u2200 s : Set \u03b1, BddBelow s \u2192 s.Nonempty \u2192 IsGLB s (sInf s)) :\n    ConditionallyCompleteLattice \u03b1 :=\n  { H1, H2 with\n    inf := fun a b => sInf {a, b}\n    inf_le_left := fun a b =>\n      (isGLB_sInf {a, b} (bddBelow_pair a b) (insert_nonempty _ _)).1 (mem_insert _ _)\n    inf_le_right := fun a b =>\n      (isGLB_sInf {a, b} (bddBelow_pair a b) (insert_nonempty _ _)).1\n        (mem_insert_of_mem _ (mem_singleton _))\n    le_inf := fun _ a b hca hcb =>\n      (isGLB_sInf {a, b} (bddBelow_pair a b) (insert_nonempty _ _)).2\n        (forall_insert_of_forall (forall_eq.mpr hcb) hca)\n    sup := fun a b => sInf (upperBounds {a, b})\n    le_sup_left := fun a b =>\n      (isGLB_sInf (upperBounds {a, b}) (Nonempty.bddBelow_upperBounds \u27e8a, mem_insert _ _\u27e9)\n            (bddAbove_pair a b)).2\n        fun _ hc => hc <| mem_insert _ _\n    le_sup_right := fun a b =>\n      (isGLB_sInf (upperBounds {a, b}) (Nonempty.bddBelow_upperBounds \u27e8a, mem_insert _ _\u27e9)\n            (bddAbove_pair a b)).2\n        fun _ hc => hc <| mem_insert_of_mem _ (mem_singleton _)\n    sup_le := fun a b c hac hbc =>\n      (isGLB_sInf (upperBounds {a, b}) (Nonempty.bddBelow_upperBounds \u27e8a, mem_insert _ _\u27e9)\n            \u27e8c, forall_insert_of_forall (forall_eq.mpr hbc) hac\u27e9).1\n        (forall_insert_of_forall (forall_eq.mpr hbc) hac)\n    sSup := fun s => sInf (upperBounds s)\n    le_csInf := fun s a hs ha => (isGLB_sInf s \u27e8a, ha\u27e9 hs).2 ha\n    csInf_le := fun s a hs ha => (isGLB_sInf s hs \u27e8a, ha\u27e9).1 ha\n    le_csSup := fun s a hs ha =>\n      (isGLB_sInf (upperBounds s) (Nonempty.bddBelow_upperBounds \u27e8a, ha\u27e9) hs).2 fun _ hb => hb ha\n    csSup_le := fun s a hs ha =>\n      (isGLB_sInf (upperBounds s) hs.bddBelow_upperBounds \u27e8a, ha\u27e9).1 ha }", "start": [375, 1], "end": [424, 74], "kind": "commanddeclaration"}, {"full_name": "conditionallyCompleteLatticeOfLatticeOfsSup", "code": "def conditionallyCompleteLatticeOfLatticeOfsSup (\u03b1 : Type*) [H1 : Lattice \u03b1] [SupSet \u03b1]\n    (isLUB_sSup : \u2200 s : Set \u03b1, BddAbove s \u2192 s.Nonempty \u2192 IsLUB s (sSup s)) :\n    ConditionallyCompleteLattice \u03b1 :=\n  { H1,\n    conditionallyCompleteLatticeOfsSup \u03b1\n      (fun a b => \u27e8a \u2294 b, forall_insert_of_forall (forall_eq.mpr le_sup_right) le_sup_left\u27e9)\n      (fun a b => \u27e8a \u2293 b, forall_insert_of_forall (forall_eq.mpr inf_le_right) inf_le_left\u27e9)\n      isLUB_sSup with }", "start": [427, 1], "end": [437, 24], "kind": "commanddeclaration"}, {"full_name": "conditionallyCompleteLatticeOfLatticeOfsInf", "code": "def conditionallyCompleteLatticeOfLatticeOfsInf (\u03b1 : Type*) [H1 : Lattice \u03b1] [InfSet \u03b1]\n    (isGLB_sInf : \u2200 s : Set \u03b1, BddBelow s \u2192 s.Nonempty \u2192 IsGLB s (sInf s)) :\n    ConditionallyCompleteLattice \u03b1 :=\n  { H1,\n    conditionallyCompleteLatticeOfsInf \u03b1\n      (fun a b => \u27e8a \u2294 b, forall_insert_of_forall (forall_eq.mpr le_sup_right) le_sup_left\u27e9)\n      (fun a b => \u27e8a \u2293 b, forall_insert_of_forall (forall_eq.mpr inf_le_right) inf_le_left\u27e9)\n      isGLB_sInf with }", "start": [440, 1], "end": [450, 24], "kind": "commanddeclaration"}, {"full_name": "le_csSup", "code": "theorem le_csSup (h\u2081 : BddAbove s) (h\u2082 : a \u2208 s) : a \u2264 sSup s", "start": [457, 1], "end": [458, 50], "kind": "commanddeclaration"}, {"full_name": "csSup_le", "code": "theorem csSup_le (h\u2081 : s.Nonempty) (h\u2082 : \u2200 b \u2208 s, b \u2264 a) : sSup s \u2264 a", "start": [461, 1], "end": [462, 50], "kind": "commanddeclaration"}, {"full_name": "csInf_le", "code": "theorem csInf_le (h\u2081 : BddBelow s) (h\u2082 : a \u2208 s) : sInf s \u2264 a", "start": [465, 1], "end": [466, 50], "kind": "commanddeclaration"}, {"full_name": "le_csInf", "code": "theorem le_csInf (h\u2081 : s.Nonempty) (h\u2082 : \u2200 b \u2208 s, a \u2264 b) : a \u2264 sInf s", "start": [469, 1], "end": [470, 50], "kind": "commanddeclaration"}, {"full_name": "le_csSup_of_le", "code": "theorem le_csSup_of_le (hs : BddAbove s) (hb : b \u2208 s) (h : a \u2264 b) : a \u2264 sSup s", "start": [473, 1], "end": [474, 30], "kind": "commanddeclaration"}, {"full_name": "csInf_le_of_le", "code": "theorem csInf_le_of_le (hs : BddBelow s) (hb : b \u2208 s) (h : b \u2264 a) : sInf s \u2264 a", "start": [477, 1], "end": [478, 30], "kind": "commanddeclaration"}, {"full_name": "csSup_le_csSup", "code": "theorem csSup_le_csSup (ht : BddAbove t) (hs : s.Nonempty) (h : s \u2286 t) : sSup s \u2264 sSup t", "start": [481, 1], "end": [482, 45], "kind": "commanddeclaration"}, {"full_name": "csInf_le_csInf", "code": "theorem csInf_le_csInf (ht : BddBelow t) (hs : s.Nonempty) (h : s \u2286 t) : sInf t \u2264 sInf s", "start": [485, 1], "end": [486, 45], "kind": "commanddeclaration"}, {"full_name": "le_csSup_iff", "code": "theorem le_csSup_iff (h : BddAbove s) (hs : s.Nonempty) :\n    a \u2264 sSup s \u2194 \u2200 b, b \u2208 upperBounds s \u2192 a \u2264 b", "start": [489, 1], "end": [491, 82], "kind": "commanddeclaration"}, {"full_name": "csInf_le_iff", "code": "theorem csInf_le_iff (h : BddBelow s) (hs : s.Nonempty) : sInf s \u2264 a \u2194 \u2200 b \u2208 lowerBounds s, b \u2264 a", "start": [494, 1], "end": [495, 82], "kind": "commanddeclaration"}, {"full_name": "isLUB_csSup", "code": "theorem isLUB_csSup (ne : s.Nonempty) (H : BddAbove s) : IsLUB s (sSup s)", "start": [498, 1], "end": [499, 46], "kind": "commanddeclaration"}, {"full_name": "isLUB_ciSup", "code": "theorem isLUB_ciSup [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (H : BddAbove (range f)) :\n    IsLUB (range f) (\u2a06 i, f i)", "start": [502, 1], "end": [504, 35], "kind": "commanddeclaration"}, {"full_name": "isLUB_ciSup_set", "code": "theorem isLUB_ciSup_set {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (H : BddAbove (f '' s)) (Hne : s.Nonempty) :\n    IsLUB (f '' s) (\u2a06 i : s, f i)", "start": [507, 1], "end": [510, 36], "kind": "commanddeclaration"}, {"full_name": "isGLB_csInf", "code": "theorem isGLB_csInf (ne : s.Nonempty) (H : BddBelow s) : IsGLB s (sInf s)", "start": [513, 1], "end": [514, 46], "kind": "commanddeclaration"}, {"full_name": "isGLB_ciInf", "code": "theorem isGLB_ciInf [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (H : BddBelow (range f)) :\n    IsGLB (range f) (\u2a05 i, f i)", "start": [517, 1], "end": [519, 35], "kind": "commanddeclaration"}, {"full_name": "isGLB_ciInf_set", "code": "theorem isGLB_ciInf_set {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (H : BddBelow (f '' s)) (Hne : s.Nonempty) :\n    IsGLB (f '' s) (\u2a05 i : s, f i)", "start": [522, 1], "end": [524, 37], "kind": "commanddeclaration"}, {"full_name": "ciSup_le_iff", "code": "theorem ciSup_le_iff [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hf : BddAbove (range f)) :\n    iSup f \u2264 a \u2194 \u2200 i, f i \u2264 a", "start": [527, 1], "end": [529, 58], "kind": "commanddeclaration"}, {"full_name": "le_ciInf_iff", "code": "theorem le_ciInf_iff [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hf : BddBelow (range f)) :\n    a \u2264 iInf f \u2194 \u2200 i, a \u2264 f i", "start": [532, 1], "end": [534, 58], "kind": "commanddeclaration"}, {"full_name": "ciSup_set_le_iff", "code": "theorem ciSup_set_le_iff {\u03b9 : Type*} {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hs : s.Nonempty)\n    (hf : BddAbove (f '' s)) : \u2a06 i : s, f i \u2264 a \u2194 \u2200 i \u2208 s, f i \u2264 a", "start": [537, 1], "end": [539, 63], "kind": "commanddeclaration"}, {"full_name": "le_ciInf_set_iff", "code": "theorem le_ciInf_set_iff {\u03b9 : Type*} {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hs : s.Nonempty)\n    (hf : BddBelow (f '' s)) : (a \u2264 \u2a05 i : s, f i) \u2194 \u2200 i \u2208 s, a \u2264 f i", "start": [542, 1], "end": [544, 63], "kind": "commanddeclaration"}, {"full_name": "IsLUB.csSup_eq", "code": "theorem IsLUB.csSup_eq (H : IsLUB s a) (ne : s.Nonempty) : sSup s = a", "start": [547, 1], "end": [548, 37], "kind": "commanddeclaration"}, {"full_name": "IsLUB.ciSup_eq", "code": "theorem IsLUB.ciSup_eq [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (H : IsLUB (range f) a) : \u2a06 i, f i = a", "start": [551, 1], "end": [552, 32], "kind": "commanddeclaration"}, {"full_name": "IsLUB.ciSup_set_eq", "code": "theorem IsLUB.ciSup_set_eq {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (H : IsLUB (f '' s) a) (Hne : s.Nonempty) :\n    \u2a06 i : s, f i = a", "start": [555, 1], "end": [557, 77], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.csSup_eq", "code": "theorem IsGreatest.csSup_eq (H : IsGreatest s a) : sSup s = a", "start": [560, 1], "end": [562, 30], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.csSup_mem", "code": "theorem IsGreatest.csSup_mem (H : IsGreatest s a) : sSup s \u2208 s", "start": [565, 1], "end": [566, 24], "kind": "commanddeclaration"}, {"full_name": "IsGLB.csInf_eq", "code": "theorem IsGLB.csInf_eq (H : IsGLB s a) (ne : s.Nonempty) : sInf s = a", "start": [569, 1], "end": [570, 37], "kind": "commanddeclaration"}, {"full_name": "IsGLB.ciInf_eq", "code": "theorem IsGLB.ciInf_eq [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (H : IsGLB (range f) a) : \u2a05 i, f i = a", "start": [573, 1], "end": [574, 32], "kind": "commanddeclaration"}, {"full_name": "IsGLB.ciInf_set_eq", "code": "theorem IsGLB.ciInf_set_eq {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (H : IsGLB (f '' s) a) (Hne : s.Nonempty) :\n    \u2a05 i : s, f i = a", "start": [577, 1], "end": [579, 77], "kind": "commanddeclaration"}, {"full_name": "IsLeast.csInf_eq", "code": "theorem IsLeast.csInf_eq (H : IsLeast s a) : sInf s = a", "start": [582, 1], "end": [584, 30], "kind": "commanddeclaration"}, {"full_name": "IsLeast.csInf_mem", "code": "theorem IsLeast.csInf_mem (H : IsLeast s a) : sInf s \u2208 s", "start": [587, 1], "end": [588, 24], "kind": "commanddeclaration"}, {"full_name": "subset_Icc_csInf_csSup", "code": "theorem subset_Icc_csInf_csSup (hb : BddBelow s) (ha : BddAbove s) : s \u2286 Icc (sInf s) (sSup s)", "start": [591, 1], "end": [592, 47], "kind": "commanddeclaration"}, {"full_name": "csSup_le_iff", "code": "theorem csSup_le_iff (hb : BddAbove s) (hs : s.Nonempty) : sSup s \u2264 a \u2194 \u2200 b \u2208 s, b \u2264 a", "start": [595, 1], "end": [596, 35], "kind": "commanddeclaration"}, {"full_name": "le_csInf_iff", "code": "theorem le_csInf_iff (hb : BddBelow s) (hs : s.Nonempty) : a \u2264 sInf s \u2194 \u2200 b \u2208 s, a \u2264 b", "start": [599, 1], "end": [600, 35], "kind": "commanddeclaration"}, {"full_name": "csSup_lower_bounds_eq_csInf", "code": "theorem csSup_lower_bounds_eq_csInf {s : Set \u03b1} (h : BddBelow s) (hs : s.Nonempty) :\n    sSup (lowerBounds s) = sInf s", "start": [603, 1], "end": [605, 84], "kind": "commanddeclaration"}, {"full_name": "csInf_upper_bounds_eq_csSup", "code": "theorem csInf_upper_bounds_eq_csSup {s : Set \u03b1} (h : BddAbove s) (hs : s.Nonempty) :\n    sInf (upperBounds s) = sSup s", "start": [608, 1], "end": [610, 84], "kind": "commanddeclaration"}, {"full_name": "not_mem_of_lt_csInf", "code": "theorem not_mem_of_lt_csInf {x : \u03b1} {s : Set \u03b1} (h : x < sInf s) (hs : BddBelow s) : x \u2209 s", "start": [613, 1], "end": [614, 54], "kind": "commanddeclaration"}, {"full_name": "not_mem_of_csSup_lt", "code": "theorem not_mem_of_csSup_lt {x : \u03b1} {s : Set \u03b1} (h : sSup s < x) (hs : BddAbove s) : x \u2209 s", "start": [617, 1], "end": [618, 38], "kind": "commanddeclaration"}, {"full_name": "csSup_eq_of_forall_le_of_forall_lt_exists_gt", "code": "theorem csSup_eq_of_forall_le_of_forall_lt_exists_gt (hs : s.Nonempty) (H : \u2200 a \u2208 s, a \u2264 b)\n    (H' : \u2200 w, w < b \u2192 \u2203 a \u2208 s, w < a) : sSup s = b", "start": [621, 1], "end": [628, 54], "kind": "commanddeclaration"}, {"full_name": "csInf_eq_of_forall_ge_of_forall_gt_exists_lt", "code": "theorem csInf_eq_of_forall_ge_of_forall_gt_exists_lt :\n    s.Nonempty \u2192 (\u2200 a \u2208 s, b \u2264 a) \u2192 (\u2200 w, b < w \u2192 \u2203 a \u2208 s, a < w) \u2192 sInf s = b", "start": [631, 1], "end": [636, 58], "kind": "commanddeclaration"}, {"full_name": "lt_csSup_of_lt", "code": "theorem lt_csSup_of_lt (hs : BddAbove s) (ha : a \u2208 s) (h : b < a) : b < sSup s", "start": [639, 1], "end": [645, 36], "kind": "commanddeclaration"}, {"full_name": "csInf_lt_of_lt", "code": "theorem csInf_lt_of_lt : BddBelow s \u2192 a \u2208 s \u2192 a < b \u2192 sInf s < b", "start": [648, 1], "end": [654, 30], "kind": "commanddeclaration"}, {"full_name": "exists_between_of_forall_le", "code": "theorem exists_between_of_forall_le (sne : s.Nonempty) (tne : t.Nonempty)\n    (hst : \u2200 x \u2208 s, \u2200 y \u2208 t, x \u2264 y) : (upperBounds s \u2229 lowerBounds t).Nonempty", "start": [657, 1], "end": [661, 89], "kind": "commanddeclaration"}, {"full_name": "csSup_singleton", "code": "@[simp]\ntheorem csSup_singleton (a : \u03b1) : sSup {a} = a", "start": [664, 1], "end": [667, 32], "kind": "commanddeclaration"}, {"full_name": "csInf_singleton", "code": "@[simp]\ntheorem csInf_singleton (a : \u03b1) : sInf {a} = a", "start": [670, 1], "end": [673, 29], "kind": "commanddeclaration"}, {"full_name": "csSup_pair", "code": "@[simp]\ntheorem csSup_pair (a b : \u03b1) : sSup {a, b} = a \u2294 b", "start": [676, 1], "end": [678, 55], "kind": "commanddeclaration"}, {"full_name": "csInf_pair", "code": "@[simp]\ntheorem csInf_pair (a b : \u03b1) : sInf {a, b} = a \u2293 b", "start": [681, 1], "end": [683, 55], "kind": "commanddeclaration"}, {"full_name": "csInf_le_csSup", "code": "theorem csInf_le_csSup (hb : BddBelow s) (ha : BddAbove s) (ne : s.Nonempty) : sInf s \u2264 sSup s", "start": [686, 1], "end": [689, 60], "kind": "commanddeclaration"}, {"full_name": "csSup_union", "code": "theorem csSup_union (hs : BddAbove s) (sne : s.Nonempty) (ht : BddAbove t) (tne : t.Nonempty) :\n    sSup (s \u222a t) = sSup s \u2294 sSup t", "start": [692, 1], "end": [696, 69], "kind": "commanddeclaration"}, {"full_name": "csInf_union", "code": "theorem csInf_union (hs : BddBelow s) (sne : s.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) :\n    sInf (s \u222a t) = sInf s \u2293 sInf t", "start": [699, 1], "end": [703, 39], "kind": "commanddeclaration"}, {"full_name": "csSup_inter_le", "code": "theorem csSup_inter_le (hs : BddAbove s) (ht : BddAbove t) (hst : (s \u2229 t).Nonempty) :\n    sSup (s \u2229 t) \u2264 sSup s \u2293 sSup t", "start": [706, 1], "end": [710, 74], "kind": "commanddeclaration"}, {"full_name": "le_csInf_inter", "code": "theorem le_csInf_inter :\n    BddBelow s \u2192 BddBelow t \u2192 (s \u2229 t).Nonempty \u2192 sInf s \u2294 sInf t \u2264 sInf (s \u2229 t)", "start": [713, 1], "end": [717, 28], "kind": "commanddeclaration"}, {"full_name": "csSup_insert", "code": "theorem csSup_insert (hs : BddAbove s) (sne : s.Nonempty) : sSup (insert a s) = a \u2294 sSup s", "start": [720, 1], "end": [723, 65], "kind": "commanddeclaration"}, {"full_name": "csInf_insert", "code": "theorem csInf_insert (hs : BddBelow s) (sne : s.Nonempty) : sInf (insert a s) = a \u2293 sInf s", "start": [726, 1], "end": [729, 33], "kind": "commanddeclaration"}, {"full_name": "csInf_Icc", "code": "@[simp]\ntheorem csInf_Icc (h : a \u2264 b) : sInf (Icc a b) = a", "start": [732, 1], "end": [734, 44], "kind": "commanddeclaration"}, {"full_name": "csInf_Ici", "code": "@[simp]\ntheorem csInf_Ici : sInf (Ici a) = a", "start": [737, 1], "end": [739, 23], "kind": "commanddeclaration"}, {"full_name": "csInf_Ico", "code": "@[simp]\ntheorem csInf_Ico (h : a < b) : sInf (Ico a b) = a", "start": [742, 1], "end": [744, 44], "kind": "commanddeclaration"}, {"full_name": "csInf_Ioc", "code": "@[simp]\ntheorem csInf_Ioc [DenselyOrdered \u03b1] (h : a < b) : sInf (Ioc a b) = a", "start": [747, 1], "end": [749, 44], "kind": "commanddeclaration"}, {"full_name": "csInf_Ioi", "code": "@[simp]\ntheorem csInf_Ioi [NoMaxOrder \u03b1] [DenselyOrdered \u03b1] : sInf (Ioi a) = a", "start": [752, 1], "end": [755, 34], "kind": "commanddeclaration"}, {"full_name": "csInf_Ioo", "code": "@[simp]\ntheorem csInf_Ioo [DenselyOrdered \u03b1] (h : a < b) : sInf (Ioo a b) = a", "start": [758, 1], "end": [760, 44], "kind": "commanddeclaration"}, {"full_name": "csSup_Icc", "code": "@[simp]\ntheorem csSup_Icc (h : a \u2264 b) : sSup (Icc a b) = b", "start": [763, 1], "end": [765, 44], "kind": "commanddeclaration"}, {"full_name": "csSup_Ico", "code": "@[simp]\ntheorem csSup_Ico [DenselyOrdered \u03b1] (h : a < b) : sSup (Ico a b) = b", "start": [768, 1], "end": [770, 44], "kind": "commanddeclaration"}, {"full_name": "csSup_Iic", "code": "@[simp]\ntheorem csSup_Iic : sSup (Iic a) = a", "start": [773, 1], "end": [775, 26], "kind": "commanddeclaration"}, {"full_name": "csSup_Iio", "code": "@[simp]\ntheorem csSup_Iio [NoMinOrder \u03b1] [DenselyOrdered \u03b1] : sSup (Iio a) = a", "start": [778, 1], "end": [781, 45], "kind": "commanddeclaration"}, {"full_name": "csSup_Ioc", "code": "@[simp]\ntheorem csSup_Ioc (h : a < b) : sSup (Ioc a b) = b", "start": [784, 1], "end": [786, 44], "kind": "commanddeclaration"}, {"full_name": "csSup_Ioo", "code": "@[simp]\ntheorem csSup_Ioo [DenselyOrdered \u03b1] (h : a < b) : sSup (Ioo a b) = b", "start": [789, 1], "end": [791, 44], "kind": "commanddeclaration"}, {"full_name": "ciSup_le", "code": "theorem ciSup_le [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {c : \u03b1} (H : \u2200 x, f x \u2264 c) : iSup f \u2264 c", "start": [794, 1], "end": [796, 58], "kind": "commanddeclaration"}, {"full_name": "le_ciSup", "code": "theorem le_ciSup {f : \u03b9 \u2192 \u03b1} (H : BddAbove (range f)) (c : \u03b9) : f c \u2264 iSup f", "start": [799, 1], "end": [801, 32], "kind": "commanddeclaration"}, {"full_name": "le_ciSup_of_le", "code": "theorem le_ciSup_of_le {f : \u03b9 \u2192 \u03b1} (H : BddAbove (range f)) (c : \u03b9) (h : a \u2264 f c) : a \u2264 iSup f", "start": [804, 1], "end": [805, 28], "kind": "commanddeclaration"}, {"full_name": "ciSup_mono", "code": "theorem ciSup_mono {f g : \u03b9 \u2192 \u03b1} (B : BddAbove (range g)) (H : \u2200 x, f x \u2264 g x) :\n    iSup f \u2264 iSup g", "start": [808, 1], "end": [813, 53], "kind": "commanddeclaration"}, {"full_name": "le_ciSup_set", "code": "theorem le_ciSup_set {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (H : BddAbove (f '' s)) {c : \u03b2} (hc : c \u2208 s) :\n    f c \u2264 \u2a06 i : s, f i", "start": [816, 1], "end": [818, 61], "kind": "commanddeclaration"}, {"full_name": "ciInf_mono", "code": "theorem ciInf_mono {f g : \u03b9 \u2192 \u03b1} (B : BddBelow (range f)) (H : \u2200 x, f x \u2264 g x) : iInf f \u2264 iInf g", "start": [821, 1], "end": [823, 30], "kind": "commanddeclaration"}, {"full_name": "le_ciInf", "code": "theorem le_ciInf [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {c : \u03b1} (H : \u2200 x, c \u2264 f x) : c \u2264 iInf f", "start": [826, 1], "end": [828, 28], "kind": "commanddeclaration"}, {"full_name": "ciInf_le", "code": "theorem ciInf_le {f : \u03b9 \u2192 \u03b1} (H : BddBelow (range f)) (c : \u03b9) : iInf f \u2264 f c", "start": [831, 1], "end": [833, 26], "kind": "commanddeclaration"}, {"full_name": "ciInf_le_of_le", "code": "theorem ciInf_le_of_le {f : \u03b9 \u2192 \u03b1} (H : BddBelow (range f)) (c : \u03b9) (h : f c \u2264 a) : iInf f \u2264 a", "start": [836, 1], "end": [837, 36], "kind": "commanddeclaration"}, {"full_name": "ciInf_set_le", "code": "theorem ciInf_set_le {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (H : BddBelow (f '' s)) {c : \u03b2} (hc : c \u2208 s) :\n    \u2a05 i : s, f i \u2264 f c", "start": [840, 1], "end": [842, 35], "kind": "commanddeclaration"}, {"full_name": "ciSup_const", "code": "@[simp]\ntheorem ciSup_const [h\u03b9 : Nonempty \u03b9] {a : \u03b1} : \u2a06 _ : \u03b9, a = a", "start": [845, 1], "end": [847, 42], "kind": "commanddeclaration"}, {"full_name": "ciInf_const", "code": "@[simp]\ntheorem ciInf_const [Nonempty \u03b9] {a : \u03b1} : \u2a05 _ : \u03b9, a = a", "start": [850, 1], "end": [852, 27], "kind": "commanddeclaration"}, {"full_name": "ciSup_unique", "code": "@[simp]\ntheorem ciSup_unique [Unique \u03b9] {s : \u03b9 \u2192 \u03b1} : \u2a06 i, s i = s default", "start": [855, 1], "end": [858, 32], "kind": "commanddeclaration"}, {"full_name": "ciInf_unique", "code": "@[simp]\ntheorem ciInf_unique [Unique \u03b9] {s : \u03b9 \u2192 \u03b1} : \u2a05 i, s i = s default", "start": [861, 1], "end": [863, 28], "kind": "commanddeclaration"}, {"full_name": "ciSup_subsingleton", "code": "theorem ciSup_subsingleton [Subsingleton \u03b9] (i : \u03b9) (s : \u03b9 \u2192 \u03b1) : \u2a06 i, s i = s i", "start": [867, 1], "end": [868, 62], "kind": "commanddeclaration"}, {"full_name": "ciInf_subsingleton", "code": "theorem ciInf_subsingleton [Subsingleton \u03b9] (i : \u03b9) (s : \u03b9 \u2192 \u03b1) : \u2a05 i, s i = s i", "start": [871, 1], "end": [872, 62], "kind": "commanddeclaration"}, {"full_name": "ciSup_pos", "code": "@[simp]\ntheorem ciSup_pos {p : Prop} {f : p \u2192 \u03b1} (hp : p) : \u2a06 h : p, f h = f hp", "start": [874, 1], "end": [876, 26], "kind": "commanddeclaration"}, {"full_name": "ciInf_pos", "code": "@[simp]\ntheorem ciInf_pos {p : Prop} {f : p \u2192 \u03b1} (hp : p) : \u2a05 h : p, f h = f hp", "start": [879, 1], "end": [881, 26], "kind": "commanddeclaration"}, {"full_name": "ciSup_neg", "code": "lemma ciSup_neg {p : Prop} {f : p \u2192 \u03b1} (hp : \u00ac p) :\n    \u2a06 (h : p), f h = sSup (\u2205 : Set \u03b1) := by\n  rw [iSup]\n  congr\n  rwa [range_eq_empty_iff, isEmpty_Prop]", "start": [884, 1], "end": [888, 41], "kind": "mathlibtacticlemma"}, {"full_name": "ciInf_neg", "code": "lemma ciInf_neg {p : Prop} {f : p \u2192 \u03b1} (hp : \u00ac p) :\n    \u2a05 (h : p), f h = sInf (\u2205 : Set \u03b1) :=\n  @ciSup_neg \u03b1\u1d52\u1d48 _ _ _ hp", "start": [890, 1], "end": [892, 26], "kind": "mathlibtacticlemma"}, {"full_name": "ciSup_eq_ite", "code": "lemma ciSup_eq_ite {p : Prop} [Decidable p] {f : p \u2192 \u03b1} :\n    (\u2a06 h : p, f h) = if h : p then f h else sSup (\u2205 : Set \u03b1) := by\n  by_cases H : p <;> simp [ciSup_neg, H]", "start": [894, 1], "end": [896, 41], "kind": "mathlibtacticlemma"}, {"full_name": "ciInf_eq_ite", "code": "lemma ciInf_eq_ite {p : Prop} [Decidable p] {f : p \u2192 \u03b1} :\n    (\u2a05 h : p, f h) = if h : p then f h else sInf (\u2205 : Set \u03b1) :=\n  ciSup_eq_ite (\u03b1 := \u03b1\u1d52\u1d48)", "start": [898, 1], "end": [900, 26], "kind": "mathlibtacticlemma"}, {"full_name": "cbiSup_eq_of_forall", "code": "theorem cbiSup_eq_of_forall {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1} (hp : \u2200 i, p i) :\n    \u2a06 (i) (h : p i), f \u27e8i, h\u27e9 = iSup f", "start": [902, 1], "end": [911, 9], "kind": "commanddeclaration"}, {"full_name": "cbiInf_eq_of_forall", "code": "theorem cbiInf_eq_of_forall {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1} (hp : \u2200 i, p i) :\n    \u2a05 (i) (h : p i), f \u27e8i, h\u27e9 = iInf f", "start": [913, 1], "end": [915, 36], "kind": "commanddeclaration"}, {"full_name": "ciSup_eq_of_forall_le_of_forall_lt_exists_gt", "code": "theorem ciSup_eq_of_forall_le_of_forall_lt_exists_gt [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (h\u2081 : \u2200 i, f i \u2264 b)\n    (h\u2082 : \u2200 w, w < b \u2192 \u2203 i, w < f i) : \u2a06 i : \u03b9, f i = b", "start": [917, 1], "end": [923, 48], "kind": "commanddeclaration"}, {"full_name": "ciInf_eq_of_forall_ge_of_forall_gt_exists_lt", "code": "theorem ciInf_eq_of_forall_ge_of_forall_gt_exists_lt [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (h\u2081 : \u2200 i, b \u2264 f i)\n    (h\u2082 : \u2200 w, b < w \u2192 \u2203 i, f i < w) : \u2a05 i : \u03b9, f i = b", "start": [927, 1], "end": [932, 78], "kind": "commanddeclaration"}, {"full_name": "Monotone.ciSup_mem_iInter_Icc_of_antitone", "code": "theorem Monotone.ciSup_mem_iInter_Icc_of_antitone [SemilatticeSup \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Monotone f)\n    (hg : Antitone g) (h : f \u2264 g) : (\u2a06 n, f n) \u2208 \u22c2 n, Icc (f n) (g n)", "start": [935, 1], "end": [942, 70], "kind": "commanddeclaration"}, {"full_name": "ciSup_mem_iInter_Icc_of_antitone_Icc", "code": "theorem ciSup_mem_iInter_Icc_of_antitone_Icc [SemilatticeSup \u03b2] {f g : \u03b2 \u2192 \u03b1}\n    (h : Antitone fun n => Icc (f n) (g n)) (h' : \u2200 n, f n \u2264 g n) :\n    (\u2a06 n, f n) \u2208 \u22c2 n, Icc (f n) (g n)", "start": [945, 1], "end": [952, 66], "kind": "commanddeclaration"}, {"full_name": "csSup_eq_of_is_forall_le_of_forall_le_imp_ge", "code": "theorem csSup_eq_of_is_forall_le_of_forall_le_imp_ge (hs : s.Nonempty) (h_is_ub : \u2200 a \u2208 s, a \u2264 b)\n    (h_b_le_ub : \u2200 ub, (\u2200 a \u2208 s, a \u2264 ub) \u2192 b \u2264 ub) : sSup s = b", "start": [955, 1], "end": [960, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_ciInf", "code": "lemma Set.Iic_ciInf [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (hf : BddBelow (range f)) :\n    Iic (\u2a05 i, f i) = \u22c2 i, Iic (f i) := by\n  apply Subset.antisymm\n  \u00b7 rintro x hx - \u27e8i, rfl\u27e9\n    exact hx.trans (ciInf_le hf _)\n  \u00b7 rintro x hx\n    apply le_ciInf\n    simpa using hx", "start": [963, 1], "end": [970, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Ici_ciSup", "code": "lemma Set.Ici_ciSup [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (hf : BddAbove (range f)) :\n    Ici (\u2a06 i, f i) = \u22c2 i, Ici (f i) :=\n  Iic_ciInf (\u03b1 := \u03b1\u1d52\u1d48) hf", "start": [972, 1], "end": [974, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.conditionallyCompleteLattice", "code": "instance Pi.conditionallyCompleteLattice {\u03b9 : Type*} {\u03b1 : \u2200 _i : \u03b9, Type*}\n    [\u2200 i, ConditionallyCompleteLattice (\u03b1 i)] : ConditionallyCompleteLattice (\u2200 i, \u03b1 i) :=\n  { Pi.lattice, Pi.supSet, Pi.infSet with\n    le_csSup := fun s f \u27e8g, hg\u27e9 hf i =>\n      le_csSup \u27e8g i, Set.forall_range_iff.2 fun \u27e8f', hf'\u27e9 => hg hf' i\u27e9 \u27e8\u27e8f, hf\u27e9, rfl\u27e9\n    csSup_le := fun s f hs hf i =>\n      (csSup_le (by haveI := hs.to_subtype; apply range_nonempty)) fun b \u27e8\u27e8g, hg\u27e9, hb\u27e9 =>\n        hb \u25b8 hf hg i\n    csInf_le := fun s f \u27e8g, hg\u27e9 hf i =>\n      csInf_le \u27e8g i, Set.forall_range_iff.2 fun \u27e8f', hf'\u27e9 => hg hf' i\u27e9 \u27e8\u27e8f, hf\u27e9, rfl\u27e9\n    le_csInf := fun s f hs hf i =>\n      (le_csInf (by haveI := hs.to_subtype; apply range_nonempty)) fun b \u27e8\u27e8g, hg\u27e9, hb\u27e9 =>\n        hb \u25b8 hf hg i }", "start": [978, 1], "end": [990, 23], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_lt_csSup", "code": "theorem exists_lt_of_lt_csSup (hs : s.Nonempty) (hb : b < sSup s) : \u2203 a \u2208 s, b < a", "start": [997, 1], "end": [1001, 23], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_lt_ciSup", "code": "theorem exists_lt_of_lt_ciSup [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (h : b < iSup f) : \u2203 i, b < f i", "start": [1004, 1], "end": [1009, 9], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_csInf_lt", "code": "theorem exists_lt_of_csInf_lt (hs : s.Nonempty) (hb : sInf s < b) : \u2203 a \u2208 s, a < b", "start": [1012, 1], "end": [1015, 41], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_ciInf_lt", "code": "theorem exists_lt_of_ciInf_lt [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (h : iInf f < a) : \u2203 i, f i < a", "start": [1018, 1], "end": [1022, 41], "kind": "commanddeclaration"}, {"full_name": "csSup_of_not_bddAbove", "code": "theorem csSup_of_not_bddAbove {s : Set \u03b1} (hs : \u00acBddAbove s) : sSup s = sSup \u2205", "start": [1025, 1], "end": [1026, 62], "kind": "commanddeclaration"}, {"full_name": "csSup_eq_univ_of_not_bddAbove", "code": "theorem csSup_eq_univ_of_not_bddAbove {s : Set \u03b1} (hs : \u00acBddAbove s) : sSup s = sSup univ", "start": [1028, 1], "end": [1031, 32], "kind": "commanddeclaration"}, {"full_name": "csInf_of_not_bddBelow", "code": "theorem csInf_of_not_bddBelow {s : Set \u03b1} (hs : \u00acBddBelow s) : sInf s = sInf \u2205", "start": [1033, 1], "end": [1034, 62], "kind": "commanddeclaration"}, {"full_name": "csInf_eq_univ_of_not_bddBelow", "code": "theorem csInf_eq_univ_of_not_bddBelow {s : Set \u03b1} (hs : \u00acBddBelow s) : sInf s = sInf univ", "start": [1036, 1], "end": [1037, 46], "kind": "commanddeclaration"}, {"full_name": "csSup_eq_csSup_of_forall_exists_le", "code": "theorem csSup_eq_csSup_of_forall_exists_le {s t : Set \u03b1}\n    (hs : \u2200 x \u2208 s, \u2203 y \u2208 t, x \u2264 y) (ht : \u2200 y \u2208 t, \u2203 x \u2208 s, y \u2264 x) :\n    sSup s = sSup t", "start": [1039, 1], "end": [1070, 65], "kind": "commanddeclaration"}, {"full_name": "csInf_eq_csInf_of_forall_exists_le", "code": "theorem csInf_eq_csInf_of_forall_exists_le {s t : Set \u03b1}\n    (hs : \u2200 x \u2208 s, \u2203 y \u2208 t, y \u2264 x) (ht : \u2200 y \u2208 t, \u2203 x \u2208 s, x \u2264 y) :\n    sInf s = sInf t", "start": [1072, 1], "end": [1077, 54], "kind": "commanddeclaration"}, {"full_name": "sSup_iUnion_Iic", "code": "lemma sSup_iUnion_Iic (f : \u03b9 \u2192 \u03b1) : sSup (\u22c3 (i : \u03b9), Iic (f i)) = \u2a06 i, f i := by\n  apply csSup_eq_csSup_of_forall_exists_le\n  \u00b7 rintro x \u27e8-, \u27e8i, rfl\u27e9, hi\u27e9\n    exact \u27e8f i, mem_range_self _, hi\u27e9\n  \u00b7 rintro x \u27e8i, rfl\u27e9\n    exact \u27e8f i, mem_iUnion_of_mem i le_rfl, le_rfl\u27e9", "start": [1079, 1], "end": [1084, 52], "kind": "mathlibtacticlemma"}, {"full_name": "sInf_iUnion_Ici", "code": "lemma sInf_iUnion_Ici (f : \u03b9 \u2192 \u03b1) : sInf (\u22c3 (i : \u03b9), Ici (f i)) = \u2a05 i, f i :=\n  sSup_iUnion_Iic (\u03b1 := \u03b1\u1d52\u1d48) f", "start": [1086, 1], "end": [1087, 31], "kind": "mathlibtacticlemma"}, {"full_name": "cbiSup_eq_of_not_forall", "code": "theorem cbiSup_eq_of_not_forall {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1} (hp : \u00ac (\u2200 i, p i)) :\n    \u2a06 (i) (h : p i), f \u27e8i, h\u27e9 = iSup f \u2294 sSup \u2205", "start": [1089, 1], "end": [1128, 15], "kind": "commanddeclaration"}, {"full_name": "cbiInf_eq_of_not_forall", "code": "theorem cbiInf_eq_of_not_forall {p : \u03b9 \u2192 Prop} {f : Subtype p \u2192 \u03b1} (hp : \u00ac (\u2200 i, p i)) :\n    \u2a05 (i) (h : p i), f \u27e8i, h\u27e9 = iInf f \u2293 sInf \u2205", "start": [1130, 1], "end": [1132, 40], "kind": "commanddeclaration"}, {"full_name": "sInf_eq_argmin_on", "code": "theorem sInf_eq_argmin_on (hs : s.Nonempty) :\n    sInf s = argminOn id (@IsWellFounded.wf \u03b1 (\u00b7 < \u00b7) _) s hs", "start": [1138, 1], "end": [1140, 77], "kind": "commanddeclaration"}, {"full_name": "isLeast_csInf", "code": "theorem isLeast_csInf (hs : s.Nonempty) : IsLeast s (sInf s)", "start": [1143, 1], "end": [1145, 66], "kind": "commanddeclaration"}, {"full_name": "le_csInf_iff'", "code": "theorem le_csInf_iff' (hs : s.Nonempty) : b \u2264 sInf s \u2194 b \u2208 lowerBounds s", "start": [1148, 1], "end": [1149, 40], "kind": "commanddeclaration"}, {"full_name": "csInf_mem", "code": "theorem csInf_mem (hs : s.Nonempty) : sInf s \u2208 s", "start": [1152, 1], "end": [1153, 23], "kind": "commanddeclaration"}, {"full_name": "ciInf_mem", "code": "theorem ciInf_mem [Nonempty \u03b9] (f : \u03b9 \u2192 \u03b1) : iInf f \u2208 range f", "start": [1156, 1], "end": [1157, 31], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_csInf", "code": "theorem MonotoneOn.map_csInf {\u03b2 : Type*} [ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : MonotoneOn f s) (hs : s.Nonempty) : f (sInf s) = sInf (f '' s)", "start": [1160, 1], "end": [1162, 52], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_csInf", "code": "theorem Monotone.map_csInf {\u03b2 : Type*} [ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Monotone f) (hs : s.Nonempty) : f (sInf s) = sInf (f '' s)", "start": [1165, 1], "end": [1167, 52], "kind": "commanddeclaration"}, {"full_name": "csSup_empty", "code": "@[simp]\ntheorem csSup_empty : (sSup \u2205 : \u03b1) = \u22a5", "start": [1183, 1], "end": [1185, 50], "kind": "commanddeclaration"}, {"full_name": "ciSup_of_empty", "code": "@[simp]\ntheorem ciSup_of_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : \u2a06 i, f i = \u22a5", "start": [1188, 1], "end": [1190, 35], "kind": "commanddeclaration"}, {"full_name": "ciSup_false", "code": "theorem ciSup_false (f : False \u2192 \u03b1) : \u2a06 i, f i = \u22a5", "start": [1193, 1], "end": [1194, 19], "kind": "commanddeclaration"}, {"full_name": "csInf_univ", "code": "@[simp]\ntheorem csInf_univ : sInf (univ : Set \u03b1) = \u22a5", "start": [1197, 1], "end": [1199, 24], "kind": "commanddeclaration"}, {"full_name": "isLUB_csSup'", "code": "theorem isLUB_csSup' {s : Set \u03b1} (hs : BddAbove s) : IsLUB s (sSup s)", "start": [1202, 1], "end": [1205, 29], "kind": "commanddeclaration"}, {"full_name": "csSup_le_iff'", "code": "theorem csSup_le_iff' {s : Set \u03b1} (hs : BddAbove s) {a : \u03b1} : sSup s \u2264 a \u2194 \u2200 x \u2208 s, x \u2264 a", "start": [1208, 1], "end": [1209, 33], "kind": "commanddeclaration"}, {"full_name": "csSup_le'", "code": "theorem csSup_le' {s : Set \u03b1} {a : \u03b1} (h : a \u2208 upperBounds s) : sSup s \u2264 a", "start": [1212, 1], "end": [1213, 29], "kind": "commanddeclaration"}, {"full_name": "le_csSup_iff'", "code": "theorem le_csSup_iff' {s : Set \u03b1} {a : \u03b1} (h : BddAbove s) :\n    a \u2264 sSup s \u2194 \u2200 b, b \u2208 upperBounds s \u2192 a \u2264 b", "start": [1216, 1], "end": [1218, 80], "kind": "commanddeclaration"}, {"full_name": "le_ciSup_iff'", "code": "theorem le_ciSup_iff' {s : \u03b9 \u2192 \u03b1} {a : \u03b1} (h : BddAbove (range s)) :\n    a \u2264 iSup s \u2194 \u2200 b, (\u2200 i, s i \u2264 b) \u2192 a \u2264 b", "start": [1221, 1], "end": [1222, 94], "kind": "commanddeclaration"}, {"full_name": "le_csInf_iff''", "code": "theorem le_csInf_iff'' {s : Set \u03b1} {a : \u03b1} (ne : s.Nonempty) :\n    a \u2264 sInf s \u2194 \u2200 b : \u03b1, b \u2208 s \u2192 a \u2264 b", "start": [1225, 1], "end": [1227, 41], "kind": "commanddeclaration"}, {"full_name": "le_ciInf_iff'", "code": "theorem le_ciInf_iff' [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} : a \u2264 iInf f \u2194 \u2200 i, a \u2264 f i", "start": [1230, 1], "end": [1231, 38], "kind": "commanddeclaration"}, {"full_name": "csInf_le'", "code": "theorem csInf_le' {s : Set \u03b1} {a : \u03b1} (h : a \u2208 s) : sInf s \u2264 a", "start": [1234, 1], "end": [1235, 36], "kind": "commanddeclaration"}, {"full_name": "ciInf_le'", "code": "theorem ciInf_le' (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i", "start": [1238, 1], "end": [1239, 36], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_lt_csSup'", "code": "theorem exists_lt_of_lt_csSup' {s : Set \u03b1} {a : \u03b1} (h : a < sSup s) : \u2203 b \u2208 s, a < b", "start": [1242, 1], "end": [1244, 20], "kind": "commanddeclaration"}, {"full_name": "ciSup_le_iff'", "code": "theorem ciSup_le_iff' {f : \u03b9 \u2192 \u03b1} (h : BddAbove (range f)) {a : \u03b1} :\n    \u2a06 i, f i \u2264 a \u2194 \u2200 i, f i \u2264 a", "start": [1247, 1], "end": [1249, 43], "kind": "commanddeclaration"}, {"full_name": "ciSup_le'", "code": "theorem ciSup_le' {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (h : \u2200 i, f i \u2264 a) : \u2a06 i, f i \u2264 a", "start": [1252, 1], "end": [1253, 36], "kind": "commanddeclaration"}, {"full_name": "exists_lt_of_lt_ciSup'", "code": "theorem exists_lt_of_lt_ciSup' {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (h : a < \u2a06 i, f i) : \u2203 i, a < f i", "start": [1256, 1], "end": [1258, 20], "kind": "commanddeclaration"}, {"full_name": "ciSup_mono'", "code": "theorem ciSup_mono' {\u03b9'} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} (hg : BddAbove (range g))\n    (h : \u2200 i, \u2203 i', f i \u2264 g i') : iSup f \u2264 iSup g", "start": [1261, 1], "end": [1263, 59], "kind": "commanddeclaration"}, {"full_name": "csInf_le_csInf'", "code": "theorem csInf_le_csInf' {s t : Set \u03b1} (h\u2081 : t.Nonempty) (h\u2082 : t \u2286 s) : sInf s \u2264 sInf t", "start": [1266, 1], "end": [1267, 45], "kind": "commanddeclaration"}, {"full_name": "WithTop.isLUB_sSup'", "code": "theorem isLUB_sSup' {\u03b2 : Type*} [ConditionallyCompleteLattice \u03b2] {s : Set (WithTop \u03b2)}\n    (hs : s.Nonempty) : IsLUB s (sSup s)", "start": [1278, 1], "end": [1312, 37], "kind": "commanddeclaration"}, {"full_name": "WithTop.isLUB_sSup", "code": "theorem isLUB_sSup (s : Set (WithTop \u03b1)) : IsLUB s (sSup s)", "start": [1316, 1], "end": [1329, 23], "kind": "commanddeclaration"}, {"full_name": "WithTop.isGLB_sInf'", "code": "theorem isGLB_sInf' {\u03b2 : Type*} [ConditionallyCompleteLattice \u03b2] {s : Set (WithTop \u03b2)}\n    (hs : BddBelow s) : IsGLB s (sInf s)", "start": [1332, 1], "end": [1370, 22], "kind": "commanddeclaration"}, {"full_name": "WithTop.isGLB_sInf", "code": "theorem isGLB_sInf (s : Set (WithTop \u03b1)) : IsGLB s (sInf s)", "start": [1373, 1], "end": [1380, 17], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sSup", "code": "@[norm_cast]\ntheorem coe_sSup {s : Set \u03b1} (hb : BddAbove s) : \u2191(sSup s) = (\u2a06 a \u2208 s, \u2191a : WithTop \u03b1)", "start": [1392, 1], "end": [1395, 32], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sInf", "code": "@[norm_cast]\ntheorem coe_sInf {s : Set \u03b1} (hs : s.Nonempty) : \u2191(sInf s) = (\u2a05 a \u2208 s, \u2191a : WithTop \u03b1)", "start": [1398, 1], "end": [1401, 32], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_csSup_image", "code": "theorem le_csSup_image {s : Set \u03b1} {c : \u03b1} (hcs : c \u2208 s) (h_bdd : BddAbove s) :\n    f c \u2264 sSup (f '' s)", "start": [1414, 1], "end": [1416, 64], "kind": "commanddeclaration"}, {"full_name": "Monotone.csSup_image_le", "code": "theorem csSup_image_le {s : Set \u03b1} (hs : s.Nonempty) {B : \u03b1} (hB : B \u2208 upperBounds s) :\n    sSup (f '' s) \u2264 f B", "start": [1419, 1], "end": [1421, 67], "kind": "commanddeclaration"}, {"full_name": "Monotone.csInf_image_le", "code": "theorem csInf_image_le {s : Set \u03b1} {c : \u03b1} (hcs : c \u2208 s) (h_bdd : BddBelow s) :\n    sInf (f '' s) \u2264 f c", "start": [1425, 1], "end": [1429, 68], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_csInf_image", "code": "theorem le_csInf_image {s : Set \u03b1} (hs : s.Nonempty) {B : \u03b1} (hB : B \u2208 lowerBounds s) :\n    f B \u2264 sInf (f '' s)", "start": [1433, 1], "end": [1437, 64], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_csSup", "code": "theorem l_csSup (gc : GaloisConnection l u) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    l (sSup s) = \u2a06 x : s, l x", "start": [1447, 1], "end": [1449, 79], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_csSup'", "code": "theorem l_csSup' (gc : GaloisConnection l u) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    l (sSup s) = sSup (l '' s)", "start": [1452, 1], "end": [1453, 75], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_ciSup", "code": "theorem l_ciSup (gc : GaloisConnection l u) {f : \u03b9 \u2192 \u03b1} (hf : BddAbove (range f)) :\n    l (\u2a06 i, f i) = \u2a06 i, l (f i)", "start": [1456, 1], "end": [1457, 95], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.l_ciSup_set", "code": "theorem l_ciSup_set (gc : GaloisConnection l u) {s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} (hf : BddAbove (f '' s))\n    (hne : s.Nonempty) : l (\u2a06 i : s, f i) = \u2a06 i : s, l (f i)", "start": [1460, 1], "end": [1464, 22], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_csInf", "code": "theorem u_csInf (gc : GaloisConnection l u) {s : Set \u03b2} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    u (sInf s) = \u2a05 x : s, u x", "start": [1467, 1], "end": [1469, 27], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_csInf'", "code": "theorem u_csInf' (gc : GaloisConnection l u) {s : Set \u03b2} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    u (sInf s) = sInf (u '' s)", "start": [1472, 1], "end": [1474, 28], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_ciInf", "code": "theorem u_ciInf (gc : GaloisConnection l u) {f : \u03b9 \u2192 \u03b2} (hf : BddBelow (range f)) :\n    u (\u2a05 i, f i) = \u2a05 i, u (f i)", "start": [1477, 1], "end": [1479, 21], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.u_ciInf_set", "code": "theorem u_ciInf_set (gc : GaloisConnection l u) {s : Set \u03b3} {f : \u03b3 \u2192 \u03b2} (hf : BddBelow (f '' s))\n    (hne : s.Nonempty) : u (\u2a05 i : s, f i) = \u2a05 i : s, u (f i)", "start": [1482, 1], "end": [1484, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_csSup", "code": "theorem map_csSup (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    e (sSup s) = \u2a06 x : s, e x", "start": [1493, 1], "end": [1495, 41], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_csSup'", "code": "theorem map_csSup' (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddAbove s) :\n    e (sSup s) = sSup (e '' s)", "start": [1498, 1], "end": [1500, 42], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_ciSup", "code": "theorem map_ciSup (e : \u03b1 \u2243o \u03b2) {f : \u03b9 \u2192 \u03b1} (hf : BddAbove (range f)) :\n    e (\u2a06 i, f i) = \u2a06 i, e (f i)", "start": [1503, 1], "end": [1505, 35], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_ciSup_set", "code": "theorem map_ciSup_set (e : \u03b1 \u2243o \u03b2) {s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} (hf : BddAbove (f '' s))\n    (hne : s.Nonempty) : e (\u2a06 i : s, f i) = \u2a06 i : s, e (f i)", "start": [1508, 1], "end": [1510, 43], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_csInf", "code": "theorem map_csInf (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    e (sInf s) = \u2a05 x : s, e x", "start": [1513, 1], "end": [1515, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_csInf'", "code": "theorem map_csInf' (e : \u03b1 \u2243o \u03b2) {s : Set \u03b1} (hne : s.Nonempty) (hbdd : BddBelow s) :\n    e (sInf s) = sInf (e '' s)", "start": [1518, 1], "end": [1520, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_ciInf", "code": "theorem map_ciInf (e : \u03b1 \u2243o \u03b2) {f : \u03b9 \u2192 \u03b1} (hf : BddBelow (range f)) :\n    e (\u2a05 i, f i) = \u2a05 i, e (f i)", "start": [1523, 1], "end": [1525, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_ciInf_set", "code": "theorem map_ciInf_set (e : \u03b1 \u2243o \u03b2) {s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} (hf : BddBelow (f '' s))\n    (hne : s.Nonempty) : e (\u2a05 i : s, f i) = \u2a05 i : s, e (f i)", "start": [1528, 1], "end": [1530, 30], "kind": "commanddeclaration"}, {"full_name": "csSup_image2_eq_csSup_csSup", "code": "theorem csSup_image2_eq_csSup_csSup (h\u2081 : \u2200 b, GaloisConnection (swap l b) (u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a) (u\u2082 a)) (hs\u2080 : s.Nonempty) (hs\u2081 : BddAbove s)\n    (ht\u2080 : t.Nonempty) (ht\u2081 : BddAbove t) : sSup (image2 l s t) = l (sSup s) (sSup t)", "start": [1550, 1], "end": [1557, 71], "kind": "commanddeclaration"}, {"full_name": "csSup_image2_eq_csSup_csInf", "code": "theorem csSup_image2_eq_csSup_csInf (h\u2081 : \u2200 b, GaloisConnection (swap l b) (u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a \u2218 ofDual) (toDual \u2218 u\u2082 a)) :\n    s.Nonempty \u2192 BddAbove s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sSup (image2 l s t) = l (sSup s) (sInf t)", "start": [1560, 1], "end": [1563, 61], "kind": "commanddeclaration"}, {"full_name": "csSup_image2_eq_csInf_csSup", "code": "theorem csSup_image2_eq_csInf_csSup (h\u2081 : \u2200 b, GaloisConnection (swap l b \u2218 ofDual) (toDual \u2218 u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a) (u\u2082 a)) :\n    s.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddAbove t \u2192 sSup (image2 l s t) = l (sInf s) (sSup t)", "start": [1566, 1], "end": [1569, 61], "kind": "commanddeclaration"}, {"full_name": "csSup_image2_eq_csInf_csInf", "code": "theorem csSup_image2_eq_csInf_csInf (h\u2081 : \u2200 b, GaloisConnection (swap l b \u2218 ofDual) (toDual \u2218 u\u2081 b))\n    (h\u2082 : \u2200 a, GaloisConnection (l a \u2218 ofDual) (toDual \u2218 u\u2082 a)) :\n    s.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sSup (image2 l s t) = l (sInf s) (sInf t)", "start": [1572, 1], "end": [1575, 63], "kind": "commanddeclaration"}, {"full_name": "csInf_image2_eq_csInf_csInf", "code": "theorem csInf_image2_eq_csInf_csInf (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) :\n    s.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sInf (image2 u s t) = u (sInf s) (sInf t)", "start": [1578, 1], "end": [1582, 16], "kind": "commanddeclaration"}, {"full_name": "csInf_image2_eq_csInf_csSup", "code": "theorem csInf_image2_eq_csInf_csSup (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    s.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddAbove t \u2192 sInf (image2 u s t) = u (sInf s) (sSup t)", "start": [1585, 1], "end": [1588, 61], "kind": "commanddeclaration"}, {"full_name": "csInf_image2_eq_csSup_csInf", "code": "theorem csInf_image2_eq_csSup_csInf (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n    (h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) :\n    s.Nonempty \u2192 BddAbove s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sInf (image2 u s t) = u (sSup s) (sInf t)", "start": [1591, 1], "end": [1594, 61], "kind": "commanddeclaration"}, {"full_name": "csInf_image2_eq_csSup_csSup", "code": "theorem csInf_image2_eq_csSup_csSup (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n    (h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\n    s.Nonempty \u2192 BddAbove s \u2192 t.Nonempty \u2192 BddAbove t \u2192 sInf (image2 u s t) = u (sSup s) (sSup t)", "start": [1597, 1], "end": [1600, 63], "kind": "commanddeclaration"}, {"full_name": "WithTop.conditionallyCompleteLattice", "code": "noncomputable instance WithTop.conditionallyCompleteLattice {\u03b1 : Type*}\n    [ConditionallyCompleteLattice \u03b1] : ConditionallyCompleteLattice (WithTop \u03b1) :=\n  { lattice, instSupSet, instInfSet with\n    le_csSup := fun _ a _ haS => (WithTop.isLUB_sSup' \u27e8a, haS\u27e9).1 haS\n    csSup_le := fun _ _ hS haS => (WithTop.isLUB_sSup' hS).2 haS\n    csInf_le := fun _ _ hS haS => (WithTop.isGLB_sInf' hS).1 haS\n    le_csInf := fun _ a _ haS => (WithTop.isGLB_sInf' \u27e8a, haS\u27e9).2 haS }", "start": [1624, 1], "end": [1632, 72], "kind": "commanddeclaration"}, {"full_name": "WithBot.conditionallyCompleteLattice", "code": "noncomputable instance WithBot.conditionallyCompleteLattice {\u03b1 : Type*}\n    [ConditionallyCompleteLattice \u03b1] : ConditionallyCompleteLattice (WithBot \u03b1) :=\n  { WithBot.lattice with\n    le_csSup := (@WithTop.conditionallyCompleteLattice \u03b1\u1d52\u1d48 _).csInf_le\n    csSup_le := (@WithTop.conditionallyCompleteLattice \u03b1\u1d52\u1d48 _).le_csInf\n    csInf_le := (@WithTop.conditionallyCompleteLattice \u03b1\u1d52\u1d48 _).le_csSup\n    le_csInf := (@WithTop.conditionallyCompleteLattice \u03b1\u1d52\u1d48 _).csSup_le }", "start": [1635, 1], "end": [1643, 73], "kind": "commanddeclaration"}, {"full_name": "WithTop.WithBot.completeLattice", "code": "noncomputable instance WithTop.WithBot.completeLattice {\u03b1 : Type*}\n    [ConditionallyCompleteLattice \u03b1] : CompleteLattice (WithTop (WithBot \u03b1)) :=\n  { instInfSet, instSupSet, boundedOrder, lattice with\n    le_sSup := fun S a haS => (WithTop.isLUB_sSup' \u27e8a, haS\u27e9).1 haS\n    sSup_le := fun S a ha => by\n      cases' S.eq_empty_or_nonempty with h h\n      \u00b7 show ite _ _ _ \u2264 a\n        split_ifs with h\u2081 h\u2082\n        \u00b7 rw [h] at h\u2081\n          cases h\u2081\n        \u00b7 convert @bot_le _ _ _ a\n          apply congr_arg\n          simp only [h, preimage_empty, WithBot.csSup_empty]\n        \u00b7 exfalso\n          apply h\u2082\n          use \u22a5\n          rw [h]\n          rintro b \u27e8\u27e9\n      \u00b7 refine' (WithTop.isLUB_sSup' h).2 ha\n    sInf_le := fun S a haS =>\n      show ite _ _ _ \u2264 a by\n        split_ifs with h\u2081\n        \u00b7 cases' a with a\n          exact le_rfl\n          cases h\u2081 haS\n        \u00b7 cases a\n          \u00b7 exact le_top\n          \u00b7 apply WithTop.some_le_some.2\n            refine' csInf_le _ haS\n            use \u22a5\n            intro b _\n            exact bot_le\n    le_sInf := fun S a haS => (WithTop.isGLB_sInf' \u27e8a, haS\u27e9).2 haS }", "start": [1647, 1], "end": [1681, 69], "kind": "commanddeclaration"}, {"full_name": "WithTop.WithBot.completeLinearOrder", "code": "noncomputable instance WithTop.WithBot.completeLinearOrder {\u03b1 : Type*}\n    [ConditionallyCompleteLinearOrder \u03b1] : CompleteLinearOrder (WithTop (WithBot \u03b1)) :=\n  { WithTop.WithBot.completeLattice, WithTop.linearOrder with }", "start": [1684, 1], "end": [1686, 64], "kind": "commanddeclaration"}, {"full_name": "WithBot.WithTop.completeLattice", "code": "noncomputable instance WithBot.WithTop.completeLattice {\u03b1 : Type*}\n    [ConditionallyCompleteLattice \u03b1] : CompleteLattice (WithBot (WithTop \u03b1)) :=\n  { instInfSet, instSupSet, instBoundedOrder, lattice with\n    le_sSup := (@WithTop.WithBot.completeLattice \u03b1\u1d52\u1d48 _).sInf_le\n    sSup_le := (@WithTop.WithBot.completeLattice \u03b1\u1d52\u1d48 _).le_sInf\n    sInf_le := (@WithTop.WithBot.completeLattice \u03b1\u1d52\u1d48 _).le_sSup\n    le_sInf := (@WithTop.WithBot.completeLattice \u03b1\u1d52\u1d48 _).sSup_le }", "start": [1689, 1], "end": [1695, 66], "kind": "commanddeclaration"}, {"full_name": "WithBot.WithTop.completeLinearOrder", "code": "noncomputable instance WithBot.WithTop.completeLinearOrder {\u03b1 : Type*}\n    [ConditionallyCompleteLinearOrder \u03b1] : CompleteLinearOrder (WithBot (WithTop \u03b1)) :=\n  { WithBot.WithTop.completeLattice, WithBot.linearOrder with }", "start": [1698, 1], "end": [1700, 64], "kind": "commanddeclaration"}, {"full_name": "WithTop.iSup_coe_eq_top", "code": "lemma iSup_coe_eq_top : \u2a06 x, (f x : WithTop \u03b1) = \u22a4 \u2194 \u00acBddAbove (range f) := by\n  rw [iSup_eq_top, not_bddAbove_iff]\n  refine' \u27e8fun hf r => _, fun hf a ha => _\u27e9\n  \u00b7 rcases hf r (WithTop.coe_lt_top r) with \u27e8i, hi\u27e9\n    exact \u27e8f i, \u27e8i, rfl\u27e9, WithTop.coe_lt_coe.mp hi\u27e9\n  \u00b7 rcases hf (a.untop ha.ne) with \u27e8-, \u27e8i, rfl\u27e9, hi\u27e9\n    exact \u27e8i, by simpa only [WithTop.coe_untop _ ha.ne] using WithTop.coe_lt_coe.mpr hi\u27e9", "start": [1706, 1], "end": [1712, 89], "kind": "mathlibtacticlemma"}, {"full_name": "WithTop.iSup_coe_lt_top", "code": "lemma iSup_coe_lt_top : \u2a06 x, (f x : WithTop \u03b1) < \u22a4 \u2194 BddAbove (range f) :=\n  lt_top_iff_ne_top.trans iSup_coe_eq_top.not_left", "start": [1715, 1], "end": [1716, 51], "kind": "mathlibtacticlemma"}, {"full_name": "WithTop.iInf_coe_eq_top", "code": "lemma iInf_coe_eq_top : \u2a05 x, (f x : WithTop \u03b1) = \u22a4 \u2194 IsEmpty \u03b9 := by simp [isEmpty_iff]", "start": [1719, 1], "end": [1719, 88], "kind": "mathlibtacticlemma"}, {"full_name": "WithTop.iInf_coe_lt_top", "code": "lemma iInf_coe_lt_top : \u2a05 i, (f i : WithTop \u03b1) < \u22a4 \u2194 Nonempty \u03b9 := by\n  rw [lt_top_iff_ne_top, Ne.def, iInf_coe_eq_top, not_isEmpty_iff]", "start": [1721, 1], "end": [1722, 67], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Set/Intervals/OrderIso.lean", "imports": ["Mathlib/Order/Hom/Set.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderIso.preimage_Iic", "code": "@[simp]\ntheorem preimage_Iic (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Iic b = Iic (e.symm b)", "start": [25, 1], "end": [28, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Ici", "code": "@[simp]\ntheorem preimage_Ici (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Ici b = Ici (e.symm b)", "start": [31, 1], "end": [34, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Iio", "code": "@[simp]\ntheorem preimage_Iio (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Iio b = Iio (e.symm b)", "start": [37, 1], "end": [40, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Ioi", "code": "@[simp]\ntheorem preimage_Ioi (e : \u03b1 \u2243o \u03b2) (b : \u03b2) : e \u207b\u00b9' Ioi b = Ioi (e.symm b)", "start": [43, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Icc", "code": "@[simp]\ntheorem preimage_Icc (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Icc a b = Icc (e.symm a) (e.symm b)", "start": [49, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Ico", "code": "@[simp]\ntheorem preimage_Ico (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ico a b = Ico (e.symm a) (e.symm b)", "start": [54, 1], "end": [56, 25], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Ioc", "code": "@[simp]\ntheorem preimage_Ioc (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ioc a b = Ioc (e.symm a) (e.symm b)", "start": [59, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "OrderIso.preimage_Ioo", "code": "@[simp]\ntheorem preimage_Ioo (e : \u03b1 \u2243o \u03b2) (a b : \u03b2) : e \u207b\u00b9' Ioo a b = Ioo (e.symm a) (e.symm b)", "start": [64, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Iic", "code": "@[simp]\ntheorem image_Iic (e : \u03b1 \u2243o \u03b2) (a : \u03b1) : e '' Iic a = Iic (e a)", "start": [69, 1], "end": [71, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Ici", "code": "@[simp]\ntheorem image_Ici (e : \u03b1 \u2243o \u03b2) (a : \u03b1) : e '' Ici a = Ici (e a)", "start": [74, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Iio", "code": "@[simp]\ntheorem image_Iio (e : \u03b1 \u2243o \u03b2) (a : \u03b1) : e '' Iio a = Iio (e a)", "start": [79, 1], "end": [81, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Ioi", "code": "@[simp]\ntheorem image_Ioi (e : \u03b1 \u2243o \u03b2) (a : \u03b1) : e '' Ioi a = Ioi (e a)", "start": [84, 1], "end": [86, 21], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Ioo", "code": "@[simp]\ntheorem image_Ioo (e : \u03b1 \u2243o \u03b2) (a b : \u03b1) : e '' Ioo a b = Ioo (e a) (e b)", "start": [89, 1], "end": [91, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Ioc", "code": "@[simp]\ntheorem image_Ioc (e : \u03b1 \u2243o \u03b2) (a b : \u03b1) : e '' Ioc a b = Ioc (e a) (e b)", "start": [94, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Ico", "code": "@[simp]\ntheorem image_Ico (e : \u03b1 \u2243o \u03b2) (a b : \u03b1) : e '' Ico a b = Ico (e a) (e b)", "start": [99, 1], "end": [101, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.image_Icc", "code": "@[simp]\ntheorem image_Icc (e : \u03b1 \u2243o \u03b2) (a b : \u03b1) : e '' Icc a b = Icc (e a) (e b)", "start": [104, 1], "end": [106, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.IicTop", "code": "def IicTop [Preorder \u03b1] [OrderTop \u03b1] : Iic (\u22a4 : \u03b1) \u2243o \u03b1 :=\n  { @Equiv.subtypeUnivEquiv \u03b1 (Iic (\u22a4 : \u03b1)) fun x => le_top with\n    map_rel_iff' := @fun x y => by rfl }", "start": [111, 1], "end": [114, 41], "kind": "commanddeclaration"}, {"full_name": "OrderIso.IciBot", "code": "def IciBot [Preorder \u03b1] [OrderBot \u03b1] : Ici (\u22a5 : \u03b1) \u2243o \u03b1 :=\n  { @Equiv.subtypeUnivEquiv \u03b1 (Ici (\u22a5 : \u03b1)) fun x => bot_le with\n    map_rel_iff' := @fun x y => by rfl }", "start": [117, 1], "end": [120, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/MinMax.lean", "imports": ["Mathlib/Algebra/Order/Monoid/MinMax.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "max_one_div_max_inv_one_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem max_one_div_max_inv_one_eq_self (a : \u03b1) : max a 1 / max a\u207b\u00b9 1 = a", "start": [20, 1], "end": [22, 48], "kind": "commanddeclaration"}, {"full_name": "max_zero_sub_eq_self", "code": "alias max_zero_sub_eq_self := max_zero_sub_max_neg_zero_eq_self", "start": [26, 1], "end": [26, 64], "kind": "stdtacticaliasalias"}, {"full_name": "min_inv_inv'", "code": "@[to_additive min_neg_neg]\ntheorem min_inv_inv' (a b : \u03b1) : min a\u207b\u00b9 b\u207b\u00b9 = (max a b)\u207b\u00b9", "start": [35, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "max_inv_inv'", "code": "@[to_additive max_neg_neg]\ntheorem max_inv_inv' (a b : \u03b1) : max a\u207b\u00b9 b\u207b\u00b9 = (min a b)\u207b\u00b9", "start": [43, 1], "end": [47, 34], "kind": "commanddeclaration"}, {"full_name": "min_div_div_right'", "code": "@[to_additive min_sub_sub_right]\ntheorem min_div_div_right' (a b c : \u03b1) : min (a / c) (b / c) = min a b / c", "start": [51, 1], "end": [53, 62], "kind": "commanddeclaration"}, {"full_name": "max_div_div_right'", "code": "@[to_additive max_sub_sub_right]\ntheorem max_div_div_right' (a b c : \u03b1) : max (a / c) (b / c) = max a b / c", "start": [57, 1], "end": [59, 62], "kind": "commanddeclaration"}, {"full_name": "min_div_div_left'", "code": "@[to_additive min_sub_sub_left]\ntheorem min_div_div_left' (a b c : \u03b1) : min (a / b) (a / c) = a / max b c", "start": [63, 1], "end": [65, 61], "kind": "commanddeclaration"}, {"full_name": "max_div_div_left'", "code": "@[to_additive max_sub_sub_left]\ntheorem max_div_div_left' (a b c : \u03b1) : max (a / b) (a / c) = a / min b c", "start": [69, 1], "end": [71, 61], "kind": "commanddeclaration"}, {"full_name": "max_sub_max_le_max", "code": "theorem max_sub_max_le_max (a b c d : \u03b1) : max a b - max c d \u2264 max (a - c) (b - d)", "start": [81, 1], "end": [88, 90], "kind": "commanddeclaration"}, {"full_name": "abs_max_sub_max_le_max", "code": "theorem abs_max_sub_max_le_max (a b c d : \u03b1) : |max a b - max c d| \u2264 max |a - c| |b - d|", "start": [91, 1], "end": [95, 90], "kind": "commanddeclaration"}, {"full_name": "abs_min_sub_min_le_max", "code": "theorem abs_min_sub_min_le_max (a b c d : \u03b1) : |min a b - min c d| \u2264 max |a - c| |b - d|", "start": [98, 1], "end": [100, 47], "kind": "commanddeclaration"}, {"full_name": "abs_max_sub_max_le_abs", "code": "theorem abs_max_sub_max_le_abs (a b c : \u03b1) : |max a c - max b c| \u2264 |a - b|", "start": [103, 1], "end": [105, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Chain.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsChain", "code": "def IsChain (s : Set \u03b1) : Prop :=\n  s.Pairwise fun x y => x \u227a y \u2228 y \u227a x", "start": [46, 1], "end": [48, 38], "kind": "commanddeclaration"}, {"full_name": "SuperChain", "code": "def SuperChain (s t : Set \u03b1) : Prop :=\n  IsChain r t \u2227 s \u2282 t", "start": [51, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "IsMaxChain", "code": "def IsMaxChain (s : Set \u03b1) : Prop :=\n  IsChain r s \u2227 \u2200 \u2983t\u2984, IsChain r t \u2192 s \u2286 t \u2192 s = t", "start": [56, 1], "end": [58, 51], "kind": "commanddeclaration"}, {"full_name": "isChain_empty", "code": "theorem isChain_empty : IsChain r \u2205", "start": [63, 1], "end": [64, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isChain", "code": "theorem Set.Subsingleton.isChain (hs : s.Subsingleton) : IsChain r s", "start": [67, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "IsChain.mono", "code": "theorem IsChain.mono : s \u2286 t \u2192 IsChain r t \u2192 IsChain r s", "start": [71, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "IsChain.mono_rel", "code": "theorem IsChain.mono_rel {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : IsChain r s) (h_imp : \u2200 x y, r x y \u2192 r' x y) :\n    IsChain r' s", "start": [75, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "IsChain.symm", "code": "theorem IsChain.symm (h : IsChain r s) : IsChain (flip r) s", "start": [80, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "isChain_of_trichotomous", "code": "theorem isChain_of_trichotomous [IsTrichotomous \u03b1 r] (s : Set \u03b1) : IsChain r s", "start": [85, 1], "end": [86, 83], "kind": "commanddeclaration"}, {"full_name": "IsChain.insert", "code": "protected theorem IsChain.insert (hs : IsChain r s) (ha : \u2200 b \u2208 s, a \u2260 b \u2192 a \u227a b \u2228 b \u227a a) :\n    IsChain r (insert a s)", "start": [89, 1], "end": [91, 49], "kind": "commanddeclaration"}, {"full_name": "isChain_univ_iff", "code": "theorem isChain_univ_iff : IsChain r (univ : Set \u03b1) \u2194 IsTrichotomous \u03b1 r", "start": [94, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "IsChain.image", "code": "theorem IsChain.image (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 x y, r x y \u2192 s (f x) (f y)) {c : Set \u03b1} (hrc : IsChain r c) : IsChain s (f '' c)", "start": [100, 1], "end": [103, 83], "kind": "commanddeclaration"}, {"full_name": "Monotone.isChain_range", "code": "theorem Monotone.isChain_range [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) :\n    IsChain (\u00b7 \u2264 \u00b7) (range f)", "start": [106, 1], "end": [109, 57], "kind": "commanddeclaration"}, {"full_name": "IsChain.lt_of_le", "code": "theorem IsChain.lt_of_le [PartialOrder \u03b1] {s : Set \u03b1} (h : IsChain (\u00b7 \u2264 \u00b7) s) :\n    IsChain (\u00b7 < \u00b7) s", "start": [111, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "IsChain.total", "code": "theorem IsChain.total (h : IsChain r s) (hx : x \u2208 s) (hy : y \u2208 s) : x \u227a y \u2228 y \u227a x", "start": [119, 1], "end": [120, 64], "kind": "commanddeclaration"}, {"full_name": "IsChain.directedOn", "code": "theorem IsChain.directedOn (H : IsChain r s) : DirectedOn r s", "start": [123, 1], "end": [124, 81], "kind": "commanddeclaration"}, {"full_name": "IsChain.directed", "code": "protected theorem IsChain.directed {f : \u03b2 \u2192 \u03b1} {c : Set \u03b2} (h : IsChain (f \u207b\u00b9'o r) c) :\n    Directed r fun x : { a : \u03b2 // a \u2208 c } => f x", "start": [127, 1], "end": [133, 96], "kind": "commanddeclaration"}, {"full_name": "IsChain.exists3", "code": "theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans \u03b1 r] {a b c} (mem1 : a \u2208 s) (mem2 : b \u2208 s)\n    (mem3 : c \u2208 s) : \u2203 (z : _) (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z", "start": [136, 1], "end": [141, 63], "kind": "commanddeclaration"}, {"full_name": "IsMaxChain.isChain", "code": "theorem IsMaxChain.isChain (h : IsMaxChain r s) : IsChain r s", "start": [146, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "IsMaxChain.not_superChain", "code": "theorem IsMaxChain.not_superChain (h : IsMaxChain r s) : \u00acSuperChain r s t", "start": [150, 1], "end": [151, 29], "kind": "commanddeclaration"}, {"full_name": "IsMaxChain.bot_mem", "code": "theorem IsMaxChain.bot_mem [LE \u03b1] [OrderBot \u03b1] (h : IsMaxChain (\u00b7 \u2264 \u00b7) s) : \u22a5 \u2208 s", "start": [154, 1], "end": [155, 91], "kind": "commanddeclaration"}, {"full_name": "IsMaxChain.top_mem", "code": "theorem IsMaxChain.top_mem [LE \u03b1] [OrderTop \u03b1] (h : IsMaxChain (\u00b7 \u2264 \u00b7) s) : \u22a4 \u2208 s", "start": [158, 1], "end": [159, 91], "kind": "commanddeclaration"}, {"full_name": "SuccChain", "code": "def SuccChain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Set \u03b1 :=\n  if h : \u2203 t, IsChain r s \u2227 SuperChain r s t then choose h else s", "start": [164, 1], "end": [167, 66], "kind": "commanddeclaration"}, {"full_name": "succChain_spec", "code": "theorem succChain_spec (h : \u2203 t, IsChain r s \u2227 SuperChain r s t) :\n    SuperChain r s (SuccChain r s)", "start": [170, 1], "end": [174, 64], "kind": "commanddeclaration"}, {"full_name": "IsChain.succ", "code": "theorem IsChain.succ (hs : IsChain r s) : IsChain r (SuccChain r s)", "start": [177, 1], "end": [181, 43], "kind": "commanddeclaration"}, {"full_name": "IsChain.superChain_succChain", "code": "theorem IsChain.superChain_succChain (hs\u2081 : IsChain r s) (hs\u2082 : \u00acIsMaxChain r s) :\n    SuperChain r s (SuccChain r s)", "start": [184, 1], "end": [188, 65], "kind": "commanddeclaration"}, {"full_name": "subset_succChain", "code": "theorem subset_succChain : s \u2286 SuccChain r s", "start": [191, 1], "end": [195, 45], "kind": "commanddeclaration"}, {"full_name": "ChainClosure", "code": "inductive ChainClosure (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Set \u03b1 \u2192 Prop\n  | succ : \u2200 {s}, ChainClosure r s \u2192 ChainClosure r (SuccChain r s)\n  | union : \u2200 {s}, (\u2200 a \u2208 s, ChainClosure r a) \u2192 ChainClosure r (\u22c3\u2080s)", "start": [198, 1], "end": [201, 70], "kind": "commanddeclaration"}, {"full_name": "maxChain", "code": "def maxChain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Set \u03b1 :=\n  \u22c3\u2080 setOf (ChainClosure r)", "start": [204, 1], "end": [207, 28], "kind": "commanddeclaration"}, {"full_name": "chainClosure_empty", "code": "theorem chainClosure_empty : ChainClosure r \u2205", "start": [210, 1], "end": [212, 19], "kind": "commanddeclaration"}, {"full_name": "chainClosure_maxChain", "code": "theorem chainClosure_maxChain : ChainClosure r (maxChain r)", "start": [215, 1], "end": [216, 33], "kind": "commanddeclaration"}, {"full_name": "chainClosure_succ_total_aux", "code": "private theorem chainClosure_succ_total_aux (hc\u2081 : ChainClosure r c\u2081)\n    (h : \u2200 \u2983c\u2083\u2984, ChainClosure r c\u2083 \u2192 c\u2083 \u2286 c\u2082 \u2192 c\u2082 = c\u2083 \u2228 SuccChain r c\u2083 \u2286 c\u2082) :\n    SuccChain r c\u2082 \u2286 c\u2081 \u2228 c\u2081 \u2286 c\u2082", "start": [219, 1], "end": [229, 83], "kind": "commanddeclaration"}, {"full_name": "chainClosure_succ_total", "code": "private theorem chainClosure_succ_total (hc\u2081 : ChainClosure r c\u2081) (hc\u2082 : ChainClosure r c\u2082)\n    (h : c\u2081 \u2286 c\u2082) : c\u2082 = c\u2081 \u2228 SuccChain r c\u2081 \u2286 c\u2082", "start": [231, 1], "end": [248, 54], "kind": "commanddeclaration"}, {"full_name": "ChainClosure.total", "code": "theorem ChainClosure.total (hc\u2081 : ChainClosure r c\u2081) (hc\u2082 : ChainClosure r c\u2082) :\n    c\u2081 \u2286 c\u2082 \u2228 c\u2082 \u2286 c\u2081", "start": [250, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "ChainClosure.succ_fixpoint", "code": "theorem ChainClosure.succ_fixpoint (hc\u2081 : ChainClosure r c\u2081) (hc\u2082 : ChainClosure r c\u2082)\n    (hc : SuccChain r c\u2082 = c\u2082) : c\u2081 \u2286 c\u2082", "start": [256, 1], "end": [260, 46], "kind": "commanddeclaration"}, {"full_name": "ChainClosure.succ_fixpoint_iff", "code": "theorem ChainClosure.succ_fixpoint_iff (hc : ChainClosure r c) :\n    SuccChain r c = c \u2194 c = maxChain r", "start": [263, 1], "end": [266, 95], "kind": "commanddeclaration"}, {"full_name": "ChainClosure.isChain", "code": "theorem ChainClosure.isChain (hc : ChainClosure r c) : IsChain r c", "start": [269, 1], "end": [275, 35], "kind": "commanddeclaration"}, {"full_name": "maxChain_spec", "code": "theorem maxChain_spec : IsMaxChain r (maxChain r)", "start": [278, 1], "end": [285, 64], "kind": "commanddeclaration"}, {"full_name": "Flag", "code": "structure Flag (\u03b1 : Type*) [LE \u03b1] where\n  \n  carrier : Set \u03b1\n  \n  Chain' : IsChain (\u00b7 \u2264 \u00b7) carrier\n  \n  max_chain' : \u2200 \u2983s\u2984, IsChain (\u00b7 \u2264 \u00b7) s \u2192 carrier \u2286 s \u2192 carrier = s", "start": [293, 1], "end": [300, 68], "kind": "commanddeclaration"}, {"full_name": "Flag.ext", "code": "@[ext]\ntheorem ext : (s : Set \u03b1) = t \u2192 s = t", "start": [316, 1], "end": [318, 15], "kind": "commanddeclaration"}, {"full_name": "Flag.mem_coe_iff", "code": "theorem mem_coe_iff : a \u2208 (s : Set \u03b1) \u2194 a \u2208 s", "start": [323, 1], "end": [324, 10], "kind": "commanddeclaration"}, {"full_name": "Flag.coe_mk", "code": "@[simp]\ntheorem coe_mk (s : Set \u03b1) (h\u2081 h\u2082) : (mk s h\u2081 h\u2082 : Set \u03b1) = s", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "Flag.mk_coe", "code": "@[simp]\ntheorem mk_coe (s : Flag \u03b1) : mk (s : Set \u03b1) s.Chain' s.max_chain' = s", "start": [332, 1], "end": [334, 10], "kind": "commanddeclaration"}, {"full_name": "Flag.chain_le", "code": "theorem chain_le (s : Flag \u03b1) : IsChain (\u00b7 \u2264 \u00b7) (s : Set \u03b1)", "start": [337, 1], "end": [338, 11], "kind": "commanddeclaration"}, {"full_name": "Flag.maxChain", "code": "protected theorem maxChain (s : Flag \u03b1) : IsMaxChain (\u00b7 \u2264 \u00b7) (s : Set \u03b1)", "start": [341, 1], "end": [342, 29], "kind": "commanddeclaration"}, {"full_name": "Flag.top_mem", "code": "theorem top_mem [OrderTop \u03b1] (s : Flag \u03b1) : (\u22a4 : \u03b1) \u2208 s", "start": [345, 1], "end": [346, 21], "kind": "commanddeclaration"}, {"full_name": "Flag.bot_mem", "code": "theorem bot_mem [OrderBot \u03b1] (s : Flag \u03b1) : (\u22a5 : \u03b1) \u2208 s", "start": [349, 1], "end": [350, 21], "kind": "commanddeclaration"}, {"full_name": "Flag.le_or_le", "code": "protected theorem le_or_le (s : Flag \u03b1) (ha : a \u2208 s) (hb : b \u2208 s) : a \u2264 b \u2228 b \u2264 a", "start": [359, 1], "end": [360, 25], "kind": "commanddeclaration"}, {"full_name": "Flag.chain_lt", "code": "theorem chain_lt (s : Flag \u03b1) : IsChain (\u00b7 < \u00b7) (s : Set \u03b1)", "start": [378, 1], "end": [378, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ModularLattice.lean", "imports": ["Mathlib/Order/Cover.lean", "Mathlib/Order/LatticeIntervals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsWeakUpperModularLattice", "code": "class IsWeakUpperModularLattice (\u03b1 : Type*) [Lattice \u03b1] : Prop where\n\n  covby_sup_of_inf_covby_covby {a b : \u03b1} : a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 a \u22d6 a \u2294 b", "start": [60, 1], "end": [64, 77], "kind": "commanddeclaration"}, {"full_name": "IsWeakLowerModularLattice", "code": "class IsWeakLowerModularLattice (\u03b1 : Type*) [Lattice \u03b1] : Prop where\n\n  inf_covby_of_covby_covby_sup {a b : \u03b1} : a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 a", "start": [67, 1], "end": [71, 77], "kind": "commanddeclaration"}, {"full_name": "IsUpperModularLattice", "code": "class IsUpperModularLattice (\u03b1 : Type*) [Lattice \u03b1] : Prop where\n\n  covby_sup_of_inf_covby {a b : \u03b1} : a \u2293 b \u22d6 a \u2192 b \u22d6 a \u2294 b", "start": [74, 1], "end": [78, 59], "kind": "commanddeclaration"}, {"full_name": "IsLowerModularLattice", "code": "class IsLowerModularLattice (\u03b1 : Type*) [Lattice \u03b1] : Prop where\n\n  inf_covby_of_covby_sup {a b : \u03b1} : a \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b", "start": [81, 1], "end": [85, 59], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice", "code": "class IsModularLattice (\u03b1 : Type*) [Lattice \u03b1] : Prop where\n\n  sup_inf_le_assoc_of_le : \u2200 {x : \u03b1} (y : \u03b1) {z : \u03b1}, x \u2264 z \u2192 (x \u2294 y) \u2293 z \u2264 x \u2294 y \u2293 z", "start": [88, 1], "end": [91, 86], "kind": "commanddeclaration"}, {"full_name": "covby_sup_of_inf_covby_of_inf_covby_left", "code": "theorem covby_sup_of_inf_covby_of_inf_covby_left : a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 a \u22d6 a \u2294 b", "start": [98, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "covby_sup_of_inf_covby_of_inf_covby_right", "code": "theorem covby_sup_of_inf_covby_of_inf_covby_right : a \u2293 b \u22d6 a \u2192 a \u2293 b \u22d6 b \u2192 b \u22d6 a \u2294 b", "start": [102, 1], "end": [104, 68], "kind": "commanddeclaration"}, {"full_name": "Covby.sup_of_inf_of_inf_left", "code": "alias Covby.sup_of_inf_of_inf_left := covby_sup_of_inf_covby_of_inf_covby_left", "start": [107, 1], "end": [107, 79], "kind": "stdtacticaliasalias"}, {"full_name": "Covby.sup_of_inf_of_inf_right", "code": "alias Covby.sup_of_inf_of_inf_right := covby_sup_of_inf_covby_of_inf_covby_right", "start": [110, 1], "end": [110, 81], "kind": "stdtacticaliasalias"}, {"full_name": "inf_covby_of_covby_sup_of_covby_sup_left", "code": "theorem inf_covby_of_covby_sup_of_covby_sup_left : a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 a", "start": [122, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "inf_covby_of_covby_sup_of_covby_sup_right", "code": "theorem inf_covby_of_covby_sup_of_covby_sup_right : a \u22d6 a \u2294 b \u2192 b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b", "start": [126, 1], "end": [128, 68], "kind": "commanddeclaration"}, {"full_name": "Covby.inf_of_sup_of_sup_left", "code": "alias Covby.inf_of_sup_of_sup_left := inf_covby_of_covby_sup_of_covby_sup_left", "start": [131, 1], "end": [131, 79], "kind": "stdtacticaliasalias"}, {"full_name": "Covby.inf_of_sup_of_sup_right", "code": "alias Covby.inf_of_sup_of_sup_right := inf_covby_of_covby_sup_of_covby_sup_right", "start": [134, 1], "end": [134, 81], "kind": "stdtacticaliasalias"}, {"full_name": "covby_sup_of_inf_covby_left", "code": "theorem covby_sup_of_inf_covby_left : a \u2293 b \u22d6 a \u2192 b \u22d6 a \u2294 b", "start": [146, 1], "end": [147, 47], "kind": "commanddeclaration"}, {"full_name": "covby_sup_of_inf_covby_right", "code": "theorem covby_sup_of_inf_covby_right : a \u2293 b \u22d6 b \u2192 a \u22d6 a \u2294 b", "start": [150, 1], "end": [152, 36], "kind": "commanddeclaration"}, {"full_name": "Covby.sup_of_inf_left", "code": "alias Covby.sup_of_inf_left := covby_sup_of_inf_covby_left", "start": [155, 1], "end": [155, 59], "kind": "stdtacticaliasalias"}, {"full_name": "Covby.sup_of_inf_right", "code": "alias Covby.sup_of_inf_right := covby_sup_of_inf_covby_right", "start": [158, 1], "end": [158, 61], "kind": "stdtacticaliasalias"}, {"full_name": "IsUpperModularLattice.to_isWeakUpperModularLattice", "code": "instance (priority := 100) IsUpperModularLattice.to_isWeakUpperModularLattice :\n    IsWeakUpperModularLattice \u03b1 :=\n  \u27e8fun _ => Covby.sup_of_inf_right\u27e9", "start": [162, 1], "end": [164, 36], "kind": "commanddeclaration"}, {"full_name": "inf_covby_of_covby_sup_left", "code": "theorem inf_covby_of_covby_sup_left : a \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 b", "start": [176, 1], "end": [177, 47], "kind": "commanddeclaration"}, {"full_name": "inf_covby_of_covby_sup_right", "code": "theorem inf_covby_of_covby_sup_right : b \u22d6 a \u2294 b \u2192 a \u2293 b \u22d6 a", "start": [180, 1], "end": [182, 36], "kind": "commanddeclaration"}, {"full_name": "Covby.inf_of_sup_left", "code": "alias Covby.inf_of_sup_left := inf_covby_of_covby_sup_left", "start": [185, 1], "end": [185, 59], "kind": "stdtacticaliasalias"}, {"full_name": "Covby.inf_of_sup_right", "code": "alias Covby.inf_of_sup_right := inf_covby_of_covby_sup_right", "start": [188, 1], "end": [188, 61], "kind": "stdtacticaliasalias"}, {"full_name": "IsLowerModularLattice.to_isWeakLowerModularLattice", "code": "instance (priority := 100) IsLowerModularLattice.to_isWeakLowerModularLattice :\n    IsWeakLowerModularLattice \u03b1 :=\n  \u27e8fun _ => Covby.inf_of_sup_right\u27e9", "start": [192, 1], "end": [194, 36], "kind": "commanddeclaration"}, {"full_name": "sup_inf_assoc_of_le", "code": "theorem sup_inf_assoc_of_le {x : \u03b1} (y : \u03b1) {z : \u03b1} (h : x \u2264 z) : (x \u2294 y) \u2293 z = x \u2294 y \u2293 z", "start": [206, 1], "end": [208, 69], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.inf_sup_inf_assoc", "code": "theorem IsModularLattice.inf_sup_inf_assoc {x y z : \u03b1} : x \u2293 z \u2294 y \u2293 z = (x \u2293 z \u2294 y) \u2293 z", "start": [211, 1], "end": [212, 44], "kind": "commanddeclaration"}, {"full_name": "inf_sup_assoc_of_le", "code": "theorem inf_sup_assoc_of_le {x : \u03b1} (y : \u03b1) {z : \u03b1} (h : z \u2264 x) : x \u2293 y \u2294 z = x \u2293 (y \u2294 z)", "start": [215, 1], "end": [216, 73], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.sup_inf_sup_assoc", "code": "theorem IsModularLattice.sup_inf_sup_assoc : (x \u2294 z) \u2293 (y \u2294 z) = (x \u2294 z) \u2293 y \u2294 z", "start": [228, 1], "end": [229, 52], "kind": "commanddeclaration"}, {"full_name": "eq_of_le_of_inf_le_of_sup_le", "code": "theorem eq_of_le_of_inf_le_of_sup_le (hxy : x \u2264 y) (hinf : y \u2293 z \u2264 x \u2293 z) (hsup : y \u2294 z \u2264 x \u2294 z) :\n    x = y", "start": [232, 1], "end": [243, 42], "kind": "commanddeclaration"}, {"full_name": "sup_lt_sup_of_lt_of_inf_le_inf", "code": "theorem sup_lt_sup_of_lt_of_inf_le_inf (hxy : x < y) (hinf : y \u2293 z \u2264 x \u2293 z) : x \u2294 z < y \u2294 z", "start": [246, 1], "end": [248, 90], "kind": "commanddeclaration"}, {"full_name": "inf_lt_inf_of_lt_of_sup_le_sup", "code": "theorem inf_lt_inf_of_lt_of_sup_le_sup (hxy : x < y) (hinf : y \u2294 z \u2264 x \u2294 z) : x \u2293 z < y \u2293 z", "start": [251, 1], "end": [252, 57], "kind": "commanddeclaration"}, {"full_name": "wellFounded_lt_exact_sequence", "code": "theorem wellFounded_lt_exact_sequence {\u03b2 \u03b3 : Type*} [PartialOrder \u03b2] [Preorder \u03b3]\n    (h\u2081 : WellFounded ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) (h\u2082 : WellFounded ((\u00b7 < \u00b7) : \u03b3 \u2192 \u03b3 \u2192 Prop)) (K : \u03b1)\n    (f\u2081 : \u03b2 \u2192 \u03b1) (f\u2082 : \u03b1 \u2192 \u03b2) (g\u2081 : \u03b3 \u2192 \u03b1) (g\u2082 : \u03b1 \u2192 \u03b3) (gci : GaloisCoinsertion f\u2081 f\u2082)\n    (gi : GaloisInsertion g\u2082 g\u2081) (hf : \u2200 a, f\u2081 (f\u2082 a) = a \u2293 K) (hg : \u2200 a, g\u2081 (g\u2082 a) = a \u2294 K) :\n    WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [255, 1], "end": [271, 37], "kind": "commanddeclaration"}, {"full_name": "wellFounded_gt_exact_sequence", "code": "theorem wellFounded_gt_exact_sequence {\u03b2 \u03b3 : Type*} [Preorder \u03b2] [PartialOrder \u03b3]\n    (h\u2081 : WellFounded ((\u00b7 > \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) (h\u2082 : WellFounded ((\u00b7 > \u00b7) : \u03b3 \u2192 \u03b3 \u2192 Prop)) (K : \u03b1)\n    (f\u2081 : \u03b2 \u2192 \u03b1) (f\u2082 : \u03b1 \u2192 \u03b2) (g\u2081 : \u03b3 \u2192 \u03b1) (g\u2082 : \u03b1 \u2192 \u03b3) (gci : GaloisCoinsertion f\u2081 f\u2082)\n    (gi : GaloisInsertion g\u2082 g\u2081) (hf : \u2200 a, f\u2081 (f\u2082 a) = a \u2293 K) (hg : \u2200 a, g\u2081 (g\u2082 a) = a \u2294 K) :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [274, 1], "end": [281, 96], "kind": "commanddeclaration"}, {"full_name": "infIccOrderIsoIccSup", "code": "@[simps]\ndef infIccOrderIsoIccSup (a b : \u03b1) : Set.Icc (a \u2293 b) a \u2243o Set.Icc b (a \u2294 b) where\n  toFun x := \u27e8x \u2294 b, \u27e8le_sup_right, sup_le_sup_right x.prop.2 b\u27e9\u27e9\n  invFun x := \u27e8a \u2293 x, \u27e8inf_le_inf_left a x.prop.1, inf_le_left\u27e9\u27e9\n  left_inv x :=\n    Subtype.ext\n      (by\n        change a \u2293 (\u2191x \u2294 b) = \u2191x\n        rw [sup_comm, \u2190 inf_sup_assoc_of_le _ x.prop.2, sup_eq_right.2 x.prop.1])\n  right_inv x :=\n    Subtype.ext\n      (by\n        change a \u2293 \u2191x \u2294 b = \u2191x\n        rw [inf_comm, inf_sup_assoc_of_le _ x.prop.1, inf_eq_left.2 x.prop.2])\n  map_rel_iff' := @fun x y => by\n    simp only [Subtype.mk_le_mk, Equiv.coe_fn_mk, and_true_iff, le_sup_right]\n    rw [\u2190 Subtype.coe_le_coe]\n    refine' \u27e8fun h => _, fun h => sup_le_sup_right h _\u27e9\n    rw [\u2190 sup_eq_right.2 x.prop.1, inf_sup_assoc_of_le _ x.prop.2, sup_comm, \u2190\n      sup_eq_right.2 y.prop.1, inf_sup_assoc_of_le _ y.prop.2, @sup_comm _ _ b]\n    exact inf_le_inf_left _ h", "start": [284, 1], "end": [305, 30], "kind": "commanddeclaration"}, {"full_name": "inf_strictMonoOn_Icc_sup", "code": "theorem inf_strictMonoOn_Icc_sup {a b : \u03b1} : StrictMonoOn (fun c => a \u2293 c) (Icc b (a \u2294 b))", "start": [310, 1], "end": [311, 68], "kind": "commanddeclaration"}, {"full_name": "sup_strictMonoOn_Icc_inf", "code": "theorem sup_strictMonoOn_Icc_inf {a b : \u03b1} : StrictMonoOn (fun c => c \u2294 b) (Icc (a \u2293 b) a)", "start": [314, 1], "end": [315, 63], "kind": "commanddeclaration"}, {"full_name": "infIooOrderIsoIooSup", "code": "@[simps]\ndef infIooOrderIsoIooSup (a b : \u03b1) : Ioo (a \u2293 b) a \u2243o Ioo b (a \u2294 b) where\n  toFun c :=\n    \u27e8c \u2294 b,\n      le_sup_right.trans_lt <|\n        sup_strictMonoOn_Icc_inf (left_mem_Icc.2 inf_le_left) (Ioo_subset_Icc_self c.2) c.2.1,\n      sup_strictMonoOn_Icc_inf (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 inf_le_left) c.2.2\u27e9\n  invFun c :=\n    \u27e8a \u2293 c,\n      inf_strictMonoOn_Icc_sup (left_mem_Icc.2 le_sup_right) (Ioo_subset_Icc_self c.2) c.2.1,\n      inf_le_left.trans_lt' <|\n        inf_strictMonoOn_Icc_sup (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 le_sup_right) c.2.2\u27e9\n  left_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [sup_comm, \u2190 inf_sup_assoc_of_le _ c.prop.2.le, sup_eq_right.2 c.prop.1.le]\n  right_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [inf_comm, inf_sup_assoc_of_le _ c.prop.1.le, inf_eq_left.2 c.prop.2.le]\n  map_rel_iff' := @fun c d =>\n    @OrderIso.le_iff_le _ _ _ _ (infIccOrderIsoIccSup _ _) \u27e8c.1, Ioo_subset_Icc_self c.2\u27e9\n      \u27e8d.1, Ioo_subset_Icc_self d.2\u27e9", "start": [318, 1], "end": [341, 37], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.to_isLowerModularLattice", "code": "instance (priority := 100) IsModularLattice.to_isLowerModularLattice : IsLowerModularLattice \u03b1 :=\n  \u27e8fun {a b} => by\n    simp_rw [covby_iff_Ioo_eq, @sup_comm _ _ a, @inf_comm _ _ a, \u2190 isEmpty_coe_sort, right_lt_sup,\n      inf_lt_left, (infIooOrderIsoIooSup b a).symm.toEquiv.isEmpty_congr]\n    exact id\u27e9", "start": [347, 1], "end": [351, 14], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.to_isUpperModularLattice", "code": "instance (priority := 100) IsModularLattice.to_isUpperModularLattice : IsUpperModularLattice \u03b1 :=\n  \u27e8fun {a b} => by\n    simp_rw [covby_iff_Ioo_eq, \u2190 isEmpty_coe_sort, right_lt_sup, inf_lt_left,\n      (infIooOrderIsoIooSup a b).toEquiv.isEmpty_congr]\n    exact id\u27e9", "start": [355, 1], "end": [359, 14], "kind": "commanddeclaration"}, {"full_name": "IsCompl.IicOrderIsoIci", "code": "def IicOrderIsoIci {a b : \u03b1} (h : IsCompl a b) : Set.Iic a \u2243o Set.Ici b :=\n  (OrderIso.setCongr (Set.Iic a) (Set.Icc (a \u2293 b) a)\n        (h.inf_eq_bot.symm \u25b8 Set.Icc_bot.symm)).trans <|\n    (infIccOrderIsoIccSup a b).trans\n      (OrderIso.setCongr (Set.Icc b (a \u2294 b)) (Set.Ici b) (h.sup_eq_top.symm \u25b8 Set.Icc_top))", "start": [368, 1], "end": [373, 92], "kind": "commanddeclaration"}, {"full_name": "isModularLattice_iff_inf_sup_inf_assoc", "code": "theorem isModularLattice_iff_inf_sup_inf_assoc [Lattice \u03b1] :\n    IsModularLattice \u03b1 \u2194 \u2200 x y z : \u03b1, x \u2293 z \u2294 y \u2293 z = (x \u2293 z \u2294 y) \u2293 z", "start": [378, 1], "end": [381, 51], "kind": "commanddeclaration"}, {"full_name": "Disjoint.disjoint_sup_right_of_disjoint_sup_left", "code": "theorem disjoint_sup_right_of_disjoint_sup_left [Lattice \u03b1] [OrderBot \u03b1]\n    [IsModularLattice \u03b1] (h : Disjoint a b) (hsup : Disjoint (a \u2294 b) c) :\n    Disjoint a (b \u2294 c)", "start": [395, 1], "end": [401, 77], "kind": "commanddeclaration"}, {"full_name": "Disjoint.disjoint_sup_left_of_disjoint_sup_right", "code": "theorem disjoint_sup_left_of_disjoint_sup_right [Lattice \u03b1] [OrderBot \u03b1]\n    [IsModularLattice \u03b1] (h : Disjoint b c) (hsup : Disjoint a (b \u2294 c)) :\n    Disjoint (a \u2294 b) c", "start": [404, 1], "end": [409, 40], "kind": "commanddeclaration"}, {"full_name": "Disjoint.isCompl_sup_right_of_isCompl_sup_left", "code": "theorem isCompl_sup_right_of_isCompl_sup_left [Lattice \u03b1] [BoundedOrder \u03b1] [IsModularLattice \u03b1]\n    (h : Disjoint a b) (hcomp : IsCompl (a \u2294 b) c) :\n    IsCompl a (b \u2294 c)", "start": [412, 1], "end": [415, 99], "kind": "commanddeclaration"}, {"full_name": "Disjoint.isCompl_sup_left_of_isCompl_sup_right", "code": "theorem isCompl_sup_left_of_isCompl_sup_right [Lattice \u03b1] [BoundedOrder \u03b1] [IsModularLattice \u03b1]\n    (h : Disjoint b c) (hcomp : IsCompl a (b \u2294 c)) :\n    IsCompl (a \u2294 b) c", "start": [417, 1], "end": [420, 100], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.isModularLattice_Iic", "code": "instance isModularLattice_Iic : IsModularLattice (Set.Iic a) :=\n  \u27e8@fun x y z xz => (sup_inf_le_assoc_of_le (y : \u03b1) xz : (\u2191x \u2294 \u2191y) \u2293 \u2191z \u2264 \u2191x \u2294 \u2191y \u2293 \u2191z)\u27e9", "start": [428, 1], "end": [429, 89], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.isModularLattice_Ici", "code": "instance isModularLattice_Ici : IsModularLattice (Set.Ici a) :=\n  \u27e8@fun x y z xz => (sup_inf_le_assoc_of_le (y : \u03b1) xz : (\u2191x \u2294 \u2191y) \u2293 \u2191z \u2264 \u2191x \u2294 \u2191y \u2293 \u2191z)\u27e9", "start": [432, 1], "end": [433, 89], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.complementedLattice_Iic", "code": "instance complementedLattice_Iic : ComplementedLattice (Set.Iic a) :=\n  \u27e8fun \u27e8x, hx\u27e9 =>\n    let \u27e8y, hy\u27e9 := exists_isCompl x\n    \u27e8\u27e8y \u2293 a, Set.mem_Iic.2 inf_le_right\u27e9, by\n      constructor\n      \u00b7 rw [disjoint_iff_inf_le]\n        change x \u2293 (y \u2293 a) \u2264 \u22a5\n        rw [\u2190 inf_assoc]\n        exact le_trans inf_le_left hy.1.le_bot\n      \u00b7 rw [codisjoint_iff_le_sup]\n        change a \u2264 x \u2294 y \u2293 a\n        rw [\u2190 sup_inf_assoc_of_le _ (Set.mem_Iic.1 hx), hy.2.eq_top, top_inf_eq]\u27e9\u27e9", "start": [440, 1], "end": [453, 83], "kind": "commanddeclaration"}, {"full_name": "IsModularLattice.complementedLattice_Ici", "code": "instance complementedLattice_Ici : ComplementedLattice (Set.Ici a) :=\n  \u27e8fun \u27e8x, hx\u27e9 =>\n    let \u27e8y, hy\u27e9 := exists_isCompl x\n    \u27e8\u27e8y \u2294 a, Set.mem_Ici.2 le_sup_right\u27e9, by\n      constructor\n      \u00b7 rw [disjoint_iff_inf_le]\n        change x \u2293 (y \u2294 a) \u2264 a\n        rw [\u2190 inf_sup_assoc_of_le _ (Set.mem_Ici.1 hx), hy.1.eq_bot, bot_sup_eq]\n      \u00b7 rw [codisjoint_iff_le_sup]\n        change \u22a4 \u2264 x \u2294 (y \u2294 a)\n        rw [\u2190 sup_assoc]\n        exact le_trans hy.2.top_le le_sup_left\u27e9\u27e9", "start": [456, 1], "end": [469, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "imports": ["Mathlib/GroupTheory/Subsemigroup/Basic.lean", "Mathlib/Algebra/Group/TypeTags.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subsemigroup.toAddSubsemigroup", "code": "@[simps]\ndef Subsemigroup.toAddSubsemigroup : Subsemigroup M \u2243o AddSubsemigroup (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul \u207b\u00b9' S\n      add_mem' := S.mul_mem' }\n  invFun S :=\n    { carrier := Additive.ofMul \u207b\u00b9' S\n      mul_mem' := S.add_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl", "start": [79, 1], "end": [90, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubsemigroup.toSubsemigroup'", "code": "abbrev AddSubsemigroup.toSubsemigroup' : AddSubsemigroup (Additive M) \u2243o Subsemigroup M :=\n  Subsemigroup.toAddSubsemigroup.symm", "start": [95, 1], "end": [98, 38], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.toAddSubsemigroup_closure", "code": "theorem Subsemigroup.toAddSubsemigroup_closure (S : Set M) :\n    Subsemigroup.toAddSubsemigroup (Subsemigroup.closure S) =\n    AddSubsemigroup.closure (Additive.toMul \u207b\u00b9' S)", "start": [101, 1], "end": [107, 74], "kind": "commanddeclaration"}, {"full_name": "AddSubsemigroup.toSubsemigroup'_closure", "code": "theorem AddSubsemigroup.toSubsemigroup'_closure (S : Set (Additive M)) :\n    AddSubsemigroup.toSubsemigroup' (AddSubsemigroup.closure S) =\n      Subsemigroup.closure (Multiplicative.ofAdd \u207b\u00b9' S)", "start": [110, 1], "end": [116, 83], "kind": "commanddeclaration"}, {"full_name": "AddSubsemigroup.toSubsemigroup", "code": "@[simps]\ndef AddSubsemigroup.toSubsemigroup : AddSubsemigroup A \u2243o Subsemigroup (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd \u207b\u00b9' S\n      mul_mem' := S.add_mem' }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd \u207b\u00b9' S\n      add_mem' := S.mul_mem' }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl", "start": [125, 1], "end": [137, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.toAddSubsemigroup'", "code": "abbrev Subsemigroup.toAddSubsemigroup' : Subsemigroup (Multiplicative A) \u2243o AddSubsemigroup A :=\n  AddSubsemigroup.toSubsemigroup.symm", "start": [142, 1], "end": [145, 38], "kind": "commanddeclaration"}, {"full_name": "AddSubsemigroup.toSubsemigroup_closure", "code": "theorem AddSubsemigroup.toSubsemigroup_closure (S : Set A) :\n    AddSubsemigroup.toSubsemigroup (AddSubsemigroup.closure S) =\n      Subsemigroup.closure (Multiplicative.toAdd \u207b\u00b9' S)", "start": [148, 1], "end": [154, 74], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.toAddSubsemigroup'_closure", "code": "theorem Subsemigroup.toAddSubsemigroup'_closure (S : Set (Multiplicative A)) :\n    Subsemigroup.toAddSubsemigroup' (Subsemigroup.closure S) =\n    AddSubsemigroup.closure (Additive.ofMul \u207b\u00b9' S)", "start": [157, 1], "end": [163, 89], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap", "code": "@[to_additive\n      \"The preimage of an `AddSubsemigroup` along an `AddSemigroup` homomorphism is an\n      `AddSubsemigroup`.\"]\ndef comap (f : M \u2192\u2099* N) (S : Subsemigroup N) :\n    Subsemigroup M where\n  carrier := f \u207b\u00b9' S\n  mul_mem' ha hb := show f (_ * _) \u2208 S by rw [map_mul]; exact mul_mem ha hb", "start": [179, 1], "end": [186, 76], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_comap", "code": "@[to_additive (attr := simp)]\ntheorem coe_comap (S : Subsemigroup N) (f : M \u2192\u2099* N) : (S.comap f : Set M) = f \u207b\u00b9' S", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_comap", "code": "@[to_additive (attr := simp)]\ntheorem mem_comap {S : Subsemigroup N} {f : M \u2192\u2099* N} {x : M} : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [196, 1], "end": [198, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_comap", "code": "@[to_additive]\ntheorem comap_comap (S : Subsemigroup P) (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) :\n    (S.comap g).comap f = S.comap (g.comp f)", "start": [202, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_id", "code": "@[to_additive (attr := simp)]\ntheorem comap_id (S : Subsemigroup P) : S.comap (MulHom.id _) = S", "start": [209, 1], "end": [211, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map", "code": "@[to_additive\n      \"The image of an `AddSubsemigroup` along an `AddSemigroup` homomorphism is\n      an `AddSubsemigroup`.\"]\ndef map (f : M \u2192\u2099* N) (S : Subsemigroup M) : Subsemigroup N where\n  carrier := f '' S\n  mul_mem' := by\n    rintro _ _ \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9\n    exact \u27e8x * y, @mul_mem (Subsemigroup M) M _ _ _ _ _ _ hx hy, by rw [map_mul]\u27e9", "start": [215, 1], "end": [223, 82], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_map", "code": "@[to_additive (attr := simp)]\ntheorem coe_map (f : M \u2192\u2099* N) (S : Subsemigroup M) : (S.map f : Set N) = f '' S", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_map", "code": "@[to_additive (attr := simp)]\ntheorem mem_map {f : M \u2192\u2099* N} {S : Subsemigroup M} {y : N} : y \u2208 S.map f \u2194 \u2203 x \u2208 S, f x = y", "start": [233, 1], "end": [235, 18], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_map_of_mem", "code": "@[to_additive]\ntheorem mem_map_of_mem (f : M \u2192\u2099* N) {S : Subsemigroup M} {x : M} (hx : x \u2208 S) : f x \u2208 S.map f", "start": [239, 1], "end": [241, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.apply_coe_mem_map", "code": "@[to_additive]\ntheorem apply_coe_mem_map (f : M \u2192\u2099* N) (S : Subsemigroup M) (x : S) : f x \u2208 S.map f", "start": [245, 1], "end": [247, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_map", "code": "@[to_additive]\ntheorem map_map (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) : (S.map f).map g = S.map (g.comp f)", "start": [251, 1], "end": [253, 45], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_map_iff_mem", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem mem_map_iff_mem {f : M \u2192\u2099* N} (hf : Function.Injective f) {S : Subsemigroup M} {x : M} :\n    f x \u2208 S.map f \u2194 x \u2208 S", "start": [260, 1], "end": [263, 19], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_le_iff_le_comap", "code": "@[to_additive]\ntheorem map_le_iff_le_comap {f : M \u2192\u2099* N} {S : Subsemigroup M} {T : Subsemigroup N} :\n    S.map f \u2264 T \u2194 S \u2264 T.comap f", "start": [267, 1], "end": [270, 19], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.gc_map_comap", "code": "@[to_additive]\ntheorem gc_map_comap (f : M \u2192\u2099* N) : GaloisConnection (map f) (comap f)", "start": [274, 1], "end": [276, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_le_of_le_comap", "code": "@[to_additive]\ntheorem map_le_of_le_comap {T : Subsemigroup N} {f : M \u2192\u2099* N} : S \u2264 T.comap f \u2192 S.map f \u2264 T", "start": [280, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.le_comap_of_map_le", "code": "@[to_additive]\ntheorem le_comap_of_map_le {T : Subsemigroup N} {f : M \u2192\u2099* N} : S.map f \u2264 T \u2192 S \u2264 T.comap f", "start": [286, 1], "end": [288, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.le_comap_map", "code": "@[to_additive]\ntheorem le_comap_map {f : M \u2192\u2099* N} : S \u2264 (S.map f).comap f", "start": [292, 1], "end": [294, 28], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_comap_le", "code": "@[to_additive]\ntheorem map_comap_le {S : Subsemigroup N} {f : M \u2192\u2099* N} : (S.comap f).map f \u2264 S", "start": [298, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.monotone_map", "code": "@[to_additive]\ntheorem monotone_map {f : M \u2192\u2099* N} : Monotone (map f)", "start": [304, 1], "end": [306, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.monotone_comap", "code": "@[to_additive]\ntheorem monotone_comap {f : M \u2192\u2099* N} : Monotone (comap f)", "start": [310, 1], "end": [312, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_comap_map", "code": "@[to_additive (attr := simp)]\ntheorem map_comap_map {f : M \u2192\u2099* N} : ((S.map f).comap f).map f = S.map f", "start": [316, 1], "end": [318, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_map_comap", "code": "@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Subsemigroup N} {f : M \u2192\u2099* N} :\n    ((S.comap f).map f).comap f = S.comap f", "start": [322, 1], "end": [325, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_sup", "code": "@[to_additive]\ntheorem map_sup (S T : Subsemigroup M) (f : M \u2192\u2099* N) : (S \u2294 T).map f = S.map f \u2294 T.map f", "start": [329, 1], "end": [331, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_iSup", "code": "@[to_additive]\ntheorem map_iSup {\u03b9 : Sort*} (f : M \u2192\u2099* N) (s : \u03b9 \u2192 Subsemigroup M) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [335, 1], "end": [338, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_inf", "code": "@[to_additive]\ntheorem comap_inf (S T : Subsemigroup N) (f : M \u2192\u2099* N) : (S \u2293 T).comap f = S.comap f \u2293 T.comap f", "start": [342, 1], "end": [344, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_iInf", "code": "@[to_additive]\ntheorem comap_iInf {\u03b9 : Sort*} (f : M \u2192\u2099* N) (s : \u03b9 \u2192 Subsemigroup N) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [348, 1], "end": [351, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_bot", "code": "@[to_additive (attr := simp)]\ntheorem map_bot (f : M \u2192\u2099* N) : (\u22a5 : Subsemigroup M).map f = \u22a5", "start": [355, 1], "end": [357, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_top", "code": "@[to_additive (attr := simp)]\ntheorem comap_top (f : M \u2192\u2099* N) : (\u22a4 : Subsemigroup N).comap f = \u22a4", "start": [361, 1], "end": [363, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id (S : Subsemigroup M) : S.map (MulHom.id M) = S", "start": [367, 1], "end": [369, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.gciMapComap", "code": "@[to_additive \" `map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. \"]\ndef gciMapComap : GaloisCoinsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisCoinsertion fun S x => by simp [mem_comap, mem_map, hf.eq_iff]", "start": [379, 1], "end": [382, 90], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_map_eq_of_injective", "code": "@[to_additive]\ntheorem comap_map_eq_of_injective (S : Subsemigroup M) : (S.map f).comap f = S", "start": [386, 1], "end": [388, 28], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_surjective_of_injective", "code": "@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f)", "start": [392, 1], "end": [394, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_injective_of_injective", "code": "@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f)", "start": [398, 1], "end": [400, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_inf_map_of_injective", "code": "@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Subsemigroup M) : (S.map f \u2293 T.map f).comap f = S \u2293 T", "start": [404, 1], "end": [406, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_iInf_map_of_injective", "code": "@[to_additive]\ntheorem comap_iInf_map_of_injective (S : \u03b9 \u2192 Subsemigroup M) :\n    (\u2a05 i, (S i).map f).comap f = iInf S", "start": [410, 1], "end": [413, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_sup_map_of_injective", "code": "@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Subsemigroup M) : (S.map f \u2294 T.map f).comap f = S \u2294 T", "start": [417, 1], "end": [419, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_iSup_map_of_injective", "code": "@[to_additive]\ntheorem comap_iSup_map_of_injective (S : \u03b9 \u2192 Subsemigroup M) :\n    (\u2a06 i, (S i).map f).comap f = iSup S", "start": [423, 1], "end": [426, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_le_map_iff_of_injective", "code": "@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Subsemigroup M} : S.map f \u2264 T.map f \u2194 S \u2264 T", "start": [430, 1], "end": [432, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_strictMono_of_injective", "code": "@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f)", "start": [436, 1], "end": [438, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.giMapComap", "code": "@[to_additive \" `map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. \"]\ndef giMapComap : GaloisInsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisInsertion fun S x h =>\n    let \u27e8y, hy\u27e9 := hf x\n    mem_map.2 \u27e8y, by simp [hy, h]\u27e9", "start": [448, 1], "end": [453, 35], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_comap_eq_of_surjective", "code": "@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Subsemigroup N) : (S.comap f).map f = S", "start": [457, 1], "end": [459, 27], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_surjective_of_surjective", "code": "@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f)", "start": [463, 1], "end": [465, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_injective_of_surjective", "code": "@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f)", "start": [469, 1], "end": [471, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_inf_comap_of_surjective", "code": "@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f \u2293 T.comap f).map f = S \u2293 T", "start": [475, 1], "end": [478, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_iInf_comap_of_surjective", "code": "@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : \u03b9 \u2192 Subsemigroup N) :\n    (\u2a05 i, (S i).comap f).map f = iInf S", "start": [482, 1], "end": [485, 29], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_sup_comap_of_surjective", "code": "@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Subsemigroup N) :\n    (S.comap f \u2294 T.comap f).map f = S \u2294 T", "start": [489, 1], "end": [492, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_iSup_comap_of_surjective", "code": "@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : \u03b9 \u2192 Subsemigroup N) :\n    (\u2a06 i, (S i).comap f).map f = iSup S", "start": [496, 1], "end": [499, 29], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_le_comap_iff_of_surjective", "code": "@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Subsemigroup N} : S.comap f \u2264 T.comap f \u2194 S \u2264 T", "start": [503, 1], "end": [505, 29], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_strictMono_of_surjective", "code": "@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f)", "start": [509, 1], "end": [511, 31], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mul", "code": "@[to_additive \"An additive submagma of an additive magma inherits an addition.\"]\ninstance (priority := 900) mul : Mul S' :=\n  \u27e8fun a b => \u27e8a.1 * b.1, mul_mem a.2 b.2\u27e9\u27e9", "start": [524, 1], "end": [527, 44], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.coe_mul", "code": "@[to_additive (attr := simp low, norm_cast)]\ntheorem coe_mul (x y : S') : (\u2191(x * y) : M) = \u2191x * \u2191y", "start": [532, 1], "end": [534, 6], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mk_mul_mk", "code": "@[to_additive (attr := simp low)]\ntheorem mk_mul_mk (x y : M) (hx : x \u2208 S') (hy : y \u2208 S') :\n    (\u27e8x, hx\u27e9 : S') * \u27e8y, hy\u27e9 = \u27e8x * y, mul_mem hx hy\u27e9", "start": [539, 1], "end": [542, 6], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mul_def", "code": "@[to_additive]\ntheorem mul_def (x y : S') : x * y = \u27e8x * y, mul_mem x.2 y.2\u27e9", "start": [546, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.toSemigroup", "code": "@[to_additive \"An `AddSubsemigroup` of an `AddSemigroup` inherits an `AddSemigroup` structure.\"]\ninstance toSemigroup {M : Type*} [Semigroup M] {A : Type*} [SetLike A M] [MulMemClass A M]\n    (S : A) : Semigroup S :=\n  Subtype.coe_injective.semigroup Subtype.val fun _ _ => rfl", "start": [552, 1], "end": [556, 61], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.toCommSemigroup", "code": "@[to_additive \"An `AddSubsemigroup` of an `AddCommSemigroup` is an `AddCommSemigroup`.\"]\ninstance toCommSemigroup {M} [CommSemigroup M] {A : Type*} [SetLike A M] [MulMemClass A M]\n    (S : A) : CommSemigroup S :=\n  Subtype.coe_injective.commSemigroup Subtype.val fun _ _ => rfl", "start": [560, 1], "end": [564, 65], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.subtype", "code": "@[to_additive \"The natural semigroup hom from an `AddSubsemigroup` of\n`AddSubsemigroup` `M` to `M`.\"]\ndef subtype : S' \u2192\u2099* M where\n  toFun := Subtype.val; map_mul' := fun _ _ => rfl", "start": [568, 1], "end": [572, 51], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.coe_subtype", "code": "@[to_additive (attr := simp)]\ntheorem coe_subtype : (MulMemClass.subtype S' : S' \u2192 M) = Subtype.val", "start": [576, 1], "end": [578, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.topEquiv", "code": "@[to_additive (attr := simps)\n  \"The top additive subsemigroup is isomorphic to the additive semigroup.\"]\ndef topEquiv : (\u22a4 : Subsemigroup M) \u2243* M where\n  toFun x := x\n  invFun x := \u27e8x, mem_top x\u27e9\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl", "start": [588, 1], "end": [596, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.topEquiv_toMulHom", "code": "@[to_additive (attr := simp)]\ntheorem topEquiv_toMulHom :\n    ((topEquiv : _ \u2243* M) : _ \u2192\u2099* M) = MulMemClass.subtype (\u22a4 : Subsemigroup M)", "start": [603, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.equivMapOfInjective", "code": "@[to_additive \"An additive subsemigroup is isomorphic to its image under an injective function\"]\nnoncomputable def equivMapOfInjective (f : M \u2192\u2099* N) (hf : Function.Injective f) : S \u2243* S.map f :=\n  { Equiv.Set.image f S hf with map_mul' := fun _ _ => Subtype.ext (map_mul f _ _) }", "start": [610, 1], "end": [613, 85], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_equivMapOfInjective_apply", "code": "@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M \u2192\u2099* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x", "start": [617, 1], "end": [620, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.closure_closure_coe_preimage", "code": "@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} :\n    closure ((Subtype.val : closure s \u2192 M) \u207b\u00b9' s) = \u22a4", "start": [624, 1], "end": [630, 37], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.prod", "code": "@[to_additive prod\n      \"Given `AddSubsemigroup`s `s`, `t` of `AddSemigroup`s `A`, `B` respectively,\n      `s \u00d7 t` as an `AddSubsemigroup` of `A \u00d7 B`.\"]\ndef prod (s : Subsemigroup M) (t : Subsemigroup N) : Subsemigroup (M \u00d7 N) where\n  carrier := s \u00d7\u02e2 t\n  mul_mem' hp hq := \u27e8s.mul_mem hp.1 hq.1, t.mul_mem hp.2 hq.2\u27e9", "start": [634, 1], "end": [641, 63], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_prod", "code": "@[to_additive coe_prod]\ntheorem coe_prod (s : Subsemigroup M) (t : Subsemigroup N) :\n    (s.prod t : Set (M \u00d7 N)) = (s : Set M) \u00d7\u02e2 (t : Set N)", "start": [645, 1], "end": [648, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_prod", "code": "@[to_additive mem_prod]\ntheorem mem_prod {s : Subsemigroup M} {t : Subsemigroup N} {p : M \u00d7 N} :\n    p \u2208 s.prod t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [652, 1], "end": [655, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.prod_mono", "code": "@[to_additive prod_mono]\ntheorem prod_mono {s\u2081 s\u2082 : Subsemigroup M} {t\u2081 t\u2082 : Subsemigroup N} (hs : s\u2081 \u2264 s\u2082) (ht : t\u2081 \u2264 t\u2082) :\n    s\u2081.prod t\u2081 \u2264 s\u2082.prod t\u2082", "start": [659, 1], "end": [662, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.prod_top", "code": "@[to_additive prod_top]\ntheorem prod_top (s : Subsemigroup M) : s.prod (\u22a4 : Subsemigroup N) = s.comap (MulHom.fst M N)", "start": [666, 1], "end": [668, 50], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.top_prod", "code": "@[to_additive top_prod]\ntheorem top_prod (s : Subsemigroup N) : (\u22a4 : Subsemigroup M).prod s = s.comap (MulHom.snd M N)", "start": [672, 1], "end": [674, 50], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.top_prod_top", "code": "@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (\u22a4 : Subsemigroup M).prod (\u22a4 : Subsemigroup N) = \u22a4", "start": [678, 1], "end": [680, 36], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.bot_prod_bot", "code": "@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (\u22a5 : Subsemigroup M).prod (\u22a5 : Subsemigroup N) = \u22a5", "start": [684, 1], "end": [686, 62], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.prodEquiv", "code": "@[to_additive prodEquiv\n    \"The product of additive subsemigroups is isomorphic to their product as additive semigroups\"]\ndef prodEquiv (s : Subsemigroup M) (t : Subsemigroup N) : s.prod t \u2243* s \u00d7 t :=\n  { (Equiv.Set.prod (s : Set M) (t : Set N)) with\n    map_mul' := fun _ _ => rfl }", "start": [690, 1], "end": [695, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_map_equiv", "code": "@[to_additive]\ntheorem mem_map_equiv {f : M \u2243* N} {K : Subsemigroup M} {x : N} :\n    x \u2208 K.map (f : M \u2192\u2099* N) \u2194 f.symm x \u2208 K", "start": [701, 1], "end": [704, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_equiv_eq_comap_symm", "code": "@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M \u2243* N) (K : Subsemigroup M) :\n    K.map (f : M \u2192\u2099* N) = K.comap (f.symm : N \u2192\u2099* M)", "start": [708, 1], "end": [711, 56], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.comap_equiv_eq_map_symm", "code": "@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N \u2243* M) (K : Subsemigroup M) :\n    K.comap (f : N \u2192\u2099* M) = K.map (f.symm : M \u2192\u2099* N)", "start": [715, 1], "end": [718, 42], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.map_equiv_top", "code": "@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M \u2243* N) : (\u22a4 : Subsemigroup M).map (f : M \u2192\u2099* N) = \u22a4", "start": [722, 1], "end": [724, 70], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.le_prod_iff", "code": "@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Subsemigroup M} {t : Subsemigroup N} {u : Subsemigroup (M \u00d7 N)} :\n    u \u2264 s.prod t \u2194 u.map (fst M N) \u2264 s \u2227 u.map (snd M N) \u2264 t", "start": [728, 1], "end": [739, 43], "kind": "commanddeclaration"}, {"full_name": "MulHom.srange", "code": "@[to_additive \"The range of an `AddHom` is an `AddSubsemigroup`.\"]\ndef srange (f : M \u2192\u2099* N) : Subsemigroup N :=\n  ((\u22a4 : Subsemigroup M).map f).copy (Set.range f) Set.image_univ.symm", "start": [751, 1], "end": [754, 70], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_srange", "code": "@[to_additive (attr := simp)]\ntheorem coe_srange (f : M \u2192\u2099* N) : (f.srange : Set N) = Set.range f", "start": [758, 1], "end": [760, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.mem_srange", "code": "@[to_additive (attr := simp)]\ntheorem mem_srange {f : M \u2192\u2099* N} {y : N} : y \u2208 f.srange \u2194 \u2203 x, f x = y", "start": [764, 1], "end": [766, 10], "kind": "commanddeclaration"}, {"full_name": "MulHom.srange_eq_map", "code": "@[to_additive]\ntheorem srange_eq_map (f : M \u2192\u2099* N) : f.srange = (\u22a4 : Subsemigroup M).map f", "start": [770, 1], "end": [772, 12], "kind": "commanddeclaration"}, {"full_name": "MulHom.map_srange", "code": "@[to_additive]\ntheorem map_srange (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) : f.srange.map g = (g.comp f).srange", "start": [776, 1], "end": [778, 68], "kind": "commanddeclaration"}, {"full_name": "MulHom.srange_top_iff_surjective", "code": "@[to_additive]\ntheorem srange_top_iff_surjective {N} [Mul N] {f : M \u2192\u2099* N} :\n    f.srange = (\u22a4 : Subsemigroup N) \u2194 Function.Surjective f", "start": [782, 1], "end": [785, 93], "kind": "commanddeclaration"}, {"full_name": "MulHom.srange_top_of_surjective", "code": "@[to_additive (attr := simp)\n  \"The range of a surjective `AddSemigroup` hom is the whole of the codomain.\"]\ntheorem srange_top_of_surjective {N} [Mul N] (f : M \u2192\u2099* N) (hf : Function.Surjective f) :\n    f.srange = (\u22a4 : Subsemigroup N)", "start": [789, 1], "end": [794, 33], "kind": "commanddeclaration"}, {"full_name": "MulHom.mclosure_preimage_le", "code": "@[to_additive]\ntheorem mclosure_preimage_le (f : M \u2192\u2099* N) (s : Set N) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [798, 1], "end": [800, 81], "kind": "commanddeclaration"}, {"full_name": "MulHom.map_mclosure", "code": "@[to_additive\n      \"The image under an `AddSemigroup` hom of the `AddSubsemigroup` generated by a set\n      equals the `AddSubsemigroup` generated by the image of the set.\"]\ntheorem map_mclosure (f : M \u2192\u2099* N) (s : Set M) : (closure s).map f = closure (f '' s)", "start": [804, 1], "end": [813, 56], "kind": "commanddeclaration"}, {"full_name": "MulHom.restrict", "code": "@[to_additive \"Restriction of an AddSemigroup hom to an `AddSubsemigroup` of the domain.\"]\ndef restrict {N : Type*} [Mul N] [SetLike \u03c3 M] [MulMemClass \u03c3 M] (f : M \u2192\u2099* N) (S : \u03c3) : S \u2192\u2099* N :=\n  f.comp (MulMemClass.subtype S)", "start": [817, 1], "end": [820, 33], "kind": "commanddeclaration"}, {"full_name": "MulHom.restrict_apply", "code": "@[to_additive (attr := simp)]\ntheorem restrict_apply {N : Type*} [Mul N] [SetLike \u03c3 M] [MulMemClass \u03c3 M] (f : M \u2192\u2099* N) {S : \u03c3}\n    (x : S) : f.restrict S x = f x", "start": [824, 1], "end": [827, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.codRestrict", "code": "@[to_additive (attr := simps)\n  \"Restriction of an `AddSemigroup` hom to an `AddSubsemigroup` of the codomain.\"]\ndef codRestrict [SetLike \u03c3 N] [MulMemClass \u03c3 N] (f : M \u2192\u2099* N) (S : \u03c3) (h : \u2200 x, f x \u2208 S) :\n    M \u2192\u2099* S where\n  toFun n := \u27e8f n, h n\u27e9\n  map_mul' x y := Subtype.eq (map_mul f x y)", "start": [831, 1], "end": [837, 45], "kind": "commanddeclaration"}, {"full_name": "MulHom.srangeRestrict", "code": "@[to_additive \"Restriction of an `AddSemigroup` hom to its range interpreted as a subsemigroup.\"]\ndef srangeRestrict {N} [Mul N] (f : M \u2192\u2099* N) : M \u2192\u2099* f.srange :=\n  (f.codRestrict f.srange) fun x => \u27e8x, rfl\u27e9", "start": [843, 1], "end": [846, 45], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_srangeRestrict", "code": "@[to_additive (attr := simp)]\ntheorem coe_srangeRestrict {N} [Mul N] (f : M \u2192\u2099* N) (x : M) : (f.srangeRestrict x : N) = f x", "start": [850, 1], "end": [852, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.srangeRestrict_surjective", "code": "@[to_additive]\ntheorem srangeRestrict_surjective (f : M \u2192\u2099* N) : Function.Surjective f.srangeRestrict", "start": [856, 1], "end": [858, 32], "kind": "commanddeclaration"}, {"full_name": "MulHom.prod_map_comap_prod'", "code": "@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [Mul M'] [Mul N'] (f : M \u2192\u2099* N)\n    (g : M' \u2192\u2099* N') (S : Subsemigroup N) (S' : Subsemigroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g)", "start": [862, 1], "end": [866, 62], "kind": "commanddeclaration"}, {"full_name": "MulHom.subsemigroupComap", "code": "@[to_additive (attr := simps)\n  \"The `AddHom` from the preimage of an additive subsemigroup to itself.\"]\ndef subsemigroupComap (f : M \u2192\u2099* N) (N' : Subsemigroup N) :\n    N'.comap f \u2192\u2099* N' where\n  toFun x := \u27e8f x, x.prop\u27e9\n  map_mul' x y := Subtype.eq (@map_mul M N _ _ _ _ f x y)", "start": [870, 1], "end": [876, 58], "kind": "commanddeclaration"}, {"full_name": "MulHom.subsemigroupMap", "code": "@[to_additive (attr := simps)\n      \"the `AddHom` from an additive subsemigroup to its image. See\n      `AddEquiv.addSubsemigroupMap` for a variant for `AddEquiv`s.\"]\ndef subsemigroupMap (f : M \u2192\u2099* N) (M' : Subsemigroup M) :\n    M' \u2192\u2099* M'.map f where\n  toFun x := \u27e8f x, \u27e8x, x.prop, rfl\u27e9\u27e9\n  map_mul' x y := Subtype.eq <| @map_mul M N _ _ _ _ f x y", "start": [882, 1], "end": [890, 59], "kind": "commanddeclaration"}, {"full_name": "MulHom.subsemigroupMap_surjective", "code": "@[to_additive]\ntheorem subsemigroupMap_surjective (f : M \u2192\u2099* N) (M' : Subsemigroup M) :\n    Function.Surjective (f.subsemigroupMap M')", "start": [896, 1], "end": [900, 23], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.srange_fst", "code": "@[to_additive (attr := simp)]\ntheorem srange_fst [Nonempty N] : (fst M N).srange = \u22a4", "start": [912, 1], "end": [914, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.srange_snd", "code": "@[to_additive (attr := simp)]\ntheorem srange_snd [Nonempty M] : (snd M N).srange = \u22a4", "start": [918, 1], "end": [920, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.prod_eq_top_iff", "code": "@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff [Nonempty M] [Nonempty N] {s : Subsemigroup M} {t : Subsemigroup N} :\n    s.prod t = \u22a4 \u2194 s = \u22a4 \u2227 t = \u22a4", "start": [924, 1], "end": [928, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.inclusion", "code": "@[to_additive \"The `AddSemigroup` hom associated to an inclusion of subsemigroups.\"]\ndef inclusion {S T : Subsemigroup M} (h : S \u2264 T) : S \u2192\u2099* T :=\n  (MulMemClass.subtype S).codRestrict _ fun x => h x.2", "start": [932, 1], "end": [935, 55], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.range_subtype", "code": "@[to_additive (attr := simp)]\ntheorem range_subtype (s : Subsemigroup M) : (MulMemClass.subtype s).srange = s", "start": [939, 1], "end": [941, 69], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.eq_top_iff'", "code": "@[to_additive]\ntheorem eq_top_iff' : S = \u22a4 \u2194 \u2200 x : M, x \u2208 S", "start": [945, 1], "end": [947, 65], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.subsemigroupCongr", "code": "@[to_additive\n      \"Makes the identity additive isomorphism from a proof two\n      subsemigroups of an additive semigroup are equal.\"]\ndef subsemigroupCongr (h : S = T) : S \u2243* T :=\n  { Equiv.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }", "start": [957, 1], "end": [963, 70], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ofLeftInverse", "code": "@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive semigroup homomorphism `f : M \u2192+ N` with a left-inverse\n      `g : N \u2192 M` defines an additive equivalence between `M` and `f.srange`.\n      This is a bidirectional version of `AddHom.srangeRestrict`. \"]\ndef ofLeftInverse (f : M \u2192\u2099* N) {g : N \u2192 M} (h : Function.LeftInverse g f) : M \u2243* f.srange :=\n  { f.srangeRestrict with\n    toFun := f.srangeRestrict\n    invFun := g \u2218 MulMemClass.subtype f.srange\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := MulHom.mem_srange.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [968, 1], "end": [984, 47], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.subsemigroupMap", "code": "@[to_additive (attr := simps)\n      \"An `AddEquiv` `\u03c6` between two additive semigroups `M` and `N` induces an `AddEquiv`\n      between a subsemigroup `S \u2264 M` and the subsemigroup `\u03c6(S) \u2264 N`.\n      See `AddHom.addSubsemigroupMap` for a variant for `AddHom`s.\"]\ndef subsemigroupMap (e : M \u2243* N) (S : Subsemigroup M) : S \u2243* S.map (e : M \u2192\u2099* N) :=\n  { (e : M \u2192\u2099* N).subsemigroupMap S,\n    (e : M \u2243 N).image S with\n    toFun := fun x => \u27e8e x, _\u27e9\n    invFun := fun x => \u27e8e.symm x, _\u27e9 }", "start": [992, 1], "end": [1004, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Basic.lean", "imports": ["Mathlib/GroupTheory/Subsemigroup/Basic.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OneMemClass", "code": "class OneMemClass (S : Type*) (M : Type*) [One M] [SetLike S M] : Prop where\n  \n  one_mem : \u2200 s : S, (1 : M) \u2208 s", "start": [70, 1], "end": [73, 33], "kind": "commanddeclaration"}, {"full_name": "ZeroMemClass", "code": "class ZeroMemClass (S : Type*) (M : Type*) [Zero M] [SetLike S M] : Prop where\n  \n  zero_mem : \u2200 s : S, (0 : M) \u2208 s", "start": [78, 1], "end": [81, 34], "kind": "commanddeclaration"}, {"full_name": "Submonoid", "code": "structure Submonoid (M : Type*) [MulOneClass M] extends Subsemigroup M where\n  \n  one_mem' : (1 : M) \u2208 carrier", "start": [92, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass", "code": "class SubmonoidClass (S : Type*) (M : Type*) [MulOneClass M] [SetLike S M] extends\n  MulMemClass S M, OneMemClass S M : Prop", "start": [104, 1], "end": [107, 42], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid", "code": "structure AddSubmonoid (M : Type*) [AddZeroClass M] extends AddSubsemigroup M where\n  \n  zero_mem' : (0 : M) \u2208 carrier", "start": [112, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoidClass", "code": "class AddSubmonoidClass (S : Type*) (M : Type*) [AddZeroClass M] [SetLike S M] extends\n  AddMemClass S M, ZeroMemClass S M : Prop", "start": [126, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "pow_mem", "code": "@[to_additive (attr := aesop safe apply (rule_sets [SetLike]))]\ntheorem pow_mem {M A} [Monoid M] [SetLike A M] [SubmonoidClass A M] {S : A} {x : M}\n    (hx : x \u2208 S) : \u2200 n : \u2115, x ^ n \u2208 S", "start": [134, 1], "end": [142, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_toSubsemigroup", "code": "@[to_additive (attr := simp)]\ntheorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x \u2208 s.toSubsemigroup \u2194 x \u2208 s", "start": [162, 1], "end": [164, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_carrier", "code": "@[to_additive]\ntheorem mem_carrier {s : Submonoid M} {x : M} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [170, 1], "end": [172, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_mk", "code": "@[to_additive (attr := simp)]\ntheorem mem_mk {s : Subsemigroup M} {x : M} (h_one) : x \u2208 mk s h_one \u2194 x \u2208 s", "start": [176, 1], "end": [178, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_set_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_set_mk {s : Subsemigroup M} (h_one) : (mk s h_one : Set M) = s", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mk_le_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Subsemigroup M} (h_one) (h_one') : mk s h_one \u2264 mk t h_one' \u2194 s \u2264 t", "start": [188, 1], "end": [190, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.ext", "code": "@[to_additive (attr := ext) \"Two `AddSubmonoid`s are equal if they have the same elements.\"]\ntheorem ext {S T : Submonoid M} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [194, 1], "end": [197, 16], "kind": "commanddeclaration"}, {"full_name": "Submonoid.copy", "code": "@[to_additive \"Copy an additive submonoid replacing `carrier` with a set that is equal to it.\"]\nprotected def copy (S : Submonoid M) (s : Set M) (hs : s = S) : Submonoid M where\n  carrier := s\n  one_mem' := show 1 \u2208 s from hs.symm \u25b8 S.one_mem'\n  mul_mem' := hs.symm \u25b8 S.mul_mem'", "start": [201, 1], "end": [206, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem coe_copy {s : Set M} (hs : s = S) : (S.copy s hs : Set M) = s", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.copy_eq", "code": "@[to_additive]\ntheorem copy_eq {s : Set M} (hs : s = S) : S.copy s hs = S", "start": [218, 1], "end": [220, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.one_mem", "code": "@[to_additive \"An `AddSubmonoid` contains the monoid's 0.\"]\nprotected theorem one_mem : (1 : M) \u2208 S", "start": [226, 1], "end": [229, 12], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mul_mem", "code": "@[to_additive \"An `AddSubmonoid` is closed under addition.\"]\nprotected theorem mul_mem {x y : M} : x \u2208 S \u2192 y \u2208 S \u2192 x * y \u2208 S", "start": [233, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_bot", "code": "@[to_additive (attr := simp)]\ntheorem mem_bot {x : M} : x \u2208 (\u22a5 : Submonoid M) \u2194 x = 1", "start": [260, 1], "end": [262, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_top", "code": "@[to_additive (attr := simp)]\ntheorem mem_top (x : M) : x \u2208 (\u22a4 : Submonoid M)", "start": [266, 1], "end": [268, 17], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_top", "code": "@[to_additive (attr := simp)]\ntheorem coe_top : ((\u22a4 : Submonoid M) : Set M) = Set.univ", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_bot", "code": "@[to_additive (attr := simp)]\ntheorem coe_bot : ((\u22a5 : Submonoid M) : Set M) = {1}", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_inf", "code": "@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Submonoid M) : ((p \u2293 p' : Submonoid M) : Set M) = (p : Set M) \u2229 p'", "start": [292, 1], "end": [294, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_inf", "code": "@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Submonoid M} {x : M} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [298, 1], "end": [300, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_sInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (S : Set (Submonoid M)) : ((sInf S : Submonoid M) : Set M) = \u22c2 s \u2208 S, \u2191s", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sInf", "code": "@[to_additive]\ntheorem mem_sInf {S : Set (Submonoid M)} {x : M} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [319, 1], "end": [321, 18], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_iInf", "code": "@[to_additive]\ntheorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Submonoid M} {x : M} : (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [325, 1], "end": [327, 51], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_iInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Submonoid M} : (\u2191(\u2a05 i, S i) : Set M) = \u22c2 i, S i", "start": [331, 1], "end": [333, 48], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subsingleton_iff", "code": "@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Submonoid M) \u2194 Subsingleton M", "start": [356, 1], "end": [364, 93], "kind": "commanddeclaration"}, {"full_name": "Submonoid.nontrivial_iff", "code": "@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Submonoid M) \u2194 Nontrivial M", "start": [368, 1], "end": [372, 44], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure", "code": "@[to_additive \"The `add_submonoid` generated by a set\"]\ndef closure (s : Set M) : Submonoid M :=\n  sInf { S | s \u2286 S }", "start": [384, 1], "end": [387, 21], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_closure", "code": "@[to_additive]\ntheorem mem_closure {x : M} : x \u2208 closure s \u2194 \u2200 S : Submonoid M, s \u2286 S \u2192 x \u2208 S", "start": [391, 1], "end": [393, 11], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subset_closure", "code": "@[to_additive (attr := simp, aesop safe 20 apply (rule_sets [SetLike]))\n  \"The `AddSubmonoid` generated by a set includes the set.\"]\ntheorem subset_closure : s \u2286 closure s", "start": [397, 1], "end": [400, 86], "kind": "commanddeclaration"}, {"full_name": "Submonoid.not_mem_of_not_mem_closure", "code": "@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : M} (hP : P \u2209 closure s) : P \u2209 s", "start": [404, 1], "end": [406, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_le", "code": "@[to_additive (attr := simp)\n\"An additive submonoid `S` includes `closure s` if and only if it includes `s`\"]\ntheorem closure_le : closure s \u2264 S \u2194 s \u2286 S", "start": [414, 1], "end": [418, 52], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_mono", "code": "@[to_additive\n      \"Additive submonoid closure of a set is monotone in its argument: if `s \u2286 t`,\n      then `closure s \u2264 closure t`\"]\ntheorem closure_mono \u2983s t : Set M\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [422, 1], "end": [428, 48], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_eq_of_le", "code": "@[to_additive]\ntheorem closure_eq_of_le (h\u2081 : s \u2286 S) (h\u2082 : S \u2264 closure s) : closure s = S", "start": [432, 1], "end": [434, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_induction", "code": "@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p` holds for `0` and all\n      elements of `s`, and is preserved under addition, then `p` holds for all elements of the\n      additive closure of `s`.\"]\ntheorem closure_induction {p : M \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x) (H1 : p 1)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [440, 1], "end": [448, 49], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_induction'", "code": "@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubmonoid.closure_induction`. \"]\ntheorem closure_induction' (s : Set M) {p : \u2200 x, x \u2208 closure s \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 s), p x (subset_closure h)) (H1 : p 1 (one_mem _))\n    (Hmul : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x * y) (mul_mem hx hy)) {x} (hx : x \u2208 closure s) :\n    p x hx", "start": [452, 1], "end": [461, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_induction\u2082", "code": "@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership for predicates with two arguments.\"]\ntheorem closure_induction\u2082 {p : M \u2192 M \u2192 Prop} {x} {y : M} (hx : x \u2208 closure s) (hy : y \u2208 closure s)\n    (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (H1_left : \u2200 x, p 1 x) (H1_right : \u2200 x, p x 1)\n    (Hmul_left : \u2200 x y z, p x z \u2192 p y z \u2192 p (x * y) z)\n    (Hmul_right : \u2200 x y z, p z x \u2192 p z y \u2192 p z (x * y)) : p x y", "start": [465, 1], "end": [475, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.dense_induction", "code": "@[to_additive (attr := elab_as_elim)\n      \"If `s` is a dense set in an additive monoid `M`, `AddSubmonoid.closure s = \u22a4`, then in\n      order to prove that some predicate `p` holds for all `x : M` it suffices to verify `p x` for\n      `x \u2208 s`, verify `p 0`, and verify that `p x` and `p y` imply `p (x + y)`.\"]\ntheorem dense_induction {p : M \u2192 Prop} (x : M) {s : Set M} (hs : closure s = \u22a4) (Hs : \u2200 x \u2208 s, p x)\n    (H1 : p 1) (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [479, 1], "end": [489, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.gi", "code": "@[to_additive \"`closure` forms a Galois insertion with the coercion to set.\"]\nprotected def gi : GaloisInsertion (@closure M _) SetLike.coe where\n  choice s _ := closure s\n  gc _ _ := closure_le\n  le_l_u _ := subset_closure\n  choice_eq _ _ := rfl", "start": [495, 1], "end": [501, 23], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_eq", "code": "@[to_additive (attr := simp) \"Additive closure of an additive submonoid `S` equals `S`\"]\ntheorem closure_eq : closure (S : Set M) = S", "start": [507, 1], "end": [510, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_empty", "code": "@[to_additive (attr := simp)]\ntheorem closure_empty : closure (\u2205 : Set M) = \u22a5", "start": [514, 1], "end": [516, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_univ", "code": "@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set M) = \u22a4", "start": [520, 1], "end": [522, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_union", "code": "@[to_additive]\ntheorem closure_union (s t : Set M) : closure (s \u222a t) = closure s \u2294 closure t", "start": [526, 1], "end": [528, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.sup_eq_closure", "code": "@[to_additive]\ntheorem sup_eq_closure (N N' : Submonoid M) : N \u2294 N' = closure ((N : Set M) \u222a (N' : Set M))", "start": [532, 1], "end": [534, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_iUnion", "code": "@[to_additive]\ntheorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set M) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [536, 1], "end": [538, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_singleton_le_iff_mem", "code": "@[to_additive]\ntheorem closure_singleton_le_iff_mem (m : M) (p : Submonoid M) : closure {m} \u2264 p \u2194 m \u2208 p", "start": [543, 1], "end": [545, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_iSup", "code": "@[to_additive]\ntheorem mem_iSup {\u03b9 : Sort*} (p : \u03b9 \u2192 Submonoid M) {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2200 N, (\u2200 i, p i \u2264 N) \u2192 m \u2208 N", "start": [549, 1], "end": [553, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.iSup_eq_closure", "code": "@[to_additive]\ntheorem iSup_eq_closure {\u03b9 : Sort*} (p : \u03b9 \u2192 Submonoid M) :\n    \u2a06 i, p i = Submonoid.closure (\u22c3 i, (p i : Set M))", "start": [557, 1], "end": [560, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.disjoint_def", "code": "@[to_additive]\ntheorem disjoint_def {p\u2081 p\u2082 : Submonoid M} : Disjoint p\u2081 p\u2082 \u2194 \u2200 {x : M}, x \u2208 p\u2081 \u2192 x \u2208 p\u2082 \u2192 x = 1", "start": [564, 1], "end": [566, 78], "kind": "commanddeclaration"}, {"full_name": "Submonoid.disjoint_def'", "code": "@[to_additive]\ntheorem disjoint_def' {p\u2081 p\u2082 : Submonoid M} :\n    Disjoint p\u2081 p\u2082 \u2194 \u2200 {x y : M}, x \u2208 p\u2081 \u2192 y \u2208 p\u2082 \u2192 x = y \u2192 x = 1", "start": [570, 1], "end": [573, 100], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqLocusM", "code": "@[to_additive \"The additive submonoid of elements `x : M` such that `f x = g x`\"]\ndef eqLocusM (f g : M \u2192* N) : Submonoid M where\n  carrier := { x | f x = g x }\n  one_mem' := by rw [Set.mem_setOf_eq, f.map_one, g.map_one]\n  mul_mem' (hx : _ = _) (hy : _ = _) := by simp [*]", "start": [585, 1], "end": [590, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqLocusM_same", "code": "@[to_additive (attr := simp)]\ntheorem eqLocusM_same (f : M \u2192* N) : f.eqLocusM f = \u22a4", "start": [594, 1], "end": [596, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqOn_closureM", "code": "@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its submonoid\n      closure.\"]\ntheorem eqOn_closureM {f g : M \u2192* N} {s : Set M} (h : Set.EqOn f g s) : Set.EqOn f g (closure s)", "start": [600, 1], "end": [605, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_of_eqOn_topM", "code": "@[to_additive]\ntheorem eq_of_eqOn_topM {f g : M \u2192* N} (h : Set.EqOn f g (\u22a4 : Submonoid M)) : f = g", "start": [609, 1], "end": [611, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_of_eqOn_denseM", "code": "@[to_additive]\ntheorem eq_of_eqOn_denseM {s : Set M} (hs : closure s = \u22a4) {f g : M \u2192* N} (h : s.EqOn f g) :\n    f = g", "start": [615, 1], "end": [618, 42], "kind": "commanddeclaration"}, {"full_name": "IsUnit.submonoid", "code": "@[to_additive \"The additive submonoid consisting of the additive units of an additive monoid\"]\ndef IsUnit.submonoid (M : Type*) [Monoid M] : Submonoid M where\n  carrier := setOf IsUnit\n  one_mem' := by simp only [isUnit_one, Set.mem_setOf_eq]\n  mul_mem' := by\n    intro a b ha hb\n    rw [Set.mem_setOf_eq] at *\n    exact IsUnit.mul ha hb", "start": [632, 1], "end": [640, 27], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mem_submonoid_iff", "code": "@[to_additive]\ntheorem IsUnit.mem_submonoid_iff {M : Type*} [Monoid M] (a : M) :\n    a \u2208 IsUnit.submonoid M \u2194 IsUnit a", "start": [644, 1], "end": [648, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofClosureMEqTopLeft", "code": "@[to_additive\n      \"Let `s` be a subset of an additive monoid `M` such that the closure of `s` is\n      the whole monoid. Then `AddMonoidHom.ofClosureEqTopLeft` defines an additive monoid\n      homomorphism from `M` asking for a proof of `f (x + y) = f x + f y` only for `x \u2208 s`. \"]\ndef ofClosureMEqTopLeft {M N} [Monoid M] [Monoid N] {s : Set M} (f : M \u2192 N) (hs : closure s = \u22a4)\n    (h1 : f 1 = 1) (hmul : \u2200 x \u2208 s, \u2200 (y), f (x * y) = f x * f y) :\n    M \u2192* N where\n  toFun := f\n  map_one' := h1\n  map_mul' x :=\n    (dense_induction (p := _) x hs hmul fun y => by rw [one_mul, h1, one_mul]) fun a b ha hb y => by\n      rw [mul_assoc, ha, ha, hb, mul_assoc]", "start": [658, 1], "end": [672, 44], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_ofClosureMEqTopLeft", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopLeft (f : M \u2192 N) (hs : closure s = \u22a4) (h1 hmul) :\n    \u21d1(ofClosureMEqTopLeft f hs h1 hmul) = f", "start": [676, 1], "end": [679, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofClosureMEqTopRight", "code": "@[to_additive\n      \"Let `s` be a subset of an additive monoid `M` such that the closure of `s` is\n      the whole monoid. Then `AddMonoidHom.ofClosureEqTopRight` defines an additive monoid\n      homomorphism from `M` asking for a proof of `f (x + y) = f x + f y` only for `y \u2208 s`. \"]\ndef ofClosureMEqTopRight {M N} [Monoid M] [Monoid N] {s : Set M} (f : M \u2192 N) (hs : closure s = \u22a4)\n    (h1 : f 1 = 1) (hmul : \u2200 (x), \u2200 y \u2208 s, f (x * y) = f x * f y) :\n    M \u2192* N where\n  toFun := f\n  map_one' := h1\n  map_mul' x y :=\n    dense_induction y hs (fun y hy x => hmul x y hy) (by simp [h1])\n      (fun y\u2081 y\u2082 (h\u2081 : \u2200 x, f _ = f _ * f _) (h\u2082 : \u2200 x, f _ = f _ * f _) x => by\n        simp [\u2190 mul_assoc, h\u2081, h\u2082]) x", "start": [683, 1], "end": [698, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_ofClosureMEqTopRight", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_ofClosureMEqTopRight (f : M \u2192 N) (hs : closure s = \u22a4) (h1 hmul) :\n    \u21d1(ofClosureMEqTopRight f hs h1 hmul) = f", "start": [702, 1], "end": [705, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Cancel/Basic.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Basic.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.orderedCancelCommMonoid", "code": "@[to_additive (attr := reducible) Function.Injective.orderedCancelAddCommMonoid\n    \"Pullback an `OrderedCancelAddCommMonoid` under an injective map.\"]\ndef Function.Injective.orderedCancelCommMonoid {\u03b2 : Type*} [One \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115] (f : \u03b2 \u2192 \u03b1)\n    (hf : Function.Injective f) (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : OrderedCancelCommMonoid \u03b2 :=\n  { hf.orderedCommMonoid f one mul npow with\n    le_of_mul_le_mul_left := fun a b c (bc : f (a * b) \u2264 f (a * c)) \u21a6\n      (mul_le_mul_iff_left (f a)).mp (by rwa [\u2190 mul, \u2190 mul]) }", "start": [28, 1], "end": [37, 63], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCancelCommMonoid", "code": "@[to_additive (attr := reducible) Function.Injective.linearOrderedCancelAddCommMonoid\n    \"Pullback a `LinearOrderedCancelAddCommMonoid` under an injective map.\"]\ndef Function.Injective.linearOrderedCancelCommMonoid {\u03b2 : Type*} [One \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115]\n    [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Function.Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedCancelCommMonoid \u03b2 :=\n  { hf.linearOrderedCommMonoid f one mul npow hsup hinf,\n    hf.orderedCancelCommMonoid f one mul npow with }", "start": [47, 1], "end": [57, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/IsField.lean", "imports": ["Mathlib/Algebra/Field/Defs.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsField", "code": "structure IsField (R : Type u) [Semiring R] : Prop where\n  \n  exists_pair_ne : \u2203 x y : R, x \u2260 y\n  \n  mul_comm : \u2200 x y : R, x * y = y * x\n  \n  mul_inv_cancel : \u2200 {a : R}, a \u2260 0 \u2192 \u2203 b, a * b = 1", "start": [25, 1], "end": [37, 53], "kind": "commanddeclaration"}, {"full_name": "Semifield.toIsField", "code": "theorem Semifield.toIsField (R : Type u) [Semifield R] : IsField R", "start": [40, 1], "end": [43, 64], "kind": "commanddeclaration"}, {"full_name": "Field.toIsField", "code": "theorem Field.toIsField (R : Type u) [Field R] : IsField R", "start": [46, 1], "end": [48, 24], "kind": "commanddeclaration"}, {"full_name": "IsField.nontrivial", "code": "@[simp]\ntheorem IsField.nontrivial {R : Type u} [Semiring R] (h : IsField R) : Nontrivial R", "start": [51, 1], "end": [53, 21], "kind": "commanddeclaration"}, {"full_name": "not_isField_of_subsingleton", "code": "@[simp]\ntheorem not_isField_of_subsingleton (R : Type u) [Semiring R] [Subsingleton R] : \u00acIsField R", "start": [56, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "IsField.toSemifield", "code": "noncomputable def IsField.toSemifield {R : Type u} [Semiring R] (h : IsField R) : Semifield R :=\n  { \u2039Semiring R\u203a, h with\n    inv := fun a => if ha : a = 0 then 0 else Classical.choose (IsField.mul_inv_cancel h ha),\n    inv_zero := dif_pos rfl,\n    mul_inv_cancel := fun a ha => by\n      convert Classical.choose_spec (IsField.mul_inv_cancel h ha)\n      exact dif_neg ha }", "start": [65, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "IsField.toField", "code": "noncomputable def IsField.toField {R : Type u} [Ring R] (h : IsField R) : Field R :=\n  { \u2039Ring R\u203a, IsField.toSemifield h with }", "start": [75, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "uniq_inv_of_isField", "code": "theorem uniq_inv_of_isField (R : Type u) [Ring R] (hf : IsField R) :\n    \u2200 x : R, x \u2260 0 \u2192 \u2203! y : R, x * y = 1", "start": [80, 1], "end": [93, 36], "kind": "commanddeclaration"}]}
