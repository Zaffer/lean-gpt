{"path": "Mathlib/Tactic/SimpRw.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.withSimpRWRulesSeq", "code": "def withSimpRWRulesSeq (token : Syntax) (rwRulesSeqStx : Syntax)\n    (x : (symm : Bool) \u2192 (term : Syntax) \u2192 TacticM Unit) : TacticM Unit := do\n  let lbrak := rwRulesSeqStx[0]\n  let rules := rwRulesSeqStx[1].getArgs\n  withTacticInfoContext (mkNullNode #[token, lbrak]) (pure ())\n  let numRules := (rules.size + 1) / 2\n  for i in [:numRules] do\n    let rule := rules[i * 2]!\n    let sep  := rules.getD (i * 2 + 1) Syntax.missing\n    withTacticInfoContext (mkNullNode #[rule, sep]) do\n      withRef rule do\n        let symm := !rule[0].isNone\n        let term := rule[1]\n        x symm term", "start": [13, 1], "end": [32, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Conv.lean", "imports": ["lake-packages/std/Std/Lean/Parser.lean", "Mathlib/Tactic/RunCmd.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Conv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Conv.elabDischargeConv", "code": "@[tactic dischargeConv] def elabDischargeConv : Tactic := fun\n  | `(conv| discharge $[=> $tac]?) => do\n    let g :: gs \u2190 getGoals | throwNoGoalsToBeSolved\n    let (theLhs, theRhs) \u2190 Conv.getLhsRhsCore g\n    let .true \u2190 isProp theLhs | throwError \"target is not a proposition\"\n    theRhs.mvarId!.assign (mkConst ``True)\n    let m \u2190 mkFreshExprMVar theLhs\n    g.assign (\u2190 mkEqTrue m)\n    if let some tac := tac then\n      setGoals [m.mvarId!]\n      evalTactic tac; done\n      setGoals gs\n    else\n      setGoals (m.mvarId! :: gs)\n  | _ => Elab.throwUnsupportedSyntax", "start": [52, 1], "end": [67, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Substs.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/FunLike/Equiv.lean", "imports": ["Mathlib/Data/FunLike/Embedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EquivLike", "code": "class EquivLike (E : Sort*) (\u03b1 \u03b2 : outParam (Sort*)) where\n  \n  coe : E \u2192 \u03b1 \u2192 \u03b2\n  \n  inv : E \u2192 \u03b2 \u2192 \u03b1\n  \n  left_inv : \u2200 e, Function.LeftInverse (inv e) (coe e)\n  \n  right_inv : \u2200 e, Function.RightInverse (inv e) (coe e)\n  \n  coe_injective' : \u2200 e g, coe e = coe g \u2192 inv e = inv g \u2192 e = g", "start": [127, 1], "end": [143, 64], "kind": "commanddeclaration"}, {"full_name": "EquivLike.inv_injective", "code": "theorem inv_injective : Function.Injective (EquivLike.inv : E \u2192 \u03b2 \u2192 \u03b1)", "start": [152, 1], "end": [153, 77], "kind": "commanddeclaration"}, {"full_name": "EquivLike.toEmbeddingLike", "code": "instance (priority := 100) toEmbeddingLike : EmbeddingLike E \u03b1 \u03b2 where\n  coe := (coe : E \u2192 \u03b1 \u2192 \u03b2)\n  coe_injective' e g h :=\n    coe_injective' e g h ((left_inv e).eq_rightInverse (h.symm \u25b8 right_inv g))\n  injective' e := (left_inv e).injective", "start": [156, 1], "end": [160, 41], "kind": "commanddeclaration"}, {"full_name": "EquivLike.injective", "code": "protected theorem injective (e : E) : Function.Injective e", "start": [162, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "EquivLike.surjective", "code": "protected theorem surjective (e : E) : Function.Surjective e", "start": [166, 1], "end": [167, 27], "kind": "commanddeclaration"}, {"full_name": "EquivLike.bijective", "code": "protected theorem bijective (e : E) : Function.Bijective (e : \u03b1 \u2192 \u03b2)", "start": [170, 1], "end": [171, 50], "kind": "commanddeclaration"}, {"full_name": "EquivLike.apply_eq_iff_eq", "code": "theorem apply_eq_iff_eq (f : E) {x y : \u03b1} : f x = f y \u2194 x = y", "start": [174, 1], "end": [175, 34], "kind": "commanddeclaration"}, {"full_name": "EquivLike.injective_comp", "code": "@[simp]\ntheorem injective_comp (e : E) (f : \u03b2 \u2192 \u03b3) : Function.Injective (f \u2218 e) \u2194 Function.Injective f", "start": [178, 1], "end": [180, 60], "kind": "commanddeclaration"}, {"full_name": "EquivLike.surjective_comp", "code": "@[simp]\ntheorem surjective_comp (e : E) (f : \u03b2 \u2192 \u03b3) : Function.Surjective (f \u2218 e) \u2194 Function.Surjective f", "start": [183, 1], "end": [185, 41], "kind": "commanddeclaration"}, {"full_name": "EquivLike.bijective_comp", "code": "@[simp]\ntheorem bijective_comp (e : E) (f : \u03b2 \u2192 \u03b3) : Function.Bijective (f \u2218 e) \u2194 Function.Bijective f", "start": [188, 1], "end": [190, 40], "kind": "commanddeclaration"}, {"full_name": "EquivLike.inv_apply_apply", "code": "@[simp]\ntheorem inv_apply_apply (e : E) (a : \u03b1) : EquivLike.inv e (e a) = a", "start": [193, 1], "end": [201, 15], "kind": "commanddeclaration"}, {"full_name": "EquivLike.apply_inv_apply", "code": "@[simp]\ntheorem apply_inv_apply (e : E) (b : \u03b2) : e (EquivLike.inv e b) = b", "start": [204, 1], "end": [212, 16], "kind": "commanddeclaration"}, {"full_name": "EquivLike.comp_injective", "code": "theorem comp_injective (f : \u03b1 \u2192 \u03b2) (e : F) : Function.Injective (e \u2218 f) \u2194 Function.Injective f", "start": [215, 1], "end": [216, 35], "kind": "commanddeclaration"}, {"full_name": "EquivLike.comp_surjective", "code": "@[simp]\ntheorem comp_surjective (f : \u03b1 \u2192 \u03b2) (e : F) : Function.Surjective (e \u2218 f) \u2194 Function.Surjective f", "start": [219, 1], "end": [221, 61], "kind": "commanddeclaration"}, {"full_name": "EquivLike.comp_bijective", "code": "@[simp]\ntheorem comp_bijective (f : \u03b1 \u2192 \u03b2) (e : F) : Function.Bijective (e \u2218 f) \u2194 Function.Bijective f", "start": [224, 1], "end": [226, 41], "kind": "commanddeclaration"}, {"full_name": "EquivLike.subsingleton_dom", "code": "lemma subsingleton_dom [Subsingleton \u03b2] : Subsingleton F :=\n  \u27e8fun f g \u21a6 FunLike.ext f g $ fun _ \u21a6 (right_inv f).injective $ Subsingleton.elim _ _\u27e9", "start": [229, 1], "end": [231, 88], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Init/Data/Bool/Lemmas.lean", "imports": ["Mathlib/Init/Data/Bool/Basic.lean", "Mathlib/Tactic/Coe.lean", "Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bool.cond_true", "code": "@[simp] lemma cond_true {\u03b1 : Type u} {a b : \u03b1} : cond true a b = a := rfl", "start": [40, 1], "end": [40, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.cond_false", "code": "@[simp] lemma cond_false {\u03b1 : Type u} {a b : \u03b1} : cond false a b = b := rfl", "start": [43, 1], "end": [43, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.cond_self", "code": "@[simp]\ntheorem cond_self.{u} {\u03b1 : Type u} (b : Bool) (a : \u03b1) : cond b a a = a", "start": [46, 1], "end": [47, 93], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_self", "code": "@[simp]\ntheorem xor_self (b : Bool) : xor b b = false", "start": [50, 1], "end": [51, 69], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_true", "code": "@[simp]\ntheorem xor_true (b : Bool) : xor b true = not b", "start": [54, 1], "end": [55, 72], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_false", "code": "theorem xor_false (b : Bool) : xor b false = b", "start": [58, 1], "end": [58, 70], "kind": "commanddeclaration"}, {"full_name": "Bool.true_xor", "code": "@[simp]\ntheorem true_xor (b : Bool) : xor true b = not b", "start": [61, 1], "end": [62, 72], "kind": "commanddeclaration"}, {"full_name": "Bool.false_xor", "code": "theorem false_xor (b : Bool) : xor false b = b", "start": [65, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "Bool.true_eq_false_eq_False", "code": "theorem true_eq_false_eq_False : \u00actrue = false", "start": [68, 1], "end": [68, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.false_eq_true_eq_False", "code": "theorem false_eq_true_eq_False : \u00acfalse = true", "start": [71, 1], "end": [71, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_eq_not_eq_true", "code": "theorem eq_false_eq_not_eq_true (b : Bool) : (\u00acb = true) = (b = false)", "start": [74, 1], "end": [74, 82], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_true_eq_not_eq_false", "code": "theorem eq_true_eq_not_eq_false (b : Bool) : (\u00acb = false) = (b = true)", "start": [77, 1], "end": [77, 82], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_of_not_eq_true", "code": "theorem eq_false_of_not_eq_true {b : Bool} : \u00acb = true \u2192 b = false", "start": [80, 1], "end": [81, 36], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_true_of_not_eq_false", "code": "theorem eq_true_of_not_eq_false {b : Bool} : \u00acb = false \u2192 b = true", "start": [84, 1], "end": [85, 36], "kind": "commanddeclaration"}, {"full_name": "Bool.and_eq_true_eq_eq_true_and_eq_true", "code": "theorem and_eq_true_eq_eq_true_and_eq_true (a b : Bool) :\n    ((a && b) = true) = (a = true \u2227 b = true)", "start": [88, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.or_eq_true_eq_eq_true_or_eq_true", "code": "theorem or_eq_true_eq_eq_true_or_eq_true (a b : Bool) :\n    ((a || b) = true) = (a = true \u2228 b = true)", "start": [92, 1], "end": [93, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_true_eq_eq_false", "code": "theorem not_eq_true_eq_eq_false (a : Bool) : (not a = true) = (a = false)", "start": [96, 1], "end": [96, 97], "kind": "commanddeclaration"}, {"full_name": "Bool.and_eq_false_eq_eq_false_or_eq_false", "code": "@[simp]\ntheorem and_eq_false_eq_eq_false_or_eq_false (a b : Bool) :\n    ((a && b) = false) = (a = false \u2228 b = false)", "start": [99, 1], "end": [102, 31], "kind": "commanddeclaration"}, {"full_name": "Bool.or_eq_false_eq_eq_false_and_eq_false", "code": "@[simp]\ntheorem or_eq_false_eq_eq_false_and_eq_false (a b : Bool) :\n    ((a || b) = false) = (a = false \u2227 b = false)", "start": [105, 1], "end": [108, 31], "kind": "commanddeclaration"}, {"full_name": "Bool.not_eq_false_eq_eq_true", "code": "theorem not_eq_false_eq_eq_true (a : Bool) : (not a = false) = (a = true)", "start": [111, 1], "end": [111, 97], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_false", "code": "theorem coe_false : \u2191false = False", "start": [114, 1], "end": [114, 46], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_true", "code": "theorem coe_true : \u2191true = True", "start": [117, 1], "end": [117, 43], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_sort_false", "code": "theorem coe_sort_false : (\u21a5false : Prop) = False", "start": [120, 1], "end": [120, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_sort_true", "code": "theorem coe_sort_true : (\u21a5true : Prop) = True", "start": [123, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_iff", "code": "theorem decide_iff (p : Prop) [d : Decidable p] : decide p = true \u2194 p", "start": [126, 1], "end": [126, 81], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_true", "code": "theorem decide_true {p : Prop} [Decidable p] : p \u2192 decide p", "start": [129, 1], "end": [130, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.of_decide_true", "code": "theorem of_decide_true {p : Prop} [Decidable p] : decide p \u2192 p", "start": [134, 1], "end": [135, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.bool_iff_false", "code": "theorem bool_iff_false {b : Bool} : \u00acb \u2194 b = false", "start": [138, 1], "end": [138, 85], "kind": "commanddeclaration"}, {"full_name": "Bool.bool_eq_false", "code": "theorem bool_eq_false {b : Bool} : \u00acb \u2192 b = false", "start": [141, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_false_iff", "code": "theorem decide_false_iff (p : Prop) [Decidable p] : decide p = false \u2194 \u00acp", "start": [145, 1], "end": [146, 55], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_false", "code": "theorem decide_false {p : Prop} [Decidable p] : \u00acp \u2192 decide p = false", "start": [149, 1], "end": [150, 25], "kind": "commanddeclaration"}, {"full_name": "Bool.of_decide_false", "code": "theorem of_decide_false {p : Prop} [Decidable p] : decide p = false \u2192 \u00acp", "start": [153, 1], "end": [154, 25], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_congr", "code": "theorem decide_congr {p q : Prop} [Decidable p] [Decidable q] (h : p \u2194 q) :\n    decide p = decide q", "start": [157, 1], "end": [161, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.or_coe_iff", "code": "theorem or_coe_iff (a b : Bool) : a || b \u2194 a \u2228 b", "start": [164, 1], "end": [164, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.and_coe_iff", "code": "theorem and_coe_iff (a b : Bool) : a && b \u2194 a \u2227 b", "start": [167, 1], "end": [167, 61], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_coe_iff", "code": "@[simp]\ntheorem xor_coe_iff (a b : Bool) : xor a b \u2194 Xor' (a = true) (b = true)", "start": [170, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "Bool.ite_eq_true_distrib", "code": "@[simp]\ntheorem ite_eq_true_distrib (c : Prop) [Decidable c] (a b : Bool) :\n    ((if c then a else b) = true) = if c then a = true else b = true", "start": [175, 1], "end": [177, 99], "kind": "commanddeclaration"}, {"full_name": "Bool.ite_eq_false_distrib", "code": "@[simp]\ntheorem ite_eq_false_distrib (c : Prop) [Decidable c] (a b : Bool) :\n    ((if c then a else b) = false) = if c then a = false else b = false", "start": [180, 1], "end": [183, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Quot.lean", "imports": ["Mathlib/Logic/Relator.lean", "Mathlib/Init/Data/Quot.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Setoid.ext", "code": "theorem ext {\u03b1 : Sort*} : \u2200 {s t : Setoid \u03b1},\n    (\u2200 a b, @Setoid.r \u03b1 s a b \u2194 @Setoid.r \u03b1 t a b) \u2192 s = t", "start": [27, 1], "end": [32, 9], "kind": "commanddeclaration"}, {"full_name": "Quot.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {\u03b1 : Sort u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {\u03b2 : Quot r \u2192 Prop} (q : Quot r)\n    (h : \u2200 a, \u03b2 (Quot.mk r a)) : \u03b2 q", "start": [45, 1], "end": [48, 10], "kind": "commanddeclaration"}, {"full_name": "Quot.Subsingleton", "code": "protected instance Subsingleton [Subsingleton \u03b1] : Subsingleton (Quot ra) :=\n  \u27e8fun x \u21a6 Quot.induction_on x fun _ \u21a6 Quot.ind fun _ \u21a6 congr_arg _ (Subsingleton.elim _ _)\u27e9", "start": [53, 1], "end": [54, 93], "kind": "commanddeclaration"}, {"full_name": "Quot.hrecOn\u2082", "code": "protected def hrecOn\u2082 (qa : Quot ra) (qb : Quot rb) (f : \u2200 a b, \u03c6 \u27e6a\u27e7 \u27e6b\u27e7)\n    (ca : \u2200 {b a\u2081 a\u2082}, ra a\u2081 a\u2082 \u2192 HEq (f a\u2081 b) (f a\u2082 b))\n    (cb : \u2200 {a b\u2081 b\u2082}, rb b\u2081 b\u2082 \u2192 HEq (f a b\u2081) (f a b\u2082)) :\n    \u03c6 qa qb :=\n  Quot.hrecOn (motive := fun qa \u21a6 \u03c6 qa qb) qa\n    (fun a \u21a6 Quot.hrecOn qb (f a) (fun b\u2081 b\u2082 pb \u21a6 cb pb))\n    fun a\u2081 a\u2082 pa \u21a6\n      Quot.induction_on qb fun b \u21a6\n        have h\u2081 : HEq (@Quot.hrecOn _ _ (\u03c6 _) \u27e6b\u27e7 (f a\u2081) (@cb _)) (f a\u2081 b) :=\n          by simp [heq_self_iff_true]\n        have h\u2082 : HEq (f a\u2082 b) (@Quot.hrecOn _ _ (\u03c6 _) \u27e6b\u27e7 (f a\u2082) (@cb _)) :=\n          by simp [heq_self_iff_true]\n        (h\u2081.trans (ca pa)).trans h\u2082", "start": [57, 1], "end": [70, 36], "kind": "commanddeclaration"}, {"full_name": "Quot.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (h : (ra \u21d2 rb) f f) : Quot ra \u2192 Quot rb :=\n  (Quot.lift fun x \u21a6 \u27e6f x\u27e7) fun x y (h\u2081 : ra x y) \u21a6 Quot.sound <| h h\u2081", "start": [73, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "Quot.mapRight", "code": "protected def mapRight {ra' : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : \u2200 a\u2081 a\u2082, ra a\u2081 a\u2082 \u2192 ra' a\u2081 a\u2082) :\n    Quot ra \u2192 Quot ra' :=\n  Quot.map id h", "start": [79, 1], "end": [82, 16], "kind": "commanddeclaration"}, {"full_name": "Quot.factor", "code": "def factor {\u03b1 : Type*} (r s : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 x y, r x y \u2192 s x y) : Quot r \u2192 Quot s :=\n  Quot.lift (Quot.mk s) fun x y rxy \u21a6 Quot.sound (h x y rxy)", "start": [85, 1], "end": [87, 61], "kind": "commanddeclaration"}, {"full_name": "Quot.factor_mk_eq", "code": "theorem factor_mk_eq {\u03b1 : Type*} (r s : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 x y, r x y \u2192 s x y) :\n    factor r s h \u2218 Quot.mk _ = Quot.mk _", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.lift_mk", "code": "theorem lift_mk (f : \u03b1 \u2192 \u03b3) (h : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2192 f a\u2081 = f a\u2082) (a : \u03b1) :\n    Quot.lift f h (Quot.mk r a) = f a", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.liftOn_mk", "code": "theorem liftOn_mk (a : \u03b1) (f : \u03b1 \u2192 \u03b3) (h : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2192 f a\u2081 = f a\u2082) :\n    Quot.liftOn (Quot.mk r a) f h = f a", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.surjective_lift", "code": "@[simp] theorem surjective_lift {f : \u03b1 \u2192 \u03b3} (h : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2192 f a\u2081 = f a\u2082) :\n    Function.Surjective (lift f h) \u2194 Function.Surjective f", "start": [109, 1], "end": [111, 90], "kind": "commanddeclaration"}, {"full_name": "Quot.lift\u2082", "code": "protected def lift\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 f a b\u2081 = f a b\u2082)\n    (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 f a\u2081 b = f a\u2082 b) (q\u2081 : Quot r) (q\u2082 : Quot s) : \u03b3 :=\n  Quot.lift (fun a \u21a6 Quot.lift (f a) (hr a))\n    (fun a\u2081 a\u2082 ha \u21a6 funext fun q \u21a6 Quot.induction_on q fun b \u21a6 hs a\u2081 a\u2082 b ha) q\u2081 q\u2082", "start": [114, 1], "end": [120, 84], "kind": "commanddeclaration"}, {"full_name": "Quot.lift\u2082_mk", "code": "@[simp]\ntheorem lift\u2082_mk (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 f a b\u2081 = f a b\u2082)\n    (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 f a\u2081 b = f a\u2082 b)\n    (a : \u03b1) (b : \u03b2) : Quot.lift\u2082 f hr hs (Quot.mk r a) (Quot.mk s b) = f a b", "start": [123, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.liftOn\u2082", "code": "protected def liftOn\u2082 (p : Quot r) (q : Quot s) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 f a b\u2081 = f a b\u2082) (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 f a\u2081 b = f a\u2082 b) : \u03b3 :=\n  Quot.lift\u2082 f hr hs p q", "start": [130, 1], "end": [135, 25], "kind": "commanddeclaration"}, {"full_name": "Quot.liftOn\u2082_mk", "code": "@[simp]\ntheorem liftOn\u2082_mk (a : \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 f a b\u2081 = f a b\u2082)\n    (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 f a\u2081 b = f a\u2082 b) :\n    Quot.liftOn\u2082 (Quot.mk r a) (Quot.mk s b) f hr hs = f a b", "start": [138, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.map\u2082", "code": "protected def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 t (f a b\u2081) (f a b\u2082))\n    (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 t (f a\u2081 b) (f a\u2082 b)) (q\u2081 : Quot r) (q\u2082 : Quot s) : Quot t :=\n  Quot.lift\u2082 (fun a b \u21a6 Quot.mk t <| f a b) (fun a b\u2081 b\u2082 hb \u21a6 Quot.sound (hr a b\u2081 b\u2082 hb))\n    (fun a\u2081 a\u2082 b ha \u21a6 Quot.sound (hs a\u2081 a\u2082 b ha)) q\u2081 q\u2082", "start": [147, 1], "end": [152, 56], "kind": "commanddeclaration"}, {"full_name": "Quot.map\u2082_mk", "code": "@[simp]\ntheorem map\u2082_mk (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hr : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 t (f a b\u2081) (f a b\u2082))\n    (hs : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 t (f a\u2081 b) (f a\u2082 b)) (a : \u03b1) (b : \u03b2) :\n    Quot.map\u2082 f hr hs (Quot.mk r a) (Quot.mk s b) = Quot.mk t (f a b)", "start": [155, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Quot.recOnSubsingleton\u2082", "code": "@[elab_as_elim]\nprotected def recOnSubsingleton\u2082 {\u03c6 : Quot r \u2192 Quot s \u2192 Sort*}\n    [h : \u2200 a b, Subsingleton (\u03c6 \u27e6a\u27e7 \u27e6b\u27e7)] (q\u2081 : Quot r)\n    (q\u2082 : Quot s) (f : \u2200 a b, \u03c6 \u27e6a\u27e7 \u27e6b\u27e7) : \u03c6 q\u2081 q\u2082 :=\n  @Quot.recOnSubsingleton _ r (fun q \u21a6 \u03c6 q q\u2082)\n    (fun a \u21a6 Quot.ind (\u03b2 := \u03bb b => Subsingleton (\u03c6 (mk r a) b)) (h a) q\u2082) q\u2081\n    fun a \u21a6 Quot.recOnSubsingleton q\u2082 fun b \u21a6 f a b", "start": [162, 1], "end": [170, 52], "kind": "commanddeclaration"}, {"full_name": "Quot.induction_on\u2082", "code": "@[elab_as_elim]\nprotected theorem induction_on\u2082 {\u03b4 : Quot r \u2192 Quot s \u2192 Prop} (q\u2081 : Quot r) (q\u2082 : Quot s)\n    (h : \u2200 a b, \u03b4 (Quot.mk r a) (Quot.mk s b)) : \u03b4 q\u2081 q\u2082", "start": [173, 1], "end": [176, 77], "kind": "commanddeclaration"}, {"full_name": "Quot.induction_on\u2083", "code": "@[elab_as_elim]\nprotected theorem induction_on\u2083 {\u03b4 : Quot r \u2192 Quot s \u2192 Quot t \u2192 Prop} (q\u2081 : Quot r)\n    (q\u2082 : Quot s) (q\u2083 : Quot t) (h : \u2200 a b c, \u03b4 (Quot.mk r a) (Quot.mk s b) (Quot.mk t c)) :\n    \u03b4 q\u2081 q\u2082 q\u2083", "start": [179, 1], "end": [184, 56], "kind": "commanddeclaration"}, {"full_name": "Quot.lift.decidablePred", "code": "instance lift.decidablePred (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : \u03b1 \u2192 Prop) (h : \u2200 a b, r a b \u2192 f a = f b)\n    [hf : DecidablePred f] :\n    DecidablePred (Quot.lift f h) :=\n  fun q \u21a6 Quot.recOnSubsingleton (motive := \u03bb _ => Decidable _) q hf", "start": [187, 1], "end": [190, 69], "kind": "commanddeclaration"}, {"full_name": "Quot.lift\u2082.decidablePred", "code": "instance lift\u2082.decidablePred (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2 \u2192 Prop)\n    (ha : \u2200 a b\u2081 b\u2082, s b\u2081 b\u2082 \u2192 f a b\u2081 = f a b\u2082) (hb : \u2200 a\u2081 a\u2082 b, r a\u2081 a\u2082 \u2192 f a\u2081 b = f a\u2082 b)\n    [hf : \u2200 a, DecidablePred (f a)] (q\u2081 : Quot r) :\n    DecidablePred (Quot.lift\u2082 f ha hb q\u2081) :=\n  fun q\u2082 \u21a6 Quot.recOnSubsingleton\u2082 q\u2081 q\u2082 hf", "start": [192, 1], "end": [197, 44], "kind": "commanddeclaration"}, {"full_name": "Quotient.instInhabitedQuotient", "code": "instance instInhabitedQuotient (s : Setoid \u03b1) [Inhabited \u03b1] : Inhabited (Quotient s) :=\n  \u27e8\u27e6default\u27e7\u27e9", "start": [226, 1], "end": [227, 14], "kind": "commanddeclaration"}, {"full_name": "Quotient.instSubsingletonQuotient", "code": "instance instSubsingletonQuotient (s : Setoid \u03b1) [Subsingleton \u03b1] : Subsingleton (Quotient s) :=\n  Quot.Subsingleton", "start": [229, 1], "end": [230, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn\u2082", "code": "protected def hrecOn\u2082 (qa : Quotient sa) (qb : Quotient sb) (f : \u2200 a b, \u03c6 \u27e6a\u27e7 \u27e6b\u27e7)\n    (c : \u2200 a\u2081 b\u2081 a\u2082 b\u2082, a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 HEq (f a\u2081 b\u2081) (f a\u2082 b\u2082)) : \u03c6 qa qb :=\n  Quot.hrecOn\u2082 qa qb f (fun p \u21a6 c _ _ _ _ p (Setoid.refl _)) fun p \u21a6 c _ _ _ _ (Setoid.refl _) p", "start": [237, 1], "end": [240, 97], "kind": "commanddeclaration"}, {"full_name": "Quotient.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) (h : ((\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7)) f f) : Quotient sa \u2192 Quotient sb :=\n  Quot.map f h", "start": [243, 1], "end": [246, 15], "kind": "commanddeclaration"}, {"full_name": "Quotient.map_mk", "code": "@[simp]\ntheorem map_mk (f : \u03b1 \u2192 \u03b2) (h : ((\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7)) f f) (x : \u03b1) :\n    Quotient.map f h (\u27e6x\u27e7 : Quotient sa) = (\u27e6f x\u27e7 : Quotient sb)", "start": [249, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.map\u2082", "code": "protected def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h : ((\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7)) f f) :\n    Quotient sa \u2192 Quotient sb \u2192 Quotient sc :=\n  Quotient.lift\u2082 (fun x y \u21a6 \u27e6f x y\u27e7) fun _ _ _ _ h\u2081 h\u2082 \u21a6 Quot.sound <| h h\u2081 h\u2082", "start": [257, 1], "end": [262, 79], "kind": "commanddeclaration"}, {"full_name": "Quotient.map\u2082_mk", "code": "@[simp]\ntheorem map\u2082_mk (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h : ((\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7) \u21d2 (\u00b7 \u2248 \u00b7)) f f) (x : \u03b1) (y : \u03b2) :\n    Quotient.map\u2082 f h (\u27e6x\u27e7 : Quotient sa) (\u27e6y\u27e7 : Quotient sb) = (\u27e6f x y\u27e7 : Quotient sc)", "start": [265, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift.decidablePred", "code": "instance lift.decidablePred (f : \u03b1 \u2192 Prop) (h : \u2200 a b, a \u2248 b \u2192 f a = f b) [DecidablePred f] :\n    DecidablePred (Quotient.lift f h) :=\n  Quot.lift.decidablePred _ _ _", "start": [271, 1], "end": [273, 32], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift\u2082.decidablePred", "code": "instance lift\u2082.decidablePred (f : \u03b1 \u2192 \u03b2 \u2192 Prop)\n    (h : \u2200 a\u2081 b\u2081 a\u2082 b\u2082, a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 f a\u2081 b\u2081 = f a\u2082 b\u2082)\n    [hf : \u2200 a, DecidablePred (f a)]\n    (q\u2081 : Quotient sa) : DecidablePred (Quotient.lift\u2082 f h q\u2081) :=\n  fun q\u2082 \u21a6 Quotient.recOnSubsingleton\u2082 q\u2081 q\u2082 hf", "start": [275, 1], "end": [280, 48], "kind": "commanddeclaration"}, {"full_name": "Quot.eq", "code": "theorem Quot.eq {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {x y : \u03b1} :\n    Quot.mk r x = Quot.mk r y \u2194 EqvGen r x y", "start": [293, 1], "end": [295, 36], "kind": "commanddeclaration"}, {"full_name": "Quotient.eq", "code": "@[simp]\ntheorem Quotient.eq [r : Setoid \u03b1] {x y : \u03b1} : Quotient.mk r x = \u27e6y\u27e7 \u2194 x \u2248 y", "start": [298, 1], "end": [300, 35], "kind": "commanddeclaration"}, {"full_name": "Quotient.forall", "code": "theorem Quotient.forall {\u03b1 : Sort*} {s : Setoid \u03b1} {p : Quotient s \u2192 Prop} :\n    (\u2200 a, p a) \u2194 \u2200 a : \u03b1, p \u27e6a\u27e7", "start": [302, 1], "end": [304, 37], "kind": "commanddeclaration"}, {"full_name": "Quotient.exists", "code": "theorem Quotient.exists {\u03b1 : Sort*} {s : Setoid \u03b1} {p : Quotient s \u2192 Prop} :\n    (\u2203 a, p a) \u2194 \u2203 a : \u03b1, p \u27e6a\u27e7", "start": [307, 1], "end": [309, 81], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift_mk", "code": "@[simp]\ntheorem Quotient.lift_mk [s : Setoid \u03b1] (f : \u03b1 \u2192 \u03b2) (h : \u2200 a b : \u03b1, a \u2248 b \u2192 f a = f b) (x : \u03b1) :\n    Quotient.lift f h (Quotient.mk s x) = f x", "start": [311, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift_comp_mk", "code": "@[simp]\ntheorem Quotient.lift_comp_mk [Setoid \u03b1] (f : \u03b1 \u2192 \u03b2) (h : \u2200 a b : \u03b1, a \u2248 b \u2192 f a = f b) :\n    Quotient.lift f h \u2218 Quotient.mk _ = f", "start": [317, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.lift\u2082_mk", "code": "@[simp]\ntheorem Quotient.lift\u2082_mk {\u03b1 : Sort*} {\u03b2 : Sort*} {\u03b3 : Sort*} [Setoid \u03b1] [Setoid \u03b2]\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (h : \u2200 (a\u2081 : \u03b1) (a\u2082 : \u03b2) (b\u2081 : \u03b1) (b\u2082 : \u03b2), a\u2081 \u2248 b\u2081 \u2192 a\u2082 \u2248 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082)\n    (a : \u03b1) (b : \u03b2) :\n    Quotient.lift\u2082 f h (Quotient.mk _ a) (Quotient.mk _ b) = f a b", "start": [323, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn_mk", "code": "theorem Quotient.liftOn_mk [s : Setoid \u03b1] (f : \u03b1 \u2192 \u03b2) (h : \u2200 a b : \u03b1, a \u2248 b \u2192 f a = f b) (x : \u03b1) :\n    Quotient.liftOn (Quotient.mk s x) f h = f x", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn\u2082_mk", "code": "@[simp]\ntheorem Quotient.liftOn\u2082_mk {\u03b1 : Sort*} {\u03b2 : Sort*} [Setoid \u03b1] (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2)\n    (h : \u2200 a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1, a\u2081 \u2248 b\u2081 \u2192 a\u2082 \u2248 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082) (x y : \u03b1) :\n    Quotient.liftOn\u2082 (Quotient.mk _ x) (Quotient.mk _ y) f h = f x y", "start": [337, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "surjective_quot_mk", "code": "theorem surjective_quot_mk (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Function.Surjective (Quot.mk r)", "start": [344, 1], "end": [346, 18], "kind": "commanddeclaration"}, {"full_name": "surjective_quotient_mk'", "code": "theorem surjective_quotient_mk' (\u03b1 : Sort*) [s : Setoid \u03b1] :\n    Function.Surjective (Quotient.mk' : \u03b1 \u2192 Quotient s)", "start": [349, 1], "end": [352, 18], "kind": "commanddeclaration"}, {"full_name": "Quot.out", "code": "noncomputable def Quot.out {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (q : Quot r) : \u03b1 :=\n  Classical.choose (Quot.exists_rep q)", "start": [355, 1], "end": [358, 39], "kind": "commanddeclaration"}, {"full_name": "Quot.unquot", "code": "unsafe def Quot.unquot {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : Quot r \u2192 \u03b1 :=\n  cast lcProof", "start": [361, 1], "end": [364, 15], "kind": "commanddeclaration"}, {"full_name": "Quot.out_eq", "code": "@[simp]\ntheorem Quot.out_eq {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (q : Quot r) : Quot.mk r q.out = q", "start": [366, 1], "end": [368, 44], "kind": "commanddeclaration"}, {"full_name": "Quotient.out", "code": "noncomputable def Quotient.out [s : Setoid \u03b1] : Quotient s \u2192 \u03b1 :=\n  Quot.out", "start": [371, 1], "end": [374, 11], "kind": "commanddeclaration"}, {"full_name": "Quotient.out_eq", "code": "@[simp]\ntheorem Quotient.out_eq [s : Setoid \u03b1] (q : Quotient s) : \u27e6q.out\u27e7 = q", "start": [377, 1], "end": [379, 16], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk_out", "code": "theorem Quotient.mk_out [Setoid \u03b1] (a : \u03b1) : \u27e6a\u27e7.out \u2248 a", "start": [382, 1], "end": [383, 37], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk_eq_iff_out", "code": "theorem Quotient.mk_eq_iff_out [s : Setoid \u03b1] {x : \u03b1} {y : Quotient s} :\n    \u27e6x\u27e7 = y \u2194 x \u2248 Quotient.out y", "start": [386, 1], "end": [389, 25], "kind": "commanddeclaration"}, {"full_name": "Quotient.eq_mk_iff_out", "code": "theorem Quotient.eq_mk_iff_out [s : Setoid \u03b1] {x : Quotient s} {y : \u03b1} :\n    x = \u27e6y\u27e7 \u2194 Quotient.out x \u2248 y", "start": [392, 1], "end": [395, 25], "kind": "commanddeclaration"}, {"full_name": "Quotient.out_equiv_out", "code": "@[simp]\ntheorem Quotient.out_equiv_out {s : Setoid \u03b1} {x y : Quotient s} : x.out \u2248 y.out \u2194 x = y", "start": [398, 1], "end": [400, 49], "kind": "commanddeclaration"}, {"full_name": "Quotient.out_injective", "code": "theorem Quotient.out_injective {s : Setoid \u03b1} : Function.Injective (@Quotient.out \u03b1 s)", "start": [403, 1], "end": [404, 60], "kind": "commanddeclaration"}, {"full_name": "Quotient.out_inj", "code": "@[simp]\ntheorem Quotient.out_inj {s : Setoid \u03b1} {x y : Quotient s} : x.out = y.out \u2194 x = y", "start": [407, 1], "end": [409, 54], "kind": "commanddeclaration"}, {"full_name": "piSetoid", "code": "instance piSetoid {\u03b9 : Sort*} {\u03b1 : \u03b9 \u2192 Sort*} [\u2200 i, Setoid (\u03b1 i)] : Setoid (\u2200 i, \u03b1 i) where\n  r a b := \u2200 i, a i \u2248 b i\n  iseqv := \u27e8fun _ _ \u21a6 Setoid.refl _,\n            fun h _ \u21a6 Setoid.symm (h _),\n            fun h\u2081 h\u2082 _ \u21a6 Setoid.trans (h\u2081 _) (h\u2082 _)\u27e9", "start": [414, 1], "end": [418, 54], "kind": "commanddeclaration"}, {"full_name": "Quotient.choice", "code": "noncomputable def Quotient.choice {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [S : \u2200 i, Setoid (\u03b1 i)]\n    (f : \u2200 i, Quotient (S i)) :\n    @Quotient (\u2200 i, \u03b1 i) (by infer_instance) :=\n  \u27e6fun i \u21a6 (f i).out\u27e7", "start": [420, 1], "end": [425, 22], "kind": "commanddeclaration"}, {"full_name": "Quotient.choice_eq", "code": "@[simp]\ntheorem Quotient.choice_eq {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Setoid (\u03b1 i)] (f : \u2200 i, \u03b1 i) :\n    (Quotient.choice fun i \u21a6 \u27e6f i\u27e7) = \u27e6f\u27e7", "start": [428, 1], "end": [431, 43], "kind": "commanddeclaration"}, {"full_name": "Quotient.induction_on_pi", "code": "@[elab_as_elim]\ntheorem Quotient.induction_on_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Sort*} [s : \u2200 i, Setoid (\u03b1 i)]\n    {p : (\u2200 i, Quotient (s i)) \u2192 Prop} (f : \u2200 i, Quotient (s i))\n    (h : \u2200 a : \u2200 i, \u03b1 i, p fun i \u21a6 \u27e6a i\u27e7) : p f", "start": [434, 1], "end": [439, 10], "kind": "commanddeclaration"}, {"full_name": "nonempty_quotient_iff", "code": "theorem nonempty_quotient_iff (s : Setoid \u03b1) : Nonempty (Quotient s) \u2194 Nonempty \u03b1", "start": [444, 1], "end": [445, 69], "kind": "commanddeclaration"}, {"full_name": "true_equivalence", "code": "theorem true_equivalence : @Equivalence \u03b1 fun _ _ \u21a6 True", "start": [451, 1], "end": [452, 56], "kind": "commanddeclaration"}, {"full_name": "trueSetoid", "code": "def trueSetoid : Setoid \u03b1 :=\n  \u27e8_, true_equivalence\u27e9", "start": [455, 1], "end": [459, 24], "kind": "commanddeclaration"}, {"full_name": "Trunc", "code": "def Trunc.{u} (\u03b1 : Sort u) : Sort u :=\n  @Quotient \u03b1 trueSetoid", "start": [462, 1], "end": [468, 25], "kind": "commanddeclaration"}, {"full_name": "Trunc.mk", "code": "def mk (a : \u03b1) : Trunc \u03b1 :=\n  Quot.mk _ a", "start": [473, 1], "end": [475, 14], "kind": "commanddeclaration"}, {"full_name": "Trunc.lift", "code": "def lift (f : \u03b1 \u2192 \u03b2) (c : \u2200 a b : \u03b1, f a = f b) : Trunc \u03b1 \u2192 \u03b2 :=\n  Quot.lift f fun a b _ \u21a6 c a b", "start": [481, 1], "end": [483, 32], "kind": "commanddeclaration"}, {"full_name": "Trunc.ind", "code": "theorem ind {\u03b2 : Trunc \u03b1 \u2192 Prop} : (\u2200 a : \u03b1, \u03b2 (mk a)) \u2192 \u2200 q : Trunc \u03b1, \u03b2 q", "start": [486, 1], "end": [487, 11], "kind": "commanddeclaration"}, {"full_name": "Trunc.lift_mk", "code": "protected theorem lift_mk (f : \u03b1 \u2192 \u03b2) (c) (a : \u03b1) : lift f c (mk a) = f a", "start": [490, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "Trunc.liftOn", "code": "protected def liftOn (q : Trunc \u03b1) (f : \u03b1 \u2192 \u03b2) (c : \u2200 a b : \u03b1, f a = f b) : \u03b2 :=\n  lift f c q", "start": [494, 1], "end": [498, 13], "kind": "commanddeclaration"}, {"full_name": "Trunc.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {\u03b2 : Trunc \u03b1 \u2192 Prop} (q : Trunc \u03b1) (h : \u2200 a, \u03b2 (mk a)) : \u03b2 q", "start": [501, 1], "end": [503, 10], "kind": "commanddeclaration"}, {"full_name": "Trunc.exists_rep", "code": "theorem exists_rep (q : Trunc \u03b1) : \u2203 a : \u03b1, mk a = q", "start": [506, 1], "end": [507, 20], "kind": "commanddeclaration"}, {"full_name": "Trunc.induction_on\u2082", "code": "@[elab_as_elim]\nprotected theorem induction_on\u2082 {C : Trunc \u03b1 \u2192 Trunc \u03b2 \u2192 Prop} (q\u2081 : Trunc \u03b1) (q\u2082 : Trunc \u03b2)\n    (h : \u2200 a b, C (mk a) (mk b)) : C q\u2081 q\u2082", "start": [510, 1], "end": [513, 62], "kind": "commanddeclaration"}, {"full_name": "Trunc.eq", "code": "protected theorem eq (a b : Trunc \u03b1) : a = b", "start": [516, 1], "end": [517, 55], "kind": "commanddeclaration"}, {"full_name": "Trunc.instSubsingletonTrunc", "code": "instance instSubsingletonTrunc : Subsingleton (Trunc \u03b1) :=\n  \u27e8Trunc.eq\u27e9", "start": [520, 1], "end": [521, 13], "kind": "commanddeclaration"}, {"full_name": "Trunc.bind", "code": "def bind (q : Trunc \u03b1) (f : \u03b1 \u2192 Trunc \u03b2) : Trunc \u03b2 :=\n  Trunc.liftOn q f fun _ _ \u21a6 Trunc.eq _ _", "start": [523, 1], "end": [525, 42], "kind": "commanddeclaration"}, {"full_name": "Trunc.map", "code": "def map (f : \u03b1 \u2192 \u03b2) (q : Trunc \u03b1) : Trunc \u03b2 :=\n  bind q (Trunc.mk \u2218 f)", "start": [528, 1], "end": [530, 24], "kind": "commanddeclaration"}, {"full_name": "Trunc.rec", "code": "@[elab_as_elim]\nprotected def rec (f : \u2200 a, C (mk a))\n    (h : \u2200 a b : \u03b1, (Eq.ndrec (f a) (Trunc.eq (mk a) (mk b)) : C (mk b)) = f b)\n    (q : Trunc \u03b1) : C q :=\n  Quot.rec f (fun a b _ \u21a6 h a b) q", "start": [551, 1], "end": [557, 35], "kind": "commanddeclaration"}, {"full_name": "Trunc.recOn", "code": "@[elab_as_elim]\nprotected def recOn (q : Trunc \u03b1) (f : \u2200 a, C (mk a))\n    (h : \u2200 a b : \u03b1, (Eq.ndrec (f a) (Trunc.eq (mk a) (mk b)) : C (mk b)) = f b) : C q :=\n  Trunc.rec f h q", "start": [560, 1], "end": [565, 18], "kind": "commanddeclaration"}, {"full_name": "Trunc.recOnSubsingleton", "code": "@[elab_as_elim]\nprotected def recOnSubsingleton [\u2200 a, Subsingleton (C (mk a))] (q : Trunc \u03b1) (f : \u2200 a, C (mk a)) :\n    C q :=\n  Trunc.rec f (fun _ b \u21a6 Subsingleton.elim _ (f b)) q", "start": [568, 1], "end": [573, 54], "kind": "commanddeclaration"}, {"full_name": "Trunc.out", "code": "noncomputable def out : Trunc \u03b1 \u2192 \u03b1 :=\n  Quot.out", "start": [576, 1], "end": [578, 11], "kind": "commanddeclaration"}, {"full_name": "Trunc.out_eq", "code": "@[simp]\ntheorem out_eq (q : Trunc \u03b1) : mk q.out = q", "start": [581, 1], "end": [583, 15], "kind": "commanddeclaration"}, {"full_name": "Trunc.nonempty", "code": "protected theorem nonempty (q : Trunc \u03b1) : Nonempty \u03b1", "start": [586, 1], "end": [587, 34], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk''", "code": "protected def mk'' (a : \u03b1) : Quotient s\u2081 :=\n  Quot.mk s\u2081.1 a", "start": [606, 1], "end": [609, 17], "kind": "commanddeclaration"}, {"full_name": "Quotient.surjective_Quotient_mk''", "code": "theorem surjective_Quotient_mk'' : Function.Surjective (Quotient.mk'' : \u03b1 \u2192 Quotient s\u2081)", "start": [613, 1], "end": [615, 18], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn'", "code": "protected def liftOn' (q : Quotient s\u2081) (f : \u03b1 \u2192 \u03c6) (h : \u2200 a b, @Setoid.r \u03b1 s\u2081 a b \u2192 f a = f b) :\n    \u03c6 :=\n  Quotient.liftOn q f h", "start": [618, 1], "end": [624, 24], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn'_mk''", "code": "@[simp]\nprotected theorem liftOn'_mk'' (f : \u03b1 \u2192 \u03c6) (h) (x : \u03b1) :\n    Quotient.liftOn' (@Quotient.mk'' _ s\u2081 x) f h = f x", "start": [627, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.surjective_liftOn'", "code": "@[simp] lemma surjective_liftOn' {f : \u03b1 \u2192 \u03c6} (h) :\n    Function.Surjective (\u03bb x : Quotient s\u2081 => x.liftOn' f h) \u2194 Function.Surjective f :=\n  Quot.surjective_lift _", "start": [632, 1], "end": [634, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Quotient.liftOn\u2082'", "code": "protected def liftOn\u2082' (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)\n    (h : \u2200 a\u2081 a\u2082 b\u2081 b\u2082, @Setoid.r \u03b1 s\u2081 a\u2081 b\u2081 \u2192 @Setoid.r \u03b2 s\u2082 a\u2082 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082) : \u03b3 :=\n  Quotient.liftOn\u2082 q\u2081 q\u2082 f h", "start": [637, 1], "end": [643, 29], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn\u2082'_mk''", "code": "@[simp]\nprotected theorem liftOn\u2082'_mk'' (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h) (a : \u03b1) (b : \u03b2) :\n    Quotient.liftOn\u2082' (@Quotient.mk'' _ s\u2081 a) (@Quotient.mk'' _ s\u2082 b) f h = f a b", "start": [646, 1], "end": [649, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.ind'", "code": "@[elab_as_elim]\nprotected theorem ind' {p : Quotient s\u2081 \u2192 Prop} (h : \u2200 a, p (Quotient.mk'' a)) (q : Quotient s\u2081) :\n    p q", "start": [651, 1], "end": [656, 19], "kind": "commanddeclaration"}, {"full_name": "Quotient.ind\u2082'", "code": "@[elab_as_elim]\nprotected theorem ind\u2082' {p : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Prop}\n    (h : \u2200 a\u2081 a\u2082, p (Quotient.mk'' a\u2081) (Quotient.mk'' a\u2082))\n    (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082) : p q\u2081 q\u2082", "start": [659, 1], "end": [665, 24], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn'", "code": "@[elab_as_elim]\nprotected theorem inductionOn' {p : Quotient s\u2081 \u2192 Prop} (q : Quotient s\u2081)\n    (h : \u2200 a, p (Quotient.mk'' a)) : p q", "start": [668, 1], "end": [673, 27], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn\u2082'", "code": "@[elab_as_elim]\nprotected theorem inductionOn\u2082' {p : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Prop} (q\u2081 : Quotient s\u2081)\n    (q\u2082 : Quotient s\u2082)\n    (h : \u2200 a\u2081 a\u2082, p (Quotient.mk'' a\u2081) (Quotient.mk'' a\u2082)) : p q\u2081 q\u2082", "start": [676, 1], "end": [682, 32], "kind": "commanddeclaration"}, {"full_name": "Quotient.inductionOn\u2083'", "code": "@[elab_as_elim]\nprotected theorem inductionOn\u2083' {p : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Quotient s\u2083 \u2192 Prop}\n    (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082) (q\u2083 : Quotient s\u2083)\n    (h : \u2200 a\u2081 a\u2082 a\u2083, p (Quotient.mk'' a\u2081) (Quotient.mk'' a\u2082) (Quotient.mk'' a\u2083)) :\n    p q\u2081 q\u2082 q\u2083", "start": [685, 1], "end": [692, 35], "kind": "commanddeclaration"}, {"full_name": "Quotient.recOnSubsingleton'", "code": "@[elab_as_elim]\nprotected def recOnSubsingleton' {\u03c6 : Quotient s\u2081 \u2192 Sort*} [\u2200 a, Subsingleton (\u03c6 \u27e6a\u27e7)]\n    (q : Quotient s\u2081)\n    (f : \u2200 a, \u03c6 (Quotient.mk'' a)) : \u03c6 q :=\n  Quotient.recOnSubsingleton q f", "start": [695, 1], "end": [701, 33], "kind": "commanddeclaration"}, {"full_name": "Quotient.recOnSubsingleton\u2082'", "code": "@[elab_as_elim]\nprotected def recOnSubsingleton\u2082' {\u03c6 : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Sort*}\n    [\u2200 a b, Subsingleton (\u03c6 \u27e6a\u27e7 \u27e6b\u27e7)]\n    (q\u2081 : Quotient s\u2081) (q\u2082 : Quotient s\u2082) (f : \u2200 a\u2081 a\u2082, \u03c6 (Quotient.mk'' a\u2081) (Quotient.mk'' a\u2082)) :\n    \u03c6 q\u2081 q\u2082 :=\n  Quotient.recOnSubsingleton\u2082 q\u2081 q\u2082 f", "start": [704, 1], "end": [712, 38], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn'", "code": "protected def hrecOn' {\u03c6 : Quotient s\u2081 \u2192 Sort*} (qa : Quotient s\u2081) (f : \u2200 a, \u03c6 (Quotient.mk'' a))\n    (c : \u2200 a\u2081 a\u2082, a\u2081 \u2248 a\u2082 \u2192 HEq (f a\u2081) (f a\u2082)) : \u03c6 qa :=\n  Quot.hrecOn qa f c", "start": [715, 1], "end": [718, 21], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn'_mk''", "code": "@[simp]\ntheorem hrecOn'_mk'' {\u03c6 : Quotient s\u2081 \u2192 Sort*} (f : \u2200 a, \u03c6 (Quotient.mk'' a))\n    (c : \u2200 a\u2081 a\u2082, a\u2081 \u2248 a\u2082 \u2192 HEq (f a\u2081) (f a\u2082))\n    (x : \u03b1) : (Quotient.mk'' x).hrecOn' f c = f x", "start": [721, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn\u2082'", "code": "protected def hrecOn\u2082' {\u03c6 : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Sort*} (qa : Quotient s\u2081)\n    (qb : Quotient s\u2082) (f : \u2200 a b, \u03c6 (Quotient.mk'' a) (Quotient.mk'' b))\n    (c : \u2200 a\u2081 b\u2081 a\u2082 b\u2082, a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 HEq (f a\u2081 b\u2081) (f a\u2082 b\u2082)) :\n    \u03c6 qa qb :=\n  Quotient.hrecOn\u2082 qa qb f c", "start": [728, 1], "end": [733, 29], "kind": "commanddeclaration"}, {"full_name": "Quotient.hrecOn\u2082'_mk''", "code": "@[simp]\ntheorem hrecOn\u2082'_mk'' {\u03c6 : Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Sort*}\n    (f : \u2200 a b, \u03c6 (Quotient.mk'' a) (Quotient.mk'' b))\n    (c : \u2200 a\u2081 b\u2081 a\u2082 b\u2082, a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 HEq (f a\u2081 b\u2081) (f a\u2082 b\u2082)) (x : \u03b1) (qb : Quotient s\u2082) :\n    (Quotient.mk'' x).hrecOn\u2082' qb f c = qb.hrecOn' (f x) fun _ _ \u21a6 c _ _ _ _ (Setoid.refl _)", "start": [736, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.map'", "code": "protected def map' (f : \u03b1 \u2192 \u03b2) (h : (s\u2081.r \u21d2 s\u2082.r) f f) : Quotient s\u2081 \u2192 Quotient s\u2082 :=\n  Quot.map f h", "start": [744, 1], "end": [747, 15], "kind": "commanddeclaration"}, {"full_name": "Quotient.map'_mk''", "code": "@[simp]\ntheorem map'_mk'' (f : \u03b1 \u2192 \u03b2) (h) (x : \u03b1) :\n    (Quotient.mk'' x : Quotient s\u2081).map' f h = (Quotient.mk'' (f x) : Quotient s\u2082)", "start": [750, 1], "end": [753, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.map\u2082'", "code": "protected def map\u2082' (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h : (s\u2081.r \u21d2 s\u2082.r \u21d2 s\u2083.r) f f) :\n    Quotient s\u2081 \u2192 Quotient s\u2082 \u2192 Quotient s\u2083 :=\n  Quotient.map\u2082 f h", "start": [755, 1], "end": [758, 20], "kind": "commanddeclaration"}, {"full_name": "Quotient.map\u2082'_mk''", "code": "@[simp]\ntheorem map\u2082'_mk'' (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h) (x : \u03b1) :\n    (Quotient.mk'' x : Quotient s\u2081).map\u2082' f h =\n      (Quotient.map' (f x) (h (Setoid.refl x)) : Quotient s\u2082 \u2192 Quotient s\u2083)", "start": [761, 1], "end": [765, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.exact'", "code": "theorem exact' {a b : \u03b1} :\n    (Quotient.mk'' a : Quotient s\u2081) = Quotient.mk'' b \u2192 @Setoid.r _ s\u2081 a b", "start": [767, 1], "end": [769, 17], "kind": "commanddeclaration"}, {"full_name": "Quotient.sound'", "code": "theorem sound' {a b : \u03b1} : @Setoid.r _ s\u2081 a b \u2192 @Quotient.mk'' \u03b1 s\u2081 a = Quotient.mk'' b", "start": [772, 1], "end": [773, 17], "kind": "commanddeclaration"}, {"full_name": "Quotient.eq'", "code": "@[simp]\nprotected theorem eq' [s\u2081 : Setoid \u03b1] {a b : \u03b1} :\n    @Quotient.mk' \u03b1 s\u2081 a = @Quotient.mk' \u03b1 s\u2081 b \u2194 @Setoid.r _ s\u2081 a b", "start": [776, 1], "end": [779, 14], "kind": "commanddeclaration"}, {"full_name": "Quotient.eq''", "code": "@[simp]\nprotected theorem eq'' {a b : \u03b1} : @Quotient.mk'' \u03b1 s\u2081 a = Quotient.mk'' b \u2194 @Setoid.r _ s\u2081 a b", "start": [782, 1], "end": [784, 14], "kind": "commanddeclaration"}, {"full_name": "Quotient.out'", "code": "noncomputable def out' (a : Quotient s\u2081) : \u03b1 :=\n  Quotient.out a", "start": [787, 1], "end": [790, 17], "kind": "commanddeclaration"}, {"full_name": "Quotient.out_eq'", "code": "@[simp]\ntheorem out_eq' (q : Quotient s\u2081) : Quotient.mk'' q.out' = q", "start": [793, 1], "end": [795, 11], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk_out'", "code": "theorem mk_out' (a : \u03b1) : @Setoid.r \u03b1 s\u2081 (Quotient.mk'' a : Quotient s\u2081).out' a", "start": [798, 1], "end": [799, 37], "kind": "commanddeclaration"}, {"full_name": "Quotient.mk''_eq_mk", "code": "protected theorem mk''_eq_mk (x : \u03b1) : Quotient.mk'' x = Quotient.mk s x", "start": [806, 1], "end": [807, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn'_mk", "code": "@[simp]\nprotected theorem liftOn'_mk (x : \u03b1) (f : \u03b1 \u2192 \u03b2) (h) : (Quotient.mk s x).liftOn' f h = f x", "start": [809, 1], "end": [811, 6], "kind": "commanddeclaration"}, {"full_name": "Quotient.liftOn\u2082'_mk", "code": "@[simp]\nprotected theorem liftOn\u2082'_mk [t : Setoid \u03b2] (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h) (a : \u03b1) (b : \u03b2) :\n    Quotient.liftOn\u2082' (Quotient.mk s a) (Quotient.mk t b) f h = f a b", "start": [814, 1], "end": [817, 33], "kind": "commanddeclaration"}, {"full_name": "Quotient.map'_mk", "code": "@[simp]\ntheorem map'_mk [t : Setoid \u03b2] (f : \u03b1 \u2192 \u03b2) (h) (x : \u03b1) :\n    (Quotient.mk s x).map' f h = (Quotient.mk t (f x))", "start": [820, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "Equivalence.quot_mk_eq_iff", "code": "@[simp]\nlemma Equivalence.quot_mk_eq_iff {\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Equivalence r) (x y : \u03b1) :\n    Quot.mk r x = Quot.mk r y \u2194 r x y := by\n  constructor\n  \u00b7 rw [Quot.eq]\n    intro hxy\n    induction hxy with\n    | rel _ _ H => exact H\n    | refl _ => exact h.refl _\n    | symm _ _ _ H => exact h.symm H\n    | trans _ _ _ _ _ h\u2081\u2082 h\u2082\u2083 => exact h.trans h\u2081\u2082 h\u2082\u2083\n  \u00b7 exact Quot.sound", "start": [841, 1], "end": [852, 21], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Logic/Unique.lean", "imports": ["Mathlib/Tactic/Inhabit.lean", "Mathlib/Init/Data/Fin/Basic.lean", "Mathlib/Logic/IsEmpty.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Logic.lean"], "premises": [{"full_name": "Unique", "code": "@[ext]\nstructure Unique (\u03b1 : Sort u) extends Inhabited \u03b1 where\n  \n  uniq : \u2200 a : \u03b1, a = default", "start": [50, 1], "end": [57, 30], "kind": "commanddeclaration"}, {"full_name": "unique_iff_exists_unique", "code": "theorem unique_iff_exists_unique (\u03b1 : Sort u) : Nonempty (Unique \u03b1) \u2194 \u2203! _ : \u03b1, True", "start": [66, 1], "end": [68, 49], "kind": "commanddeclaration"}, {"full_name": "unique_subtype_iff_exists_unique", "code": "theorem unique_subtype_iff_exists_unique {\u03b1} (p : \u03b1 \u2192 Prop) :\n    Nonempty (Unique (Subtype p)) \u2194 \u2203! a, p a", "start": [71, 1], "end": [76, 23], "kind": "commanddeclaration"}, {"full_name": "uniqueOfSubsingleton", "code": "@[reducible]\ndef uniqueOfSubsingleton {\u03b1 : Sort*} [Subsingleton \u03b1] (a : \u03b1) : Unique \u03b1 where\n  default := a\n  uniq _ := Subsingleton.elim _ _", "start": [79, 1], "end": [88, 34], "kind": "commanddeclaration"}, {"full_name": "PUnit.unique", "code": "instance PUnit.unique : Unique PUnit.{u} where\n  default := PUnit.unit\n  uniq x := subsingleton x _", "start": [91, 1], "end": [93, 29], "kind": "commanddeclaration"}, {"full_name": "PUnit.default_eq_unit", "code": "@[simp, nolint simpNF]\ntheorem PUnit.default_eq_unit : (default : PUnit) = PUnit.unit", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "uniqueProp", "code": "def uniqueProp {p : Prop} (h : p) : Unique.{0} p where\n  default := h\n  uniq _ := rfl", "start": [104, 1], "end": [107, 16], "kind": "commanddeclaration"}, {"full_name": "Fin.eq_zero", "code": "theorem Fin.eq_zero : \u2200 n : Fin 1, n = 0", "start": [113, 1], "end": [114, 77], "kind": "commanddeclaration"}, {"full_name": "inhabitedFinOneAdd", "code": "instance inhabitedFinOneAdd (n : \u2115) : Inhabited (Fin (1 + n)) :=\n  \u27e8\u27e80, by rw [Nat.add_comm]; exact Nat.zero_lt_succ _\u27e9\u27e9", "start": [120, 1], "end": [121, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.default_eq_zero", "code": "@[simp]\ntheorem Fin.default_eq_zero (n : \u2115) : (default : Fin n.succ) = 0", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.unique", "code": "instance Fin.unique : Unique (Fin 1) where\n  uniq := Fin.eq_zero", "start": [128, 1], "end": [129, 22], "kind": "commanddeclaration"}, {"full_name": "Unique.eq_default", "code": "theorem eq_default (a : \u03b1) : a = default", "start": [143, 1], "end": [144, 11], "kind": "commanddeclaration"}, {"full_name": "Unique.default_eq", "code": "theorem default_eq (a : \u03b1) : default = a", "start": [147, 1], "end": [148, 18], "kind": "commanddeclaration"}, {"full_name": "Unique.instSubsingleton", "code": "instance (priority := 100) instSubsingleton : Subsingleton \u03b1 :=\n  subsingleton_of_forall_eq _ eq_default", "start": [152, 1], "end": [153, 41], "kind": "commanddeclaration"}, {"full_name": "Unique.forall_iff", "code": "theorem forall_iff {p : \u03b1 \u2192 Prop} : (\u2200 a, p a) \u2194 p default", "start": [155, 1], "end": [156, 56], "kind": "commanddeclaration"}, {"full_name": "Unique.exists_iff", "code": "theorem exists_iff {p : \u03b1 \u2192 Prop} : Exists p \u2194 p default", "start": [159, 1], "end": [160, 58], "kind": "commanddeclaration"}, {"full_name": "Unique.subsingleton_unique'", "code": "@[ext]\nprotected theorem subsingleton_unique' : \u2200 h\u2081 h\u2082 : Unique \u03b1, h\u2081 = h\u2082", "start": [165, 1], "end": [167, 50], "kind": "commanddeclaration"}, {"full_name": "Unique.subsingleton_unique", "code": "instance subsingleton_unique : Subsingleton (Unique \u03b1) :=\n  \u27e8Unique.subsingleton_unique'\u27e9", "start": [170, 1], "end": [171, 32], "kind": "commanddeclaration"}, {"full_name": "Unique.mk'", "code": "@[reducible]\ndef mk' (\u03b1 : Sort u) [h\u2081 : Inhabited \u03b1] [Subsingleton \u03b1] : Unique \u03b1 :=\n  { h\u2081 with uniq := fun _ \u21a6 Subsingleton.elim _ _ }", "start": [173, 1], "end": [177, 52], "kind": "commanddeclaration"}, {"full_name": "unique_iff_subsingleton_and_nonempty", "code": "theorem unique_iff_subsingleton_and_nonempty (\u03b1 : Sort u) :\n    Nonempty (Unique \u03b1) \u2194 Subsingleton \u03b1 \u2227 Nonempty \u03b1", "start": [182, 1], "end": [185, 54], "kind": "commanddeclaration"}, {"full_name": "Pi.default_def", "code": "@[simp]\ntheorem Pi.default_def {\u03b2 : \u03b1 \u2192 Sort v} [\u2200 a, Inhabited (\u03b2 a)] :\n    @default (\u2200 a, \u03b2 a) _ = fun a : \u03b1 \u21a6 @default (\u03b2 a) _", "start": [188, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.default_apply", "code": "theorem Pi.default_apply {\u03b2 : \u03b1 \u2192 Sort v} [\u2200 a, Inhabited (\u03b2 a)] (a : \u03b1) :\n    @default (\u2200 a, \u03b2 a) _ a = default", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.unique", "code": "instance Pi.unique {\u03b2 : \u03b1 \u2192 Sort v} [\u2200 a, Unique (\u03b2 a)] : Unique (\u2200 a, \u03b2 a) where\n  uniq := fun _ \u21a6 funext fun _ \u21a6 Unique.eq_default _", "start": [199, 1], "end": [200, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.uniqueOfIsEmpty", "code": "instance Pi.uniqueOfIsEmpty [IsEmpty \u03b1] (\u03b2 : \u03b1 \u2192 Sort v) : Unique (\u2200 a, \u03b2 a) where\n  default := isEmptyElim\n  uniq _ := funext isEmptyElim", "start": [202, 1], "end": [205, 31], "kind": "commanddeclaration"}, {"full_name": "eq_const_of_subsingleton", "code": "theorem eq_const_of_subsingleton [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    f = Function.const \u03b1 (f a)", "start": [207, 1], "end": [209, 45], "kind": "commanddeclaration"}, {"full_name": "eq_const_of_unique", "code": "theorem eq_const_of_unique [Unique \u03b1] (f : \u03b1 \u2192 \u03b2) : f = Function.const \u03b1 (f default)", "start": [211, 1], "end": [212, 30], "kind": "commanddeclaration"}, {"full_name": "heq_const_of_unique", "code": "theorem heq_const_of_unique [Unique \u03b1] {\u03b2 : \u03b1 \u2192 Sort v} (f : \u2200 a, \u03b2 a) :\n    HEq f (Function.const \u03b1 (f default))", "start": [215, 1], "end": [217, 78], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.subsingleton", "code": "protected theorem Injective.subsingleton (hf : Injective f) [Subsingleton \u03b2] : Subsingleton \u03b1", "start": [224, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.subsingleton", "code": "protected theorem Surjective.subsingleton [Subsingleton \u03b1] (hf : Surjective f) : Subsingleton \u03b2", "start": [230, 1], "end": [233, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.unique", "code": "protected def Surjective.unique (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) [Unique.{u} \u03b1] : Unique \u03b2 :=\n  @Unique.mk' _ \u27e8f default\u27e9 hf.subsingleton", "start": [236, 1], "end": [239, 44], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.unique", "code": "protected def Injective.unique [Inhabited \u03b1] [Subsingleton \u03b2] (hf : Injective f) : Unique \u03b1 :=\n  @Unique.mk' _ _ hf.subsingleton", "start": [242, 1], "end": [244, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.uniqueOfSurjectiveConst", "code": "def Surjective.uniqueOfSurjectiveConst (\u03b1 : Type*) {\u03b2 : Type*} (b : \u03b2)\n    (h : Function.Surjective (Function.const \u03b1 b)) : Unique \u03b2 :=\n  @uniqueOfSubsingleton _ (subsingleton_of_forall_eq b <| h.forall.mpr fun _ \u21a6 rfl) b", "start": [247, 1], "end": [250, 86], "kind": "commanddeclaration"}, {"full_name": "Unique.bijective", "code": "theorem Unique.bijective {A B} [Unique A] [Unique B] {f : A \u2192 B} : Function.Bijective f", "start": [257, 1], "end": [259, 47], "kind": "commanddeclaration"}, {"full_name": "Option.subsingleton_iff_isEmpty", "code": "theorem subsingleton_iff_isEmpty {\u03b1 : Type u} : Subsingleton (Option \u03b1) \u2194 IsEmpty \u03b1", "start": [264, 1], "end": [268, 81], "kind": "commanddeclaration"}, {"full_name": "Unique.subtypeEq", "code": "instance Unique.subtypeEq (y : \u03b1) : Unique { x // x = y } where\n  default := \u27e8y, rfl\u27e9\n  uniq := fun \u27e8x, hx\u27e9 \u21a6 by congr", "start": [279, 1], "end": [281, 33], "kind": "commanddeclaration"}, {"full_name": "Unique.subtypeEq'", "code": "instance Unique.subtypeEq' (y : \u03b1) : Unique { x // y = x } where\n  default := \u27e8y, rfl\u27e9\n  uniq := fun \u27e8x, hx\u27e9 \u21a6 by subst hx; congr", "start": [283, 1], "end": [285, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Expansion.lean", "imports": ["lake-packages/aesop/Aesop/Search/Expansion/Norm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.RuleResult", "code": "inductive RuleResult\n  | proved (newRapps : Array RappRef)\n  | succeeded (newRapps : Array RappRef)\n  | failed", "start": [16, 1], "end": [19, 11], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleResult.toEmoji", "code": "def toEmoji : RuleResult \u2192 String\n  | proved .. => ruleProvedEmoji\n  | succeeded .. => ruleSuccessEmoji\n  | failed => ruleFailureEmoji", "start": [23, 1], "end": [26, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.RuleResult.isSuccessful", "code": "def isSuccessful\n  | proved .. | succeeded .. => true\n  | failed => false", "start": [28, 1], "end": [30, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRuleResult", "code": "inductive SafeRuleResult\n  | regular (result : RuleResult)\n  | postponed (result : PostponedSafeRule)", "start": [34, 1], "end": [36, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRuleResult.toEmoji", "code": "def toEmoji : SafeRuleResult \u2192 String\n  | regular r => r.toEmoji\n  | postponed .. => rulePostponedEmoji", "start": [40, 1], "end": [42, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRuleResult.isSuccessfulOrPostponed", "code": "def isSuccessfulOrPostponed\n  | regular r => r.isSuccessful\n  | postponed .. => true", "start": [44, 1], "end": [46, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.runRegularRuleTac", "code": "def runRegularRuleTac (goal : Goal) (tac : RuleTac) (ruleName : RuleName)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation)\n    (options : Options') :\n    MetaM (Sum Exception RuleTacOutput) := do\n  let some (postNormGoal, postNormState) := goal.postNormGoalAndMetaState? | throwError\n    \"aesop: internal error: expected goal {goal.id} to be normalised (but not proven by normalisation).\"\n  let input := {\n    goal := postNormGoal\n    mvars := goal.mvars\n    indexMatchLocations, options\n  }\n  runRuleTac tac ruleName postNormState input", "start": [50, 1], "end": [61, 46], "kind": "commanddeclaration"}, {"full_name": "Aesop.addRapps", "code": "def addRapps (parentRef : GoalRef) (rule : RegularRule)\n    (rapps : Array RuleApplicationWithMVarInfo) :\n    SearchM Q RuleResult := do\n  let parent \u2190 parentRef.get\n\n  let mut rrefs := Array.mkEmpty rapps.size\n  let mut subgoals := Array.mkEmpty $ rapps.size * 3\n  for h : i in [:rapps.size] do\n    let rapp := rapps[i]'(by simp_all [Membership.mem])\n    let successProbability :=\n      parent.successProbability *\n      (rapp.successProbability?.getD rule.successProbability)\n    let rref \u2190 addRapp {\n      rapp with\n      parent := parentRef\n      appliedRule := rule\n      successProbability }\n    rrefs := rrefs.push rref\n    for cref in (\u2190 rref.get).children do\n      for gref in (\u2190 cref.get).goals do\n        subgoals := subgoals.push gref\n\n  enqueueGoals subgoals\n  rrefs.forM (\u00b7.markProven)\n    let provenRref? \u2190 rrefs.findM? \u03bb rref => return (\u2190 rref.get).state.isProven\n  if let (some _) := provenRref? then\n    return .proved rrefs\n  else\n    return .succeeded rrefs", "start": [63, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "Aesop.addRuleFailure", "code": "private def addRuleFailure (rule : RegularRule) (parentRef : GoalRef) :\n    SearchM Q Unit := do\n  parentRef.modify \u03bb g => g.setFailedRapps $ g.failedRapps.push rule", "start": [97, 1], "end": [99, 69], "kind": "commanddeclaration"}, {"full_name": "Aesop.withRuleTraceNode", "code": "@[inline, always_inline]\ndef withRuleTraceNode (ruleName : RuleName)\n    (toEmoji : \u03b1 \u2192 String) (suffix : String) (k : SearchM Q \u03b1) : SearchM Q \u03b1 :=\n  withAesopTraceNode .steps fmt k\n  where\n    fmt (result : Except Exception \u03b1) : SearchM Q MessageData := do\n      let emoji := exceptRuleResultToEmoji toEmoji result\n      return m!\"{emoji} {ruleName}{suffix}\"", "start": [101, 1], "end": [108, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.runRegularRuleCore", "code": "def runRegularRuleCore (parentRef : GoalRef) (rule : RegularRule)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation) :\n    SearchM Q (Option RuleTacOutput) := do\n  let parent \u2190 parentRef.get\n  let ruleOutput? \u2190\n    runRegularRuleTac parent rule.tac.run rule.name indexMatchLocations\n      (\u2190 read).options\n  match ruleOutput? with\n  | Sum.inl exc =>\n    aesop_trace[steps] exc.toMessageData\n    return none\n  | Sum.inr { applications := #[], .. } =>\n    aesop_trace[steps] \"Rule returned no rule applications\"\n    return none\n  | Sum.inr output =>\n    return some output", "start": [110, 1], "end": [125, 23], "kind": "commanddeclaration"}, {"full_name": "Aesop.runSafeRuleCore", "code": "def runSafeRuleCore (parentRef : GoalRef) (rule : SafeRule)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation) :\n    SearchM Q SafeRuleResult := do\n  withRuleTraceNode rule.name (\u00b7.toEmoji) \"\" do\n    let some output \u2190\n        runRegularRuleCore parentRef (.safe rule) indexMatchLocations\n      | do addRuleFailure (.safe rule) parentRef; return .regular .failed\n    let parentMVars := (\u2190 parentRef.get).mvars\n    let rapps \u2190\n      output.applications.mapM (\u00b7.toRuleApplicationWithMVarInfo parentMVars)\n    if rapps.size != 1 then\n      aesop_trace[steps] \"Safe rule did not produce exactly one rule application\"\n      addRuleFailure (.safe rule) parentRef\n      return .regular .failed\n    else if rapps.any (! \u00b7.assignedMVars.isEmpty) then\n      aesop_trace[steps] \"Safe rule assigned metavariables, so we postpone it\"\n      return .postponed \u27e8rule, output\u27e9\n    else\n      return .regular (\u2190 addRapps parentRef (.safe rule) rapps)", "start": [127, 1], "end": [145, 64], "kind": "commanddeclaration"}, {"full_name": "Aesop.runSafeRule", "code": "def runSafeRule (parentRef : GoalRef) (rule : SafeRule)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation) :\n    SearchM Q SafeRuleResult :=\n  profiling (runSafeRuleCore parentRef rule indexMatchLocations)\n    \u03bb result elapsed => recordRuleProfile {\n        rule := .ruleName rule.name\n        successful := result.isSuccessfulOrPostponed\n        elapsed\n      }", "start": [147, 1], "end": [155, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.runUnsafeRuleCore", "code": "def runUnsafeRuleCore (parentRef : GoalRef) (rule : UnsafeRule)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation) :\n    SearchM Q RuleResult := do\n  withRuleTraceNode rule.name (\u00b7.toEmoji) \"\" do\n    let some output \u2190\n        runRegularRuleCore parentRef (.unsafe rule) indexMatchLocations\n      | do addRuleFailure (.unsafe rule) parentRef; return .failed\n    let parentMVars := (\u2190 parentRef.get).mvars\n    let rapps \u2190\n      output.applications.mapM (\u00b7.toRuleApplicationWithMVarInfo parentMVars)\n    addRapps parentRef (.unsafe rule) rapps", "start": [157, 1], "end": [167, 44], "kind": "commanddeclaration"}, {"full_name": "Aesop.runUnsafeRule", "code": "def runUnsafeRule (parentRef : GoalRef) (rule : UnsafeRule)\n    (indexMatchLocations : UnorderedArraySet IndexMatchLocation) :\n    SearchM Q RuleResult :=\n  profiling (runUnsafeRuleCore parentRef rule indexMatchLocations)\n    \u03bb result elapsed => recordRuleProfile {\n        rule := .ruleName rule.name\n        successful := result.isSuccessful\n        elapsed\n      }", "start": [169, 1], "end": [177, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRulesResult", "code": "inductive SafeRulesResult\n  | proved (newRapps : Array RappRef)\n  | succeeded (newRapps : Array RappRef)\n  | failed (postponed : Array PostponedSafeRule)\n  | skipped", "start": [179, 1], "end": [183, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.SafeRulesResult.toEmoji", "code": "def SafeRulesResult.toEmoji : SafeRulesResult \u2192 String\n  | proved .. => ruleProvedEmoji\n  | succeeded .. => ruleSuccessEmoji\n  | failed .. => ruleFailureEmoji\n  | skipped => ruleSkippedEmoji", "start": [185, 1], "end": [189, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.runFirstSafeRule", "code": "def runFirstSafeRule (gref : GoalRef) : SearchM Q SafeRulesResult := do\n  let g \u2190 gref.get\n  if g.unsafeRulesSelected then\n    return .skipped\n    let rules \u2190 selectSafeRules g\n  let mut postponedRules := {}\n  for r in rules do\n    let result \u2190 runSafeRule gref r.rule r.locations\n    match result with\n    | .regular .failed => continue\n    | .regular (.proved newRapps) => return .proved newRapps\n    | .regular (.succeeded newRapps) => return .succeeded newRapps\n    | .postponed r =>\n      postponedRules := postponedRules.push r\n  return .failed postponedRules", "start": [191, 1], "end": [207, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.applyPostponedSafeRule", "code": "def applyPostponedSafeRule (r : PostponedSafeRule) (parentRef : GoalRef) :\n    SearchM Q RuleResult := do\n  withRuleTraceNode r.rule.name (\u00b7.toEmoji) \" (postponed)\" do\n    let parentMVars := (\u2190 parentRef.get).mvars\n    let rapps \u2190 r.output.applications.mapM\n      (\u00b7.toRuleApplicationWithMVarInfo parentMVars)\n    addRapps parentRef (.\u00abunsafe\u00bb r.toUnsafeRule) rapps", "start": [209, 1], "end": [215, 56], "kind": "commanddeclaration"}, {"full_name": "Aesop.runFirstUnsafeRule", "code": "partial def runFirstUnsafeRule (postponedSafeRules : Array PostponedSafeRule)\n    (parentRef : GoalRef) : SearchM Q RuleResult := do\n  let queue \u2190 selectUnsafeRules postponedSafeRules parentRef\n  let (remainingQueue, result) \u2190 loop queue\n  parentRef.modify \u03bb g => g.setUnsafeQueue remainingQueue\n  if remainingQueue.isEmpty then\n    let parent \u2190 parentRef.get\n    if \u2190 pure (! parent.state.isProven) <&&> parent.isUnprovableNoCache then\n      parentRef.markUnprovable\n  return result\n  where\n    loop (queue : UnsafeQueue) : SearchM Q (UnsafeQueue \u00d7 RuleResult) := do\n      let (some (r, queue)) := Subarray.popFront? queue\n        | return (queue, RuleResult.failed)\n      match r with\n      | .unsafeRule r =>\n        let result \u2190 runUnsafeRule parentRef r.rule r.locations\n        match result with\n        | .proved .. => return (queue, result)\n        | .succeeded .. => return (queue, result)\n        | .failed => loop queue\n      | .postponedSafeRule r =>\n        return (queue, \u2190 applyPostponedSafeRule r parentRef)", "start": [217, 1], "end": [239, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandGoal", "code": "def expandGoal (gref : GoalRef) : SearchM Q RuleResult := do\n  let provedByNorm \u2190\n    withAesopTraceNode .steps fmtNorm (normalizeGoalIfNecessary gref)\n  aesop_trace[steps] do\n    let (goal, metaState) \u2190\n      (\u2190 gref.get).currentGoalAndMetaState (\u2190 getRootMetaState)\n    metaState.runMetaM' do\n      aesop_trace![steps] \"Goal after normalisation:{indentD goal}\"\n  if provedByNorm then\n    return .proved #[]\n  let safeResult \u2190\n    withAesopTraceNode .steps fmtSafe (runFirstSafeRule gref)\n  match safeResult with\n  | .succeeded newRapps => return .succeeded newRapps\n  | .proved newRapps => return .proved newRapps\n  | .failed postponedSafeRules => doUnsafe postponedSafeRules\n  | .skipped => doUnsafe #[]\n  where\n    doUnsafe (postponedSafeRules : Array PostponedSafeRule) :\n        SearchM Q RuleResult := do\n      withAesopTraceNode .steps fmtUnsafe do\n        runFirstUnsafeRule postponedSafeRules gref\n\n    fmtNorm (result : Except Exception Bool) : SearchM Q MessageData :=\n      let emoji :=\n        match result with\n        | .error _ => ruleErrorEmoji\n        | .ok true => ruleProvedEmoji\n        | .ok false => ruleSuccessEmoji\n      return m!\"{emoji} Normalisation\"\n\n    fmtSafe (result : Except Exception SafeRulesResult) :\n        SearchM Q MessageData :=\n      return m!\"{exceptRuleResultToEmoji (\u00b7.toEmoji) result} Safe rules\"\n\n    fmtUnsafe (result : Except Exception RuleResult) : SearchM Q MessageData :=\n      return m!\"{exceptRuleResultToEmoji (\u00b7.toEmoji) result} Unsafe rules\"", "start": [241, 1], "end": [277, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Command.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/aesop/Aesop/Frontend/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Frontend.Parser.elabDeclareAesopRuleSets", "code": "@[command_elab declareAesopRuleSets]\ndef elabDeclareAesopRuleSets : CommandElab\n  | `(command| declare_aesop_rule_sets [ $ids:ident,* ]\n               $[(default := $dflt?:Aesop.bool_lit)]?) => do\n    let rsNames := (ids : Array Ident).map (\u00b7.getId)\n    let dflt := (\u2190 dflt?.mapM (elabBoolLit \u00b7)).getD false\n    rsNames.forM checkRuleSetNotDeclared\n    elabCommand $ \u2190 `(initialize ($(quote rsNames).forM $ declareRuleSetUnchecked (isDefault := $(quote dflt))))\n  | _ => throwUnsupportedSyntax", "start": [18, 1], "end": [26, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend/Tactic.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/aesop/Aesop/Frontend/RuleExpr.lean", "lake-packages/aesop/Aesop/Options.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "elabConfigUnsafe", "code": "unsafe def elabConfigUnsafe (type : Name) (stx : Syntax) : TermElabM \u03b1 :=\n  withRef stx do\n    let e \u2190 withoutModifyingStateWithInfoAndMessages <| withLCtx {} {} <| withSaveInfoContext <| Term.withSynthesize <| withoutErrToSorry do\n      let e \u2190 Term.elabTermEnsuringType stx (Lean.mkConst type)\n      Term.synthesizeSyntheticMVarsNoPostponing\n      instantiateMVars e\n    evalExpr' \u03b1 type e", "start": [61, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "elabOptionsUnsafe", "code": "unsafe def elabOptionsUnsafe : Syntax \u2192 TermElabM Aesop.Options :=\n  elabConfigUnsafe ``Aesop.Options", "start": [69, 1], "end": [70, 35], "kind": "commanddeclaration"}, {"full_name": "elabOptions", "code": "@[implemented_by elabOptionsUnsafe]\nopaque elabOptions : Syntax \u2192 TermElabM Aesop.Options", "start": [72, 1], "end": [73, 54], "kind": "commanddeclaration"}, {"full_name": "elabSimpConfigUnsafe", "code": "unsafe def elabSimpConfigUnsafe : Syntax \u2192 TermElabM Aesop.SimpConfig :=\n  elabConfigUnsafe ``Aesop.SimpConfig", "start": [75, 1], "end": [76, 38], "kind": "commanddeclaration"}, {"full_name": "elabSimpConfig", "code": "@[implemented_by elabSimpConfigUnsafe]\nopaque elabSimpConfig : Syntax \u2192 TermElabM Aesop.SimpConfig", "start": [78, 1], "end": [79, 60], "kind": "commanddeclaration"}, {"full_name": "TacticConfig", "code": "structure TacticConfig where\n  additionalRules : Array RuleExpr\n  erasedRules : Array RuleExpr\n  enabledRuleSets : NameSet\n  options : Aesop.Options\n  simpConfig : Aesop.SimpConfig\n  simpConfigSyntax? : Option Term", "start": [81, 1], "end": [87, 34], "kind": "commanddeclaration"}, {"full_name": "TacticConfig.parse", "code": "def parse (stx : Syntax) : TermElabM TacticConfig :=\n  withRef stx do\n    match stx with\n    | `(tactic| aesop $clauses:Aesop.tactic_clause*) =>\n      clauses.foldlM (addClause false) (\u2190 init false)\n    | `(tactic| aesop? $clauses:Aesop.tactic_clause*) =>\n      clauses.foldlM (addClause true) (\u2190 init true)\n    | _ => throwUnsupportedSyntax\n  where\n    init (traceScript : Bool) : CoreM TacticConfig := return {\n      additionalRules := #[]\n      erasedRules := #[]\n      enabledRuleSets := \u2190 getDefaultRuleSetNames\n      options := { traceScript }\n      simpConfig := {}\n      simpConfigSyntax? := none\n    }\n\n    addClause (traceScript : Bool) (c : TacticConfig) (stx : Syntax) :\n        TermElabM TacticConfig :=\n      withRef stx do\n        match stx with\n        | `(tactic_clause| (add $es:Aesop.rule_expr,*)) => do\n          let rs \u2190 (es : Array Syntax).mapM \u03bb e =>\n            RuleExpr.elab e |>.run ElabOptions.forAdditionalRules\n          return { c with additionalRules := c.additionalRules ++ rs }\n        | `(tactic_clause| (erase $es:Aesop.rule_expr,*)) => do\n          let rs \u2190 (es : Array Syntax).mapM \u03bb e =>\n            RuleExpr.elab e |>.run ElabOptions.forErasing\n          return { c with erasedRules := c.erasedRules ++ rs }\n        | `(tactic_clause| (rule_sets [ $specs:ruleSetSpec,* ])) => do\n          let mut enabledRuleSets := c.enabledRuleSets\n          for spec in (specs : Array Syntax) do\n            match spec with\n            | `(Parser.ruleSetSpec| - $rsName:ident) => do\n              let rsName := RuleSetName.elab rsName\n              unless enabledRuleSets.contains rsName do throwError\n                \"aesop: trying to deactivate rule set '{rsName}', but it is not active\"\n              enabledRuleSets := enabledRuleSets.erase rsName\n            | `(Parser.ruleSetSpec| $rsName:ident) => do\n              let rsName := RuleSetName.elab rsName\n              if enabledRuleSets.contains rsName then throwError\n                \"aesop: rule set '{rsName}' is already active\"\n              enabledRuleSets := enabledRuleSets.insert rsName\n            | _ => throwUnsupportedSyntax\n          return { c with enabledRuleSets }\n        | `(tactic_clause| (options := $t:term)) =>\n          let options \u2190 elabOptions t\n          let options :=\n            { options with traceScript := options.traceScript || traceScript }\n          return { c with options }\n        | `(tactic_clause| (simp_options := $t:term)) =>\n          return {\n            c with\n            simpConfig := \u2190 elabSimpConfig t\n            simpConfigSyntax? := some t\n          }\n        | _ => throwUnsupportedSyntax", "start": [91, 1], "end": [148, 38], "kind": "commanddeclaration"}, {"full_name": "TacticConfig.updateRuleSets", "code": "def updateRuleSets (goal : MVarId) (rss : Aesop.RuleSets) (c : TacticConfig) :\n    MetaM (MVarId \u00d7 Aesop.RuleSets) := do\n  let mut rss := rss\n\n  let mut goal := goal\n  for ruleExpr in c.additionalRules do\n    let (goal', rules) \u2190 ruleExpr.buildAdditionalLocalRules goal\n    goal := goal'\n    for (rule, rsNames) in rules do\n      for rsName in rsNames do\n        rss \u2190 rss.addRuleChecked rsName rule\n\n  for ruleExpr in c.erasedRules do\n    let filters \u2190 ruleExpr.toLocalRuleNameFilters goal\n    for (rsFilter, rFilter) in filters do\n      rss \u2190 rss.eraseRulesChecked rsFilter rFilter\n  return (goal, rss)", "start": [150, 1], "end": [168, 21], "kind": "commanddeclaration"}, {"full_name": "TacticConfig.getRuleSet", "code": "def getRuleSet (goal : MVarId) (c : TacticConfig) :\n    MetaM (MVarId \u00d7 Aesop.RuleSet) := do\n  let rss \u2190 getRuleSets c.enabledRuleSets (includeGlobalSimpTheorems := true)\n  let (goal, rss) \u2190 c.updateRuleSets goal rss\n  return (goal, rss.getMergedRuleSet c.options)", "start": [170, 1], "end": [174, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/Basic.lean", "imports": ["Mathlib/Util/CompileInductive.lean", "Mathlib/Init/ZeroOne.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.bit0_succ_eq", "code": "protected theorem bit0_succ_eq (n : \u2115) : bit0 (succ n) = succ (succ (bit0 n))", "start": [14, 1], "end": [15, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_bit0", "code": "protected theorem zero_lt_bit0 : \u2200 {n : Nat}, n \u2260 0 \u2192 0 < bit0 n", "start": [18, 1], "end": [23, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_bit1", "code": "protected theorem zero_lt_bit1 (n : Nat) : 0 < bit1 n", "start": [26, 1], "end": [27, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_ne_zero", "code": "protected theorem bit0_ne_zero : \u2200 {n : \u2115}, n \u2260 0 \u2192 bit0 n \u2260 0", "start": [30, 1], "end": [35, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_ne_zero", "code": "protected theorem bit1_ne_zero (n : \u2115) : bit1 n \u2260 0", "start": [38, 1], "end": [39, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/MkIffOfInductiveProp.lean", "imports": ["Mathlib/Lean/Meta.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/LeftRight.lean"], "premises": [{"full_name": "Mathlib.Tactic.MkIff.select", "code": "private def select (m n : Nat) (goal : MVarId) : MetaM MVarId :=\n  match m,n with\n  | 0, 0             => pure goal\n  | 0, (_ + 1)       => do let [new_goal] \u2190 Mathlib.Tactic.LeftRight.leftRightMeta `left 0 2 goal\n                                | throwError \"expected only one new goal\"\n                           pure new_goal\n  | (m + 1), (n + 1) => do let [new_goal] \u2190 Mathlib.Tactic.LeftRight.leftRightMeta `right 1 2 goal\n                                | throwError \"expected only one new goal\"\n                           select m n new_goal\n  | _, _             => failure", "start": [33, 1], "end": [44, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.compactRelation", "code": "partial def compactRelation :\n  List Expr \u2192 List (Expr \u00d7 Expr) \u2192 List (Option Expr) \u00d7 List (Expr \u00d7 Expr) \u00d7 (Expr \u2192 Expr)\n| [],    as_ps => ([], as_ps, id)\n| b::bs, as_ps =>\n  match as_ps.span (\u03bb\u27e8_,p\u27e9 => \u00ac p == b) with\n    | (_, []) => let (bs, as_ps', subst) := compactRelation bs as_ps\n        (b::bs, as_ps', subst)\n    | (ps\u2081, (a, _) :: ps\u2082) => let i := fun e \u21a6 e.replaceFVar b a\n      let (bs, as_ps', subst) := compactRelation (bs.map i) ((ps\u2081 ++ ps\u2082).map (\u03bb\u27e8a, p\u27e9 => (a, i p)))\n      (none :: bs, as_ps', i \u2218 subst)", "start": [46, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.updateLambdaBinderInfoD!", "code": "private def updateLambdaBinderInfoD! (e : Expr) : Expr :=\n  match e with\n  | .lam n domain body _ => .lam n domain body .default\n  | _           => panic! \"lambda expected\"", "start": [66, 1], "end": [69, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.mkExistsList", "code": "def mkExistsList (args : List Expr) (inner : Expr) : MetaM Expr :=\nargs.foldrM (\u03bbarg i:Expr => do\n    let t \u2190 inferType arg\n    let l := (\u2190 inferType t).sortLevel!\n    if arg.occurs i || l != Level.zero\n      then pure (mkApp2 (mkConst `Exists [l] : Expr) t\n        (updateLambdaBinderInfoD! <| \u2190mkLambdaFVars #[arg] i))\n      else pure <| mkApp2 (mkConst `And [] : Expr) t i)\n  inner", "start": [71, 1], "end": [81, 8], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.mkOpList", "code": "def mkOpList (op : Expr) (empty : Expr) : List Expr \u2192 Expr\n  | []        => empty\n  | [e]       => e\n  | (e :: es) => mkApp2 op e $ mkOpList op empty es", "start": [83, 1], "end": [88, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.mkAndList", "code": "def mkAndList : List Expr \u2192 Expr := mkOpList (mkConst `And) (mkConst `True)", "start": [90, 1], "end": [91, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.mkOrList", "code": "def mkOrList : List Expr \u2192 Expr := mkOpList (mkConst `Or) (mkConst `False)", "start": [93, 1], "end": [94, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.List.init", "code": "def List.init : List \u03b1 \u2192 List \u03b1\n  | []     => []\n  | [_]    => []\n  | a::l => a::init l", "start": [96, 1], "end": [100, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.Shape", "code": "structure Shape : Type where\n  \n  variablesKept : List Bool\n\n  \n  neqs : Option Nat", "start": [102, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.constrToProp", "code": "def constrToProp (univs : List Level) (params : List Expr) (idxs : List Expr) (c : Name) :\n    MetaM (Shape \u00d7 Expr)  :=\ndo let type := (\u2190 getConstInfo c).instantiateTypeLevelParams univs\n   let type' \u2190 Meta.forallBoundedTelescope type (params.length) fun fvars ty \u21a6 do\n     pure $ ty.replaceFVars fvars params.toArray\n\n   Meta.forallTelescope type' fun fvars ty \u21a6 do\n     let idxs_inst := ty.getAppArgs.toList.drop params.length\n     let (bs, eqs, subst) := compactRelation fvars.toList (idxs.zip idxs_inst)\n     let eqs \u2190 eqs.mapM (\u03bb\u27e8idx, inst\u27e9 => do\n          let ty \u2190 idx.fvarId!.getType\n          let instTy \u2190 inferType inst\n          let u := (\u2190inferType ty).sortLevel!\n          if \u2190isDefEq ty instTy\n          then pure (mkApp3 (mkConst `Eq [u]) ty idx inst)\n          else pure (mkApp4 (mkConst `HEq [u]) ty idx instTy inst))\n     let (n, r) \u2190 match bs.filterMap id, eqs with\n     | [], [] => do\n           pure (some 0, (mkConst `True))\n     | bs', [] => do\n          let t : Expr \u2190 bs'.getLast!.fvarId!.getType\n          let l := (\u2190inferType t).sortLevel!\n          if l == Level.zero then do\n            let r \u2190 mkExistsList (List.init bs') t\n            pure (none, subst r)\n          else do\n            let r \u2190 mkExistsList bs' (mkConst `True)\n            pure (some 0, subst r)\n     | bs', _ => do\n       let r \u2190 mkExistsList bs' (mkAndList eqs)\n       pure (some eqs.length, subst r)\n     pure (\u27e8bs.map Option.isSome, n\u27e9, r)", "start": [130, 1], "end": [164, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.splitThenConstructor", "code": "def splitThenConstructor (mvar : MVarId) (n : Nat) : MetaM Unit :=\nmatch n with\n| 0   => do\n  let (subgoals',_) \u2190 Term.TermElabM.run $ Tactic.run mvar do\n    Tactic.evalTactic (\u2190`(tactic| constructor))\n  let [] := subgoals' | throwError \"expected no subgoals\"\n  pure ()\n| n + 1 => do\n  let (subgoals,_) \u2190 Term.TermElabM.run $ Tactic.run mvar do\n    Tactic.evalTactic (\u2190`(tactic| refine \u27e8?_,?_\u27e9))\n  let [sg1, sg2] := subgoals | throwError \"expected two subgoals\"\n  let (subgoals',_) \u2190 Term.TermElabM.run $ Tactic.run sg1 do\n    Tactic.evalTactic (\u2190`(tactic| constructor))\n  let [] := subgoals' | throwError \"expected no subgoals\"\n  splitThenConstructor sg2 n", "start": [166, 1], "end": [183, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.toCases", "code": "def toCases (mvar : MVarId) (shape : List Shape) : MetaM Unit :=\ndo\n  let \u27e8h, mvar'\u27e9 \u2190 mvar.intro1\n  let subgoals \u2190 mvar'.cases h\n  let _ \u2190 (shape.zip subgoals.toList).enum.mapM fun \u27e8p, \u27e8\u27e8shape, t\u27e9, subgoal\u27e9\u27e9 \u21a6 do\n    let vars := subgoal.fields\n    let si := (shape.zip vars.toList).filterMap (\u03bb \u27e8c,v\u27e9 => if c then some v else none)\n    let mvar'' \u2190 select p (subgoals.size - 1) subgoal.mvarId\n    match t with\n    | none => do\n      let v := vars.get! (shape.length - 1)\n      let mv \u2190 mvar''.existsi (List.init si)\n      mv.assign v\n    | some n => do\n      let mv \u2190 mvar''.existsi si\n      splitThenConstructor mv (n - 1)\n  pure ()", "start": [185, 1], "end": [204, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.nCasesSum", "code": "def nCasesSum (n : Nat) (mvar : MVarId) (h : FVarId) : MetaM (List (FVarId \u00d7 MVarId)) :=\nmatch n with\n| 0 => pure [(h, mvar)]\n| n' + 1 => do\n  let #[sg1, sg2] \u2190 mvar.cases h | throwError \"expected two case subgoals\"\n  let #[Expr.fvar fvar1] \u2190 pure sg1.fields | throwError \"expected fvar\"\n  let #[Expr.fvar fvar2] \u2190 pure sg2.fields | throwError \"expected fvar\"\n  let rest \u2190 nCasesSum n' sg2.mvarId fvar2\n  pure ((fvar1, sg1.mvarId)::rest)", "start": [206, 1], "end": [217, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.nCasesProd", "code": "def nCasesProd (n : Nat) (mvar : MVarId) (h : FVarId) : MetaM (MVarId \u00d7 List FVarId) :=\nmatch n with\n| 0 => pure (mvar, [h])\n| n' + 1 => do\n  let #[sg] \u2190 mvar.cases h | throwError \"expected one case subgoals\"\n  let #[Expr.fvar fvar1, Expr.fvar fvar2] \u2190 pure sg.fields | throwError \"expected fvar\"\n  let (mvar', rest) \u2190 nCasesProd n' sg.mvarId fvar2\n  pure (mvar', fvar1::rest)", "start": [219, 1], "end": [229, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.listBoolMerge", "code": "def listBoolMerge {\u03b1 : Type*} : List Bool \u2192 List \u03b1 \u2192 List (Option \u03b1)\n  | [], _ => []\n  | false :: xs, ys => none :: listBoolMerge xs ys\n  | true :: xs, y :: ys => some y :: listBoolMerge xs ys\n  | true :: _, [] => []", "start": [231, 1], "end": [245, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.toInductive", "code": "def toInductive (mvar : MVarId) (cs : List Name)\n    (gs : List Expr) (s : List Shape) (h : FVarId) :\n    MetaM Unit := do\n  match s.length with\n  | 0       => do let _ \u2190 mvar.cases h\n                  pure ()\n  | (n + 1) => do\n      let subgoals \u2190 nCasesSum n mvar h\n      let _ \u2190 (cs.zip (subgoals.zip s)).mapM $ \u03bb\u27e8constr_name, \u27e8h, mv\u27e9, bs, e\u27e9 => do\n        let n := (bs.filter id).length\n        let (mvar', _fvars) \u2190 match e with\n        | none => nCasesProd (n-1) mv h\n        | some 0 => do let \u27e8mvar', fvars\u27e9 \u2190 nCasesProd n mv h\n                          let mvar'' \u2190 mvar'.tryClear fvars.getLast!\n                          pure \u27e8mvar'', fvars\u27e9\n        | some (e + 1) => do\n           let (mv', fvars) \u2190 nCasesProd n mv h\n           let lastfv := fvars.getLast!\n           let (mv2, fvars') \u2190 nCasesProd e mv' lastfv\n\n           \n           let (_, mv3) \u2190 mv2.revert fvars'.toArray\n           let mv4 \u2190 fvars'.foldlM (\u03bb mv _ => do let \u27e8fv, mv'\u27e9 \u2190 mv.intro1\n                                                 subst mv' fv\n                                   ) mv3\n           pure (mv4, fvars)\n        mvar'.withContext do\n          let fvarIds := (\u2190getLCtx).getFVarIds.toList\n          let gs := fvarIds.take gs.length\n          let hs := (fvarIds.reverse.take n).reverse\n          let m := gs.map some ++ listBoolMerge bs hs\n          let args \u2190 m.mapM (\u03bba => match a with\n                                   | some v => pure $ mkFVar v\n                                   | none => mkFreshExprMVar none)\n          let c \u2190 mkConstWithFreshMVarLevels constr_name\n          let e := mkAppN c args.toArray\n          let t \u2190 inferType e\n          let mt \u2190 mvar'.getType\n          let _ \u2190 isDefEq t mt mvar'.assign e", "start": [247, 1], "end": [290, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.MkIff.mkIffOfInductivePropImpl", "code": "def mkIffOfInductivePropImpl (ind : Name) (rel : Name) (relStx : Syntax) : MetaM Unit := do\n  let .inductInfo inductVal \u2190 getConstInfo ind |\n    throwError \"mk_iff only applies to inductive declarations\"\n  let constrs := inductVal.ctors\n  let params := inductVal.numParams\n  let type := inductVal.type\n\n  let univNames := inductVal.levelParams\n  let univs := univNames.map mkLevelParam\n  \n\n  let (thmTy,shape) \u2190 Meta.forallTelescope type fun fvars ty \u21a6 do\n    if !ty.isProp then throwError \"mk_iff only applies to prop-valued declarations\"\n    let lhs := mkAppN (mkConst ind univs) fvars\n    let fvars' := fvars.toList\n    let shape_rhss \u2190 constrs.mapM (constrToProp univs (fvars'.take params) (fvars'.drop params))\n    let (shape, rhss) := shape_rhss.unzip\n    pure (\u2190mkForallFVars fvars (mkApp2 (mkConst `Iff) lhs (mkOrList rhss)),\n          shape)\n\n  let mvar \u2190 mkFreshExprMVar (some thmTy)\n  let mvarId := mvar.mvarId!\n  let (fvars, mvarId') \u2190 mvarId.intros\n  let [mp, mpr] \u2190 mvarId'.apply (mkConst `Iff.intro) | throwError \"failed to split goal\"\n\n  toCases mp shape\n\n  let \u27e8mprFvar, mpr'\u27e9 \u2190 mpr.intro1\n  toInductive mpr' constrs ((fvars.toList.take params).map .fvar) shape mprFvar\n\n  addDecl $ .thmDecl {\n    name := rel\n    levelParams := univNames\n    type := thmTy\n    value := \u2190 instantiateMVars mvar\n  }\n  addDeclarationRanges rel {\n    range := \u2190 getDeclarationRange (\u2190 getRef)\n    selectionRange := \u2190 getDeclarationRange relStx\n  }\n  addConstInfo relStx rel", "start": [292, 1], "end": [335, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Use.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.applyTheConstructor", "code": "def applyTheConstructor (mvarId : MVarId) :\n    MetaM (List MVarId \u00d7 List MVarId \u00d7 List MVarId) := do\n  mvarId.withContext do\n    mvarId.checkNotAssigned `constructor\n    let target \u2190 mvarId.getType'\n    matchConstInduct target.getAppFn\n      (fun _ => throwTacticEx `constructor mvarId\n                  m!\"target is not an inductive datatype{indentExpr target}\")\n      fun ival us => do\n        match ival.ctors with\n        | [ctor] =>\n          let cinfo \u2190 getConstInfoCtor ctor\n          let ctorConst := Lean.mkConst ctor us\n          let (args, binderInfos, _) \u2190 forallMetaTelescopeReducing (\u2190 inferType ctorConst)\n          let mut explicit := #[]\n          let mut implicit := #[]\n          let mut insts := #[]\n          for arg in args, binderInfo in binderInfos, i in [0:args.size] do\n            if cinfo.numParams \u2264 i \u2227 binderInfo.isExplicit then\n              explicit := explicit.push arg.mvarId!\n            else\n              implicit := implicit.push arg.mvarId!\n              if binderInfo.isInstImplicit then\n                insts := insts.push arg.mvarId!\n          let e := mkAppN ctorConst args\n          let eType \u2190 inferType e\n          unless (\u2190 withAssignableSyntheticOpaque <| isDefEq eType target) do\n            throwError m!\"type mismatch{indentExpr e}\\n{\u2190 mkHasTypeButIsExpectedMsg eType target}\"\n          mvarId.assign e\n          return (explicit.toList, implicit.toList, insts.toList)\n        | _ => throwTacticEx `constructor mvarId\n                m!\"target inductive type does not have exactly one constructor{indentExpr target}\"", "start": [28, 1], "end": [71, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.useLoop", "code": "partial\ndef useLoop (eager : Bool) (gs : List MVarId) (args : List Term) (acc insts : List MVarId) :\n    TermElabM (List MVarId \u00d7 List MVarId \u00d7 List MVarId) := do\n  trace[tactic.use] \"gs = {gs}\\nargs = {args}\\nacc = {acc}\"\n  match gs, args with\n  | gs, [] =>\n    return (gs, acc, insts)\n  | [], arg :: _ =>\n    throwErrorAt arg \"too many arguments supplied to `use`\"\n  | g :: gs', arg :: args' => g.withContext do\n    if \u2190 g.isAssigned then\n      let e \u2190 Term.elabTermEnsuringType arg (\u2190 g.getType)\n      unless \u2190 isDefEq e (.mvar g) do\n        throwErrorAt arg\n          \"argument is not definitionally equal to inferred value{indentExpr (.mvar g)}\"\n      return \u2190 useLoop eager gs' args' acc insts\n    let refineArg \u2190 `(tactic| refine ($arg : $(\u2190 Term.exprToSyntax (\u2190 g.getType))))\n    if eager then\n      if let some newGoals \u2190 observing? (run g do withoutRecover <| evalTactic refineArg) then\n        return \u2190 useLoop eager gs' args' (acc ++ newGoals) insts\n    if eager || gs'.isEmpty then\n      if let some (expl, impl, insts') \u2190 observing? do\n                try applyTheConstructor g\n                catch e => trace[tactic.use] \"Constructor. {e.toMessageData}\"; throw e then\n        trace[tactic.use] \"expl.length = {expl.length}, impl.length = {impl.length}\"\n        return \u2190 useLoop eager (expl ++ gs') args (acc ++ impl) (insts ++ insts')\n    let newGoals \u2190 run g do evalTactic refineArg\n    useLoop eager gs' args' (acc ++ newGoals) insts", "start": [73, 1], "end": [114, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.runUse", "code": "def runUse (eager : Bool) (discharger : TacticM Unit) (args : List Term) : TacticM Unit := do\n  let egoals \u2190 focus do\n    let (egoals, acc, insts) \u2190 useLoop eager (\u2190 getGoals) args [] []\n    for inst in insts do\n      if !(\u2190 inst.isAssigned) then\n        discard <| inst.withContext <| observing? do inst.assign (\u2190 synthInstance (\u2190 inst.getType))\n    setGoals (egoals ++ acc)\n    pruneSolvedGoals\n    pure egoals\n  for g in egoals do\n    if !(\u2190 g.isAssigned) then\n      g.withContext do\n        if \u2190 isProp (\u2190 g.getType) then\n          trace[tactic.use] \"running discharger on {g}\"\n          discard <| run g discharger", "start": [116, 1], "end": [135, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.mkUseDischarger", "code": "def mkUseDischarger (discharger? : Option (TSyntax ``Parser.Tactic.discharger)) :\n    TacticM (TacticM Unit) := do\n  let discharger \u2190\n    if let some disch := discharger? then\n      match disch with\n      | `(Parser.Tactic.discharger| ($_ := $d)) => `(tactic| ($d))\n      | _ => throwUnsupportedSyntax\n    else\n      `(tactic| try with_reducible use_discharger)\n  return evalTactic discharger", "start": [147, 1], "end": [158, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Propext.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "imp_congr_eq", "code": "theorem imp_congr_eq {a b c d : Prop} (h\u2081 : a = c) (h\u2082 : b = d) : (a \u2192 b) = (c \u2192 d)", "start": [19, 1], "end": [20, 42], "kind": "commanddeclaration"}, {"full_name": "imp_congr_ctx_eq", "code": "theorem imp_congr_ctx_eq {a b c d : Prop} (h\u2081 : a = c) (h\u2082 : c \u2192 b = d) : (a \u2192 b) = (c \u2192 d)", "start": [22, 1], "end": [23, 60], "kind": "commanddeclaration"}, {"full_name": "eq_true_intro", "code": "theorem eq_true_intro {a : Prop} (h : a) : a = True", "start": [25, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "eq_false_intro", "code": "theorem eq_false_intro {a : Prop} (h : \u00aca) : a = False", "start": [28, 1], "end": [29, 30], "kind": "commanddeclaration"}, {"full_name": "Iff.to_eq", "code": "theorem Iff.to_eq {a b : Prop} (h : a \u2194 b) : a = b", "start": [31, 1], "end": [32, 12], "kind": "commanddeclaration"}, {"full_name": "iff_eq_eq", "code": "theorem iff_eq_eq {a b : Prop} : (a \u2194 b) = (a = b)", "start": [34, 1], "end": [35, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Basic.lean", "imports": ["Mathlib/Tactic/SimpRw.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/Data/Prod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Order/LinearOrder.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Tactic/Convert.lean"], "premises": [{"full_name": "le_trans'", "code": "theorem le_trans' : b \u2264 c \u2192 a \u2264 b \u2192 a \u2264 c", "start": [77, 1], "end": [78, 16], "kind": "commanddeclaration"}, {"full_name": "lt_trans'", "code": "theorem lt_trans' : b < c \u2192 a < b \u2192 a < c", "start": [81, 1], "end": [82, 16], "kind": "commanddeclaration"}, {"full_name": "lt_of_le_of_lt'", "code": "theorem lt_of_le_of_lt' : b \u2264 c \u2192 a < b \u2192 a < c", "start": [85, 1], "end": [86, 22], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_of_le'", "code": "theorem lt_of_lt_of_le' : b < c \u2192 a \u2264 b \u2192 a < c", "start": [89, 1], "end": [90, 22], "kind": "commanddeclaration"}, {"full_name": "ge_antisymm", "code": "theorem ge_antisymm : a \u2264 b \u2192 b \u2264 a \u2192 b = a", "start": [99, 1], "end": [100, 19], "kind": "commanddeclaration"}, {"full_name": "lt_of_le_of_ne'", "code": "theorem lt_of_le_of_ne' : a \u2264 b \u2192 b \u2260 a \u2192 a < b", "start": [103, 1], "end": [103, 89], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_of_le", "code": "theorem Ne.lt_of_le : a \u2260 b \u2192 a \u2264 b \u2192 a < b", "start": [106, 1], "end": [107, 22], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_of_le'", "code": "theorem Ne.lt_of_le' : b \u2260 a \u2192 a \u2264 b \u2192 a < b", "start": [110, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "LE.le.trans", "code": "alias LE.le.trans := le_trans", "start": [120, 1], "end": [120, 30], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.trans'", "code": "alias LE.le.trans' := le_trans'", "start": [122, 1], "end": [122, 32], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.trans_lt", "code": "alias LE.le.trans_lt := lt_of_le_of_lt", "start": [124, 1], "end": [124, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.trans_lt'", "code": "alias LE.le.trans_lt' := lt_of_le_of_lt'", "start": [126, 1], "end": [126, 41], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.antisymm", "code": "alias LE.le.antisymm := le_antisymm", "start": [128, 1], "end": [128, 36], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.antisymm'", "code": "alias LE.le.antisymm' := ge_antisymm", "start": [130, 1], "end": [130, 37], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.lt_of_ne", "code": "alias LE.le.lt_of_ne := lt_of_le_of_ne", "start": [132, 1], "end": [132, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.lt_of_ne'", "code": "alias LE.le.lt_of_ne' := lt_of_le_of_ne'", "start": [134, 1], "end": [134, 41], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.lt_of_not_le", "code": "alias LE.le.lt_of_not_le := lt_of_le_not_le", "start": [136, 1], "end": [136, 44], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.lt_or_eq", "code": "alias LE.le.lt_or_eq := lt_or_eq_of_le", "start": [138, 1], "end": [138, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.lt_or_eq_dec", "code": "alias LE.le.lt_or_eq_dec := Decidable.lt_or_eq_of_le", "start": [140, 1], "end": [140, 53], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.le", "code": "alias LT.lt.le := le_of_lt", "start": [142, 1], "end": [142, 27], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans", "code": "alias LT.lt.trans := lt_trans", "start": [144, 1], "end": [144, 30], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans'", "code": "alias LT.lt.trans' := lt_trans'", "start": [146, 1], "end": [146, 32], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans_le", "code": "alias LT.lt.trans_le := lt_of_lt_of_le", "start": [148, 1], "end": [148, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans_le'", "code": "alias LT.lt.trans_le' := lt_of_lt_of_le'", "start": [150, 1], "end": [150, 41], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.ne", "code": "alias LT.lt.ne := ne_of_lt", "start": [152, 1], "end": [152, 27], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.asymm", "code": "alias LT.lt.asymm := lt_asymm", "start": [155, 1], "end": [155, 30], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.not_lt", "code": "alias LT.lt.not_lt := lt_asymm", "start": [157, 1], "end": [157, 31], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.le", "code": "alias Eq.le := le_of_eq", "start": [159, 1], "end": [159, 24], "kind": "stdtacticaliasalias"}, {"full_name": "le_rfl", "code": "theorem le_rfl : a \u2264 a", "start": [169, 1], "end": [171, 12], "kind": "commanddeclaration"}, {"full_name": "lt_self_iff_false", "code": "@[simp]\ntheorem lt_self_iff_false (x : \u03b1) : x < x \u2194 False", "start": [174, 1], "end": [176, 28], "kind": "commanddeclaration"}, {"full_name": "le_of_le_of_eq", "code": "theorem le_of_le_of_eq (hab : a \u2264 b) (hbc : b = c) : a \u2264 c", "start": [179, 1], "end": [180, 19], "kind": "commanddeclaration"}, {"full_name": "le_of_eq_of_le", "code": "theorem le_of_eq_of_le (hab : a = b) (hbc : b \u2264 c) : a \u2264 c", "start": [183, 1], "end": [184, 19], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_of_eq", "code": "theorem lt_of_lt_of_eq (hab : a < b) (hbc : b = c) : a < c", "start": [187, 1], "end": [188, 22], "kind": "commanddeclaration"}, {"full_name": "lt_of_eq_of_lt", "code": "theorem lt_of_eq_of_lt (hab : a = b) (hbc : b < c) : a < c", "start": [191, 1], "end": [192, 22], "kind": "commanddeclaration"}, {"full_name": "le_of_le_of_eq'", "code": "theorem le_of_le_of_eq' : b \u2264 c \u2192 a = b \u2192 a \u2264 c", "start": [195, 1], "end": [196, 22], "kind": "commanddeclaration"}, {"full_name": "le_of_eq_of_le'", "code": "theorem le_of_eq_of_le' : b = c \u2192 a \u2264 b \u2192 a \u2264 c", "start": [199, 1], "end": [200, 22], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_of_eq'", "code": "theorem lt_of_lt_of_eq' : b < c \u2192 a = b \u2192 a < c", "start": [203, 1], "end": [204, 22], "kind": "commanddeclaration"}, {"full_name": "lt_of_eq_of_lt'", "code": "theorem lt_of_eq_of_lt' : b = c \u2192 a < b \u2192 a < c", "start": [207, 1], "end": [208, 22], "kind": "commanddeclaration"}, {"full_name": "LE.le.trans_eq", "code": "alias LE.le.trans_eq := le_of_le_of_eq", "start": [211, 1], "end": [211, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.trans_eq'", "code": "alias LE.le.trans_eq' := le_of_le_of_eq'", "start": [213, 1], "end": [213, 41], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans_eq", "code": "alias LT.lt.trans_eq := lt_of_lt_of_eq", "start": [215, 1], "end": [215, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.trans_eq'", "code": "alias LT.lt.trans_eq' := lt_of_lt_of_eq'", "start": [217, 1], "end": [217, 41], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.trans_le", "code": "alias Eq.trans_le := le_of_eq_of_le", "start": [219, 1], "end": [219, 36], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.trans_ge", "code": "alias Eq.trans_ge := le_of_eq_of_le'", "start": [222, 1], "end": [222, 37], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.trans_lt", "code": "alias Eq.trans_lt := lt_of_eq_of_lt", "start": [225, 1], "end": [225, 36], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.trans_gt", "code": "alias Eq.trans_gt := lt_of_eq_of_lt'", "start": [228, 1], "end": [228, 37], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.ge", "code": "protected theorem ge (h : x = y) : y \u2264 x", "start": [237, 1], "end": [240, 12], "kind": "commanddeclaration"}, {"full_name": "Eq.not_lt", "code": "theorem not_lt (h : x = y) : \u00acx < y", "start": [243, 1], "end": [243, 56], "kind": "commanddeclaration"}, {"full_name": "Eq.not_gt", "code": "theorem not_gt (h : x = y) : \u00acy < x", "start": [246, 1], "end": [247, 16], "kind": "commanddeclaration"}, {"full_name": "le_of_subsingleton", "code": "@[simp] lemma le_of_subsingleton [Subsingleton \u03b1] : a \u2264 b := (Subsingleton.elim a b).le", "start": [257, 1], "end": [257, 88], "kind": "mathlibtacticlemma"}, {"full_name": "not_lt_of_subsingleton", "code": "lemma not_lt_of_subsingleton [Subsingleton \u03b1] : \u00aca < b := (Subsingleton.elim a b).not_lt", "start": [260, 1], "end": [260, 89], "kind": "mathlibtacticlemma"}, {"full_name": "LE.le.ge", "code": "protected theorem ge [LE \u03b1] {x y : \u03b1} (h : x \u2264 y) : y \u2265 x", "start": [268, 1], "end": [269, 4], "kind": "commanddeclaration"}, {"full_name": "LE.le.lt_iff_ne", "code": "theorem lt_iff_ne (h : a \u2264 b) : a < b \u2194 a \u2260 b", "start": [276, 1], "end": [277, 29], "kind": "commanddeclaration"}, {"full_name": "LE.le.gt_iff_ne", "code": "theorem gt_iff_ne (h : a \u2264 b) : a < b \u2194 b \u2260 a", "start": [280, 1], "end": [281, 35], "kind": "commanddeclaration"}, {"full_name": "LE.le.not_lt_iff_eq", "code": "theorem not_lt_iff_eq (h : a \u2264 b) : \u00aca < b \u2194 a = b", "start": [284, 1], "end": [285, 23], "kind": "commanddeclaration"}, {"full_name": "LE.le.not_gt_iff_eq", "code": "theorem not_gt_iff_eq (h : a \u2264 b) : \u00aca < b \u2194 b = a", "start": [288, 1], "end": [289, 23], "kind": "commanddeclaration"}, {"full_name": "LE.le.le_iff_eq", "code": "theorem le_iff_eq (h : a \u2264 b) : b \u2264 a \u2194 b = a", "start": [292, 1], "end": [293, 34], "kind": "commanddeclaration"}, {"full_name": "LE.le.ge_iff_eq", "code": "theorem ge_iff_eq (h : a \u2264 b) : b \u2264 a \u2194 a = b", "start": [296, 1], "end": [297, 22], "kind": "commanddeclaration"}, {"full_name": "LE.le.lt_or_le", "code": "theorem lt_or_le [LinearOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) (c : \u03b1) : a < c \u2228 c \u2264 b", "start": [302, 1], "end": [303, 49], "kind": "commanddeclaration"}, {"full_name": "LE.le.le_or_lt", "code": "theorem le_or_lt [LinearOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) (c : \u03b1) : a \u2264 c \u2228 c < b", "start": [306, 1], "end": [307, 55], "kind": "commanddeclaration"}, {"full_name": "LE.le.le_or_le", "code": "theorem le_or_le [LinearOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) (c : \u03b1) : a \u2264 c \u2228 c \u2264 b", "start": [310, 1], "end": [311, 58], "kind": "commanddeclaration"}, {"full_name": "LT.lt.gt", "code": "protected theorem gt [LT \u03b1] {x y : \u03b1} (h : x < y) : y > x", "start": [320, 1], "end": [321, 4], "kind": "commanddeclaration"}, {"full_name": "LT.lt.false", "code": "protected theorem false [Preorder \u03b1] {x : \u03b1} : x < x \u2192 False", "start": [324, 1], "end": [325, 14], "kind": "commanddeclaration"}, {"full_name": "LT.lt.ne'", "code": "theorem ne' [Preorder \u03b1] {x y : \u03b1} (h : x < y) : y \u2260 x", "start": [328, 1], "end": [329, 12], "kind": "commanddeclaration"}, {"full_name": "LT.lt.lt_or_lt", "code": "theorem lt_or_lt [LinearOrder \u03b1] {x y : \u03b1} (h : x < y) (z : \u03b1) : x < z \u2228 z < y", "start": [332, 1], "end": [333, 62], "kind": "commanddeclaration"}, {"full_name": "GE.ge.le", "code": "protected theorem GE.ge.le [LE \u03b1] {x y : \u03b1} (h : x \u2265 y) : y \u2264 x", "start": [340, 1], "end": [341, 4], "kind": "commanddeclaration"}, {"full_name": "GT.gt.lt", "code": "protected theorem GT.gt.lt [LT \u03b1] {x y : \u03b1} (h : x > y) : y < x", "start": [346, 1], "end": [347, 4], "kind": "commanddeclaration"}, {"full_name": "ge_of_eq", "code": "theorem ge_of_eq [Preorder \u03b1] {a b : \u03b1} (h : a = b) : a \u2265 b", "start": [352, 1], "end": [353, 7], "kind": "commanddeclaration"}, {"full_name": "ge_iff_le", "code": "@[simp]\ntheorem ge_iff_le [LE \u03b1] {a b : \u03b1} : a \u2265 b \u2194 b \u2264 a", "start": [358, 1], "end": [360, 10], "kind": "commanddeclaration"}, {"full_name": "gt_iff_lt", "code": "@[simp]\ntheorem gt_iff_lt [LT \u03b1] {a b : \u03b1} : a > b \u2194 b < a", "start": [365, 1], "end": [367, 10], "kind": "commanddeclaration"}, {"full_name": "not_le_of_lt", "code": "theorem not_le_of_lt [Preorder \u03b1] {a b : \u03b1} (h : a < b) : \u00acb \u2264 a", "start": [370, 1], "end": [371, 28], "kind": "commanddeclaration"}, {"full_name": "LT.lt.not_le", "code": "alias LT.lt.not_le := not_le_of_lt", "start": [374, 1], "end": [374, 35], "kind": "stdtacticaliasalias"}, {"full_name": "not_lt_of_le", "code": "theorem not_lt_of_le [Preorder \u03b1] {a b : \u03b1} (h : a \u2264 b) : \u00acb < a", "start": [376, 1], "end": [376, 91], "kind": "commanddeclaration"}, {"full_name": "LE.le.not_lt", "code": "alias LE.le.not_lt := not_lt_of_le", "start": [379, 1], "end": [379, 35], "kind": "stdtacticaliasalias"}, {"full_name": "ne_of_not_le", "code": "theorem ne_of_not_le [Preorder \u03b1] {a b : \u03b1} (h : \u00aca \u2264 b) : a \u2260 b", "start": [381, 1], "end": [381, 95], "kind": "commanddeclaration"}, {"full_name": "Decidable.le_iff_eq_or_lt", "code": "protected theorem Decidable.le_iff_eq_or_lt [PartialOrder \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] {a b : \u03b1} :\n    a \u2264 b \u2194 a = b \u2228 a < b", "start": [385, 1], "end": [387, 42], "kind": "commanddeclaration"}, {"full_name": "le_iff_eq_or_lt", "code": "theorem le_iff_eq_or_lt [PartialOrder \u03b1] {a b : \u03b1} : a \u2264 b \u2194 a = b \u2228 a < b", "start": [390, 1], "end": [391, 32], "kind": "commanddeclaration"}, {"full_name": "lt_iff_le_and_ne", "code": "theorem lt_iff_le_and_ne [PartialOrder \u03b1] {a b : \u03b1} : a < b \u2194 a \u2264 b \u2227 a \u2260 b", "start": [394, 1], "end": [395, 68], "kind": "commanddeclaration"}, {"full_name": "eq_iff_not_lt_of_le", "code": "theorem eq_iff_not_lt_of_le {\u03b1} [PartialOrder \u03b1] {x y : \u03b1} : x \u2264 y \u2192 y = x \u2194 \u00acx < y", "start": [398, 1], "end": [399, 61], "kind": "commanddeclaration"}, {"full_name": "Decidable.eq_iff_le_not_lt", "code": "protected theorem Decidable.eq_iff_le_not_lt [PartialOrder \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] {a b : \u03b1} :\n    a = b \u2194 a \u2264 b \u2227 \u00aca < b", "start": [403, 1], "end": [406, 80], "kind": "commanddeclaration"}, {"full_name": "eq_iff_le_not_lt", "code": "theorem eq_iff_le_not_lt [PartialOrder \u03b1] {a b : \u03b1} : a = b \u2194 a \u2264 b \u2227 \u00aca < b", "start": [409, 1], "end": [411, 29], "kind": "commanddeclaration"}, {"full_name": "eq_or_lt_of_le", "code": "theorem eq_or_lt_of_le [PartialOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) : a = b \u2228 a < b", "start": [414, 1], "end": [415, 18], "kind": "commanddeclaration"}, {"full_name": "eq_or_gt_of_le", "code": "theorem eq_or_gt_of_le [PartialOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) : b = a \u2228 a < b", "start": [418, 1], "end": [419, 33], "kind": "commanddeclaration"}, {"full_name": "gt_or_eq_of_le", "code": "theorem gt_or_eq_of_le [PartialOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) : a < b \u2228 b = a", "start": [422, 1], "end": [423, 26], "kind": "commanddeclaration"}, {"full_name": "LE.le.eq_or_lt_dec", "code": "alias LE.le.eq_or_lt_dec := Decidable.eq_or_lt_of_le", "start": [426, 1], "end": [426, 53], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.eq_or_lt", "code": "alias LE.le.eq_or_lt := eq_or_lt_of_le", "start": [428, 1], "end": [428, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.eq_or_gt", "code": "alias LE.le.eq_or_gt := eq_or_gt_of_le", "start": [430, 1], "end": [430, 39], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.gt_or_eq", "code": "alias LE.le.gt_or_eq := gt_or_eq_of_le", "start": [432, 1], "end": [432, 39], "kind": "stdtacticaliasalias"}, {"full_name": "eq_of_le_of_not_lt", "code": "theorem eq_of_le_of_not_lt [PartialOrder \u03b1] {a b : \u03b1} (hab : a \u2264 b) (hba : \u00aca < b) : a = b", "start": [437, 1], "end": [438, 33], "kind": "commanddeclaration"}, {"full_name": "eq_of_ge_of_not_gt", "code": "theorem eq_of_ge_of_not_gt [PartialOrder \u03b1] {a b : \u03b1} (hab : a \u2264 b) (hba : \u00aca < b) : b = a", "start": [441, 1], "end": [442, 40], "kind": "commanddeclaration"}, {"full_name": "LE.le.eq_of_not_lt", "code": "alias LE.le.eq_of_not_lt := eq_of_le_of_not_lt", "start": [445, 1], "end": [445, 47], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.eq_of_not_gt", "code": "alias LE.le.eq_of_not_gt := eq_of_ge_of_not_gt", "start": [447, 1], "end": [447, 47], "kind": "stdtacticaliasalias"}, {"full_name": "Ne.le_iff_lt", "code": "theorem Ne.le_iff_lt [PartialOrder \u03b1] {a b : \u03b1} (h : a \u2260 b) : a \u2264 b \u2194 a < b", "start": [449, 1], "end": [450, 47], "kind": "commanddeclaration"}, {"full_name": "Ne.not_le_or_not_le", "code": "theorem Ne.not_le_or_not_le [PartialOrder \u03b1] {a b : \u03b1} (h : a \u2260 b) : \u00aca \u2264 b \u2228 \u00acb \u2264 a", "start": [453, 1], "end": [454, 42], "kind": "commanddeclaration"}, {"full_name": "Decidable.ne_iff_lt_iff_le", "code": "protected theorem Decidable.ne_iff_lt_iff_le [PartialOrder \u03b1] [DecidableEq \u03b1] {a b : \u03b1} :\n    (a \u2260 b \u2194 a < b) \u2194 a \u2264 b", "start": [458, 1], "end": [460, 95], "kind": "commanddeclaration"}, {"full_name": "ne_iff_lt_iff_le", "code": "@[simp]\ntheorem ne_iff_lt_iff_le [PartialOrder \u03b1] {a b : \u03b1} : (a \u2260 b \u2194 a < b) \u2194 a \u2264 b", "start": [463, 1], "end": [466, 29], "kind": "commanddeclaration"}, {"full_name": "min_def'", "code": "theorem min_def' [LinearOrder \u03b1] (a b : \u03b1) : min a b = if b \u2264 a then b else a", "start": [470, 1], "end": [475, 49], "kind": "commanddeclaration"}, {"full_name": "max_def'", "code": "theorem max_def' [LinearOrder \u03b1] (a b : \u03b1) : max a b = if b \u2264 a then a else b", "start": [480, 1], "end": [485, 49], "kind": "commanddeclaration"}, {"full_name": "lt_of_not_le", "code": "theorem lt_of_not_le [LinearOrder \u03b1] {a b : \u03b1} (h : \u00acb \u2264 a) : a < b", "start": [488, 1], "end": [489, 50], "kind": "commanddeclaration"}, {"full_name": "lt_iff_not_le", "code": "theorem lt_iff_not_le [LinearOrder \u03b1] {x y : \u03b1} : x < y \u2194 \u00acy \u2264 x", "start": [492, 1], "end": [493, 31], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_or_lt", "code": "theorem Ne.lt_or_lt [LinearOrder \u03b1] {x y : \u03b1} (h : x \u2260 y) : x < y \u2228 y < x", "start": [496, 1], "end": [497, 19], "kind": "commanddeclaration"}, {"full_name": "lt_or_lt_iff_ne", "code": "@[simp]\ntheorem lt_or_lt_iff_ne [LinearOrder \u03b1] {x y : \u03b1} : x < y \u2228 y < x \u2194 x \u2260 y", "start": [500, 1], "end": [503, 23], "kind": "commanddeclaration"}, {"full_name": "not_lt_iff_eq_or_lt", "code": "theorem not_lt_iff_eq_or_lt [LinearOrder \u03b1] {a b : \u03b1} : \u00aca < b \u2194 a = b \u2228 b < a", "start": [506, 1], "end": [507, 78], "kind": "commanddeclaration"}, {"full_name": "exists_ge_of_linear", "code": "theorem exists_ge_of_linear [LinearOrder \u03b1] (a b : \u03b1) : \u2203 c, a \u2264 c \u2227 b \u2264 c", "start": [510, 1], "end": [513, 31], "kind": "commanddeclaration"}, {"full_name": "lt_imp_lt_of_le_imp_le", "code": "theorem lt_imp_lt_of_le_imp_le {\u03b2} [LinearOrder \u03b1] [Preorder \u03b2] {a b : \u03b1} {c d : \u03b2}\n    (H : a \u2264 b \u2192 c \u2264 d) (h : d < c) : b < a", "start": [516, 1], "end": [518, 40], "kind": "commanddeclaration"}, {"full_name": "le_imp_le_iff_lt_imp_lt", "code": "theorem le_imp_le_iff_lt_imp_lt {\u03b2} [LinearOrder \u03b1] [LinearOrder \u03b2] {a b : \u03b1} {c d : \u03b2} :\n    a \u2264 b \u2192 c \u2264 d \u2194 d < c \u2192 b < a", "start": [521, 1], "end": [523, 51], "kind": "commanddeclaration"}, {"full_name": "lt_iff_lt_of_le_iff_le'", "code": "theorem lt_iff_lt_of_le_iff_le' {\u03b2} [Preorder \u03b1] [Preorder \u03b2] {a b : \u03b1} {c d : \u03b2}\n    (H : a \u2264 b \u2194 c \u2264 d) (H' : b \u2264 a \u2194 d \u2264 c) : b < a \u2194 d < c", "start": [526, 1], "end": [528, 85], "kind": "commanddeclaration"}, {"full_name": "lt_iff_lt_of_le_iff_le", "code": "theorem lt_iff_lt_of_le_iff_le {\u03b2} [LinearOrder \u03b1] [LinearOrder \u03b2] {a b : \u03b1} {c d : \u03b2}\n    (H : a \u2264 b \u2194 c \u2264 d) : b < a \u2194 d < c", "start": [531, 1], "end": [533, 53], "kind": "commanddeclaration"}, {"full_name": "le_iff_le_iff_lt_iff_lt", "code": "theorem le_iff_le_iff_lt_iff_lt {\u03b2} [LinearOrder \u03b1] [LinearOrder \u03b2] {a b : \u03b1} {c d : \u03b2} :\n    (a \u2264 b \u2194 c \u2264 d) \u2194 (b < a \u2194 d < c)", "start": [536, 1], "end": [538, 87], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_le_iff", "code": "theorem eq_of_forall_le_iff [PartialOrder \u03b1] {a b : \u03b1} (H : \u2200 c, c \u2264 a \u2194 c \u2264 b) : a = b", "start": [541, 1], "end": [542, 45], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_le", "code": "theorem le_of_forall_le [Preorder \u03b1] {a b : \u03b1} (H : \u2200 c, c \u2264 a \u2192 c \u2264 b) : a \u2264 b", "start": [545, 1], "end": [546, 13], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_le'", "code": "theorem le_of_forall_le' [Preorder \u03b1] {a b : \u03b1} (H : \u2200 c, a \u2264 c \u2192 b \u2264 c) : b \u2264 a", "start": [549, 1], "end": [550, 13], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_lt", "code": "theorem le_of_forall_lt [LinearOrder \u03b1] {a b : \u03b1} (H : \u2200 c, c < a \u2192 c < b) : a \u2264 b", "start": [553, 1], "end": [554, 43], "kind": "commanddeclaration"}, {"full_name": "forall_lt_iff_le", "code": "theorem forall_lt_iff_le [LinearOrder \u03b1] {a b : \u03b1} : (\u2200 \u2983c\u2984, c < a \u2192 c < b) \u2194 a \u2264 b", "start": [557, 1], "end": [558, 56], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_lt'", "code": "theorem le_of_forall_lt' [LinearOrder \u03b1] {a b : \u03b1} (H : \u2200 c, a < c \u2192 b < c) : b \u2264 a", "start": [561, 1], "end": [562, 43], "kind": "commanddeclaration"}, {"full_name": "forall_lt_iff_le'", "code": "theorem forall_lt_iff_le' [LinearOrder \u03b1] {a b : \u03b1} : (\u2200 \u2983c\u2984, a < c \u2192 b < c) \u2194 b \u2264 a", "start": [565, 1], "end": [566, 57], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_ge_iff", "code": "theorem eq_of_forall_ge_iff [PartialOrder \u03b1] {a b : \u03b1} (H : \u2200 c, a \u2264 c \u2194 b \u2264 c) : a = b", "start": [569, 1], "end": [570, 45], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_lt_iff", "code": "theorem eq_of_forall_lt_iff [LinearOrder \u03b1] {a b : \u03b1} (h : \u2200 c, c < a \u2194 c < b) : a = b", "start": [573, 1], "end": [574, 80], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_gt_iff", "code": "theorem eq_of_forall_gt_iff [LinearOrder \u03b1] {a b : \u03b1} (h : \u2200 c, a < c \u2194 b < c) : a = b", "start": [577, 1], "end": [578, 82], "kind": "commanddeclaration"}, {"full_name": "rel_imp_eq_of_rel_imp_le", "code": "theorem rel_imp_eq_of_rel_imp_le [PartialOrder \u03b2] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsSymm \u03b1 r] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 a b, r a b \u2192 f a \u2264 f b) {a b : \u03b1} : r a b \u2192 f a = f b", "start": [581, 1], "end": [584, 46], "kind": "commanddeclaration"}, {"full_name": "le_implies_le_of_le_of_le", "code": "theorem le_implies_le_of_le_of_le {a b c d : \u03b1} [Preorder \u03b1] (hca : c \u2264 a) (hbd : b \u2264 d) :\n    a \u2264 b \u2192 c \u2264 d", "start": [587, 1], "end": [590, 38], "kind": "commanddeclaration"}, {"full_name": "commutative_of_le", "code": "theorem commutative_of_le {f : \u03b2 \u2192 \u03b2 \u2192 \u03b1} (comm : \u2200 a b, f a b \u2264 f b a) : \u2200 a b, f a b = f b a", "start": [597, 1], "end": [600, 44], "kind": "commanddeclaration"}, {"full_name": "associative_of_commutative_of_le", "code": "theorem associative_of_commutative_of_le {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} (comm : Commutative f)\n    (assoc : \u2200 a b c, f (f a b) c \u2264 f a (f b c)) : Associative f", "start": [603, 1], "end": [609, 22], "kind": "commanddeclaration"}, {"full_name": "Preorder.toLE_injective", "code": "@[ext]\ntheorem Preorder.toLE_injective {\u03b1 : Type*} : Function.Injective (@Preorder.toLE \u03b1)", "start": [614, 1], "end": [625, 10], "kind": "commanddeclaration"}, {"full_name": "PartialOrder.toPreorder_injective", "code": "@[ext]\ntheorem PartialOrder.toPreorder_injective {\u03b1 : Type*} :\n    Function.Injective (@PartialOrder.toPreorder \u03b1)", "start": [628, 1], "end": [634, 8], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.toPartialOrder_injective", "code": "@[ext]\ntheorem LinearOrder.toPartialOrder_injective {\u03b1 : Type*} :\n    Function.Injective (@LinearOrder.toPartialOrder \u03b1)", "start": [637, 1], "end": [664, 10], "kind": "commanddeclaration"}, {"full_name": "Preorder.ext", "code": "theorem Preorder.ext {\u03b1} {A B : Preorder \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) : A = B", "start": [667, 1], "end": [670, 14], "kind": "commanddeclaration"}, {"full_name": "PartialOrder.ext", "code": "theorem PartialOrder.ext {\u03b1} {A B : PartialOrder \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) : A = B", "start": [673, 1], "end": [676, 14], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.ext", "code": "theorem LinearOrder.ext {\u03b1} {A B : LinearOrder \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) : A = B", "start": [679, 1], "end": [682, 14], "kind": "commanddeclaration"}, {"full_name": "Order.Preimage", "code": "@[simp]\ndef Order.Preimage {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) (x y : \u03b1) : Prop :=\n  s (f x) (f y)", "start": [685, 1], "end": [690, 16], "kind": "commanddeclaration"}, {"full_name": "Order.Preimage.decidable", "code": "instance Order.Preimage.decidable {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [H : DecidableRel s] :\n    DecidableRel (f \u207b\u00b9'o s) := fun _ _ \u21a6 H _ _", "start": [696, 1], "end": [698, 47], "kind": "commanddeclaration"}, {"full_name": "OrderDual", "code": "def OrderDual (\u03b1 : Type*) : Type _ :=\n  \u03b1", "start": [704, 1], "end": [707, 4], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instPreorder", "code": "instance instPreorder (\u03b1 : Type*) [Preorder \u03b1] : Preorder \u03b1\u1d52\u1d48 where\n  le_refl := fun _ \u21a6 le_refl _\n  le_trans := fun _ _ _ hab hbc \u21a6 hbc.trans hab\n  lt_iff_le_not_le := fun _ _ \u21a6 lt_iff_le_not_le", "start": [727, 1], "end": [730, 49], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instPartialOrder", "code": "instance instPartialOrder (\u03b1 : Type*) [PartialOrder \u03b1] : PartialOrder \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (Preorder \u03b1\u1d52\u1d48)\n  le_antisymm := fun a b hab hba \u21a6 @le_antisymm \u03b1 _ a b hba hab", "start": [732, 1], "end": [734, 64], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instLinearOrder", "code": "instance instLinearOrder (\u03b1 : Type*) [LinearOrder \u03b1] : LinearOrder \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (PartialOrder \u03b1\u1d52\u1d48)\n  le_total := \u03bb a b : \u03b1 => le_total b a\n  max := fun a b \u21a6 (min a b : \u03b1)\n  min := fun a b \u21a6 (max a b : \u03b1)\n  min_def := fun a b \u21a6 show (max .. : \u03b1) = _ by rw [max_comm, max_def]; rfl\n  max_def := fun a b \u21a6 show (min .. : \u03b1) = _ by rw [min_comm, min_def]; rfl\n  decidableLE := (inferInstance : DecidableRel (\u03bb a b : \u03b1 => b \u2264 a))\n  decidableLT := (inferInstance : DecidableRel (\u03bb a b : \u03b1 => b < a))", "start": [736, 1], "end": [744, 69], "kind": "commanddeclaration"}, {"full_name": "OrderDual.Preorder.dual_dual", "code": "theorem Preorder.dual_dual (\u03b1 : Type*) [H : Preorder \u03b1] : OrderDual.instPreorder \u03b1\u1d52\u1d48 = H", "start": [749, 1], "end": [750, 33], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instPartialOrder.dual_dual", "code": "theorem instPartialOrder.dual_dual (\u03b1 : Type*) [H : PartialOrder \u03b1] :\n    OrderDual.instPartialOrder \u03b1\u1d52\u1d48 = H", "start": [753, 1], "end": [755, 37], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instLinearOrder.dual_dual", "code": "theorem instLinearOrder.dual_dual (\u03b1 : Type*) [H : LinearOrder \u03b1] :\n    OrderDual.instLinearOrder \u03b1\u1d52\u1d48 = H", "start": [758, 1], "end": [760, 36], "kind": "commanddeclaration"}, {"full_name": "HasCompl", "code": "@[notation_class]\nclass HasCompl (\u03b1 : Type*) where\n  \n  compl : \u03b1 \u2192 \u03b1", "start": [768, 1], "end": [772, 16], "kind": "commanddeclaration"}, {"full_name": "Prop.hasCompl", "code": "instance Prop.hasCompl : HasCompl Prop :=\n  \u27e8Not\u27e9", "start": [780, 1], "end": [781, 8], "kind": "commanddeclaration"}, {"full_name": "Pi.hasCompl", "code": "instance Pi.hasCompl {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, HasCompl (\u03b1 i)] : HasCompl (\u2200 i, \u03b1 i) :=\n  \u27e8fun x i \u21a6 (x i)\u1d9c\u27e9", "start": [784, 1], "end": [785, 21], "kind": "commanddeclaration"}, {"full_name": "Pi.compl_def", "code": "theorem Pi.compl_def {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, HasCompl (\u03b1 i)] (x : \u2200 i, \u03b1 i) :\n    x\u1d9c = fun i \u21a6 (x i)\u1d9c", "start": [788, 1], "end": [790, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.compl_apply", "code": "@[simp]\ntheorem Pi.compl_apply {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, HasCompl (\u03b1 i)] (x : \u2200 i, \u03b1 i) (i : \u03b9) :\n    x\u1d9c i = (x i)\u1d9c", "start": [793, 1], "end": [796, 6], "kind": "commanddeclaration"}, {"full_name": "IsIrrefl.compl", "code": "instance IsIrrefl.compl (r) [IsIrrefl \u03b1 r] : IsRefl \u03b1 r\u1d9c :=\n  \u27e8@irrefl \u03b1 r _\u27e9", "start": [799, 1], "end": [800, 18], "kind": "commanddeclaration"}, {"full_name": "IsRefl.compl", "code": "instance IsRefl.compl (r) [IsRefl \u03b1 r] : IsIrrefl \u03b1 r\u1d9c :=\n  \u27e8fun a \u21a6 not_not_intro (refl a)\u27e9", "start": [803, 1], "end": [804, 35], "kind": "commanddeclaration"}, {"full_name": "Pi.hasLe", "code": "instance Pi.hasLe {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, LE (\u03b1 i)] :\n    LE (\u2200 i, \u03b1 i) where le x y := \u2200 i, x i \u2264 y i", "start": [810, 1], "end": [811, 49], "kind": "commanddeclaration"}, {"full_name": "Pi.le_def", "code": "theorem Pi.le_def {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, LE (\u03b1 i)] {x y : \u2200 i, \u03b1 i} :\n    x \u2264 y \u2194 \u2200 i, x i \u2264 y i", "start": [814, 1], "end": [816, 10], "kind": "commanddeclaration"}, {"full_name": "Pi.preorder", "code": "instance Pi.preorder {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, Preorder (\u03b1 i)] : Preorder (\u2200 i, \u03b1 i) where\n  __ := inferInstanceAs (LE (\u2200 i, \u03b1 i))\n  le_refl := fun a i \u21a6 le_refl (a i)\n  le_trans := fun a b c h\u2081 h\u2082 i \u21a6 le_trans (h\u2081 i) (h\u2082 i)", "start": [819, 1], "end": [822, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.lt_def", "code": "theorem Pi.lt_def {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, Preorder (\u03b1 i)] {x y : \u2200 i, \u03b1 i} :\n    x < y \u2194 x \u2264 y \u2227 \u2203 i, x i < y i", "start": [825, 1], "end": [827, 72], "kind": "commanddeclaration"}, {"full_name": "Pi.partialOrder", "code": "instance Pi.partialOrder [\u2200 i, PartialOrder (\u03c0 i)] : PartialOrder (\u2200 i, \u03c0 i) where\n  __ := Pi.preorder\n  le_antisymm := fun _ _ h1 h2 \u21a6 funext fun b \u21a6 (h1 b).antisymm (h2 b)", "start": [830, 1], "end": [832, 71], "kind": "commanddeclaration"}, {"full_name": "StrongLT", "code": "def StrongLT [\u2200 i, LT (\u03c0 i)] (a b : \u2200 i, \u03c0 i) : Prop :=\n  \u2200 i, a i < b i", "start": [837, 1], "end": [839, 17], "kind": "commanddeclaration"}, {"full_name": "le_of_strongLT", "code": "theorem le_of_strongLT (h : a \u227a b) : a \u2264 b", "start": [847, 1], "end": [847, 63], "kind": "commanddeclaration"}, {"full_name": "lt_of_strongLT", "code": "theorem lt_of_strongLT [Nonempty \u03b9] (h : a \u227a b) : a < b", "start": [850, 1], "end": [852, 53], "kind": "commanddeclaration"}, {"full_name": "strongLT_of_strongLT_of_le", "code": "theorem strongLT_of_strongLT_of_le (hab : a \u227a b) (hbc : b \u2264 c) : a \u227a c", "start": [855, 1], "end": [856, 28], "kind": "commanddeclaration"}, {"full_name": "strongLT_of_le_of_strongLT", "code": "theorem strongLT_of_le_of_strongLT (hab : a \u2264 b) (hbc : b \u227a c) : a \u227a c", "start": [859, 1], "end": [860, 28], "kind": "commanddeclaration"}, {"full_name": "StrongLT.le", "code": "alias StrongLT.le := le_of_strongLT", "start": [863, 1], "end": [863, 36], "kind": "stdtacticaliasalias"}, {"full_name": "StrongLT.lt", "code": "alias StrongLT.lt := lt_of_strongLT", "start": [866, 1], "end": [866, 36], "kind": "stdtacticaliasalias"}, {"full_name": "StrongLT.trans_le", "code": "alias StrongLT.trans_le := strongLT_of_strongLT_of_le", "start": [869, 1], "end": [869, 54], "kind": "stdtacticaliasalias"}, {"full_name": "LE.le.trans_strongLT", "code": "alias LE.le.trans_strongLT := strongLT_of_le_of_strongLT", "start": [872, 1], "end": [872, 57], "kind": "stdtacticaliasalias"}, {"full_name": "le_update_iff", "code": "theorem le_update_iff : x \u2264 Function.update y i a \u2194 x i \u2264 a \u2227 \u2200 (j) (_ : j \u2260 i), x j \u2264 y j", "start": [880, 1], "end": [881, 49], "kind": "commanddeclaration"}, {"full_name": "update_le_iff", "code": "theorem update_le_iff : Function.update x i a \u2264 y \u2194 a \u2264 y i \u2227 \u2200 (j) (_ : j \u2260 i), x j \u2264 y j", "start": [884, 1], "end": [885, 49], "kind": "commanddeclaration"}, {"full_name": "update_le_update_iff", "code": "theorem update_le_update_iff :\n    Function.update x i a \u2264 Function.update y i b \u2194 a \u2264 b \u2227 \u2200 (j) (_ : j \u2260 i), x j \u2264 y j", "start": [888, 1], "end": [890, 58], "kind": "commanddeclaration"}, {"full_name": "update_le_update_iff'", "code": "@[simp]\ntheorem update_le_update_iff' : update x i a \u2264 update x i b \u2194 a \u2264 b", "start": [893, 1], "end": [895, 30], "kind": "commanddeclaration"}, {"full_name": "update_lt_update_iff", "code": "@[simp]\ntheorem update_lt_update_iff : update x i a < update x i b \u2194 a < b", "start": [898, 1], "end": [900, 70], "kind": "commanddeclaration"}, {"full_name": "le_update_self_iff", "code": "@[simp]\ntheorem le_update_self_iff : x \u2264 update x i a \u2194 x i \u2264 a", "start": [903, 1], "end": [904, 83], "kind": "commanddeclaration"}, {"full_name": "update_le_self_iff", "code": "@[simp]\ntheorem update_le_self_iff : update x i a \u2264 x \u2194 a \u2264 x i", "start": [907, 1], "end": [908, 83], "kind": "commanddeclaration"}, {"full_name": "lt_update_self_iff", "code": "@[simp]\ntheorem lt_update_self_iff : x < update x i a \u2194 x i < a", "start": [911, 1], "end": [912, 86], "kind": "commanddeclaration"}, {"full_name": "update_lt_self_iff", "code": "@[simp]\ntheorem update_lt_self_iff : update x i a < x \u2194 a < x i", "start": [915, 1], "end": [916, 86], "kind": "commanddeclaration"}, {"full_name": "Pi.sdiff", "code": "instance Pi.sdiff {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, SDiff (\u03b1 i)] : SDiff (\u2200 i, \u03b1 i) :=\n  \u27e8fun x y i \u21a6 x i \\ y i\u27e9", "start": [921, 1], "end": [922, 26], "kind": "commanddeclaration"}, {"full_name": "Pi.sdiff_def", "code": "theorem Pi.sdiff_def {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, SDiff (\u03b1 i)] (x y : \u2200 i, \u03b1 i) :\n    x \\ y = fun i \u21a6 x i \\ y i", "start": [925, 1], "end": [927, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.sdiff_apply", "code": "@[simp]\ntheorem Pi.sdiff_apply {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, SDiff (\u03b1 i)] (x y : \u2200 i, \u03b1 i) (i : \u03b9) :\n    (x \\ y) i = x i \\ y i", "start": [930, 1], "end": [933, 6], "kind": "commanddeclaration"}, {"full_name": "Function.const_le_const", "code": "@[simp]\ntheorem const_le_const : const \u03b2 a \u2264 const \u03b2 b \u2194 a \u2264 b", "start": [940, 1], "end": [941, 78], "kind": "commanddeclaration"}, {"full_name": "Function.const_lt_const", "code": "@[simp]\ntheorem const_lt_const : const \u03b2 a < const \u03b2 b \u2194 a < b", "start": [944, 1], "end": [945, 94], "kind": "commanddeclaration"}, {"full_name": "min_rec", "code": "theorem min_rec (hx : x \u2264 y \u2192 p x) (hy : y \u2264 x \u2192 p y) : p (min x y)", "start": [957, 1], "end": [959, 39], "kind": "commanddeclaration"}, {"full_name": "max_rec", "code": "theorem max_rec (hx : y \u2264 x \u2192 p x) (hy : x \u2264 y \u2192 p y) : p (max x y)", "start": [962, 1], "end": [963, 29], "kind": "commanddeclaration"}, {"full_name": "min_rec'", "code": "theorem min_rec' (p : \u03b1 \u2192 Prop) (hx : p x) (hy : p y) : p (min x y)", "start": [966, 1], "end": [967, 34], "kind": "commanddeclaration"}, {"full_name": "max_rec'", "code": "theorem max_rec' (p : \u03b1 \u2192 Prop) (hx : p x) (hy : p y) : p (max x y)", "start": [970, 1], "end": [971, 34], "kind": "commanddeclaration"}, {"full_name": "min_def_lt", "code": "theorem min_def_lt (x y : \u03b1) : min x y = if x < y then x else y", "start": [974, 1], "end": [976, 21], "kind": "commanddeclaration"}, {"full_name": "max_def_lt", "code": "theorem max_def_lt (x y : \u03b1) : max x y = if x < y then y else x", "start": [979, 1], "end": [981, 21], "kind": "commanddeclaration"}, {"full_name": "Sup", "code": "@[notation_class, ext]\nclass Sup (\u03b1 : Type u) where\n  \n  sup : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [989, 1], "end": [993, 18], "kind": "commanddeclaration"}, {"full_name": "Inf", "code": "@[notation_class, ext]\nclass Inf (\u03b1 : Type u) where\n  \n  inf : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [996, 1], "end": [1000, 18], "kind": "commanddeclaration"}, {"full_name": "Preorder.lift", "code": "@[reducible]\ndef Preorder.lift {\u03b1 \u03b2} [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) : Preorder \u03b1 where\n  le x y := f x \u2264 f y\n  le_refl _ := le_rfl\n  le_trans _ _ _ := _root_.le_trans\n  lt x y := f x < f y\n  lt_iff_le_not_le _ _ := _root_.lt_iff_le_not_le", "start": [1012, 1], "end": [1020, 50], "kind": "commanddeclaration"}, {"full_name": "PartialOrder.lift", "code": "@[reducible]\ndef PartialOrder.lift {\u03b1 \u03b2} [PartialOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (inj : Injective f) : PartialOrder \u03b1 :=\n  { Preorder.lift f with le_antisymm := fun _ _ h\u2081 h\u2082 \u21a6 inj (h\u2081.antisymm h\u2082) }", "start": [1023, 1], "end": [1027, 79], "kind": "commanddeclaration"}, {"full_name": "compare_of_injective_eq_compareOfLessAndEq", "code": "theorem compare_of_injective_eq_compareOfLessAndEq (a b : \u03b1) [LinearOrder \u03b2]\n    [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2) (inj : Injective f)\n    [Decidable (LT.lt (self := PartialOrder.lift f inj |>.toLT) a b)] :\n    compare (f a) (f b) =\n      @compareOfLessAndEq _ a b (PartialOrder.lift f inj |>.toLT) _ _", "start": [1030, 1], "end": [1041, 18], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.lift", "code": "@[reducible]\ndef LinearOrder.lift {\u03b1 \u03b2} [LinearOrder \u03b2] [Sup \u03b1] [Inf \u03b1] (f : \u03b1 \u2192 \u03b2) (inj : Injective f)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrder \u03b1 :=\n  letI instOrd\u03b1 : Ord \u03b1 := \u27e8fun a b \u21a6 compare (f a) (f b)\u27e9\n  letI decidableLE := fun x y \u21a6 (inferInstance : Decidable (f x \u2264 f y))\n  letI decidableLT := fun x y \u21a6 (inferInstance : Decidable (f x < f y))\n  letI decidableEq := fun x y \u21a6 decidable_of_iff (f x = f y) inj.eq_iff\n  { PartialOrder.lift f inj, instOrd\u03b1 with\n    le_total := fun x y \u21a6 le_total (f x) (f y)\n    decidableLE := decidableLE\n    decidableLT := decidableLT\n    decidableEq := decidableEq\n    min := (\u00b7 \u2293 \u00b7)\n    max := (\u00b7 \u2294 \u00b7)\n    min_def := by\n      intros x y\n      apply inj\n      rw [apply_ite f]\n      exact (hinf _ _).trans (min_def _ _)\n    max_def := by\n      intros x y\n      apply inj\n      rw [apply_ite f]\n      exact (hsup _ _).trans (max_def _ _)\n    compare_eq_compareOfLessAndEq := fun a b \u21a6\n      compare_of_injective_eq_compareOfLessAndEq a b f inj }", "start": [1043, 1], "end": [1074, 61], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.lift'", "code": "@[reducible]\ndef LinearOrder.lift' {\u03b1 \u03b2} [LinearOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (inj : Injective f) : LinearOrder \u03b1 :=\n  @LinearOrder.lift \u03b1 \u03b2 _ \u27e8fun x y \u21a6 if f x \u2264 f y then y else x\u27e9\n    \u27e8fun x y \u21a6 if f x \u2264 f y then x else y\u27e9 f inj\n    (fun _ _ \u21a6 (apply_ite f _ _ _).trans (max_def _ _).symm) fun _ _ \u21a6\n    (apply_ite f _ _ _).trans (min_def _ _).symm", "start": [1076, 1], "end": [1086, 49], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.liftWithOrd", "code": "@[reducible]\ndef LinearOrder.liftWithOrd {\u03b1 \u03b2} [LinearOrder \u03b2] [Sup \u03b1] [Inf \u03b1] [Ord \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (inj : Injective f) (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y))\n    (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y))\n    (compare_f : \u2200 a b : \u03b1, compare a b = compare (f a) (f b)) : LinearOrder \u03b1 :=\n  letI decidableLE := fun x y \u21a6 (inferInstance : Decidable (f x \u2264 f y))\n  letI decidableLT := fun x y \u21a6 (inferInstance : Decidable (f x < f y))\n  letI decidableEq := fun x y \u21a6 decidable_of_iff (f x = f y) inj.eq_iff\n  { PartialOrder.lift f inj with\n    le_total := fun x y \u21a6 le_total (f x) (f y)\n    decidableLE := decidableLE\n    decidableLT := decidableLT\n    decidableEq := decidableEq\n    min := (\u00b7 \u2293 \u00b7)\n    max := (\u00b7 \u2294 \u00b7)\n    min_def := by\n      intros x y\n      apply inj\n      rw [apply_ite f]\n      exact (hinf _ _).trans (min_def _ _)\n    max_def := by\n      intros x y\n      apply inj\n      rw [apply_ite f]\n      exact (hsup _ _).trans (max_def _ _)\n    compare_eq_compareOfLessAndEq := fun a b \u21a6\n      (compare_f a b).trans <| compare_of_injective_eq_compareOfLessAndEq a b f inj }", "start": [1089, 1], "end": [1121, 86], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.liftWithOrd'", "code": "@[reducible]\ndef LinearOrder.liftWithOrd' {\u03b1 \u03b2} [LinearOrder \u03b2] [Ord \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (inj : Injective f)\n    (compare_f : \u2200 a b : \u03b1, compare a b = compare (f a) (f b)) : LinearOrder \u03b1 :=\n  @LinearOrder.liftWithOrd \u03b1 \u03b2 _ \u27e8fun x y \u21a6 if f x \u2264 f y then y else x\u27e9\n    \u27e8fun x y \u21a6 if f x \u2264 f y then x else y\u27e9 _ f inj\n    (fun _ _ \u21a6 (apply_ite f _ _ _).trans (max_def _ _).symm)\n    (fun _ _ \u21a6 (apply_ite f _ _ _).trans (min_def _ _).symm)\n    compare_f", "start": [1123, 1], "end": [1136, 14], "kind": "commanddeclaration"}, {"full_name": "Subtype.le", "code": "instance le [LE \u03b1] {p : \u03b1 \u2192 Prop} : LE (Subtype p) :=\n  \u27e8fun x y \u21a6 (x : \u03b1) \u2264 y\u27e9", "start": [1143, 1], "end": [1144, 26], "kind": "commanddeclaration"}, {"full_name": "Subtype.lt", "code": "instance lt [LT \u03b1] {p : \u03b1 \u2192 Prop} : LT (Subtype p) :=\n  \u27e8fun x y \u21a6 (x : \u03b1) < y\u27e9", "start": [1146, 1], "end": [1147, 26], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk [LE \u03b1] {p : \u03b1 \u2192 Prop} {x y : \u03b1} {hx : p x} {hy : p y} :\n    (\u27e8x, hx\u27e9 : Subtype p) \u2264 \u27e8y, hy\u27e9 \u2194 x \u2264 y", "start": [1149, 1], "end": [1152, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_lt_mk", "code": "@[simp]\ntheorem mk_lt_mk [LT \u03b1] {p : \u03b1 \u2192 Prop} {x y : \u03b1} {hx : p x} {hy : p y} :\n    (\u27e8x, hx\u27e9 : Subtype p) < \u27e8y, hy\u27e9 \u2194 x < y", "start": [1155, 1], "end": [1158, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe [LE \u03b1] {p : \u03b1 \u2192 Prop} {x y : Subtype p} : (x : \u03b1) \u2264 y \u2194 x \u2264 y", "start": [1161, 1], "end": [1163, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe [LT \u03b1] {p : \u03b1 \u2192 Prop} {x y : Subtype p} : (x : \u03b1) < y \u2194 x < y", "start": [1166, 1], "end": [1168, 10], "kind": "commanddeclaration"}, {"full_name": "Subtype.preorder", "code": "instance preorder [Preorder \u03b1] (p : \u03b1 \u2192 Prop) : Preorder (Subtype p) :=\n  Preorder.lift (fun (a : Subtype p) \u21a6 (a : \u03b1))", "start": [1171, 1], "end": [1172, 48], "kind": "commanddeclaration"}, {"full_name": "Subtype.partialOrder", "code": "instance partialOrder [PartialOrder \u03b1] (p : \u03b1 \u2192 Prop) : PartialOrder (Subtype p) :=\n  PartialOrder.lift (fun (a : Subtype p) \u21a6 (a : \u03b1)) Subtype.coe_injective", "start": [1174, 1], "end": [1175, 74], "kind": "commanddeclaration"}, {"full_name": "Subtype.decidableLE", "code": "instance decidableLE [Preorder \u03b1] [h : @DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] {p : \u03b1 \u2192 Prop} :\n    @DecidableRel (Subtype p) (\u00b7 \u2264 \u00b7) := fun a b \u21a6 h a b", "start": [1178, 1], "end": [1179, 57], "kind": "commanddeclaration"}, {"full_name": "Subtype.decidableLT", "code": "instance decidableLT [Preorder \u03b1] [h : @DecidableRel \u03b1 (\u00b7 < \u00b7)] {p : \u03b1 \u2192 Prop} :\n    @DecidableRel (Subtype p) (\u00b7 < \u00b7) := fun a b \u21a6 h a b", "start": [1182, 1], "end": [1183, 57], "kind": "commanddeclaration"}, {"full_name": "Subtype.linearOrder", "code": "instance linearOrder [LinearOrder \u03b1] (p : \u03b1 \u2192 Prop) : LinearOrder (Subtype p) :=\n  @LinearOrder.lift (Subtype p) _ _ \u27e8fun x y \u21a6 \u27e8max x y, max_rec' _ x.2 y.2\u27e9\u27e9\n    \u27e8fun x y \u21a6 \u27e8min x y, min_rec' _ x.2 y.2\u27e9\u27e9 (fun (a : Subtype p) \u21a6 (a : \u03b1))\n    Subtype.coe_injective (fun _ _ \u21a6 rfl) fun _ _ \u21a6\n    rfl", "start": [1186, 1], "end": [1193, 8], "kind": "commanddeclaration"}, {"full_name": "Prod.instDecidableLE", "code": "instance instDecidableLE (\u03b1 : Type u) (\u03b2 : Type v) [LE \u03b1] [LE \u03b2] (x y : \u03b1 \u00d7 \u03b2)\n    [Decidable (x.1 \u2264 y.1)] [Decidable (x.2 \u2264 y.2)] : Decidable (x \u2264 y) := And.decidable", "start": [1211, 1], "end": [1212, 89], "kind": "commanddeclaration"}, {"full_name": "Prod.le_def", "code": "theorem le_def [LE \u03b1] [LE \u03b2] {x y : \u03b1 \u00d7 \u03b2} : x \u2264 y \u2194 x.1 \u2264 y.1 \u2227 x.2 \u2264 y.2", "start": [1214, 1], "end": [1215, 10], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk [LE \u03b1] [LE \u03b2] {x\u2081 x\u2082 : \u03b1} {y\u2081 y\u2082 : \u03b2} : (x\u2081, y\u2081) \u2264 (x\u2082, y\u2082) \u2194 x\u2081 \u2264 x\u2082 \u2227 y\u2081 \u2264 y\u2082", "start": [1218, 1], "end": [1220, 10], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_le_swap", "code": "@[simp]\ntheorem swap_le_swap [LE \u03b1] [LE \u03b2] {x y : \u03b1 \u00d7 \u03b2} : x.swap \u2264 y.swap \u2194 x \u2264 y", "start": [1223, 1], "end": [1225, 11], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_lt_swap", "code": "@[simp]\ntheorem swap_lt_swap : x.swap < y.swap \u2194 x < y", "start": [1237, 1], "end": [1239, 50], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_le_mk_iff_left", "code": "theorem mk_le_mk_iff_left : (a\u2081, b) \u2264 (a\u2082, b) \u2194 a\u2081 \u2264 a\u2082", "start": [1242, 1], "end": [1243, 22], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_le_mk_iff_right", "code": "theorem mk_le_mk_iff_right : (a, b\u2081) \u2264 (a, b\u2082) \u2194 b\u2081 \u2264 b\u2082", "start": [1246, 1], "end": [1247, 23], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_lt_mk_iff_left", "code": "theorem mk_lt_mk_iff_left : (a\u2081, b) < (a\u2082, b) \u2194 a\u2081 < a\u2082", "start": [1250, 1], "end": [1251, 62], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_lt_mk_iff_right", "code": "theorem mk_lt_mk_iff_right : (a, b\u2081) < (a, b\u2082) \u2194 b\u2081 < b\u2082", "start": [1254, 1], "end": [1255, 64], "kind": "commanddeclaration"}, {"full_name": "Prod.lt_iff", "code": "theorem lt_iff : x < y \u2194 x.1 < y.1 \u2227 x.2 \u2264 y.2 \u2228 x.1 \u2264 y.1 \u2227 x.2 < y.2", "start": [1258, 1], "end": [1265, 49], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_lt_mk", "code": "@[simp]\ntheorem mk_lt_mk : (a\u2081, b\u2081) < (a\u2082, b\u2082) \u2194 a\u2081 < a\u2082 \u2227 b\u2081 \u2264 b\u2082 \u2228 a\u2081 \u2264 a\u2082 \u2227 b\u2081 < b\u2082", "start": [1268, 1], "end": [1270, 9], "kind": "commanddeclaration"}, {"full_name": "Prod.instPartialOrder", "code": "instance instPartialOrder (\u03b1 : Type u) (\u03b2 : Type v) [PartialOrder \u03b1] [PartialOrder \u03b2] :\n    PartialOrder (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (Preorder (\u03b1 \u00d7 \u03b2))\n  le_antisymm := fun _ _ \u27e8hac, hbd\u27e9 \u27e8hca, hdb\u27e9 \u21a6 Prod.ext (hac.antisymm hca) (hbd.antisymm hdb)", "start": [1275, 1], "end": [1281, 96], "kind": "commanddeclaration"}, {"full_name": "DenselyOrdered", "code": "class DenselyOrdered (\u03b1 : Type u) [LT \u03b1] : Prop where\n  \n  dense : \u2200 a\u2081 a\u2082 : \u03b1, a\u2081 < a\u2082 \u2192 \u2203 a, a\u2081 < a \u2227 a < a\u2082", "start": [1288, 1], "end": [1291, 54], "kind": "commanddeclaration"}, {"full_name": "exists_between", "code": "theorem exists_between [LT \u03b1] [DenselyOrdered \u03b1] : \u2200 {a\u2081 a\u2082 : \u03b1}, a\u2081 < a\u2082 \u2192 \u2203 a, a\u2081 < a \u2227 a < a\u2082", "start": [1294, 1], "end": [1295, 27], "kind": "commanddeclaration"}, {"full_name": "OrderDual.denselyOrdered", "code": "instance OrderDual.denselyOrdered (\u03b1 : Type u) [LT \u03b1] [h : DenselyOrdered \u03b1] :\n    DenselyOrdered \u03b1\u1d52\u1d48 :=\n  \u27e8fun _ _ ha \u21a6 (@exists_between \u03b1 _ h _ _ ha).imp fun _ \u21a6 And.symm\u27e9", "start": [1298, 1], "end": [1300, 69], "kind": "commanddeclaration"}, {"full_name": "denselyOrdered_orderDual", "code": "@[simp]\ntheorem denselyOrdered_orderDual [LT \u03b1] : DenselyOrdered \u03b1\u1d52\u1d48 \u2194 DenselyOrdered \u03b1", "start": [1303, 1], "end": [1305, 78], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_le_of_dense", "code": "theorem le_of_forall_le_of_dense [LinearOrder \u03b1] [DenselyOrdered \u03b1] {a\u2081 a\u2082 : \u03b1}\n    (h : \u2200 a, a\u2082 < a \u2192 a\u2081 \u2264 a) : a\u2081 \u2264 a\u2082", "start": [1329, 1], "end": [1333, 58], "kind": "commanddeclaration"}, {"full_name": "eq_of_le_of_forall_le_of_dense", "code": "theorem eq_of_le_of_forall_le_of_dense [LinearOrder \u03b1] [DenselyOrdered \u03b1] {a\u2081 a\u2082 : \u03b1} (h\u2081 : a\u2082 \u2264 a\u2081)\n    (h\u2082 : \u2200 a, a\u2082 < a \u2192 a\u2081 \u2264 a) : a\u2081 = a\u2082", "start": [1336, 1], "end": [1338, 47], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_ge_of_dense", "code": "theorem le_of_forall_ge_of_dense [LinearOrder \u03b1] [DenselyOrdered \u03b1] {a\u2081 a\u2082 : \u03b1}\n    (h : \u2200 a\u2083 < a\u2081, a\u2083 \u2264 a\u2082) : a\u2081 \u2264 a\u2082", "start": [1341, 1], "end": [1345, 58], "kind": "commanddeclaration"}, {"full_name": "eq_of_le_of_forall_ge_of_dense", "code": "theorem eq_of_le_of_forall_ge_of_dense [LinearOrder \u03b1] [DenselyOrdered \u03b1] {a\u2081 a\u2082 : \u03b1} (h\u2081 : a\u2082 \u2264 a\u2081)\n    (h\u2082 : \u2200 a\u2083 < a\u2081, a\u2083 \u2264 a\u2082) : a\u2081 = a\u2082", "start": [1348, 1], "end": [1350, 44], "kind": "commanddeclaration"}, {"full_name": "dense_or_discrete", "code": "theorem dense_or_discrete [LinearOrder \u03b1] (a\u2081 a\u2082 : \u03b1) :\n    (\u2203 a, a\u2081 < a \u2227 a < a\u2082) \u2228 (\u2200 a, a\u2081 < a \u2192 a\u2082 \u2264 a) \u2227 \u2200 a < a\u2082, a \u2264 a\u2081", "start": [1353, 1], "end": [1357, 57], "kind": "commanddeclaration"}, {"full_name": "eq_or_eq_or_eq_of_forall_not_lt_lt", "code": "lemma eq_or_eq_or_eq_of_forall_not_lt_lt [LinearOrder \u03b1]\n    (h : \u2200 \u2983x y z : \u03b1\u2984, x < y \u2192 y < z \u2192 False) (x y z : \u03b1) : x = y \u2228 y = z \u2228 x = z := by\n  by_contra hne\n  simp only [not_or, \u2190 Ne.def] at hne\n  cases' hne.1.lt_or_lt with h\u2081 h\u2081 <;> cases' hne.2.1.lt_or_lt with h\u2082 h\u2082 <;>\n    cases' hne.2.2.lt_or_lt with h\u2083 h\u2083\n  exacts [h h\u2081 h\u2082, h h\u2082 h\u2083, h h\u2083 h\u2082, h h\u2083 h\u2081, h h\u2081 h\u2083, h h\u2082 h\u2083, h h\u2081 h\u2083, h h\u2082 h\u2081]", "start": [1360, 1], "end": [1367, 82], "kind": "mathlibtacticlemma"}, {"full_name": "PUnit.linearOrder", "code": "instance linearOrder: LinearOrder PUnit where\n  le  := fun _ _ \u21a6 True\n  lt  := fun _ _ \u21a6 False\n  max := fun _ _ \u21a6 unit\n  min := fun _ _ \u21a6 unit\n  decidableEq := inferInstance\n  decidableLE := fun _ _ \u21a6 Decidable.isTrue trivial\n  decidableLT := fun _ _ \u21a6 Decidable.isFalse id\n  le_refl     := by intros; trivial\n  le_trans    := by intros; trivial\n  le_total    := by intros; exact Or.inl trivial\n  le_antisymm := by intros; rfl\n  lt_iff_le_not_le := by simp only [not_true, and_false, forall_const]", "start": [1374, 1], "end": [1386, 71], "kind": "commanddeclaration"}, {"full_name": "PUnit.max_eq", "code": "theorem max_eq : max a b = unit", "start": [1388, 1], "end": [1389, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.min_eq", "code": "theorem min_eq : min a b = unit", "start": [1392, 1], "end": [1393, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.le", "code": "protected theorem le : a \u2264 b", "start": [1397, 1], "end": [1398, 10], "kind": "commanddeclaration"}, {"full_name": "PUnit.not_lt", "code": "theorem not_lt : \u00aca < b", "start": [1402, 1], "end": [1403, 12], "kind": "commanddeclaration"}, {"full_name": "Prop.le", "code": "instance Prop.le : LE Prop :=\n  \u27e8(\u00b7 \u2192 \u00b7)\u27e9", "start": [1413, 1], "end": [1415, 12], "kind": "commanddeclaration"}, {"full_name": "le_Prop_eq", "code": "@[simp]\ntheorem le_Prop_eq : ((\u00b7 \u2264 \u00b7) : Prop \u2192 Prop \u2192 Prop) = (\u00b7 \u2192 \u00b7)", "start": [1418, 1], "end": [1420, 6], "kind": "commanddeclaration"}, {"full_name": "subrelation_iff_le", "code": "theorem subrelation_iff_le {r s : \u03b1 \u2192 \u03b1 \u2192 Prop} : Subrelation r s \u2194 r \u2264 s", "start": [1423, 1], "end": [1424, 10], "kind": "commanddeclaration"}, {"full_name": "Prop.partialOrder", "code": "instance Prop.partialOrder : PartialOrder Prop where\n  __ := Prop.le\n  le_refl _ := id\n  le_trans _ _ _ f g := g \u2218 f\n  le_antisymm _ _ Hab Hba := propext \u27e8Hab, Hba\u27e9", "start": [1427, 1], "end": [1431, 48], "kind": "commanddeclaration"}, {"full_name": "AsLinearOrder", "code": "def AsLinearOrder (\u03b1 : Type u) :=\n  \u03b1", "start": [1441, 1], "end": [1443, 4], "kind": "commanddeclaration"}, {"full_name": "AsLinearOrder.linearOrder", "code": "noncomputable instance AsLinearOrder.linearOrder {\u03b1} [PartialOrder \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] :\n    LinearOrder (AsLinearOrder \u03b1) where\n  __ := inferInstanceAs (PartialOrder \u03b1)\n  le_total := @total_of \u03b1 (\u00b7 \u2264 \u00b7) _\n  decidableLE := Classical.decRel _", "start": [1449, 1], "end": [1453, 36], "kind": "commanddeclaration"}, {"full_name": "one_le_dite", "code": "@[to_additive dite_nonneg]\nlemma one_le_dite [LE \u03b1] (ha : \u2200 h, 1 \u2264 a h) (hb : \u2200 h, 1 \u2264 b h) : 1 \u2264 dite p a b := by\n  split; exacts [ha \u2039_\u203a, hb \u2039_\u203a]", "start": [1459, 1], "end": [1461, 33], "kind": "mathlibtacticlemma"}, {"full_name": "dite_le_one", "code": "@[to_additive]\nlemma dite_le_one [LE \u03b1] (ha : \u2200 h, a h \u2264 1) (hb : \u2200 h, b h \u2264 1) : dite p a b \u2264 1 := by\n  split; exacts [ha \u2039_\u203a, hb \u2039_\u203a]", "start": [1463, 1], "end": [1465, 33], "kind": "mathlibtacticlemma"}, {"full_name": "one_lt_dite", "code": "@[to_additive dite_pos]\nlemma one_lt_dite [LT \u03b1] (ha : \u2200 h, 1 < a h) (hb : \u2200 h, 1 < b h) : 1 < dite p a b := by\n  split; exacts [ha \u2039_\u203a, hb \u2039_\u203a]", "start": [1467, 1], "end": [1469, 33], "kind": "mathlibtacticlemma"}, {"full_name": "dite_lt_one", "code": "@[to_additive]\nlemma dite_lt_one [LT \u03b1] (ha : \u2200 h, a h < 1) (hb : \u2200 h, b h < 1) : dite p a b < 1 := by\n  split; exacts [ha \u2039_\u203a, hb \u2039_\u203a]", "start": [1471, 1], "end": [1473, 33], "kind": "mathlibtacticlemma"}, {"full_name": "one_le_ite", "code": "@[to_additive ite_nonneg]\nlemma one_le_ite [LE \u03b1] (ha : 1 \u2264 a) (hb : 1 \u2264 b) : 1 \u2264 ite p a b := by split <;> assumption", "start": [1480, 1], "end": [1481, 93], "kind": "mathlibtacticlemma"}, {"full_name": "ite_le_one", "code": "@[to_additive]\nlemma ite_le_one [LE \u03b1] (ha : a \u2264 1) (hb : b \u2264 1) : ite p a b \u2264 1 := by split <;> assumption", "start": [1483, 1], "end": [1484, 93], "kind": "mathlibtacticlemma"}, {"full_name": "one_lt_ite", "code": "@[to_additive ite_pos]\nlemma one_lt_ite [LT \u03b1] (ha : 1 < a) (hb : 1 < b) : 1 < ite p a b := by split <;> assumption", "start": [1486, 1], "end": [1487, 93], "kind": "mathlibtacticlemma"}, {"full_name": "ite_lt_one", "code": "@[to_additive]\nlemma ite_lt_one [LT \u03b1] (ha : a < 1) (hb : b < 1) : ite p a b < 1 := by split <;> assumption", "start": [1489, 1], "end": [1490, 93], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Logic/Equiv/Defs.lean", "imports": ["Mathlib/Logic/Unique.lean", "Mathlib/Data/Quot.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Bool/Lemmas.lean", "Mathlib/Data/FunLike/Equiv.lean", "Mathlib/Tactic/Substs.lean", "Mathlib/Tactic/Conv.lean"], "premises": [{"full_name": "Equiv", "code": "structure Equiv (\u03b1 : Sort*) (\u03b2 : Sort _) where\n  protected toFun : \u03b1 \u2192 \u03b2\n  protected invFun : \u03b2 \u2192 \u03b1\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun", "start": [65, 1], "end": [70, 50], "kind": "commanddeclaration"}, {"full_name": "EquivLike.toEquiv", "code": "@[coe]\ndef EquivLike.toEquiv {F} [EquivLike F \u03b1 \u03b2] (f : F) : \u03b1 \u2243 \u03b2 where\n  toFun := f\n  invFun := EquivLike.inv f\n  left_inv := EquivLike.left_inv f\n  right_inv := EquivLike.right_inv f", "start": [75, 1], "end": [82, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm", "code": "@[reducible]\ndef Equiv.Perm (\u03b1 : Sort*) :=\n  Equiv \u03b1 \u03b1", "start": [88, 1], "end": [91, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_fn_mk", "code": "@[simp] theorem coe_fn_mk (f : \u03b1 \u2192 \u03b2) (g l r) : (Equiv.mk f g l r : \u03b1 \u2192 \u03b2) = f", "start": [108, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_fn_injective", "code": "theorem coe_fn_injective : @Function.Injective (\u03b1 \u2243 \u03b2) (\u03b1 \u2192 \u03b2) (fun e => e)", "start": [112, 1], "end": [114, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_inj", "code": "protected theorem coe_inj {e\u2081 e\u2082 : \u03b1 \u2243 \u03b2} : (e\u2081 : \u03b1 \u2192 \u03b2) = e\u2082 \u2194 e\u2081 = e\u2082", "start": [117, 1], "end": [118, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.ext", "code": "@[ext] theorem ext {f g : Equiv \u03b1 \u03b2} (H : \u2200 x, f x = g x) : f = g", "start": [121, 1], "end": [121, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.congr_arg", "code": "protected theorem congr_arg {f : Equiv \u03b1 \u03b2} {x x' : \u03b1} : x = x' \u2192 f x = f x'", "start": [124, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.congr_fun", "code": "protected theorem congr_fun {f g : Equiv \u03b1 \u03b2} (h : f = g) (x : \u03b1) : f x = g x", "start": [128, 1], "end": [129, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.ext_iff", "code": "theorem ext_iff {f g : Equiv \u03b1 \u03b2} : f = g \u2194 \u2200 x, f x = g x", "start": [132, 1], "end": [132, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ext", "code": "@[ext] theorem Perm.ext {\u03c3 \u03c4 : Equiv.Perm \u03b1} (H : \u2200 x, \u03c3 x = \u03c4 x) : \u03c3 = \u03c4", "start": [135, 1], "end": [135, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.congr_arg", "code": "protected theorem Perm.congr_arg {f : Equiv.Perm \u03b1} {x x' : \u03b1} : x = x' \u2192 f x = f x'", "start": [138, 1], "end": [139, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.congr_fun", "code": "protected theorem Perm.congr_fun {f g : Equiv.Perm \u03b1} (h : f = g) (x : \u03b1) : f x = g x", "start": [142, 1], "end": [143, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ext_iff", "code": "theorem Perm.ext_iff {\u03c3 \u03c4 : Equiv.Perm \u03b1} : \u03c3 = \u03c4 \u2194 \u2200 x, \u03c3 x = \u03c4 x", "start": [146, 1], "end": [146, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl", "code": "@[refl] protected def refl (\u03b1 : Sort*) : \u03b1 \u2243 \u03b1 := \u27e8id, id, fun _ => rfl, fun _ => rfl\u27e9", "start": [149, 1], "end": [150, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.inhabited'", "code": "instance inhabited' : Inhabited (\u03b1 \u2243 \u03b1) := \u27e8Equiv.refl \u03b1\u27e9", "start": [153, 1], "end": [153, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm", "code": "@[symm, pp_dot]\nprotected def symm (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2243 \u03b1 := \u27e8e.invFun, e.toFun, e.right_inv, e.left_inv\u27e9", "start": [155, 1], "end": [157, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : \u03b1 \u2243 \u03b2) : \u03b2 \u2192 \u03b1 := e.symm", "start": [160, 1], "end": [161, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.left_inv'", "code": "theorem left_inv' (e : \u03b1 \u2243 \u03b2) : Function.LeftInverse e.symm e", "start": [170, 1], "end": [170, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.right_inv'", "code": "theorem right_inv' (e : \u03b1 \u2243 \u03b2) : Function.RightInverse e.symm e", "start": [171, 1], "end": [171, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans", "code": "@[trans, pp_dot]\nprotected def trans (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) : \u03b1 \u2243 \u03b3 :=\n  \u27e8e\u2082 \u2218 e\u2081, e\u2081.symm \u2218 e\u2082.symm, e\u2082.left_inv.comp e\u2081.left_inv, e\u2082.right_inv.comp e\u2081.right_inv\u27e9", "start": [173, 1], "end": [176, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.toFun_as_coe", "code": "@[simp, mfld_simps] theorem toFun_as_coe (e : \u03b1 \u2243 \u03b2) : e.toFun = e", "start": [185, 1], "end": [185, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.toFun_as_coe_apply", "code": "@[simp] theorem toFun_as_coe_apply (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.toFun x = e x", "start": [192, 1], "end": [192, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.invFun_as_coe", "code": "@[simp, mfld_simps] theorem invFun_as_coe (e : \u03b1 \u2243 \u03b2) : e.invFun = e.symm", "start": [194, 1], "end": [194, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.injective", "code": "protected theorem injective (e : \u03b1 \u2243 \u03b2) : Injective e", "start": [197, 1], "end": [197, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.surjective", "code": "protected theorem surjective (e : \u03b1 \u2243 \u03b2) : Surjective e", "start": [200, 1], "end": [200, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.bijective", "code": "protected theorem bijective (e : \u03b1 \u2243 \u03b2) : Bijective e", "start": [203, 1], "end": [203, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.subsingleton", "code": "protected theorem subsingleton (e : \u03b1 \u2243 \u03b2) [Subsingleton \u03b2] : Subsingleton \u03b1", "start": [206, 1], "end": [207, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.subsingleton.symm", "code": "protected theorem subsingleton.symm (e : \u03b1 \u2243 \u03b2) [Subsingleton \u03b1] : Subsingleton \u03b2", "start": [210, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.subsingleton_congr", "code": "theorem subsingleton_congr (e : \u03b1 \u2243 \u03b2) : Subsingleton \u03b1 \u2194 Subsingleton \u03b2", "start": [214, 1], "end": [215, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.equiv_subsingleton_cod", "code": "instance equiv_subsingleton_cod [Subsingleton \u03b2] : Subsingleton (\u03b1 \u2243 \u03b2) :=\n  \u27e8fun _ _ => Equiv.ext fun _ => Subsingleton.elim _ _\u27e9", "start": [218, 1], "end": [219, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.equiv_subsingleton_dom", "code": "instance equiv_subsingleton_dom [Subsingleton \u03b1] : Subsingleton (\u03b1 \u2243 \u03b2) :=\n  \u27e8fun f _ => Equiv.ext fun _ => @Subsingleton.elim _ (Equiv.subsingleton.symm f) _ _\u27e9", "start": [221, 1], "end": [222, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.permUnique", "code": "instance permUnique [Subsingleton \u03b1] : Unique (Perm \u03b1) :=\n  uniqueOfSubsingleton (Equiv.refl \u03b1)", "start": [224, 1], "end": [225, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subsingleton_eq_refl", "code": "theorem Perm.subsingleton_eq_refl [Subsingleton \u03b1] (e : Perm \u03b1) : e = Equiv.refl \u03b1", "start": [227, 1], "end": [228, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.decidableEq", "code": "protected def decidableEq (e : \u03b1 \u2243 \u03b2) [DecidableEq \u03b2] : DecidableEq \u03b1 :=\n  e.injective.decidableEq", "start": [231, 1], "end": [233, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonempty_congr", "code": "theorem nonempty_congr (e : \u03b1 \u2243 \u03b2) : Nonempty \u03b1 \u2194 Nonempty \u03b2", "start": [236, 1], "end": [236, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.nonempty", "code": "protected theorem nonempty (e : \u03b1 \u2243 \u03b2) [Nonempty \u03b2] : Nonempty \u03b1", "start": [239, 1], "end": [239, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.inhabited", "code": "protected def inhabited [Inhabited \u03b2] (e : \u03b1 \u2243 \u03b2) : Inhabited \u03b1 := \u27e8e.symm default\u27e9", "start": [242, 1], "end": [243, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.unique", "code": "protected def unique [Unique \u03b2] (e : \u03b1 \u2243 \u03b2) : Unique \u03b1 := e.symm.surjective.unique", "start": [246, 1], "end": [247, 83], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast", "code": "protected def cast {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : \u03b1 \u2243 \u03b2 :=\n  \u27e8cast h, cast h.symm, fun _ => by cases h; rfl, fun _ => by cases h; rfl\u27e9", "start": [250, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_fn_symm_mk", "code": "@[simp] theorem coe_fn_symm_mk (f : \u03b1 \u2192 \u03b2) (g l r) : ((Equiv.mk f g l r).symm : \u03b2 \u2192 \u03b1) = g", "start": [255, 1], "end": [255, 98], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_refl", "code": "@[simp] theorem coe_refl : (Equiv.refl \u03b1 : \u03b1 \u2192 \u03b1) = id", "start": [258, 1], "end": [258, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.coe_subsingleton", "code": "theorem Perm.coe_subsingleton {\u03b1 : Type*} [Subsingleton \u03b1] (e : Perm \u03b1) : (e : \u03b1 \u2192 \u03b1) = id", "start": [261, 1], "end": [264, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl_apply", "code": "@[simp] theorem refl_apply (x : \u03b1) : Equiv.refl \u03b1 x = x", "start": [269, 1], "end": [269, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_trans", "code": "@[simp] theorem coe_trans (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) : (f.trans g : \u03b1 \u2192 \u03b3) = g \u2218 f", "start": [272, 1], "end": [272, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_apply", "code": "@[simp] theorem trans_apply (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) (a : \u03b1) : (f.trans g) a = g (f a)", "start": [277, 1], "end": [277, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.apply_symm_apply", "code": "@[simp] theorem apply_symm_apply (e : \u03b1 \u2243 \u03b2) (x : \u03b2) : e (e.symm x) = x", "start": [280, 1], "end": [280, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_apply_apply", "code": "@[simp] theorem symm_apply_apply (e : \u03b1 \u2243 \u03b2) (x : \u03b1) : e.symm (e x) = x", "start": [283, 1], "end": [283, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_comp_self", "code": "@[simp] theorem symm_comp_self (e : \u03b1 \u2243 \u03b2) : e.symm \u2218 e = id", "start": [286, 1], "end": [286, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.self_comp_symm", "code": "@[simp] theorem self_comp_symm (e : \u03b1 \u2243 \u03b2) : e \u2218 e.symm = id", "start": [289, 1], "end": [289, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_trans_apply", "code": "@[simp] theorem symm_trans_apply (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) (a : \u03b3) :\n    (f.trans g).symm a = f.symm (g.symm a)", "start": [292, 1], "end": [293, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_symm_apply", "code": "@[simp, nolint simpNF] theorem symm_symm_apply (f : \u03b1 \u2243 \u03b2) (b : \u03b1) : f.symm.symm b = f b", "start": [298, 1], "end": [298, 96], "kind": "commanddeclaration"}, {"full_name": "Equiv.apply_eq_iff_eq", "code": "theorem apply_eq_iff_eq (f : \u03b1 \u2243 \u03b2) {x y : \u03b1} : f x = f y \u2194 x = y", "start": [301, 1], "end": [301, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.apply_eq_iff_eq_symm_apply", "code": "theorem apply_eq_iff_eq_symm_apply (f : \u03b1 \u2243 \u03b2) : f x = y \u2194 x = f.symm y", "start": [304, 1], "end": [306, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast_apply", "code": "@[simp] theorem cast_apply {\u03b1 \u03b2} (h : \u03b1 = \u03b2) (x : \u03b1) : Equiv.cast h x = cast h x", "start": [309, 1], "end": [309, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast_symm", "code": "@[simp] theorem cast_symm {\u03b1 \u03b2} (h : \u03b1 = \u03b2) : (Equiv.cast h).symm = Equiv.cast h.symm", "start": [312, 1], "end": [312, 93], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast_refl", "code": "@[simp] theorem cast_refl {\u03b1} (h : \u03b1 = \u03b1 := rfl) : Equiv.cast h = Equiv.refl \u03b1", "start": [315, 1], "end": [315, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast_trans", "code": "@[simp] theorem cast_trans {\u03b1 \u03b2 \u03b3} (h : \u03b1 = \u03b2) (h2 : \u03b2 = \u03b3) :\n    (Equiv.cast h).trans (Equiv.cast h2) = Equiv.cast (h.trans h2)", "start": [318, 1], "end": [320, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.cast_eq_iff_heq", "code": "theorem cast_eq_iff_heq {\u03b1 \u03b2} (h : \u03b1 = \u03b2) {a : \u03b1} {b : \u03b2} : Equiv.cast h a = b \u2194 HEq a b", "start": [323, 1], "end": [324, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_apply_eq", "code": "theorem symm_apply_eq {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) {x y} : e.symm x = y \u2194 x = e y", "start": [327, 1], "end": [328, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.eq_symm_apply", "code": "theorem eq_symm_apply {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) {x y} : y = e.symm x \u2194 e y = x", "start": [331, 1], "end": [332, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_symm", "code": "@[simp] theorem symm_symm (e : \u03b1 \u2243 \u03b2) : e.symm.symm = e", "start": [335, 1], "end": [335, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_refl", "code": "@[simp] theorem trans_refl (e : \u03b1 \u2243 \u03b2) : e.trans (Equiv.refl \u03b2) = e", "start": [338, 1], "end": [338, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl_symm", "code": "@[simp] theorem refl_symm : (Equiv.refl \u03b1).symm = Equiv.refl \u03b1", "start": [341, 1], "end": [341, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl_trans", "code": "@[simp] theorem refl_trans (e : \u03b1 \u2243 \u03b2) : (Equiv.refl \u03b1).trans e = e", "start": [344, 1], "end": [344, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_trans_self", "code": "@[simp] theorem symm_trans_self (e : \u03b1 \u2243 \u03b2) : e.symm.trans e = Equiv.refl \u03b2", "start": [347, 1], "end": [347, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.self_trans_symm", "code": "@[simp] theorem self_trans_symm (e : \u03b1 \u2243 \u03b2) : e.trans e.symm = Equiv.refl \u03b1", "start": [350, 1], "end": [350, 94], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_assoc", "code": "theorem trans_assoc {\u03b4} (ab : \u03b1 \u2243 \u03b2) (bc : \u03b2 \u2243 \u03b3) (cd : \u03b3 \u2243 \u03b4) :\n    (ab.trans bc).trans cd = ab.trans (bc.trans cd)", "start": [353, 1], "end": [354, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.leftInverse_symm", "code": "theorem leftInverse_symm (f : Equiv \u03b1 \u03b2) : LeftInverse f.symm f", "start": [357, 1], "end": [357, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.rightInverse_symm", "code": "theorem rightInverse_symm (f : Equiv \u03b1 \u03b2) : Function.RightInverse f.symm f", "start": [360, 1], "end": [360, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.injective_comp", "code": "theorem injective_comp (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) : Injective (f \u2218 e) \u2194 Injective f", "start": [363, 1], "end": [364, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_injective", "code": "theorem comp_injective (f : \u03b1 \u2192 \u03b2) (e : \u03b2 \u2243 \u03b3) : Injective (e \u2218 f) \u2194 Injective f", "start": [367, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.surjective_comp", "code": "theorem surjective_comp (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) : Surjective (f \u2218 e) \u2194 Surjective f", "start": [371, 1], "end": [372, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_surjective", "code": "theorem comp_surjective (f : \u03b1 \u2192 \u03b2) (e : \u03b2 \u2243 \u03b3) : Surjective (e \u2218 f) \u2194 Surjective f", "start": [375, 1], "end": [376, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.bijective_comp", "code": "theorem bijective_comp (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) : Bijective (f \u2218 e) \u2194 Bijective f", "start": [379, 1], "end": [380, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_bijective", "code": "theorem comp_bijective (f : \u03b1 \u2192 \u03b2) (e : \u03b2 \u2243 \u03b3) : Bijective (e \u2218 f) \u2194 Bijective f", "start": [383, 1], "end": [384, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr", "code": "def equivCongr (ab : \u03b1 \u2243 \u03b2) (cd : \u03b3 \u2243 \u03b4) : (\u03b1 \u2243 \u03b3) \u2243 (\u03b2 \u2243 \u03b4) where\n  toFun ac := (ab.symm.trans ac).trans cd\n  invFun bd := ab.trans <| bd.trans <| cd.symm\n  left_inv ac := by ext x; simp only [trans_apply, comp_apply, symm_apply_apply]\n  right_inv ac := by ext x; simp only [trans_apply, comp_apply, apply_symm_apply]", "start": [387, 1], "end": [393, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_refl", "code": "@[simp] theorem equivCongr_refl {\u03b1 \u03b2} :\n    (Equiv.refl \u03b1).equivCongr (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u2243 \u03b2)", "start": [396, 1], "end": [397, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_symm", "code": "@[simp] theorem equivCongr_symm {\u03b4} (ab : \u03b1 \u2243 \u03b2) (cd : \u03b3 \u2243 \u03b4) :\n    (ab.equivCongr cd).symm = ab.symm.equivCongr cd.symm", "start": [400, 1], "end": [401, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_trans", "code": "@[simp] theorem equivCongr_trans {\u03b4 \u03b5 \u03b6} (ab : \u03b1 \u2243 \u03b2) (de : \u03b4 \u2243 \u03b5) (bc : \u03b2 \u2243 \u03b3) (ef : \u03b5 \u2243 \u03b6) :\n    (ab.equivCongr de).trans (bc.equivCongr ef) = (ab.trans bc).equivCongr (de.trans ef)", "start": [404, 1], "end": [406, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_refl_left", "code": "@[simp] theorem equivCongr_refl_left {\u03b1 \u03b2 \u03b3} (bg : \u03b2 \u2243 \u03b3) (e : \u03b1 \u2243 \u03b2) :\n    (Equiv.refl \u03b1).equivCongr bg e = e.trans bg", "start": [409, 1], "end": [410, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_refl_right", "code": "@[simp] theorem equivCongr_refl_right {\u03b1 \u03b2} (ab e : \u03b1 \u2243 \u03b2) :\n    ab.equivCongr (Equiv.refl \u03b2) e = ab.symm.trans e", "start": [413, 1], "end": [414, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivCongr_apply_apply", "code": "@[simp] theorem equivCongr_apply_apply {\u03b4} (ab : \u03b1 \u2243 \u03b2) (cd : \u03b3 \u2243 \u03b4) (e : \u03b1 \u2243 \u03b3) (x) :\n    ab.equivCongr cd e x = cd (e (ab.symm x))", "start": [417, 1], "end": [418, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr", "code": "def permCongr : Perm \u03b1' \u2243 Perm \u03b2' := equivCongr e e", "start": [425, 1], "end": [426, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_def", "code": "theorem permCongr_def (p : Equiv.Perm \u03b1') : e.permCongr p = (e.symm.trans p).trans e", "start": [429, 1], "end": [429, 92], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_refl", "code": "@[simp] theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _", "start": [432, 1], "end": [433, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_symm", "code": "@[simp] theorem permCongr_symm : e.permCongr.symm = e.symm.permCongr", "start": [436, 1], "end": [436, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_apply", "code": "@[simp] theorem permCongr_apply (p : Equiv.Perm \u03b1') (x) : e.permCongr p x = e (p (e.symm x))", "start": [439, 1], "end": [439, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_symm_apply", "code": "theorem permCongr_symm_apply (p : Equiv.Perm \u03b2') (x) :\n    e.permCongr.symm p x = e.symm (p (e x))", "start": [442, 1], "end": [443, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.permCongr_trans", "code": "theorem permCongr_trans (p p' : Equiv.Perm \u03b1') :\n    (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p')", "start": [446, 1], "end": [448, 78], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivOfIsEmpty", "code": "def equivOfIsEmpty (\u03b1 \u03b2 : Sort*) [IsEmpty \u03b1] [IsEmpty \u03b2] : \u03b1 \u2243 \u03b2 :=\n  \u27e8isEmptyElim, isEmptyElim, isEmptyElim, isEmptyElim\u27e9", "start": [453, 1], "end": [455, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivEmpty", "code": "def equivEmpty (\u03b1 : Sort u) [IsEmpty \u03b1] : \u03b1 \u2243 Empty := equivOfIsEmpty \u03b1 _", "start": [458, 1], "end": [459, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivPEmpty", "code": "def equivPEmpty (\u03b1 : Sort v) [IsEmpty \u03b1] : \u03b1 \u2243 PEmpty.{u} := equivOfIsEmpty \u03b1 _", "start": [462, 1], "end": [463, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivEmptyEquiv", "code": "def equivEmptyEquiv (\u03b1 : Sort u) : \u03b1 \u2243 Empty \u2243 IsEmpty \u03b1 :=\n  \u27e8fun e => Function.isEmpty e, @equivEmpty \u03b1, fun e => ext fun x => (e x).elim, fun _ => rfl\u27e9", "start": [466, 1], "end": [468, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.propEquivPEmpty", "code": "def propEquivPEmpty {p : Prop} (h : \u00acp) : p \u2243 PEmpty := @equivPEmpty p <| IsEmpty.prop_iff.2 h", "start": [471, 1], "end": [472, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivOfUnique", "code": "def equivOfUnique (\u03b1 \u03b2 : Sort _) [Unique.{u} \u03b1] [Unique.{v} \u03b2] : \u03b1 \u2243 \u03b2 where\n  toFun := default\n  invFun := default\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [475, 1], "end": [480, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.equivPUnit", "code": "def equivPUnit (\u03b1 : Sort u) [Unique \u03b1] : \u03b1 \u2243 PUnit.{v} := equivOfUnique \u03b1 _", "start": [483, 1], "end": [484, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.propEquivPUnit", "code": "def propEquivPUnit {p : Prop} (h : p) : p \u2243 PUnit.{0} := @equivPUnit p <| uniqueProp h", "start": [487, 1], "end": [488, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.ulift", "code": "@[simps (config := { fullyApplied := false }) apply]\nprotected def ulift {\u03b1 : Type v} : ULift.{u} \u03b1 \u2243 \u03b1 :=\n  \u27e8ULift.down, ULift.up, ULift.up_down, ULift.down_up.{v, u}\u27e9", "start": [491, 1], "end": [494, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.plift", "code": "@[simps (config := { fullyApplied := false }) apply]\nprotected def plift : PLift \u03b1 \u2243 \u03b1 := \u27e8PLift.down, PLift.up, PLift.up_down, PLift.down_up\u27e9", "start": [498, 1], "end": [500, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofIff", "code": "def ofIff {P Q : Prop} (h : P \u2194 Q) : P \u2243 Q := \u27e8h.mp, h.mpr, fun _ => rfl, fun _ => rfl\u27e9", "start": [504, 1], "end": [505, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr", "code": "@[simps apply]\ndef arrowCongr {\u03b1\u2081 \u03b2\u2081 \u03b1\u2082 \u03b2\u2082 : Sort*} (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) : (\u03b1\u2081 \u2192 \u03b2\u2081) \u2243 (\u03b1\u2082 \u2192 \u03b2\u2082) where\n  toFun f := e\u2082 \u2218 f \u2218 e\u2081.symm\n  invFun f := e\u2082.symm \u2218 f \u2218 e\u2081\n  left_inv f := funext fun x => by simp only [comp_apply, symm_apply_apply]\n  right_inv f := funext fun x => by simp only [comp_apply, apply_symm_apply]", "start": [508, 1], "end": [516, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr_comp", "code": "theorem arrowCongr_comp {\u03b1\u2081 \u03b2\u2081 \u03b3\u2081 \u03b1\u2082 \u03b2\u2082 \u03b3\u2082 : Sort*} (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) (ec : \u03b3\u2081 \u2243 \u03b3\u2082)\n    (f : \u03b1\u2081 \u2192 \u03b2\u2081) (g : \u03b2\u2081 \u2192 \u03b3\u2081) :\n    arrowCongr ea ec (g \u2218 f) = arrowCongr eb ec g \u2218 arrowCongr ea eb f", "start": [520, 1], "end": [523, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr_refl", "code": "@[simp] theorem arrowCongr_refl {\u03b1 \u03b2 : Sort*} :\n    arrowCongr (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u2192 \u03b2)", "start": [526, 1], "end": [527, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr_trans", "code": "@[simp] theorem arrowCongr_trans (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2081' : \u03b2\u2081 \u2243 \u03b2\u2082) (e\u2082 : \u03b1\u2082 \u2243 \u03b1\u2083) (e\u2082' : \u03b2\u2082 \u2243 \u03b2\u2083) :\n    arrowCongr (e\u2081.trans e\u2082) (e\u2081'.trans e\u2082') = (arrowCongr e\u2081 e\u2081').trans (arrowCongr e\u2082 e\u2082')", "start": [530, 1], "end": [531, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr_symm", "code": "@[simp] theorem arrowCongr_symm (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    (arrowCongr e\u2081 e\u2082).symm = arrowCongr e\u2081.symm e\u2082.symm", "start": [534, 1], "end": [535, 64], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr'", "code": "@[simps! apply]\ndef arrowCongr' {\u03b1\u2081 \u03b2\u2081 \u03b1\u2082 \u03b2\u2082 : Type*} (h\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082) (h\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082) : (\u03b1\u2081 \u2192 \u03b2\u2081) \u2243 (\u03b1\u2082 \u2192 \u03b2\u2082) :=\n  Equiv.arrowCongr h\u03b1 h\u03b2", "start": [538, 1], "end": [546, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr'_refl", "code": "@[simp] theorem arrowCongr'_refl {\u03b1 \u03b2 : Type*} :\n    arrowCongr' (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u2192 \u03b2)", "start": [550, 1], "end": [551, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr'_trans", "code": "@[simp] theorem arrowCongr'_trans\n    (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2081' : \u03b2\u2081 \u2243 \u03b2\u2082) (e\u2082 : \u03b1\u2082 \u2243 \u03b1\u2083) (e\u2082' : \u03b2\u2082 \u2243 \u03b2\u2083) :\n    arrowCongr' (e\u2081.trans e\u2082) (e\u2081'.trans e\u2082') = (arrowCongr' e\u2081 e\u2081').trans (arrowCongr' e\u2082 e\u2082')", "start": [554, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowCongr'_symm", "code": "@[simp] theorem arrowCongr'_symm (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    (arrowCongr' e\u2081 e\u2082).symm = arrowCongr' e\u2081.symm e\u2082.symm", "start": [560, 1], "end": [561, 66], "kind": "commanddeclaration"}, {"full_name": "Equiv.conj", "code": "@[simps! apply] def conj (e : \u03b1 \u2243 \u03b2) : (\u03b1 \u2192 \u03b1) \u2243 (\u03b2 \u2192 \u03b2) := arrowCongr e e", "start": [564, 1], "end": [565, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.conj_refl", "code": "@[simp] theorem conj_refl : conj (Equiv.refl \u03b1) = Equiv.refl (\u03b1 \u2192 \u03b1)", "start": [569, 1], "end": [569, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.conj_symm", "code": "@[simp] theorem conj_symm (e : \u03b1 \u2243 \u03b2) : e.conj.symm = e.symm.conj", "start": [572, 1], "end": [572, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.conj_trans", "code": "@[simp] theorem conj_trans (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) :\n    (e\u2081.trans e\u2082).conj = e\u2081.conj.trans e\u2082.conj", "start": [575, 1], "end": [576, 54], "kind": "commanddeclaration"}, {"full_name": "Equiv.conj_comp", "code": "theorem conj_comp (e : \u03b1 \u2243 \u03b2) (f\u2081 f\u2082 : \u03b1 \u2192 \u03b1) : e.conj (f\u2081 \u2218 f\u2082) = e.conj f\u2081 \u2218 e.conj f\u2082", "start": [582, 1], "end": [583, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.eq_comp_symm", "code": "theorem eq_comp_symm {\u03b1 \u03b2 \u03b3} (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b3) : f = g \u2218 e.symm \u2194 f \u2218 e = g", "start": [586, 1], "end": [587, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_symm_eq", "code": "theorem comp_symm_eq {\u03b1 \u03b2 \u03b3} (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b3) : g \u2218 e.symm = f \u2194 g = f \u2218 e", "start": [590, 1], "end": [591, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.eq_symm_comp", "code": "theorem eq_symm_comp {\u03b1 \u03b2 \u03b3} (e : \u03b1 \u2243 \u03b2) (f : \u03b3 \u2192 \u03b1) (g : \u03b3 \u2192 \u03b2) : f = e.symm \u2218 g \u2194 e \u2218 f = g", "start": [594, 1], "end": [595, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_comp_eq", "code": "theorem symm_comp_eq {\u03b1 \u03b2 \u03b3} (e : \u03b1 \u2243 \u03b2) (f : \u03b3 \u2192 \u03b1) (g : \u03b3 \u2192 \u03b2) : e.symm \u2218 g = f \u2194 g = e \u2218 f", "start": [598, 1], "end": [599, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.punitEquivPUnit", "code": "def punitEquivPUnit : PUnit.{v} \u2243 PUnit.{w} :=\n  \u27e8fun _ => .unit, fun _ => .unit, fun \u27e8\u27e9 => rfl, fun \u27e8\u27e9 => rfl\u27e9", "start": [602, 1], "end": [604, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.propEquivBool", "code": "noncomputable def propEquivBool : Prop \u2243 Bool where\n  toFun p := @decide p (Classical.propDecidable _)\n  invFun b := b\n  left_inv p := by simp [@Bool.decide_iff p (Classical.propDecidable _)]\n  right_inv b := by cases b <;> simp", "start": [607, 1], "end": [612, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowPUnitEquivPUnit", "code": "def arrowPUnitEquivPUnit (\u03b1 : Sort*) : (\u03b1 \u2192 PUnit.{v}) \u2243 PUnit.{w} :=\n  \u27e8fun _ => .unit, fun _ _ => .unit, fun _ => rfl, fun _ => rfl\u27e9", "start": [617, 1], "end": [619, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.piSubsingleton", "code": "@[simps] def piSubsingleton (\u03b2 : \u03b1 \u2192 Sort*) [Subsingleton \u03b1] (a : \u03b1) : (\u2200 a', \u03b2 a') \u2243 \u03b2 a where\n  toFun := eval a\n  invFun x b := cast (congr_arg \u03b2 <| Subsingleton.elim a b) x\n  left_inv _ := funext fun b => by rw [Subsingleton.elim b a]; rfl\n  right_inv _ := rfl", "start": [622, 1], "end": [628, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.funUnique", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef funUnique (\u03b1 \u03b2) [Unique.{u} \u03b1] : (\u03b1 \u2192 \u03b2) \u2243 \u03b2 := piSubsingleton _ default", "start": [633, 1], "end": [635, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.punitArrowEquiv", "code": "def punitArrowEquiv (\u03b1 : Sort*) : (PUnit.{u} \u2192 \u03b1) \u2243 \u03b1 := funUnique PUnit.{u} \u03b1", "start": [639, 1], "end": [640, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.trueArrowEquiv", "code": "def trueArrowEquiv (\u03b1 : Sort*) : (True \u2192 \u03b1) \u2243 \u03b1 := funUnique _ _", "start": [643, 1], "end": [644, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowPUnitOfIsEmpty", "code": "def arrowPUnitOfIsEmpty (\u03b1 \u03b2 : Sort*) [IsEmpty \u03b1] : (\u03b1 \u2192 \u03b2) \u2243 PUnit.{u} where\n  toFun _ := PUnit.unit\n  invFun _ := isEmptyElim\n  left_inv _ := funext isEmptyElim\n  right_inv _ := rfl", "start": [647, 1], "end": [652, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.emptyArrowEquivPUnit", "code": "def emptyArrowEquivPUnit (\u03b1 : Sort*) : (Empty \u2192 \u03b1) \u2243 PUnit.{u} := arrowPUnitOfIsEmpty _ _", "start": [655, 1], "end": [656, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.pemptyArrowEquivPUnit", "code": "def pemptyArrowEquivPUnit (\u03b1 : Sort*) : (PEmpty \u2192 \u03b1) \u2243 PUnit.{u} := arrowPUnitOfIsEmpty _ _", "start": [659, 1], "end": [660, 92], "kind": "commanddeclaration"}, {"full_name": "Equiv.falseArrowEquivPUnit", "code": "def falseArrowEquivPUnit (\u03b1 : Sort*) : (False \u2192 \u03b1) \u2243 PUnit.{u} := arrowPUnitOfIsEmpty _ _", "start": [663, 1], "end": [664, 90], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaEquivSigma", "code": "@[simps apply symm_apply]\ndef psigmaEquivSigma {\u03b1} (\u03b2 : \u03b1 \u2192 Type*) : (\u03a3' i, \u03b2 i) \u2243 \u03a3 i, \u03b2 i where\n  toFun a := \u27e8a.1, a.2\u27e9\n  invFun a := \u27e8a.1, a.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [671, 1], "end": [677, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaEquivSigmaPLift", "code": "@[simps apply symm_apply]\ndef psigmaEquivSigmaPLift {\u03b1} (\u03b2 : \u03b1 \u2192 Sort*) : (\u03a3' i, \u03b2 i) \u2243 \u03a3 i : PLift \u03b1, PLift (\u03b2 i.down) where\n  toFun a := \u27e8PLift.up a.1, PLift.up a.2\u27e9\n  invFun a := \u27e8a.1.down, a.2.down\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [682, 1], "end": [688, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaCongrRight", "code": "@[simps apply]\ndef psigmaCongrRight {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Sort*} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) : (\u03a3' a, \u03b2\u2081 a) \u2243 \u03a3' a, \u03b2\u2082 a where\n  toFun a := \u27e8a.1, F a.1 a.2\u27e9\n  invFun a := \u27e8a.1, (F a.1).symm a.2\u27e9\n  left_inv | \u27e8a, b\u27e9 => congr_arg (PSigma.mk a) <| symm_apply_apply (F a) b\n  right_inv | \u27e8a, b\u27e9 => congr_arg (PSigma.mk a) <| apply_symm_apply (F a) b", "start": [693, 1], "end": [700, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaCongrRight_trans", "code": "theorem psigmaCongrRight_trans {\u03b1} {\u03b2\u2081 \u03b2\u2082 \u03b2\u2083 : \u03b1 \u2192 Sort*}\n    (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) (G : \u2200 a, \u03b2\u2082 a \u2243 \u03b2\u2083 a) :\n    (psigmaCongrRight F).trans (psigmaCongrRight G) =\n      psigmaCongrRight fun a => (F a).trans (G a)", "start": [705, 1], "end": [708, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaCongrRight_symm", "code": "theorem psigmaCongrRight_symm {\u03b1} {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Sort*} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) :\n    (psigmaCongrRight F).symm = psigmaCongrRight fun a => (F a).symm", "start": [712, 1], "end": [713, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaCongrRight_refl", "code": "theorem psigmaCongrRight_refl {\u03b1} {\u03b2 : \u03b1 \u2192 Sort*} :\n    (psigmaCongrRight fun a => Equiv.refl (\u03b2 a)) = Equiv.refl (\u03a3' a, \u03b2 a)", "start": [717, 1], "end": [718, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrRight", "code": "@[simps apply]\ndef sigmaCongrRight {\u03b1} {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Type*} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) : (\u03a3 a, \u03b2\u2081 a) \u2243 \u03a3 a, \u03b2\u2082 a where\n  toFun a := \u27e8a.1, F a.1 a.2\u27e9\n  invFun a := \u27e8a.1, (F a.1).symm a.2\u27e9\n  left_inv | \u27e8a, b\u27e9 => congr_arg (Sigma.mk a) <| symm_apply_apply (F a) b\n  right_inv | \u27e8a, b\u27e9 => congr_arg (Sigma.mk a) <| apply_symm_apply (F a) b", "start": [721, 1], "end": [728, 75], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrRight_trans", "code": "theorem sigmaCongrRight_trans {\u03b1} {\u03b2\u2081 \u03b2\u2082 \u03b2\u2083 : \u03b1 \u2192 Type*}\n    (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) (G : \u2200 a, \u03b2\u2082 a \u2243 \u03b2\u2083 a) :\n    (sigmaCongrRight F).trans (sigmaCongrRight G) =\n      sigmaCongrRight fun a => (F a).trans (G a)", "start": [733, 1], "end": [736, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrRight_symm", "code": "theorem sigmaCongrRight_symm {\u03b1} {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Type*} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) :\n    (sigmaCongrRight F).symm = sigmaCongrRight fun a => (F a).symm", "start": [740, 1], "end": [741, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrRight_refl", "code": "theorem sigmaCongrRight_refl {\u03b1} {\u03b2 : \u03b1 \u2192 Type*} :\n    (sigmaCongrRight fun a => Equiv.refl (\u03b2 a)) = Equiv.refl (\u03a3 a, \u03b2 a)", "start": [745, 1], "end": [746, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.psigmaEquivSubtype", "code": "def psigmaEquivSubtype {\u03b1 : Type v} (P : \u03b1 \u2192 Prop) : (\u03a3' i, P i) \u2243 Subtype P where\n  toFun x := \u27e8x.1, x.2\u27e9\n  invFun x := \u27e8x.1, x.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [749, 1], "end": [754, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaPLiftEquivSubtype", "code": "def sigmaPLiftEquivSubtype {\u03b1 : Type v} (P : \u03b1 \u2192 Prop) : (\u03a3 i, PLift (P i)) \u2243 Subtype P :=\n  ((psigmaEquivSigma _).symm.trans\n    (psigmaCongrRight fun _ => Equiv.plift)).trans (psigmaEquivSubtype P)", "start": [757, 1], "end": [760, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaULiftPLiftEquivSubtype", "code": "def sigmaULiftPLiftEquivSubtype {\u03b1 : Type v} (P : \u03b1 \u2192 Prop) :\n    (\u03a3 i, ULift (PLift (P i))) \u2243 Subtype P :=\n  (sigmaCongrRight fun _ => Equiv.ulift).trans (sigmaPLiftEquivSubtype P)", "start": [763, 1], "end": [768, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight", "code": "@[reducible] def sigmaCongrRight {\u03b1} {\u03b2 : \u03b1 \u2192 Sort _} (F : \u2200 a, Perm (\u03b2 a)) : Perm (\u03a3 a, \u03b2 a) :=\n  Equiv.sigmaCongrRight F", "start": [773, 1], "end": [775, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_trans", "code": "@[simp] theorem sigmaCongrRight_trans {\u03b1} {\u03b2 : \u03b1 \u2192 Sort _}\n    (F : \u2200 a, Perm (\u03b2 a)) (G : \u2200 a, Perm (\u03b2 a)) :\n    (sigmaCongrRight F).trans (sigmaCongrRight G) = sigmaCongrRight fun a => (F a).trans (G a)", "start": [778, 1], "end": [781, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_symm", "code": "@[simp] theorem sigmaCongrRight_symm {\u03b1} {\u03b2 : \u03b1 \u2192 Sort _} (F : \u2200 a, Perm (\u03b2 a)) :\n    (sigmaCongrRight F).symm = sigmaCongrRight fun a => (F a).symm", "start": [784, 1], "end": [786, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sigmaCongrRight_refl", "code": "@[simp] theorem sigmaCongrRight_refl {\u03b1} {\u03b2 : \u03b1 \u2192 Sort _} :\n    (sigmaCongrRight fun a => Equiv.refl (\u03b2 a)) = Equiv.refl (\u03a3 a, \u03b2 a)", "start": [789, 1], "end": [791, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrLeft", "code": "@[simps apply] def sigmaCongrLeft {\u03b2 : \u03b1\u2082 \u2192 Sort _} (e : \u03b1\u2081 \u2243 \u03b1\u2082) :\n    (\u03a3 a : \u03b1\u2081, \u03b2 (e a)) \u2243 \u03a3 a : \u03b1\u2082, \u03b2 a where\n  toFun a := \u27e8e a.1, a.2\u27e9\n  invFun a := \u27e8e.symm a.1, (e.right_inv' a.1).symm \u25b8 a.2\u27e9\n  left_inv := fun \u27e8a, b\u27e9 =>\n    match (motive := \u2200 a' (h : a' = a), Sigma.mk _ (congr_arg e h.symm \u25b8 b) = \u27e8a, b\u27e9)\n      e.symm (e a), e.left_inv a with\n    | _, rfl => rfl\n  right_inv := fun \u27e8a, b\u27e9 =>\n    match (motive := \u2200 a' (h : a' = a), Sigma.mk a' (h.symm \u25b8 b) = \u27e8a, b\u27e9)\n      e (e.symm a), e.apply_symm_apply _ with\n    | _, rfl => rfl", "start": [796, 1], "end": [809, 20], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrLeft'", "code": "def sigmaCongrLeft' {\u03b1\u2081 \u03b1\u2082} {\u03b2 : \u03b1\u2081 \u2192 Sort _} (f : \u03b1\u2081 \u2243 \u03b1\u2082) :\n    (\u03a3 a : \u03b1\u2081, \u03b2 a) \u2243 \u03a3 a : \u03b1\u2082, \u03b2 (f.symm a) := (sigmaCongrLeft f.symm).symm", "start": [813, 1], "end": [815, 77], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongr", "code": "def sigmaCongr {\u03b1\u2081 \u03b1\u2082} {\u03b2\u2081 : \u03b1\u2081 \u2192 Sort _} {\u03b2\u2082 : \u03b1\u2082 \u2192 Sort _} (f : \u03b1\u2081 \u2243 \u03b1\u2082)\n    (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 (f a)) : Sigma \u03b2\u2081 \u2243 Sigma \u03b2\u2082 :=\n  (sigmaCongrRight F).trans (sigmaCongrLeft f)", "start": [818, 1], "end": [822, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaEquivProd", "code": "@[simps (config := { attrs := [`mfld_simps] }) apply symm_apply]\ndef sigmaEquivProd (\u03b1 \u03b2 : Type*) : (\u03a3 _ : \u03b1, \u03b2) \u2243 \u03b1 \u00d7 \u03b2 :=\n  \u27e8fun a => \u27e8a.1, a.2\u27e9, fun a => \u27e8a.1, a.2\u27e9, fun \u27e8_, _\u27e9 => rfl, fun \u27e8_, _\u27e9 => rfl\u27e9", "start": [825, 1], "end": [828, 83], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaEquivProdOfEquiv", "code": "def sigmaEquivProdOfEquiv {\u03b1 \u03b2} {\u03b2\u2081 : \u03b1 \u2192 Sort _} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2) : Sigma \u03b2\u2081 \u2243 \u03b1 \u00d7 \u03b2 :=\n  (sigmaCongrRight F).trans (sigmaEquivProd \u03b1 \u03b2)", "start": [833, 1], "end": [836, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaAssoc", "code": "def sigmaAssoc {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} (\u03b3 : \u2200 a : \u03b1, \u03b2 a \u2192 Type*) :\n    (\u03a3 ab : \u03a3 a : \u03b1, \u03b2 a, \u03b3 ab.1 ab.2) \u2243 \u03a3 a : \u03b1, \u03a3 b : \u03b2 a, \u03b3 a b where\n  toFun x := \u27e8x.1.1, \u27e8x.1.2, x.2\u27e9\u27e9\n  invFun x := \u27e8\u27e8x.1, x.2.1\u27e9, x.2.2\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [839, 1], "end": [845, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.exists_unique_congr", "code": "protected theorem exists_unique_congr {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop}\n    (f : \u03b1 \u2243 \u03b2) (h : \u2200 {x}, p x \u2194 q (f x)) : (\u2203! x, p x) \u2194 \u2203! y, q y", "start": [850, 1], "end": [856, 97], "kind": "commanddeclaration"}, {"full_name": "Equiv.exists_unique_congr_left'", "code": "protected theorem exists_unique_congr_left' {p : \u03b1 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) :\n    (\u2203! x, p x) \u2194 \u2203! y, p (f.symm y)", "start": [859, 1], "end": [860, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.exists_unique_congr_left", "code": "protected theorem exists_unique_congr_left {p : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) :\n    (\u2203! x, p (f x)) \u2194 \u2203! y, p y", "start": [863, 1], "end": [864, 81], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall_congr", "code": "protected theorem forall_congr {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2)\n    (h : \u2200 {x}, p x \u2194 q (f x)) : (\u2200 x, p x) \u2194 (\u2200 y, q y)", "start": [867, 1], "end": [871, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall_congr'", "code": "protected theorem forall_congr' {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2)\n    (h : \u2200 {x}, p (f.symm x) \u2194 q x) : (\u2200 x, p x) \u2194 \u2200 y, q y", "start": [874, 1], "end": [876, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall\u2082_congr", "code": "protected theorem forall\u2082_congr {p : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Prop} {q : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Prop} (e\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082)\n    (e\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082) (h : \u2200 {x y}, p x y \u2194 q (e\u03b1 x) (e\u03b2 y)) : (\u2200 x y, p x y) \u2194 \u2200 x y, q x y", "start": [886, 1], "end": [888, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall\u2082_congr'", "code": "protected theorem forall\u2082_congr' {p : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Prop} {q : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Prop}\n    (e\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082) (h : \u2200 {x y}, p (e\u03b1.symm x) (e\u03b2.symm y) \u2194 q x y) :\n    (\u2200 x y, p x y) \u2194 \u2200 x y, q x y", "start": [891, 1], "end": [893, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall\u2083_congr", "code": "protected theorem forall\u2083_congr {p : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 \u03b3\u2081 \u2192 Prop} {q : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 \u03b3\u2082 \u2192 Prop}\n    (e\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082) (e\u03b3 : \u03b3\u2081 \u2243 \u03b3\u2082) (h : \u2200 {x y z}, p x y z \u2194 q (e\u03b1 x) (e\u03b2 y) (e\u03b3 z)) :\n    (\u2200 x y z, p x y z) \u2194 \u2200 x y z, q x y z", "start": [896, 1], "end": [899, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall\u2083_congr'", "code": "protected theorem forall\u2083_congr' {p : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 \u03b3\u2081 \u2192 Prop} {q : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 \u03b3\u2082 \u2192 Prop}\n    (e\u03b1 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u03b2 : \u03b2\u2081 \u2243 \u03b2\u2082) (e\u03b3 : \u03b3\u2081 \u2243 \u03b3\u2082)\n    (h : \u2200 {x y z}, p (e\u03b1.symm x) (e\u03b2.symm y) (e\u03b3.symm z) \u2194 q x y z) :\n    (\u2200 x y z, p x y z) \u2194 \u2200 x y z, q x y z", "start": [902, 1], "end": [906, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall_congr_left'", "code": "protected theorem forall_congr_left' {p : \u03b1 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) : (\u2200 x, p x) \u2194 \u2200 y, p (f.symm y)", "start": [909, 1], "end": [910, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.forall_congr_left", "code": "protected theorem forall_congr_left {p : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2) : (\u2200 x, p (f x)) \u2194 \u2200 y, p y", "start": [913, 1], "end": [914, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.exists_congr_left", "code": "protected theorem exists_congr_left {\u03b1 \u03b2} (f : \u03b1 \u2243 \u03b2) {p : \u03b1 \u2192 Prop} :\n    (\u2203 a, p a) \u2194 \u2203 b, p (f.symm b)", "start": [917, 1], "end": [919, 64], "kind": "commanddeclaration"}, {"full_name": "Quot.congr", "code": "protected def congr {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2)\n    (eq : \u2200 a\u2081 a\u2082, ra a\u2081 a\u2082 \u2194 rb (e a\u2081) (e a\u2082)) : Quot ra \u2243 Quot rb where\n  toFun := Quot.map e fun a\u2081 a\u2082 => (eq a\u2081 a\u2082).1\n  invFun := Quot.map e.symm fun b\u2081 b\u2082 h =>\n    (eq (e.symm b\u2081) (e.symm b\u2082)).2\n      ((e.apply_symm_apply b\u2081).symm \u25b8 (e.apply_symm_apply b\u2082).symm \u25b8 h)\n  left_inv := by rintro \u27e8a\u27e9; simp only [Quot.map, Equiv.symm_apply_apply]\n  right_inv := by rintro \u27e8a\u27e9; simp only [Quot.map, Equiv.apply_symm_apply]", "start": [926, 1], "end": [935, 75], "kind": "commanddeclaration"}, {"full_name": "Quot.congr_mk", "code": "@[simp] theorem congr_mk {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2)\n    (eq : \u2200 a\u2081 a\u2082 : \u03b1, ra a\u2081 a\u2082 \u2194 rb (e a\u2081) (e a\u2082)) (a : \u03b1) :\n    Quot.congr e eq (Quot.mk ra a) = Quot.mk rb (e a)", "start": [938, 1], "end": [940, 61], "kind": "commanddeclaration"}, {"full_name": "Quot.congrRight", "code": "protected def congrRight {r r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (eq : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2194 r' a\u2081 a\u2082) :\n    Quot r \u2243 Quot r' := Quot.congr (Equiv.refl \u03b1) eq", "start": [943, 1], "end": [946, 53], "kind": "commanddeclaration"}, {"full_name": "Quot.congrLeft", "code": "protected def congrLeft {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) :\n    Quot r \u2243 Quot fun b b' => r (e.symm b) (e.symm b') :=\n  Quot.congr e fun _ _ => by simp only [e.symm_apply_apply]", "start": [949, 1], "end": [953, 60], "kind": "commanddeclaration"}, {"full_name": "Quotient.congr", "code": "protected def congr {ra : Setoid \u03b1} {rb : Setoid \u03b2} (e : \u03b1 \u2243 \u03b2)\n    (eq : \u2200 a\u2081 a\u2082, @Setoid.r \u03b1 ra a\u2081 a\u2082 \u2194 @Setoid.r \u03b2 rb (e a\u2081) (e a\u2082)) :\n    Quotient ra \u2243 Quotient rb := Quot.congr e eq", "start": [960, 1], "end": [964, 49], "kind": "commanddeclaration"}, {"full_name": "Quotient.congr_mk", "code": "@[simp] theorem congr_mk {ra : Setoid \u03b1} {rb : Setoid \u03b2} (e : \u03b1 \u2243 \u03b2)\n    (eq : \u2200 a\u2081 a\u2082 : \u03b1, Setoid.r a\u2081 a\u2082 \u2194 Setoid.r (e a\u2081) (e a\u2082)) (a : \u03b1) :\n    Quotient.congr e eq (Quotient.mk ra a) = Quotient.mk rb (e a)", "start": [967, 1], "end": [969, 73], "kind": "commanddeclaration"}, {"full_name": "Quotient.congrRight", "code": "protected def congrRight {r r' : Setoid \u03b1}\n    (eq : \u2200 a\u2081 a\u2082, @Setoid.r \u03b1 r a\u2081 a\u2082 \u2194 @Setoid.r \u03b1 r' a\u2081 a\u2082) : Quotient r \u2243 Quotient r' :=\n  Quot.congrRight eq", "start": [972, 1], "end": [976, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Nontrivial/Defs.lean", "imports": ["Mathlib/Init/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nontrivial", "code": "class Nontrivial (\u03b1 : Type*) : Prop where\n  \n  exists_pair_ne : \u2203 x y : \u03b1, x \u2260 y", "start": [27, 1], "end": [31, 36], "kind": "commanddeclaration"}, {"full_name": "nontrivial_iff", "code": "theorem nontrivial_iff : Nontrivial \u03b1 \u2194 \u2203 x y : \u03b1, x \u2260 y", "start": [34, 1], "end": [35, 42], "kind": "commanddeclaration"}, {"full_name": "exists_pair_ne", "code": "theorem exists_pair_ne (\u03b1 : Type*) [Nontrivial \u03b1] : \u2203 x y : \u03b1, x \u2260 y", "start": [38, 1], "end": [39, 28], "kind": "commanddeclaration"}, {"full_name": "Decidable.exists_ne", "code": "protected theorem Decidable.exists_ne [Nontrivial \u03b1] [DecidableEq \u03b1] (x : \u03b1) : \u2203 y, y \u2260 x", "start": [43, 1], "end": [48, 26], "kind": "commanddeclaration"}, {"full_name": "exists_ne", "code": "theorem exists_ne [Nontrivial \u03b1] (x : \u03b1) : \u2203 y, y \u2260 x", "start": [51, 1], "end": [51, 79], "kind": "commanddeclaration"}, {"full_name": "nontrivial_of_ne", "code": "theorem nontrivial_of_ne (x y : \u03b1) (h : x \u2260 y) : Nontrivial \u03b1", "start": [55, 1], "end": [56, 14], "kind": "commanddeclaration"}, {"full_name": "nontrivial_iff_exists_ne", "code": "theorem nontrivial_iff_exists_ne (x : \u03b1) : Nontrivial \u03b1 \u2194 \u2203 y, y \u2260 x", "start": [59, 1], "end": [60, 68], "kind": "commanddeclaration"}, {"full_name": "Nontrivial.to_nonempty", "code": "instance (priority := 500) Nontrivial.to_nonempty [Nontrivial \u03b1] : Nonempty \u03b1 :=\n  let \u27e8x, _\u27e9 := _root_.exists_pair_ne \u03b1\n  \u27e8x\u27e9", "start": [66, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "subsingleton_iff", "code": "theorem subsingleton_iff : Subsingleton \u03b1 \u2194 \u2200 x y : \u03b1, x = y", "start": [75, 1], "end": [78, 42], "kind": "commanddeclaration"}, {"full_name": "not_nontrivial_iff_subsingleton", "code": "theorem not_nontrivial_iff_subsingleton : \u00acNontrivial \u03b1 \u2194 Subsingleton \u03b1", "start": [81, 1], "end": [82, 76], "kind": "commanddeclaration"}, {"full_name": "not_nontrivial", "code": "theorem not_nontrivial (\u03b1) [Subsingleton \u03b1] : \u00acNontrivial \u03b1", "start": [85, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "not_subsingleton", "code": "theorem not_subsingleton (\u03b1) [Nontrivial \u03b1] : \u00acSubsingleton \u03b1", "start": [89, 1], "end": [90, 32], "kind": "commanddeclaration"}, {"full_name": "subsingleton_or_nontrivial", "code": "theorem subsingleton_or_nontrivial (\u03b1 : Type*) : Subsingleton \u03b1 \u2228 Nontrivial \u03b1", "start": [93, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "false_of_nontrivial_of_subsingleton", "code": "theorem false_of_nontrivial_of_subsingleton (\u03b1 : Type*) [Nontrivial \u03b1] [Subsingleton \u03b1] : False", "start": [99, 1], "end": [100, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nontrivial", "code": "protected theorem Function.Surjective.nontrivial [Nontrivial \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Surjective f) : Nontrivial \u03b1", "start": [103, 1], "end": [112, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MLList/Basic.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.singletonM", "code": "def singletonM [Monad m] (x : m \u03b1) : MLList m \u03b1 :=\n  .squash fun _ => do return .cons (\u2190 x) .nil", "start": [18, 1], "end": [20, 46], "kind": "commanddeclaration"}, {"full_name": "MLList.singleton", "code": "def singleton [Monad m] (x : \u03b1) : MLList m \u03b1 :=\n  .singletonM (pure x)", "start": [22, 1], "end": [24, 23], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/ExpandSafePrefix.lean", "imports": ["lake-packages/aesop/Aesop/Search/Expansion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.Goal.isSafeExpanded", "code": "private def Goal.isSafeExpanded (g : Goal) : BaseIO Bool :=\n  (pure g.unsafeRulesSelected) <||> g.hasSafeRapp", "start": [15, 1], "end": [16, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandSafePrefixGoal", "code": "private partial def expandSafePrefixGoal (gref : GoalRef) :\n      SearchM Q Unit :=\n    withIncRecDepth do withIncRecDepth do\n      let g \u2190 gref.get\n      if g.state.isProven then\n        aesop_trace[steps] \"Skipping safe rule expansion of goal {g.id} since it is already proven.\"\n        return\n      if ! (\u2190 g.isSafeExpanded) then\n        aesop_trace[steps] \"Applying safe rules to goal {g.id}.\"\n        if \u2190 normalizeGoalIfNecessary gref then\n            return\n        discard $ runFirstSafeRule gref\n      else\n        aesop_trace[steps] \"Skipping safe rule expansion of goal {g.id} since safe rules have already been applied.\"\n      let g \u2190 gref.get\n      if g.state.isProven then\n        return\n      let safeRapps \u2190 g.safeRapps\n      if h\u2081 : 0 < safeRapps.size then\n        if safeRapps.size > 1 then\n          throwError \"aesop: internal error: goal {g.id} has multiple safe rapps\"\n        expandFirstPrefixRapp safeRapps[0]", "start": [19, 3], "end": [43, 43], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandFirstPrefixRapp", "code": "private partial def expandFirstPrefixRapp (rref : RappRef) :\n      SearchM Q Unit := do\n    (\u2190 rref.get).children.forM expandSafePrefixMVarCluster", "start": [45, 3], "end": [47, 59], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandSafePrefixMVarCluster", "code": "private partial def expandSafePrefixMVarCluster (cref : MVarClusterRef) :\n      SearchM Q Unit := do\n    (\u2190 cref.get).goals.forM expandSafePrefixGoal", "start": [49, 3], "end": [51, 49], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandSafePrefix", "code": "def expandSafePrefix : SearchM Q Unit := do\n  aesop_trace[steps] \"Expanding safe subtree of the root goal.\"\n  expandSafePrefixGoal (\u2190 getRootGoal)", "start": [54, 1], "end": [56, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Queue.lean", "imports": ["lake-packages/aesop/Aesop/Options.lean", "lake-packages/aesop/Aesop/Search/Queue/Class.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/BinomialHeap.lean", "lake-packages/aesop/Aesop/Tree.lean", "lake-packages/aesop/Aesop/Tracing.lean"], "premises": [{"full_name": "Aesop.BestFirstQueue.ActiveGoal", "code": "structure ActiveGoal where\n  goal : GoalRef\n  priority : Percent\n  lastExpandedInIteration : Iteration\n    addedInIteration : Iteration", "start": [18, 1], "end": [24, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.ActiveGoal.le", "code": "protected def le (g h : ActiveGoal) : Bool :=\n  g.priority > h.priority ||\n    (g.priority == h.priority &&\n      (g.lastExpandedInIteration \u2264 h.lastExpandedInIteration ||\n        (g.lastExpandedInIteration == h.lastExpandedInIteration &&\n          g.addedInIteration \u2264 h.addedInIteration)))", "start": [41, 1], "end": [46, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.ActiveGoal.ofGoalRef", "code": "protected def ofGoalRef (gref : GoalRef) : BaseIO ActiveGoal := do\n  let g \u2190 gref.get\n  return {\n    goal := gref\n    priority := g.priority\n    lastExpandedInIteration := g.lastExpandedInIteration\n    addedInIteration := g.addedInIteration\n  }", "start": [48, 1], "end": [55, 4], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.BestFirstQueue", "code": "def BestFirstQueue :=\n  BinomialHeap BestFirstQueue.ActiveGoal BestFirstQueue.ActiveGoal.le", "start": [59, 1], "end": [60, 70], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.BestFirstQueue.init", "code": "protected def init : BestFirstQueue :=\n  BinomialHeap.empty", "start": [64, 1], "end": [65, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.BestFirstQueue.addGoals", "code": "protected def addGoals (q : BestFirstQueue) (grefs : Array GoalRef) :\n    BaseIO BestFirstQueue :=\n  grefs.foldlM (init := q) \u03bb q gref =>\n    return q.insert (\u2190 ActiveGoal.ofGoalRef gref)", "start": [67, 1], "end": [70, 50], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.BestFirstQueue.popGoal", "code": "protected def popGoal (q : BestFirstQueue) : Option GoalRef \u00d7 BestFirstQueue :=\n  match q.deleteMin with\n  | none => (none, q)\n  | some (ag, q) => (some ag.goal, q)", "start": [72, 1], "end": [75, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.LIFOQueue", "code": "structure LIFOQueue where\n  goals : Array GoalRef", "start": [85, 1], "end": [86, 24], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.LIFOQueue.init", "code": "protected def init : LIFOQueue :=\n  \u27e8#[]\u27e9", "start": [90, 1], "end": [91, 8], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.LIFOQueue.addGoals", "code": "protected def addGoals (q : LIFOQueue) (grefs : Array GoalRef) : LIFOQueue :=\n  \u27e8q.goals ++ grefs.reverse\u27e9", "start": [93, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.LIFOQueue.popGoal", "code": "protected def popGoal (q : LIFOQueue) : Option GoalRef \u00d7 LIFOQueue :=\n  match q.goals.back? with\n  | some g => (some g, \u27e8q.goals.pop\u27e9)\n  | none => (none, q)", "start": [96, 1], "end": [99, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.FIFOQueue", "code": "structure FIFOQueue where\n  goals : Array GoalRef\n  pos : Nat", "start": [109, 1], "end": [111, 12], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.FIFOQueue.init", "code": "protected def init : FIFOQueue :=\n  \u27e8#[], 0\u27e9", "start": [115, 1], "end": [116, 11], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.FIFOQueue.addGoals", "code": "protected def addGoals (q : FIFOQueue) (grefs : Array GoalRef) : FIFOQueue :=\n  { q with goals := q.goals ++ grefs }", "start": [118, 1], "end": [119, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.FIFOQueue.popGoal", "code": "protected def popGoal (q : FIFOQueue) : Option GoalRef \u00d7 FIFOQueue :=\n  if h : q.pos < q.goals.size then\n    (some q.goals[q.pos], { q with pos := q.pos + 1 })\n  else\n    (none, q)", "start": [121, 1], "end": [125, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.BestFirstQueue.Options.queue", "code": "def Options.queue (opts : Aesop.Options) : \u03a3 Q, Queue Q :=\n  match opts.strategy with\n  | .bestFirst => \u27e8BestFirstQueue, inferInstance\u27e9\n  | .depthFirst => \u27e8LIFOQueue, inferInstance\u27e9\n  | .breadthFirst => \u27e8FIFOQueue, inferInstance\u27e9", "start": [134, 1], "end": [138, 48], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/DestructProducts.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.destructProductHyp", "code": "private def destructProductHyp (goal : MVarId) (hyp : FVarId)\n    (md : TransparencyMode) : MetaM MVarId :=\n  goal.withContext do\n    let hypType \u2190 hyp.getType\n    let (f, args) \u2190 withTransparency md $ getAppUpToDefeq hypType\n    match args with\n    | #[\u03b1, \u03b2] =>\n      match f with\n      | (.const ``And _) =>\n        go hypType (mkApp2 (.const ``And.casesOn [\u2190 mkFreshLevelMVar]) \u03b1 \u03b2)\n      | (.const ``Prod lvls) =>\n        go hypType (mkApp2 (.const ``Prod.casesOn  ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | (.const ``PProd lvls) =>\n        go hypType (mkApp2 (.const ``PProd.casesOn ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | (.const ``MProd lvls) =>\n        go hypType (mkApp2 (.const ``MProd.casesOn ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | (.const ``Exists lvls) =>\n        go hypType (mkApp2 (.const ``Exists.casesOn lvls) \u03b1 \u03b2)\n      | (.const ``Subtype lvls) =>\n        go hypType (mkApp2 (.const ``Subtype.casesOn ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | (.const ``Sigma lvls) =>\n        go hypType (mkApp2 (.const ``Sigma.casesOn ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | (.const ``PSigma lvls) =>\n        go hypType (mkApp2 (.const ``PSigma.casesOn ((\u2190 mkFreshLevelMVar) :: lvls)) \u03b1 \u03b2)\n      | _ => return goal\n    | _ => return goal\n  where\n    go (hypType : Expr) (rec : Expr) : MetaM MVarId := do\n      let (genHyps, goal) \u2190 goal.revert #[hyp] (preserveOrder := true)\n      let (hyp, goal) \u2190 goal.intro1\n      let hypExpr := mkFVar hyp\n      let tgt \u2190 instantiateMVars (\u2190 goal.getType)\n      let motive := mkLambda `h .default hypType $ tgt.abstract #[hypExpr]\n      let prf := mkApp2 rec motive hypExpr\n      goal.withContext $ check prf\n      let [goal] \u2190 goal.apply prf\n        | throwError \"destructProducts: apply did not return exactly one goal\"\n      let (_, goal) \u2190 goal.introN (genHyps.size - 1)\n      let (_, goal) \u2190 goal.introN 2\n      goal.clear hyp", "start": [14, 1], "end": [55, 21], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.destructProductsCore", "code": "partial def destructProductsCore (goal : MVarId) (md : TransparencyMode) :\n    MetaM MVarId :=\n  goal.withContext do\n    let newGoal \u2190 go 0 goal\n    if newGoal == goal then\n      throwError \"destructProducts: found no hypothesis with a product-like type\"\n    else\n      return newGoal\n  where\n    go (i : Nat) (goal : MVarId) : MetaM MVarId := do\n      goal.withContext $ withIncRecDepth do\n        let lctx \u2190 getLCtx\n        if h : i < lctx.decls.size then\n          match lctx.decls[i] with\n          | none => go (i + 1) goal\n          | some ldecl =>\n            if ldecl.isImplementationDetail then\n              go (i + 1) goal\n            else\n              let newGoal \u2190 destructProductHyp goal ldecl.fvarId md\n              if newGoal == goal then\n                go (i + 1) newGoal\n              else\n                go i newGoal\n        else\n          return goal", "start": [57, 1], "end": [82, 22], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.destructProducts", "code": "@[aesop norm 0 (rule_sets [builtin])\n  (tactic\n    (index := [hyp And _ _, hyp Prod _ _, hyp PProd _ _, hyp MProd _ _,\n               hyp Exists _, hyp Subtype _, hyp Sigma _, hyp PSigma _]))]\npartial def destructProducts : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n  let md := input.options.destructProductsTransparency\n  let goal \u2190 unhygienic $ destructProductsCore input.goal md\n  let scriptBuilder? :=\n    mkScriptBuilder? input.options.generateScript $ .ofTactic 1 do\n      let tac \u2190 withTransparencySyntax md (\u2190 `(tactic| aesop_destruct_products))\n      `(tactic| unhygienic $tac:tactic)\n  return (#[goal], scriptBuilder?, none)", "start": [97, 1], "end": [108, 41], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Frontend.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/aesop/Aesop/Frontend/RuleExpr.lean", "lake-packages/aesop/Aesop/Frontend/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Frontend/Command.lean"], "premises": []}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/Intros.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.getIntrosSize", "code": "private def getIntrosSize : Expr \u2192 Nat\n  | .forallE _ _ b _ => getIntrosSize b + 1\n  | .letE _ _ _ b _  => getIntrosSize b + 1\n  | .mdata _ b       => getIntrosSize b\n  | _                => 0", "start": [14, 1], "end": [18, 26], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.introsUnfolding", "code": "partial def introsUnfolding (mvarId : MVarId) : MetaM (Array FVarId \u00d7 MVarId) :=\n  run mvarId #[]\nwhere\n  run (mvarId : MVarId) (fvars : Array FVarId) : MetaM (Array FVarId \u00d7 MVarId) :=\n    mvarId.withContext do\n      let type \u2190 whnf (\u2190 mvarId.getType)\n      let size := getIntrosSize type\n      if 0 < size then\n        let (fvars', mvarId') \u2190 mvarId.introN size\n        run mvarId' (fvars ++ fvars')\n      else\n        return (fvars, mvarId)", "start": [20, 1], "end": [33, 31], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.intros", "code": "@[aesop norm -100 (rule_sets [builtin])]\ndef intros : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n    let md? := input.options.introsTransparency?\n    let (newFVars, goal) \u2190 unhygienic $\n      if let some md := md? then\n        withTransparency md $ introsUnfolding input.goal\n      else\n        input.goal.intros\n    if newFVars.size == 0 then\n      throwError \"nothing to introduce\"\n    let scriptBuilder? \u2190\n      if input.options.generateScript then\n        goal.withContext do\n          let newFVarUserNames \u2190 newFVars.mapM (mkIdent <$> \u00b7.getUserName)\n          let tac \u2190 `(tactic| intro $newFVarUserNames:ident*)\n          let tac :=\n            if let some md := md? then\n              withAllTransparencySyntax md tac\n            else\n              pure tac\n          pure $ some $ .ofTactic 1 tac\n\n      else\n        pure none\n    return (#[goal], scriptBuilder?, none)", "start": [35, 1], "end": [59, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/Assumption.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.assumption", "code": "@[aesop safe -50 (rule_sets [builtin])]\ndef assumption : RuleTac := \u03bb input => do\n  let goal := input.goal\n  let generateScript := input.options.generateScript\n  let md := input.options.assumptionTransparency\n  goal.withContext do\n    goal.checkNotAssigned `Aesop.BuiltinRules.assumption\n    goal.instantiateMVars\n    let tgt \u2190 goal.getType\n    let tgtHasMVar := tgt.hasMVar\n    let initialState \u2190 saveState\n    let mut applications := #[]\n    for ldecl in \u2190 getLCtx do\n      if ldecl.isImplementationDetail then\n        continue\n      restoreState initialState\n      let (some (application, proofHasMVar)) \u2190\n        tryHyp goal tgt ldecl md generateScript\n        | continue\n      if ! tgtHasMVar && ! proofHasMVar then\n        applications := #[application]\n        break\n      else\n        applications := applications.push application\n    if applications.isEmpty then\n      throwTacticEx `Aesop.BuiltinRules.assumption goal \"no matching assumption found\"\n    return \u27e8applications\u27e9\n  where\n    tryHyp (goal : MVarId) (tgt : Expr) (ldecl : LocalDecl)\n        (md : TransparencyMode) (generateScript : Bool) :\n        MetaM (Option (RuleApplication \u00d7 Bool)) := do\n      if ! (\u2190 withTransparency md $ isDefEq ldecl.type tgt) then\n        return none\n      goal.assign ldecl.toExpr\n      let postState \u2190 saveState\n      let scriptBuilder? :=\n        mkScriptBuilder? generateScript $\n          .ofTactic 0 $ withAllTransparencySyntax md $\n            \u2190 `(tactic| exact $(mkIdent ldecl.userName))\n      let app := {\n        goals := #[]\n        successProbability? := none\n        postState, scriptBuilder?\n      }\n      let proofHasMVar := ldecl.type.hasMVar\n      return some (app, proofHasMVar)", "start": [14, 1], "end": [59, 38], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/Subst.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.iffToEq", "code": "private def iffToEq (goal : MVarId) (fvarId : FVarId) (lhs : Expr)\n    (rhs : Expr) : MetaM (MVarId \u00d7 FVarId) := do\n  let newType \u2190 mkEq lhs rhs\n  let proof \u2190 mkPropExt (.fvar fvarId)\n  let goal \u2190 goal.assert (\u2190 fvarId.getUserName) newType proof\n  let (newFVarId, goal) \u2190 goal.intro1P\n  let goal \u2190 goal.tryClear fvarId\n  return (goal, newFVarId)", "start": [14, 1], "end": [21, 27], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.prepareSubstHyp", "code": "private def prepareSubstHyp (goal : MVarId) (fvarId : FVarId)\n    (fvarSubst : FVarSubst) :\n    MetaM (Option (MVarId \u00d7 FVarId \u00d7 Expr \u00d7 Expr \u00d7 Expr \u00d7 FVarSubst)) :=\n  goal.withContext do\n    let ty \u2190 instantiateMVars $ \u2190 fvarId.getType\n    matchHelper? ty \u03bb ty => do\n      if let some (\u03b1, lhs, rhs) := ty.eq? then\n        return some (goal, fvarId, \u03b1, lhs, rhs, fvarSubst)\n      else if let some (lhs, rhs) := ty.iff? then\n        let (goal, fvarId') \u2190 iffToEq goal fvarId lhs rhs\n        let fvarSubst := fvarSubst.insert fvarId (mkFVar fvarId')\n        return some (goal, fvarId', .sort .zero, lhs, rhs, fvarSubst)\n      else\n        return none", "start": [26, 1], "end": [39, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.substFVars", "code": "partial def substFVars (goal : MVarId) (fvarIds : Array FVarId) :\n    MetaM (MVarId \u00d7 Array Name \u00d7 FVarSubst) := do\n  let mut goal := goal\n  let mut fvarSubst := {}\n  let mut substitutedHypNames := Array.mkEmpty fvarIds.size\n  for h : i in [:fvarIds.size] do\n    let (.fvar fvarId) := fvarSubst.get $ fvarIds[i]'h.2 | throwError\n      \"unexpected expr in FVarSubst\"\n    let hypName \u2190 goal.withContext fvarId.getUserName\n    let some (goal', fvarId', _, lhs, _, fvarSubst') \u2190\n      prepareSubstHyp goal fvarId fvarSubst\n      | continue\n    goal := goal'\n    fvarSubst := fvarSubst'\n    let substResult? \u2190 substCore? goal fvarId' (symm := ! lhs.isFVar) fvarSubst\n    if let (some (fvarSubst', goal')) := substResult? then\n      goal := goal'\n      fvarSubst := fvarSubst'\n      substitutedHypNames := substitutedHypNames.push hypName\n  return (goal, substitutedHypNames, fvarSubst)", "start": [41, 1], "end": [60, 48], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.elabAesopSubst", "code": "def elabAesopSubst (hyps : Array Syntax.Ident) : TacticM Unit := do\n  liftMetaTactic \u03bb goal => do\n    let fvars \u2190 hyps.mapM \u03bb id =>\n      return (\u2190 getLocalDeclFromUserName id.getId).fvarId\n    let (goal, substitutedUserNames, _) \u2190 substFVars goal fvars\n    if substitutedUserNames.size == 0 then\n      throwTacticEx `aesop_subst goal\n        \"failed to substitute any of the given hypotheses\"\n    else\n      return [goal]", "start": [63, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.subst", "code": "@[aesop (rule_sets [builtin]) norm -50\n    (tactic (index := [hyp _ = _, hyp _ \u2194 _]))]\ndef subst : RuleTac := RuleTac.ofSingleRuleTac \u03bb input =>\n  input.goal.withContext do\n    let hyps \u2190 input.indexMatchLocations.toArray.mapM \u03bb\n      | .hyp ldecl => pure ldecl.fvarId\n      | _ => throwError \"unexpected index match location\"\n    let (goal, substitutedUserNames, _) \u2190 substFVars input.goal hyps\n    if substitutedUserNames.size == 0 then\n      throwError \"no suitable hypothesis found\"\n    let scriptBuilder? :=\n      mkScriptBuilder? input.options.generateScript $\n        let substitutedUserNames := substitutedUserNames.map mkIdent\n        let tactic :=\n          if h : substitutedUserNames.size = 1 then\n            let hypName := substitutedUserNames[0]'(by rw [h]; decide)\n            `(tactic| aesop_subst $hypName)\n          else\n            `(tactic| aesop_subst [ $substitutedUserNames:ident,* ])\n        .ofTactic 1 tactic\n    return (#[goal], scriptBuilder?, none)", "start": [80, 1], "end": [100, 43], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/ApplyHyps.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.applyHyp", "code": "def applyHyp (hyp : FVarId) (goal : MVarId) (md : TransparencyMode)\n    (generateScript : Bool) : MetaM RuleApplication :=\n  goal.withContext do\n    let goals := (\u2190 withTransparency md $ goal.apply (mkFVar hyp)).toArray\n    let postState \u2190 saveState\n    let scriptBuilder? := mkScriptBuilder? generateScript $\n      .ofTactic goals.size $ withTransparencySyntax md $\n        \u2190 `(tactic| apply $(mkIdent $ \u2190 hyp.getUserName))\n    return {\n      successProbability? := none\n      postState, goals, scriptBuilder?\n    }", "start": [14, 1], "end": [25, 6], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.applyHyps", "code": "@[aesop unsafe 75% tactic (rule_sets [builtin])]\ndef applyHyps : RuleTac := \u03bb input =>\n  input.goal.withContext do\n    let lctx \u2190 getLCtx\n    let generateScript := input.options.generateScript\n    let md := input.options.applyHypsTransparency\n    let mut rapps := Array.mkEmpty lctx.decls.size\n    for localDecl in lctx do\n      if localDecl.isImplementationDetail then continue\n      let initialState \u2190 saveState\n      try\n        let rapp \u2190 applyHyp localDecl.fvarId input.goal md generateScript\n        rapps := rapps.push rapp\n      catch _ => continue\n      finally restoreState initialState\n    return \u27e8rapps\u27e9", "start": [27, 1], "end": [42, 19], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/Ext.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.unhygienicExt", "code": "def unhygienicExt (goal : MVarId) : MetaM (Array MVarId) :=\n  unhygienic do\n    let (_, subgoals) \u2190\n      Std.Tactic.Ext.extCore goal [] (failIfUnchanged := true) |>.run' {}\n    return subgoals.map (\u00b7.fst)", "start": [13, 1], "end": [17, 32], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.unhygienicExtWithScript", "code": "def unhygienicExtWithScript (goal : MVarId) (generateScript : Bool) :\n    MetaM (Array MVarId \u00d7 Option RuleTacScriptBuilder) := do\n  let subgoals \u2190 unhygienicExt goal\n  let scriptBuilder? :=\n    mkScriptBuilder? generateScript (.unhygienicExt subgoals.size)\n  return (subgoals, scriptBuilder?)", "start": [19, 1], "end": [24, 36], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.ext", "code": "@[aesop 80% (rule_sets [builtin])]\ndef ext : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n  let (goals, scriptBuilder?) \u2190\n    unhygienicExtWithScript input.goal input.options.generateScript\n  return (goals, scriptBuilder?, none)", "start": [26, 1], "end": [30, 39], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules/Split.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.splitTarget", "code": "@[aesop (rule_sets [builtin]) safe 100]\ndef splitTarget : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n  let (some goals) \u2190 splitTarget? input.goal | throwError\n    \"nothing to split in target\"\n  let goals := goals.toArray\n  let scriptBuilder? :=\n    mkScriptBuilder? input.options.generateScript $\n      .ofTactic goals.size `(tactic| split)\n  return (goals, scriptBuilder?, none)", "start": [14, 1], "end": [22, 39], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.splitFirstHypothesis", "code": "def splitFirstHypothesis (goal : MVarId) : MetaM (Option (Array MVarId)) :=\n  goal.withContext do\n    for ldecl in \u2190 getLCtx do\n      if let some goals \u2190 splitLocalDecl? goal ldecl.fvarId then\n        return goals.toArray\n    return none", "start": [24, 1], "end": [29, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.splitHypothesesCore", "code": "def splitHypothesesCore (goal : MVarId) : MetaM (Option (Array MVarId)) :=\n  saturate1 goal splitFirstHypothesis", "start": [31, 1], "end": [32, 38], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.splitHypotheses", "code": "@[aesop (rule_sets [builtin]) safe 1000]\ndef splitHypotheses : RuleTac := RuleTac.ofSingleRuleTac \u03bb input => do\n  let (some goals) \u2190 splitHypothesesCore input.goal | throwError\n    \"no splittable hypothesis found\"\n  let scriptBuilder? :=\n    mkScriptBuilder? input.options.generateScript $\n      .ofTactic goals.size `(tactic| aesop_split_hyps)\n  return (goals, scriptBuilder?, none)", "start": [40, 1], "end": [47, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/Lemmas.lean", "imports": ["Mathlib/Init/Order/LinearOrder.lean", "Mathlib/Init/Data/Nat/Basic.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.eq_zero_of_mul_eq_zero", "code": "theorem eq_zero_of_mul_eq_zero : \u2200 {n m : \u2115}, n * m = 0 \u2192 n = 0 \u2228 m = 0", "start": [68, 1], "end": [72, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.linearOrder", "code": "instance linearOrder : LinearOrder \u2115 where\n  le := Nat.le\n  le_refl := @Nat.le_refl\n  le_trans := @Nat.le_trans\n  le_antisymm := @Nat.le_antisymm\n  le_total := @Nat.le_total\n  lt := Nat.lt\n  lt_iff_le_not_le := @Nat.lt_iff_le_not_le\n  decidableLT := inferInstance\n  decidableLE := inferInstance\n  decidableEq := inferInstance", "start": [109, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.ltGeByCases", "code": "protected def ltGeByCases {a b : \u2115} {C : Sort u} (h\u2081 : a < b \u2192 C) (h\u2082 : b \u2264 a \u2192 C) : C :=\n  Decidable.byCases h\u2081 fun h => h\u2082 (Or.elim (Nat.lt_or_ge a b) (fun a => absurd a h) fun a => a)", "start": [196, 1], "end": [197, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.ltByCases", "code": "protected def ltByCases {a b : \u2115} {C : Sort u} (h\u2081 : a < b \u2192 C) (h\u2082 : a = b \u2192 C) (h\u2083 : b < a \u2192 C) :\n    C :=\n  Nat.ltGeByCases h\u2081 fun h\u2081 => Nat.ltGeByCases h\u2083 fun h => h\u2082 (Nat.le_antisymm h h\u2081)", "start": [200, 1], "end": [202, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_eq_succ_bit0", "code": "protected theorem bit1_eq_succ_bit0 (n : \u2115) : bit1 n = succ (bit0 n)", "start": [228, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_succ_eq", "code": "protected theorem bit1_succ_eq (n : \u2115) : bit1 (succ n) = succ (succ (bit1 n))", "start": [232, 1], "end": [233, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_ne_one", "code": "protected theorem bit1_ne_one : \u2200 {n : \u2115}, n \u2260 0 \u2192 bit1 n \u2260 1", "start": [236, 1], "end": [238, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_ne_one", "code": "protected theorem bit0_ne_one : \u2200 n : \u2115, bit0 n \u2260 1", "start": [241, 1], "end": [245, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_ne_bit0", "code": "protected theorem bit1_ne_bit0 : \u2200 n m : \u2115, bit1 n \u2260 bit0 m", "start": [250, 1], "end": [259, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_ne_bit1", "code": "protected theorem bit0_ne_bit1 : \u2200 n m : \u2115, bit0 n \u2260 bit1 m", "start": [262, 1], "end": [263, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_inj", "code": "protected theorem bit0_inj : \u2200 {n m : \u2115}, bit0 n = bit0 m \u2192 n = m", "start": [266, 1], "end": [276, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_inj", "code": "protected theorem bit1_inj : \u2200 {n m : \u2115}, bit1 n = bit1 m \u2192 n = m", "start": [279, 1], "end": [282, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_ne", "code": "protected theorem bit0_ne {n m : \u2115} : n \u2260 m \u2192 bit0 n \u2260 bit0 m", "start": [285, 1], "end": [286, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_ne", "code": "protected theorem bit1_ne {n m : \u2115} : n \u2260 m \u2192 bit1 n \u2260 bit1 m", "start": [289, 1], "end": [290, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_ne_bit0", "code": "protected theorem zero_ne_bit0 {n : \u2115} : n \u2260 0 \u2192 0 \u2260 bit0 n", "start": [293, 1], "end": [293, 101], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_ne_bit1", "code": "protected theorem zero_ne_bit1 (n : \u2115) : 0 \u2260 bit1 n", "start": [296, 1], "end": [297, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.one_ne_bit0", "code": "protected theorem one_ne_bit0 (n : \u2115) : 1 \u2260 bit0 n", "start": [300, 1], "end": [301, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.one_ne_bit1", "code": "protected theorem one_ne_bit1 {n : \u2115} : n \u2260 0 \u2192 1 \u2260 bit1 n", "start": [304, 1], "end": [304, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_bit1", "code": "protected theorem one_lt_bit1 : \u2200 {n : Nat}, n \u2260 0 \u2192 1 < bit1 n", "start": [307, 1], "end": [312, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_bit0", "code": "protected theorem one_lt_bit0 : \u2200 {n : Nat}, n \u2260 0 \u2192 1 < bit0 n", "start": [315, 1], "end": [320, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_lt", "code": "protected theorem bit0_lt {n m : Nat} (h : n < m) : bit0 n < bit0 m", "start": [323, 1], "end": [324, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_lt", "code": "protected theorem bit1_lt {n m : Nat} (h : n < m) : bit1 n < bit1 m", "start": [327, 1], "end": [328, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_lt_bit1", "code": "protected theorem bit0_lt_bit1 {n m : Nat} (h : n \u2264 m) : bit0 n < bit1 m", "start": [331, 1], "end": [332, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_lt_bit0", "code": "protected theorem bit1_lt_bit0 : \u2200 {n m : Nat}, n < m \u2192 bit1 n < bit0 m", "start": [335, 1], "end": [341, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_bit1", "code": "protected theorem one_le_bit1 (n : \u2115) : 1 \u2264 bit1 n", "start": [344, 1], "end": [345, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_bit0", "code": "protected theorem one_le_bit0 : \u2200 n : \u2115, n \u2260 0 \u2192 1 \u2264 bit0 n", "start": [348, 1], "end": [352, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.discriminate", "code": "def discriminate {B : Sort u} {n : \u2115} (H1 : n = 0 \u2192 B) (H2 : \u2200 m, n = succ m \u2192 B) : B := by\n  induction n with\n  | zero => exact H1 rfl\n  | succ n _ => apply H2 _ rfl", "start": [369, 1], "end": [372, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.one_eq_succ_zero", "code": "theorem one_eq_succ_zero : 1 = succ 0", "start": [375, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.twoStepInduction", "code": "def twoStepInduction {P : \u2115 \u2192 Sort u} (H1 : P 0) (H2 : P 1)\n    (H3 : \u2200 (n : \u2115) (_IH1 : P n) (_IH2 : P (succ n)), P (succ (succ n))) : \u2200 a : \u2115, P a\n  | 0 => H1\n  | 1 => H2\n  | succ (succ _n) => H3 _ (twoStepInduction H1 H2 H3 _) (twoStepInduction H1 H2 H3 _)", "start": [482, 1], "end": [486, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.subInduction", "code": "def subInduction {P : \u2115 \u2192 \u2115 \u2192 Sort u} (H1 : \u2200 m, P 0 m) (H2 : \u2200 n, P (succ n) 0)\n    (H3 : \u2200 n m, P n m \u2192 P (succ n) (succ m)) : \u2200 n m : \u2115, P n m\n  | 0, _m => H1 _\n  | succ _n, 0 => H2 _\n  | succ n, succ m => H3 _ _ (subInduction H1 H2 H3 n m)", "start": [489, 1], "end": [493, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.strong_induction_on", "code": "@[elab_as_elim]\nprotected theorem strong_induction_on {p : Nat \u2192 Prop} (n : Nat)\n    (h : \u2200 n, (\u2200 m, m < n \u2192 p m) \u2192 p n) : p n", "start": [499, 1], "end": [502, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.case_strong_induction_on", "code": "protected theorem case_strong_induction_on {p : Nat \u2192 Prop} (a : Nat) (hz : p 0)\n    (hi : \u2200 n, (\u2200 m, m \u2264 n \u2192 p m) \u2192 p (succ n)) : p a", "start": [505, 1], "end": [510, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.cond_decide_mod_two", "code": "theorem cond_decide_mod_two (x : \u2115) [d : Decidable (x % 2 = 1)] :\n    cond (@decide (x % 2 = 1) d) 1 0 = x % 2", "start": [551, 1], "end": [555, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.lbp", "code": "private def lbp (m n : \u2115) : Prop :=\n  m = n + 1 \u2227 \u2200 k \u2264 n, \u00acp k", "start": [672, 1], "end": [673, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.wf_lbp", "code": "private def wf_lbp : WellFounded (@lbp p) :=\n  \u27e8let \u27e8n, pn\u27e9 := H\n    suffices \u2200 m k, n \u2264 k + m \u2192 Acc lbp k from fun a => this _ _ (Nat.le_add_left _ _)\n    fun m =>\n    Nat.recOn m\n      (fun k kn =>\n        \u27e8_, fun y r =>\n          match y, r with\n          | _, \u27e8rfl, a\u27e9 => absurd pn (a _ kn)\u27e9)\n      fun m IH k kn =>\n      \u27e8_, fun y r =>\n        match y, r with\n        | _, \u27e8rfl, _a\u27e9 => IH _ (by rw [Nat.add_right_comm]; exact kn)\u27e9\u27e9", "start": [677, 1], "end": [689, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.findX", "code": "protected def findX : { n // p n \u2227 \u2200 m < n, \u00acp m } :=\n  @WellFounded.fix _ (fun k => (\u2200 n < k, \u00acp n) \u2192 { n // p n \u2227 \u2200 m < n, \u00acp m }) lbp (wf_lbp H)\n    (fun m IH al =>\n      if pm : p m then \u27e8m, pm, al\u27e9\n      else\n        have : \u2200 n \u2264 m, \u00acp n := fun n h =>\n          Or.elim (Decidable.lt_or_eq_of_le h) (al n) fun e => by rw [e]; exact pm\n        IH _ \u27e8rfl, this\u27e9 fun n h => this n <| Nat.le_of_succ_le_succ h)\n    0 fun n h => absurd h (Nat.not_lt_zero _)", "start": [691, 1], "end": [699, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.find", "code": "protected def find : \u2115 :=\n  (Nat.findX H).1", "start": [702, 1], "end": [714, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.find_spec", "code": "protected theorem find_spec : p (Nat.find H)", "start": [717, 1], "end": [718, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.find_min", "code": "protected theorem find_min : \u2200 {m : \u2115}, m < Nat.find H \u2192 \u00acp m", "start": [721, 1], "end": [722, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.find_min'", "code": "protected theorem find_min' {m : \u2115} (h : p m) : Nat.find H \u2264 m", "start": [725, 1], "end": [726, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.to_digits_core_lens_eq_aux", "code": "lemma to_digits_core_lens_eq_aux (b f : Nat) :\n    \u2200 (n : Nat) (l1 l2 : List Char), l1.length = l2.length \u2192\n    (Nat.toDigitsCore b f n l1).length = (Nat.toDigitsCore b f n l2).length := by\n  induction f with (simp only [Nat.toDigitsCore, List.length]; intro n l1 l2 hlen)\n  | zero => assumption\n  | succ f ih =>\n    by_cases hx : n / b = 0\n    case pos => simp only [hx, if_true, List.length, congrArg (fun l \u21a6 l + 1) hlen]\n    case neg =>\n      simp only [hx, if_false]\n      specialize ih (n / b) (Nat.digitChar (n % b) :: l1) (Nat.digitChar (n % b) :: l2)\n      simp only [List.length, congrArg (fun l \u21a6 l + 1) hlen] at ih\n      exact ih trivial", "start": [731, 1], "end": [743, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.to_digits_core_lens_eq", "code": "lemma to_digits_core_lens_eq (b f : Nat) : \u2200 (n : Nat) (c : Char) (tl : List Char),\n    (Nat.toDigitsCore b f n (c :: tl)).length = (Nat.toDigitsCore b f n tl).length + 1 := by\n  induction f with (intro n c tl; simp only [Nat.toDigitsCore, List.length])\n  | succ f ih =>\n    by_cases hnb : (n / b) = 0\n    case pos => simp only [hnb, if_true, List.length]\n    case neg =>\n      generalize hx: Nat.digitChar (n % b) = x\n      simp only [hx, hnb, if_false] at ih\n      simp only [hnb, if_false]\n      specialize ih (n / b) c (x :: tl)\n      rw [\u2190 ih]\n      have lens_eq : (x :: (c :: tl)).length = (c :: x :: tl).length := by simp\n      apply to_digits_core_lens_eq_aux\n      exact lens_eq", "start": [745, 1], "end": [759, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.nat_repr_len_aux", "code": "lemma nat_repr_len_aux (n b e : Nat) (h_b_pos : 0 < b) :  n < b ^ e.succ \u2192 n / b < b ^ e := by\n  simp only [Nat.pow_succ]\n  exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr", "start": [761, 1], "end": [763, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.to_digits_core_length", "code": "lemma to_digits_core_length (b : Nat) (h : 2 <= b) (f n e : Nat)\n    (hlt : n < b ^ e) (h_e_pos: 0 < e) : (Nat.toDigitsCore b f n []).length <= e := by\n  induction f generalizing n e hlt h_e_pos with\n    simp only [Nat.toDigitsCore, List.length, Nat.zero_le]\n  | succ f ih =>\n    cases e with\n    | zero => exact False.elim (Nat.lt_irrefl 0 h_e_pos)\n    | succ e =>\n      by_cases h_pred_pos : 0 < e\n      case pos =>\n        have _ : 0 < b := Nat.lt_trans (by decide) h\n        specialize ih (n / b) e (nat_repr_len_aux n b e \u20390 < b\u203a hlt) h_pred_pos\n        by_cases hdiv_ten : n / b = 0\n        case pos => simp only [hdiv_ten]; exact Nat.le.step h_pred_pos\n        case neg =>\n          simp only [hdiv_ten,\n            to_digits_core_lens_eq b f (n / b) (Nat.digitChar $ n % b), if_false]\n          exact Nat.succ_le_succ ih\n      case neg =>\n        have _ : e = 0 := Nat.eq_zero_of_nonpos e h_pred_pos\n        rw [\u2039e = 0\u203a]\n        have _ : b ^ 1 = b := by simp only [pow_succ, pow_zero, Nat.one_mul]\n        have _ : n < b := \u2039b ^ 1 = b\u203a \u25b8 (\u2039e = 0\u203a \u25b8 hlt : n < b ^ Nat.succ 0)\n        simp only [(@Nat.div_eq_of_lt n b \u2039n < b\u203a : n / b = 0), if_true, List.length]", "start": [765, 1], "end": [791, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.repr_length", "code": "lemma repr_length (n e : Nat) : 0 < e \u2192 n < 10 ^ e \u2192 (Nat.repr n).length <= e := by\n  cases n with\n    (intro e0 he; simp only [Nat.repr, Nat.toDigits, String.length, List.asString])\n  | zero => assumption\n  | succ n =>\n    by_cases hterm : n.succ / 10 = 0\n    case pos => simp only [hterm, Nat.toDigitsCore]; assumption\n    case neg => exact to_digits_core_length 10 (by decide) (Nat.succ n + 1) (Nat.succ n) e he e0", "start": [793, 1], "end": [803, 97], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Logic/Relation.lean", "imports": ["Mathlib/Tactic/SimpRw.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/Init/Propext.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Relator.lean", "Mathlib/Tactic/Use.lean", "Mathlib/Init/Data/Quot.lean", "Mathlib/Tactic/MkIffOfInductiveProp.lean"], "premises": [{"full_name": "IsRefl.reflexive", "code": "theorem IsRefl.reflexive [IsRefl \u03b1 r] : Reflexive r", "start": [56, 1], "end": [56, 77], "kind": "commanddeclaration"}, {"full_name": "Reflexive.rel_of_ne_imp", "code": "theorem Reflexive.rel_of_ne_imp (h : Reflexive r) {x y : \u03b1} (hr : x \u2260 y \u2192 r x y) : r x y", "start": [59, 1], "end": [64, 17], "kind": "commanddeclaration"}, {"full_name": "Reflexive.ne_imp_iff", "code": "theorem Reflexive.ne_imp_iff (h : Reflexive r) {x y : \u03b1} : x \u2260 y \u2192 r x y \u2194 r x y", "start": [68, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "reflexive_ne_imp_iff", "code": "theorem reflexive_ne_imp_iff [IsRefl \u03b1 r] {x y : \u03b1} : x \u2260 y \u2192 r x y \u2194 r x y", "start": [74, 1], "end": [77, 30], "kind": "commanddeclaration"}, {"full_name": "Symmetric.iff", "code": "protected theorem Symmetric.iff (H : Symmetric r) (x y : \u03b1) : r x y \u2194 r y x", "start": [80, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "Symmetric.flip_eq", "code": "theorem Symmetric.flip_eq (h : Symmetric r) : flip r = r", "start": [84, 1], "end": [85, 41], "kind": "commanddeclaration"}, {"full_name": "Symmetric.swap_eq", "code": "theorem Symmetric.swap_eq : Symmetric r \u2192 swap r = r", "start": [88, 1], "end": [89, 20], "kind": "commanddeclaration"}, {"full_name": "flip_eq_iff", "code": "theorem flip_eq_iff : flip r = r \u2194 Symmetric r", "start": [92, 1], "end": [93, 57], "kind": "commanddeclaration"}, {"full_name": "swap_eq_iff", "code": "theorem swap_eq_iff : swap r = r \u2194 Symmetric r", "start": [96, 1], "end": [97, 14], "kind": "commanddeclaration"}, {"full_name": "Reflexive.comap", "code": "theorem Reflexive.comap (h : Reflexive r) (f : \u03b1 \u2192 \u03b2) : Reflexive (r on f)", "start": [106, 1], "end": [106, 94], "kind": "commanddeclaration"}, {"full_name": "Symmetric.comap", "code": "theorem Symmetric.comap (h : Symmetric r) (f : \u03b1 \u2192 \u03b2) : Symmetric (r on f)", "start": [109, 1], "end": [109, 98], "kind": "commanddeclaration"}, {"full_name": "Transitive.comap", "code": "theorem Transitive.comap (h : Transitive r) (f : \u03b1 \u2192 \u03b2) : Transitive (r on f)", "start": [112, 1], "end": [113, 32], "kind": "commanddeclaration"}, {"full_name": "Equivalence.comap", "code": "theorem Equivalence.comap (h : Equivalence r) (f : \u03b1 \u2192 \u03b2) : Equivalence (r on f)", "start": [116, 1], "end": [117, 73], "kind": "commanddeclaration"}, {"full_name": "Relation.Comp", "code": "def Comp (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (p : \u03b2 \u2192 \u03b3 \u2192 Prop) (a : \u03b1) (c : \u03b3) : Prop :=\n  \u2203 b, r a b \u2227 p b c", "start": [128, 1], "end": [133, 21], "kind": "commanddeclaration"}, {"full_name": "Relation.comp_eq", "code": "theorem comp_eq : r \u2218r (\u00b7 = \u00b7) = r", "start": [139, 1], "end": [141, 58], "kind": "commanddeclaration"}, {"full_name": "Relation.eq_comp", "code": "theorem eq_comp : (\u00b7 = \u00b7) \u2218r r = r", "start": [144, 1], "end": [146, 63], "kind": "commanddeclaration"}, {"full_name": "Relation.iff_comp", "code": "theorem iff_comp {r : Prop \u2192 \u03b1 \u2192 Prop} : (\u00b7 \u2194 \u00b7) \u2218r r = r", "start": [149, 1], "end": [151, 21], "kind": "commanddeclaration"}, {"full_name": "Relation.comp_iff", "code": "theorem comp_iff {r : \u03b1 \u2192 Prop \u2192 Prop} : r \u2218r (\u00b7 \u2194 \u00b7) = r", "start": [154, 1], "end": [156, 21], "kind": "commanddeclaration"}, {"full_name": "Relation.comp_assoc", "code": "theorem comp_assoc : (r \u2218r p) \u2218r q = r \u2218r p \u2218r q", "start": [159, 1], "end": [164, 60], "kind": "commanddeclaration"}, {"full_name": "Relation.flip_comp", "code": "theorem flip_comp : flip (r \u2218r p) = flip p \u2218r flip r", "start": [167, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "Relation.Fibration", "code": "def Fibration :=\n  \u2200 \u2983a b\u2984, r\u03b2 b (f a) \u2192 \u2203 a', r\u03b1 a' a \u2227 f a' = b", "start": [181, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "Acc.of_fibration", "code": "theorem _root_.Acc.of_fibration (fib : Fibration r\u03b1 r\u03b2 f) {a} (ha : Acc r\u03b1 a) : Acc r\u03b2 (f a)", "start": [190, 1], "end": [196, 18], "kind": "commanddeclaration"}, {"full_name": "Acc.of_downward_closed", "code": "theorem _root_.Acc.of_downward_closed (dc : \u2200 {a b}, r\u03b2 b (f a) \u2192 \u2203 c, f c = b) (a : \u03b1)\n    (ha : Acc (InvImage r\u03b2 f) a) : Acc r\u03b2 (f a)", "start": [199, 1], "end": [204, 51], "kind": "commanddeclaration"}, {"full_name": "Relation.Map", "code": "protected def Map (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) : \u03b3 \u2192 \u03b4 \u2192 Prop := fun c d \u21a6\n  \u2203 a b, r a b \u2227 f a = c \u2227 g b = d", "start": [209, 1], "end": [215, 35], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen", "code": "@[mk_iff ReflTransGen.cases_tail_iff]\ninductive ReflTransGen (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : \u03b1 \u2192 Prop\n  | refl : ReflTransGen r a a\n  | tail {b c} : ReflTransGen r a b \u2192 r b c \u2192 ReflTransGen r a c", "start": [220, 1], "end": [224, 65], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflGen", "code": "@[mk_iff reflGen_iff]\ninductive ReflGen (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : \u03b1 \u2192 Prop\n  | refl : ReflGen r a a\n  | single {b} : r a b \u2192 ReflGen r a b", "start": [230, 1], "end": [234, 39], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen", "code": "@[mk_iff transGen_iff]\ninductive TransGen (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : \u03b1 \u2192 Prop\n  | single {b} : r a b \u2192 TransGen r a b\n  | tail {b c} : TransGen r a b \u2192 r b c \u2192 TransGen r a c", "start": [239, 1], "end": [243, 57], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflGen.to_reflTransGen", "code": "theorem to_reflTransGen : \u2200 {a b}, ReflGen r a b \u2192 ReflTransGen r a b", "start": [252, 1], "end": [254, 60], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflGen.mono", "code": "theorem mono {p : \u03b1 \u2192 \u03b1 \u2192 Prop} (hp : \u2200 a b, r a b \u2192 p a b) : \u2200 {a b}, ReflGen r a b \u2192 ReflGen p a b", "start": [257, 1], "end": [259, 40], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.trans", "code": "@[trans]\ntheorem trans (hab : ReflTransGen r a b) (hbc : ReflTransGen r b c) : ReflTransGen r a c", "start": [269, 1], "end": [273, 48], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.single", "code": "theorem single (hab : r a b) : ReflTransGen r a b", "start": [276, 1], "end": [277, 16], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.head", "code": "theorem head (hab : r a b) (hbc : ReflTransGen r b c) : ReflTransGen r a c", "start": [280, 1], "end": [283, 48], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.symmetric", "code": "theorem symmetric (h : Symmetric r) : Symmetric (ReflTransGen r)", "start": [286, 1], "end": [290, 45], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.cases_tail", "code": "theorem cases_tail : ReflTransGen r a b \u2192 b = a \u2228 \u2203 c, ReflTransGen r a c \u2227 r c b", "start": [293, 1], "end": [294, 27], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.head_induction_on", "code": "@[elab_as_elim]\ntheorem head_induction_on {P : \u2200 a : \u03b1, ReflTransGen r a b \u2192 Prop} {a : \u03b1} (h : ReflTransGen r a b)\n    (refl : P b refl)\n    (head : \u2200 {a c} (h' : r a c) (h : ReflTransGen r c b), P c h \u2192 P a (h.head h')) : P a h", "start": [297, 1], "end": [307, 46], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.trans_induction_on", "code": "@[elab_as_elim]\ntheorem trans_induction_on {P : \u2200 {a b : \u03b1}, ReflTransGen r a b \u2192 Prop} {a b : \u03b1}\n    (h : ReflTransGen r a b) (ih\u2081 : \u2200 a, @P a a refl) (ih\u2082 : \u2200 {a b} (h : r a b), P (single h))\n    (ih\u2083 : \u2200 {a b c} (h\u2081 : ReflTransGen r a b) (h\u2082 : ReflTransGen r b c), P h\u2081 \u2192 P h\u2082 \u2192\n     P (h\u2081.trans h\u2082)) : P h", "start": [310, 1], "end": [317, 70], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.cases_head", "code": "theorem cases_head (h : ReflTransGen r a b) : a = b \u2228 \u2203 c, r a c \u2227 ReflTransGen r c b", "start": [320, 1], "end": [325, 45], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.cases_head_iff", "code": "theorem cases_head_iff : ReflTransGen r a b \u2194 a = b \u2228 \u2203 c, r a c \u2227 ReflTransGen r c b", "start": [328, 1], "end": [332, 23], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.total_of_right_unique", "code": "theorem total_of_right_unique (U : Relator.RightUnique r) (ab : ReflTransGen r a b)\n    (ac : ReflTransGen r a c) : ReflTransGen r b c \u2228 ReflTransGen r c b", "start": [335, 1], "end": [344, 32], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.to_reflTransGen", "code": "theorem to_reflTransGen {a b} (h : TransGen r a b) : ReflTransGen r a b", "start": [351, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.trans_left", "code": "theorem trans_left (hab : TransGen r a b) (hbc : ReflTransGen r b c) : TransGen r a c", "start": [358, 1], "end": [361, 48], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.trans", "code": "@[trans]\ntheorem trans (hab : TransGen r a b) (hbc : TransGen r b c) : TransGen r a c", "start": [367, 1], "end": [369, 37], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.head'", "code": "theorem head' (hab : r a b) (hbc : ReflTransGen r b c) : TransGen r a c", "start": [375, 1], "end": [376, 30], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.tail'", "code": "theorem tail' (hab : ReflTransGen r a b) (hbc : r b c) : TransGen r a c", "start": [379, 1], "end": [382, 52], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.head", "code": "theorem head (hab : r a b) (hbc : TransGen r b c) : TransGen r a c", "start": [385, 1], "end": [386, 32], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.head_induction_on", "code": "@[elab_as_elim]\ntheorem head_induction_on {P : \u2200 a : \u03b1, TransGen r a b \u2192 Prop} {a : \u03b1} (h : TransGen r a b)\n    (base : \u2200 {a} (h : r a b), P a (single h))\n    (ih : \u2200 {a c} (h' : r a c) (h : TransGen r c b), P c h \u2192 P a (h.head h')) : P a h", "start": [389, 1], "end": [399, 31], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.trans_induction_on", "code": "@[elab_as_elim]\ntheorem trans_induction_on {P : \u2200 {a b : \u03b1}, TransGen r a b \u2192 Prop} {a b : \u03b1} (h : TransGen r a b)\n    (base : \u2200 {a b} (h : r a b), P (single h))\n    (ih : \u2200 {a b c} (h\u2081 : TransGen r a b) (h\u2082 : TransGen r b c), P h\u2081 \u2192 P h\u2082 \u2192 P (h\u2081.trans h\u2082)) :\n    P h", "start": [402, 1], "end": [409, 67], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.trans_right", "code": "theorem trans_right (hab : ReflTransGen r a b) (hbc : TransGen r b c) : TransGen r a c", "start": [412, 1], "end": [415, 48], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.tail'_iff", "code": "theorem tail'_iff : TransGen r a c \u2194 \u2203 b, ReflTransGen r a b \u2227 r b c", "start": [421, 1], "end": [425, 40], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.head'_iff", "code": "theorem head'_iff : TransGen r a c \u2194 \u2203 b, r a b \u2227 ReflTransGen r b c", "start": [428, 1], "end": [434, 31], "kind": "commanddeclaration"}, {"full_name": "Acc.TransGen", "code": "theorem _root_.Acc.TransGen (h : Acc r a) : Acc (TransGen r) a", "start": [439, 1], "end": [443, 38], "kind": "commanddeclaration"}, {"full_name": "acc_transGen_iff", "code": "theorem _root_.acc_transGen_iff : Acc (TransGen r) a \u2194 Acc r a", "start": [446, 1], "end": [447, 57], "kind": "commanddeclaration"}, {"full_name": "WellFounded.transGen", "code": "theorem _root_.WellFounded.transGen (h : WellFounded r) : WellFounded (TransGen r)", "start": [450, 1], "end": [451, 33], "kind": "commanddeclaration"}, {"full_name": "Relation.reflGen_eq_self", "code": "lemma reflGen_eq_self (hr : Reflexive r) : ReflGen r = r := by\n  ext x y\n  simpa only [reflGen_iff, or_iff_right_iff_imp] using fun h \u21a6 h \u25b8 hr y", "start": [456, 1], "end": [458, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflexive_reflGen", "code": "lemma reflexive_reflGen : Reflexive (ReflGen r) := fun _ \u21a6 .refl", "start": [460, 1], "end": [460, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflGen_minimal", "code": "lemma reflGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Reflexive r') (h : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1}\n    (hxy : ReflGen r x y) : r' x y := by\n  simpa [reflGen_eq_self hr'] using ReflGen.mono h hxy", "start": [462, 1], "end": [464, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.transGen_eq_self", "code": "theorem transGen_eq_self (trans : Transitive r) : TransGen r = r", "start": [470, 1], "end": [475, 71], "kind": "commanddeclaration"}, {"full_name": "Relation.transitive_transGen", "code": "theorem transitive_transGen : Transitive (TransGen r)", "start": [478, 1], "end": [478, 84], "kind": "commanddeclaration"}, {"full_name": "Relation.transGen_idem", "code": "theorem transGen_idem : TransGen (TransGen r) = TransGen r", "start": [484, 1], "end": [485, 39], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.lift", "code": "theorem TransGen.lift {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2) (h : \u2200 a b, r a b \u2192 p (f a) (f b))\n    (hab : TransGen r a b) : TransGen p (f a) (f b)", "start": [488, 1], "end": [492, 65], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.lift'", "code": "theorem TransGen.lift' {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b, r a b \u2192 TransGen p (f a) (f b)) (hab : TransGen r a b) :\n    TransGen p (f a) (f b)", "start": [495, 1], "end": [498, 41], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.closed", "code": "theorem TransGen.closed {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a b, r a b \u2192 TransGen p a b) \u2192 TransGen r a b \u2192 TransGen p a b", "start": [501, 1], "end": [503, 20], "kind": "commanddeclaration"}, {"full_name": "Relation.TransGen.mono", "code": "theorem TransGen.mono {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a b, r a b \u2192 p a b) \u2192 TransGen r a b \u2192 TransGen p a b", "start": [506, 1], "end": [508, 19], "kind": "commanddeclaration"}, {"full_name": "Relation.transGen_minimal", "code": "lemma transGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Transitive r') (h : \u2200 x y, r x y \u2192 r' x y)\n    {x y : \u03b1} (hxy : TransGen r x y) : r' x y := by\n  simpa [transGen_eq_self hr'] using TransGen.mono h hxy", "start": [511, 1], "end": [513, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.TransGen.swap", "code": "theorem TransGen.swap (h : TransGen r b a) : TransGen (swap r) a b", "start": [515, 1], "end": [518, 22], "kind": "commanddeclaration"}, {"full_name": "Relation.transGen_swap", "code": "theorem transGen_swap : TransGen (swap r) a b \u2194 TransGen r b a", "start": [521, 1], "end": [522, 33], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_iff_eq", "code": "theorem reflTransGen_iff_eq (h : \u2200 b, \u00acr a b) : ReflTransGen r a b \u2194 b = a", "start": [531, 1], "end": [532, 41], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_iff_eq_or_transGen", "code": "theorem reflTransGen_iff_eq_or_transGen : ReflTransGen r a b \u2194 b = a \u2228 TransGen r a b", "start": [535, 1], "end": [542, 30], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.lift", "code": "theorem ReflTransGen.lift {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b, r a b \u2192 p (f a) (f b)) (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b)", "start": [545, 1], "end": [547, 99], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.mono", "code": "theorem ReflTransGen.mono {p : \u03b1 \u2192 \u03b1 \u2192 Prop} : (\u2200 a b, r a b \u2192 p a b) \u2192\n    ReflTransGen r a b \u2192 ReflTransGen p a b", "start": [550, 1], "end": [552, 23], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_eq_self", "code": "theorem reflTransGen_eq_self (refl : Reflexive r) (trans : Transitive r) : ReflTransGen r = r", "start": [555, 1], "end": [560, 35], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_minimal", "code": "lemma reflTransGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr\u2081 : Reflexive r') (hr\u2082 : Transitive r')\n    (h : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1} (hxy : ReflTransGen r x y) : r' x y := by\n  simpa [reflTransGen_eq_self hr\u2081 hr\u2082] using ReflTransGen.mono h hxy", "start": [563, 1], "end": [565, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflexive_reflTransGen", "code": "theorem reflexive_reflTransGen : Reflexive (ReflTransGen r)", "start": [567, 1], "end": [567, 76], "kind": "commanddeclaration"}, {"full_name": "Relation.transitive_reflTransGen", "code": "theorem transitive_reflTransGen : Transitive (ReflTransGen r)", "start": [570, 1], "end": [570, 83], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_idem", "code": "theorem reflTransGen_idem : ReflTransGen (ReflTransGen r) = ReflTransGen r", "start": [579, 1], "end": [580, 70], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.lift'", "code": "theorem ReflTransGen.lift' {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b, r a b \u2192 ReflTransGen p (f a) (f b))\n    (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b)", "start": [583, 1], "end": [586, 47], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_closed", "code": "theorem reflTransGen_closed {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n    (\u2200 a b, r a b \u2192 ReflTransGen p a b) \u2192 ReflTransGen r a b \u2192 ReflTransGen p a b", "start": [589, 1], "end": [591, 24], "kind": "commanddeclaration"}, {"full_name": "Relation.ReflTransGen.swap", "code": "theorem ReflTransGen.swap (h : ReflTransGen r b a) : ReflTransGen (swap r) a b", "start": [594, 1], "end": [597, 22], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_swap", "code": "theorem reflTransGen_swap : ReflTransGen (swap r) a b \u2194 ReflTransGen r b a", "start": [600, 1], "end": [601, 41], "kind": "commanddeclaration"}, {"full_name": "Relation.reflGen_transGen", "code": "@[simp] lemma reflGen_transGen : ReflGen (TransGen r) = ReflTransGen r := by\n  ext x y\n  simp_rw [reflTransGen_iff_eq_or_transGen, reflGen_iff]", "start": [604, 1], "end": [606, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.transGen_reflGen", "code": "@[simp] lemma transGen_reflGen : TransGen (ReflGen r) = ReflTransGen r := by\n  ext x y\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 simpa [reflTransGen_idem]\n      using TransGen.to_reflTransGen <| TransGen.mono (fun _ _ \u21a6 ReflGen.to_reflTransGen) h\n  \u00b7 obtain (rfl | h) := reflTransGen_iff_eq_or_transGen.mp h\n    \u00b7 exact .single .refl\n    \u00b7 exact TransGen.mono (fun _ _ \u21a6 .single) h", "start": [608, 1], "end": [615, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflTransGen_reflGen", "code": "@[simp] lemma reflTransGen_reflGen : ReflTransGen (ReflGen r) = ReflTransGen r := by\n  simp only [\u2190transGen_reflGen, reflGen_eq_self reflexive_reflGen]", "start": [617, 1], "end": [618, 67], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflTransGen_transGen", "code": "@[simp] lemma reflTransGen_transGen : ReflTransGen (TransGen r) = ReflTransGen r := by\n  simp only [\u2190reflGen_transGen, transGen_idem]", "start": [620, 1], "end": [621, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflTransGen_eq_transGen", "code": "lemma reflTransGen_eq_transGen (hr : Reflexive r) :\n    ReflTransGen r = TransGen r := by\n  rw [\u2190 transGen_reflGen, reflGen_eq_self hr]", "start": [623, 1], "end": [625, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.reflTransGen_eq_reflGen", "code": "lemma reflTransGen_eq_reflGen (hr : Transitive r) :\n    ReflTransGen r = ReflGen r := by\n  rw [\u2190 reflGen_transGen, transGen_eq_self hr]", "start": [627, 1], "end": [629, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Relation.Join", "code": "def Join (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u03b1 \u2192 \u03b1 \u2192 Prop := fun a b \u21a6 \u2203 c, r a c \u2227 r b c", "start": [633, 1], "end": [640, 75], "kind": "commanddeclaration"}, {"full_name": "Relation.church_rosser", "code": "theorem church_rosser (h : \u2200 a b c, r a b \u2192 r a c \u2192 \u2203 d, ReflGen r b d \u2227 ReflTransGen r c d)\n    (hab : ReflTransGen r a b) (hac : ReflTransGen r a c) : Join (ReflTransGen r) b c", "start": [647, 1], "end": [667, 33], "kind": "commanddeclaration"}, {"full_name": "Relation.join_of_single", "code": "theorem join_of_single (h : Reflexive r) (hab : r a b) : Join r a b", "start": [671, 1], "end": [672, 16], "kind": "commanddeclaration"}, {"full_name": "Relation.symmetric_join", "code": "theorem symmetric_join : Symmetric (Join r)", "start": [675, 1], "end": [675, 85], "kind": "commanddeclaration"}, {"full_name": "Relation.reflexive_join", "code": "theorem reflexive_join (h : Reflexive r) : Reflexive (Join r)", "start": [678, 1], "end": [678, 87], "kind": "commanddeclaration"}, {"full_name": "Relation.transitive_join", "code": "theorem transitive_join (ht : Transitive r) (h : \u2200 a b c, r a b \u2192 r a c \u2192 Join r b c) :\n    Transitive (Join r)", "start": [681, 1], "end": [685, 30], "kind": "commanddeclaration"}, {"full_name": "Relation.equivalence_join", "code": "theorem equivalence_join (hr : Reflexive r) (ht : Transitive r)\n    (h : \u2200 a b c, r a b \u2192 r a c \u2192 Join r b c) : Equivalence (Join r)", "start": [688, 1], "end": [690, 70], "kind": "commanddeclaration"}, {"full_name": "Relation.equivalence_join_reflTransGen", "code": "theorem equivalence_join_reflTransGen\n    (h : \u2200 a b c, r a b \u2192 r a c \u2192 \u2203 d, ReflGen r b d \u2227 ReflTransGen r c d) :\n    Equivalence (Join (ReflTransGen r))", "start": [693, 1], "end": [696, 94], "kind": "commanddeclaration"}, {"full_name": "Relation.join_of_equivalence", "code": "theorem join_of_equivalence {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Equivalence r) (h : \u2200 a b, r' a b \u2192 r a b) :\n    Join r' a b \u2192 r a b", "start": [699, 1], "end": [701, 65], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_of_transitive_reflexive", "code": "theorem reflTransGen_of_transitive_reflexive {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r)\n    (ht : Transitive r) (h : \u2200 a b, r' a b \u2192 r a b) (h' : ReflTransGen r' a b) : r a b", "start": [704, 1], "end": [708, 28], "kind": "commanddeclaration"}, {"full_name": "Relation.reflTransGen_of_equivalence", "code": "theorem reflTransGen_of_equivalence {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Equivalence r) :\n    (\u2200 a b, r' a b \u2192 r a b) \u2192 ReflTransGen r' a b \u2192 r a b", "start": [711, 1], "end": [713, 67], "kind": "commanddeclaration"}, {"full_name": "Equivalence.eqvGen_iff", "code": "theorem Equivalence.eqvGen_iff (h : Equivalence r) : EqvGen r a b \u2194 r a b", "start": [724, 1], "end": [733, 21], "kind": "commanddeclaration"}, {"full_name": "Equivalence.eqvGen_eq", "code": "theorem Equivalence.eqvGen_eq (h : Equivalence r) : EqvGen r = r", "start": [736, 1], "end": [737, 56], "kind": "commanddeclaration"}, {"full_name": "EqvGen.mono", "code": "theorem EqvGen.mono {r p : \u03b1 \u2192 \u03b1 \u2192 Prop} (hrp : \u2200 a b, r a b \u2192 p a b) (h : EqvGen r a b) :\n    EqvGen p a b", "start": [740, 1], "end": [746, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Synonym.lean", "imports": ["Mathlib/Logic/Nontrivial/Defs.lean", "Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderDual.toDual", "code": "def toDual : \u03b1 \u2243 \u03b1\u1d52\u1d48 :=\n  Equiv.refl _", "start": [49, 1], "end": [51, 15], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual", "code": "def ofDual : \u03b1\u1d52\u1d48 \u2243 \u03b1 :=\n  Equiv.refl _", "start": [54, 1], "end": [56, 15], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_symm_eq", "code": "@[simp]\ntheorem toDual_symm_eq : (@toDual \u03b1).symm = ofDual", "start": [59, 1], "end": [60, 58], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_symm_eq", "code": "@[simp]\ntheorem ofDual_symm_eq : (@ofDual \u03b1).symm = toDual", "start": [63, 1], "end": [64, 58], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_ofDual", "code": "@[simp]\ntheorem toDual_ofDual (a : \u03b1\u1d52\u1d48) : toDual (ofDual a) = a", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_toDual", "code": "@[simp]\ntheorem ofDual_toDual (a : \u03b1) : ofDual (toDual a) = a", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_inj", "code": "theorem toDual_inj {a b : \u03b1} : toDual a = toDual b \u2194 a = b", "start": [79, 1], "end": [80, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_inj", "code": "theorem ofDual_inj {a b : \u03b1\u1d52\u1d48} : ofDual a = ofDual b \u2194 a = b", "start": [85, 1], "end": [86, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_le_toDual", "code": "@[simp]\ntheorem toDual_le_toDual [LE \u03b1] {a b : \u03b1} : toDual a \u2264 toDual b \u2194 b \u2264 a", "start": [89, 1], "end": [91, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_lt_toDual", "code": "@[simp]\ntheorem toDual_lt_toDual [LT \u03b1] {a b : \u03b1} : toDual a < toDual b \u2194 b < a", "start": [94, 1], "end": [96, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_le_ofDual", "code": "@[simp]\ntheorem ofDual_le_ofDual [LE \u03b1] {a b : \u03b1\u1d52\u1d48} : ofDual a \u2264 ofDual b \u2194 b \u2264 a", "start": [99, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_lt_ofDual", "code": "@[simp]\ntheorem ofDual_lt_ofDual [LT \u03b1] {a b : \u03b1\u1d52\u1d48} : ofDual a < ofDual b \u2194 b < a", "start": [104, 1], "end": [106, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.le_toDual", "code": "theorem le_toDual [LE \u03b1] {a : \u03b1\u1d52\u1d48} {b : \u03b1} : a \u2264 toDual b \u2194 b \u2264 ofDual a", "start": [109, 1], "end": [110, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.lt_toDual", "code": "theorem lt_toDual [LT \u03b1] {a : \u03b1\u1d52\u1d48} {b : \u03b1} : a < toDual b \u2194 b < ofDual a", "start": [113, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_le", "code": "theorem toDual_le [LE \u03b1] {a : \u03b1} {b : \u03b1\u1d52\u1d48} : toDual a \u2264 b \u2194 ofDual b \u2264 a", "start": [117, 1], "end": [118, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_lt", "code": "theorem toDual_lt [LT \u03b1] {a : \u03b1} {b : \u03b1\u1d52\u1d48} : toDual a < b \u2194 ofDual b < a", "start": [121, 1], "end": [122, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.rec", "code": "@[elab_as_elim]\nprotected def rec {C : \u03b1\u1d52\u1d48 \u2192 Sort*} (h\u2082 : \u2200 a : \u03b1, C (toDual a)) : \u2200 a : \u03b1\u1d52\u1d48, C a :=\n  h\u2082", "start": [125, 1], "end": [128, 5], "kind": "commanddeclaration"}, {"full_name": "OrderDual.forall", "code": "@[simp]\nprotected theorem \u00abforall\u00bb {p : \u03b1\u1d52\u1d48 \u2192 Prop} : (\u2200 a, p a) \u2194 \u2200 a, p (toDual a)", "start": [131, 1], "end": [133, 10], "kind": "commanddeclaration"}, {"full_name": "OrderDual.exists", "code": "@[simp]\nprotected theorem \u00abexists\u00bb {p : \u03b1\u1d52\u1d48 \u2192 Prop} : (\u2203 a, p a) \u2194 \u2203 a, p (toDual a)", "start": [136, 1], "end": [138, 10], "kind": "commanddeclaration"}, {"full_name": "LE.le.dual", "code": "alias \u27e8_, _root_.LE.le.dual\u27e9 := toDual_le_toDual", "start": [141, 1], "end": [141, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LT.lt.dual", "code": "alias \u27e8_, _root_.LT.lt.dual\u27e9 := toDual_lt_toDual", "start": [143, 1], "end": [143, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LE.le.ofDual", "code": "alias \u27e8_, _root_.LE.le.ofDual\u27e9 := ofDual_le_ofDual", "start": [145, 1], "end": [145, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LT.lt.ofDual", "code": "alias \u27e8_, _root_.LT.lt.ofDual\u27e9 := ofDual_lt_ofDual", "start": [148, 1], "end": [148, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Lex", "code": "def Lex (\u03b1 : Type*) :=\n  \u03b1", "start": [156, 1], "end": [158, 4], "kind": "commanddeclaration"}, {"full_name": "toLex", "code": "@[match_pattern]\ndef toLex : \u03b1 \u2243 Lex \u03b1 :=\n  Equiv.refl _", "start": [161, 1], "end": [164, 15], "kind": "commanddeclaration"}, {"full_name": "ofLex", "code": "@[match_pattern]\ndef ofLex : Lex \u03b1 \u2243 \u03b1 :=\n  Equiv.refl _", "start": [167, 1], "end": [170, 15], "kind": "commanddeclaration"}, {"full_name": "toLex_symm_eq", "code": "@[simp]\ntheorem toLex_symm_eq : (@toLex \u03b1).symm = ofLex", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "ofLex_symm_eq", "code": "@[simp]\ntheorem ofLex_symm_eq : (@ofLex \u03b1).symm = toLex", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "toLex_ofLex", "code": "@[simp]\ntheorem toLex_ofLex (a : Lex \u03b1) : toLex (ofLex a) = a", "start": [183, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "ofLex_toLex", "code": "@[simp]\ntheorem ofLex_toLex (a : \u03b1) : ofLex (toLex a) = a", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "toLex_inj", "code": "theorem toLex_inj {a b : \u03b1} : toLex a = toLex b \u2194 a = b", "start": [195, 1], "end": [196, 10], "kind": "commanddeclaration"}, {"full_name": "ofLex_inj", "code": "theorem ofLex_inj {a b : Lex \u03b1} : ofLex a = ofLex b \u2194 a = b", "start": [201, 1], "end": [202, 10], "kind": "commanddeclaration"}, {"full_name": "Lex.rec", "code": "protected def Lex.rec {\u03b2 : Lex \u03b1 \u2192 Sort*} (h : \u2200 a, \u03b2 (toLex a)) : \u2200 a, \u03b2 a := fun a => h (ofLex a)", "start": [205, 1], "end": [206, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Tactic.lean", "imports": ["Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.modifyMetavarDecl", "code": "def modifyMetavarDecl [MonadMCtx m] (mvarId : MVarId)\n    (f : MetavarDecl \u2192 MetavarDecl) : m Unit := do\n  modifyMCtx \u03bb mctx =>\n    match mctx.decls.find? mvarId with\n    | none => mctx\n    | some mdecl => { mctx with decls := mctx.decls.insert mvarId (f mdecl) }", "start": [23, 1], "end": [40, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.modifyTarget", "code": "def modifyTarget [MonadMCtx m] (mvarId : MVarId) (f : Expr \u2192 Expr) : m Unit :=\n  modifyMetavarDecl mvarId fun mdecl \u21a6\n    { mdecl with type := f mdecl.type }", "start": [42, 1], "end": [49, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.modifyLocalContext", "code": "def modifyLocalContext [MonadMCtx m] (mvarId : MVarId)\n    (f : LocalContext \u2192 LocalContext) : m Unit :=\n  modifyMetavarDecl mvarId fun mdecl \u21a6\n    { mdecl with lctx := f mdecl.lctx }", "start": [51, 1], "end": [62, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.modifyLocalDecl", "code": "def modifyLocalDecl [MonadMCtx m] (mvarId : MVarId) (fvarId : FVarId)\n    (f : LocalDecl \u2192 LocalDecl) : m Unit :=\n  modifyLocalContext mvarId fun lctx \u21a6 lctx.modifyLocalDecl fvarId f", "start": [64, 1], "end": [76, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Int/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/ZeroOne.lean", "lake-packages/std/Std/Data/Int/Lemmas.lean"], "premises": [{"full_name": "Int.coe_nat_eq", "code": "protected theorem coe_nat_eq (n : \u2115) : \u2191n = Int.ofNat n", "start": [23, 1], "end": [24, 6], "kind": "commanddeclaration"}, {"full_name": "Int.zero", "code": "@[deprecated] protected def zero : \u2124 := ofNat 0", "start": [27, 1], "end": [28, 48], "kind": "commanddeclaration"}, {"full_name": "Int.one", "code": "@[deprecated] protected def one : \u2124 := ofNat 1", "start": [30, 1], "end": [31, 47], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_out", "code": "protected theorem ofNat_add_out (m n : \u2115) : \u2191m + \u2191n = (\u2191(m + n) : \u2124)", "start": [52, 1], "end": [52, 76], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_mul_out", "code": "protected theorem ofNat_mul_out (m n : \u2115) : \u2191m * \u2191n = (\u2191(m * n) : \u2124)", "start": [55, 1], "end": [55, 76], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_add_one_out", "code": "protected theorem ofNat_add_one_out (n : \u2115) : \u2191n + (1 : \u2124) = \u2191(succ n)", "start": [58, 1], "end": [58, 78], "kind": "commanddeclaration"}, {"full_name": "Int.neg_eq_neg", "code": "protected theorem neg_eq_neg {a b : \u2124} (h : -a = -b) : a = b", "start": [77, 1], "end": [77, 80], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_natAbs_eq_zero", "code": "@[deprecated natAbs_eq_zero]\ntheorem eq_zero_of_natAbs_eq_zero : \u2200 {a : \u2124}, natAbs a = 0 \u2192 a = 0", "start": [90, 1], "end": [91, 88], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_pos_of_ne_zero", "code": "@[deprecated natAbs_pos]\ntheorem natAbs_pos_of_ne_zero {a : \u2124} (h : a \u2260 0) : 0 < natAbs a", "start": [94, 1], "end": [95, 83], "kind": "commanddeclaration"}, {"full_name": "Int.natMod", "code": "def natMod (m n : \u2124) : \u2115 := (m % n).toNat", "start": [135, 1], "end": [136, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Function/Conjugate.lean", "imports": ["Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Semiconj", "code": "def Semiconj (f : \u03b1 \u2192 \u03b2) (ga : \u03b1 \u2192 \u03b1) (gb : \u03b2 \u2192 \u03b2) : Prop :=\n  \u2200 x, f (ga x) = gb (f x)", "start": [26, 1], "end": [32, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.comp_eq", "code": "protected theorem comp_eq (h : Semiconj f ga gb) : f \u2218 ga = gb \u2218 f", "start": [39, 1], "end": [40, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.eq", "code": "protected theorem eq (h : Semiconj f ga gb) (x : \u03b1) : f (ga x) = gb (f x)", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.comp_right", "code": "theorem comp_right (h : Semiconj f ga gb) (h' : Semiconj f ga' gb') :\n    Semiconj f (ga \u2218 ga') (gb \u2218 gb')", "start": [47, 1], "end": [49, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.comp_left", "code": "theorem comp_left (hab : Semiconj fab ga gb) (hbc : Semiconj fbc gb gc) :\n    Semiconj (fbc \u2218 fab) ga gc", "start": [52, 1], "end": [54, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.id_right", "code": "theorem id_right : Semiconj f id id", "start": [57, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.id_left", "code": "theorem id_left : Semiconj id ga ga", "start": [61, 1], "end": [62, 14], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.inverses_right", "code": "theorem inverses_right (h : Semiconj f ga gb) (ha : RightInverse ga' ga) (hb : LeftInverse gb' gb) :\n    Semiconj f ga' gb'", "start": [65, 1], "end": [67, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.option_map", "code": "theorem option_map {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2} (h : Semiconj f ga gb) :\n    Semiconj (Option.map f) (Option.map ga) (Option.map gb)", "start": [70, 1], "end": [73, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Commute", "code": "protected def Commute (f g : \u03b1 \u2192 \u03b1) : Prop :=\n  Semiconj f g g", "start": [78, 1], "end": [84, 17], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.commute", "code": "theorem Semiconj.commute {f g : \u03b1 \u2192 \u03b1} (h : Semiconj f g g) : Commute f g", "start": [89, 1], "end": [91, 79], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.semiconj", "code": "theorem semiconj (h : Commute f g) : Semiconj f g g", "start": [98, 1], "end": [100, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.refl", "code": "@[refl]\ntheorem refl (f : \u03b1 \u2192 \u03b1) : Commute f f", "start": [102, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.symm", "code": "@[symm]\ntheorem symm (h : Commute f g) : Commute g f", "start": [107, 1], "end": [109, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.comp_right", "code": "theorem comp_right (h : Commute f g) (h' : Commute f g') : Commute f (g \u2218 g')", "start": [112, 1], "end": [113, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.comp_left", "code": "theorem comp_left (h : Commute f g) (h' : Commute f' g) : Commute (f \u2218 f') g", "start": [116, 1], "end": [117, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.id_right", "code": "theorem id_right : Commute f id", "start": [120, 1], "end": [121, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.id_left", "code": "theorem id_left : Commute id f", "start": [124, 1], "end": [125, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.option_map", "code": "theorem option_map {f g : \u03b1 \u2192 \u03b1} : Commute f g \u2192 Commute (Option.map f) (Option.map g)", "start": [128, 1], "end": [129, 22], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082", "code": "def Semiconj\u2082 (f : \u03b1 \u2192 \u03b2) (ga : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (gb : \u03b2 \u2192 \u03b2 \u2192 \u03b2) : Prop :=\n  \u2200 x y, f (ga x y) = gb (f x) (f y)", "start": [134, 1], "end": [140, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.eq", "code": "protected theorem eq (h : Semiconj\u2082 f ga gb) (x y : \u03b1) : f (ga x y) = gb (f x) (f y)", "start": [147, 1], "end": [148, 8], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.comp_eq", "code": "protected theorem comp_eq (h : Semiconj\u2082 f ga gb) : bicompr f ga = bicompl gb f f", "start": [151, 1], "end": [152, 31], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.id_left", "code": "theorem id_left (op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : Semiconj\u2082 id op op", "start": [155, 1], "end": [155, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.comp", "code": "theorem comp {f' : \u03b2 \u2192 \u03b3} {gc : \u03b3 \u2192 \u03b3 \u2192 \u03b3} (hf' : Semiconj\u2082 f' gb gc) (hf : Semiconj\u2082 f ga gb) :\n    Semiconj\u2082 (f' \u2218 f) ga gc", "start": [158, 1], "end": [159, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.isAssociative_right", "code": "theorem isAssociative_right [IsAssociative \u03b1 ga] (h : Semiconj\u2082 f ga gb) (h_surj : Surjective f) :\n    IsAssociative \u03b2 gb", "start": [162, 1], "end": [164, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.isAssociative_left", "code": "theorem isAssociative_left [IsAssociative \u03b2 gb] (h : Semiconj\u2082 f ga gb) (h_inj : Injective f) :\n    IsAssociative \u03b1 ga", "start": [167, 1], "end": [169, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.isIdempotent_right", "code": "theorem isIdempotent_right [IsIdempotent \u03b1 ga] (h : Semiconj\u2082 f ga gb) (h_surj : Surjective f) :\n    IsIdempotent \u03b2 gb", "start": [172, 1], "end": [174, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.isIdempotent_left", "code": "theorem isIdempotent_left [IsIdempotent \u03b2 gb] (h : Semiconj\u2082 f ga gb) (h_inj : Injective f) :\n    IsIdempotent \u03b1 ga", "start": [177, 1], "end": [179, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nondet/Basic.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "Mathlib/Data/MLList/Basic.lean", "lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nondet", "code": "@[nolint unusedArguments]\nstructure Nondet (m : Type \u2192 Type) [MonadBacktrack \u03c3 m] (\u03b1 : Type) : Type where\n  \n  toMLList : MLList m (\u03b1 \u00d7 \u03c3)", "start": [32, 1], "end": [52, 30], "kind": "commanddeclaration"}, {"full_name": "Nondet.nil", "code": "def nil : Nondet m \u03b1 := .mk .nil", "start": [58, 1], "end": [59, 33], "kind": "commanddeclaration"}, {"full_name": "Nondet.squash", "code": "def squash (L : Unit \u2192 m (Nondet m \u03b1)) : Nondet m \u03b1 :=\n  .mk <| MLList.squash fun _ => return (\u2190 L ()).toMLList", "start": [63, 1], "end": [67, 57], "kind": "commanddeclaration"}, {"full_name": "Nondet.bind", "code": "partial def bind (L : Nondet m \u03b1) (f : \u03b1 \u2192 Nondet m \u03b2) : Nondet m \u03b2 := .squash fun _ => do\n  match \u2190 L.toMLList.uncons with\n  | none => pure .nil\n  | some (\u27e8x, s\u27e9, xs) => do\n    let r := (Nondet.mk xs).bind f\n    restoreState s\n    match \u2190 (f x).toMLList.uncons with\n    | none => return r\n    | some (y, ys) => return .mk <| .cons y (ys.append (fun _ => r.toMLList))", "start": [69, 1], "end": [81, 78], "kind": "commanddeclaration"}, {"full_name": "Nondet.singletonM", "code": "def singletonM (x : m \u03b1) : Nondet m \u03b1 :=\n  .mk <| .singletonM do\n    let a \u2190 x\n    return (a, \u2190 saveState)", "start": [83, 1], "end": [87, 28], "kind": "commanddeclaration"}, {"full_name": "Nondet.singleton", "code": "def singleton (x : \u03b1) : Nondet m \u03b1 := singletonM (pure x)", "start": [89, 1], "end": [90, 58], "kind": "commanddeclaration"}, {"full_name": "Nondet.ofListM", "code": "def ofListM (L : List (m \u03b1)) : Nondet m \u03b1 :=\n  .squash fun _ => do\n    let s \u2190 saveState\n    return .mk <| MLList.ofListM <| L.map fun x => do\n      restoreState s\n      let a \u2190 x\n      pure (a, \u2190 saveState)", "start": [105, 1], "end": [115, 28], "kind": "commanddeclaration"}, {"full_name": "Nondet.ofList", "code": "def ofList (L : List \u03b1) : Nondet m \u03b1 := ofListM (L.map pure)", "start": [117, 1], "end": [122, 61], "kind": "commanddeclaration"}, {"full_name": "Nondet.mapM", "code": "partial def mapM (f : \u03b1 \u2192 m \u03b2) (L : Nondet m \u03b1) : Nondet m \u03b2 :=\n  L.bind fun a => singletonM (f a)", "start": [124, 1], "end": [126, 35], "kind": "commanddeclaration"}, {"full_name": "Nondet.map", "code": "def map (f : \u03b1 \u2192 \u03b2) (L : Nondet m \u03b1) : Nondet m \u03b2 :=\n  L.mapM fun a => pure (f a)", "start": [128, 1], "end": [130, 29], "kind": "commanddeclaration"}, {"full_name": "Nondet.ofOptionM", "code": "def ofOptionM (x : m (Option \u03b1)) : Nondet m \u03b1 := .squash fun _ => do\n  match \u2190 x with\n  | none => return .nil\n  | some a => return singleton a", "start": [132, 1], "end": [136, 33], "kind": "commanddeclaration"}, {"full_name": "Nondet.ofOption", "code": "def ofOption (x : Option \u03b1) : Nondet m \u03b1 := ofOptionM (pure x)", "start": [138, 1], "end": [139, 63], "kind": "commanddeclaration"}, {"full_name": "Nondet.filterMapM", "code": "partial def filterMapM (f : \u03b1 \u2192 m (Option \u03b2)) (L : Nondet m \u03b1) : Nondet m \u03b2 :=\n  L.bind fun a => ofOptionM (f a)", "start": [141, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Nondet.filterMap", "code": "def filterMap (f : \u03b1 \u2192 Option \u03b2) (L : Nondet m \u03b1) : Nondet m \u03b2 :=\n  L.filterMapM fun a => pure (f a)", "start": [145, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "Nondet.filterM", "code": "partial def filterM (p : \u03b1 \u2192 m (ULift Bool)) (L : Nondet m \u03b1) : Nondet m \u03b1 :=\n  L.filterMapM fun a => do\n    if (\u2190 p a).down then\n      pure (some a)\n    else\n      pure none", "start": [149, 1], "end": [155, 16], "kind": "commanddeclaration"}, {"full_name": "Nondet.filter", "code": "def filter (p : \u03b1 \u2192 Bool) (L : Nondet m \u03b1) : Nondet m \u03b1 :=\n  L.filterM fun a => pure <| .up (p a)", "start": [157, 1], "end": [159, 39], "kind": "commanddeclaration"}, {"full_name": "Nondet.iterate", "code": "partial def iterate (f : \u03b1 \u2192 Nondet m \u03b1) (a : \u03b1) : Nondet m \u03b1 :=\n  singleton a <|> (f a).bind (iterate f)", "start": [161, 1], "end": [167, 41], "kind": "commanddeclaration"}, {"full_name": "Nondet.head", "code": "def head [Alternative m] (L : Nondet m \u03b1) : m \u03b1 := do\n  let (x, s) \u2190 L.toMLList.head\n  restoreState s\n  return x", "start": [169, 1], "end": [175, 11], "kind": "commanddeclaration"}, {"full_name": "Nondet.firstM", "code": "def firstM [Alternative m] (L : Nondet m \u03b1) (f : \u03b1 \u2192 m (Option \u03b2)) : m \u03b2 :=\n  L.filterMapM f |>.head", "start": [177, 1], "end": [182, 25], "kind": "commanddeclaration"}, {"full_name": "Nondet.toMLList'", "code": "def toMLList' (L : Nondet m \u03b1) : MLList m \u03b1 := L.toMLList.map (\u00b7.1)", "start": [184, 1], "end": [187, 68], "kind": "commanddeclaration"}, {"full_name": "Nondet.toList", "code": "def toList (L : Nondet m \u03b1) : m (List (\u03b1 \u00d7 \u03c3)) := L.toMLList.force", "start": [189, 1], "end": [192, 67], "kind": "commanddeclaration"}, {"full_name": "Nondet.toList'", "code": "def toList' (L : Nondet m \u03b1) : m (List \u03b1) := L.toMLList.map (\u00b7.1) |>.force", "start": [194, 1], "end": [197, 75], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Search/Main.lean", "imports": ["lake-packages/aesop/Aesop/Frontend/Attribute.lean", "lake-packages/aesop/Aesop/Search/Queue.lean", "lake-packages/aesop/Aesop/RuleSet.lean", "lake-packages/aesop/Aesop/Search/Expansion.lean", "lake-packages/aesop/Aesop/Check.lean", "lake-packages/aesop/Aesop/Options.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Tree.lean", "lake-packages/aesop/Aesop/Search/ExpandSafePrefix.lean"], "premises": [{"full_name": "Aesop.nextActiveGoal", "code": "partial def nextActiveGoal : SearchM Q GoalRef := do\n  let some gref \u2190 popGoal?\n    | throwError \"aesop/expandNextGoal: internal error: no active goals left\"\n  if ! (\u2190 (\u2190 gref.get).isActive) then\n    nextActiveGoal\n  else\n    return gref", "start": [25, 1], "end": [31, 16], "kind": "commanddeclaration"}, {"full_name": "Aesop.expandNextGoal", "code": "def expandNextGoal : SearchM Q Unit := do\n  let gref \u2190 nextActiveGoal\n  let g \u2190 gref.get\n  let (initialGoal, initialMetaState) \u2190\n    g.currentGoalAndMetaState (\u2190 getRootMetaState)\n  let result \u2190 withAesopTraceNode .steps\n    (fmt g.id g.priority initialGoal initialMetaState) do\n    initialMetaState.runMetaM' do\n      aesop_trace[steps] \"Initial goal:{indentD initialGoal}\"\n    let maxRappDepth := (\u2190 read).options.maxRuleApplicationDepth\n    if maxRappDepth != 0 && (\u2190 gref.get).depth >= maxRappDepth then\n      aesop_trace[steps] \"Treating the goal as unprovable since it is beyond the maximum rule application depth ({maxRappDepth}).\"\n      gref.markForcedUnprovable\n      setMaxRuleApplicationDepthReached\n      return .failed\n    let result \u2190 expandGoal gref\n    let currentIteration \u2190 getIteration\n    gref.modify \u03bb g => g.setLastExpandedInIteration currentIteration\n    if \u2190 (\u2190 gref.get).isActive then\n      enqueueGoals #[gref]\n    return result\n  match result with\n  | .proved newRapps | .succeeded newRapps => traceNewRapps newRapps\n  | .failed => return\n  where\n    fmt (id : GoalId) (priority : Percent) (initialGoal : MVarId)\n        (initialMetaState : Meta.SavedState)\n        (result : Except Exception RuleResult) : SearchM Q MessageData := do\n      let tgt \u2190 initialMetaState.runMetaM' do\n        initialGoal.withContext do\n          addMessageContext $ toMessageData (\u2190 initialGoal.getType)\n      return m!\"{exceptRuleResultToEmoji (\u00b7.toEmoji) result} (G{id}) [{priority.toHumanString}] \u22ef \u22a2 {tgt}\"\n\n    traceNewRapps (newRapps : Array RappRef) : SearchM Q Unit := do\n      aesop_trace[steps] do\n        for rref in newRapps do\n          let r \u2190 rref.get\n          r.withHeadlineTraceNode .steps\n            (transform := \u03bb msg => return m!\"{newNodeEmoji} \" ++ msg) do\n            withAesopTraceNode .steps (\u03bb _ => return \"Metadata\") do\n              r.traceMetadata .steps\n          r.metaState.runMetaM' do\n            r.forSubgoalsM \u03bb gref => do\n              let g \u2190 gref.get\n              g.withHeadlineTraceNode .steps\n                (transform := \u03bb msg => return m!\"{newNodeEmoji} \" ++ msg) do\n                aesop_trace![steps] g.preNormGoal\n                withAesopTraceNode .steps (\u03bb _ => return \"Metadata\") do\n                  g.traceMetadata .steps", "start": [33, 1], "end": [81, 41], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkGoalLimit", "code": "def checkGoalLimit : SearchM Q (Option MessageData) := do\n  let maxGoals := (\u2190 read).options.maxGoals\n  let currentGoals := (\u2190 getTree).numGoals\n  if maxGoals != 0 && currentGoals >= maxGoals then\n    return m!\"maximum number of goals ({maxGoals}) reached. Set the 'maxGoals' option to increase the limit.\"\n  return none", "start": [83, 1], "end": [88, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkRappLimit", "code": "def checkRappLimit : SearchM Q (Option MessageData) := do\n  let maxRapps := (\u2190 read).options.maxRuleApplications\n  let currentRapps := (\u2190 getTree).numRapps\n  if maxRapps != 0 && currentRapps >= maxRapps then\n    return m!\"maximum number of rule applications ({maxRapps}) reached. Set the 'maxRuleApplications' option to increase the limit.\"\n  return none", "start": [90, 1], "end": [95, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkRootUnprovable", "code": "def checkRootUnprovable : SearchM Q (Option MessageData) := do\n  let root := (\u2190 getTree).root\n  if (\u2190 root.get).state.isUnprovable then\n    let msg :=\n      if \u2190 wasMaxRuleApplicationDepthReached then\n        m!\"failed to prove the goal. Some goals were not explored because the maximum rule application depth ({(\u2190 read).options.maxRuleApplicationDepth}) was reached. Set option 'maxRuleApplicationDepth' to increase the limit.\"\n      else\n        m!\"failed to prove the goal after exhaustive search.\"\n    return msg\n  return none", "start": [97, 1], "end": [106, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.getProof?", "code": "def getProof? : SearchM Q (Option Expr) := do\n  let (some proof) \u2190 getExprMVarAssignment? (\u2190 getRootMVarId)\n    | return none\n  instantiateMVars proof", "start": [108, 1], "end": [111, 25], "kind": "commanddeclaration"}, {"full_name": "Aesop.withPPAnalyze", "code": "private def withPPAnalyze [Monad m] [MonadWithOptions m] (x : m \u03b1) : m \u03b1 :=\n  withOptions (\u00b7.setBool `pp.analyze true) x", "start": [113, 1], "end": [114, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.finalizeProof", "code": "def finalizeProof : SearchM Q Unit := do\n  (\u2190 getRootMVarId).withContext do\n    extractProof\n    let (some proof) \u2190 getProof? | throwError\n      \"aesop: internal error: root goal is proven but its metavariable is not assigned\"\n    if proof.hasExprMVar then\n      let inner :=\n        m!\"Proof: {proof}\\nUnassigned metavariables: {(\u2190 getMVarsNoDelayed proof).map (\u00b7.name)}\"\n      throwError \"aesop: internal error: extracted proof has metavariables.{indentD inner}\"\n    withPPAnalyze do\n      aesop_trace[proof] \"Final proof:{indentExpr proof}\"", "start": [116, 1], "end": [126, 58], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkRenderedScript", "code": "def checkRenderedScript (script : Array Syntax.Tactic) : SearchM Q Unit := do\n  let initialState \u2190 getRootMetaState\n  let rootGoal \u2190 getRootMVarId\n  let go : TacticM Unit := do\n    setGoals [rootGoal]\n    evalTactic $ \u2190 `(tacticSeq| $script:tactic*)\n    unless (\u2190 getUnsolvedGoals).isEmpty do\n      throwError \"script executed successfully but did not solve the main goal\"\n  try\n    show MetaM Unit from withoutModifyingState do\n      initialState.restore\n      go.run { elaborator := .anonymous, recover := false }\n        |>.run' { goals := [rootGoal] }\n        |>.run'\n  catch e => throwError\n    \"{Check.script.name}: error while executing generated script:{indentD e.toMessageData}\"", "start": [129, 1], "end": [144, 92], "kind": "commanddeclaration"}, {"full_name": "Aesop.checkScriptSteps", "code": "def checkScriptSteps (script : UnstructuredScript) : SearchM Q Unit := do\n  try\n    script.validate\n  catch e =>\n    throwError \"{Check.scriptSteps.name}: {e.toMessageData}\"", "start": [146, 1], "end": [150, 61], "kind": "commanddeclaration"}, {"full_name": "Aesop.traceScript", "code": "def traceScript : SearchM Q Unit := do\n  let options := (\u2190 read).options\n  if ! options.generateScript then\n    return\n  try\n    let uscript \u2190 (\u2190 getRootMVarCluster).extractScript\n    if \u2190 Check.scriptSteps.isEnabled then\n      checkScriptSteps uscript\n    let goal \u2190 getRootMVarId\n    let goalMVars \u2190 goal.getMVarDependencies\n    let tacticState :=\n      { visibleGoals := #[\u27e8goal, goalMVars\u27e9], invisibleGoals := {} }\n    let script \u2190 uscript.toStructuredScript tacticState\n    let script \u2190 script.render tacticState\n    if options.traceScript then\n      let script \u2190 `(tacticSeq| $script*)\n      addTryThisTacticSeqSuggestion (\u2190 getRef) script\n    if \u2190 Check.script.isEnabled then\n      checkRenderedScript script\n  catch e =>\n    logError m!\"aesop: error while generating tactic script:{indentD e.toMessageData}\"", "start": [152, 1], "end": [172, 87], "kind": "commanddeclaration"}, {"full_name": "Aesop.traceTree", "code": "def traceTree : SearchM Q Unit := do\n  (\u2190 (\u2190 getRootGoal).get).traceTree .tree", "start": [174, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "Aesop.finishIfProven", "code": "def finishIfProven : SearchM Q Bool := do\n  unless (\u2190 (\u2190 getRootMVarCluster).get).state.isProven do\n    return false\n  finalizeProof\n  traceScript\n  traceTree\n  return true", "start": [177, 1], "end": [183, 14], "kind": "commanddeclaration"}, {"full_name": "Aesop.handleNonfatalError", "code": "def handleNonfatalError (err : MessageData) : SearchM Q (Array MVarId) := do\n  let opts := (\u2190 read).options\n  if opts.terminal then\n    throwTacticEx `aesop (\u2190 getRootMVarId) err\n  if opts.warnOnNonterminal then\n    logWarning m!\"aesop: {err}\"\n  expandSafePrefix\n  let goals \u2190 extractSafePrefix\n  aesop_trace[proof] do\n    match \u2190 getProof? with\n    | some proof =>\n      (\u2190 getRootMVarId).withContext do\n        aesop_trace![proof] \"{proof}\"\n    | none => aesop_trace![proof] \"<no proof>\"\n  traceTree\n  return goals", "start": [197, 1], "end": [212, 15], "kind": "commanddeclaration"}, {"full_name": "Aesop.handleFatalError", "code": "def handleFatalError (e : Exception) : SearchM Q \u03b1 := do\n  traceTree\n  throw e", "start": [214, 1], "end": [216, 10], "kind": "commanddeclaration"}, {"full_name": "Aesop.searchLoop", "code": "partial def searchLoop : SearchM Q (Array MVarId) :=\n  withIncRecDepth do\n    if let (some err) \u2190 checkRootUnprovable then\n      handleNonfatalError err\n    else if \u2190 finishIfProven then\n      return #[]\n    else if let (some err) \u2190 checkGoalLimit then\n      handleNonfatalError err\n    else if let (some err) \u2190 checkRappLimit then\n      handleNonfatalError err\n    else\n      expandNextGoal\n      checkInvariantsIfEnabled\n      incrementIteration\n      searchLoop", "start": [218, 1], "end": [232, 17], "kind": "commanddeclaration"}, {"full_name": "Aesop.search", "code": "def search (goal : MVarId) (ruleSet? : Option RuleSet := none)\n     (options : Aesop.Options := {}) (simpConfig : Aesop.SimpConfig := {})\n     (simpConfigSyntax? : Option Term := none)\n     (profile : Profile := {}) :\n     MetaM (Array MVarId \u00d7 Profile) := do\n  goal.checkNotAssigned `aesop\n  let options \u2190 options.toOptions'\n  let ruleSet \u2190\n    match ruleSet? with\n    | none =>\n        Frontend.getDefaultRuleSet (includeGlobalSimpTheorems := true)\n          options.toOptions\n    | some ruleSet => pure ruleSet\n  let \u27e8Q, _\u27e9 := options.queue\n  let (goals, state, _) \u2190\n    SearchM.run ruleSet options simpConfig simpConfigSyntax? goal profile do\n      show SearchM Q _ from\n      try searchLoop\n      catch e => handleFatalError e\n      finally freeTree\n  return (goals, state.profile)", "start": [234, 1], "end": [254, 32], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/BuiltinRules.lean", "imports": ["lake-packages/aesop/Aesop/BuiltinRules/Split.lean", "lake-packages/aesop/Aesop/BuiltinRules/Ext.lean", "lake-packages/aesop/Aesop/BuiltinRules/ApplyHyps.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/BuiltinRules/Subst.lean", "lake-packages/aesop/Aesop/BuiltinRules/Assumption.lean", "lake-packages/aesop/Aesop/BuiltinRules/Intros.lean", "lake-packages/aesop/Aesop/Frontend.lean", "lake-packages/aesop/Aesop/BuiltinRules/DestructProducts.lean"], "premises": [{"full_name": "Aesop.BuiltinRules.not_intro", "code": "@[aesop (rule_sets [builtin]) safe 0]\ntheorem not_intro (h : P \u2192 False) : \u00ac P", "start": [43, 1], "end": [44, 45], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.empty_false", "code": "@[aesop (rule_sets [builtin]) norm destruct]\ntheorem empty_false (h : Empty) : False", "start": [46, 1], "end": [47, 53], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.pEmpty_false", "code": "@[aesop (rule_sets [builtin]) norm destruct]\ntheorem pEmpty_false (h : PEmpty) : False", "start": [49, 1], "end": [50, 55], "kind": "commanddeclaration"}, {"full_name": "Aesop.BuiltinRules.heq_iff_eq", "code": "@[aesop (rule_sets [builtin]) norm simp]\ntheorem heq_iff_eq (x y : \u03b1) : HEq x y \u2194 x = y", "start": [58, 1], "end": [60, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/RelClasses.lean", "imports": ["Mathlib/Logic/Relation.lean", "Mathlib/Order/Basic.lean", "Mathlib/Logic/IsEmpty.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "of_eq", "code": "theorem of_eq [IsRefl \u03b1 r] : \u2200 {a b}, a = b \u2192 r a b", "start": [29, 1], "end": [30, 28], "kind": "commanddeclaration"}, {"full_name": "comm", "code": "theorem comm [IsSymm \u03b1 r] {a b : \u03b1} : r a b \u2194 r b a", "start": [33, 1], "end": [34, 15], "kind": "commanddeclaration"}, {"full_name": "antisymm'", "code": "theorem antisymm' [IsAntisymm \u03b1 r] {a b : \u03b1} : r a b \u2192 r b a \u2192 b = a", "start": [37, 1], "end": [37, 98], "kind": "commanddeclaration"}, {"full_name": "antisymm_iff", "code": "theorem antisymm_iff [IsRefl \u03b1 r] [IsAntisymm \u03b1 r] {a b : \u03b1} : r a b \u2227 r b a \u2194 a = b", "start": [40, 1], "end": [43, 28], "kind": "commanddeclaration"}, {"full_name": "antisymm_of", "code": "@[elab_without_expected_type]\ntheorem antisymm_of (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsAntisymm \u03b1 r] {a b : \u03b1} : r a b \u2192 r b a \u2192 a = b", "start": [46, 1], "end": [51, 11], "kind": "commanddeclaration"}, {"full_name": "antisymm_of'", "code": "@[elab_without_expected_type]\ntheorem antisymm_of' (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsAntisymm \u03b1 r] {a b : \u03b1} : r a b \u2192 r b a \u2192 b = a", "start": [54, 1], "end": [59, 12], "kind": "commanddeclaration"}, {"full_name": "comm_of", "code": "theorem comm_of (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsSymm \u03b1 r] {a b : \u03b1} : r a b \u2194 r b a", "start": [62, 1], "end": [66, 7], "kind": "commanddeclaration"}, {"full_name": "IsRefl.swap", "code": "theorem IsRefl.swap (r) [IsRefl \u03b1 r] : IsRefl \u03b1 (swap r)", "start": [69, 1], "end": [70, 14], "kind": "commanddeclaration"}, {"full_name": "IsIrrefl.swap", "code": "theorem IsIrrefl.swap (r) [IsIrrefl \u03b1 r] : IsIrrefl \u03b1 (swap r)", "start": [73, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "IsTrans.swap", "code": "theorem IsTrans.swap (r) [IsTrans \u03b1 r] : IsTrans \u03b1 (swap r)", "start": [77, 1], "end": [78, 40], "kind": "commanddeclaration"}, {"full_name": "IsAntisymm.swap", "code": "theorem IsAntisymm.swap (r) [IsAntisymm \u03b1 r] : IsAntisymm \u03b1 (swap r)", "start": [81, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "IsAsymm.swap", "code": "theorem IsAsymm.swap (r) [IsAsymm \u03b1 r] : IsAsymm \u03b1 (swap r)", "start": [85, 1], "end": [86, 38], "kind": "commanddeclaration"}, {"full_name": "IsTotal.swap", "code": "theorem IsTotal.swap (r) [IsTotal \u03b1 r] : IsTotal \u03b1 (swap r)", "start": [89, 1], "end": [90, 37], "kind": "commanddeclaration"}, {"full_name": "IsTrichotomous.swap", "code": "theorem IsTrichotomous.swap (r) [IsTrichotomous \u03b1 r] : IsTrichotomous \u03b1 (swap r)", "start": [93, 1], "end": [94, 91], "kind": "commanddeclaration"}, {"full_name": "IsPreorder.swap", "code": "theorem IsPreorder.swap (r) [IsPreorder \u03b1 r] : IsPreorder \u03b1 (swap r)", "start": [97, 1], "end": [98, 51], "kind": "commanddeclaration"}, {"full_name": "IsStrictOrder.swap", "code": "theorem IsStrictOrder.swap (r) [IsStrictOrder \u03b1 r] : IsStrictOrder \u03b1 (swap r)", "start": [101, 1], "end": [102, 53], "kind": "commanddeclaration"}, {"full_name": "IsPartialOrder.swap", "code": "theorem IsPartialOrder.swap (r) [IsPartialOrder \u03b1 r] : IsPartialOrder \u03b1 (swap r)", "start": [105, 1], "end": [106, 58], "kind": "commanddeclaration"}, {"full_name": "IsTotalPreorder.swap", "code": "theorem IsTotalPreorder.swap (r) [IsTotalPreorder \u03b1 r] : IsTotalPreorder \u03b1 (swap r)", "start": [109, 1], "end": [110, 55], "kind": "commanddeclaration"}, {"full_name": "IsLinearOrder.swap", "code": "theorem IsLinearOrder.swap (r) [IsLinearOrder \u03b1 r] : IsLinearOrder \u03b1 (swap r)", "start": [113, 1], "end": [114, 59], "kind": "commanddeclaration"}, {"full_name": "IsAsymm.isAntisymm", "code": "protected theorem IsAsymm.isAntisymm (r) [IsAsymm \u03b1 r] : IsAntisymm \u03b1 r", "start": [117, 1], "end": [118, 47], "kind": "commanddeclaration"}, {"full_name": "IsAsymm.isIrrefl", "code": "protected theorem IsAsymm.isIrrefl [IsAsymm \u03b1 r] : IsIrrefl \u03b1 r", "start": [121, 1], "end": [122, 32], "kind": "commanddeclaration"}, {"full_name": "IsTotal.isTrichotomous", "code": "protected theorem IsTotal.isTrichotomous (r) [IsTotal \u03b1 r] : IsTrichotomous \u03b1 r", "start": [125, 1], "end": [126, 57], "kind": "commanddeclaration"}, {"full_name": "IsTotal.to_isRefl", "code": "instance (priority := 100) IsTotal.to_isRefl (r) [IsTotal \u03b1 r] : IsRefl \u03b1 r :=\n  \u27e8fun a => (or_self_iff _).1 <| total_of r a a\u27e9", "start": [130, 1], "end": [131, 49], "kind": "commanddeclaration"}, {"full_name": "ne_of_irrefl", "code": "theorem ne_of_irrefl {r} [IsIrrefl \u03b1 r] : \u2200 {x y : \u03b1}, r x y \u2192 x \u2260 y", "start": [133, 1], "end": [134, 31], "kind": "commanddeclaration"}, {"full_name": "ne_of_irrefl'", "code": "theorem ne_of_irrefl' {r} [IsIrrefl \u03b1 r] : \u2200 {x y : \u03b1}, r x y \u2192 y \u2260 x", "start": [137, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "not_rel_of_subsingleton", "code": "theorem not_rel_of_subsingleton (r) [IsIrrefl \u03b1 r] [Subsingleton \u03b1] (x y) : \u00acr x y", "start": [141, 1], "end": [142, 35], "kind": "commanddeclaration"}, {"full_name": "rel_of_subsingleton", "code": "theorem rel_of_subsingleton (r) [IsRefl \u03b1 r] [Subsingleton \u03b1] (x y) : r x y", "start": [145, 1], "end": [146, 33], "kind": "commanddeclaration"}, {"full_name": "empty_relation_apply", "code": "@[simp]\ntheorem empty_relation_apply (a b : \u03b1) : EmptyRelation a b \u2194 False", "start": [149, 1], "end": [151, 10], "kind": "commanddeclaration"}, {"full_name": "eq_empty_relation", "code": "theorem eq_empty_relation (r) [IsIrrefl \u03b1 r] [Subsingleton \u03b1] : r = EmptyRelation", "start": [154, 1], "end": [155, 54], "kind": "commanddeclaration"}, {"full_name": "trans_trichotomous_left", "code": "theorem trans_trichotomous_left [IsTrans \u03b1 r] [IsTrichotomous \u03b1 r] {a b c : \u03b1} :\n    \u00acr b a \u2192 r b c \u2192 r a c", "start": [161, 1], "end": [165, 48], "kind": "commanddeclaration"}, {"full_name": "trans_trichotomous_right", "code": "theorem trans_trichotomous_right [IsTrans \u03b1 r] [IsTrichotomous \u03b1 r] {a b c : \u03b1} :\n    r a b \u2192 \u00acr c b \u2192 r a c", "start": [168, 1], "end": [172, 48], "kind": "commanddeclaration"}, {"full_name": "transitive_of_trans", "code": "theorem transitive_of_trans (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] : Transitive r", "start": [175, 1], "end": [175, 93], "kind": "commanddeclaration"}, {"full_name": "extensional_of_trichotomous_of_irrefl", "code": "theorem extensional_of_trichotomous_of_irrefl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrichotomous \u03b1 r] [IsIrrefl \u03b1 r]\n    {a b : \u03b1} (H : \u2200 x, r x a \u2194 r x b) : a = b", "start": [178, 1], "end": [182, 16], "kind": "commanddeclaration"}, {"full_name": "partialOrderOfSO", "code": "@[reducible]\ndef partialOrderOfSO (r) [IsStrictOrder \u03b1 r] : PartialOrder \u03b1 where\n  le x y := x = y \u2228 r x y\n  lt := r\n  le_refl x := Or.inl rfl\n  le_trans x y z h\u2081 h\u2082 :=\n    match y, z, h\u2081, h\u2082 with\n    | _, _, Or.inl rfl, h\u2082 => h\u2082\n    | _, _, h\u2081, Or.inl rfl => h\u2081\n    | _, _, Or.inr h\u2081, Or.inr h\u2082 => Or.inr (_root_.trans h\u2081 h\u2082)\n  le_antisymm x y h\u2081 h\u2082 :=\n    match y, h\u2081, h\u2082 with\n    | _, Or.inl rfl, _ => rfl\n    | _, _, Or.inl rfl => rfl\n    | _, Or.inr h\u2081, Or.inr h\u2082 => (asymm h\u2081 h\u2082).elim\n  lt_iff_le_not_le x y :=\n    \u27e8fun h => \u27e8Or.inr h, not_or_of_not (fun e => by rw [e] at h; exact irrefl _ h) (asymm h)\u27e9,\n      fun \u27e8h\u2081, h\u2082\u27e9 => h\u2081.resolve_left fun e => h\u2082 <| e \u25b8 Or.inl rfl\u27e9", "start": [185, 1], "end": [205, 69], "kind": "commanddeclaration"}, {"full_name": "linearOrderOfSTO", "code": "@[reducible]\ndef linearOrderOfSTO (r) [IsStrictTotalOrder \u03b1 r] [\u2200 x y, Decidable \u00acr x y] : LinearOrder \u03b1 :=\n  let hD : DecidableRel (fun x y => x = y \u2228 r x y) := fun x y =>\n      decidable_of_iff (\u00acr y x)\n        \u27e8fun h => ((trichotomous_of r y x).resolve_left h).imp Eq.symm id, fun h =>\n          h.elim (fun h => h \u25b8 irrefl_of _ _) (asymm_of r)\u27e9\n  { partialOrderOfSO r with\n    le_total := fun x y =>\n      match y, trichotomous_of r x y with\n      | y, Or.inl h => Or.inl (Or.inr h)\n      | _, Or.inr (Or.inl rfl) => Or.inl (Or.inl rfl)\n      | _, Or.inr (Or.inr h) => Or.inr (Or.inr h),\n    toMin := minOfLe,\n    toMax := maxOfLe,\n    decidableLE := hD }", "start": [209, 1], "end": [226, 24], "kind": "commanddeclaration"}, {"full_name": "IsStrictTotalOrder.swap", "code": "theorem IsStrictTotalOrder.swap (r) [IsStrictTotalOrder \u03b1 r] : IsStrictTotalOrder \u03b1 (swap r)", "start": [230, 1], "end": [231, 55], "kind": "commanddeclaration"}, {"full_name": "IsOrderConnected", "code": "class IsOrderConnected (\u03b1 : Type u) (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  \n  conn : \u2200 a b c, lt a c \u2192 lt a b \u2228 lt b c", "start": [236, 1], "end": [242, 43], "kind": "commanddeclaration"}, {"full_name": "IsOrderConnected.neg_trans", "code": "theorem IsOrderConnected.neg_trans {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsOrderConnected \u03b1 r] {a b c}\n    (h\u2081 : \u00acr a b) (h\u2082 : \u00acr b c) : \u00acr a c", "start": [245, 1], "end": [247, 55], "kind": "commanddeclaration"}, {"full_name": "isStrictWeakOrder_of_isOrderConnected", "code": "theorem isStrictWeakOrder_of_isOrderConnected [IsAsymm \u03b1 r] [IsOrderConnected \u03b1 r] :\n    IsStrictWeakOrder \u03b1 r", "start": [250, 1], "end": [255, 77], "kind": "commanddeclaration"}, {"full_name": "isStrictOrderConnected_of_isStrictTotalOrder", "code": "instance (priority := 100) isStrictOrderConnected_of_isStrictTotalOrder [IsStrictTotalOrder \u03b1 r] :\n    IsOrderConnected \u03b1 r :=\n  \u27e8\u03bb _ _ _ h => (trichotomous _ _).imp_right\n    fun o => o.elim (fun e => e \u25b8 h) fun h' => _root_.trans h' h\u27e9", "start": [259, 1], "end": [262, 66], "kind": "commanddeclaration"}, {"full_name": "isStrictTotalOrder_of_isStrictTotalOrder", "code": "instance (priority := 100) isStrictTotalOrder_of_isStrictTotalOrder [IsStrictTotalOrder \u03b1 r] :\n    IsStrictWeakOrder \u03b1 r :=\n  { isStrictWeakOrder_of_isOrderConnected with }", "start": [266, 1], "end": [268, 49], "kind": "commanddeclaration"}, {"full_name": "IsWellFounded", "code": "@[mk_iff] class IsWellFounded (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop where\n  \n  wf : WellFounded r", "start": [274, 1], "end": [277, 21], "kind": "commanddeclaration"}, {"full_name": "WellFoundedRelation.isWellFounded", "code": "instance WellFoundedRelation.isWellFounded [h : WellFoundedRelation \u03b1] :\n    IsWellFounded \u03b1 WellFoundedRelation.rel :=\n  { h with }", "start": [285, 1], "end": [287, 13], "kind": "commanddeclaration"}, {"full_name": "WellFoundedRelation.asymmetric", "code": "theorem WellFoundedRelation.asymmetric {\u03b1 : Sort*} [WellFoundedRelation \u03b1] {a b : \u03b1} :\n    WellFoundedRelation.rel a b \u2192 \u00ac WellFoundedRelation.rel b a", "start": [289, 1], "end": [292, 22], "kind": "commanddeclaration"}, {"full_name": "WellFounded.prod_lex", "code": "lemma WellFounded.prod_lex {ra : \u03b1 \u2192 \u03b1 \u2192 Prop} {rb : \u03b2 \u2192 \u03b2 \u2192 Prop} (ha : WellFounded ra)\n    (hb : WellFounded rb) : WellFounded (Prod.Lex ra rb) :=\n  (Prod.lex \u27e8_, ha\u27e9 \u27e8_, hb\u27e9).wf", "start": [294, 1], "end": [296, 32], "kind": "mathlibtacticlemma"}, {"full_name": "IsWellFounded.induction", "code": "theorem induction {C : \u03b1 \u2192 Prop} : \u2200 a, (\u2200 x, (\u2200 y, r y x \u2192 C y) \u2192 C x) \u2192 C a", "start": [303, 1], "end": [305, 15], "kind": "commanddeclaration"}, {"full_name": "IsWellFounded.apply", "code": "theorem apply : \u2200 a, Acc r a", "start": [308, 1], "end": [310, 11], "kind": "commanddeclaration"}, {"full_name": "IsWellFounded.fix", "code": "def fix {C : \u03b1 \u2192 Sort*} : (\u2200 x : \u03b1, (\u2200 y : \u03b1, r y x \u2192 C y) \u2192 C x) \u2192 \u2200 x : \u03b1, C x :=\n  wf.fix", "start": [313, 1], "end": [316, 9], "kind": "commanddeclaration"}, {"full_name": "IsWellFounded.fix_eq", "code": "theorem fix_eq {C : \u03b1 \u2192 Sort*} (F : \u2200 x : \u03b1, (\u2200 y : \u03b1, r y x \u2192 C y) \u2192 C x) :\n    \u2200 x, fix r F x = F x fun y _ => fix r F y", "start": [319, 1], "end": [322, 14], "kind": "commanddeclaration"}, {"full_name": "IsWellFounded.toWellFoundedRelation", "code": "def toWellFoundedRelation : WellFoundedRelation \u03b1 :=\n  \u27e8r, IsWellFounded.wf\u27e9", "start": [325, 1], "end": [327, 24], "kind": "commanddeclaration"}, {"full_name": "WellFounded.asymmetric", "code": "theorem WellFounded.asymmetric {\u03b1 : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : WellFounded r) (a b) :\n    r a b \u2192 \u00acr b a", "start": [331, 1], "end": [333, 47], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT", "code": "@[reducible]\ndef WellFoundedLT (\u03b1 : Type*) [LT \u03b1] : Prop :=\n  IsWellFounded \u03b1 (\u00b7 < \u00b7)", "start": [347, 1], "end": [350, 26], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT", "code": "@[reducible]\ndef WellFoundedGT (\u03b1 : Type*) [LT \u03b1] : Prop :=\n  IsWellFounded \u03b1 (\u00b7 > \u00b7)", "start": [353, 1], "end": [356, 26], "kind": "commanddeclaration"}, {"full_name": "wellFoundedGT_dual_iff", "code": "theorem wellFoundedGT_dual_iff (\u03b1 : Type*) [LT \u03b1] : WellFoundedGT \u03b1\u1d52\u1d48 \u2194 WellFoundedLT \u03b1", "start": [367, 1], "end": [368, 37], "kind": "commanddeclaration"}, {"full_name": "wellFoundedLT_dual_iff", "code": "theorem wellFoundedLT_dual_iff (\u03b1 : Type*) [LT \u03b1] : WellFoundedLT \u03b1\u1d52\u1d48 \u2194 WellFoundedGT \u03b1", "start": [371, 1], "end": [372, 37], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder", "code": "class IsWellOrder (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) extends\n  IsTrichotomous \u03b1 r, IsTrans \u03b1 r, IsWellFounded \u03b1 r : Prop", "start": [375, 1], "end": [377, 60], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT.induction", "code": "theorem induction {C : \u03b1 \u2192 Prop} : \u2200 a, (\u2200 x, (\u2200 y, y < x \u2192 C y) \u2192 C x) \u2192 C a", "start": [404, 1], "end": [406, 28], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT.apply", "code": "theorem apply : \u2200 a : \u03b1, Acc (\u00b7 < \u00b7) a", "start": [409, 1], "end": [411, 24], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT.fix", "code": "def fix {C : \u03b1 \u2192 Sort*} : (\u2200 x : \u03b1, (\u2200 y : \u03b1, y < x \u2192 C y) \u2192 C x) \u2192 \u2200 x : \u03b1, C x :=\n  IsWellFounded.fix (\u00b7 < \u00b7)", "start": [414, 1], "end": [417, 28], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT.fix_eq", "code": "theorem fix_eq {C : \u03b1 \u2192 Sort*} (F : \u2200 x : \u03b1, (\u2200 y : \u03b1, y < x \u2192 C y) \u2192 C x) :\n    \u2200 x, fix F x = F x fun y _ => fix F y", "start": [420, 1], "end": [423, 27], "kind": "commanddeclaration"}, {"full_name": "WellFoundedLT.toWellFoundedRelation", "code": "def toWellFoundedRelation : WellFoundedRelation \u03b1 :=\n  IsWellFounded.toWellFoundedRelation (\u00b7 < \u00b7)", "start": [426, 1], "end": [428, 46], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT.induction", "code": "theorem induction {C : \u03b1 \u2192 Prop} : \u2200 a, (\u2200 x, (\u2200 y, x < y \u2192 C y) \u2192 C x) \u2192 C a", "start": [436, 1], "end": [438, 28], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT.apply", "code": "theorem apply : \u2200 a : \u03b1, Acc (\u00b7 > \u00b7) a", "start": [441, 1], "end": [443, 24], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT.fix", "code": "def fix {C : \u03b1 \u2192 Sort*} : (\u2200 x : \u03b1, (\u2200 y : \u03b1, x < y \u2192 C y) \u2192 C x) \u2192 \u2200 x : \u03b1, C x :=\n  IsWellFounded.fix (\u00b7 > \u00b7)", "start": [446, 1], "end": [449, 28], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT.fix_eq", "code": "theorem fix_eq {C : \u03b1 \u2192 Sort*} (F : \u2200 x : \u03b1, (\u2200 y : \u03b1, x < y \u2192 C y) \u2192 C x) :\n    \u2200 x, fix F x = F x fun y _ => fix F y", "start": [452, 1], "end": [455, 27], "kind": "commanddeclaration"}, {"full_name": "WellFoundedGT.toWellFoundedRelation", "code": "def toWellFoundedRelation : WellFoundedRelation \u03b1 :=\n  IsWellFounded.toWellFoundedRelation (\u00b7 > \u00b7)", "start": [458, 1], "end": [460, 46], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder.linearOrder", "code": "noncomputable def IsWellOrder.linearOrder (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : LinearOrder \u03b1 :=\n  letI := fun x y => Classical.dec \u00acr x y\n  linearOrderOfSTO r", "start": [464, 1], "end": [467, 21], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder.toHasWellFounded", "code": "def IsWellOrder.toHasWellFounded [LT \u03b1] [hwo : IsWellOrder \u03b1 (\u00b7 < \u00b7)] : WellFoundedRelation \u03b1 where\n  rel := (\u00b7 < \u00b7)\n  wf := hwo.wf", "start": [470, 1], "end": [473, 15], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.isWellOrder", "code": "theorem Subsingleton.isWellOrder [Subsingleton \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [hr : IsIrrefl \u03b1 r] :\n    IsWellOrder \u03b1 r", "start": [477, 1], "end": [482, 78], "kind": "commanddeclaration"}, {"full_name": "Subrelation.isWellFounded", "code": "theorem Subrelation.isWellFounded (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellFounded \u03b1 r] {s : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (h : Subrelation s r) : IsWellFounded \u03b1 s", "start": [517, 1], "end": [519, 26], "kind": "commanddeclaration"}, {"full_name": "Prod.wellFoundedLT", "code": "instance Prod.wellFoundedLT [PartialOrder \u03b1] [WellFoundedLT \u03b1] [Preorder \u03b2] [WellFoundedLT \u03b2] :\n    WellFoundedLT (\u03b1 \u00d7 \u03b2) where\n  wf := by\n    refine @Subrelation.wf (\u03b1 \u00d7 \u03b2) (Prod.Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7)) (\u00b7 < \u00b7) ?_ IsWellFounded.wf\n    rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 w\n    simp only [Prod.mk_lt_mk] at w\n    rcases eq_or_ne a\u2081 a\u2082 with rfl | ha\n    \u00b7 right\n      simpa using w\n    \u00b7 left\n      rcases w with \u27e8a_lt, _\u27e9 | \u27e8a_le, _\u27e9\n      \u00b7 assumption\n      \u00b7 exact Ne.lt_of_le ha a_le", "start": [522, 1], "end": [534, 34], "kind": "commanddeclaration"}, {"full_name": "Prod.wellFoundedGT", "code": "instance Prod.wellFoundedGT [PartialOrder \u03b1] [WellFoundedGT \u03b1] [Preorder \u03b2] [WellFoundedGT \u03b2] :\n    WellFoundedGT (\u03b1 \u00d7 \u03b2) :=\n  @Prod.wellFoundedLT \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 _ _ _ _", "start": [536, 1], "end": [538, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Unbounded", "code": "def Unbounded (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop :=\n  \u2200 a, \u2203 b \u2208 s, \u00acr b a", "start": [542, 1], "end": [544, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Bounded", "code": "def Bounded (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) : Prop :=\n  \u2203 a, \u2200 b \u2208 s, r b a", "start": [547, 1], "end": [549, 22], "kind": "commanddeclaration"}, {"full_name": "Set.not_bounded_iff", "code": "@[simp]\ntheorem not_bounded_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Set \u03b1) : \u00acBounded r s \u2194 Unbounded r s", "start": [552, 1], "end": [554, 88], "kind": "commanddeclaration"}, {"full_name": "Set.not_unbounded_iff", "code": "@[simp]\ntheorem not_unbounded_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Set \u03b1) : \u00acUnbounded r s \u2194 Bounded r s", "start": [557, 1], "end": [559, 37], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_of_isEmpty", "code": "theorem unbounded_of_isEmpty [IsEmpty \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Set \u03b1) : Unbounded r s", "start": [562, 1], "end": [563, 14], "kind": "commanddeclaration"}, {"full_name": "Prod.isRefl_preimage_fst", "code": "instance isRefl_preimage_fst {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : IsRefl (\u03b1 \u00d7 \u03b1) (Prod.fst \u207b\u00b9'o r) :=\n  \u27e8fun a => refl_of r a.1\u27e9", "start": [570, 1], "end": [571, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.isRefl_preimage_snd", "code": "instance isRefl_preimage_snd {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] : IsRefl (\u03b1 \u00d7 \u03b1) (Prod.snd \u207b\u00b9'o r) :=\n  \u27e8fun a => refl_of r a.2\u27e9", "start": [573, 1], "end": [574, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.isTrans_preimage_fst", "code": "instance isTrans_preimage_fst {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrans \u03b1 r] :\n    IsTrans (\u03b1 \u00d7 \u03b1) (Prod.fst \u207b\u00b9'o r) :=\n  \u27e8fun _ _ _ => trans_of r\u27e9", "start": [576, 1], "end": [578, 28], "kind": "commanddeclaration"}, {"full_name": "Prod.isTrans_preimage_snd", "code": "instance isTrans_preimage_snd {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrans \u03b1 r] :\n    IsTrans (\u03b1 \u00d7 \u03b1) (Prod.snd \u207b\u00b9'o r) :=\n  \u27e8fun _ _ _ => trans_of r\u27e9", "start": [580, 1], "end": [582, 28], "kind": "commanddeclaration"}, {"full_name": "IsNonstrictStrictOrder", "code": "class IsNonstrictStrictOrder (\u03b1 : Type*) (r : semiOutParam (\u03b1 \u2192 \u03b1 \u2192 Prop)) (s : \u03b1 \u2192 \u03b1 \u2192 Prop) :\n    Prop where\n  \n  right_iff_left_not_left (a b : \u03b1) : s a b \u2194 r a b \u2227 \u00acr b a", "start": [589, 1], "end": [595, 61], "kind": "commanddeclaration"}, {"full_name": "right_iff_left_not_left", "code": "theorem right_iff_left_not_left {r s : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsNonstrictStrictOrder \u03b1 r s] {a b : \u03b1} :\n    s a b \u2194 r a b \u2227 \u00acr b a", "start": [598, 1], "end": [600, 53], "kind": "commanddeclaration"}, {"full_name": "right_iff_left_not_left_of", "code": "theorem right_iff_left_not_left_of (r s : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsNonstrictStrictOrder \u03b1 r s] {a b : \u03b1} :\n    s a b \u2194 r a b \u2227 \u00acr b a", "start": [603, 1], "end": [606, 26], "kind": "commanddeclaration"}, {"full_name": "subset_of_eq_of_subset", "code": "lemma subset_of_eq_of_subset (hab : a = b) (hbc : b \u2286 c) : a \u2286 c := by rwa [hab]", "start": [617, 1], "end": [617, 81], "kind": "mathlibtacticlemma"}, {"full_name": "subset_of_subset_of_eq", "code": "lemma subset_of_subset_of_eq (hab : a \u2286 b) (hbc : b = c) : a \u2286 c := by rwa [\u2190hbc]", "start": [620, 1], "end": [620, 82], "kind": "mathlibtacticlemma"}, {"full_name": "subset_refl", "code": "@[refl]\nlemma subset_refl [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] (a : \u03b1) : a \u2286 a := refl _", "start": [623, 1], "end": [624, 63], "kind": "mathlibtacticlemma"}, {"full_name": "subset_rfl", "code": "lemma subset_rfl [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] : a \u2286 a := refl _", "start": [627, 1], "end": [627, 54], "kind": "mathlibtacticlemma"}, {"full_name": "subset_of_eq", "code": "lemma subset_of_eq [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] : a = b \u2192 a \u2286 b := fun h => h \u25b8 subset_rfl", "start": [630, 1], "end": [630, 81], "kind": "mathlibtacticlemma"}, {"full_name": "superset_of_eq", "code": "lemma superset_of_eq [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] : a = b \u2192 b \u2286 a := fun h => h \u25b8 subset_rfl", "start": [633, 1], "end": [633, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ne_of_not_subset", "code": "lemma ne_of_not_subset [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] : \u00aca \u2286 b \u2192 a \u2260 b := mt subset_of_eq", "start": [636, 1], "end": [636, 78], "kind": "mathlibtacticlemma"}, {"full_name": "ne_of_not_superset", "code": "lemma ne_of_not_superset [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] : \u00aca \u2286 b \u2192 b \u2260 a := mt superset_of_eq", "start": [639, 1], "end": [639, 82], "kind": "mathlibtacticlemma"}, {"full_name": "subset_trans", "code": "@[trans]\nlemma subset_trans [IsTrans \u03b1 (\u00b7 \u2286 \u00b7)] {a b c : \u03b1} : a \u2286 b \u2192 b \u2286 c \u2192 a \u2286 c := _root_.trans", "start": [642, 1], "end": [643, 91], "kind": "mathlibtacticlemma"}, {"full_name": "subset_antisymm", "code": "lemma subset_antisymm [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] : a \u2286 b \u2192 b \u2286 a \u2192 a = b := antisymm", "start": [646, 1], "end": [646, 81], "kind": "mathlibtacticlemma"}, {"full_name": "superset_antisymm", "code": "lemma superset_antisymm [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] : a \u2286 b \u2192 b \u2286 a \u2192 b = a := antisymm'", "start": [649, 1], "end": [649, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Eq.trans_subset", "code": "alias Eq.trans_subset := subset_of_eq_of_subset", "start": [652, 1], "end": [652, 48], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.subset.trans_eq", "code": "alias HasSubset.subset.trans_eq := subset_of_subset_of_eq", "start": [655, 1], "end": [655, 58], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.subset'", "code": "alias Eq.subset' := subset_of_eq", "start": [658, 1], "end": [658, 33], "kind": "stdtacticaliasalias"}, {"full_name": "Eq.superset", "code": "alias Eq.superset := superset_of_eq", "start": [661, 1], "end": [661, 36], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.trans", "code": "alias HasSubset.Subset.trans := subset_trans", "start": [664, 1], "end": [664, 45], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.antisymm", "code": "alias HasSubset.Subset.antisymm := subset_antisymm", "start": [667, 1], "end": [667, 51], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.antisymm'", "code": "alias HasSubset.Subset.antisymm' := superset_antisymm", "start": [670, 1], "end": [670, 54], "kind": "stdtacticaliasalias"}, {"full_name": "subset_antisymm_iff", "code": "theorem subset_antisymm_iff [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] : a = b \u2194 a \u2286 b \u2227 b \u2286 a", "start": [673, 1], "end": [674, 64], "kind": "commanddeclaration"}, {"full_name": "superset_antisymm_iff", "code": "theorem superset_antisymm_iff [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] : a = b \u2194 b \u2286 a \u2227 a \u2286 b", "start": [677, 1], "end": [678, 65], "kind": "commanddeclaration"}, {"full_name": "ssubset_of_eq_of_ssubset", "code": "lemma ssubset_of_eq_of_ssubset (hab : a = b) (hbc : b \u2282 c) : a \u2282 c := by rwa [hab]", "start": [686, 1], "end": [686, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ssubset_of_ssubset_of_eq", "code": "lemma ssubset_of_ssubset_of_eq (hab : a \u2282 b) (hbc : b = c) : a \u2282 c := by rwa [\u2190hbc]", "start": [689, 1], "end": [689, 84], "kind": "mathlibtacticlemma"}, {"full_name": "ssubset_irrefl", "code": "lemma ssubset_irrefl [IsIrrefl \u03b1 (\u00b7 \u2282 \u00b7)] (a : \u03b1) : \u00aca \u2282 a := irrefl _", "start": [692, 1], "end": [692, 71], "kind": "mathlibtacticlemma"}, {"full_name": "ssubset_irrfl", "code": "lemma ssubset_irrfl [IsIrrefl \u03b1 (\u00b7 \u2282 \u00b7)] {a : \u03b1} : \u00aca \u2282 a := irrefl _", "start": [695, 1], "end": [695, 70], "kind": "mathlibtacticlemma"}, {"full_name": "ne_of_ssubset", "code": "lemma ne_of_ssubset [IsIrrefl \u03b1 (\u00b7 \u2282 \u00b7)] {a b : \u03b1} : a \u2282 b \u2192 a \u2260 b := ne_of_irrefl", "start": [698, 1], "end": [698, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ne_of_ssuperset", "code": "lemma ne_of_ssuperset [IsIrrefl \u03b1 (\u00b7 \u2282 \u00b7)] {a b : \u03b1} : a \u2282 b \u2192 b \u2260 a := ne_of_irrefl'", "start": [701, 1], "end": [701, 86], "kind": "mathlibtacticlemma"}, {"full_name": "ssubset_trans", "code": "@[trans]\nlemma ssubset_trans [IsTrans \u03b1 (\u00b7 \u2282 \u00b7)] {a b c : \u03b1} : a \u2282 b \u2192 b \u2282 c \u2192 a \u2282 c := _root_.trans", "start": [704, 1], "end": [705, 92], "kind": "mathlibtacticlemma"}, {"full_name": "ssubset_asymm", "code": "lemma ssubset_asymm [IsAsymm \u03b1 (\u00b7 \u2282 \u00b7)] {a b : \u03b1} : a \u2282 b \u2192 \u00acb \u2282 a := asymm", "start": [708, 1], "end": [708, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Eq.trans_ssubset", "code": "alias Eq.trans_ssubset := ssubset_of_eq_of_ssubset", "start": [711, 1], "end": [711, 51], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.trans_eq", "code": "alias HasSSubset.SSubset.trans_eq := ssubset_of_ssubset_of_eq", "start": [714, 1], "end": [714, 62], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.false", "code": "alias HasSSubset.SSubset.false := ssubset_irrfl", "start": [717, 1], "end": [717, 48], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.ne", "code": "alias HasSSubset.SSubset.ne := ne_of_ssubset", "start": [720, 1], "end": [720, 45], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.ne'", "code": "alias HasSSubset.SSubset.ne' := ne_of_ssuperset", "start": [723, 1], "end": [723, 48], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.trans", "code": "alias HasSSubset.SSubset.trans := ssubset_trans", "start": [726, 1], "end": [726, 48], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.asymm", "code": "alias HasSSubset.SSubset.asymm := ssubset_asymm", "start": [729, 1], "end": [729, 48], "kind": "stdtacticaliasalias"}, {"full_name": "ssubset_iff_subset_not_subset", "code": "theorem ssubset_iff_subset_not_subset : a \u2282 b \u2194 a \u2286 b \u2227 \u00acb \u2286 a", "start": [738, 1], "end": [739, 26], "kind": "commanddeclaration"}, {"full_name": "subset_of_ssubset", "code": "theorem subset_of_ssubset (h : a \u2282 b) : a \u2286 b", "start": [742, 1], "end": [743, 40], "kind": "commanddeclaration"}, {"full_name": "not_subset_of_ssubset", "code": "theorem not_subset_of_ssubset (h : a \u2282 b) : \u00acb \u2286 a", "start": [746, 1], "end": [747, 40], "kind": "commanddeclaration"}, {"full_name": "not_ssubset_of_subset", "code": "theorem not_ssubset_of_subset (h : a \u2286 b) : \u00acb \u2282 a", "start": [750, 1], "end": [750, 91], "kind": "commanddeclaration"}, {"full_name": "ssubset_of_subset_not_subset", "code": "theorem ssubset_of_subset_not_subset (h\u2081 : a \u2286 b) (h\u2082 : \u00acb \u2286 a) : a \u2282 b", "start": [753, 1], "end": [754, 43], "kind": "commanddeclaration"}, {"full_name": "HasSSubset.SSubset.subset", "code": "alias HasSSubset.SSubset.subset := subset_of_ssubset", "start": [757, 1], "end": [757, 53], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.not_subset", "code": "alias HasSSubset.SSubset.not_subset := not_subset_of_ssubset", "start": [760, 1], "end": [760, 61], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.not_ssubset", "code": "alias HasSubset.Subset.not_ssubset := not_ssubset_of_subset", "start": [763, 1], "end": [763, 60], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.ssubset_of_not_subset", "code": "alias HasSubset.Subset.ssubset_of_not_subset := ssubset_of_subset_not_subset", "start": [766, 1], "end": [766, 77], "kind": "stdtacticaliasalias"}, {"full_name": "ssubset_of_subset_of_ssubset", "code": "theorem ssubset_of_subset_of_ssubset [IsTrans \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2286 b) (h\u2082 : b \u2282 c) : a \u2282 c", "start": [769, 1], "end": [770, 82], "kind": "commanddeclaration"}, {"full_name": "ssubset_of_ssubset_of_subset", "code": "theorem ssubset_of_ssubset_of_subset [IsTrans \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2282 b) (h\u2082 : b \u2286 c) : a \u2282 c", "start": [773, 1], "end": [774, 82], "kind": "commanddeclaration"}, {"full_name": "ssubset_of_subset_of_ne", "code": "theorem ssubset_of_subset_of_ne [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2286 b) (h\u2082 : a \u2260 b) : a \u2282 b", "start": [777, 1], "end": [778, 48], "kind": "commanddeclaration"}, {"full_name": "ssubset_of_ne_of_subset", "code": "theorem ssubset_of_ne_of_subset [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2260 b) (h\u2082 : a \u2286 b) : a \u2282 b", "start": [781, 1], "end": [782, 32], "kind": "commanddeclaration"}, {"full_name": "eq_or_ssubset_of_subset", "code": "theorem eq_or_ssubset_of_subset [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h : a \u2286 b) : a = b \u2228 a \u2282 b", "start": [785, 1], "end": [786, 54], "kind": "commanddeclaration"}, {"full_name": "ssubset_or_eq_of_subset", "code": "theorem ssubset_or_eq_of_subset [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h : a \u2286 b) : a \u2282 b \u2228 a = b", "start": [789, 1], "end": [790, 35], "kind": "commanddeclaration"}, {"full_name": "HasSubset.Subset.trans_ssubset", "code": "alias HasSubset.Subset.trans_ssubset := ssubset_of_subset_of_ssubset", "start": [793, 1], "end": [793, 69], "kind": "stdtacticaliasalias"}, {"full_name": "HasSSubset.SSubset.trans_subset", "code": "alias HasSSubset.SSubset.trans_subset := ssubset_of_ssubset_of_subset", "start": [796, 1], "end": [796, 70], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.ssubset_of_ne", "code": "alias HasSubset.Subset.ssubset_of_ne := ssubset_of_subset_of_ne", "start": [799, 1], "end": [799, 64], "kind": "stdtacticaliasalias"}, {"full_name": "Ne.ssubset_of_subset", "code": "alias Ne.ssubset_of_subset := ssubset_of_ne_of_subset", "start": [802, 1], "end": [802, 54], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.eq_or_ssubset", "code": "alias HasSubset.Subset.eq_or_ssubset := eq_or_ssubset_of_subset", "start": [805, 1], "end": [805, 64], "kind": "stdtacticaliasalias"}, {"full_name": "HasSubset.Subset.ssubset_or_eq", "code": "alias HasSubset.Subset.ssubset_or_eq := ssubset_or_eq_of_subset", "start": [808, 1], "end": [808, 64], "kind": "stdtacticaliasalias"}, {"full_name": "ssubset_iff_subset_ne", "code": "theorem ssubset_iff_subset_ne [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] : a \u2282 b \u2194 a \u2286 b \u2227 a \u2260 b", "start": [811, 1], "end": [812, 62], "kind": "commanddeclaration"}, {"full_name": "subset_iff_ssubset_or_eq", "code": "theorem subset_iff_ssubset_or_eq [IsRefl \u03b1 (\u00b7 \u2286 \u00b7)] [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] :\n    a \u2286 b \u2194 a \u2282 b \u2228 a = b", "start": [815, 1], "end": [817, 77], "kind": "commanddeclaration"}, {"full_name": "LE.isTotal", "code": "instance LE.isTotal [LinearOrder \u03b1] : IsTotal \u03b1 (\u00b7 \u2264 \u00b7) :=\n  \u27e8le_total\u27e9", "start": [882, 1], "end": [883, 13], "kind": "commanddeclaration"}, {"full_name": "transitive_le", "code": "theorem transitive_le [Preorder \u03b1] : Transitive (@LE.le \u03b1 _)", "start": [917, 1], "end": [918, 24], "kind": "commanddeclaration"}, {"full_name": "transitive_lt", "code": "theorem transitive_lt [Preorder \u03b1] : Transitive (@LT.lt \u03b1 _)", "start": [921, 1], "end": [922, 24], "kind": "commanddeclaration"}, {"full_name": "transitive_ge", "code": "theorem transitive_ge [Preorder \u03b1] : Transitive (@GE.ge \u03b1 _)", "start": [925, 1], "end": [926, 24], "kind": "commanddeclaration"}, {"full_name": "transitive_gt", "code": "theorem transitive_gt [Preorder \u03b1] : Transitive (@GT.gt \u03b1 _)", "start": [929, 1], "end": [930, 24], "kind": "commanddeclaration"}, {"full_name": "OrderDual.isTotal_le", "code": "instance OrderDual.isTotal_le [LE \u03b1] [h : IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] : IsTotal \u03b1\u1d52\u1d48 (\u00b7 \u2264 \u00b7) :=\n  @IsTotal.swap \u03b1 _ h", "start": [933, 1], "end": [934, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.lt.isWellOrder", "code": "instance Nat.lt.isWellOrder : IsWellOrder \u2115 (\u00b7 < \u00b7) where", "start": [940, 1], "end": [940, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Max.lean", "imports": ["Mathlib/Order/Synonym.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NoBotOrder", "code": "class NoBotOrder (\u03b1 : Type*) [LE \u03b1] : Prop where\n  \n  exists_not_ge (a : \u03b1) : \u2203 b, \u00aca \u2264 b", "start": [40, 1], "end": [43, 38], "kind": "commanddeclaration"}, {"full_name": "NoTopOrder", "code": "class NoTopOrder (\u03b1 : Type*) [LE \u03b1] : Prop where\n  \n  exists_not_le (a : \u03b1) : \u2203 b, \u00acb \u2264 a", "start": [46, 1], "end": [49, 38], "kind": "commanddeclaration"}, {"full_name": "NoMinOrder", "code": "class NoMinOrder (\u03b1 : Type*) [LT \u03b1] : Prop where\n  \n  exists_lt (a : \u03b1) : \u2203 b, b < a", "start": [52, 1], "end": [55, 33], "kind": "commanddeclaration"}, {"full_name": "NoMaxOrder", "code": "class NoMaxOrder (\u03b1 : Type*) [LT \u03b1] : Prop where\n  \n  exists_gt (a : \u03b1) : \u2203 b, a < b", "start": [58, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "nonempty_lt", "code": "instance nonempty_lt [LT \u03b1] [NoMinOrder \u03b1] (a : \u03b1) : Nonempty { x // x < a } :=\n  nonempty_subtype.2 (exists_lt a)", "start": [72, 1], "end": [73, 35], "kind": "commanddeclaration"}, {"full_name": "nonempty_gt", "code": "instance nonempty_gt [LT \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) : Nonempty { x // a < x } :=\n  nonempty_subtype.2 (exists_gt a)", "start": [75, 1], "end": [76, 35], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toNoMaxOrder", "code": "instance IsEmpty.toNoMaxOrder [LT \u03b1] [IsEmpty \u03b1] : NoMaxOrder \u03b1 := \u27e8isEmptyElim\u27e9", "start": [78, 1], "end": [78, 81], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toNoMinOrder", "code": "instance IsEmpty.toNoMinOrder [LT \u03b1] [IsEmpty \u03b1] : NoMinOrder \u03b1 := \u27e8isEmptyElim\u27e9", "start": [79, 1], "end": [79, 81], "kind": "commanddeclaration"}, {"full_name": "OrderDual.noBotOrder", "code": "instance OrderDual.noBotOrder [LE \u03b1] [NoTopOrder \u03b1] : NoBotOrder \u03b1\u1d52\u1d48 :=\n  \u27e8fun a => @exists_not_le \u03b1 _ _ a\u27e9", "start": [81, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "OrderDual.noTopOrder", "code": "instance OrderDual.noTopOrder [LE \u03b1] [NoBotOrder \u03b1] : NoTopOrder \u03b1\u1d52\u1d48 :=\n  \u27e8fun a => @exists_not_ge \u03b1 _ _ a\u27e9", "start": [85, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "OrderDual.noMinOrder", "code": "instance OrderDual.noMinOrder [LT \u03b1] [NoMaxOrder \u03b1] : NoMinOrder \u03b1\u1d52\u1d48 :=\n  \u27e8fun a => @exists_gt \u03b1 _ _ a\u27e9", "start": [89, 1], "end": [90, 32], "kind": "commanddeclaration"}, {"full_name": "OrderDual.noMaxOrder", "code": "instance OrderDual.noMaxOrder [LT \u03b1] [NoMinOrder \u03b1] : NoMaxOrder \u03b1\u1d52\u1d48 :=\n  \u27e8fun a => @exists_lt \u03b1 _ _ a\u27e9", "start": [93, 1], "end": [94, 32], "kind": "commanddeclaration"}, {"full_name": "noMaxOrder_of_left", "code": "instance noMaxOrder_of_left [Preorder \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b1] : NoMaxOrder (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun \u27e8a, b\u27e9 => by\n    obtain \u27e8c, h\u27e9 := exists_gt a\n    exact \u27e8(c, b), Prod.mk_lt_mk_iff_left.2 h\u27e9\u27e9", "start": [105, 1], "end": [108, 48], "kind": "commanddeclaration"}, {"full_name": "noMaxOrder_of_right", "code": "instance noMaxOrder_of_right [Preorder \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b2] : NoMaxOrder (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun \u27e8a, b\u27e9 => by\n    obtain \u27e8c, h\u27e9 := exists_gt b\n    exact \u27e8(a, c), Prod.mk_lt_mk_iff_right.2 h\u27e9\u27e9", "start": [111, 1], "end": [114, 49], "kind": "commanddeclaration"}, {"full_name": "noMinOrder_of_left", "code": "instance noMinOrder_of_left [Preorder \u03b1] [Preorder \u03b2] [NoMinOrder \u03b1] : NoMinOrder (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun \u27e8a, b\u27e9 => by\n    obtain \u27e8c, h\u27e9 := exists_lt a\n    exact \u27e8(c, b), Prod.mk_lt_mk_iff_left.2 h\u27e9\u27e9", "start": [117, 1], "end": [120, 48], "kind": "commanddeclaration"}, {"full_name": "noMinOrder_of_right", "code": "instance noMinOrder_of_right [Preorder \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2] : NoMinOrder (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun \u27e8a, b\u27e9 => by\n    obtain \u27e8c, h\u27e9 := exists_lt b\n    exact \u27e8(a, c), Prod.mk_lt_mk_iff_right.2 h\u27e9\u27e9", "start": [123, 1], "end": [126, 49], "kind": "commanddeclaration"}, {"full_name": "NoBotOrder.to_noMinOrder", "code": "theorem NoBotOrder.to_noMinOrder (\u03b1 : Type*) [LinearOrder \u03b1] [NoBotOrder \u03b1] : NoMinOrder \u03b1", "start": [144, 1], "end": [145, 68], "kind": "commanddeclaration"}, {"full_name": "NoTopOrder.to_noMaxOrder", "code": "theorem NoTopOrder.to_noMaxOrder (\u03b1 : Type*) [LinearOrder \u03b1] [NoTopOrder \u03b1] : NoMaxOrder \u03b1", "start": [149, 1], "end": [150, 68], "kind": "commanddeclaration"}, {"full_name": "noBotOrder_iff_noMinOrder", "code": "theorem noBotOrder_iff_noMinOrder (\u03b1 : Type*) [LinearOrder \u03b1] : NoBotOrder \u03b1 \u2194 NoMinOrder \u03b1", "start": [153, 1], "end": [159, 19], "kind": "commanddeclaration"}, {"full_name": "noTopOrder_iff_noMaxOrder", "code": "theorem noTopOrder_iff_noMaxOrder (\u03b1 : Type*) [LinearOrder \u03b1] : NoTopOrder \u03b1 \u2194 NoMaxOrder \u03b1", "start": [162, 1], "end": [168, 19], "kind": "commanddeclaration"}, {"full_name": "NoMinOrder.not_acc", "code": "theorem NoMinOrder.not_acc [LT \u03b1] [NoMinOrder \u03b1] (a : \u03b1) : \u00acAcc (\u00b7 < \u00b7) a", "start": [171, 1], "end": [172, 45], "kind": "commanddeclaration"}, {"full_name": "NoMaxOrder.not_acc", "code": "theorem NoMaxOrder.not_acc [LT \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) : \u00acAcc (\u00b7 > \u00b7) a", "start": [175, 1], "end": [176, 45], "kind": "commanddeclaration"}, {"full_name": "IsBot", "code": "def IsBot (a : \u03b1) : Prop :=\n  \u2200 b, a \u2264 b", "start": [183, 1], "end": [188, 13], "kind": "commanddeclaration"}, {"full_name": "IsTop", "code": "def IsTop (a : \u03b1) : Prop :=\n  \u2200 b, b \u2264 a", "start": [191, 1], "end": [196, 13], "kind": "commanddeclaration"}, {"full_name": "IsMin", "code": "def IsMin (a : \u03b1) : Prop :=\n  \u2200 \u2983b\u2984, b \u2264 a \u2192 a \u2264 b", "start": [199, 1], "end": [203, 23], "kind": "commanddeclaration"}, {"full_name": "IsMax", "code": "def IsMax (a : \u03b1) : Prop :=\n  \u2200 \u2983b\u2984, a \u2264 b \u2192 b \u2264 a", "start": [206, 1], "end": [210, 23], "kind": "commanddeclaration"}, {"full_name": "not_isBot", "code": "@[simp]\ntheorem not_isBot [NoBotOrder \u03b1] (a : \u03b1) : \u00acIsBot a", "start": [213, 1], "end": [216, 12], "kind": "commanddeclaration"}, {"full_name": "not_isTop", "code": "@[simp]\ntheorem not_isTop [NoTopOrder \u03b1] (a : \u03b1) : \u00acIsTop a", "start": [219, 1], "end": [222, 12], "kind": "commanddeclaration"}, {"full_name": "IsBot.isMin", "code": "protected theorem IsBot.isMin (h : IsBot a) : IsMin a", "start": [225, 1], "end": [225, 72], "kind": "commanddeclaration"}, {"full_name": "IsTop.isMax", "code": "protected theorem IsTop.isMax (h : IsTop a) : IsMax a", "start": [228, 1], "end": [228, 72], "kind": "commanddeclaration"}, {"full_name": "isBot_toDual_iff", "code": "@[simp]\ntheorem isBot_toDual_iff : IsBot (toDual a) \u2194 IsTop a", "start": [231, 1], "end": [233, 10], "kind": "commanddeclaration"}, {"full_name": "isTop_toDual_iff", "code": "@[simp]\ntheorem isTop_toDual_iff : IsTop (toDual a) \u2194 IsBot a", "start": [236, 1], "end": [238, 10], "kind": "commanddeclaration"}, {"full_name": "isMin_toDual_iff", "code": "@[simp]\ntheorem isMin_toDual_iff : IsMin (toDual a) \u2194 IsMax a", "start": [241, 1], "end": [243, 10], "kind": "commanddeclaration"}, {"full_name": "isMax_toDual_iff", "code": "@[simp]\ntheorem isMax_toDual_iff : IsMax (toDual a) \u2194 IsMin a", "start": [246, 1], "end": [248, 10], "kind": "commanddeclaration"}, {"full_name": "isBot_ofDual_iff", "code": "@[simp]\ntheorem isBot_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsBot (ofDual a) \u2194 IsTop a", "start": [251, 1], "end": [253, 10], "kind": "commanddeclaration"}, {"full_name": "isTop_ofDual_iff", "code": "@[simp]\ntheorem isTop_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsTop (ofDual a) \u2194 IsBot a", "start": [256, 1], "end": [258, 10], "kind": "commanddeclaration"}, {"full_name": "isMin_ofDual_iff", "code": "@[simp]\ntheorem isMin_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsMin (ofDual a) \u2194 IsMax a", "start": [261, 1], "end": [263, 10], "kind": "commanddeclaration"}, {"full_name": "isMax_ofDual_iff", "code": "@[simp]\ntheorem isMax_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsMax (ofDual a) \u2194 IsMin a", "start": [266, 1], "end": [268, 10], "kind": "commanddeclaration"}, {"full_name": "IsTop.toDual", "code": "alias \u27e8_, IsTop.toDual\u27e9 := isBot_toDual_iff", "start": [271, 1], "end": [271, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsBot.toDual", "code": "alias \u27e8_, IsBot.toDual\u27e9 := isTop_toDual_iff", "start": [274, 1], "end": [274, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMax.toDual", "code": "alias \u27e8_, IsMax.toDual\u27e9 := isMin_toDual_iff", "start": [277, 1], "end": [277, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMin.toDual", "code": "alias \u27e8_, IsMin.toDual\u27e9 := isMax_toDual_iff", "start": [280, 1], "end": [280, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsTop.ofDual", "code": "alias \u27e8_, IsTop.ofDual\u27e9 := isBot_ofDual_iff", "start": [283, 1], "end": [283, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsBot.ofDual", "code": "alias \u27e8_, IsBot.ofDual\u27e9 := isTop_ofDual_iff", "start": [286, 1], "end": [286, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMax.ofDual", "code": "alias \u27e8_, IsMax.ofDual\u27e9 := isMin_ofDual_iff", "start": [289, 1], "end": [289, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMin.ofDual", "code": "alias \u27e8_, IsMin.ofDual\u27e9 := isMax_ofDual_iff", "start": [292, 1], "end": [292, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsBot.mono", "code": "theorem IsBot.mono (ha : IsBot a) (h : b \u2264 a) : IsBot b", "start": [301, 1], "end": [301, 84], "kind": "commanddeclaration"}, {"full_name": "IsTop.mono", "code": "theorem IsTop.mono (ha : IsTop a) (h : a \u2264 b) : IsTop b", "start": [304, 1], "end": [304, 83], "kind": "commanddeclaration"}, {"full_name": "IsMin.mono", "code": "theorem IsMin.mono (ha : IsMin a) (h : b \u2264 a) : IsMin b", "start": [307, 1], "end": [307, 99], "kind": "commanddeclaration"}, {"full_name": "IsMax.mono", "code": "theorem IsMax.mono (ha : IsMax a) (h : a \u2264 b) : IsMax b", "start": [310, 1], "end": [310, 98], "kind": "commanddeclaration"}, {"full_name": "IsMin.not_lt", "code": "theorem IsMin.not_lt (h : IsMin a) : \u00acb < a", "start": [313, 1], "end": [313, 78], "kind": "commanddeclaration"}, {"full_name": "IsMax.not_lt", "code": "theorem IsMax.not_lt (h : IsMax a) : \u00aca < b", "start": [316, 1], "end": [316, 78], "kind": "commanddeclaration"}, {"full_name": "not_isMin_of_lt", "code": "@[simp]\ntheorem not_isMin_of_lt (h : b < a) : \u00acIsMin a", "start": [319, 1], "end": [320, 72], "kind": "commanddeclaration"}, {"full_name": "not_isMax_of_lt", "code": "@[simp]\ntheorem not_isMax_of_lt (h : a < b) : \u00acIsMax a", "start": [323, 1], "end": [324, 72], "kind": "commanddeclaration"}, {"full_name": "LT.lt.not_isMin", "code": "alias LT.lt.not_isMin := not_isMin_of_lt", "start": [327, 1], "end": [327, 41], "kind": "stdtacticaliasalias"}, {"full_name": "LT.lt.not_isMax", "code": "alias LT.lt.not_isMax := not_isMax_of_lt", "start": [329, 1], "end": [329, 41], "kind": "stdtacticaliasalias"}, {"full_name": "isMin_iff_forall_not_lt", "code": "theorem isMin_iff_forall_not_lt : IsMin a \u2194 \u2200 b, \u00acb < a", "start": [331, 1], "end": [332, 90], "kind": "commanddeclaration"}, {"full_name": "isMax_iff_forall_not_lt", "code": "theorem isMax_iff_forall_not_lt : IsMax a \u2194 \u2200 b, \u00aca < b", "start": [335, 1], "end": [336, 90], "kind": "commanddeclaration"}, {"full_name": "not_isMin_iff", "code": "@[simp]\ntheorem not_isMin_iff : \u00acIsMin a \u2194 \u2203 b, b < a", "start": [339, 1], "end": [341, 58], "kind": "commanddeclaration"}, {"full_name": "not_isMax_iff", "code": "@[simp]\ntheorem not_isMax_iff : \u00acIsMax a \u2194 \u2203 b, a < b", "start": [344, 1], "end": [346, 58], "kind": "commanddeclaration"}, {"full_name": "not_isMin", "code": "@[simp]\ntheorem not_isMin [NoMinOrder \u03b1] (a : \u03b1) : \u00acIsMin a", "start": [349, 1], "end": [351, 33], "kind": "commanddeclaration"}, {"full_name": "not_isMax", "code": "@[simp]\ntheorem not_isMax [NoMaxOrder \u03b1] (a : \u03b1) : \u00acIsMax a", "start": [354, 1], "end": [356, 33], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.isBot", "code": "protected theorem isBot (a : \u03b1) : IsBot a", "start": [363, 1], "end": [363, 81], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.isTop", "code": "protected theorem isTop (a : \u03b1) : IsTop a", "start": [366, 1], "end": [366, 81], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.isMin", "code": "protected theorem isMin (a : \u03b1) : IsMin a", "start": [369, 1], "end": [370, 31], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.isMax", "code": "protected theorem isMax (a : \u03b1) : IsMax a", "start": [373, 1], "end": [374, 31], "kind": "commanddeclaration"}, {"full_name": "IsMin.eq_of_le", "code": "protected theorem IsMin.eq_of_le (ha : IsMin a) (h : b \u2264 a) : b = a", "start": [385, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "IsMin.eq_of_ge", "code": "protected theorem IsMin.eq_of_ge (ha : IsMin a) (h : b \u2264 a) : a = b", "start": [389, 1], "end": [390, 22], "kind": "commanddeclaration"}, {"full_name": "IsMax.eq_of_le", "code": "protected theorem IsMax.eq_of_le (ha : IsMax a) (h : a \u2264 b) : a = b", "start": [393, 1], "end": [394, 21], "kind": "commanddeclaration"}, {"full_name": "IsMax.eq_of_ge", "code": "protected theorem IsMax.eq_of_ge (ha : IsMax a) (h : a \u2264 b) : b = a", "start": [397, 1], "end": [398, 22], "kind": "commanddeclaration"}, {"full_name": "IsBot.prod_mk", "code": "theorem IsBot.prod_mk (ha : IsBot a) (hb : IsBot b) : IsBot (a, b)", "start": [407, 1], "end": [407, 92], "kind": "commanddeclaration"}, {"full_name": "IsTop.prod_mk", "code": "theorem IsTop.prod_mk (ha : IsTop a) (hb : IsTop b) : IsTop (a, b)", "start": [410, 1], "end": [410, 92], "kind": "commanddeclaration"}, {"full_name": "IsMin.prod_mk", "code": "theorem IsMin.prod_mk (ha : IsMin a) (hb : IsMin b) : IsMin (a, b)", "start": [413, 1], "end": [413, 101], "kind": "commanddeclaration"}, {"full_name": "IsMax.prod_mk", "code": "theorem IsMax.prod_mk (ha : IsMax a) (hb : IsMax b) : IsMax (a, b)", "start": [416, 1], "end": [416, 101], "kind": "commanddeclaration"}, {"full_name": "IsBot.fst", "code": "theorem IsBot.fst (hx : IsBot x) : IsBot x.1", "start": [419, 1], "end": [419, 73], "kind": "commanddeclaration"}, {"full_name": "IsBot.snd", "code": "theorem IsBot.snd (hx : IsBot x) : IsBot x.2", "start": [422, 1], "end": [422, 73], "kind": "commanddeclaration"}, {"full_name": "IsTop.fst", "code": "theorem IsTop.fst (hx : IsTop x) : IsTop x.1", "start": [425, 1], "end": [425, 73], "kind": "commanddeclaration"}, {"full_name": "IsTop.snd", "code": "theorem IsTop.snd (hx : IsTop x) : IsTop x.2", "start": [428, 1], "end": [428, 73], "kind": "commanddeclaration"}, {"full_name": "IsMin.fst", "code": "theorem IsMin.fst (hx : IsMin x) : IsMin x.1", "start": [431, 1], "end": [432, 74], "kind": "commanddeclaration"}, {"full_name": "IsMin.snd", "code": "theorem IsMin.snd (hx : IsMin x) : IsMin x.2", "start": [435, 1], "end": [436, 75], "kind": "commanddeclaration"}, {"full_name": "IsMax.fst", "code": "theorem IsMax.fst (hx : IsMax x) : IsMax x.1", "start": [439, 1], "end": [440, 74], "kind": "commanddeclaration"}, {"full_name": "IsMax.snd", "code": "theorem IsMax.snd (hx : IsMax x) : IsMax x.2", "start": [443, 1], "end": [444, 75], "kind": "commanddeclaration"}, {"full_name": "Prod.isBot_iff", "code": "theorem Prod.isBot_iff : IsBot x \u2194 IsBot x.1 \u2227 IsBot x.2", "start": [447, 1], "end": [448, 57], "kind": "commanddeclaration"}, {"full_name": "Prod.isTop_iff", "code": "theorem Prod.isTop_iff : IsTop x \u2194 IsTop x.1 \u2227 IsTop x.2", "start": [451, 1], "end": [452, 57], "kind": "commanddeclaration"}, {"full_name": "Prod.isMin_iff", "code": "theorem Prod.isMin_iff : IsMin x \u2194 IsMin x.1 \u2227 IsMin x.2", "start": [455, 1], "end": [456, 57], "kind": "commanddeclaration"}, {"full_name": "Prod.isMax_iff", "code": "theorem Prod.isMax_iff : IsMax x \u2194 IsMax x.1 \u2227 IsMax x.2", "start": [459, 1], "end": [460, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Choose.lean", "imports": ["Mathlib/Util/Tactic.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Choose.mk_sometimes", "code": "def mk_sometimes (u : Level) (\u03b1 nonemp p : Expr) :\n    List Expr \u2192 Expr \u00d7 Expr \u2192 MetaM (Expr \u00d7 Expr)\n| [], (val, spec) => pure (val, spec)\n| (e :: ctx), (val, spec) => do\n  let (val, spec) \u2190 mk_sometimes u \u03b1 nonemp p ctx (val, spec)\n  let t \u2190 inferType e\n  let b \u2190 isProp t\n  if b then do\n    let val' \u2190 mkLambdaFVars #[e] val\n    pure\n      (mkApp4 (Expr.const ``Function.sometimes [Level.zero, u]) t \u03b1 nonemp val',\n      mkApp7 (Expr.const ``Function.sometimes_spec [u]) t \u03b1 nonemp p val' e spec)\n  else pure (val, spec)", "start": [22, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.ElimStatus", "code": "inductive ElimStatus\n  | success\n  | failure (ts : List Expr)", "start": [42, 1], "end": [54, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.ElimStatus.merge", "code": "def ElimStatus.merge : ElimStatus \u2192 ElimStatus \u2192 ElimStatus\n  | success, _ => success\n  | _, success => success\n  | failure ts\u2081, failure ts\u2082 => failure (ts\u2081 ++ ts\u2082)", "start": [56, 1], "end": [61, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.mkFreshNameFrom", "code": "def mkFreshNameFrom (orig base : Name) : CoreM Name :=\n  if orig = `_ then mkFreshUserName base else pure orig", "start": [63, 1], "end": [66, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.choose1", "code": "def choose1 (g : MVarId) (nondep : Bool) (h : Option Expr) (data : Name) :\n    MetaM (ElimStatus \u00d7 Expr \u00d7 MVarId) := do\n  let (g, h) \u2190 match h with\n  | some e => pure (g, e)\n  | none   => do\n    let (e, g) \u2190 g.intro1P\n    pure (g, .fvar e)\n  g.withContext do\n    let h \u2190 instantiateMVars h\n    let t \u2190 inferType h\n    forallTelescopeReducing t fun ctx t \u21a6 do\n      (\u2190 withTransparency .all (whnf t)).withApp fun\n      | .const ``Exists [u], #[\u03b1, p] => do\n        let data \u2190 mkFreshNameFrom data ((\u2190 p.getBinderName).getD `h)\n        let ((neFail : ElimStatus), (nonemp : Option Expr)) \u2190 if nondep then\n          let ne := (Expr.const ``Nonempty [u]).app \u03b1\n          let m \u2190 mkFreshExprMVar ne\n          let mut g' := m.mvarId!\n          for e in ctx do\n            if (\u2190 isProof e) then continue\n            let ty \u2190 whnf (\u2190 inferType e)\n            let nety := (Expr.const ``Nonempty [u]).app ty\n            let neval := mkApp2 (Expr.const ``Nonempty.intro [u]) ty e\n            g' \u2190 g'.assert .anonymous nety neval\n          (_, g') \u2190 g'.intros\n          g'.withContext do\n            match \u2190 synthInstance? (\u2190 g'.getType) with\n            | some e => do\n              g'.assign e\n              let m \u2190 instantiateMVars m\n              pure (.success, some m)\n            | none => pure (.failure [ne], none)\n        else pure (.failure [], none)\n        let ctx' \u2190 if nonemp.isSome then ctx.filterM (not <$> isProof \u00b7) else pure ctx\n        let dataTy \u2190 mkForallFVars ctx' \u03b1\n        let mut dataVal := mkApp3 (.const ``Classical.choose [u]) \u03b1 p (mkAppN h ctx)\n        let mut specVal := mkApp3 (.const ``Classical.choose_spec [u]) \u03b1 p (mkAppN h ctx)\n        if let some nonemp := nonemp then\n          (dataVal, specVal) \u2190 mk_sometimes u \u03b1 nonemp p ctx.toList (dataVal, specVal)\n        dataVal \u2190 mkLambdaFVars ctx' dataVal\n        specVal \u2190 mkLambdaFVars ctx specVal\n        let (fvar, g) \u2190 withLocalDeclD .anonymous dataTy fun d \u21a6 do\n          let specTy \u2190 mkForallFVars ctx (p.app (mkAppN d ctx')).headBeta\n          g.withContext <| withLocalDeclD data dataTy fun d' \u21a6 do\n            let mvarTy \u2190 mkArrow (specTy.replaceFVar d d') (\u2190 g.getType)\n            let newMVar \u2190 mkFreshExprSyntheticOpaqueMVar mvarTy (\u2190 g.getTag)\n            g.assign <| mkApp2 (\u2190 mkLambdaFVars #[d'] newMVar) dataVal specVal\n            pure (d', newMVar.mvarId!)\n        let g \u2190 match h with\n        | .fvar v => g.clear v\n        | _ => pure g\n        return (neFail, fvar, g)\n      | .const ``And _, #[p, q] => do\n        let data \u2190 mkFreshNameFrom data `h\n        let e1 \u2190 mkLambdaFVars ctx $ mkApp3 (.const ``And.left  []) p q (mkAppN h ctx)\n        let e2 \u2190 mkLambdaFVars ctx $ mkApp3 (.const ``And.right []) p q (mkAppN h ctx)\n        let t1 \u2190 inferType e1\n        let t2 \u2190 inferType e2\n        let (fvar, g) \u2190 (\u2190 (\u2190 g.assert .anonymous t2 e2).assert data t1 e1).intro1P\n        let g \u2190 match h with\n        | .fvar v => g.clear v\n        | _ => pure g\n        return (.success, .fvar fvar, g)\n      | _, _ => throwError \"expected a term of the shape `\u2200xs, \u2203a, p xs a` or `\u2200xs, p xs \u2227 q xs`\"", "start": [68, 1], "end": [143, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.choose1WithInfo", "code": "def choose1WithInfo (g : MVarId) (nondep : Bool) (h : Option Expr) (data : TSyntax ``binderIdent) :\n    MetaM (ElimStatus \u00d7 MVarId) := do\n  let n := if let `(binderIdent| $n:ident) := data then n.getId else `_\n  let (status, fvar, g) \u2190 choose1 g nondep h n\n  g.withContext <| fvar.addLocalVarInfoForBinderIdent data\n  pure (status, g)", "start": [145, 1], "end": [151, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Choose.elabChoose", "code": "def elabChoose (nondep : Bool) (h : Option Expr) :\n    List (TSyntax ``binderIdent) \u2192 ElimStatus \u2192 MVarId \u2192 MetaM MVarId\n  | [], _, _ => throwError \"expect list of variables\"\n  | [n], status, g =>\n    match nondep, status with\n    | true, .failure tys => do let mut msg := m!\"choose!: failed to synthesize any nonempty instances\"\n      for ty in tys do\n        msg := msg ++ m!\"{(\u2190 mkFreshExprMVar ty).mvarId!}\"\n      throwError msg\n    | _, _ => do\n      let (fvar, g) \u2190 match n with\n      | `(binderIdent| $n:ident) => g.intro n.getId\n      | _ => g.intro1\n      g.withContext <| (Expr.fvar fvar).addLocalVarInfoForBinderIdent n\n      return g\n  | n::ns, status, g => do\n    let (status', g) \u2190 choose1WithInfo g nondep h n\n    elabChoose nondep none ns (status.merge status') g", "start": [153, 1], "end": [172, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Compare.lean", "imports": ["Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Order/Synonym.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "cmpLE", "code": "def cmpLE {\u03b1} [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x y : \u03b1) : Ordering :=\n  if x \u2264 y then if y \u2264 x then Ordering.eq else Ordering.lt else Ordering.gt", "start": [28, 1], "end": [31, 76], "kind": "commanddeclaration"}, {"full_name": "cmpLE_swap", "code": "theorem cmpLE_swap {\u03b1} [LE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x y : \u03b1) :\n    (cmpLE x y).swap = cmpLE y x", "start": [34, 1], "end": [37, 45], "kind": "commanddeclaration"}, {"full_name": "cmpLE_eq_cmp", "code": "theorem cmpLE_eq_cmp {\u03b1} [Preorder \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)]\n    [@DecidableRel \u03b1 (\u00b7 < \u00b7)] (x y : \u03b1) : cmpLE x y = cmp x y", "start": [40, 1], "end": [43, 45], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares", "code": "def Compares [LT \u03b1] : Ordering \u2192 \u03b1 \u2192 \u03b1 \u2192 Prop\n  | lt, a, b => a < b\n  | eq, a, b => a = b\n  | gt, a, b => a > b", "start": [48, 1], "end": [55, 22], "kind": "commanddeclaration"}, {"full_name": "Ordering.compares_lt", "code": "@[simp]\nlemma compares_lt [LT \u03b1] (a b : \u03b1) : Compares lt a b = (a < b) := rfl", "start": [58, 1], "end": [59, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Ordering.compares_eq", "code": "@[simp]\nlemma compares_eq [LT \u03b1] (a b : \u03b1) : Compares eq a b = (a = b) := rfl", "start": [61, 1], "end": [62, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Ordering.compares_gt", "code": "@[simp]\nlemma compares_gt [LT \u03b1] (a b : \u03b1) : Compares gt a b = (a > b) := rfl", "start": [64, 1], "end": [65, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Ordering.compares_swap", "code": "theorem compares_swap [LT \u03b1] {a b : \u03b1} {o : Ordering} : o.swap.Compares a b \u2194 o.Compares b a", "start": [67, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.of_swap", "code": "alias \u27e8Compares.of_swap, Compares.swap\u27e9 := compares_swap", "start": [74, 1], "end": [74, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ordering.Compares.swap", "code": "alias \u27e8Compares.of_swap, Compares.swap\u27e9 := compares_swap", "start": [74, 1], "end": [74, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ordering.swap_eq_iff_eq_swap", "code": "theorem swap_eq_iff_eq_swap {o o' : Ordering} : o.swap = o' \u2194 o = o'.swap", "start": [78, 1], "end": [79, 29], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.eq_lt", "code": "theorem Compares.eq_lt [Preorder \u03b1] : \u2200 {o} {a b : \u03b1}, Compares o a b \u2192 (o = lt \u2194 a < b)", "start": [82, 1], "end": [85, 77], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.ne_lt", "code": "theorem Compares.ne_lt [Preorder \u03b1] : \u2200 {o} {a b : \u03b1}, Compares o a b \u2192 (o \u2260 lt \u2194 b \u2264 a)", "start": [88, 1], "end": [91, 68], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.eq_eq", "code": "theorem Compares.eq_eq [Preorder \u03b1] : \u2200 {o} {a b : \u03b1}, Compares o a b \u2192 (o = eq \u2194 a = b)", "start": [94, 1], "end": [97, 77], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.eq_gt", "code": "theorem Compares.eq_gt [Preorder \u03b1] {o} {a b : \u03b1} (h : Compares o a b) : o = gt \u2194 b < a", "start": [100, 1], "end": [101, 46], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.ne_gt", "code": "theorem Compares.ne_gt [Preorder \u03b1] {o} {a b : \u03b1} (h : Compares o a b) : o \u2260 gt \u2194 a \u2264 b", "start": [104, 1], "end": [105, 58], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.le_total", "code": "theorem Compares.le_total [Preorder \u03b1] {a b : \u03b1} : \u2200 {o}, Compares o a b \u2192 a \u2264 b \u2228 b \u2264 a", "start": [108, 1], "end": [111, 33], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.le_antisymm", "code": "theorem Compares.le_antisymm [Preorder \u03b1] {a b : \u03b1} : \u2200 {o}, Compares o a b \u2192 a \u2264 b \u2192 b \u2264 a \u2192 a = b", "start": [114, 1], "end": [117, 47], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.inj", "code": "theorem Compares.inj [Preorder \u03b1] {o\u2081} :\n    \u2200 {o\u2082} {a b : \u03b1}, Compares o\u2081 a b \u2192 Compares o\u2082 a b \u2192 o\u2081 = o\u2082", "start": [120, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "Ordering.compares_iff_of_compares_impl", "code": "theorem compares_iff_of_compares_impl [LinearOrder \u03b1] [Preorder \u03b2] {a b : \u03b1} {a' b' : \u03b2}\n    (h : \u2200 {o}, Compares o a b \u2192 Compares o a' b') (o) : Compares o a b \u2194 Compares o a' b'", "start": [128, 1], "end": [138, 27], "kind": "commanddeclaration"}, {"full_name": "Ordering.swap_orElse", "code": "theorem swap_orElse (o\u2081 o\u2082) : (orElse o\u2081 o\u2082).swap = orElse o\u2081.swap o\u2082.swap", "start": [141, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "Ordering.orElse_eq_lt", "code": "theorem orElse_eq_lt (o\u2081 o\u2082) : orElse o\u2081 o\u2082 = lt \u2194 o\u2081 = lt \u2228 o\u2081 = eq \u2227 o\u2082 = lt", "start": [145, 1], "end": [146, 44], "kind": "commanddeclaration"}, {"full_name": "toDual_compares_toDual", "code": "@[simp]\ntheorem toDual_compares_toDual [LT \u03b1] {a b : \u03b1} {o : Ordering} :\n    Compares o (toDual a) (toDual b) \u2194 Compares o b a", "start": [153, 1], "end": [157, 37], "kind": "commanddeclaration"}, {"full_name": "ofDual_compares_ofDual", "code": "@[simp]\ntheorem ofDual_compares_ofDual [LT \u03b1] {a b : \u03b1\u1d52\u1d48} {o : Ordering} :\n    Compares o (ofDual a) (ofDual b) \u2194 Compares o b a", "start": [160, 1], "end": [164, 37], "kind": "commanddeclaration"}, {"full_name": "cmp_compares", "code": "theorem cmp_compares [LinearOrder \u03b1] (a b : \u03b1) : (cmp a b).Compares a b", "start": [167, 1], "end": [168, 78], "kind": "commanddeclaration"}, {"full_name": "Ordering.Compares.cmp_eq", "code": "theorem Ordering.Compares.cmp_eq [LinearOrder \u03b1] {a b : \u03b1} {o : Ordering} (h : o.Compares a b) :\n    cmp a b = o", "start": [171, 1], "end": [173, 27], "kind": "commanddeclaration"}, {"full_name": "cmp_swap", "code": "@[simp]\ntheorem cmp_swap [Preorder \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] (a b : \u03b1) : (cmp a b).swap = cmp b a", "start": [176, 1], "end": [180, 22], "kind": "commanddeclaration"}, {"full_name": "cmpLE_toDual", "code": "@[simp, nolint simpNF]\ntheorem cmpLE_toDual [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x y : \u03b1) :\n    cmpLE (toDual x) (toDual y) = cmpLE y x", "start": [184, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "cmpLE_ofDual", "code": "@[simp]\ntheorem cmpLE_ofDual [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (x y : \u03b1\u1d52\u1d48) :\n    cmpLE (ofDual x) (ofDual y) = cmpLE y x", "start": [190, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "cmp_toDual", "code": "@[simp, nolint simpNF]\ntheorem cmp_toDual [LT \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] (x y : \u03b1) :\n    cmp (toDual x) (toDual y) = cmp y x", "start": [197, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "cmp_ofDual", "code": "@[simp]\ntheorem cmp_ofDual [LT \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] (x y : \u03b1\u1d52\u1d48) :\n    cmp (ofDual x) (ofDual y) = cmp y x", "start": [203, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "linearOrderOfCompares", "code": "def linearOrderOfCompares [Preorder \u03b1] (cmp : \u03b1 \u2192 \u03b1 \u2192 Ordering)\n    (h : \u2200 a b, (cmp a b).Compares a b) : LinearOrder \u03b1 :=\n  let H : DecidableRel (\u03b1 := \u03b1) (\u00b7 \u2264 \u00b7) := fun a b => decidable_of_iff _ (h a b).ne_gt\n  { inferInstanceAs (Preorder \u03b1) with\n    le_antisymm := fun a b => (h a b).le_antisymm,\n    le_total := fun a b => (h a b).le_total,\n    toMin := minOfLe,\n    toMax := maxOfLe,\n    decidableLE := H,\n    decidableLT := fun a b => decidable_of_iff _ (h a b).eq_lt,\n    decidableEq := fun a b => decidable_of_iff _ (h a b).eq_eq }", "start": [209, 1], "end": [220, 65], "kind": "commanddeclaration"}, {"full_name": "cmp_eq_lt_iff", "code": "@[simp]\ntheorem cmp_eq_lt_iff : cmp x y = Ordering.lt \u2194 x < y", "start": [225, 1], "end": [227, 45], "kind": "commanddeclaration"}, {"full_name": "cmp_eq_eq_iff", "code": "@[simp]\ntheorem cmp_eq_eq_iff : cmp x y = Ordering.eq \u2194 x = y", "start": [230, 1], "end": [232, 45], "kind": "commanddeclaration"}, {"full_name": "cmp_eq_gt_iff", "code": "@[simp]\ntheorem cmp_eq_gt_iff : cmp x y = Ordering.gt \u2194 y < x", "start": [235, 1], "end": [237, 45], "kind": "commanddeclaration"}, {"full_name": "cmp_self_eq_eq", "code": "@[simp]\ntheorem cmp_self_eq_eq : cmp x x = Ordering.eq", "start": [240, 1], "end": [241, 72], "kind": "commanddeclaration"}, {"full_name": "cmp_eq_cmp_symm", "code": "theorem cmp_eq_cmp_symm : cmp x y = cmp x' y' \u2194 cmp y x = cmp y' x'", "start": [246, 1], "end": [248, 58], "kind": "commanddeclaration"}, {"full_name": "lt_iff_lt_of_cmp_eq_cmp", "code": "theorem lt_iff_lt_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x < y \u2194 x' < y'", "start": [251, 1], "end": [252, 43], "kind": "commanddeclaration"}, {"full_name": "le_iff_le_of_cmp_eq_cmp", "code": "theorem le_iff_le_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x \u2264 y \u2194 x' \u2264 y'", "start": [255, 1], "end": [259, 24], "kind": "commanddeclaration"}, {"full_name": "eq_iff_eq_of_cmp_eq_cmp", "code": "theorem eq_iff_eq_of_cmp_eq_cmp (h : cmp x y = cmp x' y') : x = y \u2194 x' = y'", "start": [262, 1], "end": [264, 53], "kind": "commanddeclaration"}, {"full_name": "LT.lt.cmp_eq_lt", "code": "theorem LT.lt.cmp_eq_lt (h : x < y) : cmp x y = Ordering.lt", "start": [267, 1], "end": [268, 26], "kind": "commanddeclaration"}, {"full_name": "LT.lt.cmp_eq_gt", "code": "theorem LT.lt.cmp_eq_gt (h : x < y) : cmp y x = Ordering.gt", "start": [270, 1], "end": [271, 26], "kind": "commanddeclaration"}, {"full_name": "Eq.cmp_eq_eq", "code": "theorem Eq.cmp_eq_eq (h : x = y) : cmp x y = Ordering.eq", "start": [273, 1], "end": [274, 26], "kind": "commanddeclaration"}, {"full_name": "Eq.cmp_eq_eq'", "code": "theorem Eq.cmp_eq_eq' (h : x = y) : cmp y x = Ordering.eq", "start": [277, 1], "end": [278, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Int/Order.lean", "imports": ["Mathlib/Init/Order/Defs.lean", "Mathlib/Init/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.le.elim", "code": "theorem le.elim {a b : \u2124} (h : a \u2264 b) {P : Prop} (h' : \u2200 n : \u2115, a + \u2191n = b \u2192 P) : P", "start": [25, 1], "end": [26, 29], "kind": "commanddeclaration"}, {"full_name": "Int.le_of_ofNat_le_ofNat", "code": "alias \u27e8le_of_ofNat_le_ofNat, ofNat_le_ofNat_of_le\u27e9 := ofNat_le", "start": [29, 1], "end": [29, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.ofNat_le_ofNat_of_le", "code": "alias \u27e8le_of_ofNat_le_ofNat, ofNat_le_ofNat_of_le\u27e9 := ofNat_le", "start": [29, 1], "end": [29, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.lt.elim", "code": "theorem lt.elim {a b : \u2124} (h : a < b) {P : Prop} (h' : \u2200 n : \u2115, a + \u2191(Nat.succ n) = b \u2192 P) : P", "start": [37, 1], "end": [38, 29], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_ofNat_lt_ofNat", "code": "alias \u27e8lt_of_ofNat_lt_ofNat, ofNat_lt_ofNat_of_lt\u27e9 := ofNat_lt", "start": [41, 1], "end": [41, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.ofNat_lt_ofNat_of_lt", "code": "alias \u27e8lt_of_ofNat_lt_ofNat, ofNat_lt_ofNat_of_lt\u27e9 := ofNat_lt", "start": [41, 1], "end": [41, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.instLinearOrderInt", "code": "instance instLinearOrderInt : LinearOrder \u2124 where\n  le := (\u00b7\u2264\u00b7)\n  le_refl := Int.le_refl\n  le_trans := @Int.le_trans\n  le_antisymm := @Int.le_antisymm\n  lt := (\u00b7<\u00b7)\n  lt_iff_le_not_le := @Int.lt_iff_le_not_le\n  le_total := Int.le_total\n  decidableEq := by infer_instance\n  decidableLE := by infer_instance\n  decidableLT := by infer_instance", "start": [46, 1], "end": [56, 35], "kind": "commanddeclaration"}, {"full_name": "Int.neg_mul_eq_neg_mul_symm", "code": "theorem neg_mul_eq_neg_mul_symm (a b : \u2124) : -a * b = -(a * b)", "start": [63, 1], "end": [63, 99], "kind": "commanddeclaration"}, {"full_name": "Int.mul_neg_eq_neg_mul_symm", "code": "theorem mul_neg_eq_neg_mul_symm (a b : \u2124) : a * -b = -(a * b)", "start": [66, 1], "end": [66, 99], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_or_eq_zero_of_mul_eq_zero", "code": "protected theorem eq_zero_or_eq_zero_of_mul_eq_zero {a b : \u2124} (h : a * b = 0) : a = 0 \u2228 b = 0", "start": [75, 1], "end": [99, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Function/Iterate.lean", "imports": ["Mathlib/Logic/Function/Conjugate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.iterate", "code": "def Nat.iterate {\u03b1 : Sort u} (op : \u03b1 \u2192 \u03b1) : \u2115 \u2192 \u03b1 \u2192 \u03b1\n  | 0, a => a\n  | succ k, a => iterate op k (op a)", "start": [37, 1], "end": [40, 37], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_zero", "code": "@[simp]\ntheorem iterate_zero : f^[0] = id", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_zero_apply", "code": "theorem iterate_zero_apply (x : \u03b1) : f^[0] x = x", "start": [57, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_succ", "code": "@[simp]\ntheorem iterate_succ (n : \u2115) : f^[n.succ] = f^[n] \u2218 f", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_succ_apply", "code": "theorem iterate_succ_apply (n : \u2115) (x : \u03b1) : f^[n.succ] x = f^[n] (f x)", "start": [66, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_id", "code": "@[simp]\ntheorem iterate_id (n : \u2115) : (id : \u03b1 \u2192 \u03b1)^[n] = id", "start": [70, 1], "end": [72, 70], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_add", "code": "theorem iterate_add (m : \u2115) : \u2200 n : \u2115, f^[m + n] = f^[m] \u2218 f^[n]", "start": [75, 1], "end": [77, 89], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_add_apply", "code": "theorem iterate_add_apply (m n : \u2115) (x : \u03b1) : f^[m + n] x = f^[m] (f^[n] x)", "start": [80, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_one", "code": "@[simp]\ntheorem iterate_one : f^[1] = f", "start": [85, 1], "end": [87, 21], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_mul", "code": "theorem iterate_mul (m : \u2115) : \u2200 n, f^[m * n] = f^[m]^[n]", "start": [90, 1], "end": [92, 97], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_fixed", "code": "theorem iterate_fixed {x} (h : f x = x) (n : \u2115) : f^[n] x = x", "start": [97, 1], "end": [98, 65], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.iterate", "code": "theorem Injective.iterate (Hinj : Injective f) (n : \u2115) : Injective f^[n]", "start": [101, 1], "end": [102, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.iterate", "code": "theorem Surjective.iterate (Hsurj : Surjective f) (n : \u2115) : Surjective f^[n]", "start": [105, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.iterate", "code": "theorem Bijective.iterate (Hbij : Bijective f) (n : \u2115) : Bijective f^[n]", "start": [109, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.iterate_right", "code": "theorem iterate_right {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2} (h : Semiconj f ga gb) (n : \u2115) :\n    Semiconj f ga^[n] gb^[n]", "start": [115, 1], "end": [117, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.iterate_left", "code": "theorem iterate_left {g : \u2115 \u2192 \u03b1 \u2192 \u03b1} (H : \u2200 n, Semiconj f (g n) (g <| n + 1)) (n k : \u2115) :\n    Semiconj f^[n] (g k) (g <| n + k)", "start": [120, 1], "end": [128, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_right", "code": "theorem iterate_right (h : Commute f g) (n : \u2115) : Commute f g^[n]", "start": [137, 1], "end": [138, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_left", "code": "theorem iterate_left (h : Commute f g) (n : \u2115) : Commute f^[n] g", "start": [141, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_iterate", "code": "theorem iterate_iterate (h : Commute f g) (m n : \u2115) : Commute f^[m] g^[n]", "start": [145, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_eq_of_map_eq", "code": "theorem iterate_eq_of_map_eq (h : Commute f g) (n : \u2115) {x} (hx : f x = g x) :\n    f^[n] x = g^[n] x", "start": [149, 1], "end": [152, 98], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.comp_iterate", "code": "theorem comp_iterate (h : Commute f g) (n : \u2115) : (f \u2218 g)^[n] = f^[n] \u2218 g^[n]", "start": [155, 1], "end": [160, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_self", "code": "theorem iterate_self (n : \u2115) : Commute f^[n] f", "start": [165, 1], "end": [166, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.self_iterate", "code": "theorem self_iterate (n : \u2115) : Commute f f^[n]", "start": [169, 1], "end": [170, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_iterate_self", "code": "theorem iterate_iterate_self (m n : \u2115) : Commute f^[m] f^[n]", "start": [173, 1], "end": [174, 31], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj\u2082.iterate", "code": "theorem Semiconj\u2082.iterate {f : \u03b1 \u2192 \u03b1} {op : \u03b1 \u2192 \u03b1 \u2192 \u03b1} (hf : Semiconj\u2082 f op op) (n : \u2115) :\n    Semiconj\u2082 f^[n] op op", "start": [179, 1], "end": [181, 61], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_succ'", "code": "theorem iterate_succ' (n : \u2115) : f^[n.succ] = f \u2218 f^[n]", "start": [186, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_succ_apply'", "code": "theorem iterate_succ_apply' (n : \u2115) (x : \u03b1) : f^[n.succ] x = f (f^[n] x)", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_pred_comp_of_pos", "code": "theorem iterate_pred_comp_of_pos {n : \u2115} (hn : 0 < n) : f^[n.pred] \u2218 f = f^[n]", "start": [195, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "Function.comp_iterate_pred_of_pos", "code": "theorem comp_iterate_pred_of_pos {n : \u2115} (hn : 0 < n) : f \u2218 f^[n.pred] = f^[n]", "start": [199, 1], "end": [200, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Iterate.rec", "code": "def Iterate.rec (p : \u03b1 \u2192 Sort*) {f : \u03b1 \u2192 \u03b1} (h : \u2200 a, p a \u2192 p (f a)) {a : \u03b1} (ha : p a) (n : \u2115) :\n    p (f^[n] a) :=\n  match n with\n  | 0 => ha\n  | m+1 => Iterate.rec p h (h _ ha) m", "start": [203, 1], "end": [208, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Iterate.rec_zero", "code": "theorem Iterate.rec_zero (p : \u03b1 \u2192 Sort*) {f : \u03b1 \u2192 \u03b1} (h : \u2200 a, p a \u2192 p (f a)) {a : \u03b1} (ha : p a) :\n    Iterate.rec p h ha 0 = ha", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.iterate", "code": "theorem LeftInverse.iterate {g : \u03b1 \u2192 \u03b1} (hg : LeftInverse g f) (n : \u2115) :\n    LeftInverse g^[n] f^[n]", "start": [218, 1], "end": [222, 22], "kind": "commanddeclaration"}, {"full_name": "Function.RightInverse.iterate", "code": "theorem RightInverse.iterate {g : \u03b1 \u2192 \u03b1} (hg : RightInverse g f) (n : \u2115) :\n    RightInverse g^[n] f^[n]", "start": [225, 1], "end": [227, 27], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_comm", "code": "theorem iterate_comm (f : \u03b1 \u2192 \u03b1) (m n : \u2115) : f^[n]^[m] = f^[m]^[n]", "start": [230, 1], "end": [231, 87], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_commute", "code": "theorem iterate_commute (m n : \u2115) : Commute (fun f : \u03b1 \u2192 \u03b1 \u21a6 f^[m]) fun f \u21a6 f^[n]", "start": [234, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_add_eq_iterate", "code": "lemma iterate_add_eq_iterate (hf : Injective f) : f^[m + n] a = f^[n] a \u2194 f^[m] a = a :=\n  Iff.trans (by rw [\u2190iterate_add_apply, Nat.add_comm]) (hf.iterate n).eq_iff", "start": [238, 1], "end": [239, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Function.iterate_cancel_of_add", "code": "alias \u27e8iterate_cancel_of_add, _\u27e9 := iterate_add_eq_iterate", "start": [242, 1], "end": [242, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Function.iterate_cancel", "code": "lemma iterate_cancel (hf : Injective f) (ha : f^[m] a = f^[n] a) : f^[m - n] a = a := by\n  obtain h | h := Nat.le_total m n\n  { simp [Nat.sub_eq_zero_of_le h] }\n  { exact iterate_cancel_of_add hf (by rwa [Nat.sub_add_cancel h]) }", "start": [245, 1], "end": [248, 69], "kind": "mathlibtacticlemma"}, {"full_name": "Function.involutive_iff_iter_2_eq_id", "code": "theorem involutive_iff_iter_2_eq_id {\u03b1} {f : \u03b1 \u2192 \u03b1} : Involutive f \u2194 f^[2] = id", "start": [251, 1], "end": [252, 18], "kind": "commanddeclaration"}, {"full_name": "List.foldl_const", "code": "theorem foldl_const (f : \u03b1 \u2192 \u03b1) (a : \u03b1) (l : List \u03b2) :\n    l.foldl (fun b _ \u21a6 f b) a = f^[l.length] a", "start": [261, 1], "end": [265, 65], "kind": "commanddeclaration"}, {"full_name": "List.foldr_const", "code": "theorem foldr_const (f : \u03b2 \u2192 \u03b2) (b : \u03b2) : \u2200 l : List \u03b1, l.foldr (fun _ \u21a6 f) b = f^[l.length] b", "start": [268, 1], "end": [270, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Backtrack.lean", "imports": ["Mathlib/Lean/Meta.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Util.lean", "Mathlib/Data/Nondet/Basic.lean"], "premises": [{"full_name": "Except.emoji", "code": "def Except.emoji : Except \u03b5 \u03b1 \u2192 String\n  | .error _ => crossEmoji\n  | .ok _ => checkEmoji", "start": [34, 1], "end": [37, 24], "kind": "commanddeclaration"}, {"full_name": "List.tryAllM", "code": "def List.tryAllM [Monad m] [Alternative m] (L : List \u03b1) (f : \u03b1 \u2192 m \u03b2) : m (List \u03b1 \u00d7 List \u03b2) := do\n  let R \u2190 L.mapM (fun a => (Sum.inr <$> f a) <|> (pure (Sum.inl a)))\n  return (R.filterMap (fun s => match s with | .inl a => a | _ => none),\n    R.filterMap (fun s => match s with | .inr b => b | _ => none))", "start": [39, 1], "end": [44, 67], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.firstContinuation", "code": "def firstContinuation (results : MVarId \u2192 Nondet MetaM (List MVarId))\n    (cont : List MVarId \u2192 MetaM \u03b1) (g : MVarId) : MetaM \u03b1 := do\n  (results g).firstM fun r => observing? do cont r", "start": [48, 1], "end": [55, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.BacktrackConfig", "code": "structure BacktrackConfig where\n  \n  maxDepth : Nat := 6\n  \n  proc : List MVarId \u2192 List MVarId \u2192 MetaM (Option (List MVarId)) := fun _ _ => pure none\n  \n  suspend : MVarId \u2192 MetaM Bool := fun _ => pure false\n  \n  discharge : MVarId \u2192 MetaM (Option (List MVarId)) := fun _ => failure\n  \n  commitIndependentGoals : Bool := false", "start": [61, 1], "end": [91, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.ppMVarIds", "code": "def ppMVarIds (gs : List MVarId) : MetaM (List Format) := do\n  gs.mapM fun g => do ppExpr (\u2190 g.getType)", "start": [93, 1], "end": [94, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.backtrack", "code": "partial def backtrack (cfg : BacktrackConfig := {}) (trace : Name := .anonymous)\n    (alternatives : MVarId \u2192 Nondet MetaM (List MVarId))\n    (goals : List MVarId) : MetaM (List MVarId) := do\n  processIndependentGoals goals goals\nwhere\n  \n  run (n : Nat) (curr acc : List MVarId) : MetaM (List MVarId) := do\n    match n with\n    | 0 => do\n      throwError \"backtrack exceeded the recursion limit\"\n    | n + 1 => do\n    let procResult? \u2190 try\n      cfg.proc goals curr\n    catch e =>\n      withTraceNode trace\n        (return m!\"{\u00b7.emoji} BacktrackConfig.proc failed: {e.toMessageData}\") do\n      throw e\n    match procResult? with\n    | some curr' => run n curr' acc\n    | none =>\n    match curr with\n    | [] => withTraceNode trace (return m!\"{\u00b7.emoji} success!\") do\n        return acc.reverse\n    | g :: gs =>\n    if \u2190 g.isAssigned then\n      withTraceNode trace (return m!\"{\u00b7.emoji} discarding already assigned goal {g}\") do\n        run (n+1) gs acc\n    else\n    withTraceNode trace\n      (return m!\"{\u00b7.emoji} working on: {\u2190 addMessageContextFull g}\")\n      do\n        if (\u2190 cfg.suspend g) then\n          withTraceNode trace\n            (fun _ => return m!\"\u23f8\ufe0f suspending search and returning as subgoal\") do\n          run (n+1) gs (g :: acc)\n        else\n          try\n            g.firstContinuation alternatives (fun res => run n (res ++ gs) acc)\n          catch _ =>\n            match (\u2190 cfg.discharge g) with\n            | none => (withTraceNode trace\n                (fun _ => return m!\"\u23ed\ufe0f deemed acceptable, returning as subgoal\") do\n              run (n+1) gs (g :: acc))\n            | some l => (withTraceNode trace\n                (fun _ => return m!\"\u23ec discharger generated new subgoals\") do\n              run n (l ++ gs) acc)\n  processIndependentGoals (goals remaining : List MVarId) : MetaM (List MVarId) := do\n    let (igs, ogs) \u2190 remaining.partitionM (MVarId.independent? goals)\n    if igs.isEmpty then\n      return (\u2190 run cfg.maxDepth remaining [])\n    else\n      withTraceNode trace\n        (fun _ => return m!\"independent goals {\u2190 ppMVarIds igs},\"\n          ++ m!\" working on them before {\u2190 ppMVarIds ogs}\") do\n      let (failed, newSubgoals') \u2190 igs.tryAllM (fun g => run cfg.maxDepth [g] [])\n      let newSubgoals := newSubgoals'.join\n      withTraceNode trace\n        (fun _ => return m!\"failed: {\u2190 ppMVarIds failed}, new: {\u2190 ppMVarIds newSubgoals}\") do\n      let goals' := (\u2190 goals.filterM (fun g => do pure !(\u2190 g.isAssigned))) ++ newSubgoals\n      if cfg.commitIndependentGoals && !newSubgoals.isEmpty then\n        return newSubgoals ++ failed ++ (\u2190 (processIndependentGoals goals' ogs <|> pure ogs))\n      else if !failed.isEmpty then\n        failure\n      else\n        return newSubgoals ++ (\u2190 processIndependentGoals goals' ogs)", "start": [96, 1], "end": [201, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/GCongr/ForwardAttr.lean", "imports": ["lake-packages/std/Std/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.GCongr.ForwardExt", "code": "structure ForwardExt where\n  eval (h : Expr) (goal : MVarId) : MetaM Unit", "start": [16, 1], "end": [18, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GCongr.mkForwardExt", "code": "def mkForwardExt (n : Name) : ImportM ForwardExt := do\n  let { env, opts, .. } \u2190 read\n  IO.ofExcept <| unsafe env.evalConstCheck ForwardExt opts ``ForwardExt n", "start": [20, 1], "end": [23, 74], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop/Main.lean", "imports": ["lake-packages/aesop/Aesop/BuiltinRules.lean", "lake-packages/aesop/Aesop/Frontend/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/aesop/Aesop/Search/Main.lean", "lake-packages/aesop/Aesop/Profiling.lean"], "premises": [{"full_name": "Aesop.evalAesop", "code": "@[tactic Frontend.Parser.aesopTactic, tactic Frontend.Parser.aesopTactic?]\ndef evalAesop : Tactic := \u03bb stx => do\n  profileitM Exception \"aesop\" (\u2190 getOptions) do\n  withMainContext do\n    let (profile, totalTime) \u2190 time do\n      let (config, configParseTime) \u2190 time $ Frontend.TacticConfig.parse stx\n      let profile := { Profile.empty with configParsing := configParseTime }\n      let goal \u2190 getMainGoal\n      let ((goal, ruleSet), ruleSetConstructionTime) \u2190 time $\n        config.getRuleSet goal\n      let profile :=\n        { profile with ruleSetConstruction := ruleSetConstructionTime }\n      withConstAesopTraceNode .ruleSet (return \"Rule set\") do\n        ruleSet.trace .ruleSet\n      let (profile, searchTime) \u2190 time do\n        let (goals, profile) \u2190\n          search goal ruleSet config.options config.simpConfig\n            config.simpConfigSyntax? profile\n        replaceMainGoal goals.toList\n        pure profile\n      pure { profile with search := searchTime }\n    let profile := { profile with total := totalTime }\n    profile.trace .profile", "start": [17, 1], "end": [39, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ULift.lean", "imports": ["Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ULift.up_le", "code": "@[simp] theorem up_le [LE \u03b1] {a b : \u03b1} : up a \u2264 up b \u2194 a \u2264 b", "start": [22, 1], "end": [22, 72], "kind": "commanddeclaration"}, {"full_name": "ULift.down_le", "code": "@[simp] theorem down_le [LE \u03b1] {a b : ULift \u03b1} : down a \u2264 down b \u2194 a \u2264 b", "start": [23, 1], "end": [23, 84], "kind": "commanddeclaration"}, {"full_name": "ULift.up_lt", "code": "@[simp] theorem up_lt [LT \u03b1] {a b : \u03b1} : up a < up b \u2194 a < b", "start": [27, 1], "end": [27, 72], "kind": "commanddeclaration"}, {"full_name": "ULift.down_lt", "code": "@[simp] theorem down_lt [LT \u03b1] {a b : ULift \u03b1} : down a < down b \u2194 a < b", "start": [28, 1], "end": [28, 84], "kind": "commanddeclaration"}, {"full_name": "ULift.up_compare", "code": "@[simp] theorem up_compare [Ord \u03b1] (a b : \u03b1) : compare (up a) (up b) = compare a b", "start": [32, 1], "end": [32, 90], "kind": "commanddeclaration"}, {"full_name": "ULift.down_compare", "code": "@[simp] theorem down_compare [Ord \u03b1] (a b : ULift \u03b1) :\n  compare (down a) (down b) = compare a b", "start": [33, 1], "end": [34, 49], "kind": "commanddeclaration"}, {"full_name": "ULift.up_sup", "code": "@[simp] theorem up_sup [Sup \u03b1] (a b : \u03b1) : up (a \u2294 b) = up a \u2294 up b", "start": [38, 1], "end": [38, 75], "kind": "commanddeclaration"}, {"full_name": "ULift.down_sup", "code": "@[simp] theorem down_sup [Sup \u03b1] (a b : ULift \u03b1) : down (a \u2294 b) = down a \u2294 down b", "start": [39, 1], "end": [39, 89], "kind": "commanddeclaration"}, {"full_name": "ULift.up_inf", "code": "@[simp] theorem up_inf [Inf \u03b1] (a b : \u03b1) : up (a \u2293 b) = up a \u2293 up b", "start": [43, 1], "end": [43, 75], "kind": "commanddeclaration"}, {"full_name": "ULift.down_inf", "code": "@[simp] theorem down_inf [Inf \u03b1] (a b : ULift \u03b1) : down (a \u2293 b) = down a \u2293 down b", "start": [44, 1], "end": [44, 89], "kind": "commanddeclaration"}, {"full_name": "ULift.up_sdiff", "code": "@[simp] theorem up_sdiff [SDiff \u03b1] (a b : \u03b1) : up (a \\ b) = up a \\ up b", "start": [48, 1], "end": [48, 79], "kind": "commanddeclaration"}, {"full_name": "ULift.down_sdiff", "code": "@[simp] theorem down_sdiff [SDiff \u03b1] (a b : ULift \u03b1) : down (a \\ b) = down a \\ down b", "start": [49, 1], "end": [49, 93], "kind": "commanddeclaration"}, {"full_name": "ULift.up_compl", "code": "@[simp] theorem up_compl [HasCompl \u03b1] (a : \u03b1) : up (a\u1d9c) = (up a)\u1d9c", "start": [53, 1], "end": [53, 73], "kind": "commanddeclaration"}, {"full_name": "ULift.down_compl", "code": "@[simp] theorem down_compl [HasCompl \u03b1] (a : ULift \u03b1) : down a\u1d9c = (down a)\u1d9c", "start": [54, 1], "end": [54, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Monotone/Basic.lean", "imports": ["Mathlib/Logic/Function/Iterate.lean", "Mathlib/Init/Data/Int/Order.lean", "Mathlib/Order/Compare.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Choose.lean", "Mathlib/Order/Max.lean", "Mathlib/Order/RelClasses.lean"], "premises": [{"full_name": "Monotone", "code": "def Monotone (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a b\u2984, a \u2264 b \u2192 f a \u2264 f b", "start": [76, 1], "end": [78, 29], "kind": "commanddeclaration"}, {"full_name": "Antitone", "code": "def Antitone (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a b\u2984, a \u2264 b \u2192 f b \u2264 f a", "start": [81, 1], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn", "code": "def MonotoneOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a \u2264 b \u2192 f a \u2264 f b", "start": [86, 1], "end": [88, 55], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn", "code": "def AntitoneOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a \u2264 b \u2192 f b \u2264 f a", "start": [91, 1], "end": [93, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMono", "code": "def StrictMono (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a b\u2984, a < b \u2192 f a < f b", "start": [96, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "StrictAnti", "code": "def StrictAnti (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 \u2983a b\u2984, a < b \u2192 f b < f a", "start": [101, 1], "end": [103, 29], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn", "code": "def StrictMonoOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a < b \u2192 f a < f b", "start": [106, 1], "end": [109, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn", "code": "def StrictAntiOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a < b \u2192 f b < f a", "start": [112, 1], "end": [115, 55], "kind": "commanddeclaration"}, {"full_name": "monotone_comp_ofDual_iff", "code": "@[simp]\ntheorem monotone_comp_ofDual_iff : Monotone (f \u2218 ofDual) \u2194 Antitone f", "start": [159, 1], "end": [161, 14], "kind": "commanddeclaration"}, {"full_name": "antitone_comp_ofDual_iff", "code": "@[simp]\ntheorem antitone_comp_ofDual_iff : Antitone (f \u2218 ofDual) \u2194 Monotone f", "start": [164, 1], "end": [166, 14], "kind": "commanddeclaration"}, {"full_name": "monotone_toDual_comp_iff", "code": "@[simp]\ntheorem monotone_toDual_comp_iff : Monotone (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 Antitone f", "start": [173, 1], "end": [175, 10], "kind": "commanddeclaration"}, {"full_name": "antitone_toDual_comp_iff", "code": "@[simp]\ntheorem antitone_toDual_comp_iff : Antitone (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 Monotone f", "start": [178, 1], "end": [180, 10], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_comp_ofDual_iff", "code": "@[simp]\ntheorem monotoneOn_comp_ofDual_iff : MonotoneOn (f \u2218 ofDual) s \u2194 AntitoneOn f s", "start": [183, 1], "end": [185, 15], "kind": "commanddeclaration"}, {"full_name": "antitoneOn_comp_ofDual_iff", "code": "@[simp]\ntheorem antitoneOn_comp_ofDual_iff : AntitoneOn (f \u2218 ofDual) s \u2194 MonotoneOn f s", "start": [188, 1], "end": [190, 15], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_toDual_comp_iff", "code": "@[simp]\ntheorem monotoneOn_toDual_comp_iff : MonotoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 AntitoneOn f s", "start": [193, 1], "end": [195, 10], "kind": "commanddeclaration"}, {"full_name": "antitoneOn_toDual_comp_iff", "code": "@[simp]\ntheorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s", "start": [198, 1], "end": [200, 10], "kind": "commanddeclaration"}, {"full_name": "strictMono_comp_ofDual_iff", "code": "@[simp]\ntheorem strictMono_comp_ofDual_iff : StrictMono (f \u2218 ofDual) \u2194 StrictAnti f", "start": [203, 1], "end": [205, 14], "kind": "commanddeclaration"}, {"full_name": "strictAnti_comp_ofDual_iff", "code": "@[simp]\ntheorem strictAnti_comp_ofDual_iff : StrictAnti (f \u2218 ofDual) \u2194 StrictMono f", "start": [208, 1], "end": [210, 14], "kind": "commanddeclaration"}, {"full_name": "strictMono_toDual_comp_iff", "code": "@[simp]\ntheorem strictMono_toDual_comp_iff : StrictMono (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictAnti f", "start": [213, 1], "end": [215, 10], "kind": "commanddeclaration"}, {"full_name": "strictAnti_toDual_comp_iff", "code": "@[simp]\ntheorem strictAnti_toDual_comp_iff : StrictAnti (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f", "start": [218, 1], "end": [220, 10], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_comp_ofDual_iff", "code": "@[simp]\ntheorem strictMonoOn_comp_ofDual_iff : StrictMonoOn (f \u2218 ofDual) s \u2194 StrictAntiOn f s", "start": [223, 1], "end": [225, 15], "kind": "commanddeclaration"}, {"full_name": "strictAntiOn_comp_ofDual_iff", "code": "@[simp]\ntheorem strictAntiOn_comp_ofDual_iff : StrictAntiOn (f \u2218 ofDual) s \u2194 StrictMonoOn f s", "start": [228, 1], "end": [230, 15], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_toDual_comp_iff", "code": "@[simp]\ntheorem strictMonoOn_toDual_comp_iff : StrictMonoOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictAntiOn f s", "start": [233, 1], "end": [235, 10], "kind": "commanddeclaration"}, {"full_name": "strictAntiOn_toDual_comp_iff", "code": "@[simp]\ntheorem strictAntiOn_toDual_comp_iff : StrictAntiOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s", "start": [238, 1], "end": [240, 10], "kind": "commanddeclaration"}, {"full_name": "monotone_dual_iff", "code": "theorem monotone_dual_iff : Monotone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Monotone f", "start": [243, 1], "end": [244, 58], "kind": "commanddeclaration"}, {"full_name": "antitone_dual_iff", "code": "theorem antitone_dual_iff : Antitone (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 Antitone f", "start": [246, 1], "end": [247, 58], "kind": "commanddeclaration"}, {"full_name": "monotone_on_dual_iff", "code": "theorem monotone_on_dual_iff : MonotoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s", "start": [249, 1], "end": [250, 62], "kind": "commanddeclaration"}, {"full_name": "antitone_on_dual_iff", "code": "theorem antitone_on_dual_iff : AntitoneOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 AntitoneOn f s", "start": [252, 1], "end": [253, 62], "kind": "commanddeclaration"}, {"full_name": "strict_mono_dual_iff", "code": "theorem strict_mono_dual_iff : StrictMono (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictMono f", "start": [255, 1], "end": [256, 62], "kind": "commanddeclaration"}, {"full_name": "strict_anti_dual_iff", "code": "theorem strict_anti_dual_iff : StrictAnti (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) \u2194 StrictAnti f", "start": [258, 1], "end": [259, 62], "kind": "commanddeclaration"}, {"full_name": "strict_mono_on_dual_iff", "code": "theorem strict_mono_on_dual_iff :\n    StrictMonoOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictMonoOn f s", "start": [261, 1], "end": [263, 66], "kind": "commanddeclaration"}, {"full_name": "strict_anti_on_dual_iff", "code": "theorem strict_anti_on_dual_iff :\n    StrictAntiOn (toDual \u2218 f \u2218 ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) s \u2194 StrictAntiOn f s", "start": [265, 1], "end": [267, 66], "kind": "commanddeclaration"}, {"full_name": "Monotone.dual_left", "code": "alias \u27e8_, Monotone.dual_left\u27e9 := antitone_comp_ofDual_iff", "start": [269, 1], "end": [269, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Antitone.dual_left", "code": "alias \u27e8_, Antitone.dual_left\u27e9 := monotone_comp_ofDual_iff", "start": [272, 1], "end": [272, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Monotone.dual_right", "code": "alias \u27e8_, Monotone.dual_right\u27e9 := antitone_toDual_comp_iff", "start": [275, 1], "end": [275, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Antitone.dual_right", "code": "alias \u27e8_, Antitone.dual_right\u27e9 := monotone_toDual_comp_iff", "start": [278, 1], "end": [278, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MonotoneOn.dual_left", "code": "alias \u27e8_, MonotoneOn.dual_left\u27e9 := antitoneOn_comp_ofDual_iff", "start": [281, 1], "end": [281, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntitoneOn.dual_left", "code": "alias \u27e8_, AntitoneOn.dual_left\u27e9 := monotoneOn_comp_ofDual_iff", "start": [284, 1], "end": [284, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MonotoneOn.dual_right", "code": "alias \u27e8_, MonotoneOn.dual_right\u27e9 := antitoneOn_toDual_comp_iff", "start": [287, 1], "end": [287, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntitoneOn.dual_right", "code": "alias \u27e8_, AntitoneOn.dual_right\u27e9 := monotoneOn_toDual_comp_iff", "start": [290, 1], "end": [290, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMono.dual_left", "code": "alias \u27e8_, StrictMono.dual_left\u27e9 := strictAnti_comp_ofDual_iff", "start": [293, 1], "end": [293, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAnti.dual_left", "code": "alias \u27e8_, StrictAnti.dual_left\u27e9 := strictMono_comp_ofDual_iff", "start": [296, 1], "end": [296, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMono.dual_right", "code": "alias \u27e8_, StrictMono.dual_right\u27e9 := strictAnti_toDual_comp_iff", "start": [299, 1], "end": [299, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAnti.dual_right", "code": "alias \u27e8_, StrictAnti.dual_right\u27e9 := strictMono_toDual_comp_iff", "start": [302, 1], "end": [302, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMonoOn.dual_left", "code": "alias \u27e8_, StrictMonoOn.dual_left\u27e9 := strictAntiOn_comp_ofDual_iff", "start": [305, 1], "end": [305, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAntiOn.dual_left", "code": "alias \u27e8_, StrictAntiOn.dual_left\u27e9 := strictMonoOn_comp_ofDual_iff", "start": [308, 1], "end": [308, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMonoOn.dual_right", "code": "alias \u27e8_, StrictMonoOn.dual_right\u27e9 := strictAntiOn_toDual_comp_iff", "start": [311, 1], "end": [311, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAntiOn.dual_right", "code": "alias \u27e8_, StrictAntiOn.dual_right\u27e9 := strictMonoOn_toDual_comp_iff", "start": [314, 1], "end": [314, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Monotone.dual", "code": "alias \u27e8_, Monotone.dual\u27e9 := monotone_dual_iff", "start": [317, 1], "end": [317, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Antitone.dual", "code": "alias \u27e8_, Antitone.dual\u27e9 := antitone_dual_iff", "start": [320, 1], "end": [320, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MonotoneOn.dual", "code": "alias \u27e8_, MonotoneOn.dual\u27e9 := monotone_on_dual_iff", "start": [323, 1], "end": [323, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntitoneOn.dual", "code": "alias \u27e8_, AntitoneOn.dual\u27e9 := antitone_on_dual_iff", "start": [326, 1], "end": [326, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMono.dual", "code": "alias \u27e8_, StrictMono.dual\u27e9 := strict_mono_dual_iff", "start": [329, 1], "end": [329, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAnti.dual", "code": "alias \u27e8_, StrictAnti.dual\u27e9 := strict_anti_dual_iff", "start": [332, 1], "end": [332, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictMonoOn.dual", "code": "alias \u27e8_, StrictMonoOn.dual\u27e9 := strict_mono_on_dual_iff", "start": [335, 1], "end": [335, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "StrictAntiOn.dual", "code": "alias \u27e8_, StrictAntiOn.dual\u27e9 := strict_anti_on_dual_iff", "start": [338, 1], "end": [338, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Monotone.comp_le_comp_left", "code": "theorem Monotone.comp_le_comp_left\n    [Preorder \u03b2] {f : \u03b2 \u2192 \u03b1} {g h : \u03b3 \u2192 \u03b2} (hf : Monotone f) (le_gh : g \u2264 h) :\n    LE.le.{max w u} (f \u2218 g) (f \u2218 h)", "start": [350, 1], "end": [353, 23], "kind": "commanddeclaration"}, {"full_name": "monotone_lam", "code": "theorem monotone_lam {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : \u2200 b, Monotone fun a \u21a6 f a b) : Monotone f", "start": [358, 1], "end": [359, 23], "kind": "commanddeclaration"}, {"full_name": "monotone_app", "code": "theorem monotone_app (f : \u03b2 \u2192 \u03b1 \u2192 \u03b3) (b : \u03b2) (hf : Monotone fun a b \u21a6 f b a) : Monotone (f b)", "start": [362, 1], "end": [363, 21], "kind": "commanddeclaration"}, {"full_name": "antitone_lam", "code": "theorem antitone_lam {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hf : \u2200 b, Antitone fun a \u21a6 f a b) : Antitone f", "start": [366, 1], "end": [367, 23], "kind": "commanddeclaration"}, {"full_name": "antitone_app", "code": "theorem antitone_app (f : \u03b2 \u2192 \u03b1 \u2192 \u03b3) (b : \u03b2) (hf : Antitone fun a b \u21a6 f b a) : Antitone (f b)", "start": [370, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "Function.monotone_eval", "code": "theorem Function.monotone_eval {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, Preorder (\u03b1 i)] (i : \u03b9) :\n    Monotone (Function.eval i : (\u2200 i, \u03b1 i) \u2192 \u03b1 i)", "start": [376, 1], "end": [377, 69], "kind": "commanddeclaration"}, {"full_name": "Monotone.imp", "code": "theorem Monotone.imp (hf : Monotone f) (h : a \u2264 b) : f a \u2264 f b", "start": [398, 1], "end": [399, 7], "kind": "commanddeclaration"}, {"full_name": "Antitone.imp", "code": "theorem Antitone.imp (hf : Antitone f) (h : a \u2264 b) : f b \u2264 f a", "start": [402, 1], "end": [403, 7], "kind": "commanddeclaration"}, {"full_name": "StrictMono.imp", "code": "theorem StrictMono.imp (hf : StrictMono f) (h : a < b) : f a < f b", "start": [406, 1], "end": [407, 7], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.imp", "code": "theorem StrictAnti.imp (hf : StrictAnti f) (h : a < b) : f b < f a", "start": [410, 1], "end": [411, 7], "kind": "commanddeclaration"}, {"full_name": "Monotone.monotoneOn", "code": "protected theorem Monotone.monotoneOn (hf : Monotone f) (s : Set \u03b1) : MonotoneOn f s", "start": [414, 1], "end": [415, 23], "kind": "commanddeclaration"}, {"full_name": "Antitone.antitoneOn", "code": "protected theorem Antitone.antitoneOn (hf : Antitone f) (s : Set \u03b1) : AntitoneOn f s", "start": [418, 1], "end": [419, 23], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_univ", "code": "@[simp] theorem monotoneOn_univ : MonotoneOn f Set.univ \u2194 Monotone f", "start": [422, 1], "end": [423, 58], "kind": "commanddeclaration"}, {"full_name": "antitoneOn_univ", "code": "@[simp] theorem antitoneOn_univ : AntitoneOn f Set.univ \u2194 Antitone f", "start": [426, 1], "end": [427, 58], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictMonoOn", "code": "protected theorem StrictMono.strictMonoOn (hf : StrictMono f) (s : Set \u03b1) : StrictMonoOn f s", "start": [430, 1], "end": [431, 23], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.strictAntiOn", "code": "protected theorem StrictAnti.strictAntiOn (hf : StrictAnti f) (s : Set \u03b1) : StrictAntiOn f s", "start": [434, 1], "end": [435, 23], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_univ", "code": "@[simp] theorem strictMonoOn_univ : StrictMonoOn f Set.univ \u2194 StrictMono f", "start": [438, 1], "end": [439, 60], "kind": "commanddeclaration"}, {"full_name": "strictAntiOn_univ", "code": "@[simp] theorem strictAntiOn_univ : StrictAntiOn f Set.univ \u2194 StrictAnti f", "start": [442, 1], "end": [443, 60], "kind": "commanddeclaration"}, {"full_name": "Monotone.strictMono_of_injective", "code": "theorem Monotone.strictMono_of_injective (h\u2081 : Monotone f) (h\u2082 : Injective f) : StrictMono f", "start": [452, 1], "end": [453, 54], "kind": "commanddeclaration"}, {"full_name": "Antitone.strictAnti_of_injective", "code": "theorem Antitone.strictAnti_of_injective (h\u2081 : Antitone f) (h\u2082 : Injective f) : StrictAnti f", "start": [456, 1], "end": [457, 59], "kind": "commanddeclaration"}, {"full_name": "monotone_iff_forall_lt", "code": "theorem monotone_iff_forall_lt : Monotone f \u2194 \u2200 \u2983a b\u2984, a < b \u2192 f a \u2264 f b", "start": [468, 1], "end": [470, 85], "kind": "commanddeclaration"}, {"full_name": "antitone_iff_forall_lt", "code": "theorem antitone_iff_forall_lt : Antitone f \u2194 \u2200 \u2983a b\u2984, a < b \u2192 f b \u2264 f a", "start": [473, 1], "end": [475, 85], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_iff_forall_lt", "code": "theorem monotoneOn_iff_forall_lt :\n    MonotoneOn f s \u2194 \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a < b \u2192 f a \u2264 f b", "start": [478, 1], "end": [481, 81], "kind": "commanddeclaration"}, {"full_name": "antitoneOn_iff_forall_lt", "code": "theorem antitoneOn_iff_forall_lt :\n    AntitoneOn f s \u2194 \u2200 \u2983a\u2984 (_ : a \u2208 s) \u2983b\u2984 (_ : b \u2208 s), a < b \u2192 f b \u2264 f a", "start": [484, 1], "end": [487, 81], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.monotoneOn", "code": "protected theorem StrictMonoOn.monotoneOn (hf : StrictMonoOn f s) : MonotoneOn f s", "start": [492, 1], "end": [493, 63], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.antitoneOn", "code": "protected theorem StrictAntiOn.antitoneOn (hf : StrictAntiOn f s) : AntitoneOn f s", "start": [496, 1], "end": [497, 63], "kind": "commanddeclaration"}, {"full_name": "StrictMono.monotone", "code": "protected theorem StrictMono.monotone (hf : StrictMono f) : Monotone f", "start": [500, 1], "end": [501, 49], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.antitone", "code": "protected theorem StrictAnti.antitone (hf : StrictAnti f) : Antitone f", "start": [504, 1], "end": [505, 49], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.monotone", "code": "protected theorem monotone [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : Monotone f", "start": [517, 1], "end": [518, 56], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.antitone", "code": "protected theorem antitone [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : Antitone f", "start": [521, 1], "end": [522, 56], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.monotone'", "code": "theorem monotone' [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) : Monotone f", "start": [525, 1], "end": [526, 41], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.antitone'", "code": "theorem antitone' [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) : Antitone f", "start": [529, 1], "end": [530, 41], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.strictMono", "code": "protected theorem strictMono [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : StrictMono f", "start": [533, 1], "end": [534, 51], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.strictAnti", "code": "protected theorem strictAnti [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : StrictAnti f", "start": [537, 1], "end": [538, 51], "kind": "commanddeclaration"}, {"full_name": "monotone_id", "code": "theorem monotone_id [Preorder \u03b1] : Monotone (id : \u03b1 \u2192 \u03b1)", "start": [546, 1], "end": [546, 73], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_id", "code": "theorem monotoneOn_id [Preorder \u03b1] {s : Set \u03b1} : MonotoneOn id s", "start": [549, 1], "end": [549, 85], "kind": "commanddeclaration"}, {"full_name": "strictMono_id", "code": "theorem strictMono_id [Preorder \u03b1] : StrictMono (id : \u03b1 \u2192 \u03b1)", "start": [552, 1], "end": [552, 77], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_id", "code": "theorem strictMonoOn_id [Preorder \u03b1] {s : Set \u03b1} : StrictMonoOn id s", "start": [555, 1], "end": [555, 89], "kind": "commanddeclaration"}, {"full_name": "monotone_const", "code": "theorem monotone_const [Preorder \u03b1] [Preorder \u03b2] {c : \u03b2} : Monotone fun _ : \u03b1 \u21a6 c", "start": [558, 1], "end": [559, 21], "kind": "commanddeclaration"}, {"full_name": "monotoneOn_const", "code": "theorem monotoneOn_const [Preorder \u03b1] [Preorder \u03b2] {c : \u03b2} {s : Set \u03b1} :\n    MonotoneOn (fun _ : \u03b1 \u21a6 c) s", "start": [562, 1], "end": [564, 25], "kind": "commanddeclaration"}, {"full_name": "antitone_const", "code": "theorem antitone_const [Preorder \u03b1] [Preorder \u03b2] {c : \u03b2} : Antitone fun _ : \u03b1 \u21a6 c", "start": [567, 1], "end": [568, 24], "kind": "commanddeclaration"}, {"full_name": "antitoneOn_const", "code": "theorem antitoneOn_const [Preorder \u03b1] [Preorder \u03b2] {c : \u03b2} {s : Set \u03b1} :\n    AntitoneOn (fun _ : \u03b1 \u21a6 c) s", "start": [571, 1], "end": [573, 25], "kind": "commanddeclaration"}, {"full_name": "strictMono_of_le_iff_le", "code": "theorem strictMono_of_le_iff_le [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x y, x \u2264 y \u2194 f x \u2264 f y) : StrictMono f", "start": [576, 1], "end": [578, 56], "kind": "commanddeclaration"}, {"full_name": "strictAnti_of_le_iff_le", "code": "theorem strictAnti_of_le_iff_le [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x y, x \u2264 y \u2194 f y \u2264 f x) : StrictAnti f", "start": [581, 1], "end": [583, 56], "kind": "commanddeclaration"}, {"full_name": "injective_of_lt_imp_ne", "code": "theorem injective_of_lt_imp_ne [LinearOrder \u03b1] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, x < y \u2192 f x \u2260 f y) :\n    Injective f", "start": [587, 1], "end": [593, 38], "kind": "commanddeclaration"}, {"full_name": "injective_of_le_imp_le", "code": "theorem injective_of_le_imp_le [PartialOrder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 {x y}, f x \u2264 f y \u2192 x \u2264 y) : Injective f", "start": [596, 1], "end": [598, 47], "kind": "commanddeclaration"}, {"full_name": "StrictMono.isMax_of_apply", "code": "theorem StrictMono.isMax_of_apply (hf : StrictMono f) (ha : IsMax (f a)) : IsMax a", "start": [605, 1], "end": [608, 25], "kind": "commanddeclaration"}, {"full_name": "StrictMono.isMin_of_apply", "code": "theorem StrictMono.isMin_of_apply (hf : StrictMono f) (ha : IsMin (f a)) : IsMin a", "start": [611, 1], "end": [614, 25], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.isMax_of_apply", "code": "theorem StrictAnti.isMax_of_apply (hf : StrictAnti f) (ha : IsMin (f a)) : IsMax a", "start": [617, 1], "end": [620, 25], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.isMin_of_apply", "code": "theorem StrictAnti.isMin_of_apply (hf : StrictAnti f) (ha : IsMax (f a)) : IsMin a", "start": [623, 1], "end": [626, 25], "kind": "commanddeclaration"}, {"full_name": "StrictMono.ite'", "code": "protected theorem StrictMono.ite' (hf : StrictMono f) (hg : StrictMono g) {p : \u03b1 \u2192 Prop}\n    [DecidablePred p]\n    (hp : \u2200 \u2983x y\u2984, x < y \u2192 p y \u2192 p x) (hfg : \u2200 \u2983x y\u2984, p x \u2192 \u00acp y \u2192 x < y \u2192 f x < g y) :\n    StrictMono fun x \u21a6 if p x then f x else g x", "start": [629, 1], "end": [639, 30], "kind": "commanddeclaration"}, {"full_name": "StrictMono.ite", "code": "protected theorem StrictMono.ite (hf : StrictMono f) (hg : StrictMono g) {p : \u03b1 \u2192 Prop}\n    [DecidablePred p] (hp : \u2200 \u2983x y\u2984, x < y \u2192 p y \u2192 p x) (hfg : \u2200 x, f x \u2264 g x) :\n    StrictMono fun x \u21a6 if p x then f x else g x", "start": [642, 1], "end": [645, 58], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.ite'", "code": "protected theorem StrictAnti.ite' (hf : StrictAnti f) (hg : StrictAnti g) {p : \u03b1 \u2192 Prop}\n    [DecidablePred p]\n    (hp : \u2200 \u2983x y\u2984, x < y \u2192 p y \u2192 p x) (hfg : \u2200 \u2983x y\u2984, p x \u2192 \u00acp y \u2192 x < y \u2192 g y < f x) :\n    StrictAnti fun x \u21a6 if p x then f x else g x", "start": [649, 1], "end": [653, 79], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.ite", "code": "protected theorem StrictAnti.ite (hf : StrictAnti f) (hg : StrictAnti g) {p : \u03b1 \u2192 Prop}\n    [DecidablePred p] (hp : \u2200 \u2983x y\u2984, x < y \u2192 p y \u2192 p x) (hfg : \u2200 x, g x \u2264 f x) :\n    StrictAnti fun x \u21a6 if p x then f x else g x", "start": [656, 1], "end": [659, 58], "kind": "commanddeclaration"}, {"full_name": "Monotone.comp", "code": "protected theorem Monotone.comp (hg : Monotone g) (hf : Monotone f) : Monotone (g \u2218 f)", "start": [671, 1], "end": [672, 24], "kind": "commanddeclaration"}, {"full_name": "Monotone.comp_antitone", "code": "theorem Monotone.comp_antitone (hg : Monotone g) (hf : Antitone f) : Antitone (g \u2218 f)", "start": [675, 1], "end": [676, 24], "kind": "commanddeclaration"}, {"full_name": "Antitone.comp", "code": "protected theorem Antitone.comp (hg : Antitone g) (hf : Antitone f) : Monotone (g \u2218 f)", "start": [679, 1], "end": [680, 24], "kind": "commanddeclaration"}, {"full_name": "Antitone.comp_monotone", "code": "theorem Antitone.comp_monotone (hg : Antitone g) (hf : Monotone f) : Antitone (g \u2218 f)", "start": [683, 1], "end": [684, 24], "kind": "commanddeclaration"}, {"full_name": "Monotone.iterate", "code": "protected theorem Monotone.iterate {f : \u03b1 \u2192 \u03b1} (hf : Monotone f) (n : \u2115) : Monotone f^[n]", "start": [687, 1], "end": [688, 46], "kind": "commanddeclaration"}, {"full_name": "Monotone.comp_monotoneOn", "code": "protected theorem Monotone.comp_monotoneOn (hg : Monotone g) (hf : MonotoneOn f s) :\n    MonotoneOn (g \u2218 f) s", "start": [691, 1], "end": [693, 36], "kind": "commanddeclaration"}, {"full_name": "Monotone.comp_antitoneOn", "code": "theorem Monotone.comp_antitoneOn (hg : Monotone g) (hf : AntitoneOn f s) : AntitoneOn (g \u2218 f) s", "start": [696, 1], "end": [697, 36], "kind": "commanddeclaration"}, {"full_name": "Antitone.comp_antitoneOn", "code": "protected theorem Antitone.comp_antitoneOn (hg : Antitone g) (hf : AntitoneOn f s) :\n    MonotoneOn (g \u2218 f) s", "start": [700, 1], "end": [702, 36], "kind": "commanddeclaration"}, {"full_name": "Antitone.comp_monotoneOn", "code": "theorem Antitone.comp_monotoneOn (hg : Antitone g) (hf : MonotoneOn f s) : AntitoneOn (g \u2218 f) s", "start": [705, 1], "end": [706, 36], "kind": "commanddeclaration"}, {"full_name": "StrictMono.comp", "code": "protected theorem StrictMono.comp (hg : StrictMono g) (hf : StrictMono f) : StrictMono (g \u2218 f)", "start": [709, 1], "end": [710, 24], "kind": "commanddeclaration"}, {"full_name": "StrictMono.comp_strictAnti", "code": "theorem StrictMono.comp_strictAnti (hg : StrictMono g) (hf : StrictAnti f) : StrictAnti (g \u2218 f)", "start": [713, 1], "end": [714, 24], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.comp", "code": "protected theorem StrictAnti.comp (hg : StrictAnti g) (hf : StrictAnti f) : StrictMono (g \u2218 f)", "start": [717, 1], "end": [718, 24], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.comp_strictMono", "code": "theorem StrictAnti.comp_strictMono (hg : StrictAnti g) (hf : StrictMono f) : StrictAnti (g \u2218 f)", "start": [721, 1], "end": [722, 24], "kind": "commanddeclaration"}, {"full_name": "StrictMono.iterate", "code": "protected theorem StrictMono.iterate {f : \u03b1 \u2192 \u03b1} (hf : StrictMono f) (n : \u2115) : StrictMono f^[n]", "start": [725, 1], "end": [726, 48], "kind": "commanddeclaration"}, {"full_name": "StrictMono.comp_strictMonoOn", "code": "protected theorem StrictMono.comp_strictMonoOn (hg : StrictMono g) (hf : StrictMonoOn f s) :\n    StrictMonoOn (g \u2218 f) s", "start": [729, 1], "end": [731, 36], "kind": "commanddeclaration"}, {"full_name": "StrictMono.comp_strictAntiOn", "code": "theorem StrictMono.comp_strictAntiOn (hg : StrictMono g) (hf : StrictAntiOn f s) :\n    StrictAntiOn (g \u2218 f) s", "start": [734, 1], "end": [736, 36], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.comp_strictAntiOn", "code": "protected theorem StrictAnti.comp_strictAntiOn (hg : StrictAnti g) (hf : StrictAntiOn f s) :\n    StrictMonoOn (g \u2218 f) s", "start": [739, 1], "end": [741, 36], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.comp_strictMonoOn", "code": "theorem StrictAnti.comp_strictMonoOn (hg : StrictAnti g) (hf : StrictMonoOn f s) :\n    StrictAntiOn (g \u2218 f) s", "start": [744, 1], "end": [746, 36], "kind": "commanddeclaration"}, {"full_name": "List.foldl_monotone", "code": "theorem foldl_monotone [Preorder \u03b1] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} (H : \u2200 b, Monotone fun a \u21a6 f a b)\n    (l : List \u03b2) : Monotone fun a \u21a6 l.foldl f a", "start": [755, 1], "end": [757, 60], "kind": "commanddeclaration"}, {"full_name": "List.foldr_monotone", "code": "theorem foldr_monotone [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} (H : \u2200 a, Monotone (f a)) (l : List \u03b1) :\n    Monotone fun b \u21a6 l.foldr f b", "start": [760, 1], "end": [761, 83], "kind": "commanddeclaration"}, {"full_name": "List.foldl_strictMono", "code": "theorem foldl_strictMono [Preorder \u03b1] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} (H : \u2200 b, StrictMono fun a \u21a6 f a b)\n    (l : List \u03b2) : StrictMono fun a \u21a6 l.foldl f a", "start": [764, 1], "end": [766, 60], "kind": "commanddeclaration"}, {"full_name": "List.foldr_strictMono", "code": "theorem foldr_strictMono [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} (H : \u2200 a, StrictMono (f a)) (l : List \u03b1) :\n    StrictMono fun b \u21a6 l.foldr f b", "start": [769, 1], "end": [770, 85], "kind": "commanddeclaration"}, {"full_name": "Monotone.reflect_lt", "code": "theorem Monotone.reflect_lt (hf : Monotone f) {a b : \u03b1} (h : f a < f b) : a < b", "start": [790, 1], "end": [791, 41], "kind": "commanddeclaration"}, {"full_name": "Antitone.reflect_lt", "code": "theorem Antitone.reflect_lt (hf : Antitone f) {a b : \u03b1} (h : f a < f b) : b < a", "start": [794, 1], "end": [795, 41], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.reflect_lt", "code": "theorem MonotoneOn.reflect_lt (hf : MonotoneOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s)\n    (h : f a < f b) : a < b", "start": [798, 1], "end": [800, 48], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.reflect_lt", "code": "theorem AntitoneOn.reflect_lt (hf : AntitoneOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s)\n    (h : f a < f b) : b < a", "start": [803, 1], "end": [805, 48], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.le_iff_le", "code": "theorem StrictMonoOn.le_iff_le (hf : StrictMonoOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a \u2264 f b \u2194 a \u2264 b", "start": [808, 1], "end": [811, 74], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.le_iff_le", "code": "theorem StrictAntiOn.le_iff_le (hf : StrictAntiOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a \u2264 f b \u2194 b \u2264 a", "start": [814, 1], "end": [816, 32], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.eq_iff_eq", "code": "theorem StrictMonoOn.eq_iff_eq (hf : StrictMonoOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a = f b \u2194 a = b", "start": [819, 1], "end": [823, 9], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.eq_iff_eq", "code": "theorem StrictAntiOn.eq_iff_eq (hf : StrictAntiOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a = f b \u2194 b = a", "start": [826, 1], "end": [828, 48], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.lt_iff_lt", "code": "theorem StrictMonoOn.lt_iff_lt (hf : StrictMonoOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a < f b \u2194 a < b", "start": [831, 1], "end": [833, 82], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.lt_iff_lt", "code": "theorem StrictAntiOn.lt_iff_lt (hf : StrictAntiOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) :\n    f a < f b \u2194 b < a", "start": [836, 1], "end": [838, 32], "kind": "commanddeclaration"}, {"full_name": "StrictMono.le_iff_le", "code": "theorem StrictMono.le_iff_le (hf : StrictMono f) {a b : \u03b1} : f a \u2264 f b \u2194 a \u2264 b", "start": [841, 1], "end": [842, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.le_iff_le", "code": "theorem StrictAnti.le_iff_le (hf : StrictAnti f) {a b : \u03b1} : f a \u2264 f b \u2194 b \u2264 a", "start": [845, 1], "end": [846, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMono.lt_iff_lt", "code": "theorem StrictMono.lt_iff_lt (hf : StrictMono f) {a b : \u03b1} : f a < f b \u2194 a < b", "start": [849, 1], "end": [850, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.lt_iff_lt", "code": "theorem StrictAnti.lt_iff_lt (hf : StrictAnti f) {a b : \u03b1} : f a < f b \u2194 b < a", "start": [853, 1], "end": [854, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.compares", "code": "protected theorem StrictMonoOn.compares (hf : StrictMonoOn f s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) : \u2200 {o : Ordering}, o.Compares (f a) (f b) \u2194 o.Compares a b", "start": [857, 1], "end": [862, 38], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.compares", "code": "protected theorem StrictAntiOn.compares (hf : StrictAntiOn f s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) {o : Ordering} : o.Compares (f a) (f b) \u2194 o.Compares b a", "start": [865, 1], "end": [867, 63], "kind": "commanddeclaration"}, {"full_name": "StrictMono.compares", "code": "protected theorem StrictMono.compares (hf : StrictMono f) {a b : \u03b1} {o : Ordering} :\n    o.Compares (f a) (f b) \u2194 o.Compares a b", "start": [870, 1], "end": [872, 54], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.compares", "code": "protected theorem StrictAnti.compares (hf : StrictAnti f) {a b : \u03b1} {o : Ordering} :\n    o.Compares (f a) (f b) \u2194 o.Compares b a", "start": [875, 1], "end": [877, 54], "kind": "commanddeclaration"}, {"full_name": "StrictMono.injective", "code": "theorem StrictMono.injective (hf : StrictMono f) : Injective f", "start": [880, 1], "end": [881, 56], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.injective", "code": "theorem StrictAnti.injective (hf : StrictAnti f) : Injective f", "start": [884, 1], "end": [885, 61], "kind": "commanddeclaration"}, {"full_name": "StrictMono.maximal_of_maximal_image", "code": "theorem StrictMono.maximal_of_maximal_image (hf : StrictMono f) {a} (hmax : \u2200 p, p \u2264 f a) (x : \u03b1) :\n    x \u2264 a", "start": [888, 1], "end": [890, 31], "kind": "commanddeclaration"}, {"full_name": "StrictMono.minimal_of_minimal_image", "code": "theorem StrictMono.minimal_of_minimal_image (hf : StrictMono f) {a} (hmin : \u2200 p, f a \u2264 p) (x : \u03b1) :\n    a \u2264 x", "start": [893, 1], "end": [895, 31], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.minimal_of_maximal_image", "code": "theorem StrictAnti.minimal_of_maximal_image (hf : StrictAnti f) {a} (hmax : \u2200 p, p \u2264 f a) (x : \u03b1) :\n    a \u2264 x", "start": [898, 1], "end": [900, 31], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.maximal_of_minimal_image", "code": "theorem StrictAnti.maximal_of_minimal_image (hf : StrictAnti f) {a} (hmin : \u2200 p, f a \u2264 p) (x : \u03b1) :\n    x \u2264 a", "start": [903, 1], "end": [905, 31], "kind": "commanddeclaration"}, {"full_name": "Monotone.strictMono_iff_injective", "code": "theorem Monotone.strictMono_iff_injective (hf : Monotone f) : StrictMono f \u2194 Injective f", "start": [914, 1], "end": [915, 52], "kind": "commanddeclaration"}, {"full_name": "Antitone.strictAnti_iff_injective", "code": "theorem Antitone.strictAnti_iff_injective (hf : Antitone f) : StrictAnti f \u2194 Injective f", "start": [918, 1], "end": [919, 52], "kind": "commanddeclaration"}, {"full_name": "not_monotone_not_antitone_iff_exists_le_le", "code": "lemma not_monotone_not_antitone_iff_exists_le_le :\n    \u00ac Monotone f \u2227 \u00ac Antitone f \u2194 \u2203 a b c, a \u2264 b \u2227 b \u2264 c \u2227\n    (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c) := by\n  simp_rw [Monotone, Antitone, not_forall, not_le]\n  refine' Iff.symm \u27e8_, _\u27e9\n  { rintro \u27e8a, b, c, hab, hbc, \u27e8hfab, hfcb\u27e9 | \u27e8hfba, hfbc\u27e9\u27e9\n    exacts [\u27e8\u27e8_, _, hbc, hfcb\u27e9, _, _, hab, hfab\u27e9, \u27e8\u27e8_, _, hab, hfba\u27e9, _, _, hbc, hfbc\u27e9] }\n  rintro \u27e8\u27e8a, b, hab, hfba\u27e9, c, d, hcd, hfcd\u27e9\n  obtain hda | had := le_total d a\n  { obtain hfad | hfda := le_total (f a) (f d)\n    { exact \u27e8c, d, b, hcd, hda.trans hab, Or.inl \u27e8hfcd, hfba.trans_le hfad\u27e9\u27e9 }\n    { exact \u27e8c, a, b, hcd.trans hda, hab, Or.inl \u27e8hfcd.trans_le hfda, hfba\u27e9\u27e9 } }\n  obtain hac | hca := le_total a c\n  { obtain hfdb | hfbd := le_or_lt (f d) (f b)\n    { exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfcd.trans $ hfdb.trans_lt hfba, hfcd\u27e9\u27e9 }\n    obtain hfca | hfac := lt_or_le (f c) (f a)\n    { exact \u27e8a, c, d, hac, hcd, Or.inr \u27e8hfca, hfcd\u27e9\u27e9 }\n    obtain hbd | hdb := le_total b d\n    { exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9 }\n    { exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9 } }\n  { obtain hfdb | hfbd := le_or_lt (f d) (f b)\n    { exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfcd.trans $ hfdb.trans_lt hfba, hfba\u27e9\u27e9 }\n    obtain hfca | hfac := lt_or_le (f c) (f a)\n    { exact \u27e8c, a, b, hca, hab, Or.inl \u27e8hfca, hfba\u27e9\u27e9 }\n    obtain hbd | hdb := le_total b d\n    { exact \u27e8a, b, d, hab, hbd, Or.inr \u27e8hfba, hfbd\u27e9\u27e9 }\n    { exact \u27e8a, d, b, had, hdb, Or.inl \u27e8hfac.trans_lt hfcd, hfbd\u27e9\u27e9 } }", "start": [926, 1], "end": [954, 71], "kind": "mathlibtacticlemma"}, {"full_name": "not_monotone_not_antitone_iff_exists_lt_lt", "code": "lemma not_monotone_not_antitone_iff_exists_lt_lt :\n    \u00ac Monotone f \u2227 \u00ac Antitone f \u2194 \u2203 a b c, a < b \u2227 b < c \u2227\n    (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c) := by\n  simp_rw [not_monotone_not_antitone_iff_exists_le_le, \u2190and_assoc]\n  refine' exists\u2083_congr (fun a b c \u21a6 and_congr_left $\n    fun h \u21a6 (Ne.le_iff_lt _).and $ Ne.le_iff_lt _) <;>\n  (rintro rfl; simp at h)", "start": [957, 1], "end": [965, 26], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMonoOn.cmp_map_eq", "code": "theorem StrictMonoOn.cmp_map_eq (hf : StrictMonoOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    cmp (f x) (f y) = cmp x y", "start": [975, 1], "end": [977, 52], "kind": "commanddeclaration"}, {"full_name": "StrictMono.cmp_map_eq", "code": "theorem StrictMono.cmp_map_eq (hf : StrictMono f) (x y : \u03b1) : cmp (f x) (f y) = cmp x y", "start": [980, 1], "end": [981, 56], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.cmp_map_eq", "code": "theorem StrictAntiOn.cmp_map_eq (hf : StrictAntiOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    cmp (f x) (f y) = cmp y x", "start": [984, 1], "end": [986, 33], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.cmp_map_eq", "code": "theorem StrictAnti.cmp_map_eq (hf : StrictAnti f) (x y : \u03b1) : cmp (f x) (f y) = cmp y x", "start": [989, 1], "end": [990, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.rel_of_forall_rel_succ_of_le_of_lt", "code": "theorem Nat.rel_of_forall_rel_succ_of_le_of_lt (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrans \u03b2 r] {f : \u2115 \u2192 \u03b2} {a : \u2115}\n    (h : \u2200 n, a \u2264 n \u2192 r (f n) (f (n + 1))) \u2983b c : \u2115\u2984 (hab : a \u2264 b) (hbc : b < c) :\n    r (f b) (f c)", "start": [1002, 1], "end": [1006, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.rel_of_forall_rel_succ_of_le_of_le", "code": "theorem Nat.rel_of_forall_rel_succ_of_le_of_le (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b2 r] [IsTrans \u03b2 r]\n    {f : \u2115 \u2192 \u03b2} {a : \u2115} (h : \u2200 n, a \u2264 n \u2192 r (f n) (f (n + 1)))\n    \u2983b c : \u2115\u2984 (hab : a \u2264 b) (hbc : b \u2264 c) : r (f b) (f c)", "start": [1009, 1], "end": [1012, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.rel_of_forall_rel_succ_of_lt", "code": "theorem Nat.rel_of_forall_rel_succ_of_lt (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrans \u03b2 r] {f : \u2115 \u2192 \u03b2}\n    (h : \u2200 n, r (f n) (f (n + 1))) \u2983a b : \u2115\u2984 (hab : a < b) : r (f a) (f b)", "start": [1015, 1], "end": [1017, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.rel_of_forall_rel_succ_of_le", "code": "theorem Nat.rel_of_forall_rel_succ_of_le (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b2 r] [IsTrans \u03b2 r] {f : \u2115 \u2192 \u03b2}\n    (h : \u2200 n, r (f n) (f (n + 1))) \u2983a b : \u2115\u2984 (hab : a \u2264 b) : r (f a) (f b)", "start": [1020, 1], "end": [1022, 70], "kind": "commanddeclaration"}, {"full_name": "monotone_nat_of_le_succ", "code": "theorem monotone_nat_of_le_succ {f : \u2115 \u2192 \u03b1} (hf : \u2200 n, f n \u2264 f (n + 1)) : Monotone f", "start": [1025, 1], "end": [1026, 46], "kind": "commanddeclaration"}, {"full_name": "antitone_nat_of_succ_le", "code": "theorem antitone_nat_of_succ_le {f : \u2115 \u2192 \u03b1} (hf : \u2200 n, f (n + 1) \u2264 f n) : Antitone f", "start": [1029, 1], "end": [1030, 38], "kind": "commanddeclaration"}, {"full_name": "strictMono_nat_of_lt_succ", "code": "theorem strictMono_nat_of_lt_succ {f : \u2115 \u2192 \u03b1} (hf : \u2200 n, f n < f (n + 1)) : StrictMono f", "start": [1033, 1], "end": [1034, 46], "kind": "commanddeclaration"}, {"full_name": "strictAnti_nat_of_succ_lt", "code": "theorem strictAnti_nat_of_succ_lt {f : \u2115 \u2192 \u03b1} (hf : \u2200 n, f (n + 1) < f n) : StrictAnti f", "start": [1037, 1], "end": [1038, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_strictMono'", "code": "theorem exists_strictMono' [NoMaxOrder \u03b1] (a : \u03b1) : \u2203 f : \u2115 \u2192 \u03b1, StrictMono f \u2227 f 0 = a", "start": [1043, 1], "end": [1047, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_strictAnti'", "code": "theorem exists_strictAnti' [NoMinOrder \u03b1] (a : \u03b1) : \u2203 f : \u2115 \u2192 \u03b1, StrictAnti f \u2227 f 0 = a", "start": [1050, 1], "end": [1053, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_strictMono", "code": "theorem exists_strictMono [Nonempty \u03b1] [NoMaxOrder \u03b1] : \u2203 f : \u2115 \u2192 \u03b1, StrictMono f", "start": [1058, 1], "end": [1063, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_strictAnti", "code": "theorem exists_strictAnti [Nonempty \u03b1] [NoMinOrder \u03b1] : \u2203 f : \u2115 \u2192 \u03b1, StrictAnti f", "start": [1066, 1], "end": [1069, 24], "kind": "commanddeclaration"}, {"full_name": "Int.rel_of_forall_rel_succ_of_lt", "code": "theorem Int.rel_of_forall_rel_succ_of_lt (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrans \u03b2 r] {f : \u2124 \u2192 \u03b2}\n    (h : \u2200 n, r (f n) (f (n + 1))) \u2983a b : \u2124\u2984 (hab : a < b) : r (f a) (f b)", "start": [1074, 1], "end": [1082, 33], "kind": "commanddeclaration"}, {"full_name": "Int.rel_of_forall_rel_succ_of_le", "code": "theorem Int.rel_of_forall_rel_succ_of_le (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b2 r] [IsTrans \u03b2 r] {f : \u2124 \u2192 \u03b2}\n    (h : \u2200 n, r (f n) (f (n + 1))) \u2983a b : \u2124\u2984 (hab : a \u2264 b) : r (f a) (f b)", "start": [1085, 1], "end": [1087, 90], "kind": "commanddeclaration"}, {"full_name": "monotone_int_of_le_succ", "code": "theorem monotone_int_of_le_succ {f : \u2124 \u2192 \u03b1} (hf : \u2200 n, f n \u2264 f (n + 1)) : Monotone f", "start": [1090, 1], "end": [1091, 46], "kind": "commanddeclaration"}, {"full_name": "antitone_int_of_succ_le", "code": "theorem antitone_int_of_succ_le {f : \u2124 \u2192 \u03b1} (hf : \u2200 n, f (n + 1) \u2264 f n) : Antitone f", "start": [1094, 1], "end": [1095, 46], "kind": "commanddeclaration"}, {"full_name": "strictMono_int_of_lt_succ", "code": "theorem strictMono_int_of_lt_succ {f : \u2124 \u2192 \u03b1} (hf : \u2200 n, f n < f (n + 1)) : StrictMono f", "start": [1098, 1], "end": [1099, 46], "kind": "commanddeclaration"}, {"full_name": "strictAnti_int_of_succ_lt", "code": "theorem strictAnti_int_of_succ_lt {f : \u2124 \u2192 \u03b1} (hf : \u2200 n, f (n + 1) < f n) : StrictAnti f", "start": [1102, 1], "end": [1103, 46], "kind": "commanddeclaration"}, {"full_name": "Int.exists_strictMono", "code": "theorem exists_strictMono : \u2203 f : \u2124 \u2192 \u03b1, StrictMono f", "start": [1110, 1], "end": [1122, 34], "kind": "commanddeclaration"}, {"full_name": "Int.exists_strictAnti", "code": "theorem exists_strictAnti : \u2203 f : \u2124 \u2192 \u03b1, StrictAnti f", "start": [1125, 1], "end": [1128, 24], "kind": "commanddeclaration"}, {"full_name": "Monotone.ne_of_lt_of_lt_nat", "code": "theorem Monotone.ne_of_lt_of_lt_nat {f : \u2115 \u2192 \u03b1} (hf : Monotone f) (n : \u2115) {x : \u03b1} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : \u2115) : f a \u2260 x", "start": [1134, 1], "end": [1139, 74], "kind": "commanddeclaration"}, {"full_name": "Antitone.ne_of_lt_of_lt_nat", "code": "theorem Antitone.ne_of_lt_of_lt_nat {f : \u2115 \u2192 \u03b1} (hf : Antitone f) (n : \u2115) {x : \u03b1}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : \u2115) : f a \u2260 x", "start": [1142, 1], "end": [1147, 74], "kind": "commanddeclaration"}, {"full_name": "Monotone.ne_of_lt_of_lt_int", "code": "theorem Monotone.ne_of_lt_of_lt_int {f : \u2124 \u2192 \u03b1} (hf : Monotone f) (n : \u2124) {x : \u03b1} (h1 : f n < x)\n    (h2 : x < f (n + 1)) (a : \u2124) : f a \u2260 x", "start": [1150, 1], "end": [1155, 77], "kind": "commanddeclaration"}, {"full_name": "Antitone.ne_of_lt_of_lt_int", "code": "theorem Antitone.ne_of_lt_of_lt_int {f : \u2124 \u2192 \u03b1} (hf : Antitone f) (n : \u2124) {x : \u03b1}\n    (h1 : f (n + 1) < x) (h2 : x < f n) (a : \u2124) : f a \u2260 x", "start": [1158, 1], "end": [1163, 77], "kind": "commanddeclaration"}, {"full_name": "StrictMono.id_le", "code": "theorem StrictMono.id_le {\u03c6 : \u2115 \u2192 \u2115} (h : StrictMono \u03c6) : \u2200 n, n \u2264 \u03c6 n", "start": [1166, 1], "end": [1167, 100], "kind": "commanddeclaration"}, {"full_name": "Subtype.mono_coe", "code": "theorem Subtype.mono_coe [Preorder \u03b1] (t : Set \u03b1) : Monotone ((\u2191) : Subtype t \u2192 \u03b1)", "start": [1172, 1], "end": [1173, 15], "kind": "commanddeclaration"}, {"full_name": "Subtype.strictMono_coe", "code": "theorem Subtype.strictMono_coe [Preorder \u03b1] (t : Set \u03b1) :\n    StrictMono ((\u2191) : Subtype t \u2192 \u03b1)", "start": [1176, 1], "end": [1178, 15], "kind": "commanddeclaration"}, {"full_name": "monotone_fst", "code": "theorem monotone_fst : Monotone (@Prod.fst \u03b1 \u03b2)", "start": [1185, 1], "end": [1185, 70], "kind": "commanddeclaration"}, {"full_name": "monotone_snd", "code": "theorem monotone_snd : Monotone (@Prod.snd \u03b1 \u03b2)", "start": [1188, 1], "end": [1188, 71], "kind": "commanddeclaration"}, {"full_name": "Monotone.prod_map", "code": "theorem Monotone.prod_map (hf : Monotone f) (hg : Monotone g) : Monotone (Prod.map f g)", "start": [1191, 1], "end": [1192, 31], "kind": "commanddeclaration"}, {"full_name": "Antitone.prod_map", "code": "theorem Antitone.prod_map (hf : Antitone f) (hg : Antitone g) : Antitone (Prod.map f g)", "start": [1195, 1], "end": [1196, 31], "kind": "commanddeclaration"}, {"full_name": "StrictMono.prod_map", "code": "theorem StrictMono.prod_map (hf : StrictMono f) (hg : StrictMono g) : StrictMono (Prod.map f g)", "start": [1205, 1], "end": [1208, 81], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.prod_map", "code": "theorem StrictAnti.prod_map (hf : StrictAnti f) (hg : StrictAnti g) : StrictAnti (Prod.map f g)", "start": [1211, 1], "end": [1214, 81], "kind": "commanddeclaration"}, {"full_name": "Function.update_mono", "code": "theorem update_mono : Monotone (update f i)", "start": [1226, 1], "end": [1226, 82], "kind": "commanddeclaration"}, {"full_name": "Function.update_strictMono", "code": "theorem update_strictMono : StrictMono (update f i)", "start": [1229, 1], "end": [1229, 89], "kind": "commanddeclaration"}, {"full_name": "Function.const_mono", "code": "theorem const_mono : Monotone (const \u03b2 : \u03b1 \u2192 \u03b2 \u2192 \u03b1)", "start": [1232, 1], "end": [1232, 71], "kind": "commanddeclaration"}, {"full_name": "Function.const_strictMono", "code": "theorem const_strictMono [Nonempty \u03b2] : StrictMono (const \u03b2 : \u03b1 \u2192 \u03b2 \u2192 \u03b1)", "start": [1235, 1], "end": [1236, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/GCongr/Core.lean", "imports": ["Mathlib/Tactic/GCongr/ForwardAttr.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Init/Order/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Backtrack.lean"], "premises": [{"full_name": "Mathlib.Tactic.GCongr.GCongrLemma", "code": "structure GCongrLemma where\n  declName : Name\n  mainSubgoals : Array (Nat \u00d7 Nat)\n  varyingArgs : Array Bool\n  deriving Inhabited, Repr", "start": [127, 1], "end": [132, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.gcongr", "code": "partial def _root_.Lean.MVarId.gcongr\n    (g : MVarId) (template : Option Expr) (names : List (TSyntax ``binderIdent))\n    (side_goal_discharger : MVarId \u2192 MetaM Unit)\n    (main_goal_discharger : MVarId \u2192 MetaM Unit := fun g => g.assumption) :\n    MetaM (Bool \u00d7 List (TSyntax ``binderIdent) \u00d7 Array MVarId) := g.withContext do\n  withTraceNode `Meta.gcongr (fun _ => return m!\"gcongr: \u22a2 {\u2190 g.getType}\") do\n  match template with\n  | none =>\n    try main_goal_discharger g; return (true, names, #[])\n    catch _ => pure ()\n  | some tpl =>\n    if let .mvar mvarId := tpl.getAppFn then\n      if let .syntheticOpaque \u2190 mvarId.getKind then\n        try main_goal_discharger g; return (true, names, #[])\n        catch _ => return (false, names, #[g])\n    let .app (.app rel lhs) rhs \u2190 withReducible g.getType'\n    | throwError \"gcongr failed, not a relation\"\n  let some relName := rel.getAppFn.constName?\n    | throwError \"gcongr failed, relation head {rel} is not a constant\"\n  let (some lhsHead, lhsArgs) := lhs.withApp fun e a => (e.constName?, a)\n    | if template.isNone then return (false, names, #[g])\n      throwError \"gcongr failed, {lhs} is not a constant\"\n  let (some rhsHead, rhsArgs) := rhs.withApp fun e a => (e.constName?, a)\n    | if template.isNone then return (false, names, #[g])\n      throwError \"gcongr failed, {rhs} is not a constant\"\n  let tplArgs \u2190 if let some tpl := template then\n    let (some tplHead, tplArgs) := tpl.withApp fun e a => (e.constName?, a)\n      | throwError \"gcongr failed, {tpl} is not a constant\"\n    unless tplHead == lhsHead && tplArgs.size == rhsArgs.size do\n      throwError \"expected {tplHead}, got {lhsHead}\\n{lhs}\"\n    unless tplHead == rhsHead && tplArgs.size == rhsArgs.size do\n      throwError \"expected {tplHead}, got {rhsHead}\\n{rhs}\"\n    tplArgs.mapM fun tpl => do\n      let mctx \u2190 getMCtx\n      let hasMVar := tpl.findMVar? fun mvarId =>\n        if let some mdecl := mctx.findDecl? mvarId then\n          mdecl.kind matches .syntheticOpaque\n        else\n          false\n      pure (some tpl, hasMVar.isSome)\n  else\n    unless lhsHead == rhsHead && lhsArgs.size == rhsArgs.size do\n      return (false, names, #[g])\n    (lhsArgs.zip rhsArgs).mapM fun (lhsArg, rhsArg) =>\n      return (none, !(\u2190 isDefEq lhsArg rhsArg))\n  let varyingArgs := tplArgs.map (\u00b7.2)\n  if varyingArgs.all not then\n    throwError \"try rfl\"\n  let s \u2190 saveState\n  let mut ex? := none\n  for lem in (gcongrExt.getState (\u2190 getEnv)).findD (relName, lhsHead, varyingArgs) #[] do\n    let gs \u2190 try\n      Except.ok <$> g.apply (\u2190 mkConstWithFreshMVarLevels lem.declName)\n    catch e => pure (Except.error e)\n    match gs with\n    | .error e =>\n      ex? := ex? <|> (some (\u2190 saveState, e))\n      s.restore\n    | .ok gs =>\n      let some e \u2190 getExprMVarAssignment? g | panic! \"unassigned?\"\n      let args := e.getAppArgs\n      let mut subgoals := #[]\n      let mut names := names\n      for (i, j) in lem.mainSubgoals do\n        let some (.mvar mvarId) := args[i]? | panic! \"what kind of lemma is this?\"\n        let (names2, _vs, mvarId) \u2190 mvarId.introsWithBinderIdents names\n        let tpl \u2190 tplArgs[j]!.1.mapM fun e => do\n          let (_vs, _, e) \u2190 lambdaMetaTelescope e\n          pure e\n        let (_, names2, subgoals2) :=\n          \u2190 mvarId.gcongr tpl names2 side_goal_discharger main_goal_discharger\n        (names, subgoals) := (names2, subgoals ++ subgoals2)\n      let mut out := #[]\n      for g in gs do\n        if !(\u2190 g.isAssigned) && !subgoals.contains g then\n          try side_goal_discharger g\n          catch _ => out := out.push g\n      return (true, names, out ++ subgoals)\n  if template.isNone then\n    return (false, names, #[g])\n  let some (sErr, e) := ex?\n    | throwError \"gcongr failed, no @[gcongr] lemma applies for the template portion {\"\"\n        }{template} and the relation {rel}\"\n  sErr.restore\n  throw e", "start": [211, 1], "end": [350, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GCongr.exactRefl", "code": "@[gcongr_forward] def exactRefl : ForwardExt where\n  eval h goal := do\n    let m \u2190 mkFreshExprMVar none\n    goal.assignIfDefeq (\u2190 mkAppOptM ``Eq.subst #[h, m])\n    goal.applyRfl", "start": [354, 1], "end": [359, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GCongr.exactLeOfLt", "code": "@[gcongr_forward] def exactLeOfLt : ForwardExt where\n  eval h goal := do goal.assignIfDefeq (\u2190 mkAppM ``le_of_lt #[h])", "start": [361, 1], "end": [363, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GCongr.symmExact", "code": "@[gcongr_forward] def symmExact : ForwardExt where\n  eval h goal := do (\u2190 goal.applySymm).assignIfDefeq h", "start": [365, 1], "end": [367, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GCongr.exact", "code": "@[gcongr_forward] def exact : ForwardExt where\n  eval e m := m.assignIfDefeq e", "start": [369, 1], "end": [370, 32], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.gcongrForward", "code": "def _root_.Lean.MVarId.gcongrForward (hs : Array Expr) (g : MVarId) : MetaM Unit :=\n  withReducible do\n    let s \u2190 saveState\n    withTraceNode `Meta.gcongr (fun _ => return m!\"gcongr_forward: \u22a2 {\u2190 g.getType}\") do\n    let tacs := (forwardExt.getState (\u2190 getEnv)).2\n    for h in hs do\n      try\n        tacs.firstM fun (n, tac) =>\n          withTraceNode `Meta.gcongr (return m!\"{\u00b7.emoji} trying {n} on {h} : {\u2190 inferType h}\") do\n            tac.eval h g\n        return\n      catch _ => s.restore\n    throwError \"gcongr_forward failed\"", "start": [372, 1], "end": [388, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bool/Basic.lean", "imports": ["Mathlib/Init/Data/Bool/Lemmas.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Init/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bool.decide_True", "code": "theorem decide_True {h} : @decide True h = true", "start": [27, 1], "end": [28, 28], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_False", "code": "theorem decide_False {h} : @decide False h = false", "start": [31, 1], "end": [32, 21], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_coe", "code": "@[simp]\ntheorem decide_coe (b : Bool) {h} : @decide b h = b", "start": [35, 1], "end": [39, 31], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_decide", "code": "theorem coe_decide (p : Prop) [d : Decidable p] : decide p \u2194 p", "start": [42, 1], "end": [45, 70], "kind": "commanddeclaration"}, {"full_name": "Bool.of_decide_iff", "code": "theorem of_decide_iff {p : Prop} [Decidable p] : decide p \u2194 p", "start": [48, 1], "end": [49, 15], "kind": "commanddeclaration"}, {"full_name": "Bool.true_eq_decide_iff", "code": "@[simp]\ntheorem true_eq_decide_iff {p : Prop} [Decidable p] : true = decide p \u2194 p", "start": [52, 1], "end": [54, 30], "kind": "commanddeclaration"}, {"full_name": "Bool.false_eq_decide_iff", "code": "@[simp]\ntheorem false_eq_decide_iff {p : Prop} [Decidable p] : false = decide p \u2194 \u00acp", "start": [57, 1], "end": [59, 37], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_not", "code": "theorem decide_not (p : Prop) [Decidable p] : (decide \u00acp) = !(decide p)", "start": [62, 1], "end": [63, 26], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_and", "code": "@[simp]\ntheorem decide_and (p q : Prop) [Decidable p] [Decidable q] : decide (p \u2227 q) = (p && q)", "start": [66, 1], "end": [68, 41], "kind": "commanddeclaration"}, {"full_name": "Bool.decide_or", "code": "@[simp]\ntheorem decide_or (p q : Prop) [Decidable p] [Decidable q] : decide (p \u2228 q) = (p || q)", "start": [71, 1], "end": [73, 41], "kind": "commanddeclaration"}, {"full_name": "Bool.not_false'", "code": "theorem not_false' : \u00acfalse", "start": [78, 1], "end": [78, 36], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_iff_eq_true_iff", "code": "theorem eq_iff_eq_true_iff {a b : Bool} : a = b \u2194 ((a = true) \u2194 (b = true))", "start": [82, 1], "end": [83, 31], "kind": "commanddeclaration"}, {"full_name": "Bool.beq_eq_decide_eq", "code": "theorem beq_eq_decide_eq [DecidableEq \u03b1]\n    (a b : \u03b1) : (a == b) = decide (a = b)", "start": [86, 1], "end": [87, 49], "kind": "commanddeclaration"}, {"full_name": "Bool.beq_comm", "code": "theorem beq_comm [BEq \u03b1] [LawfulBEq \u03b1] {a b : \u03b1} : (a == b) = (b == a)", "start": [90, 1], "end": [91, 46], "kind": "commanddeclaration"}, {"full_name": "Bool.default_bool", "code": "@[simp]\ntheorem default_bool : default = false", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Bool.dichotomy", "code": "theorem dichotomy (b : Bool) : b = false \u2228 b = true", "start": [98, 1], "end": [98, 75], "kind": "commanddeclaration"}, {"full_name": "Bool.forall_bool", "code": "@[simp]\ntheorem forall_bool {p : Bool \u2192 Prop} : (\u2200 b, p b) \u2194 p false \u2227 p true", "start": [101, 1], "end": [103, 68], "kind": "commanddeclaration"}, {"full_name": "Bool.exists_bool", "code": "@[simp]\ntheorem exists_bool {p : Bool \u2192 Prop} : (\u2203 b, p b) \u2194 p false \u2228 p true", "start": [106, 1], "end": [111, 23], "kind": "commanddeclaration"}, {"full_name": "Bool.decidableForallBool", "code": "instance decidableForallBool {p : Bool \u2192 Prop} [\u2200 b, Decidable (p b)] : Decidable (\u2200 b, p b) :=\n  decidable_of_decidable_of_iff forall_bool.symm", "start": [114, 1], "end": [116, 49], "kind": "commanddeclaration"}, {"full_name": "Bool.decidableExistsBool", "code": "instance decidableExistsBool {p : Bool \u2192 Prop} [\u2200 b, Decidable (p b)] : Decidable (\u2203 b, p b) :=\n  decidable_of_decidable_of_iff exists_bool.symm", "start": [119, 1], "end": [121, 49], "kind": "commanddeclaration"}, {"full_name": "Bool.cond_eq_ite", "code": "theorem cond_eq_ite {\u03b1} (b : Bool) (t e : \u03b1) : cond b t e = if b then t else e", "start": [124, 1], "end": [125, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.cond_decide", "code": "@[simp]\ntheorem cond_decide {\u03b1} (p : Prop) [Decidable p] (t e : \u03b1) :\n    cond (decide p) t e = if p then t else e", "start": [128, 1], "end": [131, 26], "kind": "commanddeclaration"}, {"full_name": "Bool.cond_not", "code": "@[simp]\ntheorem cond_not {\u03b1} (b : Bool) (t e : \u03b1) : cond (!b) t e = cond b e t", "start": [134, 1], "end": [135, 93], "kind": "commanddeclaration"}, {"full_name": "Bool.not_ne_id", "code": "theorem not_ne_id : not \u2260 id", "start": [138, 1], "end": [138, 73], "kind": "commanddeclaration"}, {"full_name": "Bool.coe_bool_iff", "code": "theorem coe_bool_iff : \u2200 {a b : Bool}, (a \u2194 b) \u2194 a = b", "start": [141, 1], "end": [141, 68], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_true_of_ne_false", "code": "theorem eq_true_of_ne_false : \u2200 {a : Bool}, a \u2260 false \u2192 a = true", "start": [144, 1], "end": [144, 78], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_of_ne_true", "code": "theorem eq_false_of_ne_true : \u2200 {a : Bool}, a \u2260 true \u2192 a = false", "start": [147, 1], "end": [147, 78], "kind": "commanddeclaration"}, {"full_name": "Bool.or_comm", "code": "theorem or_comm : \u2200 a b, (a || b) = (b || a)", "start": [150, 1], "end": [150, 58], "kind": "commanddeclaration"}, {"full_name": "Bool.or_left_comm", "code": "theorem or_left_comm : \u2200 a b c, (a || (b || c)) = (b || (a || c))", "start": [155, 1], "end": [155, 79], "kind": "commanddeclaration"}, {"full_name": "Bool.or_inl", "code": "theorem or_inl {a b : Bool} (H : a) : a || b", "start": [158, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.or_inr", "code": "theorem or_inr {a b : Bool} (H : b) : a || b", "start": [161, 1], "end": [161, 72], "kind": "commanddeclaration"}, {"full_name": "Bool.and_comm", "code": "theorem and_comm : \u2200 a b, (a && b) = (b && a)", "start": [164, 1], "end": [164, 59], "kind": "commanddeclaration"}, {"full_name": "Bool.and_left_comm", "code": "theorem and_left_comm : \u2200 a b c, (a && (b && c)) = (b && (a && c))", "start": [169, 1], "end": [169, 80], "kind": "commanddeclaration"}, {"full_name": "Bool.and_elim_left", "code": "theorem and_elim_left : \u2200 {a b : Bool}, a && b \u2192 a", "start": [172, 1], "end": [172, 64], "kind": "commanddeclaration"}, {"full_name": "Bool.and_intro", "code": "theorem and_intro : \u2200 {a b : Bool}, a \u2192 b \u2192 a && b", "start": [175, 1], "end": [175, 64], "kind": "commanddeclaration"}, {"full_name": "Bool.and_elim_right", "code": "theorem and_elim_right : \u2200 {a b : Bool}, a && b \u2192 b", "start": [178, 1], "end": [178, 65], "kind": "commanddeclaration"}, {"full_name": "Bool.and_or_distrib_left", "code": "theorem and_or_distrib_left (a b c : Bool) : (a && (b || c)) = (a && b || a && c)", "start": [181, 1], "end": [182, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.and_or_distrib_right", "code": "theorem and_or_distrib_right (a b c : Bool) : ((a || b) && c) = (a && c || b && c)", "start": [185, 1], "end": [186, 43], "kind": "commanddeclaration"}, {"full_name": "Bool.or_and_distrib_left", "code": "theorem or_and_distrib_left (a b c : Bool) : (a || b && c) = ((a || b) && (a || c))", "start": [189, 1], "end": [190, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.or_and_distrib_right", "code": "theorem or_and_distrib_right (a b c : Bool) : (a && b || c) = ((a || c) && (b || c))", "start": [193, 1], "end": [194, 43], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_not_iff", "code": "lemma eq_not_iff : \u2200 {a b : Bool}, a = !b \u2194 a \u2260 b := by decide", "start": [200, 1], "end": [200, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.not_eq_iff", "code": "lemma not_eq_iff : \u2200 {a b : Bool}, !a = b \u2194 a \u2260 b := by decide", "start": [203, 1], "end": [203, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.not_eq_not", "code": "@[simp]\ntheorem not_eq_not : \u2200 {a b : Bool}, \u00aca = !b \u2194 a = b", "start": [209, 1], "end": [210, 66], "kind": "commanddeclaration"}, {"full_name": "Bool.not_not_eq", "code": "@[simp]\ntheorem not_not_eq : \u2200 {a b : Bool}, \u00ac(!a) = b \u2194 a = b", "start": [214, 1], "end": [215, 68], "kind": "commanddeclaration"}, {"full_name": "Bool.ne_not", "code": "theorem ne_not {a b : Bool} : a \u2260 !b \u2194 a = b", "start": [218, 1], "end": [219, 13], "kind": "commanddeclaration"}, {"full_name": "Bool.not_ne", "code": "theorem not_ne : \u2200 {a b : Bool}, (!a) \u2260 b \u2194 a = b", "start": [222, 1], "end": [222, 64], "kind": "commanddeclaration"}, {"full_name": "Bool.not_ne_self", "code": "lemma not_ne_self : \u2200 b : Bool, (!b) \u2260 b := by decide", "start": [225, 1], "end": [225, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.self_ne_not", "code": "lemma self_ne_not : \u2200 b : Bool, b \u2260 !b := by decide", "start": [228, 1], "end": [228, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.eq_or_eq_not", "code": "lemma eq_or_eq_not : \u2200 a b, a = b \u2228 a = !b := by decide", "start": [231, 1], "end": [231, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Bool.not_iff_not", "code": "theorem not_iff_not : \u2200 {b : Bool}, !b \u2194 \u00acb", "start": [235, 1], "end": [235, 55], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_true_of_not_eq_false'", "code": "theorem eq_true_of_not_eq_false' {a : Bool} : !a = false \u2192 a = true", "start": [238, 1], "end": [239, 21], "kind": "commanddeclaration"}, {"full_name": "Bool.eq_false_of_not_eq_true'", "code": "theorem eq_false_of_not_eq_true' {a : Bool} : !a = true \u2192 a = false", "start": [242, 1], "end": [243, 21], "kind": "commanddeclaration"}, {"full_name": "Bool.and_not_self", "code": "@[simp]\ntheorem and_not_self : \u2200 x, (x && !x) = false", "start": [246, 1], "end": [247, 59], "kind": "commanddeclaration"}, {"full_name": "Bool.not_and_self", "code": "@[simp]\ntheorem not_and_self : \u2200 x, (!x && x) = false", "start": [250, 1], "end": [251, 59], "kind": "commanddeclaration"}, {"full_name": "Bool.or_not_self", "code": "@[simp]\ntheorem or_not_self : \u2200 x, (x || !x) = true", "start": [254, 1], "end": [255, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.not_or_self", "code": "@[simp]\ntheorem not_or_self : \u2200 x, (!x || x) = true", "start": [258, 1], "end": [259, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.bne_eq_xor", "code": "theorem bne_eq_xor : bne = xor", "start": [262, 1], "end": [262, 68], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_comm", "code": "theorem xor_comm : \u2200 a b, xor a b = xor b a", "start": [264, 1], "end": [264, 57], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_assoc", "code": "@[simp]\ntheorem xor_assoc : \u2200 a b c, xor (xor a b) c = xor a (xor b c)", "start": [267, 1], "end": [268, 76], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_left_comm", "code": "theorem xor_left_comm : \u2200 a b c, xor a (xor b c) = xor b (xor a c)", "start": [271, 1], "end": [271, 80], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_not_left", "code": "@[simp]\ntheorem xor_not_left : \u2200 a, xor (!a) a = true", "start": [274, 1], "end": [275, 59], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_not_right", "code": "@[simp]\ntheorem xor_not_right : \u2200 a, xor a (!a) = true", "start": [278, 1], "end": [279, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_not_not", "code": "@[simp]\ntheorem xor_not_not : \u2200 a b, xor (!a) (!b) = xor a b", "start": [282, 1], "end": [283, 66], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_false_left", "code": "@[simp]\ntheorem xor_false_left : \u2200 a, xor false a = a", "start": [286, 1], "end": [287, 59], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_false_right", "code": "@[simp]\ntheorem xor_false_right : \u2200 a, xor a false = a", "start": [290, 1], "end": [291, 60], "kind": "commanddeclaration"}, {"full_name": "Bool.and_xor_distrib_left", "code": "theorem and_xor_distrib_left (a b c : Bool) : (a && xor b c) = xor (a && b) (a && c)", "start": [294, 1], "end": [295, 19], "kind": "commanddeclaration"}, {"full_name": "Bool.and_xor_distrib_right", "code": "theorem and_xor_distrib_right (a b c : Bool) : (xor a b && c) = xor (a && c) (b && c)", "start": [298, 1], "end": [299, 43], "kind": "commanddeclaration"}, {"full_name": "Bool.xor_iff_ne", "code": "theorem xor_iff_ne : \u2200 {x y : Bool}, xor x y = true \u2194 x \u2260 y", "start": [302, 1], "end": [302, 73], "kind": "commanddeclaration"}, {"full_name": "Bool.not_and", "code": "@[simp]\ntheorem not_and : \u2200 a b : Bool, (!(a && b)) = (!a || !b)", "start": [307, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "Bool.not_or", "code": "@[simp]\ntheorem not_or : \u2200 a b : Bool, (!(a || b)) = (!a && !b)", "start": [311, 1], "end": [312, 69], "kind": "commanddeclaration"}, {"full_name": "Bool.not_inj", "code": "theorem not_inj : \u2200 {a b : Bool}, (!a) = !b \u2192 a = b", "start": [315, 1], "end": [315, 65], "kind": "commanddeclaration"}, {"full_name": "Bool.linearOrder", "code": "instance linearOrder : LinearOrder Bool where\n  le := fun a b \u21a6 a = false \u2228 b = true\n  le_refl := by unfold LE.le; decide\n  le_trans := by unfold LE.le; decide\n  le_antisymm := by unfold LE.le Preorder.toLE; decide\n  le_total := by unfold LE.le Preorder.toLE PartialOrder.toPreorder; decide\n  decidableLE := by unfold LE.le Preorder.toLE PartialOrder.toPreorder; exact inferInstance\n  decidableEq := inferInstance\n  max := or\n  max_def := \u03bb a b => by cases a <;> cases b <;> decide\n  min := and\n  min_def := \u03bb a b => by cases a <;> cases b <;> decide", "start": [321, 1], "end": [332, 56], "kind": "commanddeclaration"}, {"full_name": "Bool.false_le", "code": "@[simp]\ntheorem false_le {x : Bool} : false \u2264 x", "start": [335, 1], "end": [337, 22], "kind": "commanddeclaration"}, {"full_name": "Bool.le_true", "code": "@[simp]\ntheorem le_true {x : Bool} : x \u2264 true", "start": [340, 1], "end": [342, 23], "kind": "commanddeclaration"}, {"full_name": "Bool.lt_iff", "code": "theorem lt_iff : \u2200 {x y : Bool}, x < y \u2194 x = false \u2227 y = true", "start": [345, 1], "end": [345, 75], "kind": "commanddeclaration"}, {"full_name": "Bool.false_lt_true", "code": "@[simp]\ntheorem false_lt_true : false < true", "start": [348, 1], "end": [350, 22], "kind": "commanddeclaration"}, {"full_name": "Bool.le_iff_imp", "code": "theorem le_iff_imp : \u2200 {x y : Bool}, x \u2264 y \u2194 x \u2192 y", "start": [353, 1], "end": [353, 64], "kind": "commanddeclaration"}, {"full_name": "Bool.and_le_left", "code": "theorem and_le_left : \u2200 x y : Bool, (x && y) \u2264 x", "start": [356, 1], "end": [356, 62], "kind": "commanddeclaration"}, {"full_name": "Bool.and_le_right", "code": "theorem and_le_right : \u2200 x y : Bool, (x && y) \u2264 y", "start": [359, 1], "end": [359, 63], "kind": "commanddeclaration"}, {"full_name": "Bool.le_and", "code": "theorem le_and : \u2200 {x y z : Bool}, x \u2264 y \u2192 x \u2264 z \u2192 x \u2264 (y && z)", "start": [362, 1], "end": [362, 77], "kind": "commanddeclaration"}, {"full_name": "Bool.left_le_or", "code": "theorem left_le_or : \u2200 x y : Bool, x \u2264 (x || y)", "start": [365, 1], "end": [365, 61], "kind": "commanddeclaration"}, {"full_name": "Bool.right_le_or", "code": "theorem right_le_or : \u2200 x y : Bool, y \u2264 (x || y)", "start": [368, 1], "end": [368, 62], "kind": "commanddeclaration"}, {"full_name": "Bool.or_le", "code": "theorem or_le : \u2200 {x y z}, x \u2264 z \u2192 y \u2264 z \u2192 (x || y) \u2264 z", "start": [371, 1], "end": [371, 69], "kind": "commanddeclaration"}, {"full_name": "Bool.toNat", "code": "def toNat (b : Bool) : Nat :=\n  cond b 1 0", "start": [374, 1], "end": [376, 13], "kind": "commanddeclaration"}, {"full_name": "Bool.ofNat", "code": "def ofNat (n : Nat) : Bool :=\n  decide (n \u2260 0)", "start": [379, 1], "end": [381, 17], "kind": "commanddeclaration"}, {"full_name": "Bool.ofNat_le_ofNat", "code": "theorem ofNat_le_ofNat {n m : Nat} (h : n \u2264 m) : ofNat n \u2264 ofNat m", "start": [384, 1], "end": [391, 84], "kind": "commanddeclaration"}, {"full_name": "Bool.toNat_le_toNat", "code": "theorem toNat_le_toNat {b\u2080 b\u2081 : Bool} (h : b\u2080 \u2264 b\u2081) : toNat b\u2080 \u2264 toNat b\u2081", "start": [394, 1], "end": [397, 40], "kind": "commanddeclaration"}, {"full_name": "Bool.ofNat_toNat", "code": "theorem ofNat_toNat (b : Bool) : ofNat (toNat b) = b", "start": [400, 1], "end": [401, 18], "kind": "commanddeclaration"}, {"full_name": "Bool.injective_iff", "code": "@[simp]\ntheorem injective_iff {\u03b1 : Sort*} {f : Bool \u2192 \u03b1} : Function.Injective f \u2194 f false \u2260 f true", "start": [404, 1], "end": [408, 56], "kind": "commanddeclaration"}, {"full_name": "Bool.apply_apply_apply", "code": "theorem apply_apply_apply (f : Bool \u2192 Bool) (x : Bool) : f (f (f x)) = f x", "start": [411, 1], "end": [413, 78], "kind": "commanddeclaration"}, {"full_name": "Bool.xor3", "code": "protected def xor3 (x y c : Bool) :=\n  xor (xor x y) c", "start": [416, 1], "end": [418, 18], "kind": "commanddeclaration"}, {"full_name": "Bool.carry", "code": "protected def carry (x y c : Bool) :=\n  x && y || x && c || y && c", "start": [421, 1], "end": [423, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/PermuteGoals.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Data/List/Basic.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.splitGoalsAndGetNth", "code": "def splitGoalsAndGetNth (nth : \u2115) (reverse : Bool := false) :\n    TacticM (MVarId \u00d7 List MVarId \u00d7 List MVarId) := do\n  if nth = 0 then throwError \"goals are 1-indexed\"\n  let goals \u2190 getGoals\n  let nGoals := goals.length\n  if nth > nGoals then throwError \"goal index out of bounds\"\n  let n := if \u00acreverse then nth - 1 else nGoals - nth\n  let (gl, g :: gr) := goals.splitAt n | throwNoGoalsToBeSolved\n  pure (g, gl, gr)", "start": [15, 1], "end": [31, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/PushNeg.lean", "imports": ["Mathlib/Init/Order/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Lean/Expr.lean", "Mathlib/Logic/Basic.lean", "Mathlib/Tactic/Conv.lean"], "premises": [{"full_name": "Mathlib.Tactic.PushNeg.not_not_eq", "code": "theorem not_not_eq : (\u00ac \u00ac p) = p", "start": [21, 1], "end": [21, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_and_eq", "code": "theorem not_and_eq : (\u00ac (p \u2227 q)) = (p \u2192 \u00ac q)", "start": [22, 1], "end": [22, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_and_or_eq", "code": "theorem not_and_or_eq : (\u00ac (p \u2227 q)) = (\u00ac p \u2228 \u00ac q)", "start": [23, 1], "end": [23, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_or_eq", "code": "theorem not_or_eq : (\u00ac (p \u2228 q)) = (\u00ac p \u2227 \u00ac q)", "start": [24, 1], "end": [24, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_forall_eq", "code": "theorem not_forall_eq : (\u00ac \u2200 x, s x) = (\u2203 x, \u00ac s x)", "start": [25, 1], "end": [25, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_exists_eq", "code": "theorem not_exists_eq : (\u00ac \u2203 x, s x) = (\u2200 x, \u00ac s x)", "start": [26, 1], "end": [26, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_implies_eq", "code": "theorem not_implies_eq : (\u00ac (p \u2192 q)) = (p \u2227 \u00ac q)", "start": [27, 1], "end": [27, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_ne_eq", "code": "theorem not_ne_eq (x y : \u03b1) : (\u00ac (x \u2260 y)) = (x = y)", "start": [28, 1], "end": [28, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_iff", "code": "theorem not_iff : (\u00ac (p \u2194 q)) = ((p \u2227 \u00ac q) \u2228 (\u00ac p \u2227 q))", "start": [29, 1], "end": [30, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_le_eq", "code": "theorem not_le_eq (a b : \u03b2) : (\u00ac (a \u2264 b)) = (b < a)", "start": [33, 1], "end": [33, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_lt_eq", "code": "theorem not_lt_eq (a b : \u03b2) : (\u00ac (a < b)) = (b \u2264 a)", "start": [34, 1], "end": [34, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_ge_eq", "code": "theorem not_ge_eq (a b : \u03b2) : (\u00ac (a \u2265 b)) = (a < b)", "start": [35, 1], "end": [35, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.not_gt_eq", "code": "theorem not_gt_eq (a b : \u03b2) : (\u00ac (a > b)) = (a \u2264 b)", "start": [36, 1], "end": [36, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.transformNegationStep", "code": "def transformNegationStep (e : Expr) : SimpM (Option Simp.Step) := do\n  let mkSimpStep (e : Expr) (pf : Expr) : Simp.Step :=\n    Simp.Step.visit { expr := e, proof? := some pf }\n  let handleIneq (e\u2081 e\u2082 : Expr) (notThm : Name) : SimpM (Option Simp.Step) := do\n    try\n      let thm \u2190 mkAppM notThm #[e\u2081, e\u2082]\n      let some (_, lhs, rhs) := (\u2190 inferType thm).eq? | failure guard <| \u2190 isDefEq e lhs\n      return some <| mkSimpStep rhs thm\n    catch _ => return none\n  let e_whnf \u2190 whnfR e\n  let some ex := e_whnf.not? | return Simp.Step.visit { expr := e }\n  let ex := (\u2190 instantiateMVars ex).cleanupAnnotations\n  match ex.getAppFnArgs with\n  | (``Not, #[e]) =>\n      return mkSimpStep e (\u2190 mkAppM ``not_not_eq #[e])\n  | (``And, #[p, q]) =>\n      match \u2190 getBoolOption `push_neg.use_distrib with\n      | false => return mkSimpStep (.forallE `_ p (mkNot q) default) (\u2190mkAppM ``not_and_eq #[p, q])\n      | true  => return mkSimpStep (mkOr (mkNot p) (mkNot q)) (\u2190mkAppM ``not_and_or_eq #[p, q])\n  | (``Or, #[p, q]) =>\n      return mkSimpStep (mkAnd (mkNot p) (mkNot q)) (\u2190mkAppM ``not_or_eq #[p, q])\n  | (``Iff, #[p, q]) =>\n      return mkSimpStep (mkOr (mkAnd p (mkNot q)) (mkAnd (mkNot p) q)) (\u2190mkAppM ``not_iff #[p, q])\n  | (``Eq, #[_ty, e\u2081, e\u2082]) =>\n      return Simp.Step.visit { expr := \u2190 mkAppM ``Ne #[e\u2081, e\u2082] }\n  | (``Ne, #[_ty, e\u2081, e\u2082]) =>\n      return mkSimpStep (\u2190 mkAppM ``Eq #[e\u2081, e\u2082]) (\u2190 mkAppM ``not_ne_eq #[e\u2081, e\u2082])\n  | (``LE.le, #[_ty, _inst, e\u2081, e\u2082]) => handleIneq e\u2081 e\u2082 ``not_le_eq\n  | (``LT.lt, #[_ty, _inst, e\u2081, e\u2082]) => handleIneq e\u2081 e\u2082 ``not_lt_eq\n  | (``GE.ge, #[_ty, _inst, e\u2081, e\u2082]) => handleIneq e\u2081 e\u2082 ``not_ge_eq\n  | (``GT.gt, #[_ty, _inst, e\u2081, e\u2082]) => handleIneq e\u2081 e\u2082 ``not_gt_eq\n  | (``Exists, #[_, .lam n typ bo bi]) =>\n      return mkSimpStep (.forallE n typ (mkNot bo) bi)\n                        (\u2190 mkAppM ``not_exists_eq #[.lam n typ bo bi])\n  | (``Exists, #[_, _]) =>\n      return none\n  | _ => match ex with\n          | .forallE name ty body binfo => do\n              if (\u2190 isProp ty) && !body.hasLooseBVars then\n                return mkSimpStep (\u2190 mkAppM ``And #[ty, mkNot body])\n                  (\u2190 mkAppM ``not_implies_eq #[ty, body])\n              else\n                let body' : Expr := .lam name ty (mkNot body) binfo\n                let body'' : Expr := .lam name ty body binfo\n                return mkSimpStep (\u2190 mkAppM ``Exists #[body']) (\u2190 mkAppM ``not_forall_eq #[body''])\n          | _ => return none", "start": [44, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.transformNegation", "code": "partial def transformNegation (e : Expr) : SimpM Simp.Step := do\n  let Simp.Step.visit r\u2081 \u2190 transformNegationStep e | return Simp.Step.visit { expr := e }\n  match r\u2081.proof? with\n  | none => return Simp.Step.visit r\u2081\n  | some _ => do\n      let Simp.Step.visit r\u2082 \u2190 transformNegation r\u2081.expr | return Simp.Step.visit r\u2081\n      return Simp.Step.visit (\u2190 Simp.mkEqTrans r\u2081 r\u2082)", "start": [98, 1], "end": [106, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.pushNegCore", "code": "def pushNegCore (tgt : Expr) : MetaM Simp.Result := do\n  let myctx : Simp.Context :=\n    { config := { eta := true, zeta := false },\n      simpTheorems := #[ ]\n      congrTheorems := (\u2190 getSimpCongrTheorems) }\n  (\u00b7.1) <$> Simp.main tgt myctx (methods := { pre := transformNegation })", "start": [108, 1], "end": [114, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.elabPushNegConv", "code": "@[tactic pushNegConv] def elabPushNegConv : Tactic := fun _ \u21a6 withMainContext do\n  Conv.applySimpResult (\u2190 pushNegCore (\u2190 instantiateMVars (\u2190 Conv.getLhs)))", "start": [139, 1], "end": [141, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.pushNegTarget", "code": "def pushNegTarget : TacticM Unit := withMainContext do\n  let goal \u2190 getMainGoal\n  let tgt \u2190 instantiateMVars (\u2190 goal.getType)\n  replaceMainGoal [\u2190 applySimpResultToTarget goal tgt (\u2190 pushNegCore tgt)]", "start": [151, 1], "end": [155, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.PushNeg.pushNegLocalDecl", "code": "def pushNegLocalDecl (fvarId : FVarId) : TacticM Unit := withMainContext do\n  let ldecl \u2190 fvarId.getDecl\n  if ldecl.isAuxDecl then return\n  let tgt \u2190 instantiateMVars ldecl.type\n  let goal \u2190 getMainGoal\n  let myres \u2190 pushNegCore tgt\n  let some (_, newGoal) \u2190 applySimpResultToLocalDecl goal fvarId myres False | failure\n  replaceMainGoal [newGoal]", "start": [157, 1], "end": [165, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Defs.lean", "imports": ["Mathlib/Init/Data/Int/Basic.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/ZeroOne.lean", "Mathlib/Tactic/Basic.lean"], "premises": [{"full_name": "HVAdd", "code": "class HVAdd (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hVAdd : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [47, 1], "end": [54, 20], "kind": "commanddeclaration"}, {"full_name": "HSMul", "code": "class HSMul (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  hSMul : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [56, 1], "end": [63, 20], "kind": "commanddeclaration"}, {"full_name": "VAdd", "code": "class VAdd (G : Type u) (P : Type v) where\n  vadd : G \u2192 P \u2192 P", "start": [69, 1], "end": [71, 19], "kind": "commanddeclaration"}, {"full_name": "VSub", "code": "class VSub (G : outParam (Type*)) (P : Type*) where\n  vsub : P \u2192 P \u2192 G", "start": [74, 1], "end": [76, 19], "kind": "commanddeclaration"}, {"full_name": "SMul", "code": "@[to_additive (attr := ext)]\nclass SMul (M : Type u) (\u03b1 : Type v) where\n  smul : M \u2192 \u03b1 \u2192 \u03b1", "start": [79, 1], "end": [82, 19], "kind": "commanddeclaration"}, {"full_name": "instHSMul", "code": "@[to_additive (attr := default_instance)]\ninstance instHSMul [SMul \u03b1 \u03b2] : HSMul \u03b1 \u03b2 \u03b2 where\n  hSMul := SMul.smul", "start": [95, 1], "end": [97, 21], "kind": "commanddeclaration"}, {"full_name": "Inv", "code": "@[to_additive, notation_class]\nclass Inv (\u03b1 : Type u) where\n  \n  inv : \u03b1 \u2192 \u03b1", "start": [105, 1], "end": [109, 14], "kind": "commanddeclaration"}, {"full_name": "leftMul", "code": "@[to_additive \"`leftAdd g` denotes left addition by `g`\"]\ndef leftMul : G \u2192 G \u2192 G := fun g : G \u21a6 fun x : G \u21a6 g * x", "start": [119, 1], "end": [121, 57], "kind": "commanddeclaration"}, {"full_name": "rightMul", "code": "@[to_additive \"`rightAdd g` denotes right addition by `g`\"]\ndef rightMul : G \u2192 G \u2192 G := fun g : G \u21a6 fun x : G \u21a6 x * g", "start": [125, 1], "end": [127, 58], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancelMul", "code": "class IsLeftCancelMul (G : Type u) [Mul G] : Prop where\n  \n  protected mul_left_cancel : \u2200 a b c : G, a * b = a * c \u2192 b = c", "start": [131, 1], "end": [134, 65], "kind": "commanddeclaration"}, {"full_name": "IsRightCancelMul", "code": "class IsRightCancelMul (G : Type u) [Mul G] : Prop where\n  \n  protected mul_right_cancel : \u2200 a b c : G, a * b = c * b \u2192 a = c", "start": [135, 1], "end": [138, 66], "kind": "commanddeclaration"}, {"full_name": "IsCancelMul", "code": "class IsCancelMul (G : Type u) [Mul G] extends IsLeftCancelMul G, IsRightCancelMul G : Prop", "start": [139, 1], "end": [140, 92], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancelAdd", "code": "class IsLeftCancelAdd (G : Type u) [Add G] : Prop where\n  \n  protected add_left_cancel : \u2200 a b c : G, a + b = a + c \u2192 b = c", "start": [145, 1], "end": [148, 65], "kind": "commanddeclaration"}, {"full_name": "IsRightCancelAdd", "code": "class IsRightCancelAdd (G : Type u) [Add G] : Prop where\n  \n  protected add_right_cancel : \u2200 a b c : G, a + b = c + b \u2192 a = c", "start": [153, 1], "end": [156, 66], "kind": "commanddeclaration"}, {"full_name": "IsCancelAdd", "code": "class IsCancelAdd (G : Type u) [Add G] extends IsLeftCancelAdd G, IsRightCancelAdd G : Prop", "start": [161, 1], "end": [162, 92], "kind": "commanddeclaration"}, {"full_name": "mul_left_cancel", "code": "@[to_additive]\ntheorem mul_left_cancel : a * b = a * c \u2192 b = c", "start": [171, 1], "end": [173, 40], "kind": "commanddeclaration"}, {"full_name": "mul_left_cancel_iff", "code": "@[to_additive]\ntheorem mul_left_cancel_iff : a * b = a * c \u2194 b = c", "start": [177, 1], "end": [179, 33], "kind": "commanddeclaration"}, {"full_name": "mul_right_injective", "code": "@[to_additive]\ntheorem mul_right_injective (a : G) : Function.Injective ((\u00b7 * \u00b7) a)", "start": [183, 1], "end": [184, 98], "kind": "commanddeclaration"}, {"full_name": "mul_right_inj", "code": "@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : G) {b c : G} : a * b = a * c \u2194 b = c", "start": [188, 1], "end": [190, 33], "kind": "commanddeclaration"}, {"full_name": "mul_ne_mul_right", "code": "@[to_additive]\ntheorem mul_ne_mul_right (a : G) {b c : G} : a * b \u2260 a * c \u2194 b \u2260 c", "start": [194, 1], "end": [196, 33], "kind": "commanddeclaration"}, {"full_name": "mul_right_cancel", "code": "@[to_additive]\ntheorem mul_right_cancel : a * b = c * b \u2192 a = c", "start": [206, 1], "end": [208, 42], "kind": "commanddeclaration"}, {"full_name": "mul_right_cancel_iff", "code": "@[to_additive]\ntheorem mul_right_cancel_iff : b * a = c * a \u2194 b = c", "start": [212, 1], "end": [214, 40], "kind": "commanddeclaration"}, {"full_name": "mul_left_injective", "code": "@[to_additive]\ntheorem mul_left_injective (a : G) : Function.Injective (\u00b7 * a)", "start": [218, 1], "end": [219, 94], "kind": "commanddeclaration"}, {"full_name": "mul_left_inj", "code": "@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : G) {b c : G} : b * a = c * a \u2194 b = c", "start": [223, 1], "end": [225, 32], "kind": "commanddeclaration"}, {"full_name": "mul_ne_mul_left", "code": "@[to_additive]\ntheorem mul_ne_mul_left (a : G) {b c : G} : b * a \u2260 c * a \u2194 b \u2260 c", "start": [229, 1], "end": [231, 32], "kind": "commanddeclaration"}, {"full_name": "Semigroup", "code": "@[ext]\nclass Semigroup (G : Type u) extends Mul G where\n  \n  protected mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c)", "start": [239, 1], "end": [243, 61], "kind": "commanddeclaration"}, {"full_name": "AddSemigroup", "code": "@[ext]\nclass AddSemigroup (G : Type u) extends Add G where\n  \n  protected add_assoc : \u2200 a b c : G, a + b + c = a + (b + c)", "start": [248, 1], "end": [252, 61], "kind": "commanddeclaration"}, {"full_name": "mul_assoc", "code": "@[to_additive]\ntheorem mul_assoc : \u2200 a b c : G, a * b * c = a * (b * c)", "start": [263, 1], "end": [265, 22], "kind": "commanddeclaration"}, {"full_name": "Semigroup.to_isAssociative", "code": "@[to_additive]\ninstance Semigroup.to_isAssociative : IsAssociative G (\u00b7 * \u00b7) :=\n  \u27e8mul_assoc\u27e9", "start": [269, 1], "end": [271, 14], "kind": "commanddeclaration"}, {"full_name": "CommSemigroup", "code": "@[ext]\nclass CommSemigroup (G : Type u) extends Semigroup G where\n  \n  protected mul_comm : \u2200 a b : G, a * b = b * a", "start": [277, 1], "end": [281, 48], "kind": "commanddeclaration"}, {"full_name": "AddCommSemigroup", "code": "@[ext]\nclass AddCommSemigroup (G : Type u) extends AddSemigroup G where\n  \n  protected add_comm : \u2200 a b : G, a + b = b + a", "start": [286, 1], "end": [290, 48], "kind": "commanddeclaration"}, {"full_name": "mul_comm", "code": "@[to_additive]\ntheorem mul_comm : \u2200 a b : G, a * b = b * a", "start": [301, 1], "end": [303, 25], "kind": "commanddeclaration"}, {"full_name": "CommSemigroup.to_isCommutative", "code": "@[to_additive]\ninstance CommSemigroup.to_isCommutative : IsCommutative G (\u00b7 * \u00b7) :=\n  \u27e8mul_comm\u27e9", "start": [307, 1], "end": [309, 13], "kind": "commanddeclaration"}, {"full_name": "CommSemigroup.IsRightCancelMul.toIsLeftCancelMul", "code": "@[to_additive AddCommSemigroup.IsRightCancelAdd.toIsLeftCancelAdd \"Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsLeftCancelAdd G`.\"]\nlemma CommSemigroup.IsRightCancelMul.toIsLeftCancelMul (G : Type u) [CommSemigroup G]\n    [IsRightCancelMul G] : IsLeftCancelMul G :=\n  \u27e8fun _ _ _ h => mul_right_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))\u27e9", "start": [313, 1], "end": [320, 85], "kind": "mathlibtacticlemma"}, {"full_name": "CommSemigroup.IsLeftCancelMul.toIsRightCancelMul", "code": "@[to_additive AddCommSemigroup.IsLeftCancelAdd.toIsRightCancelAdd \"Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsRightCancelAdd G`.\"]\nlemma CommSemigroup.IsLeftCancelMul.toIsRightCancelMul (G : Type u) [CommSemigroup G]\n    [IsLeftCancelMul G] : IsRightCancelMul G :=\n  \u27e8fun _ _ _ h => mul_left_cancel <| (mul_comm _ _).trans (h.trans (mul_comm _ _))\u27e9", "start": [324, 1], "end": [331, 84], "kind": "mathlibtacticlemma"}, {"full_name": "CommSemigroup.IsLeftCancelMul.toIsCancelMul", "code": "@[to_additive AddCommSemigroup.IsLeftCancelAdd.toIsCancelAdd \"Any\n`AddCommSemigroup G` that satisfies `IsLeftCancelAdd G` also satisfies\n`IsCancelAdd G`.\"]\nlemma CommSemigroup.IsLeftCancelMul.toIsCancelMul (G : Type u) [CommSemigroup G]\n    [IsLeftCancelMul G] : IsCancelMul G :=\n  { CommSemigroup.IsLeftCancelMul.toIsRightCancelMul G with }", "start": [335, 1], "end": [342, 62], "kind": "mathlibtacticlemma"}, {"full_name": "CommSemigroup.IsRightCancelMul.toIsCancelMul", "code": "@[to_additive AddCommSemigroup.IsRightCancelAdd.toIsCancelAdd \"Any\n`AddCommSemigroup G` that satisfies `IsRightCancelAdd G` also satisfies\n`IsCancelAdd G`.\"]\nlemma CommSemigroup.IsRightCancelMul.toIsCancelMul (G : Type u) [CommSemigroup G]\n    [IsRightCancelMul G] : IsCancelMul G :=\n  { CommSemigroup.IsRightCancelMul.toIsLeftCancelMul G with }", "start": [346, 1], "end": [353, 62], "kind": "mathlibtacticlemma"}, {"full_name": "LeftCancelSemigroup", "code": "@[ext]\nclass LeftCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_left_cancel : \u2200 a b c : G, a * b = a * c \u2192 b = c", "start": [359, 1], "end": [362, 65], "kind": "commanddeclaration"}, {"full_name": "AddLeftCancelSemigroup", "code": "@[ext]\nclass AddLeftCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_left_cancel : \u2200 a b c : G, a + b = a + c \u2192 b = c", "start": [375, 1], "end": [379, 65], "kind": "commanddeclaration"}, {"full_name": "LeftCancelSemigroup.toIsLeftCancelMul", "code": "@[to_additive AddLeftCancelSemigroup.toIsLeftCancelAdd \"Any `AddLeftCancelSemigroup` satisfies\n`IsLeftCancelAdd`.\"]\ninstance (priority := 100) LeftCancelSemigroup.toIsLeftCancelMul (G : Type u)\n    [LeftCancelSemigroup G] : IsLeftCancelMul G :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel }", "start": [388, 1], "end": [393, 61], "kind": "commanddeclaration"}, {"full_name": "RightCancelSemigroup", "code": "@[ext]\nclass RightCancelSemigroup (G : Type u) extends Semigroup G where\n  protected mul_right_cancel : \u2200 a b c : G, a * b = c * b \u2192 a = c", "start": [397, 1], "end": [400, 66], "kind": "commanddeclaration"}, {"full_name": "AddRightCancelSemigroup", "code": "@[ext]\nclass AddRightCancelSemigroup (G : Type u) extends AddSemigroup G where\n  protected add_right_cancel : \u2200 a b c : G, a + b = c + b \u2192 a = c", "start": [407, 1], "end": [411, 66], "kind": "commanddeclaration"}, {"full_name": "RightCancelSemigroup.toIsRightCancelMul", "code": "@[to_additive AddRightCancelSemigroup.toIsRightCancelAdd \"Any `AddRightCancelSemigroup` satisfies\n`IsRightCancelAdd`.\"]\ninstance (priority := 100) RightCancelSemigroup.toIsRightCancelMul (G : Type u)\n    [RightCancelSemigroup G] : IsRightCancelMul G :=\n  { mul_right_cancel := RightCancelSemigroup.mul_right_cancel }", "start": [420, 1], "end": [425, 64], "kind": "commanddeclaration"}, {"full_name": "MulOneClass", "code": "class MulOneClass (M : Type u) extends One M, Mul M where\n  \n  protected one_mul : \u2200 a : M, 1 * a = a\n  \n  protected mul_one : \u2200 a : M, a * 1 = a", "start": [429, 1], "end": [435, 41], "kind": "commanddeclaration"}, {"full_name": "AddZeroClass", "code": "class AddZeroClass (M : Type u) extends Zero M, Add M where\n  \n  protected zero_add : \u2200 a : M, 0 + a = a\n  \n  protected add_zero : \u2200 a : M, a + 0 = a", "start": [438, 1], "end": [444, 42], "kind": "commanddeclaration"}, {"full_name": "MulOneClass.ext", "code": "@[to_additive (attr := ext)]\ntheorem MulOneClass.ext {M : Type u} : \u2200 \u2983m\u2081 m\u2082 : MulOneClass M\u2984, m\u2081.mul = m\u2082.mul \u2192 m\u2081 = m\u2082", "start": [449, 1], "end": [455, 51], "kind": "commanddeclaration"}, {"full_name": "one_mul", "code": "@[to_additive (attr := simp)]\ntheorem one_mul : \u2200 a : M, 1 * a = a", "start": [463, 1], "end": [465, 22], "kind": "commanddeclaration"}, {"full_name": "mul_one", "code": "@[to_additive (attr := simp)]\ntheorem mul_one : \u2200 a : M, a * 1 = a", "start": [469, 1], "end": [471, 22], "kind": "commanddeclaration"}, {"full_name": "npowRec", "code": "def npowRec [One M] [Mul M] : \u2115 \u2192 M \u2192 M\n  | 0, _ => 1\n  | n + 1, a => a * npowRec n a", "start": [483, 1], "end": [487, 32], "kind": "commanddeclaration"}, {"full_name": "nsmulRec", "code": "def nsmulRec [Zero M] [Add M] : \u2115 \u2192 M \u2192 M\n  | 0, _ => 0\n  | n + 1, a => a + nsmulRec n a", "start": [490, 1], "end": [494, 33], "kind": "commanddeclaration"}, {"full_name": "AddMonoid", "code": "class AddMonoid (M : Type u) extends AddSemigroup M, AddZeroClass M where\n  \n  protected nsmul : \u2115 \u2192 M \u2192 M := nsmulRec\n  \n  protected nsmul_zero : \u2200 x, nsmul 0 x = 0 := by intros; rfl\n  \n  protected nsmul_succ : \u2200 (n : \u2115) (x), nsmul (n + 1) x = x + nsmul n x := by intros; rfl", "start": [584, 1], "end": [591, 90], "kind": "commanddeclaration"}, {"full_name": "Monoid", "code": "@[to_additive]\nclass Monoid (M : Type u) extends Semigroup M, MulOneClass M where\n  \n  protected npow : \u2115 \u2192 M \u2192 M := npowRec\n  \n  protected npow_zero : \u2200 x, npow 0 x = 1 := by intros; rfl\n  \n  protected npow_succ : \u2200 (n : \u2115) (x), npow (n + 1) x = x * npow n x := by intros; rfl", "start": [600, 1], "end": [608, 87], "kind": "commanddeclaration"}, {"full_name": "Monoid.Pow", "code": "@[default_instance high] instance Monoid.Pow {M : Type*} [Monoid M] : Pow M \u2115 :=\n  \u27e8fun x n \u21a6 Monoid.npow n x\u27e9", "start": [617, 1], "end": [618, 30], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.SMul", "code": "instance AddMonoid.SMul {M : Type*} [AddMonoid M] : SMul \u2115 M :=\n  \u27e8AddMonoid.nsmul\u27e9", "start": [621, 1], "end": [622, 20], "kind": "commanddeclaration"}, {"full_name": "npow_eq_pow", "code": "@[to_additive (attr := simp) nsmul_eq_smul]\ntheorem npow_eq_pow (n : \u2115) (x : M) : Monoid.npow n x = x ^ n", "start": [631, 1], "end": [633, 6], "kind": "commanddeclaration"}, {"full_name": "pow_zero", "code": "@[to_additive zero_nsmul, simp]\ntheorem pow_zero (a : M) : a ^ 0 = 1", "start": [638, 1], "end": [640, 21], "kind": "commanddeclaration"}, {"full_name": "pow_succ", "code": "@[to_additive succ_nsmul]\ntheorem pow_succ (a : M) (n : \u2115) : a ^ (n + 1) = a * a ^ n", "start": [644, 1], "end": [646, 23], "kind": "commanddeclaration"}, {"full_name": "left_inv_eq_right_inv", "code": "@[to_additive]\ntheorem left_inv_eq_right_inv {a b c : M} (hba : b * a = 1) (hac : a * c = 1) : b = c", "start": [656, 1], "end": [658, 53], "kind": "commanddeclaration"}, {"full_name": "AddCommMonoid", "code": "class AddCommMonoid (M : Type u) extends AddMonoid M, AddCommSemigroup M", "start": [664, 1], "end": [665, 73], "kind": "commanddeclaration"}, {"full_name": "CommMonoid", "code": "@[to_additive]\nclass CommMonoid (M : Type u) extends Monoid M, CommSemigroup M", "start": [668, 1], "end": [670, 64], "kind": "commanddeclaration"}, {"full_name": "AddLeftCancelMonoid", "code": "class AddLeftCancelMonoid (M : Type u) extends AddLeftCancelSemigroup M, AddMonoid M", "start": [677, 1], "end": [680, 85], "kind": "commanddeclaration"}, {"full_name": "LeftCancelMonoid", "code": "@[to_additive]\nclass LeftCancelMonoid (M : Type u) extends LeftCancelSemigroup M, Monoid M", "start": [685, 1], "end": [687, 76], "kind": "commanddeclaration"}, {"full_name": "AddRightCancelMonoid", "code": "class AddRightCancelMonoid (M : Type u) extends AddRightCancelSemigroup M, AddMonoid M", "start": [698, 1], "end": [701, 87], "kind": "commanddeclaration"}, {"full_name": "RightCancelMonoid", "code": "@[to_additive]\nclass RightCancelMonoid (M : Type u) extends RightCancelSemigroup M, Monoid M", "start": [706, 1], "end": [708, 78], "kind": "commanddeclaration"}, {"full_name": "AddCancelMonoid", "code": "class AddCancelMonoid (M : Type u) extends AddLeftCancelMonoid M, AddRightCancelMonoid M", "start": [719, 1], "end": [722, 89], "kind": "commanddeclaration"}, {"full_name": "CancelMonoid", "code": "@[to_additive]\nclass CancelMonoid (M : Type u) extends LeftCancelMonoid M, RightCancelMonoid M", "start": [725, 1], "end": [727, 80], "kind": "commanddeclaration"}, {"full_name": "AddCancelCommMonoid", "code": "class AddCancelCommMonoid (M : Type u) extends AddLeftCancelMonoid M, AddCommMonoid M", "start": [732, 1], "end": [733, 86], "kind": "commanddeclaration"}, {"full_name": "CancelCommMonoid", "code": "@[to_additive]\nclass CancelCommMonoid (M : Type u) extends LeftCancelMonoid M, CommMonoid M", "start": [738, 1], "end": [740, 77], "kind": "commanddeclaration"}, {"full_name": "CancelCommMonoid.toCancelMonoid", "code": "@[to_additive]\ninstance (priority := 100) CancelCommMonoid.toCancelMonoid (M : Type u) [CancelCommMonoid M] :\n    CancelMonoid M :=\n  { CommSemigroup.IsLeftCancelMul.toIsRightCancelMul M with }", "start": [748, 1], "end": [751, 62], "kind": "commanddeclaration"}, {"full_name": "CancelMonoid.toIsCancelMul", "code": "@[to_additive toIsCancelAdd \"Any `AddCancelMonoid G` satisfies `IsCancelAdd G`.\"]\ninstance (priority := 100) CancelMonoid.toIsCancelMul (M : Type u) [CancelMonoid M] :\n    IsCancelMul M :=\n  { mul_left_cancel := LeftCancelSemigroup.mul_left_cancel\n    mul_right_cancel := RightCancelSemigroup.mul_right_cancel }", "start": [755, 1], "end": [760, 64], "kind": "commanddeclaration"}, {"full_name": "zpowRec", "code": "def zpowRec {M : Type*} [One M] [Mul M] [Inv M] : \u2124 \u2192 M \u2192 M\n  | Int.ofNat n, a => npowRec n a\n  | Int.negSucc n, a => (npowRec n.succ a)\u207b\u00b9", "start": [766, 1], "end": [770, 45], "kind": "commanddeclaration"}, {"full_name": "zsmulRec", "code": "def zsmulRec {M : Type*} [Zero M] [Add M] [Neg M] : \u2124 \u2192 M \u2192 M\n  | Int.ofNat n, a => nsmulRec n a\n  | Int.negSucc n, a => -nsmulRec n.succ a", "start": [773, 1], "end": [777, 43], "kind": "commanddeclaration"}, {"full_name": "InvolutiveNeg", "code": "class InvolutiveNeg (A : Type*) extends Neg A where\n  protected neg_neg : \u2200 x : A, - -x = x", "start": [784, 1], "end": [786, 40], "kind": "commanddeclaration"}, {"full_name": "InvolutiveInv", "code": "@[to_additive]\nclass InvolutiveInv (G : Type*) extends Inv G where\n  protected inv_inv : \u2200 x : G, x\u207b\u00b9\u207b\u00b9 = x", "start": [790, 1], "end": [793, 41], "kind": "commanddeclaration"}, {"full_name": "inv_inv", "code": "@[to_additive (attr := simp)]\ntheorem inv_inv (a : G) : a\u207b\u00b9\u207b\u00b9 = a", "start": [799, 1], "end": [801, 26], "kind": "commanddeclaration"}, {"full_name": "DivInvMonoid.div'", "code": "def DivInvMonoid.div' {G : Type u} [Monoid G] [Inv G] (a b : G) : G := a * b\u207b\u00b9", "start": [839, 1], "end": [846, 79], "kind": "commanddeclaration"}, {"full_name": "DivInvMonoid", "code": "class DivInvMonoid (G : Type u) extends Monoid G, Inv G, Div G where\n  protected div := DivInvMonoid.div'\n  \n  protected div_eq_mul_inv : \u2200 a b : G, a / b = a * b\u207b\u00b9 := by intros; rfl\n  \n  protected zpow : \u2124 \u2192 G \u2192 G := zpowRec\n  \n  protected zpow_zero' : \u2200 a : G, zpow 0 a = 1 := by intros; rfl\n  \n  protected zpow_succ' (n : \u2115) (a : G) : zpow (Int.ofNat n.succ) a = a * zpow (Int.ofNat n) a := by\n    intros; rfl\n  \n  protected zpow_neg' (n : \u2115) (a : G) : zpow (Int.negSucc n) a = (zpow n.succ a)\u207b\u00b9 := by intros; rfl", "start": [848, 1], "end": [878, 101], "kind": "commanddeclaration"}, {"full_name": "SubNegMonoid.sub'", "code": "def SubNegMonoid.sub' {G : Type u} [AddMonoid G] [Neg G] (a b : G) : G := a + -b", "start": [881, 1], "end": [888, 81], "kind": "commanddeclaration"}, {"full_name": "SubNegMonoid", "code": "class SubNegMonoid (G : Type u) extends AddMonoid G, Neg G, Sub G where\n  protected sub := SubNegMonoid.sub'\n  protected sub_eq_add_neg : \u2200 a b : G, a - b = a + -b := by intros; rfl\n  protected zsmul : \u2124 \u2192 G \u2192 G := zsmulRec\n  protected zsmul_zero' : \u2200 a : G, zsmul 0 a = 0 := by intros; rfl\n  protected zsmul_succ' (n : \u2115) (a : G) :\n      zsmul (Int.ofNat n.succ) a = a + zsmul (Int.ofNat n) a := by\n    intros; rfl\n  protected zsmul_neg' (n : \u2115) (a : G) : zsmul (Int.negSucc n) a = -zsmul n.succ a := by intros; rfl", "start": [892, 1], "end": [917, 101], "kind": "commanddeclaration"}, {"full_name": "DivInvMonoid.Pow", "code": "instance DivInvMonoid.Pow {M} [DivInvMonoid M] : Pow M \u2124 :=\n  \u27e8fun x n \u21a6 DivInvMonoid.zpow n x\u27e9", "start": [922, 1], "end": [923, 36], "kind": "commanddeclaration"}, {"full_name": "SubNegMonoid.SMulInt", "code": "instance SubNegMonoid.SMulInt {M} [SubNegMonoid M] : SMul \u2124 M :=\n  \u27e8SubNegMonoid.zsmul\u27e9", "start": [926, 1], "end": [927, 23], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_pow", "code": "@[to_additive (attr := simp) zsmul_eq_smul] theorem zpow_eq_pow (n : \u2124) (x : G) :\n    DivInvMonoid.zpow n x = x ^ n", "start": [936, 1], "end": [938, 6], "kind": "commanddeclaration"}, {"full_name": "zpow_zero", "code": "@[to_additive (attr := simp) zero_zsmul] theorem zpow_zero (a : G) : a ^ (0 : \u2124) = 1", "start": [942, 1], "end": [943, 28], "kind": "commanddeclaration"}, {"full_name": "zpow_ofNat", "code": "@[to_additive (attr := norm_cast) ofNat_zsmul]\ntheorem zpow_ofNat (a : G) : \u2200 n : \u2115, a ^ (n : \u2124) = a ^ n", "start": [947, 1], "end": [953, 43], "kind": "commanddeclaration"}, {"full_name": "zpow_negSucc", "code": "theorem zpow_negSucc (a : G) (n : \u2115) : a ^ (Int.negSucc n) = (a ^ (n + 1))\u207b\u00b9", "start": [958, 1], "end": [960, 35], "kind": "commanddeclaration"}, {"full_name": "negSucc_zsmul", "code": "theorem negSucc_zsmul {G} [SubNegMonoid G] (a : G) (n : \u2115) :\n    Int.negSucc n \u2022 a = -((n + 1) \u2022 a)", "start": [963, 1], "end": [966, 36], "kind": "commanddeclaration"}, {"full_name": "div_eq_mul_inv", "code": "@[to_additive \"Subtracting an element is the same as adding by its negative.\nThis is a duplicate of `SubNegMonoid.sub_eq_mul_neg` ensuring that the types unfold better.\"]\ntheorem div_eq_mul_inv (a b : G) : a / b = a * b\u207b\u00b9", "start": [971, 1], "end": [978, 34], "kind": "commanddeclaration"}, {"full_name": "division_def", "code": "alias division_def := div_eq_mul_inv", "start": [982, 1], "end": [982, 37], "kind": "stdtacticaliasalias"}, {"full_name": "NegZeroClass", "code": "class NegZeroClass (G : Type*) extends Zero G, Neg G where\n  protected neg_zero : -(0 : G) = 0", "start": [989, 1], "end": [991, 36], "kind": "commanddeclaration"}, {"full_name": "SubNegZeroMonoid", "code": "class SubNegZeroMonoid (G : Type*) extends SubNegMonoid G, NegZeroClass G", "start": [994, 1], "end": [995, 74], "kind": "commanddeclaration"}, {"full_name": "InvOneClass", "code": "@[to_additive]\nclass InvOneClass (G : Type*) extends One G, Inv G where\n  protected inv_one : (1 : G)\u207b\u00b9 = 1", "start": [998, 1], "end": [1001, 36], "kind": "commanddeclaration"}, {"full_name": "DivInvOneMonoid", "code": "@[to_additive SubNegZeroMonoid]\nclass DivInvOneMonoid (G : Type*) extends DivInvMonoid G, InvOneClass G", "start": [1004, 1], "end": [1006, 72], "kind": "commanddeclaration"}, {"full_name": "inv_one", "code": "@[to_additive (attr := simp)]\ntheorem inv_one : (1 : G)\u207b\u00b9 = 1", "start": [1014, 1], "end": [1016, 22], "kind": "commanddeclaration"}, {"full_name": "SubtractionMonoid", "code": "class SubtractionMonoid (G : Type u) extends SubNegMonoid G, InvolutiveNeg G where\n  protected neg_add_rev (a b : G) : -(a + b) = -b + -a\n  \n  protected neg_eq_of_add (a b : G) : a + b = 0 \u2192 -a = b", "start": [1022, 1], "end": [1028, 57], "kind": "commanddeclaration"}, {"full_name": "DivisionMonoid", "code": "@[to_additive SubtractionMonoid]\nclass DivisionMonoid (G : Type u) extends DivInvMonoid G, InvolutiveInv G where\n  protected mul_inv_rev (a b : G) : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9\n  \n  protected inv_eq_of_mul (a b : G) : a * b = 1 \u2192 a\u207b\u00b9 = b", "start": [1031, 1], "end": [1040, 58], "kind": "commanddeclaration"}, {"full_name": "mul_inv_rev", "code": "@[to_additive (attr := simp) neg_add_rev]\ntheorem mul_inv_rev (a b : G) : (a * b)\u207b\u00b9 = b\u207b\u00b9 * a\u207b\u00b9", "start": [1049, 1], "end": [1051, 33], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_mul_eq_one_right", "code": "@[to_additive]\ntheorem inv_eq_of_mul_eq_one_right : a * b = 1 \u2192 a\u207b\u00b9 = b", "start": [1055, 1], "end": [1057, 35], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_mul_eq_one_left", "code": "@[to_additive]\ntheorem inv_eq_of_mul_eq_one_left (h : a * b = 1) : b\u207b\u00b9 = a", "start": [1061, 1], "end": [1063, 50], "kind": "commanddeclaration"}, {"full_name": "eq_inv_of_mul_eq_one_left", "code": "@[to_additive]\ntheorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b\u207b\u00b9", "start": [1067, 1], "end": [1069, 37], "kind": "commanddeclaration"}, {"full_name": "SubtractionCommMonoid", "code": "class SubtractionCommMonoid (G : Type u) extends SubtractionMonoid G, AddCommMonoid G", "start": [1075, 1], "end": [1076, 86], "kind": "commanddeclaration"}, {"full_name": "DivisionCommMonoid", "code": "@[to_additive SubtractionCommMonoid]\nclass DivisionCommMonoid (G : Type u) extends DivisionMonoid G, CommMonoid G", "start": [1079, 1], "end": [1083, 77], "kind": "commanddeclaration"}, {"full_name": "Group", "code": "class Group (G : Type u) extends DivInvMonoid G where\n  protected mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1", "start": [1088, 1], "end": [1097, 48], "kind": "commanddeclaration"}, {"full_name": "AddGroup", "code": "class AddGroup (A : Type u) extends SubNegMonoid A where\n  protected add_left_neg : \u2200 a : A, -a + a = 0", "start": [1100, 1], "end": [1109, 47], "kind": "commanddeclaration"}, {"full_name": "mul_left_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_left_inv : \u2200 a : G, a\u207b\u00b9 * a = 1", "start": [1118, 1], "end": [1120, 21], "kind": "commanddeclaration"}, {"full_name": "inv_mul_self", "code": "@[to_additive]\ntheorem inv_mul_self (a : G) : a\u207b\u00b9 * a = 1", "start": [1124, 1], "end": [1126, 17], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_mul", "code": "@[to_additive]\nprivate theorem inv_eq_of_mul (h : a * b = 1) : a\u207b\u00b9 = b", "start": [1130, 1], "end": [1132, 43], "kind": "commanddeclaration"}, {"full_name": "mul_right_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_right_inv (a : G) : a * a\u207b\u00b9 = 1", "start": [1134, 1], "end": [1136, 61], "kind": "commanddeclaration"}, {"full_name": "mul_inv_self", "code": "@[to_additive]\ntheorem mul_inv_self (a : G) : a * a\u207b\u00b9 = 1", "start": [1140, 1], "end": [1142, 18], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a b : G) : a\u207b\u00b9 * (a * b) = b", "start": [1146, 1], "end": [1148, 45], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a b : G) : a * (a\u207b\u00b9 * b) = b", "start": [1152, 1], "end": [1154, 46], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a b : G) : a * b * b\u207b\u00b9 = a", "start": [1158, 1], "end": [1160, 44], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a b : G) : a * b\u207b\u00b9 * b = a", "start": [1164, 1], "end": [1166, 43], "kind": "commanddeclaration"}, {"full_name": "Group.toDivisionMonoid", "code": "@[to_additive AddGroup.toSubtractionMonoid]\ninstance (priority := 100) Group.toDivisionMonoid : DivisionMonoid G :=\n  { inv_inv := fun a \u21a6 inv_eq_of_mul (mul_left_inv a)\n    mul_inv_rev :=\n      fun a b \u21a6 inv_eq_of_mul <| by rw [mul_assoc, mul_inv_cancel_left, mul_right_inv]\n    inv_eq_of_mul := fun _ _ \u21a6 inv_eq_of_mul }", "start": [1170, 1], "end": [1175, 47], "kind": "commanddeclaration"}, {"full_name": "Group.toCancelMonoid", "code": "@[to_additive]\ninstance (priority := 100) Group.toCancelMonoid : CancelMonoid G :=\n  { \u2039Group G\u203a with\n    mul_right_cancel := fun a b c h \u21a6 by rw [\u2190 mul_inv_cancel_right a b, h, mul_inv_cancel_right]\n    mul_left_cancel := fun a b c h \u21a6 by rw [\u2190 inv_mul_cancel_left a b, h, inv_mul_cancel_left] }", "start": [1178, 1], "end": [1182, 97], "kind": "commanddeclaration"}, {"full_name": "Group.toDivInvMonoid_injective", "code": "@[to_additive]\ntheorem Group.toDivInvMonoid_injective {G : Type*} :\n    Function.Injective (@Group.toDivInvMonoid G)", "start": [1186, 1], "end": [1188, 76], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup", "code": "class AddCommGroup (G : Type u) extends AddGroup G, AddCommMonoid G", "start": [1192, 1], "end": [1193, 68], "kind": "commanddeclaration"}, {"full_name": "CommGroup", "code": "@[to_additive]\nclass CommGroup (G : Type u) extends Group G, CommMonoid G", "start": [1196, 1], "end": [1198, 59], "kind": "commanddeclaration"}, {"full_name": "CommGroup.toGroup_injective", "code": "@[to_additive]\ntheorem CommGroup.toGroup_injective {G : Type u} : Function.Injective (@CommGroup.toGroup G)", "start": [1203, 1], "end": [1205, 23], "kind": "commanddeclaration"}, {"full_name": "CommGroup.toCancelCommMonoid", "code": "@[to_additive]\ninstance (priority := 100) CommGroup.toCancelCommMonoid : CancelCommMonoid G :=\n  { \u2039CommGroup G\u203a, Group.toCancelMonoid with }", "start": [1214, 1], "end": [1216, 47], "kind": "commanddeclaration"}, {"full_name": "CommGroup.toDivisionCommMonoid", "code": "@[to_additive]\ninstance (priority := 100) CommGroup.toDivisionCommMonoid : DivisionCommMonoid G :=\n  { \u2039CommGroup G\u203a, Group.toDivisionMonoid with }", "start": [1219, 1], "end": [1221, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Option/Defs.lean", "imports": ["Mathlib/Init/Algebra/Classes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.rel", "code": "inductive rel (r : \u03b1 \u2192 \u03b2 \u2192 Prop) : Option \u03b1 \u2192 Option \u03b2 \u2192 Prop\n  | \n    some {a b} : r a b \u2192 rel r (some a) (some b)\n  | \n    none : rel r none none", "start": [24, 1], "end": [30, 27], "kind": "commanddeclaration"}, {"full_name": "Option.traverse", "code": "protected def traverse.{u, v}\n    {F : Type u \u2192 Type v} [Applicative F] {\u03b1 : Type*} {\u03b2 : Type u} (f : \u03b1 \u2192 F \u03b2) :\n    Option \u03b1 \u2192 F (Option \u03b2)\n  | none => pure none\n  | some x => some <$> f x", "start": [33, 1], "end": [38, 27], "kind": "commanddeclaration"}, {"full_name": "Option.maybe", "code": "def maybe.{u, v} {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type u} : Option (m \u03b1) \u2192 m (Option \u03b1)\n  | none => pure none\n  | some fn => some <$> fn", "start": [41, 1], "end": [46, 27], "kind": "commanddeclaration"}, {"full_name": "Option.getDM'", "code": "@[deprecated getDM]\nprotected def getDM' [Monad m] (x : m (Option \u03b1)) (y : m \u03b1) : m \u03b1 := do\n  (\u2190 x).getDM y", "start": [52, 1], "end": [54, 16], "kind": "commanddeclaration"}, {"full_name": "Option.elim'", "code": "protected def elim' (b : \u03b2) (f : \u03b1 \u2192 \u03b2) : Option \u03b1 \u2192 \u03b2\n  | some a => f a\n  | none => b", "start": [62, 1], "end": [65, 14], "kind": "commanddeclaration"}, {"full_name": "Option.elim'_none", "code": "@[simp]\ntheorem elim'_none (b : \u03b2) (f : \u03b1 \u2192 \u03b2) : Option.elim' b f none = b", "start": [68, 1], "end": [69, 74], "kind": "commanddeclaration"}, {"full_name": "Option.elim'_some", "code": "@[simp]\ntheorem elim'_some (b : \u03b2) (f : \u03b1 \u2192 \u03b2) : Option.elim' b f (some a) = f a", "start": [70, 1], "end": [71, 80], "kind": "commanddeclaration"}, {"full_name": "Option.elim'_eq_elim", "code": "lemma elim'_eq_elim {\u03b1 \u03b2 : Type*} (b : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : Option \u03b1) :\n    Option.elim' b f a = Option.elim a b f := by\n  cases a <;> rfl", "start": [75, 1], "end": [77, 18], "kind": "mathlibtacticlemma"}, {"full_name": "Option.mem_some_iff", "code": "theorem mem_some_iff {\u03b1 : Type*} {a b : \u03b1} : a \u2208 some b \u2194 b = a", "start": [80, 1], "end": [80, 75], "kind": "commanddeclaration"}, {"full_name": "Option.decidableEqNone", "code": "@[inline]\ndef decidableEqNone {o : Option \u03b1} : Decidable (o = none) :=\n  decidable_of_decidable_of_iff isNone_iff_eq_none", "start": [83, 1], "end": [89, 51], "kind": "commanddeclaration"}, {"full_name": "Option.decidableForallMem", "code": "instance decidableForallMem {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    \u2200 o : Option \u03b1, Decidable (\u2200 a \u2208 o, p a)\n  | none => isTrue (by simp [false_imp_iff])\n  | some a =>\n      if h : p a then isTrue fun o e \u21a6 some_inj.1 e \u25b8 h\n      else isFalse <| mt (fun H \u21a6 H _ rfl) h", "start": [92, 1], "end": [97, 45], "kind": "commanddeclaration"}, {"full_name": "Option.decidableExistsMem", "code": "instance decidableExistsMem {p : \u03b1 \u2192 Prop} [DecidablePred p] :\n    \u2200 o : Option \u03b1, Decidable (\u2203 a \u2208 o, p a)\n  | none => isFalse fun \u27e8a, \u27e8h, _\u27e9\u27e9 \u21a6 by cases h\n  | some a => if h : p a then isTrue <| \u27e8_, rfl, h\u27e9 else isFalse fun \u27e8_, \u27e8rfl, hn\u27e9\u27e9 \u21a6 h hn", "start": [99, 1], "end": [102, 91], "kind": "commanddeclaration"}, {"full_name": "Option.iget", "code": "@[reducible]\ndef iget [Inhabited \u03b1] : Option \u03b1 \u2192 \u03b1\n  | some x => x\n  | none => default", "start": [104, 1], "end": [108, 20], "kind": "commanddeclaration"}, {"full_name": "Option.iget_some", "code": "theorem iget_some [Inhabited \u03b1] {a : \u03b1} : (some a).iget = a", "start": [111, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Option.mem_toList", "code": "@[simp]\ntheorem mem_toList {a : \u03b1} {o : Option \u03b1} : a \u2208 toList o \u2194 a \u2208 o", "start": [115, 1], "end": [117, 37], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_isCommutative", "code": "instance liftOrGet_isCommutative (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [IsCommutative \u03b1 f] :\n    IsCommutative (Option \u03b1) (liftOrGet f) :=\n  \u27e8fun a b \u21a6 by cases a <;> cases b <;> simp [liftOrGet, IsCommutative.comm]\u27e9", "start": [120, 1], "end": [122, 78], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_isAssociative", "code": "instance liftOrGet_isAssociative (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [IsAssociative \u03b1 f] :\n    IsAssociative (Option \u03b1) (liftOrGet f) :=\n  \u27e8fun a b c \u21a6 by cases a <;> cases b <;> cases c <;> simp [liftOrGet, IsAssociative.assoc]\u27e9", "start": [124, 1], "end": [126, 93], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_isIdempotent", "code": "instance liftOrGet_isIdempotent (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [IsIdempotent \u03b1 f] :\n    IsIdempotent (Option \u03b1) (liftOrGet f) :=\n  \u27e8fun a \u21a6 by cases a <;> simp [liftOrGet, IsIdempotent.idempotent]\u27e9", "start": [128, 1], "end": [130, 69], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_isLeftId", "code": "instance liftOrGet_isLeftId (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : IsLeftId (Option \u03b1) (liftOrGet f) none :=\n  \u27e8fun a \u21a6 by cases a <;> simp [liftOrGet]\u27e9", "start": [132, 1], "end": [133, 44], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_isRightId", "code": "instance liftOrGet_isRightId (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) : IsRightId (Option \u03b1) (liftOrGet f) none :=\n  \u27e8fun a \u21a6 by cases a <;> simp [liftOrGet]\u27e9", "start": [135, 1], "end": [136, 44], "kind": "commanddeclaration"}, {"full_name": "Lean.LOption.toOption", "code": "def _root_.Lean.LOption.toOption {\u03b1} : Lean.LOption \u03b1 \u2192 Option \u03b1\n  | .some a => some a\n  | _ => none", "start": [144, 1], "end": [147, 14], "kind": "commanddeclaration"}]}
{"path": "lake-packages/aesop/Aesop.lean", "imports": ["lake-packages/aesop/Aesop/Main.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Init/Control/Combinators.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/List/Init/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "joinM", "code": "def joinM {m : Type u \u2192 Type u} [Monad m] {\u03b1 : Type u} (a : m (m \u03b1)) : m \u03b1 :=\n  bind a id", "start": [17, 1], "end": [18, 12], "kind": "commanddeclaration"}, {"full_name": "when", "code": "def when {m : Type \u2192 Type} [Monad m] (c : Prop) [Decidable c] (t : m Unit) : m Unit :=\n  ite c t (pure ())", "start": [30, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "condM", "code": "def condM {m : Type \u2192 Type} [Monad m] {\u03b1 : Type} (mbool : m Bool) (tm fm : m \u03b1) : m \u03b1 := do\n  let b \u2190 mbool\n  cond b tm fm", "start": [33, 1], "end": [35, 15], "kind": "commanddeclaration"}, {"full_name": "whenM", "code": "def whenM {m : Type \u2192 Type} [Monad m] (c : m Bool) (t : m Unit) : m Unit :=\n  condM c t (return ())", "start": [39, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "Monad.mapM", "code": "def mapM :=\n  @List.mapM", "start": [49, 1], "end": [50, 13], "kind": "commanddeclaration"}, {"full_name": "Monad.mapM'", "code": "def mapM' :=\n  @List.mapM'", "start": [53, 1], "end": [54, 14], "kind": "commanddeclaration"}, {"full_name": "Monad.join", "code": "def join :=\n  @joinM", "start": [57, 1], "end": [58, 9], "kind": "commanddeclaration"}, {"full_name": "Monad.filter", "code": "def filter :=\n  @filterM", "start": [60, 1], "end": [61, 11], "kind": "commanddeclaration"}, {"full_name": "Monad.foldl", "code": "def foldl :=\n  @List.foldlM", "start": [63, 1], "end": [64, 15], "kind": "commanddeclaration"}, {"full_name": "Monad.cond", "code": "def cond :=\n  @condM", "start": [66, 1], "end": [67, 9], "kind": "commanddeclaration"}, {"full_name": "Monad.sequence", "code": "def sequence {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type u} : List (m \u03b1) \u2192 m (List \u03b1)\n  | [] => return []\n  | h :: t => do\n    let h' \u2190 h\n    let t' \u2190 sequence t\n    return (h' :: t')", "start": [69, 1], "end": [74, 22], "kind": "commanddeclaration"}, {"full_name": "Monad.sequence'", "code": "def sequence' {m : Type \u2192 Type u} [Monad m] {\u03b1 : Type} : List (m \u03b1) \u2192 m Unit\n  | [] => return ()\n  | h :: t => h *> sequence' t", "start": [76, 1], "end": [78, 31], "kind": "commanddeclaration"}, {"full_name": "Monad.whenb", "code": "def whenb {m : Type \u2192 Type} [Monad m] (b : Bool) (t : m Unit) : m Unit :=\n  _root_.cond b t (return ())", "start": [80, 1], "end": [81, 30], "kind": "commanddeclaration"}, {"full_name": "Monad.unlessb", "code": "def unlessb {m : Type \u2192 Type} [Monad m] (b : Bool) (t : m Unit) : m Unit :=\n  _root_.cond b (return ()) t", "start": [83, 1], "end": [84, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Lattice.lean", "imports": ["Mathlib/Data/Bool/Basic.lean", "Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Init/Order/Defs.lean", "Mathlib/Order/Monotone/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/ULift.lean"], "premises": [{"full_name": "le_antisymm'", "code": "theorem le_antisymm' [PartialOrder \u03b1] : \u2200 {a b : \u03b1}, a \u2264 b \u2192 b \u2264 a \u2192 a = b", "start": [69, 1], "end": [70, 19], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup", "code": "class SemilatticeSup (\u03b1 : Type u) extends Sup \u03b1, PartialOrder \u03b1 where\n  \n  protected le_sup_left : \u2200 a b : \u03b1, a \u2264 a \u2294 b\n  \n  protected le_sup_right : \u2200 a b : \u03b1, b \u2264 a \u2294 b\n  \n  protected sup_le : \u2200 a b c : \u03b1, a \u2264 c \u2192 b \u2264 c \u2192 a \u2294 b \u2264 c", "start": [81, 1], "end": [90, 60], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup.mk'", "code": "def SemilatticeSup.mk' {\u03b1 : Type*} [Sup \u03b1] (sup_comm : \u2200 a b : \u03b1, a \u2294 b = b \u2294 a)\n    (sup_assoc : \u2200 a b c : \u03b1, a \u2294 b \u2294 c = a \u2294 (b \u2294 c)) (sup_idem : \u2200 a : \u03b1, a \u2294 a = a) :\n    SemilatticeSup \u03b1 where\n  sup := (\u00b7 \u2294 \u00b7)\n  le a b := a \u2294 b = b\n  le_refl := sup_idem\n  le_trans a b c hab hbc := by\n    show a \u2294 c = c\n    rw [\u2190 hbc, \u2190 sup_assoc, hab]\n  le_antisymm a b hab hba := by\n    rwa [\u2190 hba, sup_comm]\n  le_sup_left a b := show a \u2294 (a \u2294 b) = a \u2294 b by rw [\u2190 sup_assoc, sup_idem]\n  le_sup_right a b := show b \u2294 (a \u2294 b) = a \u2294 b by rw [sup_comm, sup_assoc, sup_idem]\n  sup_le a b c hac hbc := by\n    show (a \u2294 b) \u2294 c = c\n    rwa [sup_assoc, hbc]", "start": [93, 1], "end": [116, 25], "kind": "commanddeclaration"}, {"full_name": "instSupOrderDual", "code": "instance instSupOrderDual (\u03b1 : Type*) [Inf \u03b1] : Sup \u03b1\u1d52\u1d48 :=\n  \u27e8((\u00b7 \u2293 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\u27e9", "start": [119, 1], "end": [120, 26], "kind": "commanddeclaration"}, {"full_name": "instInfOrderDual", "code": "instance instInfOrderDual (\u03b1 : Type*) [Sup \u03b1] : Inf \u03b1\u1d52\u1d48 :=\n  \u27e8((\u00b7 \u2294 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\u27e9", "start": [122, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "le_sup_left", "code": "@[simp]\ntheorem le_sup_left : a \u2264 a \u2294 b", "start": [129, 1], "end": [131, 33], "kind": "commanddeclaration"}, {"full_name": "le_sup_left'", "code": "theorem le_sup_left' : a \u2264 a \u2294 b", "start": [136, 1], "end": [137, 14], "kind": "commanddeclaration"}, {"full_name": "le_sup_right", "code": "@[simp]\ntheorem le_sup_right : b \u2264 a \u2294 b", "start": [140, 1], "end": [142, 34], "kind": "commanddeclaration"}, {"full_name": "le_sup_right'", "code": "theorem le_sup_right' : b \u2264 a \u2294 b", "start": [147, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "le_sup_of_le_left", "code": "theorem le_sup_of_le_left (h : c \u2264 a) : c \u2264 a \u2294 b", "start": [151, 1], "end": [152, 25], "kind": "commanddeclaration"}, {"full_name": "le_sup_of_le_right", "code": "theorem le_sup_of_le_right (h : c \u2264 b) : c \u2264 a \u2294 b", "start": [155, 1], "end": [156, 26], "kind": "commanddeclaration"}, {"full_name": "lt_sup_of_lt_left", "code": "theorem lt_sup_of_lt_left (h : c < a) : c < a \u2294 b", "start": [159, 1], "end": [160, 25], "kind": "commanddeclaration"}, {"full_name": "lt_sup_of_lt_right", "code": "theorem lt_sup_of_lt_right (h : c < b) : c < a \u2294 b", "start": [163, 1], "end": [164, 26], "kind": "commanddeclaration"}, {"full_name": "sup_le", "code": "theorem sup_le : a \u2264 c \u2192 b \u2264 c \u2192 a \u2294 b \u2264 c", "start": [167, 1], "end": [168, 30], "kind": "commanddeclaration"}, {"full_name": "sup_le_iff", "code": "@[simp]\ntheorem sup_le_iff : a \u2294 b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c", "start": [171, 1], "end": [174, 33], "kind": "commanddeclaration"}, {"full_name": "sup_eq_left", "code": "@[simp]\ntheorem sup_eq_left : a \u2294 b = a \u2194 b \u2264 a", "start": [177, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "sup_eq_right", "code": "@[simp]\ntheorem sup_eq_right : a \u2294 b = b \u2194 a \u2264 b", "start": [182, 1], "end": [184, 43], "kind": "commanddeclaration"}, {"full_name": "left_eq_sup", "code": "@[simp]\ntheorem left_eq_sup : a = a \u2294 b \u2194 b \u2264 a", "start": [187, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "right_eq_sup", "code": "@[simp]\ntheorem right_eq_sup : b = a \u2294 b \u2194 a \u2264 b", "start": [192, 1], "end": [194, 29], "kind": "commanddeclaration"}, {"full_name": "sup_of_le_left", "code": "alias \u27e8_, sup_of_le_left\u27e9 := sup_eq_left", "start": [197, 1], "end": [197, 41], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_of_sup_eq", "code": "alias \u27e8le_of_sup_eq, sup_of_le_right\u27e9 := sup_eq_right", "start": [200, 1], "end": [200, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sup_of_le_right", "code": "alias \u27e8le_of_sup_eq, sup_of_le_right\u27e9 := sup_eq_right", "start": [200, 1], "end": [200, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "left_lt_sup", "code": "@[simp]\ntheorem left_lt_sup : a < a \u2294 b \u2194 \u00acb \u2264 a", "start": [206, 1], "end": [208, 54], "kind": "commanddeclaration"}, {"full_name": "right_lt_sup", "code": "@[simp]\ntheorem right_lt_sup : b < a \u2294 b \u2194 \u00aca \u2264 b", "start": [211, 1], "end": [213, 56], "kind": "commanddeclaration"}, {"full_name": "left_or_right_lt_sup", "code": "theorem left_or_right_lt_sup (h : a \u2260 b) : a < a \u2294 b \u2228 b < a \u2294 b", "start": [216, 1], "end": [217, 59], "kind": "commanddeclaration"}, {"full_name": "le_iff_exists_sup", "code": "theorem le_iff_exists_sup : a \u2264 b \u2194 \u2203 c, b = a \u2294 c", "start": [220, 1], "end": [225, 22], "kind": "commanddeclaration"}, {"full_name": "sup_le_sup", "code": "@[gcongr]\ntheorem sup_le_sup (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : a \u2294 c \u2264 b \u2294 d", "start": [228, 1], "end": [230, 56], "kind": "commanddeclaration"}, {"full_name": "sup_le_sup_left", "code": "@[gcongr]\ntheorem sup_le_sup_left (h\u2081 : a \u2264 b) (c) : c \u2294 a \u2264 c \u2294 b", "start": [233, 1], "end": [235, 23], "kind": "commanddeclaration"}, {"full_name": "sup_le_sup_right", "code": "@[gcongr]\ntheorem sup_le_sup_right (h\u2081 : a \u2264 b) (c) : a \u2294 c \u2264 b \u2294 c", "start": [238, 1], "end": [240, 23], "kind": "commanddeclaration"}, {"full_name": "sup_idem", "code": "theorem sup_idem : a \u2294 a = a", "start": [244, 1], "end": [244, 40], "kind": "commanddeclaration"}, {"full_name": "sup_comm", "code": "theorem sup_comm : a \u2294 b = b \u2294 a", "start": [250, 1], "end": [250, 66], "kind": "commanddeclaration"}, {"full_name": "sup_assoc", "code": "theorem sup_assoc : a \u2294 b \u2294 c = a \u2294 (b \u2294 c)", "start": [256, 1], "end": [257, 75], "kind": "commanddeclaration"}, {"full_name": "sup_left_right_swap", "code": "theorem sup_left_right_swap (a b c : \u03b1) : a \u2294 b \u2294 c = c \u2294 b \u2294 a", "start": [263, 1], "end": [264, 44], "kind": "commanddeclaration"}, {"full_name": "sup_left_idem", "code": "theorem sup_left_idem : a \u2294 (a \u2294 b) = a \u2294 b", "start": [268, 1], "end": [268, 55], "kind": "commanddeclaration"}, {"full_name": "sup_right_idem", "code": "theorem sup_right_idem : a \u2294 b \u2294 b = a \u2294 b", "start": [272, 1], "end": [272, 54], "kind": "commanddeclaration"}, {"full_name": "sup_left_comm", "code": "theorem sup_left_comm (a b c : \u03b1) : a \u2294 (b \u2294 c) = b \u2294 (a \u2294 c)", "start": [275, 1], "end": [276, 49], "kind": "commanddeclaration"}, {"full_name": "sup_right_comm", "code": "theorem sup_right_comm (a b c : \u03b1) : a \u2294 b \u2294 c = a \u2294 c \u2294 b", "start": [279, 1], "end": [280, 45], "kind": "commanddeclaration"}, {"full_name": "sup_sup_sup_comm", "code": "theorem sup_sup_sup_comm (a b c d : \u03b1) : a \u2294 b \u2294 (c \u2294 d) = a \u2294 c \u2294 (b \u2294 d)", "start": [283, 1], "end": [284, 47], "kind": "commanddeclaration"}, {"full_name": "sup_sup_distrib_left", "code": "theorem sup_sup_distrib_left (a b c : \u03b1) : a \u2294 (b \u2294 c) = a \u2294 b \u2294 (a \u2294 c)", "start": [287, 1], "end": [288, 34], "kind": "commanddeclaration"}, {"full_name": "sup_sup_distrib_right", "code": "theorem sup_sup_distrib_right (a b c : \u03b1) : a \u2294 b \u2294 c = a \u2294 c \u2294 (b \u2294 c)", "start": [291, 1], "end": [292, 34], "kind": "commanddeclaration"}, {"full_name": "sup_congr_left", "code": "theorem sup_congr_left (hb : b \u2264 a \u2294 c) (hc : c \u2264 a \u2294 b) : a \u2294 b = a \u2294 c", "start": [295, 1], "end": [296, 59], "kind": "commanddeclaration"}, {"full_name": "sup_congr_right", "code": "theorem sup_congr_right (ha : a \u2264 b \u2294 c) (hb : b \u2264 a \u2294 c) : a \u2294 c = b \u2294 c", "start": [299, 1], "end": [300, 61], "kind": "commanddeclaration"}, {"full_name": "sup_eq_sup_iff_left", "code": "theorem sup_eq_sup_iff_left : a \u2294 b = a \u2294 c \u2194 b \u2264 a \u2294 c \u2227 c \u2264 a \u2294 b", "start": [303, 1], "end": [304, 88], "kind": "commanddeclaration"}, {"full_name": "sup_eq_sup_iff_right", "code": "theorem sup_eq_sup_iff_right : a \u2294 c = b \u2294 c \u2194 a \u2264 b \u2294 c \u2227 b \u2264 a \u2294 c", "start": [307, 1], "end": [308, 87], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_sup_or_lt_sup", "code": "theorem Ne.lt_sup_or_lt_sup (hab : a \u2260 b) : a < a \u2294 b \u2228 b < a \u2294 b", "start": [311, 1], "end": [312, 61], "kind": "commanddeclaration"}, {"full_name": "Monotone.forall_le_of_antitone", "code": "theorem Monotone.forall_le_of_antitone {\u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (hg : Antitone g) (h : f \u2264 g) (m n : \u03b1) : f m \u2264 g n", "start": [315, 1], "end": [321, 31], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup.ext_sup", "code": "theorem SemilatticeSup.ext_sup {\u03b1} {A B : SemilatticeSup \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y)\n    (x y : \u03b1) :\n    (haveI := A; x \u2294 y) = x \u2294 y", "start": [324, 1], "end": [328, 92], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup.ext", "code": "theorem SemilatticeSup.ext {\u03b1} {A B : SemilatticeSup \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) :\n    A = B", "start": [331, 1], "end": [338, 8], "kind": "commanddeclaration"}, {"full_name": "ite_le_sup", "code": "theorem ite_le_sup (s s' : \u03b1) (P : Prop) [Decidable P] : ite P s s' \u2264 s \u2294 s'", "start": [341, 1], "end": [342, 86], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf", "code": "class SemilatticeInf (\u03b1 : Type u) extends Inf \u03b1, PartialOrder \u03b1 where\n  \n  protected inf_le_left : \u2200 a b : \u03b1, a \u2293 b \u2264 a\n  \n  protected inf_le_right : \u2200 a b : \u03b1, a \u2293 b \u2264 b\n  \n  protected le_inf : \u2200 a b c : \u03b1, a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 b \u2293 c", "start": [352, 1], "end": [361, 60], "kind": "commanddeclaration"}, {"full_name": "OrderDual.semilatticeSup", "code": "instance OrderDual.semilatticeSup (\u03b1) [SemilatticeInf \u03b1] : SemilatticeSup \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (PartialOrder \u03b1\u1d52\u1d48)\n  __ := inferInstanceAs (Sup \u03b1\u1d52\u1d48)\n  le_sup_left := @SemilatticeInf.inf_le_left \u03b1 _\n  le_sup_right := @SemilatticeInf.inf_le_right \u03b1 _\n  sup_le := fun _ _ _ hca hcb => @SemilatticeInf.le_inf \u03b1 _ _ _ _ hca hcb", "start": [364, 1], "end": [369, 74], "kind": "commanddeclaration"}, {"full_name": "OrderDual.semilatticeInf", "code": "instance OrderDual.semilatticeInf (\u03b1) [SemilatticeSup \u03b1] : SemilatticeInf \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (PartialOrder \u03b1\u1d52\u1d48)\n  __ := inferInstanceAs (Inf \u03b1\u1d52\u1d48)\n  inf_le_left := @le_sup_left \u03b1 _\n  inf_le_right := @le_sup_right \u03b1 _\n  le_inf := fun _ _ _ hca hcb => @sup_le \u03b1 _ _ _ _ hca hcb", "start": [371, 1], "end": [376, 59], "kind": "commanddeclaration"}, {"full_name": "SemilatticeSup.dual_dual", "code": "theorem SemilatticeSup.dual_dual (\u03b1 : Type*) [H : SemilatticeSup \u03b1] :\n    OrderDual.semilatticeSup \u03b1\u1d52\u1d48 = H", "start": [378, 1], "end": [380, 42], "kind": "commanddeclaration"}, {"full_name": "inf_le_left", "code": "@[simp]\ntheorem inf_le_left : a \u2293 b \u2264 a", "start": [387, 1], "end": [389, 33], "kind": "commanddeclaration"}, {"full_name": "inf_le_left'", "code": "theorem inf_le_left' : a \u2293 b \u2264 a", "start": [394, 1], "end": [395, 33], "kind": "commanddeclaration"}, {"full_name": "inf_le_right", "code": "@[simp]\ntheorem inf_le_right : a \u2293 b \u2264 b", "start": [398, 1], "end": [400, 34], "kind": "commanddeclaration"}, {"full_name": "inf_le_right'", "code": "theorem inf_le_right' : a \u2293 b \u2264 b", "start": [405, 1], "end": [406, 34], "kind": "commanddeclaration"}, {"full_name": "le_inf", "code": "theorem le_inf : a \u2264 b \u2192 a \u2264 c \u2192 a \u2264 b \u2293 c", "start": [409, 1], "end": [410, 30], "kind": "commanddeclaration"}, {"full_name": "inf_le_of_left_le", "code": "theorem inf_le_of_left_le (h : a \u2264 c) : a \u2293 b \u2264 c", "start": [413, 1], "end": [414, 25], "kind": "commanddeclaration"}, {"full_name": "inf_le_of_right_le", "code": "theorem inf_le_of_right_le (h : b \u2264 c) : a \u2293 b \u2264 c", "start": [417, 1], "end": [418, 26], "kind": "commanddeclaration"}, {"full_name": "inf_lt_of_left_lt", "code": "theorem inf_lt_of_left_lt (h : a < c) : a \u2293 b < c", "start": [421, 1], "end": [422, 31], "kind": "commanddeclaration"}, {"full_name": "inf_lt_of_right_lt", "code": "theorem inf_lt_of_right_lt (h : b < c) : a \u2293 b < c", "start": [425, 1], "end": [426, 32], "kind": "commanddeclaration"}, {"full_name": "le_inf_iff", "code": "@[simp]\ntheorem le_inf_iff : a \u2264 b \u2293 c \u2194 a \u2264 b \u2227 a \u2264 c", "start": [429, 1], "end": [431, 26], "kind": "commanddeclaration"}, {"full_name": "inf_eq_left", "code": "@[simp]\ntheorem inf_eq_left : a \u2293 b = a \u2194 a \u2264 b", "start": [434, 1], "end": [436, 43], "kind": "commanddeclaration"}, {"full_name": "inf_eq_right", "code": "@[simp]\ntheorem inf_eq_right : a \u2293 b = b \u2194 b \u2264 a", "start": [439, 1], "end": [441, 43], "kind": "commanddeclaration"}, {"full_name": "left_eq_inf", "code": "@[simp]\ntheorem left_eq_inf : a = a \u2293 b \u2194 a \u2264 b", "start": [444, 1], "end": [446, 28], "kind": "commanddeclaration"}, {"full_name": "right_eq_inf", "code": "@[simp]\ntheorem right_eq_inf : b = a \u2293 b \u2194 b \u2264 a", "start": [449, 1], "end": [451, 29], "kind": "commanddeclaration"}, {"full_name": "le_of_inf_eq", "code": "alias \u27e8le_of_inf_eq, inf_of_le_left\u27e9 := inf_eq_left", "start": [454, 1], "end": [454, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inf_of_le_left", "code": "alias \u27e8le_of_inf_eq, inf_of_le_left\u27e9 := inf_eq_left", "start": [454, 1], "end": [454, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inf_of_le_right", "code": "alias \u27e8_, inf_of_le_right\u27e9 := inf_eq_right", "start": [458, 1], "end": [458, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inf_lt_left", "code": "@[simp]\ntheorem inf_lt_left : a \u2293 b < a \u2194 \u00aca \u2264 b", "start": [463, 1], "end": [465, 25], "kind": "commanddeclaration"}, {"full_name": "inf_lt_right", "code": "@[simp]\ntheorem inf_lt_right : a \u2293 b < b \u2194 \u00acb \u2264 a", "start": [468, 1], "end": [470, 26], "kind": "commanddeclaration"}, {"full_name": "inf_lt_left_or_right", "code": "theorem inf_lt_left_or_right (h : a \u2260 b) : a \u2293 b < a \u2228 a \u2293 b < b", "start": [473, 1], "end": [474, 36], "kind": "commanddeclaration"}, {"full_name": "inf_le_inf", "code": "@[gcongr]\ntheorem inf_le_inf (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : a \u2293 c \u2264 b \u2293 d", "start": [477, 1], "end": [479, 34], "kind": "commanddeclaration"}, {"full_name": "inf_le_inf_right", "code": "@[gcongr]\ntheorem inf_le_inf_right (a : \u03b1) {b c : \u03b1} (h : b \u2264 c) : b \u2293 a \u2264 c \u2293 a", "start": [482, 1], "end": [484, 22], "kind": "commanddeclaration"}, {"full_name": "inf_le_inf_left", "code": "@[gcongr]\ntheorem inf_le_inf_left (a : \u03b1) {b c : \u03b1} (h : b \u2264 c) : a \u2293 b \u2264 a \u2293 c", "start": [487, 1], "end": [489, 22], "kind": "commanddeclaration"}, {"full_name": "inf_idem", "code": "theorem inf_idem : a \u2293 a = a", "start": [493, 1], "end": [494, 20], "kind": "commanddeclaration"}, {"full_name": "inf_comm", "code": "theorem inf_comm : a \u2293 b = b \u2293 a", "start": [500, 1], "end": [501, 22], "kind": "commanddeclaration"}, {"full_name": "inf_assoc", "code": "theorem inf_assoc : a \u2293 b \u2293 c = a \u2293 (b \u2293 c)", "start": [507, 1], "end": [508, 25], "kind": "commanddeclaration"}, {"full_name": "inf_left_right_swap", "code": "theorem inf_left_right_swap (a b c : \u03b1) : a \u2293 b \u2293 c = c \u2293 b \u2293 a", "start": [514, 1], "end": [515, 35], "kind": "commanddeclaration"}, {"full_name": "inf_left_idem", "code": "theorem inf_left_idem : a \u2293 (a \u2293 b) = a \u2293 b", "start": [519, 1], "end": [520, 27], "kind": "commanddeclaration"}, {"full_name": "inf_right_idem", "code": "theorem inf_right_idem : a \u2293 b \u2293 b = a \u2293 b", "start": [524, 1], "end": [525, 28], "kind": "commanddeclaration"}, {"full_name": "inf_left_comm", "code": "theorem inf_left_comm (a b c : \u03b1) : a \u2293 (b \u2293 c) = b \u2293 (a \u2293 c)", "start": [528, 1], "end": [529, 29], "kind": "commanddeclaration"}, {"full_name": "inf_right_comm", "code": "theorem inf_right_comm (a b c : \u03b1) : a \u2293 b \u2293 c = a \u2293 c \u2293 b", "start": [532, 1], "end": [533, 30], "kind": "commanddeclaration"}, {"full_name": "inf_inf_inf_comm", "code": "theorem inf_inf_inf_comm (a b c d : \u03b1) : a \u2293 b \u2293 (c \u2293 d) = a \u2293 c \u2293 (b \u2293 d)", "start": [536, 1], "end": [537, 34], "kind": "commanddeclaration"}, {"full_name": "inf_inf_distrib_left", "code": "theorem inf_inf_distrib_left (a b c : \u03b1) : a \u2293 (b \u2293 c) = a \u2293 b \u2293 (a \u2293 c)", "start": [540, 1], "end": [541, 36], "kind": "commanddeclaration"}, {"full_name": "inf_inf_distrib_right", "code": "theorem inf_inf_distrib_right (a b c : \u03b1) : a \u2293 b \u2293 c = a \u2293 c \u2293 (b \u2293 c)", "start": [544, 1], "end": [545, 37], "kind": "commanddeclaration"}, {"full_name": "inf_congr_left", "code": "theorem inf_congr_left (hb : a \u2293 c \u2264 b) (hc : a \u2293 b \u2264 c) : a \u2293 b = a \u2293 c", "start": [548, 1], "end": [549, 36], "kind": "commanddeclaration"}, {"full_name": "inf_congr_right", "code": "theorem inf_congr_right (h1 : b \u2293 c \u2264 a) (h2 : a \u2293 c \u2264 b) : a \u2293 c = b \u2293 c", "start": [552, 1], "end": [553, 37], "kind": "commanddeclaration"}, {"full_name": "inf_eq_inf_iff_left", "code": "theorem inf_eq_inf_iff_left : a \u2293 b = a \u2293 c \u2194 a \u2293 c \u2264 b \u2227 a \u2293 b \u2264 c", "start": [556, 1], "end": [557, 35], "kind": "commanddeclaration"}, {"full_name": "inf_eq_inf_iff_right", "code": "theorem inf_eq_inf_iff_right : a \u2293 c = b \u2293 c \u2194 b \u2293 c \u2264 a \u2227 a \u2293 c \u2264 b", "start": [560, 1], "end": [561, 36], "kind": "commanddeclaration"}, {"full_name": "Ne.inf_lt_or_inf_lt", "code": "theorem Ne.inf_lt_or_inf_lt : a \u2260 b \u2192 a \u2293 b < a \u2228 a \u2293 b < b", "start": [564, 1], "end": [565, 33], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.ext_inf", "code": "theorem SemilatticeInf.ext_inf {\u03b1} {A B : SemilatticeInf \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y)\n    (x y : \u03b1) :\n    (haveI := A; x \u2293 y) = x \u2293 y", "start": [568, 1], "end": [572, 92], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.ext", "code": "theorem SemilatticeInf.ext {\u03b1} {A B : SemilatticeInf \u03b1}\n    (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) :\n    A = B", "start": [575, 1], "end": [582, 8], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.dual_dual", "code": "theorem SemilatticeInf.dual_dual (\u03b1 : Type*) [H : SemilatticeInf \u03b1] :\n    OrderDual.semilatticeInf \u03b1\u1d52\u1d48 = H", "start": [585, 1], "end": [587, 42], "kind": "commanddeclaration"}, {"full_name": "inf_le_ite", "code": "theorem inf_le_ite (s s' : \u03b1) (P : Prop) [Decidable P] : s \u2293 s' \u2264 ite P s s'", "start": [590, 1], "end": [591, 28], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.mk'", "code": "def SemilatticeInf.mk' {\u03b1 : Type*} [Inf \u03b1] (inf_comm : \u2200 a b : \u03b1, a \u2293 b = b \u2293 a)\n    (inf_assoc : \u2200 a b c : \u03b1, a \u2293 b \u2293 c = a \u2293 (b \u2293 c)) (inf_idem : \u2200 a : \u03b1, a \u2293 a = a) :\n    SemilatticeInf \u03b1 := by\n  haveI : SemilatticeSup \u03b1\u1d52\u1d48 := SemilatticeSup.mk' inf_comm inf_assoc inf_idem\n  haveI i := OrderDual.semilatticeInf \u03b1\u1d52\u1d48\n  exact i", "start": [596, 1], "end": [607, 10], "kind": "commanddeclaration"}, {"full_name": "Lattice", "code": "class Lattice (\u03b1 : Type u) extends SemilatticeSup \u03b1, SemilatticeInf \u03b1", "start": [615, 1], "end": [616, 70], "kind": "commanddeclaration"}, {"full_name": "OrderDual.lattice", "code": "instance OrderDual.lattice (\u03b1) [Lattice \u03b1] : Lattice \u03b1\u1d52\u1d48 :=\n  { OrderDual.semilatticeSup \u03b1, OrderDual.semilatticeInf \u03b1 with }", "start": [619, 1], "end": [620, 66], "kind": "commanddeclaration"}, {"full_name": "semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder", "code": "theorem semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder\n    {\u03b1 : Type*} [Sup \u03b1] [Inf \u03b1]\n    (sup_comm : \u2200 a b : \u03b1, a \u2294 b = b \u2294 a) (sup_assoc : \u2200 a b c : \u03b1, a \u2294 b \u2294 c = a \u2294 (b \u2294 c))\n    (sup_idem : \u2200 a : \u03b1, a \u2294 a = a) (inf_comm : \u2200 a b : \u03b1, a \u2293 b = b \u2293 a)\n    (inf_assoc : \u2200 a b c : \u03b1, a \u2293 b \u2293 c = a \u2293 (b \u2293 c)) (inf_idem : \u2200 a : \u03b1, a \u2293 a = a)\n    (sup_inf_self : \u2200 a b : \u03b1, a \u2294 a \u2293 b = a) (inf_sup_self : \u2200 a b : \u03b1, a \u2293 (a \u2294 b) = a) :\n    @SemilatticeSup.toPartialOrder _ (SemilatticeSup.mk' sup_comm sup_assoc sup_idem) =\n      @SemilatticeInf.toPartialOrder _ (SemilatticeInf.mk' inf_comm inf_assoc inf_idem)", "start": [622, 1], "end": [635, 99], "kind": "commanddeclaration"}, {"full_name": "Lattice.mk'", "code": "def Lattice.mk' {\u03b1 : Type*} [Sup \u03b1] [Inf \u03b1] (sup_comm : \u2200 a b : \u03b1, a \u2294 b = b \u2294 a)\n    (sup_assoc : \u2200 a b c : \u03b1, a \u2294 b \u2294 c = a \u2294 (b \u2294 c)) (inf_comm : \u2200 a b : \u03b1, a \u2293 b = b \u2293 a)\n    (inf_assoc : \u2200 a b c : \u03b1, a \u2293 b \u2293 c = a \u2293 (b \u2293 c)) (sup_inf_self : \u2200 a b : \u03b1, a \u2294 a \u2293 b = a)\n    (inf_sup_self : \u2200 a b : \u03b1, a \u2293 (a \u2294 b) = a) : Lattice \u03b1 :=\n  have sup_idem : \u2200 b : \u03b1, b \u2294 b = b := fun b =>\n    calc\n      b \u2294 b = b \u2294 b \u2293 (b \u2294 b) := by rw [inf_sup_self]\n      _ = b := by rw [sup_inf_self]\n\n  have inf_idem : \u2200 b : \u03b1, b \u2293 b = b := fun b =>\n    calc\n      b \u2293 b = b \u2293 (b \u2294 b \u2293 b) := by rw [sup_inf_self]\n      _ = b := by rw [inf_sup_self]\n\n  let semilatt_inf_inst := SemilatticeInf.mk' inf_comm inf_assoc inf_idem\n  let semilatt_sup_inst := SemilatticeSup.mk' sup_comm sup_assoc sup_idem\n  have partial_order_eq : @SemilatticeSup.toPartialOrder _ semilatt_sup_inst =\n                          @SemilatticeInf.toPartialOrder _ semilatt_inf_inst :=\n    semilatticeSup_mk'_partialOrder_eq_semilatticeInf_mk'_partialOrder _ _ _ _ _ _\n      sup_inf_self inf_sup_self\n  { semilatt_sup_inst, semilatt_inf_inst with\n    inf_le_left := fun a b => by\n      rw [partial_order_eq]\n      apply inf_le_left,\n    inf_le_right := fun a b => by\n      rw [partial_order_eq]\n      apply inf_le_right,\n    le_inf := fun a b c => by\n      rw [partial_order_eq]\n      apply le_inf }", "start": [638, 1], "end": [672, 21], "kind": "commanddeclaration"}, {"full_name": "inf_le_sup", "code": "theorem inf_le_sup : a \u2293 b \u2264 a \u2294 b", "start": [679, 1], "end": [680, 32], "kind": "commanddeclaration"}, {"full_name": "sup_le_inf", "code": "theorem sup_le_inf : a \u2294 b \u2264 a \u2293 b \u2194 a = b", "start": [684, 1], "end": [684, 82], "kind": "commanddeclaration"}, {"full_name": "inf_eq_sup", "code": "@[simp] lemma inf_eq_sup : a \u2293 b = a \u2294 b \u2194 a = b := by rw [\u2190inf_le_sup.ge_iff_eq, sup_le_inf]", "start": [687, 1], "end": [687, 94], "kind": "mathlibtacticlemma"}, {"full_name": "sup_eq_inf", "code": "@[simp] lemma sup_eq_inf : a \u2294 b = a \u2293 b \u2194 a = b := eq_comm.trans inf_eq_sup", "start": [689, 1], "end": [689, 77], "kind": "mathlibtacticlemma"}, {"full_name": "inf_lt_sup", "code": "@[simp] lemma inf_lt_sup : a \u2293 b < a \u2294 b \u2194 a \u2260 b := by rw [inf_le_sup.lt_iff_ne, Ne.def, inf_eq_sup]", "start": [691, 1], "end": [691, 101], "kind": "mathlibtacticlemma"}, {"full_name": "inf_eq_and_sup_eq_iff", "code": "lemma inf_eq_and_sup_eq_iff : a \u2293 b = c \u2227 a \u2294 b = c \u2194 a = c \u2227 b = c := by\n  refine' \u27e8fun h \u21a6 _, _\u27e9\n  { obtain rfl := sup_eq_inf.1 (h.2.trans h.1.symm)\n    simpa using h }\n  { rintro \u27e8rfl, rfl\u27e9\n    exact \u27e8inf_idem, sup_idem\u27e9 }", "start": [694, 1], "end": [699, 33], "kind": "mathlibtacticlemma"}, {"full_name": "sup_inf_le", "code": "theorem sup_inf_le : a \u2294 b \u2293 c \u2264 (a \u2294 b) \u2293 (a \u2294 c)", "start": [708, 1], "end": [709, 74], "kind": "commanddeclaration"}, {"full_name": "le_inf_sup", "code": "theorem le_inf_sup : a \u2293 b \u2294 a \u2293 c \u2264 a \u2293 (b \u2294 c)", "start": [712, 1], "end": [713, 74], "kind": "commanddeclaration"}, {"full_name": "inf_sup_self", "code": "theorem inf_sup_self : a \u2293 (a \u2294 b) = a", "start": [716, 1], "end": [716, 50], "kind": "commanddeclaration"}, {"full_name": "sup_inf_self", "code": "theorem sup_inf_self : a \u2294 a \u2293 b = a", "start": [719, 1], "end": [719, 48], "kind": "commanddeclaration"}, {"full_name": "sup_eq_iff_inf_eq", "code": "theorem sup_eq_iff_inf_eq : a \u2294 b = b \u2194 a \u2293 b = a", "start": [722, 1], "end": [722, 89], "kind": "commanddeclaration"}, {"full_name": "Lattice.ext", "code": "theorem Lattice.ext {\u03b1} {A B : Lattice \u03b1} (H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y) :\n    A = B", "start": [725, 1], "end": [731, 8], "kind": "commanddeclaration"}, {"full_name": "DistribLattice", "code": "class DistribLattice (\u03b1) extends Lattice \u03b1 where\n  \n  protected le_sup_inf : \u2200 x y z : \u03b1, (x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 y \u2293 z", "start": [741, 1], "end": [754, 68], "kind": "commanddeclaration"}, {"full_name": "le_sup_inf", "code": "theorem le_sup_inf : \u2200 {x y z : \u03b1}, (x \u2294 y) \u2293 (x \u2294 z) \u2264 x \u2294 y \u2293 z", "start": [761, 1], "end": [762, 49], "kind": "commanddeclaration"}, {"full_name": "sup_inf_left", "code": "theorem sup_inf_left : x \u2294 y \u2293 z = (x \u2294 y) \u2293 (x \u2294 z)", "start": [765, 1], "end": [766, 36], "kind": "commanddeclaration"}, {"full_name": "sup_inf_right", "code": "theorem sup_inf_right : y \u2293 z \u2294 x = (y \u2294 x) \u2293 (z \u2294 x)", "start": [769, 1], "end": [770, 77], "kind": "commanddeclaration"}, {"full_name": "inf_sup_left", "code": "theorem inf_sup_left : x \u2293 (y \u2294 z) = x \u2293 y \u2294 x \u2293 z", "start": [773, 1], "end": [779, 46], "kind": "commanddeclaration"}, {"full_name": "OrderDual.distribLattice", "code": "instance OrderDual.distribLattice (\u03b1 : Type*) [DistribLattice \u03b1] : DistribLattice \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (Lattice \u03b1\u1d52\u1d48)\n  le_sup_inf := fun _ _ _ => le_of_eq (@inf_sup_left \u03b1).symm", "start": [782, 1], "end": [784, 61], "kind": "commanddeclaration"}, {"full_name": "inf_sup_right", "code": "theorem inf_sup_right : (y \u2294 z) \u2293 x = y \u2293 x \u2294 z \u2293 x", "start": [786, 1], "end": [787, 77], "kind": "commanddeclaration"}, {"full_name": "le_of_inf_le_sup_le", "code": "theorem le_of_inf_le_sup_le (h\u2081 : x \u2293 z \u2264 y \u2293 z) (h\u2082 : x \u2294 z \u2264 y \u2294 z) : x \u2264 y", "start": [790, 1], "end": [797, 44], "kind": "commanddeclaration"}, {"full_name": "eq_of_inf_eq_sup_eq", "code": "theorem eq_of_inf_eq_sup_eq {\u03b1 : Type u} [DistribLattice \u03b1] {a b c : \u03b1} (h\u2081 : b \u2293 a = c \u2293 a)\n    (h\u2082 : b \u2294 a = c \u2294 a) :\n    b = c", "start": [800, 1], "end": [804, 64], "kind": "commanddeclaration"}, {"full_name": "DistribLattice.ofInfSupLe", "code": "@[reducible]\ndef DistribLattice.ofInfSupLe [Lattice \u03b1] (inf_sup_le : \u2200 a b c : \u03b1, a \u2293 (b \u2294 c) \u2264 a \u2293 b \u2294 a \u2293 c) :\n    DistribLattice \u03b1 :=\n  { le_sup_inf := (@OrderDual.distribLattice \u03b1\u1d52\u1d48 {inferInstanceAs (Lattice \u03b1\u1d52\u1d48) with\n      le_sup_inf := inf_sup_le}).le_sup_inf, }", "start": [810, 1], "end": [815, 47], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.toLattice", "code": "instance (priority := 100) LinearOrder.toLattice {\u03b1 : Type u} [o : LinearOrder \u03b1] : Lattice \u03b1 :=\n  { o with\n    sup := max,\n    le_sup_left := le_max_left, le_sup_right := le_max_right, sup_le := fun _ _ _ => max_le,\n    inf := min,\n    inf_le_left := min_le_left, inf_le_right := min_le_right, le_inf := fun _ _ _ => le_min }", "start": [824, 1], "end": [829, 94], "kind": "commanddeclaration"}, {"full_name": "sup_eq_max", "code": "theorem sup_eq_max : a \u2294 b = max a b", "start": [835, 1], "end": [836, 6], "kind": "commanddeclaration"}, {"full_name": "inf_eq_min", "code": "theorem inf_eq_min : a \u2293 b = min a b", "start": [839, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "sup_ind", "code": "theorem sup_ind (a b : \u03b1) {p : \u03b1 \u2192 Prop} (ha : p a) (hb : p b) : p (a \u2294 b)", "start": [843, 1], "end": [845, 24], "kind": "commanddeclaration"}, {"full_name": "le_sup_iff", "code": "@[simp]\ntheorem le_sup_iff : a \u2264 b \u2294 c \u2194 a \u2264 b \u2228 a \u2264 c", "start": [848, 1], "end": [854, 58], "kind": "commanddeclaration"}, {"full_name": "lt_sup_iff", "code": "@[simp]\ntheorem lt_sup_iff : a < b \u2294 c \u2194 a < b \u2228 a < c", "start": [857, 1], "end": [863, 58], "kind": "commanddeclaration"}, {"full_name": "sup_lt_iff", "code": "@[simp]\ntheorem sup_lt_iff : b \u2294 c < a \u2194 b < a \u2227 c < a", "start": [867, 1], "end": [870, 55], "kind": "commanddeclaration"}, {"full_name": "inf_ind", "code": "theorem inf_ind (a b : \u03b1) {p : \u03b1 \u2192 Prop} : p a \u2192 p b \u2192 p (a \u2293 b)", "start": [873, 1], "end": [874, 23], "kind": "commanddeclaration"}, {"full_name": "inf_le_iff", "code": "@[simp]\ntheorem inf_le_iff : b \u2293 c \u2264 a \u2194 b \u2264 a \u2228 c \u2264 a", "start": [877, 1], "end": [879, 26], "kind": "commanddeclaration"}, {"full_name": "inf_lt_iff", "code": "@[simp]\ntheorem inf_lt_iff : b \u2293 c < a \u2194 b < a \u2228 c < a", "start": [882, 1], "end": [884, 26], "kind": "commanddeclaration"}, {"full_name": "lt_inf_iff", "code": "@[simp]\ntheorem lt_inf_iff : a < b \u2293 c \u2194 a < b \u2227 a < c", "start": [887, 1], "end": [889, 26], "kind": "commanddeclaration"}, {"full_name": "max_max_max_comm", "code": "theorem max_max_max_comm : max (max a b) (max c d) = max (max a c) (max b d)", "start": [894, 1], "end": [895, 27], "kind": "commanddeclaration"}, {"full_name": "min_min_min_comm", "code": "theorem min_min_min_comm : min (min a b) (min c d) = min (min a c) (min b d)", "start": [898, 1], "end": [899, 27], "kind": "commanddeclaration"}, {"full_name": "sup_eq_maxDefault", "code": "theorem sup_eq_maxDefault [SemilatticeSup \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] :\n    (\u00b7 \u2294 \u00b7) = (maxDefault : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [904, 1], "end": [910, 87], "kind": "commanddeclaration"}, {"full_name": "inf_eq_minDefault", "code": "theorem inf_eq_minDefault [SemilatticeInf \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] :\n    (\u00b7 \u2293 \u00b7) = (minDefault : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [913, 1], "end": [919, 87], "kind": "commanddeclaration"}, {"full_name": "Lattice.toLinearOrder", "code": "@[reducible]\ndef Lattice.toLinearOrder (\u03b1 : Type u) [Lattice \u03b1] [DecidableEq \u03b1]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    [DecidableRel ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] : LinearOrder \u03b1 :=\n  { \u2039Lattice \u03b1\u203a with\n    decidableLE := \u2039_\u203a,\n    decidableEq := \u2039_\u203a,\n    decidableLT := \u2039_\u203a,\n    le_total := total_of (\u00b7 \u2264 \u00b7),\n    max := (\u00b7 \u2294 \u00b7),\n    max_def := by exact congr_fun\u2082 sup_eq_maxDefault,\n    min := (\u00b7 \u2293 \u00b7),\n    min_def := by exact congr_fun\u2082 inf_eq_minDefault }", "start": [922, 1], "end": [937, 55], "kind": "commanddeclaration"}, {"full_name": "ofDual_inf", "code": "@[simp]\ntheorem ofDual_inf [Sup \u03b1] (a b : \u03b1\u1d52\u1d48) : ofDual (a \u2293 b) = ofDual a \u2294 ofDual b", "start": [956, 1], "end": [958, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_sup", "code": "@[simp]\ntheorem ofDual_sup [Inf \u03b1] (a b : \u03b1\u1d52\u1d48) : ofDual (a \u2294 b) = ofDual a \u2293 ofDual b", "start": [961, 1], "end": [963, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_inf", "code": "@[simp]\ntheorem toDual_inf [Inf \u03b1] (a b : \u03b1) : toDual (a \u2293 b) = toDual a \u2294 toDual b", "start": [966, 1], "end": [968, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_sup", "code": "@[simp]\ntheorem toDual_sup [Sup \u03b1] (a b : \u03b1) : toDual (a \u2294 b) = toDual a \u2293 toDual b", "start": [971, 1], "end": [973, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_min", "code": "@[simp]\ntheorem ofDual_min (a b : \u03b1\u1d52\u1d48) : ofDual (min a b) = max (ofDual a) (ofDual b)", "start": [980, 1], "end": [982, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_max", "code": "@[simp]\ntheorem ofDual_max (a b : \u03b1\u1d52\u1d48) : ofDual (max a b) = min (ofDual a) (ofDual b)", "start": [985, 1], "end": [987, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_min", "code": "@[simp]\ntheorem toDual_min (a b : \u03b1) : toDual (min a b) = max (toDual a) (toDual b)", "start": [990, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_max", "code": "@[simp]\ntheorem toDual_max (a b : \u03b1) : toDual (max a b) = min (toDual a) (toDual b)", "start": [995, 1], "end": [997, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.sup_apply", "code": "@[simp]\ntheorem sup_apply [\u2200 i, Sup (\u03b1' i)] (f g : \u2200 i, \u03b1' i) (i : \u03b9) : (f \u2294 g) i = f i \u2294 g i", "start": [1012, 1], "end": [1014, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.sup_def", "code": "theorem sup_def [\u2200 i, Sup (\u03b1' i)] (f g : \u2200 i, \u03b1' i) : f \u2294 g = fun i => f i \u2294 g i", "start": [1017, 1], "end": [1018, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.inf_apply", "code": "@[simp]\ntheorem inf_apply [\u2200 i, Inf (\u03b1' i)] (f g : \u2200 i, \u03b1' i) (i : \u03b9) : (f \u2293 g) i = f i \u2293 g i", "start": [1024, 1], "end": [1026, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.inf_def", "code": "theorem inf_def [\u2200 i, Inf (\u03b1' i)] (f g : \u2200 i, \u03b1' i) : f \u2293 g = fun i => f i \u2293 g i", "start": [1029, 1], "end": [1030, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.semilatticeSup", "code": "instance semilatticeSup [\u2200 i, SemilatticeSup (\u03b1' i)] : SemilatticeSup (\u2200 i, \u03b1' i) where\n  le_sup_left _ _ _ := le_sup_left\n  le_sup_right _ _ _ := le_sup_right\n  sup_le _ _ _ ac bc i := sup_le (ac i) (bc i)", "start": [1033, 1], "end": [1036, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.semilatticeInf", "code": "instance semilatticeInf [\u2200 i, SemilatticeInf (\u03b1' i)] : SemilatticeInf (\u2200 i, \u03b1' i) where\n  inf_le_left _ _ _ := inf_le_left\n  inf_le_right _ _ _ := inf_le_right\n  le_inf _ _ _ ac bc i := le_inf (ac i) (bc i)", "start": [1038, 1], "end": [1041, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.lattice", "code": "instance lattice [\u2200 i, Lattice (\u03b1' i)] : Lattice (\u2200 i, \u03b1' i) where\n  __ := inferInstanceAs (SemilatticeSup (\u2200 i, \u03b1' i))\n  __ := inferInstanceAs (SemilatticeInf (\u2200 i, \u03b1' i))", "start": [1043, 1], "end": [1045, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.distribLattice", "code": "instance distribLattice [\u2200 i, DistribLattice (\u03b1' i)] : DistribLattice (\u2200 i, \u03b1' i) where\n  le_sup_inf _ _ _ _ := le_sup_inf", "start": [1047, 1], "end": [1048, 35], "kind": "commanddeclaration"}, {"full_name": "Function.update_sup", "code": "theorem update_sup [\u2200 i, SemilatticeSup (\u03c0 i)] (f : \u2200 i, \u03c0 i) (i : \u03b9) (a b : \u03c0 i) :\n    update f i (a \u2294 b) = update f i a \u2294 update f i b", "start": [1057, 1], "end": [1059, 81], "kind": "commanddeclaration"}, {"full_name": "Function.update_inf", "code": "theorem update_inf [\u2200 i, SemilatticeInf (\u03c0 i)] (f : \u2200 i, \u03c0 i) (i : \u03b9) (a b : \u03c0 i) :\n    update f i (a \u2293 b) = update f i a \u2293 update f i b", "start": [1062, 1], "end": [1064, 81], "kind": "commanddeclaration"}, {"full_name": "Monotone.sup", "code": "protected theorem sup [Preorder \u03b1] [SemilatticeSup \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone (f \u2294 g)", "start": [1076, 1], "end": [1079, 62], "kind": "commanddeclaration"}, {"full_name": "Monotone.inf", "code": "protected theorem inf [Preorder \u03b1] [SemilatticeInf \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone (f \u2293 g)", "start": [1082, 1], "end": [1085, 62], "kind": "commanddeclaration"}, {"full_name": "Monotone.max", "code": "protected theorem max [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone fun x => max (f x) (g x)", "start": [1088, 1], "end": [1092, 12], "kind": "commanddeclaration"}, {"full_name": "Monotone.min", "code": "protected theorem min [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (hg : Monotone g) :\n    Monotone fun x => min (f x) (g x)", "start": [1095, 1], "end": [1099, 12], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_map_sup", "code": "theorem le_map_sup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Monotone f) (x y : \u03b1) :\n    f x \u2294 f y \u2264 f (x \u2294 y)", "start": [1102, 1], "end": [1104, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_inf_le", "code": "theorem map_inf_le [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Monotone f) (x y : \u03b1) :\n    f (x \u2293 y) \u2264 f x \u2293 f y", "start": [1107, 1], "end": [1109, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.of_map_inf", "code": "theorem of_map_inf [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x y, f (x \u2293 y) = f x \u2293 f y) : Monotone f", "start": [1112, 1], "end": [1114, 64], "kind": "commanddeclaration"}, {"full_name": "Monotone.of_map_sup", "code": "theorem of_map_sup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x y, f (x \u2294 y) = f x \u2294 f y) : Monotone f", "start": [1117, 1], "end": [1119, 57], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sup", "code": "theorem map_sup [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (x y : \u03b1) :\n    f (x \u2294 y) = f x \u2294 f y", "start": [1124, 1], "end": [1127, 40], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_inf", "code": "theorem map_inf [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) (x y : \u03b1) :\n    f (x \u2293 y) = f x \u2293 f y", "start": [1130, 1], "end": [1132, 22], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.sup", "code": "protected theorem sup [Preorder \u03b1] [SemilatticeSup \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : MonotoneOn f s) (hg : MonotoneOn g s) : MonotoneOn (f \u2294 g) s", "start": [1140, 1], "end": [1143, 58], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.inf", "code": "protected theorem inf [Preorder \u03b1] [SemilatticeInf \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : MonotoneOn f s) (hg : MonotoneOn g s) : MonotoneOn (f \u2293 g) s", "start": [1146, 1], "end": [1149, 29], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.max", "code": "protected theorem max [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => max (f x) (g x)) s", "start": [1152, 1], "end": [1155, 12], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.min", "code": "protected theorem min [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => min (f x) (g x)) s", "start": [1158, 1], "end": [1161, 12], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.of_map_inf", "code": "theorem of_map_inf [SemilatticeInf \u03b1] [SemilatticeInf \u03b2]\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f (x \u2293 y) = f x \u2293 f y) : MonotoneOn f s", "start": [1164, 1], "end": [1166, 60], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.of_map_sup", "code": "theorem of_map_sup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2]\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f (x \u2294 y) = f x \u2294 f y) : MonotoneOn f s", "start": [1169, 1], "end": [1171, 39], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_sup", "code": "theorem map_sup [SemilatticeSup \u03b2] (hf : MonotoneOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    f (x \u2294 y) = f x \u2294 f y", "start": [1176, 1], "end": [1181, 53], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_inf", "code": "theorem map_inf [SemilatticeInf \u03b2] (hf : MonotoneOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    f (x \u2293 y) = f x \u2293 f y", "start": [1184, 1], "end": [1186, 24], "kind": "commanddeclaration"}, {"full_name": "Antitone.sup", "code": "protected theorem sup [Preorder \u03b1] [SemilatticeSup \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone (f \u2294 g)", "start": [1193, 1], "end": [1196, 62], "kind": "commanddeclaration"}, {"full_name": "Antitone.inf", "code": "protected theorem inf [Preorder \u03b1] [SemilatticeInf \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone (f \u2293 g)", "start": [1199, 1], "end": [1202, 62], "kind": "commanddeclaration"}, {"full_name": "Antitone.max", "code": "protected theorem max [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone fun x => max (f x) (g x)", "start": [1205, 1], "end": [1209, 12], "kind": "commanddeclaration"}, {"full_name": "Antitone.min", "code": "protected theorem min [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} (hf : Antitone f)\n    (hg : Antitone g) :\n    Antitone fun x => min (f x) (g x)", "start": [1212, 1], "end": [1216, 12], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sup_le", "code": "theorem map_sup_le [SemilatticeSup \u03b1] [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Antitone f) (x y : \u03b1) :\n    f (x \u2294 y) \u2264 f x \u2293 f y", "start": [1219, 1], "end": [1221, 30], "kind": "commanddeclaration"}, {"full_name": "Antitone.le_map_inf", "code": "theorem le_map_inf [SemilatticeInf \u03b1] [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Antitone f) (x y : \u03b1) :\n    f x \u2294 f y \u2264 f (x \u2293 y)", "start": [1224, 1], "end": [1226, 30], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sup", "code": "theorem map_sup [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) (x y : \u03b1) :\n    f (x \u2294 y) = f x \u2293 f y", "start": [1231, 1], "end": [1233, 28], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_inf", "code": "theorem map_inf [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Antitone f) (x y : \u03b1) :\n    f (x \u2293 y) = f x \u2294 f y", "start": [1236, 1], "end": [1238, 28], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.sup", "code": "protected theorem sup [Preorder \u03b1] [SemilatticeSup \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : AntitoneOn f s) (hg : AntitoneOn g s) : AntitoneOn (f \u2294 g) s", "start": [1246, 1], "end": [1249, 58], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.inf", "code": "protected theorem inf [Preorder \u03b1] [SemilatticeInf \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : AntitoneOn f s) (hg : AntitoneOn g s) : AntitoneOn (f \u2293 g) s", "start": [1252, 1], "end": [1255, 29], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.max", "code": "protected theorem max [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => max (f x) (g x)) s", "start": [1258, 1], "end": [1261, 12], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.min", "code": "protected theorem min [Preorder \u03b1] [LinearOrder \u03b2] {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => min (f x) (g x)) s", "start": [1264, 1], "end": [1267, 12], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.of_map_inf", "code": "theorem of_map_inf [SemilatticeInf \u03b1] [SemilatticeSup \u03b2]\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f (x \u2293 y) = f x \u2294 f y) : AntitoneOn f s", "start": [1270, 1], "end": [1272, 60], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.of_map_sup", "code": "theorem of_map_sup [SemilatticeSup \u03b1] [SemilatticeInf \u03b2]\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f (x \u2294 y) = f x \u2293 f y) : AntitoneOn f s", "start": [1275, 1], "end": [1277, 39], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_sup", "code": "theorem map_sup [SemilatticeInf \u03b2] (hf : AntitoneOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    f (x \u2294 y) = f x \u2293 f y", "start": [1282, 1], "end": [1287, 86], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_inf", "code": "theorem map_inf [SemilatticeSup \u03b2] (hf : AntitoneOn f s) (hx : x \u2208 s) (hy : y \u2208 s) :\n    f (x \u2293 y) = f x \u2294 f y", "start": [1290, 1], "end": [1292, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_sup_mk", "code": "@[simp]\ntheorem mk_sup_mk [Sup \u03b1] [Sup \u03b2] (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) :\n    (a\u2081, b\u2081) \u2294 (a\u2082, b\u2082) = (a\u2081 \u2294 a\u2082, b\u2081 \u2294 b\u2082)", "start": [1312, 1], "end": [1315, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_inf_mk", "code": "@[simp]\ntheorem mk_inf_mk [Inf \u03b1] [Inf \u03b2] (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) :\n    (a\u2081, b\u2081) \u2293 (a\u2082, b\u2082) = (a\u2081 \u2293 a\u2082, b\u2081 \u2293 b\u2082)", "start": [1318, 1], "end": [1321, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_sup", "code": "@[simp]\ntheorem fst_sup [Sup \u03b1] [Sup \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2294 q).fst = p.fst \u2294 q.fst", "start": [1324, 1], "end": [1326, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_inf", "code": "@[simp]\ntheorem fst_inf [Inf \u03b1] [Inf \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2293 q).fst = p.fst \u2293 q.fst", "start": [1329, 1], "end": [1331, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_sup", "code": "@[simp]\ntheorem snd_sup [Sup \u03b1] [Sup \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2294 q).snd = p.snd \u2294 q.snd", "start": [1334, 1], "end": [1336, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_inf", "code": "@[simp]\ntheorem snd_inf [Inf \u03b1] [Inf \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2293 q).snd = p.snd \u2293 q.snd", "start": [1339, 1], "end": [1341, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_sup", "code": "@[simp]\ntheorem swap_sup [Sup \u03b1] [Sup \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2294 q).swap = p.swap \u2294 q.swap", "start": [1344, 1], "end": [1346, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.swap_inf", "code": "@[simp]\ntheorem swap_inf [Inf \u03b1] [Inf \u03b2] (p q : \u03b1 \u00d7 \u03b2) : (p \u2293 q).swap = p.swap \u2293 q.swap", "start": [1349, 1], "end": [1351, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.sup_def", "code": "theorem sup_def [Sup \u03b1] [Sup \u03b2] (p q : \u03b1 \u00d7 \u03b2) : p \u2294 q = (p.fst \u2294 q.fst, p.snd \u2294 q.snd)", "start": [1354, 1], "end": [1355, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.inf_def", "code": "theorem inf_def [Inf \u03b1] [Inf \u03b2] (p q : \u03b1 \u00d7 \u03b2) : p \u2293 q = (p.fst \u2293 q.fst, p.snd \u2293 q.snd)", "start": [1358, 1], "end": [1359, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] : SemilatticeSup (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (PartialOrder (\u03b1 \u00d7 \u03b2))\n  __ := inferInstanceAs (Sup (\u03b1 \u00d7 \u03b2))\n  sup_le _ _ _ h\u2081 h\u2082 := \u27e8sup_le h\u2081.1 h\u2082.1, sup_le h\u2081.2 h\u2082.2\u27e9\n  le_sup_left _ _ := \u27e8le_sup_left, le_sup_left\u27e9\n  le_sup_right _ _ := \u27e8le_sup_right, le_sup_right\u27e9", "start": [1362, 1], "end": [1367, 51], "kind": "commanddeclaration"}, {"full_name": "Prod.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] : SemilatticeInf (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (PartialOrder (\u03b1 \u00d7 \u03b2))\n  __ := inferInstanceAs (Inf (\u03b1 \u00d7 \u03b2))\n  le_inf _ _ _ h\u2081 h\u2082 := \u27e8le_inf h\u2081.1 h\u2082.1, le_inf h\u2081.2 h\u2082.2\u27e9\n  inf_le_left _ _ := \u27e8inf_le_left, inf_le_left\u27e9\n  inf_le_right _ _ := \u27e8inf_le_right, inf_le_right\u27e9", "start": [1369, 1], "end": [1374, 51], "kind": "commanddeclaration"}, {"full_name": "Prod.lattice", "code": "instance lattice [Lattice \u03b1] [Lattice \u03b2] : Lattice (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (SemilatticeSup (\u03b1 \u00d7 \u03b2))\n  __ := inferInstanceAs (SemilatticeInf (\u03b1 \u00d7 \u03b2))", "start": [1376, 1], "end": [1378, 49], "kind": "commanddeclaration"}, {"full_name": "Prod.distribLattice", "code": "instance distribLattice [DistribLattice \u03b1] [DistribLattice \u03b2] : DistribLattice (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (Lattice (\u03b1 \u00d7 \u03b2))\n  le_sup_inf _ _ _ := \u27e8le_sup_inf, le_sup_inf\u27e9", "start": [1380, 1], "end": [1382, 47], "kind": "commanddeclaration"}, {"full_name": "Subtype.semilatticeSup", "code": "@[reducible]\nprotected def semilatticeSup [SemilatticeSup \u03b1] {P : \u03b1 \u2192 Prop}\n    (Psup : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2294 y)) :\n    SemilatticeSup { x : \u03b1 // P x } :=\n  { inferInstanceAs (PartialOrder (Subtype P)) with\n    sup := fun x y => \u27e8x.1 \u2294 y.1, Psup x.2 y.2\u27e9,\n    le_sup_left := fun _ _ => le_sup_left,\n    le_sup_right := fun _ _ => le_sup_right,\n    sup_le := fun _ _ _ h1 h2 => sup_le h1 h2 }", "start": [1393, 1], "end": [1403, 48], "kind": "commanddeclaration"}, {"full_name": "Subtype.semilatticeInf", "code": "@[reducible]\nprotected def semilatticeInf [SemilatticeInf \u03b1] {P : \u03b1 \u2192 Prop}\n    (Pinf : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2293 y)) :\n    SemilatticeInf { x : \u03b1 // P x } :=\n  { inferInstanceAs (PartialOrder (Subtype P)) with\n    inf := fun x y => \u27e8x.1 \u2293 y.1, Pinf x.2 y.2\u27e9,\n    inf_le_left := fun _ _ => inf_le_left,\n    inf_le_right := fun _ _ => inf_le_right,\n    le_inf := fun _ _ _ h1 h2 => le_inf h1 h2 }", "start": [1406, 1], "end": [1416, 48], "kind": "commanddeclaration"}, {"full_name": "Subtype.lattice", "code": "@[reducible]\nprotected def lattice [Lattice \u03b1] {P : \u03b1 \u2192 Prop} (Psup : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2294 y))\n    (Pinf : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2293 y)) : Lattice { x : \u03b1 // P x } :=\n  { Subtype.semilatticeInf Pinf, Subtype.semilatticeSup Psup with }", "start": [1419, 1], "end": [1424, 68], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup [SemilatticeSup \u03b1] {P : \u03b1 \u2192 Prop}\n    (Psup : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2294 y)) (x y : Subtype P) :\n    (haveI := Subtype.semilatticeSup Psup; (x \u2294 y : Subtype P) : \u03b1) = (x \u2294 y : \u03b1)", "start": [1427, 1], "end": [1431, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf [SemilatticeInf \u03b1] {P : \u03b1 \u2192 Prop}\n    (Pinf : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2293 y)) (x y : Subtype P) :\n    (haveI := Subtype.semilatticeInf Pinf; (x \u2293 y : Subtype P) : \u03b1) = (x \u2293 y : \u03b1)", "start": [1434, 1], "end": [1438, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_sup_mk", "code": "@[simp]\ntheorem mk_sup_mk [SemilatticeSup \u03b1] {P : \u03b1 \u2192 Prop}\n    (Psup : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2294 y)) {x y : \u03b1} (hx : P x) (hy : P y) :\n    (haveI := Subtype.semilatticeSup Psup; (\u27e8x, hx\u27e9 \u2294 \u27e8y, hy\u27e9 : Subtype P)) =\n      \u27e8x \u2294 y, Psup hx hy\u27e9", "start": [1441, 1], "end": [1446, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_inf_mk", "code": "@[simp]\ntheorem mk_inf_mk [SemilatticeInf \u03b1] {P : \u03b1 \u2192 Prop}\n    (Pinf : \u2200 \u2983x y\u2984, P x \u2192 P y \u2192 P (x \u2293 y)) {x y : \u03b1} (hx : P x) (hy : P y) :\n    (haveI := Subtype.semilatticeInf Pinf; (\u27e8x, hx\u27e9 \u2293 \u27e8y, hy\u27e9 : Subtype P)) =\n      \u27e8x \u2293 y, Pinf hx hy\u27e9", "start": [1449, 1], "end": [1454, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.semilatticeSup", "code": "@[reducible]\nprotected def Function.Injective.semilatticeSup [Sup \u03b1] [SemilatticeSup \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf_inj : Function.Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) : SemilatticeSup \u03b1 :=\n  { PartialOrder.lift f hf_inj with\n    sup := Sup.sup,\n    le_sup_left := fun a b => by\n      change f a \u2264 f (a \u2294 b)\n      rw [map_sup]\n      exact le_sup_left,\n    le_sup_right := fun a b => by\n      change f b \u2264 f (a \u2294 b)\n      rw [map_sup]\n      exact le_sup_right,\n    sup_le := fun a b c ha hb => by\n      change f (a \u2294 b) \u2264 f c\n      rw [map_sup]\n      exact sup_le ha hb }", "start": [1461, 1], "end": [1480, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.semilatticeInf", "code": "@[reducible]\nprotected def Function.Injective.semilatticeInf [Inf \u03b1] [SemilatticeInf \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf_inj : Function.Injective f) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) : SemilatticeInf \u03b1 :=\n  { PartialOrder.lift f hf_inj with\n    inf := Inf.inf,\n    inf_le_left := fun a b => by\n      change f (a \u2293 b) \u2264 f a\n      rw [map_inf]\n      exact inf_le_left,\n    inf_le_right := fun a b => by\n      change f (a \u2293 b) \u2264 f b\n      rw [map_inf]\n      exact inf_le_right,\n    le_inf := fun a b c ha hb => by\n      change f a \u2264 f (b \u2293 c)\n      rw [map_inf]\n      exact le_inf ha hb }", "start": [1483, 1], "end": [1502, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.lattice", "code": "@[reducible]\nprotected def Function.Injective.lattice [Sup \u03b1] [Inf \u03b1] [Lattice \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf_inj : Function.Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) : Lattice \u03b1 :=\n  { hf_inj.semilatticeSup f map_sup, hf_inj.semilatticeInf f map_inf with }", "start": [1505, 1], "end": [1512, 76], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.distribLattice", "code": "@[reducible]\nprotected def Function.Injective.distribLattice [Sup \u03b1] [Inf \u03b1] [DistribLattice \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf_inj : Function.Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) :\n    DistribLattice \u03b1 :=\n  { hf_inj.lattice f map_sup map_inf with\n    le_sup_inf := fun a b c => by\n      change f ((a \u2294 b) \u2293 (a \u2294 c)) \u2264 f (a \u2294 b \u2293 c)\n      rw [map_inf, map_sup, map_sup, map_sup, map_inf]\n      exact le_sup_inf }", "start": [1515, 1], "end": [1527, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Sigma/Basic.lean", "imports": ["Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ex_of_psig", "code": "theorem ex_of_psig {p : \u03b1 \u2192 Prop} : (\u03a3' x, p x) \u2192 \u2203 x, p x", "start": [14, 1], "end": [15, 23], "kind": "commanddeclaration"}, {"full_name": "Sigma.eq", "code": "protected theorem Sigma.eq {\u03b2 : \u03b1 \u2192 Type v} : \u2200 {p\u2081 p\u2082 : \u03a3 a, \u03b2 a} (h\u2081 : p\u2081.1 = p\u2082.1),\n    (Eq.recOn h\u2081 p\u2081.2 : \u03b2 p\u2082.1) = p\u2082.2 \u2192 p\u2081 = p\u2082", "start": [17, 1], "end": [19, 31], "kind": "commanddeclaration"}, {"full_name": "PSigma.eq", "code": "protected theorem PSigma.eq {\u03b2 : \u03b1 \u2192 Sort v} : \u2200 {p\u2081 p\u2082 : \u03a3' a, \u03b2 a} (h\u2081 : p\u2081.1 = p\u2082.1),\n    (Eq.recOn h\u2081 p\u2081.2 : \u03b2 p\u2082.1) = p\u2082.2 \u2192 p\u2081 = p\u2082", "start": [21, 1], "end": [23, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sum/Basic.lean", "imports": ["Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sum.exists_sum", "code": "theorem exists_sum {\u03b3 : \u03b1 \u2295 \u03b2 \u2192 Sort*} (p : (\u2200 ab, \u03b3 ab) \u2192 Prop) :\n    (\u2203 fab, p fab) \u2194 (\u2203 fa fb, p (Sum.rec fa fb))", "start": [26, 1], "end": [29, 7], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_injective", "code": "theorem inl_injective : Function.Injective (inl : \u03b1 \u2192 Sum \u03b1 \u03b2)", "start": [31, 1], "end": [31, 84], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_injective", "code": "theorem inr_injective : Function.Injective (inr : \u03b2 \u2192 Sum \u03b1 \u03b2)", "start": [34, 1], "end": [34, 84], "kind": "commanddeclaration"}, {"full_name": "Sum.sum_rec_congr", "code": "theorem sum_rec_congr (P : \u03b1 \u2295 \u03b2 \u2192 Sort*) (f : \u2200 i, P (inl i)) (g : \u2200 i, P (inr i))\n    {x y : \u03b1 \u2295 \u03b2} (h : x = y) :\n    @Sum.rec _ _ _ f g x = cast (congr_arg P h.symm) (@Sum.rec _ _ _ f g y)", "start": [37, 1], "end": [39, 95], "kind": "commanddeclaration"}, {"full_name": "Sum.eq_left_iff_getLeft_eq", "code": "theorem eq_left_iff_getLeft_eq {a : \u03b1} : x = inl a \u2194 \u2203 h, x.getLeft h = a", "start": [53, 1], "end": [54, 19], "kind": "commanddeclaration"}, {"full_name": "Sum.eq_right_iff_getRight_eq", "code": "theorem eq_right_iff_getRight_eq {b : \u03b2} : x = inr b \u2194 \u2203 h, x.getRight h = b", "start": [56, 1], "end": [57, 19], "kind": "commanddeclaration"}, {"full_name": "Sum.getLeft_eq_getLeft?", "code": "theorem getLeft_eq_getLeft? (h\u2081 : x.isLeft) (h\u2082 : x.getLeft?.isSome) :\n    x.getLeft h\u2081 = x.getLeft?.get h\u2082", "start": [62, 1], "end": [63, 73], "kind": "commanddeclaration"}, {"full_name": "Sum.getRight_eq_getRight?", "code": "theorem getRight_eq_getRight? (h\u2081 : x.isRight) (h\u2082 : x.getRight?.isSome) :\n    x.getRight h\u2081 = x.getRight?.get h\u2082", "start": [65, 1], "end": [66, 76], "kind": "commanddeclaration"}, {"full_name": "Sum.isSome_getLeft?_iff_isLeft", "code": "@[simp] theorem isSome_getLeft?_iff_isLeft : x.getLeft?.isSome \u2194 x.isLeft", "start": [77, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.isSome_getRight?_iff_isRight", "code": "@[simp] theorem isSome_getRight?_iff_isRight : x.getRight?.isSome \u2194 x.isRight", "start": [80, 1], "end": [81, 51], "kind": "commanddeclaration"}, {"full_name": "Sum.update_elim_inl", "code": "@[simp]\ntheorem update_elim_inl [DecidableEq \u03b1] [DecidableEq (Sum \u03b1 \u03b2)] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} {i : \u03b1}\n    {x : \u03b3} : update (Sum.elim f g) (inl i) x = Sum.elim (update f i x) g", "start": [112, 1], "end": [115, 72], "kind": "commanddeclaration"}, {"full_name": "Sum.update_elim_inr", "code": "@[simp]\ntheorem update_elim_inr [DecidableEq \u03b2] [DecidableEq (Sum \u03b1 \u03b2)] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} {i : \u03b2}\n    {x : \u03b3} : update (Sum.elim f g) (inr i) x = Sum.elim f (update g i x)", "start": [118, 1], "end": [121, 72], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inl_comp_inl", "code": "@[simp]\ntheorem update_inl_comp_inl [DecidableEq \u03b1] [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b1}\n    {x : \u03b3} : update f (inl i) x \u2218 inl = update (f \u2218 inl) i x", "start": [124, 1], "end": [127, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inl_apply_inl", "code": "@[simp]\ntheorem update_inl_apply_inl [DecidableEq \u03b1] [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i j : \u03b1}\n    {x : \u03b3} : update f (inl i) x (inl j) = update (f \u2218 inl) i x j", "start": [130, 1], "end": [133, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inl_comp_inr", "code": "@[simp]\ntheorem update_inl_comp_inr [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b1} {x : \u03b3} :\n    update f (inl i) x \u2218 inr = f \u2218 inr", "start": [136, 1], "end": [139, 55], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inl_apply_inr", "code": "theorem update_inl_apply_inr [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b1} {j : \u03b2} {x : \u03b3} :\n    update f (inl i) x (inr j) = f (inr j)", "start": [142, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inr_comp_inl", "code": "@[simp]\ntheorem update_inr_comp_inl [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b2} {x : \u03b3} :\n    update f (inr i) x \u2218 inl = f \u2218 inl", "start": [147, 1], "end": [150, 55], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inr_apply_inl", "code": "theorem update_inr_apply_inl [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b1} {j : \u03b2} {x : \u03b3} :\n    update f (inr j) x (inl i) = f (inl i)", "start": [153, 1], "end": [155, 39], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inr_comp_inr", "code": "@[simp]\ntheorem update_inr_comp_inr [DecidableEq \u03b2] [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i : \u03b2}\n    {x : \u03b3} : update f (inr i) x \u2218 inr = update (f \u2218 inr) i x", "start": [158, 1], "end": [161, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.update_inr_apply_inr", "code": "@[simp]\ntheorem update_inr_apply_inr [DecidableEq \u03b2] [DecidableEq (Sum \u03b1 \u03b2)] {f : Sum \u03b1 \u03b2 \u2192 \u03b3} {i j : \u03b2}\n    {x : \u03b3} : update f (inr i) x (inr j) = update (f \u2218 inr) i x j", "start": [164, 1], "end": [167, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_leftInverse", "code": "@[simp]\ntheorem swap_leftInverse : Function.LeftInverse (@swap \u03b1 \u03b2) swap", "start": [176, 1], "end": [178, 12], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_rightInverse", "code": "@[simp]\ntheorem swap_rightInverse : Function.RightInverse (@swap \u03b1 \u03b2) swap", "start": [181, 1], "end": [183, 12], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.sum_elim", "code": "theorem Injective.sum_elim {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (hf : Injective f) (hg : Injective g)\n    (hfg : \u2200 a b, f a \u2260 g b) : Injective (Sum.elim f g)", "start": [231, 1], "end": [236, 45], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.sum_map", "code": "theorem Injective.sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b1' \u2192 \u03b2'} (hf : Injective f) (hg : Injective g) :\n    Injective (Sum.map f g)", "start": [239, 1], "end": [242, 56], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.sum_map", "code": "theorem Surjective.sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b1' \u2192 \u03b2'} (hf : Surjective f) (hg : Surjective g) :\n    Surjective (Sum.map f g)", "start": [245, 1], "end": [252, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.sum_map", "code": "theorem Bijective.sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b1' \u2192 \u03b2'} (hf : Bijective f) (hg : Bijective g) :\n    Bijective (Sum.map f g)", "start": [255, 1], "end": [257, 75], "kind": "commanddeclaration"}, {"full_name": "Sum.map_injective", "code": "@[simp]\ntheorem map_injective {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Injective (Sum.map f g) \u2194 Injective f \u2227 Injective g", "start": [266, 1], "end": [272, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.map_surjective", "code": "@[simp]\ntheorem map_surjective {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Surjective (Sum.map f g) \u2194 Surjective f \u2227 Surjective g", "start": [275, 1], "end": [287, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.map_bijective", "code": "@[simp]\ntheorem map_bijective {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} :\n    Bijective (Sum.map f g) \u2194 Bijective f \u2227 Bijective g", "start": [290, 1], "end": [293, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_update_left", "code": "theorem elim_update_left [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (i : \u03b1) (c : \u03b3) :\n    Sum.elim (Function.update f i c) g = Function.update (Sum.elim f g) (inl i) c", "start": [299, 1], "end": [307, 9], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_update_right", "code": "theorem elim_update_right [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (i : \u03b2) (c : \u03b3) :\n    Sum.elim f (Function.update g i c) = Function.update (Sum.elim f g) (inr i) c", "start": [310, 1], "end": [318, 15], "kind": "commanddeclaration"}, {"full_name": "Sum3.in\u2080", "code": "@[match_pattern, simp, reducible]\ndef in\u2080 (a : \u03b1) : Sum \u03b1 (Sum \u03b2 \u03b3) :=\n  inl a", "start": [331, 1], "end": [334, 8], "kind": "commanddeclaration"}, {"full_name": "Sum3.in\u2081", "code": "@[match_pattern, simp, reducible]\ndef in\u2081 (b : \u03b2) : Sum \u03b1 (Sum \u03b2 \u03b3) :=\n  inr <| inl b", "start": [337, 1], "end": [340, 15], "kind": "commanddeclaration"}, {"full_name": "Sum3.in\u2082", "code": "@[match_pattern, simp, reducible]\ndef in\u2082 (c : \u03b3) : Sum \u03b1 (Sum \u03b2 \u03b3) :=\n  inr <| inr c", "start": [343, 1], "end": [346, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Lift.lean", "imports": ["Mathlib/Tactic/PermuteGoals.lean", "Mathlib/Init/Data/Int/Order.lean", "Mathlib/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CanLift", "code": "class CanLift (\u03b1 \u03b2 : Sort*) (coe : outParam <| \u03b2 \u2192 \u03b1) (cond : outParam <| \u03b1 \u2192 Prop) : Prop where\n  \n  prf : \u2200 x : \u03b1, cond x \u2192 \u2203 y : \u03b2, coe y = x", "start": [21, 1], "end": [25, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.canLift", "code": "instance Pi.canLift (\u03b9 : Sort*) (\u03b1 \u03b2 : \u03b9 \u2192 Sort*) (coe : \u2200 i, \u03b2 i \u2192 \u03b1 i) (P : \u2200 i, \u03b1 i \u2192 Prop)\n    [\u2200 i, CanLift (\u03b1 i) (\u03b2 i) (coe i) (P i)] :\n    CanLift (\u2200 i, \u03b1 i) (\u2200 i, \u03b2 i) (fun f i \u21a6 coe i (f i)) fun f \u21a6 \u2200 i, P i (f i) where\n  prf f hf := \u27e8fun i => Classical.choose (CanLift.prf (f i) (hf i)),\n    funext fun i => Classical.choose_spec (CanLift.prf (f i) (hf i))\u27e9", "start": [31, 1], "end": [36, 70], "kind": "commanddeclaration"}, {"full_name": "Subtype.exists_pi_extension", "code": "theorem Subtype.exists_pi_extension {\u03b9 : Sort*} {\u03b1 : \u03b9 \u2192 Sort*} [ne : \u2200 i, Nonempty (\u03b1 i)]\n    {p : \u03b9 \u2192 Prop} (f : \u2200 i : Subtype p, \u03b1 i) :\n    \u2203 g : \u2200 i : \u03b9, \u03b1 i, (fun i : Subtype p => g i) = f", "start": [39, 1], "end": [44, 32], "kind": "commanddeclaration"}, {"full_name": "PiSubtype.canLift", "code": "instance PiSubtype.canLift (\u03b9 : Sort*) (\u03b1 : \u03b9 \u2192 Sort*) [\u2200 i, Nonempty (\u03b1 i)] (p : \u03b9 \u2192 Prop) :\n    CanLift (\u2200 i : Subtype p, \u03b1 i) (\u2200 i, \u03b1 i) (fun f i => f i) fun _ => True where\n  prf f _ := Subtype.exists_pi_extension f", "start": [47, 1], "end": [49, 43], "kind": "commanddeclaration"}, {"full_name": "PiSubtype.canLift'", "code": "instance PiSubtype.canLift' (\u03b9 : Sort*) (\u03b1 : Sort*) [Nonempty \u03b1] (p : \u03b9 \u2192 Prop) :\n    CanLift (Subtype p \u2192 \u03b1) (\u03b9 \u2192 \u03b1) (fun f i => f i) fun _ => True :=\n  PiSubtype.canLift \u03b9 (fun _ => \u03b1) p", "start": [53, 1], "end": [55, 37], "kind": "commanddeclaration"}, {"full_name": "Subtype.canLift", "code": "instance Subtype.canLift {\u03b1 : Sort*} (p : \u03b1 \u2192 Prop) :\n    CanLift \u03b1 { x // p x } Subtype.val p where prf a ha :=\n  \u27e8\u27e8a, ha\u27e9, rfl\u27e9", "start": [58, 1], "end": [60, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Lift.getInst", "code": "def Lift.getInst (old_tp new_tp : Expr) : MetaM (Expr \u00d7 Expr \u00d7 Expr) := do\n  let coe \u2190 mkFreshExprMVar (some $ .forallE `a new_tp old_tp .default)\n  let p \u2190 mkFreshExprMVar (some $ .forallE `a old_tp (.sort .zero) .default)\n  let inst_type \u2190 mkAppM ``CanLift #[old_tp, new_tp, coe, p]\n  let inst \u2190 synthInstance inst_type return (\u2190 instantiateMVars p, \u2190 instantiateMVars coe, \u2190 instantiateMVars inst)", "start": [108, 1], "end": [114, 81], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Lift.main", "code": "def Lift.main (e t : TSyntax `term) (hUsing : Option (TSyntax `term))\n    (newVarName newEqName : Option (TSyntax `ident)) (keepUsing : Bool) : TacticM Unit :=\n    withMainContext do\n  let isNewVar := !newVarName.isNone\n  let newEqName := (newEqName.map Syntax.getId).getD `rfl\n  let isNewEq := newEqName != `rfl\n  let e \u2190 elabTerm e none\n  let goal \u2190 getMainGoal\n  if !(\u2190 inferType (\u2190 instantiateMVars (\u2190 goal.getType))).isProp then throwError\n    \"lift tactic failed. Tactic is only applicable when the target is a proposition.\"\n  if newVarName == none \u2227 !e.isFVar then throwError\n    \"lift tactic failed. When lifting an expression, a new variable name must be given\"\n  let (p, coe, inst) \u2190 Lift.getInst (\u2190 inferType e) (\u2190 Term.elabType t)\n  let prf \u2190 match hUsing with\n    | some h => elabTermEnsuringType h (p.betaRev #[e])\n    | none => mkFreshExprMVar (some (p.betaRev #[e]))\n  let newVarName \u2190 match newVarName with\n                 | some v => pure v.getId\n                 | none   => e.fvarId!.getUserName\n  let prfEx \u2190 mkAppOptM ``CanLift.prf #[none, none, coe, p, inst, e, prf]\n  let prfEx \u2190 instantiateMVars prfEx\n  let prfSyn \u2190 prfEx.toSyntax\n  let newEqName \u2190 if isNewVar && !isNewEq then withMainContext <| getUnusedUserName `tmpVar\n               else pure newEqName\n  let newEqIdent := mkIdent newEqName\n  replaceMainGoal (\u2190 Std.Tactic.RCases.rcases #[(none, prfSyn)]\n    (.tuple Syntax.missing <| [newVarName, newEqName].map (.one Syntax.missing)) goal)\n  if isNewVar then\n    for decl in \u2190getLCtx do\n      if decl.userName != newEqName then\n        let declIdent := mkIdent decl.userName\n        evalTactic (\u2190 `(tactic| simp (config := {failIfUnchanged := false})\n          only [\u2190 $newEqIdent] at $declIdent $declIdent))\n    evalTactic (\u2190 `(tactic| simp (config := {failIfUnchanged := false}) only [\u2190 $newEqIdent]))\n  if isNewVar && !isNewEq then\n    evalTactic (\u2190 `(tactic| clear $newEqIdent))\n  if prf.isFVar && !keepUsing then\n    let some hUsingStx := hUsing | throwError \"lift tactic failed: unreachable code was reached\"\n    evalTactic (\u2190 `(tactic| clear $hUsingStx))\n    evalTactic (\u2190 `(tactic| try clear $hUsingStx))\n  if hUsing.isNone then withMainContext <| setGoals (prf.mvarId! :: (\u2190 getGoals))", "start": [116, 1], "end": [168, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sigma/Basic.lean", "imports": ["Mathlib/Init/Function.lean", "lake-packages/std/Std/Tactic/Ext.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sigma.instInhabitedSigma", "code": "instance instInhabitedSigma [Inhabited \u03b1] [Inhabited (\u03b2 default)] : Inhabited (Sigma \u03b2) :=\n  \u27e8\u27e8default, default\u27e9\u27e9", "start": [41, 1], "end": [42, 23], "kind": "commanddeclaration"}, {"full_name": "Sigma.instDecidableEqSigma", "code": "instance instDecidableEqSigma [h\u2081 : DecidableEq \u03b1] [h\u2082 : \u2200 a, DecidableEq (\u03b2 a)] :\n    DecidableEq (Sigma \u03b2)\n  | \u27e8a\u2081, b\u2081\u27e9, \u27e8a\u2082, b\u2082\u27e9 =>\n    match a\u2081, b\u2081, a\u2082, b\u2082, h\u2081 a\u2081 a\u2082 with\n    | _, b\u2081, _, b\u2082, isTrue (Eq.refl _) =>\n      match b\u2081, b\u2082, h\u2082 _ b\u2081 b\u2082 with\n      | _, _, isTrue (Eq.refl _) => isTrue rfl\n      | _, _, isFalse n => isFalse fun h \u21a6 Sigma.noConfusion h fun _ e\u2082 \u21a6 n <| eq_of_heq e\u2082\n    | _, _, _, _, isFalse n => isFalse fun h \u21a6 Sigma.noConfusion h fun e\u2081 _ \u21a6 n e\u2081", "start": [44, 1], "end": [52, 83], "kind": "commanddeclaration"}, {"full_name": "Sigma.mk.inj_iff", "code": "@[simp] theorem mk.inj_iff {a\u2081 a\u2082 : \u03b1} {b\u2081 : \u03b2 a\u2081} {b\u2082 : \u03b2 a\u2082} :\n    Sigma.mk a\u2081 b\u2081 = \u27e8a\u2082, b\u2082\u27e9 \u2194 a\u2081 = a\u2082 \u2227 HEq b\u2081 b\u2082", "start": [55, 1], "end": [59, 49], "kind": "commanddeclaration"}, {"full_name": "Sigma.eta", "code": "@[simp]\ntheorem eta : \u2200 x : \u03a3a, \u03b2 a, Sigma.mk x.1 x.2 = x", "start": [62, 1], "end": [64, 18], "kind": "commanddeclaration"}, {"full_name": "Sigma.ext", "code": "@[ext]\ntheorem ext {x\u2080 x\u2081 : Sigma \u03b2} (h\u2080 : x\u2080.1 = x\u2081.1) (h\u2081 : HEq x\u2080.2 x\u2081.2) : x\u2080 = x\u2081", "start": [67, 1], "end": [69, 46], "kind": "commanddeclaration"}, {"full_name": "Sigma.ext_iff", "code": "theorem ext_iff {x\u2080 x\u2081 : Sigma \u03b2} : x\u2080 = x\u2081 \u2194 x\u2080.1 = x\u2081.1 \u2227 HEq x\u2080.2 x\u2081.2", "start": [72, 1], "end": [73, 45], "kind": "commanddeclaration"}, {"full_name": "Function.eq_of_sigmaMk_comp", "code": "theorem _root_.Function.eq_of_sigmaMk_comp {\u03b3 : Type*} [Nonempty \u03b3]\n    {a b : \u03b1} {f : \u03b3 \u2192 \u03b2 a} {g : \u03b3 \u2192 \u03b2 b} (h : Sigma.mk a \u2218 f = Sigma.mk b \u2218 g) :\n    a = b \u2227 HEq f g", "start": [76, 1], "end": [82, 38], "kind": "commanddeclaration"}, {"full_name": "Sigma.subtype_ext", "code": "@[ext]\ntheorem subtype_ext {\u03b2 : Type*} {p : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    \u2200 {x\u2080 x\u2081 : \u03a3a, Subtype (p a)}, x\u2080.fst = x\u2081.fst \u2192 (x\u2080.snd : \u03b2) = x\u2081.snd \u2192 x\u2080 = x\u2081", "start": [84, 1], "end": [88, 42], "kind": "commanddeclaration"}, {"full_name": "Sigma.subtype_ext_iff", "code": "theorem subtype_ext_iff {\u03b2 : Type*} {p : \u03b1 \u2192 \u03b2 \u2192 Prop} {x\u2080 x\u2081 : \u03a3a, Subtype (p a)} :\n    x\u2080 = x\u2081 \u2194 x\u2080.fst = x\u2081.fst \u2227 (x\u2080.snd : \u03b2) = x\u2081.snd", "start": [91, 1], "end": [93, 61], "kind": "commanddeclaration"}, {"full_name": "Sigma.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : (\u03a3a, \u03b2 a) \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 a b, p \u27e8a, b\u27e9", "start": [96, 1], "end": [98, 47], "kind": "commanddeclaration"}, {"full_name": "Sigma.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : (\u03a3a, \u03b2 a) \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p \u27e8a, b\u27e9", "start": [101, 1], "end": [103, 61], "kind": "commanddeclaration"}, {"full_name": "Sigma.exists'", "code": "lemma exists' {p : \u2200 a, \u03b2 a \u2192 Prop} : (\u2203 a b, p a b) \u2194 \u2203 x : \u03a3 a, \u03b2 a, p x.1 x.2 :=\n(Sigma.exists (p := \u03bb x \u21a6 p x.1 x.2)).symm", "start": [106, 1], "end": [107, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Sigma.forall'", "code": "lemma forall' {p : \u2200 a, \u03b2 a \u2192 Prop} : (\u2200 a b, p a b) \u2194 \u2200 x : \u03a3 a, \u03b2 a, p x.1 x.2 :=\n(Sigma.forall (p := \u03bb x \u21a6 p x.1 x.2)).symm", "start": [109, 1], "end": [110, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Sigma.map", "code": "def map (f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082) (f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)) (x : Sigma \u03b2\u2081) : Sigma \u03b2\u2082 :=\n  \u27e8f\u2081 x.1, f\u2082 x.1 x.2\u27e9", "start": [112, 1], "end": [114, 23], "kind": "commanddeclaration"}, {"full_name": "Sigma.map_mk", "code": "lemma map_mk (f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082) (f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)) (x : \u03b1\u2081) (y : \u03b2\u2081 x) :\n    map f\u2081 f\u2082 \u27e8x, y\u27e9 = \u27e8f\u2081 x, f\u2082 x y\u27e9 := rfl", "start": [117, 1], "end": [118, 45], "kind": "mathlibtacticlemma"}, {"full_name": "sigma_mk_injective", "code": "theorem sigma_mk_injective {i : \u03b1} : Function.Injective (@Sigma.mk \u03b1 \u03b2 i)", "start": [121, 1], "end": [122, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.sigma_map", "code": "theorem Function.Injective.sigma_map {f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082} {f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)}\n    (h\u2081 : Function.Injective f\u2081) (h\u2082 : \u2200 a, Function.Injective (f\u2082 a)) :\n    Function.Injective (Sigma.map f\u2081 f\u2082)", "start": [125, 1], "end": [131, 8], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.of_sigma_map", "code": "theorem Function.Injective.of_sigma_map {f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082} {f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)}\n    (h : Function.Injective (Sigma.map f\u2081 f\u2082)) (a : \u03b1\u2081) : Function.Injective (f\u2082 a)", "start": [134, 1], "end": [137, 73], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.sigma_map_iff", "code": "theorem Function.Injective.sigma_map_iff {f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082} {f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)}\n    (h\u2081 : Function.Injective f\u2081) :\n    Function.Injective (Sigma.map f\u2081 f\u2082) \u2194 \u2200 a, Function.Injective (f\u2082 a)", "start": [140, 1], "end": [143, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.sigma_map", "code": "theorem Function.Surjective.sigma_map {f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082} {f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)}\n    (h\u2081 : Function.Surjective f\u2081) (h\u2082 : \u2200 a, Function.Surjective (f\u2082 a)) :\n    Function.Surjective (Sigma.map f\u2081 f\u2082)", "start": [146, 1], "end": [150, 54], "kind": "commanddeclaration"}, {"full_name": "Sigma.curry", "code": "def Sigma.curry {\u03b3 : \u2200 a, \u03b2 a \u2192 Type*} (f : \u2200 x : Sigma \u03b2, \u03b3 x.1 x.2) (x : \u03b1) (y : \u03b2 x) : \u03b3 x y :=\n  f \u27e8x, y\u27e9", "start": [153, 1], "end": [157, 11], "kind": "commanddeclaration"}, {"full_name": "Sigma.uncurry", "code": "def Sigma.uncurry {\u03b3 : \u2200 a, \u03b2 a \u2192 Type*} (f : \u2200 (x) (y : \u03b2 x), \u03b3 x y) (x : Sigma \u03b2) : \u03b3 x.1 x.2 :=\n  f x.1 x.2", "start": [160, 1], "end": [164, 12], "kind": "commanddeclaration"}, {"full_name": "Sigma.uncurry_curry", "code": "@[simp]\ntheorem Sigma.uncurry_curry {\u03b3 : \u2200 a, \u03b2 a \u2192 Type*} (f : \u2200 x : Sigma \u03b2, \u03b3 x.1 x.2) :\n    Sigma.uncurry (Sigma.curry f) = f", "start": [167, 1], "end": [170, 26], "kind": "commanddeclaration"}, {"full_name": "Sigma.curry_uncurry", "code": "@[simp]\ntheorem Sigma.curry_uncurry {\u03b3 : \u2200 a, \u03b2 a \u2192 Type*} (f : \u2200 (x) (y : \u03b2 x), \u03b3 x y) :\n    Sigma.curry (Sigma.uncurry f) = f", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.toSigma", "code": "def Prod.toSigma {\u03b1 \u03b2} (p : \u03b1 \u00d7 \u03b2) : \u03a3_ : \u03b1, \u03b2 :=\n  \u27e8p.1, p.2\u27e9", "start": [179, 1], "end": [181, 13], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_comp_toSigma", "code": "@[simp]\ntheorem Prod.fst_comp_toSigma {\u03b1 \u03b2} : Sigma.fst \u2218 @Prod.toSigma \u03b1 \u03b2 = Prod.fst", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_toSigma", "code": "@[simp]\ntheorem Prod.fst_toSigma {\u03b1 \u03b2} (x : \u03b1 \u00d7 \u03b2) : (Prod.toSigma x).fst = x.fst", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_toSigma", "code": "@[simp]\ntheorem Prod.snd_toSigma {\u03b1 \u03b2} (x : \u03b1 \u00d7 \u03b2) : (Prod.toSigma x).snd = x.snd", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.toSigma_mk", "code": "@[simp]\ntheorem Prod.toSigma_mk {\u03b1 \u03b2} (x : \u03b1) (y : \u03b2) : (x, y).toSigma = \u27e8x, y\u27e9", "start": [199, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "PSigma.elim", "code": "def elim {\u03b3} (f : \u2200 a, \u03b2 a \u2192 \u03b3) (a : PSigma \u03b2) : \u03b3 :=\n  PSigma.casesOn a f", "start": [212, 1], "end": [214, 21], "kind": "commanddeclaration"}, {"full_name": "PSigma.elim_val", "code": "@[simp]\ntheorem elim_val {\u03b3} (f : \u2200 a, \u03b2 a \u2192 \u03b3) (a b) : PSigma.elim f \u27e8a, b\u27e9 = f a b", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "PSigma.decidableEq", "code": "instance decidableEq [h\u2081 : DecidableEq \u03b1] [h\u2082 : \u2200 a, DecidableEq (\u03b2 a)] : DecidableEq (PSigma \u03b2)\n  | \u27e8a\u2081, b\u2081\u27e9, \u27e8a\u2082, b\u2082\u27e9 =>\n    match a\u2081, b\u2081, a\u2082, b\u2082, h\u2081 a\u2081 a\u2082 with\n    | _, b\u2081, _, b\u2082, isTrue (Eq.refl _) =>\n      match b\u2081, b\u2082, h\u2082 _ b\u2081 b\u2082 with\n      | _, _, isTrue (Eq.refl _) => isTrue rfl\n      | _, _, isFalse n => isFalse fun h \u21a6 PSigma.noConfusion h fun _ e\u2082 \u21a6 n <| eq_of_heq e\u2082\n    | _, _, _, _, isFalse n => isFalse fun h \u21a6 PSigma.noConfusion h fun e\u2081 _ \u21a6 n e\u2081", "start": [225, 1], "end": [232, 84], "kind": "commanddeclaration"}, {"full_name": "PSigma.mk.inj_iff", "code": "theorem mk.inj_iff {a\u2081 a\u2082 : \u03b1} {b\u2081 : \u03b2 a\u2081} {b\u2082 : \u03b2 a\u2082} :\n    @PSigma.mk \u03b1 \u03b2 a\u2081 b\u2081 = @PSigma.mk \u03b1 \u03b2 a\u2082 b\u2082 \u2194 a\u2081 = a\u2082 \u2227 HEq b\u2081 b\u2082", "start": [239, 1], "end": [243, 47], "kind": "commanddeclaration"}, {"full_name": "PSigma.ext", "code": "@[ext]\ntheorem ext {x\u2080 x\u2081 : PSigma \u03b2} (h\u2080 : x\u2080.1 = x\u2081.1) (h\u2081 : HEq x\u2080.2 x\u2081.2) : x\u2080 = x\u2081", "start": [246, 1], "end": [248, 46], "kind": "commanddeclaration"}, {"full_name": "PSigma.ext_iff", "code": "theorem ext_iff {x\u2080 x\u2081 : PSigma \u03b2} : x\u2080 = x\u2081 \u2194 x\u2080.1 = x\u2081.1 \u2227 HEq x\u2080.2 x\u2081.2", "start": [251, 1], "end": [252, 46], "kind": "commanddeclaration"}, {"full_name": "PSigma.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : (\u03a3'a, \u03b2 a) \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 a b, p \u27e8a, b\u27e9", "start": [255, 1], "end": [257, 47], "kind": "commanddeclaration"}, {"full_name": "PSigma.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : (\u03a3'a, \u03b2 a) \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p \u27e8a, b\u27e9", "start": [260, 1], "end": [262, 61], "kind": "commanddeclaration"}, {"full_name": "PSigma.subtype_ext", "code": "@[ext]\ntheorem subtype_ext {\u03b2 : Sort*} {p : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    \u2200 {x\u2080 x\u2081 : \u03a3'a, Subtype (p a)}, x\u2080.fst = x\u2081.fst \u2192 (x\u2080.snd : \u03b2) = x\u2081.snd \u2192 x\u2080 = x\u2081", "start": [265, 1], "end": [269, 42], "kind": "commanddeclaration"}, {"full_name": "PSigma.subtype_ext_iff", "code": "theorem subtype_ext_iff {\u03b2 : Sort*} {p : \u03b1 \u2192 \u03b2 \u2192 Prop} {x\u2080 x\u2081 : \u03a3'a, Subtype (p a)} :\n    x\u2080 = x\u2081 \u2194 x\u2080.fst = x\u2081.fst \u2227 (x\u2080.snd : \u03b2) = x\u2081.snd", "start": [272, 1], "end": [274, 61], "kind": "commanddeclaration"}, {"full_name": "PSigma.map", "code": "def map (f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082) (f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)) : PSigma \u03b2\u2081 \u2192 PSigma \u03b2\u2082\n  | \u27e8a, b\u27e9 => \u27e8f\u2081 a, f\u2082 a b\u27e9", "start": [279, 1], "end": [281, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Contrapose.lean", "imports": ["Mathlib/Tactic/PushNeg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Contrapose.mtr", "code": "lemma mtr {p q : Prop} : (\u00ac q \u2192 \u00ac p) \u2192 (p \u2192 q) := fun h hp \u21a6 by_contra (fun h' \u21a6 h h' hp)", "start": [24, 1], "end": [24, 90], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Tactic/GeneralizeProofs.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.GeneralizeProofs.State", "code": "structure State where\n  \n  nextIdx : List (TSyntax ``binderIdent)\n  \n  curIdx : Array GeneralizeArg := #[]", "start": [32, 1], "end": [38, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GeneralizeProofs.M", "code": "abbrev M := MonadCacheT ExprStructEq Expr $ StateRefT State MetaM", "start": [40, 1], "end": [42, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GeneralizeProofs.mkGen", "code": "private def mkGen (e : Expr) : M Unit := do\n  let s \u2190 get\n  let t \u2190 match s.nextIdx with\n  | [] => mkFreshUserName `h\n  | n :: rest =>\n    modify fun s \u21a6 { s with nextIdx := rest }\n    match n with\n    | `(binderIdent| $s:ident) => pure s.getId\n    | _ => mkFreshUserName `h\n  modify fun s \u21a6 { s with curIdx := s.curIdx.push \u27e8e, t, none\u27e9 }", "start": [44, 1], "end": [54, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.GeneralizeProofs.visit", "code": "partial def visit (e : Expr) : M Expr := do\n  if e.isAtomic then\n    pure e\n  else\n    let visitBinders (xs : Array Expr) (k : M Expr) : M Expr := do\n      let localInstances \u2190 getLocalInstances\n      let mut lctx \u2190 getLCtx\n      for x in xs do\n        let xFVarId := x.fvarId!\n        let localDecl \u2190 xFVarId.getDecl\n        let type      \u2190 visit localDecl.type\n        let localDecl := localDecl.setType type\n        let localDecl \u2190 match localDecl.value? with\n           | some value => let value \u2190 visit value; pure <| localDecl.setValue value\n           | none       => pure localDecl\n        lctx := lctx.modifyLocalDecl xFVarId fun _ \u21a6 localDecl\n      withLCtx lctx localInstances k\n    checkCache (e : ExprStructEq) fun _ \u21a6 do\n      if (\u2190 AbstractNestedProofs.isNonTrivialProof e) then\n        mkGen e\n        return e\n      else match e with\n        | .lam ..      => lambdaLetTelescope e fun xs b \u21a6 visitBinders xs do\n          mkLambdaFVars xs (\u2190 visit b) (usedLetOnly := false)\n        | .letE ..     => lambdaLetTelescope e fun xs b \u21a6 visitBinders xs do\n          mkLambdaFVars xs (\u2190 visit b) (usedLetOnly := false)\n        | .forallE ..  => forallTelescope e fun xs b \u21a6 visitBinders xs do\n          mkForallFVars xs (\u2190 visit b)\n        | .mdata _ b   => return e.updateMData! (\u2190 visit b)\n        | .proj _ _ b  => return e.updateProj! (\u2190 visit b)\n        | .app ..      => e.withApp fun f args \u21a6 return mkAppN f (\u2190 args.mapM visit)\n        | _            => pure e", "start": [56, 1], "end": [88, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Defs.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "Mathlib/Tactic/SplitIfs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.unaryCast", "code": "protected def Nat.unaryCast {R : Type u} [One R] [Zero R] [Add R] : \u2115 \u2192 R\n  | 0 => 0\n  | n + 1 => Nat.unaryCast n + 1", "start": [29, 1], "end": [32, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.AtLeastTwo", "code": "class Nat.AtLeastTwo (n : \u2115) : Prop where\n  prop : n \u2265 2", "start": [43, 1], "end": [45, 15], "kind": "commanddeclaration"}, {"full_name": "instNatAtLeastTwo", "code": "instance instNatAtLeastTwo : Nat.AtLeastTwo (n + 2) where\n  prop := Nat.succ_le_succ $ Nat.succ_le_succ $ Nat.zero_le _", "start": [47, 1], "end": [48, 62], "kind": "commanddeclaration"}, {"full_name": "instOfNat", "code": "@[nolint unusedArguments]\ninstance instOfNat [NatCast R] [Nat.AtLeastTwo n] : OfNat R n where\n  ofNat := n.cast", "start": [50, 1], "end": [56, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ofNat", "code": "@[simp, norm_cast] theorem Nat.cast_ofNat [NatCast R] [Nat.AtLeastTwo n] :\n  (Nat.cast (no_index (OfNat.ofNat n)) : R) = OfNat.ofNat n", "start": [66, 1], "end": [67, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_eq_ofNat", "code": "theorem Nat.cast_eq_ofNat [NatCast R] [Nat.AtLeastTwo n] : (Nat.cast n : R) = OfNat.ofNat n", "start": [69, 1], "end": [69, 99], "kind": "commanddeclaration"}, {"full_name": "AddMonoidWithOne", "code": "class AddMonoidWithOne (R : Type u) extends NatCast R, AddMonoid R, One R where\n  natCast := Nat.unaryCast\n  \n  natCast_zero : natCast 0 = 0 := by intros; rfl\n  \n  natCast_succ : \u2200 n, natCast (n + 1) = natCast n + 1 := by intros; rfl", "start": [73, 1], "end": [80, 72], "kind": "commanddeclaration"}, {"full_name": "AddCommMonoidWithOne", "code": "class AddCommMonoidWithOne (R : Type*) extends AddMonoidWithOne R, AddCommMonoid R", "start": [88, 1], "end": [89, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_zero", "code": "@[simp, norm_cast]\ntheorem cast_zero : ((0 : \u2115) : R) = 0", "start": [113, 1], "end": [115, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_succ", "code": "@[simp 500, norm_cast 500]\ntheorem cast_succ (n : \u2115) : ((succ n : \u2115) : R) = n + 1", "start": [121, 1], "end": [123, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_add_one", "code": "theorem cast_add_one (n : \u2115) : ((n + 1 : \u2115) : R) = n + 1", "start": [126, 1], "end": [127, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ite", "code": "@[simp, norm_cast]\ntheorem cast_ite (P : Prop) [Decidable P] (m n : \u2115) :\n    ((ite P m n : \u2115) : R) = ite P (m : R) (n : R)", "start": [130, 1], "end": [133, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_one", "code": "@[simp, norm_cast]\ntheorem cast_one [AddMonoidWithOne R] : ((1 : \u2115) : R) = 1", "start": [140, 1], "end": [142, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_add", "code": "@[simp, norm_cast]\ntheorem cast_add [AddMonoidWithOne R] (m n : \u2115) : ((m + n : \u2115) : R) = m + n", "start": [145, 1], "end": [147, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.binCast", "code": "protected def binCast [Zero R] [One R] [Add R] : \u2115 \u2192 R\n  | 0 => 0\n  | n + 1 => if (n + 1) % 2 = 0\n    then (Nat.binCast ((n + 1) / 2)) + (Nat.binCast ((n + 1) / 2))\n    else (Nat.binCast ((n + 1) / 2)) + (Nat.binCast ((n + 1) / 2)) + 1\ndecreasing_by (exact Nat.div_lt_self (Nat.succ_pos n) (Nat.le_refl 2))", "start": [150, 1], "end": [156, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.binCast_eq", "code": "@[simp]\ntheorem binCast_eq [AddMonoidWithOne R] (n : \u2115) : (Nat.binCast n : R) = ((n : \u2115) : R)", "start": [159, 1], "end": [175, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_bit0", "code": "@[norm_cast, deprecated]\ntheorem cast_bit0 [AddMonoidWithOne R] (n : \u2115) : ((bit0 n : \u2115) : R) = bit0 (n : R)", "start": [181, 1], "end": [183, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_bit1", "code": "@[norm_cast, deprecated]\ntheorem cast_bit1 [AddMonoidWithOne R] (n : \u2115) : ((bit1 n : \u2115) : R) = bit1 (n : R)", "start": [186, 1], "end": [188, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_two", "code": "theorem cast_two [AddMonoidWithOne R] : ((2 : \u2115) : R) = (2 : R)", "start": [193, 1], "end": [193, 71], "kind": "commanddeclaration"}, {"full_name": "AddMonoidWithOne.unary", "code": "@[reducible]\nprotected def AddMonoidWithOne.unary {R : Type*} [AddMonoid R] [One R] : AddMonoidWithOne R :=\n  { \u2039One R\u203a, \u2039AddMonoid R\u203a with }", "start": [200, 1], "end": [203, 34], "kind": "commanddeclaration"}, {"full_name": "AddMonoidWithOne.binary", "code": "@[reducible]\nprotected def AddMonoidWithOne.binary {R : Type*} [AddMonoid R] [One R] : AddMonoidWithOne R :=\n  { \u2039One R\u203a, \u2039AddMonoid R\u203a with\n    natCast := Nat.binCast,\n    natCast_zero := by simp only [Nat.binCast, Nat.cast],\n    natCast_succ := fun n => by\n      dsimp only [NatCast.natCast]\n      letI : AddMonoidWithOne R := AddMonoidWithOne.unary\n      rw [Nat.binCast_eq, Nat.binCast_eq, Nat.cast_succ] }", "start": [206, 1], "end": [215, 59], "kind": "commanddeclaration"}, {"full_name": "one_add_one_eq_two", "code": "theorem one_add_one_eq_two [AddMonoidWithOne \u03b1] : 1 + 1 = (2 : \u03b1)", "start": [218, 1], "end": [221, 9], "kind": "commanddeclaration"}, {"full_name": "two_add_one_eq_three", "code": "theorem two_add_one_eq_three [AddMonoidWithOne \u03b1] : 2 + 1 = (3 : \u03b1)", "start": [224, 1], "end": [227, 9], "kind": "commanddeclaration"}, {"full_name": "three_add_one_eq_four", "code": "theorem three_add_one_eq_four [AddMonoidWithOne \u03b1] : 3 + 1 = (4 : \u03b1)", "start": [229, 1], "end": [233, 9], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Option/Basic.lean", "imports": ["Mathlib/Init/Control/Combinators.lean", "Mathlib/Util/CompileInductive.lean", "lake-packages/aesop/Aesop.lean", "Mathlib/Logic/IsEmpty.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Relator.lean", "Mathlib/Data/Option/Defs.lean"], "premises": [{"full_name": "Option.coe_def", "code": "theorem coe_def : (fun a \u21a6 \u2191a : \u03b1 \u2192 Option \u03b1) = some", "start": [42, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Option.mem_map", "code": "theorem mem_map {f : \u03b1 \u2192 \u03b2} {y : \u03b2} {o : Option \u03b1} : y \u2208 o.map f \u2194 \u2203 x \u2208 o, f x = y", "start": [46, 1], "end": [46, 95], "kind": "commanddeclaration"}, {"full_name": "Option.mem_map_of_injective", "code": "@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : \u03b1 \u2192 \u03b2} (H : Function.Injective f) {a : \u03b1} {o : Option \u03b1} :\n    f a \u2208 o.map f \u2194 a \u2208 o", "start": [52, 1], "end": [55, 8], "kind": "commanddeclaration"}, {"full_name": "Option.forall_mem_map", "code": "theorem forall_mem_map {f : \u03b1 \u2192 \u03b2} {o : Option \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2200 y \u2208 o.map f, p y) \u2194 \u2200 x \u2208 o, p (f x)", "start": [57, 1], "end": [58, 55], "kind": "commanddeclaration"}, {"full_name": "Option.exists_mem_map", "code": "theorem exists_mem_map {f : \u03b1 \u2192 \u03b2} {o : Option \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2203 y \u2208 o.map f, p y) \u2194 \u2203 x \u2208 o, p (f x)", "start": [61, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "Option.coe_get", "code": "theorem coe_get {o : Option \u03b1} (h : o.isSome) : ((Option.get _ h : \u03b1) : Option \u03b1) = o", "start": [65, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "Option.eq_of_mem_of_mem", "code": "theorem eq_of_mem_of_mem {a : \u03b1} {o1 o2 : Option \u03b1} (h1 : a \u2208 o1) (h2 : a \u2208 o2) : o1 = o2", "start": [69, 1], "end": [70, 19], "kind": "commanddeclaration"}, {"full_name": "Option.Mem.leftUnique", "code": "theorem Mem.leftUnique : Relator.LeftUnique ((\u00b7 \u2208 \u00b7) : \u03b1 \u2192 Option \u03b1 \u2192 Prop)", "start": [73, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Option.some_injective", "code": "theorem some_injective (\u03b1 : Type*) : Function.Injective (@some \u03b1)", "start": [77, 1], "end": [77, 91], "kind": "commanddeclaration"}, {"full_name": "Option.map_injective", "code": "theorem map_injective {f : \u03b1 \u2192 \u03b2} (Hf : Function.Injective f) : Function.Injective (Option.map f)", "start": [80, 1], "end": [83, 58], "kind": "commanddeclaration"}, {"full_name": "Option.map_comp_some", "code": "@[simp]\ntheorem map_comp_some (f : \u03b1 \u2192 \u03b2) : Option.map f \u2218 some = some \u2218 f", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Option.none_bind'", "code": "@[simp]\ntheorem none_bind' (f : \u03b1 \u2192 Option \u03b2) : none.bind f = none", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "Option.some_bind'", "code": "@[simp]\ntheorem some_bind' (a : \u03b1) (f : \u03b1 \u2192 Option \u03b2) : (some a).bind f = f a", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Option.bind_eq_some'", "code": "theorem bind_eq_some' {x : Option \u03b1} {f : \u03b1 \u2192 Option \u03b2} {b : \u03b2} :\n    x.bind f = some b \u2194 \u2203 a, x = some a \u2227 f a = some b", "start": [101, 1], "end": [103, 22], "kind": "commanddeclaration"}, {"full_name": "Option.bind_eq_none'", "code": "theorem bind_eq_none' {o : Option \u03b1} {f : \u03b1 \u2192 Option \u03b2} :\n    o.bind f = none \u2194 \u2200 b a, a \u2208 o \u2192 b \u2209 f a", "start": [106, 1], "end": [108, 85], "kind": "commanddeclaration"}, {"full_name": "Option.joinM_eq_join", "code": "theorem joinM_eq_join : joinM = @join \u03b1", "start": [111, 1], "end": [112, 21], "kind": "commanddeclaration"}, {"full_name": "Option.bind_eq_bind", "code": "theorem bind_eq_bind {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 Option \u03b2} {x : Option \u03b1} : x >>= f = x.bind f", "start": [115, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "Option.map_coe", "code": "theorem map_coe {\u03b1 \u03b2} {a : \u03b1} {f : \u03b1 \u2192 \u03b2} : f <$> (a : Option \u03b1) = \u2191(f a)", "start": [119, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "Option.map_coe'", "code": "@[simp]\ntheorem map_coe' {a : \u03b1} {f : \u03b1 \u2192 \u03b2} : Option.map f (a : Option \u03b1) = \u2191(f a)", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Option.map_injective'", "code": "theorem map_injective' : Function.Injective (@Option.map \u03b1 \u03b2)", "start": [128, 1], "end": [130, 67], "kind": "commanddeclaration"}, {"full_name": "Option.map_inj", "code": "@[simp]\ntheorem map_inj {f g : \u03b1 \u2192 \u03b2} : Option.map f = Option.map g \u2194 f = g", "start": [133, 1], "end": [135, 24], "kind": "commanddeclaration"}, {"full_name": "Option.map_eq_id", "code": "@[simp]\ntheorem map_eq_id {f : \u03b1 \u2192 \u03b1} : Option.map f = id \u2194 f = id", "start": [140, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "Option.map_comm", "code": "theorem map_comm {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {g\u2081 : \u03b2 \u2192 \u03b4} {g\u2082 : \u03b3 \u2192 \u03b4} (h : g\u2081 \u2218 f\u2081 = g\u2082 \u2218 f\u2082)\n    (a : \u03b1) :\n    (Option.map f\u2081 a).map g\u2081 = (Option.map f\u2082 a).map g\u2082", "start": [145, 1], "end": [147, 89], "kind": "commanddeclaration"}, {"full_name": "Option.pbind_eq_bind", "code": "theorem pbind_eq_bind (f : \u03b1 \u2192 Option \u03b2) (x : Option \u03b1) : (x.pbind fun a _ \u21a6 f a) = x.bind f", "start": [156, 1], "end": [157, 56], "kind": "commanddeclaration"}, {"full_name": "Option.map_bind", "code": "theorem map_bind {\u03b1 \u03b2 \u03b3} (f : \u03b2 \u2192 \u03b3) (x : Option \u03b1) (g : \u03b1 \u2192 Option \u03b2) :\n    Option.map f (x >>= g) = x >>= fun a \u21a6 Option.map f (g a)", "start": [160, 1], "end": [162, 69], "kind": "commanddeclaration"}, {"full_name": "Option.map_bind'", "code": "theorem map_bind' (f : \u03b2 \u2192 \u03b3) (x : Option \u03b1) (g : \u03b1 \u2192 Option \u03b2) :\n    Option.map f (x.bind g) = x.bind fun a \u21a6 Option.map f (g a)", "start": [165, 1], "end": [166, 87], "kind": "commanddeclaration"}, {"full_name": "Option.map_pbind", "code": "theorem map_pbind (f : \u03b2 \u2192 \u03b3) (x : Option \u03b1) (g : \u2200 a, a \u2208 x \u2192 Option \u03b2) :\n    Option.map f (x.pbind g) = x.pbind fun a H \u21a6 Option.map f (g a H)", "start": [169, 1], "end": [171, 43], "kind": "commanddeclaration"}, {"full_name": "Option.pbind_map", "code": "theorem pbind_map (f : \u03b1 \u2192 \u03b2) (x : Option \u03b1) (g : \u2200 b : \u03b2, b \u2208 x.map f \u2192 Option \u03b3) :\n    pbind (Option.map f x) g = x.pbind fun a h \u21a6 g (f a) (mem_map_of_mem _ h)", "start": [174, 1], "end": [175, 100], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_none", "code": "@[simp]\ntheorem pmap_none (f : \u2200 a : \u03b1, p a \u2192 \u03b2) {H} : pmap f (@none \u03b1) H = none", "start": [178, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_some", "code": "@[simp]\ntheorem pmap_some (f : \u2200 a : \u03b1, p a \u2192 \u03b2) {x : \u03b1} (h : p x) :\n    pmap f (some x) = fun _ \u21a6 some (f x h)", "start": [183, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Option.mem_pmem", "code": "theorem mem_pmem {a : \u03b1} (h : \u2200 a \u2208 x, p a) (ha : a \u2208 x) : f a (h a ha) \u2208 pmap f x h", "start": [189, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_map", "code": "theorem pmap_map (g : \u03b3 \u2192 \u03b1) (x : Option \u03b3) (H) :\n    pmap f (x.map g) H = pmap (fun a h \u21a6 f (g a) h) x fun a h \u21a6 H _ (mem_map_of_mem _ h)", "start": [195, 1], "end": [197, 53], "kind": "commanddeclaration"}, {"full_name": "Option.map_pmap", "code": "theorem map_pmap (g : \u03b2 \u2192 \u03b3) (f : \u2200 a, p a \u2192 \u03b2) (x H) :\n    Option.map g (pmap f x H) = pmap (fun a h \u21a6 g (f a h)) x H", "start": [200, 1], "end": [202, 56], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_eq_map", "code": "theorem pmap_eq_map (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) (x H) :\n    @pmap _ _ p (fun a _ \u21a6 f a) x H = Option.map f x", "start": [207, 1], "end": [209, 53], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_bind", "code": "theorem pmap_bind {\u03b1 \u03b2 \u03b3} {x : Option \u03b1} {g : \u03b1 \u2192 Option \u03b2} {p : \u03b2 \u2192 Prop} {f : \u2200 b, p b \u2192 \u03b3} (H)\n    (H' : \u2200 (a : \u03b1), \u2200 b \u2208 g a, b \u2208 x >>= g) :\n    pmap f (x >>= g) H = x >>= fun a \u21a6 pmap f (g a) fun b h \u21a6 H _ (H' a _ h)", "start": [212, 1], "end": [215, 67], "kind": "commanddeclaration"}, {"full_name": "Option.bind_pmap", "code": "theorem bind_pmap {\u03b1 \u03b2 \u03b3} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (x : Option \u03b1) (g : \u03b2 \u2192 Option \u03b3) (H) :\n    pmap f x H >>= g = x.pbind fun a h \u21a6 g (f a (H _ h))", "start": [218, 1], "end": [220, 74], "kind": "commanddeclaration"}, {"full_name": "Option.pbind_eq_none", "code": "theorem pbind_eq_none {f : \u2200 a : \u03b1, a \u2208 x \u2192 Option \u03b2}\n    (h' : \u2200 a (H : a \u2208 x), f a H = none \u2192 x = none) : x.pbind f = none \u2194 x = none", "start": [225, 1], "end": [231, 21], "kind": "commanddeclaration"}, {"full_name": "Option.pbind_eq_some", "code": "theorem pbind_eq_some {f : \u2200 a : \u03b1, a \u2208 x \u2192 Option \u03b2} {y : \u03b2} :\n    x.pbind f = some y \u2194 \u2203 (z : \u03b1) (H : z \u2208 x), f z H = some y", "start": [234, 1], "end": [244, 23], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_eq_none_iff", "code": "theorem pmap_eq_none_iff {h} : pmap f x h = none \u2194 x = none", "start": [249, 1], "end": [249, 83], "kind": "commanddeclaration"}, {"full_name": "Option.pmap_eq_some_iff", "code": "theorem pmap_eq_some_iff {hf} {y : \u03b2} :\n    pmap f x hf = some y \u2194 \u2203 (a : \u03b1) (H : x = some a), f a (hf a H) = y", "start": [254, 1], "end": [264, 26], "kind": "commanddeclaration"}, {"full_name": "Option.join_pmap_eq_pmap_join", "code": "theorem join_pmap_eq_pmap_join {f : \u2200 a, p a \u2192 \u03b2} {x : Option (Option \u03b1)} (H) :\n    (pmap (pmap f) x H).join = pmap f x.join fun a h \u21a6 H (some a) (mem_of_mem_join h) _ rfl", "start": [269, 1], "end": [271, 37], "kind": "commanddeclaration"}, {"full_name": "Option.seq_some", "code": "@[simp]\ntheorem seq_some {\u03b1 \u03b2} {a : \u03b1} {f : \u03b1 \u2192 \u03b2} : some f <*> some a = some (f a)", "start": [276, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "Option.some_orElse'", "code": "@[simp]\ntheorem some_orElse' (a : \u03b1) (x : Option \u03b1) : (some a).orElse (fun _ \u21a6 x) = some a", "start": [281, 1], "end": [283, 6], "kind": "commanddeclaration"}, {"full_name": "Option.none_orElse'", "code": "@[simp]\ntheorem none_orElse' (x : Option \u03b1) : none.orElse (fun _ \u21a6 x) = x", "start": [288, 1], "end": [289, 88], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_none'", "code": "@[simp]\ntheorem orElse_none' (x : Option \u03b1) : x.orElse (fun _ \u21a6 none) = x", "start": [294, 1], "end": [295, 88], "kind": "commanddeclaration"}, {"full_name": "Option.iget_mem", "code": "theorem iget_mem [Inhabited \u03b1] : \u2200 {o : Option \u03b1}, isSome o \u2192 o.iget \u2208 o", "start": [316, 1], "end": [317, 21], "kind": "commanddeclaration"}, {"full_name": "Option.iget_of_mem", "code": "theorem iget_of_mem [Inhabited \u03b1] {a : \u03b1} : \u2200 {o : Option \u03b1}, a \u2208 o \u2192 o.iget = a", "start": [320, 1], "end": [321, 18], "kind": "commanddeclaration"}, {"full_name": "Option.getD_default_eq_iget", "code": "theorem getD_default_eq_iget [Inhabited \u03b1] (o : Option \u03b1) :\n    o.getD default = o.iget", "start": [324, 1], "end": [325, 50], "kind": "commanddeclaration"}, {"full_name": "Option.guard_eq_some'", "code": "@[simp]\ntheorem guard_eq_some' {p : Prop} [Decidable p] (u) : _root_.guard p = some u \u2194 p", "start": [328, 1], "end": [331, 44], "kind": "commanddeclaration"}, {"full_name": "Option.liftOrGet_choice", "code": "theorem liftOrGet_choice {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} (h : \u2200 a b, f a b = a \u2228 f a b = b) :\n    \u2200 o\u2081 o\u2082, liftOrGet f o\u2081 o\u2082 = o\u2081 \u2228 liftOrGet f o\u2081 o\u2082 = o\u2082", "start": [334, 1], "end": [339, 55], "kind": "commanddeclaration"}, {"full_name": "Option.casesOn'", "code": "def casesOn' : Option \u03b1 \u2192 \u03b2 \u2192 (\u03b1 \u2192 \u03b2) \u2192 \u03b2\n  | none, n, _ => n\n  | some a, _, s => s a", "start": [348, 1], "end": [352, 24], "kind": "commanddeclaration"}, {"full_name": "Option.casesOn'_none", "code": "@[simp]\ntheorem casesOn'_none (x : \u03b2) (f : \u03b1 \u2192 \u03b2) : casesOn' none x f = x", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "Option.casesOn'_some", "code": "@[simp]\ntheorem casesOn'_some (x : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : casesOn' (some a) x f = f a", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "Option.casesOn'_coe", "code": "@[simp]\ntheorem casesOn'_coe (x : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : casesOn' (a : Option \u03b1) x f = f a", "start": [365, 1], "end": [367, 6], "kind": "commanddeclaration"}, {"full_name": "Option.casesOn'_none_coe", "code": "theorem casesOn'_none_coe (f : Option \u03b1 \u2192 \u03b2) (o : Option \u03b1) :\n    casesOn' o (f none) (f \u2218 (fun a \u21a6 \u2191a)) = f o", "start": [372, 1], "end": [373, 71], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_eq_some", "code": "theorem orElse_eq_some (o o' : Option \u03b1) (x : \u03b1) :\n    (o <|> o') = some x \u2194 o = some x \u2228 o = none \u2227 o' = some x", "start": [379, 1], "end": [383, 49], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_eq_some'", "code": "theorem orElse_eq_some' (o o' : Option \u03b1) (x : \u03b1) :\n    o.orElse (fun _ \u21a6 o') = some x \u2194 o = some x \u2228 o = none \u2227 o' = some x", "start": [387, 1], "end": [389, 31], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_eq_none", "code": "@[simp]\ntheorem orElse_eq_none (o o' : Option \u03b1) : (o <|> o') = none \u2194 o = none \u2227 o' = none", "start": [392, 1], "end": [396, 39], "kind": "commanddeclaration"}, {"full_name": "Option.orElse_eq_none'", "code": "@[simp]\ntheorem orElse_eq_none' (o o' : Option \u03b1) : o.orElse (fun _ \u21a6 o') = none \u2194 o = none \u2227 o' = none", "start": [399, 1], "end": [401, 29], "kind": "commanddeclaration"}, {"full_name": "Option.choice_eq_none", "code": "theorem choice_eq_none (\u03b1 : Type*) [IsEmpty \u03b1] : choice \u03b1 = none", "start": [408, 1], "end": [409, 55], "kind": "commanddeclaration"}, {"full_name": "Option.elim_none_some", "code": "theorem elim_none_some (f : Option \u03b1 \u2192 \u03b2) : (fun x \u21a6 Option.elim x (f none) (f \u2218 some)) = f", "start": [418, 1], "end": [419, 36], "kind": "commanddeclaration"}, {"full_name": "Option.elim_comp", "code": "theorem elim_comp (h : \u03b1 \u2192 \u03b2) {f : \u03b3 \u2192 \u03b1} {x : \u03b1} {i : Option \u03b3} :\n    (i.elim (h x) fun j => h (f j)) = h (i.elim x f)", "start": [422, 1], "end": [423, 75], "kind": "commanddeclaration"}, {"full_name": "Option.elim_comp\u2082", "code": "theorem elim_comp\u2082 (h : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {f : \u03b3 \u2192 \u03b1} {x : \u03b1} {g : \u03b3 \u2192 \u03b2} {y : \u03b2}\n    {i : Option \u03b3} : (i.elim (h x y) fun j => h (f j) (g j)) = h (i.elim x f) (i.elim y g)", "start": [425, 1], "end": [427, 18], "kind": "commanddeclaration"}, {"full_name": "Option.elim_apply", "code": "theorem elim_apply {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} {x : \u03b1 \u2192 \u03b2} {i : Option \u03b3} {y : \u03b1} :\n    i.elim x f y = i.elim (x y) fun j => f j y", "start": [429, 1], "end": [430, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/MinMax.lean", "imports": ["Mathlib/Order/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "le_min_iff", "code": "@[simp]\ntheorem le_min_iff : c \u2264 min a b \u2194 c \u2264 a \u2227 c \u2264 b", "start": [32, 1], "end": [34, 13], "kind": "commanddeclaration"}, {"full_name": "le_max_iff", "code": "@[simp]\ntheorem le_max_iff : a \u2264 max b c \u2194 a \u2264 b \u2228 a \u2264 c", "start": [37, 1], "end": [39, 13], "kind": "commanddeclaration"}, {"full_name": "min_le_iff", "code": "@[simp]\ntheorem min_le_iff : min a b \u2264 c \u2194 a \u2264 c \u2228 b \u2264 c", "start": [42, 1], "end": [44, 13], "kind": "commanddeclaration"}, {"full_name": "max_le_iff", "code": "@[simp]\ntheorem max_le_iff : max a b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c", "start": [47, 1], "end": [49, 13], "kind": "commanddeclaration"}, {"full_name": "lt_min_iff", "code": "@[simp]\ntheorem lt_min_iff : a < min b c \u2194 a < b \u2227 a < c", "start": [52, 1], "end": [54, 13], "kind": "commanddeclaration"}, {"full_name": "lt_max_iff", "code": "@[simp]\ntheorem lt_max_iff : a < max b c \u2194 a < b \u2228 a < c", "start": [57, 1], "end": [59, 13], "kind": "commanddeclaration"}, {"full_name": "min_lt_iff", "code": "@[simp]\ntheorem min_lt_iff : min a b < c \u2194 a < c \u2228 b < c", "start": [62, 1], "end": [64, 13], "kind": "commanddeclaration"}, {"full_name": "max_lt_iff", "code": "@[simp]\ntheorem max_lt_iff : max a b < c \u2194 a < c \u2227 b < c", "start": [67, 1], "end": [69, 13], "kind": "commanddeclaration"}, {"full_name": "max_le_max", "code": "@[gcongr]\ntheorem max_le_max : a \u2264 c \u2192 b \u2264 d \u2192 max a b \u2264 max c d", "start": [72, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "max_le_max_left", "code": "@[gcongr] theorem max_le_max_left (c) (h : a \u2264 b) : max c a \u2264 max c b", "start": [77, 1], "end": [77, 93], "kind": "commanddeclaration"}, {"full_name": "max_le_max_right", "code": "@[gcongr] theorem max_le_max_right (c) (h : a \u2264 b) : max a c \u2264 max b c", "start": [79, 1], "end": [79, 95], "kind": "commanddeclaration"}, {"full_name": "min_le_min", "code": "@[gcongr]\ntheorem min_le_min : a \u2264 c \u2192 b \u2264 d \u2192 min a b \u2264 min c d", "start": [81, 1], "end": [83, 13], "kind": "commanddeclaration"}, {"full_name": "min_le_min_left", "code": "@[gcongr] theorem min_le_min_left (c) (h : a \u2264 b) : min c a \u2264 min c b", "start": [86, 1], "end": [86, 93], "kind": "commanddeclaration"}, {"full_name": "min_le_min_right", "code": "@[gcongr] theorem min_le_min_right (c) (h : a \u2264 b) : min a c \u2264 min b c", "start": [88, 1], "end": [88, 95], "kind": "commanddeclaration"}, {"full_name": "le_max_of_le_left", "code": "theorem le_max_of_le_left : a \u2264 b \u2192 a \u2264 max b c", "start": [90, 1], "end": [91, 20], "kind": "commanddeclaration"}, {"full_name": "le_max_of_le_right", "code": "theorem le_max_of_le_right : a \u2264 c \u2192 a \u2264 max b c", "start": [94, 1], "end": [95, 21], "kind": "commanddeclaration"}, {"full_name": "lt_max_of_lt_left", "code": "theorem lt_max_of_lt_left (h : a < b) : a < max b c", "start": [98, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "lt_max_of_lt_right", "code": "theorem lt_max_of_lt_right (h : a < c) : a < max b c", "start": [102, 1], "end": [103, 32], "kind": "commanddeclaration"}, {"full_name": "min_le_of_left_le", "code": "theorem min_le_of_left_le : a \u2264 c \u2192 min a b \u2264 c", "start": [106, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "min_le_of_right_le", "code": "theorem min_le_of_right_le : b \u2264 c \u2192 min a b \u2264 c", "start": [110, 1], "end": [111, 21], "kind": "commanddeclaration"}, {"full_name": "min_lt_of_left_lt", "code": "theorem min_lt_of_left_lt (h : a < c) : min a b < c", "start": [114, 1], "end": [115, 31], "kind": "commanddeclaration"}, {"full_name": "min_lt_of_right_lt", "code": "theorem min_lt_of_right_lt (h : b < c) : min a b < c", "start": [118, 1], "end": [119, 32], "kind": "commanddeclaration"}, {"full_name": "max_min_distrib_left", "code": "theorem max_min_distrib_left : max a (min b c) = min (max a b) (max a c)", "start": [122, 1], "end": [123, 15], "kind": "commanddeclaration"}, {"full_name": "max_min_distrib_right", "code": "theorem max_min_distrib_right : max (min a b) c = min (max a c) (max b c)", "start": [126, 1], "end": [127, 16], "kind": "commanddeclaration"}, {"full_name": "min_max_distrib_left", "code": "theorem min_max_distrib_left : min a (max b c) = max (min a b) (min a c)", "start": [130, 1], "end": [131, 15], "kind": "commanddeclaration"}, {"full_name": "min_max_distrib_right", "code": "theorem min_max_distrib_right : min (max a b) c = max (min a c) (min b c)", "start": [134, 1], "end": [135, 16], "kind": "commanddeclaration"}, {"full_name": "min_le_max", "code": "theorem min_le_max : min a b \u2264 max a b", "start": [138, 1], "end": [139, 47], "kind": "commanddeclaration"}, {"full_name": "min_eq_left_iff", "code": "@[simp]\ntheorem min_eq_left_iff : min a b = a \u2194 a \u2264 b", "start": [142, 1], "end": [144, 14], "kind": "commanddeclaration"}, {"full_name": "min_eq_right_iff", "code": "@[simp]\ntheorem min_eq_right_iff : min a b = b \u2194 b \u2264 a", "start": [147, 1], "end": [149, 15], "kind": "commanddeclaration"}, {"full_name": "max_eq_left_iff", "code": "@[simp]\ntheorem max_eq_left_iff : max a b = a \u2194 b \u2264 a", "start": [152, 1], "end": [154, 14], "kind": "commanddeclaration"}, {"full_name": "max_eq_right_iff", "code": "@[simp]\ntheorem max_eq_right_iff : max a b = b \u2194 a \u2264 b", "start": [157, 1], "end": [159, 15], "kind": "commanddeclaration"}, {"full_name": "min_cases", "code": "theorem min_cases (a b : \u03b1) : min a b = a \u2227 a \u2264 b \u2228 min a b = b \u2227 b < a", "start": [162, 1], "end": [170, 63], "kind": "commanddeclaration"}, {"full_name": "max_cases", "code": "theorem max_cases (a b : \u03b1) : max a b = a \u2227 b \u2264 a \u2228 max a b = b \u2227 a < b", "start": [173, 1], "end": [177, 23], "kind": "commanddeclaration"}, {"full_name": "min_eq_iff", "code": "theorem min_eq_iff : min a b = c \u2194 a = c \u2227 a \u2264 b \u2228 b = c \u2227 b \u2264 a", "start": [180, 1], "end": [184, 46], "kind": "commanddeclaration"}, {"full_name": "max_eq_iff", "code": "theorem max_eq_iff : max a b = c \u2194 a = c \u2227 b \u2264 a \u2228 b = c \u2227 a \u2264 b", "start": [187, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "min_lt_min_left_iff", "code": "theorem min_lt_min_left_iff : min a c < min b c \u2194 a < b \u2227 a < c", "start": [191, 1], "end": [193, 59], "kind": "commanddeclaration"}, {"full_name": "min_lt_min_right_iff", "code": "theorem min_lt_min_right_iff : min a b < min a c \u2194 b < c \u2227 b < a", "start": [196, 1], "end": [197, 44], "kind": "commanddeclaration"}, {"full_name": "max_lt_max_left_iff", "code": "theorem max_lt_max_left_iff : max a c < max b c \u2194 a < b \u2227 c < b", "start": [200, 1], "end": [201, 35], "kind": "commanddeclaration"}, {"full_name": "max_lt_max_right_iff", "code": "theorem max_lt_max_right_iff : max a b < max a c \u2194 b < c \u2227 a < c", "start": [204, 1], "end": [205, 36], "kind": "commanddeclaration"}, {"full_name": "max_idem", "code": "instance max_idem : IsIdempotent \u03b1 max where\n  idempotent := by simp", "start": [208, 1], "end": [210, 24], "kind": "commanddeclaration"}, {"full_name": "min_idem", "code": "instance min_idem : IsIdempotent \u03b1 min where\n  idempotent := by simp", "start": [214, 1], "end": [216, 24], "kind": "commanddeclaration"}, {"full_name": "min_lt_max", "code": "theorem min_lt_max : min a b < max a b \u2194 a \u2260 b", "start": [220, 1], "end": [221, 13], "kind": "commanddeclaration"}, {"full_name": "max_lt_max", "code": "theorem max_lt_max (h\u2081 : a < c) (h\u2082 : b < d) : max a b < max c d", "start": [225, 1], "end": [226, 56], "kind": "commanddeclaration"}, {"full_name": "min_lt_min", "code": "theorem min_lt_min (h\u2081 : a < c) (h\u2082 : b < d) : min a b < min c d", "start": [229, 1], "end": [230, 34], "kind": "commanddeclaration"}, {"full_name": "min_right_comm", "code": "theorem min_right_comm (a b c : \u03b1) : min (min a b) c = min (min a c) b", "start": [233, 1], "end": [234, 42], "kind": "commanddeclaration"}, {"full_name": "Max.left_comm", "code": "theorem Max.left_comm (a b c : \u03b1) : max a (max b c) = max b (max a c)", "start": [237, 1], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "Max.right_comm", "code": "theorem Max.right_comm (a b c : \u03b1) : max (max a b) c = max (max a c) b", "start": [241, 1], "end": [242, 49], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_max", "code": "theorem MonotoneOn.map_max (hf : MonotoneOn f s) (ha : a \u2208 s) (hb : b \u2208 s) : f (max a b) =\n    max (f a) (f b)", "start": [245, 1], "end": [248, 65], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.map_min", "code": "theorem MonotoneOn.map_min (hf : MonotoneOn f s) (ha : a \u2208 s) (hb : b \u2208 s) : f (min a b) =\n    min (f a) (f b)", "start": [251, 1], "end": [252, 45], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_max", "code": "theorem AntitoneOn.map_max (hf : AntitoneOn f s) (ha : a \u2208 s) (hb : b \u2208 s) : f (max a b) =\n    min (f a) (f b)", "start": [255, 1], "end": [256, 51], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.map_min", "code": "theorem AntitoneOn.map_min (hf : AntitoneOn f s) (ha : a \u2208 s) (hb : b \u2208 s) : f (min a b) =\n    max (f a) (f b)", "start": [259, 1], "end": [260, 45], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_max", "code": "theorem Monotone.map_max (hf : Monotone f) : f (max a b) = max (f a) (f b)", "start": [263, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_min", "code": "theorem Monotone.map_min (hf : Monotone f) : f (min a b) = min (f a) (f b)", "start": [267, 1], "end": [268, 18], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_max", "code": "theorem Antitone.map_max (hf : Antitone f) : f (max a b) = min (f a) (f b)", "start": [271, 1], "end": [272, 50], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_min", "code": "theorem Antitone.map_min (hf : Antitone f) : f (min a b) = max (f a) (f b)", "start": [275, 1], "end": [276, 18], "kind": "commanddeclaration"}, {"full_name": "min_choice", "code": "theorem min_choice (a b : \u03b1) : min a b = a \u2228 min a b = b", "start": [279, 1], "end": [279, 95], "kind": "commanddeclaration"}, {"full_name": "max_choice", "code": "theorem max_choice (a b : \u03b1) : max a b = a \u2228 max a b = b", "start": [282, 1], "end": [283, 24], "kind": "commanddeclaration"}, {"full_name": "le_of_max_le_left", "code": "theorem le_of_max_le_left {a b c : \u03b1} (h : max a b \u2264 c) : a \u2264 c", "start": [286, 1], "end": [287, 31], "kind": "commanddeclaration"}, {"full_name": "le_of_max_le_right", "code": "theorem le_of_max_le_right {a b c : \u03b1} (h : max a b \u2264 c) : b \u2264 c", "start": [290, 1], "end": [291, 32], "kind": "commanddeclaration"}, {"full_name": "max_commutative", "code": "theorem max_commutative : Commutative (max : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [294, 1], "end": [295, 11], "kind": "commanddeclaration"}, {"full_name": "max_associative", "code": "theorem max_associative : Associative (max : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [298, 1], "end": [299, 12], "kind": "commanddeclaration"}, {"full_name": "max_left_commutative", "code": "theorem max_left_commutative : LeftCommutative (max : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [308, 1], "end": [309, 16], "kind": "commanddeclaration"}, {"full_name": "min_commutative", "code": "theorem min_commutative : Commutative (min : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [312, 1], "end": [313, 11], "kind": "commanddeclaration"}, {"full_name": "min_associative", "code": "theorem min_associative : Associative (min : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [316, 1], "end": [317, 12], "kind": "commanddeclaration"}, {"full_name": "min_left_commutative", "code": "theorem min_left_commutative : LeftCommutative (min : \u03b1 \u2192 \u03b1 \u2192 \u03b1)", "start": [326, 1], "end": [327, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CovariantAndContravariant.lean", "imports": ["Mathlib/Order/Monotone/Basic.lean", "Mathlib/Algebra/Group/Defs.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Covariant", "code": "def Covariant : Prop :=\n  \u2200 (m) {n\u2081 n\u2082}, r n\u2081 n\u2082 \u2192 r (\u03bc m n\u2081) (\u03bc m n\u2082)", "start": [75, 1], "end": [80, 47], "kind": "commanddeclaration"}, {"full_name": "Contravariant", "code": "def Contravariant : Prop :=\n  \u2200 (m) {n\u2081 n\u2082}, r (\u03bc m n\u2081) (\u03bc m n\u2082) \u2192 r n\u2081 n\u2082", "start": [83, 1], "end": [88, 47], "kind": "commanddeclaration"}, {"full_name": "CovariantClass", "code": "class CovariantClass : Prop where\n  \n  protected elim : Covariant M N \u03bc r", "start": [91, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "ContravariantClass", "code": "class ContravariantClass : Prop where\n  \n  protected elim : Contravariant M N \u03bc r", "start": [108, 1], "end": [124, 41], "kind": "commanddeclaration"}, {"full_name": "rel_iff_cov", "code": "theorem rel_iff_cov [CovariantClass M N \u03bc r] [ContravariantClass M N \u03bc r] (m : M) {a b : N} :\n    r (\u03bc m a) (\u03bc m b) \u2194 r a b", "start": [127, 1], "end": [129, 53], "kind": "commanddeclaration"}, {"full_name": "Covariant.flip", "code": "theorem Covariant.flip (h : Covariant M N \u03bc r) : Covariant M N \u03bc (flip r)", "start": [136, 1], "end": [137, 18], "kind": "commanddeclaration"}, {"full_name": "Contravariant.flip", "code": "theorem Contravariant.flip (h : Contravariant M N \u03bc r) : Contravariant M N \u03bc (flip r)", "start": [140, 1], "end": [141, 18], "kind": "commanddeclaration"}, {"full_name": "act_rel_act_of_rel", "code": "theorem act_rel_act_of_rel (m : M) {a b : N} (ab : r a b) : r (\u03bc m a) (\u03bc m b)", "start": [150, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "Group.covariant_iff_contravariant", "code": "@[to_additive]\ntheorem Group.covariant_iff_contravariant [Group N] :\n    Covariant N N (\u00b7 * \u00b7) r \u2194 Contravariant N N (\u00b7 * \u00b7) r", "start": [154, 1], "end": [161, 19], "kind": "commanddeclaration"}, {"full_name": "Group.covconv", "code": "@[to_additive]\ninstance (priority := 100) Group.covconv [Group N] [CovariantClass N N (\u00b7 * \u00b7) r] :\n    ContravariantClass N N (\u00b7 * \u00b7) r :=\n  \u27e8Group.covariant_iff_contravariant.mp CovariantClass.elim\u27e9", "start": [165, 1], "end": [168, 61], "kind": "commanddeclaration"}, {"full_name": "Group.covariant_swap_iff_contravariant_swap", "code": "@[to_additive]\ntheorem Group.covariant_swap_iff_contravariant_swap [Group N] :\n    Covariant N N (swap (\u00b7 * \u00b7)) r \u2194 Contravariant N N (swap (\u00b7 * \u00b7)) r", "start": [170, 1], "end": [177, 19], "kind": "commanddeclaration"}, {"full_name": "Group.covconv_swap", "code": "@[to_additive]\ninstance (priority := 100) Group.covconv_swap [Group N] [CovariantClass N N (swap (\u00b7 * \u00b7)) r] :\n    ContravariantClass N N (swap (\u00b7 * \u00b7)) r :=\n  \u27e8Group.covariant_swap_iff_contravariant_swap.mp CovariantClass.elim\u27e9", "start": [182, 1], "end": [185, 71], "kind": "commanddeclaration"}, {"full_name": "act_rel_of_rel_of_act_rel", "code": "theorem act_rel_of_rel_of_act_rel (ab : r a b) (rl : r (\u03bc m b) c) : r (\u03bc m a) c", "start": [193, 1], "end": [194, 44], "kind": "commanddeclaration"}, {"full_name": "rel_act_of_rel_of_rel_act", "code": "theorem rel_act_of_rel_of_rel_act (ab : r a b) (rr : r c (\u03bc m a)) : r c (\u03bc m b)", "start": [197, 1], "end": [198, 44], "kind": "commanddeclaration"}, {"full_name": "act_rel_act_of_rel_of_rel", "code": "theorem act_rel_act_of_rel_of_rel (ab : r a b) (cd : r c d) : r (mu a c) (mu b d)", "start": [211, 1], "end": [212, 90], "kind": "commanddeclaration"}, {"full_name": "rel_of_act_rel_act", "code": "theorem rel_of_act_rel_act (m : M) {a b : N} (ab : r (\u03bc m a) (\u03bc m b)) : r a b", "start": [221, 1], "end": [222, 31], "kind": "commanddeclaration"}, {"full_name": "act_rel_of_act_rel_of_rel_act_rel", "code": "theorem act_rel_of_act_rel_of_rel_act_rel (ab : r (\u03bc m a) b) (rl : r (\u03bc m b) (\u03bc m c)) :\n    r (\u03bc m a) c", "start": [230, 1], "end": [232, 44], "kind": "commanddeclaration"}, {"full_name": "rel_act_of_act_rel_act_of_rel_act", "code": "theorem rel_act_of_act_rel_act_of_rel_act (ab : r (\u03bc m a) (\u03bc m b)) (rr : r b (\u03bc m c)) :\n    r a (\u03bc m c)", "start": [235, 1], "end": [237, 44], "kind": "commanddeclaration"}, {"full_name": "Covariant.monotone_of_const", "code": "theorem Covariant.monotone_of_const [CovariantClass M N \u03bc (\u00b7 \u2264 \u00b7)] (m : M) : Monotone (\u03bc m)", "start": [250, 1], "end": [252, 34], "kind": "commanddeclaration"}, {"full_name": "Monotone.covariant_of_const", "code": "theorem Monotone.covariant_of_const [CovariantClass M N \u03bc (\u00b7 \u2264 \u00b7)] (hf : Monotone f) (m : M) :\n    Monotone (f <| \u03bc m \u00b7)", "start": [255, 1], "end": [259, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.covariant_of_const'", "code": "theorem Monotone.covariant_of_const' {\u03bc : N \u2192 N \u2192 N} [CovariantClass N N (swap \u03bc) (\u00b7 \u2264 \u00b7)]\n    (hf : Monotone f) (m : N) : Monotone (f <| \u03bc \u00b7 m)", "start": [262, 1], "end": [266, 49], "kind": "commanddeclaration"}, {"full_name": "Antitone.covariant_of_const", "code": "theorem Antitone.covariant_of_const [CovariantClass M N \u03bc (\u00b7 \u2264 \u00b7)] (hf : Antitone f) (m : M) :\n    Antitone (f <| \u03bc m \u00b7)", "start": [269, 1], "end": [272, 52], "kind": "commanddeclaration"}, {"full_name": "Antitone.covariant_of_const'", "code": "theorem Antitone.covariant_of_const' {\u03bc : N \u2192 N \u2192 N} [CovariantClass N N (swap \u03bc) (\u00b7 \u2264 \u00b7)]\n    (hf : Antitone f) (m : N) : Antitone (f <| \u03bc \u00b7 m)", "start": [275, 1], "end": [278, 49], "kind": "commanddeclaration"}, {"full_name": "covariant_le_of_covariant_lt", "code": "theorem covariant_le_of_covariant_lt [PartialOrder N] :\n    Covariant M N \u03bc (\u00b7 < \u00b7) \u2192 Covariant M N \u03bc (\u00b7 \u2264 \u00b7)", "start": [283, 1], "end": [288, 22], "kind": "commanddeclaration"}, {"full_name": "covariantClass_le_of_lt", "code": "theorem covariantClass_le_of_lt [PartialOrder N] [CovariantClass M N \u03bc (\u00b7 < \u00b7)] :\n    CovariantClass M N \u03bc (\u00b7 \u2264 \u00b7)", "start": [291, 1], "end": [292, 93], "kind": "commanddeclaration"}, {"full_name": "contravariant_le_iff_contravariant_lt_and_eq", "code": "theorem contravariant_le_iff_contravariant_lt_and_eq [PartialOrder N] :\n    Contravariant M N \u03bc (\u00b7 \u2264 \u00b7) \u2194 Contravariant M N \u03bc (\u00b7 < \u00b7) \u2227 Contravariant M N \u03bc (\u00b7 = \u00b7)", "start": [294, 1], "end": [299, 77], "kind": "commanddeclaration"}, {"full_name": "contravariant_lt_of_contravariant_le", "code": "theorem contravariant_lt_of_contravariant_le [PartialOrder N] :\n    Contravariant M N \u03bc (\u00b7 \u2264 \u00b7) \u2192 Contravariant M N \u03bc (\u00b7 < \u00b7)", "start": [301, 1], "end": [303, 69], "kind": "commanddeclaration"}, {"full_name": "covariant_le_iff_contravariant_lt", "code": "theorem covariant_le_iff_contravariant_lt [LinearOrder N] :\n    Covariant M N \u03bc (\u00b7 \u2264 \u00b7) \u2194 Contravariant M N \u03bc (\u00b7 < \u00b7)", "start": [306, 1], "end": [309, 57], "kind": "commanddeclaration"}, {"full_name": "covariant_lt_iff_contravariant_le", "code": "theorem covariant_lt_iff_contravariant_le [LinearOrder N] :\n    Covariant M N \u03bc (\u00b7 < \u00b7) \u2194 Contravariant M N \u03bc (\u00b7 \u2264 \u00b7)", "start": [312, 1], "end": [315, 57], "kind": "commanddeclaration"}, {"full_name": "covariant_flip_iff", "code": "theorem covariant_flip_iff [IsSymmOp N N mu] :\n    Covariant N N (flip mu) r \u2194 Covariant N N mu r", "start": [320, 1], "end": [321, 79], "kind": "commanddeclaration"}, {"full_name": "contravariant_flip_iff", "code": "theorem contravariant_flip_iff [IsSymmOp N N mu] :\n    Contravariant N N (flip mu) r \u2194 Contravariant N N mu r", "start": [325, 1], "end": [326, 87], "kind": "commanddeclaration"}, {"full_name": "contravariant_lt_of_covariant_le", "code": "instance contravariant_lt_of_covariant_le [LinearOrder N]\n    [CovariantClass N N mu (\u00b7 \u2264 \u00b7)] : ContravariantClass N N mu (\u00b7 < \u00b7) where\n  elim := (covariant_le_iff_contravariant_lt N N mu).mp CovariantClass.elim", "start": [330, 1], "end": [332, 76], "kind": "commanddeclaration"}, {"full_name": "covariant_lt_of_contravariant_le", "code": "instance covariant_lt_of_contravariant_le [LinearOrder N]\n    [ContravariantClass N N mu (\u00b7 \u2264 \u00b7)] : CovariantClass N N mu (\u00b7 < \u00b7) where\n  elim := (covariant_lt_iff_contravariant_le N N mu).mpr ContravariantClass.elim", "start": [334, 1], "end": [336, 81], "kind": "commanddeclaration"}, {"full_name": "covariant_swap_mul_of_covariant_mul", "code": "@[to_additive]\ninstance covariant_swap_mul_of_covariant_mul [CommSemigroup N]\n    [CovariantClass N N (\u00b7 * \u00b7) r] : CovariantClass N N (swap (\u00b7 * \u00b7)) r where\n  elim := (covariant_flip_iff N r (\u00b7 * \u00b7)).mpr CovariantClass.elim", "start": [338, 1], "end": [341, 67], "kind": "commanddeclaration"}, {"full_name": "contravariant_swap_mul_of_contravariant_mul", "code": "@[to_additive]\ninstance contravariant_swap_mul_of_contravariant_mul [CommSemigroup N]\n    [ContravariantClass N N (\u00b7 * \u00b7) r] : ContravariantClass N N (swap (\u00b7 * \u00b7)) r where\n  elim := (contravariant_flip_iff N r (\u00b7 * \u00b7)).mpr ContravariantClass.elim", "start": [343, 1], "end": [346, 75], "kind": "commanddeclaration"}, {"full_name": "covariant_lt_of_covariant_le_of_contravariant_eq", "code": "theorem covariant_lt_of_covariant_le_of_contravariant_eq [ContravariantClass M N \u03bc (\u00b7 = \u00b7)]\n    [PartialOrder N] [CovariantClass M N \u03bc (\u00b7 \u2264 \u00b7)] : CovariantClass M N \u03bc (\u00b7 < \u00b7) where", "start": [348, 1], "end": [350, 94], "kind": "commanddeclaration"}, {"full_name": "contravariant_le_of_contravariant_eq_and_lt", "code": "theorem contravariant_le_of_contravariant_eq_and_lt [PartialOrder N]\n    [ContravariantClass M N \u03bc (\u00b7 = \u00b7)] [ContravariantClass M N \u03bc (\u00b7 < \u00b7)] :\n    ContravariantClass M N \u03bc (\u00b7 \u2264 \u00b7) where", "start": [352, 1], "end": [356, 55], "kind": "commanddeclaration"}, {"full_name": "LeftCancelSemigroup.covariant_mul_lt_of_covariant_mul_le", "code": "@[to_additive]\ninstance LeftCancelSemigroup.covariant_mul_lt_of_covariant_mul_le [LeftCancelSemigroup N]\n    [PartialOrder N] [CovariantClass N N (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass N N (\u00b7 * \u00b7) (\u00b7 < \u00b7) where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_right a).mpr bc.ne)", "start": [364, 1], "end": [368, 91], "kind": "commanddeclaration"}, {"full_name": "RightCancelSemigroup.covariant_swap_mul_lt_of_covariant_swap_mul_le", "code": "@[to_additive]\ninstance RightCancelSemigroup.covariant_swap_mul_lt_of_covariant_swap_mul_le\n    [RightCancelSemigroup N] [PartialOrder N] [CovariantClass N N (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass N N (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7) where\n  elim a _ _ bc := (CovariantClass.elim a bc.le).lt_of_ne ((mul_ne_mul_left a).mpr bc.ne)", "start": [370, 1], "end": [374, 90], "kind": "commanddeclaration"}, {"full_name": "LeftCancelSemigroup.contravariant_mul_le_of_contravariant_mul_lt", "code": "@[to_additive]\ninstance LeftCancelSemigroup.contravariant_mul_le_of_contravariant_mul_lt [LeftCancelSemigroup N]\n    [PartialOrder N] [ContravariantClass N N (\u00b7 * \u00b7) (\u00b7 < \u00b7)] :\n    ContravariantClass N N (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    \u27e8ContravariantClass.elim, fun _ \u21a6 mul_left_cancel\u27e9", "start": [376, 1], "end": [381, 55], "kind": "commanddeclaration"}, {"full_name": "RightCancelSemigroup.contravariant_swap_mul_le_of_contravariant_swap_mul_lt", "code": "@[to_additive]\ninstance RightCancelSemigroup.contravariant_swap_mul_le_of_contravariant_swap_mul_lt\n    [RightCancelSemigroup N] [PartialOrder N] [ContravariantClass N N (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] :\n    ContravariantClass N N (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) where\n  elim := (contravariant_le_iff_contravariant_lt_and_eq N N _).mpr\n    \u27e8ContravariantClass.elim, fun _ \u21a6 mul_right_cancel\u27e9", "start": [383, 1], "end": [388, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Prod/PProd.lean", "imports": ["Mathlib/Logic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PProd.mk.eta", "code": "@[simp]\ntheorem mk.eta {p : PProd \u03b1 \u03b2} : PProd.mk p.1 p.2 = p", "start": [21, 1], "end": [23, 6], "kind": "commanddeclaration"}, {"full_name": "PProd.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb {p : PProd \u03b1 \u03b2 \u2192 Prop} : (\u2200 x, p x) \u2194 \u2200 a b, p \u27e8a, b\u27e9", "start": [26, 1], "end": [28, 47], "kind": "commanddeclaration"}, {"full_name": "PProd.exists", "code": "@[simp]\ntheorem \u00abexists\u00bb {p : PProd \u03b1 \u03b2 \u2192 Prop} : (\u2203 x, p x) \u2194 \u2203 a b, p \u27e8a, b\u27e9", "start": [31, 1], "end": [33, 61], "kind": "commanddeclaration"}, {"full_name": "PProd.forall'", "code": "theorem forall' {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 x : PProd \u03b1 \u03b2, p x.1 x.2) \u2194 \u2200 a b, p a b", "start": [36, 1], "end": [37, 15], "kind": "commanddeclaration"}, {"full_name": "PProd.exists'", "code": "theorem exists' {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2203 x : PProd \u03b1 \u03b2, p x.1 x.2) \u2194 \u2203 a b, p a b", "start": [40, 1], "end": [41, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.pprod_map", "code": "theorem Function.Injective.pprod_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Injective f) (hg : Injective g) :\n    Injective (fun x \u21a6 \u27e8f x.1, g x.2\u27e9 : PProd \u03b1 \u03b3 \u2192 PProd \u03b2 \u03b4)", "start": [46, 1], "end": [50, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Equiv/Basic.lean", "imports": ["Mathlib/Tactic/GeneralizeProofs.lean", "Mathlib/Data/Bool/Basic.lean", "Mathlib/Logic/Function/Conjugate.lean", "Mathlib/Tactic/Contrapose.lean", "Mathlib/Data/Sigma/Basic.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Tactic/SimpRw.lean", "Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Data/Prod/Basic.lean", "Mathlib/Tactic/Lift.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/Init/Data/Sigma/Basic.lean", "Mathlib/Tactic/Convert.lean"], "premises": [{"full_name": "Equiv.pprodEquivProd", "code": "@[simps apply symm_apply]\ndef pprodEquivProd : PProd \u03b1 \u03b2 \u2243 \u03b1 \u00d7 \u03b2 where\n  toFun x := (x.1, x.2)\n  invFun x := \u27e8x.1, x.2\u27e9\n  left_inv := fun _ => rfl\n  right_inv := fun _ => rfl", "start": [57, 1], "end": [63, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.pprodCongr", "code": "@[simps apply]\ndef pprodCongr (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b3 \u2243 \u03b4) : PProd \u03b1 \u03b3 \u2243 PProd \u03b2 \u03b4 where\n  toFun x := \u27e8e\u2081 x.1, e\u2082 x.2\u27e9\n  invFun x := \u27e8e\u2081.symm x.1, e\u2082.symm x.2\u27e9\n  left_inv := fun \u27e8x, y\u27e9 => by simp\n  right_inv := fun \u27e8x, y\u27e9 => by simp", "start": [68, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.pprodProd", "code": "@[simps! apply symm_apply]\ndef pprodProd (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    PProd \u03b1\u2081 \u03b2\u2081 \u2243 \u03b1\u2082 \u00d7 \u03b2\u2082 :=\n  (ea.pprodCongr eb).trans pprodEquivProd", "start": [80, 1], "end": [84, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodPProd", "code": "@[simps! apply symm_apply]\ndef prodPProd (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    \u03b1\u2081 \u00d7 \u03b2\u2081 \u2243 PProd \u03b1\u2082 \u03b2\u2082 :=\n  (ea.symm.pprodProd eb.symm).symm", "start": [89, 1], "end": [93, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.pprodEquivProdPLift", "code": "@[simps! apply symm_apply]\ndef pprodEquivProdPLift : PProd \u03b1 \u03b2 \u2243 PLift \u03b1 \u00d7 PLift \u03b2 :=\n  Equiv.plift.symm.pprodProd Equiv.plift.symm", "start": [98, 1], "end": [101, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongr", "code": "@[simps (config := .asFn) apply]\ndef prodCongr (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) : \u03b1\u2081 \u00d7 \u03b2\u2081 \u2243 \u03b1\u2082 \u00d7 \u03b2\u2082 :=\n  \u27e8Prod.map e\u2081 e\u2082, Prod.map e\u2081.symm e\u2082.symm, fun \u27e8a, b\u27e9 => by simp, fun \u27e8a, b\u27e9 => by simp\u27e9", "start": [106, 1], "end": [111, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongr_symm", "code": "@[simp]\ntheorem prodCongr_symm (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    (prodCongr e\u2081 e\u2082).symm = prodCongr e\u2081.symm e\u2082.symm", "start": [115, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodComm", "code": "def prodComm (\u03b1 \u03b2) : \u03b1 \u00d7 \u03b2 \u2243 \u03b2 \u00d7 \u03b1 :=\n  \u27e8Prod.swap, Prod.swap, Prod.swap_swap, Prod.swap_swap\u27e9", "start": [121, 1], "end": [124, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm (\u03b1 \u03b2) : (\u21d1(prodComm \u03b1 \u03b2) : \u03b1 \u00d7 \u03b2 \u2192 \u03b2 \u00d7 \u03b1) = Prod.swap", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodComm_apply", "code": "@[simp]\ntheorem prodComm_apply (x : \u03b1 \u00d7 \u03b2) : prodComm \u03b1 \u03b2 x = x.swap", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodComm_symm", "code": "@[simp]\ntheorem prodComm_symm (\u03b1 \u03b2) : (prodComm \u03b1 \u03b2).symm = prodComm \u03b2 \u03b1", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodAssoc", "code": "@[simps]\ndef prodAssoc (\u03b1 \u03b2 \u03b3) : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u2243 \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 :=\n  \u27e8fun p => (p.1.1, p.1.2, p.2), fun p => ((p.1, p.2.1), p.2.2), fun \u27e8\u27e8_, _\u27e9, _\u27e9 => rfl,\n    fun \u27e8_, \u27e8_, _\u27e9\u27e9 => rfl\u27e9", "start": [142, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodProdProdComm", "code": "@[simps apply]\ndef prodProdProdComm (\u03b1 \u03b2 \u03b3 \u03b4 : Type*) : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u00d7 \u03b4 \u2243 (\u03b1 \u00d7 \u03b3) \u00d7 \u03b2 \u00d7 \u03b4 where\n  toFun abcd := ((abcd.1.1, abcd.2.1), (abcd.1.2, abcd.2.2))\n  invFun acbd := ((acbd.1.1, acbd.2.1), (acbd.1.2, acbd.2.2))\n  left_inv := fun \u27e8\u27e8_a, _b\u27e9, \u27e8_c, _d\u27e9\u27e9 => rfl\n  right_inv := fun \u27e8\u27e8_a, _c\u27e9, \u27e8_b, _d\u27e9\u27e9 => rfl", "start": [151, 1], "end": [157, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodProdProdComm_symm", "code": "@[simp]\ntheorem prodProdProdComm_symm (\u03b1 \u03b2 \u03b3 \u03b4 : Type*) :\n    (prodProdProdComm \u03b1 \u03b2 \u03b3 \u03b4).symm = prodProdProdComm \u03b1 \u03b3 \u03b2 \u03b4", "start": [160, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.curry", "code": "@[simps (config := { fullyApplied := false })]\ndef curry (\u03b1 \u03b2 \u03b3) : (\u03b1 \u00d7 \u03b2 \u2192 \u03b3) \u2243 (\u03b1 \u2192 \u03b2 \u2192 \u03b3) where\n  toFun := Function.curry\n  invFun := uncurry\n  left_inv := uncurry_curry\n  right_inv := curry_uncurry", "start": [166, 1], "end": [172, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodPUnit", "code": "@[simps]\ndef prodPUnit (\u03b1) : \u03b1 \u00d7 PUnit \u2243 \u03b1 :=\n  \u27e8fun p => p.1, fun a => (a, PUnit.unit), fun \u27e8_, PUnit.unit\u27e9 => rfl, fun _ => rfl\u27e9", "start": [179, 1], "end": [182, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.punitProd", "code": "@[simps!]\ndef punitProd (\u03b1) : PUnit \u00d7 \u03b1 \u2243 \u03b1 :=\n  calc\n    PUnit \u00d7 \u03b1 \u2243 \u03b1 \u00d7 PUnit := prodComm _ _\n    _ \u2243 \u03b1 := prodPUnit _", "start": [187, 1], "end": [192, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaPUnit", "code": "@[simps]\ndef sigmaPUnit (\u03b1) : (_ : \u03b1) \u00d7 PUnit \u2243 \u03b1 :=\n  \u27e8fun p => p.1, fun a => \u27e8a, PUnit.unit\u27e9, fun \u27e8_, PUnit.unit\u27e9 => rfl, fun _ => rfl\u27e9", "start": [197, 1], "end": [200, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodUnique", "code": "def prodUnique (\u03b1 \u03b2) [Unique \u03b2] : \u03b1 \u00d7 \u03b2 \u2243 \u03b1 :=\n  ((Equiv.refl \u03b1).prodCongr <| equivPUnit.{_,1} \u03b2).trans <| prodPUnit \u03b1", "start": [202, 1], "end": [204, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_prodUnique", "code": "@[simp]\ntheorem coe_prodUnique [Unique \u03b2] : (\u21d1(prodUnique \u03b1 \u03b2) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) = Prod.fst", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodUnique_apply", "code": "theorem prodUnique_apply [Unique \u03b2] (x : \u03b1 \u00d7 \u03b2) : prodUnique \u03b1 \u03b2 x = x.1", "start": [212, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodUnique_symm_apply", "code": "@[simp]\ntheorem prodUnique_symm_apply [Unique \u03b2] (x : \u03b1) :\n    (prodUnique \u03b1 \u03b2).symm x = (x, default)", "start": [216, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniqueProd", "code": "def uniqueProd (\u03b1 \u03b2) [Unique \u03b2] : \u03b2 \u00d7 \u03b1 \u2243 \u03b1 :=\n  ((equivPUnit.{_,1} \u03b2).prodCongr <| Equiv.refl \u03b1).trans <| punitProd \u03b1", "start": [222, 1], "end": [224, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_uniqueProd", "code": "@[simp]\ntheorem coe_uniqueProd [Unique \u03b2] : (\u21d1(uniqueProd \u03b1 \u03b2) : \u03b2 \u00d7 \u03b1 \u2192 \u03b1) = Prod.snd", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniqueProd_apply", "code": "theorem uniqueProd_apply [Unique \u03b2] (x : \u03b2 \u00d7 \u03b1) : uniqueProd \u03b1 \u03b2 x = x.2", "start": [232, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniqueProd_symm_apply", "code": "@[simp]\ntheorem uniqueProd_symm_apply [Unique \u03b2] (x : \u03b1) :\n    (uniqueProd \u03b1 \u03b2).symm x = (default, x)", "start": [236, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaUnique", "code": "def sigmaUnique (\u03b1) (\u03b2 : \u03b1 \u2192 Type*) [\u2200 a, Unique (\u03b2 a)] : (a : \u03b1) \u00d7 (\u03b2 a) \u2243 \u03b1 :=\n  (Equiv.sigmaCongrRight fun a \u21a6 equivPUnit.{_,1} (\u03b2 a)).trans <| sigmaPUnit \u03b1", "start": [242, 1], "end": [245, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_sigmaUnique", "code": "@[simp]\ntheorem coe_sigmaUnique {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, Unique (\u03b2 a)] :\n    (\u21d1(sigmaUnique \u03b1 \u03b2) : (a : \u03b1) \u00d7 (\u03b2 a) \u2192 \u03b1) = Sigma.fst", "start": [247, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaUnique_apply", "code": "theorem sigmaUnique_apply {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, Unique (\u03b2 a)] (x : (a : \u03b1) \u00d7 \u03b2 a) :\n    sigmaUnique \u03b1 \u03b2 x = x.1", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaUnique_symm_apply", "code": "@[simp]\ntheorem sigmaUnique_symm_apply {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, Unique (\u03b2 a)] (x : \u03b1) :\n    (sigmaUnique \u03b1 \u03b2).symm x = \u27e8x, default\u27e9", "start": [256, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodEmpty", "code": "def prodEmpty (\u03b1) : \u03b1 \u00d7 Empty \u2243 Empty :=\n  equivEmpty _", "start": [261, 1], "end": [263, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.emptyProd", "code": "def emptyProd (\u03b1) : Empty \u00d7 \u03b1 \u2243 Empty :=\n  equivEmpty _", "start": [266, 1], "end": [268, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodPEmpty", "code": "def prodPEmpty (\u03b1) : \u03b1 \u00d7 PEmpty \u2243 PEmpty :=\n  equivPEmpty _", "start": [271, 1], "end": [273, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.pemptyProd", "code": "def pemptyProd (\u03b1) : PEmpty \u00d7 \u03b1 \u2243 PEmpty :=\n  equivPEmpty _", "start": [276, 1], "end": [278, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.psumEquivSum", "code": "def psumEquivSum (\u03b1 \u03b2) : PSum \u03b1 \u03b2 \u2243 Sum \u03b1 \u03b2 where\n  toFun s := PSum.casesOn s inl inr\n  invFun := Sum.elim PSum.inl PSum.inr\n  left_inv s := by cases s <;> rfl\n  right_inv s := by cases s <;> rfl", "start": [287, 1], "end": [292, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCongr", "code": "@[simps apply]\ndef sumCongr (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) : Sum \u03b1\u2081 \u03b2\u2081 \u2243 Sum \u03b1\u2082 \u03b2\u2082 :=\n  \u27e8Sum.map ea eb, Sum.map ea.symm eb.symm, fun x => by simp, fun x => by simp\u27e9", "start": [295, 1], "end": [298, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.psumCongr", "code": "def psumCongr (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b3 \u2243 \u03b4) : PSum \u03b1 \u03b3 \u2243 PSum \u03b2 \u03b4 where\n  toFun x := PSum.casesOn x (PSum.inl \u2218 e\u2081) (PSum.inr \u2218 e\u2082)\n  invFun x := PSum.casesOn x (PSum.inl \u2218 e\u2081.symm) (PSum.inr \u2218 e\u2082.symm)\n  left_inv := by rintro (x | x) <;> simp\n  right_inv := by rintro (x | x) <;> simp", "start": [302, 1], "end": [307, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.psumSum", "code": "def psumSum (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    PSum \u03b1\u2081 \u03b2\u2081 \u2243 Sum \u03b1\u2082 \u03b2\u2082 :=\n  (ea.psumCongr eb).trans (psumEquivSum _ _)", "start": [310, 1], "end": [313, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumPSum", "code": "def sumPSum (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    Sum \u03b1\u2081 \u03b2\u2081 \u2243 PSum \u03b1\u2082 \u03b2\u2082 :=\n  (ea.symm.psumSum eb.symm).symm", "start": [316, 1], "end": [319, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCongr_trans", "code": "@[simp]\ntheorem sumCongr_trans (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2082 \u2243 \u03b2\u2082) (g : \u03b2\u2081 \u2243 \u03b3\u2081) (h : \u03b2\u2082 \u2243 \u03b3\u2082) :\n    (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h)", "start": [322, 1], "end": [326, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCongr_symm", "code": "@[simp]\ntheorem sumCongr_symm (e : \u03b1 \u2243 \u03b2) (f : \u03b3 \u2243 \u03b4) :\n    (Equiv.sumCongr e f).symm = Equiv.sumCongr e.symm f.symm", "start": [329, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCongr_refl", "code": "@[simp]\ntheorem sumCongr_refl : Equiv.sumCongr (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (Sum \u03b1 \u03b2)", "start": [335, 1], "end": [338, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeSum", "code": "def subtypeSum {p : \u03b1 \u2295 \u03b2 \u2192 Prop} : {c // p c} \u2243 {a // p (Sum.inl a)} \u2295 {b // p (Sum.inr b)} where\n  toFun c := match h : c.1 with\n    | Sum.inl a => Sum.inl \u27e8a, h \u25b8 c.2\u27e9\n    | Sum.inr b => Sum.inr \u27e8b, h \u25b8 c.2\u27e9\n  invFun c := match c with\n    | Sum.inl a => \u27e8Sum.inl a, a.2\u27e9\n    | Sum.inr b => \u27e8Sum.inr b, b.2\u27e9\n  left_inv := by rintro \u27e8a | b, h\u27e9 <;> rfl\n  right_inv := by rintro (a | b) <;> rfl", "start": [341, 1], "end": [350, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr", "code": "@[reducible]\ndef sumCongr (ea : Equiv.Perm \u03b1) (eb : Equiv.Perm \u03b2) : Equiv.Perm (Sum \u03b1 \u03b2) :=\n  Equiv.sumCongr ea eb", "start": [354, 1], "end": [357, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_apply", "code": "@[simp]\ntheorem sumCongr_apply (ea : Equiv.Perm \u03b1) (eb : Equiv.Perm \u03b2) (x : Sum \u03b1 \u03b2) :\n    sumCongr ea eb x = Sum.map (\u21d1ea) (\u21d1eb) x", "start": [360, 1], "end": [363, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_trans", "code": "theorem sumCongr_trans (e : Equiv.Perm \u03b1) (f : Equiv.Perm \u03b2) (g : Equiv.Perm \u03b1)\n    (h : Equiv.Perm \u03b2) : (sumCongr e f).trans (sumCongr g h) = sumCongr (e.trans g) (f.trans h)", "start": [368, 1], "end": [370, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_symm", "code": "theorem sumCongr_symm (e : Equiv.Perm \u03b1) (f : Equiv.Perm \u03b2) :\n    (sumCongr e f).symm = sumCongr e.symm f.symm", "start": [373, 1], "end": [375, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_refl", "code": "theorem sumCongr_refl : sumCongr (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (Sum \u03b1 \u03b2)", "start": [378, 1], "end": [379, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.boolEquivPUnitSumPUnit", "code": "def boolEquivPUnitSumPUnit : Bool \u2243 Sum PUnit.{u + 1} PUnit.{v + 1} :=\n  \u27e8fun b => b.casesOn (inl PUnit.unit) (inr PUnit.unit) , Sum.elim (fun _ => false) fun _ => true,\n    fun b => by cases b <;> rfl, fun s => by rcases s with (\u27e8\u27e8\u27e9\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> rfl\u27e9", "start": [384, 1], "end": [387, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumComm", "code": "@[simps (config := { fullyApplied := false }) apply]\ndef sumComm (\u03b1 \u03b2) : Sum \u03b1 \u03b2 \u2243 Sum \u03b2 \u03b1 :=\n  \u27e8Sum.swap, Sum.swap, Sum.swap_swap, Sum.swap_swap\u27e9", "start": [390, 1], "end": [393, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumComm_symm", "code": "@[simp]\ntheorem sumComm_symm (\u03b1 \u03b2) : (sumComm \u03b1 \u03b2).symm = sumComm \u03b2 \u03b1", "start": [397, 1], "end": [399, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc", "code": "def sumAssoc (\u03b1 \u03b2 \u03b3) : Sum (Sum \u03b1 \u03b2) \u03b3 \u2243 Sum \u03b1 (Sum \u03b2 \u03b3) :=\n  \u27e8Sum.elim (Sum.elim Sum.inl (Sum.inr \u2218 Sum.inl)) (Sum.inr \u2218 Sum.inr),\n    Sum.elim (Sum.inl \u2218 Sum.inl) <| Sum.elim (Sum.inl \u2218 Sum.inr) Sum.inr,\n      by rintro (\u27e8_ | _\u27e9 | _) <;> rfl, by\n    rintro (_ | \u27e8_ | _\u27e9) <;> rfl\u27e9", "start": [402, 1], "end": [407, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_apply_inl_inl", "code": "@[simp]\ntheorem sumAssoc_apply_inl_inl (a) : sumAssoc \u03b1 \u03b2 \u03b3 (inl (inl a)) = inl a", "start": [410, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_apply_inl_inr", "code": "@[simp]\ntheorem sumAssoc_apply_inl_inr (b) : sumAssoc \u03b1 \u03b2 \u03b3 (inl (inr b)) = inr (inl b)", "start": [415, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_apply_inr", "code": "@[simp]\ntheorem sumAssoc_apply_inr (c) : sumAssoc \u03b1 \u03b2 \u03b3 (inr c) = inr (inr c)", "start": [420, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_symm_apply_inl", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inl {\u03b1 \u03b2 \u03b3} (a) : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inl a) = inl (inl a)", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_symm_apply_inr_inl", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inr_inl {\u03b1 \u03b2 \u03b3} (b) :\n    (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inl b)) = inl (inr b)", "start": [430, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumAssoc_symm_apply_inr_inr", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inr_inr {\u03b1 \u03b2 \u03b3} (c) : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c", "start": [436, 1], "end": [438, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumEmpty", "code": "@[simps symm_apply]\ndef sumEmpty (\u03b1 \u03b2) [IsEmpty \u03b2] : Sum \u03b1 \u03b2 \u2243 \u03b1 where\n  toFun := Sum.elim id isEmptyElim\n  invFun := inl\n  left_inv s := by\n    rcases s with (_ | x)\n    \u00b7 rfl\n    \u00b7 exact isEmptyElim x\n  right_inv _ := rfl", "start": [441, 1], "end": [450, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumEmpty_apply_inl", "code": "@[simp]\ntheorem sumEmpty_apply_inl [IsEmpty \u03b2] (a : \u03b1) : sumEmpty \u03b1 \u03b2 (Sum.inl a) = a", "start": [454, 1], "end": [456, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.emptySum", "code": "@[simps! symm_apply]\ndef emptySum (\u03b1 \u03b2) [IsEmpty \u03b1] : Sum \u03b1 \u03b2 \u2243 \u03b2 :=\n  (sumComm _ _).trans <| sumEmpty _ _", "start": [459, 1], "end": [462, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.emptySum_apply_inr", "code": "@[simp]\ntheorem emptySum_apply_inr [IsEmpty \u03b1] (b : \u03b2) : emptySum \u03b1 \u03b2 (Sum.inr b) = b", "start": [466, 1], "end": [468, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit", "code": "def optionEquivSumPUnit (\u03b1) : Option \u03b1 \u2243 Sum \u03b1 PUnit :=\n  \u27e8fun o => o.elim (inr PUnit.unit) inl, fun s => s.elim some fun _ => none,\n    fun o => by cases o <;> rfl,\n    fun s => by rcases s with (_ | \u27e8\u27e8\u27e9\u27e9) <;> rfl\u27e9", "start": [471, 1], "end": [475, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit_none", "code": "@[simp]\ntheorem optionEquivSumPUnit_none : optionEquivSumPUnit \u03b1 none = Sum.inr PUnit.unit", "start": [478, 1], "end": [480, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit_some", "code": "@[simp]\ntheorem optionEquivSumPUnit_some (a) : optionEquivSumPUnit \u03b1 (some a) = Sum.inl a", "start": [483, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit_coe", "code": "@[simp]\ntheorem optionEquivSumPUnit_coe (a : \u03b1) : optionEquivSumPUnit \u03b1 a = Sum.inl a", "start": [488, 1], "end": [490, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit_symm_inl", "code": "@[simp]\ntheorem optionEquivSumPUnit_symm_inl (a) : (optionEquivSumPUnit \u03b1).symm (Sum.inl a) = a", "start": [493, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionEquivSumPUnit_symm_inr", "code": "@[simp]\ntheorem optionEquivSumPUnit_symm_inr (a) : (optionEquivSumPUnit \u03b1).symm (Sum.inr a) = none", "start": [498, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionIsSomeEquiv", "code": "@[simps]\ndef optionIsSomeEquiv (\u03b1) : { x : Option \u03b1 // x.isSome } \u2243 \u03b1 where\n  toFun o := Option.get _ o.2\n  invFun x := \u27e8some x, rfl\u27e9\n  left_inv _ := Subtype.eq <| Option.some_get _\n  right_inv _ := Option.get_some _ _", "start": [503, 1], "end": [509, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.piOptionEquivProd", "code": "@[simps]\ndef piOptionEquivProd {\u03b2 : Option \u03b1 \u2192 Type*} :\n    (\u2200 a : Option \u03b1, \u03b2 a) \u2243 \u03b2 none \u00d7 \u2200 a : \u03b1, \u03b2 (some a) where\n  toFun f := (f none, fun a => f (some a))\n  invFun x a := Option.casesOn a x.fst x.snd\n  left_inv f := funext fun a => by cases a <;> rfl\n  right_inv x := by simp", "start": [514, 1], "end": [522, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumEquivSigmaBool", "code": "def sumEquivSigmaBool (\u03b1 \u03b2 : Type u) : Sum \u03b1 \u03b2 \u2243 \u03a3 b : Bool, b.casesOn \u03b1 \u03b2 :=\n  \u27e8fun s => s.elim (fun x => \u27e8false, x\u27e9) fun x => \u27e8true, x\u27e9, fun s =>\n    match s with\n    | \u27e8false, a\u27e9 => inl a\n    | \u27e8true, b\u27e9 => inr b,\n    fun s => by cases s <;> rfl, fun s => by rcases s with \u27e8_ | _, _\u27e9 <;> rfl\u27e9", "start": [527, 1], "end": [536, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaFiberEquiv", "code": "@[simps]\ndef sigmaFiberEquiv {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) : (\u03a3 y : \u03b2, { x // f x = y }) \u2243 \u03b1 :=\n  \u27e8fun x => \u2191x.2, fun x => \u27e8f x, x, rfl\u27e9, fun \u27e8_, _, rfl\u27e9 => rfl, fun _ => rfl\u27e9", "start": [540, 1], "end": [544, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCompl", "code": "def sumCompl {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Sum { a // p a } { a // \u00acp a } \u2243 \u03b1 where\n  toFun := Sum.elim Subtype.val Subtype.val\n  invFun a := if h : p a then Sum.inl \u27e8a, h\u27e9 else Sum.inr \u27e8a, h\u27e9\n  left_inv := by\n    rintro (\u27e8x, hx\u27e9 | \u27e8x, hx\u27e9) <;> dsimp\n    \u00b7 rw [dif_pos]\n    \u00b7 rw [dif_neg]\n  right_inv a := by\n    dsimp\n    split_ifs <;> rfl", "start": [554, 1], "end": [570, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCompl_apply_inl", "code": "@[simp]\ntheorem sumCompl_apply_inl (p : \u03b1 \u2192 Prop) [DecidablePred p] (x : { a // p a }) :\n    sumCompl p (Sum.inl x) = x", "start": [573, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCompl_apply_inr", "code": "@[simp]\ntheorem sumCompl_apply_inr (p : \u03b1 \u2192 Prop) [DecidablePred p] (x : { a // \u00acp a }) :\n    sumCompl p (Sum.inr x) = x", "start": [579, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCompl_apply_symm_of_pos", "code": "@[simp]\ntheorem sumCompl_apply_symm_of_pos (p : \u03b1 \u2192 Prop) [DecidablePred p] (a : \u03b1) (h : p a) :\n    (sumCompl p).symm a = Sum.inl \u27e8a, h\u27e9", "start": [585, 1], "end": [588, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumCompl_apply_symm_of_neg", "code": "@[simp]\ntheorem sumCompl_apply_symm_of_neg (p : \u03b1 \u2192 Prop) [DecidablePred p] (a : \u03b1) (h : \u00acp a) :\n    (sumCompl p).symm a = Sum.inr \u27e8a, h\u27e9", "start": [591, 1], "end": [594, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeCongr", "code": "def subtypeCongr {p q : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred q]\n    (e : { x // p x } \u2243 { x // q x }) (f : { x // \u00acp x } \u2243 { x // \u00acq x }) : Perm \u03b1 :=\n  (sumCompl p).symm.trans ((sumCongr e f).trans (sumCompl q))", "start": [597, 1], "end": [601, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr", "code": "def Perm.subtypeCongr : Equiv.Perm \u03b5 :=\n  permCongr (sumCompl p) (sumCongr ep en)", "start": [608, 1], "end": [611, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.apply", "code": "theorem Perm.subtypeCongr.apply (a : \u03b5) : ep.subtypeCongr en a =\n    if h : p a then (ep \u27e8a, h\u27e9 : \u03b5) else en \u27e8a, h\u27e9", "start": [614, 1], "end": [616, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.left_apply", "code": "@[simp]\ntheorem Perm.subtypeCongr.left_apply {a : \u03b5} (h : p a) : ep.subtypeCongr en a = ep \u27e8a, h\u27e9", "start": [619, 1], "end": [621, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.left_apply_subtype", "code": "@[simp]\ntheorem Perm.subtypeCongr.left_apply_subtype (a : { a // p a }) : ep.subtypeCongr en a = ep a", "start": [624, 1], "end": [626, 50], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.right_apply", "code": "@[simp]\ntheorem Perm.subtypeCongr.right_apply {a : \u03b5} (h : \u00acp a) : ep.subtypeCongr en a = en \u27e8a, h\u27e9", "start": [629, 1], "end": [631, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.right_apply_subtype", "code": "@[simp]\ntheorem Perm.subtypeCongr.right_apply_subtype (a : { a // \u00acp a }) : ep.subtypeCongr en a = en a", "start": [634, 1], "end": [636, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.refl", "code": "@[simp]\ntheorem Perm.subtypeCongr.refl :\n    Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // \u00acp a }) = Equiv.refl \u03b5", "start": [639, 1], "end": [643, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.symm", "code": "@[simp]\ntheorem Perm.subtypeCongr.symm : (ep.subtypeCongr en).symm = Perm.subtypeCongr ep.symm en.symm", "start": [646, 1], "end": [653, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.subtypeCongr.trans", "code": "@[simp]\ntheorem Perm.subtypeCongr.trans :\n    (ep.subtypeCongr en).trans (ep'.subtypeCongr en')\n    = Perm.subtypeCongr (ep.trans ep') (en.trans en')", "start": [656, 1], "end": [665, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypePreimage", "code": "@[simps]\ndef subtypePreimage : { x : \u03b1 \u2192 \u03b2 // x \u2218 Subtype.val = x\u2080 } \u2243 ({ a // \u00acp a } \u2192 \u03b2) where\n  toFun (x : { x : \u03b1 \u2192 \u03b2 // x \u2218 Subtype.val = x\u2080 }) a := (x : \u03b1 \u2192 \u03b2) a\n  invFun x := \u27e8fun a => if h : p a then x\u2080 \u27e8a, h\u27e9 else x \u27e8a, h\u27e9, funext fun \u27e8a, h\u27e9 => dif_pos h\u27e9\n  left_inv := fun \u27e8x, hx\u27e9 =>\n    Subtype.val_injective <|\n      funext fun a => by\n        dsimp only\n        split_ifs\n        \u00b7 rw [\u2190 hx]; rfl\n        \u00b7 rfl\n  right_inv x :=\n    funext fun \u27e8a, h\u27e9 =>\n      show dite (p a) _ _ = _ by\n        dsimp only\n        rw [dif_neg h]", "start": [674, 1], "end": [692, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypePreimage_symm_apply_coe_pos", "code": "theorem subtypePreimage_symm_apply_coe_pos (x : { a // \u00acp a } \u2192 \u03b2) (a : \u03b1) (h : p a) :\n    ((subtypePreimage p x\u2080).symm x : \u03b1 \u2192 \u03b2) a = x\u2080 \u27e8a, h\u27e9", "start": [697, 1], "end": [699, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypePreimage_symm_apply_coe_neg", "code": "theorem subtypePreimage_symm_apply_coe_neg (x : { a // \u00acp a } \u2192 \u03b2) (a : \u03b1) (h : \u00acp a) :\n    ((subtypePreimage p x\u2080).symm x : \u03b1 \u2192 \u03b2) a = x \u27e8a, h\u27e9", "start": [702, 1], "end": [704, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrRight", "code": "def piCongrRight {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Sort*} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) : (\u2200 a, \u03b2\u2081 a) \u2243 (\u2200 a, \u03b2\u2082 a) :=\n  \u27e8fun H a => F a (H a), fun H a => (F a).symm (H a), fun H => funext <| by simp,\n    fun H => funext <| by simp\u27e9", "start": [711, 1], "end": [715, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.piComm", "code": "@[simps apply]\ndef piComm (\u03c6 : \u03b1 \u2192 \u03b2 \u2192 Sort*) : (\u2200 a b, \u03c6 a b) \u2243 \u2200 b a, \u03c6 a b :=\n  \u27e8swap, swap, fun _ => rfl, fun _ => rfl\u27e9", "start": [718, 1], "end": [722, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.piComm_symm", "code": "@[simp]\ntheorem piComm_symm {\u03c6 : \u03b1 \u2192 \u03b2 \u2192 Sort*} : (piComm \u03c6).symm = (piComm <| swap \u03c6)", "start": [726, 1], "end": [728, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCurry", "code": "def piCurry {\u03b2 : \u03b1 \u2192 Sort _} (\u03b3 : \u2200 a, \u03b2 a \u2192 Sort _) :\n    (\u2200 x : \u03a3 i, \u03b2 i, \u03b3 x.1 x.2) \u2243 \u2200 a b, \u03b3 a b where\n  toFun := Sigma.curry\n  invFun := Sigma.uncurry\n  left_inv := Sigma.uncurry_curry\n  right_inv := Sigma.curry_uncurry", "start": [731, 1], "end": [740, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrLeft", "code": "def prodCongrLeft : \u03b2\u2081 \u00d7 \u03b1\u2081 \u2243 \u03b2\u2082 \u00d7 \u03b1\u2081 where\n  toFun ab := \u27e8e ab.2 ab.1, ab.2\u27e9\n  invFun ab := \u27e8(e ab.2).symm ab.1, ab.2\u27e9\n  left_inv := by\n    rintro \u27e8a, b\u27e9\n    simp\n  right_inv := by\n    rintro \u27e8a, b\u27e9\n    simp", "start": [749, 1], "end": [759, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrLeft_apply", "code": "@[simp]\ntheorem prodCongrLeft_apply (b : \u03b2\u2081) (a : \u03b1\u2081) : prodCongrLeft e (b, a) = (e a b, a)", "start": [762, 1], "end": [764, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongr_refl_right", "code": "theorem prodCongr_refl_right (e : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    prodCongr e (Equiv.refl \u03b1\u2081) = prodCongrLeft fun _ => e", "start": [767, 1], "end": [770, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrRight", "code": "def prodCongrRight : \u03b1\u2081 \u00d7 \u03b2\u2081 \u2243 \u03b1\u2081 \u00d7 \u03b2\u2082 where\n  toFun ab := \u27e8ab.1, e ab.1 ab.2\u27e9\n  invFun ab := \u27e8ab.1, (e ab.1).symm ab.2\u27e9\n  left_inv := by\n    rintro \u27e8a, b\u27e9\n    simp\n  right_inv := by\n    rintro \u27e8a, b\u27e9\n    simp", "start": [773, 1], "end": [783, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrRight_apply", "code": "@[simp]\ntheorem prodCongrRight_apply (a : \u03b1\u2081) (b : \u03b2\u2081) : prodCongrRight e (a, b) = (a, e a b)", "start": [786, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongr_refl_left", "code": "theorem prodCongr_refl_left (e : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    prodCongr (Equiv.refl \u03b1\u2081) e = prodCongrRight fun _ => e", "start": [791, 1], "end": [794, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrLeft_trans_prodComm", "code": "@[simp]\ntheorem prodCongrLeft_trans_prodComm :\n    (prodCongrLeft e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrRight e)", "start": [797, 1], "end": [801, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodCongrRight_trans_prodComm", "code": "@[simp]\ntheorem prodCongrRight_trans_prodComm :\n    (prodCongrRight e).trans (prodComm _ _) = (prodComm _ _).trans (prodCongrLeft e)", "start": [804, 1], "end": [808, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaCongrRight_sigmaEquivProd", "code": "theorem sigmaCongrRight_sigmaEquivProd :\n    (sigmaCongrRight e).trans (sigmaEquivProd \u03b1\u2081 \u03b2\u2082)\n    = (sigmaEquivProd \u03b1\u2081 \u03b2\u2081).trans (prodCongrRight e)", "start": [811, 1], "end": [815, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaEquivProd_sigmaCongrRight", "code": "theorem sigmaEquivProd_sigmaCongrRight :\n    (sigmaEquivProd \u03b1\u2081 \u03b2\u2081).symm.trans (sigmaCongrRight e)\n    = (prodCongrRight e).trans (sigmaEquivProd \u03b1\u2081 \u03b2\u2082).symm", "start": [818, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofFiberEquiv", "code": "@[simps!]\ndef ofFiberEquiv {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (e : \u2200 c, { a // f a = c } \u2243 { b // g b = c }) : \u03b1 \u2243 \u03b2 :=\n  (sigmaFiberEquiv f).symm.trans <| (Equiv.sigmaCongrRight e).trans (sigmaFiberEquiv g)", "start": [827, 1], "end": [830, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofFiberEquiv_map", "code": "theorem ofFiberEquiv_map {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3}\n    (e : \u2200 c, { a // f a = c } \u2243 { b // g b = c }) (a : \u03b1) : g (ofFiberEquiv e a) = f a", "start": [835, 1], "end": [837, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodShear", "code": "@[simps (config := { fullyApplied := false })]\ndef prodShear (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082) : \u03b1\u2081 \u00d7 \u03b2\u2081 \u2243 \u03b1\u2082 \u00d7 \u03b2\u2082 where\n  toFun := fun x : \u03b1\u2081 \u00d7 \u03b2\u2081 => (e\u2081 x.1, e\u2082 x.1 x.2)\n  invFun := fun y : \u03b1\u2082 \u00d7 \u03b2\u2082 => (e\u2081.symm y.1, (e\u2082 <| e\u2081.symm y.1).symm y.2)\n  left_inv := by\n    rintro \u27e8x\u2081, y\u2081\u27e9\n    simp only [symm_apply_apply]\n  right_inv := by\n    rintro \u27e8x\u2081, y\u2081\u27e9\n    simp only [apply_symm_apply]", "start": [840, 1], "end": [852, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prodExtendRight", "code": "def prodExtendRight : Perm (\u03b1\u2081 \u00d7 \u03b2\u2081) where\n  toFun ab := if ab.fst = a then (a, e ab.snd) else ab\n  invFun ab := if ab.fst = a then (a, e.symm ab.snd) else ab\n  left_inv := by\n    rintro \u27e8k', x\u27e9\n    dsimp only\n    split_ifs with h\u2081 h\u2082\n    \u00b7 simp [h\u2081]\n    \u00b7 simp at h\u2082\n    \u00b7 simp\n  right_inv := by\n    rintro \u27e8k', x\u27e9\n    dsimp only\n    split_ifs with h\u2081 h\u2082\n    \u00b7 simp [h\u2081]\n    \u00b7 simp at h\u2082\n    \u00b7 simp", "start": [863, 1], "end": [881, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prodExtendRight_apply_eq", "code": "@[simp]\ntheorem prodExtendRight_apply_eq (b : \u03b2\u2081) : prodExtendRight a e (a, b) = (a, e b)", "start": [884, 1], "end": [886, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.prodExtendRight_apply_ne", "code": "theorem prodExtendRight_apply_ne {a a' : \u03b1\u2081} (h : a' \u2260 a) (b : \u03b2\u2081) :\n    prodExtendRight a e (a', b) = (a', b)", "start": [889, 1], "end": [891, 11], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.eq_of_prodExtendRight_ne", "code": "theorem eq_of_prodExtendRight_ne {e : Perm \u03b2\u2081} {a a' : \u03b1\u2081} {b : \u03b2\u2081}\n    (h : prodExtendRight a e (a', b) \u2260 (a', b)) : a' = a", "start": [894, 1], "end": [897, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.fst_prodExtendRight", "code": "@[simp]\ntheorem fst_prodExtendRight (ab : \u03b1\u2081 \u00d7 \u03b2\u2081) : (prodExtendRight a e ab).fst = ab.fst", "start": [900, 1], "end": [906, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.arrowProdEquivProdArrow", "code": "def arrowProdEquivProdArrow (\u03b1 \u03b2 \u03b3 : Type*) : (\u03b3 \u2192 \u03b1 \u00d7 \u03b2) \u2243 (\u03b3 \u2192 \u03b1) \u00d7 (\u03b3 \u2192 \u03b2) where\n  toFun := fun f => (fun c => (f c).1, fun c => (f c).2)\n  invFun := fun p c => (p.1 c, p.2 c)\n  left_inv := fun f => rfl\n  right_inv := fun p => by cases p; rfl", "start": [913, 1], "end": [919, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumPiEquivProdPi", "code": "@[simps]\ndef sumPiEquivProdPi (\u03c0 : \u03b9 \u2295 \u03b9' \u2192 Type*) : (\u2200 i, \u03c0 i) \u2243 (\u2200 i, \u03c0 (inl i)) \u00d7 \u2200 i', \u03c0 (inr i')\n    where\n  toFun f := \u27e8fun i => f (inl i), fun i' => f (inr i')\u27e9\n  invFun g := Sum.rec g.1 g.2\n  left_inv f := by ext (i | i) <;> rfl\n  right_inv g := Prod.ext rfl rfl", "start": [924, 1], "end": [932, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodPiEquivSumPi", "code": "@[simps!]\ndef prodPiEquivSumPi (\u03c0 : \u03b9 \u2192 Type u) (\u03c0' : \u03b9' \u2192 Type u) :\n    ((\u2200 i, \u03c0 i) \u00d7 \u2200 i', \u03c0' i') \u2243 \u2200 i, Sum.elim \u03c0 \u03c0' i :=\n  sumPiEquivProdPi (Sum.elim \u03c0 \u03c0') |>.symm", "start": [934, 1], "end": [939, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumArrowEquivProdArrow", "code": "def sumArrowEquivProdArrow (\u03b1 \u03b2 \u03b3 : Type*) : (Sum \u03b1 \u03b2 \u2192 \u03b3) \u2243 (\u03b1 \u2192 \u03b3) \u00d7 (\u03b2 \u2192 \u03b3) :=\n  \u27e8fun f => (f \u2218 inl, f \u2218 inr), fun p => Sum.elim p.1 p.2, fun f => by ext \u27e8\u27e9 <;> rfl, fun p => by\n    cases p\n    rfl\u27e9", "start": [941, 1], "end": [946, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumArrowEquivProdArrow_apply_fst", "code": "@[simp]\ntheorem sumArrowEquivProdArrow_apply_fst (f : Sum \u03b1 \u03b2 \u2192 \u03b3) (a : \u03b1) :\n    (sumArrowEquivProdArrow \u03b1 \u03b2 \u03b3 f).1 a = f (inl a)", "start": [949, 1], "end": [952, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumArrowEquivProdArrow_apply_snd", "code": "@[simp]\ntheorem sumArrowEquivProdArrow_apply_snd (f : Sum \u03b1 \u03b2 \u2192 \u03b3) (b : \u03b2) :\n    (sumArrowEquivProdArrow \u03b1 \u03b2 \u03b3 f).2 b = f (inr b)", "start": [955, 1], "end": [958, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumArrowEquivProdArrow_symm_apply_inl", "code": "@[simp]\ntheorem sumArrowEquivProdArrow_symm_apply_inl (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (a : \u03b1) :\n    ((sumArrowEquivProdArrow \u03b1 \u03b2 \u03b3).symm (f, g)) (inl a) = f a", "start": [961, 1], "end": [964, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumArrowEquivProdArrow_symm_apply_inr", "code": "@[simp]\ntheorem sumArrowEquivProdArrow_symm_apply_inr (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) (b : \u03b2) :\n    ((sumArrowEquivProdArrow \u03b1 \u03b2 \u03b3).symm (f, g)) (inr b) = g b", "start": [967, 1], "end": [970, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumProdDistrib", "code": "def sumProdDistrib (\u03b1 \u03b2 \u03b3) : Sum \u03b1 \u03b2 \u00d7 \u03b3 \u2243 Sum (\u03b1 \u00d7 \u03b3) (\u03b2 \u00d7 \u03b3) :=\n  \u27e8fun p => p.1.map (fun x => (x, p.2)) fun x => (x, p.2),\n    fun s => s.elim (Prod.map inl id) (Prod.map inr id), by\n      rintro \u27e8_ | _, _\u27e9 <;> rfl, by rintro (\u27e8_, _\u27e9 | \u27e8_, _\u27e9) <;> rfl\u27e9", "start": [973, 1], "end": [977, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumProdDistrib_apply_left", "code": "@[simp]\ntheorem sumProdDistrib_apply_left (a : \u03b1) (c : \u03b3) :\n    sumProdDistrib \u03b1 \u03b2 \u03b3 (Sum.inl a, c) = Sum.inl (a, c)", "start": [980, 1], "end": [983, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumProdDistrib_apply_right", "code": "@[simp]\ntheorem sumProdDistrib_apply_right (b : \u03b2) (c : \u03b3) :\n    sumProdDistrib \u03b1 \u03b2 \u03b3 (Sum.inr b, c) = Sum.inr (b, c)", "start": [986, 1], "end": [989, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumProdDistrib_symm_apply_left", "code": "@[simp]\ntheorem sumProdDistrib_symm_apply_left (a : \u03b1 \u00d7 \u03b3) :\n    (sumProdDistrib \u03b1 \u03b2 \u03b3).symm (inl a) = (inl a.1, a.2)", "start": [992, 1], "end": [995, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sumProdDistrib_symm_apply_right", "code": "@[simp]\ntheorem sumProdDistrib_symm_apply_right (b : \u03b2 \u00d7 \u03b3) :\n    (sumProdDistrib \u03b1 \u03b2 \u03b3).symm (inr b) = (inr b.1, b.2)", "start": [998, 1], "end": [1001, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodSumDistrib", "code": "def prodSumDistrib (\u03b1 \u03b2 \u03b3) : \u03b1 \u00d7 Sum \u03b2 \u03b3 \u2243 Sum (\u03b1 \u00d7 \u03b2) (\u03b1 \u00d7 \u03b3) :=\n  calc\n    \u03b1 \u00d7 Sum \u03b2 \u03b3 \u2243 Sum \u03b2 \u03b3 \u00d7 \u03b1 := prodComm _ _\n    _ \u2243 Sum (\u03b2 \u00d7 \u03b1) (\u03b3 \u00d7 \u03b1) := sumProdDistrib _ _ _\n    _ \u2243 Sum (\u03b1 \u00d7 \u03b2) (\u03b1 \u00d7 \u03b3) := sumCongr (prodComm _ _) (prodComm _ _)", "start": [1004, 1], "end": [1009, 70], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodSumDistrib_apply_left", "code": "@[simp]\ntheorem prodSumDistrib_apply_left (a : \u03b1) (b : \u03b2) :\n    prodSumDistrib \u03b1 \u03b2 \u03b3 (a, Sum.inl b) = Sum.inl (a, b)", "start": [1012, 1], "end": [1015, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodSumDistrib_apply_right", "code": "@[simp]\ntheorem prodSumDistrib_apply_right (a : \u03b1) (c : \u03b3) :\n    prodSumDistrib \u03b1 \u03b2 \u03b3 (a, Sum.inr c) = Sum.inr (a, c)", "start": [1018, 1], "end": [1021, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodSumDistrib_symm_apply_left", "code": "@[simp]\ntheorem prodSumDistrib_symm_apply_left (a : \u03b1 \u00d7 \u03b2) :\n    (prodSumDistrib \u03b1 \u03b2 \u03b3).symm (inl a) = (a.1, inl a.2)", "start": [1024, 1], "end": [1027, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.prodSumDistrib_symm_apply_right", "code": "@[simp]\ntheorem prodSumDistrib_symm_apply_right (a : \u03b1 \u00d7 \u03b3) :\n    (prodSumDistrib \u03b1 \u03b2 \u03b3).symm (inr a) = (a.1, inr a.2)", "start": [1030, 1], "end": [1033, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaSumDistrib", "code": "@[simps]\ndef sigmaSumDistrib (\u03b1 \u03b2 : \u03b9 \u2192 Type*) :\n    (\u03a3 i, Sum (\u03b1 i) (\u03b2 i)) \u2243 Sum (\u03a3 i, \u03b1 i) (\u03a3 i, \u03b2 i) :=\n  \u27e8fun p => p.2.map (Sigma.mk p.1) (Sigma.mk p.1),\n    Sum.elim (Sigma.map id fun _ => Sum.inl) (Sigma.map id fun _ => Sum.inr), fun p => by\n    rcases p with \u27e8i, a | b\u27e9 <;> rfl, fun p => by rcases p with (\u27e8i, a\u27e9 | \u27e8i, b\u27e9) <;> rfl\u27e9", "start": [1036, 1], "end": [1042, 91], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaProdDistrib", "code": "def sigmaProdDistrib (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : Type*) : (\u03a3 i, \u03b1 i) \u00d7 \u03b2 \u2243 \u03a3 i, \u03b1 i \u00d7 \u03b2 :=\n  \u27e8fun p => \u27e8p.1.1, (p.1.2, p.2)\u27e9, fun p => (\u27e8p.1, p.2.1\u27e9, p.2.2), fun p => by\n    rcases p with \u27e8\u27e8_, _\u27e9, _\u27e9\n    rfl, fun p => by\n    rcases p with \u27e8_, \u27e8_, _\u27e9\u27e9\n    rfl\u27e9", "start": [1047, 1], "end": [1054, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaNatSucc", "code": "def sigmaNatSucc (f : \u2115 \u2192 Type u) : (\u03a3 n, f n) \u2243 Sum (f 0) (\u03a3 n, f (n + 1)) :=\n  \u27e8fun x =>\n    @Sigma.casesOn \u2115 f (fun _ => Sum (f 0) (\u03a3n, f (n + 1))) x fun n =>\n      @Nat.casesOn (fun i => f i \u2192 Sum (f 0) (\u03a3n : \u2115, f (n + 1))) n (fun x : f 0 => Sum.inl x)\n        fun (n : \u2115) (x : f n.succ) => Sum.inr \u27e8n, x\u27e9,\n    Sum.elim (Sigma.mk 0) (Sigma.map Nat.succ fun _ => id), by rintro \u27e8n | n, x\u27e9 <;> rfl, by\n    rintro (x | \u27e8n, x\u27e9) <;> rfl\u27e9", "start": [1057, 1], "end": [1064, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.boolProdEquivSum", "code": "@[simps]\ndef boolProdEquivSum (\u03b1) : Bool \u00d7 \u03b1 \u2243 Sum \u03b1 \u03b1 where\n  toFun p := p.1.casesOn (inl p.2) (inr p.2)\n  invFun := Sum.elim (Prod.mk false) (Prod.mk true)\n  left_inv := by rintro \u27e8_ | _, _\u27e9 <;> rfl\n  right_inv := by rintro (_ | _) <;> rfl", "start": [1067, 1], "end": [1073, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.boolArrowEquivProd", "code": "@[simps]\ndef boolArrowEquivProd (\u03b1) : (Bool \u2192 \u03b1) \u2243 \u03b1 \u00d7 \u03b1 where\n  toFun f := (f false, f true)\n  invFun p b := b.casesOn p.1 p.2\n  left_inv _ := funext <| Bool.forall_bool.2 \u27e8rfl, rfl\u27e9\n  right_inv := fun _ => rfl", "start": [1078, 1], "end": [1084, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.natEquivNatSumPUnit", "code": "def natEquivNatSumPUnit : \u2115 \u2243 Sum \u2115 PUnit where\n  toFun n := Nat.casesOn n (inr PUnit.unit) inl\n  invFun := Sum.elim Nat.succ fun _ => 0\n  left_inv n := by cases n <;> rfl\n  right_inv := by rintro (_ | _) <;> rfl", "start": [1095, 1], "end": [1100, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.natSumPUnitEquivNat", "code": "def natSumPUnitEquivNat : Sum \u2115 PUnit \u2243 \u2115 :=\n  natEquivNatSumPUnit.symm", "start": [1103, 1], "end": [1105, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.intEquivNatSumNat", "code": "def intEquivNatSumNat : \u2124 \u2243 Sum \u2115 \u2115 where\n  toFun z := Int.casesOn z inl inr\n  invFun := Sum.elim Int.ofNat Int.negSucc\n  left_inv := by rintro (m | n) <;> rfl\n  right_inv := by rintro (m | n) <;> rfl", "start": [1108, 1], "end": [1113, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.listEquivOfEquiv", "code": "def listEquivOfEquiv (e : \u03b1 \u2243 \u03b2) : List \u03b1 \u2243 List \u03b2 where\n  toFun := List.map e\n  invFun := List.map e.symm\n  left_inv l := by rw [List.map_map, e.symm_comp_self, List.map_id]\n  right_inv l := by rw [List.map_map, e.self_comp_symm, List.map_id]", "start": [1118, 1], "end": [1123, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniqueCongr", "code": "def uniqueCongr (e : \u03b1 \u2243 \u03b2) : Unique \u03b1 \u2243 Unique \u03b2 where\n  toFun h := @Equiv.unique _ _ h e.symm\n  invFun h := @Equiv.unique _ _ h e\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [1126, 1], "end": [1131, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.isEmpty_congr", "code": "theorem isEmpty_congr (e : \u03b1 \u2243 \u03b2) : IsEmpty \u03b1 \u2194 IsEmpty \u03b2", "start": [1134, 1], "end": [1136, 80], "kind": "commanddeclaration"}, {"full_name": "Equiv.isEmpty", "code": "protected theorem isEmpty (e : \u03b1 \u2243 \u03b2) [IsEmpty \u03b2] : IsEmpty \u03b1", "start": [1139, 1], "end": [1140, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquiv", "code": "def subtypeEquiv {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) (h : \u2200 a, p a \u2194 q (e a)) :\n    { a : \u03b1 // p a } \u2243 { b : \u03b2 // q b } where\n  toFun a := \u27e8e a, (h _).mp a.property\u27e9\n  invFun b := \u27e8e.symm b, (h _).mpr ((e.apply_symm_apply b).symm \u25b8 b.property)\u27e9\n  left_inv a := Subtype.ext <| by simp\n  right_inv b := Subtype.ext <| by simp", "start": [1147, 1], "end": [1155, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquiv_refl", "code": "@[simp]\ntheorem subtypeEquiv_refl {p : \u03b1 \u2192 Prop} (h : \u2200 a, p a \u2194 p (Equiv.refl _ a) := fun a => Iff.rfl) :\n    (Equiv.refl \u03b1).subtypeEquiv h = Equiv.refl { a : \u03b1 // p a }", "start": [1158, 1], "end": [1162, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquiv_symm", "code": "@[simp]\ntheorem subtypeEquiv_symm {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) (h : \u2200 a : \u03b1, p a \u2194 q (e a)) :\n    (e.subtypeEquiv h).symm =\n      e.symm.subtypeEquiv fun a => by\n        convert (h <| e.symm a).symm\n        exact (e.apply_symm_apply a).symm", "start": [1165, 1], "end": [1171, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquiv_trans", "code": "@[simp]\ntheorem subtypeEquiv_trans {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2243 \u03b3)\n    (h : \u2200 a : \u03b1, p a \u2194 q (e a)) (h' : \u2200 b : \u03b2, q b \u2194 r (f b)) :\n    (e.subtypeEquiv h).trans (f.subtypeEquiv h')\n    = (e.trans f).subtypeEquiv fun a => (h a).trans (h' <| e a)", "start": [1174, 1], "end": [1179, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquiv_apply", "code": "@[simp]\ntheorem subtypeEquiv_apply {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop}\n    (e : \u03b1 \u2243 \u03b2) (h : \u2200 a : \u03b1, p a \u2194 q (e a)) (x : { x // p x }) :\n    e.subtypeEquiv h x = \u27e8e x, (h _).1 x.2\u27e9", "start": [1182, 1], "end": [1186, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivRight", "code": "@[simps!]\ndef subtypeEquivRight {p q : \u03b1 \u2192 Prop} (e : \u2200 x, p x \u2194 q x) : { x // p x } \u2243 { x // q x } :=\n  subtypeEquiv (Equiv.refl _) e", "start": [1189, 1], "end": [1193, 32], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivRight_apply", "code": "lemma subtypeEquivRight_apply {p q : \u03b1 \u2192 Prop} (e : \u2200 x, p x \u2194 q x)\n    (z : { x // p x }) : subtypeEquivRight e z = \u27e8z, (e z.1).mp z.2\u27e9 := rfl", "start": [1198, 1], "end": [1199, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.subtypeEquivRight_symm_apply", "code": "lemma subtypeEquivRight_symm_apply {p q : \u03b1 \u2192 Prop} (e : \u2200 x, p x \u2194 q x)\n    (z : { x // q x }) : (subtypeEquivRight e).symm z = \u27e8z, (e z.1).mpr z.2\u27e9 := rfl", "start": [1201, 1], "end": [1202, 84], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.subtypeEquivOfSubtype", "code": "def subtypeEquivOfSubtype {p : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) : { a : \u03b1 // p (e a) } \u2243 { b : \u03b2 // p b } :=\n  subtypeEquiv e <| by simp", "start": [1204, 1], "end": [1207, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivOfSubtype'", "code": "def subtypeEquivOfSubtype' {p : \u03b1 \u2192 Prop} (e : \u03b1 \u2243 \u03b2) :\n    { a : \u03b1 // p a } \u2243 { b : \u03b2 // p (e.symm b) } :=\n  e.symm.subtypeEquivOfSubtype.symm", "start": [1210, 1], "end": [1214, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivProp", "code": "def subtypeEquivProp {p q : \u03b1 \u2192 Prop} (h : p = q) : Subtype p \u2243 Subtype q :=\n  subtypeEquiv (Equiv.refl \u03b1) fun _ => h \u25b8 Iff.rfl", "start": [1217, 1], "end": [1219, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeSubtypeEquivSubtypeExists", "code": "@[simps]\ndef subtypeSubtypeEquivSubtypeExists (p : \u03b1 \u2192 Prop) (q : Subtype p \u2192 Prop) :\n    Subtype q \u2243 { a : \u03b1 // \u2203 h : p a, q \u27e8a, h\u27e9 } :=\n  \u27e8fun a =>\n    \u27e8a.1, a.1.2, by\n      rcases a with \u27e8\u27e8a, hap\u27e9, haq\u27e9\n      exact haq\u27e9,\n    fun a => \u27e8\u27e8a, a.2.fst\u27e9, a.2.snd\u27e9, fun \u27e8\u27e8a, ha\u27e9, h\u27e9 => rfl, fun \u27e8a, h\u2081, h\u2082\u27e9 => rfl\u27e9", "start": [1222, 1], "end": [1231, 87], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeSubtypeEquivSubtypeInter", "code": "@[simps!]\ndef subtypeSubtypeEquivSubtypeInter {\u03b1 : Type u} (p q : \u03b1 \u2192 Prop) :\n    { x : Subtype p // q x.1 } \u2243 Subtype fun x => p x \u2227 q x :=\n  (subtypeSubtypeEquivSubtypeExists p _).trans <|\n    subtypeEquivRight fun x => @exists_prop (q x) (p x)", "start": [1236, 1], "end": [1241, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeSubtypeEquivSubtype", "code": "@[simps!]\ndef subtypeSubtypeEquivSubtype {p q : \u03b1 \u2192 Prop} (h : \u2200 {x}, q x \u2192 p x) :\n    { x : Subtype p // q x.1 } \u2243 Subtype q :=\n  (subtypeSubtypeEquivSubtypeInter p _).trans <| subtypeEquivRight fun _ => and_iff_right_of_imp h", "start": [1246, 1], "end": [1251, 99], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeUnivEquiv", "code": "@[simps apply symm_apply]\ndef subtypeUnivEquiv {p : \u03b1 \u2192 Prop} (h : \u2200 x, p x) : Subtype p \u2243 \u03b1 :=\n  \u27e8fun x => x, fun x => \u27e8x, h x\u27e9, fun _ => Subtype.eq rfl, fun _ => rfl\u27e9", "start": [1256, 1], "end": [1260, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeSigmaEquiv", "code": "def subtypeSigmaEquiv (p : \u03b1 \u2192 Type v) (q : \u03b1 \u2192 Prop) : { y : Sigma p // q y.1 } \u2243 \u03a3 x :\n    Subtype q, p x.1 :=\n  \u27e8fun x => \u27e8\u27e8x.1.1, x.2\u27e9, x.1.2\u27e9, fun x => \u27e8\u27e8x.1.1, x.2\u27e9, x.1.2\u27e9, fun _ => rfl,\n    fun _ => rfl\u27e9", "start": [1265, 1], "end": [1269, 18], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaSubtypeEquivOfSubset", "code": "def sigmaSubtypeEquivOfSubset (p : \u03b1 \u2192 Type v) (q : \u03b1 \u2192 Prop) (h : \u2200 x, p x \u2192 q x) :\n    (\u03a3 x : Subtype q, p x) \u2243 \u03a3 x : \u03b1, p x :=\n  (subtypeSigmaEquiv p q).symm.trans <| subtypeUnivEquiv fun x => h x.1 x.2", "start": [1272, 1], "end": [1276, 76], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaSubtypeFiberEquiv", "code": "def sigmaSubtypeFiberEquiv {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (p : \u03b2 \u2192 Prop) (h : \u2200 x, p (f x)) :\n    (\u03a3 y : Subtype p, { x : \u03b1 // f x = y }) \u2243 \u03b1 :=\n  calc\n    _ \u2243 \u03a3y : \u03b2, { x : \u03b1 // f x = y } := sigmaSubtypeEquivOfSubset _ p fun _ \u27e8x, h'\u27e9 => h' \u25b8 h x\n    _ \u2243 \u03b1 := sigmaFiberEquiv f", "start": [1279, 1], "end": [1285, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaSubtypeFiberEquivSubtype", "code": "def sigmaSubtypeFiberEquivSubtype {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop}\n    (h : \u2200 x, p x \u2194 q (f x)) : (\u03a3 y : Subtype q, { x : \u03b1 // f x = y }) \u2243 Subtype p :=\n  calc\n    (\u03a3y : Subtype q, { x : \u03b1 // f x = y }) \u2243 \u03a3y :\n        Subtype q, { x : Subtype p // Subtype.mk (f x) ((h x).1 x.2) = y } := by {\n          apply sigmaCongrRight\n          intro y\n          apply Equiv.symm\n          refine' (subtypeSubtypeEquivSubtypeExists _ _).trans (subtypeEquivRight _)\n          intro x\n          exact \u27e8fun \u27e8hp, h'\u27e9 => congr_arg Subtype.val h', fun h' => \u27e8(h x).2 (h'.symm \u25b8 y.2),\n            Subtype.eq h'\u27e9\u27e9 }\n    _ \u2243 Subtype p := sigmaFiberEquiv fun x : Subtype p => (\u27e8f x, (h x).1 x.property\u27e9 : Subtype q)", "start": [1288, 1], "end": [1302, 98], "kind": "commanddeclaration"}, {"full_name": "Equiv.sigmaOptionEquivOfSome", "code": "def sigmaOptionEquivOfSome (p : Option \u03b1 \u2192 Type v) (h : p none \u2192 False) :\n    (\u03a3 x : Option \u03b1, p x) \u2243 \u03a3 x : \u03b1, p (some x) :=\n  haveI h' : \u2200 x, p x \u2192 x.isSome := by\n    intro x\n    cases x\n    \u00b7 intro n\n      exfalso\n      exact h n\n    \u00b7 intro _\n      exact rfl\n  (sigmaSubtypeEquivOfSubset _ _ h').symm.trans (sigmaCongrLeft' (optionIsSomeEquiv \u03b1))", "start": [1305, 1], "end": [1317, 88], "kind": "commanddeclaration"}, {"full_name": "Equiv.piEquivSubtypeSigma", "code": "def piEquivSubtypeSigma (\u03b9) (\u03c0 : \u03b9 \u2192 Type*) :\n    (\u2200 i, \u03c0 i) \u2243 { f : \u03b9 \u2192 \u03a3 i, \u03c0 i // \u2200 i, (f i).1 = i } where\n  toFun := fun f => \u27e8fun i => \u27e8i, f i\u27e9, fun i => rfl\u27e9\n  invFun := fun f i => by rw [\u2190 f.2 i]; exact (f.1 i).2\n  left_inv := fun f => funext fun i => rfl\n  right_inv := fun \u27e8f, hf\u27e9 =>\n    Subtype.eq <| funext fun i =>\n      Sigma.eq (hf i).symm <| eq_of_heq <| rec_heq_of_heq _ <| by simp", "start": [1320, 1], "end": [1329, 71], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypePiEquivPi", "code": "def subtypePiEquivPi {\u03b2 : \u03b1 \u2192 Sort v} {p : \u2200 a, \u03b2 a \u2192 Prop} :\n    { f : \u2200 a, \u03b2 a // \u2200 a, p a (f a) } \u2243 \u2200 a, { b : \u03b2 a // p a b } where\n  toFun := fun f a => \u27e8f.1 a, f.2 a\u27e9\n  invFun := fun f => \u27e8fun a => (f a).1, fun a => (f a).2\u27e9\n  left_inv := by\n    rintro \u27e8f, h\u27e9\n    rfl\n  right_inv := by\n    rintro f\n    funext a\n    exact Subtype.ext_val rfl", "start": [1332, 1], "end": [1344, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeProdEquivProd", "code": "def subtypeProdEquivProd {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} :\n    { c : \u03b1 \u00d7 \u03b2 // p c.1 \u2227 q c.2 } \u2243 { a // p a } \u00d7 { b // q b } where\n  toFun := fun x => \u27e8\u27e8x.1.1, x.2.1\u27e9, \u27e8x.1.2, x.2.2\u27e9\u27e9\n  invFun := fun x => \u27e8\u27e8x.1.1, x.2.1\u27e9, \u27e8x.1.2, x.2.2\u27e9\u27e9\n  left_inv := fun \u27e8\u27e8_, _\u27e9, \u27e8_, _\u27e9\u27e9 => rfl\n  right_inv := fun \u27e8\u27e8_, _\u27e9, \u27e8_, _\u27e9\u27e9 => rfl", "start": [1347, 1], "end": [1354, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeProdEquivSigmaSubtype", "code": "def subtypeProdEquivSigmaSubtype (p : \u03b1 \u2192 \u03b2 \u2192 Prop) :\n    { x : \u03b1 \u00d7 \u03b2 // p x.1 x.2 } \u2243 \u03a3a, { b : \u03b2 // p a b } where\n  toFun x := \u27e8x.1.1, x.1.2, x.property\u27e9\n  invFun x := \u27e8\u27e8x.1, x.2\u27e9, x.2.property\u27e9\n  left_inv x := by ext <;> rfl\n  right_inv := fun \u27e8a, b, pab\u27e9 => rfl", "start": [1357, 1], "end": [1363, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.piEquivPiSubtypeProd", "code": "@[simps]\ndef piEquivPiSubtypeProd {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) (\u03b2 : \u03b1 \u2192 Type*) [DecidablePred p] :\n    (\u2200 i : \u03b1, \u03b2 i) \u2243 (\u2200 i : { x // p x }, \u03b2 i) \u00d7 \u2200 i : { x // \u00acp x }, \u03b2 i where\n  toFun f := (fun x => f x, fun x => f x)\n  invFun f x := if h : p x then f.1 \u27e8x, h\u27e9 else f.2 \u27e8x, h\u27e9\n  right_inv := by\n    rintro \u27e8f, g\u27e9\n    ext1 <;>\n      \u00b7 ext y\n        rcases y with \u27e8val, property\u27e9\n        simp only [property, dif_pos, dif_neg, not_false_iff, Subtype.coe_mk]\n  left_inv f := by\n    ext x\n    by_cases h:p x <;>\n      \u00b7 simp only [h, dif_neg, dif_pos, not_false_iff]", "start": [1366, 1], "end": [1382, 55], "kind": "commanddeclaration"}, {"full_name": "Equiv.piSplitAt", "code": "@[simps]\ndef piSplitAt {\u03b1 : Type*} [DecidableEq \u03b1] (i : \u03b1) (\u03b2 : \u03b1 \u2192 Type*) :\n    (\u2200 j, \u03b2 j) \u2243 \u03b2 i \u00d7 \u2200 j : { j // j \u2260 i }, \u03b2 j where\n  toFun f := \u27e8f i, fun j => f j\u27e9\n  invFun f j := if h : j = i then h.symm.rec f.1 else f.2 \u27e8j, h\u27e9\n  right_inv f := by\n    ext x\n    exacts [dif_pos rfl, (dif_neg x.2).trans (by cases x; rfl)]\n  left_inv f := by\n    ext x\n    dsimp only\n    split_ifs with h\n    \u00b7 subst h; rfl\n    \u00b7 rfl", "start": [1387, 1], "end": [1402, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.funSplitAt", "code": "@[simps!]\ndef funSplitAt {\u03b1 : Type*} [DecidableEq \u03b1] (i : \u03b1) (\u03b2 : Type*) :\n    (\u03b1 \u2192 \u03b2) \u2243 \u03b2 \u00d7 ({ j // j \u2260 i } \u2192 \u03b2) :=\n  piSplitAt i _", "start": [1407, 1], "end": [1412, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivCodomain", "code": "def subtypeEquivCodomain (f : { x' // x' \u2260 x } \u2192 Y) :\n    { g : X \u2192 Y // g \u2218 (\u2191) = f } \u2243 Y :=\n  (subtypePreimage _ f).trans <|\n    @funUnique { x' // \u00acx' \u2260 x } _ <|\n      show Unique { x' // \u00acx' \u2260 x } from\n        @Equiv.unique _ _\n          (show Unique { x' // x' = x } from {\n            default := \u27e8x, rfl\u27e9, uniq := fun \u27e8_, h\u27e9 => Subtype.val_injective h })\n          (subtypeEquivRight fun _ => not_not)", "start": [1423, 1], "end": [1433, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_subtypeEquivCodomain", "code": "@[simp]\ntheorem coe_subtypeEquivCodomain (f : { x' // x' \u2260 x } \u2192 Y) :\n    (subtypeEquivCodomain f : _ \u2192 Y) =\n      fun g : { g : X \u2192 Y // g \u2218 (\u2191) = f } => (g : X \u2192 Y) x", "start": [1436, 1], "end": [1440, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivCodomain_apply", "code": "@[simp]\ntheorem subtypeEquivCodomain_apply (f : { x' // x' \u2260 x } \u2192 Y) (g) :\n    subtypeEquivCodomain f g = (g : X \u2192 Y) x", "start": [1443, 1], "end": [1446, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_subtypeEquivCodomain_symm", "code": "theorem coe_subtypeEquivCodomain_symm (f : { x' // x' \u2260 x } \u2192 Y) :\n    ((subtypeEquivCodomain f).symm : Y \u2192 _) = fun y =>\n      \u27e8fun x' => if h : x' \u2260 x then f \u27e8x', h\u27e9 else y, by\n        funext x'\n        simp only [ne_eq, dite_not, comp_apply, Subtype.coe_eta, dite_eq_ite, ite_eq_right_iff]\n        intro w\n        exfalso\n        exact x'.property w\u27e9", "start": [1449, 1], "end": [1457, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivCodomain_symm_apply", "code": "@[simp]\ntheorem subtypeEquivCodomain_symm_apply (f : { x' // x' \u2260 x } \u2192 Y) (y : Y) (x' : X) :\n    ((subtypeEquivCodomain f).symm y : X \u2192 Y) x' = if h : x' \u2260 x then f \u27e8x', h\u27e9 else y", "start": [1460, 1], "end": [1463, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivCodomain_symm_apply_eq", "code": "theorem subtypeEquivCodomain_symm_apply_eq (f : { x' // x' \u2260 x } \u2192 Y) (y : Y) :\n    ((subtypeEquivCodomain f).symm y : X \u2192 Y) x = y", "start": [1466, 1], "end": [1468, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeEquivCodomain_symm_apply_ne", "code": "theorem subtypeEquivCodomain_symm_apply_ne\n    (f : { x' // x' \u2260 x } \u2192 Y) (y : Y) (x' : X) (h : x' \u2260 x) :\n    ((subtypeEquivCodomain f).symm y : X \u2192 Y) x' = f \u27e8x', h\u27e9", "start": [1471, 1], "end": [1474, 12], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofBijective", "code": "@[simps apply]\nnoncomputable def ofBijective (f : \u03b1 \u2192 \u03b2) (hf : Bijective f) : \u03b1 \u2243 \u03b2 where\n  toFun := f\n  invFun := Function.surjInv hf.surjective\n  left_inv := Function.leftInverse_surjInv hf\n  right_inv := Function.rightInverse_surjInv _", "start": [1479, 1], "end": [1485, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofBijective_apply_symm_apply", "code": "theorem ofBijective_apply_symm_apply (f : \u03b1 \u2192 \u03b2) (hf : Bijective f) (x : \u03b2) :\n    f ((ofBijective f hf).symm x) = x", "start": [1489, 1], "end": [1491, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.ofBijective_symm_apply_apply", "code": "@[simp]\ntheorem ofBijective_symm_apply_apply (f : \u03b1 \u2192 \u03b2) (hf : Bijective f) (x : \u03b1) :\n    (ofBijective f hf).symm (f x) = x", "start": [1494, 1], "end": [1497, 40], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain", "code": "def Perm.extendDomain : Perm \u03b2' :=\n  (permCongr f e).subtypeCongr (Equiv.refl _)", "start": [1506, 1], "end": [1514, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_apply_image", "code": "@[simp]\ntheorem Perm.extendDomain_apply_image (a : \u03b1') : e.extendDomain f (f a) = f (e a)", "start": [1517, 1], "end": [1519, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_apply_subtype", "code": "theorem Perm.extendDomain_apply_subtype {b : \u03b2'} (h : p b) :\n    e.extendDomain f b = f (e (f.symm \u27e8b, h\u27e9))", "start": [1522, 1], "end": [1524, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_apply_not_subtype", "code": "theorem Perm.extendDomain_apply_not_subtype {b : \u03b2'} (h : \u00acp b) : e.extendDomain f b = b", "start": [1527, 1], "end": [1528, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_refl", "code": "@[simp]\ntheorem Perm.extendDomain_refl : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _", "start": [1531, 1], "end": [1533, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_symm", "code": "@[simp]\ntheorem Perm.extendDomain_symm : (e.extendDomain f).symm = Perm.extendDomain e.symm f", "start": [1536, 1], "end": [1538, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.extendDomain_trans", "code": "theorem Perm.extendDomain_trans (e e' : Perm \u03b1') :\n    (e.extendDomain f).trans (e'.extendDomain f) = Perm.extendDomain (e.trans e') f", "start": [1541, 1], "end": [1543, 44], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeQuotientEquivQuotientSubtype", "code": "def subtypeQuotientEquivQuotientSubtype (p\u2081 : \u03b1 \u2192 Prop) [s\u2081 : Setoid \u03b1] [s\u2082 : Setoid (Subtype p\u2081)]\n    (p\u2082 : Quotient s\u2081 \u2192 Prop) (hp\u2082 : \u2200 a, p\u2081 a \u2194 p\u2082 \u27e6a\u27e7)\n    (h : \u2200 x y : Subtype p\u2081, @Setoid.r _ s\u2082 x y \u2194 (x : \u03b1) \u2248 y) :\n    { x // p\u2082 x } \u2243 Quotient s\u2082 where\n  toFun a :=\n    Quotient.hrecOn a.1 (fun a h => \u27e6\u27e8a, (hp\u2082 _).2 h\u27e9\u27e7)\n      (fun a b hab => hfunext (by rw [Quotient.sound hab]) fun h\u2081 h\u2082 _ =>\n        heq_of_eq (Quotient.sound ((h _ _).2 hab)))\n      a.2\n  invFun a :=\n    Quotient.liftOn a (fun a => (\u27e8\u27e6a.1\u27e7, (hp\u2082 _).1 a.2\u27e9 : { x // p\u2082 x })) fun a b hab =>\n      Subtype.ext_val (Quotient.sound ((h _ _).1 hab))\n  left_inv := by exact fun \u27e8a, ha\u27e9 => Quotient.inductionOn a (fun b hb => rfl) ha\n  right_inv a := Quotient.inductionOn a fun \u27e8a, ha\u27e9 => rfl", "start": [1548, 1], "end": [1565, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeQuotientEquivQuotientSubtype_mk", "code": "@[simp]\ntheorem subtypeQuotientEquivQuotientSubtype_mk (p\u2081 : \u03b1 \u2192 Prop)\n    [s\u2081 : Setoid \u03b1] [s\u2082 : Setoid (Subtype p\u2081)] (p\u2082 : Quotient s\u2081 \u2192 Prop) (hp\u2082 : \u2200 a, p\u2081 a \u2194 p\u2082 \u27e6a\u27e7)\n    (h : \u2200 x y : Subtype p\u2081, @Setoid.r _ s\u2082 x y \u2194 (x : \u03b1) \u2248 y)\n    (x hx) : subtypeQuotientEquivQuotientSubtype p\u2081 p\u2082 hp\u2082 h \u27e8\u27e6x\u27e7, hx\u27e9 = \u27e6\u27e8x, (hp\u2082 _).2 hx\u27e9\u27e7", "start": [1568, 1], "end": [1573, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeQuotientEquivQuotientSubtype_symm_mk", "code": "@[simp]\ntheorem subtypeQuotientEquivQuotientSubtype_symm_mk (p\u2081 : \u03b1 \u2192 Prop)\n    [s\u2081 : Setoid \u03b1] [s\u2082 : Setoid (Subtype p\u2081)] (p\u2082 : Quotient s\u2081 \u2192 Prop) (hp\u2082 : \u2200 a, p\u2081 a \u2194 p\u2082 \u27e6a\u27e7)\n    (h : \u2200 x y : Subtype p\u2081, @Setoid.r _ s\u2082 x y \u2194 (x : \u03b1) \u2248 y) (x) :\n    (subtypeQuotientEquivQuotientSubtype p\u2081 p\u2082 hp\u2082 h).symm \u27e6x\u27e7 = \u27e8\u27e6x\u27e7, (hp\u2082 _).1 x.property\u27e9", "start": [1576, 1], "end": [1581, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.swapCore", "code": "def swapCore (a b r : \u03b1) : \u03b1 :=\n  if r = a then b else if r = b then a else r", "start": [1588, 1], "end": [1590, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.swapCore_self", "code": "theorem swapCore_self (r a : \u03b1) : swapCore a a r = r", "start": [1593, 1], "end": [1595, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.swapCore_swapCore", "code": "theorem swapCore_swapCore (r a b : \u03b1) : swapCore a b (swapCore a b r) = r", "start": [1598, 1], "end": [1610, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.swapCore_comm", "code": "theorem swapCore_comm (r a b : \u03b1) : swapCore a b r = swapCore b a r", "start": [1613, 1], "end": [1617, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap", "code": "def swap (a b : \u03b1) : Perm \u03b1 :=\n  \u27e8swapCore a b, swapCore a b, fun r => swapCore_swapCore r a b,\n    fun r => swapCore_swapCore r a b\u27e9", "start": [1620, 1], "end": [1624, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_self", "code": "@[simp]\ntheorem swap_self (a : \u03b1) : swap a a = Equiv.refl _", "start": [1627, 1], "end": [1629, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_comm", "code": "theorem swap_comm (a b : \u03b1) : swap a b = swap b a", "start": [1632, 1], "end": [1633, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_def", "code": "theorem swap_apply_def (a b x : \u03b1) : swap a b x = if x = a then b else if x = b then a else x", "start": [1636, 1], "end": [1637, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_left", "code": "@[simp]\ntheorem swap_apply_left (a b : \u03b1) : swap a b a = b", "start": [1640, 1], "end": [1642, 13], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_right", "code": "@[simp]\ntheorem swap_apply_right (a b : \u03b1) : swap a b b = a", "start": [1645, 1], "end": [1647, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_of_ne_of_ne", "code": "theorem swap_apply_of_ne_of_ne {a b x : \u03b1} : x \u2260 a \u2192 x \u2260 b \u2192 swap a b x = x", "start": [1650, 1], "end": [1651, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_swap", "code": "@[simp]\ntheorem swap_swap (a b : \u03b1) : (swap a b).trans (swap a b) = Equiv.refl _", "start": [1654, 1], "end": [1656, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_swap", "code": "@[simp]\ntheorem symm_swap (a b : \u03b1) : (swap a b).symm = swap a b", "start": [1659, 1], "end": [1661, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_eq_refl_iff", "code": "@[simp]\ntheorem swap_eq_refl_iff {x y : \u03b1} : swap x y = Equiv.refl _ \u2194 x = y", "start": [1664, 1], "end": [1667, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_comp_apply", "code": "theorem swap_comp_apply {a b x : \u03b1} (\u03c0 : Perm \u03b1) :\n    \u03c0.trans (swap a b) x = if \u03c0 x = a then b else if \u03c0 x = b then a else \u03c0 x", "start": [1670, 1], "end": [1673, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_eq_update", "code": "theorem swap_eq_update (i j : \u03b1) : (Equiv.swap i j : \u03b1 \u2192 \u03b1) = update (update id j i) i j", "start": [1676, 1], "end": [1677, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.comp_swap_eq_update", "code": "theorem comp_swap_eq_update (i j : \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    f \u2218 Equiv.swap i j = update (update f j (f i)) i (f j)", "start": [1680, 1], "end": [1682, 63], "kind": "commanddeclaration"}, {"full_name": "Equiv.symm_trans_swap_trans", "code": "@[simp]\ntheorem symm_trans_swap_trans [DecidableEq \u03b2] (a b : \u03b1) (e : \u03b1 \u2243 \u03b2) :\n    (e.symm.trans (swap a b)).trans e = swap (e a) (e b)", "start": [1685, 1], "end": [1693, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_swap_trans_symm", "code": "@[simp]\ntheorem trans_swap_trans_symm [DecidableEq \u03b2] (a b : \u03b2) (e : \u03b1 \u2243 \u03b2) :\n    (e.trans (swap a b)).trans e.symm = swap (e.symm a) (e.symm b)", "start": [1696, 1], "end": [1699, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_self", "code": "@[simp]\ntheorem swap_apply_self (i j a : \u03b1) : swap i j (swap i j a) = a", "start": [1702, 1], "end": [1704, 62], "kind": "commanddeclaration"}, {"full_name": "Equiv.apply_swap_eq_self", "code": "theorem apply_swap_eq_self {v : \u03b1 \u2192 \u03b2} {i j : \u03b1} (hv : v i = v j) (k : \u03b1) :\n    v (swap i j k) = v k", "start": [1707, 1], "end": [1716, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_eq_iff", "code": "theorem swap_apply_eq_iff {x y z w : \u03b1} : swap x y z = w \u2194 z = swap x y w", "start": [1719, 1], "end": [1720, 45], "kind": "commanddeclaration"}, {"full_name": "Equiv.swap_apply_ne_self_iff", "code": "theorem swap_apply_ne_self_iff {a b x : \u03b1} : swap a b x \u2260 x \u2194 a \u2260 b \u2227 (x = a \u2228 x = b)", "start": [1723, 1], "end": [1733, 47], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_swap_refl", "code": "@[simp]\ntheorem sumCongr_swap_refl {\u03b1 \u03b2 : Sort _} [DecidableEq \u03b1] [DecidableEq \u03b2] (i j : \u03b1) :\n    Equiv.Perm.sumCongr (Equiv.swap i j) (Equiv.refl \u03b2) = Equiv.swap (Sum.inl i) (Sum.inl j)", "start": [1738, 1], "end": [1746, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.sumCongr_refl_swap", "code": "@[simp]\ntheorem sumCongr_refl_swap {\u03b1 \u03b2 : Sort _} [DecidableEq \u03b1] [DecidableEq \u03b2] (i j : \u03b2) :\n    Equiv.Perm.sumCongr (Equiv.refl \u03b1) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j)", "start": [1749, 1], "end": [1758, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.setValue", "code": "def setValue (f : \u03b1 \u2243 \u03b2) (a : \u03b1) (b : \u03b2) : \u03b1 \u2243 \u03b2 :=\n  (swap a (f.symm b)).trans f", "start": [1763, 1], "end": [1765, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.setValue_eq", "code": "@[simp]\ntheorem setValue_eq (f : \u03b1 \u2243 \u03b2) (a : \u03b1) (b : \u03b2) : setValue f a b a = b", "start": [1768, 1], "end": [1770, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.toPerm", "code": "def toPerm (f : \u03b1 \u2192 \u03b1) (h : Involutive f) : Equiv.Perm \u03b1 :=\n  \u27e8f, f, h.leftInverse, h.rightInverse\u27e9", "start": [1779, 1], "end": [1781, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.coe_toPerm", "code": "@[simp]\ntheorem coe_toPerm {f : \u03b1 \u2192 \u03b1} (h : Involutive f) : (h.toPerm f : \u03b1 \u2192 \u03b1) = f", "start": [1784, 1], "end": [1786, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.toPerm_symm", "code": "@[simp]\ntheorem toPerm_symm {f : \u03b1 \u2192 \u03b1} (h : Involutive f) : (h.toPerm f).symm = h.toPerm f", "start": [1789, 1], "end": [1791, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.toPerm_involutive", "code": "theorem toPerm_involutive {f : \u03b1 \u2192 \u03b1} (h : Involutive f) : Involutive (h.toPerm f)", "start": [1794, 1], "end": [1795, 4], "kind": "commanddeclaration"}, {"full_name": "PLift.eq_up_iff_down_eq", "code": "theorem PLift.eq_up_iff_down_eq {x : PLift \u03b1} {y : \u03b1} : x = PLift.up y \u2194 x.down = y", "start": [1800, 1], "end": [1801, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.map_swap", "code": "theorem Function.Injective.map_swap [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (x y z : \u03b1) :\n    f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z)", "start": [1804, 1], "end": [1811, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft'", "code": "@[simps]\ndef piCongrLeft' (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2) : (\u2200 a, P a) \u2243 \u2200 b, P (e.symm b) where\n  toFun f x := f (e.symm x)\n  invFun f x := (e.symm_apply_apply x).ndrec (f (e x))\n  left_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : \u2200 {y} (h : y = x), h.ndrec (f y) = f x) (e.symm_apply_apply x)\n  right_inv f := funext fun x =>\n    (by rintro _ rfl; rfl : \u2200 {y} (h : y = x), (congr_arg e.symm h).ndrec (f y) = f x)\n      (e.apply_symm_apply x)", "start": [1820, 1], "end": [1830, 29], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft'_symm_apply_apply", "code": "lemma piCongrLeft'_symm_apply_apply (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2) (g : \u2200 b, P (e.symm b)) (b : \u03b2) :\n    (piCongrLeft' P e).symm g (e.symm b) = g b := by\n  change Eq.ndrec _ _ = _\n  generalize_proofs hZa\n  revert hZa\n  rw [e.apply_symm_apply b]\n  simp", "start": [1840, 1], "end": [1850, 7], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.piCongrLeft", "code": "def piCongrLeft : (\u2200 a, P (e a)) \u2243 \u2200 b, P b :=\n  (piCongrLeft' P e.symm).symm", "start": [1858, 1], "end": [1862, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_apply", "code": "@[simp]\nlemma piCongrLeft_apply (f : \u2200 a, P (e a)) (b : \u03b2) :\n    (piCongrLeft P e) f b = e.apply_symm_apply b \u25b8 f (e.symm b) :=\n  rfl", "start": [1865, 1], "end": [1871, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.piCongrLeft_symm_apply", "code": "@[simp]\nlemma piCongrLeft_symm_apply (g : \u2200 b, P b) (a : \u03b1) :\n    (piCongrLeft P e).symm g a = g (e a) :=\n  piCongrLeft'_apply P e.symm g a", "start": [1873, 1], "end": [1876, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.piCongrLeft_apply_apply", "code": "lemma piCongrLeft_apply_apply (f : \u2200 a, P (e a)) (a : \u03b1) :\n    (piCongrLeft P e) f (e a) = f a :=\n  piCongrLeft'_symm_apply_apply P e.symm f a", "start": [1878, 1], "end": [1884, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.piCongrLeft_apply_eq_cast", "code": "lemma piCongrLeft_apply_eq_cast {P : \u03b2 \u2192 Sort v} {e : \u03b1 \u2243 \u03b2}\n    (f : (a : \u03b1) \u2192 P (e a)) (b : \u03b2) :\n    piCongrLeft P e f b = cast (congr_arg P (e.apply_symm_apply b)) (f (e.symm b)) :=\n  Eq.rec_eq_cast _ _", "start": [1888, 1], "end": [1891, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.piCongrLeft_sum_inl", "code": "theorem piCongrLeft_sum_inl (\u03c0 : \u03b9'' \u2192 Type*) (e : \u03b9 \u2295 \u03b9' \u2243 \u03b9'') (f : \u2200 i, \u03c0 (e (inl i)))\n    (g : \u2200 i, \u03c0 (e (inr i))) (i : \u03b9) :\n    piCongrLeft \u03c0 e (sumPiEquivProdPi (fun x => \u03c0 (e x)) |>.symm (f, g)) (e (inl i)) = f i", "start": [1893, 1], "end": [1897, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongrLeft_sum_inr", "code": "theorem piCongrLeft_sum_inr (\u03c0 : \u03b9'' \u2192 Type*) (e : \u03b9 \u2295 \u03b9' \u2243 \u03b9'') (f : \u2200 i, \u03c0 (e (inl i)))\n    (g : \u2200 i, \u03c0 (e (inr i))) (j : \u03b9') :\n    piCongrLeft \u03c0 e (sumPiEquivProdPi (fun x => \u03c0 (e x)) |>.symm (f, g)) (e (inr j)) = g j", "start": [1899, 1], "end": [1903, 74], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr", "code": "def piCongr : (\u2200 a, W a) \u2243 \u2200 b, Z b :=\n  (Equiv.piCongrRight h\u2082).trans (Equiv.piCongrLeft _ h\u2081)", "start": [1911, 1], "end": [1916, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_piCongr_symm", "code": "@[simp]\ntheorem coe_piCongr_symm : ((h\u2081.piCongr h\u2082).symm :\n    (\u2200 b, Z b) \u2192 \u2200 a, W a) = fun f a => (h\u2082 a).symm (f (h\u2081 a))", "start": [1919, 1], "end": [1922, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr_symm_apply", "code": "theorem piCongr_symm_apply (f : \u2200 b, Z b) :\n    (h\u2081.piCongr h\u2082).symm f = fun a => (h\u2082 a).symm (f (h\u2081 a))", "start": [1925, 1], "end": [1927, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr_apply_apply", "code": "@[simp]\ntheorem piCongr_apply_apply (f : \u2200 a, W a) (a : \u03b1) : h\u2081.piCongr h\u2082 f (h\u2081 a) = h\u2082 a (f a)", "start": [1930, 1], "end": [1932, 85], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr'", "code": "def piCongr' : (\u2200 a, W a) \u2243 \u2200 b, Z b :=\n  (piCongr h\u2081.symm fun b => (h\u2082 b).symm).symm", "start": [1941, 1], "end": [1946, 46], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_piCongr'", "code": "@[simp]\ntheorem coe_piCongr' :\n    (h\u2081.piCongr' h\u2082 : (\u2200 a, W a) \u2192 \u2200 b, Z b) = fun f b => h\u2082 b <| f <| h\u2081.symm b", "start": [1949, 1], "end": [1952, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr'_apply", "code": "theorem piCongr'_apply (f : \u2200 a, W a) : h\u2081.piCongr' h\u2082 f = fun b => h\u2082 b <| f <| h\u2081.symm b", "start": [1955, 1], "end": [1956, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.piCongr'_symm_apply_symm_apply", "code": "@[simp]\ntheorem piCongr'_symm_apply_symm_apply (f : \u2200 b, Z b) (b : \u03b2) :\n    (h\u2081.piCongr' h\u2082).symm f (h\u2081.symm b) = (h\u2082 b).symm (f b)", "start": [1959, 1], "end": [1962, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.semiconj_conj", "code": "theorem semiconj_conj (f : \u03b1\u2081 \u2192 \u03b1\u2081) : Semiconj e f (e.conj f)", "start": [1971, 1], "end": [1971, 82], "kind": "commanddeclaration"}, {"full_name": "Equiv.semiconj\u2082_conj", "code": "theorem semiconj\u2082_conj : Semiconj\u2082 e f (e.arrowCongr e.conj f)", "start": [1974, 1], "end": [1974, 98], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.swap_apply", "code": "theorem Function.Injective.swap_apply\n    [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (x y z : \u03b1) :\n    Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)", "start": [1993, 1], "end": [2002, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.swap_comp", "code": "theorem Function.Injective.swap_comp\n    [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (x y : \u03b1) :\n    Equiv.swap (f x) (f y) \u2218 f = f \u2218 Equiv.swap x y", "start": [2005, 1], "end": [2008, 38], "kind": "commanddeclaration"}, {"full_name": "subsingletonProdSelfEquiv", "code": "def subsingletonProdSelfEquiv [Subsingleton \u03b1] : \u03b1 \u00d7 \u03b1 \u2243 \u03b1 where\n  toFun p := p.1\n  invFun a := (a, a)\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [2011, 1], "end": [2016, 39], "kind": "commanddeclaration"}, {"full_name": "equivOfSubsingletonOfSubsingleton", "code": "def equivOfSubsingletonOfSubsingleton [Subsingleton \u03b1] [Subsingleton \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    \u03b1 \u2243 \u03b2 where\n  toFun := f\n  invFun := g\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := Subsingleton.elim _ _", "start": [2019, 1], "end": [2026, 39], "kind": "commanddeclaration"}, {"full_name": "Equiv.punitOfNonemptyOfSubsingleton", "code": "noncomputable def Equiv.punitOfNonemptyOfSubsingleton [h : Nonempty \u03b1] [Subsingleton \u03b1] :\n    \u03b1 \u2243 PUnit :=\n  equivOfSubsingletonOfSubsingleton (fun _ => PUnit.unit) fun _ => h.some", "start": [2029, 1], "end": [2032, 74], "kind": "commanddeclaration"}, {"full_name": "uniqueUniqueEquiv", "code": "def uniqueUniqueEquiv : Unique (Unique \u03b1) \u2243 Unique \u03b1 :=\n  equivOfSubsingletonOfSubsingleton (fun h => h.default) fun h =>\n    { default := h, uniq := fun _ => Subsingleton.elim _ _ }", "start": [2035, 1], "end": [2038, 61], "kind": "commanddeclaration"}, {"full_name": "uniqueEquivEquivUnique", "code": "def uniqueEquivEquivUnique (\u03b1 : Sort u) (\u03b2 : Sort v) [Unique \u03b2] : Unique \u03b1 \u2243 (\u03b1 \u2243 \u03b2) :=\n  equivOfSubsingletonOfSubsingleton (fun _ => Equiv.equivOfUnique _ _) Equiv.unique", "start": [2041, 1], "end": [2043, 84], "kind": "commanddeclaration"}, {"full_name": "Function.update_comp_equiv", "code": "theorem update_comp_equiv [DecidableEq \u03b1'] [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (g : \u03b1' \u2243 \u03b1) (a : \u03b1) (v : \u03b2) :\n    update f a v \u2218 g = update (f \u2218 g) (g.symm a) v", "start": [2047, 1], "end": [2050, 71], "kind": "commanddeclaration"}, {"full_name": "Function.update_apply_equiv_apply", "code": "theorem update_apply_equiv_apply [DecidableEq \u03b1'] [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (g : \u03b1' \u2243 \u03b1) (a : \u03b1) (v : \u03b2) (a' : \u03b1') : update f a v (g a') = update (f \u2218 g) (g.symm a) v a'", "start": [2053, 1], "end": [2055, 43], "kind": "commanddeclaration"}, {"full_name": "Function.piCongrLeft'_update", "code": "theorem piCongrLeft'_update [DecidableEq \u03b1] [DecidableEq \u03b2] (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2)\n    (f : \u2200 a, P a) (b : \u03b2) (x : P (e.symm b)) :\n    e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x", "start": [2059, 1], "end": [2072, 35], "kind": "commanddeclaration"}, {"full_name": "Function.piCongrLeft'_symm_update", "code": "theorem piCongrLeft'_symm_update [DecidableEq \u03b1] [DecidableEq \u03b2] (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2)\n    (f : \u2200 b, P (e.symm b)) (b : \u03b2) (x : P (e.symm b)) :\n    (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x", "start": [2075, 1], "end": [2078, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Cast/Defs.lean", "imports": ["Mathlib/Data/Nat/Cast/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.castDef", "code": "protected def Int.castDef {R : Type u} [NatCast R] [Neg R] : \u2124 \u2192 R\n  | (n : \u2115) => n\n  | Int.negSucc n => -(n + 1 : \u2115)", "start": [29, 1], "end": [32, 34], "kind": "commanddeclaration"}, {"full_name": "AddGroupWithOne", "code": "class AddGroupWithOne (R : Type u) extends IntCast R, AddMonoidWithOne R, AddGroup R where\n  \n  intCast := Int.castDef\n  \n  intCast_ofNat : \u2200 n : \u2115, intCast (n : \u2115) = Nat.cast n := by intros; rfl\n  \n  intCast_negSucc : \u2200 n : \u2115, intCast (Int.negSucc n) = - Nat.cast (n + 1) := by intros; rfl", "start": [40, 1], "end": [49, 92], "kind": "commanddeclaration"}, {"full_name": "AddCommGroupWithOne", "code": "class AddCommGroupWithOne (R : Type u)\n  extends AddCommGroup R, AddGroupWithOne R, AddCommMonoidWithOne R", "start": [57, 1], "end": [59, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/AssertExists.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/GroupWithZero/Defs.lean", "imports": ["Mathlib/Logic/Nontrivial/Defs.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulZeroClass", "code": "class MulZeroClass (M\u2080 : Type u) extends Mul M\u2080, Zero M\u2080 where\n  \n  zero_mul : \u2200 a : M\u2080, 0 * a = 0\n  \n  mul_zero : \u2200 a : M\u2080, a * 0 = 0", "start": [32, 1], "end": [38, 33], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancelMulZero", "code": "class IsLeftCancelMulZero (M\u2080 : Type u) [Mul M\u2080] [Zero M\u2080] : Prop where\n  \n  protected mul_left_cancel_of_ne_zero : \u2200 {a b c : M\u2080}, a \u2260 0 \u2192 a * b = a * c \u2192 b = c", "start": [41, 1], "end": [44, 87], "kind": "commanddeclaration"}, {"full_name": "mul_left_cancel\u2080", "code": "theorem mul_left_cancel\u2080 (ha : a \u2260 0) (h : a * b = a * c) : b = c", "start": [51, 1], "end": [52, 54], "kind": "commanddeclaration"}, {"full_name": "mul_right_injective\u2080", "code": "theorem mul_right_injective\u2080 (ha : a \u2260 0) : Function.Injective ((\u00b7 * \u00b7) a)", "start": [55, 1], "end": [56, 33], "kind": "commanddeclaration"}, {"full_name": "IsRightCancelMulZero", "code": "class IsRightCancelMulZero (M\u2080 : Type u) [Mul M\u2080] [Zero M\u2080] : Prop where\n  \n  protected mul_right_cancel_of_ne_zero : \u2200 {a b c : M\u2080}, b \u2260 0 \u2192 a * b = c * b \u2192 a = c", "start": [61, 1], "end": [64, 88], "kind": "commanddeclaration"}, {"full_name": "mul_right_cancel\u2080", "code": "theorem mul_right_cancel\u2080 (hb : b \u2260 0) (h : a * b = c * b) : a = c", "start": [71, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "mul_left_injective\u2080", "code": "theorem mul_left_injective\u2080 (hb : b \u2260 0) : Function.Injective fun a => a * b", "start": [75, 1], "end": [76, 34], "kind": "commanddeclaration"}, {"full_name": "IsCancelMulZero", "code": "class IsCancelMulZero (M\u2080 : Type u) [Mul M\u2080] [Zero M\u2080]\n  extends IsLeftCancelMulZero M\u2080, IsRightCancelMulZero M\u2080 : Prop", "start": [81, 1], "end": [83, 65], "kind": "commanddeclaration"}, {"full_name": "NoZeroDivisors", "code": "class NoZeroDivisors (M\u2080 : Type*) [Mul M\u2080] [Zero M\u2080] : Prop where\n  \n  eq_zero_or_eq_zero_of_mul_eq_zero : \u2200 {a b : M\u2080}, a * b = 0 \u2192 a = 0 \u2228 b = 0", "start": [91, 1], "end": [95, 78], "kind": "commanddeclaration"}, {"full_name": "SemigroupWithZero", "code": "class SemigroupWithZero (S\u2080 : Type u) extends Semigroup S\u2080, MulZeroClass S\u2080", "start": [99, 1], "end": [101, 76], "kind": "commanddeclaration"}, {"full_name": "MulZeroOneClass", "code": "class MulZeroOneClass (M\u2080 : Type u) extends MulOneClass M\u2080, MulZeroClass M\u2080", "start": [104, 1], "end": [105, 76], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero", "code": "class MonoidWithZero (M\u2080 : Type u) extends Monoid M\u2080, MulZeroOneClass M\u2080, SemigroupWithZero M\u2080", "start": [108, 1], "end": [110, 95], "kind": "commanddeclaration"}, {"full_name": "CancelMonoidWithZero", "code": "class CancelMonoidWithZero (M\u2080 : Type*) extends MonoidWithZero M\u2080, IsCancelMulZero M\u2080", "start": [113, 1], "end": [115, 86], "kind": "commanddeclaration"}, {"full_name": "CommMonoidWithZero", "code": "class CommMonoidWithZero (M\u2080 : Type*) extends CommMonoid M\u2080, MonoidWithZero M\u2080", "start": [118, 1], "end": [120, 79], "kind": "commanddeclaration"}, {"full_name": "mul_left_inj'", "code": "theorem mul_left_inj' (hc : c \u2260 0) : a * c = b * c \u2194 a = b", "start": [127, 1], "end": [128, 34], "kind": "commanddeclaration"}, {"full_name": "mul_right_inj'", "code": "theorem mul_right_inj' (ha : a \u2260 0) : a * b = a * c \u2194 b = c", "start": [131, 1], "end": [132, 35], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancelMulZero.to_isRightCancelMulZero", "code": "lemma IsLeftCancelMulZero.to_isRightCancelMulZero [IsLeftCancelMulZero M\u2080] :\n    IsRightCancelMulZero M\u2080 :=\n{ mul_right_cancel_of_ne_zero :=\n    fun hb h => mul_left_cancel\u2080 hb <| (mul_comm _ _).trans (h.trans (mul_comm _ _)) }", "start": [141, 1], "end": [144, 87], "kind": "mathlibtacticlemma"}, {"full_name": "IsRightCancelMulZero.to_isLeftCancelMulZero", "code": "lemma IsRightCancelMulZero.to_isLeftCancelMulZero [IsRightCancelMulZero M\u2080] :\n    IsLeftCancelMulZero M\u2080 :=\n{ mul_left_cancel_of_ne_zero :=\n    fun hb h => mul_right_cancel\u2080 hb <| (mul_comm _ _).trans (h.trans (mul_comm _ _)) }", "start": [147, 1], "end": [150, 88], "kind": "mathlibtacticlemma"}, {"full_name": "IsLeftCancelMulZero.to_isCancelMulZero", "code": "lemma IsLeftCancelMulZero.to_isCancelMulZero [IsLeftCancelMulZero M\u2080] :\n    IsCancelMulZero M\u2080 :=\n{ IsLeftCancelMulZero.to_isRightCancelMulZero with }", "start": [153, 1], "end": [155, 53], "kind": "mathlibtacticlemma"}, {"full_name": "IsRightCancelMulZero.to_isCancelMulZero", "code": "lemma IsRightCancelMulZero.to_isCancelMulZero [IsRightCancelMulZero M\u2080] :\n    IsCancelMulZero M\u2080 :=\n{ IsRightCancelMulZero.to_isLeftCancelMulZero with }", "start": [158, 1], "end": [160, 53], "kind": "mathlibtacticlemma"}, {"full_name": "CancelCommMonoidWithZero", "code": "class CancelCommMonoidWithZero (M\u2080 : Type*) extends CommMonoidWithZero M\u2080, IsLeftCancelMulZero M\u2080", "start": [165, 1], "end": [168, 98], "kind": "commanddeclaration"}, {"full_name": "CancelCommMonoidWithZero.toCancelMonoidWithZero", "code": "instance (priority := 100) CancelCommMonoidWithZero.toCancelMonoidWithZero\n    [CancelCommMonoidWithZero M\u2080] : CancelMonoidWithZero M\u2080 :=\n{ IsLeftCancelMulZero.to_isCancelMulZero (M\u2080 := M\u2080) with }", "start": [174, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero", "code": "class GroupWithZero (G\u2080 : Type u) extends MonoidWithZero G\u2080, DivInvMonoid G\u2080, Nontrivial G\u2080 where\n  \n  inv_zero : (0 : G\u2080)\u207b\u00b9 = 0\n  \n  mul_inv_cancel (a : G\u2080) : a \u2260 0 \u2192 a * a\u207b\u00b9 = 1", "start": [178, 1], "end": [188, 48], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel", "code": "@[simp] lemma mul_inv_cancel [GroupWithZero G\u2080] {a : G\u2080} (h : a \u2260 0) : a * a\u207b\u00b9 = 1 :=\n  GroupWithZero.mul_inv_cancel a h", "start": [194, 1], "end": [195, 35], "kind": "mathlibtacticlemma"}, {"full_name": "CommGroupWithZero", "code": "class CommGroupWithZero (G\u2080 : Type*) extends CommMonoidWithZero G\u2080, GroupWithZero G\u2080", "start": [198, 1], "end": [202, 85], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_right\u2080", "code": "@[simp]\ntheorem mul_inv_cancel_right\u2080 (h : b \u2260 0) (a : G\u2080) : a * b * b\u207b\u00b9 = a", "start": [209, 1], "end": [213, 25], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_left\u2080", "code": "@[simp]\ntheorem mul_inv_cancel_left\u2080 (h : a \u2260 0) (b : G\u2080) : a * (a\u207b\u00b9 * b) = b", "start": [216, 1], "end": [220, 25], "kind": "commanddeclaration"}, {"full_name": "mul_eq_zero_of_left", "code": "theorem mul_eq_zero_of_left {a : M\u2080} (h : a = 0) (b : M\u2080) : a * b = 0", "start": [229, 1], "end": [229, 93], "kind": "commanddeclaration"}, {"full_name": "mul_eq_zero_of_right", "code": "theorem mul_eq_zero_of_right (a : M\u2080) {b : M\u2080} (h : b = 0) : a * b = 0", "start": [232, 1], "end": [232, 94], "kind": "commanddeclaration"}, {"full_name": "mul_eq_zero", "code": "@[simp]\ntheorem mul_eq_zero : a * b = 0 \u2194 a = 0 \u2228 b = 0", "start": [237, 1], "end": [242, 81], "kind": "commanddeclaration"}, {"full_name": "zero_eq_mul", "code": "@[simp]\ntheorem zero_eq_mul : 0 = a * b \u2194 a = 0 \u2228 b = 0", "start": [245, 1], "end": [248, 80], "kind": "commanddeclaration"}, {"full_name": "mul_ne_zero_iff", "code": "theorem mul_ne_zero_iff : a * b \u2260 0 \u2194 a \u2260 0 \u2227 b \u2260 0", "start": [251, 1], "end": [253, 84], "kind": "commanddeclaration"}, {"full_name": "mul_eq_zero_comm", "code": "theorem mul_eq_zero_comm : a * b = 0 \u2194 b * a = 0", "start": [256, 1], "end": [259, 54], "kind": "commanddeclaration"}, {"full_name": "mul_ne_zero_comm", "code": "theorem mul_ne_zero_comm : a * b \u2260 0 \u2194 b * a \u2260 0", "start": [262, 1], "end": [264, 73], "kind": "commanddeclaration"}, {"full_name": "mul_self_eq_zero", "code": "theorem mul_self_eq_zero : a * a = 0 \u2194 a = 0", "start": [267, 1], "end": [267, 56], "kind": "commanddeclaration"}, {"full_name": "zero_eq_mul_self", "code": "theorem zero_eq_mul_self : 0 = a * a \u2194 a = 0", "start": [270, 1], "end": [270, 56], "kind": "commanddeclaration"}, {"full_name": "mul_self_ne_zero", "code": "theorem mul_self_ne_zero : a * a \u2260 0 \u2194 a \u2260 0", "start": [273, 1], "end": [273, 69], "kind": "commanddeclaration"}, {"full_name": "zero_ne_mul_self", "code": "theorem zero_ne_mul_self : 0 \u2260 a * a \u2194 a \u2260 0", "start": [276, 1], "end": [276, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Nontrivial/Basic.lean", "imports": ["Mathlib/Logic/Unique.lean", "Mathlib/Init/Order/Defs.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Logic/Function/Basic.lean", "Mathlib/Data/Prod/Basic.lean", "Mathlib/Logic/Nontrivial/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Attr/Register.lean"], "premises": [{"full_name": "nontrivial_of_lt", "code": "theorem nontrivial_of_lt [Preorder \u03b1] (x y : \u03b1) (h : x < y) : Nontrivial \u03b1", "start": [28, 1], "end": [29, 23], "kind": "commanddeclaration"}, {"full_name": "exists_pair_lt", "code": "theorem exists_pair_lt (\u03b1 : Type*) [Nontrivial \u03b1] [LinearOrder \u03b1] : \u2203 x y : \u03b1, x < y", "start": [32, 1], "end": [34, 49], "kind": "commanddeclaration"}, {"full_name": "nontrivial_iff_lt", "code": "theorem nontrivial_iff_lt [LinearOrder \u03b1] : Nontrivial \u03b1 \u2194 \u2203 x y : \u03b1, x < y", "start": [37, 1], "end": [38, 74], "kind": "commanddeclaration"}, {"full_name": "Subtype.nontrivial_iff_exists_ne", "code": "theorem Subtype.nontrivial_iff_exists_ne (p : \u03b1 \u2192 Prop) (x : Subtype p) :\n    Nontrivial (Subtype p) \u2194 \u2203 (y : \u03b1) (_ : p y), y \u2260 x", "start": [41, 1], "end": [43, 89], "kind": "commanddeclaration"}, {"full_name": "nontrivialPSumUnique", "code": "noncomputable def nontrivialPSumUnique (\u03b1 : Type*) [Inhabited \u03b1] :\n    PSum (Nontrivial \u03b1) (Unique \u03b1) :=\n  if h : Nontrivial \u03b1 then PSum.inl h\n  else\n    PSum.inr\n      { default := default,\n        uniq := fun x : \u03b1 \u21a6 by\n          by_contra H\n          exact h \u27e8_, _, H\u27e9 }", "start": [46, 1], "end": [55, 30], "kind": "commanddeclaration"}, {"full_name": "Option.nontrivial", "code": "instance Option.nontrivial [Nonempty \u03b1] : Nontrivial (Option \u03b1) := by\n  inhabit \u03b1\n  exact \u27e8none, some default, fun .\u27e9", "start": [58, 1], "end": [60, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nontrivial", "code": "protected theorem Function.Injective.nontrivial [Nontrivial \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) : Nontrivial \u03b2", "start": [62, 1], "end": [66, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.exists_ne", "code": "protected theorem Function.Injective.exists_ne [Nontrivial \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (y : \u03b2) : \u2203 x, f x \u2260 y", "start": [69, 1], "end": [76, 18], "kind": "commanddeclaration"}, {"full_name": "nontrivial_prod_right", "code": "instance nontrivial_prod_right [Nonempty \u03b1] [Nontrivial \u03b2] : Nontrivial (\u03b1 \u00d7 \u03b2) :=\n  Prod.snd_surjective.nontrivial", "start": [79, 1], "end": [80, 33], "kind": "commanddeclaration"}, {"full_name": "nontrivial_prod_left", "code": "instance nontrivial_prod_left [Nontrivial \u03b1] [Nonempty \u03b2] : Nontrivial (\u03b1 \u00d7 \u03b2) :=\n  Prod.fst_surjective.nontrivial", "start": [82, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "Pi.nontrivial_at", "code": "theorem nontrivial_at (i' : I) [inst : \u2200 i, Nonempty (f i)] [Nontrivial (f i')] :\n    Nontrivial (\u2200 i : I, f i)", "start": [89, 1], "end": [93, 86], "kind": "commanddeclaration"}, {"full_name": "Pi.nontrivial", "code": "instance nontrivial [Inhabited I] [\u2200 i, Nonempty (f i)] [Nontrivial (f default)] :\n    Nontrivial (\u2200 i : I, f i) :=\n  nontrivial_at default", "start": [96, 1], "end": [102, 24], "kind": "commanddeclaration"}, {"full_name": "Function.nontrivial", "code": "instance Function.nontrivial [h : Nonempty \u03b1] [Nontrivial \u03b2] : Nontrivial (\u03b1 \u2192 \u03b2) :=\n  h.elim fun a \u21a6 Pi.nontrivial_at a", "start": [106, 1], "end": [107, 36], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.le", "code": "@[nontriviality]\nprotected theorem Subsingleton.le [Preorder \u03b1] [Subsingleton \u03b1] (x y : \u03b1) : x \u2264 y", "start": [109, 1], "end": [111, 35], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.eq_one", "code": "@[to_additive]\ntheorem Subsingleton.eq_one [One \u03b1] [Subsingleton \u03b1] (a : \u03b1) : a = 1", "start": [114, 1], "end": [116, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/BoundedOrder.lean", "imports": ["Mathlib/Tactic/PushNeg.lean", "Mathlib/Order/Lattice.lean", "Mathlib/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/ULift.lean"], "premises": [{"full_name": "Top", "code": "@[notation_class, ext]\nclass Top (\u03b1 : Type u) where\n  \n  top : \u03b1", "start": [44, 1], "end": [48, 10], "kind": "commanddeclaration"}, {"full_name": "Bot", "code": "@[notation_class, ext]\nclass Bot (\u03b1 : Type u) where\n  \n  bot : \u03b1", "start": [51, 1], "end": [55, 10], "kind": "commanddeclaration"}, {"full_name": "top_nonempty", "code": "instance (priority := 100) top_nonempty (\u03b1 : Type u) [Top \u03b1] : Nonempty \u03b1 :=\n  \u27e8\u22a4\u27e9", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "bot_nonempty", "code": "instance (priority := 100) bot_nonempty (\u03b1 : Type u) [Bot \u03b1] : Nonempty \u03b1 :=\n  \u27e8\u22a5\u27e9", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "OrderTop", "code": "class OrderTop (\u03b1 : Type u) [LE \u03b1] extends Top \u03b1 where\n  \n  le_top : \u2200 a : \u03b1, a \u2264 \u22a4", "start": [74, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "topOrderOrNoTopOrder", "code": "noncomputable def topOrderOrNoTopOrder (\u03b1 : Type*) [LE \u03b1] : PSum (OrderTop \u03b1) (NoTopOrder \u03b1) := by\n  by_cases H : \u2200 a : \u03b1, \u2203 b, \u00acb \u2264 a\n  \u00b7 exact PSum.inr \u27e8H\u27e9\n  \u00b7 push_neg at H\n    letI : Top \u03b1 := \u27e8Classical.choose H\u27e9\n    exact PSum.inl \u27e8Classical.choose_spec H\u27e9", "start": [83, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "le_top", "code": "@[simp]\ntheorem le_top : a \u2264 \u22a4", "start": [97, 1], "end": [99, 20], "kind": "commanddeclaration"}, {"full_name": "isTop_top", "code": "@[simp]\ntheorem isTop_top : IsTop (\u22a4 : \u03b1)", "start": [102, 1], "end": [103, 53], "kind": "commanddeclaration"}, {"full_name": "isMax_top", "code": "@[simp]\ntheorem isMax_top : IsMax (\u22a4 : \u03b1)", "start": [112, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "not_top_lt", "code": "@[simp]\ntheorem not_top_lt : \u00ac\u22a4 < a", "start": [117, 1], "end": [119, 19], "kind": "commanddeclaration"}, {"full_name": "ne_top_of_lt", "code": "theorem ne_top_of_lt (h : a < b) : a \u2260 \u22a4", "start": [122, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "LT.lt.ne_top", "code": "alias LT.lt.ne_top := ne_top_of_lt", "start": [126, 1], "end": [126, 35], "kind": "stdtacticaliasalias"}, {"full_name": "isMax_iff_eq_top", "code": "@[simp]\ntheorem isMax_iff_eq_top : IsMax a \u2194 a = \u22a4", "start": [132, 1], "end": [134, 61], "kind": "commanddeclaration"}, {"full_name": "isTop_iff_eq_top", "code": "@[simp]\ntheorem isTop_iff_eq_top : IsTop a \u2194 a = \u22a4", "start": [137, 1], "end": [139, 65], "kind": "commanddeclaration"}, {"full_name": "not_isMax_iff_ne_top", "code": "theorem not_isMax_iff_ne_top : \u00acIsMax a \u2194 a \u2260 \u22a4", "start": [142, 1], "end": [143, 23], "kind": "commanddeclaration"}, {"full_name": "not_isTop_iff_ne_top", "code": "theorem not_isTop_iff_ne_top : \u00acIsTop a \u2194 a \u2260 \u22a4", "start": [146, 1], "end": [147, 23], "kind": "commanddeclaration"}, {"full_name": "IsMax.eq_top", "code": "alias \u27e8IsMax.eq_top, _\u27e9 := isMax_iff_eq_top", "start": [150, 1], "end": [150, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsTop.eq_top", "code": "alias \u27e8IsTop.eq_top, _\u27e9 := isTop_iff_eq_top", "start": [153, 1], "end": [153, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "top_le_iff", "code": "@[simp]\ntheorem top_le_iff : \u22a4 \u2264 a \u2194 a = \u22a4", "start": [156, 1], "end": [158, 33], "kind": "commanddeclaration"}, {"full_name": "top_unique", "code": "theorem top_unique (h : \u22a4 \u2264 a) : a = \u22a4", "start": [161, 1], "end": [162, 20], "kind": "commanddeclaration"}, {"full_name": "eq_top_iff", "code": "theorem eq_top_iff : a = \u22a4 \u2194 \u22a4 \u2264 a", "start": [165, 1], "end": [166, 18], "kind": "commanddeclaration"}, {"full_name": "eq_top_mono", "code": "theorem eq_top_mono (h : a \u2264 b) (h\u2082 : a = \u22a4) : b = \u22a4", "start": [169, 1], "end": [170, 23], "kind": "commanddeclaration"}, {"full_name": "lt_top_iff_ne_top", "code": "theorem lt_top_iff_ne_top : a < \u22a4 \u2194 a \u2260 \u22a4", "start": [173, 1], "end": [174, 19], "kind": "commanddeclaration"}, {"full_name": "not_lt_top_iff", "code": "@[simp]\ntheorem not_lt_top_iff : \u00aca < \u22a4 \u2194 a = \u22a4", "start": [177, 1], "end": [179, 29], "kind": "commanddeclaration"}, {"full_name": "eq_top_or_lt_top", "code": "theorem eq_top_or_lt_top (a : \u03b1) : a = \u22a4 \u2228 a < \u22a4", "start": [182, 1], "end": [183, 18], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_top", "code": "theorem Ne.lt_top (h : a \u2260 \u22a4) : a < \u22a4", "start": [186, 1], "end": [187, 26], "kind": "commanddeclaration"}, {"full_name": "Ne.lt_top'", "code": "theorem Ne.lt_top' (h : \u22a4 \u2260 a) : a < \u22a4", "start": [190, 1], "end": [191, 16], "kind": "commanddeclaration"}, {"full_name": "ne_top_of_le_ne_top", "code": "theorem ne_top_of_le_ne_top (hb : b \u2260 \u22a4) (hab : a \u2264 b) : a \u2260 \u22a4", "start": [194, 1], "end": [195, 30], "kind": "commanddeclaration"}, {"full_name": "StrictMono.apply_eq_top_iff", "code": "theorem StrictMono.apply_eq_top_iff (hf : StrictMono f) : f a = f \u22a4 \u2194 a = \u22a4", "start": [198, 1], "end": [199, 66], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.apply_eq_top_iff", "code": "theorem StrictAnti.apply_eq_top_iff (hf : StrictAnti f) : f a = f \u22a4 \u2194 a = \u22a4", "start": [202, 1], "end": [203, 67], "kind": "commanddeclaration"}, {"full_name": "not_isMin_top", "code": "theorem not_isMin_top : \u00acIsMin (\u22a4 : \u03b1)", "start": [208, 1], "end": [210, 33], "kind": "commanddeclaration"}, {"full_name": "StrictMono.maximal_preimage_top", "code": "theorem StrictMono.maximal_preimage_top [LinearOrder \u03b1] [Preorder \u03b2] [OrderTop \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (H : StrictMono f) {a} (h_top : f a = \u22a4) (x : \u03b1) : x \u2264 a", "start": [215, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "OrderTop.ext_top", "code": "theorem OrderTop.ext_top {\u03b1} {hA : PartialOrder \u03b1} (A : OrderTop \u03b1) {hB : PartialOrder \u03b1}\n    (B : OrderTop \u03b1) (H : \u2200 x y : \u03b1, (haveI := hA; x \u2264 y) \u2194 x \u2264 y) :\n    (@Top.top \u03b1 (@OrderTop.toTop \u03b1 hA.toLE A)) = (@Top.top \u03b1 (@OrderTop.toTop \u03b1 hB.toLE B))", "start": [224, 1], "end": [229, 24], "kind": "commanddeclaration"}, {"full_name": "OrderBot", "code": "class OrderBot (\u03b1 : Type u) [LE \u03b1] extends Bot \u03b1 where\n  \n  bot_le : \u2200 a : \u03b1, \u22a5 \u2264 a", "start": [232, 1], "end": [236, 26], "kind": "commanddeclaration"}, {"full_name": "botOrderOrNoBotOrder", "code": "noncomputable def botOrderOrNoBotOrder (\u03b1 : Type*) [LE \u03b1] : PSum (OrderBot \u03b1) (NoBotOrder \u03b1) := by\n  by_cases H : \u2200 a : \u03b1, \u2203 b, \u00aca \u2264 b\n  \u00b7 exact PSum.inr \u27e8H\u27e9\n  \u00b7 push_neg at H\n    letI : Bot \u03b1 := \u27e8Classical.choose H\u27e9\n    exact PSum.inl \u27e8Classical.choose_spec H\u27e9", "start": [241, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "bot_le", "code": "@[simp]\ntheorem bot_le : \u22a5 \u2264 a", "start": [255, 1], "end": [257, 20], "kind": "commanddeclaration"}, {"full_name": "isBot_bot", "code": "@[simp]\ntheorem isBot_bot : IsBot (\u22a5 : \u03b1)", "start": [260, 1], "end": [261, 53], "kind": "commanddeclaration"}, {"full_name": "OrderDual.top", "code": "instance top [Bot \u03b1] : Top \u03b1\u1d52\u1d48 :=\n  \u27e8(\u22a5 : \u03b1)\u27e9", "start": [270, 1], "end": [271, 12], "kind": "commanddeclaration"}, {"full_name": "OrderDual.bot", "code": "instance bot [Top \u03b1] : Bot \u03b1\u1d52\u1d48 :=\n  \u27e8(\u22a4 : \u03b1)\u27e9", "start": [273, 1], "end": [274, 12], "kind": "commanddeclaration"}, {"full_name": "OrderDual.orderTop", "code": "instance orderTop [LE \u03b1] [OrderBot \u03b1] : OrderTop \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (Top \u03b1\u1d52\u1d48)\n  le_top := @bot_le \u03b1 _ _", "start": [276, 1], "end": [278, 26], "kind": "commanddeclaration"}, {"full_name": "OrderDual.orderBot", "code": "instance orderBot [LE \u03b1] [OrderTop \u03b1] : OrderBot \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (Bot \u03b1\u1d52\u1d48)\n  bot_le := @le_top \u03b1 _ _", "start": [280, 1], "end": [282, 26], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_bot", "code": "@[simp]\ntheorem ofDual_bot [Top \u03b1] : ofDual \u22a5 = (\u22a4 : \u03b1)", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.ofDual_top", "code": "@[simp]\ntheorem ofDual_top [Bot \u03b1] : ofDual \u22a4 = (\u22a5 : \u03b1)", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_bot", "code": "@[simp]\ntheorem toDual_bot [Bot \u03b1] : toDual (\u22a5 : \u03b1) = \u22a4", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "OrderDual.toDual_top", "code": "@[simp]\ntheorem toDual_top [Top \u03b1] : toDual (\u22a4 : \u03b1) = \u22a5", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "isMin_bot", "code": "@[simp]\ntheorem isMin_bot : IsMin (\u22a5 : \u03b1)", "start": [310, 1], "end": [312, 18], "kind": "commanddeclaration"}, {"full_name": "not_lt_bot", "code": "@[simp]\ntheorem not_lt_bot : \u00aca < \u22a5", "start": [315, 1], "end": [317, 19], "kind": "commanddeclaration"}, {"full_name": "ne_bot_of_gt", "code": "theorem ne_bot_of_gt (h : a < b) : b \u2260 \u22a5", "start": [320, 1], "end": [321, 26], "kind": "commanddeclaration"}, {"full_name": "LT.lt.ne_bot", "code": "alias LT.lt.ne_bot := ne_bot_of_gt", "start": [324, 1], "end": [324, 35], "kind": "stdtacticaliasalias"}, {"full_name": "isMin_iff_eq_bot", "code": "@[simp]\ntheorem isMin_iff_eq_bot : IsMin a \u2194 a = \u22a5", "start": [330, 1], "end": [332, 61], "kind": "commanddeclaration"}, {"full_name": "isBot_iff_eq_bot", "code": "@[simp]\ntheorem isBot_iff_eq_bot : IsBot a \u2194 a = \u22a5", "start": [335, 1], "end": [337, 65], "kind": "commanddeclaration"}, {"full_name": "not_isMin_iff_ne_bot", "code": "theorem not_isMin_iff_ne_bot : \u00acIsMin a \u2194 a \u2260 \u22a5", "start": [340, 1], "end": [341, 23], "kind": "commanddeclaration"}, {"full_name": "not_isBot_iff_ne_bot", "code": "theorem not_isBot_iff_ne_bot : \u00acIsBot a \u2194 a \u2260 \u22a5", "start": [344, 1], "end": [345, 23], "kind": "commanddeclaration"}, {"full_name": "IsMin.eq_bot", "code": "alias \u27e8IsMin.eq_bot, _\u27e9 := isMin_iff_eq_bot", "start": [348, 1], "end": [348, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsBot.eq_bot", "code": "alias \u27e8IsBot.eq_bot, _\u27e9 := isBot_iff_eq_bot", "start": [351, 1], "end": [351, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_bot_iff", "code": "@[simp]\ntheorem le_bot_iff : a \u2264 \u22a5 \u2194 a = \u22a5", "start": [354, 1], "end": [356, 19], "kind": "commanddeclaration"}, {"full_name": "bot_unique", "code": "theorem bot_unique (h : a \u2264 \u22a5) : a = \u22a5", "start": [359, 1], "end": [360, 20], "kind": "commanddeclaration"}, {"full_name": "eq_bot_iff", "code": "theorem eq_bot_iff : a = \u22a5 \u2194 a \u2264 \u22a5", "start": [363, 1], "end": [364, 18], "kind": "commanddeclaration"}, {"full_name": "eq_bot_mono", "code": "theorem eq_bot_mono (h : a \u2264 b) (h\u2082 : b = \u22a5) : a = \u22a5", "start": [367, 1], "end": [368, 23], "kind": "commanddeclaration"}, {"full_name": "bot_lt_iff_ne_bot", "code": "theorem bot_lt_iff_ne_bot : \u22a5 < a \u2194 a \u2260 \u22a5", "start": [371, 1], "end": [372, 33], "kind": "commanddeclaration"}, {"full_name": "not_bot_lt_iff", "code": "@[simp]\ntheorem not_bot_lt_iff : \u00ac\u22a5 < a \u2194 a = \u22a5", "start": [375, 1], "end": [377, 29], "kind": "commanddeclaration"}, {"full_name": "eq_bot_or_bot_lt", "code": "theorem eq_bot_or_bot_lt (a : \u03b1) : a = \u22a5 \u2228 \u22a5 < a", "start": [380, 1], "end": [381, 18], "kind": "commanddeclaration"}, {"full_name": "eq_bot_of_minimal", "code": "theorem eq_bot_of_minimal (h : \u2200 b, \u00acb < a) : a = \u22a5", "start": [384, 1], "end": [385, 43], "kind": "commanddeclaration"}, {"full_name": "Ne.bot_lt", "code": "theorem Ne.bot_lt (h : a \u2260 \u22a5) : \u22a5 < a", "start": [388, 1], "end": [389, 26], "kind": "commanddeclaration"}, {"full_name": "Ne.bot_lt'", "code": "theorem Ne.bot_lt' (h : \u22a5 \u2260 a) : \u22a5 < a", "start": [392, 1], "end": [393, 16], "kind": "commanddeclaration"}, {"full_name": "ne_bot_of_le_ne_bot", "code": "theorem ne_bot_of_le_ne_bot (hb : b \u2260 \u22a5) (hab : b \u2264 a) : a \u2260 \u22a5", "start": [396, 1], "end": [397, 31], "kind": "commanddeclaration"}, {"full_name": "StrictMono.apply_eq_bot_iff", "code": "theorem StrictMono.apply_eq_bot_iff (hf : StrictMono f) : f a = f \u22a5 \u2194 a = \u22a5", "start": [400, 1], "end": [401, 27], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.apply_eq_bot_iff", "code": "theorem StrictAnti.apply_eq_bot_iff (hf : StrictAnti f) : f a = f \u22a5 \u2194 a = \u22a5", "start": [404, 1], "end": [405, 27], "kind": "commanddeclaration"}, {"full_name": "not_isMax_bot", "code": "theorem not_isMax_bot : \u00acIsMax (\u22a5 : \u03b1)", "start": [410, 1], "end": [411, 27], "kind": "commanddeclaration"}, {"full_name": "StrictMono.minimal_preimage_bot", "code": "theorem StrictMono.minimal_preimage_bot [LinearOrder \u03b1] [PartialOrder \u03b2] [OrderBot \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (H : StrictMono f) {a} (h_bot : f a = \u22a5) (x : \u03b1) : a \u2264 x", "start": [416, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "OrderBot.ext_bot", "code": "theorem OrderBot.ext_bot {\u03b1} {hA : PartialOrder \u03b1} (A : OrderBot \u03b1) {hB : PartialOrder \u03b1}\n    (B : OrderBot \u03b1) (H : \u2200 x y : \u03b1, (haveI := hA; x \u2264 y) \u2194 x \u2264 y) :\n    (@Bot.bot \u03b1 (@OrderBot.toBot \u03b1 hA.toLE A)) = (@Bot.bot \u03b1 (@OrderBot.toBot \u03b1 hB.toLE B))", "start": [425, 1], "end": [430, 24], "kind": "commanddeclaration"}, {"full_name": "top_sup_eq", "code": "theorem top_sup_eq : \u22a4 \u2294 a = \u22a4", "start": [438, 1], "end": [439, 24], "kind": "commanddeclaration"}, {"full_name": "sup_top_eq", "code": "theorem sup_top_eq : a \u2294 \u22a4 = \u22a4", "start": [443, 1], "end": [444, 25], "kind": "commanddeclaration"}, {"full_name": "bot_sup_eq", "code": "theorem bot_sup_eq : \u22a5 \u2294 a = a", "start": [454, 1], "end": [455, 25], "kind": "commanddeclaration"}, {"full_name": "sup_bot_eq", "code": "theorem sup_bot_eq : a \u2294 \u22a5 = a", "start": [459, 1], "end": [460, 24], "kind": "commanddeclaration"}, {"full_name": "sup_eq_bot_iff", "code": "@[simp]\ntheorem sup_eq_bot_iff : a \u2294 b = \u22a5 \u2194 a = \u22a5 \u2227 b = \u22a5", "start": [463, 1], "end": [464, 91], "kind": "commanddeclaration"}, {"full_name": "top_inf_eq", "code": "theorem top_inf_eq : \u22a4 \u2293 a = a", "start": [474, 1], "end": [475, 25], "kind": "commanddeclaration"}, {"full_name": "inf_top_eq", "code": "theorem inf_top_eq : a \u2293 \u22a4 = a", "start": [479, 1], "end": [480, 24], "kind": "commanddeclaration"}, {"full_name": "inf_eq_top_iff", "code": "@[simp]\ntheorem inf_eq_top_iff : a \u2293 b = \u22a4 \u2194 a = \u22a4 \u2227 b = \u22a4", "start": [483, 1], "end": [485, 30], "kind": "commanddeclaration"}, {"full_name": "bot_inf_eq", "code": "theorem bot_inf_eq : \u22a5 \u2293 a = \u22a5", "start": [495, 1], "end": [496, 24], "kind": "commanddeclaration"}, {"full_name": "inf_bot_eq", "code": "theorem inf_bot_eq : a \u2293 \u22a5 = \u22a5", "start": [500, 1], "end": [501, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedOrder", "code": "class BoundedOrder (\u03b1 : Type u) [LE \u03b1] extends OrderTop \u03b1, OrderBot \u03b1", "start": [509, 1], "end": [511, 70], "kind": "commanddeclaration"}, {"full_name": "OrderDual.boundedOrder", "code": "instance OrderDual.boundedOrder (\u03b1 : Type u) [LE \u03b1] [BoundedOrder \u03b1] : BoundedOrder \u03b1\u1d52\u1d48 where\n  __ := inferInstanceAs (OrderTop \u03b1\u1d52\u1d48)\n  __ := inferInstanceAs (OrderBot \u03b1\u1d52\u1d48)", "start": [514, 1], "end": [516, 39], "kind": "commanddeclaration"}, {"full_name": "OrderBot.instSubsingleton", "code": "instance OrderBot.instSubsingleton : Subsingleton (OrderBot \u03b1) where\n  allEq := by rintro @\u27e8\u27e8a\u27e9, ha\u27e9 @\u27e8\u27e8b\u27e9, hb\u27e9; congr; exact le_antisymm (ha _) (hb _)", "start": [521, 1], "end": [522, 83], "kind": "commanddeclaration"}, {"full_name": "OrderTop.instSubsingleton", "code": "instance OrderTop.instSubsingleton : Subsingleton (OrderTop \u03b1) where\n  allEq := by rintro @\u27e8\u27e8a\u27e9, ha\u27e9 @\u27e8\u27e8b\u27e9, hb\u27e9; congr; exact le_antisymm (hb _) (ha _)", "start": [524, 1], "end": [525, 83], "kind": "commanddeclaration"}, {"full_name": "BoundedOrder.instSubsingleton", "code": "instance BoundedOrder.instSubsingleton : Subsingleton (BoundedOrder \u03b1) where\n  allEq := by rintro \u27e8\u27e9 \u27e8\u27e9; congr <;> exact Subsingleton.elim _ _", "start": [527, 1], "end": [528, 66], "kind": "commanddeclaration"}, {"full_name": "monotone_and", "code": "theorem monotone_and {p q : \u03b1 \u2192 Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x \u2227 q x", "start": [543, 1], "end": [545, 39], "kind": "commanddeclaration"}, {"full_name": "monotone_or", "code": "theorem monotone_or {p q : \u03b1 \u2192 Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x \u2228 q x", "start": [549, 1], "end": [551, 38], "kind": "commanddeclaration"}, {"full_name": "monotone_le", "code": "theorem monotone_le {x : \u03b1} : Monotone ((\u00b7 \u2264 \u00b7) x)", "start": [554, 1], "end": [554, 81], "kind": "commanddeclaration"}, {"full_name": "monotone_lt", "code": "theorem monotone_lt {x : \u03b1} : Monotone ((\u00b7 < \u00b7) x)", "start": [557, 1], "end": [557, 84], "kind": "commanddeclaration"}, {"full_name": "antitone_le", "code": "theorem antitone_le {x : \u03b1} : Antitone (\u00b7 \u2264 x)", "start": [560, 1], "end": [560, 77], "kind": "commanddeclaration"}, {"full_name": "antitone_lt", "code": "theorem antitone_lt {x : \u03b1} : Antitone (\u00b7 < x)", "start": [563, 1], "end": [563, 80], "kind": "commanddeclaration"}, {"full_name": "Monotone.forall", "code": "theorem Monotone.forall {P : \u03b2 \u2192 \u03b1 \u2192 Prop} (hP : \u2200 x, Monotone (P x)) :\n    Monotone fun y => \u2200 x, P x y", "start": [566, 1], "end": [568, 35], "kind": "commanddeclaration"}, {"full_name": "Antitone.forall", "code": "theorem Antitone.forall {P : \u03b2 \u2192 \u03b1 \u2192 Prop} (hP : \u2200 x, Antitone (P x)) :\n    Antitone fun y => \u2200 x, P x y", "start": [571, 1], "end": [573, 34], "kind": "commanddeclaration"}, {"full_name": "Monotone.ball", "code": "theorem Monotone.ball {P : \u03b2 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b2} (hP : \u2200 x \u2208 s, Monotone (P x)) :\n    Monotone fun y => \u2200 x \u2208 s, P x y", "start": [576, 1], "end": [577, 81], "kind": "commanddeclaration"}, {"full_name": "Antitone.ball", "code": "theorem Antitone.ball {P : \u03b2 \u2192 \u03b1 \u2192 Prop} {s : Set \u03b2} (hP : \u2200 x \u2208 s, Antitone (P x)) :\n    Antitone fun y => \u2200 x \u2208 s, P x y", "start": [580, 1], "end": [581, 81], "kind": "commanddeclaration"}, {"full_name": "Monotone.exists", "code": "theorem Monotone.exists {P : \u03b2 \u2192 \u03b1 \u2192 Prop} (hP : \u2200 x, Monotone (P x)) :\n    Monotone fun y => \u2203 x, P x y", "start": [584, 1], "end": [586, 39], "kind": "commanddeclaration"}, {"full_name": "Antitone.exists", "code": "theorem Antitone.exists {P : \u03b2 \u2192 \u03b1 \u2192 Prop} (hP : \u2200 x, Antitone (P x)) :\n    Antitone fun y => \u2203 x, P x y", "start": [588, 1], "end": [590, 39], "kind": "commanddeclaration"}, {"full_name": "forall_ge_iff", "code": "theorem forall_ge_iff {P : \u03b1 \u2192 Prop} {x\u2080 : \u03b1} (hP : Monotone P) :\n    (\u2200 x \u2265 x\u2080, P x) \u2194 P x\u2080", "start": [592, 1], "end": [594, 46], "kind": "commanddeclaration"}, {"full_name": "forall_le_iff", "code": "theorem forall_le_iff {P : \u03b1 \u2192 Prop} {x\u2080 : \u03b1} (hP : Antitone P) :\n    (\u2200 x \u2264 x\u2080, P x) \u2194 P x\u2080", "start": [596, 1], "end": [598, 46], "kind": "commanddeclaration"}, {"full_name": "exists_ge_and_iff_exists", "code": "theorem exists_ge_and_iff_exists {P : \u03b1 \u2192 Prop} {x\u2080 : \u03b1} (hP : Monotone P) :\n    (\u2203 x, x\u2080 \u2264 x \u2227 P x) \u2194 \u2203 x, P x", "start": [606, 1], "end": [608, 92], "kind": "commanddeclaration"}, {"full_name": "exists_le_and_iff_exists", "code": "theorem exists_le_and_iff_exists {P : \u03b1 \u2192 Prop} {x\u2080 : \u03b1} (hP : Antitone P) :\n    (\u2203 x, x \u2264 x\u2080 \u2227 P x) \u2194 \u2203 x, P x", "start": [617, 1], "end": [619, 43], "kind": "commanddeclaration"}, {"full_name": "Pi.bot_apply", "code": "@[simp]\ntheorem bot_apply [\u2200 i, Bot (\u03b1' i)] (i : \u03b9) : (\u22a5 : \u2200 i, \u03b1' i) i = \u22a5", "start": [636, 1], "end": [638, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.bot_def", "code": "theorem bot_def [\u2200 i, Bot (\u03b1' i)] : (\u22a5 : \u2200 i, \u03b1' i) = fun _ => \u22a5", "start": [641, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.top_apply", "code": "@[simp]\ntheorem top_apply [\u2200 i, Top (\u03b1' i)] (i : \u03b9) : (\u22a4 : \u2200 i, \u03b1' i) i = \u22a4", "start": [648, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.top_def", "code": "theorem top_def [\u2200 i, Top (\u03b1' i)] : (\u22a4 : \u2200 i, \u03b1' i) = fun _ => \u22a4", "start": [653, 1], "end": [654, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.orderTop", "code": "instance orderTop [\u2200 i, LE (\u03b1' i)] [\u2200 i, OrderTop (\u03b1' i)] : OrderTop (\u2200 i, \u03b1' i) :=\n  { inferInstanceAs (Top (\u2200 i, \u03b1' i)) with le_top := fun _ _ => le_top }", "start": [657, 1], "end": [658, 73], "kind": "commanddeclaration"}, {"full_name": "Pi.orderBot", "code": "instance orderBot [\u2200 i, LE (\u03b1' i)] [\u2200 i, OrderBot (\u03b1' i)] : OrderBot (\u2200 i, \u03b1' i) :=\n  { inferInstanceAs (Bot (\u2200 i, \u03b1' i)) with bot_le := fun _ _ => bot_le }", "start": [660, 1], "end": [661, 73], "kind": "commanddeclaration"}, {"full_name": "Pi.boundedOrder", "code": "instance boundedOrder [\u2200 i, LE (\u03b1' i)] [\u2200 i, BoundedOrder (\u03b1' i)] : BoundedOrder (\u2200 i, \u03b1' i) where\n  __ := inferInstanceAs (OrderTop (\u2200 i, \u03b1' i))\n  __ := inferInstanceAs (OrderBot (\u2200 i, \u03b1' i))", "start": [663, 1], "end": [665, 47], "kind": "commanddeclaration"}, {"full_name": "eq_bot_of_bot_eq_top", "code": "theorem eq_bot_of_bot_eq_top (h\u03b1 : (\u22a5 : \u03b1) = \u22a4) (x : \u03b1) : x = (\u22a5 : \u03b1)", "start": [673, 1], "end": [674, 34], "kind": "commanddeclaration"}, {"full_name": "eq_top_of_bot_eq_top", "code": "theorem eq_top_of_bot_eq_top (h\u03b1 : (\u22a5 : \u03b1) = \u22a4) (x : \u03b1) : x = (\u22a4 : \u03b1)", "start": [677, 1], "end": [678, 24], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_top_le_bot", "code": "theorem subsingleton_of_top_le_bot (h : (\u22a4 : \u03b1) \u2264 (\u22a5 : \u03b1)) : Subsingleton \u03b1", "start": [681, 1], "end": [683, 83], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_bot_eq_top", "code": "theorem subsingleton_of_bot_eq_top (h\u03b1 : (\u22a5 : \u03b1) = (\u22a4 : \u03b1)) : Subsingleton \u03b1", "start": [686, 1], "end": [687, 43], "kind": "commanddeclaration"}, {"full_name": "subsingleton_iff_bot_eq_top", "code": "theorem subsingleton_iff_bot_eq_top : (\u22a5 : \u03b1) = (\u22a4 : \u03b1) \u2194 Subsingleton \u03b1", "start": [690, 1], "end": [691, 63], "kind": "commanddeclaration"}, {"full_name": "OrderTop.lift", "code": "@[reducible]\ndef OrderTop.lift [LE \u03b1] [Top \u03b1] [LE \u03b2] [OrderTop \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (map_le : \u2200 a b, f a \u2264 f b \u2192 a \u2264 b) (map_top : f \u22a4 = \u22a4) : OrderTop \u03b1 :=\n  \u27e8fun a =>\n    map_le _ _ <| by\n      rw [map_top]\n      exact @le_top \u03b2 _ _ _\u27e9", "start": [699, 1], "end": [707, 29], "kind": "commanddeclaration"}, {"full_name": "OrderBot.lift", "code": "@[reducible]\ndef OrderBot.lift [LE \u03b1] [Bot \u03b1] [LE \u03b2] [OrderBot \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (map_le : \u2200 a b, f a \u2264 f b \u2192 a \u2264 b) (map_bot : f \u22a5 = \u22a5) : OrderBot \u03b1 :=\n  \u27e8fun a =>\n    map_le _ _ <| by\n      rw [map_bot]\n      exact @bot_le \u03b2 _ _ _\u27e9", "start": [711, 1], "end": [719, 29], "kind": "commanddeclaration"}, {"full_name": "BoundedOrder.lift", "code": "@[reducible]\ndef BoundedOrder.lift [LE \u03b1] [Top \u03b1] [Bot \u03b1] [LE \u03b2] [BoundedOrder \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (map_le : \u2200 a b, f a \u2264 f b \u2192 a \u2264 b) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) : BoundedOrder \u03b1 :=\n  { OrderTop.lift f map_le map_top, OrderBot.lift f map_le map_bot with }", "start": [723, 1], "end": [727, 74], "kind": "commanddeclaration"}, {"full_name": "Subtype.orderBot", "code": "@[reducible]\nprotected def orderBot [LE \u03b1] [OrderBot \u03b1] (hbot : p \u22a5) : OrderBot { x : \u03b1 // p x } where\n  bot := \u27e8\u22a5, hbot\u27e9\n  bot_le _ := bot_le", "start": [740, 1], "end": [744, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.orderTop", "code": "@[reducible]\nprotected def orderTop [LE \u03b1] [OrderTop \u03b1] (htop : p \u22a4) : OrderTop { x : \u03b1 // p x } where\n  top := \u27e8\u22a4, htop\u27e9\n  le_top _ := le_top", "start": [748, 1], "end": [752, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.boundedOrder", "code": "@[reducible]\nprotected def boundedOrder [LE \u03b1] [BoundedOrder \u03b1] (hbot : p \u22a5) (htop : p \u22a4) :\n    BoundedOrder (Subtype p) :=\n  { Subtype.orderTop htop, Subtype.orderBot hbot with }", "start": [756, 1], "end": [760, 56], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_bot", "code": "@[simp]\ntheorem mk_bot [OrderBot \u03b1] [OrderBot (Subtype p)] (hbot : p \u22a5) : mk \u22a5 hbot = \u22a5", "start": [765, 1], "end": [767, 38], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_top", "code": "@[simp]\ntheorem mk_top [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) : mk \u22a4 htop = \u22a4", "start": [770, 1], "end": [772, 38], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_bot", "code": "theorem coe_bot [OrderBot \u03b1] [OrderBot (Subtype p)] (hbot : p \u22a5) : ((\u22a5 : Subtype p) : \u03b1) = \u22a5", "start": [775, 1], "end": [776, 43], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_top", "code": "theorem coe_top [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) : ((\u22a4 : Subtype p) : \u03b1) = \u22a4", "start": [779, 1], "end": [780, 43], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_eq_bot_iff", "code": "@[simp]\ntheorem coe_eq_bot_iff [OrderBot \u03b1] [OrderBot (Subtype p)] (hbot : p \u22a5) {x : { x // p x }} :\n    (x : \u03b1) = \u22a5 \u2194 x = \u22a5", "start": [783, 1], "end": [786, 31], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_eq_top_iff", "code": "@[simp]\ntheorem coe_eq_top_iff [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) {x : { x // p x }} :\n    (x : \u03b1) = \u22a4 \u2194 x = \u22a4", "start": [789, 1], "end": [792, 31], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_eq_bot_iff", "code": "@[simp]\ntheorem mk_eq_bot_iff [OrderBot \u03b1] [OrderBot (Subtype p)] (hbot : p \u22a5) {x : \u03b1} (hx : p x) :\n    (\u27e8x, hx\u27e9 : Subtype p) = \u22a5 \u2194 x = \u22a5", "start": [795, 1], "end": [798, 29], "kind": "commanddeclaration"}, {"full_name": "Subtype.mk_eq_top_iff", "code": "@[simp]\ntheorem mk_eq_top_iff [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) {x : \u03b1} (hx : p x) :\n    (\u27e8x, hx\u27e9 : Subtype p) = \u22a4 \u2194 x = \u22a4", "start": [801, 1], "end": [804, 29], "kind": "commanddeclaration"}, {"full_name": "Prod.top", "code": "instance top [Top \u03b1] [Top \u03b2] : Top (\u03b1 \u00d7 \u03b2) :=\n  \u27e8\u27e8\u22a4, \u22a4\u27e9\u27e9", "start": [813, 1], "end": [814, 11], "kind": "commanddeclaration"}, {"full_name": "Prod.bot", "code": "instance bot [Bot \u03b1] [Bot \u03b2] : Bot (\u03b1 \u00d7 \u03b2) :=\n  \u27e8\u27e8\u22a5, \u22a5\u27e9\u27e9", "start": [816, 1], "end": [817, 11], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_top", "code": "theorem fst_top [Top \u03b1] [Top \u03b2] : (\u22a4 : \u03b1 \u00d7 \u03b2).fst = \u22a4", "start": [819, 1], "end": [819, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_top", "code": "theorem snd_top [Top \u03b1] [Top \u03b2] : (\u22a4 : \u03b1 \u00d7 \u03b2).snd = \u22a4", "start": [820, 1], "end": [820, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_bot", "code": "theorem fst_bot [Bot \u03b1] [Bot \u03b2] : (\u22a5 : \u03b1 \u00d7 \u03b2).fst = \u22a5", "start": [821, 1], "end": [821, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_bot", "code": "theorem snd_bot [Bot \u03b1] [Bot \u03b2] : (\u22a5 : \u03b1 \u00d7 \u03b2).snd = \u22a5", "start": [822, 1], "end": [822, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.orderTop", "code": "instance orderTop [LE \u03b1] [LE \u03b2] [OrderTop \u03b1] [OrderTop \u03b2] : OrderTop (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (Top (\u03b1 \u00d7 \u03b2))\n  le_top _ := \u27e8le_top, le_top\u27e9", "start": [824, 1], "end": [826, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.orderBot", "code": "instance orderBot [LE \u03b1] [LE \u03b2] [OrderBot \u03b1] [OrderBot \u03b2] : OrderBot (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (Bot (\u03b1 \u00d7 \u03b2))\n  bot_le _ := \u27e8bot_le, bot_le\u27e9", "start": [828, 1], "end": [830, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.boundedOrder", "code": "instance boundedOrder [LE \u03b1] [LE \u03b2] [BoundedOrder \u03b1] [BoundedOrder \u03b2] : BoundedOrder (\u03b1 \u00d7 \u03b2) where\n  __ := inferInstanceAs (OrderTop (\u03b1 \u00d7 \u03b2))\n  __ := inferInstanceAs (OrderBot (\u03b1 \u00d7 \u03b2))", "start": [832, 1], "end": [834, 43], "kind": "commanddeclaration"}, {"full_name": "ULift.up_top", "code": "@[simp] theorem up_top [Top \u03b1] : up (\u22a4 : \u03b1) = \u22a4", "start": [842, 1], "end": [842, 55], "kind": "commanddeclaration"}, {"full_name": "ULift.down_top", "code": "@[simp] theorem down_top [Top \u03b1] : down (\u22a4 : ULift \u03b1) = \u22a4", "start": [843, 1], "end": [843, 65], "kind": "commanddeclaration"}, {"full_name": "ULift.up_bot", "code": "@[simp] theorem up_bot [Bot \u03b1] : up (\u22a5 : \u03b1) = \u22a5", "start": [847, 1], "end": [847, 55], "kind": "commanddeclaration"}, {"full_name": "ULift.down_bot", "code": "@[simp] theorem down_bot [Bot \u03b1] : down (\u22a5 : ULift \u03b1) = \u22a5", "start": [848, 1], "end": [848, 65], "kind": "commanddeclaration"}, {"full_name": "min_bot_left", "code": "theorem min_bot_left [OrderBot \u03b1] (a : \u03b1) : min \u22a5 a = \u22a5", "start": [865, 1], "end": [866, 13], "kind": "commanddeclaration"}, {"full_name": "max_top_left", "code": "theorem max_top_left [OrderTop \u03b1] (a : \u03b1) : max \u22a4 a = \u22a4", "start": [869, 1], "end": [870, 13], "kind": "commanddeclaration"}, {"full_name": "min_top_left", "code": "theorem min_top_left [OrderTop \u03b1] (a : \u03b1) : min \u22a4 a = a", "start": [873, 1], "end": [874, 13], "kind": "commanddeclaration"}, {"full_name": "max_bot_left", "code": "theorem max_bot_left [OrderBot \u03b1] (a : \u03b1) : max \u22a5 a = a", "start": [877, 1], "end": [878, 13], "kind": "commanddeclaration"}, {"full_name": "min_top_right", "code": "theorem min_top_right [OrderTop \u03b1] (a : \u03b1) : min a \u22a4 = a", "start": [881, 1], "end": [882, 13], "kind": "commanddeclaration"}, {"full_name": "max_bot_right", "code": "theorem max_bot_right [OrderBot \u03b1] (a : \u03b1) : max a \u22a5 = a", "start": [885, 1], "end": [886, 13], "kind": "commanddeclaration"}, {"full_name": "min_bot_right", "code": "theorem min_bot_right [OrderBot \u03b1] (a : \u03b1) : min a \u22a5 = \u22a5", "start": [889, 1], "end": [890, 13], "kind": "commanddeclaration"}, {"full_name": "max_top_right", "code": "theorem max_top_right [OrderTop \u03b1] (a : \u03b1) : max a \u22a4 = \u22a4", "start": [893, 1], "end": [894, 13], "kind": "commanddeclaration"}, {"full_name": "min_eq_bot", "code": "@[simp]\ntheorem min_eq_bot [OrderBot \u03b1] {a b : \u03b1} : min a b = \u22a5 \u2194 a = \u22a5 \u2228 b = \u22a5", "start": [897, 1], "end": [899, 53], "kind": "commanddeclaration"}, {"full_name": "max_eq_top", "code": "@[simp]\ntheorem max_eq_top [OrderTop \u03b1] {a b : \u03b1} : max a b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "start": [902, 1], "end": [904, 26], "kind": "commanddeclaration"}, {"full_name": "max_eq_bot", "code": "@[simp]\ntheorem max_eq_bot [OrderBot \u03b1] {a b : \u03b1} : max a b = \u22a5 \u2194 a = \u22a5 \u2227 b = \u22a5", "start": [907, 1], "end": [909, 17], "kind": "commanddeclaration"}, {"full_name": "min_eq_top", "code": "@[simp]\ntheorem min_eq_top [OrderTop \u03b1] {a b : \u03b1} : min a b = \u22a4 \u2194 a = \u22a4 \u2227 b = \u22a4", "start": [912, 1], "end": [914, 17], "kind": "commanddeclaration"}, {"full_name": "bot_ne_top", "code": "@[simp]\ntheorem bot_ne_top : (\u22a5 : \u03b1) \u2260 \u22a4", "start": [923, 1], "end": [924, 96], "kind": "commanddeclaration"}, {"full_name": "top_ne_bot", "code": "@[simp]\ntheorem top_ne_bot : (\u22a4 : \u03b1) \u2260 \u22a5", "start": [927, 1], "end": [929, 18], "kind": "commanddeclaration"}, {"full_name": "bot_lt_top", "code": "@[simp]\ntheorem bot_lt_top : (\u22a5 : \u03b1) < \u22a4", "start": [932, 1], "end": [934, 33], "kind": "commanddeclaration"}, {"full_name": "Bool.boundedOrder", "code": "instance Bool.boundedOrder : BoundedOrder Bool where\n  top := true\n  le_top _ := le_true\n  bot := false\n  bot_le _ := false_le", "start": [943, 1], "end": [947, 23], "kind": "commanddeclaration"}, {"full_name": "top_eq_true", "code": "@[simp]\ntheorem top_eq_true : \u22a4 = true", "start": [949, 1], "end": [951, 6], "kind": "commanddeclaration"}, {"full_name": "bot_eq_false", "code": "@[simp]\ntheorem bot_eq_false : \u22a5 = false", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Option/NAry.lean", "imports": ["Mathlib/Data/Option/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Option.map\u2082", "code": "def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : Option \u03b2) : Option \u03b3 :=\n  a.bind fun a => b.map <| f a", "start": [40, 1], "end": [43, 31], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_def", "code": "theorem map\u2082_def {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : Option \u03b2) :\n    map\u2082 f a b = f <$> a <*> b", "start": [46, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_some_some", "code": "theorem map\u2082_some_some (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : \u03b1) (b : \u03b2) : map\u2082 f (some a) (some b) = f a b", "start": [54, 1], "end": [54, 97], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_coe_coe", "code": "theorem map\u2082_coe_coe (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : \u03b1) (b : \u03b2) : map\u2082 f a b = f a b", "start": [57, 1], "end": [57, 81], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_none_left", "code": "@[simp]\ntheorem map\u2082_none_left (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (b : Option \u03b2) : map\u2082 f none b = none", "start": [60, 1], "end": [61, 84], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_none_right", "code": "@[simp]\ntheorem map\u2082_none_right (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) : map\u2082 f a none = none", "start": [64, 1], "end": [65, 100], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_coe_left", "code": "@[simp]\ntheorem map\u2082_coe_left (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : \u03b1) (b : Option \u03b2) : map\u2082 f a b = b.map fun b => f a b", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_coe_right", "code": "@[simp]\ntheorem map\u2082_coe_right (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : \u03b2) : map\u2082 f a b = a.map fun a => f a b", "start": [74, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "Option.mem_map\u2082_iff", "code": "theorem mem_map\u2082_iff {c : \u03b3} : c \u2208 map\u2082 f a b \u2194 \u2203 a' b', a' \u2208 a \u2227 b' \u2208 b \u2227 f a' b' = c", "start": [80, 1], "end": [81, 17], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_eq_none_iff", "code": "@[simp]\ntheorem map\u2082_eq_none_iff : map\u2082 f a b = none \u2194 a = none \u2228 b = none", "start": [84, 1], "end": [86, 34], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_swap", "code": "theorem map\u2082_swap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : Option \u03b2) :\n    map\u2082 f a b = map\u2082 (fun a b => f b a) b a", "start": [89, 1], "end": [90, 79], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082", "code": "theorem map_map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4) :\n    (map\u2082 f a b).map g = map\u2082 (fun a b => g (f a b)) a b", "start": [93, 1], "end": [94, 91], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_map_left", "code": "theorem map\u2082_map_left (f : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3) :\n    map\u2082 f (a.map g) b = map\u2082 (fun a b => f (g a) b) a b", "start": [97, 1], "end": [98, 79], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_map_right", "code": "theorem map\u2082_map_right (f : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b3) :\n    map\u2082 f a (b.map g) = map\u2082 (fun a b => f a (g b)) a b", "start": [101, 1], "end": [102, 79], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_curry", "code": "@[simp]\ntheorem map\u2082_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : Option \u03b2) :\n    map\u2082 (curry f) a b = Option.map f (map\u2082 Prod.mk a b)", "start": [105, 1], "end": [107, 80], "kind": "commanddeclaration"}, {"full_name": "Option.map_uncurry", "code": "@[simp]\ntheorem map_uncurry (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (x : Option (\u03b1 \u00d7 \u03b2)) :\n    x.map (uncurry f) = map\u2082 f (x.map Prod.fst) (x.map Prod.snd)", "start": [110, 1], "end": [112, 87], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_assoc", "code": "theorem map\u2082_assoc {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b5' \u2192 \u03b5} {g' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'}\n    (h_assoc : \u2200 a b c, f (g a b) c = f' a (g' b c)) :\n    map\u2082 f (map\u2082 g a b) c = map\u2082 f' a (map\u2082 g' b c)", "start": [124, 1], "end": [127, 56], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_comm", "code": "theorem map\u2082_comm {g : \u03b2 \u2192 \u03b1 \u2192 \u03b3} (h_comm : \u2200 a b, f a b = g b a) : map\u2082 f a b = map\u2082 g b a", "start": [130, 1], "end": [131, 43], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_left_comm", "code": "theorem map\u2082_left_comm {f : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {g : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b2 \u2192 \u03b4' \u2192 \u03b5}\n    (h_left_comm : \u2200 a b c, f a (g b c) = g' b (f' a c)) :\n    map\u2082 f a (map\u2082 g b c) = map\u2082 g' b (map\u2082 f' a c)", "start": [134, 1], "end": [137, 60], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_right_comm", "code": "theorem map\u2082_right_comm {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b4' \u2192 \u03b2 \u2192 \u03b5}\n    (h_right_comm : \u2200 a b c, f (g a b) c = g' (f' a c) b) :\n    map\u2082 f (map\u2082 g a b) c = map\u2082 g' (map\u2082 f' a c) b", "start": [140, 1], "end": [143, 61], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_distrib", "code": "theorem map_map\u2082_distrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2' \u2192 \u03b4} {g\u2081 : \u03b1 \u2192 \u03b1'} {g\u2082 : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g\u2081 a) (g\u2082 b)) :\n    (map\u2082 f a b).map g = map\u2082 f' (a.map g\u2081) (b.map g\u2082)", "start": [146, 1], "end": [149, 46], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_distrib_left", "code": "theorem map_map\u2082_distrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g' a) b) :\n    (map\u2082 f a b).map g = map\u2082 f' (a.map g') b", "start": [157, 1], "end": [160, 93], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_distrib_right", "code": "theorem map_map\u2082_distrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b2' \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' a (g' b)) : (map\u2082 f a b).map g = map\u2082 f' a (b.map g')", "start": [163, 1], "end": [166, 46], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_map_left_comm", "code": "theorem map\u2082_map_left_comm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_comm : \u2200 a b, f (g a) b = g' (f' a b)) : map\u2082 f (a.map g) b = (map\u2082 f' a b).map g'", "start": [169, 1], "end": [172, 48], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_right_comm", "code": "theorem map_map\u2082_right_comm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_comm : \u2200 a b, f a (g b) = g' (f' a b)) : map\u2082 f a (b.map g) = (map\u2082 f' a b).map g'", "start": [175, 1], "end": [178, 49], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_antidistrib", "code": "theorem map_map\u2082_antidistrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {g\u2081 : \u03b2 \u2192 \u03b2'} {g\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g\u2081 b) (g\u2082 a)) :\n    (map\u2082 f a b).map g = map\u2082 f' (b.map g\u2081) (a.map g\u2082)", "start": [181, 1], "end": [184, 50], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_antidistrib_left", "code": "theorem map_map\u2082_antidistrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g' b) a) :\n    (map\u2082 f a b).map g = map\u2082 f' (b.map g') a", "start": [187, 1], "end": [191, 50], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_antidistrib_right", "code": "theorem map_map\u2082_antidistrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' b (g' a)) : (map\u2082 f a b).map g = map\u2082 f' b (a.map g')", "start": [194, 1], "end": [197, 50], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_map_left_anticomm", "code": "theorem map\u2082_map_left_anticomm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_anticomm : \u2200 a b, f (g a) b = g' (f' b a)) :\n    map\u2082 f (a.map g) b = (map\u2082 f' b a).map g'", "start": [200, 1], "end": [203, 99], "kind": "commanddeclaration"}, {"full_name": "Option.map_map\u2082_right_anticomm", "code": "theorem map_map\u2082_right_anticomm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_anticomm : \u2200 a b, f a (g b) = g' (f' b a)) :\n    map\u2082 f a (b.map g) = (map\u2082 f' b a).map g'", "start": [206, 1], "end": [209, 100], "kind": "commanddeclaration"}, {"full_name": "Option.map\u2082_left_identity", "code": "lemma map\u2082_left_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {a : \u03b1} (h : \u2200 b, f a b = b) (o : Option \u03b2) :\n    map\u2082 f (some a) o = o := by\n  cases o; exacts [rfl, congr_arg some (h _)]", "start": [212, 1], "end": [216, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Option.map\u2082_right_identity", "code": "lemma map\u2082_right_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {b : \u03b2} (h : \u2200 a, f a b = a) (o : Option \u03b1) :\n    map\u2082 f o (some b) = o := by\n  simp [h, map\u2082]", "start": [219, 1], "end": [223, 17], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "imports": ["Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Tactic/Contrapose.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CovariantAndContravariant.lean", "Mathlib/Order/MinMax.lean"], "premises": [{"full_name": "mul_le_mul_left'", "code": "@[to_additive add_le_add_left]\ntheorem mul_le_mul_left' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {b c : \u03b1} (bc : b \u2264 c) (a : \u03b1) :\n    a * b \u2264 a * c", "start": [49, 1], "end": [52, 27], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_mul_left'", "code": "@[to_additive le_of_add_le_add_left]\ntheorem le_of_mul_le_mul_left' [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (bc : a * b \u2264 a * c) :\n    b \u2264 c", "start": [56, 1], "end": [60, 31], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_right'", "code": "@[to_additive add_le_add_right]\ntheorem mul_le_mul_right' [i : CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {b c : \u03b1} (bc : b \u2264 c)\n    (a : \u03b1) :\n    b * a \u2264 c * a", "start": [66, 1], "end": [70, 14], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_mul_right'", "code": "@[to_additive le_of_add_le_add_right]\ntheorem le_of_mul_le_mul_right' [i : ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (bc : b * a \u2264 c * a) :\n    b \u2264 c", "start": [74, 1], "end": [78, 14], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_iff_left", "code": "@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) {b c : \u03b1} :\n    a * b \u2264 a * c \u2194 b \u2264 c", "start": [82, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_iff_right", "code": "@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) {b c : \u03b1} :\n    b * a \u2264 c * a \u2194 b \u2264 c", "start": [90, 1], "end": [94, 43], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_iff_left", "code": "@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) {b c : \u03b1} :\n    a * b < a * c \u2194 b < c", "start": [104, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_iff_right", "code": "@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) {b c : \u03b1} :\n    b * a < c * a \u2194 b < c", "start": [112, 1], "end": [116, 43], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_left'", "code": "@[to_additive add_lt_add_left]\ntheorem mul_lt_mul_left' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {b c : \u03b1} (bc : b < c) (a : \u03b1) :\n    a * b < a * c", "start": [120, 1], "end": [123, 27], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_left'", "code": "@[to_additive lt_of_add_lt_add_left]\ntheorem lt_of_mul_lt_mul_left' [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b c : \u03b1}\n    (bc : a * b < a * c) :\n    b < c", "start": [127, 1], "end": [131, 31], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_right'", "code": "@[to_additive add_lt_add_right]\ntheorem mul_lt_mul_right' [i : CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {b c : \u03b1} (bc : b < c)\n    (a : \u03b1) :\n    b * a < c * a", "start": [135, 1], "end": [139, 14], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_right'", "code": "@[to_additive lt_of_add_lt_add_right]\ntheorem lt_of_mul_lt_mul_right' [i : ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c : \u03b1}\n    (bc : b * a < c * a) :\n    b < c", "start": [143, 1], "end": [147, 14], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_lt_of_lt", "code": "@[to_additive]\ntheorem mul_lt_mul_of_lt_of_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    {a b c d : \u03b1} (h\u2081 : a < b) (h\u2082 : c < d) : a * c < b * d", "start": [157, 1], "end": [163, 40], "kind": "commanddeclaration"}, {"full_name": "add_lt_add", "code": "alias add_lt_add := add_lt_add_of_lt_of_lt", "start": [167, 1], "end": [167, 43], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_mul_of_le_of_lt", "code": "@[to_additive]\ntheorem mul_lt_mul_of_le_of_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h\u2081 : a \u2264 b) (h\u2082 : c < d) :\n    a * c < b * d", "start": [170, 1], "end": [174, 60], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_lt_of_le", "code": "@[to_additive]\ntheorem mul_lt_mul_of_lt_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c d : \u03b1} (h\u2081 : a < b) (h\u2082 : c \u2264 d) :\n    a * c < b * d", "start": [178, 1], "end": [182, 60], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_mul", "code": "@[to_additive \"Only assumes left strict covariance\"]\ntheorem Left.mul_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h\u2081 : a < b) (h\u2082 : c < d) :\n    a * c < b * d", "start": [186, 1], "end": [191, 34], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_mul", "code": "@[to_additive \"Only assumes right strict covariance\"]\ntheorem Right.mul_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c d : \u03b1}\n    (h\u2081 : a < b) (h\u2082 : c < d) :\n    a * c < b * d", "start": [195, 1], "end": [201, 34], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul'", "code": "@[to_additive add_le_add]\ntheorem mul_le_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    {a b c d : \u03b1} (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) :\n    a * c \u2264 b * d", "start": [205, 1], "end": [209, 57], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_three", "code": "@[to_additive]\ntheorem mul_le_mul_three [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d e f : \u03b1} (h\u2081 : a \u2264 d) (h\u2082 : b \u2264 e)\n    (h\u2083 : c \u2264 f) :\n    a * b * c \u2264 d * e * f", "start": [213, 1], "end": [218, 37], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_mul_lt_left", "code": "@[to_additive]\ntheorem mul_lt_of_mul_lt_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h : a * b < c)\n    (hle : d \u2264 b) :\n    a * d < c", "start": [222, 1], "end": [226, 38], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_mul_le_left", "code": "@[to_additive]\ntheorem mul_le_of_mul_le_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h : a * b \u2264 c)\n    (hle : d \u2264 b) :\n    a * d \u2264 c", "start": [230, 1], "end": [234, 61], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_mul_lt_right", "code": "@[to_additive]\ntheorem mul_lt_of_mul_lt_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1}\n    (h : a * b < c) (hle : d \u2264 a) :\n    d * b < c", "start": [238, 1], "end": [242, 39], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_mul_le_right", "code": "@[to_additive]\ntheorem mul_le_of_mul_le_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1}\n    (h : a * b \u2264 c) (hle : d \u2264 a) :\n    d * b \u2264 c", "start": [246, 1], "end": [250, 36], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_mul_left", "code": "@[to_additive]\ntheorem lt_mul_of_lt_mul_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h : a < b * c)\n    (hle : c \u2264 d) :\n    a < b * d", "start": [254, 1], "end": [258, 38], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_mul_left", "code": "@[to_additive]\ntheorem le_mul_of_le_mul_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1} (h : a \u2264 b * c)\n    (hle : c \u2264 d) :\n    a \u2264 b * d", "start": [262, 1], "end": [266, 61], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_mul_right", "code": "@[to_additive]\ntheorem lt_mul_of_lt_mul_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1}\n    (h : a < b * c) (hle : b \u2264 d) :\n    a < d * c", "start": [270, 1], "end": [274, 39], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_mul_right", "code": "@[to_additive]\ntheorem le_mul_of_le_mul_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d : \u03b1}\n    (h : a \u2264 b * c) (hle : b \u2264 d) :\n    a \u2264 d * c", "start": [278, 1], "end": [282, 36], "kind": "commanddeclaration"}, {"full_name": "mul_left_cancel''", "code": "@[to_additive]\ntheorem mul_left_cancel'' [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (h : a * b = a * c) :\n    b = c", "start": [292, 1], "end": [295, 71], "kind": "commanddeclaration"}, {"full_name": "mul_right_cancel''", "code": "@[to_additive]\ntheorem mul_right_cancel'' [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (h : a * b = c * b) :\n    a = c", "start": [299, 1], "end": [303, 73], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_iff_of_ge", "code": "@[to_additive] lemma mul_le_mul_iff_of_ge [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} (ha : a\u2081 \u2264 a\u2082) (hb : b\u2081 \u2264 b\u2082) :\n    a\u2082 * b\u2082 \u2264 a\u2081 * b\u2081 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 := by\n  haveI := covariantClass_le_of_lt \u03b1 \u03b1 (\u00b7 * \u00b7)\n  haveI := covariantClass_le_of_lt \u03b1 \u03b1 (swap (\u00b7 * \u00b7))\n  refine' \u27e8fun h \u21a6 _, by rintro \u27e8rfl, rfl\u27e9; rfl\u27e9\n  simp only [eq_iff_le_not_lt, ha, hb, true_and]\n  refine' \u27e8fun ha \u21a6 h.not_lt _, fun hb \u21a6 h.not_lt _\u27e9\n  exacts [mul_lt_mul_of_lt_of_le ha hb, mul_lt_mul_of_le_of_lt ha hb]", "start": [307, 1], "end": [315, 70], "kind": "mathlibtacticlemma"}, {"full_name": "mul_eq_mul_iff_eq_and_eq", "code": "@[to_additive] theorem mul_eq_mul_iff_eq_and_eq [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c d : \u03b1} (hac : a \u2264 c) (hbd : b \u2264 d) :\n    a * b = c * d \u2194 a = c \u2227 b = d", "start": [319, 1], "end": [324, 94], "kind": "commanddeclaration"}, {"full_name": "min_lt_max_of_mul_lt_mul", "code": "@[to_additive] lemma min_lt_max_of_mul_lt_mul\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (h : a * b < c * d) : min a b < max c d := by\n  simp_rw [min_lt_iff, lt_max_iff]; contrapose! h; exact mul_le_mul' h.1.1 h.2.2", "start": [333, 1], "end": [336, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Left.min_le_max_of_mul_le_mul", "code": "@[to_additive] lemma Left.min_le_max_of_mul_le_mul\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    (h : a * b \u2264 c * d) : min a b \u2264 max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_le_of_lt h.1.1.le h.2.2", "start": [340, 1], "end": [343, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Right.min_le_max_of_mul_le_mul", "code": "@[to_additive] lemma Right.min_le_max_of_mul_le_mul\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    (h : a * b \u2264 c * d) : min a b \u2264 max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_lt_of_le h.1.1 h.2.2.le", "start": [345, 1], "end": [348, 95], "kind": "mathlibtacticlemma"}, {"full_name": "min_le_max_of_mul_le_mul", "code": "@[to_additive] lemma min_le_max_of_mul_le_mul\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    (h : a * b \u2264 c * d) : min a b \u2264 max c d :=\n  let _ := covariantClass_le_of_lt \u03b1 \u03b1 (swap (\u00b7 * \u00b7))\n  Left.min_le_max_of_mul_le_mul h", "start": [350, 1], "end": [354, 34], "kind": "mathlibtacticlemma"}, {"full_name": "max_mul_mul_le_max_mul_max'", "code": "@[to_additive max_add_add_le_max_add_max]\ntheorem max_mul_mul_le_max_mul_max' : max (a * b) (c * d) \u2264 max a c * max b d", "start": [364, 1], "end": [367, 55], "kind": "commanddeclaration"}, {"full_name": "min_mul_min_le_min_mul_mul'", "code": "@[to_additive min_add_min_le_min_add_add]\ntheorem min_mul_min_le_min_mul_mul' : min a c * min b d \u2264 min (a * b) (c * d)", "start": [372, 1], "end": [375, 55], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_right'", "code": "@[to_additive le_add_of_nonneg_right]\ntheorem le_mul_of_one_le_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : 1 \u2264 b) :\n    a \u2264 a * b", "start": [391, 1], "end": [396, 38], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_right'", "code": "@[to_additive add_le_of_nonpos_right]\ntheorem mul_le_of_le_one_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : b \u2264 1) :\n    a * b \u2264 a", "start": [400, 1], "end": [405, 23], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_left'", "code": "@[to_additive le_add_of_nonneg_left]\ntheorem le_mul_of_one_le_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : 1 \u2264 b) :\n    a \u2264 b * a", "start": [409, 1], "end": [414, 39], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_left'", "code": "@[to_additive add_le_of_nonpos_left]\ntheorem mul_le_of_le_one_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : b \u2264 1) :\n    b * a \u2264 a", "start": [418, 1], "end": [423, 23], "kind": "commanddeclaration"}, {"full_name": "one_le_of_le_mul_right", "code": "@[to_additive]\ntheorem one_le_of_le_mul_right [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : a \u2264 a * b) :\n    1 \u2264 b", "start": [427, 1], "end": [430, 52], "kind": "commanddeclaration"}, {"full_name": "le_one_of_mul_le_right", "code": "@[to_additive]\ntheorem le_one_of_mul_le_right [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (h : a * b \u2264 a) :\n    b \u2264 1", "start": [434, 1], "end": [437, 52], "kind": "commanddeclaration"}, {"full_name": "one_le_of_le_mul_left", "code": "@[to_additive]\ntheorem one_le_of_le_mul_left [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1}\n    (h : b \u2264 a * b) :\n    1 \u2264 a", "start": [441, 1], "end": [445, 53], "kind": "commanddeclaration"}, {"full_name": "le_one_of_mul_le_left", "code": "@[to_additive]\ntheorem le_one_of_mul_le_left [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1}\n    (h : a * b \u2264 b) :\n    a \u2264 1", "start": [449, 1], "end": [453, 53], "kind": "commanddeclaration"}, {"full_name": "le_mul_iff_one_le_right'", "code": "@[to_additive (attr := simp) le_add_iff_nonneg_right]\ntheorem le_mul_iff_one_le_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) {b : \u03b1} :\n    a \u2264 a * b \u2194 1 \u2264 b", "start": [457, 1], "end": [461, 54], "kind": "commanddeclaration"}, {"full_name": "le_mul_iff_one_le_left'", "code": "@[to_additive (attr := simp) le_add_iff_nonneg_left]\ntheorem le_mul_iff_one_le_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a : \u03b1) {b : \u03b1} :\n    a \u2264 b * a \u2194 1 \u2264 b", "start": [465, 1], "end": [469, 55], "kind": "commanddeclaration"}, {"full_name": "mul_le_iff_le_one_right'", "code": "@[to_additive (attr := simp) add_le_iff_nonpos_right]\ntheorem mul_le_iff_le_one_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a : \u03b1) {b : \u03b1} :\n    a * b \u2264 a \u2194 b \u2264 1", "start": [473, 1], "end": [477, 54], "kind": "commanddeclaration"}, {"full_name": "mul_le_iff_le_one_left'", "code": "@[to_additive (attr := simp) add_le_iff_nonpos_left]\ntheorem mul_le_iff_le_one_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} :\n    a * b \u2264 b \u2194 a \u2264 1", "start": [481, 1], "end": [485, 55], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_right'", "code": "@[to_additive lt_add_of_pos_right]\ntheorem lt_mul_of_one_lt_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1} (h : 1 < b) :\n    a < a * b", "start": [495, 1], "end": [500, 38], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_right'", "code": "@[to_additive add_lt_of_neg_right]\ntheorem mul_lt_of_lt_one_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1} (h : b < 1) :\n    a * b < a", "start": [504, 1], "end": [509, 23], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_left'", "code": "@[to_additive lt_add_of_pos_left]\ntheorem lt_mul_of_one_lt_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1}\n    (h : 1 < b) :\n    a < b * a", "start": [513, 1], "end": [519, 39], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_left'", "code": "@[to_additive add_lt_of_neg_left]\ntheorem mul_lt_of_lt_one_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1}\n    (h : b < 1) :\n    b * a < a", "start": [523, 1], "end": [529, 23], "kind": "commanddeclaration"}, {"full_name": "one_lt_of_lt_mul_right", "code": "@[to_additive]\ntheorem one_lt_of_lt_mul_right [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (h : a < a * b) :\n    1 < b", "start": [533, 1], "end": [536, 52], "kind": "commanddeclaration"}, {"full_name": "lt_one_of_mul_lt_right", "code": "@[to_additive]\ntheorem lt_one_of_mul_lt_right [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (h : a * b < a) :\n    b < 1", "start": [540, 1], "end": [543, 52], "kind": "commanddeclaration"}, {"full_name": "one_lt_of_lt_mul_left", "code": "@[to_additive]\ntheorem one_lt_of_lt_mul_left [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1}\n    (h : b < a * b) :\n    1 < a", "start": [547, 1], "end": [551, 53], "kind": "commanddeclaration"}, {"full_name": "lt_one_of_mul_lt_left", "code": "@[to_additive]\ntheorem lt_one_of_mul_lt_left [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1}\n    (h : a * b < b) :\n    a < 1", "start": [555, 1], "end": [559, 53], "kind": "commanddeclaration"}, {"full_name": "lt_mul_iff_one_lt_right'", "code": "@[to_additive (attr := simp) lt_add_iff_pos_right]\ntheorem lt_mul_iff_one_lt_right' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1} :\n    a < a * b \u2194 1 < b", "start": [563, 1], "end": [567, 54], "kind": "commanddeclaration"}, {"full_name": "lt_mul_iff_one_lt_left'", "code": "@[to_additive (attr := simp) lt_add_iff_pos_left]\ntheorem lt_mul_iff_one_lt_left' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) {b : \u03b1} : a < b * a \u2194 1 < b", "start": [571, 1], "end": [574, 55], "kind": "commanddeclaration"}, {"full_name": "mul_lt_iff_lt_one_left'", "code": "@[to_additive (attr := simp) add_lt_iff_neg_left]\ntheorem mul_lt_iff_lt_one_left' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} :\n    a * b < a \u2194 b < 1", "start": [578, 1], "end": [582, 54], "kind": "commanddeclaration"}, {"full_name": "mul_lt_iff_lt_one_right'", "code": "@[to_additive (attr := simp) add_lt_iff_neg_right]\ntheorem mul_lt_iff_lt_one_right' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)]\n    [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a : \u03b1} (b : \u03b1) : a * b < b \u2194 a < 1", "start": [586, 1], "end": [589, 55], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_of_le_one", "code": "@[to_additive]\ntheorem mul_le_of_le_of_le_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b \u2264 c)\n    (ha : a \u2264 1) :\n    b * a \u2264 c", "start": [603, 1], "end": [610, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_of_lt_one", "code": "@[to_additive]\ntheorem mul_lt_of_le_of_lt_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b c : \u03b1} (hbc : b \u2264 c)\n    (ha : a < 1) :\n    b * a < c", "start": [614, 1], "end": [621, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_le_one", "code": "@[to_additive]\ntheorem mul_lt_of_lt_of_le_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : a \u2264 1) :\n    b * a < c", "start": [625, 1], "end": [632, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_lt_one", "code": "@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c", "start": [636, 1], "end": [643, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_lt_one'", "code": "@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c", "start": [647, 1], "end": [651, 35], "kind": "commanddeclaration"}, {"full_name": "Left.mul_le_one", "code": "@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonpos`.\"]\ntheorem Left.mul_le_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : a \u2264 1) (hb : b \u2264 1) :\n    a * b \u2264 1", "start": [655, 1], "end": [661, 31], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_one_of_le_of_lt", "code": "@[to_additive Left.add_neg_of_nonpos_of_neg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_nonpos_of_neg`.\"]\ntheorem Left.mul_lt_one_of_le_of_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : a \u2264 1)\n    (hb : b < 1) :\n    a * b < 1", "start": [665, 1], "end": [673, 31], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_one_of_lt_of_le", "code": "@[to_additive Left.add_neg_of_neg_of_nonpos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_neg_of_nonpos`.\"]\ntheorem Left.mul_lt_one_of_lt_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : a < 1)\n    (hb : b \u2264 1) :\n    a * b < 1", "start": [677, 1], "end": [685, 31], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_one", "code": "@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg`.\"]\ntheorem Left.mul_lt_one [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : a < 1) (hb : b < 1) :\n    a * b < 1", "start": [689, 1], "end": [695, 31], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_one'", "code": "@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg'`.\"]\ntheorem Left.mul_lt_one' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : a < 1) (hb : b < 1) :\n    a * b < 1", "start": [699, 1], "end": [705, 32], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_of_one_le", "code": "@[to_additive]\ntheorem le_mul_of_le_of_one_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b \u2264 c)\n    (ha : 1 \u2264 a) :\n    b \u2264 c * a", "start": [713, 1], "end": [720, 39], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_le_of_one_lt", "code": "@[to_additive]\ntheorem lt_mul_of_le_of_one_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b c : \u03b1} (hbc : b \u2264 c)\n    (ha : 1 < a) :\n    b < c * a", "start": [724, 1], "end": [731, 39], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_le", "code": "@[to_additive]\ntheorem lt_mul_of_lt_of_one_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : 1 \u2264 a) :\n    b < c * a", "start": [735, 1], "end": [742, 39], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_lt", "code": "@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a", "start": [746, 1], "end": [753, 39], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_lt'", "code": "@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a", "start": [757, 1], "end": [761, 35], "kind": "commanddeclaration"}, {"full_name": "Left.one_le_mul", "code": "@[to_additive Left.add_nonneg \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonneg`.\"]\ntheorem Left.one_le_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n    1 \u2264 a * b", "start": [765, 1], "end": [771, 31], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_mul_of_le_of_lt", "code": "@[to_additive Left.add_pos_of_nonneg_of_pos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_nonneg_of_pos`.\"]\ntheorem Left.one_lt_mul_of_le_of_lt [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a)\n    (hb : 1 < b) :\n    1 < a * b", "start": [775, 1], "end": [783, 31], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_mul_of_lt_of_le", "code": "@[to_additive Left.add_pos_of_pos_of_nonneg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_pos_of_nonneg`.\"]\ntheorem Left.one_lt_mul_of_lt_of_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 < a)\n    (hb : 1 \u2264 b) :\n    1 < a * b", "start": [787, 1], "end": [795, 31], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_mul", "code": "@[to_additive Left.add_pos \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos`.\"]\ntheorem Left.one_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b", "start": [799, 1], "end": [805, 31], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_mul'", "code": "@[to_additive Left.add_pos' \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos'`.\"]\ntheorem Left.one_lt_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b", "start": [809, 1], "end": [815, 32], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_of_le", "code": "@[to_additive]\ntheorem mul_le_of_le_one_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : a \u2264 1)\n    (hbc : b \u2264 c) :\n    a * b \u2264 c", "start": [823, 1], "end": [830, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_le", "code": "@[to_additive]\ntheorem mul_lt_of_lt_one_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c : \u03b1} (ha : a < 1)\n    (hbc : b \u2264 c) :\n    a * b < c", "start": [834, 1], "end": [841, 17], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_one_of_lt", "code": "@[to_additive]\ntheorem mul_lt_of_le_one_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : a \u2264 1)\n    (hb : b < c) :\n    a * b < c", "start": [845, 1], "end": [852, 16], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_lt", "code": "@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c : \u03b1} (ha : a < 1)\n    (hb : b < c) :\n    a * b < c", "start": [856, 1], "end": [863, 16], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_lt'", "code": "@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : a < 1)\n    (hbc : b < c) :\n    a * b < c", "start": [867, 1], "end": [871, 35], "kind": "commanddeclaration"}, {"full_name": "Right.mul_le_one", "code": "@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonpos`.\"]\ntheorem Right.mul_le_one [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : a \u2264 1)\n    (hb : b \u2264 1) :\n    a * b \u2264 1", "start": [875, 1], "end": [882, 31], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one_of_lt_of_le", "code": "@[to_additive Right.add_neg_of_neg_of_nonpos\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`.\"]\ntheorem Right.mul_lt_one_of_lt_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1}\n    (ha : a < 1) (hb : b \u2264 1) :\n    a * b < 1", "start": [886, 1], "end": [894, 31], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one_of_le_of_lt", "code": "@[to_additive Right.add_neg_of_nonpos_of_neg\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_nonpos_of_neg`.\"]\ntheorem Right.mul_lt_one_of_le_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1}\n    (ha : a \u2264 1) (hb : b < 1) :\n    a * b < 1", "start": [898, 1], "end": [906, 31], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one", "code": "@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg`.\"]\ntheorem Right.mul_lt_one [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1", "start": [910, 1], "end": [917, 31], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one'", "code": "@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg'`.\"]\ntheorem Right.mul_lt_one' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1", "start": [921, 1], "end": [928, 32], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_of_le", "code": "@[to_additive]\ntheorem le_mul_of_one_le_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : 1 \u2264 a)\n    (hbc : b \u2264 c) :\n    b \u2264 a * c", "start": [936, 1], "end": [943, 40], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_le", "code": "@[to_additive]\ntheorem lt_mul_of_one_lt_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c : \u03b1} (ha : 1 < a)\n    (hbc : b \u2264 c) :\n    b < a * c", "start": [947, 1], "end": [954, 40], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_le_of_lt", "code": "@[to_additive]\ntheorem lt_mul_of_one_le_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : 1 \u2264 a)\n    (hbc : b < c) :\n    b < a * c", "start": [958, 1], "end": [965, 40], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_lt", "code": "@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c : \u03b1} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c", "start": [969, 1], "end": [976, 40], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_lt'", "code": "@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c", "start": [980, 1], "end": [984, 35], "kind": "commanddeclaration"}, {"full_name": "Right.one_le_mul", "code": "@[to_additive Right.add_nonneg \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonneg`.\"]\ntheorem Right.one_le_mul [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a)\n    (hb : 1 \u2264 b) :\n    1 \u2264 a * b", "start": [988, 1], "end": [995, 31], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul_of_lt_of_le", "code": "@[to_additive Right.add_pos_of_pos_of_nonneg\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_pos_of_nonneg`.\"]\ntheorem Right.one_lt_mul_of_lt_of_le [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1}\n    (ha : 1 < a) (hb : 1 \u2264 b) :\n    1 < a * b", "start": [999, 1], "end": [1007, 31], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul_of_le_of_lt", "code": "@[to_additive Right.add_pos_of_nonneg_of_pos\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_nonneg_of_pos`.\"]\ntheorem Right.one_lt_mul_of_le_of_lt [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1}\n    (ha : 1 \u2264 a) (hb : 1 < b) :\n    1 < a * b", "start": [1011, 1], "end": [1019, 31], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul", "code": "@[to_additive Right.add_pos \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos`.\"]\ntheorem Right.one_lt_mul [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b : \u03b1} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b", "start": [1023, 1], "end": [1030, 31], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul'", "code": "@[to_additive Right.add_pos' \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`.\"]\ntheorem Right.one_lt_mul' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b", "start": [1034, 1], "end": [1041, 32], "kind": "commanddeclaration"}, {"full_name": "mul_le_one'", "code": "alias mul_le_one' := Left.mul_le_one", "start": [1045, 1], "end": [1045, 37], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_one_of_le_of_lt", "code": "alias mul_lt_one_of_le_of_lt := Left.mul_lt_one_of_le_of_lt", "start": [1048, 1], "end": [1048, 60], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_one_of_lt_of_le", "code": "alias mul_lt_one_of_lt_of_le := Left.mul_lt_one_of_lt_of_le", "start": [1051, 1], "end": [1051, 60], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_one", "code": "alias mul_lt_one := Left.mul_lt_one", "start": [1054, 1], "end": [1054, 36], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_one'", "code": "alias mul_lt_one' := Left.mul_lt_one'", "start": [1057, 1], "end": [1057, 38], "kind": "stdtacticaliasalias"}, {"full_name": "one_le_mul", "code": "alias one_le_mul := Left.one_le_mul", "start": [1077, 1], "end": [1077, 36], "kind": "stdtacticaliasalias"}, {"full_name": "one_lt_mul_of_le_of_lt'", "code": "alias one_lt_mul_of_le_of_lt' := Left.one_lt_mul_of_le_of_lt", "start": [1080, 1], "end": [1080, 61], "kind": "stdtacticaliasalias"}, {"full_name": "one_lt_mul_of_lt_of_le'", "code": "alias one_lt_mul_of_lt_of_le' := Left.one_lt_mul_of_lt_of_le", "start": [1083, 1], "end": [1083, 61], "kind": "stdtacticaliasalias"}, {"full_name": "one_lt_mul'", "code": "alias one_lt_mul' := Left.one_lt_mul", "start": [1086, 1], "end": [1086, 37], "kind": "stdtacticaliasalias"}, {"full_name": "one_lt_mul''", "code": "alias one_lt_mul'' := Left.one_lt_mul'", "start": [1089, 1], "end": [1089, 39], "kind": "stdtacticaliasalias"}, {"full_name": "lt_of_mul_lt_of_one_le_left", "code": "@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (h : a * b < c)\n    (hle : 1 \u2264 b) :\n    a < c", "start": [1109, 1], "end": [1113, 43], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_of_one_le_left", "code": "@[to_additive]\ntheorem le_of_mul_le_of_one_le_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (h : a * b \u2264 c)\n    (hle : 1 \u2264 b) :\n    a \u2264 c", "start": [1117, 1], "end": [1121, 40], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_mul_of_le_one_left", "code": "@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (h : a < b * c)\n    (hle : c \u2264 1) :\n    a < b", "start": [1125, 1], "end": [1129, 43], "kind": "commanddeclaration"}, {"full_name": "le_of_le_mul_of_le_one_left", "code": "@[to_additive]\ntheorem le_of_le_mul_of_le_one_left [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (h : a \u2264 b * c)\n    (hle : c \u2264 1) :\n    a \u2264 b", "start": [1133, 1], "end": [1137, 40], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_of_one_le_right", "code": "@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (h : a * b < c) (hle : 1 \u2264 a) :\n    b < c", "start": [1141, 1], "end": [1145, 42], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_of_one_le_right", "code": "@[to_additive]\ntheorem le_of_mul_le_of_one_le_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (h : a * b \u2264 c) (hle : 1 \u2264 a) :\n    b \u2264 c", "start": [1149, 1], "end": [1153, 39], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_mul_of_le_one_right", "code": "@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (h : a < b * c) (hle : b \u2264 1) :\n    a < c", "start": [1157, 1], "end": [1161, 42], "kind": "commanddeclaration"}, {"full_name": "le_of_le_mul_of_le_one_right", "code": "@[to_additive]\ntheorem le_of_le_mul_of_le_one_right [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (h : a \u2264 b * c) (hle : b \u2264 1) :\n    a \u2264 c", "start": [1165, 1], "end": [1169, 39], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff'", "code": "@[to_additive]\ntheorem mul_eq_one_iff' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : 1 \u2264 a) (hb : 1 \u2264 b) :\n    a * b = 1 \u2194 a = 1 \u2227 b = 1", "start": [1179, 1], "end": [1190, 41], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_one_le_mul_left", "code": "@[to_additive eq_zero_of_add_nonneg_left]\ntheorem eq_one_of_one_le_mul_left (ha : a \u2264 1) (hb : b \u2264 1) (hab : 1 \u2264 a * b) : a = 1", "start": [1201, 1], "end": [1203, 69], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_mul_le_one_left", "code": "@[to_additive]\ntheorem eq_one_of_mul_le_one_left (ha : 1 \u2264 a) (hb : 1 \u2264 b) (hab : a * b \u2264 1) : a = 1", "start": [1207, 1], "end": [1209, 70], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_one_le_mul_right", "code": "@[to_additive eq_zero_of_add_nonneg_right]\ntheorem eq_one_of_one_le_mul_right (ha : a \u2264 1) (hb : b \u2264 1) (hab : 1 \u2264 a * b) : b = 1", "start": [1219, 1], "end": [1221, 75], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_mul_le_one_right", "code": "@[to_additive]\ntheorem eq_one_of_mul_le_one_right (ha : 1 \u2264 a) (hb : 1 \u2264 b) (hab : a * b \u2264 1) : b = 1", "start": [1225, 1], "end": [1227, 75], "kind": "commanddeclaration"}, {"full_name": "exists_square_le", "code": "theorem exists_square_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] (a : \u03b1) : \u2203 b : \u03b1, b * b \u2264 a", "start": [1239, 1], "end": [1247, 18], "kind": "commanddeclaration"}, {"full_name": "Contravariant.toLeftCancelSemigroup", "code": "@[to_additive\n\"An additive semigroup with a partial order and satisfying `AddLeftCancelSemigroup`\n(i.e. `c + a < c + b \u2192 a < b`) is a `left_cancel AddSemigroup`.\"]\ndef Contravariant.toLeftCancelSemigroup [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n    LeftCancelSemigroup \u03b1 :=\n  { \u2039Semigroup \u03b1\u203a with mul_left_cancel := fun a b c => mul_left_cancel'' }", "start": [1264, 1], "end": [1271, 75], "kind": "commanddeclaration"}, {"full_name": "Contravariant.toRightCancelSemigroup", "code": "@[to_additive\n\"An additive semigroup with a partial order and satisfying `AddRightCancelSemigroup`\n(`a + c < b + c \u2192 a < b`) is a `right_cancel AddSemigroup`.\"]\ndef Contravariant.toRightCancelSemigroup [ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    RightCancelSemigroup \u03b1 :=\n  { \u2039Semigroup \u03b1\u203a with mul_right_cancel := fun a b c => mul_right_cancel'' }", "start": [1277, 1], "end": [1284, 77], "kind": "commanddeclaration"}, {"full_name": "Monotone.const_mul'", "code": "@[to_additive const_add]\ntheorem Monotone.const_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (hf : Monotone f) (a : \u03b1) :\n    Monotone fun x => a * f x", "start": [1303, 1], "end": [1305, 72], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.const_mul'", "code": "@[to_additive const_add]\ntheorem MonotoneOn.const_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (hf : MonotoneOn f s) (a : \u03b1) :\n    MonotoneOn (fun x => a * f x) s", "start": [1309, 1], "end": [1311, 90], "kind": "commanddeclaration"}, {"full_name": "Antitone.const_mul'", "code": "@[to_additive const_add]\ntheorem Antitone.const_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (hf : Antitone f) (a : \u03b1) :\n    Antitone fun x => a * f x", "start": [1315, 1], "end": [1317, 72], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.const_mul'", "code": "@[to_additive const_add]\ntheorem AntitoneOn.const_mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (hf : AntitoneOn f s) (a : \u03b1) :\n    AntitoneOn (fun x => a * f x) s", "start": [1321, 1], "end": [1323, 90], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_const'", "code": "@[to_additive add_const]\ntheorem Monotone.mul_const' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : Monotone f) (a : \u03b1) :\n    Monotone fun x => f x * a", "start": [1327, 1], "end": [1329, 73], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mul_const'", "code": "@[to_additive add_const]\ntheorem MonotoneOn.mul_const' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : MonotoneOn f s)\n    (a : \u03b1) :\n    MonotoneOn (fun x => f x * a) s", "start": [1333, 1], "end": [1336, 91], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul_const'", "code": "@[to_additive add_const]\ntheorem Antitone.mul_const' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : Antitone f) (a : \u03b1) :\n    Antitone fun x => f x * a", "start": [1340, 1], "end": [1342, 73], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mul_const'", "code": "@[to_additive add_const]\ntheorem AntitoneOn.mul_const' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : AntitoneOn f s)\n    (a : \u03b1) :\n    AntitoneOn (fun x => f x * a) s", "start": [1346, 1], "end": [1349, 91], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul'", "code": "@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem Monotone.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x * g x", "start": [1353, 1], "end": [1357, 74], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mul'", "code": "@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem MonotoneOn.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : MonotoneOn f s) (hg : MonotoneOn g s) :\n    MonotoneOn (fun x => f x * g x) s", "start": [1361, 1], "end": [1366, 40], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul'", "code": "@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem Antitone.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x * g x", "start": [1370, 1], "end": [1374, 74], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mul'", "code": "@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem AntitoneOn.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => f x * g x) s", "start": [1378, 1], "end": [1383, 59], "kind": "commanddeclaration"}, {"full_name": "StrictMono.const_mul'", "code": "@[to_additive const_add]\ntheorem StrictMono.const_mul' (hf : StrictMono f) (c : \u03b1) : StrictMono fun x => c * f x", "start": [1391, 1], "end": [1393, 43], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.const_mul'", "code": "@[to_additive const_add]\ntheorem StrictMonoOn.const_mul' (hf : StrictMonoOn f s) (c : \u03b1) :\n    StrictMonoOn (fun x => c * f x) s", "start": [1397, 1], "end": [1400, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.const_mul'", "code": "@[to_additive const_add]\ntheorem StrictAnti.const_mul' (hf : StrictAnti f) (c : \u03b1) : StrictAnti fun x => c * f x", "start": [1404, 1], "end": [1406, 43], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.const_mul'", "code": "@[to_additive const_add]\ntheorem StrictAntiOn.const_mul' (hf : StrictAntiOn f s) (c : \u03b1) :\n    StrictAntiOn (fun x => c * f x) s", "start": [1410, 1], "end": [1413, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul_const'", "code": "@[to_additive add_const]\ntheorem StrictMono.mul_const' (hf : StrictMono f) (c : \u03b1) : StrictMono fun x => f x * c", "start": [1423, 1], "end": [1425, 44], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.mul_const'", "code": "@[to_additive add_const]\ntheorem StrictMonoOn.mul_const' (hf : StrictMonoOn f s) (c : \u03b1) :\n    StrictMonoOn (fun x => f x * c) s", "start": [1429, 1], "end": [1432, 56], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.mul_const'", "code": "@[to_additive add_const]\ntheorem StrictAnti.mul_const' (hf : StrictAnti f) (c : \u03b1) : StrictAnti fun x => f x * c", "start": [1436, 1], "end": [1438, 44], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.mul_const'", "code": "@[to_additive add_const]\ntheorem StrictAntiOn.mul_const' (hf : StrictAntiOn f s) (c : \u03b1) :\n    StrictAntiOn (fun x => f x * c) s", "start": [1442, 1], "end": [1445, 56], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul'", "code": "@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMono.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (hf : StrictMono f) (hg : StrictMono g) :\n    StrictMono fun x => f x * g x", "start": [1451, 1], "end": [1456, 41], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.mul'", "code": "@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMonoOn.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (hf : StrictMonoOn f s) (hg : StrictMonoOn g s) :\n    StrictMonoOn (fun x => f x * g x) s", "start": [1460, 1], "end": [1465, 73], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.mul'", "code": "@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAnti.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (hf : StrictAnti f) (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x", "start": [1469, 1], "end": [1474, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.mul'", "code": "@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAntiOn.mul' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (hf : StrictAntiOn f s) (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s", "start": [1478, 1], "end": [1483, 73], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_strictMono'", "code": "@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem Monotone.mul_strictMono' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f g : \u03b2 \u2192 \u03b1} (hf : Monotone f)\n    (hg : StrictMono g) :\n    StrictMono fun x => f x * g x", "start": [1487, 1], "end": [1494, 55], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.mul_strictMono'", "code": "@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem MonotoneOn.mul_strictMono' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f g : \u03b2 \u2192 \u03b1} (hf : MonotoneOn f s)\n    (hg : StrictMonoOn g s) : StrictMonoOn (fun x => f x * g x) s", "start": [1498, 1], "end": [1504, 73], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul_strictAnti'", "code": "@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem Antitone.mul_strictAnti' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f g : \u03b2 \u2192 \u03b1} (hf : Antitone f)\n    (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x", "start": [1508, 1], "end": [1515, 55], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.mul_strictAnti'", "code": "@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem AntitoneOn.mul_strictAnti' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f g : \u03b2 \u2192 \u03b1} (hf : AntitoneOn f s)\n    (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s", "start": [1519, 1], "end": [1526, 73], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul_monotone'", "code": "@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMono.mul_monotone' (hf : StrictMono f) (hg : Monotone g) :\n    StrictMono fun x => f x * g x", "start": [1532, 1], "end": [1537, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.mul_monotone'", "code": "@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMonoOn.mul_monotone' (hf : StrictMonoOn f s) (hg : MonotoneOn g s) :\n    StrictMonoOn (fun x => f x * g x) s", "start": [1541, 1], "end": [1546, 73], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.mul_antitone'", "code": "@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAnti.mul_antitone' (hf : StrictAnti f) (hg : Antitone g) :\n    StrictAnti fun x => f x * g x", "start": [1550, 1], "end": [1555, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.mul_antitone'", "code": "@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAntiOn.mul_antitone' (hf : StrictAntiOn f s) (hg : AntitoneOn g s) :\n    StrictAntiOn (fun x => f x * g x) s", "start": [1559, 1], "end": [1564, 73], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_left'", "code": "@[to_additive (attr := simp) cmp_add_left]\ntheorem cmp_mul_left' {\u03b1 : Type*} [Mul \u03b1] [LinearOrder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)]\n    (a b c : \u03b1) :\n    cmp (a * b) (a * c) = cmp b c", "start": [1568, 1], "end": [1572, 46], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_right'", "code": "@[to_additive (attr := simp) cmp_add_right]\ntheorem cmp_mul_right' {\u03b1 : Type*} [Mul \u03b1] [LinearOrder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] (a b c : \u03b1) :\n    cmp (a * c) (b * c) = cmp a b", "start": [1576, 1], "end": [1580, 46], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable", "code": "@[to_additive\n\"An element `a : \u03b1` is `AddLECancellable` if `x \u21a6 a + x` is order-reflecting.\nWe will make a separate version of many lemmas that require `[ContravariantClass \u03b1 \u03b1 (+) (\u2264)]` with\n`AddLECancellable` assumptions instead. These lemmas can then be instantiated to specific types,\nlike `ENNReal`, where we can replace the assumption `AddLECancellable x` by `x \u2260 \u221e`. \"]\ndef MulLECancellable [Mul \u03b1] [LE \u03b1] (a : \u03b1) : Prop :=\n  \u2200 \u2983b c\u2984, a * b \u2264 a * c \u2192 b \u2264 c", "start": [1586, 1], "end": [1597, 33], "kind": "commanddeclaration"}, {"full_name": "Contravariant.MulLECancellable", "code": "@[to_additive]\ntheorem Contravariant.MulLECancellable [Mul \u03b1] [LE \u03b1] [ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    {a : \u03b1} :\n    MulLECancellable a", "start": [1601, 1], "end": [1605, 36], "kind": "commanddeclaration"}, {"full_name": "mulLECancellable_one", "code": "@[to_additive]\ntheorem mulLECancellable_one [Monoid \u03b1] [LE \u03b1] : MulLECancellable (1 : \u03b1)", "start": [1609, 1], "end": [1611, 32], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.Injective", "code": "@[to_additive]\nprotected theorem Injective [Mul \u03b1] [PartialOrder \u03b1] {a : \u03b1} (ha : MulLECancellable a) :\n    Injective ((\u00b7 * \u00b7) a)", "start": [1617, 1], "end": [1620, 47], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.inj", "code": "@[to_additive]\nprotected theorem inj [Mul \u03b1] [PartialOrder \u03b1] {a b c : \u03b1} (ha : MulLECancellable a) :\n    a * b = a * c \u2194 b = c", "start": [1624, 1], "end": [1627, 22], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.injective_left", "code": "@[to_additive]\nprotected theorem injective_left [Mul \u03b1] [i : IsSymmOp \u03b1 \u03b1 (\u00b7 * \u00b7)] [PartialOrder \u03b1] {a : \u03b1}\n    (ha : MulLECancellable a) :\n    Injective (\u00b7 * a)", "start": [1631, 1], "end": [1634, 95], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.inj_left", "code": "@[to_additive]\nprotected theorem inj_left [Mul \u03b1] [IsSymmOp \u03b1 \u03b1 (\u00b7 * \u00b7)] [PartialOrder \u03b1] {a b c : \u03b1}\n    (hc : MulLECancellable c) :\n    a * c = b * c \u2194 a = b", "start": [1638, 1], "end": [1642, 27], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.mul_le_mul_iff_left", "code": "@[to_additive]\nprotected theorem mul_le_mul_iff_left [Mul \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1}\n    (ha : MulLECancellable a) : a * b \u2264 a * c \u2194 b \u2264 c", "start": [1648, 1], "end": [1651, 49], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.mul_le_mul_iff_right", "code": "@[to_additive]\nprotected theorem mul_le_mul_iff_right [Mul \u03b1] [i : IsSymmOp \u03b1 \u03b1 (\u00b7 * \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b c : \u03b1} (ha : MulLECancellable a) :\n    b * a \u2264 c * a \u2194 b \u2264 c", "start": [1655, 1], "end": [1658, 86], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.le_mul_iff_one_le_right", "code": "@[to_additive]\nprotected theorem le_mul_iff_one_le_right [MulOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    {a b : \u03b1} (ha : MulLECancellable a) :\n    a \u2264 a * b \u2194 1 \u2264 b", "start": [1662, 1], "end": [1666, 53], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.mul_le_iff_le_one_right", "code": "@[to_additive]\nprotected theorem mul_le_iff_le_one_right [MulOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    {a b : \u03b1} (ha : MulLECancellable a) :\n    a * b \u2264 a \u2194 b \u2264 1", "start": [1670, 1], "end": [1674, 53], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.le_mul_iff_one_le_left", "code": "@[to_additive]\nprotected theorem le_mul_iff_one_le_left [MulOneClass \u03b1] [i : IsSymmOp \u03b1 \u03b1 (\u00b7 * \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : MulLECancellable a) :\n    a \u2264 b * a \u2194 1 \u2264 b", "start": [1678, 1], "end": [1681, 71], "kind": "commanddeclaration"}, {"full_name": "MulLECancellable.mul_le_iff_le_one_left", "code": "@[to_additive]\nprotected theorem mul_le_iff_le_one_left [MulOneClass \u03b1] [i : IsSymmOp \u03b1 \u03b1 (\u00b7 * \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} (ha : MulLECancellable a) :\n    b * a \u2264 a \u2194 b \u2264 1", "start": [1685, 1], "end": [1688, 71], "kind": "commanddeclaration"}, {"full_name": "bit0_mono", "code": "@[deprecated]\ntheorem bit0_mono [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    Monotone (bit0 : \u03b1 \u2192 \u03b1)", "start": [1698, 1], "end": [1700, 59], "kind": "commanddeclaration"}, {"full_name": "bit0_strictMono", "code": "@[deprecated]\ntheorem bit0_strictMono [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] :\n    StrictMono (bit0 : \u03b1 \u2192 \u03b1)", "start": [1703, 1], "end": [1706, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/SolveByElim.lean", "imports": ["Mathlib/Tactic/Relation/Symm.lean", "lake-packages/std/Std/Tactic/LabelAttr.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Sum/Basic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "Mathlib/Tactic/Backtrack.lean"], "premises": [{"full_name": "Mathlib.Tactic.SolveByElim.applyTactics", "code": "def applyTactics (cfg : ApplyConfig := {}) (transparency : TransparencyMode := .default)\n    (lemmas : List Expr) (g : MVarId) : Nondet MetaM (List MVarId) :=\n  (Nondet.ofList lemmas).filterMapM fun e => observing? do\n    withTraceNode `Meta.Tactic.solveByElim (return m!\"{\u00b7.emoji} trying to apply: {e}\") do\n      let goals \u2190 withTransparency transparency (g.apply e cfg)\n      goals.filterM fun g => try g.inferInstance; pure false catch _ => pure true", "start": [23, 1], "end": [43, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.applyFirst", "code": "def applyFirst (cfg : ApplyConfig := {}) (transparency : TransparencyMode := .default)\n    (lemmas : List Expr) (g : MVarId) : MetaM (List MVarId) :=\n  (applyTactics cfg transparency lemmas g).head", "start": [45, 1], "end": [53, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config", "code": "structure Config extends BacktrackConfig, ApplyConfig where\n  \n  transparency : TransparencyMode := .default\n  \n  symm : Bool := true\n  \n  exfalso : Bool := true\n  backtracking : Bool := true", "start": [55, 1], "end": [69, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.ApplyRulesConfig", "code": "structure ApplyRulesConfig extends Config where\n  maxDepth := 50", "start": [73, 1], "end": [75, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.accept", "code": "def accept (cfg : Config := {}) (test : MVarId \u2192 MetaM Bool) : Config :=\n  { cfg with\n    discharge := fun g => do\n      if (\u2190 test g) then\n        pure none\n      else\n        cfg.discharge g }", "start": [93, 1], "end": [100, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.mainGoalProc", "code": "def mainGoalProc (cfg : Config := {}) (proc : MVarId \u2192 MetaM (List MVarId)) : Config :=\n  { cfg with\n    proc := fun orig goals => match goals with\n    | [] => cfg.proc orig []\n    | g :: gs => try\n        return (\u2190 proc g) ++ gs\n      catch _ => cfg.proc orig goals }", "start": [102, 1], "end": [112, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.intros", "code": "def intros (cfg : Config := {}) : Config :=\n  cfg.mainGoalProc fun g => do pure [(\u2190 g.intro1P).2]", "start": [114, 1], "end": [119, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.synthInstance", "code": "def synthInstance (cfg : Config := {}) : Config :=\n  cfg.mainGoalProc fun g => do g.synthInstance; pure []", "start": [121, 1], "end": [126, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.withDischarge", "code": "def withDischarge (cfg : Config := {}) (discharge : MVarId \u2192 MetaM (Option (List MVarId))) :\n    Config :=\n  { cfg with\n    discharge := fun g => try discharge g\n      catch _ => cfg.discharge g }", "start": [128, 1], "end": [134, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.introsAfter", "code": "def introsAfter (cfg : Config := {}) : Config :=\n  cfg.withDischarge fun g => do pure [(\u2190 g.intro1P).2]", "start": [136, 1], "end": [138, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.synthInstanceAfter", "code": "def synthInstanceAfter (cfg : Config := {}) : Config :=\n  cfg.withDischarge fun g => do g.synthInstance; pure (some [])", "start": [140, 1], "end": [143, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.testPartialSolutions", "code": "def testPartialSolutions (cfg : Config := {}) (test : List Expr \u2192 MetaM Bool) : Config :=\n  { cfg with\n    proc := fun orig goals => do\n      let .true \u2190 test (\u2190 orig.mapM fun m => m.withContext do instantiateMVars (.mvar m)) | failure\n      cfg.proc orig goals }", "start": [145, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.testSolutions", "code": "def testSolutions (cfg : Config := {}) (test : List Expr \u2192 MetaM Bool) : Config :=\n  cfg.testPartialSolutions fun sols => do\n    if sols.any Expr.hasMVar then\n      pure true\n    else\n      test sols", "start": [155, 1], "end": [164, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.Config.requireUsingAll", "code": "def requireUsingAll (cfg : Config := {}) (use : List Expr) : Config :=\n  cfg.testSolutions fun sols => do\n    pure <| use.all fun e => sols.any fun s => e.occurs s", "start": [166, 1], "end": [172, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.elabContextLemmas", "code": "def elabContextLemmas (g : MVarId) (lemmas : List (TermElabM Expr)) (ctx : TermElabM (List Expr)) :\n    MetaM (List Expr) := do\n  g.withContext (Elab.Term.TermElabM.run' do pure ((\u2190 ctx) ++ (\u2190 lemmas.mapM id)))", "start": [176, 1], "end": [182, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.applyLemmas", "code": "def applyLemmas (cfg : Config) (lemmas : List (TermElabM Expr)) (ctx : TermElabM (List Expr))\n    (g : MVarId) : Nondet MetaM (List MVarId) := Nondet.squash fun _ => do\n  let g \u2190 if cfg.symm then g.symmSaturate else pure g\n  let es \u2190 elabContextLemmas g lemmas ctx\n  return applyTactics cfg.toApplyConfig cfg.transparency es g", "start": [184, 1], "end": [191, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.applyFirstLemma", "code": "def applyFirstLemma (cfg : Config) (lemmas : List (TermElabM Expr)) (ctx : TermElabM (List Expr))\n    (g : MVarId) : MetaM (List MVarId) := do\nlet g \u2190 if cfg.symm then g.symmSaturate else pure g\nlet es \u2190 elabContextLemmas g lemmas ctx\napplyFirst cfg.toApplyConfig cfg.transparency es g", "start": [193, 1], "end": [200, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.solveByElim", "code": "def solveByElim (cfg : Config) (lemmas : List (TermElabM Expr)) (ctx : TermElabM (List Expr))\n    (goals : List MVarId) : MetaM (List MVarId) := do\n  try\n    run goals\n  catch e => do\n    match goals, cfg.exfalso with\n    | [g], true =>\n      withTraceNode `Meta.Tactic.solveByElim\n          (fun _ => return m!\"\u23ee\ufe0f starting over using `exfalso`\") do\n        run [\u2190 g.exfalso]\n    | _, _ => throw e\nwhere\n  run : List MVarId \u2192 MetaM (List MVarId) := if cfg.backtracking then\n    backtrack cfg `Meta.Tactic.solveByElim (applyLemmas cfg lemmas ctx)\n  else\n    repeat1' (maxIters := cfg.maxDepth) (applyFirstLemma cfg lemmas ctx)", "start": [202, 1], "end": [236, 73], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.applyRules", "code": "def _root_.Lean.MVarId.applyRules (cfg : Config) (lemmas : List (TermElabM Expr))\n    (only : Bool := false) (g : MVarId) : MetaM (List MVarId) := do\n  let ctx : TermElabM (List Expr) := if only then pure [] else do pure (\u2190 getLocalHyps).toList\n  solveByElim { cfg with backtracking := false } lemmas ctx [g]", "start": [238, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.mkAssumptionSet", "code": "def mkAssumptionSet (noDefaults star : Bool) (add remove : List Term) (use : Array Ident) :\n    MetaM (List (TermElabM Expr) \u00d7 TermElabM (List Expr)) := do\n  if star && !noDefaults then\n    throwError \"It doesn't make sense to use `*` without `only`.\"\n\n  let defaults : List (TermElabM Expr) :=\n    [\u2190 `(rfl), \u2190 `(trivial), \u2190 `(congrFun), \u2190 `(congrArg)].map elab'\n  let labelledLemmas := (\u2190 use.mapM (labelled \u00b7.raw.getId)).flatten.toList\n    |>.map (liftM <| mkConstWithFreshMVarLevels \u00b7)\n  let lemmas := if noDefaults then\n    add.map elab' ++ labelledLemmas\n  else\n    add.map elab' ++ labelledLemmas ++ defaults\n\n  if !remove.isEmpty && noDefaults && !star then\n    throwError \"It doesn't make sense to remove local hypotheses when using `only` without `*`.\"\n  let locals : TermElabM (List Expr) := if noDefaults && !star then do\n    pure []\n  else do\n    pure <| (\u2190 getLocalHyps).toList.removeAll (\u2190 remove.mapM elab')\n\n  return (lemmas, locals)\n  where\n  \n  elab' (t : Term) : TermElabM Expr := Elab.Term.elabTerm t.raw none", "start": [255, 1], "end": [327, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.parseArgs", "code": "def parseArgs (s : Option (TSyntax ``args)) :\n    Bool \u00d7 List Term \u00d7 List Term :=\n  let args : Array (TSyntax ``arg) := match s with\n  | some s => match s with\n    | `(args| [$args,*]) => args.getElems\n    | _ => #[]\n  | none => #[]\n  let args : Array (Option (Term \u2295 Term)) := args.map fun t => match t with\n    | `(arg| $_:star) => none\n    | `(arg| - $t:term) => some (Sum.inr t)\n    | `(arg| $t:term) => some (Sum.inl t)\n    | _ => panic! \"Unreachable parse of solve_by_elim arguments.\"\n  let args := args.toList\n  (args.contains none,\n    args.filterMap fun o => o.bind Sum.getLeft?,\n    args.filterMap fun o => o.bind Sum.getRight?)", "start": [342, 1], "end": [363, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.parseUsing", "code": "def parseUsing (s : Option (TSyntax ``using_)) : Array Ident :=\n  match s with\n  | some s => match s with\n    | `(using_ | using $ids,*) => ids.getElems\n    | _ => #[]\n  | none => #[]", "start": [365, 1], "end": [371, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.SolveByElim.solveByElim.processSyntax", "code": "def solveByElim.processSyntax (cfg : Config := {}) (only star : Bool) (add remove : List Term)\n    (use : Array Ident) (goals : List MVarId) : MetaM (List MVarId) := do\n  if !remove.isEmpty && goals.length > 1 then\n    throwError \"Removing local hypotheses is not supported when operating on multiple goals.\"\n  let \u27e8lemmas, ctx\u27e9 \u2190 mkAssumptionSet only star add remove use\n  solveByElim cfg lemmas ctx goals", "start": [413, 1], "end": [420, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/EquivFunctor.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Tactic/Convert.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EquivFunctor", "code": "class EquivFunctor (f : Type u\u2080 \u2192 Type u\u2081) where\n  \n  map : \u2200 {\u03b1 \u03b2}, \u03b1 \u2243 \u03b2 \u2192 f \u03b1 \u2192 f \u03b2\n  \n  map_refl' : \u2200 \u03b1, map (Equiv.refl \u03b1) = @id (f \u03b1) := by rfl\n  \n  map_trans' : \u2200 {\u03b1 \u03b2 \u03b3} (k : \u03b1 \u2243 \u03b2) (h : \u03b2 \u2243 \u03b3), map (k.trans h) = map h \u2218 map k := by rfl", "start": [25, 1], "end": [37, 92], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv", "code": "def mapEquiv : f \u03b1 \u2243 f \u03b2 where\n  toFun := EquivFunctor.map e\n  invFun := EquivFunctor.map e.symm\n  left_inv x := by\n    convert (congr_fun (EquivFunctor.map_trans' e e.symm) x).symm\n    simp\n  right_inv y := by\n    convert (congr_fun (EquivFunctor.map_trans' e.symm e) y).symm\n    simp", "start": [48, 1], "end": [57, 9], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv_apply", "code": "@[simp]\ntheorem mapEquiv_apply (x : f \u03b1) : mapEquiv f e x = EquivFunctor.map e x", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv_symm_apply", "code": "theorem mapEquiv_symm_apply (y : f \u03b2) : (mapEquiv f e).symm y = EquivFunctor.map e.symm y", "start": [65, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv_refl", "code": "@[simp]\ntheorem mapEquiv_refl (\u03b1) : mapEquiv f (Equiv.refl \u03b1) = Equiv.refl (f \u03b1)", "start": [69, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv_symm", "code": "@[simp]\ntheorem mapEquiv_symm : (mapEquiv f e).symm = mapEquiv f e.symm", "start": [74, 1], "end": [76, 38], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv_trans", "code": "@[simp]\ntheorem mapEquiv_trans {\u03b3 : Type u\u2080} (ab : \u03b1 \u2243 \u03b2) (bc : \u03b2 \u2243 \u03b3) :\n    (mapEquiv f ab).trans (mapEquiv f bc) = mapEquiv f (ab.trans bc)", "start": [79, 1], "end": [86, 54], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.ofLawfulFunctor", "code": "instance (priority := 100) ofLawfulFunctor (f : Type u\u2080 \u2192 Type u\u2081) [Functor f] [LawfulFunctor f] :\n    EquivFunctor f where\n  map {\u03b1 \u03b2} e := Functor.map e\n  map_refl' \u03b1 := by\n    ext\n    apply LawfulFunctor.id_map\n  map_trans' {\u03b1 \u03b2 \u03b3} k h := by\n    ext x\n    apply LawfulFunctor.comp_map k h x", "start": [91, 1], "end": [99, 39], "kind": "commanddeclaration"}, {"full_name": "EquivFunctor.mapEquiv.injective", "code": "theorem mapEquiv.injective (f : Type u\u2080 \u2192 Type u\u2081)\n    [Applicative f] [LawfulApplicative f] {\u03b1 \u03b2 : Type u\u2080}\n    (h : \u2200 \u03b3, Function.Injective (pure : \u03b3 \u2192 f \u03b3)) :\n      Function.Injective (@EquivFunctor.mapEquiv f _ \u03b1 \u03b2)", "start": [102, 1], "end": [107, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Embedding/Basic.lean", "imports": ["Mathlib/Data/Option/Basic.lean", "Mathlib/Logic/Equiv/Basic.lean", "Mathlib/Data/Prod/PProd.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Embedding", "code": "structure Embedding (\u03b1 : Sort*) (\u03b2 : Sort*) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  inj' : Injective toFun", "start": [24, 1], "end": [29, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.toEmbedding", "code": "protected def Equiv.toEmbedding : \u03b1 \u21aa \u03b2 :=\n  \u27e8f, f.injective\u27e9", "start": [51, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_toEmbedding", "code": "@[simp]\ntheorem Equiv.coe_toEmbedding : (f.toEmbedding : \u03b1 \u2192 \u03b2) = f", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toEmbedding_apply", "code": "theorem Equiv.toEmbedding_apply (a : \u03b1) : f.toEmbedding a = f a", "start": [73, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.coeEmbedding", "code": "instance Equiv.coeEmbedding : Coe (\u03b1 \u2243 \u03b2) (\u03b1 \u21aa \u03b2) :=\n  \u27e8Equiv.toEmbedding\u27e9", "start": [77, 1], "end": [78, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.coeEmbedding", "code": "@[reducible]\ninstance Equiv.Perm.coeEmbedding : Coe (Equiv.Perm \u03b1) (\u03b1 \u21aa \u03b1) :=\n  Equiv.coeEmbedding", "start": [81, 1], "end": [83, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_injective", "code": "theorem coe_injective {\u03b1 \u03b2} : @Injective (\u03b1 \u21aa \u03b2) (\u03b1 \u2192 \u03b2) (\u03bb f => \u2191f)", "start": [95, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.ext", "code": "@[ext]\ntheorem ext {\u03b1 \u03b2} {f g : Embedding \u03b1 \u03b2} (h : \u2200 x, f x = g x) : f = g", "start": [99, 1], "end": [101, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.ext_iff", "code": "theorem ext_iff {\u03b1 \u03b2} {f g : Embedding \u03b1 \u03b2} : (\u2200 x, f x = g x) \u2194 f = g", "start": [105, 1], "end": [106, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) : toFun f = f", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coeFn_mk", "code": "@[simp]\ntheorem coeFn_mk {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (i) : (@mk _ _ f i : \u03b1 \u2192 \u03b2) = f", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.mk_coe", "code": "@[simp]\ntheorem mk_coe {\u03b1 \u03b2 : Type*} (f : \u03b1 \u21aa \u03b2) (inj) : (\u27e8f, inj\u27e9 : \u03b1 \u21aa \u03b2) = f", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.injective", "code": "protected theorem injective {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) : Injective f", "start": [124, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.apply_eq_iff_eq", "code": "theorem apply_eq_iff_eq {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (x y : \u03b1) : f x = f y \u2194 x = y", "start": [128, 1], "end": [129, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.refl", "code": "@[refl, simps (config := { simpRhs := true })]\nprotected def refl (\u03b1 : Sort*) : \u03b1 \u21aa \u03b1 :=\n  \u27e8id, injective_id\u27e9", "start": [132, 1], "end": [135, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.trans", "code": "@[trans, simps (config := { simpRhs := true })]\nprotected def trans {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u21aa \u03b2) (g : \u03b2 \u21aa \u03b3) : \u03b1 \u21aa \u03b3 :=\n  \u27e8g \u2218 f, g.injective.comp f.injective\u27e9", "start": [139, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.equiv_toEmbedding_trans_symm_toEmbedding", "code": "@[simp]\ntheorem equiv_toEmbedding_trans_symm_toEmbedding {\u03b1 \u03b2 : Sort*} (e : \u03b1 \u2243 \u03b2) :\n    e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _", "start": [148, 1], "end": [152, 7], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.equiv_symm_toEmbedding_trans_toEmbedding", "code": "@[simp]\ntheorem equiv_symm_toEmbedding_trans_toEmbedding {\u03b1 \u03b2 : Sort*} (e : \u03b1 \u2243 \u03b2) :\n    e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _", "start": [155, 1], "end": [159, 7], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.congr", "code": "@[simps! (config := { fullyApplied := false, simpRhs := true })]\nprotected def congr {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {\u03b4 : Sort x} (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b3 \u2243 \u03b4)\n    (f : \u03b1 \u21aa \u03b3) : \u03b2 \u21aa \u03b4 :=\n  (Equiv.toEmbedding e\u2081.symm).trans (f.trans e\u2082.toEmbedding)", "start": [162, 1], "end": [166, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.ofSurjective", "code": "protected noncomputable def ofSurjective {\u03b1 \u03b2} (f : \u03b2 \u2192 \u03b1) (hf : Surjective f) : \u03b1 \u21aa \u03b2 :=\n  \u27e8surjInv hf, injective_surjInv _\u27e9", "start": [170, 1], "end": [172, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.equivOfSurjective", "code": "protected noncomputable def equivOfSurjective {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (hf : Surjective f) : \u03b1 \u2243 \u03b2 :=\n  Equiv.ofBijective f \u27e8f.injective, hf\u27e9", "start": [175, 1], "end": [177, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.ofIsEmpty", "code": "protected def ofIsEmpty {\u03b1 \u03b2} [IsEmpty \u03b1] : \u03b1 \u21aa \u03b2 :=\n  \u27e8isEmptyElim, isEmptyElim\u27e9", "start": [180, 1], "end": [182, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.setValue", "code": "def setValue {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (b : \u03b2) [\u2200 a', Decidable (a' = a)]\n    [\u2200 a', Decidable (f a' = b)] : \u03b1 \u21aa \u03b2 :=\n  \u27e8fun a' => if a' = a then b else if f a' = b then f a else f a', by\n    intro x y (h : ite _ _ _ = ite _ _ _)\n    split_ifs at h with h\u2081 h\u2082 _ _ h\u2085 h\u2086 <;>\n        (try subst b) <;>\n        (try simp only [f.injective.eq_iff] at *)\n    \u00b7 rw[h\u2081,h\u2082]\n    \u00b7 rw[h\u2081,h]\n    \u00b7 rw[h\u2085,\u2190h]\n    \u00b7 exact h\u2086.symm\n    \u00b7 exfalso; exact h\u2085 h.symm\n    \u00b7 exfalso; exact h\u2081 h\n    \u00b7 exact h \u27e9", "start": [185, 1], "end": [202, 16], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.setValue_eq", "code": "theorem setValue_eq {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (b : \u03b2) [\u2200 a', Decidable (a' = a)]\n    [\u2200 a', Decidable (f a' = b)] : setValue f a b a = b", "start": [205, 1], "end": [207, 18], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.some", "code": "@[simps (config := { fullyApplied := false })]\nprotected def some {\u03b1} : \u03b1 \u21aa Option \u03b1 :=\n  \u27e8some, Option.some_injective \u03b1\u27e9", "start": [210, 1], "end": [213, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.optionMap", "code": "@[simps (config := { fullyApplied := false })]\ndef optionMap {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) : Option \u03b1 \u21aa Option \u03b2 :=\n  \u27e8Option.map f, Option.map_injective f.injective\u27e9", "start": [221, 1], "end": [224, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.subtype", "code": "def subtype {\u03b1} (p : \u03b1 \u2192 Prop) : Subtype p \u21aa \u03b1 :=\n  \u27e8Subtype.val, fun _ _ => Subtype.ext\u27e9", "start": [228, 1], "end": [230, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_subtype", "code": "@[simp]\ntheorem coe_subtype {\u03b1} (p : \u03b1 \u2192 Prop) : \u2191(subtype p) = Subtype.val", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.quotientOut", "code": "noncomputable def quotientOut (\u03b1) [s : Setoid \u03b1] : Quotient s \u21aa \u03b1 :=\n  \u27e8_, Quotient.out_injective\u27e9", "start": [238, 1], "end": [240, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_quotientOut", "code": "@[simp]\ntheorem coe_quotientOut (\u03b1) [Setoid \u03b1] : \u2191(quotientOut \u03b1) = Quotient.out", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.punit", "code": "def punit {\u03b2 : Sort*} (b : \u03b2) : PUnit \u21aa \u03b2 :=\n  \u27e8fun _ => b, by\n    rintro \u27e8\u27e9 \u27e8\u27e9 _\n    rfl\u27e9", "start": [248, 1], "end": [252, 9], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sectl", "code": "@[simps]\ndef sectl (\u03b1 : Sort _) {\u03b2 : Sort _} (b : \u03b2) : \u03b1 \u21aa \u03b1 \u00d7 \u03b2 :=\n  \u27e8fun a => (a, b), fun _ _ h => congr_arg Prod.fst h\u27e9", "start": [255, 1], "end": [258, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sectr", "code": "@[simps]\ndef sectr {\u03b1 : Sort _} (a : \u03b1) (\u03b2 : Sort _) : \u03b2 \u21aa \u03b1 \u00d7 \u03b2 :=\n  \u27e8fun b => (a, b), fun _ _ h => congr_arg Prod.snd h\u27e9", "start": [262, 1], "end": [265, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.prodMap", "code": "def prodMap {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (e\u2081 : \u03b1 \u21aa \u03b2) (e\u2082 : \u03b3 \u21aa \u03b4) : \u03b1 \u00d7 \u03b3 \u21aa \u03b2 \u00d7 \u03b4 :=\n  \u27e8Prod.map e\u2081 e\u2082, e\u2081.injective.Prod_map e\u2082.injective\u27e9", "start": [269, 1], "end": [271, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_prodMap", "code": "@[simp]\ntheorem coe_prodMap {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (e\u2081 : \u03b1 \u21aa \u03b2) (e\u2082 : \u03b3 \u21aa \u03b4) :\n    e\u2081.prodMap e\u2082 = Prod.map e\u2081 e\u2082", "start": [274, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.pprodMap", "code": "def pprodMap {\u03b1 \u03b2 \u03b3 \u03b4 : Sort*} (e\u2081 : \u03b1 \u21aa \u03b2) (e\u2082 : \u03b3 \u21aa \u03b4) : PProd \u03b1 \u03b3 \u21aa PProd \u03b2 \u03b4 :=\n  \u27e8fun x => \u27e8e\u2081 x.1, e\u2082 x.2\u27e9, e\u2081.injective.pprod_map e\u2082.injective\u27e9", "start": [280, 1], "end": [282, 67], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sumMap", "code": "def sumMap {\u03b1 \u03b2 \u03b3 \u03b4 : Type*} (e\u2081 : \u03b1 \u21aa \u03b2) (e\u2082 : \u03b3 \u21aa \u03b4) : Sum \u03b1 \u03b3 \u21aa Sum \u03b2 \u03b4 :=\n  \u27e8Sum.map e\u2081 e\u2082, e\u2081.injective.sum_map e\u2082.injective\u27e9", "start": [289, 1], "end": [291, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.coe_sumMap", "code": "@[simp]\ntheorem coe_sumMap {\u03b1 \u03b2 \u03b3 \u03b4} (e\u2081 : \u03b1 \u21aa \u03b2) (e\u2082 : \u03b3 \u21aa \u03b4) : sumMap e\u2081 e\u2082 = Sum.map e\u2081 e\u2082", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.inl", "code": "@[simps]\ndef inl {\u03b1 \u03b2 : Type*} : \u03b1 \u21aa Sum \u03b1 \u03b2 :=\n  \u27e8Sum.inl, fun _ _ => Sum.inl.inj\u27e9", "start": [299, 1], "end": [302, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.inr", "code": "@[simps]\ndef inr {\u03b1 \u03b2 : Type*} : \u03b2 \u21aa Sum \u03b1 \u03b2 :=\n  \u27e8Sum.inr, fun _ _ => Sum.inr.inj\u27e9", "start": [306, 1], "end": [309, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sigmaMk", "code": "@[simps apply]\ndef sigmaMk (a : \u03b1) : \u03b2 a \u21aa \u03a3x, \u03b2 x :=\n  \u27e8Sigma.mk a, sigma_mk_injective\u27e9", "start": [319, 1], "end": [322, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sigmaMap", "code": "@[simps apply]\ndef sigmaMap (f : \u03b1 \u21aa \u03b1') (g : \u2200 a, \u03b2 a \u21aa \u03b2' (f a)) : (\u03a3a, \u03b2 a) \u21aa \u03a3a', \u03b2' a' :=\n  \u27e8Sigma.map f fun a => g a, f.injective.sigma_map fun a => (g a).injective\u27e9", "start": [326, 1], "end": [330, 77], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.piCongrRight", "code": "@[simps]\ndef piCongrRight {\u03b1 : Sort*} {\u03b2 \u03b3 : \u03b1 \u2192 Sort*} (e : \u2200 a, \u03b2 a \u21aa \u03b3 a) : (\u2200 a, \u03b2 a) \u21aa \u2200 a, \u03b3 a :=\n  \u27e8fun f a => e a (f a), fun _ _ h => funext fun a => (e a).injective (congr_fun h a)\u27e9", "start": [336, 1], "end": [340, 87], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.arrowCongrRight", "code": "def arrowCongrRight {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} (e : \u03b1 \u21aa \u03b2) : (\u03b3 \u2192 \u03b1) \u21aa \u03b3 \u2192 \u03b2 :=\n  piCongrRight fun _ => e", "start": [344, 1], "end": [347, 26], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.arrowCongrRight_apply", "code": "@[simp]\ntheorem arrowCongrRight_apply {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} (e : \u03b1 \u21aa \u03b2) (f : \u03b3 \u21aa \u03b1) :\n    arrowCongrRight e f = e \u2218 f", "start": [350, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.arrowCongrLeft", "code": "noncomputable def arrowCongrLeft {\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} [Inhabited \u03b3] (e : \u03b1 \u21aa \u03b2) :\n    (\u03b1 \u2192 \u03b3) \u21aa \u03b2 \u2192 \u03b3 :=\n  \u27e8fun f => extend e f default, fun f\u2081 f\u2082 h =>\n    funext fun x => by simpa only [e.injective.extend_apply] using congr_fun h (e x)\u27e9", "start": [356, 1], "end": [362, 86], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.subtypeMap", "code": "protected def subtypeMap {\u03b1 \u03b2} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u21aa \u03b2)\n    (h : \u2200 \u2983x\u2984, p x \u2192 q (f x)) :\n    { x : \u03b1 // p x } \u21aa { y : \u03b2 // q y } :=\n  \u27e8Subtype.map f h, Subtype.map_injective h f.2\u27e9", "start": [365, 1], "end": [369, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.swap_apply", "code": "theorem swap_apply {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u21aa \u03b2) (x y z : \u03b1) :\n    Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z)", "start": [374, 1], "end": [376, 31], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.swap_comp", "code": "theorem swap_comp {\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u21aa \u03b2) (x y : \u03b1) :\n    Equiv.swap (f x) (f y) \u2218 f = f \u2218 Equiv.swap x y", "start": [379, 1], "end": [381, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.asEmbedding", "code": "@[simps!]\ndef asEmbedding {p : \u03b2 \u2192 Prop} (e : \u03b1 \u2243 Subtype p) : \u03b1 \u21aa \u03b2 :=\n  e.toEmbedding.trans (subtype p)", "start": [392, 1], "end": [396, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.subtypeInjectiveEquivEmbedding", "code": "def subtypeInjectiveEquivEmbedding (\u03b1 \u03b2 : Sort*) :\n    { f : \u03b1 \u2192 \u03b2 // Injective f } \u2243 (\u03b1 \u21aa \u03b2) where\n  toFun f := \u27e8f.val, f.property\u27e9\n  invFun f := \u27e8f, f.injective\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [400, 1], "end": [407, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.embeddingCongr", "code": "@[simps apply]\ndef embeddingCongr {\u03b1 \u03b2 \u03b3 \u03b4 : Sort*} (h : \u03b1 \u2243 \u03b2) (h' : \u03b3 \u2243 \u03b4) : (\u03b1 \u21aa \u03b3) \u2243 (\u03b2 \u21aa \u03b4) where\n  toFun f := f.congr h h'\n  invFun f := f.congr h.symm h'.symm\n  left_inv x := by\n    ext\n    simp\n  right_inv x := by\n    ext\n    simp", "start": [411, 1], "end": [422, 9], "kind": "commanddeclaration"}, {"full_name": "Equiv.embeddingCongr_refl", "code": "@[simp]\ntheorem embeddingCongr_refl {\u03b1 \u03b2 : Sort*} :\n    embeddingCongr (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u21aa \u03b2)", "start": [426, 1], "end": [429, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.embeddingCongr_trans", "code": "@[simp]\ntheorem embeddingCongr_trans {\u03b1\u2081 \u03b2\u2081 \u03b1\u2082 \u03b2\u2082 \u03b1\u2083 \u03b2\u2083 : Sort*} (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2081' : \u03b2\u2081 \u2243 \u03b2\u2082)\n    (e\u2082 : \u03b1\u2082 \u2243 \u03b1\u2083) (e\u2082' : \u03b2\u2082 \u2243 \u03b2\u2083) :\n    embeddingCongr (e\u2081.trans e\u2082) (e\u2081'.trans e\u2082') =\n      (embeddingCongr e\u2081 e\u2081').trans (embeddingCongr e\u2082 e\u2082')", "start": [432, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.embeddingCongr_symm", "code": "@[simp]\ntheorem embeddingCongr_symm {\u03b1\u2081 \u03b2\u2081 \u03b1\u2082 \u03b2\u2082 : Sort*} (e\u2081 : \u03b1\u2081 \u2243 \u03b1\u2082) (e\u2082 : \u03b2\u2081 \u2243 \u03b2\u2082) :\n    (embeddingCongr e\u2081 e\u2082).symm = embeddingCongr e\u2081.symm e\u2082.symm", "start": [440, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.embeddingCongr_apply_trans", "code": "theorem embeddingCongr_apply_trans {\u03b1\u2081 \u03b2\u2081 \u03b3\u2081 \u03b1\u2082 \u03b2\u2082 \u03b3\u2082 : Sort*} (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082)\n    (ec : \u03b3\u2081 \u2243 \u03b3\u2082) (f : \u03b1\u2081 \u21aa \u03b2\u2081) (g : \u03b2\u2081 \u21aa \u03b3\u2081) :\n    Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g)", "start": [446, 1], "end": [451, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.refl_toEmbedding", "code": "@[simp]\ntheorem refl_toEmbedding {\u03b1 : Type*} : (Equiv.refl \u03b1).toEmbedding = Embedding.refl \u03b1", "start": [454, 1], "end": [456, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.trans_toEmbedding", "code": "@[simp]\ntheorem trans_toEmbedding {\u03b1 \u03b2 \u03b3 : Type*} (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2243 \u03b3) :\n    (e.trans f).toEmbedding = e.toEmbedding.trans f.toEmbedding", "start": [459, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "subtypeOrLeftEmbedding", "code": "def subtypeOrLeftEmbedding (p q : \u03b1 \u2192 Prop) [DecidablePred p] :\n    { x // p x \u2228 q x } \u21aa Sum { x // p x } { x // q x } :=\n  \u27e8fun x => if h : p x then Sum.inl \u27e8x, h\u27e9 else Sum.inr \u27e8x, x.prop.resolve_left h\u27e9, by\n    intro x y\n    dsimp only\n    split_ifs <;> simp [Subtype.ext_iff]\u27e9", "start": [471, 1], "end": [478, 42], "kind": "commanddeclaration"}, {"full_name": "subtypeOrLeftEmbedding_apply_left", "code": "theorem subtypeOrLeftEmbedding_apply_left {p q : \u03b1 \u2192 Prop} [DecidablePred p]\n    (x : { x // p x \u2228 q x }) (hx : p x) :\n    subtypeOrLeftEmbedding p q x = Sum.inl \u27e8x, hx\u27e9", "start": [481, 1], "end": [484, 13], "kind": "commanddeclaration"}, {"full_name": "subtypeOrLeftEmbedding_apply_right", "code": "theorem subtypeOrLeftEmbedding_apply_right {p q : \u03b1 \u2192 Prop} [DecidablePred p]\n    (x : { x // p x \u2228 q x }) (hx : \u00acp x) :\n    subtypeOrLeftEmbedding p q x = Sum.inr \u27e8x, x.prop.resolve_left hx\u27e9", "start": [487, 1], "end": [490, 13], "kind": "commanddeclaration"}, {"full_name": "Subtype.impEmbedding", "code": "@[simps]\ndef Subtype.impEmbedding (p q : \u03b1 \u2192 Prop) (h : \u2200 x, p x \u2192 q x) : { x // p x } \u21aa { x // q x } :=\n  \u27e8fun x => \u27e8x, h x x.prop\u27e9, fun x y => by simp [Subtype.ext_iff]\u27e9", "start": [493, 1], "end": [497, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/NeZero.lean", "imports": ["Mathlib/Init/Order/Defs.lean", "Mathlib/Init/ZeroOne.lean", "Mathlib/Logic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NeZero", "code": "class NeZero (n : R) : Prop where\n  \n  out : n \u2260 0", "start": [24, 1], "end": [27, 14], "kind": "commanddeclaration"}, {"full_name": "NeZero.ne", "code": "theorem NeZero.ne (n : R) [h : NeZero n] : n \u2260 0", "start": [30, 1], "end": [31, 8], "kind": "commanddeclaration"}, {"full_name": "NeZero.ne'", "code": "theorem NeZero.ne' (n : R) [h : NeZero n] : 0 \u2260 n", "start": [34, 1], "end": [35, 13], "kind": "commanddeclaration"}, {"full_name": "neZero_iff", "code": "theorem neZero_iff {n : R} : NeZero n \u2194 n \u2260 0", "start": [38, 1], "end": [39, 29], "kind": "commanddeclaration"}, {"full_name": "not_neZero", "code": "theorem not_neZero {n : R} : \u00acNeZero n \u2194 n = 0", "start": [42, 1], "end": [42, 71], "kind": "commanddeclaration"}, {"full_name": "eq_zero_or_neZero", "code": "theorem eq_zero_or_neZero (a : R) : a = 0 \u2228 NeZero a", "start": [45, 1], "end": [46, 37], "kind": "commanddeclaration"}, {"full_name": "zero_ne_one", "code": "@[simp] lemma zero_ne_one [One \u03b1] [NeZero (1 : \u03b1)] : (0 : \u03b1) \u2260 1 := NeZero.ne' (1 : \u03b1)", "start": [52, 1], "end": [52, 87], "kind": "mathlibtacticlemma"}, {"full_name": "one_ne_zero", "code": "@[simp] lemma one_ne_zero [One \u03b1] [NeZero (1 : \u03b1)] : (1 : \u03b1) \u2260 0 := NeZero.ne (1 : \u03b1)", "start": [55, 1], "end": [55, 86], "kind": "mathlibtacticlemma"}, {"full_name": "ne_zero_of_eq_one", "code": "lemma ne_zero_of_eq_one [One \u03b1] [NeZero (1 : \u03b1)] {a : \u03b1} (h : a = 1) : a \u2260 0 := h \u25b8 one_ne_zero", "start": [58, 1], "end": [58, 96], "kind": "mathlibtacticlemma"}, {"full_name": "two_ne_zero", "code": "@[field_simps]\nlemma two_ne_zero [OfNat \u03b1 2] [NeZero (2 : \u03b1)] : (2 : \u03b1) \u2260 0 := NeZero.ne (2 : \u03b1)", "start": [61, 1], "end": [62, 82], "kind": "mathlibtacticlemma"}, {"full_name": "three_ne_zero", "code": "@[field_simps]\nlemma three_ne_zero [OfNat \u03b1 3] [NeZero (3 : \u03b1)] : (3 : \u03b1) \u2260 0 := NeZero.ne (3 : \u03b1)", "start": [65, 1], "end": [66, 84], "kind": "mathlibtacticlemma"}, {"full_name": "four_ne_zero", "code": "@[field_simps]\nlemma four_ne_zero [OfNat \u03b1 4] [NeZero (4 : \u03b1)] : (4 : \u03b1) \u2260 0 := NeZero.ne (4 : \u03b1)", "start": [69, 1], "end": [70, 83], "kind": "mathlibtacticlemma"}, {"full_name": "zero_ne_one'", "code": "lemma zero_ne_one' [One \u03b1] [NeZero (1 : \u03b1)] : (0 : \u03b1) \u2260 1 := zero_ne_one", "start": [75, 1], "end": [75, 73], "kind": "mathlibtacticlemma"}, {"full_name": "one_ne_zero'", "code": "lemma one_ne_zero' [One \u03b1] [NeZero (1 : \u03b1)] : (1 : \u03b1) \u2260 0 := one_ne_zero", "start": [78, 1], "end": [78, 73], "kind": "mathlibtacticlemma"}, {"full_name": "two_ne_zero'", "code": "lemma two_ne_zero' [OfNat \u03b1 2] [NeZero (2 : \u03b1)] : (2 : \u03b1) \u2260 0 := two_ne_zero", "start": [81, 1], "end": [81, 77], "kind": "mathlibtacticlemma"}, {"full_name": "three_ne_zero'", "code": "lemma three_ne_zero' [OfNat \u03b1 3] [NeZero (3 : \u03b1)] : (3 : \u03b1) \u2260 0 := three_ne_zero", "start": [84, 1], "end": [84, 81], "kind": "mathlibtacticlemma"}, {"full_name": "four_ne_zero'", "code": "lemma four_ne_zero' [OfNat \u03b1 4] [NeZero (4 : \u03b1)] : (4 : \u03b1) \u2260 0 := four_ne_zero", "start": [87, 1], "end": [87, 79], "kind": "mathlibtacticlemma"}, {"full_name": "NeZero.succ", "code": "instance succ {n : \u2115} : NeZero (n + 1) := \u27e8n.succ_ne_zero\u27e9", "start": [96, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_pos", "code": "theorem of_pos [Preorder M] [Zero M] (h : 0 < x) : NeZero x", "start": [98, 1], "end": [98, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Defs.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Data/Int/Cast/Defs.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Algebra/Group/Defs.lean"], "premises": [{"full_name": "Distrib", "code": "class Distrib (R : Type*) extends Mul R, Add R where\n  \n  protected left_distrib : \u2200 a b c : R, a * (b + c) = a * b + a * c\n  \n  protected right_distrib : \u2200 a b c : R, (a + b) * c = a * c + b * c", "start": [46, 1], "end": [52, 69], "kind": "commanddeclaration"}, {"full_name": "LeftDistribClass", "code": "class LeftDistribClass (R : Type*) [Mul R] [Add R] : Prop where\n  \n  protected left_distrib : \u2200 a b c : R, a * (b + c) = a * b + a * c", "start": [55, 1], "end": [58, 68], "kind": "commanddeclaration"}, {"full_name": "RightDistribClass", "code": "class RightDistribClass (R : Type*) [Mul R] [Add R] : Prop where\n  \n  protected right_distrib : \u2200 a b c : R, (a + b) * c = a * c + b * c", "start": [61, 1], "end": [64, 69], "kind": "commanddeclaration"}, {"full_name": "Distrib.leftDistribClass", "code": "instance (priority := 100) Distrib.leftDistribClass (R : Type*) [Distrib R] : LeftDistribClass R :=\n  \u27e8Distrib.left_distrib\u27e9", "start": [68, 1], "end": [69, 25], "kind": "commanddeclaration"}, {"full_name": "Distrib.rightDistribClass", "code": "instance (priority := 100) Distrib.rightDistribClass (R : Type*) [Distrib R] :\n    RightDistribClass R :=\n  \u27e8Distrib.right_distrib\u27e9", "start": [73, 1], "end": [75, 26], "kind": "commanddeclaration"}, {"full_name": "left_distrib", "code": "theorem left_distrib [Mul R] [Add R] [LeftDistribClass R] (a b c : R) :\n    a * (b + c) = a * b + a * c", "start": [78, 1], "end": [80, 38], "kind": "commanddeclaration"}, {"full_name": "mul_add", "code": "alias mul_add := left_distrib", "start": [83, 1], "end": [83, 30], "kind": "stdtacticaliasalias"}, {"full_name": "right_distrib", "code": "theorem right_distrib [Mul R] [Add R] [RightDistribClass R] (a b c : R) :\n    (a + b) * c = a * c + b * c", "start": [86, 1], "end": [88, 40], "kind": "commanddeclaration"}, {"full_name": "add_mul", "code": "alias add_mul := right_distrib", "start": [91, 1], "end": [91, 31], "kind": "stdtacticaliasalias"}, {"full_name": "distrib_three_right", "code": "theorem distrib_three_right [Mul R] [Add R] [RightDistribClass R] (a b c d : R) :\n    (a + b + c) * d = a * d + b * d + c * d", "start": [94, 1], "end": [95, 71], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocSemiring", "code": "class NonUnitalNonAssocSemiring (\u03b1 : Type u) extends AddCommMonoid \u03b1, Distrib \u03b1, MulZeroClass \u03b1", "start": [112, 1], "end": [113, 96], "kind": "commanddeclaration"}, {"full_name": "NonUnitalSemiring", "code": "class NonUnitalSemiring (\u03b1 : Type u) extends NonUnitalNonAssocSemiring \u03b1, SemigroupWithZero \u03b1", "start": [116, 1], "end": [117, 94], "kind": "commanddeclaration"}, {"full_name": "NonAssocSemiring", "code": "class NonAssocSemiring (\u03b1 : Type u) extends NonUnitalNonAssocSemiring \u03b1, MulZeroOneClass \u03b1,\n    AddCommMonoidWithOne \u03b1", "start": [120, 1], "end": [122, 27], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocRing", "code": "class NonUnitalNonAssocRing (\u03b1 : Type u) extends AddCommGroup \u03b1, NonUnitalNonAssocSemiring \u03b1", "start": [125, 1], "end": [126, 93], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRing", "code": "class NonUnitalRing (\u03b1 : Type*) extends NonUnitalNonAssocRing \u03b1, NonUnitalSemiring \u03b1", "start": [131, 1], "end": [132, 85], "kind": "commanddeclaration"}, {"full_name": "NonAssocRing", "code": "class NonAssocRing (\u03b1 : Type*) extends NonUnitalNonAssocRing \u03b1, NonAssocSemiring \u03b1,\n    AddCommGroupWithOne \u03b1", "start": [135, 1], "end": [137, 26], "kind": "commanddeclaration"}, {"full_name": "Semiring", "code": "class Semiring (\u03b1 : Type u) extends NonUnitalSemiring \u03b1, NonAssocSemiring \u03b1, MonoidWithZero \u03b1", "start": [140, 1], "end": [140, 94], "kind": "commanddeclaration"}, {"full_name": "Ring", "code": "class Ring (R : Type u) extends Semiring R, AddCommGroup R, AddGroupWithOne R", "start": [143, 1], "end": [143, 78], "kind": "commanddeclaration"}, {"full_name": "add_one_mul", "code": "theorem add_one_mul [RightDistribClass \u03b1] (a b : \u03b1) : (a + 1) * b = a * b + b", "start": [154, 1], "end": [155, 24], "kind": "commanddeclaration"}, {"full_name": "mul_add_one", "code": "theorem mul_add_one [LeftDistribClass \u03b1] (a b : \u03b1) : a * (b + 1) = a * b + a", "start": [158, 1], "end": [159, 24], "kind": "commanddeclaration"}, {"full_name": "one_add_mul", "code": "theorem one_add_mul [RightDistribClass \u03b1] (a b : \u03b1) : (1 + a) * b = b + a * b", "start": [162, 1], "end": [163, 24], "kind": "commanddeclaration"}, {"full_name": "mul_one_add", "code": "theorem mul_one_add [LeftDistribClass \u03b1] (a b : \u03b1) : a * (1 + b) = a + a * b", "start": [166, 1], "end": [167, 24], "kind": "commanddeclaration"}, {"full_name": "two_mul", "code": "theorem two_mul (n : \u03b1) : 2 * n = n + n", "start": [177, 1], "end": [178, 99], "kind": "commanddeclaration"}, {"full_name": "bit0_eq_two_mul", "code": "theorem bit0_eq_two_mul (n : \u03b1) : bit0 n = 2 * n", "start": [183, 1], "end": [184, 19], "kind": "commanddeclaration"}, {"full_name": "mul_two", "code": "theorem mul_two (n : \u03b1) : n * 2 = n + n", "start": [188, 1], "end": [189, 98], "kind": "commanddeclaration"}, {"full_name": "mul_ite", "code": "@[to_additive]\ntheorem mul_ite {\u03b1} [Mul \u03b1] (P : Prop) [Decidable P] (a b c : \u03b1) :\n    (a * if P then b else c) = if P then a * b else a * c", "start": [194, 1], "end": [196, 82], "kind": "commanddeclaration"}, {"full_name": "ite_mul", "code": "@[to_additive]\ntheorem ite_mul {\u03b1} [Mul \u03b1] (P : Prop) [Decidable P] (a b c : \u03b1) :\n    (if P then a else b) * c = if P then a * c else b * c", "start": [200, 1], "end": [202, 82], "kind": "commanddeclaration"}, {"full_name": "mul_boole", "code": "theorem mul_boole {\u03b1} [MulZeroOneClass \u03b1] (P : Prop) [Decidable P] (a : \u03b1) :\n    (a * if P then 1 else 0) = if P then a else 0", "start": [217, 1], "end": [218, 61], "kind": "commanddeclaration"}, {"full_name": "boole_mul", "code": "theorem boole_mul {\u03b1} [MulZeroOneClass \u03b1] (P : Prop) [Decidable P] (a : \u03b1) :\n    (if P then 1 else 0) * a = if P then a else 0", "start": [222, 1], "end": [223, 61], "kind": "commanddeclaration"}, {"full_name": "ite_mul_zero_left", "code": "theorem ite_mul_zero_left {\u03b1 : Type*} [MulZeroClass \u03b1] (P : Prop) [Decidable P] (a b : \u03b1) :\n    ite P (a * b) 0 = ite P a 0 * b", "start": [226, 1], "end": [227, 70], "kind": "commanddeclaration"}, {"full_name": "ite_mul_zero_right", "code": "theorem ite_mul_zero_right {\u03b1 : Type*} [MulZeroClass \u03b1] (P : Prop) [Decidable P] (a b : \u03b1) :\n    ite P (a * b) 0 = a * ite P b 0", "start": [230, 1], "end": [231, 70], "kind": "commanddeclaration"}, {"full_name": "ite_and_mul_zero", "code": "theorem ite_and_mul_zero {\u03b1 : Type*} [MulZeroClass \u03b1] (P Q : Prop) [Decidable P] [Decidable Q]\n    (a b : \u03b1) : ite (P \u2227 Q) (a * b) 0 = ite P a 0 * ite Q b 0", "start": [234, 1], "end": [236, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalCommSemiring", "code": "class NonUnitalCommSemiring (\u03b1 : Type u) extends NonUnitalSemiring \u03b1, CommSemigroup \u03b1", "start": [239, 1], "end": [243, 86], "kind": "commanddeclaration"}, {"full_name": "CommSemiring", "code": "class CommSemiring (R : Type u) extends Semiring R, CommMonoid R", "start": [246, 1], "end": [246, 65], "kind": "commanddeclaration"}, {"full_name": "CommSemiring.toNonUnitalCommSemiring", "code": "instance (priority := 100) CommSemiring.toNonUnitalCommSemiring [CommSemiring \u03b1] :\n    NonUnitalCommSemiring \u03b1 :=\n  { inferInstanceAs (CommMonoid \u03b1), inferInstanceAs (CommSemiring \u03b1) with }", "start": [250, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "CommSemiring.toCommMonoidWithZero", "code": "instance (priority := 100) CommSemiring.toCommMonoidWithZero [CommSemiring \u03b1] :\n    CommMonoidWithZero \u03b1 :=\n  { inferInstanceAs (CommMonoid \u03b1), inferInstanceAs (CommSemiring \u03b1) with }", "start": [256, 1], "end": [258, 76], "kind": "commanddeclaration"}, {"full_name": "add_mul_self_eq", "code": "theorem add_mul_self_eq (a b : \u03b1) : (a + b) * (a + b) = a * a + 2 * a * b + b * b", "start": [265, 1], "end": [266, 63], "kind": "commanddeclaration"}, {"full_name": "HasDistribNeg", "code": "class HasDistribNeg (\u03b1 : Type*) [Mul \u03b1] extends InvolutiveNeg \u03b1 where\n  \n  neg_mul : \u2200 x y : \u03b1, -x * y = -(x * y)\n  \n  mul_neg : \u2200 x y : \u03b1, x * -y = -(x * y)", "start": [273, 1], "end": [281, 41], "kind": "commanddeclaration"}, {"full_name": "neg_mul", "code": "@[simp]\ntheorem neg_mul (a b : \u03b1) : -a * b = -(a * b)", "start": [288, 1], "end": [290, 28], "kind": "commanddeclaration"}, {"full_name": "mul_neg", "code": "@[simp]\ntheorem mul_neg (a b : \u03b1) : a * -b = -(a * b)", "start": [293, 1], "end": [295, 28], "kind": "commanddeclaration"}, {"full_name": "neg_mul_neg", "code": "theorem neg_mul_neg (a b : \u03b1) : -a * -b = a * b", "start": [298, 1], "end": [298, 59], "kind": "commanddeclaration"}, {"full_name": "neg_mul_eq_neg_mul", "code": "theorem neg_mul_eq_neg_mul (a b : \u03b1) : -(a * b) = -a * b", "start": [301, 1], "end": [302, 21], "kind": "commanddeclaration"}, {"full_name": "neg_mul_eq_mul_neg", "code": "theorem neg_mul_eq_mul_neg (a b : \u03b1) : -(a * b) = a * -b", "start": [305, 1], "end": [306, 21], "kind": "commanddeclaration"}, {"full_name": "neg_mul_comm", "code": "theorem neg_mul_comm (a b : \u03b1) : -a * b = a * -b", "start": [309, 1], "end": [309, 60], "kind": "commanddeclaration"}, {"full_name": "neg_eq_neg_one_mul", "code": "theorem neg_eq_neg_one_mul (a : \u03b1) : -a = -1 * a", "start": [318, 1], "end": [318, 60], "kind": "commanddeclaration"}, {"full_name": "mul_neg_one", "code": "theorem mul_neg_one (a : \u03b1) : a * -1 = -a", "start": [321, 1], "end": [323, 53], "kind": "commanddeclaration"}, {"full_name": "neg_one_mul", "code": "theorem neg_one_mul (a : \u03b1) : -1 * a = -a", "start": [326, 1], "end": [328, 53], "kind": "commanddeclaration"}, {"full_name": "MulZeroClass.negZeroClass", "code": "instance (priority := 100) MulZeroClass.negZeroClass : NegZeroClass \u03b1 where\n  __ := inferInstanceAs (Zero \u03b1); __ := inferInstanceAs (InvolutiveNeg \u03b1)\n  neg_zero := by rw [\u2190 zero_mul (0 : \u03b1), \u2190 neg_mul, mul_zero, mul_zero]", "start": [337, 1], "end": [339, 72], "kind": "commanddeclaration"}, {"full_name": "NonUnitalNonAssocRing.toHasDistribNeg", "code": "instance (priority := 100) NonUnitalNonAssocRing.toHasDistribNeg : HasDistribNeg \u03b1 where\n  neg := Neg.neg\n  neg_neg := neg_neg\n  neg_mul a b := eq_neg_of_add_eq_zero_left <| by rw [\u2190 right_distrib, add_left_neg, zero_mul]\n  mul_neg a b := eq_neg_of_add_eq_zero_left <| by rw [\u2190 left_distrib, add_left_neg, mul_zero]", "start": [354, 1], "end": [358, 94], "kind": "commanddeclaration"}, {"full_name": "mul_sub_left_distrib", "code": "theorem mul_sub_left_distrib (a b c : \u03b1) : a * (b - c) = a * b - a * c", "start": [361, 1], "end": [362, 73], "kind": "commanddeclaration"}, {"full_name": "mul_sub", "code": "alias mul_sub := mul_sub_left_distrib", "start": [365, 1], "end": [365, 38], "kind": "stdtacticaliasalias"}, {"full_name": "mul_sub_right_distrib", "code": "theorem mul_sub_right_distrib (a b c : \u03b1) : (a - b) * c = a * c - b * c", "start": [368, 1], "end": [369, 73], "kind": "commanddeclaration"}, {"full_name": "sub_mul", "code": "alias sub_mul := mul_sub_right_distrib", "start": [372, 1], "end": [372, 39], "kind": "stdtacticaliasalias"}, {"full_name": "sub_one_mul", "code": "theorem sub_one_mul (a b : \u03b1) : (a - 1) * b = a * b - b", "start": [384, 1], "end": [384, 84], "kind": "commanddeclaration"}, {"full_name": "mul_sub_one", "code": "theorem mul_sub_one (a b : \u03b1) : a * (b - 1) = a * b - a", "start": [387, 1], "end": [387, 84], "kind": "commanddeclaration"}, {"full_name": "one_sub_mul", "code": "theorem one_sub_mul (a b : \u03b1) : (1 - a) * b = b - a * b", "start": [390, 1], "end": [390, 84], "kind": "commanddeclaration"}, {"full_name": "mul_one_sub", "code": "theorem mul_one_sub (a b : \u03b1) : a * (1 - b) = a - a * b", "start": [393, 1], "end": [393, 84], "kind": "commanddeclaration"}, {"full_name": "Ring.toNonUnitalRing", "code": "instance (priority := 100) Ring.toNonUnitalRing : NonUnitalRing \u03b1 :=\n  { \u2039Ring \u03b1\u203a with }", "start": [404, 1], "end": [405, 20], "kind": "commanddeclaration"}, {"full_name": "Ring.toNonAssocRing", "code": "instance (priority := 100) Ring.toNonAssocRing : NonAssocRing \u03b1 :=\n  { \u2039Ring \u03b1\u203a with }", "start": [410, 1], "end": [411, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalCommRing", "code": "class NonUnitalCommRing (\u03b1 : Type u) extends NonUnitalRing \u03b1, CommSemigroup \u03b1", "start": [424, 1], "end": [425, 78], "kind": "commanddeclaration"}, {"full_name": "NonUnitalCommRing.toNonUnitalCommSemiring", "code": "instance (priority := 100) NonUnitalCommRing.toNonUnitalCommSemiring [s : NonUnitalCommRing \u03b1] :\n    NonUnitalCommSemiring \u03b1 :=\n  { s with }", "start": [429, 1], "end": [431, 13], "kind": "commanddeclaration"}, {"full_name": "CommRing", "code": "class CommRing (\u03b1 : Type u) extends Ring \u03b1, CommMonoid \u03b1", "start": [434, 1], "end": [434, 57], "kind": "commanddeclaration"}, {"full_name": "CommRing.toCommSemiring", "code": "instance (priority := 100) CommRing.toCommSemiring [s : CommRing \u03b1] : CommSemiring \u03b1 :=\n  { s with }", "start": [437, 1], "end": [438, 13], "kind": "commanddeclaration"}, {"full_name": "CommRing.toNonUnitalCommRing", "code": "instance (priority := 100) CommRing.toNonUnitalCommRing [s : CommRing \u03b1] : NonUnitalCommRing \u03b1 :=\n  { s with }", "start": [442, 1], "end": [443, 13], "kind": "commanddeclaration"}, {"full_name": "CommRing.toAddCommGroupWithOne", "code": "instance (priority := 100) CommRing.toAddCommGroupWithOne [s : CommRing \u03b1] :\n    AddCommGroupWithOne \u03b1 :=\n  { s with }", "start": [447, 1], "end": [449, 13], "kind": "commanddeclaration"}, {"full_name": "IsDomain", "code": "class IsDomain (\u03b1 : Type u) [Semiring \u03b1] extends IsCancelMulZero \u03b1, Nontrivial \u03b1 : Prop", "start": [451, 1], "end": [458, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/WithBot.lean", "imports": ["Mathlib/Tactic/Lift.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Option/NAry.lean", "Mathlib/Order/BoundedOrder.lean", "Mathlib/Logic/Nontrivial/Basic.lean"], "premises": [{"full_name": "WithBot", "code": "def WithBot (\u03b1 : Type*) :=\n  Option \u03b1", "start": [26, 1], "end": [28, 11], "kind": "commanddeclaration"}, {"full_name": "WithBot.some", "code": "@[coe, match_pattern] def some : \u03b1 \u2192 WithBot \u03b1 :=\n  Option.some", "start": [41, 1], "end": [43, 14], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe", "code": "instance coe : Coe \u03b1 (WithBot \u03b1) :=\n  \u27e8some\u27e9", "start": [46, 1], "end": [47, 9], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot", "code": "instance bot : Bot (WithBot \u03b1) :=\n  \u27e8none\u27e9", "start": [49, 1], "end": [50, 9], "kind": "commanddeclaration"}, {"full_name": "WithBot.inhabited", "code": "instance inhabited : Inhabited (WithBot \u03b1) :=\n  \u27e8\u22a5\u27e9", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.nontrivial", "code": "instance nontrivial [Nonempty \u03b1] : Nontrivial (WithBot \u03b1) :=\n  Option.nontrivial", "start": [55, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : \u03b1 \u2192 WithBot \u03b1)", "start": [60, 1], "end": [61, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj : (a : WithBot \u03b1) = b \u2194 a = b", "start": [64, 1], "end": [66, 18], "kind": "commanddeclaration"}, {"full_name": "WithBot.forall", "code": "protected theorem \u00abforall\u00bb {p : WithBot \u03b1 \u2192 Prop} : (\u2200 x, p x) \u2194 p \u22a5 \u2227 \u2200 x : \u03b1, p x", "start": [69, 1], "end": [70, 16], "kind": "commanddeclaration"}, {"full_name": "WithBot.exists", "code": "protected theorem \u00abexists\u00bb {p : WithBot \u03b1 \u2192 Prop} : (\u2203 x, p x) \u2194 p \u22a5 \u2228 \u2203 x : \u03b1, p x", "start": [73, 1], "end": [74, 16], "kind": "commanddeclaration"}, {"full_name": "WithBot.none_eq_bot", "code": "theorem none_eq_bot : (none : WithBot \u03b1) = (\u22a5 : WithBot \u03b1)", "start": [77, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.some_eq_coe", "code": "theorem some_eq_coe (a : \u03b1) : (Option.some a : WithBot \u03b1) = (\u2191a : WithBot \u03b1)", "start": [81, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_ne_coe", "code": "@[simp]\ntheorem bot_ne_coe : \u22a5 \u2260 (a : WithBot \u03b1)", "start": [85, 1], "end": [87, 7], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_ne_bot", "code": "@[simp]\ntheorem coe_ne_bot : (a : WithBot \u03b1) \u2260 \u22a5", "start": [90, 1], "end": [92, 7], "kind": "commanddeclaration"}, {"full_name": "WithBot.recBotCoe", "code": "@[elab_as_elim]\ndef recBotCoe {C : WithBot \u03b1 \u2192 Sort*} (bot : C \u22a5) (coe : \u2200 a : \u03b1, C a) : \u2200 n : WithBot \u03b1, C n\n  | none => bot\n  | Option.some a => coe a", "start": [95, 1], "end": [99, 27], "kind": "commanddeclaration"}, {"full_name": "WithBot.recBotCoe_bot", "code": "@[simp]\ntheorem recBotCoe_bot {C : WithBot \u03b1 \u2192 Sort*} (d : C \u22a5) (f : \u2200 a : \u03b1, C a) :\n    @recBotCoe _ C d f \u22a5 = d", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.recBotCoe_coe", "code": "@[simp]\ntheorem recBotCoe_coe {C : WithBot \u03b1 \u2192 Sort*} (d : C \u22a5) (f : \u2200 a : \u03b1, C a) (x : \u03b1) :\n    @recBotCoe _ C d f \u2191x = f x", "start": [108, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'", "code": "def unbot' (d : \u03b1) (x : WithBot \u03b1) : \u03b1 :=\n  recBotCoe d id x", "start": [114, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_bot", "code": "@[simp]\ntheorem unbot'_bot {\u03b1} (d : \u03b1) : unbot' d \u22a5 = d", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_coe", "code": "@[simp]\ntheorem unbot'_coe {\u03b1} (d x : \u03b1) : unbot' d x = x", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_eq_coe", "code": "theorem coe_eq_coe : (a : WithBot \u03b1) = b \u2194 a = b", "start": [130, 1], "end": [130, 60], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_eq_iff", "code": "theorem unbot'_eq_iff {d y : \u03b1} {x : WithBot \u03b1} : unbot' d x = y \u2194 x = y \u2228 x = \u22a5 \u2227 y = d", "start": [133, 1], "end": [134, 54], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_eq_self_iff", "code": "@[simp] theorem unbot'_eq_self_iff {d : \u03b1} {x : WithBot \u03b1} : unbot' d x = d \u2194 x = d \u2228 x = \u22a5", "start": [137, 1], "end": [138, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_eq_unbot'_iff", "code": "theorem unbot'_eq_unbot'_iff {d : \u03b1} {x y : WithBot \u03b1} :\n    unbot' d x = unbot' d y \u2194 x = y \u2228 x = d \u2227 y = \u22a5 \u2228 x = \u22a5 \u2227 y = d", "start": [141, 1], "end": [143, 63], "kind": "commanddeclaration"}, {"full_name": "WithBot.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : WithBot \u03b1 \u2192 WithBot \u03b2 :=\n  Option.map f", "start": [146, 1], "end": [148, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_bot", "code": "@[simp]\ntheorem map_bot (f : \u03b1 \u2192 \u03b2) : map f \u22a5 = \u22a5", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_coe", "code": "@[simp]\ntheorem map_coe (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : map f a = f a", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_comm", "code": "theorem map_comm {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {g\u2081 : \u03b2 \u2192 \u03b4} {g\u2082 : \u03b3 \u2192 \u03b4}\n    (h : g\u2081 \u2218 f\u2081 = g\u2082 \u2218 f\u2082) (a : \u03b1) :\n    map g\u2081 (map f\u2081 a) = map g\u2082 (map f\u2082 a)", "start": [161, 1], "end": [164, 22], "kind": "commanddeclaration"}, {"full_name": "WithBot.ne_bot_iff_exists", "code": "theorem ne_bot_iff_exists {x : WithBot \u03b1} : x \u2260 \u22a5 \u2194 \u2203 a : \u03b1, \u2191a = x", "start": [167, 1], "end": [168, 28], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot", "code": "def unbot : \u2200 x : WithBot \u03b1, x \u2260 \u22a5 \u2192 \u03b1\n  | \u22a5, h => absurd rfl h\n  | Option.some x, _ => x", "start": [171, 1], "end": [174, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_unbot", "code": "@[simp]\ntheorem coe_unbot (x : WithBot \u03b1) (h : x \u2260 \u22a5) : (x.unbot h : WithBot \u03b1) = x", "start": [177, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot_coe", "code": "@[simp]\ntheorem unbot_coe (x : \u03b1) (h : (x : WithBot \u03b1) \u2260 \u22a5 := coe_ne_bot) : (x : WithBot \u03b1).unbot h = x", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.canLift", "code": "instance canLift : CanLift (WithBot \u03b1) \u03b1 (\u2191) fun r => r \u2260 \u22a5 where\n  prf x h := \u27e8x.unbot h, coe_unbot _ _\u27e9", "start": [189, 1], "end": [190, 40], "kind": "commanddeclaration"}, {"full_name": "WithBot.le", "code": "instance (priority := 10) le : LE (WithBot \u03b1) :=\n  \u27e8fun o\u2081 o\u2082 : Option \u03b1 => \u2200 a \u2208 o\u2081, \u2203 b \u2208 o\u2082, a \u2264 b\u27e9", "start": [197, 1], "end": [198, 54], "kind": "commanddeclaration"}, {"full_name": "WithBot.some_le_some", "code": "@[simp]\ntheorem some_le_some : @LE.le (WithBot \u03b1) _ (Option.some a) (Option.some b) \u2194 a \u2264 b", "start": [200, 1], "end": [202, 18], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe : (a : WithBot \u03b1) \u2264 b \u2194 a \u2264 b", "start": [205, 1], "end": [207, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.none_le", "code": "@[simp]\ntheorem none_le {a : WithBot \u03b1} : @LE.le (WithBot \u03b1) _ none a", "start": [210, 1], "end": [211, 97], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderBot", "code": "instance orderBot : OrderBot (WithBot \u03b1) :=\n  { WithBot.bot with bot_le := fun _ => none_le }", "start": [214, 1], "end": [215, 50], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderTop", "code": "instance orderTop [OrderTop \u03b1] : OrderTop (WithBot \u03b1) where\n  top := some \u22a4\n  le_top o a ha := by cases ha; exact \u27e8_, rfl, le_top\u27e9", "start": [218, 1], "end": [220, 55], "kind": "commanddeclaration"}, {"full_name": "WithBot.instBoundedOrder", "code": "instance instBoundedOrder [OrderTop \u03b1] : BoundedOrder (WithBot \u03b1) :=\n  { WithBot.orderBot, WithBot.orderTop with }", "start": [222, 1], "end": [223, 46], "kind": "commanddeclaration"}, {"full_name": "WithBot.not_coe_le_bot", "code": "theorem not_coe_le_bot (a : \u03b1) : \u00ac(a : WithBot \u03b1) \u2264 \u22a5", "start": [225, 1], "end": [227, 27], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_bot_iff", "code": "@[simp]\nprotected theorem le_bot_iff : \u2200 {a : WithBot \u03b1}, a \u2264 \u22a5 \u2194 a = \u22a5", "start": [230, 1], "end": [234, 17], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_le", "code": "theorem coe_le : \u2200 {o : Option \u03b1}, b \u2208 o \u2192 ((a : WithBot \u03b1) \u2264 o \u2194 a \u2264 b)", "start": [236, 1], "end": [237, 25], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_le_iff", "code": "theorem coe_le_iff : \u2200 {x : WithBot \u03b1}, (a : WithBot \u03b1) \u2264 x \u2194 \u2203 b : \u03b1, x = b \u2227 a \u2264 b", "start": [240, 1], "end": [242, 69], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_coe_iff", "code": "theorem le_coe_iff : \u2200 {x : WithBot \u03b1}, x \u2264 b \u2194 \u2200 a : \u03b1, x = \u2191a \u2192 a \u2264 b", "start": [245, 1], "end": [247, 34], "kind": "commanddeclaration"}, {"full_name": "IsMax.withBot", "code": "protected theorem _root_.IsMax.withBot (h : IsMax a) : IsMax (a : WithBot \u03b1)", "start": [250, 1], "end": [252, 66], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_unbot_iff", "code": "theorem le_unbot_iff {a : \u03b1} {b : WithBot \u03b1} (h : b \u2260 \u22a5) :\n    a \u2264 unbot b h \u2194 (a : WithBot \u03b1) \u2264 b", "start": [255, 1], "end": [258, 51], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot_le_iff", "code": "theorem unbot_le_iff {a : WithBot \u03b1} (h : a \u2260 \u22a5) {b : \u03b1} :\n    unbot a h \u2264 b \u2194 a \u2264 (b : WithBot \u03b1)", "start": [260, 1], "end": [263, 51], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt", "code": "instance (priority := 10) lt : LT (WithBot \u03b1) :=\n  \u27e8fun o\u2081 o\u2082 : Option \u03b1 => \u2203 b \u2208 o\u2082, \u2200 a \u2208 o\u2081, a < b\u27e9", "start": [271, 1], "end": [272, 54], "kind": "commanddeclaration"}, {"full_name": "WithBot.some_lt_some", "code": "@[simp]\ntheorem some_lt_some : @LT.lt (WithBot \u03b1) _ (Option.some a) (Option.some b) \u2194 a < b", "start": [274, 1], "end": [276, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe : (a : WithBot \u03b1) < b \u2194 a < b", "start": [279, 1], "end": [281, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.none_lt_some", "code": "@[simp]\ntheorem none_lt_some (a : \u03b1) : @LT.lt (WithBot \u03b1) _ none (some a)", "start": [284, 1], "end": [286, 56], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_lt_coe", "code": "theorem bot_lt_coe (a : \u03b1) : (\u22a5 : WithBot \u03b1) < a", "start": [289, 1], "end": [290, 17], "kind": "commanddeclaration"}, {"full_name": "WithBot.not_lt_none", "code": "@[simp]\ntheorem not_lt_none (a : WithBot \u03b1) : \u00ac@LT.lt (WithBot \u03b1) _ a none", "start": [293, 1], "end": [295, 43], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt_iff_exists_coe", "code": "theorem lt_iff_exists_coe : \u2200 {a b : WithBot \u03b1}, a < b \u2194 \u2203 p : \u03b1, b = p \u2227 a < p", "start": [298, 1], "end": [300, 69], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt_coe_iff", "code": "theorem lt_coe_iff : \u2200 {x : WithBot \u03b1}, x < b \u2194 \u2200 a, x = \u2191a \u2192 a < b", "start": [303, 1], "end": [305, 46], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_lt_iff_ne_bot", "code": "protected theorem bot_lt_iff_ne_bot : \u2200 {x : WithBot \u03b1}, \u22a5 < x \u2194 x \u2260 \u22a5", "start": [308, 1], "end": [312, 36], "kind": "commanddeclaration"}, {"full_name": "WithBot.preorder", "code": "instance preorder [Preorder \u03b1] : Preorder (WithBot \u03b1) where\n  le := (\u00b7 \u2264 \u00b7)\n  lt := (\u00b7 < \u00b7)\n  lt_iff_le_not_le := by\n    intros a b\n    cases a <;> cases b <;> simp [lt_iff_le_not_le]; simp [LE.le, LT.lt]\n  le_refl o a ha := \u27e8a, ha, le_rfl\u27e9\n  le_trans o\u2081 o\u2082 o\u2083 h\u2081 h\u2082 a ha :=\n    let \u27e8b, hb, ab\u27e9 := h\u2081 a ha\n    let \u27e8c, hc, bc\u27e9 := h\u2082 b hb\n    \u27e8c, hc, le_trans ab bc\u27e9", "start": [317, 1], "end": [327, 28], "kind": "commanddeclaration"}, {"full_name": "WithBot.partialOrder", "code": "instance partialOrder [PartialOrder \u03b1] : PartialOrder (WithBot \u03b1) :=\n  { WithBot.preorder with\n    le_antisymm := fun o\u2081 o\u2082 h\u2081 h\u2082 => by\n      cases' o\u2081 with a\n      \u00b7 cases' o\u2082 with b\n        \u00b7 rfl\n\n        rcases h\u2082 b rfl with \u27e8_, \u27e8\u27e9, _\u27e9\n\n      \u00b7 rcases h\u2081 a rfl with \u27e8b, \u27e8\u27e9, h\u2081'\u27e9\n        rcases h\u2082 b rfl with \u27e8_, \u27e8\u27e9, h\u2082'\u27e9\n        rw [le_antisymm h\u2081' h\u2082']\n         }", "start": [329, 1], "end": [341, 11], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_strictMono", "code": "theorem coe_strictMono [Preorder \u03b1] : StrictMono (fun (a : \u03b1) => (a : WithBot \u03b1))", "start": [344, 1], "end": [345, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_mono", "code": "theorem coe_mono [Preorder \u03b1] : Monotone (fun (a : \u03b1) => (a : WithBot \u03b1))", "start": [348, 1], "end": [349, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.monotone_iff", "code": "theorem monotone_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithBot \u03b1 \u2192 \u03b2} :\n    Monotone f \u2194 Monotone (\u03bb a => f a : \u03b1 \u2192 \u03b2) \u2227 \u2200 x : \u03b1, f \u22a5 \u2264 f x", "start": [352, 1], "end": [358, 49], "kind": "commanddeclaration"}, {"full_name": "WithBot.monotone_map_iff", "code": "@[simp]\ntheorem monotone_map_iff [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Monotone (WithBot.map f) \u2194 Monotone f", "start": [361, 1], "end": [364, 43], "kind": "commanddeclaration"}, {"full_name": "Monotone.withBot_map", "code": "alias \u27e8_, _root_.Monotone.withBot_map\u27e9 := monotone_map_iff", "start": [367, 1], "end": [367, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WithBot.strictMono_iff", "code": "theorem strictMono_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithBot \u03b1 \u2192 \u03b2} :\n    StrictMono f \u2194 StrictMono (\u03bb a => f a : \u03b1 \u2192 \u03b2) \u2227 \u2200 x : \u03b1, f \u22a5 < f x", "start": [370, 1], "end": [375, 95], "kind": "commanddeclaration"}, {"full_name": "WithBot.strictAnti_iff", "code": "theorem strictAnti_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithBot \u03b1 \u2192 \u03b2} :\n    StrictAnti f \u2194 StrictAnti (\u03bb a => f a : \u03b1 \u2192 \u03b2) \u2227 \u2200 x : \u03b1, f x < f \u22a5", "start": [378, 1], "end": [380, 28], "kind": "commanddeclaration"}, {"full_name": "WithBot.strictMono_map_iff", "code": "@[simp]\ntheorem strictMono_map_iff [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    StrictMono (WithBot.map f) \u2194 StrictMono f", "start": [382, 1], "end": [385, 59], "kind": "commanddeclaration"}, {"full_name": "StrictMono.withBot_map", "code": "alias \u27e8_, _root_.StrictMono.withBot_map\u27e9 := strictMono_map_iff", "start": [388, 1], "end": [388, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WithBot.map_le_iff", "code": "theorem map_le_iff [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (mono_iff : \u2200 {a b}, f a \u2264 f b \u2194 a \u2264 b) :\n    \u2200 a b : WithBot \u03b1, a.map f \u2264 b.map f \u2194 a \u2264 b", "start": [391, 1], "end": [395, 75], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_coe_unbot'", "code": "theorem le_coe_unbot' [Preorder \u03b1] : \u2200 (a : WithBot \u03b1) (b : \u03b1), a \u2264 a.unbot' b", "start": [398, 1], "end": [400, 19], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_le_iff", "code": "theorem unbot'_le_iff [LE \u03b1] {a : WithBot \u03b1} {b c : \u03b1} (h : a = \u22a5 \u2192 b \u2264 c) :\n    a.unbot' b \u2264 c \u2194 a \u2264 c", "start": [403, 1], "end": [407, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.unbot'_lt_iff", "code": "theorem unbot'_lt_iff [LT \u03b1] {a : WithBot \u03b1} {b c : \u03b1} (h : a = \u22a5 \u2192 b < c) :\n    a.unbot' b < c \u2194 a < c", "start": [410, 1], "end": [414, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] : SemilatticeSup (WithBot \u03b1) :=\n  { WithBot.partialOrder, @WithBot.orderBot \u03b1 _ with\n    sup := Option.liftOrGet (\u00b7 \u2294 \u00b7),\n    le_sup_left := fun o\u2081 o\u2082 a ha => by cases ha; cases o\u2082 <;> simp [Option.liftOrGet],\n    le_sup_right := fun o\u2081 o\u2082 a ha => by cases ha; cases o\u2081 <;> simp [Option.liftOrGet],\n    sup_le := fun o\u2081 o\u2082 o\u2083 h\u2081 h\u2082 a ha => by\n      cases' o\u2081 with b <;> cases' o\u2082 with c <;> cases ha\n      \u00b7 exact h\u2082 a rfl\n\n      \u00b7 exact h\u2081 a rfl\n\n      \u00b7 rcases h\u2081 b rfl with \u27e8d, \u27e8\u27e9, h\u2081'\u27e9\n        simp at h\u2082\n        exact \u27e8d, rfl, sup_le h\u2081' h\u2082\u27e9\n         }", "start": [416, 1], "end": [430, 11], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_sup", "code": "theorem coe_sup [SemilatticeSup \u03b1] (a b : \u03b1) : ((a \u2294 b : \u03b1) : WithBot \u03b1) = (a : WithBot \u03b1) \u2294 b", "start": [432, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] : SemilatticeInf (WithBot \u03b1) :=\n  { WithBot.partialOrder, @WithBot.orderBot \u03b1 _ with\n    inf := Option.map\u2082 (\u00b7 \u2293 \u00b7),\n    inf_le_left := fun o\u2081 o\u2082 a ha => by\n      rcases Option.mem_map\u2082_iff.1 ha with \u27e8a, b, (rfl : _ = _), (rfl : _ = _), rfl\u27e9\n      exact \u27e8_, rfl, inf_le_left\u27e9,\n    inf_le_right := fun o\u2081 o\u2082 a ha => by\n      rcases Option.mem_map\u2082_iff.1 ha with \u27e8a, b, (rfl : _ = _), (rfl : _ = _), rfl\u27e9\n      exact \u27e8_, rfl, inf_le_right\u27e9,\n    le_inf := fun o\u2081 o\u2082 o\u2083 h\u2081 h\u2082 a ha => by\n      cases ha\n      rcases h\u2081 a rfl with \u27e8b, \u27e8\u27e9, ab\u27e9\n      rcases h\u2082 a rfl with \u27e8c, \u27e8\u27e9, ac\u27e9\n      exact \u27e8_, rfl, le_inf ab ac\u27e9 }", "start": [436, 1], "end": [449, 37], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_inf", "code": "theorem coe_inf [SemilatticeInf \u03b1] (a b : \u03b1) : ((a \u2293 b : \u03b1) : WithBot \u03b1) = (a : WithBot \u03b1) \u2293 b", "start": [451, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.lattice", "code": "instance lattice [Lattice \u03b1] : Lattice (WithBot \u03b1) :=\n  { WithBot.semilatticeSup, WithBot.semilatticeInf with }", "start": [455, 1], "end": [456, 58], "kind": "commanddeclaration"}, {"full_name": "WithBot.distribLattice", "code": "instance distribLattice [DistribLattice \u03b1] : DistribLattice (WithBot \u03b1) :=\n  { WithBot.lattice with\n    le_sup_inf := fun o\u2081 o\u2082 o\u2083 =>\n      match o\u2081, o\u2082, o\u2083 with\n      | \u22a5, \u22a5, \u22a5 => le_rfl\n      | \u22a5, \u22a5, (a\u2081 : \u03b1) => le_rfl\n      | \u22a5, (a\u2081 : \u03b1), \u22a5 => le_rfl\n      | \u22a5, (a\u2081 : \u03b1), (a\u2083 : \u03b1) => le_rfl\n      | (a\u2081 : \u03b1), \u22a5, \u22a5 => inf_le_left\n      | (a\u2081 : \u03b1), \u22a5, (a\u2083 : \u03b1) => inf_le_left\n      | (a\u2081 : \u03b1), (a\u2082 : \u03b1), \u22a5 => inf_le_right\n      | (a\u2081 : \u03b1), (a\u2082 : \u03b1), (a\u2083 : \u03b1) => coe_le_coe.mpr le_sup_inf }", "start": [458, 1], "end": [469, 68], "kind": "commanddeclaration"}, {"full_name": "WithBot.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] : DecidableEq (WithBot \u03b1) := instDecidableEqOption", "start": [472, 1], "end": [472, 88], "kind": "commanddeclaration"}, {"full_name": "WithBot.decidableLE", "code": "instance decidableLE [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : @DecidableRel (WithBot \u03b1) (\u00b7 \u2264 \u00b7)\n  | none, x => isTrue fun a h => Option.noConfusion h\n  | Option.some x, Option.some y =>\n      if h : x \u2264 y then isTrue (some_le_some.2 h) else isFalse <| by simp [*]\n  | Option.some x, none => isFalse fun h => by rcases h x rfl with \u27e8y, \u27e8_\u27e9, _\u27e9", "start": [474, 1], "end": [478, 79], "kind": "commanddeclaration"}, {"full_name": "WithBot.decidableLT", "code": "instance decidableLT [LT \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] : @DecidableRel (WithBot \u03b1) (\u00b7 < \u00b7)\n  | none, Option.some x => isTrue <| by exists x, rfl; rintro _ \u27e8\u27e9\n  | Option.some x, Option.some y =>\n      if h : x < y then isTrue <| by simp [*] else isFalse <| by simp [*]\n  | x, none => isFalse <| by rintro \u27e8a, \u27e8\u27e8\u27e9\u27e9\u27e9", "start": [481, 1], "end": [485, 46], "kind": "commanddeclaration"}, {"full_name": "WithBot.isTotal_le", "code": "instance isTotal_le [LE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] : IsTotal (WithBot \u03b1) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b =>\n    match a, b with\n    | none, _ => Or.inl bot_le\n    | _, none => Or.inr bot_le\n    | Option.some x, Option.some y => (total_of (\u00b7 \u2264 \u00b7) x y).imp some_le_some.2 some_le_some.2\u27e9", "start": [488, 1], "end": [493, 96], "kind": "commanddeclaration"}, {"full_name": "WithBot.linearOrder", "code": "instance linearOrder [LinearOrder \u03b1] : LinearOrder (WithBot \u03b1) :=\n  Lattice.toLinearOrder _", "start": [496, 1], "end": [497, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min [LinearOrder \u03b1] (x y : \u03b1) : ((min x y : \u03b1) : WithBot \u03b1) = min (x : WithBot \u03b1) y", "start": [500, 1], "end": [502, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max [LinearOrder \u03b1] (x y : \u03b1) : ((max x y : \u03b1) : WithBot \u03b1) = max (x : WithBot \u03b1) y", "start": [505, 1], "end": [507, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.wellFounded_lt", "code": "theorem wellFounded_lt [LT \u03b1] (h : @WellFounded \u03b1 (\u00b7 < \u00b7)) :\n    @WellFounded (WithBot \u03b1) (\u00b7 < \u00b7)", "start": [510, 1], "end": [519, 52], "kind": "commanddeclaration"}, {"full_name": "WithBot.denselyOrdered", "code": "instance denselyOrdered [LT \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] : DenselyOrdered (WithBot \u03b1) :=\n  \u27e8fun a b =>\n    match a, b with\n    | a, none => fun h : a < \u22a5 => (not_lt_none _ h).elim\n    | none, Option.some b => fun _ =>\n      let \u27e8a, ha\u27e9 := exists_lt b\n      \u27e8a, bot_lt_coe a, coe_lt_coe.2 ha\u27e9\n    | Option.some _, Option.some _ => fun h =>\n      let \u27e8a, ha\u2081, ha\u2082\u27e9 := exists_between (coe_lt_coe.1 h)\n      \u27e8a, coe_lt_coe.2 ha\u2081, coe_lt_coe.2 ha\u2082\u27e9\u27e9", "start": [522, 1], "end": [531, 47], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt_iff_exists_coe_btwn", "code": "theorem lt_iff_exists_coe_btwn [Preorder \u03b1] [DenselyOrdered \u03b1] [NoMinOrder \u03b1] {a b : WithBot \u03b1} :\n    a < b \u2194 \u2203 x : \u03b1, a < \u2191x \u2227 \u2191x < b", "start": [533, 1], "end": [539, 39], "kind": "commanddeclaration"}, {"full_name": "WithBot.noTopOrder", "code": "instance noTopOrder [LE \u03b1] [NoTopOrder \u03b1] [Nonempty \u03b1] : NoTopOrder (WithBot \u03b1) :=\n  \u27e8by\n    apply recBotCoe\n    \u00b7 exact \u2039Nonempty \u03b1\u203a.elim fun a => \u27e8a, not_coe_le_bot a\u27e9\n\n    \u00b7 intro a\n      obtain \u27e8b, h\u27e9 := exists_not_le a\n      exact \u27e8b, by rwa [coe_le_coe]\u27e9\n      \u27e9", "start": [542, 1], "end": [550, 8], "kind": "commanddeclaration"}, {"full_name": "WithBot.noMaxOrder", "code": "instance noMaxOrder [LT \u03b1] [NoMaxOrder \u03b1] [Nonempty \u03b1] : NoMaxOrder (WithBot \u03b1) :=\n  \u27e8by\n    apply WithBot.recBotCoe\n    \u00b7 apply \u2039Nonempty \u03b1\u203a.elim\n      exact fun a => \u27e8a, WithBot.bot_lt_coe a\u27e9\n\n    \u00b7 intro a\n      obtain \u27e8b, ha\u27e9 := exists_gt a\n      exact \u27e8b, coe_lt_coe.mpr ha\u27e9\n      \u27e9", "start": [552, 1], "end": [561, 8], "kind": "commanddeclaration"}, {"full_name": "WithTop", "code": "def WithTop (\u03b1 : Type*) :=\n  Option \u03b1", "start": [566, 1], "end": [568, 11], "kind": "commanddeclaration"}, {"full_name": "WithTop.some", "code": "@[coe, match_pattern] def some : \u03b1 \u2192 WithTop \u03b1 :=\n  Option.some", "start": [581, 1], "end": [583, 14], "kind": "commanddeclaration"}, {"full_name": "WithTop.coeTC", "code": "instance coeTC : CoeTC \u03b1 (WithTop \u03b1) :=\n  \u27e8some\u27e9", "start": [585, 1], "end": [586, 9], "kind": "commanddeclaration"}, {"full_name": "WithTop.top", "code": "instance top : Top (WithTop \u03b1) :=\n  \u27e8none\u27e9", "start": [588, 1], "end": [589, 9], "kind": "commanddeclaration"}, {"full_name": "WithTop.inhabited", "code": "instance inhabited : Inhabited (WithTop \u03b1) :=\n  \u27e8\u22a4\u27e9", "start": [591, 1], "end": [592, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.nontrivial", "code": "instance nontrivial [Nonempty \u03b1] : Nontrivial (WithTop \u03b1) :=\n  Option.nontrivial", "start": [594, 1], "end": [595, 20], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : \u03b1 \u2192 WithTop \u03b1)", "start": [599, 1], "end": [600, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_inj", "code": "@[norm_cast]\ntheorem coe_inj : (a : WithTop \u03b1) = b \u2194 a = b", "start": [602, 1], "end": [604, 18], "kind": "commanddeclaration"}, {"full_name": "WithTop.forall", "code": "protected theorem \u00abforall\u00bb {p : WithTop \u03b1 \u2192 Prop} : (\u2200 x, p x) \u2194 p \u22a4 \u2227 \u2200 x : \u03b1, p x", "start": [606, 1], "end": [607, 16], "kind": "commanddeclaration"}, {"full_name": "WithTop.exists", "code": "protected theorem \u00abexists\u00bb {p : WithTop \u03b1 \u2192 Prop} : (\u2203 x, p x) \u2194 p \u22a4 \u2228 \u2203 x : \u03b1, p x", "start": [610, 1], "end": [611, 16], "kind": "commanddeclaration"}, {"full_name": "WithTop.none_eq_top", "code": "theorem none_eq_top : (none : WithTop \u03b1) = (\u22a4 : WithTop \u03b1)", "start": [614, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.some_eq_coe", "code": "theorem some_eq_coe (a : \u03b1) : (Option.some a : WithTop \u03b1) = (\u2191a : WithTop \u03b1)", "start": [618, 1], "end": [619, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_ne_coe", "code": "@[simp]\ntheorem top_ne_coe : \u22a4 \u2260 (a : WithTop \u03b1)", "start": [622, 1], "end": [624, 7], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_ne_top", "code": "@[simp]\ntheorem coe_ne_top : (a : WithTop \u03b1) \u2260 \u22a4", "start": [627, 1], "end": [629, 7], "kind": "commanddeclaration"}, {"full_name": "WithTop.recTopCoe", "code": "@[elab_as_elim]\ndef recTopCoe {C : WithTop \u03b1 \u2192 Sort*} (top : C \u22a4) (coe : \u2200 a : \u03b1, C a) : \u2200 n : WithTop \u03b1, C n\n  | none => top\n  | Option.some a => coe a", "start": [632, 1], "end": [636, 27], "kind": "commanddeclaration"}, {"full_name": "WithTop.recTopCoe_top", "code": "@[simp]\ntheorem recTopCoe_top {C : WithTop \u03b1 \u2192 Sort*} (d : C \u22a4) (f : \u2200 a : \u03b1, C a) :\n    @recTopCoe _ C d f \u22a4 = d", "start": [639, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.recTopCoe_coe", "code": "@[simp]\ntheorem recTopCoe_coe {C : WithTop \u03b1 \u2192 Sort*} (d : C \u22a4) (f : \u2200 a : \u03b1, C a) (x : \u03b1) :\n    @recTopCoe _ C d f \u2191x = f x", "start": [645, 1], "end": [648, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual", "code": "protected def toDual : WithTop \u03b1 \u2243 WithBot \u03b1\u1d52\u1d48 :=\n  Equiv.refl _", "start": [651, 1], "end": [655, 15], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual", "code": "protected def ofDual : WithTop \u03b1\u1d52\u1d48 \u2243 WithBot \u03b1 :=\n  Equiv.refl _", "start": [658, 1], "end": [662, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual", "code": "protected def _root_.WithBot.toDual : WithBot \u03b1 \u2243 WithTop \u03b1\u1d52\u1d48 :=\n  Equiv.refl _", "start": [665, 1], "end": [669, 15], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual", "code": "protected def _root_.WithBot.ofDual : WithBot \u03b1\u1d52\u1d48 \u2243 WithTop \u03b1 :=\n  Equiv.refl _", "start": [672, 1], "end": [676, 15], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_symm_apply", "code": "@[simp]\ntheorem toDual_symm_apply (a : WithBot \u03b1\u1d52\u1d48) : WithTop.toDual.symm a = WithBot.ofDual a", "start": [679, 1], "end": [681, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_symm_apply", "code": "@[simp]\ntheorem ofDual_symm_apply (a : WithBot \u03b1) : WithTop.ofDual.symm a = WithBot.toDual a", "start": [684, 1], "end": [686, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_apply_top", "code": "@[simp]\ntheorem toDual_apply_top : WithTop.toDual (\u22a4 : WithTop \u03b1) = \u22a5", "start": [689, 1], "end": [691, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_apply_top", "code": "@[simp]\ntheorem ofDual_apply_top : WithTop.ofDual (\u22a4 : WithTop \u03b1) = \u22a5", "start": [694, 1], "end": [696, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_apply_coe", "code": "@[simp]\ntheorem toDual_apply_coe (a : \u03b1) : WithTop.toDual (a : WithTop \u03b1) = toDual a", "start": [701, 1], "end": [703, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_apply_coe", "code": "@[simp]\ntheorem ofDual_apply_coe (a : \u03b1\u1d52\u1d48) : WithTop.ofDual (a : WithTop \u03b1\u1d52\u1d48) = ofDual a", "start": [706, 1], "end": [708, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'", "code": "def untop' (d : \u03b1) (x : WithTop \u03b1) : \u03b1 :=\n  recTopCoe d id x", "start": [711, 1], "end": [714, 19], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_top", "code": "@[simp]\ntheorem untop'_top {\u03b1} (d : \u03b1) : untop' d \u22a4 = d", "start": [717, 1], "end": [719, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_coe", "code": "@[simp]\ntheorem untop'_coe {\u03b1} (d x : \u03b1) : untop' d x = x", "start": [722, 1], "end": [724, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_eq_coe", "code": "@[simp, norm_cast] theorem coe_eq_coe : (a : WithTop \u03b1) = b \u2194 a = b", "start": [727, 1], "end": [729, 18], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_eq_iff", "code": "theorem untop'_eq_iff {d y : \u03b1} {x : WithTop \u03b1} : untop' d x = y \u2194 x = y \u2228 x = \u22a4 \u2227 y = d", "start": [732, 1], "end": [733, 24], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_eq_self_iff", "code": "@[simp] theorem untop'_eq_self_iff {d : \u03b1} {x : WithTop \u03b1} : untop' d x = d \u2194 x = d \u2228 x = \u22a4", "start": [736, 1], "end": [737, 29], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_eq_untop'_iff", "code": "theorem untop'_eq_untop'_iff {d : \u03b1} {x y : WithTop \u03b1} :\n    untop' d x = untop' d y \u2194 x = y \u2228 x = d \u2227 y = \u22a4 \u2228 x = \u22a4 \u2227 y = d", "start": [740, 1], "end": [742, 31], "kind": "commanddeclaration"}, {"full_name": "WithTop.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : WithTop \u03b1 \u2192 WithTop \u03b2 :=\n  Option.map f", "start": [745, 1], "end": [747, 15], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_top", "code": "@[simp]\ntheorem map_top (f : \u03b1 \u2192 \u03b2) : map f \u22a4 = \u22a4", "start": [750, 1], "end": [752, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_coe", "code": "@[simp]\ntheorem map_coe (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : map f a = f a", "start": [755, 1], "end": [757, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_comm", "code": "theorem map_comm {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {g\u2081 : \u03b2 \u2192 \u03b4} {g\u2082 : \u03b3 \u2192 \u03b4}\n    (h : g\u2081 \u2218 f\u2081 = g\u2082 \u2218 f\u2082) (a : \u03b1) : map g\u2081 (map f\u2081 a) = map g\u2082 (map f\u2082 a)", "start": [760, 1], "end": [762, 22], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_toDual", "code": "theorem map_toDual (f : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) (a : WithBot \u03b1) :\n    map f (WithBot.toDual a) = a.map (toDual \u2218 f)", "start": [765, 1], "end": [767, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_ofDual", "code": "theorem map_ofDual (f : \u03b1 \u2192 \u03b2) (a : WithBot \u03b1\u1d52\u1d48) : map f (WithBot.ofDual a) = a.map (ofDual \u2218 f)", "start": [770, 1], "end": [771, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_map", "code": "theorem toDual_map (f : \u03b1 \u2192 \u03b2) (a : WithTop \u03b1) :\n    WithTop.toDual (map f a) = WithBot.map (toDual \u2218 f \u2218 ofDual) (WithTop.toDual a)", "start": [774, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_map", "code": "theorem ofDual_map (f : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) (a : WithTop \u03b1\u1d52\u1d48) :\n    WithTop.ofDual (map f a) = WithBot.map (ofDual \u2218 f \u2218 toDual) (WithTop.ofDual a)", "start": [779, 1], "end": [781, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.ne_top_iff_exists", "code": "theorem ne_top_iff_exists {x : WithTop \u03b1} : x \u2260 \u22a4 \u2194 \u2203 a : \u03b1, \u2191a = x", "start": [784, 1], "end": [785, 28], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop", "code": "def untop : \u2200 x : WithTop \u03b1, x \u2260 \u22a4 \u2192 \u03b1 :=\n  WithBot.unbot", "start": [788, 1], "end": [790, 16], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_untop", "code": "@[simp]\ntheorem coe_untop (x : WithTop \u03b1) (h : x \u2260 \u22a4) : (x.untop h : WithTop \u03b1) = x", "start": [793, 1], "end": [795, 24], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop_coe", "code": "@[simp]\ntheorem untop_coe (x : \u03b1) (h : (x : WithTop \u03b1) \u2260 \u22a4 := coe_ne_top) : (x : WithTop \u03b1).untop h = x", "start": [798, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.canLift", "code": "instance canLift : CanLift (WithTop \u03b1) \u03b1 (\u2191) fun r => r \u2260 \u22a4 where\n  prf x h := \u27e8x.untop h, coe_untop _ _\u27e9", "start": [803, 1], "end": [804, 40], "kind": "commanddeclaration"}, {"full_name": "WithTop.le", "code": "instance (priority := 10) le : LE (WithTop \u03b1) :=\n  \u27e8fun o\u2081 o\u2082 : Option \u03b1 => \u2200 a \u2208 o\u2082, \u2203 b \u2208 o\u2081, b \u2264 a\u27e9", "start": [811, 1], "end": [812, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_le_iff", "code": "theorem toDual_le_iff {a : WithTop \u03b1} {b : WithBot \u03b1\u1d52\u1d48} :\n    WithTop.toDual a \u2264 b \u2194 WithBot.ofDual b \u2264 a", "start": [814, 1], "end": [816, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_toDual_iff", "code": "theorem le_toDual_iff {a : WithBot \u03b1\u1d52\u1d48} {b : WithTop \u03b1} :\n    a \u2264 WithTop.toDual b \u2194 b \u2264 WithBot.ofDual a", "start": [819, 1], "end": [821, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_le_toDual_iff", "code": "@[simp]\ntheorem toDual_le_toDual_iff {a b : WithTop \u03b1} : WithTop.toDual a \u2264 WithTop.toDual b \u2194 b \u2264 a", "start": [824, 1], "end": [826, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_le_iff", "code": "theorem ofDual_le_iff {a : WithTop \u03b1\u1d52\u1d48} {b : WithBot \u03b1} :\n    WithTop.ofDual a \u2264 b \u2194 WithBot.toDual b \u2264 a", "start": [829, 1], "end": [831, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_ofDual_iff", "code": "theorem le_ofDual_iff {a : WithBot \u03b1} {b : WithTop \u03b1\u1d52\u1d48} :\n    a \u2264 WithTop.ofDual b \u2194 b \u2264 WithBot.toDual a", "start": [834, 1], "end": [836, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_le_ofDual_iff", "code": "@[simp]\ntheorem ofDual_le_ofDual_iff {a b : WithTop \u03b1\u1d52\u1d48} : WithTop.ofDual a \u2264 WithTop.ofDual b \u2194 b \u2264 a", "start": [839, 1], "end": [841, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe : (a : WithTop \u03b1) \u2264 b \u2194 a \u2264 b", "start": [844, 1], "end": [846, 93], "kind": "commanddeclaration"}, {"full_name": "WithTop.some_le_some", "code": "@[simp]\ntheorem some_le_some : @LE.le (WithTop \u03b1) _ (Option.some a) (Option.some b) \u2194 a \u2264 b", "start": [849, 1], "end": [851, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_none", "code": "@[simp]\ntheorem le_none {a : WithTop \u03b1} : @LE.le (WithTop \u03b1) _ a none", "start": [854, 1], "end": [856, 53], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderTop", "code": "instance orderTop : OrderTop (WithTop \u03b1) :=\n  { WithTop.top with le_top := fun _ => le_none }", "start": [859, 1], "end": [860, 50], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderBot", "code": "instance orderBot [OrderBot \u03b1] : OrderBot (WithTop \u03b1) where\n  bot := some \u22a5\n  bot_le o a ha := by cases ha; exact \u27e8_, rfl, bot_le\u27e9", "start": [862, 1], "end": [864, 55], "kind": "commanddeclaration"}, {"full_name": "WithTop.boundedOrder", "code": "instance boundedOrder [OrderBot \u03b1] : BoundedOrder (WithTop \u03b1) :=\n  { WithTop.orderTop, WithTop.orderBot with }", "start": [867, 1], "end": [868, 46], "kind": "commanddeclaration"}, {"full_name": "WithTop.not_top_le_coe", "code": "theorem not_top_le_coe (a : \u03b1) : \u00ac(\u22a4 : WithTop \u03b1) \u2264 \u2191a", "start": [870, 1], "end": [871, 36], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_le_iff", "code": "@[simp]\nprotected theorem top_le_iff : \u2200 {a : WithTop \u03b1}, \u22a4 \u2264 a \u2194 a = \u22a4", "start": [874, 1], "end": [878, 17], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_coe", "code": "theorem le_coe : \u2200 {o : Option \u03b1}, a \u2208 o \u2192 (@LE.le (WithTop \u03b1) _ o b \u2194 a \u2264 b)", "start": [880, 1], "end": [881, 25], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_coe_iff", "code": "theorem le_coe_iff {x : WithTop \u03b1} : x \u2264 b \u2194 \u2203 a : \u03b1, x = a \u2227 a \u2264 b", "start": [884, 1], "end": [885, 43], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_le_iff", "code": "theorem coe_le_iff {x : WithTop \u03b1} : \u2191a \u2264 x \u2194 \u2200 b : \u03b1, x = \u2191b \u2192 a \u2264 b", "start": [888, 1], "end": [889, 43], "kind": "commanddeclaration"}, {"full_name": "IsMin.withTop", "code": "protected theorem _root_.IsMin.withTop (h : IsMin a) : IsMin (a : WithTop \u03b1)", "start": [892, 1], "end": [896, 84], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop_le_iff", "code": "theorem untop_le_iff {a : WithTop \u03b1} {b : \u03b1} (h : a \u2260 \u22a4) :\n    untop a h \u2264 b \u2194 a \u2264 (b : WithTop \u03b1)", "start": [899, 1], "end": [901, 36], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_untop_iff", "code": "theorem le_untop_iff {a : \u03b1} {b : WithTop \u03b1} (h : b \u2260 \u22a4) :\n    a \u2264 untop b h \u2194 (a : WithTop \u03b1) \u2264 b", "start": [903, 1], "end": [905, 36], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt", "code": "instance (priority := 10) lt : LT (WithTop \u03b1) :=\n  \u27e8fun o\u2081 o\u2082 : Option \u03b1 => \u2203 b \u2208 o\u2081, \u2200 a \u2208 o\u2082, b < a\u27e9", "start": [913, 1], "end": [914, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_lt_iff", "code": "theorem toDual_lt_iff {a : WithTop \u03b1} {b : WithBot \u03b1\u1d52\u1d48} :\n    WithTop.toDual a < b \u2194 WithBot.ofDual b < a", "start": [916, 1], "end": [918, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_toDual_iff", "code": "theorem lt_toDual_iff {a : WithBot \u03b1\u1d52\u1d48} {b : WithTop \u03b1} :\n    a < WithTop.toDual b \u2194 b < WithBot.ofDual a", "start": [921, 1], "end": [923, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDual_lt_toDual_iff", "code": "@[simp]\ntheorem toDual_lt_toDual_iff {a b : WithTop \u03b1} : WithTop.toDual a < WithTop.toDual b \u2194 b < a", "start": [926, 1], "end": [928, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_lt_iff", "code": "theorem ofDual_lt_iff {a : WithTop \u03b1\u1d52\u1d48} {b : WithBot \u03b1} :\n    WithTop.ofDual a < b \u2194 WithBot.toDual b < a", "start": [931, 1], "end": [933, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_ofDual_iff", "code": "theorem lt_ofDual_iff {a : WithBot \u03b1} {b : WithTop \u03b1\u1d52\u1d48} :\n    a < WithTop.ofDual b \u2194 b < WithBot.toDual a", "start": [936, 1], "end": [938, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.ofDual_lt_ofDual_iff", "code": "@[simp]\ntheorem ofDual_lt_ofDual_iff {a b : WithTop \u03b1\u1d52\u1d48} : WithTop.ofDual a < WithTop.ofDual b \u2194 b < a", "start": [941, 1], "end": [943, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_symm_apply", "code": "@[simp]\ntheorem toDual_symm_apply (a : WithTop \u03b1\u1d52\u1d48) : WithBot.toDual.symm a = WithTop.ofDual a", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_symm_apply", "code": "@[simp]\ntheorem ofDual_symm_apply (a : WithTop \u03b1) : WithBot.ofDual.symm a = WithTop.toDual a", "start": [959, 1], "end": [961, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_apply_bot", "code": "@[simp]\ntheorem toDual_apply_bot : WithBot.toDual (\u22a5 : WithBot \u03b1) = \u22a4", "start": [964, 1], "end": [966, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_apply_bot", "code": "@[simp]\ntheorem ofDual_apply_bot : WithBot.ofDual (\u22a5 : WithBot \u03b1) = \u22a4", "start": [969, 1], "end": [971, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_apply_coe", "code": "@[simp]\ntheorem toDual_apply_coe (a : \u03b1) : WithBot.toDual (a : WithBot \u03b1) = toDual a", "start": [974, 1], "end": [976, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_apply_coe", "code": "@[simp]\ntheorem ofDual_apply_coe (a : \u03b1\u1d52\u1d48) : WithBot.ofDual (a : WithBot \u03b1\u1d52\u1d48) = ofDual a", "start": [979, 1], "end": [981, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_toDual", "code": "theorem map_toDual (f : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) (a : WithTop \u03b1) :\n    WithBot.map f (WithTop.toDual a) = a.map (toDual \u2218 f)", "start": [984, 1], "end": [986, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.map_ofDual", "code": "theorem map_ofDual (f : \u03b1 \u2192 \u03b2) (a : WithTop \u03b1\u1d52\u1d48) :\n    WithBot.map f (WithTop.ofDual a) = a.map (ofDual \u2218 f)", "start": [989, 1], "end": [991, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_map", "code": "theorem toDual_map (f : \u03b1 \u2192 \u03b2) (a : WithBot \u03b1) :\n    WithBot.toDual (WithBot.map f a) = map (toDual \u2218 f \u2218 ofDual) (WithBot.toDual a)", "start": [994, 1], "end": [996, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_map", "code": "theorem ofDual_map (f : \u03b1\u1d52\u1d48 \u2192 \u03b2\u1d52\u1d48) (a : WithBot \u03b1\u1d52\u1d48) :\n    WithBot.ofDual (WithBot.map f a) = map (ofDual \u2218 f \u2218 toDual) (WithBot.ofDual a)", "start": [999, 1], "end": [1001, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_le_iff", "code": "theorem toDual_le_iff {a : WithBot \u03b1} {b : WithTop \u03b1\u1d52\u1d48} :\n    WithBot.toDual a \u2264 b \u2194 WithTop.ofDual b \u2264 a", "start": [1008, 1], "end": [1010, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_toDual_iff", "code": "theorem le_toDual_iff {a : WithTop \u03b1\u1d52\u1d48} {b : WithBot \u03b1} :\n    a \u2264 WithBot.toDual b \u2194 b \u2264 WithTop.ofDual a", "start": [1013, 1], "end": [1015, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_le_toDual_iff", "code": "@[simp]\ntheorem toDual_le_toDual_iff {a b : WithBot \u03b1} : WithBot.toDual a \u2264 WithBot.toDual b \u2194 b \u2264 a", "start": [1018, 1], "end": [1020, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_le_iff", "code": "theorem ofDual_le_iff {a : WithBot \u03b1\u1d52\u1d48} {b : WithTop \u03b1} :\n    WithBot.ofDual a \u2264 b \u2194 WithTop.toDual b \u2264 a", "start": [1023, 1], "end": [1025, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.le_ofDual_iff", "code": "theorem le_ofDual_iff {a : WithTop \u03b1} {b : WithBot \u03b1\u1d52\u1d48} :\n    a \u2264 WithBot.ofDual b \u2194 b \u2264 WithTop.toDual a", "start": [1028, 1], "end": [1030, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_le_ofDual_iff", "code": "@[simp]\ntheorem ofDual_le_ofDual_iff {a b : WithBot \u03b1\u1d52\u1d48} : WithBot.ofDual a \u2264 WithBot.ofDual b \u2194 b \u2264 a", "start": [1033, 1], "end": [1035, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_lt_iff", "code": "theorem toDual_lt_iff {a : WithBot \u03b1} {b : WithTop \u03b1\u1d52\u1d48} :\n    WithBot.toDual a < b \u2194 WithTop.ofDual b < a", "start": [1044, 1], "end": [1046, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt_toDual_iff", "code": "theorem lt_toDual_iff {a : WithTop \u03b1\u1d52\u1d48} {b : WithBot \u03b1} :\n    a < WithBot.toDual b \u2194 b < WithTop.ofDual a", "start": [1049, 1], "end": [1051, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDual_lt_toDual_iff", "code": "@[simp]\ntheorem toDual_lt_toDual_iff {a b : WithBot \u03b1} : WithBot.toDual a < WithBot.toDual b \u2194 b < a", "start": [1054, 1], "end": [1056, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_lt_iff", "code": "theorem ofDual_lt_iff {a : WithBot \u03b1\u1d52\u1d48} {b : WithTop \u03b1} :\n    WithBot.ofDual a < b \u2194 WithTop.toDual b < a", "start": [1059, 1], "end": [1061, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.lt_ofDual_iff", "code": "theorem lt_ofDual_iff {a : WithTop \u03b1} {b : WithBot \u03b1\u1d52\u1d48} :\n    a < WithBot.ofDual b \u2194 b < WithTop.toDual a", "start": [1064, 1], "end": [1066, 10], "kind": "commanddeclaration"}, {"full_name": "WithBot.ofDual_lt_ofDual_iff", "code": "@[simp]\ntheorem ofDual_lt_ofDual_iff {a b : WithBot \u03b1\u1d52\u1d48} : WithBot.ofDual a < WithBot.ofDual b \u2194 b < a", "start": [1069, 1], "end": [1071, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe : (a : WithTop \u03b1) < b \u2194 a < b", "start": [1086, 1], "end": [1088, 93], "kind": "commanddeclaration"}, {"full_name": "WithTop.some_lt_some", "code": "@[simp]\ntheorem some_lt_some : @LT.lt (WithTop \u03b1) _ (Option.some a) (Option.some b) \u2194 a < b", "start": [1091, 1], "end": [1093, 13], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_lt_top", "code": "theorem coe_lt_top (a : \u03b1) : (a : WithTop \u03b1) < \u22a4", "start": [1096, 1], "end": [1097, 52], "kind": "commanddeclaration"}, {"full_name": "WithTop.some_lt_none", "code": "@[simp]\ntheorem some_lt_none (a : \u03b1) : @LT.lt (WithTop \u03b1) _ (Option.some a) none", "start": [1100, 1], "end": [1102, 15], "kind": "commanddeclaration"}, {"full_name": "WithTop.not_none_lt", "code": "@[simp]\ntheorem not_none_lt (a : WithTop \u03b1) : \u00ac@LT.lt (WithTop \u03b1) _ none a", "start": [1105, 1], "end": [1108, 30], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_iff_exists_coe", "code": "theorem lt_iff_exists_coe {a b : WithTop \u03b1} : a < b \u2194 \u2203 p : \u03b1, a = p \u2227 \u2191p < b", "start": [1111, 1], "end": [1113, 54], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_lt_iff", "code": "theorem coe_lt_iff {x : WithTop \u03b1} : \u2191a < x \u2194 \u2200 b, x = \u2191b \u2192 a < b", "start": [1116, 1], "end": [1116, 77], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_top_iff_ne_top", "code": "protected theorem lt_top_iff_ne_top {x : WithTop \u03b1} : x < \u22a4 \u2194 x \u2260 \u22a4", "start": [1119, 1], "end": [1122, 37], "kind": "commanddeclaration"}, {"full_name": "WithTop.preorder", "code": "instance preorder [Preorder \u03b1] : Preorder (WithTop \u03b1) where\n  le := (\u00b7 \u2264 \u00b7)\n  lt := (\u00b7 < \u00b7)\n  lt_iff_le_not_le := by simp [\u2190 toDual_lt_toDual_iff, lt_iff_le_not_le]\n  le_refl _ := toDual_le_toDual_iff.mp le_rfl\n  le_trans _ _ _ := by\n    simp_rw [\u2190 toDual_le_toDual_iff]\n    exact Function.swap le_trans", "start": [1127, 1], "end": [1134, 33], "kind": "commanddeclaration"}, {"full_name": "WithTop.partialOrder", "code": "instance partialOrder [PartialOrder \u03b1] : PartialOrder (WithTop \u03b1) :=\n  { WithTop.preorder with\n    le_antisymm := fun _ _ => by\n      simp_rw [\u2190 toDual_le_toDual_iff]\n      exact Function.swap le_antisymm }", "start": [1136, 1], "end": [1140, 40], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_strictMono", "code": "theorem coe_strictMono [Preorder \u03b1] : StrictMono (fun a : \u03b1 => (a : WithTop \u03b1))", "start": [1143, 1], "end": [1144, 28], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_mono", "code": "theorem coe_mono [Preorder \u03b1] : Monotone (fun a : \u03b1 => (a : WithTop \u03b1))", "start": [1147, 1], "end": [1148, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.monotone_iff", "code": "theorem monotone_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithTop \u03b1 \u2192 \u03b2} :\n    Monotone f \u2194 Monotone (fun (a : \u03b1) => f a) \u2227 \u2200 x : \u03b1, f x \u2264 f \u22a4", "start": [1151, 1], "end": [1156, 81], "kind": "commanddeclaration"}, {"full_name": "WithTop.monotone_map_iff", "code": "@[simp]\ntheorem monotone_map_iff [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Monotone (WithTop.map f) \u2194 Monotone f", "start": [1159, 1], "end": [1162, 43], "kind": "commanddeclaration"}, {"full_name": "Monotone.withTop_map", "code": "alias \u27e8_, _root_.Monotone.withTop_map\u27e9 := monotone_map_iff", "start": [1165, 1], "end": [1165, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WithTop.strictMono_iff", "code": "theorem strictMono_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithTop \u03b1 \u2192 \u03b2} :\n    StrictMono f \u2194 StrictMono (fun (a : \u03b1) => f a) \u2227 \u2200 x : \u03b1, f x < f \u22a4", "start": [1168, 1], "end": [1173, 81], "kind": "commanddeclaration"}, {"full_name": "WithTop.strictAnti_iff", "code": "theorem strictAnti_iff [Preorder \u03b1] [Preorder \u03b2] {f : WithTop \u03b1 \u2192 \u03b2} :\n    StrictAnti f \u2194 StrictAnti (\u03bb a => f a : \u03b1 \u2192 \u03b2) \u2227 \u2200 x : \u03b1, f \u22a4 < f x", "start": [1176, 1], "end": [1178, 28], "kind": "commanddeclaration"}, {"full_name": "WithTop.strictMono_map_iff", "code": "@[simp]\ntheorem strictMono_map_iff [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    StrictMono (WithTop.map f) \u2194 StrictMono f", "start": [1180, 1], "end": [1183, 59], "kind": "commanddeclaration"}, {"full_name": "StrictMono.withTop_map", "code": "alias \u27e8_, _root_.StrictMono.withTop_map\u27e9 := strictMono_map_iff", "start": [1186, 1], "end": [1186, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WithTop.map_le_iff", "code": "theorem map_le_iff [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (a b : WithTop \u03b1)\n    (mono_iff : \u2200 {a b}, f a \u2264 f b \u2194 a \u2264 b) :\n    a.map f \u2264 b.map f \u2194 a \u2264 b", "start": [1189, 1], "end": [1193, 18], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_untop'_le", "code": "theorem coe_untop'_le [Preorder \u03b1] : \u2200 (a : WithTop \u03b1) (b : \u03b1), a.untop' b \u2264 a", "start": [1196, 1], "end": [1198, 19], "kind": "commanddeclaration"}, {"full_name": "WithTop.le_untop'_iff", "code": "theorem le_untop'_iff [LE \u03b1] {a : WithTop \u03b1} {b c : \u03b1} (h : a = \u22a4 \u2192 c \u2264 b) :\n    c \u2264 a.untop' b \u2194 c \u2264 a", "start": [1200, 1], "end": [1204, 23], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_untop'_iff", "code": "theorem lt_untop'_iff [LT \u03b1] {a : WithTop \u03b1} {b c : \u03b1} (h : a = \u22a4 \u2192 c < b) :\n    c < a.untop' b \u2194 c < a", "start": [1206, 1], "end": [1210, 23], "kind": "commanddeclaration"}, {"full_name": "WithTop.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] : SemilatticeInf (WithTop \u03b1) :=\n  { WithTop.partialOrder with\n    inf := Option.liftOrGet (\u00b7 \u2293 \u00b7),\n    inf_le_left := fun o\u2081 o\u2082 a ha => by cases ha; cases o\u2082 <;> simp [Option.liftOrGet],\n    inf_le_right := fun o\u2081 o\u2082 a ha => by cases ha; cases o\u2081 <;> simp [Option.liftOrGet],\n    le_inf := fun o\u2081 o\u2082 o\u2083 h\u2081 h\u2082 a ha => by\n      cases' o\u2082 with b <;> cases' o\u2083 with c <;> cases ha\n      \u00b7 exact h\u2082 a rfl\n\n      \u00b7 exact h\u2081 a rfl\n\n      \u00b7 rcases h\u2081 b rfl with \u27e8d, \u27e8\u27e9, h\u2081'\u27e9\n        simp at h\u2082\n        exact \u27e8d, rfl, le_inf h\u2081' h\u2082\u27e9\n         }", "start": [1212, 1], "end": [1226, 11], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_inf", "code": "theorem coe_inf [SemilatticeInf \u03b1] (a b : \u03b1) : ((a \u2293 b : \u03b1) : WithTop \u03b1) = (a : WithTop \u03b1) \u2293 b", "start": [1228, 1], "end": [1229, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] : SemilatticeSup (WithTop \u03b1) :=\n  { WithTop.partialOrder with\n    sup := Option.map\u2082 (\u00b7 \u2294 \u00b7),\n    le_sup_left := fun o\u2081 o\u2082 a ha => by\n      rcases Option.mem_map\u2082_iff.1 ha with \u27e8a, b, (rfl : _ = _), (rfl : _ = _), rfl\u27e9\n      exact \u27e8_, rfl, le_sup_left\u27e9,\n    le_sup_right := fun o\u2081 o\u2082 a ha => by\n      rcases Option.mem_map\u2082_iff.1 ha with \u27e8a, b, (rfl : _ = _), (rfl : _ = _), rfl\u27e9\n      exact \u27e8_, rfl, le_sup_right\u27e9,\n    sup_le := fun o\u2081 o\u2082 o\u2083 h\u2081 h\u2082 a ha => by\n      cases ha\n      rcases h\u2081 a rfl with \u27e8b, \u27e8\u27e9, ab\u27e9\n      rcases h\u2082 a rfl with \u27e8c, \u27e8\u27e9, ac\u27e9\n      exact \u27e8_, rfl, sup_le ab ac\u27e9 }", "start": [1232, 1], "end": [1245, 37], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sup", "code": "theorem coe_sup [SemilatticeSup \u03b1] (a b : \u03b1) : ((a \u2294 b : \u03b1) : WithTop \u03b1) = (a : WithTop \u03b1) \u2294 b", "start": [1247, 1], "end": [1248, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.lattice", "code": "instance lattice [Lattice \u03b1] : Lattice (WithTop \u03b1) :=\n  { WithTop.semilatticeSup, WithTop.semilatticeInf with }", "start": [1251, 1], "end": [1252, 58], "kind": "commanddeclaration"}, {"full_name": "WithTop.distribLattice", "code": "instance distribLattice [DistribLattice \u03b1] : DistribLattice (WithTop \u03b1) :=\n  { WithTop.lattice with\n    le_sup_inf := fun o\u2081 o\u2082 o\u2083 =>\n      match o\u2081, o\u2082, o\u2083 with\n      | \u22a4, _, _ => le_rfl\n      | (a\u2081 : \u03b1), \u22a4, \u22a4 => le_rfl\n      | (a\u2081 : \u03b1), \u22a4, (a\u2083 : \u03b1) => le_rfl\n      | (a\u2081 : \u03b1), (a\u2082 : \u03b1), \u22a4 => le_rfl\n      | (a\u2081 : \u03b1), (a\u2082 : \u03b1), (a\u2083 : \u03b1) => coe_le_coe.mpr le_sup_inf }", "start": [1254, 1], "end": [1262, 68], "kind": "commanddeclaration"}, {"full_name": "WithTop.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] : DecidableEq (WithTop \u03b1) := instDecidableEqOption", "start": [1265, 1], "end": [1265, 88], "kind": "commanddeclaration"}, {"full_name": "WithTop.decidableLE", "code": "instance decidableLE [LE \u03b1] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] :\n    @DecidableRel (WithTop \u03b1) (\u00b7 \u2264 \u00b7) := fun _ _ =>\n  decidable_of_decidable_of_iff toDual_le_toDual_iff", "start": [1267, 1], "end": [1269, 53], "kind": "commanddeclaration"}, {"full_name": "WithTop.decidableLT", "code": "instance decidableLT [LT \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] :\n    @DecidableRel (WithTop \u03b1) (\u00b7 < \u00b7) := fun _ _ =>\n  decidable_of_decidable_of_iff toDual_lt_toDual_iff", "start": [1272, 1], "end": [1274, 53], "kind": "commanddeclaration"}, {"full_name": "WithTop.isTotal_le", "code": "instance isTotal_le [LE \u03b1] [IsTotal \u03b1 (\u00b7 \u2264 \u00b7)] : IsTotal (WithTop \u03b1) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ => by\n    simp_rw [\u2190 toDual_le_toDual_iff]\n    exact total_of _ _ _\u27e9", "start": [1277, 1], "end": [1280, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.linearOrder", "code": "instance linearOrder [LinearOrder \u03b1] : LinearOrder (WithTop \u03b1) :=\n  Lattice.toLinearOrder _", "start": [1283, 1], "end": [1284, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min [LinearOrder \u03b1] (x y : \u03b1) : (\u2191(min x y) : WithTop \u03b1) = min (x : WithTop \u03b1) y", "start": [1287, 1], "end": [1289, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max [LinearOrder \u03b1] (x y : \u03b1) : (\u2191(max x y) : WithTop \u03b1) = max (x : WithTop \u03b1) y", "start": [1292, 1], "end": [1294, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.wellFounded_lt", "code": "theorem wellFounded_lt [LT \u03b1] (h : @WellFounded \u03b1 (\u00b7 < \u00b7)) :\n    @WellFounded (WithTop \u03b1) (\u00b7 < \u00b7)", "start": [1297, 1], "end": [1309, 43], "kind": "commanddeclaration"}, {"full_name": "WithTop.wellFounded_gt", "code": "theorem wellFounded_gt [LT \u03b1] (h : @WellFounded \u03b1 (\u00b7 > \u00b7)) :\n    @WellFounded (WithTop \u03b1) (\u00b7 > \u00b7)", "start": [1314, 1], "end": [1326, 82], "kind": "commanddeclaration"}, {"full_name": "WithBot.wellFounded_gt", "code": "theorem _root_.WithBot.wellFounded_gt [LT \u03b1] (h : @WellFounded \u03b1 (\u00b7 > \u00b7)) :\n    @WellFounded (WithBot \u03b1) (\u00b7 > \u00b7)", "start": [1329, 1], "end": [1341, 82], "kind": "commanddeclaration"}, {"full_name": "WithTop.trichotomous.lt", "code": "instance trichotomous.lt [Preorder \u03b1] [IsTrichotomous \u03b1 (\u00b7 < \u00b7)] :\n    IsTrichotomous (WithTop \u03b1) (\u00b7 < \u00b7) :=\n  \u27e8by\n    rintro (a | a) (b | b)\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 simpa [some_eq_coe, IsTrichotomous, coe_eq_coe] using @trichotomous \u03b1 (\u00b7 < \u00b7) _ a b\u27e9", "start": [1344, 1], "end": [1351, 91], "kind": "commanddeclaration"}, {"full_name": "WithTop.IsWellOrder.lt", "code": "instance IsWellOrder.lt [Preorder \u03b1] [h : IsWellOrder \u03b1 (\u00b7 < \u00b7)] :\n    IsWellOrder (WithTop \u03b1) (\u00b7 < \u00b7) where wf := wellFounded_lt h.wf", "start": [1354, 1], "end": [1355, 68], "kind": "commanddeclaration"}, {"full_name": "WithTop.trichotomous.gt", "code": "instance trichotomous.gt [Preorder \u03b1] [IsTrichotomous \u03b1 (\u00b7 > \u00b7)] :\n    IsTrichotomous (WithTop \u03b1) (\u00b7 > \u00b7) :=\n  \u27e8by\n    rintro (a | a) (b | b)\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 simp\n    \u00b7 simpa [some_eq_coe, IsTrichotomous, coe_eq_coe] using @trichotomous \u03b1 (\u00b7 > \u00b7) _ a b\u27e9", "start": [1358, 1], "end": [1365, 91], "kind": "commanddeclaration"}, {"full_name": "WithTop.IsWellOrder.gt", "code": "instance IsWellOrder.gt [Preorder \u03b1] [h : IsWellOrder \u03b1 (\u00b7 > \u00b7)] :\n    IsWellOrder (WithTop \u03b1) (\u00b7 > \u00b7) where wf := wellFounded_gt h.wf", "start": [1368, 1], "end": [1369, 68], "kind": "commanddeclaration"}, {"full_name": "WithBot.trichotomous.lt", "code": "instance _root_.WithBot.trichotomous.lt [Preorder \u03b1] [h : IsTrichotomous \u03b1 (\u00b7 < \u00b7)] :\n    IsTrichotomous (WithBot \u03b1) (\u00b7 < \u00b7) :=\n  @WithTop.trichotomous.gt \u03b1\u1d52\u1d48 _ h", "start": [1372, 1], "end": [1374, 35], "kind": "commanddeclaration"}, {"full_name": "WithBot.isWellOrder.lt", "code": "instance _root_.WithBot.isWellOrder.lt [Preorder \u03b1] [h : IsWellOrder \u03b1 (\u00b7 < \u00b7)] :\n    IsWellOrder (WithBot \u03b1) (\u00b7 < \u00b7) :=\n  @WithTop.IsWellOrder.gt \u03b1\u1d52\u1d48 _ h", "start": [1377, 1], "end": [1379, 34], "kind": "commanddeclaration"}, {"full_name": "WithBot.trichotomous.gt", "code": "instance _root_.WithBot.trichotomous.gt [Preorder \u03b1] [h : IsTrichotomous \u03b1 (\u00b7 > \u00b7)] :\n    IsTrichotomous (WithBot \u03b1) (\u00b7 > \u00b7) :=\n  @WithTop.trichotomous.lt \u03b1\u1d52\u1d48 _ h", "start": [1382, 1], "end": [1384, 35], "kind": "commanddeclaration"}, {"full_name": "WithBot.isWellOrder.gt", "code": "instance _root_.WithBot.isWellOrder.gt [Preorder \u03b1] [h : IsWellOrder \u03b1 (\u00b7 > \u00b7)] :\n    IsWellOrder (WithBot \u03b1) (\u00b7 > \u00b7) :=\n  @WithTop.IsWellOrder.lt \u03b1\u1d52\u1d48 _ h", "start": [1387, 1], "end": [1389, 34], "kind": "commanddeclaration"}, {"full_name": "WithTop.lt_iff_exists_coe_btwn", "code": "theorem lt_iff_exists_coe_btwn [Preorder \u03b1] [DenselyOrdered \u03b1] [NoMaxOrder \u03b1] {a b : WithTop \u03b1} :\n    a < b \u2194 \u2203 x : \u03b1, a < \u2191x \u2227 \u2191x < b", "start": [1395, 1], "end": [1401, 39], "kind": "commanddeclaration"}, {"full_name": "WithTop.noBotOrder", "code": "instance noBotOrder [LE \u03b1] [NoBotOrder \u03b1] [Nonempty \u03b1] : NoBotOrder (WithTop \u03b1) :=\n  @OrderDual.noBotOrder (WithBot \u03b1\u1d52\u1d48) _ _", "start": [1404, 1], "end": [1405, 42], "kind": "commanddeclaration"}, {"full_name": "WithTop.noMinOrder", "code": "instance noMinOrder [LT \u03b1] [NoMinOrder \u03b1] [Nonempty \u03b1] : NoMinOrder (WithTop \u03b1) :=\n  @OrderDual.noMinOrder (WithBot \u03b1\u1d52\u1d48) _ _", "start": [1407, 1], "end": [1408, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Defs.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderedCommMonoid", "code": "class OrderedCommMonoid (\u03b1 : Type*) extends CommMonoid \u03b1, PartialOrder \u03b1 where\n  \n  protected mul_le_mul_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c * a \u2264 c * b", "start": [25, 1], "end": [30, 72], "kind": "commanddeclaration"}, {"full_name": "OrderedAddCommMonoid", "code": "class OrderedAddCommMonoid (\u03b1 : Type*) extends AddCommMonoid \u03b1, PartialOrder \u03b1 where\n  \n  protected add_le_add_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c + a \u2264 c + b", "start": [33, 1], "end": [38, 72], "kind": "commanddeclaration"}, {"full_name": "OrderedCommMonoid.to_covariantClass_left", "code": "@[to_additive]\ninstance OrderedCommMonoid.to_covariantClass_left (M : Type*) [OrderedCommMonoid M] :\n    CovariantClass M M (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) where\n  elim := fun a _ _ bc \u21a6 OrderedCommMonoid.mul_le_mul_left _ _ bc a", "start": [45, 1], "end": [48, 68], "kind": "commanddeclaration"}, {"full_name": "OrderedCommMonoid.to_covariantClass_right", "code": "@[to_additive]\ninstance OrderedCommMonoid.to_covariantClass_right (M : Type*) [OrderedCommMonoid M] :\n    CovariantClass M M (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  covariant_swap_mul_of_covariant_mul M _", "start": [54, 1], "end": [57, 42], "kind": "commanddeclaration"}, {"full_name": "bit0_pos", "code": "@[deprecated] theorem bit0_pos [OrderedAddCommMonoid \u03b1] {a : \u03b1} (h : 0 < a) : 0 < bit0 a", "start": [69, 1], "end": [70, 15], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommMonoid", "code": "class LinearOrderedAddCommMonoid (\u03b1 : Type*) extends LinearOrder \u03b1, OrderedAddCommMonoid \u03b1", "start": [73, 1], "end": [74, 91], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommMonoid", "code": "@[to_additive]\nclass LinearOrderedCommMonoid (\u03b1 : Type*) extends LinearOrder \u03b1, OrderedCommMonoid \u03b1", "start": [77, 1], "end": [79, 85], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommMonoidWithTop", "code": "class LinearOrderedAddCommMonoidWithTop (\u03b1 : Type*) extends LinearOrderedAddCommMonoid \u03b1,\n    Top \u03b1 where\n  \n  protected le_top : \u2200 x : \u03b1, x \u2264 \u22a4\n  \n  protected top_add' : \u2200 x : \u03b1, \u22a4 + x = \u22a4", "start": [84, 1], "end": [91, 42], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommMonoidWithTop.toOrderTop", "code": "instance (priority := 100) LinearOrderedAddCommMonoidWithTop.toOrderTop (\u03b1 : Type u)\n    [h : LinearOrderedAddCommMonoidWithTop \u03b1] : OrderTop \u03b1 :=\n  { h with }", "start": [95, 1], "end": [97, 13], "kind": "commanddeclaration"}, {"full_name": "top_add", "code": "@[simp]\ntheorem top_add (a : \u03b1) : \u22a4 + a = \u22a4", "start": [104, 1], "end": [106, 47], "kind": "commanddeclaration"}, {"full_name": "add_top", "code": "@[simp]\ntheorem add_top (a : \u03b1) : a + \u22a4 = \u22a4", "start": [109, 1], "end": [111, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Nontriviality/Core.lean", "imports": ["Mathlib/Tactic/SolveByElim.lean", "lake-packages/Qq/Qq/MetaM.lean", "Mathlib/Logic/Nontrivial/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Nontriviality.subsingleton_or_nontrivial_elim", "code": "theorem subsingleton_or_nontrivial_elim {p : Prop} {\u03b1 : Type u}\n    (h\u2081 : Subsingleton \u03b1 \u2192 p) (h\u2082 : Nontrivial \u03b1 \u2192 p) : p", "start": [17, 1], "end": [19, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Nontriviality.nontrivialityByElim", "code": "def nontrivialityByElim (\u03b1 : Q(Type u)) (g : MVarId) (simpArgs : Array Syntax) : MetaM MVarId := do\n  let p : Q(Prop) \u2190 g.getType\n  guard (\u2190instantiateMVars (\u2190 inferType p)).isProp\n  g.withContext do\n    let g\u2081 \u2190 mkFreshExprMVarQ q(Subsingleton $\u03b1 \u2192 $p)\n    let (_, g\u2081') \u2190 g\u2081.mvarId!.intro1\n    g\u2081'.withContext try\n      (do g\u2081'.assign (\u2190 synthInstance (\u2190 g\u2081'.getType))) <|> do\n        let simpArgs := simpArgs.push (Unhygienic.run `(Parser.Tactic.simpLemma| nontriviality))\n        let stx := open TSyntax.Compat in Unhygienic.run `(tactic| simp [$simpArgs,*])\n        let ([], _) \u2190 runTactic g\u2081' stx | failure\n    catch _ => throwError\n      \"Could not prove goal assuming `{q(Subsingleton $\u03b1)}`\\n{MessageData.ofGoal g\u2081'}\"\n    let g\u2082 : Q(Nontrivial $\u03b1 \u2192 $p) \u2190 mkFreshExprMVarQ q(Nontrivial $\u03b1 \u2192 $p)\n    g.assign q(subsingleton_or_nontrivial_elim $g\u2081 $g\u2082)\n    pure g\u2082.mvarId!", "start": [21, 1], "end": [44, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Nontriviality.nontrivialityByAssumption", "code": "def nontrivialityByAssumption (g : MVarId) : MetaM Unit := do\n  g.inferInstance <|> do\n    _ \u2190 SolveByElim.solveByElim.processSyntax {maxDepth := 6}\n      false false [\u2190 `(nontrivial_of_ne), \u2190 `(nontrivial_of_lt)] [] #[] [g]", "start": [46, 1], "end": [53, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Nontriviality.elabNontriviality", "code": "@[tactic nontriviality] def elabNontriviality : Tactic := fun stx => do\n    let g \u2190 getMainGoal\n    let \u03b1 \u2190 match stx[1].getOptional? with\n    | some e => Term.elabType e\n    | none => (do\n      let mut tgt \u2190 withReducible g.getType'\n      if let some tgt' := tgt.not? then tgt \u2190 withReducible (whnf tgt')\n      if let some (\u03b1, _) := tgt.eq? then return \u03b1\n      if let some (\u03b1, _) := tgt.app4? ``LE.le then return \u03b1\n      if let some (\u03b1, _) := tgt.app4? ``LT.lt then return \u03b1\n      throwError \"The goal is not an (in)equality, so you'll need to specify the desired {\"\"\n        }`Nontrivial \u03b1` instance by invoking `nontriviality \u03b1`.\")\n    let .sort u \u2190 whnf (\u2190 inferType \u03b1) | unreachable!\n    let some v := u.dec | throwError \"not a type{indentExpr \u03b1}\"\n    let \u03b1 : Q(Type v) := \u03b1\n    let tac := do\n      let ty := q(Nontrivial $\u03b1)\n      let m \u2190 mkFreshExprMVar (some ty)\n      nontrivialityByAssumption m.mvarId!\n      g.assert `inst ty m\n    let g \u2190 liftM <| tac <|> nontrivialityByElim \u03b1 g stx[2][1].getSepArgs\n    replaceMainGoal [(\u2190 g.intro1).2]", "start": [100, 1], "end": [122, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Basic.lean", "imports": ["Mathlib/Tactic/Cases.lean", "Mathlib/Tactic/SimpRw.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "comp_mul_left", "code": "@[to_additive (attr := simp) \"Composing two additions on the left by `y` then `x`\nis equal to an addition on the left by `x + y`.\"]\ntheorem comp_mul_left [Semigroup \u03b1] (x y : \u03b1) : (x * \u00b7) \u2218 (y * \u00b7) = (x * y * \u00b7)", "start": [29, 1], "end": [36, 19], "kind": "commanddeclaration"}, {"full_name": "comp_mul_right", "code": "@[to_additive (attr := simp) \"Composing two additions on the right by `y` and `x`\nis equal to an addition on the right by `y + x`.\"]\ntheorem comp_mul_right [Semigroup \u03b1] (x y : \u03b1) : (\u00b7 * x) \u2218 (\u00b7 * y) = (\u00b7 * (y * x))", "start": [40, 1], "end": [47, 19], "kind": "commanddeclaration"}, {"full_name": "ite_mul_one", "code": "@[to_additive]\ntheorem ite_mul_one {P : Prop} [Decidable P] {a b : M} :\n    ite P (a * b) 1 = ite P a 1 * ite P b 1", "start": [57, 1], "end": [60, 28], "kind": "commanddeclaration"}, {"full_name": "ite_one_mul", "code": "@[to_additive]\ntheorem ite_one_mul {P : Prop} [Decidable P] {a b : M} :\n    ite P 1 (a * b) = ite P 1 a * ite P 1 b", "start": [64, 1], "end": [67, 28], "kind": "commanddeclaration"}, {"full_name": "eq_one_iff_eq_one_of_mul_eq_one", "code": "@[to_additive]\ntheorem eq_one_iff_eq_one_of_mul_eq_one {a b : M} (h : a * b = 1) : a = 1 \u2194 b = 1", "start": [71, 1], "end": [73, 46], "kind": "commanddeclaration"}, {"full_name": "one_mul_eq_id", "code": "@[to_additive]\ntheorem one_mul_eq_id : (\u00b7 * \u00b7) (1 : M) = id", "start": [77, 1], "end": [79, 17], "kind": "commanddeclaration"}, {"full_name": "mul_one_eq_id", "code": "@[to_additive]\ntheorem mul_one_eq_id : (\u00b7 * (1 : M)) = id", "start": [83, 1], "end": [85, 17], "kind": "commanddeclaration"}, {"full_name": "mul_left_comm", "code": "@[to_additive]\ntheorem mul_left_comm : \u2200 a b c : G, a * (b * c) = b * (a * c)", "start": [95, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "mul_right_comm", "code": "@[to_additive]\ntheorem mul_right_comm : \u2200 a b c : G, a * b * c = a * c * b", "start": [101, 1], "end": [103, 40], "kind": "commanddeclaration"}, {"full_name": "mul_mul_mul_comm", "code": "@[to_additive]\ntheorem mul_mul_mul_comm (a b c d : G) : a * b * (c * d) = a * c * (b * d)", "start": [107, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "mul_rotate", "code": "@[to_additive]\ntheorem mul_rotate (a b c : G) : a * b * c = b * c * a", "start": [113, 1], "end": [115, 41], "kind": "commanddeclaration"}, {"full_name": "mul_rotate'", "code": "@[to_additive]\ntheorem mul_rotate' (a b c : G) : a * (b * c) = b * (c * a)", "start": [119, 1], "end": [121, 41], "kind": "commanddeclaration"}, {"full_name": "bit0_add", "code": "theorem bit0_add (a b : M) : bit0 (a + b) = bit0 a + bit0 b", "start": [132, 1], "end": [133, 27], "kind": "commanddeclaration"}, {"full_name": "bit1_add", "code": "theorem bit1_add [One M] (a b : M) : bit1 (a + b) = bit0 a + bit1 b", "start": [136, 1], "end": [137, 72], "kind": "commanddeclaration"}, {"full_name": "bit1_add'", "code": "theorem bit1_add' [One M] (a b : M) : bit1 (a + b) = bit1 a + bit0 b", "start": [140, 1], "end": [141, 36], "kind": "commanddeclaration"}, {"full_name": "bit0_zero", "code": "@[simp]\ntheorem bit0_zero : bit0 (0 : M) = 0", "start": [151, 1], "end": [153, 13], "kind": "commanddeclaration"}, {"full_name": "bit1_zero", "code": "@[simp]\ntheorem bit1_zero [One M] : bit1 (0 : M) = 1", "start": [156, 1], "end": [157, 82], "kind": "commanddeclaration"}, {"full_name": "inv_unique", "code": "@[to_additive]\ntheorem inv_unique (hy : x * y = 1) (hz : x * z = 1) : y = z", "start": [168, 1], "end": [170, 59], "kind": "commanddeclaration"}, {"full_name": "mul_right_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem mul_right_eq_self : a * b = a \u2194 b = 1", "start": [180, 1], "end": [183, 35], "kind": "commanddeclaration"}, {"full_name": "self_eq_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem self_eq_mul_right : a = a * b \u2194 b = 1", "start": [187, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "mul_right_ne_self", "code": "@[to_additive]\ntheorem mul_right_ne_self : a * b \u2260 a \u2194 b \u2260 1", "start": [193, 1], "end": [194, 71], "kind": "commanddeclaration"}, {"full_name": "self_ne_mul_right", "code": "@[to_additive]\ntheorem self_ne_mul_right : a \u2260 a * b \u2194 b \u2260 1", "start": [198, 1], "end": [199, 71], "kind": "commanddeclaration"}, {"full_name": "mul_left_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem mul_left_eq_self : a * b = b \u2194 a = 1", "start": [209, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "self_eq_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem self_eq_mul_left : b = a * b \u2194 a = 1", "start": [216, 1], "end": [218, 33], "kind": "commanddeclaration"}, {"full_name": "mul_left_ne_self", "code": "@[to_additive]\ntheorem mul_left_ne_self : a * b \u2260 b \u2194 a \u2260 1", "start": [222, 1], "end": [223, 69], "kind": "commanddeclaration"}, {"full_name": "self_ne_mul_left", "code": "@[to_additive]\ntheorem self_ne_mul_left : b \u2260 a * b \u2194 a \u2260 1", "start": [227, 1], "end": [228, 69], "kind": "commanddeclaration"}, {"full_name": "inv_involutive", "code": "@[to_additive (attr := simp)]\ntheorem inv_involutive : Function.Involutive (Inv.inv : G \u2192 G)", "start": [238, 1], "end": [240, 10], "kind": "commanddeclaration"}, {"full_name": "inv_surjective", "code": "@[to_additive (attr := simp)]\ntheorem inv_surjective : Function.Surjective (Inv.inv : G \u2192 G)", "start": [244, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "inv_injective", "code": "@[to_additive]\ntheorem inv_injective : Function.Injective (Inv.inv : G \u2192 G)", "start": [250, 1], "end": [252, 27], "kind": "commanddeclaration"}, {"full_name": "inv_inj", "code": "@[to_additive (attr := simp)]\ntheorem inv_inj : a\u207b\u00b9 = b\u207b\u00b9 \u2194 a = b", "start": [256, 1], "end": [258, 23], "kind": "commanddeclaration"}, {"full_name": "inv_eq_iff_eq_inv", "code": "@[to_additive]\ntheorem inv_eq_iff_eq_inv : a\u207b\u00b9 = b \u2194 a = b\u207b\u00b9", "start": [262, 1], "end": [264, 63], "kind": "commanddeclaration"}, {"full_name": "inv_comp_inv", "code": "@[to_additive]\ntheorem inv_comp_inv : Inv.inv \u2218 Inv.inv = @id G", "start": [270, 1], "end": [272, 27], "kind": "commanddeclaration"}, {"full_name": "leftInverse_inv", "code": "@[to_additive]\ntheorem leftInverse_inv : LeftInverse (fun a : G \u21a6 a\u207b\u00b9) fun a \u21a6 a\u207b\u00b9", "start": [276, 1], "end": [278, 10], "kind": "commanddeclaration"}, {"full_name": "rightInverse_inv", "code": "@[to_additive]\ntheorem rightInverse_inv : LeftInverse (fun a : G \u21a6 a\u207b\u00b9) fun a \u21a6 a\u207b\u00b9", "start": [282, 1], "end": [284, 10], "kind": "commanddeclaration"}, {"full_name": "inv_eq_one_div", "code": "@[to_additive, field_simps] theorem inv_eq_one_div (x : G) : x\u207b\u00b9 = 1 / x", "start": [294, 1], "end": [295, 80], "kind": "commanddeclaration"}, {"full_name": "mul_one_div", "code": "@[to_additive]\ntheorem mul_one_div (x y : G) : x * (1 / y) = x / y", "start": [299, 1], "end": [301, 50], "kind": "commanddeclaration"}, {"full_name": "mul_div_assoc", "code": "@[to_additive]\ntheorem mul_div_assoc (a b c : G) : a * b / c = a * (b / c)", "start": [305, 1], "end": [307, 58], "kind": "commanddeclaration"}, {"full_name": "mul_div_assoc'", "code": "@[to_additive, field_simps] theorem mul_div_assoc' (a b c : G) : a * (b / c) = a * b / c", "start": [311, 1], "end": [313, 29], "kind": "commanddeclaration"}, {"full_name": "one_div", "code": "@[to_additive (attr := simp)]\ntheorem one_div (a : G) : 1 / a = a\u207b\u00b9", "start": [317, 1], "end": [319, 26], "kind": "commanddeclaration"}, {"full_name": "mul_div", "code": "@[to_additive]\ntheorem mul_div (a b c : G) : a * (b / c) = a * b / c", "start": [323, 1], "end": [324, 98], "kind": "commanddeclaration"}, {"full_name": "div_eq_mul_one_div", "code": "@[to_additive]\ntheorem div_eq_mul_one_div (a b : G) : a / b = a * (1 / b)", "start": [328, 1], "end": [329, 94], "kind": "commanddeclaration"}, {"full_name": "div_one", "code": "@[to_additive (attr := simp)]\ntheorem div_one (a : G) : a / 1 = a", "start": [339, 1], "end": [340, 64], "kind": "commanddeclaration"}, {"full_name": "one_div_one", "code": "@[to_additive]\ntheorem one_div_one : (1 : G) / 1 = 1", "start": [344, 1], "end": [346, 12], "kind": "commanddeclaration"}, {"full_name": "eq_inv_of_mul_eq_one_right", "code": "@[to_additive]\ntheorem eq_inv_of_mul_eq_one_right (h : a * b = 1) : b = a\u207b\u00b9", "start": [358, 1], "end": [360, 38], "kind": "commanddeclaration"}, {"full_name": "eq_one_div_of_mul_eq_one_left", "code": "@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_left (h : b * a = 1) : b = 1 / a", "start": [364, 1], "end": [366, 47], "kind": "commanddeclaration"}, {"full_name": "eq_one_div_of_mul_eq_one_right", "code": "@[to_additive]\ntheorem eq_one_div_of_mul_eq_one_right (h : a * b = 1) : b = 1 / a", "start": [370, 1], "end": [372, 48], "kind": "commanddeclaration"}, {"full_name": "eq_of_div_eq_one", "code": "@[to_additive]\ntheorem eq_of_div_eq_one (h : a / b = 1) : a = b", "start": [376, 1], "end": [378, 75], "kind": "commanddeclaration"}, {"full_name": "div_ne_one_of_ne", "code": "@[to_additive]\ntheorem div_ne_one_of_ne : a \u2260 b \u2192 a / b \u2260 1", "start": [382, 1], "end": [384, 22], "kind": "commanddeclaration"}, {"full_name": "one_div_mul_one_div_rev", "code": "@[to_additive]\ntheorem one_div_mul_one_div_rev : 1 / a * (1 / b) = 1 / (b * a)", "start": [390, 1], "end": [391, 75], "kind": "commanddeclaration"}, {"full_name": "inv_div_left", "code": "@[to_additive]\ntheorem inv_div_left : a\u207b\u00b9 / b = (b * a)\u207b\u00b9", "start": [395, 1], "end": [396, 54], "kind": "commanddeclaration"}, {"full_name": "inv_div", "code": "@[to_additive (attr := simp)]\ntheorem inv_div : (a / b)\u207b\u00b9 = b / a", "start": [400, 1], "end": [401, 47], "kind": "commanddeclaration"}, {"full_name": "one_div_div", "code": "@[to_additive]\ntheorem one_div_div : 1 / (a / b) = b / a", "start": [405, 1], "end": [406, 53], "kind": "commanddeclaration"}, {"full_name": "one_div_one_div", "code": "@[to_additive]\ntheorem one_div_one_div : 1 / (1 / a) = a", "start": [410, 1], "end": [411, 53], "kind": "commanddeclaration"}, {"full_name": "DivisionMonoid.toDivInvOneMonoid", "code": "@[to_additive SubtractionMonoid.toSubNegZeroMonoid]\ninstance (priority := 100) DivisionMonoid.toDivInvOneMonoid : DivInvOneMonoid \u03b1 :=\n  { DivisionMonoid.toDivInvMonoid with\n    inv_one := by simpa only [one_div, inv_inv] using (inv_div (1 : \u03b1) 1).symm }", "start": [415, 1], "end": [418, 81], "kind": "commanddeclaration"}, {"full_name": "inv_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem inv_eq_one : a\u207b\u00b9 = 1 \u2194 a = 1", "start": [422, 1], "end": [424, 32], "kind": "commanddeclaration"}, {"full_name": "one_eq_inv", "code": "@[to_additive (attr := simp)]\ntheorem one_eq_inv : 1 = a\u207b\u00b9 \u2194 a = 1", "start": [428, 1], "end": [430, 27], "kind": "commanddeclaration"}, {"full_name": "inv_ne_one", "code": "@[to_additive]\ntheorem inv_ne_one : a\u207b\u00b9 \u2260 1 \u2194 a \u2260 1", "start": [434, 1], "end": [436, 17], "kind": "commanddeclaration"}, {"full_name": "eq_of_one_div_eq_one_div", "code": "@[to_additive]\ntheorem eq_of_one_div_eq_one_div (h : 1 / a = 1 / b) : a = b", "start": [440, 1], "end": [442, 50], "kind": "commanddeclaration"}, {"full_name": "div_div_eq_mul_div", "code": "@[to_additive, field_simps] theorem div_div_eq_mul_div : a / (b / c) = a * c / b", "start": [448, 1], "end": [449, 64], "kind": "commanddeclaration"}, {"full_name": "div_inv_eq_mul", "code": "@[to_additive (attr := simp)]\ntheorem div_inv_eq_mul : a / b\u207b\u00b9 = a * b", "start": [453, 1], "end": [454, 52], "kind": "commanddeclaration"}, {"full_name": "div_mul_eq_div_div_swap", "code": "@[to_additive]\ntheorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b", "start": [458, 1], "end": [460, 56], "kind": "commanddeclaration"}, {"full_name": "bit0_neg", "code": "lemma bit0_neg [SubtractionMonoid \u03b1] (a : \u03b1) : bit0 (-a) = -bit0 a := (neg_add_rev _ _).symm", "start": [470, 1], "end": [470, 93], "kind": "mathlibtacticlemma"}, {"full_name": "mul_inv", "code": "@[to_additive neg_add]\ntheorem mul_inv : (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9", "start": [481, 1], "end": [482, 51], "kind": "commanddeclaration"}, {"full_name": "inv_div'", "code": "@[to_additive]\ntheorem inv_div' : (a / b)\u207b\u00b9 = a\u207b\u00b9 / b\u207b\u00b9", "start": [486, 1], "end": [487, 52], "kind": "commanddeclaration"}, {"full_name": "div_eq_inv_mul", "code": "@[to_additive]\ntheorem div_eq_inv_mul : a / b = b\u207b\u00b9 * a", "start": [491, 1], "end": [492, 52], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_div", "code": "@[to_additive]\ntheorem inv_mul_eq_div : a\u207b\u00b9 * b = b / a", "start": [496, 1], "end": [497, 52], "kind": "commanddeclaration"}, {"full_name": "inv_mul'", "code": "@[to_additive]\ntheorem inv_mul' : (a * b)\u207b\u00b9 = a\u207b\u00b9 / b", "start": [501, 1], "end": [502, 50], "kind": "commanddeclaration"}, {"full_name": "inv_div_inv", "code": "@[to_additive]\ntheorem inv_div_inv : a\u207b\u00b9 / b\u207b\u00b9 = b / a", "start": [506, 1], "end": [507, 51], "kind": "commanddeclaration"}, {"full_name": "inv_inv_div_inv", "code": "@[to_additive]\ntheorem inv_inv_div_inv : (a\u207b\u00b9 / b\u207b\u00b9)\u207b\u00b9 = a / b", "start": [511, 1], "end": [512, 59], "kind": "commanddeclaration"}, {"full_name": "one_div_mul_one_div", "code": "@[to_additive]\ntheorem one_div_mul_one_div : 1 / a * (1 / b) = 1 / (a * b)", "start": [516, 1], "end": [517, 71], "kind": "commanddeclaration"}, {"full_name": "div_right_comm", "code": "@[to_additive]\ntheorem div_right_comm : a / b / c = a / c / b", "start": [521, 1], "end": [522, 58], "kind": "commanddeclaration"}, {"full_name": "div_div", "code": "@[to_additive, field_simps]\ntheorem div_div : a / b / c = a / (b * c)", "start": [526, 1], "end": [527, 53], "kind": "commanddeclaration"}, {"full_name": "div_mul", "code": "@[to_additive]\ntheorem div_mul : a / b * c = a / (b / c)", "start": [531, 1], "end": [532, 53], "kind": "commanddeclaration"}, {"full_name": "mul_div_left_comm", "code": "@[to_additive]\ntheorem mul_div_left_comm : a * (b / c) = b * (a / c)", "start": [536, 1], "end": [537, 65], "kind": "commanddeclaration"}, {"full_name": "mul_div_right_comm", "code": "@[to_additive]\ntheorem mul_div_right_comm : a * b / c = a / c * b", "start": [541, 1], "end": [542, 62], "kind": "commanddeclaration"}, {"full_name": "div_mul_eq_div_div", "code": "@[to_additive]\ntheorem div_mul_eq_div_div : a / (b * c) = a / b / c", "start": [546, 1], "end": [547, 64], "kind": "commanddeclaration"}, {"full_name": "div_mul_eq_mul_div", "code": "@[to_additive, field_simps]\ntheorem div_mul_eq_mul_div : a / b * c = a * c / b", "start": [551, 1], "end": [552, 62], "kind": "commanddeclaration"}, {"full_name": "mul_comm_div", "code": "@[to_additive]\ntheorem mul_comm_div : a / b * c = a * (c / b)", "start": [556, 1], "end": [557, 58], "kind": "commanddeclaration"}, {"full_name": "div_mul_comm", "code": "@[to_additive]\ntheorem div_mul_comm : a / b * c = c / b * a", "start": [561, 1], "end": [562, 56], "kind": "commanddeclaration"}, {"full_name": "div_mul_eq_div_mul_one_div", "code": "@[to_additive]\ntheorem div_mul_eq_div_mul_one_div : a / (b * c) = a / b * (1 / c)", "start": [566, 1], "end": [567, 78], "kind": "commanddeclaration"}, {"full_name": "div_div_div_eq", "code": "@[to_additive]\ntheorem div_div_div_eq : a / b / (c / d) = a * d / (b * c)", "start": [571, 1], "end": [572, 70], "kind": "commanddeclaration"}, {"full_name": "div_div_div_comm", "code": "@[to_additive]\ntheorem div_div_div_comm : a / b / (c / d) = a / c / (b / d)", "start": [576, 1], "end": [577, 72], "kind": "commanddeclaration"}, {"full_name": "div_mul_div_comm", "code": "@[to_additive]\ntheorem div_mul_div_comm : a / b * (c / d) = a * c / (b * d)", "start": [581, 1], "end": [582, 72], "kind": "commanddeclaration"}, {"full_name": "mul_div_mul_comm", "code": "@[to_additive]\ntheorem mul_div_mul_comm : a * b / (c * d) = a / c * (b / d)", "start": [586, 1], "end": [587, 72], "kind": "commanddeclaration"}, {"full_name": "div_eq_inv_self", "code": "@[to_additive (attr := simp)]\ntheorem div_eq_inv_self : a / b = b\u207b\u00b9 \u2194 a = 1", "start": [597, 1], "end": [598, 90], "kind": "commanddeclaration"}, {"full_name": "mul_left_surjective", "code": "@[to_additive]\ntheorem mul_left_surjective (a : G) : Function.Surjective ((\u00b7 * \u00b7) a)", "start": [602, 1], "end": [604, 45], "kind": "commanddeclaration"}, {"full_name": "mul_right_surjective", "code": "@[to_additive]\ntheorem mul_right_surjective (a : G) : Function.Surjective fun x \u21a6 x * a", "start": [608, 1], "end": [610, 38], "kind": "commanddeclaration"}, {"full_name": "eq_mul_inv_of_mul_eq", "code": "@[to_additive]\ntheorem eq_mul_inv_of_mul_eq (h : a * c = b) : a = b * c\u207b\u00b9", "start": [614, 1], "end": [615, 79], "kind": "commanddeclaration"}, {"full_name": "eq_inv_mul_of_mul_eq", "code": "@[to_additive]\ntheorem eq_inv_mul_of_mul_eq (h : b * a = c) : a = b\u207b\u00b9 * c", "start": [619, 1], "end": [620, 79], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_of_eq_mul", "code": "@[to_additive]\ntheorem inv_mul_eq_of_eq_mul (h : b = a * c) : a\u207b\u00b9 * b = c", "start": [624, 1], "end": [625, 74], "kind": "commanddeclaration"}, {"full_name": "mul_inv_eq_of_eq_mul", "code": "@[to_additive]\ntheorem mul_inv_eq_of_eq_mul (h : a = c * b) : a * b\u207b\u00b9 = c", "start": [629, 1], "end": [630, 74], "kind": "commanddeclaration"}, {"full_name": "eq_mul_of_mul_inv_eq", "code": "@[to_additive]\ntheorem eq_mul_of_mul_inv_eq (h : a * c\u207b\u00b9 = b) : a = b * c", "start": [634, 1], "end": [635, 79], "kind": "commanddeclaration"}, {"full_name": "eq_mul_of_inv_mul_eq", "code": "@[to_additive]\ntheorem eq_mul_of_inv_mul_eq (h : b\u207b\u00b9 * a = c) : a = b * c", "start": [639, 1], "end": [640, 100], "kind": "commanddeclaration"}, {"full_name": "mul_eq_of_eq_inv_mul", "code": "@[to_additive]\ntheorem mul_eq_of_eq_inv_mul (h : b = a\u207b\u00b9 * c) : a * b = c", "start": [644, 1], "end": [645, 93], "kind": "commanddeclaration"}, {"full_name": "mul_eq_of_eq_mul_inv", "code": "@[to_additive]\ntheorem mul_eq_of_eq_mul_inv (h : a = c * b\u207b\u00b9) : a * b = c", "start": [649, 1], "end": [650, 74], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff_eq_inv", "code": "@[to_additive]\ntheorem mul_eq_one_iff_eq_inv : a * b = 1 \u2194 a = b\u207b\u00b9", "start": [654, 1], "end": [656, 63], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff_inv_eq", "code": "@[to_additive]\ntheorem mul_eq_one_iff_inv_eq : a * b = 1 \u2194 a\u207b\u00b9 = b", "start": [660, 1], "end": [662, 51], "kind": "commanddeclaration"}, {"full_name": "eq_inv_iff_mul_eq_one", "code": "@[to_additive]\ntheorem eq_inv_iff_mul_eq_one : a = b\u207b\u00b9 \u2194 a * b = 1", "start": [666, 1], "end": [668, 29], "kind": "commanddeclaration"}, {"full_name": "inv_eq_iff_mul_eq_one", "code": "@[to_additive]\ntheorem inv_eq_iff_mul_eq_one : a\u207b\u00b9 = b \u2194 a * b = 1", "start": [672, 1], "end": [674, 29], "kind": "commanddeclaration"}, {"full_name": "eq_mul_inv_iff_mul_eq", "code": "@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq : a = b * c\u207b\u00b9 \u2194 a * c = b", "start": [678, 1], "end": [680, 87], "kind": "commanddeclaration"}, {"full_name": "eq_inv_mul_iff_mul_eq", "code": "@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq : a = b\u207b\u00b9 * c \u2194 b * a = c", "start": [684, 1], "end": [686, 85], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul : a\u207b\u00b9 * b = c \u2194 b = a * c", "start": [690, 1], "end": [692, 85], "kind": "commanddeclaration"}, {"full_name": "mul_inv_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul : a * b\u207b\u00b9 = c \u2194 a = c * b", "start": [696, 1], "end": [698, 87], "kind": "commanddeclaration"}, {"full_name": "mul_inv_eq_one", "code": "@[to_additive]\ntheorem mul_inv_eq_one : a * b\u207b\u00b9 = 1 \u2194 a = b", "start": [702, 1], "end": [703, 87], "kind": "commanddeclaration"}, {"full_name": "inv_mul_eq_one", "code": "@[to_additive]\ntheorem inv_mul_eq_one : a\u207b\u00b9 * b = 1 \u2194 a = b", "start": [707, 1], "end": [708, 87], "kind": "commanddeclaration"}, {"full_name": "div_left_injective", "code": "@[to_additive]\ntheorem div_left_injective : Function.Injective fun a \u21a6 a / b", "start": [712, 1], "end": [716, 46], "kind": "commanddeclaration"}, {"full_name": "div_right_injective", "code": "@[to_additive]\ntheorem div_right_injective : Function.Injective fun a \u21a6 b / a", "start": [720, 1], "end": [724, 61], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel'", "code": "@[to_additive (attr := simp) sub_add_cancel]\ntheorem div_mul_cancel' (a b : G) : a / b * b = a", "start": [728, 1], "end": [730, 51], "kind": "commanddeclaration"}, {"full_name": "div_self'", "code": "@[to_additive (attr := simp) sub_self]\ntheorem div_self' (a : G) : a / a = 1", "start": [734, 1], "end": [735, 81], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel''", "code": "@[to_additive (attr := simp) add_sub_cancel]\ntheorem mul_div_cancel'' (a b : G) : a * b / b = a", "start": [739, 1], "end": [741, 51], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel'''", "code": "@[to_additive (attr := simp) sub_add_cancel'']\ntheorem div_mul_cancel''' (a b : G) : a / (b * a) = b\u207b\u00b9", "start": [745, 1], "end": [746, 95], "kind": "commanddeclaration"}, {"full_name": "mul_div_mul_right_eq_div", "code": "@[to_additive (attr := simp)]\ntheorem mul_div_mul_right_eq_div (a b c : G) : a * c / (b * c) = a / b", "start": [750, 1], "end": [752, 93], "kind": "commanddeclaration"}, {"full_name": "eq_div_of_mul_eq'", "code": "@[to_additive eq_sub_of_add_eq]\ntheorem eq_div_of_mul_eq' (h : a * c = b) : a = b / c", "start": [756, 1], "end": [757, 71], "kind": "commanddeclaration"}, {"full_name": "div_eq_of_eq_mul''", "code": "@[to_additive sub_eq_of_eq_add]\ntheorem div_eq_of_eq_mul'' (h : a = c * b) : a / b = c", "start": [761, 1], "end": [762, 70], "kind": "commanddeclaration"}, {"full_name": "eq_mul_of_div_eq", "code": "@[to_additive]\ntheorem eq_mul_of_div_eq (h : a / c = b) : a = b * c", "start": [766, 1], "end": [767, 70], "kind": "commanddeclaration"}, {"full_name": "mul_eq_of_eq_div", "code": "@[to_additive]\ntheorem mul_eq_of_eq_div (h : a = c / b) : a * b = c", "start": [771, 1], "end": [772, 68], "kind": "commanddeclaration"}, {"full_name": "div_right_inj", "code": "@[to_additive (attr := simp)]\ntheorem div_right_inj : a / b = a / c \u2194 b = c", "start": [776, 1], "end": [778, 29], "kind": "commanddeclaration"}, {"full_name": "div_left_inj", "code": "@[to_additive (attr := simp)]\ntheorem div_left_inj : b / a = c / a \u2194 b = c", "start": [782, 1], "end": [785, 23], "kind": "commanddeclaration"}, {"full_name": "div_mul_div_cancel'", "code": "@[to_additive (attr := simp) sub_add_sub_cancel]\ntheorem div_mul_div_cancel' (a b c : G) : a / b * (b / c) = a / c", "start": [789, 1], "end": [791, 43], "kind": "commanddeclaration"}, {"full_name": "div_div_div_cancel_right'", "code": "@[to_additive (attr := simp) sub_sub_sub_cancel_right]\ntheorem div_div_div_cancel_right' (a b c : G) : a / c / (b / c) = a / b", "start": [795, 1], "end": [797, 58], "kind": "commanddeclaration"}, {"full_name": "div_eq_one", "code": "@[to_additive]\ntheorem div_eq_one : a / b = 1 \u2194 a = b", "start": [801, 1], "end": [803, 51], "kind": "commanddeclaration"}, {"full_name": "div_eq_one_of_eq", "code": "alias \u27e8_, div_eq_one_of_eq\u27e9 := div_eq_one", "start": [807, 1], "end": [807, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_eq_zero_of_eq", "code": "alias \u27e8_, sub_eq_zero_of_eq\u27e9 := sub_eq_zero", "start": [810, 1], "end": [810, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_ne_one", "code": "@[to_additive]\ntheorem div_ne_one : a / b \u2260 1 \u2194 a \u2260 b", "start": [813, 1], "end": [815, 23], "kind": "commanddeclaration"}, {"full_name": "div_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem div_eq_self : a / b = a \u2194 b = 1", "start": [819, 1], "end": [820, 97], "kind": "commanddeclaration"}, {"full_name": "eq_div_iff_mul_eq'", "code": "@[to_additive eq_sub_iff_add_eq]\ntheorem eq_div_iff_mul_eq' : a = b / c \u2194 a * c = b", "start": [824, 1], "end": [825, 100], "kind": "commanddeclaration"}, {"full_name": "div_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem div_eq_iff_eq_mul : a / b = c \u2194 a = c * b", "start": [829, 1], "end": [830, 99], "kind": "commanddeclaration"}, {"full_name": "eq_iff_eq_of_div_eq_div", "code": "@[to_additive]\ntheorem eq_iff_eq_of_div_eq_div (H : a / b = c / d) : a = b \u2194 c = d", "start": [834, 1], "end": [836, 38], "kind": "commanddeclaration"}, {"full_name": "leftInverse_div_mul_left", "code": "@[to_additive]\ntheorem leftInverse_div_mul_left (c : G) : Function.LeftInverse (fun x \u21a6 x / c) fun x \u21a6 x * c", "start": [840, 1], "end": [842, 31], "kind": "commanddeclaration"}, {"full_name": "leftInverse_mul_left_div", "code": "@[to_additive]\ntheorem leftInverse_mul_left_div (c : G) : Function.LeftInverse (fun x \u21a6 x * c) fun x \u21a6 x / c", "start": [846, 1], "end": [848, 30], "kind": "commanddeclaration"}, {"full_name": "leftInverse_mul_right_inv_mul", "code": "@[to_additive]\ntheorem leftInverse_mul_right_inv_mul (c : G) :\n    Function.LeftInverse (fun x \u21a6 c * x) fun x \u21a6 c\u207b\u00b9 * x", "start": [852, 1], "end": [855, 34], "kind": "commanddeclaration"}, {"full_name": "leftInverse_inv_mul_mul_right", "code": "@[to_additive]\ntheorem leftInverse_inv_mul_mul_right (c : G) :\n    Function.LeftInverse (fun x \u21a6 c\u207b\u00b9 * x) fun x \u21a6 c * x", "start": [859, 1], "end": [862, 34], "kind": "commanddeclaration"}, {"full_name": "exists_npow_eq_one_of_zpow_eq_one", "code": "@[to_additive]\ntheorem exists_npow_eq_one_of_zpow_eq_one {n : \u2124} (hn : n \u2260 0) {x : G} (h : x ^ n = 1) :\n    \u2203 n : \u2115, 0 < n \u2227 x ^ n = 1", "start": [866, 1], "end": [876, 35], "kind": "commanddeclaration"}, {"full_name": "div_eq_of_eq_mul'", "code": "@[to_additive]\ntheorem div_eq_of_eq_mul' {a b c : G} (h : a = b * c) : a / b = c", "start": [888, 1], "end": [890, 56], "kind": "commanddeclaration"}, {"full_name": "mul_div_mul_left_eq_div", "code": "@[to_additive (attr := simp)]\ntheorem mul_div_mul_left_eq_div (a b c : G) : c * a / (c * b) = a / b", "start": [894, 1], "end": [897, 44], "kind": "commanddeclaration"}, {"full_name": "eq_div_of_mul_eq''", "code": "@[to_additive eq_sub_of_add_eq']\ntheorem eq_div_of_mul_eq'' (h : c * a = b) : a = b / c", "start": [901, 1], "end": [902, 75], "kind": "commanddeclaration"}, {"full_name": "eq_mul_of_div_eq'", "code": "@[to_additive]\ntheorem eq_mul_of_div_eq' (h : a / b = c) : a = b * c", "start": [906, 1], "end": [907, 74], "kind": "commanddeclaration"}, {"full_name": "mul_eq_of_eq_div'", "code": "@[to_additive]\ntheorem mul_eq_of_eq_div' (h : b = c / a) : a * b = c", "start": [911, 1], "end": [913, 58], "kind": "commanddeclaration"}, {"full_name": "div_div_self'", "code": "@[to_additive sub_sub_self]\ntheorem div_div_self' (a b : G) : a / (a / b) = b", "start": [917, 1], "end": [918, 92], "kind": "commanddeclaration"}, {"full_name": "div_eq_div_mul_div", "code": "@[to_additive]\ntheorem div_eq_div_mul_div (a b c : G) : a / b = c / b * (a / c)", "start": [922, 1], "end": [923, 94], "kind": "commanddeclaration"}, {"full_name": "div_div_cancel", "code": "@[to_additive (attr := simp)]\ntheorem div_div_cancel (a b : G) : a / (a / b) = b", "start": [927, 1], "end": [929, 20], "kind": "commanddeclaration"}, {"full_name": "div_div_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem div_div_cancel_left (a b : G) : a / b / a = b\u207b\u00b9", "start": [933, 1], "end": [934, 67], "kind": "commanddeclaration"}, {"full_name": "eq_div_iff_mul_eq''", "code": "@[to_additive eq_sub_iff_add_eq']\ntheorem eq_div_iff_mul_eq'' : a = b / c \u2194 c * a = b", "start": [938, 1], "end": [939, 92], "kind": "commanddeclaration"}, {"full_name": "div_eq_iff_eq_mul'", "code": "@[to_additive]\ntheorem div_eq_iff_eq_mul' : a / b = c \u2194 a = b * c", "start": [943, 1], "end": [944, 90], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel'''", "code": "@[to_additive (attr := simp) add_sub_cancel']\ntheorem mul_div_cancel''' (a b : G) : a * b / a = b", "start": [948, 1], "end": [949, 99], "kind": "commanddeclaration"}, {"full_name": "mul_div_cancel'_right", "code": "@[to_additive (attr := simp)]\ntheorem mul_div_cancel'_right (a b : G) : a * (b / a) = b", "start": [953, 1], "end": [955, 42], "kind": "commanddeclaration"}, {"full_name": "div_mul_cancel''", "code": "@[to_additive (attr := simp) sub_add_cancel']\ntheorem div_mul_cancel'' (a b : G) : a / (a * b) = b\u207b\u00b9", "start": [959, 1], "end": [960, 95], "kind": "commanddeclaration"}, {"full_name": "mul_mul_inv_cancel'_right", "code": "@[to_additive]\ntheorem mul_mul_inv_cancel'_right (a b : G) : a * (b * a\u207b\u00b9) = b", "start": [967, 1], "end": [969, 51], "kind": "commanddeclaration"}, {"full_name": "mul_mul_div_cancel", "code": "@[to_additive (attr := simp)]\ntheorem mul_mul_div_cancel (a b c : G) : a * c * (b / c) = a * b", "start": [973, 1], "end": [975, 40], "kind": "commanddeclaration"}, {"full_name": "div_mul_mul_cancel", "code": "@[to_additive (attr := simp)]\ntheorem div_mul_mul_cancel (a b c : G) : a / c * (b * c) = a * b", "start": [979, 1], "end": [981, 48], "kind": "commanddeclaration"}, {"full_name": "div_mul_div_cancel''", "code": "@[to_additive (attr := simp) sub_add_sub_cancel']\ntheorem div_mul_div_cancel'' (a b c : G) : a / b * (c / a) = c / b", "start": [985, 1], "end": [987, 43], "kind": "commanddeclaration"}, {"full_name": "mul_div_div_cancel", "code": "@[to_additive (attr := simp)]\ntheorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c", "start": [991, 1], "end": [993, 36], "kind": "commanddeclaration"}, {"full_name": "div_div_div_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem div_div_div_cancel_left (a b c : G) : c / a / (c / b) = b / a", "start": [997, 1], "end": [999, 68], "kind": "commanddeclaration"}, {"full_name": "div_eq_div_iff_mul_eq_mul", "code": "@[to_additive]\ntheorem div_eq_div_iff_mul_eq_mul : a / b = c / d \u2194 a * d = c * b", "start": [1003, 1], "end": [1006, 32], "kind": "commanddeclaration"}, {"full_name": "div_eq_div_iff_div_eq_div", "code": "@[to_additive]\ntheorem div_eq_div_iff_div_eq_div : a / b = c / d \u2194 a / c = b / d", "start": [1010, 1], "end": [1012, 80], "kind": "commanddeclaration"}, {"full_name": "multiplicative_of_symmetric_of_isTotal", "code": "@[to_additive additive_of_symmetric_of_isTotal]\nlemma multiplicative_of_symmetric_of_isTotal\n    (hsymm : Symmetric p) (hf_swap : \u2200 {a b}, p a b \u2192 f a b * f b a = 1)\n    (hmul : \u2200 {a b c}, r a b \u2192 r b c \u2192 p a b \u2192 p b c \u2192 p a c \u2192 f a c = f a b * f b c)\n    {a b c : \u03b1} (pab : p a b) (pbc : p b c) (pac : p a c) : f a c = f a b * f b c := by\n  have hmul' : \u2200 {b c}, r b c \u2192 p a b \u2192 p b c \u2192 p a c \u2192 f a c = f a b * f b c := by\n    intros b c rbc pab pbc pac\n    obtain rab | rba := total_of r a b\n    \u00b7 exact hmul rab rbc pab pbc pac\n    rw [\u2190 one_mul (f a c), \u2190 hf_swap pab, mul_assoc]\n    obtain rac | rca := total_of r a c\n    \u00b7 rw [hmul rba rac (hsymm pab) pac pbc]\n    \u00b7 rw [hmul rbc rca pbc (hsymm pac) (hsymm pab), mul_assoc, hf_swap (hsymm pac), mul_one]\n  obtain rbc | rcb := total_of r b c\n  \u00b7 exact hmul' rbc pab pbc pac\n  \u00b7 rw [hmul' rcb pac (hsymm pbc) pab, mul_assoc, hf_swap (hsymm pbc), mul_one]", "start": [1022, 1], "end": [1037, 80], "kind": "mathlibtacticlemma"}, {"full_name": "multiplicative_of_isTotal", "code": "@[to_additive additive_of_isTotal \"If a binary function from a type equipped with a total relation\n`r` to an additive monoid is anti-symmetric (i.e. satisfies `f a b + f b a = 0`), in order to show\nit is additive (i.e. satisfies `f a c = f a b + f b c`), we may assume `r a b` and `r b c` are\nsatisfied. We allow restricting to a subset specified by a predicate `p`.\"]\ntheorem multiplicative_of_isTotal (p : \u03b1 \u2192 Prop) (hswap : \u2200 {a b}, p a \u2192 p b \u2192 f a b * f b a = 1)\n    (hmul : \u2200 {a b c}, r a b \u2192 r b c \u2192 p a \u2192 p b \u2192 p c \u2192 f a c = f a b * f b c) {a b c : \u03b1}\n    (pa : p a) (pb : p b) (pc : p c) : f a c = f a b * f b c", "start": [1041, 1], "end": [1055, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Monotonicity/Attr.lean", "imports": ["lake-packages/std/Std/Tactic/LabelAttr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Logic/Equiv/Option.lean", "imports": ["Mathlib/Control/EquivFunctor.lean", "Mathlib/Data/Option/Basic.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Tactic/Cases.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Equiv.optionCongr", "code": "@[simps apply]\ndef optionCongr (e : \u03b1 \u2243 \u03b2) : Option \u03b1 \u2243 Option \u03b2 where\n  toFun := Option.map e\n  invFun := Option.map e.symm\n  left_inv x := (Option.map_map _ _ _).trans <| e.symm_comp_self.symm \u25b8 congr_fun Option.map_id x\n  right_inv x := (Option.map_map _ _ _).trans <| e.self_comp_symm.symm \u25b8 congr_fun Option.map_id x", "start": [35, 1], "end": [41, 99], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_refl", "code": "@[simp]\ntheorem optionCongr_refl : optionCongr (Equiv.refl \u03b1) = Equiv.refl _", "start": [45, 1], "end": [47, 33], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_symm", "code": "@[simp]\ntheorem optionCongr_symm (e : \u03b1 \u2243 \u03b2) : (optionCongr e).symm = optionCongr e.symm", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_trans", "code": "@[simp]\ntheorem optionCongr_trans (e\u2081 : \u03b1 \u2243 \u03b2) (e\u2082 : \u03b2 \u2243 \u03b3) :\n    (optionCongr e\u2081).trans (optionCongr e\u2082) = optionCongr (e\u2081.trans e\u2082)", "start": [55, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_eq_equivFunctor_mapEquiv", "code": "theorem optionCongr_eq_equivFunctor_mapEquiv {\u03b1 \u03b2 : Type u} (e : \u03b1 \u2243 \u03b2) :\n    optionCongr e = EquivFunctor.mapEquiv Option e", "start": [61, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_aux", "code": "def removeNone_aux (x : \u03b1) : \u03b2 :=\n  if h : (e (some x)).isSome then Option.get _ h\n  else\n    Option.get _ <|\n      show (e none).isSome by\n        rw [\u2190 Option.ne_none_iff_isSome]\n        intro hn\n        rw [Option.not_isSome_iff_eq_none, \u2190 hn] at h\n        exact Option.some_ne_none _ (e.injective h)", "start": [74, 1], "end": [85, 52], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_aux_some", "code": "theorem removeNone_aux_some {x : \u03b1} (h : \u2203 x', e (some x) = some x') :\n    some (removeNone_aux e x) = e (some x)", "start": [89, 1], "end": [91, 59], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_aux_none", "code": "theorem removeNone_aux_none {x : \u03b1} (h : e (some x) = none) :\n    some (removeNone_aux e x) = e none", "start": [95, 1], "end": [97, 61], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_aux_inv", "code": "theorem removeNone_aux_inv (x : \u03b1) : removeNone_aux e.symm (removeNone_aux e x) = x", "start": [101, 1], "end": [116, 14], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone", "code": "def removeNone : \u03b1 \u2243 \u03b2 where\n  toFun := removeNone_aux e\n  invFun := removeNone_aux e.symm\n  left_inv := removeNone_aux_inv e\n  right_inv := removeNone_aux_inv e.symm", "start": [120, 1], "end": [126, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_symm", "code": "@[simp]\ntheorem removeNone_symm : (removeNone e).symm = removeNone e.symm", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_some", "code": "theorem removeNone_some {x : \u03b1} (h : \u2203 x', e (some x) = some x') :\n    some (removeNone e x) = e (some x)", "start": [134, 1], "end": [136, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_none", "code": "theorem removeNone_none {x : \u03b1} (h : e (some x) = none) : some (removeNone e x) = e none", "start": [139, 1], "end": [140, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.option_symm_apply_none_iff", "code": "@[simp]\ntheorem option_symm_apply_none_iff : e.symm none = none \u2194 e none = none", "start": [143, 1], "end": [145, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.some_removeNone_iff", "code": "theorem some_removeNone_iff {x : \u03b1} : some (removeNone e x) = e none \u2194 e.symm none = some x", "start": [148, 1], "end": [156, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.removeNone_optionCongr", "code": "@[simp]\ntheorem removeNone_optionCongr (e : \u03b1 \u2243 \u03b2) : removeNone e.optionCongr = e", "start": [159, 1], "end": [161, 100], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionCongr_injective", "code": "theorem optionCongr_injective : Function.Injective (optionCongr : \u03b1 \u2243 \u03b2 \u2192 Option \u03b1 \u2243 Option \u03b2)", "start": [166, 1], "end": [167, 56], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype", "code": "def optionSubtype [DecidableEq \u03b2] (x : \u03b2) :\n    { e : Option \u03b1 \u2243 \u03b2 // e none = x } \u2243 (\u03b1 \u2243 { y : \u03b2 // y \u2260 x }) where\n  toFun e :=\n    { toFun := fun a =>\n        \u27e8(e : Option \u03b1 \u2243 \u03b2) a, ((EquivLike.injective _).ne_iff' e.property).2 (some_ne_none _)\u27e9,\n      invFun := fun b =>\n        get _\n          (ne_none_iff_isSome.1\n            (((EquivLike.injective _).ne_iff'\n              ((apply_eq_iff_eq_symm_apply _).1 e.property).symm).2 b.property)),\n      left_inv := fun a => by\n        rw [\u2190 some_inj, some_get]\n        exact symm_apply_apply (e : Option \u03b1 \u2243 \u03b2) a,\n      right_inv := fun b => by\n        ext\n        simp }\n  invFun e :=\n    \u27e8{  toFun := fun a => casesOn' a x (Subtype.val \u2218 e),\n        invFun := fun b => if h : b = x then none else e.symm \u27e8b, h\u27e9,\n        left_inv := fun a => by\n          cases a with\n          | none => simp\n          | some a =>\n            simp only [casesOn'_some, Function.comp_apply, Subtype.coe_eta,\n              symm_apply_apply, dite_eq_ite]\n            exact if_neg (e a).property,\n        right_inv := fun b => by\n          by_cases h : b = x <;> simp [h] },\n      rfl\u27e9\n  left_inv e := by\n    ext a\n    cases a\n    \u00b7 simpa using e.property.symm\n    \u00b7 rfl\n  right_inv e := by\n    ext a\n    rfl", "start": [170, 1], "end": [211, 8], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_apply_apply", "code": "@[simp]\ntheorem optionSubtype_apply_apply\n    [DecidableEq \u03b2] (x : \u03b2)\n    (e : { e : Option \u03b1 \u2243 \u03b2 // e none = x })\n    (a : \u03b1)\n    (h) : optionSubtype x e a = \u27e8(e : Option \u03b1 \u2243 \u03b2) a, h\u27e9", "start": [214, 1], "end": [219, 65], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_optionSubtype_apply_apply", "code": "@[simp]\ntheorem coe_optionSubtype_apply_apply\n    [DecidableEq \u03b2] (x : \u03b2)\n    (e : { e : Option \u03b1 \u2243 \u03b2 // e none = x })\n    (a : \u03b1) : \u2191(optionSubtype x e a) = (e : Option \u03b1 \u2243 \u03b2) a", "start": [222, 1], "end": [226, 67], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_apply_symm_apply", "code": "@[simp]\ntheorem optionSubtype_apply_symm_apply\n    [DecidableEq \u03b2] (x : \u03b2)\n    (e : { e : Option \u03b1 \u2243 \u03b2 // e none = x })\n    (b : { y : \u03b2 // y \u2260 x }) : \u2191((optionSubtype x e).symm b) = (e : Option \u03b1 \u2243 \u03b2).symm b", "start": [229, 1], "end": [235, 7], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_symm_apply_apply_coe", "code": "@[simp]\ntheorem optionSubtype_symm_apply_apply_coe [DecidableEq \u03b2] (x : \u03b2) (e : \u03b1 \u2243 { y : \u03b2 // y \u2260 x })\n    (a : \u03b1) : ((optionSubtype x).symm e : Option \u03b1 \u2243 \u03b2) a = e a", "start": [238, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_symm_apply_apply_some", "code": "@[simp]\ntheorem optionSubtype_symm_apply_apply_some\n    [DecidableEq \u03b2]\n    (x : \u03b2)\n    (e : \u03b1 \u2243 { y : \u03b2 // y \u2260 x })\n    (a : \u03b1) : ((optionSubtype x).symm e : Option \u03b1 \u2243 \u03b2) (some a) = e a", "start": [244, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_symm_apply_apply_none", "code": "@[simp]\ntheorem optionSubtype_symm_apply_apply_none\n    [DecidableEq \u03b2]\n    (x : \u03b2)\n    (e : \u03b1 \u2243 { y : \u03b2 // y \u2260 x }) : ((optionSubtype x).symm e : Option \u03b1 \u2243 \u03b2) none = x", "start": [253, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.optionSubtype_symm_apply_symm_apply", "code": "@[simp]\ntheorem optionSubtype_symm_apply_symm_apply [DecidableEq \u03b2] (x : \u03b2) (e : \u03b1 \u2243 { y : \u03b2 // y \u2260 x })\n    (b : { y : \u03b2 // y \u2260 x }) : ((optionSubtype x).symm e : Option \u03b1 \u2243 \u03b2).symm b = e.symm b", "start": [261, 1], "end": [266, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Disjoint.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Disjoint", "code": "def Disjoint (a b : \u03b1) : Prop :=\n  \u2200 \u2983x\u2984, x \u2264 a \u2192 x \u2264 b \u2192 x \u2264 \u22a5", "start": [35, 1], "end": [42, 31], "kind": "commanddeclaration"}, {"full_name": "disjoint_comm", "code": "theorem disjoint_comm : Disjoint a b \u2194 Disjoint b a", "start": [45, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "Disjoint.symm", "code": "@[symm]\ntheorem Disjoint.symm \u2983a b : \u03b1\u2984 : Disjoint a b \u2192 Disjoint b a", "start": [49, 1], "end": [51, 18], "kind": "commanddeclaration"}, {"full_name": "symmetric_disjoint", "code": "theorem symmetric_disjoint : Symmetric (Disjoint : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [54, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "disjoint_bot_left", "code": "@[simp]\ntheorem disjoint_bot_left : Disjoint \u22a5 a", "start": [58, 1], "end": [59, 64], "kind": "commanddeclaration"}, {"full_name": "disjoint_bot_right", "code": "@[simp]\ntheorem disjoint_bot_right : Disjoint a \u22a5", "start": [62, 1], "end": [63, 65], "kind": "commanddeclaration"}, {"full_name": "Disjoint.mono", "code": "theorem Disjoint.mono (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : Disjoint b d \u2192 Disjoint a c", "start": [66, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "Disjoint.mono_left", "code": "theorem Disjoint.mono_left (h : a \u2264 b) : Disjoint b c \u2192 Disjoint a c", "start": [70, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "Disjoint.mono_right", "code": "theorem Disjoint.mono_right : b \u2264 c \u2192 Disjoint a c \u2192 Disjoint a b", "start": [74, 1], "end": [75, 23], "kind": "commanddeclaration"}, {"full_name": "disjoint_self", "code": "@[simp]\ntheorem disjoint_self : Disjoint a a \u2194 a = \u22a5", "start": [78, 1], "end": [80, 74], "kind": "commanddeclaration"}, {"full_name": "Disjoint.eq_bot_of_self", "code": "alias \u27e8Disjoint.eq_bot_of_self, _\u27e9 := disjoint_self", "start": [85, 1], "end": [85, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Disjoint.ne", "code": "theorem Disjoint.ne (ha : a \u2260 \u22a5) (hab : Disjoint a b) : a \u2260 b", "start": [88, 1], "end": [89, 55], "kind": "commanddeclaration"}, {"full_name": "Disjoint.eq_bot_of_le", "code": "theorem Disjoint.eq_bot_of_le (hab : Disjoint a b) (h : a \u2264 b) : a = \u22a5", "start": [92, 1], "end": [93, 31], "kind": "commanddeclaration"}, {"full_name": "Disjoint.eq_bot_of_ge", "code": "theorem Disjoint.eq_bot_of_ge (hab : Disjoint a b) : b \u2264 a \u2192 b = \u22a5", "start": [96, 1], "end": [97, 24], "kind": "commanddeclaration"}, {"full_name": "disjoint_top", "code": "@[simp]\ntheorem disjoint_top : Disjoint a \u22a4 \u2194 a = \u22a5", "start": [106, 1], "end": [108, 72], "kind": "commanddeclaration"}, {"full_name": "top_disjoint", "code": "@[simp]\ntheorem top_disjoint : Disjoint \u22a4 a \u2194 a = \u22a5", "start": [111, 1], "end": [113, 72], "kind": "commanddeclaration"}, {"full_name": "disjoint_iff_inf_le", "code": "theorem disjoint_iff_inf_le : Disjoint a b \u2194 a \u2293 b \u2264 \u22a5", "start": [122, 1], "end": [123, 81], "kind": "commanddeclaration"}, {"full_name": "disjoint_iff", "code": "theorem disjoint_iff : Disjoint a b \u2194 a \u2293 b = \u22a5", "start": [126, 1], "end": [127, 39], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_bot", "code": "theorem Disjoint.le_bot : Disjoint a b \u2192 a \u2293 b \u2264 \u22a5", "start": [130, 1], "end": [131, 25], "kind": "commanddeclaration"}, {"full_name": "Disjoint.eq_bot", "code": "theorem Disjoint.eq_bot : Disjoint a b \u2192 a \u2293 b = \u22a5", "start": [134, 1], "end": [135, 31], "kind": "commanddeclaration"}, {"full_name": "disjoint_assoc", "code": "theorem disjoint_assoc : Disjoint (a \u2293 b) c \u2194 Disjoint a (b \u2293 c)", "start": [138, 1], "end": [139, 59], "kind": "commanddeclaration"}, {"full_name": "disjoint_left_comm", "code": "theorem disjoint_left_comm : Disjoint a (b \u2293 c) \u2194 Disjoint b (a \u2293 c)", "start": [142, 1], "end": [143, 47], "kind": "commanddeclaration"}, {"full_name": "disjoint_right_comm", "code": "theorem disjoint_right_comm : Disjoint (a \u2293 b) c \u2194 Disjoint (a \u2293 c) b", "start": [146, 1], "end": [147, 48], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inf_left", "code": "theorem Disjoint.inf_left (h : Disjoint a b) : Disjoint (a \u2293 c) b", "start": [152, 1], "end": [153, 26], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inf_left'", "code": "theorem Disjoint.inf_left' (h : Disjoint a b) : Disjoint (c \u2293 a) b", "start": [156, 1], "end": [157, 27], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inf_right", "code": "theorem Disjoint.inf_right (h : Disjoint a b) : Disjoint a (b \u2293 c)", "start": [160, 1], "end": [161, 27], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inf_right'", "code": "theorem Disjoint.inf_right' (h : Disjoint a b) : Disjoint a (c \u2293 b)", "start": [164, 1], "end": [165, 28], "kind": "commanddeclaration"}, {"full_name": "Disjoint.of_disjoint_inf_of_le", "code": "theorem Disjoint.of_disjoint_inf_of_le (h : Disjoint (a \u2293 b) c) (hle : a \u2264 c) : Disjoint a b", "start": [170, 1], "end": [171, 60], "kind": "commanddeclaration"}, {"full_name": "Disjoint.of_disjoint_inf_of_le'", "code": "theorem Disjoint.of_disjoint_inf_of_le' (h : Disjoint (a \u2293 b) c) (hle : b \u2264 c) : Disjoint a b", "start": [174, 1], "end": [175, 61], "kind": "commanddeclaration"}, {"full_name": "disjoint_sup_left", "code": "@[simp]\ntheorem disjoint_sup_left : Disjoint (a \u2294 b) c \u2194 Disjoint a c \u2227 Disjoint b c", "start": [184, 1], "end": [186, 58], "kind": "commanddeclaration"}, {"full_name": "disjoint_sup_right", "code": "@[simp]\ntheorem disjoint_sup_right : Disjoint a (b \u2294 c) \u2194 Disjoint a b \u2227 Disjoint a c", "start": [189, 1], "end": [191, 57], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sup_left", "code": "theorem Disjoint.sup_left (ha : Disjoint a c) (hb : Disjoint b c) : Disjoint (a \u2294 b) c", "start": [194, 1], "end": [195, 31], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sup_right", "code": "theorem Disjoint.sup_right (hb : Disjoint a b) (hc : Disjoint a c) : Disjoint a (b \u2294 c)", "start": [198, 1], "end": [199, 32], "kind": "commanddeclaration"}, {"full_name": "Disjoint.left_le_of_le_sup_right", "code": "theorem Disjoint.left_le_of_le_sup_right (h : a \u2264 b \u2294 c) (hd : Disjoint a c) : a \u2264 b", "start": [202, 1], "end": [203, 75], "kind": "commanddeclaration"}, {"full_name": "Disjoint.left_le_of_le_sup_left", "code": "theorem Disjoint.left_le_of_le_sup_left (h : a \u2264 c \u2294 b) (hd : Disjoint a c) : a \u2264 b", "start": [206, 1], "end": [207, 50], "kind": "commanddeclaration"}, {"full_name": "Codisjoint", "code": "def Codisjoint (a b : \u03b1) : Prop :=\n  \u2200 \u2983x\u2984, a \u2264 x \u2192 b \u2264 x \u2192 \u22a4 \u2264 x", "start": [220, 1], "end": [226, 31], "kind": "commanddeclaration"}, {"full_name": "Codisjoint_comm", "code": "theorem Codisjoint_comm : Codisjoint a b \u2194 Codisjoint b a", "start": [229, 1], "end": [230, 36], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.symm", "code": "@[symm]\ntheorem Codisjoint.symm \u2983a b : \u03b1\u2984 : Codisjoint a b \u2192 Codisjoint b a", "start": [233, 1], "end": [235, 20], "kind": "commanddeclaration"}, {"full_name": "symmetric_codisjoint", "code": "theorem symmetric_codisjoint : Symmetric (Codisjoint : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [238, 1], "end": [239, 18], "kind": "commanddeclaration"}, {"full_name": "codisjoint_top_left", "code": "@[simp]\ntheorem codisjoint_top_left : Codisjoint \u22a4 a", "start": [242, 1], "end": [243, 68], "kind": "commanddeclaration"}, {"full_name": "codisjoint_top_right", "code": "@[simp]\ntheorem codisjoint_top_right : Codisjoint a \u22a4", "start": [246, 1], "end": [247, 69], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.mono", "code": "theorem Codisjoint.mono (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : Codisjoint a c \u2192 Codisjoint b d", "start": [250, 1], "end": [251, 48], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.mono_left", "code": "theorem Codisjoint.mono_left (h : a \u2264 b) : Codisjoint a c \u2192 Codisjoint b c", "start": [254, 1], "end": [255, 27], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.mono_right", "code": "theorem Codisjoint.mono_right : b \u2264 c \u2192 Codisjoint a b \u2192 Codisjoint a c", "start": [258, 1], "end": [259, 25], "kind": "commanddeclaration"}, {"full_name": "codisjoint_self", "code": "@[simp]\ntheorem codisjoint_self : Codisjoint a a \u2194 a = \u22a4", "start": [262, 1], "end": [264, 79], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.eq_top_of_self", "code": "alias \u27e8Codisjoint.eq_top_of_self, _\u27e9 := codisjoint_self", "start": [269, 1], "end": [269, 56], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Codisjoint.ne", "code": "theorem Codisjoint.ne (ha : a \u2260 \u22a4) (hab : Codisjoint a b) : a \u2260 b", "start": [272, 1], "end": [273, 57], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.eq_top_of_le", "code": "theorem Codisjoint.eq_top_of_le (hab : Codisjoint a b) (h : b \u2264 a) : a = \u22a4", "start": [276, 1], "end": [277, 31], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.eq_top_of_ge", "code": "theorem Codisjoint.eq_top_of_ge (hab : Codisjoint a b) : a \u2264 b \u2192 b = \u22a4", "start": [280, 1], "end": [281, 24], "kind": "commanddeclaration"}, {"full_name": "codisjoint_bot", "code": "@[simp]\ntheorem codisjoint_bot : Codisjoint a \u22a5 \u2194 a = \u22a4", "start": [290, 1], "end": [292, 77], "kind": "commanddeclaration"}, {"full_name": "bot_codisjoint", "code": "@[simp]\ntheorem bot_codisjoint : Codisjoint \u22a5 a \u2194 a = \u22a4", "start": [295, 1], "end": [297, 77], "kind": "commanddeclaration"}, {"full_name": "codisjoint_iff_le_sup", "code": "theorem codisjoint_iff_le_sup : Codisjoint a b \u2194 \u22a4 \u2264 a \u2294 b", "start": [306, 1], "end": [307, 35], "kind": "commanddeclaration"}, {"full_name": "codisjoint_iff", "code": "theorem codisjoint_iff : Codisjoint a b \u2194 a \u2294 b = \u22a4", "start": [310, 1], "end": [311, 28], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.top_le", "code": "theorem Codisjoint.top_le : Codisjoint a b \u2192 \u22a4 \u2264 a \u2294 b", "start": [314, 1], "end": [315, 31], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.eq_top", "code": "theorem Codisjoint.eq_top : Codisjoint a b \u2192 a \u2294 b = \u22a4", "start": [318, 1], "end": [319, 31], "kind": "commanddeclaration"}, {"full_name": "codisjoint_assoc", "code": "theorem codisjoint_assoc : Codisjoint (a \u2294 b) c \u2194 Codisjoint a (b \u2294 c)", "start": [322, 1], "end": [323, 32], "kind": "commanddeclaration"}, {"full_name": "codisjoint_left_comm", "code": "theorem codisjoint_left_comm : Codisjoint a (b \u2294 c) \u2194 Codisjoint b (a \u2294 c)", "start": [326, 1], "end": [327, 36], "kind": "commanddeclaration"}, {"full_name": "codisjoint_right_comm", "code": "theorem codisjoint_right_comm : Codisjoint (a \u2294 b) c \u2194 Codisjoint (a \u2294 c) b", "start": [330, 1], "end": [331, 37], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.sup_left", "code": "theorem Codisjoint.sup_left (h : Codisjoint a b) : Codisjoint (a \u2294 c) b", "start": [336, 1], "end": [337, 26], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.sup_left'", "code": "theorem Codisjoint.sup_left' (h : Codisjoint a b) : Codisjoint (c \u2294 a) b", "start": [340, 1], "end": [341, 27], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.sup_right", "code": "theorem Codisjoint.sup_right (h : Codisjoint a b) : Codisjoint a (b \u2294 c)", "start": [344, 1], "end": [345, 27], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.sup_right'", "code": "theorem Codisjoint.sup_right' (h : Codisjoint a b) : Codisjoint a (c \u2294 b)", "start": [348, 1], "end": [349, 28], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.of_codisjoint_sup_of_le", "code": "theorem Codisjoint.of_codisjoint_sup_of_le (h : Codisjoint (a \u2294 b) c) (hle : c \u2264 a) :\n    Codisjoint a b", "start": [354, 1], "end": [356, 54], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.of_codisjoint_sup_of_le'", "code": "theorem Codisjoint.of_codisjoint_sup_of_le' (h : Codisjoint (a \u2294 b) c) (hle : c \u2264 b) :\n    Codisjoint a b", "start": [359, 1], "end": [361, 55], "kind": "commanddeclaration"}, {"full_name": "codisjoint_inf_left", "code": "@[simp]\ntheorem codisjoint_inf_left : Codisjoint (a \u2293 b) c \u2194 Codisjoint a c \u2227 Codisjoint b c", "start": [370, 1], "end": [372, 60], "kind": "commanddeclaration"}, {"full_name": "codisjoint_inf_right", "code": "@[simp]\ntheorem codisjoint_inf_right : Codisjoint a (b \u2293 c) \u2194 Codisjoint a b \u2227 Codisjoint a c", "start": [375, 1], "end": [377, 59], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.inf_left", "code": "theorem Codisjoint.inf_left (ha : Codisjoint a c) (hb : Codisjoint b c) : Codisjoint (a \u2293 b) c", "start": [380, 1], "end": [381, 33], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.inf_right", "code": "theorem Codisjoint.inf_right (hb : Codisjoint a b) (hc : Codisjoint a c) : Codisjoint a (b \u2293 c)", "start": [384, 1], "end": [385, 34], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.left_le_of_le_inf_right", "code": "theorem Codisjoint.left_le_of_le_inf_right (h : a \u2293 b \u2264 c) (hd : Codisjoint b c) : a \u2264 c", "start": [388, 1], "end": [389, 60], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.left_le_of_le_inf_left", "code": "theorem Codisjoint.left_le_of_le_inf_left (h : b \u2293 a \u2264 c) (hd : Codisjoint b c) : a \u2264 c", "start": [392, 1], "end": [393, 50], "kind": "commanddeclaration"}, {"full_name": "Disjoint.dual", "code": "theorem Disjoint.dual [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1} :\n    Disjoint a b \u2192 Codisjoint (toDual a) (toDual b)", "start": [402, 1], "end": [404, 5], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.dual", "code": "theorem Codisjoint.dual [SemilatticeSup \u03b1] [OrderTop \u03b1] {a b : \u03b1} :\n    Codisjoint a b \u2192 Disjoint (toDual a) (toDual b)", "start": [407, 1], "end": [409, 5], "kind": "commanddeclaration"}, {"full_name": "disjoint_toDual_iff", "code": "@[simp]\ntheorem disjoint_toDual_iff [SemilatticeSup \u03b1] [OrderTop \u03b1] {a b : \u03b1} :\n    Disjoint (toDual a) (toDual b) \u2194 Codisjoint a b", "start": [412, 1], "end": [415, 10], "kind": "commanddeclaration"}, {"full_name": "disjoint_ofDual_iff", "code": "@[simp]\ntheorem disjoint_ofDual_iff [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1\u1d52\u1d48} :\n    Disjoint (ofDual a) (ofDual b) \u2194 Codisjoint a b", "start": [418, 1], "end": [421, 10], "kind": "commanddeclaration"}, {"full_name": "codisjoint_toDual_iff", "code": "@[simp]\ntheorem codisjoint_toDual_iff [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1} :\n    Codisjoint (toDual a) (toDual b) \u2194 Disjoint a b", "start": [424, 1], "end": [427, 10], "kind": "commanddeclaration"}, {"full_name": "codisjoint_ofDual_iff", "code": "@[simp]\ntheorem codisjoint_ofDual_iff [SemilatticeSup \u03b1] [OrderTop \u03b1] {a b : \u03b1\u1d52\u1d48} :\n    Codisjoint (ofDual a) (ofDual b) \u2194 Disjoint a b", "start": [430, 1], "end": [433, 10], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_of_codisjoint", "code": "theorem Disjoint.le_of_codisjoint (hab : Disjoint a b) (hbc : Codisjoint b c) : a \u2264 c", "start": [440, 1], "end": [442, 39], "kind": "commanddeclaration"}, {"full_name": "IsCompl", "code": "structure IsCompl [PartialOrder \u03b1] [BoundedOrder \u03b1] (x y : \u03b1) : Prop where\n  \n  protected disjoint : Disjoint x y\n  \n  protected codisjoint : Codisjoint x y", "start": [449, 1], "end": [454, 40], "kind": "commanddeclaration"}, {"full_name": "isCompl_iff", "code": "theorem isCompl_iff [PartialOrder \u03b1] [BoundedOrder \u03b1] {a b : \u03b1} :\n    IsCompl a b \u2194 Disjoint a b \u2227 Codisjoint a b", "start": [457, 1], "end": [459, 43], "kind": "commanddeclaration"}, {"full_name": "IsCompl.symm", "code": "@[symm]\nprotected theorem symm (h : IsCompl x y) : IsCompl y x", "start": [468, 1], "end": [470, 23], "kind": "commanddeclaration"}, {"full_name": "IsCompl.dual", "code": "theorem dual (h : IsCompl x y) : IsCompl (toDual x) (toDual y)", "start": [473, 1], "end": [474, 13], "kind": "commanddeclaration"}, {"full_name": "IsCompl.ofDual", "code": "theorem ofDual {a b : \u03b1\u1d52\u1d48} (h : IsCompl a b) : IsCompl (ofDual a) (ofDual b)", "start": [477, 1], "end": [478, 13], "kind": "commanddeclaration"}, {"full_name": "IsCompl.of_le", "code": "theorem of_le (h\u2081 : x \u2293 y \u2264 \u22a5) (h\u2082 : \u22a4 \u2264 x \u2294 y) : IsCompl x y", "start": [487, 1], "end": [488, 61], "kind": "commanddeclaration"}, {"full_name": "IsCompl.of_eq", "code": "theorem of_eq (h\u2081 : x \u2293 y = \u22a5) (h\u2082 : x \u2294 y = \u22a4) : IsCompl x y", "start": [491, 1], "end": [492, 47], "kind": "commanddeclaration"}, {"full_name": "IsCompl.inf_eq_bot", "code": "theorem inf_eq_bot (h : IsCompl x y) : x \u2293 y = \u22a5", "start": [495, 1], "end": [496, 20], "kind": "commanddeclaration"}, {"full_name": "IsCompl.sup_eq_top", "code": "theorem sup_eq_top (h : IsCompl x y) : x \u2294 y = \u22a4", "start": [499, 1], "end": [500, 22], "kind": "commanddeclaration"}, {"full_name": "IsCompl.inf_left_le_of_le_sup_right", "code": "theorem inf_left_le_of_le_sup_right (h : IsCompl x y) (hle : a \u2264 b \u2294 y) : a \u2293 x \u2264 b", "start": [507, 1], "end": [512, 25], "kind": "commanddeclaration"}, {"full_name": "IsCompl.le_sup_right_iff_inf_left_le", "code": "theorem le_sup_right_iff_inf_left_le {a b} (h : IsCompl x y) : a \u2264 b \u2294 y \u2194 a \u2293 x \u2264 b", "start": [515, 1], "end": [516, 75], "kind": "commanddeclaration"}, {"full_name": "IsCompl.inf_left_eq_bot_iff", "code": "theorem inf_left_eq_bot_iff (h : IsCompl y z) : x \u2293 y = \u22a5 \u2194 x \u2264 z", "start": [519, 1], "end": [520, 66], "kind": "commanddeclaration"}, {"full_name": "IsCompl.inf_right_eq_bot_iff", "code": "theorem inf_right_eq_bot_iff (h : IsCompl y z) : x \u2293 z = \u22a5 \u2194 x \u2264 y", "start": [523, 1], "end": [524, 29], "kind": "commanddeclaration"}, {"full_name": "IsCompl.disjoint_left_iff", "code": "theorem disjoint_left_iff (h : IsCompl y z) : Disjoint x y \u2194 x \u2264 z", "start": [527, 1], "end": [529, 30], "kind": "commanddeclaration"}, {"full_name": "IsCompl.disjoint_right_iff", "code": "theorem disjoint_right_iff (h : IsCompl y z) : Disjoint x z \u2194 x \u2264 y", "start": [532, 1], "end": [533, 27], "kind": "commanddeclaration"}, {"full_name": "IsCompl.le_left_iff", "code": "theorem le_left_iff (h : IsCompl x y) : z \u2264 x \u2194 Disjoint z y", "start": [536, 1], "end": [537, 28], "kind": "commanddeclaration"}, {"full_name": "IsCompl.le_right_iff", "code": "theorem le_right_iff (h : IsCompl x y) : z \u2264 y \u2194 Disjoint z x", "start": [540, 1], "end": [541, 21], "kind": "commanddeclaration"}, {"full_name": "IsCompl.left_le_iff", "code": "theorem left_le_iff (h : IsCompl x y) : x \u2264 z \u2194 Codisjoint z y", "start": [544, 1], "end": [545, 21], "kind": "commanddeclaration"}, {"full_name": "IsCompl.right_le_iff", "code": "theorem right_le_iff (h : IsCompl x y) : y \u2264 z \u2194 Codisjoint z x", "start": [548, 1], "end": [549, 21], "kind": "commanddeclaration"}, {"full_name": "IsCompl.Antitone", "code": "protected theorem Antitone {x' y'} (h : IsCompl x y) (h' : IsCompl x' y') (hx : x \u2264 x') : y' \u2264 y", "start": [552, 1], "end": [553, 55], "kind": "commanddeclaration"}, {"full_name": "IsCompl.right_unique", "code": "theorem right_unique (hxy : IsCompl x y) (hxz : IsCompl x z) : y = z", "start": [556, 1], "end": [557, 78], "kind": "commanddeclaration"}, {"full_name": "IsCompl.left_unique", "code": "theorem left_unique (hxz : IsCompl x z) (hyz : IsCompl y z) : x = y", "start": [560, 1], "end": [561, 33], "kind": "commanddeclaration"}, {"full_name": "IsCompl.sup_inf", "code": "theorem sup_inf {x' y'} (h : IsCompl x y) (h' : IsCompl x' y') : IsCompl (x \u2294 x') (y \u2293 y')", "start": [564, 1], "end": [569, 60], "kind": "commanddeclaration"}, {"full_name": "IsCompl.inf_sup", "code": "theorem inf_sup {x' y'} (h : IsCompl x y) (h' : IsCompl x' y') : IsCompl (x \u2293 x') (y \u2294 y')", "start": [572, 1], "end": [573, 32], "kind": "commanddeclaration"}, {"full_name": "Prod.disjoint_iff", "code": "protected theorem disjoint_iff [OrderBot \u03b1] [OrderBot \u03b2] {x y : \u03b1 \u00d7 \u03b2} :\n    Disjoint x y \u2194 Disjoint x.1 y.1 \u2227 Disjoint x.2 y.2", "start": [582, 1], "end": [590, 45], "kind": "commanddeclaration"}, {"full_name": "Prod.codisjoint_iff", "code": "protected theorem codisjoint_iff [OrderTop \u03b1] [OrderTop \u03b2] {x y : \u03b1 \u00d7 \u03b2} :\n    Codisjoint x y \u2194 Codisjoint x.1 y.1 \u2227 Codisjoint x.2 y.2", "start": [593, 1], "end": [595, 41], "kind": "commanddeclaration"}, {"full_name": "Prod.isCompl_iff", "code": "protected theorem isCompl_iff [BoundedOrder \u03b1] [BoundedOrder \u03b2] {x y : \u03b1 \u00d7 \u03b2} :\n    IsCompl x y \u2194 IsCompl x.1 y.1 \u2227 IsCompl x.2 y.2", "start": [598, 1], "end": [600, 82], "kind": "commanddeclaration"}, {"full_name": "isCompl_toDual_iff", "code": "@[simp]\ntheorem isCompl_toDual_iff : IsCompl (toDual a) (toDual b) \u2194 IsCompl a b", "start": [609, 1], "end": [611, 33], "kind": "commanddeclaration"}, {"full_name": "isCompl_ofDual_iff", "code": "@[simp]\ntheorem isCompl_ofDual_iff {a b : \u03b1\u1d52\u1d48} : IsCompl (ofDual a) (ofDual b) \u2194 IsCompl a b", "start": [614, 1], "end": [616, 33], "kind": "commanddeclaration"}, {"full_name": "isCompl_bot_top", "code": "theorem isCompl_bot_top : IsCompl (\u22a5 : \u03b1) \u22a4", "start": [619, 1], "end": [620, 38], "kind": "commanddeclaration"}, {"full_name": "isCompl_top_bot", "code": "theorem isCompl_top_bot : IsCompl (\u22a4 : \u03b1) \u22a5", "start": [623, 1], "end": [624, 38], "kind": "commanddeclaration"}, {"full_name": "eq_top_of_isCompl_bot", "code": "theorem eq_top_of_isCompl_bot (h : IsCompl x \u22a5) : x = \u22a4", "start": [627, 1], "end": [628, 37], "kind": "commanddeclaration"}, {"full_name": "eq_top_of_bot_isCompl", "code": "theorem eq_top_of_bot_isCompl (h : IsCompl \u22a5 x) : x = \u22a4", "start": [631, 1], "end": [632, 31], "kind": "commanddeclaration"}, {"full_name": "eq_bot_of_isCompl_top", "code": "theorem eq_bot_of_isCompl_top (h : IsCompl x \u22a4) : x = \u22a5", "start": [635, 1], "end": [636, 31], "kind": "commanddeclaration"}, {"full_name": "eq_bot_of_top_isCompl", "code": "theorem eq_bot_of_top_isCompl (h : IsCompl \u22a4 x) : x = \u22a5", "start": [639, 1], "end": [640, 31], "kind": "commanddeclaration"}, {"full_name": "IsComplemented", "code": "def IsComplemented (a : \u03b1) : Prop :=\n  \u2203 b, IsCompl a b", "start": [651, 1], "end": [653, 19], "kind": "commanddeclaration"}, {"full_name": "isComplemented_bot", "code": "theorem isComplemented_bot : IsComplemented (\u22a5 : \u03b1)", "start": [656, 1], "end": [657, 23], "kind": "commanddeclaration"}, {"full_name": "isComplemented_top", "code": "theorem isComplemented_top : IsComplemented (\u22a4 : \u03b1)", "start": [660, 1], "end": [661, 23], "kind": "commanddeclaration"}, {"full_name": "IsComplemented.sup", "code": "theorem IsComplemented.sup : IsComplemented a \u2192 IsComplemented b \u2192 IsComplemented (a \u2294 b)", "start": [668, 1], "end": [669, 52], "kind": "commanddeclaration"}, {"full_name": "IsComplemented.inf", "code": "theorem IsComplemented.inf : IsComplemented a \u2192 IsComplemented b \u2192 IsComplemented (a \u2293 b)", "start": [672, 1], "end": [673, 52], "kind": "commanddeclaration"}, {"full_name": "ComplementedLattice", "code": "class ComplementedLattice (\u03b1) [Lattice \u03b1] [BoundedOrder \u03b1] : Prop where\n  \n  exists_isCompl : \u2200 a : \u03b1, \u2203 b : \u03b1, IsCompl a b", "start": [678, 1], "end": [682, 49], "kind": "commanddeclaration"}, {"full_name": "Complementeds", "code": "@[reducible]\ndef Complementeds (\u03b1 : Type*) [Lattice \u03b1] [BoundedOrder \u03b1] : Type _ := {a : \u03b1 // IsComplemented a}", "start": [699, 1], "end": [701, 99], "kind": "commanddeclaration"}, {"full_name": "Complementeds.hasCoeT", "code": "instance hasCoeT : CoeTC (Complementeds \u03b1) \u03b1 := \u27e8Subtype.val\u27e9", "start": [710, 1], "end": [710, 62], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : Complementeds \u03b1 \u2192 \u03b1)", "start": [713, 1], "end": [713, 87], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj : (a : \u03b1) = b \u2194 a = b", "start": [716, 1], "end": [717, 57], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_le_coe", "code": "@[norm_cast]\ntheorem coe_le_coe : (a : \u03b1) \u2264 b \u2194 a \u2264 b", "start": [721, 1], "end": [722, 52], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_lt_coe", "code": "@[norm_cast]\ntheorem coe_lt_coe : (a : \u03b1) < b \u2194 a < b", "start": [726, 1], "end": [727, 52], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : Complementeds \u03b1) : \u03b1) = \u22a5", "start": [733, 1], "end": [734, 57], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : Complementeds \u03b1) : \u03b1) = \u22a4", "start": [737, 1], "end": [738, 57], "kind": "commanddeclaration"}, {"full_name": "Complementeds.mk_bot", "code": "theorem mk_bot : (\u27e8\u22a5, isComplemented_bot\u27e9 : Complementeds \u03b1) = \u22a5", "start": [742, 1], "end": [742, 72], "kind": "commanddeclaration"}, {"full_name": "Complementeds.mk_top", "code": "theorem mk_top : (\u27e8\u22a4, isComplemented_top\u27e9 : Complementeds \u03b1) = \u22a4", "start": [746, 1], "end": [746, 72], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (a b : Complementeds \u03b1) : \u2191(a \u2294 b) = (a : \u03b1) \u2294 b", "start": [761, 1], "end": [762, 72], "kind": "commanddeclaration"}, {"full_name": "Complementeds.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (a b : Complementeds \u03b1) : \u2191(a \u2293 b) = (a : \u03b1) \u2293 b", "start": [765, 1], "end": [766, 72], "kind": "commanddeclaration"}, {"full_name": "Complementeds.mk_sup_mk", "code": "@[simp]\ntheorem mk_sup_mk {a b : \u03b1} (ha : IsComplemented a) (hb : IsComplemented b) :\n    (\u27e8a, ha\u27e9 \u2294 \u27e8b, hb\u27e9 : Complementeds \u03b1) = \u27e8a \u2294 b, ha.sup hb\u27e9", "start": [769, 1], "end": [771, 70], "kind": "commanddeclaration"}, {"full_name": "Complementeds.mk_inf_mk", "code": "@[simp]\ntheorem mk_inf_mk {a b : \u03b1} (ha : IsComplemented a) (hb : IsComplemented b) :\n    (\u27e8a, ha\u27e9 \u2293 \u27e8b, hb\u27e9 : Complementeds \u03b1) = \u27e8a \u2293 b, ha.inf hb\u27e9", "start": [774, 1], "end": [776, 70], "kind": "commanddeclaration"}, {"full_name": "Complementeds.disjoint_coe", "code": "@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (a : \u03b1) b \u2194 Disjoint a b", "start": [782, 1], "end": [784, 65], "kind": "commanddeclaration"}, {"full_name": "Complementeds.codisjoint_coe", "code": "@[simp, norm_cast]\ntheorem codisjoint_coe : Codisjoint (a : \u03b1) b \u2194 Codisjoint a b", "start": [787, 1], "end": [789, 69], "kind": "commanddeclaration"}, {"full_name": "Complementeds.isCompl_coe", "code": "@[simp, norm_cast]\ntheorem isCompl_coe : IsCompl (a : \u03b1) b \u2194 IsCompl a b", "start": [792, 1], "end": [794, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/RelIso/Basic.lean", "imports": ["Mathlib/Data/FunLike/Basic.lean", "Mathlib/Logic/Embedding/Basic.lean", "Mathlib/Order/RelClasses.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RelHom", "code": "structure RelHom {\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_rel' : \u2200 {a b}, r a b \u2192 s (toFun a) (toFun b)", "start": [46, 1], "end": [52, 52], "kind": "commanddeclaration"}, {"full_name": "RelHomClass", "code": "class RelHomClass (F : Type*) {\u03b1 \u03b2 : outParam <| Type*} (r : outParam <| \u03b1 \u2192 \u03b1 \u2192 Prop)\n  (s : outParam <| \u03b2 \u2192 \u03b2 \u2192 Prop) extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_rel : \u2200 (f : F) {a b}, r a b \u2192 s (f a) (f b)", "start": [61, 1], "end": [70, 51], "kind": "commanddeclaration"}, {"full_name": "RelHomClass.isIrrefl", "code": "protected theorem isIrrefl [RelHomClass F r s] (f : F) : \u2200 [IsIrrefl \u03b2 s], IsIrrefl \u03b1 r", "start": [81, 1], "end": [82, 42], "kind": "commanddeclaration"}, {"full_name": "RelHomClass.isAsymm", "code": "protected theorem isAsymm [RelHomClass F r s] (f : F) : \u2200 [IsAsymm \u03b2 s], IsAsymm \u03b1 r", "start": [85, 1], "end": [86, 66], "kind": "commanddeclaration"}, {"full_name": "RelHomClass.acc", "code": "protected theorem acc [RelHomClass F r s] (f : F) (a : \u03b1) : Acc s (f a) \u2192 Acc r a", "start": [89, 1], "end": [94, 55], "kind": "commanddeclaration"}, {"full_name": "RelHomClass.wellFounded", "code": "protected theorem wellFounded [RelHomClass F r s] (f : F) : \u2200 _ : WellFounded s, WellFounded r", "start": [97, 1], "end": [98, 48], "kind": "commanddeclaration"}, {"full_name": "RelHom.map_rel", "code": "protected theorem map_rel (f : r \u2192r s) {a b} : r a b \u2192 s (f a) (f b)", "start": [115, 1], "end": [116, 13], "kind": "commanddeclaration"}, {"full_name": "RelHom.coe_fn_toFun", "code": "@[simp]\ntheorem coe_fn_toFun (f : r \u2192r s) : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "RelHom.coe_fn_injective", "code": "theorem coe_fn_injective : Injective fun (f : r \u2192r s) => (f : \u03b1 \u2192 \u03b2)", "start": [124, 1], "end": [126, 24], "kind": "commanddeclaration"}, {"full_name": "RelHom.ext", "code": "@[ext]\ntheorem ext \u2983f g : r \u2192r s\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [129, 1], "end": [131, 20], "kind": "commanddeclaration"}, {"full_name": "RelHom.ext_iff", "code": "theorem ext_iff {f g : r \u2192r s} : f = g \u2194 \u2200 x, f x = g x", "start": [134, 1], "end": [135, 18], "kind": "commanddeclaration"}, {"full_name": "RelHom.id", "code": "@[refl, simps]\nprotected def id (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : r \u2192r r :=\n  \u27e8fun x => x, fun x => x\u27e9", "start": [138, 1], "end": [141, 27], "kind": "commanddeclaration"}, {"full_name": "RelHom.comp", "code": "@[simps]\nprotected def comp (g : s \u2192r t) (f : r \u2192r s) : r \u2192r t :=\n  \u27e8fun x => g (f x), fun h => g.2 (f.2 h)\u27e9", "start": [145, 1], "end": [148, 43], "kind": "commanddeclaration"}, {"full_name": "RelHom.swap", "code": "protected def swap (f : r \u2192r s) : swap r \u2192r swap s :=\n  \u27e8f, f.map_rel\u27e9", "start": [152, 1], "end": [154, 17], "kind": "commanddeclaration"}, {"full_name": "RelHom.preimage", "code": "def preimage (f : \u03b1 \u2192 \u03b2) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : f \u207b\u00b9'o s \u2192r s :=\n  \u27e8f, id\u27e9", "start": [157, 1], "end": [159, 10], "kind": "commanddeclaration"}, {"full_name": "injective_of_increasing", "code": "theorem injective_of_increasing (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrichotomous \u03b1 r]\n    [IsIrrefl \u03b2 s] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 {x y}, r x y \u2192 s (f x) (f y)) : Injective f", "start": [164, 1], "end": [177, 33], "kind": "commanddeclaration"}, {"full_name": "RelHom.injective_of_increasing", "code": "theorem RelHom.injective_of_increasing [IsTrichotomous \u03b1 r] [IsIrrefl \u03b2 s] (f : r \u2192r s) :\n    Injective f", "start": [180, 1], "end": [183, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.wellFounded_iff", "code": "theorem Function.Surjective.wellFounded_iff {f : \u03b1 \u2192 \u03b2} (hf : Surjective f)\n    (o : \u2200 {a b}, r a b \u2194 s (f a) (f b)) :\n    WellFounded r \u2194 WellFounded s", "start": [186, 1], "end": [192, 50], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding", "code": "structure RelEmbedding {\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) extends \u03b1 \u21aa \u03b2 where\n  \n  map_rel_iff' : \u2200 {a b}, s (toEmbedding a) (toEmbedding b) \u2194 r a b", "start": [195, 1], "end": [199, 68], "kind": "commanddeclaration"}, {"full_name": "Subtype.relEmbedding", "code": "def Subtype.relEmbedding {X : Type*} (r : X \u2192 X \u2192 Prop) (p : X \u2192 Prop) :\n    (Subtype.val : Subtype p \u2192 X) \u207b\u00b9'o r \u21aar r :=\n  \u27e8Embedding.subtype p, Iff.rfl\u27e9", "start": [206, 1], "end": [209, 33], "kind": "commanddeclaration"}, {"full_name": "preimage_equivalence", "code": "theorem preimage_equivalence {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (hs : Equivalence s) :\n    Equivalence (f \u207b\u00b9'o s)", "start": [212, 1], "end": [214, 62], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.toRelHom", "code": "def toRelHom (f : r \u21aar s) : r \u2192r s where\n  toFun := f.toEmbedding.toFun\n  map_rel' := (map_rel_iff' f).mpr", "start": [219, 1], "end": [222, 35], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.Simps.apply", "code": "def Simps.apply (h : r \u21aar s) : \u03b1 \u2192 \u03b2 :=\n  h", "start": [243, 1], "end": [247, 4], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_toEmbedding", "code": "@[simp]\ntheorem coe_toEmbedding : ((f : r \u21aar s).toEmbedding : \u03b1 \u2192 \u03b2) = f", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_toRelHom", "code": "@[simp]\ntheorem coe_toRelHom : ((f : r \u21aar s).toRelHom : \u03b1 \u2192 \u03b2) = f", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.injective", "code": "theorem injective (f : r \u21aar s) : Injective f", "start": [260, 1], "end": [261, 9], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.inj", "code": "theorem inj (f : r \u21aar s) {a b} : f a = f b \u2194 a = b", "start": [264, 1], "end": [265, 21], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.map_rel_iff", "code": "theorem map_rel_iff (f : r \u21aar s) {a b} : s (f a) (f b) \u2194 r a b", "start": [268, 1], "end": [269, 17], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_mk", "code": "@[simp]\ntheorem coe_mk : \u21d1(\u27e8f, h\u27e9 : r \u21aar s) = f", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_fn_injective", "code": "theorem coe_fn_injective : Injective fun f : r \u21aar s => (f : \u03b1 \u2192 \u03b2)", "start": [277, 1], "end": [279, 24], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ext", "code": "@[ext]\ntheorem ext \u2983f g : r \u21aar s\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [282, 1], "end": [284, 20], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ext_iff", "code": "theorem ext_iff {f g : r \u21aar s} : f = g \u2194 \u2200 x, f x = g x", "start": [287, 1], "end": [288, 18], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.refl", "code": "@[refl, simps!]\nprotected def refl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : r \u21aar r :=\n  \u27e8Embedding.refl _, Iff.rfl\u27e9", "start": [291, 1], "end": [294, 30], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.trans", "code": "protected def trans (f : r \u21aar s) (g : s \u21aar t) : r \u21aar t :=\n  \u27e8f.1.trans g.1, by simp [f.map_rel_iff, g.map_rel_iff]\u27e9", "start": [298, 1], "end": [300, 58], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.trans_apply", "code": "theorem trans_apply (f : r \u21aar s) (g : s \u21aar t) (a : \u03b1) : (f.trans g) a = g (f a)", "start": [306, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_trans", "code": "@[simp]\ntheorem coe_trans (f : r \u21aar s) (g : s \u21aar t) : (f.trans g) = g \u2218 f", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.swap", "code": "protected def swap (f : r \u21aar s) : swap r \u21aar swap s :=\n  \u27e8f.toEmbedding, f.map_rel_iff\u27e9", "start": [315, 1], "end": [317, 33], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.preimage", "code": "def preimage (f : \u03b1 \u21aa \u03b2) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : f \u207b\u00b9'o s \u21aar s :=\n  \u27e8f, Iff.rfl\u27e9", "start": [320, 1], "end": [323, 15], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.eq_preimage", "code": "theorem eq_preimage (f : r \u21aar s) : r = f \u207b\u00b9'o s", "start": [326, 1], "end": [328, 27], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isIrrefl", "code": "protected theorem isIrrefl (f : r \u21aar s) [IsIrrefl \u03b2 s] : IsIrrefl \u03b1 r", "start": [331, 1], "end": [332, 47], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isRefl", "code": "protected theorem isRefl (f : r \u21aar s) [IsRefl \u03b2 s] : IsRefl \u03b1 r", "start": [335, 1], "end": [336, 39], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isSymm", "code": "protected theorem isSymm (f : r \u21aar s) [IsSymm \u03b2 s] : IsSymm \u03b1 r", "start": [339, 1], "end": [340, 64], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isAsymm", "code": "protected theorem isAsymm (f : r \u21aar s) [IsAsymm \u03b2 s] : IsAsymm \u03b1 r", "start": [343, 1], "end": [344, 69], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isAntisymm", "code": "protected theorem isAntisymm : \u2200 (_ : r \u21aar s) [IsAntisymm \u03b2 s], IsAntisymm \u03b1 r", "start": [347, 1], "end": [348, 71], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isTrans", "code": "protected theorem isTrans : \u2200 (_ : r \u21aar s) [IsTrans \u03b2 s], IsTrans \u03b1 r", "start": [351, 1], "end": [352, 72], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isTotal", "code": "protected theorem isTotal : \u2200 (_ : r \u21aar s) [IsTotal \u03b2 s], IsTotal \u03b1 r", "start": [355, 1], "end": [356, 57], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isPreorder", "code": "protected theorem isPreorder : \u2200 (_ : r \u21aar s) [IsPreorder \u03b2 s], IsPreorder \u03b1 r", "start": [359, 1], "end": [360, 41], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isPartialOrder", "code": "protected theorem isPartialOrder : \u2200 (_ : r \u21aar s) [IsPartialOrder \u03b2 s], IsPartialOrder \u03b1 r", "start": [363, 1], "end": [364, 48], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isLinearOrder", "code": "protected theorem isLinearOrder : \u2200 (_ : r \u21aar s) [IsLinearOrder \u03b2 s], IsLinearOrder \u03b1 r", "start": [367, 1], "end": [368, 49], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isStrictOrder", "code": "protected theorem isStrictOrder : \u2200 (_ : r \u21aar s) [IsStrictOrder \u03b2 s], IsStrictOrder \u03b1 r", "start": [371, 1], "end": [372, 43], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isTrichotomous", "code": "protected theorem isTrichotomous : \u2200 (_ : r \u21aar s) [IsTrichotomous \u03b2 s], IsTrichotomous \u03b1 r", "start": [375, 1], "end": [376, 82], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isStrictTotalOrder", "code": "protected theorem isStrictTotalOrder : \u2200 (_ : r \u21aar s) [IsStrictTotalOrder \u03b2 s],\n    IsStrictTotalOrder \u03b1 r", "start": [379, 1], "end": [381, 55], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.acc", "code": "protected theorem acc (f : r \u21aar s) (a : \u03b1) : Acc s (f a) \u2192 Acc r a", "start": [384, 1], "end": [389, 61], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.wellFounded", "code": "protected theorem wellFounded : \u2200 (_ : r \u21aar s) (_ : WellFounded s), WellFounded r", "start": [392, 1], "end": [393, 39], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isWellFounded", "code": "protected theorem isWellFounded (f : r \u21aar s) [IsWellFounded \u03b2 s] : IsWellFounded \u03b1 r", "start": [396, 1], "end": [397, 35], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.isWellOrder", "code": "protected theorem isWellOrder : \u2200 (_ : r \u21aar s) [IsWellOrder \u03b2 s], IsWellOrder \u03b1 r", "start": [400, 1], "end": [401, 67], "kind": "commanddeclaration"}, {"full_name": "Subtype.wellFoundedLT", "code": "instance Subtype.wellFoundedLT [LT \u03b1] [WellFoundedLT \u03b1] (p : \u03b1 \u2192 Prop) :\n    WellFoundedLT (Subtype p) :=\n  (Subtype.relEmbedding (\u00b7 < \u00b7) p).isWellFounded", "start": [406, 1], "end": [408, 49], "kind": "commanddeclaration"}, {"full_name": "Subtype.wellFoundedGT", "code": "instance Subtype.wellFoundedGT [LT \u03b1] [WellFoundedGT \u03b1] (p : \u03b1 \u2192 Prop) :\n    WellFoundedGT (Subtype p) :=\n  (Subtype.relEmbedding (\u00b7 > \u00b7) p).isWellFounded", "start": [411, 1], "end": [413, 49], "kind": "commanddeclaration"}, {"full_name": "Quotient.mkRelHom", "code": "@[simps]\ndef Quotient.mkRelHom [Setoid \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (H : \u2200 (a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1), a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 r a\u2081 b\u2081 = r a\u2082 b\u2082) : r \u2192r Quotient.lift\u2082 r H :=\n  \u27e8@Quotient.mk' \u03b1 _, id\u27e9", "start": [416, 1], "end": [420, 26], "kind": "commanddeclaration"}, {"full_name": "Quotient.outRelEmbedding", "code": "@[simps!]\nnoncomputable def Quotient.outRelEmbedding [Setoid \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (H : \u2200 (a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1), a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 r a\u2081 b\u2081 = r a\u2082 b\u2082) : Quotient.lift\u2082 r H \u21aar r :=\n  \u27e8Embedding.quotientOut \u03b1, by\n    refine' @fun x y => Quotient.inductionOn\u2082 x y fun a b => _\n    apply iff_iff_eq.2 (H _ _ _ _ _ _) <;> apply Quotient.mk_out\u27e9", "start": [423, 1], "end": [429, 66], "kind": "commanddeclaration"}, {"full_name": "Quotient.out'RelEmbedding", "code": "@[simps]\nnoncomputable def Quotient.out'RelEmbedding {_ : Setoid \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (H : \u2200 (a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1), a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 r a\u2081 b\u2081 = r a\u2082 b\u2082) :\n    (fun a b => Quotient.liftOn\u2082' a b r H) \u21aar r :=\n  { Quotient.outRelEmbedding H with toFun := Quotient.out' }", "start": [433, 1], "end": [438, 61], "kind": "commanddeclaration"}, {"full_name": "acc_lift\u2082_iff", "code": "@[simp]\ntheorem acc_lift\u2082_iff [Setoid \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {H : \u2200 (a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1), a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 r a\u2081 b\u2081 = r a\u2082 b\u2082} {a} :\n    Acc (Quotient.lift\u2082 r H) \u27e6a\u27e7 \u2194 Acc r a", "start": [441, 1], "end": [451, 18], "kind": "commanddeclaration"}, {"full_name": "acc_liftOn\u2082'_iff", "code": "@[simp]\ntheorem acc_liftOn\u2082'_iff {s : Setoid \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {H} {a} :\n    Acc (fun x y => Quotient.liftOn\u2082' x y r H) (Quotient.mk'' a : Quotient s) \u2194 Acc r a", "start": [454, 1], "end": [457, 25], "kind": "commanddeclaration"}, {"full_name": "wellFounded_lift\u2082_iff", "code": "@[simp]\ntheorem wellFounded_lift\u2082_iff [Setoid \u03b1] {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {H : \u2200 (a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1), a\u2081 \u2248 a\u2082 \u2192 b\u2081 \u2248 b\u2082 \u2192 r a\u2081 b\u2081 = r a\u2082 b\u2082} :\n    WellFounded (Quotient.lift\u2082 r H) \u2194 WellFounded r", "start": [460, 1], "end": [469, 39], "kind": "commanddeclaration"}, {"full_name": "WellFounded.of_quotient_lift\u2082", "code": "alias \u27e8WellFounded.of_quotient_lift\u2082, WellFounded.quotient_lift\u2082\u27e9 := wellFounded_lift\u2082_iff", "start": [472, 1], "end": [472, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WellFounded.quotient_lift\u2082", "code": "alias \u27e8WellFounded.of_quotient_lift\u2082, WellFounded.quotient_lift\u2082\u27e9 := wellFounded_lift\u2082_iff", "start": [472, 1], "end": [472, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "wellFounded_liftOn\u2082'_iff", "code": "@[simp]\ntheorem wellFounded_liftOn\u2082'_iff {s : Setoid \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {H} :\n    (WellFounded fun x y : Quotient s => Quotient.liftOn\u2082' x y r H) \u2194 WellFounded r", "start": [476, 1], "end": [479, 33], "kind": "commanddeclaration"}, {"full_name": "WellFounded.of_quotient_liftOn\u2082'", "code": "alias \u27e8WellFounded.of_quotient_liftOn\u2082', WellFounded.quotient_liftOn\u2082'\u27e9 := wellFounded_liftOn\u2082'_iff", "start": [482, 1], "end": [482, 100], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WellFounded.quotient_liftOn\u2082'", "code": "alias \u27e8WellFounded.of_quotient_liftOn\u2082', WellFounded.quotient_liftOn\u2082'\u27e9 := wellFounded_liftOn\u2082'_iff", "start": [482, 1], "end": [482, 100], "kind": "stdtacticaliasaliaslr"}, {"full_name": "RelEmbedding.ofMapRelIff", "code": "def ofMapRelIff (f : \u03b1 \u2192 \u03b2) [IsAntisymm \u03b1 r] [IsRefl \u03b2 s] (hf : \u2200 a b, s (f a) (f b) \u2194 r a b) :\n    r \u21aar s where\n  toFun := f\n  inj' _ _ h := antisymm ((hf _ _).1 (h \u25b8 refl _)) ((hf _ _).1 (h \u25b8 refl _))\n  map_rel_iff' := hf _ _", "start": [488, 1], "end": [495, 25], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ofMapRelIff_coe", "code": "@[simp]\ntheorem ofMapRelIff_coe (f : \u03b1 \u2192 \u03b2) [IsAntisymm \u03b1 r] [IsRefl \u03b2 s]\n    (hf : \u2200 a b, s (f a) (f b) \u2194 r a b) :\n    (ofMapRelIff f hf : r \u21aar s) = f", "start": [498, 1], "end": [502, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ofMonotone", "code": "def ofMonotone [IsTrichotomous \u03b1 r] [IsAsymm \u03b2 s] (f : \u03b1 \u2192 \u03b2) (H : \u2200 a b, r a b \u2192 s (f a) (f b)) :\n    r \u21aar s := by\n  haveI := @IsAsymm.isIrrefl \u03b2 s _\n  refine' \u27e8\u27e8f, fun a b e => _\u27e9, @fun a b => \u27e8fun h => _, H _ _\u27e9\u27e9\n  \u00b7 refine' ((@trichotomous _ r _ a b).resolve_left _).resolve_right _ <;>\n      exact fun h => @irrefl _ s _ _ (by simpa [e] using H _ _ h)\n  \u00b7 refine' (@trichotomous _ r _ a b).resolve_right (Or.rec (fun e => _) fun h' => _)\n    \u00b7 subst e\n      exact irrefl _ h\n    \u00b7 exact asymm (H _ _ h') h", "start": [505, 1], "end": [516, 31], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ofMonotone_coe", "code": "@[simp]\ntheorem ofMonotone_coe [IsTrichotomous \u03b1 r] [IsAsymm \u03b2 s] (f : \u03b1 \u2192 \u03b2) (H) :\n    (@ofMonotone _ _ r s _ _ f H : \u03b1 \u2192 \u03b2) = f", "start": [519, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ofIsEmpty", "code": "def ofIsEmpty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsEmpty \u03b1] : r \u21aar s :=\n  \u27e8Embedding.ofIsEmpty, @fun a => isEmptyElim a\u27e9", "start": [525, 1], "end": [527, 49], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLiftRelInl", "code": "@[simps]\ndef sumLiftRelInl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : r \u21aar Sum.LiftRel r s where\n  toFun := Sum.inl\n  inj' := Sum.inl_injective\n  map_rel_iff' := Sum.liftRel_inl_inl", "start": [530, 1], "end": [535, 38], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLiftRelInr", "code": "@[simps]\ndef sumLiftRelInr (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : s \u21aar Sum.LiftRel r s where\n  toFun := Sum.inr\n  inj' := Sum.inr_injective\n  map_rel_iff' := Sum.liftRel_inr_inr", "start": [539, 1], "end": [544, 38], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLiftRelMap", "code": "@[simps]\ndef sumLiftRelMap (f : r \u21aar s) (g : t \u21aar u) : Sum.LiftRel r t \u21aar Sum.LiftRel s u where\n  toFun := Sum.map f g\n  inj' := f.injective.sum_map g.injective\n  map_rel_iff' := by rintro (a | b) (c | d) <;> simp [f.map_rel_iff, g.map_rel_iff]", "start": [548, 1], "end": [553, 84], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLexInl", "code": "@[simps]\ndef sumLexInl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : r \u21aar Sum.Lex r s where\n  toFun := Sum.inl\n  inj' := Sum.inl_injective\n  map_rel_iff' := Sum.lex_inl_inl", "start": [557, 1], "end": [562, 34], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLexInr", "code": "@[simps]\ndef sumLexInr (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : s \u21aar Sum.Lex r s where\n  toFun := Sum.inr\n  inj' := Sum.inr_injective\n  map_rel_iff' := Sum.lex_inr_inr", "start": [566, 1], "end": [571, 34], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.sumLexMap", "code": "@[simps]\ndef sumLexMap (f : r \u21aar s) (g : t \u21aar u) : Sum.Lex r t \u21aar Sum.Lex s u where\n  toFun := Sum.map f g\n  inj' := f.injective.sum_map g.injective\n  map_rel_iff' := by rintro (a | b) (c | d) <;> simp [f.map_rel_iff, g.map_rel_iff]", "start": [575, 1], "end": [580, 84], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.prodLexMkLeft", "code": "@[simps]\ndef prodLexMkLeft (s : \u03b2 \u2192 \u03b2 \u2192 Prop) {a : \u03b1} (h : \u00acr a a) : s \u21aar Prod.Lex r s where\n  toFun := Prod.mk a\n  inj' := Prod.mk.inj_left a\n  map_rel_iff' := by simp [Prod.lex_def, h]", "start": [584, 1], "end": [589, 44], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.prodLexMkRight", "code": "@[simps]\ndef prodLexMkRight (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {b : \u03b2} (h : \u00acs b b) : r \u21aar Prod.Lex r s where\n  toFun a := (a, b)\n  inj' := Prod.mk.inj_right b\n  map_rel_iff' := by simp [Prod.lex_def, h]", "start": [593, 1], "end": [598, 44], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.prodLexMap", "code": "@[simps]\ndef prodLexMap (f : r \u21aar s) (g : t \u21aar u) : Prod.Lex r t \u21aar Prod.Lex s u where\n  toFun := Prod.map f g\n  inj' := f.injective.Prod_map g.injective\n  map_rel_iff' := by simp [Prod.lex_def, f.map_rel_iff, g.map_rel_iff, f.inj]", "start": [602, 1], "end": [607, 78], "kind": "commanddeclaration"}, {"full_name": "RelIso", "code": "structure RelIso {\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) extends \u03b1 \u2243 \u03b2 where\n  \n  map_rel_iff' : \u2200 {a b}, s (toEquiv a) (toEquiv b) \u2194 r a b", "start": [613, 1], "end": [616, 60], "kind": "commanddeclaration"}, {"full_name": "RelIso.toRelEmbedding", "code": "def toRelEmbedding (f : r \u2243r s) : r \u21aar s :=\n  \u27e8f.toEquiv.toEmbedding, f.map_rel_iff'\u27e9", "start": [624, 1], "end": [628, 42], "kind": "commanddeclaration"}, {"full_name": "RelIso.toEquiv_injective", "code": "theorem toEquiv_injective : Injective (toEquiv : r \u2243r s \u2192 \u03b1 \u2243 \u03b2)", "start": [631, 1], "end": [632, 37], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_toRelEmbedding", "code": "@[simp]\ntheorem coe_toRelEmbedding (f : r \u2243r s) : (f.toRelEmbedding : \u03b1 \u2192 \u03b2) = f", "start": [653, 1], "end": [655, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_toEmbedding", "code": "@[simp]\ntheorem coe_toEmbedding (f : r \u2243r s) : (f.toEmbedding : \u03b1 \u2192 \u03b2) = f", "start": [657, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (f : r \u2243r s) : (f.toEquiv : \u03b1 \u2192 \u03b2) = f", "start": [661, 1], "end": [663, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.map_rel_iff", "code": "theorem map_rel_iff (f : r \u2243r s) {a b} : s (f a) (f b) \u2194 r a b", "start": [665, 1], "end": [666, 17], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_fn_mk", "code": "@[simp]\ntheorem coe_fn_mk (f : \u03b1 \u2243 \u03b2) (o : \u2200 \u2983a b\u2984, s (f a) (f b) \u2194 r a b) :\n    (RelIso.mk f @o : \u03b1 \u2192 \u03b2) = f", "start": [669, 1], "end": [672, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_fn_toEquiv", "code": "@[simp]\ntheorem coe_fn_toEquiv (f : r \u2243r s) : (f.toEquiv : \u03b1 \u2192 \u03b2) = f", "start": [675, 1], "end": [677, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_fn_injective", "code": "theorem coe_fn_injective : Injective fun f : r \u2243r s => (f : \u03b1 \u2192 \u03b2)", "start": [680, 1], "end": [683, 24], "kind": "commanddeclaration"}, {"full_name": "RelIso.ext", "code": "@[ext]\ntheorem ext \u2983f g : r \u2243r s\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [686, 1], "end": [688, 20], "kind": "commanddeclaration"}, {"full_name": "RelIso.ext_iff", "code": "theorem ext_iff {f g : r \u2243r s} : f = g \u2194 \u2200 x, f x = g x", "start": [691, 1], "end": [692, 18], "kind": "commanddeclaration"}, {"full_name": "RelIso.symm", "code": "protected def symm (f : r \u2243r s) : s \u2243r r :=\n  \u27e8f.toEquiv.symm, @fun a b => by erw [\u2190 f.map_rel_iff, f.1.apply_symm_apply, f.1.apply_symm_apply]\u27e9", "start": [695, 1], "end": [697, 101], "kind": "commanddeclaration"}, {"full_name": "RelIso.Simps.apply", "code": "def Simps.apply (h : r \u2243r s) : \u03b1 \u2192 \u03b2 :=\n  h", "start": [700, 1], "end": [703, 4], "kind": "commanddeclaration"}, {"full_name": "RelIso.Simps.symm_apply", "code": "def Simps.symm_apply (h : r \u2243r s) : \u03b2 \u2192 \u03b1 :=\n  h.symm", "start": [706, 1], "end": [708, 9], "kind": "commanddeclaration"}, {"full_name": "RelIso.refl", "code": "@[refl, simps! apply]\nprotected def refl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : r \u2243r r :=\n  \u27e8Equiv.refl _, Iff.rfl\u27e9", "start": [713, 1], "end": [716, 26], "kind": "commanddeclaration"}, {"full_name": "RelIso.trans", "code": "@[simps! apply]\nprotected def trans (f\u2081 : r \u2243r s) (f\u2082 : s \u2243r t) : r \u2243r t :=\n  \u27e8f\u2081.toEquiv.trans f\u2082.toEquiv, f\u2082.map_rel_iff.trans f\u2081.map_rel_iff\u27e9", "start": [720, 1], "end": [723, 69], "kind": "commanddeclaration"}, {"full_name": "RelIso.default_def", "code": "@[simp]\ntheorem default_def (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : default = RelIso.refl r", "start": [730, 1], "end": [732, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.cast", "code": "@[simps! toEquiv apply]\nprotected def cast {\u03b1 \u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (h\u2081 : \u03b1 = \u03b2)\n    (h\u2082 : HEq r s) : r \u2243r s :=\n  \u27e8Equiv.cast h\u2081, @fun a b => by\n    subst h\u2081\n    rw [eq_of_heq h\u2082]\n    rfl\u27e9", "start": [735, 1], "end": [742, 9], "kind": "commanddeclaration"}, {"full_name": "RelIso.cast_symm", "code": "@[simp]\nprotected theorem cast_symm {\u03b1 \u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (h\u2081 : \u03b1 = \u03b2)\n    (h\u2082 : HEq r s) : (RelIso.cast h\u2081 h\u2082).symm = RelIso.cast h\u2081.symm h\u2082.symm", "start": [747, 1], "end": [750, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.cast_refl", "code": "@[simp]\nprotected theorem cast_refl {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (h\u2081 : \u03b1 = \u03b1 := rfl)\n    (h\u2082 : HEq r r := HEq.rfl) : RelIso.cast h\u2081 h\u2082 = RelIso.refl r", "start": [753, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.cast_trans", "code": "@[simp]\nprotected theorem cast_trans {\u03b1 \u03b2 \u03b3 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    {t : \u03b3 \u2192 \u03b3 \u2192 Prop} (h\u2081 : \u03b1 = \u03b2) (h\u2081' : \u03b2 = \u03b3) (h\u2082 : HEq r s) (h\u2082' : HEq s t) :\n    (RelIso.cast h\u2081 h\u2082).trans (RelIso.cast h\u2081' h\u2082') = RelIso.cast (h\u2081.trans h\u2081') (h\u2082.trans h\u2082')", "start": [759, 1], "end": [763, 32], "kind": "commanddeclaration"}, {"full_name": "RelIso.swap", "code": "protected def swap (f : r \u2243r s) : swap r \u2243r swap s :=\n  \u27e8f.toEquiv, f.map_rel_iff\u27e9", "start": [766, 1], "end": [768, 29], "kind": "commanddeclaration"}, {"full_name": "RelIso.coe_fn_symm_mk", "code": "@[simp]\ntheorem coe_fn_symm_mk (f o) : ((@RelIso.mk _ _ r s f @o).symm : \u03b2 \u2192 \u03b1) = f.symm", "start": [771, 1], "end": [773, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : r \u2243r s) (x : \u03b2) : e (e.symm x) = x", "start": [776, 1], "end": [778, 31], "kind": "commanddeclaration"}, {"full_name": "RelIso.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : r \u2243r s) (x : \u03b1) : e.symm (e x) = x", "start": [781, 1], "end": [783, 31], "kind": "commanddeclaration"}, {"full_name": "RelIso.rel_symm_apply", "code": "theorem rel_symm_apply (e : r \u2243r s) {x y} : r x (e.symm y) \u2194 s (e x) y", "start": [786, 1], "end": [787, 43], "kind": "commanddeclaration"}, {"full_name": "RelIso.symm_apply_rel", "code": "theorem symm_apply_rel (e : r \u2243r s) {x y} : r (e.symm x) y \u2194 s x (e y)", "start": [790, 1], "end": [791, 43], "kind": "commanddeclaration"}, {"full_name": "RelIso.bijective", "code": "protected theorem bijective (e : r \u2243r s) : Bijective e", "start": [794, 1], "end": [795, 22], "kind": "commanddeclaration"}, {"full_name": "RelIso.injective", "code": "protected theorem injective (e : r \u2243r s) : Injective e", "start": [798, 1], "end": [799, 22], "kind": "commanddeclaration"}, {"full_name": "RelIso.surjective", "code": "protected theorem surjective (e : r \u2243r s) : Surjective e", "start": [802, 1], "end": [803, 23], "kind": "commanddeclaration"}, {"full_name": "RelIso.eq_iff_eq", "code": "theorem eq_iff_eq (f : r \u2243r s) {a b} : f a = f b \u2194 a = b", "start": [806, 1], "end": [807, 21], "kind": "commanddeclaration"}, {"full_name": "RelIso.preimage", "code": "protected def preimage (f : \u03b1 \u2243 \u03b2) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : f \u207b\u00b9'o s \u2243r s :=\n  \u27e8f, Iff.rfl\u27e9", "start": [810, 1], "end": [812, 15], "kind": "commanddeclaration"}, {"full_name": "RelIso.IsWellOrder.preimage", "code": "instance IsWellOrder.preimage {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (f : \u03b2 \u2243 \u03b1) :\n    IsWellOrder \u03b2 (f \u207b\u00b9'o r) :=\n  @RelEmbedding.isWellOrder _ _ (f \u207b\u00b9'o r) r (RelIso.preimage f r) _", "start": [815, 1], "end": [817, 69], "kind": "commanddeclaration"}, {"full_name": "RelIso.IsWellOrder.ulift", "code": "instance IsWellOrder.ulift {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    IsWellOrder (ULift \u03b1) (ULift.down \u207b\u00b9'o r) :=\n  IsWellOrder.preimage r Equiv.ulift", "start": [820, 1], "end": [822, 37], "kind": "commanddeclaration"}, {"full_name": "RelIso.ofSurjective", "code": "@[simps! apply]\nnoncomputable def ofSurjective (f : r \u21aar s) (H : Surjective f) : r \u2243r s :=\n  \u27e8Equiv.ofBijective f \u27e8f.injective, H\u27e9, f.map_rel_iff\u27e9", "start": [825, 1], "end": [828, 56], "kind": "commanddeclaration"}, {"full_name": "RelIso.sumLexCongr", "code": "def sumLexCongr {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 r\u2081 r\u2082 s\u2081 s\u2082} (e\u2081 : @RelIso \u03b1\u2081 \u03b2\u2081 r\u2081 s\u2081) (e\u2082 : @RelIso \u03b1\u2082 \u03b2\u2082 r\u2082 s\u2082) :\n    Sum.Lex r\u2081 r\u2082 \u2243r Sum.Lex s\u2081 s\u2082 :=\n  \u27e8Equiv.sumCongr e\u2081.toEquiv e\u2082.toEquiv, @fun a b => by\n    cases' e\u2081 with f hf; cases' e\u2082 with g hg; cases a <;> cases b <;> simp [hf, hg]\u27e9", "start": [832, 1], "end": [838, 85], "kind": "commanddeclaration"}, {"full_name": "RelIso.prodLexCongr", "code": "def prodLexCongr {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 r\u2081 r\u2082 s\u2081 s\u2082} (e\u2081 : @RelIso \u03b1\u2081 \u03b2\u2081 r\u2081 s\u2081) (e\u2082 : @RelIso \u03b1\u2082 \u03b2\u2082 r\u2082 s\u2082) :\n    Prod.Lex r\u2081 r\u2082 \u2243r Prod.Lex s\u2081 s\u2082 :=\n  \u27e8Equiv.prodCongr e\u2081.toEquiv e\u2082.toEquiv, by simp [Prod.lex_def, e\u2081.map_rel_iff, e\u2082.map_rel_iff,\n    e\u2081.injective.eq_iff]\u27e9", "start": [841, 1], "end": [847, 26], "kind": "commanddeclaration"}, {"full_name": "RelIso.relIsoOfIsEmpty", "code": "def relIsoOfIsEmpty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsEmpty \u03b1] [IsEmpty \u03b2] : r \u2243r s :=\n  \u27e8Equiv.equivOfIsEmpty \u03b1 \u03b2, @fun a => isEmptyElim a\u27e9", "start": [850, 1], "end": [852, 54], "kind": "commanddeclaration"}, {"full_name": "RelIso.relIsoOfUniqueOfIrrefl", "code": "def relIsoOfUniqueOfIrrefl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsIrrefl \u03b1 r]\n    [IsIrrefl \u03b2 s] [Unique \u03b1] [Unique \u03b2] : r \u2243r s :=\n  \u27e8Equiv.equivOfUnique \u03b1 \u03b2, iff_of_false (not_rel_of_subsingleton s _ _)\n      (not_rel_of_subsingleton r _ _) \u27e9", "start": [855, 1], "end": [859, 40], "kind": "commanddeclaration"}, {"full_name": "RelIso.relIsoOfUniqueOfRefl", "code": "def relIsoOfUniqueOfRefl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsRefl \u03b1 r] [IsRefl \u03b2 s]\n    [Unique \u03b1] [Unique \u03b2] : r \u2243r s :=\n  \u27e8Equiv.equivOfUnique \u03b1 \u03b2, iff_of_true (rel_of_subsingleton s _ _) (rel_of_subsingleton r _ _)\u27e9", "start": [862, 1], "end": [865, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ToLevel.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Mathport/Rename.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.ToLevel", "code": "@[pp_with_univ]\nclass ToLevel.{u} where\n  \n  toLevel : Level\n  \n  univ : Type u := Sort u", "start": [24, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.ToLevel.max", "code": "def ToLevel.max [ToLevel.{u}] [ToLevel.{v}] : ToLevel.{max u v} where\n  toLevel := .max toLevel.{u} toLevel.{v}", "start": [43, 1], "end": [45, 42], "kind": "commanddeclaration"}, {"full_name": "Lean.ToLevel.imax", "code": "def ToLevel.imax [ToLevel.{u}] [ToLevel.{v}] : ToLevel.{imax u v} where\n  toLevel := .imax toLevel.{u} toLevel.{v}", "start": [47, 1], "end": [49, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/ZeroLEOne.lean", "imports": ["Mathlib/Algebra/NeZero.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZeroLEOneClass", "code": "class ZeroLEOneClass (\u03b1 : Type*) [Zero \u03b1] [One \u03b1] [LE \u03b1] : Prop where\n  \n  zero_le_one : (0 : \u03b1) \u2264 1", "start": [19, 1], "end": [22, 28], "kind": "commanddeclaration"}, {"full_name": "zero_le_one", "code": "@[simp] lemma zero_le_one [Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1] : (0 : \u03b1) \u2264 1 :=\n  ZeroLEOneClass.zero_le_one", "start": [25, 1], "end": [27, 29], "kind": "mathlibtacticlemma"}, {"full_name": "zero_le_one'", "code": "lemma zero_le_one' (\u03b1) [Zero \u03b1] [One \u03b1] [LE \u03b1] [ZeroLEOneClass \u03b1] : (0 : \u03b1) \u2264 1 :=\n  zero_le_one", "start": [30, 1], "end": [32, 14], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_one", "code": "@[simp] lemma zero_lt_one : (0 : \u03b1) < 1 := zero_le_one.lt_of_ne (NeZero.ne' 1)", "start": [38, 1], "end": [39, 79], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_one'", "code": "lemma zero_lt_one' : (0 : \u03b1) < 1 := zero_lt_one", "start": [44, 1], "end": [45, 48], "kind": "mathlibtacticlemma"}, {"full_name": "one_pos", "code": "alias one_pos := zero_lt_one", "start": [50, 1], "end": [50, 29], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/Algebra/Group/WithOne/Defs.lean", "imports": ["Mathlib/Order/WithBot.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithOne", "code": "@[to_additive \"Add an extra element `0` to a type\"]\ndef WithOne (\u03b1) :=\n  Option \u03b1", "start": [35, 1], "end": [38, 11], "kind": "commanddeclaration"}, {"full_name": "WithOne.monad", "code": "@[to_additive]\ninstance monad : Monad WithOne :=\n  instMonadOption", "start": [57, 1], "end": [59, 18], "kind": "commanddeclaration"}, {"full_name": "WithOne.one", "code": "@[to_additive]\ninstance one : One (WithOne \u03b1) :=\n  \u27e8none\u27e9", "start": [61, 1], "end": [63, 9], "kind": "commanddeclaration"}, {"full_name": "WithOne.mul", "code": "@[to_additive]\ninstance mul [Mul \u03b1] : Mul (WithOne \u03b1) :=\n  \u27e8Option.liftOrGet (\u00b7 * \u00b7)\u27e9", "start": [67, 1], "end": [69, 29], "kind": "commanddeclaration"}, {"full_name": "WithOne.inv", "code": "@[to_additive]\ninstance inv [Inv \u03b1] : Inv (WithOne \u03b1) :=\n  \u27e8fun a => Option.map Inv.inv a\u27e9", "start": [73, 1], "end": [75, 34], "kind": "commanddeclaration"}, {"full_name": "WithOne.invOneClass", "code": "@[to_additive]\ninstance invOneClass [Inv \u03b1] : InvOneClass (WithOne \u03b1) :=\n  { WithOne.one, WithOne.inv with inv_one := rfl }", "start": [79, 1], "end": [81, 51], "kind": "commanddeclaration"}, {"full_name": "WithOne.inhabited", "code": "@[to_additive]\ninstance inhabited : Inhabited (WithOne \u03b1) :=\n  \u27e81\u27e9", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.nontrivial", "code": "@[to_additive]\ninstance nontrivial [Nonempty \u03b1] : Nontrivial (WithOne \u03b1) :=\n  Option.nontrivial", "start": [87, 1], "end": [89, 20], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe", "code": "@[to_additive (attr := coe) \"The canonical map from `\u03b1` into `WithZero \u03b1`\"]\ndef coe : \u03b1 \u2192 WithOne \u03b1 :=\n  Option.some", "start": [94, 1], "end": [97, 14], "kind": "commanddeclaration"}, {"full_name": "WithOne.coeTC", "code": "@[to_additive]\ninstance coeTC : CoeTC \u03b1 (WithOne \u03b1) :=\n  \u27e8coe\u27e9", "start": [99, 1], "end": [101, 8], "kind": "commanddeclaration"}, {"full_name": "WithOne.recOneCoe", "code": "@[to_additive (attr := elab_as_elim)\n  \"Recursor for `WithZero` using the preferred forms `0` and `\u2191a`.\"]\ndef recOneCoe {C : WithOne \u03b1 \u2192 Sort*} (h\u2081 : C 1) (h\u2082 : \u2200 a : \u03b1, C a) : \u2200 n : WithOne \u03b1, C n\n  | Option.none => h\u2081\n  | Option.some x => h\u2082 x", "start": [103, 1], "end": [108, 26], "kind": "commanddeclaration"}, {"full_name": "WithOne.unone", "code": "@[to_additive unzero\n      \"Deconstruct an `x : WithZero \u03b1` to the underlying value in `\u03b1`, given a proof that `x \u2260 0`.\"]\ndef unone {x : WithOne \u03b1} (hx : x \u2260 1) : \u03b1 :=\n  WithBot.unbot x hx", "start": [119, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "WithOne.unone_coe", "code": "@[to_additive (attr := simp) unzero_coe]\ntheorem unone_coe {x : \u03b1} (hx : (x : WithOne \u03b1) \u2260 1) : unone hx = x", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe_unone", "code": "@[to_additive (attr := simp) coe_unzero]\ntheorem coe_unone {x : WithOne \u03b1} (hx : x \u2260 1) : \u2191(unone hx) = x", "start": [133, 1], "end": [135, 25], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe_ne_one", "code": "@[to_additive (attr := simp)]\ntheorem coe_ne_one {a : \u03b1} : (a : WithOne \u03b1) \u2260 (1 : WithOne \u03b1)", "start": [144, 1], "end": [146, 24], "kind": "commanddeclaration"}, {"full_name": "WithOne.one_ne_coe", "code": "@[to_additive (attr := simp)]\ntheorem one_ne_coe {a : \u03b1} : (1 : WithOne \u03b1) \u2260 a", "start": [150, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "WithOne.ne_one_iff_exists", "code": "@[to_additive]\ntheorem ne_one_iff_exists {x : WithOne \u03b1} : x \u2260 1 \u2194 \u2203 a : \u03b1, \u2191a = x", "start": [156, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "WithOne.canLift", "code": "@[to_additive]\ninstance canLift : CanLift (WithOne \u03b1) \u03b1 (\u2191) fun a => a \u2260 1 where\n  prf _ := ne_one_iff_exists.1", "start": [162, 1], "end": [164, 31], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe_inj", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inj {a b : \u03b1} : (a : WithOne \u03b1) = b \u2194 a = b", "start": [168, 1], "end": [170, 18], "kind": "commanddeclaration"}, {"full_name": "WithOne.cases_on", "code": "@[to_additive (attr := elab_as_elim)]\nprotected theorem cases_on {P : WithOne \u03b1 \u2192 Prop} : \u2200 x : WithOne \u03b1, P 1 \u2192 (\u2200 a : \u03b1, P a) \u2192 P x", "start": [174, 1], "end": [176, 17], "kind": "commanddeclaration"}, {"full_name": "WithOne.mulOneClass", "code": "@[to_additive]\ninstance mulOneClass [Mul \u03b1] : MulOneClass (WithOne \u03b1) where\n  mul := (\u00b7 * \u00b7)\n  one := 1\n  one_mul := (Option.liftOrGet_isLeftId _).1\n  mul_one := (Option.liftOrGet_isRightId _).1", "start": [183, 1], "end": [188, 46], "kind": "commanddeclaration"}, {"full_name": "WithOne.monoid", "code": "@[to_additive]\ninstance monoid [Semigroup \u03b1] : Monoid (WithOne \u03b1) :=\n  { WithOne.mulOneClass with mul_assoc := (Option.liftOrGet_isAssociative _).1 }", "start": [190, 1], "end": [192, 81], "kind": "commanddeclaration"}, {"full_name": "WithOne.commMonoid", "code": "@[to_additive]\ninstance commMonoid [CommSemigroup \u03b1] : CommMonoid (WithOne \u03b1) :=\n  { WithOne.monoid with mul_comm := (Option.liftOrGet_isCommutative _).1 }", "start": [194, 1], "end": [196, 75], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul [Mul \u03b1] (a b : \u03b1) : ((a * b : \u03b1) : WithOne \u03b1) = a * b", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "WithOne.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv [Inv \u03b1] (a : \u03b1) : ((a\u207b\u00b9 : \u03b1) : WithOne \u03b1) = (a : WithOne \u03b1)\u207b\u00b9", "start": [204, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.one", "code": "instance one [one : One \u03b1] : One (WithZero \u03b1) :=\n  { one with }", "start": [214, 1], "end": [215, 15], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one [One \u03b1] : ((1 : \u03b1) : WithZero \u03b1) = 1", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.mulZeroClass", "code": "instance mulZeroClass [Mul \u03b1] : MulZeroClass (WithZero \u03b1) :=\n  { WithZero.zero with\n    mul := Option.map\u2082 (\u00b7 * \u00b7),\n    zero_mul := Option.map\u2082_none_left (\u00b7 * \u00b7),\n    mul_zero := Option.map\u2082_none_right (\u00b7 * \u00b7) }", "start": [222, 1], "end": [226, 49], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul {\u03b1 : Type u} [Mul \u03b1] {a b : \u03b1} : ((a * b : \u03b1) : WithZero \u03b1) = a * b", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.noZeroDivisors", "code": "instance noZeroDivisors [Mul \u03b1] : NoZeroDivisors (WithZero \u03b1) :=\n  \u27e8Option.map\u2082_eq_none_iff.1\u27e9", "start": [233, 1], "end": [234, 30], "kind": "commanddeclaration"}, {"full_name": "WithZero.semigroupWithZero", "code": "instance semigroupWithZero [Semigroup \u03b1] : SemigroupWithZero (WithZero \u03b1) :=\n  { WithZero.mulZeroClass with\n    mul_assoc := fun _ _ _ => Option.map\u2082_assoc mul_assoc }", "start": [236, 1], "end": [238, 60], "kind": "commanddeclaration"}, {"full_name": "WithZero.commSemigroup", "code": "instance commSemigroup [CommSemigroup \u03b1] : CommSemigroup (WithZero \u03b1) :=\n  { WithZero.semigroupWithZero with\n    mul_comm := fun _ _ => Option.map\u2082_comm mul_comm }", "start": [240, 1], "end": [242, 55], "kind": "commanddeclaration"}, {"full_name": "WithZero.mulZeroOneClass", "code": "instance mulZeroOneClass [MulOneClass \u03b1] : MulZeroOneClass (WithZero \u03b1) :=\n  { WithZero.mulZeroClass, WithZero.one with\n    one_mul := Option.map\u2082_left_identity one_mul,\n    mul_one := Option.map\u2082_right_identity mul_one }", "start": [244, 1], "end": [247, 52], "kind": "commanddeclaration"}, {"full_name": "WithZero.pow", "code": "instance pow [One \u03b1] [Pow \u03b1 \u2115] : Pow (WithZero \u03b1) \u2115 :=\n  \u27e8fun x n =>\n    match x, n with\n    | none, 0 => 1\n    | none, _ + 1 => 0\n    | some x, n => \u2191(x ^ n)\u27e9", "start": [249, 1], "end": [254, 29], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow [One \u03b1] [Pow \u03b1 \u2115] {a : \u03b1} (n : \u2115) :\n    \u2191(a ^ n : \u03b1) = ((a : WithZero \u03b1) ^ n : WithZero \u03b1)", "start": [256, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.monoidWithZero", "code": "instance monoidWithZero [Monoid \u03b1] : MonoidWithZero (WithZero \u03b1) :=\n  { WithZero.mulZeroOneClass, WithZero.semigroupWithZero with\n    npow := fun n x => x ^ n,\n    npow_zero := fun x =>\n      match x with\n      | none => rfl\n      | some x => congr_arg some <| pow_zero x,\n    npow_succ := fun n x =>\n      match x with\n      | none => rfl\n      | some x => congr_arg some <| pow_succ x n }", "start": [262, 1], "end": [272, 51], "kind": "commanddeclaration"}, {"full_name": "WithZero.commMonoidWithZero", "code": "instance commMonoidWithZero [CommMonoid \u03b1] : CommMonoidWithZero (WithZero \u03b1) :=\n  { WithZero.monoidWithZero, WithZero.commSemigroup with }", "start": [274, 1], "end": [275, 59], "kind": "commanddeclaration"}, {"full_name": "WithZero.inv", "code": "instance inv [Inv \u03b1] : Inv (WithZero \u03b1) :=\n  \u27e8fun a => Option.map Inv.inv a\u27e9", "start": [277, 1], "end": [280, 34], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv [Inv \u03b1] (a : \u03b1) : ((a\u207b\u00b9 : \u03b1) : WithZero \u03b1) = (\u2191a)\u207b\u00b9", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.inv_zero", "code": "@[simp]\ntheorem inv_zero [Inv \u03b1] : (0 : WithZero \u03b1)\u207b\u00b9 = 0", "start": [287, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.invOneClass", "code": "instance invOneClass [InvOneClass \u03b1] : InvOneClass (WithZero \u03b1) :=\n  { WithZero.one, WithZero.inv with inv_one := show ((1\u207b\u00b9 : \u03b1) : WithZero \u03b1) = 1 by simp }", "start": [292, 1], "end": [293, 91], "kind": "commanddeclaration"}, {"full_name": "WithZero.div", "code": "instance div [Div \u03b1] : Div (WithZero \u03b1) :=\n  \u27e8Option.map\u2082 (\u00b7 / \u00b7)\u27e9", "start": [295, 1], "end": [296, 24], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_div", "code": "@[norm_cast]\ntheorem coe_div [Div \u03b1] (a b : \u03b1) : \u2191(a / b : \u03b1) = (a / b : WithZero \u03b1)", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_zpow", "code": "@[simp, norm_cast]\ntheorem coe_zpow [DivInvMonoid \u03b1] {a : \u03b1} (n : \u2124) : \u2191(a ^ n : \u03b1) = ((\u2191a : WithZero \u03b1) ^ n)", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.divInvMonoid", "code": "instance divInvMonoid [DivInvMonoid \u03b1] : DivInvMonoid (WithZero \u03b1) :=\n  { WithZero.div, WithZero.inv, WithZero.monoidWithZero with\n    div_eq_mul_inv := fun a b =>\n      match a, b with\n      | none, _ => rfl\n      | some _, none => rfl\n      | some a, some b => congr_arg some (div_eq_mul_inv a b),\n    zpow := fun n x => x ^ n,\n    zpow_zero' := fun x =>\n      match x with\n      | none => rfl\n      | some x => congr_arg some <| zpow_zero x,\n    zpow_succ' := fun n x =>\n      match x with\n      | none => rfl\n      | some x => congr_arg some <| DivInvMonoid.zpow_succ' n x,\n    zpow_neg' := fun n x =>\n      match x with\n      | none => rfl\n      | some x => congr_arg some <| DivInvMonoid.zpow_neg' n x }", "start": [316, 1], "end": [335, 65], "kind": "commanddeclaration"}, {"full_name": "WithZero.divInvOneMonoid", "code": "instance divInvOneMonoid [DivInvOneMonoid \u03b1] : DivInvOneMonoid (WithZero \u03b1) :=\n  { WithZero.divInvMonoid, WithZero.invOneClass with }", "start": [337, 1], "end": [338, 55], "kind": "commanddeclaration"}, {"full_name": "WithZero.groupWithZero", "code": "instance groupWithZero : GroupWithZero (WithZero \u03b1) :=\n  { WithZero.monoidWithZero, WithZero.divInvMonoid, WithZero.nontrivial with\n    inv_zero := inv_zero,\n    mul_inv_cancel := fun a ha \u21a6 by\n      lift a to \u03b1 using ha\n      norm_cast\n      apply mul_right_inv }", "start": [344, 1], "end": [351, 28], "kind": "commanddeclaration"}, {"full_name": "WithZero.commGroupWithZero", "code": "instance commGroupWithZero [CommGroup \u03b1] : CommGroupWithZero (WithZero \u03b1) :=\n  { WithZero.groupWithZero, WithZero.commMonoidWithZero with }", "start": [355, 1], "end": [356, 63], "kind": "commanddeclaration"}, {"full_name": "WithZero.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne \u03b1] : AddMonoidWithOne (WithZero \u03b1) :=\n  { WithZero.addMonoid, WithZero.one with\n    natCast := fun n => if n = 0 then 0 else (n.cast : \u03b1),\n    natCast_zero := rfl,\n    natCast_succ := fun n => by\n      cases n with\n      | zero => show (((1 : \u2115) : \u03b1) : WithZero \u03b1) = 0 + 1; \u00b7 rw [Nat.cast_one, coe_one, zero_add]\n      | succ n =>\n          show (((n + 2 : \u2115) : \u03b1) : WithZero \u03b1) = ((n + 1 : \u2115) : \u03b1) + 1\n          rw [Nat.cast_succ, coe_add, coe_one]\n      }", "start": [358, 1], "end": [368, 8], "kind": "commanddeclaration"}, {"full_name": "WithZero.semiring", "code": "instance semiring [Semiring \u03b1] : Semiring (WithZero \u03b1) :=\n  { WithZero.addMonoidWithOne, WithZero.addCommMonoid, WithZero.mulZeroClass,\n    WithZero.monoidWithZero with\n    left_distrib := fun a b c => by\n      cases' a with a; \u00b7 rfl\n      cases' b with b <;> cases' c with c <;> try rfl\n      exact congr_arg some (left_distrib _ _ _),\n    right_distrib := fun a b c => by\n      cases' c with c\n      \u00b7 change (a + b) * 0 = a * 0 + b * 0\n        simp\n      cases' a with a <;> cases' b with b <;> try rfl\n      exact congr_arg some (right_distrib _ _ _) }", "start": [370, 1], "end": [382, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Order/BoundedOrder.lean", "Mathlib/Order/MinMax.lean"], "premises": [{"full_name": "ExistsMulOfLE", "code": "class ExistsMulOfLE (\u03b1 : Type u) [Mul \u03b1] [LE \u03b1] : Prop where\n  \n  exists_mul_of_le : \u2200 {a b : \u03b1}, a \u2264 b \u2192 \u2203 c : \u03b1, b = a * c", "start": [24, 1], "end": [29, 61], "kind": "commanddeclaration"}, {"full_name": "ExistsAddOfLE", "code": "class ExistsAddOfLE (\u03b1 : Type u) [Add \u03b1] [LE \u03b1] : Prop where\n  \n  exists_add_of_le : \u2200 {a b : \u03b1}, a \u2264 b \u2192 \u2203 c : \u03b1, b = a + c", "start": [32, 1], "end": [37, 61], "kind": "commanddeclaration"}, {"full_name": "Group.existsMulOfLE", "code": "@[to_additive]\ninstance (priority := 100) Group.existsMulOfLE (\u03b1 : Type u) [Group \u03b1] [LE \u03b1] : ExistsMulOfLE \u03b1 :=\n  \u27e8fun {a b} _ => \u27e8a\u207b\u00b9 * b, (mul_inv_cancel_left _ _).symm\u27e9\u27e9", "start": [47, 1], "end": [49, 61], "kind": "commanddeclaration"}, {"full_name": "exists_one_lt_mul_of_lt'", "code": "@[to_additive]\ntheorem exists_one_lt_mul_of_lt' (h : a < b) : \u2203 c, 1 < c \u2227 a * c = b", "start": [58, 1], "end": [61, 43], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_one_lt_le_mul", "code": "@[to_additive]\ntheorem le_of_forall_one_lt_le_mul (h : \u2200 \u03b5 : \u03b1, 1 < \u03b5 \u2192 a \u2264 b * \u03b5) : a \u2264 b", "start": [72, 1], "end": [76, 51], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_one_lt_lt_mul'", "code": "@[to_additive]\ntheorem le_of_forall_one_lt_lt_mul' (h : \u2200 \u03b5 : \u03b1, 1 < \u03b5 \u2192 a < b * \u03b5) : a \u2264 b", "start": [80, 1], "end": [82, 53], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_one_lt_lt_mul'", "code": "@[to_additive]\ntheorem le_iff_forall_one_lt_lt_mul' : a \u2264 b \u2194 \u2200 \u03b5, 1 < \u03b5 \u2192 a < b * \u03b5", "start": [86, 1], "end": [88, 69], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedAddCommMonoid", "code": "class CanonicallyOrderedAddCommMonoid (\u03b1 : Type*) extends OrderedAddCommMonoid \u03b1, Bot \u03b1 where\n  \n  protected bot_le : \u2200 x : \u03b1, \u22a5 \u2264 x\n  \n  protected exists_add_of_le : \u2200 {a b : \u03b1}, a \u2264 b \u2192 \u2203 c, b = a + c\n  \n  protected le_self_add : \u2200 a b : \u03b1, a \u2264 a + b", "start": [95, 1], "end": [106, 47], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedAddCommMonoid.toOrderBot", "code": "instance (priority := 100) CanonicallyOrderedAddCommMonoid.toOrderBot (\u03b1 : Type u)\n    [h : CanonicallyOrderedAddCommMonoid \u03b1] : OrderBot \u03b1 :=\n  { h with }", "start": [111, 1], "end": [113, 13], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommMonoid", "code": "@[to_additive]\nclass CanonicallyOrderedCommMonoid (\u03b1 : Type*) extends OrderedCommMonoid \u03b1, Bot \u03b1 where\n  \n  protected bot_le : \u2200 x : \u03b1, \u22a5 \u2264 x\n  \n  protected exists_mul_of_le : \u2200 {a b : \u03b1}, a \u2264 b \u2192 \u2203 c, b = a * c\n  \n  protected le_self_mul : \u2200 a b : \u03b1, a \u2264 a * b", "start": [116, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommMonoid.toOrderBot", "code": "@[to_additive existing]\ninstance (priority := 100) CanonicallyOrderedCommMonoid.toOrderBot (\u03b1 : Type u)\n    [h : CanonicallyOrderedCommMonoid \u03b1] : OrderBot \u03b1 :=\n  { h with }", "start": [136, 1], "end": [139, 13], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommMonoid.existsMulOfLE", "code": "@[to_additive]\ninstance (priority := 100) CanonicallyOrderedCommMonoid.existsMulOfLE (\u03b1 : Type u)\n    [h : CanonicallyOrderedCommMonoid \u03b1] : ExistsMulOfLE \u03b1 :=\n  { h with }", "start": [143, 1], "end": [146, 13], "kind": "commanddeclaration"}, {"full_name": "le_self_mul", "code": "@[to_additive]\ntheorem le_self_mul : a \u2264 a * c", "start": [154, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "le_mul_self", "code": "@[to_additive]\ntheorem le_mul_self : a \u2264 b * a", "start": [160, 1], "end": [163, 20], "kind": "commanddeclaration"}, {"full_name": "self_le_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem self_le_mul_right (a b : \u03b1) : a \u2264 a * b", "start": [167, 1], "end": [169, 14], "kind": "commanddeclaration"}, {"full_name": "self_le_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem self_le_mul_left (a b : \u03b1) : a \u2264 b * a", "start": [173, 1], "end": [175, 14], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_left", "code": "@[to_additive]\ntheorem le_of_mul_le_left : a * b \u2264 c \u2192 a \u2264 c", "start": [179, 1], "end": [181, 20], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_right", "code": "@[to_additive]\ntheorem le_of_mul_le_right : a * b \u2264 c \u2192 b \u2264 c", "start": [185, 1], "end": [187, 20], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_left", "code": "@[to_additive]\ntheorem le_mul_of_le_left : a \u2264 b \u2192 a \u2264 b * c", "start": [191, 1], "end": [193, 21], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_right", "code": "@[to_additive]\ntheorem le_mul_of_le_right : a \u2264 c \u2192 a \u2264 b * c", "start": [197, 1], "end": [199, 21], "kind": "commanddeclaration"}, {"full_name": "le_iff_exists_mul", "code": "@[to_additive]\ntheorem le_iff_exists_mul : a \u2264 b \u2194 \u2203 c, b = a * c", "start": [203, 1], "end": [207, 23], "kind": "commanddeclaration"}, {"full_name": "le_iff_exists_mul'", "code": "@[to_additive]\ntheorem le_iff_exists_mul' : a \u2264 b \u2194 \u2203 c, b = c * a", "start": [211, 1], "end": [213, 46], "kind": "commanddeclaration"}, {"full_name": "one_le", "code": "@[to_additive (attr := simp) zero_le]\ntheorem one_le (a : \u03b1) : 1 \u2264 a", "start": [217, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "bot_eq_one", "code": "@[to_additive]\ntheorem bot_eq_one : (\u22a5 : \u03b1) = 1", "start": [223, 1], "end": [225, 32], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq_one_iff : a * b = 1 \u2194 a = 1 \u2227 b = 1", "start": [231, 1], "end": [233, 40], "kind": "commanddeclaration"}, {"full_name": "le_one_iff_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem le_one_iff_eq_one : a \u2264 1 \u2194 a = 1", "start": [237, 1], "end": [239, 23], "kind": "commanddeclaration"}, {"full_name": "one_lt_iff_ne_one", "code": "@[to_additive]\ntheorem one_lt_iff_ne_one : 1 < a \u2194 a \u2260 1", "start": [243, 1], "end": [245, 37], "kind": "commanddeclaration"}, {"full_name": "eq_one_or_one_lt", "code": "@[to_additive]\ntheorem eq_one_or_one_lt : a = 1 \u2228 1 < a", "start": [249, 1], "end": [251, 39], "kind": "commanddeclaration"}, {"full_name": "one_lt_mul_iff", "code": "@[to_additive (attr := simp) add_pos_iff]\ntheorem one_lt_mul_iff : 1 < a * b \u2194 1 < a \u2228 1 < b", "start": [255, 1], "end": [257, 68], "kind": "commanddeclaration"}, {"full_name": "exists_one_lt_mul_of_lt", "code": "@[to_additive]\ntheorem exists_one_lt_mul_of_lt (h : a < b) : \u2203 (c : _) (_ : 1 < c), a * c = b", "start": [261, 1], "end": [266, 28], "kind": "commanddeclaration"}, {"full_name": "le_mul_left", "code": "@[to_additive]\ntheorem le_mul_left (h : a \u2264 c) : a \u2264 b * c", "start": [270, 1], "end": [274, 42], "kind": "commanddeclaration"}, {"full_name": "le_mul_right", "code": "@[to_additive]\ntheorem le_mul_right (h : a \u2264 b) : a \u2264 b * c", "start": [278, 1], "end": [282, 42], "kind": "commanddeclaration"}, {"full_name": "lt_iff_exists_mul", "code": "@[to_additive]\ntheorem lt_iff_exists_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] : a < b \u2194 \u2203 c > 1, b = a * c", "start": [286, 1], "end": [299, 34], "kind": "commanddeclaration"}, {"full_name": "pos_of_gt", "code": "theorem pos_of_gt {M : Type*} [CanonicallyOrderedAddCommMonoid M] {n m : M} (h : n < m) : 0 < m", "start": [305, 1], "end": [306, 31], "kind": "commanddeclaration"}, {"full_name": "NeZero.pos", "code": "theorem pos {M} (a : M) [CanonicallyOrderedAddCommMonoid M] [NeZero a] : 0 < a", "start": [311, 1], "end": [312, 42], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_gt", "code": "theorem of_gt {M} [CanonicallyOrderedAddCommMonoid M] {x y : M} (h : x < y) : NeZero y", "start": [315, 1], "end": [316, 24], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_gt'", "code": "instance (priority := 10) of_gt' [CanonicallyOrderedAddCommMonoid M] [One M] {y : M}\n  [Fact (1 < y)] : NeZero y := of_gt <| @Fact.out (1 < y) _", "start": [322, 1], "end": [324, 60], "kind": "commanddeclaration"}, {"full_name": "NeZero.bit0", "code": "instance bit0 {M} [CanonicallyOrderedAddCommMonoid M] {x : M} [NeZero x] : NeZero (bit0 x) :=\n  of_pos <| bit0_pos <| NeZero.pos x", "start": [328, 1], "end": [329, 37], "kind": "commanddeclaration"}, {"full_name": "CanonicallyLinearOrderedAddCommMonoid", "code": "class CanonicallyLinearOrderedAddCommMonoid (\u03b1 : Type*)\n  extends CanonicallyOrderedAddCommMonoid \u03b1, LinearOrderedAddCommMonoid \u03b1", "start": [334, 1], "end": [337, 74], "kind": "commanddeclaration"}, {"full_name": "CanonicallyLinearOrderedCommMonoid", "code": "@[to_additive]\nclass CanonicallyLinearOrderedCommMonoid (\u03b1 : Type*)\n  extends CanonicallyOrderedCommMonoid \u03b1, LinearOrderedCommMonoid \u03b1", "start": [340, 1], "end": [344, 68], "kind": "commanddeclaration"}, {"full_name": "CanonicallyLinearOrderedCommMonoid.semilatticeSup", "code": "@[to_additive]\ninstance (priority := 100) CanonicallyLinearOrderedCommMonoid.semilatticeSup : SemilatticeSup \u03b1 :=\n  { LinearOrder.toLattice with }", "start": [354, 1], "end": [356, 33], "kind": "commanddeclaration"}, {"full_name": "min_mul_distrib", "code": "@[to_additive]\ntheorem min_mul_distrib (a b c : \u03b1) : min a (b * c) = min a (min a b * min a c)", "start": [360, 1], "end": [366, 20], "kind": "commanddeclaration"}, {"full_name": "min_mul_distrib'", "code": "@[to_additive]\ntheorem min_mul_distrib' (a b c : \u03b1) : min (a * b) c = min (min a c * min b c) c", "start": [370, 1], "end": [372, 51], "kind": "commanddeclaration"}, {"full_name": "one_min", "code": "@[to_additive]\ntheorem one_min (a : \u03b1) : min 1 a = 1", "start": [377, 1], "end": [379, 25], "kind": "commanddeclaration"}, {"full_name": "min_one", "code": "@[to_additive]\ntheorem min_one (a : \u03b1) : min a 1 = 1", "start": [384, 1], "end": [386, 26], "kind": "commanddeclaration"}, {"full_name": "bot_eq_one'", "code": "@[to_additive (attr := simp)\n  \"In a linearly ordered monoid, we are happy for `bot_eq_zero` to be a `@[simp]` lemma\"]\ntheorem bot_eq_one' : (\u22a5 : \u03b1) = 1", "start": [390, 1], "end": [394, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Nontriviality.lean", "imports": ["Mathlib/Tactic/Nontriviality/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Algebra/Order/Sub/Defs.lean", "imports": ["Mathlib/Order/Lattice.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CovariantAndContravariant.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean"], "premises": [{"full_name": "OrderedSub", "code": "class OrderedSub (\u03b1 : Type*) [LE \u03b1] [Add \u03b1] [Sub \u03b1] : Prop where\n  \n  tsub_le_iff_right : \u2200 a b c : \u03b1, a - b \u2264 c \u2194 a \u2264 c + b", "start": [49, 1], "end": [57, 57], "kind": "commanddeclaration"}, {"full_name": "tsub_le_iff_right", "code": "@[simp]\ntheorem tsub_le_iff_right : a - b \u2264 c \u2194 a \u2264 c + b", "start": [64, 1], "end": [66, 37], "kind": "commanddeclaration"}, {"full_name": "add_tsub_le_right", "code": "theorem add_tsub_le_right : a + b - b \u2264 a", "start": [69, 1], "end": [71, 31], "kind": "commanddeclaration"}, {"full_name": "le_tsub_add", "code": "theorem le_tsub_add : b \u2264 b - a + a", "start": [74, 1], "end": [75, 30], "kind": "commanddeclaration"}, {"full_name": "tsub_le_iff_left", "code": "theorem tsub_le_iff_left : a - b \u2264 c \u2194 a \u2264 b + c", "start": [94, 1], "end": [94, 88], "kind": "commanddeclaration"}, {"full_name": "le_add_tsub", "code": "theorem le_add_tsub : a \u2264 b + (a - b)", "start": [97, 1], "end": [98, 29], "kind": "commanddeclaration"}, {"full_name": "add_tsub_le_left", "code": "theorem add_tsub_le_left : a + b - a \u2264 b", "start": [101, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub_right", "code": "theorem tsub_le_tsub_right (h : a \u2264 b) (c : \u03b1) : a - c \u2264 b - c", "start": [106, 1], "end": [107, 46], "kind": "commanddeclaration"}, {"full_name": "tsub_le_iff_tsub_le", "code": "theorem tsub_le_iff_tsub_le : a - b \u2264 c \u2194 a - c \u2264 b", "start": [110, 1], "end": [110, 99], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_le", "code": "theorem tsub_tsub_le : b - (b - a) \u2264 a", "start": [113, 1], "end": [115, 36], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub_left", "code": "theorem tsub_le_tsub_left (h : a \u2264 b) (c : \u03b1) : c - b \u2264 c - a", "start": [122, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub", "code": "theorem tsub_le_tsub (hab : a \u2264 b) (hcd : c \u2264 d) : a - d \u2264 b - c", "start": [126, 1], "end": [127, 62], "kind": "commanddeclaration"}, {"full_name": "antitone_const_tsub", "code": "theorem antitone_const_tsub : Antitone fun x => c - x", "start": [130, 1], "end": [130, 96], "kind": "commanddeclaration"}, {"full_name": "add_tsub_le_assoc", "code": "theorem add_tsub_le_assoc : a + b - c \u2264 a + (b - c)", "start": [133, 1], "end": [136, 38], "kind": "commanddeclaration"}, {"full_name": "add_tsub_le_tsub_add", "code": "theorem add_tsub_le_tsub_add : a + b - c \u2264 a - c + b", "start": [139, 1], "end": [142, 26], "kind": "commanddeclaration"}, {"full_name": "add_le_add_add_tsub", "code": "theorem add_le_add_add_tsub : a + b \u2264 a + c + (b - c)", "start": [145, 1], "end": [147, 38], "kind": "commanddeclaration"}, {"full_name": "le_tsub_add_add", "code": "theorem le_tsub_add_add : a + b \u2264 a - c + (b + c)", "start": [150, 1], "end": [152, 28], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub_add_tsub", "code": "theorem tsub_le_tsub_add_tsub : a - c \u2264 a - b + (b - c)", "start": [155, 1], "end": [157, 59], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_tsub_le_tsub", "code": "theorem tsub_tsub_tsub_le_tsub : c - a - (c - b) \u2264 b - a", "start": [160, 1], "end": [162, 58], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_le_tsub_add", "code": "theorem tsub_tsub_le_tsub_add {a b c : \u03b1} : a - (b - c) \u2264 a - b + c", "start": [165, 1], "end": [170, 56], "kind": "commanddeclaration"}, {"full_name": "add_tsub_add_le_tsub_add_tsub", "code": "theorem add_tsub_add_le_tsub_add_tsub : a + b - (c + d) \u2264 a - c + (b - d)", "start": [173, 1], "end": [178, 26], "kind": "commanddeclaration"}, {"full_name": "add_tsub_add_le_tsub_left", "code": "theorem add_tsub_add_le_tsub_left : a + b - (a + c) \u2264 b - c", "start": [181, 1], "end": [184, 38], "kind": "commanddeclaration"}, {"full_name": "add_tsub_add_le_tsub_right", "code": "theorem add_tsub_add_le_tsub_right : a + c - (b + c) \u2264 a - b", "start": [187, 1], "end": [190, 39], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_add_tsub_swap", "code": "protected theorem le_add_tsub_swap (hb : AddLECancellable b) : a \u2264 b + a - b", "start": [200, 1], "end": [201, 17], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_add_tsub", "code": "protected theorem le_add_tsub (hb : AddLECancellable b) : a \u2264 a + b - b", "start": [204, 1], "end": [206, 28], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_tsub_of_add_le_left", "code": "protected theorem le_tsub_of_add_le_left (ha : AddLECancellable a) (h : a + b \u2264 c) : b \u2264 c - a", "start": [209, 1], "end": [210, 28], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_tsub_of_add_le_right", "code": "protected theorem le_tsub_of_add_le_right (hb : AddLECancellable b) (h : a + b \u2264 c) : a \u2264 c - b", "start": [213, 1], "end": [214, 49], "kind": "commanddeclaration"}, {"full_name": "le_add_tsub_swap", "code": "theorem le_add_tsub_swap : a \u2264 b + a - b", "start": [226, 1], "end": [227, 50], "kind": "commanddeclaration"}, {"full_name": "le_add_tsub'", "code": "theorem le_add_tsub' : a \u2264 a + b - b", "start": [230, 1], "end": [231, 45], "kind": "commanddeclaration"}, {"full_name": "le_tsub_of_add_le_left", "code": "theorem le_tsub_of_add_le_left (h : a + b \u2264 c) : b \u2264 c - a", "start": [234, 1], "end": [235, 58], "kind": "commanddeclaration"}, {"full_name": "le_tsub_of_add_le_right", "code": "theorem le_tsub_of_add_le_right (h : a + b \u2264 c) : a \u2264 c - b", "start": [238, 1], "end": [239, 59], "kind": "commanddeclaration"}, {"full_name": "tsub_nonpos", "code": "theorem tsub_nonpos : a - b \u2264 0 \u2194 a \u2264 b", "start": [248, 1], "end": [248, 78], "kind": "commanddeclaration"}, {"full_name": "tsub_nonpos_of_le", "code": "alias \u27e8_, tsub_nonpos_of_le\u27e9 := tsub_nonpos", "start": [251, 1], "end": [251, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "tsub_tsub", "code": "theorem tsub_tsub (b a c : \u03b1) : b - a - c = b - (a + c)", "start": [261, 1], "end": [264, 77], "kind": "commanddeclaration"}, {"full_name": "tsub_add_eq_tsub_tsub", "code": "theorem tsub_add_eq_tsub_tsub (a b c : \u03b1) : a - (b + c) = a - b - c", "start": [267, 1], "end": [268, 25], "kind": "commanddeclaration"}, {"full_name": "tsub_add_eq_tsub_tsub_swap", "code": "theorem tsub_add_eq_tsub_tsub_swap (a b c : \u03b1) : a - (b + c) = a - c - b", "start": [271, 1], "end": [273, 30], "kind": "commanddeclaration"}, {"full_name": "tsub_right_comm", "code": "theorem tsub_right_comm : a - b - c = a - c - b", "start": [276, 1], "end": [277, 58], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_eq_of_eq_add", "code": "protected theorem tsub_eq_of_eq_add (hb : AddLECancellable b) (h : a = c + b) : a - b = c", "start": [285, 1], "end": [288, 25], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.eq_tsub_of_add_eq", "code": "protected theorem eq_tsub_of_add_eq (hc : AddLECancellable c) (h : a + c = b) : a = b - c", "start": [291, 1], "end": [292, 37], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_eq_of_eq_add_rev", "code": "protected theorem tsub_eq_of_eq_add_rev (hb : AddLECancellable b) (h : a = b + c) : a - b = c", "start": [295, 1], "end": [296, 46], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.add_tsub_cancel_right", "code": "@[simp]\nprotected theorem add_tsub_cancel_right (hb : AddLECancellable b) : a + b - b = a", "start": [299, 1], "end": [301, 43], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.add_tsub_cancel_left", "code": "@[simp]\nprotected theorem add_tsub_cancel_left (ha : AddLECancellable a) : a + b - a = b", "start": [304, 1], "end": [306, 39], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_add_of_tsub_lt_left", "code": "protected theorem lt_add_of_tsub_lt_left (hb : AddLECancellable b) (h : a - b < c) : a < b + c", "start": [309, 1], "end": [313, 17], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_add_of_tsub_lt_right", "code": "protected theorem lt_add_of_tsub_lt_right (hc : AddLECancellable c) (h : a - c < b) :\n    a < b + c", "start": [316, 1], "end": [321, 17], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_of_add_lt_right", "code": "protected theorem lt_tsub_of_add_lt_right (hc : AddLECancellable c) (h : a + c < b) : a < b - c", "start": [324, 1], "end": [327, 31], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_of_add_lt_left", "code": "protected theorem lt_tsub_of_add_lt_left (ha : AddLECancellable a) (h : a + c < b) : c < b - a", "start": [330, 1], "end": [331, 50], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_of_eq_add", "code": "theorem tsub_eq_of_eq_add (h : a = c + b) : a - b = c", "start": [343, 1], "end": [344, 53], "kind": "commanddeclaration"}, {"full_name": "eq_tsub_of_add_eq", "code": "theorem eq_tsub_of_add_eq (h : a + c = b) : a = b - c", "start": [347, 1], "end": [348, 53], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_of_eq_add_rev", "code": "theorem tsub_eq_of_eq_add_rev (h : a = b + c) : a - b = c", "start": [351, 1], "end": [352, 57], "kind": "commanddeclaration"}, {"full_name": "add_tsub_cancel_right", "code": "@[simp]\ntheorem add_tsub_cancel_right (a b : \u03b1) : a + b - b = a", "start": [355, 1], "end": [357, 55], "kind": "commanddeclaration"}, {"full_name": "add_tsub_cancel_left", "code": "@[simp]\ntheorem add_tsub_cancel_left (a b : \u03b1) : a + b - a = b", "start": [360, 1], "end": [362, 54], "kind": "commanddeclaration"}, {"full_name": "lt_add_of_tsub_lt_left", "code": "theorem lt_add_of_tsub_lt_left (h : a - b < c) : a < b + c", "start": [365, 1], "end": [366, 58], "kind": "commanddeclaration"}, {"full_name": "lt_add_of_tsub_lt_right", "code": "theorem lt_add_of_tsub_lt_right (h : a - c < b) : a < b + c", "start": [369, 1], "end": [370, 59], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_of_add_lt_left", "code": "theorem lt_tsub_of_add_lt_left : a + c < b \u2192 c < b - a", "start": [373, 1], "end": [376, 56], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_of_add_lt_right", "code": "theorem lt_tsub_of_add_lt_right : a + c < b \u2192 a < b - c", "start": [379, 1], "end": [380, 57], "kind": "commanddeclaration"}, {"full_name": "add_tsub_add_eq_tsub_right", "code": "theorem add_tsub_add_eq_tsub_right (a c b : \u03b1) : a + c - (b + c) = a - b", "start": [389, 1], "end": [393, 20], "kind": "commanddeclaration"}, {"full_name": "add_tsub_add_eq_tsub_left", "code": "theorem add_tsub_add_eq_tsub_left (a b c : \u03b1) : a + b - (a + c) = b - c", "start": [396, 1], "end": [397, 62], "kind": "commanddeclaration"}, {"full_name": "lt_of_tsub_lt_tsub_right", "code": "theorem lt_of_tsub_lt_tsub_right (h : a - c < b - c) : a < b", "start": [411, 1], "end": [413, 61], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_iff_right", "code": "theorem lt_tsub_iff_right : a < b - c \u2194 a + c < b", "start": [416, 1], "end": [418, 43], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_iff_left", "code": "theorem lt_tsub_iff_left : a < b - c \u2194 c + a < b", "start": [421, 1], "end": [423, 42], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_comm", "code": "theorem lt_tsub_comm : a < b - c \u2194 c < b - a", "start": [426, 1], "end": [427, 48], "kind": "commanddeclaration"}, {"full_name": "lt_of_tsub_lt_tsub_left", "code": "theorem lt_of_tsub_lt_tsub_left (h : a - b < a - c) : c < b", "start": [434, 1], "end": [436, 60], "kind": "commanddeclaration"}, {"full_name": "tsub_zero", "code": "@[simp]\ntheorem tsub_zero (a : \u03b1) : a - 0 = a", "start": [447, 1], "end": [449, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderedCancelAddCommMonoid", "code": "class OrderedCancelAddCommMonoid (\u03b1 : Type u) extends AddCommMonoid \u03b1, PartialOrder \u03b1 where\n  \n  protected add_le_add_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c + a \u2264 c + b\n  \n  protected le_of_add_le_add_left : \u2200 a b c : \u03b1, a + b \u2264 a + c \u2192 b \u2264 c", "start": [21, 1], "end": [29, 71], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid", "code": "class OrderedCancelCommMonoid (\u03b1 : Type u) extends CommMonoid \u03b1, PartialOrder \u03b1 where\n  \n  protected mul_le_mul_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c * a \u2264 c * b\n  \n  protected le_of_mul_le_mul_left : \u2200 a b c : \u03b1, a * b \u2264 a * c \u2192 b \u2264 c", "start": [32, 1], "end": [39, 71], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.to_contravariantClass_le_left", "code": "@[to_additive]\ninstance (priority := 200) OrderedCancelCommMonoid.to_contravariantClass_le_left :\n    ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8OrderedCancelCommMonoid.le_of_mul_le_mul_left\u27e9", "start": [49, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.lt_of_mul_lt_mul_left", "code": "@[to_additive]\ntheorem OrderedCancelCommMonoid.lt_of_mul_lt_mul_left : \u2200 a b c : \u03b1, a * b < a * c \u2192 b < c", "start": [56, 1], "end": [58, 69], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.to_contravariantClass_left", "code": "@[to_additive]\ninstance OrderedCancelCommMonoid.to_contravariantClass_left (M : Type*)\n    [OrderedCancelCommMonoid M] :\n    ContravariantClass M M (\u00b7 * \u00b7) (\u00b7 < \u00b7) where\n  elim _ _ _ := OrderedCancelCommMonoid.lt_of_mul_lt_mul_left _ _ _", "start": [62, 1], "end": [66, 68], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.to_contravariantClass_right", "code": "@[to_additive]\ninstance OrderedCancelCommMonoid.to_contravariantClass_right (M : Type*)\n    [OrderedCancelCommMonoid M] :\n    ContravariantClass M M (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7) :=\n  contravariant_swap_mul_of_contravariant_mul M _", "start": [74, 1], "end": [78, 50], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.toOrderedCommMonoid", "code": "@[to_additive]\ninstance (priority := 100) OrderedCancelCommMonoid.toOrderedCommMonoid : OrderedCommMonoid \u03b1 :=\n  { \u2039OrderedCancelCommMonoid \u03b1\u203a with }", "start": [83, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "OrderedCancelCommMonoid.toCancelCommMonoid", "code": "@[to_additive OrderedCancelAddCommMonoid.toCancelAddCommMonoid]\ninstance (priority := 100) OrderedCancelCommMonoid.toCancelCommMonoid : CancelCommMonoid \u03b1 :=\n  { \u2039OrderedCancelCommMonoid \u03b1\u203a with\n    mul_left_cancel :=\n      fun a b c h => (le_of_mul_le_mul_left' h.le).antisymm <| le_of_mul_le_mul_left' h.ge }", "start": [90, 1], "end": [94, 93], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCancelAddCommMonoid", "code": "class LinearOrderedCancelAddCommMonoid (\u03b1 : Type u) extends OrderedCancelAddCommMonoid \u03b1,\n    LinearOrderedAddCommMonoid \u03b1", "start": [100, 1], "end": [104, 33], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCancelCommMonoid", "code": "class LinearOrderedCancelCommMonoid (\u03b1 : Type u) extends OrderedCancelCommMonoid \u03b1,\n    LinearOrderedCommMonoid \u03b1", "start": [107, 1], "end": [111, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/Basic.lean", "imports": ["Mathlib/Order/WithBot.lean", "Mathlib/Order/RelIso/Basic.lean", "Mathlib/Order/Disjoint.lean", "Mathlib/Logic/Equiv/Option.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Tactic/Monotonicity/Attr.lean"], "premises": [{"full_name": "OrderHom", "code": "structure OrderHom (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  monotone' : Monotone toFun", "start": [79, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding", "code": "abbrev OrderEmbedding (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] :=\n  @RelEmbedding \u03b1 \u03b2 (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)", "start": [90, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "OrderIso", "code": "abbrev OrderIso (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] :=\n  @RelIso \u03b1 \u03b2 (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)", "start": [99, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass", "code": "abbrev OrderHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [LE \u03b1] [LE \u03b2] :=\n  RelHomClass F ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) ((\u00b7 \u2264 \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)", "start": [110, 1], "end": [112, 66], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass", "code": "class OrderIsoClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [LE \u03b1] [LE \u03b2] extends\n  EquivLike F \u03b1 \u03b2 where\n  \n  map_le_map_iff (f : F) {a b : \u03b1} : f a \u2264 f b \u2194 a \u2264 b", "start": [115, 1], "end": [121, 55], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toOrderIso", "code": "@[coe]\ndef OrderIsoClass.toOrderIso [LE \u03b1] [LE \u03b2] [OrderIsoClass F \u03b1 \u03b2] (f : F) : \u03b1 \u2243o \u03b2 :=\n  { EquivLike.toEquiv f with map_rel_iff' := map_le_map_iff f }", "start": [130, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toOrderHomClass", "code": "instance (priority := 100) OrderIsoClass.toOrderHomClass [LE \u03b1] [LE \u03b2]\n    [OrderIsoClass F \u03b1 \u03b2] : OrderHomClass F \u03b1 \u03b2 :=\n  { EquivLike.toEmbeddingLike with\n    map_rel := fun f _ _ => (map_le_map_iff f).2 }", "start": [142, 1], "end": [145, 51], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.monotone", "code": "protected theorem monotone (f : F) : Monotone f", "start": [152, 1], "end": [152, 72], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.mono", "code": "protected theorem mono (f : F) : Monotone f", "start": [155, 1], "end": [155, 68], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.toOrderHom", "code": "@[coe]\ndef toOrderHom (f : F) : \u03b1 \u2192o \u03b2 where\n  toFun := f\n  monotone' := OrderHomClass.monotone f", "start": [158, 1], "end": [163, 40], "kind": "commanddeclaration"}, {"full_name": "map_inv_le_iff", "code": "@[simp]\ntheorem map_inv_le_iff (f : F) {a : \u03b1} {b : \u03b2} : EquivLike.inv f b \u2264 a \u2194 b \u2264 f a", "start": [179, 1], "end": [182, 39], "kind": "commanddeclaration"}, {"full_name": "le_map_inv_iff", "code": "@[simp]\ntheorem le_map_inv_iff (f : F) {a : \u03b1} {b : \u03b2} : a \u2264 EquivLike.inv f b \u2194 f a \u2264 b", "start": [186, 1], "end": [189, 39], "kind": "commanddeclaration"}, {"full_name": "map_lt_map_iff", "code": "theorem map_lt_map_iff (f : F) {a b : \u03b1} : f a < f b \u2194 a < b", "start": [196, 1], "end": [197, 64], "kind": "commanddeclaration"}, {"full_name": "map_inv_lt_iff", "code": "@[simp]\ntheorem map_inv_lt_iff (f : F) {a : \u03b1} {b : \u03b2} : EquivLike.inv f b < a \u2194 b < f a", "start": [200, 1], "end": [203, 40], "kind": "commanddeclaration"}, {"full_name": "lt_map_inv_iff", "code": "@[simp]\ntheorem lt_map_inv_iff (f : F) {a : \u03b1} {b : \u03b2} : a < EquivLike.inv f b \u2194 f a < b", "start": [206, 1], "end": [209, 40], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_mk", "code": "@[simp] theorem coe_mk (f : \u03b1 \u2192 \u03b2) (hf : Monotone f) : \u21d1(mk f hf) = f", "start": [228, 1], "end": [228, 77], "kind": "commanddeclaration"}, {"full_name": "OrderHom.monotone", "code": "protected theorem monotone (f : \u03b1 \u2192o \u03b2) : Monotone f", "start": [231, 1], "end": [232, 14], "kind": "commanddeclaration"}, {"full_name": "OrderHom.mono", "code": "protected theorem mono (f : \u03b1 \u2192o \u03b2) : Monotone f", "start": [235, 1], "end": [236, 13], "kind": "commanddeclaration"}, {"full_name": "OrderHom.Simps.coe", "code": "def Simps.coe (f : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2 := f", "start": [239, 1], "end": [241, 40], "kind": "commanddeclaration"}, {"full_name": "OrderHom.toFun_eq_coe", "code": "@[simp] theorem toFun_eq_coe (f : \u03b1 \u2192o \u03b2) : f.toFun = f", "start": [247, 1], "end": [247, 63], "kind": "commanddeclaration"}, {"full_name": "OrderHom.ext", "code": "@[ext]\ntheorem ext (f g : \u03b1 \u2192o \u03b2) (h : (f : \u03b1 \u2192 \u03b2) = g) : f = g", "start": [251, 1], "end": [253, 26], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_eq", "code": "@[simp] theorem coe_eq (f : \u03b1 \u2192o \u03b2) : OrderHomClass.toOrderHom f = f", "start": [256, 1], "end": [256, 76], "kind": "commanddeclaration"}, {"full_name": "OrderHomClass.coe_coe", "code": "@[simp] theorem _root_.OrderHomClass.coe_coe {F} [OrderHomClass F \u03b1 \u03b2] (f : F) :\n    \u21d1(f : \u03b1 \u2192o \u03b2) = f", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.canLift", "code": "protected instance canLift : CanLift (\u03b1 \u2192 \u03b2) (\u03b1 \u2192o \u03b2) (\u2191) Monotone where\n  prf f h := \u27e8\u27e8f, h\u27e9, rfl\u27e9", "start": [262, 1], "end": [264, 27], "kind": "commanddeclaration"}, {"full_name": "OrderHom.copy", "code": "protected def copy (f : \u03b1 \u2192o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u03b1 \u2192o \u03b2 :=\n  \u27e8f', h.symm.subst f.monotone'\u27e9", "start": [267, 1], "end": [270, 33], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : \u03b1 \u2192o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : (f.copy f' h) = f'", "start": [273, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.copy_eq", "code": "theorem copy_eq (f : \u03b1 \u2192o \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [278, 1], "end": [279, 17], "kind": "commanddeclaration"}, {"full_name": "OrderHom.id", "code": "@[simps (config := { fullyApplied := false })]\ndef id : \u03b1 \u2192o \u03b1 :=\n  \u27e8_root_.id, monotone_id\u27e9", "start": [282, 1], "end": [285, 27], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_def", "code": "theorem le_def {f g : \u03b1 \u2192o \u03b2} : f \u2264 g \u2194 \u2200 x, f x \u2264 g x", "start": [299, 1], "end": [300, 10], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {f g : \u03b1 \u2192o \u03b2} : (f : \u03b1 \u2192 \u03b2) \u2264 g \u2194 f \u2264 g", "start": [303, 1], "end": [305, 10], "kind": "commanddeclaration"}, {"full_name": "OrderHom.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk {f g : \u03b1 \u2192 \u03b2} {hf hg} : mk f hf \u2264 mk g hg \u2194 f \u2264 g", "start": [308, 1], "end": [310, 10], "kind": "commanddeclaration"}, {"full_name": "OrderHom.apply_mono", "code": "@[mono]\ntheorem apply_mono {f g : \u03b1 \u2192o \u03b2} {x y : \u03b1} (h\u2081 : f \u2264 g) (h\u2082 : x \u2264 y) : f x \u2264 g y", "start": [313, 1], "end": [315, 28], "kind": "commanddeclaration"}, {"full_name": "OrderHom.curry", "code": "def curry : (\u03b1 \u00d7 \u03b2 \u2192o \u03b3) \u2243o (\u03b1 \u2192o \u03b2 \u2192o \u03b3) where\n  toFun f := \u27e8fun x \u21a6 \u27e8Function.curry f x, fun _ _ h \u21a6 f.mono \u27e8le_rfl, h\u27e9\u27e9, fun _ _ h _ =>\n    f.mono \u27e8h, le_rfl\u27e9\u27e9\n  invFun f := \u27e8Function.uncurry fun x \u21a6 f x, fun x y h \u21a6 (f.mono h.1 x.2).trans ((f y.1).mono h.2)\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := by simp [le_def]", "start": [318, 1], "end": [325, 35], "kind": "commanddeclaration"}, {"full_name": "OrderHom.curry_apply", "code": "@[simp]\ntheorem curry_apply (f : \u03b1 \u00d7 \u03b2 \u2192o \u03b3) (x : \u03b1) (y : \u03b2) : curry f x y = f (x, y)", "start": [328, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.curry_symm_apply", "code": "@[simp]\ntheorem curry_symm_apply (f : \u03b1 \u2192o \u03b2 \u2192o \u03b3) (x : \u03b1 \u00d7 \u03b2) : curry.symm f x = f x.1 x.2", "start": [333, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp", "code": "@[simps (config := { fullyApplied := false })]\ndef comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) : \u03b1 \u2192o \u03b3 :=\n  \u27e8g \u2218 f, g.mono.comp f.mono\u27e9", "start": [338, 1], "end": [341, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp_mono", "code": "@[mono]\ntheorem comp_mono \u2983g\u2081 g\u2082 : \u03b2 \u2192o \u03b3\u2984 (hg : g\u2081 \u2264 g\u2082) \u2983f\u2081 f\u2082 : \u03b1 \u2192o \u03b2\u2984 (hf : f\u2081 \u2264 f\u2082) :\n    g\u2081.comp f\u2081 \u2264 g\u2082.comp f\u2082", "start": [345, 1], "end": [347, 71], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp\u2098", "code": "@[simps! (config := { fullyApplied := false })]\ndef comp\u2098 : (\u03b2 \u2192o \u03b3) \u2192o (\u03b1 \u2192o \u03b2) \u2192o \u03b1 \u2192o \u03b3 :=\n  curry \u27e8fun f : (\u03b2 \u2192o \u03b3) \u00d7 (\u03b1 \u2192o \u03b2) => f.1.comp f.2, fun _ _ h => comp_mono h.1 h.2\u27e9", "start": [350, 1], "end": [353, 86], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b1 \u2192o \u03b2) : comp f id = f", "start": [357, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b1 \u2192o \u03b2) : comp id f = f", "start": [363, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.const", "code": "@[simps (config := { fullyApplied := false })]\ndef const (\u03b1 : Type*) [Preorder \u03b1] {\u03b2 : Type*} [Preorder \u03b2] : \u03b2 \u2192o \u03b1 \u2192o \u03b2 where\n  toFun b := \u27e8Function.const \u03b1 b, fun _ _ _ => le_rfl\u27e9\n  monotone' _ _ h _ := h", "start": [369, 1], "end": [373, 25], "kind": "commanddeclaration"}, {"full_name": "OrderHom.const_comp", "code": "@[simp]\ntheorem const_comp (f : \u03b1 \u2192o \u03b2) (c : \u03b3) : (const \u03b2 c).comp f = const \u03b1 c", "start": [377, 1], "end": [379, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp_const", "code": "@[simp]\ntheorem comp_const (\u03b3 : Type*) [Preorder \u03b3] (f : \u03b1 \u2192o \u03b2) (c : \u03b1) :\n    f.comp (const \u03b3 c) = const \u03b3 (f c)", "start": [382, 1], "end": [385, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prod", "code": "@[simps]\nprotected def prod (f : \u03b1 \u2192o \u03b2) (g : \u03b1 \u2192o \u03b3) : \u03b1 \u2192o \u03b2 \u00d7 \u03b3 :=\n  \u27e8fun x => (f x, g x), fun _ _ h => \u27e8f.mono h, g.mono h\u27e9\u27e9", "start": [388, 1], "end": [392, 59], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prod_mono", "code": "@[mono]\ntheorem prod_mono {f\u2081 f\u2082 : \u03b1 \u2192o \u03b2} (hf : f\u2081 \u2264 f\u2082) {g\u2081 g\u2082 : \u03b1 \u2192o \u03b3} (hg : g\u2081 \u2264 g\u2082) :\n    f\u2081.prod g\u2081 \u2264 f\u2082.prod g\u2082", "start": [396, 1], "end": [398, 67], "kind": "commanddeclaration"}, {"full_name": "OrderHom.comp_prod_comp_same", "code": "theorem comp_prod_comp_same (f\u2081 f\u2082 : \u03b2 \u2192o \u03b3) (g : \u03b1 \u2192o \u03b2) :\n    (f\u2081.comp g).prod (f\u2082.comp g) = (f\u2081.prod f\u2082).comp g", "start": [401, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prod\u2098", "code": "@[simps!]\ndef prod\u2098 : (\u03b1 \u2192o \u03b2) \u2192o (\u03b1 \u2192o \u03b3) \u2192o \u03b1 \u2192o \u03b2 \u00d7 \u03b3 :=\n  curry \u27e8fun f : (\u03b1 \u2192o \u03b2) \u00d7 (\u03b1 \u2192o \u03b3) => f.1.prod f.2, fun _ _ h => prod_mono h.1 h.2\u27e9", "start": [406, 1], "end": [410, 86], "kind": "commanddeclaration"}, {"full_name": "OrderHom.diag", "code": "@[simps!]\ndef diag : \u03b1 \u2192o \u03b1 \u00d7 \u03b1 :=\n  id.prod id", "start": [414, 1], "end": [417, 13], "kind": "commanddeclaration"}, {"full_name": "OrderHom.onDiag", "code": "@[simps! (config := { simpRhs := true })]\ndef onDiag (f : \u03b1 \u2192o \u03b1 \u2192o \u03b2) : \u03b1 \u2192o \u03b2 :=\n  (curry.symm f).comp diag", "start": [421, 1], "end": [424, 27], "kind": "commanddeclaration"}, {"full_name": "OrderHom.fst", "code": "@[simps]\ndef fst : \u03b1 \u00d7 \u03b2 \u2192o \u03b1 :=\n  \u27e8Prod.fst, fun _ _ h => h.1\u27e9", "start": [428, 1], "end": [431, 31], "kind": "commanddeclaration"}, {"full_name": "OrderHom.snd", "code": "@[simps]\ndef snd : \u03b1 \u00d7 \u03b2 \u2192o \u03b2 :=\n  \u27e8Prod.snd, fun _ _ h => h.2\u27e9", "start": [435, 1], "end": [438, 31], "kind": "commanddeclaration"}, {"full_name": "OrderHom.fst_prod_snd", "code": "@[simp]\ntheorem fst_prod_snd : (fst : \u03b1 \u00d7 \u03b2 \u2192o \u03b1).prod snd = id", "start": [442, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.fst_comp_prod", "code": "@[simp]\ntheorem fst_comp_prod (f : \u03b1 \u2192o \u03b2) (g : \u03b1 \u2192o \u03b3) : fst.comp (f.prod g) = f", "start": [448, 1], "end": [450, 14], "kind": "commanddeclaration"}, {"full_name": "OrderHom.snd_comp_prod", "code": "@[simp]\ntheorem snd_comp_prod (f : \u03b1 \u2192o \u03b2) (g : \u03b1 \u2192o \u03b3) : snd.comp (f.prod g) = g", "start": [453, 1], "end": [455, 14], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prodIso", "code": "@[simps]\ndef prodIso : (\u03b1 \u2192o \u03b2 \u00d7 \u03b3) \u2243o (\u03b1 \u2192o \u03b2) \u00d7 (\u03b1 \u2192o \u03b3) where\n  toFun f := (fst.comp f, snd.comp f)\n  invFun f := f.1.prod f.2\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_and.symm", "start": [458, 1], "end": [466, 34], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prodMap", "code": "@[simps]\ndef prodMap (f : \u03b1 \u2192o \u03b2) (g : \u03b3 \u2192o \u03b4) : \u03b1 \u00d7 \u03b3 \u2192o \u03b2 \u00d7 \u03b4 :=\n  \u27e8Prod.map f g, fun _ _ h => \u27e8f.mono h.1, g.mono h.2\u27e9\u27e9", "start": [471, 1], "end": [474, 56], "kind": "commanddeclaration"}, {"full_name": "Pi.evalOrderHom", "code": "@[simps (config := { fullyApplied := false })]\ndef _root_.Pi.evalOrderHom (i : \u03b9) : (\u2200 j, \u03c0 j) \u2192o \u03c0 i :=\n  \u27e8Function.eval i, Function.monotone_eval i\u27e9", "start": [480, 1], "end": [483, 46], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coeFnHom", "code": "@[simps (config := { fullyApplied := false })]\ndef coeFnHom : (\u03b1 \u2192o \u03b2) \u2192o \u03b1 \u2192 \u03b2 where\n  toFun f := f\n  monotone' _ _ h := h", "start": [487, 1], "end": [492, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.apply", "code": "@[simps! (config := { fullyApplied := false })]\ndef apply (x : \u03b1) : (\u03b1 \u2192o \u03b2) \u2192o \u03b2 :=\n  (Pi.evalOrderHom x).comp coeFnHom", "start": [496, 1], "end": [500, 36], "kind": "commanddeclaration"}, {"full_name": "OrderHom.pi", "code": "@[simps]\ndef pi (f : \u2200 i, \u03b1 \u2192o \u03c0 i) : \u03b1 \u2192o \u2200 i, \u03c0 i :=\n  \u27e8fun x i => f i x, fun _ _ h i => (f i).mono h\u27e9", "start": [504, 1], "end": [508, 50], "kind": "commanddeclaration"}, {"full_name": "OrderHom.piIso", "code": "@[simps]\ndef piIso : (\u03b1 \u2192o \u2200 i, \u03c0 i) \u2243o \u2200 i, \u03b1 \u2192o \u03c0 i where\n  toFun f i := (Pi.evalOrderHom i).comp f\n  invFun := pi\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := forall_swap", "start": [512, 1], "end": [520, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHom.Subtype.val", "code": "@[simps (config := { fullyApplied := false })]\ndef Subtype.val (p : \u03b1 \u2192 Prop) : Subtype p \u2192o \u03b1 :=\n  \u27e8_root_.Subtype.val, fun _ _ h => h\u27e9", "start": [525, 1], "end": [528, 39], "kind": "commanddeclaration"}, {"full_name": "Subtype.orderEmbedding", "code": "@[simps!]\ndef _root_.Subtype.orderEmbedding {p q : \u03b1 \u2192 Prop} (h : \u2200 a, p a \u2192 q a) :\n    {x // p x} \u21aao {x // q x} :=\n  { Subtype.impEmbedding _ _ h with\n    map_rel_iff' := by aesop }", "start": [532, 1], "end": [537, 31], "kind": "commanddeclaration"}, {"full_name": "OrderHom.unique", "code": "instance unique [Subsingleton \u03b1] : Unique (\u03b1 \u2192o \u03b1) where\n  default := OrderHom.id\n  uniq _ := ext _ _ (Subsingleton.elim _ _)", "start": [539, 1], "end": [542, 44], "kind": "commanddeclaration"}, {"full_name": "OrderHom.orderHom_eq_id", "code": "theorem orderHom_eq_id [Subsingleton \u03b1] (g : \u03b1 \u2192o \u03b1) : g = OrderHom.id", "start": [545, 1], "end": [546, 24], "kind": "commanddeclaration"}, {"full_name": "OrderHom.dual", "code": "@[simps]\nprotected def dual : (\u03b1 \u2192o \u03b2) \u2243 (\u03b1\u1d52\u1d48 \u2192o \u03b2\u1d52\u1d48) where\n  toFun f := \u27e8(OrderDual.toDual : \u03b2 \u2192 \u03b2\u1d52\u1d48) \u2218 (f : \u03b1 \u2192 \u03b2) \u2218\n    (OrderDual.ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b1), f.mono.dual\u27e9\n  invFun f := \u27e8OrderDual.ofDual \u2218 f \u2218 OrderDual.toDual, f.mono.dual\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [549, 1], "end": [556, 21], "kind": "commanddeclaration"}, {"full_name": "OrderHom.dual_id", "code": "@[simp]\ntheorem dual_id : OrderHom.dual (OrderHom.id : \u03b1 \u2192o \u03b1) = OrderHom.id", "start": [564, 1], "end": [566, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) :\n    OrderHom.dual (g.comp f) = (OrderHom.dual g).comp (OrderHom.dual f)", "start": [569, 1], "end": [572, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : OrderHom.dual.symm OrderHom.id = (OrderHom.id : \u03b1 \u2192o \u03b1)", "start": [575, 1], "end": [577, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : \u03b2\u1d52\u1d48 \u2192o \u03b3\u1d52\u1d48) (f : \u03b1\u1d52\u1d48 \u2192o \u03b2\u1d52\u1d48) :\n    OrderHom.dual.symm (g.comp f) = (OrderHom.dual.symm g).comp (OrderHom.dual.symm f)", "start": [580, 1], "end": [583, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.dualIso", "code": "def dualIso (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] : (\u03b1 \u2192o \u03b2) \u2243o (\u03b1\u1d52\u1d48 \u2192o \u03b2\u1d52\u1d48)\u1d52\u1d48 where\n  toEquiv := OrderHom.dual.trans OrderDual.toDual\n  map_rel_iff' := Iff.rfl", "start": [586, 1], "end": [589, 26], "kind": "commanddeclaration"}, {"full_name": "OrderHom.withBotMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def withBotMap (f : \u03b1 \u2192o \u03b2) : WithBot \u03b1 \u2192o WithBot \u03b2 :=\n  \u27e8WithBot.map f, f.mono.withBot_map\u27e9", "start": [592, 1], "end": [595, 38], "kind": "commanddeclaration"}, {"full_name": "OrderHom.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def withTopMap (f : \u03b1 \u2192o \u03b2) : WithTop \u03b1 \u2192o WithTop \u03b2 :=\n  \u27e8WithTop.map f, f.mono.withTop_map\u27e9", "start": [599, 1], "end": [602, 38], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.orderEmbeddingOfLTEmbedding", "code": "def RelEmbedding.orderEmbeddingOfLTEmbedding [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u21aar ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) : \u03b1 \u21aao \u03b2 :=\n  { f with\n    map_rel_iff' := by\n      intros\n      simp [le_iff_lt_or_eq, f.map_rel_iff, f.injective.eq_iff] }", "start": [608, 1], "end": [614, 66], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.orderEmbeddingOfLTEmbedding_apply", "code": "@[simp]\ntheorem RelEmbedding.orderEmbeddingOfLTEmbedding_apply [PartialOrder \u03b1] [PartialOrder \u03b2]\n    {f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u21aar ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)} {x : \u03b1} :\n    RelEmbedding.orderEmbeddingOfLTEmbedding f x = f x", "start": [617, 1], "end": [621, 6], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.ltEmbedding", "code": "def ltEmbedding : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u21aar ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) :=\n  { f with map_rel_iff' := by intros; simp [lt_iff_le_not_le, f.map_rel_iff] }", "start": [628, 1], "end": [630, 79], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.ltEmbedding_apply", "code": "@[simp]\ntheorem ltEmbedding_apply (x : \u03b1) : f.ltEmbedding x = f x", "start": [633, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.le_iff_le", "code": "@[simp]\ntheorem le_iff_le {a b} : f a \u2264 f b \u2194 a \u2264 b", "start": [638, 1], "end": [640, 16], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.lt_iff_lt", "code": "@[simp]\ntheorem lt_iff_lt {a b} : f a < f b \u2194 a < b", "start": [643, 1], "end": [645, 28], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.eq_iff_eq", "code": "@[simp]\ntheorem eq_iff_eq {a b} : f a = f b \u2194 a = b", "start": [648, 1], "end": [650, 21], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.monotone", "code": "protected theorem monotone : Monotone f", "start": [653, 1], "end": [654, 27], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.strictMono", "code": "protected theorem strictMono : StrictMono f", "start": [657, 1], "end": [657, 72], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.acc", "code": "protected theorem acc (a : \u03b1) : Acc (\u00b7 < \u00b7) (f a) \u2192 Acc (\u00b7 < \u00b7) a", "start": [660, 1], "end": [661, 22], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.wellFounded", "code": "protected theorem wellFounded :\n    WellFounded ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) \u2192 WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [664, 1], "end": [666, 28], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.isWellOrder", "code": "protected theorem isWellOrder [IsWellOrder \u03b2 (\u00b7 < \u00b7)] : IsWellOrder \u03b1 (\u00b7 < \u00b7)", "start": [669, 1], "end": [670, 28], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.dual", "code": "protected def dual : \u03b1\u1d52\u1d48 \u21aao \u03b2\u1d52\u1d48 :=\n  \u27e8f.toEmbedding, f.map_rel_iff\u27e9", "start": [673, 1], "end": [675, 33], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.wellFoundedLT", "code": "protected theorem wellFoundedLT [WellFoundedLT \u03b2] : WellFoundedLT \u03b1 where", "start": [678, 1], "end": [680, 39], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.wellFoundedGT", "code": "protected theorem wellFoundedGT [WellFoundedGT \u03b2] : WellFoundedGT \u03b1", "start": [682, 1], "end": [685, 51], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.withBotMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def withBotMap (f : \u03b1 \u21aao \u03b2) : WithBot \u03b1 \u21aao WithBot \u03b2 :=\n  { f.toEmbedding.optionMap with\n    toFun := WithBot.map f,\n    map_rel_iff' := @fun a b => WithBot.map_le_iff f f.map_rel_iff a b }", "start": [687, 1], "end": [692, 73], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def withTopMap (f : \u03b1 \u21aao \u03b2) : WithTop \u03b1 \u21aao WithTop \u03b2 :=\n  { f.dual.withBotMap.dual with toFun := WithTop.map f }", "start": [696, 1], "end": [699, 57], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.ofMapLEIff", "code": "def ofMapLEIff {\u03b1 \u03b2} [PartialOrder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a b, f a \u2264 f b \u2194 a \u2264 b) :\n    \u03b1 \u21aao \u03b2 :=\n  RelEmbedding.ofMapRelIff f hf", "start": [703, 1], "end": [708, 32], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.coe_ofMapLEIff", "code": "@[simp]\ntheorem coe_ofMapLEIff {\u03b1 \u03b2} [PartialOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (h) :\n    \u21d1ofMapLEIff f h = f", "start": [711, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.ofStrictMono", "code": "def ofStrictMono {\u03b1 \u03b2} [LinearOrder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) (h : StrictMono f) : \u03b1 \u21aao \u03b2 :=\n  ofMapLEIff f fun _ _ => h.le_iff_le", "start": [717, 1], "end": [719, 38], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.coe_ofStrictMono", "code": "@[simp]\ntheorem coe_ofStrictMono {\u03b1 \u03b2} [LinearOrder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (h : StrictMono f) :\n    \u21d1ofStrictMono f h = f", "start": [722, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.subtype", "code": "@[simps! (config := { fullyApplied := false })]\ndef subtype (p : \u03b1 \u2192 Prop) : Subtype p \u21aao \u03b1 :=\n  \u27e8Function.Embedding.subtype p, Iff.rfl\u27e9", "start": [728, 1], "end": [731, 42], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.toOrderHom", "code": "@[simps (config := { fullyApplied := false })]\ndef toOrderHom {X Y : Type*} [Preorder X] [Preorder Y] (f : X \u21aao Y) : X \u2192o Y where\n  toFun := f\n  monotone' := f.monotone", "start": [735, 1], "end": [739, 26], "kind": "commanddeclaration"}, {"full_name": "RelHom.toOrderHom", "code": "@[simps (config := { fullyApplied := false })]\ndef toOrderHom : \u03b1 \u2192o \u03b2 where\n  toFun := f\n  monotone' := StrictMono.monotone fun _ _ => f.map_rel", "start": [753, 1], "end": [758, 56], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.toOrderHom_injective", "code": "theorem RelEmbedding.toOrderHom_injective\n    (f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u21aar ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) :\n    Function.Injective (f : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2192r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)).toOrderHom", "start": [764, 1], "end": [767, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe {f : \u03b1 \u2243o \u03b2} : f.toFun = f", "start": [789, 1], "end": [791, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2243o \u03b2} (h : (f : \u03b1 \u2192 \u03b2) = g) : f = g", "start": [795, 1], "end": [797, 26], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toOrderEmbedding", "code": "def toOrderEmbedding (e : \u03b1 \u2243o \u03b2) : \u03b1 \u21aao \u03b2 :=\n  e.toRelEmbedding", "start": [800, 1], "end": [802, 19], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_toOrderEmbedding", "code": "@[simp]\ntheorem coe_toOrderEmbedding (e : \u03b1 \u2243o \u03b2) : \u21d1e.toOrderEmbedding = e", "start": [805, 1], "end": [807, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.bijective", "code": "protected theorem bijective (e : \u03b1 \u2243o \u03b2) : Function.Bijective e", "start": [810, 1], "end": [811, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.injective", "code": "protected theorem injective (e : \u03b1 \u2243o \u03b2) : Function.Injective e", "start": [814, 1], "end": [815, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.surjective", "code": "protected theorem surjective (e : \u03b1 \u2243o \u03b2) : Function.Surjective e", "start": [818, 1], "end": [819, 23], "kind": "commanddeclaration"}, {"full_name": "OrderIso.apply_eq_iff_eq", "code": "theorem apply_eq_iff_eq (e : \u03b1 \u2243o \u03b2) {x y : \u03b1} : e x = e y \u2194 x = y", "start": [824, 1], "end": [825, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.refl", "code": "def refl (\u03b1 : Type*) [LE \u03b1] : \u03b1 \u2243o \u03b1 :=\n  RelIso.refl (\u00b7 \u2264 \u00b7)", "start": [828, 1], "end": [830, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1refl \u03b1 = id", "start": [833, 1], "end": [835, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : \u03b1) : refl \u03b1 x = x", "start": [838, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.refl_toEquiv", "code": "@[simp]\ntheorem refl_toEquiv : (refl \u03b1).toEquiv = Equiv.refl \u03b1", "start": [843, 1], "end": [845, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm", "code": "def symm (e : \u03b1 \u2243o \u03b2) : \u03b2 \u2243o \u03b1 := RelIso.symm e", "start": [848, 1], "end": [849, 48], "kind": "commanddeclaration"}, {"full_name": "OrderIso.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : \u03b1 \u2243o \u03b2) (x : \u03b2) : e (e.symm x) = x", "start": [852, 1], "end": [854, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : \u03b1 \u2243o \u03b2) (x : \u03b1) : e.symm (e x) = x", "start": [857, 1], "end": [859, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_refl", "code": "@[simp]\ntheorem symm_refl (\u03b1 : Type*) [LE \u03b1] : (refl \u03b1).symm = refl \u03b1", "start": [862, 1], "end": [864, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.apply_eq_iff_eq_symm_apply", "code": "theorem apply_eq_iff_eq_symm_apply (e : \u03b1 \u2243o \u03b2) (x : \u03b1) (y : \u03b2) : e x = y \u2194 x = e.symm y", "start": [867, 1], "end": [868, 39], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_apply_eq", "code": "theorem symm_apply_eq (e : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2} : e.symm y = x \u2194 y = e x", "start": [871, 1], "end": [872, 26], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : \u03b1 \u2243o \u03b2) : e.symm.symm = e", "start": [875, 1], "end": [878, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_injective", "code": "theorem symm_injective : Function.Injective (symm : \u03b1 \u2243o \u03b2 \u2192 \u03b2 \u2243o \u03b1)", "start": [881, 1], "end": [882, 38], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toEquiv_symm", "code": "@[simp]\ntheorem toEquiv_symm (e : \u03b1 \u2243o \u03b2) : e.toEquiv.symm = e.symm.toEquiv", "start": [885, 1], "end": [887, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.trans", "code": "@[trans]\ndef trans (e : \u03b1 \u2243o \u03b2) (e' : \u03b2 \u2243o \u03b3) : \u03b1 \u2243o \u03b3 :=\n  RelIso.trans e e'", "start": [890, 1], "end": [893, 20], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_trans", "code": "@[simp]\ntheorem coe_trans (e : \u03b1 \u2243o \u03b2) (e' : \u03b2 \u2243o \u03b3) : \u21d1e.trans e' = e' \u2218 e", "start": [896, 1], "end": [898, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.trans_apply", "code": "@[simp]\ntheorem trans_apply (e : \u03b1 \u2243o \u03b2) (e' : \u03b2 \u2243o \u03b3) (x : \u03b1) : e.trans e' x = e' (e x)", "start": [901, 1], "end": [903, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.refl_trans", "code": "@[simp]\ntheorem refl_trans (e : \u03b1 \u2243o \u03b2) : (refl \u03b1).trans e = e", "start": [906, 1], "end": [909, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.trans_refl", "code": "@[simp]\ntheorem trans_refl (e : \u03b1 \u2243o \u03b2) : e.trans (refl \u03b2) = e", "start": [912, 1], "end": [915, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (e\u2081 : \u03b1 \u2243o \u03b2) (e\u2082 : \u03b2 \u2243o \u03b3) (c : \u03b3) :\n    (e\u2081.trans e\u2082).symm c = e\u2081.symm (e\u2082.symm c)", "start": [918, 1], "end": [921, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_trans", "code": "theorem symm_trans (e\u2081 : \u03b1 \u2243o \u03b2) (e\u2082 : \u03b2 \u2243o \u03b3) : (e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm", "start": [924, 1], "end": [925, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.prodComm", "code": "def prodComm : \u03b1 \u00d7 \u03b2 \u2243o \u03b2 \u00d7 \u03b1 where\n  toEquiv := Equiv.prodComm \u03b1 \u03b2\n  map_rel_iff' := Prod.swap_le_swap", "start": [928, 1], "end": [931, 36], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm : \u21d1(prodComm : \u03b1 \u00d7 \u03b2 \u2243o \u03b2 \u00d7 \u03b1) = Prod.swap", "start": [934, 1], "end": [936, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.prodComm_symm", "code": "@[simp]\ntheorem prodComm_symm : (prodComm : \u03b1 \u00d7 \u03b2 \u2243o \u03b2 \u00d7 \u03b1).symm = prodComm", "start": [939, 1], "end": [941, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualDual", "code": "def dualDual : \u03b1 \u2243o \u03b1\u1d52\u1d48\u1d52\u1d48 :=\n  refl \u03b1", "start": [946, 1], "end": [948, 9], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_dualDual", "code": "@[simp]\ntheorem coe_dualDual : \u21d1dualDual \u03b1 = toDual \u2218 toDual", "start": [951, 1], "end": [953, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.coe_dualDual_symm", "code": "@[simp]\ntheorem coe_dualDual_symm : \u21d1(dualDual \u03b1).symm = ofDual \u2218 ofDual", "start": [956, 1], "end": [958, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualDual_apply", "code": "@[simp]\ntheorem dualDual_apply (a : \u03b1) : dualDual \u03b1 a = toDual (toDual a)", "start": [963, 1], "end": [965, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dualDual_symm_apply", "code": "@[simp]\ntheorem dualDual_symm_apply (a : \u03b1\u1d52\u1d48\u1d52\u1d48) : (dualDual \u03b1).symm a = ofDual (ofDual a)", "start": [968, 1], "end": [970, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.le_iff_le", "code": "theorem le_iff_le (e : \u03b1 \u2243o \u03b2) {x y : \u03b1} : e x \u2264 e y \u2194 x \u2264 y", "start": [982, 1], "end": [983, 16], "kind": "commanddeclaration"}, {"full_name": "OrderIso.le_symm_apply", "code": "theorem le_symm_apply (e : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2} : x \u2264 e.symm y \u2194 e x \u2264 y", "start": [986, 1], "end": [987, 19], "kind": "commanddeclaration"}, {"full_name": "OrderIso.symm_apply_le", "code": "theorem symm_apply_le (e : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2} : e.symm y \u2264 x \u2194 y \u2264 e x", "start": [990, 1], "end": [991, 19], "kind": "commanddeclaration"}, {"full_name": "OrderIso.monotone", "code": "protected theorem monotone (e : \u03b1 \u2243o \u03b2) : Monotone e", "start": [998, 1], "end": [999, 30], "kind": "commanddeclaration"}, {"full_name": "OrderIso.strictMono", "code": "protected theorem strictMono (e : \u03b1 \u2243o \u03b2) : StrictMono e", "start": [1002, 1], "end": [1003, 32], "kind": "commanddeclaration"}, {"full_name": "OrderIso.lt_iff_lt", "code": "@[simp]\ntheorem lt_iff_lt (e : \u03b1 \u2243o \u03b2) {x y : \u03b1} : e x < e y \u2194 x < y", "start": [1006, 1], "end": [1008, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toRelIsoLT", "code": "def toRelIsoLT (e : \u03b1 \u2243o \u03b2) : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop) :=\n  \u27e8e.toEquiv, lt_iff_lt e\u27e9", "start": [1011, 1], "end": [1013, 27], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toRelIsoLT_apply", "code": "@[simp]\ntheorem toRelIsoLT_apply (e : \u03b1 \u2243o \u03b2) (x : \u03b1) : e.toRelIsoLT x = e x", "start": [1016, 1], "end": [1018, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toRelIsoLT_symm", "code": "@[simp]\ntheorem toRelIsoLT_symm (e : \u03b1 \u2243o \u03b2) : e.toRelIsoLT.symm = e.symm.toRelIsoLT", "start": [1021, 1], "end": [1023, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofRelIsoLT", "code": "def ofRelIsoLT {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (e : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) : \u03b1 \u2243o \u03b2 :=\n  \u27e8e.toEquiv, by simp [le_iff_eq_or_lt, e.map_rel_iff, e.injective.eq_iff]\u27e9", "start": [1026, 1], "end": [1029, 76], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofRelIsoLT_apply", "code": "@[simp]\ntheorem ofRelIsoLT_apply {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (e : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) (x : \u03b1) : ofRelIsoLT e x = e x", "start": [1032, 1], "end": [1035, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofRelIsoLT_symm", "code": "@[simp]\ntheorem ofRelIsoLT_symm {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (e : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) :\n    (ofRelIsoLT e).symm = ofRelIsoLT e.symm", "start": [1038, 1], "end": [1042, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofRelIsoLT_toRelIsoLT", "code": "@[simp]\ntheorem ofRelIsoLT_toRelIsoLT {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2] (e : \u03b1 \u2243o \u03b2) :\n    ofRelIsoLT (toRelIsoLT e) = e", "start": [1045, 1], "end": [1049, 7], "kind": "commanddeclaration"}, {"full_name": "OrderIso.toRelIsoLT_ofRelIsoLT", "code": "@[simp]\ntheorem toRelIsoLT_ofRelIsoLT {\u03b1 \u03b2} [PartialOrder \u03b1] [PartialOrder \u03b2]\n    (e : ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2243r ((\u00b7 < \u00b7) : \u03b2 \u2192 \u03b2 \u2192 Prop)) : toRelIsoLT (ofRelIsoLT e) = e", "start": [1052, 1], "end": [1056, 7], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofCmpEqCmp", "code": "def ofCmpEqCmp {\u03b1 \u03b2} [LinearOrder \u03b1] [LinearOrder \u03b2] (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1)\n    (h : \u2200 (a : \u03b1) (b : \u03b2), cmp a (g b) = cmp (f a) b) : \u03b1 \u2243o \u03b2 :=\n  have gf : \u2200 a : \u03b1, a = g (f a) := by\n    intro\n    rw [\u2190 cmp_eq_eq_iff, h, cmp_self_eq_eq]\n  { toFun := f, invFun := g, left_inv := fun a => (gf a).symm,\n    right_inv := by\n      intro\n      rw [\u2190 cmp_eq_eq_iff, \u2190 h, cmp_self_eq_eq],\n    map_rel_iff' := by\n      intros a b\n      apply le_iff_le_of_cmp_eq_cmp\n      convert (h a (f b)).symm\n      apply gf }", "start": [1059, 1], "end": [1074, 17], "kind": "commanddeclaration"}, {"full_name": "OrderIso.ofHomInv", "code": "def ofHomInv {F G : Type*} [OrderHomClass F \u03b1 \u03b2] [OrderHomClass G \u03b2 \u03b1] (f : F) (g : G)\n    (h\u2081 : (f : \u03b1 \u2192o \u03b2).comp (g : \u03b2 \u2192o \u03b1) = OrderHom.id)\n    (h\u2082 : (g : \u03b2 \u2192o \u03b1).comp (f : \u03b1 \u2192o \u03b2) = OrderHom.id) :\n    \u03b1 \u2243o \u03b2 where\n  toFun := f\n  invFun := g\n  left_inv := FunLike.congr_fun h\u2082\n  right_inv := FunLike.congr_fun h\u2081\n  map_rel_iff' := @fun a b =>\n    \u27e8fun h => by\n      replace h := map_rel g h\n      rwa [Equiv.coe_fn_mk, show g (f a) = (g : \u03b2 \u2192o \u03b1).comp (f : \u03b1 \u2192o \u03b2) a from rfl,\n        show g (f b) = (g : \u03b2 \u2192o \u03b1).comp (f : \u03b1 \u2192o \u03b2) b from rfl, h\u2082] at h,\n      fun h => (f : \u03b1 \u2192o \u03b2).monotone h\u27e9", "start": [1077, 1], "end": [1092, 40], "kind": "commanddeclaration"}, {"full_name": "OrderIso.funUnique", "code": "@[simps! toEquiv apply]\ndef funUnique (\u03b1 \u03b2 : Type*) [Unique \u03b1] [Preorder \u03b2] : (\u03b1 \u2192 \u03b2) \u2243o \u03b2 where\n  toEquiv := Equiv.funUnique \u03b1 \u03b2\n  map_rel_iff' := by simp [Pi.le_def, Unique.forall_iff]", "start": [1095, 1], "end": [1099, 57], "kind": "commanddeclaration"}, {"full_name": "OrderIso.funUnique_symm_apply", "code": "@[simp]\ntheorem funUnique_symm_apply {\u03b1 \u03b2 : Type*} [Unique \u03b1] [Preorder \u03b2] :\n    ((funUnique \u03b1 \u03b2).symm : \u03b2 \u2192 \u03b1 \u2192 \u03b2) = Function.const \u03b1", "start": [1104, 1], "end": [1107, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toOrderIso", "code": "def toOrderIso (e : \u03b1 \u2243 \u03b2) (h\u2081 : Monotone e) (h\u2082 : Monotone e.symm) : \u03b1 \u2243o \u03b2 :=\n  \u27e8e, \u27e8fun h => by simpa only [e.symm_apply_apply] using h\u2082 h, fun h => h\u2081 h\u27e9\u27e9", "start": [1116, 1], "end": [1119, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_toOrderIso", "code": "@[simp]\ntheorem coe_toOrderIso (e : \u03b1 \u2243 \u03b2) (h\u2081 : Monotone e) (h\u2082 : Monotone e.symm) :\n    \u21d1e.toOrderIso h\u2081 h\u2082 = e", "start": [1122, 1], "end": [1125, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.toOrderIso_toEquiv", "code": "@[simp]\ntheorem toOrderIso_toEquiv (e : \u03b1 \u2243 \u03b2) (h\u2081 : Monotone e) (h\u2082 : Monotone e.symm) :\n    (e.toOrderIso h\u2081 h\u2082).toEquiv = e", "start": [1128, 1], "end": [1131, 6], "kind": "commanddeclaration"}, {"full_name": "StrictMono.orderIsoOfRightInverse", "code": "@[simps (config := { fullyApplied := False })]\ndef orderIsoOfRightInverse (g : \u03b2 \u2192 \u03b1) (hg : Function.RightInverse g f) : \u03b1 \u2243o \u03b2 :=\n  { OrderEmbedding.ofStrictMono f h_mono with\n    toFun := f,\n    invFun := g,\n    left_inv := fun _ => h_mono.injective <| hg _,\n    right_inv := hg }", "start": [1142, 1], "end": [1149, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.dual", "code": "protected def OrderIso.dual [LE \u03b1] [LE \u03b2] (f : \u03b1 \u2243o \u03b2) : \u03b1\u1d52\u1d48 \u2243o \u03b2\u1d52\u1d48 :=\n  \u27e8f.toEquiv, f.map_rel_iff\u27e9", "start": [1156, 1], "end": [1158, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_bot'", "code": "theorem OrderIso.map_bot' [LE \u03b1] [PartialOrder \u03b2] (f : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2} (hx : \u2200 x', x \u2264 x')\n    (hy : \u2200 y', y \u2264 y') : f x = y", "start": [1163, 1], "end": [1167, 11], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_bot", "code": "theorem OrderIso.map_bot [LE \u03b1] [PartialOrder \u03b2] [OrderBot \u03b1] [OrderBot \u03b2] (f : \u03b1 \u2243o \u03b2) : f \u22a5 = \u22a5", "start": [1170, 1], "end": [1171, 47], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_top'", "code": "theorem OrderIso.map_top' [LE \u03b1] [PartialOrder \u03b2] (f : \u03b1 \u2243o \u03b2) {x : \u03b1} {y : \u03b2} (hx : \u2200 x', x' \u2264 x)\n    (hy : \u2200 y', y' \u2264 y) : f x = y", "start": [1174, 1], "end": [1176, 24], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_top", "code": "theorem OrderIso.map_top [LE \u03b1] [PartialOrder \u03b2] [OrderTop \u03b1] [OrderTop \u03b2] (f : \u03b1 \u2243o \u03b2) : f \u22a4 = \u22a4", "start": [1179, 1], "end": [1180, 17], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.map_inf_le", "code": "theorem OrderEmbedding.map_inf_le [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] (f : \u03b1 \u21aao \u03b2) (x y : \u03b1) :\n    f (x \u2293 y) \u2264 f x \u2293 f y", "start": [1183, 1], "end": [1185, 28], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.le_map_sup", "code": "theorem OrderEmbedding.le_map_sup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] (f : \u03b1 \u21aao \u03b2) (x y : \u03b1) :\n    f x \u2294 f y \u2264 f (x \u2294 y)", "start": [1188, 1], "end": [1190, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_inf", "code": "theorem OrderIso.map_inf [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] (f : \u03b1 \u2243o \u03b2) (x y : \u03b1) :\n    f (x \u2293 y) = f x \u2293 f y", "start": [1193, 1], "end": [1197, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_sup", "code": "theorem OrderIso.map_sup [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] (f : \u03b1 \u2243o \u03b2) (x y : \u03b1) :\n    f (x \u2294 y) = f x \u2294 f y", "start": [1200, 1], "end": [1202, 21], "kind": "commanddeclaration"}, {"full_name": "Disjoint.map_orderIso", "code": "theorem Disjoint.map_orderIso [SemilatticeInf \u03b1] [OrderBot \u03b1] [SemilatticeInf \u03b2] [OrderBot \u03b2]\n    {a b : \u03b1} (f : \u03b1 \u2243o \u03b2) (ha : Disjoint a b) : Disjoint (f a) (f b)", "start": [1205, 1], "end": [1209, 29], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.map_orderIso", "code": "theorem Codisjoint.map_orderIso [SemilatticeSup \u03b1] [OrderTop \u03b1] [SemilatticeSup \u03b2] [OrderTop \u03b2]\n    {a b : \u03b1} (f : \u03b1 \u2243o \u03b2) (ha : Codisjoint a b) : Codisjoint (f a) (f b)", "start": [1212, 1], "end": [1216, 29], "kind": "commanddeclaration"}, {"full_name": "disjoint_map_orderIso_iff", "code": "@[simp]\ntheorem disjoint_map_orderIso_iff [SemilatticeInf \u03b1] [OrderBot \u03b1] [SemilatticeInf \u03b2] [OrderBot \u03b2]\n    {a b : \u03b1} (f : \u03b1 \u2243o \u03b2) : Disjoint (f a) (f b) \u2194 Disjoint a b", "start": [1219, 1], "end": [1223, 30], "kind": "commanddeclaration"}, {"full_name": "codisjoint_map_orderIso_iff", "code": "@[simp]\ntheorem codisjoint_map_orderIso_iff [SemilatticeSup \u03b1] [OrderTop \u03b1] [SemilatticeSup \u03b2] [OrderTop \u03b2]\n    {a b : \u03b1} (f : \u03b1 \u2243o \u03b2) : Codisjoint (f a) (f b) \u2194 Codisjoint a b", "start": [1226, 1], "end": [1230, 30], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDualTopEquiv", "code": "protected def toDualTopEquiv [LE \u03b1] : WithBot \u03b1\u1d52\u1d48 \u2243o (WithTop \u03b1)\u1d52\u1d48 :=\n  OrderIso.refl _", "start": [1235, 1], "end": [1239, 18], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDualTopEquiv_coe", "code": "@[simp]\ntheorem toDualTopEquiv_coe [LE \u03b1] (a : \u03b1) :\n    WithBot.toDualTopEquiv \u2191(toDual a) = toDual (a : WithTop \u03b1)", "start": [1242, 1], "end": [1245, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDualTopEquiv_symm_coe", "code": "@[simp]\ntheorem toDualTopEquiv_symm_coe [LE \u03b1] (a : \u03b1) :\n    WithBot.toDualTopEquiv.symm (toDual (a : WithTop \u03b1)) = \u2191(toDual a)", "start": [1248, 1], "end": [1251, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDualTopEquiv_bot", "code": "@[simp]\ntheorem toDualTopEquiv_bot [LE \u03b1] : WithBot.toDualTopEquiv (\u22a5 : WithBot \u03b1\u1d52\u1d48) = \u22a5", "start": [1254, 1], "end": [1256, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.toDualTopEquiv_symm_bot", "code": "@[simp]\ntheorem toDualTopEquiv_symm_bot [LE \u03b1] : WithBot.toDualTopEquiv.symm (\u22a5 : (WithTop \u03b1)\u1d52\u1d48) = \u22a5", "start": [1259, 1], "end": [1261, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_toDualTopEquiv_eq", "code": "theorem coe_toDualTopEquiv_eq [LE \u03b1] :\n    (WithBot.toDualTopEquiv : WithBot \u03b1\u1d52\u1d48 \u2192 (WithTop \u03b1)\u1d52\u1d48) = toDual \u2218 WithBot.ofDual", "start": [1264, 1], "end": [1266, 22], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDualBotEquiv", "code": "protected def toDualBotEquiv [LE \u03b1] : WithTop \u03b1\u1d52\u1d48 \u2243o (WithBot \u03b1)\u1d52\u1d48 :=\n  OrderIso.refl _", "start": [1273, 1], "end": [1276, 18], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDualBotEquiv_coe", "code": "@[simp]\ntheorem toDualBotEquiv_coe [LE \u03b1] (a : \u03b1) :\n    WithTop.toDualBotEquiv \u2191(toDual a) = toDual (a : WithBot \u03b1)", "start": [1279, 1], "end": [1282, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDualBotEquiv_symm_coe", "code": "@[simp]\ntheorem toDualBotEquiv_symm_coe [LE \u03b1] (a : \u03b1) :\n    WithTop.toDualBotEquiv.symm (toDual (a : WithBot \u03b1)) = \u2191(toDual a)", "start": [1285, 1], "end": [1288, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDualBotEquiv_top", "code": "@[simp]\ntheorem toDualBotEquiv_top [LE \u03b1] : WithTop.toDualBotEquiv (\u22a4 : WithTop \u03b1\u1d52\u1d48) = \u22a4", "start": [1291, 1], "end": [1293, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.toDualBotEquiv_symm_top", "code": "@[simp]\ntheorem toDualBotEquiv_symm_top [LE \u03b1] : WithTop.toDualBotEquiv.symm (\u22a4 : (WithBot \u03b1)\u1d52\u1d48) = \u22a4", "start": [1296, 1], "end": [1298, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_toDualBotEquiv", "code": "theorem coe_toDualBotEquiv [LE \u03b1] :\n    (WithTop.toDualBotEquiv : WithTop \u03b1\u1d52\u1d48 \u2192 (WithBot \u03b1)\u1d52\u1d48) = toDual \u2218 WithTop.ofDual", "start": [1301, 1], "end": [1303, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withTopCongr", "code": "@[simps! apply]\ndef withTopCongr (e : \u03b1 \u2243o \u03b2) : WithTop \u03b1 \u2243o WithTop \u03b2 :=\n  { e.toOrderEmbedding.withTopMap with\n    toEquiv := e.toEquiv.optionCongr }", "start": [1312, 1], "end": [1316, 39], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withTopCongr_refl", "code": "@[simp]\ntheorem withTopCongr_refl : (OrderIso.refl \u03b1).withTopCongr = OrderIso.refl _", "start": [1320, 1], "end": [1322, 50], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withTopCongr_symm", "code": "@[simp]\ntheorem withTopCongr_symm (e : \u03b1 \u2243o \u03b2) : e.withTopCongr.symm = e.symm.withTopCongr", "start": [1325, 1], "end": [1327, 54], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withTopCongr_trans", "code": "@[simp]\ntheorem withTopCongr_trans (e\u2081 : \u03b1 \u2243o \u03b2) (e\u2082 : \u03b2 \u2243o \u03b3) :\n    e\u2081.withTopCongr.trans e\u2082.withTopCongr = (e\u2081.trans e\u2082).withTopCongr", "start": [1330, 1], "end": [1333, 70], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withBotCongr", "code": "@[simps! apply]\ndef withBotCongr (e : \u03b1 \u2243o \u03b2) : WithBot \u03b1 \u2243o WithBot \u03b2 :=\n  { e.toOrderEmbedding.withBotMap with toEquiv := e.toEquiv.optionCongr }", "start": [1336, 1], "end": [1339, 74], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withBotCongr_refl", "code": "@[simp]\ntheorem withBotCongr_refl : (OrderIso.refl \u03b1).withBotCongr = OrderIso.refl _", "start": [1343, 1], "end": [1345, 50], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withBotCongr_symm", "code": "@[simp]\ntheorem withBotCongr_symm (e : \u03b1 \u2243o \u03b2) : e.withBotCongr.symm = e.symm.withBotCongr", "start": [1348, 1], "end": [1350, 54], "kind": "commanddeclaration"}, {"full_name": "OrderIso.withBotCongr_trans", "code": "@[simp]\ntheorem withBotCongr_trans (e\u2081 : \u03b1 \u2243o \u03b2) (e\u2082 : \u03b2 \u2243o \u03b3) :\n    e\u2081.withBotCongr.trans e\u2082.withBotCongr = (e\u2081.trans e\u2082).withBotCongr", "start": [1353, 1], "end": [1356, 70], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isCompl", "code": "theorem OrderIso.isCompl {x y : \u03b1} (h : IsCompl x y) : IsCompl (f x) (f y)", "start": [1365, 1], "end": [1366, 43], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isCompl_iff", "code": "theorem OrderIso.isCompl_iff {x y : \u03b1} : IsCompl x y \u2194 IsCompl (f x) (f y)", "start": [1369, 1], "end": [1370, 87], "kind": "commanddeclaration"}, {"full_name": "OrderIso.complementedLattice", "code": "theorem OrderIso.complementedLattice [ComplementedLattice \u03b1] : ComplementedLattice \u03b2", "start": [1373, 1], "end": [1377, 42], "kind": "commanddeclaration"}, {"full_name": "OrderIso.complementedLattice_iff", "code": "theorem OrderIso.complementedLattice_iff : ComplementedLattice \u03b1 \u2194 ComplementedLattice \u03b2", "start": [1380, 1], "end": [1382, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Group/Defs.lean", "imports": ["Mathlib/Data/FunLike/Basic.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ZeroHom", "code": "structure ZeroHom (M : Type*) (N : Type*) [Zero M] [Zero N] where\n  \n  protected toFun : M \u2192 N\n  \n  protected map_zero' : toFun 0 = 0", "start": [74, 1], "end": [85, 36], "kind": "commanddeclaration"}, {"full_name": "ZeroHomClass", "code": "class ZeroHomClass (F : Type*) (M N : outParam (Type*)) [Zero M] [Zero N]\n  extends FunLike F M fun _ => N where\n  \n  map_zero : \u2200 f : F, f 0 = 0", "start": [89, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "AddHom", "code": "structure AddHom (M : Type*) (N : Type*) [Add M] [Add N] where\n  \n  protected toFun : M \u2192 N\n  \n  protected map_add' : \u2200 x y, toFun (x + y) = toFun x + toFun y", "start": [105, 1], "end": [116, 64], "kind": "commanddeclaration"}, {"full_name": "AddHomClass", "code": "class AddHomClass (F : Type*) (M N : outParam (Type*)) [Add M] [Add N]\n  extends FunLike F M fun _ => N where\n  \n  map_add : \u2200 (f : F) (x y : M), f (x + y) = f x + f y", "start": [119, 1], "end": [125, 55], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom", "code": "structure AddMonoidHom (M : Type*) (N : Type*) [AddZeroClass M] [AddZeroClass N] extends\n  ZeroHom M N, AddHom M N", "start": [133, 1], "end": [143, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHomClass", "code": "class AddMonoidHomClass (F : Type*) (M N : outParam (Type*)) [AddZeroClass M] [AddZeroClass N]\n  extends AddHomClass F M N, ZeroHomClass F M N", "start": [152, 1], "end": [158, 48], "kind": "commanddeclaration"}, {"full_name": "OneHom", "code": "@[to_additive]\nstructure OneHom (M : Type*) (N : Type*) [One M] [One N] where\n  \n  protected toFun : M \u2192 N\n  \n  protected map_one' : toFun 1 = 1", "start": [168, 1], "end": [180, 35], "kind": "commanddeclaration"}, {"full_name": "OneHomClass", "code": "@[to_additive]\nclass OneHomClass (F : Type*) (M N : outParam (Type*)) [One M] [One N]\n  extends FunLike F M fun _ => N where\n  \n  map_one : \u2200 f : F, f 1 = 1", "start": [183, 1], "end": [190, 29], "kind": "commanddeclaration"}, {"full_name": "OneHom.oneHomClass", "code": "@[to_additive]\ninstance OneHom.oneHomClass : OneHomClass (OneHom M N) M N where\n  coe := OneHom.toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  map_one := OneHom.map_one'", "start": [193, 1], "end": [197, 29], "kind": "commanddeclaration"}, {"full_name": "map_one", "code": "@[to_additive (attr := simp)]\ntheorem map_one [OneHomClass F M N] (f : F) : f 1 = 1", "start": [201, 1], "end": [203, 24], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.of_oneHomClass", "code": "@[to_additive]\ntheorem Subsingleton.of_oneHomClass [Subsingleton M] [OneHomClass F M N] :\n    Subsingleton F where", "start": [207, 1], "end": [211, 71], "kind": "commanddeclaration"}, {"full_name": "map_eq_one_iff", "code": "@[to_additive]\ntheorem map_eq_one_iff [OneHomClass F M N] (f : F) (hf : Function.Injective f) {x : M} :\n    f x = 1 \u2194 x = 1", "start": [215, 1], "end": [217, 46], "kind": "commanddeclaration"}, {"full_name": "map_ne_one_iff", "code": "@[to_additive]\ntheorem map_ne_one_iff {R S F : Type*} [One R] [One S] [OneHomClass F R S] (f : F)\n    (hf : Function.Injective f) {x : R} : f x \u2260 1 \u2194 x \u2260 1", "start": [221, 1], "end": [223, 87], "kind": "commanddeclaration"}, {"full_name": "ne_one_of_map", "code": "@[to_additive]\ntheorem ne_one_of_map {R S F : Type*} [One R] [One S] [OneHomClass F R S] {f : F} {x : R}\n    (hx : f x \u2260 1) : x \u2260 1", "start": [227, 1], "end": [229, 73], "kind": "commanddeclaration"}, {"full_name": "OneHomClass.toOneHom", "code": "@[to_additive (attr := coe)\n\"Turn an element of a type `F` satisfying `ZeroHomClass F M N` into an actual\n`ZeroHom`. This is declared as the default coercion from `F` to `ZeroHom M N`.\"]\ndef OneHomClass.toOneHom [OneHomClass F M N] (f : F) : OneHom M N where\n  toFun := f\n  map_one' := map_one f", "start": [233, 1], "end": [240, 24], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_coe", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.coe_coe [OneHomClass F M N] (f : F) : ((f : OneHom M N) : M \u2192 N) = f", "start": [248, 1], "end": [249, 91], "kind": "commanddeclaration"}, {"full_name": "MulHom", "code": "@[to_additive]\nstructure MulHom (M : Type*) (N : Type*) [Mul M] [Mul N] where\n  \n  protected toFun : M \u2192 N\n  \n  protected map_mul' : \u2200 x y, toFun (x * y) = toFun x * toFun y", "start": [259, 1], "end": [272, 64], "kind": "commanddeclaration"}, {"full_name": "MulHomClass", "code": "@[to_additive]\nclass MulHomClass (F : Type*) (M N : outParam (Type*)) [Mul M] [Mul N]\n  extends FunLike F M fun _ => N where\n  \n  map_mul : \u2200 (f : F) (x y : M), f (x * y) = f x * f y", "start": [278, 1], "end": [286, 55], "kind": "commanddeclaration"}, {"full_name": "MulHom.mulHomClass", "code": "@[to_additive \"`AddHom` is a type of addition-preserving homomorphisms\"]\ninstance MulHom.mulHomClass : MulHomClass (M \u2192\u2099* N) M N where\n  coe := MulHom.toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  map_mul := MulHom.map_mul'", "start": [289, 1], "end": [294, 29], "kind": "commanddeclaration"}, {"full_name": "map_mul", "code": "@[to_additive (attr := simp)]\ntheorem map_mul [MulHomClass F M N] (f : F) (x y : M) : f (x * y) = f x * f y", "start": [298, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "MulHomClass.toMulHom", "code": "@[to_additive (attr := coe)\n\"Turn an element of a type `F` satisfying `AddHomClass F M N` into an actual\n`AddHom`. This is declared as the default coercion from `F` to `M \u2192\u2099+ N`.\"]\ndef MulHomClass.toMulHom [MulHomClass F M N] (f : F) : M \u2192\u2099* N where\n  toFun := f\n  map_mul' := map_mul f", "start": [304, 1], "end": [311, 24], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_coe", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.coe_coe [MulHomClass F M N] (f : F) : ((f : MulHom M N) : M \u2192 N) = f", "start": [319, 1], "end": [320, 91], "kind": "commanddeclaration"}, {"full_name": "MonoidHom", "code": "@[to_additive]\nstructure MonoidHom (M : Type*) (N : Type*) [MulOneClass M] [MulOneClass N] extends\n  OneHom M N, M \u2192\u2099* N", "start": [330, 1], "end": [340, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass", "code": "@[to_additive]\nclass MonoidHomClass (F : Type*) (M N : outParam (Type*)) [MulOneClass M] [MulOneClass N]\n  extends MulHomClass F M N, OneHomClass F M N", "start": [352, 1], "end": [356, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.monoidHomClass", "code": "@[to_additive]\ninstance MonoidHom.monoidHomClass : MonoidHomClass (M \u2192* N) M N where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    apply FunLike.coe_injective'\n    exact h\n  map_mul := MonoidHom.map_mul'\n  map_one f := f.toOneHom.map_one'", "start": [359, 1], "end": [369, 35], "kind": "commanddeclaration"}, {"full_name": "MonoidHomClass.toMonoidHom", "code": "@[to_additive (attr := coe)\n\"Turn an element of a type `F` satisfying `AddMonoidHomClass F M N` into an\nactual `MonoidHom`. This is declared as the default coercion from `F` to `M \u2192+ N`.\"]\ndef MonoidHomClass.toMonoidHom [MonoidHomClass F M N] (f : F) : M \u2192* N :=\n  { (f : M \u2192\u2099* N), (f : OneHom M N) with }", "start": [379, 1], "end": [385, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_coe", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_coe [MonoidHomClass F M N] (f : F) : ((f : M \u2192* N) : M \u2192 N) = f", "start": [394, 1], "end": [395, 93], "kind": "commanddeclaration"}, {"full_name": "map_mul_eq_one", "code": "@[to_additive]\ntheorem map_mul_eq_one [MonoidHomClass F M N] (f : F) {a b : M} (h : a * b = 1) : f a * f b = 1", "start": [399, 1], "end": [401, 32], "kind": "commanddeclaration"}, {"full_name": "map_div'", "code": "@[to_additive]\ntheorem map_div' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : \u2200 a, f a\u207b\u00b9 = (f a)\u207b\u00b9) (a b : G) : f (a / b) = f a / f b", "start": [405, 1], "end": [408, 51], "kind": "commanddeclaration"}, {"full_name": "map_inv", "code": "@[to_additive (attr := simp) \"Additive group homomorphisms preserve negation.\"]\ntheorem map_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (a : G) : f a\u207b\u00b9 = (f a)\u207b\u00b9", "start": [412, 1], "end": [416, 66], "kind": "commanddeclaration"}, {"full_name": "map_mul_inv", "code": "@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_mul_inv [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) (a b : G) :\n    f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9", "start": [420, 1], "end": [423, 60], "kind": "commanddeclaration"}, {"full_name": "map_div", "code": "@[to_additive (attr := simp) \"Additive group homomorphisms preserve subtraction.\"]\ntheorem map_div [Group G] [DivisionMonoid H] [MonoidHomClass F G H] (f : F) :\n    \u2200 a b, f (a / b) = f a / f b", "start": [427, 1], "end": [430, 60], "kind": "commanddeclaration"}, {"full_name": "map_pow", "code": "@[to_additive (attr := simp) (reorder := 8 9)]\ntheorem map_pow [Monoid G] [Monoid H] [MonoidHomClass F G H] (f : F) (a : G) :\n    \u2200 n : \u2115, f (a ^ n) = f a ^ n", "start": [434, 1], "end": [438, 64], "kind": "commanddeclaration"}, {"full_name": "map_zpow'", "code": "@[to_additive]\ntheorem map_zpow' [DivInvMonoid G] [DivInvMonoid H] [MonoidHomClass F G H]\n    (f : F) (hf : \u2200 x : G, f x\u207b\u00b9 = (f x)\u207b\u00b9) (a : G) : \u2200 n : \u2124, f (a ^ n) = f a ^ n", "start": [442, 1], "end": [446, 87], "kind": "commanddeclaration"}, {"full_name": "map_zpow", "code": "@[to_additive (attr := simp) (reorder := 8 9)\n\"Additive group homomorphisms preserve integer scaling.\"]\ntheorem map_zpow [Group G] [DivisionMonoid H] [MonoidHomClass F G H]\n    (f : F) (g : G) (n : \u2124) : f (g ^ n) = f g ^ n", "start": [450, 1], "end": [454, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom", "code": "structure MonoidWithZeroHom (M : Type*) (N : Type*)\n  [MulZeroOneClass M] [MulZeroOneClass N] extends ZeroHom M N, MonoidHom M N", "start": [464, 1], "end": [475, 77], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHomClass", "code": "class MonoidWithZeroHomClass (F : Type*) (M N : outParam (Type*)) [MulZeroOneClass M]\n  [MulZeroOneClass N] extends MonoidHomClass F M N, ZeroHomClass F M N", "start": [484, 1], "end": [490, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.monoidWithZeroHomClass", "code": "instance MonoidWithZeroHom.monoidWithZeroHomClass : MonoidWithZeroHomClass (M \u2192*\u2080 N) M N where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    apply FunLike.coe_injective'\n    exact h\n  map_mul := MonoidWithZeroHom.map_mul'\n  map_one := MonoidWithZeroHom.map_one'\n  map_zero f := f.map_zero'", "start": [493, 1], "end": [503, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHomClass.toMonoidWithZeroHom", "code": "@[coe]\ndef MonoidWithZeroHomClass.toMonoidWithZeroHom [MonoidWithZeroHomClass F M N] (f : F) : M \u2192*\u2080 N :=\n  { (f : M \u2192* N), (f : ZeroHom M N) with }", "start": [508, 1], "end": [512, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coe_coe", "code": "@[simp]\ntheorem MonoidWithZeroHom.coe_coe [MonoidWithZeroHomClass F M N] (f : F) :\n    ((f : M \u2192*\u2080 N) : M \u2192 N) = f", "start": [519, 1], "end": [521, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coeToOneHom", "code": "@[to_additive \"`AddMonoidHom` down-cast to a `ZeroHom`, forgetting the additive property\"]\ninstance MonoidHom.coeToOneHom [MulOneClass M] [MulOneClass N] :\n  Coe (M \u2192* N) (OneHom M N) := \u27e8MonoidHom.toOneHom\u27e9", "start": [534, 1], "end": [537, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coeToMulHom", "code": "@[to_additive \"`AddMonoidHom` down-cast to an `AddHom`, forgetting the 0-preserving property.\"]\ninstance MonoidHom.coeToMulHom [MulOneClass M] [MulOneClass N] :\n  Coe (M \u2192* N) (M \u2192\u2099* N) := \u27e8MonoidHom.toMulHom\u27e9", "start": [544, 1], "end": [547, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coeToMonoidHom", "code": "instance MonoidWithZeroHom.coeToMonoidHom [MulZeroOneClass M] [MulZeroOneClass N] :\n  Coe (M \u2192*\u2080 N) (M \u2192* N) := \u27e8MonoidWithZeroHom.toMonoidHom\u27e9", "start": [553, 1], "end": [555, 60], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coeToZeroHom", "code": "instance MonoidWithZeroHom.coeToZeroHom [MulZeroOneClass M] [MulZeroOneClass N] :\n  Coe (M \u2192*\u2080 N) (ZeroHom M N) := \u27e8MonoidWithZeroHom.toZeroHom\u27e9", "start": [560, 1], "end": [562, 63], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.coe_mk [One M] [One N] (f : M \u2192 N) (h1) : (OneHom.mk f h1 : M \u2192 N) = f", "start": [574, 1], "end": [575, 93], "kind": "commanddeclaration"}, {"full_name": "OneHom.toFun_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.toFun_eq_coe [One M] [One N] (f : OneHom M N) : f.toFun = f", "start": [579, 1], "end": [580, 82], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.coe_mk [Mul M] [Mul N] (f : M \u2192 N) (hmul) : (MulHom.mk f hmul : M \u2192 N) = f", "start": [584, 1], "end": [585, 97], "kind": "commanddeclaration"}, {"full_name": "MulHom.toFun_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.toFun_eq_coe [Mul M] [Mul N] (f : M \u2192\u2099* N) : f.toFun = f", "start": [589, 1], "end": [590, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_mk [MulOneClass M] [MulOneClass N] (f hmul) :\n    (MonoidHom.mk f hmul : M \u2192 N) = f", "start": [594, 1], "end": [596, 45], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toOneHom_coe", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.toOneHom_coe [MulOneClass M] [MulOneClass N] (f : M \u2192* N) :\n    (f.toOneHom : M \u2192 N) = f", "start": [600, 1], "end": [602, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toMulHom_coe", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.toMulHom_coe [MulOneClass M] [MulOneClass N] (f : M \u2192* N) :\n    f.toMulHom.toFun = f", "start": [606, 1], "end": [608, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toFun_eq_coe", "code": "@[to_additive]\ntheorem MonoidHom.toFun_eq_coe [MulOneClass M] [MulOneClass N] (f : M \u2192* N) : f.toFun = f", "start": [612, 1], "end": [613, 97], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coe_mk", "code": "@[simp]\ntheorem MonoidWithZeroHom.coe_mk [MulZeroOneClass M] [MulZeroOneClass N] (f h1 hmul) :\n    (MonoidWithZeroHom.mk f h1 hmul : M \u2192 N) = (f : M \u2192 N)", "start": [617, 1], "end": [619, 66], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.toZeroHom_coe", "code": "@[simp]\ntheorem MonoidWithZeroHom.toZeroHom_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    (f.toZeroHom : M \u2192 N) = f", "start": [622, 1], "end": [624, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.toMonoidHom_coe", "code": "theorem MonoidWithZeroHom.toMonoidHom_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    f.toMonoidHom.toFun = f", "start": [627, 1], "end": [628, 35], "kind": "commanddeclaration"}, {"full_name": "OneHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem OneHom.ext [One M] [One N] \u2983f g : OneHom M N\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [631, 1], "end": [633, 20], "kind": "commanddeclaration"}, {"full_name": "MulHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem MulHom.ext [Mul M] [Mul N] \u2983f g : M \u2192\u2099* N\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [637, 1], "end": [639, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext", "code": "@[to_additive (attr := ext)]\ntheorem MonoidHom.ext [MulOneClass M] [MulOneClass N] \u2983f g : M \u2192* N\u2984 (h : \u2200 x, f x = g x) : f = g", "start": [643, 1], "end": [645, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext", "code": "@[ext]\ntheorem MonoidWithZeroHom.ext [MulZeroOneClass M] [MulZeroOneClass N] \u2983f g : M \u2192*\u2080 N\u2984\n    (h : \u2200 x, f x = g x) : f = g", "start": [649, 1], "end": [651, 54], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mk'", "code": "@[to_additive (attr := simps (config := .asFn))\n  \"Makes an additive group homomorphism from a proof that the map preserves addition.\"]\ndef mk' (f : M \u2192 G) (map_mul : \u2200 a b : M, f (a * b) = f a * f b) : M \u2192* G where\n  toFun := f\n  map_mul' := map_mul\n  map_one' := by rw [\u2190 mul_right_cancel_iff, \u2190 map_mul _ 1, one_mul, one_mul]", "start": [660, 1], "end": [666, 78], "kind": "commanddeclaration"}, {"full_name": "OneHom.congr_fun", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_fun` instead.\"]\ntheorem OneHom.congr_fun [One M] [One N] {f g : OneHom M N} (h : f = g) (x : M) : f x = g x", "start": [676, 1], "end": [679, 24], "kind": "commanddeclaration"}, {"full_name": "MulHom.congr_fun", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_fun` instead.\"]\ntheorem MulHom.congr_fun [Mul M] [Mul N] {f g : M \u2192\u2099* N} (h : f = g) (x : M) : f x = g x", "start": [683, 1], "end": [686, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.congr_fun", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_fun` instead.\"]\ntheorem MonoidHom.congr_fun [MulOneClass M] [MulOneClass N] {f g : M \u2192* N} (h : f = g) (x : M) :\n    f x = g x", "start": [690, 1], "end": [693, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.congr_fun", "code": "@[deprecated]\ntheorem MonoidWithZeroHom.congr_fun [MulZeroOneClass M] [MulZeroOneClass N] {f g : M \u2192*\u2080 N}\n    (h : f = g) (x : M) : f x = g x", "start": [697, 1], "end": [700, 61], "kind": "commanddeclaration"}, {"full_name": "OneHom.congr_arg", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_arg` instead.\"]\ntheorem OneHom.congr_arg [One M] [One N] (f : OneHom M N) {x y : M} (h : x = y) : f x = f y", "start": [703, 1], "end": [706, 24], "kind": "commanddeclaration"}, {"full_name": "MulHom.congr_arg", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_arg` instead.\"]\ntheorem MulHom.congr_arg [Mul M] [Mul N] (f : M \u2192\u2099* N) {x y : M} (h : x = y) : f x = f y", "start": [710, 1], "end": [713, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.congr_arg", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.congr_arg` instead.\"]\ntheorem MonoidHom.congr_arg [MulOneClass M] [MulOneClass N] (f : M \u2192* N) {x y : M} (h : x = y) :\n    f x = f y", "start": [717, 1], "end": [720, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.congr_arg", "code": "@[deprecated]\ntheorem MonoidWithZeroHom.congr_arg [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) {x y : M}\n    (h : x = y) : f x = f y", "start": [724, 1], "end": [727, 53], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_inj", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.coe_injective` instead.\"]\ntheorem OneHom.coe_inj [One M] [One N] \u2983f g : OneHom M N\u2984 (h : (f : M \u2192 N) = g) : f = g", "start": [730, 1], "end": [733, 26], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_inj", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.coe_injective` instead.\"]\ntheorem MulHom.coe_inj [Mul M] [Mul N] \u2983f g : M \u2192\u2099* N\u2984 (h : (f : M \u2192 N) = g) : f = g", "start": [737, 1], "end": [740, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_inj", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.coe_injective` instead.\"]\ntheorem MonoidHom.coe_inj [MulOneClass M] [MulOneClass N] \u2983f g : M \u2192* N\u2984 (h : (f : M \u2192 N) = g) :\n    f = g", "start": [744, 1], "end": [747, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coe_inj", "code": "@[deprecated]\ntheorem MonoidWithZeroHom.coe_inj [MulZeroOneClass M] [MulZeroOneClass N] \u2983f g : M \u2192*\u2080 N\u2984\n    (h : (f : M \u2192 N) = g) : f = g", "start": [751, 1], "end": [754, 61], "kind": "commanddeclaration"}, {"full_name": "OneHom.ext_iff", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.ext_iff` instead.\"]\ntheorem OneHom.ext_iff [One M] [One N] {f g : OneHom M N} : f = g \u2194 \u2200 x, f x = g x", "start": [757, 1], "end": [760, 18], "kind": "commanddeclaration"}, {"full_name": "MulHom.ext_iff", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.ext_iff` instead.\"]\ntheorem MulHom.ext_iff [Mul M] [Mul N] {f g : M \u2192\u2099* N} : f = g \u2194 \u2200 x, f x = g x", "start": [764, 1], "end": [767, 18], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ext_iff", "code": "@[to_additive (attr := deprecated) \"Deprecated: use `FunLike.ext_iff` instead.\"]\ntheorem MonoidHom.ext_iff [MulOneClass M] [MulOneClass N] {f g : M \u2192* N} : f = g \u2194 \u2200 x, f x = g x", "start": [771, 1], "end": [774, 18], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.ext_iff", "code": "@[deprecated]\ntheorem MonoidWithZeroHom.ext_iff [MulZeroOneClass M] [MulZeroOneClass N] {f g : M \u2192*\u2080 N} :\n    f = g \u2194 \u2200 x, f x = g x", "start": [778, 1], "end": [781, 46], "kind": "commanddeclaration"}, {"full_name": "OneHom.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.mk_coe [One M] [One N] (f : OneHom M N) (h1) : OneHom.mk f h1 = f", "start": [786, 1], "end": [788, 26], "kind": "commanddeclaration"}, {"full_name": "MulHom.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.mk_coe [Mul M] [Mul N] (f : M \u2192\u2099* N) (hmul) : MulHom.mk f hmul = f", "start": [792, 1], "end": [794, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.mk_coe [MulOneClass M] [MulOneClass N] (f : M \u2192* N) (hmul) :\n    MonoidHom.mk f hmul = f", "start": [798, 1], "end": [800, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.mk_coe", "code": "@[simp]\ntheorem MonoidWithZeroHom.mk_coe [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) (h1 hmul) :\n    MonoidWithZeroHom.mk f h1 hmul = f", "start": [804, 1], "end": [806, 77], "kind": "commanddeclaration"}, {"full_name": "OneHom.copy", "code": "@[to_additive\n  \"Copy of a `ZeroHom` with a new `toFun` equal to the old one. Useful to fix\n  definitional equalities.\"]\nprotected def OneHom.copy [One M] [One N] (f : OneHom M N) (f' : M \u2192 N) (h : f' = f) :\n    OneHom M N where\n  toFun := f'\n  map_one' := h.symm \u25b8 f.map_one'", "start": [811, 1], "end": [819, 34], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.coe_copy {_ : One M} {_ : One N} (f : OneHom M N) (f' : M \u2192 N) (h : f' = f) :\n    (f.copy f' h) = f'", "start": [823, 1], "end": [826, 6], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_copy_eq", "code": "@[to_additive]\ntheorem OneHom.coe_copy_eq {_ : One M} {_ : One N} (f : OneHom M N) (f' : M \u2192 N) (h : f' = f) :\n    f.copy f' h = f", "start": [830, 1], "end": [833, 17], "kind": "commanddeclaration"}, {"full_name": "MulHom.copy", "code": "@[to_additive\n  \"Copy of an `AddHom` with a new `toFun` equal to the old one. Useful to fix\n  definitional equalities.\"]\nprotected def MulHom.copy [Mul M] [Mul N] (f : M \u2192\u2099* N) (f' : M \u2192 N) (h : f' = f) :\n    M \u2192\u2099* N where\n  toFun := f'\n  map_mul' := h.symm \u25b8 f.map_mul'", "start": [837, 1], "end": [845, 34], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.coe_copy {_ : Mul M} {_ : Mul N} (f : M \u2192\u2099* N) (f' : M \u2192 N) (h : f' = f) :\n    (f.copy f' h) = f'", "start": [849, 1], "end": [852, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_copy_eq", "code": "@[to_additive]\ntheorem MulHom.coe_copy_eq {_ : Mul M} {_ : Mul N} (f : M \u2192\u2099* N) (f' : M \u2192 N) (h : f' = f) :\n    f.copy f' h = f", "start": [856, 1], "end": [859, 17], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.copy", "code": "@[to_additive\n  \"Copy of an `AddMonoidHom` with a new `toFun` equal to the old one. Useful to fix\n  definitional equalities.\"]\nprotected def MonoidHom.copy [MulOneClass M] [MulOneClass N] (f : M \u2192* N) (f' : M \u2192 N)\n    (h : f' = f) : M \u2192* N :=\n  { f.toOneHom.copy f' h, f.toMulHom.copy f' h with }", "start": [863, 1], "end": [870, 54], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_copy {_ : MulOneClass M} {_ : MulOneClass N} (f : M \u2192* N) (f' : M \u2192 N)\n    (h : f' = f) : (f.copy f' h) = f'", "start": [874, 1], "end": [877, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.copy_eq", "code": "@[to_additive]\ntheorem MonoidHom.copy_eq {_ : MulOneClass M} {_ : MulOneClass N} (f : M \u2192* N) (f' : M \u2192 N)\n    (h : f' = f) : f.copy f' h = f", "start": [881, 1], "end": [884, 17], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.copy", "code": "protected def MonoidWithZeroHom.copy [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N)\n    (f' : M \u2192 N) (h : f' = f) : M \u2192* N :=\n  { f.toZeroHom.copy f' h, f.toMonoidHom.copy f' h with }", "start": [888, 1], "end": [892, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coe_copy", "code": "@[simp]\ntheorem MonoidWithZeroHom.coe_copy {_ : MulZeroOneClass M} {_ : MulZeroOneClass N} (f : M \u2192*\u2080 N)\n    (f' : M \u2192 N) (h : f' = f) : (f.copy f' h) = f'", "start": [895, 1], "end": [898, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.copy_eq", "code": "theorem MonoidWithZeroHom.copy_eq {_ : MulZeroOneClass M} {_ : MulZeroOneClass N} (f : M \u2192*\u2080 N)\n    (f' : M \u2192 N) (h : f' = f) : f.copy f' h = f", "start": [901, 1], "end": [903, 17], "kind": "commanddeclaration"}, {"full_name": "OneHom.map_one", "code": "@[to_additive]\nprotected theorem OneHom.map_one [One M] [One N] (f : OneHom M N) : f 1 = 1", "start": [906, 1], "end": [908, 13], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_one", "code": "@[to_additive]\nprotected theorem MonoidHom.map_one [MulOneClass M] [MulOneClass N] (f : M \u2192* N) : f 1 = 1", "start": [912, 1], "end": [915, 13], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.map_one", "code": "protected theorem MonoidWithZeroHom.map_one [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    f 1 = 1", "start": [919, 1], "end": [920, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.map_zero", "code": "protected theorem MonoidWithZeroHom.map_zero [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    f 0 = 0", "start": [926, 1], "end": [927, 27], "kind": "commanddeclaration"}, {"full_name": "MulHom.map_mul", "code": "@[to_additive]\nprotected theorem MulHom.map_mul [Mul M] [Mul N] (f : M \u2192\u2099* N) (a b : M) : f (a * b) = f a * f b", "start": [930, 1], "end": [932, 17], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mul", "code": "@[to_additive]\nprotected theorem MonoidHom.map_mul [MulOneClass M] [MulOneClass N] (f : M \u2192* N) (a b : M) :\n    f (a * b) = f a * f b", "start": [936, 1], "end": [939, 44], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.map_mul", "code": "protected theorem MonoidWithZeroHom.map_mul [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N)\n    (a b : M) : f (a * b) = f a * f b", "start": [943, 1], "end": [944, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_exists_right_inv", "code": "@[to_additive\n  \"Given an AddMonoid homomorphism `f : M \u2192+ N` and an element `x : M`, if `x` has\n  a right inverse, then `f x` has a right inverse too.\"]\ntheorem map_exists_right_inv (f : F) {x : M} (hx : \u2203 y, x * y = 1) : \u2203 y, f x * y = 1", "start": [954, 1], "end": [961, 29], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_exists_left_inv", "code": "@[to_additive\n  \"Given an AddMonoid homomorphism `f : M \u2192+ N` and an element `x : M`, if `x` has\n  a left inverse, then `f x` has a left inverse too. For elements invertible on both sides see\n  `IsAddUnit.map`.\"]\ntheorem map_exists_left_inv (f : F) {x : M} (hx : \u2203 y, y * x = 1) : \u2203 y, y * f x = 1", "start": [965, 1], "end": [973, 29], "kind": "commanddeclaration"}, {"full_name": "OneHom.id", "code": "@[to_additive (attr := simps)]\ndef OneHom.id (M : Type*) [One M] : OneHom M M where\n  toFun x := x\n  map_one' := rfl", "start": [979, 1], "end": [983, 18], "kind": "commanddeclaration"}, {"full_name": "MulHom.id", "code": "@[to_additive (attr := simps)]\ndef MulHom.id (M : Type*) [Mul M] : M \u2192\u2099* M where\n  toFun x := x\n  map_mul' _ _ := rfl", "start": [989, 1], "end": [993, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.id", "code": "@[to_additive (attr := simps)]\ndef MonoidHom.id (M : Type*) [MulOneClass M] : M \u2192* M where\n  toFun x := x\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [999, 1], "end": [1004, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.id", "code": "@[simps]\ndef MonoidWithZeroHom.id (M : Type*) [MulZeroOneClass M] : M \u2192*\u2080 M where\n  toFun x := x\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [1010, 1], "end": [1016, 22], "kind": "commanddeclaration"}, {"full_name": "OneHom.comp", "code": "@[to_additive]\ndef OneHom.comp [One M] [One N] [One P] (hnp : OneHom N P) (hmn : OneHom M N) : OneHom M P where\n  toFun := hnp \u2218 hmn\n  map_one' := by simp", "start": [1029, 1], "end": [1033, 22], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp", "code": "@[to_additive]\ndef MulHom.comp [Mul M] [Mul N] [Mul P] (hnp : N \u2192\u2099* P) (hmn : M \u2192\u2099* N) : M \u2192\u2099* P where\n  toFun := hnp \u2218 hmn\n  map_mul' x y := by simp", "start": [1037, 1], "end": [1041, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp", "code": "@[to_additive]\ndef MonoidHom.comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (hnp : N \u2192* P) (hmn : M \u2192* N) :\n    M \u2192* P where\n  toFun := hnp \u2218 hmn\n  map_one' := by simp\n  map_mul' := by simp", "start": [1045, 1], "end": [1051, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.comp", "code": "def MonoidWithZeroHom.comp [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    (hnp : N \u2192*\u2080 P) (hmn : M \u2192*\u2080 N) : M \u2192*\u2080 P where\n  toFun := hnp \u2218 hmn\n  map_zero' := by rw [Function.comp_apply, map_zero, map_zero]\n  map_one' := by simp\n  map_mul' := by simp", "start": [1055, 1], "end": [1061, 22], "kind": "commanddeclaration"}, {"full_name": "OneHom.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.coe_comp [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) :\n    \u2191(g.comp f) = g \u2218 f", "start": [1073, 1], "end": [1075, 31], "kind": "commanddeclaration"}, {"full_name": "MulHom.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.coe_comp [Mul M] [Mul N] [Mul P] (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) :\n    \u2191(g.comp f) = g \u2218 f", "start": [1079, 1], "end": [1081, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_comp", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.coe_comp [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N \u2192* P) (f : M \u2192* N) : \u2191(g.comp f) = g \u2218 f", "start": [1085, 1], "end": [1087, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.coe_comp", "code": "@[simp]\ntheorem MonoidWithZeroHom.coe_comp [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    (g : N \u2192*\u2080 P) (f : M \u2192*\u2080 N) : \u2191(g.comp f) = g \u2218 f", "start": [1091, 1], "end": [1093, 61], "kind": "commanddeclaration"}, {"full_name": "OneHom.comp_apply", "code": "@[to_additive]\ntheorem OneHom.comp_apply [One M] [One N] [One P] (g : OneHom N P) (f : OneHom M N) (x : M) :\n    g.comp f x = g (f x)", "start": [1096, 1], "end": [1098, 32], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp_apply", "code": "@[to_additive]\ntheorem MulHom.comp_apply [Mul M] [Mul N] [Mul P] (g : N \u2192\u2099* P) (f : M \u2192\u2099* N) (x : M) :\n    g.comp f x = g (f x)", "start": [1102, 1], "end": [1104, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_apply", "code": "@[to_additive]\ntheorem MonoidHom.comp_apply [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (g : N \u2192* P) (f : M \u2192* N) (x : M) : g.comp f x = g (f x)", "start": [1108, 1], "end": [1110, 68], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.comp_apply", "code": "theorem MonoidWithZeroHom.comp_apply [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    (g : N \u2192*\u2080 P) (f : M \u2192*\u2080 N) (x : M) : g.comp f x = g (f x)", "start": [1114, 1], "end": [1115, 70], "kind": "commanddeclaration"}, {"full_name": "OneHom.comp_assoc", "code": "@[to_additive \"Composition of additive monoid homomorphisms is associative.\"]\ntheorem OneHom.comp_assoc {Q : Type*} [One M] [One N] [One P] [One Q]\n    (f : OneHom M N) (g : OneHom N P) (h : OneHom P Q) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [1118, 1], "end": [1122, 49], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp_assoc", "code": "@[to_additive]\ntheorem MulHom.comp_assoc {Q : Type*} [Mul M] [Mul N] [Mul P] [Mul Q]\n    (f : M \u2192\u2099* N) (g : N \u2192\u2099* P) (h : P \u2192\u2099* Q) : (h.comp g).comp f = h.comp (g.comp f)", "start": [1126, 1], "end": [1128, 93], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_assoc", "code": "@[to_additive]\ntheorem MonoidHom.comp_assoc {Q : Type*} [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    [MulOneClass Q] (f : M \u2192* N) (g : N \u2192* P) (h : P \u2192* Q) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [1132, 1], "end": [1135, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.comp_assoc", "code": "theorem MonoidWithZeroHom.comp_assoc {Q : Type*} [MulZeroOneClass M] [MulZeroOneClass N]\n    [MulZeroOneClass P] [MulZeroOneClass Q] (f : M \u2192*\u2080 N) (g : N \u2192*\u2080 P) (h : P \u2192*\u2080 Q) :\n    (h.comp g).comp f = h.comp (g.comp f)", "start": [1139, 1], "end": [1141, 49], "kind": "commanddeclaration"}, {"full_name": "OneHom.cancel_right", "code": "@[to_additive]\ntheorem OneHom.cancel_right [One M] [One N] [One P] {g\u2081 g\u2082 : OneHom N P} {f : OneHom M N}\n    (hf : Function.Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1144, 1], "end": [1147, 79], "kind": "commanddeclaration"}, {"full_name": "MulHom.cancel_right", "code": "@[to_additive]\ntheorem MulHom.cancel_right [Mul M] [Mul N] [Mul P] {g\u2081 g\u2082 : N \u2192\u2099* P} {f : M \u2192\u2099* N}\n    (hf : Function.Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1151, 1], "end": [1154, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.cancel_right", "code": "@[to_additive]\ntheorem MonoidHom.cancel_right [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g\u2081 g\u2082 : N \u2192* P} {f : M \u2192* N} (hf : Function.Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1158, 1], "end": [1162, 82], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.cancel_right", "code": "theorem MonoidWithZeroHom.cancel_right [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    {g\u2081 g\u2082 : N \u2192*\u2080 P} {f : M \u2192*\u2080 N} (hf : Function.Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [1166, 1], "end": [1169, 90], "kind": "commanddeclaration"}, {"full_name": "OneHom.cancel_left", "code": "@[to_additive]\ntheorem OneHom.cancel_left [One M] [One N] [One P] {g : OneHom N P} {f\u2081 f\u2082 : OneHom M N}\n    (hg : Function.Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1172, 1], "end": [1176, 22], "kind": "commanddeclaration"}, {"full_name": "MulHom.cancel_left", "code": "@[to_additive]\ntheorem MulHom.cancel_left [Mul M] [Mul N] [Mul P] {g : N \u2192\u2099* P} {f\u2081 f\u2082 : M \u2192\u2099* N}\n    (hg : Function.Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1180, 1], "end": [1184, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.cancel_left", "code": "@[to_additive]\ntheorem MonoidHom.cancel_left [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    {g : N \u2192* P} {f\u2081 f\u2082 : M \u2192* N} (hg : Function.Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1188, 1], "end": [1192, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.cancel_left", "code": "theorem MonoidWithZeroHom.cancel_left [MulZeroOneClass M] [MulZeroOneClass N] [MulZeroOneClass P]\n    {g : N \u2192*\u2080 P} {f\u2081 f\u2082 : M \u2192*\u2080 N} (hg : Function.Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [1196, 1], "end": [1201, 53], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toOneHom_injective", "code": "@[to_additive]\ntheorem MonoidHom.toOneHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toOneHom : (M \u2192* N) \u2192 OneHom M N)", "start": [1207, 1], "end": [1210, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toMulHom_injective", "code": "@[to_additive]\ntheorem MonoidHom.toMulHom_injective [MulOneClass M] [MulOneClass N] :\n    Function.Injective (MonoidHom.toMulHom : (M \u2192* N) \u2192 M \u2192\u2099* N)", "start": [1214, 1], "end": [1217, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.toMonoidHom_injective", "code": "theorem MonoidWithZeroHom.toMonoidHom_injective [MulZeroOneClass M] [MulZeroOneClass N] :\n    Function.Injective (MonoidWithZeroHom.toMonoidHom : (M \u2192*\u2080 N) \u2192 M \u2192* N)", "start": [1221, 1], "end": [1223, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.toZeroHom_injective", "code": "theorem MonoidWithZeroHom.toZeroHom_injective [MulZeroOneClass M] [MulZeroOneClass N] :\n    Function.Injective (MonoidWithZeroHom.toZeroHom : (M \u2192*\u2080 N) \u2192 ZeroHom M N)", "start": [1228, 1], "end": [1230, 82], "kind": "commanddeclaration"}, {"full_name": "OneHom.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.comp_id [One M] [One N] (f : OneHom M N) : f.comp (OneHom.id M) = f", "start": [1233, 1], "end": [1235, 26], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.comp_id [Mul M] [Mul N] (f : M \u2192\u2099* N) : f.comp (MulHom.id M) = f", "start": [1239, 1], "end": [1241, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_id", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.comp_id [MulOneClass M] [MulOneClass N] (f : M \u2192* N) :\n    f.comp (MonoidHom.id M) = f", "start": [1245, 1], "end": [1247, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.comp_id", "code": "@[simp]\ntheorem MonoidWithZeroHom.comp_id [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    f.comp (MonoidWithZeroHom.id M) = f", "start": [1251, 1], "end": [1253, 78], "kind": "commanddeclaration"}, {"full_name": "OneHom.id_comp", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.id_comp [One M] [One N] (f : OneHom M N) : (OneHom.id N).comp f = f", "start": [1256, 1], "end": [1258, 26], "kind": "commanddeclaration"}, {"full_name": "MulHom.id_comp", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.id_comp [Mul M] [Mul N] (f : M \u2192\u2099* N) : (MulHom.id N).comp f = f", "start": [1262, 1], "end": [1264, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.id_comp", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.id_comp [MulOneClass M] [MulOneClass N] (f : M \u2192* N) :\n    (MonoidHom.id N).comp f = f", "start": [1268, 1], "end": [1270, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.id_comp", "code": "@[simp]\ntheorem MonoidWithZeroHom.id_comp [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\n    (MonoidWithZeroHom.id N).comp f = f", "start": [1274, 1], "end": [1276, 78], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_pow", "code": "@[to_additive]\nprotected theorem MonoidHom.map_pow [Monoid M] [Monoid N] (f : M \u2192* N) (a : M) (n : \u2115) :\n    f (a ^ n) = f a ^ n", "start": [1279, 1], "end": [1281, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_zpow'", "code": "@[to_additive]\nprotected theorem MonoidHom.map_zpow' [DivInvMonoid M] [DivInvMonoid N] (f : M \u2192* N)\n    (hf : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) (a : M) (n : \u2124) :\n    f (a ^ n) = f a ^ n", "start": [1285, 1], "end": [1288, 46], "kind": "commanddeclaration"}, {"full_name": "Monoid.End", "code": "protected def End := M \u2192* M", "start": [1298, 1], "end": [1299, 28], "kind": "commanddeclaration"}, {"full_name": "Monoid.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : Monoid.End M) : M \u2192 M) = id", "start": [1317, 1], "end": [1318, 59], "kind": "commanddeclaration"}, {"full_name": "Monoid.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g) : ((f * g : Monoid.End M) : M \u2192 M) = f \u2218 g", "start": [1321, 1], "end": [1322, 72], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End", "code": "protected def End := A \u2192+ A", "start": [1331, 1], "end": [1332, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.monoid", "code": "instance monoid : Monoid (AddMonoid.End A) where\n  mul := AddMonoidHom.comp\n  one := AddMonoidHom.id A\n  mul_assoc _ _ _ := AddMonoidHom.comp_assoc _ _ _\n  mul_one := AddMonoidHom.comp_id\n  one_mul := AddMonoidHom.id_comp", "start": [1337, 1], "end": [1342, 34], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : AddMonoid.End A) : A \u2192 A) = id", "start": [1350, 1], "end": [1351, 62], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g) : ((f * g : AddMonoid.End A) : A \u2192 A) = f \u2218 g", "start": [1354, 1], "end": [1355, 75], "kind": "commanddeclaration"}, {"full_name": "OneHom.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.one_apply [One M] [One N] (x : M) : (1 : OneHom M N) x = 1", "start": [1376, 1], "end": [1377, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.one_apply [MulOneClass M] [MulOneClass N] (x : M) : (1 : M \u2192* N) x = 1", "start": [1381, 1], "end": [1382, 96], "kind": "commanddeclaration"}, {"full_name": "OneHom.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.one_comp [One M] [One N] [One P] (f : OneHom M N) :\n    (1 : OneHom N P).comp f = 1", "start": [1386, 1], "end": [1388, 39], "kind": "commanddeclaration"}, {"full_name": "OneHom.comp_one", "code": "@[to_additive (attr := simp)]\ntheorem OneHom.comp_one [One M] [One N] [One P] (f : OneHom N P) : f.comp (1 : OneHom M N) = 1", "start": [1392, 1], "end": [1395, 85], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem one_comp [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : M \u2192* N) :\n    (1 : N \u2192* P).comp f = 1", "start": [1415, 1], "end": [1417, 35], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_one", "code": "@[to_additive (attr := simp)]\ntheorem comp_one [MulOneClass M] [MulOneClass N] [MulOneClass P] (f : N \u2192* P) :\n    f.comp (1 : M \u2192* N) = 1", "start": [1421, 1], "end": [1425, 64], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_inv", "code": "@[to_additive \"Additive group homomorphisms preserve negation.\"]\nprotected theorem map_inv [Group \u03b1] [DivisionMonoid \u03b2] (f : \u03b1 \u2192* \u03b2) (a : \u03b1) : f a\u207b\u00b9 = (f a)\u207b\u00b9", "start": [1429, 1], "end": [1432, 14], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_zpow", "code": "@[to_additive \"Additive group homomorphisms preserve integer scaling.\"]\nprotected theorem map_zpow [Group \u03b1] [DivisionMonoid \u03b2] (f : \u03b1 \u2192* \u03b2) (g : \u03b1) (n : \u2124) :\n    f (g ^ n) = f g ^ n", "start": [1436, 1], "end": [1439, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_div", "code": "@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_div [Group \u03b1] [DivisionMonoid \u03b2] (f : \u03b1 \u2192* \u03b2) (g h : \u03b1) :\n    f (g / h) = f g / f h", "start": [1443, 1], "end": [1446, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mul_inv", "code": "@[to_additive \"Additive group homomorphisms preserve subtraction.\"]\nprotected theorem map_mul_inv [Group \u03b1] [DivisionMonoid \u03b2] (f : \u03b1 \u2192* \u03b2) (g h : \u03b1) :\n    f (g * h\u207b\u00b9) = f g * (f h)\u207b\u00b9", "start": [1450, 1], "end": [1453, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finite/Defs.lean", "imports": ["Mathlib/Logic/Equiv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finite", "code": "class inductive Finite (\u03b1 : Sort*) : Prop\n  | intro {n : \u2115} : \u03b1 \u2243 Fin n \u2192 Finite _", "start": [52, 1], "end": [59, 41], "kind": "commanddeclaration"}, {"full_name": "finite_iff_exists_equiv_fin", "code": "theorem finite_iff_exists_equiv_fin {\u03b1 : Sort*} : Finite \u03b1 \u2194 \u2203 n, Nonempty (\u03b1 \u2243 Fin n)", "start": [62, 1], "end": [63, 45], "kind": "commanddeclaration"}, {"full_name": "Finite.exists_equiv_fin", "code": "theorem Finite.exists_equiv_fin (\u03b1 : Sort*) [h : Finite \u03b1] : \u2203 n : \u2115, Nonempty (\u03b1 \u2243 Fin n)", "start": [66, 1], "end": [67, 35], "kind": "commanddeclaration"}, {"full_name": "Finite.of_equiv", "code": "theorem Finite.of_equiv (\u03b1 : Sort*) [h : Finite \u03b1] (f : \u03b1 \u2243 \u03b2) : Finite \u03b2", "start": [70, 1], "end": [72, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.finite_iff", "code": "theorem Equiv.finite_iff (f : \u03b1 \u2243 \u03b2) : Finite \u03b1 \u2194 Finite \u03b2", "start": [75, 1], "end": [76, 68], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.finite_iff", "code": "theorem Function.Bijective.finite_iff {f : \u03b1 \u2192 \u03b2} (h : Bijective f) : Finite \u03b1 \u2194 Finite \u03b2", "start": [79, 1], "end": [80, 37], "kind": "commanddeclaration"}, {"full_name": "Finite.ofBijective", "code": "theorem Finite.ofBijective [Finite \u03b1] {f : \u03b1 \u2192 \u03b2} (h : Bijective f) : Finite \u03b2", "start": [83, 1], "end": [84, 22], "kind": "commanddeclaration"}, {"full_name": "Infinite", "code": "class Infinite (\u03b1 : Sort*) : Prop where\n  \n  not_finite : \u00acFinite \u03b1", "start": [93, 1], "end": [97, 25], "kind": "commanddeclaration"}, {"full_name": "not_finite_iff_infinite", "code": "@[simp]\ntheorem not_finite_iff_infinite : \u00acFinite \u03b1 \u2194 Infinite \u03b1", "start": [100, 1], "end": [102, 30], "kind": "commanddeclaration"}, {"full_name": "not_infinite_iff_finite", "code": "@[simp]\ntheorem not_infinite_iff_finite : \u00acInfinite \u03b1 \u2194 Finite \u03b1", "start": [105, 1], "end": [107, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.infinite_iff", "code": "theorem Equiv.infinite_iff (e : \u03b1 \u2243 \u03b2) : Infinite \u03b1 \u2194 Infinite \u03b2", "start": [110, 1], "end": [111, 87], "kind": "commanddeclaration"}, {"full_name": "finite_or_infinite", "code": "theorem finite_or_infinite (\u03b1 : Sort*) : Finite \u03b1 \u2228 Infinite \u03b1", "start": [120, 1], "end": [121, 50], "kind": "commanddeclaration"}, {"full_name": "not_finite", "code": "theorem not_finite (\u03b1 : Sort*) [Infinite \u03b1] [Finite \u03b1] : False", "start": [124, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "Finite.false", "code": "protected theorem Finite.false [Infinite \u03b1] (_ : Finite \u03b1) : False", "start": [129, 1], "end": [130, 15], "kind": "commanddeclaration"}, {"full_name": "Infinite.false", "code": "protected theorem Infinite.false [Finite \u03b1] (_ : Infinite \u03b1) : False", "start": [133, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "Finite.of_not_infinite", "code": "alias \u27e8Finite.of_not_infinite, Finite.not_infinite\u27e9 := not_infinite_iff_finite", "start": [137, 1], "end": [137, 79], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finite.not_infinite", "code": "alias \u27e8Finite.of_not_infinite, Finite.not_infinite\u27e9 := not_infinite_iff_finite", "start": [137, 1], "end": [137, 79], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Algebra/Group/Semiconj/Defs.lean", "imports": ["Mathlib/Tactic/Cases.lean", "Mathlib/Algebra/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy", "code": "@[to_additive AddSemiconjBy \"`x` is additive semiconjugate to `y` by `a` if `a + x = y + a`\"]\ndef SemiconjBy [Mul M] (a x y : M) : Prop :=\n  a * x = y * a", "start": [34, 1], "end": [37, 16], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.eq", "code": "@[to_additive \"Equality behind `AddSemiconjBy a x y`; useful for rewriting.\"]\nprotected theorem eq [Mul S] {a x y : S} (h : SemiconjBy a x y) : a * x = y * a", "start": [43, 1], "end": [46, 4], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.mul_right", "code": "@[to_additive (attr := simp) \"If `a` semiconjugates `x` to `y` and `x'` to `y'`,\nthen it semiconjugates `x + x'` to `y + y'`.\"]\ntheorem mul_right (h : SemiconjBy a x y) (h' : SemiconjBy a x' y') :\n    SemiconjBy a (x * x') (y * y')", "start": [54, 1], "end": [62, 54], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.mul_left", "code": "@[to_additive \"If `b` semiconjugates `x` to `y` and `a` semiconjugates `y` to `z`, then `a + b`\nsemiconjugates `x` to `z`.\"]\ntheorem mul_left (ha : SemiconjBy a y z) (hb : SemiconjBy b x y) : SemiconjBy (a * b) x z", "start": [66, 1], "end": [72, 54], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.transitive", "code": "@[to_additive \"The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on an additive\nsemigroup is transitive.\"]\nprotected theorem transitive : Transitive fun a b : S \u21a6 \u2203 c, SemiconjBy c a b", "start": [76, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.one_right", "code": "@[to_additive (attr := simp) \"Any element semiconjugates `0` to `0`.\"]\ntheorem one_right (a : M) : SemiconjBy a 1 1", "start": [91, 1], "end": [93, 85], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.one_left", "code": "@[to_additive (attr := simp) \"Zero semiconjugates any element to itself.\"]\ntheorem one_left (x : M) : SemiconjBy 1 x x", "start": [97, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.reflexive", "code": "@[to_additive \"The relation \u201cthere exists an element that semiconjugates `a` to `b`\u201d on an additive\nmonoid (or, more generally, on an `AddZeroClass` type) is reflexive.\"]\nprotected theorem reflexive : Reflexive fun a b : M \u21a6 \u2203 c, SemiconjBy c a b", "start": [104, 1], "end": [109, 25], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.pow_right", "code": "@[to_additive (attr := simp)]\ntheorem pow_right {a x y : M} (h : SemiconjBy a x y) (n : \u2115) : SemiconjBy a (x ^ n) (y ^ n)", "start": [119, 1], "end": [125, 25], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.conj_mk", "code": "@[to_additive \"`a` semiconjugates `x` to `a + x + -a`.\"]\ntheorem conj_mk (a x : G) : SemiconjBy a x (a * x * a\u207b\u00b9)", "start": [135, 1], "end": [138, 59], "kind": "commanddeclaration"}, {"full_name": "semiconjBy_iff_eq", "code": "@[to_additive (attr := simp) addSemiconjBy_iff_eq]\ntheorem semiconjBy_iff_eq [CancelCommMonoid M] {a x y : M} : SemiconjBy a x y \u2194 x = y", "start": [146, 1], "end": [148, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Meta/DiscrTree.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/DiscrTree.lean", "Mathlib/Lean/Expr/Traverse.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.DiscrTree.insertIfSpecific", "code": "def insertIfSpecific [BEq \u03b1] (d : DiscrTree \u03b1 s)\n    (keys : Array (DiscrTree.Key s)) (v : \u03b1) : DiscrTree \u03b1 s :=\n  if keys == #[Key.star] || keys == #[Key.const `Eq 3, Key.star, Key.star, Key.star] then\n    d\n  else\n    d.insertCore keys v", "start": [17, 1], "end": [26, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.getSubexpressionMatches", "code": "partial def getSubexpressionMatches (d : DiscrTree \u03b1 s) (e : Expr) : MetaM (Array \u03b1) := do\n  match e with\n  | .bvar _ => return #[]\n  | .forallE _ _ _ _ => forallTelescope e (fun args body => do\n      args.foldlM (fun acc arg => do\n          pure <| acc ++ (\u2190 d.getSubexpressionMatches (\u2190 inferType arg)))\n        (\u2190 d.getSubexpressionMatches body).reverse)\n  | .lam _ _ _ _\n  | .letE _ _ _ _ _ => lambdaLetTelescope e (fun args body => do\n      args.foldlM (fun acc arg => do\n          pure <| acc ++ (\u2190 d.getSubexpressionMatches (\u2190 inferType arg)))\n        (\u2190 d.getSubexpressionMatches body).reverse)\n  | _ =>\n    e.foldlM (fun a f => do pure <| a ++ (\u2190 d.getSubexpressionMatches f)) (\u2190 d.getMatch e).reverse", "start": [28, 1], "end": [52, 99], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Ctxt", "code": "private inductive Ctxt {\u03b1 \u03b2 s}\n  | empty : Ctxt\n  | ctxt : Array (Key s \u00d7 Trie \u03b2 s) \u2192 Array \u03b2 \u2192 Array (Key s \u00d7 Trie \u03b1 s) \u2192 Key s \u2192 Ctxt \u2192 Ctxt", "start": [57, 1], "end": [60, 95], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.Trie.mapArrays", "code": "partial def Trie.mapArrays (t : Trie \u03b1 s) (f : Array \u03b1 \u2192 Array \u03b2) : Trie \u03b2 s :=\n  let .node vs0 cs0 := t\n  go (.mkEmpty cs0.size) (f vs0) cs0.reverse Ctxt.empty\nwhere\n  \n  go cs vs todo ps :=\n    if todo.isEmpty then\n      let c := .node vs cs\n      match ps with\n      | .empty => c\n      | .ctxt cs' vs' todo k ps => go (cs'.push (k, c)) vs' todo ps\n    else\n      let (k, .node vs' cs') := todo.back\n      go (.mkEmpty cs'.size) (f vs') cs'.reverse (.ctxt cs vs todo.pop k ps)", "start": [62, 1], "end": [77, 77], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.DiscrTree.mapArrays", "code": "def mapArrays (d : DiscrTree \u03b1 s) (f : Array \u03b1 \u2192 Array \u03b2) : DiscrTree \u03b2 s :=\n  { root := d.root.map (fun t => t.mapArrays f) }", "start": [79, 1], "end": [81, 50], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/SortLocalDecls.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.SortLocalDecls.Context", "code": "structure Context where\n  localDecls : NameMap LocalDecl := {}", "start": [14, 1], "end": [15, 39], "kind": "commanddeclaration"}, {"full_name": "Qq.SortLocalDecls.State", "code": "structure State where\n  visited : NameSet := {}\n  result  : Array LocalDecl := #[]", "start": [17, 1], "end": [19, 35], "kind": "commanddeclaration"}, {"full_name": "Qq.SortLocalDecls.M", "code": "abbrev M := ReaderT Context $ StateRefT State MetaM", "start": [21, 1], "end": [21, 52], "kind": "commanddeclaration"}, {"full_name": "Qq.SortLocalDecls.visitExpr", "code": "partial def visitExpr (e : Expr) : M Unit := do\n    match e with\n    | .proj _ _ e    => visitExpr e\n    | .forallE _ d b _ => visitExpr d; visitExpr b\n    | .lam _ d b _     => visitExpr d; visitExpr b\n    | .letE _ t v b _  => visitExpr t; visitExpr v; visitExpr b\n    | .app f a       => visitExpr f; visitExpr a\n    | .mdata _ b     => visitExpr b\n    | .mvar _        => let v \u2190 instantiateMVars e; unless v.isMVar do visitExpr v\n    | .fvar fvarId   => if let some localDecl := (\u2190 read).localDecls.find? fvarId.name then visitLocalDecl localDecl\n    | _              => return ()", "start": [24, 3], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "Qq.SortLocalDecls.visitLocalDecl", "code": "partial def visitLocalDecl (localDecl : LocalDecl) : M Unit := do\n    unless (\u2190 get).visited.contains localDecl.fvarId.name do\n      modify fun s => { s with visited := s.visited.insert localDecl.fvarId.name }\n      visitExpr localDecl.type\n      if let some val := localDecl.value? then\n        visitExpr val\n      modify fun s => { s with result := s.result.push localDecl }", "start": [36, 3], "end": [42, 67], "kind": "commanddeclaration"}, {"full_name": "Qq.sortLocalDecls", "code": "def sortLocalDecls (localDecls : Array LocalDecl) : MetaM (Array LocalDecl) :=\n  let aux : M (Array LocalDecl) := do localDecls.forM visitLocalDecl; return (\u2190 get).result\n  aux.run { localDecls := localDecls.foldl (init := {}) fun s d => s.insert d.fvarId.name d } |>.run' {}", "start": [48, 1], "end": [50, 105], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/ForLean/Do.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Term.mkIdBindFor", "code": "def mkIdBindFor (type : Expr) : TermElabM ExtractMonadResult := do\n  let u \u2190 getDecLevel type\n  let id        := Lean.mkConst ``Id [u]\n  pure { m := id, returnType := type, expectedType := mkApp id type }", "start": [11, 1], "end": [14, 70], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Term.extractBind", "code": "partial def extractBind (expectedType? : Option Expr) : TermElabM ExtractMonadResult := do\n  match expectedType? with\n  | none => throwError \"invalid 'do' notation, expected type is not available\"\n  | some expectedType =>\n    let extractStep? (type : Expr) : MetaM (Option ExtractMonadResult) := do\n      match type with\n      | .app m returnType =>\n        return some { m, returnType, expectedType }\n      | _ =>\n        return none\n    let rec extract? (type : Expr) : MetaM (Option ExtractMonadResult) := do\n      match (\u2190 extractStep? type) with\n      | some r => return r\n      | none =>\n        let typeNew \u2190 whnfCore type\n        if typeNew != type then\n          extract? typeNew\n        else\n          if typeNew.getAppFn.isMVar then throwError \"invalid 'do' notation, expected type is not available\"\n          match (\u2190 unfoldDefinition? typeNew) with\n          | some typeNew => extract? typeNew\n          | none => return none\n    match (\u2190 extract? expectedType) with\n    | some r => return r\n    | none   => mkIdBindFor expectedType", "start": [16, 1], "end": [40, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/DeriveToExpr.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/ToLevel.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Deriving.ToExpr.mkToExprHeader", "code": "def mkToExprHeader (indVal : InductiveVal) : TermElabM Header := do\n  let header \u2190 mkHeader ``ToExpr 1 indVal\n  return header", "start": [30, 1], "end": [34, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkAppNTerm", "code": "def mkAppNTerm (f : Term) (args : Array Term) : MetaM Term :=\n  args.foldlM (fun a b => `(Expr.app $a $b)) f", "start": [36, 1], "end": [39, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkToExprBody", "code": "def mkToExprBody (header : Header) (indVal : InductiveVal) (auxFunName : Name) :\n    TermElabM Term := do\n  let discrs \u2190 mkDiscrs header indVal\n  let alts \u2190 mkAlts\n  `(match $[$discrs],* with $alts:matchAlt*)\nwhere\n  \n  mkAlts : TermElabM (Array (TSyntax ``matchAlt)) := do\n    let mut alts := #[]\n    for ctorName in indVal.ctors do\n      let ctorInfo \u2190 getConstInfoCtor ctorName\n      let alt \u2190 forallTelescopeReducing ctorInfo.type fun xs _ => do\n        let mut patterns := #[]\n        for _ in [:indVal.numIndices] do\n          patterns := patterns.push (\u2190 `(_))\n        let mut ctorArgs := #[]\n        let mut rhsArgs : Array Term := #[]\n        let mkArg (x : Expr) (a : Term) : TermElabM Term := do\n          if (\u2190 inferType x).isAppOf indVal.name then\n            `($(mkIdent auxFunName) $a)\n          else if \u2190 Meta.isType x then\n            `(toTypeExpr $a)\n          else\n            `(toExpr $a)\n        for i in [:ctorInfo.numParams] do\n          let a := mkIdent header.argNames[i]!\n          ctorArgs := ctorArgs.push (\u2190 `(_))\n          rhsArgs := rhsArgs.push <| \u2190 mkArg xs[i]! a\n        for i in [:ctorInfo.numFields] do\n          let a := mkIdent (\u2190 mkFreshUserName `a)\n          ctorArgs := ctorArgs.push a\n          rhsArgs := rhsArgs.push <| \u2190 mkArg xs[ctorInfo.numParams + i]! a\n        patterns := patterns.push (\u2190 `(@$(mkIdent ctorName):ident $ctorArgs:term*))\n        let levels \u2190 indVal.levelParams.toArray.mapM (fun u => `(toLevel.{$(mkIdent u)}))\n        let rhs : Term \u2190\n          mkAppNTerm (\u2190 `(Expr.const $(quote ctorInfo.name) [$levels,*])) rhsArgs\n        `(matchAltExpr| | $[$patterns:term],* => $rhs)\n      alts := alts.push alt\n    return alts", "start": [41, 1], "end": [87, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkToTypeExpr", "code": "def mkToTypeExpr (argNames : Array Name) (indVal : InductiveVal) : TermElabM Term := do\n  let levels \u2190 indVal.levelParams.toArray.mapM (fun u => `(toLevel.{$(mkIdent u)}))\n  forallTelescopeReducing indVal.type fun xs _ => do\n    let mut args : Array Term := #[]\n    for i in [:xs.size] do\n      let x := xs[i]!\n      let a := mkIdent argNames[i]!\n      if \u2190 Meta.isType x then\n        args := args.push <| \u2190 `(toTypeExpr $a)\n      else\n        args := args.push <| \u2190 `(toExpr $a)\n    mkAppNTerm (\u2190 `((Expr.const $(quote indVal.name) [$levels,*]))) args", "start": [89, 1], "end": [102, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkLocalInstanceLetDecls", "code": "def mkLocalInstanceLetDecls (ctx : Deriving.Context) (argNames : Array Name) :\n    TermElabM (Array (TSyntax ``Parser.Term.letDecl)) := do\n  let mut letDecls := #[]\n  for i in [:ctx.typeInfos.size] do\n    let indVal       := ctx.typeInfos[i]!\n    let auxFunName   := ctx.auxFunNames[i]!\n    let currArgNames \u2190 mkInductArgNames indVal\n    let numParams    := indVal.numParams\n    let currIndices  := currArgNames[numParams:]\n    let binders      \u2190 mkImplicitBinders currIndices\n    let argNamesNew  := argNames[:numParams] ++ currIndices\n    let indType      \u2190 mkInductiveApp indVal argNamesNew\n    let instName     \u2190 mkFreshUserName `localinst\n    let toTypeExpr   \u2190 mkToTypeExpr argNames indVal\n    let letDecl      \u2190 `(Parser.Term.letDecl| $(mkIdent instName):ident $binders:implicitBinder* :\n                            ToExpr $indType :=\n                          { toExpr := $(mkIdent auxFunName), toTypeExpr := $toTypeExpr })\n    letDecls := letDecls.push letDecl\n  return letDecls", "start": [104, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.fixIndType", "code": "def fixIndType (indVal : InductiveVal) (t : Term) : TermElabM Term :=\n  match t with\n  | `(@$f $args*) =>\n    let levels := indVal.levelParams.toArray.map mkIdent\n    `(@$f.{$levels,*} $args*)\n  | _ => throwError \"(internal error) expecting output of `mkInductiveApp`\"", "start": [134, 1], "end": [140, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkToLevelBinders", "code": "def mkToLevelBinders (indVal : InductiveVal) : TermElabM (TSyntaxArray ``instBinderF) := do\n  indVal.levelParams.toArray.mapM (fun u => `(instBinderF| [ToLevel.{$(mkIdent u)}]))", "start": [142, 1], "end": [144, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkAuxFunction", "code": "def mkAuxFunction (ctx : Deriving.Context) (i : Nat) : TermElabM Command := do\n  let auxFunName := ctx.auxFunNames[i]!\n  let indVal     := ctx.typeInfos[i]!\n  let header     \u2190 mkToExprHeader indVal\n  let mut body   \u2190 mkToExprBody header indVal auxFunName\n  if ctx.usePartial then\n    let letDecls \u2190 mkLocalInstanceLetDecls ctx header.argNames\n    body \u2190 mkLet letDecls body\n  let addLevels binder :=\n    match binder with\n    | `(bracketedBinderF| ($a : $ty)) => do `(bracketedBinderF| ($a : $(\u2190 fixIndType indVal ty)))\n    | _ => throwError \"(internal error) expecting inst binder\"\n  let binders := header.binders.pop\n    ++ (\u2190 mkToLevelBinders indVal)\n    ++ #[\u2190 addLevels header.binders.back]\n  let levels := indVal.levelParams.toArray.map mkIdent\n  if ctx.usePartial then\n    `(private partial def $(mkIdent auxFunName):ident.{$levels,*} $binders:bracketedBinder* :\n        Expr := $body:term)\n  else\n    `(private def $(mkIdent auxFunName):ident.{$levels,*} $binders:bracketedBinder* :\n        Expr := $body:term)", "start": [147, 1], "end": [177, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.$", "code": "private partial def $(mkIdent auxFunName):ident.{$levels,*} $binders:bracketedBinder* :\n        Expr := $body:term", "start": [173, 7], "end": [174, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.$", "code": "private def $(mkIdent auxFunName):ident.{$levels,*} $binders:bracketedBinder* :\n        Expr := $body:term", "start": [176, 7], "end": [177, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkMutualBlock", "code": "def mkMutualBlock (ctx : Deriving.Context) : TermElabM Syntax := do\n  let mut auxDefs := #[]\n  for i in [:ctx.typeInfos.size] do\n    auxDefs := auxDefs.push (\u2190 mkAuxFunction ctx i)\n  `(mutual $auxDefs:command* end)", "start": [179, 1], "end": [185, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkInstanceCmds", "code": "def mkInstanceCmds (ctx : Deriving.Context) (typeNames : Array Name) :\n    TermElabM (Array Command) := do\n  let mut instances := #[]\n  for i in [:ctx.typeInfos.size] do\n    let indVal       := ctx.typeInfos[i]!\n    if typeNames.contains indVal.name then\n      let auxFunName   := ctx.auxFunNames[i]!\n      let argNames     \u2190 mkInductArgNames indVal\n      let binders      \u2190 mkImplicitBinders argNames\n      let binders      := binders ++ (\u2190 mkInstImplicitBinders ``ToExpr indVal argNames)\n      let binders      := binders ++ (\u2190 mkToLevelBinders indVal)\n      let indType      \u2190 fixIndType indVal (\u2190 mkInductiveApp indVal argNames)\n      let toTypeExpr   \u2190 mkToTypeExpr argNames indVal\n      let levels       := indVal.levelParams.toArray.map mkIdent\n      let instCmd \u2190 `(instance $binders:implicitBinder* : ToExpr $indType where\n                        toExpr := $(mkIdent auxFunName).{$levels,*}\n                        toTypeExpr := $toTypeExpr)\n      instances := instances.push instCmd\n  return instances", "start": [188, 1], "end": [208, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkToExprInstanceCmds", "code": "def mkToExprInstanceCmds (declNames : Array Name) : TermElabM (Array Syntax) := do\n  let ctx \u2190 mkContext \"toExpr\" declNames[0]!\n  let cmds := #[\u2190 mkMutualBlock ctx] ++ (\u2190 mkInstanceCmds ctx declNames)\n  trace[Elab.Deriving.toExpr] \"\\n{cmds}\"\n  return cmds", "start": [210, 1], "end": [215, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Deriving.ToExpr.mkToExprInstanceHandler", "code": "def mkToExprInstanceHandler (declNames : Array Name) : CommandElabM Bool := do\n  if (\u2190 declNames.allM isInductive) && declNames.size > 0 then\n    let cmds \u2190 liftTermElabM <| mkToExprInstanceCmds declNames\n    cmds.forM elabCommand\n    return true\n  else\n    return false", "start": [217, 1], "end": [224, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/WhatsNew.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/OpenPrivate.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.WhatsNew.throwUnknownId", "code": "private def throwUnknownId (id : Name) : CommandElabM Unit :=\n  throwError \"unknown identifier '{mkConst id}'\"", "start": [24, 1], "end": [25, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.levelParamsToMessageData", "code": "private def levelParamsToMessageData (levelParams : List Name) : MessageData :=\n  match levelParams with\n  | []    => \"\"\n  | u::us => Id.run <| do\n    let mut m := m!\".\\{{u}\"\n    for u in us do\n      m := m ++ \", \" ++ toMessageData u\n    return m ++ \"}\"", "start": [27, 1], "end": [34, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.mkHeader", "code": "private def mkHeader (kind : String) (id : Name) (levelParams : List Name) (type : Expr)\n    (safety : DefinitionSafety) : CoreM MessageData := do\n  let m : MessageData :=\n    match safety with\n    | DefinitionSafety.unsafe  => \"unsafe \"\n    | DefinitionSafety.partial => \"partial \"\n    | DefinitionSafety.safe    => \"\"\n  let m := if isProtected (\u2190 getEnv) id then m ++ \"protected \" else m\n  let (m, id) := match privateToUserName? id with\n    | some id => (m ++ \"private \", id)\n    | none    => (m, id)\n  let m := m ++ kind ++ \" \" ++ id ++ levelParamsToMessageData levelParams ++ \" : \" ++ type\n  pure m", "start": [36, 1], "end": [48, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.mkHeader'", "code": "private def mkHeader' (kind : String) (id : Name) (levelParams : List Name) (type : Expr)\n    (isUnsafe : Bool) : CoreM MessageData :=\n  mkHeader kind id levelParams type\n    (if isUnsafe then DefinitionSafety.unsafe else DefinitionSafety.safe)", "start": [50, 1], "end": [53, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.printDefLike", "code": "private def printDefLike (kind : String) (id : Name) (levelParams : List Name) (type : Expr)\n    (value : Expr) (safety := DefinitionSafety.safe) : CoreM MessageData :=\n  return (\u2190 mkHeader kind id levelParams type safety) ++ \" :=\" ++ Format.line ++ value", "start": [55, 1], "end": [57, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.printInduct", "code": "private def printInduct (id : Name) (levelParams : List Name) (_numParams : Nat) (_numIndices : Nat)\n    (type : Expr) (ctors : List Name) (isUnsafe : Bool) : CoreM MessageData := do\n  let mut m \u2190 mkHeader' \"inductive\" id levelParams type isUnsafe\n  m := m ++ Format.line ++ \"constructors:\"\n  for ctor in ctors do\n    let cinfo \u2190 getConstInfo ctor\n    m := m ++ Format.line ++ ctor ++ \" : \" ++ cinfo.type\n  pure m", "start": [59, 1], "end": [66, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.printIdCore", "code": "private def printIdCore (id : Name) : ConstantInfo \u2192 CoreM MessageData\n  | ConstantInfo.axiomInfo { levelParams := us, type := t, isUnsafe := u, .. } =>\n    mkHeader' \"axiom\" id us t u\n  | ConstantInfo.defnInfo { levelParams := us, type := t, value := v, safety := s, .. } =>\n    printDefLike \"def\" id us t v s\n  | ConstantInfo.thmInfo { levelParams := us, type := t, value := v, .. } =>\n    printDefLike \"theorem\" id us t v\n  | ConstantInfo.opaqueInfo { levelParams := us, type := t, isUnsafe := u, .. } =>\n    mkHeader' \"constant\" id us t u\n  | ConstantInfo.quotInfo { levelParams := us, type := t, .. } =>\n    mkHeader' \"Quotient primitive\" id us t false\n  | ConstantInfo.ctorInfo { levelParams := us, type := t, isUnsafe := u, .. } =>\n    mkHeader' \"constructor\" id us t u\n  | ConstantInfo.recInfo { levelParams := us, type := t, isUnsafe := u, .. } =>\n    mkHeader' \"recursor\" id us t u\n  | ConstantInfo.inductInfo\n      { levelParams := us, numParams, numIndices, type := t, ctors, isUnsafe := u, .. } =>\n    printInduct id us numParams numIndices t ctors u", "start": [68, 1], "end": [85, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.diffExtension", "code": "def diffExtension (old new : Environment)\n    (ext : PersistentEnvExtension EnvExtensionEntry EnvExtensionEntry EnvExtensionState) :\n    CoreM (Option MessageData) := unsafe do\n  let oldSt := ext.toEnvExtension.getState old\n  let newSt := ext.toEnvExtension.getState new\n  if ptrAddrUnsafe oldSt == ptrAddrUnsafe newSt then return none\n  let oldEntries := ext.exportEntriesFn oldSt.state\n  let newEntries := ext.exportEntriesFn newSt.state\n  pure m!\"", "start": [87, 1], "end": [95, 92], "kind": "commanddeclaration"}, {"full_name": "Mathlib.WhatsNew.whatsNew", "code": "def whatsNew (old new : Environment) : CoreM MessageData := do\n  let mut diffs := #[]\n\n  for (c, i) in new.constants.map\u2082.toList do\n    unless old.constants.map\u2082.contains c do\n      diffs := diffs.push (\u2190 printIdCore c i)\n\n  for ext in \u2190 persistentEnvExtensionsRef.get do\n    if let some diff := \u2190 diffExtension old new ext then\n      diffs := diffs.push diff\n\n  if diffs.isEmpty then return \"no new constants\"\n\n  pure $ MessageData.joinSep diffs.toList \"\\n\\n\"", "start": [97, 1], "end": [110, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/Algebra/Group/WithOne/Defs.lean", "Mathlib/Algebra/Order/ZeroLEOne.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearOrderedCommMonoidWithZero", "code": "class LinearOrderedCommMonoidWithZero (\u03b1 : Type*) extends LinearOrderedCommMonoid \u03b1,\n  CommMonoidWithZero \u03b1 where\n  \n  zero_le_one : (0 : \u03b1) \u2264 1", "start": [21, 1], "end": [25, 28], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommMonoidWithZero.toZeroLeOneClass", "code": "instance (priority := 100) LinearOrderedCommMonoidWithZero.toZeroLeOneClass\n    [LinearOrderedCommMonoidWithZero \u03b1] : ZeroLEOneClass \u03b1 :=\n  { \u2039LinearOrderedCommMonoidWithZero \u03b1\u203a with }", "start": [28, 1], "end": [30, 47], "kind": "commanddeclaration"}, {"full_name": "canonicallyOrderedAddCommMonoid.toZeroLeOneClass", "code": "instance (priority := 100) canonicallyOrderedAddCommMonoid.toZeroLeOneClass\n    [CanonicallyOrderedAddCommMonoid \u03b1] [One \u03b1] : ZeroLEOneClass \u03b1 :=\n  \u27e8zero_le 1\u27e9", "start": [33, 1], "end": [35, 14], "kind": "commanddeclaration"}, {"full_name": "WithZero.preorder", "code": "instance preorder [Preorder \u03b1] : Preorder (WithZero \u03b1) :=\n  WithBot.preorder", "start": [40, 1], "end": [41, 19], "kind": "commanddeclaration"}, {"full_name": "WithZero.partialOrder", "code": "instance partialOrder [PartialOrder \u03b1] : PartialOrder (WithZero \u03b1) :=\n  WithBot.partialOrder", "start": [43, 1], "end": [44, 23], "kind": "commanddeclaration"}, {"full_name": "WithZero.orderBot", "code": "instance orderBot [Preorder \u03b1] : OrderBot (WithZero \u03b1) :=\n  WithBot.orderBot", "start": [46, 1], "end": [47, 19], "kind": "commanddeclaration"}, {"full_name": "WithZero.zero_le", "code": "theorem zero_le [Preorder \u03b1] (a : WithZero \u03b1) : 0 \u2264 a", "start": [49, 1], "end": [50, 9], "kind": "commanddeclaration"}, {"full_name": "WithZero.zero_lt_coe", "code": "theorem zero_lt_coe [Preorder \u03b1] (a : \u03b1) : (0 : WithZero \u03b1) < a", "start": [53, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "WithZero.zero_eq_bot", "code": "theorem zero_eq_bot [Preorder \u03b1] : (0 : WithZero \u03b1) = \u22a5", "start": [57, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe [Preorder \u03b1] {a b : \u03b1} : (a : WithZero \u03b1) < b \u2194 a < b", "start": [61, 1], "end": [63, 21], "kind": "commanddeclaration"}, {"full_name": "WithZero.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe [Preorder \u03b1] {a b : \u03b1} : (a : WithZero \u03b1) \u2264 b \u2194 a \u2264 b", "start": [66, 1], "end": [68, 21], "kind": "commanddeclaration"}, {"full_name": "WithZero.lattice", "code": "instance lattice [Lattice \u03b1] : Lattice (WithZero \u03b1) :=\n  WithBot.lattice", "start": [71, 1], "end": [72, 18], "kind": "commanddeclaration"}, {"full_name": "WithZero.linearOrder", "code": "instance linearOrder [LinearOrder \u03b1] : LinearOrder (WithZero \u03b1) :=\n  WithBot.linearOrder", "start": [74, 1], "end": [75, 22], "kind": "commanddeclaration"}, {"full_name": "WithZero.covariantClass_mul_le", "code": "instance covariantClass_mul_le [Mul \u03b1] [Preorder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] :\n    CovariantClass (WithZero \u03b1) (WithZero \u03b1) (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) := by\n  refine \u27e8fun a b c hbc => ?_\u27e9\n  induction a using WithZero.recZeroCoe; \u00b7 exact zero_le _\n  induction b using WithZero.recZeroCoe; \u00b7 exact zero_le _\n  rcases WithBot.coe_le_iff.1 hbc with \u27e8c, rfl, hbc'\u27e9\n  refine le_trans ?_ (le_of_eq <| coe_mul)\n  rw [\u2190 coe_mul, coe_le_coe]\n  exact mul_le_mul_left' hbc' _", "start": [77, 1], "end": [89, 32], "kind": "commanddeclaration"}, {"full_name": "WithZero.le_max_iff", "code": "nonrec theorem le_max_iff [LinearOrder \u03b1] {a b c : \u03b1} :\n    (a : WithZero \u03b1) \u2264 max (b : WithZero \u03b1) c \u2194 a \u2264 max b c", "start": [93, 1], "end": [95, 46], "kind": "commanddeclaration"}, {"full_name": "WithZero.min_le_iff", "code": "nonrec theorem min_le_iff [LinearOrder \u03b1] {a b c : \u03b1} :\n    min (a : WithZero \u03b1) b \u2264 c \u2194 min a b \u2264 c", "start": [99, 1], "end": [101, 46], "kind": "commanddeclaration"}, {"full_name": "WithZero.orderedCommMonoid", "code": "instance orderedCommMonoid [OrderedCommMonoid \u03b1] : OrderedCommMonoid (WithZero \u03b1) :=\n  { WithZero.commMonoidWithZero.toCommMonoid, WithZero.partialOrder with\n    mul_le_mul_left := fun _ _ => mul_le_mul_left' }", "start": [104, 1], "end": [106, 53], "kind": "commanddeclaration"}, {"full_name": "WithZero.covariantClass_add_le", "code": "protected theorem covariantClass_add_le [AddZeroClass \u03b1] [Preorder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (h : \u2200 a : \u03b1, 0 \u2264 a) :\n    CovariantClass (WithZero \u03b1) (WithZero \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)", "start": [111, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "WithZero.orderedAddCommMonoid", "code": "@[reducible]\nprotected def orderedAddCommMonoid [OrderedAddCommMonoid \u03b1] (zero_le : \u2200 a : \u03b1, 0 \u2264 a) :\n    OrderedAddCommMonoid (WithZero \u03b1) :=\n  { WithZero.partialOrder, WithZero.addCommMonoid with\n    add_le_add_left := @add_le_add_left _ _ _ (WithZero.covariantClass_add_le zero_le).. }", "start": [136, 1], "end": [143, 91], "kind": "commanddeclaration"}, {"full_name": "WithZero.existsAddOfLE", "code": "instance existsAddOfLE [Add \u03b1] [Preorder \u03b1] [ExistsAddOfLE \u03b1] :\n    ExistsAddOfLE (WithZero \u03b1) :=\n  \u27e8fun {a b} => by\n    induction a using WithZero.cases_on\n    \u00b7 exact fun _ => \u27e8b, (zero_add b).symm\u27e9\n    induction b using WithZero.cases_on\n    \u00b7 exact fun h => (WithBot.not_coe_le_bot _ h).elim\n    intro h\n    obtain \u27e8c, rfl\u27e9 := exists_add_of_le (WithZero.coe_le_coe.1 h)\n    exact \u27e8c, rfl\u27e9\u27e9", "start": [148, 1], "end": [157, 20], "kind": "commanddeclaration"}, {"full_name": "WithZero.canonicallyOrderedAddCommMonoid", "code": "instance canonicallyOrderedAddCommMonoid [CanonicallyOrderedAddCommMonoid \u03b1] :\n    CanonicallyOrderedAddCommMonoid (WithZero \u03b1) :=\n  { WithZero.orderBot,\n    WithZero.orderedAddCommMonoid _root_.zero_le,\n    WithZero.existsAddOfLE with\n    le_self_add := fun a b => by\n      induction a using WithZero.cases_on\n      \u00b7 exact bot_le\n      induction b using WithZero.cases_on\n      \u00b7 exact le_rfl\n      \u00b7 exact WithZero.coe_le_coe.2 le_self_add }", "start": [161, 1], "end": [172, 50], "kind": "commanddeclaration"}, {"full_name": "WithZero.canonicallyLinearOrderedAddCommMonoid", "code": "instance canonicallyLinearOrderedAddCommMonoid (\u03b1 : Type*)\n    [CanonicallyLinearOrderedAddCommMonoid \u03b1] :\n    CanonicallyLinearOrderedAddCommMonoid (WithZero \u03b1) :=\n  { WithZero.canonicallyOrderedAddCommMonoid, WithZero.linearOrder with }", "start": [179, 1], "end": [182, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/NatCast.lean", "imports": ["Mathlib/Algebra/Order/ZeroLEOne.lean", "Mathlib/Data/Nat/Cast/Defs.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "lt_add_one", "code": "lemma lt_add_one [One \u03b1] [AddZeroClass \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]\n    [NeZero (1 : \u03b1)] [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7<\u00b7)] (a : \u03b1) : a < a + 1 :=\n  lt_add_of_pos_right _ zero_lt_one", "start": [20, 1], "end": [22, 36], "kind": "mathlibtacticlemma"}, {"full_name": "lt_one_add", "code": "lemma lt_one_add [One \u03b1] [AddZeroClass \u03b1] [PartialOrder \u03b1] [ZeroLEOneClass \u03b1]\n    [NeZero (1 : \u03b1)] [CovariantClass \u03b1 \u03b1 (swap (\u00b7+\u00b7)) (\u00b7<\u00b7)] (a : \u03b1) : a < 1 + a :=\n  lt_add_of_pos_left _ zero_lt_one", "start": [25, 1], "end": [27, 35], "kind": "mathlibtacticlemma"}, {"full_name": "zero_le_two", "code": "lemma zero_le_two [Preorder \u03b1] [ZeroLEOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)] :\n    (0 : \u03b1) \u2264 2 := by\n  rw [\u2190 one_add_one_eq_two]\n  exact add_nonneg zero_le_one zero_le_one", "start": [32, 1], "end": [35, 43], "kind": "mathlibtacticlemma"}, {"full_name": "zero_le_three", "code": "lemma zero_le_three [Preorder \u03b1] [ZeroLEOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)] :\n    (0 : \u03b1) \u2264 3 := by\n  rw [\u2190 two_add_one_eq_three]\n  exact add_nonneg zero_le_two zero_le_one", "start": [38, 1], "end": [41, 43], "kind": "mathlibtacticlemma"}, {"full_name": "zero_le_four", "code": "lemma zero_le_four [Preorder \u03b1] [ZeroLEOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)] :\n    (0 : \u03b1) \u2264 4 := by\n  rw [\u2190 three_add_one_eq_four]\n  exact add_nonneg zero_le_three zero_le_one", "start": [44, 1], "end": [47, 45], "kind": "mathlibtacticlemma"}, {"full_name": "one_le_two", "code": "lemma one_le_two [LE \u03b1] [ZeroLEOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7\u2264\u00b7)] :\n    (1 : \u03b1) \u2264 2 :=\n  calc (1 : \u03b1) = 1 + 0 := (add_zero 1).symm\n     _ \u2264 1 + 1 := add_le_add_left zero_le_one _\n     _ = 2 := one_add_one_eq_two", "start": [50, 1], "end": [54, 33], "kind": "mathlibtacticlemma"}, {"full_name": "one_le_two'", "code": "lemma one_le_two' [LE \u03b1] [ZeroLEOneClass \u03b1] [CovariantClass \u03b1 \u03b1 (swap (\u00b7+\u00b7)) (\u00b7\u2264\u00b7)] :\n    (1 : \u03b1) \u2264 2 :=\n  calc (1 : \u03b1) = 0 + 1 := (zero_add 1).symm\n     _ \u2264 1 + 1 := add_le_add_right zero_le_one _\n     _ = 2 := one_add_one_eq_two", "start": [57, 1], "end": [61, 33], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_two", "code": "@[simp] lemma zero_lt_two : (0 : \u03b1) < 2 := zero_lt_one.trans_le one_le_two", "start": [70, 1], "end": [71, 75], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_three", "code": "@[simp] lemma zero_lt_three : (0 : \u03b1) < 3 := by\n  rw [\u2190 two_add_one_eq_three]\n  exact lt_add_of_lt_of_nonneg zero_lt_two zero_le_one", "start": [74, 1], "end": [77, 55], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_four", "code": "@[simp] lemma zero_lt_four : (0 : \u03b1) < 4 := by\n  rw [\u2190 three_add_one_eq_four]\n  exact lt_add_of_lt_of_nonneg zero_lt_three zero_le_one", "start": [80, 1], "end": [83, 57], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_two'", "code": "lemma zero_lt_two' : (0 : \u03b1) < 2 := zero_lt_two", "start": [88, 1], "end": [89, 48], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_three'", "code": "lemma zero_lt_three' : (0 : \u03b1) < 3 := zero_lt_three", "start": [92, 1], "end": [93, 52], "kind": "mathlibtacticlemma"}, {"full_name": "zero_lt_four'", "code": "lemma zero_lt_four' : (0 : \u03b1) < 4 := zero_lt_four", "start": [96, 1], "end": [97, 50], "kind": "mathlibtacticlemma"}, {"full_name": "ZeroLEOneClass.neZero.two", "code": "instance ZeroLEOneClass.neZero.two : NeZero (2 : \u03b1) := \u27e8zero_lt_two.ne'\u27e9", "start": [100, 1], "end": [100, 73], "kind": "commanddeclaration"}, {"full_name": "ZeroLEOneClass.neZero.three", "code": "instance ZeroLEOneClass.neZero.three : NeZero (3 : \u03b1) := \u27e8zero_lt_three.ne'\u27e9", "start": [101, 1], "end": [101, 77], "kind": "commanddeclaration"}, {"full_name": "ZeroLEOneClass.neZero.four", "code": "instance ZeroLEOneClass.neZero.four : NeZero (4 : \u03b1) := \u27e8zero_lt_four.ne'\u27e9", "start": [102, 1], "end": [102, 75], "kind": "commanddeclaration"}, {"full_name": "one_lt_two", "code": "lemma one_lt_two [CovariantClass \u03b1 \u03b1 (\u00b7+\u00b7) (\u00b7<\u00b7)] : (1 : \u03b1) < 2 := by\n  rw [\u2190 one_add_one_eq_two]\n  exact lt_add_one _", "start": [106, 1], "end": [108, 21], "kind": "mathlibtacticlemma"}, {"full_name": "two_pos", "code": "alias two_pos := zero_lt_two", "start": [113, 1], "end": [113, 29], "kind": "stdtacticaliasalias"}, {"full_name": "three_pos", "code": "alias three_pos := zero_lt_three", "start": [116, 1], "end": [116, 33], "kind": "stdtacticaliasalias"}, {"full_name": "four_pos", "code": "alias four_pos := zero_lt_four", "start": [119, 1], "end": [119, 31], "kind": "stdtacticaliasalias"}]}
{"path": "Mathlib/Algebra/GroupWithZero/NeZero.lean", "imports": ["Mathlib/Algebra/NeZero.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NeZero.one", "code": "instance NeZero.one : NeZero (1 : M\u2080) := \u27e8by\n  intro h\n  rcases exists_pair_ne M\u2080 with \u27e8x, y, hx\u27e9\n  apply hx\n  calc\n    x = 1 * x := by rw [one_mul]\n    _ = 0 := by rw [h, zero_mul]\n    _ = 1 * y := by rw [h, zero_mul]\n    _ = y := by rw [one_mul]\u27e9", "start": [24, 1], "end": [33, 30], "kind": "commanddeclaration"}, {"full_name": "pullback_nonzero", "code": "theorem pullback_nonzero [Zero M\u2080'] [One M\u2080'] (f : M\u2080' \u2192 M\u2080) (zero : f 0 = 0) (one : f 1 = 1) :\n    Nontrivial M\u2080'", "start": [36, 1], "end": [41, 24], "kind": "commanddeclaration"}, {"full_name": "inv_ne_zero", "code": "theorem inv_ne_zero (h : a \u2260 0) : a\u207b\u00b9 \u2260 0", "start": [49, 1], "end": [51, 52], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel", "code": "@[simp]\ntheorem inv_mul_cancel (h : a \u2260 0) : a\u207b\u00b9 * a = 1", "start": [54, 1], "end": [59, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/Lemmas.lean", "imports": ["Mathlib/Algebra/CovariantAndContravariant.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PosMulMono", "code": "abbrev PosMulMono : Prop :=\n  CovariantClass \u03b1\u22650 \u03b1 (fun x y => x * y) (\u00b7 \u2264 \u00b7)", "start": [72, 1], "end": [75, 50], "kind": "commanddeclaration"}, {"full_name": "MulPosMono", "code": "abbrev MulPosMono : Prop :=\n  CovariantClass \u03b1\u22650 \u03b1 (fun x y => y * x) (\u00b7 \u2264 \u00b7)", "start": [78, 1], "end": [81, 50], "kind": "commanddeclaration"}, {"full_name": "PosMulStrictMono", "code": "abbrev PosMulStrictMono : Prop :=\n  CovariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 < \u00b7)", "start": [84, 1], "end": [87, 50], "kind": "commanddeclaration"}, {"full_name": "MulPosStrictMono", "code": "abbrev MulPosStrictMono : Prop :=\n  CovariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 < \u00b7)", "start": [90, 1], "end": [93, 50], "kind": "commanddeclaration"}, {"full_name": "PosMulReflectLT", "code": "abbrev PosMulReflectLT : Prop :=\n  ContravariantClass \u03b1\u22650 \u03b1 (fun x y => x * y) (\u00b7 < \u00b7)", "start": [96, 1], "end": [99, 54], "kind": "commanddeclaration"}, {"full_name": "MulPosReflectLT", "code": "abbrev MulPosReflectLT : Prop :=\n  ContravariantClass \u03b1\u22650 \u03b1 (fun x y => y * x) (\u00b7 < \u00b7)", "start": [102, 1], "end": [105, 54], "kind": "commanddeclaration"}, {"full_name": "PosMulMonoRev", "code": "abbrev PosMulMonoRev : Prop :=\n  ContravariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 \u2264 \u00b7)", "start": [108, 1], "end": [111, 54], "kind": "commanddeclaration"}, {"full_name": "MulPosMonoRev", "code": "abbrev MulPosMonoRev : Prop :=\n  ContravariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 \u2264 \u00b7)", "start": [114, 1], "end": [117, 54], "kind": "commanddeclaration"}, {"full_name": "PosMulMono.to_covariantClass_pos_mul_le", "code": "instance PosMulMono.to_covariantClass_pos_mul_le [PosMulMono \u03b1] :\n    CovariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a _ _ bc => @CovariantClass.elim \u03b1\u22650 \u03b1 (fun x y => x * y) (\u00b7 \u2264 \u00b7) _ \u27e8_, a.2.le\u27e9 _ _ bc\u27e9", "start": [132, 1], "end": [134, 95], "kind": "commanddeclaration"}, {"full_name": "MulPosMono.to_covariantClass_pos_mul_le", "code": "instance MulPosMono.to_covariantClass_pos_mul_le [MulPosMono \u03b1] :\n    CovariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a _ _ bc => @CovariantClass.elim \u03b1\u22650 \u03b1 (fun x y => y * x) (\u00b7 \u2264 \u00b7) _ \u27e8_, a.2.le\u27e9 _ _ bc\u27e9", "start": [137, 1], "end": [139, 95], "kind": "commanddeclaration"}, {"full_name": "PosMulReflectLT.to_contravariantClass_pos_mul_lt", "code": "instance PosMulReflectLT.to_contravariantClass_pos_mul_lt [PosMulReflectLT \u03b1] :\n    ContravariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 < \u00b7) :=\n  \u27e8fun a _ _ bc => @ContravariantClass.elim \u03b1\u22650 \u03b1 (fun x y => x * y) (\u00b7 < \u00b7) _ \u27e8_, a.2.le\u27e9 _ _ bc\u27e9", "start": [142, 1], "end": [144, 99], "kind": "commanddeclaration"}, {"full_name": "MulPosReflectLT.to_contravariantClass_pos_mul_lt", "code": "instance MulPosReflectLT.to_contravariantClass_pos_mul_lt [MulPosReflectLT \u03b1] :\n    ContravariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 < \u00b7) :=\n  \u27e8fun a _ _ bc => @ContravariantClass.elim \u03b1\u22650 \u03b1 (fun x y => y * x) (\u00b7 < \u00b7) _ \u27e8_, a.2.le\u27e9 _ _ bc\u27e9", "start": [147, 1], "end": [149, 99], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonneg_left", "code": "theorem mul_le_mul_of_nonneg_left [PosMulMono \u03b1] (h : b \u2264 c) (a0 : 0 \u2264 a) : a * b \u2264 a * c", "start": [152, 1], "end": [153, 72], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonneg_right", "code": "theorem mul_le_mul_of_nonneg_right [MulPosMono \u03b1] (h : b \u2264 c) (a0 : 0 \u2264 a) : b * a \u2264 c * a", "start": [156, 1], "end": [157, 72], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_pos_left", "code": "theorem mul_lt_mul_of_pos_left [PosMulStrictMono \u03b1] (bc : b < c) (a0 : 0 < a) : a * b < a * c", "start": [160, 1], "end": [161, 73], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_pos_right", "code": "theorem mul_lt_mul_of_pos_right [MulPosStrictMono \u03b1] (bc : b < c) (a0 : 0 < a) : b * a < c * a", "start": [164, 1], "end": [165, 73], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_left", "code": "theorem lt_of_mul_lt_mul_left [PosMulReflectLT \u03b1] (h : a * b < a * c) (a0 : 0 \u2264 a) : b < c", "start": [168, 1], "end": [169, 76], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_right", "code": "theorem lt_of_mul_lt_mul_right [MulPosReflectLT \u03b1] (h : b * a < c * a) (a0 : 0 \u2264 a) : b < c", "start": [172, 1], "end": [173, 76], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_mul_left", "code": "theorem le_of_mul_le_mul_left [PosMulMonoRev \u03b1] (bc : a * b \u2264 a * c) (a0 : 0 < a) : b \u2264 c", "start": [176, 1], "end": [177, 77], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_mul_right", "code": "theorem le_of_mul_le_mul_right [MulPosMonoRev \u03b1] (bc : b * a \u2264 c * a) (a0 : 0 < a) : b \u2264 c", "start": [180, 1], "end": [181, 77], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_of_nonneg_left", "code": "alias lt_of_mul_lt_mul_of_nonneg_left := lt_of_mul_lt_mul_left", "start": [184, 1], "end": [184, 63], "kind": "stdtacticaliasalias"}, {"full_name": "lt_of_mul_lt_mul_of_nonneg_right", "code": "alias lt_of_mul_lt_mul_of_nonneg_right := lt_of_mul_lt_mul_right", "start": [187, 1], "end": [187, 65], "kind": "stdtacticaliasalias"}, {"full_name": "le_of_mul_le_mul_of_pos_left", "code": "alias le_of_mul_le_mul_of_pos_left := le_of_mul_le_mul_left", "start": [190, 1], "end": [190, 60], "kind": "stdtacticaliasalias"}, {"full_name": "le_of_mul_le_mul_of_pos_right", "code": "alias le_of_mul_le_mul_of_pos_right := le_of_mul_le_mul_right", "start": [193, 1], "end": [193, 62], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_mul_left", "code": "@[simp]\ntheorem mul_lt_mul_left [PosMulStrictMono \u03b1] [PosMulReflectLT \u03b1] (a0 : 0 < a) :\n    a * b < a * c \u2194 b < c", "start": [196, 1], "end": [199, 64], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_right", "code": "@[simp]\ntheorem mul_lt_mul_right [MulPosStrictMono \u03b1] [MulPosReflectLT \u03b1] (a0 : 0 < a) :\n    b * a < c * a \u2194 b < c", "start": [202, 1], "end": [205, 64], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_left", "code": "@[simp]\ntheorem mul_le_mul_left [PosMulMono \u03b1] [PosMulMonoRev \u03b1] (a0 : 0 < a) : a * b \u2264 a * c \u2194 b \u2264 c", "start": [208, 1], "end": [210, 64], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_right", "code": "@[simp]\ntheorem mul_le_mul_right [MulPosMono \u03b1] [MulPosMonoRev \u03b1] (a0 : 0 < a) : b * a \u2264 c * a \u2194 b \u2264 c", "start": [213, 1], "end": [215, 64], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_pos_of_nonneg", "code": "theorem mul_lt_mul_of_pos_of_nonneg [PosMulStrictMono \u03b1] [MulPosMono \u03b1] (h\u2081 : a \u2264 b) (h\u2082 : c < d)\n    (a0 : 0 < a) (d0 : 0 \u2264 d) : a * c < b * d", "start": [218, 1], "end": [220, 77], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_le_of_le'", "code": "theorem mul_lt_mul_of_le_of_le' [PosMulStrictMono \u03b1] [MulPosMono \u03b1] (h\u2081 : a \u2264 b) (h\u2082 : c < d)\n    (b0 : 0 < b) (c0 : 0 \u2264 c) : a * c < b * d", "start": [223, 1], "end": [225, 77], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_nonneg_of_pos", "code": "theorem mul_lt_mul_of_nonneg_of_pos [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (h\u2081 : a < b) (h\u2082 : c \u2264 d)\n    (a0 : 0 \u2264 a) (d0 : 0 < d) : a * c < b * d", "start": [228, 1], "end": [230, 77], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_le_of_lt'", "code": "theorem mul_lt_mul_of_le_of_lt' [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (h\u2081 : a < b) (h\u2082 : c \u2264 d)\n    (b0 : 0 \u2264 b) (c0 : 0 < c) : a * c < b * d", "start": [233, 1], "end": [235, 77], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_pos_of_pos", "code": "theorem mul_lt_mul_of_pos_of_pos [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1] (h\u2081 : a < b) (h\u2082 : c < d)\n    (a0 : 0 < a) (d0 : 0 < d) : a * c < b * d", "start": [238, 1], "end": [240, 71], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_lt_of_lt'", "code": "theorem mul_lt_mul_of_lt_of_lt' [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1] (h\u2081 : a < b) (h\u2082 : c < d)\n    (b0 : 0 < b) (c0 : 0 < c) : a * c < b * d", "start": [243, 1], "end": [245, 71], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_mul_lt_of_nonneg_left", "code": "theorem mul_lt_of_mul_lt_of_nonneg_left [PosMulMono \u03b1] (h : a * b < c) (hdb : d \u2264 b) (ha : 0 \u2264 a) :\n    a * d < c", "start": [248, 1], "end": [250, 48], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_mul_of_nonneg_left", "code": "theorem lt_mul_of_lt_mul_of_nonneg_left [PosMulMono \u03b1] (h : a < b * c) (hcd : c \u2264 d) (hb : 0 \u2264 b) :\n    a < b * d", "start": [253, 1], "end": [255, 49], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_mul_lt_of_nonneg_right", "code": "theorem mul_lt_of_mul_lt_of_nonneg_right [MulPosMono \u03b1] (h : a * b < c) (hda : d \u2264 a) (hb : 0 \u2264 b) :\n    d * b < c", "start": [258, 1], "end": [260, 49], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_mul_of_nonneg_right", "code": "theorem lt_mul_of_lt_mul_of_nonneg_right [MulPosMono \u03b1] (h : a < b * c) (hbd : b \u2264 d) (hc : 0 \u2264 c) :\n    a < d * c", "start": [263, 1], "end": [265, 50], "kind": "commanddeclaration"}, {"full_name": "PosMulStrictMono.toPosMulMonoRev", "code": "instance (priority := 100) PosMulStrictMono.toPosMulMonoRev [PosMulStrictMono \u03b1] :\n    PosMulMonoRev \u03b1 :=\n  \u27e8(covariant_lt_iff_contravariant_le _ _ _).1 CovariantClass.elim\u27e9", "start": [275, 1], "end": [277, 68], "kind": "commanddeclaration"}, {"full_name": "MulPosStrictMono.toMulPosMonoRev", "code": "instance (priority := 100) MulPosStrictMono.toMulPosMonoRev [MulPosStrictMono \u03b1] :\n    MulPosMonoRev \u03b1 :=\n  \u27e8(covariant_lt_iff_contravariant_le _ _ _).1 CovariantClass.elim\u27e9", "start": [280, 1], "end": [282, 68], "kind": "commanddeclaration"}, {"full_name": "PosMulMonoRev.toPosMulStrictMono", "code": "theorem PosMulMonoRev.toPosMulStrictMono [PosMulMonoRev \u03b1] : PosMulStrictMono \u03b1", "start": [284, 1], "end": [285, 72], "kind": "commanddeclaration"}, {"full_name": "MulPosMonoRev.toMulPosStrictMono", "code": "theorem MulPosMonoRev.toMulPosStrictMono [MulPosMonoRev \u03b1] : MulPosStrictMono \u03b1", "start": [288, 1], "end": [289, 72], "kind": "commanddeclaration"}, {"full_name": "posMulStrictMono_iff_posMulMonoRev", "code": "theorem posMulStrictMono_iff_posMulMonoRev : PosMulStrictMono \u03b1 \u2194 PosMulMonoRev \u03b1", "start": [292, 1], "end": [293, 89], "kind": "commanddeclaration"}, {"full_name": "mulPosStrictMono_iff_mulPosMonoRev", "code": "theorem mulPosStrictMono_iff_mulPosMonoRev : MulPosStrictMono \u03b1 \u2194 MulPosMonoRev \u03b1", "start": [296, 1], "end": [297, 89], "kind": "commanddeclaration"}, {"full_name": "PosMulReflectLT.toPosMulMono", "code": "theorem PosMulReflectLT.toPosMulMono [PosMulReflectLT \u03b1] : PosMulMono \u03b1", "start": [300, 1], "end": [301, 72], "kind": "commanddeclaration"}, {"full_name": "MulPosReflectLT.toMulPosMono", "code": "theorem MulPosReflectLT.toMulPosMono [MulPosReflectLT \u03b1] : MulPosMono \u03b1", "start": [304, 1], "end": [305, 72], "kind": "commanddeclaration"}, {"full_name": "PosMulMono.toPosMulReflectLT", "code": "theorem PosMulMono.toPosMulReflectLT [PosMulMono \u03b1] : PosMulReflectLT \u03b1", "start": [308, 1], "end": [309, 68], "kind": "commanddeclaration"}, {"full_name": "MulPosMono.toMulPosReflectLT", "code": "theorem MulPosMono.toMulPosReflectLT [MulPosMono \u03b1] : MulPosReflectLT \u03b1", "start": [312, 1], "end": [313, 68], "kind": "commanddeclaration"}, {"full_name": "posMulMono_iff_posMulReflectLT", "code": "theorem posMulMono_iff_posMulReflectLT : PosMulMono \u03b1 \u2194 PosMulReflectLT \u03b1", "start": [320, 1], "end": [321, 81], "kind": "commanddeclaration"}, {"full_name": "mulPosMono_iff_mulPosReflectLT", "code": "theorem mulPosMono_iff_mulPosReflectLT : MulPosMono \u03b1 \u2194 MulPosReflectLT \u03b1", "start": [324, 1], "end": [325, 81], "kind": "commanddeclaration"}, {"full_name": "Left.mul_pos", "code": "theorem Left.mul_pos [PosMulStrictMono \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < a * b", "start": [340, 1], "end": [342, 59], "kind": "commanddeclaration"}, {"full_name": "mul_pos", "code": "alias mul_pos := Left.mul_pos", "start": [345, 1], "end": [345, 30], "kind": "stdtacticaliasalias"}, {"full_name": "mul_neg_of_pos_of_neg", "code": "theorem mul_neg_of_pos_of_neg [PosMulStrictMono \u03b1] (ha : 0 < a) (hb : b < 0) : a * b < 0", "start": [348, 1], "end": [349, 59], "kind": "commanddeclaration"}, {"full_name": "zero_lt_mul_left", "code": "@[simp]\ntheorem zero_lt_mul_left [PosMulStrictMono \u03b1] [PosMulReflectLT \u03b1] (h : 0 < c) :\n    0 < c * b \u2194 0 < b", "start": [352, 1], "end": [356, 7], "kind": "commanddeclaration"}, {"full_name": "Right.mul_pos", "code": "theorem Right.mul_pos [MulPosStrictMono \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < a * b", "start": [359, 1], "end": [361, 60], "kind": "commanddeclaration"}, {"full_name": "mul_neg_of_neg_of_pos", "code": "theorem mul_neg_of_neg_of_pos [MulPosStrictMono \u03b1] (ha : a < 0) (hb : 0 < b) : a * b < 0", "start": [364, 1], "end": [365, 60], "kind": "commanddeclaration"}, {"full_name": "zero_lt_mul_right", "code": "@[simp]\ntheorem zero_lt_mul_right [MulPosStrictMono \u03b1] [MulPosReflectLT \u03b1] (h : 0 < c) :\n    0 < b * c \u2194 0 < b", "start": [368, 1], "end": [372, 7], "kind": "commanddeclaration"}, {"full_name": "Left.mul_nonneg", "code": "theorem Left.mul_nonneg [PosMulMono \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b", "start": [375, 1], "end": [377, 62], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg", "code": "alias mul_nonneg := Left.mul_nonneg", "start": [380, 1], "end": [380, 36], "kind": "stdtacticaliasalias"}, {"full_name": "mul_nonpos_of_nonneg_of_nonpos", "code": "theorem mul_nonpos_of_nonneg_of_nonpos [PosMulMono \u03b1] (ha : 0 \u2264 a) (hb : b \u2264 0) : a * b \u2264 0", "start": [383, 1], "end": [384, 62], "kind": "commanddeclaration"}, {"full_name": "Right.mul_nonneg", "code": "theorem Right.mul_nonneg [MulPosMono \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b", "start": [387, 1], "end": [389, 63], "kind": "commanddeclaration"}, {"full_name": "mul_nonpos_of_nonpos_of_nonneg", "code": "theorem mul_nonpos_of_nonpos_of_nonneg [MulPosMono \u03b1] (ha : a \u2264 0) (hb : 0 \u2264 b) : a * b \u2264 0", "start": [392, 1], "end": [393, 63], "kind": "commanddeclaration"}, {"full_name": "pos_of_mul_pos_right", "code": "theorem pos_of_mul_pos_right [PosMulReflectLT \u03b1] (h : 0 < a * b) (ha : 0 \u2264 a) : 0 < b", "start": [396, 1], "end": [397, 67], "kind": "commanddeclaration"}, {"full_name": "pos_of_mul_pos_left", "code": "theorem pos_of_mul_pos_left [MulPosReflectLT \u03b1] (h : 0 < a * b) (hb : 0 \u2264 b) : 0 < a", "start": [400, 1], "end": [401, 68], "kind": "commanddeclaration"}, {"full_name": "pos_iff_pos_of_mul_pos", "code": "theorem pos_iff_pos_of_mul_pos [PosMulReflectLT \u03b1] [MulPosReflectLT \u03b1] (hab : 0 < a * b) :\n    0 < a \u2194 0 < b", "start": [404, 1], "end": [406, 76], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_le_of_le", "code": "theorem mul_le_mul_of_le_of_le [PosMulMono \u03b1] [MulPosMono \u03b1] (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) (a0 : 0 \u2264 a)\n    (d0 : 0 \u2264 d) : a * c \u2264 b * d", "start": [409, 1], "end": [411, 78], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul", "code": "theorem mul_le_mul [PosMulMono \u03b1] [MulPosMono \u03b1] (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) (c0 : 0 \u2264 c)\n    (b0 : 0 \u2264 b) : a * c \u2264 b * d", "start": [414, 1], "end": [416, 78], "kind": "commanddeclaration"}, {"full_name": "mul_self_le_mul_self", "code": "theorem mul_self_le_mul_self [PosMulMono \u03b1] [MulPosMono \u03b1] (ha : 0 \u2264 a) (hab : a \u2264 b) :\n    a * a \u2264 b * b", "start": [419, 1], "end": [421, 40], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_mul_le_of_nonneg_left", "code": "theorem mul_le_of_mul_le_of_nonneg_left [PosMulMono \u03b1] (h : a * b \u2264 c) (hle : d \u2264 b)\n    (a0 : 0 \u2264 a) : a * d \u2264 c", "start": [424, 1], "end": [426, 45], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_mul_of_nonneg_left", "code": "theorem le_mul_of_le_mul_of_nonneg_left [PosMulMono \u03b1] (h : a \u2264 b * c) (hle : c \u2264 d)\n    (b0 : 0 \u2264 b) : a \u2264 b * d", "start": [429, 1], "end": [431, 45], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_mul_le_of_nonneg_right", "code": "theorem mul_le_of_mul_le_of_nonneg_right [MulPosMono \u03b1] (h : a * b \u2264 c) (hle : d \u2264 a)\n    (b0 : 0 \u2264 b) : d * b \u2264 c", "start": [434, 1], "end": [436, 46], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_mul_of_nonneg_right", "code": "theorem le_mul_of_le_mul_of_nonneg_right [MulPosMono \u03b1] (h : a \u2264 b * c) (hle : b \u2264 d)\n    (c0 : 0 \u2264 c) : a \u2264 d * c", "start": [439, 1], "end": [441, 46], "kind": "commanddeclaration"}, {"full_name": "posMulMono_iff_covariant_pos", "code": "theorem posMulMono_iff_covariant_pos :\n    PosMulMono \u03b1 \u2194 CovariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 \u2264 \u00b7)", "start": [450, 1], "end": [456, 87], "kind": "commanddeclaration"}, {"full_name": "mulPosMono_iff_covariant_pos", "code": "theorem mulPosMono_iff_covariant_pos :\n    MulPosMono \u03b1 \u2194 CovariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 \u2264 \u00b7)", "start": [459, 1], "end": [465, 87], "kind": "commanddeclaration"}, {"full_name": "posMulReflectLT_iff_contravariant_pos", "code": "theorem posMulReflectLT_iff_contravariant_pos :\n    PosMulReflectLT \u03b1 \u2194 ContravariantClass \u03b1>0 \u03b1 (fun x y => x * y) (\u00b7 < \u00b7)", "start": [468, 1], "end": [474, 91], "kind": "commanddeclaration"}, {"full_name": "mulPosReflectLT_iff_contravariant_pos", "code": "theorem mulPosReflectLT_iff_contravariant_pos :\n    MulPosReflectLT \u03b1 \u2194 ContravariantClass \u03b1>0 \u03b1 (fun x y => y * x) (\u00b7 < \u00b7)", "start": [477, 1], "end": [483, 91], "kind": "commanddeclaration"}, {"full_name": "PosMulStrictMono.toPosMulMono", "code": "instance (priority := 100) PosMulStrictMono.toPosMulMono [PosMulStrictMono \u03b1] : PosMulMono \u03b1 :=\n  posMulMono_iff_covariant_pos.2 (covariantClass_le_of_lt _ _ _)", "start": [489, 1], "end": [490, 65], "kind": "commanddeclaration"}, {"full_name": "MulPosStrictMono.toMulPosMono", "code": "instance (priority := 100) MulPosStrictMono.toMulPosMono [MulPosStrictMono \u03b1] : MulPosMono \u03b1 :=\n  mulPosMono_iff_covariant_pos.2 (covariantClass_le_of_lt _ _ _)", "start": [496, 1], "end": [497, 65], "kind": "commanddeclaration"}, {"full_name": "PosMulMonoRev.toPosMulReflectLT", "code": "instance (priority := 100) PosMulMonoRev.toPosMulReflectLT [PosMulMonoRev \u03b1] :\n    PosMulReflectLT \u03b1 :=\n  posMulReflectLT_iff_contravariant_pos.2\n    \u27e8fun a b c h =>\n      (le_of_mul_le_mul_of_pos_left h.le a.2).lt_of_ne <| by\n        rintro rfl\n        simp at h\u27e9", "start": [501, 1], "end": [507, 19], "kind": "commanddeclaration"}, {"full_name": "MulPosMonoRev.toMulPosReflectLT", "code": "instance (priority := 100) MulPosMonoRev.toMulPosReflectLT [MulPosMonoRev \u03b1] :\n    MulPosReflectLT \u03b1 :=\n  mulPosReflectLT_iff_contravariant_pos.2\n    \u27e8fun a b c h =>\n      (le_of_mul_le_mul_of_pos_right h.le a.2).lt_of_ne <| by\n        rintro rfl\n        simp at h\u27e9", "start": [511, 1], "end": [517, 19], "kind": "commanddeclaration"}, {"full_name": "mul_left_cancel_iff_of_pos", "code": "theorem mul_left_cancel_iff_of_pos [PosMulMonoRev \u03b1] (a0 : 0 < a) : a * b = a * c \u2194 b = c", "start": [520, 1], "end": [522, 55], "kind": "commanddeclaration"}, {"full_name": "mul_right_cancel_iff_of_pos", "code": "theorem mul_right_cancel_iff_of_pos [MulPosMonoRev \u03b1] (b0 : 0 < b) : a * b = c * b \u2194 a = c", "start": [525, 1], "end": [527, 62], "kind": "commanddeclaration"}, {"full_name": "mul_eq_mul_iff_eq_and_eq_of_pos", "code": "theorem mul_eq_mul_iff_eq_and_eq_of_pos [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1]\n    (hab : a \u2264 b) (hcd : c \u2264 d) (a0 : 0 < a) (d0 : 0 < d) :\n    a * c = b * d \u2194 a = b \u2227 c = d", "start": [530, 1], "end": [537, 90], "kind": "commanddeclaration"}, {"full_name": "mul_eq_mul_iff_eq_and_eq_of_pos'", "code": "theorem mul_eq_mul_iff_eq_and_eq_of_pos' [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1]\n    (hab : a \u2264 b) (hcd : c \u2264 d) (b0 : 0 < b) (c0 : 0 < c) :\n    a * c = b * d \u2194 a = b \u2227 c = d", "start": [540, 1], "end": [547, 90], "kind": "commanddeclaration"}, {"full_name": "pos_and_pos_or_neg_and_neg_of_mul_pos", "code": "theorem pos_and_pos_or_neg_and_neg_of_mul_pos [PosMulMono \u03b1] [MulPosMono \u03b1] (hab : 0 < a * b) :\n    0 < a \u2227 0 < b \u2228 a < 0 \u2227 b < 0", "start": [556, 1], "end": [564, 50], "kind": "commanddeclaration"}, {"full_name": "neg_of_mul_pos_right", "code": "theorem neg_of_mul_pos_right [PosMulMono \u03b1] [MulPosMono \u03b1] (h : 0 < a * b) (ha : a \u2264 0) : b < 0", "start": [568, 1], "end": [569, 84], "kind": "commanddeclaration"}, {"full_name": "neg_of_mul_pos_left", "code": "theorem neg_of_mul_pos_left [PosMulMono \u03b1] [MulPosMono \u03b1] (h : 0 < a * b) (ha : b \u2264 0) : a < 0", "start": [572, 1], "end": [573, 84], "kind": "commanddeclaration"}, {"full_name": "neg_iff_neg_of_mul_pos", "code": "theorem neg_iff_neg_of_mul_pos [PosMulMono \u03b1] [MulPosMono \u03b1] (hab : 0 < a * b) : a < 0 \u2194 b < 0", "start": [576, 1], "end": [577, 76], "kind": "commanddeclaration"}, {"full_name": "Left.neg_of_mul_neg_left", "code": "theorem Left.neg_of_mul_neg_left [PosMulMono \u03b1] (h : a * b < 0) (h1 : 0 \u2264 a) : b < 0", "start": [580, 1], "end": [581, 66], "kind": "commanddeclaration"}, {"full_name": "Right.neg_of_mul_neg_left", "code": "theorem Right.neg_of_mul_neg_left [MulPosMono \u03b1] (h : a * b < 0) (h1 : 0 \u2264 a) : b < 0", "start": [584, 1], "end": [585, 67], "kind": "commanddeclaration"}, {"full_name": "Left.neg_of_mul_neg_right", "code": "theorem Left.neg_of_mul_neg_right [PosMulMono \u03b1] (h : a * b < 0) (h1 : 0 \u2264 b) : a < 0", "start": [588, 1], "end": [589, 66], "kind": "commanddeclaration"}, {"full_name": "Right.neg_of_mul_neg_right", "code": "theorem Right.neg_of_mul_neg_right [MulPosMono \u03b1] (h : a * b < 0) (h1 : 0 \u2264 b) : a < 0", "start": [592, 1], "end": [593, 67], "kind": "commanddeclaration"}, {"full_name": "le_mul_iff_one_le_right", "code": "@[simp]\ntheorem le_mul_iff_one_le_right [PosMulMono \u03b1] [PosMulMonoRev \u03b1] (a0 : 0 < a) : a \u2264 a * b \u2194 1 \u2264 b", "start": [612, 1], "end": [614, 51], "kind": "commanddeclaration"}, {"full_name": "lt_mul_iff_one_lt_right", "code": "@[simp]\ntheorem lt_mul_iff_one_lt_right [PosMulStrictMono \u03b1] [PosMulReflectLT \u03b1] (a0 : 0 < a) :\n    a < a * b \u2194 1 < b", "start": [617, 1], "end": [620, 51], "kind": "commanddeclaration"}, {"full_name": "mul_le_iff_le_one_right", "code": "@[simp]\ntheorem mul_le_iff_le_one_right [PosMulMono \u03b1] [PosMulMonoRev \u03b1] (a0 : 0 < a) : a * b \u2264 a \u2194 b \u2264 1", "start": [623, 1], "end": [625, 51], "kind": "commanddeclaration"}, {"full_name": "mul_lt_iff_lt_one_right", "code": "@[simp]\ntheorem mul_lt_iff_lt_one_right [PosMulStrictMono \u03b1] [PosMulReflectLT \u03b1] (a0 : 0 < a) :\n    a * b < a \u2194 b < 1", "start": [628, 1], "end": [631, 51], "kind": "commanddeclaration"}, {"full_name": "le_mul_iff_one_le_left", "code": "@[simp]\ntheorem le_mul_iff_one_le_left [MulPosMono \u03b1] [MulPosMonoRev \u03b1] (a0 : 0 < a) : a \u2264 b * a \u2194 1 \u2264 b", "start": [638, 1], "end": [640, 52], "kind": "commanddeclaration"}, {"full_name": "lt_mul_iff_one_lt_left", "code": "@[simp]\ntheorem lt_mul_iff_one_lt_left [MulPosStrictMono \u03b1] [MulPosReflectLT \u03b1] (a0 : 0 < a) :\n    a < b * a \u2194 1 < b", "start": [643, 1], "end": [646, 52], "kind": "commanddeclaration"}, {"full_name": "mul_le_iff_le_one_left", "code": "@[simp]\ntheorem mul_le_iff_le_one_left [MulPosMono \u03b1] [MulPosMonoRev \u03b1] (b0 : 0 < b) : a * b \u2264 b \u2194 a \u2264 1", "start": [649, 1], "end": [651, 52], "kind": "commanddeclaration"}, {"full_name": "mul_lt_iff_lt_one_left", "code": "@[simp]\ntheorem mul_lt_iff_lt_one_left [MulPosStrictMono \u03b1] [MulPosReflectLT \u03b1] (b0 : 0 < b) :\n    a * b < b \u2194 a < 1", "start": [654, 1], "end": [657, 52], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_left", "code": "theorem mul_le_of_le_one_left [MulPosMono \u03b1] (hb : 0 \u2264 b) (h : a \u2264 1) : a * b \u2264 b", "start": [666, 1], "end": [667, 61], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_left", "code": "theorem le_mul_of_one_le_left [MulPosMono \u03b1] (hb : 0 \u2264 b) (h : 1 \u2264 a) : b \u2264 a * b", "start": [670, 1], "end": [671, 61], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_right", "code": "theorem mul_le_of_le_one_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : b \u2264 1) : a * b \u2264 a", "start": [674, 1], "end": [675, 60], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_right", "code": "theorem le_mul_of_one_le_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : 1 \u2264 b) : a \u2264 a * b", "start": [678, 1], "end": [679, 60], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_left", "code": "theorem mul_lt_of_lt_one_left [MulPosStrictMono \u03b1] (hb : 0 < b) (h : a < 1) : a * b < b", "start": [682, 1], "end": [683, 58], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_left", "code": "theorem lt_mul_of_one_lt_left [MulPosStrictMono \u03b1] (hb : 0 < b) (h : 1 < a) : b < a * b", "start": [686, 1], "end": [687, 58], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_right", "code": "theorem mul_lt_of_lt_one_right [PosMulStrictMono \u03b1] (ha : 0 < a) (h : b < 1) : a * b < a", "start": [690, 1], "end": [691, 57], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_right", "code": "theorem lt_mul_of_one_lt_right [PosMulStrictMono \u03b1] (ha : 0 < a) (h : 1 < b) : a < a * b", "start": [694, 1], "end": [695, 57], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_of_le_one_of_nonneg", "code": "theorem mul_le_of_le_of_le_one_of_nonneg [PosMulMono \u03b1] (h : b \u2264 c) (ha : a \u2264 1) (hb : 0 \u2264 b) :\n    b * a \u2264 c", "start": [704, 1], "end": [706, 41], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_of_lt_one_of_pos", "code": "theorem mul_lt_of_le_of_lt_one_of_pos [PosMulStrictMono \u03b1] (bc : b \u2264 c) (ha : a < 1) (b0 : 0 < b) :\n    b * a < c", "start": [709, 1], "end": [711, 45], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_le_one_of_nonneg", "code": "theorem mul_lt_of_lt_of_le_one_of_nonneg [PosMulMono \u03b1] (h : b < c) (ha : a \u2264 1) (hb : 0 \u2264 b) :\n    b * a < c", "start": [714, 1], "end": [716, 44], "kind": "commanddeclaration"}, {"full_name": "Left.mul_le_one_of_le_of_le", "code": "theorem Left.mul_le_one_of_le_of_le [PosMulMono \u03b1] (ha : a \u2264 1) (hb : b \u2264 1) (a0 : 0 \u2264 a) :\n    a * b \u2264 1", "start": [719, 1], "end": [722, 44], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_of_le_of_lt_one_of_pos", "code": "theorem Left.mul_lt_of_le_of_lt_one_of_pos [PosMulStrictMono \u03b1] (ha : a \u2264 1) (hb : b < 1)\n    (a0 : 0 < a) : a * b < 1", "start": [725, 1], "end": [728, 48], "kind": "commanddeclaration"}, {"full_name": "Left.mul_lt_of_lt_of_le_one_of_nonneg", "code": "theorem Left.mul_lt_of_lt_of_le_one_of_nonneg [PosMulMono \u03b1] (ha : a < 1) (hb : b \u2264 1)\n    (a0 : 0 \u2264 a) : a * b < 1", "start": [731, 1], "end": [734, 51], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_of_le_one'", "code": "theorem mul_le_of_le_of_le_one' [PosMulMono \u03b1] [MulPosMono \u03b1] (bc : b \u2264 c) (ha : a \u2264 1) (a0 : 0 \u2264 a)\n    (c0 : 0 \u2264 c) : b * a \u2264 c", "start": [737, 1], "end": [739, 75], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_le_one'", "code": "theorem mul_lt_of_lt_of_le_one' [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (bc : b < c) (ha : a \u2264 1)\n    (a0 : 0 < a) (c0 : 0 \u2264 c) : b * a < c", "start": [742, 1], "end": [744, 75], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_of_lt_one'", "code": "theorem mul_lt_of_le_of_lt_one' [PosMulStrictMono \u03b1] [MulPosMono \u03b1] (bc : b \u2264 c) (ha : a < 1)\n    (a0 : 0 \u2264 a) (c0 : 0 < c) : b * a < c", "start": [747, 1], "end": [749, 78], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_of_lt_one_of_pos", "code": "theorem mul_lt_of_lt_of_lt_one_of_pos [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (bc : b < c) (ha : a \u2264 1)\n    (a0 : 0 < a) (c0 : 0 \u2264 c) : b * a < c", "start": [752, 1], "end": [754, 75], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_of_one_le_of_nonneg", "code": "theorem le_mul_of_le_of_one_le_of_nonneg [PosMulMono \u03b1] (h : b \u2264 c) (ha : 1 \u2264 a) (hc : 0 \u2264 c) :\n    b \u2264 c * a", "start": [760, 1], "end": [762, 42], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_le_of_one_lt_of_pos", "code": "theorem lt_mul_of_le_of_one_lt_of_pos [PosMulStrictMono \u03b1] (bc : b \u2264 c) (ha : 1 < a) (c0 : 0 < c) :\n    b < c * a", "start": [765, 1], "end": [767, 46], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_le_of_nonneg", "code": "theorem lt_mul_of_lt_of_one_le_of_nonneg [PosMulMono \u03b1] (h : b < c) (ha : 1 \u2264 a) (hc : 0 \u2264 c) :\n    b < c * a", "start": [770, 1], "end": [772, 45], "kind": "commanddeclaration"}, {"full_name": "Left.one_le_mul_of_le_of_le", "code": "theorem Left.one_le_mul_of_le_of_le [PosMulMono \u03b1] (ha : 1 \u2264 a) (hb : 1 \u2264 b) (a0 : 0 \u2264 a) :\n    1 \u2264 a * b", "start": [775, 1], "end": [778, 44], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_mul_of_le_of_lt_of_pos", "code": "theorem Left.one_lt_mul_of_le_of_lt_of_pos [PosMulStrictMono \u03b1] (ha : 1 \u2264 a) (hb : 1 < b)\n    (a0 : 0 < a) : 1 < a * b", "start": [781, 1], "end": [784, 41], "kind": "commanddeclaration"}, {"full_name": "Left.lt_mul_of_lt_of_one_le_of_nonneg", "code": "theorem Left.lt_mul_of_lt_of_one_le_of_nonneg [PosMulMono \u03b1] (ha : 1 < a) (hb : 1 \u2264 b)\n    (a0 : 0 \u2264 a) : 1 < a * b", "start": [787, 1], "end": [790, 51], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_of_one_le'", "code": "theorem le_mul_of_le_of_one_le' [PosMulMono \u03b1] [MulPosMono \u03b1] (bc : b \u2264 c) (ha : 1 \u2264 a)\n    (a0 : 0 \u2264 a) (b0 : 0 \u2264 b) : b \u2264 c * a", "start": [793, 1], "end": [795, 75], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_le_of_one_lt'", "code": "theorem lt_mul_of_le_of_one_lt' [PosMulStrictMono \u03b1] [MulPosMono \u03b1] (bc : b \u2264 c) (ha : 1 < a)\n    (a0 : 0 \u2264 a) (b0 : 0 < b) : b < c * a", "start": [798, 1], "end": [800, 78], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_le'", "code": "theorem lt_mul_of_lt_of_one_le' [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (bc : b < c) (ha : 1 \u2264 a)\n    (a0 : 0 < a) (b0 : 0 \u2264 b) : b < c * a", "start": [803, 1], "end": [805, 75], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_of_one_lt_of_pos", "code": "theorem lt_mul_of_lt_of_one_lt_of_pos [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1] (bc : b < c)\n    (ha : 1 < a) (a0 : 0 < a) (b0 : 0 < b) : b < c * a", "start": [808, 1], "end": [810, 72], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_of_le_of_nonneg", "code": "theorem mul_le_of_le_one_of_le_of_nonneg [MulPosMono \u03b1] (ha : a \u2264 1) (h : b \u2264 c) (hb : 0 \u2264 b) :\n    a * b \u2264 c", "start": [816, 1], "end": [818, 40], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_le_of_pos", "code": "theorem mul_lt_of_lt_one_of_le_of_pos [MulPosStrictMono \u03b1] (ha : a < 1) (h : b \u2264 c) (hb : 0 < b) :\n    a * b < c", "start": [821, 1], "end": [823, 43], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_one_of_lt_of_nonneg", "code": "theorem mul_lt_of_le_one_of_lt_of_nonneg [MulPosMono \u03b1] (ha : a \u2264 1) (h : b < c) (hb : 0 \u2264 b) :\n    a * b < c", "start": [826, 1], "end": [828, 43], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one_of_lt_of_le_of_pos", "code": "theorem Right.mul_lt_one_of_lt_of_le_of_pos [MulPosStrictMono \u03b1] (ha : a < 1) (hb : b \u2264 1)\n    (b0 : 0 < b) : a * b < 1", "start": [831, 1], "end": [834, 41], "kind": "commanddeclaration"}, {"full_name": "Right.mul_lt_one_of_le_of_lt_of_nonneg", "code": "theorem Right.mul_lt_one_of_le_of_lt_of_nonneg [MulPosMono \u03b1] (ha : a \u2264 1) (hb : b < 1)\n    (b0 : 0 \u2264 b) : a * b < 1", "start": [837, 1], "end": [840, 44], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_lt_of_pos", "code": "theorem mul_lt_of_lt_one_of_lt_of_pos [PosMulStrictMono \u03b1] [MulPosStrictMono \u03b1] (ha : a < 1)\n    (bc : b < c) (a0 : 0 < a) (c0 : 0 < c) : a * b < c", "start": [843, 1], "end": [845, 70], "kind": "commanddeclaration"}, {"full_name": "Right.mul_le_one_of_le_of_le", "code": "theorem Right.mul_le_one_of_le_of_le [MulPosMono \u03b1] (ha : a \u2264 1) (hb : b \u2264 1) (b0 : 0 \u2264 b) :\n    a * b \u2264 1", "start": [848, 1], "end": [851, 44], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_le_one_of_le'", "code": "theorem mul_le_of_le_one_of_le' [PosMulMono \u03b1] [MulPosMono \u03b1] (ha : a \u2264 1) (bc : b \u2264 c) (a0 : 0 \u2264 a)\n    (c0 : 0 \u2264 c) : a * b \u2264 c", "start": [854, 1], "end": [856, 73], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_lt_one_of_le'", "code": "theorem mul_lt_of_lt_one_of_le' [PosMulMono \u03b1] [MulPosStrictMono \u03b1] (ha : a < 1) (bc : b \u2264 c)\n    (a0 : 0 \u2264 a) (c0 : 0 < c) : a * b < c", "start": [859, 1], "end": [861, 76], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_le_one_of_lt'", "code": "theorem mul_lt_of_le_one_of_lt' [PosMulStrictMono \u03b1] [MulPosMono \u03b1] (ha : a \u2264 1) (bc : b < c)\n    (a0 : 0 < a) (c0 : 0 \u2264 c) : a * b < c", "start": [864, 1], "end": [866, 73], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_le_of_pos", "code": "theorem lt_mul_of_one_lt_of_le_of_pos [MulPosStrictMono \u03b1] (ha : 1 < a) (h : b \u2264 c) (hc : 0 < c) :\n    b < a * c", "start": [872, 1], "end": [874, 44], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_le_of_lt_of_nonneg", "code": "theorem lt_mul_of_one_le_of_lt_of_nonneg [MulPosMono \u03b1] (ha : 1 \u2264 a) (h : b < c) (hc : 0 \u2264 c) :\n    b < a * c", "start": [877, 1], "end": [879, 44], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_lt_of_pos", "code": "theorem lt_mul_of_one_lt_of_lt_of_pos [MulPosStrictMono \u03b1] (ha : 1 < a) (h : b < c) (hc : 0 < c) :\n    b < a * c", "start": [882, 1], "end": [884, 41], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul_of_lt_of_le_of_pos", "code": "theorem Right.one_lt_mul_of_lt_of_le_of_pos [MulPosStrictMono \u03b1] (ha : 1 < a) (hb : 1 \u2264 b)\n    (b0 : 0 < b) : 1 < a * b", "start": [887, 1], "end": [890, 41], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul_of_le_of_lt_of_nonneg", "code": "theorem Right.one_lt_mul_of_le_of_lt_of_nonneg [MulPosMono \u03b1] (ha : 1 \u2264 a) (hb : 1 < b)\n    (b0 : 0 \u2264 b) : 1 < a * b", "start": [893, 1], "end": [896, 44], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_mul_of_lt_of_lt", "code": "theorem Right.one_lt_mul_of_lt_of_lt [MulPosStrictMono \u03b1] (ha : 1 < a) (hb : 1 < b) (b0 : 0 < b) :\n    1 < a * b", "start": [899, 1], "end": [902, 41], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_one_lt_of_lt_of_nonneg", "code": "theorem lt_mul_of_one_lt_of_lt_of_nonneg [MulPosMono \u03b1] (ha : 1 \u2264 a) (h : b < c) (hc : 0 \u2264 c) :\n    b < a * c", "start": [905, 1], "end": [907, 44], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_of_one_le_of_nonneg_left", "code": "theorem lt_of_mul_lt_of_one_le_of_nonneg_left [PosMulMono \u03b1] (h : a * b < c) (hle : 1 \u2264 b)\n    (ha : 0 \u2264 a) : a < c", "start": [910, 1], "end": [912, 45], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_mul_of_le_one_of_nonneg_left", "code": "theorem lt_of_lt_mul_of_le_one_of_nonneg_left [PosMulMono \u03b1] (h : a < b * c) (hc : c \u2264 1)\n    (hb : 0 \u2264 b) : a < b", "start": [915, 1], "end": [917, 45], "kind": "commanddeclaration"}, {"full_name": "lt_of_lt_mul_of_le_one_of_nonneg_right", "code": "theorem lt_of_lt_mul_of_le_one_of_nonneg_right [MulPosMono \u03b1] (h : a < b * c) (hb : b \u2264 1)\n    (hc : 0 \u2264 c) : a < c", "start": [920, 1], "end": [922, 44], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_one_le_of_le_of_nonneg", "code": "theorem le_mul_of_one_le_of_le_of_nonneg [MulPosMono \u03b1] (ha : 1 \u2264 a) (bc : b \u2264 c) (c0 : 0 \u2264 c) :\n    b \u2264 a * c", "start": [925, 1], "end": [927, 42], "kind": "commanddeclaration"}, {"full_name": "Right.one_le_mul_of_le_of_le", "code": "theorem Right.one_le_mul_of_le_of_le [MulPosMono \u03b1] (ha : 1 \u2264 a) (hb : 1 \u2264 b) (b0 : 0 \u2264 b) :\n    1 \u2264 a * b", "start": [930, 1], "end": [933, 44], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_of_one_le_of_nonneg_left", "code": "theorem le_of_mul_le_of_one_le_of_nonneg_left [PosMulMono \u03b1] (h : a * b \u2264 c) (hb : 1 \u2264 b)\n    (ha : 0 \u2264 a) : a \u2264 c", "start": [936, 1], "end": [938, 41], "kind": "commanddeclaration"}, {"full_name": "le_of_le_mul_of_le_one_of_nonneg_left", "code": "theorem le_of_le_mul_of_le_one_of_nonneg_left [PosMulMono \u03b1] (h : a \u2264 b * c) (hc : c \u2264 1)\n    (hb : 0 \u2264 b) : a \u2264 b", "start": [941, 1], "end": [943, 42], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_of_one_le_nonneg_right", "code": "theorem le_of_mul_le_of_one_le_nonneg_right [MulPosMono \u03b1] (h : a * b \u2264 c) (ha : 1 \u2264 a)\n    (hb : 0 \u2264 b) : b \u2264 c", "start": [946, 1], "end": [948, 40], "kind": "commanddeclaration"}, {"full_name": "le_of_le_mul_of_le_one_of_nonneg_right", "code": "theorem le_of_le_mul_of_le_one_of_nonneg_right [MulPosMono \u03b1] (h : a \u2264 b * c) (hb : b \u2264 1)\n    (hc : 0 \u2264 c) : a \u2264 c", "start": [951, 1], "end": [953, 41], "kind": "commanddeclaration"}, {"full_name": "exists_square_le'", "code": "theorem exists_square_le' [PosMulStrictMono \u03b1] (a0 : 0 < a) : \u2203 b : \u03b1, b * b \u2264 a", "start": [964, 1], "end": [967, 32], "kind": "commanddeclaration"}, {"full_name": "PosMulMono.toPosMulStrictMono", "code": "theorem PosMulMono.toPosMulStrictMono [PosMulMono \u03b1] : PosMulStrictMono \u03b1", "start": [982, 1], "end": [984, 39], "kind": "commanddeclaration"}, {"full_name": "posMulMono_iff_posMulStrictMono", "code": "theorem posMulMono_iff_posMulStrictMono : PosMulMono \u03b1 \u2194 PosMulStrictMono \u03b1", "start": [987, 1], "end": [988, 79], "kind": "commanddeclaration"}, {"full_name": "MulPosMono.toMulPosStrictMono", "code": "theorem MulPosMono.toMulPosStrictMono [MulPosMono \u03b1] : MulPosStrictMono \u03b1", "start": [991, 1], "end": [993, 40], "kind": "commanddeclaration"}, {"full_name": "mulPosMono_iff_mulPosStrictMono", "code": "theorem mulPosMono_iff_mulPosStrictMono : MulPosMono \u03b1 \u2194 MulPosStrictMono \u03b1", "start": [996, 1], "end": [997, 79], "kind": "commanddeclaration"}, {"full_name": "PosMulReflectLT.toPosMulMonoRev", "code": "theorem PosMulReflectLT.toPosMulMonoRev [PosMulReflectLT \u03b1] : PosMulMonoRev \u03b1", "start": [1000, 1], "end": [1003, 44], "kind": "commanddeclaration"}, {"full_name": "posMulMonoRev_iff_posMulReflectLT", "code": "theorem posMulMonoRev_iff_posMulReflectLT : PosMulMonoRev \u03b1 \u2194 PosMulReflectLT \u03b1", "start": [1006, 1], "end": [1007, 83], "kind": "commanddeclaration"}, {"full_name": "MulPosReflectLT.toMulPosMonoRev", "code": "theorem MulPosReflectLT.toMulPosMonoRev [MulPosReflectLT \u03b1] : MulPosMonoRev \u03b1", "start": [1010, 1], "end": [1012, 43], "kind": "commanddeclaration"}, {"full_name": "mulPosMonoRev_iff_mulPosReflectLT", "code": "theorem mulPosMonoRev_iff_mulPosReflectLT : MulPosMonoRev \u03b1 \u2194 MulPosReflectLT \u03b1", "start": [1015, 1], "end": [1016, 83], "kind": "commanddeclaration"}, {"full_name": "posMulStrictMono_iff_mulPosStrictMono", "code": "theorem posMulStrictMono_iff_mulPosStrictMono : PosMulStrictMono \u03b1 \u2194 MulPosStrictMono \u03b1", "start": [1027, 1], "end": [1028, 67], "kind": "commanddeclaration"}, {"full_name": "posMulReflectLT_iff_mulPosReflectLT", "code": "theorem posMulReflectLT_iff_mulPosReflectLT : PosMulReflectLT \u03b1 \u2194 MulPosReflectLT \u03b1", "start": [1031, 1], "end": [1032, 65], "kind": "commanddeclaration"}, {"full_name": "posMulMono_iff_mulPosMono", "code": "theorem posMulMono_iff_mulPosMono : PosMulMono \u03b1 \u2194 MulPosMono \u03b1", "start": [1035, 1], "end": [1036, 55], "kind": "commanddeclaration"}, {"full_name": "posMulMonoRev_iff_mulPosMonoRev", "code": "theorem posMulMonoRev_iff_mulPosMonoRev : PosMulMonoRev \u03b1 \u2194 MulPosMonoRev \u03b1", "start": [1039, 1], "end": [1040, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Units.lean", "imports": ["Mathlib/Logic/Unique.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Tactic/Lift.lean"], "premises": [{"full_name": "Units", "code": "structure Units (\u03b1 : Type u) [Monoid \u03b1] where\n  \n  val : \u03b1\n  \n  inv : \u03b1\n  \n  val_inv : val * inv = 1\n  \n  inv_val : inv * val = 1", "start": [40, 1], "end": [53, 26], "kind": "commanddeclaration"}, {"full_name": "AddUnits", "code": "structure AddUnits (\u03b1 : Type u) [AddMonoid \u03b1] where\n  \n  val : \u03b1\n  \n  neg : \u03b1\n  \n  val_neg : val + neg = 0\n  \n  neg_val : neg + val = 0", "start": [66, 1], "end": [79, 26], "kind": "commanddeclaration"}, {"full_name": "unique_one", "code": "@[to_additive]\ntheorem unique_one {\u03b1 : Type*} [Unique \u03b1] [One \u03b1] : default = (1 : \u03b1)", "start": [91, 1], "end": [93, 22], "kind": "commanddeclaration"}, {"full_name": "Units.instInv", "code": "@[to_additive \"The additive inverse of an additive unit in an `AddMonoid`.\"]\ninstance instInv : Inv \u03b1\u02e3 :=\n  \u27e8fun u => \u27e8u.2, u.1, u.4, u.3\u27e9\u27e9", "start": [109, 1], "end": [112, 34], "kind": "commanddeclaration"}, {"full_name": "Units.Simps.val_inv", "code": "@[to_additive \"See Note [custom simps projection]\"]\ndef Simps.val_inv (u : \u03b1\u02e3) : \u03b1 := \u2191(u\u207b\u00b9)", "start": [120, 1], "end": [122, 41], "kind": "commanddeclaration"}, {"full_name": "Units.val_mk", "code": "@[to_additive]\ntheorem val_mk (a : \u03b1) (b h\u2081 h\u2082) : \u2191(Units.mk a b h\u2081 h\u2082) = a", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Units.ext", "code": "@[to_additive (attr := ext)]\ntheorem ext : Function.Injective (val : \u03b1\u02e3 \u2192 \u03b1)", "start": [138, 1], "end": [142, 68], "kind": "commanddeclaration"}, {"full_name": "Units.eq_iff", "code": "@[to_additive (attr := norm_cast)]\ntheorem eq_iff {a b : \u03b1\u02e3} : (a : \u03b1) = b \u2194 a = b", "start": [146, 1], "end": [148, 13], "kind": "commanddeclaration"}, {"full_name": "Units.ext_iff", "code": "@[to_additive]\ntheorem ext_iff {a b : \u03b1\u02e3} : a = b \u2194 (a : \u03b1) = b", "start": [152, 1], "end": [154, 14], "kind": "commanddeclaration"}, {"full_name": "Units.mk_val", "code": "@[to_additive (attr := simp)]\ntheorem mk_val (u : \u03b1\u02e3) (y h\u2081 h\u2082) : mk (u : \u03b1) y h\u2081 h\u2082 = u", "start": [163, 1], "end": [165, 10], "kind": "commanddeclaration"}, {"full_name": "Units.copy", "code": "@[to_additive (attr := simps) \"Copy an `AddUnit`, adjusting definitional equalities.\"]\ndef copy (u : \u03b1\u02e3) (val : \u03b1) (hv : val = u) (inv : \u03b1) (hi : inv = \u2191u\u207b\u00b9) : \u03b1\u02e3 :=\n  { val, inv, inv_val := hv.symm \u25b8 hi.symm \u25b8 u.inv_val, val_inv := hv.symm \u25b8 hi.symm \u25b8 u.val_inv }", "start": [169, 1], "end": [172, 99], "kind": "commanddeclaration"}, {"full_name": "Units.copy_eq", "code": "@[to_additive]\ntheorem copy_eq (u : \u03b1\u02e3) (val hv inv hi) : u.copy val hv inv hi = u", "start": [180, 1], "end": [182, 9], "kind": "commanddeclaration"}, {"full_name": "Units.instCommGroupUnits", "code": "@[to_additive \"Additive units of an additive commutative monoid form\nan additive commutative group.\"]\ninstance instCommGroupUnits {\u03b1} [CommMonoid \u03b1] : CommGroup \u03b1\u02e3 :=\n  { mul_comm := fun _ _ => ext <| mul_comm _ _ }", "start": [204, 1], "end": [210, 49], "kind": "commanddeclaration"}, {"full_name": "Units.val_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_mul : (\u2191(a * b) : \u03b1) = a * b", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "Units.val_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_one : ((1 : \u03b1\u02e3) : \u03b1) = 1", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Units.val_eq_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_eq_one {a : \u03b1\u02e3} : (a : \u03b1) = 1 \u2194 a = 1", "start": [240, 1], "end": [241, 85], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mk", "code": "@[to_additive (attr := simp)]\ntheorem inv_mk (x y : \u03b1) (h\u2081 h\u2082) : (mk x y h\u2081 h\u2082)\u207b\u00b9 = mk y x h\u2082 h\u2081", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "Units.inv_eq_val_inv", "code": "@[to_additive (attr := simp)]\ntheorem inv_eq_val_inv : a.inv = ((a\u207b\u00b9 : \u03b1\u02e3) : \u03b1)", "start": [255, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul : (\u2191a\u207b\u00b9 * a : \u03b1) = 1", "start": [261, 1], "end": [263, 12], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv : (a * \u2191a\u207b\u00b9 : \u03b1) = 1", "start": [267, 1], "end": [269, 12], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul_of_eq", "code": "@[to_additive]\ntheorem inv_mul_of_eq {a : \u03b1} (h : \u2191u = a) : \u2191u\u207b\u00b9 * a = 1", "start": [273, 1], "end": [274, 84], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv_of_eq", "code": "@[to_additive]\ntheorem mul_inv_of_eq {a : \u03b1} (h : \u2191u = a) : a * \u2191u\u207b\u00b9 = 1", "start": [278, 1], "end": [279, 84], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_left (a : \u03b1\u02e3) (b : \u03b1) : (a : \u03b1) * (\u2191a\u207b\u00b9 * b) = b", "start": [283, 1], "end": [285, 37], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul_cancel_left", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_left (a : \u03b1\u02e3) (b : \u03b1) : (\u2191a\u207b\u00b9 : \u03b1) * (a * b) = b", "start": [289, 1], "end": [291, 37], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv_cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_right (a : \u03b1) (b : \u03b1\u02e3) : a * b * \u2191b\u207b\u00b9 = a", "start": [295, 1], "end": [297, 35], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul_cancel_right", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_cancel_right (a : \u03b1) (b : \u03b1\u02e3) : a * \u2191b\u207b\u00b9 * b = a", "start": [301, 1], "end": [303, 35], "kind": "commanddeclaration"}, {"full_name": "Units.mul_right_inj", "code": "@[to_additive (attr := simp)]\ntheorem mul_right_inj (a : \u03b1\u02e3) {b c : \u03b1} : (a : \u03b1) * b = a * c \u2194 b = c", "start": [307, 1], "end": [310, 17], "kind": "commanddeclaration"}, {"full_name": "Units.mul_left_inj", "code": "@[to_additive (attr := simp)]\ntheorem mul_left_inj (a : \u03b1\u02e3) {b c : \u03b1} : b * a = c * a \u2194 b = c", "start": [314, 1], "end": [317, 27], "kind": "commanddeclaration"}, {"full_name": "Units.eq_mul_inv_iff_mul_eq", "code": "@[to_additive]\ntheorem eq_mul_inv_iff_mul_eq {a b : \u03b1} : a = b * \u2191c\u207b\u00b9 \u2194 a * c = b", "start": [321, 1], "end": [323, 89], "kind": "commanddeclaration"}, {"full_name": "Units.eq_inv_mul_iff_mul_eq", "code": "@[to_additive]\ntheorem eq_inv_mul_iff_mul_eq {a c : \u03b1} : a = \u2191b\u207b\u00b9 * c \u2194 \u2191b * a = c", "start": [327, 1], "end": [329, 87], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem inv_mul_eq_iff_eq_mul {b c : \u03b1} : \u2191a\u207b\u00b9 * b = c \u2194 b = a * c", "start": [333, 1], "end": [335, 87], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv_eq_iff_eq_mul", "code": "@[to_additive]\ntheorem mul_inv_eq_iff_eq_mul {a c : \u03b1} : a * \u2191b\u207b\u00b9 = c \u2194 a = c * b", "start": [339, 1], "end": [341, 89], "kind": "commanddeclaration"}, {"full_name": "Units.inv_eq_of_mul_eq_one_left", "code": "@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_left {a : \u03b1} (h : a * u = 1) : \u2191u\u207b\u00b9 = a", "start": [346, 1], "end": [350, 47], "kind": "commanddeclaration"}, {"full_name": "Units.inv_eq_of_mul_eq_one_right", "code": "@[to_additive]\nprotected theorem inv_eq_of_mul_eq_one_right {a : \u03b1} (h : \u2191u * a = 1) : \u2191u\u207b\u00b9 = a", "start": [356, 1], "end": [360, 46], "kind": "commanddeclaration"}, {"full_name": "Units.eq_inv_of_mul_eq_one_left", "code": "@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_left {a : \u03b1} (h : \u2191u * a = 1) : a = \u2191u\u207b\u00b9", "start": [365, 1], "end": [367, 44], "kind": "commanddeclaration"}, {"full_name": "Units.eq_inv_of_mul_eq_one_right", "code": "@[to_additive]\nprotected theorem eq_inv_of_mul_eq_one_right {a : \u03b1} (h : a * u = 1) : a = \u2191u\u207b\u00b9", "start": [371, 1], "end": [373, 43], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_eq_one {a : \u03b1} : a * \u2191u\u207b\u00b9 = 1 \u2194 a = u", "start": [377, 1], "end": [379, 80], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_eq_one {a : \u03b1} : \u2191u\u207b\u00b9 * a = 1 \u2194 \u2191u = a", "start": [383, 1], "end": [385, 64], "kind": "commanddeclaration"}, {"full_name": "Units.mul_eq_one_iff_eq_inv", "code": "@[to_additive]\ntheorem mul_eq_one_iff_eq_inv {a : \u03b1} : a * u = 1 \u2194 a = \u2191u\u207b\u00b9", "start": [389, 1], "end": [390, 98], "kind": "commanddeclaration"}, {"full_name": "Units.mul_eq_one_iff_inv_eq", "code": "@[to_additive]\ntheorem mul_eq_one_iff_inv_eq {a : \u03b1} : \u2191u * a = 1 \u2194 \u2191u\u207b\u00b9 = a", "start": [394, 1], "end": [395, 99], "kind": "commanddeclaration"}, {"full_name": "Units.inv_unique", "code": "@[to_additive]\ntheorem inv_unique {u\u2081 u\u2082 : \u03b1\u02e3} (h : (\u2191u\u2081 : \u03b1) = \u2191u\u2082) : (\u2191u\u2081\u207b\u00b9 : \u03b1) = \u2191u\u2082\u207b\u00b9", "start": [399, 1], "end": [401, 60], "kind": "commanddeclaration"}, {"full_name": "Units.val_inv_eq_inv_val", "code": "@[to_additive (attr := simp)]\ntheorem val_inv_eq_inv_val {M : Type*} [DivisionMonoid M] (u : Units M) : \u2191u\u207b\u00b9 = (u\u207b\u00b9 : M)", "start": [405, 1], "end": [407, 50], "kind": "commanddeclaration"}, {"full_name": "Units.mkOfMulEqOne", "code": "@[to_additive\n  \"For `a, b` in an `AddCommMonoid` such that `a + b = 0`, makes an addUnit out of `a`.\"]\ndef Units.mkOfMulEqOne [CommMonoid \u03b1] (a b : \u03b1) (hab : a * b = 1) : \u03b1\u02e3 :=\n  \u27e8a, b, hab, (mul_comm b a).trans hab\u27e9", "start": [412, 1], "end": [416, 40], "kind": "commanddeclaration"}, {"full_name": "Units.val_mkOfMulEqOne", "code": "@[to_additive (attr := simp)]\ntheorem Units.val_mkOfMulEqOne [CommMonoid \u03b1] {a b : \u03b1} (h : a * b = 1) :\n    (Units.mkOfMulEqOne a b h : \u03b1) = a", "start": [420, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "divp", "code": "def divp (a : \u03b1) (u : Units \u03b1) : \u03b1 :=\n  a * (u\u207b\u00b9 : \u03b1\u02e3)", "start": [431, 1], "end": [435, 17], "kind": "commanddeclaration"}, {"full_name": "divp_self", "code": "@[simp]\ntheorem divp_self (u : \u03b1\u02e3) : (u : \u03b1) /\u209a u = 1", "start": [441, 1], "end": [443, 18], "kind": "commanddeclaration"}, {"full_name": "divp_one", "code": "@[simp]\ntheorem divp_one (a : \u03b1) : a /\u209a 1 = a", "start": [446, 1], "end": [448, 12], "kind": "commanddeclaration"}, {"full_name": "divp_assoc", "code": "theorem divp_assoc (a b : \u03b1) (u : \u03b1\u02e3) : a * b /\u209a u = a * (b /\u209a u)", "start": [451, 1], "end": [452, 18], "kind": "commanddeclaration"}, {"full_name": "divp_assoc'", "code": "@[field_simps]\ntheorem divp_assoc' (x y : \u03b1) (u : \u03b1\u02e3) : x * (y /\u209a u) = x * y /\u209a u", "start": [455, 1], "end": [458, 26], "kind": "commanddeclaration"}, {"full_name": "divp_inv", "code": "@[simp]\ntheorem divp_inv (u : \u03b1\u02e3) : a /\u209a u\u207b\u00b9 = a * u", "start": [461, 1], "end": [463, 6], "kind": "commanddeclaration"}, {"full_name": "divp_mul_cancel", "code": "@[simp]\ntheorem divp_mul_cancel (a : \u03b1) (u : \u03b1\u02e3) : a /\u209a u * u = a", "start": [466, 1], "end": [468, 60], "kind": "commanddeclaration"}, {"full_name": "mul_divp_cancel", "code": "@[simp]\ntheorem mul_divp_cancel (a : \u03b1) (u : \u03b1\u02e3) : a * u /\u209a u = a", "start": [471, 1], "end": [473, 60], "kind": "commanddeclaration"}, {"full_name": "divp_left_inj", "code": "@[simp]\ntheorem divp_left_inj (u : \u03b1\u02e3) {a b : \u03b1} : a /\u209a u = b /\u209a u \u2194 a = b", "start": [476, 1], "end": [478, 23], "kind": "commanddeclaration"}, {"full_name": "divp_divp_eq_divp_mul", "code": "@[field_simps]\ntheorem divp_divp_eq_divp_mul (x : \u03b1) (u\u2081 u\u2082 : \u03b1\u02e3) : x /\u209a u\u2081 /\u209a u\u2082 = x /\u209a (u\u2082 * u\u2081)", "start": [481, 1], "end": [483, 58], "kind": "commanddeclaration"}, {"full_name": "divp_eq_iff_mul_eq", "code": "@[field_simps 1010]\ntheorem divp_eq_iff_mul_eq {x : \u03b1} {u : \u03b1\u02e3} {y : \u03b1} : x /\u209a u = y \u2194 y * u = x", "start": [488, 1], "end": [490, 81], "kind": "commanddeclaration"}, {"full_name": "eq_divp_iff_mul_eq", "code": "@[field_simps]\ntheorem eq_divp_iff_mul_eq {x : \u03b1} {u : \u03b1\u02e3} {y : \u03b1} : x = y /\u209a u \u2194 x * u = y", "start": [493, 1], "end": [495, 35], "kind": "commanddeclaration"}, {"full_name": "divp_eq_one_iff_eq", "code": "theorem divp_eq_one_iff_eq {a : \u03b1} {u : \u03b1\u02e3} : a /\u209a u = 1 \u2194 a = u", "start": [498, 1], "end": [499, 72], "kind": "commanddeclaration"}, {"full_name": "one_divp", "code": "@[simp]\ntheorem one_divp (u : \u03b1\u02e3) : 1 /\u209a u = \u2191u\u207b\u00b9", "start": [502, 1], "end": [504, 12], "kind": "commanddeclaration"}, {"full_name": "inv_eq_one_divp", "code": "@[field_simps]\ntheorem inv_eq_one_divp (u : \u03b1\u02e3) : \u2191u\u207b\u00b9 = 1 /\u209a u", "start": [507, 1], "end": [509, 69], "kind": "commanddeclaration"}, {"full_name": "inv_eq_one_divp'", "code": "@[field_simps]\ntheorem inv_eq_one_divp' (u : \u03b1\u02e3) : ((1 / u : \u03b1\u02e3) : \u03b1) = 1 /\u209a u", "start": [512, 1], "end": [518, 25], "kind": "commanddeclaration"}, {"full_name": "val_div_eq_divp", "code": "@[field_simps]\ntheorem val_div_eq_divp (u\u2081 u\u2082 : \u03b1\u02e3) : \u2191(u\u2081 / u\u2082) = \u2191u\u2081 /\u209a u\u2082", "start": [521, 1], "end": [526, 41], "kind": "commanddeclaration"}, {"full_name": "divp_mul_eq_mul_divp", "code": "@[field_simps]\ntheorem divp_mul_eq_mul_divp (x y : \u03b1) (u : \u03b1\u02e3) : x /\u209a u * y = x * y /\u209a u", "start": [535, 1], "end": [537, 34], "kind": "commanddeclaration"}, {"full_name": "divp_eq_divp_iff", "code": "@[field_simps]\ntheorem divp_eq_divp_iff {x y : \u03b1} {ux uy : \u03b1\u02e3} : x /\u209a ux = y /\u209a uy \u2194 x * uy = y * ux", "start": [541, 1], "end": [543, 68], "kind": "commanddeclaration"}, {"full_name": "divp_mul_divp", "code": "@[field_simps]\ntheorem divp_mul_divp (x y : \u03b1) (ux uy : \u03b1\u02e3) : x /\u209a ux * (y /\u209a uy) = x * y /\u209a (ux * uy)", "start": [547, 1], "end": [549, 64], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_mul_right", "code": "@[to_additive]\ntheorem eq_one_of_mul_right (h : a * b = 1) : a = 1", "start": [554, 1], "end": [556, 82], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_mul_left", "code": "@[to_additive]\ntheorem eq_one_of_mul_left (h : a * b = 1) : b = 1", "start": [560, 1], "end": [562, 83], "kind": "commanddeclaration"}, {"full_name": "mul_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq_one : a * b = 1 \u2194 a = 1 \u2227 b = 1", "start": [566, 1], "end": [570, 21], "kind": "commanddeclaration"}, {"full_name": "IsUnit", "code": "@[to_additive\n      \"An element `a : M` of an `AddMonoid` is an `AddUnit` if it has a two-sided additive inverse.\n      The actual definition says that `a` is equal to some `u : AddUnits M`,\n      where `AddUnits M` is a bundled version of `IsAddUnit`.\"]\ndef IsUnit [Monoid M] (a : M) : Prop :=\n  \u2203 u : M\u02e3, (u : M) = a", "start": [585, 1], "end": [593, 24], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_subsingleton", "code": "@[to_additive (attr := nontriviality)]\ntheorem isUnit_of_subsingleton [Monoid M] [Subsingleton M] (a : M) : IsUnit a", "start": [597, 1], "end": [599, 62], "kind": "commanddeclaration"}, {"full_name": "Units.isUnit", "code": "@[to_additive (attr := simp)]\nprotected theorem Units.isUnit [Monoid M] (u : M\u02e3) : IsUnit (u : M)", "start": [614, 1], "end": [616, 11], "kind": "commanddeclaration"}, {"full_name": "isUnit_one", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_one [Monoid M] : IsUnit (1 : M)", "start": [620, 1], "end": [622, 11], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_mul_eq_one", "code": "@[to_additive]\ntheorem isUnit_of_mul_eq_one [CommMonoid M] (a b : M) (h : a * b = 1) : IsUnit a", "start": [626, 1], "end": [628, 34], "kind": "commanddeclaration"}, {"full_name": "IsUnit.exists_right_inv", "code": "@[to_additive IsAddUnit.exists_neg]\ntheorem IsUnit.exists_right_inv [Monoid M] {a : M} (h : IsUnit a) : \u2203 b, a * b = 1", "start": [632, 1], "end": [635, 17], "kind": "commanddeclaration"}, {"full_name": "IsUnit.exists_left_inv", "code": "@[to_additive IsAddUnit.exists_neg']\ntheorem IsUnit.exists_left_inv [Monoid M] {a : M} (h : IsUnit a) : \u2203 b, b * a = 1", "start": [639, 1], "end": [642, 17], "kind": "commanddeclaration"}, {"full_name": "isUnit_iff_exists_inv", "code": "@[to_additive]\ntheorem isUnit_iff_exists_inv [CommMonoid M] {a : M} : IsUnit a \u2194 \u2203 b, a * b = 1", "start": [646, 1], "end": [648, 78], "kind": "commanddeclaration"}, {"full_name": "isUnit_iff_exists_inv'", "code": "@[to_additive]\ntheorem isUnit_iff_exists_inv' [CommMonoid M] {a : M} : IsUnit a \u2194 \u2203 b, b * a = 1", "start": [652, 1], "end": [654, 41], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul", "code": "@[to_additive]\ntheorem IsUnit.mul [Monoid M] {x y : M} : IsUnit x \u2192 IsUnit y \u2192 IsUnit (x * y)", "start": [658, 1], "end": [661, 35], "kind": "commanddeclaration"}, {"full_name": "Units.isUnit_mul_units", "code": "@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the right doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_mul_units [Monoid M] (a : M) (u : M\u02e3) : IsUnit (a * u) \u2194 IsUnit a", "start": [665, 1], "end": [673, 28], "kind": "commanddeclaration"}, {"full_name": "Units.isUnit_units_mul", "code": "@[to_additive (attr := simp)\n\"Addition of a `u : AddUnits M` on the left doesn't affect `IsAddUnit`.\"]\ntheorem Units.isUnit_units_mul {M : Type*} [Monoid M] (u : M\u02e3) (a : M) :\n    IsUnit (\u2191u * a) \u2194 IsUnit a", "start": [677, 1], "end": [686, 17], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_mul_isUnit_left", "code": "@[to_additive]\ntheorem isUnit_of_mul_isUnit_left [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit x", "start": [690, 1], "end": [693, 56], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_mul_isUnit_right", "code": "@[to_additive]\ntheorem isUnit_of_mul_isUnit_right [CommMonoid M] {x y : M} (hu : IsUnit (x * y)) : IsUnit y", "start": [697, 1], "end": [699, 58], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_iff", "code": "@[to_additive (attr := simp)]\ntheorem mul_iff [CommMonoid M] {x y : M} : IsUnit (x * y) \u2194 IsUnit x \u2227 IsUnit y", "start": [705, 1], "end": [708, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.unit", "code": "protected noncomputable def unit (h : IsUnit a) : M\u02e3 :=\n  (Classical.choose h).copy a (Classical.choose_spec h).symm _ rfl", "start": [716, 1], "end": [719, 67], "kind": "commanddeclaration"}, {"full_name": "IsAddUnit.addUnit", "code": "protected noncomputable def _root_.IsAddUnit.addUnit [AddMonoid N] {a : N} (h : IsAddUnit a) :\n    AddUnits N :=\n  (Classical.choose h).copy a (Classical.choose_spec h).symm _ rfl", "start": [723, 1], "end": [728, 67], "kind": "commanddeclaration"}, {"full_name": "IsUnit.unit_of_val_units", "code": "@[to_additive (attr := simp)]\ntheorem unit_of_val_units {a : M\u02e3} (h : IsUnit (a : M)) : h.unit = a", "start": [732, 1], "end": [734, 19], "kind": "commanddeclaration"}, {"full_name": "IsUnit.unit_spec", "code": "@[to_additive (attr := simp)]\ntheorem unit_spec (h : IsUnit a) : \u2191h.unit = a", "start": [738, 1], "end": [740, 6], "kind": "commanddeclaration"}, {"full_name": "IsUnit.val_inv_mul", "code": "@[to_additive (attr := simp)]\ntheorem val_inv_mul (h : IsUnit a) : \u2191h.unit\u207b\u00b9 * a = 1", "start": [744, 1], "end": [746, 18], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_val_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_val_inv (h : IsUnit a) : a * \u2191h.unit\u207b\u00b9 = 1", "start": [750, 1], "end": [752, 30], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_left_inj", "code": "@[to_additive]\ntheorem mul_left_inj (h : IsUnit a) : b * a = c * a \u2194 b = c", "start": [761, 1], "end": [764, 22], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_right_inj", "code": "@[to_additive]\ntheorem mul_right_inj (h : IsUnit a) : a * b = a * c \u2194 b = c", "start": [768, 1], "end": [771, 23], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_left_cancel", "code": "@[to_additive]\nprotected theorem mul_left_cancel (h : IsUnit a) : a * b = a * c \u2192 b = c", "start": [775, 1], "end": [777, 20], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_right_cancel", "code": "@[to_additive]\nprotected theorem mul_right_cancel (h : IsUnit b) : a * b = c * b \u2192 a = c", "start": [781, 1], "end": [783, 19], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_right_injective", "code": "@[to_additive]\nprotected theorem mul_right_injective (h : IsUnit a) : Injective ((\u00b7 * \u00b7) a)", "start": [787, 1], "end": [789, 31], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_left_injective", "code": "@[to_additive]\nprotected theorem mul_left_injective (h : IsUnit b) : Injective (\u00b7 * b)", "start": [793, 1], "end": [795, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_mul_cancel", "code": "@[to_additive (attr := simp)]\nprotected theorem inv_mul_cancel : IsUnit a \u2192 a\u207b\u00b9 * a = 1", "start": [803, 1], "end": [806, 49], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_inv_cancel", "code": "@[to_additive (attr := simp)]\nprotected theorem mul_inv_cancel : IsUnit a \u2192 a * a\u207b\u00b9 = 1", "start": [810, 1], "end": [813, 49], "kind": "commanddeclaration"}, {"full_name": "groupOfIsUnit", "code": "noncomputable def groupOfIsUnit [hM : Monoid M] (h : \u2200 a : M, IsUnit a) : Group M :=\n  { hM with\n    inv := fun a => \u2191(h a).unit\u207b\u00b9,\n    mul_left_inv := fun a => by\n      change \u2191(h a).unit\u207b\u00b9 * a = 1\n      rw [Units.inv_mul_eq_iff_eq_mul, (h a).unit_spec, mul_one] }", "start": [827, 1], "end": [833, 67], "kind": "commanddeclaration"}, {"full_name": "commGroupOfIsUnit", "code": "noncomputable def commGroupOfIsUnit [hM : CommMonoid M] (h : \u2200 a : M, IsUnit a) : CommGroup M :=\n  { hM with\n    inv := fun a => \u2191(h a).unit\u207b\u00b9,\n    mul_left_inv := fun a => by\n      change \u2191(h a).unit\u207b\u00b9 * a = 1\n      rw [Units.inv_mul_eq_iff_eq_mul, (h a).unit_spec, mul_one] }", "start": [836, 1], "end": [842, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Defs.lean", "imports": ["Mathlib/Order/Hom/Basic.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/Algebra/Order/Sub/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderedAddCommGroup", "code": "class OrderedAddCommGroup (\u03b1 : Type u) extends AddCommGroup \u03b1, PartialOrder \u03b1 where\n  \n  protected add_le_add_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c + a \u2264 c + b", "start": [31, 1], "end": [35, 72], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup", "code": "class OrderedCommGroup (\u03b1 : Type u) extends CommGroup \u03b1, PartialOrder \u03b1 where\n  \n  protected mul_le_mul_left : \u2200 a b : \u03b1, a \u2264 b \u2192 \u2200 c : \u03b1, c * a \u2264 c * b", "start": [38, 1], "end": [42, 72], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup.to_covariantClass_left_le", "code": "@[to_additive]\ninstance OrderedCommGroup.to_covariantClass_left_le (\u03b1 : Type u) [OrderedCommGroup \u03b1] :\n    CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) where\n      elim a b c bc := OrderedCommGroup.mul_le_mul_left b c bc a", "start": [47, 1], "end": [50, 65], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup.toOrderedCancelCommMonoid", "code": "@[to_additive OrderedAddCommGroup.toOrderedCancelAddCommMonoid]\ninstance (priority := 100) OrderedCommGroup.toOrderedCancelCommMonoid [OrderedCommGroup \u03b1] :\n    OrderedCancelCommMonoid \u03b1 :=\n{ \u2039OrderedCommGroup \u03b1\u203a with le_of_mul_le_mul_left := fun a b c \u21a6 le_of_mul_le_mul_left' }", "start": [55, 1], "end": [58, 90], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup.to_contravariantClass_left_le", "code": "@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.to_contravariantClass_left_le (\u03b1 : Type u) [OrderedCommGroup \u03b1] :\n    ContravariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) where", "start": [69, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "OrderedCommGroup.to_contravariantClass_right_le", "code": "@[to_additive \"A choice-free shortcut instance.\"]\ntheorem OrderedCommGroup.to_contravariantClass_right_le (\u03b1 : Type u) [OrderedCommGroup \u03b1] :\n    ContravariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) where", "start": [80, 1], "end": [84, 63], "kind": "commanddeclaration"}, {"full_name": "Left.inv_le_one_iff", "code": "@[to_additive (attr := simp) \"Uses `left` co(ntra)variant.\"]\ntheorem Left.inv_le_one_iff : a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "start": [96, 1], "end": [100, 7], "kind": "commanddeclaration"}, {"full_name": "Left.one_le_inv_iff", "code": "@[to_additive (attr := simp) \"Uses `left` co(ntra)variant.\"]\ntheorem Left.one_le_inv_iff : 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "start": [104, 1], "end": [108, 7], "kind": "commanddeclaration"}, {"full_name": "le_inv_mul_iff_mul_le", "code": "@[to_additive (attr := simp)]\ntheorem le_inv_mul_iff_mul_le : b \u2264 a\u207b\u00b9 * c \u2194 a * b \u2264 c", "start": [112, 1], "end": [115, 7], "kind": "commanddeclaration"}, {"full_name": "inv_mul_le_iff_le_mul", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_le_iff_le_mul : b\u207b\u00b9 * a \u2264 c \u2194 a \u2264 b * c", "start": [119, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "inv_le_iff_one_le_mul'", "code": "@[to_additive neg_le_iff_add_nonneg']\ntheorem inv_le_iff_one_le_mul' : a\u207b\u00b9 \u2264 b \u2194 1 \u2264 a * b", "start": [125, 1], "end": [127, 61], "kind": "commanddeclaration"}, {"full_name": "le_inv_iff_mul_le_one_left", "code": "@[to_additive]\ntheorem le_inv_iff_mul_le_one_left : a \u2264 b\u207b\u00b9 \u2194 b * a \u2264 1", "start": [131, 1], "end": [133, 61], "kind": "commanddeclaration"}, {"full_name": "le_inv_mul_iff_le", "code": "@[to_additive]\ntheorem le_inv_mul_iff_le : 1 \u2264 b\u207b\u00b9 * a \u2194 b \u2264 a", "start": [137, 1], "end": [139, 61], "kind": "commanddeclaration"}, {"full_name": "inv_mul_le_one_iff", "code": "@[to_additive]\ntheorem inv_mul_le_one_iff : a\u207b\u00b9 * b \u2264 1 \u2194 b \u2264 a", "start": [143, 1], "end": [146, 56], "kind": "commanddeclaration"}, {"full_name": "Left.one_lt_inv_iff", "code": "@[to_additive (attr := simp) Left.neg_pos_iff \"Uses `left` co(ntra)variant.\"]\ntheorem Left.one_lt_inv_iff : 1 < a\u207b\u00b9 \u2194 a < 1", "start": [156, 1], "end": [159, 54], "kind": "commanddeclaration"}, {"full_name": "Left.inv_lt_one_iff", "code": "@[to_additive (attr := simp) \"Uses `left` co(ntra)variant.\"]\ntheorem Left.inv_lt_one_iff : a\u207b\u00b9 < 1 \u2194 1 < a", "start": [163, 1], "end": [166, 54], "kind": "commanddeclaration"}, {"full_name": "lt_inv_mul_iff_mul_lt", "code": "@[to_additive (attr := simp)]\ntheorem lt_inv_mul_iff_mul_lt : b < a\u207b\u00b9 * c \u2194 a * b < c", "start": [170, 1], "end": [173, 7], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_iff_lt_mul", "code": "@[to_additive (attr := simp)]\ntheorem inv_mul_lt_iff_lt_mul : b\u207b\u00b9 * a < c \u2194 a < b * c", "start": [177, 1], "end": [179, 52], "kind": "commanddeclaration"}, {"full_name": "inv_lt_iff_one_lt_mul'", "code": "@[to_additive]\ntheorem inv_lt_iff_one_lt_mul' : a\u207b\u00b9 < b \u2194 1 < a * b", "start": [183, 1], "end": [185, 61], "kind": "commanddeclaration"}, {"full_name": "lt_inv_iff_mul_lt_one'", "code": "@[to_additive]\ntheorem lt_inv_iff_mul_lt_one' : a < b\u207b\u00b9 \u2194 b * a < 1", "start": [189, 1], "end": [191, 61], "kind": "commanddeclaration"}, {"full_name": "lt_inv_mul_iff_lt", "code": "@[to_additive]\ntheorem lt_inv_mul_iff_lt : 1 < b\u207b\u00b9 * a \u2194 b < a", "start": [195, 1], "end": [197, 61], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_one_iff", "code": "@[to_additive]\ntheorem inv_mul_lt_one_iff : a\u207b\u00b9 * b < 1 \u2194 b < a", "start": [201, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "Right.inv_le_one_iff", "code": "@[to_additive (attr := simp) \"Uses `right` co(ntra)variant.\"]\ntheorem Right.inv_le_one_iff : a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "start": [213, 1], "end": [217, 7], "kind": "commanddeclaration"}, {"full_name": "Right.one_le_inv_iff", "code": "@[to_additive (attr := simp) \"Uses `right` co(ntra)variant.\"]\ntheorem Right.one_le_inv_iff : 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "start": [221, 1], "end": [225, 7], "kind": "commanddeclaration"}, {"full_name": "inv_le_iff_one_le_mul", "code": "@[to_additive neg_le_iff_add_nonneg]\ntheorem inv_le_iff_one_le_mul : a\u207b\u00b9 \u2264 b \u2194 1 \u2264 b * a", "start": [229, 1], "end": [231, 62], "kind": "commanddeclaration"}, {"full_name": "le_inv_iff_mul_le_one_right", "code": "@[to_additive]\ntheorem le_inv_iff_mul_le_one_right : a \u2264 b\u207b\u00b9 \u2194 a * b \u2264 1", "start": [235, 1], "end": [237, 62], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_iff_le_mul", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_le_iff_le_mul : a * b\u207b\u00b9 \u2264 c \u2194 a \u2264 c * b", "start": [241, 1], "end": [243, 70], "kind": "commanddeclaration"}, {"full_name": "le_mul_inv_iff_mul_le", "code": "@[to_additive (attr := simp)]\ntheorem le_mul_inv_iff_mul_le : c \u2264 a * b\u207b\u00b9 \u2194 c * b \u2264 a", "start": [247, 1], "end": [249, 70], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_one_iff_le", "code": "@[to_additive]\ntheorem mul_inv_le_one_iff_le : a * b\u207b\u00b9 \u2264 1 \u2194 a \u2264 b", "start": [254, 1], "end": [256, 49], "kind": "commanddeclaration"}, {"full_name": "le_mul_inv_iff_le", "code": "@[to_additive]\ntheorem le_mul_inv_iff_le : 1 \u2264 a * b\u207b\u00b9 \u2194 b \u2264 a", "start": [260, 1], "end": [262, 63], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_one_iff", "code": "@[to_additive]\ntheorem mul_inv_le_one_iff : b * a\u207b\u00b9 \u2264 1 \u2194 b \u2264 a", "start": [266, 1], "end": [268, 56], "kind": "commanddeclaration"}, {"full_name": "Right.inv_lt_one_iff", "code": "@[to_additive (attr := simp) \"Uses `right` co(ntra)variant.\"]\ntheorem Right.inv_lt_one_iff : a\u207b\u00b9 < 1 \u2194 1 < a", "start": [278, 1], "end": [281, 55], "kind": "commanddeclaration"}, {"full_name": "Right.one_lt_inv_iff", "code": "@[to_additive (attr := simp) Right.neg_pos_iff \"Uses `right` co(ntra)variant.\"]\ntheorem Right.one_lt_inv_iff : 1 < a\u207b\u00b9 \u2194 a < 1", "start": [285, 1], "end": [288, 55], "kind": "commanddeclaration"}, {"full_name": "inv_lt_iff_one_lt_mul", "code": "@[to_additive]\ntheorem inv_lt_iff_one_lt_mul : a\u207b\u00b9 < b \u2194 1 < b * a", "start": [292, 1], "end": [294, 62], "kind": "commanddeclaration"}, {"full_name": "lt_inv_iff_mul_lt_one", "code": "@[to_additive]\ntheorem lt_inv_iff_mul_lt_one : a < b\u207b\u00b9 \u2194 a * b < 1", "start": [298, 1], "end": [300, 62], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_iff_lt_mul", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_lt_iff_lt_mul : a * b\u207b\u00b9 < c \u2194 a < c * b", "start": [304, 1], "end": [306, 54], "kind": "commanddeclaration"}, {"full_name": "lt_mul_inv_iff_mul_lt", "code": "@[to_additive (attr := simp)]\ntheorem lt_mul_inv_iff_mul_lt : c < a * b\u207b\u00b9 \u2194 c * b < a", "start": [310, 1], "end": [312, 70], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_one_iff_lt", "code": "@[to_additive]\ntheorem inv_mul_lt_one_iff_lt : a * b\u207b\u00b9 < 1 \u2194 a < b", "start": [317, 1], "end": [319, 63], "kind": "commanddeclaration"}, {"full_name": "lt_mul_inv_iff_lt", "code": "@[to_additive]\ntheorem lt_mul_inv_iff_lt : 1 < a * b\u207b\u00b9 \u2194 b < a", "start": [323, 1], "end": [325, 63], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_one_iff", "code": "@[to_additive]\ntheorem mul_inv_lt_one_iff : b * a\u207b\u00b9 < 1 \u2194 b < a", "start": [329, 1], "end": [331, 56], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_le_inv_iff : a\u207b\u00b9 \u2264 b\u207b\u00b9 \u2194 b \u2264 a", "start": [342, 1], "end": [345, 7], "kind": "commanddeclaration"}, {"full_name": "le_of_neg_le_neg", "code": "alias \u27e8le_of_neg_le_neg, _\u27e9 := neg_le_neg_iff", "start": [349, 1], "end": [349, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_inv_le_inv_mul_iff", "code": "@[to_additive]\ntheorem mul_inv_le_inv_mul_iff : a * b\u207b\u00b9 \u2264 d\u207b\u00b9 * c \u2194 d * a \u2264 c * b", "start": [352, 1], "end": [355, 26], "kind": "commanddeclaration"}, {"full_name": "div_le_self_iff", "code": "@[to_additive (attr := simp)]\ntheorem div_le_self_iff (a : \u03b1) {b : \u03b1} : a / b \u2264 a \u2194 1 \u2264 b", "start": [359, 1], "end": [361, 24], "kind": "commanddeclaration"}, {"full_name": "le_div_self_iff", "code": "@[to_additive (attr := simp)]\ntheorem le_div_self_iff (a : \u03b1) {b : \u03b1} : a \u2264 a / b \u2194 b \u2264 1", "start": [365, 1], "end": [367, 24], "kind": "commanddeclaration"}, {"full_name": "sub_le_self", "code": "alias \u27e8_, sub_le_self\u27e9 := sub_le_self_iff", "start": [371, 1], "end": [371, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_lt_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_lt_inv_iff : a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a", "start": [381, 1], "end": [384, 7], "kind": "commanddeclaration"}, {"full_name": "inv_lt'", "code": "@[to_additive neg_lt]\ntheorem inv_lt' : a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a", "start": [388, 1], "end": [389, 73], "kind": "commanddeclaration"}, {"full_name": "lt_inv'", "code": "@[to_additive lt_neg]\ntheorem lt_inv' : a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9", "start": [393, 1], "end": [394, 73], "kind": "commanddeclaration"}, {"full_name": "lt_inv_of_lt_inv", "code": "alias \u27e8lt_inv_of_lt_inv, _\u27e9 := lt_inv'", "start": [398, 1], "end": [398, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_lt_of_inv_lt'", "code": "alias \u27e8inv_lt_of_inv_lt', _\u27e9 := inv_lt'", "start": [404, 1], "end": [404, 40], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_inv_lt_inv_mul_iff", "code": "@[to_additive]\ntheorem mul_inv_lt_inv_mul_iff : a * b\u207b\u00b9 < d\u207b\u00b9 * c \u2194 d * a < c * b", "start": [410, 1], "end": [413, 26], "kind": "commanddeclaration"}, {"full_name": "div_lt_self_iff", "code": "@[to_additive (attr := simp)]\ntheorem div_lt_self_iff (a : \u03b1) {b : \u03b1} : a / b < a \u2194 1 < b", "start": [417, 1], "end": [419, 24], "kind": "commanddeclaration"}, {"full_name": "sub_lt_self", "code": "alias \u27e8_, sub_lt_self\u27e9 := sub_lt_self_iff", "start": [423, 1], "end": [423, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Left.inv_le_self", "code": "@[to_additive]\ntheorem Left.inv_le_self (h : 1 \u2264 a) : a\u207b\u00b9 \u2264 a", "start": [436, 1], "end": [438, 41], "kind": "commanddeclaration"}, {"full_name": "neg_le_self", "code": "alias neg_le_self := Left.neg_le_self", "start": [442, 1], "end": [442, 38], "kind": "stdtacticaliasalias"}, {"full_name": "Left.self_le_inv", "code": "@[to_additive]\ntheorem Left.self_le_inv (h : a \u2264 1) : a \u2264 a\u207b\u00b9", "start": [445, 1], "end": [447, 41], "kind": "commanddeclaration"}, {"full_name": "Left.inv_lt_self", "code": "@[to_additive]\ntheorem Left.inv_lt_self (h : 1 < a) : a\u207b\u00b9 < a", "start": [457, 1], "end": [459, 38], "kind": "commanddeclaration"}, {"full_name": "neg_lt_self", "code": "alias neg_lt_self := Left.neg_lt_self", "start": [463, 1], "end": [463, 38], "kind": "stdtacticaliasalias"}, {"full_name": "Left.self_lt_inv", "code": "@[to_additive]\ntheorem Left.self_lt_inv (h : a < 1) : a < a\u207b\u00b9", "start": [466, 1], "end": [468, 41], "kind": "commanddeclaration"}, {"full_name": "Right.inv_le_self", "code": "@[to_additive]\ntheorem Right.inv_le_self (h : 1 \u2264 a) : a\u207b\u00b9 \u2264 a", "start": [478, 1], "end": [480, 42], "kind": "commanddeclaration"}, {"full_name": "Right.self_le_inv", "code": "@[to_additive]\ntheorem Right.self_le_inv (h : a \u2264 1) : a \u2264 a\u207b\u00b9", "start": [484, 1], "end": [486, 42], "kind": "commanddeclaration"}, {"full_name": "Right.inv_lt_self", "code": "@[to_additive]\ntheorem Right.inv_lt_self (h : 1 < a) : a\u207b\u00b9 < a", "start": [496, 1], "end": [498, 39], "kind": "commanddeclaration"}, {"full_name": "Right.self_lt_inv", "code": "@[to_additive]\ntheorem Right.self_lt_inv (h : a < 1) : a < a\u207b\u00b9", "start": [502, 1], "end": [504, 42], "kind": "commanddeclaration"}, {"full_name": "inv_mul_le_iff_le_mul'", "code": "@[to_additive]\ntheorem inv_mul_le_iff_le_mul' : c\u207b\u00b9 * a \u2264 b \u2194 a \u2264 b * c", "start": [522, 1], "end": [523, 100], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_iff_le_mul'", "code": "@[to_additive]\ntheorem mul_inv_le_iff_le_mul' : a * b\u207b\u00b9 \u2264 c \u2194 a \u2264 b * c", "start": [528, 1], "end": [530, 41], "kind": "commanddeclaration"}, {"full_name": "mul_inv_le_mul_inv_iff'", "code": "@[to_additive add_neg_le_add_neg_iff]\ntheorem mul_inv_le_mul_inv_iff' : a * b\u207b\u00b9 \u2264 c * d\u207b\u00b9 \u2194 a * d \u2264 c * b", "start": [534, 1], "end": [536, 52], "kind": "commanddeclaration"}, {"full_name": "inv_mul_lt_iff_lt_mul'", "code": "@[to_additive]\ntheorem inv_mul_lt_iff_lt_mul' : c\u207b\u00b9 * a < b \u2194 a < b * c", "start": [546, 1], "end": [547, 100], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_iff_le_mul'", "code": "@[to_additive]\ntheorem mul_inv_lt_iff_le_mul' : a * b\u207b\u00b9 < c \u2194 a < b * c", "start": [552, 1], "end": [554, 41], "kind": "commanddeclaration"}, {"full_name": "mul_inv_lt_mul_inv_iff'", "code": "@[to_additive add_neg_lt_add_neg_iff]\ntheorem mul_inv_lt_mul_inv_iff' : a * b\u207b\u00b9 < c * d\u207b\u00b9 \u2194 a * d < c * b", "start": [558, 1], "end": [560, 52], "kind": "commanddeclaration"}, {"full_name": "one_le_of_inv_le_one", "code": "alias \u27e8one_le_of_inv_le_one, _\u27e9 := Left.inv_le_one_iff", "start": [568, 1], "end": [568, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_one_of_one_le_inv", "code": "alias \u27e8le_one_of_one_le_inv, _\u27e9 := Left.one_le_inv_iff", "start": [574, 1], "end": [574, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_of_inv_lt_inv", "code": "alias \u27e8lt_of_inv_lt_inv, _\u27e9 := inv_lt_inv_iff", "start": [580, 1], "end": [580, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "one_lt_of_inv_lt_one", "code": "alias \u27e8one_lt_of_inv_lt_one, _\u27e9 := Left.inv_lt_one_iff", "start": [586, 1], "end": [586, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_lt_one_iff_one_lt", "code": "alias inv_lt_one_iff_one_lt := Left.inv_lt_one_iff", "start": [592, 1], "end": [592, 51], "kind": "stdtacticaliasalias"}, {"full_name": "inv_lt_one'", "code": "alias inv_lt_one' := Left.inv_lt_one_iff", "start": [598, 1], "end": [598, 41], "kind": "stdtacticaliasalias"}, {"full_name": "inv_of_one_lt_inv", "code": "alias \u27e8inv_of_one_lt_inv, _\u27e9 := Left.one_lt_inv_iff", "start": [604, 1], "end": [604, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "one_lt_inv_of_inv", "code": "alias \u27e8_, one_lt_inv_of_inv\u27e9 := Left.one_lt_inv_iff", "start": [610, 1], "end": [610, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_le_of_le_inv_mul", "code": "alias \u27e8mul_le_of_le_inv_mul, _\u27e9 := le_inv_mul_iff_mul_le", "start": [616, 1], "end": [616, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_inv_mul_of_mul_le", "code": "alias \u27e8_, le_inv_mul_of_mul_le\u27e9 := le_inv_mul_iff_mul_le", "start": [622, 1], "end": [622, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_mul_le_of_le_mul", "code": "alias \u27e8_, inv_mul_le_of_le_mul\u27e9 := inv_mul_le_iff_le_mul", "start": [628, 1], "end": [628, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "mul_lt_of_lt_inv_mul", "code": "alias \u27e8mul_lt_of_lt_inv_mul, _\u27e9 := lt_inv_mul_iff_mul_lt", "start": [634, 1], "end": [634, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_inv_mul_of_mul_lt", "code": "alias \u27e8_, lt_inv_mul_of_mul_lt\u27e9 := lt_inv_mul_iff_mul_lt", "start": [640, 1], "end": [640, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_mul_of_inv_mul_lt", "code": "alias \u27e8lt_mul_of_inv_mul_lt, inv_mul_lt_of_lt_mul\u27e9 := inv_mul_lt_iff_lt_mul", "start": [646, 1], "end": [646, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_mul_lt_of_lt_mul", "code": "alias \u27e8lt_mul_of_inv_mul_lt, inv_mul_lt_of_lt_mul\u27e9 := inv_mul_lt_iff_lt_mul", "start": [646, 1], "end": [646, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_mul_of_inv_mul_lt_left", "code": "alias lt_mul_of_inv_mul_lt_left := lt_mul_of_inv_mul_lt", "start": [656, 1], "end": [656, 56], "kind": "stdtacticaliasalias"}, {"full_name": "inv_le_one'", "code": "alias inv_le_one' := Left.inv_le_one_iff", "start": [662, 1], "end": [662, 41], "kind": "stdtacticaliasalias"}, {"full_name": "one_le_inv'", "code": "alias one_le_inv' := Left.one_le_inv_iff", "start": [668, 1], "end": [668, 41], "kind": "stdtacticaliasalias"}, {"full_name": "one_lt_inv'", "code": "alias one_lt_inv' := Left.one_lt_inv_iff", "start": [674, 1], "end": [674, 41], "kind": "stdtacticaliasalias"}, {"full_name": "OrderedCommGroup.mul_lt_mul_left'", "code": "alias OrderedCommGroup.mul_lt_mul_left' := mul_lt_mul_left'", "start": [680, 1], "end": [680, 60], "kind": "stdtacticaliasalias"}, {"full_name": "OrderedCommGroup.le_of_mul_le_mul_left", "code": "alias OrderedCommGroup.le_of_mul_le_mul_left := le_of_mul_le_mul_left'", "start": [686, 1], "end": [686, 71], "kind": "stdtacticaliasalias"}, {"full_name": "OrderedCommGroup.lt_of_mul_lt_mul_left", "code": "alias OrderedCommGroup.lt_of_mul_lt_mul_left := lt_of_mul_lt_mul_left'", "start": [692, 1], "end": [692, 71], "kind": "stdtacticaliasalias"}, {"full_name": "div_le_div_iff_right", "code": "@[to_additive (attr := simp)]\ntheorem div_le_div_iff_right (c : \u03b1) : a / c \u2264 b / c \u2194 a \u2264 b", "start": [708, 1], "end": [710, 59], "kind": "commanddeclaration"}, {"full_name": "div_le_div_right'", "code": "@[to_additive sub_le_sub_right]\ntheorem div_le_div_right' (h : a \u2264 b) (c : \u03b1) : a / c \u2264 b / c", "start": [714, 1], "end": [716, 31], "kind": "commanddeclaration"}, {"full_name": "one_le_div'", "code": "@[to_additive (attr := simp) sub_nonneg]\ntheorem one_le_div' : 1 \u2264 a / b \u2194 b \u2264 a", "start": [720, 1], "end": [722, 79], "kind": "commanddeclaration"}, {"full_name": "le_of_sub_nonneg", "code": "alias \u27e8le_of_sub_nonneg, sub_nonneg_of_le\u27e9 := sub_nonneg", "start": [726, 1], "end": [726, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_nonneg_of_le", "code": "alias \u27e8le_of_sub_nonneg, sub_nonneg_of_le\u27e9 := sub_nonneg", "start": [726, 1], "end": [726, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_le_one'", "code": "@[to_additive (attr := simp) sub_nonpos]\ntheorem div_le_one' : a / b \u2264 1 \u2194 a \u2264 b", "start": [730, 1], "end": [732, 79], "kind": "commanddeclaration"}, {"full_name": "le_of_sub_nonpos", "code": "alias \u27e8le_of_sub_nonpos, sub_nonpos_of_le\u27e9 := sub_nonpos", "start": [736, 1], "end": [736, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_nonpos_of_le", "code": "alias \u27e8le_of_sub_nonpos, sub_nonpos_of_le\u27e9 := sub_nonpos", "start": [736, 1], "end": [736, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_div_iff_mul_le", "code": "@[to_additive]\ntheorem le_div_iff_mul_le : a \u2264 c / b \u2194 a * b \u2264 c", "start": [740, 1], "end": [742, 70], "kind": "commanddeclaration"}, {"full_name": "add_le_of_le_sub_right", "code": "alias \u27e8add_le_of_le_sub_right, le_sub_right_of_add_le\u27e9 := le_sub_iff_add_le", "start": [746, 1], "end": [746, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_sub_right_of_add_le", "code": "alias \u27e8add_le_of_le_sub_right, le_sub_right_of_add_le\u27e9 := le_sub_iff_add_le", "start": [746, 1], "end": [746, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_le_iff_le_mul", "code": "@[to_additive]\ntheorem div_le_iff_le_mul : a / c \u2264 b \u2194 a \u2264 b * c", "start": [750, 1], "end": [752, 70], "kind": "commanddeclaration"}, {"full_name": "AddGroup.toHasOrderedSub", "code": "instance (priority := 100) AddGroup.toHasOrderedSub {\u03b1 : Type*} [AddGroup \u03b1] [LE \u03b1]\n    [CovariantClass \u03b1 \u03b1 (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7)] : OrderedSub \u03b1 :=\n  \u27e8fun _ _ _ => sub_le_iff_le_add\u27e9", "start": [759, 1], "end": [761, 35], "kind": "commanddeclaration"}, {"full_name": "div_le_div_iff_left", "code": "@[to_additive (attr := simp)]\ntheorem div_le_div_iff_left (a : \u03b1) : a / b \u2264 a / c \u2194 c \u2264 b", "start": [772, 1], "end": [775, 41], "kind": "commanddeclaration"}, {"full_name": "div_le_div_left'", "code": "@[to_additive sub_le_sub_left]\ntheorem div_le_div_left' (h : a \u2264 b) (c : \u03b1) : c / b \u2264 c / a", "start": [779, 1], "end": [781, 30], "kind": "commanddeclaration"}, {"full_name": "div_le_div_iff'", "code": "@[to_additive sub_le_sub_iff]\ntheorem div_le_div_iff' : a / b \u2264 c / d \u2194 a * d \u2264 c * b", "start": [797, 1], "end": [799, 60], "kind": "commanddeclaration"}, {"full_name": "le_div_iff_mul_le'", "code": "@[to_additive]\ntheorem le_div_iff_mul_le' : b \u2264 c / a \u2194 a * b \u2264 c", "start": [803, 1], "end": [804, 90], "kind": "commanddeclaration"}, {"full_name": "add_le_of_le_sub_left", "code": "alias \u27e8add_le_of_le_sub_left, le_sub_left_of_add_le\u27e9 := le_sub_iff_add_le'", "start": [808, 1], "end": [808, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_sub_left_of_add_le", "code": "alias \u27e8add_le_of_le_sub_left, le_sub_left_of_add_le\u27e9 := le_sub_iff_add_le'", "start": [808, 1], "end": [808, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_le_iff_le_mul'", "code": "@[to_additive]\ntheorem div_le_iff_le_mul' : a / b \u2264 c \u2194 a \u2264 b * c", "start": [812, 1], "end": [813, 90], "kind": "commanddeclaration"}, {"full_name": "le_add_of_sub_left_le", "code": "alias \u27e8le_add_of_sub_left_le, sub_left_le_of_le_add\u27e9 := sub_le_iff_le_add'", "start": [817, 1], "end": [817, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_left_le_of_le_add", "code": "alias \u27e8le_add_of_sub_left_le, sub_left_le_of_le_add\u27e9 := sub_le_iff_le_add'", "start": [817, 1], "end": [817, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_le_div_iff_le_mul", "code": "@[to_additive (attr := simp)]\ntheorem inv_le_div_iff_le_mul : b\u207b\u00b9 \u2264 a / c \u2194 c \u2264 a * b", "start": [821, 1], "end": [823, 49], "kind": "commanddeclaration"}, {"full_name": "inv_le_div_iff_le_mul'", "code": "@[to_additive]\ntheorem inv_le_div_iff_le_mul' : a\u207b\u00b9 \u2264 b / c \u2194 c \u2264 a * b", "start": [827, 1], "end": [828, 100], "kind": "commanddeclaration"}, {"full_name": "div_le_comm", "code": "@[to_additive]\ntheorem div_le_comm : a / b \u2264 c \u2194 a / c \u2264 b", "start": [832, 1], "end": [834, 50], "kind": "commanddeclaration"}, {"full_name": "le_div_comm", "code": "@[to_additive]\ntheorem le_div_comm : a \u2264 b / c \u2194 c \u2264 b / a", "start": [838, 1], "end": [840, 50], "kind": "commanddeclaration"}, {"full_name": "div_le_div''", "code": "@[to_additive sub_le_sub]\ntheorem div_le_div'' (hab : a \u2264 b) (hcd : c \u2264 d) : a / d \u2264 b / c", "start": [850, 1], "end": [853, 28], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_iff_right", "code": "@[to_additive (attr := simp)]\ntheorem div_lt_div_iff_right (c : \u03b1) : a / c < b / c \u2194 a < b", "start": [871, 1], "end": [873, 59], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_right'", "code": "@[to_additive sub_lt_sub_right]\ntheorem div_lt_div_right' (h : a < b) (c : \u03b1) : a / c < b / c", "start": [877, 1], "end": [879, 31], "kind": "commanddeclaration"}, {"full_name": "one_lt_div'", "code": "@[to_additive (attr := simp) sub_pos]\ntheorem one_lt_div' : 1 < a / b \u2194 b < a", "start": [883, 1], "end": [885, 79], "kind": "commanddeclaration"}, {"full_name": "lt_of_sub_pos", "code": "alias \u27e8lt_of_sub_pos, sub_pos_of_lt\u27e9 := sub_pos", "start": [889, 1], "end": [889, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_pos_of_lt", "code": "alias \u27e8lt_of_sub_pos, sub_pos_of_lt\u27e9 := sub_pos", "start": [889, 1], "end": [889, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_lt_one'", "code": "@[to_additive (attr := simp) sub_neg \"For `a - -b = a + b`, see `sub_neg_eq_add`.\"]\ntheorem div_lt_one' : a / b < 1 \u2194 a < b", "start": [893, 1], "end": [895, 79], "kind": "commanddeclaration"}, {"full_name": "lt_of_sub_neg", "code": "alias \u27e8lt_of_sub_neg, sub_neg_of_lt\u27e9 := sub_neg", "start": [899, 1], "end": [899, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_neg_of_lt", "code": "alias \u27e8lt_of_sub_neg, sub_neg_of_lt\u27e9 := sub_neg", "start": [899, 1], "end": [899, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_lt_zero", "code": "alias sub_lt_zero := sub_neg", "start": [903, 1], "end": [903, 29], "kind": "stdtacticaliasalias"}, {"full_name": "lt_div_iff_mul_lt", "code": "@[to_additive]\ntheorem lt_div_iff_mul_lt : a < c / b \u2194 a * b < c", "start": [906, 1], "end": [908, 70], "kind": "commanddeclaration"}, {"full_name": "add_lt_of_lt_sub_right", "code": "alias \u27e8add_lt_of_lt_sub_right, lt_sub_right_of_add_lt\u27e9 := lt_sub_iff_add_lt", "start": [912, 1], "end": [912, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_sub_right_of_add_lt", "code": "alias \u27e8add_lt_of_lt_sub_right, lt_sub_right_of_add_lt\u27e9 := lt_sub_iff_add_lt", "start": [912, 1], "end": [912, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_lt_iff_lt_mul", "code": "@[to_additive]\ntheorem div_lt_iff_lt_mul : a / c < b \u2194 a < b * c", "start": [916, 1], "end": [918, 70], "kind": "commanddeclaration"}, {"full_name": "lt_add_of_sub_right_lt", "code": "alias \u27e8lt_add_of_sub_right_lt, sub_right_lt_of_lt_add\u27e9 := sub_lt_iff_lt_add", "start": [922, 1], "end": [922, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_right_lt_of_lt_add", "code": "alias \u27e8lt_add_of_sub_right_lt, sub_right_lt_of_lt_add\u27e9 := sub_lt_iff_lt_add", "start": [922, 1], "end": [922, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_lt_div_iff_left", "code": "@[to_additive (attr := simp)]\ntheorem div_lt_div_iff_left (a : \u03b1) : a / b < a / c \u2194 c < b", "start": [933, 1], "end": [936, 41], "kind": "commanddeclaration"}, {"full_name": "inv_lt_div_iff_lt_mul", "code": "@[to_additive (attr := simp)]\ntheorem inv_lt_div_iff_lt_mul : a\u207b\u00b9 < b / c \u2194 c < a * b", "start": [940, 1], "end": [942, 68], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_left'", "code": "@[to_additive sub_lt_sub_left]\ntheorem div_lt_div_left' (h : a < b) (c : \u03b1) : c / b < c / a", "start": [946, 1], "end": [948, 30], "kind": "commanddeclaration"}, {"full_name": "div_lt_div_iff'", "code": "@[to_additive sub_lt_sub_iff]\ntheorem div_lt_div_iff' : a / b < c / d \u2194 a * d < c * b", "start": [964, 1], "end": [966, 60], "kind": "commanddeclaration"}, {"full_name": "lt_div_iff_mul_lt'", "code": "@[to_additive]\ntheorem lt_div_iff_mul_lt' : b < c / a \u2194 a * b < c", "start": [970, 1], "end": [971, 90], "kind": "commanddeclaration"}, {"full_name": "add_lt_of_lt_sub_left", "code": "alias \u27e8add_lt_of_lt_sub_left, lt_sub_left_of_add_lt\u27e9 := lt_sub_iff_add_lt'", "start": [975, 1], "end": [975, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lt_sub_left_of_add_lt", "code": "alias \u27e8add_lt_of_lt_sub_left, lt_sub_left_of_add_lt\u27e9 := lt_sub_iff_add_lt'", "start": [975, 1], "end": [975, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "div_lt_iff_lt_mul'", "code": "@[to_additive]\ntheorem div_lt_iff_lt_mul' : a / b < c \u2194 a < b * c", "start": [979, 1], "end": [980, 90], "kind": "commanddeclaration"}, {"full_name": "lt_add_of_sub_left_lt", "code": "alias \u27e8lt_add_of_sub_left_lt, sub_left_lt_of_lt_add\u27e9 := sub_lt_iff_lt_add'", "start": [984, 1], "end": [984, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "sub_left_lt_of_lt_add", "code": "alias \u27e8lt_add_of_sub_left_lt, sub_left_lt_of_lt_add\u27e9 := sub_lt_iff_lt_add'", "start": [984, 1], "end": [984, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "inv_lt_div_iff_lt_mul'", "code": "@[to_additive]\ntheorem inv_lt_div_iff_lt_mul' : b\u207b\u00b9 < a / c \u2194 c < a * b", "start": [988, 1], "end": [990, 49], "kind": "commanddeclaration"}, {"full_name": "div_lt_comm", "code": "@[to_additive]\ntheorem div_lt_comm : a / b < c \u2194 a / c < b", "start": [994, 1], "end": [996, 50], "kind": "commanddeclaration"}, {"full_name": "lt_div_comm", "code": "@[to_additive]\ntheorem lt_div_comm : a < b / c \u2194 c < b / a", "start": [1000, 1], "end": [1002, 50], "kind": "commanddeclaration"}, {"full_name": "div_lt_div''", "code": "@[to_additive sub_lt_sub]\ntheorem div_lt_div'' (hab : a < b) (hcd : c < d) : a / d < b / c", "start": [1012, 1], "end": [1015, 39], "kind": "commanddeclaration"}, {"full_name": "cmp_div_one'", "code": "@[to_additive (attr := simp) cmp_sub_zero]\ntheorem cmp_div_one' [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] (a b : \u03b1) :\n    cmp (a / b) 1 = cmp a b", "start": [1027, 1], "end": [1029, 88], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_one_lt_lt_mul", "code": "@[to_additive]\ntheorem le_of_forall_one_lt_lt_mul (h : \u2200 \u03b5 : \u03b1, 1 < \u03b5 \u2192 a < b * \u03b5) : a \u2264 b", "start": [1039, 1], "end": [1041, 85], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_one_lt_lt_mul", "code": "@[to_additive]\ntheorem le_iff_forall_one_lt_lt_mul : a \u2264 b \u2194 \u2200 \u03b5, 1 < \u03b5 \u2192 a < b * \u03b5", "start": [1045, 1], "end": [1047, 68], "kind": "commanddeclaration"}, {"full_name": "div_le_inv_mul_iff", "code": "@[to_additive]\ntheorem div_le_inv_mul_iff [CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] :\n    a / b \u2264 a\u207b\u00b9 * b \u2194 a \u2264 b", "start": [1053, 1], "end": [1059, 23], "kind": "commanddeclaration"}, {"full_name": "div_le_div_flip", "code": "@[to_additive, simp]\ntheorem div_le_div_flip {\u03b1 : Type*} [CommGroup \u03b1] [LinearOrder \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} : a / b \u2264 b / a \u2194 a \u2264 b", "start": [1066, 1], "end": [1070, 27], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommGroup", "code": "class LinearOrderedAddCommGroup (\u03b1 : Type u) extends OrderedAddCommGroup \u03b1, LinearOrder \u03b1", "start": [1083, 1], "end": [1086, 90], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommGroupWithTop", "code": "class LinearOrderedAddCommGroupWithTop (\u03b1 : Type*) extends LinearOrderedAddCommMonoidWithTop \u03b1,\n  SubNegMonoid \u03b1, Nontrivial \u03b1 where\n  protected neg_top : -(\u22a4 : \u03b1) = \u22a4\n  protected add_neg_cancel : \u2200 a : \u03b1, a \u2260 \u22a4 \u2192 a + -a = 0", "start": [1089, 1], "end": [1094, 57], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommGroup", "code": "@[to_additive]\nclass LinearOrderedCommGroup (\u03b1 : Type u) extends OrderedCommGroup \u03b1, LinearOrder \u03b1", "start": [1097, 1], "end": [1101, 84], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommGroup.mul_lt_mul_left'", "code": "@[to_additive LinearOrderedAddCommGroup.add_lt_add_left]\ntheorem LinearOrderedCommGroup.mul_lt_mul_left' (a b : \u03b1) (h : a < b) (c : \u03b1) : c * a < c * b", "start": [1108, 1], "end": [1110, 30], "kind": "commanddeclaration"}, {"full_name": "eq_one_of_inv_eq'", "code": "@[to_additive eq_zero_of_neg_eq]\ntheorem eq_one_of_inv_eq' (h : a\u207b\u00b9 = a) : a = 1", "start": [1114, 1], "end": [1123, 25], "kind": "commanddeclaration"}, {"full_name": "exists_one_lt'", "code": "@[to_additive exists_zero_lt]\ntheorem exists_one_lt' [Nontrivial \u03b1] : \u2203 a : \u03b1, 1 < a", "start": [1127, 1], "end": [1132, 17], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommGroup.to_noMaxOrder", "code": "@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMaxOrder [Nontrivial \u03b1] : NoMaxOrder \u03b1 :=\n  \u27e8by\n    obtain \u27e8y, hy\u27e9 : \u2203 a : \u03b1, 1 < a := exists_one_lt'\n    exact fun a => \u27e8a * y, lt_mul_of_one_lt_right' a hy\u27e9\u27e9", "start": [1137, 1], "end": [1141, 58], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommGroup.to_noMinOrder", "code": "@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.to_noMinOrder [Nontrivial \u03b1] : NoMinOrder \u03b1 :=\n  \u27e8by\n    obtain \u27e8y, hy\u27e9 : \u2203 a : \u03b1, 1 < a := exists_one_lt'\n    exact fun a => \u27e8a / y, (div_lt_self_iff a).mpr hy\u27e9\u27e9", "start": [1146, 1], "end": [1150, 56], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid", "code": "@[to_additive]\ninstance (priority := 100) LinearOrderedCommGroup.toLinearOrderedCancelCommMonoid\n    [LinearOrderedCommGroup \u03b1] : LinearOrderedCancelCommMonoid \u03b1 :=\n{ \u2039LinearOrderedCommGroup \u03b1\u203a, OrderedCommGroup.toOrderedCancelCommMonoid with }", "start": [1155, 1], "end": [1158, 80], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.PositiveCone", "code": "structure PositiveCone (\u03b1 : Type*) [AddCommGroup \u03b1] where\n  nonneg : \u03b1 \u2192 Prop\n  pos : \u03b1 \u2192 Prop := fun a => nonneg a \u2227 \u00acnonneg (-a)\n  pos_iff : \u2200 a, pos a \u2194 nonneg a \u2227 \u00acnonneg (-a) := by intros; rfl\n  zero_nonneg : nonneg 0\n  add_nonneg : \u2200 {a b}, nonneg a \u2192 nonneg b \u2192 nonneg (a + b)\n  nonneg_antisymm : \u2200 {a}, nonneg a \u2192 nonneg (-a) \u2192 a = 0", "start": [1166, 1], "end": [1176, 58], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.TotalPositiveCone", "code": "structure TotalPositiveCone (\u03b1 : Type*) [AddCommGroup \u03b1] extends PositiveCone \u03b1 where\n  \n  nonnegDecidable : DecidablePred nonneg\n  \n  nonneg_total : \u2200 a : \u03b1, nonneg a \u2228 nonneg (-a)", "start": [1179, 1], "end": [1186, 49], "kind": "commanddeclaration"}, {"full_name": "OrderedAddCommGroup.mkOfPositiveCone", "code": "def mkOfPositiveCone {\u03b1 : Type*} [AddCommGroup \u03b1] (C : PositiveCone \u03b1) : OrderedAddCommGroup \u03b1 :=\n  { \u2039AddCommGroup \u03b1\u203a with\n    le := fun a b => C.nonneg (b - a),\n    lt := fun a b => C.pos (b - a),\n    lt_iff_le_not_le := fun a b => by simp [C.pos_iff],\n    le_refl := fun a => by simp [C.zero_nonneg],\n    le_trans := fun a b c nab nbc => by simpa [\u2190 sub_add_sub_cancel] using C.add_nonneg nbc nab,\n    le_antisymm := fun a b nab nba =>\n      eq_of_sub_eq_zero <| C.nonneg_antisymm nba (by rwa [neg_sub]),\n    add_le_add_left := fun a b nab c => by simpa using nab }", "start": [1199, 1], "end": [1210, 61], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommGroup.mkOfPositiveCone", "code": "def mkOfPositiveCone {\u03b1 : Type*} [AddCommGroup \u03b1] (C : TotalPositiveCone \u03b1) :\n    LinearOrderedAddCommGroup \u03b1 :=\n  { OrderedAddCommGroup.mkOfPositiveCone C.toPositiveCone with\n    le_total := fun a b => by simpa [neg_sub] using C.nonneg_total (b - a)\n    decidableLE := fun a b => C.nonnegDecidable _ }", "start": [1219, 1], "end": [1227, 52], "kind": "commanddeclaration"}, {"full_name": "inv_le_inv'", "code": "@[to_additive neg_le_neg]\ntheorem inv_le_inv' : a \u2264 b \u2192 b\u207b\u00b9 \u2264 a\u207b\u00b9", "start": [1238, 1], "end": [1241, 29], "kind": "commanddeclaration"}, {"full_name": "inv_lt_inv'", "code": "@[to_additive neg_lt_neg]\ntheorem inv_lt_inv' : a < b \u2192 b\u207b\u00b9 < a\u207b\u00b9", "start": [1245, 1], "end": [1248, 29], "kind": "commanddeclaration"}, {"full_name": "inv_lt_one_of_one_lt", "code": "@[to_additive]\ntheorem inv_lt_one_of_one_lt : 1 < a \u2192 a\u207b\u00b9 < 1", "start": [1253, 1], "end": [1255, 28], "kind": "commanddeclaration"}, {"full_name": "inv_le_one_of_one_le", "code": "@[to_additive]\ntheorem inv_le_one_of_one_le : 1 \u2264 a \u2192 a\u207b\u00b9 \u2264 1", "start": [1260, 1], "end": [1262, 18], "kind": "commanddeclaration"}, {"full_name": "one_le_inv_of_le_one", "code": "@[to_additive neg_nonneg_of_nonpos]\ntheorem one_le_inv_of_le_one : a \u2264 1 \u2192 1 \u2264 a\u207b\u00b9", "start": [1266, 1], "end": [1268, 18], "kind": "commanddeclaration"}, {"full_name": "Monotone.inv", "code": "@[to_additive]\ntheorem Monotone.inv (hf : Monotone f) : Antitone fun x => (f x)\u207b\u00b9", "start": [1279, 1], "end": [1281, 28], "kind": "commanddeclaration"}, {"full_name": "Antitone.inv", "code": "@[to_additive]\ntheorem Antitone.inv (hf : Antitone f) : Monotone fun x => (f x)\u207b\u00b9", "start": [1285, 1], "end": [1287, 28], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.inv", "code": "@[to_additive]\ntheorem MonotoneOn.inv (hf : MonotoneOn f s) : AntitoneOn (fun x => (f x)\u207b\u00b9) s", "start": [1291, 1], "end": [1293, 55], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.inv", "code": "@[to_additive]\ntheorem AntitoneOn.inv (hf : AntitoneOn f s) : MonotoneOn (fun x => (f x)\u207b\u00b9) s", "start": [1297, 1], "end": [1299, 55], "kind": "commanddeclaration"}, {"full_name": "StrictMono.inv", "code": "@[to_additive]\ntheorem StrictMono.inv (hf : StrictMono f) : StrictAnti fun x => (f x)\u207b\u00b9", "start": [1310, 1], "end": [1312, 28], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.inv", "code": "@[to_additive]\ntheorem StrictAnti.inv (hf : StrictAnti f) : StrictMono fun x => (f x)\u207b\u00b9", "start": [1316, 1], "end": [1318, 28], "kind": "commanddeclaration"}, {"full_name": "StrictMonoOn.inv", "code": "@[to_additive]\ntheorem StrictMonoOn.inv (hf : StrictMonoOn f s) : StrictAntiOn (fun x => (f x)\u207b\u00b9) s", "start": [1322, 1], "end": [1324, 55], "kind": "commanddeclaration"}, {"full_name": "StrictAntiOn.inv", "code": "@[to_additive]\ntheorem StrictAntiOn.inv (hf : StrictAntiOn f s) : StrictMonoOn (fun x => (f x)\u207b\u00b9) s", "start": [1328, 1], "end": [1330, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Pi/Algebra.lean", "imports": ["Mathlib/Logic/Unique.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Data/Prod/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Sum/Basic.lean", "Mathlib/Algebra/Group/Defs.lean"], "premises": [{"full_name": "Pi.instOne", "code": "@[to_additive]\ninstance instOne [\u2200 i, One <| f i] : One (\u2200 i : I, f i) :=\n  \u27e8fun _ => 1\u27e9", "start": [40, 1], "end": [42, 15], "kind": "commanddeclaration"}, {"full_name": "Pi.one_apply", "code": "@[to_additive (attr := simp)]\ntheorem one_apply [\u2200 i, One <| f i] : (1 : \u2200 i, f i) i = 1", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.one_def", "code": "@[to_additive]\ntheorem one_def [\u2200 i, One <| f i] : (1 : \u2200 i, f i) = fun _ => 1", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.const_one", "code": "@[to_additive (attr := simp)]\ntheorem const_one [One \u03b2] : const \u03b1 (1 : \u03b2) = 1", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.one_comp", "code": "@[to_additive (attr := simp)]\ntheorem one_comp [One \u03b3] (x : \u03b1 \u2192 \u03b2) : (1 : \u03b2 \u2192 \u03b3) \u2218 x = 1", "start": [64, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.comp_one", "code": "@[to_additive (attr := simp)]\ntheorem comp_one [One \u03b2] (x : \u03b2 \u2192 \u03b3) : x \u2218 (1 : \u03b1 \u2192 \u03b2) = const \u03b1 (x 1)", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instMul", "code": "@[to_additive]\ninstance instMul [\u2200 i, Mul <| f i] : Mul (\u2200 i : I, f i) :=\n  \u27e8fun f g i => f i * g i\u27e9", "start": [76, 1], "end": [78, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply [\u2200 i, Mul <| f i] : (x * y) i = x i * y i", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.mul_def", "code": "@[to_additive]\ntheorem mul_def [\u2200 i, Mul <| f i] : x * y = fun i => x i * y i", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.const_mul", "code": "@[to_additive (attr := simp)]\ntheorem const_mul [Mul \u03b2] (a b : \u03b2) : const \u03b1 a * const \u03b1 b = const \u03b1 (a * b)", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.mul_comp", "code": "@[to_additive]\ntheorem mul_comp [Mul \u03b3] (x y : \u03b2 \u2192 \u03b3) (z : \u03b1 \u2192 \u03b2) : (x * y) \u2218 z = x \u2218 z * y \u2218 z", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instSMul", "code": "@[to_additive]\ninstance instSMul [\u2200 i, SMul \u03b1 <| f i] : SMul \u03b1 (\u2200 i : I, f i) :=\n  \u27e8fun s x => fun i => s \u2022 x i\u27e9", "start": [106, 1], "end": [108, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.instPow", "code": "@[to_additive existing instSMul]\ninstance instPow [\u2200 i, Pow (f i) \u03b2] : Pow (\u2200 i, f i) \u03b2 :=\n  \u27e8fun x b i => x i ^ b\u27e9", "start": [112, 1], "end": [114, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.pow_apply", "code": "@[to_additive (attr := simp, to_additive) (reorder := 5 6) smul_apply]\ntheorem pow_apply [\u2200 i, Pow (f i) \u03b2] (x : \u2200 i, f i) (b : \u03b2) (i : I) : (x ^ b) i = x i ^ b", "start": [116, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.pow_def", "code": "@[to_additive (attr := to_additive) (reorder := 5 6) smul_def]\ntheorem pow_def [\u2200 i, Pow (f i) \u03b2] (x : \u2200 i, f i) (b : \u03b2) : x ^ b = fun i => x i ^ b", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.const_pow", "code": "@[to_additive (attr := simp, to_additive) (reorder := 2 3, 5 6) smul_const]\ntheorem const_pow [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : const I a ^ b = const I (a ^ b)", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.pow_comp", "code": "@[to_additive (attr := to_additive) (reorder := 6 7) smul_comp]\ntheorem pow_comp [Pow \u03b3 \u03b1] (x : \u03b2 \u2192 \u03b3) (a : \u03b1) (y : I \u2192 \u03b2) : (x ^ a) \u2218 y = x \u2218 y ^ a", "start": [137, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.bit0_apply", "code": "@[simp, deprecated]\ntheorem bit0_apply [\u2200 i, Add <| f i] : (bit0 x) i = bit0 (x i)", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.bit1_apply", "code": "@[simp, deprecated]\ntheorem bit1_apply [\u2200 i, Add <| f i] [\u2200 i, One <| f i] : (bit1 x) i = bit1 (x i)", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instInv", "code": "@[to_additive]\ninstance instInv [\u2200 i, Inv <| f i] : Inv (\u2200 i : I, f i) :=\n  \u27e8fun f i => (f i)\u207b\u00b9\u27e9", "start": [164, 1], "end": [166, 23], "kind": "commanddeclaration"}, {"full_name": "Pi.inv_apply", "code": "@[to_additive (attr := simp)]\ntheorem inv_apply [\u2200 i, Inv <| f i] : x\u207b\u00b9 i = (x i)\u207b\u00b9", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.inv_def", "code": "@[to_additive]\ntheorem inv_def [\u2200 i, Inv <| f i] : x\u207b\u00b9 = fun i => (x i)\u207b\u00b9", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.const_inv", "code": "@[to_additive]\ntheorem const_inv [Inv \u03b2] (a : \u03b2) : (const \u03b1 a)\u207b\u00b9 = const \u03b1 a\u207b\u00b9", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.inv_comp", "code": "@[to_additive]\ntheorem inv_comp [Inv \u03b3] (x : \u03b2 \u2192 \u03b3) (y : \u03b1 \u2192 \u03b2) : x\u207b\u00b9 \u2218 y = (x \u2218 y)\u207b\u00b9", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instDiv", "code": "@[to_additive]\ninstance instDiv [\u2200 i, Div <| f i] : Div (\u2200 i : I, f i) :=\n  \u27e8fun f g i => f i / g i\u27e9", "start": [194, 1], "end": [196, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.div_apply", "code": "@[to_additive (attr := simp)]\ntheorem div_apply [\u2200 i, Div <| f i] : (x / y) i = x i / y i", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.div_def", "code": "@[to_additive]\ntheorem div_def [\u2200 i, Div <| f i] : x / y = fun i => x i / y i", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.div_comp", "code": "@[to_additive]\ntheorem div_comp [Div \u03b3] (x y : \u03b2 \u2192 \u03b3) (z : \u03b1 \u2192 \u03b2) : (x / y) \u2218 z = x \u2218 z / y \u2218 z", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.const_div", "code": "@[to_additive (attr := simp)]\ntheorem const_div [Div \u03b2] (a b : \u03b2) : const \u03b1 a / const \u03b1 b = const \u03b1 (a / b)", "start": [218, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle", "code": "@[to_additive \"The function supported at `i`, with value `x` there, and `0` elsewhere.\"]\ndef mulSingle (i : I) (x : f i) : \u2200 (j : I), f j :=\n  Function.update 1 i x", "start": [230, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_eq_same", "code": "@[to_additive (attr := simp)]\ntheorem mulSingle_eq_same (i : I) (x : f i) : mulSingle i x i = x", "start": [237, 1], "end": [239, 29], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_eq_of_ne", "code": "@[to_additive (attr := simp)]\ntheorem mulSingle_eq_of_ne {i i' : I} (h : i' \u2260 i) (x : f i) : mulSingle i x i' = 1", "start": [243, 1], "end": [245, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_eq_of_ne'", "code": "@[to_additive (attr := simp)\n  \"Abbreviation for `single_eq_of_ne h.symm`, for ease of use by `simp`.\"]\ntheorem mulSingle_eq_of_ne' {i i' : I} (h : i \u2260 i') (x : f i) : mulSingle i x i' = 1", "start": [249, 1], "end": [253, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_one", "code": "@[to_additive (attr := simp)]\ntheorem mulSingle_one (i : I) : mulSingle i (1 : f i) = 1", "start": [257, 1], "end": [259, 30], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_apply", "code": "@[to_additive \"On non-dependent functions, `Pi.single` can be expressed as an `ite`\"]\ntheorem mulSingle_apply [One \u03b2] (i : I) (x : \u03b2) (i' : I) :\n    (mulSingle i x : I \u2192 \u03b2) i' = if i' = i then x else 1", "start": [267, 1], "end": [271, 43], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_comm", "code": "@[to_additive \"On non-dependent functions, `Pi.single` is symmetric in the two indices.\"]\ntheorem mulSingle_comm [One \u03b2] (i : I) (x : \u03b2) (i' : I) :\n    (mulSingle i x : I \u2192 \u03b2) i' = (mulSingle i' x : I \u2192 \u03b2) i", "start": [276, 1], "end": [280, 34], "kind": "commanddeclaration"}, {"full_name": "Pi.apply_mulSingle", "code": "@[to_additive]\ntheorem apply_mulSingle (f' : \u2200 i, f i \u2192 g i) (hf' : \u2200 i, f' i 1 = 1) (i : I) (x : f i) (j : I) :\n    f' j (mulSingle i x j) = mulSingle i (f' i x) j", "start": [284, 1], "end": [287, 83], "kind": "commanddeclaration"}, {"full_name": "Pi.apply_mulSingle\u2082", "code": "@[to_additive apply_single\u2082]\ntheorem apply_mulSingle\u2082 (f' : \u2200 i, f i \u2192 g i \u2192 h i) (hf' : \u2200 i, f' i 1 1 = 1) (i : I)\n    (x : f i) (y : g i) (j : I) :\n    f' j (mulSingle i x j) (mulSingle i y j) = mulSingle i (f' i x y) j", "start": [291, 1], "end": [298, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_op", "code": "@[to_additive]\ntheorem mulSingle_op {g : I \u2192 Type*} [\u2200 i, One (g i)] (op : \u2200 i, f i \u2192 g i)\n    (h : \u2200 i, op i 1 = 1) (i : I) (x : f i) :\n    mulSingle i (op i x) = fun j => op j (mulSingle i x j)", "start": [302, 1], "end": [306, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_op\u2082", "code": "@[to_additive]\ntheorem mulSingle_op\u2082 {g\u2081 g\u2082 : I \u2192 Type*} [\u2200 i, One (g\u2081 i)] [\u2200 i, One (g\u2082 i)]\n    (op : \u2200 i, g\u2081 i \u2192 g\u2082 i \u2192 f i) (h : \u2200 i, op i 1 1 = 1) (i : I) (x\u2081 : g\u2081 i) (x\u2082 : g\u2082 i) :\n    mulSingle i (op i x\u2081 x\u2082) = fun j => op j (mulSingle i x\u2081 j) (mulSingle i x\u2082 j)", "start": [310, 1], "end": [314, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_injective", "code": "@[to_additive]\ntheorem mulSingle_injective (i : I) : Function.Injective (mulSingle i : f i \u2192 \u2200 i, f i)", "start": [320, 1], "end": [322, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSingle_inj", "code": "@[to_additive (attr := simp)]\ntheorem mulSingle_inj (i : I) {x y : f i} : mulSingle i x = mulSingle i y \u2194 x = y", "start": [326, 1], "end": [328, 38], "kind": "commanddeclaration"}, {"full_name": "Pi.prod", "code": "@[simp]\nprotected def prod (f' : \u2200 i, f i) (g' : \u2200 i, g i) (i : I) : f i \u00d7 g i :=\n  (f' i, g' i)", "start": [334, 1], "end": [337, 15], "kind": "commanddeclaration"}, {"full_name": "Pi.prod_fst_snd", "code": "theorem prod_fst_snd : Pi.prod (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) = id", "start": [342, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.prod_snd_fst", "code": "theorem prod_snd_fst : Pi.prod (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) = Prod.swap", "start": [348, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "Function.extend_one", "code": "@[to_additive]\ntheorem extend_one [One \u03b3] (f : \u03b1 \u2192 \u03b2) : Function.extend f (1 : \u03b1 \u2192 \u03b3) (1 : \u03b2 \u2192 \u03b3) = 1", "start": [358, 1], "end": [360, 36], "kind": "commanddeclaration"}, {"full_name": "Function.extend_mul", "code": "@[to_additive]\ntheorem extend_mul [Mul \u03b3] (f : \u03b1 \u2192 \u03b2) (g\u2081 g\u2082 : \u03b1 \u2192 \u03b3) (e\u2081 e\u2082 : \u03b2 \u2192 \u03b3) :\n    Function.extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) = Function.extend f g\u2081 e\u2081 * Function.extend f g\u2082 e\u2082", "start": [364, 1], "end": [369, 87], "kind": "commanddeclaration"}, {"full_name": "Function.extend_inv", "code": "@[to_additive]\ntheorem extend_inv [Inv \u03b3] (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (e : \u03b2 \u2192 \u03b3) :\n    Function.extend f g\u207b\u00b9 e\u207b\u00b9 = (Function.extend f g e)\u207b\u00b9", "start": [378, 1], "end": [383, 71], "kind": "commanddeclaration"}, {"full_name": "Function.extend_div", "code": "@[to_additive]\ntheorem extend_div [Div \u03b3] (f : \u03b1 \u2192 \u03b2) (g\u2081 g\u2082 : \u03b1 \u2192 \u03b3) (e\u2081 e\u2082 : \u03b2 \u2192 \u03b3) :\n    Function.extend f (g\u2081 / g\u2082) (e\u2081 / e\u2082) = Function.extend f g\u2081 e\u2081 / Function.extend f g\u2082 e\u2082", "start": [392, 1], "end": [397, 42], "kind": "commanddeclaration"}, {"full_name": "Function.surjective_pi_map", "code": "theorem surjective_pi_map {F : \u2200 i, f i \u2192 g i} (hF : \u2200 i, Surjective (F i)) :\n    Surjective fun x : \u2200 i, f i => fun i => F i (x i)", "start": [408, 1], "end": [410, 75], "kind": "commanddeclaration"}, {"full_name": "Function.injective_pi_map", "code": "theorem injective_pi_map {F : \u2200 i, f i \u2192 g i} (hF : \u2200 i, Injective (F i)) :\n    Injective fun x : \u2200 i, f i => fun i => F i (x i)", "start": [413, 1], "end": [415, 59], "kind": "commanddeclaration"}, {"full_name": "Function.bijective_pi_map", "code": "theorem bijective_pi_map {F : \u2200 i, f i \u2192 g i} (hF : \u2200 i, Bijective (F i)) :\n    Bijective fun x : \u2200 i, f i => fun i => F i (x i)", "start": [418, 1], "end": [420, 93], "kind": "commanddeclaration"}, {"full_name": "uniqueOfSurjectiveOne", "code": "@[to_additive \"If the zero function is surjective, the codomain is trivial.\"]\ndef uniqueOfSurjectiveOne (\u03b1 : Type*) {\u03b2 : Type*} [One \u03b2] (h : Function.Surjective (1 : \u03b1 \u2192 \u03b2)) :\n    Unique \u03b2 :=\n  h.uniqueOfSurjectiveConst \u03b1 (1 : \u03b2)", "start": [425, 1], "end": [429, 38], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.pi_mulSingle_eq", "code": "@[to_additive]\ntheorem Subsingleton.pi_mulSingle_eq {\u03b1 : Type*} [DecidableEq I] [Subsingleton I] [One \u03b1]\n    (i : I) (x : \u03b1) : Pi.mulSingle i x = fun _ => x", "start": [433, 1], "end": [436, 70], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_one_one", "code": "@[to_additive (attr := simp)]\ntheorem elim_one_one [One \u03b3] : Sum.elim (1 : \u03b1 \u2192 \u03b3) (1 : \u03b2 \u2192 \u03b3) = 1", "start": [444, 1], "end": [446, 25], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_mulSingle_one", "code": "@[to_additive (attr := simp)]\ntheorem elim_mulSingle_one [DecidableEq \u03b1] [DecidableEq \u03b2] [One \u03b3] (i : \u03b1) (c : \u03b3) :\n    Sum.elim (Pi.mulSingle i c) (1 : \u03b2 \u2192 \u03b3) = Pi.mulSingle (Sum.inl i) c", "start": [450, 1], "end": [453, 63], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_one_mulSingle", "code": "@[to_additive (attr := simp)]\ntheorem elim_one_mulSingle [DecidableEq \u03b1] [DecidableEq \u03b2] [One \u03b3] (i : \u03b2) (c : \u03b3) :\n    Sum.elim (1 : \u03b1 \u2192 \u03b3) (Pi.mulSingle i c) = Pi.mulSingle (Sum.inr i) c", "start": [455, 1], "end": [458, 64], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_inv_inv", "code": "@[to_additive]\ntheorem elim_inv_inv [Inv \u03b3] : Sum.elim a\u207b\u00b9 b\u207b\u00b9 = (Sum.elim a b)\u207b\u00b9", "start": [464, 1], "end": [466, 35], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_mul_mul", "code": "@[to_additive]\ntheorem elim_mul_mul [Mul \u03b3] : Sum.elim (a * a') (b * b') = Sum.elim a b * Sum.elim a' b'", "start": [470, 1], "end": [473, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.elim_div_div", "code": "@[to_additive]\ntheorem elim_div_div [Div \u03b3] : Sum.elim (a / a') (b / b') = Sum.elim a b / Sum.elim a' b'", "start": [477, 1], "end": [480, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Opposites.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Logic/IsEmpty.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/Defs.lean", "Mathlib/Logic/Nontrivial/Basic.lean"], "premises": [{"full_name": "PreOpposite", "code": "structure PreOpposite (\u03b1 : Type u) : Type u where\n   op' ::\n   unop' : \u03b1", "start": [51, 1], "end": [61, 74], "kind": "commanddeclaration"}, {"full_name": "MulOpposite", "code": "@[to_additive\n      \"Additive opposite of a type. This type inherits all multiplicative structures on `\u03b1` and\n      reverses left and right in addition.\"]\ndef MulOpposite (\u03b1 : Type u) : Type u :=\n  PreOpposite \u03b1", "start": [63, 1], "end": [69, 16], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op", "code": "@[to_additive \"The element of `\u03b1\u1d43\u1d52\u1d56` that represents `x : \u03b1`.\"]\ndef op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56 :=\n  PreOpposite.op'", "start": [84, 1], "end": [87, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop", "code": "@[to_additive \"The element of `\u03b1` represented by `x : \u03b1\u1d43\u1d52\u1d56`.\"]\ndef unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1 :=\n  PreOpposite.unop'", "start": [91, 1], "end": [94, 20], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_op", "code": "@[to_additive (attr := simp)]\ntheorem unop_op (x : \u03b1) : unop (op x) = x", "start": [98, 1], "end": [99, 49], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_unop", "code": "@[to_additive (attr := simp)]\ntheorem op_unop (x : \u03b1\u1d50\u1d52\u1d56) : op (unop x) = x", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_comp_unop", "code": "@[to_additive (attr := simp)]\ntheorem op_comp_unop : (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56) \u2218 unop = id", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_comp_op", "code": "@[to_additive (attr := simp)]\ntheorem unop_comp_op : (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1) \u2218 op = id", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.rec'", "code": "@[to_additive (attr := simp, elab_as_elim)\n  \"A recursor for `AddOpposite`. Use as `induction x using AddOpposite.rec'`.\"]\nprotected def rec' {F : \u2200 _ : \u03b1\u1d50\u1d52\u1d56, Sort v} (h : \u2200 X, F (op X)) : \u2200 X, F X := fun X => h (unop X)", "start": [121, 1], "end": [124, 98], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opEquiv", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }) apply symm_apply)\n  \"The canonical bijection between `\u03b1` and `\u03b1\u1d43\u1d52\u1d56`.\"]\ndef opEquiv : \u03b1 \u2243 \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8op, unop, unop_op, op_unop\u27e9", "start": [128, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_bijective", "code": "@[to_additive]\ntheorem op_bijective : Bijective (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56)", "start": [138, 1], "end": [140, 20], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_bijective", "code": "@[to_additive]\ntheorem unop_bijective : Bijective (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)", "start": [144, 1], "end": [146, 25], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_injective", "code": "@[to_additive]\ntheorem op_injective : Injective (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56)", "start": [150, 1], "end": [152, 25], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_surjective", "code": "@[to_additive]\ntheorem op_surjective : Surjective (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56)", "start": [156, 1], "end": [158, 26], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_injective", "code": "@[to_additive]\ntheorem unop_injective : Injective (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)", "start": [162, 1], "end": [164, 27], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_surjective", "code": "@[to_additive]\ntheorem unop_surjective : Surjective (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)", "start": [168, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_inj", "code": "@[to_additive (attr := simp)]\ntheorem op_inj {x y : \u03b1} : op x = op y \u2194 x = y", "start": [174, 1], "end": [175, 88], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_inj", "code": "@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_inj {x y : \u03b1\u1d50\u1d52\u1d56} : unop x = unop y \u2194 x = y", "start": [179, 1], "end": [181, 24], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nontrivial", "code": "@[to_additive]\ninstance nontrivial [Nontrivial \u03b1] : Nontrivial \u03b1\u1d50\u1d52\u1d56 :=\n  op_injective.nontrivial", "start": [189, 1], "end": [191, 26], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.inhabited", "code": "@[to_additive]\ninstance inhabited [Inhabited \u03b1] : Inhabited \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8op default\u27e9", "start": [193, 1], "end": [195, 15], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.subsingleton", "code": "@[to_additive]\ninstance subsingleton [Subsingleton \u03b1] : Subsingleton \u03b1\u1d50\u1d52\u1d56 :=\n  unop_injective.subsingleton", "start": [197, 1], "end": [199, 30], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unique", "code": "@[to_additive]\ninstance unique [Unique \u03b1] : Unique \u03b1\u1d50\u1d52\u1d56 :=\n  Unique.mk' _", "start": [201, 1], "end": [203, 15], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.isEmpty", "code": "@[to_additive]\ninstance isEmpty [IsEmpty \u03b1] : IsEmpty \u03b1\u1d50\u1d52\u1d56 :=\n  Function.isEmpty unop", "start": [205, 1], "end": [207, 24], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.zero", "code": "instance zero [Zero \u03b1] : Zero \u03b1\u1d50\u1d52\u1d56 where zero := op 0", "start": [209, 1], "end": [209, 54], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.one", "code": "@[to_additive]\ninstance one [One \u03b1] : One \u03b1\u1d50\u1d52\u1d56 where one := op 1", "start": [211, 1], "end": [212, 50], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.add", "code": "instance add [Add \u03b1] : Add \u03b1\u1d50\u1d52\u1d56 where add x y := op (unop x + unop y)", "start": [214, 1], "end": [214, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.sub", "code": "instance sub [Sub \u03b1] : Sub \u03b1\u1d50\u1d52\u1d56 where sub x y := op (unop x - unop y)", "start": [216, 1], "end": [216, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.neg", "code": "instance neg [Neg \u03b1] : Neg \u03b1\u1d50\u1d52\u1d56 where neg x := op $ -unop x", "start": [218, 1], "end": [218, 60], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.involutiveNeg", "code": "instance involutiveNeg [InvolutiveNeg \u03b1] : InvolutiveNeg \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.neg \u03b1 with neg_neg := fun _ => unop_injective $ neg_neg _ }", "start": [220, 1], "end": [221, 76], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.mul", "code": "@[to_additive]\ninstance mul [Mul \u03b1] : Mul \u03b1\u1d50\u1d52\u1d56 where mul x y := op (unop y * unop x)", "start": [223, 1], "end": [224, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.inv", "code": "@[to_additive]\ninstance inv [Inv \u03b1] : Inv \u03b1\u1d50\u1d52\u1d56 where inv x := op $ (unop x)\u207b\u00b9", "start": [226, 1], "end": [227, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.involutiveInv", "code": "@[to_additive]\ninstance involutiveInv [InvolutiveInv \u03b1] : InvolutiveInv \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.inv \u03b1 with inv_inv := fun _ => unop_injective $ inv_inv _ }", "start": [229, 1], "end": [231, 76], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.smul", "code": "@[to_additive]\ninstance smul (R : Type*) [SMul R \u03b1] : SMul R \u03b1\u1d50\u1d52\u1d56 where smul c x := op (c \u2022 unop x)", "start": [233, 1], "end": [234, 85], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_zero", "code": "@[simp]\ntheorem op_zero [Zero \u03b1] : op (0 : \u03b1) = 0", "start": [238, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_zero", "code": "@[simp]\ntheorem unop_zero [Zero \u03b1] : unop (0 : \u03b1\u1d50\u1d52\u1d56) = 0", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_one", "code": "@[to_additive (attr := simp)]\ntheorem op_one [One \u03b1] : op (1 : \u03b1) = 1", "start": [248, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_one", "code": "@[to_additive (attr := simp)]\ntheorem unop_one [One \u03b1] : unop (1 : \u03b1\u1d50\u1d52\u1d56) = 1", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_add", "code": "@[simp]\ntheorem op_add [Add \u03b1] (x y : \u03b1) : op (x + y) = op x + op y", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_add", "code": "@[simp]\ntheorem unop_add [Add \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) : unop (x + y) = unop x + unop y", "start": [267, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_neg", "code": "@[simp]\ntheorem op_neg [Neg \u03b1] (x : \u03b1) : op (-x) = -op x", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_neg", "code": "@[simp]\ntheorem unop_neg [Neg \u03b1] (x : \u03b1\u1d50\u1d52\u1d56) : unop (-x) = -unop x", "start": [277, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_mul", "code": "@[to_additive (attr := simp)]\ntheorem op_mul [Mul \u03b1] (x y : \u03b1) : op (x * y) = op y * op x", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_mul", "code": "@[to_additive (attr := simp)]\ntheorem unop_mul [Mul \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) : unop (x * y) = unop y * unop x", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_inv", "code": "@[to_additive (attr := simp)]\ntheorem op_inv [Inv \u03b1] (x : \u03b1) : op x\u207b\u00b9 = (op x)\u207b\u00b9", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_inv", "code": "@[to_additive (attr := simp)]\ntheorem unop_inv [Inv \u03b1] (x : \u03b1\u1d50\u1d52\u1d56) : unop x\u207b\u00b9 = (unop x)\u207b\u00b9", "start": [300, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_sub", "code": "@[simp]\ntheorem op_sub [Sub \u03b1] (x y : \u03b1) : op (x - y) = op x - op y", "start": [306, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_sub", "code": "@[simp]\ntheorem unop_sub [Sub \u03b1] (x y : \u03b1\u1d50\u1d52\u1d56) : unop (x - y) = unop x - unop y", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_smul", "code": "@[to_additive (attr := simp)]\ntheorem op_smul {R : Type*} [SMul R \u03b1] (c : R) (a : \u03b1) : op (c \u2022 a) = c \u2022 op a", "start": [316, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_smul", "code": "@[to_additive (attr := simp)]\ntheorem unop_smul {R : Type*} [SMul R \u03b1] (c : R) (a : \u03b1\u1d50\u1d52\u1d56) : unop (c \u2022 a) = c \u2022 unop a", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_eq_zero_iff", "code": "@[simp, nolint simpComm]\ntheorem unop_eq_zero_iff [Zero \u03b1] (a : \u03b1\u1d50\u1d52\u1d56) : a.unop = (0 : \u03b1) \u2194 a = (0 : \u03b1\u1d50\u1d52\u1d56)", "start": [332, 1], "end": [334, 29], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_eq_zero_iff", "code": "@[simp]\ntheorem op_eq_zero_iff [Zero \u03b1] (a : \u03b1) : op a = (0 : \u03b1\u1d50\u1d52\u1d56) \u2194 a = (0 : \u03b1)", "start": [337, 1], "end": [339, 27], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_ne_zero_iff", "code": "theorem unop_ne_zero_iff [Zero \u03b1] (a : \u03b1\u1d50\u1d52\u1d56) : a.unop \u2260 (0 : \u03b1) \u2194 a \u2260 (0 : \u03b1\u1d50\u1d52\u1d56)", "start": [342, 1], "end": [343, 33], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_ne_zero_iff", "code": "theorem op_ne_zero_iff [Zero \u03b1] (a : \u03b1) : op a \u2260 (0 : \u03b1\u1d50\u1d52\u1d56) \u2194 a \u2260 (0 : \u03b1)", "start": [346, 1], "end": [347, 31], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_eq_one_iff", "code": "@[to_additive (attr := simp, nolint simpComm)]\ntheorem unop_eq_one_iff [One \u03b1] (a : \u03b1\u1d50\u1d52\u1d56) : a.unop = 1 \u2194 a = 1", "start": [350, 1], "end": [352, 29], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem op_eq_one_iff [One \u03b1] (a : \u03b1) : op a = 1 \u2194 a = 1", "start": [358, 1], "end": [360, 27], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.one", "code": "instance one [One \u03b1] : One \u03b1\u1d43\u1d52\u1d56 where one := op 1", "start": [368, 1], "end": [368, 50], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_one", "code": "@[simp]\ntheorem op_one [One \u03b1] : op (1 : \u03b1) = 1", "start": [370, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_one", "code": "@[simp]\ntheorem unop_one [One \u03b1] : unop 1 = (1 : \u03b1)", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_eq_one_iff", "code": "@[simp]\ntheorem op_eq_one_iff [One \u03b1] {a : \u03b1} : op a = 1 \u2194 a = 1", "start": [380, 1], "end": [382, 30], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_eq_one_iff", "code": "@[simp]\ntheorem unop_eq_one_iff [One \u03b1] {a : \u03b1\u1d43\u1d52\u1d56} : unop a = 1 \u2194 a = 1", "start": [385, 1], "end": [387, 34], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.mul", "code": "instance mul [Mul \u03b1] : Mul \u03b1\u1d43\u1d52\u1d56 where mul a b := op (unop a * unop b)", "start": [392, 1], "end": [392, 70], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_mul", "code": "@[simp]\ntheorem op_mul [Mul \u03b1] (a b : \u03b1) : op (a * b) = op a * op b", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_mul", "code": "@[simp]\ntheorem unop_mul [Mul \u03b1] (a b : \u03b1\u1d43\u1d52\u1d56) : unop (a * b) = unop a * unop b", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.inv", "code": "instance inv [Inv \u03b1] : Inv \u03b1\u1d43\u1d52\u1d56 where inv a := op (unop a)\u207b\u00b9", "start": [404, 1], "end": [404, 61], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.involutiveInv", "code": "instance involutiveInv [InvolutiveInv \u03b1] : InvolutiveInv \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.inv with inv_inv := fun _ => unop_injective $ inv_inv _ }", "start": [406, 1], "end": [407, 74], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_inv", "code": "@[simp]\ntheorem op_inv [Inv \u03b1] (a : \u03b1) : op a\u207b\u00b9 = (op a)\u207b\u00b9", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_inv", "code": "@[simp]\ntheorem unop_inv [Inv \u03b1] (a : \u03b1\u1d43\u1d52\u1d56) : unop a\u207b\u00b9 = (unop a)\u207b\u00b9", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.div", "code": "instance div [Div \u03b1] : Div \u03b1\u1d43\u1d52\u1d56 where div a b := op (unop a / unop b)", "start": [419, 1], "end": [419, 70], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.op_div", "code": "@[simp]\ntheorem op_div [Div \u03b1] (a b : \u03b1) : op (a / b) = op a / op b", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.unop_div", "code": "@[simp]\ntheorem unop_div [Div \u03b1] (a b : \u03b1\u1d43\u1d52\u1d56) : unop (a / b) = unop a / unop b", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/TypeTags.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finite/Defs.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Logic/Nontrivial/Basic.lean"], "premises": [{"full_name": "Additive", "code": "def Additive (\u03b1 : Type*) := \u03b1", "start": [40, 1], "end": [42, 30], "kind": "commanddeclaration"}, {"full_name": "Multiplicative", "code": "def Multiplicative (\u03b1 : Type*) := \u03b1", "start": [45, 1], "end": [47, 36], "kind": "commanddeclaration"}, {"full_name": "Additive.ofMul", "code": "def ofMul : \u03b1 \u2243 Additive \u03b1 :=\n  \u27e8fun x => x, fun x => x, fun _ => rfl, fun _ => rfl\u27e9", "start": [52, 1], "end": [54, 55], "kind": "commanddeclaration"}, {"full_name": "Additive.toMul", "code": "def toMul : Additive \u03b1 \u2243 \u03b1 := ofMul.symm", "start": [57, 1], "end": [58, 41], "kind": "commanddeclaration"}, {"full_name": "Additive.ofMul_symm_eq", "code": "@[simp]\ntheorem ofMul_symm_eq : (@ofMul \u03b1).symm = toMul", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.toMul_symm_eq", "code": "@[simp]\ntheorem toMul_symm_eq : (@toMul \u03b1).symm = ofMul", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.ofAdd", "code": "def ofAdd : \u03b1 \u2243 Multiplicative \u03b1 :=\n  \u27e8fun x => x, fun x => x, fun _ => rfl, fun _ => rfl\u27e9", "start": [75, 1], "end": [77, 55], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toAdd", "code": "def toAdd : Multiplicative \u03b1 \u2243 \u03b1 := ofAdd.symm", "start": [80, 1], "end": [81, 47], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.ofAdd_symm_eq", "code": "@[simp]\ntheorem ofAdd_symm_eq : (@ofAdd \u03b1).symm = toAdd", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.toAdd_symm_eq", "code": "@[simp]\ntheorem toAdd_symm_eq : (@toAdd \u03b1).symm = ofAdd", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "toAdd_ofAdd", "code": "@[simp]\ntheorem toAdd_ofAdd (x : \u03b1) : toAdd (ofAdd x) = x", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "ofAdd_toAdd", "code": "@[simp]\ntheorem ofAdd_toAdd (x : Multiplicative \u03b1) : ofAdd (toAdd x) = x", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "toMul_ofMul", "code": "@[simp]\ntheorem toMul_ofMul (x : \u03b1) : toMul (ofMul x) = x", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "ofMul_toMul", "code": "@[simp]\ntheorem ofMul_toMul (x : Additive \u03b1) : ofMul (toMul x) = x", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "instNontrivialAdditive", "code": "instance instNontrivialAdditive [Nontrivial \u03b1] : Nontrivial (Additive \u03b1) :=\n  ofMul.injective.nontrivial", "start": [135, 1], "end": [136, 29], "kind": "commanddeclaration"}, {"full_name": "instNontrivialMultiplicative", "code": "instance instNontrivialMultiplicative [Nontrivial \u03b1] : Nontrivial (Multiplicative \u03b1) :=\n  ofAdd.injective.nontrivial", "start": [139, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "Additive.add", "code": "instance Additive.add [Mul \u03b1] : Add (Additive \u03b1) where\n  add x y := ofMul (toMul x * toMul y)", "start": [143, 1], "end": [144, 39], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.mul", "code": "instance Multiplicative.mul [Add \u03b1] : Mul (Multiplicative \u03b1) where\n  mul x y := ofAdd (toAdd x + toAdd y)", "start": [146, 1], "end": [147, 39], "kind": "commanddeclaration"}, {"full_name": "ofAdd_add", "code": "@[simp]\ntheorem ofAdd_add [Add \u03b1] (x y : \u03b1) : ofAdd (x + y) = ofAdd x * ofAdd y", "start": [149, 1], "end": [150, 79], "kind": "commanddeclaration"}, {"full_name": "toAdd_mul", "code": "@[simp]\ntheorem toAdd_mul [Add \u03b1] (x y : Multiplicative \u03b1) : toAdd (x * y) = toAdd x + toAdd y", "start": [153, 1], "end": [154, 94], "kind": "commanddeclaration"}, {"full_name": "ofMul_mul", "code": "@[simp]\ntheorem ofMul_mul [Mul \u03b1] (x y : \u03b1) : ofMul (x * y) = ofMul x + ofMul y", "start": [157, 1], "end": [158, 79], "kind": "commanddeclaration"}, {"full_name": "toMul_add", "code": "@[simp]\ntheorem toMul_add [Mul \u03b1] (x y : Additive \u03b1) : toMul (x + y) = toMul x * toMul y", "start": [161, 1], "end": [162, 88], "kind": "commanddeclaration"}, {"full_name": "Additive.addSemigroup", "code": "instance Additive.addSemigroup [Semigroup \u03b1] : AddSemigroup (Additive \u03b1) :=\n  { Additive.add with add_assoc := @mul_assoc \u03b1 _ }", "start": [165, 1], "end": [166, 52], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.semigroup", "code": "instance Multiplicative.semigroup [AddSemigroup \u03b1] : Semigroup (Multiplicative \u03b1) :=\n  { Multiplicative.mul with mul_assoc := @add_assoc \u03b1 _ }", "start": [168, 1], "end": [169, 58], "kind": "commanddeclaration"}, {"full_name": "Additive.addCommSemigroup", "code": "instance Additive.addCommSemigroup [CommSemigroup \u03b1] : AddCommSemigroup (Additive \u03b1) :=\n  { Additive.addSemigroup with add_comm := @mul_comm \u03b1 _ }", "start": [171, 1], "end": [172, 59], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.commSemigroup", "code": "instance Multiplicative.commSemigroup [AddCommSemigroup \u03b1] : CommSemigroup (Multiplicative \u03b1) :=\n  { Multiplicative.semigroup with mul_comm := @add_comm \u03b1 _ }", "start": [174, 1], "end": [175, 62], "kind": "commanddeclaration"}, {"full_name": "Additive.isLeftCancelAdd", "code": "instance Additive.isLeftCancelAdd [Mul \u03b1] [IsLeftCancelMul \u03b1] : IsLeftCancelAdd (Additive \u03b1) :=\n  \u27e8@mul_left_cancel \u03b1 _ _\u27e9", "start": [177, 1], "end": [178, 27], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isLeftCancelMul", "code": "instance Multiplicative.isLeftCancelMul [Add \u03b1] [IsLeftCancelAdd \u03b1] :\n    IsLeftCancelMul (Multiplicative \u03b1) :=\n  \u27e8@add_left_cancel \u03b1 _ _\u27e9", "start": [180, 1], "end": [182, 27], "kind": "commanddeclaration"}, {"full_name": "Additive.isRightCancelAdd", "code": "instance Additive.isRightCancelAdd [Mul \u03b1] [IsRightCancelMul \u03b1] : IsRightCancelAdd (Additive \u03b1) :=\n  \u27e8@mul_right_cancel \u03b1 _ _\u27e9", "start": [184, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isRightCancelMul", "code": "instance Multiplicative.isRightCancelMul [Add \u03b1] [IsRightCancelAdd \u03b1] :\n    IsRightCancelMul (Multiplicative \u03b1) :=\n  \u27e8@add_right_cancel \u03b1 _ _\u27e9", "start": [187, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "Additive.isCancelAdd", "code": "instance Additive.isCancelAdd [Mul \u03b1] [IsCancelMul \u03b1] : IsCancelAdd (Additive \u03b1) :=\n  \u27e8\u27e9", "start": [191, 1], "end": [192, 5], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.isCancelMul", "code": "instance Multiplicative.isCancelMul [Add \u03b1] [IsCancelAdd \u03b1] : IsCancelMul (Multiplicative \u03b1) :=\n  \u27e8\u27e9", "start": [194, 1], "end": [195, 5], "kind": "commanddeclaration"}, {"full_name": "Additive.addLeftCancelSemigroup", "code": "instance Additive.addLeftCancelSemigroup [LeftCancelSemigroup \u03b1] :\n    AddLeftCancelSemigroup (Additive \u03b1) :=\n  { Additive.addSemigroup, Additive.isLeftCancelAdd with }", "start": [197, 1], "end": [199, 59], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.leftCancelSemigroup", "code": "instance Multiplicative.leftCancelSemigroup [AddLeftCancelSemigroup \u03b1] :\n    LeftCancelSemigroup (Multiplicative \u03b1) :=\n  { Multiplicative.semigroup, Multiplicative.isLeftCancelMul with }", "start": [201, 1], "end": [203, 68], "kind": "commanddeclaration"}, {"full_name": "Additive.addRightCancelSemigroup", "code": "instance Additive.addRightCancelSemigroup [RightCancelSemigroup \u03b1] :\n    AddRightCancelSemigroup (Additive \u03b1) :=\n  { Additive.addSemigroup, Additive.isRightCancelAdd with }", "start": [205, 1], "end": [207, 60], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.rightCancelSemigroup", "code": "instance Multiplicative.rightCancelSemigroup [AddRightCancelSemigroup \u03b1] :\n    RightCancelSemigroup (Multiplicative \u03b1) :=\n  { Multiplicative.semigroup, Multiplicative.isRightCancelMul with }", "start": [209, 1], "end": [211, 69], "kind": "commanddeclaration"}, {"full_name": "ofMul_one", "code": "@[simp]\ntheorem ofMul_one [One \u03b1] : @Additive.ofMul \u03b1 1 = 0", "start": [216, 1], "end": [217, 59], "kind": "commanddeclaration"}, {"full_name": "ofMul_eq_zero", "code": "@[simp]\ntheorem ofMul_eq_zero {A : Type*} [One A] {x : A} : Additive.ofMul x = 0 \u2194 x = 1", "start": [220, 1], "end": [221, 92], "kind": "commanddeclaration"}, {"full_name": "toMul_zero", "code": "@[simp]\ntheorem toMul_zero [One \u03b1] : toMul (0 : Additive \u03b1) = 1", "start": [224, 1], "end": [225, 63], "kind": "commanddeclaration"}, {"full_name": "ofAdd_zero", "code": "@[simp]\ntheorem ofAdd_zero [Zero \u03b1] : @Multiplicative.ofAdd \u03b1 0 = 1", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "ofAdd_eq_one", "code": "@[simp]\ntheorem ofAdd_eq_one {A : Type*} [Zero A] {x : A} : Multiplicative.ofAdd x = 1 \u2194 x = 0", "start": [236, 1], "end": [238, 10], "kind": "commanddeclaration"}, {"full_name": "toAdd_one", "code": "@[simp]\ntheorem toAdd_one [Zero \u03b1] : toAdd (1 : Multiplicative \u03b1) = 0", "start": [241, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.addZeroClass", "code": "instance Additive.addZeroClass [MulOneClass \u03b1] : AddZeroClass (Additive \u03b1) where\n  zero := 0\n  add := (\u00b7 + \u00b7)\n  zero_add := @one_mul \u03b1 _\n  add_zero := @mul_one \u03b1 _", "start": [246, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.mulOneClass", "code": "instance Multiplicative.mulOneClass [AddZeroClass \u03b1] : MulOneClass (Multiplicative \u03b1) where\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  one_mul := @zero_add \u03b1 _\n  mul_one := @add_zero \u03b1 _", "start": [252, 1], "end": [256, 27], "kind": "commanddeclaration"}, {"full_name": "Additive.addMonoid", "code": "instance Additive.addMonoid [h : Monoid \u03b1] : AddMonoid (Additive \u03b1) :=\n  { Additive.addZeroClass, Additive.addSemigroup with\n    nsmul := @Monoid.npow \u03b1 h\n    nsmul_zero := @Monoid.npow_zero \u03b1 h\n    nsmul_succ := @Monoid.npow_succ \u03b1 h }", "start": [258, 1], "end": [262, 42], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.monoid", "code": "instance Multiplicative.monoid [h : AddMonoid \u03b1] : Monoid (Multiplicative \u03b1) :=\n  { Multiplicative.mulOneClass, Multiplicative.semigroup with\n    npow := @AddMonoid.nsmul \u03b1 h\n    npow_zero := @AddMonoid.nsmul_zero \u03b1 h\n    npow_succ := @AddMonoid.nsmul_succ \u03b1 h }", "start": [264, 1], "end": [268, 45], "kind": "commanddeclaration"}, {"full_name": "Additive.addLeftCancelMonoid", "code": "instance Additive.addLeftCancelMonoid [LeftCancelMonoid \u03b1] : AddLeftCancelMonoid (Additive \u03b1) :=\n  { Additive.addMonoid, Additive.addLeftCancelSemigroup with }", "start": [270, 1], "end": [271, 63], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.leftCancelMonoid", "code": "instance Multiplicative.leftCancelMonoid [AddLeftCancelMonoid \u03b1] :\n    LeftCancelMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.monoid, Multiplicative.leftCancelSemigroup with }", "start": [273, 1], "end": [275, 69], "kind": "commanddeclaration"}, {"full_name": "Additive.addRightCancelMonoid", "code": "instance Additive.addRightCancelMonoid [RightCancelMonoid \u03b1] : AddRightCancelMonoid (Additive \u03b1) :=\n  { Additive.addMonoid, Additive.addRightCancelSemigroup with }", "start": [277, 1], "end": [278, 64], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.rightCancelMonoid", "code": "instance Multiplicative.rightCancelMonoid [AddRightCancelMonoid \u03b1] :\n    RightCancelMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.monoid, Multiplicative.rightCancelSemigroup with }", "start": [280, 1], "end": [282, 70], "kind": "commanddeclaration"}, {"full_name": "Additive.addCommMonoid", "code": "instance Additive.addCommMonoid [CommMonoid \u03b1] : AddCommMonoid (Additive \u03b1) :=\n  { Additive.addMonoid, Additive.addCommSemigroup with }", "start": [284, 1], "end": [285, 57], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.commMonoid", "code": "instance Multiplicative.commMonoid [AddCommMonoid \u03b1] : CommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.monoid, Multiplicative.commSemigroup with }", "start": [287, 1], "end": [288, 63], "kind": "commanddeclaration"}, {"full_name": "Additive.neg", "code": "instance Additive.neg [Inv \u03b1] : Neg (Additive \u03b1) :=\n  \u27e8fun x => ofAdd (toMul x)\u207b\u00b9\u27e9", "start": [290, 1], "end": [291, 31], "kind": "commanddeclaration"}, {"full_name": "ofMul_inv", "code": "@[simp]\ntheorem ofMul_inv [Inv \u03b1] (x : \u03b1) : ofMul x\u207b\u00b9 = -ofMul x", "start": [293, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "toMul_neg", "code": "@[simp]\ntheorem toMul_neg [Inv \u03b1] (x : Additive \u03b1) : toMul (-x) = (toMul x)\u207b\u00b9", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.inv", "code": "instance Multiplicative.inv [Neg \u03b1] : Inv (Multiplicative \u03b1) :=\n  \u27e8fun x => ofMul (-toAdd x)\u27e9", "start": [303, 1], "end": [304, 30], "kind": "commanddeclaration"}, {"full_name": "ofAdd_neg", "code": "@[simp]\ntheorem ofAdd_neg [Neg \u03b1] (x : \u03b1) : ofAdd (-x) = (ofAdd x)\u207b\u00b9", "start": [306, 1], "end": [308, 6], "kind": "commanddeclaration"}, {"full_name": "toAdd_inv", "code": "@[simp]\ntheorem toAdd_inv [Neg \u03b1] (x : Multiplicative \u03b1) : toAdd x\u207b\u00b9 = -(toAdd x)", "start": [311, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.sub", "code": "instance Additive.sub [Div \u03b1] : Sub (Additive \u03b1) where\n  sub x y := ofMul (toMul x / toMul y)", "start": [316, 1], "end": [317, 39], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.div", "code": "instance Multiplicative.div [Sub \u03b1] : Div (Multiplicative \u03b1) where\n  div x y := ofAdd (toAdd x - toAdd y)", "start": [320, 1], "end": [321, 39], "kind": "commanddeclaration"}, {"full_name": "ofAdd_sub", "code": "@[simp]\ntheorem ofAdd_sub [Sub \u03b1] (x y : \u03b1) : ofAdd (x - y) = ofAdd x / ofAdd y", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "toAdd_div", "code": "@[simp]\ntheorem toAdd_div [Sub \u03b1] (x y : Multiplicative \u03b1) : toAdd (x / y) = toAdd x - toAdd y", "start": [329, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "ofMul_div", "code": "@[simp]\ntheorem ofMul_div [Div \u03b1] (x y : \u03b1) : ofMul (x / y) = ofMul x - ofMul y", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "toMul_sub", "code": "@[simp]\ntheorem toMul_sub [Div \u03b1] (x y : Additive \u03b1) : toMul (x - y) = toMul x / toMul y", "start": [339, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.involutiveNeg", "code": "instance Additive.involutiveNeg [InvolutiveInv \u03b1] : InvolutiveNeg (Additive \u03b1) :=\n  { Additive.neg with neg_neg := @inv_inv \u03b1 _ }", "start": [344, 1], "end": [345, 48], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.involutiveInv", "code": "instance Multiplicative.involutiveInv [InvolutiveNeg \u03b1] : InvolutiveInv (Multiplicative \u03b1) :=\n  { Multiplicative.inv with inv_inv := @neg_neg \u03b1 _ }", "start": [347, 1], "end": [348, 54], "kind": "commanddeclaration"}, {"full_name": "Additive.subNegMonoid", "code": "instance Additive.subNegMonoid [DivInvMonoid \u03b1] : SubNegMonoid (Additive \u03b1) :=\n  { Additive.neg, Additive.sub, Additive.addMonoid with\n    sub_eq_add_neg := @div_eq_mul_inv \u03b1 _\n    zsmul := @DivInvMonoid.zpow \u03b1 _\n    zsmul_zero' := @DivInvMonoid.zpow_zero' \u03b1 _\n    zsmul_succ' := @DivInvMonoid.zpow_succ' \u03b1 _\n    zsmul_neg' := @DivInvMonoid.zpow_neg' \u03b1 _ }", "start": [350, 1], "end": [356, 48], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.divInvMonoid", "code": "instance Multiplicative.divInvMonoid [SubNegMonoid \u03b1] : DivInvMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.inv, Multiplicative.div, Multiplicative.monoid with\n    div_eq_mul_inv := @sub_eq_add_neg \u03b1 _\n    zpow := @SubNegMonoid.zsmul \u03b1 _\n    zpow_zero' := @SubNegMonoid.zsmul_zero' \u03b1 _\n    zpow_succ' := @SubNegMonoid.zsmul_succ' \u03b1 _\n    zpow_neg' := @SubNegMonoid.zsmul_neg' \u03b1 _ }", "start": [358, 1], "end": [364, 48], "kind": "commanddeclaration"}, {"full_name": "Additive.subtractionMonoid", "code": "instance Additive.subtractionMonoid [DivisionMonoid \u03b1] : SubtractionMonoid (Additive \u03b1) :=\n  { Additive.subNegMonoid, Additive.involutiveNeg with\n    neg_add_rev := @mul_inv_rev \u03b1 _\n    neg_eq_of_add := @inv_eq_of_mul_eq_one_right \u03b1 _ }", "start": [366, 1], "end": [369, 55], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.divisionMonoid", "code": "instance Multiplicative.divisionMonoid [SubtractionMonoid \u03b1] : DivisionMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.divInvMonoid, Multiplicative.involutiveInv with\n    mul_inv_rev := @neg_add_rev \u03b1 _\n    inv_eq_of_mul := @neg_eq_of_add_eq_zero_right \u03b1 _ }", "start": [371, 1], "end": [374, 56], "kind": "commanddeclaration"}, {"full_name": "Additive.subtractionCommMonoid", "code": "instance Additive.subtractionCommMonoid [DivisionCommMonoid \u03b1] :\n    SubtractionCommMonoid (Additive \u03b1) :=\n  { Additive.subtractionMonoid, Additive.addCommSemigroup with }", "start": [376, 1], "end": [378, 65], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.divisionCommMonoid", "code": "instance Multiplicative.divisionCommMonoid [SubtractionCommMonoid \u03b1] :\n    DivisionCommMonoid (Multiplicative \u03b1) :=\n  { Multiplicative.divisionMonoid, Multiplicative.commSemigroup with }", "start": [380, 1], "end": [382, 71], "kind": "commanddeclaration"}, {"full_name": "Additive.addGroup", "code": "instance Additive.addGroup [Group \u03b1] : AddGroup (Additive \u03b1) :=\n  { Additive.subNegMonoid with add_left_neg := @mul_left_inv \u03b1 _ }", "start": [384, 1], "end": [385, 67], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.group", "code": "instance Multiplicative.group [AddGroup \u03b1] : Group (Multiplicative \u03b1) :=\n  { Multiplicative.divInvMonoid with mul_left_inv := @add_left_neg \u03b1 _ }", "start": [387, 1], "end": [388, 73], "kind": "commanddeclaration"}, {"full_name": "Additive.addCommGroup", "code": "instance Additive.addCommGroup [CommGroup \u03b1] : AddCommGroup (Additive \u03b1) :=\n  { Additive.addGroup, Additive.addCommMonoid with }", "start": [390, 1], "end": [391, 53], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.commGroup", "code": "instance Multiplicative.commGroup [AddCommGroup \u03b1] : CommGroup (Multiplicative \u03b1) :=\n  { Multiplicative.group, Multiplicative.commMonoid with }", "start": [393, 1], "end": [394, 59], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toMultiplicative", "code": "@[simps]\ndef AddMonoidHom.toMultiplicative [AddZeroClass \u03b1] [AddZeroClass \u03b2] :\n    (\u03b1 \u2192+ \u03b2) \u2243 (Multiplicative \u03b1 \u2192* Multiplicative \u03b2) where\n  toFun f := {\n    toFun := fun a => ofAdd (f (toAdd a))\n    map_mul' := f.map_add\n    map_one' := f.map_zero\n  }\n  invFun f := {\n    toFun := fun a => toAdd (f (ofAdd a))\n    map_add' := f.map_mul\n    map_zero' := f.map_one\n  }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [396, 1], "end": [411, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toAdditive", "code": "@[simps]\ndef MonoidHom.toAdditive [MulOneClass \u03b1] [MulOneClass \u03b2] :\n    (\u03b1 \u2192* \u03b2) \u2243 (Additive \u03b1 \u2192+ Additive \u03b2) where\n  toFun f := {\n    toFun := fun a => ofMul (f (toMul a))\n    map_add' := f.map_mul\n    map_zero' := f.map_one\n  }\n  invFun f := {\n    toFun := fun a => toMul (f (ofMul a))\n    map_mul' := f.map_add\n    map_one' := f.map_zero\n  }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [416, 1], "end": [431, 21], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toMultiplicative'", "code": "@[simps]\ndef AddMonoidHom.toMultiplicative' [MulOneClass \u03b1] [AddZeroClass \u03b2] :\n    (Additive \u03b1 \u2192+ \u03b2) \u2243 (\u03b1 \u2192* Multiplicative \u03b2) where\n  toFun f := {\n    toFun := fun a => ofAdd (f (ofMul a))\n    map_mul' := f.map_add\n    map_one' := f.map_zero\n  }\n  invFun f := {\n    toFun := fun a => toAdd (f (toMul a))\n    map_add' := f.map_mul\n    map_zero' := f.map_one\n  }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [436, 1], "end": [451, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toAdditive'", "code": "@[simps!]\ndef MonoidHom.toAdditive' [MulOneClass \u03b1] [AddZeroClass \u03b2] :\n    (\u03b1 \u2192* Multiplicative \u03b2) \u2243 (Additive \u03b1 \u2192+ \u03b2) :=\n  AddMonoidHom.toMultiplicative'.symm", "start": [456, 1], "end": [460, 38], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toMultiplicative''", "code": "@[simps]\ndef AddMonoidHom.toMultiplicative'' [AddZeroClass \u03b1] [MulOneClass \u03b2] :\n    (\u03b1 \u2192+ Additive \u03b2) \u2243 (Multiplicative \u03b1 \u2192* \u03b2) where\n  toFun f := {\n    toFun := fun a => toMul (f (toAdd a))\n    map_mul' := f.map_add\n    map_one' := f.map_zero\n  }\n  invFun f := {\n    toFun := fun a => ofMul (f (ofAdd a))\n    map_add' := f.map_mul\n    map_zero' := f.map_one\n  }\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [465, 1], "end": [480, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toAdditive''", "code": "@[simps!]\ndef MonoidHom.toAdditive'' [AddZeroClass \u03b1] [MulOneClass \u03b2] :\n    (Multiplicative \u03b1 \u2192* \u03b2) \u2243 (\u03b1 \u2192+ Additive \u03b2) :=\n  AddMonoidHom.toMultiplicative''.symm", "start": [485, 1], "end": [489, 39], "kind": "commanddeclaration"}, {"full_name": "Additive.coeToFun", "code": "instance Additive.coeToFun {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Sort*} [CoeFun \u03b1 \u03b2] :\n    CoeFun (Additive \u03b1) fun a => \u03b2 (toMul a) :=\n  \u27e8fun a => CoeFun.coe (toMul a)\u27e9", "start": [494, 1], "end": [502, 34], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.coeToFun", "code": "instance Multiplicative.coeToFun {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Sort*} [CoeFun \u03b1 \u03b2] :\n    CoeFun (Multiplicative \u03b1) fun a => \u03b2 (toAdd a) :=\n  \u27e8fun a => CoeFun.coe (toAdd a)\u27e9", "start": [505, 1], "end": [513, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Commute/Defs.lean", "imports": ["Mathlib/Algebra/Group/Semiconj/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Commute", "code": "@[to_additive AddCommute \"Two elements additively commute if `a + b = b + a`\"]\ndef Commute {S : Type*} [Mul S] (a b : S) : Prop :=\n  SemiconjBy a b b", "start": [32, 1], "end": [35, 19], "kind": "commanddeclaration"}, {"full_name": "Commute.eq", "code": "@[to_additive \"Equality behind `AddCommute a b`; useful for rewriting.\"]\nprotected theorem eq {a b : S} (h : Commute a b) : a * b = b * a", "start": [45, 1], "end": [48, 4], "kind": "commanddeclaration"}, {"full_name": "Commute.refl", "code": "@[to_additive (attr := refl, simp) \"Any element commutes with itself.\"]\nprotected theorem refl (a : S) : Commute a a", "start": [52, 1], "end": [55, 18], "kind": "commanddeclaration"}, {"full_name": "Commute.symm", "code": "@[to_additive (attr := symm) \"If `a` commutes with `b`, then `b` commutes with `a`.\"]\nprotected theorem symm {a b : S} (h : Commute a b) : Commute b a", "start": [59, 1], "end": [62, 12], "kind": "commanddeclaration"}, {"full_name": "Commute.semiconjBy", "code": "@[to_additive]\nprotected theorem semiconjBy {a b : S} (h : Commute a b) : SemiconjBy a b b", "start": [66, 1], "end": [68, 4], "kind": "commanddeclaration"}, {"full_name": "Commute.symm_iff", "code": "@[to_additive]\nprotected theorem symm_iff {a b : S} : Commute a b \u2194 Commute b a", "start": [72, 1], "end": [74, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.on_isRefl", "code": "@[to_additive]\ninstance on_isRefl {f : G \u2192 S} : IsRefl G fun a b => Commute (f a) (f b) :=\n  \u27e8fun _ => Commute.refl _\u27e9", "start": [83, 1], "end": [85, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_right", "code": "@[to_additive (attr := simp)\n\"If `a` commutes with both `b` and `c`, then it commutes with their sum.\"]\ntheorem mul_right (hab : Commute a b) (hac : Commute a c) : Commute a (b * c)", "start": [95, 1], "end": [99, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_left", "code": "@[to_additive (attr := simp)\n\"If both `a` and `b` commute with `c`, then their product commutes with `c`.\"]\ntheorem mul_left (hac : Commute a c) (hbc : Commute b c) : Commute (a * b) c", "start": [104, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "Commute.right_comm", "code": "@[to_additive]\nprotected theorem right_comm (h : Commute b c) (a : S) : a * b * c = a * c * b", "start": [113, 1], "end": [115, 33], "kind": "commanddeclaration"}, {"full_name": "Commute.left_comm", "code": "@[to_additive]\nprotected theorem left_comm (h : Commute a b) (c) : a * (b * c) = b * (a * c)", "start": [120, 1], "end": [122, 35], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_mul_mul_comm", "code": "@[to_additive]\nprotected theorem mul_mul_mul_comm (hbc : Commute b c) (a d : S) :\n    a * b * (c * d) = a * c * (b * d)", "start": [127, 1], "end": [129, 81], "kind": "commanddeclaration"}, {"full_name": "Commute.all", "code": "@[to_additive]\nprotected theorem all {S : Type*} [CommSemigroup S] (a b : S) : Commute a b", "start": [135, 1], "end": [137, 15], "kind": "commanddeclaration"}, {"full_name": "Commute.one_right", "code": "@[to_additive (attr := simp)]\ntheorem one_right (a : M) : Commute a 1", "start": [146, 1], "end": [148, 25], "kind": "commanddeclaration"}, {"full_name": "Commute.one_left", "code": "@[to_additive (attr := simp)]\ntheorem one_left (a : M) : Commute 1 a", "start": [153, 1], "end": [155, 24], "kind": "commanddeclaration"}, {"full_name": "Commute.pow_right", "code": "@[to_additive (attr := simp)]\ntheorem pow_right (h : Commute a b) (n : \u2115) : Commute a (b ^ n)", "start": [166, 1], "end": [168, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.pow_left", "code": "@[to_additive (attr := simp)]\ntheorem pow_left (h : Commute a b) (n : \u2115) : Commute (a ^ n) b", "start": [173, 1], "end": [175, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.pow_pow", "code": "@[to_additive (attr := simp)]\ntheorem pow_pow (h : Commute a b) (m n : \u2115) : Commute (a ^ m) (b ^ n)", "start": [181, 1], "end": [183, 29], "kind": "commanddeclaration"}, {"full_name": "Commute.self_pow", "code": "@[to_additive]\ntheorem self_pow (a : M) (n : \u2115) : Commute a (a ^ n)", "start": [189, 1], "end": [191, 31], "kind": "commanddeclaration"}, {"full_name": "Commute.pow_self", "code": "@[to_additive]\ntheorem pow_self (a : M) (n : \u2115) : Commute (a ^ n) a", "start": [197, 1], "end": [199, 30], "kind": "commanddeclaration"}, {"full_name": "Commute.pow_pow_self", "code": "@[to_additive]\ntheorem pow_pow_self (a : M) (m n : \u2115) : Commute (a ^ m) (a ^ n)", "start": [205, 1], "end": [207, 31], "kind": "commanddeclaration"}, {"full_name": "pow_succ'", "code": "@[to_additive succ_nsmul']\ntheorem _root_.pow_succ' (a : M) (n : \u2115) : a ^ (n + 1) = a ^ n * a", "start": [212, 1], "end": [214, 38], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_inv", "code": "@[to_additive]\nprotected theorem mul_inv (hab : Commute a b) : (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9", "start": [224, 1], "end": [225, 101], "kind": "commanddeclaration"}, {"full_name": "Commute.inv", "code": "@[to_additive]\nprotected theorem inv (hab : Commute a b) : (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9", "start": [229, 1], "end": [230, 97], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_inv_cancel", "code": "@[to_additive]\nprotected theorem mul_inv_cancel (h : Commute a b) : a * b * a\u207b\u00b9 = b", "start": [240, 1], "end": [242, 34], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_inv_cancel_assoc", "code": "@[to_additive]\ntheorem mul_inv_cancel_assoc (h : Commute a b) : a * (b * a\u207b\u00b9) = b", "start": [246, 1], "end": [248, 37], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_comm", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_comm : a * b * a\u207b\u00b9 = b", "start": [260, 1], "end": [262, 35], "kind": "commanddeclaration"}, {"full_name": "mul_inv_cancel_comm_assoc", "code": "@[to_additive (attr := simp)]\ntheorem mul_inv_cancel_comm_assoc : a * (b * a\u207b\u00b9) = b", "start": [266, 1], "end": [268, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/Syntax.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.TSyntax.replaceM", "code": "def TSyntax.replaceM [Monad M] (f : Syntax \u2192 M (Option Syntax)) (stx : TSyntax k) : M (TSyntax k) :=\n  .mk <$> stx.1.replaceM f", "start": [16, 1], "end": [22, 27], "kind": "commanddeclaration"}, {"full_name": "Lean.Syntax.TSepArray.ofElems", "code": "def Syntax.TSepArray.ofElems {sep} (elems : Array (TSyntax k)) : TSepArray k sep :=\n  .mk (SepArray.ofElems (sep := sep) elems).1", "start": [24, 1], "end": [31, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Attr/Core.lean", "imports": ["lake-packages/std/Std/Logic.lean", "Mathlib/Tactic/Attr/Register.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/CasesM.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.casesMatching", "code": "partial def casesMatching (matcher : Expr \u2192 MetaM Bool) (recursive := false) (allowSplit := true)\n    (throwOnNoMatch := true) (g : MVarId) : MetaM (List MVarId) := do\n  let result := (\u2190 go g).toList\n  if throwOnNoMatch && result == [g] then\n    throwError \"no match\"\n  else\n    return result\n  where\n  \n  go (g : MVarId) (acc : Array MVarId := #[]) : MetaM (Array MVarId) :=\n    g.withContext do\n      for ldecl in \u2190 getLCtx do\n        if ldecl.isImplementationDetail then continue\n        if \u2190 matcher ldecl.type then\n          let mut acc := acc\n          let subgoals \u2190 if allowSplit then\n            g.cases ldecl.fvarId\n          else\n            let s \u2190 saveState\n            let subgoals \u2190 g.cases ldecl.fvarId\n            if subgoals.size > 1 then\n              s.restore\n              continue\n            else\n              pure subgoals\n          for subgoal in subgoals do\n            if recursive then\n              acc \u2190 go subgoal.mvarId acc\n            else\n              acc := acc.push subgoal.mvarId\n          return acc\n      return (acc.push g)", "start": [16, 1], "end": [54, 26], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.casesType", "code": "def casesType (heads : Array Name) (recursive := false) (allowSplit := true) :\n    MVarId \u2192 MetaM (List MVarId) :=\n  let matcher ty := pure <|\n    if let .const n .. := ty.headBeta.getAppFn then heads.contains n else false\n  casesMatching matcher recursive allowSplit", "start": [56, 1], "end": [60, 45], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.elabPatterns", "code": "def elabPatterns (pats : Array Term) : TermElabM (Array AbstractMVarsResult) :=\n  withTheReader Term.Context (fun ctx \u21a6 { ctx with ignoreTCFailures := true }) <|\n  Term.withoutErrToSorry <|\n  pats.mapM fun p \u21a6 Term.withoutModifyingElabMetaStateWithInfo do\n    withRef p <| abstractMVars (\u2190 Term.elabTerm p none)", "start": [67, 1], "end": [72, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.matchPatterns", "code": "def matchPatterns (pats : Array AbstractMVarsResult) (e : Expr) : MetaM Bool := do\n  let e \u2190 instantiateMVars e\n  pats.anyM fun p \u21a6 return (\u2190 Conv.matchPattern? p e) matches some (_, #[])", "start": [74, 1], "end": [77, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.elabCasesType", "code": "def elabCasesType (heads : Array Ident)\n    (recursive := false) (allowSplit := true) : TacticM Unit := do\n  let heads \u2190 heads.mapM resolveGlobalConstNoOverloadWithInfo\n  liftMetaTactic (casesType heads recursive allowSplit)", "start": [96, 1], "end": [100, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.constructorMatching", "code": "partial def constructorMatching (g : MVarId) (matcher : Expr \u2192 MetaM Bool)\n    (recursive := false) (throwOnNoMatch := true) : MetaM (List MVarId) := do\n  let result \u2190\n    (if recursive then (do\n      let result \u2190 go g\n      pure result.toList)\n     else\n      (g.withContext do\n          if \u2190 matcher (\u2190 g.getType) then g.constructor else pure [g]))\n  if throwOnNoMatch && [g] == result then\n    throwError \"no match\"\n  else\n    return result\nwhere\n  \n  go (g : MVarId) (acc : Array MVarId := #[]) : MetaM (Array MVarId) :=\n    g.withContext do\n      if \u2190 matcher (\u2190 g.getType) then\n        let mut acc := acc\n        for g' in \u2190 g.constructor do\n          acc \u2190 go g' acc\n        return acc\n      return (acc.push g)", "start": [121, 1], "end": [149, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Cache.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Cache", "code": "def Cache (\u03b1 : Type) :=\n  IO.Ref <| Sum (MetaM \u03b1) <|\n    Task <| Except Exception \u03b1", "start": [50, 1], "end": [53, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Cache.mk", "code": "def Cache.mk (init : MetaM \u03b1) : IO (Cache \u03b1) :=\n  IO.mkRef <| Sum.inl init", "start": [58, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Cache.get", "code": "def Cache.get [Monad m] [MonadEnv m] [MonadLog m] [MonadOptions m] [MonadLiftT BaseIO m]\n    [MonadExcept Exception m] (cache : Cache \u03b1) : m \u03b1 := do\n  let t \u2190 match \u2190 show BaseIO _ from ST.Ref.get cache with\n    | Sum.inr t => pure t\n    | Sum.inl init =>\n      let env \u2190 getEnv\n      let fileName \u2190 getFileName\n      let fileMap \u2190 getFileMap\n      let options \u2190 getOptions let options := Core.maxHeartbeats.set options <|\n        options.get? Core.maxHeartbeats.name |>.getD 1000000\n      let res \u2190 EIO.asTask do\n        let metaCtx : Meta.Context := {}\n        let metaState : Meta.State := {}\n        let coreCtx : Core.Context := {options, fileName, fileMap}\n        let coreState : Core.State := {env}\n        pure (\u2190 ((init \u2039_\u203a).run \u2039_\u203a \u2039_\u203a).run \u2039_\u203a).1.1\n      show BaseIO _ from cache.set (Sum.inr res)\n      pure res\n  match t.get with\n    | Except.ok res => pure res\n    | Except.error err => throw err", "start": [62, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DeclCache", "code": "structure DeclCache (\u03b1 : Type) where mk' ::\n  \n  cache : Cache \u03b1\n  \n  addDecl : Name \u2192 ConstantInfo \u2192 \u03b1 \u2192 MetaM \u03b1\n  \n  addLibraryDecl : Name \u2192 ConstantInfo \u2192 \u03b1 \u2192 MetaM \u03b1 := addDecl\nderiving Nonempty", "start": [94, 1], "end": [106, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DeclCache.mk", "code": "def DeclCache.mk (profilingName : String) (empty : \u03b1)\n    (addDecl : Name \u2192 ConstantInfo \u2192 \u03b1 \u2192 MetaM \u03b1)\n    (addLibraryDecl : Name \u2192 ConstantInfo \u2192 \u03b1 \u2192 MetaM \u03b1 := addDecl)\n    (post : \u03b1 \u2192 MetaM \u03b1 := fun a => pure a) : IO (DeclCache \u03b1) := do\n  let cache \u2190 Cache.mk do\n    profileitM Exception profilingName (\u2190 getOptions) do\n    let mut a := empty\n    for (n, c) in (\u2190 getEnv).constants.map\u2081.toList do\n      a \u2190 addLibraryDecl n c a\n    return (\u2190 post a)\n  pure { cache := cache, addDecl := addDecl }", "start": [108, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DeclCache.get", "code": "def DeclCache.get (cache : DeclCache \u03b1) : MetaM \u03b1 := do\n  let mut a \u2190 cache.cache.get\n  for (n, c) in (\u2190 getEnv).constants.map\u2082.toList do\n    a \u2190 cache.addDecl n c a\n  return a", "start": [127, 1], "end": [137, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DiscrTreeCache", "code": "@[reducible] def DiscrTreeCache (\u03b1 : Type) : Type :=\n  DeclCache (DiscrTree \u03b1 true \u00d7 DiscrTree \u03b1 true)", "start": [139, 1], "end": [145, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DiscrTreeCache.mk", "code": "def DiscrTreeCache.mk [BEq \u03b1] (profilingName : String)\n    (processDecl : Name \u2192 ConstantInfo \u2192 MetaM (Array (Array (DiscrTree.Key true) \u00d7 \u03b1)))\n    (post? : Option (Array \u03b1 \u2192 Array \u03b1) := none)\n    (init : Option (DiscrTree \u03b1 true) := none) :\n    IO (DiscrTreeCache \u03b1) :=\n  let updateTree := fun name constInfo tree => do\n    return (\u2190 processDecl name constInfo).foldl (fun t (k, v) => t.insertIfSpecific k v) tree\n  let addDecl := fun name constInfo (tree\u2081, tree\u2082) => do\n    return (\u2190 updateTree name constInfo tree\u2081, tree\u2082)\n  let addLibraryDecl := fun name constInfo (tree\u2081, tree\u2082) => do\n    return (tree\u2081, \u2190 updateTree name constInfo tree\u2082)\n  let post := match post? with\n  | some f => fun (T\u2081, T\u2082) => return (T\u2081, T\u2082.mapArrays f)\n  | none => fun T => pure T\n  match init with\n  | some t => return \u27e8\u2190 Cache.mk (pure ({}, t)), addDecl, addLibraryDecl\u27e9\n  | none => DeclCache.mk profilingName ({}, {}) addDecl addLibraryDecl (post := post)", "start": [147, 1], "end": [167, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.DiscrTreeCache.getMatch", "code": "def DiscrTreeCache.getMatch (c : DiscrTreeCache \u03b1) (e : Expr) : MetaM (Array \u03b1) := do\n  let (locals, imports) \u2190 c.get\n  return (\u2190 locals.getMatch e).reverse ++ (\u2190 imports.getMatch e).reverse", "start": [169, 1], "end": [182, 73], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/AssertInstancesCommute.lean", "imports": ["lake-packages/Qq/Qq/MetaM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.Impl.isRedundantLocalInst?", "code": "def isRedundantLocalInst? (inst : FVarId) : MetaM (Option Expr) := do\n  let ldecl \u2190 inst.getDecl\n  if ldecl.hasValue then return none\n  let rest := (\u2190 getLocalInstances).filter (\u00b7.fvar != .fvar inst)\n  withLCtx (\u2190 getLCtx) rest do\n  let some inst \u2190 synthInstance? ldecl.type | return none\n  return if (\u2190 makeDefEq ldecl.toExpr inst).isSome then inst else none", "start": [10, 1], "end": [16, 71], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.findRedundantLocalInst?", "code": "def findRedundantLocalInst? : QuoteM (Option (FVarId \u00d7 Expr)) := do\n  for {fvar, ..} in \u2190 withUnquotedLCtx getLocalInstances do\n    if let some (.quoted (.fvar quotedFVar)) := (\u2190 read).exprBackSubst.find? fvar then\n      if (\u2190 quotedFVar.getDecl).hasValue then continue\n      if let some result \u2190 withUnquotedLCtx do isRedundantLocalInst? fvar.fvarId! then\n        return (fvar.fvarId!, result)\n  return none", "start": [18, 1], "end": [24, 14], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.findRedundantLocalInstQuoted?", "code": "def findRedundantLocalInstQuoted? :\n    TermElabM (Option (FVarId \u00d7 (u : Q(Level)) \u00d7 (ty : Q(Quoted (.sort $u))) \u00d7 Q(Quoted $ty) \u00d7 Q(Quoted $ty))) := do\n  for ldecl in \u2190 getLCtx do\n    let ty \u2190 whnfR ldecl.type\n    if ty.isMVar then tryPostpone\n    if ty.isAppOf ``Quoted then\n      if (\u2190 instantiateMVars ty.appArg!).hasExprMVar then\n        tryPostpone\n  StateT.run' (m := MetaM) (s := { mayPostpone := (\u2190 read).mayPostpone }) do\n  unquoteLCtx\n  (\u2190 findRedundantLocalInst?).mapM fun (fvar, inst) => do\n  let ty \u2190 withUnquotedLCtx do inferType (.fvar fvar)\n  let u \u2190 withUnquotedLCtx do getLevel ty\n  return \u27e8fvar, \u2190 quoteLevel u, \u2190 quoteExpr ty, \u2190 quoteExpr (.fvar fvar), \u2190 quoteExpr inst\u27e9", "start": [26, 1], "end": [39, 92], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq/Match.lean", "imports": ["lake-packages/Qq/Qq/Macro.lean", "lake-packages/Qq/Qq/ForLean/Do.lean", "lake-packages/Qq/Qq/MetaM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/Qq/Qq/SortLocalDecls.lean"], "premises": [{"full_name": "Lean.Syntax.stripPos", "code": "partial def Lean.Syntax.stripPos : Syntax \u2192 Syntax\n  | atom _ a => atom .none a\n  | ident _ r v p => ident .none r v p\n  | node _ kind args => node .none kind (args.map stripPos)\n  | missing => missing", "start": [7, 1], "end": [11, 23], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.PatVarDecl", "code": "structure PatVarDecl where\n  ty : Option Q(Expr)\n  fvarId : FVarId\n  userName : Name", "start": [20, 1], "end": [23, 18], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.PatVarDecl.fvarTy", "code": "def PatVarDecl.fvarTy : PatVarDecl \u2192 Q(Type)\n  | { ty := none, .. } => q(Level)\n  | { ty := some _, .. } => q(Expr)", "start": [25, 1], "end": [27, 36], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.PatVarDecl.fvar", "code": "def PatVarDecl.fvar (decl : PatVarDecl) : Q($((decl.fvarTy))) :=\n  Expr.fvar decl.fvarId", "start": [29, 1], "end": [30, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkIsDefEqType", "code": "def mkIsDefEqType : List PatVarDecl \u2192 Q(Type)\n  | [] => q(Bool)\n  | decl :: decls => q($(decl.fvarTy) \u00d7 $(mkIsDefEqType decls))", "start": [32, 1], "end": [34, 64], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkIsDefEqResult", "code": "def mkIsDefEqResult (val : Bool) : (decls : List PatVarDecl) \u2192 Q($(mkIsDefEqType decls))\n  | [] => show Q(Bool) from q($val)\n  | decl :: decls => q(($(decl.fvar), $(mkIsDefEqResult val decls)))", "start": [36, 1], "end": [38, 69], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkIsDefEqResultVal", "code": "def mkIsDefEqResultVal : (decls : List PatVarDecl) \u2192 Q($(mkIsDefEqType decls)) \u2192 Q(Bool)\n  | [], val => q($val)\n  | _ :: decls, val => mkIsDefEqResultVal decls q($val.2)", "start": [40, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkLambda'", "code": "def mkLambda' (n : Name) (fvar : Expr) (ty : Expr) (body : Expr) : MetaM Expr :=\n  return mkLambda n BinderInfo.default ty (\u2190 body.abstractM #[fvar])", "start": [44, 1], "end": [45, 69], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkLet'", "code": "def mkLet' (n : Name) (fvar : Expr) (ty : Expr) (val : Expr) (body : Expr) : MetaM Expr :=\n  return mkLet n ty val (\u2190 body.abstractM #[fvar])", "start": [47, 1], "end": [48, 51], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkLambdaQ", "code": "def mkLambdaQ (n : Name) (fvar : Quoted \u03b1) (body : Quoted \u03b2) : MetaM (Quoted (mkForall n BinderInfo.default \u03b1 \u03b2)) :=\n  return mkLambda n BinderInfo.default \u03b1 (\u2190 body.abstractM #[fvar])", "start": [50, 1], "end": [51, 68], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkInstantiateMVars", "code": "def mkInstantiateMVars (decls : List PatVarDecl) : List PatVarDecl \u2192 MetaM Q(MetaM $(mkIsDefEqType decls))\n  | [] => return q(return $(mkIsDefEqResult true decls))\n  | { ty := none, fvarId := fvarId, userName := userName } :: rest => do\n    let decl : PatVarDecl := { ty := none, fvarId := fvarId, userName := userName }\n    let instMVars : Q(Level \u2192 MetaM $(mkIsDefEqType decls)) \u2190\n      mkLambdaQ _ decl.fvar q($(\u2190 mkInstantiateMVars decls rest))\n    return q(Bind.bind (instantiateLevelMVars $(decl.fvar)) $instMVars)\n  | { ty := some ty, fvarId := fvarId, userName := userName } :: rest => do\n    let decl : PatVarDecl := { ty := some ty, fvarId := fvarId, userName := userName }\n    let instMVars : Q(Expr \u2192 MetaM $(mkIsDefEqType decls)) \u2190\n      mkLambdaQ _ decl.fvar q($(\u2190 mkInstantiateMVars decls rest))\n    return q(Bind.bind (instantiateMVars $(decl.fvar)) $instMVars)", "start": [53, 1], "end": [65, 67], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkIsDefEqCore", "code": "def mkIsDefEqCore (decls : List PatVarDecl) (pat discr : Q(Expr)) :\n    List PatVarDecl \u2192 MetaM Q(MetaM $(mkIsDefEqType decls))\n  | { ty := none, fvarId := fvarId, userName := userName } :: rest =>\n    let decl : PatVarDecl := { ty := none, fvarId := fvarId, userName := userName }\n    return q(Bind.bind mkFreshLevelMVar $(\u2190 mkLambdaQ `x decl.fvar (\u2190 mkIsDefEqCore decls pat discr rest)))\n  | { ty := some ty, fvarId := fvarId, userName := userName } :: rest =>\n    let decl : PatVarDecl := { ty := some ty, fvarId := fvarId, userName := userName }\n    return q(Bind.bind (mkFreshExprMVar $ty) $(\u2190 mkLambdaQ `x decl.fvar (\u2190 mkIsDefEqCore decls pat discr rest)))\n  | [] => do\n    let instMVars \u2190 mkInstantiateMVars decls decls\n    return q(do\n      let matches? \u2190 withReducible $ isDefEq $pat $discr\n      (if matches? then $instMVars else return $(mkIsDefEqResult false decls)))", "start": [67, 1], "end": [79, 80], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkIsDefEq", "code": "def mkIsDefEq (decls : List PatVarDecl) (pat discr : Q(Expr)) : MetaM Q(MetaM $(mkIsDefEqType decls)) := do\n  return q(withNewMCtxDepth $(\u2190 mkIsDefEqCore decls pat discr decls))", "start": [81, 1], "end": [82, 70], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.withLetHave", "code": "def withLetHave [Monad m] [MonadControlT MetaM m] [MonadLiftT MetaM m] [MonadLCtx m]\n    (fvarId : FVarId) (userName : Name) (val : (Quoted \u03b1)) (k : (Quoted \u03b1) \u2192 m (Quoted \u03b2)) : m (Quoted \u03b2) := do\n  withExistingLocalDecls [LocalDecl.cdecl (\u2190 getLCtx).decls.size fvarId userName \u03b1 .default .default] do\n    return Quoted.unsafeMk $ \u2190 mkLet' userName (.fvar fvarId) \u03b1 val (\u2190 k (.fvar fvarId))", "start": [84, 1], "end": [87, 89], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkQqLets", "code": "def mkQqLets {\u03b3 : Q(Type)} : (decls : List PatVarDecl) \u2192 Q($(mkIsDefEqType decls)) \u2192\n    TermElabM Q($\u03b3) \u2192 TermElabM Q($\u03b3)\n  | { ty := none, fvarId := fvarId, userName := userName } :: decls, acc, cb =>\n    withLetHave fvarId userName (\u03b1 := q(Level)) q($acc.1) fun _ => mkQqLets decls q($acc.2) cb\n  | { ty := some ty, fvarId := fvarId, userName := userName } :: decls, acc, cb =>\n    withLetHave fvarId userName (\u03b1 := q(Quoted $ty)) q($acc.1) fun _ => mkQqLets decls q($acc.2) cb\n  | [], _, cb => cb", "start": [89, 1], "end": [95, 20], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.replaceTempExprsByQVars", "code": "def replaceTempExprsByQVars : List PatVarDecl \u2192 Expr \u2192 Expr\n  | [], e => e\n  | { ty := some _, fvarId, .. } :: decls, e =>\n    ((replaceTempExprsByQVars decls e).abstract #[.fvar fvarId]).instantiate #[.fvar fvarId]\n  | { ty := none, .. } :: decls, e =>\n    replaceTempExprsByQVars decls e", "start": [98, 1], "end": [103, 36], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.makeMatchCode", "code": "def makeMatchCode {\u03b3 : Q(Type)} {m : Q(Type \u2192 Type v)} (_instLift : Q(MonadLiftT MetaM $m)) (_instBind : Q(Bind $m))\n    (decls : List PatVarDecl) (uTy : Q(Level)) (ty : Q(Quoted (.sort $uTy)))\n    (pat discr : Q(Quoted $ty)) (alt : Q($m $\u03b3)) (expectedType : Expr)\n    (k : Expr \u2192 TermElabM Q($m $\u03b3)) : TermElabM Q($m $\u03b3) := do\n  let nextDecls : List PatVarDecl :=\n    decls.map fun decl => { decl with ty := decl.ty.map fun e => replaceTempExprsByQVars decls e }\n  let next \u2190 withLocalDeclD (\u2190 mkFreshBinderName) (mkIsDefEqType decls) fun fv => do\n    let fv : Q($(mkIsDefEqType decls)) := fv\n    let next : Q($m $\u03b3) :=\n      q(if $(mkIsDefEqResultVal decls fv) then\n          $(\u2190 mkQqLets nextDecls fv do\n            have pat : Q(Quoted $ty) := replaceTempExprsByQVars decls pat\n            let (_, s) \u2190 unquoteLCtx.run { mayPostpone := (\u2190 read).mayPostpone }\n            let _discr' \u2190 (unquoteExpr discr).run' s\n            let _pat' \u2190 (unquoteExpr pat).run' s\n            withLocalDeclDQ (\u2190 mkFreshUserName `match_eq) q(QuotedDefEq $discr $pat) fun h => do\n              let res \u2190 k expectedType\n              let res : Q($m $\u03b3) \u2190 instantiateMVars res\n              let res : Q($m $\u03b3) := (\u2190 res.abstractM #[h]).instantiate #[q(\u27e8\u27e9 : QuotedDefEq $discr $pat)]\n              return res)\n        else\n          $alt)\n    return show Q($(mkIsDefEqType decls) \u2192 $m $\u03b3) from\n      Quoted.unsafeMk $ \u2190 mkLambda' `result fv (mkIsDefEqType decls) next\n  pure q(Bind.bind $(\u2190 mkIsDefEq decls pat discr) $next)", "start": [105, 1], "end": [129, 57], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.unquoteForMatch", "code": "def unquoteForMatch (et : Expr) : UnquoteM (LocalContext \u00d7 LocalInstances \u00d7 Expr) := do\n  unquoteLCtx\n  let newET \u2190 unquoteExpr et\n  let newLCtx := (\u2190 get).unquoted\n  return (newLCtx, \u2190 determineLocalInstances newLCtx, newET)", "start": [131, 1], "end": [135, 61], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkNAryFunctionType", "code": "def mkNAryFunctionType : Nat \u2192 MetaM Expr\n  | 0 => mkFreshTypeMVar\n  | n+1 => do withLocalDeclD `x (\u2190 mkFreshTypeMVar) fun x => do\n    mkForallFVars #[x] (\u2190 mkNAryFunctionType n)", "start": [137, 1], "end": [140, 48], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.getPatVars", "code": "partial def getPatVars (pat : Term) : StateT (Array (Name \u00d7 Nat \u00d7 Expr \u00d7 Term)) TermElabM Term := do\n  match pat with\n    | `($fn $args*) => if isPatVar fn then return \u2190 mkMVar fn args\n    | _ => if isPatVar pat then return \u2190 mkMVar pat #[]\n  match pat with\n    | \u27e8.node info kind args\u27e9 => return \u27e8.node info kind (\u2190 args.mapM (getPatVars \u27e8\u00b7\u27e9))\u27e9\n    | pat => return pat\n\n  where\n\n    isPatVar (fn : Syntax) : Bool :=\n      fn.isAntiquot && !fn.isEscapedAntiquot && fn.getAntiquotTerm.isIdent &&\n      fn.getAntiquotTerm.getId.isAtomic\n\n    mkMVar (fn : Syntax) (args : Array Term) : StateT _ TermElabM Term := do\n      let args \u2190 args.mapM getPatVars\n      let id := fn.getAntiquotTerm.getId\n      withFreshMacroScope do\n        if let some (_, _, _, m) := (\u2190 get).find? fun (n, _) => n == id then\n          return \u2190 `($m $args*)\n        let mvar \u2190 elabTerm (\u2190 `(?m)).1.stripPos (\u2190 mkNAryFunctionType args.size)\n        modify (\u00b7.push (id, args.size, mvar, \u2190 `(?m)))\n        `(?m $args*)", "start": [142, 1], "end": [164, 21], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.elabPat", "code": "def elabPat (pat : Term) (lctx : LocalContext) (localInsts : LocalInstances) (ty : Expr)\n    (levelNames : List Name) : TermElabM (Expr \u00d7 Array LocalDecl \u00d7 Array Name) :=\n  withLCtx lctx localInsts do\n    withLevelNames levelNames do\n          let (pat, patVars) \u2190 getPatVars pat #[]\n          let pat \u2190 Lean.Elab.Term.elabTerm pat ty\n          let pat \u2190 ensureHasType ty pat\n          synthesizeSyntheticMVars false\n          let pat \u2190 instantiateMVars pat\n\n          let mctx \u2190 getMCtx\n          let levelNames \u2190 getLevelNames\n          let r := mctx.levelMVarToParam levelNames.elem (fun _ => false) pat `u 1\n          setMCtx r.mctx\n\n          let mut newDecls := #[]\n\n          for (patVar, _, mvar, _) in patVars do\n            assert! mvar.isMVar\n            let fvarId := FVarId.mk (\u2190 mkFreshId)\n            let type \u2190 inferType mvar\n            newDecls := newDecls.push $\n              LocalDecl.cdecl default fvarId patVar type .default .default\n            mvar.mvarId!.assign (.fvar fvarId)\n\n          for newMVar in \u2190 getMVars pat do\n            let fvarId := FVarId.mk (\u2190 mkFreshId)\n            let type \u2190 instantiateMVars (\u2190 newMVar.getDecl).type\n            let userName \u2190 mkFreshBinderName\n            newDecls := newDecls.push $\n              LocalDecl.cdecl default fvarId userName type .default .default\n            newMVar.assign (.fvar fvarId)\n\n          withExistingLocalDecls newDecls.toList do\n            return (\u2190 instantiateMVars pat,\n              \u2190 sortLocalDecls (\u2190 newDecls.mapM fun d => instantiateLocalDeclMVars d),\n              r.newParamNames)", "start": [166, 1], "end": [202, 31], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.isIrrefutablePattern", "code": "partial def isIrrefutablePattern : Term \u2192 Bool\n  | `(($stx)) => isIrrefutablePattern stx\n  | `(\u27e8$args,*\u27e9) => args.getElems.all isIrrefutablePattern\n  | `(($a, $b)) => isIrrefutablePattern a && isIrrefutablePattern b\n  | `(_) => true\n  | `(true) => false | `(false) => false | stx => stx.1.isIdent", "start": [241, 1], "end": [247, 25], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.mkLetDoSeqItem", "code": "def mkLetDoSeqItem [Monad m] [MonadQuotation m] (pat : Term) (rhs : TSyntax `doElem) (alt : TSyntax ``doSeq) : m (List (TSyntax ``doSeqItem)) := do\n  match pat with\n    | `(_) => return []\n    | _ =>\n      if isIrrefutablePattern pat then\n        return [\u2190 `(doSeqItem| let $pat:term \u2190 $rhs)]\n      else\n        return [\u2190 `(doSeqItem| let $pat:term \u2190 $rhs | $alt)]", "start": [260, 1], "end": [267, 61], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.hasQMatch", "code": "partial def Impl.hasQMatch : Syntax \u2192 Bool\n  | `(~q($_)) => true\n  | stx => stx.getArgs.any hasQMatch", "start": [277, 1], "end": [279, 37], "kind": "commanddeclaration"}, {"full_name": "Qq.Impl.floatQMatch", "code": "partial def Impl.floatQMatch (alt : TSyntax ``doSeq) : Term \u2192 StateT (List (TSyntax ``doSeqItem)) MacroM Term\n  | `(~q($term)) =>\n    withFreshMacroScope do\n      let auxDoElem \u2190 `(doSeqItem| let ~q($term) \u2190 x | $alt)\n      modify fun s => s ++ [auxDoElem]\n      `(x)\n  | stx => do match stx with\n    | \u27e8.node i k args\u27e9 => return \u27e8.node i k (\u2190 args.mapM (floatQMatch alt \u27e8\u00b7\u27e9))\u27e9\n    | stx => return stx", "start": [281, 1], "end": [289, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.push", "code": "private def push (i : TSyntax ``doSeqItem) : StateT (Array (TSyntax ``doSeqItem)) MacroM Unit :=\n  modify fun s => s.push i", "start": [291, 1], "end": [292, 27], "kind": "commanddeclaration"}, {"full_name": "Qq.unpackParensIdent", "code": "partial def unpackParensIdent : Syntax \u2192 Option Syntax\n  | `(($stx)) => unpackParensIdent stx\n  | stx => if stx.isIdent then some stx else none", "start": [294, 1], "end": [296, 50], "kind": "commanddeclaration"}, {"full_name": "Qq.floatLevelAntiquot", "code": "private partial def floatLevelAntiquot (stx : Syntax.Level) : StateT (Array (TSyntax ``doSeqItem)) MacroM Syntax.Level :=\n  if stx.1.isAntiquot && !stx.1.isEscapedAntiquot then\n    if !stx.1.getAntiquotTerm.isIdent then\n      withFreshMacroScope do\n        push <|<- `(doSeqItem| let u : Level := $(\u27e8stx.1.getAntiquotTerm\u27e9))\n        `(level| u)\n    else\n      pure stx\n  else\n    match stx with\n    | \u27e8.node i k args\u27e9 => return \u27e8Syntax.node i k (\u2190 args.mapM (floatLevelAntiquot \u27e8\u00b7\u27e9))\u27e9\n    | stx => return stx", "start": [298, 1], "end": [309, 24], "kind": "commanddeclaration"}, {"full_name": "Qq.floatExprAntiquot", "code": "private partial def floatExprAntiquot (depth : Nat) : Term \u2192 StateT (Array (TSyntax ``doSeqItem)) MacroM Term\n  | `(Q($x)) => do `(Q($(\u2190 floatExprAntiquot (depth + 1) x)))\n  | `(q($x)) => do `(q($(\u2190 floatExprAntiquot (depth + 1) x)))\n  | `(Type $term) => do `(Type $(\u2190 floatLevelAntiquot term))\n  | `(Sort $term) => do `(Sort $(\u2190 floatLevelAntiquot term))\n  | stx => do\n    if stx.1.isAntiquot && !stx.1.isEscapedAntiquot then\n      let term : Term := \u27e8stx.1.getAntiquotTerm\u27e9\n      if term.1.isIdent then\n        return stx\n      else if depth > 0 then\n        return \u27e8.mkAntiquotNode stx.1.antiquotKind?.get!.1 (\u2190 floatExprAntiquot (depth - 1) term)\u27e9\n      else\n        match unpackParensIdent stx.1.getAntiquotTerm with\n          | some id =>\n            if id.getId.isAtomic then\n              return \u27e8addSyntaxDollar id\u27e9\n          | none => pure ()\n        withFreshMacroScope do\n          push <|<- `(doSeqItem| let a : Quoted _ := $term)\n          return \u27e8addSyntaxDollar (\u2190 `(a))\u27e9\n    else\n      match stx with\n      | \u27e8.node i k args\u27e9 => return \u27e8.node i k (\u2190 args.mapM (floatExprAntiquot depth \u27e8\u00b7\u27e9))\u27e9\n      | stx => return stx", "start": [311, 1], "end": [335, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ToExpr.lean", "imports": ["Mathlib/Util/WhatsNew.lean", "Mathlib/Tactic/DeriveToExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.toExprMData", "code": "private def toExprMData (md : MData) : Expr := Id.run do\n  let mut e := mkConst ``MData.empty\n  for (k, v) in md do\n    let k := toExpr k\n    e := match v with\n          | ofString v => mkApp3 (mkConst ``KVMap.setString) e k (mkStrLit v)\n          | ofBool v   => mkApp3 (mkConst ``KVMap.setBool) e k (toExpr v)\n          | ofName v   => mkApp3 (mkConst ``KVMap.setName) e k (toExpr v)\n          | ofNat v    => mkApp3 (mkConst ``KVMap.setNat) e k (mkNatLit v)\n          | ofInt v    => mkApp3 (mkConst ``KVMap.setInt) e k (toExpr v)\n          | ofSyntax v => mkApp3 (mkConst ``KVMap.setSyntax) e k (toExpr v)\n  return e", "start": [67, 1], "end": [81, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/PropInstances.lean", "imports": ["Mathlib/Order/WithBot.lean", "Mathlib/Order/Disjoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prop.distribLattice", "code": "instance Prop.distribLattice : DistribLattice Prop where\n  sup := Or\n  le_sup_left := @Or.inl\n  le_sup_right := @Or.inr\n  sup_le := fun _ _ _ => Or.rec\n  inf := And\n  inf_le_left := @And.left\n  inf_le_right := @And.right\n  le_inf := fun _ _ _ Hab Hac Ha => And.intro (Hab Ha) (Hac Ha)\n  le_sup_inf := fun _ _ _ => or_and_left.2", "start": [22, 1], "end": [32, 43], "kind": "commanddeclaration"}, {"full_name": "Prop.boundedOrder", "code": "instance Prop.boundedOrder : BoundedOrder Prop where\n  top := True\n  le_top _ _ := True.intro\n  bot := False\n  bot_le := @False.elim", "start": [35, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "Prop.bot_eq_false", "code": "theorem Prop.bot_eq_false : (\u22a5 : Prop) = False", "start": [43, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "Prop.top_eq_true", "code": "theorem Prop.top_eq_true : (\u22a4 : Prop) = True", "start": [47, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Prop.le_isTotal", "code": "instance Prop.le_isTotal : IsTotal Prop (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun p q => by by_cases h : q <;> simp [h]\u27e9", "start": [51, 1], "end": [52, 46], "kind": "commanddeclaration"}, {"full_name": "Prop.linearOrder", "code": "noncomputable instance Prop.linearOrder : LinearOrder Prop := by\n  classical\n  exact Lattice.toLinearOrder Prop", "start": [55, 1], "end": [57, 35], "kind": "commanddeclaration"}, {"full_name": "sup_Prop_eq", "code": "@[simp]\ntheorem sup_Prop_eq : (\u00b7 \u2294 \u00b7) = (\u00b7 \u2228 \u00b7)", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "inf_Prop_eq", "code": "@[simp]\ntheorem inf_Prop_eq : (\u00b7 \u2293 \u00b7) = (\u00b7 \u2227 \u00b7)", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.disjoint_iff", "code": "theorem disjoint_iff [\u2200 i, OrderBot (\u03b1' i)] {f g : \u2200 i, \u03b1' i} :\n    Disjoint f g \u2194 \u2200 i, Disjoint (f i) (g i)", "start": [74, 1], "end": [84, 28], "kind": "commanddeclaration"}, {"full_name": "Pi.codisjoint_iff", "code": "theorem codisjoint_iff [\u2200 i, OrderTop (\u03b1' i)] {f g : \u2200 i, \u03b1' i} :\n    Codisjoint f g \u2194 \u2200 i, Codisjoint (f i) (g i)", "start": [87, 1], "end": [89, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.isCompl_iff", "code": "theorem isCompl_iff [\u2200 i, BoundedOrder (\u03b1' i)] {f g : \u2200 i, \u03b1' i} :\n    IsCompl f g \u2194 \u2200 i, IsCompl (f i) (g i)", "start": [92, 1], "end": [94, 73], "kind": "commanddeclaration"}, {"full_name": "Prop.disjoint_iff", "code": "@[simp]\ntheorem Prop.disjoint_iff {P Q : Prop} : Disjoint P Q \u2194 \u00ac(P \u2227 Q)", "start": [99, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Prop.codisjoint_iff", "code": "@[simp]\ntheorem Prop.codisjoint_iff {P Q : Prop} : Codisjoint P Q \u2194 P \u2228 Q", "start": [104, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "Prop.isCompl_iff", "code": "@[simp]\ntheorem Prop.isCompl_iff {P Q : Prop} : IsCompl P Q \u2194 \u00ac(P \u2194 Q)", "start": [109, 1], "end": [112, 41], "kind": "commanddeclaration"}, {"full_name": "Prop.decidablePredBot", "code": "instance Prop.decidablePredBot : DecidablePred (\u22a5 : \u03b1 \u2192 Prop) := fun _ => instDecidableFalse", "start": [119, 1], "end": [119, 93], "kind": "commanddeclaration"}, {"full_name": "Prop.decidablePredTop", "code": "instance Prop.decidablePredTop : DecidablePred (\u22a4 : \u03b1 \u2192 Prop) := fun _ => instDecidableTrue", "start": [121, 1], "end": [121, 92], "kind": "commanddeclaration"}, {"full_name": "Prop.decidableRelBot", "code": "instance Prop.decidableRelBot : DecidableRel (\u22a5 : \u03b1 \u2192 \u03b1 \u2192 Prop) := fun _ _ => instDecidableFalse", "start": [123, 1], "end": [123, 97], "kind": "commanddeclaration"}, {"full_name": "Prop.decidableRelTop", "code": "instance Prop.decidableRelTop : DecidableRel (\u22a4 : \u03b1 \u2192 \u03b1 \u2192 Prop) := fun _ _ => instDecidableTrue", "start": [125, 1], "end": [125, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Group/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NeZero.of_map", "code": "theorem of_map {R M} [Zero R] [Zero M] [ZeroHomClass F R M]\n    (f : F) {r : R} [neZero : NeZero (f r)] : NeZero r", "start": [29, 1], "end": [31, 66], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_injective", "code": "theorem of_injective {R M} [Zero R] {r : R} [NeZero r] [Zero M] [ZeroHomClass F R M] {f : F}\n    (hf : Function.Injective f) : NeZero (f r)", "start": [34, 1], "end": [38, 28], "kind": "commanddeclaration"}, {"full_name": "invMonoidHom", "code": "@[to_additive \"Negation on a commutative additive group, considered as an additive monoid\nhomomorphism.\"]\ndef invMonoidHom : \u03b1 \u2192* \u03b1 where\n  toFun := Inv.inv\n  map_one' := inv_one\n  map_mul' := mul_inv", "start": [47, 1], "end": [53, 22], "kind": "commanddeclaration"}, {"full_name": "coe_invMonoidHom", "code": "@[simp]\ntheorem coe_invMonoidHom : (invMonoidHom : \u03b1 \u2192 \u03b1) = Inv.inv", "start": [57, 1], "end": [58, 67], "kind": "commanddeclaration"}, {"full_name": "invMonoidHom_apply", "code": "@[simp]\ntheorem invMonoidHom_apply (a : \u03b1) : invMonoidHom a = a\u207b\u00b9", "start": [61, 1], "end": [62, 65], "kind": "commanddeclaration"}, {"full_name": "MulHom.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply {M N} [Mul M] [CommSemigroup N] (f g : M \u2192\u2099* N) (x : M) :\n    (f * g) x = f x * g x", "start": [81, 1], "end": [83, 33], "kind": "commanddeclaration"}, {"full_name": "MulHom.mul_comp", "code": "@[to_additive]\ntheorem mul_comp [Mul M] [Mul N] [CommSemigroup P] (g\u2081 g\u2082 : N \u2192\u2099* P) (f : M \u2192\u2099* N) :\n    (g\u2081 * g\u2082).comp f = g\u2081.comp f * g\u2082.comp f", "start": [87, 1], "end": [89, 52], "kind": "commanddeclaration"}, {"full_name": "MulHom.comp_mul", "code": "@[to_additive]\ntheorem comp_mul [Mul M] [CommSemigroup N] [CommSemigroup P] (g : N \u2192\u2099* P) (f\u2081 f\u2082 : M \u2192\u2099* N) :\n    g.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082", "start": [93, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mul", "code": "@[to_additive]\ninstance mul {M N} [MulOneClass M] [CommMonoid N] : Mul (M \u2192* N) :=\n  \u27e8fun f g =>\n    { toFun := fun m => f m * g m,\n      map_one' := show f 1 * g 1 = 1 by simp,\n      map_mul' := fun x y => by\n        intros\n        show f (x * y) * g (x * y) = f x * g x * (f y * g y)\n        rw [f.map_mul, g.map_mul, \u2190 mul_assoc, \u2190 mul_assoc, mul_right_comm (f x)] }\u27e9", "start": [107, 1], "end": [117, 85], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mul_apply", "code": "@[to_additive (attr := simp)]\ntheorem mul_apply {M N} [MulOneClass M] [CommMonoid N] (f g : M \u2192* N) (x : M) :\n    (f * g) x = f x * g x", "start": [123, 1], "end": [125, 33], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mul_comp", "code": "@[to_additive]\ntheorem mul_comp [MulOneClass M] [MulOneClass N] [CommMonoid P] (g\u2081 g\u2082 : N \u2192* P) (f : M \u2192* N) :\n    (g\u2081 * g\u2082).comp f = g\u2081.comp f * g\u2082.comp f", "start": [129, 1], "end": [131, 52], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_mul", "code": "@[to_additive]\ntheorem comp_mul [MulOneClass M] [CommMonoid N] [CommMonoid P] (g : N \u2192* P) (f\u2081 f\u2082 : M \u2192* N) :\n    g.comp (f\u2081 * f\u2082) = g.comp f\u2081 * g.comp f\u2082", "start": [135, 1], "end": [139, 64], "kind": "commanddeclaration"}, {"full_name": "injective_iff_map_eq_one", "code": "@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff\n  its kernel is trivial. For the iff statement on the triviality of the kernel,\n  see `injective_iff_map_eq_zero'`.\"]\ntheorem _root_.injective_iff_map_eq_one {G H} [Group G] [MulOneClass H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f \u2194 \u2200 a, f a = 1 \u2192 a = 1", "start": [143, 1], "end": [152, 87], "kind": "commanddeclaration"}, {"full_name": "injective_iff_map_eq_one'", "code": "@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff its\n  kernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n  `injective_iff_map_eq_zero`.\"]\ntheorem _root_.injective_iff_map_eq_one' {G H} [Group G] [MulOneClass H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f \u2194 \u2200 a, f a = 1 \u2194 a = 1", "start": [156, 1], "end": [166, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofMapMulInv", "code": "@[to_additive\n  \"Makes an additive group homomorphism from a proof that the map preserves\n  the operation `fun a b => a + -b`. See also `AddMonoidHom.ofMapSub` for a version using\n  `fun a b => a - b`.\"]\ndef ofMapMulInv {H : Type*} [Group H] (f : G \u2192 H)\n    (map_div : \u2200 a b : G, f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9) : G \u2192* H :=\n  (mk' f) fun x y =>\n    calc\n      f (x * y) = f x * (f <| 1 * 1\u207b\u00b9 * y\u207b\u00b9)\u207b\u00b9 := by\n        { simp only [one_mul, inv_one, \u2190 map_div, inv_inv] }\n      _ = f x * f y := by\n        { simp only [map_div]\n          simp only [mul_right_inv, one_mul, inv_inv] }", "start": [172, 1], "end": [187, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_of_map_mul_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_of_map_mul_inv {H : Type*} [Group H] (f : G \u2192 H)\n    (map_div : \u2200 a b : G, f (a * b\u207b\u00b9) = f a * (f b)\u207b\u00b9) :\n  \u2191(ofMapMulInv f map_div) = f", "start": [191, 1], "end": [194, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofMapDiv", "code": "@[to_additive \"Define a morphism of additive groups given a map which respects difference.\"]\ndef ofMapDiv {H : Type*} [Group H] (f : G \u2192 H) (hf : \u2200 x y, f (x / y) = f x / f y) : G \u2192* H :=\n  ofMapMulInv f (by simpa only [div_eq_mul_inv] using hf)", "start": [198, 1], "end": [201, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_of_map_div", "code": "@[to_additive (attr := simp)]\ntheorem coe_of_map_div {H : Type*} [Group H] (f : G \u2192 H) (hf : \u2200 x y, f (x / y) = f x / f y) :\n    \u2191(ofMapDiv f hf) = f", "start": [205, 1], "end": [207, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inv_apply", "code": "@[to_additive (attr := simp)]\ntheorem inv_apply {M G} [MulOneClass M] [CommGroup G] (f : M \u2192* G) (x : M) :\n    f\u207b\u00b9 x = (f x)\u207b\u00b9", "start": [218, 1], "end": [220, 27], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inv_comp", "code": "@[to_additive (attr := simp)]\ntheorem inv_comp {M N A} [MulOneClass M] [MulOneClass N] [CommGroup A]\n    (\u03c6 : N \u2192* A) (\u03c8 : M \u2192* N) : \u03c6\u207b\u00b9.comp \u03c8 = (\u03c6.comp \u03c8)\u207b\u00b9", "start": [224, 1], "end": [228, 55], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comp_inv", "code": "@[to_additive (attr := simp)]\ntheorem comp_inv {M A B} [MulOneClass M] [CommGroup A] [CommGroup B]\n    (\u03c6 : A \u2192* B) (\u03c8 : M \u2192* A) : \u03c6.comp \u03c8\u207b\u00b9 = (\u03c6.comp \u03c8)\u207b\u00b9", "start": [232, 1], "end": [236, 64], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.div_apply", "code": "@[to_additive (attr := simp)]\ntheorem div_apply {M G} [MulOneClass M] [CommGroup G] (f g : M \u2192* G) (x : M) :\n    (f / g) x = f x / g x", "start": [248, 1], "end": [250, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/Defs.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Order/Ring/Lemmas.lean", "Mathlib/Order/MinMax.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Order/Monoid/NatCast.lean", "Mathlib/Algebra/Order/Monoid/WithZero/Defs.lean"], "premises": [{"full_name": "add_one_le_two_mul", "code": "theorem add_one_le_two_mul [LE \u03b1] [Semiring \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {a : \u03b1}\n    (a1 : 1 \u2264 a) : a + 1 \u2264 2 * a", "start": [122, 1], "end": [126, 34], "kind": "commanddeclaration"}, {"full_name": "OrderedSemiring", "code": "class OrderedSemiring (\u03b1 : Type u) extends Semiring \u03b1, OrderedAddCommMonoid \u03b1 where\n  \n  protected zero_le_one : (0 : \u03b1) \u2264 1\n  \n  protected mul_le_mul_of_nonneg_left : \u2200 a b c : \u03b1, a \u2264 b \u2192 0 \u2264 c \u2192 c * a \u2264 c * b\n  \n  protected mul_le_mul_of_nonneg_right : \u2200 a b c : \u03b1, a \u2264 b \u2192 0 \u2264 c \u2192 a * c \u2264 b * c", "start": [129, 1], "end": [139, 84], "kind": "commanddeclaration"}, {"full_name": "OrderedCommSemiring", "code": "class OrderedCommSemiring (\u03b1 : Type u) extends OrderedSemiring \u03b1, CommSemiring \u03b1 where\n  mul_le_mul_of_nonneg_right a b c ha hc :=\n    (by simpa only [mul_comm] using mul_le_mul_of_nonneg_left a b c ha hc)", "start": [142, 1], "end": [147, 75], "kind": "commanddeclaration"}, {"full_name": "OrderedRing", "code": "class OrderedRing (\u03b1 : Type u) extends Ring \u03b1, OrderedAddCommGroup \u03b1 where\n  \n  protected zero_le_one : 0 \u2264 (1 : \u03b1)\n  \n  protected mul_nonneg : \u2200 a b : \u03b1, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 \u2264 a * b", "start": [150, 1], "end": [156, 62], "kind": "commanddeclaration"}, {"full_name": "OrderedCommRing", "code": "class OrderedCommRing (\u03b1 : Type u) extends OrderedRing \u03b1, CommRing \u03b1", "start": [159, 1], "end": [161, 69], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring", "code": "class StrictOrderedSemiring (\u03b1 : Type u) extends Semiring \u03b1, OrderedCancelAddCommMonoid \u03b1,\n    Nontrivial \u03b1 where\n  \n  protected zero_le_one : (0 : \u03b1) \u2264 1\n  \n  protected mul_lt_mul_of_pos_left : \u2200 a b c : \u03b1, a < b \u2192 0 < c \u2192 c * a < c * b\n  \n  protected mul_lt_mul_of_pos_right : \u2200 a b c : \u03b1, a < b \u2192 0 < c \u2192 a * c < b * c", "start": [164, 1], "end": [173, 81], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommSemiring", "code": "class StrictOrderedCommSemiring (\u03b1 : Type u) extends StrictOrderedSemiring \u03b1, CommSemiring \u03b1", "start": [176, 1], "end": [178, 93], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedRing", "code": "class StrictOrderedRing (\u03b1 : Type u) extends Ring \u03b1, OrderedAddCommGroup \u03b1, Nontrivial \u03b1 where\n  \n  protected zero_le_one : 0 \u2264 (1 : \u03b1)\n  \n  protected mul_pos : \u2200 a b : \u03b1, 0 < a \u2192 0 < b \u2192 0 < a * b", "start": [181, 1], "end": [187, 59], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommRing", "code": "class StrictOrderedCommRing (\u03b1 : Type*) extends StrictOrderedRing \u03b1, CommRing \u03b1", "start": [190, 1], "end": [192, 80], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemiring", "code": "class LinearOrderedSemiring (\u03b1 : Type u) extends StrictOrderedSemiring \u03b1,\n  LinearOrderedAddCommMonoid \u03b1", "start": [198, 1], "end": [201, 31], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommSemiring", "code": "class LinearOrderedCommSemiring (\u03b1 : Type*) extends StrictOrderedCommSemiring \u03b1,\n  LinearOrderedSemiring \u03b1", "start": [204, 1], "end": [207, 26], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing", "code": "class LinearOrderedRing (\u03b1 : Type u) extends StrictOrderedRing \u03b1, LinearOrder \u03b1", "start": [210, 1], "end": [212, 80], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommRing", "code": "class LinearOrderedCommRing (\u03b1 : Type u) extends LinearOrderedRing \u03b1, CommMonoid \u03b1", "start": [215, 1], "end": [217, 83], "kind": "commanddeclaration"}, {"full_name": "OrderedSemiring.zeroLEOneClass", "code": "instance (priority := 100) OrderedSemiring.zeroLEOneClass : ZeroLEOneClass \u03b1 :=\n  { \u2039OrderedSemiring \u03b1\u203a with }", "start": [225, 1], "end": [226, 31], "kind": "commanddeclaration"}, {"full_name": "OrderedSemiring.toPosMulMono", "code": "instance (priority := 200) OrderedSemiring.toPosMulMono : PosMulMono \u03b1 :=\n  \u27e8fun x _ _ h => OrderedSemiring.mul_le_mul_of_nonneg_left _ _ _ h x.2\u27e9", "start": [230, 1], "end": [231, 73], "kind": "commanddeclaration"}, {"full_name": "OrderedSemiring.toMulPosMono", "code": "instance (priority := 200) OrderedSemiring.toMulPosMono : MulPosMono \u03b1 :=\n  \u27e8fun x _ _ h => OrderedSemiring.mul_le_mul_of_nonneg_right _ _ _ h x.2\u27e9", "start": [235, 1], "end": [236, 74], "kind": "commanddeclaration"}, {"full_name": "bit1_mono", "code": "theorem bit1_mono : Monotone (bit1 : \u03b1 \u2192 \u03b1)", "start": [240, 1], "end": [240, 93], "kind": "commanddeclaration"}, {"full_name": "pow_nonneg", "code": "@[simp]\ntheorem pow_nonneg (H : 0 \u2264 a) : \u2200 n : \u2115, 0 \u2264 a ^ n", "start": [243, 1], "end": [250, 40], "kind": "commanddeclaration"}, {"full_name": "add_le_mul_two_add", "code": "theorem add_le_mul_two_add (a2 : 2 \u2264 a) (b0 : 0 \u2264 b) : a + (2 + b) \u2264 a * (2 + b)", "start": [254, 1], "end": [258, 59], "kind": "commanddeclaration"}, {"full_name": "one_le_mul_of_one_le_of_one_le", "code": "theorem one_le_mul_of_one_le_of_one_le (ha : 1 \u2264 a) (hb : 1 \u2264 b) : (1 : \u03b1) \u2264 a * b", "start": [261, 1], "end": [262, 60], "kind": "commanddeclaration"}, {"full_name": "monotone_mul_left_of_nonneg", "code": "theorem monotone_mul_left_of_nonneg (ha : 0 \u2264 a) : Monotone fun x => a * x", "start": [269, 1], "end": [270, 33], "kind": "commanddeclaration"}, {"full_name": "monotone_mul_right_of_nonneg", "code": "theorem monotone_mul_right_of_nonneg (ha : 0 \u2264 a) : Monotone fun x => x * a", "start": [273, 1], "end": [274, 34], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_const", "code": "theorem Monotone.mul_const (hf : Monotone f) (ha : 0 \u2264 a) : Monotone fun x => f x * a", "start": [277, 1], "end": [278, 44], "kind": "commanddeclaration"}, {"full_name": "Monotone.const_mul", "code": "theorem Monotone.const_mul (hf : Monotone f) (ha : 0 \u2264 a) : Monotone fun x => a * f x", "start": [281, 1], "end": [282, 43], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul_const", "code": "theorem Antitone.mul_const (hf : Antitone f) (ha : 0 \u2264 a) : Antitone fun x => f x * a", "start": [285, 1], "end": [286, 53], "kind": "commanddeclaration"}, {"full_name": "Antitone.const_mul", "code": "theorem Antitone.const_mul (hf : Antitone f) (ha : 0 \u2264 a) : Antitone fun x => a * f x", "start": [289, 1], "end": [290, 52], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul", "code": "theorem Monotone.mul (hf : Monotone f) (hg : Monotone g) (hf\u2080 : \u2200 x, 0 \u2264 f x) (hg\u2080 : \u2200 x, 0 \u2264 g x) :\n    Monotone (f * g)", "start": [293, 1], "end": [294, 78], "kind": "commanddeclaration"}, {"full_name": "bit1_pos", "code": "theorem bit1_pos [Nontrivial \u03b1] (h : 0 \u2264 a) : 0 < bit1 a", "start": [302, 1], "end": [303, 65], "kind": "commanddeclaration"}, {"full_name": "bit1_pos'", "code": "theorem bit1_pos' (h : 0 < a) : 0 < bit1 a", "start": [306, 1], "end": [308, 22], "kind": "commanddeclaration"}, {"full_name": "mul_le_one", "code": "theorem mul_le_one (ha : a \u2264 1) (hb' : 0 \u2264 b) (hb : b \u2264 1) : a * b \u2264 1", "start": [313, 1], "end": [314, 53], "kind": "commanddeclaration"}, {"full_name": "one_lt_mul_of_le_of_lt", "code": "theorem one_lt_mul_of_le_of_lt (ha : 1 \u2264 a) (hb : 1 < b) : 1 < a * b", "start": [317, 1], "end": [318, 68], "kind": "commanddeclaration"}, {"full_name": "one_lt_mul_of_lt_of_le", "code": "theorem one_lt_mul_of_lt_of_le (ha : 1 < a) (hb : 1 \u2264 b) : 1 < a * b", "start": [321, 1], "end": [322, 69], "kind": "commanddeclaration"}, {"full_name": "one_lt_mul", "code": "alias one_lt_mul := one_lt_mul_of_le_of_lt", "start": [325, 1], "end": [325, 43], "kind": "stdtacticaliasalias"}, {"full_name": "mul_lt_one_of_nonneg_of_lt_one_left", "code": "theorem mul_lt_one_of_nonneg_of_lt_one_left (ha\u2080 : 0 \u2264 a) (ha : a < 1) (hb : b \u2264 1) : a * b < 1", "start": [328, 1], "end": [329, 46], "kind": "commanddeclaration"}, {"full_name": "mul_lt_one_of_nonneg_of_lt_one_right", "code": "theorem mul_lt_one_of_nonneg_of_lt_one_right (ha : a \u2264 1) (hb\u2080 : 0 \u2264 b) (hb : b < 1) : a * b < 1", "start": [332, 1], "end": [333, 45], "kind": "commanddeclaration"}, {"full_name": "OrderedRing.toOrderedSemiring", "code": "instance (priority := 100) OrderedRing.toOrderedSemiring : OrderedSemiring \u03b1 :=\n  { \u2039OrderedRing \u03b1\u203a, (Ring.toSemiring : Semiring \u03b1) with\n    mul_le_mul_of_nonneg_left := fun a b c h hc => by\n      simpa only [mul_sub, sub_nonneg] using OrderedRing.mul_nonneg _ _ hc (sub_nonneg.2 h),\n    mul_le_mul_of_nonneg_right := fun a b c h hc => by\n      simpa only [sub_mul, sub_nonneg] using OrderedRing.mul_nonneg _ _ (sub_nonneg.2 h) hc }", "start": [343, 1], "end": [348, 94], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_left", "code": "theorem mul_le_mul_of_nonpos_left (h : b \u2264 a) (hc : c \u2264 0) : c * a \u2264 c * b", "start": [351, 1], "end": [352, 91], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_right", "code": "theorem mul_le_mul_of_nonpos_right (h : b \u2264 a) (hc : c \u2264 0) : a * c \u2264 b * c", "start": [355, 1], "end": [356, 92], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg_of_nonpos_of_nonpos", "code": "theorem mul_nonneg_of_nonpos_of_nonpos (ha : a \u2264 0) (hb : b \u2264 0) : 0 \u2264 a * b", "start": [359, 1], "end": [360, 63], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonneg_of_nonpos", "code": "theorem mul_le_mul_of_nonneg_of_nonpos (hca : c \u2264 a) (hbd : b \u2264 d) (hc : 0 \u2264 c) (hb : b \u2264 0) :\n    a * b \u2264 c * d", "start": [363, 1], "end": [365, 80], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonneg_of_nonpos'", "code": "theorem mul_le_mul_of_nonneg_of_nonpos' (hca : c \u2264 a) (hbd : b \u2264 d) (ha : 0 \u2264 a) (hd : d \u2264 0) :\n    a * b \u2264 c * d", "start": [368, 1], "end": [370, 80], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_of_nonneg", "code": "theorem mul_le_mul_of_nonpos_of_nonneg (hac : a \u2264 c) (hdb : d \u2264 b) (hc : c \u2264 0) (hb : 0 \u2264 b) :\n    a * b \u2264 c * d", "start": [373, 1], "end": [375, 80], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_of_nonneg'", "code": "theorem mul_le_mul_of_nonpos_of_nonneg' (hca : c \u2264 a) (hbd : b \u2264 d) (ha : 0 \u2264 a) (hd : d \u2264 0) :\n    a * b \u2264 c * d", "start": [378, 1], "end": [380, 80], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_of_nonpos", "code": "theorem mul_le_mul_of_nonpos_of_nonpos (hca : c \u2264 a) (hdb : d \u2264 b) (hc : c \u2264 0) (hb : b \u2264 0) :\n    a * b \u2264 c * d", "start": [383, 1], "end": [385, 80], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_of_nonpos_of_nonpos'", "code": "theorem mul_le_mul_of_nonpos_of_nonpos' (hca : c \u2264 a) (hdb : d \u2264 b) (ha : a \u2264 0) (hd : d \u2264 0) :\n    a * b \u2264 c * d", "start": [388, 1], "end": [390, 80], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_one_left", "code": "theorem le_mul_of_le_one_left (hb : b \u2264 0) (h : a \u2264 1) : b \u2264 a * b", "start": [393, 1], "end": [395, 61], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_one_le_left", "code": "theorem mul_le_of_one_le_left (hb : b \u2264 0) (h : 1 \u2264 a) : a * b \u2264 b", "start": [398, 1], "end": [400, 61], "kind": "commanddeclaration"}, {"full_name": "le_mul_of_le_one_right", "code": "theorem le_mul_of_le_one_right (ha : a \u2264 0) (h : b \u2264 1) : a \u2264 a * b", "start": [403, 1], "end": [405, 60], "kind": "commanddeclaration"}, {"full_name": "mul_le_of_one_le_right", "code": "theorem mul_le_of_one_le_right (ha : a \u2264 0) (h : 1 \u2264 b) : a * b \u2264 a", "start": [408, 1], "end": [410, 60], "kind": "commanddeclaration"}, {"full_name": "antitone_mul_left", "code": "theorem antitone_mul_left {a : \u03b1} (ha : a \u2264 0) : Antitone ((\u00b7 * \u00b7) a)", "start": [417, 1], "end": [418, 38], "kind": "commanddeclaration"}, {"full_name": "antitone_mul_right", "code": "theorem antitone_mul_right {a : \u03b1} (ha : a \u2264 0) : Antitone fun x => x * a", "start": [421, 1], "end": [422, 39], "kind": "commanddeclaration"}, {"full_name": "Monotone.const_mul_of_nonpos", "code": "theorem Monotone.const_mul_of_nonpos (hf : Monotone f) (ha : a \u2264 0) : Antitone fun x => a * f x", "start": [425, 1], "end": [426, 42], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_const_of_nonpos", "code": "theorem Monotone.mul_const_of_nonpos (hf : Monotone f) (ha : a \u2264 0) : Antitone fun x => f x * a", "start": [429, 1], "end": [430, 43], "kind": "commanddeclaration"}, {"full_name": "Antitone.const_mul_of_nonpos", "code": "theorem Antitone.const_mul_of_nonpos (hf : Antitone f) (ha : a \u2264 0) : Monotone fun x => a * f x", "start": [433, 1], "end": [434, 33], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul_const_of_nonpos", "code": "theorem Antitone.mul_const_of_nonpos (hf : Antitone f) (ha : a \u2264 0) : Monotone fun x => f x * a", "start": [437, 1], "end": [438, 34], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul_monotone", "code": "theorem Antitone.mul_monotone (hf : Antitone f) (hg : Monotone g) (hf\u2080 : \u2200 x, f x \u2264 0)\n    (hg\u2080 : \u2200 x, 0 \u2264 g x) : Antitone (f * g)", "start": [441, 1], "end": [443, 63], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_antitone", "code": "theorem Monotone.mul_antitone (hf : Monotone f) (hg : Antitone g) (hf\u2080 : \u2200 x, 0 \u2264 f x)\n    (hg\u2080 : \u2200 x, g x \u2264 0) : Antitone (f * g)", "start": [446, 1], "end": [448, 63], "kind": "commanddeclaration"}, {"full_name": "Antitone.mul", "code": "theorem Antitone.mul (hf : Antitone f) (hg : Antitone g) (hf\u2080 : \u2200 x, f x \u2264 0) (hg\u2080 : \u2200 x, g x \u2264 0) :\n    Monotone (f * g)", "start": [451, 1], "end": [452, 98], "kind": "commanddeclaration"}, {"full_name": "le_iff_exists_nonneg_add", "code": "theorem le_iff_exists_nonneg_add (a b : \u03b1) : a \u2264 b \u2194 \u2203 c \u2265 0, b = a + c", "start": [457, 1], "end": [460, 14], "kind": "commanddeclaration"}, {"full_name": "OrderedCommRing.toOrderedCommSemiring", "code": "instance (priority := 100) OrderedCommRing.toOrderedCommSemiring : OrderedCommSemiring \u03b1 :=\n  { OrderedRing.toOrderedSemiring, \u2039OrderedCommRing \u03b1\u203a with }", "start": [470, 1], "end": [471, 62], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring.toPosMulStrictMono", "code": "instance (priority := 200) StrictOrderedSemiring.toPosMulStrictMono : PosMulStrictMono \u03b1 :=\n  \u27e8fun x _ _ h => StrictOrderedSemiring.mul_lt_mul_of_pos_left _ _ _ h x.prop\u27e9", "start": [481, 1], "end": [482, 79], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring.toMulPosStrictMono", "code": "instance (priority := 200) StrictOrderedSemiring.toMulPosStrictMono : MulPosStrictMono \u03b1 :=\n  \u27e8fun x _ _ h => StrictOrderedSemiring.mul_lt_mul_of_pos_right _ _ _ h x.prop\u27e9", "start": [486, 1], "end": [487, 80], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring.toOrderedSemiring'", "code": "@[reducible]\ndef StrictOrderedSemiring.toOrderedSemiring' [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : OrderedSemiring \u03b1 :=\n  { \u2039StrictOrderedSemiring \u03b1\u203a with\n    mul_le_mul_of_nonneg_left := fun a b c hab hc => by\n      obtain rfl | hab := Decidable.eq_or_lt_of_le hab\n      \u00b7 rfl\n      obtain rfl | hc := Decidable.eq_or_lt_of_le hc\n      \u00b7 simp\n      \u00b7 exact (mul_lt_mul_of_pos_left hab hc).le,\n    mul_le_mul_of_nonneg_right := fun a b c hab hc => by\n      obtain rfl | hab := Decidable.eq_or_lt_of_le hab\n      \u00b7 rfl\n      obtain rfl | hc := Decidable.eq_or_lt_of_le hc\n      \u00b7 simp\n      \u00b7 exact (mul_lt_mul_of_pos_right hab hc).le }", "start": [491, 1], "end": [507, 52], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring.toOrderedSemiring", "code": "instance (priority := 100) StrictOrderedSemiring.toOrderedSemiring : OrderedSemiring \u03b1 :=\n  { \u2039StrictOrderedSemiring \u03b1\u203a with\n    mul_le_mul_of_nonneg_left := fun _ _ _ =>\n      letI := @StrictOrderedSemiring.toOrderedSemiring' \u03b1 _ (Classical.decRel _)\n      mul_le_mul_of_nonneg_left,\n    mul_le_mul_of_nonneg_right := fun _ _ _ =>\n      letI := @StrictOrderedSemiring.toOrderedSemiring' \u03b1 _ (Classical.decRel _)\n      mul_le_mul_of_nonneg_right }", "start": [511, 1], "end": [518, 35], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul", "code": "theorem mul_lt_mul (hac : a < c) (hbd : b \u2264 d) (hb : 0 < b) (hc : 0 \u2264 c) : a * b < c * d", "start": [521, 1], "end": [522, 80], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul'", "code": "theorem mul_lt_mul' (hac : a \u2264 c) (hbd : b < d) (hb : 0 \u2264 b) (hc : 0 < c) : a * b < c * d", "start": [525, 1], "end": [526, 80], "kind": "commanddeclaration"}, {"full_name": "pow_pos", "code": "@[simp]\ntheorem pow_pos (H : 0 < a) : \u2200 n : \u2115, 0 < a ^ n", "start": [529, 1], "end": [537, 34], "kind": "commanddeclaration"}, {"full_name": "mul_self_lt_mul_self", "code": "theorem mul_self_lt_mul_self (h1 : 0 \u2264 a) (h2 : a < b) : a * a < b * b", "start": [540, 1], "end": [541, 44], "kind": "commanddeclaration"}, {"full_name": "strictMonoOn_mul_self", "code": "theorem strictMonoOn_mul_self : StrictMonoOn (fun x : \u03b1 => x * x) { x | 0 \u2264 x }", "start": [548, 1], "end": [549, 50], "kind": "commanddeclaration"}, {"full_name": "Decidable.mul_lt_mul''", "code": "protected theorem Decidable.mul_lt_mul'' [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] (h1 : a < c) (h2 : b < d)\n    (h3 : 0 \u2264 a) (h4 : 0 \u2264 b) : a * b < c * d", "start": [553, 1], "end": [556, 73], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul''", "code": "theorem mul_lt_mul'' : a < c \u2192 b < d \u2192 0 \u2264 a \u2192 0 \u2264 b \u2192 a * b < c * d", "start": [559, 1], "end": [560, 31], "kind": "commanddeclaration"}, {"full_name": "lt_mul_left", "code": "theorem lt_mul_left (hn : 0 < a) (hm : 1 < b) : a < b * a", "start": [563, 1], "end": [565, 15], "kind": "commanddeclaration"}, {"full_name": "lt_mul_right", "code": "theorem lt_mul_right (hn : 0 < a) (hm : 1 < b) : a < a * b", "start": [568, 1], "end": [570, 15], "kind": "commanddeclaration"}, {"full_name": "lt_mul_self", "code": "theorem lt_mul_self (hn : 1 < a) : a < a * a", "start": [573, 1], "end": [574, 44], "kind": "commanddeclaration"}, {"full_name": "strictMono_mul_left_of_pos", "code": "theorem strictMono_mul_left_of_pos (ha : 0 < a) : StrictMono fun x => a * x", "start": [581, 1], "end": [582, 35], "kind": "commanddeclaration"}, {"full_name": "strictMono_mul_right_of_pos", "code": "theorem strictMono_mul_right_of_pos (ha : 0 < a) : StrictMono fun x => x * a", "start": [585, 1], "end": [586, 36], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul_const", "code": "theorem StrictMono.mul_const (hf : StrictMono f) (ha : 0 < a) : StrictMono fun x => f x * a", "start": [589, 1], "end": [590, 43], "kind": "commanddeclaration"}, {"full_name": "StrictMono.const_mul", "code": "theorem StrictMono.const_mul (hf : StrictMono f) (ha : 0 < a) : StrictMono fun x => a * f x", "start": [593, 1], "end": [594, 42], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.mul_const", "code": "theorem StrictAnti.mul_const (hf : StrictAnti f) (ha : 0 < a) : StrictAnti fun x => f x * a", "start": [597, 1], "end": [598, 54], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.const_mul", "code": "theorem StrictAnti.const_mul (hf : StrictAnti f) (ha : 0 < a) : StrictAnti fun x => a * f x", "start": [601, 1], "end": [602, 53], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul_monotone", "code": "theorem StrictMono.mul_monotone (hf : StrictMono f) (hg : Monotone g) (hf\u2080 : \u2200 x, 0 \u2264 f x)\n    (hg\u2080 : \u2200 x, 0 < g x) : StrictMono (f * g)", "start": [605, 1], "end": [607, 46], "kind": "commanddeclaration"}, {"full_name": "Monotone.mul_strictMono", "code": "theorem Monotone.mul_strictMono (hf : Monotone f) (hg : StrictMono g) (hf\u2080 : \u2200 x, 0 < f x)\n    (hg\u2080 : \u2200 x, 0 \u2264 g x) : StrictMono (f * g)", "start": [610, 1], "end": [612, 47], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul", "code": "theorem StrictMono.mul (hf : StrictMono f) (hg : StrictMono g) (hf\u2080 : \u2200 x, 0 \u2264 f x)\n    (hg\u2080 : \u2200 x, 0 \u2264 g x) : StrictMono (f * g)", "start": [615, 1], "end": [617, 45], "kind": "commanddeclaration"}, {"full_name": "lt_two_mul_self", "code": "theorem lt_two_mul_self (ha : 0 < a) : a < 2 * a", "start": [622, 1], "end": [623, 38], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedSemiring.toNoMaxOrder", "code": "instance (priority := 100) StrictOrderedSemiring.toNoMaxOrder : NoMaxOrder \u03b1 :=\n  \u27e8fun a => \u27e8a + 1, lt_add_of_pos_right _ one_pos\u27e9\u27e9", "start": [627, 1], "end": [628, 52], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommSemiring.toOrderedCommSemiring'", "code": "@[reducible]\ndef StrictOrderedCommSemiring.toOrderedCommSemiring' [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] :\n    OrderedCommSemiring \u03b1 :=\n  { \u2039StrictOrderedCommSemiring \u03b1\u203a, StrictOrderedSemiring.toOrderedSemiring' with }", "start": [638, 1], "end": [643, 83], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommSemiring.toOrderedCommSemiring", "code": "instance (priority := 100) StrictOrderedCommSemiring.toOrderedCommSemiring :\n    OrderedCommSemiring \u03b1 :=\n  { \u2039StrictOrderedCommSemiring \u03b1\u203a, StrictOrderedSemiring.toOrderedSemiring with }", "start": [647, 1], "end": [649, 82], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedRing.toStrictOrderedSemiring", "code": "instance (priority := 100) StrictOrderedRing.toStrictOrderedSemiring : StrictOrderedSemiring \u03b1 :=\n  { \u2039StrictOrderedRing \u03b1\u203a, (Ring.toSemiring : Semiring \u03b1) with\n    le_of_add_le_add_left := @le_of_add_le_add_left \u03b1 _ _ _,\n    mul_lt_mul_of_pos_left := fun a b c h hc => by\n      simpa only [mul_sub, sub_pos] using StrictOrderedRing.mul_pos _ _ hc (sub_pos.2 h),\n    mul_lt_mul_of_pos_right := fun a b c h hc => by\n      simpa only [sub_mul, sub_pos] using StrictOrderedRing.mul_pos _ _ (sub_pos.2 h) hc }", "start": [659, 1], "end": [665, 91], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedRing.toOrderedRing'", "code": "@[reducible]\ndef StrictOrderedRing.toOrderedRing' [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : OrderedRing \u03b1 :=\n  { \u2039StrictOrderedRing \u03b1\u203a, (Ring.toSemiring : Semiring \u03b1) with\n    mul_nonneg := fun a b ha hb => by\n      obtain ha | ha := Decidable.eq_or_lt_of_le ha\n      \u00b7 rw [\u2190 ha, zero_mul]\n      obtain hb | hb := Decidable.eq_or_lt_of_le hb\n      \u00b7 rw [\u2190 hb, mul_zero]\n      \u00b7 exact (StrictOrderedRing.mul_pos _ _ ha hb).le }", "start": [669, 1], "end": [679, 57], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedRing.toOrderedRing", "code": "instance (priority := 100) StrictOrderedRing.toOrderedRing : OrderedRing \u03b1 :=\n  { \u2039StrictOrderedRing \u03b1\u203a with\n    mul_nonneg := fun a b =>\n      letI := @StrictOrderedRing.toOrderedRing' \u03b1 _ (Classical.decRel _)\n      mul_nonneg }", "start": [683, 1], "end": [687, 19], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_neg_left", "code": "theorem mul_lt_mul_of_neg_left (h : b < a) (hc : c < 0) : c * a < c * b", "start": [690, 1], "end": [691, 90], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_of_neg_right", "code": "theorem mul_lt_mul_of_neg_right (h : b < a) (hc : c < 0) : a * c < b * c", "start": [694, 1], "end": [695, 91], "kind": "commanddeclaration"}, {"full_name": "mul_pos_of_neg_of_neg", "code": "theorem mul_pos_of_neg_of_neg {a b : \u03b1} (ha : a < 0) (hb : b < 0) : 0 < a * b", "start": [698, 1], "end": [699, 60], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_one_left", "code": "theorem lt_mul_of_lt_one_left (hb : b < 0) (h : a < 1) : b < a * b", "start": [702, 1], "end": [704, 58], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_one_lt_left", "code": "theorem mul_lt_of_one_lt_left (hb : b < 0) (h : 1 < a) : a * b < b", "start": [707, 1], "end": [709, 58], "kind": "commanddeclaration"}, {"full_name": "lt_mul_of_lt_one_right", "code": "theorem lt_mul_of_lt_one_right (ha : a < 0) (h : b < 1) : a < a * b", "start": [712, 1], "end": [714, 57], "kind": "commanddeclaration"}, {"full_name": "mul_lt_of_one_lt_right", "code": "theorem mul_lt_of_one_lt_right (ha : a < 0) (h : 1 < b) : a * b < a", "start": [717, 1], "end": [719, 57], "kind": "commanddeclaration"}, {"full_name": "strictAnti_mul_left", "code": "theorem strictAnti_mul_left {a : \u03b1} (ha : a < 0) : StrictAnti ((\u00b7 * \u00b7) a)", "start": [726, 1], "end": [727, 35], "kind": "commanddeclaration"}, {"full_name": "strictAnti_mul_right", "code": "theorem strictAnti_mul_right {a : \u03b1} (ha : a < 0) : StrictAnti fun x => x * a", "start": [730, 1], "end": [731, 36], "kind": "commanddeclaration"}, {"full_name": "StrictMono.const_mul_of_neg", "code": "theorem StrictMono.const_mul_of_neg (hf : StrictMono f) (ha : a < 0) :\n    StrictAnti fun x => a * f x", "start": [734, 1], "end": [736, 46], "kind": "commanddeclaration"}, {"full_name": "StrictMono.mul_const_of_neg", "code": "theorem StrictMono.mul_const_of_neg (hf : StrictMono f) (ha : a < 0) :\n    StrictAnti fun x => f x * a", "start": [739, 1], "end": [741, 47], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.const_mul_of_neg", "code": "theorem StrictAnti.const_mul_of_neg (hf : StrictAnti f) (ha : a < 0) :\n    StrictMono fun x => a * f x", "start": [744, 1], "end": [746, 35], "kind": "commanddeclaration"}, {"full_name": "StrictAnti.mul_const_of_neg", "code": "theorem StrictAnti.mul_const_of_neg (hf : StrictAnti f) (ha : a < 0) :\n    StrictMono fun x => f x * a", "start": [749, 1], "end": [751, 36], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommRing.toOrderedCommRing'", "code": "@[reducible]\ndef StrictOrderedCommRing.toOrderedCommRing' [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] : OrderedCommRing \u03b1 :=\n  { \u2039StrictOrderedCommRing \u03b1\u203a, StrictOrderedRing.toOrderedRing' with }", "start": [763, 1], "end": [767, 71], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommRing.toStrictOrderedCommSemiring", "code": "instance (priority := 100) StrictOrderedCommRing.toStrictOrderedCommSemiring :\n    StrictOrderedCommSemiring \u03b1 :=\n  { \u2039StrictOrderedCommRing \u03b1\u203a, StrictOrderedRing.toStrictOrderedSemiring with }", "start": [771, 1], "end": [773, 80], "kind": "commanddeclaration"}, {"full_name": "StrictOrderedCommRing.toOrderedCommRing", "code": "instance (priority := 100) StrictOrderedCommRing.toOrderedCommRing : OrderedCommRing \u03b1 :=\n  { \u2039StrictOrderedCommRing \u03b1\u203a, StrictOrderedRing.toOrderedRing with }", "start": [777, 1], "end": [778, 70], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemiring.toPosMulReflectLT", "code": "instance (priority := 200) LinearOrderedSemiring.toPosMulReflectLT : PosMulReflectLT \u03b1 :=\n  \u27e8fun a _ _ => (monotone_mul_left_of_nonneg a.2).reflect_lt\u27e9", "start": [788, 1], "end": [789, 62], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemiring.toMulPosReflectLT", "code": "instance (priority := 200) LinearOrderedSemiring.toMulPosReflectLT : MulPosReflectLT \u03b1 :=\n  \u27e8fun a _ _ => (monotone_mul_right_of_nonneg a.2).reflect_lt\u27e9", "start": [793, 1], "end": [794, 63], "kind": "commanddeclaration"}, {"full_name": "nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nonneg", "code": "theorem nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nonneg (hab : 0 \u2264 a * b) :\n    0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "start": [799, 1], "end": [809, 47], "kind": "commanddeclaration"}, {"full_name": "nonneg_of_mul_nonneg_left", "code": "theorem nonneg_of_mul_nonneg_left (h : 0 \u2264 a * b) (hb : 0 < b) : 0 \u2264 a", "start": [812, 1], "end": [813, 64], "kind": "commanddeclaration"}, {"full_name": "nonneg_of_mul_nonneg_right", "code": "theorem nonneg_of_mul_nonneg_right (h : 0 \u2264 a * b) (ha : 0 < a) : 0 \u2264 b", "start": [816, 1], "end": [817, 64], "kind": "commanddeclaration"}, {"full_name": "neg_of_mul_neg_left", "code": "theorem neg_of_mul_neg_left (h : a * b < 0) (hb : 0 \u2264 b) : a < 0", "start": [820, 1], "end": [821, 53], "kind": "commanddeclaration"}, {"full_name": "neg_of_mul_neg_right", "code": "theorem neg_of_mul_neg_right (h : a * b < 0) (ha : 0 \u2264 a) : b < 0", "start": [824, 1], "end": [825, 53], "kind": "commanddeclaration"}, {"full_name": "nonpos_of_mul_nonpos_left", "code": "theorem nonpos_of_mul_nonpos_left (h : a * b \u2264 0) (hb : 0 < b) : a \u2264 0", "start": [828, 1], "end": [829, 58], "kind": "commanddeclaration"}, {"full_name": "nonpos_of_mul_nonpos_right", "code": "theorem nonpos_of_mul_nonpos_right (h : a * b \u2264 0) (ha : 0 < a) : b \u2264 0", "start": [832, 1], "end": [833, 58], "kind": "commanddeclaration"}, {"full_name": "zero_le_mul_left", "code": "@[simp]\ntheorem zero_le_mul_left (h : 0 < c) : 0 \u2264 c * b \u2194 0 \u2264 b", "start": [836, 1], "end": [842, 58], "kind": "commanddeclaration"}, {"full_name": "zero_le_mul_right", "code": "@[simp]\ntheorem zero_le_mul_right (h : 0 < c) : 0 \u2264 b * c \u2194 0 \u2264 b", "start": [845, 1], "end": [847, 59], "kind": "commanddeclaration"}, {"full_name": "add_le_mul_of_left_le_right", "code": "theorem add_le_mul_of_left_le_right (a2 : 2 \u2264 a) (ab : a \u2264 b) : a + b \u2264 a * b", "start": [851, 1], "end": [860, 48], "kind": "commanddeclaration"}, {"full_name": "add_le_mul_of_right_le_left", "code": "theorem add_le_mul_of_right_le_left (b2 : 2 \u2264 b) (ba : b \u2264 a) : a + b \u2264 a * b", "start": [864, 1], "end": [873, 47], "kind": "commanddeclaration"}, {"full_name": "add_le_mul", "code": "theorem add_le_mul (a2 : 2 \u2264 a) (b2 : 2 \u2264 b) : a + b \u2264 a * b", "start": [876, 1], "end": [878, 57], "kind": "commanddeclaration"}, {"full_name": "add_le_mul'", "code": "theorem add_le_mul' (a2 : 2 \u2264 a) (b2 : 2 \u2264 b) : a + b \u2264 b * a", "start": [881, 1], "end": [882, 53], "kind": "commanddeclaration"}, {"full_name": "bit0_le_bit0", "code": "@[simp]\ntheorem bit0_le_bit0 : bit0 a \u2264 bit0 b \u2194 a \u2264 b", "start": [888, 1], "end": [890, 85], "kind": "commanddeclaration"}, {"full_name": "bit0_lt_bit0", "code": "@[simp]\ntheorem bit0_lt_bit0 : bit0 a < bit0 b \u2194 a < b", "start": [893, 1], "end": [895, 85], "kind": "commanddeclaration"}, {"full_name": "bit1_le_bit1", "code": "@[simp]\ntheorem bit1_le_bit1 : bit1 a \u2264 bit1 b \u2194 a \u2264 b", "start": [898, 1], "end": [900, 46], "kind": "commanddeclaration"}, {"full_name": "bit1_lt_bit1", "code": "@[simp]\ntheorem bit1_lt_bit1 : bit1 a < bit1 b \u2194 a < b", "start": [903, 1], "end": [905, 46], "kind": "commanddeclaration"}, {"full_name": "one_le_bit1", "code": "@[simp]\ntheorem one_le_bit1 : (1 : \u03b1) \u2264 bit1 a \u2194 0 \u2264 a", "start": [908, 1], "end": [910, 99], "kind": "commanddeclaration"}, {"full_name": "one_lt_bit1", "code": "@[simp]\ntheorem one_lt_bit1 : (1 : \u03b1) < bit1 a \u2194 0 < a", "start": [913, 1], "end": [915, 96], "kind": "commanddeclaration"}, {"full_name": "zero_le_bit0", "code": "@[simp]\ntheorem zero_le_bit0 : (0 : \u03b1) \u2264 bit0 a \u2194 0 \u2264 a", "start": [918, 1], "end": [920, 69], "kind": "commanddeclaration"}, {"full_name": "zero_lt_bit0", "code": "@[simp]\ntheorem zero_lt_bit0 : (0 : \u03b1) < bit0 a \u2194 0 < a", "start": [923, 1], "end": [925, 69], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg_iff_right_nonneg_of_pos", "code": "theorem mul_nonneg_iff_right_nonneg_of_pos (ha : 0 < a) : 0 \u2264 a * b \u2194 0 \u2264 b", "start": [930, 1], "end": [931, 63], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg_iff_left_nonneg_of_pos", "code": "theorem mul_nonneg_iff_left_nonneg_of_pos (hb : 0 < b) : 0 \u2264 a * b \u2194 0 \u2264 a", "start": [934, 1], "end": [935, 73], "kind": "commanddeclaration"}, {"full_name": "nonpos_of_mul_nonneg_left", "code": "theorem nonpos_of_mul_nonneg_left (h : 0 \u2264 a * b) (hb : b < 0) : a \u2264 0", "start": [938, 1], "end": [939, 71], "kind": "commanddeclaration"}, {"full_name": "nonpos_of_mul_nonneg_right", "code": "theorem nonpos_of_mul_nonneg_right (h : 0 \u2264 a * b) (ha : a < 0) : b \u2264 0", "start": [942, 1], "end": [943, 71], "kind": "commanddeclaration"}, {"full_name": "Units.inv_pos", "code": "@[simp]\ntheorem Units.inv_pos {u : \u03b1\u02e3} : (0 : \u03b1) < \u2191u\u207b\u00b9 \u2194 (0 : \u03b1) < u", "start": [946, 1], "end": [950, 15], "kind": "commanddeclaration"}, {"full_name": "Units.inv_neg", "code": "@[simp]\ntheorem Units.inv_neg {u : \u03b1\u02e3} : \u2191u\u207b\u00b9 < (0 : \u03b1) \u2194 \u2191u < (0 : \u03b1)", "start": [953, 1], "end": [957, 15], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_pos_left", "code": "theorem cmp_mul_pos_left (ha : 0 < a) (b c : \u03b1) : cmp (a * b) (a * c) = cmp b c", "start": [960, 1], "end": [961, 49], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_pos_right", "code": "theorem cmp_mul_pos_right (ha : 0 < a) (b c : \u03b1) : cmp (b * a) (c * a) = cmp b c", "start": [964, 1], "end": [965, 50], "kind": "commanddeclaration"}, {"full_name": "mul_max_of_nonneg", "code": "theorem mul_max_of_nonneg (b c : \u03b1) (ha : 0 \u2264 a) : a * max b c = max (a * b) (a * c)", "start": [968, 1], "end": [969, 43], "kind": "commanddeclaration"}, {"full_name": "mul_min_of_nonneg", "code": "theorem mul_min_of_nonneg (b c : \u03b1) (ha : 0 \u2264 a) : a * min b c = min (a * b) (a * c)", "start": [972, 1], "end": [973, 43], "kind": "commanddeclaration"}, {"full_name": "max_mul_of_nonneg", "code": "theorem max_mul_of_nonneg (a b : \u03b1) (hc : 0 \u2264 c) : max a b * c = max (a * c) (b * c)", "start": [976, 1], "end": [977, 44], "kind": "commanddeclaration"}, {"full_name": "min_mul_of_nonneg", "code": "theorem min_mul_of_nonneg (a b : \u03b1) (hc : 0 \u2264 c) : min a b * c = min (a * c) (b * c)", "start": [980, 1], "end": [981, 44], "kind": "commanddeclaration"}, {"full_name": "le_of_mul_le_of_one_le", "code": "theorem le_of_mul_le_of_one_le {a b c : \u03b1} (h : a * c \u2264 b) (hb : 0 \u2264 b) (hc : 1 \u2264 c) : a \u2264 b", "start": [984, 1], "end": [985, 94], "kind": "commanddeclaration"}, {"full_name": "nonneg_le_nonneg_of_sq_le_sq", "code": "theorem nonneg_le_nonneg_of_sq_le_sq {a b : \u03b1} (hb : 0 \u2264 b) (h : a * a \u2264 b * b) : a \u2264 b", "start": [988, 1], "end": [989, 65], "kind": "commanddeclaration"}, {"full_name": "mul_self_le_mul_self_iff", "code": "theorem mul_self_le_mul_self_iff {a b : \u03b1} (h1 : 0 \u2264 a) (h2 : 0 \u2264 b) : a \u2264 b \u2194 a * a \u2264 b * b", "start": [992, 1], "end": [993, 61], "kind": "commanddeclaration"}, {"full_name": "mul_self_lt_mul_self_iff", "code": "theorem mul_self_lt_mul_self_iff {a b : \u03b1} (h1 : 0 \u2264 a) (h2 : 0 \u2264 b) : a < b \u2194 a * a < b * b", "start": [996, 1], "end": [997, 54], "kind": "commanddeclaration"}, {"full_name": "mul_self_inj", "code": "theorem mul_self_inj {a b : \u03b1} (h1 : 0 \u2264 a) (h2 : 0 \u2264 b) : a * a = b * b \u2194 a = b", "start": [1000, 1], "end": [1001, 47], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommSemiring.toLinearOrderedCancelAddCommMonoid", "code": "instance (priority := 100) LinearOrderedCommSemiring.toLinearOrderedCancelAddCommMonoid\n    [LinearOrderedCommSemiring \u03b1] : LinearOrderedCancelAddCommMonoid \u03b1 :=\n  { \u2039LinearOrderedCommSemiring \u03b1\u203a with }", "start": [1007, 1], "end": [1009, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.toLinearOrderedSemiring", "code": "instance (priority := 100) LinearOrderedRing.toLinearOrderedSemiring : LinearOrderedSemiring \u03b1 :=\n  { \u2039LinearOrderedRing \u03b1\u203a, StrictOrderedRing.toStrictOrderedSemiring with }", "start": [1019, 1], "end": [1020, 76], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.toLinearOrderedAddCommGroup", "code": "instance (priority := 100) LinearOrderedRing.toLinearOrderedAddCommGroup :\n    LinearOrderedAddCommGroup \u03b1 :=\n  { \u2039LinearOrderedRing \u03b1\u203a with }", "start": [1024, 1], "end": [1026, 33], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.noZeroDivisors", "code": "instance (priority := 100) LinearOrderedRing.noZeroDivisors : NoZeroDivisors \u03b1 :=\n  { \u2039LinearOrderedRing \u03b1\u203a with\n    eq_zero_or_eq_zero_of_mul_eq_zero := by\n      intro a b hab\n      refine' Decidable.or_iff_not_and_not.2 fun h => _; revert hab\n      cases' lt_or_gt_of_ne h.1 with ha ha <;> cases' lt_or_gt_of_ne h.2 with hb hb\n      exacts [(mul_pos_of_neg_of_neg ha hb).ne.symm, (mul_neg_of_neg_of_pos ha hb).ne,\n        (mul_neg_of_pos_of_neg ha hb).ne, (mul_pos ha hb).ne.symm] }", "start": [1030, 1], "end": [1037, 69], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedRing.isDomain", "code": "instance (priority := 100) LinearOrderedRing.isDomain : IsDomain \u03b1 :=\n  { (inferInstance : Nontrivial \u03b1) with\n    mul_left_cancel_of_ne_zero := fun {a b c} ha h => by\n      rw [\u2190 sub_eq_zero, \u2190 mul_sub] at h\n      exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha),\n    mul_right_cancel_of_ne_zero := fun {a b c} hb h => by\n      rw [\u2190 sub_eq_zero, \u2190 sub_mul] at h\n      exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb) }", "start": [1042, 1], "end": [1049, 85], "kind": "commanddeclaration"}, {"full_name": "mul_pos_iff", "code": "theorem mul_pos_iff : 0 < a * b \u2194 0 < a \u2227 0 < b \u2228 a < 0 \u2227 b < 0", "start": [1052, 1], "end": [1054, 66], "kind": "commanddeclaration"}, {"full_name": "mul_neg_iff", "code": "theorem mul_neg_iff : a * b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b", "start": [1057, 1], "end": [1058, 72], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg_iff", "code": "theorem mul_nonneg_iff : 0 \u2264 a * b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0", "start": [1061, 1], "end": [1063, 78], "kind": "commanddeclaration"}, {"full_name": "mul_nonneg_of_three", "code": "theorem mul_nonneg_of_three (a b c : \u03b1) : 0 \u2264 a * b \u2228 0 \u2264 b * c \u2228 0 \u2264 c * a", "start": [1066, 1], "end": [1089, 63], "kind": "commanddeclaration"}, {"full_name": "mul_nonpos_iff", "code": "theorem mul_nonpos_iff : a * b \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b", "start": [1092, 1], "end": [1093, 80], "kind": "commanddeclaration"}, {"full_name": "mul_self_nonneg", "code": "theorem mul_self_nonneg (a : \u03b1) : 0 \u2264 a * a", "start": [1096, 1], "end": [1097, 92], "kind": "commanddeclaration"}, {"full_name": "neg_le_self_iff", "code": "@[simp]\ntheorem neg_le_self_iff : -a \u2264 a \u2194 0 \u2264 a", "start": [1100, 1], "end": [1102, 96], "kind": "commanddeclaration"}, {"full_name": "neg_lt_self_iff", "code": "@[simp]\ntheorem neg_lt_self_iff : -a < a \u2194 0 < a", "start": [1105, 1], "end": [1107, 90], "kind": "commanddeclaration"}, {"full_name": "le_neg_self_iff", "code": "@[simp]\ntheorem le_neg_self_iff : a \u2264 -a \u2194 a \u2264 0", "start": [1110, 1], "end": [1115, 28], "kind": "commanddeclaration"}, {"full_name": "lt_neg_self_iff", "code": "@[simp]\ntheorem lt_neg_self_iff : a < -a \u2194 a < 0", "start": [1118, 1], "end": [1123, 25], "kind": "commanddeclaration"}, {"full_name": "neg_one_lt_zero", "code": "theorem neg_one_lt_zero : -1 < (0 : \u03b1)", "start": [1126, 1], "end": [1127, 28], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_left_of_neg", "code": "@[simp]\ntheorem mul_le_mul_left_of_neg {a b c : \u03b1} (h : c < 0) : c * a \u2264 c * b \u2194 b \u2264 a", "start": [1130, 1], "end": [1132, 36], "kind": "commanddeclaration"}, {"full_name": "mul_le_mul_right_of_neg", "code": "@[simp]\ntheorem mul_le_mul_right_of_neg {a b c : \u03b1} (h : c < 0) : a * c \u2264 b * c \u2194 b \u2264 a", "start": [1135, 1], "end": [1137, 37], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_left_of_neg", "code": "@[simp]\ntheorem mul_lt_mul_left_of_neg {a b c : \u03b1} (h : c < 0) : c * a < c * b \u2194 b < a", "start": [1140, 1], "end": [1142, 36], "kind": "commanddeclaration"}, {"full_name": "mul_lt_mul_right_of_neg", "code": "@[simp]\ntheorem mul_lt_mul_right_of_neg {a b c : \u03b1} (h : c < 0) : a * c < b * c \u2194 b < a", "start": [1145, 1], "end": [1147, 37], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_of_nonpos_left", "code": "theorem lt_of_mul_lt_mul_of_nonpos_left (h : c * a < c * b) (hc : c \u2264 0) : b < a", "start": [1150, 1], "end": [1151, 87], "kind": "commanddeclaration"}, {"full_name": "lt_of_mul_lt_mul_of_nonpos_right", "code": "theorem lt_of_mul_lt_mul_of_nonpos_right (h : a * c < b * c) (hc : c \u2264 0) : b < a", "start": [1154, 1], "end": [1155, 88], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_neg_left", "code": "theorem cmp_mul_neg_left {a : \u03b1} (ha : a < 0) (b c : \u03b1) : cmp (a * b) (a * c) = cmp c b", "start": [1158, 1], "end": [1159, 42], "kind": "commanddeclaration"}, {"full_name": "cmp_mul_neg_right", "code": "theorem cmp_mul_neg_right {a : \u03b1} (ha : a < 0) (b c : \u03b1) : cmp (b * a) (c * a) = cmp c b", "start": [1162, 1], "end": [1163, 43], "kind": "commanddeclaration"}, {"full_name": "sub_one_lt", "code": "theorem sub_one_lt (a : \u03b1) : a - 1 < a", "start": [1166, 1], "end": [1167, 37], "kind": "commanddeclaration"}, {"full_name": "mul_self_pos", "code": "@[simp]\ntheorem mul_self_pos {a : \u03b1} : 0 < a * a \u2194 a \u2260 0", "start": [1170, 1], "end": [1178, 52], "kind": "commanddeclaration"}, {"full_name": "mul_self_le_mul_self_of_le_of_neg_le", "code": "theorem mul_self_le_mul_self_of_le_of_neg_le {x y : \u03b1} (h\u2081 : x \u2264 y) (h\u2082 : -x \u2264 y) : x * x \u2264 y * y", "start": [1181, 1], "end": [1184, 74], "kind": "commanddeclaration"}, {"full_name": "nonneg_of_mul_nonpos_left", "code": "theorem nonneg_of_mul_nonpos_left {a b : \u03b1} (h : a * b \u2264 0) (hb : b < 0) : 0 \u2264 a", "start": [1187, 1], "end": [1188, 71], "kind": "commanddeclaration"}, {"full_name": "nonneg_of_mul_nonpos_right", "code": "theorem nonneg_of_mul_nonpos_right {a b : \u03b1} (h : a * b \u2264 0) (ha : a < 0) : 0 \u2264 b", "start": [1191, 1], "end": [1192, 71], "kind": "commanddeclaration"}, {"full_name": "pos_of_mul_neg_left", "code": "theorem pos_of_mul_neg_left {a b : \u03b1} (h : a * b < 0) (hb : b \u2264 0) : 0 < a", "start": [1195, 1], "end": [1196, 80], "kind": "commanddeclaration"}, {"full_name": "pos_of_mul_neg_right", "code": "theorem pos_of_mul_neg_right {a b : \u03b1} (h : a * b < 0) (ha : a \u2264 0) : 0 < b", "start": [1199, 1], "end": [1200, 80], "kind": "commanddeclaration"}, {"full_name": "neg_iff_pos_of_mul_neg", "code": "theorem neg_iff_pos_of_mul_neg (hab : a * b < 0) : a < 0 \u2194 0 < b", "start": [1203, 1], "end": [1204, 76], "kind": "commanddeclaration"}, {"full_name": "pos_iff_neg_of_mul_neg", "code": "theorem pos_iff_neg_of_mul_neg (hab : a * b < 0) : 0 < a \u2194 b < 0", "start": [1207, 1], "end": [1208, 76], "kind": "commanddeclaration"}, {"full_name": "mul_self_add_mul_self_eq_zero", "code": "theorem mul_self_add_mul_self_eq_zero {x y : \u03b1} : x * x + y * y = 0 \u2194 x = 0 \u2227 y = 0", "start": [1211, 1], "end": [1213, 86], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_mul_self_add_mul_self_eq_zero", "code": "theorem eq_zero_of_mul_self_add_mul_self_eq_zero (h : a * a + b * b = 0) : a = 0", "start": [1216, 1], "end": [1217, 44], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommRing.toStrictOrderedCommRing", "code": "instance (priority := 100) LinearOrderedCommRing.toStrictOrderedCommRing\n    [d : LinearOrderedCommRing \u03b1] : StrictOrderedCommRing \u03b1 :=\n  { d with }", "start": [1223, 1], "end": [1225, 13], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedCommRing.toLinearOrderedCommSemiring", "code": "instance (priority := 100) LinearOrderedCommRing.toLinearOrderedCommSemiring\n    [d : LinearOrderedCommRing \u03b1] : LinearOrderedCommSemiring \u03b1 :=\n  { d, LinearOrderedRing.toLinearOrderedSemiring with }", "start": [1229, 1], "end": [1231, 56], "kind": "commanddeclaration"}, {"full_name": "max_mul_mul_le_max_mul_max", "code": "theorem max_mul_mul_le_max_mul_max (b c : \u03b1) (ha : 0 \u2264 a) (hd : 0 \u2264 d) :\n    max (a * b) (d * c) \u2264 max a c * max d b", "start": [1238, 1], "end": [1244, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Defs.lean", "imports": ["Mathlib/Algebra/Group/Commute/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/TypeTags.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/Opposites.lean", "Mathlib/Logic/Embedding/Basic.lean"], "premises": [{"full_name": "FaithfulVAdd", "code": "class FaithfulVAdd (G : Type*) (P : Type*) [VAdd G P] : Prop where\n  \n  eq_of_vadd_eq_vadd : \u2200 {g\u2081 g\u2082 : G}, (\u2200 p : P, g\u2081 +\u1d65 p = g\u2082 +\u1d65 p) \u2192 g\u2081 = g\u2082", "start": [60, 1], "end": [63, 77], "kind": "commanddeclaration"}, {"full_name": "FaithfulSMul", "code": "@[to_additive]\nclass FaithfulSMul (M : Type*) (\u03b1 : Type*) [SMul M \u03b1] : Prop where\n  \n  eq_of_smul_eq_smul : \u2200 {m\u2081 m\u2082 : M}, (\u2200 a : \u03b1, m\u2081 \u2022 a = m\u2082 \u2022 a) \u2192 m\u2081 = m\u2082", "start": [66, 1], "end": [70, 75], "kind": "commanddeclaration"}, {"full_name": "smul_left_injective'", "code": "@[to_additive]\ntheorem smul_left_injective' [SMul M \u03b1] [FaithfulSMul M \u03b1] :\n    Function.Injective ((\u00b7 \u2022 \u00b7) : M \u2192 \u03b1 \u2192 \u03b1)", "start": [77, 1], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "Mul.toSMul", "code": "@[to_additive \"See also `AddMonoid.toAddAction`\"]\ninstance (priority := 910) Mul.toSMul (\u03b1 : Type*) [Mul \u03b1] : SMul \u03b1 \u03b1 :=\n  \u27e8(\u00b7 * \u00b7)\u27e9", "start": [85, 1], "end": [88, 12], "kind": "commanddeclaration"}, {"full_name": "smul_eq_mul", "code": "@[to_additive (attr := simp)]\ntheorem smul_eq_mul (\u03b1 : Type*) [Mul \u03b1] {a a' : \u03b1} : a \u2022 a' = a * a'", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "AddAction", "code": "class AddAction (G : Type*) (P : Type*) [AddMonoid G] extends VAdd G P where\n  \n  protected zero_vadd : \u2200 p : P, (0 : G) +\u1d65 p = p\n  \n  add_vadd : \u2200 (g\u2081 g\u2082 : G) (p : P), g\u2081 + g\u2082 +\u1d65 p = g\u2081 +\u1d65 (g\u2082 +\u1d65 p)", "start": [98, 1], "end": [103, 67], "kind": "commanddeclaration"}, {"full_name": "MulAction", "code": "@[to_additive (attr := ext)]\nclass MulAction (\u03b1 : Type*) (\u03b2 : Type*) [Monoid \u03b1] extends SMul \u03b1 \u03b2 where\n  \n  protected one_smul : \u2200 b : \u03b2, (1 : \u03b1) \u2022 b = b\n  \n  mul_smul : \u2200 (x y : \u03b1) (b : \u03b2), (x * y) \u2022 b = x \u2022 y \u2022 b", "start": [106, 1], "end": [112, 58], "kind": "commanddeclaration"}, {"full_name": "AddAction.IsPretransitive", "code": "class AddAction.IsPretransitive (M \u03b1 : Type*) [VAdd M \u03b1] : Prop where\n  \n  exists_vadd_eq : \u2200 x y : \u03b1, \u2203 g : M, g +\u1d65 x = y", "start": [132, 1], "end": [136, 50], "kind": "commanddeclaration"}, {"full_name": "MulAction.IsPretransitive", "code": "@[to_additive]\nclass MulAction.IsPretransitive (M \u03b1 : Type*) [SMul M \u03b1] : Prop where\n  \n  exists_smul_eq : \u2200 x y : \u03b1, \u2203 g : M, g \u2022 x = y", "start": [139, 1], "end": [144, 49], "kind": "commanddeclaration"}, {"full_name": "MulAction.exists_smul_eq", "code": "@[to_additive]\ntheorem exists_smul_eq (x y : \u03b1) : \u2203 m : M, m \u2022 x = y", "start": [151, 1], "end": [153, 37], "kind": "commanddeclaration"}, {"full_name": "MulAction.surjective_smul", "code": "@[to_additive]\ntheorem surjective_smul (x : \u03b1) : Surjective fun c : M => c \u2022 x", "start": [157, 1], "end": [159, 21], "kind": "commanddeclaration"}, {"full_name": "MulAction.Regular.isPretransitive", "code": "@[to_additive \"The regular action of a group on itself is transitive.\"]\ninstance Regular.isPretransitive [Group G] : IsPretransitive G G :=\n  \u27e8fun x y => \u27e8y * x\u207b\u00b9, inv_mul_cancel_right _ _\u27e9\u27e9", "start": [163, 1], "end": [166, 51], "kind": "commanddeclaration"}, {"full_name": "VAddCommClass", "code": "class VAddCommClass (M N \u03b1 : Type*) [VAdd M \u03b1] [VAdd N \u03b1] : Prop where\n  \n  vadd_comm : \u2200 (m : M) (n : N) (a : \u03b1), m +\u1d65 (n +\u1d65 a) = n +\u1d65 (m +\u1d65 a)", "start": [177, 1], "end": [180, 71], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass", "code": "@[to_additive]\nclass SMulCommClass (M N \u03b1 : Type*) [SMul M \u03b1] [SMul N \u03b1] : Prop where\n  \n  smul_comm : \u2200 (m : M) (n : N) (a : \u03b1), m \u2022 n \u2022 a = n \u2022 m \u2022 a", "start": [183, 1], "end": [187, 63], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.symm", "code": "@[to_additive]\ntheorem SMulCommClass.symm (M N \u03b1 : Type*) [SMul M \u03b1] [SMul N \u03b1] [SMulCommClass M N \u03b1] :\n    SMulCommClass N M \u03b1", "start": [216, 1], "end": [221, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.smulCommClass", "code": "theorem Function.Injective.smulCommClass [SMul M \u03b1] [SMul N \u03b1] [SMul M \u03b2] [SMul N \u03b2]\n    [SMulCommClass M N \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)\n    (h\u2081 : \u2200 (c : M) x, f (c \u2022 x) = c \u2022 f x) (h\u2082 : \u2200 (c : N) x, f (c \u2022 x) = c \u2022 f x) :\n    SMulCommClass M N \u03b1 where", "start": [229, 1], "end": [233, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.smulCommClass", "code": "theorem Function.Surjective.smulCommClass [SMul M \u03b1] [SMul N \u03b1] [SMul M \u03b2] [SMul N \u03b2]\n    [SMulCommClass M N \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f)\n    (h\u2081 : \u2200 (c : M) x, f (c \u2022 x) = c \u2022 f x) (h\u2082 : \u2200 (c : N) x, f (c \u2022 x) = c \u2022 f x) :\n    SMulCommClass M N \u03b2 where", "start": [235, 1], "end": [239, 86], "kind": "commanddeclaration"}, {"full_name": "smulCommClass_self", "code": "@[to_additive]\ninstance smulCommClass_self (M \u03b1 : Type*) [CommMonoid M] [MulAction M \u03b1] : SMulCommClass M M \u03b1 :=\n  \u27e8fun a a' b => by rw [\u2190 mul_smul, mul_comm, mul_smul]\u27e9", "start": [241, 1], "end": [243, 57], "kind": "commanddeclaration"}, {"full_name": "VAddAssocClass", "code": "class VAddAssocClass (M N \u03b1 : Type*) [VAdd M N] [VAdd N \u03b1] [VAdd M \u03b1] : Prop where\n  \n  vadd_assoc : \u2200 (x : M) (y : N) (z : \u03b1), x +\u1d65 y +\u1d65 z = x +\u1d65 (y +\u1d65 z)", "start": [247, 1], "end": [251, 70], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower", "code": "@[to_additive VAddAssocClass] class IsScalarTower (M N \u03b1 : Type*) [SMul M N] [SMul N \u03b1] [SMul M \u03b1] : Prop where\n  \n  smul_assoc : \u2200 (x : M) (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z", "start": [254, 1], "end": [260, 66], "kind": "commanddeclaration"}, {"full_name": "smul_assoc", "code": "@[to_additive (attr := simp)]\ntheorem smul_assoc {M N} [SMul M N] [SMul N \u03b1] [SMul M \u03b1] [IsScalarTower M N \u03b1] (x : M)\n    (y : N) (z : \u03b1) : (x \u2022 y) \u2022 z = x \u2022 y \u2022 z", "start": [263, 1], "end": [266, 33], "kind": "commanddeclaration"}, {"full_name": "Semigroup.isScalarTower", "code": "@[to_additive]\ninstance Semigroup.isScalarTower [Semigroup \u03b1] : IsScalarTower \u03b1 \u03b1 \u03b1 :=\n  \u27e8mul_assoc\u27e9", "start": [270, 1], "end": [272, 14], "kind": "commanddeclaration"}, {"full_name": "IsCentralVAdd", "code": "class IsCentralVAdd (M \u03b1 : Type*) [VAdd M \u03b1] [VAdd M\u1d43\u1d52\u1d56 \u03b1] : Prop where\n  \n  op_vadd_eq_vadd : \u2200 (m : M) (a : \u03b1), AddOpposite.op m +\u1d65 a = m +\u1d65 a", "start": [276, 1], "end": [281, 70], "kind": "commanddeclaration"}, {"full_name": "IsCentralScalar", "code": "@[to_additive]\nclass IsCentralScalar (M \u03b1 : Type*) [SMul M \u03b1] [SMul M\u1d50\u1d52\u1d56 \u03b1] : Prop where\n  \n  op_smul_eq_smul : \u2200 (m : M) (a : \u03b1), MulOpposite.op m \u2022 a = m \u2022 a", "start": [284, 1], "end": [290, 68], "kind": "commanddeclaration"}, {"full_name": "IsCentralScalar.unop_smul_eq_smul", "code": "@[to_additive]\ntheorem IsCentralScalar.unop_smul_eq_smul {M \u03b1 : Type*} [SMul M \u03b1] [SMul M\u1d50\u1d52\u1d56 \u03b1]\n    [IsCentralScalar M \u03b1] (m : M\u1d50\u1d52\u1d56) (a : \u03b1) : MulOpposite.unop m \u2022 a = m \u2022 a", "start": [295, 1], "end": [299, 51], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.op_left", "code": "@[to_additive]\ninstance (priority := 50) SMulCommClass.op_left [SMul M \u03b1] [SMul M\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar M \u03b1]\n    [SMul N \u03b1] [SMulCommClass M N \u03b1] : SMulCommClass M\u1d50\u1d52\u1d56 N \u03b1 :=\n  \u27e8fun m n a => by rw [\u2190 unop_smul_eq_smul m (n \u2022 a), \u2190 unop_smul_eq_smul m a, smul_comm]\u27e9", "start": [308, 1], "end": [311, 91], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.op_right", "code": "@[to_additive]\ninstance (priority := 50) SMulCommClass.op_right [SMul M \u03b1] [SMul N \u03b1] [SMul N\u1d50\u1d52\u1d56 \u03b1]\n    [IsCentralScalar N \u03b1] [SMulCommClass M N \u03b1] : SMulCommClass M N\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8fun m n a => by rw [\u2190 unop_smul_eq_smul n (m \u2022 a), \u2190 unop_smul_eq_smul n a, smul_comm]\u27e9", "start": [315, 1], "end": [318, 91], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.op_left", "code": "@[to_additive]\ninstance (priority := 50) IsScalarTower.op_left [SMul M \u03b1] [SMul M\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar M \u03b1]\n    [SMul M N] [SMul M\u1d50\u1d52\u1d56 N] [IsCentralScalar M N] [SMul N \u03b1] [IsScalarTower M N \u03b1] :\n    IsScalarTower M\u1d50\u1d52\u1d56 N \u03b1 :=\n  \u27e8fun m n a => by rw [\u2190 unop_smul_eq_smul m (n \u2022 a), \u2190 unop_smul_eq_smul m n, smul_assoc]\u27e9", "start": [322, 1], "end": [326, 92], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.op_right", "code": "@[to_additive]\ninstance (priority := 50) IsScalarTower.op_right [SMul M \u03b1] [SMul M N] [SMul N \u03b1]\n    [SMul N\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar N \u03b1] [IsScalarTower M N \u03b1] : IsScalarTower M N\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8fun m n a => by\n    rw [\u2190 unop_smul_eq_smul n a, \u2190 unop_smul_eq_smul (m \u2022 n) a, MulOpposite.unop_smul, smul_assoc]\u27e9", "start": [330, 1], "end": [334, 100], "kind": "commanddeclaration"}, {"full_name": "SMul.comp.smul", "code": "@[to_additive (attr := simp) \" Auxiliary definition for `VAdd.comp`, `AddAction.compHom`, etc. \"]\ndef comp.smul (g : N \u2192 M) (n : N) (a : \u03b1) : \u03b1 :=\n  g n \u2022 a", "start": [342, 1], "end": [346, 10], "kind": "commanddeclaration"}, {"full_name": "SMul.comp", "code": "@[to_additive (attr := reducible)\n      \"An additive action of `M` on `\u03b1` and a function `N \u2192 M` induces\n       an additive action of `N` on `\u03b1` \"]\ndef comp (g : N \u2192 M) : SMul N \u03b1 where smul := SMul.comp.smul g", "start": [352, 1], "end": [359, 63], "kind": "commanddeclaration"}, {"full_name": "SMul.comp.isScalarTower", "code": "@[to_additive\n      \"Given a tower of additive actions `M \u2192 \u03b1 \u2192 \u03b2`, if we use `SMul.comp` to pull back both of\n       `M`'s actions by a map `g : N \u2192 M`, then we obtain a new tower of scalar actions `N \u2192 \u03b1 \u2192 \u03b2`.\n\n       This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\n       are still metavariables.\"]\ntheorem comp.isScalarTower [SMul M \u03b2] [SMul \u03b1 \u03b2] [IsScalarTower M \u03b1 \u03b2] (g : N \u2192 M) : by\n    haveI := comp \u03b1 g; haveI := comp \u03b2 g; exact IsScalarTower N \u03b1 \u03b2", "start": [365, 1], "end": [381, 46], "kind": "commanddeclaration"}, {"full_name": "SMul.comp.smulCommClass", "code": "@[to_additive\n      \"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\n       are still metavariables.\"]\ntheorem comp.smulCommClass [SMul \u03b2 \u03b1] [SMulCommClass M \u03b2 \u03b1] (g : N \u2192 M) :\n    haveI := comp \u03b1 g\n    SMulCommClass N \u03b2 \u03b1", "start": [385, 1], "end": [395, 44], "kind": "commanddeclaration"}, {"full_name": "SMul.comp.smulCommClass'", "code": "@[to_additive\n      \"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\n       are still metavariables.\"]\ntheorem comp.smulCommClass' [SMul \u03b2 \u03b1] [SMulCommClass \u03b2 M \u03b1] (g : N \u2192 M) :\n    haveI := comp \u03b1 g\n    SMulCommClass \u03b2 N \u03b1", "start": [399, 1], "end": [409, 48], "kind": "commanddeclaration"}, {"full_name": "mul_smul_comm", "code": "@[to_additive] theorem mul_smul_comm [Mul \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] (s : \u03b1) (x y : \u03b2) :\n    x * s \u2022 y = s \u2022 (x * y)", "start": [417, 1], "end": [422, 25], "kind": "commanddeclaration"}, {"full_name": "smul_mul_assoc", "code": "@[to_additive] theorem smul_mul_assoc [Mul \u03b2] [SMul \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (r : \u03b1) (x y : \u03b2) :\n    r \u2022 x * y = r \u2022 (x * y)", "start": [426, 1], "end": [431, 19], "kind": "commanddeclaration"}, {"full_name": "smul_smul_smul_comm", "code": "@[to_additive]\ntheorem smul_smul_smul_comm [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b4] [SMul \u03b1 \u03b4] [SMul \u03b3 \u03b4]\n    [IsScalarTower \u03b1 \u03b2 \u03b4] [IsScalarTower \u03b1 \u03b3 \u03b4] [SMulCommClass \u03b2 \u03b3 \u03b4] (a : \u03b1) (b : \u03b2) (c : \u03b3)\n    (d : \u03b4) : (a \u2022 b) \u2022 c \u2022 d = (a \u2022 c) \u2022 b \u2022 d", "start": [435, 1], "end": [439, 43], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_right", "code": "@[to_additive]\ntheorem Commute.smul_right [Mul \u03b1] [SMulCommClass M \u03b1 \u03b1] [IsScalarTower M \u03b1 \u03b1] {a b : \u03b1}\n    (h : Commute a b) (r : M) : Commute a (r \u2022 b)", "start": [445, 1], "end": [448, 85], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_left", "code": "@[to_additive]\ntheorem Commute.smul_left [Mul \u03b1] [SMulCommClass M \u03b1 \u03b1] [IsScalarTower M \u03b1 \u03b1] {a b : \u03b1}\n    (h : Commute a b) (r : M) : Commute (r \u2022 a) b", "start": [452, 1], "end": [455, 29], "kind": "commanddeclaration"}, {"full_name": "ite_smul", "code": "@[to_additive]\ntheorem ite_smul (a\u2081 a\u2082 : M) (b : \u03b1) : ite p a\u2081 a\u2082 \u2022 b = ite p (a\u2081 \u2022 b) (a\u2082 \u2022 b)", "start": [465, 1], "end": [467, 20], "kind": "commanddeclaration"}, {"full_name": "smul_ite", "code": "@[to_additive]\ntheorem smul_ite (a : M) (b\u2081 b\u2082 : \u03b1) : a \u2022 ite p b\u2081 b\u2082 = ite p (a \u2022 b\u2081) (a \u2022 b\u2082)", "start": [471, 1], "end": [473, 20], "kind": "commanddeclaration"}, {"full_name": "smul_smul", "code": "@[to_additive]\ntheorem smul_smul (a\u2081 a\u2082 : M) (b : \u03b1) : a\u2081 \u2022 a\u2082 \u2022 b = (a\u2081 * a\u2082) \u2022 b", "start": [483, 1], "end": [485, 24], "kind": "commanddeclaration"}, {"full_name": "one_smul", "code": "@[to_additive (attr := simp)]\ntheorem one_smul (b : \u03b1) : (1 : M) \u2022 b = b", "start": [491, 1], "end": [493, 23], "kind": "commanddeclaration"}, {"full_name": "one_smul_eq_id", "code": "@[to_additive \"`VAdd` version of `zero_add_eq_id`\"]\ntheorem one_smul_eq_id : ((\u00b7 \u2022 \u00b7) (1 : M) : \u03b1 \u2192 \u03b1) = id", "start": [497, 1], "end": [500, 23], "kind": "commanddeclaration"}, {"full_name": "comp_smul_left", "code": "@[to_additive \"`VAdd` version of `comp_add_left`\"]\ntheorem comp_smul_left (a\u2081 a\u2082 : M) : (\u00b7 \u2022 \u00b7) a\u2081 \u2218 (\u00b7 \u2022 \u00b7) a\u2082 = ((\u00b7 \u2022 \u00b7) (a\u2081 * a\u2082) : \u03b1 \u2192 \u03b1)", "start": [504, 1], "end": [507, 40], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mulAction", "code": "@[to_additive (attr := reducible)\n    \"Pullback an additive action along an injective map respecting `+\u1d65`.\"]\nprotected def Function.Injective.mulAction [SMul M \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) :\n    MulAction M \u03b2 where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul x := hf <| (smul _ _).trans <| one_smul _ (f x)\n  mul_smul c\u2081 c\u2082 x := hf <| by simp only [smul, mul_smul]", "start": [513, 1], "end": [522, 58], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulAction", "code": "@[to_additive (attr := reducible)\n    \"Pushforward an additive action along a surjective map respecting `+\u1d65`.\"]\nprotected def Function.Surjective.mulAction [SMul M \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f)\n    (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) :\n    MulAction M \u03b2 where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul y := by\n    rcases hf y with \u27e8x, rfl\u27e9\n    rw [\u2190 smul, one_smul]\n  mul_smul c\u2081 c\u2082 y := by\n    rcases hf y with \u27e8x, rfl\u27e9\n    simp only [\u2190 smul, mul_smul]", "start": [526, 1], "end": [539, 33], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulActionLeft", "code": "@[to_additive (attr := reducible)\n    \"Push forward the action of `R` on `M` along a compatible surjective map `f : R \u2192+ S`.\"]\ndef Function.Surjective.mulActionLeft {R S M : Type*} [Monoid R] [MulAction R M] [Monoid S]\n    [SMul S M] (f : R \u2192* S) (hf : Function.Surjective f)\n    (hsmul : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x) :\n    MulAction S M where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul b := by rw [\u2190 f.map_one, hsmul, one_smul]\n  mul_smul := hf.forall\u2082.mpr fun a b x => by simp only [\u2190 f.map_mul, hsmul, mul_smul]", "start": [543, 1], "end": [555, 86], "kind": "commanddeclaration"}, {"full_name": "Monoid.toMulAction", "code": "@[to_additive]\ninstance (priority := 910) Monoid.toMulAction :\n    MulAction M M where\n  smul := (\u00b7 * \u00b7)\n  one_smul := one_mul\n  mul_smul := mul_assoc", "start": [564, 1], "end": [572, 24], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.left", "code": "@[to_additive]\ninstance IsScalarTower.left : IsScalarTower M M \u03b1 :=\n  \u27e8fun x y z => mul_smul x y z\u27e9", "start": [581, 1], "end": [583, 32], "kind": "commanddeclaration"}, {"full_name": "smul_mul_smul", "code": "@[to_additive] theorem smul_mul_smul [Mul \u03b1] (r s : M) (x y : \u03b1) [IsScalarTower M \u03b1 \u03b1] [SMulCommClass M \u03b1 \u03b1] :\n    r \u2022 x * s \u2022 y = (r * s) \u2022 (x * y)", "start": [589, 1], "end": [594, 64], "kind": "commanddeclaration"}, {"full_name": "MulAction.toFun", "code": "@[to_additive]\ndef toFun : \u03b1 \u21aa M \u2192 \u03b1 :=\n  \u27e8fun y x => x \u2022 y, fun y\u2081 y\u2082 H => one_smul M y\u2081 \u25b8 one_smul M y\u2082 \u25b8 by convert congr_fun H 1\u27e9", "start": [604, 1], "end": [607, 94], "kind": "commanddeclaration"}, {"full_name": "MulAction.toFun_apply", "code": "@[to_additive (attr := simp)]\ntheorem toFun_apply (x : M) (y : \u03b1) : MulAction.toFun M \u03b1 y x = x \u2022 y", "start": [616, 1], "end": [618, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.compHom", "code": "@[to_additive (attr := reducible)]\ndef compHom [Monoid N] (g : N \u2192* M) :\n    MulAction N \u03b1 where\n  smul := SMul.comp.smul g\n  one_smul _ := by simp [(\u00b7 \u2022 \u00b7)]; apply MulAction.one_smul\n  mul_smul _ _ _ := by simp [(\u00b7 \u2022 \u00b7)]; apply MulAction.mul_smul", "start": [624, 1], "end": [635, 64], "kind": "commanddeclaration"}, {"full_name": "MulAction.compHom_smul_def", "code": "@[to_additive]\ntheorem compHom_smul_def\n    {E F G : Type*} [Monoid E] [Monoid F] [MulAction F G] (f : E \u2192* F) (a : E) (x : G) :\n    letI : MulAction E G := MulAction.compHom _ f\n    a \u2022 x = (f a) \u2022 x", "start": [645, 1], "end": [649, 29], "kind": "commanddeclaration"}, {"full_name": "MulAction.isPretransitive_compHom", "code": "@[to_additive]\ntheorem isPretransitive_compHom\n    {E F G : Type*} [Monoid E] [Monoid F] [MulAction F G] [IsPretransitive F G]\n    {f : E \u2192* F} (hf : Surjective f) :\n    letI : MulAction E G := MulAction.compHom _ f\n    IsPretransitive E G", "start": [651, 1], "end": [663, 17], "kind": "commanddeclaration"}, {"full_name": "smul_one_smul", "code": "@[to_additive]\ntheorem smul_one_smul {M} (N) [Monoid N] [SMul M N] [MulAction N \u03b1] [SMul M \u03b1]\n    [IsScalarTower M N \u03b1] (x : M) (y : \u03b1) : (x \u2022 (1 : N)) \u2022 y = x \u2022 y", "start": [671, 1], "end": [674, 28], "kind": "commanddeclaration"}, {"full_name": "smul_one_mul", "code": "@[to_additive (attr := simp)]\ntheorem smul_one_mul {M N} [MulOneClass N] [SMul M N] [IsScalarTower M N N] (x : M) (y : N) :\n    x \u2022 (1 : N) * y = x \u2022 y", "start": [678, 1], "end": [680, 63], "kind": "commanddeclaration"}, {"full_name": "mul_smul_one", "code": "@[to_additive (attr := simp)]\ntheorem mul_smul_one {M N} [MulOneClass N] [SMul M N] [SMulCommClass M N N] (x : M) (y : N) :\n    y * x \u2022 (1 : N) = x \u2022 y", "start": [684, 1], "end": [686, 88], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.of_smul_one_mul", "code": "@[to_additive]\ntheorem IsScalarTower.of_smul_one_mul {M N} [Monoid N] [SMul M N]\n    (h : \u2200 (x : M) (y : N), x \u2022 (1 : N) * y = x \u2022 y) : IsScalarTower M N N", "start": [690, 1], "end": [693, 69], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.of_mul_smul_one", "code": "@[to_additive]\ntheorem SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n    (H : \u2200 (x : M) (y : N), y * x \u2022 (1 : N) = x \u2022 y) : SMulCommClass M N N", "start": [697, 1], "end": [700, 75], "kind": "commanddeclaration"}, {"full_name": "smulOneHom", "code": "@[to_additive (attr := simps)\n    \"If the additive action of `M` on `N` is compatible with addition on `N`, then\n    `fun x => x +\u1d65 0` is an additive monoid homomorphism from `M` to `N`.\"]\ndef smulOneHom {M N} [Monoid M] [Monoid N] [MulAction M N] [IsScalarTower M N N] :\n    M \u2192* N where\n  toFun x := x \u2022 (1 : N)\n  map_one' := one_smul _ _\n  map_mul' x y := by rw [smul_one_mul, smul_smul]", "start": [704, 1], "end": [713, 50], "kind": "commanddeclaration"}, {"full_name": "SMulZeroClass", "code": "class SMulZeroClass (M A : Type*) [Zero A] extends SMul M A where\n  \n  smul_zero : \u2200 a : M, a \u2022 (0 : A) = 0", "start": [721, 1], "end": [724, 39], "kind": "commanddeclaration"}, {"full_name": "smul_zero", "code": "@[simp]\ntheorem smul_zero (a : M) : a \u2022 (0 : A) = 0", "start": [731, 1], "end": [733, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.smulZeroClass", "code": "@[reducible]\nprotected def Function.Injective.smulZeroClass [Zero B] [SMul M B] (f : ZeroHom B A)\n    (hf : Injective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) :\n    SMulZeroClass M B where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_zero c := hf <| by simp only [smul, map_zero, smul_zero]", "start": [736, 1], "end": [743, 64], "kind": "commanddeclaration"}, {"full_name": "ZeroHom.smulZeroClass", "code": "@[reducible]\nprotected def ZeroHom.smulZeroClass [Zero B] [SMul M B] (f : ZeroHom A B)\n    (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) :\n    SMulZeroClass M B where\n  smul_zero c := by rw [\u2190 map_zero f, \u2190 smul, smul_zero]", "start": [746, 1], "end": [753, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.smulZeroClassLeft", "code": "@[reducible]\ndef Function.Surjective.smulZeroClassLeft {R S M : Type*} [Zero M] [SMulZeroClass R M]\n    [SMul S M] (f : R \u2192 S) (hf : Function.Surjective f)\n    (hsmul : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x) :\n    SMulZeroClass S M where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_zero := hf.forall.mpr fun c => by rw [hsmul, smul_zero]", "start": [756, 1], "end": [766, 63], "kind": "commanddeclaration"}, {"full_name": "SMulZeroClass.compFun", "code": "@[reducible]\ndef SMulZeroClass.compFun (f : N \u2192 M) :\n    SMulZeroClass N A where\n  smul := SMul.comp.smul f\n  smul_zero x := smul_zero (f x)", "start": [771, 1], "end": [777, 33], "kind": "commanddeclaration"}, {"full_name": "SMulZeroClass.toZeroHom", "code": "@[simps]\ndef SMulZeroClass.toZeroHom (x : M) :\n    ZeroHom A A where\n  toFun := (\u00b7 \u2022 \u00b7) x\n  map_zero' := smul_zero x", "start": [780, 1], "end": [785, 27], "kind": "commanddeclaration"}, {"full_name": "DistribSMul", "code": "@[ext]\nclass DistribSMul (M A : Type*) [AddZeroClass A] extends SMulZeroClass M A where\n  \n  smul_add : \u2200 (a : M) (x y : A), a \u2022 (x + y) = a \u2022 x + a \u2022 y", "start": [791, 1], "end": [798, 62], "kind": "commanddeclaration"}, {"full_name": "smul_add", "code": "theorem smul_add (a : M) (b\u2081 b\u2082 : A) : a \u2022 (b\u2081 + b\u2082) = a \u2022 b\u2081 + a \u2022 b\u2082", "start": [807, 1], "end": [808, 29], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.smulZeroClass", "code": "instance AddMonoidHom.smulZeroClass [AddZeroClass B] : SMulZeroClass M (B \u2192+ A) where\n  smul r f :=\n    { toFun := (fun a => r \u2022 (f a))\n      map_zero' := by simp only [map_zero, smul_zero]\n      map_add' := fun x y => by simp only [map_add, smul_add] }\n  smul_zero r := ext fun _ => smul_zero _", "start": [811, 1], "end": [816, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.distribSMul", "code": "@[reducible]\nprotected def Function.Injective.distribSMul [AddZeroClass B] [SMul M B] (f : B \u2192+ A)\n    (hf : Injective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : DistribSMul M B :=\n  { hf.smulZeroClass f.toZeroHom smul with\n    smul_add := fun c x y => hf <| by simp only [smul, map_add, smul_add] }", "start": [818, 1], "end": [825, 76], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.distribSMul", "code": "@[reducible]\nprotected def Function.Surjective.distribSMul [AddZeroClass B] [SMul M B] (f : A \u2192+ B)\n    (hf : Surjective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : DistribSMul M B :=\n  { f.toZeroHom.smulZeroClass smul with\n    smul_add := fun c x y => by\n      rcases hf x with \u27e8x, rfl\u27e9\n      rcases hf y with \u27e8y, rfl\u27e9\n      simp only [smul_add, \u2190 smul, \u2190 map_add] }", "start": [828, 1], "end": [838, 48], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.distribSMulLeft", "code": "@[reducible]\ndef Function.Surjective.distribSMulLeft {R S M : Type*} [AddZeroClass M] [DistribSMul R M]\n    [SMul S M] (f : R \u2192 S) (hf : Function.Surjective f)\n    (hsmul : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x) : DistribSMul S M :=\n  { hf.smulZeroClassLeft f hsmul with\n    smul_add := hf.forall.mpr fun c x y => by simp only [hsmul, smul_add] }", "start": [841, 1], "end": [850, 76], "kind": "commanddeclaration"}, {"full_name": "DistribSMul.compFun", "code": "@[reducible]\ndef DistribSMul.compFun (f : N \u2192 M) : DistribSMul N A :=\n  { SMulZeroClass.compFun A f with\n    smul_add := fun x => smul_add (f x) }", "start": [855, 1], "end": [860, 42], "kind": "commanddeclaration"}, {"full_name": "DistribSMul.toAddMonoidHom", "code": "@[simps]\ndef DistribSMul.toAddMonoidHom (x : M) : A \u2192+ A :=\n  { SMulZeroClass.toZeroHom A x with toFun := (\u00b7 \u2022 \u00b7) x, map_add' := smul_add x }", "start": [863, 1], "end": [866, 82], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction", "code": "@[ext]\nclass DistribMulAction (M A : Type*) [Monoid M] [AddMonoid A] extends MulAction M A where\n  \n  smul_zero : \u2200 a : M, a \u2022 (0 : A) = 0\n  \n  smul_add : \u2200 (a : M) (x y : A), a \u2022 (x + y) = a \u2022 x + a \u2022 y", "start": [872, 1], "end": [878, 62], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toDistribSMul", "code": "instance (priority := 100) DistribMulAction.toDistribSMul : DistribSMul M A :=\n  { \u2039DistribMulAction M A\u203a with }", "start": [888, 1], "end": [889, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.distribMulAction", "code": "@[reducible]\nprotected def Function.Injective.distribMulAction [AddMonoid B] [SMul M B] (f : B \u2192+ A)\n    (hf : Injective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : DistribMulAction M B :=\n  { hf.distribSMul f smul, hf.mulAction f smul with }", "start": [901, 1], "end": [907, 54], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.distribMulAction", "code": "@[reducible]\nprotected def Function.Surjective.distribMulAction [AddMonoid B] [SMul M B] (f : A \u2192+ B)\n    (hf : Surjective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : DistribMulAction M B :=\n  { hf.distribSMul f smul, hf.mulAction f smul with }", "start": [910, 1], "end": [916, 54], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.distribMulActionLeft", "code": "@[reducible]\ndef Function.Surjective.distribMulActionLeft {R S M : Type*} [Monoid R] [AddMonoid M]\n    [DistribMulAction R M] [Monoid S] [SMul S M] (f : R \u2192* S) (hf : Function.Surjective f)\n    (hsmul : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x) : DistribMulAction S M :=\n  { hf.distribSMulLeft f hsmul, hf.mulActionLeft f hsmul with }", "start": [919, 1], "end": [927, 64], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.compHom", "code": "@[reducible]\ndef DistribMulAction.compHom [Monoid N] (f : N \u2192* M) : DistribMulAction N A :=\n  { DistribSMul.compFun A f, MulAction.compHom A f with }", "start": [932, 1], "end": [936, 58], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toAddMonoidHom", "code": "@[simps!]\ndef DistribMulAction.toAddMonoidHom (x : M) : A \u2192+ A :=\n  DistribSMul.toAddMonoidHom A x", "start": [939, 1], "end": [942, 33], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toAddMonoidEnd", "code": "@[simps]\ndef DistribMulAction.toAddMonoidEnd :\n    M \u2192* AddMonoid.End A where\n  toFun := DistribMulAction.toAddMonoidHom A\n  map_one' := AddMonoidHom.ext <| one_smul M\n  map_mul' x y := AddMonoidHom.ext <| mul_smul x y", "start": [948, 1], "end": [954, 51], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.nat_smulCommClass", "code": "instance AddMonoid.nat_smulCommClass :\n    SMulCommClass \u2115 M\n      A where smul_comm n x y := ((DistribMulAction.toAddMonoidHom A x).map_nsmul y n).symm", "start": [958, 1], "end": [960, 92], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.nat_smulCommClass'", "code": "instance AddMonoid.nat_smulCommClass' : SMulCommClass M \u2115 A :=\n  SMulCommClass.symm _ _ _", "start": [964, 1], "end": [965, 27], "kind": "commanddeclaration"}, {"full_name": "AddGroup.int_smulCommClass", "code": "instance AddGroup.int_smulCommClass : SMulCommClass \u2124 M A where\n  smul_comm n x y := ((DistribMulAction.toAddMonoidHom A x).map_zsmul y n).symm", "start": [974, 1], "end": [975, 80], "kind": "commanddeclaration"}, {"full_name": "AddGroup.int_smulCommClass'", "code": "instance AddGroup.int_smulCommClass' : SMulCommClass M \u2124 A :=\n  SMulCommClass.symm _ _ _", "start": [979, 1], "end": [980, 27], "kind": "commanddeclaration"}, {"full_name": "smul_neg", "code": "@[simp]\ntheorem smul_neg (r : M) (x : A) : r \u2022 -x = -(r \u2022 x)", "start": [983, 1], "end": [985, 76], "kind": "commanddeclaration"}, {"full_name": "smul_sub", "code": "theorem smul_sub (r : M) (x y : A) : r \u2022 (x - y) = r \u2022 x - r \u2022 y", "start": [988, 1], "end": [989, 58], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction", "code": "@[ext]\nclass MulDistribMulAction (M : Type*) (A : Type*) [Monoid M] [Monoid A] extends\n  MulAction M A where\n  \n  smul_mul : \u2200 (r : M) (x y : A), r \u2022 (x * y) = r \u2022 x * r \u2022 y\n  \n  smul_one : \u2200 r : M, r \u2022 (1 : A) = 1", "start": [994, 1], "end": [1002, 38], "kind": "commanddeclaration"}, {"full_name": "smul_mul'", "code": "theorem smul_mul' (a : M) (b\u2081 b\u2082 : A) : a \u2022 (b\u2081 * b\u2082) = a \u2022 b\u2081 * a \u2022 b\u2082", "start": [1013, 1], "end": [1014, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mulDistribMulAction", "code": "@[reducible]\nprotected def Function.Injective.mulDistribMulAction [Monoid B] [SMul M B] (f : B \u2192* A)\n    (hf : Injective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : MulDistribMulAction M B :=\n  { hf.mulAction f smul with\n    smul_mul := fun c x y => hf <| by simp only [smul, f.map_mul, smul_mul'],\n    smul_one := fun c => hf <| by simp only [smul, f.map_one, smul_one] }", "start": [1017, 1], "end": [1025, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulDistribMulAction", "code": "@[reducible]\nprotected def Function.Surjective.mulDistribMulAction [Monoid B] [SMul M B] (f : A \u2192* B)\n    (hf : Surjective f) (smul : \u2200 (c : M) (x), f (c \u2022 x) = c \u2022 f x) : MulDistribMulAction M B :=\n  { hf.mulAction f smul with\n    smul_mul := fun c x y => by\n      rcases hf x with \u27e8x, rfl\u27e9\n      rcases hf y with \u27e8y, rfl\u27e9\n      simp only [smul_mul', \u2190 smul, \u2190 f.map_mul],\n    smul_one := fun c => by rw [\u2190 f.map_one, \u2190 smul, smul_one] }", "start": [1028, 1], "end": [1039, 65], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.compHom", "code": "@[reducible]\ndef MulDistribMulAction.compHom [Monoid N] (f : N \u2192* M) : MulDistribMulAction N A :=\n  { MulAction.compHom A f with\n    smul_one := fun x => smul_one (f x),\n    smul_mul := fun x => smul_mul' (f x) }", "start": [1044, 1], "end": [1050, 43], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.toMonoidHom", "code": "def MulDistribMulAction.toMonoidHom (r : M) :\n    A \u2192* A where\n  toFun := (\u00b7 \u2022 \u00b7) r\n  map_one' := smul_one r\n  map_mul' := smul_mul' r", "start": [1053, 1], "end": [1058, 26], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.toMonoidHom_apply", "code": "@[simp]\ntheorem MulDistribMulAction.toMonoidHom_apply (r : M) (x : A) :\n    MulDistribMulAction.toMonoidHom A r x = r \u2022 x", "start": [1063, 1], "end": [1066, 6], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.toMonoidEnd", "code": "@[simps]\ndef MulDistribMulAction.toMonoidEnd :\n    M \u2192* Monoid.End A where\n  toFun := MulDistribMulAction.toMonoidHom A\n  map_one' := MonoidHom.ext <| one_smul M\n  map_mul' x y := MonoidHom.ext <| mul_smul x y", "start": [1071, 1], "end": [1077, 48], "kind": "commanddeclaration"}, {"full_name": "smul_inv'", "code": "@[simp]\ntheorem smul_inv' (r : M) (x : A) : r \u2022 x\u207b\u00b9 = (r \u2022 x)\u207b\u00b9", "start": [1087, 1], "end": [1089, 50], "kind": "commanddeclaration"}, {"full_name": "smul_div'", "code": "theorem smul_div' (r : M) (x y : A) : r \u2022 (x / y) = r \u2022 x / r \u2022 y", "start": [1092, 1], "end": [1093, 52], "kind": "commanddeclaration"}, {"full_name": "Function.End", "code": "protected def Function.End :=\n  \u03b1 \u2192 \u03b1", "start": [1100, 1], "end": [1104, 8], "kind": "commanddeclaration"}, {"full_name": "Function.End.applyMulAction", "code": "instance Function.End.applyMulAction :\n    MulAction (Function.End \u03b1) \u03b1 where\n  smul := (\u00b7 <| \u00b7)\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [1119, 1], "end": [1136, 24], "kind": "commanddeclaration"}, {"full_name": "Function.End.smul_def", "code": "@[simp]\ntheorem Function.End.smul_def (f : Function.End \u03b1) (a : \u03b1) : f \u2022 a = f a", "start": [1139, 1], "end": [1141, 6], "kind": "commanddeclaration"}, {"full_name": "Function.End.mul_def", "code": "theorem Function.End.mul_def (f g : Function.End \u03b1) : (f * g) = f \u2218 g", "start": [1145, 1], "end": [1146, 6], "kind": "commanddeclaration"}, {"full_name": "Function.End.one_def", "code": "theorem Function.End.one_def : (1 : Function.End \u03b1) = id", "start": [1149, 1], "end": [1150, 6], "kind": "commanddeclaration"}, {"full_name": "Function.End.apply_FaithfulSMul", "code": "instance Function.End.apply_FaithfulSMul : FaithfulSMul (Function.End \u03b1) \u03b1 :=\n  \u27e8fun {_ _} => funext\u27e9", "start": [1152, 1], "end": [1154, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.applyDistribMulAction", "code": "instance AddMonoid.End.applyDistribMulAction [AddMonoid \u03b1] :\n    DistribMulAction (AddMonoid.End \u03b1) \u03b1 where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := AddMonoidHom.map_zero\n  smul_add := AddMonoidHom.map_add\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [1157, 1], "end": [1166, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.smul_def", "code": "@[simp]\ntheorem AddMonoid.End.smul_def [AddMonoid \u03b1] (f : AddMonoid.End \u03b1) (a : \u03b1) : f \u2022 a = f a", "start": [1169, 1], "end": [1171, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.applyFaithfulSMul", "code": "instance AddMonoid.End.applyFaithfulSMul [AddMonoid \u03b1] :\n    FaithfulSMul (AddMonoid.End \u03b1) \u03b1 :=\n  \u27e8fun {_ _ h} => AddMonoidHom.ext h\u27e9", "start": [1174, 1], "end": [1177, 38], "kind": "commanddeclaration"}, {"full_name": "MulAction.toEndHom", "code": "def MulAction.toEndHom [Monoid M] [MulAction M \u03b1] : M \u2192* Function.End \u03b1 where\n  toFun := (\u00b7 \u2022 \u00b7)\n  map_one' := funext (one_smul M)\n  map_mul' x y := funext (mul_smul x y)", "start": [1180, 1], "end": [1186, 40], "kind": "commanddeclaration"}, {"full_name": "MulAction.ofEndHom", "code": "@[reducible]\ndef MulAction.ofEndHom [Monoid M] (f : M \u2192* Function.End \u03b1) : MulAction M \u03b1 :=\n  MulAction.compHom \u03b1 f", "start": [1189, 1], "end": [1194, 24], "kind": "commanddeclaration"}, {"full_name": "Additive.vadd", "code": "instance Additive.vadd [SMul \u03b1 \u03b2] : VAdd (Additive \u03b1) \u03b2 :=\n  \u27e8fun a => (toMul a \u2022 \u00b7)\u27e9", "start": [1203, 1], "end": [1204, 27], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.smul", "code": "instance Multiplicative.smul [VAdd \u03b1 \u03b2] : SMul (Multiplicative \u03b1) \u03b2 :=\n  \u27e8fun a => (toAdd a +\u1d65 \u00b7)\u27e9", "start": [1207, 1], "end": [1208, 28], "kind": "commanddeclaration"}, {"full_name": "toMul_smul", "code": "@[simp]\ntheorem toMul_smul [SMul \u03b1 \u03b2] (a) (b : \u03b2) : (toMul a : \u03b1) \u2022 b = a +\u1d65 b", "start": [1211, 1], "end": [1213, 6], "kind": "commanddeclaration"}, {"full_name": "ofMul_vadd", "code": "@[simp]\ntheorem ofMul_vadd [SMul \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : ofMul a +\u1d65 b = a \u2022 b", "start": [1216, 1], "end": [1218, 6], "kind": "commanddeclaration"}, {"full_name": "toAdd_vadd", "code": "@[simp]\ntheorem toAdd_vadd [VAdd \u03b1 \u03b2] (a) (b : \u03b2) : (toAdd a : \u03b1) +\u1d65 b = a \u2022 b", "start": [1221, 1], "end": [1223, 6], "kind": "commanddeclaration"}, {"full_name": "ofAdd_smul", "code": "@[simp]\ntheorem ofAdd_smul [VAdd \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : ofAdd a \u2022 b = a +\u1d65 b", "start": [1226, 1], "end": [1228, 6], "kind": "commanddeclaration"}, {"full_name": "Additive.addAction", "code": "instance Additive.addAction [Monoid \u03b1] [MulAction \u03b1 \u03b2] :\n    AddAction (Additive \u03b1) \u03b2 where\n  zero_vadd := MulAction.one_smul\n  add_vadd := @MulAction.mul_smul \u03b1 _ _ _", "start": [1232, 1], "end": [1235, 42], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.mulAction", "code": "instance Multiplicative.mulAction [AddMonoid \u03b1] [AddAction \u03b1 \u03b2] :\n    MulAction (Multiplicative \u03b1)\n      \u03b2 where\n  one_smul := AddAction.zero_vadd\n  mul_smul := @AddAction.add_vadd \u03b1 _ _ _", "start": [1238, 1], "end": [1242, 42], "kind": "commanddeclaration"}, {"full_name": "Additive.addAction_isPretransitive", "code": "instance Additive.addAction_isPretransitive [Monoid \u03b1] [MulAction \u03b1 \u03b2]\n    [MulAction.IsPretransitive \u03b1 \u03b2] : AddAction.IsPretransitive (Additive \u03b1) \u03b2 :=\n  \u27e8@MulAction.exists_smul_eq \u03b1 _ _ _\u27e9", "start": [1245, 1], "end": [1247, 38], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.mulAction_isPretransitive", "code": "instance Multiplicative.mulAction_isPretransitive [AddMonoid \u03b1] [AddAction \u03b1 \u03b2]\n    [AddAction.IsPretransitive \u03b1 \u03b2] : MulAction.IsPretransitive (Multiplicative \u03b1) \u03b2 :=\n  \u27e8@AddAction.exists_vadd_eq \u03b1 _ _ _\u27e9", "start": [1250, 1], "end": [1252, 38], "kind": "commanddeclaration"}, {"full_name": "Additive.vaddCommClass", "code": "instance Additive.vaddCommClass [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    VAddCommClass (Additive \u03b1) (Additive \u03b2) \u03b3 :=\n  \u27e8@smul_comm \u03b1 \u03b2 _ _ _ _\u27e9", "start": [1255, 1], "end": [1257, 27], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.smulCommClass", "code": "instance Multiplicative.smulCommClass [VAdd \u03b1 \u03b3] [VAdd \u03b2 \u03b3] [VAddCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Multiplicative \u03b1) (Multiplicative \u03b2) \u03b3 :=\n  \u27e8@vadd_comm \u03b1 \u03b2 _ _ _ _\u27e9", "start": [1260, 1], "end": [1262, 27], "kind": "commanddeclaration"}, {"full_name": "AddAction.functionEnd", "code": "instance AddAction.functionEnd : AddAction (Additive (Function.End \u03b1)) \u03b1 :=\n  inferInstance", "start": [1267, 1], "end": [1269, 16], "kind": "commanddeclaration"}, {"full_name": "AddAction.toEndHom", "code": "def AddAction.toEndHom [AddMonoid M] [AddAction M \u03b1] : M \u2192+ Additive (Function.End \u03b1) :=\n  MonoidHom.toAdditive'' MulAction.toEndHom", "start": [1272, 1], "end": [1276, 44], "kind": "commanddeclaration"}, {"full_name": "AddAction.ofEndHom", "code": "@[reducible]\ndef AddAction.ofEndHom [AddMonoid M] (f : M \u2192+ Additive (Function.End \u03b1)) : AddAction M \u03b1 :=\n  AddAction.compHom \u03b1 f", "start": [1279, 1], "end": [1284, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Sub/Canonical.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/Algebra/Order/Sub/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "add_tsub_cancel_of_le", "code": "@[simp]\ntheorem add_tsub_cancel_of_le (h : a \u2264 b) : a + (b - a) = b", "start": [23, 1], "end": [27, 43], "kind": "commanddeclaration"}, {"full_name": "tsub_add_cancel_of_le", "code": "theorem tsub_add_cancel_of_le (h : a \u2264 b) : b - a + a = b", "start": [30, 1], "end": [32, 32], "kind": "commanddeclaration"}, {"full_name": "add_le_of_le_tsub_right_of_le", "code": "theorem add_le_of_le_tsub_right_of_le (h : b \u2264 c) (h2 : a \u2264 c - b) : a + b \u2264 c", "start": [35, 1], "end": [36, 62], "kind": "commanddeclaration"}, {"full_name": "add_le_of_le_tsub_left_of_le", "code": "theorem add_le_of_le_tsub_left_of_le (h : a \u2264 c) (h2 : b \u2264 c - a) : a + b \u2264 c", "start": [39, 1], "end": [40, 61], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub_iff_right", "code": "theorem tsub_le_tsub_iff_right (h : c \u2264 b) : a - c \u2264 b - c \u2194 a \u2264 b", "start": [43, 1], "end": [44, 50], "kind": "commanddeclaration"}, {"full_name": "tsub_left_inj", "code": "theorem tsub_left_inj (h1 : c \u2264 a) (h2 : c \u2264 b) : a - c = b - c \u2194 a = b", "start": [47, 1], "end": [48, 82], "kind": "commanddeclaration"}, {"full_name": "tsub_inj_left", "code": "theorem tsub_inj_left (h\u2081 : a \u2264 b) (h\u2082 : a \u2264 c) : b - a = c - a \u2192 b = c", "start": [51, 1], "end": [52, 26], "kind": "commanddeclaration"}, {"full_name": "lt_of_tsub_lt_tsub_right_of_le", "code": "theorem lt_of_tsub_lt_tsub_right_of_le (h : c \u2264 b) (h2 : a - c < b - c) : a < b", "start": [55, 1], "end": [59, 17], "kind": "commanddeclaration"}, {"full_name": "tsub_add_tsub_cancel", "code": "theorem tsub_add_tsub_cancel (hab : b \u2264 a) (hcb : c \u2264 b) : a - b + (b - c) = a - c", "start": [62, 1], "end": [64, 44], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_tsub_cancel_right", "code": "theorem tsub_tsub_tsub_cancel_right (h : c \u2264 b) : a - c - (b - c) = a - b", "start": [67, 1], "end": [68, 42], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.eq_tsub_iff_add_eq_of_le", "code": "protected theorem eq_tsub_iff_add_eq_of_le (hc : AddLECancellable c) (h : c \u2264 b) :\n    a = b - c \u2194 a + c = b", "start": [76, 1], "end": [80, 57], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_eq_iff_eq_add_of_le", "code": "protected theorem tsub_eq_iff_eq_add_of_le (hb : AddLECancellable b) (h : b \u2264 a) :\n    a - b = c \u2194 a = c + b", "start": [83, 1], "end": [84, 85], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.add_tsub_assoc_of_le", "code": "protected theorem add_tsub_assoc_of_le (hc : AddLECancellable c) (h : c \u2264 b) (a : \u03b1) :\n    a + b - c = a + (b - c)", "start": [87, 1], "end": [89, 96], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_add_eq_add_tsub", "code": "protected theorem tsub_add_eq_add_tsub (hb : AddLECancellable b) (h : b \u2264 a) :\n    a - b + c = a + c - b", "start": [92, 1], "end": [93, 85], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_tsub_assoc", "code": "protected theorem tsub_tsub_assoc (hbc : AddLECancellable (b - c)) (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 b) :\n    a - (b - c) = a - b + c", "start": [96, 1], "end": [98, 97], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_add_tsub_comm", "code": "protected theorem tsub_add_tsub_comm (hb : AddLECancellable b) (hd : AddLECancellable d)\n    (hba : b \u2264 a) (hdc : d \u2264 c) : a - b + (c - d) = a + c - (b + d)", "start": [101, 1], "end": [103, 89], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_tsub_iff_left", "code": "protected theorem le_tsub_iff_left (ha : AddLECancellable a) (h : a \u2264 c) : b \u2264 c - a \u2194 a + b \u2264 c", "start": [106, 1], "end": [107, 62], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_tsub_iff_right", "code": "protected theorem le_tsub_iff_right (ha : AddLECancellable a) (h : a \u2264 c) :\n    b \u2264 c - a \u2194 b + a \u2264 c", "start": [110, 1], "end": [113, 30], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_iff_left", "code": "protected theorem tsub_lt_iff_left (hb : AddLECancellable b) (hba : b \u2264 a) :\n    a - b < c \u2194 a < b + c", "start": [116, 1], "end": [120, 54], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_iff_right", "code": "protected theorem tsub_lt_iff_right (hb : AddLECancellable b) (hba : b \u2264 a) :\n    a - b < c \u2194 a < c + b", "start": [123, 1], "end": [126, 32], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_iff_tsub_lt", "code": "protected theorem tsub_lt_iff_tsub_lt (hb : AddLECancellable b) (hc : AddLECancellable c)\n    (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) : a - b < c \u2194 a - c < b", "start": [129, 1], "end": [131, 55], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.le_tsub_iff_le_tsub", "code": "protected theorem le_tsub_iff_le_tsub (ha : AddLECancellable a) (hc : AddLECancellable c)\n    (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 b) : a \u2264 b - c \u2194 c \u2264 b - a", "start": [134, 1], "end": [136, 55], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_iff_right_of_le", "code": "protected theorem lt_tsub_iff_right_of_le (hc : AddLECancellable c) (h : c \u2264 b) :\n    a < b - c \u2194 a + c < b", "start": [139, 1], "end": [143, 40], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_iff_left_of_le", "code": "protected theorem lt_tsub_iff_left_of_le (hc : AddLECancellable c) (h : c \u2264 b) :\n    a < b - c \u2194 c + a < b", "start": [146, 1], "end": [149, 37], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_inj_right", "code": "protected theorem tsub_inj_right (hab : AddLECancellable (a - b)) (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a)\n    (h\u2083 : a - b = a - c) : b = c", "start": [152, 1], "end": [155, 62], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_of_tsub_lt_tsub_left_of_le", "code": "protected theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    (hb : AddLECancellable b) (hca : c \u2264 a) (h : a - b < a - c) : c < b", "start": [158, 1], "end": [161, 61], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_tsub_left_of_le", "code": "protected theorem tsub_lt_tsub_left_of_le (hab : AddLECancellable (a - b)) (h\u2081 : b \u2264 a)\n    (h : c < b) : a - b < a - c", "start": [164, 1], "end": [166, 98], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_tsub_right_of_le", "code": "protected theorem tsub_lt_tsub_right_of_le (hc : AddLECancellable c) (h : c \u2264 a) (h2 : a < b) :\n    a - c < b - c", "start": [169, 1], "end": [172, 32], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_tsub_iff_left_of_le_of_le", "code": "protected theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    (hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) :\n    a - b < a - c \u2194 c < b", "start": [175, 1], "end": [178, 72], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.add_tsub_tsub_cancel", "code": "@[simp]\nprotected theorem add_tsub_tsub_cancel (hac : AddLECancellable (a - c)) (h : c \u2264 a) :\n    a + b - (a - c) = b + c", "start": [181, 1], "end": [184, 80], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_tsub_cancel_of_le", "code": "protected theorem tsub_tsub_cancel_of_le (hba : AddLECancellable (b - a)) (h : a \u2264 b) :\n    b - (b - a) = a", "start": [187, 1], "end": [189, 55], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_tsub_tsub_cancel_left", "code": "protected theorem tsub_tsub_tsub_cancel_left (hab : AddLECancellable (a - b)) (h : b \u2264 a) :\n    a - c - (a - b) = b - c", "start": [192, 1], "end": [193, 85], "kind": "commanddeclaration"}, {"full_name": "eq_tsub_iff_add_eq_of_le", "code": "theorem eq_tsub_iff_add_eq_of_le (h : c \u2264 b) : a = b - c \u2194 a + c = b", "start": [205, 1], "end": [206, 60], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_iff_eq_add_of_le", "code": "theorem tsub_eq_iff_eq_add_of_le (h : b \u2264 a) : a - b = c \u2194 a = c + b", "start": [209, 1], "end": [210, 60], "kind": "commanddeclaration"}, {"full_name": "add_tsub_assoc_of_le", "code": "theorem add_tsub_assoc_of_le (h : c \u2264 b) (a : \u03b1) : a + b - c = a + (b - c)", "start": [213, 1], "end": [215, 58], "kind": "commanddeclaration"}, {"full_name": "tsub_add_eq_add_tsub", "code": "theorem tsub_add_eq_add_tsub (h : b \u2264 a) : a - b + c = a + c - b", "start": [218, 1], "end": [219, 56], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_assoc", "code": "theorem tsub_tsub_assoc (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 b) : a - (b - c) = a - b + c", "start": [222, 1], "end": [223, 55], "kind": "commanddeclaration"}, {"full_name": "tsub_add_tsub_comm", "code": "theorem tsub_add_tsub_comm (hba : b \u2264 a) (hdc : d \u2264 c) : a - b + (c - d) = a + c - (b + d)", "start": [226, 1], "end": [227, 91], "kind": "commanddeclaration"}, {"full_name": "le_tsub_iff_left", "code": "theorem le_tsub_iff_left (h : a \u2264 c) : b \u2264 c - a \u2194 a + b \u2264 c", "start": [230, 1], "end": [231, 52], "kind": "commanddeclaration"}, {"full_name": "le_tsub_iff_right", "code": "theorem le_tsub_iff_right (h : a \u2264 c) : b \u2264 c - a \u2194 b + a \u2264 c", "start": [234, 1], "end": [235, 53], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_iff_left", "code": "theorem tsub_lt_iff_left (hbc : b \u2264 a) : a - b < c \u2194 a < b + c", "start": [238, 1], "end": [239, 54], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_iff_right", "code": "theorem tsub_lt_iff_right (hbc : b \u2264 a) : a - b < c \u2194 a < c + b", "start": [242, 1], "end": [243, 55], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_iff_tsub_lt", "code": "theorem tsub_lt_iff_tsub_lt (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) : a - b < c \u2194 a - c < b", "start": [246, 1], "end": [247, 90], "kind": "commanddeclaration"}, {"full_name": "le_tsub_iff_le_tsub", "code": "theorem le_tsub_iff_le_tsub (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 b) : a \u2264 b - c \u2194 c \u2264 b - a", "start": [250, 1], "end": [251, 90], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_iff_right_of_le", "code": "theorem lt_tsub_iff_right_of_le (h : c \u2264 b) : a < b - c \u2194 a + c < b", "start": [254, 1], "end": [256, 59], "kind": "commanddeclaration"}, {"full_name": "lt_tsub_iff_left_of_le", "code": "theorem lt_tsub_iff_left_of_le (h : c \u2264 b) : a < b - c \u2194 c + a < b", "start": [259, 1], "end": [261, 58], "kind": "commanddeclaration"}, {"full_name": "lt_of_tsub_lt_tsub_left_of_le", "code": "theorem lt_of_tsub_lt_tsub_left_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (hca : c \u2264 a)\n    (h : a - b < a - c) : c < b", "start": [264, 1], "end": [267, 69], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_tsub_left_of_le", "code": "theorem tsub_lt_tsub_left_of_le : b \u2264 a \u2192 c < b \u2192 a - b < a - c", "start": [270, 1], "end": [271, 57], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_tsub_right_of_le", "code": "theorem tsub_lt_tsub_right_of_le (h : c \u2264 a) (h2 : a < b) : a - c < b - c", "start": [274, 1], "end": [275, 63], "kind": "commanddeclaration"}, {"full_name": "tsub_inj_right", "code": "theorem tsub_inj_right (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) (h\u2083 : a - b = a - c) : b = c", "start": [278, 1], "end": [279, 57], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_tsub_iff_left_of_le_of_le", "code": "theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)] (h\u2081 : b \u2264 a)\n    (h\u2082 : c \u2264 a) : a - b < a - c \u2194 c < b", "start": [282, 1], "end": [286, 7], "kind": "commanddeclaration"}, {"full_name": "add_tsub_tsub_cancel", "code": "@[simp]\ntheorem add_tsub_tsub_cancel (h : c \u2264 a) : a + b - (a - c) = b + c", "start": [289, 1], "end": [291, 56], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_cancel_of_le", "code": "theorem tsub_tsub_cancel_of_le (h : a \u2264 b) : b - (b - a) = a", "start": [294, 1], "end": [296, 58], "kind": "commanddeclaration"}, {"full_name": "tsub_tsub_tsub_cancel_left", "code": "theorem tsub_tsub_tsub_cancel_left (h : b \u2264 a) : a - c - (a - b) = b - c", "start": [299, 1], "end": [300, 62], "kind": "commanddeclaration"}, {"full_name": "add_tsub_cancel_iff_le", "code": "theorem add_tsub_cancel_iff_le : a + (b - a) = b \u2194 a \u2264 b", "start": [314, 1], "end": [315, 74], "kind": "commanddeclaration"}, {"full_name": "tsub_add_cancel_iff_le", "code": "theorem tsub_add_cancel_iff_le : b - a + a = b \u2194 a \u2264 b", "start": [318, 1], "end": [320, 31], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_zero_iff_le", "code": "@[simp]\ntheorem tsub_eq_zero_iff_le : a - b = 0 \u2194 a \u2264 b", "start": [323, 1], "end": [325, 56], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_zero_of_le", "code": "alias \u27e8_, tsub_eq_zero_of_le\u27e9 := tsub_eq_zero_iff_le", "start": [328, 1], "end": [328, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "tsub_self", "code": "theorem tsub_self (a : \u03b1) : a - a = 0", "start": [333, 1], "end": [334, 28], "kind": "commanddeclaration"}, {"full_name": "tsub_le_self", "code": "theorem tsub_le_self : a - b \u2264 a", "start": [337, 1], "end": [338, 45], "kind": "commanddeclaration"}, {"full_name": "zero_tsub", "code": "theorem zero_tsub (a : \u03b1) : 0 - a = 0", "start": [341, 1], "end": [342, 34], "kind": "commanddeclaration"}, {"full_name": "tsub_self_add", "code": "theorem tsub_self_add (a b : \u03b1) : a - (a + b) = 0", "start": [345, 1], "end": [346, 46], "kind": "commanddeclaration"}, {"full_name": "tsub_pos_iff_not_le", "code": "theorem tsub_pos_iff_not_le : 0 < a - b \u2194 \u00aca \u2264 b", "start": [349, 1], "end": [350, 52], "kind": "commanddeclaration"}, {"full_name": "tsub_pos_of_lt", "code": "theorem tsub_pos_of_lt (h : a < b) : 0 < b - a", "start": [353, 1], "end": [354, 35], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_of_lt", "code": "theorem tsub_lt_of_lt (h : a < b) : a - c < b", "start": [357, 1], "end": [358, 32], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_le_tsub_iff_left", "code": "protected theorem tsub_le_tsub_iff_left (ha : AddLECancellable a) (hc : AddLECancellable c)\n    (h : c \u2264 a) : a - b \u2264 a - c \u2194 c \u2264 b", "start": [363, 1], "end": [368, 11], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_right_inj", "code": "protected theorem tsub_right_inj (ha : AddLECancellable a) (hb : AddLECancellable b)\n    (hc : AddLECancellable c) (hba : b \u2264 a) (hca : c \u2264 a) : a - b = a - c \u2194 b = c", "start": [371, 1], "end": [374, 14], "kind": "commanddeclaration"}, {"full_name": "tsub_le_tsub_iff_left", "code": "theorem tsub_le_tsub_iff_left (h : c \u2264 a) : a - b \u2264 a - c \u2194 c \u2264 b", "start": [386, 1], "end": [387, 88], "kind": "commanddeclaration"}, {"full_name": "tsub_right_inj", "code": "theorem tsub_right_inj (hba : b \u2264 a) (hca : c \u2264 a) : a - b = a - c \u2194 b = c", "start": [390, 1], "end": [392, 43], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedAddCommMonoid.toAddCancelCommMonoid", "code": "@[reducible]\ndef CanonicallyOrderedAddCommMonoid.toAddCancelCommMonoid : AddCancelCommMonoid \u03b1 :=\n  { (by infer_instance : AddCommMonoid \u03b1) with\n    add_left_cancel := fun a b c h => by\n      simpa only [add_tsub_cancel_left] using congr_arg (fun x => x - a) h }", "start": [397, 1], "end": [405, 77], "kind": "commanddeclaration"}, {"full_name": "tsub_pos_iff_lt", "code": "@[simp]\ntheorem tsub_pos_iff_lt : 0 < a - b \u2194 b < a", "start": [419, 1], "end": [420, 83], "kind": "commanddeclaration"}, {"full_name": "tsub_eq_tsub_min", "code": "theorem tsub_eq_tsub_min (a b : \u03b1) : a - b = a - min a b", "start": [423, 1], "end": [426, 24], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_iff_right", "code": "protected theorem lt_tsub_iff_right (hc : AddLECancellable c) : a < b - c \u2194 a + c < b", "start": [431, 1], "end": [432, 77], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.lt_tsub_iff_left", "code": "protected theorem lt_tsub_iff_left (hc : AddLECancellable c) : a < b - c \u2194 c + a < b", "start": [435, 1], "end": [436, 75], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_tsub_iff_right", "code": "protected theorem tsub_lt_tsub_iff_right (hc : AddLECancellable c) (h : c \u2264 a) :\n    a - c < b - c \u2194 a < b", "start": [439, 1], "end": [440, 82], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_self", "code": "protected theorem tsub_lt_self (ha : AddLECancellable a) (h\u2081 : 0 < a) (h\u2082 : 0 < b) : a - b < a", "start": [443, 1], "end": [446, 91], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_self_iff", "code": "protected theorem tsub_lt_self_iff (ha : AddLECancellable a) : a - b < a \u2194 0 < a \u2227 0 < b", "start": [449, 1], "end": [454, 16], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_lt_tsub_iff_left_of_le", "code": "protected theorem tsub_lt_tsub_iff_left_of_le (ha : AddLECancellable a) (hb : AddLECancellable b)\n    (h : b \u2264 a) : a - b < a - c \u2194 c < b", "start": [457, 1], "end": [460, 58], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_tsub_iff_right", "code": "theorem tsub_lt_tsub_iff_right (h : c \u2264 a) : a - c < b - c \u2194 a < b", "start": [469, 1], "end": [471, 58], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_self", "code": "theorem tsub_lt_self : 0 < a \u2192 0 < b \u2192 a - b < a", "start": [474, 1], "end": [475, 46], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_self_iff", "code": "theorem tsub_lt_self_iff : a - b < a \u2194 0 < a \u2227 0 < b", "start": [478, 1], "end": [479, 50], "kind": "commanddeclaration"}, {"full_name": "tsub_lt_tsub_iff_left_of_le", "code": "theorem tsub_lt_tsub_iff_left_of_le (h : b \u2264 a) : a - b < a - c \u2194 c < b", "start": [482, 1], "end": [484, 94], "kind": "commanddeclaration"}, {"full_name": "tsub_add_eq_max", "code": "theorem tsub_add_eq_max : a - b + b = max a b", "start": [492, 1], "end": [495, 48], "kind": "commanddeclaration"}, {"full_name": "add_tsub_eq_max", "code": "theorem add_tsub_eq_max : a + (b - a) = max a b", "start": [498, 1], "end": [498, 95], "kind": "commanddeclaration"}, {"full_name": "tsub_min", "code": "theorem tsub_min : a - min a b = a - b", "start": [501, 1], "end": [504, 24], "kind": "commanddeclaration"}, {"full_name": "tsub_add_min", "code": "theorem tsub_add_min : a - b + min a b = a", "start": [507, 1], "end": [509, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Nat/Bitwise.lean", "imports": ["Mathlib/Data/Bool/Basic.lean", "Mathlib/Tactic/PermuteGoals.lean", "Mathlib/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Bool/Lemmas.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Init/ZeroOne.lean", "lake-packages/lean4/src/lean/Init/WFTactics.lean"], "premises": [{"full_name": "Nat.boddDiv2", "code": "def boddDiv2 : \u2115 \u2192 Bool \u00d7 \u2115\n  | 0 => (false, 0)\n  | succ n =>\n    match boddDiv2 n with\n    | (false, m) => (true, m)\n    | (true, m) => (false, succ m)", "start": [33, 1], "end": [41, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.div2", "code": "def div2 (n : \u2115) : \u2115 :=\n  (boddDiv2 n).2", "start": [44, 1], "end": [46, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd", "code": "def bodd (n : \u2115) : Bool :=\n  (boddDiv2 n).1", "start": [49, 1], "end": [51, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_zero", "code": "@[simp]\ntheorem bodd_zero : bodd 0 = false", "start": [54, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_one", "code": "theorem bodd_one : bodd 1 = true", "start": [59, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_two", "code": "theorem bodd_two : bodd 2 = false", "start": [63, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_succ", "code": "@[simp]\ntheorem bodd_succ (n : \u2115) : bodd (succ n) = not (bodd n)", "start": [67, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_add", "code": "@[simp]\ntheorem bodd_add (m n : \u2115) : bodd (m + n) = bxor (bodd m) (bodd n)", "start": [74, 1], "end": [79, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_mul", "code": "@[simp]\ntheorem bodd_mul (m n : \u2115) : bodd (m * n) = (bodd m && bodd n)", "start": [82, 1], "end": [87, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_two_of_bodd", "code": "theorem mod_two_of_bodd (n : \u2115) : n % 2 = cond (bodd n) 1 0", "start": [90, 1], "end": [100, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_zero", "code": "@[simp]\ntheorem div2_zero : div2 0 = 0", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_one", "code": "theorem div2_one : div2 1 = 0", "start": [108, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_two", "code": "theorem div2_two : div2 2 = 1", "start": [112, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_succ", "code": "@[simp]\ntheorem div2_succ (n : \u2115) : div2 (succ n) = cond (bodd n) (succ (div2 n)) (div2 n)", "start": [116, 1], "end": [124, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_add_div2", "code": "theorem bodd_add_div2 : \u2200 n, cond (bodd n) 1 0 + 2 * div2 n = n", "start": [129, 1], "end": [136, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_val", "code": "theorem div2_val (n) : div2 n = n / 2", "start": [139, 1], "end": [143, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.bit", "code": "def bit (b : Bool) : \u2115 \u2192 \u2115 :=\n  cond b bit1 bit0", "start": [146, 1], "end": [149, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_val", "code": "theorem bit0_val (n : Nat) : bit0 n = 2 * n", "start": [152, 1], "end": [156, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_val", "code": "theorem bit1_val (n : Nat) : bit1 n = 2 * n + 1", "start": [159, 1], "end": [160, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_val", "code": "theorem bit_val (b n) : bit b n = 2 * n + cond b 1 0", "start": [163, 1], "end": [166, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_decomp", "code": "theorem bit_decomp (n : Nat) : bit (bodd n) (div2 n) = n", "start": [169, 1], "end": [170, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.bitCasesOn", "code": "def bitCasesOn {C : Nat \u2192 Sort u} (n) (h : \u2200 b n, C (bit b n)) : C n := bit_decomp n \u25b8 h _ _", "start": [173, 1], "end": [176, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_zero", "code": "theorem bit_zero : bit false 0 = 0", "start": [179, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'", "code": "def shiftLeft' (b : Bool) (m : \u2115) : \u2115 \u2192 \u2115\n  | 0 => m\n  | n + 1 => bit b (shiftLeft' b m n)", "start": [183, 1], "end": [188, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_false", "code": "@[simp]\ntheorem shiftLeft'_false : \u2200 n, shiftLeft' false m n = m <<< n", "start": [191, 1], "end": [197, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft_eq'", "code": "@[simp]\nlemma shiftLeft_eq' (m n : Nat) : shiftLeft m n = m <<< n := rfl", "start": [199, 1], "end": [201, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.shiftRight_eq", "code": "@[simp]\nlemma shiftRight_eq (m n : Nat) : shiftRight m n = m >>> n := rfl", "start": [203, 1], "end": [204, 66], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.shiftLeft_zero", "code": "theorem shiftLeft_zero (m) : m <<< 0 = m", "start": [206, 1], "end": [206, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft_succ", "code": "theorem shiftLeft_succ (m n) : m <<< (n + 1) = 2 * (m <<< n)", "start": [208, 1], "end": [209, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit", "code": "def testBit (m n : \u2115) : Bool :=\n  bodd (m >>> n)", "start": [211, 1], "end": [213, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRec_decreasing", "code": "lemma binaryRec_decreasing (h : n \u2260 0) : div2 n < n := by\n  rw [div2_val]\n  apply (div_lt_iff_lt_mul <| succ_pos 1).2\n  have := Nat.mul_lt_mul_of_pos_left (lt_succ_self 1)\n    (lt_of_le_of_ne n.zero_le h.symm)\n  rwa [Nat.mul_one] at this", "start": [216, 1], "end": [221, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.binaryRec", "code": "def binaryRec {C : Nat \u2192 Sort u} (z : C 0) (f : \u2200 b n, C n \u2192 C (bit b n)) : \u2200 n, C n :=\n  fun n =>\n    if n0 : n = 0 then by\n      simp only [n0]\n      exact z\n    else by\n      let n' := div2 n\n      have _x : bit (bodd n) n' = n := by\n        apply bit_decomp n\n      rw [\u2190_x]\n      exact f (bodd n) n' (binaryRec z f n')\n  decreasing_by exact binaryRec_decreasing n0", "start": [223, 1], "end": [238, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.size", "code": "def size : \u2115 \u2192 \u2115 :=\n  binaryRec 0 fun _ _ => succ", "start": [241, 1], "end": [244, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.bits", "code": "def bits : \u2115 \u2192 List Bool :=\n  binaryRec [] fun b _ IH => b :: IH", "start": [247, 1], "end": [249, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.ldiff", "code": "def ldiff : \u2115 \u2192 \u2115 \u2192 \u2115 :=\n  bitwise fun a b => a && not b", "start": [258, 1], "end": [262, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRec_zero", "code": "@[simp]\ntheorem binaryRec_zero {C : Nat \u2192 Sort u} (z : C 0) (f : \u2200 b n, C n \u2192 C (bit b n)) :\n    binaryRec z f 0 = z", "start": [265, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_bit", "code": "theorem bodd_bit (b n) : bodd (bit b n) = b", "start": [274, 1], "end": [278, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_bit", "code": "theorem div2_bit (b n) : div2 (bit b n) = n", "start": [281, 1], "end": [284, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_add", "code": "theorem shiftLeft'_add (b m n) : \u2200 k, shiftLeft' b m (n + k) = shiftLeft' b (shiftLeft' b m n) k", "start": [287, 1], "end": [289, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft_add", "code": "theorem shiftLeft_add (m n : Nat) : \u2200 k, m <<< (n + k) = (m <<< n) <<< k", "start": [292, 1], "end": [293, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft'_sub", "code": "theorem shiftLeft'_sub (b m) : \u2200 {n k}, k \u2264 n \u2192 shiftLeft' b m (n - k) = (shiftLeft' b m n) >>> k", "start": [295, 1], "end": [300, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.shiftLeft_sub", "code": "theorem shiftLeft_sub : \u2200 (m : Nat) {n k}, k \u2264 n \u2192 m <<< (n - k) = (m <<< n) >>> k", "start": [303, 1], "end": [304, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_zero", "code": "@[simp]\ntheorem testBit_zero (b n) : testBit (bit b n) 0 = b", "start": [306, 1], "end": [308, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_succ", "code": "theorem testBit_succ (m b n) : testBit (bit b n) (succ m) = testBit n m", "start": [311, 1], "end": [316, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRec_eq", "code": "theorem binaryRec_eq {C : Nat \u2192 Sort u} {z : C 0} {f : \u2200 b n, C n \u2192 C (bit b n)}\n    (h : f false 0 z = z) (b n) : binaryRec z f (bit b n) = f b n (binaryRec z f n)", "start": [319, 1], "end": [343, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/List/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "lake-packages/std/Std/Data/List/Basic.lean", "Mathlib/Init/Data/Nat/Notation.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "List.nthLe", "code": "@[deprecated get]\ndef nthLe (l : List \u03b1) (n) (h : n < l.length) : \u03b1 := get l \u27e8n, h\u27e9", "start": [29, 1], "end": [31, 66], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_eq", "code": "@[deprecated]\ntheorem nthLe_eq (l : List \u03b1) (n) (h : n < l.length) : nthLe l n h = get l \u27e8n, h\u27e9", "start": [35, 1], "end": [36, 89], "kind": "commanddeclaration"}, {"full_name": "List.headI", "code": "def headI [Inhabited \u03b1] : List \u03b1 \u2192 \u03b1\n  | []       => default\n  | (a :: _) => a", "start": [38, 1], "end": [41, 18], "kind": "commanddeclaration"}, {"full_name": "List.headI_nil", "code": "@[simp] theorem headI_nil [Inhabited \u03b1] : ([] : List \u03b1).headI = default", "start": [44, 1], "end": [44, 79], "kind": "commanddeclaration"}, {"full_name": "List.headI_cons", "code": "@[simp] theorem headI_cons [Inhabited \u03b1] {h : \u03b1} {t : List \u03b1} : (h :: t).headI = h", "start": [45, 1], "end": [45, 90], "kind": "commanddeclaration"}, {"full_name": "List.findIndex", "code": "@[deprecated findIdx]\ndef findIndex (p : \u03b1 \u2192 Prop) [DecidablePred p] : List \u03b1 \u2192 \u2115 := List.findIdx p", "start": [53, 1], "end": [55, 78], "kind": "commanddeclaration"}, {"full_name": "List.getLastI", "code": "def getLastI [Inhabited \u03b1] : List \u03b1 \u2192 \u03b1\n  | [] => default\n  | [a] => a\n  | [_, b] => b\n  | _ :: _ :: l => getLastI l", "start": [66, 1], "end": [71, 30], "kind": "commanddeclaration"}, {"full_name": "List.ret", "code": "@[inline] protected def ret {\u03b1 : Type u} (a : \u03b1) : List \u03b1 := [a]", "start": [76, 1], "end": [77, 65], "kind": "commanddeclaration"}, {"full_name": "List.le_eq_not_gt", "code": "theorem le_eq_not_gt [LT \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, (l\u2081 \u2264 l\u2082) = \u00acl\u2082 < l\u2081", "start": [80, 1], "end": [81, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Basic.lean", "imports": ["Mathlib/Tactic/PushNeg.lean", "Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Order/Basic.lean", "Mathlib/Algebra/GroupWithZero/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Use.lean", "Mathlib/Init/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "Nat.nontrivial", "code": "instance nontrivial : Nontrivial \u2115 :=\n  \u27e8\u27e80, 1, Nat.zero_ne_one\u27e9\u27e9", "start": [43, 1], "end": [44, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.commSemiring", "code": "instance commSemiring : CommSemiring \u2115 where\n  add := Nat.add\n  add_assoc := Nat.add_assoc\n  zero := Nat.zero\n  zero_add := Nat.zero_add\n  add_zero := Nat.add_zero\n  add_comm := Nat.add_comm\n  mul := Nat.mul\n  mul_assoc := Nat.mul_assoc\n  one := Nat.succ Nat.zero\n  one_mul := Nat.one_mul\n  mul_one := Nat.mul_one\n  left_distrib := Nat.left_distrib\n  right_distrib := Nat.right_distrib\n  zero_mul := Nat.zero_mul\n  mul_zero := Nat.mul_zero\n  mul_comm := Nat.mul_comm\n  natCast n := n\n  natCast_zero := rfl\n  natCast_succ n := rfl\n  nsmul m n := m * n\n  nsmul_zero := Nat.zero_mul\n  nsmul_succ _ _ := by dsimp only; rw [Nat.add_comm, Nat.right_distrib, Nat.one_mul]\n  npow m n := n ^ m\n  npow_zero := Nat.pow_zero\n  npow_succ _ _ := Nat.pow_succ'", "start": [46, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid \u2115 :=\n  inferInstance", "start": [76, 1], "end": [77, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.addMonoid", "code": "instance addMonoid : AddMonoid \u2115 :=\n  inferInstance", "start": [79, 1], "end": [80, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.monoid", "code": "instance monoid : Monoid \u2115 :=\n  inferInstance", "start": [82, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.commMonoid", "code": "instance commMonoid : CommMonoid \u2115 :=\n  inferInstance", "start": [85, 1], "end": [86, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.commSemigroup", "code": "instance commSemigroup : CommSemigroup \u2115 :=\n  inferInstance", "start": [88, 1], "end": [89, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.semigroup", "code": "instance semigroup : Semigroup \u2115 :=\n  inferInstance", "start": [91, 1], "end": [92, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.addCommSemigroup", "code": "instance addCommSemigroup : AddCommSemigroup \u2115 :=\n  inferInstance", "start": [94, 1], "end": [95, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.addSemigroup", "code": "instance addSemigroup : AddSemigroup \u2115 :=\n  inferInstance", "start": [97, 1], "end": [98, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.distrib", "code": "instance distrib : Distrib \u2115 :=\n  inferInstance", "start": [100, 1], "end": [101, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.semiring", "code": "instance semiring : Semiring \u2115 :=\n  inferInstance", "start": [103, 1], "end": [104, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.nsmul_eq_mul", "code": "protected theorem nsmul_eq_mul (m n : \u2115) : m \u2022 n = m * n", "start": [106, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.cancelCommMonoidWithZero", "code": "instance cancelCommMonoidWithZero : CancelCommMonoidWithZero \u2115 :=\n  { (inferInstance : CommMonoidWithZero \u2115) with\n    mul_left_cancel_of_ne_zero :=\n      fun h1 h2 => Nat.eq_of_mul_eq_mul_left (Nat.pos_of_ne_zero h1) h2 }", "start": [113, 1], "end": [116, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.and_forall_succ", "code": "theorem and_forall_succ {p : \u2115 \u2192 Prop} : (p 0 \u2227 \u2200 n, p (n + 1)) \u2194 \u2200 n, p n", "start": [133, 1], "end": [134, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.or_exists_succ", "code": "theorem or_exists_succ {p : \u2115 \u2192 Prop} : (p 0 \u2228 \u2203 n, p (n + 1)) \u2194 \u2203 n, p n", "start": [140, 1], "end": [143, 40], "kind": "commanddeclaration"}, {"full_name": "LT.lt.nat_succ_le", "code": "theorem _root_.LT.lt.nat_succ_le {n m : \u2115} (h : n < m) : succ n \u2264 m", "start": [149, 1], "end": [150, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_lt_succ_of_not_lt", "code": "theorem eq_of_lt_succ_of_not_lt {a b : \u2115} (h1 : a < b + 1) (h2 : \u00aca < b) : a = b", "start": [156, 1], "end": [158, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_le_of_lt_succ", "code": "theorem eq_of_le_of_lt_succ {n m : \u2115} (h\u2081 : n \u2264 m) (h\u2082 : m < n + 1) : m = n", "start": [161, 1], "end": [162, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_pos'", "code": "@[simp]\ntheorem succ_pos' {n : \u2115} : 0 < succ n", "start": [168, 1], "end": [170, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_injective", "code": "theorem succ_injective : Function.Injective Nat.succ", "start": [176, 1], "end": [176, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_ne_succ", "code": "theorem succ_ne_succ {n m : \u2115} : succ n \u2260 succ m \u2194 n \u2260 m", "start": [179, 1], "end": [180, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_succ_ne_one", "code": "theorem succ_succ_ne_one (n : \u2115) : n.succ.succ \u2260 1", "start": [184, 1], "end": [185, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_succ_succ", "code": "@[simp]\ntheorem one_lt_succ_succ (n : \u2115) : 1 < n.succ.succ", "start": [188, 1], "end": [190, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.max_succ_succ", "code": "theorem max_succ_succ {m n : \u2115} : max (succ m) (succ n) = succ (max m n)", "start": [195, 1], "end": [200, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.not_succ_lt_self", "code": "theorem not_succ_lt_self {n : \u2115} : \u00acsucc n < n", "start": [203, 1], "end": [204, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_iff", "code": "theorem lt_succ_iff {m n : \u2115} : m < succ n \u2194 m \u2264 n", "start": [207, 1], "end": [208, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_le_iff", "code": "theorem succ_le_iff {m n : \u2115} : succ m \u2264 n \u2194 m < n", "start": [211, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_iff_add_one_le", "code": "theorem lt_iff_add_one_le {m n : \u2115} : m < n \u2194 m + 1 \u2264 n", "start": [215, 1], "end": [215, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_one_iff", "code": "theorem lt_add_one_iff {a b : \u2115} : a < b + 1 \u2194 a \u2264 b", "start": [219, 1], "end": [220, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_one_add_iff", "code": "theorem lt_one_add_iff {a b : \u2115} : a < 1 + b \u2194 a \u2264 b", "start": [224, 1], "end": [224, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.add_one_le_iff", "code": "theorem add_one_le_iff {a b : \u2115} : a + 1 \u2264 b \u2194 a < b", "start": [229, 1], "end": [230, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.one_add_le_iff", "code": "theorem one_add_le_iff {a b : \u2115} : 1 + a \u2264 b \u2194 a < b", "start": [233, 1], "end": [233, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.of_le_succ", "code": "theorem of_le_succ {n m : \u2115} (H : n \u2264 m.succ) : n \u2264 m \u2228 n = m.succ", "start": [236, 1], "end": [237, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_iff_le_mul_add_pred", "code": "theorem div_le_iff_le_mul_add_pred {m n k : \u2115} (n0 : 0 < n) : m / n \u2264 k \u2194 m \u2264 n * k + (n - 1)", "start": [242, 1], "end": [247, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.two_lt_of_ne", "code": "theorem two_lt_of_ne : \u2200 {n}, n \u2260 0 \u2192 n \u2260 1 \u2192 n \u2260 2 \u2192 2 < n", "start": [250, 1], "end": [255, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.forall_lt_succ", "code": "theorem forall_lt_succ {P : \u2115 \u2192 Prop} {n : \u2115} : (\u2200 m < n + 1, P m) \u2194 (\u2200 m < n, P m) \u2227 P n", "start": [258, 1], "end": [259, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_lt_succ", "code": "theorem exists_lt_succ {P : \u2115 \u2192 Prop} {n : \u2115} : (\u2203 m < n + 1, P m) \u2194 (\u2203 m < n, P m) \u2228 P n", "start": [262, 1], "end": [265, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.add_def", "code": "@[simp]\ntheorem add_def {a b : \u2115} : Nat.add a b = a + b", "start": [273, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_def", "code": "@[simp]\ntheorem mul_def {a b : \u2115} : Nat.mul a b = a * b", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_eq_add_of_le", "code": "theorem exists_eq_add_of_le (h : m \u2264 n) : \u2203 k : \u2115, n = m + k", "start": [283, 1], "end": [284, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_eq_add_of_le'", "code": "theorem exists_eq_add_of_le' (h : m \u2264 n) : \u2203 k : \u2115, n = k + m", "start": [287, 1], "end": [288, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_eq_add_of_lt", "code": "theorem exists_eq_add_of_lt (h : m < n) : \u2203 k : \u2115, n = m + k + 1", "start": [291, 1], "end": [292, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.add_succ_sub_one", "code": "@[simp]\ntheorem add_succ_sub_one (n m : \u2115) : n + succ m - 1 = n + m", "start": [297, 1], "end": [298, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_add_sub_one", "code": "@[simp]\ntheorem succ_add_sub_one (n m : \u2115) : succ n + m - 1 = n + m", "start": [301, 1], "end": [302, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_eq_sub_one", "code": "theorem pred_eq_sub_one (n : \u2115) : pred n = n - 1", "start": [305, 1], "end": [306, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_eq_of_eq_succ", "code": "theorem pred_eq_of_eq_succ {m n : \u2115} (H : m = n.succ) : m.pred = n", "start": [309, 1], "end": [309, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_eq_succ_iff", "code": "@[simp]\ntheorem pred_eq_succ_iff {n m : \u2115} : pred n = succ m \u2194 n = m + 2", "start": [312, 1], "end": [314, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_sub", "code": "theorem pred_sub (n m : \u2115) : pred n - m = pred (n - m)", "start": [317, 1], "end": [318, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_pred_lt", "code": "theorem le_of_pred_lt {m n : \u2115} : pred m < n \u2192 m \u2264 n", "start": [324, 1], "end": [327, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.self_add_sub_one", "code": "theorem self_add_sub_one (n : \u2115) : n + (n - 1) = 2 * n - 1", "start": [330, 1], "end": [334, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_one_add_self", "code": "theorem sub_one_add_self (n : \u2115) : (n - 1) + n = 2 * n - 1", "start": [336, 1], "end": [337, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.self_add_pred", "code": "theorem self_add_pred (n : \u2115) : n + pred n = (2 * n).pred", "start": [339, 1], "end": [340, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_add_self", "code": "theorem pred_add_self (n : \u2115) : pred n + n = (2 * n).pred", "start": [342, 1], "end": [343, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_one_add", "code": "@[simp]\ntheorem pred_one_add (n : \u2115) : pred (1 + n) = n", "start": [345, 1], "end": [347, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.two_mul_ne_two_mul_add_one", "code": "theorem two_mul_ne_two_mul_add_one {n m} : 2 * n \u2260 2 * m + 1", "start": [353, 1], "end": [355, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_ne_mul_left", "code": "theorem mul_ne_mul_left {a b c : \u2115} (ha : 0 < a) : b * a \u2260 c * a \u2194 b \u2260 c", "start": [358, 1], "end": [359, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_ne_mul_right", "code": "theorem mul_ne_mul_right {a b c : \u2115} (ha : 0 < a) : a * b \u2260 a * c \u2194 b \u2260 c", "start": [362, 1], "end": [363, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_right_eq_self_iff", "code": "theorem mul_right_eq_self_iff {a b : \u2115} (ha : 0 < a) : a * b = a \u2194 b = 1", "start": [366, 1], "end": [368, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_left_eq_self_iff", "code": "theorem mul_left_eq_self_iff {a b : \u2115} (hb : 0 < b) : a * b = b \u2194 a = 1", "start": [371, 1], "end": [372, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_iff_lt_or_eq", "code": "theorem lt_succ_iff_lt_or_eq {n i : \u2115} : n < i.succ \u2194 n < i \u2228 n = i", "start": [375, 1], "end": [376, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_mul_iff", "code": "lemma one_lt_mul_iff : 1 < m * n \u2194 0 < m \u2227 0 < n \u2227 (1 < m \u2228 1 < n) := by\n  constructor <;> intro h\n  \u00b7 by_contra h'; push_neg at h'; simp_rw [Nat.le_zero] at h'\n    obtain rfl | rfl | h' := h'\n    \u00b7 simp at h\n    \u00b7 simp at h\n    \u00b7 exact (Nat.mul_le_mul h'.1 h'.2).not_lt h\n  \u00b7 obtain hm | hn := h.2.2\n    \u00b7 exact Nat.mul_lt_mul hm h.2.1 Nat.zero_lt_one\n    \u00b7 exact Nat.mul_lt_mul' h.1 hn h.1", "start": [380, 1], "end": [391, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.rec_zero", "code": "@[simp]\ntheorem rec_zero {C : \u2115 \u2192 Sort u} (h0 : C 0) (h : \u2200 n, C n \u2192 C (n + 1)) :\n    Nat.rec h0 h 0 = h0", "start": [403, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.rec_add_one", "code": "@[simp]\ntheorem rec_add_one {C : \u2115 \u2192 Sort u} (h0 : C 0) (h : \u2200 n, C n \u2192 C (n + 1)) (n : \u2115) :\n    Nat.rec h0 h (n + 1) = h n (Nat.rec h0 h n)", "start": [409, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn", "code": "@[elab_as_elim]\ndef leRecOn {C : \u2115 \u2192 Sort u} {n : \u2115} : \u2200 {m : \u2115}, n \u2264 m \u2192 (\u2200 {k}, C k \u2192 C (k + 1)) \u2192 C n \u2192 C m\n  | 0, H, _, x => Eq.recOn (Nat.eq_zero_of_le_zero H) x\n  | m + 1, H, next, x =>\n    Or.by_cases (of_le_succ H) (fun h : n \u2264 m => next <| leRecOn h (@next) x)\n      fun h : n = m + 1 => Eq.recOn h x", "start": [415, 1], "end": [423, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_self", "code": "theorem leRecOn_self {C : \u2115 \u2192 Sort u} {n} {h : n \u2264 n} {next : \u2200 {k}, C k \u2192 C (k + 1)} (x : C n) :\n    (leRecOn h next x : C n) = x", "start": [426, 1], "end": [431, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_succ", "code": "theorem leRecOn_succ {C : \u2115 \u2192 Sort u} {n m} (h1 : n \u2264 m) {h2 : n \u2264 m + 1} {next} (x : C n) :\n    (leRecOn h2 (@next) x : C (m + 1)) = next (leRecOn h1 (@next) x : C m)", "start": [434, 1], "end": [438, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_succ'", "code": "theorem leRecOn_succ' {C : \u2115 \u2192 Sort u} {n} {h : n \u2264 n + 1} {next : \u2200 {k}, C k \u2192 C (k + 1)}\n    (x : C n) :\n    (leRecOn h next x : C (n + 1)) = next x", "start": [441, 1], "end": [443, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_trans", "code": "theorem leRecOn_trans {C : \u2115 \u2192 Sort u} {n m k} (hnm : n \u2264 m) (hmk : m \u2264 k) {next} (x : C n) :\n    (leRecOn (le_trans hnm hmk) (@next) x : C k) = leRecOn hmk (@next) (leRecOn hnm (@next) x)", "start": [446, 1], "end": [451, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_succ_left", "code": "theorem leRecOn_succ_left {C : \u2115 \u2192 Sort u} {n m} (h1 : n \u2264 m) (h2 : n + 1 \u2264 m)\n    {next : \u2200 {k}, C k \u2192 C (k + 1)} (x : C n) :\n    (leRecOn h2 next (next x) : C m) = (leRecOn h1 next x : C m)", "start": [454, 1], "end": [457, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_injective", "code": "theorem leRecOn_injective {C : \u2115 \u2192 Sort u} {n m} (hnm : n \u2264 m) (next : \u2200 {k}, C k \u2192 C (k + 1))\n    (Hnext : \u2200 n, Function.Injective (@next n)) :\n    Function.Injective (@leRecOn C n m hnm next)", "start": [460, 1], "end": [469, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn_surjective", "code": "theorem leRecOn_surjective {C : \u2115 \u2192 Sort u} {n m} (hnm : n \u2264 m) (next : \u2200 {k}, C k \u2192 C (k + 1))\n    (Hnext : \u2200 n, Function.Surjective (@next n)) :\n    Function.Surjective (@leRecOn C n m hnm next)", "start": [472, 1], "end": [484, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRec'", "code": "@[elab_as_elim]\nprotected def strongRec' {p : \u2115 \u2192 Sort u} (H : \u2200 n, (\u2200 m, m < n \u2192 p m) \u2192 p n) : \u2200 n : \u2115, p n\n  | n => H n fun m _ => Nat.strongRec' H m", "start": [487, 1], "end": [490, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRecOn'", "code": "@[elab_as_elim]\ndef strongRecOn' {P : \u2115 \u2192 Sort*} (n : \u2115) (h : \u2200 n, (\u2200 m, m < n \u2192 P m) \u2192 P n) : P n :=\n  Nat.strongRec' h n", "start": [493, 1], "end": [496, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.strongRecOn'_beta", "code": "theorem strongRecOn'_beta {P : \u2115 \u2192 Sort*} {h} {n : \u2115} :\n    (strongRecOn' n h : P n) = h n fun m _ => (strongRecOn' m h : P m)", "start": [499, 1], "end": [502, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.le_induction", "code": "@[elab_as_elim]\ntheorem le_induction {m} {P : \u2200 (n : Nat) (_ : m \u2264 n), Prop} (base : P m le_rfl)\n    (succ : \u2200 (n : Nat) (hn : m \u2264 n), P n hn \u2192 P (n + 1) (hn.trans <| Nat.le_succ _)) :\n    \u2200 (n : Nat) (hn : m \u2264 n), P n hn", "start": [505, 1], "end": [515, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction", "code": "@[elab_as_elim]\ndef decreasingInduction {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {m n : \u2115} (mn : m \u2264 n)\n    (hP : P n) : P m :=\n  leRecOn mn (fun {k} ih hsk => ih <| h k hsk) (fun h => h) hP", "start": [518, 1], "end": [524, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction_self", "code": "@[simp]\ntheorem decreasingInduction_self {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {n : \u2115} (nn : n \u2264 n)\n    (hP : P n) :\n    (decreasingInduction h nn hP : P n) = hP", "start": [527, 1], "end": [532, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction_succ", "code": "theorem decreasingInduction_succ {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {m n : \u2115} (mn : m \u2264 n)\n    (msn : m \u2264 n + 1) (hP : P (n + 1)) :\n    (decreasingInduction h msn hP : P m) = decreasingInduction h mn (h n hP)", "start": [535, 1], "end": [539, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction_succ'", "code": "@[simp]\ntheorem decreasingInduction_succ' {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {m : \u2115}\n    (msm : m \u2264 m + 1) (hP : P (m + 1)) : (decreasingInduction h msm hP : P m) = h m hP", "start": [542, 1], "end": [546, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction_trans", "code": "theorem decreasingInduction_trans {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {m n k : \u2115}\n    (mn : m \u2264 n) (nk : n \u2264 k) (hP : P k) :\n    (decreasingInduction h (le_trans mn nk) hP : P m) =\n    decreasingInduction h mn (decreasingInduction h nk hP)", "start": [549, 1], "end": [555, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction_succ_left", "code": "theorem decreasingInduction_succ_left {P : \u2115 \u2192 Sort*} (h : \u2200 n, P (n + 1) \u2192 P n) {m n : \u2115}\n    (smn : m + 1 \u2264 n) (mn : m \u2264 n) (hP : P n) :\n    (decreasingInduction h mn hP : P m) = h m (decreasingInduction h smn hP)", "start": [558, 1], "end": [563, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.strongSubRecursion", "code": "def strongSubRecursion {P : \u2115 \u2192 \u2115 \u2192 Sort*} (H : \u2200 a b, (\u2200 x y, x < a \u2192 y < b \u2192 P x y) \u2192 P a b) :\n    \u2200 n m : \u2115, P n m\n  | n, m => H n m fun x y _ _ => strongSubRecursion H x y", "start": [566, 1], "end": [572, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.pincerRecursion", "code": "def pincerRecursion {P : \u2115 \u2192 \u2115 \u2192 Sort*} (Ha0 : \u2200 a : \u2115, P a 0) (H0b : \u2200 b : \u2115, P 0 b)\n    (H : \u2200 x y : \u2115, P x y.succ \u2192 P x.succ y \u2192 P x.succ y.succ) : \u2200 n m : \u2115, P n m\n  | a, 0 => Ha0 a\n  | 0, b => H0b b\n  | Nat.succ a, Nat.succ b => H _ _ (pincerRecursion Ha0 H0b H _ _) (pincerRecursion Ha0 H0b H _ _)\ntermination_by pincerRecursion Ha0 Hab H n m => n + m", "start": [580, 1], "end": [590, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.leRecOn'", "code": "@[elab_as_elim]\ndef leRecOn' {C : \u2115 \u2192 Sort*} {n : \u2115} :\n    \u2200 {m : \u2115}, n \u2264 m \u2192 (\u2200 \u2983k\u2984, n \u2264 k \u2192 C k \u2192 C (k + 1)) \u2192 C n \u2192 C m\n  | 0, H, _, x => Eq.recOn (Nat.eq_zero_of_le_zero H) x\n  | m + 1, H, next, x =>\n    Or.by_cases (of_le_succ H) (fun h : n \u2264 m => next h <| leRecOn' h next x)\n      fun h : n = m + 1 => Eq.recOn h x", "start": [598, 1], "end": [606, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasingInduction'", "code": "@[elab_as_elim]\ndef decreasingInduction' {P : \u2115 \u2192 Sort*} {m n : \u2115} (h : \u2200 k < n, m \u2264 k \u2192 P (k + 1) \u2192 P k)\n    (mn : m \u2264 n) (hP : P n) :\n    P m := by\n  revert h hP\n  refine' leRecOn' mn _ _\n  \u00b7 intro n mn ih h hP\n    apply ih\n    \u00b7 exact fun k hk => h k (Nat.lt.step hk)\n    \u00b7 exact h n (lt_succ_self n) mn hP\n  \u00b7 intro _ hP\n    exact hP", "start": [609, 1], "end": [622, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_self'", "code": "theorem div_lt_self' (n b : \u2115) : (n + 1) / (b + 2) < n + 1", "start": [629, 1], "end": [631, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.le_div_iff_mul_le'", "code": "theorem le_div_iff_mul_le' {x y : \u2115} {k : \u2115} (k0 : 0 < k) : x \u2264 y / k \u2194 x * k \u2264 y", "start": [634, 1], "end": [635, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_iff_lt_mul'", "code": "theorem div_lt_iff_lt_mul' {x y : \u2115} {k : \u2115} (k0 : 0 < k) : x / k < y \u2194 x < y * k", "start": [638, 1], "end": [639, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_div_iff", "code": "theorem one_le_div_iff {a b : \u2115} (hb : 0 < b) : 1 \u2264 a / b \u2194 b \u2264 a", "start": [642, 1], "end": [643, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_one_iff", "code": "theorem div_lt_one_iff {a b : \u2115} (hb : 0 < b) : a / b < 1 \u2194 a < b", "start": [646, 1], "end": [647, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_div_right", "code": "protected theorem div_le_div_right {n m : \u2115} (h : n \u2264 m) {k : \u2115} : n / k \u2264 m / k", "start": [650, 1], "end": [652, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_div_lt_div", "code": "theorem lt_of_div_lt_div {m n k : \u2115} : m / k < n / k \u2192 m < n", "start": [655, 1], "end": [656, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.div_pos", "code": "protected theorem div_pos {a b : \u2115} (hba : b \u2264 a) (hb : 0 < b) : 0 < a / b", "start": [659, 1], "end": [666, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_mul_of_div_lt", "code": "theorem lt_mul_of_div_lt {a b c : \u2115} (h : a / c < b) (w : 0 < c) : a < b * c", "start": [669, 1], "end": [670, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_le_mul_div_assoc", "code": "theorem mul_div_le_mul_div_assoc (a b c : \u2115) : a * (b / c) \u2264 a * b / c", "start": [673, 1], "end": [677, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_mul_of_div_eq_right", "code": "protected theorem eq_mul_of_div_eq_right {a b c : \u2115} (H1 : b \u2223 a) (H2 : a / b = c) : a = b * c", "start": [680, 1], "end": [681, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_iff_eq_mul_right", "code": "protected theorem div_eq_iff_eq_mul_right {a b c : \u2115} (H : 0 < b) (H' : b \u2223 a) :\n    a / b = c \u2194 a = b * c", "start": [684, 1], "end": [686, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_iff_eq_mul_left", "code": "protected theorem div_eq_iff_eq_mul_left {a b c : \u2115} (H : 0 < b) (H' : b \u2223 a) :\n    a / b = c \u2194 a = c * b", "start": [689, 1], "end": [692, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_mul_of_div_eq_left", "code": "protected theorem eq_mul_of_div_eq_left {a b c : \u2115} (H1 : b \u2223 a) (H2 : a / b = c) : a = c * b", "start": [695, 1], "end": [696, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_cancel_left'", "code": "protected theorem mul_div_cancel_left' {a b : \u2115} (Hd : a \u2223 b) : a * (b / a) = b", "start": [699, 1], "end": [700, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_div_mul_add", "code": "theorem lt_div_mul_add {a b : \u2115} (hb : 0 < b) : a < a / b * b + b", "start": [706, 1], "end": [708, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.div_left_inj", "code": "@[simp]\nprotected theorem div_left_inj {a b d : \u2115} (hda : d \u2223 a) (hdb : d \u2223 b) : a / d = b / d \u2194 a = b", "start": [711, 1], "end": [714, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_eq_iff_lt", "code": "theorem mod_eq_iff_lt {a b : \u2115} (h : b \u2260 0) : a % b = a \u2194 a < b", "start": [720, 1], "end": [723, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_succ_eq_iff_lt", "code": "@[simp]\ntheorem mod_succ_eq_iff_lt {a b : \u2115} : a % b.succ = a \u2194 a < b.succ", "start": [726, 1], "end": [728, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_add_div'", "code": "theorem mod_add_div' (m k : \u2115) : m % k + m / k * k = m", "start": [733, 1], "end": [735, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.div_add_mod'", "code": "theorem div_add_mod' (m k : \u2115) : m / k * k + m % k = m", "start": [738, 1], "end": [740, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mod_unique", "code": "protected theorem div_mod_unique {n k m d : \u2115} (h : 0 < k) :\n    n / k = d \u2227 n % k = m \u2194 m + k * d = n \u2227 m < k", "start": [743, 1], "end": [749, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_left", "code": "protected theorem dvd_add_left {k m n : \u2115} (h : k \u2223 n) : k \u2223 m + n \u2194 k \u2223 m", "start": [752, 1], "end": [753, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_add_right", "code": "protected theorem dvd_add_right {k m n : \u2115} (h : k \u2223 m) : k \u2223 m + n \u2194 k \u2223 n", "start": [756, 1], "end": [757, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_mul_iff_left", "code": "protected theorem mul_dvd_mul_iff_left {a b c : \u2115} (ha : 0 < a) : a * b \u2223 a * c \u2194 b \u2223 c", "start": [760, 1], "end": [761, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_mul_iff_right", "code": "protected theorem mul_dvd_mul_iff_right {a b c : \u2115} (hc : 0 < c) : a * c \u2223 b * c \u2194 a \u2223 b", "start": [764, 1], "end": [765, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mod_of_dvd", "code": "@[simp]\ntheorem mod_mod_of_dvd (n : Nat) {m k : Nat} (h : m \u2223 k) : n % k % m = n % m", "start": [768, 1], "end": [774, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_eq_add_mod_right", "code": "theorem add_mod_eq_add_mod_right {m n k : \u2115} (i : \u2115) (H : m % n = k % n) :\n    (m + i) % n = (k + i) % n", "start": [783, 1], "end": [785, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_eq_add_mod_left", "code": "theorem add_mod_eq_add_mod_left {m n k : \u2115} (i : \u2115) (H : m % n = k % n) :\n    (i + m) % n = (i + k) % n", "start": [788, 1], "end": [790, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_dvd_of_dvd_div", "code": "theorem mul_dvd_of_dvd_div {a b c : \u2115} (hab : c \u2223 b) (h : a \u2223 b / c) : c * a \u2223 b", "start": [796, 1], "end": [801, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_dvd_of_div_eq_one", "code": "theorem eq_of_dvd_of_div_eq_one {a b : \u2115} (w : a \u2223 b) (h : b / a = 1) : a = b", "start": [804, 1], "end": [805, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_dvd_of_div_eq_zero", "code": "theorem eq_zero_of_dvd_of_div_eq_zero {a b : \u2115} (w : a \u2223 b) (h : b / a = 0) : b = 0", "start": [808, 1], "end": [809, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_div_left", "code": "theorem div_le_div_left {a b c : \u2115} (h\u2081 : c \u2264 b) (h\u2082 : 0 < c) : a / b \u2264 a / c", "start": [812, 1], "end": [813, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_iff_le_pred", "code": "theorem lt_iff_le_pred : \u2200 {m n : \u2115}, 0 < n \u2192 (m < n \u2194 m \u2264 n - 1)", "start": [816, 1], "end": [817, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_mul_div_succ", "code": "theorem lt_mul_div_succ (m : \u2115) {n : \u2115} (n0 : 0 < n) : m < n * (m / n + 1)", "start": [823, 1], "end": [825, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_add_mod", "code": "theorem mul_add_mod (a b c : \u2115) : (a * b + c) % b = c % b", "start": [828, 1], "end": [828, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_add_mod_of_lt", "code": "theorem mul_add_mod_of_lt {a b c : \u2115} (h : c < b) : (a * b + c) % b = c", "start": [831, 1], "end": [832, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_eq_self_iff", "code": "theorem pred_eq_self_iff {n : \u2115} : n.pred = n \u2194 n = 0", "start": [835, 1], "end": [836, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.find_eq_iff", "code": "theorem find_eq_iff (h : \u2203 n : \u2115, p n) : Nat.find h = m \u2194 p m \u2227 \u2200 n < m, \u00acp n", "start": [846, 1], "end": [851, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.find_lt_iff", "code": "@[simp]\ntheorem find_lt_iff (h : \u2203 n : \u2115, p n) (n : \u2115) : Nat.find h < n \u2194 \u2203 m < n, p m", "start": [854, 1], "end": [857, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.find_le_iff", "code": "@[simp]\ntheorem find_le_iff (h : \u2203 n : \u2115, p n) (n : \u2115) : Nat.find h \u2264 n \u2194 \u2203 m \u2264 n, p m", "start": [860, 1], "end": [862, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.le_find_iff", "code": "@[simp]\ntheorem le_find_iff (h : \u2203 n : \u2115, p n) (n : \u2115) : n \u2264 Nat.find h \u2194 \u2200 m < n, \u00acp m", "start": [865, 1], "end": [867, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_find_iff", "code": "@[simp]\ntheorem lt_find_iff (h : \u2203 n : \u2115, p n) (n : \u2115) : n < Nat.find h \u2194 \u2200 m \u2264 n, \u00acp m", "start": [870, 1], "end": [872, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.find_eq_zero", "code": "@[simp]\ntheorem find_eq_zero (h : \u2203 n : \u2115, p n) : Nat.find h = 0 \u2194 p 0", "start": [875, 1], "end": [876, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.find_mono", "code": "theorem find_mono (h : \u2200 n, q n \u2192 p n) {hp : \u2203 n, p n} {hq : \u2203 n, q n} :\n    Nat.find hp \u2264 Nat.find hq", "start": [879, 1], "end": [881, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.find_le", "code": "theorem find_le {h : \u2203 n, p n} (hn : p n) : Nat.find h \u2264 n", "start": [884, 1], "end": [885, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.find_comp_succ", "code": "theorem find_comp_succ (h\u2081 : \u2203 n, p n) (h\u2082 : \u2203 n, p (n + 1)) (h0 : \u00acp 0) :\n    Nat.find h\u2081 = Nat.find h\u2082 + 1", "start": [888, 1], "end": [892, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest", "code": "protected def findGreatest (P : \u2115 \u2192 Prop) [DecidablePred P] : \u2115 \u2192 \u2115\n  | 0 => 0\n  | n + 1 => if P (n + 1) then n + 1 else Nat.findGreatest P n", "start": [902, 1], "end": [906, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_zero", "code": "@[simp]\ntheorem findGreatest_zero : Nat.findGreatest P 0 = 0", "start": [911, 1], "end": [913, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_succ", "code": "theorem findGreatest_succ (n : \u2115) :\n    Nat.findGreatest P (n + 1) = if P (n + 1) then n + 1 else Nat.findGreatest P n", "start": [916, 1], "end": [918, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_eq", "code": "@[simp]\ntheorem findGreatest_eq : \u2200 {b}, P b \u2192 Nat.findGreatest P b = b", "start": [921, 1], "end": [924, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_of_not", "code": "@[simp]\ntheorem findGreatest_of_not (h : \u00acP (b + 1)) :\n    Nat.findGreatest P (b + 1) = Nat.findGreatest P b", "start": [927, 1], "end": [930, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableBallLT", "code": "instance decidableBallLT :\n  \u2200 (n : Nat) (P : \u2200 k, k < n \u2192 Prop) [\u2200 n h, Decidable (P n h)], Decidable (\u2200 n h, P n h)\n| 0, _, _ => isTrue fun _ => (by cases \u00b7)\n| (n+1), P, H =>\n  match decidableBallLT n (P \u00b7 <| lt_succ_of_lt \u00b7) with\n  | isFalse h => isFalse (h fun _ _ => \u00b7 _ _)\n  | isTrue h =>\n    match H n Nat.le.refl with\n    | isFalse p => isFalse (p <| \u00b7 _ _)\n    | isTrue p => isTrue fun _ h' => (Nat.le_of_lt_succ h').lt_or_eq_dec.elim (h _) (\u00b7 \u25b8 p)", "start": [938, 1], "end": [947, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableForallFin", "code": "instance decidableForallFin {n : \u2115} (P : Fin n \u2192 Prop) [DecidablePred P] :\n    Decidable (\u2200 i, P i) :=\n  decidable_of_iff (\u2200 k h, P \u27e8k, h\u27e9) \u27e8fun a \u27e8k, h\u27e9 => a k h, fun a k h => a \u27e8k, h\u27e9\u27e9", "start": [955, 1], "end": [957, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableBallLe", "code": "instance decidableBallLe (n : \u2115) (P : \u2200 k \u2264 n, Prop) [\u2200 n h, Decidable (P n h)] :\n    Decidable (\u2200 n h, P n h) :=\n  decidable_of_iff (\u2200 (k) (h : k < succ n), P k (le_of_lt_succ h))\n    \u27e8fun a k h => a k (lt_succ_of_le h), fun a k _ => a k _\u27e9", "start": [960, 1], "end": [963, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableExistsLT", "code": "instance decidableExistsLT {P : \u2115 \u2192 Prop} [h : DecidablePred P] :\n    DecidablePred fun n => \u2203 m : \u2115, m < n \u2227 P m\n  | 0 => isFalse (by simp)\n  | n + 1 =>\n    @decidable_of_decidable_of_iff _ _ (@instDecidableOr _ _ (decidableExistsLT n) (h n))\n      (by simp only [lt_succ_iff_lt_or_eq, or_and_right, exists_or, exists_eq_left]; apply Iff.refl)", "start": [966, 1], "end": [971, 101], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableExistsLe", "code": "instance decidableExistsLe {P : \u2115 \u2192 Prop} [DecidablePred P] :\n    DecidablePred fun n => \u2203 m : \u2115, m \u2264 n \u2227 P m :=\n  fun n => decidable_of_iff (\u2203 m, m < n + 1 \u2227 P m)\n    (exists_congr fun _ => and_congr_left' lt_succ_iff)", "start": [974, 1], "end": [977, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Have.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Data/Array/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.optBinderIdent", "code": "def optBinderIdent : Parser := leading_parser\n  (ppSpace >> Term.binderIdent) <|> withResetCache hygieneInfo", "start": [19, 1], "end": [23, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.optBinderIdent.name", "code": "def optBinderIdent.name (id : TSyntax ``optBinderIdent) : Name :=\n  if id.raw[0].isIdent then id.raw[0].getId else HygieneInfo.mkIdent \u27e8id.raw[0]\u27e9 `this |>.getId", "start": [25, 1], "end": [27, 96], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.haveIdLhs'", "code": "def haveIdLhs' : Parser :=\n  optBinderIdent >> many (ppSpace >>\n    checkColGt \"expected to be indented\" >> letIdBinder) >> optType", "start": [29, 1], "end": [45, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.haveLetCore", "code": "def haveLetCore (goal : MVarId) (name : TSyntax ``optBinderIdent)\n    (bis : Array (TSyntax ``letIdBinder))\n    (t : Option Term) (keepTerm : Bool) : TermElabM (MVarId \u00d7 MVarId) :=\n  let declFn := if keepTerm then MVarId.define else MVarId.assert\n  goal.withContext do\n    let n := optBinderIdent.name name\n    let elabBinders k := if bis.isEmpty then k #[] else elabBinders bis k\n    let (goal1, t, p) \u2190 elabBinders fun es \u21a6 do\n      let t \u2190 match t with\n      | none => mkFreshTypeMVar\n      | some stx => withRef stx do\n          let e \u2190 Term.elabTerm stx none\n          Term.synthesizeSyntheticMVars false\n          instantiateMVars e\n      let p \u2190 mkFreshExprMVar t MetavarKind.syntheticOpaque n\n      pure (p.mvarId!, \u2190 mkForallFVars es t, \u2190 mkLambdaFVars es p)\n    let (fvar, goal2) \u2190 (\u2190 declFn goal n t p).intro1P\n    goal2.withContext do\n      Term.addTermInfo' (isBinder := true) name.raw[0] (mkFVar fvar)\n    pure (goal1, goal2)", "start": [52, 1], "end": [78, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/TermCongr.lean", "imports": ["Mathlib/Lean/Meta/CongrTheorems.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Basic.lean", "Mathlib/Lean/Expr/Basic.lean", "Mathlib/Tactic/Congr!.lean"], "premises": [{"full_name": "Mathlib.Tactic.TermCongr.congrHoleForLhsKey", "code": "private def congrHoleForLhsKey : Name := decl_name%", "start": [89, 1], "end": [91, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.congrHoleIndex", "code": "private def congrHoleIndex : Name := decl_name%", "start": [93, 1], "end": [96, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.cHole", "code": "@[reducible, nolint unusedArguments]\ndef cHole {\u03b1 : Sort u} (val : \u03b1) {p : Prop} (_pf : p) : \u03b1 := val", "start": [98, 1], "end": [109, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.unexpandCHole", "code": "@[app_unexpander cHole] def unexpandCHole : Lean.PrettyPrinter.Unexpander\n  | `($_ $val $_) => pure val\n  | _ => throw ()", "start": [111, 1], "end": [115, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkCHole", "code": "def mkCHole (forLhs : Bool) (val pf : Expr) : MetaM Expr := do\n  discard <| mkFreshTypeMVar\n  let d : MData := KVMap.empty\n    |>.insert congrHoleForLhsKey forLhs\n    |>.insert congrHoleIndex (\u2190 getMCtx).mvarCounter\n  return Expr.mdata d <| \u2190 mkAppM ``cHole #[val, pf]", "start": [117, 1], "end": [127, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.cHole?", "code": "def cHole? (e : Expr) (mvarCounterSaved? : Option Nat := none) : Option (Bool \u00d7 Expr \u00d7 Expr) := do\n  match e with\n  | .mdata d e' =>\n    let forLhs : Bool \u2190 d.get? congrHoleForLhsKey\n    let mvarCounter : Nat \u2190 d.get? congrHoleIndex\n    if let some mvarCounterSaved := mvarCounterSaved? then\n      guard <| mvarCounterSaved \u2264 mvarCounter\n    let #[_, val, _, pf] := e'.getAppArgs | failure\n    return (forLhs, val, pf)\n  | _ => none", "start": [129, 1], "end": [140, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.hasCHole", "code": "def hasCHole (mvarCounterSaved : Nat) (e : Expr) : Option Expr :=\n  e.find? fun e' => (cHole? e' mvarCounterSaved).isSome", "start": [142, 1], "end": [144, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.removeCHoles", "code": "def removeCHoles (e : Expr) : Expr :=\n  e.replace fun e' => if let some (_, val, _) := cHole? e' then val else none", "start": [146, 1], "end": [148, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.elabCHole", "code": "def elabCHole (h : Syntax) (forLhs : Bool) (expectedType? : Option Expr) : Term.TermElabM Expr := do\n  let pf \u2190 Term.elabTerm h none\n  let pfTy \u2190 inferType pf\n  unless \u2190 isDefEq (\u2190 inferType pfTy) (.sort .zero) do\n    throwError \"Hole has type{indentD pfTy}\\nbut is expected to be a Prop\"\n  if let some (_, lhs, _, rhs) := (\u2190 whnf pfTy).sides? then\n    let val := if forLhs then lhs else rhs\n    if let some expectedType := expectedType? then\n      discard <| isDefEq expectedType (\u2190 inferType val)\n    mkCHole forLhs val pf\n  else\n    mkCHole forLhs (\u2190 mkFreshExprMVar expectedType?) pf", "start": [150, 1], "end": [167, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.elabCHoleExpand", "code": "@[term_elab cHoleExpand, inherit_doc cHoleExpand]\ndef elabCHoleExpand : Term.TermElab := fun stx expectedType? =>\n  match stx with\n  | `(cHole% lhs $h) => elabCHole h true expectedType?\n  | `(cHole% rhs $h) => elabCHole h false expectedType?\n  | _ => throwUnsupportedSyntax", "start": [174, 1], "end": [179, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.processAntiquot", "code": "def processAntiquot (t : Term) (expand : Term \u2192 Term.TermElabM Term) : Term.TermElabM Term := do\n  let t' \u2190 t.raw.replaceM fun s => do\n    if s.isAntiquots then\n      let ks := s.antiquotKinds\n      unless ks.any (fun (k, _) => k == `term) do\n        throwErrorAt s \"Expecting term\"\n      let h : Term := \u27e8s.getCanonicalAntiquot.getAntiquotTerm\u27e9\n      expand h\n    else\n      pure none\n  return \u27e8t'\u27e9", "start": [181, 1], "end": [192, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.elaboratePattern", "code": "def elaboratePattern (t : Term) (expectedType? : Option Expr) (forLhs : Bool) :\n    Term.TermElabM Expr :=\n  Term.withoutErrToSorry do\n    let t' \u2190 processAntiquot t (fun h => if forLhs then `(cHole% lhs $h) else `(cHole% rhs $h))\n    Term.elabTermEnsuringType t' expectedType?", "start": [194, 1], "end": [201, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkEqForExpectedType", "code": "def mkEqForExpectedType (expectedType? : Option Expr) : MetaM Expr := do\n  let u \u2190 mkFreshLevelMVar\n  let ty \u2190 mkFreshExprMVar (mkSort u)\n  let eq := mkApp3 (mkConst ``Eq [u]) ty (\u2190 mkFreshExprMVar ty) (\u2190 mkFreshExprMVar ty)\n  if let some expectedType := expectedType? then\n    unless \u2190 isDefEq expectedType eq do\n      throwError m!\"Type{indentD expectedType}\\nis expected to be an equality.\"\n  return eq", "start": [205, 1], "end": [214, 12], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkHEqForExpectedType", "code": "def mkHEqForExpectedType (expectedType? : Option Expr) : MetaM Expr := do\n  let u \u2190 mkFreshLevelMVar\n  let tya \u2190 mkFreshExprMVar (mkSort u)\n  let tyb \u2190 mkFreshExprMVar (mkSort u)\n  let heq := mkApp4 (mkConst ``HEq [u]) tya (\u2190 mkFreshExprMVar tya) tyb (\u2190 mkFreshExprMVar tyb)\n  if let some expectedType := expectedType? then\n    unless \u2190 isDefEq expectedType heq do\n      throwError m!\"Type{indentD expectedType}\\nis expected to be a `HEq`.\"\n  return heq", "start": [216, 1], "end": [226, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkIffForExpectedType", "code": "def mkIffForExpectedType (expectedType? : Option Expr) : MetaM Expr := do\n  let a \u2190 mkFreshExprMVar (Expr.sort .zero)\n  let b \u2190 mkFreshExprMVar (Expr.sort .zero)\n  let iff := mkApp2 (Expr.const `Iff []) a b\n  if let some expectedType := expectedType? then\n    unless \u2190 isDefEq expectedType iff do\n      throwError m!\"Type{indentD expectedType}\\nis expected to be an `Iff`.\"\n  return iff", "start": [228, 1], "end": [237, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.ensureIff", "code": "def ensureIff (pf : Expr) : MetaM Expr := do\n  discard <| mkIffForExpectedType (\u2190 inferType pf)\n  return pf", "start": [239, 1], "end": [242, 12], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrType", "code": "inductive CongrType\n  | eq | heq", "start": [244, 1], "end": [246, 13], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult", "code": "structure CongrResult where\n  \n  lhs : Expr\n  \n  rhs : Expr\n  \n  (pf? : Option (CongrType \u2192 MetaM Expr))", "start": [248, 1], "end": [274, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.isRfl", "code": "def CongrResult.isRfl (res : CongrResult) : Bool := res.pf?.isNone", "start": [276, 1], "end": [278, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.eq", "code": "def CongrResult.eq (res : CongrResult) : MetaM Expr := do\n  unless \u2190 isDefEq (\u2190 inferType res.lhs) (\u2190 inferType res.rhs) do\n    throwError \"Expecting{indentD res.lhs}\\nand{indentD res.rhs}\\n{\"\"\n      }to have definitionally equal types.\"\n  match res.pf? with\n  | some pf => pf .eq\n  | none => mkEqRefl res.lhs", "start": [280, 1], "end": [289, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.heq", "code": "def CongrResult.heq (res : CongrResult) : MetaM Expr := do\n  match res.pf? with\n  | some pf => pf .heq\n  | none => mkHEqRefl res.lhs", "start": [291, 1], "end": [296, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.iff", "code": "def CongrResult.iff (res : CongrResult) : MetaM Expr := do\n  unless \u2190 Meta.isProp res.lhs do\n    throwError \"Expecting{indentD res.lhs}\\nto be a proposition.\"\n  return mkApp3 (.const ``iff_of_eq []) res.lhs res.rhs (\u2190 res.eq)", "start": [298, 1], "end": [302, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.trans", "code": "def CongrResult.trans (res1 res2 : CongrResult) : CongrResult where\n  lhs := res1.lhs\n  rhs := res2.rhs\n  pf? :=\n    if res1.isRfl then\n      res2.pf?\n    else if res2.isRfl then\n      res1.pf?\n    else\n      some fun\n        | .eq => do mkEqTrans (\u2190 res1.eq) (\u2190 res2.eq)\n        | .heq => do mkHEqTrans (\u2190 res1.heq) (\u2190 res2.heq)", "start": [304, 1], "end": [318, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.mk'", "code": "def CongrResult.mk' (lhs rhs : Expr) (pf : Expr) : CongrResult where\n  lhs := lhs\n  rhs := rhs\n  pf? := some fun\n    | .eq => do ensureSidesDefeq (\u2190 toEqPf)\n    | .heq => do ensureSidesDefeq (\u2190 toHEqPf)\nwhere\n  \n  toEqPf : MetaM Expr := do\n    let ty \u2190 whnf (\u2190 inferType pf)\n    if let some .. := ty.iff? then\n      mkPropExt pf\n    else if let some .. := ty.eq? then\n      return pf\n    else if let some (lhsTy, _, rhsTy, _) := ty.heq? then\n      unless \u2190 isDefEq lhsTy rhsTy do\n        throwError \"Cannot turn HEq proof into an equality proof. Has type{indentD ty}\"\n      mkAppM ``eq_of_heq #[pf]\n    else if \u2190 Meta.isProp lhs then\n      mkPropExt (\u2190 ensureIff pf)\n    else\n      discard <| mkEqForExpectedType (\u2190 inferType pf)\n      return pf\n  \n  toHEqPf : MetaM Expr := do\n    let ty \u2190 whnf (\u2190 inferType pf)\n    if let some .. := ty.iff? then\n      mkAppM ``heq_of_eq #[\u2190 mkPropExt pf]\n    else if let some .. := ty.eq? then\n      mkAppM ``heq_of_eq #[pf]\n    else if let some .. := ty.heq? then\n      return pf\n    else if \u2190 withNewMCtxDepth <| isDefEq (\u2190 inferType lhs) (\u2190 inferType rhs) then\n      mkAppM ``heq_of_eq #[\u2190 toEqPf]\n    else\n      discard <| mkHEqForExpectedType (\u2190 inferType pf)\n      return pf\n  \n  ensureSidesDefeq (pf : Expr) : MetaM Expr := do\n    let pfTy \u2190 inferType pf\n    let some (_, lhs', _, rhs') := (\u2190 whnf pfTy).sides?\n      | panic! \"Unexpectedly did not generate an eq or heq\"\n    unless \u2190 isDefEq lhs lhs' do\n      throwError \"Congruence hole has type{indentD pfTy}\\n{\"\"\n        }but its left-hand side is not definitionally equal to the expected value{indentD lhs}\"\n    unless \u2190 isDefEq rhs rhs' do\n      throwError \"Congruence hole has type{indentD pfTy}\\n{\"\"\n        }but its right-hand side is not definitionally equal to the expected value{indentD rhs}\"\n    return pf", "start": [320, 1], "end": [377, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.defeq", "code": "def CongrResult.defeq (res : CongrResult) : MetaM CongrResult := do\n  if res.isRfl then\n    return res\n  else\n    unless \u2190 isDefEq res.lhs res.rhs do\n      throwError \"Cannot generate congruence because we need{indentD res.lhs}\\n{\"\"\n        }to be definitionally equal to{indentD res.rhs}\"\n    discard <| res.eq\n    return {res with pf? := none}", "start": [379, 1], "end": [390, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.mkDefault", "code": "def CongrResult.mkDefault (lhs rhs : Expr) : MetaM CongrResult := do\n  if \u2190 isDefEq lhs rhs then\n    return {lhs, rhs, pf? := none}\n  else if let some pf \u2190 (observing? <| mkAppM ``Subsingleton.elim #[lhs, rhs]) then\n    return CongrResult.mk' lhs rhs pf\n  else if let some pf \u2190 (observing? <| mkAppM ``proof_irrel_heq #[lhs, rhs]) then\n    return CongrResult.mk' lhs rhs pf\n  throwError \"Could not generate congruence between{indentD lhs}\\nand{indentD rhs}\"", "start": [392, 1], "end": [408, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.CongrResult.mkDefault'", "code": "def CongrResult.mkDefault' (mvarCounterSaved : Nat) (lhs rhs : Expr) : MetaM CongrResult := do\n  if let some h := hasCHole mvarCounterSaved lhs then\n    throwError \"Left-hand side{indentD lhs}\\nstill has a congruence hole{indentD h}\"\n  if let some h := hasCHole mvarCounterSaved rhs then\n    throwError \"Right-hand side{indentD rhs}\\nstill has a congruence hole{indentD h}\"\n  CongrResult.mkDefault lhs rhs", "start": [410, 1], "end": [416, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.throwCongrEx", "code": "def throwCongrEx (lhs rhs : Expr) (msg : MessageData) : MetaM \u03b1 := do\n  throwError \"congr(...) failed with left-hand side{indentD lhs}\\n{\"\"\n    }and right-hand side {indentD rhs}\\n{msg}\"", "start": [418, 1], "end": [421, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkCongrOfCHole?", "code": "def mkCongrOfCHole? (mvarCounterSaved : Nat) (lhs rhs : Expr) : MetaM (Option CongrResult) := do\n  match cHole? lhs mvarCounterSaved, cHole? rhs mvarCounterSaved with\n  | some (isLhs1, val1, pf1), some (isLhs2, val2, pf2) =>\n    trace[Elab.congr] \"mkCongrOfCHole, both holes\"\n    unless isLhs1 == true do\n      throwCongrEx lhs rhs \"A RHS congruence hole leaked into the LHS\"\n    unless isLhs2 == false do\n      throwCongrEx lhs rhs \"A LHS congruence hole leaked into the RHS\"\n    unless \u2190 isDefEq (\u2190 inferType pf1) (\u2190 inferType pf2) do\n      throwCongrEx lhs rhs \"Elaborated types of congruence holes are not defeq.\"\n    if let some (_, lhsVal, _, rhsVal) := (\u2190 whnf <| \u2190 inferType pf1).sides? then\n      unless \u2190 isDefEq val1 lhsVal do\n        throwError \"Left-hand side of congruence hole is{indentD lhsVal}\\n{\"\"\n          }but is expected to be{indentD val1}\"\n      unless \u2190 isDefEq val2 rhsVal do\n        throwError \"Right-hand side of congruence hole is{indentD rhsVal}\\n{\"\"\n          }but is expected to be{indentD val2}\"\n    return some <| CongrResult.mk' val1 val2 pf1\n  | some .., none =>\n    throwCongrEx lhs rhs \"Right-hand side lost its congruence hole annotation.\"\n  | none, some .. =>\n    throwCongrEx lhs rhs \"Left-hand side lost its congruence hole annotation.\"\n  | none, none => return none", "start": [423, 1], "end": [449, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.mkCongrOf", "code": "partial def mkCongrOf (depth : Nat) (mvarCounterSaved : Nat) (lhs rhs : Expr) :\n    MetaM CongrResult := do\n  trace[Elab.congr] \"mkCongrOf: {depth}, {lhs}, {rhs}, {(\u2190 mkFreshExprMVar none).mvarId!}\"\n  if depth > 1000 then\n    throwError \"congr(...) internal error: out of gas\"\n  let lhs \u2190 instantiateMVars lhs\n  let rhs \u2190 instantiateMVars rhs\n  if let some res \u2190 mkCongrOfCHole? mvarCounterSaved lhs rhs then\n    trace[Elab.congr] \"hole processing succeeded\"\n    return res\n  if (hasCHole mvarCounterSaved lhs).isNone && (hasCHole mvarCounterSaved rhs).isNone then\n    if \u2190 isDefEq lhs rhs then\n      return {lhs, rhs, pf? := none}\n  if \u2190 (isProof lhs <||> isProof rhs) then\n    return \u2190 CongrResult.mkDefault lhs rhs\n  match lhs, rhs with\n  | .app .., .app .. =>\n    trace[Elab.congr] \"app\"\n    let arity := lhs.getAppNumArgs\n    unless arity == rhs.getAppNumArgs do\n      trace[Elab.congr] \"app desync (arity)\"\n      return \u2190 CongrResult.mkDefault' mvarCounterSaved lhs rhs\n    let f := lhs.getAppFn\n    let f' := rhs.getAppFn\n    unless \u2190 isDefEq (\u2190 inferType f) (\u2190 inferType f') do\n      trace[Elab.congr] \"app desync (function types)\"\n      return \u2190 CongrResult.mkDefault' mvarCounterSaved lhs rhs\n    let fnRes \u2190 mkCongrOf (depth + 1) mvarCounterSaved f f'\n    trace[Elab.congr] \"mkCongrOf functions {f}, {f'} has isRfl = {fnRes.isRfl}\"\n    if !fnRes.isRfl then\n      let lhs := mkAppN fnRes.lhs lhs.getAppArgs\n      let lhs' := mkAppN fnRes.rhs lhs.getAppArgs\n      let rhs := mkAppN fnRes.rhs rhs.getAppArgs\n      let mut pf \u2190 fnRes.eq\n      for arg in lhs.getAppArgs do\n        pf \u2190 mkCongrFun pf arg\n      let res1 := CongrResult.mk' lhs lhs' pf\n      let res2 \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs' rhs\n      return res1.trans res2\n    let thm \u2190 mkHCongrWithArity' fnRes.lhs arity\n    let mut args := #[]\n    let mut lhsArgs := #[]\n    let mut rhsArgs := #[]\n    let mut nontriv : Bool := false\n    for lhs' in lhs.getAppArgs, rhs' in rhs.getAppArgs, kind in thm.argKinds do\n      match kind with\n      | .eq =>\n        let res \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs' rhs'\n        nontriv := nontriv || !res.isRfl\n        args := args |>.push res.lhs |>.push res.rhs |>.push (\u2190 res.eq)\n        lhsArgs := lhsArgs.push res.lhs\n        rhsArgs := rhsArgs.push res.rhs\n      | .heq =>\n        let res \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs' rhs'\n        nontriv := nontriv || !res.isRfl\n        args := args |>.push res.lhs |>.push res.rhs |>.push (\u2190 res.heq)\n        lhsArgs := lhsArgs.push res.lhs\n        rhsArgs := rhsArgs.push res.rhs\n      | .subsingletonInst =>\n        nontriv := true\n        let lhs := removeCHoles lhs'\n        let rhs := removeCHoles rhs'\n        args := args |>.push lhs |>.push rhs\n        lhsArgs := lhsArgs.push lhs\n        rhsArgs := rhsArgs.push rhs\n      | _ => panic! \"unexpected hcongr argument kind\"\n    let lhs := mkAppN fnRes.lhs lhsArgs\n    let rhs := mkAppN fnRes.rhs rhsArgs\n    if nontriv then\n      return CongrResult.mk' lhs rhs (mkAppN thm.proof args)\n    else\n      CongrResult.mkDefault lhs rhs\n  | .lam .., .lam .. =>\n    trace[Elab.congr] \"lam\"\n    let resDom \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs.bindingDomain! rhs.bindingDomain!\n    discard <| resDom.defeq\n    withLocalDecl lhs.bindingName! lhs.bindingInfo! resDom.lhs fun x => do\n      let lhsb := lhs.bindingBody!.instantiate1 x\n      let rhsb := rhs.bindingBody!.instantiate1 x\n      let resBody \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhsb rhsb\n      let lhs \u2190 mkLambdaFVars #[x] resBody.lhs\n      let rhs \u2190 mkLambdaFVars #[x] resBody.rhs\n      if resBody.isRfl then\n        return {lhs, rhs, pf? := none}\n      else\n        let pf \u2190 mkLambdaFVars #[x] (\u2190 resBody.eq)\n        return CongrResult.mk' lhs rhs (\u2190 mkAppM ``funext #[pf])\n  | .forallE .., .forallE .. =>\n    trace[Elab.congr] \"forallE\"\n    let resDom \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs.bindingDomain! rhs.bindingDomain!\n    if lhs.isArrow && rhs.isArrow then\n      let resBody \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs.bindingBody! rhs.bindingBody!\n      let lhs := Expr.forallE lhs.bindingName! resDom.lhs resBody.lhs lhs.bindingInfo!\n      let rhs := Expr.forallE rhs.bindingName! resDom.rhs resBody.rhs rhs.bindingInfo!\n      if resDom.isRfl && resBody.isRfl then\n        return {lhs, rhs, pf? := none}\n      else\n        return CongrResult.mk' lhs rhs (\u2190 mkImpCongr (\u2190 resDom.eq) (\u2190 resBody.eq))\n    else\n      discard <| resDom.defeq\n      withLocalDecl lhs.bindingName! lhs.bindingInfo! resDom.lhs fun x => do\n        let lhsb := lhs.bindingBody!.instantiate1 x\n        let rhsb := rhs.bindingBody!.instantiate1 x\n        let resBody \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhsb rhsb\n        let lhs \u2190 mkForallFVars #[x] resBody.lhs\n        let rhs \u2190 mkForallFVars #[x] resBody.rhs\n        if resBody.isRfl then\n          return {lhs, rhs, pf? := none}\n        else\n          let pf \u2190 mkLambdaFVars #[x] (\u2190 resBody.eq)\n          return CongrResult.mk' lhs rhs (\u2190 mkAppM ``pi_congr #[pf])\n  | .letE .., .letE .. =>\n    trace[Elab.congr] \"letE\"\n    let lhs := lhs.letBody!.instantiate1 lhs.letValue!\n    let rhs := rhs.letBody!.instantiate1 rhs.letValue!\n    mkCongrOf (depth + 1) mvarCounterSaved lhs rhs\n  | .mdata _ lhs', .mdata _ rhs' =>\n    trace[Elab.congr] \"mdata\"\n    let res \u2190 mkCongrOf (depth + 1) mvarCounterSaved lhs' rhs'\n    return {res with lhs := lhs.updateMData! res.lhs, rhs := rhs.updateMData! res.rhs}\n  | .proj n1 i1 e1, .proj n2 i2 e2 =>\n    trace[Elab.congr] \"proj\"\n    unless n1 == n2 && i1 == i2 do\n      throwCongrEx lhs rhs \"Incompatible primitive projections\"\n    let res \u2190 mkCongrOf (depth + 1) mvarCounterSaved e1 e2\n    discard <| res.defeq\n    return {lhs := lhs.updateProj! res.lhs, rhs := rhs.updateProj! res.rhs, pf? := none}\n  | _, _ =>\n    trace[Elab.congr] \"base case\"\n    CongrResult.mkDefault' mvarCounterSaved lhs rhs", "start": [451, 1], "end": [602, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TermCongr.elabTermCongr", "code": "@[term_elab termCongr, inherit_doc termCongr]\ndef elabTermCongr : Term.TermElab := fun stx expectedType? => do\n  match stx with\n  | `(congr($t)) =>\n    let mvarCounterSaved := (\u2190 getMCtx).mvarCounter\n    if let some expectedType := expectedType? then\n      if let some (expLhsTy, expLhs, expRhsTy, expRhs) := (\u2190 whnf expectedType).sides? then\n        let lhs \u2190 elaboratePattern t expLhsTy true\n        let rhs \u2190 elaboratePattern t expRhsTy false\n        unless \u2190 isDefEq expLhs lhs do\n          throwError \"Left-hand side of elaborated pattern{indentD lhs}\\n{\"\"\n            }is not definitionally equal to left-hand side of expected type{indentD expectedType}\"\n        unless \u2190 isDefEq expRhs rhs do\n          throwError \"Right-hand side of elaborated pattern{indentD rhs}\\n{\"\"\n            }is not definitionally equal to right-hand side of expected type{indentD expectedType}\"\n        Term.synthesizeSyntheticMVars (mayPostpone := true)\n        let res \u2190 mkCongrOf 0 mvarCounterSaved lhs rhs\n        let expectedType' \u2190 whnf expectedType\n        let pf \u2190 if expectedType'.iff?.isSome then res.iff\n                  else if expectedType'.isEq then res.eq\n                  else if expectedType'.isHEq then res.heq\n                  else panic! \"unreachable case, sides? guarantees Iff, Eq, and HEq\"\n        return \u2190 mkExpectedTypeHint pf expectedType\n    let lhs \u2190 elaboratePattern t none true\n    let rhs \u2190 elaboratePattern t none false\n    Term.synthesizeSyntheticMVars (mayPostpone := true)\n    let res \u2190 mkCongrOf 0 mvarCounterSaved lhs rhs\n    let pf \u2190 res.eq\n    let ty \u2190 mkEq res.lhs res.rhs\n    mkExpectedTypeHint pf ty\n  | _ => throwUnsupportedSyntax", "start": [606, 1], "end": [640, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/MLList/Dedup.lean", "imports": ["lake-packages/std/Std/Data/MLList/Basic.lean", "lake-packages/std/Std/Data/HashMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MLList.dedupBy", "code": "def dedupBy (L : MLList m \u03b1) (f : \u03b1 \u2192 m \u03b2) : MLList m \u03b1 :=\n  ((L.liftM : MLList (StateT (HashMap \u03b2 Unit) m) \u03b1) >>= fun a => do\n      let b \u2190 f a\n      guard !(\u2190 get).contains b\n      modify fun s => s.insert b ()\n      pure a)\n  |>.runState' \u2205", "start": [21, 1], "end": [29, 17], "kind": "commanddeclaration"}, {"full_name": "MLList.dedup", "code": "def dedup (L : MLList m \u03b2) : MLList m \u03b2 :=\n  L.dedupBy (fun b => pure b)", "start": [31, 1], "end": [33, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/TryThis.lean", "imports": ["lake-packages/std/Std/Tactic/TryThis.lean", "Mathlib/Util/Syntax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "addHaveSuggestion", "code": "def addHaveSuggestion (ref : Syntax) (t? : Option Expr) (e : Expr)\n    (origSpan? : Option Syntax := none) : TermElabM Unit := do\n  let estx \u2190 delabToRefinableSyntax e\n  let prop \u2190 isProp (\u2190 inferType e)\n  let tac \u2190 if let some t := t? then\n    let tstx \u2190 delabToRefinableSyntax t\n    if prop then\n      `(tactic| have : $tstx := $estx)\n    else\n      `(tactic| let this : $tstx := $estx)\n  else\n    if prop then\n      `(tactic| have := $estx)\n    else\n      `(tactic| let this := $estx)\n  addSuggestion ref tac none origSpan?", "start": [17, 1], "end": [33, 39], "kind": "commanddeclaration"}, {"full_name": "addRewriteSuggestion", "code": "def addRewriteSuggestion (ref : Syntax) (rules : List (Expr \u00d7 Bool))\n    (type? : Option Expr := none) (loc? : Option Expr := none)\n  (origSpan? : Option Syntax := none) :\n    TermElabM Unit := do\n  let rules_stx := TSepArray.ofElems <| \u2190 rules.toArray.mapM fun \u27e8e, symm\u27e9 => do\n    let t \u2190 delabToRefinableSyntax e\n    if symm then `(rwRule| \u2190 $t:term) else `(rwRule| $t:term)\n  let tac \u2190 do\n    let loc \u2190 loc?.mapM fun loc => do `(location| at $(\u2190 delab loc):term)\n    `(tactic| rw [$rules_stx,*] $(loc)?)\n\n  let mut tacMsg :=\n    let rulesMsg := MessageData.sbracket <| MessageData.joinSep\n      (rules.map fun \u27e8e, symm\u27e9 => (if symm then \"\u2190 \" else \"\") ++ m!\"{e}\") \", \"\n    if let some loc := loc? then\n      m!\"rw {rulesMsg} at {loc}\"\n    else\n      m!\"rw {rulesMsg}\"\n  let mut extraMsg := \"\"\n  if let some type := type? then\n    tacMsg := tacMsg ++ m!\"\\n    extraMsg := extraMsg ++ s!\"\\n  addSuggestion ref tac (suggestionForMessage? := tacMsg)\n    (extraMsg := extraMsg) (origSpan? := origSpan?)", "start": [38, 1], "end": [62, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Basic.lean", "imports": ["Mathlib/Tactic/CasesM.lean", "Mathlib/Init/Control/Combinators.lean", "lake-packages/std/Std/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Attr/Core.lean"], "premises": [{"full_name": "Functor.map_map", "code": "@[functor_norm]\ntheorem Functor.map_map (m : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) (x : f \u03b1) : g <$> m <$> x = (g \u2218 m) <$> x", "start": [24, 1], "end": [26, 24], "kind": "commanddeclaration"}, {"full_name": "zipWithM", "code": "def zipWithM {\u03b1\u2081 \u03b1\u2082 \u03c6 : Type u} (f : \u03b1\u2081 \u2192 \u03b1\u2082 \u2192 F \u03c6) : \u2200 (_ : List \u03b1\u2081) (_ : List \u03b1\u2082), F (List \u03c6)\n  | x :: xs, y :: ys => (\u00b7 :: \u00b7) <$> f x y <*> zipWithM f xs ys\n  | _, _ => pure []", "start": [39, 1], "end": [42, 20], "kind": "commanddeclaration"}, {"full_name": "zipWithM'", "code": "def zipWithM' (f : \u03b1 \u2192 \u03b2 \u2192 F \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 F PUnit\n  | x :: xs, y :: ys => f x y *> zipWithM' f xs ys\n  | [], _ => pure PUnit.unit\n  | _, [] => pure PUnit.unit", "start": [45, 1], "end": [49, 29], "kind": "commanddeclaration"}, {"full_name": "pure_id'_seq", "code": "@[simp]\ntheorem pure_id'_seq (x : F \u03b1) : (pure fun x => x) <*> x = x", "start": [54, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "seq_map_assoc", "code": "@[functor_norm]\ntheorem seq_map_assoc (x : F (\u03b1 \u2192 \u03b2)) (f : \u03b3 \u2192 \u03b1) (y : F \u03b3) :\n    x <*> f <$> y = (\u00b7 \u2218 f) <$> x <*> y", "start": [59, 1], "end": [64, 18], "kind": "commanddeclaration"}, {"full_name": "map_seq", "code": "@[functor_norm]\ntheorem map_seq (f : \u03b2 \u2192 \u03b3) (x : F (\u03b1 \u2192 \u03b2)) (y : F \u03b1) :\n    f <$> (x <*> y) = (f \u2218 \u00b7) <$> x <*> y", "start": [67, 1], "end": [70, 43], "kind": "commanddeclaration"}, {"full_name": "map_bind", "code": "theorem map_bind (x : m \u03b1) {g : \u03b1 \u2192 m \u03b2} {f : \u03b2 \u2192 \u03b3} :\n    f <$> (x >>= g) = x >>= fun a => f <$> g a", "start": [83, 1], "end": [85, 59], "kind": "commanddeclaration"}, {"full_name": "seq_bind_eq", "code": "theorem seq_bind_eq (x : m \u03b1) {g : \u03b2 \u2192 m \u03b3} {f : \u03b1 \u2192 \u03b2} :\n    f <$> x >>= g = x >>= g \u2218 f", "start": [88, 1], "end": [91, 66], "kind": "commanddeclaration"}, {"full_name": "fish_pure", "code": "@[functor_norm]\ntheorem fish_pure {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : f >=> pure = f", "start": [97, 1], "end": [98, 97], "kind": "commanddeclaration"}, {"full_name": "fish_pipe", "code": "@[functor_norm]\ntheorem fish_pipe {\u03b1 \u03b2} (f : \u03b1 \u2192 m \u03b2) : pure >=> f = f", "start": [101, 1], "end": [102, 97], "kind": "commanddeclaration"}, {"full_name": "fish_assoc", "code": "@[functor_norm]\ntheorem fish_assoc {\u03b1 \u03b2 \u03b3 \u03c6} (f : \u03b1 \u2192 m \u03b2) (g : \u03b2 \u2192 m \u03b3) (h : \u03b3 \u2192 m \u03c6) :\n    (f >=> g) >=> h = f >=> g >=> h", "start": [106, 1], "end": [109, 38], "kind": "commanddeclaration"}, {"full_name": "List.mapAccumRM", "code": "def List.mapAccumRM (f : \u03b1 \u2192 \u03b2' \u2192 m' (\u03b2' \u00d7 \u03b3')) : \u03b2' \u2192 List \u03b1 \u2192 m' (\u03b2' \u00d7 List \u03b3')\n  | a, [] => pure (a, [])\n  | a, x :: xs => do\n    let (a', ys) \u2190 List.mapAccumRM f a xs\n    let (a'', y) \u2190 f x a'\n    pure (a'', y :: ys)", "start": [116, 1], "end": [123, 24], "kind": "commanddeclaration"}, {"full_name": "List.mapAccumLM", "code": "def List.mapAccumLM (f : \u03b2' \u2192 \u03b1 \u2192 m' (\u03b2' \u00d7 \u03b3')) : \u03b2' \u2192 List \u03b1 \u2192 m' (\u03b2' \u00d7 List \u03b3')\n  | a, [] => pure (a, [])\n  | a, x :: xs => do\n    let (a', y) \u2190 f a x\n    let (a'', ys) \u2190 List.mapAccumLM f a' xs\n    pure (a'', y :: ys)", "start": [126, 1], "end": [133, 24], "kind": "commanddeclaration"}, {"full_name": "joinM_map_map", "code": "theorem joinM_map_map {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (a : m (m \u03b1)) :\n    joinM (Functor.map f <$> a) = f <$> joinM a", "start": [142, 1], "end": [144, 88], "kind": "commanddeclaration"}, {"full_name": "joinM_map_joinM", "code": "theorem joinM_map_joinM {\u03b1 : Type u} (a : m (m (m \u03b1))) : joinM (joinM <$> a) = joinM (joinM a)", "start": [147, 1], "end": [148, 88], "kind": "commanddeclaration"}, {"full_name": "joinM_map_pure", "code": "@[simp]\ntheorem joinM_map_pure {\u03b1 : Type u} (a : m \u03b1) : joinM (pure <$> a) = a", "start": [151, 1], "end": [153, 99], "kind": "commanddeclaration"}, {"full_name": "joinM_pure", "code": "@[simp]\ntheorem joinM_pure {\u03b1 : Type u} (a : m \u03b1) : joinM (pure a) = a", "start": [156, 1], "end": [158, 29], "kind": "commanddeclaration"}, {"full_name": "succeeds", "code": "def succeeds {\u03b1} (x : F \u03b1) : F Bool :=\n  Functor.mapConst true x <|> pure false", "start": [168, 1], "end": [170, 41], "kind": "commanddeclaration"}, {"full_name": "tryM", "code": "def tryM {\u03b1} (x : F \u03b1) : F Unit :=\n  Functor.mapConst () x <|> pure ()", "start": [173, 1], "end": [175, 36], "kind": "commanddeclaration"}, {"full_name": "try?", "code": "def try? {\u03b1} (x : F \u03b1) : F (Option \u03b1) :=\n  some <$> x <|> pure none", "start": [178, 1], "end": [180, 27], "kind": "commanddeclaration"}, {"full_name": "guard_true", "code": "@[simp]\ntheorem guard_true {h : Decidable True} : @guard F _ True h = pure ()", "start": [182, 1], "end": [183, 97], "kind": "commanddeclaration"}, {"full_name": "guard_false", "code": "@[simp]\ntheorem guard_false {h : Decidable False} : @guard F _ False h = failure", "start": [186, 1], "end": [188, 36], "kind": "commanddeclaration"}, {"full_name": "Sum.bind", "code": "protected def bind {\u03b1 \u03b2} : Sum e \u03b1 \u2192 (\u03b1 \u2192 Sum e \u03b2) \u2192 Sum e \u03b2\n  | inl x, _ => inl x\n  | inr x, f => f x", "start": [197, 1], "end": [200, 20], "kind": "commanddeclaration"}, {"full_name": "CommApplicative", "code": "class CommApplicative (m : Type u \u2192 Type v) [Applicative m] extends LawfulApplicative m : Prop where\n  \n  commutative_prod : \u2200 {\u03b1 \u03b2} (a : m \u03b1) (b : m \u03b2),\n    Prod.mk <$> a <*> b = (fun (b : \u03b2) a => (a, b)) <$> b <*> a", "start": [236, 1], "end": [242, 64], "kind": "commanddeclaration"}, {"full_name": "CommApplicative.commutative_map", "code": "theorem CommApplicative.commutative_map {m : Type u \u2192 Type v} [h : Applicative m]\n    [CommApplicative m] {\u03b1 \u03b2 \u03b3} (a : m \u03b1) (b : m \u03b2) {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} :\n  f <$> a <*> b = flip f <$> b <*> a", "start": [249, 1], "end": [257, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Meta/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.preservingMCtx", "code": "def Lean.Meta.preservingMCtx (x : MetaM \u03b1) : MetaM \u03b1 := do\n  let mctx \u2190 getMCtx\n  try x finally setMCtx mctx", "start": [16, 1], "end": [21, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/WithWeakNamespace.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.resolveNamespace", "code": "def resolveNamespace (ns : Name) : Name \u2192 Name\n  | `_root_ => Name.anonymous\n  | Name.str n s .. => Name.mkStr (resolveNamespace ns n) s\n  | Name.num n i .. => Name.mkNum (resolveNamespace ns n) i\n  | Name.anonymous => ns", "start": [19, 1], "end": [29, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.withWeakNamespace", "code": "def withWeakNamespace (ns : Name) (m : CommandElabM \u03b1) : CommandElabM \u03b1 := do\n  let old \u2190 getCurrNamespace\n  let ns := resolveNamespace old ns\n  modify fun s \u21a6 { s with env := s.env.registerNamespace ns }\n  modifyScope ({ \u00b7 with currNamespace := ns })\n  try m finally modifyScope ({ \u00b7 with currNamespace := old })", "start": [31, 1], "end": [37, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/LibrarySearch.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/MLList/Heartbeats.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/Cache.lean", "lake-packages/std/Std/Util/Pickle.lean"], "premises": [{"full_name": "Mathlib.Tactic.LibrarySearch.DeclMod", "code": "inductive DeclMod\n  | none | mp | mpr\nderiving DecidableEq, Ord", "start": [34, 1], "end": [43, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.processLemma", "code": "def processLemma (name : Name) (constInfo : ConstantInfo) :\n    MetaM (Array (Array (DiscrTree.Key true) \u00d7 (Name \u00d7 DeclMod))) := do\n  if constInfo.isUnsafe then return #[]\n  if \u2190 name.isBlackListed then return #[]\n  withNewMCtxDepth do withReducible do\n    let (_, _, type) \u2190 forallMetaTelescope constInfo.type\n    let keys \u2190 DiscrTree.mkPath type\n    let mut r := #[(keys, (name, .none))]\n    match type.getAppFnArgs with\n    | (``Iff, #[lhs, rhs]) => do\n      return r.push (\u2190 DiscrTree.mkPath rhs, (name, .mp))\n        |>.push (\u2190 DiscrTree.mkPath lhs, (name, .mpr))\n    | _ => return r", "start": [48, 1], "end": [61, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.addLemma", "code": "def addLemma (name : Name) (constInfo : ConstantInfo)\n    (lemmas : DiscrTree (Name \u00d7 DeclMod) true) : MetaM (DiscrTree (Name \u00d7 DeclMod) true) := do\n  let mut lemmas := lemmas\n  for (key, value) in \u2190 processLemma name constInfo do\n    lemmas := lemmas.insertIfSpecific key value\n  return lemmas", "start": [63, 1], "end": [73, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.buildDiscrTree", "code": "def buildDiscrTree : IO (DiscrTreeCache (Name \u00d7 DeclMod)) :=\n  DiscrTreeCache.mk \"apply?: init cache\" processLemma\n    (post? := some fun A =>\n      A.map (fun (n, m) => (n.toString.length, n, m)) |>.qsort (fun p q => p.1 > q.1) |>.map (\u00b7.2))", "start": [75, 1], "end": [85, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.cachePath", "code": "def cachePath : IO FilePath :=\n  try\n    return (\u2190 findOLean `MathlibExtras.LibrarySearch).withExtension \"extra\"\n  catch _ =>\n    return \"build\" / \"lib\" / \"MathlibExtras\" / \"LibrarySearch.extra\"", "start": [89, 1], "end": [93, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.solveByElim", "code": "def solveByElim (goals : List MVarId) (required : List Expr) (exfalso := false) (depth) := do\n  let cfg : SolveByElim.Config :=\n    { maxDepth := depth, exfalso := exfalso, symm := true, commitIndependentGoals := true }\n  let cfg := if !required.isEmpty then cfg.requireUsingAll required else cfg\n  SolveByElim.solveByElim.processSyntax cfg false false [] [] #[] goals", "start": [107, 1], "end": [114, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.librarySearchLemma", "code": "def librarySearchLemma (lem : Name) (mod : DeclMod) (required : List Expr) (solveByElimDepth := 6)\n    (goal : MVarId) : MetaM (List MVarId) :=\n  withTraceNode `Tactic.librarySearch (return m!\"{\u00b7.emoji} trying {lem}\") do\n    let lem \u2190 mkConstWithFreshMVarLevels lem\n    let lem \u2190 match mod with\n    | .none => pure lem\n    | .mp => mapForallTelescope (fun e => mkAppM ``Iff.mp #[e]) lem\n    | .mpr => mapForallTelescope (fun e => mkAppM ``Iff.mpr #[e]) lem\n    let newGoals \u2190 goal.apply lem { allowSynthFailures := true }\n    try\n      let subgoals \u2190 solveByElim newGoals required (exfalso := false) (depth := solveByElimDepth)\n      pure subgoals\n    catch _ =>\n      if required.isEmpty then\n        pure newGoals\n      else\n        failure", "start": [116, 1], "end": [138, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.librarySearchCore", "code": "def librarySearchCore (goal : MVarId)\n    (required : List Expr) (solveByElimDepth := 6) : Nondet MetaM (List MVarId) :=\n  .squash fun _ => do\n    let ty \u2190 goal.getType\n    let lemmas := (\u2190 librarySearchLemmas.getMatch ty).toList\n    trace[Tactic.librarySearch.lemmas] m!\"Candidate library_search lemmas:\\n{lemmas}\"\n    return (Nondet.ofList lemmas).filterMapM fun (lem, mod) =>\n      observing? <| librarySearchLemma lem mod required solveByElimDepth goal", "start": [140, 1], "end": [151, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.librarySearchSymm", "code": "def librarySearchSymm (goal : MVarId)\n    (required : List Expr) (solveByElimDepth := 6) :\n    Nondet MetaM (List MVarId) :=\n  (librarySearchCore goal required solveByElimDepth) <|>\n  .squash fun _ => do\n    if let some symm \u2190 observing? goal.applySymm then\n      return librarySearchCore symm required solveByElimDepth\n    else\n      return .nil", "start": [153, 1], "end": [164, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.subgoalRankType", "code": "def subgoalRankType : Type := Bool \u00d7 Nat \u00d7 Int\n  deriving ToString", "start": [166, 1], "end": [168, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.subgoalRanking", "code": "def subgoalRanking (goal : MVarId) (subgoals : List MVarId) : MetaM subgoalRankType := do\n  return (subgoals.isEmpty, \u2190 countLocalHypsUsed (.mvar goal), - subgoals.length)", "start": [174, 1], "end": [183, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.sortResults", "code": "def sortResults (goal : MVarId) (R : Array (List MVarId \u00d7 MetavarContext)) :\n    MetaM (Array (List MVarId \u00d7 MetavarContext)) := do\n  let R' \u2190 R.mapM fun (gs, ctx) => do\n    return (\u2190 withMCtx ctx (subgoalRanking goal gs), gs, ctx)\n  let R'' := R'.qsort fun a b => compare a.1 b.1 = Ordering.gt\n  return R''.map (\u00b7.2)", "start": [185, 1], "end": [194, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.librarySearch", "code": "def librarySearch (goal : MVarId) (required : List Expr)\n    (solveByElimDepth := 6) (leavePercentHeartbeats : Nat := 10) :\n    MetaM (Option (Array (List MVarId \u00d7 MetavarContext))) := do\n  let librarySearchEmoji := fun\n    | .error _ => bombEmoji\n    | .ok (some _) => crossEmoji\n    | .ok none => checkEmoji\n  withTraceNode `Tactic.librarySearch (return m!\"{librarySearchEmoji \u00b7} {\u2190 goal.getType}\") do\n  profileitM Exception \"librarySearch\" (\u2190 getOptions) do\n  (do\n    _ \u2190 solveByElim [goal] required (exfalso := true) (depth := solveByElimDepth)\n    return none) <|>\n  (do\n    let results \u2190 librarySearchSymm goal required solveByElimDepth\n      |>.mapM (fun x => do pure (x, \u2190 getMCtx))\n      |>.toMLList'\n      |>.whileAtLeastHeartbeatsPercent leavePercentHeartbeats\n      |>.takeUpToFirst (\u00b7.1.isEmpty)\n      |>.asArray\n    match results.find? (\u00b7.1.isEmpty) with\n    | none => return (\u2190 sortResults goal results)\n    | some (_, ctx) => do\n      setMCtx ctx\n      return none)", "start": [196, 1], "end": [237, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LibrarySearch.exact?", "code": "def exact? (tk : Syntax) (required : Option (Array (TSyntax `term))) (requireClose : Bool) :\n    TacticM Unit := do\n  let mvar \u2190 getMainGoal\n  let (_, goal) \u2190 (\u2190 getMainGoal).intros\n  goal.withContext do\n    let required := (\u2190 (required.getD #[]).mapM getFVarId).toList.map .fvar\n    if let some suggestions \u2190 librarySearch goal required then\n      if requireClose then\n        throwError \"`exact?` could not close the goal. Try `apply?` to see partial suggestions.\"\n      reportOutOfHeartbeats `library_search tk\n      for suggestion in suggestions do\n        withMCtx suggestion.2 do\n          addExactSuggestion tk (\u2190 instantiateMVars (mkMVar mvar)).headBeta (addSubgoalsMsg := true)\n      if suggestions.isEmpty then logError \"apply? didn't find any relevant lemmas\"\n      admitGoal goal\n    else\n      addExactSuggestion tk (\u2190 instantiateMVars (mkMVar mvar)).headBeta", "start": [259, 1], "end": [275, 72], "kind": "commanddeclaration"}]}
{"path": "lake-packages/Qq/Qq.lean", "imports": ["lake-packages/Qq/Qq/Delab.lean", "lake-packages/Qq/Qq/Macro.lean", "lake-packages/Qq/Qq/MetaM.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/Qq/Qq/Match.lean", "lake-packages/Qq/Qq/AssertInstancesCommute.lean"], "premises": []}
{"path": "Mathlib/Tactic/FBinop.lean", "imports": ["Mathlib/Tactic/ToExpr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FBinopElab.Tree", "code": "private inductive Tree where\n  \n  | term (ref : Syntax) (infoTrees : PersistentArray InfoTree) (val : Expr)\n  \n  | binop (ref : Syntax) (f : Expr) (lhs rhs : Tree)\n  \n  | macroExpansion (macroName : Name) (stx stx' : Syntax) (nested : Tree)", "start": [37, 1], "end": [47, 74], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.toTree", "code": "private partial def toTree (s : Syntax) : TermElabM Tree := do\n  let result \u2190 go s\n  synthesizeSyntheticMVars (mayPostpone := true)\n  return result\nwhere\n  go (s : Syntax) : TermElabM Tree := do\n    match s with\n    | `(fbinop% $f $lhs $rhs) => processBinOp s f lhs rhs\n    | `(($e)) =>\n      if hasCDot e then\n        processLeaf s\n      else\n        go e\n    | _ =>\n      withRef s do\n        match \u2190 liftMacroM <| expandMacroImpl? (\u2190 getEnv) s with\n        | some (macroName, s?) =>\n          let s' \u2190 liftMacroM <| liftExcept s?\n          withPushMacroExpansionStack s s' do\n            return .macroExpansion macroName s s' (\u2190 go s')\n        | none => processLeaf s\n\n  processBinOp (ref : Syntax) (f lhs rhs : Syntax) := do\n    let some f \u2190 resolveId? f | throwUnknownConstant f.getId\n    return .binop ref f (\u2190 go lhs) (\u2190 go rhs)\n\n  processLeaf (s : Syntax) := do\n    let e \u2190 elabTerm s none\n    let info \u2190 getResetInfoTrees\n    return .term s info e", "start": [49, 1], "end": [78, 26], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.SRec", "code": "structure SRec where\n  name : Name\n  args : Array Expr\n  deriving Inhabited, ToExpr", "start": [80, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.extractS", "code": "private partial def extractS (e : Expr) : TermElabM (Option (SRec \u00d7 Expr)) :=\n  match e with\n  | .letE .. => extractS (e.letBody!.instantiate1 e.letValue!)\n  | .mdata _ b => extractS b\n  | .app .. => do\n    let f := e.getAppFn\n    let .const n _ := f | return none\n    let mut args := e.getAppArgs\n    let mut info := (\u2190 getFunInfoNArgs f args.size).paramInfo\n    for _ in [0 : args.size - 1] do\n      if info.back.isInstImplicit then\n        args := args.pop\n        info := info.pop\n      else\n        break\n    let x := args.back\n    unless \u2190 Meta.isType x do return none\n    return some ({name := n, args := args.pop}, x)\n  | _ => return none", "start": [87, 1], "end": [109, 21], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.applyS", "code": "private def applyS (S : SRec) (x : Expr) : TermElabM (Option Expr) :=\n  try\n    let f \u2190 mkConstWithFreshMVarLevels S.name\n    let v \u2190 elabAppArgs f #[] ((S.args.push x).map .expr)\n      (expectedType? := none) (explicit := true) (ellipsis := false)\n    elabAppArgs v #[] #[] (expectedType? := none) (explicit := false) (ellipsis := false)\n  catch _ =>\n    return none", "start": [111, 1], "end": [121, 16], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.hasCoeS", "code": "private def hasCoeS (fromS toS : SRec) (x : Expr) : TermElabM Bool := do\n  let some fromType \u2190 applyS fromS x | return false\n  let some toType \u2190 applyS toS x | return false\n  trace[Elab.fbinop] m!\"fromType = {fromType}, toType = {toType}\"\n  withLocalDeclD `v fromType fun v => do\n    match \u2190 coerceSimple? v toType with\n    | .some _ => return true\n    | .none   => return false\n    | .undef  => return false", "start": [123, 1], "end": [133, 30], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.AnalyzeResult", "code": "private structure AnalyzeResult where\n  maxS? : Option SRec := none\n  \n  hasUncomparable : Bool := false", "start": [135, 1], "end": [139, 34], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.analyze", "code": "private def analyze (t : Tree) (expectedType? : Option Expr) : TermElabM AnalyzeResult := do\n  let maxS? \u2190\n    match expectedType? with\n    | none => pure none\n    | some expectedType =>\n      let expectedType \u2190 instantiateMVars expectedType\n      if let some (S, _) \u2190 extractS expectedType then\n        pure S\n      else\n        pure none\n  (go t *> get).run' { maxS? }\nwhere\n  go (t : Tree) : StateRefT AnalyzeResult TermElabM Unit := do\n    unless (\u2190 get).hasUncomparable do\n      match t with\n      | .macroExpansion _ _ _ nested => go nested\n      | .binop _ _ lhs rhs => go lhs; go rhs\n      | .term _ _ val =>\n        let type \u2190 instantiateMVars (\u2190 inferType val)\n        let some (S, x) \u2190 extractS type\n          | return match (\u2190 get).maxS? with\n        | none     => modify fun s => { s with maxS? := S }\n        | some maxS =>\n          let some maxSx \u2190 applyS maxS x | return unless \u2190 withNewMCtxDepth <| isDefEqGuarded maxSx type do\n            if \u2190 hasCoeS S maxS x then\n              return ()\n            else if \u2190 hasCoeS maxS S x then\n              modify fun s => { s with maxS? := S }\n            else\n              trace[Elab.fbinop] \"uncomparable types: {maxSx}, {type}\"\n              modify fun s => { s with hasUncomparable := true }", "start": [141, 1], "end": [174, 65], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.mkBinOp", "code": "private def mkBinOp (f : Expr) (lhs rhs : Expr) : TermElabM Expr := do\n  elabAppArgs f #[] #[Arg.expr lhs, Arg.expr rhs] (expectedType? := none)\n    (explicit := false) (ellipsis := false) (resultIsOutParamSupport := false)", "start": [176, 1], "end": [178, 79], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.toExprCore", "code": "private def toExprCore (t : Tree) : TermElabM Expr := do\n  match t with\n  | .term _ trees e =>\n    modifyInfoState (fun s => { s with trees := s.trees ++ trees }); return e\n  | .binop ref f lhs rhs =>\n    withRef ref <| withInfoContext' ref (mkInfo := mkTermInfo .anonymous ref) do\n      let lhs \u2190 toExprCore lhs\n      let mut rhs \u2190 toExprCore rhs\n      mkBinOp f lhs rhs\n  | .macroExpansion macroName stx stx' nested =>\n    withRef stx <| withInfoContext' stx (mkInfo := mkTermInfo macroName stx) do\n      withMacroExpansion stx stx' do\n        toExprCore nested", "start": [180, 1], "end": [193, 26], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.applyCoe", "code": "private def applyCoe (t : Tree) (maxS : SRec) : TermElabM Tree := do\n  go t none\nwhere\n  go (t : Tree) (f? : Option Expr) : TermElabM Tree := do\n    match t with\n    | .binop ref f lhs rhs =>\n      let lhs' \u2190 go lhs f\n      let rhs' \u2190 go rhs f\n      return .binop ref f lhs' rhs'\n    | .term ref trees e =>\n      let type \u2190 instantiateMVars (\u2190 inferType e)\n      trace[Elab.fbinop] \"visiting {e} : {type}\"\n      let some (_, x) \u2190 extractS type\n        | let x' \u2190 mkFreshExprMVar none\n          let some maxType \u2190 applyS maxS x' | trace[Elab.fbinop] \"mvar apply failed\"; return t\n          trace[Elab.fbinop] \"defeq hint {maxType} =?= {type}\"\n          _ \u2190 isDefEqGuarded maxType type\n          return t\n      let some maxType \u2190 applyS maxS x\n        | trace[Elab.fbinop] \"applying {Lean.toExpr maxS} {x} failed\"\n          return t\n      trace[Elab.fbinop] \"{type} =?= {maxType}\"\n      if \u2190 isDefEqGuarded maxType type then\n        return t\n      else\n        trace[Elab.fbinop] \"added coercion: {e} : {type} => {maxType}\"\n        withRef ref <| return .term ref trees (\u2190 mkCoe maxType e)\n    | .macroExpansion macroName stx stx' nested =>\n      withRef stx <| withPushMacroExpansionStack stx stx' do\n        return .macroExpansion macroName stx stx' (\u2190 go nested f?)", "start": [195, 1], "end": [226, 67], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.toExpr", "code": "private def toExpr (tree : Tree) (expectedType? : Option Expr) : TermElabM Expr := do\n  let r \u2190 analyze tree expectedType?\n  trace[Elab.fbinop] \"hasUncomparable: {r.hasUncomparable}, maxType: {Lean.toExpr r.maxS?}\"\n  if r.hasUncomparable || r.maxS?.isNone then\n    let result \u2190 toExprCore tree\n    ensureHasType expectedType? result\n  else\n    let result \u2190 toExprCore (\u2190 applyCoe tree r.maxS?.get!)\n    trace[Elab.fbinop] \"result: {result}\"\n    ensureHasType expectedType? result", "start": [228, 1], "end": [237, 39], "kind": "commanddeclaration"}, {"full_name": "FBinopElab.elabBinOp", "code": "@[term_elab prodSyntax]\ndef elabBinOp : TermElab := fun stx expectedType? => do\n  toExpr (\u2190 toTree stx) expectedType?", "start": [239, 1], "end": [241, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Heyting/Basic.lean", "imports": ["Mathlib/Order/PropInstances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HImp", "code": "@[notation_class]\nclass HImp (\u03b1 : Type*) where\n  \n  himp : \u03b1 \u2192 \u03b1 \u2192 \u03b1", "start": [61, 1], "end": [65, 19], "kind": "commanddeclaration"}, {"full_name": "HNot", "code": "@[notation_class]\nclass HNot (\u03b1 : Type*) where\n  \n  hnot : \u03b1 \u2192 \u03b1", "start": [68, 1], "end": [78, 15], "kind": "commanddeclaration"}, {"full_name": "Prod.himp", "code": "instance Prod.himp [HImp \u03b1] [HImp \u03b2] : HImp (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a b => (a.1 \u21e8 b.1, a.2 \u21e8 b.2)\u27e9", "start": [94, 1], "end": [95, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.hnot", "code": "instance Prod.hnot [HNot \u03b1] [HNot \u03b2] : HNot (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a => (\uffe2a.1, \uffe2a.2)\u27e9", "start": [97, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "Prod.sdiff", "code": "instance Prod.sdiff [SDiff \u03b1] [SDiff \u03b2] : SDiff (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a b => (a.1 \\ b.1, a.2 \\ b.2)\u27e9", "start": [100, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.hasCompl", "code": "instance Prod.hasCompl [HasCompl \u03b1] [HasCompl \u03b2] : HasCompl (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun a => (a.1\u1d9c, a.2\u1d9c)\u27e9", "start": [103, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "fst_himp", "code": "@[simp]\ntheorem fst_himp [HImp \u03b1] [HImp \u03b2] (a b : \u03b1 \u00d7 \u03b2) : (a \u21e8 b).1 = a.1 \u21e8 b.1", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "snd_himp", "code": "@[simp]\ntheorem snd_himp [HImp \u03b1] [HImp \u03b2] (a b : \u03b1 \u00d7 \u03b2) : (a \u21e8 b).2 = a.2 \u21e8 b.2", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "fst_hnot", "code": "@[simp]\ntheorem fst_hnot [HNot \u03b1] [HNot \u03b2] (a : \u03b1 \u00d7 \u03b2) : (\uffe2a).1 = \uffe2a.1", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "snd_hnot", "code": "@[simp]\ntheorem snd_hnot [HNot \u03b1] [HNot \u03b2] (a : \u03b1 \u00d7 \u03b2) : (\uffe2a).2 = \uffe2a.2", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "fst_sdiff", "code": "@[simp]\ntheorem fst_sdiff [SDiff \u03b1] [SDiff \u03b2] (a b : \u03b1 \u00d7 \u03b2) : (a \\ b).1 = a.1 \\ b.1", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "snd_sdiff", "code": "@[simp]\ntheorem snd_sdiff [SDiff \u03b1] [SDiff \u03b2] (a b : \u03b1 \u00d7 \u03b2) : (a \\ b).2 = a.2 \\ b.2", "start": [133, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "fst_compl", "code": "@[simp]\ntheorem fst_compl [HasCompl \u03b1] [HasCompl \u03b2] (a : \u03b1 \u00d7 \u03b2) : a\u1d9c.1 = a.1\u1d9c", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "snd_compl", "code": "@[simp]\ntheorem snd_compl [HasCompl \u03b1] [HasCompl \u03b2] (a : \u03b1 \u00d7 \u03b2) : a\u1d9c.2 = a.2\u1d9c", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.himp_def", "code": "theorem himp_def [\u2200 i, HImp (\u03c0 i)] (a b : \u2200 i, \u03c0 i) : a \u21e8 b = fun i => a i \u21e8 b i", "start": [158, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.hnot_def", "code": "theorem hnot_def [\u2200 i, HNot (\u03c0 i)] (a : \u2200 i, \u03c0 i) : \uffe2a = fun i => \uffe2a i", "start": [162, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.himp_apply", "code": "@[simp]\ntheorem himp_apply [\u2200 i, HImp (\u03c0 i)] (a b : \u2200 i, \u03c0 i) (i : \u03b9) : (a \u21e8 b) i = a i \u21e8 b i", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.hnot_apply", "code": "@[simp]\ntheorem hnot_apply [\u2200 i, HNot (\u03c0 i)] (a : \u2200 i, \u03c0 i) (i : \u03b9) : (\uffe2a) i = \uffe2a i", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "GeneralizedHeytingAlgebra", "code": "class GeneralizedHeytingAlgebra (\u03b1 : Type*) extends Lattice \u03b1, Top \u03b1, HImp \u03b1 where\n  \n  le_top : \u2200 a : \u03b1, a \u2264 \u22a4\n  \n  le_himp_iff (a b c : \u03b1) : a \u2264 b \u21e8 c \u2194 a \u2293 b \u2264 c", "start": [178, 1], "end": [186, 50], "kind": "commanddeclaration"}, {"full_name": "GeneralizedCoheytingAlgebra", "code": "class GeneralizedCoheytingAlgebra (\u03b1 : Type*) extends Lattice \u03b1, Bot \u03b1, SDiff \u03b1 where\n  \n  bot_le : \u2200 a : \u03b1, \u22a5 \u2264 a\n  \n  sdiff_le_iff (a b c : \u03b1) : a \\ b \u2264 c \u2194 a \u2264 b \u2294 c", "start": [189, 1], "end": [197, 51], "kind": "commanddeclaration"}, {"full_name": "HeytingAlgebra", "code": "class HeytingAlgebra (\u03b1 : Type*) extends GeneralizedHeytingAlgebra \u03b1, Bot \u03b1, HasCompl \u03b1 where\n  \n  bot_le : \u2200 a : \u03b1, \u22a5 \u2264 a\n  \n  himp_bot (a : \u03b1) : a \u21e8 \u22a5 = a\u1d9c", "start": [200, 1], "end": [206, 32], "kind": "commanddeclaration"}, {"full_name": "CoheytingAlgebra", "code": "class CoheytingAlgebra (\u03b1 : Type*) extends GeneralizedCoheytingAlgebra \u03b1, Top \u03b1, HNot \u03b1 where\n  \n  le_top : \u2200 a : \u03b1, a \u2264 \u22a4\n  \n  top_sdiff (a : \u03b1) : \u22a4 \\ a = \uffe2a", "start": [209, 1], "end": [215, 33], "kind": "commanddeclaration"}, {"full_name": "BiheytingAlgebra", "code": "class BiheytingAlgebra (\u03b1 : Type*) extends HeytingAlgebra \u03b1, SDiff \u03b1, HNot \u03b1 where\n  \n  sdiff_le_iff (a b c : \u03b1) : a \\ b \u2264 c \u2194 a \u2264 b \u2294 c\n  \n  top_sdiff (a : \u03b1) : \u22a4 \\ a = \uffe2a", "start": [218, 1], "end": [223, 33], "kind": "commanddeclaration"}, {"full_name": "GeneralizedHeytingAlgebra.toOrderTop", "code": "instance (priority := 100) GeneralizedHeytingAlgebra.toOrderTop [GeneralizedHeytingAlgebra \u03b1] :\n    OrderTop \u03b1 :=\n  { \u2039GeneralizedHeytingAlgebra \u03b1\u203a with }", "start": [227, 1], "end": [229, 41], "kind": "commanddeclaration"}, {"full_name": "GeneralizedCoheytingAlgebra.toOrderBot", "code": "instance (priority := 100) GeneralizedCoheytingAlgebra.toOrderBot [GeneralizedCoheytingAlgebra \u03b1] :\n    OrderBot \u03b1 :=\n  { \u2039GeneralizedCoheytingAlgebra \u03b1\u203a with }", "start": [233, 1], "end": [235, 43], "kind": "commanddeclaration"}, {"full_name": "HeytingAlgebra.toBoundedOrder", "code": "instance (priority := 100) HeytingAlgebra.toBoundedOrder [HeytingAlgebra \u03b1] : BoundedOrder \u03b1 :=\n  { bot_le := \u2039HeytingAlgebra \u03b1\u203a.bot_le }", "start": [239, 1], "end": [240, 42], "kind": "commanddeclaration"}, {"full_name": "CoheytingAlgebra.toBoundedOrder", "code": "instance (priority := 100) CoheytingAlgebra.toBoundedOrder [CoheytingAlgebra \u03b1] : BoundedOrder \u03b1 :=\n  { \u2039CoheytingAlgebra \u03b1\u203a with }", "start": [244, 1], "end": [245, 32], "kind": "commanddeclaration"}, {"full_name": "BiheytingAlgebra.toCoheytingAlgebra", "code": "instance (priority := 100) BiheytingAlgebra.toCoheytingAlgebra [BiheytingAlgebra \u03b1] :\n    CoheytingAlgebra \u03b1 :=\n  { \u2039BiheytingAlgebra \u03b1\u203a with }", "start": [249, 1], "end": [251, 32], "kind": "commanddeclaration"}, {"full_name": "HeytingAlgebra.ofHImp", "code": "@[reducible]\ndef HeytingAlgebra.ofHImp [DistribLattice \u03b1] [BoundedOrder \u03b1] (himp : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (le_himp_iff : \u2200 a b c, a \u2264 himp b c \u2194 a \u2293 b \u2264 c) : HeytingAlgebra \u03b1 :=\n  { \u2039DistribLattice \u03b1\u203a, \u2039BoundedOrder \u03b1\u203a with\n    himp,\n    compl := fun a => himp a \u22a5,\n    le_himp_iff,\n    himp_bot := fun a => rfl }", "start": [255, 1], "end": [263, 31], "kind": "commanddeclaration"}, {"full_name": "HeytingAlgebra.ofCompl", "code": "@[reducible]\ndef HeytingAlgebra.ofCompl [DistribLattice \u03b1] [BoundedOrder \u03b1] (compl : \u03b1 \u2192 \u03b1)\n    (le_himp_iff : \u2200 a b c, a \u2264 compl b \u2294 c \u2194 a \u2293 b \u2264 c) : HeytingAlgebra \u03b1 :=\n  { \u2039DistribLattice \u03b1\u203a, \u2039BoundedOrder \u03b1\u203a with\n    himp := fun a => (\u00b7 \u2294 \u00b7) (compl a),\n    compl,\n    le_himp_iff,\n    himp_bot := fun a => sup_bot_eq }", "start": [267, 1], "end": [275, 38], "kind": "commanddeclaration"}, {"full_name": "CoheytingAlgebra.ofSDiff", "code": "@[reducible]\ndef CoheytingAlgebra.ofSDiff [DistribLattice \u03b1] [BoundedOrder \u03b1] (sdiff : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (sdiff_le_iff : \u2200 a b c, sdiff a b \u2264 c \u2194 a \u2264 b \u2294 c) : CoheytingAlgebra \u03b1 :=\n  { \u2039DistribLattice \u03b1\u203a, \u2039BoundedOrder \u03b1\u203a with\n    sdiff,\n    hnot := fun a => sdiff \u22a4 a,\n    sdiff_le_iff,\n    top_sdiff := fun a => rfl }", "start": [279, 1], "end": [287, 32], "kind": "commanddeclaration"}, {"full_name": "CoheytingAlgebra.ofHNot", "code": "@[reducible]\ndef CoheytingAlgebra.ofHNot [DistribLattice \u03b1] [BoundedOrder \u03b1] (hnot : \u03b1 \u2192 \u03b1)\n    (sdiff_le_iff : \u2200 a b c, a \u2293 hnot b \u2264 c \u2194 a \u2264 b \u2294 c) : CoheytingAlgebra \u03b1 :=\n  { \u2039DistribLattice \u03b1\u203a, \u2039BoundedOrder \u03b1\u203a with\n    sdiff := fun a b => a \u2293 hnot b,\n    hnot,\n    sdiff_le_iff,\n    top_sdiff := fun a => top_inf_eq }", "start": [291, 1], "end": [299, 39], "kind": "commanddeclaration"}, {"full_name": "le_himp_iff", "code": "@[simp]\ntheorem le_himp_iff : a \u2264 b \u21e8 c \u2194 a \u2293 b \u2264 c", "start": [313, 1], "end": [315, 46], "kind": "commanddeclaration"}, {"full_name": "le_himp_iff'", "code": "theorem le_himp_iff' : a \u2264 b \u21e8 c \u2194 b \u2293 a \u2264 c", "start": [319, 1], "end": [319, 78], "kind": "commanddeclaration"}, {"full_name": "le_himp_comm", "code": "theorem le_himp_comm : a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c", "start": [323, 1], "end": [323, 82], "kind": "commanddeclaration"}, {"full_name": "le_himp", "code": "theorem le_himp : a \u2264 b \u21e8 a", "start": [327, 1], "end": [328, 28], "kind": "commanddeclaration"}, {"full_name": "le_himp_iff_left", "code": "theorem le_himp_iff_left : a \u2264 a \u21e8 b \u2194 a \u2264 b", "start": [332, 1], "end": [332, 78], "kind": "commanddeclaration"}, {"full_name": "himp_self", "code": "@[simp]\ntheorem himp_self : a \u21e8 a = \u22a4", "start": [336, 1], "end": [338, 45], "kind": "commanddeclaration"}, {"full_name": "himp_inf_le", "code": "theorem himp_inf_le : (a \u21e8 b) \u2293 a \u2264 b", "start": [342, 1], "end": [343, 23], "kind": "commanddeclaration"}, {"full_name": "inf_himp_le", "code": "theorem inf_himp_le : a \u2293 (a \u21e8 b) \u2264 b", "start": [347, 1], "end": [347, 73], "kind": "commanddeclaration"}, {"full_name": "inf_himp", "code": "@[simp]\ntheorem inf_himp (a b : \u03b1) : a \u2293 (a \u21e8 b) = a \u2293 b", "start": [351, 1], "end": [353, 99], "kind": "commanddeclaration"}, {"full_name": "himp_inf_self", "code": "@[simp]\ntheorem himp_inf_self (a b : \u03b1) : (a \u21e8 b) \u2293 a = b \u2293 a", "start": [357, 1], "end": [358, 94], "kind": "commanddeclaration"}, {"full_name": "himp_eq_top_iff", "code": "@[simp]\ntheorem himp_eq_top_iff : a \u21e8 b = \u22a4 \u2194 a \u2264 b", "start": [361, 1], "end": [364, 93], "kind": "commanddeclaration"}, {"full_name": "himp_top", "code": "@[simp]\ntheorem himp_top : a \u21e8 \u22a4 = \u22a4", "start": [368, 1], "end": [370, 27], "kind": "commanddeclaration"}, {"full_name": "top_himp", "code": "@[simp]\ntheorem top_himp : \u22a4 \u21e8 a = a", "start": [373, 1], "end": [375, 63], "kind": "commanddeclaration"}, {"full_name": "himp_himp", "code": "theorem himp_himp (a b c : \u03b1) : a \u21e8 b \u21e8 c = a \u2293 b \u21e8 c", "start": [379, 1], "end": [380, 67], "kind": "commanddeclaration"}, {"full_name": "himp_le_himp_himp_himp", "code": "theorem himp_le_himp_himp_himp : b \u21e8 c \u2264 (a \u21e8 b) \u21e8 a \u21e8 c", "start": [384, 1], "end": [386, 20], "kind": "commanddeclaration"}, {"full_name": "himp_inf_himp_inf_le", "code": "@[simp]\ntheorem himp_inf_himp_inf_le : (b \u21e8 c) \u2293 (a \u21e8 b) \u2293 a \u2264 c", "start": [389, 1], "end": [391, 38], "kind": "commanddeclaration"}, {"full_name": "himp_left_comm", "code": "theorem himp_left_comm (a b c : \u03b1) : a \u21e8 b \u21e8 c = b \u21e8 a \u21e8 c", "start": [394, 1], "end": [394, 95], "kind": "commanddeclaration"}, {"full_name": "himp_idem", "code": "@[simp]\ntheorem himp_idem : b \u21e8 b \u21e8 a = b \u21e8 a", "start": [397, 1], "end": [398, 69], "kind": "commanddeclaration"}, {"full_name": "himp_inf_distrib", "code": "theorem himp_inf_distrib (a b c : \u03b1) : a \u21e8 b \u2293 c = (a \u21e8 b) \u2293 (a \u21e8 c)", "start": [401, 1], "end": [402, 81], "kind": "commanddeclaration"}, {"full_name": "sup_himp_distrib", "code": "theorem sup_himp_distrib (a b c : \u03b1) : a \u2294 b \u21e8 c = (a \u21e8 c) \u2293 (b \u21e8 c)", "start": [405, 1], "end": [408, 27], "kind": "commanddeclaration"}, {"full_name": "himp_le_himp_left", "code": "theorem himp_le_himp_left (h : a \u2264 b) : c \u21e8 a \u2264 c \u21e8 b", "start": [411, 1], "end": [412, 39], "kind": "commanddeclaration"}, {"full_name": "himp_le_himp_right", "code": "theorem himp_le_himp_right (h : a \u2264 b) : b \u21e8 c \u2264 a \u21e8 c", "start": [415, 1], "end": [416, 59], "kind": "commanddeclaration"}, {"full_name": "himp_le_himp", "code": "theorem himp_le_himp (hab : a \u2264 b) (hcd : c \u2264 d) : b \u21e8 c \u2264 a \u21e8 d", "start": [419, 1], "end": [420, 58], "kind": "commanddeclaration"}, {"full_name": "sup_himp_self_left", "code": "@[simp]\ntheorem sup_himp_self_left (a b : \u03b1) : a \u2294 b \u21e8 a = b \u21e8 a", "start": [423, 1], "end": [425, 47], "kind": "commanddeclaration"}, {"full_name": "sup_himp_self_right", "code": "@[simp]\ntheorem sup_himp_self_right (a b : \u03b1) : a \u2294 b \u21e8 b = a \u21e8 b", "start": [428, 1], "end": [430, 47], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.himp_eq_right", "code": "theorem Codisjoint.himp_eq_right (h : Codisjoint a b) : b \u21e8 a = a", "start": [433, 1], "end": [435, 38], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.himp_eq_left", "code": "theorem Codisjoint.himp_eq_left (h : Codisjoint a b) : a \u21e8 b = b", "start": [438, 1], "end": [439, 23], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.himp_inf_cancel_right", "code": "theorem Codisjoint.himp_inf_cancel_right (h : Codisjoint a b) : a \u21e8 a \u2293 b = b", "start": [442, 1], "end": [443, 63], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.himp_inf_cancel_left", "code": "theorem Codisjoint.himp_inf_cancel_left (h : Codisjoint a b) : b \u21e8 a \u2293 b = a", "start": [446, 1], "end": [447, 64], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.himp_le_of_right_le", "code": "theorem Codisjoint.himp_le_of_right_le (hac : Codisjoint a c) (hba : b \u2264 a) : c \u21e8 b \u2264 a", "start": [450, 1], "end": [452, 53], "kind": "commanddeclaration"}, {"full_name": "le_himp_himp", "code": "theorem le_himp_himp : a \u2264 (a \u21e8 b) \u21e8 b", "start": [455, 1], "end": [456, 28], "kind": "commanddeclaration"}, {"full_name": "himp_triangle", "code": "theorem himp_triangle (a b c : \u03b1) : (a \u21e8 b) \u2293 (b \u21e8 c) \u2264 a \u21e8 c", "start": [459, 1], "end": [461, 39], "kind": "commanddeclaration"}, {"full_name": "himp_inf_himp_cancel", "code": "theorem himp_inf_himp_cancel (hba : b \u2264 a) (hcb : c \u2264 b) : (a \u21e8 b) \u2293 (b \u21e8 c) = a \u21e8 c", "start": [464, 1], "end": [465, 92], "kind": "commanddeclaration"}, {"full_name": "GeneralizedHeytingAlgebra.toDistribLattice", "code": "instance (priority := 100) GeneralizedHeytingAlgebra.toDistribLattice : DistribLattice \u03b1 :=\n  DistribLattice.ofInfSupLe fun a b c => by\n    simp_rw [@inf_comm _ _ a, \u2190 le_himp_iff, sup_le_iff, le_himp_iff, \u2190 sup_le_iff]; rfl", "start": [469, 1], "end": [471, 89], "kind": "commanddeclaration"}, {"full_name": "Prod.generalizedHeytingAlgebra", "code": "instance Prod.generalizedHeytingAlgebra [GeneralizedHeytingAlgebra \u03b2] :\n    GeneralizedHeytingAlgebra (\u03b1 \u00d7 \u03b2) :=\n  { Prod.lattice \u03b1 \u03b2, Prod.orderTop \u03b1 \u03b2, Prod.himp \u03b1 \u03b2 with\n    le_himp_iff := fun _ _ _ => and_congr le_himp_iff le_himp_iff }", "start": [481, 1], "end": [484, 68], "kind": "commanddeclaration"}, {"full_name": "Pi.generalizedHeytingAlgebra", "code": "instance Pi.generalizedHeytingAlgebra {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, GeneralizedHeytingAlgebra (\u03b1 i)] :\n    GeneralizedHeytingAlgebra (\u2200 i, \u03b1 i) :=\n  { Pi.lattice, Pi.orderTop with\n    le_himp_iff := fun i => by simp [le_def] }", "start": [487, 1], "end": [490, 47], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_iff", "code": "@[simp]\ntheorem sdiff_le_iff : a \\ b \u2264 c \u2194 a \u2264 b \u2294 c", "start": [499, 1], "end": [501, 49], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_iff'", "code": "theorem sdiff_le_iff' : a \\ b \u2264 c \u2194 a \u2264 c \u2294 b", "start": [504, 1], "end": [504, 80], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_comm", "code": "theorem sdiff_le_comm : a \\ b \u2264 c \u2194 a \\ c \u2264 b", "start": [507, 1], "end": [507, 85], "kind": "commanddeclaration"}, {"full_name": "sdiff_le", "code": "theorem sdiff_le : a \\ b \u2264 a", "start": [510, 1], "end": [511, 30], "kind": "commanddeclaration"}, {"full_name": "Disjoint.disjoint_sdiff_left", "code": "theorem Disjoint.disjoint_sdiff_left (h : Disjoint a b) : Disjoint (a \\ c) b", "start": [514, 1], "end": [515, 23], "kind": "commanddeclaration"}, {"full_name": "Disjoint.disjoint_sdiff_right", "code": "theorem Disjoint.disjoint_sdiff_right (h : Disjoint a b) : Disjoint a (b \\ c)", "start": [518, 1], "end": [519, 24], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_iff_left", "code": "theorem sdiff_le_iff_left : a \\ b \u2264 b \u2194 a \u2264 b", "start": [522, 1], "end": [522, 80], "kind": "commanddeclaration"}, {"full_name": "sdiff_self", "code": "@[simp]\ntheorem sdiff_self : a \\ a = \u22a5", "start": [525, 1], "end": [527, 45], "kind": "commanddeclaration"}, {"full_name": "le_sup_sdiff", "code": "theorem le_sup_sdiff : a \u2264 b \u2294 a \\ b", "start": [530, 1], "end": [531, 24], "kind": "commanddeclaration"}, {"full_name": "le_sdiff_sup", "code": "theorem le_sdiff_sup : a \u2264 a \\ b \u2294 b", "start": [534, 1], "end": [534, 73], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_left", "code": "theorem sup_sdiff_left : a \u2294 a \\ b = a", "start": [537, 1], "end": [538, 26], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_right", "code": "theorem sup_sdiff_right : a \\ b \u2294 a = a", "start": [541, 1], "end": [542, 27], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_left", "code": "theorem inf_sdiff_left : a \\ b \u2293 a = a \\ b", "start": [545, 1], "end": [546, 26], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_right", "code": "theorem inf_sdiff_right : a \u2293 a \\ b = a \\ b", "start": [549, 1], "end": [550, 27], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_self", "code": "@[simp]\ntheorem sup_sdiff_self (a b : \u03b1) : a \u2294 b \\ a = a \u2294 b", "start": [553, 1], "end": [555, 77], "kind": "commanddeclaration"}, {"full_name": "sdiff_sup_self", "code": "@[simp]\ntheorem sdiff_sup_self (a b : \u03b1) : b \\ a \u2294 a = b \u2294 a", "start": [558, 1], "end": [559, 99], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_self_left", "code": "alias sup_sdiff_self_left := sdiff_sup_self", "start": [562, 1], "end": [562, 44], "kind": "stdtacticaliasalias"}, {"full_name": "sup_sdiff_self_right", "code": "alias sup_sdiff_self_right := sup_sdiff_self", "start": [565, 1], "end": [565, 45], "kind": "stdtacticaliasalias"}, {"full_name": "sup_sdiff_eq_sup", "code": "theorem sup_sdiff_eq_sup (h : c \u2264 a) : a \u2294 b \\ c = a \u2294 b", "start": [568, 1], "end": [569, 93], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_cancel'", "code": "theorem sup_sdiff_cancel' (hab : a \u2264 b) (hbc : b \u2264 c) : b \u2294 c \\ a = c", "start": [573, 1], "end": [574, 49], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_cancel_right", "code": "theorem sup_sdiff_cancel_right (h : a \u2264 b) : a \u2294 b \\ a = b", "start": [577, 1], "end": [578, 29], "kind": "commanddeclaration"}, {"full_name": "sdiff_sup_cancel", "code": "theorem sdiff_sup_cancel (h : b \u2264 a) : a \\ b \u2294 b = a", "start": [581, 1], "end": [581, 99], "kind": "commanddeclaration"}, {"full_name": "sup_le_of_le_sdiff_left", "code": "theorem sup_le_of_le_sdiff_left (h : b \u2264 c \\ a) (hac : a \u2264 c) : a \u2294 b \u2264 c", "start": [584, 1], "end": [585, 33], "kind": "commanddeclaration"}, {"full_name": "sup_le_of_le_sdiff_right", "code": "theorem sup_le_of_le_sdiff_right (h : a \u2264 c \\ b) (hbc : b \u2264 c) : a \u2294 b \u2264 c", "start": [588, 1], "end": [589, 32], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_bot_iff", "code": "@[simp]\ntheorem sdiff_eq_bot_iff : a \\ b = \u22a5 \u2194 a \u2264 b", "start": [592, 1], "end": [593, 95], "kind": "commanddeclaration"}, {"full_name": "sdiff_bot", "code": "@[simp]\ntheorem sdiff_bot : a \\ \u22a5 = a", "start": [596, 1], "end": [598, 64], "kind": "commanddeclaration"}, {"full_name": "bot_sdiff", "code": "@[simp]\ntheorem bot_sdiff : \u22a5 \\ a = \u22a5", "start": [601, 1], "end": [603, 28], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_sdiff_le_sdiff", "code": "theorem sdiff_sdiff_sdiff_le_sdiff : (a \\ b) \\ (a \\ c) \u2264 c \\ b", "start": [606, 1], "end": [609, 20], "kind": "commanddeclaration"}, {"full_name": "le_sup_sdiff_sup_sdiff", "code": "@[simp]\ntheorem le_sup_sdiff_sup_sdiff : a \u2264 b \u2294 (a \\ c \u2294 c \\ b)", "start": [612, 1], "end": [614, 45], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff", "code": "theorem sdiff_sdiff (a b c : \u03b1) : (a \\ b) \\ c = a \\ (b \u2294 c)", "start": [616, 1], "end": [617, 68], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_left", "code": "theorem sdiff_sdiff_left : (a \\ b) \\ c = a \\ (b \u2294 c)", "start": [620, 1], "end": [621, 20], "kind": "commanddeclaration"}, {"full_name": "sdiff_right_comm", "code": "theorem sdiff_right_comm (a b c : \u03b1) : (a \\ b) \\ c = (a \\ c) \\ b", "start": [624, 1], "end": [625, 34], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_comm", "code": "theorem sdiff_sdiff_comm : (a \\ b) \\ c = (a \\ c) \\ b", "start": [628, 1], "end": [629, 25], "kind": "commanddeclaration"}, {"full_name": "sdiff_idem", "code": "@[simp]\ntheorem sdiff_idem : (a \\ b) \\ b = a \\ b", "start": [632, 1], "end": [633, 79], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_self", "code": "@[simp]\ntheorem sdiff_sdiff_self : (a \\ b) \\ a = \u22a5", "start": [636, 1], "end": [637, 94], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_distrib", "code": "theorem sup_sdiff_distrib (a b c : \u03b1) : (a \u2294 b) \\ c = a \\ c \u2294 b \\ c", "start": [640, 1], "end": [641, 83], "kind": "commanddeclaration"}, {"full_name": "sdiff_inf_distrib", "code": "theorem sdiff_inf_distrib (a b c : \u03b1) : a \\ (b \u2293 c) = a \\ b \u2294 a \\ c", "start": [644, 1], "end": [647, 28], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff", "code": "theorem sup_sdiff : (a \u2294 b) \\ c = a \\ c \u2294 b \\ c", "start": [650, 1], "end": [651, 26], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_right_self", "code": "@[simp]\ntheorem sup_sdiff_right_self : (a \u2294 b) \\ b = a \\ b", "start": [654, 1], "end": [655, 96], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_left_self", "code": "@[simp]\ntheorem sup_sdiff_left_self : (a \u2294 b) \\ a = b \\ a", "start": [658, 1], "end": [659, 92], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_sdiff_right", "code": "theorem sdiff_le_sdiff_right (h : a \u2264 b) : a \\ c \u2264 b \\ c", "start": [662, 1], "end": [663, 44], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_sdiff_left", "code": "theorem sdiff_le_sdiff_left (h : a \u2264 b) : c \\ b \u2264 c \\ a", "start": [666, 1], "end": [667, 63], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_sdiff", "code": "theorem sdiff_le_sdiff (hab : a \u2264 b) (hcd : c \u2264 d) : a \\ d \u2264 b \\ c", "start": [670, 1], "end": [671, 62], "kind": "commanddeclaration"}, {"full_name": "sdiff_inf", "code": "theorem sdiff_inf : a \\ (b \u2293 c) = a \\ b \u2294 a \\ c", "start": [675, 1], "end": [676, 26], "kind": "commanddeclaration"}, {"full_name": "sdiff_inf_self_left", "code": "@[simp]\ntheorem sdiff_inf_self_left (a b : \u03b1) : a \\ (a \u2293 b) = a \\ b", "start": [679, 1], "end": [681, 41], "kind": "commanddeclaration"}, {"full_name": "sdiff_inf_self_right", "code": "@[simp]\ntheorem sdiff_inf_self_right (a b : \u03b1) : b \\ (a \u2293 b) = b \\ a", "start": [684, 1], "end": [686, 41], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sdiff_eq_left", "code": "theorem Disjoint.sdiff_eq_left (h : Disjoint a b) : a \\ b = a", "start": [689, 1], "end": [691, 39], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sdiff_eq_right", "code": "theorem Disjoint.sdiff_eq_right (h : Disjoint a b) : b \\ a = b", "start": [694, 1], "end": [695, 23], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sup_sdiff_cancel_left", "code": "theorem Disjoint.sup_sdiff_cancel_left (h : Disjoint a b) : (a \u2294 b) \\ a = b", "start": [698, 1], "end": [699, 59], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sup_sdiff_cancel_right", "code": "theorem Disjoint.sup_sdiff_cancel_right (h : Disjoint a b) : (a \u2294 b) \\ b = a", "start": [702, 1], "end": [703, 58], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_sdiff_of_le_left", "code": "theorem Disjoint.le_sdiff_of_le_left (hac : Disjoint a c) (hab : a \u2264 b) : a \u2264 b \\ c", "start": [706, 1], "end": [708, 57], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_le", "code": "theorem sdiff_sdiff_le : a \\ (a \\ b) \u2264 b", "start": [711, 1], "end": [712, 30], "kind": "commanddeclaration"}, {"full_name": "sdiff_triangle", "code": "theorem sdiff_triangle (a b c : \u03b1) : a \\ c \u2264 a \\ b \u2294 b \\ c", "start": [715, 1], "end": [717, 42], "kind": "commanddeclaration"}, {"full_name": "sdiff_sup_sdiff_cancel", "code": "theorem sdiff_sup_sdiff_cancel (hba : b \u2264 a) (hcb : c \u2264 b) : a \\ b \u2294 b \\ c = a \\ c", "start": [720, 1], "end": [721, 98], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_sdiff_of_sup_le_sup_left", "code": "theorem sdiff_le_sdiff_of_sup_le_sup_left (h : c \u2294 a \u2264 c \u2294 b) : a \\ c \u2264 b \\ c", "start": [724, 1], "end": [726, 31], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_sdiff_of_sup_le_sup_right", "code": "theorem sdiff_le_sdiff_of_sup_le_sup_right (h : a \u2294 c \u2264 b \u2294 c) : a \\ c \u2264 b \\ c", "start": [729, 1], "end": [731, 31], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_sup_left", "code": "@[simp]\ntheorem inf_sdiff_sup_left : a \\ c \u2293 (a \u2294 b) = a \\ c", "start": [734, 1], "end": [736, 47], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_sup_right", "code": "@[simp]\ntheorem inf_sdiff_sup_right : a \\ c \u2293 (b \u2294 a) = a \\ c", "start": [739, 1], "end": [741, 48], "kind": "commanddeclaration"}, {"full_name": "GeneralizedCoheytingAlgebra.toDistribLattice", "code": "instance (priority := 100) GeneralizedCoheytingAlgebra.toDistribLattice : DistribLattice \u03b1 :=\n  { \u2039GeneralizedCoheytingAlgebra \u03b1\u203a with\n    le_sup_inf :=\n      fun a b c => by simp_rw [\u2190 sdiff_le_iff, le_inf_iff, sdiff_le_iff, \u2190 le_inf_iff]; rfl }", "start": [745, 1], "end": [748, 94], "kind": "commanddeclaration"}, {"full_name": "Prod.generalizedCoheytingAlgebra", "code": "instance Prod.generalizedCoheytingAlgebra [GeneralizedCoheytingAlgebra \u03b2] :\n    GeneralizedCoheytingAlgebra (\u03b1 \u00d7 \u03b2) :=\n  { Prod.lattice \u03b1 \u03b2, Prod.orderBot \u03b1 \u03b2, Prod.sdiff \u03b1 \u03b2 with\n    sdiff_le_iff := fun _ _ _ => and_congr sdiff_le_iff sdiff_le_iff }", "start": [758, 1], "end": [761, 71], "kind": "commanddeclaration"}, {"full_name": "Pi.generalizedCoheytingAlgebra", "code": "instance Pi.generalizedCoheytingAlgebra {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, GeneralizedCoheytingAlgebra (\u03b1 i)] :\n    GeneralizedCoheytingAlgebra (\u2200 i, \u03b1 i) :=\n  { Pi.lattice, Pi.orderBot with\n    sdiff_le_iff := fun i => by simp [le_def] }", "start": [764, 1], "end": [767, 48], "kind": "commanddeclaration"}, {"full_name": "himp_bot", "code": "@[simp]\ntheorem himp_bot (a : \u03b1) : a \u21e8 \u22a5 = a\u1d9c", "start": [776, 1], "end": [778, 28], "kind": "commanddeclaration"}, {"full_name": "bot_himp", "code": "@[simp]\ntheorem bot_himp (a : \u03b1) : \u22a5 \u21e8 a = \u22a4", "start": [781, 1], "end": [783, 27], "kind": "commanddeclaration"}, {"full_name": "compl_sup_distrib", "code": "theorem compl_sup_distrib (a b : \u03b1) : (a \u2294 b)\u1d9c = a\u1d9c \u2293 b\u1d9c", "start": [786, 1], "end": [787, 41], "kind": "commanddeclaration"}, {"full_name": "compl_sup", "code": "@[simp]\ntheorem compl_sup : (a \u2294 b)\u1d9c = a\u1d9c \u2293 b\u1d9c", "start": [790, 1], "end": [792, 24], "kind": "commanddeclaration"}, {"full_name": "compl_le_himp", "code": "theorem compl_le_himp : a\u1d9c \u2264 a \u21e8 b", "start": [795, 1], "end": [796, 52], "kind": "commanddeclaration"}, {"full_name": "compl_sup_le_himp", "code": "theorem compl_sup_le_himp : a\u1d9c \u2294 b \u2264 a \u21e8 b", "start": [799, 1], "end": [800, 31], "kind": "commanddeclaration"}, {"full_name": "sup_compl_le_himp", "code": "theorem sup_compl_le_himp : b \u2294 a\u1d9c \u2264 a \u21e8 b", "start": [803, 1], "end": [804, 31], "kind": "commanddeclaration"}, {"full_name": "himp_compl", "code": "@[simp]\ntheorem himp_compl (a : \u03b1) : a \u21e8 a\u1d9c = a\u1d9c", "start": [808, 1], "end": [809, 84], "kind": "commanddeclaration"}, {"full_name": "himp_compl_comm", "code": "theorem himp_compl_comm (a b : \u03b1) : a \u21e8 b\u1d9c = b \u21e8 a\u1d9c", "start": [813, 1], "end": [813, 95], "kind": "commanddeclaration"}, {"full_name": "le_compl_iff_disjoint_right", "code": "theorem le_compl_iff_disjoint_right : a \u2264 b\u1d9c \u2194 Disjoint a b", "start": [816, 1], "end": [817, 52], "kind": "commanddeclaration"}, {"full_name": "le_compl_iff_disjoint_left", "code": "theorem le_compl_iff_disjoint_left : a \u2264 b\u1d9c \u2194 Disjoint b a", "start": [820, 1], "end": [821, 50], "kind": "commanddeclaration"}, {"full_name": "le_compl_comm", "code": "theorem le_compl_comm : a \u2264 b\u1d9c \u2194 b \u2264 a\u1d9c", "start": [824, 1], "end": [825, 63], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_compl_right", "code": "alias \u27e8_, Disjoint.le_compl_right\u27e9 := le_compl_iff_disjoint_right", "start": [828, 1], "end": [828, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Disjoint.le_compl_left", "code": "alias \u27e8_, Disjoint.le_compl_left\u27e9 := le_compl_iff_disjoint_left", "start": [831, 1], "end": [831, 64], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_compl_iff_le_compl", "code": "alias le_compl_iff_le_compl := le_compl_comm", "start": [834, 1], "end": [834, 45], "kind": "stdtacticaliasalias"}, {"full_name": "le_compl_of_le_compl", "code": "alias \u27e8le_compl_of_le_compl, _\u27e9 := le_compl_comm", "start": [837, 1], "end": [837, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "disjoint_compl_left", "code": "theorem disjoint_compl_left : Disjoint a\u1d9c a", "start": [840, 1], "end": [841, 59], "kind": "commanddeclaration"}, {"full_name": "disjoint_compl_right", "code": "theorem disjoint_compl_right : Disjoint a a\u1d9c", "start": [844, 1], "end": [845, 27], "kind": "commanddeclaration"}, {"full_name": "LE.le.disjoint_compl_left", "code": "theorem LE.le.disjoint_compl_left (h : b \u2264 a) : Disjoint a\u1d9c b", "start": [848, 1], "end": [849, 35], "kind": "commanddeclaration"}, {"full_name": "LE.le.disjoint_compl_right", "code": "theorem LE.le.disjoint_compl_right (h : a \u2264 b) : Disjoint a b\u1d9c", "start": [852, 1], "end": [853, 35], "kind": "commanddeclaration"}, {"full_name": "IsCompl.compl_eq", "code": "theorem IsCompl.compl_eq (h : IsCompl a b) : a\u1d9c = b", "start": [856, 1], "end": [857, 83], "kind": "commanddeclaration"}, {"full_name": "IsCompl.eq_compl", "code": "theorem IsCompl.eq_compl (h : IsCompl a b) : a = b\u1d9c", "start": [860, 1], "end": [861, 88], "kind": "commanddeclaration"}, {"full_name": "compl_unique", "code": "theorem compl_unique (h\u2080 : a \u2293 b = \u22a5) (h\u2081 : a \u2294 b = \u22a4) : a\u1d9c = b", "start": [864, 1], "end": [865, 33], "kind": "commanddeclaration"}, {"full_name": "inf_compl_self", "code": "@[simp]\ntheorem inf_compl_self (a : \u03b1) : a \u2293 a\u1d9c = \u22a5", "start": [868, 1], "end": [870, 30], "kind": "commanddeclaration"}, {"full_name": "compl_inf_self", "code": "@[simp]\ntheorem compl_inf_self (a : \u03b1) : a\u1d9c \u2293 a = \u22a5", "start": [873, 1], "end": [875, 29], "kind": "commanddeclaration"}, {"full_name": "inf_compl_eq_bot", "code": "theorem inf_compl_eq_bot : a \u2293 a\u1d9c = \u22a5", "start": [878, 1], "end": [879, 19], "kind": "commanddeclaration"}, {"full_name": "compl_inf_eq_bot", "code": "theorem compl_inf_eq_bot : a\u1d9c \u2293 a = \u22a5", "start": [882, 1], "end": [883, 19], "kind": "commanddeclaration"}, {"full_name": "compl_top", "code": "@[simp]\ntheorem compl_top : (\u22a4 : \u03b1)\u1d9c = \u22a5", "start": [886, 1], "end": [888, 93], "kind": "commanddeclaration"}, {"full_name": "compl_bot", "code": "@[simp]\ntheorem compl_bot : (\u22a5 : \u03b1)\u1d9c = \u22a4", "start": [891, 1], "end": [892, 66], "kind": "commanddeclaration"}, {"full_name": "le_compl_self", "code": "@[simp] theorem le_compl_self : a \u2264 a\u1d9c \u2194 a = \u22a5", "start": [895, 1], "end": [896, 49], "kind": "commanddeclaration"}, {"full_name": "ne_compl_self", "code": "@[simp] theorem ne_compl_self [Nontrivial \u03b1] : a \u2260 a\u1d9c", "start": [898, 1], "end": [901, 12], "kind": "commanddeclaration"}, {"full_name": "compl_ne_self", "code": "@[simp] theorem compl_ne_self [Nontrivial \u03b1] : a\u1d9c \u2260 a", "start": [903, 1], "end": [904, 26], "kind": "commanddeclaration"}, {"full_name": "lt_compl_self", "code": "@[simp] theorem lt_compl_self [Nontrivial \u03b1] : a < a\u1d9c \u2194 a = \u22a5", "start": [906, 1], "end": [907, 30], "kind": "commanddeclaration"}, {"full_name": "le_compl_compl", "code": "theorem le_compl_compl : a \u2264 a\u1d9c\u1d9c", "start": [909, 1], "end": [910, 38], "kind": "commanddeclaration"}, {"full_name": "compl_anti", "code": "theorem compl_anti : Antitone (compl : \u03b1 \u2192 \u03b1)", "start": [913, 1], "end": [914, 44], "kind": "commanddeclaration"}, {"full_name": "compl_le_compl", "code": "@[gcongr]\ntheorem compl_le_compl (h : a \u2264 b) : b\u1d9c \u2264 a\u1d9c", "start": [917, 1], "end": [919, 15], "kind": "commanddeclaration"}, {"full_name": "compl_compl_compl", "code": "@[simp]\ntheorem compl_compl_compl (a : \u03b1) : a\u1d9c\u1d9c\u1d9c = a\u1d9c", "start": [922, 1], "end": [924, 54], "kind": "commanddeclaration"}, {"full_name": "disjoint_compl_compl_left_iff", "code": "@[simp]\ntheorem disjoint_compl_compl_left_iff : Disjoint a\u1d9c\u1d9c b \u2194 Disjoint a b", "start": [927, 1], "end": [929, 60], "kind": "commanddeclaration"}, {"full_name": "disjoint_compl_compl_right_iff", "code": "@[simp]\ntheorem disjoint_compl_compl_right_iff : Disjoint a b\u1d9c\u1d9c \u2194 Disjoint a b", "start": [932, 1], "end": [934, 61], "kind": "commanddeclaration"}, {"full_name": "compl_sup_compl_le", "code": "theorem compl_sup_compl_le : a\u1d9c \u2294 b\u1d9c \u2264 (a \u2293 b)\u1d9c", "start": [937, 1], "end": [938, 61], "kind": "commanddeclaration"}, {"full_name": "compl_compl_inf_distrib", "code": "theorem compl_compl_inf_distrib (a b : \u03b1) : (a \u2293 b)\u1d9c\u1d9c = a\u1d9c\u1d9c \u2293 b\u1d9c\u1d9c", "start": [941, 1], "end": [945, 29], "kind": "commanddeclaration"}, {"full_name": "compl_compl_himp_distrib", "code": "theorem compl_compl_himp_distrib (a b : \u03b1) : (a \u21e8 b)\u1d9c\u1d9c = a\u1d9c\u1d9c \u21e8 b\u1d9c\u1d9c", "start": [948, 1], "end": [955, 22], "kind": "commanddeclaration"}, {"full_name": "ofDual_hnot", "code": "@[simp]\ntheorem ofDual_hnot (a : \u03b1\u1d52\u1d48) : ofDual (\uffe2a) = (ofDual a)\u1d9c", "start": [967, 1], "end": [969, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_compl", "code": "@[simp]\ntheorem toDual_compl (a : \u03b1) : toDual a\u1d9c = \uffe2toDual a", "start": [972, 1], "end": [974, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.heytingAlgebra", "code": "instance Prod.heytingAlgebra [HeytingAlgebra \u03b2] : HeytingAlgebra (\u03b1 \u00d7 \u03b2) :=\n  { Prod.generalizedHeytingAlgebra, Prod.boundedOrder \u03b1 \u03b2, Prod.hasCompl \u03b1 \u03b2 with\n     himp_bot := fun a => Prod.ext_iff.2 \u27e8himp_bot a.1, himp_bot a.2\u27e9 }", "start": [977, 1], "end": [979, 72], "kind": "commanddeclaration"}, {"full_name": "Pi.heytingAlgebra", "code": "instance Pi.heytingAlgebra {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, HeytingAlgebra (\u03b1 i)] :\n    HeytingAlgebra (\u2200 i, \u03b1 i) :=\n  { Pi.orderBot, Pi.generalizedHeytingAlgebra with\n    himp_bot := fun f => funext fun i => himp_bot (f i) }", "start": [982, 1], "end": [985, 58], "kind": "commanddeclaration"}, {"full_name": "top_sdiff'", "code": "@[simp]\ntheorem top_sdiff' (a : \u03b1) : \u22a4 \\ a = \uffe2a", "start": [994, 1], "end": [996, 31], "kind": "commanddeclaration"}, {"full_name": "sdiff_top", "code": "@[simp]\ntheorem sdiff_top (a : \u03b1) : a \\ \u22a4 = \u22a5", "start": [999, 1], "end": [1001, 28], "kind": "commanddeclaration"}, {"full_name": "hnot_inf_distrib", "code": "theorem hnot_inf_distrib (a b : \u03b1) : \uffe2(a \u2293 b) = \uffe2a \u2294 \uffe2b", "start": [1004, 1], "end": [1005, 44], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_hnot", "code": "theorem sdiff_le_hnot : a \\ b \u2264 \uffe2b", "start": [1008, 1], "end": [1009, 57], "kind": "commanddeclaration"}, {"full_name": "sdiff_le_inf_hnot", "code": "theorem sdiff_le_inf_hnot : a \\ b \u2264 a \u2293 \uffe2b", "start": [1012, 1], "end": [1013, 32], "kind": "commanddeclaration"}, {"full_name": "CoheytingAlgebra.toDistribLattice", "code": "instance (priority := 100) CoheytingAlgebra.toDistribLattice : DistribLattice \u03b1 :=\n  { \u2039CoheytingAlgebra \u03b1\u203a with\n    le_sup_inf :=\n      fun a b c => by simp_rw [\u2190 sdiff_le_iff, le_inf_iff, sdiff_le_iff, \u2190 le_inf_iff]; rfl }", "start": [1017, 1], "end": [1020, 94], "kind": "commanddeclaration"}, {"full_name": "hnot_sdiff", "code": "@[simp]\ntheorem hnot_sdiff (a : \u03b1) : \uffe2a \\ a = \uffe2a", "start": [1023, 1], "end": [1024, 88], "kind": "commanddeclaration"}, {"full_name": "hnot_sdiff_comm", "code": "theorem hnot_sdiff_comm (a b : \u03b1) : \uffe2a \\ b = \uffe2b \\ a", "start": [1027, 1], "end": [1027, 99], "kind": "commanddeclaration"}, {"full_name": "hnot_le_iff_codisjoint_right", "code": "theorem hnot_le_iff_codisjoint_right : \uffe2a \u2264 b \u2194 Codisjoint a b", "start": [1030, 1], "end": [1031, 57], "kind": "commanddeclaration"}, {"full_name": "hnot_le_iff_codisjoint_left", "code": "theorem hnot_le_iff_codisjoint_left : \uffe2a \u2264 b \u2194 Codisjoint b a", "start": [1034, 1], "end": [1035, 53], "kind": "commanddeclaration"}, {"full_name": "hnot_le_comm", "code": "theorem hnot_le_comm : \uffe2a \u2264 b \u2194 \uffe2b \u2264 a", "start": [1038, 1], "end": [1039, 65], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.hnot_le_right", "code": "alias \u27e8_, Codisjoint.hnot_le_right\u27e9 := hnot_le_iff_codisjoint_right", "start": [1042, 1], "end": [1042, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Codisjoint.hnot_le_left", "code": "alias \u27e8_, Codisjoint.hnot_le_left\u27e9 := hnot_le_iff_codisjoint_left", "start": [1045, 1], "end": [1045, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "codisjoint_hnot_right", "code": "theorem codisjoint_hnot_right : Codisjoint a (\uffe2a)", "start": [1048, 1], "end": [1049, 62], "kind": "commanddeclaration"}, {"full_name": "codisjoint_hnot_left", "code": "theorem codisjoint_hnot_left : Codisjoint (\uffe2a) a", "start": [1052, 1], "end": [1053, 29], "kind": "commanddeclaration"}, {"full_name": "LE.le.codisjoint_hnot_left", "code": "theorem LE.le.codisjoint_hnot_left (h : a \u2264 b) : Codisjoint (\uffe2a) b", "start": [1056, 1], "end": [1057, 36], "kind": "commanddeclaration"}, {"full_name": "LE.le.codisjoint_hnot_right", "code": "theorem LE.le.codisjoint_hnot_right (h : b \u2264 a) : Codisjoint a (\uffe2b)", "start": [1060, 1], "end": [1061, 36], "kind": "commanddeclaration"}, {"full_name": "IsCompl.hnot_eq", "code": "theorem IsCompl.hnot_eq (h : IsCompl a b) : \uffe2a = b", "start": [1064, 1], "end": [1065, 89], "kind": "commanddeclaration"}, {"full_name": "IsCompl.eq_hnot", "code": "theorem IsCompl.eq_hnot (h : IsCompl a b) : a = \uffe2b", "start": [1068, 1], "end": [1069, 84], "kind": "commanddeclaration"}, {"full_name": "sup_hnot_self", "code": "@[simp]\ntheorem sup_hnot_self (a : \u03b1) : a \u2294 \uffe2a = \u22a4", "start": [1072, 1], "end": [1074, 42], "kind": "commanddeclaration"}, {"full_name": "hnot_sup_self", "code": "@[simp]\ntheorem hnot_sup_self (a : \u03b1) : \uffe2a \u2294 a = \u22a4", "start": [1077, 1], "end": [1079, 41], "kind": "commanddeclaration"}, {"full_name": "hnot_bot", "code": "@[simp]\ntheorem hnot_bot : \uffe2(\u22a5 : \u03b1) = \u22a4", "start": [1082, 1], "end": [1084, 95], "kind": "commanddeclaration"}, {"full_name": "hnot_top", "code": "@[simp]\ntheorem hnot_top : \uffe2(\u22a4 : \u03b1) = \u22a5", "start": [1087, 1], "end": [1088, 68], "kind": "commanddeclaration"}, {"full_name": "hnot_hnot_le", "code": "theorem hnot_hnot_le : \uffe2\uffe2a \u2264 a", "start": [1091, 1], "end": [1092, 37], "kind": "commanddeclaration"}, {"full_name": "hnot_anti", "code": "theorem hnot_anti : Antitone (hnot : \u03b1 \u2192 \u03b1)", "start": [1095, 1], "end": [1095, 99], "kind": "commanddeclaration"}, {"full_name": "hnot_le_hnot", "code": "theorem hnot_le_hnot (h : a \u2264 b) : \uffe2b \u2264 \uffe2a", "start": [1098, 1], "end": [1099, 14], "kind": "commanddeclaration"}, {"full_name": "hnot_hnot_hnot", "code": "@[simp]\ntheorem hnot_hnot_hnot (a : \u03b1) : \uffe2\uffe2\uffe2a = \uffe2a", "start": [1102, 1], "end": [1104, 50], "kind": "commanddeclaration"}, {"full_name": "codisjoint_hnot_hnot_left_iff", "code": "@[simp]\ntheorem codisjoint_hnot_hnot_left_iff : Codisjoint (\uffe2\uffe2a) b \u2194 Codisjoint a b", "start": [1107, 1], "end": [1109, 59], "kind": "commanddeclaration"}, {"full_name": "codisjoint_hnot_hnot_right_iff", "code": "@[simp]\ntheorem codisjoint_hnot_hnot_right_iff : Codisjoint a (\uffe2\uffe2b) \u2194 Codisjoint a b", "start": [1112, 1], "end": [1114, 58], "kind": "commanddeclaration"}, {"full_name": "le_hnot_inf_hnot", "code": "theorem le_hnot_inf_hnot : \uffe2(a \u2294 b) \u2264 \uffe2a \u2293 \uffe2b", "start": [1117, 1], "end": [1118, 59], "kind": "commanddeclaration"}, {"full_name": "hnot_hnot_sup_distrib", "code": "theorem hnot_hnot_sup_distrib (a b : \u03b1) : \uffe2\uffe2(a \u2294 b) = \uffe2\uffe2a \u2294 \uffe2\uffe2b", "start": [1121, 1], "end": [1125, 30], "kind": "commanddeclaration"}, {"full_name": "hnot_hnot_sdiff_distrib", "code": "theorem hnot_hnot_sdiff_distrib (a b : \u03b1) : \uffe2\uffe2(a \\ b) = \uffe2\uffe2a \\ \uffe2\uffe2b", "start": [1128, 1], "end": [1135, 45], "kind": "commanddeclaration"}, {"full_name": "ofDual_compl", "code": "@[simp]\ntheorem ofDual_compl (a : \u03b1\u1d52\u1d48) : ofDual a\u1d9c = \uffe2ofDual a", "start": [1147, 1], "end": [1149, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_himp", "code": "@[simp]\ntheorem ofDual_himp (a b : \u03b1\u1d52\u1d48) : ofDual (a \u21e8 b) = ofDual b \\ ofDual a", "start": [1152, 1], "end": [1154, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_hnot", "code": "@[simp]\ntheorem toDual_hnot (a : \u03b1) : toDual (\uffe2a) = (toDual a)\u1d9c", "start": [1157, 1], "end": [1159, 6], "kind": "commanddeclaration"}, {"full_name": "toDual_sdiff", "code": "@[simp]\ntheorem toDual_sdiff (a b : \u03b1) : toDual (a \\ b) = toDual b \u21e8 toDual a", "start": [1162, 1], "end": [1164, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.coheytingAlgebra", "code": "instance Prod.coheytingAlgebra [CoheytingAlgebra \u03b2] : CoheytingAlgebra (\u03b1 \u00d7 \u03b2) :=\n  { Prod.lattice \u03b1 \u03b2, Prod.boundedOrder \u03b1 \u03b2, Prod.sdiff \u03b1 \u03b2, Prod.hnot \u03b1 \u03b2 with\n    sdiff_le_iff := fun _ _ _ => and_congr sdiff_le_iff sdiff_le_iff,\n    top_sdiff := fun a => Prod.ext_iff.2 \u27e8top_sdiff' a.1, top_sdiff' a.2\u27e9 }", "start": [1167, 1], "end": [1170, 76], "kind": "commanddeclaration"}, {"full_name": "Pi.coheytingAlgebra", "code": "instance Pi.coheytingAlgebra {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, CoheytingAlgebra (\u03b1 i)] :\n    CoheytingAlgebra (\u2200 i, \u03b1 i) :=\n  { Pi.orderTop, Pi.generalizedCoheytingAlgebra with\n    top_sdiff := fun f => funext fun i => top_sdiff' (f i) }", "start": [1173, 1], "end": [1176, 61], "kind": "commanddeclaration"}, {"full_name": "compl_le_hnot", "code": "theorem compl_le_hnot : a\u1d9c \u2264 \uffe2a", "start": [1185, 1], "end": [1186, 78], "kind": "commanddeclaration"}, {"full_name": "Prop.heytingAlgebra", "code": "instance Prop.heytingAlgebra : HeytingAlgebra Prop :=\n  { Prop.distribLattice, Prop.boundedOrder with\n    himp := (\u00b7 \u2192 \u00b7),\n    le_himp_iff := fun _ _ _ => and_imp.symm, himp_bot := fun _ => rfl }", "start": [1191, 1], "end": [1196, 73], "kind": "commanddeclaration"}, {"full_name": "himp_iff_imp", "code": "@[simp]\ntheorem himp_iff_imp (p q : Prop) : p \u21e8 q \u2194 p \u2192 q", "start": [1199, 1], "end": [1201, 10], "kind": "commanddeclaration"}, {"full_name": "compl_iff_not", "code": "@[simp]\ntheorem compl_iff_not (p : Prop) : p\u1d9c \u2194 \u00acp", "start": [1204, 1], "end": [1206, 10], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.toBiheytingAlgebra", "code": "@[reducible]\ndef LinearOrder.toBiheytingAlgebra [LinearOrder \u03b1] [BoundedOrder \u03b1] : BiheytingAlgebra \u03b1 :=\n  { LinearOrder.toLattice, \u2039BoundedOrder \u03b1\u203a with\n    himp := fun a b => if a \u2264 b then \u22a4 else b,\n    compl := fun a => if a = \u22a5 then \u22a4 else \u22a5,\n    le_himp_iff := fun a b c => by\n      change _ \u2264 ite _ _ _ \u2194 _\n      split_ifs with h\n      \u00b7 exact iff_of_true le_top (inf_le_of_right_le h)\n      \u00b7 rw [inf_le_iff, or_iff_left h],\n    himp_bot := fun a => if_congr le_bot_iff rfl rfl, sdiff := fun a b => if a \u2264 b then \u22a5 else a,\n    hnot := fun a => if a = \u22a4 then \u22a5 else \u22a4,\n    sdiff_le_iff := fun a b c => by\n      change ite _ _ _ \u2264 _ \u2194 _\n      split_ifs with h\n      \u00b7 exact iff_of_true bot_le (le_sup_of_le_left h)\n      \u00b7 rw [le_sup_iff, or_iff_right h],\n    top_sdiff := fun a => if_congr top_le_iff rfl rfl }", "start": [1210, 1], "end": [1230, 56], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.generalizedHeytingAlgebra", "code": "@[reducible]\nprotected def Function.Injective.generalizedHeytingAlgebra [Sup \u03b1] [Inf \u03b1] [Top \u03b1]\n    [HImp \u03b1] [GeneralizedHeytingAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_top : f \u22a4 = \u22a4) (map_himp : \u2200 a b, f (a \u21e8 b) = f a \u21e8 f b) : GeneralizedHeytingAlgebra \u03b1 :=\n  { hf.lattice f map_sup map_inf, \u2039Top \u03b1\u203a, \u2039HImp \u03b1\u203a with\n    le_top := fun a => by\n      change f _ \u2264 _\n      rw [map_top]\n      exact le_top,\n    le_himp_iff := fun a b c => by\n      change f _ \u2264 _ \u2194 f _ \u2264 _\n      erw [map_himp, map_inf, le_himp_iff] }", "start": [1236, 1], "end": [1249, 45], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.generalizedCoheytingAlgebra", "code": "@[reducible]\nprotected def Function.Injective.generalizedCoheytingAlgebra [Sup \u03b1] [Inf \u03b1] [Bot \u03b1]\n    [SDiff \u03b1] [GeneralizedCoheytingAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_bot : f \u22a5 = \u22a5) (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) :\n    GeneralizedCoheytingAlgebra \u03b1 :=\n  { hf.lattice f map_sup map_inf, \u2039Bot \u03b1\u203a, \u2039SDiff \u03b1\u203a with\n    bot_le := fun a => by\n      change f _ \u2264 _\n      rw [map_bot]\n      exact bot_le,\n    sdiff_le_iff := fun a b c => by\n      change f _ \u2264 _ \u2194 f _ \u2264 _\n      erw [map_sdiff, map_sup, sdiff_le_iff] }", "start": [1253, 1], "end": [1267, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.heytingAlgebra", "code": "@[reducible]\nprotected def Function.Injective.heytingAlgebra [Sup \u03b1] [Inf \u03b1] [Top \u03b1] [Bot \u03b1]\n    [HasCompl \u03b1] [HImp \u03b1] [HeytingAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) (map_compl : \u2200 a, f a\u1d9c = (f a)\u1d9c)\n    (map_himp : \u2200 a b, f (a \u21e8 b) = f a \u21e8 f b) : HeytingAlgebra \u03b1 :=\n  { hf.generalizedHeytingAlgebra f map_sup map_inf map_top map_himp, \u2039Bot \u03b1\u203a, \u2039HasCompl \u03b1\u203a with\n    bot_le := fun a => by\n      change f _ \u2264 _\n      rw [map_bot]\n      exact bot_le,\n    himp_bot := fun a => hf <| by erw [map_himp, map_compl, map_bot, himp_bot] }", "start": [1271, 1], "end": [1283, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.coheytingAlgebra", "code": "@[reducible]\nprotected def Function.Injective.coheytingAlgebra [Sup \u03b1] [Inf \u03b1] [Top \u03b1] [Bot \u03b1]\n    [HNot \u03b1] [SDiff \u03b1] [CoheytingAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) (map_hnot : \u2200 a, f (\uffe2a) = \uffe2f a)\n    (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) : CoheytingAlgebra \u03b1 :=\n  { hf.generalizedCoheytingAlgebra f map_sup map_inf map_bot map_sdiff, \u2039Top \u03b1\u203a, \u2039HNot \u03b1\u203a with\n    le_top := fun a => by\n      change f _ \u2264 _\n      rw [map_top]\n      exact le_top,\n    top_sdiff := fun a => hf <| by erw [map_sdiff, map_hnot, map_top, top_sdiff'] }", "start": [1287, 1], "end": [1299, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.biheytingAlgebra", "code": "@[reducible]\nprotected def Function.Injective.biheytingAlgebra [Sup \u03b1] [Inf \u03b1] [Top \u03b1] [Bot \u03b1]\n    [HasCompl \u03b1] [HNot \u03b1] [HImp \u03b1] [SDiff \u03b1] [BiheytingAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (hf : Injective f) (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b)\n    (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b) (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5)\n    (map_compl : \u2200 a, f a\u1d9c = (f a)\u1d9c) (map_hnot : \u2200 a, f (\uffe2a) = \uffe2f a)\n    (map_himp : \u2200 a b, f (a \u21e8 b) = f a \u21e8 f b) (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) :\n    BiheytingAlgebra \u03b1 :=\n  { hf.heytingAlgebra f map_sup map_inf map_top map_bot map_compl map_himp,\n    hf.coheytingAlgebra f map_sup map_inf map_top map_bot map_hnot map_sdiff with }", "start": [1303, 1], "end": [1313, 84], "kind": "commanddeclaration"}, {"full_name": "PUnit.biheytingAlgebra", "code": "instance biheytingAlgebra : BiheytingAlgebra PUnit.{u+1} :=\n  { PUnit.linearOrder.{u} with\n    top := unit,\n    bot := unit,\n    sup := fun _ _ => unit,\n    inf := fun _ _ => unit,\n    compl := fun _ => unit,\n    sdiff := fun _ _ => unit,\n    hnot := fun _ => unit,\n    himp := fun _ _ => unit,\n    le_top := fun _ => trivial,\n    le_sup_left := fun _ _ => trivial,\n    le_sup_right := fun _ _ => trivial,\n    sup_le := fun _ _ _ _ _ => trivial,\n    inf_le_left := fun _ _ => trivial,\n    inf_le_right := fun _ _ => trivial,\n    le_inf := fun _ _ _ _ _ => trivial,\n    bot_le := fun _ => trivial,\n    le_himp_iff := fun _ _ _ => Iff.rfl,\n    himp_bot := fun _ => rfl,\n    top_sdiff := fun _ => rfl,\n    sdiff_le_iff := fun _ _ _ => Iff.rfl }", "start": [1322, 1], "end": [1343, 43], "kind": "commanddeclaration"}, {"full_name": "PUnit.top_eq", "code": "@[simp]\ntheorem top_eq : (\u22a4 : PUnit) = unit", "start": [1345, 1], "end": [1347, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.bot_eq", "code": "@[simp]\ntheorem bot_eq : (\u22a5 : PUnit) = unit", "start": [1350, 1], "end": [1352, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.sup_eq", "code": "@[simp, nolint simpNF]\ntheorem sup_eq : a \u2294 b = unit", "start": [1355, 1], "end": [1357, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.inf_eq", "code": "@[simp, nolint simpNF]\ntheorem inf_eq : a \u2293 b = unit", "start": [1360, 1], "end": [1362, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.compl_eq", "code": "@[simp]\ntheorem compl_eq : a\u1d9c = unit", "start": [1365, 1], "end": [1367, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.sdiff_eq", "code": "@[simp, nolint simpNF]\ntheorem sdiff_eq : a \\ b = unit", "start": [1370, 1], "end": [1372, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.hnot_eq", "code": "@[simp, nolint simpNF]\ntheorem hnot_eq : \uffe2a = unit", "start": [1375, 1], "end": [1377, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.himp_eq", "code": "@[simp, nolint simpNF]\ntheorem himp_eq : a \u21e8 b = unit", "start": [1381, 1], "end": [1383, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Units.lean", "imports": ["Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Group.isUnit", "code": "@[to_additive]\ntheorem Group.isUnit {G} [Group G] (g : G) : IsUnit g", "start": [34, 1], "end": [36, 50], "kind": "commanddeclaration"}, {"full_name": "IsUnit.eq_on_inv", "code": "@[to_additive\n  \"If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\n  additive unit `x`, then they are equal at `-x`.\"]\ntheorem IsUnit.eq_on_inv {F G N} [DivisionMonoid G] [Monoid N] [MonoidHomClass F G N]\n    {x : G} (hx : IsUnit x) (f g : F) (h : f x = g x) : f x\u207b\u00b9 = g x\u207b\u00b9", "start": [42, 1], "end": [50, 52], "kind": "commanddeclaration"}, {"full_name": "eq_on_inv", "code": "@[to_additive\n    \"If two homomorphism from an additive group to an additive monoid are equal at `x`,\n    then they are equal at `-x`.\"]\ntheorem eq_on_inv {F G M} [Group G] [Monoid M] [MonoidHomClass F G M]\n    (f g : F) {x : G} (h : f x = g x) : f x\u207b\u00b9 = g x\u207b\u00b9", "start": [54, 1], "end": [60, 35], "kind": "commanddeclaration"}, {"full_name": "Units.map", "code": "@[to_additive \"The additive homomorphism on `AddUnit`s induced by an `AddMonoidHom`.\"]\ndef map (f : M \u2192* N) : M\u02e3 \u2192* N\u02e3 :=\n  MonoidHom.mk'\n    (fun u => \u27e8f u.val, f u.inv,\n      by rw [\u2190 f.map_mul, u.val_inv, f.map_one],\n      by rw [\u2190 f.map_mul, u.inv_val, f.map_one]\u27e9)\n    fun x y => ext (f.map_mul x y)", "start": [70, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Units.coe_map", "code": "@[to_additive (attr := simp)]\ntheorem coe_map (f : M \u2192* N) (x : M\u02e3) : \u2191(map f x) = f x", "start": [81, 1], "end": [82, 64], "kind": "commanddeclaration"}, {"full_name": "Units.coe_map_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_map_inv (f : M \u2192* N) (u : M\u02e3) : \u2191(map f u)\u207b\u00b9 = f \u2191u\u207b\u00b9", "start": [86, 1], "end": [87, 73], "kind": "commanddeclaration"}, {"full_name": "Units.map_comp", "code": "@[to_additive (attr := simp)]\ntheorem map_comp (f : M \u2192* N) (g : N \u2192* P) : map (g.comp f) = (map g).comp (map f)", "start": [91, 1], "end": [92, 90], "kind": "commanddeclaration"}, {"full_name": "Units.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id : map (MonoidHom.id M) = MonoidHom.id M\u02e3", "start": [98, 1], "end": [99, 71], "kind": "commanddeclaration"}, {"full_name": "Units.coeHom", "code": "@[to_additive \"Coercion `AddUnits M \u2192 M` as an AddMonoid homomorphism.\"]\ndef coeHom : M\u02e3 \u2192* M where\n  toFun := Units.val; map_one' := val_one; map_mul' := val_mul", "start": [103, 1], "end": [106, 63], "kind": "commanddeclaration"}, {"full_name": "Units.coeHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem coeHom_apply (x : M\u02e3) : coeHom M x = \u2191x", "start": [112, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "Units.val_pow_eq_pow_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_pow_eq_pow_val (u : M\u02e3) (n : \u2115) : ((u ^ n : M\u02e3) : M) = (u : M) ^ n", "start": [117, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "Units.val_div_eq_div_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_div_eq_div_val : \u2200 u\u2081 u\u2082 : \u03b1\u02e3, \u2191(u\u2081 / u\u2082) = (u\u2081 / u\u2082 : \u03b1)", "start": [127, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Units.val_zpow_eq_zpow_val", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem val_zpow_eq_zpow_val : \u2200 (u : \u03b1\u02e3) (n : \u2124), ((u ^ n : \u03b1\u02e3) : \u03b1) = (u : \u03b1) ^ n", "start": [133, 1], "end": [135, 28], "kind": "commanddeclaration"}, {"full_name": "divp_eq_div", "code": "@[field_simps]\ntheorem _root_.divp_eq_div (a : \u03b1) (u : \u03b1\u02e3) : a /\u209a u = a / u", "start": [139, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "map_units_inv", "code": "@[to_additive (attr := simp)]\ntheorem _root_.map_units_inv {F : Type*} [MonoidHomClass F M \u03b1] (f : F) (u : Units M) :\n    f \u2191u\u207b\u00b9 = (f u)\u207b\u00b9", "start": [144, 1], "end": [146, 71], "kind": "commanddeclaration"}, {"full_name": "Units.liftRight", "code": "@[to_additive\n  \"If a map `g : M \u2192 AddUnits N` agrees with a homomorphism `f : M \u2192+ N`, then this map\n  is an AddMonoid homomorphism too.\"]\ndef liftRight (f : M \u2192* N) (g : M \u2192 N\u02e3) (h : \u2200 x, \u2191(g x) = f x) : M \u2192* N\u02e3 where\n  toFun := g\n  map_one' := by ext; dsimp only; rw [h 1]; exact f.map_one map_mul' x y := Units.ext <| by simp only [h, val_mul, f.map_mul]", "start": [152, 1], "end": [160, 68], "kind": "commanddeclaration"}, {"full_name": "Units.coe_liftRight", "code": "@[to_additive (attr := simp)]\ntheorem coe_liftRight {f : M \u2192* N} {g : M \u2192 N\u02e3} (h : \u2200 x, \u2191(g x) = f x) (x) :\n    (liftRight f g h x : N) = f x", "start": [164, 1], "end": [166, 41], "kind": "commanddeclaration"}, {"full_name": "Units.mul_liftRight_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv {f : M \u2192* N} {g : M \u2192 N\u02e3} (h : \u2200 x, \u2191(g x) = f x) (x) :\n    f x * \u2191(liftRight f g h x)\u207b\u00b9 = 1", "start": [170, 1], "end": [173, 62], "kind": "commanddeclaration"}, {"full_name": "Units.liftRight_inv_mul", "code": "@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul {f : M \u2192* N} {g : M \u2192 N\u02e3} (h : \u2200 x, \u2191(g x) = f x) (x) :\n    \u2191(liftRight f g h x)\u207b\u00b9 * f x = 1", "start": [177, 1], "end": [180, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toHomUnits", "code": "@[to_additive\n  \"If `f` is a homomorphism from an additive group `G` to an additive monoid `M`,\n  then its image lies in the `AddUnits` of `M`,\n  and `f.toHomUnits` is the corresponding homomorphism from `G` to `AddUnits M`.\"]\ndef toHomUnits {G M : Type*} [Group G] [Monoid M] (f : G \u2192* M) : G \u2192* M\u02e3 :=\n  Units.liftRight f (fun g => \u27e8f g, f g\u207b\u00b9, map_mul_eq_one f (mul_inv_self _),\n    map_mul_eq_one f (inv_mul_self _)\u27e9)\n    fun _ => rfl", "start": [188, 1], "end": [198, 17], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_toHomUnits", "code": "@[to_additive (attr := simp)]\ntheorem coe_toHomUnits {G M : Type*} [Group G] [Monoid M] (f : G \u2192* M) (g : G) :\n    (f.toHomUnits g : M) = f g", "start": [202, 1], "end": [204, 38], "kind": "commanddeclaration"}, {"full_name": "IsUnit.map", "code": "@[to_additive]\ntheorem map [MonoidHomClass F M N] (f : F) {x : M} (h : IsUnit x) : IsUnit (f x)", "start": [218, 1], "end": [220, 66], "kind": "commanddeclaration"}, {"full_name": "IsUnit.of_leftInverse", "code": "@[to_additive]\ntheorem of_leftInverse [MonoidHomClass F M N] [MonoidHomClass G N M] {f : F} {x : M} (g : G)\n    (hfg : Function.LeftInverse g f) (h : IsUnit (f x)) : IsUnit x", "start": [224, 1], "end": [227, 35], "kind": "commanddeclaration"}, {"full_name": "isUnit_map_of_leftInverse", "code": "@[to_additive]\ntheorem _root_.isUnit_map_of_leftInverse [MonoidHomClass F M N] [MonoidHomClass G N M]\n    {f : F} {x : M} (g : G) (hfg : Function.LeftInverse g f) :\n    IsUnit (f x) \u2194 IsUnit x", "start": [231, 1], "end": [234, 61], "kind": "commanddeclaration"}, {"full_name": "IsUnit.liftRight", "code": "@[to_additive\n  \"If a homomorphism `f : M \u2192+ N` sends each element to an `IsAddUnit`, then it can be\n  lifted to `f : M \u2192+ AddUnits N`. See also `AddUnits.liftRight` for a computable version.\"]\nnoncomputable def liftRight (f : M \u2192* N) (hf : \u2200 x, IsUnit (f x)) : M \u2192* N\u02e3 :=\n  (Units.liftRight f fun x => (hf x).unit) fun _ => rfl", "start": [238, 1], "end": [244, 56], "kind": "commanddeclaration"}, {"full_name": "IsUnit.coe_liftRight", "code": "@[to_additive]\ntheorem coe_liftRight (f : M \u2192* N) (hf : \u2200 x, IsUnit (f x)) (x) :\n    (IsUnit.liftRight f hf x : N) = f x", "start": [248, 1], "end": [250, 47], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_liftRight_inv", "code": "@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv (f : M \u2192* N) (h : \u2200 x, IsUnit (f x)) (x) :\n    f x * \u2191(IsUnit.liftRight f h x)\u207b\u00b9 = 1", "start": [254, 1], "end": [256, 87], "kind": "commanddeclaration"}, {"full_name": "IsUnit.liftRight_inv_mul", "code": "@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul (f : M \u2192* N) (h : \u2200 x, IsUnit (f x)) (x) :\n    \u2191(IsUnit.liftRight f h x)\u207b\u00b9 * f x = 1", "start": [260, 1], "end": [262, 87], "kind": "commanddeclaration"}, {"full_name": "IsUnit.unit'", "code": "@[to_additive (attr := simps val)\n  \"The element of the additive group of additive units, corresponding to an element of\n  an additive monoid which is an additive unit. As opposed to `IsAddUnit.addUnit`, the negation is\n  computable and comes from the negation on `\u03b1`. This is useful to transfer properties of negation\n  in `AddUnits \u03b1` to `\u03b1`. See also `toAddUnits`.\"]\ndef unit' (h : IsUnit a) : \u03b1\u02e3 :=\n  \u27e8a, a\u207b\u00b9, h.mul_inv_cancel, h.inv_mul_cancel\u27e9", "start": [272, 1], "end": [281, 47], "kind": "commanddeclaration"}, {"full_name": "IsUnit.val_inv_unit'", "code": "@[to_additive] theorem val_inv_unit' (h : IsUnit a) : \u2191(h.unit'\u207b\u00b9) = a\u207b\u00b9", "start": [288, 1], "end": [288, 80], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_inv_cancel_left", "code": "@[to_additive (attr := simp)]\nprotected theorem mul_inv_cancel_left (h : IsUnit a) : \u2200 b, a * (a\u207b\u00b9 * b) = b", "start": [292, 1], "end": [294, 30], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_mul_cancel_left", "code": "@[to_additive (attr := simp)]\nprotected theorem inv_mul_cancel_left (h : IsUnit a) : \u2200 b, a\u207b\u00b9 * (a * b) = b", "start": [298, 1], "end": [300, 30], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_inv_cancel_right", "code": "@[to_additive (attr := simp)]\nprotected theorem mul_inv_cancel_right (h : IsUnit b) (a : \u03b1) : a * b * b\u207b\u00b9 = a", "start": [304, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_mul_cancel_right", "code": "@[to_additive (attr := simp)]\nprotected theorem inv_mul_cancel_right (h : IsUnit b) (a : \u03b1) : a * b\u207b\u00b9 * b = a", "start": [310, 1], "end": [312, 33], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_self", "code": "@[to_additive]\nprotected theorem div_self (h : IsUnit a) : a / a = 1", "start": [316, 1], "end": [317, 98], "kind": "commanddeclaration"}, {"full_name": "IsUnit.eq_mul_inv_iff_mul_eq", "code": "@[to_additive]\nprotected theorem eq_mul_inv_iff_mul_eq (h : IsUnit c) : a = b * c\u207b\u00b9 \u2194 a * c = b", "start": [321, 1], "end": [323, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.eq_inv_mul_iff_mul_eq", "code": "@[to_additive]\nprotected theorem eq_inv_mul_iff_mul_eq (h : IsUnit b) : a = b\u207b\u00b9 * c \u2194 b * a = c", "start": [327, 1], "end": [329, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_mul_eq_iff_eq_mul", "code": "@[to_additive]\nprotected theorem inv_mul_eq_iff_eq_mul (h : IsUnit a) : a\u207b\u00b9 * b = c \u2194 b = a * c", "start": [333, 1], "end": [335, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_inv_eq_iff_eq_mul", "code": "@[to_additive]\nprotected theorem mul_inv_eq_iff_eq_mul (h : IsUnit b) : a * b\u207b\u00b9 = c \u2194 a = c * b", "start": [339, 1], "end": [341, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_inv_eq_one", "code": "@[to_additive]\nprotected theorem mul_inv_eq_one (h : IsUnit b) : a * b\u207b\u00b9 = 1 \u2194 a = b", "start": [345, 1], "end": [347, 38], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv_mul_eq_one", "code": "@[to_additive]\nprotected theorem inv_mul_eq_one (h : IsUnit a) : a\u207b\u00b9 * b = 1 \u2194 a = b", "start": [351, 1], "end": [353, 38], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_eq_one_iff_eq_inv", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff_eq_inv (h : IsUnit b) : a * b = 1 \u2194 a = b\u207b\u00b9", "start": [357, 1], "end": [359, 45], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_eq_one_iff_inv_eq", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff_inv_eq (h : IsUnit a) : a * b = 1 \u2194 a\u207b\u00b9 = b", "start": [363, 1], "end": [365, 45], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_mul_cancel", "code": "@[to_additive (attr := simp)]\nprotected theorem div_mul_cancel (h : IsUnit b) (a : \u03b1) : a / b * b = a", "start": [369, 1], "end": [371, 46], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_div_cancel", "code": "@[to_additive (attr := simp)]\nprotected theorem mul_div_cancel (h : IsUnit b) (a : \u03b1) : a * b / b = a", "start": [375, 1], "end": [377, 46], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_one_div_cancel", "code": "@[to_additive]\nprotected theorem mul_one_div_cancel (h : IsUnit a) : a * (1 / a) = 1", "start": [381, 1], "end": [382, 85], "kind": "commanddeclaration"}, {"full_name": "IsUnit.one_div_mul_cancel", "code": "@[to_additive]\nprotected theorem one_div_mul_cancel (h : IsUnit a) : 1 / a * a = 1", "start": [386, 1], "end": [387, 83], "kind": "commanddeclaration"}, {"full_name": "IsUnit.inv", "code": "@[to_additive]\ntheorem inv (h : IsUnit a) : IsUnit a\u207b\u00b9", "start": [391, 1], "end": [395, 23], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div", "code": "@[to_additive]\ntheorem div (ha : IsUnit a) (hb : IsUnit b) : IsUnit (a / b)", "start": [399, 1], "end": [402, 22], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_left_inj", "code": "@[to_additive]\nprotected theorem div_left_inj (h : IsUnit c) : a / c = b / c \u2194 a = b", "start": [406, 1], "end": [409, 39], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_eq_iff", "code": "@[to_additive]\nprotected theorem div_eq_iff (h : IsUnit b) : a / b = c \u2194 a = c * b", "start": [413, 1], "end": [415, 47], "kind": "commanddeclaration"}, {"full_name": "IsUnit.eq_div_iff", "code": "@[to_additive]\nprotected theorem eq_div_iff (h : IsUnit c) : a = b / c \u2194 a * c = b", "start": [419, 1], "end": [421, 47], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_eq_of_eq_mul", "code": "@[to_additive]\nprotected theorem div_eq_of_eq_mul (h : IsUnit b) : a = c * b \u2192 a / b = c", "start": [425, 1], "end": [427, 17], "kind": "commanddeclaration"}, {"full_name": "IsUnit.eq_div_of_mul_eq", "code": "@[to_additive]\nprotected theorem eq_div_of_mul_eq (h : IsUnit c) : a * c = b \u2192 a = b / c", "start": [431, 1], "end": [433, 17], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_eq_one_iff_eq", "code": "@[to_additive]\nprotected theorem div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 \u2194 a = b", "start": [437, 1], "end": [439, 55], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_mul_left", "code": "@[to_additive \"The `AddGroup` version of this lemma is `sub_add_cancel''`\"]\nprotected theorem div_mul_left (h : IsUnit b) : b / (a * b) = 1 / a", "start": [443, 1], "end": [446, 67], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_div_mul_right", "code": "@[to_additive]\nprotected theorem mul_div_mul_right (h : IsUnit c) (a b : \u03b1) : a * c / (b * c) = a / b", "start": [450, 1], "end": [452, 76], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_mul_div", "code": "@[to_additive]\nprotected theorem mul_mul_div (a : \u03b1) (h : IsUnit b) : a * b * (1 / b) = a", "start": [456, 1], "end": [457, 90], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_mul_right", "code": "@[to_additive]\nprotected theorem div_mul_right (h : IsUnit a) (b : \u03b1) : a / (a * b) = 1 / b", "start": [467, 1], "end": [469, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_div_cancel_left", "code": "@[to_additive]\nprotected theorem mul_div_cancel_left (h : IsUnit a) (b : \u03b1) : a * b / a = b", "start": [473, 1], "end": [475, 34], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_div_cancel'", "code": "@[to_additive]\nprotected theorem mul_div_cancel' (h : IsUnit a) (b : \u03b1) : a * (b / a) = b", "start": [479, 1], "end": [481, 34], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_div_mul_left", "code": "@[to_additive]\nprotected theorem mul_div_mul_left (h : IsUnit c) (a b : \u03b1) : c * a / (c * b) = a / b", "start": [485, 1], "end": [487, 51], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_eq_mul_of_div_eq_div", "code": "@[to_additive]\nprotected theorem mul_eq_mul_of_div_eq_div (hb : IsUnit b) (hd : IsUnit d)\n    (a c : \u03b1) (h : a / b = c / d) : a * d = c * b", "start": [491, 1], "end": [494, 92], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_eq_div_iff", "code": "@[to_additive]\nprotected theorem div_eq_div_iff (hb : IsUnit b) (hd : IsUnit d) :\n    a / b = c / d \u2194 a * d = c * b", "start": [498, 1], "end": [502, 23], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_div_cancel", "code": "@[to_additive]\nprotected theorem div_div_cancel (h : IsUnit a) : a / (a / b) = b", "start": [506, 1], "end": [508, 49], "kind": "commanddeclaration"}, {"full_name": "IsUnit.div_div_cancel_left", "code": "@[to_additive]\nprotected theorem div_div_cancel_left (h : IsUnit a) : a / b / a = b\u207b\u00b9", "start": [512, 1], "end": [514, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Equiv/Basic.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Algebra/Hom/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/FunLike/Equiv.lean", "Mathlib/Logic/Equiv/Basic.lean"], "premises": [{"full_name": "OneHom.inverse", "code": "@[to_additive (attr := simps)\n  \"Make a `ZeroHom` inverse from the bijective inverse of a `ZeroHom`\"]\ndef OneHom.inverse [One M] [One N]\n    (f : OneHom M N) (g : N \u2192 M)\n    (h\u2081 : Function.LeftInverse g f) :\n  OneHom N M :=\n  { toFun := g,\n    map_one' := by rw [\u2190 f.map_one, h\u2081] }", "start": [35, 1], "end": [43, 42], "kind": "commanddeclaration"}, {"full_name": "MulHom.inverse", "code": "@[to_additive (attr := simps)\n  \"Makes an additive inverse from a bijection which preserves addition.\"]\ndef MulHom.inverse [Mul M] [Mul N] (f : M \u2192\u2099* N) (g : N \u2192 M)\n    (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : N \u2192\u2099* M where\n  toFun := g\n  map_mul' x y :=\n    calc\n      g (x * y) = g (f (g x) * f (g y)) := by rw [h\u2082 x, h\u2082 y]\n      _ = g (f (g x * g y)) := by rw [f.map_mul]\n      _ = g x * g y := h\u2081 _", "start": [45, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.inverse", "code": "@[to_additive (attr := simps)\n  \"The inverse of a bijective `AddMonoidHom` is an `AddMonoidHom`.\"]\ndef MonoidHom.inverse {A B : Type*} [Monoid A] [Monoid B] (f : A \u2192* B) (g : B \u2192 A)\n    (h\u2081 : Function.LeftInverse g f) (h\u2082 : Function.RightInverse g f) : B \u2192* A :=\n  { (f : OneHom A B).inverse g h\u2081,\n    (f : A \u2192\u2099* B).inverse g h\u2081 h\u2082 with toFun := g }", "start": [60, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "AddEquiv", "code": "structure AddEquiv (A B : Type*) [Add A] [Add B] extends A \u2243 B, AddHom A B", "start": [72, 1], "end": [73, 75], "kind": "commanddeclaration"}, {"full_name": "AddEquivClass", "code": "class AddEquivClass (F : Type*) (A B : outParam (Type*)) [Add A] [Add B]\n    extends EquivLike F A B where\n  \n  map_add : \u2200 (f : F) (a b), f (a + b) = f a + f b", "start": [76, 1], "end": [81, 51], "kind": "commanddeclaration"}, {"full_name": "MulEquiv", "code": "@[to_additive]\nstructure MulEquiv (M N : Type*) [Mul M] [Mul N] extends M \u2243 N, M \u2192\u2099* N", "start": [92, 1], "end": [94, 72], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass", "code": "@[to_additive]\nclass MulEquivClass (F : Type*) (A B : outParam (Type*)) [Mul A] [Mul B] extends\n  EquivLike F A B where\n  \n  map_mul : \u2200 (f : F) (a b), f (a * b) = f a * f b", "start": [108, 1], "end": [114, 51], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.instMulHomClass", "code": "@[to_additive]\ninstance (priority := 100) instMulHomClass (F : Type*)\n    [Mul M] [Mul N] [h : MulEquivClass F M N] : MulHomClass F M N :=\n  { h with coe := h.coe, coe_injective' := FunLike.coe_injective' }", "start": [128, 1], "end": [131, 68], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.instMonoidHomClass", "code": "@[to_additive]\ninstance (priority := 100) instMonoidHomClass\n    [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] :\n    MonoidHomClass F M N :=\n  { MulEquivClass.instMulHomClass F with\n    coe := fun _ => _,\n    map_one := fun e =>\n      calc\n        e 1 = e 1 * 1 := (mul_one _).symm\n        _ = e 1 * e (MulEquivClass.toEquivLike.inv e (1 : N) : M) :=\n          congr_arg _ (MulEquivClass.toEquivLike.right_inv e 1).symm\n        _ = e (MulEquivClass.toEquivLike.inv e (1 : N)) := by rw [\u2190 map_mul, one_mul]\n        _ = 1 := MulEquivClass.toEquivLike.right_inv e 1 }", "start": [134, 1], "end": [146, 59], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.toZeroHomClass", "code": "instance (priority := 100) toZeroHomClass\n    [MulZeroClass \u03b1] [MulZeroClass \u03b2] [MulEquivClass F \u03b1 \u03b2] :\n    ZeroHomClass F \u03b1 \u03b2 where\n  map_zero := fun e =>\n    calc\n      e 0 = e 0 * e (EquivLike.inv e 0) := by rw [\u2190 map_mul, zero_mul]\n        _ = 0 := by simp", "start": [149, 1], "end": [155, 25], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.toMonoidWithZeroHomClass", "code": "instance (priority := 100) toMonoidWithZeroHomClass\n    [MulZeroOneClass \u03b1] [MulZeroOneClass \u03b2] [MulEquivClass F \u03b1 \u03b2] :\n    MonoidWithZeroHomClass F \u03b1 \u03b2 :=\n  { MulEquivClass.instMonoidHomClass F, MulEquivClass.toZeroHomClass F with }", "start": [158, 1], "end": [161, 78], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.map_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem map_eq_one_iff {M N} [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] (h : F) {x : M} :\n    h x = 1 \u2194 x = 1", "start": [166, 1], "end": [168, 71], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.map_ne_one_iff", "code": "@[to_additive]\ntheorem map_ne_one_iff {M N} [MulOneClass M] [MulOneClass N] [MulEquivClass F M N] (h : F) {x : M} :\n    h x \u2260 1 \u2194 x \u2260 1", "start": [172, 1], "end": [174, 71], "kind": "commanddeclaration"}, {"full_name": "MulEquivClass.toMulEquiv", "code": "@[to_additive (attr := coe)\n\"Turn an element of a type `F` satisfying `AddEquivClass F \u03b1 \u03b2` into an actual\n`AddEquiv`. This is declared as the default coercion from `F` to `\u03b1 \u2243+ \u03b2`.\"]\ndef MulEquivClass.toMulEquiv [Mul \u03b1] [Mul \u03b2] [MulEquivClass F \u03b1 \u03b2] (f : F) : \u03b1 \u2243* \u03b2 :=\n  { (f : \u03b1 \u2243 \u03b2), (f : \u03b1 \u2192\u2099* \u03b2) with }", "start": [180, 1], "end": [186, 38], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toEquiv_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toEquiv_eq_coe (f : M \u2243* N) : f.toEquiv = f", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toMulHom_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem toMulHom_eq_coe (f : M \u2243* N) : f.toMulHom = \u2191f", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_toEquiv", "code": "@[to_additive (attr := simp)]\ntheorem coe_toEquiv (f : M \u2243* N) : \u21d1(f : M \u2243 N) = f", "start": [231, 1], "end": [232, 59], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_toMulHom", "code": "@[to_additive (attr := simp 1100)]\ntheorem coe_toMulHom {f : M \u2243* N} : (f.toMulHom : M \u2192 N) = f", "start": [238, 1], "end": [239, 68], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_mul", "code": "@[to_additive \"An additive isomorphism preserves addition.\"]\nprotected theorem map_mul (f : M \u2243* N) : \u2200 x y, f (x * y) = f x * f y", "start": [243, 1], "end": [246, 19], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.mk'", "code": "@[to_additive \"Makes an additive isomorphism from a bijection which preserves addition.\"]\ndef mk' (f : M \u2243 N) (h : \u2200 x y, f (x * y) = f x * f y) : M \u2243* N := \u27e8f, h\u27e9", "start": [250, 1], "end": [252, 74], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.bijective", "code": "@[to_additive]\nprotected theorem bijective (e : M \u2243* N) : Function.Bijective e", "start": [256, 1], "end": [258, 24], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.injective", "code": "@[to_additive]\nprotected theorem injective (e : M \u2243* N) : Function.Injective e", "start": [262, 1], "end": [264, 24], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.surjective", "code": "@[to_additive]\nprotected theorem surjective (e : M \u2243* N) : Function.Surjective e", "start": [268, 1], "end": [270, 25], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.refl", "code": "@[to_additive (attr := refl) \"The identity map is an additive isomorphism.\"]\ndef refl (M : Type*) [Mul M] : M \u2243* M :=\n  { Equiv.refl _ with map_mul' := fun _ _ => rfl }", "start": [274, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_map_mul", "code": "@[to_additive]\nlemma symm_map_mul {M N : Type*} [Mul M] [Mul N] (h : M \u2243* N) (x y : N) :\n    h.symm (x * y) = h.symm x * h.symm y :=\n  (h.toMulHom.inverse h.toEquiv.symm h.left_inv h.right_inv).map_mul x y", "start": [284, 1], "end": [290, 73], "kind": "mathlibtacticlemma"}, {"full_name": "MulEquiv.symm", "code": "@[to_additive (attr := symm) \"The inverse of an isomorphism is an isomorphism.\"]\ndef symm {M N : Type*} [Mul M] [Mul N] (h : M \u2243* N) : N \u2243* M :=\n  \u27e8h.toEquiv.symm, h.symm_map_mul\u27e9", "start": [292, 1], "end": [295, 35], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.invFun_eq_symm", "code": "@[to_additive] theorem invFun_eq_symm {f : M \u2243* N} : f.invFun = f.symm", "start": [299, 1], "end": [300, 63], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_toEquiv_symm", "code": "@[to_additive (attr := simp)]\ntheorem coe_toEquiv_symm (f : M \u2243* N) : ((f : M \u2243 N).symm : N \u2192 M) = f.symm", "start": [305, 1], "end": [306, 83], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.equivLike_inv_eq_symm", "code": "@[to_additive (attr := simp)]\ntheorem equivLike_inv_eq_symm (f : M \u2243* N) : EquivLike.inv f = f.symm", "start": [308, 1], "end": [309, 77], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.Simps.symm_apply", "code": "@[to_additive \"See Note [custom simps projection]\"] def Simps.symm_apply (e : M \u2243* N) : N \u2192 M :=\n  e.symm", "start": [314, 1], "end": [317, 9], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toEquiv_symm", "code": "@[to_additive (attr := simp)]\ntheorem toEquiv_symm (f : M \u2243* N) : (f.symm : N \u2243 M) = (f : M \u2243 N).symm", "start": [325, 1], "end": [326, 79], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_mk (f : M \u2243 N) (hf : \u2200 x y, f (x * y) = f x * f y) : (mk f hf : M \u2192 N) = f", "start": [331, 1], "end": [332, 94], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_symm", "code": "@[to_additive (attr := simp)]\ntheorem symm_symm (f : M \u2243* N) : f.symm.symm = f", "start": [340, 1], "end": [341, 56], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_bijective", "code": "@[to_additive]\ntheorem symm_bijective : Function.Bijective (symm : M \u2243* N \u2192 N \u2243* M)", "start": [345, 1], "end": [347, 53], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_mk", "code": "@[to_additive (attr := simp)]\ntheorem symm_mk (f : M \u2243 N) (h) :\n    (MulEquiv.mk f h).symm = \u27e8f.symm, (MulEquiv.mk f h).symm_map_mul\u27e9", "start": [353, 1], "end": [355, 77], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.refl_symm", "code": "@[to_additive (attr := simp)]\ntheorem refl_symm : (refl M).symm = refl M", "start": [359, 1], "end": [360, 50], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.trans", "code": "@[to_additive (attr := trans) \"Transitivity of addition-preserving isomorphisms\"]\ndef trans (h1 : M \u2243* N) (h2 : N \u2243* P) : M \u2243* P :=\n  { h1.toEquiv.trans h2.toEquiv with\n    map_mul' := fun x y => show h2 (h1 (x * y)) = h2 (h1 x) * h2 (h1 y) by\n      rw [h1.map_mul, h2.map_mul] }", "start": [364, 1], "end": [369, 36], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.apply_symm_apply", "code": "@[to_additive (attr := simp) \"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.\"]\ntheorem apply_symm_apply (e : M \u2243* N) (y : N) : e (e.symm y) = y", "start": [373, 1], "end": [376, 31], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_apply_apply", "code": "@[to_additive (attr := simp) \"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.\"]\ntheorem symm_apply_apply (e : M \u2243* N) (x : M) : e.symm (e x) = x", "start": [380, 1], "end": [383, 31], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_comp_self", "code": "@[to_additive (attr := simp)]\ntheorem symm_comp_self (e : M \u2243* N) : e.symm \u2218 e = id", "start": [387, 1], "end": [389, 28], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.self_comp_symm", "code": "@[to_additive (attr := simp)]\ntheorem self_comp_symm (e : M \u2243* N) : e \u2218 e.symm = id", "start": [393, 1], "end": [395, 28], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_refl", "code": "@[to_additive (attr := simp)]\ntheorem coe_refl : \u2191(refl M) = id", "start": [399, 1], "end": [400, 41], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.refl_apply", "code": "@[to_additive (attr := simp)]\ntheorem refl_apply (m : M) : refl M m = m", "start": [404, 1], "end": [405, 49], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_trans", "code": "@[to_additive (attr := simp)]\ntheorem coe_trans (e\u2081 : M \u2243* N) (e\u2082 : N \u2243* P) : \u2191(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081", "start": [409, 1], "end": [410, 80], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.trans_apply", "code": "@[to_additive (attr := simp)]\ntheorem trans_apply (e\u2081 : M \u2243* N) (e\u2082 : N \u2243* P) (m : M) : e\u2081.trans e\u2082 m = e\u2082 (e\u2081 m)", "start": [414, 1], "end": [415, 91], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_trans_apply", "code": "@[to_additive (attr := simp)]\ntheorem symm_trans_apply (e\u2081 : M \u2243* N) (e\u2082 : N \u2243* P) (p : P) :\n    (e\u2081.trans e\u2082).symm p = e\u2081.symm (e\u2082.symm p)", "start": [419, 1], "end": [421, 54], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.apply_eq_iff_eq", "code": "@[to_additive]\ntheorem apply_eq_iff_eq (e : M \u2243* N) {x y : M} : e x = e y \u2194 x = y", "start": [426, 1], "end": [428, 21], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.apply_eq_iff_symm_apply", "code": "@[to_additive]\ntheorem apply_eq_iff_symm_apply (e : M \u2243* N) {x : M} {y : N} : e x = y \u2194 x = e.symm y", "start": [432, 1], "end": [434, 39], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_apply_eq", "code": "@[to_additive]\ntheorem symm_apply_eq (e : M \u2243* N) {x y} : e.symm x = y \u2194 x = e y", "start": [438, 1], "end": [440, 26], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.eq_symm_apply", "code": "@[to_additive]\ntheorem eq_symm_apply (e : M \u2243* N) {x y} : y = e.symm x \u2194 e y = x", "start": [444, 1], "end": [446, 26], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.eq_comp_symm", "code": "@[to_additive]\ntheorem eq_comp_symm {\u03b1 : Type*} (e : M \u2243* N) (f : N \u2192 \u03b1) (g : M \u2192 \u03b1) :\n    f = g \u2218 e.symm \u2194 f \u2218 e = g", "start": [450, 1], "end": [453, 29], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.comp_symm_eq", "code": "@[to_additive]\ntheorem comp_symm_eq {\u03b1 : Type*} (e : M \u2243* N) (f : N \u2192 \u03b1) (g : M \u2192 \u03b1) :\n    g \u2218 e.symm = f \u2194 g = f \u2218 e", "start": [457, 1], "end": [460, 29], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.eq_symm_comp", "code": "@[to_additive]\ntheorem eq_symm_comp {\u03b1 : Type*} (e : M \u2243* N) (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 N) :\n    f = e.symm \u2218 g \u2194 e \u2218 f = g", "start": [464, 1], "end": [467, 29], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_comp_eq", "code": "@[to_additive]\ntheorem symm_comp_eq {\u03b1 : Type*} (e : M \u2243* N) (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 N) :\n    e.symm \u2218 g = f \u2194 g = e \u2218 f", "start": [471, 1], "end": [474, 29], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.symm_trans_self", "code": "@[to_additive (attr := simp)]\ntheorem symm_trans_self (e : M \u2243* N) : e.symm.trans e = refl N", "start": [478, 1], "end": [480, 37], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.self_trans_symm", "code": "@[to_additive (attr := simp)]\ntheorem self_trans_symm (e : M \u2243* N) : e.trans e.symm = refl M", "start": [484, 1], "end": [486, 37], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_monoidHom_refl", "code": "@[to_additive]\ntheorem coe_monoidHom_refl {M} [MulOneClass M] : (refl M : M \u2192* M) = MonoidHom.id M", "start": [491, 1], "end": [492, 91], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_monoidHom_trans", "code": "@[to_additive]\ntheorem coe_monoidHom_trans {M N P} [MulOneClass M] [MulOneClass N] [MulOneClass P]\n    (e\u2081 : M \u2243* N) (e\u2082 : N \u2243* P) :\n    (e\u2081.trans e\u2082 : M \u2192* P) = (e\u2082 : N \u2192* P).comp \u2191e\u2081", "start": [497, 1], "end": [500, 59], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ext", "code": "@[to_additive (attr := ext)\n  \"Two additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : MulEquiv M N} (h : \u2200 x, f x = g x) : f = g", "start": [504, 1], "end": [509, 20], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ext_iff", "code": "@[to_additive]\ntheorem ext_iff {f g : MulEquiv M N} : f = g \u2194 \u2200 x, f x = g x", "start": [513, 1], "end": [515, 18], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.mk_coe", "code": "@[to_additive (attr := simp)]\ntheorem mk_coe (e : M \u2243* N) (e' h\u2081 h\u2082 h\u2083) : (\u27e8\u27e8e, e', h\u2081, h\u2082\u27e9, h\u2083\u27e9 : M \u2243* N) = e", "start": [519, 1], "end": [521, 19], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.mk_coe'", "code": "@[to_additive (attr := simp)]\ntheorem mk_coe' (e : M \u2243* N) (f h\u2081 h\u2082 h\u2083) : (MulEquiv.mk \u27e8f, e, h\u2081, h\u2082\u27e9 h\u2083 : N \u2243* M) = e.symm", "start": [525, 1], "end": [527, 47], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.congr_arg", "code": "@[to_additive]\nprotected theorem congr_arg {f : MulEquiv M N} {x x' : M} : x = x' \u2192 f x = f x'", "start": [531, 1], "end": [533, 22], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.congr_fun", "code": "@[to_additive]\nprotected theorem congr_fun {f g : MulEquiv M N} (h : f = g) (x : M) : f x = g x", "start": [537, 1], "end": [539, 24], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.mulEquivOfUnique", "code": "@[to_additive \"The `AddEquiv` between two `AddMonoid`s with a unique element.\"]\ndef mulEquivOfUnique {M N} [Unique M] [Unique N] [Mul M] [Mul N] : M \u2243* N :=\n  { Equiv.equivOfUnique M N with map_mul' := fun _ _ => Subsingleton.elim _ _ }", "start": [543, 1], "end": [546, 80], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_one", "code": "@[to_additive\n  \"An additive isomorphism of additive monoids sends `0` to `0`\n  (and is hence an additive monoid isomorphism).\"]\nprotected theorem map_one {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) : h 1 = 1", "start": [561, 1], "end": [566, 19], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_eq_one_iff", "code": "@[to_additive]\nprotected theorem map_eq_one_iff {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) {x : M} :\n    h x = 1 \u2194 x = 1", "start": [570, 1], "end": [573, 33], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_ne_one_iff", "code": "@[to_additive]\ntheorem map_ne_one_iff {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) {x : M} :\n    h x \u2260 1 \u2194 x \u2260 1", "start": [577, 1], "end": [580, 33], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ofBijective", "code": "@[to_additive (attr := simps! apply) \"A bijective `AddSemigroup` homomorphism is an isomorphism\"]\nnoncomputable def ofBijective {M N F} [Mul M] [Mul N] [MulHomClass F M N]\n(f : F) (hf : Function.Bijective f) :\n    M \u2243* N :=\n  { Equiv.ofBijective f hf with map_mul' := map_mul f }", "start": [584, 1], "end": [589, 56], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ofBijective_apply_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem ofBijective_apply_symm_apply {M N} [MulOneClass M] [MulOneClass N] {n : N} (f : M \u2192* N)\n    (hf : Function.Bijective f) : f ((Equiv.ofBijective f hf).symm n) = n", "start": [596, 1], "end": [599, 49], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toMonoidHom", "code": "@[to_additive \"Extract the forward direction of an additive equivalence\n  as an addition-preserving function.\"]\ndef toMonoidHom {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) : M \u2192* N :=\n  { h with map_one' := h.map_one }", "start": [603, 1], "end": [609, 35], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_toMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_toMonoidHom {M N} [MulOneClass M] [MulOneClass N] (e : M \u2243* N) :\n    \u21d1e.toMonoidHom = e", "start": [613, 1], "end": [615, 30], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toMonoidHom_injective", "code": "@[to_additive]\ntheorem toMonoidHom_injective {M N} [MulOneClass M] [MulOneClass N] :\n    Function.Injective (toMonoidHom : M \u2243* N \u2192 M \u2192* N)", "start": [620, 1], "end": [623, 52], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.arrowCongr", "code": "@[to_additive (attr := simps apply) \"An additive analogue of `Equiv.arrowCongr`,\n  where the equivalence between the targets is additive.\"]\ndef arrowCongr {M N P Q : Type*} [Mul P] [Mul Q] (f : M \u2243 N) (g : P \u2243* Q) :\n    (M \u2192 P) \u2243* (N \u2192 Q) where\n  toFun h n := g (h (f.symm n))\n  invFun k m := g.symm (k (f m))\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp", "start": [627, 1], "end": [638, 31], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.monoidHomCongr", "code": "@[to_additive (attr := simps apply)\n  \"An additive analogue of `Equiv.arrowCongr`,\n  for additive maps from an additive monoid to a commutative additive monoid.\"]\ndef monoidHomCongr {M N P Q} [MulOneClass M] [MulOneClass N] [CommMonoid P] [CommMonoid Q]\n    (f : M \u2243* N) (g : P \u2243* Q) : (M \u2192* P) \u2243* (N \u2192* Q) where\n  toFun h := g.toMonoidHom.comp (h.comp f.symm.toMonoidHom)\n  invFun k := g.symm.toMonoidHom.comp (k.comp f.toMonoidHom)\n  left_inv h := by ext; simp\n  right_inv k := by ext; simp\n  map_mul' h k := by ext; simp", "start": [644, 1], "end": [658, 31], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.piCongrRight", "code": "@[to_additive (attr := simps apply)\n  \"A family of additive equivalences `\u03a0 j, (Ms j \u2243+ Ns j)`\n  generates an additive equivalence between `\u03a0 j, Ms j` and `\u03a0 j, Ns j`.\n\n  This is the `AddEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n  `AddEquiv.arrowCongr`.\"]\ndef piCongrRight {\u03b7 : Type*} {Ms Ns : \u03b7 \u2192 Type*} [\u2200 j, Mul (Ms j)] [\u2200 j, Mul (Ns j)]\n    (es : \u2200 j, Ms j \u2243* Ns j) : (\u2200 j, Ms j) \u2243* \u2200 j, Ns j :=\n  { Equiv.piCongrRight fun j => (es j).toEquiv with\n    toFun := fun x j => es j (x j),\n    invFun := fun x j => (es j).symm (x j),\n    map_mul' := fun x y => funext fun j => (es j).map_mul (x j) (y j) }", "start": [664, 1], "end": [681, 72], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.piCongrRight_refl", "code": "@[to_additive (attr := simp)]\ntheorem piCongrRight_refl {\u03b7 : Type*} {Ms : \u03b7 \u2192 Type*} [\u2200 j, Mul (Ms j)] :\n    (piCongrRight fun j => MulEquiv.refl (Ms j)) = MulEquiv.refl _", "start": [687, 1], "end": [689, 74], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.piCongrRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem piCongrRight_symm {\u03b7 : Type*} {Ms Ns : \u03b7 \u2192 Type*} [\u2200 j, Mul (Ms j)] [\u2200 j, Mul (Ns j)]\n    (es : \u2200 j, Ms j \u2243* Ns j) : (piCongrRight es).symm = piCongrRight fun i => (es i).symm", "start": [693, 1], "end": [695, 97], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.piCongrRight_trans", "code": "@[to_additive (attr := simp)]\ntheorem piCongrRight_trans {\u03b7 : Type*} {Ms Ns Ps : \u03b7 \u2192 Type*} [\u2200 j, Mul (Ms j)]\n    [\u2200 j, Mul (Ns j)] [\u2200 j, Mul (Ps j)] (es : \u2200 j, Ms j \u2243* Ns j) (fs : \u2200 j, Ns j \u2243* Ps j) :\n    (piCongrRight es).trans (piCongrRight fs) = piCongrRight fun i => (es i).trans (fs i)", "start": [699, 1], "end": [702, 97], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.piSubsingleton", "code": "@[to_additive (attr := simps!)\n  \"A family indexed by a nonempty subsingleton type is\n  equivalent to the element at the single index.\"]\ndef piSubsingleton {\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 j, Mul (M j)] [Subsingleton \u03b9]\n    (i : \u03b9) : (\u2200 j, M j) \u2243* M i :=\n  { Equiv.piSubsingleton M i with map_mul' := fun _ _ => Pi.mul_apply _ _ _ }", "start": [706, 1], "end": [713, 78], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_inv", "code": "@[to_additive \"An additive equivalence of additive groups preserves negation.\"]\nprotected theorem map_inv [Group G] [DivisionMonoid H] (h : G \u2243* H) (x : G) :\n    h x\u207b\u00b9 = (h x)\u207b\u00b9", "start": [725, 1], "end": [729, 21], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_div", "code": "@[to_additive \"An additive equivalence of additive groups preserves subtractions.\"]\nprotected theorem map_div [Group G] [DivisionMonoid H] (h : G \u2243* H) (x y : G) :\n    h (x / y) = h x / h y", "start": [733, 1], "end": [737, 23], "kind": "commanddeclaration"}, {"full_name": "MulHom.toMulEquiv", "code": "@[to_additive\n  \"Given a pair of additive homomorphisms `f`, `g` such that `g.comp f = id` and\n  `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`. This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  homomorphisms.\"]\ndef MulHom.toMulEquiv [Mul M] [Mul N] (f : M \u2192\u2099* N) (g : N \u2192\u2099* M) (h\u2081 : g.comp f = MulHom.id _)\n    (h\u2082 : f.comp g = MulHom.id _) : M \u2243* N where\n  toFun := f\n  invFun := g\n  left_inv := FunLike.congr_fun h\u2081\n  right_inv := FunLike.congr_fun h\u2082\n  map_mul' := f.map_mul", "start": [747, 1], "end": [762, 24], "kind": "commanddeclaration"}, {"full_name": "MulHom.toMulEquiv_apply", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.toMulEquiv_apply [Mul M] [Mul N] (f : M \u2192\u2099* N) (g : N \u2192\u2099* M)\n    (h\u2081 : g.comp f = MulHom.id _) (h\u2082 : f.comp g = MulHom.id _) :\n    ((MulHom.toMulEquiv f g h\u2081 h\u2082) : M \u2192 N) = f", "start": [768, 1], "end": [772, 6], "kind": "commanddeclaration"}, {"full_name": "MulHom.toMulEquiv_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem MulHom.toMulEquiv_symm_apply [Mul M] [Mul N] (f : M \u2192\u2099* N) (g : N \u2192\u2099* M)\n    (h\u2081 : g.comp f = MulHom.id _) (h\u2082 : f.comp g = MulHom.id _) :\n    (MulEquiv.symm (MulHom.toMulEquiv f g h\u2081 h\u2082) : N \u2192 M) = \u2191g", "start": [776, 1], "end": [780, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.toMulEquiv", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }))\n  \"Given a pair of additive monoid homomorphisms `f`, `g` such that `g.comp f = id`\n  and `f.comp g = id`, returns an additive equivalence with `toFun = f` and `invFun = g`.  This\n  constructor is useful if the underlying type(s) have specialized `ext` lemmas for additive\n  monoid homomorphisms.\"]\ndef MonoidHom.toMulEquiv [MulOneClass M] [MulOneClass N] (f : M \u2192* N) (g : N \u2192* M)\n    (h\u2081 : g.comp f = MonoidHom.id _) (h\u2082 : f.comp g = MonoidHom.id _) : M \u2243* N where\n  toFun := f\n  invFun := g\n  left_inv := FunLike.congr_fun h\u2081\n  right_inv := FunLike.congr_fun h\u2082\n  map_mul' := f.map_mul", "start": [784, 1], "end": [798, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.inv", "code": "@[to_additive (attr := simps! (config := { fullyApplied := false }) apply)\n    \"Negation on an `AddGroup` is a permutation of the underlying type.\"]\nprotected def inv : Perm G :=\n  inv_involutive.toPerm _", "start": [812, 1], "end": [816, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.inv_symm", "code": "@[to_additive (attr := simp)]\ntheorem inv_symm : (Equiv.inv G).symm = Equiv.inv G", "start": [824, 1], "end": [825, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/Canonical.lean", "imports": ["Mathlib/Algebra/Order/Sub/Canonical.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CanonicallyOrderedCommSemiring", "code": "class CanonicallyOrderedCommSemiring (\u03b1 : Type*) extends CanonicallyOrderedAddCommMonoid \u03b1,\n    CommSemiring \u03b1 where\n  \n  protected eq_zero_or_eq_zero_of_mul_eq_zero : \u2200 {a b : \u03b1}, a * b = 0 \u2192 a = 0 \u2228 b = 0", "start": [33, 1], "end": [39, 87], "kind": "commanddeclaration"}, {"full_name": "mul_add_mul_le_mul_add_mul", "code": "theorem mul_add_mul_le_mul_add_mul (hab : a \u2264 b) (hcd : c \u2264 d) : a * d + b * c \u2264 a * c + b * d", "start": [50, 1], "end": [55, 96], "kind": "commanddeclaration"}, {"full_name": "mul_add_mul_le_mul_add_mul'", "code": "theorem mul_add_mul_le_mul_add_mul' (hba : b \u2264 a) (hdc : d \u2264 c) :\n    a \u2022 d + b \u2022 c \u2264 a \u2022 c + b \u2022 d", "start": [58, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "mul_add_mul_lt_mul_add_mul", "code": "theorem mul_add_mul_lt_mul_add_mul (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d", "start": [65, 1], "end": [70, 90], "kind": "commanddeclaration"}, {"full_name": "mul_add_mul_lt_mul_add_mul'", "code": "theorem mul_add_mul_lt_mul_add_mul' (hba : b < a) (hdc : d < c) :\n    a \u2022 d + b \u2022 c < a \u2022 c + b \u2022 d", "start": [73, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.toNoZeroDivisors", "code": "instance (priority := 100) toNoZeroDivisors : NoZeroDivisors \u03b1 :=\n  \u27e8CanonicallyOrderedCommSemiring.eq_zero_or_eq_zero_of_mul_eq_zero\u27e9", "start": [89, 1], "end": [90, 69], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.toCovariantClassMulLE", "code": "instance (priority := 100) toCovariantClassMulLE : CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) := by\n  refine' \u27e8fun a b c h => _\u27e9\n  rcases exists_add_of_le h with \u27e8c, rfl\u27e9\n  rw [mul_add]\n  apply self_le_add_right", "start": [94, 1], "end": [98, 26], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.toOrderedCommMonoid", "code": "instance (priority := 100) toOrderedCommMonoid : OrderedCommMonoid \u03b1 where\n  mul_le_mul_left := fun _ _ => mul_le_mul_left'", "start": [102, 1], "end": [103, 49], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring", "code": "instance (priority := 100) toOrderedCommSemiring : OrderedCommSemiring \u03b1 :=\n  { \u2039CanonicallyOrderedCommSemiring \u03b1\u203a with\n    zero_le_one := zero_le _,\n    mul_le_mul_of_nonneg_left := fun a b c h _ => mul_le_mul_left' h _,\n    mul_le_mul_of_nonneg_right := fun a b c h _ => mul_le_mul_right' h _ }", "start": [107, 1], "end": [111, 75], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.mul_pos", "code": "@[simp]\ntheorem mul_pos : 0 < a * b \u2194 0 < a \u2227 0 < b", "start": [114, 1], "end": [116, 58], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.mul_tsub", "code": "protected theorem mul_tsub (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c", "start": [131, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "AddLECancellable.tsub_mul", "code": "protected theorem tsub_mul (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c", "start": [138, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "mul_tsub", "code": "theorem mul_tsub (a b c : \u03b1) : a * (b - c) = a * b - a * c", "start": [147, 1], "end": [148, 42], "kind": "commanddeclaration"}, {"full_name": "tsub_mul", "code": "theorem tsub_mul (a b c : \u03b1) : (a - b) * c = a * c - b * c", "start": [151, 1], "end": [152, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Bits.lean", "imports": ["Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Init/Data/List/Basic.lean", "Mathlib/Init/Data/Nat/Bitwise.lean"], "premises": [{"full_name": "Nat.boddDiv2_eq", "code": "@[simp]\ntheorem boddDiv2_eq (n : \u2115) : boddDiv2 n = (bodd n, div2 n)", "start": [38, 1], "end": [40, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_bit0", "code": "@[simp]\ntheorem bodd_bit0 (n) : bodd (bit0 n) = false", "start": [43, 1], "end": [45, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_bit1", "code": "@[simp]\ntheorem bodd_bit1 (n) : bodd (bit1 n) = true", "start": [48, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_bit0", "code": "@[simp]\ntheorem div2_bit0 (n) : div2 (bit0 n) = n", "start": [53, 1], "end": [55, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_bit1", "code": "@[simp]\ntheorem div2_bit1 (n) : div2 (bit1 n) = n", "start": [58, 1], "end": [60, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_eq_bit0", "code": "@[simp]\ntheorem bit0_eq_bit0 {m n : \u2115} : bit0 m = bit0 n \u2194 m = n", "start": [70, 1], "end": [72, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_eq_bit1", "code": "@[simp]\ntheorem bit1_eq_bit1 {m n : \u2115} : bit1 m = bit1 n \u2194 m = n", "start": [75, 1], "end": [77, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_eq_one", "code": "@[simp]\ntheorem bit1_eq_one {n : \u2115} : bit1 n = 1 \u2194 n = 0", "start": [80, 1], "end": [82, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.one_eq_bit1", "code": "@[simp]\ntheorem one_eq_bit1 {n : \u2115} : 1 = bit1 n \u2194 n = 0", "start": [85, 1], "end": [87, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_add", "code": "theorem bit_add : \u2200 (b : Bool) (n m : \u2115), bit b (n + m) = bit false n + bit b m", "start": [90, 1], "end": [92, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_add'", "code": "theorem bit_add' : \u2200 (b : Bool) (n m : \u2115), bit b (n + m) = bit b n + bit false m", "start": [95, 1], "end": [97, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_ne_zero", "code": "theorem bit_ne_zero (b) {n} (h : n \u2260 0) : bit b n \u2260 0", "start": [100, 1], "end": [101, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_mod_two", "code": "theorem bit0_mod_two : bit0 n % 2 = 0", "start": [104, 1], "end": [106, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_mod_two", "code": "theorem bit1_mod_two : bit1 n % 2 = 1", "start": [109, 1], "end": [111, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_bit0_pos", "code": "theorem pos_of_bit0_pos {n : \u2115} (h : 0 < bit0 n) : 0 < n", "start": [114, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.bitCasesOn_bit", "code": "@[simp]\ntheorem bitCasesOn_bit {C : \u2115 \u2192 Sort u} (H : \u2200 b n, C (bit b n)) (b : Bool) (n : \u2115) :\n    bitCasesOn (bit b n) H = H b n", "start": [120, 1], "end": [123, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.bitCasesOn_bit0", "code": "@[simp]\ntheorem bitCasesOn_bit0 {C : \u2115 \u2192 Sort u} (H : \u2200 b n, C (bit b n)) (n : \u2115) :\n    bitCasesOn (bit0 n) H = H false n", "start": [126, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.bitCasesOn_bit1", "code": "@[simp]\ntheorem bitCasesOn_bit1 {C : \u2115 \u2192 Sort u} (H : \u2200 b n, C (bit b n)) (n : \u2115) :\n    bitCasesOn (bit1 n) H = H true n", "start": [132, 1], "end": [135, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_cases_on_injective", "code": "theorem bit_cases_on_injective {C : \u2115 \u2192 Sort u} :\n    Function.Injective fun H : \u2200 b n, C (bit b n) => fun n => bitCasesOn n H", "start": [138, 1], "end": [142, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_cases_on_inj", "code": "@[simp]\ntheorem bit_cases_on_inj {C : \u2115 \u2192 Sort u} (H\u2081 H\u2082 : \u2200 b n, C (bit b n)) :\n    ((fun n => bitCasesOn n H\u2081) = fun n => bitCasesOn n H\u2082) \u2194 H\u2081 = H\u2082", "start": [145, 1], "end": [148, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_eq_zero", "code": "protected theorem bit0_eq_zero {n : \u2115} : bit0 n = 0 \u2194 n = 0", "start": [151, 1], "end": [152, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_eq_zero_iff", "code": "theorem bit_eq_zero_iff {n : \u2115} {b : Bool} : bit b n = 0 \u2194 n = 0 \u2227 b = false", "start": [155, 1], "end": [159, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRec_eq'", "code": "theorem binaryRec_eq' {C : \u2115 \u2192 Sort*} {z : C 0} {f : \u2200 b n, C n \u2192 C (bit b n)} (b n)\n    (h : f false 0 z = z \u2228 (n = 0 \u2192 b = true)) :\n    binaryRec z f (bit b n) = f b n (binaryRec z f n)", "start": [162, 1], "end": [183, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRec'", "code": "@[elab_as_elim]\ndef binaryRec' {C : \u2115 \u2192 Sort*} (z : C 0) (f : \u2200 b n, (n = 0 \u2192 b = true) \u2192 C n \u2192 C (bit b n)) :\n    \u2200 n, C n :=\n  binaryRec z fun b n ih =>\n    if h : n = 0 \u2192 b = true then f b n h ih\n    else by\n      convert z\n      rw [bit_eq_zero_iff]\n      simpa using h", "start": [186, 1], "end": [196, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.binaryRecFromOne", "code": "@[elab_as_elim]\ndef binaryRecFromOne {C : \u2115 \u2192 Sort*} (z\u2080 : C 0) (z\u2081 : C 1) (f : \u2200 b n, n \u2260 0 \u2192 C n \u2192 C (bit b n)) :\n    \u2200 n, C n :=\n  binaryRec' z\u2080 fun b n h ih =>\n    if h' : n = 0 then by\n      rw [h', h h']\n      exact z\u2081\n    else f b n h' ih", "start": [199, 1], "end": [207, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_bits", "code": "@[simp]\ntheorem zero_bits : bits 0 = []", "start": [210, 1], "end": [211, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.bits_append_bit", "code": "@[simp]\ntheorem bits_append_bit (n : \u2115) (b : Bool) (hn : n = 0 \u2192 b = true) :\n    (bit b n).bits = b :: n.bits", "start": [214, 1], "end": [218, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_bits", "code": "@[simp]\ntheorem bit0_bits (n : \u2115) (hn : n \u2260 0) : (bit0 n).bits = false :: n.bits", "start": [221, 1], "end": [223, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_bits", "code": "@[simp]\ntheorem bit1_bits (n : \u2115) : (bit1 n).bits = true :: n.bits", "start": [226, 1], "end": [228, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.one_bits", "code": "@[simp]\ntheorem one_bits : Nat.bits 1 = [true]", "start": [231, 1], "end": [233, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.bodd_eq_bits_head", "code": "theorem bodd_eq_bits_head (n : \u2115) : n.bodd = n.bits.headI", "start": [240, 1], "end": [242, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.div2_bits_eq_tail", "code": "theorem div2_bits_eq_tail (n : \u2115) : n.div2.bits = n.bits.tail", "start": [245, 1], "end": [247, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Constructor.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Meta/Tactic/Constructor.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/SimpIntro.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Lean/Parser.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.simpIntroCore", "code": "partial def simpIntroCore (g : MVarId) (ctx : Simp.Context) (discharge? : Option Simp.Discharge)\n    (more : Bool) (ids : List (TSyntax ``binderIdent)) : TermElabM (Option MVarId) := do\n  let done := return (\u2190 simpTargetCore g ctx discharge?).1\n  let (transp, var, ids') \u2190 match ids with\n    | [] => if more then pure (.reducible, mkHole (\u2190 getRef), []) else return \u2190 done\n    | v::ids => pure (.default, v.raw[0], ids)\n  let t \u2190 withTransparency transp g.getType'\n  let n := if var.isIdent then var.getId else `_\n  let withFVar := fun (fvar, g) \u21a6 g.withContext do\n    Term.addLocalVarInfo var (mkFVar fvar)\n    let simpTheorems \u2190 ctx.simpTheorems.addTheorem (.fvar fvar) (.fvar fvar)\n    simpIntroCore g { ctx with simpTheorems } discharge? more ids'\n  match t with\n  | .letE .. => withFVar (\u2190 g.intro n)\n  | .forallE (body := body) .. =>\n    let (fvar, g) \u2190 g.intro n\n    if body.hasLooseBVars then withFVar (fvar, g) else\n    match (\u2190 simpLocalDecl g fvar ctx discharge?).1 with\n    | none =>\n      g.withContext <| Term.addLocalVarInfo var (mkFVar fvar)\n      return none\n    | some g' => withFVar g'\n  | _ =>\n    if more && ids.isEmpty then done else\n    throwErrorAt var \"simp_intro failed to introduce {var}\\n{g}\"", "start": [14, 1], "end": [46, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/HigherOrder.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean/Elab/DeclarationRange.lean", "lake-packages/lean4/src/lean/Lean/Elab/Term.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Apply.lean", "Mathlib/Tactic/Attr/Register.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Assumption.lean"], "premises": [{"full_name": "Tactic.mkComp", "code": "def mkComp (v : Expr) : Expr \u2192 MetaM Expr\n  | .app f e =>\n    if e.equal v then\n      return f\n    else do\n      if v.occurs f then\n        throwError \"mkComp failed occurs check\"\n      let e' \u2190 mkComp v e\n      mkAppM ``Function.comp #[f, e']\n  | e => do\n    guard (e.equal v)\n    let t \u2190 inferType e\n    mkAppOptM ``id #[t]", "start": [30, 1], "end": [44, 24], "kind": "commanddeclaration"}, {"full_name": "Tactic.mkHigherOrderType", "code": "partial def mkHigherOrderType (e : Expr) : MetaM Expr := do\n  if not e.isForall then\n    throwError \"not a forall\"\n  withLocalDecl e.bindingName! e.binderInfo e.bindingDomain! fun fvar => do\n    let body := instantiate1 e.bindingBody! fvar\n    if body.isForall then\n      let exp \u2190 mkHigherOrderType body\n      mkForallFVars #[fvar] exp (binderInfoForMVars := e.binderInfo)\n    else\n      let some (_, lhs, rhs) \u2190 matchEq? body | throwError \"not an equality {\u2190 ppExpr body}\"\n      mkEq (\u2190 mkComp fvar lhs) (\u2190 mkComp fvar rhs)", "start": [46, 1], "end": [61, 51], "kind": "commanddeclaration"}, {"full_name": "Tactic.higherOrderGetParam", "code": "def higherOrderGetParam (thm : Name) (stx : Syntax) : AttrM Name := do\n  match stx with\n  | `(attr| higher_order $[$name]?) =>\n    let ref := (name : Option Syntax).getD stx[0]\n    let hothmName :=\n      if let some sname := name then\n        updatePrefix sname.getId thm.getPrefix\n      else\n        thm.appendAfter \"\\'\"\n    MetaM.run' <| TermElabM.run' <| do\n      let lvl := (\u2190 getConstInfo thm).levelParams\n      let typ \u2190 instantiateMVars (\u2190 inferType <| .const thm (lvl.map mkLevelParam))\n      let hot \u2190 mkHigherOrderType typ\n      let prf \u2190 do\n        let mvar \u2190 mkFreshExprMVar hot\n        let (_, mvarId) \u2190 mvar.mvarId!.intros\n        let [mvarId] \u2190 mvarId.apply (\u2190 mkConst ``funext) | throwError \"failed\"\n        let (_, mvarId) \u2190 mvarId.intro1\n        let lmvr \u2190 mvarId.apply (\u2190 mkConst thm)\n        lmvr.forM fun mv \u21a6 mv.assumption\n        instantiateMVars mvar\n      addDecl <| .thmDecl\n        { name := hothmName\n          levelParams := lvl\n          type := hot\n          value := prf }\n      addDeclarationRanges hothmName\n        { range := \u2190 getDeclarationRange (\u2190 getRef)\n          selectionRange := \u2190 getDeclarationRange ref }\n      _ \u2190 addTermInfo (isBinder := true) ref <| \u2190 mkConstWithLevelParams hothmName\n      let hsm := simpExtension.getState (\u2190 getEnv) |>.lemmaNames.contains (.decl thm)\n      if hsm then\n        addSimpTheorem simpExtension hothmName true false .global 1000\n      let some fcn \u2190 getSimpExtension? `functor_norm | failure\n      let hfm := fcn.getState (\u2190 getEnv) |>.lemmaNames.contains <| .decl thm\n      if hfm then\n        addSimpTheorem fcn hothmName true false .global 1000\n      return hothmName\n  | _ => throwUnsupportedSyntax", "start": [63, 1], "end": [104, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/WLOG.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.WLOGResult", "code": "structure WLOGResult where\n  \n  reductionGoal    : MVarId\n  \n  reductionFVarIds : FVarId \u00d7 FVarId\n  \n  hypothesisGoal   : MVarId\n  \n  hypothesisFVarId : FVarId\n  \n  revertedFVarIds  : Array FVarId", "start": [25, 1], "end": [47, 34], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.wlog", "code": "def _root_.Lean.MVarId.wlog (goal : MVarId) (h : Option Name) (P : Expr)\n    (xs : Option (TSyntaxArray `ident) := none) (H : Option Name := none) :\n    TacticM WLOGResult := goal.withContext do\n  goal.checkNotAssigned `wlog\n  let H := H.getD `this\n  let inaccessible := h.isNone\n  let h := h.getD `h\n  \n  let HSuffix := Expr.forallE h P (\u2190 goal.getType) .default\n  let fvars \u2190 getFVarIdsAt goal xs\n  let fvars := fvars.map Expr.fvar\n  let lctx := (\u2190 goal.getDecl).lctx\n  let (revertedFVars, HType) \u2190 liftMkBindingM <| fun ctx => (do\n    let f \u2190 collectForwardDeps lctx fvars\n    let revertedFVars := filterOutImplementationDetails lctx (f.map Expr.fvarId!)\n    let HType \u2190 withFreshCache do mkAuxMVarType lctx (revertedFVars.map Expr.fvar) .natural HSuffix\n    return (revertedFVars, HType))\n      { preserveOrder := false, mainModule := ctx.mainModule }\n  \n  let HExpr \u2190 mkFreshExprSyntheticOpaqueMVar HType\n  let hGoal := HExpr.mvarId!\n  \n  let (HFVarId, reductionGoal) \u2190 goal.assertHypotheses #[\u27e8H, HType, HExpr\u27e9]\n  let HFVarId := HFVarId[0]!\n  \n  let hGoal \u2190 hGoal.tryClearMany revertedFVars\n  \n  let (_, hGoal) \u2190 hGoal.introNP revertedFVars.size\n  let (hFVar, hGoal) \u2190 if inaccessible then hGoal.intro1 else hGoal.intro1P\n  \n  let (\u27e8easyGoal, hyp\u27e9, \u27e8reductionGoal, negHyp\u27e9) \u2190\n    reductionGoal.byCases P <| if inaccessible then `_ else h\n  easyGoal.withContext do\n    let HArgFVarIds \u2190 revertedFVars.filterM (notM \u00b7.isLetVar)\n    let HApp \u2190 instantiateMVars <|\n      mkAppN (.fvar HFVarId) (HArgFVarIds.map .fvar) |>.app (.fvar hyp)\n    ensureHasNoMVars HApp\n    easyGoal.assign HApp\n  return \u27e8reductionGoal, (HFVarId, negHyp), hGoal, hFVar, revertedFVars\u27e9", "start": [50, 1], "end": [109, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Rename.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/HelpCmd.lean", "imports": ["Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.getHeadTk", "code": "partial def getHeadTk (e : Expr) : Option String :=\n  match e.getAppFnArgs with\n  | (``ParserDescr.node, #[_, _, p]) => getHeadTk p\n  | (``ParserDescr.unary, #[.app _ (.lit (.strVal \"withPosition\")), p]) => getHeadTk p\n  | (``ParserDescr.unary, #[.app _ (.lit (.strVal \"atomic\")), p]) => getHeadTk p\n  | (``ParserDescr.binary, #[.app _ (.lit (.strVal \"andthen\")), p, _]) => getHeadTk p\n  | (``ParserDescr.nonReservedSymbol, #[.lit (.strVal tk), _]) => some tk\n  | (``ParserDescr.symbol, #[.lit (.strVal tk)]) => some tk\n  | (``Parser.withAntiquot, #[_, p]) => getHeadTk p\n  | (``Parser.leadingNode, #[_, _, p]) => getHeadTk p\n  | (``HAndThen.hAndThen, #[_, _, _, _, p, _]) => getHeadTk p\n  | (``Parser.nonReservedSymbol, #[.lit (.strVal tk), _]) => some tk\n  | (``Parser.symbol, #[.lit (.strVal tk)]) => some tk\n  | _ => none", "start": [108, 1], "end": [124, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/TypeCheck.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Existsi.lean", "imports": ["Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Replace.lean", "imports": ["lake-packages/std/Std/Tactic/Replace.lean", "Mathlib/Tactic/Have.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Clear!.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Trace.lean", "imports": ["lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Lean/Meta/Eval.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/ElabTerm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Congrm.lean", "imports": ["Mathlib/Tactic/TermCongr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/ExtractLets.lean", "imports": ["Mathlib/Tactic/Basic.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.MVarId.extractLetsAt", "code": "def Lean.MVarId.extractLetsAt (mvarId : MVarId) (fvarId : FVarId) (names : Array Name) :\n    MetaM (Array FVarId \u00d7 MVarId) := do\n  mvarId.checkNotAssigned `extractLetAt\n  mvarId.withReverted #[fvarId] fun mvarId fvarIds => mvarId.withContext do\n    let mut mvarId := mvarId\n    let mut fvarIds' := #[]\n    for name in names do\n      let ty \u2190 Lean.instantiateMVars (\u2190 mvarId.getType)\n      mvarId \u2190 match ty with\n        | .letE n t v b ndep => process mvarId t (.letE n \u00b7 v b ndep)\n        | .forallE n t v b   => process mvarId t (.forallE n \u00b7 v b)\n        | _ => throwTacticEx `extractLetAt mvarId \"unexpected auxiliary target\"\n      let (fvarId', mvarId') \u2190 mvarId.intro name\n      fvarIds' := fvarIds'.push fvarId'\n      mvarId := mvarId'\n    return (fvarIds', fvarIds.map .some, mvarId)\nwhere\n  \n  process (mvarId : MVarId) (t : Expr) (mk : Expr \u2192 Expr) : MetaM MVarId := do\n    let .letE n' t' v' b' _ := t.cleanupAnnotations\n      | throwTacticEx `extractLetAt mvarId \"insufficient number of `let` expressions\"\n    withLetDecl n' t' v' fun fvar => do\n      let b' := b'.instantiate1 fvar\n      let ty' \u2190 mkLetFVars #[fvar] <| mk b'\n      mvarId.change ty'", "start": [19, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "Lean.MVarId.extractLets", "code": "def Lean.MVarId.extractLets (mvarId : MVarId) (names : Array Name) :\n    MetaM (Array FVarId \u00d7 MVarId) :=\n  mvarId.withContext do\n    let ty := (\u2190 Lean.instantiateMVars (\u2190 mvarId.getType)).cleanupAnnotations\n    if ty.letDepth < names.size then\n      throwTacticEx `extractLet mvarId \"insufficient number of `let` expressions\"\n    mvarId.introN names.size names.toList", "start": [49, 1], "end": [57, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.evalExtractLet", "code": "@[tactic Mathlib.extractLets] def evalExtractLet : Tactic := fun stx => do\n  match stx with\n  | `(tactic| extract_lets $loc:location)         => doExtract none loc\n  | `(tactic| extract_lets $hs* $loc:location)    => doExtract hs loc\n  | _ => throwUnsupportedSyntax\nwhere\n  setupNames (ids? : Option (TSyntaxArray [`ident, `Lean.Parser.Term.hole])) (ty : Expr) :\n      MetaM (Array Name) := do\n    if let some ids := ids? then\n      return ids.map getNameOfIdent'\n    else\n      return Array.mkArray (\u2190 instantiateMVars ty).cleanupAnnotations.letDepth `_\n  doExtract (ids? : Option (TSyntaxArray [`ident, `Lean.Parser.Term.hole]))\n      (loc : TSyntax `Lean.Parser.Tactic.location) :\n      TacticM Unit := do\n    let process (f : MVarId \u2192 Array Name \u2192 MetaM (Array FVarId \u00d7 MVarId))\n        (ty : MVarId \u2192 MetaM Expr) : TacticM Unit := do\n      let fvarIds \u2190 liftMetaTacticAux fun mvarId => do\n        let ids \u2190 setupNames ids? (\u2190 ty mvarId)\n        let (fvarIds, mvarId) \u2190 f mvarId ids\n        return (fvarIds, [mvarId])\n      if let some ids := ids? then\n        withMainContext do\n          for stx in ids, fvarId in fvarIds do\n            Term.addLocalVarInfo stx (.fvar fvarId)\n    withLocation (expandOptLocation (mkOptionalNode loc))\n      (atLocal := fun h \u21a6 do\n        process (fun mvarId ids => mvarId.extractLetsAt h ids) (fun _ => h.getType))\n      (atTarget := do\n        process (fun mvarId ids => mvarId.extractLets ids) (fun mvarId => mvarId.getType))\n      (failed := fun _ \u21a6 throwError \"extract_let tactic failed\")", "start": [76, 1], "end": [106, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Recover.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/RCases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.getUnassignedGoalMVarDependencies", "code": "partial def getUnassignedGoalMVarDependencies (mvarId : MVarId) :\n    MetaM (HashSet MVarId) :=\n  return (\u2190 go mvarId |>.run {}).snd\n  where\n    \n    addMVars (e : Expr) : StateRefT (HashSet MVarId) MetaM Unit := do\n      let mvars \u2190 getMVars e\n      let mut s \u2190 get\n      set ({} : HashSet MVarId) for mvarId in mvars do\n        unless \u2190 mvarId.isDelayedAssigned do\n          s := s.insert mvarId\n      set s\n      mvars.forM go\n    \n    go (mvarId : MVarId) : StateRefT (HashSet MVarId) MetaM Unit :=\n      withIncRecDepth do\n        let mdecl \u2190 mvarId.getDecl\n        addMVars mdecl.type\n        for ldecl in mdecl.lctx do\n          addMVars ldecl.type\n          if let (some val) := ldecl.value? then\n            addMVars val\n        if let (some ass) \u2190 getDelayedMVarAssignment? mvarId then\n          let pendingMVarId := ass.mvarIdPending\n          unless \u2190 pendingMVarId.isAssigned <||> pendingMVarId.isDelayedAssigned do\n            modify (\u00b7.insert pendingMVarId)\n          go pendingMVarId", "start": [14, 1], "end": [46, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Lint.lean", "imports": ["lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.Tactic.Lint.structureInType", "code": "@[std_linter] def structureInType : Linter where\n  noErrorsFound := \"no structures that should be in Prop found.\"\n  errorsFound := \"FOUND STRUCTURES THAT SHOULD BE IN PROP.\"\n  test declName := do\n    unless isStructure (\u2190 getEnv) declName do return none\n    let isProp \u2190 forallTelescopeReducing (\u2190 inferType (\u2190 mkConstWithLevelParams declName))\n      fun _ ty => return ty == .sort .zero\n    if isProp then return none\n    let projs := (getStructureInfo? (\u2190 getEnv) declName).get!.fieldNames\n    if projs.isEmpty then return none let allProofs \u2190 projs.allM (do isProof <| \u2190 mkConstWithLevelParams <| declName ++ \u00b7)\n    unless allProofs do return none\n    return m!\"all fields are propositional but the structure isn't.\"", "start": [19, 1], "end": [36, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/SwapVar.lean", "imports": ["Mathlib/Util/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/ApplyWith.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Variable.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Command.Variable.bracketedBinderType", "code": "def bracketedBinderType : Syntax \u2192 Option Term\n  | `(bracketedBinderF|($_* $[: $ty?]? $(_annot?)?)) => ty?\n  | `(bracketedBinderF|{$_* $[: $ty?]?})             => ty?\n  | `(bracketedBinderF|\u2983$_* $[: $ty?]?\u2984)             => ty?\n  | `(bracketedBinderF|[$[$_ :]? $ty])               => some ty\n  | _                                                => none", "start": [38, 1], "end": [44, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.pendingActionableSynthMVar", "code": "def pendingActionableSynthMVar (binder : TSyntax ``bracketedBinder) :\n    TermElabM (Option MVarId) := do\n  let pendingMVars := (\u2190 get).pendingMVars\n  if pendingMVars.isEmpty then\n    return none\n  for mvarId in pendingMVars.reverse do\n    let some decl \u2190 Term.getSyntheticMVarDecl? mvarId | continue\n    match decl.kind with\n    | .typeClass =>\n      let ty \u2190 instantiateMVars (\u2190 mvarId.getType)\n      if !ty.hasExprMVar then\n        return mvarId\n    | _ => pure ()\n  throwErrorAt binder \"Can not satisfy requirements for {binder} due to metavariables.\"", "start": [104, 1], "end": [118, 88], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.getSubproblem", "code": "partial def getSubproblem\n    (binder : TSyntax ``bracketedBinder) (ty : Term) :\n    TermElabM (Option (MessageData \u00d7 TSyntax ``bracketedBinder)) := do\n  let res : Term.TermElabResult (Option (MessageData \u00d7 TSyntax ``bracketedBinder)) \u2190\n    Term.observing do\n    withTheReader Term.Context (fun ctx => {ctx with ignoreTCFailures := true}) do\n    Term.withAutoBoundImplicit do\n      _ \u2190 Term.elabType ty\n      Term.synthesizeSyntheticMVars (mayPostpone := true) (ignoreStuckTC := true)\n      let fvarIds := (\u2190 getLCtx).getFVarIds\n      if let some mvarId \u2190 pendingActionableSynthMVar binder then\n        trace[\u00abvariable?\u00bb] \"Actionable mvar:{mvarId}\"\n        let fvarIds' := (\u2190 mvarId.getDecl).lctx.getFVarIds.filter\n                          (fun fvar => !(fvarIds.contains fvar))\n        let goal \u2190 mvarId.withContext do instantiateMVars <|\n                    (\u2190 mkForallFVars (usedOnly := true) (fvarIds'.map .fvar) (\u2190 mvarId.getType))\n        let ty' \u2190 PrettyPrinter.delab goal\n        let binder' \u2190 withRef binder `(bracketedBinderF| [$ty'])\n        return some (\u2190 addMessageContext m!\"{mvarId}\", binder')\n      else\n        return none\n  match res with\n  | .ok v _ => return v\n  | .error .. => Term.applyResult res", "start": [120, 1], "end": [150, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.completeBinders'", "code": "partial def completeBinders' (maxSteps : Nat) (gas : Nat)\n    (checkRedundant : Bool)\n    (binders : TSyntaxArray ``bracketedBinder)\n    (toOmit : Array Bool) (i : Nat) :\n    TermElabM (TSyntaxArray ``bracketedBinder \u00d7 Array Bool) := do\n  if 0 < gas && i < binders.size then\n    let binder := binders[i]!\n    trace[\u00abvariable?\u00bb]\n      \"Have {(\u2190 getLCtx).getFVarIds.size} fvars and {(\u2190 getLocalInstances).size} local instances{\n      \"\"}. Looking at{indentD binder}\"\n    let sub? \u2190 getSubproblem binder (bracketedBinderType binder).get!\n    if let some (goalMsg, binder') := sub? then\n      trace[\u00abvariable?\u00bb] m!\"new subproblem:{indentD binder'}\"\n      if binders.any (stop := i) (\u00b7 == binder') then\n        let binders' := binders.extract 0 i\n        throwErrorAt binder\n          \"Binder{indentD binder}\\nwas not able to satisfy one of its dependencies using {\n          \"\"}the pre-existing binder{indentD binder'}\\n\\n{\n          \"\"}This might be due to differences in implicit arguments, which are not represented {\n          \"\"}in binders since they are generated by pretty printing unsatisfied dependencies.\\n\\n{\n          \"\"}Current variable command:{indentD (\u2190 `(command| variable $binders'*))}\\n\\n{\n          \"\"}Local context for the unsatisfied dependency:{goalMsg}\"\n      let binders := binders.insertAt! i binder'\n      completeBinders' maxSteps (gas - 1) checkRedundant binders toOmit i\n    else\n      let lctx \u2190 getLCtx\n      let linst \u2190 getLocalInstances\n      withOptions (fun opts => Term.checkBinderAnnotations.set opts false) <| Term.withAutoBoundImplicit <|\n      Term.elabBinders #[binder] fun bindersElab => do\n        let types : Array Expr \u2190 bindersElab.mapM (inferType \u00b7)\n        trace[\u00abvariable?\u00bb] m!\"elaborated binder types array = {types}\"\n        Term.synthesizeSyntheticMVarsNoPostponing Term.withoutAutoBoundImplicit do\n        let (binders, toOmit) := \u2190 do\n          match binder with\n          | `(bracketedBinderF|[$[$ident? :]? $ty]) =>\n            let type \u2190 instantiateMVars (\u2190 inferType bindersElab.back)\n            if \u2190 isVariableAlias type then\n              if ident?.isSome then\n                throwErrorAt binder \"`variable_alias` binders can't have an explicit name\"\n              let binder' \u2190 withRef binder `(bracketedBinderF|{_ : $ty})\n              return (binders.set! i binder', toOmit.push true)\n            let res \u2190 try withLCtx lctx linst <| trySynthInstance type catch _ => pure .none\n            if let .some _ := res then\n              if checkRedundant then\n                let mvar \u2190 mkFreshExprMVarAt lctx linst type\n                logWarningAt binder\n                  m!\"Instance argument can be inferred from earlier arguments.\\n{mvar.mvarId!}\"\n              return (binders, toOmit.push true)\n            else\n              return (binders, toOmit.push false)\n          | _ => return (binders, toOmit.push false)\n        completeBinders' maxSteps gas checkRedundant binders toOmit (i + 1)\n  else\n    if gas == 0 && i < binders.size then\n      let binders' := binders.extract 0 i\n      logErrorAt binders[i]! m!\"Maximum recursion depth for variables! reached. This might be a {\n        \"\"}bug, or you can try adjusting `set_option variable?.maxSteps {maxSteps}`{\n        \"\"}\\n\\nCurrent variable command:{indentD (\u2190 `(command| variable $binders'*))}\"\n    return (binders, toOmit)\nwhere\n  isVariableAlias (type : Expr) : MetaM Bool := do\n    forallTelescope type fun _ type => do\n      if let .const name _ := type.getAppFn then\n        if variableAliasAttr.hasTag (\u2190 getEnv) name then\n          return true\n      return false", "start": [152, 1], "end": [228, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.completeBinders", "code": "def completeBinders (maxSteps : Nat) (checkRedundant : Bool)\n    (binders : TSyntaxArray ``bracketedBinder) :\n    TermElabM (TSyntaxArray ``bracketedBinder \u00d7 Array Bool) :=\n  completeBinders' maxSteps maxSteps checkRedundant binders #[] 0", "start": [230, 1], "end": [233, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.cleanBinders", "code": "def cleanBinders (binders : TSyntaxArray ``bracketedBinder) :\n    TSyntaxArray ``bracketedBinder := Id.run do\n  let mut binders' := #[]\n  for binder in binders do\n    binders' := binders'.push <| \u27e8binder.raw.unsetTrailing\u27e9\n  return binders'", "start": [235, 1], "end": [241, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.elabVariables", "code": "@[command_elab \u00abvariable?\u00bb, inherit_doc \u00abvariable?\u00bb]\ndef elabVariables : CommandElab := fun stx =>\n  match stx with\n  | `(variable? $binders* $[=> $expectedBinders?*]?) => do\n    let checkRedundant := variable?.checkRedundant.get (\u2190 getOptions)\n    process stx checkRedundant binders expectedBinders?\n  | _ => throwUnsupportedSyntax\nwhere\n  extendScope (binders : TSyntaxArray ``bracketedBinder) : CommandElabM Unit := do\n    for binder in binders do\n      let varUIds \u2190 getBracketedBinderIds binder |>.mapM\n        (withFreshMacroScope \u2218 MonadQuotation.addMacroScope)\n      modifyScope fun scope =>\n        { scope with varDecls := scope.varDecls.push binder, varUIds := scope.varUIds ++ varUIds }\n  process (stx : Syntax) (checkRedundant : Bool)\n      (binders : TSyntaxArray ``bracketedBinder)\n      (expectedBinders? : Option <| TSyntaxArray ``bracketedBinder) : CommandElabM Unit := do\n    let binders := cleanBinders binders\n    let maxSteps := variable?.maxSteps.get (\u2190 getOptions)\n    trace[\u00abvariable?\u00bb] \"variable?.maxSteps = {maxSteps}\"\n    for binder in binders do\n      if (bracketedBinderType binder).isNone then\n        throwErrorAt binder \"variable? cannot update pre-existing variables\"\n    let (binders', suggest) \u2190 runTermElabM fun _ => do\n      let (binders, toOmit) \u2190 completeBinders maxSteps checkRedundant binders\n      \n      Term.withAutoBoundImplicit <| Term.elabBinders binders fun _ => pure ()\n      let binders' : TSyntaxArray ``bracketedBinder :=\n        (binders.zip toOmit).filterMap fun (b, omit) => if omit then none else some b\n      if let some expectedBinders := expectedBinders? then\n        trace[\u00abvariable?\u00bb] \"checking expected binders\"\n        \n        let ctx1 \u2190 Term.withAutoBoundImplicit <| Term.elabBinders binders' fun _ => do\n          mkForallFVars (\u2190 getLCtx).getFVars (.sort .zero)\n        let ctx2 \u2190 Term.withAutoBoundImplicit <| Term.elabBinders expectedBinders fun _ => do\n          mkForallFVars (\u2190 getLCtx).getFVars (.sort .zero)\n        trace[\u00abvariable?\u00bb] \"new context: {ctx1}\"\n        trace[\u00abvariable?\u00bb] \"expected context: {ctx2}\"\n        if \u2190 isDefEq ctx1 ctx2 then\n          return (binders', false)\n        else\n          logWarning \"Calculated binders do not match the expected binders given after `=>`.\"\n          return (binders', true)\n      else\n        return (binders', true)\n    extendScope binders'\n    let varComm \u2190 `(command| variable? $binders* => $binders'*)\n    trace[\u00abvariable?\u00bb] \"derived{indentD varComm}\"\n    if suggest then\n      liftTermElabM <| Std.Tactic.TryThis.addSuggestion stx (origSpan? := stx) varComm", "start": [243, 1], "end": [296, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Command.Variable.ignorevariable?", "code": "@[unused_variables_ignore_fn]\ndef ignorevariable? : Lean.Linter.IgnoreFunction := fun _ stack _ =>\n  stack.matches [`null, none, `null, `Mathlib.Command.variable?]", "start": [298, 1], "end": [301, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/CountHeartbeats.lean", "imports": ["lake-packages/std/Std/Tactic/TryThis.lean", "lake-packages/std/Std/Lean/CoreM.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/ExtractGoal.lean", "imports": ["lake-packages/std/Std/Lean/Meta/Inaccessible.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Rewrites.lean", "imports": ["Mathlib/Control/Basic.lean", "Mathlib/Lean/Meta.lean", "Mathlib/Lean/Meta/DiscrTree.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/MLList/Heartbeats.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/Cache.lean", "lake-packages/std/Std/Tactic/Relation/Rfl.lean", "lake-packages/std/Std/Util/Pickle.lean", "Mathlib/Tactic/TryThis.lean", "Mathlib/Data/MLList/Dedup.lean"], "premises": [{"full_name": "Lean.Meta.RewriteResult.by?", "code": "def RewriteResult.by? (r : RewriteResult) : Option Expr :=\n  if r.eqProof.isAppOfArity ``Eq.ndrec 6 then\n    r.eqProof.getArg! 5\n  else\n    none", "start": [36, 1], "end": [44, 9], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.forwardWeight", "code": "def forwardWeight := 2", "start": [55, 1], "end": [56, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.backwardWeight", "code": "def backwardWeight := 1", "start": [57, 1], "end": [58, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.processLemma", "code": "def processLemma (name : Name) (constInfo : ConstantInfo) :\n    MetaM (Array (Array (DiscrTree.Key true) \u00d7 (Name \u00d7 Bool \u00d7 Nat))) := do\n  if constInfo.isUnsafe then return #[]\n  if \u2190 name.isBlackListed then return #[]\n  if name matches .str _ \"injEq\" then return #[]\n  if name matches .str _ \"sizeOf_spec\" then return #[]\n  match name with\n  | .str _ n => if n.endsWith \"_inj\" \u2228 n.endsWith \"_inj'\" then return #[]\n  | _ => pure ()\n  withNewMCtxDepth do withReducible do\n    let (_, _, type) \u2190 forallMetaTelescopeReducing constInfo.type\n    match type.getAppFnArgs with\n    | (``Eq, #[_, lhs, rhs])\n    | (``Iff, #[lhs, rhs]) => do\n      let lhsKey \u2190 DiscrTree.mkPath lhs\n      let rhsKey \u2190 DiscrTree.mkPath rhs\n      return #[(lhsKey, (name, false, forwardWeight * lhsKey.size)),\n        (rhsKey, (name, true, backwardWeight * rhsKey.size))]\n    | _ => return #[]", "start": [60, 1], "end": [80, 22], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.localHypotheses", "code": "def localHypotheses (except : List FVarId := []) : MetaM (Array (Expr \u00d7 Bool \u00d7 Nat)) := do\n  let r \u2190 getLocalHyps\n  let mut result := #[]\n  for h in r do\n    if except.contains h.fvarId! then continue\n    let (_, _, type) \u2190 forallMetaTelescopeReducing (\u2190 inferType h)\n    match type.getAppFnArgs with\n    | (``Eq, #[_, lhs, rhs])\n    | (``Iff, #[lhs, rhs]) => do\n      let lhsKey : Array (DiscrTree.Key true) \u2190 DiscrTree.mkPath lhs\n      let rhsKey : Array (DiscrTree.Key true) \u2190 DiscrTree.mkPath rhs\n      result := result.push (h, false, forwardWeight * lhsKey.size)\n        |>.push (h, true, backwardWeight * rhsKey.size)\n    | _ => pure ()\n  return result", "start": [82, 1], "end": [97, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.addLemma", "code": "def addLemma (name : Name) (constInfo : ConstantInfo)\n    (lemmas : DiscrTree (Name \u00d7 Bool \u00d7 Nat) true) : MetaM (DiscrTree (Name \u00d7 Bool \u00d7 Nat) true) := do\n  let mut lemmas := lemmas\n  for (key, value) in \u2190 processLemma name constInfo do\n    lemmas := lemmas.insertIfSpecific key value\n  return lemmas", "start": [99, 1], "end": [109, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.buildDiscrTree", "code": "def buildDiscrTree : IO (DiscrTreeCache (Name \u00d7 Bool \u00d7 Nat)) :=\n  DiscrTreeCache.mk \"rw?: init cache\" processLemma\n    (post? := some fun A =>\n      A.map (fun (n, m) => (n.toString.length, n, m)) |>.qsort (fun p q => p.1 > q.1) |>.map (\u00b7.2))", "start": [111, 1], "end": [121, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.cachePath", "code": "def cachePath : IO FilePath :=\n  try\n    return (\u2190 findOLean `MathlibExtras.Rewrites).withExtension \"extra\"\n  catch _ =>\n    return \"build\" / \"lib\" / \"MathlibExtras\" / \"Rewrites.extra\"", "start": [125, 1], "end": [129, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.RewriteResult", "code": "structure RewriteResult where\n  \n  expr : Expr\n  \n  symm : Bool\n  \n  weight : Nat\n  \n  result : Meta.RewriteResult\n  \n  ppResult? : Option String\n  \n  rfl? : Option Bool\n  \n  mctx : MetavarContext", "start": [143, 1], "end": [162, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.RewriteResult.computeRfl", "code": "def RewriteResult.computeRfl (r : RewriteResult) : MetaM RewriteResult := do\n  if let some _ := r.rfl? then\n    return r\n  try\n    withoutModifyingState <| withMCtx r.mctx do\n      withReducible (\u2190 mkFreshExprMVar r.result.eNew).mvarId!.applyRfl\n      pure { r with rfl? := some true }\n  catch _ =>\n    pure { r with rfl? := some false }", "start": [164, 1], "end": [176, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.RewriteResult.prepare_ppResult", "code": "def RewriteResult.prepare_ppResult (r : RewriteResult) : MetaM RewriteResult := do\n  if let some _ := r.ppResult? then\n    return r\n  else\n    return { r with ppResult? := some ((\u2190 ppExpr r.result.eNew).pretty) }", "start": [178, 1], "end": [183, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.RewriteResult.ppResult", "code": "def RewriteResult.ppResult (r : RewriteResult) : MetaM String :=\n  if let some pp := r.ppResult? then\n    return pp\n  else\n    return (\u2190 ppExpr r.result.eNew).pretty", "start": [185, 1], "end": [193, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.solveByElim", "code": "def solveByElim (goals : List MVarId) (depth : Nat := 6) : MetaM PUnit := do\n  let cfg : SolveByElim.Config :=\n    { maxDepth := depth, exfalso := false, symm := true }\n  let [] \u2190 SolveByElim.solveByElim.processSyntax cfg false false [] [] #[] goals\n    | failure", "start": [195, 1], "end": [202, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.rewritesCore", "code": "def rewritesCore (hyps : Array (Expr \u00d7 Bool \u00d7 Nat))\n    (lemmas : DiscrTree (Name \u00d7 Bool \u00d7 Nat) s \u00d7 DiscrTree (Name \u00d7 Bool \u00d7 Nat) s)\n    (ctx : MetavarContext) (goal : MVarId) (target : Expr) :\n    MLList MetaM RewriteResult := MLList.squash fun _ => do\n  let candidates := (\u2190 lemmas.1.getSubexpressionMatches target)\n    ++ (\u2190 lemmas.2.getSubexpressionMatches target)\n\n  let candidates := candidates.insertionSort fun r s => r.2.2 > s.2.2\n\n  let mut forward : NameSet := \u2205\n  let mut backward : NameSet := \u2205\n  let mut deduped := #[]\n  for (l, s, w) in candidates do\n    if s then\n      if \u00ac backward.contains l then\n        deduped := deduped.push (l, s, w)\n        backward := backward.insert l\n    else\n      if \u00ac forward.contains l then\n        deduped := deduped.push (l, s, w)\n        forward := forward.insert l\n\n  trace[Tactic.rewrites.lemmas] m!\"Candidate rewrite lemmas:\\n{deduped}\"\n\n  let hyps := MLList.ofArray <| hyps.map fun \u27e8hyp, symm, weight\u27e9 => (Sum.inl hyp, symm, weight)\n  let lemmas := MLList.ofArray <| deduped.map fun \u27e8lem, symm, weight\u27e9 => (Sum.inr lem, symm, weight)\n\n  pure <| (hyps |>.append fun _ => lemmas).filterMapM fun \u27e8lem, symm, weight\u27e9 => withMCtx ctx do\n    let some expr \u2190 (match lem with\n    | .inl hyp => pure (some hyp)\n    | .inr lem => try? <| mkConstWithFreshMVarLevels lem) | return none\n    trace[Tactic.rewrites] m!\"considering {if symm then \"\u2190\" else \"\"}{expr}\"\n    let some result \u2190 try? do goal.rewrite target expr symm\n      | return none\n    if result.mvarIds.isEmpty then\n      return some \u27e8expr, symm, weight, result, none, none, \u2190 getMCtx\u27e9\n    else\n      let some _ \u2190 try? do solveByElim result.mvarIds | return none\n      let some expr := result.by? | return none\n      let expr \u2190 instantiateMVars expr\n      let (expr, symm) := if expr.isAppOfArity ``Eq.symm 4 then\n          (expr.getArg! 3, true)\n        else\n          (expr, false)\n      return some \u27e8expr, symm, weight, result, none, none, \u2190 getMCtx\u27e9", "start": [204, 1], "end": [265, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.rewritesDedup", "code": "def rewritesDedup (hyps : Array (Expr \u00d7 Bool \u00d7 Nat))\n    (lemmas : DiscrTree (Name \u00d7 Bool \u00d7 Nat) s \u00d7 DiscrTree (Name \u00d7 Bool \u00d7 Nat) s)\n    (mctx : MetavarContext)\n    (goal : MVarId) (target : Expr) : MLList MetaM RewriteResult := MLList.squash fun _ => do\n  return rewritesCore hyps lemmas mctx goal target\n    |>.mapM (fun r => r.prepare_ppResult)\n    |>.dedupBy (fun r => pure r.ppResult?)", "start": [267, 1], "end": [280, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Rewrites.rewrites", "code": "def rewrites (hyps : Array (Expr \u00d7 Bool \u00d7 Nat))\n    (lemmas : DiscrTree (Name \u00d7 Bool \u00d7 Nat) s \u00d7 DiscrTree (Name \u00d7 Bool \u00d7 Nat) s)\n    (goal : MVarId) (target : Expr) (stopAtRfl : Bool := false) (max : Nat := 20)\n    (leavePercentHeartbeats : Nat := 10) : MetaM (List RewriteResult) := do\n  let results \u2190 rewritesDedup hyps lemmas (\u2190 getMCtx) goal target\n    |>.mapM RewriteResult.computeRfl |>.takeUpToFirst (fun r => stopAtRfl && r.rfl? = some true)\n    |>.whileAtLeastHeartbeatsPercent leavePercentHeartbeats\n    |>.takeAsList max\n  return match results.filter (fun r => stopAtRfl && r.rfl? = some true) with\n  | [] =>\n    results\n  | results => results", "start": [282, 1], "end": [301, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Propose.lean", "imports": ["Mathlib/Lean/Meta/Basic.lean", "Mathlib/Lean/Meta.lean", "Mathlib/Lean/Meta/DiscrTree.lean", "Mathlib/Tactic/Core.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Cache.lean", "Mathlib/Lean/Expr/Basic.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/TryThis.lean"], "premises": [{"full_name": "Mathlib.Tactic.Propose.solveByElim", "code": "def solveByElim (orig : MVarId) (goals : Array MVarId) (use : Array Expr) (required : Array Expr)\n    (depth) := do\n  let cfg : SolveByElim.Config := { maxDepth := depth, exfalso := true, symm := true }\n  let cfg := if !required.isEmpty then\n    cfg.testSolutions (fun _ => do\n    let r \u2190 instantiateMVars (.mvar orig)\n    pure <| required.all fun e => e.occurs r)\n  else\n    cfg\n  let cfg := cfg.synthInstance\n  _ \u2190 SolveByElim.solveByElim cfg (use.toList.map pure) (pure (\u2190 getLocalHyps).toList) goals.toList", "start": [56, 1], "end": [67, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Propose.propose", "code": "def propose (lemmas : DiscrTree Name s) (type : Expr) (required : Array Expr)\n    (solveByElimDepth := 15) : MetaM (Array (Name \u00d7 Expr)) := do\n  guard !required.isEmpty\n  let ty \u2190 whnfR (\u2190 instantiateMVars (\u2190 inferType required[0]!))\n  let candidates \u2190 lemmas.getMatch ty\n  candidates.filterMapM fun lem : Name =>\n    try\n      trace[Tactic.propose] \"considering {lem}\"\n      let Expr.mvar g \u2190 mkFreshExprMVar type | failure\n      let e \u2190 mkConstWithFreshMVarLevels lem\n      let (args, _, _) \u2190 forallMetaTelescope (\u2190 inferType e)\n      let .true \u2190 preservingMCtx <| withAssignableSyntheticOpaque <|\n        isDefEq type (\u2190 inferType (mkAppN e args)) | failure\n      g.assign (mkAppN e args)\n      let use := required.filterMap fun e => match e with | .fvar _ => none | _ => some e\n      solveByElim g (args.map fun a => a.mvarId!) use required solveByElimDepth\n      trace[Tactic.propose] \"successfully filled in arguments for {lem}\"\n      pure <| some (lem, \u2190 instantiateMVars (.mvar g))\n    catch _ => pure none", "start": [69, 1], "end": [94, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/IrreducibleDef.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Data/Subtype.lean", "Mathlib/Tactic/Eqns.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Command.definition", "code": "$[$nc:noncomputable]? $[$uns]? def definition$[.{$us,*}]? $declSig:optDeclSig $val", "start": [99, 5], "end": [99, 87], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.wrapped", "code": "$[$nc:noncomputable]? $[$uns]? opaque wrapped$[.{$us,*}]? : Subtype (Eq @definition.{$us',*}) :=\n      \u27e8_, rfl\u27e9", "start": [100, 5], "end": [101, 15], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.$n", "code": "$[$doc:docComment]? $[private%$priv]? $[$nc:noncomputable]? $[$uns]?\n    def $n:ident$[.{$us,*}]? :=\n      val_proj @wrapped.{$us',*}", "start": [102, 5], "end": [104, 33], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.$n_def", "code": "$[private%$priv]? $[$uns:unsafe]? theorem $n_def:ident $[.{$us,*}]? :\n        eta_helper Eq @$n.{$us',*} @(delta% @definition)", "start": [105, 5], "end": [110, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/GuardHypNums.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Set.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/RSuffices.lean", "imports": ["Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/ScopedNS.lean", "imports": ["Mathlib/Util/WithWeakNamespace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/UnsetOption.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Parser/Term.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/KVMap.lean", "lake-packages/lean4/src/lean/Lean/Parser/Do.lean", "lake-packages/lean4/src/lean/Lean/Elab/Command.lean"], "premises": [{"full_name": "Lean.Elab.elabUnsetOption", "code": "def elabUnsetOption (id : Syntax) : m Options := do\n  addCompletionInfo <| CompletionInfo.option (\u2190 getRef)\n  unsetOption id.getId.eraseMacroScopes\nwhere\n  \n  unsetOption (optionName : Name) : m Options := return (\u2190 getOptions).erase optionName", "start": [30, 1], "end": [37, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ByContra.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/PushNeg.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/InferParam.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Says.lean", "imports": ["lake-packages/std/Std/Data/String/Basic.lean", "lake-packages/Qq/Qq/Match.lean", "lake-packages/std/Std/Tactic/GuardMsgs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Says.parseAsTacticSeq", "code": "def parseAsTacticSeq (env : Environment) (input : String) (fileName := \"<input>\") :\n    Except String (TSyntax ``tacticSeq) :=\n  let p := andthenFn whitespace Tactic.tacticSeq.fn\n  let ictx := mkInputContext input fileName\n  let s := p.run ictx { env, options := {} } (getTokenTable env) (mkParserState input)\n  if s.hasError then\n    Except.error (s.toErrorMsg ictx)\n  else if input.atEnd s.pos then\n    Except.ok \u27e8s.stxStack.back\u27e9\n  else\n    Except.error ((s.mkError \"end of input\").toErrorMsg ictx)", "start": [42, 1], "end": [53, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Says.evalTacticCapturingMessages", "code": "def evalTacticCapturingMessages (tac : TSyntax `tactic) (only : Message \u2192 Bool := fun _ => true) :\n    TacticM (List Message) := do\n  let mut msgs \u2190 modifyGetThe Core.State fun st => (st.messages, { st with messages := {} })\n  try\n    evalTactic tac\n    let (capture, leave) := (\u2190 getThe Core.State).messages.msgs.toList.partition only\n    msgs := \u27e8leave.foldl (fun m => m.push) msgs.msgs\u27e9\n    return capture\n  catch e =>\n    msgs := msgs ++ (\u2190 getThe Core.State).messages\n    throw e\n  finally\n    modifyThe Core.State fun st => { st with messages := msgs }", "start": [55, 1], "end": [72, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Says.evalTacticCapturingInfo", "code": "def evalTacticCapturingInfo (tac : TSyntax `tactic) : TacticM (List Message) :=\n  evalTacticCapturingMessages tac fun m => match m.severity with | .information => true | _ => false", "start": [74, 1], "end": [78, 101], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Says.evalTacticCapturingTryThis", "code": "def evalTacticCapturingTryThis (tac : TSyntax `tactic) : TacticM (TSyntax ``tacticSeq) := do\n  let msg \u2190 match \u2190 evalTacticCapturingInfo tac with\n  | [] => throwError m!\"Tactic `{tac}` did not produce any messages.\"\n  | [msg] => msg.toString\n  | _ => throwError m!\"Tactic `{tac}` produced multiple messages.\"\n  let tryThis \u2190 match msg.dropPrefix? \"Try this:\" with\n  | none => throwError m!\"Tactic output did not begin with 'Try this:': {msg}\"\n  | some S => pure (Lean.removeLeadingSpaces S.toString)\n  match parseAsTacticSeq (\u2190 getEnv) tryThis with\n  | .ok stx => return stx\n  | .error err => throwError m!\"Failed to parse tactic output: {tryThis}\\n{err}\"", "start": [80, 1], "end": [93, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/RenameBVar.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Util/Tactic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.renameBVarHyp", "code": "def renameBVarHyp (mvarId : MVarId) (fvarId : FVarId) (old new : Name) :\n    MetaM Unit :=\n  modifyLocalDecl mvarId fvarId fun ldecl \u21a6\n    ldecl.setType $ ldecl.type.renameBVar old new", "start": [14, 1], "end": [18, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.renameBVarTarget", "code": "def renameBVarTarget (mvarId : MVarId) (old new : Name) : MetaM Unit :=\n  modifyTarget mvarId fun e \u21a6 e.renameBVar old new", "start": [20, 1], "end": [22, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/NthRewrite.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Tactic/Rewrite.lean", "lake-packages/lean4/src/lean/Lean/Elab/BuiltinTerm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.evalNthRewriteSeq", "code": "@[inherit_doc nthRewriteSeq, tactic nthRewriteSeq] def evalNthRewriteSeq : Tactic := fun stx => do\n  match stx with\n  | `(tactic| nth_rewrite $[$_cfg]? $n $_rules $[$_loc]?) =>\n    let cfg \u2190 elabRewriteConfig stx[1]\n    let loc := expandOptLocation stx[4]\n    let occ := Occurrences.pos [n.getNat]\n    let cfg := { cfg with occs := occ }\n    withRWRulesSeq stx[0] stx[3] fun symm term => do\n      withLocation loc\n        (rewriteLocalDecl term symm \u00b7 cfg)\n        (rewriteTarget term symm cfg)\n        (throwTacticEx `nth_rewrite \u00b7 \"did not find instance of the pattern in the current goal\")\n  | _ => throwUnsupportedSyntax", "start": [28, 1], "end": [42, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/GuardGoalNums.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/FailIfNoProgress.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.lctxIsDefEq", "code": "def lctxIsDefEq : (l\u2081 l\u2082 : List (Option LocalDecl)) \u2192 MetaM Bool\n  | some d\u2081 :: l\u2081, some d\u2082 :: l\u2082 => do\n    unless (\u2190 withNewMCtxDepth <| isDefEq d\u2081.type d\u2082.type) do\n      return false\n    lctxIsDefEq l\u2081 l\u2082\n  | none :: l\u2081, none :: l\u2082 => lctxIsDefEq l\u2081 l\u2082\n  | [], [] => return true\n  | _, _ => return false", "start": [37, 1], "end": [47, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.runAndFailIfNoProgress", "code": "def runAndFailIfNoProgress (goal : MVarId) (tacs : TacticM Unit) : TacticM (List MVarId) := do\n  let l \u2190 run goal tacs\n  try\n    let [newGoal] := l | failure\n    guard <|\u2190 withNewMCtxDepth <| withReducible <| isDefEq (\u2190 newGoal.getType) (\u2190 goal.getType)\n    let ctxDecls := (\u2190 goal.getDecl).lctx.decls.toList\n    let newCtxDecls := (\u2190 newGoal.getDecl).lctx.decls.toList\n    guard <|\u2190 withNewMCtxDepth <| withReducible <| lctxIsDefEq ctxDecls newCtxDecls\n  catch _ =>\n    return l\n  throwError \"no progress made on {goal}\"", "start": [49, 1], "end": [60, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ApplyCongr.lean", "imports": ["lake-packages/std/Std/Tactic/OpenPrivate.lean", "Mathlib/Tactic/Conv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.applyCongr", "code": "def Lean.Elab.Tactic.applyCongr (q : Option Expr) : TacticM Unit := do\n  let const lhsFun _ \u2190 (getAppFn \u2218 cleanupAnnotations) <$> instantiateMVars (\u2190 getLhs) |\n    throwError \"Left-hand side must be an application of a constant.\"\n  let congrTheoremExprs \u2190\n    match q with\n    | some e =>\n      pure [e]\n    | none =>\n      let congrTheorems \u2190\n        (fun congrTheoremMap => congrTheoremMap.get lhsFun) <$> getSimpCongrTheorems\n      congrTheorems.mapM (fun congrTheorem =>\n        liftM <| mkConstWithFreshMVarLevels congrTheorem.theoremName)\n  if congrTheoremExprs == [] then\n    throwError \"No matching congr lemmas found\"\n  liftMetaTactic <| fun mainGoal => congrTheoremExprs.firstM (fun congrTheoremExpr => do\n    let newGoals \u2190 mainGoal.apply congrTheoremExpr { newGoals := .nonDependentOnly }\n    newGoals.mapM fun newGoal => Prod.snd <$> newGoal.intros)", "start": [21, 1], "end": [83, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/ClearExcept.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/Observe.lean", "imports": ["Mathlib/Tactic/TryThis.lean", "Mathlib/Tactic/LibrarySearch.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/SuccessIfFailWithMsg.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/std/Std/Util/TermUnsafe.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.successIfFailWithMessage", "code": "def successIfFailWithMessage [Monad m] [MonadLiftT IO m] [MonadBacktrack s m] [MonadError m]\n    (msg : String) (tacs : m \u03b1) (ref : Option Syntax := none) : m Unit := do\n  let s \u2190 saveState\n  let err \u2190\n    try _ \u2190 tacs; pure none\n    catch err => pure (some (\u2190 err.toMessageData.toString))\n  restoreState s\n  if let some err := err then\n    unless msg.trim == err.trim do\n      if let some ref := ref then\n        throwErrorAt ref \"tactic '{ref}' failed, but got different error message:\\n\\n{err}\"\n      else\n        throwError \"tactic failed, but got different error message:\\n\\n{err}\"\n  else\n    if let some ref := ref then\n      throwErrorAt ref \"tactic '{ref}' succeeded, but was expected to fail\"\n    else\n      throwError \"tactic succeeded, but was expected to fail\"", "start": [30, 1], "end": [49, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Clear_.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/PrintPrefix.lean", "imports": ["lake-packages/lean4/src/lean/Lean/Elab/Command.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Meta.FindOptions", "code": "structure FindOptions where\n  stage1       : Bool := true\n  checkPrivate : Bool := false", "start": [13, 1], "end": [15, 31], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.findCore", "code": "def findCore (\u03d5 : ConstantInfo \u2192 MetaM Bool) (opts : FindOptions := {}) :\n    MetaM (Array ConstantInfo) := do\n  let matches_ \u2190 if !opts.stage1 then pure #[] else\n    (\u2190 getEnv).constants.map\u2081.foldM (init := #[]) check\n  (\u2190 getEnv).constants.map\u2082.foldlM (init := matches_) check\nwhere\n  check matches_ name cinfo := do\n    if opts.checkPrivate || !isPrivateName name then\n      if \u2190 \u03d5 cinfo then pure $ matches_.push cinfo else pure matches_\n    else pure matches_", "start": [17, 1], "end": [26, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Meta.find", "code": "def find (msg : String)\n    (\u03d5 : ConstantInfo \u2192 MetaM Bool) (opts : FindOptions := {}) : TermElabM String := do\n  let cinfos \u2190 findCore \u03d5 opts\n  let cinfos := cinfos.qsort fun p q \u21a6 p.name.lt q.name\n  let mut msg := msg\n  for cinfo in cinfos do\n    msg := msg ++ s!\"{cinfo.name} : {\u2190 Meta.ppExpr cinfo.type}\\n\"\n  pure msg", "start": [28, 1], "end": [35, 11], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Command.elabPrintPrefix", "code": "@[command_elab printPrefix] def elabPrintPrefix : CommandElab\n| `(#print prefix%$tk $name:ident) => do\n  let nameId := name.getId\n  liftTermElabM do\n    let mut msg \u2190 find \"\" fun cinfo \u21a6 pure $ nameId.isPrefixOf cinfo.name\n    if msg.isEmpty then\n      if let [name] \u2190 resolveGlobalConst name then\n        msg \u2190 find msg fun cinfo \u21a6 pure $ name.isPrefixOf cinfo.name\n    if !msg.isEmpty then\n      logInfoAt tk msg\n| _ => throwUnsupportedSyntax", "start": [43, 1], "end": [57, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Tauto.lean", "imports": ["Mathlib/Tactic/CasesM.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Tactic/Classical.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/lean4/src/lean/Lean.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Logic/Basic.lean", "Mathlib/Lean/Elab/Tactic/Basic.lean", "Mathlib/Tactic/SolveByElim.lean"], "premises": [{"full_name": "Mathlib.Tactic.Tauto.distribNotOnceAt", "code": "def distribNotOnceAt (hypFVar : Expr) (g : MVarId) : MetaM AssertAfterResult := g.withContext do\n  let .fvar fvarId := hypFVar | throwError \"not fvar {hypFVar}\"\n  let h \u2190 fvarId.getDecl\n  let e : Q(Prop) \u2190 (do guard <| \u2190 Meta.isProp h.type; pure h.type)\n  let replace (p : Expr) := g.replace h.fvarId p\n  match e with\n  | ~q(\u00ac ($a : Prop) = $b) => do\n    let h' : Q(\u00ac$a = $b) := h.toExpr\n    replace q(mt propext $h')\n  | ~q(($a : Prop) = $b) => do\n    let h' : Q($a = $b) := h.toExpr\n    replace q(Eq.to_iff $h')\n  | ~q(\u00ac (($a : Prop) \u2227 $b)) => do\n    let h' : Q(\u00ac($a \u2227 $b)) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $b) : Q(Type))\n    replace q(Decidable.not_and'.mp $h')\n  | ~q(\u00ac (($a : Prop) \u2228 $b)) => do\n    let h' : Q(\u00ac($a \u2228 $b)) := h.toExpr\n    replace q(not_or.mp $h')\n  | ~q(\u00ac (($a : Prop) \u2260 $b)) => do\n    let h' : Q(\u00ac($a \u2260 $b)) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable ($a = $b)) : Q(Type))\n    replace q(Decidable.of_not_not $h')\n  | ~q(\u00ac\u00ac ($a : Prop)) => do\n    let h' : Q(\u00ac\u00ac$a) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $a) : Q(Type))\n    replace q(Decidable.of_not_not $h')\n  | ~q(\u00ac ((($a : Prop)) \u2192 $b)) => do\n    let h' : Q(\u00ac($a \u2192 $b)) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $a) : Q(Type))\n    replace q(Decidable.not_imp.mp $h')\n  | ~q(\u00ac (($a : Prop) \u2194 $b)) => do\n    let h' : Q(\u00ac($a \u2194 $b)) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $b) : Q(Type))\n    replace q(Decidable.not_iff.mp $h')\n  | ~q(($a : Prop) \u2194 $b) => do\n    let h' : Q($a \u2194 $b) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $b) : Q(Type))\n    replace q(Decidable.iff_iff_and_or_not_and_not.mp $h')\n  | ~q((((($a : Prop)) \u2192 False) : Prop)) =>\n    throwError \"distribNot found nothing to work on with negation\"\n  | ~q((((($a : Prop)) \u2192 $b) : Prop)) => do\n    let h' : Q($a \u2192 $b) := h.toExpr\n    let _inst \u2190 synthInstanceQ (q(Decidable $a) : Q(Type))\n    replace q(Decidable.not_or_of_imp $h')\n  | _ => throwError \"distribNot found nothing to work on\"", "start": [27, 1], "end": [73, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.DistribNotState", "code": "structure DistribNotState where\n  \n  fvars : List Expr\n\n  \n  currentGoal : MVarId", "start": [75, 1], "end": [87, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.distribNotAt", "code": "partial def distribNotAt (nIters : Nat) (state : DistribNotState) : MetaM DistribNotState :=\n  match nIters, state.fvars with\n  | 0, _ | _, [] => pure state\n  | n + 1, fv::fvs => do\n    try\n      let result \u2190 distribNotOnceAt fv state.currentGoal\n      let newFVars := mkFVar result.fvarId :: fvs.map (fun x \u21a6 result.subst.apply x)\n      distribNotAt n \u27e8newFVars, result.mvarId\u27e9\n    catch _ => pure state", "start": [89, 1], "end": [101, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.distribNotAux", "code": "partial def distribNotAux (fvars : List Expr) (g : MVarId) : MetaM MVarId :=\n  match fvars with\n  | [] => pure g\n  | _ => do\n    let result \u2190 distribNotAt 3 \u27e8fvars, g\u27e9\n    distribNotAux result.fvars.tail! result.currentGoal", "start": [103, 1], "end": [112, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.distribNot", "code": "def distribNot : TacticM Unit := withMainContext do\n  let mut fvars := []\n  for h in \u2190 getLCtx do\n    if !h.isImplementationDetail then\n      fvars := mkFVar h.fvarId :: fvars\n  liftMetaTactic' (distribNotAux fvars)", "start": [114, 1], "end": [123, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.Config", "code": "structure Config", "start": [125, 1], "end": [126, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.coreConstructorMatcher", "code": "def coreConstructorMatcher (e : Q(Prop)) : MetaM Bool :=\n  match e with\n  | ~q(_ \u2227 _) => pure true\n  | ~q(_ \u2194 _) => pure true\n  | ~q(True) => pure true\n  | _ => pure false", "start": [131, 1], "end": [138, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.casesMatcher", "code": "def casesMatcher (e : Q(Prop)) : MetaM Bool :=\n  match e with\n  | ~q(_ \u2227 _) => pure true\n  | ~q(_ \u2228 _) => pure true\n  | ~q(Exists _) => pure true\n  | ~q(False) => pure true\n  | _ => pure false", "start": [140, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.tautoCore", "code": "def tautoCore : TacticM Unit := do\n  _ \u2190 tryTactic (evalTactic (\u2190 `(tactic| contradiction)))\n  _ \u2190 tryTactic (evalTactic (\u2190 `(tactic| assumption)))\n  iterateUntilFailure do\n    let gs \u2190 getUnsolvedGoals\n    allGoals (\n      liftMetaTactic (fun m => do pure [(\u2190 m.intros!).2]) <;>\n      distribNot <;>\n      liftMetaTactic (casesMatching casesMatcher (recursive := true) (throwOnNoMatch := false)) <;>\n      (do _ \u2190 tryTactic (evalTactic (\u2190 `(tactic| contradiction)))) <;>\n      (do _ \u2190 tryTactic (evalTactic (\u2190`(tactic| refine or_iff_not_imp_left.mpr ?_)))) <;>\n      liftMetaTactic (fun m => do pure [(\u2190 m.intros!).2]) <;>\n      liftMetaTactic (constructorMatching \u00b7 coreConstructorMatcher\n        (recursive := true) (throwOnNoMatch := false)) <;>\n      do _ \u2190 tryTactic (evalTactic (\u2190 `(tactic| assumption))))\n    let gs' \u2190 getUnsolvedGoals\n    if gs == gs' then failure pure ()", "start": [153, 1], "end": [179, 12], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.finishingConstructorMatcher", "code": "def finishingConstructorMatcher (e : Q(Prop)) : MetaM Bool :=\n  match e with\n  | ~q(_ \u2227 _) => pure true\n  | ~q(_ \u2194 _) => pure true\n  | ~q(Exists _) => pure true\n  | ~q(True) => pure true\n  | _ => pure false", "start": [181, 1], "end": [189, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Tauto.tautology", "code": "def tautology : TacticM Unit := focusAndDoneWithScope \"tauto\" do\n  evalTactic (\u2190 `(tactic| classical!))\n  tautoCore\n  allGoals (iterateUntilFailure\n    (evalTactic (\u2190 `(tactic| rfl)) <|>\n     evalTactic (\u2190 `(tactic| solve_by_elim)) <|>\n     liftMetaTactic (constructorMatching \u00b7 finishingConstructorMatcher)))", "start": [191, 1], "end": [198, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/DefEqTransformations.lean", "imports": ["Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.runDefEqTactic", "code": "def runDefEqTactic (m : Expr \u2192 MetaM Expr)\n    (loc? : Option (TSyntax ``Parser.Tactic.location))\n    (tacticName : String)\n    (checkDefEq : Bool := true) :\n    TacticM Unit := withMainContext do\n  withLocation (expandOptLocation (Lean.mkOptionalNode loc?))\n    (atLocal := fun h => liftMetaTactic1 fun mvarId => do\n      let ty \u2190 instantiateMVars (\u2190 h.getType)\n      mvarId.changeLocalDecl' (checkDefEq := checkDefEq) h (\u2190 m ty))\n    (atTarget := liftMetaTactic1 fun mvarId => do\n      let ty \u2190 instantiateMVars (\u2190 mvarId.getType)\n      mvarId.change (checkDefEq := checkDefEq) (\u2190 m ty))\n    (failed := fun _ => throwError \"{tacticName} failed\")", "start": [20, 1], "end": [39, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.runDefEqConvTactic", "code": "def runDefEqConvTactic (m : Expr \u2192 MetaM Expr) : TacticM Unit := withMainContext do\n  Conv.changeLhs <| \u2190 m (\u2190 instantiateMVars <| \u2190 Conv.getLhs)", "start": [41, 1], "end": [43, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.unfoldFVars", "code": "def unfoldFVars (fvars : Array FVarId) (e : Expr) : MetaM Expr := do\n  transform (usedLetOnly := true) e fun node => do\n    match node with\n    | .fvar fvarId =>\n      if fvars.contains fvarId then\n        if let some val \u2190 fvarId.getValue? then\n          return .visit (\u2190 instantiateMVars val)\n        else\n          return .continue\n      else\n        return .continue\n    | _ => return .continue", "start": [90, 1], "end": [102, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.unfoldProjs", "code": "def unfoldProjs (e : Expr) : MetaM Expr := do\n  transform e fun node => do\n    if let some node' \u2190 unfoldProjInst? node then\n      return .visit (\u2190 instantiateMVars node')\n    else\n      return .continue", "start": [134, 1], "end": [140, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.etaReduceAll", "code": "def etaReduceAll (e : Expr) : MetaM Expr := do\n  transform e fun node =>\n    match node.etaExpandedStrict? with\n    | some e' => return .visit e'\n    | none => return .continue", "start": [155, 1], "end": [160, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.etaExpandAll", "code": "partial def etaExpandAll (e : Expr) : MetaM Expr := do\n  let betaOrApp (f : Expr) (args : Array Expr) : Expr :=\n    if f.etaExpanded?.isSome then f.beta args else mkAppN f args\n  let expand (e : Expr) : MetaM Expr := do\n    if e.isLambda then\n      return e\n    else\n      forallTelescopeReducing (\u2190 inferType e) fun xs _ => do\n        mkLambdaFVars xs (betaOrApp e xs)\n  transform e\n    (pre := fun node => do\n      if node.isApp then\n        let f \u2190 etaExpandAll node.getAppFn\n        let args \u2190 node.getAppArgs.mapM etaExpandAll\n        .done <$> expand (betaOrApp f args)\n      else\n        pure .continue)\n    (post := (.done <$> expand \u00b7))", "start": [177, 1], "end": [197, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.getProjectedExpr", "code": "def getProjectedExpr (e : Expr) : MetaM (Option (Name \u00d7 Nat \u00d7 Expr)) := do\n  if let .proj S i x := e then\n    return (S, i, x)\n  if let .const fn _ := e.getAppFn then\n    if let some info \u2190 getProjectionFnInfo? fn then\n      if e.getAppNumArgs == info.numParams + 1 then\n        if let some (ConstantInfo.ctorInfo fVal) := (\u2190 getEnv).find? info.ctorName then\n          return (fVal.induct, info.i, e.appArg!)\n  return none", "start": [219, 1], "end": [230, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.etaStruct?", "code": "def etaStruct? (e : Expr) (tryWhnfR : Bool := true) : MetaM (Option Expr) := do\n  let .const f _ := e.getAppFn | return none\n  let some (ConstantInfo.ctorInfo fVal) := (\u2190 getEnv).find? f | return none\n  unless 0 < fVal.numFields && e.getAppNumArgs == fVal.numParams + fVal.numFields do return none\n  unless isStructureLike (\u2190 getEnv) fVal.induct do return none\n  let args := e.getAppArgs\n  let mut x? \u2190 findProj fVal args pure\n  if tryWhnfR then\n    if let .undef := x? then\n      x? \u2190 findProj fVal args whnfR\n  if let .some x := x? then\n    if \u2190 isDefEq x e then\n      return x\n  return none\nwhere\n  \n  findProj (fVal : ConstructorVal) (args : Array Expr) (m : Expr \u2192 MetaM Expr) :\n      MetaM (LOption Expr) := do\n    for i in [0 : fVal.numFields] do\n      let arg \u2190 m args[fVal.numParams + i]!\n      let some (S, j, x) \u2190 getProjectedExpr arg | continue\n      if S == fVal.induct && i == j then\n        return .some x\n      else\n        return .none\n    return .undef", "start": [232, 1], "end": [269, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.etaStructAll", "code": "def etaStructAll (e : Expr) : MetaM Expr :=\n  transform e fun node => do\n    if let some node' \u2190 etaStruct? node then\n      return .visit node'\n    else\n      return .continue", "start": [271, 1], "end": [278, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Find.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "Mathlib/Tactic/Cache.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Find.matchHyps", "code": "private partial def matchHyps : List Expr \u2192 List Expr \u2192 List Expr \u2192 MetaM Bool\n  | p::ps, oldHyps, h::newHyps => do\n    let pt \u2190 inferType p\n    let t \u2190 inferType h\n    if (\u2190 isDefEq pt t) then\n      matchHyps ps [] (oldHyps ++ newHyps)\n    else\n      matchHyps (p::ps) (h::oldHyps) newHyps\n  | [], _, _    => pure true\n  | _::_, _, [] => pure false", "start": [31, 1], "end": [40, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Find.isBlackListed", "code": "private def isBlackListed (declName : Name) : MetaM Bool := do\n  let env \u2190 getEnv\n  pure $ declName.isInternal\n   || isAuxRecursor env declName\n   || isNoConfusion env declName\n  <||> isRec declName\n  <||> isMatcher declName", "start": [43, 1], "end": [49, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Find.findType", "code": "def findType (t : Expr) : TermElabM Unit := withReducible do\n  let t \u2190 instantiateMVars t\n  let head := (\u2190 forallMetaTelescopeReducing t).2.2.toHeadIndex\n  let pat \u2190 abstractMVars t\n\n  let env \u2190 getEnv\n  let mut numFound := 0\n  for n in (\u2190 findDeclsPerHead.get).findD head #[] do\n    let c := env.find? n |>.get!\n    let cTy := c.instantiateTypeLevelParams (\u2190 mkFreshLevelMVars c.numLevelParams)\n    let found \u2190 forallTelescopeReducing cTy fun cParams cTy' \u21a6 do\n      let pat := pat.expr.instantiateLevelParamsArray pat.paramNames\n        (\u2190 mkFreshLevelMVars pat.numMVars).toArray\n      let (_, _, pat) \u2190 lambdaMetaTelescope pat\n      let (patParams, _, pat) \u2190 forallMetaTelescopeReducing pat\n      isDefEq cTy' pat <&&> matchHyps patParams.toList [] cParams.toList\n    if found then\n      numFound := numFound + 1\n      if numFound > 20 then\n        logInfo m!\"maximum number of search results reached\"\n        break\n      logInfo m!\"{n}: {cTy}\"", "start": [61, 1], "end": [82, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/SudoSetOption.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "setOption", "code": "private def setOption [Monad m] [MonadError m]\n    (name val : Syntax) (opts : Options) : m Options := do\n  let val \u2190 match val with\n    | Syntax.ident _ _ `true _  => pure $ DataValue.ofBool true\n    | Syntax.ident _ _ `false _ => pure $ DataValue.ofBool false\n    | _ => match val.isNatLit? with\n      | some num => pure $ DataValue.ofNat num\n      | none => match val.isStrLit? with\n        | some str => pure $ DataValue.ofString str\n        | none => throwError \"unsupported option value {val}\"\n  pure $ opts.insert name.getId val", "start": [19, 1], "end": [29, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/List/Lemmas.lean", "imports": ["Mathlib/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Init/Data/List/Basic.lean", "Mathlib/Init/Function.lean"], "premises": [{"full_name": "List.mem_cons_eq", "code": "theorem mem_cons_eq (a y : \u03b1) (l : List \u03b1) : (a \u2208 y :: l) = (a = y \u2228 a \u2208 l)", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "List.eq_or_mem_of_mem_cons", "code": "alias \u27e8eq_or_mem_of_mem_cons, _\u27e9 := mem_cons", "start": [68, 1], "end": [68, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.not_bex_nil", "code": "theorem not_bex_nil (p : \u03b1 \u2192 Prop) : \u00ac\u2203 x \u2208 @nil \u03b1, p x", "start": [76, 1], "end": [76, 99], "kind": "commanddeclaration"}, {"full_name": "List.bex_cons", "code": "theorem bex_cons (p : \u03b1 \u2192 Prop) (a : \u03b1) (l : List \u03b1) : (\u2203 x \u2208 a :: l, p x) \u2194 p a \u2228 \u2203 x \u2208 l, p x", "start": [81, 1], "end": [88, 98], "kind": "commanddeclaration"}, {"full_name": "List.length_le_of_sublist", "code": "alias length_le_of_sublist := Sublist.length_le", "start": [120, 1], "end": [120, 48], "kind": "stdtacticaliasalias"}, {"full_name": "List.mapAccumr", "code": "def mapAccumr (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) : List \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 List \u03b2\n  | [], c => (c, [])\n  | y :: yr, c =>\n    let r := mapAccumr f yr c\n    let z := f y r.1\n    (z.1, z.2 :: r.2)", "start": [138, 1], "end": [144, 22], "kind": "commanddeclaration"}, {"full_name": "List.length_mapAccumr", "code": "@[simp]\ntheorem length_mapAccumr :\n    \u2200 (f : \u03b1 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03b2) (x : List \u03b1) (s : \u03c3), length (mapAccumr f x s).2 = length x", "start": [147, 1], "end": [152, 20], "kind": "commanddeclaration"}, {"full_name": "List.mapAccumr\u2082", "code": "def mapAccumr\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03c6) : List \u03b1 \u2192 List \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 List \u03c6\n  | [], _, c => (c, [])\n  | _, [], c => (c, [])\n  | x :: xr, y :: yr, c =>\n    let r := mapAccumr\u2082 f xr yr c\n    let q := f x y r.1\n    (q.1, q.2 :: r.2)", "start": [161, 1], "end": [168, 22], "kind": "commanddeclaration"}, {"full_name": "List.length_mapAccumr\u2082", "code": "@[simp]\ntheorem length_mapAccumr\u2082 :\n    \u2200 (f : \u03b1 \u2192 \u03b2 \u2192 \u03c3 \u2192 \u03c3 \u00d7 \u03c6) (x y c), length (mapAccumr\u2082 f x y c).2 = min (length x) (length y)", "start": [171, 1], "end": [182, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Functor.lean", "imports": ["Mathlib/Control/Basic.lean", "lake-packages/std/Std/Tactic/Lint.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Set.lean", "Mathlib/Tactic/Basic.lean"], "premises": [{"full_name": "Functor.map_id", "code": "theorem Functor.map_id : (\u00b7 <$> \u00b7) id = (id : F \u03b1 \u2192 F \u03b1)", "start": [41, 1], "end": [41, 74], "kind": "commanddeclaration"}, {"full_name": "Functor.map_comp_map", "code": "theorem Functor.map_comp_map (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) :\n    ((\u00b7 <$> \u00b7) g \u2218 (\u00b7 <$> \u00b7) f : F \u03b1 \u2192 F \u03b3) = (\u00b7 <$> \u00b7) (g \u2218 f)", "start": [44, 1], "end": [46, 43], "kind": "commanddeclaration"}, {"full_name": "Functor.ext", "code": "theorem Functor.ext {F} :\n    \u2200 {F1 : Functor F} {F2 : Functor F} [@LawfulFunctor F F1] [@LawfulFunctor F F2],\n    (\u2200 (\u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2) (x : F \u03b1), @Functor.map _ F1 _ _ f x = @Functor.map _ F2 _ _ f x) \u2192\n    F1 = F2", "start": [50, 1], "end": [60, 27], "kind": "commanddeclaration"}, {"full_name": "id.mk", "code": "def id.mk {\u03b1 : Sort u} : \u03b1 \u2192 id \u03b1 :=\n  id", "start": [65, 1], "end": [68, 5], "kind": "commanddeclaration"}, {"full_name": "Functor.Const", "code": "@[nolint unusedArguments]\ndef Const (\u03b1 : Type*) (_\u03b2 : Type*) :=\n  \u03b1", "start": [73, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.mk", "code": "@[match_pattern]\ndef Const.mk {\u03b1 \u03b2} (x : \u03b1) : Const \u03b1 \u03b2 :=\n  x", "start": [81, 1], "end": [85, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.mk'", "code": "def Const.mk' {\u03b1} (x : \u03b1) : Const \u03b1 PUnit :=\n  x", "start": [88, 1], "end": [91, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.run", "code": "def Const.run {\u03b1 \u03b2} (x : Const \u03b1 \u03b2) : \u03b1 :=\n  x", "start": [94, 1], "end": [96, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.ext", "code": "protected theorem ext {\u03b1 \u03b2} {x y : Const \u03b1 \u03b2} (h : x.run = y.run) : x = y", "start": [101, 1], "end": [102, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.map", "code": "@[nolint unusedArguments]\nprotected def map {\u03b3 \u03b1 \u03b2} (_f : \u03b1 \u2192 \u03b2) (x : Const \u03b3 \u03b2) : Const \u03b3 \u03b1 :=\n  x", "start": [105, 1], "end": [108, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.functor", "code": "instance functor {\u03b3} : Functor (Const \u03b3) where map := @Const.map \u03b3", "start": [111, 1], "end": [111, 67], "kind": "commanddeclaration"}, {"full_name": "Functor.Const.lawfulFunctor", "code": "instance lawfulFunctor {\u03b3} : LawfulFunctor (Const \u03b3) := by constructor <;> intros <;> rfl", "start": [113, 1], "end": [113, 90], "kind": "commanddeclaration"}, {"full_name": "Functor.AddConst", "code": "def AddConst (\u03b1 : Type*) :=\n  Const \u03b1", "start": [120, 1], "end": [125, 10], "kind": "commanddeclaration"}, {"full_name": "Functor.AddConst.mk", "code": "@[match_pattern]\ndef AddConst.mk {\u03b1 \u03b2} (x : \u03b1) : AddConst \u03b1 \u03b2 :=\n  x", "start": [128, 1], "end": [132, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.AddConst.run", "code": "def AddConst.run {\u03b1 \u03b2} : AddConst \u03b1 \u03b2 \u2192 \u03b1 :=\n  id", "start": [135, 1], "end": [137, 5], "kind": "commanddeclaration"}, {"full_name": "Functor.AddConst.functor", "code": "instance AddConst.functor {\u03b3} : Functor (AddConst \u03b3) :=\n  @Const.functor \u03b3", "start": [140, 1], "end": [141, 19], "kind": "commanddeclaration"}, {"full_name": "Functor.AddConst.lawfulFunctor", "code": "instance AddConst.lawfulFunctor {\u03b3} : LawfulFunctor (AddConst \u03b3) :=\n  @Const.lawfulFunctor \u03b3", "start": [144, 1], "end": [145, 25], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp", "code": "def Comp (F : Type u \u2192 Type w) (G : Type v \u2192 Type u) (\u03b1 : Type v) : Type w :=\n  F <| G \u03b1", "start": [151, 1], "end": [155, 11], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.mk", "code": "@[match_pattern]\ndef Comp.mk {F : Type u \u2192 Type w} {G : Type v \u2192 Type u} {\u03b1 : Type v} (x : F (G \u03b1)) : Comp F G \u03b1 :=\n  x", "start": [158, 1], "end": [162, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.run", "code": "def Comp.run {F : Type u \u2192 Type w} {G : Type v \u2192 Type u} {\u03b1 : Type v} (x : Comp F G \u03b1) : F (G \u03b1) :=\n  x", "start": [165, 1], "end": [167, 4], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.ext", "code": "protected theorem ext {\u03b1} {x y : Comp F G \u03b1} : x.run = y.run \u2192 x = y", "start": [174, 1], "end": [175, 5], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.map", "code": "protected def map {\u03b1 \u03b2 : Type v} (h : \u03b1 \u2192 \u03b2) : Comp F G \u03b1 \u2192 Comp F G \u03b2\n  | Comp.mk x => Comp.mk ((\u00b7 <$> \u00b7) h <$> x)", "start": [183, 1], "end": [185, 45], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.functor", "code": "instance functor : Functor (Comp F G) where map := @Comp.map F G _ _", "start": [188, 1], "end": [188, 69], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.map_mk", "code": "@[functor_norm]\ntheorem map_mk {\u03b1 \u03b2} (h : \u03b1 \u2192 \u03b2) (x : F (G \u03b1)) : h <$> Comp.mk x = Comp.mk ((\u00b7 <$> \u00b7) h <$> x)", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.run_map", "code": "@[simp]\nprotected theorem run_map {\u03b1 \u03b2} (h : \u03b1 \u2192 \u03b2) (x : Comp F G \u03b1) :\n    (h <$> x).run = (\u00b7 <$> \u00b7) h <$> x.run", "start": [195, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.id_map", "code": "protected theorem id_map : \u2200 x : Comp F G \u03b1, Comp.map id x = x", "start": [205, 1], "end": [206, 57], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.comp_map", "code": "protected theorem comp_map (g' : \u03b1 \u2192 \u03b2) (h : \u03b2 \u2192 \u03b3) :\n    \u2200 x : Comp F G \u03b1, Comp.map (h \u2218 g') x = Comp.map h (Comp.map g' x)", "start": [210, 1], "end": [212, 81], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.lawfulFunctor", "code": "instance lawfulFunctor : LawfulFunctor (Comp F G) where\n  map_const := rfl\n  id_map := @Comp.id_map F G _ _ _ _\n  comp_map := @Comp.comp_map F G _ _ _ _", "start": [216, 1], "end": [219, 41], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.functor_comp_id", "code": "theorem functor_comp_id {F} [AF : Functor F] [LawfulFunctor F] :\n    @Comp.functor F Id _ _ = AF", "start": [222, 1], "end": [224, 78], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.functor_id_comp", "code": "theorem functor_id_comp {F} [AF : Functor F] [LawfulFunctor F] : @Comp.functor Id F _ _ = AF", "start": [228, 1], "end": [229, 78], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.seq", "code": "protected def seq {\u03b1 \u03b2 : Type v} : Comp F G (\u03b1 \u2192 \u03b2) \u2192 (Unit \u2192 Comp F G \u03b1) \u2192 Comp F G \u03b2\n  | Comp.mk f, g => match g () with\n    | Comp.mk x => Comp.mk <| (\u00b7 <*> \u00b7) <$> f <*> x", "start": [244, 1], "end": [247, 52], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.run_pure", "code": "@[simp]\nprotected theorem run_pure {\u03b1 : Type v} : \u2200 x : \u03b1, (pure x : Comp F G \u03b1).run = pure (pure x)", "start": [257, 1], "end": [259, 13], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.run_seq", "code": "@[simp]\nprotected theorem run_seq {\u03b1 \u03b2 : Type v} (f : Comp F G (\u03b1 \u2192 \u03b2)) (x : Comp F G \u03b1) :\n    (f <*> x).run = (\u00b7 <*> \u00b7) <$> f.run <*> x.run", "start": [262, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "Functor.Comp.instApplicativeComp", "code": "instance instApplicativeComp : Applicative (Comp F G) :=\n  { map := @Comp.map F G _ _, seq := @Comp.seq F G _ _ }", "start": [268, 1], "end": [269, 57], "kind": "commanddeclaration"}, {"full_name": "Functor.Liftp", "code": "def Liftp {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) (x : F \u03b1) : Prop :=\n  \u2203 u : F (Subtype p), Subtype.val <$> u = x", "start": [275, 1], "end": [278, 45], "kind": "commanddeclaration"}, {"full_name": "Functor.Liftr", "code": "def Liftr {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (x y : F \u03b1) : Prop :=\n  \u2203 u : F { p : \u03b1 \u00d7 \u03b1 // r p.fst p.snd },\n    (fun t : { p : \u03b1 \u00d7 \u03b1 // r p.fst p.snd } => t.val.fst) <$> u = x \u2227\n      (fun t : { p : \u03b1 \u00d7 \u03b1 // r p.fst p.snd } => t.val.snd) <$> u = y", "start": [281, 1], "end": [287, 70], "kind": "commanddeclaration"}, {"full_name": "Functor.supp", "code": "def supp {\u03b1 : Type u} (x : F \u03b1) : Set \u03b1 :=\n  { y : \u03b1 | \u2200 \u2983p\u2984, Liftp p x \u2192 p y }", "start": [290, 1], "end": [293, 37], "kind": "commanddeclaration"}, {"full_name": "Functor.of_mem_supp", "code": "theorem of_mem_supp {\u03b1 : Type u} {x : F \u03b1} {p : \u03b1 \u2192 Prop} (h : Liftp p x) : \u2200 y \u2208 supp x, p y", "start": [296, 1], "end": [297, 19], "kind": "commanddeclaration"}, {"full_name": "Functor.mapConstRev", "code": "@[reducible] def mapConstRev {f : Type u \u2192 Type v} [Functor f] {\u03b1 \u03b2 : Type u} :\n    f \u03b2 \u2192 \u03b1 \u2192 f \u03b1 :=\n  fun a b => Functor.mapConst b a", "start": [300, 1], "end": [305, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/SProd.lean", "imports": ["Mathlib/Tactic/FBinop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SProd", "code": "class SProd (\u03b1 : Type u) (\u03b2 : Type v) (\u03b3 : outParam (Type w)) where\n  \n  sprod : \u03b1 \u2192 \u03b2 \u2192 \u03b3", "start": [26, 1], "end": [29, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Cast/Basic.lean", "imports": ["Mathlib/Algebra/Group/Basic.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Data/Int/Cast/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.cast_sub", "code": "@[simp, norm_cast]\ntheorem cast_sub {m n} (h : m \u2264 n) : ((n - m : \u2115) : R) = n - m", "start": [32, 1], "end": [34, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_pred", "code": "@[simp, norm_cast]\ntheorem cast_pred : \u2200 {n}, 0 < n \u2192 ((n - 1 : \u2115) : R) = n - 1", "start": [38, 1], "end": [41, 55], "kind": "commanddeclaration"}, {"full_name": "Int.cast_negSucc", "code": "@[simp, norm_cast]\ntheorem cast_negSucc (n : \u2115) : (-[n+1] : R) = -(n + 1 : \u2115)", "start": [52, 1], "end": [54, 36], "kind": "commanddeclaration"}, {"full_name": "Int.cast_zero", "code": "@[simp, norm_cast]\ntheorem cast_zero : ((0 : \u2124) : R) = 0", "start": [58, 1], "end": [60, 56], "kind": "commanddeclaration"}, {"full_name": "Int.cast_ofNat", "code": "@[simp high, nolint simpNF, norm_cast] theorem cast_ofNat (n : \u2115) : ((n : \u2124) : R) = n", "start": [64, 1], "end": [66, 34], "kind": "commanddeclaration"}, {"full_name": "Int.int_cast_ofNat", "code": "@[simp, norm_cast]\ntheorem int_cast_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ((no_index (OfNat.ofNat n) : \u2124) : R) = OfNat.ofNat n", "start": [71, 1], "end": [74, 74], "kind": "commanddeclaration"}, {"full_name": "Int.cast_one", "code": "@[simp, norm_cast]\ntheorem cast_one : ((1 : \u2124) : R) = 1", "start": [76, 1], "end": [78, 33], "kind": "commanddeclaration"}, {"full_name": "Int.cast_neg", "code": "@[simp, norm_cast]\ntheorem cast_neg : \u2200 n, ((-n : \u2124) : R) = -n", "start": [82, 1], "end": [86, 57], "kind": "commanddeclaration"}, {"full_name": "Int.cast_subNatNat", "code": "@[simp, norm_cast]\ntheorem cast_subNatNat (m n) : ((Int.subNatNat m n : \u2124) : R) = m - n", "start": [90, 1], "end": [97, 15], "kind": "commanddeclaration"}, {"full_name": "Int.cast_negOfNat", "code": "@[simp]\ntheorem cast_negOfNat (n : \u2115) : ((negOfNat n : \u2124) : R) = -n", "start": [103, 1], "end": [104, 99], "kind": "commanddeclaration"}, {"full_name": "Int.cast_add", "code": "@[simp, norm_cast]\ntheorem cast_add : \u2200 m n, ((m + n : \u2124) : R) = m + n", "start": [107, 1], "end": [117, 63], "kind": "commanddeclaration"}, {"full_name": "Int.cast_sub", "code": "@[simp, norm_cast]\ntheorem cast_sub (m n) : ((m - n : \u2124) : R) = m - n", "start": [121, 1], "end": [123, 72], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_bit0", "code": "@[norm_cast, deprecated]\ntheorem ofNat_bit0 (n : \u2115) : (\u2191(bit0 n) : \u2124) = bit0 \u2191n", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_bit1", "code": "@[norm_cast, deprecated]\ntheorem ofNat_bit1 (n : \u2115) : (\u2191(bit1 n) : \u2124) = bit1 \u2191n", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Int.cast_bit0", "code": "@[norm_cast, deprecated]\ntheorem cast_bit0 (n : \u2124) : ((bit0 n : \u2124) : R) = bit0 (n : R)", "start": [140, 1], "end": [142, 19], "kind": "commanddeclaration"}, {"full_name": "Int.cast_bit1", "code": "@[norm_cast, deprecated]\ntheorem cast_bit1 (n : \u2124) : ((bit1 n : \u2124) : R) = bit1 (n : R)", "start": [145, 1], "end": [147, 59], "kind": "commanddeclaration"}, {"full_name": "Int.cast_two", "code": "theorem cast_two : ((2 : \u2124) : R) = 2", "start": [152, 1], "end": [153, 78], "kind": "commanddeclaration"}, {"full_name": "Int.cast_three", "code": "theorem cast_three : ((3 : \u2124) : R) = 3", "start": [156, 1], "end": [157, 78], "kind": "commanddeclaration"}, {"full_name": "Int.cast_four", "code": "theorem cast_four : ((4 : \u2124) : R) = 4", "start": [160, 1], "end": [161, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/BooleanAlgebra.lean", "imports": ["Mathlib/Order/Heyting/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "GeneralizedBooleanAlgebra", "code": "class GeneralizedBooleanAlgebra (\u03b1 : Type u) extends DistribLattice \u03b1, SDiff \u03b1, Bot \u03b1 where\n  \n  sup_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2294 a \\ b = a\n  \n  inf_inf_sdiff : \u2200 a b : \u03b1, a \u2293 b \u2293 a \\ b = \u22a5", "start": [77, 1], "end": [87, 47], "kind": "commanddeclaration"}, {"full_name": "sup_inf_sdiff", "code": "@[simp]\ntheorem sup_inf_sdiff (x y : \u03b1) : x \u2293 y \u2294 x \\ y = x", "start": [96, 1], "end": [98, 46], "kind": "commanddeclaration"}, {"full_name": "inf_inf_sdiff", "code": "@[simp]\ntheorem inf_inf_sdiff (x y : \u03b1) : x \u2293 y \u2293 x \\ y = \u22a5", "start": [101, 1], "end": [103, 46], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_inf", "code": "@[simp]\ntheorem sup_sdiff_inf (x y : \u03b1) : x \\ y \u2294 x \u2293 y = x", "start": [106, 1], "end": [107, 87], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_inf", "code": "@[simp]\ntheorem inf_sdiff_inf (x y : \u03b1) : x \\ y \u2293 (x \u2293 y) = \u22a5", "start": [110, 1], "end": [111, 89], "kind": "commanddeclaration"}, {"full_name": "GeneralizedBooleanAlgebra.toOrderBot", "code": "instance (priority := 100) GeneralizedBooleanAlgebra.toOrderBot : OrderBot \u03b1 :=\n  { GeneralizedBooleanAlgebra.toBot with\n    bot_le := fun a => by\n      rw [\u2190 inf_inf_sdiff a a, inf_assoc]\n      exact inf_le_left }", "start": [115, 1], "end": [119, 26], "kind": "commanddeclaration"}, {"full_name": "disjoint_inf_sdiff", "code": "theorem disjoint_inf_sdiff : Disjoint (x \u2293 y) (x \\ y)", "start": [122, 1], "end": [123, 49], "kind": "commanddeclaration"}, {"full_name": "sdiff_unique", "code": "theorem sdiff_unique (s : x \u2293 y \u2294 z = x) (i : x \u2293 y \u2293 z = \u22a5) : x \\ y = z", "start": [127, 1], "end": [132, 39], "kind": "commanddeclaration"}, {"full_name": "sdiff_le'", "code": "private theorem sdiff_le' : x \\ y \u2264 x", "start": [136, 1], "end": [139, 31], "kind": "commanddeclaration"}, {"full_name": "sdiff_sup_self'", "code": "private theorem sdiff_sup_self' : y \\ x \u2294 x = y \u2294 x", "start": [142, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "sdiff_inf_sdiff", "code": "@[simp]\ntheorem sdiff_inf_sdiff : x \\ y \u2293 y \\ x = \u22a5", "start": [148, 1], "end": [160, 61], "kind": "commanddeclaration"}, {"full_name": "disjoint_sdiff_sdiff", "code": "theorem disjoint_sdiff_sdiff : Disjoint (x \\ y) (y \\ x)", "start": [163, 1], "end": [164, 45], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_self_right", "code": "@[simp]\ntheorem inf_sdiff_self_right : x \u2293 y \\ x = \u22a5", "start": [167, 1], "end": [172, 83], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_self_left", "code": "@[simp]\ntheorem inf_sdiff_self_left : y \\ x \u2293 x = \u22a5", "start": [175, 1], "end": [176, 86], "kind": "commanddeclaration"}, {"full_name": "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra", "code": "instance (priority := 100) GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra :\n    GeneralizedCoheytingAlgebra \u03b1 :=\n  { \u2039GeneralizedBooleanAlgebra \u03b1\u203a, GeneralizedBooleanAlgebra.toOrderBot with\n    sdiff := (\u00b7 \\ \u00b7),\n    sdiff_le_iff := fun y x z =>\n      \u27e8fun h =>\n        le_of_inf_le_sup_le\n          (le_of_eq\n            (calc\n              y \u2293 y \\ x = y \\ x := inf_of_le_right sdiff_le'\n              _ = x \u2293 y \\ x \u2294 z \u2293 y \\ x :=\n                by rw [inf_eq_right.2 h, inf_sdiff_self_right, bot_sup_eq]\n              _ = (x \u2294 z) \u2293 y \\ x := inf_sup_right.symm))\n          (calc\n            y \u2294 y \\ x = y := sup_of_le_left sdiff_le'\n            _ \u2264 y \u2294 (x \u2294 z) := le_sup_left\n            _ = y \\ x \u2294 x \u2294 z := by rw [\u2190 sup_assoc, \u2190 @sdiff_sup_self' _ x y]\n            _ = x \u2294 z \u2294 y \\ x := by ac_rfl),\n        fun h =>\n        le_of_inf_le_sup_le\n          (calc\n            y \\ x \u2293 x = \u22a5 := inf_sdiff_self_left\n            _ \u2264 z \u2293 x := bot_le)\n          (calc\n            y \\ x \u2294 x = y \u2294 x := sdiff_sup_self'\n            _ \u2264 x \u2294 z \u2294 x := sup_le_sup_right h x\n            _ \u2264 z \u2294 x := by rw [sup_assoc, sup_comm, sup_assoc, sup_idem])\u27e9 }", "start": [180, 1], "end": [206, 78], "kind": "commanddeclaration"}, {"full_name": "disjoint_sdiff_self_left", "code": "theorem disjoint_sdiff_self_left : Disjoint (y \\ x) x", "start": [209, 1], "end": [210, 49], "kind": "commanddeclaration"}, {"full_name": "disjoint_sdiff_self_right", "code": "theorem disjoint_sdiff_self_right : Disjoint x (y \\ x)", "start": [213, 1], "end": [214, 50], "kind": "commanddeclaration"}, {"full_name": "le_sdiff", "code": "lemma le_sdiff : x \u2264 y \\ z \u2194 x \u2264 y \u2227 Disjoint x z :=\n  \u27e8fun h \u21a6 \u27e8h.trans sdiff_le, disjoint_sdiff_self_left.mono_left h\u27e9, fun h \u21a6\n    by rw [\u2190h.2.sdiff_eq_left]; exact sdiff_le_sdiff_right h.1\u27e9", "start": [217, 1], "end": [219, 64], "kind": "mathlibtacticlemma"}, {"full_name": "sdiff_eq_left", "code": "@[simp] lemma sdiff_eq_left : x \\ y = x \u2194 Disjoint x y :=\n  \u27e8fun h \u21a6 disjoint_sdiff_self_left.mono_left h.ge, Disjoint.sdiff_eq_left\u27e9", "start": [222, 1], "end": [223, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Disjoint.sdiff_eq_of_sup_eq", "code": "theorem Disjoint.sdiff_eq_of_sup_eq (hi : Disjoint x z) (hs : x \u2294 z = y) : y \\ x = z", "start": [228, 1], "end": [230, 54], "kind": "commanddeclaration"}, {"full_name": "Disjoint.sdiff_unique", "code": "protected theorem Disjoint.sdiff_unique (hd : Disjoint x z) (hz : z \u2264 y) (hs : y \u2264 x \u2294 z) :\n    y \\ x = z", "start": [233, 1], "end": [240, 47], "kind": "commanddeclaration"}, {"full_name": "disjoint_sdiff_iff_le", "code": "theorem disjoint_sdiff_iff_le (hz : z \u2264 y) (hx : x \u2264 y) : Disjoint z (y \\ x) \u2194 z \u2264 x", "start": [244, 1], "end": [251, 52], "kind": "commanddeclaration"}, {"full_name": "le_iff_disjoint_sdiff", "code": "theorem le_iff_disjoint_sdiff (hz : z \u2264 y) (hx : x \u2264 y) : z \u2264 x \u2194 Disjoint z (y \\ x)", "start": [255, 1], "end": [256, 37], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_eq_bot_iff", "code": "theorem inf_sdiff_eq_bot_iff (hz : z \u2264 y) (hx : x \u2264 y) : z \u2293 y \\ x = \u22a5 \u2194 z \u2264 x", "start": [260, 1], "end": [262, 36], "kind": "commanddeclaration"}, {"full_name": "le_iff_eq_sup_sdiff", "code": "theorem le_iff_eq_sup_sdiff (hz : z \u2264 y) (hx : x \u2264 y) : x \u2264 z \u2194 y = z \u2294 y \\ x", "start": [266, 1], "end": [279, 18], "kind": "commanddeclaration"}, {"full_name": "sdiff_sup", "code": "theorem sdiff_sup : y \\ (x \u2294 z) = y \\ x \u2293 y \\ z", "start": [283, 1], "end": [298, 50], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_sdiff_iff_inf_eq_inf", "code": "theorem sdiff_eq_sdiff_iff_inf_eq_inf : y \\ x = y \\ z \u2194 y \u2293 x = y \u2293 z", "start": [301, 1], "end": [304, 96], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_self_iff_disjoint", "code": "theorem sdiff_eq_self_iff_disjoint : x \\ y = x \u2194 Disjoint y x", "start": [307, 1], "end": [311, 67], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_self_iff_disjoint'", "code": "theorem sdiff_eq_self_iff_disjoint' : x \\ y = x \u2194 Disjoint x y", "start": [314, 1], "end": [315, 49], "kind": "commanddeclaration"}, {"full_name": "sdiff_lt", "code": "theorem sdiff_lt (hx : y \u2264 x) (hy : y \u2260 \u22a5) : x \\ y < x", "start": [318, 1], "end": [321, 32], "kind": "commanddeclaration"}, {"full_name": "le_sdiff_iff", "code": "@[simp]\ntheorem le_sdiff_iff : x \u2264 y \\ x \u2194 x = \u22a5", "start": [324, 1], "end": [326, 98], "kind": "commanddeclaration"}, {"full_name": "sdiff_lt_sdiff_right", "code": "theorem sdiff_lt_sdiff_right (h : x < y) (hz : z \u2264 x) : x \\ z < y \\ z", "start": [329, 1], "end": [331, 79], "kind": "commanddeclaration"}, {"full_name": "sup_inf_inf_sdiff", "code": "theorem sup_inf_inf_sdiff : x \u2293 y \u2293 z \u2294 y \\ z = x \u2293 y \u2294 y \\ z", "start": [334, 1], "end": [338, 63], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_right", "code": "theorem sdiff_sdiff_right : x \\ (y \\ z) = x \\ y \u2294 x \u2293 y \u2293 z", "start": [341, 1], "end": [362, 68], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_right'", "code": "theorem sdiff_sdiff_right' : x \\ (y \\ z) = x \\ y \u2294 x \u2293 z", "start": [365, 1], "end": [369, 71], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_eq_sdiff_sup", "code": "theorem sdiff_sdiff_eq_sdiff_sup (h : z \u2264 x) : x \\ (y \\ z) = x \\ y \u2294 z", "start": [372, 1], "end": [373, 44], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_right_self", "code": "@[simp]\ntheorem sdiff_sdiff_right_self : x \\ (x \\ y) = x \u2293 y", "start": [376, 1], "end": [378, 59], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_eq_self", "code": "theorem sdiff_sdiff_eq_self (h : y \u2264 x) : x \\ (x \\ y) = y", "start": [381, 1], "end": [382, 49], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_symm", "code": "theorem sdiff_eq_symm (hy : y \u2264 x) (h : x \\ y = z) : x \\ z = y", "start": [385, 1], "end": [386, 35], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq_comm", "code": "theorem sdiff_eq_comm (hy : y \u2264 x) (hz : z \u2264 x) : x \\ y = z \u2194 x \\ z = y", "start": [389, 1], "end": [390, 39], "kind": "commanddeclaration"}, {"full_name": "eq_of_sdiff_eq_sdiff", "code": "theorem eq_of_sdiff_eq_sdiff (hxz : x \u2264 z) (hyz : y \u2264 z) (h : z \\ x = z \\ y) : x = y", "start": [393, 1], "end": [394, 61], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_left'", "code": "theorem sdiff_sdiff_left' : (x \\ y) \\ z = x \\ y \u2293 x \\ z", "start": [397, 1], "end": [397, 95], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_sup_sdiff", "code": "theorem sdiff_sdiff_sup_sdiff : z \\ (x \\ y \u2294 y \\ x) = z \u2293 (z \\ x \u2294 y) \u2293 (z \\ y \u2294 x)", "start": [400, 1], "end": [408, 58], "kind": "commanddeclaration"}, {"full_name": "sdiff_sdiff_sup_sdiff'", "code": "theorem sdiff_sdiff_sup_sdiff' : z \\ (x \\ y \u2294 y \\ x) = z \u2293 x \u2293 y \u2294 z \\ x \u2293 z \\ y", "start": [411, 1], "end": [417, 47], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff", "code": "theorem inf_sdiff : (x \u2293 y) \\ z = x \\ z \u2293 y \\ z", "start": [420, 1], "end": [432, 69], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_assoc", "code": "theorem inf_sdiff_assoc : (x \u2293 y) \\ z = x \u2293 y \\ z", "start": [435, 1], "end": [443, 50], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_right_comm", "code": "theorem inf_sdiff_right_comm : x \\ z \u2293 y = (x \u2293 y) \\ z", "start": [446, 1], "end": [447, 50], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_distrib_left", "code": "theorem inf_sdiff_distrib_left (a b c : \u03b1) : a \u2293 b \\ c = (a \u2293 b) \\ (a \u2293 c)", "start": [450, 1], "end": [451, 78], "kind": "commanddeclaration"}, {"full_name": "inf_sdiff_distrib_right", "code": "theorem inf_sdiff_distrib_right (a b c : \u03b1) : a \\ b \u2293 c = (a \u2293 c) \\ (b \u2293 c)", "start": [454, 1], "end": [455, 54], "kind": "commanddeclaration"}, {"full_name": "disjoint_sdiff_comm", "code": "theorem disjoint_sdiff_comm : Disjoint (x \\ z) y \u2194 Disjoint x (y \\ z)", "start": [458, 1], "end": [459, 64], "kind": "commanddeclaration"}, {"full_name": "sup_eq_sdiff_sup_sdiff_sup_inf", "code": "theorem sup_eq_sdiff_sup_sdiff_sup_inf : x \u2294 y = x \\ y \u2294 y \\ x \u2294 x \u2293 y", "start": [462, 1], "end": [468, 79], "kind": "commanddeclaration"}, {"full_name": "sup_lt_of_lt_sdiff_left", "code": "theorem sup_lt_of_lt_sdiff_left (h : y < z \\ x) (hxz : x \u2264 z) : x \u2294 y < z", "start": [471, 1], "end": [475, 62], "kind": "commanddeclaration"}, {"full_name": "sup_lt_of_lt_sdiff_right", "code": "theorem sup_lt_of_lt_sdiff_right (h : x < z \\ y) (hyz : y \u2264 z) : x \u2294 y < z", "start": [478, 1], "end": [482, 63], "kind": "commanddeclaration"}, {"full_name": "Pi.generalizedBooleanAlgebra", "code": "instance Pi.generalizedBooleanAlgebra {\u03b1 : Type u} {\u03b2 : Type v} [GeneralizedBooleanAlgebra \u03b2] :\n    GeneralizedBooleanAlgebra (\u03b1 \u2192 \u03b2) where\n  sup_inf_sdiff := fun f g => funext fun a => sup_inf_sdiff (f a) (g a)\n  inf_inf_sdiff := fun f g => funext fun a => inf_inf_sdiff (f a) (g a)", "start": [487, 1], "end": [490, 72], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra", "code": "class BooleanAlgebra (\u03b1 : Type u) extends\n    DistribLattice \u03b1, HasCompl \u03b1, SDiff \u03b1, HImp \u03b1, Top \u03b1, Bot \u03b1 where\n  \n  inf_compl_le_bot : \u2200 x : \u03b1, x \u2293 x\u1d9c \u2264 \u22a5\n  \n  top_le_sup_compl : \u2200 x : \u03b1, \u22a4 \u2264 x \u2294 x\u1d9c\n  \n  le_top : \u2200 a : \u03b1, a \u2264 \u22a4\n  \n  bot_le : \u2200 a : \u03b1, \u22a5 \u2264 a\n  \n  sdiff := fun x y => x \u2293 y\u1d9c\n  \n  himp := fun x y => y \u2294 x\u1d9c\n  \n  sdiff_eq : \u2200 x y : \u03b1, x \\ y = x \u2293 y\u1d9c := by aesop\n  \n  himp_eq : \u2200 x y : \u03b1, x \u21e8 y = y \u2294 x\u1d9c := by aesop", "start": [500, 1], "end": [528, 50], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.toBoundedOrder", "code": "instance (priority := 100) BooleanAlgebra.toBoundedOrder [h : BooleanAlgebra \u03b1] : BoundedOrder \u03b1 :=\n  { h with }", "start": [532, 1], "end": [533, 13], "kind": "commanddeclaration"}, {"full_name": "GeneralizedBooleanAlgebra.toBooleanAlgebra", "code": "@[reducible]\ndef GeneralizedBooleanAlgebra.toBooleanAlgebra [GeneralizedBooleanAlgebra \u03b1] [OrderTop \u03b1] :\n    BooleanAlgebra \u03b1 :=\n  { \u2039GeneralizedBooleanAlgebra \u03b1\u203a, GeneralizedBooleanAlgebra.toOrderBot, \u2039OrderTop \u03b1\u203a with\n    compl := fun a => \u22a4 \\ a,\n    inf_compl_le_bot := fun _ => disjoint_sdiff_self_right.le_bot,\n    top_le_sup_compl := fun _ => le_sup_sdiff,\n    sdiff_eq := fun _ _ => by\n      erw [\u2190 inf_sdiff_assoc, inf_top_eq] }", "start": [537, 1], "end": [548, 44], "kind": "commanddeclaration"}, {"full_name": "inf_compl_eq_bot'", "code": "theorem inf_compl_eq_bot' : x \u2293 x\u1d9c = \u22a5", "start": [555, 1], "end": [556, 50], "kind": "commanddeclaration"}, {"full_name": "sup_compl_eq_top", "code": "@[simp]\ntheorem sup_compl_eq_top : x \u2294 x\u1d9c = \u22a4", "start": [559, 1], "end": [561, 50], "kind": "commanddeclaration"}, {"full_name": "compl_sup_eq_top", "code": "@[simp]\ntheorem compl_sup_eq_top : x\u1d9c \u2294 x = \u22a4", "start": [564, 1], "end": [566, 34], "kind": "commanddeclaration"}, {"full_name": "isCompl_compl", "code": "theorem isCompl_compl : IsCompl x x\u1d9c", "start": [569, 1], "end": [570, 51], "kind": "commanddeclaration"}, {"full_name": "sdiff_eq", "code": "theorem sdiff_eq : x \\ y = x \u2293 y\u1d9c", "start": [573, 1], "end": [574, 30], "kind": "commanddeclaration"}, {"full_name": "himp_eq", "code": "theorem himp_eq : x \u21e8 y = y \u2294 x\u1d9c", "start": [577, 1], "end": [578, 29], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.toComplementedLattice", "code": "instance (priority := 100) BooleanAlgebra.toComplementedLattice : ComplementedLattice \u03b1 :=\n  \u27e8fun x => \u27e8x\u1d9c, isCompl_compl\u27e9\u27e9", "start": [581, 1], "end": [582, 33], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.toGeneralizedBooleanAlgebra", "code": "instance (priority := 100) BooleanAlgebra.toGeneralizedBooleanAlgebra :\n    GeneralizedBooleanAlgebra \u03b1 :=\n  { \u2039BooleanAlgebra \u03b1\u203a with\n    sup_inf_sdiff := fun a b => by rw [sdiff_eq, \u2190 inf_sup_left, sup_compl_eq_top, inf_top_eq],\n    inf_inf_sdiff := fun a b => by\n      rw [sdiff_eq, \u2190 inf_inf_distrib_left, inf_compl_eq_bot', inf_bot_eq] }", "start": [586, 1], "end": [591, 77], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.toBiheytingAlgebra", "code": "instance (priority := 100) BooleanAlgebra.toBiheytingAlgebra : BiheytingAlgebra \u03b1 :=\n  { \u2039BooleanAlgebra \u03b1\u203a, GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra with\n    hnot := compl,\n    le_himp_iff := fun a b c => by rw [himp_eq, isCompl_compl.le_sup_right_iff_inf_left_le],\n    himp_bot := fun _ => _root_.himp_eq.trans bot_sup_eq,\n    top_sdiff := fun a => by rw [sdiff_eq, top_inf_eq]; rfl }", "start": [595, 1], "end": [600, 62], "kind": "commanddeclaration"}, {"full_name": "hnot_eq_compl", "code": "@[simp]\ntheorem hnot_eq_compl : \uffe2x = x\u1d9c", "start": [603, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "top_sdiff", "code": "theorem top_sdiff : \u22a4 \\ x = x\u1d9c", "start": [609, 1], "end": [610, 15], "kind": "commanddeclaration"}, {"full_name": "eq_compl_iff_isCompl", "code": "theorem eq_compl_iff_isCompl : x = y\u1d9c \u2194 IsCompl x y", "start": [613, 1], "end": [616, 48], "kind": "commanddeclaration"}, {"full_name": "compl_eq_iff_isCompl", "code": "theorem compl_eq_iff_isCompl : x\u1d9c = y \u2194 IsCompl x y", "start": [619, 1], "end": [622, 43], "kind": "commanddeclaration"}, {"full_name": "compl_eq_comm", "code": "theorem compl_eq_comm : x\u1d9c = y \u2194 y\u1d9c = x", "start": [625, 1], "end": [626, 59], "kind": "commanddeclaration"}, {"full_name": "eq_compl_comm", "code": "theorem eq_compl_comm : x = y\u1d9c \u2194 y = x\u1d9c", "start": [629, 1], "end": [630, 59], "kind": "commanddeclaration"}, {"full_name": "compl_compl", "code": "@[simp]\ntheorem compl_compl (x : \u03b1) : x\u1d9c\u1d9c = x", "start": [633, 1], "end": [635, 39], "kind": "commanddeclaration"}, {"full_name": "compl_comp_compl", "code": "theorem compl_comp_compl : compl \u2218 compl = @id \u03b1", "start": [638, 1], "end": [639, 21], "kind": "commanddeclaration"}, {"full_name": "compl_involutive", "code": "@[simp]\ntheorem compl_involutive : Function.Involutive (compl : \u03b1 \u2192 \u03b1)", "start": [642, 1], "end": [644, 14], "kind": "commanddeclaration"}, {"full_name": "compl_bijective", "code": "theorem compl_bijective : Function.Bijective (compl : \u03b1 \u2192 \u03b1)", "start": [647, 1], "end": [648, 29], "kind": "commanddeclaration"}, {"full_name": "compl_surjective", "code": "theorem compl_surjective : Function.Surjective (compl : \u03b1 \u2192 \u03b1)", "start": [651, 1], "end": [652, 30], "kind": "commanddeclaration"}, {"full_name": "compl_injective", "code": "theorem compl_injective : Function.Injective (compl : \u03b1 \u2192 \u03b1)", "start": [655, 1], "end": [656, 29], "kind": "commanddeclaration"}, {"full_name": "compl_inj_iff", "code": "@[simp]\ntheorem compl_inj_iff : x\u1d9c = y\u1d9c \u2194 x = y", "start": [659, 1], "end": [661, 25], "kind": "commanddeclaration"}, {"full_name": "IsCompl.compl_eq_iff", "code": "theorem IsCompl.compl_eq_iff (h : IsCompl x y) : z\u1d9c = y \u2194 z = x", "start": [664, 1], "end": [665, 29], "kind": "commanddeclaration"}, {"full_name": "compl_eq_top", "code": "@[simp]\ntheorem compl_eq_top : x\u1d9c = \u22a4 \u2194 x = \u22a5", "start": [668, 1], "end": [670, 31], "kind": "commanddeclaration"}, {"full_name": "compl_eq_bot", "code": "@[simp]\ntheorem compl_eq_bot : x\u1d9c = \u22a5 \u2194 x = \u22a4", "start": [673, 1], "end": [675, 31], "kind": "commanddeclaration"}, {"full_name": "compl_inf", "code": "@[simp]\ntheorem compl_inf : (x \u2293 y)\u1d9c = x\u1d9c \u2294 y\u1d9c", "start": [678, 1], "end": [680, 23], "kind": "commanddeclaration"}, {"full_name": "compl_le_compl_iff_le", "code": "@[simp]\ntheorem compl_le_compl_iff_le : y\u1d9c \u2264 x\u1d9c \u2194 x \u2264 y", "start": [683, 1], "end": [685, 82], "kind": "commanddeclaration"}, {"full_name": "compl_lt_compl_iff_lt", "code": "@[simp] lemma compl_lt_compl_iff_lt : y\u1d9c < x\u1d9c \u2194 x < y :=\n  lt_iff_lt_of_le_iff_le' compl_le_compl_iff_le compl_le_compl_iff_le", "start": [688, 1], "end": [689, 70], "kind": "mathlibtacticlemma"}, {"full_name": "compl_le_of_compl_le", "code": "theorem compl_le_of_compl_le (h : y\u1d9c \u2264 x) : x\u1d9c \u2264 y", "start": [691, 1], "end": [692, 50], "kind": "commanddeclaration"}, {"full_name": "compl_le_iff_compl_le", "code": "theorem compl_le_iff_compl_le : x\u1d9c \u2264 y \u2194 y\u1d9c \u2264 x", "start": [695, 1], "end": [696, 47], "kind": "commanddeclaration"}, {"full_name": "compl_le_self", "code": "@[simp] theorem compl_le_self : x\u1d9c \u2264 x \u2194 x = \u22a4", "start": [699, 1], "end": [699, 89], "kind": "commanddeclaration"}, {"full_name": "compl_lt_self", "code": "@[simp] theorem compl_lt_self [Nontrivial \u03b1] : x\u1d9c < x \u2194 x = \u22a4", "start": [701, 1], "end": [702, 38], "kind": "commanddeclaration"}, {"full_name": "sdiff_compl", "code": "@[simp]\ntheorem sdiff_compl : x \\ y\u1d9c = x \u2293 y", "start": [704, 1], "end": [705, 70], "kind": "commanddeclaration"}, {"full_name": "OrderDual.booleanAlgebra", "code": "instance OrderDual.booleanAlgebra (\u03b1) [BooleanAlgebra \u03b1] : BooleanAlgebra \u03b1\u1d52\u1d48 :=\n  { OrderDual.distribLattice \u03b1, OrderDual.boundedOrder \u03b1 with\n    compl := fun a => toDual (ofDual a\u1d9c),\n    sdiff :=\n      fun a b => toDual (ofDual b \u21e8 ofDual a), himp := fun a b => toDual (ofDual b \\ ofDual a),\n    inf_compl_le_bot := fun a => (@codisjoint_hnot_right _ _ (ofDual a)).top_le,\n    top_le_sup_compl := fun a => (@disjoint_compl_right _ _ (ofDual a)).le_bot,\n    sdiff_eq := fun _ _ => @himp_eq \u03b1 _ _ _,\n    himp_eq := fun _ _ => @sdiff_eq \u03b1 _ _ _, }", "start": [708, 1], "end": [716, 47], "kind": "commanddeclaration"}, {"full_name": "sup_inf_inf_compl", "code": "@[simp]\ntheorem sup_inf_inf_compl : x \u2293 y \u2294 x \u2293 y\u1d9c = x", "start": [718, 1], "end": [719, 88], "kind": "commanddeclaration"}, {"full_name": "compl_sdiff", "code": "@[simp]\ntheorem compl_sdiff : (x \\ y)\u1d9c = x \u21e8 y", "start": [722, 1], "end": [724, 59], "kind": "commanddeclaration"}, {"full_name": "compl_himp", "code": "@[simp]\ntheorem compl_himp : (x \u21e8 y)\u1d9c = x \\ y", "start": [727, 1], "end": [729, 25], "kind": "commanddeclaration"}, {"full_name": "compl_sdiff_compl", "code": "theorem compl_sdiff_compl : x\u1d9c \\ y\u1d9c = y \\ x", "start": [732, 1], "end": [732, 87], "kind": "commanddeclaration"}, {"full_name": "compl_himp_compl", "code": "@[simp]\ntheorem compl_himp_compl : x\u1d9c \u21e8 y\u1d9c = y \u21e8 x", "start": [735, 1], "end": [737, 31], "kind": "commanddeclaration"}, {"full_name": "disjoint_compl_left_iff", "code": "theorem disjoint_compl_left_iff : Disjoint x\u1d9c y \u2194 y \u2264 x", "start": [740, 1], "end": [741, 49], "kind": "commanddeclaration"}, {"full_name": "disjoint_compl_right_iff", "code": "theorem disjoint_compl_right_iff : Disjoint x y\u1d9c \u2194 x \u2264 y", "start": [744, 1], "end": [745, 50], "kind": "commanddeclaration"}, {"full_name": "codisjoint_himp_self_left", "code": "theorem codisjoint_himp_self_left : Codisjoint (x \u21e8 y) x", "start": [748, 1], "end": [749, 38], "kind": "commanddeclaration"}, {"full_name": "codisjoint_himp_self_right", "code": "theorem codisjoint_himp_self_right : Codisjoint x (x \u21e8 y)", "start": [752, 1], "end": [753, 39], "kind": "commanddeclaration"}, {"full_name": "himp_le", "code": "theorem himp_le : x \u21e8 y \u2264 z \u2194 y \u2264 z \u2227 Codisjoint x z", "start": [756, 1], "end": [757, 83], "kind": "commanddeclaration"}, {"full_name": "Prop.booleanAlgebra", "code": "instance Prop.booleanAlgebra : BooleanAlgebra Prop :=\n  { Prop.heytingAlgebra, GeneralizedHeytingAlgebra.toDistribLattice with\n    compl := Not,\n    himp_eq := fun p q => propext imp_iff_or_not,\n    inf_compl_le_bot := fun p \u27e8Hp, Hpc\u27e9 => Hpc Hp,\n    top_le_sup_compl := fun p _ => Classical.em p }", "start": [762, 1], "end": [767, 52], "kind": "commanddeclaration"}, {"full_name": "Prod.booleanAlgebra", "code": "instance Prod.booleanAlgebra (\u03b1 \u03b2) [BooleanAlgebra \u03b1] [BooleanAlgebra \u03b2] :\n    BooleanAlgebra (\u03b1 \u00d7 \u03b2) where\n  __ := Prod.heytingAlgebra\n  __ := Prod.distribLattice \u03b1 \u03b2\n  himp_eq x y := by ext <;> simp [himp_eq]\n  sdiff_eq x y := by ext <;> simp [sdiff_eq]\n  inf_compl_le_bot x := by constructor <;> simp\n  top_le_sup_compl x := by constructor <;> simp", "start": [770, 1], "end": [777, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.booleanAlgebra", "code": "instance Pi.booleanAlgebra {\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} [\u2200 i, BooleanAlgebra (\u03b1 i)] :\n    BooleanAlgebra (\u2200 i, \u03b1 i) :=\n  { Pi.sdiff, Pi.heytingAlgebra, @Pi.distribLattice \u03b9 \u03b1 _ with\n    sdiff_eq := fun _ _ => funext fun _ => sdiff_eq,\n    himp_eq := fun _ _ => funext fun _ => himp_eq,\n    inf_compl_le_bot := fun _ _ => BooleanAlgebra.inf_compl_le_bot _,\n    top_le_sup_compl := fun _ _ => BooleanAlgebra.top_le_sup_compl _ }", "start": [779, 1], "end": [785, 71], "kind": "commanddeclaration"}, {"full_name": "Bool.sup_eq_bor", "code": "@[simp]\ntheorem Bool.sup_eq_bor : (\u00b7 \u2294 \u00b7) = or", "start": [803, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "Bool.inf_eq_band", "code": "@[simp]\ntheorem Bool.inf_eq_band : (\u00b7 \u2293 \u00b7) = and", "start": [808, 1], "end": [810, 6], "kind": "commanddeclaration"}, {"full_name": "Bool.compl_eq_bnot", "code": "@[simp]\ntheorem Bool.compl_eq_bnot : HasCompl.compl = not", "start": [813, 1], "end": [815, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.generalizedBooleanAlgebra", "code": "@[reducible]\nprotected def Function.Injective.generalizedBooleanAlgebra [Sup \u03b1] [Inf \u03b1] [Bot \u03b1] [SDiff \u03b1]\n    [GeneralizedBooleanAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_bot : f \u22a5 = \u22a5) (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) :\n    GeneralizedBooleanAlgebra \u03b1 :=\n  { hf.generalizedCoheytingAlgebra f map_sup map_inf map_bot map_sdiff,\n    hf.distribLattice f map_sup map_inf with\n    sup_inf_sdiff := fun a b => hf <| by erw [map_sup, map_sdiff, map_inf, sup_inf_sdiff],\n    inf_inf_sdiff := fun a b => hf <| by erw [map_inf, map_sdiff, map_inf, inf_inf_sdiff, map_bot] }", "start": [821, 1], "end": [831, 101], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.booleanAlgebra", "code": "@[reducible]\nprotected def Function.Injective.booleanAlgebra [Sup \u03b1] [Inf \u03b1] [Top \u03b1] [Bot \u03b1] [HasCompl \u03b1]\n    [SDiff \u03b1] [BooleanAlgebra \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Injective f)\n    (map_sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (map_inf : \u2200 a b, f (a \u2293 b) = f a \u2293 f b)\n    (map_top : f \u22a4 = \u22a4) (map_bot : f \u22a5 = \u22a5) (map_compl : \u2200 a, f a\u1d9c = (f a)\u1d9c)\n    (map_sdiff : \u2200 a b, f (a \\ b) = f a \\ f b) : BooleanAlgebra \u03b1 :=\n  { hf.generalizedBooleanAlgebra f map_sup map_inf map_bot map_sdiff with\n    compl := compl,\n    top := \u22a4,\n    le_top := fun a => (@le_top \u03b2 _ _ _).trans map_top.ge,\n    bot_le := fun a => map_bot.le.trans bot_le,\n    inf_compl_le_bot :=\n      fun a => ((map_inf _ _).trans <| by rw [map_compl, inf_compl_eq_bot, map_bot]).le,\n    top_le_sup_compl :=\n      fun a => ((map_sup _ _).trans <| by rw [map_compl, sup_compl_eq_top, map_top]).ge,\n    sdiff_eq := fun a b => by\n      refine hf ((map_sdiff _ _).trans (sdiff_eq.trans ?_))\n      rw [map_inf, map_compl] }", "start": [835, 1], "end": [853, 32], "kind": "commanddeclaration"}, {"full_name": "PUnit.booleanAlgebra", "code": "instance PUnit.booleanAlgebra : BooleanAlgebra PUnit := by\n  refine'\n  { PUnit.biheytingAlgebra with\n    .. } <;> (intros; trivial)", "start": [858, 1], "end": [861, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Hom/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "toUnits", "code": "@[to_additive \"An additive group is isomorphic to its group of additive units\"]\ndef toUnits [Group G] : G \u2243* G\u02e3 where\n  toFun x := \u27e8x, x\u207b\u00b9, mul_inv_self _, inv_mul_self _\u27e9\n  invFun x := x\n  left_inv _ := rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := Units.ext rfl", "start": [17, 1], "end": [24, 32], "kind": "commanddeclaration"}, {"full_name": "coe_toUnits", "code": "@[to_additive (attr := simp)]\ntheorem coe_toUnits [Group G] (g : G) : (toUnits g : G) = g", "start": [28, 1], "end": [30, 6], "kind": "commanddeclaration"}, {"full_name": "Units.mapEquiv", "code": "def mapEquiv (h : M \u2243* N) : M\u02e3 \u2243* N\u02e3 :=\n  { map h.toMonoidHom with\n    invFun := map h.symm.toMonoidHom,\n    left_inv := fun u => ext <| h.left_inv u,\n    right_inv := fun u => ext <| h.right_inv u }", "start": [38, 1], "end": [44, 49], "kind": "commanddeclaration"}, {"full_name": "Units.mapEquiv_symm", "code": "@[simp]\ntheorem mapEquiv_symm (h : M \u2243* N) : (mapEquiv h).symm = mapEquiv h.symm", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Units.coe_mapEquiv", "code": "@[simp]\ntheorem coe_mapEquiv (h : M \u2243* N) (x : M\u02e3) : (mapEquiv h x : N) = h x", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Units.mulLeft", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }) apply)\n  \"Left addition of an additive unit is a permutation of the underlying type.\"]\ndef mulLeft (u : M\u02e3) : Equiv.Perm M where\n  toFun x := u * x\n  invFun x := u\u207b\u00b9 * x\n  left_inv := u.inv_mul_cancel_left\n  right_inv := u.mul_inv_cancel_left", "start": [57, 1], "end": [64, 37], "kind": "commanddeclaration"}, {"full_name": "Units.mulLeft_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulLeft_symm (u : M\u02e3) : u.mulLeft.symm = u\u207b\u00b9.mulLeft", "start": [70, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "Units.mulLeft_bijective", "code": "@[to_additive]\ntheorem mulLeft_bijective (a : M\u02e3) : Function.Bijective ((a * \u00b7) : M \u2192 M)", "start": [76, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Units.mulRight", "code": "@[to_additive (attr := simps (config := { fullyApplied := false }) apply)\n\"Right addition of an additive unit is a permutation of the underlying type.\"]\ndef mulRight (u : M\u02e3) : Equiv.Perm M where\n  toFun x := x * u\n  invFun x := x * \u2191u\u207b\u00b9\n  left_inv x := mul_inv_cancel_right x u\n  right_inv x := inv_mul_cancel_right x u", "start": [82, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "Units.mulRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulRight_symm (u : M\u02e3) : u.mulRight.symm = u\u207b\u00b9.mulRight", "start": [95, 1], "end": [97, 25], "kind": "commanddeclaration"}, {"full_name": "Units.mulRight_bijective", "code": "@[to_additive]\ntheorem mulRight_bijective (a : M\u02e3) : Function.Bijective ((\u00b7 * a) : M \u2192 M)", "start": [101, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulLeft", "code": "@[to_additive \"Left addition in an `AddGroup` is a permutation of the underlying type.\"]\nprotected def mulLeft (a : G) : Perm G :=\n  (toUnits a).mulLeft", "start": [115, 1], "end": [118, 22], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_mulLeft", "code": "@[to_additive (attr := simp)]\ntheorem coe_mulLeft (a : G) : \u21d1(Equiv.mulLeft a) = (\u00b7 * \u00b7) a", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulLeft_symm_apply", "code": "@[to_additive \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\",\n  simp, nolint simpNF]\ntheorem mulLeft_symm_apply (a : G) : ((Equiv.mulLeft a).symm : G \u2192 G) = (a\u207b\u00b9 * \u00b7)", "start": [130, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulLeft_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulLeft_symm (a : G) : (Equiv.mulLeft a).symm = Equiv.mulLeft a\u207b\u00b9", "start": [138, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "Group.mulLeft_bijective", "code": "@[to_additive]\ntheorem _root_.Group.mulLeft_bijective (a : G) : Function.Bijective (a * \u00b7)", "start": [144, 1], "end": [146, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulRight", "code": "@[to_additive \"Right addition in an `AddGroup` is a permutation of the underlying type.\"]\nprotected def mulRight (a : G) : Perm G :=\n  (toUnits a).mulRight", "start": [150, 1], "end": [153, 23], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_mulRight", "code": "@[to_additive (attr := simp)]\ntheorem coe_mulRight (a : G) : \u21d1(Equiv.mulRight a) = fun x => x * a", "start": [157, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem mulRight_symm (a : G) : (Equiv.mulRight a).symm = Equiv.mulRight a\u207b\u00b9", "start": [163, 1], "end": [165, 19], "kind": "commanddeclaration"}, {"full_name": "Equiv.mulRight_symm_apply", "code": "@[to_additive \"Extra simp lemma that `dsimp` can use. `simp` will never use this.\",\n  simp, nolint simpNF]\ntheorem mulRight_symm_apply (a : G) : ((Equiv.mulRight a).symm : G \u2192 G) = fun x => x * a\u207b\u00b9", "start": [169, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Group.mulRight_bijective", "code": "@[to_additive]\ntheorem _root_.Group.mulRight_bijective (a : G) : Function.Bijective (\u00b7 * a)", "start": [177, 1], "end": [179, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.divLeft", "code": "@[to_additive (attr := simps) \" A version of `Equiv.addLeft a (-b)` that is defeq to `a - b`. \"]\nprotected def divLeft (a : G) : G \u2243 G where\n  toFun b := a / b\n  invFun b := b\u207b\u00b9 * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]", "start": [183, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.divLeft_eq_inv_trans_mulLeft", "code": "@[to_additive]\ntheorem divLeft_eq_inv_trans_mulLeft (a : G) :\n    Equiv.divLeft a = (Equiv.inv G).trans (Equiv.mulLeft a)", "start": [197, 1], "end": [200, 34], "kind": "commanddeclaration"}, {"full_name": "Equiv.divRight", "code": "@[to_additive (attr := simps) \" A version of `Equiv.addRight (-a) b` that is defeq to `b - a`. \"]\nprotected def divRight (a : G) : G \u2243 G where\n  toFun b := b / a\n  invFun b := b * a\n  left_inv b := by simp [div_eq_mul_inv]\n  right_inv b := by simp [div_eq_mul_inv]", "start": [204, 1], "end": [210, 42], "kind": "commanddeclaration"}, {"full_name": "Equiv.divRight_eq_mulRight_inv", "code": "@[to_additive]\ntheorem divRight_eq_mulRight_inv (a : G) : Equiv.divRight a = Equiv.mulRight a\u207b\u00b9", "start": [218, 1], "end": [220, 34], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.inv", "code": "@[to_additive (attr := simps apply)\n  \"When the `AddGroup` is commutative, `Equiv.neg` is an `AddEquiv`.\"]\ndef MulEquiv.inv (G : Type*) [DivisionCommMonoid G] : G \u2243* G :=\n  { Equiv.inv G with toFun := Inv.inv, invFun := Inv.inv, map_mul' := mul_inv }", "start": [232, 1], "end": [237, 80], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.inv_symm", "code": "@[to_additive (attr := simp)]\ntheorem MulEquiv.inv_symm (G : Type*) [DivisionCommMonoid G] :\n    (MulEquiv.inv G).symm = MulEquiv.inv G", "start": [243, 1], "end": [246, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Order/Basic.lean", "imports": ["Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/Nat/Bits.lean", "Mathlib/Algebra/Order/Ring/Canonical.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.orderBot", "code": "instance orderBot : OrderBot \u2115 where\n  bot := 0\n  bot_le := Nat.zero_le", "start": [29, 1], "end": [31, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.linearOrderedCommSemiring", "code": "instance linearOrderedCommSemiring : LinearOrderedCommSemiring \u2115 :=\n  { Nat.commSemiring, Nat.linearOrder with\n    lt := Nat.lt, add_le_add_left := @Nat.add_le_add_left,\n    le_of_add_le_add_left := @Nat.le_of_add_le_add_left,\n    zero_le_one := Nat.le_of_lt (Nat.zero_lt_succ 0),\n    mul_lt_mul_of_pos_left := @Nat.mul_lt_mul_of_pos_left,\n    mul_lt_mul_of_pos_right := @Nat.mul_lt_mul_of_pos_right,\n    exists_pair_ne := \u27e80, 1, ne_of_lt Nat.zero_lt_one\u27e9 }", "start": [34, 1], "end": [41, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.linearOrderedCommMonoidWithZero", "code": "instance linearOrderedCommMonoidWithZero : LinearOrderedCommMonoidWithZero \u2115 :=\n  { Nat.linearOrderedCommSemiring, (inferInstance : CommMonoidWithZero \u2115) with\n    mul_le_mul_left := fun _ _ h c => Nat.mul_le_mul_left c h }", "start": [43, 1], "end": [45, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.linearOrderedSemiring", "code": "instance linearOrderedSemiring : LinearOrderedSemiring \u2115 :=\n  inferInstance", "start": [51, 1], "end": [52, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.strictOrderedSemiring", "code": "instance strictOrderedSemiring : StrictOrderedSemiring \u2115 :=\n  inferInstance", "start": [54, 1], "end": [55, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.strictOrderedCommSemiring", "code": "instance strictOrderedCommSemiring : StrictOrderedCommSemiring \u2115 :=\n  inferInstance", "start": [57, 1], "end": [58, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.orderedSemiring", "code": "instance orderedSemiring : OrderedSemiring \u2115 :=\n  StrictOrderedSemiring.toOrderedSemiring'", "start": [60, 1], "end": [61, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.orderedCommSemiring", "code": "instance orderedCommSemiring : OrderedCommSemiring \u2115 :=\n  StrictOrderedCommSemiring.toOrderedCommSemiring'", "start": [63, 1], "end": [64, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.linearOrderedCancelAddCommMonoid", "code": "instance linearOrderedCancelAddCommMonoid : LinearOrderedCancelAddCommMonoid \u2115 :=\n  inferInstance", "start": [66, 1], "end": [67, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.canonicallyOrderedCommSemiring", "code": "instance canonicallyOrderedCommSemiring : CanonicallyOrderedCommSemiring \u2115 :=\n  { Nat.nontrivial, Nat.orderBot, (inferInstance : OrderedAddCommMonoid \u2115),\n    (inferInstance : LinearOrderedSemiring \u2115), (inferInstance : CommSemiring \u2115) with\n    exists_add_of_le := fun {_ _} h => (Nat.le.dest h).imp fun _ => Eq.symm,\n    le_self_add := Nat.le_add_right,\n    eq_zero_or_eq_zero_of_mul_eq_zero := Nat.eq_zero_of_mul_eq_zero }", "start": [69, 1], "end": [74, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.canonicallyLinearOrderedAddCommMonoid", "code": "instance canonicallyLinearOrderedAddCommMonoid : CanonicallyLinearOrderedAddCommMonoid \u2115 :=\n  { (inferInstance : CanonicallyOrderedAddCommMonoid \u2115), Nat.linearOrder with }", "start": [76, 1], "end": [77, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_iff_ne_zero", "code": "theorem one_le_iff_ne_zero : 1 \u2264 n \u2194 n \u2260 0", "start": [83, 1], "end": [84, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.one_lt_iff_ne_zero_and_ne_one", "code": "theorem one_lt_iff_ne_zero_and_ne_one : \u2200 {n : \u2115}, 1 < n \u2194 n \u2260 0 \u2227 n \u2260 1", "start": [87, 1], "end": [90, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.le_one_iff_eq_zero_or_eq_one", "code": "theorem le_one_iff_eq_zero_or_eq_one : \u2200 {n : \u2115}, n \u2264 1 \u2194 n = 0 \u2228 n = 1", "start": [93, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_eq_mul", "code": "protected theorem zero_eq_mul : 0 = m * n \u2194 m = 0 \u2228 n = 0", "start": [104, 1], "end": [104, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_double_le", "code": "theorem eq_zero_of_double_le (h : 2 * n \u2264 n) : n = 0", "start": [107, 1], "end": [108, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_mul_le", "code": "theorem eq_zero_of_mul_le (hb : 2 \u2264 n) (h : n * m \u2264 m) : m = 0", "start": [111, 1], "end": [112, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_max", "code": "theorem zero_max : max 0 n = n", "start": [115, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.min_eq_zero_iff", "code": "@[simp]\ntheorem min_eq_zero_iff : min m n = 0 \u2194 m = 0 \u2228 n = 0", "start": [119, 1], "end": [120, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.max_eq_zero_iff", "code": "@[simp]\ntheorem max_eq_zero_iff : max m n = 0 \u2194 m = 0 \u2227 n = 0", "start": [123, 1], "end": [124, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq_max_iff", "code": "theorem add_eq_max_iff : m + n = max m n \u2194 m = 0 \u2228 n = 0", "start": [127, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq_min_iff", "code": "theorem add_eq_min_iff : m + n = min m n \u2194 m = 0 \u2227 n = 0", "start": [132, 1], "end": [134, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_of_lt", "code": "theorem one_le_of_lt (h : n < m) : 1 \u2264 m", "start": [137, 1], "end": [138, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_one_of_mul_eq_one_right", "code": "theorem eq_one_of_mul_eq_one_right (H : m * n = 1) : m = 1", "start": [141, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_one_of_mul_eq_one_left", "code": "theorem eq_one_of_mul_eq_one_left (H : m * n = 1) : n = 1", "start": [145, 1], "end": [146, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.two_le_iff", "code": "theorem two_le_iff : \u2200 n, 2 \u2264 n \u2194 n \u2260 0 \u2227 n \u2260 1", "start": [152, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_one_iff", "code": "@[simp]\ntheorem lt_one_iff {n : \u2115} : n < 1 \u2194 n = 0", "start": [158, 1], "end": [160, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.add_pos_iff_pos_or_pos", "code": "theorem add_pos_iff_pos_or_pos (m n : \u2115) : 0 < m + n \u2194 0 < m \u2228 0 < n", "start": [168, 1], "end": [179, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq_one_iff", "code": "theorem add_eq_one_iff : m + n = 1 \u2194 m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0", "start": [182, 1], "end": [183, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq_two_iff", "code": "theorem add_eq_two_iff : m + n = 2 \u2194 m = 0 \u2227 n = 2 \u2228 m = 1 \u2227 n = 1 \u2228 m = 2 \u2227 n = 0", "start": [186, 1], "end": [189, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.add_eq_three_iff", "code": "theorem add_eq_three_iff :\n    m + n = 3 \u2194 m = 0 \u2227 n = 3 \u2228 m = 1 \u2227 n = 2 \u2228 m = 2 \u2227 n = 1 \u2228 m = 3 \u2227 n = 0", "start": [192, 1], "end": [196, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.le_add_one_iff", "code": "theorem le_add_one_iff : m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1", "start": [199, 1], "end": [204, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.le_and_le_add_one_iff", "code": "theorem le_and_le_add_one_iff : n \u2264 m \u2227 m \u2264 n + 1 \u2194 m = n \u2228 m = n + 1", "start": [207, 1], "end": [210, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.add_succ_lt_add", "code": "theorem add_succ_lt_add (hab : m < n) (hcd : k < l) : m + k + 1 < n + l", "start": [213, 1], "end": [215, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_le_iff", "code": "theorem pred_le_iff : pred m \u2264 n \u2194 m \u2264 succ n", "start": [221, 1], "end": [225, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_pred_iff", "code": "theorem lt_pred_iff : n < pred m \u2194 succ n < m", "start": [240, 1], "end": [241, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_lt_pred", "code": "theorem lt_of_lt_pred (h : m < n - 1) : m < n", "start": [244, 1], "end": [245, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.le_or_le_of_add_eq_add_pred", "code": "theorem le_or_le_of_add_eq_add_pred (h : k + l = m + n - 1) : m \u2264 k \u2228 n \u2264 l", "start": [248, 1], "end": [257, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_succ'", "code": "theorem sub_succ' (m n : \u2115) : m - n.succ = m - n - 1", "start": [260, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mul_pos", "code": "theorem succ_mul_pos (m : \u2115) (hn : 0 < n) : 0 < succ m * n", "start": [267, 1], "end": [268, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_le_mul_self", "code": "theorem mul_self_le_mul_self (h : m \u2264 n) : m * m \u2264 n * n", "start": [271, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_lt_mul_self", "code": "theorem mul_self_lt_mul_self : \u2200 {m n : \u2115}, m < n \u2192 m * m < n * n", "start": [275, 1], "end": [277, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_le_mul_self_iff", "code": "theorem mul_self_le_mul_self_iff : m \u2264 n \u2194 m * m \u2264 n * n", "start": [280, 1], "end": [281, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_lt_mul_self_iff", "code": "theorem mul_self_lt_mul_self_iff : m < n \u2194 m * m < n * n", "start": [284, 1], "end": [285, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.le_mul_self", "code": "theorem le_mul_self : \u2200 n : \u2115, n \u2264 n * n", "start": [288, 1], "end": [290, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.le_mul_of_pos_left", "code": "theorem le_mul_of_pos_left (h : 0 < n) : m \u2264 n * m", "start": [293, 1], "end": [297, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.le_mul_of_pos_right", "code": "theorem le_mul_of_pos_right (h : 0 < n) : m \u2264 m * n", "start": [300, 1], "end": [304, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_self_inj", "code": "theorem mul_self_inj : m * m = n * n \u2194 m = n", "start": [307, 1], "end": [309, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.le_add_pred_of_pos", "code": "theorem le_add_pred_of_pos (n : \u2115) {i : \u2115} (hi : i \u2260 0) : n \u2264 i + (n - 1)", "start": [312, 1], "end": [314, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_mul_self_iff", "code": "@[simp]\ntheorem lt_mul_self_iff : \u2200 {n : \u2115}, n < n * n \u2194 1 < n", "start": [317, 1], "end": [320, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.add_sub_one_le_mul", "code": "theorem add_sub_one_le_mul (hm : m \u2260 0) (hn : n \u2260 0) : m + n - 1 \u2264 m * n", "start": [323, 1], "end": [327, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.diag_induction", "code": "@[elab_as_elim]\ntheorem diag_induction (P : \u2115 \u2192 \u2115 \u2192 Prop) (ha : \u2200 a, P (a + 1) (a + 1)) (hb : \u2200 b, P 0 (b + 1))\n    (hd : \u2200 a b, a < b \u2192 P (a + 1) b \u2192 P a (b + 1) \u2192 P (a + 1) (b + 1)) : \u2200 a b, a < b \u2192 P a b", "start": [338, 1], "end": [356, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.set_induction_bounded", "code": "theorem set_induction_bounded {S : Set \u2115} (hk : k \u2208 S) (h_ind : \u2200 k : \u2115, k \u2208 S \u2192 k + 1 \u2208 S)\n    (hnk : k \u2264 n) : n \u2208 S", "start": [359, 1], "end": [362, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.set_induction", "code": "theorem set_induction {S : Set \u2115} (hb : 0 \u2208 S) (h_ind : \u2200 k : \u2115, k \u2208 S \u2192 k + 1 \u2208 S) (n : \u2115) :\n    n \u2208 S", "start": [365, 1], "end": [368, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_of_le_mul'", "code": "protected theorem div_le_of_le_mul' (h : m \u2264 k * n) : m / k \u2264 n", "start": [374, 1], "end": [380, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.div_le_self'", "code": "protected theorem div_le_self' (m n : \u2115) : m / n \u2264 m", "start": [383, 1], "end": [388, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.div_lt_of_lt_mul", "code": "protected theorem div_lt_of_lt_mul (h : m < n * k) : m / n < k", "start": [391, 1], "end": [398, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_le_div", "code": "theorem eq_zero_of_le_div (hn : 2 \u2264 n) (h : m \u2264 m / n) : m = 0", "start": [401, 1], "end": [403, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mul_div_le_div", "code": "theorem div_mul_div_le_div (m n k : \u2115) : m / k * n / m \u2264 n / k", "start": [406, 1], "end": [414, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_zero_of_le_half", "code": "theorem eq_zero_of_le_half (h : n \u2264 n / 2) : n = 0", "start": [417, 1], "end": [418, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.mul_div_mul_comm_of_dvd_dvd", "code": "theorem mul_div_mul_comm_of_dvd_dvd (hmk : k \u2223 m) (hnl : l \u2223 n) :\n    m * n / (k * l) = m / k * (n / l)", "start": [421, 1], "end": [428, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.le_half_of_half_lt_sub", "code": "theorem le_half_of_half_lt_sub {a b : \u2115} (h : a / 2 < a - b) : b \u2264 a / 2", "start": [431, 1], "end": [434, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.half_le_of_sub_le_half", "code": "theorem half_le_of_sub_le_half {a b : \u2115} (h : a - b \u2264 a / 2) : a / 2 \u2264 b", "start": [437, 1], "end": [441, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.two_mul_odd_div_two", "code": "theorem two_mul_odd_div_two (hn : n % 2 = 1) : 2 * (n / 2) = n - 1", "start": [447, 1], "end": [450, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.div_dvd_of_dvd", "code": "theorem div_dvd_of_dvd (h : n \u2223 m) : m / n \u2223 m", "start": [453, 1], "end": [454, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.div_div_self", "code": "protected theorem div_div_self (h : n \u2223 m) (hm : m \u2260 0) : m / (m / n) = n", "start": [457, 1], "end": [460, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mul_right_div_self", "code": "theorem mod_mul_right_div_self (m n k : \u2115) : m % (n * k) / n = m / n % k", "start": [465, 1], "end": [470, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mul_left_div_self", "code": "theorem mod_mul_left_div_self (m n k : \u2115) : m % (k * n) / n = m / n % k", "start": [473, 1], "end": [474, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.not_dvd_of_pos_of_lt", "code": "theorem not_dvd_of_pos_of_lt (h1 : 0 < n) (h2 : n < m) : \u00acm \u2223 n", "start": [477, 1], "end": [481, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_mod_eq_zero_of_mod_eq", "code": "theorem sub_mod_eq_zero_of_mod_eq (h : m % k = n % k) : (m - n) % k = 0", "start": [484, 1], "end": [487, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.one_mod", "code": "@[simp]\ntheorem one_mod (n : \u2115) : 1 % (n + 2) = 1", "start": [490, 1], "end": [492, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_sub_mod", "code": "theorem dvd_sub_mod (k : \u2115) : n \u2223 k - k % n", "start": [495, 1], "end": [496, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_eq_ite", "code": "theorem add_mod_eq_ite :\n    (m + n) % k = if k \u2264 m % k + n % k then m % k + n % k - k else m % k + n % k", "start": [499, 1], "end": [508, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mul_div_comm", "code": "theorem div_mul_div_comm (hmn : n \u2223 m) (hkl : l \u2223 k) : m / n * (k / l) = m * k / (n * l)", "start": [511, 1], "end": [528, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_self", "code": "theorem div_eq_self : m / n = m \u2194 m = 0 \u2228 n = 1", "start": [531, 1], "end": [544, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.div_eq_sub_mod_div", "code": "theorem div_eq_sub_mod_div : m / n = (m - m % n) / n", "start": [547, 1], "end": [552, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.not_dvd_of_between_consec_multiples", "code": "theorem not_dvd_of_between_consec_multiples (h1 : n * k < m) (h2 : m < n * (k + 1)) : \u00acn \u2223 m", "start": [555, 1], "end": [558, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.find_pos", "code": "theorem find_pos (h : \u2203 n : \u2115, p n) : 0 < Nat.find h \u2194 \u00acp 0", "start": [569, 1], "end": [570, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.find_add", "code": "theorem find_add {h\u2098 : \u2203 m, p (m + n)} {h\u2099 : \u2203 n, p n} (hn : n \u2264 Nat.find h\u2099) :\n    Nat.find h\u2098 + n = Nat.find h\u2099", "start": [573, 1], "end": [582, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_eq_iff", "code": "theorem findGreatest_eq_iff :\n    Nat.findGreatest P k = m \u2194 m \u2264 k \u2227 (m \u2260 0 \u2192 P m) \u2227 \u2200 \u2983n\u2984, m < n \u2192 n \u2264 k \u2192 \u00acP n", "start": [594, 1], "end": [618, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_eq_zero_iff", "code": "theorem findGreatest_eq_zero_iff : Nat.findGreatest P k = 0 \u2194 \u2200 \u2983n\u2984, 0 < n \u2192 n \u2264 k \u2192 \u00acP n", "start": [621, 1], "end": [622, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_pos", "code": "@[simp] lemma findGreatest_pos : 0 < Nat.findGreatest P k \u2194 \u2203 n, 0 < n \u2227 n \u2264 k \u2227 P n := by\n  rw [pos_iff_ne_zero, Ne.def, findGreatest_eq_zero_iff]; push_neg; rfl", "start": [625, 1], "end": [626, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.findGreatest_spec", "code": "theorem findGreatest_spec (hmb : m \u2264 n) (hm : P m) : P (Nat.findGreatest P n)", "start": [628, 1], "end": [633, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_le", "code": "theorem findGreatest_le (n : \u2115) : Nat.findGreatest P n \u2264 n", "start": [636, 1], "end": [637, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.le_findGreatest", "code": "theorem le_findGreatest (hmb : m \u2264 n) (hm : P m) : m \u2264 Nat.findGreatest P n", "start": [640, 1], "end": [641, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_mono_right", "code": "theorem findGreatest_mono_right (P : \u2115 \u2192 Prop) [DecidablePred P] :\n    Monotone (Nat.findGreatest P)", "start": [644, 1], "end": [650, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_mono_left", "code": "theorem findGreatest_mono_left [DecidablePred Q] (hPQ : P \u2264 Q) :\n    Nat.findGreatest P \u2264 Nat.findGreatest Q", "start": [653, 1], "end": [661, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_mono", "code": "theorem findGreatest_mono [DecidablePred Q] (hPQ : P \u2264 Q) (hmn : m \u2264 n) :\n    Nat.findGreatest P m \u2264 Nat.findGreatest Q n", "start": [664, 1], "end": [666, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_is_greatest", "code": "theorem findGreatest_is_greatest (hk : Nat.findGreatest P n < k) (hkb : k \u2264 n) : \u00acP k", "start": [669, 1], "end": [670, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.findGreatest_of_ne_zero", "code": "theorem findGreatest_of_ne_zero (h : Nat.findGreatest P n = m) (h0 : m \u2260 0) : P m", "start": [673, 1], "end": [674, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_le", "code": "protected theorem bit0_le {n m : \u2115} (h : n \u2264 m) : bit0 n \u2264 bit0 m", "start": [684, 1], "end": [685, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_le", "code": "protected theorem bit1_le {n m : \u2115} (h : n \u2264 m) : bit1 n \u2264 bit1 m", "start": [688, 1], "end": [689, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_le", "code": "theorem bit_le : \u2200 (b : Bool) {m n : \u2115}, m \u2264 n \u2192 bit b m \u2264 bit b n", "start": [692, 1], "end": [694, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_le_bit", "code": "theorem bit0_le_bit : \u2200 (b) {m n : \u2115}, m \u2264 n \u2192 bit0 m \u2264 bit b n", "start": [697, 1], "end": [699, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_le_bit1", "code": "theorem bit_le_bit1 : \u2200 (b) {m n : \u2115}, m \u2264 n \u2192 bit b m \u2264 bit1 n", "start": [702, 1], "end": [704, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_lt_bit0", "code": "theorem bit_lt_bit0 : \u2200 (b) {m n : \u2115}, m < n \u2192 bit b m < bit0 n", "start": [707, 1], "end": [709, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_lt_bit", "code": "theorem bit_lt_bit (a b) (h : m < n) : bit a m < bit b n", "start": [712, 1], "end": [713, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_le_bit1_iff", "code": "@[simp]\ntheorem bit0_le_bit1_iff : bit0 m \u2264 bit1 n \u2194 m \u2264 n", "start": [716, 1], "end": [721, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_lt_bit1_iff", "code": "@[simp]\ntheorem bit0_lt_bit1_iff : bit0 m < bit1 n \u2194 m \u2264 n", "start": [724, 1], "end": [726, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_le_bit0_iff", "code": "@[simp]\ntheorem bit1_le_bit0_iff : bit1 m \u2264 bit0 n \u2194 m < n", "start": [729, 1], "end": [732, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_lt_bit0_iff", "code": "@[simp]\ntheorem bit1_lt_bit0_iff : bit1 m < bit0 n \u2194 m < n", "start": [735, 1], "end": [737, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableLoHi", "code": "instance decidableLoHi (lo hi : \u2115) (P : \u2115 \u2192 Prop) [H : DecidablePred P] :\n    Decidable (\u2200 x, lo \u2264 x \u2192 x < hi \u2192 P x) :=\n  decidable_of_iff (\u2200 x < hi - lo, P (lo + x))\n    \u27e8fun al x hl hh => by\n      have := al (x - lo) ((tsub_lt_tsub_iff_right hl).mpr hh)\n      rwa [add_tsub_cancel_of_le hl] at this, fun al x h =>\n      al _ (Nat.le_add_right _ _) (lt_tsub_iff_left.mp h)\u27e9", "start": [778, 1], "end": [784, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.decidableLoHiLe", "code": "instance decidableLoHiLe (lo hi : \u2115) (P : \u2115 \u2192 Prop) [DecidablePred P] :\n    Decidable (\u2200 x, lo \u2264 x \u2192 x \u2264 hi \u2192 P x) :=\n  decidable_of_iff (\u2200 x, lo \u2264 x \u2192 x < hi + 1 \u2192 P x) <|\n    ball_congr fun _ _ => imp_congr lt_succ_iff Iff.rfl", "start": [787, 1], "end": [790, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Common.lean", "imports": ["Mathlib/Tactic/Cases.lean", "Mathlib/Tactic/SudoSetOption.lean", "Mathlib/Tactic/Find.lean", "Mathlib/Tactic/DefEqTransformations.lean", "Mathlib/Tactic/ProjectionNotation.lean", "Mathlib/Tactic/Eqns.lean", "Mathlib/Tactic/RunCmd.lean", "Mathlib/Tactic/Tauto.lean", "Mathlib/Tactic/Classical.lean", "Mathlib/Tactic/SimpRw.lean", "lake-packages/aesop/Aesop.lean", "Mathlib/Tactic/PrintPrefix.lean", "Mathlib/Tactic/Use.lean", "Mathlib/Util/Imports.lean", "Mathlib/Tactic/Clear_.lean", "Mathlib/Tactic/SuccessIfFailWithMsg.lean", "Mathlib/Tactic/Lift.lean", "Mathlib/Tactic/Observe.lean", "Mathlib/Tactic/PushNeg.lean", "Mathlib/Tactic/ClearExcept.lean", "Mathlib/Tactic/ApplyCongr.lean", "Mathlib/Tactic/FailIfNoProgress.lean", "Mathlib/Tactic/GuardGoalNums.lean", "Mathlib/Tactic/Have.lean", "Mathlib/Tactic/ToLevel.lean", "Mathlib/Tactic/DeriveToExpr.lean", "Mathlib/Tactic/Substs.lean", "Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/Tactic/RenameBVar.lean", "Mathlib/Tactic/MkIffOfInductiveProp.lean", "Mathlib/Tactic/Convert.lean", "Mathlib/Tactic/Says.lean", "Mathlib/Tactic/InferParam.lean", "Mathlib/Tactic/Congr!.lean", "Mathlib/Tactic/TermCongr.lean", "Mathlib/Tactic/ByContra.lean", "Mathlib/Tactic/Coe.lean", "Mathlib/Tactic/CasesM.lean", "Mathlib/Tactic/UnsetOption.lean", "Mathlib/Tactic/ScopedNS.lean", "Mathlib/Tactic/RSuffices.lean", "Mathlib/Tactic/Set.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/Inhabit.lean", "Mathlib/Tactic/GuardHypNums.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Tactic/Spread.lean", "Mathlib/Tactic/TryThis.lean", "Mathlib/Tactic/IrreducibleDef.lean", "Mathlib/Tactic/Propose.lean", "Mathlib/Tactic/Rewrites.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Tactic/ToExpr.lean", "Mathlib/Tactic/LeftRight.lean", "Mathlib/Tactic/ExtractGoal.lean", "Mathlib/Tactic/PermuteGoals.lean", "Mathlib/Util/CountHeartbeats.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Variable.lean", "Mathlib/Tactic/ApplyWith.lean", "Mathlib/Tactic/SwapVar.lean", "Mathlib/Tactic/Lint.lean", "Mathlib/Tactic/GeneralizeProofs.lean", "Mathlib/Tactic/Recover.lean", "Mathlib/Tactic/ExtractLets.lean", "Mathlib/Tactic/Conv.lean", "Mathlib/Tactic/Congrm.lean", "Mathlib/Tactic/Trace.lean", "Mathlib/Tactic/Clear!.lean", "Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Simps/Basic.lean", "Mathlib/Tactic/Replace.lean", "Mathlib/Tactic/Existsi.lean", "Mathlib/Tactic/TypeCheck.lean", "Mathlib/Tactic/Contrapose.lean", "Mathlib/Tactic/Choose.lean", "Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/HelpCmd.lean", "Mathlib/Tactic/LibrarySearch.lean", "Mathlib/Tactic/Rename.lean", "Mathlib/Tactic/SplitIfs.lean", "Mathlib/Tactic/Relation/Trans.lean", "Mathlib/Tactic/WLOG.lean", "Mathlib/Tactic/HigherOrder.lean", "Mathlib/Tactic/SimpIntro.lean", "Mathlib/Util/WhatsNew.lean", "Mathlib/Tactic/Constructor.lean"], "premises": []}
{"path": "Mathlib/Init/Data/List/Instances.lean", "imports": ["Mathlib/Init/Data/List/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.bind_singleton", "code": "theorem bind_singleton (f : \u03b1 \u2192 List \u03b2) (x : \u03b1) : [x].bind f = f x", "start": [22, 1], "end": [23, 19], "kind": "commanddeclaration"}, {"full_name": "List.bind_singleton'", "code": "@[simp] theorem bind_singleton' (l : List \u03b1) : (l.bind fun x => [x]) = l", "start": [26, 1], "end": [27, 27], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_bind", "code": "theorem map_eq_bind {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map f l = l.bind fun x => [f x]", "start": [30, 1], "end": [32, 54], "kind": "commanddeclaration"}, {"full_name": "List.bind_assoc", "code": "theorem bind_assoc {\u03b1 \u03b2} (l : List \u03b1) (f : \u03b1 \u2192 List \u03b2) (g : \u03b2 \u2192 List \u03b3) :\n    (l.bind f).bind g = l.bind fun x => (f x).bind g", "start": [35, 1], "end": [36, 84], "kind": "commanddeclaration"}, {"full_name": "List.instMonad", "code": "instance instMonad : Monad List.{u} where\n  pure := @List.ret\n  bind := @List.bind\n  map := @List.map", "start": [39, 1], "end": [42, 19], "kind": "commanddeclaration"}, {"full_name": "List.instLawfulMonad", "code": "instance instLawfulMonad : LawfulMonad List.{u} := LawfulMonad.mk'\n  (id_map := map_id)\n  (pure_bind := fun _ _ => List.append_nil _)\n  (bind_assoc := List.bind_assoc)\n  (bind_pure_comp := fun _ _ => (map_eq_bind _ _).symm)", "start": [45, 1], "end": [49, 56], "kind": "commanddeclaration"}, {"full_name": "List.instAlternative", "code": "instance instAlternative : Alternative List.{u} where\n  failure := @List.nil\n  orElse l l' := List.append l (l' ())", "start": [52, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "List.decidableBex", "code": "instance decidableBex : \u2200 (l : List \u03b1), Decidable (\u2203 x \u2208 l, p x)\n  | []    => isFalse (by simp)\n  | x::xs =>\n    match \u2039DecidablePred p\u203a x with\n    | isTrue h\u2081 => isTrue \u27e8x, mem_cons_self _ _, h\u2081\u27e9\n    | isFalse h\u2081 => match decidableBex xs with\n      | isTrue h\u2082  => isTrue <| by\n        cases' h\u2082 with y h; cases' h with hm hp\n        exact \u27e8y, mem_cons_of_mem _ hm, hp\u27e9\n      | isFalse h\u2082 => isFalse <| by\n        intro h; cases' h with y h; cases' h with hm hp\n        cases' mem_cons.1 hm with h h\n        \u00b7 rw [h] at hp; contradiction\n        \u00b7 exact absurd \u27e8y, h, hp\u27e9 h\u2082", "start": [63, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "List.decidableBall", "code": "instance decidableBall (l : List \u03b1) : Decidable (\u2200 x \u2208 l, p x) :=\n  match (inferInstance : Decidable <| \u2203 x \u2208 l, \u00ac p x) with\n  | isFalse h => isTrue $ fun x hx => match \u2039DecidablePred p\u203a x with\n    | isTrue h' => h'\n    | isFalse h' => False.elim $ h \u27e8x, hx, h'\u27e9\n  | isTrue h => isFalse <| let \u27e8x, h, np\u27e9 := h; fun al => np (al x h)", "start": [79, 1], "end": [84, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Defs.lean", "imports": ["Mathlib/Util/CompileInductive.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Basic.lean", "Mathlib/Data/SProd.lean", "Mathlib/Logic/Basic.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "lake-packages/std/Std/Data/RBMap/Basic.lean", "Mathlib/Algebra/Group/Defs.lean", "Mathlib/Control/Functor.lean"], "premises": [{"full_name": "List.getI", "code": "def getI [Inhabited \u03b1] (l : List \u03b1) (n : Nat) : \u03b1 :=\n  getD l n default", "start": [57, 1], "end": [60, 19], "kind": "commanddeclaration"}, {"full_name": "List.takeI", "code": "def takeI [Inhabited \u03b1] (n : Nat) (l : List \u03b1) : List \u03b1 :=\n  takeD n l default", "start": [63, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "List.prod", "code": "def prod [Mul \u03b1] [One \u03b1] : List \u03b1 \u2192 \u03b1 :=\n  foldl (\u00b7 * \u00b7) 1", "start": [78, 1], "end": [82, 18], "kind": "commanddeclaration"}, {"full_name": "List.sum", "code": "def sum [Add \u03b1] [Zero \u03b1] : List \u03b1 \u2192 \u03b1 :=\n  foldl (\u00b7 + \u00b7) 0", "start": [87, 1], "end": [91, 18], "kind": "commanddeclaration"}, {"full_name": "List.alternatingSum", "code": "def alternatingSum {G : Type*} [Zero G] [Add G] [Neg G] : List G \u2192 G\n  | [] => 0\n  | g :: [] => g\n  | g :: h :: t => g + -h + alternatingSum t", "start": [94, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd", "code": "def alternatingProd {G : Type*} [One G] [Mul G] [Inv G] : List G \u2192 G\n  | [] => 1\n  | g :: [] => g\n  | g :: h :: t => g * h\u207b\u00b9 * alternatingProd t", "start": [101, 1], "end": [105, 47], "kind": "commanddeclaration"}, {"full_name": "List.findM", "code": "def findM {\u03b1} {m : Type u \u2192 Type v} [Alternative m] (tac : \u03b1 \u2192 m PUnit) : List \u03b1 \u2192 m \u03b1 :=\n  List.firstM <| fun a => (tac a) $> a", "start": [111, 1], "end": [114, 39], "kind": "commanddeclaration"}, {"full_name": "List.findM?'", "code": "def findM?'\n    {m : Type u \u2192 Type v}\n    [Monad m] {\u03b1 : Type u}\n    (p : \u03b1 \u2192 m (ULift Bool)) : List \u03b1 \u2192 m (Option \u03b1)\n  | [] => pure none\n  | x :: xs => do\n    let \u27e8px\u27e9 \u2190 p x\n    if px then pure (some x) else findM?' p xs", "start": [117, 1], "end": [127, 47], "kind": "commanddeclaration"}, {"full_name": "List.orM", "code": "def orM : List (m Bool) \u2192 m Bool :=\n  anyM id", "start": [138, 1], "end": [142, 10], "kind": "commanddeclaration"}, {"full_name": "List.andM", "code": "def andM : List (m Bool) \u2192 m Bool :=\n  allM id", "start": [145, 1], "end": [149, 10], "kind": "commanddeclaration"}, {"full_name": "List.foldlIdxM", "code": "def foldlIdxM {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b : \u03b2) (as : List \u03b1) : m \u03b2 :=\n  as.foldlIdx\n    (fun i ma b => do\n      let a \u2190 ma\n      f i a b)\n    (pure b)", "start": [164, 1], "end": [170, 13], "kind": "commanddeclaration"}, {"full_name": "List.foldrIdxM", "code": "def foldrIdxM {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b : \u03b2) (as : List \u03b1) : m \u03b2 :=\n  as.foldrIdx\n    (fun i a mb => do\n      let b \u2190 mb\n      f i a b)\n    (pure b)", "start": [173, 1], "end": [179, 13], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxMAux'", "code": "def mapIdxMAux' {\u03b1} (f : \u2115 \u2192 \u03b1 \u2192 m PUnit) : \u2115 \u2192 List \u03b1 \u2192 m PUnit\n  | _, [] => pure \u27e8\u27e9\n  | i, a :: as => f i a *> mapIdxMAux' f (i + 1) as", "start": [197, 1], "end": [200, 52], "kind": "commanddeclaration"}, {"full_name": "List.mapIdxM'", "code": "def mapIdxM' {\u03b1} (f : \u2115 \u2192 \u03b1 \u2192 m PUnit) (as : List \u03b1) : m PUnit :=\n  mapIdxMAux' f 0 as", "start": [203, 1], "end": [206, 21], "kind": "commanddeclaration"}, {"full_name": "List.All\u2082", "code": "@[simp]\ndef All\u2082 (p : \u03b1 \u2192 Prop) : List \u03b1 \u2192 Prop\n  | [] => True\n  | x :: [] => p x\n  | x :: l => p x \u2227 All\u2082 p l", "start": [223, 1], "end": [229, 29], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux2", "code": "def permutationsAux2 (t : \u03b1) (ts : List \u03b1) (r : List \u03b2) : List \u03b1 \u2192 (List \u03b1 \u2192 \u03b2) \u2192 List \u03b1 \u00d7 List \u03b2\n  | [], _ => (ts, r)\n  | y :: ys, f =>\n    let (us, zs) := permutationsAux2 t ts r ys (fun x: List \u03b1 => f (y :: x))\n    (y :: us, f (t :: y :: us) :: zs)", "start": [237, 1], "end": [250, 38], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux.rec", "code": "def permutationsAux.rec {C : List \u03b1 \u2192 List \u03b1 \u2192 Sort v} (H0 : \u2200 is, C [] is)\n    (H1 : \u2200 t ts is, C ts (t :: is) \u2192 C is [] \u2192 C (t :: ts) is) : \u2200 l\u2081 l\u2082, C l\u2081 l\u2082\n  | [], is => H0 is\n  | t :: ts, is =>\n      H1 t ts is (permutationsAux.rec H0 H1 ts (t :: is)) (permutationsAux.rec H0 H1 is [])\n  termination_by _ ts is => (length ts + length is, length ts)\n  decreasing_by simp_wf; simp [Nat.succ_add]; decreasing_tactic", "start": [255, 1], "end": [263, 64], "kind": "commanddeclaration"}, {"full_name": "List.permutationsAux", "code": "def permutationsAux : List \u03b1 \u2192 List \u03b1 \u2192 List (List \u03b1) :=\n  permutationsAux.rec (fun _ => []) fun t ts is IH1 IH2 =>\n    foldr (fun y r => (permutationsAux2 t ts r y id).2) IH1 (is :: IH2)", "start": [266, 1], "end": [270, 72], "kind": "commanddeclaration"}, {"full_name": "List.permutations", "code": "def permutations (l : List \u03b1) : List (List \u03b1) :=\n  l :: permutationsAux l []", "start": [273, 1], "end": [279, 28], "kind": "commanddeclaration"}, {"full_name": "List.permutations'Aux", "code": "@[simp]\ndef permutations'Aux (t : \u03b1) : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[t]]\n  | y :: ys => (t :: y :: ys) :: (permutations'Aux t ys).map (cons y)", "start": [282, 1], "end": [296, 70], "kind": "commanddeclaration"}, {"full_name": "List.permutations'", "code": "@[simp]\ndef permutations' : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[]]\n  | t :: ts => (permutations' ts).bind <| permutations'Aux t", "start": [299, 1], "end": [309, 61], "kind": "commanddeclaration"}, {"full_name": "List.extractp", "code": "def extractp (p : \u03b1 \u2192 Prop) [DecidablePred p] : List \u03b1 \u2192 Option \u03b1 \u00d7 List \u03b1\n  | [] => (none, [])\n  | a :: l =>\n    if p a then (some a, l)\n    else\n      let (a', l') := extractp p l\n      (a', a :: l')", "start": [316, 1], "end": [324, 20], "kind": "commanddeclaration"}, {"full_name": "List.instSProd", "code": "instance instSProd : SProd (List \u03b1) (List \u03b2) (List (\u03b1 \u00d7 \u03b2)) where\n  sprod := List.product", "start": [330, 1], "end": [334, 24], "kind": "commanddeclaration"}, {"full_name": "List.decidableChain", "code": "instance decidableChain [DecidableRel R] (a : \u03b1) (l : List \u03b1) :\n    Decidable (Chain R a l) := by\n  induction l generalizing a with\n  | nil => simp only [List.Chain.nil]; infer_instance\n  | cons a as ih => haveI := ih; simp only [List.chain_cons]; infer_instance", "start": [350, 1], "end": [354, 77], "kind": "commanddeclaration"}, {"full_name": "List.decidableChain'", "code": "instance decidableChain' [DecidableRel R] (l : List \u03b1) : Decidable (Chain' R l) := by\n  cases l <;> dsimp only [List.Chain'] <;> infer_instance", "start": [357, 1], "end": [358, 58], "kind": "commanddeclaration"}, {"full_name": "List.dedup", "code": "def dedup [DecidableEq \u03b1] : List \u03b1 \u2192 List \u03b1 :=\n  pwFilter (\u00b7 \u2260 \u00b7)", "start": [366, 1], "end": [371, 19], "kind": "commanddeclaration"}, {"full_name": "List.destutter'", "code": "def destutter' (R : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel R] : \u03b1 \u2192 List \u03b1 \u2192 List \u03b1\n  | a, [] => [a]\n  | a, h :: l => if R a h then a :: destutter' R h l else destutter' R a l", "start": [374, 1], "end": [379, 75], "kind": "commanddeclaration"}, {"full_name": "List.destutter", "code": "def destutter (R : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel R] : List \u03b1 \u2192 List \u03b1\n  | h :: l => destutter' R h l\n  | [] => []", "start": [383, 1], "end": [388, 13], "kind": "commanddeclaration"}, {"full_name": "List.chooseX", "code": "def chooseX : \u2200 l : List \u03b1, \u2200 _ : \u2203 a, a \u2208 l \u2227 p a, { a // a \u2208 l \u2227 p a }\n  | [], hp => False.elim (Exists.elim hp fun a h => not_mem_nil a h.left)\n  | l :: ls, hp =>\n    if pl : p l then \u27e8l, \u27e8mem_cons.mpr <| Or.inl rfl, pl\u27e9\u27e9\n    else\n      let \u27e8a, \u27e8a_mem_ls, pa\u27e9\u27e9 :=\n        chooseX ls\n          (hp.imp fun _ \u27e8o, h\u2082\u27e9 => \u27e8(mem_cons.mp o).resolve_left fun e => pl <| e \u25b8 h\u2082, h\u2082\u27e9)\n      \u27e8a, \u27e8mem_cons.mpr <| Or.inr a_mem_ls, pa\u27e9\u27e9", "start": [405, 1], "end": [416, 49], "kind": "commanddeclaration"}, {"full_name": "List.choose", "code": "def choose (hp : \u2203 a, a \u2208 l \u2227 p a) : \u03b1 :=\n  chooseX p l hp", "start": [419, 1], "end": [423, 17], "kind": "commanddeclaration"}, {"full_name": "List.mapDiagM'", "code": "def mapDiagM' {m} [Monad m] {\u03b1} (f : \u03b1 \u2192 \u03b1 \u2192 m Unit) : List \u03b1 \u2192 m Unit\n  | [] => return ()\n  | h :: t => do\n    _ \u2190 f h h\n    _ \u2190 t.mapM' (f h)\n    t.mapDiagM' f", "start": [431, 1], "end": [443, 18], "kind": "commanddeclaration"}, {"full_name": "List.traverse", "code": "protected def traverse {F : Type u \u2192 Type v} [Applicative F]\n    {\u03b1 : Type*} {\u03b2 : Type u} (f : \u03b1 \u2192 F \u03b2) : List \u03b1 \u2192 F (List \u03b2)\n  | [] => pure []\n  | x :: xs => List.cons <$> f x <*> List.traverse f xs", "start": [449, 1], "end": [455, 56], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left'", "code": "@[simp]\ndef map\u2082Left' (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u00d7 List \u03b2\n  | [], bs => ([], bs)\n  | a :: as, [] => ((a :: as).map fun a => f a none, [])\n  | a :: as, b :: bs =>\n    let rec' := map\u2082Left' f as bs\n    (f a (some b) :: rec'.fst, rec'.snd)", "start": [461, 1], "end": [478, 41], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right'", "code": "def map\u2082Right' (f : Option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : List \u03b1) (bs : List \u03b2) : List \u03b3 \u00d7 List \u03b1 :=\n  map\u2082Left' (flip f) bs as", "start": [481, 1], "end": [493, 27], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left", "code": "@[simp]\ndef map\u2082Left (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3\n  | [], _ => []\n  | a :: as, [] => (a :: as).map fun a => f a none\n  | a :: as, b :: bs => f a (some b) :: map\u2082Left f as bs", "start": [497, 1], "end": [513, 57], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right", "code": "def map\u2082Right (f : Option \u03b1 \u2192 \u03b2 \u2192 \u03b3) (as : List \u03b1) (bs : List \u03b2) : List \u03b3 :=\n  map\u2082Left (flip f) bs as", "start": [516, 1], "end": [529, 26], "kind": "commanddeclaration"}, {"full_name": "List.mapAsyncChunked", "code": "def mapAsyncChunked {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (xs : List \u03b1) (chunk_size := 1024) : List \u03b2 :=\n  ((xs.toChunks chunk_size).map fun xs => Task.spawn fun _ => List.map f xs).bind Task.get", "start": [545, 1], "end": [548, 91], "kind": "commanddeclaration"}, {"full_name": "List.zipWith3", "code": "def zipWith3 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4\n  | x :: xs, y :: ys, z :: zs => f x y z :: zipWith3 f xs ys zs\n  | _, _, _ => []", "start": [561, 1], "end": [564, 18], "kind": "commanddeclaration"}, {"full_name": "List.zipWith4", "code": "def zipWith4 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4 \u2192 \u03b5) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4 \u2192 List \u03b5\n  | x :: xs, y :: ys, z :: zs, u :: us => f x y z u :: zipWith4 f xs ys zs us\n  | _, _, _, _ => []", "start": [567, 1], "end": [570, 21], "kind": "commanddeclaration"}, {"full_name": "List.zipWith5", "code": "def zipWith5 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4 \u2192 \u03b5 \u2192 \u03b6) : List \u03b1 \u2192 List \u03b2 \u2192 List \u03b3 \u2192 List \u03b4 \u2192 List \u03b5 \u2192 List \u03b6\n  | x :: xs, y :: ys, z :: zs, u :: us, v :: vs => f x y z u v :: zipWith5 f xs ys zs us vs\n  | _, _, _, _, _ => []", "start": [573, 1], "end": [576, 24], "kind": "commanddeclaration"}, {"full_name": "List.replaceIf", "code": "def replaceIf : List \u03b1 \u2192 List Bool \u2192 List \u03b1 \u2192 List \u03b1\n  | l, _, [] => l\n  | [], _, _ => []\n  | l, [], _ => l\n  | n :: ns, tf :: bs, e@(c :: cs) => if tf then c :: ns.replaceIf bs cs else n :: ns.replaceIf bs e", "start": [579, 1], "end": [586, 101], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/OrderSynonym.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "Mathlib/Order/Synonym.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderDual.instPow", "code": "@[to_additive (attr := to_additive) (reorder := 1 2) OrderDual.instSMul]\ninstance OrderDual.instPow [h : Pow \u03b1 \u03b2] : Pow \u03b1\u1d52\u1d48 \u03b2 := h", "start": [37, 1], "end": [38, 58], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instPow'", "code": "@[to_additive (attr := to_additive) (reorder := 1 2) OrderDual.instSMul']\ninstance OrderDual.instPow' [h : Pow \u03b1 \u03b2] : Pow \u03b1 \u03b2\u1d52\u1d48 := h", "start": [42, 1], "end": [43, 59], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instCommMonoid", "code": "@[to_additive]\ninstance OrderDual.instCommMonoid [h : CommMonoid \u03b1] : CommMonoid \u03b1\u1d52\u1d48 := h", "start": [65, 1], "end": [66, 75], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instCancelCommMonoid", "code": "@[to_additive]\ninstance OrderDual.instCancelCommMonoid [h : CancelCommMonoid \u03b1] : CancelCommMonoid \u03b1\u1d52\u1d48 := h", "start": [77, 1], "end": [78, 93], "kind": "commanddeclaration"}, {"full_name": "OrderDual.instGroup", "code": "@[to_additive]\ninstance OrderDual.instGroup [h : Group \u03b1] : Group \u03b1\u1d52\u1d48 := h", "start": [92, 1], "end": [93, 60], "kind": "commanddeclaration"}, {"full_name": "toDual_one", "code": "@[to_additive (attr := simp)]\ntheorem toDual_one [One \u03b1] : toDual (1 : \u03b1) = 1", "start": [100, 1], "end": [101, 55], "kind": "commanddeclaration"}, {"full_name": "ofDual_one", "code": "@[to_additive (attr := simp)]\ntheorem ofDual_one [One \u03b1] : (ofDual 1 : \u03b1) = 1", "start": [105, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "toDual_mul", "code": "@[to_additive (attr := simp)]\ntheorem toDual_mul [Mul \u03b1] (a b : \u03b1) : toDual (a * b) = toDual a * toDual b", "start": [110, 1], "end": [111, 83], "kind": "commanddeclaration"}, {"full_name": "ofDual_mul", "code": "@[to_additive (attr := simp)]\ntheorem ofDual_mul [Mul \u03b1] (a b : \u03b1\u1d52\u1d48) : ofDual (a * b) = ofDual a * ofDual b", "start": [115, 1], "end": [116, 85], "kind": "commanddeclaration"}, {"full_name": "toDual_inv", "code": "@[to_additive (attr := simp)]\ntheorem toDual_inv [Inv \u03b1] (a : \u03b1) : toDual a\u207b\u00b9 = (toDual a)\u207b\u00b9", "start": [120, 1], "end": [121, 70], "kind": "commanddeclaration"}, {"full_name": "ofDual_inv", "code": "@[to_additive (attr := simp)]\ntheorem ofDual_inv [Inv \u03b1] (a : \u03b1\u1d52\u1d48) : ofDual a\u207b\u00b9 = (ofDual a)\u207b\u00b9", "start": [125, 1], "end": [126, 72], "kind": "commanddeclaration"}, {"full_name": "toDual_div", "code": "@[to_additive (attr := simp)]\ntheorem toDual_div [Div \u03b1] (a b : \u03b1) : toDual (a / b) = toDual a / toDual b", "start": [130, 1], "end": [131, 83], "kind": "commanddeclaration"}, {"full_name": "ofDual_div", "code": "@[to_additive (attr := simp)]\ntheorem ofDual_div [Div \u03b1] (a b : \u03b1\u1d52\u1d48) : ofDual (a / b) = ofDual a / ofDual b", "start": [135, 1], "end": [136, 85], "kind": "commanddeclaration"}, {"full_name": "toDual_pow", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) toDual_smul]\ntheorem toDual_pow [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : toDual (a ^ b) = toDual a ^ b", "start": [140, 1], "end": [141, 84], "kind": "commanddeclaration"}, {"full_name": "ofDual_pow", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) ofDual_smul]\ntheorem ofDual_pow [Pow \u03b1 \u03b2] (a : \u03b1\u1d52\u1d48) (b : \u03b2) : ofDual (a ^ b) = ofDual a ^ b", "start": [146, 1], "end": [147, 86], "kind": "commanddeclaration"}, {"full_name": "pow_toDual", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) toDual_smul']\ntheorem pow_toDual [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : a ^ toDual b = a ^ b", "start": [152, 1], "end": [153, 75], "kind": "commanddeclaration"}, {"full_name": "pow_ofDual", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) ofDual_smul']\ntheorem pow_ofDual [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2\u1d52\u1d48) : a ^ ofDual b = a ^ b", "start": [158, 1], "end": [159, 77], "kind": "commanddeclaration"}, {"full_name": "Lex.instPow", "code": "@[to_additive (attr := to_additive) (reorder := 1 2) Lex.instSMul]\ninstance Lex.instPow [h : Pow \u03b1 \u03b2] : Pow (Lex \u03b1) \u03b2 := h", "start": [179, 1], "end": [180, 56], "kind": "commanddeclaration"}, {"full_name": "Lex.instPow'", "code": "@[to_additive (attr := to_additive) (reorder := 1 2) Lex.instSMul']\ninstance Lex.instPow' [h : Pow \u03b1 \u03b2] : Pow \u03b1 (Lex \u03b2) := h", "start": [184, 1], "end": [185, 57], "kind": "commanddeclaration"}, {"full_name": "toLex_one", "code": "@[to_additive (attr := simp)]\ntheorem toLex_one [One \u03b1] : toLex (1 : \u03b1) = 1", "start": [240, 1], "end": [241, 53], "kind": "commanddeclaration"}, {"full_name": "ofLex_one", "code": "@[to_additive (attr := simp)]\ntheorem ofLex_one [One \u03b1] : (ofLex 1 : \u03b1) = 1", "start": [245, 1], "end": [246, 53], "kind": "commanddeclaration"}, {"full_name": "toLex_mul", "code": "@[to_additive (attr := simp)]\ntheorem toLex_mul [Mul \u03b1] (a b : \u03b1) : toLex (a * b) = toLex a * toLex b", "start": [250, 1], "end": [251, 79], "kind": "commanddeclaration"}, {"full_name": "ofLex_mul", "code": "@[to_additive (attr := simp)]\ntheorem ofLex_mul [Mul \u03b1] (a b : Lex \u03b1) : ofLex (a * b) = ofLex a * ofLex b", "start": [255, 1], "end": [256, 83], "kind": "commanddeclaration"}, {"full_name": "toLex_inv", "code": "@[to_additive (attr := simp)]\ntheorem toLex_inv [Inv \u03b1] (a : \u03b1) : toLex a\u207b\u00b9 = (toLex a)\u207b\u00b9", "start": [260, 1], "end": [261, 67], "kind": "commanddeclaration"}, {"full_name": "ofLex_inv", "code": "@[to_additive (attr := simp)]\ntheorem ofLex_inv [Inv \u03b1] (a : Lex \u03b1) : ofLex a\u207b\u00b9 = (ofLex a)\u207b\u00b9", "start": [265, 1], "end": [266, 71], "kind": "commanddeclaration"}, {"full_name": "toLex_div", "code": "@[to_additive (attr := simp)]\ntheorem toLex_div [Div \u03b1] (a b : \u03b1) : toLex (a / b) = toLex a / toLex b", "start": [270, 1], "end": [271, 79], "kind": "commanddeclaration"}, {"full_name": "ofLex_div", "code": "@[to_additive (attr := simp)]\ntheorem ofLex_div [Div \u03b1] (a b : Lex \u03b1) : ofLex (a / b) = ofLex a / ofLex b", "start": [275, 1], "end": [276, 83], "kind": "commanddeclaration"}, {"full_name": "toLex_pow", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) toLex_smul]\ntheorem toLex_pow [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : toLex (a ^ b) = toLex a ^ b", "start": [280, 1], "end": [281, 81], "kind": "commanddeclaration"}, {"full_name": "ofLex_pow", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) ofLex_smul]\ntheorem ofLex_pow [Pow \u03b1 \u03b2] (a : Lex \u03b1) (b : \u03b2) : ofLex (a ^ b) = ofLex a ^ b", "start": [286, 1], "end": [287, 85], "kind": "commanddeclaration"}, {"full_name": "pow_toLex", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) toLex_smul']\ntheorem pow_toLex [Pow \u03b1 \u03b2] (a : \u03b1) (b : \u03b2) : a ^ toLex b = a ^ b", "start": [292, 1], "end": [293, 73], "kind": "commanddeclaration"}, {"full_name": "pow_ofLex", "code": "@[to_additive (attr := simp, to_additive) (reorder := 1 2, 4 5) ofLex_smul']\ntheorem pow_ofLex [Pow \u03b1 \u03b2] (a : \u03b1) (b : Lex \u03b2) : a ^ ofLex b = a ^ b", "start": [298, 1], "end": [299, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/InjSurj.lean", "imports": ["Mathlib/Data/Int/Cast/Basic.lean", "Mathlib/Algebra/Group/Defs.lean", "Mathlib/Logic/Function/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.semigroup", "code": "@[to_additive (attr := reducible) \"A type endowed with `+` is an additive semigroup, if it admits an\ninjective map that preserves `+` to an additive semigroup.\"]\nprotected def semigroup [Semigroup M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : Semigroup M\u2081 :=\n  { \u2039Mul M\u2081\u203a with mul_assoc := fun x y z => hf <| by erw [mul, mul, mul, mul, mul_assoc] }", "start": [41, 1], "end": [47, 91], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commSemigroup", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `+` is an additive commutative semigroup,if it admits\nan injective map that preserves `+` to an additive commutative semigroup.\"]\nprotected def commSemigroup [CommSemigroup M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : CommSemigroup M\u2081 :=\n  { hf.semigroup f mul with mul_comm := fun x y => hf <| by erw [mul, mul, mul_comm] }", "start": [51, 1], "end": [58, 87], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.leftCancelSemigroup", "code": "@[to_additive (attr := reducible) \"A type endowed with `+` is an additive left cancel\nsemigroup, if it admits an injective map that preserves `+` to an additive left cancel semigroup.\"]\nprotected def leftCancelSemigroup [LeftCancelSemigroup M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : LeftCancelSemigroup M\u2081 :=\n  { hf.semigroup f mul with\n    mul_left_cancel := fun x y z H => hf <| (mul_right_inj (f x)).1 <| by erw [\u2190 mul, \u2190 mul, H] }", "start": [62, 1], "end": [69, 98], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.rightCancelSemigroup", "code": "@[to_additive (attr := reducible) \"A type endowed with `+` is an additive right\ncancel semigroup, if it admits an injective map that preserves `+` to an additive right cancel\nsemigroup.\"]\nprotected def rightCancelSemigroup [RightCancelSemigroup M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : RightCancelSemigroup M\u2081 :=\n  { hf.semigroup f mul with\n    mul_right_cancel := fun x y z H => hf <| (mul_left_inj (f y)).1 <| by erw [\u2190 mul, \u2190 mul, H] }", "start": [73, 1], "end": [81, 98], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mulOneClass", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits an\ninjective map that preserves `0` and `+` to an `AddZeroClass`.\"]\nprotected def mulOneClass [MulOneClass M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : MulOneClass M\u2081 :=\n  { \u2039One M\u2081\u203a, \u2039Mul M\u2081\u203a with\n    one_mul := fun x => hf <| by erw [mul, one, one_mul],\n    mul_one := fun x => hf <| by erw [mul, one, mul_one] }", "start": [87, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.monoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive monoid, if it admits an\ninjective map that preserves `0` and `+` to an additive monoid. See note\n[reducible non-instances].\"]\nprotected def monoid [Monoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : Monoid M\u2081 :=\n  { hf.mulOneClass f one mul, hf.semigroup f mul with\n    npow := fun n x => x ^ n,\n    npow_zero := fun x => hf <| by erw [npow, one, pow_zero],\n    npow_succ := fun n x => hf <| by erw [npow, pow_succ, mul, npow] }", "start": [102, 1], "end": [113, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.addMonoidWithOne", "code": "@[reducible]\nprotected def addMonoidWithOne {M\u2081} [Zero M\u2081] [One M\u2081] [Add M\u2081] [SMul \u2115 M\u2081] [NatCast M\u2081]\n    [AddMonoidWithOne M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : AddMonoidWithOne M\u2081 :=\n  { hf.addMonoid f zero add nsmul with\n    natCast := Nat.cast,\n    natCast_zero := hf (by erw [nat_cast, Nat.cast_zero, zero]),\n    natCast_succ := fun n => hf (by erw [nat_cast, Nat.cast_succ, add, one, nat_cast]), one := 1 }", "start": [117, 1], "end": [128, 99], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.leftCancelMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive left cancel monoid, if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.\"]\nprotected def leftCancelMonoid [LeftCancelMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : LeftCancelMonoid M\u2081 :=\n  { hf.leftCancelSemigroup f mul, hf.monoid f one mul npow with }", "start": [131, 1], "end": [139, 66], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.rightCancelMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive left cancel monoid,if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.\"]\nprotected def rightCancelMonoid [RightCancelMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : RightCancelMonoid M\u2081 :=\n  { hf.rightCancelSemigroup f mul, hf.monoid f one mul npow with }", "start": [143, 1], "end": [151, 67], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.cancelMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive left cancel monoid,if it\nadmits an injective map that preserves `0` and `+` to an additive left cancel monoid.\"]\nprotected def cancelMonoid [CancelMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CancelMonoid M\u2081 :=\n  { hf.leftCancelMonoid f one mul npow, hf.rightCancelMonoid f one mul npow with }", "start": [155, 1], "end": [163, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive commutative monoid, if it\nadmits an injective map that preserves `0` and `+` to an additive commutative monoid.\"]\nprotected def commMonoid [CommMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CommMonoid M\u2081 :=\n  { hf.commSemigroup f mul, hf.monoid f one mul npow with }", "start": [167, 1], "end": [175, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.addCommMonoidWithOne", "code": "@[reducible]\nprotected def addCommMonoidWithOne {M\u2081} [Zero M\u2081] [One M\u2081] [Add M\u2081] [SMul \u2115 M\u2081] [NatCast M\u2081]\n    [AddCommMonoidWithOne M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : AddCommMonoidWithOne M\u2081 :=\n  { hf.addMonoidWithOne f zero one add nsmul nat_cast, hf.addCommMonoid f zero add nsmul with }", "start": [179, 1], "end": [187, 96], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.cancelCommMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive cancel commutative monoid,\nif it admits an injective map that preserves `0` and `+` to an additive cancel commutative monoid.\"]\nprotected def cancelCommMonoid [CancelCommMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : CancelCommMonoid M\u2081 :=\n  { hf.leftCancelSemigroup f mul, hf.commMonoid f one mul npow with }", "start": [190, 1], "end": [198, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.involutiveInv", "code": "@[to_additive (attr := reducible)\n\"A type has an involutive negation if it admits a surjective map that\npreserves `-` to a type which has an involutive negation.\"]\nprotected def involutiveInv {M\u2081 : Type*} [Inv M\u2081] [InvolutiveInv M\u2082] (f : M\u2081 \u2192 M\u2082)\n    (hf : Injective f) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) : InvolutiveInv M\u2081 where\n  inv := Inv.inv\n  inv_inv x := hf <| by rw [inv, inv, inv_inv]", "start": [202, 1], "end": [210, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.invOneClass", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and unary `-` is an `NegZeroClass`, if it admits an\ninjective map that preserves `0` and unary `-` to an `NegZeroClass`.\"]\nprotected def invOneClass [InvOneClass M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (inv : \u2200 x, f (x\u207b\u00b9) = (f x)\u207b\u00b9) : InvOneClass M\u2081 :=\n  { \u2039One M\u2081\u203a, \u2039Inv M\u2081\u203a with\n    inv_one := hf <| by erw [inv, one, inv_one] }", "start": [216, 1], "end": [224, 50], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divInvMonoid", "code": "@[to_additive (attr := reducible) subNegMonoid\n\"A type endowed with `0`, `+`, unary `-`, and binary `-` is a\n`SubNegMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `SubNegMonoid`. This version takes custom `nsmul` and `zsmul` as `[SMul \u2115 M\u2081]` and `[SMul \u2124 M\u2081]`\narguments.\"]\nprotected def divInvMonoid [DivInvMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : DivInvMonoid M\u2081 :=\n  { hf.monoid f one mul npow, \u2039Inv M\u2081\u203a, \u2039Div M\u2081\u203a with\n    zpow := fun n x => x ^ n,\n    zpow_zero' := fun x => hf <| by erw [zpow, zpow_zero, one],\n    zpow_succ' := fun n x => hf <| by erw [zpow, mul, zpow_ofNat, pow_succ, zpow, zpow_ofNat],\n    zpow_neg' := fun n x => hf <| by erw [zpow, zpow_negSucc, inv, zpow, zpow_ofNat],\n    div_eq_mul_inv := fun x y => hf <| by erw [div, mul, inv, div_eq_mul_inv] }", "start": [228, 1], "end": [244, 80], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divInvOneMonoid", "code": "@[to_additive (attr := reducible) subNegZeroMonoid\n\"A type endowed with `0`, `+`, unary `-`, and binary `-` is a\n`SubNegZeroMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`, and binary\n`-` to a `SubNegZeroMonoid`. This version takes custom `nsmul` and `zsmul` as `[SMul \u2115 M\u2081]` and\n`[SMul \u2124 M\u2081]` arguments.\"]\nprotected def divInvOneMonoid [DivInvOneMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : DivInvOneMonoid M\u2081 :=\n  { hf.divInvMonoid f one mul inv div npow zpow, hf.invOneClass f one inv with }", "start": [248, 1], "end": [260, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divisionMonoid", "code": "@[to_additive (attr := reducible) subtractionMonoid\n\"A type endowed with `0`, `+`, unary `-`, and binary `-`\nis a `SubtractionMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`, and\nbinary `-` to a `SubtractionMonoid`. This version takes custom `nsmul` and `zsmul` as `[SMul \u2115 M\u2081]`\nand `[SMul \u2124 M\u2081]` arguments.\"]\nprotected def divisionMonoid [DivisionMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : DivisionMonoid M\u2081 :=\n  { hf.divInvMonoid f one mul inv div npow zpow, hf.involutiveInv f inv with\n    mul_inv_rev := fun x y => hf <| by erw [inv, mul, mul_inv_rev, mul, inv, inv],\n    inv_eq_of_mul := fun x y h => hf <| by\n      erw [inv, inv_eq_of_mul_eq_one_right (by erw [\u2190 mul, h, one])] }", "start": [262, 1], "end": [276, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.divisionCommMonoid", "code": "@[to_additive (attr := reducible) subtractionCommMonoid\n\"A type endowed with `0`, `+`, unary `-`, and binary\n`-` is a `SubtractionCommMonoid` if it admits an injective map that preserves `0`, `+`, unary `-`,\nand binary `-` to a `SubtractionCommMonoid`. This version takes custom `nsmul` and `zsmul` as\n`[SMul \u2115 M\u2081]` and `[SMul \u2124 M\u2081]` arguments.\"]\nprotected def divisionCommMonoid [DivisionCommMonoid M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : DivisionCommMonoid M\u2081 :=\n  { hf.divisionMonoid f one mul inv div npow zpow, hf.commSemigroup f mul with }", "start": [280, 1], "end": [292, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.group", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive group, if it admits an\ninjective map that preserves `0` and `+` to an additive group.\"]\nprotected def group [Group M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : Group M\u2081 :=\n  { hf.divInvMonoid f one mul inv div npow zpow with\n    mul_left_inv := fun x => hf <| by erw [mul, inv, mul_left_inv, one] }", "start": [296, 1], "end": [306, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.addGroupWithOne", "code": "@[reducible]\nprotected def addGroupWithOne {M\u2081} [Zero M\u2081] [One M\u2081] [Add M\u2081] [SMul \u2115 M\u2081] [Neg M\u2081] [Sub M\u2081]\n    [SMul \u2124 M\u2081] [NatCast M\u2081] [IntCast M\u2081] [AddGroupWithOne M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : AddGroupWithOne M\u2081 :=\n  { hf.addGroup f zero add neg sub nsmul zsmul,\n    hf.addMonoidWithOne f zero one add nsmul nat_cast with\n    intCast := Int.cast,\n    intCast_ofNat := fun n => hf (by rw [nat_cast, \u2190Int.cast, int_cast, Int.cast_ofNat]),\n    intCast_negSucc := fun n => hf (by erw [int_cast, neg, nat_cast, Int.cast_negSucc] ) }", "start": [310, 1], "end": [324, 91], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commGroup", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive commutative group, if it\nadmits an injective map that preserves `0` and `+` to an additive commutative group.\"]\nprotected def commGroup [CommGroup M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : CommGroup M\u2081 :=\n  { hf.commMonoid f one mul npow, hf.group f one mul inv div npow zpow with }", "start": [327, 1], "end": [336, 78], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.addCommGroupWithOne", "code": "@[reducible]\nprotected def addCommGroupWithOne {M\u2081} [Zero M\u2081] [One M\u2081] [Add M\u2081] [SMul \u2115 M\u2081] [Neg M\u2081] [Sub M\u2081]\n    [SMul \u2124 M\u2081] [NatCast M\u2081] [IntCast M\u2081] [AddCommGroupWithOne M\u2082] (f : M\u2081 \u2192 M\u2082) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : AddCommGroupWithOne M\u2081 :=\n  { hf.addGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,\n    hf.addCommMonoid f zero add nsmul with }", "start": [340, 1], "end": [351, 45], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.semigroup", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `+` is an additive semigroup, if it admits a\nsurjective map that preserves `+` from an additive semigroup.\"]\nprotected def semigroup [Semigroup M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : Semigroup M\u2082 :=\n  { \u2039Mul M\u2082\u203a with mul_assoc := hf.forall\u2083.2 fun x y z => by simp only [\u2190 mul, mul_assoc] }", "start": [365, 1], "end": [372, 91], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commSemigroup", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `+` is an additive commutative semigroup, if it admits\na surjective map that preserves `+` from an additive commutative semigroup.\"]\nprotected def commSemigroup [CommSemigroup M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : CommSemigroup M\u2082 :=\n  { hf.semigroup f mul with\n    mul_comm := hf.forall\u2082.2 fun x y => by erw [\u2190 mul, \u2190 mul, mul_comm] }", "start": [376, 1], "end": [384, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulOneClass", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an `AddZeroClass`, if it admits a\nsurjective map that preserves `0` and `+` to an `AddZeroClass`.\"]\nprotected def mulOneClass [MulOneClass M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) : MulOneClass M\u2082 :=\n  { \u2039One M\u2082\u203a, \u2039Mul M\u2082\u203a with\n    one_mul := hf.forall.2 fun x => by erw [\u2190 one, \u2190 mul, one_mul],\n    mul_one := hf.forall.2 fun x => by erw [\u2190 one, \u2190 mul, mul_one] }", "start": [390, 1], "end": [399, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.monoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive monoid, if it admits a\nsurjective map that preserves `0` and `+` to an additive monoid. This version takes a custom `nsmul`\nas a `[SMul \u2115 M\u2082]` argument.\"]\nprotected def monoid [Monoid M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) : Monoid M\u2082 :=\n  { hf.semigroup f mul, hf.mulOneClass f one mul with\n    npow := fun n x => x ^ n,\n    npow_zero := hf.forall.2 fun x => by dsimp only; erw [\u2190npow, pow_zero, \u2190one],\n    npow_succ := fun n => hf.forall.2 fun x => by dsimp only; erw [\u2190npow, pow_succ, \u2190npow, \u2190mul] }", "start": [405, 1], "end": [416, 99], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.addMonoidWithOne", "code": "@[reducible]\nprotected def addMonoidWithOne {M\u2082} [Zero M\u2082] [One M\u2082] [Add M\u2082] [SMul \u2115 M\u2082] [NatCast M\u2082]\n    [AddMonoidWithOne M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : AddMonoidWithOne M\u2082 :=\n  { hf.addMonoid f zero add nsmul with\n    natCast := Nat.cast,\n    natCast_zero := by rw [\u2190 Nat.cast, \u2190 nat_cast, Nat.cast_zero, zero]\n    natCast_succ := fun n => by rw [\u2190 Nat.cast, \u2190 nat_cast, Nat.cast_succ, add, one, nat_cast]\n    one := 1 }", "start": [420, 1], "end": [432, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commMonoid", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive commutative monoid, if it\nadmits a surjective map that preserves `0` and `+` to an additive commutative monoid.\"]\nprotected def commMonoid [CommMonoid M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CommMonoid M\u2082 :=\n  { hf.commSemigroup f mul, hf.monoid f one mul npow with }", "start": [435, 1], "end": [443, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.addCommMonoidWithOne", "code": "@[reducible]\nprotected def addCommMonoidWithOne {M\u2082} [Zero M\u2082] [One M\u2082] [Add M\u2082] [SMul \u2115 M\u2082] [NatCast M\u2082]\n    [AddCommMonoidWithOne M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : AddCommMonoidWithOne M\u2082 :=\n  { hf.addMonoidWithOne f zero one add nsmul nat_cast, hf.addCommMonoid _ zero add nsmul with }", "start": [447, 1], "end": [455, 96], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.involutiveInv", "code": "@[to_additive (attr := reducible)\n\"A type has an involutive negation if it admits a surjective map that\npreserves `-` to a type which has an involutive negation.\"]\nprotected def involutiveInv {M\u2082 : Type*} [Inv M\u2082] [InvolutiveInv M\u2081] (f : M\u2081 \u2192 M\u2082)\n    (hf : Surjective f) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) : InvolutiveInv M\u2082 where\n  inv := Inv.inv\n  inv_inv := hf.forall.2 fun x => by erw [\u2190 inv, \u2190 inv, inv_inv]", "start": [458, 1], "end": [466, 65], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.divInvMonoid", "code": "@[to_additive (attr := reducible) subNegMonoid\n\"A type endowed with `0`, `+`, unary `-`, and binary `-` is a\n`SubNegMonoid` if it admits a surjective map that preserves `0`, `+`, unary `-`, and binary `-` to\na `SubNegMonoid`.\"]\nprotected def divInvMonoid [DivInvMonoid M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : DivInvMonoid M\u2082 :=\n  { hf.monoid f one mul npow, \u2039Div M\u2082\u203a, \u2039Inv M\u2082\u203a with\n    zpow := fun n x => x ^ n,\n    zpow_zero' := hf.forall.2 fun x => by dsimp only; erw [\u2190 zpow, zpow_zero, \u2190 one],\n    zpow_succ' := fun n => hf.forall.2 fun x => by\n      dsimp only\n      erw [\u2190 zpow, \u2190 zpow, zpow_ofNat, zpow_ofNat, pow_succ, \u2190 mul],\n    zpow_neg' := fun n => hf.forall.2 fun x => by\n      dsimp only\n      erw [\u2190 zpow, \u2190 zpow, zpow_negSucc, zpow_ofNat, inv],\n    div_eq_mul_inv := hf.forall\u2082.2 fun x y => by erw [\u2190 inv, \u2190 mul, \u2190 div, div_eq_mul_inv] }", "start": [472, 1], "end": [491, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.group", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive group, if it admits a\nsurjective map that preserves `0` and `+` to an additive group.\"]\nprotected def group [Group M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : Group M\u2082 :=\n  { hf.divInvMonoid f one mul inv div npow zpow with\n    mul_left_inv := hf.forall.2 fun x => by erw [\u2190 inv, \u2190 mul, mul_left_inv, one] }", "start": [495, 1], "end": [505, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.addGroupWithOne", "code": "@[reducible]\nprotected def addGroupWithOne {M\u2082} [Zero M\u2082] [One M\u2082] [Add M\u2082] [Neg M\u2082] [Sub M\u2082] [SMul \u2115 M\u2082]\n    [SMul \u2124 M\u2082] [NatCast M\u2082] [IntCast M\u2082] [AddGroupWithOne M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : AddGroupWithOne M\u2082 :=\n  { hf.addMonoidWithOne f zero one add nsmul nat_cast,\n    hf.addGroup f zero add neg sub nsmul zsmul with\n    intCast := Int.cast,\n    intCast_ofNat := fun n => by rw [\u2190 Int.cast, \u2190 int_cast, Int.cast_ofNat, nat_cast],\n    intCast_negSucc := fun n => by\n      rw [\u2190 Int.cast, \u2190 int_cast, Int.cast_negSucc, neg, nat_cast] }", "start": [509, 1], "end": [524, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commGroup", "code": "@[to_additive (attr := reducible)\n\"A type endowed with `0` and `+` is an additive commutative group, if it\nadmits a surjective map that preserves `0` and `+` to an additive commutative group.\"]\nprotected def commGroup [CommGroup M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : CommGroup M\u2082 :=\n  { hf.commMonoid f one mul npow, hf.group f one mul inv div npow zpow with }", "start": [527, 1], "end": [537, 78], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.addCommGroupWithOne", "code": "@[reducible]\nprotected def addCommGroupWithOne {M\u2082} [Zero M\u2082] [One M\u2082] [Add M\u2082] [Neg M\u2082] [Sub M\u2082] [SMul \u2115 M\u2082]\n    [SMul \u2124 M\u2082] [NatCast M\u2082] [IntCast M\u2082] [AddCommGroupWithOne M\u2081] (f : M\u2081 \u2192 M\u2082) (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : AddCommGroupWithOne M\u2082 :=\n  { hf.addGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,\n    hf.addCommMonoid _ zero add nsmul with }", "start": [541, 1], "end": [552, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SymmDiff.lean", "imports": ["Mathlib/Logic/Equiv/Basic.lean", "Mathlib/Order/BooleanAlgebra.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "symmDiff", "code": "def symmDiff [Sup \u03b1] [SDiff \u03b1] (a b : \u03b1) : \u03b1 :=\n  a \\ b \u2294 b \\ a", "start": [59, 1], "end": [61, 16], "kind": "commanddeclaration"}, {"full_name": "bihimp", "code": "def bihimp [Inf \u03b1] [HImp \u03b1] (a b : \u03b1) : \u03b1 :=\n  (b \u21e8 a) \u2293 (a \u21e8 b)", "start": [64, 1], "end": [67, 20], "kind": "commanddeclaration"}, {"full_name": "symmDiff_def", "code": "theorem symmDiff_def [Sup \u03b1] [SDiff \u03b1] (a b : \u03b1) : a \u2206 b = a \\ b \u2294 b \\ a", "start": [78, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "bihimp_def", "code": "theorem bihimp_def [Inf \u03b1] [HImp \u03b1] (a b : \u03b1) : a \u21d4 b = (b \u21e8 a) \u2293 (a \u21e8 b)", "start": [82, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_Xor'", "code": "theorem symmDiff_eq_Xor' (p q : Prop) : p \u2206 q = Xor' p q", "start": [86, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "bihimp_iff_iff", "code": "@[simp]\ntheorem bihimp_iff_iff {p q : Prop} : p \u21d4 q \u2194 (p \u2194 q)", "start": [90, 1], "end": [92, 56], "kind": "commanddeclaration"}, {"full_name": "Bool.symmDiff_eq_xor", "code": "@[simp]\ntheorem Bool.symmDiff_eq_xor : \u2200 p q : Bool, p \u2206 q = xor p q", "start": [95, 1], "end": [96, 74], "kind": "commanddeclaration"}, {"full_name": "toDual_symmDiff", "code": "@[simp]\ntheorem toDual_symmDiff : toDual (a \u2206 b) = toDual a \u21d4 toDual b", "start": [103, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_bihimp", "code": "@[simp]\ntheorem ofDual_bihimp (a b : \u03b1\u1d52\u1d48) : ofDual (a \u21d4 b) = ofDual a \u2206 ofDual b", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "symmDiff_comm", "code": "theorem symmDiff_comm : a \u2206 b = b \u2206 a", "start": [113, 1], "end": [113, 75], "kind": "commanddeclaration"}, {"full_name": "symmDiff_isCommutative", "code": "instance symmDiff_isCommutative : IsCommutative \u03b1 (\u00b7 \u2206 \u00b7) :=\n  \u27e8symmDiff_comm\u27e9", "start": [116, 1], "end": [117, 18], "kind": "commanddeclaration"}, {"full_name": "symmDiff_self", "code": "@[simp]\ntheorem symmDiff_self : a \u2206 a = \u22a5", "start": [120, 1], "end": [121, 76], "kind": "commanddeclaration"}, {"full_name": "symmDiff_bot", "code": "@[simp]\ntheorem symmDiff_bot : a \u2206 \u22a5 = a", "start": [124, 1], "end": [125, 87], "kind": "commanddeclaration"}, {"full_name": "bot_symmDiff", "code": "@[simp]\ntheorem bot_symmDiff : \u22a5 \u2206 a = a", "start": [128, 1], "end": [129, 72], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_bot", "code": "@[simp]\ntheorem symmDiff_eq_bot {a b : \u03b1} : a \u2206 b = \u22a5 \u2194 a = b", "start": [132, 1], "end": [134, 72], "kind": "commanddeclaration"}, {"full_name": "symmDiff_of_le", "code": "theorem symmDiff_of_le {a b : \u03b1} (h : a \u2264 b) : a \u2206 b = b \\ a", "start": [137, 1], "end": [138, 50], "kind": "commanddeclaration"}, {"full_name": "symmDiff_of_ge", "code": "theorem symmDiff_of_ge {a b : \u03b1} (h : b \u2264 a) : a \u2206 b = a \\ b", "start": [141, 1], "end": [142, 50], "kind": "commanddeclaration"}, {"full_name": "symmDiff_le", "code": "theorem symmDiff_le {a b c : \u03b1} (ha : a \u2264 b \u2294 c) (hb : b \u2264 a \u2294 c) : a \u2206 b \u2264 c", "start": [145, 1], "end": [146, 50], "kind": "commanddeclaration"}, {"full_name": "symmDiff_le_iff", "code": "theorem symmDiff_le_iff {a b c : \u03b1} : a \u2206 b \u2264 c \u2194 a \u2264 b \u2294 c \u2227 b \u2264 a \u2294 c", "start": [149, 1], "end": [150, 47], "kind": "commanddeclaration"}, {"full_name": "symmDiff_le_sup", "code": "@[simp]\ntheorem symmDiff_le_sup {a b : \u03b1} : a \u2206 b \u2264 a \u2294 b", "start": [153, 1], "end": [155, 31], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_sup_sdiff_inf", "code": "theorem symmDiff_eq_sup_sdiff_inf : a \u2206 b = (a \u2294 b) \\ (a \u2293 b)", "start": [158, 1], "end": [158, 95], "kind": "commanddeclaration"}, {"full_name": "Disjoint.symmDiff_eq_sup", "code": "theorem Disjoint.symmDiff_eq_sup {a b : \u03b1} (h : Disjoint a b) : a \u2206 b = a \u2294 b", "start": [161, 1], "end": [162, 51], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sdiff", "code": "theorem symmDiff_sdiff : a \u2206 b \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c)", "start": [165, 1], "end": [166, 71], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sdiff_inf", "code": "@[simp]\ntheorem symmDiff_sdiff_inf : a \u2206 b \\ (a \u2293 b) = a \u2206 b", "start": [169, 1], "end": [172, 18], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sdiff_eq_sup", "code": "@[simp]\ntheorem symmDiff_sdiff_eq_sup : a \u2206 (b \\ a) = a \u2294 b", "start": [175, 1], "end": [180, 86], "kind": "commanddeclaration"}, {"full_name": "sdiff_symmDiff_eq_sup", "code": "@[simp]\ntheorem sdiff_symmDiff_eq_sup : (a \\ b) \u2206 b = a \u2294 b", "start": [183, 1], "end": [185, 54], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sup_inf", "code": "@[simp]\ntheorem symmDiff_sup_inf : a \u2206 b \u2294 a \u2293 b = a \u2294 b", "start": [188, 1], "end": [196, 42], "kind": "commanddeclaration"}, {"full_name": "inf_sup_symmDiff", "code": "@[simp]\ntheorem inf_sup_symmDiff : a \u2293 b \u2294 a \u2206 b = a \u2294 b", "start": [199, 1], "end": [200, 87], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_inf", "code": "@[simp]\ntheorem symmDiff_symmDiff_inf : a \u2206 b \u2206 (a \u2293 b) = a \u2294 b", "start": [203, 1], "end": [205, 71], "kind": "commanddeclaration"}, {"full_name": "inf_symmDiff_symmDiff", "code": "@[simp]\ntheorem inf_symmDiff_symmDiff : (a \u2293 b) \u2206 (a \u2206 b) = a \u2294 b", "start": [208, 1], "end": [210, 44], "kind": "commanddeclaration"}, {"full_name": "symmDiff_triangle", "code": "theorem symmDiff_triangle : a \u2206 c \u2264 a \u2206 b \u2294 b \u2206 c", "start": [213, 1], "end": [215, 67], "kind": "commanddeclaration"}, {"full_name": "toDual_bihimp", "code": "@[simp]\ntheorem toDual_bihimp : toDual (a \u21d4 b) = toDual a \u2206 toDual b", "start": [224, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "ofDual_symmDiff", "code": "@[simp]\ntheorem ofDual_symmDiff (a b : \u03b1\u1d52\u1d48) : ofDual (a \u2206 b) = ofDual a \u21d4 ofDual b", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "bihimp_comm", "code": "theorem bihimp_comm : a \u21d4 b = b \u21d4 a", "start": [234, 1], "end": [234, 72], "kind": "commanddeclaration"}, {"full_name": "bihimp_isCommutative", "code": "instance bihimp_isCommutative : IsCommutative \u03b1 (\u00b7 \u21d4 \u00b7) :=\n  \u27e8bihimp_comm\u27e9", "start": [237, 1], "end": [238, 16], "kind": "commanddeclaration"}, {"full_name": "bihimp_self", "code": "@[simp]\ntheorem bihimp_self : a \u21d4 a = \u22a4", "start": [241, 1], "end": [242, 71], "kind": "commanddeclaration"}, {"full_name": "bihimp_top", "code": "@[simp]\ntheorem bihimp_top : a \u21d4 \u22a4 = a", "start": [245, 1], "end": [246, 81], "kind": "commanddeclaration"}, {"full_name": "top_bihimp", "code": "@[simp]\ntheorem top_bihimp : \u22a4 \u21d4 a = a", "start": [249, 1], "end": [250, 66], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_top", "code": "@[simp]\ntheorem bihimp_eq_top {a b : \u03b1} : a \u21d4 b = \u22a4 \u2194 a = b", "start": [253, 1], "end": [255, 29], "kind": "commanddeclaration"}, {"full_name": "bihimp_of_le", "code": "theorem bihimp_of_le {a b : \u03b1} (h : a \u2264 b) : a \u21d4 b = b \u21e8 a", "start": [258, 1], "end": [259, 47], "kind": "commanddeclaration"}, {"full_name": "bihimp_of_ge", "code": "theorem bihimp_of_ge {a b : \u03b1} (h : b \u2264 a) : a \u21d4 b = a \u21e8 b", "start": [262, 1], "end": [263, 47], "kind": "commanddeclaration"}, {"full_name": "le_bihimp", "code": "theorem le_bihimp {a b c : \u03b1} (hb : a \u2293 b \u2264 c) (hc : a \u2293 c \u2264 b) : a \u2264 b \u21d4 c", "start": [266, 1], "end": [267, 48], "kind": "commanddeclaration"}, {"full_name": "le_bihimp_iff", "code": "theorem le_bihimp_iff {a b c : \u03b1} : a \u2264 b \u21d4 c \u2194 a \u2293 b \u2264 c \u2227 a \u2293 c \u2264 b", "start": [270, 1], "end": [271, 54], "kind": "commanddeclaration"}, {"full_name": "inf_le_bihimp", "code": "@[simp]\ntheorem inf_le_bihimp {a b : \u03b1} : a \u2293 b \u2264 a \u21d4 b", "start": [274, 1], "end": [276, 29], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_inf_himp_inf", "code": "theorem bihimp_eq_inf_himp_inf : a \u21d4 b = a \u2294 b \u21e8 a \u2293 b", "start": [279, 1], "end": [279, 93], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.bihimp_eq_inf", "code": "theorem Codisjoint.bihimp_eq_inf {a b : \u03b1} (h : Codisjoint a b) : a \u21d4 b = a \u2293 b", "start": [282, 1], "end": [283, 47], "kind": "commanddeclaration"}, {"full_name": "himp_bihimp", "code": "theorem himp_bihimp : a \u21e8 b \u21d4 c = (a \u2293 c \u21e8 b) \u2293 (a \u2293 b \u21e8 c)", "start": [286, 1], "end": [287, 54], "kind": "commanddeclaration"}, {"full_name": "sup_himp_bihimp", "code": "@[simp]\ntheorem sup_himp_bihimp : a \u2294 b \u21e8 a \u21d4 b = a \u21d4 b", "start": [290, 1], "end": [293, 16], "kind": "commanddeclaration"}, {"full_name": "bihimp_himp_eq_inf", "code": "@[simp]\ntheorem bihimp_himp_eq_inf : a \u21d4 (a \u21e8 b) = a \u2293 b", "start": [296, 1], "end": [298, 35], "kind": "commanddeclaration"}, {"full_name": "himp_bihimp_eq_inf", "code": "@[simp]\ntheorem himp_bihimp_eq_inf : (b \u21e8 a) \u21d4 b = a \u2293 b", "start": [301, 1], "end": [303, 35], "kind": "commanddeclaration"}, {"full_name": "bihimp_inf_sup", "code": "@[simp]\ntheorem bihimp_inf_sup : a \u21d4 b \u2293 (a \u2294 b) = a \u2293 b", "start": [306, 1], "end": [308, 30], "kind": "commanddeclaration"}, {"full_name": "sup_inf_bihimp", "code": "@[simp]\ntheorem sup_inf_bihimp : (a \u2294 b) \u2293 a \u21d4 b = a \u2293 b", "start": [311, 1], "end": [313, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_bihimp_sup", "code": "@[simp]\ntheorem bihimp_bihimp_sup : a \u21d4 b \u21d4 (a \u2294 b) = a \u2293 b", "start": [316, 1], "end": [318, 35], "kind": "commanddeclaration"}, {"full_name": "sup_bihimp_bihimp", "code": "@[simp]\ntheorem sup_bihimp_bihimp : (a \u2294 b) \u21d4 (a \u21d4 b) = a \u2293 b", "start": [321, 1], "end": [323, 35], "kind": "commanddeclaration"}, {"full_name": "bihimp_triangle", "code": "theorem bihimp_triangle : a \u21d4 b \u2293 b \u21d4 c \u2264 a \u21d4 c", "start": [326, 1], "end": [327, 33], "kind": "commanddeclaration"}, {"full_name": "symmDiff_top'", "code": "@[simp]\ntheorem symmDiff_top' : a \u2206 \u22a4 = \uffe2a", "start": [336, 1], "end": [337, 57], "kind": "commanddeclaration"}, {"full_name": "top_symmDiff'", "code": "@[simp]\ntheorem top_symmDiff' : \u22a4 \u2206 a = \uffe2a", "start": [340, 1], "end": [341, 57], "kind": "commanddeclaration"}, {"full_name": "hnot_symmDiff_self", "code": "@[simp]\ntheorem hnot_symmDiff_self : (\uffe2a) \u2206 a = \u22a4", "start": [344, 1], "end": [347, 47], "kind": "commanddeclaration"}, {"full_name": "symmDiff_hnot_self", "code": "@[simp]\ntheorem symmDiff_hnot_self : a \u2206 (\uffe2a) = \u22a4", "start": [350, 1], "end": [351, 87], "kind": "commanddeclaration"}, {"full_name": "IsCompl.symmDiff_eq_top", "code": "theorem IsCompl.symmDiff_eq_top {a b : \u03b1} (h : IsCompl a b) : a \u2206 b = \u22a4", "start": [354, 1], "end": [355, 37], "kind": "commanddeclaration"}, {"full_name": "bihimp_bot", "code": "@[simp]\ntheorem bihimp_bot : a \u21d4 \u22a5 = a\u1d9c", "start": [364, 1], "end": [365, 52], "kind": "commanddeclaration"}, {"full_name": "bot_bihimp", "code": "@[simp]\ntheorem bot_bihimp : \u22a5 \u21d4 a = a\u1d9c", "start": [368, 1], "end": [369, 52], "kind": "commanddeclaration"}, {"full_name": "compl_bihimp_self", "code": "@[simp]\ntheorem compl_bihimp_self : a\u1d9c \u21d4 a = \u22a5", "start": [372, 1], "end": [374, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_hnot_self", "code": "@[simp]\ntheorem bihimp_hnot_self : a \u21d4 a\u1d9c = \u22a5", "start": [377, 1], "end": [379, 30], "kind": "commanddeclaration"}, {"full_name": "IsCompl.bihimp_eq_bot", "code": "theorem IsCompl.bihimp_eq_bot {a b : \u03b1} (h : IsCompl a b) : a \u21d4 b = \u22a5", "start": [382, 1], "end": [383, 37], "kind": "commanddeclaration"}, {"full_name": "sup_sdiff_symmDiff", "code": "@[simp]\ntheorem sup_sdiff_symmDiff : (a \u2294 b) \\ a \u2206 b = a \u2293 b", "start": [392, 1], "end": [394, 63], "kind": "commanddeclaration"}, {"full_name": "disjoint_symmDiff_inf", "code": "theorem disjoint_symmDiff_inf : Disjoint (a \u2206 b) (a \u2293 b)", "start": [397, 1], "end": [399, 33], "kind": "commanddeclaration"}, {"full_name": "inf_symmDiff_distrib_left", "code": "theorem inf_symmDiff_distrib_left : a \u2293 b \u2206 c = (a \u2293 b) \u2206 (a \u2293 c)", "start": [402, 1], "end": [404, 31], "kind": "commanddeclaration"}, {"full_name": "inf_symmDiff_distrib_right", "code": "theorem inf_symmDiff_distrib_right : a \u2206 b \u2293 c = (a \u2293 c) \u2206 (b \u2293 c)", "start": [407, 1], "end": [408, 57], "kind": "commanddeclaration"}, {"full_name": "sdiff_symmDiff", "code": "theorem sdiff_symmDiff : c \\ a \u2206 b = c \u2293 a \u2293 b \u2294 c \\ a \u2293 c \\ b", "start": [411, 1], "end": [412, 46], "kind": "commanddeclaration"}, {"full_name": "sdiff_symmDiff'", "code": "theorem sdiff_symmDiff' : c \\ a \u2206 b = c \u2293 a \u2293 b \u2294 c \\ (a \u2294 b)", "start": [415, 1], "end": [416, 43], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sdiff_left", "code": "@[simp]\ntheorem symmDiff_sdiff_left : a \u2206 b \\ a = b \\ a", "start": [419, 1], "end": [421, 73], "kind": "commanddeclaration"}, {"full_name": "symmDiff_sdiff_right", "code": "@[simp]\ntheorem symmDiff_sdiff_right : a \u2206 b \\ b = a \\ b", "start": [424, 1], "end": [425, 95], "kind": "commanddeclaration"}, {"full_name": "sdiff_symmDiff_left", "code": "@[simp]\ntheorem sdiff_symmDiff_left : a \\ a \u2206 b = a \u2293 b", "start": [428, 1], "end": [429, 76], "kind": "commanddeclaration"}, {"full_name": "sdiff_symmDiff_right", "code": "@[simp]\ntheorem sdiff_symmDiff_right : b \\ a \u2206 b = a \u2293 b", "start": [432, 1], "end": [434, 52], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_sup", "code": "theorem symmDiff_eq_sup : a \u2206 b = a \u2294 b \u2194 Disjoint a b", "start": [437, 1], "end": [440, 44], "kind": "commanddeclaration"}, {"full_name": "le_symmDiff_iff_left", "code": "@[simp]\ntheorem le_symmDiff_iff_left : a \u2264 a \u2206 b \u2194 Disjoint a b", "start": [443, 1], "end": [447, 75], "kind": "commanddeclaration"}, {"full_name": "le_symmDiff_iff_right", "code": "@[simp]\ntheorem le_symmDiff_iff_right : b \u2264 a \u2206 b \u2194 Disjoint a b", "start": [450, 1], "end": [452, 58], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_left", "code": "theorem symmDiff_symmDiff_left :\n    a \u2206 b \u2206 c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) \u2294 c \\ (a \u2294 b) \u2294 a \u2293 b \u2293 c", "start": [455, 1], "end": [461, 73], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_right", "code": "theorem symmDiff_symmDiff_right :\n    a \u2206 (b \u2206 c) = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) \u2294 c \\ (a \u2294 b) \u2294 a \u2293 b \u2293 c", "start": [464, 1], "end": [470, 73], "kind": "commanddeclaration"}, {"full_name": "symmDiff_assoc", "code": "theorem symmDiff_assoc : a \u2206 b \u2206 c = a \u2206 (b \u2206 c)", "start": [473, 1], "end": [474, 55], "kind": "commanddeclaration"}, {"full_name": "symmDiff_isAssociative", "code": "instance symmDiff_isAssociative : IsAssociative \u03b1 (\u00b7 \u2206 \u00b7) :=\n  \u27e8symmDiff_assoc\u27e9", "start": [477, 1], "end": [478, 19], "kind": "commanddeclaration"}, {"full_name": "symmDiff_left_comm", "code": "theorem symmDiff_left_comm : a \u2206 (b \u2206 c) = b \u2206 (a \u2206 c)", "start": [481, 1], "end": [482, 44], "kind": "commanddeclaration"}, {"full_name": "symmDiff_right_comm", "code": "theorem symmDiff_right_comm : a \u2206 b \u2206 c = a \u2206 c \u2206 b", "start": [485, 1], "end": [485, 98], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_symmDiff_comm", "code": "theorem symmDiff_symmDiff_symmDiff_comm : a \u2206 b \u2206 (c \u2206 d) = a \u2206 c \u2206 (b \u2206 d)", "start": [488, 1], "end": [489, 47], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_cancel_left", "code": "@[simp]\ntheorem symmDiff_symmDiff_cancel_left : a \u2206 (a \u2206 b) = b", "start": [492, 1], "end": [493, 86], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_cancel_right", "code": "@[simp]\ntheorem symmDiff_symmDiff_cancel_right : b \u2206 a \u2206 a = b", "start": [496, 1], "end": [497, 83], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_self'", "code": "@[simp]\ntheorem symmDiff_symmDiff_self' : a \u2206 b \u2206 a = b", "start": [500, 1], "end": [502, 52], "kind": "commanddeclaration"}, {"full_name": "symmDiff_left_involutive", "code": "theorem symmDiff_left_involutive (a : \u03b1) : Involutive (\u00b7 \u2206 a)", "start": [505, 1], "end": [506, 35], "kind": "commanddeclaration"}, {"full_name": "symmDiff_right_involutive", "code": "theorem symmDiff_right_involutive (a : \u03b1) : Involutive ((\u00b7 \u2206 \u00b7) a)", "start": [509, 1], "end": [510, 34], "kind": "commanddeclaration"}, {"full_name": "symmDiff_left_injective", "code": "theorem symmDiff_left_injective (a : \u03b1) : Injective (\u00b7 \u2206 a)", "start": [513, 1], "end": [514, 61], "kind": "commanddeclaration"}, {"full_name": "symmDiff_right_injective", "code": "theorem symmDiff_right_injective (a : \u03b1) : Injective ((\u00b7 \u2206 \u00b7) a)", "start": [517, 1], "end": [518, 62], "kind": "commanddeclaration"}, {"full_name": "symmDiff_left_surjective", "code": "theorem symmDiff_left_surjective (a : \u03b1) : Surjective (\u00b7 \u2206 a)", "start": [521, 1], "end": [522, 62], "kind": "commanddeclaration"}, {"full_name": "symmDiff_right_surjective", "code": "theorem symmDiff_right_surjective (a : \u03b1) : Surjective ((\u00b7 \u2206 \u00b7) a)", "start": [525, 1], "end": [526, 63], "kind": "commanddeclaration"}, {"full_name": "symmDiff_left_inj", "code": "@[simp]\ntheorem symmDiff_left_inj : a \u2206 b = c \u2206 b \u2194 a = c", "start": [531, 1], "end": [533, 37], "kind": "commanddeclaration"}, {"full_name": "symmDiff_right_inj", "code": "@[simp]\ntheorem symmDiff_right_inj : a \u2206 b = a \u2206 c \u2194 b = c", "start": [536, 1], "end": [538, 38], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_left", "code": "@[simp]\ntheorem symmDiff_eq_left : a \u2206 b = a \u2194 b = \u22a5", "start": [541, 1], "end": [545, 44], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_right", "code": "@[simp]\ntheorem symmDiff_eq_right : a \u2206 b = b \u2194 a = \u22a5", "start": [548, 1], "end": [549, 89], "kind": "commanddeclaration"}, {"full_name": "Disjoint.symmDiff_left", "code": "protected theorem Disjoint.symmDiff_left (ha : Disjoint a c) (hb : Disjoint b c) :\n    Disjoint (a \u2206 b) c", "start": [552, 1], "end": [555, 45], "kind": "commanddeclaration"}, {"full_name": "Disjoint.symmDiff_right", "code": "protected theorem Disjoint.symmDiff_right (ha : Disjoint a b) (hb : Disjoint a c) :\n    Disjoint a (b \u2206 c)", "start": [558, 1], "end": [560, 39], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_iff_sdiff_eq", "code": "theorem symmDiff_eq_iff_sdiff_eq (ha : a \u2264 c) : a \u2206 b = c \u2194 c \\ a = b", "start": [563, 1], "end": [565, 90], "kind": "commanddeclaration"}, {"full_name": "inf_himp_bihimp", "code": "@[simp]\ntheorem inf_himp_bihimp : a \u21d4 b \u21e8 a \u2293 b = a \u2294 b", "start": [578, 1], "end": [580, 32], "kind": "commanddeclaration"}, {"full_name": "codisjoint_bihimp_sup", "code": "theorem codisjoint_bihimp_sup : Codisjoint (a \u21d4 b) (a \u2294 b)", "start": [583, 1], "end": [584, 35], "kind": "commanddeclaration"}, {"full_name": "himp_bihimp_left", "code": "@[simp]\ntheorem himp_bihimp_left : a \u21e8 a \u21d4 b = a \u21e8 b", "start": [587, 1], "end": [589, 33], "kind": "commanddeclaration"}, {"full_name": "himp_bihimp_right", "code": "@[simp]\ntheorem himp_bihimp_right : b \u21e8 a \u21d4 b = b \u21e8 a", "start": [592, 1], "end": [594, 34], "kind": "commanddeclaration"}, {"full_name": "bihimp_himp_left", "code": "@[simp]\ntheorem bihimp_himp_left : a \u21d4 b \u21e8 a = a \u2294 b", "start": [597, 1], "end": [599, 33], "kind": "commanddeclaration"}, {"full_name": "bihimp_himp_right", "code": "@[simp]\ntheorem bihimp_himp_right : a \u21d4 b \u21e8 b = a \u2294 b", "start": [602, 1], "end": [604, 34], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_inf", "code": "@[simp]\ntheorem bihimp_eq_inf : a \u21d4 b = a \u2293 b \u2194 Codisjoint a b", "start": [607, 1], "end": [609, 29], "kind": "commanddeclaration"}, {"full_name": "bihimp_le_iff_left", "code": "@[simp]\ntheorem bihimp_le_iff_left : a \u21d4 b \u2264 a \u2194 Codisjoint a b", "start": [612, 1], "end": [614, 34], "kind": "commanddeclaration"}, {"full_name": "bihimp_le_iff_right", "code": "@[simp]\ntheorem bihimp_le_iff_right : a \u21d4 b \u2264 b \u2194 Codisjoint a b", "start": [617, 1], "end": [619, 35], "kind": "commanddeclaration"}, {"full_name": "bihimp_assoc", "code": "theorem bihimp_assoc : a \u21d4 b \u21d4 c = a \u21d4 (b \u21d4 c)", "start": [622, 1], "end": [623, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_isAssociative", "code": "instance bihimp_isAssociative : IsAssociative \u03b1 (\u00b7 \u21d4 \u00b7) :=\n  \u27e8bihimp_assoc\u27e9", "start": [626, 1], "end": [627, 17], "kind": "commanddeclaration"}, {"full_name": "bihimp_left_comm", "code": "theorem bihimp_left_comm : a \u21d4 (b \u21d4 c) = b \u21d4 (a \u21d4 c)", "start": [630, 1], "end": [630, 97], "kind": "commanddeclaration"}, {"full_name": "bihimp_right_comm", "code": "theorem bihimp_right_comm : a \u21d4 b \u21d4 c = a \u21d4 c \u21d4 b", "start": [633, 1], "end": [633, 92], "kind": "commanddeclaration"}, {"full_name": "bihimp_bihimp_bihimp_comm", "code": "theorem bihimp_bihimp_bihimp_comm : a \u21d4 b \u21d4 (c \u21d4 d) = a \u21d4 c \u21d4 (b \u21d4 d)", "start": [636, 1], "end": [637, 43], "kind": "commanddeclaration"}, {"full_name": "bihimp_bihimp_cancel_left", "code": "@[simp]\ntheorem bihimp_bihimp_cancel_left : a \u21d4 (a \u21d4 b) = b", "start": [640, 1], "end": [641, 80], "kind": "commanddeclaration"}, {"full_name": "bihimp_bihimp_cancel_right", "code": "@[simp]\ntheorem bihimp_bihimp_cancel_right : b \u21d4 a \u21d4 a = b", "start": [644, 1], "end": [645, 77], "kind": "commanddeclaration"}, {"full_name": "bihimp_bihimp_self", "code": "@[simp]\ntheorem bihimp_bihimp_self : a \u21d4 b \u21d4 a = b", "start": [648, 1], "end": [649, 93], "kind": "commanddeclaration"}, {"full_name": "bihimp_left_involutive", "code": "theorem bihimp_left_involutive (a : \u03b1) : Involutive (\u00b7 \u21d4 a)", "start": [652, 1], "end": [653, 31], "kind": "commanddeclaration"}, {"full_name": "bihimp_right_involutive", "code": "theorem bihimp_right_involutive (a : \u03b1) : Involutive ((\u00b7 \u21d4 \u00b7) a)", "start": [656, 1], "end": [657, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_left_injective", "code": "theorem bihimp_left_injective (a : \u03b1) : Injective (\u00b7 \u21d4 a)", "start": [660, 1], "end": [661, 35], "kind": "commanddeclaration"}, {"full_name": "bihimp_right_injective", "code": "theorem bihimp_right_injective (a : \u03b1) : Injective ((\u00b7 \u21d4 \u00b7) a)", "start": [664, 1], "end": [665, 36], "kind": "commanddeclaration"}, {"full_name": "bihimp_left_surjective", "code": "theorem bihimp_left_surjective (a : \u03b1) : Surjective (\u00b7 \u21d4 a)", "start": [668, 1], "end": [669, 36], "kind": "commanddeclaration"}, {"full_name": "bihimp_right_surjective", "code": "theorem bihimp_right_surjective (a : \u03b1) : Surjective ((\u00b7 \u21d4 \u00b7) a)", "start": [672, 1], "end": [673, 37], "kind": "commanddeclaration"}, {"full_name": "bihimp_left_inj", "code": "@[simp]\ntheorem bihimp_left_inj : a \u21d4 b = c \u21d4 b \u2194 a = c", "start": [678, 1], "end": [680, 35], "kind": "commanddeclaration"}, {"full_name": "bihimp_right_inj", "code": "@[simp]\ntheorem bihimp_right_inj : a \u21d4 b = a \u21d4 c \u2194 b = c", "start": [683, 1], "end": [685, 36], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_left", "code": "@[simp]\ntheorem bihimp_eq_left : a \u21d4 b = a \u2194 b = \u22a4", "start": [688, 1], "end": [690, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_right", "code": "@[simp]\ntheorem bihimp_eq_right : a \u21d4 b = b \u2194 a = \u22a4", "start": [693, 1], "end": [695, 31], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.bihimp_left", "code": "protected theorem Codisjoint.bihimp_left (ha : Codisjoint a c) (hb : Codisjoint b c) :\n    Codisjoint (a \u21d4 b) c", "start": [698, 1], "end": [700, 43], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.bihimp_right", "code": "protected theorem Codisjoint.bihimp_right (ha : Codisjoint a b) (hb : Codisjoint a c) :\n    Codisjoint a (b \u21d4 c)", "start": [703, 1], "end": [705, 45], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq", "code": "theorem symmDiff_eq : a \u2206 b = a \u2293 b\u1d9c \u2294 b \u2293 a\u1d9c", "start": [710, 1], "end": [710, 82], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq", "code": "theorem bihimp_eq : a \u21d4 b = (a \u2294 b\u1d9c) \u2293 (b \u2294 a\u1d9c)", "start": [713, 1], "end": [713, 83], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq'", "code": "theorem symmDiff_eq' : a \u2206 b = (a \u2294 b) \u2293 (a\u1d9c \u2294 b\u1d9c)", "start": [716, 1], "end": [717, 54], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq'", "code": "theorem bihimp_eq' : a \u21d4 b = a \u2293 b \u2294 a\u1d9c \u2293 b\u1d9c", "start": [720, 1], "end": [721, 26], "kind": "commanddeclaration"}, {"full_name": "symmDiff_top", "code": "theorem symmDiff_top : a \u2206 \u22a4 = a\u1d9c", "start": [724, 1], "end": [725, 18], "kind": "commanddeclaration"}, {"full_name": "top_symmDiff", "code": "theorem top_symmDiff : \u22a4 \u2206 a = a\u1d9c", "start": [728, 1], "end": [729, 18], "kind": "commanddeclaration"}, {"full_name": "compl_symmDiff", "code": "@[simp]\ntheorem compl_symmDiff : (a \u2206 b)\u1d9c = a \u21d4 b", "start": [732, 1], "end": [734, 71], "kind": "commanddeclaration"}, {"full_name": "compl_bihimp", "code": "@[simp]\ntheorem compl_bihimp : (a \u21d4 b)\u1d9c = a \u2206 b", "start": [737, 1], "end": [739, 28], "kind": "commanddeclaration"}, {"full_name": "compl_symmDiff_compl", "code": "@[simp]\ntheorem compl_symmDiff_compl : a\u1d9c \u2206 b\u1d9c = a \u2206 b", "start": [742, 1], "end": [744, 74], "kind": "commanddeclaration"}, {"full_name": "compl_bihimp_compl", "code": "@[simp]\ntheorem compl_bihimp_compl : a\u1d9c \u21d4 b\u1d9c = a \u21d4 b", "start": [747, 1], "end": [749, 34], "kind": "commanddeclaration"}, {"full_name": "symmDiff_eq_top", "code": "@[simp]\ntheorem symmDiff_eq_top : a \u2206 b = \u22a4 \u2194 IsCompl a b", "start": [752, 1], "end": [755, 30], "kind": "commanddeclaration"}, {"full_name": "bihimp_eq_bot", "code": "@[simp]\ntheorem bihimp_eq_bot : a \u21d4 b = \u22a5 \u2194 IsCompl a b", "start": [758, 1], "end": [761, 20], "kind": "commanddeclaration"}, {"full_name": "compl_symmDiff_self", "code": "@[simp]\ntheorem compl_symmDiff_self : a\u1d9c \u2206 a = \u22a4", "start": [764, 1], "end": [766, 23], "kind": "commanddeclaration"}, {"full_name": "symmDiff_compl_self", "code": "@[simp]\ntheorem symmDiff_compl_self : a \u2206 a\u1d9c = \u22a4", "start": [769, 1], "end": [771, 23], "kind": "commanddeclaration"}, {"full_name": "symmDiff_symmDiff_right'", "code": "theorem symmDiff_symmDiff_right' :\n    a \u2206 (b \u2206 c) = a \u2293 b \u2293 c \u2294 a \u2293 b\u1d9c \u2293 c\u1d9c \u2294 a\u1d9c \u2293 b \u2293 c\u1d9c \u2294 a\u1d9c \u2293 b\u1d9c \u2293 c", "start": [774, 1], "end": [785, 35], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_symmDiff_sup_symmDiff_left", "code": "theorem Disjoint.le_symmDiff_sup_symmDiff_left (h : Disjoint a b) : c \u2264 a \u2206 c \u2294 b \u2206 c", "start": [790, 1], "end": [794, 47], "kind": "commanddeclaration"}, {"full_name": "Disjoint.le_symmDiff_sup_symmDiff_right", "code": "theorem Disjoint.le_symmDiff_sup_symmDiff_right (h : Disjoint b c) : a \u2264 a \u2206 b \u2294 a \u2206 c", "start": [797, 1], "end": [799, 40], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.bihimp_inf_bihimp_le_left", "code": "theorem Codisjoint.bihimp_inf_bihimp_le_left (h : Codisjoint a b) : a \u21d4 c \u2293 b \u21d4 c \u2264 c", "start": [802, 1], "end": [803, 39], "kind": "commanddeclaration"}, {"full_name": "Codisjoint.bihimp_inf_bihimp_le_right", "code": "theorem Codisjoint.bihimp_inf_bihimp_le_right (h : Codisjoint b c) : a \u21d4 b \u2293 a \u21d4 c \u2264 a", "start": [806, 1], "end": [807, 40], "kind": "commanddeclaration"}, {"full_name": "symmDiff_fst", "code": "@[simp]\ntheorem symmDiff_fst [GeneralizedCoheytingAlgebra \u03b1] [GeneralizedCoheytingAlgebra \u03b2]\n    (a b : \u03b1 \u00d7 \u03b2) : (a \u2206 b).1 = a.1 \u2206 b.1", "start": [817, 1], "end": [820, 6], "kind": "commanddeclaration"}, {"full_name": "symmDiff_snd", "code": "@[simp]\ntheorem symmDiff_snd [GeneralizedCoheytingAlgebra \u03b1] [GeneralizedCoheytingAlgebra \u03b2]\n    (a b : \u03b1 \u00d7 \u03b2) : (a \u2206 b).2 = a.2 \u2206 b.2", "start": [823, 1], "end": [826, 6], "kind": "commanddeclaration"}, {"full_name": "bihimp_fst", "code": "@[simp]\ntheorem bihimp_fst [GeneralizedHeytingAlgebra \u03b1] [GeneralizedHeytingAlgebra \u03b2] (a b : \u03b1 \u00d7 \u03b2) :\n    (a \u21d4 b).1 = a.1 \u21d4 b.1", "start": [829, 1], "end": [832, 6], "kind": "commanddeclaration"}, {"full_name": "bihimp_snd", "code": "@[simp]\ntheorem bihimp_snd [GeneralizedHeytingAlgebra \u03b1] [GeneralizedHeytingAlgebra \u03b2] (a b : \u03b1 \u00d7 \u03b2) :\n    (a \u21d4 b).2 = a.2 \u21d4 b.2", "start": [835, 1], "end": [838, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.symmDiff_def", "code": "theorem symmDiff_def [\u2200 i, GeneralizedCoheytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) :\n    a \u2206 b = fun i => a i \u2206 b i", "start": [848, 1], "end": [850, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.bihimp_def", "code": "theorem bihimp_def [\u2200 i, GeneralizedHeytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) :\n    a \u21d4 b = fun i => a i \u21d4 b i", "start": [853, 1], "end": [855, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.symmDiff_apply", "code": "@[simp]\ntheorem symmDiff_apply [\u2200 i, GeneralizedCoheytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) (i : \u03b9) :\n    (a \u2206 b) i = a i \u2206 b i", "start": [858, 1], "end": [861, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.bihimp_apply", "code": "@[simp]\ntheorem bihimp_apply [\u2200 i, GeneralizedHeytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) (i : \u03b9) :\n    (a \u21d4 b) i = a i \u21d4 b i", "start": [864, 1], "end": [867, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Divisibility/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "semigroupDvd", "code": "instance (priority := 100) semigroupDvd : Dvd \u03b1 :=\n  Dvd.mk fun a b => \u2203 c, b = a * c", "start": [40, 1], "end": [43, 35], "kind": "commanddeclaration"}, {"full_name": "Dvd.intro", "code": "theorem Dvd.intro (c : \u03b1) (h : a * c = b) : a \u2223 b", "start": [48, 1], "end": [49, 24], "kind": "commanddeclaration"}, {"full_name": "dvd_of_mul_right_eq", "code": "alias dvd_of_mul_right_eq := Dvd.intro", "start": [52, 1], "end": [52, 39], "kind": "stdtacticaliasalias"}, {"full_name": "exists_eq_mul_right_of_dvd", "code": "theorem exists_eq_mul_right_of_dvd (h : a \u2223 b) : \u2203 c, b = a * c", "start": [55, 1], "end": [56, 4], "kind": "commanddeclaration"}, {"full_name": "dvd_def", "code": "theorem dvd_def : a \u2223 b \u2194 \u2203 c, b = a * c", "start": [59, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "dvd_iff_exists_eq_mul_right", "code": "alias dvd_iff_exists_eq_mul_right := dvd_def", "start": [62, 1], "end": [62, 45], "kind": "stdtacticaliasalias"}, {"full_name": "Dvd.elim", "code": "theorem Dvd.elim {P : Prop} {a b : \u03b1} (H\u2081 : a \u2223 b) (H\u2082 : \u2200 c, b = a * c \u2192 P) : P", "start": [64, 1], "end": [65, 20], "kind": "commanddeclaration"}, {"full_name": "dvd_trans", "code": "@[trans]\ntheorem dvd_trans : a \u2223 b \u2192 b \u2223 c \u2192 a \u2223 c", "start": [70, 1], "end": [72, 66], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.trans", "code": "alias Dvd.dvd.trans := dvd_trans", "start": [75, 1], "end": [75, 33], "kind": "stdtacticaliasalias"}, {"full_name": "dvd_mul_right", "code": "@[simp]\ntheorem dvd_mul_right (a b : \u03b1) : a \u2223 a * b", "start": [81, 1], "end": [83, 18], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_of_dvd_left", "code": "theorem dvd_mul_of_dvd_left (h : a \u2223 b) (c : \u03b1) : a \u2223 b * c", "start": [86, 1], "end": [87, 30], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.mul_right", "code": "alias Dvd.dvd.mul_right := dvd_mul_of_dvd_left", "start": [90, 1], "end": [90, 47], "kind": "stdtacticaliasalias"}, {"full_name": "dvd_of_mul_right_dvd", "code": "theorem dvd_of_mul_right_dvd (h : a * b \u2223 c) : a \u2223 c", "start": [92, 1], "end": [93, 30], "kind": "commanddeclaration"}, {"full_name": "map_dvd", "code": "theorem map_dvd {F : Type*} [MulHomClass F M N] (f : F) {a b} : a \u2223 b \u2192 f a \u2223 f b", "start": [100, 1], "end": [101, 44], "kind": "commanddeclaration"}, {"full_name": "MulHom.map_dvd", "code": "theorem MulHom.map_dvd (f : M \u2192\u2099* N) {a b} : a \u2223 b \u2192 f a \u2223 f b", "start": [104, 1], "end": [105, 19], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_dvd", "code": "theorem MonoidHom.map_dvd (f : M \u2192* N) {a b} : a \u2223 b \u2192 f a \u2223 f b", "start": [108, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "dvd_refl", "code": "@[refl, simp]\ntheorem dvd_refl (a : \u03b1) : a \u2223 a", "start": [120, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "dvd_rfl", "code": "theorem dvd_rfl : \u2200 {a : \u03b1}, a \u2223 a", "start": [125, 1], "end": [125, 60], "kind": "commanddeclaration"}, {"full_name": "one_dvd", "code": "theorem one_dvd (a : \u03b1) : 1 \u2223 a", "start": [131, 1], "end": [132, 26], "kind": "commanddeclaration"}, {"full_name": "dvd_of_eq", "code": "theorem dvd_of_eq (h : a = b) : a \u2223 b", "start": [135, 1], "end": [135, 51], "kind": "commanddeclaration"}, {"full_name": "Eq.dvd", "code": "alias Eq.dvd := dvd_of_eq", "start": [138, 1], "end": [138, 26], "kind": "stdtacticaliasalias"}, {"full_name": "Dvd.intro_left", "code": "theorem Dvd.intro_left (c : \u03b1) (h : c * a = b) : a \u2223 b", "start": [147, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "dvd_of_mul_left_eq", "code": "alias dvd_of_mul_left_eq := Dvd.intro_left", "start": [151, 1], "end": [151, 43], "kind": "stdtacticaliasalias"}, {"full_name": "exists_eq_mul_left_of_dvd", "code": "theorem exists_eq_mul_left_of_dvd (h : a \u2223 b) : \u2203 c, b = c * a", "start": [154, 1], "end": [155, 88], "kind": "commanddeclaration"}, {"full_name": "dvd_iff_exists_eq_mul_left", "code": "theorem dvd_iff_exists_eq_mul_left : a \u2223 b \u2194 \u2203 c, b = c * a", "start": [158, 1], "end": [161, 29], "kind": "commanddeclaration"}, {"full_name": "Dvd.elim_left", "code": "theorem Dvd.elim_left {P : Prop} (h\u2081 : a \u2223 b) (h\u2082 : \u2200 c, b = c * a \u2192 P) : P", "start": [164, 1], "end": [165, 84], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_left", "code": "@[simp]\ntheorem dvd_mul_left (a b : \u03b1) : a \u2223 b * a", "start": [168, 1], "end": [170, 29], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_of_dvd_right", "code": "theorem dvd_mul_of_dvd_right (h : a \u2223 b) (c : \u03b1) : a \u2223 c * b", "start": [173, 1], "end": [174, 37], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.mul_left", "code": "alias Dvd.dvd.mul_left := dvd_mul_of_dvd_right", "start": [177, 1], "end": [177, 47], "kind": "stdtacticaliasalias"}, {"full_name": "mul_dvd_mul", "code": "theorem mul_dvd_mul : \u2200 {a b c d : \u03b1}, a \u2223 b \u2192 c \u2223 d \u2192 a * c \u2223 b * d", "start": [181, 1], "end": [182, 55], "kind": "commanddeclaration"}, {"full_name": "dvd_of_mul_left_dvd", "code": "theorem dvd_of_mul_left_dvd (h : a * b \u2223 c) : b \u2223 c", "start": [185, 1], "end": [186, 60], "kind": "commanddeclaration"}, {"full_name": "mul_dvd_mul_left", "code": "theorem mul_dvd_mul_left (a : \u03b1) {b c : \u03b1} (h : b \u2223 c) : a * b \u2223 a * c", "start": [195, 1], "end": [196, 29], "kind": "commanddeclaration"}, {"full_name": "mul_dvd_mul_right", "code": "theorem mul_dvd_mul_right (h : a \u2223 b) (c : \u03b1) : a * c \u2223 b * c", "start": [199, 1], "end": [200, 29], "kind": "commanddeclaration"}, {"full_name": "pow_dvd_pow_of_dvd", "code": "theorem pow_dvd_pow_of_dvd {a b : \u03b1} (h : a \u2223 b) : \u2200 n : \u2115, a ^ n \u2223 b ^ n", "start": [203, 1], "end": [207, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/OrderIso.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Units/Basic.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderIso.inv", "code": "@[to_additive (attr := simps!) \"`x \u21a6 -x` as an order-reversing equivalence.\"]\ndef OrderIso.inv : \u03b1 \u2243o \u03b1\u1d52\u1d48 where\n  toEquiv := (Equiv.inv \u03b1).trans OrderDual.toDual\n  map_rel_iff' {_ _} := @inv_le_inv_iff \u03b1 _ _ _ _ _ _", "start": [35, 1], "end": [39, 54], "kind": "commanddeclaration"}, {"full_name": "inv_le'", "code": "@[to_additive neg_le]\ntheorem inv_le' : a\u207b\u00b9 \u2264 b \u2194 b\u207b\u00b9 \u2264 a", "start": [47, 1], "end": [49, 33], "kind": "commanddeclaration"}, {"full_name": "inv_le_of_inv_le'", "code": "alias \u27e8inv_le_of_inv_le', _\u27e9 := inv_le'", "start": [53, 1], "end": [53, 40], "kind": "stdtacticaliasaliaslr"}, {"full_name": "le_inv'", "code": "@[to_additive le_neg]\ntheorem le_inv' : a \u2264 b\u207b\u00b9 \u2194 b \u2264 a\u207b\u00b9", "start": [59, 1], "end": [61, 33], "kind": "commanddeclaration"}, {"full_name": "OrderIso.divLeft", "code": "@[to_additive (attr := simps!) \"`x \u21a6 a - x` as an order-reversing equivalence.\"]\ndef OrderIso.divLeft (a : \u03b1) : \u03b1 \u2243o \u03b1\u1d52\u1d48 where\n  toEquiv := (Equiv.divLeft a).trans OrderDual.toDual\n  map_rel_iff' {_ _} := @div_le_div_iff_left \u03b1 _ _ _ _ _ _ _", "start": [65, 1], "end": [69, 61], "kind": "commanddeclaration"}, {"full_name": "le_inv_of_le_inv", "code": "alias \u27e8le_inv_of_le_inv, _\u27e9 := le_inv'", "start": [77, 1], "end": [77, 39], "kind": "stdtacticaliasaliaslr"}, {"full_name": "OrderIso.mulRight", "code": "@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addRight` as an `OrderIso`. See also `OrderEmbedding.addRight`.\"]\ndef OrderIso.mulRight (a : \u03b1) : \u03b1 \u2243o \u03b1 where\n  map_rel_iff' {_ _} := mul_le_mul_iff_right a\n  toEquiv := Equiv.mulRight a", "start": [91, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulRight_symm", "code": "@[to_additive (attr := simp)]\ntheorem OrderIso.mulRight_symm (a : \u03b1) : (OrderIso.mulRight a).symm = OrderIso.mulRight a\u207b\u00b9", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.divRight", "code": "@[to_additive (attr := simps!) \"`x \u21a6 x - a` as an order isomorphism.\"]\ndef OrderIso.divRight (a : \u03b1) : \u03b1 \u2243o \u03b1 where\n  toEquiv := Equiv.divRight a\n  map_rel_iff' {_ _} := div_le_div_iff_right a", "start": [109, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulLeft", "code": "@[to_additive (attr := simps! (config := { simpRhs := true }) toEquiv apply)\n  \"`Equiv.addLeft` as an `OrderIso`. See also `OrderEmbedding.addLeft`.\"]\ndef OrderIso.mulLeft (a : \u03b1) : \u03b1 \u2243o \u03b1 where\n  map_rel_iff' {_ _} := mul_le_mul_iff_left a\n  toEquiv := Equiv.mulLeft a", "start": [123, 1], "end": [128, 29], "kind": "commanddeclaration"}, {"full_name": "OrderIso.mulLeft_symm", "code": "@[to_additive (attr := simp)]\ntheorem OrderIso.mulLeft_symm (a : \u03b1) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a\u207b\u00b9", "start": [135, 1], "end": [138, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Abs.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Abs", "code": "class Abs (\u03b1 : Type*) where\n  \n  abs : \u03b1 \u2192 \u03b1", "start": [36, 1], "end": [41, 14], "kind": "commanddeclaration"}, {"full_name": "PosPart", "code": "class PosPart (\u03b1 : Type*) where\n  \n  pos : \u03b1 \u2192 \u03b1", "start": [47, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "NegPart", "code": "class NegPart (\u03b1 : Type*) where\n  \n  neg : \u03b1 \u2192 \u03b1", "start": [55, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "Abs.abs.unexpander", "code": "@[app_unexpander Abs.abs]\ndef Abs.abs.unexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $a) =>\n    match a with\n    | `(|$_|) | `(-$_) => `(|($a)|)\n    | _ => `(|$a|)\n  | _ => throw ()", "start": [66, 1], "end": [74, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharZero/Defs.lean", "imports": ["Mathlib/Algebra/NeZero.lean", "Mathlib/Tactic/Cases.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Lemmas.lean", "Mathlib/Tactic/NormCast/Tactic.lean", "Mathlib/Data/Int/Cast/Defs.lean"], "premises": [{"full_name": "CharZero", "code": "class CharZero (R) [AddMonoidWithOne R] : Prop where\n  \n  cast_injective : Function.Injective (Nat.cast : \u2115 \u2192 R)", "start": [35, 1], "end": [48, 57], "kind": "commanddeclaration"}, {"full_name": "charZero_of_inj_zero", "code": "theorem charZero_of_inj_zero [AddGroupWithOne R] (H : \u2200 n : \u2115, (n : R) = 0 \u2192 n = 0) :\n    CharZero R", "start": [51, 1], "end": [63, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_injective", "code": "theorem cast_injective : Function.Injective (Nat.cast : \u2115 \u2192 R)", "start": [70, 1], "end": [71, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_inj", "code": "@[simp, norm_cast]\ntheorem cast_inj {m n : \u2115} : (m : R) = n \u2194 m = n", "start": [74, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_eq_zero", "code": "@[simp, norm_cast]\ntheorem cast_eq_zero {n : \u2115} : (n : R) = 0 \u2194 n = 0", "start": [79, 1], "end": [80, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ne_zero", "code": "@[norm_cast]\ntheorem cast_ne_zero {n : \u2115} : (n : R) \u2260 0 \u2194 n \u2260 0", "start": [83, 1], "end": [85, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_add_one_ne_zero", "code": "theorem cast_add_one_ne_zero (n : \u2115) : (n + 1 : R) \u2260 0", "start": [88, 1], "end": [91, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_eq_one", "code": "@[simp, norm_cast]\ntheorem cast_eq_one {n : \u2115} : (n : R) = 1 \u2194 n = 1", "start": [94, 1], "end": [95, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ne_one", "code": "@[norm_cast]\ntheorem cast_ne_one {n : \u2115} : (n : R) \u2260 1 \u2194 n \u2260 1", "start": [98, 1], "end": [100, 18], "kind": "commanddeclaration"}, {"full_name": "OfNat.ofNat_ne_zero", "code": "@[simp] lemma ofNat_ne_zero (n : \u2115) [h : n.AtLeastTwo] : (no_index (ofNat n) : R) \u2260 0 :=\n  Nat.cast_ne_zero.2 <| ne_of_gt <| lt_trans Nat.one_pos h.prop", "start": [109, 1], "end": [110, 64], "kind": "mathlibtacticlemma"}, {"full_name": "OfNat.zero_ne_ofNat", "code": "@[simp] lemma zero_ne_ofNat (n : \u2115) [n.AtLeastTwo] : 0 \u2260 (no_index (ofNat n) : R) :=\n  (ofNat_ne_zero n).symm", "start": [112, 1], "end": [113, 25], "kind": "mathlibtacticlemma"}, {"full_name": "OfNat.ofNat_ne_one", "code": "@[simp] lemma ofNat_ne_one (n : \u2115) [h : n.AtLeastTwo] : (no_index (ofNat n) : R) \u2260 1 := by\n  rw [\u2190 Nat.cast_eq_ofNat, \u2190 @Nat.cast_one R, Ne.def, Nat.cast_inj]\n  exact ne_of_gt h.prop", "start": [115, 1], "end": [117, 24], "kind": "mathlibtacticlemma"}, {"full_name": "OfNat.one_ne_ofNat", "code": "@[simp] lemma one_ne_ofNat (n : \u2115) [n.AtLeastTwo] : (1 : R) \u2260 no_index (ofNat n) :=\n  (ofNat_ne_one n).symm", "start": [119, 1], "end": [120, 24], "kind": "mathlibtacticlemma"}, {"full_name": "OfNat.ofNat_eq_ofNat", "code": "@[simp] lemma ofNat_eq_ofNat {m n : \u2115} [m.AtLeastTwo] [n.AtLeastTwo] :\n    (no_index (ofNat m) : R) = no_index (ofNat n) \u2194 (ofNat m : \u2115) = ofNat n :=\n  Nat.cast_inj", "start": [122, 1], "end": [124, 15], "kind": "mathlibtacticlemma"}, {"full_name": "NeZero.charZero", "code": "instance charZero {M} {n : \u2115} [NeZero n] [AddMonoidWithOne M] [CharZero M] : NeZero (n : M) :=\n  \u27e8Nat.cast_ne_zero.mpr out\u27e9", "start": [130, 1], "end": [131, 29], "kind": "commanddeclaration"}, {"full_name": "NeZero.charZero_ofNat", "code": "instance charZero_ofNat {M} {n : \u2115} [n.AtLeastTwo] [AddMonoidWithOne M] [CharZero M] :\n    NeZero (OfNat.ofNat n : M) :=\n  \u27e8OfNat.ofNat_ne_zero n\u27e9", "start": [134, 1], "end": [136, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "Mathlib/Algebra/Opposites.lean"], "premises": [{"full_name": "AddHom.mulLeft", "code": "@[simps (config := { fullyApplied := false })]\ndef mulLeft [Distrib R] (r : R) : AddHom R R where\n  toFun := (\u00b7 * \u00b7) r\n  map_add' := mul_add r", "start": [31, 1], "end": [35, 24], "kind": "commanddeclaration"}, {"full_name": "AddHom.mulRight", "code": "@[simps (config := { fullyApplied := false })]\ndef mulRight [Distrib R] (r : R) : AddHom R R where\n  toFun a := a * r\n  map_add' _ _ := add_mul _ _ r", "start": [39, 1], "end": [43, 32], "kind": "commanddeclaration"}, {"full_name": "map_bit0", "code": "@[deprecated, simp]\ntheorem map_bit0 (f : F) (a : \u03b1) : (f (bit0 a) : \u03b2) = bit0 (f a)", "start": [54, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mulLeft", "code": "def mulLeft [NonUnitalNonAssocSemiring R] (r : R) : R \u2192+ R where\n  toFun := (r * \u00b7)\n  map_zero' := mul_zero r\n  map_add' := mul_add r", "start": [64, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_mulLeft", "code": "@[simp]\ntheorem coe_mulLeft [NonUnitalNonAssocSemiring R] (r : R) :\n    (mulLeft r : R \u2192 R) = HMul.hMul r", "start": [71, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mulRight", "code": "def mulRight [NonUnitalNonAssocSemiring R] (r : R) : R \u2192+ R where\n  toFun a := a * r\n  map_zero' := zero_mul r\n  map_add' _ _ := add_mul _ _ r", "start": [77, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_mulRight", "code": "@[simp]\ntheorem coe_mulRight [NonUnitalNonAssocSemiring R] (r : R) :\n    (mulRight r) = (\u00b7 * r)", "start": [84, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mulRight_apply", "code": "theorem mulRight_apply [NonUnitalNonAssocSemiring R] (a r : R) :\n    mulRight r a = a * r", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "hasDistribNeg", "code": "instance hasDistribNeg : HasDistribNeg \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.involutiveNeg _ with\n    neg_mul := fun _ _ => unop_injective <| mul_neg _ _,\n    mul_neg := fun _ _ => unop_injective <| neg_mul _ _ }", "start": [105, 1], "end": [108, 58], "kind": "commanddeclaration"}, {"full_name": "inv_neg'", "code": "@[simp]\ntheorem inv_neg' (a : \u03b1) : (-a)\u207b\u00b9 = -a\u207b\u00b9", "start": [116, 1], "end": [118, 79], "kind": "commanddeclaration"}, {"full_name": "vieta_formula_quadratic", "code": "theorem vieta_formula_quadratic {b c x : \u03b1} (h : x * x - b * x + c = 0) :\n    \u2203 y : \u03b1, y * y - b * y + c = 0 \u2227 x + y = b \u2227 x * y = c", "start": [131, 1], "end": [139, 42], "kind": "commanddeclaration"}, {"full_name": "succ_ne_self", "code": "theorem succ_ne_self [NonAssocRing \u03b1] [Nontrivial \u03b1] (a : \u03b1) : a + 1 \u2260 a", "start": [145, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "pred_ne_self", "code": "theorem pred_ne_self [NonAssocRing \u03b1] [Nontrivial \u03b1] (a : \u03b1) : a - 1 \u2260 a", "start": [149, 1], "end": [150, 84], "kind": "commanddeclaration"}, {"full_name": "IsLeftCancelMulZero.to_noZeroDivisors", "code": "lemma IsLeftCancelMulZero.to_noZeroDivisors [Ring \u03b1] [IsLeftCancelMulZero \u03b1] :\n    NoZeroDivisors \u03b1 :=\n  { eq_zero_or_eq_zero_of_mul_eq_zero := fun {x y} h \u21a6 by\n      by_cases hx : x = 0\n      { left\n        exact hx }\n      { right\n        rw [\u2190 sub_zero (x * y), \u2190 mul_zero x, \u2190 mul_sub] at h\n        have := (IsLeftCancelMulZero.mul_left_cancel_of_ne_zero) hx h\n        rwa [sub_zero] at this } }", "start": [157, 1], "end": [166, 35], "kind": "mathlibtacticlemma"}, {"full_name": "IsRightCancelMulZero.to_noZeroDivisors", "code": "lemma IsRightCancelMulZero.to_noZeroDivisors [Ring \u03b1] [IsRightCancelMulZero \u03b1] :\n    NoZeroDivisors \u03b1 :=\n  { eq_zero_or_eq_zero_of_mul_eq_zero := fun {x y} h \u21a6 by\n      by_cases hy : y = 0\n      { right\n        exact hy }\n      { left\n        rw [\u2190 sub_zero (x * y), \u2190 zero_mul y, \u2190 sub_mul] at h\n        have := (IsRightCancelMulZero.mul_right_cancel_of_ne_zero) hy h\n        rwa [sub_zero] at this } }", "start": [169, 1], "end": [178, 35], "kind": "mathlibtacticlemma"}, {"full_name": "NoZeroDivisors.to_isCancelMulZero", "code": "instance (priority := 100) NoZeroDivisors.to_isCancelMulZero [Ring \u03b1] [NoZeroDivisors \u03b1] :\n    IsCancelMulZero \u03b1 :=\n  { mul_left_cancel_of_ne_zero := fun ha h \u21a6 by\n      rw [\u2190 sub_eq_zero, \u2190 mul_sub] at h\n      exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_left ha)\n    mul_right_cancel_of_ne_zero := fun hb h \u21a6 by\n      rw [\u2190 sub_eq_zero, \u2190 sub_mul] at h\n      exact sub_eq_zero.1 ((eq_zero_or_eq_zero_of_mul_eq_zero h).resolve_right hb) }", "start": [181, 1], "end": [188, 85], "kind": "commanddeclaration"}, {"full_name": "NoZeroDivisors.to_isDomain", "code": "lemma NoZeroDivisors.to_isDomain [Ring \u03b1] [h : Nontrivial \u03b1] [NoZeroDivisors \u03b1] :\n    IsDomain \u03b1 :=\n  { NoZeroDivisors.to_isCancelMulZero \u03b1, h with .. }", "start": [191, 1], "end": [193, 53], "kind": "mathlibtacticlemma"}, {"full_name": "IsDomain.to_noZeroDivisors", "code": "instance (priority := 100) IsDomain.to_noZeroDivisors [Ring \u03b1] [IsDomain \u03b1] :\n    NoZeroDivisors \u03b1 :=\n  IsRightCancelMulZero.to_noZeroDivisors \u03b1", "start": [196, 1], "end": [198, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Basic.lean", "imports": ["Mathlib/Data/List/Defs.lean", "Mathlib/Init/Core.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/List/Instances.lean", "lake-packages/std/Std/Data/List/Lemmas.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "List.uniqueOfIsEmpty", "code": "instance uniqueOfIsEmpty [IsEmpty \u03b1] : Unique (List \u03b1) :=\n  { instInhabitedList with\n    uniq := fun l =>\n      match l with\n      | [] => rfl\n      | a :: _ => isEmptyElim a }", "start": [34, 1], "end": [40, 34], "kind": "commanddeclaration"}, {"full_name": "List.cons_injective", "code": "@[simp] theorem cons_injective {a : \u03b1} : Injective (cons a)", "start": [58, 1], "end": [58, 93], "kind": "commanddeclaration"}, {"full_name": "List.cons_eq_cons", "code": "theorem cons_eq_cons {a b : \u03b1} {l l' : List \u03b1} : a :: l = b :: l' \u2194 a = b \u2227 l = l'", "start": [63, 1], "end": [64, 44], "kind": "commanddeclaration"}, {"full_name": "List.singleton_injective", "code": "theorem singleton_injective : Injective fun a : \u03b1 => [a]", "start": [67, 1], "end": [67, 94], "kind": "commanddeclaration"}, {"full_name": "List.singleton_inj", "code": "theorem singleton_inj {a b : \u03b1} : [a] = [b] \u2194 a = b", "start": [70, 1], "end": [71, 29], "kind": "commanddeclaration"}, {"full_name": "List.set_of_mem_cons", "code": "theorem set_of_mem_cons (l : List \u03b1) (a : \u03b1) : { x | x \u2208 a :: l } = insert a { x | x \u2208 l }", "start": [76, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "Decidable.List.eq_or_ne_mem_of_mem", "code": "theorem _root_.Decidable.List.eq_or_ne_mem_of_mem [DecidableEq \u03b1]\n    {a b : \u03b1} {l : List \u03b1} (h : a \u2208 b :: l) : a = b \u2228 a \u2260 b \u2227 a \u2208 l", "start": [87, 1], "end": [91, 71], "kind": "commanddeclaration"}, {"full_name": "List.mem_pair", "code": "lemma mem_pair {a b c : \u03b1} : a \u2208 [b, c] \u2194 a = b \u2228 a = c := by\n  rw [mem_cons, mem_singleton]", "start": [100, 1], "end": [101, 31], "kind": "mathlibtacticlemma"}, {"full_name": "List.mem_split", "code": "theorem mem_split {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) : \u2203 s t : List \u03b1, l = s ++ a :: t", "start": [103, 1], "end": [107, 27], "kind": "commanddeclaration"}, {"full_name": "List.mem_map_of_injective", "code": "@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : \u03b1 \u2192 \u03b2} (H : Injective f) {a : \u03b1} {l : List \u03b1} :\n    f a \u2208 map f l \u2194 a \u2208 l", "start": [129, 1], "end": [132, 79], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.exists_mem_and_apply_eq_iff", "code": "@[simp]\ntheorem _root_.Function.Involutive.exists_mem_and_apply_eq_iff {f : \u03b1 \u2192 \u03b1}\n    (hf : Function.Involutive f) (x : \u03b1) (l : List \u03b1) : (\u2203 y : \u03b1, y \u2208 l \u2227 f y = x) \u2194 f x \u2208 l", "start": [135, 1], "end": [138, 63], "kind": "commanddeclaration"}, {"full_name": "List.mem_map_of_involutive", "code": "theorem mem_map_of_involutive {f : \u03b1 \u2192 \u03b1} (hf : Involutive f) {a : \u03b1} {l : List \u03b1} :\n    a \u2208 map f l \u2194 f a \u2208 l", "start": [141, 1], "end": [142, 77], "kind": "commanddeclaration"}, {"full_name": "List.map_bind", "code": "theorem map_bind (g : \u03b2 \u2192 List \u03b3) (f : \u03b1 \u2192 \u03b2) :\n    \u2200 l : List \u03b1, (List.map f l).bind g = l.bind fun a => g (f a)", "start": [166, 1], "end": [169, 65], "kind": "commanddeclaration"}, {"full_name": "List.ne_nil_of_length_pos", "code": "alias \u27e8ne_nil_of_length_pos, length_pos_of_ne_nil\u27e9 := length_pos", "start": [184, 1], "end": [184, 65], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.length_pos_of_ne_nil", "code": "alias \u27e8ne_nil_of_length_pos, length_pos_of_ne_nil\u27e9 := length_pos", "start": [184, 1], "end": [184, 65], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.length_pos_iff_ne_nil", "code": "theorem length_pos_iff_ne_nil {l : List \u03b1} : 0 < length l \u2194 l \u2260 []", "start": [188, 1], "end": [189, 47], "kind": "commanddeclaration"}, {"full_name": "List.exists_of_length_succ", "code": "theorem exists_of_length_succ {n} : \u2200 l : List \u03b1, l.length = n + 1 \u2192 \u2203 h t, l = h :: t", "start": [196, 1], "end": [198, 29], "kind": "commanddeclaration"}, {"full_name": "List.length_injective_iff", "code": "@[simp] lemma length_injective_iff : Injective (List.length : List \u03b1 \u2192 \u2115) \u2194 Subsingleton \u03b1 := by\n  constructor\n  \u00b7 intro h; refine \u27e8fun x y => ?_\u27e9; (suffices [x] = [y] by simpa using this); apply h; rfl\n  \u00b7 intros h\u03b1 l1 l2 hl\n    induction l1 generalizing l2 <;> cases l2\n    \u00b7 rfl\n    \u00b7 cases hl\n    \u00b7 cases hl\n    \u00b7 next ih _ _ =>\n      congr\n      \u00b7 exact Subsingleton.elim _ _\n      \u00b7 apply ih; simpa using hl", "start": [201, 1], "end": [212, 33], "kind": "mathlibtacticlemma"}, {"full_name": "List.length_injective", "code": "@[simp default+1] lemma length_injective [Subsingleton \u03b1] : Injective (length : List \u03b1 \u2192 \u2115) :=\n  length_injective_iff.mpr inferInstance", "start": [215, 1], "end": [217, 41], "kind": "mathlibtacticlemma"}, {"full_name": "List.length_eq_two", "code": "theorem length_eq_two {l : List \u03b1} : l.length = 2 \u2194 \u2203 a b, l = [a, b]", "start": [220, 1], "end": [221, 68], "kind": "commanddeclaration"}, {"full_name": "List.length_eq_three", "code": "theorem length_eq_three {l : List \u03b1} : l.length = 3 \u2194 \u2203 a b c, l = [a, b, c]", "start": [224, 1], "end": [225, 77], "kind": "commanddeclaration"}, {"full_name": "List.instSingletonList", "code": "instance instSingletonList : Singleton \u03b1 (List \u03b1) := \u27e8fun x => [x]\u27e9", "start": [233, 1], "end": [233, 68], "kind": "commanddeclaration"}, {"full_name": "List.singleton_eq", "code": "theorem singleton_eq (x : \u03b1) : ({x} : List \u03b1) = [x]", "start": [246, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "List.insert_neg", "code": "theorem insert_neg [DecidableEq \u03b1] {x : \u03b1} {l : List \u03b1} (h : x \u2209 l) : Insert.insert x l = x :: l", "start": [250, 1], "end": [251, 11], "kind": "commanddeclaration"}, {"full_name": "List.insert_pos", "code": "theorem insert_pos [DecidableEq \u03b1] {x : \u03b1} {l : List \u03b1} (h : x \u2208 l) : Insert.insert x l = l", "start": [254, 1], "end": [255, 11], "kind": "commanddeclaration"}, {"full_name": "List.doubleton_eq", "code": "theorem doubleton_eq [DecidableEq \u03b1] {x y : \u03b1} (h : x \u2260 y) : ({x, y} : List \u03b1) = [x, y]", "start": [258, 1], "end": [260, 36], "kind": "commanddeclaration"}, {"full_name": "List.forall_mem_of_forall_mem_cons", "code": "theorem forall_mem_of_forall_mem_cons {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1} (h : \u2200 x \u2208 a :: l, p x) :\n    \u2200 x \u2208 l, p x", "start": [269, 1], "end": [270, 44], "kind": "commanddeclaration"}, {"full_name": "List.not_exists_mem_nil", "code": "theorem not_exists_mem_nil (p : \u03b1 \u2192 Prop) : \u00ac\u2203 x \u2208 @nil \u03b1, p x", "start": [277, 1], "end": [278, 7], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_cons_of", "code": "theorem exists_mem_cons_of {p : \u03b1 \u2192 Prop} {a : \u03b1} (l : List \u03b1) (h : p a) : \u2203 x \u2208 a :: l, p x", "start": [282, 1], "end": [283, 28], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_cons_of_exists", "code": "theorem exists_mem_cons_of_exists {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1} : (\u2203 x \u2208 l, p x) \u2192\n    \u2203 x \u2208 a :: l, p x", "start": [287, 1], "end": [289, 51], "kind": "commanddeclaration"}, {"full_name": "List.or_exists_of_exists_mem_cons", "code": "theorem or_exists_of_exists_mem_cons {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : List \u03b1} : (\u2203 x \u2208 a :: l, p x) \u2192\n    p a \u2228 \u2203 x \u2208 l, p x", "start": [293, 1], "end": [297, 41], "kind": "commanddeclaration"}, {"full_name": "List.exists_mem_cons_iff", "code": "theorem exists_mem_cons_iff (p : \u03b1 \u2192 Prop) (a : \u03b1) (l : List \u03b1) :\n    (\u2203 x \u2208 a :: l, p x) \u2194 p a \u2228 \u2203 x \u2208 l, p x", "start": [300, 1], "end": [303, 63], "kind": "commanddeclaration"}, {"full_name": "List.subset_append_of_subset_right'", "code": "@[deprecated subset_append_of_subset_right]\ntheorem subset_append_of_subset_right' (l l\u2081 l\u2082 : List \u03b1) : l \u2286 l\u2082 \u2192 l \u2286 l\u2081 ++ l\u2082", "start": [315, 1], "end": [317, 34], "kind": "commanddeclaration"}, {"full_name": "List.cons_subset_of_subset_of_mem", "code": "theorem cons_subset_of_subset_of_mem {a : \u03b1} {l m : List \u03b1}\n    (ainm : a \u2208 m) (lsubm : l \u2286 m) : a::l \u2286 m", "start": [322, 1], "end": [324, 30], "kind": "commanddeclaration"}, {"full_name": "List.append_subset_of_subset_of_subset", "code": "theorem append_subset_of_subset_of_subset {l\u2081 l\u2082 l : List \u03b1} (l\u2081subl : l\u2081 \u2286 l) (l\u2082subl : l\u2082 \u2286 l) :\n    l\u2081 ++ l\u2082 \u2286 l", "start": [327, 1], "end": [329, 58], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_of_subset_nil", "code": "alias \u27e8eq_nil_of_subset_nil, _\u27e9 := subset_nil", "start": [335, 1], "end": [335, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.map_subset_iff", "code": "theorem map_subset_iff {l\u2081 l\u2082 : List \u03b1} (f : \u03b1 \u2192 \u03b2) (h : Injective f) :\n    map f l\u2081 \u2286 map f l\u2082 \u2194 l\u2081 \u2286 l\u2082", "start": [342, 1], "end": [346, 26], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_has_append", "code": "theorem append_eq_has_append {L\u2081 L\u2082 : List \u03b1} : List.append L\u2081 L\u2082 = L\u2081 ++ L\u2082", "start": [351, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "List.append_eq_cons_iff", "code": "theorem append_eq_cons_iff {a b c : List \u03b1} {x : \u03b1} :\n    a ++ b = x :: c \u2194 a = [] \u2227 b = x :: c \u2228 \u2203 a', a = x :: a' \u2227 c = a' ++ b", "start": [366, 1], "end": [370, 97], "kind": "commanddeclaration"}, {"full_name": "List.cons_eq_append_iff", "code": "theorem cons_eq_append_iff {a b c : List \u03b1} {x : \u03b1} :\n    (x :: c : List \u03b1) = a ++ b \u2194 a = [] \u2227 b = x :: c \u2228 \u2203 a', a = x :: a' \u2227 c = a' ++ b", "start": [373, 1], "end": [375, 35], "kind": "commanddeclaration"}, {"full_name": "List.append_left_cancel", "code": "theorem append_left_cancel {s t\u2081 t\u2082 : List \u03b1} (h : s ++ t\u2081 = s ++ t\u2082) : t\u2081 = t\u2082", "start": [394, 1], "end": [395, 27], "kind": "commanddeclaration"}, {"full_name": "List.append_right_cancel", "code": "theorem append_right_cancel {s\u2081 s\u2082 t : List \u03b1} (h : s\u2081 ++ t = s\u2082 ++ t) : s\u2081 = s\u2082", "start": [398, 1], "end": [399, 26], "kind": "commanddeclaration"}, {"full_name": "List.append_right_injective", "code": "theorem append_right_injective (s : List \u03b1) : Injective fun t \u21a6 s ++ t", "start": [402, 1], "end": [403, 31], "kind": "commanddeclaration"}, {"full_name": "List.append_left_injective", "code": "theorem append_left_injective (t : List \u03b1) : Injective fun s \u21a6 s ++ t", "start": [408, 1], "end": [409, 32], "kind": "commanddeclaration"}, {"full_name": "List.replicate_zero", "code": "@[simp] lemma replicate_zero (a : \u03b1) : replicate 0 a = [] := rfl", "start": [418, 1], "end": [418, 65], "kind": "mathlibtacticlemma"}, {"full_name": "List.replicate_one", "code": "lemma replicate_one (a : \u03b1) : replicate 1 a = [a] := rfl", "start": [424, 1], "end": [424, 57], "kind": "mathlibtacticlemma"}, {"full_name": "List.eq_replicate_length", "code": "theorem eq_replicate_length {a : \u03b1} : \u2200 {l : List \u03b1}, l = replicate l.length a \u2194 \u2200 b \u2208 l, b = a", "start": [431, 1], "end": [433, 46], "kind": "commanddeclaration"}, {"full_name": "List.replicate_add", "code": "theorem replicate_add (m n) (a : \u03b1) : replicate (m + n) a = replicate m a ++ replicate n a", "start": [440, 1], "end": [441, 58], "kind": "commanddeclaration"}, {"full_name": "List.replicate_succ'", "code": "theorem replicate_succ' (n) (a : \u03b1) : replicate (n + 1) a = replicate n a ++ [a]", "start": [444, 1], "end": [445, 22], "kind": "commanddeclaration"}, {"full_name": "List.replicate_subset_singleton", "code": "theorem replicate_subset_singleton (n) (a : \u03b1) : replicate n a \u2286 [a]", "start": [448, 1], "end": [449, 42], "kind": "commanddeclaration"}, {"full_name": "List.subset_singleton_iff", "code": "theorem subset_singleton_iff {a : \u03b1} {L : List \u03b1} : L \u2286 [a] \u2194 \u2203 n, L = replicate n a", "start": [452, 1], "end": [453, 71], "kind": "commanddeclaration"}, {"full_name": "List.map_replicate", "code": "@[simp] theorem map_replicate (f : \u03b1 \u2192 \u03b2) (n) (a : \u03b1) :\n    map f (replicate n a) = replicate n (f a)", "start": [456, 1], "end": [458, 55], "kind": "commanddeclaration"}, {"full_name": "List.tail_replicate", "code": "@[simp] theorem tail_replicate (a : \u03b1) (n) :\n    tail (replicate n a) = replicate (n - 1) a", "start": [461, 1], "end": [462, 69], "kind": "commanddeclaration"}, {"full_name": "List.join_replicate_nil", "code": "@[simp] theorem join_replicate_nil (n : \u2115) : join (replicate n []) = @nil \u03b1", "start": [465, 1], "end": [466, 68], "kind": "commanddeclaration"}, {"full_name": "List.replicate_right_injective", "code": "theorem replicate_right_injective {n : \u2115} (hn : n \u2260 0) : Injective (@replicate \u03b1 n)", "start": [469, 1], "end": [470, 67], "kind": "commanddeclaration"}, {"full_name": "List.replicate_right_inj", "code": "theorem replicate_right_inj {a b : \u03b1} {n : \u2115} (hn : n \u2260 0) :\n    replicate n a = replicate n b \u2194 a = b", "start": [473, 1], "end": [475, 40], "kind": "commanddeclaration"}, {"full_name": "List.replicate_right_inj'", "code": "@[simp] theorem replicate_right_inj' {a b : \u03b1} : \u2200 {n},\n    replicate n a = replicate n b \u2194 n = 0 \u2228 a = b", "start": [478, 1], "end": [481, 99], "kind": "commanddeclaration"}, {"full_name": "List.replicate_left_injective", "code": "theorem replicate_left_injective (a : \u03b1) : Injective (replicate \u00b7 a)", "start": [484, 1], "end": [485, 47], "kind": "commanddeclaration"}, {"full_name": "List.replicate_left_inj", "code": "@[simp] theorem replicate_left_inj {a : \u03b1} {n m : \u2115} : replicate n a = replicate m a \u2194 n = m", "start": [488, 1], "end": [489, 38], "kind": "commanddeclaration"}, {"full_name": "List.mem_pure", "code": "@[simp]\ntheorem mem_pure {\u03b1} (x y : \u03b1) : x \u2208 (pure y : List \u03b1) \u2194 x = y", "start": [494, 1], "end": [496, 31], "kind": "commanddeclaration"}, {"full_name": "List.bind_eq_bind", "code": "@[simp]\ntheorem bind_eq_bind {\u03b1 \u03b2} (f : \u03b1 \u2192 List \u03b2) (l : List \u03b1) : l >>= f = l.bind f", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "List.concat_nil", "code": "theorem concat_nil (a : \u03b1) : concat [] a = [a]", "start": [510, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "List.concat_cons", "code": "theorem concat_cons (a b : \u03b1) (l : List \u03b1) : concat (a :: l) b = a :: concat l b", "start": [514, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "List.concat_eq_append'", "code": "@[deprecated concat_eq_append]\ntheorem concat_eq_append' (a : \u03b1) (l : List \u03b1) : concat l a = l ++ [a]", "start": [518, 1], "end": [520, 23], "kind": "commanddeclaration"}, {"full_name": "List.init_eq_of_concat_eq", "code": "theorem init_eq_of_concat_eq {a : \u03b1} {l\u2081 l\u2082 : List \u03b1} : concat l\u2081 a = concat l\u2082 a \u2192 l\u2081 = l\u2082", "start": [523, 1], "end": [526, 30], "kind": "commanddeclaration"}, {"full_name": "List.last_eq_of_concat_eq", "code": "theorem last_eq_of_concat_eq {a b : \u03b1} {l : List \u03b1} : concat l a = concat l b \u2192 a = b", "start": [529, 1], "end": [532, 50], "kind": "commanddeclaration"}, {"full_name": "List.concat_ne_nil", "code": "theorem concat_ne_nil (a : \u03b1) (l : List \u03b1) : concat l a \u2260 []", "start": [535, 1], "end": [535, 72], "kind": "commanddeclaration"}, {"full_name": "List.concat_append", "code": "theorem concat_append (a : \u03b1) (l\u2081 l\u2082 : List \u03b1) : concat l\u2081 a ++ l\u2082 = l\u2081 ++ a :: l\u2082", "start": [538, 1], "end": [538, 94], "kind": "commanddeclaration"}, {"full_name": "List.length_concat'", "code": "@[deprecated length_concat]\ntheorem length_concat' (a : \u03b1) (l : List \u03b1) : length (concat l a) = succ (length l)", "start": [541, 1], "end": [543, 54], "kind": "commanddeclaration"}, {"full_name": "List.append_concat", "code": "theorem append_concat (a : \u03b1) (l\u2081 l\u2082 : List \u03b1) : l\u2081 ++ concat l\u2082 a = concat (l\u2081 ++ l\u2082) a", "start": [546, 1], "end": [546, 100], "kind": "commanddeclaration"}, {"full_name": "List.reverse_cons'", "code": "theorem reverse_cons' (a : \u03b1) (l : List \u03b1) : reverse (a :: l) = concat (reverse l) a", "start": [562, 1], "end": [563, 45], "kind": "commanddeclaration"}, {"full_name": "List.reverse_singleton", "code": "theorem reverse_singleton (a : \u03b1) : reverse [a] = [a]", "start": [568, 1], "end": [569, 6], "kind": "commanddeclaration"}, {"full_name": "List.reverse_involutive", "code": "@[simp]\ntheorem reverse_involutive : Involutive (@reverse \u03b1)", "start": [576, 1], "end": [578, 18], "kind": "commanddeclaration"}, {"full_name": "List.reverse_injective", "code": "@[simp]\ntheorem reverse_injective : Injective (@reverse \u03b1)", "start": [581, 1], "end": [583, 31], "kind": "commanddeclaration"}, {"full_name": "List.reverse_surjective", "code": "theorem reverse_surjective : Surjective (@reverse \u03b1)", "start": [586, 1], "end": [587, 32], "kind": "commanddeclaration"}, {"full_name": "List.reverse_bijective", "code": "theorem reverse_bijective : Bijective (@reverse \u03b1)", "start": [590, 1], "end": [591, 31], "kind": "commanddeclaration"}, {"full_name": "List.reverse_inj", "code": "@[simp]\ntheorem reverse_inj {l\u2081 l\u2082 : List \u03b1} : reverse l\u2081 = reverse l\u2082 \u2194 l\u2081 = l\u2082", "start": [594, 1], "end": [596, 27], "kind": "commanddeclaration"}, {"full_name": "List.reverse_eq_iff", "code": "theorem reverse_eq_iff {l l' : List \u03b1} : l.reverse = l' \u2194 l = l'.reverse", "start": [599, 1], "end": [600, 28], "kind": "commanddeclaration"}, {"full_name": "List.reverse_eq_nil", "code": "@[simp]\ntheorem reverse_eq_nil {l : List \u03b1} : reverse l = [] \u2194 l = []", "start": [603, 1], "end": [605, 22], "kind": "commanddeclaration"}, {"full_name": "List.concat_eq_reverse_cons", "code": "theorem concat_eq_reverse_cons (a : \u03b1) (l : List \u03b1) : concat l a = reverse (a :: reverse l)", "start": [608, 1], "end": [609, 62], "kind": "commanddeclaration"}, {"full_name": "List.map_reverse", "code": "theorem map_reverse (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map f (reverse l) = reverse (map f l)", "start": [618, 1], "end": [619, 25], "kind": "commanddeclaration"}, {"full_name": "List.map_reverseAux", "code": "theorem map_reverseAux (f : \u03b1 \u2192 \u03b2) (l\u2081 l\u2082 : List \u03b1) :\n    map f (reverseAux l\u2081 l\u2082) = reverseAux (map f l\u2081) (map f l\u2082)", "start": [622, 1], "end": [624, 53], "kind": "commanddeclaration"}, {"full_name": "List.reverse_replicate", "code": "@[simp] theorem reverse_replicate (n) (a : \u03b1) : reverse (replicate n a) = replicate n a", "start": [629, 1], "end": [632, 55], "kind": "commanddeclaration"}, {"full_name": "List.isEmpty_iff_eq_nil", "code": "theorem isEmpty_iff_eq_nil {l : List \u03b1} : l.isEmpty \u2194 l = []", "start": [640, 1], "end": [640, 94], "kind": "commanddeclaration"}, {"full_name": "List.length_dropLast", "code": "@[simp]\ntheorem length_dropLast : \u2200 l : List \u03b1, length l.dropLast = length l - 1", "start": [645, 1], "end": [651, 9], "kind": "commanddeclaration"}, {"full_name": "List.getLast_cons", "code": "@[simp]\ntheorem getLast_cons {a : \u03b1} {l : List \u03b1} :\n    \u2200 h : l \u2260 nil, getLast (a :: l) (cons_ne_nil a l) = getLast l h", "start": [656, 1], "end": [661, 6], "kind": "commanddeclaration"}, {"full_name": "List.getLast_append_singleton", "code": "theorem getLast_append_singleton {a : \u03b1} (l : List \u03b1) :\n    getLast (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a", "start": [664, 1], "end": [666, 29], "kind": "commanddeclaration"}, {"full_name": "List.getLast_append'", "code": "theorem getLast_append' (l\u2081 l\u2082 : List \u03b1) (h : l\u2082 \u2260 []) :\n    getLast (l\u2081 ++ l\u2082) (append_ne_nil_of_ne_nil_right l\u2081 l\u2082 h) = getLast l\u2082 h", "start": [670, 1], "end": [676, 13], "kind": "commanddeclaration"}, {"full_name": "List.getLast_concat'", "code": "theorem getLast_concat' {a : \u03b1} (l : List \u03b1) : getLast (concat l a) (concat_ne_nil a l) = a", "start": [679, 1], "end": [680, 20], "kind": "commanddeclaration"}, {"full_name": "List.getLast_singleton'", "code": "@[simp]\ntheorem getLast_singleton' (a : \u03b1) : getLast [a] (cons_ne_nil a []) = a", "start": [683, 1], "end": [684, 79], "kind": "commanddeclaration"}, {"full_name": "List.getLast_cons_cons", "code": "theorem getLast_cons_cons (a\u2081 a\u2082 : \u03b1) (l : List \u03b1) :\n    getLast (a\u2081 :: a\u2082 :: l) (cons_ne_nil _ _) = getLast (a\u2082 :: l) (cons_ne_nil a\u2082 l)", "start": [689, 1], "end": [691, 6], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_append_getLast", "code": "theorem dropLast_append_getLast : \u2200 {l : List \u03b1} (h : l \u2260 []), dropLast l ++ [getLast l h] = l", "start": [694, 1], "end": [700, 52], "kind": "commanddeclaration"}, {"full_name": "List.getLast_congr", "code": "theorem getLast_congr {l\u2081 l\u2082 : List \u03b1} (h\u2081 : l\u2081 \u2260 []) (h\u2082 : l\u2082 \u2260 []) (h\u2083 : l\u2081 = l\u2082) :\n    getLast l\u2081 h\u2081 = getLast l\u2082 h\u2082", "start": [703, 1], "end": [704, 54], "kind": "commanddeclaration"}, {"full_name": "List.getLast_mem", "code": "theorem getLast_mem : \u2200 {l : List \u03b1} (h : l \u2260 []), getLast l h \u2208 l", "start": [707, 1], "end": [713, 44], "kind": "commanddeclaration"}, {"full_name": "List.getLast_replicate_succ", "code": "theorem getLast_replicate_succ (m : \u2115) (a : \u03b1) :\n    (replicate (m + 1) a).getLast (ne_nil_of_length_eq_succ (length_replicate _ _)) = a", "start": [716, 1], "end": [719, 35], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_singleton", "code": "@[simp]\ntheorem getLast?_singleton (a : \u03b1) :\n    getLast? [a] = a", "start": [725, 1], "end": [727, 28], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_cons_cons", "code": "@[simp]\ntheorem getLast?_cons_cons (a b : \u03b1) (l : List \u03b1) :\n    getLast? (a :: b :: l) = getLast? (b :: l)", "start": [730, 1], "end": [732, 54], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_isNone", "code": "@[simp]\ntheorem getLast?_isNone : \u2200 {l : List \u03b1}, (getLast? l).isNone \u2194 l = []", "start": [734, 1], "end": [738, 55], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_isSome", "code": "@[simp]\ntheorem getLast?_isSome : \u2200 {l : List \u03b1}, l.getLast?.isSome \u2194 l \u2260 []", "start": [741, 1], "end": [745, 55], "kind": "commanddeclaration"}, {"full_name": "List.mem_getLast?_eq_getLast", "code": "theorem mem_getLast?_eq_getLast : \u2200 {l : List \u03b1} {x : \u03b1}, x \u2208 l.getLast? \u2192 \u2203 h, x = getLast l h", "start": [748, 1], "end": [757, 15], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_eq_getLast_of_ne_nil", "code": "theorem getLast?_eq_getLast_of_ne_nil : \u2200 {l : List \u03b1} (h : l \u2260 []), l.getLast? = some (l.getLast h)", "start": [760, 1], "end": [763, 80], "kind": "commanddeclaration"}, {"full_name": "List.mem_getLast?_cons", "code": "theorem mem_getLast?_cons {x y : \u03b1} : \u2200 {l : List \u03b1}, x \u2208 l.getLast? \u2192 x \u2208 (y :: l).getLast?", "start": [766, 1], "end": [768, 19], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_getLast?", "code": "theorem mem_of_mem_getLast? {l : List \u03b1} {a : \u03b1} (ha : a \u2208 l.getLast?) : a \u2208 l", "start": [771, 1], "end": [773, 26], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_append_getLast?", "code": "theorem dropLast_append_getLast? : \u2200 {l : List \u03b1}, \u2200 a \u2208 l.getLast?, dropLast l ++ [a] = l", "start": [776, 1], "end": [781, 68], "kind": "commanddeclaration"}, {"full_name": "List.getLastI_eq_getLast?", "code": "theorem getLastI_eq_getLast? [Inhabited \u03b1] : \u2200 l : List \u03b1, l.getLastI = l.getLast?.iget", "start": [784, 1], "end": [789, 74], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_append_cons", "code": "@[simp]\ntheorem getLast?_append_cons :\n    \u2200 (l\u2081 : List \u03b1) (a : \u03b1) (l\u2082 : List \u03b1), getLast? (l\u2081 ++ a :: l\u2082) = getLast? (a :: l\u2082)", "start": [792, 1], "end": [798, 51], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_append_of_ne_nil", "code": "theorem getLast?_append_of_ne_nil (l\u2081 : List \u03b1) :\n    \u2200 {l\u2082 : List \u03b1} (_ : l\u2082 \u2260 []), getLast? (l\u2081 ++ l\u2082) = getLast? l\u2082", "start": [803, 1], "end": [806, 47], "kind": "commanddeclaration"}, {"full_name": "List.getLast?_append", "code": "theorem getLast?_append {l\u2081 l\u2082 : List \u03b1} {x : \u03b1} (h : x \u2208 l\u2082.getLast?) :\n    x \u2208 (l\u2081 ++ l\u2082).getLast?", "start": [809, 1], "end": [814, 12], "kind": "commanddeclaration"}, {"full_name": "List.head!_eq_head?", "code": "theorem head!_eq_head? [Inhabited \u03b1] (l : List \u03b1) : head! l = (head? l).iget", "start": [819, 1], "end": [819, 99], "kind": "commanddeclaration"}, {"full_name": "List.surjective_head!", "code": "theorem surjective_head! [Inhabited \u03b1] : Surjective (@head! \u03b1 _)", "start": [822, 1], "end": [822, 88], "kind": "commanddeclaration"}, {"full_name": "List.surjective_head?", "code": "theorem surjective_head? : Surjective (@head? \u03b1)", "start": [825, 1], "end": [826, 51], "kind": "commanddeclaration"}, {"full_name": "List.surjective_tail", "code": "theorem surjective_tail : Surjective (@tail \u03b1)", "start": [829, 1], "end": [831, 33], "kind": "commanddeclaration"}, {"full_name": "List.eq_cons_of_mem_head?", "code": "theorem eq_cons_of_mem_head? {x : \u03b1} : \u2200 {l : List \u03b1}, x \u2208 l.head? \u2192 l = x :: tail l", "start": [834, 1], "end": [838, 18], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_head?", "code": "theorem mem_of_mem_head? {x : \u03b1} {l : List \u03b1} (h : x \u2208 l.head?) : x \u2208 l", "start": [841, 1], "end": [842, 52], "kind": "commanddeclaration"}, {"full_name": "List.head!_cons", "code": "@[simp] theorem head!_cons [Inhabited \u03b1] (a : \u03b1) (l : List \u03b1) : head! (a :: l) = a", "start": [845, 1], "end": [845, 90], "kind": "commanddeclaration"}, {"full_name": "List.head!_append", "code": "@[simp]\ntheorem head!_append [Inhabited \u03b1] (t : List \u03b1) {s : List \u03b1} (h : s \u2260 []) :\n    head! (s ++ t) = head! s", "start": [851, 1], "end": [853, 67], "kind": "commanddeclaration"}, {"full_name": "List.head?_append", "code": "theorem head?_append {s t : List \u03b1} {x : \u03b1} (h : x \u2208 s.head?) : x \u2208 (s ++ t).head?", "start": [856, 1], "end": [857, 34], "kind": "commanddeclaration"}, {"full_name": "List.head?_append_of_ne_nil", "code": "theorem head?_append_of_ne_nil :\n    \u2200 (l\u2081 : List \u03b1) {l\u2082 : List \u03b1} (_ : l\u2081 \u2260 []), head? (l\u2081 ++ l\u2082) = head? l\u2081", "start": [860, 1], "end": [862, 24], "kind": "commanddeclaration"}, {"full_name": "List.tail_append_singleton_of_ne_nil", "code": "theorem tail_append_singleton_of_ne_nil {a : \u03b1} {l : List \u03b1} (h : l \u2260 nil) :\n    tail (l ++ [a]) = tail l ++ [a]", "start": [865, 1], "end": [867, 59], "kind": "commanddeclaration"}, {"full_name": "List.cons_head?_tail", "code": "theorem cons_head?_tail : \u2200 {l : List \u03b1} {a : \u03b1}, a \u2208 head? l \u2192 a :: tail l = l", "start": [870, 1], "end": [874, 13], "kind": "commanddeclaration"}, {"full_name": "List.head!_mem_head?", "code": "theorem head!_mem_head? [Inhabited \u03b1] : \u2200 {l : List \u03b1}, l \u2260 [] \u2192 head! l \u2208 head? l", "start": [877, 1], "end": [879, 21], "kind": "commanddeclaration"}, {"full_name": "List.cons_head!_tail", "code": "theorem cons_head!_tail [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 []) : head! l :: tail l = l", "start": [882, 1], "end": [883, 38], "kind": "commanddeclaration"}, {"full_name": "List.head!_mem_self", "code": "theorem head!_mem_self [Inhabited \u03b1] {l : List \u03b1} (h : l \u2260 nil) : l.head! \u2208 l", "start": [886, 1], "end": [888, 32], "kind": "commanddeclaration"}, {"full_name": "List.head_mem", "code": "theorem head_mem {l : List \u03b1} : \u2200 (h : l \u2260 nil), l.head h \u2208 l", "start": [891, 1], "end": [892, 19], "kind": "commanddeclaration"}, {"full_name": "List.head?_map", "code": "@[simp]\ntheorem head?_map (f : \u03b1 \u2192 \u03b2) (l) : head? (map f l) = (head? l).map f", "start": [894, 1], "end": [895, 92], "kind": "commanddeclaration"}, {"full_name": "List.tail_append_of_ne_nil", "code": "theorem tail_append_of_ne_nil (l l' : List \u03b1) (h : l \u2260 []) : (l ++ l').tail = l.tail ++ l'", "start": [898, 1], "end": [901, 9], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_tail", "code": "@[simp] theorem nthLe_tail (l : List \u03b1) (i) (h : i < l.tail.length)\n    (h' : i + 1 < l.length := (by simpa [\u2190 lt_tsub_iff_right] using h)) :\n    l.tail.nthLe i h = l.nthLe (i + 1) h'", "start": [907, 1], "end": [913, 8], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_cons_aux", "code": "theorem nthLe_cons_aux {l : List \u03b1} {a : \u03b1} {n} (hn : n \u2260 0) (h : n < (a :: l).length) :\n    n - 1 < l.length", "start": [916, 1], "end": [921, 49], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_cons", "code": "theorem nthLe_cons {l : List \u03b1} {a : \u03b1} {n} (hl) :\n    (a :: l).nthLe n hl = if hn : n = 0 then a else l.nthLe (n - 1) (nthLe_cons_aux hn hl)", "start": [924, 1], "end": [933, 6], "kind": "commanddeclaration"}, {"full_name": "List.modifyHead_modifyHead", "code": "@[simp 1100, nolint simpNF]\ntheorem modifyHead_modifyHead (l : List \u03b1) (f g : \u03b1 \u2192 \u03b1) :\n    (l.modifyHead f).modifyHead g = l.modifyHead (g \u2218 f)", "start": [943, 1], "end": [945, 80], "kind": "commanddeclaration"}, {"full_name": "List.reverseRecOn", "code": "@[elab_as_elim]\ndef reverseRecOn {C : List \u03b1 \u2192 Sort*} (l : List \u03b1) (H0 : C [])\n    (H1 : \u2200 (l : List \u03b1) (a : \u03b1), C l \u2192 C (l ++ [a])) : C l := by\n  rw [\u2190 reverse_reverse l]\n  match h:(reverse l) with\n  | [] => exact H0\n  | head :: tail =>\n    have : tail.length < l.length := by\n      rw [\u2190 length_reverse l, h, length_cons]\n      simp [Nat.lt_succ]\n    let ih := reverseRecOn (reverse tail) H0 H1\n    rw [reverse_cons]\n    exact H1 _ _ ih\ntermination_by _ _ l _ _ => l.length", "start": [950, 1], "end": [966, 37], "kind": "commanddeclaration"}, {"full_name": "List.bidirectionalRec", "code": "def bidirectionalRec {C : List \u03b1 \u2192 Sort*} (H0 : C []) (H1 : \u2200 a : \u03b1, C [a])\n    (Hn : \u2200 (a : \u03b1) (l : List \u03b1) (b : \u03b1), C l \u2192 C (a :: (l ++ [b]))) : \u2200 l, C l\n  | [] => H0\n  | [a] => H1 a\n  | a :: b :: l => by\n    let l' := dropLast (b :: l)\n    let b' := getLast (b :: l) (cons_ne_nil _ _)\n    rw [\u2190 dropLast_append_getLast (cons_ne_nil b l)]\n    have : C l' := bidirectionalRec H0 H1 Hn l'\n    exact Hn a l' b' this\ntermination_by _ l => l.length", "start": [969, 1], "end": [983, 31], "kind": "commanddeclaration"}, {"full_name": "List.bidirectionalRecOn", "code": "@[elab_as_elim]\ndef bidirectionalRecOn {C : List \u03b1 \u2192 Sort*} (l : List \u03b1) (H0 : C []) (H1 : \u2200 a : \u03b1, C [a])\n    (Hn : \u2200 (a : \u03b1) (l : List \u03b1) (b : \u03b1), C l \u2192 C (a :: (l ++ [b]))) : C l :=\n  bidirectionalRec H0 H1 Hn l", "start": [986, 1], "end": [990, 30], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.cons_cons", "code": "theorem Sublist.cons_cons {l\u2081 l\u2082 : List \u03b1} (a : \u03b1) (s : l\u2081 <+ l\u2082) : a :: l\u2081 <+ a :: l\u2082", "start": [1003, 1], "end": [1004, 20], "kind": "commanddeclaration"}, {"full_name": "List.sublist_cons_of_sublist", "code": "theorem sublist_cons_of_sublist (a : \u03b1) {l\u2081 l\u2082 : List \u03b1} : l\u2081 <+ l\u2082 \u2192 l\u2081 <+ a :: l\u2082", "start": [1010, 1], "end": [1011, 17], "kind": "commanddeclaration"}, {"full_name": "List.sublist_of_cons_sublist_cons", "code": "theorem sublist_of_cons_sublist_cons {l\u2081 l\u2082 : List \u03b1} : \u2200 {a : \u03b1}, a :: l\u2081 <+ a :: l\u2082 \u2192 l\u2081 <+ l\u2082", "start": [1017, 1], "end": [1019, 30], "kind": "commanddeclaration"}, {"full_name": "List.cons_sublist_cons_iff", "code": "theorem cons_sublist_cons_iff {l\u2081 l\u2082 : List \u03b1} {a : \u03b1} : a :: l\u2081 <+ a :: l\u2082 \u2194 l\u2081 <+ l\u2082", "start": [1022, 1], "end": [1023, 54], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_of_sublist_nil", "code": "theorem eq_nil_of_sublist_nil {l : List \u03b1} (s : l <+ []) : l = []", "start": [1039, 1], "end": [1040, 35], "kind": "commanddeclaration"}, {"full_name": "List.sublist_nil_iff_eq_nil", "code": "alias sublist_nil_iff_eq_nil := sublist_nil", "start": [1044, 1], "end": [1044, 44], "kind": "stdtacticaliasalias"}, {"full_name": "List.sublist_replicate_iff", "code": "theorem sublist_replicate_iff {l : List \u03b1} {a : \u03b1} {n : \u2115} :\n    l <+ replicate n a \u2194 \u2203 k \u2264 n, l = replicate k a", "start": [1049, 1], "end": [1054, 72], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.antisymm", "code": "theorem Sublist.antisymm (s\u2081 : l\u2081 <+ l\u2082) (s\u2082 : l\u2082 <+ l\u2081) : l\u2081 = l\u2082", "start": [1061, 1], "end": [1062, 34], "kind": "commanddeclaration"}, {"full_name": "List.decidableSublist", "code": "instance decidableSublist [DecidableEq \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, Decidable (l\u2081 <+ l\u2082)\n  | [], _ => isTrue <| nil_sublist _\n  | _ :: _, [] => isFalse fun h => List.noConfusion <| eq_nil_of_sublist_nil h\n  | a :: l\u2081, b :: l\u2082 =>\n    if h : a = b then\n      @decidable_of_decidable_of_iff _ _ (decidableSublist l\u2081 l\u2082) <|\n        h \u25b8 \u27e8Sublist.cons_cons _, sublist_of_cons_sublist_cons\u27e9\n    else\n      @decidable_of_decidable_of_iff _ _ (decidableSublist (a :: l\u2081) l\u2082)\n        \u27e8sublist_cons_of_sublist _, fun s =>\n          match a, l\u2081, s, h with\n          | _, _, Sublist.cons _ s', h => s'\n          | _, _, Sublist.cons\u2082 t _, h => absurd rfl h\u27e9", "start": [1065, 1], "end": [1077, 56], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_nil", "code": "theorem indexOf_nil (a : \u03b1) : indexOf a [] = 0", "start": [1088, 1], "end": [1089, 6], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_cons_self", "code": "@[simp]\ntheorem indexOf_cons_self (a : \u03b1) (l : List \u03b1) : indexOf a (a :: l) = 0", "start": [1104, 1], "end": [1106, 53], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_cons_eq", "code": "theorem indexOf_cons_eq {a b : \u03b1} (l : List \u03b1) : a = b \u2192 indexOf a (b :: l) = 0", "start": [1110, 1], "end": [1111, 48], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_cons_ne", "code": "@[simp]\ntheorem indexOf_cons_ne {a b : \u03b1} (l : List \u03b1) : a \u2260 b \u2192 indexOf a (b :: l) = succ (indexOf a l)", "start": [1115, 1], "end": [1117, 90], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_cons", "code": "theorem indexOf_cons (a b : \u03b1) (l : List \u03b1) :\n    indexOf a (b :: l) = if a = b then 0 else succ (indexOf a l)", "start": [1121, 1], "end": [1123, 66], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_eq_length", "code": "theorem indexOf_eq_length {a : \u03b1} {l : List \u03b1} : indexOf a l = length l \u2194 a \u2209 l", "start": [1126, 1], "end": [1133, 20], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_of_not_mem", "code": "@[simp]\ntheorem indexOf_of_not_mem {l : List \u03b1} {a : \u03b1} : a \u2209 l \u2192 indexOf a l = length l", "start": [1136, 1], "end": [1138, 22], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_le_length", "code": "theorem indexOf_le_length {a : \u03b1} {l : List \u03b1} : indexOf a l \u2264 length l", "start": [1141, 1], "end": [1146, 41], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_lt_length", "code": "theorem indexOf_lt_length {a} {l : List \u03b1} : indexOf a l < length l \u2194 a \u2208 l", "start": [1149, 1], "end": [1151, 83], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_append_of_mem", "code": "theorem indexOf_append_of_mem {a : \u03b1} (h : a \u2208 l\u2081) : indexOf a (l\u2081 ++ l\u2082) = indexOf a l\u2081", "start": [1154, 1], "end": [1161, 78], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_append_of_not_mem", "code": "theorem indexOf_append_of_not_mem {a : \u03b1} (h : a \u2209 l\u2081) :\n    indexOf a (l\u2081 ++ l\u2082) = l\u2081.length + indexOf a l\u2082", "start": [1164, 1], "end": [1169, 50], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_of_mem", "code": "@[deprecated get_of_mem]\ntheorem nthLe_of_mem {a} {l : List \u03b1} (h : a \u2208 l) : \u2203 n h, nthLe l n h = a", "start": [1179, 1], "end": [1181, 44], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_get?", "code": "@[deprecated get?_eq_get]\ntheorem nthLe_get? {l : List \u03b1} {n} (h) : get? l n = some (nthLe l n h)", "start": [1184, 1], "end": [1185, 89], "kind": "commanddeclaration"}, {"full_name": "List.get?_length", "code": "@[simp]\ntheorem get?_length (l : List \u03b1) : l.get? l.length = none", "start": [1190, 1], "end": [1191, 80], "kind": "commanddeclaration"}, {"full_name": "List.get?_eq_some'", "code": "@[deprecated get?_eq_some]\ntheorem get?_eq_some' {l : List \u03b1} {n a} : get? l n = some a \u2194 \u2203 h, nthLe l n h = a", "start": [1194, 1], "end": [1195, 100], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_mem", "code": "@[deprecated get_mem]\ntheorem nthLe_mem (l : List \u03b1) (n h) : nthLe l n h \u2208 l", "start": [1201, 1], "end": [1202, 69], "kind": "commanddeclaration"}, {"full_name": "List.mem_iff_nthLe", "code": "@[deprecated mem_iff_get]\ntheorem mem_iff_nthLe {a} {l : List \u03b1} : a \u2208 l \u2194 \u2203 n h, nthLe l n h = a", "start": [1207, 1], "end": [1209, 81], "kind": "commanddeclaration"}, {"full_name": "List.get?_injective", "code": "theorem get?_injective {\u03b1 : Type u} {xs : List \u03b1} {i j : \u2115} (h\u2080 : i < xs.length) (h\u2081 : Nodup xs)\n    (h\u2082 : xs.get? i = xs.get? j) : i = j", "start": [1216, 1], "end": [1228, 49], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_map", "code": "@[deprecated get_map]\ntheorem nthLe_map (f : \u03b1 \u2192 \u03b2) {l n} (H1 H2) : nthLe (map f l) n H1 = f (nthLe l n H2)", "start": [1233, 1], "end": [1234, 100], "kind": "commanddeclaration"}, {"full_name": "List.get_map_rev", "code": "theorem get_map_rev (f : \u03b1 \u2192 \u03b2) {l n} :\n    f (get l n) = get (map f l) \u27e8n.1, (l.length_map f).symm \u25b8 n.2\u27e9", "start": [1237, 1], "end": [1239, 90], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_map_rev", "code": "@[deprecated get_map_rev]\ntheorem nthLe_map_rev (f : \u03b1 \u2192 \u03b2) {l n} (H) :\n    f (nthLe l n H) = nthLe (map f l) n ((l.length_map f).symm \u25b8 H)", "start": [1241, 1], "end": [1245, 25], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_map'", "code": "@[simp, deprecated get_map]\ntheorem nthLe_map' (f : \u03b1 \u2192 \u03b2) {l n} (H) :\n    nthLe (map f l) n H = f (nthLe l n (l.length_map f \u25b8 H))", "start": [1248, 1], "end": [1250, 80], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_of_eq", "code": "@[deprecated get_of_eq]\ntheorem nthLe_of_eq {L L' : List \u03b1} (h : L = L') {i : \u2115} (hi : i < L.length) :\n    nthLe L i hi = nthLe L' i (h \u25b8 hi)", "start": [1253, 1], "end": [1258, 51], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_singleton", "code": "@[simp, deprecated get_singleton]\ntheorem nthLe_singleton (a : \u03b1) {n : \u2115} (hn : n < 1) : nthLe [a] n hn = a", "start": [1261, 1], "end": [1262, 94], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_zero", "code": "@[deprecated] theorem nthLe_zero [Inhabited \u03b1] {L : List \u03b1} (h : 0 < L.length) : List.nthLe L 0 h = L.head!", "start": [1265, 1], "end": [1269, 15], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_append", "code": "@[deprecated get_append]\ntheorem nthLe_append {l\u2081 l\u2082 : List \u03b1} {n : \u2115} (hn\u2081) (hn\u2082) :\n    (l\u2081 ++ l\u2082).nthLe n hn\u2081 = l\u2081.nthLe n hn\u2082", "start": [1272, 1], "end": [1274, 64], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_append_right", "code": "@[deprecated get_append_right']\ntheorem nthLe_append_right {l\u2081 l\u2082 : List \u03b1} {n : \u2115} (h\u2081 : l\u2081.length \u2264 n) (h\u2082) :\n    (l\u2081 ++ l\u2082).nthLe n h\u2082 = l\u2082.nthLe (n - l\u2081.length) (get_append_right_aux h\u2081 h\u2082)", "start": [1277, 1], "end": [1280, 26], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_replicate", "code": "@[deprecated get_replicate]\ntheorem nthLe_replicate (a : \u03b1) {n m : \u2115} (h : m < (replicate n a).length) :\n    (replicate n a).nthLe m h = a", "start": [1284, 1], "end": [1286, 54], "kind": "commanddeclaration"}, {"full_name": "List.getLast_eq_nthLe", "code": "@[deprecated getLast_eq_get]\ntheorem getLast_eq_nthLe (l : List \u03b1) (h : l \u2260 []) :\n    getLast l h = l.nthLe (l.length - 1) (Nat.sub_lt (length_pos_of_ne_nil h) one_pos)", "start": [1292, 1], "end": [1295, 20], "kind": "commanddeclaration"}, {"full_name": "List.get_length_sub_one", "code": "theorem get_length_sub_one {l : List \u03b1} (h : l.length - 1 < l.length) :\n    l.get \u27e8l.length - 1, h\u27e9 = l.getLast (by rintro rfl; exact Nat.lt_irrefl 0 h)", "start": [1298, 1], "end": [1300, 28], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_length_sub_one", "code": "@[deprecated get_length_sub_one]\ntheorem nthLe_length_sub_one {l : List \u03b1} (h : l.length - 1 < l.length) :\n    l.nthLe (l.length - 1) h = l.getLast (by rintro rfl; exact Nat.lt_irrefl 0 h)", "start": [1302, 1], "end": [1305, 23], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_cons_length", "code": "@[deprecated get_cons_length]\ntheorem nthLe_cons_length : \u2200 (x : \u03b1) (xs : List \u03b1) (n : \u2115) (h : n = xs.length),\n    (x :: xs).nthLe n (by simp [h]) = (x :: xs).getLast (cons_ne_nil x xs)", "start": [1310, 1], "end": [1312, 94], "kind": "commanddeclaration"}, {"full_name": "List.take_one_drop_eq_of_lt_length", "code": "theorem take_one_drop_eq_of_lt_length {l : List \u03b1} {n : \u2115} (h : n < l.length) :\n    (l.drop n).take 1 = [l.get \u27e8n, h\u27e9]", "start": [1315, 1], "end": [1330, 13], "kind": "commanddeclaration"}, {"full_name": "List.take_one_drop_eq_of_lt_length'", "code": "@[deprecated take_one_drop_eq_of_lt_length]\ntheorem take_one_drop_eq_of_lt_length' {l : List \u03b1} {n : \u2115} (h : n < l.length) :\n    (l.drop n).take 1 = [l.nthLe n h]", "start": [1332, 1], "end": [1334, 73], "kind": "commanddeclaration"}, {"full_name": "List.ext_nthLe", "code": "@[deprecated ext_get]\ntheorem ext_nthLe {l\u2081 l\u2082 : List \u03b1} (hl : length l\u2081 = length l\u2082)\n    (h : \u2200 n h\u2081 h\u2082, nthLe l\u2081 n h\u2081 = nthLe l\u2082 n h\u2082) : l\u2081 = l\u2082", "start": [1339, 1], "end": [1342, 15], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_get", "code": "@[simp]\ntheorem indexOf_get [DecidableEq \u03b1] {a : \u03b1} : \u2200 {l : List \u03b1} (h), get l \u27e8indexOf a l, h\u27e9 = a", "start": [1345, 1], "end": [1349, 78], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_nthLe", "code": "@[simp, deprecated indexOf_get]\ntheorem indexOf_nthLe [DecidableEq \u03b1] {a : \u03b1} : \u2200 {l : List \u03b1} (h), nthLe l (indexOf a l) h = a", "start": [1351, 1], "end": [1353, 14], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_get?", "code": "@[simp]\ntheorem indexOf_get? [DecidableEq \u03b1] {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) :\n    get? l (indexOf a l) = some a", "start": [1356, 1], "end": [1358, 95], "kind": "commanddeclaration"}, {"full_name": "List.get_reverse_aux\u2081", "code": "@[deprecated]\ntheorem get_reverse_aux\u2081 :\n    \u2200 (l r : List \u03b1) (i h1 h2), get (reverseAux l r) \u27e8i + length l, h1\u27e9 = get r \u27e8i, h2\u27e9", "start": [1361, 1], "end": [1367, 80], "kind": "commanddeclaration"}, {"full_name": "List.indexOf_inj", "code": "theorem indexOf_inj [DecidableEq \u03b1] {l : List \u03b1} {x y : \u03b1} (hx : x \u2208 l) (hy : y \u2208 l) :\n    indexOf x l = indexOf y l \u2194 x = y", "start": [1370, 1], "end": [1377, 79], "kind": "commanddeclaration"}, {"full_name": "List.get_reverse_aux\u2082", "code": "theorem get_reverse_aux\u2082 :\n    \u2200 (l r : List \u03b1) (i : Nat) (h1) (h2),\n      get (reverseAux l r) \u27e8length l - 1 - i, h1\u27e9 = get l \u27e8i, h2\u27e9", "start": [1380, 1], "end": [1395, 14], "kind": "commanddeclaration"}, {"full_name": "List.get_reverse", "code": "@[simp] theorem get_reverse (l : List \u03b1) (i : Nat) (h1 h2) :\n    get (reverse l) \u27e8length l - 1 - i, h1\u27e9 = get l \u27e8i, h2\u27e9", "start": [1398, 1], "end": [1400, 29], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_reverse", "code": "@[simp, deprecated get_reverse]\ntheorem nthLe_reverse (l : List \u03b1) (i : Nat) (h1 h2) :\n    nthLe (reverse l) (length l - 1 - i) h1 = nthLe l i h2", "start": [1402, 1], "end": [1405, 17], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_reverse'", "code": "theorem nthLe_reverse' (l : List \u03b1) (n : \u2115) (hn : n < l.reverse.length) (hn') :\n    l.reverse.nthLe n hn = l.nthLe (l.length - 1 - n) hn'", "start": [1408, 1], "end": [1412, 7], "kind": "commanddeclaration"}, {"full_name": "List.get_reverse'", "code": "theorem get_reverse' (l : List \u03b1) (n) (hn') :\n    l.reverse.get n = l.get \u27e8l.length - 1 - n, hn'\u27e9", "start": [1415, 1], "end": [1416, 73], "kind": "commanddeclaration"}, {"full_name": "List.eq_cons_of_length_one", "code": "theorem eq_cons_of_length_one {l : List \u03b1} (h : l.length = 1) :\n    l = [l.nthLe 0 (h.symm \u25b8 zero_lt_one)]", "start": [1421, 1], "end": [1426, 47], "kind": "commanddeclaration"}, {"full_name": "List.get_eq_iff", "code": "theorem get_eq_iff {l : List \u03b1} {n : Fin l.length} {x : \u03b1} : l.get n = x \u2194 l.get? n.1 = some x", "start": [1429, 1], "end": [1431, 13], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_eq_iff", "code": "@[deprecated get_eq_iff]\ntheorem nthLe_eq_iff {l : List \u03b1} {n : \u2115} {x : \u03b1} {h} : l.nthLe n h = x \u2194 l.get? n = some x", "start": [1433, 1], "end": [1435, 13], "kind": "commanddeclaration"}, {"full_name": "List.some_nthLe_eq", "code": "@[deprecated get?_eq_get]\ntheorem some_nthLe_eq {l : List \u03b1} {n : \u2115} {h} : some (l.nthLe n h) = l.get? n", "start": [1438, 1], "end": [1440, 23], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_modifyNthTail", "code": "theorem modifyNthTail_modifyNthTail {f g : List \u03b1 \u2192 List \u03b1} (m : \u2115) :\n    \u2200 (n) (l : List \u03b1),\n      (l.modifyNthTail f n).modifyNthTail g (m + n) =\n        l.modifyNthTail (fun l => (f l).modifyNthTail g m) n", "start": [1445, 1], "end": [1451, 81], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_modifyNthTail_le", "code": "theorem modifyNthTail_modifyNthTail_le {f g : List \u03b1 \u2192 List \u03b1} (m n : \u2115) (l : List \u03b1)\n    (h : n \u2264 m) :\n    (l.modifyNthTail f n).modifyNthTail g m =\n      l.modifyNthTail (fun l => (f l).modifyNthTail g (m - n)) n", "start": [1454, 1], "end": [1459, 68], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_modifyNthTail_same", "code": "theorem modifyNthTail_modifyNthTail_same {f g : List \u03b1 \u2192 List \u03b1} (n : \u2115) (l : List \u03b1) :\n    (l.modifyNthTail f n).modifyNthTail g n = l.modifyNthTail (g \u2218 f) n", "start": [1462, 1], "end": [1464, 72], "kind": "commanddeclaration"}, {"full_name": "List.removeNth_eq_nthTail", "code": "theorem removeNth_eq_nthTail : \u2200 (n) (l : List \u03b1), removeNth l n = modifyNthTail tail n l", "start": [1469, 1], "end": [1472, 67], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_set", "code": "theorem modifyNth_eq_set (f : \u03b1 \u2192 \u03b1) :\n    \u2200 (n) (l : List \u03b1), modifyNth f n l = ((fun a => set l n (f a)) <$> get? l n).getD l", "start": [1477, 1], "end": [1482, 85], "kind": "commanddeclaration"}, {"full_name": "List.length_modifyNthTail", "code": "theorem length_modifyNthTail (f : List \u03b1 \u2192 List \u03b1) (H : \u2200 l, length (f l) = length l) :\n    \u2200 n l, length (modifyNthTail f n l) = length l", "start": [1487, 1], "end": [1491, 79], "kind": "commanddeclaration"}, {"full_name": "List.length_modifyNth", "code": "theorem length_modifyNth (f : \u03b1 \u2192 \u03b1) : \u2200 n l, length (modifyNth f n l) = length l", "start": [1497, 1], "end": [1498, 23], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_set_eq", "code": "@[simp, deprecated get_set_eq]\ntheorem nthLe_set_eq (l : List \u03b1) (i : \u2115) (a : \u03b1) (h : i < (l.set i a).length) :\n    (l.set i a).nthLe i h = a", "start": [1512, 1], "end": [1514, 47], "kind": "commanddeclaration"}, {"full_name": "List.get_set_of_ne", "code": "@[simp]\ntheorem get_set_of_ne {l : List \u03b1} {i j : \u2115} (h : i \u2260 j) (a : \u03b1)\n    (hj : j < (l.set i a).length) :\n    (l.set i a).get \u27e8j, hj\u27e9 = l.get \u27e8j, by simpa using hj\u27e9", "start": [1517, 1], "end": [1521, 87], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_set_of_ne", "code": "@[simp, deprecated get_set_of_ne]\ntheorem nthLe_set_of_ne {l : List \u03b1} {i j : \u2115} (h : i \u2260 j) (a : \u03b1)\n    (hj : j < (l.set i a).length) :\n    (l.set i a).nthLe j hj = l.nthLe j (by simpa using hj)", "start": [1523, 1], "end": [1527, 23], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_zero", "code": "@[simp]\ntheorem insertNth_zero (s : List \u03b1) (x : \u03b1) : insertNth 0 x s = x :: s", "start": [1536, 1], "end": [1538, 6], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_succ_nil", "code": "@[simp]\ntheorem insertNth_succ_nil (n : \u2115) (a : \u03b1) : insertNth (n + 1) a [] = []", "start": [1541, 1], "end": [1543, 6], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_succ_cons", "code": "@[simp]\ntheorem insertNth_succ_cons (s : List \u03b1) (hd x : \u03b1) (n : \u2115) :\n    insertNth (n + 1) x (hd :: s) = hd :: insertNth n x s", "start": [1546, 1], "end": [1549, 6], "kind": "commanddeclaration"}, {"full_name": "List.length_insertNth", "code": "theorem length_insertNth : \u2200 n as, n \u2264 length as \u2192 length (insertNth n a as) = length as + 1", "start": [1552, 1], "end": [1555, 96], "kind": "commanddeclaration"}, {"full_name": "List.removeNth_insertNth", "code": "theorem removeNth_insertNth (n : \u2115) (l : List \u03b1) : (l.insertNth n a).removeNth n = l", "start": [1558, 1], "end": [1560, 29], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_removeNth_of_ge", "code": "theorem insertNth_removeNth_of_ge :\n    \u2200 n m as,\n      n < length as \u2192 n \u2264 m \u2192 insertNth m a (as.removeNth n) = (as.insertNth (m + 1) a).removeNth n", "start": [1563, 1], "end": [1571, 97], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_removeNth_of_le", "code": "theorem insertNth_removeNth_of_le :\n    \u2200 n m as,\n      n < length as \u2192 m \u2264 n \u2192 insertNth m a (as.removeNth n) = (as.insertNth m a).removeNth (n + 1)", "start": [1574, 1], "end": [1580, 97], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_comm", "code": "theorem insertNth_comm (a b : \u03b1) :\n    \u2200 (i j : \u2115) (l : List \u03b1) (_ : i \u2264 j) (_ : j \u2264 length l),\n      (l.insertNth i a).insertNth (j + 1) b = (l.insertNth j b).insertNth i a", "start": [1583, 1], "end": [1591, 91], "kind": "commanddeclaration"}, {"full_name": "List.mem_insertNth", "code": "theorem mem_insertNth {a b : \u03b1} :\n    \u2200 {n : \u2115} {l : List \u03b1} (_ : n \u2264 l.length), a \u2208 l.insertNth n b \u2194 a = b \u2228 a \u2208 l", "start": [1594, 1], "end": [1600, 57], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_of_length_lt", "code": "theorem insertNth_of_length_lt (l : List \u03b1) (x : \u03b1) (n : \u2115) (h : l.length < n) :\n    insertNth n x l = l", "start": [1603, 1], "end": [1612, 25], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_length_self", "code": "@[simp]\ntheorem insertNth_length_self (l : List \u03b1) (x : \u03b1) : insertNth l.length x l = l ++ [x]", "start": [1615, 1], "end": [1619, 19], "kind": "commanddeclaration"}, {"full_name": "List.length_le_length_insertNth", "code": "theorem length_le_length_insertNth (l : List \u03b1) (x : \u03b1) (n : \u2115) :\n    l.length \u2264 (insertNth n x l).length", "start": [1622, 1], "end": [1627, 41], "kind": "commanddeclaration"}, {"full_name": "List.length_insertNth_le_succ", "code": "theorem length_insertNth_le_succ (l : List \u03b1) (x : \u03b1) (n : \u2115) :\n    (insertNth n x l).length \u2264 l.length + 1", "start": [1630, 1], "end": [1635, 34], "kind": "commanddeclaration"}, {"full_name": "List.get_insertNth_of_lt", "code": "theorem get_insertNth_of_lt (l : List \u03b1) (x : \u03b1) (n k : \u2115) (hn : k < n) (hk : k < l.length)\n    (hk' : k < (insertNth n x l).length := hk.trans_le (length_le_length_insertNth _ _ _)) :\n    (insertNth n x l).get \u27e8k, hk'\u27e9 = l.get \u27e8k, hk\u27e9", "start": [1638, 1], "end": [1648, 32], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_insertNth_of_lt", "code": "@[deprecated get_insertNth_of_lt]\ntheorem nthLe_insertNth_of_lt : \u2200 (l : List \u03b1) (x : \u03b1) (n k : \u2115), k < n \u2192 \u2200 (hk : k < l.length)\n    (hk' : k < (insertNth n x l).length := hk.trans_le (length_le_length_insertNth _ _ _)),\n    (insertNth n x l).nthLe k hk' = l.nthLe k hk", "start": [1650, 1], "end": [1653, 75], "kind": "commanddeclaration"}, {"full_name": "List.get_insertNth_self", "code": "@[simp]\ntheorem get_insertNth_self (l : List \u03b1) (x : \u03b1) (n : \u2115) (hn : n \u2264 l.length)\n    (hn' : n < (insertNth n x l).length := (by rwa [length_insertNth _ _ hn, Nat.lt_succ_iff])) :\n    (insertNth n x l).get \u27e8n, hn'\u27e9 = x", "start": [1656, 1], "end": [1667, 26], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_insertNth_self", "code": "@[simp, deprecated get_insertNth_self]\ntheorem nthLe_insertNth_self (l : List \u03b1) (x : \u03b1) (n : \u2115) (hn : n \u2264 l.length)\n    (hn' : n < (insertNth n x l).length := (by rwa [length_insertNth _ _ hn, Nat.lt_succ_iff])) :\n    (insertNth n x l).nthLe n hn' = x", "start": [1669, 1], "end": [1672, 69], "kind": "commanddeclaration"}, {"full_name": "List.get_insertNth_add_succ", "code": "theorem get_insertNth_add_succ (l : List \u03b1) (x : \u03b1) (n k : \u2115) (hk' : n + k < l.length)\n    (hk : n + k + 1 < (insertNth n x l).length := (by\n      rw [length_insertNth _ _ (le_self_add.trans hk'.le)]; exact Nat.succ_lt_succ_iff.2 hk')) :\n    (insertNth n x l).get \u27e8n + k + 1, hk\u27e9 = get l \u27e8n + k, hk'\u27e9", "start": [1675, 1], "end": [1685, 38], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_insertNth_add_succ", "code": "@[deprecated get_insertNth_add_succ]\ntheorem nthLe_insertNth_add_succ : \u2200 (l : List \u03b1) (x : \u03b1) (n k : \u2115) (hk' : n + k < l.length)\n    (hk : n + k + 1 < (insertNth n x l).length := (by\n      rw [length_insertNth _ _ (le_self_add.trans hk'.le)]; exact Nat.succ_lt_succ_iff.2 hk')),\n    (insertNth n x l).nthLe (n + k + 1) hk = nthLe l (n + k) hk'", "start": [1688, 1], "end": [1695, 28], "kind": "commanddeclaration"}, {"full_name": "List.insertNth_injective", "code": "theorem insertNth_injective (n : \u2115) (x : \u03b1) : Function.Injective (insertNth n x)", "start": [1699, 1], "end": [1703, 71], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_foldr", "code": "theorem map_eq_foldr (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map f l = foldr (fun a bs => f a :: bs) [] l", "start": [1712, 1], "end": [1713, 27], "kind": "commanddeclaration"}, {"full_name": "List.map_congr", "code": "theorem map_congr {f g : \u03b1 \u2192 \u03b2} : \u2200 {l : List \u03b1}, (\u2200 x \u2208 l, f x = g x) \u2192 map f l = map g l", "start": [1716, 1], "end": [1720, 36], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_map_iff", "code": "theorem map_eq_map_iff {f g : \u03b1 \u2192 \u03b2} {l : List \u03b1} : map f l = map g l \u2194 \u2200 x \u2208 l, f x = g x", "start": [1723, 1], "end": [1727, 9], "kind": "commanddeclaration"}, {"full_name": "List.map_concat", "code": "theorem map_concat (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1) :\n    map f (concat l a) = concat (map f l) (f a)", "start": [1730, 1], "end": [1732, 87], "kind": "commanddeclaration"}, {"full_name": "List.map_id''", "code": "@[simp]\ntheorem map_id'' (l : List \u03b1) : map (fun x => x) l = l", "start": [1735, 1], "end": [1737, 11], "kind": "commanddeclaration"}, {"full_name": "List.map_id'", "code": "theorem map_id' {f : \u03b1 \u2192 \u03b1} (h : \u2200 x, f x = x) (l : List \u03b1) : map f l = l", "start": [1740, 1], "end": [1741, 35], "kind": "commanddeclaration"}, {"full_name": "List.eq_nil_of_map_eq_nil", "code": "theorem eq_nil_of_map_eq_nil {f : \u03b1 \u2192 \u03b2} {l : List \u03b1} (h : map f l = nil) : l = nil", "start": [1744, 1], "end": [1745, 63], "kind": "commanddeclaration"}, {"full_name": "List.map_join", "code": "@[simp]\ntheorem map_join (f : \u03b1 \u2192 \u03b2) (L : List (List \u03b1)) : map f (join L) = join (map (map f) L)", "start": [1748, 1], "end": [1750, 62], "kind": "commanddeclaration"}, {"full_name": "List.bind_ret_eq_map", "code": "theorem bind_ret_eq_map (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : l.bind (List.ret \u2218 f) = map f l", "start": [1753, 1], "end": [1756, 13], "kind": "commanddeclaration"}, {"full_name": "List.bind_congr", "code": "theorem bind_congr {l : List \u03b1} {f g : \u03b1 \u2192 List \u03b2} (h : \u2200 x \u2208 l, f x = g x) :\n    List.bind l f = List.bind l g", "start": [1759, 1], "end": [1761, 43], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_map", "code": "@[simp]\ntheorem map_eq_map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : f <$> l = map f l", "start": [1764, 1], "end": [1766, 6], "kind": "commanddeclaration"}, {"full_name": "List.map_tail", "code": "@[simp]\ntheorem map_tail (f : \u03b1 \u2192 \u03b2) (l) : map f (tail l) = tail (map f l)", "start": [1769, 1], "end": [1770, 89], "kind": "commanddeclaration"}, {"full_name": "List.map_injective_iff", "code": "@[simp]\ntheorem map_injective_iff {f : \u03b1 \u2192 \u03b2} : Injective (map f) \u2194 Injective f", "start": [1773, 1], "end": [1784, 33], "kind": "commanddeclaration"}, {"full_name": "List.comp_map", "code": "theorem comp_map (h : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map (h \u2218 g) l = map h (map g l)", "start": [1787, 1], "end": [1792, 23], "kind": "commanddeclaration"}, {"full_name": "List.map_comp_map", "code": "@[simp]\ntheorem map_comp_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) : map g \u2218 map f = map (g \u2218 f)", "start": [1795, 1], "end": [1800, 44], "kind": "commanddeclaration"}, {"full_name": "List.map_filter_eq_foldr", "code": "theorem map_filter_eq_foldr (f : \u03b1 \u2192 \u03b2) (p : \u03b1 \u2192 Bool) (as : List \u03b1) :\n    map f (filter p as) = foldr (fun a bs => bif p a then f a :: bs else bs) [] as", "start": [1803, 1], "end": [1808, 43], "kind": "commanddeclaration"}, {"full_name": "List.getLast_map", "code": "theorem getLast_map (f : \u03b1 \u2192 \u03b2) {l : List \u03b1} (hl : l \u2260 []) :\n    (l.map f).getLast (mt eq_nil_of_map_eq_nil hl) = f (l.getLast hl)", "start": [1811, 1], "end": [1817, 25], "kind": "commanddeclaration"}, {"full_name": "List.map_eq_replicate_iff", "code": "theorem map_eq_replicate_iff {l : List \u03b1} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} :\n    l.map f = replicate l.length b \u2194 \u2200 x \u2208 l, f x = b", "start": [1820, 1], "end": [1822, 22], "kind": "commanddeclaration"}, {"full_name": "List.map_const", "code": "@[simp] theorem map_const (l : List \u03b1) (b : \u03b2) : map (const \u03b1 b) l = replicate l.length b", "start": [1825, 1], "end": [1826, 42], "kind": "commanddeclaration"}, {"full_name": "List.map_const'", "code": "@[simp] theorem map_const' (l : List \u03b1) (b : \u03b2) : map (fun _ => b) l = replicate l.length b", "start": [1829, 1], "end": [1830, 16], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_mem_map_const", "code": "theorem eq_of_mem_map_const {b\u2081 b\u2082 : \u03b2} {l : List \u03b1} (h : b\u2081 \u2208 map (const \u03b1 b\u2082) l) :\n    b\u2081 = b\u2082", "start": [1833, 1], "end": [1834, 67], "kind": "commanddeclaration"}, {"full_name": "List.nil_zipWith", "code": "theorem nil_zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b2) : zipWith f [] l = []", "start": [1839, 1], "end": [1839, 93], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_nil", "code": "theorem zipWith_nil (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b1) : zipWith f l [] = []", "start": [1842, 1], "end": [1842, 93], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_flip", "code": "@[simp]\ntheorem zipWith_flip (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : \u2200 as bs, zipWith (flip f) bs as = zipWith f as bs", "start": [1845, 1], "end": [1852, 8], "kind": "commanddeclaration"}, {"full_name": "List.take_cons", "code": "theorem take_cons (n) (a : \u03b1) (l : List \u03b1) : take (succ n) (a :: l) = a :: take n l", "start": [1861, 1], "end": [1862, 6], "kind": "commanddeclaration"}, {"full_name": "List.take_all_of_le", "code": "theorem take_all_of_le : \u2200 {n} {l : List \u03b1}, length l \u2264 n \u2192 take n l = l", "start": [1867, 1], "end": [1873, 47], "kind": "commanddeclaration"}, {"full_name": "List.take_left", "code": "@[simp]\ntheorem take_left : \u2200 l\u2081 l\u2082 : List \u03b1, take (length l\u2081) (l\u2081 ++ l\u2082) = l\u2081", "start": [1876, 1], "end": [1879, 56], "kind": "commanddeclaration"}, {"full_name": "List.take_left'", "code": "theorem take_left' {l\u2081 l\u2082 : List \u03b1} {n} (h : length l\u2081 = n) : take n (l\u2081 ++ l\u2082) = l\u2081", "start": [1882, 1], "end": [1883, 28], "kind": "commanddeclaration"}, {"full_name": "List.take_take", "code": "theorem take_take : \u2200 (n m) (l : List \u03b1), take n (take m l) = take (min n m) l", "start": [1886, 1], "end": [1891, 53], "kind": "commanddeclaration"}, {"full_name": "List.take_replicate", "code": "theorem take_replicate (a : \u03b1) : \u2200 n m : \u2115, take n (replicate m a) = replicate (min n m) a", "start": [1894, 1], "end": [1897, 62], "kind": "commanddeclaration"}, {"full_name": "List.map_take", "code": "theorem map_take {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n    \u2200 (L : List \u03b1) (i : \u2115), (L.take i).map f = (L.map f).take i", "start": [1900, 1], "end": [1904, 51], "kind": "commanddeclaration"}, {"full_name": "List.take_append_eq_append_take", "code": "theorem take_append_eq_append_take {l\u2081 l\u2082 : List \u03b1} {n : \u2115} :\n    take n (l\u2081 ++ l\u2082) = take n l\u2081 ++ take (n - l\u2081.length) l\u2082", "start": [1907, 1], "end": [1912, 23], "kind": "commanddeclaration"}, {"full_name": "List.take_append_of_le_length", "code": "theorem take_append_of_le_length {l\u2081 l\u2082 : List \u03b1} {n : \u2115} (h : n \u2264 l\u2081.length) :\n    (l\u2081 ++ l\u2082).take n = l\u2081.take n", "start": [1915, 1], "end": [1916, 101], "kind": "commanddeclaration"}, {"full_name": "List.take_append", "code": "theorem take_append {l\u2081 l\u2082 : List \u03b1} (i : \u2115) : take (l\u2081.length + i) (l\u2081 ++ l\u2082) = l\u2081 ++ take i l\u2082", "start": [1919, 1], "end": [1922, 67], "kind": "commanddeclaration"}, {"full_name": "List.get_take", "code": "theorem get_take (L : List \u03b1) {i j : \u2115} (hi : i < L.length) (hj : i < j) :\n    get L \u27e8i, hi\u27e9 = get (L.take j) \u27e8i, length_take .. \u25b8 lt_min hj hi\u27e9", "start": [1925, 1], "end": [1929, 58], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_take", "code": "@[deprecated get_take]\ntheorem nthLe_take (L : List \u03b1) {i j : \u2115} (hi : i < L.length) (hj : i < j) :\n    nthLe L i hi = nthLe (L.take j) i (length_take .. \u25b8 lt_min hj hi)", "start": [1932, 1], "end": [1937, 19], "kind": "commanddeclaration"}, {"full_name": "List.get_take'", "code": "theorem get_take' (L : List \u03b1) {j i} :\n    get (L.take j) i = get L \u27e8i.1, lt_of_lt_of_le i.2 (by simp [le_refl])\u27e9", "start": [1940, 1], "end": [1944, 55], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_take'", "code": "@[deprecated get_take']\ntheorem nthLe_take' (L : List \u03b1) {i j : \u2115} (hi : i < (L.take j).length) :\n    nthLe (L.take j) i hi = nthLe L i (lt_of_lt_of_le hi (by simp [le_refl]))", "start": [1947, 1], "end": [1951, 93], "kind": "commanddeclaration"}, {"full_name": "List.get?_take", "code": "theorem get?_take {l : List \u03b1} {n m : \u2115} (h : m < n) : (l.take n).get? m = l.get? m", "start": [1954, 1], "end": [1962, 55], "kind": "commanddeclaration"}, {"full_name": "List.nth_take_of_succ", "code": "@[simp]\ntheorem nth_take_of_succ {l : List \u03b1} {n : \u2115} : (l.take (n + 1)).get? n = l.get? n", "start": [1965, 1], "end": [1967, 33], "kind": "commanddeclaration"}, {"full_name": "List.take_succ", "code": "theorem take_succ {l : List \u03b1} {n : \u2115} : l.take (n + 1) = l.take n ++ (l.get? n).toList", "start": [1970, 1], "end": [1975, 78], "kind": "commanddeclaration"}, {"full_name": "List.take_eq_nil_iff", "code": "@[simp]\ntheorem take_eq_nil_iff {l : List \u03b1} {k : \u2115} : l.take k = [] \u2194 l = [] \u2228 k = 0", "start": [1978, 1], "end": [1980, 50], "kind": "commanddeclaration"}, {"full_name": "List.take_eq_take", "code": "theorem take_eq_take :\n    \u2200 {l : List \u03b1} {m n : \u2115}, l.take m = l.take n \u2194 min m l.length = min n l.length", "start": [1983, 1], "end": [1989, 71], "kind": "commanddeclaration"}, {"full_name": "List.take_add", "code": "theorem take_add (l : List \u03b1) (m n : \u2115) : l.take (m + n) = l.take m ++ (l.drop m).take n", "start": [1992, 1], "end": [2003, 11], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_eq_take", "code": "theorem dropLast_eq_take (l : List \u03b1) : l.dropLast = l.take l.length.pred", "start": [2006, 1], "end": [2011, 26], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_take", "code": "theorem dropLast_take {n : \u2115} {l : List \u03b1} (h : n < l.length) :\n    (l.take n).dropLast = l.take n.pred", "start": [2014, 1], "end": [2016, 67], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_cons_of_ne_nil", "code": "theorem dropLast_cons_of_ne_nil {\u03b1 : Type*} {x : \u03b1}\n    {l : List \u03b1} (h : l \u2260 []) : (x :: l).dropLast = x :: l.dropLast", "start": [2019, 1], "end": [2020, 93], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_append_of_ne_nil", "code": "@[simp]\ntheorem dropLast_append_of_ne_nil {\u03b1 : Type*} {l : List \u03b1} :\n    \u2200 (l' : List \u03b1) (_ : l \u2260 []), (l' ++ l).dropLast = l' ++ l.dropLast", "start": [2023, 1], "end": [2029, 13], "kind": "commanddeclaration"}, {"full_name": "List.drop_eq_nil_iff_le", "code": "theorem drop_eq_nil_iff_le {l : List \u03b1} {k : \u2115} : l.drop k = [] \u2194 l.length \u2264 k", "start": [2034, 1], "end": [2042, 46], "kind": "commanddeclaration"}, {"full_name": "List.tail_drop", "code": "@[simp]\ntheorem tail_drop (l : List \u03b1) (n : \u2115) : (l.drop n).tail = l.drop (n + 1)", "start": [2045, 1], "end": [2051, 16], "kind": "commanddeclaration"}, {"full_name": "List.drop_tail", "code": "@[simp]\ntheorem drop_tail (l : List \u03b1) (n : \u2115) : l.tail.drop n = l.drop (n + 1)", "start": [2054, 1], "end": [2056, 24], "kind": "commanddeclaration"}, {"full_name": "List.cons_get_drop_succ", "code": "theorem cons_get_drop_succ {l : List \u03b1} {n} :\n    l.get n :: l.drop (n.1 + 1) = l.drop n.1", "start": [2058, 1], "end": [2066, 43], "kind": "commanddeclaration"}, {"full_name": "List.cons_nthLe_drop_succ", "code": "@[deprecated cons_get_drop_succ]\ntheorem cons_nthLe_drop_succ {l : List \u03b1} {n : \u2115} (hn : n < l.length) :\n    l.nthLe n hn :: l.drop (n + 1) = l.drop n", "start": [2068, 1], "end": [2070, 68], "kind": "commanddeclaration"}, {"full_name": "List.drop_one", "code": "@[simp]\ntheorem drop_one : \u2200 l : List \u03b1, drop 1 l = tail l", "start": [2075, 1], "end": [2077, 23], "kind": "commanddeclaration"}, {"full_name": "List.drop_add", "code": "theorem drop_add : \u2200 (m n) (l : List \u03b1), drop (m + n) l = drop m (drop n l)", "start": [2080, 1], "end": [2083, 39], "kind": "commanddeclaration"}, {"full_name": "List.drop_left", "code": "@[simp]\ntheorem drop_left : \u2200 l\u2081 l\u2082 : List \u03b1, drop (length l\u2081) (l\u2081 ++ l\u2082) = l\u2082", "start": [2086, 1], "end": [2089, 35], "kind": "commanddeclaration"}, {"full_name": "List.drop_left'", "code": "theorem drop_left' {l\u2081 l\u2082 : List \u03b1} {n} (h : length l\u2081 = n) : drop n (l\u2081 ++ l\u2082) = l\u2082", "start": [2092, 1], "end": [2093, 28], "kind": "commanddeclaration"}, {"full_name": "List.drop_eq_get_cons", "code": "theorem drop_eq_get_cons : \u2200 {n} {l : List \u03b1} (h), drop n l = get l \u27e8n, h\u27e9 :: drop (n + 1) l", "start": [2096, 1], "end": [2098, 48], "kind": "commanddeclaration"}, {"full_name": "List.drop_length_cons", "code": "theorem drop_length_cons {l : List \u03b1} (h : l \u2260 []) (a : \u03b1) :\n    (a :: l).drop l.length = [l.getLast h]", "start": [2103, 1], "end": [2111, 18], "kind": "commanddeclaration"}, {"full_name": "List.drop_append", "code": "theorem drop_append {l\u2081 l\u2082 : List \u03b1} (i : \u2115) : drop (l\u2081.length + i) (l\u2081 ++ l\u2082) = drop i l\u2082", "start": [2118, 1], "end": [2121, 62], "kind": "commanddeclaration"}, {"full_name": "List.drop_sizeOf_le", "code": "theorem drop_sizeOf_le [SizeOf \u03b1] (l : List \u03b1) : \u2200 n : \u2115, sizeOf (l.drop n) \u2264 sizeOf l", "start": [2124, 1], "end": [2129, 44], "kind": "commanddeclaration"}, {"full_name": "List.get_drop", "code": "theorem get_drop (L : List \u03b1) {i j : \u2115} (h : i + j < L.length) :\n    get L \u27e8i + j, h\u27e9 = get (L.drop i) \u27e8j, by\n      have A : i < L.length := lt_of_le_of_lt (Nat.le.intro rfl) h\n      rw [(take_append_drop i L).symm] at h\n      simpa only [le_of_lt A, min_eq_left, add_lt_add_iff_left, length_take,\n        length_append] using h\u27e9", "start": [2133, 1], "end": [2143, 78], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_drop", "code": "@[deprecated get_drop]\ntheorem nthLe_drop (L : List \u03b1) {i j : \u2115} (h : i + j < L.length) :\n    nthLe L (i + j) h = nthLe (L.drop i) j (by\n      have A : i < L.length := lt_of_le_of_lt (Nat.le.intro rfl) h\n      rw [(take_append_drop i L).symm] at h\n      simpa only [le_of_lt A, min_eq_left, add_lt_add_iff_left, length_take,\n        length_append] using h)", "start": [2146, 1], "end": [2154, 47], "kind": "commanddeclaration"}, {"full_name": "List.get_drop'", "code": "theorem get_drop' (L : List \u03b1) {i j} :\n    get (L.drop i) j = get L \u27e8i + j, lt_tsub_iff_left.mp (length_drop i L \u25b8 j.2)\u27e9", "start": [2157, 1], "end": [2161, 16], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_drop'", "code": "@[deprecated get_drop']\ntheorem nthLe_drop' (L : List \u03b1) {i j : \u2115} (h : j < (L.drop i).length) :\n    nthLe (L.drop i) j h = nthLe L (i + j) (lt_tsub_iff_left.mp (length_drop i L \u25b8 h))", "start": [2164, 1], "end": [2169, 15], "kind": "commanddeclaration"}, {"full_name": "List.get?_drop", "code": "theorem get?_drop (L : List \u03b1) (i j : \u2115) : get? (L.drop i) j = get? L (i + j)", "start": [2172, 1], "end": [2175, 81], "kind": "commanddeclaration"}, {"full_name": "List.drop_drop", "code": "@[simp]\ntheorem drop_drop (n : \u2115) : \u2200 (m) (l : List \u03b1), drop n (drop m l) = drop (n + m) l", "start": [2178, 1], "end": [2186, 45], "kind": "commanddeclaration"}, {"full_name": "List.drop_take", "code": "theorem drop_take : \u2200 (m : \u2115) (n : \u2115) (l : List \u03b1), drop m (take (m + n) l) = take n (drop m l)", "start": [2189, 1], "end": [2194, 47], "kind": "commanddeclaration"}, {"full_name": "List.map_drop", "code": "theorem map_drop {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n    \u2200 (L : List \u03b1) (i : \u2115), (L.drop i).map f = (L.map f).drop i", "start": [2197, 1], "end": [2203, 22], "kind": "commanddeclaration"}, {"full_name": "List.modifyNthTail_eq_take_drop", "code": "theorem modifyNthTail_eq_take_drop (f : List \u03b1 \u2192 List \u03b1) (H : f [] = []) :\n    \u2200 n l, modifyNthTail f n l = take n l ++ f (drop n l)", "start": [2206, 1], "end": [2210, 77], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_take_drop", "code": "theorem modifyNth_eq_take_drop (f : \u03b1 \u2192 \u03b1) :\n    \u2200 n l, modifyNth f n l = take n l ++ modifyHead f (drop n l)", "start": [2213, 1], "end": [2215, 35], "kind": "commanddeclaration"}, {"full_name": "List.modifyNth_eq_take_cons_drop", "code": "theorem modifyNth_eq_take_cons_drop (f : \u03b1 \u2192 \u03b1) {n l} (h) :\n    modifyNth f n l = take n l ++ f (get l \u27e8n, h\u27e9) :: drop (n + 1) l", "start": [2218, 1], "end": [2220, 55], "kind": "commanddeclaration"}, {"full_name": "List.set_eq_take_cons_drop", "code": "theorem set_eq_take_cons_drop (a : \u03b1) {n l} (h : n < length l) :\n    set l n a = take n l ++ a :: drop (n + 1) l", "start": [2223, 1], "end": [2225, 57], "kind": "commanddeclaration"}, {"full_name": "List.reverse_take", "code": "theorem reverse_take {\u03b1} {xs : List \u03b1} (n : \u2115) (h : n \u2264 xs.length) :\n    xs.reverse.take n = (xs.drop (xs.length - n)).reverse", "start": [2228, 1], "end": [2243, 8], "kind": "commanddeclaration"}, {"full_name": "List.set_eq_nil", "code": "@[simp]\ntheorem set_eq_nil (l : List \u03b1) (n : \u2115) (a : \u03b1) : l.set n a = [] \u2194 l = []", "start": [2246, 1], "end": [2248, 42], "kind": "commanddeclaration"}, {"full_name": "List.takeI_length", "code": "@[simp]\ntheorem takeI_length : \u2200 n l, length (@takeI \u03b1 _ n l) = n", "start": [2255, 1], "end": [2258, 50], "kind": "commanddeclaration"}, {"full_name": "List.takeI_nil", "code": "@[simp]\ntheorem takeI_nil : \u2200 n, takeI n (@nil \u03b1) = replicate n default", "start": [2261, 1], "end": [2264, 46], "kind": "commanddeclaration"}, {"full_name": "List.takeI_eq_take", "code": "theorem takeI_eq_take : \u2200 {n} {l : List \u03b1}, n \u2264 length l \u2192 takeI n l = take n l", "start": [2267, 1], "end": [2269, 84], "kind": "commanddeclaration"}, {"full_name": "List.takeI_left", "code": "@[simp]\ntheorem takeI_left (l\u2081 l\u2082 : List \u03b1) : takeI (length l\u2081) (l\u2081 ++ l\u2082) = l\u2081", "start": [2272, 1], "end": [2274, 89], "kind": "commanddeclaration"}, {"full_name": "List.takeI_left'", "code": "theorem takeI_left' {l\u2081 l\u2082 : List \u03b1} {n} (h : length l\u2081 = n) : takeI n (l\u2081 ++ l\u2082) = l\u2081", "start": [2277, 1], "end": [2278, 29], "kind": "commanddeclaration"}, {"full_name": "List.takeD_length", "code": "@[simp]\ntheorem takeD_length : \u2200 n l a, length (@takeD \u03b1 n l a) = n", "start": [2287, 1], "end": [2290, 55], "kind": "commanddeclaration"}, {"full_name": "List.takeD_eq_take", "code": "theorem takeD_eq_take : \u2200 {n} {l : List \u03b1} a, n \u2264 length l \u2192 takeD n l a = take n l", "start": [2294, 1], "end": [2296, 89], "kind": "commanddeclaration"}, {"full_name": "List.takeD_left", "code": "@[simp]\ntheorem takeD_left (l\u2081 l\u2082 : List \u03b1) (a : \u03b1) : takeD (length l\u2081) (l\u2081 ++ l\u2082) a = l\u2081", "start": [2298, 1], "end": [2300, 91], "kind": "commanddeclaration"}, {"full_name": "List.takeD_left'", "code": "theorem takeD_left' {l\u2081 l\u2082 : List \u03b1} {n} {a} (h : length l\u2081 = n) : takeD n (l\u2081 ++ l\u2082) a = l\u2081", "start": [2302, 1], "end": [2303, 32], "kind": "commanddeclaration"}, {"full_name": "List.foldl_ext", "code": "theorem foldl_ext (f g : \u03b1 \u2192 \u03b2 \u2192 \u03b1) (a : \u03b1) {l : List \u03b2} (H : \u2200 a : \u03b1, \u2200 b \u2208 l, f a b = g a b) :\n    foldl f a l = foldl g a l", "start": [2309, 1], "end": [2315, 88], "kind": "commanddeclaration"}, {"full_name": "List.foldr_ext", "code": "theorem foldr_ext (f g : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) {l : List \u03b1} (H : \u2200 a \u2208 l, \u2200 b : \u03b2, f a b = g a b) :\n    foldr f b l = foldr g b l", "start": [2318, 1], "end": [2322, 33], "kind": "commanddeclaration"}, {"full_name": "List.foldl_concat", "code": "theorem foldl_concat\n    (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2) (x : \u03b1) (xs : List \u03b1) :\n    List.foldl f b (xs ++ [x]) = f (List.foldl f b xs) x", "start": [2334, 1], "end": [2337, 44], "kind": "commanddeclaration"}, {"full_name": "List.foldr_concat", "code": "theorem foldr_concat\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (x : \u03b1) (xs : List \u03b1) :\n    List.foldr f b (xs ++ [x]) = (List.foldr f (f x b) xs)", "start": [2339, 1], "end": [2342, 44], "kind": "commanddeclaration"}, {"full_name": "List.foldl_fixed'", "code": "theorem foldl_fixed' {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : \u2200 b, f a b = a) : \u2200 l : List \u03b2, foldl f a l = a", "start": [2344, 1], "end": [2346, 58], "kind": "commanddeclaration"}, {"full_name": "List.foldr_fixed'", "code": "theorem foldr_fixed' {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {b : \u03b2} (hf : \u2200 a, f a b = b) : \u2200 l : List \u03b1, foldr f b l = b", "start": [2349, 1], "end": [2351, 58], "kind": "commanddeclaration"}, {"full_name": "List.foldl_fixed", "code": "@[simp]\ntheorem foldl_fixed {a : \u03b1} : \u2200 l : List \u03b2, foldl (fun a _ => a) a l = a", "start": [2354, 1], "end": [2356, 28], "kind": "commanddeclaration"}, {"full_name": "List.foldr_fixed", "code": "@[simp]\ntheorem foldr_fixed {b : \u03b2} : \u2200 l : List \u03b1, foldr (fun _ b => b) b l = b", "start": [2359, 1], "end": [2361, 28], "kind": "commanddeclaration"}, {"full_name": "List.foldl_join", "code": "@[simp]\ntheorem foldl_join (f : \u03b1 \u2192 \u03b2 \u2192 \u03b1) :\n    \u2200 (a : \u03b1) (L : List (List \u03b2)), foldl f a (join L) = foldl (foldl f) a L", "start": [2364, 1], "end": [2368, 93], "kind": "commanddeclaration"}, {"full_name": "List.foldr_join", "code": "@[simp]\ntheorem foldr_join (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) :\n    \u2200 (b : \u03b2) (L : List (List \u03b1)), foldr f b (join L) = foldr (fun l b => foldr f b l) b L", "start": [2371, 1], "end": [2375, 81], "kind": "commanddeclaration"}, {"full_name": "List.foldr_eta", "code": "theorem foldr_eta : \u2200 l : List \u03b1, foldr cons [] l = l", "start": [2384, 1], "end": [2385, 61], "kind": "commanddeclaration"}, {"full_name": "List.reverse_foldl", "code": "@[simp]\ntheorem reverse_foldl {l : List \u03b1} : reverse (foldl (fun t h => h :: t) [] l) = l", "start": [2388, 1], "end": [2390, 83], "kind": "commanddeclaration"}, {"full_name": "List.foldl_map'", "code": "theorem foldl_map' {\u03b1 \u03b2 : Type u} (g : \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (f' : \u03b2 \u2192 \u03b2 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1)\n    (h : \u2200 x y, f' (g x) (g y) = g (f x y)) :\n    List.foldl f' (g a) (l.map g) = g (List.foldl f a l)", "start": [2397, 1], "end": [2402, 16], "kind": "commanddeclaration"}, {"full_name": "List.foldr_map'", "code": "theorem foldr_map' {\u03b1 \u03b2 : Type u} (g : \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (f' : \u03b2 \u2192 \u03b2 \u2192 \u03b2) (a : \u03b1) (l : List \u03b1)\n    (h : \u2200 x y, f' (g x) (g y) = g (f x y)) :\n    List.foldr f' (g a) (l.map g) = g (List.foldr f a l)", "start": [2405, 1], "end": [2410, 16], "kind": "commanddeclaration"}, {"full_name": "List.foldl_hom\u2082", "code": "theorem foldl_hom\u2082 (l : List \u03b9) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (op\u2081 : \u03b1 \u2192 \u03b9 \u2192 \u03b1) (op\u2082 : \u03b2 \u2192 \u03b9 \u2192 \u03b2)\n    (op\u2083 : \u03b3 \u2192 \u03b9 \u2192 \u03b3) (a : \u03b1) (b : \u03b2) (h : \u2200 a b i, f (op\u2081 a i) (op\u2082 b i) = op\u2083 (f a b) i) :\n    foldl op\u2083 (f a b) l = f (foldl op\u2081 a l) (foldl op\u2082 b l)", "start": [2417, 1], "end": [2422, 59], "kind": "commanddeclaration"}, {"full_name": "List.foldr_hom\u2082", "code": "theorem foldr_hom\u2082 (l : List \u03b9) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (op\u2081 : \u03b9 \u2192 \u03b1 \u2192 \u03b1) (op\u2082 : \u03b9 \u2192 \u03b2 \u2192 \u03b2)\n    (op\u2083 : \u03b9 \u2192 \u03b3 \u2192 \u03b3) (a : \u03b1) (b : \u03b2) (h : \u2200 a b i, f (op\u2081 i a) (op\u2082 i b) = op\u2083 i (f a b)) :\n    foldr op\u2083 (f a b) l = f (foldr op\u2081 a l) (foldr op\u2082 b l)", "start": [2425, 1], "end": [2429, 57], "kind": "commanddeclaration"}, {"full_name": "List.injective_foldl_comp", "code": "theorem injective_foldl_comp {\u03b1 : Type*} {l : List (\u03b1 \u2192 \u03b1)} {f : \u03b1 \u2192 \u03b1}\n    (hl : \u2200 f \u2208 l, Function.Injective f) (hf : Function.Injective f) :\n    Function.Injective (@List.foldl (\u03b1 \u2192 \u03b1) (\u03b1 \u2192 \u03b1) Function.comp f l)", "start": [2432, 1], "end": [2439, 40], "kind": "commanddeclaration"}, {"full_name": "List.foldrRecOn", "code": "def foldrRecOn {C : \u03b2 \u2192 Sort*} (l : List \u03b1) (op : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (hb : C b)\n    (hl : \u2200 (b : \u03b2) (_ : C b) (a : \u03b1) (_ : a \u2208 l), C (op a b)) : C (foldr op b l) := by\n  cases l with\n  | nil => exact hb\n  | cons hd tl =>\n    have IH : ((b : \u03b2) \u2192 C b \u2192 (a : \u03b1) \u2192 a \u2208 tl \u2192 C (op a b)) \u2192 C (foldr op b tl) :=\n      foldrRecOn _ _ _ hb\n    refine' hl _ _ hd (mem_cons_self hd tl)\n    refine' IH _\n    intro y hy x hx\n    exact hl y hy x (mem_cons_of_mem hd hx)", "start": [2453, 1], "end": [2467, 44], "kind": "commanddeclaration"}, {"full_name": "List.foldlRecOn", "code": "def foldlRecOn {C : \u03b2 \u2192 Sort*} (l : List \u03b1) (op : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b : \u03b2) (hb : C b)\n    (hl : \u2200 (b : \u03b2) (_ : C b) (a : \u03b1) (_ : a \u2208 l), C (op b a)) : C (foldl op b l) := by\n  cases l with\n  | nil => exact hb\n  | cons hd tl =>\n    have IH : (b : \u03b2) \u2192 C b \u2192 ((b : \u03b2) \u2192 C b \u2192 (a : \u03b1) \u2192 a \u2208 tl \u2192 C (op b a)) \u2192 C (foldl op b tl) :=\n      foldlRecOn _ _\n    refine' IH _ _ _\n    \u00b7 exact hl b hb hd (mem_cons_self hd tl)\n    \u00b7 intro y hy x hx\n      exact hl y hy x (mem_cons_of_mem hd hx)", "start": [2481, 1], "end": [2495, 46], "kind": "commanddeclaration"}, {"full_name": "List.foldrRecOn_nil", "code": "@[simp]\ntheorem foldrRecOn_nil {C : \u03b2 \u2192 Sort*} (op : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b) (hb : C b) (hl) :\n    foldrRecOn [] op b hb hl = hb", "start": [2498, 1], "end": [2501, 6], "kind": "commanddeclaration"}, {"full_name": "List.foldrRecOn_cons", "code": "@[simp]\ntheorem foldrRecOn_cons {C : \u03b2 \u2192 Sort*} (x : \u03b1) (l : List \u03b1) (op : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b) (hb : C b)\n    (hl : \u2200 (b : \u03b2) (_ : C b) (a : \u03b1) (_ : a \u2208 x :: l), C (op a b)) :\n    foldrRecOn (x :: l) op b hb hl =\n      hl _ (foldrRecOn l op b hb fun b hb a ha => hl b hb a (mem_cons_of_mem _ ha)) x\n        (mem_cons_self _ _)", "start": [2504, 1], "end": [2510, 6], "kind": "commanddeclaration"}, {"full_name": "List.foldlRecOn_nil", "code": "@[simp]\ntheorem foldlRecOn_nil {C : \u03b2 \u2192 Sort*} (op : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (b) (hb : C b) (hl) :\n    foldlRecOn [] op b hb hl = hb", "start": [2513, 1], "end": [2516, 6], "kind": "commanddeclaration"}, {"full_name": "List.length_scanl", "code": "theorem length_scanl : \u2200 a l, length (scanl f a l) = l.length + 1", "start": [2523, 1], "end": [2527, 27], "kind": "commanddeclaration"}, {"full_name": "List.scanl_nil", "code": "@[simp]\ntheorem scanl_nil (b : \u03b2) : scanl f b nil = [b]", "start": [2530, 1], "end": [2532, 6], "kind": "commanddeclaration"}, {"full_name": "List.scanl_cons", "code": "@[simp]\ntheorem scanl_cons : scanl f b (a :: l) = [b] ++ scanl f (f b a) l", "start": [2535, 1], "end": [2537, 70], "kind": "commanddeclaration"}, {"full_name": "List.get?_zero_scanl", "code": "@[simp]\ntheorem get?_zero_scanl : (scanl f b l).get? 0 = some b", "start": [2540, 1], "end": [2544, 51], "kind": "commanddeclaration"}, {"full_name": "List.get_zero_scanl", "code": "@[simp]\ntheorem get_zero_scanl {h : 0 < (scanl f b l).length} : (scanl f b l).get \u27e80, h\u27e9 = b", "start": [2547, 1], "end": [2551, 50], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_zero_scanl", "code": "@[simp, deprecated get_zero_scanl]\ntheorem nthLe_zero_scanl {h : 0 < (scanl f b l).length} : (scanl f b l).nthLe 0 h = b", "start": [2554, 1], "end": [2556, 17], "kind": "commanddeclaration"}, {"full_name": "List.get?_succ_scanl", "code": "theorem get?_succ_scanl {i : \u2115} : (scanl f b l).get? (i + 1) =\n    ((scanl f b l).get? i).bind fun x => (l.get? i).map fun y => f x y", "start": [2559, 1], "end": [2568, 27], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_succ_scanl", "code": "theorem nthLe_succ_scanl {i : \u2115} {h : i + 1 < (scanl f b l).length} :\n    (scanl f b l).nthLe (i + 1) h =\n      f ((scanl f b l).nthLe i (Nat.lt_of_succ_lt h))\n        (l.nthLe i (Nat.lt_of_succ_lt_succ (lt_of_lt_of_le h (le_of_eq (length_scanl b l)))))", "start": [2572, 1], "end": [2588, 64], "kind": "commanddeclaration"}, {"full_name": "List.get_succ_scanl", "code": "theorem get_succ_scanl {i : \u2115} {h : i + 1 < (scanl f b l).length} :\n    (scanl f b l).get \u27e8i + 1, h\u27e9 =\n      f ((scanl f b l).get \u27e8i, Nat.lt_of_succ_lt h\u27e9)\n        (l.get \u27e8i, Nat.lt_of_succ_lt_succ (lt_of_lt_of_le h (le_of_eq (length_scanl b l)))\u27e9)", "start": [2591, 1], "end": [2595, 19], "kind": "commanddeclaration"}, {"full_name": "List.scanr_nil", "code": "@[simp]\ntheorem scanr_nil (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) : scanr f b [] = [b]", "start": [2603, 1], "end": [2605, 6], "kind": "commanddeclaration"}, {"full_name": "List.scanr_cons", "code": "@[simp]\ntheorem scanr_cons (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (b : \u03b2) (a : \u03b1) (l : List \u03b1) :\n    scanr f b (a :: l) = foldr f b (a :: l) :: scanr f b l", "start": [2610, 1], "end": [2616, 43], "kind": "commanddeclaration"}, {"full_name": "List.foldl1_eq_foldr1", "code": "theorem foldl1_eq_foldr1 : \u2200 a b l, foldl f a (l ++ [b]) = foldr f b (a :: l)", "start": [2624, 1], "end": [2627, 89], "kind": "commanddeclaration"}, {"full_name": "List.foldl_eq_of_comm_of_assoc", "code": "theorem foldl_eq_of_comm_of_assoc : \u2200 a b l, foldl f a (b :: l) = f b (foldl f a l)", "start": [2630, 1], "end": [2634, 72], "kind": "commanddeclaration"}, {"full_name": "List.foldl_eq_foldr", "code": "theorem foldl_eq_foldr : \u2200 a l, foldl f a l = foldr f a l", "start": [2637, 1], "end": [2640, 92], "kind": "commanddeclaration"}, {"full_name": "List.foldl_eq_of_comm'", "code": "theorem foldl_eq_of_comm' : \u2200 a b l, foldl f a (b :: l) = f (foldl f a l) b", "start": [2651, 1], "end": [2653, 83], "kind": "commanddeclaration"}, {"full_name": "List.foldl_eq_foldr'", "code": "theorem foldl_eq_foldr' : \u2200 a l, foldl f a l = foldr (flip f) a l", "start": [2656, 1], "end": [2658, 78], "kind": "commanddeclaration"}, {"full_name": "List.foldr_eq_of_comm'", "code": "theorem foldr_eq_of_comm' : \u2200 a b l, foldr f a (b :: l) = foldr f (f b a) l", "start": [2669, 1], "end": [2671, 81], "kind": "commanddeclaration"}, {"full_name": "List.foldl_assoc", "code": "theorem foldl_assoc : \u2200 {l : List \u03b1} {a\u2081 a\u2082}, (l <*> a\u2081 \u22c6 a\u2082) = a\u2081 \u22c6 l <*> a\u2082", "start": [2686, 1], "end": [2691, 66], "kind": "commanddeclaration"}, {"full_name": "List.foldl_op_eq_op_foldr_assoc", "code": "theorem foldl_op_eq_op_foldr_assoc :\n    \u2200 {l : List \u03b1} {a\u2081 a\u2082}, ((l <*> a\u2081) \u22c6 a\u2082) = a\u2081 \u22c6 l.foldr (\u00b7 \u22c6 \u00b7) a\u2082", "start": [2694, 1], "end": [2698, 95], "kind": "commanddeclaration"}, {"full_name": "List.foldl_assoc_comm_cons", "code": "theorem foldl_assoc_comm_cons {l : List \u03b1} {a\u2081 a\u2082} : ((a\u2081 :: l) <*> a\u2082) = a\u2081 \u22c6 l <*> a\u2082", "start": [2701, 1], "end": [2702, 40], "kind": "commanddeclaration"}, {"full_name": "List.foldrM_eq_foldr", "code": "theorem foldrM_eq_foldr (f : \u03b1 \u2192 \u03b2 \u2192 m \u03b2) (b l) :\n    foldrM f b l = foldr (fun a mb => mb >>= f a) (pure b) l", "start": [2725, 1], "end": [2726, 92], "kind": "commanddeclaration"}, {"full_name": "List.foldlM_eq_foldl", "code": "theorem foldlM_eq_foldl (f : \u03b2 \u2192 \u03b1 \u2192 m \u03b2) (b l) :\n    List.foldlM f b l = foldl (fun mb a => mb >>= fun b => f b a) (pure b) l", "start": [2731, 1], "end": [2738, 80], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_singleton", "code": "@[simp]\ntheorem intersperse_singleton {\u03b1 : Type u} (a b : \u03b1) : intersperse a [b] = [b]", "start": [2753, 1], "end": [2755, 6], "kind": "commanddeclaration"}, {"full_name": "List.intersperse_cons_cons", "code": "@[simp]\ntheorem intersperse_cons_cons {\u03b1 : Type u} (a b c : \u03b1) (tl : List \u03b1) :\n    intersperse a (b :: c :: tl) = b :: a :: intersperse a (c :: tl)", "start": [2758, 1], "end": [2761, 6], "kind": "commanddeclaration"}, {"full_name": "List.splitAt_eq_take_drop", "code": "@[simp]\ntheorem splitAt_eq_take_drop (n : \u2115) (l : List \u03b1) : splitAt n l = (take n l, drop n l)", "start": [2778, 1], "end": [2810, 71], "kind": "commanddeclaration"}, {"full_name": "List.splitOn_nil", "code": "@[simp]\ntheorem splitOn_nil {\u03b1 : Type u} [DecidableEq \u03b1] (a : \u03b1) : [].splitOn a = [[]]", "start": [2813, 1], "end": [2815, 6], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_nil", "code": "@[simp]\ntheorem splitOnP_nil : [].splitOnP p = [[]]", "start": [2818, 1], "end": [2820, 6], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP.go_ne_nil", "code": "theorem splitOnP.go_ne_nil (xs acc : List \u03b1) : splitOnP.go p xs acc \u2260 []", "start": [2833, 1], "end": [2834, 66], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP.go_acc", "code": "theorem splitOnP.go_acc (xs acc : List \u03b1) :\n    splitOnP.go p xs acc = modifyHead (acc.reverse ++ \u00b7) (splitOnP p xs)", "start": [2836, 1], "end": [2844, 67], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_ne_nil", "code": "theorem splitOnP_ne_nil (xs : List \u03b1) : xs.splitOnP p \u2260 []", "start": [2846, 1], "end": [2846, 87], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_cons", "code": "@[simp]\ntheorem splitOnP_cons (x : \u03b1) (xs : List \u03b1) :\n    (x :: xs).splitOnP p =\n      if p x then [] :: xs.splitOnP p else (xs.splitOnP p).modifyHead (cons x)", "start": [2849, 1], "end": [2853, 70], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_spec", "code": "theorem splitOnP_spec (as : List \u03b1) :\n    join (zipWith (\u00b7 ++ \u00b7) (splitOnP p as) (((as.filter p).map fun x => [x]) ++ [[]])) = as", "start": [2856, 1], "end": [2875, 57], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_eq_single", "code": "theorem splitOnP_eq_single (h : \u2200 x \u2208 xs, \u00acp x) : xs.splitOnP p = [xs]", "start": [2878, 1], "end": [2885, 8], "kind": "commanddeclaration"}, {"full_name": "List.splitOnP_first", "code": "theorem splitOnP_first (h : \u2200 x \u2208 xs, \u00acp x) (sep : \u03b1) (hsep : p sep) (as : List \u03b1) :\n    (xs ++ sep :: as).splitOnP p = xs :: as.splitOnP p", "start": [2888, 1], "end": [2894, 74], "kind": "commanddeclaration"}, {"full_name": "List.intercalate_splitOn", "code": "theorem intercalate_splitOn (x : \u03b1) [DecidableEq \u03b1] : [x].intercalate (xs.splitOn x) = xs", "start": [2897, 1], "end": [2908, 42], "kind": "commanddeclaration"}, {"full_name": "List.splitOn_intercalate", "code": "theorem splitOn_intercalate [DecidableEq \u03b1] (x : \u03b1) (hx : \u2200 l \u2208 ls, x \u2209 l) (hls : ls \u2260 []) :\n    ([x].intercalate ls).splitOn x = ls", "start": [2911, 1], "end": [2937, 18], "kind": "commanddeclaration"}, {"full_name": "List.modifyLast.go_append_one", "code": "theorem modifyLast.go_append_one (f : \u03b1 \u2192 \u03b1) (a : \u03b1) (tl : List \u03b1) (r : Array \u03b1) :\n    modifyLast.go f (tl ++ [a]) r = (r.toListAppend <| modifyLast.go f (tl ++ [a]) #[])", "start": [2947, 1], "end": [2957, 101], "kind": "commanddeclaration"}, {"full_name": "List.modifyLast_append_one", "code": "theorem modifyLast_append_one (f : \u03b1 \u2192 \u03b1) (a : \u03b1) (l : List \u03b1) :\n    modifyLast f (l ++ [a]) = l ++ [f a]", "start": [2959, 1], "end": [2970, 39], "kind": "commanddeclaration"}, {"full_name": "List.modifyLast_append", "code": "theorem modifyLast_append (f : \u03b1 \u2192 \u03b1) (l\u2081 l\u2082 : List \u03b1) (_ : l\u2082 \u2260 []) :\n    modifyLast f (l\u2081 ++ l\u2082) = l\u2081 ++ modifyLast f l\u2082", "start": [2972, 1], "end": [2983, 42], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_lt_sizeOf_of_mem", "code": "theorem sizeOf_lt_sizeOf_of_mem [SizeOf \u03b1] {x : \u03b1} {l : List \u03b1} (hx : x \u2208 l) :\n    SizeOf.sizeOf x < SizeOf.sizeOf l", "start": [2992, 1], "end": [2997, 36], "kind": "commanddeclaration"}, {"full_name": "List.pmap_eq_map", "code": "@[simp]\ntheorem pmap_eq_map (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) (H) :\n    @pmap _ _ p (fun a _ => f a) l H = map f l", "start": [3000, 1], "end": [3003, 50], "kind": "commanddeclaration"}, {"full_name": "List.pmap_congr", "code": "theorem pmap_congr {p q : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {g : \u2200 a, q a \u2192 \u03b2} (l : List \u03b1) {H\u2081 H\u2082}\n    (h : \u2200 a \u2208 l, \u2200 (h\u2081 h\u2082), f a h\u2081 = g a h\u2082) : pmap f l H\u2081 = pmap g l H\u2082", "start": [3006, 1], "end": [3010, 88], "kind": "commanddeclaration"}, {"full_name": "List.map_pmap", "code": "theorem map_pmap {p : \u03b1 \u2192 Prop} (g : \u03b2 \u2192 \u03b3) (f : \u2200 a, p a \u2192 \u03b2) (l H) :\n    map g (pmap f l H) = pmap (fun a h => g (f a h)) l H", "start": [3013, 1], "end": [3015, 50], "kind": "commanddeclaration"}, {"full_name": "List.pmap_map", "code": "theorem pmap_map {p : \u03b2 \u2192 Prop} (g : \u2200 b, p b \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (l H) :\n    pmap g (map f l) H = pmap (fun a h => g (f a) h) l fun a h => H _ (mem_map_of_mem _ h)", "start": [3018, 1], "end": [3020, 50], "kind": "commanddeclaration"}, {"full_name": "List.pmap_eq_map_attach", "code": "theorem pmap_eq_map_attach {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (l H) :\n    pmap f l H = l.attach.map fun x => f x.1 (H _ x.2)", "start": [3023, 1], "end": [3025, 63], "kind": "commanddeclaration"}, {"full_name": "List.attach_map_coe'", "code": "theorem attach_map_coe' (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (l.attach.map fun (i : {i // i \u2208 l}) => f i) = l.map f", "start": [3029, 1], "end": [3031, 51], "kind": "commanddeclaration"}, {"full_name": "List.attach_map_val'", "code": "theorem attach_map_val' (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) : (l.attach.map fun i => f i.val) = l.map f", "start": [3034, 1], "end": [3035, 22], "kind": "commanddeclaration"}, {"full_name": "List.attach_map_val", "code": "@[simp]\ntheorem attach_map_val (l : List \u03b1) : l.attach.map Subtype.val = l", "start": [3038, 1], "end": [3040, 39], "kind": "commanddeclaration"}, {"full_name": "List.mem_attach", "code": "@[simp]\ntheorem mem_attach (l : List \u03b1) : \u2200 x, x \u2208 l.attach", "start": [3045, 1], "end": [3050, 12], "kind": "commanddeclaration"}, {"full_name": "List.mem_pmap", "code": "@[simp]\ntheorem mem_pmap {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {l H b} :\n    b \u2208 pmap f l H \u2194 \u2203 (a : _) (h : a \u2208 l), f a (H a h) = b", "start": [3053, 1], "end": [3056, 93], "kind": "commanddeclaration"}, {"full_name": "List.length_pmap", "code": "@[simp]\ntheorem length_pmap {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {l H} : length (pmap f l H) = length l", "start": [3059, 1], "end": [3061, 53], "kind": "commanddeclaration"}, {"full_name": "List.length_attach", "code": "@[simp]\ntheorem length_attach (L : List \u03b1) : L.attach.length = L.length", "start": [3064, 1], "end": [3066, 14], "kind": "commanddeclaration"}, {"full_name": "List.pmap_eq_nil", "code": "@[simp]\ntheorem pmap_eq_nil {p : \u03b1 \u2192 Prop} {f : \u2200 a, p a \u2192 \u03b2} {l H} : pmap f l H = [] \u2194 l = []", "start": [3069, 1], "end": [3071, 53], "kind": "commanddeclaration"}, {"full_name": "List.attach_eq_nil", "code": "@[simp]\ntheorem attach_eq_nil (l : List \u03b1) : l.attach = [] \u2194 l = []", "start": [3074, 1], "end": [3076, 14], "kind": "commanddeclaration"}, {"full_name": "List.getLast_pmap", "code": "theorem getLast_pmap {\u03b1 \u03b2 : Type*} (p : \u03b1 \u2192 Prop) (f : \u2200 a, p a \u2192 \u03b2) (l : List \u03b1)\n    (hl\u2081 : \u2200 a \u2208 l, p a) (hl\u2082 : l \u2260 []) :\n    (l.pmap f hl\u2081).getLast (mt List.pmap_eq_nil.1 hl\u2082) =\n      f (l.getLast hl\u2082) (hl\u2081 _ (List.getLast_mem hl\u2082))", "start": [3079, 1], "end": [3089, 37], "kind": "commanddeclaration"}, {"full_name": "List.get?_pmap", "code": "theorem get?_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l : List \u03b1} (h : \u2200 a \u2208 l, p a) (n : \u2115) :\n    get? (pmap f l h) n = Option.pmap f (get? l n) fun x H => h x (get?_mem H)", "start": [3092, 1], "end": [3098, 16], "kind": "commanddeclaration"}, {"full_name": "List.get_pmap", "code": "theorem get_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l : List \u03b1} (h : \u2200 a \u2208 l, p a) {n : \u2115}\n    (hn : n < (pmap f l h).length) :\n    get (pmap f l h) \u27e8n, hn\u27e9 =\n      f (get l \u27e8n, @length_pmap _ _ p f l h \u25b8 hn\u27e9)\n        (h _ (get_mem l n (@length_pmap _ _ p f l h \u25b8 hn)))", "start": [3101, 1], "end": [3111, 16], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_pmap", "code": "@[deprecated get_pmap]\ntheorem nthLe_pmap {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) {l : List \u03b1} (h : \u2200 a \u2208 l, p a) {n : \u2115}\n    (hn : n < (pmap f l h).length) :\n    nthLe (pmap f l h) n hn =\n      f (nthLe l n (@length_pmap _ _ p f l h \u25b8 hn))\n        (h _ (get_mem l n (@length_pmap _ _ p f l h \u25b8 hn)))", "start": [3114, 1], "end": [3120, 14], "kind": "commanddeclaration"}, {"full_name": "List.pmap_append", "code": "theorem pmap_append {p : \u03b9 \u2192 Prop} (f : \u2200 a : \u03b9, p a \u2192 \u03b1) (l\u2081 l\u2082 : List \u03b9)\n    (h : \u2200 a \u2208 l\u2081 ++ l\u2082, p a) :\n    (l\u2081 ++ l\u2082).pmap f h =\n      (l\u2081.pmap f fun a ha => h a (mem_append_left l\u2082 ha)) ++\n        l\u2082.pmap f fun a ha => h a (mem_append_right l\u2081 ha)", "start": [3124, 1], "end": [3132, 12], "kind": "commanddeclaration"}, {"full_name": "List.pmap_append'", "code": "theorem pmap_append' {\u03b1 \u03b2 : Type*} {p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (l\u2081 l\u2082 : List \u03b1)\n    (h\u2081 : \u2200 a \u2208 l\u2081, p a) (h\u2082 : \u2200 a \u2208 l\u2082, p a) :\n    ((l\u2081 ++ l\u2082).pmap f fun a ha => (List.mem_append.1 ha).elim (h\u2081 a) (h\u2082 a)) =\n      l\u2081.pmap f h\u2081 ++ l\u2082.pmap f h\u2082", "start": [3135, 1], "end": [3139, 24], "kind": "commanddeclaration"}, {"full_name": "List.find?_mem", "code": "@[simp]\ntheorem find?_mem (H : find? p l = some a) : a \u2208 l", "start": [3165, 1], "end": [3173, 35], "kind": "commanddeclaration"}, {"full_name": "List.lookmap.go_append", "code": "theorem lookmap.go_append (l : List \u03b1) (acc : Array \u03b1) :\n    lookmap.go f l acc = acc.toListAppend (lookmap f l)", "start": [3185, 1], "end": [3193, 20], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_nil", "code": "@[simp]\ntheorem lookmap_nil : [].lookmap f = []", "start": [3195, 1], "end": [3197, 6], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_cons_none", "code": "@[simp]\ntheorem lookmap_cons_none {a : \u03b1} (l : List \u03b1) (h : f a = none) :\n    (a :: l).lookmap f = a :: l.lookmap f", "start": [3200, 1], "end": [3204, 33], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_cons_some", "code": "@[simp]\ntheorem lookmap_cons_some {a b : \u03b1} (l : List \u03b1) (h : f a = some b) :\n    (a :: l).lookmap f = b :: l", "start": [3207, 1], "end": [3211, 9], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_some", "code": "theorem lookmap_some : \u2200 l : List \u03b1, l.lookmap some = l", "start": [3214, 1], "end": [3216, 18], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_none", "code": "theorem lookmap_none : \u2200 l : List \u03b1, (l.lookmap fun _ => none) = l", "start": [3219, 1], "end": [3221, 86], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_congr", "code": "theorem lookmap_congr {f g : \u03b1 \u2192 Option \u03b1} :\n    \u2200 {l : List \u03b1}, (\u2200 a \u2208 l, f a = g a) \u2192 l.lookmap f = l.lookmap g", "start": [3224, 1], "end": [3231, 73], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_of_forall_not", "code": "theorem lookmap_of_forall_not {l : List \u03b1} (H : \u2200 a \u2208 l, f a = none) : l.lookmap f = l", "start": [3234, 1], "end": [3235, 43], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_map_eq", "code": "theorem lookmap_map_eq (g : \u03b1 \u2192 \u03b2) (h : \u2200 (a), \u2200 b \u2208 f a, g a = g b) :\n    \u2200 l : List \u03b1, map g (l.lookmap f) = map g l", "start": [3238, 1], "end": [3244, 48], "kind": "commanddeclaration"}, {"full_name": "List.lookmap_id'", "code": "theorem lookmap_id' (h : \u2200 (a), \u2200 b \u2208 f a, a = b) (l : List \u03b1) : l.lookmap f = l", "start": [3247, 1], "end": [3248, 63], "kind": "commanddeclaration"}, {"full_name": "List.length_lookmap", "code": "theorem length_lookmap (l : List \u03b1) : length (l.lookmap f) = length l", "start": [3251, 1], "end": [3252, 68], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.map", "code": "theorem Sublist.map (f : \u03b1 \u2192 \u03b2) {l\u2081 l\u2082 : List \u03b1} (s : l\u2081 <+ l\u2082) : map f l\u2081 <+ map f l\u2082", "start": [3307, 1], "end": [3308, 37], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_cons_of_some", "code": "@[simp]\ntheorem reduceOption_cons_of_some (x : \u03b1) (l : List (Option \u03b1)) :\n    reduceOption (some x :: l) = x :: l.reduceOption", "start": [3313, 1], "end": [3316, 78], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_cons_of_none", "code": "@[simp]\ntheorem reduceOption_cons_of_none (l : List (Option \u03b1)) :\n    reduceOption (none :: l) = l.reduceOption", "start": [3319, 1], "end": [3321, 96], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_nil", "code": "@[simp]\ntheorem reduceOption_nil : @reduceOption \u03b1 [] = []", "start": [3324, 1], "end": [3326, 6], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_map", "code": "@[simp]\ntheorem reduceOption_map {l : List (Option \u03b1)} {f : \u03b1 \u2192 \u03b2} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l)", "start": [3329, 1], "end": [3336, 44], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_append", "code": "theorem reduceOption_append (l l' : List (Option \u03b1)) :\n    (l ++ l').reduceOption = l.reduceOption ++ l'.reduceOption", "start": [3339, 1], "end": [3341, 27], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_length_le", "code": "theorem reduceOption_length_le (l : List (Option \u03b1)) : l.reduceOption.length \u2264 l.length", "start": [3344, 1], "end": [3349, 84], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_length_eq_iff", "code": "theorem reduceOption_length_eq_iff {l : List (Option \u03b1)} :\n    l.reduceOption.length = l.length \u2194 \u2200 x \u2208 l, Option.isSome x", "start": [3352, 1], "end": [3365, 38], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_length_lt_iff", "code": "theorem reduceOption_length_lt_iff {l : List (Option \u03b1)} :\n    l.reduceOption.length < l.length \u2194 none \u2208 l", "start": [3368, 1], "end": [3373, 35], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_singleton", "code": "theorem reduceOption_singleton (x : Option \u03b1) : [x].reduceOption = x.toList", "start": [3376, 1], "end": [3376, 98], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_concat", "code": "theorem reduceOption_concat (l : List (Option \u03b1)) (x : Option \u03b1) :\n    (l.concat x).reduceOption = l.reduceOption ++ x.toList", "start": [3379, 1], "end": [3384, 48], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_concat_of_some", "code": "theorem reduceOption_concat_of_some (l : List (Option \u03b1)) (x : \u03b1) :\n    (l.concat (some x)).reduceOption = l.reduceOption.concat x", "start": [3387, 1], "end": [3389, 97], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_mem_iff", "code": "theorem reduceOption_mem_iff {l : List (Option \u03b1)} {x : \u03b1} : x \u2208 l.reduceOption \u2194 some x \u2208 l", "start": [3392, 1], "end": [3393, 67], "kind": "commanddeclaration"}, {"full_name": "List.reduceOption_get?_iff", "code": "theorem reduceOption_get?_iff {l : List (Option \u03b1)} {x : \u03b1} :\n    (\u2203 i, l.get? i = some (some x)) \u2194 \u2203 i, l.reduceOption.get? i = some x", "start": [3396, 1], "end": [3398, 60], "kind": "commanddeclaration"}, {"full_name": "List.filter_singleton", "code": "theorem filter_singleton {a : \u03b1} : [a].filter p = bif p a then [a] else []", "start": [3410, 1], "end": [3411, 6], "kind": "commanddeclaration"}, {"full_name": "List.filter_eq_foldr", "code": "theorem filter_eq_foldr (p : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    filter p l = foldr (fun a out => bif p a then a :: out else out) [] l", "start": [3414, 1], "end": [3416, 40], "kind": "commanddeclaration"}, {"full_name": "List.filter_subset", "code": "@[simp]\ntheorem filter_subset (l : List \u03b1) : filter p l \u2286 l", "start": [3421, 1], "end": [3423, 28], "kind": "commanddeclaration"}, {"full_name": "List.of_mem_filter", "code": "theorem of_mem_filter {a : \u03b1} : \u2200 {l}, a \u2208 filter p l \u2192 p a", "start": [3426, 1], "end": [3432, 80], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_filter", "code": "theorem mem_of_mem_filter {a : \u03b1} {l} (h : a \u2208 filter p l) : a \u2208 l", "start": [3435, 1], "end": [3436, 20], "kind": "commanddeclaration"}, {"full_name": "List.mem_filter_of_mem", "code": "theorem mem_filter_of_mem {a : \u03b1} : \u2200 {l}, a \u2208 l \u2192 p a \u2192 a \u2208 filter p l", "start": [3439, 1], "end": [3444, 50], "kind": "commanddeclaration"}, {"full_name": "List.monotone_filter_left", "code": "theorem monotone_filter_left (p : \u03b1 \u2192 Bool) \u2983l l' : List \u03b1\u2984 (h : l \u2286 l') :\n    filter p l \u2286 filter p l'", "start": [3449, 1], "end": [3453, 30], "kind": "commanddeclaration"}, {"full_name": "List.monotone_filter_right", "code": "theorem monotone_filter_right (l : List \u03b1) \u2983p q : \u03b1 \u2192 Bool\u2984\n    (h : \u2200 a, p a \u2192 q a) : l.filter p <+ l.filter q", "start": [3466, 1], "end": [3478, 17], "kind": "commanddeclaration"}, {"full_name": "List.filter_true", "code": "@[simp]\ntheorem filter_true (l : List \u03b1) :\n    filter (fun _ => true) l = l", "start": [3485, 1], "end": [3487, 72], "kind": "commanddeclaration"}, {"full_name": "List.filter_false", "code": "@[simp]\ntheorem filter_false (l : List \u03b1) :\n    filter (fun _ => false) l = []", "start": [3490, 1], "end": [3492, 74], "kind": "commanddeclaration"}, {"full_name": "List.span.loop_eq_take_drop", "code": "theorem span.loop_eq_take_drop :\n    \u2200 l\u2081 l\u2082 : List \u03b1, span.loop p l\u2081 l\u2082 = (l\u2082.reverse ++ takeWhile p l\u2081, dropWhile p l\u2081)", "start": [3496, 1], "end": [3500, 90], "kind": "commanddeclaration"}, {"full_name": "List.span_eq_take_drop", "code": "@[simp]\ntheorem span_eq_take_drop (l : List \u03b1) : span p l = (takeWhile p l, dropWhile p l)", "start": [3502, 1], "end": [3504, 44], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile_nthLe_zero_not", "code": "theorem dropWhile_nthLe_zero_not (l : List \u03b1) (hl : 0 < (l.dropWhile p).length) :\n    \u00acp ((l.dropWhile p).nthLe 0 hl)", "start": [3509, 1], "end": [3516, 28], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile_eq_nil_iff", "code": "@[simp]\ntheorem dropWhile_eq_nil_iff : dropWhile p l = [] \u2194 \u2200 x \u2208 l, p x", "start": [3524, 1], "end": [3528, 51], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_nil", "code": "@[simp] theorem takeWhile_nil : List.takeWhile p [] = []", "start": [3531, 1], "end": [3531, 64], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_cons", "code": "theorem takeWhile_cons {x : \u03b1} :\n    List.takeWhile p (x :: l) = (match p x with\n      | true  => x :: takeWhile p l\n      | false => [])", "start": [3533, 1], "end": [3537, 6], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_cons_of_pos", "code": "theorem takeWhile_cons_of_pos {x : \u03b1} (h : p x) :\n    List.takeWhile p (x :: l) = x :: takeWhile p l", "start": [3539, 1], "end": [3541, 27], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_cons_of_neg", "code": "theorem takeWhile_cons_of_neg {x : \u03b1} (h : \u00ac p x) :\n    List.takeWhile p (x :: l) = []", "start": [3543, 1], "end": [3545, 27], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_eq_self_iff", "code": "@[simp]\ntheorem takeWhile_eq_self_iff : takeWhile p l = l \u2194 \u2200 x \u2208 l, p x", "start": [3547, 1], "end": [3551, 56], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_eq_nil_iff", "code": "@[simp]\ntheorem takeWhile_eq_nil_iff : takeWhile p l = [] \u2194 \u2200 hl : 0 < l.length, \u00acp (l.nthLe 0 hl)", "start": [3554, 1], "end": [3560, 68], "kind": "commanddeclaration"}, {"full_name": "List.mem_takeWhile_imp", "code": "theorem mem_takeWhile_imp {x : \u03b1} (hx : x \u2208 takeWhile p l) : p x", "start": [3563, 1], "end": [3571, 20], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_takeWhile", "code": "theorem takeWhile_takeWhile (p q : \u03b1 \u2192 Bool) (l : List \u03b1) :\n    takeWhile p (takeWhile q l) = takeWhile (fun a => p a \u2227 q a) l", "start": [3574, 1], "end": [3578, 79], "kind": "commanddeclaration"}, {"full_name": "List.takeWhile_idem", "code": "theorem takeWhile_idem : takeWhile p (takeWhile p l) = takeWhile p l", "start": [3581, 1], "end": [3582, 63], "kind": "commanddeclaration"}, {"full_name": "List.length_eraseP_add_one", "code": "@[simp]\ntheorem length_eraseP_add_one {l : List \u03b1} {a} (al : a \u2208 l) (pa : p a) :\n    (l.eraseP p).length + 1 = l.length", "start": [3603, 1], "end": [3608, 6], "kind": "commanddeclaration"}, {"full_name": "List.length_erase_add_one", "code": "@[simp] theorem length_erase_add_one {a : \u03b1} {l : List \u03b1} (h : a \u2208 l) :\n    (l.erase a).length + 1 = l.length", "start": [3639, 1], "end": [3641, 69], "kind": "commanddeclaration"}, {"full_name": "List.map_erase", "code": "theorem map_erase [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (finj : Injective f) {a : \u03b1} (l : List \u03b1) :\n    map f (l.erase a) = (map f l).erase (f a)", "start": [3655, 1], "end": [3658, 65], "kind": "commanddeclaration"}, {"full_name": "List.map_foldl_erase", "code": "theorem map_foldl_erase [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (finj : Injective f) {l\u2081 l\u2082 : List \u03b1} :\n    map f (foldl List.erase l\u2081 l\u2082) = foldl (fun l a => l.erase (f a)) (map f l\u2081) l\u2082", "start": [3661, 1], "end": [3663, 84], "kind": "commanddeclaration"}, {"full_name": "List.map_diff", "code": "@[simp]\ntheorem map_diff [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (finj : Injective f) {l\u2081 l\u2082 : List \u03b1} :\n    map f (l\u2081.diff l\u2082) = (map f l\u2081).diff (map f l\u2082)", "start": [3694, 1], "end": [3697, 61], "kind": "commanddeclaration"}, {"full_name": "List.erase_diff_erase_sublist_of_sublist", "code": "theorem erase_diff_erase_sublist_of_sublist {a : \u03b1} :\n    \u2200 {l\u2081 l\u2082 : List \u03b1}, l\u2081 <+ l\u2082 \u2192 (l\u2082.erase a).diff (l\u2081.erase a) <+ l\u2082.diff l\u2081", "start": [3708, 1], "end": [3718, 70], "kind": "commanddeclaration"}, {"full_name": "List.length_enumFrom", "code": "theorem length_enumFrom : \u2200 (n) (l : List \u03b1), length (enumFrom n l) = length l", "start": [3725, 1], "end": [3727, 58], "kind": "commanddeclaration"}, {"full_name": "List.length_enum", "code": "theorem length_enum : \u2200 l : List \u03b1, length (enum l) = length l", "start": [3730, 1], "end": [3731, 20], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_get?", "code": "@[simp]\ntheorem enumFrom_get? :\n    \u2200 (n) (l : List \u03b1) (m), get? (enumFrom n l) m = (fun a => (n + m, a)) <$> get? l m", "start": [3734, 1], "end": [3739, 89], "kind": "commanddeclaration"}, {"full_name": "List.enum_get?", "code": "@[simp]\ntheorem enum_get? : \u2200 (l : List \u03b1) (n), get? (enum l) n = (fun a => (n, a)) <$> get? l n", "start": [3742, 1], "end": [3744, 61], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_map_snd", "code": "@[simp]\ntheorem enumFrom_map_snd : \u2200 (n) (l : List \u03b1), map Prod.snd (enumFrom n l) = l", "start": [3747, 1], "end": [3750, 59], "kind": "commanddeclaration"}, {"full_name": "List.enum_map_snd", "code": "@[simp]\ntheorem enum_map_snd : \u2200 l : List \u03b1, map Prod.snd (enum l) = l", "start": [3753, 1], "end": [3755, 21], "kind": "commanddeclaration"}, {"full_name": "List.mem_enumFrom", "code": "theorem mem_enumFrom {x : \u03b1} {i : \u2115} :\n    \u2200 {j : \u2115} (xs : List \u03b1), (i, x) \u2208 xs.enumFrom j \u2192 j \u2264 i \u2227 i < j + xs.length \u2227 x \u2208 xs", "start": [3758, 1], "end": [3774, 20], "kind": "commanddeclaration"}, {"full_name": "List.enum_nil", "code": "@[simp]\ntheorem enum_nil : enum ([] : List \u03b1) = []", "start": [3777, 1], "end": [3779, 6], "kind": "commanddeclaration"}, {"full_name": "List.enum_cons", "code": "@[simp]\ntheorem enum_cons (x : \u03b1) (xs : List \u03b1) : enum (x :: xs) = (0, x) :: enumFrom 1 xs", "start": [3786, 1], "end": [3788, 6], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_singleton", "code": "@[simp]\ntheorem enumFrom_singleton (x : \u03b1) (n : \u2115) : enumFrom n [x] = [(n, x)]", "start": [3791, 1], "end": [3793, 6], "kind": "commanddeclaration"}, {"full_name": "List.enum_singleton", "code": "@[simp]\ntheorem enum_singleton (x : \u03b1) : enum [x] = [(0, x)]", "start": [3796, 1], "end": [3798, 6], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_append", "code": "theorem enumFrom_append (xs ys : List \u03b1) (n : \u2115) :\n    enumFrom n (xs ++ ys) = enumFrom n xs ++ enumFrom (n + xs.length) ys", "start": [3801, 1], "end": [3806, 17], "kind": "commanddeclaration"}, {"full_name": "List.enum_append", "code": "theorem enum_append (xs ys : List \u03b1) : enum (xs ++ ys) = enum xs ++ enumFrom xs.length ys", "start": [3809, 1], "end": [3810, 31], "kind": "commanddeclaration"}, {"full_name": "List.map_fst_add_enumFrom_eq_enumFrom", "code": "theorem map_fst_add_enumFrom_eq_enumFrom (l : List \u03b1) (n k : \u2115) :\n    map (Prod.map (\u00b7 + n) id) (enumFrom k l) = enumFrom (n + k) l", "start": [3813, 1], "end": [3818, 54], "kind": "commanddeclaration"}, {"full_name": "List.map_fst_add_enum_eq_enumFrom", "code": "theorem map_fst_add_enum_eq_enumFrom (l : List \u03b1) (n : \u2115) :\n    map (Prod.map (\u00b7 + n) id) (enum l) = enumFrom n l", "start": [3821, 1], "end": [3823, 41], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_cons'", "code": "theorem enumFrom_cons' (n : \u2115) (x : \u03b1) (xs : List \u03b1) :\n    enumFrom n (x :: xs) = (n, x) :: (enumFrom n xs).map (Prod.map Nat.succ id)", "start": [3826, 1], "end": [3828, 67], "kind": "commanddeclaration"}, {"full_name": "List.enum_cons'", "code": "theorem enum_cons' (x : \u03b1) (xs : List \u03b1) :\n    enum (x :: xs) = (0, x) :: (enum xs).map (Prod.map Nat.succ id)", "start": [3831, 1], "end": [3833, 23], "kind": "commanddeclaration"}, {"full_name": "List.enumFrom_map", "code": "theorem enumFrom_map (n : \u2115) (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    enumFrom n (l.map f) = (enumFrom n l).map (Prod.map id f)", "start": [3836, 1], "end": [3841, 8], "kind": "commanddeclaration"}, {"full_name": "List.enum_map", "code": "theorem enum_map (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) : (l.map f).enum = l.enum.map (Prod.map id f)", "start": [3844, 1], "end": [3845, 21], "kind": "commanddeclaration"}, {"full_name": "List.get_enumFrom", "code": "theorem get_enumFrom (l : List \u03b1) (n) (i : Fin (l.enumFrom n).length)\n    (hi : i.1 < l.length := (by simpa [length_enumFrom] using i.2)) :\n    (l.enumFrom n).get i = (n + i, l.get \u27e8i, hi\u27e9)", "start": [3848, 1], "end": [3852, 39], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_enumFrom", "code": "@[deprecated get_enumFrom]\ntheorem nthLe_enumFrom (l : List \u03b1) (n i : \u2115) (hi' : i < (l.enumFrom n).length)\n    (hi : i < l.length := (by simpa [length_enumFrom] using hi')) :\n    (l.enumFrom n).nthLe i hi' = (n + i, l.nthLe i hi)", "start": [3855, 1], "end": [3859, 18], "kind": "commanddeclaration"}, {"full_name": "List.get_enum", "code": "theorem get_enum (l : List \u03b1) (i : Fin l.enum.length)\n    (hi : i < l.length := (by simpa [length_enum] using i.2)) :\n    l.enum.get i = (i.1, l.get \u27e8i, hi\u27e9)", "start": [3862, 1], "end": [3866, 26], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_enum", "code": "@[deprecated get_enum]\ntheorem nthLe_enum (l : List \u03b1) (i : \u2115) (hi' : i < l.enum.length)\n    (hi : i < l.length := (by simpa [length_enum] using hi')) :\n    l.enum.nthLe i hi' = (i, l.nthLe i hi)", "start": [3869, 1], "end": [3872, 58], "kind": "commanddeclaration"}, {"full_name": "List.choose_spec", "code": "theorem choose_spec (hp : \u2203 a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l \u2227 p (choose p l hp)", "start": [3879, 1], "end": [3880, 28], "kind": "commanddeclaration"}, {"full_name": "List.choose_mem", "code": "theorem choose_mem (hp : \u2203 a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l", "start": [3883, 1], "end": [3884, 24], "kind": "commanddeclaration"}, {"full_name": "List.choose_property", "code": "theorem choose_property (hp : \u2203 a, a \u2208 l \u2227 p a) : p (choose p l hp)", "start": [3887, 1], "end": [3888, 24], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left'_nil_right", "code": "@[simp]\ntheorem map\u2082Left'_nil_right (f : \u03b1 \u2192 Option \u03b2 \u2192 \u03b3) (as) :\n    map\u2082Left' f as [] = (as.map fun a => f a none, [])", "start": [3899, 1], "end": [3901, 78], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right'_nil_left", "code": "@[simp]\ntheorem map\u2082Right'_nil_left : map\u2082Right' f [] bs = (bs.map (f none), [])", "start": [3912, 1], "end": [3913, 96], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right'_nil_right", "code": "@[simp]\ntheorem map\u2082Right'_nil_right : map\u2082Right' f as [] = ([], as)", "start": [3916, 1], "end": [3918, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right'_nil_cons", "code": "theorem map\u2082Right'_nil_cons : map\u2082Right' f [] (b :: bs) = (f none b :: bs.map (f none), [])", "start": [3923, 1], "end": [3924, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right'_cons_cons", "code": "@[simp]\ntheorem map\u2082Right'_cons_cons :\n    map\u2082Right' f (a :: as) (b :: bs) =\n      let r := map\u2082Right' f as bs\n      (f (some a) b :: r.fst, r.snd)", "start": [3927, 1], "end": [3932, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft'_nil_right", "code": "@[simp]\ntheorem zipLeft'_nil_right : zipLeft' as ([] : List \u03b2) = (as.map fun a => (a, none), [])", "start": [3943, 1], "end": [3945, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft'_nil_left", "code": "@[simp]\ntheorem zipLeft'_nil_left : zipLeft' ([] : List \u03b1) bs = ([], bs)", "start": [3948, 1], "end": [3950, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft'_cons_nil", "code": "theorem zipLeft'_cons_nil :\n    zipLeft' (a :: as) ([] : List \u03b2) = ((a, none) :: as.map fun a => (a, none), [])", "start": [3955, 1], "end": [3957, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft'_cons_cons", "code": "@[simp]\ntheorem zipLeft'_cons_cons :\n    zipLeft' (a :: as) (b :: bs) =\n      let r := zipLeft' as bs\n      ((a, some b) :: r.fst, r.snd)", "start": [3960, 1], "end": [3965, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight'_nil_left", "code": "@[simp]\ntheorem zipRight'_nil_left : zipRight' ([] : List \u03b1) bs = (bs.map fun b => (none, b), [])", "start": [3976, 1], "end": [3978, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipRight'_nil_right", "code": "@[simp]\ntheorem zipRight'_nil_right : zipRight' as ([] : List \u03b2) = ([], as)", "start": [3981, 1], "end": [3983, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight'_nil_cons", "code": "theorem zipRight'_nil_cons :\n    zipRight' ([] : List \u03b1) (b :: bs) = ((none, b) :: bs.map fun b => (none, b), [])", "start": [3988, 1], "end": [3990, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight'_cons_cons", "code": "@[simp]\ntheorem zipRight'_cons_cons :\n    zipRight' (a :: as) (b :: bs) =\n      let r := zipRight' as bs\n      ((some a, b) :: r.fst, r.snd)", "start": [3993, 1], "end": [3998, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left_nil_right", "code": "@[simp]\ntheorem map\u2082Left_nil_right : map\u2082Left f as [] = as.map fun a => f a none", "start": [4011, 1], "end": [4012, 96], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left_eq_map\u2082Left'", "code": "theorem map\u2082Left_eq_map\u2082Left' : \u2200 as bs, map\u2082Left f as bs = (map\u2082Left' f as bs).fst", "start": [4015, 1], "end": [4018, 56], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Left_eq_zipWith", "code": "theorem map\u2082Left_eq_zipWith :\n    \u2200 as bs, length as \u2264 length bs \u2192 map\u2082Left f as bs = zipWith (fun a b => f a (some b)) as bs", "start": [4021, 1], "end": [4029, 34], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_nil_left", "code": "@[simp]\ntheorem map\u2082Right_nil_left : map\u2082Right f [] bs = bs.map (f none)", "start": [4040, 1], "end": [4041, 88], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_nil_right", "code": "@[simp]\ntheorem map\u2082Right_nil_right : map\u2082Right f as [] = []", "start": [4044, 1], "end": [4046, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_nil_cons", "code": "theorem map\u2082Right_nil_cons : map\u2082Right f [] (b :: bs) = f none b :: bs.map (f none)", "start": [4051, 1], "end": [4052, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_cons_cons", "code": "@[simp]\ntheorem map\u2082Right_cons_cons :\n    map\u2082Right f (a :: as) (b :: bs) = f (some a) b :: map\u2082Right f as bs", "start": [4055, 1], "end": [4058, 6], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_eq_map\u2082Right'", "code": "theorem map\u2082Right_eq_map\u2082Right' : map\u2082Right f as bs = (map\u2082Right' f as bs).fst", "start": [4061, 1], "end": [4062, 59], "kind": "commanddeclaration"}, {"full_name": "List.map\u2082Right_eq_zipWith", "code": "theorem map\u2082Right_eq_zipWith (h : length bs \u2264 length as) :\n    map\u2082Right f as bs = zipWith (fun a b => f (some a) b) as bs", "start": [4065, 1], "end": [4068, 62], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft_nil_right", "code": "@[simp]\ntheorem zipLeft_nil_right : zipLeft as ([] : List \u03b2) = as.map fun a => (a, none)", "start": [4079, 1], "end": [4081, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft_nil_left", "code": "@[simp]\ntheorem zipLeft_nil_left : zipLeft ([] : List \u03b1) bs = []", "start": [4084, 1], "end": [4086, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft_cons_nil", "code": "theorem zipLeft_cons_nil :\n    zipLeft (a :: as) ([] : List \u03b2) = (a, none) :: as.map fun a => (a, none)", "start": [4091, 1], "end": [4093, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft_cons_cons", "code": "@[simp]\ntheorem zipLeft_cons_cons : zipLeft (a :: as) (b :: bs) = (a, some b) :: zipLeft as bs", "start": [4096, 1], "end": [4098, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipLeft_eq_zipLeft'", "code": "theorem zipLeft_eq_zipLeft' (as : List \u03b1) (bs : List \u03b2) : zipLeft as bs = (zipLeft' as bs).fst", "start": [4102, 1], "end": [4109, 97], "kind": "commanddeclaration"}, {"full_name": "List.zipRight_nil_left", "code": "@[simp]\ntheorem zipRight_nil_left : zipRight ([] : List \u03b1) bs = bs.map fun b => (none, b)", "start": [4120, 1], "end": [4122, 19], "kind": "commanddeclaration"}, {"full_name": "List.zipRight_nil_right", "code": "@[simp]\ntheorem zipRight_nil_right : zipRight as ([] : List \u03b2) = []", "start": [4125, 1], "end": [4127, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight_nil_cons", "code": "theorem zipRight_nil_cons :\n    zipRight ([] : List \u03b1) (b :: bs) = (none, b) :: bs.map fun b => (none, b)", "start": [4132, 1], "end": [4134, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight_cons_cons", "code": "@[simp]\ntheorem zipRight_cons_cons : zipRight (a :: as) (b :: bs) = (some a, b) :: zipRight as bs", "start": [4137, 1], "end": [4139, 6], "kind": "commanddeclaration"}, {"full_name": "List.zipRight_eq_zipRight'", "code": "theorem zipRight_eq_zipRight' : zipRight as bs = (zipRight' as bs).fst", "start": [4142, 1], "end": [4143, 57], "kind": "commanddeclaration"}, {"full_name": "List.all\u2082_cons", "code": "@[simp]\ntheorem all\u2082_cons (p : \u03b1 \u2192 Prop) (x : \u03b1) : \u2200 l : List \u03b1, All\u2082 p (x :: l) \u2194 p x \u2227 All\u2082 p l", "start": [4169, 1], "end": [4172, 22], "kind": "commanddeclaration"}, {"full_name": "List.all\u2082_iff_forall", "code": "theorem all\u2082_iff_forall : \u2200 {l : List \u03b1}, All\u2082 p l \u2194 \u2200 x \u2208 l, p x", "start": [4175, 1], "end": [4177, 66], "kind": "commanddeclaration"}, {"full_name": "List.All\u2082.imp", "code": "theorem All\u2082.imp (h : \u2200 x, p x \u2192 q x) : \u2200 {l : List \u03b1}, All\u2082 p l \u2192 All\u2082 q l", "start": [4180, 1], "end": [4182, 71], "kind": "commanddeclaration"}, {"full_name": "List.all\u2082_map_iff", "code": "@[simp]\ntheorem all\u2082_map_iff {p : \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) : All\u2082 p (l.map f) \u2194 All\u2082 (p \u2218 f) l", "start": [4185, 1], "end": [4187, 27], "kind": "commanddeclaration"}, {"full_name": "List.getLast_reverse", "code": "theorem getLast_reverse {l : List \u03b1} (hl : l.reverse \u2260 [])\n    (hl' : 0 < l.length := (by\n      contrapose! hl\n      simpa [length_eq_zero] using hl)) :\n    l.reverse.getLast hl = l.get \u27e80, hl'\u27e9", "start": [4206, 1], "end": [4213, 20], "kind": "commanddeclaration"}, {"full_name": "List.ilast'_mem", "code": "theorem ilast'_mem : \u2200 a l, @ilast' \u03b1 a l \u2208 a :: l", "start": [4216, 1], "end": [4218, 65], "kind": "commanddeclaration"}, {"full_name": "List.get_attach", "code": "@[simp]\ntheorem get_attach (L : List \u03b1) (i) :\n    (L.attach.get i).1 = L.get \u27e8i, length_attach L \u25b8 i.2\u27e9", "start": [4221, 1], "end": [4227, 61], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_attach", "code": "@[simp, deprecated get_attach]\ntheorem nthLe_attach (L : List \u03b1) (i) (H : i < L.attach.length) :\n    (L.attach.nthLe i H).1 = L.nthLe i (length_attach L \u25b8 H)", "start": [4229, 1], "end": [4231, 78], "kind": "commanddeclaration"}, {"full_name": "List.mem_map_swap", "code": "@[simp 1100]\ntheorem mem_map_swap (x : \u03b1) (y : \u03b2) (xs : List (\u03b1 \u00d7 \u03b2)) :\n    (y, x) \u2208 map Prod.swap xs \u2194 (x, y) \u2208 xs", "start": [4234, 1], "end": [4240, 96], "kind": "commanddeclaration"}, {"full_name": "List.dropSlice_eq", "code": "theorem dropSlice_eq (xs : List \u03b1) (n m : \u2115) : dropSlice n m xs = xs.take n ++ xs.drop (n + m)", "start": [4243, 1], "end": [4246, 51], "kind": "commanddeclaration"}, {"full_name": "List.sizeOf_dropSlice_lt", "code": "theorem sizeOf_dropSlice_lt [SizeOf \u03b1] (i j : \u2115) (hj : 0 < j) (xs : List \u03b1) (hi : i < xs.length) :\n    SizeOf.sizeOf (List.dropSlice i j xs) < SizeOf.sizeOf xs", "start": [4249, 1], "end": [4270, 34], "kind": "commanddeclaration"}, {"full_name": "List.getD_nil", "code": "@[simp]\ntheorem getD_nil : getD [] n d = d", "start": [4279, 1], "end": [4281, 6], "kind": "commanddeclaration"}, {"full_name": "List.getD_cons_zero", "code": "@[simp]\ntheorem getD_cons_zero : getD (x :: xs) 0 d = x", "start": [4284, 1], "end": [4286, 6], "kind": "commanddeclaration"}, {"full_name": "List.getD_cons_succ", "code": "@[simp]\ntheorem getD_cons_succ : getD (x :: xs) (n + 1) d = getD xs n d", "start": [4289, 1], "end": [4291, 6], "kind": "commanddeclaration"}, {"full_name": "List.getD_eq_get", "code": "theorem getD_eq_get {n : \u2115} (hn : n < l.length) : l.getD n d = l.get \u27e8n, hn\u27e9", "start": [4294, 1], "end": [4300, 17], "kind": "commanddeclaration"}, {"full_name": "List.getD_map", "code": "@[simp]\ntheorem getD_map {n : \u2115} (f : \u03b1 \u2192 \u03b2) : (map f l).getD n (f d) = f (l.getD n d)", "start": [4302, 1], "end": [4309, 16], "kind": "commanddeclaration"}, {"full_name": "List.getD_eq_nthLe", "code": "@[deprecated getD_eq_get]\ntheorem getD_eq_nthLe {n : \u2115} (hn : n < l.length) : l.getD n d = l.nthLe n hn", "start": [4312, 1], "end": [4314, 17], "kind": "commanddeclaration"}, {"full_name": "List.getD_eq_default", "code": "theorem getD_eq_default {n : \u2115} (hn : l.length \u2264 n) : l.getD n d = d", "start": [4317, 1], "end": [4323, 43], "kind": "commanddeclaration"}, {"full_name": "List.decidableGetDNilNe", "code": "def decidableGetDNilNe {\u03b1} (a : \u03b1) : DecidablePred fun i : \u2115 => getD ([] : List \u03b1) i a \u2260 a :=\n  fun _ => isFalse fun H => H (getD_nil _ _)", "start": [4326, 1], "end": [4329, 45], "kind": "commanddeclaration"}, {"full_name": "List.getD_singleton_default_eq", "code": "@[simp]\ntheorem getD_singleton_default_eq (n : \u2115) : [d].getD n d = d", "start": [4332, 1], "end": [4333, 84], "kind": "commanddeclaration"}, {"full_name": "List.getD_replicate_default_eq", "code": "@[simp]\ntheorem getD_replicate_default_eq (r n : \u2115) : (replicate r d).getD n d = d", "start": [4336, 1], "end": [4340, 39], "kind": "commanddeclaration"}, {"full_name": "List.getD_append", "code": "theorem getD_append (l l' : List \u03b1) (d : \u03b1) (n : \u2115) (h : n < l.length)\n    (h' : n < (l ++ l').length := h.trans_le ((length_append l l').symm \u25b8 le_self_add)) :\n    (l ++ l').getD n d = l.getD n d", "start": [4343, 1], "end": [4346, 55], "kind": "commanddeclaration"}, {"full_name": "List.getD_append_right", "code": "theorem getD_append_right (l l' : List \u03b1) (d : \u03b1) (n : \u2115) (h : l.length \u2264 n) :\n    (l ++ l').getD n d = l'.getD (n - l.length) d", "start": [4349, 1], "end": [4359, 46], "kind": "commanddeclaration"}, {"full_name": "List.getD_eq_getD_get?", "code": "theorem getD_eq_getD_get? (n : \u2115) : l.getD n d = (l.get? n).getD d", "start": [4362, 1], "end": [4365, 78], "kind": "commanddeclaration"}, {"full_name": "List.getI_nil", "code": "@[simp]\ntheorem getI_nil : getI ([] : List \u03b1) n = default", "start": [4374, 1], "end": [4376, 6], "kind": "commanddeclaration"}, {"full_name": "List.getI_cons_zero", "code": "@[simp]\ntheorem getI_cons_zero : getI (x :: xs) 0 = x", "start": [4379, 1], "end": [4381, 6], "kind": "commanddeclaration"}, {"full_name": "List.getI_cons_succ", "code": "@[simp]\ntheorem getI_cons_succ : getI (x :: xs) (n + 1) = getI xs n", "start": [4384, 1], "end": [4386, 6], "kind": "commanddeclaration"}, {"full_name": "List.getI_eq_get", "code": "theorem getI_eq_get {n : \u2115} (hn : n < l.length) : l.getI n = l.get \u27e8n, hn\u27e9", "start": [4389, 1], "end": [4390, 17], "kind": "commanddeclaration"}, {"full_name": "List.getI_eq_nthLe", "code": "@[deprecated getI_eq_get]\ntheorem getI_eq_nthLe {n : \u2115} (hn : n < l.length) : l.getI n = l.nthLe n hn", "start": [4392, 1], "end": [4394, 17], "kind": "commanddeclaration"}, {"full_name": "List.getI_eq_default", "code": "theorem getI_eq_default {n : \u2115} (hn : l.length \u2264 n) : l.getI n = default", "start": [4397, 1], "end": [4398, 25], "kind": "commanddeclaration"}, {"full_name": "List.getD_default_eq_getI", "code": "theorem getD_default_eq_getI {n : \u2115} : l.getD n default = l.getI n", "start": [4401, 1], "end": [4402, 6], "kind": "commanddeclaration"}, {"full_name": "List.getI_append", "code": "theorem getI_append (l l' : List \u03b1) (n : \u2115) (h : n < l.length)\n    (h' : n < (l ++ l').length := h.trans_le ((length_append l l').symm \u25b8 le_self_add)) :\n    (l ++ l').getI n = l.getI n", "start": [4405, 1], "end": [4408, 27], "kind": "commanddeclaration"}, {"full_name": "List.getI_append_right", "code": "theorem getI_append_right (l l' : List \u03b1) (n : \u2115) (h : l.length \u2264 n) :\n    (l ++ l').getI n = l'.getI (n - l.length)", "start": [4411, 1], "end": [4413, 30], "kind": "commanddeclaration"}, {"full_name": "List.getI_eq_iget_get?", "code": "theorem getI_eq_iget_get? (n : \u2115) : l.getI n = (l.get? n).iget", "start": [4416, 1], "end": [4417, 78], "kind": "commanddeclaration"}, {"full_name": "List.getI_zero_eq_headI", "code": "theorem getI_zero_eq_headI : l.getI 0 = l.headI", "start": [4420, 1], "end": [4420, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Basic.lean", "imports": ["Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Group/OrderSynonym.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "left_ne_zero_of_mul", "code": "theorem left_ne_zero_of_mul : a * b \u2260 0 \u2192 a \u2260 0", "start": [51, 1], "end": [52, 38], "kind": "commanddeclaration"}, {"full_name": "right_ne_zero_of_mul", "code": "theorem right_ne_zero_of_mul : a * b \u2260 0 \u2192 b \u2260 0", "start": [55, 1], "end": [56, 30], "kind": "commanddeclaration"}, {"full_name": "ne_zero_and_ne_zero_of_mul", "code": "theorem ne_zero_and_ne_zero_of_mul (h : a * b \u2260 0) : a \u2260 0 \u2227 b \u2260 0", "start": [59, 1], "end": [60, 50], "kind": "commanddeclaration"}, {"full_name": "mul_eq_zero_of_ne_zero_imp_eq_zero", "code": "theorem mul_eq_zero_of_ne_zero_imp_eq_zero {a b : M\u2080} (h : a \u2260 0 \u2192 b = 0) : a * b = 0", "start": [63, 1], "end": [64, 70], "kind": "commanddeclaration"}, {"full_name": "zero_mul_eq_const", "code": "theorem zero_mul_eq_const : (\u00b7 * \u00b7) (0 : M\u2080) = Function.const _ 0", "start": [67, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "mul_zero_eq_const", "code": "theorem mul_zero_eq_const : (\u00b7 * (0 : M\u2080)) = Function.const _ 0", "start": [72, 1], "end": [74, 18], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_mul_self_eq_zero", "code": "theorem eq_zero_of_mul_self_eq_zero (h : a * a = 0) : a = 0", "start": [83, 1], "end": [84, 51], "kind": "commanddeclaration"}, {"full_name": "mul_ne_zero", "code": "@[field_simps]\ntheorem mul_ne_zero (ha : a \u2260 0) (hb : b \u2260 0) : a * b \u2260 0", "start": [87, 1], "end": [89, 62], "kind": "commanddeclaration"}, {"full_name": "NeZero.mul", "code": "instance mul [Zero M\u2080] [Mul M\u2080] [NoZeroDivisors M\u2080] {x y : M\u2080} [NeZero x] [NeZero y] :\n    NeZero (x * y) :=\n  \u27e8mul_ne_zero out out\u27e9", "start": [96, 1], "end": [98, 24], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_zero_eq_one", "code": "theorem eq_zero_of_zero_eq_one (h : (0 : M\u2080) = 1) (a : M\u2080) : a = 0", "start": [108, 1], "end": [110, 34], "kind": "commanddeclaration"}, {"full_name": "uniqueOfZeroEqOne", "code": "def uniqueOfZeroEqOne (h : (0 : M\u2080) = 1) : Unique M\u2080 where\n  default := 0\n  uniq := eq_zero_of_zero_eq_one h", "start": [113, 1], "end": [119, 35], "kind": "commanddeclaration"}, {"full_name": "subsingleton_iff_zero_eq_one", "code": "theorem subsingleton_iff_zero_eq_one : (0 : M\u2080) = 1 \u2194 Subsingleton M\u2080", "start": [122, 1], "end": [125, 94], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_zero_eq_one", "code": "alias \u27e8subsingleton_of_zero_eq_one, _\u27e9 := subsingleton_iff_zero_eq_one", "start": [128, 1], "end": [128, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "eq_of_zero_eq_one", "code": "theorem eq_of_zero_eq_one (h : (0 : M\u2080) = 1) (a b : M\u2080) : a = b", "start": [131, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "zero_ne_one_or_forall_eq_0", "code": "theorem zero_ne_one_or_forall_eq_0 : (0 : M\u2080) \u2260 1 \u2228 \u2200 a : M\u2080, a = 0", "start": [135, 1], "end": [137, 39], "kind": "commanddeclaration"}, {"full_name": "left_ne_zero_of_mul_eq_one", "code": "theorem left_ne_zero_of_mul_eq_one (h : a * b = 1) : a \u2260 0", "start": [146, 1], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "right_ne_zero_of_mul_eq_one", "code": "theorem right_ne_zero_of_mul_eq_one (h : a * b = 1) : b \u2260 0", "start": [150, 1], "end": [151, 46], "kind": "commanddeclaration"}, {"full_name": "CancelMonoidWithZero.to_noZeroDivisors", "code": "instance (priority := 10) CancelMonoidWithZero.to_noZeroDivisors : NoZeroDivisors M\u2080 :=\n  \u27e8fun ab0 => or_iff_not_imp_left.mpr <| fun ha => mul_left_cancel\u2080 ha <|\n    ab0.trans (mul_zero _).symm\u27e9", "start": [161, 1], "end": [163, 33], "kind": "commanddeclaration"}, {"full_name": "mul_eq_mul_right_iff", "code": "@[simp]\ntheorem mul_eq_mul_right_iff : a * c = b * c \u2194 a = b \u2228 c = 0", "start": [166, 1], "end": [168, 64], "kind": "commanddeclaration"}, {"full_name": "mul_eq_mul_left_iff", "code": "@[simp]\ntheorem mul_eq_mul_left_iff : a * b = a * c \u2194 b = c \u2228 a = 0", "start": [171, 1], "end": [173, 65], "kind": "commanddeclaration"}, {"full_name": "mul_right_eq_self\u2080", "code": "theorem mul_right_eq_self\u2080 : a * b = a \u2194 b = 1 \u2228 a = 0", "start": [176, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "mul_left_eq_self\u2080", "code": "theorem mul_left_eq_self\u2080 : a * b = b \u2194 a = 1 \u2228 b = 0", "start": [182, 1], "end": [185, 46], "kind": "commanddeclaration"}, {"full_name": "mul_eq_left\u2080", "code": "@[simp]\ntheorem mul_eq_left\u2080 (ha : a \u2260 0) : a * b = a \u2194 b = 1", "start": [188, 1], "end": [190, 46], "kind": "commanddeclaration"}, {"full_name": "mul_eq_right\u2080", "code": "@[simp]\ntheorem mul_eq_right\u2080 (hb : b \u2260 0) : a * b = b \u2194 a = 1", "start": [193, 1], "end": [195, 45], "kind": "commanddeclaration"}, {"full_name": "left_eq_mul\u2080", "code": "@[simp]\ntheorem left_eq_mul\u2080 (ha : a \u2260 0) : a = a * b \u2194 b = 1", "start": [198, 1], "end": [199, 90], "kind": "commanddeclaration"}, {"full_name": "right_eq_mul\u2080", "code": "@[simp]\ntheorem right_eq_mul\u2080 (hb : b \u2260 0) : b = a * b \u2194 a = 1", "start": [202, 1], "end": [203, 92], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_mul_eq_self_right", "code": "theorem eq_zero_of_mul_eq_self_right (h\u2081 : b \u2260 1) (h\u2082 : a * b = a) : a = 0", "start": [206, 1], "end": [209, 94], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_mul_eq_self_left", "code": "theorem eq_zero_of_mul_eq_self_left (h\u2081 : b \u2260 1) (h\u2082 : b * a = a) : a = 0", "start": [212, 1], "end": [215, 95], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.mul_left_injective", "code": "theorem GroupWithZero.mul_left_injective (h : x \u2260 0) :\n    Function.Injective fun y => x * y", "start": [224, 1], "end": [226, 91], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.mul_right_injective", "code": "theorem GroupWithZero.mul_right_injective (h : x \u2260 0) :\n    Function.Injective fun y => y * x", "start": [229, 1], "end": [231, 91], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_right\u2080", "code": "@[simp]\ntheorem inv_mul_cancel_right\u2080 (h : b \u2260 0) (a : G\u2080) : a * b\u207b\u00b9 * b = a", "start": [234, 1], "end": [238, 25], "kind": "commanddeclaration"}, {"full_name": "inv_mul_cancel_left\u2080", "code": "@[simp]\ntheorem inv_mul_cancel_left\u2080 (h : a \u2260 0) (b : G\u2080) : a\u207b\u00b9 * (a * b) = b", "start": [242, 1], "end": [246, 25], "kind": "commanddeclaration"}, {"full_name": "inv_eq_of_mul", "code": "private theorem inv_eq_of_mul (h : a * b = 1) : a\u207b\u00b9 = b", "start": [250, 1], "end": [251, 75], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.toDivisionMonoid", "code": "instance (priority := 100) GroupWithZero.toDivisionMonoid : DivisionMonoid G\u2080 :=\n  { \u2039GroupWithZero G\u2080\u203a with\n    inv := Inv.inv,\n    inv_inv := fun a => by\n      by_cases h : a = 0\n      \u00b7 simp [h]\n\n      \u00b7 exact left_inv_eq_right_inv (inv_mul_cancel <| inv_ne_zero h) (inv_mul_cancel h)\n        ,\n    mul_inv_rev := fun a b => by\n      by_cases ha : a = 0\n      \u00b7 simp [ha]\n\n      by_cases hb : b = 0\n      \u00b7 simp [hb]\n\n      refine' inv_eq_of_mul _\n      simp [mul_assoc, ha, hb],\n    inv_eq_of_mul := fun a b => inv_eq_of_mul }", "start": [254, 1], "end": [272, 48], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.toCancelMonoidWithZero", "code": "instance (priority := 10) GroupWithZero.toCancelMonoidWithZero : CancelMonoidWithZero G\u2080 :=\n  { (\u2039_\u203a : GroupWithZero G\u2080) with\n    mul_left_cancel_of_ne_zero := @fun x y z hx h => by\n      rw [\u2190 inv_mul_cancel_left\u2080 hx y, h, inv_mul_cancel_left\u2080 hx z],\n    mul_right_cancel_of_ne_zero := @fun x y z hy h => by\n      rw [\u2190 mul_inv_cancel_right\u2080 hy x, h, mul_inv_cancel_right\u2080 hy z] }", "start": [276, 1], "end": [281, 73], "kind": "commanddeclaration"}, {"full_name": "zero_div", "code": "@[simp]\ntheorem zero_div (a : G\u2080) : 0 / a = 0", "start": [290, 1], "end": [291, 74], "kind": "commanddeclaration"}, {"full_name": "div_zero", "code": "@[simp]\ntheorem div_zero (a : G\u2080) : a / 0 = 0", "start": [294, 1], "end": [295, 84], "kind": "commanddeclaration"}, {"full_name": "mul_self_mul_inv", "code": "@[simp]\ntheorem mul_self_mul_inv (a : G\u2080) : a * a * a\u207b\u00b9 = a", "start": [298, 1], "end": [304, 46], "kind": "commanddeclaration"}, {"full_name": "mul_inv_mul_self", "code": "@[simp]\ntheorem mul_inv_mul_self (a : G\u2080) : a * a\u207b\u00b9 * a = a", "start": [308, 1], "end": [314, 35], "kind": "commanddeclaration"}, {"full_name": "inv_mul_mul_self", "code": "@[simp]\ntheorem inv_mul_mul_self (a : G\u2080) : a\u207b\u00b9 * a * a = a", "start": [318, 1], "end": [324, 35], "kind": "commanddeclaration"}, {"full_name": "mul_self_div_self", "code": "@[simp]\ntheorem mul_self_div_self (a : G\u2080) : a * a / a = a", "start": [328, 1], "end": [331, 97], "kind": "commanddeclaration"}, {"full_name": "div_self_mul_self", "code": "@[simp]\ntheorem div_self_mul_self (a : G\u2080) : a / a * a = a", "start": [334, 1], "end": [337, 97], "kind": "commanddeclaration"}, {"full_name": "div_self_mul_self'", "code": "@[simp]\ntheorem div_self_mul_self' (a : G\u2080) : a / (a * a) = a\u207b\u00b9", "start": [342, 1], "end": [346, 34], "kind": "commanddeclaration"}, {"full_name": "one_div_ne_zero", "code": "theorem one_div_ne_zero {a : G\u2080} (h : a \u2260 0) : 1 / a \u2260 0", "start": [350, 1], "end": [351, 43], "kind": "commanddeclaration"}, {"full_name": "inv_eq_zero", "code": "@[simp]\ntheorem inv_eq_zero {a : G\u2080} : a\u207b\u00b9 = 0 \u2194 a = 0", "start": [354, 1], "end": [355, 86], "kind": "commanddeclaration"}, {"full_name": "zero_eq_inv", "code": "@[simp]\ntheorem zero_eq_inv {a : G\u2080} : 0 = a\u207b\u00b9 \u2194 0 = a", "start": [358, 1], "end": [360, 45], "kind": "commanddeclaration"}, {"full_name": "div_div_self", "code": "@[simp]\ntheorem div_div_self (a : G\u2080) : a / (a / a) = a", "start": [363, 1], "end": [368, 28], "kind": "commanddeclaration"}, {"full_name": "ne_zero_of_one_div_ne_zero", "code": "theorem ne_zero_of_one_div_ne_zero {a : G\u2080} (h : 1 / a \u2260 0) : a \u2260 0", "start": [371, 1], "end": [373, 16], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_one_div_eq_zero", "code": "theorem eq_zero_of_one_div_eq_zero {a : G\u2080} (h : 1 / a = 0) : a = 0", "start": [376, 1], "end": [377, 75], "kind": "commanddeclaration"}, {"full_name": "mul_left_surjective\u2080", "code": "theorem mul_left_surjective\u2080 {a : G\u2080} (h : a \u2260 0) : Surjective fun g => a * g", "start": [380, 1], "end": [381, 53], "kind": "commanddeclaration"}, {"full_name": "mul_right_surjective\u2080", "code": "theorem mul_right_surjective\u2080 {a : G\u2080} (h : a \u2260 0) : Surjective fun g => g * a", "start": [384, 1], "end": [385, 51], "kind": "commanddeclaration"}, {"full_name": "div_mul_eq_mul_div\u2080", "code": "theorem div_mul_eq_mul_div\u2080 (a b c : G\u2080) : a / c * b = a * b / c", "start": [394, 1], "end": [395, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/InjSurj.lean", "imports": ["Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/Algebra/Group/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.mulZeroClass", "code": "@[reducible]\nprotected def Function.Injective.mulZeroClass [Mul M\u2080'] [Zero M\u2080'] (f : M\u2080' \u2192 M\u2080) (hf : Injective f)\n    (zero : f 0 = 0) (mul : \u2200 a b, f (a * b) = f a * f b) : MulZeroClass M\u2080' where\n  mul := (\u00b7 * \u00b7)\n  zero := 0\n  zero_mul a := hf <| by simp only [mul, zero, zero_mul]\n  mul_zero a := hf <| by simp only [mul, zero, mul_zero]", "start": [25, 1], "end": [33, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulZeroClass", "code": "@[reducible]\nprotected def Function.Surjective.mulZeroClass [Mul M\u2080'] [Zero M\u2080'] (f : M\u2080 \u2192 M\u2080')\n    (hf : Surjective f) (zero : f 0 = 0) (mul : \u2200 a b, f (a * b) = f a * f b) :\n    MulZeroClass M\u2080' where\n  mul := (\u00b7 * \u00b7)\n  zero := 0\n  mul_zero := hf.forall.2 fun x => by simp only [\u2190 zero, \u2190 mul, mul_zero]\n  zero_mul := hf.forall.2 fun x => by simp only [\u2190 zero, \u2190 mul, zero_mul]", "start": [36, 1], "end": [45, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.noZeroDivisors", "code": "protected theorem Function.Injective.noZeroDivisors [NoZeroDivisors M\u2080'] : NoZeroDivisors M\u2080", "start": [55, 1], "end": [60, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.isLeftCancelMulZero", "code": "protected theorem Function.Injective.isLeftCancelMulZero\n    [IsLeftCancelMulZero M\u2080'] : IsLeftCancelMulZero M\u2080", "start": [63, 1], "end": [68, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.isRightCancelMulZero", "code": "protected theorem Function.Injective.isRightCancelMulZero\n    [IsRightCancelMulZero M\u2080'] : IsRightCancelMulZero M\u2080", "start": [70, 1], "end": [75, 86], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mulZeroOneClass", "code": "@[reducible]\nprotected def Function.Injective.mulZeroOneClass [Mul M\u2080'] [Zero M\u2080'] [One M\u2080'] (f : M\u2080' \u2192 M\u2080)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : \u2200 a b, f (a * b) = f a * f b) :\n    MulZeroOneClass M\u2080' :=\n  { hf.mulZeroClass f zero mul, hf.mulOneClass f one mul with }", "start": [83, 1], "end": [89, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulZeroOneClass", "code": "@[reducible]\nprotected def Function.Surjective.mulZeroOneClass [Mul M\u2080'] [Zero M\u2080'] [One M\u2080'] (f : M\u2080 \u2192 M\u2080')\n    (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1) (mul : \u2200 a b, f (a * b) = f a * f b) :\n    MulZeroOneClass M\u2080' :=\n  { hf.mulZeroClass f zero mul, hf.mulOneClass f one mul with }", "start": [92, 1], "end": [98, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.semigroupWithZero", "code": "@[reducible]\nprotected def Function.Injective.semigroupWithZero [Zero M\u2080'] [Mul M\u2080'] [SemigroupWithZero M\u2080]\n    (f : M\u2080' \u2192 M\u2080) (hf : Injective f) (zero : f 0 = 0) (mul : \u2200 x y, f (x * y) = f x * f y) :\n    SemigroupWithZero M\u2080' :=\n  { hf.mulZeroClass f zero mul, \u2039Zero M\u2080'\u203a, hf.semigroup f mul with }", "start": [105, 1], "end": [111, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.semigroupWithZero", "code": "@[reducible]\nprotected def Function.Surjective.semigroupWithZero [SemigroupWithZero M\u2080] [Zero M\u2080'] [Mul M\u2080']\n    (f : M\u2080 \u2192 M\u2080') (hf : Surjective f) (zero : f 0 = 0) (mul : \u2200 x y, f (x * y) = f x * f y) :\n    SemigroupWithZero M\u2080' :=\n  { hf.mulZeroClass f zero mul, \u2039Zero M\u2080'\u203a, hf.semigroup f mul with }", "start": [114, 1], "end": [120, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.monoidWithZero", "code": "@[reducible]\nprotected def Function.Injective.monoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    [MonoidWithZero M\u2080] (f : M\u2080' \u2192 M\u2080) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    MonoidWithZero M\u2080' :=\n  { hf.monoid f one mul npow, hf.mulZeroClass f zero mul with }", "start": [127, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.monoidWithZero", "code": "@[reducible]\nprotected def Function.Surjective.monoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    [MonoidWithZero M\u2080] (f : M\u2080 \u2192 M\u2080') (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    MonoidWithZero M\u2080' :=\n  { hf.monoid f one mul npow, hf.mulZeroClass f zero mul with }", "start": [137, 1], "end": [144, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commMonoidWithZero", "code": "@[reducible]\nprotected def Function.Injective.commMonoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    [CommMonoidWithZero M\u2080] (f : M\u2080' \u2192 M\u2080) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CommMonoidWithZero M\u2080' :=\n  { hf.commMonoid f one mul npow, hf.mulZeroClass f zero mul with }", "start": [147, 1], "end": [154, 68], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commMonoidWithZero", "code": "@[reducible]\nprotected def Function.Surjective.commMonoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    [CommMonoidWithZero M\u2080] (f : M\u2080 \u2192 M\u2080') (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CommMonoidWithZero M\u2080' :=\n  { hf.commMonoid f one mul npow, hf.mulZeroClass f zero mul with }", "start": [157, 1], "end": [164, 68], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.cancelMonoidWithZero", "code": "@[reducible]\nprotected def Function.Injective.cancelMonoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    (f : M\u2080' \u2192 M\u2080) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CancelMonoidWithZero M\u2080' :=\n  { hf.monoid f one mul npow, hf.mulZeroClass f zero mul with\n    mul_left_cancel_of_ne_zero := fun hx H =>\n      hf <| mul_left_cancel\u2080 ((hf.ne_iff' zero).2 hx) <| by erw [\u2190 mul, \u2190 mul, H],\n    mul_right_cancel_of_ne_zero := fun hx H =>\n      hf <| mul_right_cancel\u2080 ((hf.ne_iff' zero).2 hx) <| by erw [\u2190 mul, \u2190 mul, H] }", "start": [173, 1], "end": [184, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.cancelCommMonoidWithZero", "code": "@[reducible]\nprotected def Function.Injective.cancelCommMonoidWithZero [Zero M\u2080'] [Mul M\u2080'] [One M\u2080'] [Pow M\u2080' \u2115]\n    (f : M\u2080' \u2192 M\u2080) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) :\n    CancelCommMonoidWithZero M\u2080' :=\n  { hf.commMonoidWithZero f zero one mul npow, hf.cancelMonoidWithZero f zero one mul npow with }", "start": [193, 1], "end": [200, 98], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.groupWithZero", "code": "@[reducible]\nprotected def Function.Injective.groupWithZero [Zero G\u2080'] [Mul G\u2080'] [One G\u2080'] [Inv G\u2080'] [Div G\u2080']\n    [Pow G\u2080' \u2115] [Pow G\u2080' \u2124] (f : G\u2080' \u2192 G\u2080) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : GroupWithZero G\u2080' :=\n  { hf.monoidWithZero f zero one mul npow,\n    hf.divInvMonoid f one mul inv div npow zpow,\n    pullback_nonzero f zero one with\n    inv_zero := hf <| by erw [inv, zero, inv_zero],\n    mul_inv_cancel := fun x hx => hf <| by\n      erw [one, mul, inv, mul_inv_cancel ((hf.ne_iff' zero).2 hx)] }", "start": [209, 1], "end": [222, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.groupWithZero", "code": "@[reducible]\nprotected def Function.Surjective.groupWithZero [Zero G\u2080'] [Mul G\u2080'] [One G\u2080'] [Inv G\u2080'] [Div G\u2080']\n    [Pow G\u2080' \u2115] [Pow G\u2080' \u2124] (h01 : (0 : G\u2080') \u2260 1) (f : G\u2080 \u2192 G\u2080') (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) (div : \u2200 x y, f (x / y) = f x / f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) :\n    GroupWithZero G\u2080' :=\n  { hf.monoidWithZero f zero one mul npow, hf.divInvMonoid f one mul inv div npow zpow with\n    inv_zero := by erw [\u2190 zero, \u2190 inv, inv_zero],\n    mul_inv_cancel := hf.forall.2 fun x hx => by\n        erw [\u2190 inv, \u2190 mul, mul_inv_cancel (mt (congr_arg f) <| fun h \u21a6 hx (h.trans zero)), one]\n    exists_pair_ne := \u27e80, 1, h01\u27e9 }", "start": [225, 1], "end": [238, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commGroupWithZero", "code": "@[reducible]\nprotected def Function.Injective.commGroupWithZero [Zero G\u2080'] [Mul G\u2080'] [One G\u2080'] [Inv G\u2080']\n    [Div G\u2080'] [Pow G\u2080' \u2115] [Pow G\u2080' \u2124] (f : G\u2080' \u2192 G\u2080) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : CommGroupWithZero G\u2080' :=\n  { hf.groupWithZero f zero one mul inv div npow zpow, hf.commSemigroup f mul with }", "start": [247, 1], "end": [255, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commGroupWithZero", "code": "protected def Function.Surjective.commGroupWithZero [Zero G\u2080'] [Mul G\u2080'] [One G\u2080'] [Inv G\u2080']\n    [Div G\u2080'] [Pow G\u2080' \u2115] [Pow G\u2080' \u2124] (h01 : (0 : G\u2080') \u2260 1) (f : G\u2080 \u2192 G\u2080') (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) (div : \u2200 x y, f (x / y) = f x / f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) :\n    CommGroupWithZero G\u2080' :=\n  { hf.groupWithZero h01 f zero one mul inv div npow zpow, hf.commSemigroup f mul with }", "start": [258, 1], "end": [266, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Basic.lean", "imports": ["Mathlib/Tactic/Tauto.lean", "Mathlib/Logic/Function/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/SymmDiff.lean", "Mathlib/Tactic/ByContra.lean"], "premises": [{"full_name": "Set.instBooleanAlgebraSet", "code": "instance instBooleanAlgebraSet : BooleanAlgebra (Set \u03b1) :=\n  { (inferInstance : BooleanAlgebra (\u03b1 \u2192 Prop)) with\n    sup := (\u00b7 \u222a \u00b7),\n    le := (\u00b7 \u2264 \u00b7),\n    lt := fun s t => s \u2286 t \u2227 \u00act \u2286 s,\n    inf := (\u00b7 \u2229 \u00b7),\n    bot := \u2205,\n    compl := fun s => { x | x \u2209 s },\n    top := univ,\n    sdiff := fun s t => { x | x \u2208 s \u2227 x \u2209 t } }", "start": [86, 1], "end": [95, 48], "kind": "commanddeclaration"}, {"full_name": "Set.top_eq_univ", "code": "@[simp]\ntheorem top_eq_univ : (\u22a4 : Set \u03b1) = univ", "start": [100, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "Set.bot_eq_empty", "code": "@[simp]\ntheorem bot_eq_empty : (\u22a5 : Set \u03b1) = \u2205", "start": [105, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Set.sup_eq_union", "code": "@[simp]\ntheorem sup_eq_union : ((\u00b7 \u2294 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1) = (\u00b7 \u222a \u00b7)", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inf_eq_inter", "code": "@[simp]\ntheorem inf_eq_inter : ((\u00b7 \u2293 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b1) = (\u00b7 \u2229 \u00b7)", "start": [115, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "Set.le_eq_subset", "code": "@[simp]\ntheorem le_eq_subset : ((\u00b7 \u2264 \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Prop) = (\u00b7 \u2286 \u00b7)", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "Set.lt_eq_ssubset", "code": "@[simp]\ntheorem lt_eq_ssubset : ((\u00b7 < \u00b7) : Set \u03b1 \u2192 Set \u03b1 \u2192 Prop) = (\u00b7 \u2282 \u00b7)", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "Set.le_iff_subset", "code": "theorem le_iff_subset : s \u2264 t \u2194 s \u2286 t", "start": [130, 1], "end": [131, 10], "kind": "commanddeclaration"}, {"full_name": "Set.lt_iff_ssubset", "code": "theorem lt_iff_ssubset : s < t \u2194 s \u2282 t", "start": [134, 1], "end": [135, 10], "kind": "commanddeclaration"}, {"full_name": "LE.le.subset", "code": "alias \u27e8_root_.LE.le.subset, _root_.HasSubset.Subset.le\u27e9 := le_iff_subset", "start": [138, 1], "end": [138, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasSubset.Subset.le", "code": "alias \u27e8_root_.LE.le.subset, _root_.HasSubset.Subset.le\u27e9 := le_iff_subset", "start": [138, 1], "end": [138, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LT.lt.ssubset", "code": "alias \u27e8_root_.LT.lt.ssubset, _root_.HasSSubset.SSubset.lt\u27e9 := lt_iff_ssubset", "start": [141, 1], "end": [141, 77], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasSSubset.SSubset.lt", "code": "alias \u27e8_root_.LT.lt.ssubset, _root_.HasSSubset.SSubset.lt\u27e9 := lt_iff_ssubset", "start": [141, 1], "end": [141, 77], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Elem", "code": "@[coe, reducible] def Elem (s : Set \u03b1) : Type u := { x // x \u2208 s }", "start": [150, 1], "end": [151, 66], "kind": "commanddeclaration"}, {"full_name": "Set.PiSetCoe.canLift", "code": "instance PiSetCoe.canLift (\u03b9 : Type u) (\u03b1 : \u03b9 \u2192 Type v) [\u2200 i, Nonempty (\u03b1 i)] (s : Set \u03b9) :\n    CanLift (\u2200 i : s, \u03b1 i) (\u2200 i, \u03b1 i) (fun f i => f i) fun _ => True :=\n  PiSubtype.canLift \u03b9 \u03b1 s", "start": [157, 1], "end": [159, 26], "kind": "commanddeclaration"}, {"full_name": "Set.PiSetCoe.canLift'", "code": "instance PiSetCoe.canLift' (\u03b9 : Type u) (\u03b1 : Type v) [Nonempty \u03b1] (s : Set \u03b9) :\n    CanLift (s \u2192 \u03b1) (\u03b9 \u2192 \u03b1) (fun f i => f i) fun _ => True :=\n  PiSetCoe.canLift \u03b9 (fun _ => \u03b1) s", "start": [162, 1], "end": [164, 36], "kind": "commanddeclaration"}, {"full_name": "Set.coe_eq_subtype", "code": "theorem Set.coe_eq_subtype (s : Set \u03b1) : \u21a5s = { x // x \u2208 s }", "start": [175, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Set.coe_setOf", "code": "@[simp]\ntheorem Set.coe_setOf (p : \u03b1 \u2192 Prop) : \u21a5{ x | p x } = { x // p x }", "start": [179, 1], "end": [181, 6], "kind": "commanddeclaration"}, {"full_name": "SetCoe.forall", "code": "theorem SetCoe.forall {s : Set \u03b1} {p : s \u2192 Prop} : (\u2200 x : s, p x) \u2194 \u2200 (x) (h : x \u2208 s), p \u27e8x, h\u27e9", "start": [185, 1], "end": [186, 17], "kind": "commanddeclaration"}, {"full_name": "SetCoe.exists", "code": "theorem SetCoe.exists {s : Set \u03b1} {p : s \u2192 Prop} :\n    (\u2203 x : s, p x) \u2194 \u2203 (x : _) (h : x \u2208 s), p \u27e8x, h\u27e9", "start": [190, 1], "end": [192, 17], "kind": "commanddeclaration"}, {"full_name": "SetCoe.exists'", "code": "theorem SetCoe.exists' {s : Set \u03b1} {p : \u2200 x, x \u2208 s \u2192 Prop} :\n    (\u2203 (x : _) (h : x \u2208 s), p x h) \u2194 \u2203 x : s, p x.1 x.2", "start": [195, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "SetCoe.forall'", "code": "theorem SetCoe.forall' {s : Set \u03b1} {p : \u2200 x, x \u2208 s \u2192 Prop} :\n    (\u2200 (x) (h : x \u2208 s), p x h) \u2194 \u2200 x : s, p x.1 x.2", "start": [200, 1], "end": [202, 47], "kind": "commanddeclaration"}, {"full_name": "set_coe_cast", "code": "@[simp]\ntheorem set_coe_cast :\n    \u2200 {s t : Set \u03b1} (H' : s = t) (H : \u21a5s = \u21a5t) (x : s), cast H x = \u27e8x.1, H' \u25b8 x.2\u27e9", "start": [205, 1], "end": [208, 27], "kind": "commanddeclaration"}, {"full_name": "SetCoe.ext", "code": "theorem SetCoe.ext {s : Set \u03b1} {a b : s} : (a : \u03b1) = b \u2192 a = b", "start": [211, 1], "end": [212, 13], "kind": "commanddeclaration"}, {"full_name": "SetCoe.ext_iff", "code": "theorem SetCoe.ext_iff {s : Set \u03b1} {a b : s} : (\u2191a : \u03b1) = \u2191b \u2194 a = b", "start": [215, 1], "end": [216, 40], "kind": "commanddeclaration"}, {"full_name": "Subtype.mem", "code": "theorem Subtype.mem {\u03b1 : Type*} {s : Set \u03b1} (p : s) : (p : \u03b1) \u2208 s", "start": [221, 1], "end": [223, 9], "kind": "commanddeclaration"}, {"full_name": "Eq.subset", "code": "theorem Eq.subset {\u03b1} {s t : Set \u03b1} : s = t \u2192 s \u2286 t", "start": [226, 1], "end": [228, 40], "kind": "commanddeclaration"}, {"full_name": "Set.ext_iff", "code": "theorem ext_iff {s t : Set \u03b1} : s = t \u2194 \u2200 x, x \u2208 s \u2194 x \u2208 t", "start": [241, 1], "end": [242, 30], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_of_subset", "code": "@[trans]\ntheorem mem_of_mem_of_subset {x : \u03b1} {s t : Set \u03b1} (hx : x \u2208 s) (h : s \u2286 t) : x \u2208 t", "start": [245, 1], "end": [247, 7], "kind": "commanddeclaration"}, {"full_name": "Set.forall_in_swap", "code": "theorem forall_in_swap {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 a \u2208 s, \u2200 (b), p a b) \u2194 \u2200 (b), \u2200 a \u2208 s, p a b", "start": [250, 1], "end": [251, 8], "kind": "commanddeclaration"}, {"full_name": "Set.mem_setOf_eq", "code": "@[simp, mfld_simps] theorem mem_setOf_eq {x : \u03b1} {p : \u03b1 \u2192 Prop} : (x \u2208 {y | p y}) = p x", "start": [256, 1], "end": [256, 95], "kind": "commanddeclaration"}, {"full_name": "Set.mem_setOf", "code": "theorem mem_setOf {a : \u03b1} {p : \u03b1 \u2192 Prop} : a \u2208 { x | p x } \u2194 p a", "start": [259, 1], "end": [260, 10], "kind": "commanddeclaration"}, {"full_name": "Membership.mem.out", "code": "theorem _root_.Membership.mem.out {p : \u03b1 \u2192 Prop} {a : \u03b1} (h : a \u2208 { x | p x }) : p a", "start": [263, 1], "end": [267, 4], "kind": "commanddeclaration"}, {"full_name": "Set.nmem_setOf_iff", "code": "theorem nmem_setOf_iff {a : \u03b1} {p : \u03b1 \u2192 Prop} : a \u2209 { x | p x } \u2194 \u00acp a", "start": [270, 1], "end": [271, 10], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_mem_eq", "code": "@[simp]\ntheorem setOf_mem_eq {s : Set \u03b1} : { x | x \u2208 s } = s", "start": [274, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_set", "code": "theorem setOf_set {s : Set \u03b1} : setOf s = s", "start": [279, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_app_iff", "code": "theorem setOf_app_iff {p : \u03b1 \u2192 Prop} {x : \u03b1} : { x | p x } x \u2194 p x", "start": [283, 1], "end": [284, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_def", "code": "theorem mem_def {a : \u03b1} {s : Set \u03b1} : a \u2208 s \u2194 s a", "start": [287, 1], "end": [288, 10], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_bijective", "code": "theorem setOf_bijective : Bijective (setOf : (\u03b1 \u2192 Prop) \u2192 Set \u03b1)", "start": [291, 1], "end": [292, 15], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_subset_setOf", "code": "@[simp]\ntheorem setOf_subset_setOf {p q : \u03b1 \u2192 Prop} : { a | p a } \u2286 { a | q a } \u2194 \u2200 a, p a \u2192 q a", "start": [295, 1], "end": [297, 10], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_and", "code": "theorem setOf_and {p q : \u03b1 \u2192 Prop} : { a | p a \u2227 q a } = { a | p a } \u2229 { a | q a }", "start": [300, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_or", "code": "theorem setOf_or {p q : \u03b1 \u2192 Prop} : { a | p a \u2228 q a } = { a | p a } \u222a { a | q a }", "start": [304, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "Set.subset_def", "code": "theorem subset_def : (s \u2286 t) = \u2200 x, x \u2208 s \u2192 x \u2208 t", "start": [345, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_def", "code": "theorem ssubset_def : (s \u2282 t) = (s \u2286 t \u2227 \u00act \u2286 s)", "start": [349, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Subset.refl", "code": "@[refl]\ntheorem Subset.refl (a : Set \u03b1) : a \u2286 a", "start": [353, 1], "end": [354, 55], "kind": "commanddeclaration"}, {"full_name": "Set.Subset.rfl", "code": "theorem Subset.rfl {s : Set \u03b1} : s \u2286 s", "start": [357, 1], "end": [358, 16], "kind": "commanddeclaration"}, {"full_name": "Set.Subset.trans", "code": "@[trans]\ntheorem Subset.trans {a b c : Set \u03b1} (ab : a \u2286 b) (bc : b \u2286 c) : a \u2286 c", "start": [361, 1], "end": [362, 96], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_eq_of_mem", "code": "@[trans]\ntheorem mem_of_eq_of_mem {x y : \u03b1} {s : Set \u03b1} (hx : x = y) (h : y \u2208 s) : x \u2208 s", "start": [365, 1], "end": [367, 14], "kind": "commanddeclaration"}, {"full_name": "Set.Subset.antisymm", "code": "theorem Subset.antisymm {a b : Set \u03b1} (h\u2081 : a \u2286 b) (h\u2082 : b \u2286 a) : a = b", "start": [370, 1], "end": [371, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Subset.antisymm_iff", "code": "theorem Subset.antisymm_iff {a b : Set \u03b1} : a = b \u2194 a \u2286 b \u2227 b \u2286 a", "start": [374, 1], "end": [375, 78], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_subset_of_subset", "code": "theorem eq_of_subset_of_subset {a b : Set \u03b1} : a \u2286 b \u2192 b \u2286 a \u2192 a = b", "start": [379, 1], "end": [380, 18], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_subset_of_mem", "code": "theorem mem_of_subset_of_mem {s\u2081 s\u2082 : Set \u03b1} {a : \u03b1} (h : s\u2081 \u2286 s\u2082) : a \u2208 s\u2081 \u2192 a \u2208 s\u2082", "start": [383, 1], "end": [384, 7], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_subset", "code": "theorem not_mem_subset (h : s \u2286 t) : a \u2209 t \u2192 a \u2209 s", "start": [387, 1], "end": [388, 31], "kind": "commanddeclaration"}, {"full_name": "Set.not_subset", "code": "theorem not_subset : \u00acs \u2286 t \u2194 \u2203 a \u2208 s, a \u2209 t", "start": [391, 1], "end": [392, 50], "kind": "commanddeclaration"}, {"full_name": "Set.eq_or_ssubset_of_subset", "code": "protected theorem eq_or_ssubset_of_subset (h : s \u2286 t) : s = t \u2228 s \u2282 t", "start": [398, 1], "end": [399, 19], "kind": "commanddeclaration"}, {"full_name": "Set.exists_of_ssubset", "code": "theorem exists_of_ssubset {s t : Set \u03b1} (h : s \u2282 t) : \u2203 x \u2208 t, x \u2209 s", "start": [402, 1], "end": [403, 19], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_iff_subset_ne", "code": "protected theorem ssubset_iff_subset_ne {s t : Set \u03b1} : s \u2282 t \u2194 s \u2286 t \u2227 s \u2260 t", "start": [406, 1], "end": [407, 34], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_iff_of_subset", "code": "theorem ssubset_iff_of_subset {s t : Set \u03b1} (h : s \u2286 t) : s \u2282 t \u2194 \u2203 x \u2208 t, x \u2209 s", "start": [410, 1], "end": [411, 71], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_of_ssubset_of_subset", "code": "protected theorem ssubset_of_ssubset_of_subset {s\u2081 s\u2082 s\u2083 : Set \u03b1} (hs\u2081s\u2082 : s\u2081 \u2282 s\u2082)\n    (hs\u2082s\u2083 : s\u2082 \u2286 s\u2083) : s\u2081 \u2282 s\u2083", "start": [414, 1], "end": [416, 80], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_of_subset_of_ssubset", "code": "protected theorem ssubset_of_subset_of_ssubset {s\u2081 s\u2082 s\u2083 : Set \u03b1} (hs\u2081s\u2082 : s\u2081 \u2286 s\u2082)\n    (hs\u2082s\u2083 : s\u2082 \u2282 s\u2083) : s\u2081 \u2282 s\u2083", "start": [419, 1], "end": [421, 80], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_empty", "code": "theorem not_mem_empty (x : \u03b1) : \u00acx \u2208 (\u2205 : Set \u03b1)", "start": [424, 1], "end": [425, 5], "kind": "commanddeclaration"}, {"full_name": "Set.not_not_mem", "code": "theorem not_not_mem : \u00aca \u2209 s \u2194 a \u2208 s", "start": [429, 1], "end": [430, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty", "code": "protected def Nonempty (s : Set \u03b1) : Prop :=\n  \u2203 x, x \u2208 s", "start": [436, 1], "end": [440, 13], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_coe_sort", "code": "theorem nonempty_coe_sort {s : Set \u03b1} : Nonempty (\u21a5s) \u2194 s.Nonempty", "start": [447, 1], "end": [448, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.coe_sort", "code": "alias \u27e8_, Nonempty.coe_sort\u27e9 := nonempty_coe_sort", "start": [451, 1], "end": [451, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.nonempty_def", "code": "theorem nonempty_def : s.Nonempty \u2194 \u2203 x, x \u2208 s", "start": [454, 1], "end": [455, 10], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_mem", "code": "theorem nonempty_of_mem {x} (h : x \u2208 s) : s.Nonempty", "start": [458, 1], "end": [459, 9], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.not_subset_empty", "code": "theorem Nonempty.not_subset_empty : s.Nonempty \u2192 \u00acs \u2286 \u2205", "start": [462, 1], "end": [463, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.some", "code": "protected noncomputable def Nonempty.some (h : s.Nonempty) : \u03b1 :=\n  Classical.choose h", "start": [466, 1], "end": [469, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.some_mem", "code": "protected theorem Nonempty.some_mem (h : s.Nonempty) : h.some \u2208 s", "start": [472, 1], "end": [473, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.mono", "code": "theorem Nonempty.mono (ht : s \u2286 t) (hs : s.Nonempty) : t.Nonempty", "start": [476, 1], "end": [477, 12], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_not_subset", "code": "theorem nonempty_of_not_subset (h : \u00acs \u2286 t) : (s \\ t).Nonempty", "start": [480, 1], "end": [482, 14], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_ssubset", "code": "theorem nonempty_of_ssubset (ht : s \u2282 t) : (t \\ s).Nonempty", "start": [485, 1], "end": [486, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_diff", "code": "theorem Nonempty.of_diff (h : (s \\ t).Nonempty) : s.Nonempty", "start": [489, 1], "end": [490, 26], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_ssubset'", "code": "theorem nonempty_of_ssubset' (ht : s \u2282 t) : t.Nonempty", "start": [493, 1], "end": [494, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.inl", "code": "theorem Nonempty.inl (hs : s.Nonempty) : (s \u222a t).Nonempty", "start": [497, 1], "end": [498, 25], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.inr", "code": "theorem Nonempty.inr (ht : t.Nonempty) : (s \u222a t).Nonempty", "start": [501, 1], "end": [502, 25], "kind": "commanddeclaration"}, {"full_name": "Set.union_nonempty", "code": "@[simp]\ntheorem union_nonempty : (s \u222a t).Nonempty \u2194 s.Nonempty \u2228 t.Nonempty", "start": [505, 1], "end": [507, 12], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.left", "code": "theorem Nonempty.left (h : (s \u2229 t).Nonempty) : s.Nonempty", "start": [510, 1], "end": [511, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.right", "code": "theorem Nonempty.right (h : (s \u2229 t).Nonempty) : t.Nonempty", "start": [514, 1], "end": [515, 27], "kind": "commanddeclaration"}, {"full_name": "Set.inter_nonempty", "code": "theorem inter_nonempty : (s \u2229 t).Nonempty \u2194 \u2203 x, x \u2208 s \u2227 x \u2208 t", "start": [518, 1], "end": [519, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inter_nonempty_iff_exists_left", "code": "theorem inter_nonempty_iff_exists_left : (s \u2229 t).Nonempty \u2194 \u2203 x \u2208 s, x \u2208 t", "start": [522, 1], "end": [523, 27], "kind": "commanddeclaration"}, {"full_name": "Set.inter_nonempty_iff_exists_right", "code": "theorem inter_nonempty_iff_exists_right : (s \u2229 t).Nonempty \u2194 \u2203 x \u2208 t, x \u2208 s", "start": [526, 1], "end": [527, 37], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iff_univ_nonempty", "code": "theorem nonempty_iff_univ_nonempty : Nonempty \u03b1 \u2194 (univ : Set \u03b1).Nonempty", "start": [530, 1], "end": [531, 47], "kind": "commanddeclaration"}, {"full_name": "Set.univ_nonempty", "code": "@[simp]\ntheorem univ_nonempty : \u2200 [Nonempty \u03b1], (univ : Set \u03b1).Nonempty", "start": [534, 1], "end": [536, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.to_subtype", "code": "theorem Nonempty.to_subtype : s.Nonempty \u2192 Nonempty (\u21a5s)", "start": [539, 1], "end": [540, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.to_type", "code": "theorem Nonempty.to_type : s.Nonempty \u2192 Nonempty \u03b1", "start": [543, 1], "end": [543, 72], "kind": "commanddeclaration"}, {"full_name": "Set.univ.nonempty", "code": "instance univ.nonempty [Nonempty \u03b1] : Nonempty (\u21a5(Set.univ : Set \u03b1)) :=\n  Set.univ_nonempty.to_subtype", "start": [546, 1], "end": [547, 31], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_nonempty_subtype", "code": "theorem nonempty_of_nonempty_subtype [Nonempty (\u21a5s)] : s.Nonempty", "start": [550, 1], "end": [551, 26], "kind": "commanddeclaration"}, {"full_name": "Set.empty_def", "code": "theorem empty_def : (\u21a5(\u2205 : Set \u03b1)) = { _x : \u03b1 | False }", "start": [557, 1], "end": [558, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_empty_iff_false", "code": "@[simp]\ntheorem mem_empty_iff_false (x : \u03b1) : x \u2208 (\u2205 : Set \u03b1) \u2194 False", "start": [561, 1], "end": [563, 10], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_false", "code": "@[simp]\ntheorem setOf_false : { _a : \u03b1 | False } = \u2205", "start": [566, 1], "end": [568, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_bot", "code": "@[simp] theorem setOf_bot : { _x : \u03b1 | \u22a5 } = \u2205", "start": [571, 1], "end": [571, 54], "kind": "commanddeclaration"}, {"full_name": "Set.empty_subset", "code": "@[simp]\ntheorem empty_subset (s : Set \u03b1) : \u2205 \u2286 s", "start": [573, 1], "end": [575, 7], "kind": "commanddeclaration"}, {"full_name": "Set.subset_empty_iff", "code": "theorem subset_empty_iff {s : Set \u03b1} : s \u2286 \u2205 \u2194 s = \u2205", "start": [578, 1], "end": [579, 68], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_iff_forall_not_mem", "code": "theorem eq_empty_iff_forall_not_mem {s : Set \u03b1} : s = \u2205 \u2194 \u2200 x, x \u2209 s", "start": [582, 1], "end": [583, 24], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_of_forall_not_mem", "code": "theorem eq_empty_of_forall_not_mem (h : \u2200 x, x \u2209 s) : s = \u2205", "start": [586, 1], "end": [587, 23], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_of_subset_empty", "code": "theorem eq_empty_of_subset_empty {s : Set \u03b1} : s \u2286 \u2205 \u2192 s = \u2205", "start": [590, 1], "end": [591, 21], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_of_isEmpty", "code": "theorem eq_empty_of_isEmpty [IsEmpty \u03b1] (s : Set \u03b1) : s = \u2205", "start": [594, 1], "end": [595, 52], "kind": "commanddeclaration"}, {"full_name": "Set.uniqueEmpty", "code": "instance uniqueEmpty [IsEmpty \u03b1] : Unique (Set \u03b1) where\n  default := \u2205\n  uniq := eq_empty_of_isEmpty", "start": [598, 1], "end": [601, 30], "kind": "commanddeclaration"}, {"full_name": "Set.not_nonempty_iff_eq_empty", "code": "theorem not_nonempty_iff_eq_empty {s : Set \u03b1} : \u00acs.Nonempty \u2194 s = \u2205", "start": [604, 1], "end": [606, 68], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iff_ne_empty", "code": "theorem nonempty_iff_ne_empty : s.Nonempty \u2194 s \u2260 \u2205", "start": [609, 1], "end": [611, 38], "kind": "commanddeclaration"}, {"full_name": "Set.not_nonempty_iff_eq_empty'", "code": "theorem not_nonempty_iff_eq_empty' : \u00acNonempty s \u2194 s = \u2205", "start": [614, 1], "end": [616, 65], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_iff_ne_empty'", "code": "theorem nonempty_iff_ne_empty' : Nonempty s \u2194 s \u2260 \u2205", "start": [618, 1], "end": [620, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.ne_empty", "code": "alias \u27e8Nonempty.ne_empty, _\u27e9 := nonempty_iff_ne_empty", "start": [622, 1], "end": [622, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.not_nonempty_empty", "code": "@[simp]\ntheorem not_nonempty_empty : \u00ac(\u2205 : Set \u03b1).Nonempty", "start": [625, 1], "end": [626, 72], "kind": "commanddeclaration"}, {"full_name": "Set.isEmpty_coe_sort", "code": "theorem isEmpty_coe_sort {s : Set \u03b1} : IsEmpty (\u21a5s) \u2194 s = \u2205", "start": [631, 1], "end": [632, 56], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_or_nonempty", "code": "theorem eq_empty_or_nonempty (s : Set \u03b1) : s = \u2205 \u2228 s.Nonempty", "start": [635, 1], "end": [636, 48], "kind": "commanddeclaration"}, {"full_name": "Set.subset_eq_empty", "code": "theorem subset_eq_empty {s t : Set \u03b1} (h : t \u2286 s) (e : s = \u2205) : t = \u2205", "start": [639, 1], "end": [640, 30], "kind": "commanddeclaration"}, {"full_name": "Set.ball_empty_iff", "code": "theorem ball_empty_iff {p : \u03b1 \u2192 Prop} : (\u2200 x \u2208 (\u2205 : Set \u03b1), p x) \u2194 True", "start": [643, 1], "end": [644, 37], "kind": "commanddeclaration"}, {"full_name": "Set.empty_ssubset", "code": "@[simp]\ntheorem empty_ssubset : \u2205 \u2282 s \u2194 s.Nonempty", "start": [650, 1], "end": [652, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.empty_ssubset", "code": "alias \u27e8_, Nonempty.empty_ssubset\u27e9 := empty_ssubset", "start": [655, 1], "end": [655, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.setOf_true", "code": "@[simp]\ntheorem setOf_true : { _x : \u03b1 | True } = univ", "start": [668, 1], "end": [670, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_top", "code": "@[simp] theorem setOf_top : { _x : \u03b1 | \u22a4 } = univ", "start": [673, 1], "end": [673, 57], "kind": "commanddeclaration"}, {"full_name": "Set.mem_univ", "code": "@[simp, mfld_simps]\ntheorem mem_univ (x : \u03b1) : x \u2208 @univ \u03b1", "start": [675, 1], "end": [677, 10], "kind": "commanddeclaration"}, {"full_name": "Set.univ_eq_empty_iff", "code": "@[simp]\ntheorem univ_eq_empty_iff : (univ : Set \u03b1) = \u2205 \u2194 IsEmpty \u03b1", "start": [680, 1], "end": [683, 73], "kind": "commanddeclaration"}, {"full_name": "Set.empty_ne_univ", "code": "theorem empty_ne_univ [Nonempty \u03b1] : (\u2205 : Set \u03b1) \u2260 univ", "start": [686, 1], "end": [687, 58], "kind": "commanddeclaration"}, {"full_name": "Set.subset_univ", "code": "@[simp]\ntheorem subset_univ (s : Set \u03b1) : s \u2286 univ", "start": [690, 1], "end": [691, 65], "kind": "commanddeclaration"}, {"full_name": "Set.univ_subset_iff", "code": "theorem univ_subset_iff {s : Set \u03b1} : univ \u2286 s \u2194 s = univ", "start": [694, 1], "end": [695, 22], "kind": "commanddeclaration"}, {"full_name": "Set.eq_univ_of_univ_subset", "code": "alias \u27e8eq_univ_of_univ_subset, _\u27e9 := univ_subset_iff", "start": [698, 1], "end": [698, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.eq_univ_iff_forall", "code": "theorem eq_univ_iff_forall {s : Set \u03b1} : s = univ \u2194 \u2200 x, x \u2208 s", "start": [701, 1], "end": [702, 77], "kind": "commanddeclaration"}, {"full_name": "Set.eq_univ_of_forall", "code": "theorem eq_univ_of_forall {s : Set \u03b1} : (\u2200 x, x \u2208 s) \u2192 s = univ", "start": [705, 1], "end": [706, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.eq_univ", "code": "theorem Nonempty.eq_univ [Subsingleton \u03b1] : s.Nonempty \u2192 s = univ", "start": [709, 1], "end": [711, 68], "kind": "commanddeclaration"}, {"full_name": "Set.eq_univ_of_subset", "code": "theorem eq_univ_of_subset {s t : Set \u03b1} (h : s \u2286 t) (hs : s = univ) : t = univ", "start": [714, 1], "end": [715, 48], "kind": "commanddeclaration"}, {"full_name": "Set.exists_mem_of_nonempty", "code": "theorem exists_mem_of_nonempty (\u03b1) : \u2200 [Nonempty \u03b1], \u2203 x : \u03b1, x \u2208 (univ : Set \u03b1)", "start": [718, 1], "end": [719, 24], "kind": "commanddeclaration"}, {"full_name": "Set.ne_univ_iff_exists_not_mem", "code": "theorem ne_univ_iff_exists_not_mem {\u03b1 : Type*} (s : Set \u03b1) : s \u2260 univ \u2194 \u2203 a, a \u2209 s", "start": [722, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "Set.not_subset_iff_exists_mem_not_mem", "code": "theorem not_subset_iff_exists_mem_not_mem {\u03b1 : Type*} {s t : Set \u03b1} :\n    \u00acs \u2286 t \u2194 \u2203 x, x \u2208 s \u2227 x \u2209 t", "start": [726, 1], "end": [727, 56], "kind": "commanddeclaration"}, {"full_name": "Set.univ_unique", "code": "theorem univ_unique [Unique \u03b1] : @Set.univ \u03b1 = {default}", "start": [730, 1], "end": [731, 70], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_univ_iff", "code": "theorem ssubset_univ_iff : s \u2282 univ \u2194 s \u2260 univ", "start": [734, 1], "end": [735, 20], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_nonempty", "code": "instance nontrivial_of_nonempty [Nonempty \u03b1] : Nontrivial (Set \u03b1) :=\n  \u27e8\u27e8\u2205, univ, empty_ne_univ\u27e9\u27e9", "start": [738, 1], "end": [739, 29], "kind": "commanddeclaration"}, {"full_name": "Set.union_def", "code": "theorem union_def {s\u2081 s\u2082 : Set \u03b1} : s\u2081 \u222a s\u2082 = { a | a \u2208 s\u2081 \u2228 a \u2208 s\u2082 }", "start": [745, 1], "end": [746, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_union_left", "code": "theorem mem_union_left {x : \u03b1} {a : Set \u03b1} (b : Set \u03b1) : x \u2208 a \u2192 x \u2208 a \u222a b", "start": [749, 1], "end": [750, 9], "kind": "commanddeclaration"}, {"full_name": "Set.mem_union_right", "code": "theorem mem_union_right {x : \u03b1} {b : Set \u03b1} (a : Set \u03b1) : x \u2208 b \u2192 x \u2208 a \u222a b", "start": [753, 1], "end": [754, 9], "kind": "commanddeclaration"}, {"full_name": "Set.mem_or_mem_of_mem_union", "code": "theorem mem_or_mem_of_mem_union {x : \u03b1} {a b : Set \u03b1} (H : x \u2208 a \u222a b) : x \u2208 a \u2228 x \u2208 b", "start": [757, 1], "end": [758, 4], "kind": "commanddeclaration"}, {"full_name": "Set.MemUnion.elim", "code": "theorem MemUnion.elim {x : \u03b1} {a b : Set \u03b1} {P : Prop} (H\u2081 : x \u2208 a \u222a b) (H\u2082 : x \u2208 a \u2192 P)\n    (H\u2083 : x \u2208 b \u2192 P) : P", "start": [761, 1], "end": [763, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mem_union", "code": "@[simp]\ntheorem mem_union (x : \u03b1) (a b : Set \u03b1) : x \u2208 a \u222a b \u2194 x \u2208 a \u2228 x \u2208 b", "start": [766, 1], "end": [768, 10], "kind": "commanddeclaration"}, {"full_name": "Set.union_self", "code": "@[simp]\ntheorem union_self (a : Set \u03b1) : a \u222a a = a", "start": [771, 1], "end": [773, 29], "kind": "commanddeclaration"}, {"full_name": "Set.union_empty", "code": "@[simp]\ntheorem union_empty (a : Set \u03b1) : a \u222a \u2205 = a", "start": [776, 1], "end": [778, 30], "kind": "commanddeclaration"}, {"full_name": "Set.empty_union", "code": "@[simp]\ntheorem empty_union (a : Set \u03b1) : \u2205 \u222a a = a", "start": [781, 1], "end": [783, 30], "kind": "commanddeclaration"}, {"full_name": "Set.union_comm", "code": "theorem union_comm (a b : Set \u03b1) : a \u222a b = b \u222a a", "start": [786, 1], "end": [787, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_assoc", "code": "theorem union_assoc (a b c : Set \u03b1) : a \u222a b \u222a c = a \u222a (b \u222a c)", "start": [790, 1], "end": [791, 24], "kind": "commanddeclaration"}, {"full_name": "Set.union_isAssoc", "code": "instance union_isAssoc : IsAssociative (Set \u03b1) (\u00b7 \u222a \u00b7) :=\n  \u27e8union_assoc\u27e9", "start": [794, 1], "end": [795, 16], "kind": "commanddeclaration"}, {"full_name": "Set.union_isComm", "code": "instance union_isComm : IsCommutative (Set \u03b1) (\u00b7 \u222a \u00b7) :=\n  \u27e8union_comm\u27e9", "start": [798, 1], "end": [799, 15], "kind": "commanddeclaration"}, {"full_name": "Set.union_left_comm", "code": "theorem union_left_comm (s\u2081 s\u2082 s\u2083 : Set \u03b1) : s\u2081 \u222a (s\u2082 \u222a s\u2083) = s\u2082 \u222a (s\u2081 \u222a s\u2083)", "start": [802, 1], "end": [803, 28], "kind": "commanddeclaration"}, {"full_name": "Set.union_right_comm", "code": "theorem union_right_comm (s\u2081 s\u2082 s\u2083 : Set \u03b1) : s\u2081 \u222a s\u2082 \u222a s\u2083 = s\u2081 \u222a s\u2083 \u222a s\u2082", "start": [806, 1], "end": [807, 29], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_left", "code": "@[simp]\ntheorem union_eq_left {s t : Set \u03b1} : s \u222a t = s \u2194 t \u2286 s", "start": [810, 1], "end": [812, 14], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_right", "code": "@[simp]\ntheorem union_eq_right {s t : Set \u03b1} : s \u222a t = t \u2194 s \u2286 t", "start": [815, 1], "end": [817, 15], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_self_of_subset_left", "code": "theorem union_eq_self_of_subset_left {s t : Set \u03b1} (h : s \u2286 t) : s \u222a t = t", "start": [820, 1], "end": [821, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_self_of_subset_right", "code": "theorem union_eq_self_of_subset_right {s t : Set \u03b1} (h : t \u2286 s) : s \u222a t = s", "start": [824, 1], "end": [825, 22], "kind": "commanddeclaration"}, {"full_name": "Set.subset_union_left", "code": "@[simp]\ntheorem subset_union_left (s t : Set \u03b1) : s \u2286 s \u222a t", "start": [828, 1], "end": [829, 71], "kind": "commanddeclaration"}, {"full_name": "Set.subset_union_right", "code": "@[simp]\ntheorem subset_union_right (s t : Set \u03b1) : t \u2286 s \u222a t", "start": [832, 1], "end": [833, 72], "kind": "commanddeclaration"}, {"full_name": "Set.union_subset", "code": "theorem union_subset {s t r : Set \u03b1} (sr : s \u2286 r) (tr : t \u2286 r) : s \u222a t \u2286 r", "start": [836, 1], "end": [837, 25], "kind": "commanddeclaration"}, {"full_name": "Set.union_subset_iff", "code": "@[simp]\ntheorem union_subset_iff {s t u : Set \u03b1} : s \u222a t \u2286 u \u2194 s \u2286 u \u2227 t \u2286 u", "start": [840, 1], "end": [842, 51], "kind": "commanddeclaration"}, {"full_name": "Set.union_subset_union", "code": "@[gcongr]\ntheorem union_subset_union {s\u2081 s\u2082 t\u2081 t\u2082 : Set \u03b1} (h\u2081 : s\u2081 \u2286 s\u2082) (h\u2082 : t\u2081 \u2286 t\u2082) :\n    s\u2081 \u222a t\u2081 \u2286 s\u2082 \u222a t\u2082", "start": [845, 1], "end": [847, 57], "kind": "commanddeclaration"}, {"full_name": "Set.union_subset_union_left", "code": "@[gcongr]\ntheorem union_subset_union_left {s\u2081 s\u2082 : Set \u03b1} (t) (h : s\u2081 \u2286 s\u2082) : s\u2081 \u222a t \u2286 s\u2082 \u222a t", "start": [850, 1], "end": [852, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_subset_union_right", "code": "@[gcongr]\ntheorem union_subset_union_right (s) {t\u2081 t\u2082 : Set \u03b1} (h : t\u2081 \u2286 t\u2082) : s \u222a t\u2081 \u2286 s \u222a t\u2082", "start": [855, 1], "end": [857, 34], "kind": "commanddeclaration"}, {"full_name": "Set.subset_union_of_subset_left", "code": "theorem subset_union_of_subset_left {s t : Set \u03b1} (h : s \u2286 t) (u : Set \u03b1) : s \u2286 t \u222a u", "start": [860, 1], "end": [861, 41], "kind": "commanddeclaration"}, {"full_name": "Set.subset_union_of_subset_right", "code": "theorem subset_union_of_subset_right {s u : Set \u03b1} (h : s \u2286 u) (t : Set \u03b1) : s \u2286 t \u222a u", "start": [864, 1], "end": [865, 42], "kind": "commanddeclaration"}, {"full_name": "Set.union_congr_left", "code": "theorem union_congr_left (ht : t \u2286 s \u222a u) (hu : u \u2286 s \u222a t) : s \u222a t = s \u222a u", "start": [869, 1], "end": [870, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_congr_right", "code": "theorem union_congr_right (hs : s \u2286 t \u222a u) (ht : t \u2286 s \u222a u) : s \u222a u = t \u222a u", "start": [873, 1], "end": [874, 24], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_union_iff_left", "code": "theorem union_eq_union_iff_left : s \u222a t = s \u222a u \u2194 t \u2286 s \u222a u \u2227 u \u2286 s \u222a t", "start": [877, 1], "end": [878, 22], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_union_iff_right", "code": "theorem union_eq_union_iff_right : s \u222a u = t \u222a u \u2194 s \u2286 t \u222a u \u2227 t \u2286 s \u222a u", "start": [881, 1], "end": [882, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_empty_iff", "code": "@[simp]\ntheorem union_empty_iff {s t : Set \u03b1} : s \u222a t = \u2205 \u2194 s = \u2205 \u2227 t = \u2205", "start": [885, 1], "end": [888, 25], "kind": "commanddeclaration"}, {"full_name": "Set.union_univ", "code": "@[simp]\ntheorem union_univ {s : Set \u03b1} : s \u222a univ = univ", "start": [891, 1], "end": [893, 13], "kind": "commanddeclaration"}, {"full_name": "Set.univ_union", "code": "@[simp]\ntheorem univ_union {s : Set \u03b1} : univ \u222a s = univ", "start": [896, 1], "end": [898, 13], "kind": "commanddeclaration"}, {"full_name": "Set.inter_def", "code": "theorem inter_def {s\u2081 s\u2082 : Set \u03b1} : s\u2081 \u2229 s\u2082 = { a | a \u2208 s\u2081 \u2227 a \u2208 s\u2082 }", "start": [904, 1], "end": [905, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_inter_iff", "code": "@[simp, mfld_simps]\ntheorem mem_inter_iff (x : \u03b1) (a b : Set \u03b1) : x \u2208 a \u2229 b \u2194 x \u2208 a \u2227 x \u2208 b", "start": [908, 1], "end": [910, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_inter", "code": "theorem mem_inter {x : \u03b1} {a b : Set \u03b1} (ha : x \u2208 a) (hb : x \u2208 b) : x \u2208 a \u2229 b", "start": [913, 1], "end": [914, 11], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_inter_left", "code": "theorem mem_of_mem_inter_left {x : \u03b1} {a b : Set \u03b1} (h : x \u2208 a \u2229 b) : x \u2208 a", "start": [917, 1], "end": [918, 9], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_inter_right", "code": "theorem mem_of_mem_inter_right {x : \u03b1} {a b : Set \u03b1} (h : x \u2208 a \u2229 b) : x \u2208 b", "start": [921, 1], "end": [922, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inter_self", "code": "@[simp]\ntheorem inter_self (a : Set \u03b1) : a \u2229 a = a", "start": [925, 1], "end": [927, 30], "kind": "commanddeclaration"}, {"full_name": "Set.inter_empty", "code": "@[simp]\ntheorem inter_empty (a : Set \u03b1) : a \u2229 \u2205 = \u2205", "start": [930, 1], "end": [932, 31], "kind": "commanddeclaration"}, {"full_name": "Set.empty_inter", "code": "@[simp]\ntheorem empty_inter (a : Set \u03b1) : \u2205 \u2229 a = \u2205", "start": [935, 1], "end": [937, 31], "kind": "commanddeclaration"}, {"full_name": "Set.inter_comm", "code": "theorem inter_comm (a b : Set \u03b1) : a \u2229 b = b \u2229 a", "start": [940, 1], "end": [941, 24], "kind": "commanddeclaration"}, {"full_name": "Set.inter_assoc", "code": "theorem inter_assoc (a b c : Set \u03b1) : a \u2229 b \u2229 c = a \u2229 (b \u2229 c)", "start": [944, 1], "end": [945, 25], "kind": "commanddeclaration"}, {"full_name": "Set.inter_isAssoc", "code": "instance inter_isAssoc : IsAssociative (Set \u03b1) (\u00b7 \u2229 \u00b7) :=\n  \u27e8inter_assoc\u27e9", "start": [948, 1], "end": [949, 16], "kind": "commanddeclaration"}, {"full_name": "Set.inter_isComm", "code": "instance inter_isComm : IsCommutative (Set \u03b1) (\u00b7 \u2229 \u00b7) :=\n  \u27e8inter_comm\u27e9", "start": [952, 1], "end": [953, 15], "kind": "commanddeclaration"}, {"full_name": "Set.inter_left_comm", "code": "theorem inter_left_comm (s\u2081 s\u2082 s\u2083 : Set \u03b1) : s\u2081 \u2229 (s\u2082 \u2229 s\u2083) = s\u2082 \u2229 (s\u2081 \u2229 s\u2083)", "start": [956, 1], "end": [957, 29], "kind": "commanddeclaration"}, {"full_name": "Set.inter_right_comm", "code": "theorem inter_right_comm (s\u2081 s\u2082 s\u2083 : Set \u03b1) : s\u2081 \u2229 s\u2082 \u2229 s\u2083 = s\u2081 \u2229 s\u2083 \u2229 s\u2082", "start": [960, 1], "end": [961, 30], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_left", "code": "@[simp, mfld_simps]\ntheorem inter_subset_left (s t : Set \u03b1) : s \u2229 t \u2286 s", "start": [964, 1], "end": [965, 73], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_right", "code": "@[simp]\ntheorem inter_subset_right (s t : Set \u03b1) : s \u2229 t \u2286 t", "start": [968, 1], "end": [969, 75], "kind": "commanddeclaration"}, {"full_name": "Set.subset_inter", "code": "theorem subset_inter {s t r : Set \u03b1} (rs : r \u2286 s) (rt : r \u2286 t) : r \u2286 s \u2229 t", "start": [972, 1], "end": [973, 15], "kind": "commanddeclaration"}, {"full_name": "Set.subset_inter_iff", "code": "@[simp]\ntheorem subset_inter_iff {s t r : Set \u03b1} : r \u2286 s \u2229 t \u2194 r \u2286 s \u2227 r \u2286 t", "start": [976, 1], "end": [978, 52], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_left", "code": "@[simp] lemma inter_eq_left : s \u2229 t = s \u2194 s \u2286 t := inf_eq_left", "start": [981, 1], "end": [981, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Set.inter_eq_right", "code": "@[simp] lemma inter_eq_right : s \u2229 t = t \u2194 t \u2286 s := inf_eq_right", "start": [984, 1], "end": [984, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Set.inter_eq_self_of_subset_left", "code": "theorem inter_eq_self_of_subset_left {s t : Set \u03b1} : s \u2286 t \u2192 s \u2229 t = s", "start": [987, 1], "end": [988, 20], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_self_of_subset_right", "code": "theorem inter_eq_self_of_subset_right {s t : Set \u03b1} : t \u2286 s \u2192 s \u2229 t = t", "start": [991, 1], "end": [992, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_congr_left", "code": "theorem inter_congr_left (ht : s \u2229 u \u2286 t) (hu : s \u2229 t \u2286 u) : s \u2229 t = s \u2229 u", "start": [995, 1], "end": [996, 23], "kind": "commanddeclaration"}, {"full_name": "Set.inter_congr_right", "code": "theorem inter_congr_right (hs : t \u2229 u \u2286 s) (ht : s \u2229 u \u2286 t) : s \u2229 u = t \u2229 u", "start": [999, 1], "end": [1000, 24], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_inter_iff_left", "code": "theorem inter_eq_inter_iff_left : s \u2229 t = s \u2229 u \u2194 s \u2229 u \u2286 t \u2227 s \u2229 t \u2286 u", "start": [1003, 1], "end": [1004, 22], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_inter_iff_right", "code": "theorem inter_eq_inter_iff_right : s \u2229 u = t \u2229 u \u2194 t \u2229 u \u2286 s \u2227 s \u2229 u \u2286 t", "start": [1007, 1], "end": [1008, 23], "kind": "commanddeclaration"}, {"full_name": "Set.inter_univ", "code": "@[simp, mfld_simps]\ntheorem inter_univ (a : Set \u03b1) : a \u2229 univ = a", "start": [1011, 1], "end": [1013, 13], "kind": "commanddeclaration"}, {"full_name": "Set.univ_inter", "code": "@[simp, mfld_simps]\ntheorem univ_inter (a : Set \u03b1) : univ \u2229 a = a", "start": [1016, 1], "end": [1018, 13], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_inter", "code": "@[gcongr]\ntheorem inter_subset_inter {s\u2081 s\u2082 t\u2081 t\u2082 : Set \u03b1} (h\u2081 : s\u2081 \u2286 t\u2081) (h\u2082 : s\u2082 \u2286 t\u2082) :\n    s\u2081 \u2229 s\u2082 \u2286 t\u2081 \u2229 t\u2082", "start": [1021, 1], "end": [1023, 58], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_inter_left", "code": "@[gcongr]\ntheorem inter_subset_inter_left {s t : Set \u03b1} (u : Set \u03b1) (H : s \u2286 t) : s \u2229 u \u2286 t \u2229 u", "start": [1026, 1], "end": [1028, 34], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_inter_right", "code": "@[gcongr]\ntheorem inter_subset_inter_right {s t : Set \u03b1} (u : Set \u03b1) (H : s \u2286 t) : u \u2229 s \u2286 u \u2229 t", "start": [1031, 1], "end": [1033, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_inter_cancel_left", "code": "theorem union_inter_cancel_left {s t : Set \u03b1} : (s \u222a t) \u2229 s = s", "start": [1036, 1], "end": [1037, 57], "kind": "commanddeclaration"}, {"full_name": "Set.union_inter_cancel_right", "code": "theorem union_inter_cancel_right {s t : Set \u03b1} : (s \u222a t) \u2229 t = t", "start": [1040, 1], "end": [1041, 58], "kind": "commanddeclaration"}, {"full_name": "Set.inter_setOf_eq_sep", "code": "theorem inter_setOf_eq_sep (s : Set \u03b1) (p : \u03b1 \u2192 Prop) : s \u2229 {a | p a} = {a \u2208 s | p a}", "start": [1044, 1], "end": [1045, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_inter_eq_sep", "code": "theorem setOf_inter_eq_sep (p : \u03b1 \u2192 Prop) (s : Set \u03b1) : {a | p a} \u2229 s = {a \u2208 s | p a}", "start": [1048, 1], "end": [1049, 17], "kind": "commanddeclaration"}, {"full_name": "Set.inter_distrib_left", "code": "theorem inter_distrib_left (s t u : Set \u03b1) : s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u", "start": [1055, 1], "end": [1056, 15], "kind": "commanddeclaration"}, {"full_name": "Set.inter_union_distrib_left", "code": "theorem inter_union_distrib_left {s t u : Set \u03b1} : s \u2229 (t \u222a u) = s \u2229 t \u222a s \u2229 u", "start": [1059, 1], "end": [1060, 15], "kind": "commanddeclaration"}, {"full_name": "Set.inter_distrib_right", "code": "theorem inter_distrib_right (s t u : Set \u03b1) : (s \u222a t) \u2229 u = s \u2229 u \u222a t \u2229 u", "start": [1063, 1], "end": [1064, 16], "kind": "commanddeclaration"}, {"full_name": "Set.union_inter_distrib_right", "code": "theorem union_inter_distrib_right {s t u : Set \u03b1} : (s \u222a t) \u2229 u = s \u2229 u \u222a t \u2229 u", "start": [1067, 1], "end": [1068, 16], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_left", "code": "theorem union_distrib_left (s t u : Set \u03b1) : s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "start": [1071, 1], "end": [1072, 15], "kind": "commanddeclaration"}, {"full_name": "Set.union_inter_distrib_left", "code": "theorem union_inter_distrib_left {s t u : Set \u03b1} : s \u222a t \u2229 u = (s \u222a t) \u2229 (s \u222a u)", "start": [1075, 1], "end": [1076, 15], "kind": "commanddeclaration"}, {"full_name": "Set.union_distrib_right", "code": "theorem union_distrib_right (s t u : Set \u03b1) : s \u2229 t \u222a u = (s \u222a u) \u2229 (t \u222a u)", "start": [1079, 1], "end": [1080, 16], "kind": "commanddeclaration"}, {"full_name": "Set.inter_union_distrib_right", "code": "theorem inter_union_distrib_right {s t u : Set \u03b1} : s \u2229 t \u222a u = (s \u222a u) \u2229 (t \u222a u)", "start": [1083, 1], "end": [1084, 16], "kind": "commanddeclaration"}, {"full_name": "Set.union_union_distrib_left", "code": "theorem union_union_distrib_left (s t u : Set \u03b1) : s \u222a (t \u222a u) = s \u222a t \u222a (s \u222a u)", "start": [1087, 1], "end": [1088, 29], "kind": "commanddeclaration"}, {"full_name": "Set.union_union_distrib_right", "code": "theorem union_union_distrib_right (s t u : Set \u03b1) : s \u222a t \u222a u = s \u222a u \u222a (t \u222a u)", "start": [1091, 1], "end": [1092, 30], "kind": "commanddeclaration"}, {"full_name": "Set.inter_inter_distrib_left", "code": "theorem inter_inter_distrib_left (s t u : Set \u03b1) : s \u2229 (t \u2229 u) = s \u2229 t \u2229 (s \u2229 u)", "start": [1095, 1], "end": [1096, 29], "kind": "commanddeclaration"}, {"full_name": "Set.inter_inter_distrib_right", "code": "theorem inter_inter_distrib_right (s t u : Set \u03b1) : s \u2229 t \u2229 u = s \u2229 u \u2229 (t \u2229 u)", "start": [1099, 1], "end": [1100, 30], "kind": "commanddeclaration"}, {"full_name": "Set.union_union_union_comm", "code": "theorem union_union_union_comm (s t u v : Set \u03b1) : s \u222a t \u222a (u \u222a v) = s \u222a u \u222a (t \u222a v)", "start": [1103, 1], "end": [1104, 27], "kind": "commanddeclaration"}, {"full_name": "Set.inter_inter_inter_comm", "code": "theorem inter_inter_inter_comm (s t u v : Set \u03b1) : s \u2229 t \u2229 (u \u2229 v) = s \u2229 u \u2229 (t \u2229 v)", "start": [1107, 1], "end": [1108, 27], "kind": "commanddeclaration"}, {"full_name": "Set.insert_def", "code": "theorem insert_def (x : \u03b1) (s : Set \u03b1) : insert x s = { y | y = x \u2228 y \u2208 s }", "start": [1118, 1], "end": [1119, 6], "kind": "commanddeclaration"}, {"full_name": "Set.subset_insert", "code": "@[simp]\ntheorem subset_insert (x : \u03b1) (s : Set \u03b1) : s \u2286 insert x s", "start": [1122, 1], "end": [1123, 78], "kind": "commanddeclaration"}, {"full_name": "Set.mem_insert", "code": "theorem mem_insert (x : \u03b1) (s : Set \u03b1) : x \u2208 insert x s", "start": [1126, 1], "end": [1127, 13], "kind": "commanddeclaration"}, {"full_name": "Set.mem_insert_of_mem", "code": "theorem mem_insert_of_mem {x : \u03b1} {s : Set \u03b1} (y : \u03b1) : x \u2208 s \u2192 x \u2208 insert y s", "start": [1130, 1], "end": [1131, 9], "kind": "commanddeclaration"}, {"full_name": "Set.eq_or_mem_of_mem_insert", "code": "theorem eq_or_mem_of_mem_insert {x a : \u03b1} {s : Set \u03b1} : x \u2208 insert a s \u2192 x = a \u2228 x \u2208 s", "start": [1134, 1], "end": [1135, 5], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_insert_of_ne", "code": "theorem mem_of_mem_insert_of_ne : b \u2208 insert a s \u2192 b \u2260 a \u2192 b \u2208 s", "start": [1138, 1], "end": [1139, 18], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_not_mem_of_mem_insert", "code": "theorem eq_of_not_mem_of_mem_insert : b \u2208 insert a s \u2192 b \u2209 s \u2192 b = a", "start": [1142, 1], "end": [1143, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mem_insert_iff", "code": "@[simp]\ntheorem mem_insert_iff {x a : \u03b1} {s : Set \u03b1} : x \u2208 insert a s \u2194 x = a \u2228 x \u2208 s", "start": [1146, 1], "end": [1148, 10], "kind": "commanddeclaration"}, {"full_name": "Set.insert_eq_of_mem", "code": "@[simp]\ntheorem insert_eq_of_mem {a : \u03b1} {s : Set \u03b1} (h : a \u2208 s) : insert a s = s", "start": [1151, 1], "end": [1153, 55], "kind": "commanddeclaration"}, {"full_name": "Set.ne_insert_of_not_mem", "code": "theorem ne_insert_of_not_mem {s : Set \u03b1} (t : Set \u03b1) {a : \u03b1} : a \u2209 s \u2192 s \u2260 insert a t", "start": [1156, 1], "end": [1157, 38], "kind": "commanddeclaration"}, {"full_name": "Set.insert_eq_self", "code": "@[simp]\ntheorem insert_eq_self : insert a s = s \u2194 a \u2208 s", "start": [1160, 1], "end": [1162, 50], "kind": "commanddeclaration"}, {"full_name": "Set.insert_ne_self", "code": "theorem insert_ne_self : insert a s \u2260 s \u2194 a \u2209 s", "start": [1165, 1], "end": [1166, 21], "kind": "commanddeclaration"}, {"full_name": "Set.insert_subset_iff", "code": "theorem insert_subset_iff : insert a s \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t", "start": [1169, 1], "end": [1170, 72], "kind": "commanddeclaration"}, {"full_name": "Set.insert_subset", "code": "theorem insert_subset (ha : a \u2208 t) (hs : s \u2286 t) : insert a s \u2286 t", "start": [1173, 1], "end": [1174, 33], "kind": "commanddeclaration"}, {"full_name": "Set.insert_subset_insert", "code": "theorem insert_subset_insert (h : s \u2286 t) : insert a s \u2286 insert a t", "start": [1176, 1], "end": [1176, 99], "kind": "commanddeclaration"}, {"full_name": "Set.insert_subset_insert_iff", "code": "@[simp] theorem insert_subset_insert_iff (ha : a \u2209 s) : insert a s \u2286 insert a t \u2194 s \u2286 t", "start": [1179, 1], "end": [1182, 29], "kind": "commanddeclaration"}, {"full_name": "Set.subset_insert_iff_of_not_mem", "code": "theorem subset_insert_iff_of_not_mem (ha : a \u2209 s) : s \u2286 insert a t \u2194 s \u2286 t", "start": [1185, 1], "end": [1186, 74], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_iff_insert", "code": "theorem ssubset_iff_insert {s t : Set \u03b1} : s \u2282 t \u2194 \u2203 (a : \u03b1) (_ : a \u2209 s), insert a s \u2286 t", "start": [1189, 1], "end": [1191, 36], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_insert", "code": "theorem ssubset_insert {s : Set \u03b1} {a : \u03b1} (h : a \u2209 s) : s \u2282 insert a s", "start": [1194, 1], "end": [1195, 42], "kind": "commanddeclaration"}, {"full_name": "Set.insert_comm", "code": "theorem insert_comm (a b : \u03b1) (s : Set \u03b1) : insert a (insert b s) = insert b (insert a s)", "start": [1198, 1], "end": [1199, 28], "kind": "commanddeclaration"}, {"full_name": "Set.insert_idem", "code": "theorem insert_idem (a : \u03b1) (s : Set \u03b1) : insert a (insert a s) = insert a s", "start": [1203, 1], "end": [1204, 37], "kind": "commanddeclaration"}, {"full_name": "Set.insert_union", "code": "theorem insert_union : insert a s \u222a t = insert a (s \u222a t)", "start": [1207, 1], "end": [1208, 24], "kind": "commanddeclaration"}, {"full_name": "Set.union_insert", "code": "@[simp]\ntheorem union_insert : s \u222a insert a t = insert a (s \u222a t)", "start": [1211, 1], "end": [1213, 28], "kind": "commanddeclaration"}, {"full_name": "Set.insert_nonempty", "code": "@[simp]\ntheorem insert_nonempty (a : \u03b1) (s : Set \u03b1) : (insert a s).Nonempty", "start": [1216, 1], "end": [1218, 22], "kind": "commanddeclaration"}, {"full_name": "Set.insert_inter_distrib", "code": "theorem insert_inter_distrib (a : \u03b1) (s t : Set \u03b1) : insert a (s \u2229 t) = insert a s \u2229 insert a t", "start": [1224, 1], "end": [1225, 27], "kind": "commanddeclaration"}, {"full_name": "Set.insert_union_distrib", "code": "theorem insert_union_distrib (a : \u03b1) (s t : Set \u03b1) : insert a (s \u222a t) = insert a s \u222a insert a t", "start": [1228, 1], "end": [1229, 34], "kind": "commanddeclaration"}, {"full_name": "Set.insert_inj", "code": "theorem insert_inj (ha : a \u2209 s) : insert a s = insert b s \u2194 a = b", "start": [1232, 1], "end": [1234, 37], "kind": "commanddeclaration"}, {"full_name": "Set.forall_of_forall_insert", "code": "theorem forall_of_forall_insert {P : \u03b1 \u2192 Prop} {a : \u03b1} {s : Set \u03b1} (H : \u2200 x, x \u2208 insert a s \u2192 P x)\n    (x) (h : x \u2208 s) : P x", "start": [1238, 1], "end": [1240, 17], "kind": "commanddeclaration"}, {"full_name": "Set.forall_insert_of_forall", "code": "theorem forall_insert_of_forall {P : \u03b1 \u2192 Prop} {a : \u03b1} {s : Set \u03b1} (H : \u2200 x, x \u2208 s \u2192 P x) (ha : P a)\n    (x) (h : x \u2208 insert a s) : P x", "start": [1243, 1], "end": [1245, 38], "kind": "commanddeclaration"}, {"full_name": "Set.bex_insert_iff", "code": "theorem bex_insert_iff {P : \u03b1 \u2192 Prop} {a : \u03b1} {s : Set \u03b1} :\n    (\u2203 x \u2208 insert a s, P x) \u2194 (P a \u2228 \u2203 x \u2208 s, P x)", "start": [1250, 1], "end": [1252, 66], "kind": "commanddeclaration"}, {"full_name": "Set.ball_insert_iff", "code": "theorem ball_insert_iff {P : \u03b1 \u2192 Prop} {a : \u03b1} {s : Set \u03b1} :\n    (\u2200 x \u2208 insert a s, P x) \u2194 P a \u2227 \u2200 x \u2208 s, P x", "start": [1255, 1], "end": [1257, 50], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_def", "code": "theorem singleton_def (a : \u03b1) : ({a} : Set \u03b1) = insert a \u2205", "start": [1268, 1], "end": [1269, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mem_singleton_iff", "code": "@[simp]\ntheorem mem_singleton_iff {a b : \u03b1} : a \u2208 ({b} : Set \u03b1) \u2194 a = b", "start": [1272, 1], "end": [1274, 10], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_eq_eq_singleton", "code": "@[simp]\ntheorem setOf_eq_eq_singleton {a : \u03b1} : { n | n = a } = {a}", "start": [1277, 1], "end": [1279, 6], "kind": "commanddeclaration"}, {"full_name": "Set.setOf_eq_eq_singleton'", "code": "@[simp]\ntheorem setOf_eq_eq_singleton' {a : \u03b1} : { x | a = x } = {a}", "start": [1282, 1], "end": [1284, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_singleton", "code": "theorem mem_singleton (a : \u03b1) : a \u2208 ({a} : Set \u03b1)", "start": [1289, 1], "end": [1290, 11], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_mem_singleton", "code": "theorem eq_of_mem_singleton {x y : \u03b1} (h : x \u2208 ({y} : Set \u03b1)) : x = y", "start": [1293, 1], "end": [1294, 4], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_eq_singleton_iff", "code": "@[simp]\ntheorem singleton_eq_singleton_iff {x y : \u03b1} : {x} = ({y} : Set \u03b1) \u2194 x = y", "start": [1297, 1], "end": [1299, 38], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_injective", "code": "theorem singleton_injective : Injective (singleton : \u03b1 \u2192 Set \u03b1)", "start": [1302, 1], "end": [1303, 32], "kind": "commanddeclaration"}, {"full_name": "Set.mem_singleton_of_eq", "code": "theorem mem_singleton_of_eq {x y : \u03b1} (H : x = y) : x \u2208 ({y} : Set \u03b1)", "start": [1306, 1], "end": [1307, 4], "kind": "commanddeclaration"}, {"full_name": "Set.insert_eq", "code": "theorem insert_eq (x : \u03b1) (s : Set \u03b1) : insert x s = ({x} : Set \u03b1) \u222a s", "start": [1310, 1], "end": [1311, 6], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_nonempty", "code": "@[simp]\ntheorem singleton_nonempty (a : \u03b1) : ({a} : Set \u03b1).Nonempty", "start": [1314, 1], "end": [1316, 11], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_ne_empty", "code": "@[simp]\ntheorem singleton_ne_empty (a : \u03b1) : ({a} : Set \u03b1) \u2260 \u2205", "start": [1319, 1], "end": [1321, 34], "kind": "commanddeclaration"}, {"full_name": "Set.empty_ssubset_singleton", "code": "theorem empty_ssubset_singleton : (\u2205 : Set \u03b1) \u2282 {a}", "start": [1325, 1], "end": [1326, 39], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_subset_iff", "code": "@[simp]\ntheorem singleton_subset_iff {a : \u03b1} {s : Set \u03b1} : {a} \u2286 s \u2194 a \u2208 s", "start": [1329, 1], "end": [1331, 12], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_subset_singleton", "code": "theorem singleton_subset_singleton : ({a} : Set \u03b1) \u2286 {b} \u2194 a = b", "start": [1334, 1], "end": [1334, 76], "kind": "commanddeclaration"}, {"full_name": "Set.set_compr_eq_eq_singleton", "code": "theorem set_compr_eq_eq_singleton {a : \u03b1} : { b | b = a } = {a}", "start": [1337, 1], "end": [1338, 6], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_union", "code": "@[simp]\ntheorem singleton_union : {a} \u222a s = insert a s", "start": [1341, 1], "end": [1343, 6], "kind": "commanddeclaration"}, {"full_name": "Set.union_singleton", "code": "@[simp]\ntheorem union_singleton : s \u222a {a} = insert a s", "start": [1346, 1], "end": [1348, 17], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_inter_nonempty", "code": "@[simp]\ntheorem singleton_inter_nonempty : ({a} \u2229 s).Nonempty \u2194 a \u2208 s", "start": [1351, 1], "end": [1353, 77], "kind": "commanddeclaration"}, {"full_name": "Set.inter_singleton_nonempty", "code": "@[simp]\ntheorem inter_singleton_nonempty : (s \u2229 {a}).Nonempty \u2194 a \u2208 s", "start": [1356, 1], "end": [1358, 44], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_inter_eq_empty", "code": "@[simp]\ntheorem singleton_inter_eq_empty : {a} \u2229 s = \u2205 \u2194 a \u2209 s", "start": [1361, 1], "end": [1363, 68], "kind": "commanddeclaration"}, {"full_name": "Set.inter_singleton_eq_empty", "code": "@[simp]\ntheorem inter_singleton_eq_empty : s \u2229 {a} = \u2205 \u2194 a \u2209 s", "start": [1366, 1], "end": [1368, 44], "kind": "commanddeclaration"}, {"full_name": "Set.nmem_singleton_empty", "code": "theorem nmem_singleton_empty {s : Set \u03b1} : s \u2209 ({\u2205} : Set (Set \u03b1)) \u2194 s.Nonempty", "start": [1371, 1], "end": [1372, 29], "kind": "commanddeclaration"}, {"full_name": "Set.uniqueSingleton", "code": "instance uniqueSingleton (a : \u03b1) : Unique (\u21a5({a} : Set \u03b1)) :=\n  \u27e8\u27e8\u27e8a, mem_singleton a\u27e9\u27e9, fun \u27e8_, h\u27e9 => Subtype.eq h\u27e9", "start": [1375, 1], "end": [1376, 55], "kind": "commanddeclaration"}, {"full_name": "Set.eq_singleton_iff_unique_mem", "code": "theorem eq_singleton_iff_unique_mem : s = {a} \u2194 a \u2208 s \u2227 \u2200 x \u2208 s, x = a", "start": [1379, 1], "end": [1380, 86], "kind": "commanddeclaration"}, {"full_name": "Set.eq_singleton_iff_nonempty_unique_mem", "code": "theorem eq_singleton_iff_nonempty_unique_mem : s = {a} \u2194 s.Nonempty \u2227 \u2200 x \u2208 s, x = a", "start": [1383, 1], "end": [1385, 73], "kind": "commanddeclaration"}, {"full_name": "Set.default_coe_singleton", "code": "@[simp]\ntheorem default_coe_singleton (x : \u03b1) : (default : ({x} : Set \u03b1)) = \u27e8x, rfl\u27e9", "start": [1389, 1], "end": [1391, 6], "kind": "commanddeclaration"}, {"full_name": "Set.pair_eq_singleton", "code": "theorem pair_eq_singleton (a : \u03b1) : ({a, a} : Set \u03b1) = {a}", "start": [1398, 1], "end": [1399, 15], "kind": "commanddeclaration"}, {"full_name": "Set.pair_comm", "code": "theorem pair_comm (a b : \u03b1) : ({a, b} : Set \u03b1) = {b, a}", "start": [1402, 1], "end": [1403, 17], "kind": "commanddeclaration"}, {"full_name": "Set.pair_eq_pair_iff", "code": "theorem pair_eq_pair_iff {x y z w : \u03b1} :\n    ({x, y} : Set \u03b1) = {z, w} \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z", "start": [1407, 1], "end": [1413, 46], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sep", "code": "theorem mem_sep (xs : x \u2208 s) (px : p x) : x \u2208 { x \u2208 s | p x }", "start": [1423, 1], "end": [1424, 11], "kind": "commanddeclaration"}, {"full_name": "Set.sep_mem_eq", "code": "@[simp]\ntheorem sep_mem_eq : { x \u2208 s | x \u2208 t } = s \u2229 t", "start": [1427, 1], "end": [1429, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_sep_iff", "code": "@[simp]\ntheorem mem_sep_iff : x \u2208 { x \u2208 s | p x } \u2194 x \u2208 s \u2227 p x", "start": [1432, 1], "end": [1434, 10], "kind": "commanddeclaration"}, {"full_name": "Set.sep_ext_iff", "code": "theorem sep_ext_iff : { x \u2208 s | p x } = { x \u2208 s | q x } \u2194 \u2200 x \u2208 s, p x \u2194 q x", "start": [1437, 1], "end": [1438, 54], "kind": "commanddeclaration"}, {"full_name": "Set.sep_eq_of_subset", "code": "theorem sep_eq_of_subset (h : s \u2286 t) : { x \u2208 t | x \u2208 s } = s", "start": [1441, 1], "end": [1442, 34], "kind": "commanddeclaration"}, {"full_name": "Set.sep_subset", "code": "@[simp]\ntheorem sep_subset (s : Set \u03b1) (p : \u03b1 \u2192 Prop) : { x \u2208 s | p x } \u2286 s", "start": [1445, 1], "end": [1446, 89], "kind": "commanddeclaration"}, {"full_name": "Set.sep_eq_self_iff_mem_true", "code": "@[simp]\ntheorem sep_eq_self_iff_mem_true : { x \u2208 s | p x } = s \u2194 \u2200 x \u2208 s, p x", "start": [1449, 1], "end": [1451, 55], "kind": "commanddeclaration"}, {"full_name": "Set.sep_eq_empty_iff_mem_false", "code": "@[simp]\ntheorem sep_eq_empty_iff_mem_false : { x \u2208 s | p x } = \u2205 \u2194 \u2200 x \u2208 s, \u00acp x", "start": [1454, 1], "end": [1456, 78], "kind": "commanddeclaration"}, {"full_name": "Set.sep_true", "code": "theorem sep_true : { x \u2208 s | True } = s", "start": [1460, 1], "end": [1461, 15], "kind": "commanddeclaration"}, {"full_name": "Set.sep_false", "code": "theorem sep_false : { x \u2208 s | False } = \u2205", "start": [1465, 1], "end": [1466, 16], "kind": "commanddeclaration"}, {"full_name": "Set.sep_empty", "code": "theorem sep_empty (p : \u03b1 \u2192 Prop) : { x \u2208 (\u2205 : Set \u03b1) | p x } = \u2205", "start": [1470, 1], "end": [1471, 16], "kind": "commanddeclaration"}, {"full_name": "Set.sep_univ", "code": "theorem sep_univ : { x \u2208 (univ : Set \u03b1) | p x } = { x | p x }", "start": [1475, 1], "end": [1476, 15], "kind": "commanddeclaration"}, {"full_name": "Set.sep_union", "code": "@[simp]\ntheorem sep_union : { x | (x \u2208 s \u2228 x \u2208 t) \u2227 p x } = { x \u2208 s | p x } \u222a { x \u2208 t | p x }", "start": [1479, 1], "end": [1481, 28], "kind": "commanddeclaration"}, {"full_name": "Set.sep_inter", "code": "@[simp]\ntheorem sep_inter : { x | (x \u2208 s \u2227 x \u2208 t) \u2227 p x } = { x \u2208 s | p x } \u2229 { x \u2208 t | p x }", "start": [1484, 1], "end": [1486, 34], "kind": "commanddeclaration"}, {"full_name": "Set.sep_and", "code": "@[simp]\ntheorem sep_and : { x \u2208 s | p x \u2227 q x } = { x \u2208 s | p x } \u2229 { x \u2208 s | q x }", "start": [1489, 1], "end": [1491, 33], "kind": "commanddeclaration"}, {"full_name": "Set.sep_or", "code": "@[simp]\ntheorem sep_or : { x \u2208 s | p x \u2228 q x } = { x \u2208 s | p x } \u222a { x \u2208 s | q x }", "start": [1494, 1], "end": [1496, 27], "kind": "commanddeclaration"}, {"full_name": "Set.sep_setOf", "code": "@[simp]\ntheorem sep_setOf : { x \u2208 { y | p y } | q x } = { x | p x \u2227 q x }", "start": [1499, 1], "end": [1501, 6], "kind": "commanddeclaration"}, {"full_name": "Set.subset_singleton_iff", "code": "@[simp]\ntheorem subset_singleton_iff {\u03b1 : Type*} {s : Set \u03b1} {x : \u03b1} : s \u2286 {x} \u2194 \u2200 y \u2208 s, y = x", "start": [1506, 1], "end": [1508, 10], "kind": "commanddeclaration"}, {"full_name": "Set.subset_singleton_iff_eq", "code": "theorem subset_singleton_iff_eq {s : Set \u03b1} {x : \u03b1} : s \u2286 {x} \u2194 s = \u2205 \u2228 s = {x}", "start": [1511, 1], "end": [1514, 65], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.subset_singleton_iff", "code": "theorem Nonempty.subset_singleton_iff (h : s.Nonempty) : s \u2286 {a} \u2194 s = {a}", "start": [1517, 1], "end": [1518, 59], "kind": "commanddeclaration"}, {"full_name": "Set.ssubset_singleton_iff", "code": "theorem ssubset_singleton_iff {s : Set \u03b1} {x : \u03b1} : s \u2282 {x} \u2194 s = \u2205", "start": [1521, 1], "end": [1524, 49], "kind": "commanddeclaration"}, {"full_name": "Set.eq_empty_of_ssubset_singleton", "code": "theorem eq_empty_of_ssubset_singleton {s : Set \u03b1} {x : \u03b1} (hs : s \u2282 {x}) : s = \u2205", "start": [1527, 1], "end": [1528, 29], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iff", "code": "protected theorem disjoint_iff : Disjoint s t \u2194 s \u2229 t \u2286 \u2205", "start": [1534, 1], "end": [1535, 22], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_iff_inter_eq_empty", "code": "theorem disjoint_iff_inter_eq_empty : Disjoint s t \u2194 s \u2229 t = \u2205", "start": [1538, 1], "end": [1539, 15], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inter_eq", "code": "theorem _root_.Disjoint.inter_eq : Disjoint s t \u2192 s \u2229 t = \u2205", "start": [1542, 1], "end": [1543, 18], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_left", "code": "theorem disjoint_left : Disjoint s t \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 a \u2209 t", "start": [1546, 1], "end": [1547, 62], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_right", "code": "theorem disjoint_right : Disjoint s t \u2194 \u2200 \u2983a\u2984, a \u2208 t \u2192 a \u2209 s", "start": [1550, 1], "end": [1550, 101], "kind": "commanddeclaration"}, {"full_name": "Set.not_disjoint_iff", "code": "lemma not_disjoint_iff : \u00acDisjoint s t \u2194 \u2203 x, x \u2208 s \u2227 x \u2208 t :=\n  Set.disjoint_iff.not.trans $ not_forall.trans $ exists_congr fun _ \u21a6 not_not", "start": [1553, 1], "end": [1554, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Set.not_disjoint_iff_nonempty_inter", "code": "lemma not_disjoint_iff_nonempty_inter : \u00ac Disjoint s t \u2194 (s \u2229 t).Nonempty := not_disjoint_iff", "start": [1557, 1], "end": [1557, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Nonempty.not_disjoint", "code": "alias \u27e8_, Nonempty.not_disjoint\u27e9 := not_disjoint_iff_nonempty_inter", "start": [1560, 1], "end": [1560, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.disjoint_or_nonempty_inter", "code": "lemma disjoint_or_nonempty_inter (s t : Set \u03b1) : Disjoint s t \u2228 (s \u2229 t).Nonempty :=\n  (em _).imp_right not_disjoint_iff_nonempty_inter.1", "start": [1563, 1], "end": [1564, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_iff_forall_ne", "code": "lemma disjoint_iff_forall_ne : Disjoint s t \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 t \u2192 a \u2260 b := by\n  simp only [Ne.def, disjoint_left, @imp_not_comm _ (_ = _), forall_eq']", "start": [1567, 1], "end": [1568, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Disjoint.ne_of_mem", "code": "alias \u27e8_root_.Disjoint.ne_of_mem, _\u27e9 := disjoint_iff_forall_ne", "start": [1571, 1], "end": [1571, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.disjoint_of_subset_left", "code": "lemma disjoint_of_subset_left (h : s \u2286 u) (d : Disjoint u t) : Disjoint s t := d.mono_left h", "start": [1574, 1], "end": [1574, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_of_subset_right", "code": "lemma disjoint_of_subset_right (h : t \u2286 u) (d : Disjoint s u) : Disjoint s t := d.mono_right h", "start": [1576, 1], "end": [1576, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_of_subset", "code": "lemma disjoint_of_subset (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) (h : Disjoint s\u2082 t\u2082) : Disjoint s\u2081 t\u2081 :=\n  h.mono hs ht", "start": [1579, 1], "end": [1580, 15], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_union_left", "code": "@[simp]\nlemma disjoint_union_left : Disjoint (s \u222a t) u \u2194 Disjoint s u \u2227 Disjoint t u := disjoint_sup_left", "start": [1583, 1], "end": [1584, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_union_right", "code": "@[simp]\nlemma disjoint_union_right : Disjoint s (t \u222a u) \u2194 Disjoint s t \u2227 Disjoint s u := disjoint_sup_right", "start": [1587, 1], "end": [1588, 100], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_empty", "code": "@[simp] lemma disjoint_empty (s : Set \u03b1) : Disjoint s \u2205 := disjoint_bot_right", "start": [1591, 1], "end": [1591, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Set.empty_disjoint", "code": "@[simp] lemma empty_disjoint (s : Set \u03b1) : Disjoint \u2205 s := disjoint_bot_left", "start": [1593, 1], "end": [1593, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Set.univ_disjoint", "code": "@[simp] lemma univ_disjoint : Disjoint univ s \u2194 s = \u2205 := top_disjoint", "start": [1596, 1], "end": [1596, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_univ", "code": "@[simp] lemma disjoint_univ : Disjoint s univ \u2194 s = \u2205 := disjoint_top", "start": [1598, 1], "end": [1598, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_sdiff_left", "code": "lemma disjoint_sdiff_left : Disjoint (t \\ s) s := disjoint_sdiff_self_left", "start": [1601, 1], "end": [1601, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_sdiff_right", "code": "lemma disjoint_sdiff_right : Disjoint s (t \\ s) := disjoint_sdiff_self_right", "start": [1604, 1], "end": [1604, 77], "kind": "mathlibtacticlemma"}, {"full_name": "Set.diff_union_diff_cancel", "code": "theorem diff_union_diff_cancel (hts : t \u2286 s) (hut : u \u2286 t) : s \\ t \u222a t \\ u = s \\ u", "start": [1607, 1], "end": [1608, 33], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff_eq_sdiff_union", "code": "theorem diff_diff_eq_sdiff_union (h : u \u2286 s) : s \\ (t \\ u) = s \\ t \u222a u", "start": [1611, 1], "end": [1611, 101], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_singleton_left", "code": "@[simp default+1]\nlemma disjoint_singleton_left : Disjoint {a} s \u2194 a \u2209 s := by simp [Set.disjoint_iff, subset_def]", "start": [1614, 1], "end": [1615, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_singleton_right", "code": "@[simp]\nlemma disjoint_singleton_right : Disjoint s {a} \u2194 a \u2209 s :=\n  disjoint_comm.trans disjoint_singleton_left", "start": [1618, 1], "end": [1620, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Set.disjoint_singleton", "code": "lemma disjoint_singleton : Disjoint ({a} : Set \u03b1) {b} \u2194 a \u2260 b :=\n  by simp", "start": [1623, 1], "end": [1624, 10], "kind": "mathlibtacticlemma"}, {"full_name": "Set.subset_diff", "code": "lemma subset_diff : s \u2286 t \\ u \u2194 s \u2286 t \u2227 Disjoint s u := le_iff_subset.symm.trans le_sdiff", "start": [1627, 1], "end": [1627, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Set.inter_diff_distrib_left", "code": "theorem inter_diff_distrib_left (s t u : Set \u03b1) : s \u2229 (t \\ u) = (s \u2229 t) \\ (s \u2229 u)", "start": [1630, 1], "end": [1631, 31], "kind": "commanddeclaration"}, {"full_name": "Set.inter_diff_distrib_right", "code": "theorem inter_diff_distrib_right (s t u : Set \u03b1) : s \\ t \u2229 u = (s \u2229 u) \\ (t \u2229 u)", "start": [1634, 1], "end": [1635, 32], "kind": "commanddeclaration"}, {"full_name": "Set.compl_def", "code": "theorem compl_def (s : Set \u03b1) : s\u1d9c = { x | x \u2209 s }", "start": [1641, 1], "end": [1642, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_compl", "code": "theorem mem_compl {s : Set \u03b1} {x : \u03b1} (h : x \u2209 s) : x \u2208 s\u1d9c", "start": [1645, 1], "end": [1646, 4], "kind": "commanddeclaration"}, {"full_name": "Set.compl_setOf", "code": "theorem compl_setOf {\u03b1} (p : \u03b1 \u2192 Prop) : { a | p a }\u1d9c = { a | \u00acp a }", "start": [1649, 1], "end": [1650, 6], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_of_mem_compl", "code": "theorem not_mem_of_mem_compl {s : Set \u03b1} {x : \u03b1} (h : x \u2208 s\u1d9c) : x \u2209 s", "start": [1653, 1], "end": [1654, 4], "kind": "commanddeclaration"}, {"full_name": "Set.mem_compl_iff", "code": "@[simp]\ntheorem mem_compl_iff (s : Set \u03b1) (x : \u03b1) : x \u2208 s\u1d9c \u2194 x \u2209 s", "start": [1657, 1], "end": [1659, 10], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_compl_iff", "code": "theorem not_mem_compl_iff {x : \u03b1} : x \u2209 s\u1d9c \u2194 x \u2208 s", "start": [1662, 1], "end": [1663, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inter_compl_self", "code": "@[simp]\ntheorem inter_compl_self (s : Set \u03b1) : s \u2229 s\u1d9c = \u2205", "start": [1666, 1], "end": [1668, 19], "kind": "commanddeclaration"}, {"full_name": "Set.compl_inter_self", "code": "@[simp]\ntheorem compl_inter_self (s : Set \u03b1) : s\u1d9c \u2229 s = \u2205", "start": [1671, 1], "end": [1673, 19], "kind": "commanddeclaration"}, {"full_name": "Set.compl_empty", "code": "@[simp]\ntheorem compl_empty : (\u2205 : Set \u03b1)\u1d9c = univ", "start": [1676, 1], "end": [1678, 12], "kind": "commanddeclaration"}, {"full_name": "Set.compl_union", "code": "@[simp]\ntheorem compl_union (s t : Set \u03b1) : (s \u222a t)\u1d9c = s\u1d9c \u2229 t\u1d9c", "start": [1681, 1], "end": [1683, 12], "kind": "commanddeclaration"}, {"full_name": "Set.compl_inter", "code": "theorem compl_inter (s t : Set \u03b1) : (s \u2229 t)\u1d9c = s\u1d9c \u222a t\u1d9c", "start": [1686, 1], "end": [1687, 12], "kind": "commanddeclaration"}, {"full_name": "Set.compl_univ", "code": "@[simp]\ntheorem compl_univ : (univ : Set \u03b1)\u1d9c = \u2205", "start": [1690, 1], "end": [1692, 12], "kind": "commanddeclaration"}, {"full_name": "Set.compl_empty_iff", "code": "@[simp]\ntheorem compl_empty_iff {s : Set \u03b1} : s\u1d9c = \u2205 \u2194 s = univ", "start": [1695, 1], "end": [1697, 15], "kind": "commanddeclaration"}, {"full_name": "Set.compl_univ_iff", "code": "@[simp]\ntheorem compl_univ_iff {s : Set \u03b1} : s\u1d9c = univ \u2194 s = \u2205", "start": [1700, 1], "end": [1702, 15], "kind": "commanddeclaration"}, {"full_name": "Set.compl_ne_univ", "code": "theorem compl_ne_univ : s\u1d9c \u2260 univ \u2194 s.Nonempty", "start": [1705, 1], "end": [1706, 54], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_compl", "code": "theorem nonempty_compl : s\u1d9c.Nonempty \u2194 s \u2260 univ", "start": [1709, 1], "end": [1710, 38], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_compl_of_nontrivial", "code": "@[simp] lemma nonempty_compl_of_nontrivial [Nontrivial \u03b1] (x : \u03b1) : Set.Nonempty {x}\u1d9c := by\n  obtain \u27e8y, hy\u27e9 := exists_ne x\n  exact \u27e8y, by simp [hy]\u27e9", "start": [1713, 1], "end": [1715, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mem_compl_singleton_iff", "code": "theorem mem_compl_singleton_iff {a x : \u03b1} : x \u2208 ({a} : Set \u03b1)\u1d9c \u2194 x \u2260 a", "start": [1717, 1], "end": [1718, 10], "kind": "commanddeclaration"}, {"full_name": "Set.compl_singleton_eq", "code": "theorem compl_singleton_eq (a : \u03b1) : ({a} : Set \u03b1)\u1d9c = { x | x \u2260 a }", "start": [1721, 1], "end": [1722, 6], "kind": "commanddeclaration"}, {"full_name": "Set.compl_ne_eq_singleton", "code": "@[simp]\ntheorem compl_ne_eq_singleton (a : \u03b1) : ({ x | x \u2260 a } : Set \u03b1)\u1d9c = {a}", "start": [1725, 1], "end": [1727, 16], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_compl_compl_inter_compl", "code": "theorem union_eq_compl_compl_inter_compl (s t : Set \u03b1) : s \u222a t = (s\u1d9c \u2229 t\u1d9c)\u1d9c", "start": [1730, 1], "end": [1731, 34], "kind": "commanddeclaration"}, {"full_name": "Set.inter_eq_compl_compl_union_compl", "code": "theorem inter_eq_compl_compl_union_compl (s t : Set \u03b1) : s \u2229 t = (s\u1d9c \u222a t\u1d9c)\u1d9c", "start": [1734, 1], "end": [1735, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_compl_self", "code": "@[simp]\ntheorem union_compl_self (s : Set \u03b1) : s \u222a s\u1d9c = univ", "start": [1738, 1], "end": [1740, 37], "kind": "commanddeclaration"}, {"full_name": "Set.compl_union_self", "code": "@[simp]\ntheorem compl_union_self (s : Set \u03b1) : s\u1d9c \u222a s = univ", "start": [1743, 1], "end": [1744, 93], "kind": "commanddeclaration"}, {"full_name": "Set.compl_subset_comm", "code": "theorem compl_subset_comm : s\u1d9c \u2286 t \u2194 t\u1d9c \u2286 s", "start": [1747, 1], "end": [1748, 33], "kind": "commanddeclaration"}, {"full_name": "Set.subset_compl_comm", "code": "theorem subset_compl_comm : s \u2286 t\u1d9c \u2194 t \u2286 s\u1d9c", "start": [1751, 1], "end": [1752, 33], "kind": "commanddeclaration"}, {"full_name": "Set.compl_subset_compl", "code": "@[simp]\ntheorem compl_subset_compl : s\u1d9c \u2286 t\u1d9c \u2194 t \u2286 s", "start": [1755, 1], "end": [1757, 39], "kind": "commanddeclaration"}, {"full_name": "Set.compl_subset_compl_of_subset", "code": "@[gcongr] theorem compl_subset_compl_of_subset (h : t \u2286 s) : s\u1d9c \u2286 t\u1d9c", "start": [1760, 1], "end": [1760, 95], "kind": "commanddeclaration"}, {"full_name": "Set.subset_compl_iff_disjoint_left", "code": "theorem subset_compl_iff_disjoint_left : s \u2286 t\u1d9c \u2194 Disjoint t s", "start": [1762, 1], "end": [1763, 44], "kind": "commanddeclaration"}, {"full_name": "Set.subset_compl_iff_disjoint_right", "code": "theorem subset_compl_iff_disjoint_right : s \u2286 t\u1d9c \u2194 Disjoint s t", "start": [1766, 1], "end": [1767, 45], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_compl_left_iff_subset", "code": "theorem disjoint_compl_left_iff_subset : Disjoint s\u1d9c t \u2194 t \u2286 s", "start": [1770, 1], "end": [1771, 26], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_compl_right_iff_subset", "code": "theorem disjoint_compl_right_iff_subset : Disjoint s t\u1d9c \u2194 s \u2286 t", "start": [1774, 1], "end": [1775, 27], "kind": "commanddeclaration"}, {"full_name": "Disjoint.subset_compl_right", "code": "alias \u27e8_, _root_.Disjoint.subset_compl_right\u27e9 := subset_compl_iff_disjoint_right", "start": [1778, 1], "end": [1778, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Disjoint.subset_compl_left", "code": "alias \u27e8_, _root_.Disjoint.subset_compl_left\u27e9 := subset_compl_iff_disjoint_left", "start": [1781, 1], "end": [1781, 79], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasSubset.Subset.disjoint_compl_left", "code": "alias \u27e8_, _root_.HasSubset.Subset.disjoint_compl_left\u27e9 := disjoint_compl_left_iff_subset", "start": [1784, 1], "end": [1784, 89], "kind": "stdtacticaliasaliaslr"}, {"full_name": "HasSubset.Subset.disjoint_compl_right", "code": "alias \u27e8_, _root_.HasSubset.Subset.disjoint_compl_right\u27e9 := disjoint_compl_right_iff_subset", "start": [1787, 1], "end": [1787, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.subset_union_compl_iff_inter_subset", "code": "theorem subset_union_compl_iff_inter_subset {s t u : Set \u03b1} : s \u2286 t \u222a u\u1d9c \u2194 s \u2229 u \u2286 t", "start": [1790, 1], "end": [1791, 54], "kind": "commanddeclaration"}, {"full_name": "Set.compl_subset_iff_union", "code": "theorem compl_subset_iff_union {s t : Set \u03b1} : s\u1d9c \u2286 t \u2194 s \u222a t = univ", "start": [1794, 1], "end": [1795, 85], "kind": "commanddeclaration"}, {"full_name": "Set.subset_compl_singleton_iff", "code": "@[simp]\ntheorem subset_compl_singleton_iff {a : \u03b1} {s : Set \u03b1} : s \u2286 {a}\u1d9c \u2194 a \u2209 s", "start": [1798, 1], "end": [1800, 47], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset", "code": "theorem inter_subset (a b c : Set \u03b1) : a \u2229 b \u2286 c \u2194 a \u2286 b\u1d9c \u222a c", "start": [1803, 1], "end": [1804, 82], "kind": "commanddeclaration"}, {"full_name": "Set.inter_compl_nonempty_iff", "code": "theorem inter_compl_nonempty_iff {s t : Set \u03b1} : (s \u2229 t\u1d9c).Nonempty \u2194 \u00acs \u2286 t", "start": [1807, 1], "end": [1808, 71], "kind": "commanddeclaration"}, {"full_name": "Set.diff_eq", "code": "theorem diff_eq (s t : Set \u03b1) : s \\ t = s \u2229 t\u1d9c", "start": [1814, 1], "end": [1815, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diff", "code": "@[simp]\ntheorem mem_diff {s t : Set \u03b1} (x : \u03b1) : x \u2208 s \\ t \u2194 x \u2208 s \u2227 x \u2209 t", "start": [1818, 1], "end": [1820, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diff_of_mem", "code": "theorem mem_diff_of_mem {s t : Set \u03b1} {x : \u03b1} (h1 : x \u2208 s) (h2 : x \u2209 t) : x \u2208 s \\ t", "start": [1823, 1], "end": [1824, 11], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_diff_of_mem", "code": "theorem not_mem_diff_of_mem {s t : Set \u03b1} {x : \u03b1} (hx : x \u2208 t) : x \u2209 s \\ t", "start": [1827, 1], "end": [1827, 94], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mem_diff", "code": "theorem mem_of_mem_diff {s t : Set \u03b1} {x : \u03b1} (h : x \u2208 s \\ t) : x \u2208 s", "start": [1830, 1], "end": [1831, 9], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_of_mem_diff", "code": "theorem not_mem_of_mem_diff {s t : Set \u03b1} {x : \u03b1} (h : x \u2208 s \\ t) : x \u2209 t", "start": [1834, 1], "end": [1835, 10], "kind": "commanddeclaration"}, {"full_name": "Set.diff_eq_compl_inter", "code": "theorem diff_eq_compl_inter {s t : Set \u03b1} : s \\ t = t\u1d9c \u2229 s", "start": [1838, 1], "end": [1838, 90], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_diff", "code": "theorem nonempty_diff {s t : Set \u03b1} : (s \\ t).Nonempty \u2194 \u00acs \u2286 t", "start": [1841, 1], "end": [1842, 27], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset", "code": "theorem diff_subset (s t : Set \u03b1) : s \\ t \u2286 s", "start": [1845, 1], "end": [1846, 31], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_cancel'", "code": "theorem union_diff_cancel' {s t u : Set \u03b1} (h\u2081 : s \u2286 t) (h\u2082 : t \u2286 u) : t \u222a u \\ s = u", "start": [1849, 1], "end": [1850, 26], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_cancel", "code": "theorem union_diff_cancel {s t : Set \u03b1} (h : s \u2286 t) : s \u222a t \\ s = t", "start": [1853, 1], "end": [1854, 27], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_cancel_left", "code": "theorem union_diff_cancel_left {s t : Set \u03b1} (h : s \u2229 t \u2286 \u2205) : (s \u222a t) \\ s = t", "start": [1857, 1], "end": [1858, 60], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_cancel_right", "code": "theorem union_diff_cancel_right {s t : Set \u03b1} (h : s \u2229 t \u2286 \u2205) : (s \u222a t) \\ t = s", "start": [1861, 1], "end": [1862, 61], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_left", "code": "@[simp]\ntheorem union_diff_left {s t : Set \u03b1} : (s \u222a t) \\ s = t \\ s", "start": [1865, 1], "end": [1867, 22], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_right", "code": "@[simp]\ntheorem union_diff_right {s t : Set \u03b1} : (s \u222a t) \\ t = s \\ t", "start": [1870, 1], "end": [1872, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_distrib", "code": "theorem union_diff_distrib {s t u : Set \u03b1} : (s \u222a t) \\ u = s \\ u \u222a t \\ u", "start": [1875, 1], "end": [1876, 12], "kind": "commanddeclaration"}, {"full_name": "Set.inter_diff_assoc", "code": "theorem inter_diff_assoc (a b c : Set \u03b1) : (a \u2229 b) \\ c = a \u2229 (b \\ c)", "start": [1879, 1], "end": [1880, 18], "kind": "commanddeclaration"}, {"full_name": "Set.inter_diff_self", "code": "@[simp]\ntheorem inter_diff_self (a b : Set \u03b1) : a \u2229 (b \\ a) = \u2205", "start": [1883, 1], "end": [1885, 23], "kind": "commanddeclaration"}, {"full_name": "Set.inter_union_diff", "code": "@[simp]\ntheorem inter_union_diff (s t : Set \u03b1) : s \u2229 t \u222a s \\ t = s", "start": [1888, 1], "end": [1890, 20], "kind": "commanddeclaration"}, {"full_name": "Set.diff_union_inter", "code": "@[simp]\ntheorem diff_union_inter (s t : Set \u03b1) : s \\ t \u222a s \u2229 t = s", "start": [1893, 1], "end": [1896, 26], "kind": "commanddeclaration"}, {"full_name": "Set.inter_union_compl", "code": "@[simp]\ntheorem inter_union_compl (s t : Set \u03b1) : s \u2229 t \u222a s \u2229 t\u1d9c = s", "start": [1899, 1], "end": [1901, 23], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset_diff", "code": "theorem diff_subset_diff {s\u2081 s\u2082 t\u2081 t\u2082 : Set \u03b1} : s\u2081 \u2286 s\u2082 \u2192 t\u2082 \u2286 t\u2081 \u2192 s\u2081 \\ t\u2081 \u2286 s\u2082 \\ t\u2082", "start": [1904, 1], "end": [1905, 65], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset_diff_left", "code": "theorem diff_subset_diff_left {s\u2081 s\u2082 t : Set \u03b1} (h : s\u2081 \u2286 s\u2082) : s\u2081 \\ t \u2286 s\u2082 \\ t", "start": [1908, 1], "end": [1909, 33], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset_diff_right", "code": "theorem diff_subset_diff_right {s t u : Set \u03b1} (h : t \u2286 u) : s \\ u \u2286 s \\ t", "start": [1912, 1], "end": [1913, 30], "kind": "commanddeclaration"}, {"full_name": "Set.compl_eq_univ_diff", "code": "theorem compl_eq_univ_diff (s : Set \u03b1) : s\u1d9c = univ \\ s", "start": [1916, 1], "end": [1917, 17], "kind": "commanddeclaration"}, {"full_name": "Set.empty_diff", "code": "@[simp]\ntheorem empty_diff (s : Set \u03b1) : (\u2205 \\ s : Set \u03b1) = \u2205", "start": [1920, 1], "end": [1922, 12], "kind": "commanddeclaration"}, {"full_name": "Set.diff_eq_empty", "code": "theorem diff_eq_empty {s t : Set \u03b1} : s \\ t = \u2205 \u2194 s \u2286 t", "start": [1925, 1], "end": [1926, 19], "kind": "commanddeclaration"}, {"full_name": "Set.diff_empty", "code": "@[simp]\ntheorem diff_empty {s : Set \u03b1} : s \\ \u2205 = s", "start": [1929, 1], "end": [1931, 12], "kind": "commanddeclaration"}, {"full_name": "Set.diff_univ", "code": "@[simp]\ntheorem diff_univ (s : Set \u03b1) : s \\ univ = \u2205", "start": [1934, 1], "end": [1936, 34], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff", "code": "theorem diff_diff {u : Set \u03b1} : (s \\ t) \\ u = s \\ (t \u222a u)", "start": [1939, 1], "end": [1940, 19], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff_comm", "code": "theorem diff_diff_comm {s t u : Set \u03b1} : (s \\ t) \\ u = (s \\ u) \\ t", "start": [1944, 1], "end": [1945, 19], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset_iff", "code": "theorem diff_subset_iff {s t u : Set \u03b1} : s \\ t \u2286 u \u2194 s \u2286 t \u222a u", "start": [1948, 1], "end": [1949, 47], "kind": "commanddeclaration"}, {"full_name": "Set.subset_diff_union", "code": "theorem subset_diff_union (s t : Set \u03b1) : s \u2286 s \\ t \u222a t", "start": [1952, 1], "end": [1953, 39], "kind": "commanddeclaration"}, {"full_name": "Set.diff_union_of_subset", "code": "theorem diff_union_of_subset {s t : Set \u03b1} (h : t \u2286 s) : s \\ t \u222a t = s", "start": [1956, 1], "end": [1957, 77], "kind": "commanddeclaration"}, {"full_name": "Set.diff_singleton_subset_iff", "code": "@[simp]\ntheorem diff_singleton_subset_iff {x : \u03b1} {s t : Set \u03b1} : s \\ {x} \u2286 t \u2194 s \u2286 insert x t", "start": [1960, 1], "end": [1963, 24], "kind": "commanddeclaration"}, {"full_name": "Set.subset_diff_singleton", "code": "theorem subset_diff_singleton {x : \u03b1} {s t : Set \u03b1} (h : s \u2286 t) (hx : x \u2209 s) : s \u2286 t \\ {x}", "start": [1966, 1], "end": [1967, 69], "kind": "commanddeclaration"}, {"full_name": "Set.subset_insert_diff_singleton", "code": "theorem subset_insert_diff_singleton (x : \u03b1) (s : Set \u03b1) : s \u2286 insert x (s \\ {x})", "start": [1970, 1], "end": [1971, 35], "kind": "commanddeclaration"}, {"full_name": "Set.diff_subset_comm", "code": "theorem diff_subset_comm {s t u : Set \u03b1} : s \\ t \u2286 u \u2194 s \\ u \u2286 t", "start": [1974, 1], "end": [1975, 48], "kind": "commanddeclaration"}, {"full_name": "Set.diff_inter", "code": "theorem diff_inter {s t u : Set \u03b1} : s \\ (t \u2229 u) = s \\ t \u222a s \\ u", "start": [1978, 1], "end": [1979, 12], "kind": "commanddeclaration"}, {"full_name": "Set.diff_inter_diff", "code": "theorem diff_inter_diff {s t u : Set \u03b1} : s \\ t \u2229 (s \\ u) = s \\ (t \u222a u)", "start": [1982, 1], "end": [1983, 17], "kind": "commanddeclaration"}, {"full_name": "Set.diff_compl", "code": "theorem diff_compl : s \\ t\u1d9c = s \u2229 t", "start": [1986, 1], "end": [1987, 14], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff_right", "code": "theorem diff_diff_right {s t u : Set \u03b1} : s \\ (t \\ u) = s \\ t \u222a s \u2229 u", "start": [1990, 1], "end": [1991, 21], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_of_mem", "code": "@[simp]\ntheorem insert_diff_of_mem (s) (h : a \u2208 t) : insert a s \\ t = s \\ t", "start": [1994, 1], "end": [1997, 70], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_of_not_mem", "code": "theorem insert_diff_of_not_mem (s) (h : a \u2209 t) : insert a s \\ t = insert a (s \\ t)", "start": [2000, 1], "end": [2009, 19], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_self_of_not_mem", "code": "theorem insert_diff_self_of_not_mem {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : insert a s \\ {a} = s", "start": [2012, 1], "end": [2014, 88], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_eq_singleton", "code": "@[simp]\ntheorem insert_diff_eq_singleton {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : insert a s \\ s = {a}", "start": [2017, 1], "end": [2023, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inter_insert_of_mem", "code": "theorem inter_insert_of_mem (h : a \u2208 s) : s \u2229 insert a t = insert a (s \u2229 t)", "start": [2026, 1], "end": [2027, 48], "kind": "commanddeclaration"}, {"full_name": "Set.insert_inter_of_mem", "code": "theorem insert_inter_of_mem (h : a \u2208 t) : insert a s \u2229 t = insert a (s \u2229 t)", "start": [2030, 1], "end": [2031, 48], "kind": "commanddeclaration"}, {"full_name": "Set.inter_insert_of_not_mem", "code": "theorem inter_insert_of_not_mem (h : a \u2209 s) : s \u2229 insert a t = s \u2229 t", "start": [2034, 1], "end": [2035, 83], "kind": "commanddeclaration"}, {"full_name": "Set.insert_inter_of_not_mem", "code": "theorem insert_inter_of_not_mem (h : a \u2209 t) : insert a s \u2229 t = s \u2229 t", "start": [2038, 1], "end": [2039, 82], "kind": "commanddeclaration"}, {"full_name": "Set.union_diff_self", "code": "@[simp]\ntheorem union_diff_self {s t : Set \u03b1} : s \u222a t \\ s = s \u222a t", "start": [2042, 1], "end": [2044, 21], "kind": "commanddeclaration"}, {"full_name": "Set.diff_union_self", "code": "@[simp]\ntheorem diff_union_self {s t : Set \u03b1} : s \\ t \u222a t = s \u222a t", "start": [2047, 1], "end": [2049, 21], "kind": "commanddeclaration"}, {"full_name": "Set.diff_inter_self", "code": "@[simp]\ntheorem diff_inter_self {a b : Set \u03b1} : b \\ a \u2229 a = \u2205", "start": [2052, 1], "end": [2054, 22], "kind": "commanddeclaration"}, {"full_name": "Set.diff_inter_self_eq_diff", "code": "@[simp]\ntheorem diff_inter_self_eq_diff {s t : Set \u03b1} : s \\ (t \u2229 s) = s \\ t", "start": [2057, 1], "end": [2059, 27], "kind": "commanddeclaration"}, {"full_name": "Set.diff_self_inter", "code": "@[simp]\ntheorem diff_self_inter {s t : Set \u03b1} : s \\ (s \u2229 t) = s \\ t", "start": [2062, 1], "end": [2064, 26], "kind": "commanddeclaration"}, {"full_name": "Set.diff_singleton_eq_self", "code": "@[simp]\ntheorem diff_singleton_eq_self {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : s \\ {a} = s", "start": [2067, 1], "end": [2069, 45], "kind": "commanddeclaration"}, {"full_name": "Set.diff_singleton_sSubset", "code": "@[simp]\ntheorem diff_singleton_sSubset {s : Set \u03b1} {a : \u03b1} : s \\ {a} \u2282 s \u2194 a \u2208 s", "start": [2072, 1], "end": [2074, 65], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_singleton", "code": "@[simp]\ntheorem insert_diff_singleton {a : \u03b1} {s : Set \u03b1} : insert a (s \\ {a}) = insert a s", "start": [2077, 1], "end": [2079, 72], "kind": "commanddeclaration"}, {"full_name": "Set.insert_diff_singleton_comm", "code": "theorem insert_diff_singleton_comm (hab : a \u2260 b) (s : Set \u03b1) :\n    insert a (s \\ {b}) = insert a s \\ {b}", "start": [2082, 1], "end": [2085, 63], "kind": "commanddeclaration"}, {"full_name": "Set.diff_self", "code": "theorem diff_self {s : Set \u03b1} : s \\ s = \u2205", "start": [2089, 1], "end": [2090, 13], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff_right_self", "code": "theorem diff_diff_right_self (s t : Set \u03b1) : s \\ (s \\ t) = s \u2229 t", "start": [2093, 1], "end": [2094, 25], "kind": "commanddeclaration"}, {"full_name": "Set.diff_diff_cancel_left", "code": "theorem diff_diff_cancel_left {s t : Set \u03b1} (h : s \u2286 t) : t \\ (t \\ s) = s", "start": [2097, 1], "end": [2098, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diff_singleton", "code": "theorem mem_diff_singleton {x y : \u03b1} {s : Set \u03b1} : x \u2208 s \\ {y} \u2194 x \u2208 s \u2227 x \u2260 y", "start": [2101, 1], "end": [2102, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_diff_singleton_empty", "code": "theorem mem_diff_singleton_empty {t : Set (Set \u03b1)} : s \u2208 t \\ {\u2205} \u2194 s \u2208 t \u2227 s.Nonempty", "start": [2105, 1], "end": [2106, 74], "kind": "commanddeclaration"}, {"full_name": "Set.union_eq_diff_union_diff_union_inter", "code": "theorem union_eq_diff_union_diff_union_inter (s t : Set \u03b1) : s \u222a t = s \\ t \u222a t \\ s \u222a s \u2229 t", "start": [2109, 1], "end": [2110, 33], "kind": "commanddeclaration"}, {"full_name": "Set.mem_symmDiff", "code": "theorem mem_symmDiff : a \u2208 s \u2206 t \u2194 a \u2208 s \u2227 a \u2209 t \u2228 a \u2208 t \u2227 a \u2209 s", "start": [2116, 1], "end": [2117, 10], "kind": "commanddeclaration"}, {"full_name": "Set.symmDiff_def", "code": "protected theorem symmDiff_def (s t : Set \u03b1) : s \u2206 t = s \\ t \u222a t \\ s", "start": [2120, 1], "end": [2121, 6], "kind": "commanddeclaration"}, {"full_name": "Set.symmDiff_subset_union", "code": "theorem symmDiff_subset_union : s \u2206 t \u2286 s \u222a t", "start": [2124, 1], "end": [2125, 33], "kind": "commanddeclaration"}, {"full_name": "Set.symmDiff_eq_empty", "code": "@[simp]\ntheorem symmDiff_eq_empty : s \u2206 t = \u2205 \u2194 s = t", "start": [2128, 1], "end": [2130, 18], "kind": "commanddeclaration"}, {"full_name": "Set.symmDiff_nonempty", "code": "@[simp]\ntheorem symmDiff_nonempty : (s \u2206 t).Nonempty \u2194 s \u2260 t", "start": [2133, 1], "end": [2135, 52], "kind": "commanddeclaration"}, {"full_name": "Set.inter_symmDiff_distrib_left", "code": "theorem inter_symmDiff_distrib_left (s t u : Set \u03b1) : s \u2229 t \u2206 u = (s \u2229 t) \u2206 (s \u2229 u)", "start": [2138, 1], "end": [2139, 34], "kind": "commanddeclaration"}, {"full_name": "Set.inter_symmDiff_distrib_right", "code": "theorem inter_symmDiff_distrib_right (s t u : Set \u03b1) : s \u2206 t \u2229 u = (s \u2229 u) \u2206 (t \u2229 u)", "start": [2142, 1], "end": [2143, 35], "kind": "commanddeclaration"}, {"full_name": "Set.subset_symmDiff_union_symmDiff_left", "code": "theorem subset_symmDiff_union_symmDiff_left (h : Disjoint s t) : u \u2286 s \u2206 u \u222a t \u2206 u", "start": [2146, 1], "end": [2147, 34], "kind": "commanddeclaration"}, {"full_name": "Set.subset_symmDiff_union_symmDiff_right", "code": "theorem subset_symmDiff_union_symmDiff_right (h : Disjoint t u) : s \u2286 s \u2206 t \u222a s \u2206 u", "start": [2150, 1], "end": [2151, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mem_powerset", "code": "theorem mem_powerset {x s : Set \u03b1} (h : x \u2286 s) : x \u2208 \ud835\udcab s", "start": [2158, 1], "end": [2158, 63], "kind": "commanddeclaration"}, {"full_name": "Set.subset_of_mem_powerset", "code": "theorem subset_of_mem_powerset {x s : Set \u03b1} (h : x \u2208 \ud835\udcab s) : x \u2286 s", "start": [2161, 1], "end": [2161, 73], "kind": "commanddeclaration"}, {"full_name": "Set.mem_powerset_iff", "code": "@[simp]\ntheorem mem_powerset_iff (x s : Set \u03b1) : x \u2208 \ud835\udcab s \u2194 x \u2286 s", "start": [2164, 1], "end": [2166, 10], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_inter", "code": "theorem powerset_inter (s t : Set \u03b1) : \ud835\udcab(s \u2229 t) = \ud835\udcab s \u2229 \ud835\udcab t", "start": [2169, 1], "end": [2170, 32], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_mono", "code": "@[simp]\ntheorem powerset_mono : \ud835\udcab s \u2286 \ud835\udcab t \u2194 s \u2286 t", "start": [2173, 1], "end": [2175, 63], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_powerset", "code": "theorem monotone_powerset : Monotone (powerset : Set \u03b1 \u2192 Set (Set \u03b1))", "start": [2178, 1], "end": [2178, 100], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_nonempty", "code": "@[simp]\ntheorem powerset_nonempty : (\ud835\udcab s).Nonempty", "start": [2181, 1], "end": [2183, 35], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_empty", "code": "@[simp]\ntheorem powerset_empty : \ud835\udcab(\u2205 : Set \u03b1) = {\u2205}", "start": [2186, 1], "end": [2188, 32], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_univ", "code": "@[simp]\ntheorem powerset_univ : \ud835\udcab(univ : Set \u03b1) = univ", "start": [2191, 1], "end": [2193, 32], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_singleton", "code": "theorem powerset_singleton (x : \u03b1) : \ud835\udcab({x} : Set \u03b1) = {\u2205, {x}}", "start": [2196, 1], "end": [2199, 84], "kind": "commanddeclaration"}, {"full_name": "Set.mem_dite", "code": "theorem mem_dite (p : Prop) [Decidable p] (s : p \u2192 Set \u03b1) (t : \u00ac p \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then s h else t h) \u2194 (\u2200 h : p, x \u2208 s h) \u2227 \u2200 h : \u00acp, x \u2208 t h", "start": [2207, 1], "end": [2211, 77], "kind": "commanddeclaration"}, {"full_name": "Set.mem_dite_univ_right", "code": "theorem mem_dite_univ_right (p : Prop) [Decidable p] (t : p \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then t h else univ) \u2194 \u2200 h : p, x \u2208 t h", "start": [2214, 1], "end": [2216, 18], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ite_univ_right", "code": "@[simp]\ntheorem mem_ite_univ_right (p : Prop) [Decidable p] (t : Set \u03b1) (x : \u03b1) :\n    x \u2208 ite p t Set.univ \u2194 p \u2192 x \u2208 t", "start": [2219, 1], "end": [2222, 39], "kind": "commanddeclaration"}, {"full_name": "Set.mem_dite_univ_left", "code": "theorem mem_dite_univ_left (p : Prop) [Decidable p] (t : \u00acp \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then univ else t h) \u2194 \u2200 h : \u00acp, x \u2208 t h", "start": [2225, 1], "end": [2227, 18], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ite_univ_left", "code": "@[simp]\ntheorem mem_ite_univ_left (p : Prop) [Decidable p] (t : Set \u03b1) (x : \u03b1) :\n    x \u2208 ite p Set.univ t \u2194 \u00acp \u2192 x \u2208 t", "start": [2230, 1], "end": [2233, 38], "kind": "commanddeclaration"}, {"full_name": "Set.mem_dite_empty_right", "code": "theorem mem_dite_empty_right (p : Prop) [Decidable p] (t : p \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then t h else \u2205) \u2194 \u2203 h : p, x \u2208 t h", "start": [2236, 1], "end": [2239, 69], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ite_empty_right", "code": "@[simp]\ntheorem mem_ite_empty_right (p : Prop) [Decidable p] (t : Set \u03b1) (x : \u03b1) :\n    x \u2208 ite p t \u2205 \u2194 p \u2227 x \u2208 t", "start": [2242, 1], "end": [2245, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mem_dite_empty_left", "code": "theorem mem_dite_empty_left (p : Prop) [Decidable p] (t : \u00acp \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then \u2205 else t h) \u2194 \u2203 h : \u00acp, x \u2208 t h", "start": [2248, 1], "end": [2251, 80], "kind": "commanddeclaration"}, {"full_name": "Set.mem_ite_empty_left", "code": "@[simp]\ntheorem mem_ite_empty_left (p : Prop) [Decidable p] (t : Set \u03b1) (x : \u03b1) :\n    x \u2208 ite p \u2205 t \u2194 \u00acp \u2227 x \u2208 t", "start": [2254, 1], "end": [2257, 57], "kind": "commanddeclaration"}, {"full_name": "Set.ite", "code": "protected def ite (t s s' : Set \u03b1) : Set \u03b1 :=\n  s \u2229 t \u222a s' \\ t", "start": [2263, 1], "end": [2266, 17], "kind": "commanddeclaration"}, {"full_name": "Set.ite_inter_self", "code": "@[simp]\ntheorem ite_inter_self (t s s' : Set \u03b1) : t.ite s s' \u2229 t = s \u2229 t", "start": [2269, 1], "end": [2271, 97], "kind": "commanddeclaration"}, {"full_name": "Set.ite_compl", "code": "@[simp]\ntheorem ite_compl (t s s' : Set \u03b1) : t\u1d9c.ite s s' = t.ite s' s", "start": [2274, 1], "end": [2276, 57], "kind": "commanddeclaration"}, {"full_name": "Set.ite_inter_compl_self", "code": "@[simp]\ntheorem ite_inter_compl_self (t s s' : Set \u03b1) : t.ite s s' \u2229 t\u1d9c = s' \u2229 t\u1d9c", "start": [2279, 1], "end": [2281, 35], "kind": "commanddeclaration"}, {"full_name": "Set.ite_diff_self", "code": "@[simp]\ntheorem ite_diff_self (t s s' : Set \u03b1) : t.ite s s' \\ t = s' \\ t", "start": [2284, 1], "end": [2286, 30], "kind": "commanddeclaration"}, {"full_name": "Set.ite_same", "code": "@[simp]\ntheorem ite_same (t s : Set \u03b1) : t.ite s s = s", "start": [2289, 1], "end": [2291, 23], "kind": "commanddeclaration"}, {"full_name": "Set.ite_left", "code": "@[simp]\ntheorem ite_left (s t : Set \u03b1) : s.ite s t = s \u222a t", "start": [2294, 1], "end": [2295, 72], "kind": "commanddeclaration"}, {"full_name": "Set.ite_right", "code": "@[simp]\ntheorem ite_right (s t : Set \u03b1) : s.ite t s = t \u2229 s", "start": [2298, 1], "end": [2299, 73], "kind": "commanddeclaration"}, {"full_name": "Set.ite_empty", "code": "@[simp]\ntheorem ite_empty (s s' : Set \u03b1) : Set.ite \u2205 s s' = s'", "start": [2302, 1], "end": [2303, 76], "kind": "commanddeclaration"}, {"full_name": "Set.ite_univ", "code": "@[simp]\ntheorem ite_univ (s s' : Set \u03b1) : Set.ite univ s s' = s", "start": [2306, 1], "end": [2307, 77], "kind": "commanddeclaration"}, {"full_name": "Set.ite_empty_left", "code": "@[simp]\ntheorem ite_empty_left (t s : Set \u03b1) : t.ite \u2205 s = s \\ t", "start": [2310, 1], "end": [2311, 78], "kind": "commanddeclaration"}, {"full_name": "Set.ite_empty_right", "code": "@[simp]\ntheorem ite_empty_right (t s : Set \u03b1) : t.ite s \u2205 = s \u2229 t", "start": [2314, 1], "end": [2315, 79], "kind": "commanddeclaration"}, {"full_name": "Set.ite_mono", "code": "theorem ite_mono (t : Set \u03b1) {s\u2081 s\u2081' s\u2082 s\u2082' : Set \u03b1} (h : s\u2081 \u2286 s\u2082) (h' : s\u2081' \u2286 s\u2082') :\n    t.ite s\u2081 s\u2081' \u2286 t.ite s\u2082 s\u2082'", "start": [2318, 1], "end": [2320, 82], "kind": "commanddeclaration"}, {"full_name": "Set.ite_subset_union", "code": "theorem ite_subset_union (t s s' : Set \u03b1) : t.ite s s' \u2286 s \u222a s'", "start": [2323, 1], "end": [2324, 63], "kind": "commanddeclaration"}, {"full_name": "Set.inter_subset_ite", "code": "theorem inter_subset_ite (t s s' : Set \u03b1) : s \u2229 s' \u2286 t.ite s s'", "start": [2327, 1], "end": [2328, 84], "kind": "commanddeclaration"}, {"full_name": "Set.ite_inter_inter", "code": "theorem ite_inter_inter (t s\u2081 s\u2082 s\u2081' s\u2082' : Set \u03b1) :\n    t.ite (s\u2081 \u2229 s\u2082) (s\u2081' \u2229 s\u2082') = t.ite s\u2081 s\u2081' \u2229 t.ite s\u2082 s\u2082'", "start": [2331, 1], "end": [2335, 8], "kind": "commanddeclaration"}, {"full_name": "Set.ite_inter", "code": "theorem ite_inter (t s\u2081 s\u2082 s : Set \u03b1) : t.ite (s\u2081 \u2229 s) (s\u2082 \u2229 s) = t.ite s\u2081 s\u2082 \u2229 s", "start": [2338, 1], "end": [2339, 33], "kind": "commanddeclaration"}, {"full_name": "Set.ite_inter_of_inter_eq", "code": "theorem ite_inter_of_inter_eq (t : Set \u03b1) {s\u2081 s\u2082 s : Set \u03b1} (h : s\u2081 \u2229 s = s\u2082 \u2229 s) :\n    t.ite s\u2081 s\u2082 \u2229 s = s\u2081 \u2229 s", "start": [2342, 1], "end": [2343, 67], "kind": "commanddeclaration"}, {"full_name": "Set.subset_ite", "code": "theorem subset_ite {t s s' u : Set \u03b1} : u \u2286 t.ite s s' \u2194 u \u2229 t \u2286 s \u2227 u \\ t \u2286 s'", "start": [2346, 1], "end": [2349, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton", "code": "protected def Subsingleton (s : Set \u03b1) : Prop :=\n  \u2200 \u2983x\u2984 (_ : x \u2208 s) \u2983y\u2984 (_ : y \u2208 s), x = y", "start": [2355, 1], "end": [2357, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.anti", "code": "theorem Subsingleton.anti (ht : t.Subsingleton) (hst : s \u2286 t) : s.Subsingleton", "start": [2360, 1], "end": [2361, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.eq_singleton_of_mem", "code": "theorem Subsingleton.eq_singleton_of_mem (hs : s.Subsingleton) {x : \u03b1} (hx : x \u2208 s) : s = {x}", "start": [2364, 1], "end": [2365, 100], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_empty", "code": "@[simp]\ntheorem subsingleton_empty : (\u2205 : Set \u03b1).Subsingleton", "start": [2368, 1], "end": [2369, 77], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_singleton", "code": "@[simp]\ntheorem subsingleton_singleton {a} : ({a} : Set \u03b1).Subsingleton", "start": [2372, 1], "end": [2374, 70], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_subset_singleton", "code": "theorem subsingleton_of_subset_singleton (h : s \u2286 {a}) : s.Subsingleton", "start": [2377, 1], "end": [2378, 32], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_forall_eq", "code": "theorem subsingleton_of_forall_eq (a : \u03b1) (h : \u2200 b \u2208 s, b = a) : s.Subsingleton", "start": [2381, 1], "end": [2382, 31], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_iff_singleton", "code": "theorem subsingleton_iff_singleton {x} (hx : x \u2208 s) : s.Subsingleton \u2194 s = {x}", "start": [2385, 1], "end": [2386, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.eq_empty_or_singleton", "code": "theorem Subsingleton.eq_empty_or_singleton (hs : s.Subsingleton) : s = \u2205 \u2228 \u2203 x, s = {x}", "start": [2389, 1], "end": [2390, 90], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.induction_on", "code": "theorem Subsingleton.induction_on {p : Set \u03b1 \u2192 Prop} (hs : s.Subsingleton) (he : p \u2205)\n    (h\u2081 : \u2200 x, p {x}) : p s", "start": [2393, 1], "end": [2396, 20], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_univ", "code": "theorem subsingleton_univ [Subsingleton \u03b1] : (univ : Set \u03b1).Subsingleton", "start": [2399, 1], "end": [2400, 24], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_univ_subsingleton", "code": "theorem subsingleton_of_univ_subsingleton (h : (univ : Set \u03b1).Subsingleton) : Subsingleton \u03b1", "start": [2403, 1], "end": [2404, 43], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_univ_iff", "code": "@[simp]\ntheorem subsingleton_univ_iff : (univ : Set \u03b1).Subsingleton \u2194 Subsingleton \u03b1", "start": [2407, 1], "end": [2409, 71], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_subsingleton", "code": "theorem subsingleton_of_subsingleton [Subsingleton \u03b1] {s : Set \u03b1} : Set.Subsingleton s", "start": [2412, 1], "end": [2413, 41], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_isTop", "code": "theorem subsingleton_isTop (\u03b1 : Type*) [PartialOrder \u03b1] : Set.Subsingleton { x : \u03b1 | IsTop x }", "start": [2416, 1], "end": [2417, 44], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_isBot", "code": "theorem subsingleton_isBot (\u03b1 : Type*) [PartialOrder \u03b1] : Set.Subsingleton { x : \u03b1 | IsBot x }", "start": [2420, 1], "end": [2421, 44], "kind": "commanddeclaration"}, {"full_name": "Set.exists_eq_singleton_iff_nonempty_subsingleton", "code": "theorem exists_eq_singleton_iff_nonempty_subsingleton :\n    (\u2203 a : \u03b1, s = {a}) \u2194 s.Nonempty \u2227 s.Subsingleton", "start": [2424, 1], "end": [2429, 62], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_coe", "code": "@[simp, norm_cast]\ntheorem subsingleton_coe (s : Set \u03b1) : Subsingleton s \u2194 s.Subsingleton", "start": [2432, 1], "end": [2438, 86], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.coe_sort", "code": "theorem Subsingleton.coe_sort {s : Set \u03b1} : s.Subsingleton \u2192 Subsingleton s", "start": [2441, 1], "end": [2442, 23], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_coe_of_subsingleton", "code": "instance subsingleton_coe_of_subsingleton [Subsingleton \u03b1] {s : Set \u03b1} : Subsingleton s := by\n  rw [s.subsingleton_coe]\n  exact subsingleton_of_subsingleton", "start": [2445, 1], "end": [2449, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial", "code": "protected def Nontrivial (s : Set \u03b1) : Prop :=\n  \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y", "start": [2454, 1], "end": [2456, 26], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_mem_mem_ne", "code": "theorem nontrivial_of_mem_mem_ne {x y} (hx : x \u2208 s) (hy : y \u2208 s) (hxy : x \u2260 y) : s.Nontrivial", "start": [2459, 1], "end": [2460, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.choose", "code": "protected noncomputable def Nontrivial.choose (hs : s.Nontrivial) : \u03b1 \u00d7 \u03b1 :=\n  (Exists.choose hs, hs.choose_spec.right.choose)", "start": [2465, 1], "end": [2468, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.choose_fst_mem", "code": "protected theorem Nontrivial.choose_fst_mem (hs : s.Nontrivial) : hs.choose.fst \u2208 s", "start": [2471, 1], "end": [2472, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.choose_snd_mem", "code": "protected theorem Nontrivial.choose_snd_mem (hs : s.Nontrivial) : hs.choose.snd \u2208 s", "start": [2475, 1], "end": [2476, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.choose_fst_ne_choose_snd", "code": "protected theorem Nontrivial.choose_fst_ne_choose_snd (hs : s.Nontrivial) :\n    hs.choose.fst \u2260 hs.choose.snd", "start": [2479, 1], "end": [2481, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.mono", "code": "theorem Nontrivial.mono (hs : s.Nontrivial) (hst : s \u2286 t) : t.Nontrivial", "start": [2484, 1], "end": [2486, 30], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_pair", "code": "theorem nontrivial_pair {x y} (hxy : x \u2260 y) : ({x, y} : Set \u03b1).Nontrivial", "start": [2489, 1], "end": [2490, 69], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_pair_subset", "code": "theorem nontrivial_of_pair_subset {x y} (hxy : x \u2260 y) (h : {x, y} \u2286 s) : s.Nontrivial", "start": [2493, 1], "end": [2494, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.pair_subset", "code": "theorem Nontrivial.pair_subset (hs : s.Nontrivial) : \u2203 (x y : _) (_ : x \u2260 y), {x, y} \u2286 s", "start": [2497, 1], "end": [2499, 67], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_iff_pair_subset", "code": "theorem nontrivial_iff_pair_subset : s.Nontrivial \u2194 \u2203 (x y : _) (_ : x \u2260 y), {x, y} \u2286 s", "start": [2502, 1], "end": [2505, 37], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_exists_ne", "code": "theorem nontrivial_of_exists_ne {x} (hx : x \u2208 s) (h : \u2203 y \u2208 s, y \u2260 x) : s.Nontrivial", "start": [2508, 1], "end": [2510, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.exists_ne", "code": "theorem Nontrivial.exists_ne (hs : s.Nontrivial) (z) : \u2203 x \u2208 s, x \u2260 z", "start": [2513, 1], "end": [2517, 16], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_iff_exists_ne", "code": "theorem nontrivial_iff_exists_ne {x} (hx : x \u2208 s) : s.Nontrivial \u2194 \u2203 y \u2208 s, y \u2260 x", "start": [2520, 1], "end": [2521, 55], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_lt", "code": "theorem nontrivial_of_lt [Preorder \u03b1] {x y} (hx : x \u2208 s) (hy : y \u2208 s) (hxy : x < y) :\n    s.Nontrivial", "start": [2524, 1], "end": [2526, 31], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_exists_lt", "code": "theorem nontrivial_of_exists_lt [Preorder \u03b1]\n    (H : \u2203 (x : \u03b1) (_ : x \u2208 s) (y : \u03b1) (_ : y \u2208 s), x < y) : s.Nontrivial", "start": [2529, 1], "end": [2532, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.exists_lt", "code": "theorem Nontrivial.exists_lt [LinearOrder \u03b1] (hs : s.Nontrivial) :\n    \u2203 (x : \u03b1) (_ : x \u2208 s) (y : \u03b1) (_ : y \u2208 s), x < y", "start": [2535, 1], "end": [2538, 87], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_iff_exists_lt", "code": "theorem nontrivial_iff_exists_lt [LinearOrder \u03b1] :\n    s.Nontrivial \u2194 \u2203 (x : \u03b1) (_ : x \u2208 s) (y : \u03b1) (_ : y \u2208 s), x < y", "start": [2541, 1], "end": [2543, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.nonempty", "code": "protected theorem Nontrivial.nonempty (hs : s.Nontrivial) : s.Nonempty", "start": [2546, 1], "end": [2548, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.ne_empty", "code": "protected theorem Nontrivial.ne_empty (hs : s.Nontrivial) : s \u2260 \u2205", "start": [2551, 1], "end": [2552, 23], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.not_subset_empty", "code": "theorem Nontrivial.not_subset_empty (hs : s.Nontrivial) : \u00acs \u2286 \u2205", "start": [2555, 1], "end": [2556, 31], "kind": "commanddeclaration"}, {"full_name": "Set.not_nontrivial_empty", "code": "@[simp]\ntheorem not_nontrivial_empty : \u00ac(\u2205 : Set \u03b1).Nontrivial", "start": [2559, 1], "end": [2560, 82], "kind": "commanddeclaration"}, {"full_name": "Set.not_nontrivial_singleton", "code": "@[simp]\ntheorem not_nontrivial_singleton {x} : \u00ac({x} : Set \u03b1).Nontrivial", "start": [2563, 1], "end": [2567, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.ne_singleton", "code": "theorem Nontrivial.ne_singleton {x} (hs : s.Nontrivial) : s \u2260 {x}", "start": [2570, 1], "end": [2572, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.not_subset_singleton", "code": "theorem Nontrivial.not_subset_singleton {x} (hs : s.Nontrivial) : \u00acs \u2286 {x}", "start": [2575, 1], "end": [2576, 84], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_univ", "code": "theorem nontrivial_univ [Nontrivial \u03b1] : (univ : Set \u03b1).Nontrivial", "start": [2579, 1], "end": [2581, 38], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_univ_nontrivial", "code": "theorem nontrivial_of_univ_nontrivial (h : (univ : Set \u03b1).Nontrivial) : Nontrivial \u03b1", "start": [2584, 1], "end": [2586, 16], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_univ_iff", "code": "@[simp]\ntheorem nontrivial_univ_iff : (univ : Set \u03b1).Nontrivial \u2194 Nontrivial \u03b1", "start": [2589, 1], "end": [2591, 65], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_nontrivial", "code": "theorem nontrivial_of_nontrivial (hs : s.Nontrivial) : Nontrivial \u03b1", "start": [2594, 1], "end": [2596, 16], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_coe_sort", "code": "@[simp, norm_cast]\ntheorem nontrivial_coe_sort {s : Set \u03b1} : Nontrivial s \u2194 s.Nontrivial", "start": [2601, 1], "end": [2611, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.coe_sort", "code": "alias \u27e8_, Nontrivial.coe_sort\u27e9 := nontrivial_coe_sort", "start": [2614, 1], "end": [2614, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.nontrivial_of_nontrivial_coe", "code": "theorem nontrivial_of_nontrivial_coe (hs : Nontrivial s) : Nontrivial \u03b1", "start": [2617, 1], "end": [2620, 55], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_mono", "code": "theorem nontrivial_mono {\u03b1 : Type*} {s t : Set \u03b1} (hst : s \u2286 t) (hs : Nontrivial s) :\n    Nontrivial t", "start": [2623, 1], "end": [2625, 61], "kind": "commanddeclaration"}, {"full_name": "Set.not_subsingleton_iff", "code": "@[simp]\ntheorem not_subsingleton_iff : \u00acs.Subsingleton \u2194 s.Nontrivial", "start": [2628, 1], "end": [2630, 70], "kind": "commanddeclaration"}, {"full_name": "Set.not_nontrivial_iff", "code": "@[simp]\ntheorem not_nontrivial_iff : \u00acs.Nontrivial \u2194 s.Subsingleton", "start": [2633, 1], "end": [2635, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.not_nontrivial", "code": "alias \u27e8_, Subsingleton.not_nontrivial\u27e9 := not_nontrivial_iff", "start": [2638, 1], "end": [2638, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Nontrivial.not_subsingleton", "code": "alias \u27e8_, Nontrivial.not_subsingleton\u27e9 := not_subsingleton_iff", "start": [2641, 1], "end": [2641, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.subsingleton_or_nontrivial", "code": "protected lemma subsingleton_or_nontrivial (s : Set \u03b1) : s.Subsingleton \u2228 s.Nontrivial := by\n  simp [or_iff_not_imp_right]", "start": [2644, 1], "end": [2645, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Set.eq_singleton_or_nontrivial", "code": "lemma eq_singleton_or_nontrivial (ha : a \u2208 s) : s = {a} \u2228 s.Nontrivial := by\n  rw [\u2190subsingleton_iff_singleton ha]; exact s.subsingleton_or_nontrivial", "start": [2648, 1], "end": [2649, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Set.nontrivial_iff_ne_singleton", "code": "lemma nontrivial_iff_ne_singleton (ha : a \u2208 s) : s.Nontrivial \u2194 s \u2260 {a} :=\n  \u27e8Nontrivial.ne_singleton, (eq_singleton_or_nontrivial ha).resolve_left\u27e9", "start": [2652, 1], "end": [2653, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Nonempty.exists_eq_singleton_or_nontrivial", "code": "lemma Nonempty.exists_eq_singleton_or_nontrivial : s.Nonempty \u2192 (\u2203 a, s = {a}) \u2228 s.Nontrivial :=\n  fun \u27e8a, ha\u27e9 \u21a6 (eq_singleton_or_nontrivial ha).imp_left $ Exists.intro a", "start": [2656, 1], "end": [2657, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Set.univ_eq_true_false", "code": "theorem univ_eq_true_false : univ = ({True, False} : Set Prop)", "start": [2660, 1], "end": [2663, 35], "kind": "commanddeclaration"}, {"full_name": "Set.monotoneOn_iff_monotone", "code": "theorem monotoneOn_iff_monotone : MonotoneOn f s \u2194\n    Monotone fun a : s => f a", "start": [2675, 1], "end": [2677, 30], "kind": "commanddeclaration"}, {"full_name": "Set.antitoneOn_iff_antitone", "code": "theorem antitoneOn_iff_antitone : AntitoneOn f s \u2194\n    Antitone fun a : s => f a", "start": [2680, 1], "end": [2682, 30], "kind": "commanddeclaration"}, {"full_name": "Set.strictMonoOn_iff_strictMono", "code": "theorem strictMonoOn_iff_strictMono : StrictMonoOn f s \u2194\n    StrictMono fun a : s => f a", "start": [2685, 1], "end": [2687, 34], "kind": "commanddeclaration"}, {"full_name": "Set.strictAntiOn_iff_strictAnti", "code": "theorem strictAntiOn_iff_strictAnti : StrictAntiOn f s \u2194\n    StrictAnti fun a : s => f a", "start": [2690, 1], "end": [2692, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.monotoneOn", "code": "protected theorem Subsingleton.monotoneOn (h : s.Subsingleton) : MonotoneOn f s", "start": [2700, 1], "end": [2701, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.antitoneOn", "code": "protected theorem Subsingleton.antitoneOn (h : s.Subsingleton) : AntitoneOn f s", "start": [2704, 1], "end": [2705, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.strictMonoOn", "code": "protected theorem Subsingleton.strictMonoOn (h : s.Subsingleton) : StrictMonoOn f s", "start": [2708, 1], "end": [2709, 47], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.strictAntiOn", "code": "protected theorem Subsingleton.strictAntiOn (h : s.Subsingleton) : StrictAntiOn f s", "start": [2712, 1], "end": [2713, 47], "kind": "commanddeclaration"}, {"full_name": "Set.monotoneOn_singleton", "code": "@[simp]\ntheorem monotoneOn_singleton : MonotoneOn f {a}", "start": [2716, 1], "end": [2718, 38], "kind": "commanddeclaration"}, {"full_name": "Set.antitoneOn_singleton", "code": "@[simp]\ntheorem antitoneOn_singleton : AntitoneOn f {a}", "start": [2721, 1], "end": [2723, 38], "kind": "commanddeclaration"}, {"full_name": "Set.strictMonoOn_singleton", "code": "@[simp]\ntheorem strictMonoOn_singleton : StrictMonoOn f {a}", "start": [2726, 1], "end": [2728, 40], "kind": "commanddeclaration"}, {"full_name": "Set.strictAntiOn_singleton", "code": "@[simp]\ntheorem strictAntiOn_singleton : StrictAntiOn f {a}", "start": [2731, 1], "end": [2733, 40], "kind": "commanddeclaration"}, {"full_name": "Set.not_monotoneOn_not_antitoneOn_iff_exists_le_le", "code": "theorem not_monotoneOn_not_antitoneOn_iff_exists_le_le :\n    \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n      \u2203 (a : \u03b1) (_ : a \u2208 s) (b : \u03b1) (_ : b \u2208 s) (c : \u03b1) (_ : c \u2208 s),\n        a \u2264 b \u2227 b \u2264 c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)", "start": [2742, 1], "end": [2749, 72], "kind": "commanddeclaration"}, {"full_name": "Set.not_monotoneOn_not_antitoneOn_iff_exists_lt_lt", "code": "theorem not_monotoneOn_not_antitoneOn_iff_exists_lt_lt :\n    \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n      \u2203 (a : \u03b1) (_ : a \u2208 s) (b : \u03b1) (_ : b \u2208 s) (c : \u03b1) (_ : c \u2208 s),\n        a < b \u2227 b < c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)", "start": [2752, 1], "end": [2759, 72], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonempty_apply_iff", "code": "theorem Injective.nonempty_apply_iff {f : Set \u03b1 \u2192 Set \u03b2} (hf : Injective f) (h2 : f \u2205 = \u2205)\n    {s : Set \u03b1} : (f s).Nonempty \u2194 s.Nonempty", "start": [2772, 1], "end": [2774, 69], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion", "code": "def inclusion (h : s \u2286 t) : s \u2192 t := fun x : s => (\u27e8x, h x.2\u27e9 : t)", "start": [2790, 1], "end": [2791, 67], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_self", "code": "@[simp]\ntheorem inclusion_self (x : s) : inclusion Subset.rfl x = x", "start": [2794, 1], "end": [2797, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_eq_id", "code": "theorem inclusion_eq_id (h : s \u2286 s) : inclusion h = id", "start": [2800, 1], "end": [2801, 24], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_mk", "code": "@[simp]\ntheorem inclusion_mk {h : s \u2286 t} (a : \u03b1) (ha : a \u2208 s) : inclusion h \u27e8a, ha\u27e9 = \u27e8a, h ha\u27e9", "start": [2804, 1], "end": [2806, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_right", "code": "theorem inclusion_right (h : s \u2286 t) (x : t) (m : (x : \u03b1) \u2208 s) : inclusion h \u27e8x, m\u27e9 = x", "start": [2809, 1], "end": [2811, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_inclusion", "code": "@[simp]\ntheorem inclusion_inclusion (hst : s \u2286 t) (htu : t \u2286 u) (x : s) :\n    inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x", "start": [2814, 1], "end": [2818, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_comp_inclusion", "code": "@[simp]\ntheorem inclusion_comp_inclusion {\u03b1} {s t u : Set \u03b1} (hst : s \u2286 t) (htu : t \u2286 u) :\n    inclusion htu \u2218 inclusion hst = inclusion (hst.trans htu)", "start": [2821, 1], "end": [2824, 39], "kind": "commanddeclaration"}, {"full_name": "Set.coe_inclusion", "code": "@[simp]\ntheorem coe_inclusion (h : s \u2286 t) (x : s) : (inclusion h x : \u03b1) = (x : \u03b1)", "start": [2827, 1], "end": [2829, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_injective", "code": "theorem inclusion_injective (h : s \u2286 t) : Injective (inclusion h)", "start": [2832, 1], "end": [2833, 68], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_inj", "code": "@[simp]\ntheorem inclusion_inj (h : s \u2286 t) {x y : s} : inclusion h x = inclusion h y \u2194 x = y", "start": [2836, 1], "end": [2838, 33], "kind": "commanddeclaration"}, {"full_name": "Set.eq_of_inclusion_surjective", "code": "theorem eq_of_inclusion_surjective {s t : Set \u03b1} {h : s \u2286 t}\n    (h_surj : Function.Surjective (inclusion h)) : s = t", "start": [2840, 1], "end": [2844, 64], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_le_inclusion", "code": "@[simp]\ntheorem inclusion_le_inclusion [Preorder \u03b1] {s t : Set \u03b1} (h : s \u2286 t) {x y : s} :\n    inclusion h x \u2264 inclusion h y \u2194 x \u2264 y", "start": [2847, 1], "end": [2849, 53], "kind": "commanddeclaration"}, {"full_name": "Set.inclusion_lt_inclusion", "code": "@[simp]\ntheorem inclusion_lt_inclusion [Preorder \u03b1] {s t : Set \u03b1} (h : s \u2286 t) {x y : s} :\n    inclusion h x < inclusion h y \u2194 x < y", "start": [2851, 1], "end": [2853, 53], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.eq_univ_of_nonempty", "code": "theorem eq_univ_of_nonempty {s : Set \u03b1} : s.Nonempty \u2192 s = univ", "start": [2863, 1], "end": [2864, 56], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.set_cases", "code": "@[elab_as_elim]\ntheorem set_cases {p : Set \u03b1 \u2192 Prop} (h0 : p \u2205) (h1 : p univ) (s) : p s", "start": [2867, 1], "end": [2869, 96], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.mem_iff_nonempty", "code": "theorem mem_iff_nonempty {\u03b1 : Type*} [Subsingleton \u03b1] {s : Set \u03b1} {x : \u03b1} : x \u2208 s \u2194 s.Nonempty", "start": [2872, 1], "end": [2873, 65], "kind": "commanddeclaration"}, {"full_name": "Set.decidableSdiff", "code": "instance decidableSdiff [Decidable (a \u2208 s)] [Decidable (a \u2208 t)] : Decidable (a \u2208 s \\ t) :=\n  (by infer_instance : Decidable (a \u2208 s \u2227 a \u2209 t))", "start": [2885, 1], "end": [2886, 50], "kind": "commanddeclaration"}, {"full_name": "Set.decidableInter", "code": "instance decidableInter [Decidable (a \u2208 s)] [Decidable (a \u2208 t)] : Decidable (a \u2208 s \u2229 t) :=\n  (by infer_instance : Decidable (a \u2208 s \u2227 a \u2208 t))", "start": [2889, 1], "end": [2890, 50], "kind": "commanddeclaration"}, {"full_name": "Set.decidableUnion", "code": "instance decidableUnion [Decidable (a \u2208 s)] [Decidable (a \u2208 t)] : Decidable (a \u2208 s \u222a t) :=\n  (by infer_instance : Decidable (a \u2208 s \u2228 a \u2208 t))", "start": [2893, 1], "end": [2894, 50], "kind": "commanddeclaration"}, {"full_name": "Set.decidableCompl", "code": "instance decidableCompl [Decidable (a \u2208 s)] : Decidable (a \u2208 s\u1d9c) :=\n  (by infer_instance : Decidable (a \u2209 s))", "start": [2897, 1], "end": [2898, 42], "kind": "commanddeclaration"}, {"full_name": "Set.decidableEmptyset", "code": "instance decidableEmptyset : DecidablePred (\u00b7 \u2208 (\u2205 : Set \u03b1)) := fun _ => Decidable.isFalse (by simp)", "start": [2901, 1], "end": [2901, 101], "kind": "commanddeclaration"}, {"full_name": "Set.decidableUniv", "code": "instance decidableUniv : DecidablePred (\u00b7 \u2208 (Set.univ : Set \u03b1)) := fun _ =>\n  Decidable.isTrue (by simp)", "start": [2904, 1], "end": [2905, 29], "kind": "commanddeclaration"}, {"full_name": "Set.decidableSetOf", "code": "instance decidableSetOf (p : \u03b1 \u2192 Prop) [Decidable (p a)] : Decidable (a \u2208 { a | p a }) := by\n  assumption", "start": [2908, 1], "end": [2909, 13], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemSingleton", "code": "instance decidableMemSingleton {a b : \u03b1} [DecidableEq \u03b1] :\n    Decidable (a \u2208 ({b} : Set \u03b1)) := decidableSetOf _ (\u00b7 = b)", "start": [2913, 1], "end": [2914, 62], "kind": "commanddeclaration"}, {"full_name": "Monotone.inter", "code": "theorem Monotone.inter [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x \u2229 g x", "start": [2923, 1], "end": [2925, 12], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.inter", "code": "theorem MonotoneOn.inter [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => f x \u2229 g x) s", "start": [2928, 1], "end": [2930, 12], "kind": "commanddeclaration"}, {"full_name": "Antitone.inter", "code": "theorem Antitone.inter [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x \u2229 g x", "start": [2933, 1], "end": [2935, 12], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.inter", "code": "theorem AntitoneOn.inter [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => f x \u2229 g x) s", "start": [2938, 1], "end": [2940, 12], "kind": "commanddeclaration"}, {"full_name": "Monotone.union", "code": "theorem Monotone.union [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x \u222a g x", "start": [2943, 1], "end": [2945, 12], "kind": "commanddeclaration"}, {"full_name": "MonotoneOn.union", "code": "theorem MonotoneOn.union [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hf : MonotoneOn f s)\n    (hg : MonotoneOn g s) : MonotoneOn (fun x => f x \u222a g x) s", "start": [2948, 1], "end": [2950, 12], "kind": "commanddeclaration"}, {"full_name": "Antitone.union", "code": "theorem Antitone.union [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x \u222a g x", "start": [2953, 1], "end": [2955, 12], "kind": "commanddeclaration"}, {"full_name": "AntitoneOn.union", "code": "theorem AntitoneOn.union [Preorder \u03b2] {f g : \u03b2 \u2192 Set \u03b1} {s : Set \u03b2} (hf : AntitoneOn f s)\n    (hg : AntitoneOn g s) : AntitoneOn (fun x => f x \u222a g x) s", "start": [2958, 1], "end": [2960, 12], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_setOf", "code": "theorem monotone_setOf [Preorder \u03b1] {p : \u03b1 \u2192 \u03b2 \u2192 Prop} (hp : \u2200 b, Monotone fun a => p a b) :\n    Monotone fun a => { b | p a b }", "start": [2965, 1], "end": [2966, 61], "kind": "commanddeclaration"}, {"full_name": "Set.antitone_setOf", "code": "theorem antitone_setOf [Preorder \u03b1] {p : \u03b1 \u2192 \u03b2 \u2192 Prop} (hp : \u2200 b, Antitone fun a => p a b) :\n    Antitone fun a => { b | p a b }", "start": [2969, 1], "end": [2970, 61], "kind": "commanddeclaration"}, {"full_name": "Set.antitone_bforall", "code": "theorem antitone_bforall {P : \u03b1 \u2192 Prop} : Antitone fun s : Set \u03b1 => \u2200 x \u2208 s, P x", "start": [2973, 1], "end": [2975, 38], "kind": "commanddeclaration"}, {"full_name": "Disjoint.union_left", "code": "theorem union_left (hs : Disjoint s u) (ht : Disjoint t u) : Disjoint (s \u222a t) u", "start": [2988, 1], "end": [2989, 17], "kind": "commanddeclaration"}, {"full_name": "Disjoint.union_right", "code": "theorem union_right (ht : Disjoint s t) (hu : Disjoint s u) : Disjoint s (t \u222a u)", "start": [2992, 1], "end": [2993, 18], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inter_left", "code": "theorem inter_left (u : Set \u03b1) (h : Disjoint s t) : Disjoint (s \u2229 u) t", "start": [2996, 1], "end": [2997, 15], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inter_left'", "code": "theorem inter_left' (u : Set \u03b1) (h : Disjoint s t) : Disjoint (u \u2229 s) t", "start": [3000, 1], "end": [3001, 16], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inter_right", "code": "theorem inter_right (u : Set \u03b1) (h : Disjoint s t) : Disjoint s (t \u2229 u)", "start": [3004, 1], "end": [3005, 16], "kind": "commanddeclaration"}, {"full_name": "Disjoint.inter_right'", "code": "theorem inter_right' (u : Set \u03b1) (h : Disjoint s t) : Disjoint s (u \u2229 t)", "start": [3008, 1], "end": [3009, 17], "kind": "commanddeclaration"}, {"full_name": "Disjoint.subset_left_of_subset_union", "code": "theorem subset_left_of_subset_union (h : s \u2286 t \u222a u) (hac : Disjoint s u) : s \u2286 t", "start": [3012, 1], "end": [3013, 32], "kind": "commanddeclaration"}, {"full_name": "Disjoint.subset_right_of_subset_union", "code": "theorem subset_right_of_subset_union (h : s \u2286 t \u222a u) (hab : Disjoint s t) : s \u2286 u", "start": [3016, 1], "end": [3017, 31], "kind": "commanddeclaration"}, {"full_name": "Prop.compl_singleton", "code": "@[simp] theorem Prop.compl_singleton (p : Prop) : ({p}\u1d9c : Set Prop) = {\u00acp}", "start": [3022, 1], "end": [3023, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "dvd_add", "code": "theorem dvd_add [LeftDistribClass \u03b1] {a b c : \u03b1} (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b + c", "start": [27, 1], "end": [28, 101], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.add", "code": "alias Dvd.dvd.add := dvd_add", "start": [31, 1], "end": [31, 29], "kind": "stdtacticaliasalias"}, {"full_name": "two_dvd_bit0", "code": "@[simp]\ntheorem two_dvd_bit0 [Semiring \u03b1] {a : \u03b1} : 2 \u2223 bit0 a", "start": [37, 1], "end": [39, 25], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.linear_comb", "code": "theorem Dvd.dvd.linear_comb {d x y : \u03b1} (hdx : d \u2223 x) (hdy : d \u2223 y) (a b : \u03b1) : d \u2223 a * x + b * y", "start": [46, 1], "end": [47, 44], "kind": "commanddeclaration"}, {"full_name": "dvd_neg", "code": "@[simp]\ntheorem dvd_neg : a \u2223 -b \u2194 a \u2223 b", "start": [56, 1], "end": [61, 56], "kind": "commanddeclaration"}, {"full_name": "neg_dvd", "code": "@[simp]\ntheorem neg_dvd : -a \u2223 b \u2194 a \u2223 b", "start": [64, 1], "end": [69, 56], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.of_neg_left", "code": "alias \u27e8Dvd.dvd.of_neg_left, Dvd.dvd.neg_left\u27e9 := neg_dvd", "start": [72, 1], "end": [72, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Dvd.dvd.neg_left", "code": "alias \u27e8Dvd.dvd.of_neg_left, Dvd.dvd.neg_left\u27e9 := neg_dvd", "start": [72, 1], "end": [72, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Dvd.dvd.of_neg_right", "code": "alias \u27e8Dvd.dvd.of_neg_right, Dvd.dvd.neg_right\u27e9 := dvd_neg", "start": [76, 1], "end": [76, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Dvd.dvd.neg_right", "code": "alias \u27e8Dvd.dvd.of_neg_right, Dvd.dvd.neg_right\u27e9 := dvd_neg", "start": [76, 1], "end": [76, 59], "kind": "stdtacticaliasaliaslr"}, {"full_name": "dvd_sub", "code": "theorem dvd_sub (h\u2081 : a \u2223 b) (h\u2082 : a \u2223 c) : a \u2223 b - c", "start": [86, 1], "end": [87, 58], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.sub", "code": "alias Dvd.dvd.sub := dvd_sub", "start": [90, 1], "end": [90, 29], "kind": "stdtacticaliasalias"}, {"full_name": "dvd_add_left", "code": "theorem dvd_add_left (h : a \u2223 c) : a \u2223 b + c \u2194 a \u2223 b", "start": [93, 1], "end": [96, 86], "kind": "commanddeclaration"}, {"full_name": "dvd_add_right", "code": "theorem dvd_add_right (h : a \u2223 b) : a \u2223 b + c \u2194 a \u2223 c", "start": [99, 1], "end": [101, 96], "kind": "commanddeclaration"}, {"full_name": "dvd_sub_left", "code": "theorem dvd_sub_left (h : a \u2223 c) : a \u2223 b - c \u2194 a \u2223 b", "start": [104, 1], "end": [108, 76], "kind": "commanddeclaration"}, {"full_name": "dvd_sub_right", "code": "theorem dvd_sub_right (h : a \u2223 b) : a \u2223 b - c \u2194 a \u2223 c", "start": [111, 1], "end": [115, 57], "kind": "commanddeclaration"}, {"full_name": "dvd_iff_dvd_of_dvd_sub", "code": "theorem dvd_iff_dvd_of_dvd_sub (h : a \u2223 b - c) : a \u2223 b \u2194 a \u2223 c", "start": [118, 1], "end": [119, 45], "kind": "commanddeclaration"}, {"full_name": "dvd_sub_comm", "code": "theorem dvd_sub_comm : a \u2223 b - c \u2194 a \u2223 c - b", "start": [123, 1], "end": [123, 84], "kind": "commanddeclaration"}, {"full_name": "two_dvd_bit1", "code": "theorem two_dvd_bit1 : 2 \u2223 bit1 a \u2194 (2 : \u03b1) \u2223 1", "start": [133, 1], "end": [134, 29], "kind": "commanddeclaration"}, {"full_name": "dvd_add_self_left", "code": "@[simp]\ntheorem dvd_add_self_left {a b : \u03b1} : a \u2223 a + b \u2194 a \u2223 b", "start": [137, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "dvd_add_self_right", "code": "@[simp]\ntheorem dvd_add_self_right {a b : \u03b1} : a \u2223 b + a \u2194 a \u2223 b", "start": [143, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "dvd_sub_self_left", "code": "@[simp]\ntheorem dvd_sub_self_left : a \u2223 a - b \u2194 a \u2223 b", "start": [149, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "dvd_sub_self_right", "code": "@[simp]\ntheorem dvd_sub_self_right : a \u2223 b - a \u2194 a \u2223 b", "start": [155, 1], "end": [158, 23], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_sub_mul", "code": "theorem dvd_mul_sub_mul {k a b x y : \u03b1} (hab : k \u2223 a - b) (hxy : k \u2223 x - y) :\n    k \u2223 a * x - b * y", "start": [167, 1], "end": [171, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Abs.lean", "imports": ["Mathlib/Algebra/Abs.lean", "Mathlib/Algebra/Order/Group/OrderIso.lean", "Mathlib/Order/MinMax.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Inv.toHasAbs", "code": "@[to_additive \"`abs a` is the absolute value of `a`\"]\ninstance (priority := 100) Inv.toHasAbs [Inv \u03b1] [Sup \u03b1] : Abs \u03b1 :=\n  \u27e8fun a => a \u2294 a\u207b\u00b9\u27e9", "start": [26, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "abs_eq_sup_inv", "code": "@[to_additive]\ntheorem abs_eq_sup_inv [Inv \u03b1] [Sup \u03b1] (a : \u03b1) : |a| = a \u2294 a\u207b\u00b9", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "abs_eq_max_neg", "code": "theorem abs_eq_max_neg : abs a = max a (-a)", "start": [41, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "abs_choice", "code": "theorem abs_choice (x : \u03b1) : |x| = x \u2228 |x| = -x", "start": [45, 1], "end": [46, 17], "kind": "commanddeclaration"}, {"full_name": "abs_le'", "code": "theorem abs_le' : |a| \u2264 b \u2194 a \u2264 b \u2227 -a \u2264 b", "start": [49, 1], "end": [50, 13], "kind": "commanddeclaration"}, {"full_name": "le_abs", "code": "theorem le_abs : a \u2264 |b| \u2194 a \u2264 b \u2228 a \u2264 -b", "start": [53, 1], "end": [54, 13], "kind": "commanddeclaration"}, {"full_name": "le_abs_self", "code": "theorem le_abs_self (a : \u03b1) : a \u2264 |a|", "start": [57, 1], "end": [58, 18], "kind": "commanddeclaration"}, {"full_name": "neg_le_abs_self", "code": "theorem neg_le_abs_self (a : \u03b1) : -a \u2264 |a|", "start": [61, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "lt_abs", "code": "theorem lt_abs : a < |b| \u2194 a < b \u2228 a < -b", "start": [65, 1], "end": [66, 13], "kind": "commanddeclaration"}, {"full_name": "abs_le_abs", "code": "theorem abs_le_abs (h\u2080 : a \u2264 b) (h\u2081 : -a \u2264 b) : |a| \u2264 |b|", "start": [69, 1], "end": [70, 45], "kind": "commanddeclaration"}, {"full_name": "abs_by_cases", "code": "theorem abs_by_cases (P : \u03b1 \u2192 Prop) {a : \u03b1} (h1 : P a) (h2 : P (-a)) : P |a|", "start": [73, 1], "end": [74, 20], "kind": "commanddeclaration"}, {"full_name": "abs_neg", "code": "@[simp]\ntheorem abs_neg (a : \u03b1) : |(-a)| = |a|", "start": [83, 1], "end": [84, 100], "kind": "commanddeclaration"}, {"full_name": "eq_or_eq_neg_of_abs_eq", "code": "theorem eq_or_eq_neg_of_abs_eq {a b : \u03b1} (h : |a| = b) : a = b \u2228 a = -b", "start": [87, 1], "end": [88, 77], "kind": "commanddeclaration"}, {"full_name": "abs_eq_abs", "code": "theorem abs_eq_abs {a b : \u03b1} : |a| = |b| \u2194 a = b \u2228 a = -b", "start": [91, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "abs_sub_comm", "code": "theorem abs_sub_comm (a b : \u03b1) : |a - b| = |b - a|", "start": [99, 1], "end": [102, 35], "kind": "commanddeclaration"}, {"full_name": "abs_of_nonneg", "code": "theorem abs_of_nonneg (h : 0 \u2264 a) : |a| = a", "start": [107, 1], "end": [108, 42], "kind": "commanddeclaration"}, {"full_name": "abs_of_pos", "code": "theorem abs_of_pos (h : 0 < a) : |a| = a", "start": [111, 1], "end": [112, 21], "kind": "commanddeclaration"}, {"full_name": "abs_of_nonpos", "code": "theorem abs_of_nonpos (h : a \u2264 0) : |a| = -a", "start": [115, 1], "end": [116, 43], "kind": "commanddeclaration"}, {"full_name": "abs_of_neg", "code": "theorem abs_of_neg (h : a < 0) : |a| = -a", "start": [119, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "abs_le_abs_of_nonneg", "code": "theorem abs_le_abs_of_nonneg (ha : 0 \u2264 a) (hab : a \u2264 b) : |a| \u2264 |b|", "start": [123, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "abs_zero", "code": "@[simp]\ntheorem abs_zero : |0| = (0 : \u03b1)", "start": [127, 1], "end": [129, 23], "kind": "commanddeclaration"}, {"full_name": "abs_pos", "code": "@[simp]\ntheorem abs_pos : 0 < |a| \u2194 a \u2260 0", "start": [132, 1], "end": [137, 41], "kind": "commanddeclaration"}, {"full_name": "abs_pos_of_pos", "code": "theorem abs_pos_of_pos (h : 0 < a) : 0 < |a|", "start": [140, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "abs_pos_of_neg", "code": "theorem abs_pos_of_neg (h : a < 0) : 0 < |a|", "start": [144, 1], "end": [145, 17], "kind": "commanddeclaration"}, {"full_name": "neg_abs_le_self", "code": "theorem neg_abs_le_self (a : \u03b1) : -|a| \u2264 a", "start": [148, 1], "end": [156, 30], "kind": "commanddeclaration"}, {"full_name": "add_abs_nonneg", "code": "theorem add_abs_nonneg (a : \u03b1) : 0 \u2264 a + |a|", "start": [159, 1], "end": [162, 26], "kind": "commanddeclaration"}, {"full_name": "neg_abs_le_neg", "code": "theorem neg_abs_le_neg (a : \u03b1) : -|a| \u2264 -a", "start": [165, 1], "end": [165, 82], "kind": "commanddeclaration"}, {"full_name": "abs_nonneg", "code": "@[simp]\ntheorem abs_nonneg (a : \u03b1) : 0 \u2264 |a|", "start": [168, 1], "end": [171, 48], "kind": "commanddeclaration"}, {"full_name": "abs_abs", "code": "@[simp]\ntheorem abs_abs (a : \u03b1) : |(|a|)| = |a|", "start": [174, 1], "end": [176, 32], "kind": "commanddeclaration"}, {"full_name": "abs_eq_zero", "code": "@[simp]\ntheorem abs_eq_zero : |a| = 0 \u2194 a = 0", "start": [179, 1], "end": [181, 90], "kind": "commanddeclaration"}, {"full_name": "abs_nonpos_iff", "code": "@[simp]\ntheorem abs_nonpos_iff {a : \u03b1} : |a| \u2264 0 \u2194 a = 0", "start": [184, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "abs_le_abs_of_nonpos", "code": "theorem abs_le_abs_of_nonpos (ha : a \u2264 0) (hab : b \u2264 a) : |a| \u2264 |b|", "start": [191, 1], "end": [193, 31], "kind": "commanddeclaration"}, {"full_name": "abs_lt", "code": "theorem abs_lt : |a| < b \u2194 -b < a \u2227 a < b", "start": [196, 1], "end": [197, 55], "kind": "commanddeclaration"}, {"full_name": "neg_lt_of_abs_lt", "code": "theorem neg_lt_of_abs_lt (h : |a| < b) : -b < a", "start": [200, 1], "end": [201, 18], "kind": "commanddeclaration"}, {"full_name": "lt_of_abs_lt", "code": "theorem lt_of_abs_lt (h : |a| < b) : a < b", "start": [204, 1], "end": [205, 18], "kind": "commanddeclaration"}, {"full_name": "max_sub_min_eq_abs'", "code": "theorem max_sub_min_eq_abs' (a b : \u03b1) : max a b - min a b = |a - b|", "start": [208, 1], "end": [213, 21], "kind": "commanddeclaration"}, {"full_name": "max_sub_min_eq_abs", "code": "theorem max_sub_min_eq_abs (a b : \u03b1) : max a b - min a b = |b - a|", "start": [216, 1], "end": [218, 32], "kind": "commanddeclaration"}, {"full_name": "abs_le", "code": "theorem abs_le : |a| \u2264 b \u2194 -b \u2264 a \u2227 a \u2264 b", "start": [234, 1], "end": [234, 82], "kind": "commanddeclaration"}, {"full_name": "le_abs'", "code": "theorem le_abs' : a \u2264 |b| \u2194 b \u2264 -a \u2228 a \u2264 b", "start": [237, 1], "end": [237, 81], "kind": "commanddeclaration"}, {"full_name": "neg_le_of_abs_le", "code": "theorem neg_le_of_abs_le (h : |a| \u2264 b) : -b \u2264 a", "start": [240, 1], "end": [241, 18], "kind": "commanddeclaration"}, {"full_name": "le_of_abs_le", "code": "theorem le_of_abs_le (h : |a| \u2264 b) : a \u2264 b", "start": [244, 1], "end": [245, 18], "kind": "commanddeclaration"}, {"full_name": "apply_abs_le_mul_of_one_le'", "code": "@[to_additive]\ntheorem apply_abs_le_mul_of_one_le' {\u03b2 : Type*} [MulOneClass \u03b2] [Preorder \u03b2]\n    [CovariantClass \u03b2 \u03b2 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b2 \u03b2 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f : \u03b1 \u2192 \u03b2}\n    {a : \u03b1} (h\u2081 : 1 \u2264 f a) (h\u2082 : 1 \u2264 f (-a)) : f |a| \u2264 f a * f (-a)", "start": [248, 1], "end": [253, 57], "kind": "commanddeclaration"}, {"full_name": "apply_abs_le_mul_of_one_le", "code": "@[to_additive]\ntheorem apply_abs_le_mul_of_one_le {\u03b2 : Type*} [MulOneClass \u03b2] [Preorder \u03b2]\n    [CovariantClass \u03b2 \u03b2 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] [CovariantClass \u03b2 \u03b2 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x, 1 \u2264 f x) (a : \u03b1) : f |a| \u2264 f a * f (-a)", "start": [257, 1], "end": [261, 42], "kind": "commanddeclaration"}, {"full_name": "abs_add", "code": "theorem abs_add (a b : \u03b1) : |a + b| \u2264 |a| + |b|", "start": [265, 1], "end": [270, 50], "kind": "commanddeclaration"}, {"full_name": "abs_add'", "code": "theorem abs_add' (a b : \u03b1) : |a| \u2264 |b| + |b + a|", "start": [273, 1], "end": [273, 88], "kind": "commanddeclaration"}, {"full_name": "abs_sub", "code": "theorem abs_sub (a b : \u03b1) : |a - b| \u2264 |a| + |b|", "start": [276, 1], "end": [278, 20], "kind": "commanddeclaration"}, {"full_name": "abs_sub_le_iff", "code": "theorem abs_sub_le_iff : |a - b| \u2264 c \u2194 a - b \u2264 c \u2227 b - a \u2264 c", "start": [281, 1], "end": [282, 87], "kind": "commanddeclaration"}, {"full_name": "abs_sub_lt_iff", "code": "theorem abs_sub_lt_iff : |a - b| < c \u2194 a - b < c \u2227 b - a < c", "start": [285, 1], "end": [286, 91], "kind": "commanddeclaration"}, {"full_name": "sub_le_of_abs_sub_le_left", "code": "theorem sub_le_of_abs_sub_le_left (h : |a - b| \u2264 c) : b - c \u2264 a", "start": [289, 1], "end": [290, 42], "kind": "commanddeclaration"}, {"full_name": "sub_le_of_abs_sub_le_right", "code": "theorem sub_le_of_abs_sub_le_right (h : |a - b| \u2264 c) : a - c \u2264 b", "start": [293, 1], "end": [294, 51], "kind": "commanddeclaration"}, {"full_name": "sub_lt_of_abs_sub_lt_left", "code": "theorem sub_lt_of_abs_sub_lt_left (h : |a - b| < c) : b - c < a", "start": [297, 1], "end": [298, 42], "kind": "commanddeclaration"}, {"full_name": "sub_lt_of_abs_sub_lt_right", "code": "theorem sub_lt_of_abs_sub_lt_right (h : |a - b| < c) : a - c < b", "start": [301, 1], "end": [302, 51], "kind": "commanddeclaration"}, {"full_name": "abs_sub_abs_le_abs_sub", "code": "theorem abs_sub_abs_le_abs_sub (a b : \u03b1) : |a| - |b| \u2264 |a - b|", "start": [305, 1], "end": [309, 39], "kind": "commanddeclaration"}, {"full_name": "abs_abs_sub_abs_le_abs_sub", "code": "theorem abs_abs_sub_abs_le_abs_sub (a b : \u03b1) : |(|a| - |b|)| \u2264 |a - b|", "start": [312, 1], "end": [314, 85], "kind": "commanddeclaration"}, {"full_name": "abs_eq", "code": "theorem abs_eq (hb : 0 \u2264 b) : |a| = b \u2194 a = b \u2228 a = -b", "start": [317, 1], "end": [319, 63], "kind": "commanddeclaration"}, {"full_name": "abs_le_max_abs_abs", "code": "theorem abs_le_max_abs_abs (hab : a \u2264 b) (hbc : b \u2264 c) : |b| \u2264 max |a| |c|", "start": [322, 1], "end": [325, 73], "kind": "commanddeclaration"}, {"full_name": "min_abs_abs_le_abs_max", "code": "theorem min_abs_abs_le_abs_max : min |a| |b| \u2264 |max a b|", "start": [328, 1], "end": [330, 76], "kind": "commanddeclaration"}, {"full_name": "min_abs_abs_le_abs_min", "code": "theorem min_abs_abs_le_abs_min : min |a| |b| \u2264 |min a b|", "start": [333, 1], "end": [335, 78], "kind": "commanddeclaration"}, {"full_name": "abs_max_le_max_abs_abs", "code": "theorem abs_max_le_max_abs_abs : |max a b| \u2264 max |a| |b|", "start": [338, 1], "end": [340, 72], "kind": "commanddeclaration"}, {"full_name": "abs_min_le_max_abs_abs", "code": "theorem abs_min_le_max_abs_abs : |min a b| \u2264 max |a| |b|", "start": [343, 1], "end": [345, 65], "kind": "commanddeclaration"}, {"full_name": "eq_of_abs_sub_eq_zero", "code": "theorem eq_of_abs_sub_eq_zero {a b : \u03b1} (h : |a - b| = 0) : a = b", "start": [348, 1], "end": [349, 35], "kind": "commanddeclaration"}, {"full_name": "abs_sub_le", "code": "theorem abs_sub_le (a b c : \u03b1) : |a - c| \u2264 |a - b| + |b - c|", "start": [352, 1], "end": [355, 41], "kind": "commanddeclaration"}, {"full_name": "abs_add_three", "code": "theorem abs_add_three (a b c : \u03b1) : |a + b + c| \u2264 |a| + |b| + |c|", "start": [358, 1], "end": [359, 57], "kind": "commanddeclaration"}, {"full_name": "dist_bdd_within_interval", "code": "theorem dist_bdd_within_interval {a b lb ub : \u03b1} (hal : lb \u2264 a) (hau : a \u2264 ub) (hbl : lb \u2264 b)\n    (hbu : b \u2264 ub) : |a - b| \u2264 ub - lb", "start": [362, 1], "end": [364, 60], "kind": "commanddeclaration"}, {"full_name": "eq_of_abs_sub_nonpos", "code": "theorem eq_of_abs_sub_nonpos (h : |a - b| \u2264 0) : a = b", "start": [367, 1], "end": [368, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/CharZero.lean", "imports": ["Mathlib/Algebra/CharZero/Defs.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StrictOrderedSemiring.to_charZero", "code": "instance (priority := 100) StrictOrderedSemiring.to_charZero [StrictOrderedSemiring \u03b1] :\n    CharZero \u03b1 :=\n  \u27e8StrictMono.injective <|\n      strictMono_nat_of_lt_succ fun n => by\n        rw [Nat.cast_succ]\n        apply lt_add_one\u27e9", "start": [19, 1], "end": [24, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Basic.lean", "Mathlib/Order/Monotone/Basic.lean", "Mathlib/Data/Int/Cast/Basic.lean", "Mathlib/Init/Data/Int/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.instNontrivialInt", "code": "instance instNontrivialInt : Nontrivial \u2124 := \u27e8\u27e80, 1, Int.zero_ne_one\u27e9\u27e9", "start": [27, 1], "end": [27, 71], "kind": "commanddeclaration"}, {"full_name": "Int.instCommRingInt", "code": "instance instCommRingInt : CommRing \u2124 where\n  zero_mul := Int.zero_mul\n  mul_zero := Int.mul_zero\n  mul_comm := Int.mul_comm\n  left_distrib := Int.mul_add\n  right_distrib := Int.add_mul\n  mul_one := Int.mul_one\n  one_mul := Int.one_mul\n  npow n x := x ^ n\n  npow_zero _ := rfl\n  npow_succ _ _ := by rw [Int.mul_comm]; rfl\n  mul_assoc := Int.mul_assoc\n  add_comm := Int.add_comm\n  add_assoc := Int.add_assoc\n  add_zero := Int.add_zero\n  zero_add := Int.zero_add\n  add_left_neg := Int.add_left_neg\n  nsmul := (\u00b7*\u00b7)\n  nsmul_zero := Int.zero_mul\n  nsmul_succ n x :=\n    show (n + 1 : \u2124) * x = x + n * x\n    by rw [Int.add_mul, Int.add_comm, Int.one_mul]\n  zsmul := (\u00b7*\u00b7)\n  zsmul_zero' := Int.zero_mul\n  zsmul_succ' m n := by\n    simp only [ofNat_eq_coe, ofNat_succ, Int.add_mul, Int.add_comm, Int.one_mul]\n  zsmul_neg' m n := by simp only [negSucc_coe, ofNat_succ, Int.neg_mul]\n  sub_eq_add_neg _ _ := Int.sub_eq_add_neg\n  natCast := (\u00b7)\n  natCast_zero := rfl\n  natCast_succ _ := rfl\n  intCast := (\u00b7)\n  intCast_ofNat _ := rfl\n  intCast_negSucc _ := rfl", "start": [29, 1], "end": [62, 27], "kind": "commanddeclaration"}, {"full_name": "Int.cast_id", "code": "@[simp, norm_cast] lemma cast_id : Int.cast n = n := rfl", "start": [64, 1], "end": [64, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Int.cast_mul", "code": "@[simp, norm_cast]\ntheorem cast_mul [NonAssocRing \u03b1] : \u2200 m n, ((m * n : \u2124) : \u03b1) = m * n", "start": [66, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "Int.ofNat_eq_cast", "code": "@[simp] lemma ofNat_eq_cast : Int.ofNat n = n := rfl", "start": [77, 1], "end": [77, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Int.cast_Nat_cast", "code": "lemma cast_Nat_cast [AddGroupWithOne R] : (Int.cast (Nat.cast n) : R) = Nat.cast n :=\n  Int.cast_ofNat _", "start": [79, 1], "end": [80, 19], "kind": "mathlibtacticlemma"}, {"full_name": "Int.cast_eq_cast_iff_Nat", "code": "@[norm_cast]\nlemma cast_eq_cast_iff_Nat (m n : \u2115) : (m : \u2124) = (n : \u2124) \u2194 m = n := ofNat_inj", "start": [82, 1], "end": [83, 78], "kind": "mathlibtacticlemma"}, {"full_name": "Int.natAbs_cast", "code": "@[simp, norm_cast]\nlemma natAbs_cast (n : \u2115) : natAbs \u2191n = n := rfl", "start": [85, 1], "end": [86, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Int.coe_nat_sub", "code": "@[norm_cast]\nprotected lemma coe_nat_sub {n m : \u2115} : n \u2264 m \u2192 (\u2191(m - n) : \u2124) = \u2191m - \u2191n := ofNat_sub", "start": [88, 1], "end": [89, 86], "kind": "mathlibtacticlemma"}, {"full_name": "zpow_coe_nat", "code": "@[to_additive (attr := simp, norm_cast) coe_nat_zsmul]\ntheorem _root_.zpow_coe_nat [DivInvMonoid G] (a : G) (n : \u2115) : a ^ (Nat.cast n : \u2124) = a ^ n", "start": [91, 1], "end": [93, 16], "kind": "commanddeclaration"}, {"full_name": "Int.instRingInt", "code": "instance instRingInt : Ring \u2124             := by infer_instance", "start": [113, 1], "end": [113, 63], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_inj'", "code": "theorem coe_nat_inj' {m n : \u2115} : (\u2191m : \u2124) = \u2191n \u2194 m = n", "start": [126, 1], "end": [126, 72], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_strictMono", "code": "theorem coe_nat_strictMono : StrictMono (\u00b7 : \u2115 \u2192 \u2124)", "start": [129, 1], "end": [129, 80], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_nonneg", "code": "theorem coe_nat_nonneg (n : \u2115) : 0 \u2264 (n : \u2124)", "start": [132, 1], "end": [132, 75], "kind": "commanddeclaration"}, {"full_name": "Int.sign_coe_add_one", "code": "@[simp]\ntheorem sign_coe_add_one (n : \u2115) : Int.sign (n + 1) = 1", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Int.sign_negSucc", "code": "@[simp]\ntheorem sign_negSucc (n : \u2115) : Int.sign -[n+1] = -1", "start": [143, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Int.succ", "code": "def succ (a : \u2124) := a + 1", "start": [150, 1], "end": [151, 26], "kind": "commanddeclaration"}, {"full_name": "Int.pred", "code": "def pred (a : \u2124) := a - 1", "start": [154, 1], "end": [155, 26], "kind": "commanddeclaration"}, {"full_name": "Int.nat_succ_eq_int_succ", "code": "theorem nat_succ_eq_int_succ (n : \u2115) : (Nat.succ n : \u2124) = Int.succ n", "start": [158, 1], "end": [158, 76], "kind": "commanddeclaration"}, {"full_name": "Int.pred_succ", "code": "theorem pred_succ (a : \u2124) : pred (succ a) = a", "start": [161, 1], "end": [161, 68], "kind": "commanddeclaration"}, {"full_name": "Int.succ_pred", "code": "theorem succ_pred (a : \u2124) : succ (pred a) = a", "start": [164, 1], "end": [164, 68], "kind": "commanddeclaration"}, {"full_name": "Int.neg_succ", "code": "theorem neg_succ (a : \u2124) : -succ a = pred (-a)", "start": [167, 1], "end": [167, 62], "kind": "commanddeclaration"}, {"full_name": "Int.succ_neg_succ", "code": "theorem succ_neg_succ (a : \u2124) : succ (-succ a) = -a", "start": [170, 1], "end": [170, 83], "kind": "commanddeclaration"}, {"full_name": "Int.neg_pred", "code": "theorem neg_pred (a : \u2124) : -pred a = succ (-a)", "start": [173, 1], "end": [174, 53], "kind": "commanddeclaration"}, {"full_name": "Int.pred_neg_pred", "code": "theorem pred_neg_pred (a : \u2124) : pred (-pred a) = -a", "start": [177, 1], "end": [177, 83], "kind": "commanddeclaration"}, {"full_name": "Int.pred_nat_succ", "code": "theorem pred_nat_succ (n : \u2115) : pred (Nat.succ n) = n", "start": [180, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "Int.neg_nat_succ", "code": "theorem neg_nat_succ (n : \u2115) : -(Nat.succ n : \u2124) = pred (-n)", "start": [183, 1], "end": [183, 75], "kind": "commanddeclaration"}, {"full_name": "Int.succ_neg_nat_succ", "code": "theorem succ_neg_nat_succ (n : \u2115) : succ (-Nat.succ n) = -n", "start": [186, 1], "end": [186, 79], "kind": "commanddeclaration"}, {"full_name": "Int.coe_pred_of_pos", "code": "@[norm_cast] theorem coe_pred_of_pos {n : \u2115} (h : 0 < n) : ((n - 1 : \u2115) : \u2124) = (n : \u2124) - 1", "start": [189, 1], "end": [190, 25], "kind": "commanddeclaration"}, {"full_name": "Int.induction_on", "code": "@[elab_as_elim] protected theorem induction_on {p : \u2124 \u2192 Prop} (i : \u2124)\n    (hz : p 0) (hp : \u2200 i : \u2115, p i \u2192 p (i + 1)) (hn : \u2200 i : \u2115, p (-i) \u2192 p (-i - 1)) : p i", "start": [193, 1], "end": [204, 66], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_surjective", "code": "theorem natAbs_surjective : natAbs.Surjective", "start": [209, 1], "end": [209, 78], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_ne_zero_of_ne_zero", "code": "@[deprecated natAbs_ne_zero]\ntheorem natAbs_ne_zero_of_ne_zero : \u2200 {a : \u2124}, a \u2260 0 \u2192 natAbs a \u2260 0", "start": [220, 1], "end": [221, 88], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_div", "code": "@[simp, norm_cast] theorem coe_nat_div (m n : \u2115) : ((m / n : \u2115) : \u2124) = m / n", "start": [240, 1], "end": [240, 84], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_ediv", "code": "theorem coe_nat_ediv (m n : \u2115) : ((m / n : \u2115) : \u2124) = ediv m n", "start": [243, 1], "end": [243, 69], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_of_neg_of_pos", "code": "theorem ediv_of_neg_of_pos {a b : \u2124} (Ha : a < 0) (Hb : 0 < b) : ediv a b = -((-a - 1) / b + 1)", "start": [249, 1], "end": [252, 76], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_mod", "code": "@[simp, norm_cast] theorem coe_nat_mod (m n : \u2115) : (\u2191(m % n) : \u2124) = \u2191m % \u2191n", "start": [264, 1], "end": [264, 83], "kind": "commanddeclaration"}, {"full_name": "Int.sign_coe_nat_of_nonzero", "code": "theorem sign_coe_nat_of_nonzero {n : \u2115} (hn : n \u2260 0) : Int.sign n = 1", "start": [290, 1], "end": [290, 98], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_coe_nat", "code": "@[simp] theorem toNat_coe_nat (n : \u2115) : toNat \u2191n = n", "start": [304, 1], "end": [304, 60], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_coe_nat_add_one", "code": "@[simp] theorem toNat_coe_nat_add_one {n : \u2115} : ((n : \u2124) + 1).toNat = n + 1", "start": [307, 1], "end": [307, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Infix.lean", "imports": ["Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.prefix_rfl", "code": "theorem prefix_rfl : l <+: l", "start": [56, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "List.suffix_rfl", "code": "theorem suffix_rfl : l <:+ l", "start": [60, 1], "end": [61, 16], "kind": "commanddeclaration"}, {"full_name": "List.infix_rfl", "code": "theorem infix_rfl : l <:+: l", "start": [64, 1], "end": [65, 15], "kind": "commanddeclaration"}, {"full_name": "List.prefix_concat", "code": "theorem prefix_concat (a : \u03b1) (l) : l <+: concat l a", "start": [70, 1], "end": [70, 64], "kind": "commanddeclaration"}, {"full_name": "List.isSuffix.reverse", "code": "alias \u27e8_, isSuffix.reverse\u27e9 := reverse_prefix", "start": [88, 1], "end": [88, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.isPrefix.reverse", "code": "alias \u27e8_, isPrefix.reverse\u27e9 := reverse_suffix", "start": [91, 1], "end": [91, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.isInfix.reverse", "code": "alias \u27e8_, isInfix.reverse\u27e9 := reverse_infix", "start": [94, 1], "end": [94, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.eq_nil_of_infix_nil", "code": "alias \u27e8eq_nil_of_infix_nil, _\u27e9 := infix_nil", "start": [104, 1], "end": [104, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.eq_nil_of_prefix_nil", "code": "alias \u27e8eq_nil_of_prefix_nil, _\u27e9 := prefix_nil", "start": [107, 1], "end": [107, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.eq_nil_of_suffix_nil", "code": "alias \u27e8eq_nil_of_suffix_nil, _\u27e9 := suffix_nil", "start": [110, 1], "end": [110, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "List.eq_of_infix_of_length_eq", "code": "theorem eq_of_infix_of_length_eq (h : l\u2081 <:+: l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [115, 1], "end": [116, 25], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_prefix_of_length_eq", "code": "theorem eq_of_prefix_of_length_eq (h : l\u2081 <+: l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [119, 1], "end": [120, 25], "kind": "commanddeclaration"}, {"full_name": "List.eq_of_suffix_of_length_eq", "code": "theorem eq_of_suffix_of_length_eq (h : l\u2081 <:+ l\u2082) : l\u2081.length = l\u2082.length \u2192 l\u2081 = l\u2082", "start": [123, 1], "end": [124, 25], "kind": "commanddeclaration"}, {"full_name": "List.dropSlice_sublist", "code": "lemma dropSlice_sublist (n m : \u2115) (l : List \u03b1) : l.dropSlice n m <+ l :=\n  calc l.dropSlice n m = take n l ++ drop m (drop n l) := by rw [dropSlice_eq, drop_drop, add_comm]\n  _ <+ take n l ++ drop n l := (Sublist.refl _).append (drop_sublist _ _)\n  _ = _ := take_append_drop _ _", "start": [145, 1], "end": [148, 32], "kind": "mathlibtacticlemma"}, {"full_name": "List.dropSlice_subset", "code": "lemma dropSlice_subset (n m : \u2115) (l : List \u03b1) : l.dropSlice n m \u2286 l :=\n  (dropSlice_sublist n m l).subset", "start": [151, 1], "end": [152, 35], "kind": "mathlibtacticlemma"}, {"full_name": "List.mem_of_mem_dropSlice", "code": "lemma mem_of_mem_dropSlice {n m : \u2115} {l : List \u03b1} {a : \u03b1} (h : a \u2208 l.dropSlice n m) : a \u2208 l :=\n  dropSlice_subset n m l h", "start": [155, 1], "end": [156, 27], "kind": "mathlibtacticlemma"}, {"full_name": "List.takeWhile_prefix", "code": "theorem takeWhile_prefix (p : \u03b1 \u2192 Bool) : l.takeWhile p <+: l", "start": [159, 1], "end": [160, 50], "kind": "commanddeclaration"}, {"full_name": "List.dropWhile_suffix", "code": "theorem dropWhile_suffix (p : \u03b1 \u2192 Bool) : l.dropWhile p <:+ l", "start": [163, 1], "end": [164, 50], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_prefix", "code": "theorem dropLast_prefix : \u2200 l : List \u03b1, l.dropLast <+: l", "start": [167, 1], "end": [169, 61], "kind": "commanddeclaration"}, {"full_name": "List.tail_suffix", "code": "theorem tail_suffix (l : List \u03b1) : tail l <:+ l", "start": [172, 1], "end": [172, 89], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_sublist", "code": "theorem dropLast_sublist (l : List \u03b1) : l.dropLast <+ l", "start": [175, 1], "end": [176, 30], "kind": "commanddeclaration"}, {"full_name": "List.tail_sublist", "code": "theorem tail_sublist (l : List \u03b1) : l.tail <+ l", "start": [179, 1], "end": [180, 26], "kind": "commanddeclaration"}, {"full_name": "List.dropLast_subset", "code": "theorem dropLast_subset (l : List \u03b1) : l.dropLast \u2286 l", "start": [183, 1], "end": [184, 30], "kind": "commanddeclaration"}, {"full_name": "List.tail_subset", "code": "theorem tail_subset (l : List \u03b1) : tail l \u2286 l", "start": [187, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_dropLast", "code": "theorem mem_of_mem_dropLast (h : a \u2208 l.dropLast) : a \u2208 l", "start": [191, 1], "end": [192, 22], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_tail", "code": "theorem mem_of_mem_tail (h : a \u2208 l.tail) : a \u2208 l", "start": [195, 1], "end": [196, 18], "kind": "commanddeclaration"}, {"full_name": "List.prefix_iff_eq_append", "code": "theorem prefix_iff_eq_append : l\u2081 <+: l\u2082 \u2194 l\u2081 ++ drop (length l\u2081) l\u2082 = l\u2082", "start": [199, 1], "end": [200, 56], "kind": "commanddeclaration"}, {"full_name": "List.suffix_iff_eq_append", "code": "theorem suffix_iff_eq_append : l\u2081 <:+ l\u2082 \u2194 take (length l\u2082 - length l\u2081) l\u2082 ++ l\u2081 = l\u2082", "start": [203, 1], "end": [205, 12], "kind": "commanddeclaration"}, {"full_name": "List.prefix_iff_eq_take", "code": "theorem prefix_iff_eq_take : l\u2081 <+: l\u2082 \u2194 l\u2081 = take (length l\u2081) l\u2082", "start": [208, 1], "end": [210, 39], "kind": "commanddeclaration"}, {"full_name": "List.suffix_iff_eq_drop", "code": "theorem suffix_iff_eq_drop : l\u2081 <:+ l\u2082 \u2194 l\u2081 = drop (length l\u2082 - length l\u2081) l\u2082", "start": [213, 1], "end": [215, 39], "kind": "commanddeclaration"}, {"full_name": "List.decidablePrefix", "code": "instance decidablePrefix [DecidableEq \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, Decidable (l\u2081 <+: l\u2082)\n  | [], l\u2082 => isTrue \u27e8l\u2082, rfl\u27e9\n  | a :: l\u2081, [] => isFalse fun \u27e8t, te\u27e9 => List.noConfusion te\n  | a :: l\u2081, b :: l\u2082 =>\n    if h : a = b then\n      @decidable_of_decidable_of_iff _ _ (decidablePrefix l\u2081 l\u2082) (by rw [\u2190 h, prefix_cons_inj])\n    else\n      isFalse fun \u27e8t, te\u27e9 => h <| by injection te", "start": [218, 1], "end": [225, 50], "kind": "commanddeclaration"}, {"full_name": "List.decidableSuffix", "code": "instance decidableSuffix [DecidableEq \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, Decidable (l\u2081 <:+ l\u2082)\n  | [], l\u2082 => isTrue \u27e8l\u2082, append_nil _\u27e9\n  | a :: l\u2081, [] => isFalse <| mt (Sublist.length_le \u2218 IsSuffix.sublist) (by simp)\n  | l\u2081, b :: l\u2082 =>\n    @decidable_of_decidable_of_iff _ _\n      (@instDecidableOr _ _ _ (l\u2081.decidableSuffix l\u2082))\n      suffix_cons_iff.symm\ntermination_by decidableSuffix l\u2081 l\u2082 => (l\u2081, l\u2082)", "start": [229, 1], "end": [236, 49], "kind": "commanddeclaration"}, {"full_name": "List.decidableInfix", "code": "instance decidableInfix [DecidableEq \u03b1] : \u2200 l\u2081 l\u2082 : List \u03b1, Decidable (l\u2081 <:+: l\u2082)\n  | [], l\u2082 => isTrue \u27e8[], l\u2082, rfl\u27e9\n  | a :: l\u2081, [] => isFalse fun \u27e8s, t, te\u27e9 => by simp at te\n  | l\u2081, b :: l\u2082 =>\n    @decidable_of_decidable_of_iff _ _\n      (@instDecidableOr _ _ (l\u2081.decidablePrefix (b :: l\u2082)) (l\u2081.decidableInfix l\u2082))\n      infix_cons_iff.symm\ntermination_by decidableInfix l\u2081 l\u2082 => (l\u2081, l\u2082)", "start": [239, 1], "end": [246, 48], "kind": "commanddeclaration"}, {"full_name": "List.prefix_take_le_iff", "code": "theorem prefix_take_le_iff {L : List (List (Option \u03b1))} (hm : m < L.length) :\n    L.take m <+: L.take n \u2194 m \u2264 n", "start": [249, 1], "end": [269, 57], "kind": "commanddeclaration"}, {"full_name": "List.cons_prefix_iff", "code": "theorem cons_prefix_iff : a :: l\u2081 <+: b :: l\u2082 \u2194 a = b \u2227 l\u2081 <+: l\u2082", "start": [272, 1], "end": [279, 26], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.map", "code": "theorem IsPrefix.map (h : l\u2081 <+: l\u2082) (f : \u03b1 \u2192 \u03b2) : l\u2081.map f <+: l\u2082.map f", "start": [282, 1], "end": [288, 61], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.filter_map", "code": "theorem IsPrefix.filter_map (h : l\u2081 <+: l\u2082) (f : \u03b1 \u2192 Option \u03b2) :\n    l\u2081.filterMap f <+: l\u2082.filterMap f", "start": [291, 1], "end": [300, 23], "kind": "commanddeclaration"}, {"full_name": "List.IsPrefix.reduceOption", "code": "theorem IsPrefix.reduceOption {l\u2081 l\u2082 : List (Option \u03b1)} (h : l\u2081 <+: l\u2082) :\n    l\u2081.reduceOption <+: l\u2082.reduceOption", "start": [303, 1], "end": [305, 18], "kind": "commanddeclaration"}, {"full_name": "List.mem_inits", "code": "@[simp]\ntheorem mem_inits : \u2200 s t : List \u03b1, s \u2208 inits t \u2194 s <+: t", "start": [331, 1], "end": [349, 75], "kind": "commanddeclaration"}, {"full_name": "List.mem_tails", "code": "@[simp]\ntheorem mem_tails : \u2200 s t : List \u03b1, s \u2208 tails t \u2194 s <:+ t", "start": [352, 1], "end": [367, 82], "kind": "commanddeclaration"}, {"full_name": "List.inits_cons", "code": "theorem inits_cons (a : \u03b1) (l : List \u03b1) : inits (a :: l) = [] :: l.inits.map fun t => a :: t", "start": [370, 1], "end": [371, 7], "kind": "commanddeclaration"}, {"full_name": "List.tails_cons", "code": "theorem tails_cons (a : \u03b1) (l : List \u03b1) : tails (a :: l) = (a :: l) :: l.tails", "start": [374, 1], "end": [374, 90], "kind": "commanddeclaration"}, {"full_name": "List.inits_append", "code": "@[simp]\ntheorem inits_append : \u2200 s t : List \u03b1, inits (s ++ t) = s.inits ++ t.inits.tail.map fun l => s ++ l", "start": [377, 1], "end": [381, 51], "kind": "commanddeclaration"}, {"full_name": "List.tails_append", "code": "@[simp]\ntheorem tails_append :\n    \u2200 s t : List \u03b1, tails (s ++ t) = (s.tails.map fun l => l ++ t) ++ t.tails.tail", "start": [384, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "List.inits_eq_tails", "code": "theorem inits_eq_tails : \u2200 l : List \u03b1, l.inits = (reverse <| map reverse <| tails <| reverse l)", "start": [393, 1], "end": [395, 70], "kind": "commanddeclaration"}, {"full_name": "List.tails_eq_inits", "code": "theorem tails_eq_inits : \u2200 l : List \u03b1, l.tails = (reverse <| map reverse <| inits <| reverse l)", "start": [398, 1], "end": [400, 58], "kind": "commanddeclaration"}, {"full_name": "List.inits_reverse", "code": "theorem inits_reverse (l : List \u03b1) : inits (reverse l) = reverse (map reverse l.tails)", "start": [403, 1], "end": [405, 51], "kind": "commanddeclaration"}, {"full_name": "List.tails_reverse", "code": "theorem tails_reverse (l : List \u03b1) : tails (reverse l) = reverse (map reverse l.inits)", "start": [408, 1], "end": [410, 51], "kind": "commanddeclaration"}, {"full_name": "List.map_reverse_inits", "code": "theorem map_reverse_inits (l : List \u03b1) : map reverse l.inits = (reverse <| tails <| reverse l)", "start": [413, 1], "end": [415, 51], "kind": "commanddeclaration"}, {"full_name": "List.map_reverse_tails", "code": "theorem map_reverse_tails (l : List \u03b1) : map reverse l.tails = (reverse <| inits <| reverse l)", "start": [418, 1], "end": [420, 51], "kind": "commanddeclaration"}, {"full_name": "List.length_tails", "code": "@[simp]\ntheorem length_tails (l : List \u03b1) : length (tails l) = length l + 1", "start": [423, 1], "end": [427, 19], "kind": "commanddeclaration"}, {"full_name": "List.length_inits", "code": "@[simp]\ntheorem length_inits (l : List \u03b1) : length (inits l) = length l + 1", "start": [430, 1], "end": [431, 96], "kind": "commanddeclaration"}, {"full_name": "List.nth_le_tails", "code": "@[simp]\ntheorem nth_le_tails (l : List \u03b1) (n : \u2115) (hn : n < length (tails l)) :\n    nthLe (tails l) n hn = l.drop n", "start": [437, 1], "end": [444, 37], "kind": "commanddeclaration"}, {"full_name": "List.nth_le_inits", "code": "@[simp]\ntheorem nth_le_inits (l : List \u03b1) (n : \u2115) (hn : n < length (inits l)) :\n    nthLe (inits l) n hn = l.take n", "start": [447, 1], "end": [454, 37], "kind": "commanddeclaration"}, {"full_name": "List.insert_nil", "code": "@[simp]\ntheorem insert_nil (a : \u03b1) : insert a nil = [a]", "start": [467, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "List.insert.def", "code": "theorem insert.def (a : \u03b1) (l : List \u03b1) : insert a l = if a \u2208 l then l else a :: l", "start": [472, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "List.suffix_insert", "code": "@[simp]\ntheorem suffix_insert (a : \u03b1) (l : List \u03b1) : l <:+ l.insert a", "start": [480, 1], "end": [484, 57], "kind": "commanddeclaration"}, {"full_name": "List.infix_insert", "code": "theorem infix_insert (a : \u03b1) (l : List \u03b1) : l <:+: l.insert a", "start": [487, 1], "end": [488, 30], "kind": "commanddeclaration"}, {"full_name": "List.sublist_insert", "code": "theorem sublist_insert (a : \u03b1) (l : List \u03b1) : l <+ l.insert a", "start": [491, 1], "end": [492, 30], "kind": "commanddeclaration"}, {"full_name": "List.subset_insert", "code": "theorem subset_insert (a : \u03b1) (l : List \u03b1) : l \u2286 l.insert a", "start": [495, 1], "end": [496, 30], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_mem_suffix", "code": "theorem mem_of_mem_suffix (hx : a \u2208 l\u2081) (hl : l\u2081 <:+ l\u2082) : a \u2208 l\u2082", "start": [507, 1], "end": [508, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Units/Basic.lean", "imports": ["Mathlib/Tactic/Contrapose.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Logic/Nontrivial/Basic.lean"], "premises": [{"full_name": "Units.ne_zero", "code": "@[simp]\ntheorem ne_zero [Nontrivial M\u2080] (u : M\u2080\u02e3) : (u : M\u2080) \u2260 0", "start": [29, 1], "end": [33, 39], "kind": "commanddeclaration"}, {"full_name": "Units.mul_left_eq_zero", "code": "@[simp]\ntheorem mul_left_eq_zero (u : M\u2080\u02e3) {a : M\u2080} : a * u = 0 \u2194 a = 0", "start": [38, 1], "end": [40, 89], "kind": "commanddeclaration"}, {"full_name": "Units.mul_right_eq_zero", "code": "@[simp]\ntheorem mul_right_eq_zero (u : M\u2080\u02e3) {a : M\u2080} : \u2191u * a = 0 \u2194 a = 0", "start": [43, 1], "end": [45, 89], "kind": "commanddeclaration"}, {"full_name": "IsUnit.ne_zero", "code": "theorem ne_zero [Nontrivial M\u2080] {a : M\u2080} (ha : IsUnit a) : a \u2260 0", "start": [52, 1], "end": [54, 17], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_right_eq_zero", "code": "theorem mul_right_eq_zero {a b : M\u2080} (ha : IsUnit a) : a * b = 0 \u2194 b = 0", "start": [57, 1], "end": [59, 27], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mul_left_eq_zero", "code": "theorem mul_left_eq_zero {a b : M\u2080} (hb : IsUnit b) : a * b = 0 \u2194 a = 0", "start": [62, 1], "end": [64, 26], "kind": "commanddeclaration"}, {"full_name": "isUnit_zero_iff", "code": "@[simp]\ntheorem isUnit_zero_iff : IsUnit (0 : M\u2080) \u2194 (0 : M\u2080) = 1", "start": [69, 1], "end": [72, 67], "kind": "commanddeclaration"}, {"full_name": "not_isUnit_zero", "code": "theorem not_isUnit_zero [Nontrivial M\u2080] : \u00acIsUnit (0 : M\u2080)", "start": [76, 1], "end": [77, 35], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse", "code": "noncomputable def inverse : M\u2080 \u2192 M\u2080 := fun x => if h : IsUnit x then ((h.unit\u207b\u00b9 : M\u2080\u02e3) : M\u2080) else 0", "start": [84, 1], "end": [90, 100], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_unit", "code": "@[simp]\ntheorem inverse_unit (u : M\u2080\u02e3) : inverse (u : M\u2080) = (u\u207b\u00b9 : M\u2080\u02e3)", "start": [93, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_non_unit", "code": "@[simp]\ntheorem inverse_non_unit (x : M\u2080) (h : \u00acIsUnit x) : inverse x = 0", "start": [99, 1], "end": [102, 12], "kind": "commanddeclaration"}, {"full_name": "Ring.mul_inverse_cancel", "code": "theorem mul_inverse_cancel (x : M\u2080) (h : IsUnit x) : x * inverse x = 1", "start": [105, 1], "end": [107, 35], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_mul_cancel", "code": "theorem inverse_mul_cancel (x : M\u2080) (h : IsUnit x) : inverse x * x = 1", "start": [110, 1], "end": [112, 35], "kind": "commanddeclaration"}, {"full_name": "Ring.mul_inverse_cancel_right", "code": "theorem mul_inverse_cancel_right (x y : M\u2080) (h : IsUnit x) : y * x * inverse x = y", "start": [115, 1], "end": [116, 50], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_mul_cancel_right", "code": "theorem inverse_mul_cancel_right (x y : M\u2080) (h : IsUnit x) : y * inverse x * x = y", "start": [119, 1], "end": [120, 50], "kind": "commanddeclaration"}, {"full_name": "Ring.mul_inverse_cancel_left", "code": "theorem mul_inverse_cancel_left (x y : M\u2080) (h : IsUnit x) : x * (inverse x * y) = y", "start": [123, 1], "end": [124, 52], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_mul_cancel_left", "code": "theorem inverse_mul_cancel_left (x y : M\u2080) (h : IsUnit x) : inverse x * (x * y) = y", "start": [127, 1], "end": [128, 52], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_mul_eq_iff_eq_mul", "code": "theorem inverse_mul_eq_iff_eq_mul (x y z : M\u2080) (h : IsUnit x) : inverse x * y = z \u2194 y = x * z", "start": [131, 1], "end": [133, 55], "kind": "commanddeclaration"}, {"full_name": "Ring.eq_mul_inverse_iff_mul_eq", "code": "theorem eq_mul_inverse_iff_mul_eq (x y z : M\u2080) (h : IsUnit z) : x = y * inverse z \u2194 x * z = y", "start": [136, 1], "end": [138, 58], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_one", "code": "@[simp]\ntheorem inverse_one : inverse (1 : M\u2080) = 1", "start": [143, 1], "end": [145, 17], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_zero", "code": "@[simp]\ntheorem inverse_zero : inverse (0 : M\u2080) = 0", "start": [148, 1], "end": [151, 43], "kind": "commanddeclaration"}, {"full_name": "IsUnit.ring_inverse", "code": "theorem IsUnit.ring_inverse {a : M\u2080} : IsUnit a \u2192 IsUnit (Ring.inverse a)", "start": [158, 1], "end": [159, 54], "kind": "commanddeclaration"}, {"full_name": "isUnit_ring_inverse", "code": "@[simp]\ntheorem isUnit_ring_inverse {a : M\u2080} : IsUnit (Ring.inverse a) \u2194 IsUnit a", "start": [162, 1], "end": [171, 25], "kind": "commanddeclaration"}, {"full_name": "Units.mk0", "code": "def mk0 (a : G\u2080) (ha : a \u2260 0) : G\u2080\u02e3 :=\n  \u27e8a, a\u207b\u00b9, mul_inv_cancel ha, inv_mul_cancel ha\u27e9", "start": [180, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "Units.mk0_one", "code": "@[simp]\ntheorem mk0_one (h := one_ne_zero) : mk0 (1 : G\u2080) h = 1", "start": [188, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Units.val_mk0", "code": "@[simp]\ntheorem val_mk0 {a : G\u2080} (h : a \u2260 0) : (mk0 a h : G\u2080) = a", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Units.mk0_val", "code": "@[simp]\ntheorem mk0_val (u : G\u2080\u02e3) (h : (u : G\u2080) \u2260 0) : mk0 (u : G\u2080) h = u", "start": [199, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "Units.mul_inv'", "code": "theorem mul_inv' (u : G\u2080\u02e3) : u * (u : G\u2080)\u207b\u00b9 = 1", "start": [205, 1], "end": [206, 27], "kind": "commanddeclaration"}, {"full_name": "Units.inv_mul'", "code": "theorem inv_mul' (u : G\u2080\u02e3) : (u\u207b\u00b9 : G\u2080) * u = 1", "start": [210, 1], "end": [211, 27], "kind": "commanddeclaration"}, {"full_name": "Units.mk0_inj", "code": "@[simp]\ntheorem mk0_inj {a b : G\u2080} (ha : a \u2260 0) (hb : b \u2260 0) : Units.mk0 a ha = Units.mk0 b hb \u2194 a = b", "start": [214, 1], "end": [216, 50], "kind": "commanddeclaration"}, {"full_name": "Units.exists0", "code": "theorem exists0 {p : G\u2080\u02e3 \u2192 Prop} : (\u2203 g : G\u2080\u02e3, p g) \u2194 \u2203 (g : G\u2080) (hg : g \u2260 0), p (Units.mk0 g hg)", "start": [219, 1], "end": [222, 43], "kind": "commanddeclaration"}, {"full_name": "Units.exists0'", "code": "theorem exists0' {p : \u2200 g : G\u2080, g \u2260 0 \u2192 Prop} :\n    (\u2203 (g : G\u2080) (hg : g \u2260 0), p g hg) \u2194 \u2203 g : G\u2080\u02e3, p g g.ne_zero", "start": [225, 1], "end": [229, 48], "kind": "commanddeclaration"}, {"full_name": "Units.exists_iff_ne_zero", "code": "@[simp]\ntheorem exists_iff_ne_zero {x : G\u2080} : (\u2203 u : G\u2080\u02e3, \u2191u = x) \u2194 x \u2260 0", "start": [233, 1], "end": [234, 87], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.eq_zero_or_unit", "code": "theorem _root_.GroupWithZero.eq_zero_or_unit (a : G\u2080) : a = 0 \u2228 \u2203 u : G\u2080\u02e3, a = u", "start": [237, 1], "end": [242, 62], "kind": "commanddeclaration"}, {"full_name": "IsUnit.mk0", "code": "theorem IsUnit.mk0 (x : G\u2080) (hx : x \u2260 0) : IsUnit x", "start": [251, 1], "end": [252, 26], "kind": "commanddeclaration"}, {"full_name": "isUnit_iff_ne_zero", "code": "theorem isUnit_iff_ne_zero : IsUnit a \u2194 a \u2260 0", "start": [255, 1], "end": [256, 27], "kind": "commanddeclaration"}, {"full_name": "Ne.isUnit", "code": "alias \u27e8_, Ne.isUnit\u27e9 := isUnit_iff_ne_zero", "start": [259, 1], "end": [259, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "GroupWithZero.noZeroDivisors", "code": "instance (priority := 10) GroupWithZero.noZeroDivisors : NoZeroDivisors G\u2080 :=\n  { (\u2039_\u203a : GroupWithZero G\u2080) with\n    eq_zero_or_eq_zero_of_mul_eq_zero := @fun a b h => by\n      contrapose! h\n      exact (Units.mk0 a h.1 * Units.mk0 b h.2).ne_zero }", "start": [267, 1], "end": [271, 58], "kind": "commanddeclaration"}, {"full_name": "Units.mk0_mul", "code": "@[simp]\ntheorem Units.mk0_mul (x y : G\u2080) (hxy) :\n    Units.mk0 (x * y) hxy =\n      Units.mk0 x (mul_ne_zero_iff.mp hxy).1 * Units.mk0 y (mul_ne_zero_iff.mp hxy).2", "start": [276, 1], "end": [280, 11], "kind": "commanddeclaration"}, {"full_name": "div_ne_zero", "code": "theorem div_ne_zero (ha : a \u2260 0) (hb : b \u2260 0) : a / b \u2260 0", "start": [283, 1], "end": [285, 40], "kind": "commanddeclaration"}, {"full_name": "div_eq_zero_iff", "code": "@[simp]\ntheorem div_eq_zero_iff : a / b = 0 \u2194 a = 0 \u2228 b = 0", "start": [288, 1], "end": [289, 80], "kind": "commanddeclaration"}, {"full_name": "div_ne_zero_iff", "code": "theorem div_ne_zero_iff : a / b \u2260 0 \u2194 a \u2260 0 \u2227 b \u2260 0", "start": [292, 1], "end": [293, 35], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_eq_inv", "code": "theorem Ring.inverse_eq_inv (a : G\u2080) : Ring.inverse a = a\u207b\u00b9", "start": [296, 1], "end": [299, 45], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_eq_inv'", "code": "@[simp]\ntheorem Ring.inverse_eq_inv' : (Ring.inverse : G\u2080 \u2192 G\u2080) = Inv.inv", "start": [302, 1], "end": [304, 29], "kind": "commanddeclaration"}, {"full_name": "CommGroupWithZero.toCancelCommMonoidWithZero", "code": "instance (priority := 10) CommGroupWithZero.toCancelCommMonoidWithZero :\n    CancelCommMonoidWithZero G\u2080 :=\n  { GroupWithZero.toCancelMonoidWithZero,\n    CommGroupWithZero.toCommMonoidWithZero with }", "start": [315, 1], "end": [318, 50], "kind": "commanddeclaration"}, {"full_name": "CommGroupWithZero.toDivisionCommMonoid", "code": "instance (priority := 100) CommGroupWithZero.toDivisionCommMonoid : DivisionCommMonoid G\u2080 :=\n  { \u2039CommGroupWithZero G\u2080\u203a, GroupWithZero.toDivisionMonoid with }", "start": [322, 1], "end": [323, 66], "kind": "commanddeclaration"}, {"full_name": "groupWithZeroOfIsUnitOrEqZero", "code": "noncomputable def groupWithZeroOfIsUnitOrEqZero [hM : MonoidWithZero M]\n    (h : \u2200 a : M, IsUnit a \u2228 a = 0) : GroupWithZero M :=\n  { hM with\n    inv := fun a => if h0 : a = 0 then 0 else \u2191((h a).resolve_right h0).unit\u207b\u00b9,\n    inv_zero := dif_pos rfl,\n    mul_inv_cancel := fun a h0 => by\n      change (a * if h0 : a = 0 then 0 else \u2191((h a).resolve_right h0).unit\u207b\u00b9) = 1\n      rw [dif_neg h0, Units.mul_inv_eq_iff_eq_mul, one_mul, IsUnit.unit_spec],\n    exists_pair_ne := Nontrivial.exists_pair_ne }", "start": [334, 1], "end": [344, 50], "kind": "commanddeclaration"}, {"full_name": "commGroupWithZeroOfIsUnitOrEqZero", "code": "noncomputable def commGroupWithZeroOfIsUnitOrEqZero [hM : CommMonoidWithZero M]\n    (h : \u2200 a : M, IsUnit a \u2228 a = 0) : CommGroupWithZero M :=\n  { groupWithZeroOfIsUnitOrEqZero h, hM with }", "start": [347, 1], "end": [351, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Semiconj/Units.lean", "imports": ["Mathlib/Algebra/Group/Units.lean", "Mathlib/Algebra/Group/Semiconj/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy.units_inv_right", "code": "@[to_additive \"If `a` semiconjugates an additive unit `x` to an additive unit `y`, then it\nsemiconjugates `-x` to `-y`.\"]\ntheorem units_inv_right {a : M} {x y : M\u02e3} (h : SemiconjBy a x y) : SemiconjBy a \u2191x\u207b\u00b9 \u2191y\u207b\u00b9", "start": [40, 1], "end": [46, 94], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_inv_right_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_inv_right_iff {a : M} {x y : M\u02e3} : SemiconjBy a \u2191x\u207b\u00b9 \u2191y\u207b\u00b9 \u2194 SemiconjBy a x y", "start": [50, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_inv_symm_left", "code": "@[to_additive \"If an additive unit `a` semiconjugates `x` to `y`, then `-a` semiconjugates `y` to\n`x`.\"]\ntheorem units_inv_symm_left {a : M\u02e3} {x y : M} (h : SemiconjBy (\u2191a) x y) : SemiconjBy (\u2191a\u207b\u00b9) y x", "start": [56, 1], "end": [62, 75], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_inv_symm_left_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_inv_symm_left_iff {a : M\u02e3} {x y : M} : SemiconjBy (\u2191a\u207b\u00b9) y x \u2194 SemiconjBy (\u2191a) x y", "start": [66, 1], "end": [68, 45], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_val", "code": "@[to_additive]\ntheorem units_val {a x y : M\u02e3} (h : SemiconjBy a x y) : SemiconjBy (a : M) x y", "start": [72, 1], "end": [74, 24], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_of_val", "code": "@[to_additive]\ntheorem units_of_val {a x y : M\u02e3} (h : SemiconjBy (a : M) x y) : SemiconjBy a x y", "start": [78, 1], "end": [80, 14], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.units_val_iff", "code": "@[to_additive (attr := simp)]\ntheorem units_val_iff {a x y : M\u02e3} : SemiconjBy (a : M) x y \u2194 SemiconjBy a x y", "start": [84, 1], "end": [86, 28], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_right_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_right_iff : SemiconjBy a x\u207b\u00b9 y\u207b\u00b9 \u2194 SemiconjBy a x y", "start": [96, 1], "end": [99, 45], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_right", "code": "@[to_additive]\ntheorem inv_right : SemiconjBy a x y \u2192 SemiconjBy a x\u207b\u00b9 y\u207b\u00b9", "start": [103, 1], "end": [105, 18], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_symm_left_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_symm_left_iff : SemiconjBy a\u207b\u00b9 y x \u2194 SemiconjBy a x y", "start": [109, 1], "end": [111, 76], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.inv_symm_left", "code": "@[to_additive]\ntheorem inv_symm_left : SemiconjBy a x y \u2192 SemiconjBy a\u207b\u00b9 y x", "start": [115, 1], "end": [117, 22], "kind": "commanddeclaration"}, {"full_name": "Units.mk_semiconjBy", "code": "@[to_additive AddUnits.mk_addSemiconjBy \"`a` semiconjugates `x` to `a + x + -a`.\"]\ntheorem Units.mk_semiconjBy [Monoid M] (u : M\u02e3) (x : M) : SemiconjBy (\u2191u) x (u * x * \u2191u\u207b\u00b9)", "start": [125, 1], "end": [128, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Classical.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/IrreducibleDef.lean", "Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Classical.axiom_of_choice", "code": "alias axiom_of_choice := axiomOfChoice", "start": [20, 1], "end": [20, 39], "kind": "stdtacticaliasalias"}, {"full_name": "Classical.prop_complete", "code": "alias prop_complete := propComplete", "start": [21, 1], "end": [21, 36], "kind": "stdtacticaliasalias"}, {"full_name": "Classical.cases_true_false", "code": "@[elab_as_elim] theorem cases_true_false (p : Prop \u2192 Prop)\n    (h1 : p True) (h2 : p False) (a : Prop) : p a", "start": [23, 1], "end": [25, 97], "kind": "commanddeclaration"}, {"full_name": "Classical.cases_on", "code": "theorem cases_on (a : Prop) {p : Prop \u2192 Prop} (h1 : p True) (h2 : p False) : p a", "start": [27, 1], "end": [28, 30], "kind": "commanddeclaration"}, {"full_name": "Classical.cases", "code": "theorem cases {p : Prop \u2192 Prop} (h1 : p True) (h2 : p False) (a) : p a", "start": [30, 1], "end": [30, 91], "kind": "commanddeclaration"}, {"full_name": "Classical.by_cases", "code": "alias by_cases := byCases", "start": [33, 1], "end": [33, 26], "kind": "stdtacticaliasalias"}, {"full_name": "Classical.by_contradiction", "code": "alias by_contradiction := byContradiction", "start": [34, 1], "end": [34, 42], "kind": "stdtacticaliasalias"}, {"full_name": "Classical.eq_false_or_eq_true", "code": "theorem eq_false_or_eq_true (a : Prop) : a = False \u2228 a = True", "start": [36, 1], "end": [36, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/InjSurj.lean", "imports": ["Mathlib/Algebra/GroupWithZero/InjSurj.lean", "Mathlib/Algebra/Opposites.lean", "Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.distrib", "code": "@[reducible]\nprotected def Function.Injective.distrib {S} [Mul R] [Add R] [Distrib S] (f : R \u2192 S)\n    (hf : Injective f) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y) :\n    Distrib R where\n  mul := (\u00b7 * \u00b7)\n  add := (\u00b7 + \u00b7)\n  left_distrib x y z := hf <| by simp only [*, left_distrib]\n  right_distrib x y z := hf <| by simp only [*, right_distrib]", "start": [29, 1], "end": [38, 63], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.distrib", "code": "@[reducible]\nprotected def Function.Surjective.distrib {S} [Distrib R] [Add S] [Mul S] (f : R \u2192 S)\n    (hf : Surjective f) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y) :\n    Distrib S where\n  mul := (\u00b7 * \u00b7)\n  add := (\u00b7 + \u00b7)\n  left_distrib := hf.forall\u2083.2 fun x y z => by simp only [\u2190 add, \u2190 mul, left_distrib]\n  right_distrib := hf.forall\u2083.2 fun x y z => by simp only [\u2190 add, \u2190 mul, right_distrib]", "start": [41, 1], "end": [50, 88], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalNonAssocSemiring", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalNonAssocSemiring {\u03b1 : Type u}\n    [NonUnitalNonAssocSemiring \u03b1] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) : NonUnitalNonAssocSemiring \u03b2 :=\n  { hf.mulZeroClass f zero mul, hf.addCommMonoid f zero add nsmul, hf.distrib f add mul with }", "start": [62, 1], "end": [69, 95], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalSemiring", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalSemiring {\u03b1 : Type u} [NonUnitalSemiring \u03b1] (f : \u03b2 \u2192 \u03b1)\n    (hf : Injective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalSemiring \u03b2 :=\n  { hf.nonUnitalNonAssocSemiring f zero add mul nsmul, hf.semigroupWithZero f zero mul with }", "start": [72, 1], "end": [79, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonAssocSemiring", "code": "@[reducible]\nprotected def Function.Injective.nonAssocSemiring {\u03b1 : Type u} [NonAssocSemiring \u03b1] {\u03b2 : Type v}\n    [Zero \u03b2] [One \u03b2] [Mul \u03b2] [Add \u03b2] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : NonAssocSemiring \u03b2 :=\n  { hf.addMonoidWithOne f zero one add nsmul nat_cast,\n    hf.nonUnitalNonAssocSemiring f zero add mul nsmul,\n    hf.mulOneClass f one mul with }", "start": [82, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.semiring", "code": "@[reducible]\nprotected def Function.Injective.semiring {\u03b1 : Type u} [Semiring \u03b1] {\u03b2 : Type v} [Zero \u03b2] [One \u03b2]\n    [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : Semiring \u03b2 :=\n  { hf.nonAssocSemiring f zero one add mul nsmul nat_cast,\n    hf.monoidWithZero f zero one mul npow,\n    hf.distrib f add mul with }", "start": [95, 1], "end": [105, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalNonAssocSemiring", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalNonAssocSemiring {\u03b1 : Type u}\n    [NonUnitalNonAssocSemiring \u03b1] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) : NonUnitalNonAssocSemiring \u03b2 :=\n  { hf.mulZeroClass f zero mul, hf.addCommMonoid f zero add nsmul, hf.distrib f add mul with }", "start": [108, 1], "end": [115, 95], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalSemiring", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalSemiring {\u03b1 : Type u} [NonUnitalSemiring \u03b1] (f : \u03b1 \u2192 \u03b2)\n    (hf : Surjective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalSemiring \u03b2 :=\n  { hf.nonUnitalNonAssocSemiring f zero add mul nsmul, hf.semigroupWithZero f zero mul with }", "start": [118, 1], "end": [125, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonAssocSemiring", "code": "@[reducible]\nprotected def Function.Surjective.nonAssocSemiring {\u03b1 : Type u} [NonAssocSemiring \u03b1] {\u03b2 : Type v}\n    [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) : NonAssocSemiring \u03b2 :=\n  { hf.addMonoidWithOne f zero one add nsmul nat_cast,\n    hf.nonUnitalNonAssocSemiring f zero add mul nsmul,\n    hf.mulOneClass f one mul with }", "start": [128, 1], "end": [138, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.semiring", "code": "@[reducible]\nprotected def Function.Surjective.semiring {\u03b1 : Type u} [Semiring \u03b1] {\u03b2 : Type v} [Zero \u03b2] [One \u03b2]\n    [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n) : Semiring \u03b2 :=\n  { hf.nonAssocSemiring f zero one add mul nsmul nat_cast,\n    hf.monoidWithZero f zero one mul npow,\n    hf.addCommMonoid f zero add nsmul,\n    hf.distrib f add mul with }", "start": [141, 1], "end": [152, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalCommSemiring", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalCommSemiring [Zero \u03b3] [Add \u03b3] [Mul \u03b3] [SMul \u2115 \u03b3]\n    (f : \u03b3 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalCommSemiring \u03b3 :=\n  { hf.nonUnitalSemiring f zero add mul nsmul, hf.commSemigroup f mul with }", "start": [161, 1], "end": [168, 77], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalCommSemiring", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalCommSemiring [Zero \u03b3] [Add \u03b3] [Mul \u03b3] [SMul \u2115 \u03b3]\n    (f : \u03b1 \u2192 \u03b3) (hf : Surjective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalCommSemiring \u03b3 :=\n  { hf.nonUnitalSemiring f zero add mul nsmul, hf.commSemigroup f mul with }", "start": [171, 1], "end": [178, 77], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commSemiring", "code": "@[reducible]\nprotected def Function.Injective.commSemiring [Zero \u03b3] [One \u03b3] [Add \u03b3] [Mul \u03b3] [SMul \u2115 \u03b3]\n    [NatCast \u03b3] [Pow \u03b3 \u2115] (f : \u03b3 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : CommSemiring \u03b3 :=\n  { hf.semiring f zero one add mul nsmul npow nat_cast, hf.commSemigroup f mul with }", "start": [187, 1], "end": [195, 86], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commSemiring", "code": "@[reducible]\nprotected def Function.Surjective.commSemiring [Zero \u03b3] [One \u03b3] [Add \u03b3] [Mul \u03b3] [SMul \u2115 \u03b3]\n    [NatCast \u03b3] [Pow \u03b3 \u2115] (f : \u03b1 \u2192 \u03b3) (hf : Surjective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : CommSemiring \u03b3 :=\n  { hf.semiring f zero one add mul nsmul npow nat_cast, hf.commSemigroup f mul with }", "start": [198, 1], "end": [206, 86], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.hasDistribNeg", "code": "@[reducible]\nprotected def Function.Injective.hasDistribNeg [Neg \u03b2] [Mul \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (neg : \u2200 a, f (-a) = -f a) (mul : \u2200 a b, f (a * b) = f a * f b) : HasDistribNeg \u03b2 :=\n  { hf.involutiveNeg _ neg, \u2039Mul \u03b2\u203a with\n    neg_mul := fun x y => hf <| by erw [neg, mul, neg, neg_mul, mul],\n    mul_neg := fun x y => hf <| by erw [neg, mul, neg, mul_neg, mul] }", "start": [218, 1], "end": [225, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.hasDistribNeg", "code": "@[reducible]\nprotected def Function.Surjective.hasDistribNeg [Neg \u03b2] [Mul \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f)\n    (neg : \u2200 a, f (-a) = -f a) (mul : \u2200 a b, f (a * b) = f a * f b) : HasDistribNeg \u03b2 :=\n  { hf.involutiveNeg _ neg, \u2039Mul \u03b2\u203a with\n    neg_mul := hf.forall\u2082.2 fun x y => by erw [\u2190 neg, \u2190 mul, neg_mul, neg, mul]\n    mul_neg := hf.forall\u2082.2 fun x y => by erw [\u2190 neg, \u2190 mul, mul_neg, neg, mul] }", "start": [229, 1], "end": [236, 82], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalNonAssocRing", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalNonAssocRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalNonAssocRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul zsmul,\n    hf.mulZeroClass f zero mul,\n    hf.distrib f add mul with }", "start": [259, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalNonAssocRing", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalNonAssocRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalNonAssocRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul zsmul,\n    hf.mulZeroClass f zero mul,\n    hf.distrib f add mul with }", "start": [273, 1], "end": [284, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalRing", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2] [SMul \u2115 \u03b2]\n    [SMul \u2124 \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (gsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) : NonUnitalRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul gsmul,\n    hf.mulZeroClass f zero mul,\n    hf.distrib f add mul,\n    hf.semigroup f mul with }", "start": [293, 1], "end": [304, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalRing", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2] [SMul \u2115 \u03b2]\n    [SMul \u2124 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (gsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) : NonUnitalRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul gsmul,\n    hf.mulZeroClass f zero mul,\n    hf.distrib f add mul,\n    hf.semigroup f mul with }", "start": [307, 1], "end": [318, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonAssocRing", "code": "@[reducible]\nprotected def Function.Injective.nonAssocRing [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (gsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : NonAssocRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul gsmul,\n    hf.addGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast,\n    hf.mulZeroClass f zero mul,\n    hf.distrib f add mul,\n    hf.mulOneClass f one mul with }", "start": [328, 1], "end": [341, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonAssocRing", "code": "@[reducible]\nprotected def Function.Surjective.nonAssocRing [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (gsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) :\n    NonAssocRing \u03b2 :=\n  { hf.addCommGroup f zero add neg sub nsmul gsmul,\n    hf.mulZeroClass f zero mul,\n    hf.addGroupWithOne f zero one add neg sub nsmul gsmul nat_cast int_cast,\n    hf.distrib f add mul,\n    hf.mulOneClass f one mul with }", "start": [344, 1], "end": [358, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.ring", "code": "@[reducible]\nprotected def Function.Injective.ring [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2] [SMul \u2115 \u03b2]\n    [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : Ring \u03b2 :=\n  { hf.mulZeroClass f zero mul, hf.addGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,\n    hf.addCommGroup f zero add neg sub nsmul zsmul,\n    hf.monoid f one mul npow,\n    hf.distrib f add mul with }", "start": [367, 1], "end": [381, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.ring", "code": "@[reducible]\nprotected def Function.Surjective.ring [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2] [SMul \u2115 \u03b2]\n    [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) : Ring \u03b2 :=\n  { hf.mulZeroClass f zero mul, hf.addGroupWithOne f zero one add neg sub nsmul zsmul nat_cast int_cast,\n    hf.addCommGroup f zero add neg sub nsmul zsmul,\n    hf.monoid f one mul npow,\n    hf.distrib f add mul with }", "start": [384, 1], "end": [398, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nonUnitalCommRing", "code": "@[reducible]\nprotected def Function.Injective.nonUnitalCommRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalCommRing \u03b2 :=\n  { hf.nonUnitalRing f zero add mul neg sub nsmul zsmul,\n    hf.commSemigroup f mul with }", "start": [407, 1], "end": [417, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonUnitalCommRing", "code": "@[reducible]\nprotected def Function.Surjective.nonUnitalCommRing [Zero \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f) (zero : f 0 = 0)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) :\n    NonUnitalCommRing \u03b2 :=\n  { hf.nonUnitalRing f zero add mul neg sub nsmul zsmul,\n    hf.commSemigroup f mul with }", "start": [420, 1], "end": [430, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.commRing", "code": "@[reducible]\nprotected def Function.Injective.commRing [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : CommRing \u03b2 :=\n  { hf.ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,\n    hf.commSemigroup f mul with }", "start": [439, 1], "end": [450, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.commRing", "code": "@[reducible]\nprotected def Function.Surjective.commRing [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Surjective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : CommRing \u03b2 :=\n  { hf.ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,\n    hf.commSemigroup f mul with }", "start": [453, 1], "end": [464, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Image.lean", "imports": ["Mathlib/Data/Set/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.preimage", "code": "def preimage {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : Set \u03b1 :=\n  { x | f x \u2208 s }", "start": [45, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_empty", "code": "@[simp]\ntheorem preimage_empty : f \u207b\u00b9' \u2205 = \u2205", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_preimage", "code": "@[simp, mfld_simps]\ntheorem mem_preimage {s : Set \u03b2} {a : \u03b1} : a \u2208 f \u207b\u00b9' s \u2194 f a \u2208 s", "start": [63, 1], "end": [65, 10], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_congr", "code": "theorem preimage_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : \u2200 x : \u03b1, f x = g x) : f \u207b\u00b9' s = g \u207b\u00b9' s", "start": [68, 1], "end": [70, 11], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mono", "code": "@[gcongr]\ntheorem preimage_mono {s t : Set \u03b2} (h : s \u2286 t) : f \u207b\u00b9' s \u2286 f \u207b\u00b9' t", "start": [73, 1], "end": [74, 88], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_univ", "code": "@[simp, mfld_simps]\ntheorem preimage_univ : f \u207b\u00b9' univ = univ", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "Set.subset_preimage_univ", "code": "theorem subset_preimage_univ {s : Set \u03b1} : s \u2286 f \u207b\u00b9' univ", "start": [82, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inter", "code": "@[simp, mfld_simps]\ntheorem preimage_inter {s t : Set \u03b2} : f \u207b\u00b9' (s \u2229 t) = f \u207b\u00b9' s \u2229 f \u207b\u00b9' t", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_union", "code": "@[simp]\ntheorem preimage_union {s t : Set \u03b2} : f \u207b\u00b9' (s \u222a t) = f \u207b\u00b9' s \u222a f \u207b\u00b9' t", "start": [91, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_compl", "code": "@[simp]\ntheorem preimage_compl {s : Set \u03b2} : f \u207b\u00b9' s\u1d9c = (f \u207b\u00b9' s)\u1d9c", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_diff", "code": "@[simp]\ntheorem preimage_diff (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b2) : f \u207b\u00b9' (s \\ t) = f \u207b\u00b9' s \\ f \u207b\u00b9' t", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_symmDiff", "code": "@[simp]\nlemma preimage_symmDiff {f : \u03b1 \u2192 \u03b2} (s t : Set \u03b2) : f \u207b\u00b9' (s \u2206 t) = (f \u207b\u00b9' s) \u2206 (f \u207b\u00b9' t) :=\n  rfl", "start": [106, 1], "end": [108, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Set.preimage_ite", "code": "@[simp]\ntheorem preimage_ite (f : \u03b1 \u2192 \u03b2) (s t\u2081 t\u2082 : Set \u03b2) :\n    f \u207b\u00b9' s.ite t\u2081 t\u2082 = (f \u207b\u00b9' s).ite (f \u207b\u00b9' t\u2081) (f \u207b\u00b9' t\u2082)", "start": [111, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_setOf_eq", "code": "@[simp]\ntheorem preimage_setOf_eq {p : \u03b1 \u2192 Prop} {f : \u03b2 \u2192 \u03b1} : f \u207b\u00b9' { a | p a } = { a | p (f a) }", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_id_eq", "code": "@[simp]\ntheorem preimage_id_eq : preimage (id : \u03b1 \u2192 \u03b1) = id", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_id", "code": "@[mfld_simps]\ntheorem preimage_id {s : Set \u03b1} : id \u207b\u00b9' s = s", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_id'", "code": "@[simp, mfld_simps]\ntheorem preimage_id' {s : Set \u03b1} : (fun x => x) \u207b\u00b9' s = s", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_of_mem", "code": "@[simp]\ntheorem preimage_const_of_mem {b : \u03b2} {s : Set \u03b2} (h : b \u2208 s) : (fun _ : \u03b1 => b) \u207b\u00b9' s = univ", "start": [137, 1], "end": [139, 31], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_of_not_mem", "code": "@[simp]\ntheorem preimage_const_of_not_mem {b : \u03b2} {s : Set \u03b2} (h : b \u2209 s) : (fun _ : \u03b1 => b) \u207b\u00b9' s = \u2205", "start": [142, 1], "end": [144, 44], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const", "code": "theorem preimage_const (b : \u03b2) (s : Set \u03b2) [Decidable (b \u2208 s)] :\n    (fun _ : \u03b1 => b) \u207b\u00b9' s = if b \u2208 s then univ else \u2205", "start": [147, 1], "end": [150, 66], "kind": "commanddeclaration"}, {"full_name": "Set.exists_eq_const_of_preimage_singleton", "code": "lemma exists_eq_const_of_preimage_singleton [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 b : \u03b2, f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ) : \u2203 b, f = const \u03b1 b := by\n  rcases em (\u2203 b, f \u207b\u00b9' {b} = univ) with \u27e8b, hb\u27e9 | hf'\n  \u00b7 exact \u27e8b, funext fun x \u21a6 eq_univ_iff_forall.1 hb x\u27e9\n  \u00b7 have : \u2200 x b, f x \u2260 b := fun x b \u21a6\n      eq_empty_iff_forall_not_mem.1 ((hf b).resolve_right fun h \u21a6 hf' \u27e8b, h\u27e9) x\n    exact \u27e8Classical.arbitrary \u03b2, funext fun x \u21a6 absurd rfl (this x _)\u27e9", "start": [153, 1], "end": [161, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Set.preimage_comp", "code": "theorem preimage_comp {s : Set \u03b3} : g \u2218 f \u207b\u00b9' s = f \u207b\u00b9' (g \u207b\u00b9' s)", "start": [163, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_comp_eq", "code": "theorem preimage_comp_eq : preimage (g \u2218 f) = preimage f \u2218 preimage g", "start": [167, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iterate_eq", "code": "theorem preimage_iterate_eq {f : \u03b1 \u2192 \u03b1} {n : \u2115} : Set.preimage f^[n] = (Set.preimage f)^[n]", "start": [171, 1], "end": [173, 61], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_preimage", "code": "theorem preimage_preimage {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b3} :\n    f \u207b\u00b9' (g \u207b\u00b9' s) = (fun x => g (f x)) \u207b\u00b9' s", "start": [176, 1], "end": [178, 21], "kind": "commanddeclaration"}, {"full_name": "Set.eq_preimage_subtype_val_iff", "code": "theorem eq_preimage_subtype_val_iff {p : \u03b1 \u2192 Prop} {s : Set (Subtype p)} {t : Set \u03b1} :\n    s = Subtype.val \u207b\u00b9' t \u2194 \u2200 (x) (h : p x), (\u27e8x, h\u27e9 : Subtype p) \u2208 s \u2194 x \u2208 t", "start": [181, 1], "end": [185, 51], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_of_nonempty_preimage", "code": "theorem nonempty_of_nonempty_preimage {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : (f \u207b\u00b9' s).Nonempty) :\n    s.Nonempty", "start": [188, 1], "end": [191, 12], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_singleton_true", "code": "@[simp] theorem preimage_singleton_true (p : \u03b1 \u2192 Prop) : p \u207b\u00b9' {True} = {a | p a}", "start": [194, 1], "end": [194, 98], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_singleton_false", "code": "@[simp] theorem preimage_singleton_false (p : \u03b1 \u2192 Prop) : p \u207b\u00b9' {False} = {a | \u00acp a}", "start": [197, 1], "end": [197, 101], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_subtype_coe_eq_compl", "code": "theorem preimage_subtype_coe_eq_compl {\u03b1 : Type*} {s u v : Set \u03b1} (hsuv : s \u2286 u \u222a v)\n    (H : s \u2229 (u \u2229 v) = \u2205) : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' u = ((\u2191) \u207b\u00b9' v)\u1d9c", "start": [200, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_iff_bex", "code": "theorem mem_image_iff_bex {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {y : \u03b2} :\n    y \u2208 f '' s \u2194 \u2203 (x : _) (_ : x \u2208 s), f x = y", "start": [225, 1], "end": [227, 15], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image", "code": "@[simp]\ntheorem mem_image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (y : \u03b2) : y \u2208 f '' s \u2194 \u2203 x, x \u2208 s \u2227 f x = y", "start": [230, 1], "end": [232, 10], "kind": "commanddeclaration"}, {"full_name": "Set.image_eta", "code": "theorem image_eta (f : \u03b1 \u2192 \u03b2) : f '' s = (fun x => f x) '' s", "start": [235, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_of_mem", "code": "@[mfld_simps]\ntheorem mem_image_of_mem (f : \u03b1 \u2192 \u03b2) {x : \u03b1} {a : Set \u03b1} (h : x \u2208 a) : f x \u2208 f '' a", "start": [239, 1], "end": [241, 14], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mem_set_image", "code": "theorem _root_.Function.Injective.mem_set_image {f : \u03b1 \u2192 \u03b2} (hf : Injective f) {s : Set \u03b1} {a : \u03b1} :\n    f a \u2208 f '' s \u2194 a \u2208 s", "start": [244, 1], "end": [246, 54], "kind": "commanddeclaration"}, {"full_name": "Set.ball_image_iff", "code": "theorem ball_image_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 x \u2208 s, p (f x)", "start": [249, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "Set.ball_image_of_ball", "code": "theorem ball_image_of_ball {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop} (h : \u2200 x \u2208 s, p (f x)) :\n    \u2200 y \u2208 f '' s, p y", "start": [253, 1], "end": [255, 21], "kind": "commanddeclaration"}, {"full_name": "Set.bex_image_iff", "code": "theorem bex_image_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2203 y \u2208 f '' s, p y) \u2194 \u2203 x \u2208 s, p (f x)", "start": [258, 1], "end": [259, 54], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_elim", "code": "theorem mem_image_elim {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {C : \u03b2 \u2192 Prop} (h : \u2200 x : \u03b1, x \u2208 s \u2192 C (f x)) :\n    \u2200 {y : \u03b2}, y \u2208 f '' s \u2192 C y", "start": [262, 1], "end": [264, 34], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_elim_on", "code": "theorem mem_image_elim_on {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {C : \u03b2 \u2192 Prop} {y : \u03b2} (h_y : y \u2208 f '' s)\n    (h : \u2200 x : \u03b1, x \u2208 s \u2192 C (f x)) : C y", "start": [267, 1], "end": [269, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image_congr", "code": "@[congr]\ntheorem image_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : \u2200 a \u2208 s, f a = g a) : f '' s = g '' s", "start": [273, 1], "end": [284, 4], "kind": "commanddeclaration"}, {"full_name": "Set.image_congr'", "code": "theorem image_congr' {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : \u2200 x : \u03b1, f x = g x) : f '' s = g '' s", "start": [288, 1], "end": [290, 29], "kind": "commanddeclaration"}, {"full_name": "Set.image_comp", "code": "theorem image_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (a : Set \u03b1) : f \u2218 g '' a = f '' (g '' a)", "start": [293, 1], "end": [295, 81], "kind": "commanddeclaration"}, {"full_name": "Set.image_image", "code": "theorem image_image (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : g '' (f '' s) = (fun x => g (f x)) '' s", "start": [298, 1], "end": [300, 26], "kind": "commanddeclaration"}, {"full_name": "Set.image_comm", "code": "theorem image_comm {\u03b2'} {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {f' : \u03b1 \u2192 \u03b2'} {g' : \u03b2' \u2192 \u03b3}\n    (h_comm : \u2200 a, f (g a) = g' (f' a)) : (s.image g).image f = (s.image f').image g'", "start": [303, 1], "end": [305, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.set_image", "code": "theorem _root_.Function.Semiconj.set_image {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2}\n    (h : Function.Semiconj f ga gb) : Function.Semiconj (image f) (image ga) (image gb)", "start": [308, 1], "end": [310, 15], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.set_image", "code": "theorem _root_.Function.Commute.set_image {f g : \u03b1 \u2192 \u03b1} (h : Function.Commute f g) :\n    Function.Commute (image f) (image g)", "start": [313, 1], "end": [315, 32], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset", "code": "@[gcongr]\ntheorem image_subset {a b : Set \u03b1} (f : \u03b1 \u2192 \u03b2) (h : a \u2286 b) : f '' a \u2286 f '' b", "start": [318, 1], "end": [323, 50], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_image", "code": "lemma monotone_image {f : \u03b1 \u2192 \u03b2} : Monotone (image f) := fun _ _ => image_subset _", "start": [326, 1], "end": [327, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Set.image_union", "code": "theorem image_union (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' (s \u222a t) = f '' s \u222a f '' t", "start": [330, 1], "end": [333, 96], "kind": "commanddeclaration"}, {"full_name": "Set.image_empty", "code": "@[simp]\ntheorem image_empty (f : \u03b1 \u2192 \u03b2) : f '' \u2205 = \u2205", "start": [336, 1], "end": [339, 7], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter_subset", "code": "theorem image_inter_subset (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' (s \u2229 t) \u2286 f '' s \u2229 f '' t", "start": [342, 1], "end": [343, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter_on", "code": "theorem image_inter_on {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} (h : \u2200 x \u2208 t, \u2200 y \u2208 s, f x = f y \u2192 x = y) :\n    f '' (s \u2229 t) = f '' s \u2229 f '' t", "start": [346, 1], "end": [351, 34], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter", "code": "theorem image_inter {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} (H : Injective f) : f '' (s \u2229 t) = f '' s \u2229 f '' t", "start": [354, 1], "end": [355, 38], "kind": "commanddeclaration"}, {"full_name": "Set.image_univ_of_surjective", "code": "theorem image_univ_of_surjective {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} (H : Surjective f) : f '' univ = univ", "start": [358, 1], "end": [359, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_singleton", "code": "@[simp]\ntheorem image_singleton {f : \u03b1 \u2192 \u03b2} {a : \u03b1} : f '' {a} = {f a}", "start": [362, 1], "end": [365, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.image_const", "code": "@[simp]\ntheorem Nonempty.image_const {s : Set \u03b1} (hs : s.Nonempty) (a : \u03b2) : (fun _ => a) '' s = {a}", "start": [368, 1], "end": [372, 67], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_empty", "code": "@[simp, mfld_simps]\ntheorem image_eq_empty {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : f '' s = \u2205 \u2194 s = \u2205", "start": [375, 1], "end": [378, 71], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_compl_eq_image_compl", "code": "theorem preimage_compl_eq_image_compl [BooleanAlgebra \u03b1] (S : Set \u03b1) :\n    HasCompl.compl \u207b\u00b9' S = HasCompl.compl '' S", "start": [382, 1], "end": [386, 73], "kind": "commanddeclaration"}, {"full_name": "Set.mem_compl_image", "code": "theorem mem_compl_image [BooleanAlgebra \u03b1] (t : \u03b1) (S : Set \u03b1) :\n    t \u2208 HasCompl.compl '' S \u2194 t\u1d9c \u2208 S", "start": [389, 1], "end": [391, 41], "kind": "commanddeclaration"}, {"full_name": "Set.image_id'", "code": "@[simp]\ntheorem image_id' (s : Set \u03b1) : (fun x => x) '' s = s", "start": [394, 1], "end": [398, 7], "kind": "commanddeclaration"}, {"full_name": "Set.image_id", "code": "theorem image_id (s : Set \u03b1) : id '' s = s", "start": [401, 1], "end": [401, 54], "kind": "commanddeclaration"}, {"full_name": "Set.compl_compl_image", "code": "theorem compl_compl_image [BooleanAlgebra \u03b1] (S : Set \u03b1) :\n    HasCompl.compl '' (HasCompl.compl '' S) = S", "start": [404, 1], "end": [406, 48], "kind": "commanddeclaration"}, {"full_name": "Set.image_insert_eq", "code": "theorem image_insert_eq {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} :\n    f '' insert a s = insert (f a) (f '' s)", "start": [409, 1], "end": [412, 60], "kind": "commanddeclaration"}, {"full_name": "Set.image_pair", "code": "theorem image_pair (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) : f '' {a, b} = {f a, f b}", "start": [415, 1], "end": [416, 47], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_preimage_of_inverse", "code": "theorem image_subset_preimage_of_inverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (I : LeftInverse g f) (s : Set \u03b1) :\n    f '' s \u2286 g \u207b\u00b9' s", "start": [419, 1], "end": [420, 78], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_subset_image_of_inverse", "code": "theorem preimage_subset_image_of_inverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (I : LeftInverse g f) (s : Set \u03b2) :\n    f \u207b\u00b9' s \u2286 g '' s", "start": [423, 1], "end": [424, 49], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_preimage_of_inverse", "code": "theorem image_eq_preimage_of_inverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h\u2081 : LeftInverse g f)\n    (h\u2082 : RightInverse g f) : image f = preimage g", "start": [427, 1], "end": [430, 100], "kind": "commanddeclaration"}, {"full_name": "Set.mem_image_iff_of_inverse", "code": "theorem mem_image_iff_of_inverse {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b1} (h\u2081 : LeftInverse g f)\n    (h\u2082 : RightInverse g f) : b \u2208 f '' s \u2194 g b \u2208 s", "start": [433, 1], "end": [435, 47], "kind": "commanddeclaration"}, {"full_name": "Set.image_compl_subset", "code": "theorem image_compl_subset {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (H : Injective f) : f '' s\u1d9c \u2286 (f '' s)\u1d9c", "start": [438, 1], "end": [439, 78], "kind": "commanddeclaration"}, {"full_name": "Set.subset_image_compl", "code": "theorem subset_image_compl {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (H : Surjective f) : (f '' s)\u1d9c \u2286 f '' s\u1d9c", "start": [442, 1], "end": [445, 38], "kind": "commanddeclaration"}, {"full_name": "Set.image_compl_eq", "code": "theorem image_compl_eq {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (H : Bijective f) : f '' s\u1d9c = (f '' s)\u1d9c", "start": [448, 1], "end": [449, 68], "kind": "commanddeclaration"}, {"full_name": "Set.subset_image_diff", "code": "theorem subset_image_diff (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' s \\ f '' t \u2286 f '' (s \\ t)", "start": [452, 1], "end": [454, 48], "kind": "commanddeclaration"}, {"full_name": "Set.subset_image_symmDiff", "code": "theorem subset_image_symmDiff : (f '' s) \u2206 (f '' t) \u2286 f '' s \u2206 t", "start": [457, 1], "end": [459, 41], "kind": "commanddeclaration"}, {"full_name": "Set.image_diff", "code": "theorem image_diff {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (s t : Set \u03b1) : f '' (s \\ t) = f '' s \\ f '' t", "start": [462, 1], "end": [465, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_symmDiff", "code": "theorem image_symmDiff (hf : Injective f) (s t : Set \u03b1) : f '' s \u2206 t = (f '' s) \u2206 (f '' t)", "start": [468, 1], "end": [469, 57], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.image", "code": "theorem Nonempty.image (f : \u03b1 \u2192 \u03b2) {s : Set \u03b1} : s.Nonempty \u2192 (f '' s).Nonempty", "start": [472, 1], "end": [473, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_image", "code": "theorem Nonempty.of_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : (f '' s).Nonempty \u2192 s.Nonempty", "start": [476, 1], "end": [477, 29], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_image_iff", "code": "@[simp]\ntheorem nonempty_image_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : (f '' s).Nonempty \u2194 s.Nonempty", "start": [480, 1], "end": [482, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.preimage", "code": "theorem Nonempty.preimage {s : Set \u03b2} (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) :\n    (f \u207b\u00b9' s).Nonempty", "start": [485, 1], "end": [489, 38], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_iff", "code": "@[simp]\ntheorem image_subset_iff {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} : f '' s \u2286 t \u2194 s \u2286 f \u207b\u00b9' t", "start": [495, 1], "end": [498, 17], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_subset", "code": "theorem image_preimage_subset (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : f '' (f \u207b\u00b9' s) \u2286 s", "start": [501, 1], "end": [502, 32], "kind": "commanddeclaration"}, {"full_name": "Set.subset_preimage_image", "code": "theorem subset_preimage_image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : s \u2286 f \u207b\u00b9' (f '' s)", "start": [505, 1], "end": [506, 21], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_image_eq", "code": "@[simp]\ntheorem preimage_image_eq {f : \u03b1 \u2192 \u03b2} (s : Set \u03b1) (h : Injective f) : f \u207b\u00b9' (f '' s) = s", "start": [509, 1], "end": [511, 77], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_eq", "code": "@[simp]\ntheorem image_preimage_eq {f : \u03b1 \u2192 \u03b2} (s : Set \u03b2) (h : Surjective f) : f '' (f \u207b\u00b9' s) = s", "start": [514, 1], "end": [518, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_eq_preimage", "code": "@[simp]\ntheorem preimage_eq_preimage {f : \u03b2 \u2192 \u03b1} (hf : Surjective f) : f \u207b\u00b9' s = f \u207b\u00b9' t \u2194 s = t", "start": [521, 1], "end": [525, 23], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter_preimage", "code": "theorem image_inter_preimage (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    f '' (s \u2229 f \u207b\u00b9' t) = f '' s \u2229 t", "start": [528, 1], "end": [535, 28], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_inter", "code": "theorem image_preimage_inter (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    f '' (f \u207b\u00b9' t \u2229 s) = t \u2229 f '' s", "start": [538, 1], "end": [539, 87], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter_nonempty_iff", "code": "@[simp]\ntheorem image_inter_nonempty_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} :\n    (f '' s \u2229 t).Nonempty \u2194 (s \u2229 f \u207b\u00b9' t).Nonempty", "start": [542, 1], "end": [545, 50], "kind": "commanddeclaration"}, {"full_name": "Set.image_diff_preimage", "code": "theorem image_diff_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} : f '' (s \\ f \u207b\u00b9' t) = f '' s \\ t", "start": [548, 1], "end": [549, 63], "kind": "commanddeclaration"}, {"full_name": "Set.compl_image", "code": "theorem compl_image : image (compl : Set \u03b1 \u2192 Set \u03b1) = preimage compl", "start": [552, 1], "end": [553, 55], "kind": "commanddeclaration"}, {"full_name": "Set.compl_image_set_of", "code": "theorem compl_image_set_of {p : Set \u03b1 \u2192 Prop} : compl '' { s | p s } = { s | p s\u1d9c }", "start": [556, 1], "end": [557, 26], "kind": "commanddeclaration"}, {"full_name": "Set.inter_preimage_subset", "code": "theorem inter_preimage_subset (s : Set \u03b1) (t : Set \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    s \u2229 f \u207b\u00b9' t \u2286 f \u207b\u00b9' (f '' s \u2229 t)", "start": [560, 1], "end": [561, 88], "kind": "commanddeclaration"}, {"full_name": "Set.union_preimage_subset", "code": "theorem union_preimage_subset (s : Set \u03b1) (t : Set \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    s \u222a f \u207b\u00b9' t \u2286 f \u207b\u00b9' (f '' s \u222a t)", "start": [564, 1], "end": [566, 72], "kind": "commanddeclaration"}, {"full_name": "Set.subset_image_union", "code": "theorem subset_image_union (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) : f '' (s \u222a f \u207b\u00b9' t) \u2286 f '' s \u222a t", "start": [569, 1], "end": [570, 51], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_subset_iff", "code": "theorem preimage_subset_iff {A : Set \u03b1} {B : Set \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    f \u207b\u00b9' B \u2286 A \u2194 \u2200 a : \u03b1, f a \u2208 B \u2192 a \u2208 A", "start": [573, 1], "end": [575, 10], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_image", "code": "theorem image_eq_image {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : f '' s = f '' t \u2194 s = t", "start": [578, 1], "end": [581, 66], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_image_iff", "code": "theorem image_subset_image_iff {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : f '' s \u2286 f '' t \u2194 s \u2286 t", "start": [584, 1], "end": [587, 24], "kind": "commanddeclaration"}, {"full_name": "Set.prod_quotient_preimage_eq_image", "code": "theorem prod_quotient_preimage_eq_image [s : Setoid \u03b1] (g : Quotient s \u2192 \u03b2) {h : \u03b1 \u2192 \u03b2}\n    (Hh : h = g \u2218 Quotient.mk'') (r : Set (\u03b2 \u00d7 \u03b2)) :\n    { x : Quotient s \u00d7 Quotient s | (g x.1, g x.2) \u2208 r } =\n      (fun a : \u03b1 \u00d7 \u03b1 => (\u27e6a.1\u27e7, \u27e6a.2\u27e7)) '' ((fun a : \u03b1 \u00d7 \u03b1 => (h a.1, h a.2)) \u207b\u00b9' r)", "start": [590, 1], "end": [599, 28], "kind": "commanddeclaration"}, {"full_name": "Set.exists_image_iff", "code": "theorem exists_image_iff (f : \u03b1 \u2192 \u03b2) (x : Set \u03b1) (P : \u03b2 \u2192 Prop) :\n    (\u2203 a : f '' x, P a) \u2194 \u2203 a : x, P (f a)", "start": [602, 1], "end": [605, 30], "kind": "commanddeclaration"}, {"full_name": "Set.imageFactorization", "code": "def imageFactorization (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : s \u2192 f '' s := fun p =>\n  \u27e8f p.1, mem_image_of_mem f p.2\u27e9", "start": [608, 1], "end": [610, 34], "kind": "commanddeclaration"}, {"full_name": "Set.imageFactorization_eq", "code": "theorem imageFactorization_eq {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    Subtype.val \u2218 imageFactorization f s = f \u2218 Subtype.val", "start": [613, 1], "end": [615, 22], "kind": "commanddeclaration"}, {"full_name": "Set.surjective_onto_image", "code": "theorem surjective_onto_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : Surjective (imageFactorization f s)", "start": [618, 1], "end": [619, 42], "kind": "commanddeclaration"}, {"full_name": "Set.image_perm", "code": "theorem image_perm {s : Set \u03b1} {\u03c3 : Equiv.Perm \u03b1} (hs : { a : \u03b1 | \u03c3 a \u2260 a } \u2286 s) : \u03c3 '' s = s", "start": [622, 1], "end": [631, 64], "kind": "commanddeclaration"}, {"full_name": "Set.powerset_insert", "code": "theorem powerset_insert (s : Set \u03b1) (a : \u03b1) : \ud835\udcab insert a s = \ud835\udcab s \u222a insert a '' \ud835\udcab s", "start": [638, 1], "end": [654, 36], "kind": "commanddeclaration"}, {"full_name": "Set.range", "code": "def range (f : \u03b9 \u2192 \u03b1) : Set \u03b1 :=\n  { x | \u2203 y, f y = x }", "start": [664, 1], "end": [669, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mem_range", "code": "@[simp]\ntheorem mem_range {x : \u03b1} : x \u2208 range f \u2194 \u2203 y, f y = x", "start": [672, 1], "end": [674, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mem_range_self", "code": "@[mfld_simps]\ntheorem mem_range_self (i : \u03b9) : f i \u2208 range f", "start": [679, 1], "end": [681, 11], "kind": "commanddeclaration"}, {"full_name": "Set.forall_range_iff", "code": "theorem forall_range_iff {p : \u03b1 \u2192 Prop} : (\u2200 a \u2208 range f, p a) \u2194 \u2200 i, p (f i)", "start": [684, 1], "end": [684, 89], "kind": "commanddeclaration"}, {"full_name": "Set.forall_subtype_range_iff", "code": "theorem forall_subtype_range_iff {p : range f \u2192 Prop} :\n    (\u2200 a : range f, p a) \u2194 \u2200 i, p \u27e8f i, mem_range_self _\u27e9", "start": [687, 1], "end": [691, 13], "kind": "commanddeclaration"}, {"full_name": "Set.exists_range_iff", "code": "theorem exists_range_iff {p : \u03b1 \u2192 Prop} : (\u2203 a \u2208 range f, p a) \u2194 \u2203 i, p (f i)", "start": [694, 1], "end": [694, 89], "kind": "commanddeclaration"}, {"full_name": "Set.exists_range_iff'", "code": "theorem exists_range_iff' {p : \u03b1 \u2192 Prop} : (\u2203 a, a \u2208 range f \u2227 p a) \u2194 \u2203 i, p (f i)", "start": [697, 1], "end": [698, 50], "kind": "commanddeclaration"}, {"full_name": "Set.exists_subtype_range_iff", "code": "theorem exists_subtype_range_iff {p : range f \u2192 Prop} :\n    (\u2203 a : range f, p a) \u2194 \u2203 i, p \u27e8f i, mem_range_self _\u27e9", "start": [701, 1], "end": [706, 27], "kind": "commanddeclaration"}, {"full_name": "Set.range_iff_surjective", "code": "theorem range_iff_surjective : range f = univ \u2194 Surjective f", "start": [709, 1], "end": [710, 21], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.range_eq", "code": "alias \u27e8_, _root_.Function.Surjective.range_eq\u27e9 := range_iff_surjective", "start": [714, 1], "end": [714, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.image_univ", "code": "@[simp]\ntheorem image_univ {f : \u03b1 \u2192 \u03b2} : f '' univ = range f", "start": [717, 1], "end": [720, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_subset_range", "code": "theorem image_subset_range (f : \u03b1 \u2192 \u03b2) (s) : f '' s \u2286 range f", "start": [723, 1], "end": [724, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mem_range_of_mem_image", "code": "theorem mem_range_of_mem_image (f : \u03b1 \u2192 \u03b2) (s) {x : \u03b2} (h : x \u2208 f '' s) : x \u2208 range f", "start": [727, 1], "end": [728, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.mem_range_succ", "code": "theorem _root_.Nat.mem_range_succ (i : \u2115) : i \u2208 range Nat.succ \u2194 0 < i", "start": [731, 1], "end": [734, 67], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.preimage'", "code": "theorem Nonempty.preimage' {s : Set \u03b2} (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b2} (hf : s \u2286 Set.range f) :\n    (f \u207b\u00b9' s).Nonempty", "start": [737, 1], "end": [741, 42], "kind": "commanddeclaration"}, {"full_name": "Set.range_comp", "code": "theorem range_comp (g : \u03b1 \u2192 \u03b2) (f : \u03b9 \u2192 \u03b1) : range (g \u2218 f) = g '' range f", "start": [744, 1], "end": [746, 64], "kind": "commanddeclaration"}, {"full_name": "Set.range_subset_iff", "code": "theorem range_subset_iff : range f \u2286 s \u2194 \u2200 y, f y \u2208 s", "start": [749, 1], "end": [750, 19], "kind": "commanddeclaration"}, {"full_name": "Set.range_subset_range_iff_exists_comp", "code": "theorem range_subset_range_iff_exists_comp {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} :\n    range f \u2286 range g \u2194 \u2203 h : \u03b1 \u2192 \u03b2, f = g \u2218 h", "start": [753, 1], "end": [755, 99], "kind": "commanddeclaration"}, {"full_name": "Set.range_eq_iff", "code": "theorem range_eq_iff (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) :\n    range f = s \u2194 (\u2200 a, f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b", "start": [757, 1], "end": [760, 24], "kind": "commanddeclaration"}, {"full_name": "Set.range_comp_subset_range", "code": "theorem range_comp_subset_range (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) : range (g \u2218 f) \u2286 range g", "start": [763, 1], "end": [764, 44], "kind": "commanddeclaration"}, {"full_name": "Set.range_nonempty_iff_nonempty", "code": "theorem range_nonempty_iff_nonempty : (range f).Nonempty \u2194 Nonempty \u03b9", "start": [767, 1], "end": [768, 61], "kind": "commanddeclaration"}, {"full_name": "Set.range_nonempty", "code": "theorem range_nonempty [h : Nonempty \u03b9] (f : \u03b9 \u2192 \u03b1) : (range f).Nonempty", "start": [771, 1], "end": [772, 34], "kind": "commanddeclaration"}, {"full_name": "Set.range_eq_empty_iff", "code": "@[simp]\ntheorem range_eq_empty_iff {f : \u03b9 \u2192 \u03b1} : range f = \u2205 \u2194 IsEmpty \u03b9", "start": [775, 1], "end": [777, 84], "kind": "commanddeclaration"}, {"full_name": "Set.range_eq_empty", "code": "theorem range_eq_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u03b1) : range f = \u2205", "start": [780, 1], "end": [781, 27], "kind": "commanddeclaration"}, {"full_name": "Set.instNonemptyRange", "code": "instance instNonemptyRange [Nonempty \u03b9] (f : \u03b9 \u2192 \u03b1) : Nonempty (range f) :=\n  (range_nonempty f).to_subtype", "start": [784, 1], "end": [785, 32], "kind": "commanddeclaration"}, {"full_name": "Set.image_union_image_compl_eq_range", "code": "@[simp]\ntheorem image_union_image_compl_eq_range (f : \u03b1 \u2192 \u03b2) : f '' s \u222a f '' s\u1d9c = range f", "start": [787, 1], "end": [789, 55], "kind": "commanddeclaration"}, {"full_name": "Set.insert_image_compl_eq_range", "code": "theorem insert_image_compl_eq_range (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : insert (f x) (f '' {x}\u1d9c) = range f", "start": [792, 1], "end": [793, 66], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_eq_inter_range", "code": "theorem image_preimage_eq_inter_range {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2} : f '' (f \u207b\u00b9' t) = t \u2229 range f", "start": [796, 1], "end": [799, 97], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_eq_of_subset", "code": "theorem image_preimage_eq_of_subset {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hs : s \u2286 range f) :\n    f '' (f \u207b\u00b9' s) = s", "start": [802, 1], "end": [803, 97], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_eq_iff", "code": "theorem image_preimage_eq_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f '' (f \u207b\u00b9' s) = s \u2194 s \u2286 range f", "start": [806, 1], "end": [811, 32], "kind": "commanddeclaration"}, {"full_name": "Set.subset_range_iff_exists_image_eq", "code": "theorem subset_range_iff_exists_image_eq {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : s \u2286 range f \u2194 \u2203 t, f '' t = s", "start": [814, 1], "end": [815, 88], "kind": "commanddeclaration"}, {"full_name": "Set.range_image", "code": "theorem range_image (f : \u03b1 \u2192 \u03b2) : range (image f) = \ud835\udcab range f", "start": [818, 1], "end": [819, 53], "kind": "commanddeclaration"}, {"full_name": "Set.exists_subset_range_and_iff", "code": "@[simp]\ntheorem exists_subset_range_and_iff {f : \u03b1 \u2192 \u03b2} {p : Set \u03b2 \u2192 Prop} :\n    (\u2203 s, s \u2286 range f \u2227 p s) \u2194 \u2203 s, p (f '' s)", "start": [822, 1], "end": [825, 44], "kind": "commanddeclaration"}, {"full_name": "Set.exists_subset_range_iff", "code": "theorem exists_subset_range_iff {f : \u03b1 \u2192 \u03b2} {p : Set \u03b2 \u2192 Prop} :\n    (\u2203 (s : _) (_ : s \u2286 range f), p s) \u2194 \u2203 s, p (f '' s)", "start": [828, 1], "end": [829, 68], "kind": "commanddeclaration"}, {"full_name": "Set.forall_subset_range_iff", "code": "theorem forall_subset_range_iff {f : \u03b1 \u2192 \u03b2} {p : Set \u03b2 \u2192 Prop} :\n    (\u2200 s, s \u2286 range f \u2192 p s) \u2194 \u2200 s, p (f '' s)", "start": [832, 1], "end": [834, 44], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_subset_preimage_iff", "code": "theorem preimage_subset_preimage_iff {s t : Set \u03b1} {f : \u03b2 \u2192 \u03b1} (hs : s \u2286 range f) :\n    f \u207b\u00b9' s \u2286 f \u207b\u00b9' t \u2194 s \u2286 t", "start": [836, 1], "end": [842, 21], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_eq_preimage'", "code": "theorem preimage_eq_preimage' {s t : Set \u03b1} {f : \u03b2 \u2192 \u03b1} (hs : s \u2286 range f) (ht : t \u2286 range f) :\n    f \u207b\u00b9' s = f \u207b\u00b9' t \u2194 s = t", "start": [845, 1], "end": [852, 18], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inter_range", "code": "theorem preimage_inter_range {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f \u207b\u00b9' (s \u2229 range f) = f \u207b\u00b9' s", "start": [857, 1], "end": [858, 41], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_range_inter", "code": "theorem preimage_range_inter {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f \u207b\u00b9' (range f \u2229 s) = f \u207b\u00b9' s", "start": [863, 1], "end": [864, 40], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_image_preimage", "code": "theorem preimage_image_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f \u207b\u00b9' (f '' (f \u207b\u00b9' s)) = f \u207b\u00b9' s", "start": [867, 1], "end": [868, 59], "kind": "commanddeclaration"}, {"full_name": "Set.range_id", "code": "@[simp, mfld_simps]\ntheorem range_id : range (@id \u03b1) = univ", "start": [871, 1], "end": [873, 39], "kind": "commanddeclaration"}, {"full_name": "Set.range_id'", "code": "@[simp, mfld_simps]\ntheorem range_id' : (range fun x : \u03b1 => x) = univ", "start": [876, 1], "end": [878, 11], "kind": "commanddeclaration"}, {"full_name": "Prod.range_fst", "code": "@[simp]\ntheorem _root_.Prod.range_fst [Nonempty \u03b2] : range (Prod.fst : \u03b1 \u00d7 \u03b2 \u2192 \u03b1) = univ", "start": [881, 1], "end": [883, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.range_snd", "code": "@[simp]\ntheorem _root_.Prod.range_snd [Nonempty \u03b1] : range (Prod.snd : \u03b1 \u00d7 \u03b2 \u2192 \u03b2) = univ", "start": [886, 1], "end": [888, 31], "kind": "commanddeclaration"}, {"full_name": "Set.range_eval", "code": "@[simp]\ntheorem range_eval {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Sort _} [\u2200 i, Nonempty (\u03b1 i)] (i : \u03b9) :\n    range (eval i : (\u2200 i, \u03b1 i) \u2192 \u03b1 i) = univ", "start": [891, 1], "end": [894, 31], "kind": "commanddeclaration"}, {"full_name": "Set.range_inl", "code": "theorem range_inl : range (@Sum.inl \u03b1 \u03b2) = {x | Sum.isLeft x}", "start": [897, 1], "end": [897, 87], "kind": "commanddeclaration"}, {"full_name": "Set.range_inr", "code": "theorem range_inr : range (@Sum.inr \u03b1 \u03b2) = {x | Sum.isRight x}", "start": [899, 1], "end": [899, 88], "kind": "commanddeclaration"}, {"full_name": "Set.isCompl_range_inl_range_inr", "code": "theorem isCompl_range_inl_range_inr : IsCompl (range <| @Sum.inl \u03b1 \u03b2) (range Sum.inr)", "start": [902, 1], "end": [907, 71], "kind": "commanddeclaration"}, {"full_name": "Set.range_inl_union_range_inr", "code": "@[simp]\ntheorem range_inl_union_range_inr : range (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2) \u222a range Sum.inr = univ", "start": [910, 1], "end": [912, 41], "kind": "commanddeclaration"}, {"full_name": "Set.range_inl_inter_range_inr", "code": "@[simp]\ntheorem range_inl_inter_range_inr : range (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2) \u2229 range Sum.inr = \u2205", "start": [915, 1], "end": [917, 41], "kind": "commanddeclaration"}, {"full_name": "Set.range_inr_union_range_inl", "code": "@[simp]\ntheorem range_inr_union_range_inl : range (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2) \u222a range Sum.inl = univ", "start": [920, 1], "end": [922, 46], "kind": "commanddeclaration"}, {"full_name": "Set.range_inr_inter_range_inl", "code": "@[simp]\ntheorem range_inr_inter_range_inl : range (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2) \u2229 range Sum.inl = \u2205", "start": [925, 1], "end": [927, 46], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inl_image_inr", "code": "@[simp]\ntheorem preimage_inl_image_inr (s : Set \u03b2) : Sum.inl \u207b\u00b9' (@Sum.inr \u03b1 \u03b2 '' s) = \u2205", "start": [930, 1], "end": [933, 7], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inr_image_inl", "code": "@[simp]\ntheorem preimage_inr_image_inl (s : Set \u03b1) : Sum.inr \u207b\u00b9' (@Sum.inl \u03b1 \u03b2 '' s) = \u2205", "start": [936, 1], "end": [939, 7], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inl_range_inr", "code": "@[simp]\ntheorem preimage_inl_range_inr : Sum.inl \u207b\u00b9' range (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2) = \u2205", "start": [942, 1], "end": [944, 44], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_inr_range_inl", "code": "@[simp]\ntheorem preimage_inr_range_inl : Sum.inr \u207b\u00b9' range (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2) = \u2205", "start": [947, 1], "end": [949, 44], "kind": "commanddeclaration"}, {"full_name": "Set.compl_range_inl", "code": "@[simp]\ntheorem compl_range_inl : (range (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2))\u1d9c = range (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2)", "start": [952, 1], "end": [954, 47], "kind": "commanddeclaration"}, {"full_name": "Set.compl_range_inr", "code": "@[simp]\ntheorem compl_range_inr : (range (Sum.inr : \u03b2 \u2192 Sum \u03b1 \u03b2))\u1d9c = range (Sum.inl : \u03b1 \u2192 Sum \u03b1 \u03b2)", "start": [957, 1], "end": [959, 52], "kind": "commanddeclaration"}, {"full_name": "Set.image_preimage_inl_union_image_preimage_inr", "code": "theorem image_preimage_inl_union_image_preimage_inr (s : Set (Sum \u03b1 \u03b2)) :\n    Sum.inl '' (Sum.inl \u207b\u00b9' s) \u222a Sum.inr '' (Sum.inr \u207b\u00b9' s) = s", "start": [962, 1], "end": [965, 43], "kind": "commanddeclaration"}, {"full_name": "Set.range_quot_mk", "code": "@[simp]\ntheorem range_quot_mk (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : range (Quot.mk r) = univ", "start": [968, 1], "end": [970, 34], "kind": "commanddeclaration"}, {"full_name": "Set.range_quot_lift", "code": "@[simp]\ntheorem range_quot_lift {r : \u03b9 \u2192 \u03b9 \u2192 Prop} (hf : \u2200 x y, r x y \u2192 f x = f y) :\n    range (Quot.lift f hf) = range f", "start": [973, 1], "end": [976, 45], "kind": "commanddeclaration"}, {"full_name": "Set.range_quotient_mk", "code": "@[simp]\ntheorem range_quotient_mk [sa : Setoid \u03b1] : (range (\u03b1 := Quotient sa) fun x : \u03b1 => \u27e6x\u27e7) = univ", "start": [980, 1], "end": [982, 18], "kind": "commanddeclaration"}, {"full_name": "Set.range_quotient_lift", "code": "@[simp]\ntheorem range_quotient_lift [s : Setoid \u03b9] (hf) :\n    range (Quotient.lift f hf : Quotient s \u2192 \u03b1) = range f", "start": [985, 1], "end": [988, 20], "kind": "commanddeclaration"}, {"full_name": "Set.range_quotient_mk'", "code": "@[simp]\ntheorem range_quotient_mk' {s : Setoid \u03b1} : range (Quotient.mk' : \u03b1 \u2192 Quotient s) = univ", "start": [991, 1], "end": [993, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Quotient.range_mk''", "code": "@[simp] lemma Quotient.range_mk'' {sa : Setoid \u03b1} : range (Quotient.mk'' (s\u2081 := sa)) = univ :=\n  range_quotient_mk", "start": [996, 1], "end": [997, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Set.range_quotient_lift_on'", "code": "@[simp]\ntheorem range_quotient_lift_on' {s : Setoid \u03b9} (hf) :\n    (range fun x : Quotient s => Quotient.liftOn' x f hf) = range f", "start": [999, 1], "end": [1002, 20], "kind": "commanddeclaration"}, {"full_name": "Set.canLift", "code": "instance canLift (c) (p) [CanLift \u03b1 \u03b2 c p] :\n    CanLift (Set \u03b1) (Set \u03b2) ((\u00b7 '' \u00b7) c) fun s => \u2200 x \u2208 s, p x where\n  prf _ hs := subset_range_iff_exists_image_eq.mp fun x hx => CanLift.prf _ (hs x hx)", "start": [1005, 1], "end": [1007, 86], "kind": "commanddeclaration"}, {"full_name": "Set.range_const_subset", "code": "theorem range_const_subset {c : \u03b1} : (range fun _ : \u03b9 => c) \u2286 {c}", "start": [1010, 1], "end": [1011, 34], "kind": "commanddeclaration"}, {"full_name": "Set.range_const", "code": "@[simp]\ntheorem range_const : \u2200 [Nonempty \u03b9] {c : \u03b1}, (range fun _ : \u03b9 => c) = {c}", "start": [1014, 1], "end": [1018, 55], "kind": "commanddeclaration"}, {"full_name": "Set.range_subtype_map", "code": "theorem range_subtype_map {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (h : \u2200 x, p x \u2192 q (f x)) :\n    range (Subtype.map f h) = (\u2191) \u207b\u00b9' (f '' { x | p x })", "start": [1021, 1], "end": [1034, 14], "kind": "commanddeclaration"}, {"full_name": "Set.image_swap_eq_preimage_swap", "code": "theorem image_swap_eq_preimage_swap : image (@Prod.swap \u03b1 \u03b2) = preimage Prod.swap", "start": [1040, 1], "end": [1041, 76], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_singleton_nonempty", "code": "theorem preimage_singleton_nonempty {f : \u03b1 \u2192 \u03b2} {y : \u03b2} : (f \u207b\u00b9' {y}).Nonempty \u2194 y \u2208 range f", "start": [1044, 1], "end": [1045, 10], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_singleton_eq_empty", "code": "theorem preimage_singleton_eq_empty {f : \u03b1 \u2192 \u03b2} {y : \u03b2} : f \u207b\u00b9' {y} = \u2205 \u2194 y \u2209 range f", "start": [1048, 1], "end": [1049, 71], "kind": "commanddeclaration"}, {"full_name": "Set.range_subset_singleton", "code": "theorem range_subset_singleton {f : \u03b9 \u2192 \u03b1} {x : \u03b1} : range f \u2286 {x} \u2194 f = const \u03b9 x", "start": [1052, 1], "end": [1053, 53], "kind": "commanddeclaration"}, {"full_name": "Set.image_compl_preimage", "code": "theorem image_compl_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f '' (f \u207b\u00b9' s)\u1d9c = range f \\ s", "start": [1056, 1], "end": [1057, 59], "kind": "commanddeclaration"}, {"full_name": "Set.rangeFactorization", "code": "def rangeFactorization (f : \u03b9 \u2192 \u03b2) : \u03b9 \u2192 range f := fun i => \u27e8f i, mem_range_self i\u27e9", "start": [1060, 1], "end": [1061, 85], "kind": "commanddeclaration"}, {"full_name": "Set.rangeFactorization_eq", "code": "theorem rangeFactorization_eq {f : \u03b9 \u2192 \u03b2} : Subtype.val \u2218 rangeFactorization f = f", "start": [1064, 1], "end": [1065, 22], "kind": "commanddeclaration"}, {"full_name": "Set.rangeFactorization_coe", "code": "@[simp]\ntheorem rangeFactorization_coe (f : \u03b9 \u2192 \u03b2) (a : \u03b9) : (rangeFactorization f a : \u03b2) = f a", "start": [1068, 1], "end": [1070, 6], "kind": "commanddeclaration"}, {"full_name": "Set.coe_comp_rangeFactorization", "code": "@[simp]\ntheorem coe_comp_rangeFactorization (f : \u03b9 \u2192 \u03b2) : (\u2191) \u2218 rangeFactorization f = f", "start": [1073, 1], "end": [1074, 88], "kind": "commanddeclaration"}, {"full_name": "Set.surjective_onto_range", "code": "theorem surjective_onto_range : Surjective (rangeFactorization f)", "start": [1077, 1], "end": [1077, 99], "kind": "commanddeclaration"}, {"full_name": "Set.image_eq_range", "code": "theorem image_eq_range (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : f '' s = range fun x : s => f x", "start": [1080, 1], "end": [1086, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.range_eq", "code": "theorem _root_.Sum.range_eq (f : Sum \u03b1 \u03b2 \u2192 \u03b3) :\n    range f = range (f \u2218 Sum.inl) \u222a range (f \u2218 Sum.inr)", "start": [1089, 1], "end": [1091, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Sum.elim_range", "code": "@[simp]\ntheorem Sum.elim_range (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) : range (Sum.elim f g) = range f \u222a range g", "start": [1094, 1], "end": [1096, 17], "kind": "commanddeclaration"}, {"full_name": "Set.range_ite_subset'", "code": "theorem range_ite_subset' {p : Prop} [Decidable p] {f g : \u03b1 \u2192 \u03b2} :\n    range (if p then f else g) \u2286 range f \u222a range g", "start": [1099, 1], "end": [1105, 33], "kind": "commanddeclaration"}, {"full_name": "Set.range_ite_subset", "code": "theorem range_ite_subset {p : \u03b1 \u2192 Prop} [DecidablePred p] {f g : \u03b1 \u2192 \u03b2} :\n    (range fun x => if p x then f x else g x) \u2286 range f \u222a range g", "start": [1108, 1], "end": [1112, 45], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_range", "code": "@[simp]\ntheorem preimage_range (f : \u03b1 \u2192 \u03b2) : f \u207b\u00b9' range f = univ", "start": [1115, 1], "end": [1117, 35], "kind": "commanddeclaration"}, {"full_name": "Set.range_unique", "code": "theorem range_unique [h : Unique \u03b9] : range f = {f default}", "start": [1120, 1], "end": [1129, 37], "kind": "commanddeclaration"}, {"full_name": "Set.range_diff_image_subset", "code": "theorem range_diff_image_subset (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : range f \\ f '' s \u2286 f '' s\u1d9c", "start": [1132, 1], "end": [1133, 57], "kind": "commanddeclaration"}, {"full_name": "Set.range_diff_image", "code": "theorem range_diff_image {f : \u03b1 \u2192 \u03b2} (H : Injective f) (s : Set \u03b1) : range f \\ f '' s = f '' s\u1d9c", "start": [1136, 1], "end": [1138, 66], "kind": "commanddeclaration"}, {"full_name": "Set.range_inclusion", "code": "@[simp]\ntheorem range_inclusion (h : s \u2286 t) : range (inclusion h) = { x : t | (x : \u03b1) \u2208 s }", "start": [1141, 1], "end": [1154, 12], "kind": "commanddeclaration"}, {"full_name": "Set.rangeSplitting", "code": "noncomputable def rangeSplitting (f : \u03b1 \u2192 \u03b2) : range f \u2192 \u03b1 := fun x => x.2.choose", "start": [1159, 1], "end": [1160, 82], "kind": "commanddeclaration"}, {"full_name": "Set.apply_rangeSplitting", "code": "theorem apply_rangeSplitting (f : \u03b1 \u2192 \u03b2) (x : range f) : f (rangeSplitting f x) = x", "start": [1164, 1], "end": [1165, 18], "kind": "commanddeclaration"}, {"full_name": "Set.comp_rangeSplitting", "code": "@[simp]\ntheorem comp_rangeSplitting (f : \u03b1 \u2192 \u03b2) : f \u2218 rangeSplitting f = (\u2191)", "start": [1168, 1], "end": [1172, 29], "kind": "commanddeclaration"}, {"full_name": "Set.leftInverse_rangeSplitting", "code": "theorem leftInverse_rangeSplitting (f : \u03b1 \u2192 \u03b2) :\n    LeftInverse (rangeFactorization f) (rangeSplitting f)", "start": [1176, 1], "end": [1180, 29], "kind": "commanddeclaration"}, {"full_name": "Set.rangeSplitting_injective", "code": "theorem rangeSplitting_injective (f : \u03b1 \u2192 \u03b2) : Injective (rangeSplitting f)", "start": [1183, 1], "end": [1184, 43], "kind": "commanddeclaration"}, {"full_name": "Set.rightInverse_rangeSplitting", "code": "theorem rightInverse_rangeSplitting {f : \u03b1 \u2192 \u03b2} (h : Injective f) :\n    RightInverse (rangeFactorization f) (rangeSplitting f)", "start": [1187, 1], "end": [1190, 31], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_rangeSplitting", "code": "theorem preimage_rangeSplitting {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    preimage (rangeSplitting f) = image (rangeFactorization f)", "start": [1193, 1], "end": [1196, 43], "kind": "commanddeclaration"}, {"full_name": "Set.isCompl_range_some_none", "code": "theorem isCompl_range_some_none (\u03b1 : Type*) : IsCompl (range (some : \u03b1 \u2192 Option \u03b1)) {none}", "start": [1199, 1], "end": [1201, 81], "kind": "commanddeclaration"}, {"full_name": "Set.compl_range_some", "code": "@[simp]\ntheorem compl_range_some (\u03b1 : Type*) : (range (some : \u03b1 \u2192 Option \u03b1))\u1d9c = {none}", "start": [1204, 1], "end": [1206, 39], "kind": "commanddeclaration"}, {"full_name": "Set.range_some_inter_none", "code": "@[simp]\ntheorem range_some_inter_none (\u03b1 : Type*) : range (some : \u03b1 \u2192 Option \u03b1) \u2229 {none} = \u2205", "start": [1209, 1], "end": [1211, 41], "kind": "commanddeclaration"}, {"full_name": "Set.range_some_union_none", "code": "theorem range_some_union_none (\u03b1 : Type*) : range (some : \u03b1 \u2192 Option \u03b1) \u222a {none} = univ", "start": [1216, 1], "end": [1217, 41], "kind": "commanddeclaration"}, {"full_name": "Set.insert_none_range_some", "code": "@[simp]\ntheorem insert_none_range_some (\u03b1 : Type*) : insert none (range (some : \u03b1 \u2192 Option \u03b1)) = univ", "start": [1220, 1], "end": [1222, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.image", "code": "theorem Subsingleton.image (hs : s.Subsingleton) (f : \u03b1 \u2192 \u03b2) : (f '' s).Subsingleton", "start": [1231, 1], "end": [1233, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.preimage", "code": "theorem Subsingleton.preimage {s : Set \u03b2} (hs : s.Subsingleton) {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) : (f \u207b\u00b9' s).Subsingleton", "start": [1236, 1], "end": [1238, 92], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_image", "code": "theorem subsingleton_of_image {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (s : Set \u03b1)\n    (hs : (f '' s).Subsingleton) : s.Subsingleton", "start": [1241, 1], "end": [1244, 53], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_of_preimage", "code": "theorem subsingleton_of_preimage {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} (hf : Function.Surjective f) (s : Set \u03b2)\n    (hs : (f \u207b\u00b9' s).Subsingleton) : s.Subsingleton", "start": [1247, 1], "end": [1252, 31], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_range", "code": "theorem subsingleton_range {\u03b1 : Sort*} [Subsingleton \u03b1] (f : \u03b1 \u2192 \u03b2) : (range f).Subsingleton", "start": [1255, 1], "end": [1256, 94], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.preimage", "code": "theorem Nontrivial.preimage {s : Set \u03b2} (hs : s.Nontrivial) {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Surjective f) : (f \u207b\u00b9' s).Nontrivial", "start": [1259, 1], "end": [1264, 45], "kind": "commanddeclaration"}, {"full_name": "Set.Nontrivial.image", "code": "theorem Nontrivial.image (hs : s.Nontrivial) {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) :\n    (f '' s).Nontrivial", "start": [1267, 1], "end": [1271, 70], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_image", "code": "theorem nontrivial_of_image (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (hs : (f '' s).Nontrivial) : s.Nontrivial", "start": [1274, 1], "end": [1277, 39], "kind": "commanddeclaration"}, {"full_name": "Set.nontrivial_of_preimage", "code": "theorem nontrivial_of_preimage {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (s : Set \u03b2)\n    (hs : (f \u207b\u00b9' s).Nontrivial) : s.Nontrivial", "start": [1280, 1], "end": [1283, 50], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.preimage_injective", "code": "theorem Surjective.preimage_injective (hf : Surjective f) : Injective (preimage f)", "start": [1296, 1], "end": [1297, 30], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.preimage_image", "code": "theorem Injective.preimage_image (hf : Injective f) (s : Set \u03b1) : f \u207b\u00b9' (f '' s) = s", "start": [1300, 1], "end": [1301, 25], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.preimage_surjective", "code": "theorem Injective.preimage_surjective (hf : Injective f) : Surjective (preimage f)", "start": [1304, 1], "end": [1307, 25], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.subsingleton_image_iff", "code": "theorem Injective.subsingleton_image_iff (hf : Injective f) {s : Set \u03b1} :\n    (f '' s).Subsingleton \u2194 s.Subsingleton", "start": [1310, 1], "end": [1312, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.image_preimage", "code": "theorem Surjective.image_preimage (hf : Surjective f) (s : Set \u03b2) : f '' (f \u207b\u00b9' s) = s", "start": [1315, 1], "end": [1316, 25], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.image_surjective", "code": "theorem Surjective.image_surjective (hf : Surjective f) : Surjective (image f)", "start": [1319, 1], "end": [1322, 25], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.nonempty_preimage", "code": "@[simp]\ntheorem Surjective.nonempty_preimage (hf : Surjective f) {s : Set \u03b2} :\n    (f \u207b\u00b9' s).Nonempty \u2194 s.Nonempty", "start": [1325, 1], "end": [1327, 87], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.image_injective", "code": "theorem Injective.image_injective (hf : Injective f) : Injective (image f)", "start": [1330, 1], "end": [1332, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.preimage_subset_preimage_iff", "code": "theorem Surjective.preimage_subset_preimage_iff {s t : Set \u03b2} (hf : Surjective f) :\n    f \u207b\u00b9' s \u2286 f \u207b\u00b9' t \u2194 s \u2286 t", "start": [1335, 1], "end": [1339, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.range_comp", "code": "theorem Surjective.range_comp {f : \u03b9 \u2192 \u03b9'} (hf : Surjective f) (g : \u03b9' \u2192 \u03b1) :\n    range (g \u2218 f) = range g", "start": [1342, 1], "end": [1344, 67], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.mem_range_iff_exists_unique", "code": "theorem Injective.mem_range_iff_exists_unique (hf : Injective f) {b : \u03b2} :\n    b \u2208 range f \u2194 \u2203! a, f a = b", "start": [1347, 1], "end": [1349, 80], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.exists_unique_of_mem_range", "code": "theorem Injective.exists_unique_of_mem_range (hf : Injective f) {b : \u03b2} (hb : b \u2208 range f) :\n    \u2203! a, f a = b", "start": [1352, 1], "end": [1354, 39], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.compl_image_eq", "code": "theorem Injective.compl_image_eq (hf : Injective f) (s : Set \u03b1) :\n    (f '' s)\u1d9c = f '' s\u1d9c \u222a (range f)\u1d9c", "start": [1357, 1], "end": [1363, 14], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.image_image", "code": "theorem LeftInverse.image_image {g : \u03b2 \u2192 \u03b1} (h : LeftInverse g f) (s : Set \u03b1) : g '' (f '' s) = s", "start": [1366, 1], "end": [1367, 47], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.preimage_preimage", "code": "theorem LeftInverse.preimage_preimage {g : \u03b2 \u2192 \u03b1} (h : LeftInverse g f) (s : Set \u03b1) :\n    f \u207b\u00b9' (g \u207b\u00b9' s) = s", "start": [1370, 1], "end": [1371, 78], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.preimage", "code": "protected theorem Involutive.preimage {f : \u03b1 \u2192 \u03b1} (hf : Involutive f) : Involutive (preimage f)", "start": [1374, 1], "end": [1375, 36], "kind": "commanddeclaration"}, {"full_name": "EquivLike.range_comp", "code": "@[simp] lemma range_comp (f : \u03b9' \u2192 \u03b1) (e : E) : range (f \u2218 e) = range f :=\n  (EquivLike.surjective _).range_comp _", "start": [1383, 1], "end": [1384, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Subtype.coe_image", "code": "theorem coe_image {p : \u03b1 \u2192 Prop} {s : Set (Subtype p)} :\n    (\u2191) '' s = { x | \u2203 h : p x, (\u27e8x, h\u27e9 : Subtype p) \u2208 s }", "start": [1396, 1], "end": [1399, 95], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_image_of_subset", "code": "@[simp]\ntheorem coe_image_of_subset {s t : Set \u03b1} (h : t \u2286 s) : (\u2191) '' { x : \u21a5s | \u2191x \u2208 t } = t", "start": [1402, 1], "end": [1406, 71], "kind": "commanddeclaration"}, {"full_name": "Subtype.range_coe", "code": "theorem range_coe {s : Set \u03b1} : range ((\u2191) : s \u2192 \u03b1) = s", "start": [1409, 1], "end": [1411, 36], "kind": "commanddeclaration"}, {"full_name": "Subtype.range_val", "code": "theorem range_val {s : Set \u03b1} : range (Subtype.val : s \u2192 \u03b1) = s", "start": [1414, 1], "end": [1418, 12], "kind": "commanddeclaration"}, {"full_name": "Subtype.range_coe_subtype", "code": "@[simp]\ntheorem range_coe_subtype {p : \u03b1 \u2192 Prop} : range ((\u2191) : Subtype p \u2192 \u03b1) = { x | p x }", "start": [1421, 1], "end": [1426, 12], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_preimage_self", "code": "@[simp]\ntheorem coe_preimage_self (s : Set \u03b1) : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' s = univ", "start": [1429, 1], "end": [1431, 35], "kind": "commanddeclaration"}, {"full_name": "Subtype.range_val_subtype", "code": "theorem range_val_subtype {p : \u03b1 \u2192 Prop} : range (Subtype.val : Subtype p \u2192 \u03b1) = { x | p x }", "start": [1434, 1], "end": [1435, 12], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_image_subset", "code": "theorem coe_image_subset (s : Set \u03b1) (t : Set s) : ((\u2191) : s \u2192 \u03b1) '' t \u2286 s", "start": [1438, 1], "end": [1440, 34], "kind": "commanddeclaration"}, {"full_name": "Subtype.coe_image_univ", "code": "theorem coe_image_univ (s : Set \u03b1) : ((\u2191) : s \u2192 \u03b1) '' Set.univ = s", "start": [1443, 1], "end": [1444, 29], "kind": "commanddeclaration"}, {"full_name": "Subtype.image_preimage_coe", "code": "@[simp]\ntheorem image_preimage_coe (s t : Set \u03b1) : ((\u2191) : s \u2192 \u03b1) '' (((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t) = t \u2229 s", "start": [1447, 1], "end": [1449, 63], "kind": "commanddeclaration"}, {"full_name": "Subtype.image_preimage_val", "code": "theorem image_preimage_val (s t : Set \u03b1) : (Subtype.val : s \u2192 \u03b1) '' (Subtype.val \u207b\u00b9' t) = t \u2229 s", "start": [1452, 1], "end": [1453, 25], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_eq_preimage_coe_iff", "code": "theorem preimage_coe_eq_preimage_coe_iff {s t u : Set \u03b1} :\n    ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t = ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' u \u2194 t \u2229 s = u \u2229 s", "start": [1456, 1], "end": [1458, 88], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_inter_self", "code": "theorem preimage_coe_inter_self (s t : Set \u03b1) :\n    ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' (t \u2229 s) = ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t", "start": [1463, 1], "end": [1465, 65], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_val_eq_preimage_val_iff", "code": "theorem preimage_val_eq_preimage_val_iff (s t u : Set \u03b1) :\n    (Subtype.val : s \u2192 \u03b1) \u207b\u00b9' t = Subtype.val \u207b\u00b9' u \u2194 t \u2229 s = u \u2229 s", "start": [1468, 1], "end": [1470, 35], "kind": "commanddeclaration"}, {"full_name": "Subtype.exists_set_subtype", "code": "theorem exists_set_subtype {t : Set \u03b1} (p : Set \u03b1 \u2192 Prop) :\n    (\u2203 s : Set t, p (((\u2191) : t \u2192 \u03b1) '' s)) \u2194 \u2203 s : Set \u03b1, s \u2286 t \u2227 p s", "start": [1473, 1], "end": [1475, 48], "kind": "commanddeclaration"}, {"full_name": "Subtype.forall_set_subtype", "code": "theorem forall_set_subtype {t : Set \u03b1} (p : Set \u03b1 \u2192 Prop) :\n    (\u2200 s : Set t, p (((\u2191) : t \u2192 \u03b1) '' s)) \u2194 \u2200 s : Set \u03b1, s \u2286 t \u2192 p s", "start": [1478, 1], "end": [1480, 44], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_nonempty", "code": "theorem preimage_coe_nonempty {s t : Set \u03b1} :\n    (((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t).Nonempty \u2194 (s \u2229 t).Nonempty", "start": [1482, 1], "end": [1484, 60], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_eq_empty", "code": "theorem preimage_coe_eq_empty {s t : Set \u03b1} : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t = \u2205 \u2194 s \u2229 t = \u2205", "start": [1487, 1], "end": [1488, 60], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_compl", "code": "theorem preimage_coe_compl (s : Set \u03b1) : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' s\u1d9c = \u2205", "start": [1493, 1], "end": [1494, 47], "kind": "commanddeclaration"}, {"full_name": "Subtype.preimage_coe_compl'", "code": "@[simp]\ntheorem preimage_coe_compl' (s : Set \u03b1) :\n    (fun x : (s\u1d9c : Set \u03b1) => (x : \u03b1)) \u207b\u00b9' s = \u2205", "start": [1497, 1], "end": [1500, 47], "kind": "commanddeclaration"}, {"full_name": "Option.injective_iff", "code": "theorem injective_iff {\u03b1 \u03b2} {f : Option \u03b1 \u2192 \u03b2} :\n    Injective f \u2194 Injective (f \u2218 some) \u2227 f none \u2209 range (f \u2218 some)", "start": [1512, 1], "end": [1518, 91], "kind": "commanddeclaration"}, {"full_name": "Option.range_eq", "code": "theorem range_eq {\u03b1 \u03b2} (f : Option \u03b1 \u2192 \u03b2) : range f = insert (f none) (range (f \u2218 some))", "start": [1521, 1], "end": [1522, 61], "kind": "commanddeclaration"}, {"full_name": "WithBot.range_eq", "code": "theorem WithBot.range_eq {\u03b1 \u03b2} (f : WithBot \u03b1 \u2192 \u03b2) :\n    range f = insert (f \u22a5) (range (f \u2218 WithBot.some : \u03b1 \u2192 \u03b2))", "start": [1527, 1], "end": [1529, 20], "kind": "commanddeclaration"}, {"full_name": "WithTop.range_eq", "code": "theorem WithTop.range_eq {\u03b1 \u03b2} (f : WithTop \u03b1 \u2192 \u03b2) :\n    range f = insert (f \u22a4) (range (f \u2218 WithBot.some : \u03b1 \u2192 \u03b2))", "start": [1532, 1], "end": [1534, 20], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_injective", "code": "@[simp]\ntheorem preimage_injective : Injective (preimage f) \u2194 Surjective f", "start": [1548, 1], "end": [1554, 16], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_surjective", "code": "@[simp]\ntheorem preimage_surjective : Surjective (preimage f) \u2194 Injective f", "start": [1557, 1], "end": [1561, 87], "kind": "commanddeclaration"}, {"full_name": "Set.image_surjective", "code": "@[simp]\ntheorem image_surjective : Surjective (image f) \u2194 Surjective f", "start": [1564, 1], "end": [1569, 16], "kind": "commanddeclaration"}, {"full_name": "Set.image_injective", "code": "@[simp]\ntheorem image_injective : Injective (image f) \u2194 Injective f", "start": [1572, 1], "end": [1576, 44], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_eq_iff_eq_image", "code": "theorem preimage_eq_iff_eq_image {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} : f \u207b\u00b9' s = t \u2194 s = f '' t", "start": [1579, 1], "end": [1580, 53], "kind": "commanddeclaration"}, {"full_name": "Set.eq_preimage_iff_image_eq", "code": "theorem eq_preimage_iff_image_eq {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} : s = f \u207b\u00b9' t \u2194 f '' s = t", "start": [1583, 1], "end": [1584, 53], "kind": "commanddeclaration"}, {"full_name": "Disjoint.preimage", "code": "theorem Disjoint.preimage (f : \u03b1 \u2192 \u03b2) {s t : Set \u03b2} (h : Disjoint s t) :\n    Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)", "start": [1596, 1], "end": [1598, 50], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_image_image", "code": "theorem disjoint_image_image {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1} {s : Set \u03b2} {t : Set \u03b3}\n    (h : \u2200 b \u2208 s, \u2200 c \u2208 t, f b \u2260 g c) : Disjoint (f '' s) (g '' t)", "start": [1603, 1], "end": [1605, 89], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_image_of_injective", "code": "theorem disjoint_image_of_injective (hf : Injective f) {s t : Set \u03b1} (hd : Disjoint s t) :\n    Disjoint (f '' s) (f '' t)", "start": [1608, 1], "end": [1610, 95], "kind": "commanddeclaration"}, {"full_name": "Disjoint.of_image", "code": "theorem _root_.Disjoint.of_image (h : Disjoint (f '' s) (f '' t)) : Disjoint s t", "start": [1613, 1], "end": [1615, 74], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_image_iff", "code": "@[simp]\ntheorem disjoint_image_iff (hf : Injective f) : Disjoint (f '' s) (f '' t) \u2194 Disjoint s t", "start": [1618, 1], "end": [1620, 54], "kind": "commanddeclaration"}, {"full_name": "Disjoint.of_preimage", "code": "theorem _root_.Disjoint.of_preimage (hf : Surjective f) {s t : Set \u03b2}\n    (h : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)) : Disjoint s t", "start": [1623, 1], "end": [1626, 17], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_preimage_iff", "code": "@[simp]\ntheorem disjoint_preimage_iff (hf : Surjective f) {s t : Set \u03b2} :\n    Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t) \u2194 Disjoint s t", "start": [1629, 1], "end": [1632, 49], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_eq_empty", "code": "theorem preimage_eq_empty {s : Set \u03b2} (h : Disjoint s (range f)) :\n    f \u207b\u00b9' s = \u2205", "start": [1635, 1], "end": [1637, 30], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_eq_empty_iff", "code": "theorem preimage_eq_empty_iff {s : Set \u03b2} : f \u207b\u00b9' s = \u2205 \u2194 Disjoint s (range f)", "start": [1640, 1], "end": [1647, 21], "kind": "commanddeclaration"}, {"full_name": "sigma_mk_preimage_image'", "code": "lemma sigma_mk_preimage_image' (h : i \u2260 j) : Sigma.mk j \u207b\u00b9' (Sigma.mk i '' s) = \u2205 := by\n  simp [image, h]", "start": [1658, 1], "end": [1659, 18], "kind": "mathlibtacticlemma"}, {"full_name": "sigma_mk_preimage_image_eq_self", "code": "lemma sigma_mk_preimage_image_eq_self : Sigma.mk i \u207b\u00b9' (Sigma.mk i '' s) = s := by\n  simp [image]", "start": [1661, 1], "end": [1662, 15], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Int/Order/Basic.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Algebra/Order/Ring/CharZero.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean"], "premises": [{"full_name": "Int.linearOrderedCommRing", "code": "instance linearOrderedCommRing : LinearOrderedCommRing \u2124 :=\n  { instCommRingInt, instLinearOrderInt, instNontrivialInt with\n    add_le_add_left := @Int.add_le_add_left,\n    mul_pos := @Int.mul_pos, zero_le_one := le_of_lt Int.zero_lt_one }", "start": [35, 1], "end": [38, 71], "kind": "commanddeclaration"}, {"full_name": "Int.orderedCommRing", "code": "instance orderedCommRing : OrderedCommRing \u2124 :=\n  StrictOrderedCommRing.toOrderedCommRing'", "start": [44, 1], "end": [45, 43], "kind": "commanddeclaration"}, {"full_name": "Int.orderedRing", "code": "instance orderedRing : OrderedRing \u2124 :=\n  StrictOrderedRing.toOrderedRing'", "start": [47, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "Int.linearOrderedAddCommGroup", "code": "instance linearOrderedAddCommGroup : LinearOrderedAddCommGroup \u2124 := by infer_instance", "start": [50, 1], "end": [50, 86], "kind": "commanddeclaration"}, {"full_name": "Int.abs_eq_natAbs", "code": "theorem abs_eq_natAbs : \u2200 a : \u2124, |a| = natAbs a", "start": [56, 1], "end": [58, 61], "kind": "commanddeclaration"}, {"full_name": "Int.coe_natAbs", "code": "@[simp, norm_cast] lemma coe_natAbs (n : \u2124) : (n.natAbs : \u2124) = |n| := n.abs_eq_natAbs.symm", "start": [61, 1], "end": [61, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.cast_natAbs", "code": "lemma _root_.Nat.cast_natAbs {\u03b1 : Type*} [AddGroupWithOne \u03b1] (n : \u2124) : (n.natAbs : \u03b1) = |n| :=\n  by rw [\u2190coe_natAbs, Int.cast_ofNat]", "start": [64, 1], "end": [65, 38], "kind": "mathlibtacticlemma"}, {"full_name": "Int.natAbs_abs", "code": "theorem natAbs_abs (a : \u2124) : natAbs |a| = natAbs a", "start": [68, 1], "end": [68, 81], "kind": "commanddeclaration"}, {"full_name": "Int.sign_mul_abs", "code": "theorem sign_mul_abs (a : \u2124) : sign a * |a| = a", "start": [71, 1], "end": [72, 40], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_eq_zero", "code": "theorem coe_nat_eq_zero {n : \u2115} : (n : \u2124) = 0 \u2194 n = 0", "start": [75, 1], "end": [76, 19], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_ne_zero", "code": "theorem coe_nat_ne_zero {n : \u2115} : (n : \u2124) \u2260 0 \u2194 n \u2260 0", "start": [79, 1], "end": [79, 65], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_ne_zero_iff_pos", "code": "theorem coe_nat_ne_zero_iff_pos {n : \u2115} : (n : \u2124) \u2260 0 \u2194 0 < n", "start": [82, 1], "end": [84, 51], "kind": "commanddeclaration"}, {"full_name": "Int.abs_coe_nat", "code": "@[norm_cast] lemma abs_coe_nat (n : \u2115) : |(n : \u2124)| = n := abs_of_nonneg (coe_nat_nonneg n)", "start": [87, 1], "end": [87, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Int.sign_add_eq_of_sign_eq", "code": "theorem sign_add_eq_of_sign_eq : \u2200 {m n : \u2124}, m.sign = n.sign \u2192 (m + n).sign = n.sign", "start": [90, 1], "end": [94, 97], "kind": "commanddeclaration"}, {"full_name": "Int.lt_succ_self", "code": "theorem lt_succ_self (a : \u2124) : a < succ a", "start": [100, 1], "end": [101, 36], "kind": "commanddeclaration"}, {"full_name": "Int.pred_self_lt", "code": "theorem pred_self_lt (a : \u2124) : pred a < a", "start": [104, 1], "end": [105, 28], "kind": "commanddeclaration"}, {"full_name": "Int.sub_one_lt_iff", "code": "theorem sub_one_lt_iff {a b : \u2124} : a - 1 < b \u2194 a \u2264 b", "start": [111, 1], "end": [112, 41], "kind": "commanddeclaration"}, {"full_name": "Int.le_sub_one_iff", "code": "theorem le_sub_one_iff {a b : \u2124} : a \u2264 b - 1 \u2194 a < b", "start": [115, 1], "end": [116, 20], "kind": "commanddeclaration"}, {"full_name": "Int.abs_lt_one_iff", "code": "@[simp]\ntheorem abs_lt_one_iff {a : \u2124} : |a| < 1 \u2194 a = 0", "start": [119, 1], "end": [126, 60], "kind": "commanddeclaration"}, {"full_name": "Int.abs_le_one_iff", "code": "theorem abs_le_one_iff {a : \u2124} : |a| \u2264 1 \u2194 a = 0 \u2228 a = 1 \u2228 a = -1", "start": [129, 1], "end": [130, 64], "kind": "commanddeclaration"}, {"full_name": "Int.one_le_abs", "code": "theorem one_le_abs {z : \u2124} (h\u2080 : z \u2260 0) : 1 \u2264 |z|", "start": [133, 1], "end": [134, 38], "kind": "commanddeclaration"}, {"full_name": "Int.inductionOn'", "code": "@[elab_as_elim] protected def inductionOn' {C : \u2124 \u2192 Sort*}\n    (z : \u2124) (b : \u2124) (H0 : C b) (Hs : \u2200 k, b \u2264 k \u2192 C k \u2192 C (k + 1))\n    (Hp : \u2200 k \u2264 b, C k \u2192 C (k - 1)) : C z := by\n  rw [\u2190 sub_add_cancel (G := \u2124) z b, add_comm]\n  exact match z - b with\n  | .ofNat n => pos n\n  | .negSucc n => neg n\nwhere\n  \n  pos : \u2200 n : \u2115, C (b + n)\n  | 0 => _root_.cast (by erw [add_zero]) H0\n  | n+1 => _root_.cast (by rw [add_assoc]; rfl) <|\n    Hs _ (Int.le_add_of_nonneg_right (ofNat_nonneg _)) (pos n)\n\n  \n  neg : \u2200 n : \u2115, C (b + -[n+1])\n  | 0 => Hp _ (Int.le_refl _) H0\n  | n+1 => by\n    refine _root_.cast (by rw [add_sub_assoc]; rfl) (Hp _ (Int.le_of_lt ?_) (neg n))\n    conv => rhs; apply (add_zero b).symm\n    rw [Int.add_lt_add_iff_left]; apply negSucc_lt_zero", "start": [137, 1], "end": [159, 56], "kind": "commanddeclaration"}, {"full_name": "Int.le_induction", "code": "protected theorem le_induction {P : \u2124 \u2192 Prop} {m : \u2124} (h0 : P m)\n    (h1 : \u2200 n : \u2124, m \u2264 n \u2192 P n \u2192 P (n + 1)) (n : \u2124) : m \u2264 n \u2192 P n", "start": [162, 1], "end": [172, 59], "kind": "commanddeclaration"}, {"full_name": "Int.le_induction_down", "code": "protected theorem le_induction_down {P : \u2124 \u2192 Prop} {m : \u2124} (h0 : P m)\n    (h1 : \u2200 n : \u2124, n \u2264 m \u2192 P n \u2192 P (n - 1)) (n : \u2124) : n \u2264 m \u2192 P n", "start": [175, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_zero_of_lt_abs", "code": "theorem ediv_eq_zero_of_lt_abs {a b : \u2124} (H1 : 0 \u2264 a) (H2 : a < |b|) : a / b = 0", "start": [201, 1], "end": [204, 98], "kind": "commanddeclaration"}, {"full_name": "Int.emod_abs", "code": "@[simp]\ntheorem emod_abs (a b : \u2124) : a % |b| = a % b", "start": [226, 1], "end": [228, 59], "kind": "commanddeclaration"}, {"full_name": "Int.emod_lt", "code": "theorem emod_lt (a : \u2124) {b : \u2124} (H : b \u2260 0) : a % b < |b|", "start": [235, 1], "end": [236, 56], "kind": "commanddeclaration"}, {"full_name": "Int.add_emod_eq_add_mod_right", "code": "theorem add_emod_eq_add_mod_right {m n k : \u2124} (i : \u2124) (H : m % n = k % n) :\n    (m + i) % n = (k + i) % n", "start": [253, 1], "end": [254, 79], "kind": "commanddeclaration"}, {"full_name": "Int.neg_emod_two", "code": "@[simp]\ntheorem neg_emod_two (i : \u2124) : -i % 2 = i % 2", "start": [287, 1], "end": [291, 31], "kind": "commanddeclaration"}, {"full_name": "Int.abs_ediv_le_abs", "code": "theorem abs_ediv_le_abs : \u2200 a b : \u2124, |a / b| \u2264 |a|", "start": [298, 1], "end": [310, 67], "kind": "commanddeclaration"}, {"full_name": "Int.emod_two_eq_zero_or_one", "code": "theorem emod_two_eq_zero_or_one (n : \u2124) : n % 2 = 0 \u2228 n % 2 = 1", "start": [315, 1], "end": [327, 33], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_dvd_ediv", "code": "theorem ediv_dvd_ediv : \u2200 {a b c : \u2124} (_ : a \u2223 b) (_ : b \u2223 c), b / a \u2223 c / a", "start": [350, 1], "end": [355, 28], "kind": "commanddeclaration"}, {"full_name": "Int.abs_sign_of_nonzero", "code": "theorem abs_sign_of_nonzero {z : \u2124} (hz : z \u2260 0) : |z.sign| = 1", "start": [376, 1], "end": [377, 63], "kind": "commanddeclaration"}, {"full_name": "Int.exists_lt_and_lt_iff_not_dvd", "code": "theorem exists_lt_and_lt_iff_not_dvd (m : \u2124) {n : \u2124} (hn : 0 < n) :\n    (\u2203 k, n * k < m \u2227 m < n * (k + 1)) \u2194 \u00acn \u2223 m", "start": [380, 1], "end": [395, 51], "kind": "commanddeclaration"}, {"full_name": "Int.sign_eq_ediv_abs", "code": "protected theorem sign_eq_ediv_abs (a : \u2124) : sign a = a / |a|", "start": [410, 1], "end": [412, 85], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_mul_le", "code": "protected theorem ediv_mul_le (a : \u2124) {b : \u2124} (H : b \u2260 0) : a / b * b \u2264 a", "start": [418, 1], "end": [419, 74], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_le_of_le_mul", "code": "protected theorem ediv_le_of_le_mul {a b c : \u2124} (H : 0 < c) (H' : a \u2264 b * c) : a / c \u2264 b", "start": [422, 1], "end": [423, 74], "kind": "commanddeclaration"}, {"full_name": "Int.mul_lt_of_lt_ediv", "code": "protected theorem mul_lt_of_lt_ediv {a b c : \u2124} (H : 0 < c) (H3 : a < b / c) : a * c < b", "start": [426, 1], "end": [427, 65], "kind": "commanddeclaration"}, {"full_name": "Int.mul_le_of_le_ediv", "code": "protected theorem mul_le_of_le_ediv {a b c : \u2124} (H1 : 0 < c) (H2 : a \u2264 b / c) : a * c \u2264 b", "start": [430, 1], "end": [431, 91], "kind": "commanddeclaration"}, {"full_name": "Int.le_ediv_of_mul_le", "code": "protected theorem le_ediv_of_mul_le {a b c : \u2124} (H1 : 0 < c) (H2 : a * c \u2264 b) : a \u2264 b / c", "start": [434, 1], "end": [436, 93], "kind": "commanddeclaration"}, {"full_name": "Int.le_ediv_iff_mul_le", "code": "protected theorem le_ediv_iff_mul_le {a b c : \u2124} (H : 0 < c) : a \u2264 b / c \u2194 a * c \u2264 b", "start": [439, 1], "end": [440, 53], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_le_ediv", "code": "protected theorem ediv_le_ediv {a b c : \u2124} (H : 0 < c) (H' : a \u2264 b) : a / c \u2264 b / c", "start": [443, 1], "end": [444, 73], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_lt_of_lt_mul", "code": "protected theorem ediv_lt_of_lt_mul {a b c : \u2124} (H : 0 < c) (H' : a < b * c) : a / c < b", "start": [447, 1], "end": [448, 65], "kind": "commanddeclaration"}, {"full_name": "Int.lt_mul_of_ediv_lt", "code": "protected theorem lt_mul_of_ediv_lt {a b c : \u2124} (H1 : 0 < c) (H2 : a / c < b) : a < b * c", "start": [451, 1], "end": [452, 66], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_lt_iff_lt_mul", "code": "protected theorem ediv_lt_iff_lt_mul {a b c : \u2124} (H : 0 < c) : a / c < b \u2194 a < b * c", "start": [455, 1], "end": [456, 53], "kind": "commanddeclaration"}, {"full_name": "Int.le_mul_of_ediv_le", "code": "protected theorem le_mul_of_ediv_le {a b c : \u2124} (H1 : 0 \u2264 b) (H2 : b \u2223 a) (H3 : a / b \u2264 c) :\n    a \u2264 c * b", "start": [459, 1], "end": [460, 90], "kind": "commanddeclaration"}, {"full_name": "Int.lt_ediv_of_mul_lt", "code": "protected theorem lt_ediv_of_mul_lt {a b c : \u2124} (H1 : 0 \u2264 b) (H2 : b \u2223 c) (H3 : a * b < c) :\n    a < c / b", "start": [463, 1], "end": [465, 69], "kind": "commanddeclaration"}, {"full_name": "Int.lt_ediv_iff_mul_lt", "code": "protected theorem lt_ediv_iff_mul_lt {a b : \u2124} (c : \u2124) (H : 0 < c) (H' : c \u2223 b) :\n    a < b / c \u2194 a * c < b", "start": [468, 1], "end": [470, 67], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_pos_of_pos_of_dvd", "code": "theorem ediv_pos_of_pos_of_dvd {a b : \u2124} (H1 : 0 < a) (H2 : 0 \u2264 b) (H3 : b \u2223 a) : 0 < a / b", "start": [473, 1], "end": [474, 50], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq_of_dvd_dvd", "code": "theorem natAbs_eq_of_dvd_dvd {s t : \u2124} (hst : s \u2223 t) (hts : t \u2223 s) : natAbs s = natAbs t", "start": [477, 1], "end": [478, 75], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_eq_ediv_of_mul_eq_mul", "code": "theorem ediv_eq_ediv_of_mul_eq_mul {a b c d : \u2124} (H2 : d \u2223 c) (H3 : b \u2260 0) (H4 : d \u2260 0)\n    (H5 : a * d = b * c) : a / b = c / d", "start": [481, 1], "end": [484, 87], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_dvd_of_dvd", "code": "theorem ediv_dvd_of_dvd {s t : \u2124} (hst : s \u2223 t) : t / s \u2223 t", "start": [487, 1], "end": [491, 43], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_le", "code": "@[simp]\ntheorem toNat_le {a : \u2124} {n : \u2115} : toNat a \u2264 n \u2194 a \u2264 n", "start": [497, 1], "end": [499, 85], "kind": "commanddeclaration"}, {"full_name": "Int.lt_toNat", "code": "@[simp]\ntheorem lt_toNat {n : \u2115} {a : \u2124} : n < toNat a \u2194 (n : \u2124) < a", "start": [502, 1], "end": [504, 37], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_nonpos_iff", "code": "@[simp]\ntheorem coe_nat_nonpos_iff {n : \u2115} : (n : \u2124) \u2264 0 \u2194 n = 0", "start": [507, 1], "end": [510, 40], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_le_toNat", "code": "theorem toNat_le_toNat {a b : \u2124} (h : a \u2264 b) : toNat a \u2264 toNat b", "start": [513, 1], "end": [514, 52], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_lt_toNat", "code": "theorem toNat_lt_toNat {a b : \u2124} (hb : 0 < b) : toNat a < toNat b \u2194 a < b", "start": [517, 1], "end": [519, 58], "kind": "commanddeclaration"}, {"full_name": "Int.lt_of_toNat_lt", "code": "theorem lt_of_toNat_lt {a b : \u2124} (h : toNat a < toNat b) : a < b", "start": [522, 1], "end": [523, 73], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_pred_coe_of_pos", "code": "@[simp]\ntheorem toNat_pred_coe_of_pos {i : \u2124} (h : 0 < i) : ((i.toNat - 1 : \u2115) : \u2124) = i - 1", "start": [526, 1], "end": [528, 34], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_eq_zero", "code": "@[simp]\ntheorem toNat_eq_zero : \u2200 {n : \u2124}, n.toNat = 0 \u2194 n \u2264 0", "start": [531, 1], "end": [542, 85], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_sub_of_le", "code": "@[simp]\ntheorem toNat_sub_of_le {a b : \u2124} (h : b \u2264 a) : (toNat (a - b) : \u2124) = a - b", "start": [546, 1], "end": [548, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Forall2.lean", "imports": ["Mathlib/Data/List/Infix.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.forall\u2082_cons", "code": "@[simp]\ntheorem forall\u2082_cons {a b l\u2081 l\u2082} : Forall\u2082 R (a :: l\u2081) (b :: l\u2082) \u2194 R a b \u2227 Forall\u2082 R l\u2081 l\u2082", "start": [33, 1], "end": [36, 24], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.imp", "code": "theorem Forall\u2082.imp (H : \u2200 a b, R a b \u2192 S a b) {l\u2081 l\u2082} (h : Forall\u2082 R l\u2081 l\u2082) : Forall\u2082 S l\u2081 l\u2082", "start": [39, 1], "end": [40, 48], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.mp", "code": "theorem Forall\u2082.mp {Q : \u03b1 \u2192 \u03b2 \u2192 Prop} (h : \u2200 a b, Q a b \u2192 R a b \u2192 S a b) :\n    \u2200 {l\u2081 l\u2082}, Forall\u2082 Q l\u2081 l\u2082 \u2192 Forall\u2082 R l\u2081 l\u2082 \u2192 Forall\u2082 S l\u2081 l\u2082", "start": [43, 1], "end": [47, 54], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.flip", "code": "theorem Forall\u2082.flip : \u2200 {a b}, Forall\u2082 (flip R) b a \u2192 Forall\u2082 R a b", "start": [50, 1], "end": [52, 66], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_same", "code": "@[simp]\ntheorem forall\u2082_same : \u2200 {l : List \u03b1}, Forall\u2082 R\u2090 l l \u2194 \u2200 x \u2208 l, R\u2090 x x", "start": [55, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_refl", "code": "theorem forall\u2082_refl [IsRefl \u03b1 R\u2090] (l : List \u03b1) : Forall\u2082 R\u2090 l l", "start": [61, 1], "end": [62, 35], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_eq_eq_eq", "code": "@[simp]\ntheorem forall\u2082_eq_eq_eq : Forall\u2082 ((\u00b7 = \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) = Eq", "start": [65, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_nil_left_iff", "code": "@[simp]\ntheorem forall\u2082_nil_left_iff {l} : Forall\u2082 R nil l \u2194 l = nil", "start": [77, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_nil_right_iff", "code": "@[simp]\ntheorem forall\u2082_nil_right_iff {l} : Forall\u2082 R l nil \u2194 l = nil", "start": [82, 1], "end": [84, 63], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_cons_left_iff", "code": "theorem forall\u2082_cons_left_iff {a l u} :\n    Forall\u2082 R (a :: l) u \u2194 \u2203 b u', R a b \u2227 Forall\u2082 R l u' \u2227 u = b :: u'", "start": [87, 1], "end": [95, 51], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_cons_right_iff", "code": "theorem forall\u2082_cons_right_iff {b l u} :\n    Forall\u2082 R u (b :: l) \u2194 \u2203 a u', R a b \u2227 Forall\u2082 R u' l \u2227 u = a :: u'", "start": [98, 1], "end": [106, 51], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_and_left", "code": "theorem forall\u2082_and_left {p : \u03b1 \u2192 Prop} :\n    \u2200 l u, Forall\u2082 (fun a b => p a \u2227 R a b) l u \u2194 (\u2200 a \u2208 l, p a) \u2227 Forall\u2082 R l u", "start": [109, 1], "end": [117, 71], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_map_left_iff", "code": "@[simp]\ntheorem forall\u2082_map_left_iff {f : \u03b3 \u2192 \u03b1} :\n    \u2200 {l u}, Forall\u2082 R (map f l) u \u2194 Forall\u2082 (fun c b => R (f c) b) l u", "start": [120, 1], "end": [124, 81], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_map_right_iff", "code": "@[simp]\ntheorem forall\u2082_map_right_iff {f : \u03b3 \u2192 \u03b2} :\n    \u2200 {l u}, Forall\u2082 R l (map f u) \u2194 Forall\u2082 (fun a c => R a (f c)) l u", "start": [127, 1], "end": [131, 83], "kind": "commanddeclaration"}, {"full_name": "List.left_unique_forall\u2082'", "code": "theorem left_unique_forall\u2082' (hr : LeftUnique R) : \u2200 {a b c}, Forall\u2082 R a c \u2192 Forall\u2082 R b c \u2192 a = b", "start": [134, 1], "end": [137, 53], "kind": "commanddeclaration"}, {"full_name": "Relator.LeftUnique.forall\u2082", "code": "theorem _root_.Relator.LeftUnique.forall\u2082 (hr : LeftUnique R) : LeftUnique (Forall\u2082 R)", "start": [140, 1], "end": [141, 33], "kind": "commanddeclaration"}, {"full_name": "List.right_unique_forall\u2082'", "code": "theorem right_unique_forall\u2082' (hr : RightUnique R) :\n    \u2200 {a b c}, Forall\u2082 R a b \u2192 Forall\u2082 R a c \u2192 b = c", "start": [144, 1], "end": [148, 54], "kind": "commanddeclaration"}, {"full_name": "Relator.RightUnique.forall\u2082", "code": "theorem _root_.Relator.RightUnique.forall\u2082 (hr : RightUnique R) : RightUnique (Forall\u2082 R)", "start": [151, 1], "end": [152, 34], "kind": "commanddeclaration"}, {"full_name": "Relator.BiUnique.forall\u2082", "code": "theorem _root_.Relator.BiUnique.forall\u2082 (hr : BiUnique R) : BiUnique (Forall\u2082 R)", "start": [155, 1], "end": [156, 38], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.length_eq", "code": "theorem Forall\u2082.length_eq : \u2200 {l\u2081 l\u2082}, Forall\u2082 R l\u2081 l\u2082 \u2192 length l\u2081 = length l\u2082", "start": [159, 1], "end": [161, 69], "kind": "commanddeclaration"}, {"full_name": "List.Forall\u2082.nthLe", "code": "theorem Forall\u2082.nthLe :\n    \u2200 {x : List \u03b1} {y : List \u03b2} (_ : Forall\u2082 R x y) \u2983i : \u2115\u2984 (hx : i < x.length) (hy : i < y.length),\n      R (x.nthLe i hx) (y.nthLe i hy)", "start": [164, 1], "end": [168, 58], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_of_length_eq_of_nthLe", "code": "theorem forall\u2082_of_length_eq_of_nthLe :\n    \u2200 {x : List \u03b1} {y : List \u03b2},\n      x.length = y.length \u2192 (\u2200 i h\u2081 h\u2082, R (x.nthLe i h\u2081) (y.nthLe i h\u2082)) \u2192 Forall\u2082 R x y", "start": [171, 1], "end": [178, 54], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_iff_nthLe", "code": "theorem forall\u2082_iff_nthLe {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} :\n    Forall\u2082 R l\u2081 l\u2082 \u2194 l\u2081.length = l\u2082.length \u2227 \u2200 i h\u2081 h\u2082, R (l\u2081.nthLe i h\u2081) (l\u2082.nthLe i h\u2082)", "start": [181, 1], "end": [183, 84], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_zip", "code": "theorem forall\u2082_zip : \u2200 {l\u2081 l\u2082}, Forall\u2082 R l\u2081 l\u2082 \u2192 \u2200 {a b}, (a, b) \u2208 zip l\u2081 l\u2082 \u2192 R a b", "start": [186, 1], "end": [191, 43], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_iff_zip", "code": "theorem forall\u2082_iff_zip {l\u2081 l\u2082} :\n    Forall\u2082 R l\u2081 l\u2082 \u2194 length l\u2081 = length l\u2082 \u2227 \u2200 {a b}, (a, b) \u2208 zip l\u2081 l\u2082 \u2192 R a b", "start": [194, 1], "end": [207, 34], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_take", "code": "theorem forall\u2082_take : \u2200 (n) {l\u2081 l\u2082}, Forall\u2082 R l\u2081 l\u2082 \u2192 Forall\u2082 R (take n l\u2081) (take n l\u2082)", "start": [210, 1], "end": [213, 81], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_drop", "code": "theorem forall\u2082_drop : \u2200 (n) {l\u2081 l\u2082}, Forall\u2082 R l\u2081 l\u2082 \u2192 Forall\u2082 R (drop n l\u2081) (drop n l\u2082)", "start": [216, 1], "end": [219, 81], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_take_append", "code": "theorem forall\u2082_take_append (l : List \u03b1) (l\u2081 : List \u03b2) (l\u2082 : List \u03b2) (h : Forall\u2082 R l (l\u2081 ++ l\u2082)) :\n    Forall\u2082 R (List.take (length l\u2081) l) l\u2081", "start": [222, 1], "end": [226, 24], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_drop_append", "code": "theorem forall\u2082_drop_append (l : List \u03b1) (l\u2081 : List \u03b2) (l\u2082 : List \u03b2) (h : Forall\u2082 R l (l\u2081 ++ l\u2082)) :\n    Forall\u2082 R (List.drop (length l\u2081) l) l\u2082", "start": [229, 1], "end": [233, 24], "kind": "commanddeclaration"}, {"full_name": "List.rel_mem", "code": "theorem rel_mem (hr : BiUnique R) : (R \u21d2 Forall\u2082 R \u21d2 Iff) (\u00b7 \u2208 \u00b7) (\u00b7 \u2208 \u00b7)", "start": [236, 1], "end": [240, 52], "kind": "commanddeclaration"}, {"full_name": "List.rel_map", "code": "theorem rel_map : ((R \u21d2 P) \u21d2 Forall\u2082 R \u21d2 Forall\u2082 P) map map", "start": [243, 1], "end": [245, 89], "kind": "commanddeclaration"}, {"full_name": "List.rel_append", "code": "theorem rel_append : (Forall\u2082 R \u21d2 Forall\u2082 R \u21d2 Forall\u2082 R) (\u00b7 ++ \u00b7) (\u00b7 ++ \u00b7)", "start": [248, 1], "end": [250, 77], "kind": "commanddeclaration"}, {"full_name": "List.rel_reverse", "code": "theorem rel_reverse : (Forall\u2082 R \u21d2 Forall\u2082 R) reverse reverse", "start": [253, 1], "end": [257, 68], "kind": "commanddeclaration"}, {"full_name": "List.forall\u2082_reverse_iff", "code": "@[simp]\ntheorem forall\u2082_reverse_iff {l\u2081 l\u2082} : Forall\u2082 R (reverse l\u2081) (reverse l\u2082) \u2194 Forall\u2082 R l\u2081 l\u2082", "start": [260, 1], "end": [266, 27], "kind": "commanddeclaration"}, {"full_name": "List.rel_join", "code": "theorem rel_join : (Forall\u2082 (Forall\u2082 R) \u21d2 Forall\u2082 R) join join", "start": [269, 1], "end": [271, 60], "kind": "commanddeclaration"}, {"full_name": "List.rel_bind", "code": "theorem rel_bind : (Forall\u2082 R \u21d2 (R \u21d2 Forall\u2082 P) \u21d2 Forall\u2082 P) List.bind List.bind", "start": [274, 1], "end": [275, 51], "kind": "commanddeclaration"}, {"full_name": "List.rel_foldl", "code": "theorem rel_foldl : ((P \u21d2 R \u21d2 P) \u21d2 P \u21d2 Forall\u2082 R \u21d2 P) foldl foldl", "start": [278, 1], "end": [280, 89], "kind": "commanddeclaration"}, {"full_name": "List.rel_foldr", "code": "theorem rel_foldr : ((R \u21d2 P \u21d2 P) \u21d2 P \u21d2 Forall\u2082 R \u21d2 P) foldr foldr", "start": [283, 1], "end": [285, 89], "kind": "commanddeclaration"}, {"full_name": "List.rel_filter", "code": "theorem rel_filter {p : \u03b1 \u2192 Bool} {q : \u03b2 \u2192 Bool}\n    (hpq : (R \u21d2 (\u00b7 \u2194 \u00b7)) (fun x => p x) (fun x => q x)) :\n    (Forall\u2082 R \u21d2 Forall\u2082 R) (filter p) (filter q)", "start": [288, 1], "end": [299, 87], "kind": "commanddeclaration"}, {"full_name": "List.rel_filterMap", "code": "theorem rel_filterMap : ((R \u21d2 Option.Rel P) \u21d2 Forall\u2082 R \u21d2 Forall\u2082 P) filterMap filterMap", "start": [302, 1], "end": [309, 76], "kind": "commanddeclaration"}, {"full_name": "List.rel_prod", "code": "@[to_additive]\ntheorem rel_prod [Monoid \u03b1] [Monoid \u03b2] (h : R 1 1) (hf : (R \u21d2 R \u21d2 R) (\u00b7 * \u00b7) (\u00b7 * \u00b7)) :\n    (Forall\u2082 R \u21d2 R) prod prod", "start": [312, 1], "end": [315, 17], "kind": "commanddeclaration"}, {"full_name": "List.SublistForall\u2082", "code": "inductive SublistForall\u2082 (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : List \u03b1 \u2192 List \u03b2 \u2192 Prop\n  | nil {l} : SublistForall\u2082 R [] l\n  | cons {a\u2081 a\u2082 l\u2081 l\u2082} : R a\u2081 a\u2082 \u2192 SublistForall\u2082 R l\u2081 l\u2082 \u2192 SublistForall\u2082 R (a\u2081 :: l\u2081) (a\u2082 :: l\u2082)\n  | cons_right {a l\u2081 l\u2082} : SublistForall\u2082 R l\u2081 l\u2082 \u2192 SublistForall\u2082 R l\u2081 (a :: l\u2082)", "start": [319, 1], "end": [324, 82], "kind": "commanddeclaration"}, {"full_name": "List.sublistForall\u2082_iff", "code": "theorem sublistForall\u2082_iff {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} :\n    SublistForall\u2082 R l\u2081 l\u2082 \u2194 \u2203 l, Forall\u2082 R l\u2081 l \u2227 l <+ l\u2082", "start": [330, 1], "end": [346, 43], "kind": "commanddeclaration"}, {"full_name": "List.SublistForall\u2082.is_refl", "code": "instance SublistForall\u2082.is_refl [IsRefl \u03b1 R\u2090] : IsRefl (List \u03b1) (SublistForall\u2082 R\u2090) :=\n  \u27e8fun l => sublistForall\u2082_iff.2 \u27e8l, forall\u2082_refl l, Sublist.refl l\u27e9\u27e9", "start": [349, 1], "end": [350, 70], "kind": "commanddeclaration"}, {"full_name": "List.SublistForall\u2082.is_trans", "code": "instance SublistForall\u2082.is_trans [IsTrans \u03b1 R\u2090] : IsTrans (List \u03b1) (SublistForall\u2082 R\u2090) :=\n  \u27e8fun a b c => by\n    revert a b\n    induction' c with _ _ ih\n    \u00b7 rintro _ _ h1 h2\n      cases h2\n      exact h1\n    \u00b7 rintro a b h1 h2\n      cases' h2 with _ _ _ _ _ hbc tbc _ _ y1 btc\n      \u00b7 cases h1\n        exact SublistForall\u2082.nil\n      \u00b7 cases' h1 with _ _ _ _ _ hab tab _ _ _ atb\n        \u00b7 exact SublistForall\u2082.nil\n        \u00b7 exact SublistForall\u2082.cons (_root_.trans hab hbc) (ih _ _ tab tbc)\n        \u00b7 exact SublistForall\u2082.cons_right (ih _ _ atb tbc)\n      \u00b7 exact SublistForall\u2082.cons_right (ih _ _ h1 btc)\u27e9", "start": [353, 1], "end": [368, 57], "kind": "commanddeclaration"}, {"full_name": "List.Sublist.sublistForall\u2082", "code": "theorem Sublist.sublistForall\u2082 {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 <+ l\u2082) [IsRefl \u03b1 R\u2090] :\n    SublistForall\u2082 R\u2090 l\u2081 l\u2082", "start": [371, 1], "end": [373, 48], "kind": "commanddeclaration"}, {"full_name": "List.tail_sublistForall\u2082_self", "code": "theorem tail_sublistForall\u2082_self [IsRefl \u03b1 R\u2090] (l : List \u03b1) : SublistForall\u2082 R\u2090 l.tail l", "start": [376, 1], "end": [377, 32], "kind": "commanddeclaration"}]}
